# range.c

> 自动生成时间: 2025-10-25 15:37:53
> 
> 生成工具: 通义千问 API (qwen3-max)
> 
> 原始文件: `range.c`

---

# range.c 技术文档

## 1. 文件概述

`range.c` 是 Linux 内核中用于管理地址范围（range）集合的核心工具文件。它提供了一组操作函数，用于动态地添加、合并、删除和排序不连续的地址区间（通常表示物理内存或 I/O 地址范围）。这些操作在内存管理、资源分配、NUMA 拓扑构建等场景中被广泛使用，尤其适用于需要维护非重叠、有序地址区间的子系统。

## 2. 核心功能

### 数据结构
- `struct range`：表示一个地址区间，包含 `start`（起始地址）和 `end`（结束地址，不包含）两个 `u64` 字段。

### 主要函数
- `int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)`  
  向范围数组中添加一个新的区间，不进行合并。
- `int add_range_with_merge(struct range *range, int az, int nr_range, u64 start, u64 end)`  
  添加新区间，并自动与已有区间合并重叠或相邻的部分。
- `void subtract_range(struct range *range, int az, u64 start, u64 end)`  
  从现有范围中减去指定区间，可能将一个区间拆分为两个。
- `int clean_sort_range(struct range *range, int az)`  
  清理数组中无效（`end == 0`）的条目，压缩有效区间到数组前端，并按起始地址排序，返回有效区间数量。
- `void sort_range(struct range *range, int nr_range)`  
  对指定数量的区间按起始地址进行排序。

## 3. 关键实现

### 区间合并逻辑（`add_range_with_merge`）
1. 首先检查输入区间是否有效（`start < end`）。
2. 遍历现有所有有效区间，查找与新区间有交集的部分：
   - 若存在交集，则扩展新区间的 `start` 和 `end` 以覆盖合并后的范围。
   - 将被合并的旧区间从数组中移除（通过 `memmove` 前移后续元素，并将末尾置零）。
   - 由于移除了元素，需将索引 `i` 减 1 以重新检查当前位置。
3. 最终将合并后的新区间通过 `add_range` 添加到数组末尾。

### 区间相减逻辑（`subtract_range`）
处理四种相交情况：
1. **完全覆盖**：待减区间完全包含目标区间 → 将目标区间置为无效（`start = end = 0`）。
2. **左覆盖**：待减区间覆盖目标区间的左部 → 将目标区间起始地址更新为 `end`。
3. **右覆盖**：待减区间覆盖目标区间的右部 → 将目标区间结束地址更新为 `start`。
4. **中间挖洞**：待减区间位于目标区间内部 → 将原区间拆分为两段：
   - 原区间保留左段（`[start, subtract_start)`）。
   - 在数组中寻找空闲槽位（`end == 0`），插入右段（`[subtract_end, original_end)`）。
   - 若无空闲槽位，打印错误日志。

### 数组清理与排序（`clean_sort_range`）
- 采用双指针法：从前往后找无效项，从后往前找有效项，进行交换，将所有有效区间压缩到数组前端。
- 遍历压缩后的数组，统计有效区间数量（首个 `end == 0` 的位置）。
- 使用内核 `sort()` 函数按 `start` 升序排列有效区间。

## 4. 依赖关系

- **头文件依赖**：
  - `<linux/range.h>`：定义 `struct range`。
  - `<linux/sort.h>`：提供 `sort()` 排序函数。
  - `<linux/minmax.h>`：提供 `min()`/`max()` 宏。
  - `<linux/printk.h>`：用于错误日志输出。
  - `<linux/string.h>`：提供 `memmove()`。
  - `<linux/init.h>`：可能用于初始化上下文（尽管本文件未直接使用初始化宏）。
- **无外部模块依赖**：该文件为通用工具库，被多个内核子系统（如 `e820`、`memblock`、`ACPI`、`NUMA` 初始化等）直接调用。

## 5. 使用场景

- **物理内存布局管理**：在启动早期，通过 `e820` 或 `EFI` 获取物理内存范围后，使用 `add_range_with_merge` 合并连续内存块。
- **内存热插拔/热移除**：动态调整可用内存范围时，使用 `subtract_range` 移除故障或离线内存区域。
- **I/O 资源分配**：管理 PCI 或平台设备的 I/O 地址空间，避免冲突。
- **NUMA 节点拓扑构建**：在解析 SRAT 表时，合并属于同一节点的内存范围。
- **内核参数处理**：如 `mem=` 或 `memmap=` 参数指定的内存保留/排除区域，需与系统内存范围进行加减运算。
- **资源冲突检测**：在设备枚举过程中，通过区间运算判断资源是否重叠。