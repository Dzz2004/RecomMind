# livepatch\shadow.c

> 自动生成时间: 2025-10-25 14:33:15
> 
> 生成工具: 通义千问 API (qwen3-max)
> 
> 原始文件: `livepatch\shadow.c`

---

# livepatch/shadow.c 技术文档

## 1. 文件概述

`shadow.c` 实现了内核实时补丁（Livepatch）子系统中的**影子变量（Shadow Variables）**机制。该机制允许为任意内核对象（通过指针标识）关联额外的私有数据，而无需修改原始对象的结构定义。影子变量通过 `<obj, id>` 键值对进行唯一标识，支持并发安全的创建、查询和销毁操作，主要用于在热补丁过程中为旧版本对象附加新版本所需的状态或元数据。

## 2. 核心功能

### 数据结构
- **`struct klp_shadow`**：影子变量的核心结构
  - `node`：哈希表节点，用于链接到全局哈希表
  - `rcu_head`：RCU 回调结构，用于安全释放内存
  - `obj`：指向父对象的指针
  - `id`：数据标识符（与 obj 共同构成唯一键）
  - `data[]`：柔性数组，存储实际的影子数据

### 主要函数
- **`klp_shadow_get()`**：根据 `<obj, id>` 查询影子变量数据指针
- **`klp_shadow_alloc()`**：分配并注册新的影子变量（若已存在则返回 NULL 并警告）
- **`klp_shadow_get_or_alloc()`**：获取现有影子变量或分配新变量
- **`klp_shadow_free()`**：释放指定的影子变量并调用析构函数

### 辅助函数
- **`klp_shadow_match()`**：验证影子变量是否匹配给定的 `<obj, id>`
- **`__klp_shadow_get_or_alloc()`**：内部实现函数，支持重复分配策略控制
- **`klp_shadow_free_struct()`**：内部释放函数，执行哈希删除和 RCU 释放

## 3. 关键实现

### 并发控制机制
- **RCU 读路径**：`klp_shadow_get()` 使用 `rcu_read_lock()` 保护哈希表遍历，允许无锁并发读取
- **自旋锁写路径**：`klp_shadow_lock` 保护所有写操作（分配/释放），确保哈希表修改的原子性
- **双重检查模式**：在分配新变量时先无锁检查存在性，再在锁保护下二次验证，避免竞争条件

### 内存管理
- **柔性数组设计**：`data[]` 直接附加在结构体末尾，避免二次内存分配
- **RCU 安全释放**：通过 `kfree_rcu()` 延迟释放内存，确保读路径安全
- **构造/析构回调**：
  - `klp_shadow_ctor_t`：在分配时初始化数据（原子上下文执行）
  - `klp_shadow_dtor_t`：在释放前清理资源

### 哈希表实现
- 使用内核通用哈希表（`DEFINE_HASHTABLE`），桶数为 4096（2^12）
- 哈希键为 `(unsigned long)obj`，通过 `hash_for_each_possible()` 快速定位桶
- RCU 安全操作：`hash_add_rcu()` / `hash_del_rcu()` 保证并发一致性

## 4. 依赖关系

- **头文件依赖**：
  - `<linux/hashtable.h>`：提供哈希表实现
  - `<linux/slab.h>`：提供内存分配接口（kzalloc/kfree）
  - `<linux/livepatch.h>`：定义 Livepatch 相关类型和 API
- **内核子系统**：
  - **RCU 子系统**：用于无锁读取和安全内存释放
  - **内存管理子系统**：通过 GFP 标志控制分配行为
  - **Livepatch 核心框架**：作为补丁运行时状态管理的基础组件

## 5. 使用场景

1. **热补丁状态迁移**  
   在函数替换过程中，为旧版本对象附加新版本所需的运行时状态（如数据结构转换缓冲区）。

2. **跨版本数据兼容**  
   当补丁修改了对象结构体时，通过影子变量存储新字段，避免直接修改原始对象布局。

3. **动态元数据附加**  
   为无法修改定义的内核对象（如第三方模块对象）动态关联调试或监控数据。

4. **原子性状态更新**  
   利用构造函数在锁保护下初始化复杂状态，确保多线程环境下的数据一致性。

> **典型调用模式**：  
> 补丁模块在 `pre_patch()` 阶段调用 `klp_shadow_alloc()` 为关键对象分配影子数据，在 `post_unpatch()` 阶段通过 `klp_shadow_free()` 清理资源，运行时通过 `klp_shadow_get()` 访问附加状态。