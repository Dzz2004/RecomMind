{
  "query": "hi",
  "timestamp": "2025-11-08 17:41:43",
  "retrieved_files": [
    {
      "source_file": "kernel/trace/trace_events_hist.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:19:59\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_events_hist.c`\n\n---\n\n# `trace/trace_events_hist.c` 技术文档\n\n## 1. 文件概述\n\n`trace_events_hist.c` 是 Linux 内核中用于实现 **直方图（histogram）触发器（hist triggers）** 的核心模块，属于动态追踪（ftrace）子系统的一部分。该文件提供了基于事件字段的直方图统计、变量定义、表达式计算、条件动作（如 `onmax()`、`save()`）以及合成事件（synthetic events）支持等功能。用户可通过 `tracefs` 接口配置复杂的事件聚合与分析逻辑，用于性能分析、调试和监控。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`enum field_op_id`**  \n  定义表达式中支持的算术操作符（如加、减、乘、除、一元负号等）。\n\n- **`enum hist_field_fn`**  \n  枚举所有支持的字段处理函数类型，包括常量、计数器、时间戳、CPU ID、各种整型字段、字符串、动态字符串、变量引用、表达式运算等。\n\n- **`struct hist_var`**  \n  表示直方图中的变量（如 `ts0 = common_timestamp`），包含变量名、所属直方图数据结构及在 `tracing_map` 中的唯一索引。\n\n- **`struct hist_field`**  \n  核心数据结构，表示直方图中的一个字段（key 或 value），可为原始事件字段、变量、常量或复杂表达式。支持嵌套操作数（最多两个）、变量引用、字符串处理、数值类型信息等。\n\n- **错误码枚举（`HIST_ERR_*`）**  \n  定义了丰富的错误类型（如变量重复、字段未找到、表达式语法错误等），用于解析和验证用户输入的触发器命令。\n\n### 主要函数\n\n- **`hist_fn_call()`**  \n  通用字段值获取入口，根据 `hist_field->fn_num` 调用对应的具体处理函数。\n\n- **`hist_field_const()`**  \n  返回字段中存储的常量值（`field->constant`）。\n\n- **`hist_field_counter()`**  \n  返回固定值 `1`，用于实现事件计数（hitcount）。\n\n- **`hist_field_string()` / `hist_field_dynstring()`**  \n  分别处理静态字符串字段和动态分配的字符串字段（如 `__string` 类型），返回字符串在事件记录中的地址。\n\n- **各类类型专用函数（如 `hist_field_u64`, `hist_field_s32` 等）**  \n  从事件记录中提取对应类型和偏移的字段值。\n\n## 3. 关键实现\n\n### 直方图字段模型\n- 每个 `hist_field` 可表示原始事件字段、用户定义变量、常量或由操作符组合的表达式。\n- 表达式支持最多两级嵌套（`HIST_FIELD_OPERANDS_MAX = 2`），通过 `operands[]` 构建 AST。\n- 数值类型字段通过 `is_signed` 和 `size` 字段区分有无符号及宽度，确保正确提取。\n\n### 变量机制\n- 用户可通过 `varname=field` 语法定义变量，存储在 `hist_var` 中。\n- 变量在 `tracing_map` 中分配唯一索引（`idx`），读写通过该索引进行。\n- 支持跨事件引用变量（需使用 `subsys.event.var` 全限定名），解决命名冲突。\n\n### 表达式优化\n- 对除法运算进行优化：若除数为常数，预计算 `div_multiplier` 和移位参数（`HIST_DIV_SHIFT = 20`），将除法转换为乘法+移位，提升运行时性能。\n- 支持 `log2()`、`bucket()` 等聚合函数，用于数据分组。\n\n### 字符串处理\n- 支持多种字符串类型：普通字符串（`string`）、动态字符串（`__string`）、相对动态字符串（`rel_dynamic`）、指针字符串（`pstring`）及 `execname`。\n- 字符串字段在直方图中以指针形式存储，实际内容保存在 ring buffer 中。\n\n### 错误处理\n- 使用宏 `ERRORS` 统一定义错误码和描述文本，便于维护和国际化。\n- 在解析用户命令（如写入 `trigger` 文件）时进行严格语法和语义检查，返回精确错误信息。\n\n## 4. 依赖关系\n\n- **`tracing_map.h`**：提供底层哈希表实现，用于存储直方图条目（key-value 对）及变量。\n- **`trace_synth.h`**：支持合成事件（synthetic events）的创建与触发。\n- **`trace_events.h` / `mmflags.h`**：提供事件字段定义及内存标志等辅助信息。\n- **`tracefs.h`**：通过 tracefs 文件系统暴露用户接口（如 `events/.../trigger`）。\n- **`ring_buffer.h` / `trace_buffer.h`**：访问原始事件数据。\n- **`ftrace_event.h`**：依赖 ftrace 事件基础设施，获取字段元数据。\n\n## 5. 使用场景\n\n- **性能分析**：统计特定事件（如系统调用、中断、调度事件）的发生频率、延迟分布（如 `common_timestamp` 差值）。\n- **条件监控**：使用 `onmax(var).save(...)` 在某变量达到最大值时保存上下文。\n- **数据聚合**：按多个字段（如 PID + 函数名）分组统计，生成多维直方图。\n- **合成事件生成**：基于多个原始事件的变量组合，触发自定义合成事件，用于复杂场景建模。\n- **调试辅助**：在特定条件满足时（如计数器超过阈值）输出堆栈或关键变量值。\n\n该模块是内核动态追踪能力的重要扩展，为用户空间工具（如 `perf`, `trace-cmd`）提供强大的后端支持。",
      "similarity": 0.48252183198928833,
      "chunks": [
        {
          "chunk_id": 33,
          "file_path": "kernel/trace/trace_events_hist.c",
          "start_line": 6499,
          "end_line": 6612,
          "content": [
            "static int hist_register_trigger(char *glob,",
            "\t\t\t\t struct event_trigger_data *data,",
            "\t\t\t\t struct trace_event_file *file)",
            "{",
            "\tstruct hist_trigger_data *hist_data = data->private_data;",
            "\tstruct event_trigger_data *test, *named_data = NULL;",
            "\tstruct trace_array *tr = file->tr;",
            "\tint ret = 0;",
            "",
            "\tif (hist_data->attrs->name) {",
            "\t\tnamed_data = find_named_trigger(hist_data->attrs->name);",
            "\t\tif (named_data) {",
            "\t\t\tif (!hist_trigger_match(data, named_data, named_data,",
            "\t\t\t\t\t\ttrue)) {",
            "\t\t\t\thist_err(tr, HIST_ERR_NAMED_MISMATCH, errpos(hist_data->attrs->name));",
            "\t\t\t\tret = -EINVAL;",
            "\t\t\t\tgoto out;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tif (hist_data->attrs->name && !named_data)",
            "\t\tgoto new;",
            "",
            "\tlockdep_assert_held(&event_mutex);",
            "",
            "\tlist_for_each_entry(test, &file->triggers, list) {",
            "\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {",
            "\t\t\tif (hist_trigger_match(data, test, named_data, false)) {",
            "\t\t\t\thist_err(tr, HIST_ERR_TRIGGER_EEXIST, 0);",
            "\t\t\t\tret = -EEXIST;",
            "\t\t\t\tgoto out;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            " new:",
            "\tif (hist_data->attrs->cont || hist_data->attrs->clear) {",
            "\t\thist_err(tr, HIST_ERR_TRIGGER_ENOENT_CLEAR, 0);",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (hist_data->attrs->pause)",
            "\t\tdata->paused = true;",
            "",
            "\tif (named_data) {",
            "\t\tdata->private_data = named_data->private_data;",
            "\t\tset_named_trigger_data(data, named_data);",
            "\t\tdata->ops = &event_hist_trigger_named_ops;",
            "\t}",
            "",
            "\tif (data->ops->init) {",
            "\t\tret = data->ops->init(data);",
            "\t\tif (ret < 0)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tif (hist_data->enable_timestamps) {",
            "\t\tchar *clock = hist_data->attrs->clock;",
            "",
            "\t\tret = tracing_set_clock(file->tr, hist_data->attrs->clock);",
            "\t\tif (ret) {",
            "\t\t\thist_err(tr, HIST_ERR_SET_CLOCK_FAIL, errpos(clock));",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\ttracing_set_filter_buffering(file->tr, true);",
            "\t}",
            "",
            "\tif (named_data)",
            "\t\tdestroy_hist_data(hist_data);",
            " out:",
            "\treturn ret;",
            "}",
            "static int hist_trigger_enable(struct event_trigger_data *data,",
            "\t\t\t       struct trace_event_file *file)",
            "{",
            "\tint ret = 0;",
            "",
            "\tlist_add_tail_rcu(&data->list, &file->triggers);",
            "",
            "\tupdate_cond_flag(file);",
            "",
            "\tif (trace_event_trigger_enable_disable(file, 1) < 0) {",
            "\t\tlist_del_rcu(&data->list);",
            "\t\tupdate_cond_flag(file);",
            "\t\tret--;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static bool have_hist_trigger_match(struct event_trigger_data *data,",
            "\t\t\t\t    struct trace_event_file *file)",
            "{",
            "\tstruct hist_trigger_data *hist_data = data->private_data;",
            "\tstruct event_trigger_data *test, *named_data = NULL;",
            "\tbool match = false;",
            "",
            "\tlockdep_assert_held(&event_mutex);",
            "",
            "\tif (hist_data->attrs->name)",
            "\t\tnamed_data = find_named_trigger(hist_data->attrs->name);",
            "",
            "\tlist_for_each_entry(test, &file->triggers, list) {",
            "\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {",
            "\t\t\tif (hist_trigger_match(data, test, named_data, false)) {",
            "\t\t\t\tmatch = true;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn match;",
            "}"
          ],
          "function_name": "hist_register_trigger, hist_trigger_enable, have_hist_trigger_match",
          "description": "该代码段实现了历史触发器（hist trigger）的注册、启用及匹配检测逻辑。  \n`hist_register_trigger` 注册新触发器并校验命名冲突及重复触发器，初始化触发器属性并关联操作函数；`hist_trigger_enable` 将触发器添加至文件触发器链表并尝试启用；`have_hist_trigger_match` 检查当前触发器是否与已有触发器匹配。",
          "similarity": 0.46116718649864197
        },
        {
          "chunk_id": 17,
          "file_path": "kernel/trace/trace_events_hist.c",
          "start_line": 4274,
          "end_line": 4382,
          "content": [
            "static int create_val_field(struct hist_trigger_data *hist_data,",
            "\t\t\t    unsigned int val_idx,",
            "\t\t\t    struct trace_event_file *file,",
            "\t\t\t    char *field_str)",
            "{",
            "\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);",
            "}",
            "static u64 hist_field_execname(struct hist_field *hist_field,",
            "\t\t\t       struct tracing_map_elt *elt,",
            "\t\t\t       struct trace_buffer *buffer,",
            "\t\t\t       struct ring_buffer_event *rbe,",
            "\t\t\t       void *event)",
            "{",
            "\tstruct hist_elt_data *elt_data;",
            "",
            "\tif (WARN_ON_ONCE(!elt))",
            "\t\treturn (u64)(unsigned long)no_comm;",
            "",
            "\telt_data = elt->private_data;",
            "",
            "\tif (WARN_ON_ONCE(!elt_data->comm))",
            "\t\treturn (u64)(unsigned long)no_comm;",
            "",
            "\treturn (u64)(unsigned long)(elt_data->comm);",
            "}",
            "static u64 hist_field_stack(struct hist_field *hist_field,",
            "\t\t\t    struct tracing_map_elt *elt,",
            "\t\t\t    struct trace_buffer *buffer,",
            "\t\t\t    struct ring_buffer_event *rbe,",
            "\t\t\t    void *event)",
            "{",
            "\tu32 str_item = *(u32 *)(event + hist_field->field->offset);",
            "\tint str_loc = str_item & 0xffff;",
            "\tchar *addr = (char *)(event + str_loc);",
            "",
            "\treturn (u64)(unsigned long)addr;",
            "}",
            "static u64 hist_fn_call(struct hist_field *hist_field,",
            "\t\t\tstruct tracing_map_elt *elt,",
            "\t\t\tstruct trace_buffer *buffer,",
            "\t\t\tstruct ring_buffer_event *rbe,",
            "\t\t\tvoid *event)",
            "{",
            "\tswitch (hist_field->fn_num) {",
            "\tcase HIST_FIELD_FN_VAR_REF:",
            "\t\treturn hist_field_var_ref(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_COUNTER:",
            "\t\treturn hist_field_counter(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_CONST:",
            "\t\treturn hist_field_const(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_LOG2:",
            "\t\treturn hist_field_log2(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_BUCKET:",
            "\t\treturn hist_field_bucket(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_TIMESTAMP:",
            "\t\treturn hist_field_timestamp(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_CPU:",
            "\t\treturn hist_field_cpu(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_STRING:",
            "\t\treturn hist_field_string(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_DYNSTRING:",
            "\t\treturn hist_field_dynstring(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_RELDYNSTRING:",
            "\t\treturn hist_field_reldynstring(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_PSTRING:",
            "\t\treturn hist_field_pstring(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_S64:",
            "\t\treturn hist_field_s64(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_U64:",
            "\t\treturn hist_field_u64(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_S32:",
            "\t\treturn hist_field_s32(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_U32:",
            "\t\treturn hist_field_u32(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_S16:",
            "\t\treturn hist_field_s16(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_U16:",
            "\t\treturn hist_field_u16(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_S8:",
            "\t\treturn hist_field_s8(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_U8:",
            "\t\treturn hist_field_u8(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_UMINUS:",
            "\t\treturn hist_field_unary_minus(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_MINUS:",
            "\t\treturn hist_field_minus(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_PLUS:",
            "\t\treturn hist_field_plus(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_DIV:",
            "\t\treturn hist_field_div(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_MULT:",
            "\t\treturn hist_field_mult(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_DIV_POWER2:",
            "\t\treturn div_by_power_of_two(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_DIV_NOT_POWER2:",
            "\t\treturn div_by_not_power_of_two(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_DIV_MULT_SHIFT:",
            "\t\treturn div_by_mult_and_shift(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_EXECNAME:",
            "\t\treturn hist_field_execname(hist_field, elt, buffer, rbe, event);",
            "\tcase HIST_FIELD_FN_STACK:",
            "\t\treturn hist_field_stack(hist_field, elt, buffer, rbe, event);",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "function_name": "create_val_field, hist_field_execname, hist_field_stack, hist_fn_call",
          "description": "该代码段实现了跟踪事件处理中的字段解析逻辑，核心功能是通过多种函数处理不同类型的字段值提取。`create_val_field`用于创建值字段的辅助函数，`hist_field_execname`和`hist_field_stack`分别提取进程名和堆栈地址，`hist_fn_call`作为多路复用器根据字段类型调用对应处理函数。代码上下文完整，未引入额外API。",
          "similarity": 0.4594835042953491
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_events_hist.c",
          "start_line": 1,
          "end_line": 208,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace_events_hist - trace event hist triggers",
            " *",
            " * Copyright (C) 2015 Tom Zanussi <tom.zanussi@linux.intel.com>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/tracefs.h>",
            "",
            "/* for gfp flag names */",
            "#include <linux/trace_events.h>",
            "#include <trace/events/mmflags.h>",
            "",
            "#include \"tracing_map.h\"",
            "#include \"trace_synth.h\"",
            "",
            "#define ERRORS\t\t\t\t\t\t\t\t\\",
            "\tC(NONE,\t\t\t\"No error\"),\t\t\t\t\\",
            "\tC(DUPLICATE_VAR,\t\"Variable already defined\"),\t\t\\",
            "\tC(VAR_NOT_UNIQUE,\t\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable\"), \\",
            "\tC(TOO_MANY_VARS,\t\"Too many variables defined\"),\t\t\\",
            "\tC(MALFORMED_ASSIGNMENT,\t\"Malformed assignment\"),\t\t\\",
            "\tC(NAMED_MISMATCH,\t\"Named hist trigger doesn't match existing named trigger (includes variables)\"), \\",
            "\tC(TRIGGER_EEXIST,\t\"Hist trigger already exists\"),\t\t\\",
            "\tC(TRIGGER_ENOENT_CLEAR,\t\"Can't clear or continue a nonexistent hist trigger\"), \\",
            "\tC(SET_CLOCK_FAIL,\t\"Couldn't set trace_clock\"),\t\t\\",
            "\tC(BAD_FIELD_MODIFIER,\t\"Invalid field modifier\"),\t\t\\",
            "\tC(TOO_MANY_SUBEXPR,\t\"Too many subexpressions (3 max)\"),\t\\",
            "\tC(TIMESTAMP_MISMATCH,\t\"Timestamp units in expression don't match\"), \\",
            "\tC(TOO_MANY_FIELD_VARS,\t\"Too many field variables defined\"),\t\\",
            "\tC(EVENT_FILE_NOT_FOUND,\t\"Event file not found\"),\t\t\\",
            "\tC(HIST_NOT_FOUND,\t\"Matching event histogram not found\"),\t\\",
            "\tC(HIST_CREATE_FAIL,\t\"Couldn't create histogram for field\"),\t\\",
            "\tC(SYNTH_VAR_NOT_FOUND,\t\"Couldn't find synthetic variable\"),\t\\",
            "\tC(SYNTH_EVENT_NOT_FOUND,\"Couldn't find synthetic event\"),\t\\",
            "\tC(SYNTH_TYPE_MISMATCH,\t\"Param type doesn't match synthetic event field type\"), \\",
            "\tC(SYNTH_COUNT_MISMATCH,\t\"Param count doesn't match synthetic event field count\"), \\",
            "\tC(FIELD_VAR_PARSE_FAIL,\t\"Couldn't parse field variable\"),\t\\",
            "\tC(VAR_CREATE_FIND_FAIL,\t\"Couldn't create or find variable\"),\t\\",
            "\tC(ONX_NOT_VAR,\t\t\"For onmax(x) or onchange(x), x must be a variable\"), \\",
            "\tC(ONX_VAR_NOT_FOUND,\t\"Couldn't find onmax or onchange variable\"), \\",
            "\tC(ONX_VAR_CREATE_FAIL,\t\"Couldn't create onmax or onchange variable\"), \\",
            "\tC(FIELD_VAR_CREATE_FAIL,\"Couldn't create field variable\"),\t\\",
            "\tC(TOO_MANY_PARAMS,\t\"Too many action params\"),\t\t\\",
            "\tC(PARAM_NOT_FOUND,\t\"Couldn't find param\"),\t\t\t\\",
            "\tC(INVALID_PARAM,\t\"Invalid action param\"),\t\t\\",
            "\tC(ACTION_NOT_FOUND,\t\"No action found\"),\t\t\t\\",
            "\tC(NO_SAVE_PARAMS,\t\"No params found for save()\"),\t\t\\",
            "\tC(TOO_MANY_SAVE_ACTIONS,\"Can't have more than one save() action per hist\"), \\",
            "\tC(ACTION_MISMATCH,\t\"Handler doesn't support action\"),\t\\",
            "\tC(NO_CLOSING_PAREN,\t\"No closing paren found\"),\t\t\\",
            "\tC(SUBSYS_NOT_FOUND,\t\"Missing subsystem\"),\t\t\t\\",
            "\tC(INVALID_SUBSYS_EVENT,\t\"Invalid subsystem or event name\"),\t\\",
            "\tC(INVALID_REF_KEY,\t\"Using variable references in keys not supported\"), \\",
            "\tC(VAR_NOT_FOUND,\t\"Couldn't find variable\"),\t\t\\",
            "\tC(FIELD_NOT_FOUND,\t\"Couldn't find field\"),\t\t\t\\",
            "\tC(EMPTY_ASSIGNMENT,\t\"Empty assignment\"),\t\t\t\\",
            "\tC(INVALID_SORT_MODIFIER,\"Invalid sort modifier\"),\t\t\\",
            "\tC(EMPTY_SORT_FIELD,\t\"Empty sort field\"),\t\t\t\\",
            "\tC(TOO_MANY_SORT_FIELDS,\t\"Too many sort fields (Max = 2)\"),\t\\",
            "\tC(INVALID_SORT_FIELD,\t\"Sort field must be a key or a val\"),\t\\",
            "\tC(INVALID_STR_OPERAND,\t\"String type can not be an operand in expression\"), \\",
            "\tC(EXPECT_NUMBER,\t\"Expecting numeric literal\"),\t\t\\",
            "\tC(UNARY_MINUS_SUBEXPR,\t\"Unary minus not supported in sub-expressions\"), \\",
            "\tC(DIVISION_BY_ZERO,\t\"Division by zero\"),\t\t\t\\",
            "\tC(NEED_NOHC_VAL,\t\"Non-hitcount value is required for 'nohitcount'\"),",
            "",
            "#undef C",
            "#define C(a, b)\t\tHIST_ERR_##a",
            "",
            "enum { ERRORS };",
            "",
            "#undef C",
            "#define C(a, b)\t\tb",
            "",
            "static const char *err_text[] = { ERRORS };",
            "",
            "struct hist_field;",
            "",
            "typedef u64 (*hist_field_fn_t) (struct hist_field *field,",
            "\t\t\t\tstruct tracing_map_elt *elt,",
            "\t\t\t\tstruct trace_buffer *buffer,",
            "\t\t\t\tstruct ring_buffer_event *rbe,",
            "\t\t\t\tvoid *event);",
            "",
            "#define HIST_FIELD_OPERANDS_MAX\t2",
            "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)",
            "#define HIST_ACTIONS_MAX\t8",
            "#define HIST_CONST_DIGITS_MAX\t21",
            "#define HIST_DIV_SHIFT\t\t20  /* For optimizing division by constants */",
            "",
            "enum field_op_id {",
            "\tFIELD_OP_NONE,",
            "\tFIELD_OP_PLUS,",
            "\tFIELD_OP_MINUS,",
            "\tFIELD_OP_UNARY_MINUS,",
            "\tFIELD_OP_DIV,",
            "\tFIELD_OP_MULT,",
            "};",
            "",
            "enum hist_field_fn {",
            "\tHIST_FIELD_FN_NOP,",
            "\tHIST_FIELD_FN_VAR_REF,",
            "\tHIST_FIELD_FN_COUNTER,",
            "\tHIST_FIELD_FN_CONST,",
            "\tHIST_FIELD_FN_LOG2,",
            "\tHIST_FIELD_FN_BUCKET,",
            "\tHIST_FIELD_FN_TIMESTAMP,",
            "\tHIST_FIELD_FN_CPU,",
            "\tHIST_FIELD_FN_STRING,",
            "\tHIST_FIELD_FN_DYNSTRING,",
            "\tHIST_FIELD_FN_RELDYNSTRING,",
            "\tHIST_FIELD_FN_PSTRING,",
            "\tHIST_FIELD_FN_S64,",
            "\tHIST_FIELD_FN_U64,",
            "\tHIST_FIELD_FN_S32,",
            "\tHIST_FIELD_FN_U32,",
            "\tHIST_FIELD_FN_S16,",
            "\tHIST_FIELD_FN_U16,",
            "\tHIST_FIELD_FN_S8,",
            "\tHIST_FIELD_FN_U8,",
            "\tHIST_FIELD_FN_UMINUS,",
            "\tHIST_FIELD_FN_MINUS,",
            "\tHIST_FIELD_FN_PLUS,",
            "\tHIST_FIELD_FN_DIV,",
            "\tHIST_FIELD_FN_MULT,",
            "\tHIST_FIELD_FN_DIV_POWER2,",
            "\tHIST_FIELD_FN_DIV_NOT_POWER2,",
            "\tHIST_FIELD_FN_DIV_MULT_SHIFT,",
            "\tHIST_FIELD_FN_EXECNAME,",
            "\tHIST_FIELD_FN_STACK,",
            "};",
            "",
            "/*",
            " * A hist_var (histogram variable) contains variable information for",
            " * hist_fields having the HIST_FIELD_FL_VAR or HIST_FIELD_FL_VAR_REF",
            " * flag set.  A hist_var has a variable name e.g. ts0, and is",
            " * associated with a given histogram trigger, as specified by",
            " * hist_data.  The hist_var idx is the unique index assigned to the",
            " * variable by the hist trigger's tracing_map.  The idx is what is",
            " * used to set a variable's value and, by a variable reference, to",
            " * retrieve it.",
            " */",
            "struct hist_var {",
            "\tchar\t\t\t\t*name;",
            "\tstruct hist_trigger_data\t*hist_data;",
            "\tunsigned int\t\t\tidx;",
            "};",
            "",
            "struct hist_field {",
            "\tstruct ftrace_event_field\t*field;",
            "\tunsigned long\t\t\tflags;",
            "\tunsigned long\t\t\tbuckets;",
            "\tconst char\t\t\t*type;",
            "\tstruct hist_field\t\t*operands[HIST_FIELD_OPERANDS_MAX];",
            "\tstruct hist_trigger_data\t*hist_data;",
            "\tenum hist_field_fn\t\tfn_num;",
            "\tunsigned int\t\t\tref;",
            "\tunsigned int\t\t\tsize;",
            "\tunsigned int\t\t\toffset;",
            "\tunsigned int                    is_signed;",
            "",
            "\t/*",
            "\t * Variable fields contain variable-specific info in var.",
            "\t */",
            "\tstruct hist_var\t\t\tvar;",
            "\tenum field_op_id\t\toperator;",
            "\tchar\t\t\t\t*system;",
            "\tchar\t\t\t\t*event_name;",
            "",
            "\t/*",
            "\t * The name field is used for EXPR and VAR_REF fields.  VAR",
            "\t * fields contain the variable name in var.name.",
            "\t */",
            "\tchar\t\t\t\t*name;",
            "",
            "\t/*",
            "\t * When a histogram trigger is hit, if it has any references",
            "\t * to variables, the values of those variables are collected",
            "\t * into a var_ref_vals array by resolve_var_refs().  The",
            "\t * current value of each variable is read from the tracing_map",
            "\t * using the hist field's hist_var.idx and entered into the",
            "\t * var_ref_idx entry i.e. var_ref_vals[var_ref_idx].",
            "\t */",
            "\tunsigned int\t\t\tvar_ref_idx;",
            "\tbool                            read_once;",
            "",
            "\tunsigned int\t\t\tvar_str_idx;",
            "",
            "\t/* Numeric literals are represented as u64 */",
            "\tu64\t\t\t\tconstant;",
            "\t/* Used to optimize division by constants */",
            "\tu64\t\t\t\tdiv_multiplier;",
            "};",
            "",
            "static u64 hist_fn_call(struct hist_field *hist_field,",
            "\t\t\tstruct tracing_map_elt *elt,",
            "\t\t\tstruct trace_buffer *buffer,",
            "\t\t\tstruct ring_buffer_event *rbe,",
            "\t\t\tvoid *event);",
            ""
          ],
          "function_name": null,
          "description": "定义错误码枚举和错误消息字符串数组，声明hist_field结构体及函数指针类型，用于跟踪事件的字段处理和错误信息管理。",
          "similarity": 0.45198696851730347
        }
      ]
    },
    {
      "source_file": "kernel/trace/tracing_map.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:40:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\tracing_map.c`\n\n---\n\n# `trace/tracing_map.c` 技术文档\n\n## 1. 文件概述\n\n`tracing_map.c` 实现了一个**无锁（lock-free）的哈希映射结构**，专为 Linux 内核的追踪（tracing）子系统设计。该结构支持高并发场景下的高效插入、查找和聚合操作，适用于事件统计、直方图构建等实时追踪需求。其实现灵感来源于 Cliff Click 提出的无锁哈希表算法，旨在避免传统锁机制带来的性能瓶颈和死锁风险。\n\n该文件提供了对 `tracing_map` 中元素（`tracing_map_elt`）的字段操作接口，包括**累加求和字段（sum fields）**、**变量字段（var fields）** 以及**键字段（key fields）** 的管理，并支持基于不同数据类型的比较函数，用于后续排序或聚合。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `tracing_map_update_sum()` | 对指定元素的指定 sum 字段原子地累加一个值 |\n| `tracing_map_read_sum()` | 读取指定元素的指定 sum 字段的当前值 |\n| `tracing_map_set_var()` | 设置指定元素的指定 var 字段的值，并标记为“已设置” |\n| `tracing_map_var_set()` | 检查指定 var 字段是否已被设置 |\n| `tracing_map_read_var()` | 读取指定 var 字段的值（不改变其状态） |\n| `tracing_map_read_var_once()` | 读取并**重置**指定 var 字段为“未设置”状态，实现“一次读取”语义 |\n| `tracing_map_add_sum_field()` | 向 tracing_map 添加一个 sum 字段，返回其索引 |\n| `tracing_map_add_var()` | 向 tracing_map 添加一个 var 字段，返回其索引 |\n| `tracing_map_add_key_field()` | 向 tracing_map 注册一个 key 字段及其比较函数和偏移量 |\n| `tracing_map_cmp_num()` | 根据字段大小和符号性，返回对应的数值比较函数指针 |\n\n### 比较函数（Comparison Functions）\n\n- `tracing_map_cmp_string()`：字符串比较（使用 `strcmp`）\n- `tracing_map_cmp_none()`：恒等比较（始终返回 0）\n- `tracing_map_cmp_atomic64()`：用于 sum 字段的原子64位整数比较\n- 通过宏 `DEFINE_TRACING_MAP_CMP_FN` 自动生成的各类整数比较函数：\n  - `tracing_map_cmp_s64/u64/s32/u32/s16/u16/s8/u8`\n\n### 数据结构（定义在 `tracing_map.h` 中）\n\n- `struct tracing_map`：追踪映射的主结构体，包含字段元数据、桶数组等\n- `struct tracing_map_elt`：映射中的单个元素，包含 key、sum 字段数组、var 字段数组及状态标记\n- `tracing_map_cmp_fn_t`：比较函数指针类型\n\n## 3. 关键实现\n\n### 无锁设计基础\n- 虽然本文件主要提供字段操作接口，但其底层 `tracing_map` 结构基于无锁哈希表实现（参考 Cliff Click 算法），确保多 CPU 并发写入时的数据一致性。\n- **sum 字段**使用 `atomic64_t` 类型，通过 `atomic64_add()` 和 `atomic64_read()` 实现线程安全的累加与读取。\n- **var 字段**同样使用 `atomic64_t` 存储值，但额外维护一个 `bool var_set[]` 数组来跟踪变量是否被显式设置，支持“一次读取”语义。\n\n### 字段管理机制\n- **字段索引**：`tracing_map` 在初始化阶段通过 `tracing_map_add_*_field()` 系列函数注册字段，返回的索引用于后续对 `tracing_map_elt` 中对应字段的访问。\n- **sum vs var**：\n  - **sum 字段**：专用于累加统计（如事件计数、总耗时），天然支持并发更新。\n  - **var 字段**：用于存储瞬时值或状态（如最新时间戳、错误码），支持“设置-读取-重置”模式。\n- **key 字段**：仅用于定义复合键的组成部分及其排序规则，不直接存储在 `tracing_map_elt` 的字段数组中，而是作为键的一部分参与哈希和比较。\n\n### 类型安全的比较函数\n- 通过 `tracing_map_cmp_num()` 函数，根据字段的**字节大小（1/2/4/8）** 和**符号性（signed/unsigned）** 动态选择正确的比较函数，确保排序和聚合逻辑的正确性。\n- 所有数值比较函数均通过宏生成，避免重复代码，保证类型转换安全。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/vmalloc.h>`：用于大内存分配（可能用于哈希表桶）\n- `<linux/jhash.h>`：提供 Jenkins 哈希函数（实际哈希逻辑在 `tracing_map.h` 或其他文件中）\n- `<linux/slab.h>`：内核内存分配器（`kmalloc`/`kfree`）\n- `<linux/sort.h>`：提供排序功能（用于结果输出）\n- `<linux/kmemleak.h>`：内存泄漏检测支持\n- `\"tracing_map.h\"`：核心数据结构和 API 声明\n- `\"trace.h\"`：追踪子系统通用头文件\n\n### 内核子系统依赖\n- **Tracing Subsystem**：作为核心追踪基础设施的一部分，被事件触发器（如 `hist` 触发器）、直方图统计等功能使用。\n- **Memory Management**：依赖 SLAB/SLUB 分配器管理 `tracing_map` 和 `tracing_map_elt` 对象。\n- **Atomic Operations**：重度依赖 `atomic64_*` 系列原子操作保证并发安全。\n\n## 5. 使用场景\n\n- **事件聚合统计**：在 `ftrace` 或 `eBPF` 追踪中，对具有相同键（如进程 PID、函数名）的事件进行计数、求和（如总延迟、总字节数）。\n- **直方图构建**：`hist` 触发器使用 `tracing_map` 存储每个桶（bucket）的统计信息，sum 字段记录命中次数。\n- **状态跟踪**：var 字段可用于记录每个键关联的最新状态（如最后一次错误码、最大延迟值），并通过 `read_var_once` 实现状态消费。\n- **高性能追踪**：在高频率事件（如每秒百万级）场景下，无锁设计避免了传统哈希表在锁竞争下的性能下降，适用于实时性要求高的系统分析。",
      "similarity": 0.4589031934738159,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/tracing_map.c",
          "start_line": 270,
          "end_line": 374,
          "content": [
            "int tracing_map_add_key_field(struct tracing_map *map,",
            "\t\t\t      unsigned int offset,",
            "\t\t\t      tracing_map_cmp_fn_t cmp_fn)",
            "",
            "{",
            "\tint idx = tracing_map_add_field(map, cmp_fn);",
            "",
            "\tif (idx < 0)",
            "\t\treturn idx;",
            "",
            "\tmap->fields[idx].offset = offset;",
            "",
            "\tmap->key_idx[map->n_keys++] = idx;",
            "",
            "\treturn idx;",
            "}",
            "static void tracing_map_array_clear(struct tracing_map_array *a)",
            "{",
            "\tunsigned int i;",
            "",
            "\tif (!a->pages)",
            "\t\treturn;",
            "",
            "\tfor (i = 0; i < a->n_pages; i++)",
            "\t\tmemset(a->pages[i], 0, PAGE_SIZE);",
            "}",
            "static void tracing_map_array_free(struct tracing_map_array *a)",
            "{",
            "\tunsigned int i;",
            "",
            "\tif (!a)",
            "\t\treturn;",
            "",
            "\tif (!a->pages)",
            "\t\tgoto free;",
            "",
            "\tfor (i = 0; i < a->n_pages; i++) {",
            "\t\tif (!a->pages[i])",
            "\t\t\tbreak;",
            "\t\tkmemleak_free(a->pages[i]);",
            "\t\tfree_page((unsigned long)a->pages[i]);",
            "\t}",
            "",
            "\tkfree(a->pages);",
            "",
            " free:",
            "\tkfree(a);",
            "}",
            "static void tracing_map_elt_clear(struct tracing_map_elt *elt)",
            "{",
            "\tunsigned i;",
            "",
            "\tfor (i = 0; i < elt->map->n_fields; i++)",
            "\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)",
            "\t\t\tatomic64_set(&elt->fields[i].sum, 0);",
            "",
            "\tfor (i = 0; i < elt->map->n_vars; i++) {",
            "\t\tatomic64_set(&elt->vars[i], 0);",
            "\t\telt->var_set[i] = false;",
            "\t}",
            "",
            "\tif (elt->map->ops && elt->map->ops->elt_clear)",
            "\t\telt->map->ops->elt_clear(elt);",
            "}",
            "static void tracing_map_elt_init_fields(struct tracing_map_elt *elt)",
            "{",
            "\tunsigned int i;",
            "",
            "\ttracing_map_elt_clear(elt);",
            "",
            "\tfor (i = 0; i < elt->map->n_fields; i++) {",
            "\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;",
            "",
            "\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)",
            "\t\t\telt->fields[i].offset = elt->map->fields[i].offset;",
            "\t}",
            "}",
            "static void tracing_map_elt_free(struct tracing_map_elt *elt)",
            "{",
            "\tif (!elt)",
            "\t\treturn;",
            "",
            "\tif (elt->map->ops && elt->map->ops->elt_free)",
            "\t\telt->map->ops->elt_free(elt);",
            "\tkfree(elt->fields);",
            "\tkfree(elt->vars);",
            "\tkfree(elt->var_set);",
            "\tkfree(elt->key);",
            "\tkfree(elt);",
            "}",
            "static void tracing_map_free_elts(struct tracing_map *map)",
            "{",
            "\tunsigned int i;",
            "",
            "\tif (!map->elts)",
            "\t\treturn;",
            "",
            "\tfor (i = 0; i < map->max_elts; i++) {",
            "\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));",
            "\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;",
            "\t}",
            "",
            "\ttracing_map_array_free(map->elts);",
            "\tmap->elts = NULL;",
            "}"
          ],
          "function_name": "tracing_map_add_key_field, tracing_map_array_clear, tracing_map_array_free, tracing_map_elt_clear, tracing_map_elt_init_fields, tracing_map_elt_free, tracing_map_free_elts",
          "description": "实现tracing_map_elt_clear清除元素数据，tracing_map_elt_init_fields初始化字段配置，提供元素内存释放逻辑及映射元素数组清理功能",
          "similarity": 0.417554646730423
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/tracing_map.c",
          "start_line": 39,
          "end_line": 141,
          "content": [
            "void tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)",
            "{",
            "\tatomic64_add(n, &elt->fields[i].sum);",
            "}",
            "u64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)",
            "{",
            "\treturn (u64)atomic64_read(&elt->fields[i].sum);",
            "}",
            "void tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)",
            "{",
            "\tatomic64_set(&elt->vars[i], n);",
            "\telt->var_set[i] = true;",
            "}",
            "bool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)",
            "{",
            "\treturn elt->var_set[i];",
            "}",
            "u64 tracing_map_read_var(struct tracing_map_elt *elt, unsigned int i)",
            "{",
            "\treturn (u64)atomic64_read(&elt->vars[i]);",
            "}",
            "u64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)",
            "{",
            "\telt->var_set[i] = false;",
            "\treturn (u64)atomic64_read(&elt->vars[i]);",
            "}",
            "int tracing_map_cmp_string(void *val_a, void *val_b)",
            "{",
            "\tchar *a = val_a;",
            "\tchar *b = val_b;",
            "",
            "\treturn strcmp(a, b);",
            "}",
            "int tracing_map_cmp_none(void *val_a, void *val_b)",
            "{",
            "\treturn 0;",
            "}",
            "static int tracing_map_cmp_atomic64(void *val_a, void *val_b)",
            "{",
            "\tu64 a = atomic64_read((atomic64_t *)val_a);",
            "\tu64 b = atomic64_read((atomic64_t *)val_b);",
            "",
            "\treturn (a > b) ? 1 : ((a < b) ? -1 : 0);",
            "}",
            "tracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,",
            "\t\t\t\t\t int field_is_signed)",
            "{",
            "\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;",
            "",
            "\tswitch (field_size) {",
            "\tcase 8:",
            "\t\tif (field_is_signed)",
            "\t\t\tfn = tracing_map_cmp_s64;",
            "\t\telse",
            "\t\t\tfn = tracing_map_cmp_u64;",
            "\t\tbreak;",
            "\tcase 4:",
            "\t\tif (field_is_signed)",
            "\t\t\tfn = tracing_map_cmp_s32;",
            "\t\telse",
            "\t\t\tfn = tracing_map_cmp_u32;",
            "\t\tbreak;",
            "\tcase 2:",
            "\t\tif (field_is_signed)",
            "\t\t\tfn = tracing_map_cmp_s16;",
            "\t\telse",
            "\t\t\tfn = tracing_map_cmp_u16;",
            "\t\tbreak;",
            "\tcase 1:",
            "\t\tif (field_is_signed)",
            "\t\t\tfn = tracing_map_cmp_s8;",
            "\t\telse",
            "\t\t\tfn = tracing_map_cmp_u8;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn fn;",
            "}",
            "static int tracing_map_add_field(struct tracing_map *map,",
            "\t\t\t\t tracing_map_cmp_fn_t cmp_fn)",
            "{",
            "\tint ret = -EINVAL;",
            "",
            "\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {",
            "\t\tret = map->n_fields;",
            "\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "int tracing_map_add_sum_field(struct tracing_map *map)",
            "{",
            "\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);",
            "}",
            "int tracing_map_add_var(struct tracing_map *map)",
            "{",
            "\tint ret = -EINVAL;",
            "",
            "\tif (map->n_vars < TRACING_MAP_VARS_MAX)",
            "\t\tret = map->n_vars++;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "tracing_map_update_sum, tracing_map_read_sum, tracing_map_set_var, tracing_map_var_set, tracing_map_read_var, tracing_map_read_var_once, tracing_map_cmp_string, tracing_map_cmp_none, tracing_map_cmp_atomic64, tracing_map_cmp_num, tracing_map_add_field, tracing_map_add_sum_field, tracing_map_add_var",
          "description": "实现tracing_map_update_sum等函数，通过atomic64操作更新sum字段，提供变量设置与读取接口，定义字符串、原子64位数等比较函数及字段添加逻辑",
          "similarity": 0.4133852422237396
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/tracing_map.c",
          "start_line": 886,
          "end_line": 1016,
          "content": [
            "static int cmp_entries_key(const void *A, const void *B)",
            "{",
            "\tconst struct tracing_map_elt *elt_a, *elt_b;",
            "\tconst struct tracing_map_sort_entry *a, *b;",
            "\tstruct tracing_map_sort_key *sort_key;",
            "\tstruct tracing_map_field *field;",
            "\ttracing_map_cmp_fn_t cmp_fn;",
            "\tvoid *val_a, *val_b;",
            "\tint ret = 0;",
            "",
            "\ta = *(const struct tracing_map_sort_entry **)A;",
            "\tb = *(const struct tracing_map_sort_entry **)B;",
            "",
            "\telt_a = a->elt;",
            "\telt_b = b->elt;",
            "",
            "\tsort_key = &elt_a->map->sort_key;",
            "",
            "\tfield = &elt_a->fields[sort_key->field_idx];",
            "",
            "\tcmp_fn = field->cmp_fn;",
            "",
            "\tval_a = elt_a->key + field->offset;",
            "\tval_b = elt_b->key + field->offset;",
            "",
            "\tret = cmp_fn(val_a, val_b);",
            "\tif (sort_key->descending)",
            "\t\tret = -ret;",
            "",
            "\treturn ret;",
            "}",
            "static void destroy_sort_entry(struct tracing_map_sort_entry *entry)",
            "{",
            "\tif (!entry)",
            "\t\treturn;",
            "",
            "\tif (entry->elt_copied)",
            "\t\ttracing_map_elt_free(entry->elt);",
            "",
            "\tkfree(entry);",
            "}",
            "void tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,",
            "\t\t\t\t      unsigned int n_entries)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < n_entries; i++)",
            "\t\tdestroy_sort_entry(entries[i]);",
            "",
            "\tvfree(entries);",
            "}",
            "static void detect_dups(struct tracing_map_sort_entry **sort_entries,",
            "\t\t      int n_entries, unsigned int key_size)",
            "{",
            "\tunsigned int total_dups = 0;",
            "\tint i;",
            "\tvoid *key;",
            "",
            "\tif (n_entries < 2)",
            "\t\treturn;",
            "",
            "\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),",
            "\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);",
            "",
            "\tkey = sort_entries[0]->key;",
            "\tfor (i = 1; i < n_entries; i++) {",
            "\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {",
            "\t\t\ttotal_dups++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tkey = sort_entries[i]->key;",
            "\t}",
            "",
            "\tWARN_ONCE(total_dups > 0,",
            "\t\t  \"Duplicates detected: %d\\n\", total_dups);",
            "}",
            "static bool is_key(struct tracing_map *map, unsigned int field_idx)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < map->n_keys; i++)",
            "\t\tif (map->key_idx[i] == field_idx)",
            "\t\t\treturn true;",
            "\treturn false;",
            "}",
            "static void sort_secondary(struct tracing_map *map,",
            "\t\t\t   const struct tracing_map_sort_entry **entries,",
            "\t\t\t   unsigned int n_entries,",
            "\t\t\t   struct tracing_map_sort_key *primary_key,",
            "\t\t\t   struct tracing_map_sort_key *secondary_key)",
            "{",
            "\tint (*primary_fn)(const void *, const void *);",
            "\tint (*secondary_fn)(const void *, const void *);",
            "\tunsigned i, start = 0, n_sub = 1;",
            "",
            "\tif (is_key(map, primary_key->field_idx))",
            "\t\tprimary_fn = cmp_entries_key;",
            "\telse",
            "\t\tprimary_fn = cmp_entries_sum;",
            "",
            "\tif (is_key(map, secondary_key->field_idx))",
            "\t\tsecondary_fn = cmp_entries_key;",
            "\telse",
            "\t\tsecondary_fn = cmp_entries_sum;",
            "",
            "\tfor (i = 0; i < n_entries - 1; i++) {",
            "\t\tconst struct tracing_map_sort_entry **a = &entries[i];",
            "\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];",
            "",
            "\t\tif (primary_fn(a, b) == 0) {",
            "\t\t\tn_sub++;",
            "\t\t\tif (i < n_entries - 2)",
            "\t\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (n_sub < 2) {",
            "\t\t\tstart = i + 1;",
            "\t\t\tn_sub = 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tset_sort_key(map, secondary_key);",
            "\t\tsort(&entries[start], n_sub,",
            "\t\t     sizeof(struct tracing_map_sort_entry *),",
            "\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);",
            "\t\tset_sort_key(map, primary_key);",
            "",
            "\t\tstart = i + 1;",
            "\t\tn_sub = 1;",
            "\t}",
            "}"
          ],
          "function_name": "cmp_entries_key, destroy_sort_entry, tracing_map_destroy_sort_entries, detect_dups, is_key, sort_secondary",
          "description": "实现cmp_entries_key等排序比较函数，detect_dups检测重复键，destroy_sort_entry销毁排序条目，sort_secondary实现多级排序逻辑",
          "similarity": 0.4122164845466614
        }
      ]
    },
    {
      "source_file": "kernel/umh.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:44:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `umh.c`\n\n---\n\n# umh.c 技术文档\n\n## 文件概述\n\n`umh.c` 实现了 Linux 内核的 **用户模式辅助程序（Usermode Helper, UMH）** 机制，允许内核在需要时安全地启动用户空间进程。该机制广泛用于模块自动加载、热插拔事件处理、固件加载等场景。文件提供了同步与异步执行用户空间程序的能力，并支持在系统挂起/休眠期间禁用该功能以确保系统状态一致性。\n\n## 核心功能\n\n### 主要数据结构\n\n- `struct subprocess_info`：封装用户模式辅助程序执行所需的所有信息，包括路径、参数、环境变量、初始化/清理回调、等待模式等。\n- `enum umh_disable_depth`：控制 UMH 功能的启用/禁用状态，用于系统挂起等场景。\n\n### 关键全局变量\n\n- `usermodehelper_bset` / `usermodehelper_inheritable`：控制 UMH 进程的初始能力集（capabilities）。\n- `umhelper_sem`（读写信号量）：保护 UMH 全局状态，协调禁用/启用操作。\n- `usermodehelper_disabled`：标识 UMH 是否被禁用。\n- `running_helpers`：原子计数器，跟踪当前正在运行的 UMH 实例数量。\n\n### 核心函数\n\n- `call_usermodehelper_exec_async()`：UMH 工作线程的主函数，负责设置执行环境并调用 `kernel_execve()`。\n- `call_usermodehelper_exec_sync()`：同步执行 UMH，等待子进程结束。\n- `call_usermodehelper_exec_work()`：工作队列回调函数，根据等待模式选择同步或异步执行。\n- `usermodehelper_read_trylock()` / `usermodehelper_read_lock_wait()` / `usermodehelper_read_unlock()`：提供对 UMH 状态的读锁机制，用于检查是否可安全启动 UMH。\n- `__usermodehelper_set_disable_depth()` / `__usermodehelper_disable()`：控制 UMH 的禁用状态，并等待现有实例完成。\n\n## 关键实现\n\n### 执行环境隔离与安全\n\n- **能力集限制**：通过 `usermodehelper_bset` 和 `usermodehelper_inheritable` 限制 UMH 进程的初始能力，防止权限过度提升。\n- **凭证设置**：使用 `prepare_kernel_cred()` 创建新凭证，并通过 `commit_creds()` 应用，确保与调用者隔离。\n- **信号处理**：重置信号处理程序（`flush_signal_handlers`），避免继承内核线程的信号配置。\n- **调度优先级**：显式将 nice 值设为 0，避免继承高优先级工作队列的调度属性。\n- **umask 重置**：将文件创建掩码设为默认值 `0022`。\n\n### 执行模式\n\n- **异步模式（UMH_NO_WAIT）**：通过 `user_mode_thread()` 创建子进程后立即返回，子进程结束后自动清理资源。\n- **同步模式（UMH_WAIT_PROC）**：使用 `kernel_wait()` 阻塞等待子进程结束，适用于需要获取执行结果的场景。\n\n### 资源管理与生命周期\n\n- **自动清理**：通过 `umh_complete()` 统一处理子进程结束后的资源释放，支持同步/异步两种路径。\n- **工作队列执行**：所有 UMH 请求均通过 **无边界工作队列（unbound workqueue）** 执行，确保 CPU 亲和性宽泛，避免在繁忙 CPU 上竞争。\n\n### 系统挂起支持\n\n- **禁用机制**：通过 `usermodehelper_disabled` 标志和读写信号量 `umhelper_sem`，在系统挂起/休眠期间阻止新 UMH 启动。\n- **等待完成**：`__usermodehelper_disable()` 会等待所有正在运行的 UMH 实例结束（超时 5 秒），确保系统状态干净。\n\n## 依赖关系\n\n- **核心调度子系统**：依赖 `user_mode_thread()`、`kernel_execve()`、`kernel_wait()` 等接口。\n- **凭证与安全子系统**：使用 `cred` 结构、`security` LSM 接口、`capabilities` 管理。\n- **工作队列子系统**：通过 `work_struct` 和无边界工作队列执行 UMH 任务。\n- **内存管理**：使用 `kmalloc`/`kfree` 管理 `subprocess_info` 结构。\n- **信号与进程管理**：操作信号处理、进程创建与等待。\n- **电源管理**：与系统挂起/休眠框架集成，通过 `freezer.h` 支持冻结用户空间进程。\n\n## 使用场景\n\n1. **内核模块自动加载**：当内核需要某个未加载的模块时，通过 UMH 调用 `modprobe`。\n2. **热插拔事件处理**：设备插入/移除时，内核通过 UMH 通知用户空间（如 `udev`）。\n3. **固件加载**：设备驱动请求固件时，内核调用用户空间工具（如 `firmware_class`）。\n4. **网络子系统**：如 `netfilter` 的 `nfnetlink_queue` 使用 UMH 启动用户空间处理程序。\n5. **系统挂起/恢复**：在挂起前禁用 UMH，防止用户空间进程干扰系统状态；恢复后重新启用。",
      "similarity": 0.4552297592163086,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/umh.c",
          "start_line": 168,
          "end_line": 279,
          "content": [
            "static void call_usermodehelper_exec_work(struct work_struct *work)",
            "{",
            "\tstruct subprocess_info *sub_info =",
            "\t\tcontainer_of(work, struct subprocess_info, work);",
            "",
            "\tif (sub_info->wait & UMH_WAIT_PROC) {",
            "\t\tcall_usermodehelper_exec_sync(sub_info);",
            "\t} else {",
            "\t\tpid_t pid;",
            "\t\t/*",
            "\t\t * Use CLONE_PARENT to reparent it to kthreadd; we do not",
            "\t\t * want to pollute current->children, and we need a parent",
            "\t\t * that always ignores SIGCHLD to ensure auto-reaping.",
            "\t\t */",
            "\t\tpid = user_mode_thread(call_usermodehelper_exec_async, sub_info,",
            "\t\t\t\t       CLONE_PARENT | SIGCHLD);",
            "\t\tif (pid < 0) {",
            "\t\t\tsub_info->retval = pid;",
            "\t\t\tumh_complete(sub_info);",
            "\t\t}",
            "\t}",
            "}",
            "int usermodehelper_read_trylock(void)",
            "{",
            "\tDEFINE_WAIT(wait);",
            "\tint ret = 0;",
            "",
            "\tdown_read(&umhelper_sem);",
            "\tfor (;;) {",
            "\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,",
            "\t\t\t\tTASK_INTERRUPTIBLE);",
            "\t\tif (!usermodehelper_disabled)",
            "\t\t\tbreak;",
            "",
            "\t\tif (usermodehelper_disabled == UMH_DISABLED)",
            "\t\t\tret = -EAGAIN;",
            "",
            "\t\tup_read(&umhelper_sem);",
            "",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "",
            "\t\tschedule();",
            "\t\ttry_to_freeze();",
            "",
            "\t\tdown_read(&umhelper_sem);",
            "\t}",
            "\tfinish_wait(&usermodehelper_disabled_waitq, &wait);",
            "\treturn ret;",
            "}",
            "long usermodehelper_read_lock_wait(long timeout)",
            "{",
            "\tDEFINE_WAIT(wait);",
            "",
            "\tif (timeout < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tdown_read(&umhelper_sem);",
            "\tfor (;;) {",
            "\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,",
            "\t\t\t\tTASK_UNINTERRUPTIBLE);",
            "\t\tif (!usermodehelper_disabled)",
            "\t\t\tbreak;",
            "",
            "\t\tup_read(&umhelper_sem);",
            "",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\tif (!timeout)",
            "\t\t\tbreak;",
            "",
            "\t\tdown_read(&umhelper_sem);",
            "\t}",
            "\tfinish_wait(&usermodehelper_disabled_waitq, &wait);",
            "\treturn timeout;",
            "}",
            "void usermodehelper_read_unlock(void)",
            "{",
            "\tup_read(&umhelper_sem);",
            "}",
            "void __usermodehelper_set_disable_depth(enum umh_disable_depth depth)",
            "{",
            "\tdown_write(&umhelper_sem);",
            "\tusermodehelper_disabled = depth;",
            "\twake_up(&usermodehelper_disabled_waitq);",
            "\tup_write(&umhelper_sem);",
            "}",
            "int __usermodehelper_disable(enum umh_disable_depth depth)",
            "{",
            "\tlong retval;",
            "",
            "\tif (!depth)",
            "\t\treturn -EINVAL;",
            "",
            "\tdown_write(&umhelper_sem);",
            "\tusermodehelper_disabled = depth;",
            "\tup_write(&umhelper_sem);",
            "",
            "\t/*",
            "\t * From now on call_usermodehelper_exec() won't start any new",
            "\t * helpers, so it is sufficient if running_helpers turns out to",
            "\t * be zero at one point (it may be increased later, but that",
            "\t * doesn't matter).",
            "\t */",
            "\tretval = wait_event_timeout(running_helpers_waitq,",
            "\t\t\t\t\tatomic_read(&running_helpers) == 0,",
            "\t\t\t\t\tRUNNING_HELPERS_TIMEOUT);",
            "\tif (retval)",
            "\t\treturn 0;",
            "",
            "\t__usermodehelper_set_disable_depth(UMH_ENABLED);",
            "\treturn -EAGAIN;",
            "}"
          ],
          "function_name": "call_usermodehelper_exec_work, usermodehelper_read_trylock, usermodehelper_read_lock_wait, usermodehelper_read_unlock, __usermodehelper_set_disable_depth, __usermodehelper_disable",
          "description": "提供读锁操作、深度禁用状态设置及禁用控制接口，用于协调用户模式帮助程序的启用状态和资源竞争管理。",
          "similarity": 0.4267313480377197
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/umh.c",
          "start_line": 331,
          "end_line": 467,
          "content": [
            "static void helper_lock(void)",
            "{",
            "\tatomic_inc(&running_helpers);",
            "\tsmp_mb__after_atomic();",
            "}",
            "static void helper_unlock(void)",
            "{",
            "\tif (atomic_dec_and_test(&running_helpers))",
            "\t\twake_up(&running_helpers_waitq);",
            "}",
            "int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)",
            "{",
            "\tunsigned int state = TASK_UNINTERRUPTIBLE;",
            "\tDECLARE_COMPLETION_ONSTACK(done);",
            "\tint retval = 0;",
            "",
            "\tif (!sub_info->path) {",
            "\t\tcall_usermodehelper_freeinfo(sub_info);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\thelper_lock();",
            "\tif (usermodehelper_disabled) {",
            "\t\tretval = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * If there is no binary for us to call, then just return and get out of",
            "\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and",
            "\t * disable all call_usermodehelper() calls.",
            "\t */",
            "\tif (strlen(sub_info->path) == 0)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Set the completion pointer only if there is a waiter.",
            "\t * This makes it possible to use umh_complete to free",
            "\t * the data structure in case of UMH_NO_WAIT.",
            "\t */",
            "\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;",
            "\tsub_info->wait = wait;",
            "",
            "\tqueue_work(system_unbound_wq, &sub_info->work);",
            "\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */",
            "\t\tgoto unlock;",
            "",
            "\tif (wait & UMH_FREEZABLE)",
            "\t\tstate |= TASK_FREEZABLE;",
            "",
            "\tif (wait & UMH_KILLABLE) {",
            "\t\tretval = wait_for_completion_state(&done, state | TASK_KILLABLE);",
            "\t\tif (!retval)",
            "\t\t\tgoto wait_done;",
            "",
            "\t\t/* umh_complete() will see NULL and free sub_info */",
            "\t\tif (xchg(&sub_info->complete, NULL))",
            "\t\t\tgoto unlock;",
            "",
            "\t\t/*",
            "\t\t * fallthrough; in case of -ERESTARTSYS now do uninterruptible",
            "\t\t * wait_for_completion_state(). Since umh_complete() shall call",
            "\t\t * complete() in a moment if xchg() above returned NULL, this",
            "\t\t * uninterruptible wait_for_completion_state() will not block",
            "\t\t * SIGKILL'ed processes for long.",
            "\t\t */",
            "\t}",
            "\twait_for_completion_state(&done, state);",
            "",
            "wait_done:",
            "\tretval = sub_info->retval;",
            "out:",
            "\tcall_usermodehelper_freeinfo(sub_info);",
            "unlock:",
            "\thelper_unlock();",
            "\treturn retval;",
            "}",
            "int call_usermodehelper(const char *path, char **argv, char **envp, int wait)",
            "{",
            "\tstruct subprocess_info *info;",
            "\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;",
            "",
            "\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,",
            "\t\t\t\t\t NULL, NULL, NULL);",
            "\tif (info == NULL)",
            "\t\treturn -ENOMEM;",
            "",
            "\treturn call_usermodehelper_exec(info, wait);",
            "}",
            "static int proc_cap_handler(struct ctl_table *table, int write,",
            "\t\t\t void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct ctl_table t;",
            "\tunsigned long cap_array[2];",
            "\tkernel_cap_t new_cap, *cap;",
            "\tint err;",
            "",
            "\tif (write && (!capable(CAP_SETPCAP) ||",
            "\t\t      !capable(CAP_SYS_MODULE)))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * convert from the global kernel_cap_t to the ulong array to print to",
            "\t * userspace if this is a read.",
            "\t *",
            "\t * Legacy format: capabilities are exposed as two 32-bit values",
            "\t */",
            "\tcap = table->data;",
            "\tspin_lock(&umh_sysctl_lock);",
            "\tcap_array[0] = (u32) cap->val;",
            "\tcap_array[1] = cap->val >> 32;",
            "\tspin_unlock(&umh_sysctl_lock);",
            "",
            "\tt = *table;",
            "\tt.data = &cap_array;",
            "",
            "\t/*",
            "\t * actually read or write and array of ulongs from userspace.  Remember",
            "\t * these are least significant 32 bits first",
            "\t */",
            "\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);",
            "\tif (err < 0)",
            "\t\treturn err;",
            "",
            "\tnew_cap.val = (u32)cap_array[0];",
            "\tnew_cap.val += (u64)cap_array[1] << 32;",
            "",
            "\t/*",
            "\t * Drop everything not in the new_cap (but don't add things)",
            "\t */",
            "\tif (write) {",
            "\t\tspin_lock(&umh_sysctl_lock);",
            "\t\t*cap = cap_intersect(*cap, new_cap);",
            "\t\tspin_unlock(&umh_sysctl_lock);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "helper_lock, helper_unlock, call_usermodehelper_exec, call_usermodehelper, proc_cap_handler",
          "description": "实现用户模式帮助程序执行核心API，包含运行计数器管理、能力交集计算及系统调参处理，支持动态能力限制配置。",
          "similarity": 0.41440537571907043
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/umh.c",
          "start_line": 44,
          "end_line": 145,
          "content": [
            "static void call_usermodehelper_freeinfo(struct subprocess_info *info)",
            "{",
            "\tif (info->cleanup)",
            "\t\t(*info->cleanup)(info);",
            "\tkfree(info);",
            "}",
            "static void umh_complete(struct subprocess_info *sub_info)",
            "{",
            "\tstruct completion *comp = xchg(&sub_info->complete, NULL);",
            "\t/*",
            "\t * See call_usermodehelper_exec(). If xchg() returns NULL",
            "\t * we own sub_info, the UMH_KILLABLE caller has gone away",
            "\t * or the caller used UMH_NO_WAIT.",
            "\t */",
            "\tif (comp)",
            "\t\tcomplete(comp);",
            "\telse",
            "\t\tcall_usermodehelper_freeinfo(sub_info);",
            "}",
            "static int call_usermodehelper_exec_async(void *data)",
            "{",
            "\tstruct subprocess_info *sub_info = data;",
            "\tstruct cred *new;",
            "\tint retval;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tflush_signal_handlers(current, 1);",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\t/*",
            "\t * Initial kernel threads share ther FS with init, in order to",
            "\t * get the init root directory. But we've now created a new",
            "\t * thread that is going to execve a user process and has its own",
            "\t * 'struct fs_struct'. Reset umask to the default.",
            "\t */",
            "\tcurrent->fs->umask = 0022;",
            "",
            "\t/*",
            "\t * Our parent (unbound workqueue) runs with elevated scheduling",
            "\t * priority. Avoid propagating that into the userspace child.",
            "\t */",
            "\tset_user_nice(current, 0);",
            "",
            "\tretval = -ENOMEM;",
            "\tnew = prepare_kernel_cred(current);",
            "\tif (!new)",
            "\t\tgoto out;",
            "",
            "\tspin_lock(&umh_sysctl_lock);",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_cap_bset(new, cap_intersect(usermodehelper_bset, new->cap_bset));",
            "\tiee_set_cred_cap_inheritable(new, cap_intersect(usermodehelper_inheritable,",
            "\t\t\t\t\t     new->cap_inheritable));",
            "\t#else",
            "\tnew->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);",
            "\tnew->cap_inheritable = cap_intersect(usermodehelper_inheritable,",
            "\t\t\t\t\t     new->cap_inheritable);",
            "\t#endif",
            "\tspin_unlock(&umh_sysctl_lock);",
            "",
            "\tif (sub_info->init) {",
            "\t\tretval = sub_info->init(sub_info, new);",
            "\t\tif (retval) {",
            "\t\t\tabort_creds(new);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tcommit_creds(new);",
            "",
            "\twait_for_initramfs();",
            "\tretval = kernel_execve(sub_info->path,",
            "\t\t\t       (const char *const *)sub_info->argv,",
            "\t\t\t       (const char *const *)sub_info->envp);",
            "out:",
            "\tsub_info->retval = retval;",
            "\t/*",
            "\t * call_usermodehelper_exec_sync() will call umh_complete",
            "\t * if UHM_WAIT_PROC.",
            "\t */",
            "\tif (!(sub_info->wait & UMH_WAIT_PROC))",
            "\t\tumh_complete(sub_info);",
            "\tif (!retval)",
            "\t\treturn 0;",
            "\tdo_exit(0);",
            "}",
            "static void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)",
            "{",
            "\tpid_t pid;",
            "",
            "\t/* If SIGCLD is ignored do_wait won't populate the status. */",
            "\tkernel_sigaction(SIGCHLD, SIG_DFL);",
            "\tpid = user_mode_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);",
            "\tif (pid < 0)",
            "\t\tsub_info->retval = pid;",
            "\telse",
            "\t\tkernel_wait(pid, &sub_info->retval);",
            "",
            "\t/* Restore default kernel sig handler */",
            "\tkernel_sigaction(SIGCHLD, SIG_IGN);",
            "\tumh_complete(sub_info);",
            "}"
          ],
          "function_name": "call_usermodehelper_freeinfo, umh_complete, call_usermodehelper_exec_async, call_usermodehelper_exec_sync",
          "description": "实现用户模式帮助程序的子进程清理、完成通知及异步/同步执行逻辑，包括权限调整、执行路径切换和结果返回处理。",
          "similarity": 0.4080105423927307
        }
      ]
    }
  ]
}