{
  "query": "进程状态",
  "timestamp": "2025-12-19 16:18:31",
  "retrieved_files": [
    {
      "source_file": "kernel/ptrace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ptrace.c`\n\n---\n\n# ptrace.c 技术文档\n\n## 1. 文件概述\n\n`ptrace.c` 是 Linux 内核中实现 **ptrace**（进程跟踪）机制的核心通用代码文件。该文件提供了跨架构的 ptrace 公共接口和基础功能，避免在每个体系结构中重复实现相同逻辑。ptrace 机制允许一个进程（tracer，通常是调试器）观察和控制另一个进程（tracee）的执行，包括读写其内存、寄存器状态、拦截系统调用等，是调试器（如 GDB）、系统调用追踪工具（如 strace）和安全监控工具的基础。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`ptrace_access_vm()`**  \n  安全地访问被跟踪进程（tracee）的虚拟内存空间，用于读写其内存内容。\n\n- **`__ptrace_link()`**  \n  将被跟踪进程链接到跟踪进程（tracer）的 `ptraced` 链表中，并设置其父进程为 tracer。\n\n- **`ptrace_link()`**  \n  封装 `__ptrace_link()`，使用当前进程的凭证建立跟踪关系。\n\n- **`__ptrace_unlink()`**  \n  解除跟踪关系：将被跟踪进程从 tracer 的链表中移除，恢复其原始父进程，并根据进程组停止状态调整其任务状态（如从 `TASK_TRACED` 转为 `TASK_STOPPED` 或唤醒）。\n\n- **`ptrace_freeze_traced()`** / **`ptrace_unfreeze_traced()`**  \n  在执行 ptrace 操作期间临时冻结被跟踪进程，防止其被意外唤醒（即使是 SIGKILL），确保操作的原子性和一致性。\n\n- **`ptrace_check_attach()`**  \n  验证当前进程是否有权对目标进程执行 ptrace 操作，并确保目标进程处于合适的跟踪状态（可选）。\n\n- **`looks_like_a_spurious_pid()`**  \n  辅助函数，用于检测因线程组 leader 更换（如 `de_thread()`）导致的“虚假”ptrace 事件，避免对已销毁进程的误操作。\n\n### 关键数据结构字段（在 `task_struct` 中）\n\n- `ptrace`：标志位，表示进程是否被跟踪。\n- `parent` / `real_parent`：分别表示当前父进程（通常是 tracer）和原始父进程。\n- `ptraced`：链表头，包含所有被当前进程跟踪的子进程。\n- `ptrace_entry`：链表节点，用于加入 tracer 的 `ptraced` 链表。\n- `ptracer_cred`：跟踪进程的凭证（credentials），用于权限检查。\n- `jobctl`：任务控制标志，包含 `JOBCTL_PTRACE_FROZEN`、`JOBCTL_TRACED`、`JOBCTL_STOP_PENDING` 等 ptrace 相关状态。\n\n## 3. 关键实现\n\n### 安全内存访问 (`ptrace_access_vm`)\n- 通过 `get_task_mm()` 获取目标进程的内存描述符 `mm_struct`。\n- 执行严格的权限检查：\n  - 目标进程必须正在被跟踪（`tsk->ptrace` 非零）。\n  - 当前进程必须是目标进程的直接父进程（`current == tsk->parent`）。\n  - 或者当前进程在目标进程的用户命名空间中具有 `CAP_SYS_PTRACE` 能力（通过 `ptracer_capable()` 检查）。\n- 使用 `__access_remote_vm()` 安全地读写目标进程内存，避免直接遍历页表。\n\n### 跟踪关系管理\n- **链接**：`ptrace_link()` 在持有 `tasklist_lock` 写锁时调用 `__ptrace_link()`，将 tracee 加入 tracer 的 `ptraced` 链表，并保存 tracer 的凭证。\n- **解链接**：`__ptrace_unlink()` 在 detach 或 tracer 退出时调用：\n  - 清除 syscall trace/emu 标志。\n  - 恢复 `real_parent`。\n  - 清除 `ptrace` 标志和 jobctl 中的 trap 相关位。\n  - 根据进程组停止状态决定是否设置 `JOBCTL_STOP_PENDING` 并唤醒进程（`ptrace_signal_wake_up()`）。\n\n### 进程状态冻结机制\n- 在执行 ptrace 操作前调用 `ptrace_freeze_traced()`：\n  - 若 tracee 处于 `TASK_TRACED` 且无致命信号待处理，则设置 `JOBCTL_PTRACE_FROZEN` 标志，使其无法被唤醒。\n- 操作完成后调用 `ptrace_unfreeze_traced()`：\n  - 清除冻结标志。\n  - 若存在致命信号（如 SIGKILL），则清除 `JOBCTL_TRACED` 并唤醒进程以处理信号。\n\n### 权限与状态验证 (`ptrace_check_attach`)\n- 在 `tasklist_lock` 读锁保护下验证：\n  - 目标进程确由当前进程跟踪（`child->ptrace && child->parent == current`）。\n  - 若 `ignore_state=false`，则进一步冻结 tracee 以确保其处于稳定状态。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`mm_struct`、`sighand_struct` 等核心数据结构，以及 `wake_up_state()`、`task_is_traced()` 等调度状态管理函数。\n- **内存管理**：通过 `get_task_mm()`、`mmput()` 和 `__access_remote_vm()` 访问远程进程内存。\n- **信号处理**：大量使用 `siglock`、`jobctl`、`signal_struct` 等信号相关机制管理进程状态转换。\n- **安全模块**：集成 LSM（Linux Security Module）钩子（`security_ptrace_access_check`）和能力检查（`capable()`）。\n- **审计与通知**：与 `audit` 和 `cn_proc`（进程事件连接器）交互，记录 ptrace 事件。\n- **体系结构相关代码**：依赖 `asm/syscall.h` 提供的 `syscall_get_*` 接口获取系统调用信息。\n- **硬件断点**：通过 `hw_breakpoint.h` 支持硬件断点调试功能。\n\n## 5. 使用场景\n\n- **调试器（如 GDB）**：attach 到目标进程，读取/修改寄存器和内存，设置断点，单步执行。\n- **系统调用追踪（如 strace）**：拦截并记录目标进程的所有系统调用及其参数和返回值。\n- **安全监控工具**：监控可疑进程的行为，如检测恶意代码注入或提权操作。\n- **容器与沙箱**：在用户命名空间中实现进程隔离和监控。\n- **内核测试**：用于内核自检和调试，验证进程行为和系统调用处理。\n- **进程注入与热补丁**：通过修改运行中进程的内存和寄存器状态实现代码注入或修复。",
      "similarity": 0.6099658012390137,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/ptrace.c",
          "start_line": 44,
          "end_line": 148,
          "content": [
            "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,",
            "\t\t     void *buf, int len, unsigned int gup_flags)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint ret;",
            "",
            "\tmm = get_task_mm(tsk);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tif (!tsk->ptrace ||",
            "\t    (current != tsk->parent) ||",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptracer_capable(tsk, mm->user_ns))) {",
            "\t\tmmput(mm);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = __access_remote_vm(mm, addr, buf, len, gup_flags);",
            "\tmmput(mm);",
            "",
            "\treturn ret;",
            "}",
            "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,",
            "\t\t   const struct cred *ptracer_cred)",
            "{",
            "\tBUG_ON(!list_empty(&child->ptrace_entry));",
            "\tlist_add(&child->ptrace_entry, &new_parent->ptraced);",
            "\tchild->parent = new_parent;",
            "\tchild->ptracer_cred = get_cred(ptracer_cred);",
            "}",
            "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)",
            "{",
            "\t__ptrace_link(child, new_parent, current_cred());",
            "}",
            "void __ptrace_unlink(struct task_struct *child)",
            "{",
            "\tconst struct cred *old_cred;",
            "\tBUG_ON(!child->ptrace);",
            "",
            "\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tchild->parent = child->real_parent;",
            "\tlist_del_init(&child->ptrace_entry);",
            "\told_cred = child->ptracer_cred;",
            "\tchild->ptracer_cred = NULL;",
            "\tput_cred(old_cred);",
            "",
            "\tspin_lock(&child->sighand->siglock);",
            "\tchild->ptrace = 0;",
            "\t/*",
            "\t * Clear all pending traps and TRAPPING.  TRAPPING should be",
            "\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.",
            "\t */",
            "\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);",
            "\ttask_clear_jobctl_trapping(child);",
            "",
            "\t/*",
            "\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and",
            "\t * @child isn't dead.",
            "\t */",
            "\tif (!(child->flags & PF_EXITING) &&",
            "\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||",
            "\t     child->signal->group_stop_count)) {",
            "\t\tchild->jobctl |= JOBCTL_STOP_PENDING;",
            "",
            "\t\t/*",
            "\t\t * This is only possible if this thread was cloned by the",
            "\t\t * traced task running in the stopped group, set the signal",
            "\t\t * for the future reports.",
            "\t\t * FIXME: we should change ptrace_init_task() to handle this",
            "\t\t * case.",
            "\t\t */",
            "\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))",
            "\t\t\tchild->jobctl |= SIGSTOP;",
            "\t}",
            "",
            "\t/*",
            "\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick",
            "\t * @child in the butt.  Note that @resume should be used iff @child",
            "\t * is in TASK_TRACED; otherwise, we might unduly disrupt",
            "\t * TASK_KILLABLE sleeps.",
            "\t */",
            "\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))",
            "\t\tptrace_signal_wake_up(child, true);",
            "",
            "\tspin_unlock(&child->sighand->siglock);",
            "}",
            "static bool looks_like_a_spurious_pid(struct task_struct *task)",
            "{",
            "\tif (task->exit_code != ((PTRACE_EVENT_EXEC << 8) | SIGTRAP))",
            "\t\treturn false;",
            "",
            "\tif (task_pid_vnr(task) == task->ptrace_message)",
            "\t\treturn false;",
            "\t/*",
            "\t * The tracee changed its pid but the PTRACE_EVENT_EXEC event",
            "\t * was not wait()'ed, most probably debugger targets the old",
            "\t * leader which was destroyed in de_thread().",
            "\t */",
            "\treturn true;",
            "}"
          ],
          "function_name": "ptrace_access_vm, __ptrace_link, ptrace_link, __ptrace_unlink, looks_like_a_spurious_pid",
          "description": "实现进程跟踪核心操作，包含访问目标进程地址空间、维护跟踪链表、解除跟踪关系及检测虚假PID逻辑，用于安全控制和状态同步。",
          "similarity": 0.6660212278366089
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/ptrace.c",
          "start_line": 360,
          "end_line": 490,
          "content": [
            "bool ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tint err;",
            "\ttask_lock(task);",
            "\terr = __ptrace_may_access(task, mode);",
            "\ttask_unlock(task);",
            "\treturn !err;",
            "}",
            "static int check_ptrace_options(unsigned long data)",
            "{",
            "\tif (data & ~(unsigned long)PTRACE_O_MASK)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {",
            "\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||",
            "\t\t    !IS_ENABLED(CONFIG_SECCOMP))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (!capable(CAP_SYS_ADMIN))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||",
            "\t\t    current->ptrace & PT_SUSPEND_SECCOMP)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "\treturn 0;",
            "}",
            "static inline void ptrace_set_stopped(struct task_struct *task)",
            "{",
            "\tguard(spinlock)(&task->sighand->siglock);",
            "",
            "\t/*",
            "\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and",
            "\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING",
            "\t * will be cleared if the child completes the transition or any",
            "\t * event which clears the group stop states happens.  We'll wait",
            "\t * for the transition to complete before returning from this",
            "\t * function.",
            "\t *",
            "\t * This hides STOPPED -> RUNNING -> TRACED transition from the",
            "\t * attaching thread but a different thread in the same group can",
            "\t * still observe the transient RUNNING state.  IOW, if another",
            "\t * thread's WNOHANG wait(2) on the stopped tracee races against",
            "\t * ATTACH, the wait(2) may fail due to the transient RUNNING.",
            "\t *",
            "\t * The following task_is_stopped() test is safe as both transitions",
            "\t * in and out of STOPPED are protected by siglock.",
            "\t */",
            "\tif (task_is_stopped(task) &&",
            "\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING)) {",
            "\t\ttask->jobctl &= ~JOBCTL_STOPPED;",
            "\t\tsignal_wake_up_state(task, __TASK_STOPPED);",
            "\t}",
            "}",
            "static int ptrace_attach(struct task_struct *task, long request,",
            "\t\t\t unsigned long addr,",
            "\t\t\t unsigned long flags)",
            "{",
            "\tbool seize = (request == PTRACE_SEIZE);",
            "\tint retval;",
            "",
            "\tif (seize) {",
            "\t\tif (addr != 0)",
            "\t\t\treturn -EIO;",
            "\t\t/*",
            "\t\t * This duplicates the check in check_ptrace_options() because",
            "\t\t * ptrace_attach() and ptrace_setoptions() have historically",
            "\t\t * used different error codes for unknown ptrace options.",
            "\t\t */",
            "\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)",
            "\t\t\treturn -EIO;",
            "",
            "\t\tretval = check_ptrace_options(flags);",
            "\t\tif (retval)",
            "\t\t\treturn retval;",
            "\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);",
            "\t} else {",
            "\t\tflags = PT_PTRACED;",
            "\t}",
            "",
            "\taudit_ptrace(task);",
            "",
            "\tif (unlikely(task->flags & PF_KTHREAD))",
            "\t\treturn -EPERM;",
            "\tif (same_thread_group(task, current))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Protect exec's credential calculations against our interference;",
            "\t * SUID, SGID and LSM creds get determined differently",
            "\t * under ptrace.",
            "\t */",
            "\tscoped_cond_guard (mutex_intr, return -ERESTARTNOINTR,",
            "\t\t\t   &task->signal->cred_guard_mutex) {",
            "",
            "\t\tscoped_guard (task_lock, task) {",
            "\t\t\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);",
            "\t\t\tif (retval)",
            "\t\t\t\treturn retval;",
            "\t\t}",
            "",
            "\t\tscoped_guard (write_lock_irq, &tasklist_lock) {",
            "\t\t\tif (unlikely(task->exit_state))",
            "\t\t\t\treturn -EPERM;",
            "\t\t\tif (task->ptrace)",
            "\t\t\t\treturn -EPERM;",
            "",
            "\t\t\ttask->ptrace = flags;",
            "",
            "\t\t\tptrace_link(task, current);",
            "",
            "\t\t\t/* SEIZE doesn't trap tracee on attach */",
            "\t\t\tif (!seize)",
            "\t\t\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);",
            "",
            "\t\t\tptrace_set_stopped(task);",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * We do not bother to change retval or clear JOBCTL_TRAPPING",
            "\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will",
            "\t * not return to user-mode, it will exit and clear this bit in",
            "\t * __ptrace_unlink() if it wasn't already cleared by the tracee;",
            "\t * and until then nobody can ptrace this task.",
            "\t */",
            "\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);",
            "\tproc_ptrace_connector(task, PTRACE_ATTACH);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "ptrace_may_access, check_ptrace_options, ptrace_set_stopped, ptrace_attach",
          "description": "实现ptrace附加流程，包含权限校验、选项解析、停止状态设置及实际附加操作，协调信号传递和跟踪标志位更新。",
          "similarity": 0.6104123592376709
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/ptrace.c",
          "start_line": 195,
          "end_line": 336,
          "content": [
            "static bool ptrace_freeze_traced(struct task_struct *task)",
            "{",
            "\tbool ret = false;",
            "",
            "\t/* Lockless, nobody but us can set this flag */",
            "\tif (task->jobctl & JOBCTL_LISTENING)",
            "\t\treturn ret;",
            "",
            "\tspin_lock_irq(&task->sighand->siglock);",
            "\tif (task_is_traced(task) && !looks_like_a_spurious_pid(task) &&",
            "\t    !__fatal_signal_pending(task)) {",
            "\t\ttask->jobctl |= JOBCTL_PTRACE_FROZEN;",
            "\t\tret = true;",
            "\t}",
            "\tspin_unlock_irq(&task->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void ptrace_unfreeze_traced(struct task_struct *task)",
            "{",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * The child may be awake and may have cleared",
            "\t * JOBCTL_PTRACE_FROZEN (see ptrace_resume).  The child will",
            "\t * not set JOBCTL_PTRACE_FROZEN or enter __TASK_TRACED anew.",
            "\t */",
            "\tif (lock_task_sighand(task, &flags)) {",
            "\t\ttask->jobctl &= ~JOBCTL_PTRACE_FROZEN;",
            "\t\tif (__fatal_signal_pending(task)) {",
            "\t\t\ttask->jobctl &= ~JOBCTL_TRACED;",
            "\t\t\twake_up_state(task, __TASK_TRACED);",
            "\t\t}",
            "\t\tunlock_task_sighand(task, &flags);",
            "\t}",
            "}",
            "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)",
            "{",
            "\tint ret = -ESRCH;",
            "",
            "\t/*",
            "\t * We take the read lock around doing both checks to close a",
            "\t * possible race where someone else was tracing our child and",
            "\t * detached between these two checks.  After this locked check,",
            "\t * we are sure that this is our traced child and that can only",
            "\t * be changed by us so it's not changing right after this.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tif (child->ptrace && child->parent == current) {",
            "\t\t/*",
            "\t\t * child->sighand can't be NULL, release_task()",
            "\t\t * does ptrace_unlink() before __exit_signal().",
            "\t\t */",
            "\t\tif (ignore_state || ptrace_freeze_traced(child))",
            "\t\t\tret = 0;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tif (!ret && !ignore_state &&",
            "\t    WARN_ON_ONCE(!wait_task_inactive(child, __TASK_TRACED|TASK_FROZEN)))",
            "\t\tret = -ESRCH;",
            "",
            "\treturn ret;",
            "}",
            "static bool ptrace_has_cap(struct user_namespace *ns, unsigned int mode)",
            "{",
            "\tif (mode & PTRACE_MODE_NOAUDIT)",
            "\t\treturn ns_capable_noaudit(ns, CAP_SYS_PTRACE);",
            "\treturn ns_capable(ns, CAP_SYS_PTRACE);",
            "}",
            "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tconst struct cred *cred = current_cred(), *tcred;",
            "\tstruct mm_struct *mm;",
            "\tkuid_t caller_uid;",
            "\tkgid_t caller_gid;",
            "",
            "\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {",
            "\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* May we inspect the given task?",
            "\t * This check is used both for attaching with ptrace",
            "\t * and for allowing access to sensitive information in /proc.",
            "\t *",
            "\t * ptrace_attach denies several cases that /proc allows",
            "\t * because setting up the necessary parent/child relationship",
            "\t * or halting the specified task is impossible.",
            "\t */",
            "",
            "\t/* Don't let security modules deny introspection */",
            "\tif (same_thread_group(task, current))",
            "\t\treturn 0;",
            "\trcu_read_lock();",
            "\tif (mode & PTRACE_MODE_FSCREDS) {",
            "\t\tcaller_uid = cred->fsuid;",
            "\t\tcaller_gid = cred->fsgid;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Using the euid would make more sense here, but something",
            "\t\t * in userland might rely on the old behavior, and this",
            "\t\t * shouldn't be a security problem since",
            "\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly",
            "\t\t * used a syscall that requests access to another process",
            "\t\t * (and not a filesystem syscall to procfs).",
            "\t\t */",
            "\t\tcaller_uid = cred->uid;",
            "\t\tcaller_gid = cred->gid;",
            "\t}",
            "\ttcred = __task_cred(task);",
            "\tif (uid_eq(caller_uid, tcred->euid) &&",
            "\t    uid_eq(caller_uid, tcred->suid) &&",
            "\t    uid_eq(caller_uid, tcred->uid)  &&",
            "\t    gid_eq(caller_gid, tcred->egid) &&",
            "\t    gid_eq(caller_gid, tcred->sgid) &&",
            "\t    gid_eq(caller_gid, tcred->gid))",
            "\t\tgoto ok;",
            "\tif (ptrace_has_cap(tcred->user_ns, mode))",
            "\t\tgoto ok;",
            "\trcu_read_unlock();",
            "\treturn -EPERM;",
            "ok:",
            "\trcu_read_unlock();",
            "\t/*",
            "\t * If a task drops privileges and becomes nondumpable (through a syscall",
            "\t * like setresuid()) while we are trying to access it, we must ensure",
            "\t * that the dumpability is read after the credentials; otherwise,",
            "\t * we may be able to attach to a task that we shouldn't be able to",
            "\t * attach to (as if the task had dropped privileges without becoming",
            "\t * nondumpable).",
            "\t * Pairs with a write barrier in commit_creds().",
            "\t */",
            "\tsmp_rmb();",
            "\tmm = task->mm;",
            "\tif (mm &&",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptrace_has_cap(mm->user_ns, mode)))",
            "\t    return -EPERM;",
            "",
            "\treturn security_ptrace_access_check(task, mode);",
            "}"
          ],
          "function_name": "ptrace_freeze_traced, ptrace_unfreeze_traced, ptrace_check_attach, ptrace_has_cap, __ptrace_may_access",
          "description": "处理跟踪进程的冻结/解冻机制，检查附加合法性并验证能力权限，确保跟踪操作符合安全策略和内核状态约束。",
          "similarity": 0.6021367311477661
        }
      ]
    },
    {
      "source_file": "kernel/sched/stats.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:17:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\stats.c`\n\n---\n\n# `sched/stats.c` 技术文档\n\n## 1. 文件概述\n\n`sched/stats.c` 是 Linux 内核调度器统计信息模块的核心实现文件，负责收集和导出与任务调度相关的性能统计指标。该文件实现了 `/proc/schedstat` 接口，向用户空间提供调度器运行队列（runqueue）、任务等待/睡眠/阻塞时间、负载均衡事件等详细统计数据，主要用于性能分析、调度调优和系统监控。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__update_stats_wait_start()`**  \n  记录任务进入等待状态的起始时间戳。\n\n- **`__update_stats_wait_end()`**  \n  计算任务等待时间，更新最大等待时间、等待次数和总等待时间，并处理任务迁移场景。\n\n- **`__update_stats_enqueue_sleeper()`**  \n  处理任务从睡眠或阻塞状态被重新入队时的统计更新，包括睡眠时间、阻塞时间、I/O 等待时间等。\n\n- **`show_schedstat()`**  \n  格式化输出 `/proc/schedstat` 的内容，包括版本号、时间戳、每个 CPU 的运行队列统计以及调度域（SMP）的负载均衡统计。\n\n- **`schedstat_start()` / `schedstat_next()` / `schedstat_stop()`**  \n  实现 `seq_file` 迭代器，用于遍历所有在线 CPU 并生成 `/proc/schedstat` 的多行输出。\n\n- **`proc_schedstat_init()`**  \n  初始化函数，通过 `subsys_initcall` 在内核启动时注册 `/proc/schedstat` 文件。\n\n### 关键宏与常量\n\n- **`SCHEDSTAT_VERSION`**  \n  当前调度统计 API 的版本号（值为 15），用于兼容性检查。\n\n- **`__schedstat_set/inc/add` 系列宏**  \n  安全地更新调度统计字段（通常在 `CONFIG_SCHEDSTATS` 启用时有效）。\n\n## 3. 关键实现\n\n### 等待时间统计机制\n- 任务进入不可运行状态时调用 `__update_stats_wait_start()`，记录当前运行队列时钟时间。\n- 当任务重新变为可运行时调用 `__update_stats_wait_end()`，计算等待时长 `delta`。\n- 若任务正在 CPU 间迁移（`task_on_rq_migrating`），则保留 `delta` 作为新的 `wait_start`，以便在目标 CPU 上继续累加等待时间，确保跨 CPU 迁移时等待时间统计的连续性。\n\n### 睡眠与阻塞时间区分\n- `sleep_start`：任务主动睡眠（如调用 `schedule()`）时设置。\n- `block_start`：任务因等待资源（如 I/O）而阻塞时设置。\n- 两者在任务被唤醒并重新入队时分别计算持续时间，并累加到 `sum_sleep_runtime`；阻塞时间额外计入 `sum_block_runtime` 和 I/O 等待统计（若 `in_iowait` 为真）。\n\n### `/proc/schedstat` 输出格式\n- **首行**：`version <N>` 和 `timestamp <jiffies>`，用于工具识别格式版本和采样时间。\n- **每 CPU 行**：以 `cpu<N>` 开头，包含 yield 次数、调度次数、空闲调度次数、wake-up 次数等运行队列级指标。\n- **调度域行（SMP）**：以 `domain<N>` 开头，列出各 CPU 空闲类型下的负载均衡尝试、成功、失败等详细计数。\n\n### 迭代器设计\n- 使用特殊指针值区分头部（`(void *)1`）和 CPU 数据（`(void *)(cpu + 2)`）。\n- 通过 `cpumask_next()` 和 `cpumask_first()` 遍历 `cpu_online_mask`，支持 CPU 热插拔场景。\n\n## 4. 依赖关系\n\n- **调度器核心**：依赖 `kernel/sched/` 下的运行队列（`struct rq`）、任务结构（`struct task_struct`）和时钟函数（`rq_clock()`）。\n- **配置选项**：功能受 `CONFIG_SCHEDSTATS` 控制（虽未在本文件显式检查，但相关字段和宏由该配置启用）。\n- **SMP 支持**：调度域统计仅在 `CONFIG_SMP` 启用时编译。\n- **跟踪子系统**：调用 `trace_sched_stat_*` 系列 tracepoint，依赖 `kernel/trace/`。\n- **延迟账户**：调用 `account_scheduler_latency()`，与延迟跟踪机制集成。\n- **proc 文件系统**：使用 `proc_create_seq()` 注册 `/proc` 接口。\n\n## 5. 使用场景\n\n- **性能分析工具**：如 `perf`、`sar`、`vmstat` 等读取 `/proc/schedstat` 获取调度延迟、负载均衡效率等指标。\n- **内核调试**：开发者通过分析等待/睡眠时间分布定位调度瓶颈或任务饥饿问题。\n- **调度器调优**：系统管理员根据域级负载均衡统计调整 `sched_domain` 参数。\n- **I/O 性能诊断**：通过 `iowait_sum` 和 `iowait_count` 识别 I/O 密集型任务对调度的影响。\n- **实时性评估**：结合 `wait_max` 和 `run_delay` 评估任务响应延迟。",
      "similarity": 0.6004491448402405,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/stats.c",
          "start_line": 6,
          "end_line": 156,
          "content": [
            "void __update_stats_wait_start(struct rq *rq, struct task_struct *p,",
            "\t\t\t       struct sched_statistics *stats)",
            "{",
            "\tu64 wait_start, prev_wait_start;",
            "",
            "\twait_start = rq_clock(rq);",
            "\tprev_wait_start = schedstat_val(stats->wait_start);",
            "",
            "\tif (p && likely(wait_start > prev_wait_start))",
            "\t\twait_start -= prev_wait_start;",
            "",
            "\t__schedstat_set(stats->wait_start, wait_start);",
            "}",
            "void __update_stats_wait_end(struct rq *rq, struct task_struct *p,",
            "\t\t\t     struct sched_statistics *stats)",
            "{",
            "\tu64 delta = rq_clock(rq) - schedstat_val(stats->wait_start);",
            "",
            "\tif (p) {",
            "\t\tif (task_on_rq_migrating(p)) {",
            "\t\t\t/*",
            "\t\t\t * Preserve migrating task's wait time so wait_start",
            "\t\t\t * time stamp can be adjusted to accumulate wait time",
            "\t\t\t * prior to migration.",
            "\t\t\t */",
            "\t\t\t__schedstat_set(stats->wait_start, delta);",
            "",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\ttrace_sched_stat_wait(p, delta);",
            "\t}",
            "",
            "\t__schedstat_set(stats->wait_max,",
            "\t\t\tmax(schedstat_val(stats->wait_max), delta));",
            "\t__schedstat_inc(stats->wait_count);",
            "\t__schedstat_add(stats->wait_sum, delta);",
            "\t__schedstat_set(stats->wait_start, 0);",
            "}",
            "void __update_stats_enqueue_sleeper(struct rq *rq, struct task_struct *p,",
            "\t\t\t\t    struct sched_statistics *stats)",
            "{",
            "\tu64 sleep_start, block_start;",
            "",
            "\tsleep_start = schedstat_val(stats->sleep_start);",
            "\tblock_start = schedstat_val(stats->block_start);",
            "",
            "\tif (sleep_start) {",
            "\t\tu64 delta = rq_clock(rq) - sleep_start;",
            "",
            "\t\tif ((s64)delta < 0)",
            "\t\t\tdelta = 0;",
            "",
            "\t\tif (unlikely(delta > schedstat_val(stats->sleep_max)))",
            "\t\t\t__schedstat_set(stats->sleep_max, delta);",
            "",
            "\t\t__schedstat_set(stats->sleep_start, 0);",
            "\t\t__schedstat_add(stats->sum_sleep_runtime, delta);",
            "",
            "\t\tif (p) {",
            "\t\t\taccount_scheduler_latency(p, delta >> 10, 1);",
            "\t\t\ttrace_sched_stat_sleep(p, delta);",
            "\t\t}",
            "\t}",
            "",
            "\tif (block_start) {",
            "\t\tu64 delta = rq_clock(rq) - block_start;",
            "",
            "\t\tif ((s64)delta < 0)",
            "\t\t\tdelta = 0;",
            "",
            "\t\tif (unlikely(delta > schedstat_val(stats->block_max)))",
            "\t\t\t__schedstat_set(stats->block_max, delta);",
            "",
            "\t\t__schedstat_set(stats->block_start, 0);",
            "\t\t__schedstat_add(stats->sum_sleep_runtime, delta);",
            "\t\t__schedstat_add(stats->sum_block_runtime, delta);",
            "",
            "\t\tif (p) {",
            "\t\t\tif (p->in_iowait) {",
            "\t\t\t\t__schedstat_add(stats->iowait_sum, delta);",
            "\t\t\t\t__schedstat_inc(stats->iowait_count);",
            "\t\t\t\ttrace_sched_stat_iowait(p, delta);",
            "\t\t\t}",
            "",
            "\t\t\ttrace_sched_stat_blocked(p, delta);",
            "",
            "\t\t\taccount_scheduler_latency(p, delta >> 10, 0);",
            "\t\t}",
            "\t}",
            "}",
            "static int show_schedstat(struct seq_file *seq, void *v)",
            "{",
            "\tint cpu;",
            "",
            "\tif (v == (void *)1) {",
            "\t\tseq_printf(seq, \"version %d\\n\", SCHEDSTAT_VERSION);",
            "\t\tseq_printf(seq, \"timestamp %lu\\n\", jiffies);",
            "\t} else {",
            "\t\tstruct rq *rq;",
            "#ifdef CONFIG_SMP",
            "\t\tstruct sched_domain *sd;",
            "\t\tint dcount = 0;",
            "#endif",
            "\t\tcpu = (unsigned long)(v - 2);",
            "\t\trq = cpu_rq(cpu);",
            "",
            "\t\t/* runqueue-specific stats */",
            "\t\tseq_printf(seq,",
            "\t\t    \"cpu%d %u 0 %u %u %u %u %llu %llu %lu\",",
            "\t\t    cpu, rq->yld_count,",
            "\t\t    rq->sched_count, rq->sched_goidle,",
            "\t\t    rq->ttwu_count, rq->ttwu_local,",
            "\t\t    rq->rq_cpu_time,",
            "\t\t    rq->rq_sched_info.run_delay, rq->rq_sched_info.pcount);",
            "",
            "\t\tseq_printf(seq, \"\\n\");",
            "",
            "#ifdef CONFIG_SMP",
            "\t\t/* domain-specific stats */",
            "\t\trcu_read_lock();",
            "\t\tfor_each_domain(cpu, sd) {",
            "\t\t\tenum cpu_idle_type itype;",
            "",
            "\t\t\tseq_printf(seq, \"domain%d %*pb\", dcount++,",
            "\t\t\t\t   cpumask_pr_args(sched_domain_span(sd)));",
            "\t\t\tfor (itype = CPU_IDLE; itype < CPU_MAX_IDLE_TYPES;",
            "\t\t\t\t\titype++) {",
            "\t\t\t\tseq_printf(seq, \" %u %u %u %u %u %u %u %u\",",
            "\t\t\t\t    sd->lb_count[itype],",
            "\t\t\t\t    sd->lb_balanced[itype],",
            "\t\t\t\t    sd->lb_failed[itype],",
            "\t\t\t\t    sd->lb_imbalance[itype],",
            "\t\t\t\t    sd->lb_gained[itype],",
            "\t\t\t\t    sd->lb_hot_gained[itype],",
            "\t\t\t\t    sd->lb_nobusyq[itype],",
            "\t\t\t\t    sd->lb_nobusyg[itype]);",
            "\t\t\t}",
            "\t\t\tseq_printf(seq,",
            "\t\t\t\t   \" %u %u %u %u %u %u %u %u %u %u %u %u\\n\",",
            "\t\t\t    sd->alb_count, sd->alb_failed, sd->alb_pushed,",
            "\t\t\t    sd->sbe_count, sd->sbe_balanced, sd->sbe_pushed,",
            "\t\t\t    sd->sbf_count, sd->sbf_balanced, sd->sbf_pushed,",
            "\t\t\t    sd->ttwu_wake_remote, sd->ttwu_move_affine,",
            "\t\t\t    sd->ttwu_move_balance);",
            "\t\t}",
            "\t\trcu_read_unlock();",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__update_stats_wait_start, __update_stats_wait_end, __update_stats_enqueue_sleeper, show_schedstat",
          "description": "实现调度器运行队列的等待时间、睡眠时间、阻塞时间等统计更新逻辑，并提供展示调度统计信息的序列化接口",
          "similarity": 0.5945031642913818
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/stats.c",
          "start_line": 205,
          "end_line": 212,
          "content": [
            "static void schedstat_stop(struct seq_file *file, void *data)",
            "{",
            "}",
            "static int __init proc_schedstat_init(void)",
            "{",
            "\tproc_create_seq(\"schedstat\", 0, NULL, &schedstat_sops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "schedstat_stop, proc_schedstat_init",
          "description": "注册/proc/schedstat文件节点的初始化函数，其中schedstat_stop函数当前未实现具体功能",
          "similarity": 0.5733128786087036
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/stats.c",
          "start_line": 1,
          "end_line": 5,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * /proc/schedstat implementation",
            " */",
            ""
          ],
          "function_name": null,
          "description": "定义/proc/schedstat接口的实现框架，声明调度统计相关信息的注释和许可证标识",
          "similarity": 0.5169519782066345
        }
      ]
    },
    {
      "source_file": "kernel/sched/stop_task.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:17:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\stop_task.c`\n\n---\n\n# `sched/stop_task.c` 技术文档\n\n## 1. 文件概述\n\n`sched/stop_task.c` 实现了 Linux 内核调度器中的 **stop 调度类（stop scheduling class）**。该调度类用于管理 per-CPU 的 **stop 任务（stop task）**，这些任务具有系统中最高的调度优先级，能够抢占所有其他任务，且自身不会被任何任务抢占。stop 任务主要用于需要在所有 CPU 上立即停止常规调度活动的场景，例如 CPU 热插拔、内核模块卸载或 `stop_machine()` 机制执行期间。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `select_task_rq_stop()`：在 SMP 系统中，确保 stop 任务始终运行在其初始 CPU 上，禁止迁移。\n- `balance_stop()`：在负载均衡时判断当前运行队列上是否有可运行的 stop 任务。\n- `wakeup_preempt_stop()`：空实现，因为 stop 任务不会被抢占。\n- `set_next_task_stop()`：设置下一个运行的 stop 任务，并记录其执行起始时间。\n- `pick_task_stop()`：从运行队列中选择 stop 任务（如果存在且可运行）。\n- `enqueue_task_stop()` / `dequeue_task_stop()`：将 stop 任务加入/移出运行队列，并更新运行任务计数。\n- `yield_task_stop()`：触发 `BUG()`，因为 stop 任务绝不应主动让出 CPU。\n- `put_prev_task_stop()`：在切换出 stop 任务时更新其运行统计（调用通用更新函数）。\n- `task_tick_stop()`：空实现，stop 任务不受调度 tick 影响。\n- `switched_to_stop()` / `prio_changed_stop()`：均触发 `BUG()`，因为任务不能动态切换到 stop 调度类，也无优先级概念。\n- `update_curr_stop()`：空实现，stop 任务不参与常规的运行时间更新逻辑。\n\n### 数据结构\n\n- `DEFINE_SCHED_CLASS(stop)`：定义并初始化名为 `stop` 的调度类实例，实现了 `struct sched_class` 接口的所有必要回调函数。\n\n## 3. 关键实现\n\n- **最高优先级保证**：stop 调度类在调度类层级中位于最顶端（高于 `rt`、`fair`、`idle`），确保其任务总是优先获得 CPU。\n- **禁止迁移**：在 `CONFIG_SMP` 下，`select_task_rq_stop()` 强制 stop 任务绑定到其创建时的 CPU，防止跨 CPU 迁移，保证操作的局部性和确定性。\n- **无抢占逻辑**：所有与抢占相关的函数（如 `wakeup_preempt_stop`）均为空或触发错误，因为 stop 任务运行期间系统处于“停止”状态，不应被中断。\n- **错误防护机制**：任何试图动态切换到 stop 调度类、修改其优先级或主动让出 CPU 的行为都会触发 `BUG()`，防止误用。\n- **轻量级统计**：虽然调用 `update_curr_common()` 更新运行时间，但 `update_curr_stop()` 本身为空，表明 stop 任务不参与复杂的调度实体（`sched_entity`）时间计算。\n- **与 `stop_machine` 协同**：该文件与 `kernel/stop_machine.c` 紧密配合，为 `stop_machine()` 提供底层调度支持，确保在所有 CPU 上同步执行关键操作。\n\n## 4. 依赖关系\n\n- **调度核心**：依赖 `kernel/sched/core.c` 中定义的调度类框架、运行队列（`rq`）结构和通用辅助函数（如 `add_nr_running`、`update_curr_common`）。\n- **SMP 支持**：在 `CONFIG_SMP` 编译选项下，依赖 `kernel/sched/sched.h` 中的 `set_cpus_allowed_common` 函数。\n- **Stop Machine 机制**：与 `kernel/stop_machine.c` 深度集成，后者负责创建和管理 per-CPU stop 任务，并触发其执行。\n- **时间子系统**：使用 `rq_clock_task()` 获取任务执行时间戳，依赖内核时间管理基础设施。\n\n## 5. 使用场景\n\n- **`stop_machine()` 执行**：当内核需要在所有在线 CPU 上同步执行一段不能被中断的代码时（如修改全局数据结构、CPU 热插拔），会激活所有 CPU 的 stop 任务。\n- **CPU 热插拔**：在 CPU 上线或下线过程中，使用 stop 任务确保目标 CPU 处于可控状态，避免调度干扰。\n- **内核关键路径保护**：在极少数需要完全禁止调度器干预的内核关键操作中，临时启用 stop 任务以获得独占 CPU 的能力。\n- **调试与诊断**：某些内核调试机制可能利用 stop 任务来冻结系统状态进行分析。",
      "similarity": 0.5952311754226685,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 12,
          "end_line": 64,
          "content": [
            "static int",
            "select_task_rq_stop(struct task_struct *p, int cpu, int flags)",
            "{",
            "\treturn task_cpu(p); /* stop tasks as never migrate */",
            "}",
            "static int",
            "balance_stop(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)",
            "{",
            "\treturn sched_stop_runnable(rq);",
            "}",
            "static void",
            "wakeup_preempt_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\t/* we're never preempted */",
            "}",
            "static void set_next_task_stop(struct rq *rq, struct task_struct *stop, bool first)",
            "{",
            "\tstop->se.exec_start = rq_clock_task(rq);",
            "}",
            "static void",
            "enqueue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tadd_nr_running(rq, 1);",
            "}",
            "static bool",
            "dequeue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tsub_nr_running(rq, 1);",
            "\treturn true;",
            "}",
            "static void yield_task_stop(struct rq *rq)",
            "{",
            "\tBUG(); /* the stop task should never yield, its pointless. */",
            "}",
            "static void put_prev_task_stop(struct rq *rq, struct task_struct *prev, struct task_struct *next)",
            "{",
            "\tupdate_curr_common(rq);",
            "}",
            "static void task_tick_stop(struct rq *rq, struct task_struct *curr, int queued)",
            "{",
            "}",
            "static void switched_to_stop(struct rq *rq, struct task_struct *p)",
            "{",
            "\tBUG(); /* its impossible to change to this class */",
            "}",
            "static void",
            "prio_changed_stop(struct rq *rq, struct task_struct *p, int oldprio)",
            "{",
            "\tBUG(); /* how!?, what priority? */",
            "}",
            "static void update_curr_stop(struct rq *rq)",
            "{",
            "}"
          ],
          "function_name": "select_task_rq_stop, balance_stop, wakeup_preempt_stop, set_next_task_stop, enqueue_task_stop, dequeue_task_stop, yield_task_stop, put_prev_task_stop, task_tick_stop, switched_to_stop, prio_changed_stop, update_curr_stop",
          "description": "实现stop任务调度类的核心操作，包括CPU选择、负载均衡、抢占唤醒、任务添加删除、时间统计更新等，强制禁止任务迁移和抢占以保证系统中断处理优先级",
          "similarity": 0.5766570568084717
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * stop-task scheduling class.",
            " *",
            " * The stop task is the highest priority task in the system, it preempts",
            " * everything and will be preempted by nothing.",
            " *",
            " * See kernel/stop_machine.c",
            " */",
            "",
            "#ifdef CONFIG_SMP"
          ],
          "function_name": null,
          "description": "定义stop任务调度类的框架，启用SMP配置时提供最高优先级调度策略，通过禁用任务迁移和抢占实现系统级中断控制",
          "similarity": 0.5462921857833862
        }
      ]
    }
  ]
}