{
  "query": "linux如何实现内存管理？",
  "timestamp": "2025-11-01 15:43:44",
  "retrieved_files": [
    {
      "source_file": "kernel/power/user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:28:21\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\user.c`\n\n---\n\n# power/user.c 技术文档\n\n## 1. 文件概述\n\n`power/user.c` 是 Linux 内核中实现用户空间与休眠（Hibernate）/恢复（Resume）功能交互的核心接口文件。该文件通过字符设备 `/dev/snapshot` 向用户空间提供对系统内存快照的读写能力，支持创建休眠镜像（保存系统状态）和从镜像恢复系统状态。它实现了软件休眠机制的用户态控制路径，是 hibernation 子系统的关键组成部分。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct snapshot_data`**：保存当前快照操作的上下文状态，包括：\n  - `handle`：快照操作句柄（`struct snapshot_handle`）\n  - `swap`：使用的交换分区类型索引\n  - `mode`：打开模式（`O_RDONLY` 表示休眠，`O_WRONLY` 表示恢复）\n  - `frozen`：是否已冻结用户进程\n  - `ready`：快照是否准备就绪\n  - `platform_support`：是否启用平台特定的休眠支持（如 ACPI S4）\n  - `free_bitmaps`：是否需要释放内存位图\n  - `dev`：恢复所用的设备号\n\n- **`static bool need_wait`**：标志是否需要等待设备探测完成（用于恢复流程）\n\n### 主要函数\n- **`snapshot_open()`**：设备打开函数，初始化快照上下文，根据打开模式（读/写）执行休眠或恢复的前期准备。\n- **`snapshot_release()`**：设备关闭函数，清理资源，释放内存位图，解冻进程，发送 PM 通知。\n- **`snapshot_read()`**：从内存快照中读取数据到用户空间（用于休眠时保存镜像）。\n- **`snapshot_write()`**：从用户空间写入数据到内存快照（用于恢复时加载镜像）。\n- **`snapshot_ioctl()`**：设备控制接口，支持多种休眠/恢复控制命令。\n- **`snapshot_set_swap_area()`**：设置恢复时使用的交换区域（兼容 32/64 位系统调用）。\n- **`is_hibernate_resume_dev()`**：判断指定设备是否为当前休眠恢复设备。\n\n### 关键 ioctl 命令\n- `SNAPSHOT_FREEZE`：冻结用户空间进程。\n- `SNAPSHOT_UNFREEZE`：解冻用户空间进程。\n- `SNAPSHOT_CREATE_IMAGE`：创建内存快照镜像（休眠）。\n- `SNAPSHOT_ATOMIC_RESTORE`：原子性地从镜像恢复系统。\n- `SNAPSHOT_FREE`：释放快照相关内存。\n- `SNAPSHOT_PREF_IMAGE_SIZE` / `SNAPSHOT_GET_IMAGE_SIZE`：设置/获取镜像大小。\n- `SNAPSHOT_AVAIL_SWAP_SIZE` / `SNAPSHOT_ALLOC_SWAP_PAGE`：管理交换空间分配。\n\n## 3. 关键实现\n\n### 休眠（Suspend-to-Disk）流程\n1. 用户空间以 `O_RDONLY` 打开 `/dev/snapshot`。\n2. 调用 `SNAPSHOT_FREEZE` 冻结所有用户进程。\n3. 调用 `SNAPSHOT_CREATE_IMAGE` 创建内存快照，内核将可恢复的内存页信息组织成镜像。\n4. 用户空间通过 `read()` 系统调用从设备读取镜像数据，并写入交换分区。\n5. 系统关机。\n\n### 恢复（Resume）流程\n1. 启动时内核检测到休眠镜像，但用户空间需主动参与恢复。\n2. 用户空间以 `O_WRONLY` 打开 `/dev/snapshot`。\n3. 通过 `ioctl(SNAPSHOT_SET_SWAP_AREA)` 指定镜像所在的交换设备。\n4. 用户空间从交换分区读取镜像数据，通过 `write()` 写入 `/dev/snapshot`。\n5. 调用 `SNAPSHOT_FREEZE` 冻结当前进程（为恢复做准备）。\n6. 调用 `SNAPSHOT_ATOMIC_RESTORE` 触发内核原子恢复，跳转回休眠时的执行上下文。\n\n### 内存管理\n- 使用 `create_basic_memory_bitmaps()` / `free_basic_memory_bitmaps()` 管理内存页的位图，标记哪些页需要保存/恢复。\n- 通过 `swsusp_free()` 释放休眠专用的内存缓冲区。\n- `alloc_swapdev_block()` 用于在休眠过程中分配交换页。\n\n### 同步与锁机制\n- 使用 `lock_system_sleep()` / `unlock_system_sleep()` 确保休眠操作的原子性。\n- 通过 `mutex_trylock(&system_transition_mutex)` 防止并发的系统状态转换。\n- `lock_device_hotplug()` 防止设备热插拔干扰休眠过程。\n\n### 兼容性处理\n- 通过 `in_compat_syscall()` 区分 32 位和 64 位系统调用，使用 `compat_resume_swap_area` 结构保证 ABI 兼容。\n\n## 4. 依赖关系\n\n- **`<linux/suspend.h>` / `power.h`**：休眠核心逻辑和数据结构定义。\n- **`<linux/swap.h>` / `<linux/swapops.h>`**：交换子系统接口，用于管理休眠镜像的存储。\n- **`<linux/freezer.h>`**：进程冻结/解冻机制。\n- **`<linux/pm.h>`**：电源管理通知链（`pm_notifier_call_chain`）。\n- **`<linux/miscdevice.h>`**：注册 `/dev/snapshot` 字符设备。\n- **`<linux/uaccess.h>`**：用户空间内存访问（`copy_from_user` 等）。\n- **`<linux/compat.h>`**：32/64 位系统调用兼容层。\n- **`hibernate.c`**：依赖 `hibernate_acquire()` / `hibernate_release()` 管理休眠资源。\n\n## 5. 使用场景\n\n- **系统休眠（Hibernation）**：当用户执行 `systemctl hibernate` 或类似命令时，用户空间工具（如 `uswsusp` 或 `systemd-hibernate`) 通过此接口保存系统状态到交换分区。\n- **系统恢复（Resume）**：在内核启动早期，initramfs 中的恢复工具（如 `resume` 脚本）通过此接口从交换分区加载镜像并触发恢复。\n- **调试与测试**：开发人员可通过直接操作 `/dev/snapshot` 设备测试休眠/恢复逻辑。\n- **定制休眠方案**：嵌入式或特殊用途系统可基于此接口实现自定义的休眠存储后端（如存储到文件而非交换分区）。",
      "similarity": 0.6618199944496155,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/power/user.c",
          "start_line": 424,
          "end_line": 444,
          "content": [
            "static long",
            "snapshot_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
            "{",
            "\tBUILD_BUG_ON(sizeof(loff_t) != sizeof(compat_loff_t));",
            "",
            "\tswitch (cmd) {",
            "\tcase SNAPSHOT_GET_IMAGE_SIZE:",
            "\tcase SNAPSHOT_AVAIL_SWAP_SIZE:",
            "\tcase SNAPSHOT_ALLOC_SWAP_PAGE:",
            "\tcase SNAPSHOT_CREATE_IMAGE:",
            "\tcase SNAPSHOT_SET_SWAP_AREA:",
            "\t\treturn snapshot_ioctl(file, cmd,",
            "\t\t\t\t      (unsigned long) compat_ptr(arg));",
            "\tdefault:",
            "\t\treturn snapshot_ioctl(file, cmd, arg);",
            "\t}",
            "}",
            "static int __init snapshot_device_init(void)",
            "{",
            "\treturn misc_register(&snapshot_device);",
            "};"
          ],
          "function_name": "snapshot_compat_ioctl, snapshot_device_init",
          "description": "提供32位兼容性的ioctl处理函数和设备初始化函数，注册快照字符设备驱动以实现用户空间与内核电源管理子系统的交互。",
          "similarity": 0.5899317264556885
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/power/user.c",
          "start_line": 168,
          "end_line": 414,
          "content": [
            "static ssize_t snapshot_write(struct file *filp, const char __user *buf,",
            "                              size_t count, loff_t *offp)",
            "{",
            "\tloff_t pg_offp = *offp & ~PAGE_MASK;",
            "\tstruct snapshot_data *data;",
            "\tunsigned long sleep_flags;",
            "\tssize_t res;",
            "",
            "\tif (need_wait) {",
            "\t\twait_for_device_probe();",
            "\t\tneed_wait = false;",
            "\t}",
            "",
            "\tsleep_flags = lock_system_sleep();",
            "",
            "\tdata = filp->private_data;",
            "",
            "\tif (!pg_offp) {",
            "\t\tres = snapshot_write_next(&data->handle);",
            "\t\tif (res <= 0)",
            "\t\t\tgoto unlock;",
            "\t} else {",
            "\t\tres = PAGE_SIZE;",
            "\t}",
            "",
            "\tif (!data_of(data->handle)) {",
            "\t\tres = -EINVAL;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,",
            "\t\t\tbuf, count);",
            "\tif (res > 0)",
            "\t\t*offp += res;",
            "unlock:",
            "\tunlock_system_sleep(sleep_flags);",
            "",
            "\treturn res;",
            "}",
            "static int snapshot_set_swap_area(struct snapshot_data *data,",
            "\t\tvoid __user *argp)",
            "{",
            "\tsector_t offset;",
            "\tdev_t swdev;",
            "",
            "\tif (swsusp_swap_in_use())",
            "\t\treturn -EPERM;",
            "",
            "\tif (in_compat_syscall()) {",
            "\t\tstruct compat_resume_swap_area swap_area;",
            "",
            "\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))",
            "\t\t\treturn -EFAULT;",
            "\t\tswdev = new_decode_dev(swap_area.dev);",
            "\t\toffset = swap_area.offset;",
            "\t} else {",
            "\t\tstruct resume_swap_area swap_area;",
            "",
            "\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))",
            "\t\t\treturn -EFAULT;",
            "\t\tswdev = new_decode_dev(swap_area.dev);",
            "\t\toffset = swap_area.offset;",
            "\t}",
            "",
            "\t/*",
            "\t * User space encodes device types as two-byte values,",
            "\t * so we need to recode them",
            "\t */",
            "\tdata->swap = swap_type_of(swdev, offset);",
            "\tif (data->swap < 0)",
            "\t\treturn swdev ? -ENODEV : -EINVAL;",
            "\tdata->dev = swdev;",
            "\treturn 0;",
            "}",
            "static long snapshot_ioctl(struct file *filp, unsigned int cmd,",
            "\t\t\t\t\t\t\tunsigned long arg)",
            "{",
            "\tint error = 0;",
            "\tstruct snapshot_data *data;",
            "\tloff_t size;",
            "\tsector_t offset;",
            "",
            "\tif (need_wait) {",
            "\t\twait_for_device_probe();",
            "\t\tneed_wait = false;",
            "\t}",
            "",
            "\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)",
            "\t\treturn -ENOTTY;",
            "\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)",
            "\t\treturn -ENOTTY;",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tif (!mutex_trylock(&system_transition_mutex))",
            "\t\treturn -EBUSY;",
            "",
            "\tlock_device_hotplug();",
            "\tdata = filp->private_data;",
            "",
            "\tswitch (cmd) {",
            "",
            "\tcase SNAPSHOT_FREEZE:",
            "\t\tif (data->frozen)",
            "\t\t\tbreak;",
            "",
            "\t\tksys_sync_helper();",
            "",
            "\t\terror = freeze_processes();",
            "\t\tif (error)",
            "\t\t\tbreak;",
            "",
            "\t\terror = create_basic_memory_bitmaps();",
            "\t\tif (error)",
            "\t\t\tthaw_processes();",
            "\t\telse",
            "\t\t\tdata->frozen = true;",
            "",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_UNFREEZE:",
            "\t\tif (!data->frozen || data->ready)",
            "\t\t\tbreak;",
            "\t\tpm_restore_gfp_mask();",
            "\t\tfree_basic_memory_bitmaps();",
            "\t\tdata->free_bitmaps = false;",
            "\t\tthaw_processes();",
            "\t\tdata->frozen = false;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_CREATE_IMAGE:",
            "\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tpm_restore_gfp_mask();",
            "\t\terror = hibernation_snapshot(data->platform_support);",
            "\t\tif (!error) {",
            "\t\t\terror = put_user(in_suspend, (int __user *)arg);",
            "\t\t\tdata->ready = !freezer_test_done && !error;",
            "\t\t\tfreezer_test_done = false;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_ATOMIC_RESTORE:",
            "\t\tsnapshot_write_finalize(&data->handle);",
            "\t\tif (data->mode != O_WRONLY || !data->frozen ||",
            "\t\t    !snapshot_image_loaded(&data->handle)) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\terror = hibernation_restore(data->platform_support);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_FREE:",
            "\t\tswsusp_free();",
            "\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));",
            "\t\tdata->ready = false;",
            "\t\t/*",
            "\t\t * It is necessary to thaw kernel threads here, because",
            "\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after",
            "\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not",
            "\t\t * thawed, the preallocation of memory carried out by",
            "\t\t * hibernation_snapshot() might run into problems (i.e. it",
            "\t\t * might fail or even deadlock).",
            "\t\t */",
            "\t\tthaw_kernel_threads();",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_PREF_IMAGE_SIZE:",
            "\t\timage_size = arg;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_GET_IMAGE_SIZE:",
            "\t\tif (!data->ready) {",
            "\t\t\terror = -ENODATA;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tsize = snapshot_get_image_size();",
            "\t\tsize <<= PAGE_SHIFT;",
            "\t\terror = put_user(size, (loff_t __user *)arg);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_AVAIL_SWAP_SIZE:",
            "\t\tsize = count_swap_pages(data->swap, 1);",
            "\t\tsize <<= PAGE_SHIFT;",
            "\t\terror = put_user(size, (loff_t __user *)arg);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_ALLOC_SWAP_PAGE:",
            "\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {",
            "\t\t\terror = -ENODEV;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\toffset = alloc_swapdev_block(data->swap);",
            "\t\tif (offset) {",
            "\t\t\toffset <<= PAGE_SHIFT;",
            "\t\t\terror = put_user(offset, (loff_t __user *)arg);",
            "\t\t} else {",
            "\t\t\terror = -ENOSPC;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_FREE_SWAP_PAGES:",
            "\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {",
            "\t\t\terror = -ENODEV;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tfree_all_swap_pages(data->swap);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_S2RAM:",
            "\t\tif (!data->frozen) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Tasks are frozen and the notifiers have been called with",
            "\t\t * PM_HIBERNATION_PREPARE",
            "\t\t */",
            "\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);",
            "\t\tdata->ready = false;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_PLATFORM_SUPPORT:",
            "\t\tdata->platform_support = !!arg;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_POWER_OFF:",
            "\t\tif (data->platform_support)",
            "\t\t\terror = hibernation_platform_enter();",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_SET_SWAP_AREA:",
            "\t\terror = snapshot_set_swap_area(data, (void __user *)arg);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\terror = -ENOTTY;",
            "",
            "\t}",
            "",
            "\tunlock_device_hotplug();",
            "\tmutex_unlock(&system_transition_mutex);",
            "",
            "\treturn error;",
            "}"
          ],
          "function_name": "snapshot_write, snapshot_set_swap_area, snapshot_ioctl",
          "description": "实现快照设备的写入、交换区设置和通用控制命令处理，包含对内存镜像创建、恢复、页面分配等关键操作的支持，并通过ioctl接口暴露多种系统控制功能。",
          "similarity": 0.5874403715133667
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/power/user.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * linux/kernel/power/user.c",
            " *",
            " * This file provides the user space interface for software suspend/resume.",
            " *",
            " * Copyright (C) 2006 Rafael J. Wysocki <rjw@sisk.pl>",
            " */",
            "",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pm.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/console.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#include \"power.h\"",
            "",
            "static bool need_wait;",
            "",
            "static struct snapshot_data {",
            "\tstruct snapshot_handle handle;",
            "\tint swap;",
            "\tint mode;",
            "\tbool frozen;",
            "\tbool ready;",
            "\tbool platform_support;",
            "\tbool free_bitmaps;",
            "\tdev_t dev;",
            "} snapshot_state;",
            ""
          ],
          "function_name": null,
          "description": "定义了支持软件挂起/恢复的用户空间接口所需的全局变量和辅助结构体，包括用于跟踪快照状态的snapshot_state结构体及need_wait标志位。",
          "similarity": 0.4914015233516693
        }
      ]
    },
    {
      "source_file": "kernel/power/hibernate.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:21:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\hibernate.c`\n\n---\n\n# `power/hibernate.c` 技术文档\n\n## 1. 文件概述\n\n`power/hibernate.c` 是 Linux 内核中实现**休眠（Hibernation，又称 Suspend-to-Disk）**功能的核心源文件。该文件负责协调系统进入和退出休眠状态的全过程，包括冻结用户空间进程、保存内存镜像到磁盘（通常为交换分区）、关闭系统，以及在下次启动时从磁盘恢复内存状态并唤醒系统。它提供了平台无关的休眠控制逻辑，并通过 `platform_hibernation_ops` 接口支持特定硬件平台的定制化操作。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `nocompress`, `noresume`, `nohibernate`, `resume_wait`, `resume_delay`: 控制休眠行为的内核启动参数标志。\n- `resume_file[256]`: 指定用于恢复的设备路径（默认为 `CONFIG_PM_STD_PARTITION`）。\n- `swsusp_resume_device` / `swsusp_resume_block`: 解析后的恢复设备标识（设备号 + 起始扇区）。\n- `in_suspend`: 标记系统是否正处于休眠流程中（使用 `__nosavedata` 避免被休眠镜像保存）。\n- `hibernation_mode`: 当前休眠模式（如 `HIBERNATION_SHUTDOWN`, `HIBERNATION_PLATFORM` 等）。\n- `freezer_test_done`: 用于调试，标记冻结测试是否完成。\n- `hibernation_ops`: 指向平台特定休眠操作的回调函数结构体。\n- `hibernate_atomic`: 原子计数器，用于确保休眠操作的互斥性。\n\n### 主要函数\n- **休眠控制接口**:\n  - `hibernate_acquire()` / `hibernate_release()`: 获取/释放休眠操作权限（基于原子计数器）。\n  - `hibernation_in_progress()`: 检查是否有休眠正在进行。\n  - `hibernation_available()`: 判断当前系统是否允许休眠（检查安全锁定、secret memory 等限制）。\n  - `hibernation_set_ops()`: 设置平台特定的休眠操作回调（导出符号）。\n  - `system_entering_hibernation()`: 查询是否正在执行平台休眠（导出符号）。\n\n- **平台操作封装**:\n  - `platform_begin()`, `platform_end()`, `platform_pre_snapshot()`, `platform_leave()`, `platform_finish()`, `platform_pre_restore()`, `platform_restore_cleanup()`, `platform_recover()`: 封装对 `hibernation_ops` 中各回调函数的调用，处理平台模式开关逻辑。\n\n- **辅助功能**:\n  - `swsusp_show_speed()`: 计算并打印休眠/恢复过程中的 I/O 速度（如内存页保存/加载速率）。\n  - `arch_resume_nosmt()` (弱符号): 架构相关函数，用于在恢复后禁用同步多线程（SMT）。\n\n- **调试支持** (`CONFIG_PM_DEBUG`):\n  - `hibernation_test()`: 在指定测试级别下模拟休眠延迟，用于验证恢复流程。\n\n## 3. 关键实现\n\n### 休眠流程控制\n- 使用 `hibernate_atomic` 原子变量实现**单次休眠互斥**：`hibernate_acquire()` 尝试将计数器减 1（仅当值为 1 时成功），确保同一时间只有一个休眠操作进行。\n- `hibernation_available()` 综合判断休眠可行性：需未设置 `nohibernate`、未被内核锁定（`LOCKDOWN_HIBERNATION`）、且无 `secretmem` 或 CXL 内存活动。\n\n### 平台操作抽象\n- 通过 `struct platform_hibernation_ops` 提供**平台无关的休眠框架**。该结构体包含完整的休眠生命周期回调（如 `begin`, `pre_snapshot`, `enter`, `pre_restore`, `leave` 等）。\n- `hibernation_set_ops()` 在设置有效操作集时自动切换 `hibernation_mode` 为 `HIBERNATION_PLATFORM`；若取消设置则回退到 `HIBERNATION_SHUTDOWN`。\n- 所有平台操作函数（如 `platform_pre_snapshot()`）均通过 `platform_mode` 参数和 `hibernation_ops` 指针进行条件调用，保证无平台支持时的兼容性。\n\n### 调试与性能监控\n- `swsusp_show_speed()` 利用高精度时间戳（`ktime_t`）计算操作耗时，并以 **KB/s 和 MB/s** 格式输出内存镜像处理速度，便于性能分析。\n- `CONFIG_PM_DEBUG` 编译选项启用休眠测试模式：`hibernation_test()` 可在指定阶段插入延迟，模拟休眠后立即恢复，用于验证恢复路径。\n\n### 安全与限制\n- 集成内核安全机制：通过 `security_locked_down(LOCKDOWN_HIBERNATION)` 阻止在锁定状态下休眠。\n- 检测特殊内存使用：`secretmem_active()` 和 `cxl_mem_active()` 确保敏感内存或 CXL 设备未激活时才允许休眠，防止数据泄露或状态不一致。\n\n## 4. 依赖关系\n\n- **头文件依赖**:\n  - `<linux/suspend.h>`, `<linux/pm.h>`: 电源管理核心接口和数据结构。\n  - `<linux/blkdev.h>`, `<linux/fs.h>`: 用于访问休眠镜像存储设备（块设备/文件系统）。\n  - `<linux/freezer.h>`: 进程冻结/解冻机制。\n  - `<linux/security.h>`: 内核安全锁定检查。\n  - `<linux/secretmem.h>`, `<linux/cxl_mem.h>`: 特殊内存活动检测。\n  - `\"power.h\"`: 本地电源管理私有头文件。\n\n- **模块交互**:\n  - **设备驱动**: 通过 `device_suspend()`/`device_resume()` 调用驱动的休眠/恢复回调。\n  - **内存快照子系统** (`swsusp`): 依赖 `kernel/power/snapshot.c` 实现内存镜像的创建与恢复。\n  - **交换子系统**: 休眠镜像通常写入交换分区，需与 `mm/swapfile.c` 协同。\n  - **平台驱动**: 通过 `hibernation_set_ops()` 注册的平台驱动（如 ACPI）提供硬件特定操作。\n\n## 5. 使用场景\n\n- **系统休眠 (Suspend-to-Disk)**:\n  - 用户执行 `echo disk > /sys/power/state` 时，内核调用此文件中的流程保存内存状态到磁盘并关机。\n  - 下次开机时，引导加载程序（如 GRUB）检测到休眠镜像，内核通过 `resume=` 参数指定的设备加载镜像并恢复系统状态。\n\n- **混合休眠 (Hybrid Sleep)**:\n  - 结合 `suspend-to-ram` 和 `suspend-to-disk`，先休眠到内存，若电源失效则从磁盘恢复。\n\n- **内核调试与测试**:\n  - 通过 `pm_test_level` 和 `pm_test_delay` 参数测试休眠恢复路径的正确性。\n  - 使用 `swsusp_show_speed()` 分析休眠/恢复性能瓶颈。\n\n- **安全敏感环境**:\n  - 在启用了内核锁定（Lockdown）或使用 `secretmem` 的系统中，自动禁用休眠功能以保障安全。",
      "similarity": 0.6607102155685425,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/power/hibernate.c",
          "start_line": 289,
          "end_line": 436,
          "content": [
            "__weak int arch_resume_nosmt(void)",
            "{",
            "\treturn 0;",
            "}",
            "static int create_image(int platform_mode)",
            "{",
            "\tint error;",
            "",
            "\terror = dpm_suspend_end(PMSG_FREEZE);",
            "\tif (error) {",
            "\t\tpr_err(\"Some devices failed to power down, aborting\\n\");",
            "\t\treturn error;",
            "\t}",
            "",
            "\terror = platform_pre_snapshot(platform_mode);",
            "\tif (error || hibernation_test(TEST_PLATFORM))",
            "\t\tgoto Platform_finish;",
            "",
            "\terror = pm_sleep_disable_secondary_cpus();",
            "\tif (error || hibernation_test(TEST_CPUS))",
            "\t\tgoto Enable_cpus;",
            "",
            "\tlocal_irq_disable();",
            "",
            "\tsystem_state = SYSTEM_SUSPEND;",
            "",
            "\terror = syscore_suspend();",
            "\tif (error) {",
            "\t\tpr_err(\"Some system devices failed to power down, aborting\\n\");",
            "\t\tgoto Enable_irqs;",
            "\t}",
            "",
            "\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())",
            "\t\tgoto Power_up;",
            "",
            "\tin_suspend = 1;",
            "\tsave_processor_state();",
            "\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);",
            "\terror = swsusp_arch_suspend();",
            "\t/* Restore control flow magically appears here */",
            "\trestore_processor_state();",
            "\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);",
            "\tif (error)",
            "\t\tpr_err(\"Error %d creating image\\n\", error);",
            "",
            "\tif (!in_suspend) {",
            "\t\tevents_check_enabled = false;",
            "\t\tclear_or_poison_free_pages();",
            "\t}",
            "",
            "\tplatform_leave(platform_mode);",
            "",
            " Power_up:",
            "\tsyscore_resume();",
            "",
            " Enable_irqs:",
            "\tsystem_state = SYSTEM_RUNNING;",
            "\tlocal_irq_enable();",
            "",
            " Enable_cpus:",
            "\tpm_sleep_enable_secondary_cpus();",
            "",
            "\t/* Allow architectures to do nosmt-specific post-resume dances */",
            "\tif (!in_suspend)",
            "\t\terror = arch_resume_nosmt();",
            "",
            " Platform_finish:",
            "\tplatform_finish(platform_mode);",
            "",
            "\tdpm_resume_start(in_suspend ?",
            "\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);",
            "",
            "\treturn error;",
            "}",
            "int hibernation_snapshot(int platform_mode)",
            "{",
            "\tpm_message_t msg;",
            "\tint error;",
            "",
            "\tpm_suspend_clear_flags();",
            "\terror = platform_begin(platform_mode);",
            "\tif (error)",
            "\t\tgoto Close;",
            "",
            "\t/* Preallocate image memory before shutting down devices. */",
            "\terror = hibernate_preallocate_memory();",
            "\tif (error)",
            "\t\tgoto Close;",
            "",
            "\terror = freeze_kernel_threads();",
            "\tif (error)",
            "\t\tgoto Cleanup;",
            "",
            "\tif (hibernation_test(TEST_FREEZER)) {",
            "",
            "\t\t/*",
            "\t\t * Indicate to the caller that we are returning due to a",
            "\t\t * successful freezer test.",
            "\t\t */",
            "\t\tfreezer_test_done = true;",
            "\t\tgoto Thaw;",
            "\t}",
            "",
            "\terror = dpm_prepare(PMSG_FREEZE);",
            "\tif (error) {",
            "\t\tdpm_complete(PMSG_RECOVER);",
            "\t\tgoto Thaw;",
            "\t}",
            "",
            "\tsuspend_console();",
            "\tpm_restrict_gfp_mask();",
            "",
            "\terror = dpm_suspend(PMSG_FREEZE);",
            "",
            "\tif (error || hibernation_test(TEST_DEVICES))",
            "\t\tplatform_recover(platform_mode);",
            "\telse",
            "\t\terror = create_image(platform_mode);",
            "",
            "\t/*",
            "\t * In the case that we call create_image() above, the control",
            "\t * returns here (1) after the image has been created or the",
            "\t * image creation has failed and (2) after a successful restore.",
            "\t */",
            "",
            "\t/* We may need to release the preallocated image pages here. */",
            "\tif (error || !in_suspend)",
            "\t\tswsusp_free();",
            "",
            "\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;",
            "\tdpm_resume(msg);",
            "",
            "\tif (error || !in_suspend)",
            "\t\tpm_restore_gfp_mask();",
            "",
            "\tresume_console();",
            "\tdpm_complete(msg);",
            "",
            " Close:",
            "\tplatform_end(platform_mode);",
            "\treturn error;",
            "",
            " Thaw:",
            "\tthaw_kernel_threads();",
            " Cleanup:",
            "\tswsusp_free();",
            "\tgoto Close;",
            "}"
          ],
          "function_name": "arch_resume_nosmt, create_image, hibernation_snapshot",
          "description": "create_image负责执行设备关闭、内存保存和磁盘镜像创建，hibernation_snapshot冻结内核线程、准备设备并启动实际挂起流程，通过syscore_suspend/dpm_suspend协调硬件设备状态转换，最终调用swsusp_arch_suspend完成数据持久化。",
          "similarity": 0.5900560617446899
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/power/hibernate.c",
          "start_line": 455,
          "end_line": 626,
          "content": [
            "int __weak hibernate_resume_nonboot_cpu_disable(void)",
            "{",
            "\treturn suspend_disable_secondary_cpus();",
            "}",
            "static int resume_target_kernel(bool platform_mode)",
            "{",
            "\tint error;",
            "",
            "\terror = dpm_suspend_end(PMSG_QUIESCE);",
            "\tif (error) {",
            "\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");",
            "\t\treturn error;",
            "\t}",
            "",
            "\terror = platform_pre_restore(platform_mode);",
            "\tif (error)",
            "\t\tgoto Cleanup;",
            "",
            "\tcpuidle_pause();",
            "",
            "\terror = hibernate_resume_nonboot_cpu_disable();",
            "\tif (error)",
            "\t\tgoto Enable_cpus;",
            "",
            "\tlocal_irq_disable();",
            "\tsystem_state = SYSTEM_SUSPEND;",
            "",
            "\terror = syscore_suspend();",
            "\tif (error)",
            "\t\tgoto Enable_irqs;",
            "",
            "\tsave_processor_state();",
            "\terror = restore_highmem();",
            "\tif (!error) {",
            "\t\terror = swsusp_arch_resume();",
            "\t\t/*",
            "\t\t * The code below is only ever reached in case of a failure.",
            "\t\t * Otherwise, execution continues at the place where",
            "\t\t * swsusp_arch_suspend() was called.",
            "\t\t */",
            "\t\tBUG_ON(!error);",
            "\t\t/*",
            "\t\t * This call to restore_highmem() reverts the changes made by",
            "\t\t * the previous one.",
            "\t\t */",
            "\t\trestore_highmem();",
            "\t}",
            "\t/*",
            "\t * The only reason why swsusp_arch_resume() can fail is memory being",
            "\t * very tight, so we have to free it as soon as we can to avoid",
            "\t * subsequent failures.",
            "\t */",
            "\tswsusp_free();",
            "\trestore_processor_state();",
            "\ttouch_softlockup_watchdog();",
            "",
            "\tsyscore_resume();",
            "",
            " Enable_irqs:",
            "\tsystem_state = SYSTEM_RUNNING;",
            "\tlocal_irq_enable();",
            "",
            " Enable_cpus:",
            "\tpm_sleep_enable_secondary_cpus();",
            "",
            " Cleanup:",
            "\tplatform_restore_cleanup(platform_mode);",
            "",
            "\tdpm_resume_start(PMSG_RECOVER);",
            "",
            "\treturn error;",
            "}",
            "int hibernation_restore(int platform_mode)",
            "{",
            "\tint error;",
            "",
            "\tpm_prepare_console();",
            "\tsuspend_console();",
            "\tpm_restrict_gfp_mask();",
            "\terror = dpm_suspend_start(PMSG_QUIESCE);",
            "\tif (!error) {",
            "\t\terror = resume_target_kernel(platform_mode);",
            "\t\t/*",
            "\t\t * The above should either succeed and jump to the new kernel,",
            "\t\t * or return with an error. Otherwise things are just",
            "\t\t * undefined, so let's be paranoid.",
            "\t\t */",
            "\t\tBUG_ON(!error);",
            "\t}",
            "\tdpm_resume_end(PMSG_RECOVER);",
            "\tpm_restore_gfp_mask();",
            "\tresume_console();",
            "\tpm_restore_console();",
            "\treturn error;",
            "}",
            "int hibernation_platform_enter(void)",
            "{",
            "\tint error;",
            "",
            "\tif (!hibernation_ops)",
            "\t\treturn -ENOSYS;",
            "",
            "\t/*",
            "\t * We have cancelled the power transition by running",
            "\t * hibernation_ops->finish() before saving the image, so we should let",
            "\t * the firmware know that we're going to enter the sleep state after all",
            "\t */",
            "\terror = hibernation_ops->begin(PMSG_HIBERNATE);",
            "\tif (error)",
            "\t\tgoto Close;",
            "",
            "\tentering_platform_hibernation = true;",
            "\tsuspend_console();",
            "\terror = dpm_suspend_start(PMSG_HIBERNATE);",
            "\tif (error) {",
            "\t\tif (hibernation_ops->recover)",
            "\t\t\thibernation_ops->recover();",
            "\t\tgoto Resume_devices;",
            "\t}",
            "",
            "\terror = dpm_suspend_end(PMSG_HIBERNATE);",
            "\tif (error)",
            "\t\tgoto Resume_devices;",
            "",
            "\terror = hibernation_ops->prepare();",
            "\tif (error)",
            "\t\tgoto Platform_finish;",
            "",
            "\terror = pm_sleep_disable_secondary_cpus();",
            "\tif (error)",
            "\t\tgoto Enable_cpus;",
            "",
            "\tlocal_irq_disable();",
            "\tsystem_state = SYSTEM_SUSPEND;",
            "",
            "\terror = syscore_suspend();",
            "\tif (error)",
            "\t\tgoto Enable_irqs;",
            "",
            "\tif (pm_wakeup_pending()) {",
            "\t\terror = -EAGAIN;",
            "\t\tgoto Power_up;",
            "\t}",
            "",
            "\thibernation_ops->enter();",
            "\t/* We should never get here */",
            "\twhile (1);",
            "",
            " Power_up:",
            "\tsyscore_resume();",
            " Enable_irqs:",
            "\tsystem_state = SYSTEM_RUNNING;",
            "\tlocal_irq_enable();",
            "",
            " Enable_cpus:",
            "\tpm_sleep_enable_secondary_cpus();",
            "",
            " Platform_finish:",
            "\thibernation_ops->finish();",
            "",
            "\tdpm_resume_start(PMSG_RESTORE);",
            "",
            " Resume_devices:",
            "\tentering_platform_hibernation = false;",
            "\tdpm_resume_end(PMSG_RESTORE);",
            "\tresume_console();",
            "",
            " Close:",
            "\thibernation_ops->end();",
            "",
            "\treturn error;",
            "}"
          ],
          "function_name": "hibernate_resume_nonboot_cpu_disable, resume_target_kernel, hibernation_restore, hibernation_platform_enter",
          "description": "resume_target_kernel处理内核恢复阶段的设备唤醒和内存还原，hibernation_restore负责恢复流程的主逻辑，hibernation_platform_enter调用平台特定的enter方法，协调系统状态转换并处理异常情况，通过syscore_suspend/resume管理底层硬件设备。",
          "similarity": 0.5846570730209351
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/power/hibernate.c",
          "start_line": 1231,
          "end_line": 1333,
          "content": [
            "static ssize_t resume_offset_show(struct kobject *kobj,",
            "\t\t\t\t  struct kobj_attribute *attr, char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%llu\\n\", (unsigned long long)swsusp_resume_block);",
            "}",
            "static ssize_t resume_offset_store(struct kobject *kobj,",
            "\t\t\t\t   struct kobj_attribute *attr, const char *buf,",
            "\t\t\t\t   size_t n)",
            "{",
            "\tunsigned long long offset;",
            "\tint rc;",
            "",
            "\trc = kstrtoull(buf, 0, &offset);",
            "\tif (rc)",
            "\t\treturn rc;",
            "\tswsusp_resume_block = offset;",
            "",
            "\treturn n;",
            "}",
            "static ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t       char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%lu\\n\", image_size);",
            "}",
            "static ssize_t image_size_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\tconst char *buf, size_t n)",
            "{",
            "\tunsigned long size;",
            "",
            "\tif (sscanf(buf, \"%lu\", &size) == 1) {",
            "\t\timage_size = size;",
            "\t\treturn n;",
            "\t}",
            "",
            "\treturn -EINVAL;",
            "}",
            "static ssize_t reserved_size_show(struct kobject *kobj,",
            "\t\t\t\t  struct kobj_attribute *attr, char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%lu\\n\", reserved_size);",
            "}",
            "static ssize_t reserved_size_store(struct kobject *kobj,",
            "\t\t\t\t   struct kobj_attribute *attr,",
            "\t\t\t\t   const char *buf, size_t n)",
            "{",
            "\tunsigned long size;",
            "",
            "\tif (sscanf(buf, \"%lu\", &size) == 1) {",
            "\t\treserved_size = size;",
            "\t\treturn n;",
            "\t}",
            "",
            "\treturn -EINVAL;",
            "}",
            "static int __init pm_disk_init(void)",
            "{",
            "\treturn sysfs_create_group(power_kobj, &attr_group);",
            "}",
            "static int __init resume_setup(char *str)",
            "{",
            "\tif (noresume)",
            "\t\treturn 1;",
            "",
            "\tstrncpy(resume_file, str, 255);",
            "\treturn 1;",
            "}",
            "static int __init resume_offset_setup(char *str)",
            "{",
            "\tunsigned long long offset;",
            "",
            "\tif (noresume)",
            "\t\treturn 1;",
            "",
            "\tif (sscanf(str, \"%llu\", &offset) == 1)",
            "\t\tswsusp_resume_block = offset;",
            "",
            "\treturn 1;",
            "}",
            "static int __init hibernate_setup(char *str)",
            "{",
            "\tif (!strncmp(str, \"noresume\", 8)) {",
            "\t\tnoresume = 1;",
            "\t} else if (!strncmp(str, \"nocompress\", 10)) {",
            "\t\tnocompress = 1;",
            "\t} else if (!strncmp(str, \"no\", 2)) {",
            "\t\tnoresume = 1;",
            "\t\tnohibernate = 1;",
            "\t} else if (IS_ENABLED(CONFIG_STRICT_KERNEL_RWX)",
            "\t\t   && !strncmp(str, \"protect_image\", 13)) {",
            "\t\tenable_restore_image_protection();",
            "\t}",
            "\treturn 1;",
            "}",
            "static int __init noresume_setup(char *str)",
            "{",
            "\tnoresume = 1;",
            "\treturn 1;",
            "}",
            "static int __init resumewait_setup(char *str)",
            "{",
            "\tresume_wait = 1;",
            "\treturn 1;",
            "}"
          ],
          "function_name": "resume_offset_show, resume_offset_store, image_size_show, image_size_store, reserved_size_show, reserved_size_store, pm_disk_init, resume_setup, resume_offset_setup, hibernate_setup, noresume_setup, resumewait_setup",
          "description": "resume_offset_show/store 控制休眠镜像的恢复偏移量配置。image_size_show/store 和 reserved_size_show/store 调整镜像存储区域大小。pm_disk_init 注册 sysfs 属性组，resume_setup 等函数解析命令行参数配置唤醒设备及行为。",
          "similarity": 0.5622690320014954
        }
      ]
    },
    {
      "source_file": "kernel/user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:58\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user.c`\n\n---\n\n# user.c 技术文档\n\n## 1. 文件概述\n\n`user.c` 实现了 Linux 内核中的 **用户缓存（user cache）** 机制，用于跟踪每个用户（以 UID 标识）所占用的系统资源（如进程数、打开文件数等），从而支持基于用户的资源限制（per-user limits）。该文件维护了一个全局的哈希表，用于快速查找和管理 `user_struct` 结构体实例，并提供了用户结构的分配、引用计数管理和释放接口。此外，文件还定义了初始用户命名空间 `init_user_ns` 和根用户结构 `root_user`，为系统启动和用户命名空间功能提供基础支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`init_user_ns`**：全局初始用户命名空间（`struct user_namespace`），作为所有用户命名空间的根，包含完整的 UID/GID/ProjID 映射（0~2³²-1），引用计数初始化为 3。\n- **`root_user`**：代表 UID 为 0 的根用户的 `struct user_struct` 实例，引用计数初始化为 1（供 init 进程使用）。\n- **`uidhash_table`**：大小为 `2^UIDHASH_BITS`（通常为 128）的哈希表，用于存储 `user_struct` 实例，实现 O(1) 平均查找复杂度。\n- **`uid_cachep`**：SLAB 缓存，用于高效分配和释放 `struct user_struct` 对象。\n\n### 主要函数\n\n- **`alloc_uid(kuid_t uid)`**：根据 UID 查找或创建对应的 `user_struct`。若不存在则分配新结构体，初始化资源计数器（如 epoll watches），并插入哈希表；若已存在则增加引用计数。处理并发创建的竞争条件。\n- **`find_user(kuid_t uid)`**：在哈希表中查找指定 UID 的 `user_struct`，若找到则增加引用计数并返回，否则返回 NULL。\n- **`free_uid(struct user_struct *up)`**：减少 `user_struct` 的引用计数，若计数归零则调用 `free_user` 释放资源。\n- **`free_user(struct user_struct *up, unsigned long flags)`**：内部函数，从哈希表中移除用户结构，释放 epoll 计数器，并通过 SLAB 缓存回收内存。\n- **`uid_cache_init(void)`**：初始化函数（通过 `subsys_initcall` 注册），创建 SLAB 缓存、初始化哈希表、为 `root_user` 分配 epoll 计数器，并将 `root_user` 插入哈希表。\n\n### 辅助函数\n\n- **`uid_hash_insert/remove/find`**：哈希表操作的内部封装，必须在持有 `uidhash_lock` 自旋锁时调用。\n- **`user_epoll_alloc/free`**：条件编译函数，用于初始化/销毁 `user_struct` 中的 epoll watches per-CPU 计数器（仅当 `CONFIG_EPOLL` 启用时有效）。\n\n## 3. 关键实现\n\n### 哈希表设计与并发控制\n\n- **哈希函数**：使用 `__uidhashfn(uid) = ((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK`，将 32 位 UID 映射到 `UIDHASH_SZ`（默认 128）个桶中，减少冲突。\n- **锁机制**：使用 `DEFINE_SPINLOCK(uidhash_lock)` 保护哈希表操作。该锁需 **软中断安全（softirq-safe）**，因为 `free_uid()` 可能在 RCU 回调（软中断上下文）中被调用。\n- **中断处理**：所有哈希表操作均使用 `spin_lock_irqsave/restore` 或 `spin_lock_irq/unlock`，确保在中断上下文和进程上下文间的正确同步。\n\n### 引用计数与资源管理\n\n- **引用计数**：`user_struct.__count` 使用 `refcount_t` 类型，确保原子操作。`alloc_uid` 返回时已持有引用，调用者必须通过 `free_uid` 释放。\n- **延迟释放**：`free_uid` 使用 `refcount_dec_and_lock_irqsave` 原子地减少计数并在归零时获取锁，避免竞态条件。\n- **资源初始化**：新创建的 `user_struct` 会初始化速率限制器（`ratelimit`）和 epoll watches 计数器（若启用）。\n\n### 初始化与竞态处理\n\n- **`root_user` 预置**：在 `uid_cache_init` 中预先将 `root_user` 插入哈希表，确保 init 进程可直接使用。\n- **双重检查**：`alloc_uid` 在分配新结构后再次检查哈希表，防止多线程同时创建同一 UID 的 `user_struct`，确保唯一性。\n\n### 用户命名空间支持\n\n- **`init_user_ns`**：作为初始用户命名空间，其 UID/GID 映射覆盖全范围（0 到 2³²-1），标志位 `USERNS_INIT_FLAGS` 启用特定行为（如允许 setgroups）。\n- **密钥环支持**：若启用 `CONFIG_KEYS`，`init_user_ns` 包含密钥环名称列表和读写信号量。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/sched/user.h>`：定义 `struct user_struct`。\n  - `<linux/user_namespace.h>`：定义 `struct user_namespace` 和相关操作。\n  - `<linux/key.h>`：提供密钥环支持（条件编译）。\n  - `<linux/percpu_counter.h>`（隐含）：用于 epoll watches 计数（通过 `CONFIG_EPOLL`）。\n- **内核配置依赖**：\n  - `CONFIG_EPOLL`：控制 epoll watches 计数器的编译。\n  - `CONFIG_USER_NS`：控制用户命名空间操作函数的绑定。\n  - `CONFIG_KEYS`：控制密钥环相关字段的初始化。\n- **子系统依赖**：\n  - **进程调度子系统**：`user_struct` 被嵌入到进程凭证（`cred`）中，用于资源统计。\n  - **用户命名空间子系统**：`init_user_ns` 是用户命名空间层次结构的根。\n  - **内存管理子系统**：依赖 SLAB 分配器管理 `user_struct` 对象。\n\n## 5. 使用场景\n\n- **进程凭证管理**：当进程通过 `setuid()`、`setreuid()` 等系统调用切换用户身份时，内核调用 `alloc_uid` 获取目标 UID 的 `user_struct`，并更新进程凭证中的用户引用。\n- **资源限制实施**：内核在创建进程、打开文件、分配内存等操作时，通过 `current_uid()` 获取当前用户的 `user_struct`，检查并更新资源使用计数（如 `processes`、`files` 字段），确保不超过 `ulimit` 限制。\n- **用户命名空间创建**：新用户命名空间的创建依赖 `init_user_ns` 作为父命名空间，并继承其映射逻辑。\n- **系统初始化**：在内核启动早期（`subsys_initcall` 阶段），初始化用户缓存和根用户结构，为 init 进程（PID 1）提供用户上下文。\n- **资源回收**：当进程退出或切换用户时，通过 `free_uid` 释放不再需要的 `user_struct` 引用，最终在引用计数归零时回收内存和相关资源（如 epoll 计数器）。",
      "similarity": 0.6593042016029358,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/user.c",
          "start_line": 1,
          "end_line": 107,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * The \"user cache\".",
            " *",
            " * (C) Copyright 1991-2000 Linus Torvalds",
            " *",
            " * We have a per-user structure to keep track of how many",
            " * processes, files etc the user has claimed, in order to be",
            " * able to have per-user limits for system resources. ",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "",
            "/*",
            " * userns count is 1 for root user, 1 for init_uts_ns,",
            " * and 1 for... ?",
            " */",
            "struct user_namespace init_user_ns = {",
            "\t.uid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.gid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.projid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.ns.count = REFCOUNT_INIT(3),",
            "\t.owner = GLOBAL_ROOT_UID,",
            "\t.group = GLOBAL_ROOT_GID,",
            "\t.ns.inum = PROC_USER_INIT_INO,",
            "#ifdef CONFIG_USER_NS",
            "\t.ns.ops = &userns_operations,",
            "#endif",
            "\t.flags = USERNS_INIT_FLAGS,",
            "#ifdef CONFIG_KEYS",
            "\t.keyring_name_list = LIST_HEAD_INIT(init_user_ns.keyring_name_list),",
            "\t.keyring_sem = __RWSEM_INITIALIZER(init_user_ns.keyring_sem),",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_user_ns);",
            "",
            "/*",
            " * UID task count cache, to get fast user lookup in \"alloc_uid\"",
            " * when changing user ID's (ie setuid() and friends).",
            " */",
            "",
            "#define UIDHASH_BITS\t(CONFIG_BASE_SMALL ? 3 : 7)",
            "#define UIDHASH_SZ\t(1 << UIDHASH_BITS)",
            "#define UIDHASH_MASK\t\t(UIDHASH_SZ - 1)",
            "#define __uidhashfn(uid)\t(((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK)",
            "#define uidhashentry(uid)\t(uidhash_table + __uidhashfn((__kuid_val(uid))))",
            "",
            "static struct kmem_cache *uid_cachep;",
            "static struct hlist_head uidhash_table[UIDHASH_SZ];",
            "",
            "/*",
            " * The uidhash_lock is mostly taken from process context, but it is",
            " * occasionally also taken from softirq/tasklet context, when",
            " * task-structs get RCU-freed. Hence all locking must be softirq-safe.",
            " * But free_uid() is also called with local interrupts disabled, and running",
            " * local_bh_enable() with local interrupts disabled is an error - we'll run",
            " * softirq callbacks, and they can unconditionally enable interrupts, and",
            " * the caller of free_uid() didn't expect that..",
            " */",
            "static DEFINE_SPINLOCK(uidhash_lock);",
            "",
            "/* root_user.__count is 1, for init task cred */",
            "struct user_struct root_user = {",
            "\t.__count\t= REFCOUNT_INIT(1),",
            "\t.uid\t\t= GLOBAL_ROOT_UID,",
            "\t.ratelimit\t= RATELIMIT_STATE_INIT(root_user.ratelimit, 0, 0),",
            "};",
            "",
            "/*",
            " * These routines must be called with the uidhash spinlock held!",
            " */"
          ],
          "function_name": null,
          "description": "定义初始用户命名空间init_user_ns，配置UID/GID/PROJID映射关系并初始化引用计数，建立全局根用户user_struct结构，通过uidhash_table构建基于哈希的UID快速查找表，设置UID哈希锁及缓存参数",
          "similarity": 0.5492709875106812
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/user.c",
          "start_line": 108,
          "end_line": 167,
          "content": [
            "static void uid_hash_insert(struct user_struct *up, struct hlist_head *hashent)",
            "{",
            "\thlist_add_head(&up->uidhash_node, hashent);",
            "}",
            "static void uid_hash_remove(struct user_struct *up)",
            "{",
            "\thlist_del_init(&up->uidhash_node);",
            "}",
            "static int user_epoll_alloc(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\treturn percpu_counter_init(&up->epoll_watches, 0, GFP_KERNEL);",
            "#else",
            "\treturn 0;",
            "#endif",
            "}",
            "static void user_epoll_free(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\tpercpu_counter_destroy(&up->epoll_watches);",
            "#endif",
            "}",
            "static void free_user(struct user_struct *up, unsigned long flags)",
            "\t__releases(&uidhash_lock)",
            "{",
            "\tuid_hash_remove(up);",
            "\tspin_unlock_irqrestore(&uidhash_lock, flags);",
            "\tuser_epoll_free(up);",
            "\tkmem_cache_free(uid_cachep, up);",
            "}",
            "void free_uid(struct user_struct *up)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!up)",
            "\t\treturn;",
            "",
            "\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))",
            "\t\tfree_user(up, flags);",
            "}",
            "static int __init uid_cache_init(void)",
            "{",
            "\tint n;",
            "",
            "\tuid_cachep = kmem_cache_create(\"uid_cache\", sizeof(struct user_struct),",
            "\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);",
            "",
            "\tfor(n = 0; n < UIDHASH_SZ; ++n)",
            "\t\tINIT_HLIST_HEAD(uidhash_table + n);",
            "",
            "\tif (user_epoll_alloc(&root_user))",
            "\t\tpanic(\"root_user epoll percpu counter alloc failed\");",
            "",
            "\t/* Insert the root user immediately (init already runs as root) */",
            "\tspin_lock_irq(&uidhash_lock);",
            "\tuid_hash_insert(&root_user, uidhashentry(GLOBAL_ROOT_UID));",
            "\tspin_unlock_irq(&uidhash_lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "uid_hash_insert, uid_hash_remove, user_epoll_alloc, user_epoll_free, free_user, free_uid, uid_cache_init",
          "description": "实现用户结构体在UID哈希表中的增删操作，管理epoll计数器资源分配释放，提供free_user/free_uid接口完成用户结构销毁流程，初始化uid_cache缓存及哈希表基础结构并注册根用户",
          "similarity": 0.5231920480728149
        }
      ]
    }
  ]
}