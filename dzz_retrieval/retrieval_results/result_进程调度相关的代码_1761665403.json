{
  "query": "进程调度相关的代码",
  "timestamp": "2025-10-28 23:30:03",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/core_sched.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:00:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\core_sched.c`\n\n---\n\n# `sched/core_sched.c` 技术文档\n\n## 1. 文件概述\n\n`sched/core_sched.c` 是 Linux 内核调度器中用于实现 **核心调度（Core Scheduling）** 功能的核心文件之一。核心调度是一种安全机制，旨在防止来自不同安全上下文的任务在同一个物理 CPU 核心（特别是超线程/SMT 共享核心）上并发执行，从而缓解侧信道攻击（如 Spectre、MDS 等）。\n\n该文件主要负责管理任务的 **调度 cookie**（`core_cookie`），通过引用计数的 cookie 对象将具有相同安全上下文的任务分组，确保只有拥有相同 cookie 的任务才能在同一个 CPU 核心上并发运行。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct sched_core_cookie`**  \n  表示一个调度 cookie，仅包含一个引用计数器 `refcnt`。其内存地址本身即作为 cookie 值使用。\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `sched_core_alloc_cookie()` | 分配一个新的 `sched_core_cookie` 对象，初始化引用计数为 1，并启用核心调度全局状态。返回 cookie 地址（转换为 `unsigned long`）。 |\n| `sched_core_put_cookie(unsigned long cookie)` | 释放 cookie 引用；若引用计数归零，则释放内存并关闭核心调度全局状态。 |\n| `sched_core_get_cookie(unsigned long cookie)` | 增加 cookie 引用计数，返回原 cookie 值。 |\n| `sched_core_update_cookie(struct task_struct *p, unsigned long cookie)` | 原子地更新任务 `p` 的 `core_cookie`，处理任务在运行队列中的入队/出队，并在必要时触发重调度。 |\n| `sched_core_clone_cookie(struct task_struct *p)` | 安全地复制任务 `p` 的当前 cookie（带锁保护），用于 fork 或共享操作。 |\n| `sched_core_fork(struct task_struct *p)` | 在 `fork()` 时初始化子任务的核心调度状态，继承父进程的 cookie。 |\n| `sched_core_free(struct task_struct *p)` | 在任务退出时释放其持有的 cookie 引用。 |\n| `__sched_core_set(struct task_struct *p, unsigned long cookie)` | 设置任务 `p` 的 cookie，自动处理引用计数的获取与释放。 |\n| `sched_core_share_pid(...)` | 用户空间通过 `prctl(PR_SCHED_CORE, ...)` 调用的核心接口，支持创建、查询、共享 cookie。 |\n| `__sched_core_account_forceidle(struct rq *rq)` | （仅当 `CONFIG_SCHEDSTATS` 启用）统计核心强制空闲（force-idle）时间，并分摊到相关任务。 |\n| `__sched_core_tick(struct rq *rq)` | 在调度 tick 中调用，用于更新强制空闲时间统计。 |\n\n## 3. 关键实现\n\n### Cookie 生命周期管理\n- Cookie 通过 `kmalloc` 动态分配，其地址作为唯一标识。\n- 使用 `refcount_t` 实现线程安全的引用计数。\n- `sched_core_get()` / `sched_core_put()` 控制全局核心调度使能状态。\n\n### 任务 Cookie 更新\n- 在 `task_rq_lock()` 保护下更新 `p->core_cookie`，确保调度器一致性。\n- 若任务已在运行队列中，先出队再根据新 cookie 决定是否重新入队。\n- 若任务正在 CPU 上运行，调用 `resched_curr()` 触发重调度，以确保新 cookie 策略立即生效。\n\n### 安全访问控制\n- 通过 `ptrace_may_access()` 检查调用者是否有权限操作目标进程的 cookie。\n- 仅当系统存在 SMT（超线程）时（`sched_smt_present` 为真），才允许使用核心调度功能。\n\n### prctl 接口支持\n- 支持四种命令：\n  - `PR_SCHED_CORE_CREATE`：创建新 cookie。\n  - `PR_SCHED_CORE_SHARE_TO`：将当前进程的 cookie 应用于目标进程（或进程组）。\n  - `PR_SCHED_CORE_SHARE_FROM`：将目标进程的 cookie 应用于当前进程。\n  - `PR_SCHED_CORE_GET`：获取目标进程的 cookie 哈希值（用于用户空间识别）。\n- 支持作用域：线程（`PIDTYPE_PID`）、线程组（`PIDTYPE_TGID`）、进程组（`PIDTYPE_PGID`）。\n\n### 强制空闲时间统计（`CONFIG_SCHEDSTATS`）\n- 当核心因 cookie 不兼容而进入强制空闲状态时，记录空闲时间。\n- 时间按 `core_forceidle_count / core_forceidle_occupation` 比例分摊到所有相关 CPU 上的非 idle 任务。\n- 通过 `__account_forceidle_time()` 更新任务的调度统计信息。\n\n## 4. 依赖关系\n\n- **调度器核心**：依赖 `kernel/sched/` 下的通用调度器基础设施，如 `task_rq_lock()`、`resched_curr()`、`rq` 结构等。\n- **SMT 检测**：依赖 `sched_smt_present` 静态分支判断系统是否支持超线程。\n- **内存管理**：使用 `kmalloc`/`kfree` 进行动态内存分配。\n- **进程管理**：依赖 `find_task_by_vpid()`、`tasklist_lock`、`do_each_pid_thread` 等进程遍历机制。\n- **安全机制**：依赖 `ptrace_may_access()` 进行权限检查。\n- **调度统计**：`__sched_core_account_forceidle` 依赖 `CONFIG_SCHEDSTATS` 和 `__account_forceidle_time`。\n\n## 5. 使用场景\n\n- **安全敏感应用**：如浏览器、虚拟机监控器（VMM）、加密服务等，需防止跨任务的侧信道攻击。\n- **用户空间控制**：通过 `prctl(PR_SCHED_CORE, ...)` 接口，应用程序可显式创建和共享调度 cookie，将信任的任务分组。\n- **进程 fork 行为**：子进程自动继承父进程的 cookie，确保同源任务保持调度兼容性。\n- **系统资源隔离**：在多租户或容器环境中，确保不同租户的任务不会在同一个物理核心上并发执行。\n- **性能调优与监控**：通过 `CONFIG_SCHEDSTATS` 收集核心强制空闲开销，评估安全策略对性能的影响。",
      "similarity": 0.6497458815574646,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 11,
          "end_line": 216,
          "content": [
            "static unsigned long sched_core_alloc_cookie(void)",
            "{",
            "\tstruct sched_core_cookie *ck = kmalloc(sizeof(*ck), GFP_KERNEL);",
            "\tif (!ck)",
            "\t\treturn 0;",
            "",
            "\trefcount_set(&ck->refcnt, 1);",
            "\tsched_core_get();",
            "",
            "\treturn (unsigned long)ck;",
            "}",
            "static void sched_core_put_cookie(unsigned long cookie)",
            "{",
            "\tstruct sched_core_cookie *ptr = (void *)cookie;",
            "",
            "\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {",
            "\t\tkfree(ptr);",
            "\t\tsched_core_put();",
            "\t}",
            "}",
            "static unsigned long sched_core_get_cookie(unsigned long cookie)",
            "{",
            "\tstruct sched_core_cookie *ptr = (void *)cookie;",
            "",
            "\tif (ptr)",
            "\t\trefcount_inc(&ptr->refcnt);",
            "",
            "\treturn cookie;",
            "}",
            "static unsigned long sched_core_update_cookie(struct task_struct *p,",
            "\t\t\t\t\t      unsigned long cookie)",
            "{",
            "\tunsigned long old_cookie;",
            "\tstruct rq_flags rf;",
            "\tstruct rq *rq;",
            "",
            "\trq = task_rq_lock(p, &rf);",
            "",
            "\t/*",
            "\t * Since creating a cookie implies sched_core_get(), and we cannot set",
            "\t * a cookie until after we've created it, similarly, we cannot destroy",
            "\t * a cookie until after we've removed it, we must have core scheduling",
            "\t * enabled here.",
            "\t */",
            "\tSCHED_WARN_ON((p->core_cookie || cookie) && !sched_core_enabled(rq));",
            "",
            "\tif (sched_core_enqueued(p))",
            "\t\tsched_core_dequeue(rq, p, DEQUEUE_SAVE);",
            "",
            "\told_cookie = p->core_cookie;",
            "\tp->core_cookie = cookie;",
            "",
            "\t/*",
            "\t * Consider the cases: !prev_cookie and !cookie.",
            "\t */",
            "\tif (cookie && task_on_rq_queued(p))",
            "\t\tsched_core_enqueue(rq, p);",
            "",
            "\t/*",
            "\t * If task is currently running, it may not be compatible anymore after",
            "\t * the cookie change, so enter the scheduler on its CPU to schedule it",
            "\t * away.",
            "\t *",
            "\t * Note that it is possible that as a result of this cookie change, the",
            "\t * core has now entered/left forced idle state. Defer accounting to the",
            "\t * next scheduling edge, rather than always forcing a reschedule here.",
            "\t */",
            "\tif (task_on_cpu(rq, p))",
            "\t\tresched_curr(rq);",
            "",
            "\ttask_rq_unlock(rq, p, &rf);",
            "",
            "\treturn old_cookie;",
            "}",
            "static unsigned long sched_core_clone_cookie(struct task_struct *p)",
            "{",
            "\tunsigned long cookie, flags;",
            "",
            "\traw_spin_lock_irqsave(&p->pi_lock, flags);",
            "\tcookie = sched_core_get_cookie(p->core_cookie);",
            "\traw_spin_unlock_irqrestore(&p->pi_lock, flags);",
            "",
            "\treturn cookie;",
            "}",
            "void sched_core_fork(struct task_struct *p)",
            "{",
            "\tRB_CLEAR_NODE(&p->core_node);",
            "\tp->core_cookie = sched_core_clone_cookie(current);",
            "}",
            "void sched_core_free(struct task_struct *p)",
            "{",
            "\tsched_core_put_cookie(p->core_cookie);",
            "}",
            "static void __sched_core_set(struct task_struct *p, unsigned long cookie)",
            "{",
            "\tcookie = sched_core_get_cookie(cookie);",
            "\tcookie = sched_core_update_cookie(p, cookie);",
            "\tsched_core_put_cookie(cookie);",
            "}",
            "int sched_core_share_pid(unsigned int cmd, pid_t pid, enum pid_type type,",
            "\t\t\t unsigned long uaddr)",
            "{",
            "\tunsigned long cookie = 0, id = 0;",
            "\tstruct task_struct *task, *p;",
            "\tstruct pid *grp;",
            "\tint err = 0;",
            "",
            "\tif (!static_branch_likely(&sched_smt_present))",
            "\t\treturn -ENODEV;",
            "",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD != PIDTYPE_PID);",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD_GROUP != PIDTYPE_TGID);",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_PROCESS_GROUP != PIDTYPE_PGID);",
            "",
            "\tif (type > PIDTYPE_PGID || cmd >= PR_SCHED_CORE_MAX || pid < 0 ||",
            "\t    (cmd != PR_SCHED_CORE_GET && uaddr))",
            "\t\treturn -EINVAL;",
            "",
            "\trcu_read_lock();",
            "\tif (pid == 0) {",
            "\t\ttask = current;",
            "\t} else {",
            "\t\ttask = find_task_by_vpid(pid);",
            "\t\tif (!task) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\treturn -ESRCH;",
            "\t\t}",
            "\t}",
            "\tget_task_struct(task);",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Check if this process has the right to modify the specified",
            "\t * process. Use the regular \"ptrace_may_access()\" checks.",
            "\t */",
            "\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\terr = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tswitch (cmd) {",
            "\tcase PR_SCHED_CORE_GET:",
            "\t\tif (type != PIDTYPE_PID || uaddr & 7) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tcookie = sched_core_clone_cookie(task);",
            "\t\tif (cookie) {",
            "\t\t\t/* XXX improve ? */",
            "\t\t\tptr_to_hashval((void *)cookie, &id);",
            "\t\t}",
            "\t\terr = put_user(id, (u64 __user *)uaddr);",
            "\t\tgoto out;",
            "",
            "\tcase PR_SCHED_CORE_CREATE:",
            "\t\tcookie = sched_core_alloc_cookie();",
            "\t\tif (!cookie) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase PR_SCHED_CORE_SHARE_TO:",
            "\t\tcookie = sched_core_clone_cookie(current);",
            "\t\tbreak;",
            "",
            "\tcase PR_SCHED_CORE_SHARE_FROM:",
            "\t\tif (type != PIDTYPE_PID) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tcookie = sched_core_clone_cookie(task);",
            "\t\t__sched_core_set(current, cookie);",
            "\t\tgoto out;",
            "",
            "\tdefault:",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (type == PIDTYPE_PID) {",
            "\t\t__sched_core_set(task, cookie);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tgrp = task_pid_type(task, type);",
            "",
            "\tdo_each_pid_thread(grp, type, p) {",
            "\t\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\t\terr = -EPERM;",
            "\t\t\tgoto out_tasklist;",
            "\t\t}",
            "\t} while_each_pid_thread(grp, type, p);",
            "",
            "\tdo_each_pid_thread(grp, type, p) {",
            "\t\t__sched_core_set(p, cookie);",
            "\t} while_each_pid_thread(grp, type, p);",
            "out_tasklist:",
            "\tread_unlock(&tasklist_lock);",
            "",
            "out:",
            "\tsched_core_put_cookie(cookie);",
            "\tput_task_struct(task);",
            "\treturn err;",
            "}"
          ],
          "function_name": "sched_core_alloc_cookie, sched_core_put_cookie, sched_core_get_cookie, sched_core_update_cookie, sched_core_clone_cookie, sched_core_fork, sched_core_free, __sched_core_set, sched_core_share_pid",
          "description": "实现了核心调度 cookie 的分配、释放、获取和更新机制，包含 cookie 分配/回收、任务核心绑定变更、进程克隆共享及核心调度策略控制等功能",
          "similarity": 0.6242823004722595
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 240,
          "end_line": 297,
          "content": [
            "void __sched_core_account_forceidle(struct rq *rq)",
            "{",
            "\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));",
            "\tu64 delta, now = rq_clock(rq->core);",
            "\tstruct rq *rq_i;",
            "\tstruct task_struct *p;",
            "\tint i;",
            "",
            "\tlockdep_assert_rq_held(rq);",
            "",
            "\tWARN_ON_ONCE(!rq->core->core_forceidle_count);",
            "",
            "\tif (rq->core->core_forceidle_start == 0)",
            "\t\treturn;",
            "",
            "\tdelta = now - rq->core->core_forceidle_start;",
            "\tif (unlikely((s64)delta <= 0))",
            "\t\treturn;",
            "",
            "\trq->core->core_forceidle_start = now;",
            "",
            "\tif (WARN_ON_ONCE(!rq->core->core_forceidle_occupation)) {",
            "\t\t/* can't be forced idle without a running task */",
            "\t} else if (rq->core->core_forceidle_count > 1 ||",
            "\t\t   rq->core->core_forceidle_occupation > 1) {",
            "\t\t/*",
            "\t\t * For larger SMT configurations, we need to scale the charged",
            "\t\t * forced idle amount since there can be more than one forced",
            "\t\t * idle sibling and more than one running cookied task.",
            "\t\t */",
            "\t\tdelta *= rq->core->core_forceidle_count;",
            "\t\tdelta = div_u64(delta, rq->core->core_forceidle_occupation);",
            "\t}",
            "",
            "\tfor_each_cpu(i, smt_mask) {",
            "\t\trq_i = cpu_rq(i);",
            "\t\tp = rq_i->core_pick ?: rq_i->curr;",
            "",
            "\t\tif (p == rq_i->idle)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Note: this will account forceidle to the current cpu, even",
            "\t\t * if it comes from our SMT sibling.",
            "\t\t */",
            "\t\t__account_forceidle_time(p, delta);",
            "\t}",
            "}",
            "void __sched_core_tick(struct rq *rq)",
            "{",
            "\tif (!rq->core->core_forceidle_count)",
            "\t\treturn;",
            "",
            "\tif (rq != rq->core)",
            "\t\tupdate_rq_clock(rq->core);",
            "",
            "\t__sched_core_account_forceidle(rq);",
            "}"
          ],
          "function_name": "__sched_core_account_forceidle, __sched_core_tick",
          "description": "提供强制空闲时间统计功能，通过遍历 SMT 核心计算并分摊强制空闲时间消耗，tick 中断触发强制空闲会计入逻辑",
          "similarity": 0.5253162384033203
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 1,
          "end_line": 10,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "/*",
            " * A simple wrapper around refcount. An allocated sched_core_cookie's",
            " * address is used to compute the cookie of the task.",
            " */",
            "struct sched_core_cookie {",
            "\trefcount_t refcnt;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了 sched_core_cookie 结构体，用于核心调度系统中管理任务的 cookie 引用计数，通过结构体地址计算 cookie 值",
          "similarity": 0.520309567451477
        }
      ]
    },
    {
      "source_file": "kernel/trace/pid_list.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:04:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\pid_list.c`\n\n---\n\n# `trace/pid_list.c` 技术文档\n\n## 1. 文件概述\n\n`trace/pid_list.c` 实现了一个高效、可扩展的 PID（进程标识符）集合管理机制，用于 Linux 内核跟踪子系统（ftrace）中对特定进程的过滤控制。该文件通过三级位图结构（upper1 → upper2 → lower）将 PID 空间分层组织，支持快速的 PID 设置、清除、查询及遍历操作，同时兼顾内存使用效率和并发安全性。该实现特别适用于需要动态跟踪大量进程但又不能占用过多连续内存的场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trace_pid_list_is_set()`：检查指定 PID 是否在列表中（用于调度时快速判断是否应跟踪该任务）。\n- `trace_pid_list_set()`：将指定 PID 加入跟踪列表。\n- `trace_pid_list_clear()`：从跟踪列表中移除指定 PID，并在对应位图块为空时自动释放内存。\n- `trace_pid_list_next()`：从给定 PID 开始查找下一个存在于列表中的 PID（用于遍历所有被跟踪的 PID）。\n\n### 辅助内联函数\n\n- `get_lower_chunk()` / `put_lower_chunk()`：从空闲链表中分配或归还底层位图块（`lower_chunk`）。\n- `get_upper_chunk()` / `put_upper_chunk()`：从空闲链表中分配或归还上层索引块（`upper_chunk`）。\n- `upper_empty()`：判断一个 `upper_chunk` 是否完全为空（所有 `lower_chunk` 均为 NULL）。\n- `pid_split()` / `pid_join()`：将 PID 拆分为三级索引（upper1, upper2, lower）或将三级索引合并为 PID。\n\n### 关键数据结构（定义于 `pid_list.h`）\n\n- `struct trace_pid_list`：PID 列表的主结构体，包含：\n  - 两级指针数组：`upper[UPPER_MAX]` 指向 `upper_chunk`。\n  - 空闲块链表：`lower_list` 和 `upper_list` 用于缓存未使用的块。\n  - 计数器：`free_lower_chunks` 和 `free_upper_chunks`。\n  - 自旋锁：`lock` 保证并发安全。\n  - 中断工作队列：`refill_irqwork` 用于异步补充空闲块。\n- `union upper_chunk`：包含一个指针数组 `data[UPPER_MAX]`，每个元素指向一个 `lower_chunk`。\n- `union lower_chunk`：包含一个位图数组 `data[LOWER_SIZE]`，用于存储 `LOWER_MAX` 个 PID 的存在状态。\n\n## 3. 关键实现\n\n### 三级分层位图结构\n- **设计目的**：避免为整个 PID 空间（最大 `PID_MAX_LIMIT`，通常为 4194304）分配连续大内存。\n- **层级划分**：\n  - **Upper1**：最高位，索引 `trace_pid_list->upper[]` 数组（大小 `UPPER_MAX`）。\n  - **Upper2**：中间位，索引 `upper_chunk->data[]` 数组（大小 `UPPER_MAX`）。\n  - **Lower**：最低位，索引 `lower_chunk->data` 位图中的具体位（范围 `0` 到 `LOWER_MAX-1`）。\n- **内存效率**：仅当某 PID 范围被使用时才动态分配对应的 `upper_chunk` 和 `lower_chunk`。\n\n### 并发与内存管理\n- **自旋锁保护**：所有操作均在 `pid_list->lock` 保护下进行，使用 `raw_spin_lock_irqsave()` 禁用本地中断以确保在硬中断上下文（如调度器）中的安全性。\n- **空闲块缓存**：通过 `lower_list` 和 `upper_list` 链表缓存已释放的块，避免频繁的内存分配/释放。\n- **异步补充机制**：当空闲块数量低于阈值 `CHUNK_REALLOC` 时，通过 `irq_work_queue()` 触发中断上下文工作（`refill_irqwork`）来补充空闲块，避免在持有调度器锁时执行耗时的内存分配。\n\n### 动态释放\n- 在 `trace_pid_list_clear()` 中，清除位后检查 `lower_chunk` 是否全零：\n  - 若是，则将其归还到 `lower_list` 并置空 `upper_chunk->data[upper2]`。\n  - 进一步检查 `upper_chunk` 是否完全为空（所有 `data[]` 为 NULL），若是则归还到 `upper_list` 并置空 `pid_list->upper[upper1]`。\n\n### PID 遍历算法\n- `trace_pid_list_next()` 从给定 PID 的拆分索引开始，按 `upper1 → upper2 → lower` 顺序遍历：\n  - 外层循环遍历 `upper1`（从起始值到 `UPPER_MASK`）。\n  - 内层循环遍历 `upper2`（从起始值或 0 到 `UPPER_MASK`）。\n  - 在有效的 `lower_chunk` 中使用 `find_next_bit()` 查找下一个置位的 PID。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/spinlock.h>`：提供自旋锁原语。\n  - `<linux/irq_work.h>`：提供中断上下文工作队列机制。\n  - `<linux/slab.h>`：提供内存分配接口（由 `pid_list.h` 或其他文件间接使用）。\n  - `\"trace.h\"`：包含跟踪子系统通用定义及 `pid_list.h`。\n- **数据结构依赖**：依赖 `pid_list.h` 中定义的 `struct trace_pid_list`、`union upper_chunk`、`union lower_chunk` 及相关常量（如 `UPPER_MASK`、`LOWER_MASK`、`CHUNK_REALLOC` 等）。\n- **内核子系统**：作为 ftrace 跟踪过滤机制的核心组件，被调度器（`kernel/sched/`）和 tracefs 接口（`kernel/trace/`）调用。\n\n## 5. 使用场景\n\n- **动态进程跟踪**：用户通过 tracefs 接口（如 `set_ftrace_pid`）指定要跟踪的进程 PID，内核调用 `trace_pid_list_set()` 将其加入列表。\n- **调度器过滤**：在任务切换时（`__schedule()`），调度器调用 `trace_pid_list_is_set()` 快速判断当前任务是否应被跟踪，决定是否触发跟踪事件。\n- **进程生命周期管理**：\n  - **Fork**：若父进程在跟踪列表中且配置了跟踪子进程，则新进程 PID 通过 `trace_pid_list_set()` 加入列表。\n  - **Exit**：任务退出时，若其 PID 在列表中，则通过 `trace_pid_list_clear()` 移除。\n- **PID 列表遍历**：调试工具或内核接口需要枚举所有被跟踪的 PID 时，调用 `trace_pid_list_next()` 进行迭代。\n- **内存压力处理**：在高并发设置/清除 PID 时，通过异步 `irq_work` 补充空闲块，避免在关键路径（如调度器）中阻塞。",
      "similarity": 0.6426007747650146,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2021 VMware Inc, Steven Rostedt <rostedt@goodmis.org>",
            " */",
            "#include <linux/spinlock.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include \"trace.h\"",
            "",
            "/* See pid_list.h for details */",
            "",
            "static inline union lower_chunk *get_lower_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion lower_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->lower_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->lower_list;",
            "\tpid_list->lower_list = chunk->next;",
            "\tpid_list->free_lower_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_lower_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_lower_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            "",
            "static inline union upper_chunk *get_upper_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->upper_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->upper_list;",
            "\tpid_list->upper_list = chunk->next;",
            "\tpid_list->free_upper_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_upper_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_upper_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现从trace_pid_list结构中获取下层和上层块的函数，通过原子操作减少空闲块计数并可能触发异步补充分配，用于动态管理PID跟踪的内存块。",
          "similarity": 0.6114457249641418
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 457,
          "end_line": 495,
          "content": [
            "void trace_pid_list_free(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *upper;",
            "\tunion lower_chunk *lower;",
            "\tint i, j;",
            "",
            "\tif (!pid_list)",
            "\t\treturn;",
            "",
            "\tirq_work_sync(&pid_list->refill_irqwork);",
            "",
            "\twhile (pid_list->lower_list) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->lower_list;",
            "\t\tpid_list->lower_list = pid_list->lower_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\twhile (pid_list->upper_list) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->upper_list;",
            "\t\tpid_list->upper_list = pid_list->upper_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\tfor (i = 0; i < UPPER1_SIZE; i++) {",
            "\t\tupper = pid_list->upper[i];",
            "\t\tif (upper) {",
            "\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {",
            "\t\t\t\tlower = upper->data[j];",
            "\t\t\t\tkfree(lower);",
            "\t\t\t}",
            "\t\t\tkfree(upper);",
            "\t\t}",
            "\t}",
            "\tkfree(pid_list);",
            "}"
          ],
          "function_name": "trace_pid_list_free",
          "description": "释放trace_pid_list及其关联的所有内存资源，递归回收上层块和下层块链表，彻底清理PID跟踪结构体占用的内存量。",
          "similarity": 0.5703153014183044
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 221,
          "end_line": 377,
          "content": [
            "int trace_pid_list_clear(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (!upper_chunk)",
            "\t\tgoto out;",
            "",
            "\tlower_chunk = upper_chunk->data[upper2];",
            "\tif (!lower_chunk)",
            "\t\tgoto out;",
            "",
            "\tclear_bit(lower, lower_chunk->data);",
            "",
            "\t/* if there's no more bits set, add it to the free list */",
            "\tif (find_first_bit(lower_chunk->data, LOWER_MAX) >= LOWER_MAX) {",
            "\t\tput_lower_chunk(pid_list, lower_chunk);",
            "\t\tupper_chunk->data[upper2] = NULL;",
            "\t\tif (upper_empty(upper_chunk)) {",
            "\t\t\tput_upper_chunk(pid_list, upper_chunk);",
            "\t\t\tpid_list->upper[upper1] = NULL;",
            "\t\t}",
            "\t}",
            " out:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_next(struct trace_pid_list *pid_list, unsigned int pid,",
            "\t\t\tunsigned int *next)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tfor (; upper1 <= UPPER_MASK; upper1++, upper2 = 0) {",
            "\t\tupper_chunk = pid_list->upper[upper1];",
            "",
            "\t\tif (!upper_chunk)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (; upper2 <= UPPER_MASK; upper2++, lower = 0) {",
            "\t\t\tlower_chunk = upper_chunk->data[upper2];",
            "\t\t\tif (!lower_chunk)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tlower = find_next_bit(lower_chunk->data, LOWER_MAX,",
            "\t\t\t\t\t    lower);",
            "\t\t\tif (lower < LOWER_MAX)",
            "\t\t\t\tgoto found;",
            "\t\t}",
            "\t}",
            "",
            " found:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\tif (upper1 > UPPER_MASK)",
            "\t\treturn -1;",
            "",
            "\t*next = pid_join(upper1, upper2, lower);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_first(struct trace_pid_list *pid_list, unsigned int *pid)",
            "{",
            "\treturn trace_pid_list_next(pid_list, 0, pid);",
            "}",
            "static void pid_list_refill_irq(struct irq_work *iwork)",
            "{",
            "\tstruct trace_pid_list *pid_list = container_of(iwork, struct trace_pid_list,",
            "\t\t\t\t\t\t       refill_irqwork);",
            "\tunion upper_chunk *upper = NULL;",
            "\tunion lower_chunk *lower = NULL;",
            "\tunion upper_chunk **upper_next = &upper;",
            "\tunion lower_chunk **lower_next = &lower;",
            "\tint upper_count;",
            "\tint lower_count;",
            "\tint ucnt = 0;",
            "\tint lcnt = 0;",
            "",
            " again:",
            "\traw_spin_lock(&pid_list->lock);",
            "\tupper_count = CHUNK_ALLOC - pid_list->free_upper_chunks;",
            "\tlower_count = CHUNK_ALLOC - pid_list->free_lower_chunks;",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\tif (upper_count <= 0 && lower_count <= 0)",
            "\t\treturn;",
            "",
            "\twhile (upper_count-- > 0) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*upper_next = chunk;",
            "\t\tupper_next = &chunk->next;",
            "\t\tucnt++;",
            "\t}",
            "",
            "\twhile (lower_count-- > 0) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*lower_next = chunk;",
            "\t\tlower_next = &chunk->next;",
            "\t\tlcnt++;",
            "\t}",
            "",
            "\traw_spin_lock(&pid_list->lock);",
            "\tif (upper) {",
            "\t\t*upper_next = pid_list->upper_list;",
            "\t\tpid_list->upper_list = upper;",
            "\t\tpid_list->free_upper_chunks += ucnt;",
            "\t}",
            "\tif (lower) {",
            "\t\t*lower_next = pid_list->lower_list;",
            "\t\tpid_list->lower_list = lower;",
            "\t\tpid_list->free_lower_chunks += lcnt;",
            "\t}",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\t/*",
            "\t * On success of allocating all the chunks, both counters",
            "\t * will be less than zero. If they are not, then an allocation",
            "\t * failed, and we should not try again.",
            "\t */",
            "\tif (upper_count >= 0 || lower_count >= 0)",
            "\t\treturn;",
            "\t/*",
            "\t * When the locks were released, free chunks could have",
            "\t * been used and allocation needs to be done again. Might as",
            "\t * well allocate it now.",
            "\t */",
            "\tgoto again;",
            "}"
          ],
          "function_name": "trace_pid_list_clear, trace_pid_list_next, trace_pid_list_first, pid_list_refill_irq",
          "description": "实现PID集合的遍历与清理功能，包含按序查找下一个PID、首次PID查询及异步内存补充分配逻辑，支持动态扩展存储结构以避免内存耗尽。",
          "similarity": 0.5331799387931824
        }
      ]
    },
    {
      "source_file": "kernel/sched/stop_task.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:17:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\stop_task.c`\n\n---\n\n# `sched/stop_task.c` 技术文档\n\n## 1. 文件概述\n\n`sched/stop_task.c` 实现了 Linux 内核调度器中的 **stop 调度类（stop scheduling class）**。该调度类用于管理 per-CPU 的 **stop 任务（stop task）**，这些任务具有系统中最高的调度优先级，能够抢占所有其他任务，且自身不会被任何任务抢占。stop 任务主要用于需要在所有 CPU 上立即停止常规调度活动的场景，例如 CPU 热插拔、内核模块卸载或 `stop_machine()` 机制执行期间。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `select_task_rq_stop()`：在 SMP 系统中，确保 stop 任务始终运行在其初始 CPU 上，禁止迁移。\n- `balance_stop()`：在负载均衡时判断当前运行队列上是否有可运行的 stop 任务。\n- `wakeup_preempt_stop()`：空实现，因为 stop 任务不会被抢占。\n- `set_next_task_stop()`：设置下一个运行的 stop 任务，并记录其执行起始时间。\n- `pick_task_stop()`：从运行队列中选择 stop 任务（如果存在且可运行）。\n- `enqueue_task_stop()` / `dequeue_task_stop()`：将 stop 任务加入/移出运行队列，并更新运行任务计数。\n- `yield_task_stop()`：触发 `BUG()`，因为 stop 任务绝不应主动让出 CPU。\n- `put_prev_task_stop()`：在切换出 stop 任务时更新其运行统计（调用通用更新函数）。\n- `task_tick_stop()`：空实现，stop 任务不受调度 tick 影响。\n- `switched_to_stop()` / `prio_changed_stop()`：均触发 `BUG()`，因为任务不能动态切换到 stop 调度类，也无优先级概念。\n- `update_curr_stop()`：空实现，stop 任务不参与常规的运行时间更新逻辑。\n\n### 数据结构\n\n- `DEFINE_SCHED_CLASS(stop)`：定义并初始化名为 `stop` 的调度类实例，实现了 `struct sched_class` 接口的所有必要回调函数。\n\n## 3. 关键实现\n\n- **最高优先级保证**：stop 调度类在调度类层级中位于最顶端（高于 `rt`、`fair`、`idle`），确保其任务总是优先获得 CPU。\n- **禁止迁移**：在 `CONFIG_SMP` 下，`select_task_rq_stop()` 强制 stop 任务绑定到其创建时的 CPU，防止跨 CPU 迁移，保证操作的局部性和确定性。\n- **无抢占逻辑**：所有与抢占相关的函数（如 `wakeup_preempt_stop`）均为空或触发错误，因为 stop 任务运行期间系统处于“停止”状态，不应被中断。\n- **错误防护机制**：任何试图动态切换到 stop 调度类、修改其优先级或主动让出 CPU 的行为都会触发 `BUG()`，防止误用。\n- **轻量级统计**：虽然调用 `update_curr_common()` 更新运行时间，但 `update_curr_stop()` 本身为空，表明 stop 任务不参与复杂的调度实体（`sched_entity`）时间计算。\n- **与 `stop_machine` 协同**：该文件与 `kernel/stop_machine.c` 紧密配合，为 `stop_machine()` 提供底层调度支持，确保在所有 CPU 上同步执行关键操作。\n\n## 4. 依赖关系\n\n- **调度核心**：依赖 `kernel/sched/core.c` 中定义的调度类框架、运行队列（`rq`）结构和通用辅助函数（如 `add_nr_running`、`update_curr_common`）。\n- **SMP 支持**：在 `CONFIG_SMP` 编译选项下，依赖 `kernel/sched/sched.h` 中的 `set_cpus_allowed_common` 函数。\n- **Stop Machine 机制**：与 `kernel/stop_machine.c` 深度集成，后者负责创建和管理 per-CPU stop 任务，并触发其执行。\n- **时间子系统**：使用 `rq_clock_task()` 获取任务执行时间戳，依赖内核时间管理基础设施。\n\n## 5. 使用场景\n\n- **`stop_machine()` 执行**：当内核需要在所有在线 CPU 上同步执行一段不能被中断的代码时（如修改全局数据结构、CPU 热插拔），会激活所有 CPU 的 stop 任务。\n- **CPU 热插拔**：在 CPU 上线或下线过程中，使用 stop 任务确保目标 CPU 处于可控状态，避免调度干扰。\n- **内核关键路径保护**：在极少数需要完全禁止调度器干预的内核关键操作中，临时启用 stop 任务以获得独占 CPU 的能力。\n- **调试与诊断**：某些内核调试机制可能利用 stop 任务来冻结系统状态进行分析。",
      "similarity": 0.6382603049278259,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 12,
          "end_line": 64,
          "content": [
            "static int",
            "select_task_rq_stop(struct task_struct *p, int cpu, int flags)",
            "{",
            "\treturn task_cpu(p); /* stop tasks as never migrate */",
            "}",
            "static int",
            "balance_stop(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)",
            "{",
            "\treturn sched_stop_runnable(rq);",
            "}",
            "static void",
            "wakeup_preempt_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\t/* we're never preempted */",
            "}",
            "static void set_next_task_stop(struct rq *rq, struct task_struct *stop, bool first)",
            "{",
            "\tstop->se.exec_start = rq_clock_task(rq);",
            "}",
            "static void",
            "enqueue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tadd_nr_running(rq, 1);",
            "}",
            "static bool",
            "dequeue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tsub_nr_running(rq, 1);",
            "\treturn true;",
            "}",
            "static void yield_task_stop(struct rq *rq)",
            "{",
            "\tBUG(); /* the stop task should never yield, its pointless. */",
            "}",
            "static void put_prev_task_stop(struct rq *rq, struct task_struct *prev, struct task_struct *next)",
            "{",
            "\tupdate_curr_common(rq);",
            "}",
            "static void task_tick_stop(struct rq *rq, struct task_struct *curr, int queued)",
            "{",
            "}",
            "static void switched_to_stop(struct rq *rq, struct task_struct *p)",
            "{",
            "\tBUG(); /* its impossible to change to this class */",
            "}",
            "static void",
            "prio_changed_stop(struct rq *rq, struct task_struct *p, int oldprio)",
            "{",
            "\tBUG(); /* how!?, what priority? */",
            "}",
            "static void update_curr_stop(struct rq *rq)",
            "{",
            "}"
          ],
          "function_name": "select_task_rq_stop, balance_stop, wakeup_preempt_stop, set_next_task_stop, enqueue_task_stop, dequeue_task_stop, yield_task_stop, put_prev_task_stop, task_tick_stop, switched_to_stop, prio_changed_stop, update_curr_stop",
          "description": "实现stop任务调度类的核心操作，包括CPU选择、负载均衡、抢占唤醒、任务添加删除、时间统计更新等，强制禁止任务迁移和抢占以保证系统中断处理优先级",
          "similarity": 0.6296040415763855
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * stop-task scheduling class.",
            " *",
            " * The stop task is the highest priority task in the system, it preempts",
            " * everything and will be preempted by nothing.",
            " *",
            " * See kernel/stop_machine.c",
            " */",
            "",
            "#ifdef CONFIG_SMP"
          ],
          "function_name": null,
          "description": "定义stop任务调度类的框架，启用SMP配置时提供最高优先级调度策略，通过禁用任务迁移和抢占实现系统级中断控制",
          "similarity": 0.5701438188552856
        }
      ]
    }
  ]
}