{
  "query": "Linux 如何实现进程记账？",
  "timestamp": "2025-10-28 18:38:12",
  "retrieved_files": [
    {
      "source_file": "acct.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:48:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `acct.c`\n\n---\n\n# Linux 内核进程记账模块（acct.c）技术文档\n\n## 1. 文件概述\n\n`acct.c` 实现了 BSD 风格的 Linux 进程记账（Process Accounting）功能。当任意进程退出时，内核会向通过 `acct()` 系统调用指定的文件中写入一条类型为 `struct acct` 的记账记录。该模块仅负责生成原始记账数据，具体的数据分析和处理由用户空间程序完成。此功能可用于系统资源使用审计、用户行为追踪和性能分析等场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bsd_acct_struct`**：进程记账核心控制结构\n  - `pin`：文件系统 pin 机制，防止记账文件被意外卸载\n  - `count`：引用计数，用于安全释放资源\n  - `active`：记账功能是否处于激活状态\n  - `check_space`：是否启用磁盘空间检查\n  - `needcheck`：下次磁盘空间检查的时间点\n  - `file`：记账文件的 file 结构指针\n  - `ns`：关联的 PID 命名空间\n  - `work`：用于异步关闭记账文件的工作队列\n  - `ac`：实际的记账数据结构（`acct_t` 类型）\n\n### 主要函数\n\n- **`acct_on()`**：启用进程记账功能，打开指定文件并初始化记账结构\n- **`check_free_space()`**：检查磁盘剩余空间，根据阈值暂停或恢复记账\n- **`acct_pin_kill()`**：安全关闭记账功能，处理资源清理\n- **`close_work()`**：工作队列回调函数，异步执行记账文件关闭操作\n- **`acct_get()`**：获取当前命名空间的记账结构，带引用计数管理\n- **`acct_put()`**：减少记账结构引用计数，必要时释放内存\n- **`fill_ac()`** 和 **`acct_write_process()`**：填充和写入进程记账记录（声明但未在提供的代码片段中实现）\n\n### 系统参数\n\n- **`acct_parm[3]`**：记账系统控制参数数组\n  - `acct_parm[0]`（RESUME）：磁盘剩余空间百分比阈值，超过此值恢复记账\n  - `acct_parm[1]`（SUSPEND）：磁盘剩余空间百分比阈值，低于此值暂停记账  \n  - `acct_parm[2]`（ACCT_TIMEOUT）：磁盘空间检查间隔时间（秒）\n\n## 3. 关键实现\n\n### 磁盘空间监控机制\n\n记账系统实现了智能的磁盘空间管理：\n- 当可用磁盘空间低于 `SUSPEND` 百分比时，自动暂停记账以避免填满磁盘\n- 当可用磁盘空间恢复到 `RESUME` 百分比以上时，自动恢复记账\n- 通过 `needcheck` 字段控制检查频率，避免频繁的磁盘 I/O 操作\n\n### 资源安全管理和并发控制\n\n- **引用计数机制**：使用 `atomic_long_t count` 确保记账结构在多线程环境下的安全访问和释放\n- **RCU 读取优化**：通过 RCU 机制实现高效的记账结构读取，减少锁竞争\n- **互斥锁保护**：`mutex lock` 保护关键操作，防止竞态条件\n- **文件系统 pin 机制**：防止记账文件所在的文件系统被意外卸载\n\n### 异步关闭机制\n\n- 使用工作队列（`work_struct`）异步处理记账文件关闭操作\n- 通过 `completion` 机制确保关闭操作完成后再释放资源\n- 在关闭前调用文件操作的 `flush` 方法确保数据写入磁盘\n\n### 安全性和验证\n\n- 验证目标文件必须是普通文件（`S_ISREG`）\n- 排除内核内部文件系统（`SB_NOUSER | SB_KERNMOUNT`）\n- 排除特殊文件系统如 procfs 和 sysfs（`SB_I_USERNS_VISIBLE`）\n- 验证文件必须具有写权限（`FMODE_CAN_WRITE`）\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n\n- **内存管理**：`<linux/mm.h>`, `<linux/slab.h>`\n- **文件系统**：`<linux/vfs.h>`, `<linux/file.h>`, `<linux/mount.h>`, `<linux/fs_pin.h>`\n- **进程管理**：`<linux/sched/cputime.h>`, `<linux/pid_namespace.h>`\n- **系统调用**：`<linux/syscalls.h>`, `<linux/uaccess.h>`\n- **安全机制**：`<linux/capability.h>`, `<linux/security.h>`\n- **设备支持**：`<linux/tty.h>`\n- **时间管理**：`<linux/jiffies.h>`, `<linux/times.h>`\n\n### 内核子系统交互\n\n- **VFS 层**：通过标准 VFS 接口进行文件操作和文件系统状态查询\n- **内存管理子系统**：使用 slab 分配器分配记账结构内存\n- **工作队列子系统**：利用内核工作队列处理异步关闭操作\n- **RCU 机制**：使用 RCU 进行无锁读取操作\n- **sysctl 接口**：提供运行时可调参数（当 `CONFIG_SYSCTL` 启用时）\n\n## 5. 使用场景\n\n### 系统管理员监控\n\n- 通过 `acct()` 系统调用启用进程记账，收集系统中所有进程的执行信息\n- 分析用户资源使用情况，识别异常进程行为\n- 监控系统负载和进程执行模式\n\n### 安全审计\n\n- 记录所有进程的执行历史，包括命令名、执行时间、资源消耗等\n- 用于事后安全事件分析和取证\n- 检测未授权的程序执行\n\n### 性能分析\n\n- 收集进程 CPU 时间、内存使用、I/O 操作等性能指标\n- 分析系统资源瓶颈和优化机会\n- 监控长时间运行的进程资源消耗趋势\n\n### 容器环境支持\n\n- 通过 PID 命名空间隔离，支持容器级别的进程记账\n- 每个命名空间可以独立配置记账文件和参数\n- 为容器监控和计费提供基础数据支持",
      "similarity": 0.7610177993774414,
      "chunks": []
    },
    {
      "source_file": "tsacct.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:42:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `tsacct.c`\n\n---\n\n# tsacct.c 技术文档\n\n## 1. 文件概述\n\n`tsacct.c` 是 Linux 内核中实现任务统计（taskstats）接口下系统记账（accounting）功能的核心文件。它负责收集进程/任务的资源使用信息，包括基本记账（basic accounting）和扩展记账（extended accounting）两类数据。这些数据通过 `taskstats` 接口暴露给用户空间，用于系统监控、资源审计和性能分析等用途。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`bacct_add_tsk()`**  \n  填充任务的基本记账信息到 `struct taskstats` 结构体中，包括进程 ID、父进程 ID、用户/组 ID、CPU 时间、启动时间、退出码、调度策略、nice 值、缺页次数、命令名等。\n\n- **`xacct_add_tsk()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  填充任务的扩展记账信息，包括内存使用积分（RSS/VM）、I/O 字节数、系统调用次数等。\n\n- **`acct_update_integrals()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  在中断上下文中安全地更新任务的内存使用积分（RSS 和虚拟内存的时间积分）。\n\n- **`acct_account_cputime()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  在已知 CPU 时间更新后，直接调用内部函数更新内存积分，避免重复获取时间。\n\n- **`acct_clear_integrals()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  清除任务结构体中的内存积分字段，通常在进程创建或复用时调用。\n\n### 关键数据结构\n\n- **`struct taskstats`**  \n  用户空间通过 netlink 接口获取的统计信息结构体，包含 `ac_*` 前缀的各类记账字段。\n\n- **`struct task_struct` 中的扩展字段**（仅当 `CONFIG_TASK_XACCT` 启用时）：\n  - `acct_rss_mem1`：RSS 内存使用的时间积分（单位：页·纳秒 / 1024）\n  - `acct_vm_mem1`：虚拟内存使用的时间积分（单位：页·纳秒 / 1024）\n  - `acct_timexpd`：上次更新积分时的累计 CPU 时间（纳秒）\n\n## 3. 关键实现\n\n### 基本记账实现细节\n\n- **时间计算**：\n  - `ac_etime`：任务自启动以来的经过时间（微秒）。\n  - `ac_tgetime`：整个线程组自组长启动以来的经过时间（微秒）。\n  - `ac_btime` / `ac_btime64`：任务启动的绝对时间（Unix 时间戳），前者限制为 32 位以兼容旧接口。\n\n- **身份与关系信息**：\n  - 使用 `from_kuid_munged()` 和 `from_kgid_munged()` 将内核 UID/GID 映射到指定用户命名空间。\n  - 父进程 ID（`ac_ppid`）通过 RCU 读取 `real_parent`，并在进程已退出时设为 0。\n\n- **CPU 时间**：\n  - 使用 `task_cputime()` 获取任务及其子线程的累计用户态和内核态 CPU 时间（纳秒）。\n  - 同时提供原始时间和按 CPU 频率缩放后的时间（`ac_utimescaled` / `ac_stimescaled`）。\n\n- **退出与特权标志**：\n  - 根据任务标志（如 `PF_EXITING`、`PF_SUPERPRIV` 等）设置 `ac_flag` 中的对应位（`AXSIG`、`ASU` 等）。\n\n### 扩展记账实现细节（`CONFIG_TASK_XACCT`）\n\n- **内存积分算法**：\n  - 通过 `__acct_update_integrals()` 定期累积 `RSS × 时间` 和 `VM × 时间`。\n  - 积分单位为“页·纳秒”，右移 10 位（即除以 1024）防止溢出。\n  - 最终在 `xacct_add_tsk()` 中转换为 **MB·微秒**（通过 `PAGE_SIZE / (1000 * KB)`）。\n\n- **高水位内存统计**：\n  - 从 `mm_struct` 中获取历史最高 RSS 和 VM 值，并转换为 KB 单位。\n\n- **I/O 统计**：\n  - 从 `task_struct->ioac` 获取字符级和字节级的读写统计。\n  - 使用 `KB_MASK` 对结果向下对齐到 KB 边界（即清除低 10 位）。\n  - 若未启用 `CONFIG_TASK_IO_ACCOUNTING`，则 I/O 字节字段置零。\n\n- **中断安全更新**：\n  - `acct_update_integrals()` 使用 `local_irq_save/restore` 禁用本地中断，确保在中断上下文中安全更新。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/tsacct_kern.h>`：定义 `taskstats` 结构和相关接口。\n  - `<linux/acct.h>`：提供记账相关的常量和类型。\n  - `<linux/sched/*.h>`：访问任务调度、CPU 时间、凭证等信息。\n  - `<linux/mm.h>`：访问内存管理结构（如 `mm_struct`）。\n  - `<linux/jiffies.h>` 和 `<linux/kernel.h>`：时间转换和基础宏。\n\n- **配置依赖**：\n  - 基本记账功能始终编译。\n  - 扩展记账功能（`xacct_add_tsk` 及相关函数）依赖 `CONFIG_TASK_XACCT`。\n  - I/O 字节统计依赖 `CONFIG_TASK_IO_ACCOUNTING`。\n\n- **与其他子系统交互**：\n  - **调度子系统**：通过 `task_cputime()` 获取 CPU 时间。\n  - **内存管理子系统**：通过 `get_task_mm()` 和 `get_mm_hiwater_*` 获取内存使用情况。\n  - **用户命名空间**：通过 `user_ns` 参数进行 UID/GID 映射。\n  - **进程管理**：访问 `task_struct` 的各种字段（如 `start_time`、`exit_code`、`flags` 等）。\n\n## 5. 使用场景\n\n- **用户空间监控工具**：如 `nmon`、`atop`、`sadc` 等通过 taskstats netlink 接口获取进程资源使用详情。\n- **作业调度系统**：HPC 或容器平台（如 Slurm、Kubernetes）利用扩展记账数据进行资源配额和计费。\n- **系统审计**：记录进程的 CPU、内存、I/O 消耗，用于安全分析或性能瓶颈定位。\n- **内核自身记账**：在进程退出或通过 `TASKSTATS_CMD_ATTR_PID` 查询时，填充并返回 `taskstats` 数据。\n- **cgroup v1/v2 集成**：部分记账数据可被 cgroup 控制器复用或聚合。",
      "similarity": 0.7115199565887451,
      "chunks": []
    },
    {
      "source_file": "taskstats.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:34:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `taskstats.c`\n\n---\n\n# taskstats.c 技术文档\n\n## 1. 文件概述\n\n`taskstats.c` 是 Linux 内核中用于向用户空间导出每个任务（task）统计信息的核心实现文件。该模块通过通用 Netlink（Generic Netlink, genetlink）接口，提供对进程和线程组（TGID）的详细资源使用统计，包括 CPU 时间、上下文切换、延迟会计（delay accounting）、扩展会计（extended accounting）以及可执行文件元数据等。此外，还支持基于 CPU 掩码的监听器注册机制，允许用户空间程序订阅特定 CPU 上任务退出时的统计信息。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct listener`**：表示一个注册的监听器，包含 PID 和有效性标志。\n- **`struct listener_list`**：每个 CPU 上的监听器链表，受读写信号量保护。\n- **`taskstats_cache`**：用于分配 `struct taskstats` 的 slab 缓存。\n- **`family`**：Generic Netlink 通信家族实例。\n\n### 主要函数\n\n- **`prepare_reply()`**：为 Generic Netlink 消息准备回复缓冲区。\n- **`send_reply()`**：向请求者发送单播回复。\n- **`send_cpu_listeners()`**：向注册在特定 CPU 上的所有监听器广播任务统计信息。\n- **`fill_stats()`**：填充单个任务的完整统计信息。\n- **`fill_stats_for_pid()`**：根据 PID 填充对应任务的统计。\n- **`fill_stats_for_tgid()`**：聚合线程组内所有活跃线程的统计信息。\n- **`fill_tgid_exit()`**：在线程退出时，将其统计累加到所属线程组的汇总结构中。\n- **`add_del_listener()`**：注册或注销监听特定 CPU 任务退出事件的用户空间进程。\n- **`exe_add_tsk()`**：提取任务可执行文件的设备号和 inode 号。\n\n### Netlink 策略定义\n\n- `taskstats_cmd_get_policy[]`：定义 `TASKSTATS_CMD_ATTR_*` 属性的解析规则。\n- `cgroupstats_cmd_get_policy[]`：定义 `CGROUPSTATS_CMD_ATTR_FD` 属性的解析规则。\n\n## 3. 关键实现\n\n### 统计信息聚合机制\n\n- **单任务统计**：通过 `fill_stats()` 调用多个子系统（如 `delayacct_add_tsk`、`bacct_add_tsk`、`xacct_add_tsk`）分别填充延迟、基础会计、扩展会计等字段。\n- **线程组统计**：`fill_stats_for_tgid()` 遍历线程组内所有非退出线程，累加 CPU 时间、上下文切换次数，并计算运行时长（`ac_etime`）。\n- **退出时聚合**：当线程退出时，`fill_tgid_exit()` 将其统计信息累加到 `task_struct->signal->stats` 中，供后续查询使用。\n\n### 监听器管理\n\n- 每个 CPU 维护一个独立的 `listener_list`，使用 per-CPU 变量 `listener_array` 存储。\n- 监听器通过 `add_del_listener()` 注册/注销，仅允许在初始用户命名空间和 PID 命名空间中操作。\n- 发送消息时采用“克隆 skb”策略：除最后一个监听器外，其余均使用 `skb_clone()` 保证每个接收者获得独立副本。\n- 自动清理无效监听器：若 `genlmsg_unicast()` 返回 `-ECONNREFUSED`，标记该监听器无效，并在后续批量删除。\n\n### 安全与命名空间限制\n\n- 仅允许 `init_user_ns` 和 `init_pid_ns` 中的进程注册监听器，防止容器内进程干扰全局统计。\n- 对注册的 CPU 掩码进行合法性校验（必须是 `cpu_possible_mask` 的子集）。\n\n### 内存与并发控制\n\n- 使用 `rw_semaphore` 保护监听器链表，读操作（发送）并发，写操作（增删）互斥。\n- `taskstats_seqnum` 为 per-CPU 序列号，用于无请求上下文时的消息标识。\n- 所有动态分配均考虑 NUMA 节点亲和性（`kmalloc_node`）。\n\n## 4. 依赖关系\n\n- **Generic Netlink (`<net/genetlink.h>`)**：提供用户空间通信通道。\n- **延迟会计 (`<linux/delayacct.h>`)**：提供 I/O、调度等延迟统计。\n- **进程会计 (`<linux/acct.h>`, `<linux/tsacct_kern.h>`)**：提供基础和扩展会计信息。\n- **CGroup 统计 (`<linux/cgroupstats.h>`)**：虽未在截断代码中完整体现，但头文件包含表明支持 cgroup 级别统计。\n- **调度与任务管理 (`<linux/sched/cputime.h>`, `<linux/pid_namespace.h>`)**：获取任务 CPU 时间、PID 命名空间信息。\n- **内存管理 (`<linux/slab.h>`, `<linux/percpu.h>`)**：slab 缓存和 per-CPU 数据结构支持。\n\n## 5. 使用场景\n\n- **性能分析工具**：如 `pidstat`、`perf` 等可通过 taskstats 获取高精度任务资源使用数据。\n- **资源监控系统**：实时收集进程 CPU、上下文切换、延迟等指标，用于系统调优或异常检测。\n- **作业调度器**：根据历史任务统计信息优化任务放置策略。\n- **容器运行时**：虽受限于命名空间，但宿主机监控工具可利用此接口获取容器内进程统计（需通过宿主机 PID）。\n- **内核调试**：开发人员可通过监听任务退出事件，分析进程生命周期行为。",
      "similarity": 0.6576765179634094,
      "chunks": []
    }
  ]
}