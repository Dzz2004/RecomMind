{
  "query": "Linux 进程资源监控 实现方法",
  "timestamp": "2025-12-26 14:34:19",
  "retrieved_files": [
    {
      "source_file": "kernel/ptrace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ptrace.c`\n\n---\n\n# ptrace.c 技术文档\n\n## 1. 文件概述\n\n`ptrace.c` 是 Linux 内核中实现 **ptrace**（进程跟踪）机制的核心通用代码文件。该文件提供了跨架构的 ptrace 公共接口和基础功能，避免在每个体系结构中重复实现相同逻辑。ptrace 机制允许一个进程（tracer，通常是调试器）观察和控制另一个进程（tracee）的执行，包括读写其内存、寄存器状态、拦截系统调用等，是调试器（如 GDB）、系统调用追踪工具（如 strace）和安全监控工具的基础。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`ptrace_access_vm()`**  \n  安全地访问被跟踪进程（tracee）的虚拟内存空间，用于读写其内存内容。\n\n- **`__ptrace_link()`**  \n  将被跟踪进程链接到跟踪进程（tracer）的 `ptraced` 链表中，并设置其父进程为 tracer。\n\n- **`ptrace_link()`**  \n  封装 `__ptrace_link()`，使用当前进程的凭证建立跟踪关系。\n\n- **`__ptrace_unlink()`**  \n  解除跟踪关系：将被跟踪进程从 tracer 的链表中移除，恢复其原始父进程，并根据进程组停止状态调整其任务状态（如从 `TASK_TRACED` 转为 `TASK_STOPPED` 或唤醒）。\n\n- **`ptrace_freeze_traced()`** / **`ptrace_unfreeze_traced()`**  \n  在执行 ptrace 操作期间临时冻结被跟踪进程，防止其被意外唤醒（即使是 SIGKILL），确保操作的原子性和一致性。\n\n- **`ptrace_check_attach()`**  \n  验证当前进程是否有权对目标进程执行 ptrace 操作，并确保目标进程处于合适的跟踪状态（可选）。\n\n- **`looks_like_a_spurious_pid()`**  \n  辅助函数，用于检测因线程组 leader 更换（如 `de_thread()`）导致的“虚假”ptrace 事件，避免对已销毁进程的误操作。\n\n### 关键数据结构字段（在 `task_struct` 中）\n\n- `ptrace`：标志位，表示进程是否被跟踪。\n- `parent` / `real_parent`：分别表示当前父进程（通常是 tracer）和原始父进程。\n- `ptraced`：链表头，包含所有被当前进程跟踪的子进程。\n- `ptrace_entry`：链表节点，用于加入 tracer 的 `ptraced` 链表。\n- `ptracer_cred`：跟踪进程的凭证（credentials），用于权限检查。\n- `jobctl`：任务控制标志，包含 `JOBCTL_PTRACE_FROZEN`、`JOBCTL_TRACED`、`JOBCTL_STOP_PENDING` 等 ptrace 相关状态。\n\n## 3. 关键实现\n\n### 安全内存访问 (`ptrace_access_vm`)\n- 通过 `get_task_mm()` 获取目标进程的内存描述符 `mm_struct`。\n- 执行严格的权限检查：\n  - 目标进程必须正在被跟踪（`tsk->ptrace` 非零）。\n  - 当前进程必须是目标进程的直接父进程（`current == tsk->parent`）。\n  - 或者当前进程在目标进程的用户命名空间中具有 `CAP_SYS_PTRACE` 能力（通过 `ptracer_capable()` 检查）。\n- 使用 `__access_remote_vm()` 安全地读写目标进程内存，避免直接遍历页表。\n\n### 跟踪关系管理\n- **链接**：`ptrace_link()` 在持有 `tasklist_lock` 写锁时调用 `__ptrace_link()`，将 tracee 加入 tracer 的 `ptraced` 链表，并保存 tracer 的凭证。\n- **解链接**：`__ptrace_unlink()` 在 detach 或 tracer 退出时调用：\n  - 清除 syscall trace/emu 标志。\n  - 恢复 `real_parent`。\n  - 清除 `ptrace` 标志和 jobctl 中的 trap 相关位。\n  - 根据进程组停止状态决定是否设置 `JOBCTL_STOP_PENDING` 并唤醒进程（`ptrace_signal_wake_up()`）。\n\n### 进程状态冻结机制\n- 在执行 ptrace 操作前调用 `ptrace_freeze_traced()`：\n  - 若 tracee 处于 `TASK_TRACED` 且无致命信号待处理，则设置 `JOBCTL_PTRACE_FROZEN` 标志，使其无法被唤醒。\n- 操作完成后调用 `ptrace_unfreeze_traced()`：\n  - 清除冻结标志。\n  - 若存在致命信号（如 SIGKILL），则清除 `JOBCTL_TRACED` 并唤醒进程以处理信号。\n\n### 权限与状态验证 (`ptrace_check_attach`)\n- 在 `tasklist_lock` 读锁保护下验证：\n  - 目标进程确由当前进程跟踪（`child->ptrace && child->parent == current`）。\n  - 若 `ignore_state=false`，则进一步冻结 tracee 以确保其处于稳定状态。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`mm_struct`、`sighand_struct` 等核心数据结构，以及 `wake_up_state()`、`task_is_traced()` 等调度状态管理函数。\n- **内存管理**：通过 `get_task_mm()`、`mmput()` 和 `__access_remote_vm()` 访问远程进程内存。\n- **信号处理**：大量使用 `siglock`、`jobctl`、`signal_struct` 等信号相关机制管理进程状态转换。\n- **安全模块**：集成 LSM（Linux Security Module）钩子（`security_ptrace_access_check`）和能力检查（`capable()`）。\n- **审计与通知**：与 `audit` 和 `cn_proc`（进程事件连接器）交互，记录 ptrace 事件。\n- **体系结构相关代码**：依赖 `asm/syscall.h` 提供的 `syscall_get_*` 接口获取系统调用信息。\n- **硬件断点**：通过 `hw_breakpoint.h` 支持硬件断点调试功能。\n\n## 5. 使用场景\n\n- **调试器（如 GDB）**：attach 到目标进程，读取/修改寄存器和内存，设置断点，单步执行。\n- **系统调用追踪（如 strace）**：拦截并记录目标进程的所有系统调用及其参数和返回值。\n- **安全监控工具**：监控可疑进程的行为，如检测恶意代码注入或提权操作。\n- **容器与沙箱**：在用户命名空间中实现进程隔离和监控。\n- **内核测试**：用于内核自检和调试，验证进程行为和系统调用处理。\n- **进程注入与热补丁**：通过修改运行中进程的内存和寄存器状态实现代码注入或修复。",
      "similarity": 0.678156316280365,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/ptrace.c",
          "start_line": 44,
          "end_line": 148,
          "content": [
            "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,",
            "\t\t     void *buf, int len, unsigned int gup_flags)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint ret;",
            "",
            "\tmm = get_task_mm(tsk);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tif (!tsk->ptrace ||",
            "\t    (current != tsk->parent) ||",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptracer_capable(tsk, mm->user_ns))) {",
            "\t\tmmput(mm);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = __access_remote_vm(mm, addr, buf, len, gup_flags);",
            "\tmmput(mm);",
            "",
            "\treturn ret;",
            "}",
            "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,",
            "\t\t   const struct cred *ptracer_cred)",
            "{",
            "\tBUG_ON(!list_empty(&child->ptrace_entry));",
            "\tlist_add(&child->ptrace_entry, &new_parent->ptraced);",
            "\tchild->parent = new_parent;",
            "\tchild->ptracer_cred = get_cred(ptracer_cred);",
            "}",
            "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)",
            "{",
            "\t__ptrace_link(child, new_parent, current_cred());",
            "}",
            "void __ptrace_unlink(struct task_struct *child)",
            "{",
            "\tconst struct cred *old_cred;",
            "\tBUG_ON(!child->ptrace);",
            "",
            "\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tchild->parent = child->real_parent;",
            "\tlist_del_init(&child->ptrace_entry);",
            "\told_cred = child->ptracer_cred;",
            "\tchild->ptracer_cred = NULL;",
            "\tput_cred(old_cred);",
            "",
            "\tspin_lock(&child->sighand->siglock);",
            "\tchild->ptrace = 0;",
            "\t/*",
            "\t * Clear all pending traps and TRAPPING.  TRAPPING should be",
            "\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.",
            "\t */",
            "\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);",
            "\ttask_clear_jobctl_trapping(child);",
            "",
            "\t/*",
            "\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and",
            "\t * @child isn't dead.",
            "\t */",
            "\tif (!(child->flags & PF_EXITING) &&",
            "\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||",
            "\t     child->signal->group_stop_count)) {",
            "\t\tchild->jobctl |= JOBCTL_STOP_PENDING;",
            "",
            "\t\t/*",
            "\t\t * This is only possible if this thread was cloned by the",
            "\t\t * traced task running in the stopped group, set the signal",
            "\t\t * for the future reports.",
            "\t\t * FIXME: we should change ptrace_init_task() to handle this",
            "\t\t * case.",
            "\t\t */",
            "\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))",
            "\t\t\tchild->jobctl |= SIGSTOP;",
            "\t}",
            "",
            "\t/*",
            "\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick",
            "\t * @child in the butt.  Note that @resume should be used iff @child",
            "\t * is in TASK_TRACED; otherwise, we might unduly disrupt",
            "\t * TASK_KILLABLE sleeps.",
            "\t */",
            "\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))",
            "\t\tptrace_signal_wake_up(child, true);",
            "",
            "\tspin_unlock(&child->sighand->siglock);",
            "}",
            "static bool looks_like_a_spurious_pid(struct task_struct *task)",
            "{",
            "\tif (task->exit_code != ((PTRACE_EVENT_EXEC << 8) | SIGTRAP))",
            "\t\treturn false;",
            "",
            "\tif (task_pid_vnr(task) == task->ptrace_message)",
            "\t\treturn false;",
            "\t/*",
            "\t * The tracee changed its pid but the PTRACE_EVENT_EXEC event",
            "\t * was not wait()'ed, most probably debugger targets the old",
            "\t * leader which was destroyed in de_thread().",
            "\t */",
            "\treturn true;",
            "}"
          ],
          "function_name": "ptrace_access_vm, __ptrace_link, ptrace_link, __ptrace_unlink, looks_like_a_spurious_pid",
          "description": "实现进程跟踪核心操作，包含访问目标进程地址空间、维护跟踪链表、解除跟踪关系及检测虚假PID逻辑，用于安全控制和状态同步。",
          "similarity": 0.6759788393974304
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/ptrace.c",
          "start_line": 647,
          "end_line": 799,
          "content": [
            "int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tif (copy_from_user(buf, src, this_len))",
            "\t\t\treturn -EFAULT;",
            "\t\tretval = ptrace_access_vm(tsk, dst, buf, this_len,",
            "\t\t\t\tFOLL_FORCE | FOLL_WRITE);",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}",
            "static int ptrace_setoptions(struct task_struct *child, unsigned long data)",
            "{",
            "\tunsigned flags;",
            "\tint ret;",
            "",
            "\tret = check_ptrace_options(data);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* Avoid intermediate state when all opts are cleared */",
            "\tflags = child->ptrace;",
            "\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);",
            "\tflags |= (data << PT_OPT_FLAG_SHIFT);",
            "\tchild->ptrace = flags;",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(info, child->last_siginfo);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(child->last_siginfo, info);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_peek_siginfo(struct task_struct *child,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long data)",
            "{",
            "\tstruct ptrace_peeksiginfo_args arg;",
            "\tstruct sigpending *pending;",
            "\tstruct sigqueue *q;",
            "\tint ret, i;",
            "",
            "\tret = copy_from_user(&arg, (void __user *) addr,",
            "\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)",
            "\t\treturn -EINVAL; /* unknown flags */",
            "",
            "\tif (arg.nr < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure arg.off fits in an unsigned long */",
            "\tif (arg.off > ULONG_MAX)",
            "\t\treturn 0;",
            "",
            "\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)",
            "\t\tpending = &child->signal->shared_pending;",
            "\telse",
            "\t\tpending = &child->pending;",
            "",
            "\tfor (i = 0; i < arg.nr; ) {",
            "\t\tkernel_siginfo_t info;",
            "\t\tunsigned long off = arg.off + i;",
            "\t\tbool found = false;",
            "",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tlist_for_each_entry(q, &pending->list, list) {",
            "\t\t\tif (!off--) {",
            "\t\t\t\tfound = true;",
            "\t\t\t\tcopy_siginfo(&info, &q->info);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tif (!found) /* beyond the end of the list */",
            "\t\t\tbreak;",
            "",
            "#ifdef CONFIG_COMPAT",
            "\t\tif (unlikely(in_compat_syscall())) {",
            "\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);",
            "",
            "\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t} else",
            "#endif",
            "\t\t{",
            "\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;",
            "",
            "\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tdata += sizeof(siginfo_t);",
            "\t\ti++;",
            "",
            "\t\tif (signal_pending(current))",
            "\t\t\tbreak;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\tif (i > 0)",
            "\t\treturn i;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_writedata, ptrace_setoptions, ptrace_getsiginfo, ptrace_setsiginfo, ptrace_peek_siginfo",
          "description": "实现ptrace_writedata用于将数据写入被跟踪进程的内存，通过循环拷贝并处理错误；ptrace_setoptions用于更新跟踪选项标志位；ptrace_getsiginfo/ptrace_setsiginfo用于获取和设置进程的最后一个信号信息；ptrace_peek_siginfo用于遍历信号队列并复制信号信息到用户空间",
          "similarity": 0.6081798076629639
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/ptrace.c",
          "start_line": 501,
          "end_line": 618,
          "content": [
            "static int ptrace_traceme(void)",
            "{",
            "\tint ret = -EPERM;",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\t/* Are we already being traced? */",
            "\tif (!current->ptrace) {",
            "\t\tret = security_ptrace_traceme(current->parent);",
            "\t\t/*",
            "\t\t * Check PF_EXITING to ensure ->real_parent has not passed",
            "\t\t * exit_ptrace(). Otherwise we don't report the error but",
            "\t\t * pretend ->real_parent untraces us right after return.",
            "\t\t */",
            "\t\tif (!ret && !(current->real_parent->flags & PF_EXITING)) {",
            "\t\t\tcurrent->ptrace = PT_PTRACED;",
            "\t\t\tptrace_link(current, current->real_parent);",
            "\t\t}",
            "\t}",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\treturn ret;",
            "}",
            "static int ignoring_children(struct sighand_struct *sigh)",
            "{",
            "\tint ret;",
            "\tspin_lock(&sigh->siglock);",
            "\tret = (sigh->action[SIGCHLD-1].sa.sa_handler == SIG_IGN) ||",
            "\t      (sigh->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT);",
            "\tspin_unlock(&sigh->siglock);",
            "\treturn ret;",
            "}",
            "static bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)",
            "{",
            "\tbool dead;",
            "",
            "\t__ptrace_unlink(p);",
            "",
            "\tif (p->exit_state != EXIT_ZOMBIE)",
            "\t\treturn false;",
            "",
            "\tdead = !thread_group_leader(p);",
            "",
            "\tif (!dead && thread_group_empty(p)) {",
            "\t\tif (!same_thread_group(p->real_parent, tracer))",
            "\t\t\tdead = do_notify_parent(p, p->exit_signal);",
            "\t\telse if (ignoring_children(tracer->sighand)) {",
            "\t\t\t__wake_up_parent(p, tracer);",
            "\t\t\tdead = true;",
            "\t\t}",
            "\t}",
            "\t/* Mark it as in the process of being reaped. */",
            "\tif (dead)",
            "\t\tp->exit_state = EXIT_DEAD;",
            "\treturn dead;",
            "}",
            "static int ptrace_detach(struct task_struct *child, unsigned int data)",
            "{",
            "\tif (!valid_signal(data))",
            "\t\treturn -EIO;",
            "",
            "\t/* Architecture-specific hardware disable .. */",
            "\tptrace_disable(child);",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\t/*",
            "\t * We rely on ptrace_freeze_traced(). It can't be killed and",
            "\t * untraced by another thread, it can't be a zombie.",
            "\t */",
            "\tWARN_ON(!child->ptrace || child->exit_state);",
            "\t/*",
            "\t * tasklist_lock avoids the race with wait_task_stopped(), see",
            "\t * the comment in ptrace_resume().",
            "\t */",
            "\tchild->exit_code = data;",
            "\t__ptrace_detach(current, child);",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\tproc_ptrace_connector(child, PTRACE_DETACH);",
            "",
            "\treturn 0;",
            "}",
            "void exit_ptrace(struct task_struct *tracer, struct list_head *dead)",
            "{",
            "\tstruct task_struct *p, *n;",
            "",
            "\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {",
            "\t\tif (unlikely(p->ptrace & PT_EXITKILL))",
            "\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);",
            "",
            "\t\tif (__ptrace_detach(tracer, p))",
            "\t\t\tlist_add(&p->ptrace_entry, dead);",
            "\t}",
            "}",
            "int ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tretval = ptrace_access_vm(tsk, src, buf, this_len, FOLL_FORCE);",
            "",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tif (copy_to_user(dst, buf, retval))",
            "\t\t\treturn -EFAULT;",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}"
          ],
          "function_name": "ptrace_traceme, ignoring_children, __ptrace_detach, ptrace_detach, exit_ptrace, ptrace_readdata",
          "description": "完成跟踪关系建立与终止，包含被跟踪进程自我注册、子进程忽略信号检测、跟踪分离及资源释放逻辑，处理进程退出时的跟踪清理。",
          "similarity": 0.6018081903457642
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/ptrace.c",
          "start_line": 195,
          "end_line": 336,
          "content": [
            "static bool ptrace_freeze_traced(struct task_struct *task)",
            "{",
            "\tbool ret = false;",
            "",
            "\t/* Lockless, nobody but us can set this flag */",
            "\tif (task->jobctl & JOBCTL_LISTENING)",
            "\t\treturn ret;",
            "",
            "\tspin_lock_irq(&task->sighand->siglock);",
            "\tif (task_is_traced(task) && !looks_like_a_spurious_pid(task) &&",
            "\t    !__fatal_signal_pending(task)) {",
            "\t\ttask->jobctl |= JOBCTL_PTRACE_FROZEN;",
            "\t\tret = true;",
            "\t}",
            "\tspin_unlock_irq(&task->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void ptrace_unfreeze_traced(struct task_struct *task)",
            "{",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * The child may be awake and may have cleared",
            "\t * JOBCTL_PTRACE_FROZEN (see ptrace_resume).  The child will",
            "\t * not set JOBCTL_PTRACE_FROZEN or enter __TASK_TRACED anew.",
            "\t */",
            "\tif (lock_task_sighand(task, &flags)) {",
            "\t\ttask->jobctl &= ~JOBCTL_PTRACE_FROZEN;",
            "\t\tif (__fatal_signal_pending(task)) {",
            "\t\t\ttask->jobctl &= ~JOBCTL_TRACED;",
            "\t\t\twake_up_state(task, __TASK_TRACED);",
            "\t\t}",
            "\t\tunlock_task_sighand(task, &flags);",
            "\t}",
            "}",
            "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)",
            "{",
            "\tint ret = -ESRCH;",
            "",
            "\t/*",
            "\t * We take the read lock around doing both checks to close a",
            "\t * possible race where someone else was tracing our child and",
            "\t * detached between these two checks.  After this locked check,",
            "\t * we are sure that this is our traced child and that can only",
            "\t * be changed by us so it's not changing right after this.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tif (child->ptrace && child->parent == current) {",
            "\t\t/*",
            "\t\t * child->sighand can't be NULL, release_task()",
            "\t\t * does ptrace_unlink() before __exit_signal().",
            "\t\t */",
            "\t\tif (ignore_state || ptrace_freeze_traced(child))",
            "\t\t\tret = 0;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tif (!ret && !ignore_state &&",
            "\t    WARN_ON_ONCE(!wait_task_inactive(child, __TASK_TRACED|TASK_FROZEN)))",
            "\t\tret = -ESRCH;",
            "",
            "\treturn ret;",
            "}",
            "static bool ptrace_has_cap(struct user_namespace *ns, unsigned int mode)",
            "{",
            "\tif (mode & PTRACE_MODE_NOAUDIT)",
            "\t\treturn ns_capable_noaudit(ns, CAP_SYS_PTRACE);",
            "\treturn ns_capable(ns, CAP_SYS_PTRACE);",
            "}",
            "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tconst struct cred *cred = current_cred(), *tcred;",
            "\tstruct mm_struct *mm;",
            "\tkuid_t caller_uid;",
            "\tkgid_t caller_gid;",
            "",
            "\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {",
            "\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* May we inspect the given task?",
            "\t * This check is used both for attaching with ptrace",
            "\t * and for allowing access to sensitive information in /proc.",
            "\t *",
            "\t * ptrace_attach denies several cases that /proc allows",
            "\t * because setting up the necessary parent/child relationship",
            "\t * or halting the specified task is impossible.",
            "\t */",
            "",
            "\t/* Don't let security modules deny introspection */",
            "\tif (same_thread_group(task, current))",
            "\t\treturn 0;",
            "\trcu_read_lock();",
            "\tif (mode & PTRACE_MODE_FSCREDS) {",
            "\t\tcaller_uid = cred->fsuid;",
            "\t\tcaller_gid = cred->fsgid;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Using the euid would make more sense here, but something",
            "\t\t * in userland might rely on the old behavior, and this",
            "\t\t * shouldn't be a security problem since",
            "\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly",
            "\t\t * used a syscall that requests access to another process",
            "\t\t * (and not a filesystem syscall to procfs).",
            "\t\t */",
            "\t\tcaller_uid = cred->uid;",
            "\t\tcaller_gid = cred->gid;",
            "\t}",
            "\ttcred = __task_cred(task);",
            "\tif (uid_eq(caller_uid, tcred->euid) &&",
            "\t    uid_eq(caller_uid, tcred->suid) &&",
            "\t    uid_eq(caller_uid, tcred->uid)  &&",
            "\t    gid_eq(caller_gid, tcred->egid) &&",
            "\t    gid_eq(caller_gid, tcred->sgid) &&",
            "\t    gid_eq(caller_gid, tcred->gid))",
            "\t\tgoto ok;",
            "\tif (ptrace_has_cap(tcred->user_ns, mode))",
            "\t\tgoto ok;",
            "\trcu_read_unlock();",
            "\treturn -EPERM;",
            "ok:",
            "\trcu_read_unlock();",
            "\t/*",
            "\t * If a task drops privileges and becomes nondumpable (through a syscall",
            "\t * like setresuid()) while we are trying to access it, we must ensure",
            "\t * that the dumpability is read after the credentials; otherwise,",
            "\t * we may be able to attach to a task that we shouldn't be able to",
            "\t * attach to (as if the task had dropped privileges without becoming",
            "\t * nondumpable).",
            "\t * Pairs with a write barrier in commit_creds().",
            "\t */",
            "\tsmp_rmb();",
            "\tmm = task->mm;",
            "\tif (mm &&",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptrace_has_cap(mm->user_ns, mode)))",
            "\t    return -EPERM;",
            "",
            "\treturn security_ptrace_access_check(task, mode);",
            "}"
          ],
          "function_name": "ptrace_freeze_traced, ptrace_unfreeze_traced, ptrace_check_attach, ptrace_has_cap, __ptrace_may_access",
          "description": "处理跟踪进程的冻结/解冻机制，检查附加合法性并验证能力权限，确保跟踪操作符合安全策略和内核状态约束。",
          "similarity": 0.6014424562454224
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/ptrace.c",
          "start_line": 360,
          "end_line": 490,
          "content": [
            "bool ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tint err;",
            "\ttask_lock(task);",
            "\terr = __ptrace_may_access(task, mode);",
            "\ttask_unlock(task);",
            "\treturn !err;",
            "}",
            "static int check_ptrace_options(unsigned long data)",
            "{",
            "\tif (data & ~(unsigned long)PTRACE_O_MASK)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {",
            "\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||",
            "\t\t    !IS_ENABLED(CONFIG_SECCOMP))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (!capable(CAP_SYS_ADMIN))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||",
            "\t\t    current->ptrace & PT_SUSPEND_SECCOMP)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "\treturn 0;",
            "}",
            "static inline void ptrace_set_stopped(struct task_struct *task)",
            "{",
            "\tguard(spinlock)(&task->sighand->siglock);",
            "",
            "\t/*",
            "\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and",
            "\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING",
            "\t * will be cleared if the child completes the transition or any",
            "\t * event which clears the group stop states happens.  We'll wait",
            "\t * for the transition to complete before returning from this",
            "\t * function.",
            "\t *",
            "\t * This hides STOPPED -> RUNNING -> TRACED transition from the",
            "\t * attaching thread but a different thread in the same group can",
            "\t * still observe the transient RUNNING state.  IOW, if another",
            "\t * thread's WNOHANG wait(2) on the stopped tracee races against",
            "\t * ATTACH, the wait(2) may fail due to the transient RUNNING.",
            "\t *",
            "\t * The following task_is_stopped() test is safe as both transitions",
            "\t * in and out of STOPPED are protected by siglock.",
            "\t */",
            "\tif (task_is_stopped(task) &&",
            "\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING)) {",
            "\t\ttask->jobctl &= ~JOBCTL_STOPPED;",
            "\t\tsignal_wake_up_state(task, __TASK_STOPPED);",
            "\t}",
            "}",
            "static int ptrace_attach(struct task_struct *task, long request,",
            "\t\t\t unsigned long addr,",
            "\t\t\t unsigned long flags)",
            "{",
            "\tbool seize = (request == PTRACE_SEIZE);",
            "\tint retval;",
            "",
            "\tif (seize) {",
            "\t\tif (addr != 0)",
            "\t\t\treturn -EIO;",
            "\t\t/*",
            "\t\t * This duplicates the check in check_ptrace_options() because",
            "\t\t * ptrace_attach() and ptrace_setoptions() have historically",
            "\t\t * used different error codes for unknown ptrace options.",
            "\t\t */",
            "\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)",
            "\t\t\treturn -EIO;",
            "",
            "\t\tretval = check_ptrace_options(flags);",
            "\t\tif (retval)",
            "\t\t\treturn retval;",
            "\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);",
            "\t} else {",
            "\t\tflags = PT_PTRACED;",
            "\t}",
            "",
            "\taudit_ptrace(task);",
            "",
            "\tif (unlikely(task->flags & PF_KTHREAD))",
            "\t\treturn -EPERM;",
            "\tif (same_thread_group(task, current))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Protect exec's credential calculations against our interference;",
            "\t * SUID, SGID and LSM creds get determined differently",
            "\t * under ptrace.",
            "\t */",
            "\tscoped_cond_guard (mutex_intr, return -ERESTARTNOINTR,",
            "\t\t\t   &task->signal->cred_guard_mutex) {",
            "",
            "\t\tscoped_guard (task_lock, task) {",
            "\t\t\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);",
            "\t\t\tif (retval)",
            "\t\t\t\treturn retval;",
            "\t\t}",
            "",
            "\t\tscoped_guard (write_lock_irq, &tasklist_lock) {",
            "\t\t\tif (unlikely(task->exit_state))",
            "\t\t\t\treturn -EPERM;",
            "\t\t\tif (task->ptrace)",
            "\t\t\t\treturn -EPERM;",
            "",
            "\t\t\ttask->ptrace = flags;",
            "",
            "\t\t\tptrace_link(task, current);",
            "",
            "\t\t\t/* SEIZE doesn't trap tracee on attach */",
            "\t\t\tif (!seize)",
            "\t\t\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);",
            "",
            "\t\t\tptrace_set_stopped(task);",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * We do not bother to change retval or clear JOBCTL_TRAPPING",
            "\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will",
            "\t * not return to user-mode, it will exit and clear this bit in",
            "\t * __ptrace_unlink() if it wasn't already cleared by the tracee;",
            "\t * and until then nobody can ptrace this task.",
            "\t */",
            "\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);",
            "\tproc_ptrace_connector(task, PTRACE_ATTACH);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "ptrace_may_access, check_ptrace_options, ptrace_set_stopped, ptrace_attach",
          "description": "实现ptrace附加流程，包含权限校验、选项解析、停止状态设置及实际附加操作，协调信号传递和跟踪标志位更新。",
          "similarity": 0.5962048768997192
        }
      ]
    },
    {
      "source_file": "kernel/trace/rv/rv.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:10:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\rv\\rv.c`\n\n---\n\n# `trace/rv/rv.c` 技术文档\n\n## 1. 文件概述\n\n`rv.c` 是 Linux 内核中运行时验证（Runtime Verification, RV）子系统的主接口实现文件。该文件提供了注册、启用、禁用运行时监控器（monitor）的统一接口，并实现了用户空间与内核 RV 子系统交互的 tracefs 文件系统接口。RV 通过将内核实际执行轨迹与形式化规范进行比对，实现对关键行为的实时监控与异常响应，适用于安全关键系统。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct rv_monitor`**  \n  定义运行时监控器的回调接口，包括 `enable()` 和 `disable()` 等函数指针，用于挂载/卸载内核追踪点。\n\n- **`struct rv_monitor_def`**  \n  监控器定义结构体，封装 `rv_monitor` 实例及其元数据（如名称、描述、启用状态等）。\n\n- **`struct rv_interface`**  \n  表示 RV 子系统的根接口结构，包含 tracefs 目录项（如 `monitors_dir`）。\n\n- **`task_monitor_slots[]` 与 `task_monitor_count`**  \n  管理 per-task 监控器槽位的位图与计数器，限制同时启用的 per-task 监控器数量（上限为 `RV_PER_TASK_MONITORS`）。\n\n### 主要函数\n\n- **`rv_register_monitor()` / `rv_unregister_monitor()`**  \n  用于向 RV 子系统注册或注销一个监控器。\n\n- **`rv_get_task_monitor_slot()` / `rv_put_task_monitor_slot()`**  \n  分配和释放 per-task 监控器槽位，确保不超过系统限制。\n\n- **`__rv_disable_monitor()` / `rv_disable_monitor()`**  \n  禁用已启用的监控器，可选择是否同步等待所有追踪点执行完成（通过 `tracepoint_synchronize_unregister()`）。\n\n- **`monitor_enable_read_data()`**  \n  实现 tracefs 中每个监控器目录下 `enable` 文件的读取操作，返回当前启用状态（\"0\\n\" 或 \"1\\n\"）。\n\n- **`get_monitors_root()`**  \n  返回 tracefs 中 `monitors/` 目录的 dentry，供其他模块创建子目录使用。\n\n## 3. 关键实现\n\n- **互斥锁保护**  \n  全局互斥锁 `rv_interface_lock` 保护所有监控器注册、启用/禁用及槽位分配操作，确保并发安全。\n\n- **槽位管理机制**  \n  使用位图 `task_monitor_slots[]` 和计数器 `task_monitor_count` 跟踪 per-task 监控器资源使用情况，防止超额分配。\n\n- **同步禁用机制**  \n  在禁用监控器时调用 `tracepoint_synchronize_unregister()`，确保所有 CPU 上的追踪点回调执行完毕后再释放资源，避免竞态导致的数据不一致。\n\n- **tracefs 接口布局**  \n  模仿内核 tracing 子系统的 `events/` 目录结构，在 tracefs 下创建：\n  - `available_monitors`：列出所有已注册监控器\n  - `enabled_monitors`：控制监控器启用/禁用（支持前缀 `!` 禁用和清空禁用全部）\n  - `monitoring_on`：全局开关，暂停所有监控逻辑但不卸载追踪点\n  - `monitors/<name>/`：每个监控器的专属目录，包含 `desc`（描述）和 `enable`（状态控制）文件\n\n- **Lockdep 断言**  \n  关键函数（如槽位分配/释放、监控器禁用）使用 `lockdep_assert_held(&rv_interface_lock)` 确保调用者已持有锁，增强代码健壮性。\n\n## 4. 依赖关系\n\n- **内核追踪子系统**  \n  依赖 tracepoint 机制实现事件注入，使用 `tracepoint_synchronize_unregister()` 进行同步。\n  \n- **tracefs 文件系统**  \n  通过 tracefs 暴露用户接口，依赖 `<linux/fs.h>` 和 dentry 操作。\n\n- **内存管理**  \n  使用 `kmalloc()`/`kfree()`（通过 `rv.h` 中的封装）管理监控器定义结构体内存。\n\n- **模块系统**  \n  作为可加载模块实现（`MODULE_LICENSE(\"GPL\")`），支持动态加载/卸载。\n\n- **RV 子系统头文件**  \n  包含本地头文件 `\"rv.h\"`，定义监控器结构、常量（如 `RV_PER_TASK_MONITORS`）和辅助函数。\n\n- **DA_MON_EVENTS 支持**  \n  若配置 `CONFIG_DA_MON_EVENTS`，则生成 RV 专用追踪点（`<trace/events/rv.h>`）。\n\n## 5. 使用场景\n\n- **形式化验证集成**  \n  作为学术研究（如论文 *Efficient formal verification for the Linux kernel*）的工程实现，将自动机模型与内核实例绑定。\n\n- **实时行为监控**  \n  在安全关键系统（如工业控制、自动驾驶）中监控内核行为是否违反预定义规范（如“禁止在中断上下文中睡眠”）。\n\n- **调试与诊断**  \n  开发者通过启用特定监控器（如 `wip`、`wwnr`）捕获复杂并发 bug 或时序违规。\n\n- **动态策略执行**  \n  用户空间可通过写入 `enabled_monitors` 动态切换监控策略，无需重启系统。\n\n- **资源受限环境**  \n  per-task 监控器槽位限制机制确保 RV 子系统在资源受限设备上可控运行。",
      "similarity": 0.6480790376663208,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 317,
          "end_line": 459,
          "content": [
            "static ssize_t monitor_desc_read_data(struct file *filp, char __user *user_buf, size_t count,",
            "\t\t\t\t      loff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tchar buff[256];",
            "",
            "\tmemset(buff, 0, sizeof(buff));",
            "",
            "\tsnprintf(buff, sizeof(buff), \"%s\\n\", mdef->monitor->description);",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);",
            "}",
            "static int create_monitor_dir(struct rv_monitor_def *mdef)",
            "{",
            "\tstruct dentry *root = get_monitors_root();",
            "\tconst char *name = mdef->monitor->name;",
            "\tstruct dentry *tmp;",
            "\tint retval;",
            "",
            "\tmdef->root_d = rv_create_dir(name, root);",
            "\tif (!mdef->root_d)",
            "\t\treturn -ENOMEM;",
            "",
            "\ttmp = rv_create_file(\"enable\", RV_MODE_WRITE, mdef->root_d, mdef, &interface_enable_fops);",
            "\tif (!tmp) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_remove_root;",
            "\t}",
            "",
            "\ttmp = rv_create_file(\"desc\", RV_MODE_READ, mdef->root_d, mdef, &interface_desc_fops);",
            "\tif (!tmp) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_remove_root;",
            "\t}",
            "",
            "\tretval = reactor_populate_monitor(mdef);",
            "\tif (retval)",
            "\t\tgoto out_remove_root;",
            "",
            "\treturn 0;",
            "",
            "out_remove_root:",
            "\trv_remove(mdef->root_d);",
            "\treturn retval;",
            "}",
            "static int monitors_show(struct seq_file *m, void *p)",
            "{",
            "\tstruct rv_monitor_def *mon_def = p;",
            "",
            "\tseq_printf(m, \"%s\\n\", mon_def->monitor->name);",
            "\treturn 0;",
            "}",
            "static void monitors_stop(struct seq_file *m, void *p)",
            "{",
            "\tmutex_unlock(&rv_interface_lock);",
            "}",
            "static int available_monitors_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn seq_open(file, &available_monitors_seq_ops);",
            "};",
            "static void disable_all_monitors(void)",
            "{",
            "\tstruct rv_monitor_def *mdef;",
            "\tint enabled = 0;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list)",
            "\t\tenabled += __rv_disable_monitor(mdef, false);",
            "",
            "\tif (enabled) {",
            "\t\t/*",
            "\t\t * Wait for the execution of all events to finish.",
            "\t\t * Otherwise, the data used by the monitor could",
            "\t\t * be inconsistent. i.e., if the monitor is re-enabled.",
            "\t\t */",
            "\t\ttracepoint_synchronize_unregister();",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "}",
            "static int enabled_monitors_open(struct inode *inode, struct file *file)",
            "{",
            "\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC))",
            "\t\tdisable_all_monitors();",
            "",
            "\treturn seq_open(file, &enabled_monitors_seq_ops);",
            "};",
            "static ssize_t enabled_monitors_write(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t      size_t count, loff_t *ppos)",
            "{",
            "\tchar buff[MAX_RV_MONITOR_NAME_SIZE + 2];",
            "\tstruct rv_monitor_def *mdef;",
            "\tint retval = -EINVAL;",
            "\tbool enable = true;",
            "\tchar *ptr;",
            "\tint len;",
            "",
            "\tif (count < 1 || count > MAX_RV_MONITOR_NAME_SIZE + 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tmemset(buff, 0, sizeof(buff));",
            "",
            "\tretval = simple_write_to_buffer(buff, sizeof(buff) - 1, ppos, user_buf, count);",
            "\tif (retval < 0)",
            "\t\treturn -EFAULT;",
            "",
            "\tptr = strim(buff);",
            "",
            "\tif (ptr[0] == '!') {",
            "\t\tenable = false;",
            "\t\tptr++;",
            "\t}",
            "",
            "\tlen = strlen(ptr);",
            "\tif (!len)",
            "\t\treturn count;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tretval = -EINVAL;",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list) {",
            "\t\tif (strcmp(ptr, mdef->monitor->name) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Monitor found!",
            "\t\t */",
            "\t\tif (enable)",
            "\t\t\tretval = rv_enable_monitor(mdef);",
            "\t\telse",
            "\t\t\tretval = rv_disable_monitor(mdef);",
            "",
            "\t\tif (!retval)",
            "\t\t\tretval = count;",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "monitor_desc_read_data, create_monitor_dir, monitors_show, monitors_stop, available_monitors_open, disable_all_monitors, enabled_monitors_open, enabled_monitors_write",
          "description": "创建监控专用目录结构，实现监控描述信息读取和可用监控列表展示，支持动态监控使能状态管理和全局禁用操作。",
          "similarity": 0.6238919496536255
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 170,
          "end_line": 278,
          "content": [
            "int rv_get_task_monitor_slot(void)",
            "{",
            "\tint i;",
            "",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (task_monitor_count == RV_PER_TASK_MONITORS)",
            "\t\treturn -EBUSY;",
            "",
            "\ttask_monitor_count++;",
            "",
            "\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++) {",
            "\t\tif (task_monitor_slots[i] == false) {",
            "\t\t\ttask_monitor_slots[i] = true;",
            "\t\t\treturn i;",
            "\t\t}",
            "\t}",
            "",
            "\tWARN_ONCE(1, \"RV task_monitor_count and slots are out of sync\\n\");",
            "",
            "\treturn -EINVAL;",
            "}",
            "void rv_put_task_monitor_slot(int slot)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (slot < 0 || slot >= RV_PER_TASK_MONITORS) {",
            "\t\tWARN_ONCE(1, \"RV releasing an invalid slot!: %d\\n\", slot);",
            "\t\treturn;",
            "\t}",
            "",
            "\tWARN_ONCE(!task_monitor_slots[slot], \"RV releasing unused task_monitor_slots: %d\\n\",",
            "\t\t  slot);",
            "",
            "\ttask_monitor_count--;",
            "\ttask_monitor_slots[slot] = false;",
            "}",
            "static ssize_t monitor_enable_read_data(struct file *filp, char __user *user_buf, size_t count,",
            "\t\t\t\t\tloff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tconst char *buff;",
            "",
            "\tbuff = mdef->monitor->enabled ? \"1\\n\" : \"0\\n\";",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff)+1);",
            "}",
            "static int __rv_disable_monitor(struct rv_monitor_def *mdef, bool sync)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (mdef->monitor->enabled) {",
            "\t\tmdef->monitor->enabled = 0;",
            "\t\tmdef->monitor->disable();",
            "",
            "\t\t/*",
            "\t\t * Wait for the execution of all events to finish.",
            "\t\t * Otherwise, the data used by the monitor could",
            "\t\t * be inconsistent. i.e., if the monitor is re-enabled.",
            "\t\t */",
            "\t\tif (sync)",
            "\t\t\ttracepoint_synchronize_unregister();",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "int rv_disable_monitor(struct rv_monitor_def *mdef)",
            "{",
            "\t__rv_disable_monitor(mdef, true);",
            "\treturn 0;",
            "}",
            "int rv_enable_monitor(struct rv_monitor_def *mdef)",
            "{",
            "\tint retval;",
            "",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (mdef->monitor->enabled)",
            "\t\treturn 0;",
            "",
            "\tretval = mdef->monitor->enable();",
            "",
            "\tif (!retval)",
            "\t\tmdef->monitor->enabled = 1;",
            "",
            "\treturn retval;",
            "}",
            "static ssize_t monitor_enable_write_data(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t\t size_t count, loff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tint retval;",
            "\tbool val;",
            "",
            "\tretval = kstrtobool_from_user(user_buf, count, &val);",
            "\tif (retval)",
            "\t\treturn retval;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tif (val)",
            "\t\tretval = rv_enable_monitor(mdef);",
            "\telse",
            "\t\tretval = rv_disable_monitor(mdef);",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "",
            "\treturn retval ? : count;",
            "}"
          ],
          "function_name": "rv_get_task_monitor_slot, rv_put_task_monitor_slot, monitor_enable_read_data, __rv_disable_monitor, rv_disable_monitor, rv_enable_monitor, monitor_enable_write_data",
          "description": "管理任务级监控槽位分配与回收，实现监控启停控制逻辑，通过互斥锁保护监控状态变更并同步跟踪事件处理。",
          "similarity": 0.614629328250885
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 742,
          "end_line": 798,
          "content": [
            "int rv_unregister_monitor(struct rv_monitor *monitor)",
            "{",
            "\tstruct rv_monitor_def *ptr, *next;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry_safe(ptr, next, &rv_monitors_list, list) {",
            "\t\tif (strcmp(monitor->name, ptr->monitor->name) == 0) {",
            "\t\t\trv_disable_monitor(ptr);",
            "\t\t\tlist_del(&ptr->list);",
            "\t\t\tdestroy_monitor_dir(ptr);",
            "\t\t}",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn 0;",
            "}",
            "int __init rv_init_interface(void)",
            "{",
            "\tstruct dentry *tmp;",
            "\tint retval;",
            "",
            "\trv_root.root_dir = rv_create_dir(\"rv\", NULL);",
            "\tif (!rv_root.root_dir)",
            "\t\tgoto out_err;",
            "",
            "\trv_root.monitors_dir = rv_create_dir(\"monitors\", rv_root.root_dir);",
            "\tif (!rv_root.monitors_dir)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"available_monitors\", RV_MODE_READ, rv_root.root_dir, NULL,",
            "\t\t\t     &available_monitors_ops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"enabled_monitors\", RV_MODE_WRITE, rv_root.root_dir, NULL,",
            "\t\t\t     &enabled_monitors_ops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"monitoring_on\", RV_MODE_WRITE, rv_root.root_dir, NULL,",
            "\t\t\t     &monitoring_on_fops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "\tretval = init_rv_reactors(rv_root.root_dir);",
            "\tif (retval)",
            "\t\tgoto out_err;",
            "",
            "\tturn_monitoring_on();",
            "",
            "\treturn 0;",
            "",
            "out_err:",
            "\trv_remove(rv_root.root_dir);",
            "\tprintk(KERN_ERR \"RV: Error while creating the RV interface\\n\");",
            "\treturn 1;",
            "}"
          ],
          "function_name": "rv_unregister_monitor, rv_init_interface",
          "description": "实现监控器注册注销流程，完成RV接口初始化，建立监控管理核心结构并注册基础控制接口，处理初始化失败时的资源清理。",
          "similarity": 0.5887473821640015
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 586,
          "end_line": 710,
          "content": [
            "bool rv_monitoring_on(void)",
            "{",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_rmb();",
            "\treturn READ_ONCE(monitoring_on);",
            "}",
            "static ssize_t monitoring_on_read_data(struct file *filp, char __user *user_buf,",
            "\t\t\t\t       size_t count, loff_t *ppos)",
            "{",
            "\tconst char *buff;",
            "",
            "\tbuff = rv_monitoring_on() ? \"1\\n\" : \"0\\n\";",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);",
            "}",
            "static void turn_monitoring_off(void)",
            "{",
            "\tWRITE_ONCE(monitoring_on, false);",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_wmb();",
            "}",
            "static void reset_all_monitors(void)",
            "{",
            "\tstruct rv_monitor_def *mdef;",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list) {",
            "\t\tif (mdef->monitor->enabled)",
            "\t\t\tmdef->monitor->reset();",
            "\t}",
            "}",
            "static void turn_monitoring_on(void)",
            "{",
            "\tWRITE_ONCE(monitoring_on, true);",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_wmb();",
            "}",
            "static void turn_monitoring_on_with_reset(void)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (rv_monitoring_on())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Monitors might be out of sync with the system if events were not",
            "\t * processed because of !rv_monitoring_on().",
            "\t *",
            "\t * Reset all monitors, forcing a re-sync.",
            "\t */",
            "\treset_all_monitors();",
            "\tturn_monitoring_on();",
            "}",
            "static ssize_t monitoring_on_write_data(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t\tsize_t count, loff_t *ppos)",
            "{",
            "\tint retval;",
            "\tbool val;",
            "",
            "\tretval = kstrtobool_from_user(user_buf, count, &val);",
            "\tif (retval)",
            "\t\treturn retval;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tif (val)",
            "\t\tturn_monitoring_on_with_reset();",
            "\telse",
            "\t\tturn_monitoring_off();",
            "",
            "\t/*",
            "\t * Wait for the execution of all events to finish",
            "\t * before returning to user-space.",
            "\t */",
            "\ttracepoint_synchronize_unregister();",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "",
            "\treturn count;",
            "}",
            "static void destroy_monitor_dir(struct rv_monitor_def *mdef)",
            "{",
            "\treactor_cleanup_monitor(mdef);",
            "\trv_remove(mdef->root_d);",
            "}",
            "int rv_register_monitor(struct rv_monitor *monitor)",
            "{",
            "\tstruct rv_monitor_def *r;",
            "\tint retval = 0;",
            "",
            "\tif (strlen(monitor->name) >= MAX_RV_MONITOR_NAME_SIZE) {",
            "\t\tpr_info(\"Monitor %s has a name longer than %d\\n\", monitor->name,",
            "\t\t\tMAX_RV_MONITOR_NAME_SIZE);",
            "\t\treturn -1;",
            "\t}",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry(r, &rv_monitors_list, list) {",
            "\t\tif (strcmp(monitor->name, r->monitor->name) == 0) {",
            "\t\t\tpr_info(\"Monitor %s is already registered\\n\", monitor->name);",
            "\t\t\tretval = -1;",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "\t}",
            "",
            "\tr = kzalloc(sizeof(struct rv_monitor_def), GFP_KERNEL);",
            "\tif (!r) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tr->monitor = monitor;",
            "",
            "\tretval = create_monitor_dir(r);",
            "\tif (retval) {",
            "\t\tkfree(r);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tlist_add_tail(&r->list, &rv_monitors_list);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "rv_monitoring_on, monitoring_on_read_data, turn_monitoring_off, reset_all_monitors, turn_monitoring_on, turn_monitoring_on_with_reset, monitoring_on_write_data, destroy_monitor_dir, rv_register_monitor",
          "description": "控制整体监控开关状态，提供监控开关切换接口，包含监控状态同步和异常恢复机制，确保监控器与系统状态一致性。",
          "similarity": 0.5407345294952393
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 1,
          "end_line": 169,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2019-2022 Red Hat, Inc. Daniel Bristot de Oliveira <bristot@kernel.org>",
            " *",
            " * This is the online Runtime Verification (RV) interface.",
            " *",
            " * RV is a lightweight (yet rigorous) method that complements classical",
            " * exhaustive verification techniques (such as model checking and",
            " * theorem proving) with a more practical approach to complex systems.",
            " *",
            " * RV works by analyzing the trace of the system's actual execution,",
            " * comparing it against a formal specification of the system behavior.",
            " * RV can give precise information on the runtime behavior of the",
            " * monitored system while enabling the reaction for unexpected",
            " * events, avoiding, for example, the propagation of a failure on",
            " * safety-critical systems.",
            " *",
            " * The development of this interface roots in the development of the",
            " * paper:",
            " *",
            " * De Oliveira, Daniel Bristot; Cucinotta, Tommaso; De Oliveira, Romulo",
            " * Silva. Efficient formal verification for the Linux kernel. In:",
            " * International Conference on Software Engineering and Formal Methods.",
            " * Springer, Cham, 2019. p. 315-332.",
            " *",
            " * And:",
            " *",
            " * De Oliveira, Daniel Bristot, et al. Automata-based formal analysis",
            " * and verification of the real-time Linux kernel. PhD Thesis, 2020.",
            " *",
            " * == Runtime monitor interface ==",
            " *",
            " * A monitor is the central part of the runtime verification of a system.",
            " *",
            " * The monitor stands in between the formal specification of the desired",
            " * (or undesired) behavior, and the trace of the actual system.",
            " *",
            " * In Linux terms, the runtime verification monitors are encapsulated",
            " * inside the \"RV monitor\" abstraction. A RV monitor includes a reference",
            " * model of the system, a set of instances of the monitor (per-cpu monitor,",
            " * per-task monitor, and so on), and the helper functions that glue the",
            " * monitor to the system via trace. Generally, a monitor includes some form",
            " * of trace output as a reaction for event parsing and exceptions,",
            " * as depicted bellow:",
            " *",
            " * Linux  +----- RV Monitor ----------------------------------+ Formal",
            " *  Realm |                                                   |  Realm",
            " *  +-------------------+     +----------------+     +-----------------+",
            " *  |   Linux kernel    |     |     Monitor    |     |     Reference   |",
            " *  |     Tracing       |  -> |   Instance(s)  | <-  |       Model     |",
            " *  | (instrumentation) |     | (verification) |     | (specification) |",
            " *  +-------------------+     +----------------+     +-----------------+",
            " *         |                          |                       |",
            " *         |                          V                       |",
            " *         |                     +----------+                 |",
            " *         |                     | Reaction |                 |",
            " *         |                     +--+--+--+-+                 |",
            " *         |                        |  |  |                   |",
            " *         |                        |  |  +-> trace output ?  |",
            " *         +------------------------|--|----------------------+",
            " *                                  |  +----> panic ?",
            " *                                  +-------> <user-specified>",
            " *",
            " * This file implements the interface for loading RV monitors, and",
            " * to control the verification session.",
            " *",
            " * == Registering monitors ==",
            " *",
            " * The struct rv_monitor defines a set of callback functions to control",
            " * a verification session. For instance, when a given monitor is enabled,",
            " * the \"enable\" callback function is called to hook the instrumentation",
            " * functions to the kernel trace events. The \"disable\" function is called",
            " * when disabling the verification session.",
            " *",
            " * A RV monitor is registered via:",
            " *   int rv_register_monitor(struct rv_monitor *monitor);",
            " * And unregistered via:",
            " *   int rv_unregister_monitor(struct rv_monitor *monitor);",
            " *",
            " * == User interface ==",
            " *",
            " * The user interface resembles kernel tracing interface. It presents",
            " * these files:",
            " *",
            " *  \"available_monitors\"",
            " *    - List the available monitors, one per line.",
            " *",
            " *    For example:",
            " *      # cat available_monitors",
            " *      wip",
            " *      wwnr",
            " *",
            " *  \"enabled_monitors\"",
            " *    - Lists the enabled monitors, one per line;",
            " *    - Writing to it enables a given monitor;",
            " *    - Writing a monitor name with a '!' prefix disables it;",
            " *    - Truncating the file disables all enabled monitors.",
            " *",
            " *    For example:",
            " *      # cat enabled_monitors",
            " *      # echo wip > enabled_monitors",
            " *      # echo wwnr >> enabled_monitors",
            " *      # cat enabled_monitors",
            " *      wip",
            " *      wwnr",
            " *      # echo '!wip' >> enabled_monitors",
            " *      # cat enabled_monitors",
            " *      wwnr",
            " *      # echo > enabled_monitors",
            " *      # cat enabled_monitors",
            " *      #",
            " *",
            " *    Note that more than one monitor can be enabled concurrently.",
            " *",
            " *  \"monitoring_on\"",
            " *    - It is an on/off general switcher for monitoring. Note",
            " *    that it does not disable enabled monitors or detach events,",
            " *    but stops the per-entity monitors from monitoring the events",
            " *    received from the instrumentation. It resembles the \"tracing_on\"",
            " *    switcher.",
            " *",
            " *  \"monitors/\"",
            " *    Each monitor will have its own directory inside \"monitors/\". There",
            " *    the monitor specific files will be presented.",
            " *    The \"monitors/\" directory resembles the \"events\" directory on",
            " *    tracefs.",
            " *",
            " *    For example:",
            " *      # cd monitors/wip/",
            " *      # ls",
            " *      desc  enable",
            " *      # cat desc",
            " *      auto-generated wakeup in preemptive monitor.",
            " *      # cat enable",
            " *      0",
            " *",
            " *  For further information, see:",
            " *   Documentation/trace/rv/runtime-verification.rst",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "",
            "#ifdef CONFIG_DA_MON_EVENTS",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/rv.h>",
            "#endif",
            "",
            "#include \"rv.h\"",
            "",
            "DEFINE_MUTEX(rv_interface_lock);",
            "",
            "static struct rv_interface rv_root;",
            "",
            "struct dentry *get_monitors_root(void)",
            "{",
            "\treturn rv_root.monitors_dir;",
            "}",
            "",
            "/*",
            " * Interface for the monitor register.",
            " */",
            "static LIST_HEAD(rv_monitors_list);",
            "",
            "static int task_monitor_count;",
            "static bool task_monitor_slots[RV_PER_TASK_MONITORS];",
            ""
          ],
          "function_name": null,
          "description": "定义RV监控接口的基础结构，包括互斥锁、全局监控根节点及监控列表，为后续监控注册和管理提供基础设施。",
          "similarity": 0.48366814851760864
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_dynevent.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:15:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_dynevent.c`\n\n---\n\n# `trace/trace_dynevent.c` 技术文档\n\n## 1. 文件概述\n\n`trace_dynevent.c` 是 Linux 内核中动态事件（Dynamic Event）子系统的通用控制接口实现文件。它提供了一套统一的框架，用于注册、创建、释放和查询各种类型的动态跟踪事件（如 kprobe、uprobe、synthetic events 等）。该文件通过 tracefs 接口 `/sys/kernel/tracing/dynamic_events` 向用户空间暴露控制能力，允许用户以字符串命令的形式动态添加或删除跟踪点，并维护所有动态事件的全局列表和生命周期管理。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct dyn_event_operations`**  \n  动态事件操作集，定义了特定类型动态事件所需实现的回调函数，包括：\n  - `create()`：根据命令字符串创建事件\n  - `show()`：将事件信息输出到 seq_file\n  - `is_busy()`：判断事件是否正在被使用\n  - `free()`：释放事件资源\n  - `match()`：匹配给定名称的事件\n\n- **`struct dyn_event`**  \n  动态事件的通用基类，包含指向其操作集 `ops` 的指针，具体事件类型通过继承此结构实现。\n\n- **`struct dynevent_cmd` / `struct dynevent_arg`**  \n  用于构建动态事件命令字符串的辅助结构，支持参数拼接与校验。\n\n### 主要函数\n\n| 函数 | 功能说明 |\n|------|--------|\n| `dyn_event_register()` | 注册一种新的动态事件类型（如 kprobe_ops）到全局列表 |\n| `dyn_event_create()` | 调用指定类型的操作集创建动态事件（加锁保护） |\n| `dyn_event_release()` | 根据命令字符串查找并释放匹配的动态事件 |\n| `dyn_events_release_all()` | 释放所有（或指定类型）的动态事件，支持批量清理 |\n| `trace_event_dyn_try_get_ref()` / `trace_event_dyn_put_ref()` | 对动态 trace_event_call 进行引用计数管理 |\n| `trace_event_dyn_busy()` | 检查动态事件是否正被使用（引用计数非零） |\n| `create_dyn_event()` | 解析用户命令，自动分发给注册的事件类型处理（支持 `-` 前缀删除） |\n| `dynevent_arg_add()` / `dynevent_arg_pair_add()` | 安全地向动态事件命令缓冲区追加参数 |\n\n### 全局变量\n\n- `dyn_event_ops_list`：已注册的 `dyn_event_operations` 链表\n- `dyn_event_list`：所有已创建的 `dyn_event` 实例链表\n- `dyn_event_ops_mutex`：保护 `dyn_event_ops_list` 和 trace_probe_log 的互斥锁\n- `event_mutex`：保护 `dyn_event_list` 的互斥锁\n\n## 3. 关键实现\n\n### 动态事件注册与分发机制\n- 通过 `dyn_event_register()` 将不同类型的动态事件（如 kprobe、uprobe）注册到全局链表 `dyn_event_ops_list`。\n- 用户写入 `dynamic_events` 文件时，`create_dyn_event()` 遍历该链表，依次调用各类型的 `create()` 方法，直到成功或返回非 `-ECANCELED` 错误。\n- 删除操作（命令以 `-` 或 `!` 开头）由 `dyn_event_release()` 处理，通过 `match()` 回调匹配事件并调用 `free()`。\n\n### 引用计数与忙状态检查\n- 动态事件对应的 `trace_event_call` 使用 `refcnt` 原子计数器管理生命周期。\n- `trace_event_dyn_try_get_ref()` 在 `ftrace_events` 全局列表中查找事件并增加引用，确保事件在使用中不被释放。\n- `is_busy()` 回调通常基于 `trace_event_dyn_busy()` 实现，防止正在使用的事件被删除。\n\n### tracefs 接口实现\n- 文件操作 `dynamic_events_ops` 实现了：\n  - **读操作**：通过 seq_file 遍历 `dyn_event_list`，调用各事件的 `show()` 方法输出配置。\n  - **写操作**：调用 `trace_parse_run_command()` 解析多行命令，逐行执行 `create_dyn_event()`。\n  - **截断操作（O_TRUNC）**：清空所有动态事件（调用 `dyn_events_release_all(NULL)`）。\n\n### 命令构建辅助函数\n- `dynevent_arg_add()` 提供安全的字符串拼接，支持参数校验（`check_arg` 回调）和自动添加分隔符，防止缓冲区溢出（使用 `seq_buf_printf`）。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `trace.h` / `trace_output.h`：使用 `trace_event_sem`、`ftrace_events` 列表及 trace_event_call 结构。\n  - `trace_dynevent.h`：定义 `dyn_event`、`dyn_event_operations` 等核心结构。\n- **内核子系统**：\n  - **Tracefs**：通过 `trace_create_file()` 创建 `dynamic_events` 控制文件。\n  - **Debugfs**：部分调试功能可能依赖 debugfs（头文件包含）。\n  - **内存管理**：使用 `argv_split()`/`argv_free()` 解析用户命令参数。\n- **具体事件实现**：  \n  本文件为框架层，实际事件类型（如 `kprobe_event`、`uprobe_event`）在各自文件中实现 `dyn_event_operations` 并调用 `dyn_event_register()` 注册。\n\n## 5. 使用场景\n\n1. **用户空间动态跟踪配置**  \n   用户通过向 `/sys/kernel/tracing/dynamic_events` 写入命令（如 `p:myprobe do_sys_open`）创建 kprobe 事件，或通过 `-:myprobe` 删除事件。\n\n2. **内核模块扩展跟踪能力**  \n   新的动态事件类型（如 future 的 eBPF-based events）可通过实现 `dyn_event_operations` 并注册到该框架，复用统一的 tracefs 接口和生命周期管理。\n\n3. **系统启动/关闭时的清理**  \n   `dyn_events_release_all()` 可在模块卸载或系统关闭时安全释放所有动态事件，确保无资源泄漏。\n\n4. **合成事件（Synthetic Events）支持**  \n   作为合成事件的基础框架，管理其创建、查询和销毁流程。\n\n5. **调试与诊断**  \n   通过读取 `dynamic_events` 文件，用户可查看当前系统中所有活跃的动态事件配置，用于调试跟踪会话。",
      "similarity": 0.6468915343284607,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_dynevent.c",
          "start_line": 132,
          "end_line": 239,
          "content": [
            "int dyn_event_create(const char *raw_command, struct dyn_event_operations *type)",
            "{",
            "\tint ret;",
            "",
            "\tmutex_lock(&dyn_event_ops_mutex);",
            "\tret = type->create(raw_command);",
            "\tmutex_unlock(&dyn_event_ops_mutex);",
            "\treturn ret;",
            "}",
            "static int create_dyn_event(const char *raw_command)",
            "{",
            "\tstruct dyn_event_operations *ops;",
            "\tint ret = -ENODEV;",
            "",
            "\tif (raw_command[0] == '-' || raw_command[0] == '!')",
            "\t\treturn dyn_event_release(raw_command, NULL);",
            "",
            "\tmutex_lock(&dyn_event_ops_mutex);",
            "\tlist_for_each_entry(ops, &dyn_event_ops_list, list) {",
            "\t\tret = ops->create(raw_command);",
            "\t\tif (!ret || ret != -ECANCELED)",
            "\t\t\tbreak;",
            "\t}",
            "\tmutex_unlock(&dyn_event_ops_mutex);",
            "\tif (ret == -ECANCELED)",
            "\t\tret = -EINVAL;",
            "",
            "\treturn ret;",
            "}",
            "void dyn_event_seq_stop(struct seq_file *m, void *v)",
            "{",
            "\tmutex_unlock(&event_mutex);",
            "}",
            "static int dyn_event_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct dyn_event *ev = v;",
            "",
            "\tif (ev && ev->ops)",
            "\t\treturn ev->ops->show(m, ev);",
            "",
            "\treturn 0;",
            "}",
            "int dyn_events_release_all(struct dyn_event_operations *type)",
            "{",
            "\tstruct dyn_event *ev, *tmp;",
            "\tint ret = 0;",
            "",
            "\tmutex_lock(&event_mutex);",
            "\tfor_each_dyn_event(ev) {",
            "\t\tif (type && ev->ops != type)",
            "\t\t\tcontinue;",
            "\t\tif (ev->ops->is_busy(ev)) {",
            "\t\t\tret = -EBUSY;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "\tfor_each_dyn_event_safe(ev, tmp) {",
            "\t\tif (type && ev->ops != type)",
            "\t\t\tcontinue;",
            "\t\tret = ev->ops->free(ev);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "out:",
            "\ttracing_reset_all_online_cpus();",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn ret;",
            "}",
            "static int dyn_event_open(struct inode *inode, struct file *file)",
            "{",
            "\tint ret;",
            "",
            "\tret = security_locked_down(LOCKDOWN_TRACEFS);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = tracing_check_open_get_tr(NULL);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {",
            "\t\tret = dyn_events_release_all(NULL);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\treturn seq_open(file, &dyn_event_seq_op);",
            "}",
            "static ssize_t dyn_event_write(struct file *file, const char __user *buffer,",
            "\t\t\t\tsize_t count, loff_t *ppos)",
            "{",
            "\treturn trace_parse_run_command(file, buffer, count, ppos,",
            "\t\t\t\t       create_dyn_event);",
            "}",
            "static __init int init_dynamic_event(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = tracing_init_dentry();",
            "\tif (ret)",
            "\t\treturn 0;",
            "",
            "\ttrace_create_file(\"dynamic_events\", TRACE_MODE_WRITE, NULL,",
            "\t\t\t  NULL, &dynamic_events_ops);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "dyn_event_create, create_dyn_event, dyn_event_seq_stop, dyn_event_seq_show, dyn_events_release_all, dyn_event_open, dyn_event_write, init_dynamic_event",
          "description": "该代码实现了Linux动态跟踪事件框架的核心逻辑，提供事件创建、序列化输出与资源管理功能。`dyn_event_create`作为通用创建接口调用具体类型的`create`方法，`create_dyn_event`遍历注册的事件操作符尝试匹配并创建事件；其余函数协同管理事件生命周期、序列化展示及文件操作。代码上下文完整，未引入未出现的API。",
          "similarity": 0.646385669708252
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_dynevent.c",
          "start_line": 22,
          "end_line": 122,
          "content": [
            "bool trace_event_dyn_try_get_ref(struct trace_event_call *dyn_call)",
            "{",
            "\tstruct trace_event_call *call;",
            "\tbool ret = false;",
            "",
            "\tif (WARN_ON_ONCE(!(dyn_call->flags & TRACE_EVENT_FL_DYNAMIC)))",
            "\t\treturn false;",
            "",
            "\tdown_read(&trace_event_sem);",
            "\tlist_for_each_entry(call, &ftrace_events, list) {",
            "\t\tif (call == dyn_call) {",
            "\t\t\tatomic_inc(&dyn_call->refcnt);",
            "\t\t\tret = true;",
            "\t\t}",
            "\t}",
            "\tup_read(&trace_event_sem);",
            "\treturn ret;",
            "}",
            "void trace_event_dyn_put_ref(struct trace_event_call *call)",
            "{",
            "\tif (WARN_ON_ONCE(!(call->flags & TRACE_EVENT_FL_DYNAMIC)))",
            "\t\treturn;",
            "",
            "\tif (WARN_ON_ONCE(atomic_read(&call->refcnt) <= 0)) {",
            "\t\tatomic_set(&call->refcnt, 0);",
            "\t\treturn;",
            "\t}",
            "",
            "\tatomic_dec(&call->refcnt);",
            "}",
            "bool trace_event_dyn_busy(struct trace_event_call *call)",
            "{",
            "\treturn atomic_read(&call->refcnt) != 0;",
            "}",
            "int dyn_event_register(struct dyn_event_operations *ops)",
            "{",
            "\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||",
            "\t    !ops->free || !ops->match)",
            "\t\treturn -EINVAL;",
            "",
            "\tINIT_LIST_HEAD(&ops->list);",
            "\tmutex_lock(&dyn_event_ops_mutex);",
            "\tlist_add_tail(&ops->list, &dyn_event_ops_list);",
            "\tmutex_unlock(&dyn_event_ops_mutex);",
            "\treturn 0;",
            "}",
            "int dyn_event_release(const char *raw_command, struct dyn_event_operations *type)",
            "{",
            "\tstruct dyn_event *pos, *n;",
            "\tchar *system = NULL, *event, *p;",
            "\tint argc, ret = -ENOENT;",
            "\tchar **argv;",
            "",
            "\targv = argv_split(GFP_KERNEL, raw_command, &argc);",
            "\tif (!argv)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (argv[0][0] == '-') {",
            "\t\tif (argv[0][1] != ':') {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tevent = &argv[0][2];",
            "\t} else {",
            "\t\tevent = strchr(argv[0], ':');",
            "\t\tif (!event) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tevent++;",
            "\t}",
            "",
            "\tp = strchr(event, '/');",
            "\tif (p) {",
            "\t\tsystem = event;",
            "\t\tevent = p + 1;",
            "\t\t*p = '\\0';",
            "\t}",
            "\tif (!system && event[0] == '\\0') {",
            "\t\tret = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmutex_lock(&event_mutex);",
            "\tfor_each_dyn_event_safe(pos, n) {",
            "\t\tif (type && type != pos->ops)",
            "\t\t\tcontinue;",
            "\t\tif (!pos->ops->match(system, event,",
            "\t\t\t\targc - 1, (const char **)argv + 1, pos))",
            "\t\t\tcontinue;",
            "",
            "\t\tret = pos->ops->free(pos);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "\ttracing_reset_all_online_cpus();",
            "\tmutex_unlock(&event_mutex);",
            "out:",
            "\targv_free(argv);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "trace_event_dyn_try_get_ref, trace_event_dyn_put_ref, trace_event_dyn_busy, dyn_event_register, dyn_event_release",
          "description": "该代码实现了动态跟踪事件的引用计数管理及注册释放机制。  \n`trace_event_dyn_*`系列函数通过原子操作维护动态事件调用的引用计数，确保并发访问安全，并通过busy状态判断事件是否处于活动状态；`dyn_event_register`将动态事件操作注册至全局链表，`dyn_event_release`根据命令参数匹配并释放对应事件资源。  \n注：代码片段未包含全局数据结构定义（如`ftrace_events`、`dyn_event_ops_list`等），上下文存在缺失。",
          "similarity": 0.5856634378433228
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_dynevent.c",
          "start_line": 309,
          "end_line": 400,
          "content": [
            "int dynevent_arg_add(struct dynevent_cmd *cmd,",
            "\t\t     struct dynevent_arg *arg,",
            "\t\t     dynevent_check_arg_fn_t check_arg)",
            "{",
            "\tint ret = 0;",
            "",
            "\tif (check_arg) {",
            "\t\tret = check_arg(arg);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);",
            "\tif (ret) {",
            "\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);",
            "\t\treturn -E2BIG;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "int dynevent_arg_pair_add(struct dynevent_cmd *cmd,",
            "\t\t\t  struct dynevent_arg_pair *arg_pair,",
            "\t\t\t  dynevent_check_arg_fn_t check_arg)",
            "{",
            "\tint ret = 0;",
            "",
            "\tif (check_arg) {",
            "\t\tret = check_arg(arg_pair);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tret = seq_buf_printf(&cmd->seq, \" %s%c%s%c\", arg_pair->lhs,",
            "\t\t\t     arg_pair->operator, arg_pair->rhs,",
            "\t\t\t     arg_pair->separator);",
            "\tif (ret) {",
            "\t\tpr_err(\"field string is too long: %s%c%s%c\\n\", arg_pair->lhs,",
            "\t\t       arg_pair->operator, arg_pair->rhs,",
            "\t\t       arg_pair->separator);",
            "\t\treturn -E2BIG;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "int dynevent_str_add(struct dynevent_cmd *cmd, const char *str)",
            "{",
            "\tint ret = 0;",
            "",
            "\tret = seq_buf_puts(&cmd->seq, str);",
            "\tif (ret) {",
            "\t\tpr_err(\"String is too long: %s\\n\", str);",
            "\t\treturn -E2BIG;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "void dynevent_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen,",
            "\t\t       enum dynevent_type type,",
            "\t\t       dynevent_create_fn_t run_command)",
            "{",
            "\tmemset(cmd, '\\0', sizeof(*cmd));",
            "",
            "\tseq_buf_init(&cmd->seq, buf, maxlen);",
            "\tcmd->type = type;",
            "\tcmd->run_command = run_command;",
            "}",
            "void dynevent_arg_init(struct dynevent_arg *arg,",
            "\t\t       char separator)",
            "{",
            "\tmemset(arg, '\\0', sizeof(*arg));",
            "",
            "\tif (!separator)",
            "\t\tseparator = ' ';",
            "\targ->separator = separator;",
            "}",
            "void dynevent_arg_pair_init(struct dynevent_arg_pair *arg_pair,",
            "\t\t\t    char operator, char separator)",
            "{",
            "\tmemset(arg_pair, '\\0', sizeof(*arg_pair));",
            "",
            "\tif (!operator)",
            "\t\toperator = ' ';",
            "\targ_pair->operator = operator;",
            "",
            "\tif (!separator)",
            "\t\tseparator = ' ';",
            "\targ_pair->separator = separator;",
            "}",
            "int dynevent_create(struct dynevent_cmd *cmd)",
            "{",
            "\treturn cmd->run_command(cmd);",
            "}"
          ],
          "function_name": "dynevent_arg_add, dynevent_arg_pair_add, dynevent_str_add, dynevent_cmd_init, dynevent_arg_init, dynevent_arg_pair_init, dynevent_create",
          "description": "该代码段实现了动态跟踪事件系统的参数及命令构建逻辑，核心功能是通过一系列辅助函数处理带参数的追踪命令生成与校验。  \n`dynevent_arg_add`等函数将参数格式化至序列缓冲区并检查长度溢出，`dynevent_cmd_init`等初始化函数则配置命令结构体及其关联的序列化上下文。  \n所有函数均围绕动态事件命令的构建流程展开，包含参数校验、字符串追加及结构体初始化等基础操作，但未涉及完整的动态事件注册或解析机制。",
          "similarity": 0.5351598262786865
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_dynevent.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Generic dynamic event control interface",
            " *",
            " * Copyright (C) 2018 Masami Hiramatsu <mhiramat@kernel.org>",
            " */",
            "",
            "#include <linux/debugfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tracefs.h>",
            "",
            "#include \"trace.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace_dynevent.h\"",
            "",
            "DEFINE_MUTEX(dyn_event_ops_mutex);",
            "static LIST_HEAD(dyn_event_ops_list);",
            ""
          ],
          "function_name": null,
          "description": "此代码段定义了动态事件控制接口的核心数据结构，包含一个互斥锁`dyn_event_ops_mutex`用于保护动态事件操作的并发访问，以及一个链表头`dyn_event_ops_list`用于注册和管理动态事件操作模块。作为全局定义，其用途是为后续动态事件的注册、遍历及同步操作提供基础设施。由于未包含具体函数实现，仅能确认其作为动态事件系统的基础组件存在。",
          "similarity": 0.49714887142181396
        }
      ]
    }
  ]
}