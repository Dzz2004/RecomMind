{
  "query": "Linux内核虚拟内存管理实现原理",
  "timestamp": "2025-12-22 14:00:19",
  "retrieved_files": [
    {
      "source_file": "mm/vmstat.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:34:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `vmstat.c`\n\n---\n\n# vmstat.c 技术文档\n\n## 1. 文件概述\n\n`vmstat.c` 是 Linux 内核内存管理子系统（MM）中的核心统计模块，负责维护和管理虚拟内存相关的各类计数器。该文件实现了以下三类主要统计信息：\n\n- **全局/区域级内存统计**（zone/node 级别）\n- **NUMA 架构下的内存访问统计**\n- **虚拟内存事件计数器**（如页面分配、回收、交换等）\n\n这些统计数据通过 `/proc/vmstat`、`/sys/kernel/debug/` 等接口暴露给用户空间，用于性能监控、调优和故障诊断。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `vm_zone_stat[NR_VM_ZONE_STAT_ITEMS]`：全局区域级内存统计计数器（如空闲页、活跃页等）\n- `vm_node_stat[NR_VM_NODE_STAT_ITEMS]`：NUMA 节点级内存统计计数器\n- `vm_numa_event[NR_VM_NUMA_EVENT_ITEMS]`：NUMA 相关事件计数器（如本地/远程页面分配）\n- `vm_event_states`（per-CPU）：每个 CPU 的虚拟内存事件状态\n- `per_cpu_zonestats` / `per_cpu_nodestats`：每个 CPU 对应的区域/节点统计结构\n\n### 主要函数\n- **NUMA 统计控制**：\n  - `sysctl_vm_numa_stat_handler()`：通过 sysctl 接口动态启用/禁用 NUMA 统计\n  - `invalid_numa_statistics()`：清除所有 NUMA 计数器\n  - `fold_vm_numa_events()`：将 per-CPU NUMA 事件聚合到全局计数器\n\n- **VM 事件管理**（需 CONFIG_VM_EVENT_COUNTERS）：\n  - `all_vm_events()`：汇总所有 CPU 的 VM 事件计数\n  - `vm_events_fold_cpu()`：将指定 CPU 的事件折叠到全局计数器\n\n- **阈值计算与刷新**（SMP 系统）：\n  - `calculate_normal_threshold()`：基于 CPU 数量和内存大小计算正常统计更新阈值\n  - `calculate_pressure_threshold()`：计算内存压力下的保守阈值\n  - `refresh_zone_stat_thresholds()`：为所有区域和节点刷新 per-CPU 统计阈值\n\n## 3. 关键实现\n\n### Per-CPU 统计与延迟更新机制\n为避免频繁原子操作带来的性能开销，内核采用 **per-CPU 缓存 + 延迟批量更新** 策略：\n- 每个 CPU 维护自己的统计副本（如 `per_cpu_zonestats`）\n- 当本地计数器超过预设阈值（`stat_threshold`）时，才将增量同步到全局原子变量\n- 阈值通过 `calculate_normal_threshold()` 动态调整，平衡精度与性能\n\n### NUMA 统计动态开关\n通过静态分支（`static_branch_enable/disable`）实现零开销切换：\n- 启用时：记录本地/远程页面分配等 NUMA 行为\n- 禁用时：立即清零所有相关计数器，避免无效统计\n\n### 内存水位线与漂移容忍\n在 `refresh_zone_stat_thresholds()` 中考虑了统计延迟导致的“漂移”问题：\n- 计算最大可能漂移量：`max_drift = num_online_cpus() * threshold`\n- 若漂移可能掩盖 min watermark 违规，则设置 `percpu_drift_mark` 作为更严格的警戒线\n\n### 高效聚合算法\n- 使用 `xchg()` 原子交换清零 per-CPU 计数器，避免读-改-写竞争\n- 全局聚合时加 `cpus_read_lock()` 防止 CPU 热插拔导致的数据不一致\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/mm.h>`：内存管理核心定义\n- `<linux/vmstat.h>`：VM 统计相关的宏和类型\n- `<linux/percpu.h>`（隐含）：Per-CPU 变量支持\n- `\"internal.h\"`：MM 子系统内部接口\n\n### 配置选项依赖\n- `CONFIG_NUMA`：启用 NUMA 统计相关代码\n- `CONFIG_VM_EVENT_COUNTERS`：启用详细的 VM 事件计数\n- `CONFIG_SMP`：多处理器阈值计算逻辑\n\n### 符号导出\n- `EXPORT_SYMBOL(vm_zone_stat)` / `vm_node_stat`：供其他模块（如 compaction、vmscan）读取统计\n- `EXPORT_SYMBOL_GPL(all_vm_events)`：供 tracing 或 debug 模块使用\n\n## 5. 使用场景\n\n### 内核内部使用\n- **内存回收**（kswapd）：根据 `NR_FREE_PAGES` 等统计决定回收时机\n- **页面分配器**：更新分配路径的统计（如 `alloc_pages` 调用 `count_vm_event`）\n- **内存压缩**（compaction）：监控迁移成功率等指标\n- **OOM Killer**：评估系统内存压力\n\n### 用户空间监控\n- **`/proc/vmstat`**：提供全局 VM 统计（由 `fs/proc/proc_misc.c` 调用 `all_vm_events` 生成）\n- **`/sys/kernel/debug/`**：debugfs 接口暴露详细 per-zone 统计\n- **性能分析工具**：如 `sar -r`, `vmstat`, `perf` 依赖这些计数器\n- **NUMA 调优**：通过 `numastat` 工具分析跨节点访问开销\n\n### 动态调优\n- 管理员可通过 `sysctl vm.numa_stat=0/1` 动态关闭 NUMA 统计以降低开销\n- 内核根据系统规模自动调整统计更新频率，适应从嵌入式设备到大型服务器的不同场景",
      "similarity": 0.6526869535446167,
      "chunks": [
        {
          "chunk_id": 11,
          "file_path": "mm/vmstat.c",
          "start_line": 1773,
          "end_line": 1875,
          "content": [
            "static int zoneinfo_show(struct seq_file *m, void *arg)",
            "{",
            "\tpg_data_t *pgdat = (pg_data_t *)arg;",
            "\twalk_zones_in_node(m, pgdat, false, false, zoneinfo_show_print);",
            "\treturn 0;",
            "}",
            "static int vmstat_show(struct seq_file *m, void *arg)",
            "{",
            "\tunsigned long *l = arg;",
            "\tunsigned long off = l - (unsigned long *)m->private;",
            "",
            "\tseq_puts(m, vmstat_text[off]);",
            "\tseq_put_decimal_ull(m, \" \", *l);",
            "\tseq_putc(m, '\\n');",
            "",
            "\tif (off == NR_VMSTAT_ITEMS - 1) {",
            "\t\t/*",
            "\t\t * We've come to the end - add any deprecated counters to avoid",
            "\t\t * breaking userspace which might depend on them being present.",
            "\t\t */",
            "\t\tseq_puts(m, \"nr_unstable 0\\n\");",
            "\t}",
            "\treturn 0;",
            "}",
            "static void vmstat_stop(struct seq_file *m, void *arg)",
            "{",
            "\tkfree(m->private);",
            "\tm->private = NULL;",
            "}",
            "static void refresh_vm_stats(struct work_struct *work)",
            "{",
            "\trefresh_cpu_vm_stats(true);",
            "}",
            "int vmstat_refresh(struct ctl_table *table, int write,",
            "\t\t   void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tlong val;",
            "\tint err;",
            "\tint i;",
            "",
            "\t/*",
            "\t * The regular update, every sysctl_stat_interval, may come later",
            "\t * than expected: leaving a significant amount in per_cpu buckets.",
            "\t * This is particularly misleading when checking a quantity of HUGE",
            "\t * pages, immediately after running a test.  /proc/sys/vm/stat_refresh,",
            "\t * which can equally be echo'ed to or cat'ted from (by root),",
            "\t * can be used to update the stats just before reading them.",
            "\t *",
            "\t * Oh, and since global_zone_page_state() etc. are so careful to hide",
            "\t * transiently negative values, report an error here if any of",
            "\t * the stats is negative, so we know to go looking for imbalance.",
            "\t */",
            "\terr = schedule_on_each_cpu(refresh_vm_stats);",
            "\tif (err)",
            "\t\treturn err;",
            "\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {",
            "\t\t/*",
            "\t\t * Skip checking stats known to go negative occasionally.",
            "\t\t */",
            "\t\tswitch (i) {",
            "\t\tcase NR_ZONE_WRITE_PENDING:",
            "\t\tcase NR_FREE_CMA_PAGES:",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tval = atomic_long_read(&vm_zone_stat[i]);",
            "\t\tif (val < 0) {",
            "\t\t\tpr_warn(\"%s: %s %ld\\n\",",
            "\t\t\t\t__func__, zone_stat_name(i), val);",
            "\t\t}",
            "\t}",
            "\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {",
            "\t\t/*",
            "\t\t * Skip checking stats known to go negative occasionally.",
            "\t\t */",
            "\t\tswitch (i) {",
            "\t\tcase NR_WRITEBACK:",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tval = atomic_long_read(&vm_node_stat[i]);",
            "\t\tif (val < 0) {",
            "\t\t\tpr_warn(\"%s: %s %ld\\n\",",
            "\t\t\t\t__func__, node_stat_name(i), val);",
            "\t\t}",
            "\t}",
            "\tif (write)",
            "\t\t*ppos += *lenp;",
            "\telse",
            "\t\t*lenp = 0;",
            "\treturn 0;",
            "}",
            "static void vmstat_update(struct work_struct *w)",
            "{",
            "\tif (refresh_cpu_vm_stats(true)) {",
            "\t\t/*",
            "\t\t * Counters were updated so we expect more updates",
            "\t\t * to occur in the future. Keep on running the",
            "\t\t * update worker thread.",
            "\t\t */",
            "\t\tqueue_delayed_work_on(smp_processor_id(), mm_percpu_wq,",
            "\t\t\t\tthis_cpu_ptr(&vmstat_work),",
            "\t\t\t\tround_jiffies_relative(sysctl_stat_interval));",
            "\t}",
            "}"
          ],
          "function_name": "zoneinfo_show, vmstat_show, vmstat_stop, refresh_vm_stats, vmstat_refresh, vmstat_update",
          "description": "提供虚拟内存统计项的显示与刷新功能，支持通过sysctl接口手动刷新统计数据，包含跨CPU的统计更新及异常值检查逻辑",
          "similarity": 0.5924612879753113
        },
        {
          "chunk_id": 13,
          "file_path": "mm/vmstat.c",
          "start_line": 2093,
          "end_line": 2211,
          "content": [
            "static int vmstat_cpu_down_prep(unsigned int cpu)",
            "{",
            "\tcancel_delayed_work_sync(&per_cpu(vmstat_work, cpu));",
            "\treturn 0;",
            "}",
            "static int vmstat_cpu_dead(unsigned int cpu)",
            "{",
            "\tconst struct cpumask *node_cpus;",
            "\tint node;",
            "",
            "\tnode = cpu_to_node(cpu);",
            "",
            "\trefresh_zone_stat_thresholds();",
            "\tnode_cpus = cpumask_of_node(node);",
            "\tif (!cpumask_empty(node_cpus))",
            "\t\treturn 0;",
            "",
            "\tnode_clear_state(node, N_CPU);",
            "",
            "\treturn 0;",
            "}",
            "void __init init_mm_internals(void)",
            "{",
            "\tint ret __maybe_unused;",
            "",
            "\tmm_percpu_wq = alloc_workqueue(\"mm_percpu_wq\", WQ_MEM_RECLAIM, 0);",
            "",
            "#ifdef CONFIG_SMP",
            "\tret = cpuhp_setup_state_nocalls(CPUHP_MM_VMSTAT_DEAD, \"mm/vmstat:dead\",",
            "\t\t\t\t\tNULL, vmstat_cpu_dead);",
            "\tif (ret < 0)",
            "\t\tpr_err(\"vmstat: failed to register 'dead' hotplug state\\n\");",
            "",
            "\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, \"mm/vmstat:online\",",
            "\t\t\t\t\tvmstat_cpu_online,",
            "\t\t\t\t\tvmstat_cpu_down_prep);",
            "\tif (ret < 0)",
            "\t\tpr_err(\"vmstat: failed to register 'online' hotplug state\\n\");",
            "",
            "\tcpus_read_lock();",
            "\tinit_cpu_node_state();",
            "\tcpus_read_unlock();",
            "",
            "\tstart_shepherd_timer();",
            "#endif",
            "#ifdef CONFIG_PROC_FS",
            "\tproc_create_seq(\"buddyinfo\", 0444, NULL, &fragmentation_op);",
            "\tproc_create_seq(\"pagetypeinfo\", 0400, NULL, &pagetypeinfo_op);",
            "\tproc_create_seq(\"vmstat\", 0444, NULL, &vmstat_op);",
            "\tproc_create_seq(\"zoneinfo\", 0444, NULL, &zoneinfo_op);",
            "#endif",
            "}",
            "static int unusable_free_index(unsigned int order,",
            "\t\t\t\tstruct contig_page_info *info)",
            "{",
            "\t/* No free memory is interpreted as all free memory is unusable */",
            "\tif (info->free_pages == 0)",
            "\t\treturn 1000;",
            "",
            "\t/*",
            "\t * Index should be a value between 0 and 1. Return a value to 3",
            "\t * decimal places.",
            "\t *",
            "\t * 0 => no fragmentation",
            "\t * 1 => high fragmentation",
            "\t */",
            "\treturn div_u64((info->free_pages - (info->free_blocks_suitable << order)) * 1000ULL, info->free_pages);",
            "",
            "}",
            "static void unusable_show_print(struct seq_file *m,",
            "\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tunsigned int order;",
            "\tint index;",
            "\tstruct contig_page_info info;",
            "",
            "\tseq_printf(m, \"Node %d, zone %8s \",",
            "\t\t\t\tpgdat->node_id,",
            "\t\t\t\tzone->name);",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; ++order) {",
            "\t\tfill_contig_page_info(zone, order, &info);",
            "\t\tindex = unusable_free_index(order, &info);",
            "\t\tseq_printf(m, \"%d.%03d \", index / 1000, index % 1000);",
            "\t}",
            "",
            "\tseq_putc(m, '\\n');",
            "}",
            "static int unusable_show(struct seq_file *m, void *arg)",
            "{",
            "\tpg_data_t *pgdat = (pg_data_t *)arg;",
            "",
            "\t/* check memoryless node */",
            "\tif (!node_state(pgdat->node_id, N_MEMORY))",
            "\t\treturn 0;",
            "",
            "\twalk_zones_in_node(m, pgdat, true, false, unusable_show_print);",
            "",
            "\treturn 0;",
            "}",
            "static void extfrag_show_print(struct seq_file *m,",
            "\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tunsigned int order;",
            "\tint index;",
            "",
            "\t/* Alloc on stack as interrupts are disabled for zone walk */",
            "\tstruct contig_page_info info;",
            "",
            "\tseq_printf(m, \"Node %d, zone %8s \",",
            "\t\t\t\tpgdat->node_id,",
            "\t\t\t\tzone->name);",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; ++order) {",
            "\t\tfill_contig_page_info(zone, order, &info);",
            "\t\tindex = __fragmentation_index(order, &info);",
            "\t\tseq_printf(m, \"%2d.%03d \", index / 1000, index % 1000);",
            "\t}",
            "",
            "\tseq_putc(m, '\\n');",
            "}"
          ],
          "function_name": "vmstat_cpu_down_prep, vmstat_cpu_dead, init_mm_internals, unusable_free_index, unusable_show_print, unusable_show, extfrag_show_print",
          "description": "初始化内存管理内部结构体并注册proc文件系统接口，实现不可用内存碎片率计算及扩展碎片化指数的输出功能",
          "similarity": 0.5709846019744873
        },
        {
          "chunk_id": 5,
          "file_path": "mm/vmstat.c",
          "start_line": 595,
          "end_line": 699,
          "content": [
            "void mod_zone_page_state(struct zone *zone, enum zone_stat_item item,",
            "\t\t\t long delta)",
            "{",
            "\tmod_zone_state(zone, item, delta, 0);",
            "}",
            "void inc_zone_page_state(struct page *page, enum zone_stat_item item)",
            "{",
            "\tmod_zone_state(page_zone(page), item, 1, 1);",
            "}",
            "void dec_zone_page_state(struct page *page, enum zone_stat_item item)",
            "{",
            "\tmod_zone_state(page_zone(page), item, -1, -1);",
            "}",
            "static inline void mod_node_state(struct pglist_data *pgdat,",
            "       enum node_stat_item item, int delta, int overstep_mode)",
            "{",
            "\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;",
            "\ts8 __percpu *p = pcp->vm_node_stat_diff + item;",
            "\tlong o, n, t, z;",
            "",
            "\tif (vmstat_item_in_bytes(item)) {",
            "\t\t/*",
            "\t\t * Only cgroups use subpage accounting right now; at",
            "\t\t * the global level, these items still change in",
            "\t\t * multiples of whole pages. Store them as pages",
            "\t\t * internally to keep the per-cpu counters compact.",
            "\t\t */",
            "\t\tVM_WARN_ON_ONCE(delta & (PAGE_SIZE - 1));",
            "\t\tdelta >>= PAGE_SHIFT;",
            "\t}",
            "",
            "\tdo {",
            "\t\tz = 0;  /* overflow to node counters */",
            "",
            "\t\t/*",
            "\t\t * The fetching of the stat_threshold is racy. We may apply",
            "\t\t * a counter threshold to the wrong the cpu if we get",
            "\t\t * rescheduled while executing here. However, the next",
            "\t\t * counter update will apply the threshold again and",
            "\t\t * therefore bring the counter under the threshold again.",
            "\t\t *",
            "\t\t * Most of the time the thresholds are the same anyways",
            "\t\t * for all cpus in a node.",
            "\t\t */",
            "\t\tt = this_cpu_read(pcp->stat_threshold);",
            "",
            "\t\to = this_cpu_read(*p);",
            "\t\tn = delta + o;",
            "",
            "\t\tif (abs(n) > t) {",
            "\t\t\tint os = overstep_mode * (t >> 1) ;",
            "",
            "\t\t\t/* Overflow must be added to node counters */",
            "\t\t\tz = n + os;",
            "\t\t\tn = -os;",
            "\t\t}",
            "\t} while (this_cpu_cmpxchg(*p, o, n) != o);",
            "",
            "\tif (z)",
            "\t\tnode_page_state_add(z, pgdat, item);",
            "}",
            "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,",
            "\t\t\t\t\tlong delta)",
            "{",
            "\tmod_node_state(pgdat, item, delta, 0);",
            "}",
            "void inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)",
            "{",
            "\tmod_node_state(pgdat, item, 1, 1);",
            "}",
            "void inc_node_page_state(struct page *page, enum node_stat_item item)",
            "{",
            "\tmod_node_state(page_pgdat(page), item, 1, 1);",
            "}",
            "void dec_node_page_state(struct page *page, enum node_stat_item item)",
            "{",
            "\tmod_node_state(page_pgdat(page), item, -1, -1);",
            "}",
            "void mod_zone_page_state(struct zone *zone, enum zone_stat_item item,",
            "\t\t\t long delta)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\t__mod_zone_page_state(zone, item, delta);",
            "\tlocal_irq_restore(flags);",
            "}",
            "void inc_zone_page_state(struct page *page, enum zone_stat_item item)",
            "{",
            "\tunsigned long flags;",
            "\tstruct zone *zone;",
            "",
            "\tzone = page_zone(page);",
            "\tlocal_irq_save(flags);",
            "\t__inc_zone_state(zone, item);",
            "\tlocal_irq_restore(flags);",
            "}",
            "void dec_zone_page_state(struct page *page, enum zone_stat_item item)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\t__dec_zone_page_state(page, item);",
            "\tlocal_irq_restore(flags);",
            "}"
          ],
          "function_name": "mod_zone_page_state, inc_zone_page_state, dec_zone_page_state, mod_node_state, mod_node_page_state, inc_node_state, inc_node_page_state, dec_node_page_state, mod_zone_page_state, inc_zone_page_state, dec_zone_page_state",
          "description": "实现对内存区域（zone）和节点（node）的页面状态修改函数，通过per-CPU统计和溢出处理机制同步至全局统计，支持NUMA架构下的内存计数。",
          "similarity": 0.5482706427574158
        },
        {
          "chunk_id": 9,
          "file_path": "mm/vmstat.c",
          "start_line": 1474,
          "end_line": 1578,
          "content": [
            "static void frag_show_print(struct seq_file *m, pg_data_t *pgdat,",
            "\t\t\t\t\t\tstruct zone *zone)",
            "{",
            "\tint order;",
            "",
            "\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; ++order)",
            "\t\t/*",
            "\t\t * Access to nr_free is lockless as nr_free is used only for",
            "\t\t * printing purposes. Use data_race to avoid KCSAN warning.",
            "\t\t */",
            "\t\tseq_printf(m, \"%6lu \", data_race(zone->free_area[order].nr_free));",
            "\tseq_putc(m, '\\n');",
            "}",
            "static int frag_show(struct seq_file *m, void *arg)",
            "{",
            "\tpg_data_t *pgdat = (pg_data_t *)arg;",
            "\twalk_zones_in_node(m, pgdat, true, false, frag_show_print);",
            "\treturn 0;",
            "}",
            "static void pagetypeinfo_showfree_print(struct seq_file *m,",
            "\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tint order, mtype;",
            "",
            "\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++) {",
            "\t\tseq_printf(m, \"Node %4d, zone %8s, type %12s \",",
            "\t\t\t\t\tpgdat->node_id,",
            "\t\t\t\t\tzone->name,",
            "\t\t\t\t\tmigratetype_names[mtype]);",
            "\t\tfor (order = 0; order < NR_PAGE_ORDERS; ++order) {",
            "\t\t\tunsigned long freecount = 0;",
            "\t\t\tstruct free_area *area;",
            "\t\t\tstruct list_head *curr;",
            "\t\t\tbool overflow = false;",
            "",
            "\t\t\tarea = &(zone->free_area[order]);",
            "",
            "\t\t\tlist_for_each(curr, &area->free_list[mtype]) {",
            "\t\t\t\t/*",
            "\t\t\t\t * Cap the free_list iteration because it might",
            "\t\t\t\t * be really large and we are under a spinlock",
            "\t\t\t\t * so a long time spent here could trigger a",
            "\t\t\t\t * hard lockup detector. Anyway this is a",
            "\t\t\t\t * debugging tool so knowing there is a handful",
            "\t\t\t\t * of pages of this order should be more than",
            "\t\t\t\t * sufficient.",
            "\t\t\t\t */",
            "\t\t\t\tif (++freecount >= 100000) {",
            "\t\t\t\t\toverflow = true;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tseq_printf(m, \"%s%6lu \", overflow ? \">\" : \"\", freecount);",
            "\t\t\tspin_unlock_irq(&zone->lock);",
            "\t\t\tcond_resched();",
            "\t\t\tspin_lock_irq(&zone->lock);",
            "\t\t}",
            "\t\tseq_putc(m, '\\n');",
            "\t}",
            "}",
            "static void pagetypeinfo_showfree(struct seq_file *m, void *arg)",
            "{",
            "\tint order;",
            "\tpg_data_t *pgdat = (pg_data_t *)arg;",
            "",
            "\t/* Print header */",
            "\tseq_printf(m, \"%-43s \", \"Free pages count per migrate type at order\");",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; ++order)",
            "\t\tseq_printf(m, \"%6d \", order);",
            "\tseq_putc(m, '\\n');",
            "",
            "\twalk_zones_in_node(m, pgdat, true, false, pagetypeinfo_showfree_print);",
            "}",
            "static void pagetypeinfo_showblockcount_print(struct seq_file *m,",
            "\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tint mtype;",
            "\tunsigned long pfn;",
            "\tunsigned long start_pfn = zone->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(zone);",
            "\tunsigned long count[MIGRATE_TYPES] = { 0, };",
            "",
            "\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {",
            "\t\tstruct page *page;",
            "",
            "\t\tpage = pfn_to_online_page(pfn);",
            "\t\tif (!page)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (page_zone(page) != zone)",
            "\t\t\tcontinue;",
            "",
            "\t\tmtype = get_pageblock_migratetype(page);",
            "",
            "\t\tif (mtype < MIGRATE_TYPES)",
            "\t\t\tcount[mtype]++;",
            "\t}",
            "",
            "\t/* Print counts */",
            "\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);",
            "\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)",
            "\t\tseq_printf(m, \"%12lu \", count[mtype]);",
            "\tseq_putc(m, '\\n');",
            "}"
          ],
          "function_name": "frag_show_print, frag_show, pagetypeinfo_showfree_print, pagetypeinfo_showfree, pagetypeinfo_showblockcount_print",
          "description": "实现内存状态序列化展示接口，包括按订单级别显示空闲页统计、迁移类型分组空闲页追踪及物理块分配单元计数功能。",
          "similarity": 0.5463950634002686
        },
        {
          "chunk_id": 12,
          "file_path": "mm/vmstat.c",
          "start_line": 1966,
          "end_line": 2071,
          "content": [
            "static bool need_update(int cpu)",
            "{",
            "\tpg_data_t *last_pgdat = NULL;",
            "\tstruct zone *zone;",
            "",
            "\tfor_each_populated_zone(zone) {",
            "\t\tstruct per_cpu_zonestat *pzstats = per_cpu_ptr(zone->per_cpu_zonestats, cpu);",
            "\t\tstruct per_cpu_nodestat *n;",
            "",
            "\t\t/*",
            "\t\t * The fast way of checking if there are any vmstat diffs.",
            "\t\t */",
            "\t\tif (memchr_inv(pzstats->vm_stat_diff, 0, sizeof(pzstats->vm_stat_diff)))",
            "\t\t\treturn true;",
            "",
            "\t\tif (last_pgdat == zone->zone_pgdat)",
            "\t\t\tcontinue;",
            "\t\tlast_pgdat = zone->zone_pgdat;",
            "\t\tn = per_cpu_ptr(zone->zone_pgdat->per_cpu_nodestats, cpu);",
            "\t\tif (memchr_inv(n->vm_node_stat_diff, 0, sizeof(n->vm_node_stat_diff)))",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "void quiet_vmstat(void)",
            "{",
            "\tif (system_state != SYSTEM_RUNNING)",
            "\t\treturn;",
            "",
            "\tif (!delayed_work_pending(this_cpu_ptr(&vmstat_work)))",
            "\t\treturn;",
            "",
            "\tif (!need_update(smp_processor_id()))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Just refresh counters and do not care about the pending delayed",
            "\t * vmstat_update. It doesn't fire that often to matter and canceling",
            "\t * it would be too expensive from this path.",
            "\t * vmstat_shepherd will take care about that for us.",
            "\t */",
            "\trefresh_cpu_vm_stats(false);",
            "}",
            "static void vmstat_shepherd(struct work_struct *w)",
            "{",
            "\tint cpu;",
            "",
            "\tcpus_read_lock();",
            "\t/* Check processors whose vmstat worker threads have been disabled */",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct delayed_work *dw = &per_cpu(vmstat_work, cpu);",
            "",
            "\t\t/*",
            "\t\t * In kernel users of vmstat counters either require the precise value and",
            "\t\t * they are using zone_page_state_snapshot interface or they can live with",
            "\t\t * an imprecision as the regular flushing can happen at arbitrary time and",
            "\t\t * cumulative error can grow (see calculate_normal_threshold).",
            "\t\t *",
            "\t\t * From that POV the regular flushing can be postponed for CPUs that have",
            "\t\t * been isolated from the kernel interference without critical",
            "\t\t * infrastructure ever noticing. Skip regular flushing from vmstat_shepherd",
            "\t\t * for all isolated CPUs to avoid interference with the isolated workload.",
            "\t\t */",
            "\t\tif (cpu_is_isolated(cpu))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (!delayed_work_pending(dw) && need_update(cpu))",
            "\t\t\tqueue_delayed_work_on(cpu, mm_percpu_wq, dw, 0);",
            "",
            "\t\tcond_resched();",
            "\t}",
            "\tcpus_read_unlock();",
            "",
            "\tschedule_delayed_work(&shepherd,",
            "\t\tround_jiffies_relative(sysctl_stat_interval));",
            "}",
            "static void __init start_shepherd_timer(void)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tINIT_DEFERRABLE_WORK(per_cpu_ptr(&vmstat_work, cpu),",
            "\t\t\tvmstat_update);",
            "",
            "\tschedule_delayed_work(&shepherd,",
            "\t\tround_jiffies_relative(sysctl_stat_interval));",
            "}",
            "static void __init init_cpu_node_state(void)",
            "{",
            "\tint node;",
            "",
            "\tfor_each_online_node(node) {",
            "\t\tif (!cpumask_empty(cpumask_of_node(node)))",
            "\t\t\tnode_set_state(node, N_CPU);",
            "\t}",
            "}",
            "static int vmstat_cpu_online(unsigned int cpu)",
            "{",
            "\trefresh_zone_stat_thresholds();",
            "",
            "\tif (!node_state(cpu_to_node(cpu), N_CPU)) {",
            "\t\tnode_set_state(cpu_to_node(cpu), N_CPU);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "need_update, quiet_vmstat, vmstat_shepherd, start_shepherd_timer, init_cpu_node_state, vmstat_cpu_online",
          "description": "管理vmstat统计更新的延迟工作队列，处理CPU热插拔事件的统计维护，包含CPU在线/离线状态下的统计阈值调整与工作队列调度",
          "similarity": 0.5300931334495544
        }
      ]
    },
    {
      "source_file": "mm/memblock.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memblock.c`\n\n---\n\n# memblock.c 技术文档\n\n## 1. 文件概述\n\n`memblock.c` 实现了 Linux 内核早期启动阶段的内存管理机制——**memblock**。该机制用于在常规内存分配器（如 buddy allocator）尚未初始化之前，对物理内存进行粗粒度的区域管理。它将系统内存抽象为若干连续的内存区域（regions），支持“可用内存”（memory）、“保留内存”（reserved）和“物理内存”（physmem，部分架构支持）三种类型，为内核早期初始化提供内存添加、查询和分配能力。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct memblock_region`：表示一个连续的物理内存区域，包含基地址（base）、大小（size）、NUMA 节点 ID 和属性标志。\n- `struct memblock_type`：管理一类内存区域的集合，包含区域数组、当前数量（cnt）、最大容量（max）和名称。\n- `struct memblock`：全局 memblock 管理结构，包含 `memory` 和 `reserved` 两种类型的 `memblock_type`，以及分配方向（bottom_up）和当前分配上限（current_limit）。\n- `physmem`（条件编译）：描述不受 `mem=` 参数限制的实际物理内存布局。\n\n### 主要函数与变量\n- `memblock_add()` / `memblock_add_node()`：向 memblock 添加可用内存区域。\n- `memblock_reserve()`：标记内存区域为保留（不可用于动态分配）。\n- `memblock_phys_alloc*()` / `memblock_alloc*()`：分配物理或虚拟地址的内存。\n- `memblock_overlaps_region()`：判断指定区域是否与某类 memblock 区域重叠。\n- `__memblock_find_range_bottom_up()`：从低地址向高地址查找满足条件的空闲内存范围。\n- 全局变量 `memblock`：静态初始化的主 memblock 结构体。\n- `max_low_pfn`, `min_low_pfn`, `max_pfn`, `max_possible_pfn`：记录 PFN（页帧号）边界信息。\n\n### 配置宏\n- `INIT_MEMBLOCK_REGIONS`：初始内存/保留区域数组大小（默认 128）。\n- `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 类型支持。\n- `CONFIG_MEMBLOCK_KHO_SCRATCH`：支持仅从特定标记（KHO_SCRATCH）区域分配内存。\n- `CONFIG_ARCH_KEEP_MEMBLOCK`：决定是否在初始化完成后保留 memblock 数据结构。\n\n## 3. 关键实现\n\n### 初始化与存储\n- `memblock` 结构体在编译时静态初始化，其 `memory` 和 `reserved` 的区域数组分别使用 `memblock_memory_init_regions` 和 `memblock_reserved_init_regions`，初始容量由 `INIT_MEMBLOCK_*_REGIONS` 定义。\n- 每个 `memblock_type` 的 `cnt` 初始设为 1，但实际第一个条目为空的占位符，有效区域从索引 1 开始（后续代码处理）。\n- 支持通过 `memblock_allow_resize()` 动态扩容区域数组，但需谨慎避免与 initrd 等关键区域冲突。\n\n### 内存区域管理\n- 使用 `for_each_memblock_type` 宏遍历指定类型的区域。\n- `memblock_addrs_overlap()` 通过比较区间端点判断两个物理内存区域是否重叠。\n- `memblock_overlaps_region()` 封装了对某类所有区域的重叠检测。\n\n### 分配策略\n- 默认采用 **top-down**（从高地址向低地址）分配策略，可通过 `memblock_set_bottom_up(true)` 切换为 **bottom-up**。\n- 分配时受 `current_limit` 限制（默认 `MEMBLOCK_ALLOC_ANYWHERE` 表示无限制）。\n- 支持基于 NUMA 节点、对齐要求、内存属性（如 `MEMBLOCK_MIRROR`、`MEMBLOCK_KHO_SCRATCH`）的精细控制。\n- `choose_memblock_flags()` 根据 `kho_scratch_only` 和镜像内存存在性动态选择分配标志。\n\n### 安全与调试\n- `memblock_cap_size()` 防止地址计算溢出（确保 `base + size <= PHYS_ADDR_MAX`）。\n- 条件编译的 `memblock_dbg()` 宏用于调试输出（需开启 `memblock_debug`）。\n- 使用 `__initdata_memblock` 属性标记仅在初始化阶段使用的数据，便于后续释放。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memblock.h>`：定义 memblock API 和数据结构。\n  - `<linux/kernel.h>`, `<linux/init.h>`：提供基础内核功能和初始化宏。\n  - `<linux/pfn.h>`：PFN 相关操作。\n  - `<asm/sections.h>`：访问内核链接段信息。\n  - 架构相关头文件（如 `internal.h`）。\n- **配置依赖**：\n  - `CONFIG_NUMA`：影响 `contig_page_data` 的定义。\n  - `CONFIG_KEXEC_HANDOVER`：引入 kexec 相关头文件。\n  - `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 支持。\n- **后续移交**：在 `mem_init()` 中，memblock 管理的内存会被释放给 buddy allocator，完成内存管理权移交。\n\n## 5. 使用场景\n\n- **内核早期初始化**：在 `start_kernel()` 初期，架构代码（如 `setup_arch()`）调用 `memblock_add()` 注册可用物理内存，调用 `memblock_reserve()` 保留内核镜像、设备树、initrd 等关键区域。\n- **早期内存分配**：在 slab/buddy 分配器就绪前，使用 `memblock_alloc()` 分配大块连续内存（如页表、中断向量表、ACPI 表解析缓冲区）。\n- **内存布局查询**：通过 `for_each_memblock()` 等宏遍历内存区域，用于构建 e820 表、EFI 内存映射或 NUMA 拓扑。\n- **特殊分配需求**：支持从镜像内存（`MEMBLOCK_MIRROR`）或 KHO scratch 区域分配，满足安全启动或崩溃转储等场景。\n- **调试与分析**：通过 debugfs 接口（未在片段中体现）导出 memblock 布局，辅助内存问题诊断。",
      "similarity": 0.6396008729934692,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "mm/memblock.c",
          "start_line": 1607,
          "end_line": 1734,
          "content": [
            "phys_addr_t __init memblock_phys_alloc_range(phys_addr_t size,",
            "\t\t\t\t\t     phys_addr_t align,",
            "\t\t\t\t\t     phys_addr_t start,",
            "\t\t\t\t\t     phys_addr_t end)",
            "{",
            "\tmemblock_dbg(\"%s: %llu bytes align=0x%llx from=%pa max_addr=%pa %pS\\n\",",
            "\t\t     __func__, (u64)size, (u64)align, &start, &end,",
            "\t\t     (void *)_RET_IP_);",
            "\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,",
            "\t\t\t\t\tfalse);",
            "}",
            "phys_addr_t __init memblock_phys_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)",
            "{",
            "\treturn memblock_alloc_range_nid(size, align, 0,",
            "\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid, false);",
            "}",
            "void __init memblock_free_late(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t cursor, end;",
            "",
            "\tend = base + size - 1;",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\",",
            "\t\t     __func__, &base, &end, (void *)_RET_IP_);",
            "\tkmemleak_free_part_phys(base, size);",
            "\tcursor = PFN_UP(base);",
            "\tend = PFN_DOWN(base + size);",
            "",
            "\tfor (; cursor < end; cursor++) {",
            "\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);",
            "\t\ttotalram_pages_inc();",
            "\t}",
            "}",
            "phys_addr_t __init_memblock memblock_reserved_kern_size(phys_addr_t limit, int nid)",
            "{",
            "\tstruct memblock_region *r;",
            "\tphys_addr_t total = 0;",
            "",
            "\tfor_each_reserved_mem_region(r) {",
            "\t\tphys_addr_t size = r->size;",
            "",
            "\t\tif (r->base > limit)",
            "\t\t\tbreak;",
            "",
            "\t\tif (r->base + r->size > limit)",
            "\t\t\tsize = limit - r->base;",
            "",
            "\t\tif (nid == memblock_get_region_node(r) || !numa_valid_node(nid))",
            "\t\t\tif (r->flags & MEMBLOCK_RSRV_KERN)",
            "\t\t\t\ttotal += size;",
            "\t}",
            "",
            "\treturn total;",
            "}",
            "unsigned long __init memblock_estimated_nr_free_pages(void)",
            "{",
            "\treturn PHYS_PFN(memblock_phys_mem_size() - memblock_reserved_size());",
            "}",
            "static phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr = PHYS_ADDR_MAX;",
            "\tstruct memblock_region *r;",
            "",
            "\t/*",
            "\t * translate the memory @limit size into the max address within one of",
            "\t * the memory memblock regions, if the @limit exceeds the total size",
            "\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX",
            "\t */",
            "\tfor_each_mem_region(r) {",
            "\t\tif (limit <= r->size) {",
            "\t\t\tmax_addr = r->base + limit;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tlimit -= r->size;",
            "\t}",
            "",
            "\treturn max_addr;",
            "}",
            "void __init memblock_enforce_memory_limit(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\t/* truncate both memory and reserved regions */",
            "\tmemblock_remove_range(&memblock.memory, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "\tmemblock_remove_range(&memblock.reserved, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "}",
            "void __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint start_rgn, end_rgn;",
            "\tint i, ret;",
            "",
            "\tif (!size)",
            "\t\treturn;",
            "",
            "\tif (!memblock_memory->total_size) {",
            "\t\tpr_warn(\"%s: No memory registered yet\\n\", __func__);",
            "\t\treturn;",
            "\t}",
            "",
            "\tret = memblock_isolate_range(&memblock.memory, base, size,",
            "\t\t\t\t\t\t&start_rgn, &end_rgn);",
            "\tif (ret)",
            "\t\treturn;",
            "",
            "\t/* remove all the MAP regions */",
            "\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\tfor (i = start_rgn - 1; i >= 0; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\t/* truncate the reserved regions */",
            "\tmemblock_remove_range(&memblock.reserved, 0, base);",
            "\tmemblock_remove_range(&memblock.reserved,",
            "\t\t\tbase + size, PHYS_ADDR_MAX);",
            "}"
          ],
          "function_name": "memblock_phys_alloc_range, memblock_phys_alloc_try_nid, memblock_free_late, memblock_reserved_kern_size, memblock_estimated_nr_free_pages, __find_max_addr, memblock_enforce_memory_limit, memblock_cap_memory_range",
          "description": "实现物理内存分配/释放控制，包含内存上限强制限制、空闲页面估算、内存区域截断等管理功能，支持对保留内存的容量统计",
          "similarity": 0.63405841588974
        },
        {
          "chunk_id": 10,
          "file_path": "mm/memblock.c",
          "start_line": 1954,
          "end_line": 2057,
          "content": [
            "void __init memblock_mem_limit_remove_map(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\tmemblock_cap_memory_range(0, max_addr);",
            "}",
            "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)",
            "{",
            "\tunsigned int left = 0, right = type->cnt;",
            "",
            "\tdo {",
            "\t\tunsigned int mid = (right + left) / 2;",
            "",
            "\t\tif (addr < type->regions[mid].base)",
            "\t\t\tright = mid;",
            "\t\telse if (addr >= (type->regions[mid].base +",
            "\t\t\t\t  type->regions[mid].size))",
            "\t\t\tleft = mid + 1;",
            "\t\telse",
            "\t\t\treturn mid;",
            "\t} while (left < right);",
            "\treturn -1;",
            "}",
            "bool __init_memblock memblock_is_reserved(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.reserved, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_memory(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.memory, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_map_memory(phys_addr_t addr)",
            "{",
            "\tint i = memblock_search(&memblock.memory, addr);",
            "",
            "\tif (i == -1)",
            "\t\treturn false;",
            "\treturn !memblock_is_nomap(&memblock.memory.regions[i]);",
            "}",
            "int __init_memblock memblock_search_pfn_nid(unsigned long pfn,",
            "\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)",
            "{",
            "\tstruct memblock_type *type = &memblock.memory;",
            "\tint mid = memblock_search(type, PFN_PHYS(pfn));",
            "",
            "\tif (mid == -1)",
            "\t\treturn -1;",
            "",
            "\t*start_pfn = PFN_DOWN(type->regions[mid].base);",
            "\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);",
            "",
            "\treturn memblock_get_region_node(&type->regions[mid]);",
            "}",
            "bool __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint idx = memblock_search(&memblock.memory, base);",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "",
            "\tif (idx == -1)",
            "\t\treturn false;",
            "\treturn (memblock.memory.regions[idx].base +",
            "\t\t memblock.memory.regions[idx].size) >= end;",
            "}",
            "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_overlaps_region(&memblock.reserved, base, size);",
            "}",
            "void __init_memblock memblock_trim_memory(phys_addr_t align)",
            "{",
            "\tphys_addr_t start, end, orig_start, orig_end;",
            "\tstruct memblock_region *r;",
            "",
            "\tfor_each_mem_region(r) {",
            "\t\torig_start = r->base;",
            "\t\torig_end = r->base + r->size;",
            "\t\tstart = round_up(orig_start, align);",
            "\t\tend = round_down(orig_end, align);",
            "",
            "\t\tif (start == orig_start && end == orig_end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start < end) {",
            "\t\t\tr->base = start;",
            "\t\t\tr->size = end - start;",
            "\t\t} else {",
            "\t\t\tmemblock_remove_region(&memblock.memory,",
            "\t\t\t\t\t       r - memblock.memory.regions);",
            "\t\t\tr--;",
            "\t\t}",
            "\t}",
            "}",
            "void __init_memblock memblock_set_current_limit(phys_addr_t limit)",
            "{",
            "\tmemblock.current_limit = limit;",
            "}"
          ],
          "function_name": "memblock_mem_limit_remove_map, memblock_search, memblock_is_reserved, memblock_is_memory, memblock_is_map_memory, memblock_search_pfn_nid, memblock_is_region_memory, memblock_is_region_reserved, memblock_trim_memory, memblock_set_current_limit",
          "description": "实现内存块限制移除、搜索和区域判断逻辑，用于管理内存和保留区域的地址范围查询及修剪操作",
          "similarity": 0.6204267740249634
        },
        {
          "chunk_id": 11,
          "file_path": "mm/memblock.c",
          "start_line": 2094,
          "end_line": 2203,
          "content": [
            "static void __init_memblock memblock_dump(struct memblock_type *type)",
            "{",
            "\tphys_addr_t base, end, size;",
            "\tenum memblock_flags flags;",
            "\tint idx;",
            "\tstruct memblock_region *rgn;",
            "",
            "\tpr_info(\" %s.cnt  = 0x%lx\\n\", type->name, type->cnt);",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tchar nid_buf[32] = \"\";",
            "",
            "\t\tbase = rgn->base;",
            "\t\tsize = rgn->size;",
            "\t\tend = base + size - 1;",
            "\t\tflags = rgn->flags;",
            "#ifdef CONFIG_NUMA",
            "\t\tif (numa_valid_node(memblock_get_region_node(rgn)))",
            "\t\t\tsnprintf(nid_buf, sizeof(nid_buf), \" on node %d\",",
            "\t\t\t\t memblock_get_region_node(rgn));",
            "#endif",
            "\t\tpr_info(\" %s[%#x]\\t[%pa-%pa], %pa bytes%s flags: %#x\\n\",",
            "\t\t\ttype->name, idx, &base, &end, &size, nid_buf, flags);",
            "\t}",
            "}",
            "void __init memblock_allow_resize(void)",
            "{",
            "\tmemblock_can_resize = 1;",
            "}",
            "static int __init early_memblock(char *p)",
            "{",
            "\tif (p && strstr(p, \"debug\"))",
            "\t\tmemblock_debug = 1;",
            "\treturn 0;",
            "}",
            "static void __init free_memmap(unsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tstruct page *start_pg, *end_pg;",
            "\tphys_addr_t pg, pgend;",
            "",
            "\t/*",
            "\t * Convert start_pfn/end_pfn to a struct page pointer.",
            "\t */",
            "\tstart_pg = pfn_to_page(start_pfn - 1) + 1;",
            "\tend_pg = pfn_to_page(end_pfn - 1) + 1;",
            "",
            "\t/*",
            "\t * Convert to physical addresses, and round start upwards and end",
            "\t * downwards.",
            "\t */",
            "\tpg = PAGE_ALIGN(__pa(start_pg));",
            "\tpgend = __pa(end_pg) & PAGE_MASK;",
            "",
            "\t/*",
            "\t * If there are free pages between these, free the section of the",
            "\t * memmap array.",
            "\t */",
            "\tif (pg < pgend)",
            "\t\tmemblock_phys_free(pg, pgend - pg);",
            "}",
            "static void __init free_unused_memmap(void)",
            "{",
            "\tunsigned long start, end, prev_end = 0;",
            "\tint i;",
            "",
            "\tif (!IS_ENABLED(CONFIG_HAVE_ARCH_PFN_VALID) ||",
            "\t    IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This relies on each bank being in address order.",
            "\t * The banks are sorted previously in bootmem_init().",
            "\t */",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, NULL) {",
            "#ifdef CONFIG_SPARSEMEM",
            "\t\t/*",
            "\t\t * Take care not to free memmap entries that don't exist",
            "\t\t * due to SPARSEMEM sections which aren't present.",
            "\t\t */",
            "\t\tstart = min(start, ALIGN(prev_end, PAGES_PER_SECTION));",
            "#endif",
            "\t\t/*",
            "\t\t * Align down here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tstart = pageblock_start_pfn(start);",
            "",
            "\t\t/*",
            "\t\t * If we had a previous bank, and there is a space",
            "\t\t * between the current bank and the previous, free it.",
            "\t\t */",
            "\t\tif (prev_end && prev_end < start)",
            "\t\t\tfree_memmap(prev_end, start);",
            "",
            "\t\t/*",
            "\t\t * Align up here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tprev_end = pageblock_align(end);",
            "\t}",
            "",
            "#ifdef CONFIG_SPARSEMEM",
            "\tif (!IS_ALIGNED(prev_end, PAGES_PER_SECTION)) {",
            "\t\tprev_end = pageblock_align(end);",
            "\t\tfree_memmap(prev_end, ALIGN(prev_end, PAGES_PER_SECTION));",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "memblock_dump, memblock_allow_resize, early_memblock, free_memmap, free_unused_memmap",
          "description": "提供内存块状态调试、调整支持、早期内存处理及未使用memmap释放功能，用于优化内存映射管理",
          "similarity": 0.6003344058990479
        },
        {
          "chunk_id": 2,
          "file_path": "mm/memblock.c",
          "start_line": 366,
          "end_line": 506,
          "content": [
            "static void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)",
            "{",
            "\ttype->total_size -= type->regions[r].size;",
            "\tmemmove(&type->regions[r], &type->regions[r + 1],",
            "\t\t(type->cnt - (r + 1)) * sizeof(type->regions[r]));",
            "\ttype->cnt--;",
            "",
            "\t/* Special case for empty arrays */",
            "\tif (type->cnt == 0) {",
            "\t\tWARN_ON(type->total_size != 0);",
            "\t\ttype->cnt = 1;",
            "\t\ttype->regions[0].base = 0;",
            "\t\ttype->regions[0].size = 0;",
            "\t\ttype->regions[0].flags = 0;",
            "\t\tmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);",
            "\t}",
            "}",
            "void __init memblock_discard(void)",
            "{",
            "\tphys_addr_t addr, size;",
            "",
            "\tif (memblock.reserved.regions != memblock_reserved_init_regions) {",
            "\t\taddr = __pa(memblock.reserved.regions);",
            "\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *",
            "\t\t\t\t  memblock.reserved.max);",
            "\t\tif (memblock_reserved_in_slab)",
            "\t\t\tkfree(memblock.reserved.regions);",
            "\t\telse",
            "\t\t\tmemblock_free_late(addr, size);",
            "\t}",
            "",
            "\tif (memblock.memory.regions != memblock_memory_init_regions) {",
            "\t\taddr = __pa(memblock.memory.regions);",
            "\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *",
            "\t\t\t\t  memblock.memory.max);",
            "\t\tif (memblock_memory_in_slab)",
            "\t\t\tkfree(memblock.memory.regions);",
            "\t\telse",
            "\t\t\tmemblock_free_late(addr, size);",
            "\t}",
            "",
            "\tmemblock_memory = NULL;",
            "}",
            "static int __init_memblock memblock_double_array(struct memblock_type *type,",
            "\t\t\t\t\t\tphys_addr_t new_area_start,",
            "\t\t\t\t\t\tphys_addr_t new_area_size)",
            "{",
            "\tstruct memblock_region *new_array, *old_array;",
            "\tphys_addr_t old_alloc_size, new_alloc_size;",
            "\tphys_addr_t old_size, new_size, addr, new_end;",
            "\tint use_slab = slab_is_available();",
            "\tint *in_slab;",
            "",
            "\t/* We don't allow resizing until we know about the reserved regions",
            "\t * of memory that aren't suitable for allocation",
            "\t */",
            "\tif (!memblock_can_resize)",
            "\t\treturn -1;",
            "",
            "\t/* Calculate new doubled size */",
            "\told_size = type->max * sizeof(struct memblock_region);",
            "\tnew_size = old_size << 1;",
            "\t/*",
            "\t * We need to allocated new one align to PAGE_SIZE,",
            "\t *   so we can free them completely later.",
            "\t */",
            "\told_alloc_size = PAGE_ALIGN(old_size);",
            "\tnew_alloc_size = PAGE_ALIGN(new_size);",
            "",
            "\t/* Retrieve the slab flag */",
            "\tif (type == &memblock.memory)",
            "\t\tin_slab = &memblock_memory_in_slab;",
            "\telse",
            "\t\tin_slab = &memblock_reserved_in_slab;",
            "",
            "\t/* Try to find some space for it */",
            "\tif (use_slab) {",
            "\t\tnew_array = kmalloc(new_size, GFP_KERNEL);",
            "\t\taddr = new_array ? __pa(new_array) : 0;",
            "\t} else {",
            "\t\t/* only exclude range when trying to double reserved.regions */",
            "\t\tif (type != &memblock.reserved)",
            "\t\t\tnew_area_start = new_area_size = 0;",
            "",
            "\t\taddr = memblock_find_in_range(new_area_start + new_area_size,",
            "\t\t\t\t\t\tmemblock.current_limit,",
            "\t\t\t\t\t\tnew_alloc_size, PAGE_SIZE);",
            "\t\tif (!addr && new_area_size)",
            "\t\t\taddr = memblock_find_in_range(0,",
            "\t\t\t\tmin(new_area_start, memblock.current_limit),",
            "\t\t\t\tnew_alloc_size, PAGE_SIZE);",
            "",
            "\t\tif (addr) {",
            "\t\t\t/* The memory may not have been accepted, yet. */",
            "\t\t\taccept_memory(addr, new_alloc_size);",
            "",
            "\t\t\tnew_array = __va(addr);",
            "\t\t} else {",
            "\t\t\tnew_array = NULL;",
            "\t\t}",
            "\t}",
            "\tif (!addr) {",
            "\t\tpr_err(\"memblock: Failed to double %s array from %ld to %ld entries !\\n\",",
            "\t\t       type->name, type->max, type->max * 2);",
            "\t\treturn -1;",
            "\t}",
            "",
            "\tnew_end = addr + new_size - 1;",
            "\tmemblock_dbg(\"memblock: %s is doubled to %ld at [%pa-%pa]\",",
            "\t\t\ttype->name, type->max * 2, &addr, &new_end);",
            "",
            "\t/*",
            "\t * Found space, we now need to move the array over before we add the",
            "\t * reserved region since it may be our reserved array itself that is",
            "\t * full.",
            "\t */",
            "\tmemcpy(new_array, type->regions, old_size);",
            "\tmemset(new_array + type->max, 0, old_size);",
            "\told_array = type->regions;",
            "\ttype->regions = new_array;",
            "\ttype->max <<= 1;",
            "",
            "\t/* Free old array. We needn't free it if the array is the static one */",
            "\tif (*in_slab)",
            "\t\tkfree(old_array);",
            "\telse if (old_array != memblock_memory_init_regions &&",
            "\t\t old_array != memblock_reserved_init_regions)",
            "\t\tmemblock_free(old_array, old_alloc_size);",
            "",
            "\t/*",
            "\t * Reserve the new array if that comes from the memblock.  Otherwise, we",
            "\t * needn't do it",
            "\t */",
            "\tif (!use_slab)",
            "\t\tBUG_ON(memblock_reserve_kern(addr, new_alloc_size));",
            "",
            "\t/* Update slab flag */",
            "\t*in_slab = use_slab;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "memblock_remove_region, memblock_discard, memblock_double_array",
          "description": "实现内存区域数组的动态扩容（double_array）、旧区域释放（discard）及区域移除操作，维护内存类型总大小统计。",
          "similarity": 0.5773324370384216
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memblock.c",
          "start_line": 537,
          "end_line": 685,
          "content": [
            "static void __init_memblock memblock_merge_regions(struct memblock_type *type,",
            "\t\t\t\t\t\t   unsigned long start_rgn,",
            "\t\t\t\t\t\t   unsigned long end_rgn)",
            "{",
            "\tint i = 0;",
            "\tif (start_rgn)",
            "\t\ti = start_rgn - 1;",
            "\tend_rgn = min(end_rgn, type->cnt - 1);",
            "\twhile (i < end_rgn) {",
            "\t\tstruct memblock_region *this = &type->regions[i];",
            "\t\tstruct memblock_region *next = &type->regions[i + 1];",
            "",
            "\t\tif (this->base + this->size != next->base ||",
            "\t\t    memblock_get_region_node(this) !=",
            "\t\t    memblock_get_region_node(next) ||",
            "\t\t    this->flags != next->flags) {",
            "\t\t\tBUG_ON(this->base + this->size > next->base);",
            "\t\t\ti++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tthis->size += next->size;",
            "\t\t/* move forward from next + 1, index of which is i + 2 */",
            "\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));",
            "\t\ttype->cnt--;",
            "\t\tend_rgn--;",
            "\t}",
            "}",
            "static void __init_memblock memblock_insert_region(struct memblock_type *type,",
            "\t\t\t\t\t\t   int idx, phys_addr_t base,",
            "\t\t\t\t\t\t   phys_addr_t size,",
            "\t\t\t\t\t\t   int nid,",
            "\t\t\t\t\t\t   enum memblock_flags flags)",
            "{",
            "\tstruct memblock_region *rgn = &type->regions[idx];",
            "",
            "\tBUG_ON(type->cnt >= type->max);",
            "\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));",
            "\trgn->base = base;",
            "\trgn->size = size;",
            "\trgn->flags = flags;",
            "\tmemblock_set_region_node(rgn, nid);",
            "\ttype->cnt++;",
            "\ttype->total_size += size;",
            "}",
            "static int __init_memblock memblock_add_range(struct memblock_type *type,",
            "\t\t\t\tphys_addr_t base, phys_addr_t size,",
            "\t\t\t\tint nid, enum memblock_flags flags)",
            "{",
            "\tbool insert = false;",
            "\tphys_addr_t obase = base;",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "\tint idx, nr_new, start_rgn = -1, end_rgn;",
            "\tstruct memblock_region *rgn;",
            "",
            "\tif (!size)",
            "\t\treturn 0;",
            "",
            "\t/* special case for empty array */",
            "\tif (type->regions[0].size == 0) {",
            "\t\tWARN_ON(type->cnt != 1 || type->total_size);",
            "\t\ttype->regions[0].base = base;",
            "\t\ttype->regions[0].size = size;",
            "\t\ttype->regions[0].flags = flags;",
            "\t\tmemblock_set_region_node(&type->regions[0], nid);",
            "\t\ttype->total_size = size;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * The worst case is when new range overlaps all existing regions,",
            "\t * then we'll need type->cnt + 1 empty regions in @type. So if",
            "\t * type->cnt * 2 + 1 is less than or equal to type->max, we know",
            "\t * that there is enough empty regions in @type, and we can insert",
            "\t * regions directly.",
            "\t */",
            "\tif (type->cnt * 2 + 1 <= type->max)",
            "\t\tinsert = true;",
            "",
            "repeat:",
            "\t/*",
            "\t * The following is executed twice.  Once with %false @insert and",
            "\t * then with %true.  The first counts the number of regions needed",
            "\t * to accommodate the new area.  The second actually inserts them.",
            "\t */",
            "\tbase = obase;",
            "\tnr_new = 0;",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tphys_addr_t rbase = rgn->base;",
            "\t\tphys_addr_t rend = rbase + rgn->size;",
            "",
            "\t\tif (rbase >= end)",
            "\t\t\tbreak;",
            "\t\tif (rend <= base)",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * @rgn overlaps.  If it separates the lower part of new",
            "\t\t * area, insert that portion.",
            "\t\t */",
            "\t\tif (rbase > base) {",
            "#ifdef CONFIG_NUMA",
            "\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));",
            "#endif",
            "\t\t\tWARN_ON(flags != MEMBLOCK_NONE && flags != rgn->flags);",
            "\t\t\tnr_new++;",
            "\t\t\tif (insert) {",
            "\t\t\t\tif (start_rgn == -1)",
            "\t\t\t\t\tstart_rgn = idx;",
            "\t\t\t\tend_rgn = idx + 1;",
            "\t\t\t\tmemblock_insert_region(type, idx++, base,",
            "\t\t\t\t\t\t       rbase - base, nid,",
            "\t\t\t\t\t\t       flags);",
            "\t\t\t}",
            "\t\t}",
            "\t\t/* area below @rend is dealt with, forget about it */",
            "\t\tbase = min(rend, end);",
            "\t}",
            "",
            "\t/* insert the remaining portion */",
            "\tif (base < end) {",
            "\t\tnr_new++;",
            "\t\tif (insert) {",
            "\t\t\tif (start_rgn == -1)",
            "\t\t\t\tstart_rgn = idx;",
            "\t\t\tend_rgn = idx + 1;",
            "\t\t\tmemblock_insert_region(type, idx, base, end - base,",
            "\t\t\t\t\t       nid, flags);",
            "\t\t}",
            "\t}",
            "",
            "\tif (!nr_new)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * If this was the first round, resize array and repeat for actual",
            "\t * insertions; otherwise, merge and return.",
            "\t */",
            "\tif (!insert) {",
            "\t\twhile (type->cnt + nr_new > type->max)",
            "\t\t\tif (memblock_double_array(type, obase, size) < 0)",
            "\t\t\t\treturn -ENOMEM;",
            "\t\tinsert = true;",
            "\t\tgoto repeat;",
            "\t} else {",
            "\t\tmemblock_merge_regions(type, start_rgn, end_rgn);",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "function_name": "memblock_merge_regions, memblock_insert_region, memblock_add_range",
          "description": "实现内存区域合并（merge_regions）与插入（insert_region）逻辑，处理新增内存范围的拆分与整合，优化连续区域管理。",
          "similarity": 0.5723426938056946
        }
      ]
    },
    {
      "source_file": "mm/highmem.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:03:56\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `highmem.c`\n\n---\n\n# highmem.c 技术文档\n\n## 1. 文件概述\n\n`highmem.c` 是 Linux 内核中用于管理高内存（High Memory）的核心实现文件。在 32 位系统中，由于虚拟地址空间有限（通常为 4GB），内核无法将全部物理内存直接映射到内核虚拟地址空间。高内存指那些不能被永久映射到内核地址空间的物理内存页。该文件提供了对高内存页进行临时映射（kmap）和本地映射（kmap_local）的通用机制，使得内核代码能够安全地访问高内存中的数据。\n\n## 2. 核心功能\n\n### 主要函数\n- `kmap_high(struct page *page)`：将高内存页映射到内核虚拟地址空间，返回其虚拟地址。\n- `__kmap_flush_unused(void)`：释放所有未使用的持久性 kmap 映射。\n- `__kmap_to_page(void *vaddr)`：根据虚拟地址反向查找对应的 `struct page`。\n- `map_new_virtual(struct page *page)`：为指定页面分配一个新的持久性 kmap 虚拟地址。\n- `flush_all_zero_pkmaps(void)`：清除所有引用计数为 1（即空闲但尚未解除映射）的 PKMAP 条目。\n\n### 主要数据结构与变量\n- `pkmap_count[LAST_PKMAP]`：记录每个持久性 kmap 槽的引用状态。\n- `pkmap_page_table`：指向持久性 kmap 区域的页表项数组。\n- `_totalhigh_pages`：系统中高内存页的总数（全局可导出变量）。\n- `kmap_lock`：保护持久性 kmap 操作的自旋锁。\n- `__nr_free_highpages(void)`：计算当前系统中空闲的高内存页数量。\n\n## 3. 关键实现\n\n### 持久性 kmap 机制（PKMAP）\n- 使用固定大小的虚拟地址窗口（`PKMAP_ADDR(0)` 到 `PKMAP_ADDR(LAST_PKMAP)`）作为高内存页的映射区域。\n- `pkmap_count[]` 数组不仅记录引用计数，还编码映射状态：\n  - **0**：槽位空闲且 TLB 已刷新，可安全复用。\n  - **1**：槽位空闲但自上次 TLB 刷新后曾被使用，需先刷新 TLB 才能复用。\n  - **n (>1)**：当前有 (n-1) 个活跃用户。\n- 当无可用槽位时，调用者会进入不可中断睡眠，等待其他线程调用 `kunmap` 释放槽位。\n\n### 缓存着色支持（Cache Coloring）\n- 在具有别名数据缓存（Aliasing Data Cache）的架构上，通过 `get_pkmap_color()` 等钩子函数控制映射的“颜色”（即缓存索引），避免缓存冲突。\n- 默认实现（无缓存别名架构）返回颜色 0，所有映射共享同一等待队列。\n\n### 本地 kmap 支持（kmap_local）\n- 通过 `CONFIG_KMAP_LOCAL` 配置选项启用。\n- 每个 CPU 拥有独立的固定映射区域（FIX_KMAP），避免全局锁竞争。\n- 使用 `arch_kmap_local_map_idx()` 计算 per-CPU 的映射索引。\n\n### 锁与中断处理\n- 根据 `ARCH_NEEDS_KMAP_HIGH_GET` 宏决定是否在获取 kmap 锁时禁用中断，以优化性能。\n\n### 地址反查\n- `__kmap_to_page()` 支持从持久性 kmap 和本地 kmap 的虚拟地址反向解析出原始 `struct page`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`、`<linux/highmem.h>`：内存管理和高内存接口定义。\n  - `<asm/tlbflush.h>`：TLB 刷新操作。\n  - `<linux/vmalloc.h>`：虚拟内存分配相关。\n  - 架构特定头文件（如 `asm/highmem.h`）：提供架构相关的 kmap 实现。\n  \n- **内核子系统依赖**：\n  - 内存管理子系统（MM）：页分配、zone 管理。\n  - 虚拟内存管理：页表操作、TLB 控制。\n  - SMP 支持：per-CPU 数据、自旋锁。\n\n- **导出符号**：\n  - `_totalhigh_pages`：供其他模块查询高内存总量。\n  - `__kmap_to_page`：供调试或特殊用途反查页结构。\n\n## 5. 使用场景\n\n- **块设备 I/O**：当 bio 请求涉及高内存页时，驱动程序使用 `kmap()` 获取线性地址进行 DMA 或拷贝。\n- **文件系统缓存**：页缓存可能位于高内存，读写时需临时映射。\n- **网络子系统**：SKB 数据页若在高内存，协议栈需映射后处理。\n- **内核调试**：KGDB 等调试器可能需要访问高内存内容。\n- **内存压缩/迁移**：在内存管理高级功能中临时访问高内存页。\n\n> 注意：`kmap_high()` 可能阻塞，因此**不能在中断上下文或持有自旋锁时调用**。对于不能睡眠的场景，应使用 `kmap_atomic()`（已废弃）或 `kmap_local_page()`。",
      "similarity": 0.6395028233528137,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "mm/highmem.c",
          "start_line": 472,
          "end_line": 591,
          "content": [
            "static inline int kmap_local_idx(void)",
            "{",
            "\treturn current->kmap_ctrl.idx - 1;",
            "}",
            "static inline void kmap_local_idx_pop(void)",
            "{",
            "\tcurrent->kmap_ctrl.idx -= KM_INCR;",
            "\tBUG_ON(current->kmap_ctrl.idx < 0);",
            "}",
            "static inline bool kmap_high_unmap_local(unsigned long vaddr)",
            "{",
            "#ifdef ARCH_NEEDS_KMAP_HIGH_GET",
            "\tif (vaddr >= PKMAP_ADDR(0) && vaddr < PKMAP_ADDR(LAST_PKMAP)) {",
            "\t\tkunmap_high(pte_page(ptep_get(&pkmap_page_table[PKMAP_NR(vaddr)])));",
            "\t\treturn true;",
            "\t}",
            "#endif",
            "\treturn false;",
            "}",
            "void kunmap_local_indexed(const void *vaddr)",
            "{",
            "\tunsigned long addr = (unsigned long) vaddr & PAGE_MASK;",
            "\tpte_t *kmap_pte;",
            "\tint idx;",
            "",
            "\tif (addr < __fix_to_virt(FIX_KMAP_END) ||",
            "\t    addr > __fix_to_virt(FIX_KMAP_BEGIN)) {",
            "\t\tif (IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP)) {",
            "\t\t\t/* This _should_ never happen! See above. */",
            "\t\t\tWARN_ON_ONCE(1);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Handle mappings which were obtained by kmap_high_get()",
            "\t\t * first as the virtual address of such mappings is below",
            "\t\t * PAGE_OFFSET. Warn for all other addresses which are in",
            "\t\t * the user space part of the virtual address space.",
            "\t\t */",
            "\t\tif (!kmap_high_unmap_local(addr))",
            "\t\t\tWARN_ON_ONCE(addr < PAGE_OFFSET);",
            "\t\treturn;",
            "\t}",
            "",
            "\tpreempt_disable();",
            "\tidx = arch_kmap_local_unmap_idx(kmap_local_idx(), addr);",
            "\tWARN_ON_ONCE(addr != __fix_to_virt(FIX_KMAP_BEGIN + idx));",
            "",
            "\tkmap_pte = kmap_get_pte(addr, idx);",
            "\tarch_kmap_local_pre_unmap(addr);",
            "\tpte_clear(&init_mm, addr, kmap_pte);",
            "\tarch_kmap_local_post_unmap(addr);",
            "\tcurrent->kmap_ctrl.pteval[kmap_local_idx()] = __pte(0);",
            "\tkmap_local_idx_pop();",
            "\tpreempt_enable();",
            "\tmigrate_enable();",
            "}",
            "void __kmap_local_sched_out(void)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tpte_t *kmap_pte;",
            "\tint i;",
            "",
            "\t/* Clear kmaps */",
            "\tfor (i = 0; i < tsk->kmap_ctrl.idx; i++) {",
            "\t\tpte_t pteval = tsk->kmap_ctrl.pteval[i];",
            "\t\tunsigned long addr;",
            "\t\tint idx;",
            "",
            "\t\t/* With debug all even slots are unmapped and act as guard */",
            "\t\tif (IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL) && !(i & 0x01)) {",
            "\t\t\tWARN_ON_ONCE(pte_val(pteval) != 0);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (WARN_ON_ONCE(pte_none(pteval)))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * This is a horrible hack for XTENSA to calculate the",
            "\t\t * coloured PTE index. Uses the PFN encoded into the pteval",
            "\t\t * and the map index calculation because the actual mapped",
            "\t\t * virtual address is not stored in task::kmap_ctrl.",
            "\t\t * For any sane architecture this is optimized out.",
            "\t\t */",
            "\t\tidx = arch_kmap_local_map_idx(i, pte_pfn(pteval));",
            "",
            "\t\taddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);",
            "\t\tkmap_pte = kmap_get_pte(addr, idx);",
            "\t\tarch_kmap_local_pre_unmap(addr);",
            "\t\tpte_clear(&init_mm, addr, kmap_pte);",
            "\t\tarch_kmap_local_post_unmap(addr);",
            "\t}",
            "}",
            "void __kmap_local_sched_in(void)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tpte_t *kmap_pte;",
            "\tint i;",
            "",
            "\t/* Restore kmaps */",
            "\tfor (i = 0; i < tsk->kmap_ctrl.idx; i++) {",
            "\t\tpte_t pteval = tsk->kmap_ctrl.pteval[i];",
            "\t\tunsigned long addr;",
            "\t\tint idx;",
            "",
            "\t\t/* With debug all even slots are unmapped and act as guard */",
            "\t\tif (IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL) && !(i & 0x01)) {",
            "\t\t\tWARN_ON_ONCE(pte_val(pteval) != 0);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (WARN_ON_ONCE(pte_none(pteval)))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* See comment in __kmap_local_sched_out() */",
            "\t\tidx = arch_kmap_local_map_idx(i, pte_pfn(pteval));",
            "\t\taddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);",
            "\t\tkmap_pte = kmap_get_pte(addr, idx);",
            "\t\tset_pte_at(&init_mm, addr, kmap_pte, pteval);",
            "\t\tarch_kmap_local_post_map(addr, pteval);",
            "\t}",
            "}"
          ],
          "function_name": "kmap_local_idx, kmap_local_idx_pop, kmap_high_unmap_local, kunmap_local_indexed, __kmap_local_sched_out, __kmap_local_sched_in",
          "description": "实现任务调度上下文中的高内存映射管理，包含保存/恢复页表项、处理虚实地址转换及架构特定的预后处理操作。",
          "similarity": 0.6076709032058716
        },
        {
          "chunk_id": 4,
          "file_path": "mm/highmem.c",
          "start_line": 700,
          "end_line": 743,
          "content": [
            "void kmap_local_fork(struct task_struct *tsk)",
            "{",
            "\tif (WARN_ON_ONCE(tsk->kmap_ctrl.idx))",
            "\t\tmemset(&tsk->kmap_ctrl, 0, sizeof(tsk->kmap_ctrl));",
            "}",
            "void set_page_address(struct page *page, void *virtual)",
            "{",
            "\tunsigned long flags;",
            "\tstruct page_address_slot *pas;",
            "\tstruct page_address_map *pam;",
            "",
            "\tBUG_ON(!PageHighMem(page));",
            "",
            "\tpas = page_slot(page);",
            "\tif (virtual) {\t\t/* Add */",
            "\t\tpam = &page_address_maps[PKMAP_NR((unsigned long)virtual)];",
            "\t\tpam->page = page;",
            "\t\tpam->virtual = virtual;",
            "",
            "\t\tspin_lock_irqsave(&pas->lock, flags);",
            "\t\tlist_add_tail(&pam->list, &pas->lh);",
            "\t\tspin_unlock_irqrestore(&pas->lock, flags);",
            "\t} else {\t\t/* Remove */",
            "\t\tspin_lock_irqsave(&pas->lock, flags);",
            "\t\tlist_for_each_entry(pam, &pas->lh, list) {",
            "\t\t\tif (pam->page == page) {",
            "\t\t\t\tlist_del(&pam->list);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock_irqrestore(&pas->lock, flags);",
            "\t}",
            "",
            "\treturn;",
            "}",
            "void __init page_address_init(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(page_address_htable); i++) {",
            "\t\tINIT_LIST_HEAD(&page_address_htable[i].lh);",
            "\t\tspin_lock_init(&page_address_htable[i].lock);",
            "\t}",
            "}"
          ],
          "function_name": "kmap_local_fork, set_page_address, page_address_init",
          "description": "初始化高内存页地址关联数据结构，提供任务fork时的映射状态重置及页面虚拟地址的增删操作接口。",
          "similarity": 0.5528602600097656
        },
        {
          "chunk_id": 0,
          "file_path": "mm/highmem.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * High memory handling common code and variables.",
            " *",
            " * (C) 1999 Andrea Arcangeli, SuSE GmbH, andrea@suse.de",
            " *          Gerhard Wichert, Siemens AG, Gerhard.Wichert@pdb.siemens.de",
            " *",
            " *",
            " * Redesigned the x86 32-bit VM architecture to deal with",
            " * 64-bit physical space. With current x86 CPUs this",
            " * means up to 64 Gigabytes physical RAM.",
            " *",
            " * Rewrote high memory support to move the page cache into",
            " * high memory. Implemented permanent (schedulable) kmaps",
            " * based on Linus' idea.",
            " *",
            " * Copyright (C) 1999 Ingo Molnar <mingo@redhat.com>",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kgdb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/vmalloc.h>",
            "",
            "#ifdef CONFIG_KMAP_LOCAL"
          ],
          "function_name": null,
          "description": "声明高内存支持的公共代码和变量，包含页表管理、永久kmaps等功能的实现及相关头文件导入。",
          "similarity": 0.5520808696746826
        },
        {
          "chunk_id": 1,
          "file_path": "mm/highmem.c",
          "start_line": 34,
          "end_line": 168,
          "content": [
            "static inline int kmap_local_calc_idx(int idx)",
            "{",
            "\treturn idx + KM_MAX_IDX * smp_processor_id();",
            "}",
            "static inline unsigned int get_pkmap_color(struct page *page)",
            "{",
            "\treturn 0;",
            "}",
            "static inline unsigned int get_next_pkmap_nr(unsigned int color)",
            "{",
            "\tstatic unsigned int last_pkmap_nr;",
            "",
            "\tlast_pkmap_nr = (last_pkmap_nr + 1) & LAST_PKMAP_MASK;",
            "\treturn last_pkmap_nr;",
            "}",
            "static inline int no_more_pkmaps(unsigned int pkmap_nr, unsigned int color)",
            "{",
            "\treturn pkmap_nr == 0;",
            "}",
            "static inline int get_pkmap_entries_count(unsigned int color)",
            "{",
            "\treturn LAST_PKMAP;",
            "}",
            "unsigned int __nr_free_highpages(void)",
            "{",
            "\tstruct zone *zone;",
            "\tunsigned int pages = 0;",
            "",
            "\tfor_each_populated_zone(zone) {",
            "\t\tif (is_highmem(zone))",
            "\t\t\tpages += zone_page_state(zone, NR_FREE_PAGES);",
            "\t}",
            "",
            "\treturn pages;",
            "}",
            "static void flush_all_zero_pkmaps(void)",
            "{",
            "\tint i;",
            "\tint need_flush = 0;",
            "",
            "\tflush_cache_kmaps();",
            "",
            "\tfor (i = 0; i < LAST_PKMAP; i++) {",
            "\t\tstruct page *page;",
            "\t\tpte_t ptent;",
            "",
            "\t\t/*",
            "\t\t * zero means we don't have anything to do,",
            "\t\t * >1 means that it is still in use. Only",
            "\t\t * a count of 1 means that it is free but",
            "\t\t * needs to be unmapped",
            "\t\t */",
            "\t\tif (pkmap_count[i] != 1)",
            "\t\t\tcontinue;",
            "\t\tpkmap_count[i] = 0;",
            "",
            "\t\t/* sanity check */",
            "\t\tptent = ptep_get(&pkmap_page_table[i]);",
            "\t\tBUG_ON(pte_none(ptent));",
            "",
            "\t\t/*",
            "\t\t * Don't need an atomic fetch-and-clear op here;",
            "\t\t * no-one has the page mapped, and cannot get at",
            "\t\t * its virtual address (and hence PTE) without first",
            "\t\t * getting the kmap_lock (which is held here).",
            "\t\t * So no dangers, even with speculative execution.",
            "\t\t */",
            "\t\tpage = pte_page(ptent);",
            "\t\tpte_clear(&init_mm, PKMAP_ADDR(i), &pkmap_page_table[i]);",
            "",
            "\t\tset_page_address(page, NULL);",
            "\t\tneed_flush = 1;",
            "\t}",
            "\tif (need_flush)",
            "\t\tflush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));",
            "}",
            "void __kmap_flush_unused(void)",
            "{",
            "\tlock_kmap();",
            "\tflush_all_zero_pkmaps();",
            "\tunlock_kmap();",
            "}",
            "static inline unsigned long map_new_virtual(struct page *page)",
            "{",
            "\tunsigned long vaddr;",
            "\tint count;",
            "\tunsigned int last_pkmap_nr;",
            "\tunsigned int color = get_pkmap_color(page);",
            "",
            "start:",
            "\tcount = get_pkmap_entries_count(color);",
            "\t/* Find an empty entry */",
            "\tfor (;;) {",
            "\t\tlast_pkmap_nr = get_next_pkmap_nr(color);",
            "\t\tif (no_more_pkmaps(last_pkmap_nr, color)) {",
            "\t\t\tflush_all_zero_pkmaps();",
            "\t\t\tcount = get_pkmap_entries_count(color);",
            "\t\t}",
            "\t\tif (!pkmap_count[last_pkmap_nr])",
            "\t\t\tbreak;\t/* Found a usable entry */",
            "\t\tif (--count)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Sleep for somebody else to unmap their entries",
            "\t\t */",
            "\t\t{",
            "\t\t\tDECLARE_WAITQUEUE(wait, current);",
            "\t\t\twait_queue_head_t *pkmap_map_wait =",
            "\t\t\t\tget_pkmap_wait_queue_head(color);",
            "",
            "\t\t\t__set_current_state(TASK_UNINTERRUPTIBLE);",
            "\t\t\tadd_wait_queue(pkmap_map_wait, &wait);",
            "\t\t\tunlock_kmap();",
            "\t\t\tschedule();",
            "\t\t\tremove_wait_queue(pkmap_map_wait, &wait);",
            "\t\t\tlock_kmap();",
            "",
            "\t\t\t/* Somebody else might have mapped it while we slept */",
            "\t\t\tif (page_address(page))",
            "\t\t\t\treturn (unsigned long)page_address(page);",
            "",
            "\t\t\t/* Re-start */",
            "\t\t\tgoto start;",
            "\t\t}",
            "\t}",
            "\tvaddr = PKMAP_ADDR(last_pkmap_nr);",
            "\tset_pte_at(&init_mm, vaddr,",
            "\t\t   &(pkmap_page_table[last_pkmap_nr]), mk_pte(page, kmap_prot));",
            "",
            "\tpkmap_count[last_pkmap_nr] = 1;",
            "\tset_page_address(page, (void *)vaddr);",
            "",
            "\treturn vaddr;",
            "}"
          ],
          "function_name": "kmap_local_calc_idx, get_pkmap_color, get_next_pkmap_nr, no_more_pkmaps, get_pkmap_entries_count, __nr_free_highpages, flush_all_zero_pkmaps, __kmap_flush_unused, map_new_virtual",
          "description": "实现高内存页表项管理逻辑，包含计算索引、获取颜色值、遍历页表项、统计空闲页及刷新无效页表项的操作。",
          "similarity": 0.5402124524116516
        },
        {
          "chunk_id": 2,
          "file_path": "mm/highmem.c",
          "start_line": 348,
          "end_line": 451,
          "content": [
            "void kunmap_high(struct page *page)",
            "{",
            "\tunsigned long vaddr;",
            "\tunsigned long nr;",
            "\tunsigned long flags;",
            "\tint need_wakeup;",
            "\tunsigned int color = get_pkmap_color(page);",
            "\twait_queue_head_t *pkmap_map_wait;",
            "",
            "\tlock_kmap_any(flags);",
            "\tvaddr = (unsigned long)page_address(page);",
            "\tBUG_ON(!vaddr);",
            "\tnr = PKMAP_NR(vaddr);",
            "",
            "\t/*",
            "\t * A count must never go down to zero",
            "\t * without a TLB flush!",
            "\t */",
            "\tneed_wakeup = 0;",
            "\tswitch (--pkmap_count[nr]) {",
            "\tcase 0:",
            "\t\tBUG();",
            "\tcase 1:",
            "\t\t/*",
            "\t\t * Avoid an unnecessary wake_up() function call.",
            "\t\t * The common case is pkmap_count[] == 1, but",
            "\t\t * no waiters.",
            "\t\t * The tasks queued in the wait-queue are guarded",
            "\t\t * by both the lock in the wait-queue-head and by",
            "\t\t * the kmap_lock.  As the kmap_lock is held here,",
            "\t\t * no need for the wait-queue-head's lock.  Simply",
            "\t\t * test if the queue is empty.",
            "\t\t */",
            "\t\tpkmap_map_wait = get_pkmap_wait_queue_head(color);",
            "\t\tneed_wakeup = waitqueue_active(pkmap_map_wait);",
            "\t}",
            "\tunlock_kmap_any(flags);",
            "",
            "\t/* do wake-up, if needed, race-free outside of the spin lock */",
            "\tif (need_wakeup)",
            "\t\twake_up(pkmap_map_wait);",
            "}",
            "void zero_user_segments(struct page *page, unsigned start1, unsigned end1,",
            "\t\tunsigned start2, unsigned end2)",
            "{",
            "\tunsigned int i;",
            "",
            "\tBUG_ON(end1 > page_size(page) || end2 > page_size(page));",
            "",
            "\tif (start1 >= end1)",
            "\t\tstart1 = end1 = 0;",
            "\tif (start2 >= end2)",
            "\t\tstart2 = end2 = 0;",
            "",
            "\tfor (i = 0; i < compound_nr(page); i++) {",
            "\t\tvoid *kaddr = NULL;",
            "",
            "\t\tif (start1 >= PAGE_SIZE) {",
            "\t\t\tstart1 -= PAGE_SIZE;",
            "\t\t\tend1 -= PAGE_SIZE;",
            "\t\t} else {",
            "\t\t\tunsigned this_end = min_t(unsigned, end1, PAGE_SIZE);",
            "",
            "\t\t\tif (end1 > start1) {",
            "\t\t\t\tkaddr = kmap_local_page(page + i);",
            "\t\t\t\tmemset(kaddr + start1, 0, this_end - start1);",
            "\t\t\t}",
            "\t\t\tend1 -= this_end;",
            "\t\t\tstart1 = 0;",
            "\t\t}",
            "",
            "\t\tif (start2 >= PAGE_SIZE) {",
            "\t\t\tstart2 -= PAGE_SIZE;",
            "\t\t\tend2 -= PAGE_SIZE;",
            "\t\t} else {",
            "\t\t\tunsigned this_end = min_t(unsigned, end2, PAGE_SIZE);",
            "",
            "\t\t\tif (end2 > start2) {",
            "\t\t\t\tif (!kaddr)",
            "\t\t\t\t\tkaddr = kmap_local_page(page + i);",
            "\t\t\t\tmemset(kaddr + start2, 0, this_end - start2);",
            "\t\t\t}",
            "\t\t\tend2 -= this_end;",
            "\t\t\tstart2 = 0;",
            "\t\t}",
            "",
            "\t\tif (kaddr) {",
            "\t\t\tkunmap_local(kaddr);",
            "\t\t\tflush_dcache_page(page + i);",
            "\t\t}",
            "",
            "\t\tif (!end1 && !end2)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\tBUG_ON((start1 | start2 | end1 | end2) != 0);",
            "}",
            "static inline int kmap_local_idx_push(void)",
            "{",
            "\tWARN_ON_ONCE(in_hardirq() && !irqs_disabled());",
            "\tcurrent->kmap_ctrl.idx += KM_INCR;",
            "\tBUG_ON(current->kmap_ctrl.idx >= KM_MAX_IDX);",
            "\treturn current->kmap_ctrl.idx - 1;",
            "}"
          ],
          "function_name": "kunmap_high, zero_user_segments, kmap_local_idx_push",
          "description": "提供高内存页解除映射和零填充功能，通过原子操作更新计数器并唤醒等待者，处理页面内容清零的特殊场景。",
          "similarity": 0.49814730882644653
        }
      ]
    }
  ]
}