{
  "query": "Linux进程地址空间页表结构",
  "timestamp": "2025-12-22 14:00:19",
  "retrieved_files": [
    {
      "source_file": "mm/pagewalk.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:08:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pagewalk.c`\n\n---\n\n# pagewalk.c 技术文档\n\n## 1. 文件概述\n\n`pagewalk.c` 是 Linux 内核中实现通用页表遍历（page table walk）机制的核心文件。它提供了一套可配置的回调接口，允许内核子系统以统一的方式遍历进程地址空间中的各级页表项（PGD → P4D → PUD → PMD → PTE），并支持对普通页、透明大页（THP）、hugetlbfs 大页以及架构特定的 hugepd（huge page directory）结构进行处理。该机制广泛用于内存管理、调试、性能分析和安全审计等场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `real_depth(int depth)`  \n  计算页表项在物理层级结构中的真实深度，考虑了某些架构下页表层级被“折叠”（folded）的情况（如 x86_64 中 P4D/PUD/PMD 可能被编译时优化掉）。\n\n- `walk_pte_range(pmd_t *pmd, ...)`  \n  遍历指定 PMD 所覆盖地址范围内的所有 PTE 项，调用 `ops->pte_entry` 回调。\n\n- `walk_pmd_range(pud_t *pud, ...)`  \n  遍历 PUD 范围内的 PMD 项，支持透明大页（THP）处理：若遇到 THP 且需要深入，则调用 `split_huge_pmd()` 拆分后再遍历 PTE。\n\n- `walk_pud_range(p4d_t *p4d, ...)`  \n  遍历 P4D 范围内的 PUD 项，类似地支持 PUD 级别的透明大页拆分。\n\n- `walk_p4d_range(pgd_t *pgd, ...)`  \n  遍历 PGD 范围内的 P4D 项。\n\n- `walk_pgd_range(unsigned long addr, ...)`  \n  顶层遍历函数，从 PGD 开始向下递归遍历整个指定虚拟地址区间。\n\n- `walk_hugetlb_range(unsigned long addr, ...)`  \n  （仅当 `CONFIG_HUGETLB_PAGE` 启用时）专门处理 hugetlbfs 映射的大页，调用 `ops->hugetlb_entry` 回调。\n\n- `walk_hugepd_range(hugepd_t *phpd, ...)`  \n  （仅当 `CONFIG_ARCH_HAS_HUGEPD` 启用时）处理架构特定的 hugepd 结构，用于非标准大页布局。\n\n### 关键数据结构\n\n- `struct mm_walk`  \n  封装遍历上下文，包含目标地址空间（`mm`）、VMA（`vma`）、操作回调集合（`ops`）、当前动作控制（`action`）等。\n\n- `struct mm_walk_ops`  \n  定义遍历过程中各级页表项的回调函数指针，包括：\n  - `pgd_entry`, `p4d_entry`, `pud_entry`, `pmd_entry`\n  - `pte_entry`, `hugetlb_entry`\n  - `pte_hole`（处理未映射或无效区域）\n\n- 动作控制枚举（隐式使用）：\n  - `ACTION_SUBTREE`：默认行为，继续向下遍历\n  - `ACTION_CONTINUE`：跳过当前子树\n  - `ACTION_AGAIN`：重新处理当前项（用于动态修改页表后重试）\n\n## 3. 关键实现\n\n### 层级折叠处理\n`real_depth()` 函数通过检查 `PTRS_PER_P?D == 1` 来判断某一级页表是否在编译时被折叠（即逻辑存在但物理上与上一级合并），从而将逻辑深度映射到实际硬件层级，确保 `pte_hole` 回调传入正确的深度参数。\n\n### 页表锁与映射管理\n- 在有 VMA 上下文时（`!walk->no_vma`），使用 `pte_offset_map_lock()` 获取 PTE 页表锁并映射 PTE；\n- 在无 VMA 场景（如内核页表遍历）时，根据地址范围选择 `pte_offset_kernel()` 或 `pte_offset_map()`，避免对用户空间页表执行不必要的验证。\n\n### 透明大页（THP）支持\n在 `walk_pmd_range()` 和 `walk_pud_range()` 中：\n- 若 `walk->vma` 存在且遇到 THP（`pmd_leaf()` 为真），则调用 `split_huge_pmd()` 将其拆分为普通 PTE 页表；\n- 拆分后重新检查 PMD 状态，确保遍历的是细化后的 PTE。\n\n### HugePD 支持\n当检测到页表项是 `hugepd` 类型（通过 `is_hugepd()` 判断），调用 `walk_hugepd_range()`，该函数按大页大小步进地址，并通过 `hugepte_offset()` 获取对应 PTE，适用于 PowerPC 等架构的非标准大页布局。\n\n### Hugetlbfs 专用路径\n`walk_hugetlb_range()` 使用 `hugetlb_walk()` 查找大页 PTE，并在 VMA 读锁保护下遍历，确保 hugetlbfs 映射的一致性。\n\n### 动作控制机制\n通过 `walk->action` 字段实现遍历流程的动态控制：\n- 回调函数可设置 `ACTION_CONTINUE` 跳过子树；\n- 设置 `ACTION_AGAIN` 可触发当前节点重处理（如页表被修改后）；\n- 默认为 `ACTION_SUBTREE`，继续向下遍历。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pagewalk.h>`：定义 `struct mm_walk`、`struct mm_walk_ops` 及相关常量\n  - `<linux/highmem.h>`：提供 `pte_offset_map()` / `pte_unmap()` 等高内存映射接口\n  - `<linux/sched.h>`：访问 `task_struct` 和 `mm_struct`\n  - `<linux/hugetlb.h>`：hugetlbfs 相关操作（如 `hugetlb_walk()`, `hstate_vma()`）\n\n- **架构依赖**：\n  - 依赖各架构定义的页表操作宏（如 `pmd_offset()`, `pmd_none()`, `pmd_leaf()` 等）\n  - `CONFIG_ARCH_HAS_HUGEPD` 控制 hugepd 支持\n  - `PTRS_PER_P?D` 宏用于判断页表折叠\n\n- **内存管理子系统**：\n  - 与 THP 子系统交互（`split_huge_pmd()`, `split_huge_pud()`）\n  - 与 hugetlbfs 子系统交互（`hugetlb_vma_lock_read()` 等）\n\n## 5. 使用场景\n\n- **内存统计与审计**：如 `/proc/pid/smaps` 生成、内存占用分析工具\n- **页表转储与调试**：内核调试功能（如 `CONFIG_EFI_PGT_DUMP`）遍历 EFI 页表\n- **内存迁移与回收**：在内存规整（compaction）或 NUMA 迁移时扫描页表\n- **安全监控**：检测异常内存映射（如可执行堆栈）\n- **性能分析**：perf 工具通过页表遍历关联虚拟地址与物理页\n- **KSM（Kernel Samepage Merging）**：扫描可合并页面\n- **用户态页表检查**：通过 `walk_page_range()` 系列 API 供内核模块遍历指定 VMA 的页表结构",
      "similarity": 0.6185587048530579,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/pagewalk.c",
          "start_line": 12,
          "end_line": 168,
          "content": [
            "static int real_depth(int depth)",
            "{",
            "\tif (depth == 3 && PTRS_PER_PMD == 1)",
            "\t\tdepth = 2;",
            "\tif (depth == 2 && PTRS_PER_PUD == 1)",
            "\t\tdepth = 1;",
            "\tif (depth == 1 && PTRS_PER_P4D == 1)",
            "\t\tdepth = 0;",
            "\treturn depth;",
            "}",
            "static int walk_pte_range_inner(pte_t *pte, unsigned long addr,",
            "\t\t\t\tunsigned long end, struct mm_walk *walk)",
            "{",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint err = 0;",
            "",
            "\tfor (;;) {",
            "\t\terr = ops->pte_entry(pte, addr, addr + PAGE_SIZE, walk);",
            "\t\tif (err)",
            "\t\t       break;",
            "\t\tif (addr >= end - PAGE_SIZE)",
            "\t\t\tbreak;",
            "\t\taddr += PAGE_SIZE;",
            "\t\tpte++;",
            "\t}",
            "\treturn err;",
            "}",
            "static int walk_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,",
            "\t\t\t  struct mm_walk *walk)",
            "{",
            "\tpte_t *pte;",
            "\tint err = 0;",
            "\tspinlock_t *ptl;",
            "",
            "\tif (walk->no_vma) {",
            "\t\t/*",
            "\t\t * pte_offset_map() might apply user-specific validation.",
            "\t\t * Indeed, on x86_64 the pmd entries set up by init_espfix_ap()",
            "\t\t * fit its pmd_bad() check (_PAGE_NX set and _PAGE_RW clear),",
            "\t\t * and CONFIG_EFI_PGT_DUMP efi_mm goes so far as to walk them.",
            "\t\t */",
            "\t\tif (walk->mm == &init_mm || addr >= TASK_SIZE)",
            "\t\t\tpte = pte_offset_kernel(pmd, addr);",
            "\t\telse",
            "\t\t\tpte = pte_offset_map(pmd, addr);",
            "\t\tif (pte) {",
            "\t\t\terr = walk_pte_range_inner(pte, addr, end, walk);",
            "\t\t\tif (walk->mm != &init_mm && addr < TASK_SIZE)",
            "\t\t\t\tpte_unmap(pte);",
            "\t\t}",
            "\t} else {",
            "\t\tpte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);",
            "\t\tif (pte) {",
            "\t\t\terr = walk_pte_range_inner(pte, addr, end, walk);",
            "\t\t\tpte_unmap_unlock(pte, ptl);",
            "\t\t}",
            "\t}",
            "\tif (!pte)",
            "\t\twalk->action = ACTION_AGAIN;",
            "\treturn err;",
            "}",
            "static int walk_hugepd_range(hugepd_t *phpd, unsigned long addr,",
            "\t\t\t     unsigned long end, struct mm_walk *walk, int pdshift)",
            "{",
            "\tint err = 0;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint shift = hugepd_shift(*phpd);",
            "\tint page_size = 1 << shift;",
            "",
            "\tif (!ops->pte_entry)",
            "\t\treturn 0;",
            "",
            "\tif (addr & (page_size - 1))",
            "\t\treturn 0;",
            "",
            "\tfor (;;) {",
            "\t\tpte_t *pte;",
            "",
            "\t\tspin_lock(&walk->mm->page_table_lock);",
            "\t\tpte = hugepte_offset(*phpd, addr, pdshift);",
            "\t\terr = ops->pte_entry(pte, addr, addr + page_size, walk);",
            "\t\tspin_unlock(&walk->mm->page_table_lock);",
            "",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t\tif (addr >= end - page_size)",
            "\t\t\tbreak;",
            "\t\taddr += page_size;",
            "\t}",
            "\treturn err;",
            "}",
            "static int walk_hugepd_range(hugepd_t *phpd, unsigned long addr,",
            "\t\t\t     unsigned long end, struct mm_walk *walk, int pdshift)",
            "{",
            "\treturn 0;",
            "}",
            "static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,",
            "\t\t\t  struct mm_walk *walk)",
            "{",
            "\tpmd_t *pmd;",
            "\tunsigned long next;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint err = 0;",
            "\tint depth = real_depth(3);",
            "",
            "\tpmd = pmd_offset(pud, addr);",
            "\tdo {",
            "again:",
            "\t\tnext = pmd_addr_end(addr, end);",
            "\t\tif (pmd_none(*pmd)) {",
            "\t\t\tif (ops->pte_hole)",
            "\t\t\t\terr = ops->pte_hole(addr, next, depth, walk);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\twalk->action = ACTION_SUBTREE;",
            "",
            "\t\t/*",
            "\t\t * This implies that each ->pmd_entry() handler",
            "\t\t * needs to know about pmd_trans_huge() pmds",
            "\t\t */",
            "\t\tif (ops->pmd_entry)",
            "\t\t\terr = ops->pmd_entry(pmd, addr, next, walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "",
            "\t\tif (walk->action == ACTION_AGAIN)",
            "\t\t\tgoto again;",
            "",
            "\t\t/*",
            "\t\t * Check this here so we only break down trans_huge",
            "\t\t * pages when we _need_ to",
            "\t\t */",
            "\t\tif ((!walk->vma && (pmd_leaf(*pmd) || !pmd_present(*pmd))) ||",
            "\t\t    walk->action == ACTION_CONTINUE ||",
            "\t\t    !(ops->pte_entry))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (walk->vma)",
            "\t\t\tsplit_huge_pmd(walk->vma, pmd, addr);",
            "",
            "\t\tif (is_hugepd(__hugepd(pmd_val(*pmd))))",
            "\t\t\terr = walk_hugepd_range((hugepd_t *)pmd, addr, next, walk, PMD_SHIFT);",
            "\t\telse",
            "\t\t\terr = walk_pte_range(pmd, addr, next, walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "",
            "\t\tif (walk->action == ACTION_AGAIN)",
            "\t\t\tgoto again;",
            "",
            "\t} while (pmd++, addr = next, addr != end);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "real_depth, walk_pte_range_inner, walk_pte_range, walk_hugepd_range, walk_hugepd_range, walk_pmd_range",
          "description": "实现页表遍历核心逻辑，包含real_depth函数用于修正页表层级，walk_pte_range遍历页目录项，walk_pmd_range处理大页面拆分，walk_hugepd_range处理HugePD页面，walk_pud_range/walk_p4d_range/walk_pgd_range递归处理更高层级页表结构。",
          "similarity": 0.5459574460983276
        },
        {
          "chunk_id": 4,
          "file_path": "mm/pagewalk.c",
          "start_line": 470,
          "end_line": 589,
          "content": [
            "int walk_page_range(struct mm_struct *mm, unsigned long start,",
            "\t\tunsigned long end, const struct mm_walk_ops *ops,",
            "\t\tvoid *private)",
            "{",
            "\tint err = 0;",
            "\tunsigned long next;",
            "\tstruct vm_area_struct *vma;",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.mm\t\t= mm,",
            "\t\t.private\t= private,",
            "\t};",
            "",
            "\tif (start >= end)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!walk.mm)",
            "\t\treturn -EINVAL;",
            "",
            "\tprocess_mm_walk_lock(walk.mm, ops->walk_lock);",
            "",
            "\tvma = find_vma(walk.mm, start);",
            "\tdo {",
            "\t\tif (!vma) { /* after the last vma */",
            "\t\t\twalk.vma = NULL;",
            "\t\t\tnext = end;",
            "\t\t\tif (ops->pte_hole)",
            "\t\t\t\terr = ops->pte_hole(start, next, -1, &walk);",
            "\t\t} else if (start < vma->vm_start) { /* outside vma */",
            "\t\t\twalk.vma = NULL;",
            "\t\t\tnext = min(end, vma->vm_start);",
            "\t\t\tif (ops->pte_hole)",
            "\t\t\t\terr = ops->pte_hole(start, next, -1, &walk);",
            "\t\t} else { /* inside vma */",
            "\t\t\tprocess_vma_walk_lock(vma, ops->walk_lock);",
            "\t\t\twalk.vma = vma;",
            "\t\t\tnext = min(end, vma->vm_end);",
            "\t\t\tvma = find_vma(mm, vma->vm_end);",
            "",
            "\t\t\terr = walk_page_test(start, next, &walk);",
            "\t\t\tif (err > 0) {",
            "\t\t\t\t/*",
            "\t\t\t\t * positive return values are purely for",
            "\t\t\t\t * controlling the pagewalk, so should never",
            "\t\t\t\t * be passed to the callers.",
            "\t\t\t\t */",
            "\t\t\t\terr = 0;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif (err < 0)",
            "\t\t\t\tbreak;",
            "\t\t\terr = __walk_page_range(start, next, &walk);",
            "\t\t}",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t} while (start = next, start < end);",
            "\treturn err;",
            "}",
            "int walk_page_range_novma(struct mm_struct *mm, unsigned long start,",
            "\t\t\t  unsigned long end, const struct mm_walk_ops *ops,",
            "\t\t\t  pgd_t *pgd,",
            "\t\t\t  void *private)",
            "{",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.mm\t\t= mm,",
            "\t\t.pgd\t\t= pgd,",
            "\t\t.private\t= private,",
            "\t\t.no_vma\t\t= true",
            "\t};",
            "",
            "\tif (start >= end || !walk.mm)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * 1) For walking the user virtual address space:",
            "\t *",
            "\t * The mmap lock protects the page walker from changes to the page",
            "\t * tables during the walk.  However a read lock is insufficient to",
            "\t * protect those areas which don't have a VMA as munmap() detaches",
            "\t * the VMAs before downgrading to a read lock and actually tearing",
            "\t * down PTEs/page tables. In which case, the mmap write lock should",
            "\t * be hold.",
            "\t *",
            "\t * 2) For walking the kernel virtual address space:",
            "\t *",
            "\t * The kernel intermediate page tables usually do not be freed, so",
            "\t * the mmap map read lock is sufficient. But there are some exceptions.",
            "\t * E.g. memory hot-remove. In which case, the mmap lock is insufficient",
            "\t * to prevent the intermediate kernel pages tables belonging to the",
            "\t * specified address range from being freed. The caller should take",
            "\t * other actions to prevent this race.",
            "\t */",
            "\tif (mm == &init_mm)",
            "\t\tmmap_assert_locked(walk.mm);",
            "\telse",
            "\t\tmmap_assert_write_locked(walk.mm);",
            "",
            "\treturn walk_pgd_range(start, end, &walk);",
            "}",
            "int walk_page_range_vma(struct vm_area_struct *vma, unsigned long start,",
            "\t\t\tunsigned long end, const struct mm_walk_ops *ops,",
            "\t\t\tvoid *private)",
            "{",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.mm\t\t= vma->vm_mm,",
            "\t\t.vma\t\t= vma,",
            "\t\t.private\t= private,",
            "\t};",
            "",
            "\tif (start >= end || !walk.mm)",
            "\t\treturn -EINVAL;",
            "\tif (start < vma->vm_start || end > vma->vm_end)",
            "\t\treturn -EINVAL;",
            "",
            "\tprocess_mm_walk_lock(walk.mm, ops->walk_lock);",
            "\tprocess_vma_walk_lock(vma, ops->walk_lock);",
            "\treturn __walk_page_range(start, end, &walk);",
            "}"
          ],
          "function_name": "walk_page_range, walk_page_range_novma, walk_page_range_vma",
          "description": "实现三种页表遍历接口，walk_page_range处理任意MM域的页表遍历，walk_page_range_novma处理无需VMA的内核地址空间遍历，walk_page_range_vma处理特定VMA区域的遍历，均通过调用底层遍历函数完成实际工作。",
          "similarity": 0.5394389629364014
        },
        {
          "chunk_id": 5,
          "file_path": "mm/pagewalk.c",
          "start_line": 613,
          "end_line": 675,
          "content": [
            "int walk_page_vma(struct vm_area_struct *vma, const struct mm_walk_ops *ops,",
            "\t\tvoid *private)",
            "{",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.mm\t\t= vma->vm_mm,",
            "\t\t.vma\t\t= vma,",
            "\t\t.private\t= private,",
            "\t};",
            "",
            "\tif (!walk.mm)",
            "\t\treturn -EINVAL;",
            "",
            "\tprocess_mm_walk_lock(walk.mm, ops->walk_lock);",
            "\tprocess_vma_walk_lock(vma, ops->walk_lock);",
            "\treturn __walk_page_range(vma->vm_start, vma->vm_end, &walk);",
            "}",
            "int walk_page_mapping(struct address_space *mapping, pgoff_t first_index,",
            "\t\t      pgoff_t nr, const struct mm_walk_ops *ops,",
            "\t\t      void *private)",
            "{",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.private\t= private,",
            "\t};",
            "\tstruct vm_area_struct *vma;",
            "\tpgoff_t vba, vea, cba, cea;",
            "\tunsigned long start_addr, end_addr;",
            "\tint err = 0;",
            "",
            "\tlockdep_assert_held(&mapping->i_mmap_rwsem);",
            "\tvma_interval_tree_foreach(vma, &mapping->i_mmap, first_index,",
            "\t\t\t\t  first_index + nr - 1) {",
            "\t\t/* Clip to the vma */",
            "\t\tvba = vma->vm_pgoff;",
            "\t\tvea = vba + vma_pages(vma);",
            "\t\tcba = first_index;",
            "\t\tcba = max(cba, vba);",
            "\t\tcea = first_index + nr;",
            "\t\tcea = min(cea, vea);",
            "",
            "\t\tstart_addr = ((cba - vba) << PAGE_SHIFT) + vma->vm_start;",
            "\t\tend_addr = ((cea - vba) << PAGE_SHIFT) + vma->vm_start;",
            "\t\tif (start_addr >= end_addr)",
            "\t\t\tcontinue;",
            "",
            "\t\twalk.vma = vma;",
            "\t\twalk.mm = vma->vm_mm;",
            "",
            "\t\terr = walk_page_test(vma->vm_start, vma->vm_end, &walk);",
            "\t\tif (err > 0) {",
            "\t\t\terr = 0;",
            "\t\t\tbreak;",
            "\t\t} else if (err < 0)",
            "\t\t\tbreak;",
            "",
            "\t\terr = __walk_page_range(start_addr, end_addr, &walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "walk_page_vma, walk_page_mapping",
          "description": "该代码段实现了两种页面遍历接口：  \n1. `walk_page_vma`用于遍历指定VMA范围的页面，通过`__walk_page_range`执行实际操作，需持有VMA锁以保证并发安全；  \n2. `walk_page_mapping`遍历文件映射区域对应的所有VMA区间，按索引范围裁剪后调用`__walk_page_range`处理具体页表项，依赖VMA区间树遍历机制；  \n代码上下文不完整，部分锁操作和底层遍历函数（如`__walk_page_range`）未展示。",
          "similarity": 0.5085436105728149
        },
        {
          "chunk_id": 3,
          "file_path": "mm/pagewalk.c",
          "start_line": 302,
          "end_line": 413,
          "content": [
            "static unsigned long hugetlb_entry_end(struct hstate *h, unsigned long addr,",
            "\t\t\t\t       unsigned long end)",
            "{",
            "\tunsigned long boundary = (addr & huge_page_mask(h)) + huge_page_size(h);",
            "\treturn boundary < end ? boundary : end;",
            "}",
            "static int walk_hugetlb_range(unsigned long addr, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "\tstruct vm_area_struct *vma = walk->vma;",
            "\tstruct hstate *h = hstate_vma(vma);",
            "\tunsigned long next;",
            "\tunsigned long hmask = huge_page_mask(h);",
            "\tunsigned long sz = huge_page_size(h);",
            "\tpte_t *pte;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint err = 0;",
            "",
            "\thugetlb_vma_lock_read(vma);",
            "\tdo {",
            "\t\tnext = hugetlb_entry_end(h, addr, end);",
            "\t\tpte = hugetlb_walk(vma, addr & hmask, sz);",
            "\t\tif (pte)",
            "\t\t\terr = ops->hugetlb_entry(pte, hmask, addr, next, walk);",
            "\t\telse if (ops->pte_hole)",
            "\t\t\terr = ops->pte_hole(addr, next, -1, walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t} while (addr = next, addr != end);",
            "\thugetlb_vma_unlock_read(vma);",
            "",
            "\treturn err;",
            "}",
            "static int walk_hugetlb_range(unsigned long addr, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "\treturn 0;",
            "}",
            "static int walk_page_test(unsigned long start, unsigned long end,",
            "\t\t\tstruct mm_walk *walk)",
            "{",
            "\tstruct vm_area_struct *vma = walk->vma;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "",
            "\tif (ops->test_walk)",
            "\t\treturn ops->test_walk(start, end, walk);",
            "",
            "\t/*",
            "\t * vma(VM_PFNMAP) doesn't have any valid struct pages behind VM_PFNMAP",
            "\t * range, so we don't walk over it as we do for normal vmas. However,",
            "\t * Some callers are interested in handling hole range and they don't",
            "\t * want to just ignore any single address range. Such users certainly",
            "\t * define their ->pte_hole() callbacks, so let's delegate them to handle",
            "\t * vma(VM_PFNMAP).",
            "\t */",
            "\tif (vma->vm_flags & VM_PFNMAP) {",
            "\t\tint err = 1;",
            "\t\tif (ops->pte_hole)",
            "\t\t\terr = ops->pte_hole(start, end, -1, walk);",
            "\t\treturn err ? err : 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int __walk_page_range(unsigned long start, unsigned long end,",
            "\t\t\tstruct mm_walk *walk)",
            "{",
            "\tint err = 0;",
            "\tstruct vm_area_struct *vma = walk->vma;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "",
            "\tif (ops->pre_vma) {",
            "\t\terr = ops->pre_vma(start, end, walk);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t}",
            "",
            "\tif (is_vm_hugetlb_page(vma)) {",
            "\t\tif (ops->hugetlb_entry)",
            "\t\t\terr = walk_hugetlb_range(start, end, walk);",
            "\t} else",
            "\t\terr = walk_pgd_range(start, end, walk);",
            "",
            "\tif (ops->post_vma)",
            "\t\tops->post_vma(walk);",
            "",
            "\treturn err;",
            "}",
            "static inline void process_mm_walk_lock(struct mm_struct *mm,",
            "\t\t\t\t\tenum page_walk_lock walk_lock)",
            "{",
            "\tif (walk_lock == PGWALK_RDLOCK)",
            "\t\tmmap_assert_locked(mm);",
            "\telse",
            "\t\tmmap_assert_write_locked(mm);",
            "}",
            "static inline void process_vma_walk_lock(struct vm_area_struct *vma,",
            "\t\t\t\t\t enum page_walk_lock walk_lock)",
            "{",
            "#ifdef CONFIG_PER_VMA_LOCK",
            "\tswitch (walk_lock) {",
            "\tcase PGWALK_WRLOCK:",
            "\t\tvma_start_write(vma);",
            "\t\tbreak;",
            "\tcase PGWALK_WRLOCK_VERIFY:",
            "\t\tvma_assert_write_locked(vma);",
            "\t\tbreak;",
            "\tcase PGWALK_RDLOCK:",
            "\t\t/* PGWALK_RDLOCK is handled by process_mm_walk_lock */",
            "\t\tbreak;",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "hugetlb_entry_end, walk_hugetlb_range, walk_hugetlb_range, walk_page_test, __walk_page_range, process_mm_walk_lock, process_vma_walk_lock",
          "description": "提供HugeTLB页面处理支持，hugetlb_entry_end计算巨型页面边界，walk_hugetlb_range遍历HugeTLB页表，walk_page_test检测页表范围有效性，__walk_page_range作为通用遍历入口，process_*_walk_lock管理锁操作。",
          "similarity": 0.4972081482410431
        },
        {
          "chunk_id": 0,
          "file_path": "mm/pagewalk.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/pagewalk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched.h>",
            "#include <linux/hugetlb.h>",
            "",
            "/*",
            " * We want to know the real level where a entry is located ignoring any",
            " * folding of levels which may be happening. For example if p4d is folded then",
            " * a missing entry found at level 1 (p4d) is actually at level 0 (pgd).",
            " */"
          ],
          "function_name": null,
          "description": "定义了real_depth函数，用于调整页表层级以忽略折叠情况，通过比较PTRS_PER_*宏值来动态修正深度。其余部分为页表遍历相关头文件声明及注释说明。",
          "similarity": 0.4792773127555847
        }
      ]
    },
    {
      "source_file": "kernel/nsproxy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:12:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `nsproxy.c`\n\n---\n\n# nsproxy.c 技术文档\n\n## 1. 文件概述\n\n`nsproxy.c` 是 Linux 内核中实现命名空间（namespaces）代理机制的核心文件。该文件负责管理进程的命名空间代理结构 `nsproxy`，提供创建、复制、切换和释放命名空间集合的功能。命名空间是 Linux 容器技术（如 Docker、LXC）的基础，用于隔离进程视图，包括挂载点、UTS（主机名）、IPC、PID、网络、cgroup 和时间等资源。`nsproxy` 作为指向各类命名空间实例的容器，使得一个进程可以拥有独立的命名空间视图。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct nsproxy`**  \n  命名空间代理结构体，包含指向各类命名空间的指针：\n  - `uts_ns`：UTS 命名空间（主机名、域名）\n  - `ipc_ns`：IPC 命名空间（System V IPC 和 POSIX 消息队列）\n  - `mnt_ns`：挂载命名空间（文件系统挂载点视图）\n  - `pid_ns_for_children`：子进程将加入的 PID 命名空间\n  - `net_ns`：网络命名空间（网络设备、协议栈等）\n  - `cgroup_ns`：cgroup 命名空间（cgroup 层级视图）\n  - `time_ns` / `time_ns_for_children`：时间命名空间（用于虚拟化时间）\n\n- **`init_nsproxy`**  \n  全局初始化的命名空间代理实例，作为系统初始命名空间的引用。\n\n### 主要函数\n\n- **`create_nsproxy()`**  \n  从 slab 缓存分配一个新的 `nsproxy` 结构并初始化引用计数。\n\n- **`create_new_namespaces()`**  \n  根据指定标志位（如 `CLONE_NEWNS` 等）为任务创建全新的命名空间集合。\n\n- **`copy_namespaces()`**  \n  在 `clone()` 系统调用中被调用，根据 `clone_flags` 决定是否复制命名空间。\n\n- **`free_nsproxy()`**  \n  释放 `nsproxy` 及其引用的所有命名空间资源。\n\n- **`unshare_nsproxy_namespaces()`**  \n  在 `unshare()` 系统调用中使用，允许进程脱离当前命名空间并创建新的命名空间。\n\n- **`switch_task_namespaces()`**  \n  安全地切换任务的 `nsproxy`，并释放旧的引用。\n\n- **`exit_task_namespaces()`**  \n  进程退出时清理命名空间引用。\n\n- **`exec_task_namespaces()`**  \n  在 `execve()` 期间处理时间命名空间的特殊语义（子进程继承 `time_ns_for_children`）。\n\n- **`check_setns_flags()`**  \n  验证 `setns()` 系统调用传入的命名空间标志是否合法且内核已启用对应支持。\n\n## 3. 关键实现\n\n### 命名空间复制逻辑\n\n`create_new_namespaces()` 函数按顺序复制各类命名空间。若某一步失败（如内存不足或权限不足），则回滚已分配的资源，确保无内存泄漏。每个命名空间的复制由对应模块提供 `copy_xxx_ns()` 函数实现（如 `copy_mnt_ns()`、`copy_net_ns()` 等）。\n\n### 引用计数管理\n\n所有命名空间结构均使用引用计数（`refcount_t` 或类似机制）。`nsproxy` 本身也通过 `refcount_t count` 管理生命周期。`get_nsproxy()` 增加引用，`put_nsproxy()`（内联调用 `free_nsproxy()`）减少引用并在归零时释放。\n\n### 时间命名空间特殊处理\n\n时间命名空间具有两个字段：\n- `time_ns`：当前任务使用的时间命名空间。\n- `time_ns_for_children`：新创建子进程将继承的时间命名空间。\n\n在 `execve()` 时，若两者不同，需创建新的 `nsproxy` 并调用 `timens_on_fork()` 更新时间命名空间状态。\n\n### 权限与安全检查\n\n- 除 `CLONE_VM` 优化路径外，创建新命名空间需 `CAP_SYS_ADMIN` 能力。\n- 禁止同时指定 `CLONE_NEWIPC` 和 `CLONE_SYSVSEM`，因语义冲突。\n- `check_setns_flags()` 确保仅启用的命名空间类型可被操作。\n\n### 优化路径\n\n若 `clone_flags` 未请求任何新命名空间，且满足 `CLONE_VM` 或时间命名空间一致，则直接复用父进程的 `nsproxy`（仅增加引用计数），避免不必要的复制开销。\n\n## 4. 依赖关系\n\n- **内存管理**：依赖 `slab.h` 的 `kmem_cache` 机制分配 `nsproxy`。\n- **各命名空间子系统**：\n  - 挂载命名空间：`mnt_namespace.h`\n  - UTS：`utsname.h`\n  - IPC：`ipc_namespace.h`\n  - PID：`pid_namespace.h`\n  - 网络：`net_namespace.h`\n  - cgroup：`cgroup.h`\n  - 时间：`time_namespace.h`\n- **进程管理**：依赖 `task_struct`、`cred`、`fs_struct` 等结构。\n- **能力机制**：通过 `ns_capable()` 检查 `CAP_SYS_ADMIN`。\n- **proc 文件系统**：支持 `/proc/[pid]/ns/` 下的命名空间符号链接（通过 `proc_ns.h`）。\n\n## 5. 使用场景\n\n- **`clone()` 系统调用**：当指定 `CLONE_NEW*` 标志时，`copy_namespaces()` 被调用以创建子进程的命名空间视图。\n- **`unshare()` 系统调用**：进程调用 `unshare(CLONE_NEWNS | ...)` 时，`unshare_nsproxy_namespaces()` 创建新命名空间并切换。\n- **`setns()` 系统调用**：通过 `check_setns_flags()` 验证传入的命名空间类型合法性。\n- **`execve()` 系统调用**：处理时间命名空间的继承语义，确保子进程使用正确的 `time_ns_for_children`。\n- **进程退出**：`exit_task_namespaces()` 在进程终止时释放命名空间资源。\n- **容器运行时**：Docker、Podman、LXC 等依赖此机制实现资源隔离。",
      "similarity": 0.6169382333755493,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/nsproxy.c",
          "start_line": 151,
          "end_line": 265,
          "content": [
            "int copy_namespaces(unsigned long flags, struct task_struct *tsk)",
            "{",
            "\tstruct nsproxy *old_ns = tsk->nsproxy;",
            "\tstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);",
            "\tstruct nsproxy *new_ns;",
            "",
            "\tif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t      CLONE_NEWPID | CLONE_NEWNET |",
            "\t\t\t      CLONE_NEWCGROUP | CLONE_NEWTIME)))) {",
            "\t\tif ((flags & CLONE_VM) ||",
            "\t\t    likely(old_ns->time_ns_for_children == old_ns->time_ns)) {",
            "\t\t\tget_nsproxy(old_ns);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t} else if (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * CLONE_NEWIPC must detach from the undolist: after switching",
            "\t * to a new ipc namespace, the semaphore arrays from the old",
            "\t * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM",
            "\t * means share undolist with parent, so we must forbid using",
            "\t * it along with CLONE_NEWIPC.",
            "\t */",
            "\tif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==",
            "\t\t(CLONE_NEWIPC | CLONE_SYSVSEM))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);",
            "\tif (IS_ERR(new_ns))",
            "\t\treturn  PTR_ERR(new_ns);",
            "",
            "\tif ((flags & CLONE_VM) == 0)",
            "\t\ttimens_on_fork(new_ns, tsk);",
            "",
            "\ttsk->nsproxy = new_ns;",
            "\treturn 0;",
            "}",
            "void free_nsproxy(struct nsproxy *ns)",
            "{",
            "\tif (ns->mnt_ns)",
            "\t\tput_mnt_ns(ns->mnt_ns);",
            "\tif (ns->uts_ns)",
            "\t\tput_uts_ns(ns->uts_ns);",
            "\tif (ns->ipc_ns)",
            "\t\tput_ipc_ns(ns->ipc_ns);",
            "\tif (ns->pid_ns_for_children)",
            "\t\tput_pid_ns(ns->pid_ns_for_children);",
            "\tif (ns->time_ns)",
            "\t\tput_time_ns(ns->time_ns);",
            "\tif (ns->time_ns_for_children)",
            "\t\tput_time_ns(ns->time_ns_for_children);",
            "\tput_cgroup_ns(ns->cgroup_ns);",
            "\tput_net(ns->net_ns);",
            "\tkmem_cache_free(nsproxy_cachep, ns);",
            "}",
            "int unshare_nsproxy_namespaces(unsigned long unshare_flags,",
            "\tstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)",
            "{",
            "\tstruct user_namespace *user_ns;",
            "\tint err = 0;",
            "",
            "\tif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP |",
            "\t\t\t       CLONE_NEWTIME)))",
            "\t\treturn 0;",
            "",
            "\tuser_ns = new_cred ? new_cred->user_ns : current_user_ns();",
            "\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,",
            "\t\t\t\t\t new_fs ? new_fs : current->fs);",
            "\tif (IS_ERR(*new_nsp)) {",
            "\t\terr = PTR_ERR(*new_nsp);",
            "\t\tgoto out;",
            "\t}",
            "",
            "out:",
            "\treturn err;",
            "}",
            "void switch_task_namespaces(struct task_struct *p, struct nsproxy *new)",
            "{",
            "\tstruct nsproxy *ns;",
            "",
            "\tmight_sleep();",
            "",
            "\ttask_lock(p);",
            "\tns = p->nsproxy;",
            "\tp->nsproxy = new;",
            "\ttask_unlock(p);",
            "",
            "\tif (ns)",
            "\t\tput_nsproxy(ns);",
            "}",
            "void exit_task_namespaces(struct task_struct *p)",
            "{",
            "\tswitch_task_namespaces(p, NULL);",
            "}",
            "int exec_task_namespaces(void)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct nsproxy *new;",
            "",
            "\tif (tsk->nsproxy->time_ns_for_children == tsk->nsproxy->time_ns)",
            "\t\treturn 0;",
            "",
            "\tnew = create_new_namespaces(0, tsk, current_user_ns(), tsk->fs);",
            "\tif (IS_ERR(new))",
            "\t\treturn PTR_ERR(new);",
            "",
            "\ttimens_on_fork(new, tsk);",
            "\tswitch_task_namespaces(tsk, new);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_namespaces, free_nsproxy, unshare_nsproxy_namespaces, switch_task_namespaces, exit_task_namespaces, exec_task_namespaces",
          "description": "实现了命名空间相关操作，包括复制（copy_namespaces）、释放（free_nsproxy）、分离（unshare_nsproxy_namespaces）、切换（switch_task_namespaces）和验证（validate_nsset）等功能，支持多命名空间的动态管理",
          "similarity": 0.5511131286621094
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/nsproxy.c",
          "start_line": 512,
          "end_line": 549,
          "content": [
            "static void commit_nsset(struct nsset *nsset)",
            "{",
            "\tunsigned flags = nsset->flags;",
            "\tstruct task_struct *me = current;",
            "",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER) {",
            "\t\t/* transfer ownership */",
            "\t\tcommit_creds(nsset_cred(nsset));",
            "\t\tnsset->cred = NULL;",
            "\t}",
            "#endif",
            "",
            "\t/* We only need to commit if we have used a temporary fs_struct. */",
            "\tif ((flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS)) {",
            "\t\tset_fs_root(me->fs, &nsset->fs->root);",
            "\t\tset_fs_pwd(me->fs, &nsset->fs->pwd);",
            "\t}",
            "",
            "#ifdef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC)",
            "\t\texit_sem(me);",
            "#endif",
            "",
            "#ifdef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME)",
            "\t\ttimens_commit(me, nsset->nsproxy->time_ns);",
            "#endif",
            "",
            "\t/* transfer ownership */",
            "\tswitch_task_namespaces(me, nsset->nsproxy);",
            "\tnsset->nsproxy = NULL;",
            "}",
            "int __init nsproxy_cache_init(void)",
            "{",
            "\tnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC|SLAB_ACCOUNT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "commit_nsset, nsproxy_cache_init",
          "description": "完成命名空间变更提交（commit_nsset）和缓存初始化（nsproxy_cache_init），将临时命名空间绑定到当前任务并持久化，同时建立nsproxy结构体的Slab缓存以优化内存分配",
          "similarity": 0.510060727596283
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/nsproxy.c",
          "start_line": 1,
          "end_line": 150,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  Copyright (C) 2006 IBM Corporation",
            " *",
            " *  Author: Serge Hallyn <serue@us.ibm.com>",
            " *",
            " *  Jun 2006 - namespaces support",
            " *             OpenVZ, SWsoft Inc.",
            " *             Pavel Emelianov <xemul@openvz.org>",
            " */",
            "",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/init_task.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pid_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/perf_event.h>",
            "",
            "static struct kmem_cache *nsproxy_cachep;",
            "",
            "struct nsproxy init_nsproxy = {",
            "\t.count\t\t\t= REFCOUNT_INIT(1),",
            "\t.uts_ns\t\t\t= &init_uts_ns,",
            "#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)",
            "\t.ipc_ns\t\t\t= &init_ipc_ns,",
            "#endif",
            "\t.mnt_ns\t\t\t= NULL,",
            "\t.pid_ns_for_children\t= &init_pid_ns,",
            "#ifdef CONFIG_NET",
            "\t.net_ns\t\t\t= &init_net,",
            "#endif",
            "#ifdef CONFIG_CGROUPS",
            "\t.cgroup_ns\t\t= &init_cgroup_ns,",
            "#endif",
            "#ifdef CONFIG_TIME_NS",
            "\t.time_ns\t\t= &init_time_ns,",
            "\t.time_ns_for_children\t= &init_time_ns,",
            "#endif",
            "};",
            "",
            "static inline struct nsproxy *create_nsproxy(void)",
            "{",
            "\tstruct nsproxy *nsproxy;",
            "",
            "\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);",
            "\tif (nsproxy)",
            "\t\trefcount_set(&nsproxy->count, 1);",
            "\treturn nsproxy;",
            "}",
            "",
            "/*",
            " * Create new nsproxy and all of its the associated namespaces.",
            " * Return the newly created nsproxy.  Do not attach this to the task,",
            " * leave it to the caller to do proper locking and attach it to task.",
            " */",
            "static struct nsproxy *create_new_namespaces(unsigned long flags,",
            "\tstruct task_struct *tsk, struct user_namespace *user_ns,",
            "\tstruct fs_struct *new_fs)",
            "{",
            "\tstruct nsproxy *new_nsp;",
            "\tint err;",
            "",
            "\tnew_nsp = create_nsproxy();",
            "\tif (!new_nsp)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "",
            "\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);",
            "\tif (IS_ERR(new_nsp->mnt_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->mnt_ns);",
            "\t\tgoto out_ns;",
            "\t}",
            "",
            "\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);",
            "\tif (IS_ERR(new_nsp->uts_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->uts_ns);",
            "\t\tgoto out_uts;",
            "\t}",
            "",
            "\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);",
            "\tif (IS_ERR(new_nsp->ipc_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->ipc_ns);",
            "\t\tgoto out_ipc;",
            "\t}",
            "",
            "\tnew_nsp->pid_ns_for_children =",
            "\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);",
            "\tif (IS_ERR(new_nsp->pid_ns_for_children)) {",
            "\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);",
            "\t\tgoto out_pid;",
            "\t}",
            "",
            "\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,",
            "\t\t\t\t\t    tsk->nsproxy->cgroup_ns);",
            "\tif (IS_ERR(new_nsp->cgroup_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->cgroup_ns);",
            "\t\tgoto out_cgroup;",
            "\t}",
            "",
            "\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);",
            "\tif (IS_ERR(new_nsp->net_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->net_ns);",
            "\t\tgoto out_net;",
            "\t}",
            "",
            "\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,",
            "\t\t\t\t\ttsk->nsproxy->time_ns_for_children);",
            "\tif (IS_ERR(new_nsp->time_ns_for_children)) {",
            "\t\terr = PTR_ERR(new_nsp->time_ns_for_children);",
            "\t\tgoto out_time;",
            "\t}",
            "\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);",
            "",
            "\treturn new_nsp;",
            "",
            "out_time:",
            "\tput_net(new_nsp->net_ns);",
            "out_net:",
            "\tput_cgroup_ns(new_nsp->cgroup_ns);",
            "out_cgroup:",
            "\tif (new_nsp->pid_ns_for_children)",
            "\t\tput_pid_ns(new_nsp->pid_ns_for_children);",
            "out_pid:",
            "\tif (new_nsp->ipc_ns)",
            "\t\tput_ipc_ns(new_nsp->ipc_ns);",
            "out_ipc:",
            "\tif (new_nsp->uts_ns)",
            "\t\tput_uts_ns(new_nsp->uts_ns);",
            "out_uts:",
            "\tif (new_nsp->mnt_ns)",
            "\t\tput_mnt_ns(new_nsp->mnt_ns);",
            "out_ns:",
            "\tkmem_cache_free(nsproxy_cachep, new_nsp);",
            "\treturn ERR_PTR(err);",
            "}",
            "",
            "/*",
            " * called from clone.  This now handles copy for nsproxy and all",
            " * namespaces therein.",
            " */"
          ],
          "function_name": null,
          "description": "定义了nsproxy结构体的初始值和创建逻辑，包括各命名空间（如mnt、uts、ipc等）的初始化及通过create_new_namespaces函数创建新命名空间的流程，用于进程克隆时复制命名空间环境",
          "similarity": 0.5055642127990723
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/nsproxy.c",
          "start_line": 276,
          "end_line": 490,
          "content": [
            "static int check_setns_flags(unsigned long flags)",
            "{",
            "\tif (!flags || (flags & ~(CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t\t CLONE_NEWNET | CLONE_NEWTIME | CLONE_NEWUSER |",
            "\t\t\t\t CLONE_NEWPID | CLONE_NEWCGROUP)))",
            "\t\treturn -EINVAL;",
            "",
            "#ifndef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_UTS_NS",
            "\tif (flags & CLONE_NEWUTS)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_CGROUPS",
            "\tif (flags & CLONE_NEWCGROUP)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_NET_NS",
            "\tif (flags & CLONE_NEWNET)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME)",
            "\t\treturn -EINVAL;",
            "#endif",
            "",
            "\treturn 0;",
            "}",
            "static void put_nsset(struct nsset *nsset)",
            "{",
            "\tunsigned flags = nsset->flags;",
            "",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tput_cred(nsset_cred(nsset));",
            "\t/*",
            "\t * We only created a temporary copy if we attached to more than just",
            "\t * the mount namespace.",
            "\t */",
            "\tif (nsset->fs && (flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS))",
            "\t\tfree_fs_struct(nsset->fs);",
            "\tif (nsset->nsproxy)",
            "\t\tfree_nsproxy(nsset->nsproxy);",
            "}",
            "static int prepare_nsset(unsigned flags, struct nsset *nsset)",
            "{",
            "\tstruct task_struct *me = current;",
            "",
            "\tnsset->nsproxy = create_new_namespaces(0, me, current_user_ns(), me->fs);",
            "\tif (IS_ERR(nsset->nsproxy))",
            "\t\treturn PTR_ERR(nsset->nsproxy);",
            "",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tnsset->cred = prepare_creds();",
            "\telse",
            "\t\tnsset->cred = current_cred();",
            "\tif (!nsset->cred)",
            "\t\tgoto out;",
            "",
            "\t/* Only create a temporary copy of fs_struct if we really need to. */",
            "\tif (flags == CLONE_NEWNS) {",
            "\t\tnsset->fs = me->fs;",
            "\t} else if (flags & CLONE_NEWNS) {",
            "\t\tnsset->fs = copy_fs_struct(me->fs);",
            "\t\tif (!nsset->fs)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tnsset->flags = flags;",
            "\treturn 0;",
            "",
            "out:",
            "\tput_nsset(nsset);",
            "\treturn -ENOMEM;",
            "}",
            "static inline int validate_ns(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\treturn ns->ops->install(nsset, ns);",
            "}",
            "static int validate_nsset(struct nsset *nsset, struct pid *pid)",
            "{",
            "\tint ret = 0;",
            "\tunsigned flags = nsset->flags;",
            "\tstruct user_namespace *user_ns = NULL;",
            "\tstruct pid_namespace *pid_ns = NULL;",
            "\tstruct nsproxy *nsp;",
            "\tstruct task_struct *tsk;",
            "",
            "\t/* Take a \"snapshot\" of the target task's namespaces. */",
            "\trcu_read_lock();",
            "\ttsk = pid_task(pid, PIDTYPE_PID);",
            "\tif (!tsk) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "\tif (!ptrace_may_access(tsk, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\ttask_lock(tsk);",
            "\tnsp = tsk->nsproxy;",
            "\tif (nsp)",
            "\t\tget_nsproxy(nsp);",
            "\ttask_unlock(tsk);",
            "\tif (!nsp) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "#ifdef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID) {",
            "\t\tpid_ns = task_active_pid_ns(tsk);",
            "\t\tif (unlikely(!pid_ns)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tret = -ESRCH;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tget_pid_ns(pid_ns);",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tuser_ns = get_user_ns(__task_cred(tsk)->user_ns);",
            "#endif",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Install requested namespaces. The caller will have",
            "\t * verified earlier that the requested namespaces are",
            "\t * supported on this kernel. We don't report errors here",
            "\t * if a namespace is requested that isn't supported.",
            "\t */",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER) {",
            "\t\tret = validate_ns(nsset, &user_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "\tif (flags & CLONE_NEWNS) {",
            "\t\tret = validate_ns(nsset, from_mnt_ns(nsp->mnt_ns));",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "#ifdef CONFIG_UTS_NS",
            "\tif (flags & CLONE_NEWUTS) {",
            "\t\tret = validate_ns(nsset, &nsp->uts_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC) {",
            "\t\tret = validate_ns(nsset, &nsp->ipc_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID) {",
            "\t\tret = validate_ns(nsset, &pid_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_CGROUPS",
            "\tif (flags & CLONE_NEWCGROUP) {",
            "\t\tret = validate_ns(nsset, &nsp->cgroup_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_NET_NS",
            "\tif (flags & CLONE_NEWNET) {",
            "\t\tret = validate_ns(nsset, &nsp->net_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME) {",
            "\t\tret = validate_ns(nsset, &nsp->time_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "out:",
            "\tif (pid_ns)",
            "\t\tput_pid_ns(pid_ns);",
            "\tif (nsp)",
            "\t\tput_nsproxy(nsp);",
            "\tput_user_ns(user_ns);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "check_setns_flags, put_nsset, prepare_nsset, validate_ns, validate_nsset",
          "description": "提供命名空间集合的校验与准备逻辑，check_setns_flags验证标志位有效性，prepare_nsset构建临时命名空间集，validate_nsset检查目标命名空间权限和可用性，确保安全操作",
          "similarity": 0.48991239070892334
        }
      ]
    },
    {
      "source_file": "mm/vmalloc.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:32:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `vmalloc.c`\n\n---\n\n# vmalloc.c 技术文档\n\n## 1. 文件概述\n\n`vmalloc.c` 是 Linux 内核中实现虚拟内存分配（vmalloc）机制的核心源文件。该文件提供了在内核虚拟地址空间中非连续物理页映射为连续虚拟地址的功能，主要用于分配大块内存、I/O 映射（如 `ioremap`）以及需要页表特殊属性（如不可执行、缓存控制等）的场景。与 `kmalloc` 不同，`vmalloc` 分配的内存物理上不连续，但虚拟地址连续，适用于大内存分配或硬件寄存器映射。\n\n## 2. 核心功能\n\n### 主要函数\n- `is_vmalloc_addr(const void *x)`：判断给定地址是否位于 vmalloc 区域。\n- `vmap_page_range(unsigned long addr, unsigned long end, phys_addr_t phys_addr, pgprot_t prot)`：将指定物理地址范围映射到内核虚拟地址空间，支持普通页和大页。\n- `ioremap_page_range(...)`：用于 I/O 内存重映射（代码片段未完整展示）。\n- `vmap_range_noflush(...)`：执行实际的页表填充操作，不触发 TLB 刷新。\n- `vmap_pte_range`, `vmap_pmd_range`, `vmap_pud_range`, `vmap_p4d_range`：逐级填充页表项的辅助函数。\n- `vmap_try_huge_*` 系列函数（如 `vmap_try_huge_pmd`）：尝试使用大页（huge page）进行映射以提升性能。\n\n### 主要数据结构\n- `struct vfree_deferred`：用于延迟释放 vmalloc 内存的 per-CPU 工作队列结构。\n- `ioremap_max_page_shift`：控制 I/O 映射时允许的最大页面大小（受 `nohugeiomap` 启动参数影响）。\n- `vmap_allow_huge`：控制 vmalloc 是否允许使用大页（受 `nohugevmalloc` 启动参数影响）。\n\n## 3. 关键实现\n\n### 大页（Huge Page）支持\n- 通过 `CONFIG_HAVE_ARCH_HUGE_VMAP` 和 `CONFIG_HAVE_ARCH_HUGE_VMALLOC` 配置选项启用架构相关的大页映射能力。\n- 在页表填充过程中（如 `vmap_pmd_range`），优先尝试使用 PMD/PUD/P4D 级别的大页映射（通过 `vmap_try_huge_pmd` 等函数），前提是：\n  - 地址和物理地址对齐；\n  - 请求区域大小等于对应层级的大页尺寸；\n  - 架构支持该级别的大页（通过 `arch_vmap_*_supported` 判断）；\n  - 当前页表项未被占用或可安全释放下级页表。\n- 启动参数 `nohugeiomap` 和 `nohugevmalloc` 可分别禁用 I/O 映射和通用 vmalloc 的大页功能。\n\n### 页表操作与跟踪\n- 使用 `_track` 后缀的页表分配函数（如 `pte_alloc_kernel_track`）配合 `pgtbl_mod_mask` 标记修改的页表层级，便于后续同步（如 `arch_sync_kernel_mappings`）。\n- 映射完成后调用 `flush_cache_vmap` 确保缓存一致性，并集成 KMSAN（Kernel Memory Sanitizer）支持。\n\n### 安全与调试\n- 使用 `kasan_reset_tag` 处理 KASAN 的内存标记，确保地址比较正确。\n- 通过 `BUG_ON` 检查页表项是否为空，防止覆盖已有映射。\n- 支持 `kmemleak` 内存泄漏检测。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `<linux/mm.h>`、`<linux/highmem.h>`、`<linux/pfn.h>` 等提供基础内存操作。\n- **体系结构相关接口**：通过 `asm/tlbflush.h`、`asm/shmparam.h` 及 `arch_*` 函数（如 `arch_make_huge_pte`）适配不同 CPU 架构。\n- **内核基础设施**：\n  - RCU（`<linux/rcupdate.h>`）用于安全遍历；\n  - Per-CPU 变量（`DEFINE_PER_CPU`）实现无锁延迟释放；\n  - 工作队列（`work_struct`）处理异步释放；\n  - 调试工具（`debugobjects`、`kallsyms`、`trace/events/vmalloc.h`）。\n- **安全特性**：集成 KASAN、KMSAN、`set_memory.h`（页属性设置）等。\n\n## 5. 使用场景\n\n- **内核模块加载**：模块的代码和数据通常通过 `vmalloc` 分配。\n- **大内存分配**：当所需内存超过 `kmalloc` 的限制（通常几 MB）时使用。\n- **设备 I/O 映射**：通过 `ioremap` 将设备寄存器映射到内核地址空间，底层调用 `ioremap_page_range`。\n- **动态内核数据结构**：如网络协议栈的某些缓冲区、文件系统元数据缓存等。\n- **安全隔离**：为敏感数据分配具有特殊页属性（如不可执行 NX）的内存区域。",
      "similarity": 0.6102470755577087,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/vmalloc.c",
          "start_line": 1,
          "end_line": 54,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  Copyright (C) 1993  Linus Torvalds",
            " *  Support of BIGMEM added by Gerhard Wichert, Siemens AG, July 1999",
            " *  SMP-safe vmalloc/vfree/ioremap, Tigran Aivazian <tigran@veritas.com>, May 2000",
            " *  Major rework to support vmap/vunmap, Christoph Hellwig, SGI, August 2002",
            " *  Numa awareness, Christoph Lameter, SGI, June 2005",
            " *  Improving global KVA allocator, Uladzislau Rezki, Sony, May 2019",
            " */",
            "",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xarray.h>",
            "#include <linux/io.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pfn.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/atomic.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/llist.h>",
            "#include <linux/uio.h>",
            "#include <linux/bitops.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/overflow.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/shmparam.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/vmalloc.h>",
            "",
            "#include \"internal.h\"",
            "#include \"pgalloc-track.h\"",
            "",
            "#ifdef CONFIG_HAVE_ARCH_HUGE_VMAP",
            "static unsigned int __ro_after_init ioremap_max_page_shift = BITS_PER_LONG - 1;",
            ""
          ],
          "function_name": null,
          "description": "包含虚拟内存分配所需头文件并定义了用于控制巨页（Huge Page）大小的全局变量ioremap_max_page_shift，为后续虚拟内存管理和大页支持提供基础框架。",
          "similarity": 0.5782058835029602
        },
        {
          "chunk_id": 20,
          "file_path": "mm/vmalloc.c",
          "start_line": 4992,
          "end_line": 5118,
          "content": [
            "static int vmalloc_info_show(struct seq_file *m, void *p)",
            "{",
            "\tstruct vmap_node *vn;",
            "\tstruct vmap_area *va;",
            "\tstruct vm_struct *v;",
            "\tint i;",
            "\tunsigned int *counters;",
            "",
            "\tif (IS_ENABLED(CONFIG_NUMA))",
            "\t\tcounters = kmalloc(nr_node_ids * sizeof(unsigned int), GFP_KERNEL);",
            "",
            "\tfor (i = 0; i < nr_vmap_nodes; i++) {",
            "\t\tvn = &vmap_nodes[i];",
            "",
            "\t\tspin_lock(&vn->busy.lock);",
            "\t\tlist_for_each_entry(va, &vn->busy.head, list) {",
            "\t\t\tif (!va->vm) {",
            "\t\t\t\tif (va->flags & VMAP_RAM)",
            "\t\t\t\t\tseq_printf(m, \"0x%pK-0x%pK %7ld vm_map_ram\\n\",",
            "\t\t\t\t\t\t(void *)va->va_start, (void *)va->va_end,",
            "\t\t\t\t\t\tva_size(va));",
            "",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tv = va->vm;",
            "\t\t\tif (v->flags & VM_UNINITIALIZED)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\t/* Pair with smp_wmb() in clear_vm_uninitialized_flag() */",
            "\t\t\tsmp_rmb();",
            "",
            "\t\t\tseq_printf(m, \"0x%pK-0x%pK %7ld\",",
            "\t\t\t\tv->addr, v->addr + v->size, v->size);",
            "",
            "\t\t\tif (v->caller)",
            "\t\t\t\tseq_printf(m, \" %pS\", v->caller);",
            "",
            "\t\t\tif (v->nr_pages)",
            "\t\t\t\tseq_printf(m, \" pages=%d\", v->nr_pages);",
            "",
            "\t\t\tif (v->phys_addr)",
            "\t\t\t\tseq_printf(m, \" phys=%pa\", &v->phys_addr);",
            "",
            "\t\t\tif (v->flags & VM_IOREMAP)",
            "\t\t\t\tseq_puts(m, \" ioremap\");",
            "",
            "\t\t\tif (v->flags & VM_SPARSE)",
            "\t\t\t\tseq_puts(m, \" sparse\");",
            "",
            "\t\t\tif (v->flags & VM_ALLOC)",
            "\t\t\t\tseq_puts(m, \" vmalloc\");",
            "",
            "\t\t\tif (v->flags & VM_MAP)",
            "\t\t\t\tseq_puts(m, \" vmap\");",
            "",
            "\t\t\tif (v->flags & VM_USERMAP)",
            "\t\t\t\tseq_puts(m, \" user\");",
            "",
            "\t\t\tif (v->flags & VM_DMA_COHERENT)",
            "\t\t\t\tseq_puts(m, \" dma-coherent\");",
            "",
            "\t\t\tif (is_vmalloc_addr(v->pages))",
            "\t\t\t\tseq_puts(m, \" vpages\");",
            "",
            "\t\t\tif (IS_ENABLED(CONFIG_NUMA))",
            "\t\t\t\tshow_numa_info(m, v, counters);",
            "",
            "\t\t\tseq_putc(m, '\\n');",
            "\t\t}",
            "\t\tspin_unlock(&vn->busy.lock);",
            "\t}",
            "",
            "\t/*",
            "\t * As a final step, dump \"unpurged\" areas.",
            "\t */",
            "\tshow_purge_info(m);",
            "\tif (IS_ENABLED(CONFIG_NUMA))",
            "\t\tkfree(counters);",
            "\treturn 0;",
            "}",
            "static int __init proc_vmalloc_init(void)",
            "{",
            "\tproc_create_single(\"vmallocinfo\", 0400, NULL, vmalloc_info_show);",
            "\treturn 0;",
            "}",
            "static void __init vmap_init_free_space(void)",
            "{",
            "\tunsigned long vmap_start = 1;",
            "\tconst unsigned long vmap_end = ULONG_MAX;",
            "\tstruct vmap_area *free;",
            "\tstruct vm_struct *busy;",
            "",
            "\t/*",
            "\t *     B     F     B     B     B     F",
            "\t * -|-----|.....|-----|-----|-----|.....|-",
            "\t *  |           The KVA space           |",
            "\t *  |<--------------------------------->|",
            "\t */",
            "\tfor (busy = vmlist; busy; busy = busy->next) {",
            "\t\tif ((unsigned long) busy->addr - vmap_start > 0) {",
            "\t\t\tfree = kmem_cache_zalloc(vmap_area_cachep, GFP_NOWAIT);",
            "\t\t\tif (!WARN_ON_ONCE(!free)) {",
            "\t\t\t\tfree->va_start = vmap_start;",
            "\t\t\t\tfree->va_end = (unsigned long) busy->addr;",
            "",
            "\t\t\t\tinsert_vmap_area_augment(free, NULL,",
            "\t\t\t\t\t&free_vmap_area_root,",
            "\t\t\t\t\t\t&free_vmap_area_list);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tvmap_start = (unsigned long) busy->addr + busy->size;",
            "\t}",
            "",
            "\tif (vmap_end - vmap_start > 0) {",
            "\t\tfree = kmem_cache_zalloc(vmap_area_cachep, GFP_NOWAIT);",
            "\t\tif (!WARN_ON_ONCE(!free)) {",
            "\t\t\tfree->va_start = vmap_start;",
            "\t\t\tfree->va_end = vmap_end;",
            "",
            "\t\t\tinsert_vmap_area_augment(free, NULL,",
            "\t\t\t\t&free_vmap_area_root,",
            "\t\t\t\t\t&free_vmap_area_list);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "vmalloc_info_show, proc_vmalloc_init, vmap_init_free_space",
          "description": "该代码段主要实现对虚拟内存分配（vmalloc）区域及空闲空间的管理和展示。`vmalloc_info_show`函数遍历所有vmap_area节点，输出当前活动的vmalloc区域及其属性（如物理地址、页数、标志位等），并支持NUMA架构下的统计信息；`proc_vmalloc_init`注册 `/proc/vmallocinfo` 接口以暴露该信息；`vmap_init_free_space`初始化并记录未被占用的虚拟地址空间，供后续分配使用。注：`show_numa_info` 等辅助函数未在片段中定义，需结合上下文确认完整性。",
          "similarity": 0.558915376663208
        },
        {
          "chunk_id": 7,
          "file_path": "mm/vmalloc.c",
          "start_line": 1208,
          "end_line": 1309,
          "content": [
            "static __always_inline void",
            "link_va(struct vmap_area *va, struct rb_root *root,",
            "\tstruct rb_node *parent, struct rb_node **link,",
            "\tstruct list_head *head)",
            "{",
            "\t__link_va(va, root, parent, link, head, false);",
            "}",
            "static __always_inline void",
            "link_va_augment(struct vmap_area *va, struct rb_root *root,",
            "\tstruct rb_node *parent, struct rb_node **link,",
            "\tstruct list_head *head)",
            "{",
            "\t__link_va(va, root, parent, link, head, true);",
            "}",
            "static __always_inline void",
            "__unlink_va(struct vmap_area *va, struct rb_root *root, bool augment)",
            "{",
            "\tif (WARN_ON(RB_EMPTY_NODE(&va->rb_node)))",
            "\t\treturn;",
            "",
            "\tif (augment)",
            "\t\trb_erase_augmented(&va->rb_node,",
            "\t\t\troot, &free_vmap_area_rb_augment_cb);",
            "\telse",
            "\t\trb_erase(&va->rb_node, root);",
            "",
            "\tlist_del_init(&va->list);",
            "\tRB_CLEAR_NODE(&va->rb_node);",
            "}",
            "static __always_inline void",
            "unlink_va(struct vmap_area *va, struct rb_root *root)",
            "{",
            "\t__unlink_va(va, root, false);",
            "}",
            "static __always_inline void",
            "unlink_va_augment(struct vmap_area *va, struct rb_root *root)",
            "{",
            "\t__unlink_va(va, root, true);",
            "}",
            "static __always_inline unsigned long",
            "compute_subtree_max_size(struct vmap_area *va)",
            "{",
            "\treturn max3(va_size(va),",
            "\t\tget_subtree_max_size(va->rb_node.rb_left),",
            "\t\tget_subtree_max_size(va->rb_node.rb_right));",
            "}",
            "static void",
            "augment_tree_propagate_check(void)",
            "{",
            "\tstruct vmap_area *va;",
            "\tunsigned long computed_size;",
            "",
            "\tlist_for_each_entry(va, &free_vmap_area_list, list) {",
            "\t\tcomputed_size = compute_subtree_max_size(va);",
            "\t\tif (computed_size != va->subtree_max_size)",
            "\t\t\tpr_emerg(\"tree is corrupted: %lu, %lu\\n\",",
            "\t\t\t\tva_size(va), va->subtree_max_size);",
            "\t}",
            "}",
            "static __always_inline void",
            "augment_tree_propagate_from(struct vmap_area *va)",
            "{",
            "\t/*",
            "\t * Populate the tree from bottom towards the root until",
            "\t * the calculated maximum available size of checked node",
            "\t * is equal to its current one.",
            "\t */",
            "\tfree_vmap_area_rb_augment_cb_propagate(&va->rb_node, NULL);",
            "",
            "#if DEBUG_AUGMENT_PROPAGATE_CHECK",
            "\taugment_tree_propagate_check();",
            "#endif",
            "}",
            "static void",
            "insert_vmap_area(struct vmap_area *va,",
            "\tstruct rb_root *root, struct list_head *head)",
            "{",
            "\tstruct rb_node **link;",
            "\tstruct rb_node *parent;",
            "",
            "\tlink = find_va_links(va, root, NULL, &parent);",
            "\tif (link)",
            "\t\tlink_va(va, root, parent, link, head);",
            "}",
            "static void",
            "insert_vmap_area_augment(struct vmap_area *va,",
            "\tstruct rb_node *from, struct rb_root *root,",
            "\tstruct list_head *head)",
            "{",
            "\tstruct rb_node **link;",
            "\tstruct rb_node *parent;",
            "",
            "\tif (from)",
            "\t\tlink = find_va_links(va, NULL, from, &parent);",
            "\telse",
            "\t\tlink = find_va_links(va, root, NULL, &parent);",
            "",
            "\tif (link) {",
            "\t\tlink_va_augment(va, root, parent, link, head);",
            "\t\taugment_tree_propagate_from(va);",
            "\t}",
            "}"
          ],
          "function_name": "link_va, link_va_augment, __unlink_va, unlink_va, unlink_va_augment, compute_subtree_max_size, augment_tree_propagate_check, augment_tree_propagate_from, insert_vmap_area, insert_vmap_area_augment",
          "description": "实现基于红黑树的虚拟内存区域动态管理，包含节点插入/删除、子树最大尺寸计算及传播机制，确保树结构平衡性与查询效率",
          "similarity": 0.5572237968444824
        },
        {
          "chunk_id": 4,
          "file_path": "mm/vmalloc.c",
          "start_line": 434,
          "end_line": 537,
          "content": [
            "void __vunmap_range_noflush(unsigned long start, unsigned long end)",
            "{",
            "\tunsigned long next;",
            "\tpgd_t *pgd;",
            "\tunsigned long addr = start;",
            "\tpgtbl_mod_mask mask = 0;",
            "",
            "\tBUG_ON(addr >= end);",
            "\tpgd = pgd_offset_k(addr);",
            "\tdo {",
            "\t\tnext = pgd_addr_end(addr, end);",
            "\t\tif (pgd_bad(*pgd))",
            "\t\t\tmask |= PGTBL_PGD_MODIFIED;",
            "\t\tif (pgd_none_or_clear_bad(pgd))",
            "\t\t\tcontinue;",
            "\t\tvunmap_p4d_range(pgd, addr, next, &mask);",
            "\t} while (pgd++, addr = next, addr != end);",
            "",
            "\tif (mask & ARCH_PAGE_TABLE_SYNC_MASK)",
            "\t\tarch_sync_kernel_mappings(start, end);",
            "}",
            "void vunmap_range_noflush(unsigned long start, unsigned long end)",
            "{",
            "\tkmsan_vunmap_range_noflush(start, end);",
            "\t__vunmap_range_noflush(start, end);",
            "}",
            "void vunmap_range(unsigned long addr, unsigned long end)",
            "{",
            "\tflush_cache_vunmap(addr, end);",
            "\tvunmap_range_noflush(addr, end);",
            "\tflush_tlb_kernel_range(addr, end);",
            "}",
            "static int vmap_pages_pte_range(pmd_t *pmd, unsigned long addr,",
            "\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr,",
            "\t\tpgtbl_mod_mask *mask)",
            "{",
            "\tint err = 0;",
            "\tpte_t *pte;",
            "",
            "\t/*",
            "\t * nr is a running index into the array which helps higher level",
            "\t * callers keep track of where we're up to.",
            "\t */",
            "",
            "\tpte = pte_alloc_kernel_track(pmd, addr, mask);",
            "\tif (!pte)",
            "\t\treturn -ENOMEM;",
            "\tdo {",
            "\t\tstruct page *page = pages[*nr];",
            "",
            "\t\tif (WARN_ON(!pte_none(ptep_get(pte)))) {",
            "\t\t\terr = -EBUSY;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (WARN_ON(!page)) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (WARN_ON(!pfn_valid(page_to_pfn(page)))) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tset_pte_at(&init_mm, addr, pte, mk_pte(page, prot));",
            "\t\t(*nr)++;",
            "\t} while (pte++, addr += PAGE_SIZE, addr != end);",
            "\t*mask |= PGTBL_PTE_MODIFIED;",
            "",
            "\treturn err;",
            "}",
            "static int vmap_pages_pmd_range(pud_t *pud, unsigned long addr,",
            "\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr,",
            "\t\tpgtbl_mod_mask *mask)",
            "{",
            "\tpmd_t *pmd;",
            "\tunsigned long next;",
            "",
            "\tpmd = pmd_alloc_track(&init_mm, pud, addr, mask);",
            "\tif (!pmd)",
            "\t\treturn -ENOMEM;",
            "\tdo {",
            "\t\tnext = pmd_addr_end(addr, end);",
            "\t\tif (vmap_pages_pte_range(pmd, addr, next, prot, pages, nr, mask))",
            "\t\t\treturn -ENOMEM;",
            "\t} while (pmd++, addr = next, addr != end);",
            "\treturn 0;",
            "}",
            "static int vmap_pages_pud_range(p4d_t *p4d, unsigned long addr,",
            "\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr,",
            "\t\tpgtbl_mod_mask *mask)",
            "{",
            "\tpud_t *pud;",
            "\tunsigned long next;",
            "",
            "\tpud = pud_alloc_track(&init_mm, p4d, addr, mask);",
            "\tif (!pud)",
            "\t\treturn -ENOMEM;",
            "\tdo {",
            "\t\tnext = pud_addr_end(addr, end);",
            "\t\tif (vmap_pages_pmd_range(pud, addr, next, prot, pages, nr, mask))",
            "\t\t\treturn -ENOMEM;",
            "\t} while (pud++, addr = next, addr != end);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__vunmap_range_noflush, vunmap_range_noflush, vunmap_range, vmap_pages_pte_range, vmap_pages_pmd_range, vmap_pages_pud_range",
          "description": "提供了基于页面对象数组的虚拟内存映射实现，包含页表项填充与清除逻辑，支持通过struct page直接映射物理页面并维护页表修改标记。",
          "similarity": 0.552283525466919
        },
        {
          "chunk_id": 1,
          "file_path": "mm/vmalloc.c",
          "start_line": 55,
          "end_line": 174,
          "content": [
            "static int __init set_nohugeiomap(char *str)",
            "{",
            "\tioremap_max_page_shift = PAGE_SHIFT;",
            "\treturn 0;",
            "}",
            "static int __init set_nohugevmalloc(char *str)",
            "{",
            "\tvmap_allow_huge = false;",
            "\treturn 0;",
            "}",
            "bool is_vmalloc_addr(const void *x)",
            "{",
            "\tunsigned long addr = (unsigned long)kasan_reset_tag(x);",
            "",
            "\treturn addr >= VMALLOC_START && addr < VMALLOC_END;",
            "}",
            "static int vmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,",
            "\t\t\tphys_addr_t phys_addr, pgprot_t prot,",
            "\t\t\tunsigned int max_page_shift, pgtbl_mod_mask *mask)",
            "{",
            "\tpte_t *pte;",
            "\tu64 pfn;",
            "\tunsigned long size = PAGE_SIZE;",
            "",
            "\tpfn = phys_addr >> PAGE_SHIFT;",
            "\tpte = pte_alloc_kernel_track(pmd, addr, mask);",
            "\tif (!pte)",
            "\t\treturn -ENOMEM;",
            "\tdo {",
            "\t\tBUG_ON(!pte_none(ptep_get(pte)));",
            "",
            "#ifdef CONFIG_HUGETLB_PAGE",
            "\t\tsize = arch_vmap_pte_range_map_size(addr, end, pfn, max_page_shift);",
            "\t\tif (size != PAGE_SIZE) {",
            "\t\t\tpte_t entry = pfn_pte(pfn, prot);",
            "",
            "\t\t\tentry = arch_make_huge_pte(entry, ilog2(size), 0);",
            "\t\t\tset_huge_pte_at(&init_mm, addr, pte, entry, size);",
            "\t\t\tpfn += PFN_DOWN(size);",
            "\t\t\tcontinue;",
            "\t\t}",
            "#endif",
            "\t\tset_pte_at(&init_mm, addr, pte, pfn_pte(pfn, prot));",
            "\t\tpfn++;",
            "\t} while (pte += PFN_DOWN(size), addr += size, addr != end);",
            "\t*mask |= PGTBL_PTE_MODIFIED;",
            "\treturn 0;",
            "}",
            "static int vmap_try_huge_pmd(pmd_t *pmd, unsigned long addr, unsigned long end,",
            "\t\t\tphys_addr_t phys_addr, pgprot_t prot,",
            "\t\t\tunsigned int max_page_shift)",
            "{",
            "\tif (max_page_shift < PMD_SHIFT)",
            "\t\treturn 0;",
            "",
            "\tif (!arch_vmap_pmd_supported(prot))",
            "\t\treturn 0;",
            "",
            "\tif ((end - addr) != PMD_SIZE)",
            "\t\treturn 0;",
            "",
            "\tif (!IS_ALIGNED(addr, PMD_SIZE))",
            "\t\treturn 0;",
            "",
            "\tif (!IS_ALIGNED(phys_addr, PMD_SIZE))",
            "\t\treturn 0;",
            "",
            "\tif (pmd_present(*pmd) && !pmd_free_pte_page(pmd, addr))",
            "\t\treturn 0;",
            "",
            "\treturn pmd_set_huge(pmd, phys_addr, prot);",
            "}",
            "static int vmap_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,",
            "\t\t\tphys_addr_t phys_addr, pgprot_t prot,",
            "\t\t\tunsigned int max_page_shift, pgtbl_mod_mask *mask)",
            "{",
            "\tpmd_t *pmd;",
            "\tunsigned long next;",
            "",
            "\tpmd = pmd_alloc_track(&init_mm, pud, addr, mask);",
            "\tif (!pmd)",
            "\t\treturn -ENOMEM;",
            "\tdo {",
            "\t\tnext = pmd_addr_end(addr, end);",
            "",
            "\t\tif (vmap_try_huge_pmd(pmd, addr, next, phys_addr, prot,",
            "\t\t\t\t\tmax_page_shift)) {",
            "\t\t\t*mask |= PGTBL_PMD_MODIFIED;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (vmap_pte_range(pmd, addr, next, phys_addr, prot, max_page_shift, mask))",
            "\t\t\treturn -ENOMEM;",
            "\t} while (pmd++, phys_addr += (next - addr), addr = next, addr != end);",
            "\treturn 0;",
            "}",
            "static int vmap_try_huge_pud(pud_t *pud, unsigned long addr, unsigned long end,",
            "\t\t\tphys_addr_t phys_addr, pgprot_t prot,",
            "\t\t\tunsigned int max_page_shift)",
            "{",
            "\tif (max_page_shift < PUD_SHIFT)",
            "\t\treturn 0;",
            "",
            "\tif (!arch_vmap_pud_supported(prot))",
            "\t\treturn 0;",
            "",
            "\tif ((end - addr) != PUD_SIZE)",
            "\t\treturn 0;",
            "",
            "\tif (!IS_ALIGNED(addr, PUD_SIZE))",
            "\t\treturn 0;",
            "",
            "\tif (!IS_ALIGNED(phys_addr, PUD_SIZE))",
            "\t\treturn 0;",
            "",
            "\tif (pud_present(*pud) && !pud_free_pmd_page(pud, addr))",
            "\t\treturn 0;",
            "",
            "\treturn pud_set_huge(pud, phys_addr, prot);",
            "}"
          ],
          "function_name": "set_nohugeiomap, set_nohugevmalloc, is_vmalloc_addr, vmap_pte_range, vmap_try_huge_pmd, vmap_pmd_range, vmap_try_huge_pud",
          "description": "实现了巨页兼容性配置参数设置、地址有效性判断及多级页表的大页映射逻辑，尝试通过huge pte/pmd/pud/p4d方式优化连续物理内存的虚拟映射效率。",
          "similarity": 0.5496194362640381
        }
      ]
    }
  ]
}