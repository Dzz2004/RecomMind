{
  "query": "系统调用 进程记账 实现方式",
  "timestamp": "2025-12-26 14:34:19",
  "retrieved_files": [
    {
      "source_file": "kernel/acct.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:48:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `acct.c`\n\n---\n\n# Linux 内核进程记账模块（acct.c）技术文档\n\n## 1. 文件概述\n\n`acct.c` 实现了 BSD 风格的 Linux 进程记账（Process Accounting）功能。当任意进程退出时，内核会向通过 `acct()` 系统调用指定的文件中写入一条类型为 `struct acct` 的记账记录。该模块仅负责生成原始记账数据，具体的数据分析和处理由用户空间程序完成。此功能可用于系统资源使用审计、用户行为追踪和性能分析等场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bsd_acct_struct`**：进程记账核心控制结构\n  - `pin`：文件系统 pin 机制，防止记账文件被意外卸载\n  - `count`：引用计数，用于安全释放资源\n  - `active`：记账功能是否处于激活状态\n  - `check_space`：是否启用磁盘空间检查\n  - `needcheck`：下次磁盘空间检查的时间点\n  - `file`：记账文件的 file 结构指针\n  - `ns`：关联的 PID 命名空间\n  - `work`：用于异步关闭记账文件的工作队列\n  - `ac`：实际的记账数据结构（`acct_t` 类型）\n\n### 主要函数\n\n- **`acct_on()`**：启用进程记账功能，打开指定文件并初始化记账结构\n- **`check_free_space()`**：检查磁盘剩余空间，根据阈值暂停或恢复记账\n- **`acct_pin_kill()`**：安全关闭记账功能，处理资源清理\n- **`close_work()`**：工作队列回调函数，异步执行记账文件关闭操作\n- **`acct_get()`**：获取当前命名空间的记账结构，带引用计数管理\n- **`acct_put()`**：减少记账结构引用计数，必要时释放内存\n- **`fill_ac()`** 和 **`acct_write_process()`**：填充和写入进程记账记录（声明但未在提供的代码片段中实现）\n\n### 系统参数\n\n- **`acct_parm[3]`**：记账系统控制参数数组\n  - `acct_parm[0]`（RESUME）：磁盘剩余空间百分比阈值，超过此值恢复记账\n  - `acct_parm[1]`（SUSPEND）：磁盘剩余空间百分比阈值，低于此值暂停记账  \n  - `acct_parm[2]`（ACCT_TIMEOUT）：磁盘空间检查间隔时间（秒）\n\n## 3. 关键实现\n\n### 磁盘空间监控机制\n\n记账系统实现了智能的磁盘空间管理：\n- 当可用磁盘空间低于 `SUSPEND` 百分比时，自动暂停记账以避免填满磁盘\n- 当可用磁盘空间恢复到 `RESUME` 百分比以上时，自动恢复记账\n- 通过 `needcheck` 字段控制检查频率，避免频繁的磁盘 I/O 操作\n\n### 资源安全管理和并发控制\n\n- **引用计数机制**：使用 `atomic_long_t count` 确保记账结构在多线程环境下的安全访问和释放\n- **RCU 读取优化**：通过 RCU 机制实现高效的记账结构读取，减少锁竞争\n- **互斥锁保护**：`mutex lock` 保护关键操作，防止竞态条件\n- **文件系统 pin 机制**：防止记账文件所在的文件系统被意外卸载\n\n### 异步关闭机制\n\n- 使用工作队列（`work_struct`）异步处理记账文件关闭操作\n- 通过 `completion` 机制确保关闭操作完成后再释放资源\n- 在关闭前调用文件操作的 `flush` 方法确保数据写入磁盘\n\n### 安全性和验证\n\n- 验证目标文件必须是普通文件（`S_ISREG`）\n- 排除内核内部文件系统（`SB_NOUSER | SB_KERNMOUNT`）\n- 排除特殊文件系统如 procfs 和 sysfs（`SB_I_USERNS_VISIBLE`）\n- 验证文件必须具有写权限（`FMODE_CAN_WRITE`）\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n\n- **内存管理**：`<linux/mm.h>`, `<linux/slab.h>`\n- **文件系统**：`<linux/vfs.h>`, `<linux/file.h>`, `<linux/mount.h>`, `<linux/fs_pin.h>`\n- **进程管理**：`<linux/sched/cputime.h>`, `<linux/pid_namespace.h>`\n- **系统调用**：`<linux/syscalls.h>`, `<linux/uaccess.h>`\n- **安全机制**：`<linux/capability.h>`, `<linux/security.h>`\n- **设备支持**：`<linux/tty.h>`\n- **时间管理**：`<linux/jiffies.h>`, `<linux/times.h>`\n\n### 内核子系统交互\n\n- **VFS 层**：通过标准 VFS 接口进行文件操作和文件系统状态查询\n- **内存管理子系统**：使用 slab 分配器分配记账结构内存\n- **工作队列子系统**：利用内核工作队列处理异步关闭操作\n- **RCU 机制**：使用 RCU 进行无锁读取操作\n- **sysctl 接口**：提供运行时可调参数（当 `CONFIG_SYSCTL` 启用时）\n\n## 5. 使用场景\n\n### 系统管理员监控\n\n- 通过 `acct()` 系统调用启用进程记账，收集系统中所有进程的执行信息\n- 分析用户资源使用情况，识别异常进程行为\n- 监控系统负载和进程执行模式\n\n### 安全审计\n\n- 记录所有进程的执行历史，包括命令名、执行时间、资源消耗等\n- 用于事后安全事件分析和取证\n- 检测未授权的程序执行\n\n### 性能分析\n\n- 收集进程 CPU 时间、内存使用、I/O 操作等性能指标\n- 分析系统资源瓶颈和优化机会\n- 监控长时间运行的进程资源消耗趋势\n\n### 容器环境支持\n\n- 通过 PID 命名空间隔离，支持容器级别的进程记账\n- 每个命名空间可以独立配置记账文件和参数\n- 为容器监控和计费提供基础数据支持",
      "similarity": 0.6737982630729675,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/acct.c",
          "start_line": 544,
          "end_line": 644,
          "content": [
            "static void acct_write_process(struct bsd_acct_struct *acct)",
            "{",
            "\tstruct file *file = acct->file;",
            "\tconst struct cred *cred;",
            "\tacct_t *ac = &acct->ac;",
            "",
            "\t/* Perform file operations on behalf of whoever enabled accounting */",
            "\tcred = override_creds(file->f_cred);",
            "",
            "\t/*",
            "\t * First check to see if there is enough free_space to continue",
            "\t * the process accounting system. Then get freeze protection. If",
            "\t * the fs is frozen, just skip the write as we could deadlock",
            "\t * the system otherwise.",
            "\t */",
            "\tif (check_free_space(acct) && file_start_write_trylock(file)) {",
            "\t\t/* it's been opened O_APPEND, so position is irrelevant */",
            "\t\tloff_t pos = 0;",
            "\t\t__kernel_write(file, ac, sizeof(acct_t), &pos);",
            "\t\tfile_end_write(file);",
            "\t}",
            "",
            "\trevert_creds(cred);",
            "}",
            "static void do_acct_process(struct bsd_acct_struct *acct)",
            "{",
            "\tunsigned long flim;",
            "",
            "\t/* Accounting records are not subject to resource limits. */",
            "\tflim = rlimit(RLIMIT_FSIZE);",
            "\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;",
            "\tfill_ac(acct);",
            "\tacct_write_process(acct);",
            "\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;",
            "}",
            "void acct_collect(long exitcode, int group_dead)",
            "{",
            "\tstruct pacct_struct *pacct = &current->signal->pacct;",
            "\tu64 utime, stime;",
            "\tunsigned long vsize = 0;",
            "",
            "\tif (group_dead && current->mm) {",
            "\t\tstruct mm_struct *mm = current->mm;",
            "\t\tVMA_ITERATOR(vmi, mm, 0);",
            "\t\tstruct vm_area_struct *vma;",
            "",
            "\t\tmmap_read_lock(mm);",
            "\t\tfor_each_vma(vmi, vma)",
            "\t\t\tvsize += vma->vm_end - vma->vm_start;",
            "\t\tmmap_read_unlock(mm);",
            "\t}",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tif (group_dead)",
            "\t\tpacct->ac_mem = vsize / 1024;",
            "\tif (thread_group_leader(current)) {",
            "\t\tpacct->ac_exitcode = exitcode;",
            "\t\tif (current->flags & PF_FORKNOEXEC)",
            "\t\t\tpacct->ac_flag |= AFORK;",
            "\t}",
            "\tif (current->flags & PF_SUPERPRIV)",
            "\t\tpacct->ac_flag |= ASU;",
            "\tif (current->flags & PF_DUMPCORE)",
            "\t\tpacct->ac_flag |= ACORE;",
            "\tif (current->flags & PF_SIGNALED)",
            "\t\tpacct->ac_flag |= AXSIG;",
            "",
            "\ttask_cputime(current, &utime, &stime);",
            "\tpacct->ac_utime += utime;",
            "\tpacct->ac_stime += stime;",
            "\tpacct->ac_minflt += current->min_flt;",
            "\tpacct->ac_majflt += current->maj_flt;",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "}",
            "static void slow_acct_process(struct pid_namespace *ns)",
            "{",
            "\tfor ( ; ns; ns = ns->parent) {",
            "\t\tstruct bsd_acct_struct *acct = acct_get(ns);",
            "\t\tif (acct) {",
            "\t\t\tdo_acct_process(acct);",
            "\t\t\tmutex_unlock(&acct->lock);",
            "\t\t\tacct_put(acct);",
            "\t\t}",
            "\t}",
            "}",
            "void acct_process(void)",
            "{",
            "\tstruct pid_namespace *ns;",
            "",
            "\t/*",
            "\t * This loop is safe lockless, since current is still",
            "\t * alive and holds its namespace, which in turn holds",
            "\t * its parent.",
            "\t */",
            "\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {",
            "\t\tif (ns->bacct)",
            "\t\t\tbreak;",
            "\t}",
            "\tif (unlikely(ns))",
            "\t\tslow_acct_process(ns);",
            "}"
          ],
          "function_name": "acct_write_process, do_acct_process, acct_collect, slow_acct_process, acct_process",
          "description": "实现会计记录的实际写入流程、进程状态收集逻辑及跨命名空间的递归计账处理，包含资源限制绕过、线程组统计信息聚合和锁安全的遍历机制。",
          "similarity": 0.7061723470687866
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/acct.c",
          "start_line": 89,
          "end_line": 236,
          "content": [
            "static __init int kernel_acct_sysctls_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kern_acct_table);",
            "\treturn 0;",
            "}",
            "static bool check_free_space(struct bsd_acct_struct *acct)",
            "{",
            "\tstruct kstatfs sbuf;",
            "",
            "\tif (!acct->check_space)",
            "\t\treturn acct->active;",
            "",
            "\t/* May block */",
            "\tif (vfs_statfs(&acct->file->f_path, &sbuf))",
            "\t\treturn acct->active;",
            "",
            "\tif (acct->active) {",
            "\t\tu64 suspend = sbuf.f_blocks * SUSPEND;",
            "\t\tdo_div(suspend, 100);",
            "\t\tif (sbuf.f_bavail <= suspend) {",
            "\t\t\tacct->active = false;",
            "\t\t\tpr_info(\"Process accounting paused\\n\");",
            "\t\t}",
            "\t} else {",
            "\t\tu64 resume = sbuf.f_blocks * RESUME;",
            "\t\tdo_div(resume, 100);",
            "\t\tif (sbuf.f_bavail >= resume) {",
            "\t\t\tacct->active = true;",
            "\t\t\tpr_info(\"Process accounting resumed\\n\");",
            "\t\t}",
            "\t}",
            "",
            "\tacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;",
            "\treturn acct->active;",
            "}",
            "static void acct_put(struct bsd_acct_struct *p)",
            "{",
            "\tif (atomic_long_dec_and_test(&p->count))",
            "\t\tkfree_rcu(p, rcu);",
            "}",
            "static void acct_pin_kill(struct fs_pin *pin)",
            "{",
            "\tstruct bsd_acct_struct *acct = to_acct(pin);",
            "\tmutex_lock(&acct->lock);",
            "\t/*",
            "\t * Fill the accounting struct with the exiting task's info",
            "\t * before punting to the workqueue.",
            "\t */",
            "\tfill_ac(acct);",
            "\tschedule_work(&acct->work);",
            "\twait_for_completion(&acct->done);",
            "\tcmpxchg(&acct->ns->bacct, pin, NULL);",
            "\tmutex_unlock(&acct->lock);",
            "\tpin_remove(pin);",
            "\tacct_put(acct);",
            "}",
            "static void close_work(struct work_struct *work)",
            "{",
            "\tstruct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);",
            "\tstruct file *file = acct->file;",
            "",
            "\t/* We were fired by acct_pin_kill() which holds acct->lock. */",
            "\tacct_write_process(acct);",
            "\tif (file->f_op->flush)",
            "\t\tfile->f_op->flush(file, NULL);",
            "\t__fput_sync(file);",
            "\tcomplete(&acct->done);",
            "}",
            "static int acct_on(struct filename *pathname)",
            "{",
            "\tstruct file *file;",
            "\tstruct vfsmount *mnt, *internal;",
            "\tstruct pid_namespace *ns = task_active_pid_ns(current);",
            "\tstruct bsd_acct_struct *acct;",
            "\tstruct fs_pin *old;",
            "\tint err;",
            "",
            "\tacct = kzalloc(sizeof(struct bsd_acct_struct), GFP_KERNEL);",
            "\tif (!acct)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* Difference from BSD - they don't do O_APPEND */",
            "\tfile = file_open_name(pathname, O_WRONLY|O_APPEND|O_LARGEFILE, 0);",
            "\tif (IS_ERR(file)) {",
            "\t\tkfree(acct);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\tif (!S_ISREG(file_inode(file)->i_mode)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EACCES;",
            "\t}",
            "",
            "\t/* Exclude kernel kernel internal filesystems. */",
            "\tif (file_inode(file)->i_sb->s_flags & (SB_NOUSER | SB_KERNMOUNT)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* Exclude procfs and sysfs. */",
            "\tif (file_inode(file)->i_sb->s_iflags & SB_I_USERNS_VISIBLE) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (!(file->f_mode & FMODE_CAN_WRITE)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EIO;",
            "\t}",
            "\tinternal = mnt_clone_internal(&file->f_path);",
            "\tif (IS_ERR(internal)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn PTR_ERR(internal);",
            "\t}",
            "\terr = mnt_get_write_access(internal);",
            "\tif (err) {",
            "\t\tmntput(internal);",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn err;",
            "\t}",
            "\tmnt = file->f_path.mnt;",
            "\tfile->f_path.mnt = internal;",
            "",
            "\tatomic_long_set(&acct->count, 1);",
            "\tinit_fs_pin(&acct->pin, acct_pin_kill);",
            "\tacct->file = file;",
            "\tacct->needcheck = jiffies;",
            "\tacct->ns = ns;",
            "\tmutex_init(&acct->lock);",
            "\tINIT_WORK(&acct->work, close_work);",
            "\tinit_completion(&acct->done);",
            "\tmutex_lock_nested(&acct->lock, 1);\t/* nobody has seen it yet */",
            "\tpin_insert(&acct->pin, mnt);",
            "",
            "\trcu_read_lock();",
            "\told = xchg(&ns->bacct, &acct->pin);",
            "\tmutex_unlock(&acct->lock);",
            "\tpin_kill(old);",
            "\tmnt_put_write_access(mnt);",
            "\tmntput(mnt);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "kernel_acct_sysctls_init, check_free_space, acct_put, acct_pin_kill, close_work, acct_on",
          "description": "实现计账文件的空间检查逻辑、资源释放机制、文件句柄管理及计账开启流程，包含磁盘空间监控、文件操作封装和命名空间绑定等功能。",
          "similarity": 0.6481237411499023
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/acct.c",
          "start_line": 1,
          "end_line": 88,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  linux/kernel/acct.c",
            " *",
            " *  BSD Process Accounting for Linux",
            " *",
            " *  Author: Marco van Wieringen <mvw@planets.elm.net>",
            " *",
            " *  Some code based on ideas and code from:",
            " *  Thomas K. Dyas <tdyas@eden.rutgers.edu>",
            " *",
            " *  This file implements BSD-style process accounting. Whenever any",
            " *  process exits, an accounting record of type \"struct acct\" is",
            " *  written to the file specified with the acct() system call. It is",
            " *  up to user-level programs to do useful things with the accounting",
            " *  log. The kernel just provides the raw accounting information.",
            " *",
            " * (C) Copyright 1995 - 1997 Marco van Wieringen - ELM Consultancy B.V.",
            " *",
            " *  Plugged two leaks. 1) It didn't return acct_file into the free_filps if",
            " *  the file happened to be read-only. 2) If the accounting was suspended",
            " *  due to the lack of space it happily allowed to reopen it and completely",
            " *  lost the old acct_file. 3/10/98, Al Viro.",
            " *",
            " *  Now we silently close acct_file on attempt to reopen. Cleaned sys_acct().",
            " *  XTerms and EMACS are manifestations of pure evil. 21/10/98, AV.",
            " *",
            " *  Fixed a nasty interaction with sys_umount(). If the accounting",
            " *  was suspeneded we failed to stop it on umount(). Messy.",
            " *  Another one: remount to readonly didn't stop accounting.",
            " *\tQuestion: what should we do if we have CAP_SYS_ADMIN but not",
            " *  CAP_SYS_PACCT? Current code does the following: umount returns -EBUSY",
            " *  unless we are messing with the root. In that case we are getting a",
            " *  real mess with do_remount_sb(). 9/11/98, AV.",
            " *",
            " *  Fixed a bunch of races (and pair of leaks). Probably not the best way,",
            " *  but this one obviously doesn't introduce deadlocks. Later. BTW, found",
            " *  one race (and leak) in BSD implementation.",
            " *  OK, that's better. ANOTHER race and leak in BSD variant. There always",
            " *  is one more bug... 10/11/98, AV.",
            " *",
            " *\tOh, fsck... Oopsable SMP race in do_process_acct() - we must hold",
            " * ->mmap_lock to walk the vma list of current->mm. Nasty, since it leaks",
            " * a struct file opened for write. Fixed. 2/6/2000, AV.",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/capability.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/security.h>",
            "#include <linux/vfs.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/times.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/cputime.h>",
            "",
            "#include <asm/div64.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/fs_pin.h>",
            "",
            "/*",
            " * These constants control the amount of freespace that suspend and",
            " * resume the process accounting system, and the time delay between",
            " * each check.",
            " * Turned into sysctl-controllable parameters. AV, 12/11/98",
            " */",
            "",
            "static int acct_parm[3] = {4, 2, 30};",
            "#define RESUME\t\t(acct_parm[0])\t/* >foo% free space - resume */",
            "#define SUSPEND\t\t(acct_parm[1])\t/* <foo% free space - suspend */",
            "#define ACCT_TIMEOUT\t(acct_parm[2])\t/* foo second timeout between checks */",
            "",
            "#ifdef CONFIG_SYSCTL",
            "static struct ctl_table kern_acct_table[] = {",
            "\t{",
            "\t\t.procname       = \"acct\",",
            "\t\t.data           = &acct_parm,",
            "\t\t.maxlen         = 3*sizeof(int),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = proc_dointvec,",
            "\t},",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义BSD进程计账系统的常量和sysctl控制表，用于动态调整磁盘空间阈值和检查间隔，注册到内核sysctl接口以支持运行时配置。",
          "similarity": 0.6367899775505066
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/acct.c",
          "start_line": 338,
          "end_line": 498,
          "content": [
            "void acct_exit_ns(struct pid_namespace *ns)",
            "{",
            "\trcu_read_lock();",
            "\tpin_kill(ns->bacct);",
            "}",
            "static comp_t encode_comp_t(u64 value)",
            "{",
            "\tint exp, rnd;",
            "",
            "\texp = rnd = 0;",
            "\twhile (value > MAXFRACT) {",
            "\t\trnd = value & (1 << (EXPSIZE - 1));\t/* Round up? */",
            "\t\tvalue >>= EXPSIZE;\t/* Base 8 exponent == 3 bit shift. */",
            "\t\texp++;",
            "\t}",
            "",
            "\t/*",
            "\t * If we need to round up, do it (and handle overflow correctly).",
            "\t */",
            "\tif (rnd && (++value > MAXFRACT)) {",
            "\t\tvalue >>= EXPSIZE;",
            "\t\texp++;",
            "\t}",
            "",
            "\tif (exp > (((comp_t) ~0U) >> MANTSIZE))",
            "\t\treturn (comp_t) ~0U;",
            "\t/*",
            "\t * Clean it up and polish it off.",
            "\t */",
            "\texp <<= MANTSIZE;\t\t/* Shift the exponent into place */",
            "\texp += value;\t\t\t/* and add on the mantissa. */",
            "\treturn exp;",
            "}",
            "static comp2_t encode_comp2_t(u64 value)",
            "{",
            "\tint exp, rnd;",
            "",
            "\texp = (value > (MAXFRACT2>>1));",
            "\trnd = 0;",
            "\twhile (value > MAXFRACT2) {",
            "\t\trnd = value & 1;",
            "\t\tvalue >>= 1;",
            "\t\texp++;",
            "\t}",
            "",
            "\t/*",
            "\t * If we need to round up, do it (and handle overflow correctly).",
            "\t */",
            "\tif (rnd && (++value > MAXFRACT2)) {",
            "\t\tvalue >>= 1;",
            "\t\texp++;",
            "\t}",
            "",
            "\tif (exp > MAXEXP2) {",
            "\t\t/* Overflow. Return largest representable number instead. */",
            "\t\treturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;",
            "\t} else {",
            "\t\treturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));",
            "\t}",
            "}",
            "static u32 encode_float(u64 value)",
            "{",
            "\tunsigned exp = 190;",
            "\tunsigned u;",
            "",
            "\tif (value == 0)",
            "\t\treturn 0;",
            "\twhile ((s64)value > 0) {",
            "\t\tvalue <<= 1;",
            "\t\texp--;",
            "\t}",
            "\tu = (u32)(value >> 40) & 0x7fffffu;",
            "\treturn u | (exp << 23);",
            "}",
            "static void fill_ac(struct bsd_acct_struct *acct)",
            "{",
            "\tstruct pacct_struct *pacct = &current->signal->pacct;",
            "\tstruct file *file = acct->file;",
            "\tacct_t *ac = &acct->ac;",
            "\tu64 elapsed, run_time;",
            "\ttime64_t btime;",
            "\tstruct tty_struct *tty;",
            "",
            "\tlockdep_assert_held(&acct->lock);",
            "",
            "\tif (time_is_after_jiffies(acct->needcheck)) {",
            "\t\tacct->check_space = false;",
            "",
            "\t\t/* Don't fill in @ac if nothing will be written. */",
            "\t\tif (!acct->active)",
            "\t\t\treturn;",
            "\t} else {",
            "\t\tacct->check_space = true;",
            "\t}",
            "",
            "\t/*",
            "\t * Fill the accounting struct with the needed info as recorded",
            "\t * by the different kernel functions.",
            "\t */",
            "\tmemset(ac, 0, sizeof(acct_t));",
            "",
            "\tac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;",
            "\tstrscpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));",
            "",
            "\t/* calculate run_time in nsec*/",
            "\trun_time = ktime_get_ns();",
            "\trun_time -= current->group_leader->start_time;",
            "\t/* convert nsec -> AHZ */",
            "\telapsed = nsec_to_AHZ(run_time);",
            "#if ACCT_VERSION == 3",
            "\tac->ac_etime = encode_float(elapsed);",
            "#else",
            "\tac->ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?",
            "\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);",
            "#endif",
            "#if ACCT_VERSION == 1 || ACCT_VERSION == 2",
            "\t{",
            "\t\t/* new enlarged etime field */",
            "\t\tcomp2_t etime = encode_comp2_t(elapsed);",
            "",
            "\t\tac->ac_etime_hi = etime >> 16;",
            "\t\tac->ac_etime_lo = (u16) etime;",
            "\t}",
            "#endif",
            "\tdo_div(elapsed, AHZ);",
            "\tbtime = ktime_get_real_seconds() - elapsed;",
            "\tac->ac_btime = clamp_t(time64_t, btime, 0, U32_MAX);",
            "#if ACCT_VERSION == 2",
            "\tac->ac_ahz = AHZ;",
            "#endif",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\ttty = current->signal->tty;\t/* Safe as we hold the siglock */",
            "\tac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;",
            "\tac->ac_utime = encode_comp_t(nsec_to_AHZ(pacct->ac_utime));",
            "\tac->ac_stime = encode_comp_t(nsec_to_AHZ(pacct->ac_stime));",
            "\tac->ac_flag = pacct->ac_flag;",
            "\tac->ac_mem = encode_comp_t(pacct->ac_mem);",
            "\tac->ac_minflt = encode_comp_t(pacct->ac_minflt);",
            "\tac->ac_majflt = encode_comp_t(pacct->ac_majflt);",
            "\tac->ac_exitcode = pacct->ac_exitcode;",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\t/* we really need to bite the bullet and change layout */",
            "\tac->ac_uid = from_kuid_munged(file->f_cred->user_ns, current_uid());",
            "\tac->ac_gid = from_kgid_munged(file->f_cred->user_ns, current_gid());",
            "#if ACCT_VERSION == 1 || ACCT_VERSION == 2",
            "\t/* backward-compatible 16 bit fields */",
            "\tac->ac_uid16 = ac->ac_uid;",
            "\tac->ac_gid16 = ac->ac_gid;",
            "#elif ACCT_VERSION == 3",
            "\t{",
            "\t\tstruct pid_namespace *ns = acct->ns;",
            "",
            "\t\tac->ac_pid = task_tgid_nr_ns(current, ns);",
            "\t\trcu_read_lock();",
            "\t\tac->ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent), ns);",
            "\t\trcu_read_unlock();",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "acct_exit_ns, encode_comp_t, encode_comp2_t, encode_float, fill_ac",
          "description": "提供时间编码辅助函数和会计记录填充逻辑，实现不同版本会计结构的数据转换与字段填充，包含UID/GID映射和进程标识符获取等关键操作。",
          "similarity": 0.5994205474853516
        }
      ]
    },
    {
      "source_file": "kernel/tsacct.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:42:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `tsacct.c`\n\n---\n\n# tsacct.c 技术文档\n\n## 1. 文件概述\n\n`tsacct.c` 是 Linux 内核中实现任务统计（taskstats）接口下系统记账（accounting）功能的核心文件。它负责收集进程/任务的资源使用信息，包括基本记账（basic accounting）和扩展记账（extended accounting）两类数据。这些数据通过 `taskstats` 接口暴露给用户空间，用于系统监控、资源审计和性能分析等用途。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`bacct_add_tsk()`**  \n  填充任务的基本记账信息到 `struct taskstats` 结构体中，包括进程 ID、父进程 ID、用户/组 ID、CPU 时间、启动时间、退出码、调度策略、nice 值、缺页次数、命令名等。\n\n- **`xacct_add_tsk()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  填充任务的扩展记账信息，包括内存使用积分（RSS/VM）、I/O 字节数、系统调用次数等。\n\n- **`acct_update_integrals()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  在中断上下文中安全地更新任务的内存使用积分（RSS 和虚拟内存的时间积分）。\n\n- **`acct_account_cputime()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  在已知 CPU 时间更新后，直接调用内部函数更新内存积分，避免重复获取时间。\n\n- **`acct_clear_integrals()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  清除任务结构体中的内存积分字段，通常在进程创建或复用时调用。\n\n### 关键数据结构\n\n- **`struct taskstats`**  \n  用户空间通过 netlink 接口获取的统计信息结构体，包含 `ac_*` 前缀的各类记账字段。\n\n- **`struct task_struct` 中的扩展字段**（仅当 `CONFIG_TASK_XACCT` 启用时）：\n  - `acct_rss_mem1`：RSS 内存使用的时间积分（单位：页·纳秒 / 1024）\n  - `acct_vm_mem1`：虚拟内存使用的时间积分（单位：页·纳秒 / 1024）\n  - `acct_timexpd`：上次更新积分时的累计 CPU 时间（纳秒）\n\n## 3. 关键实现\n\n### 基本记账实现细节\n\n- **时间计算**：\n  - `ac_etime`：任务自启动以来的经过时间（微秒）。\n  - `ac_tgetime`：整个线程组自组长启动以来的经过时间（微秒）。\n  - `ac_btime` / `ac_btime64`：任务启动的绝对时间（Unix 时间戳），前者限制为 32 位以兼容旧接口。\n\n- **身份与关系信息**：\n  - 使用 `from_kuid_munged()` 和 `from_kgid_munged()` 将内核 UID/GID 映射到指定用户命名空间。\n  - 父进程 ID（`ac_ppid`）通过 RCU 读取 `real_parent`，并在进程已退出时设为 0。\n\n- **CPU 时间**：\n  - 使用 `task_cputime()` 获取任务及其子线程的累计用户态和内核态 CPU 时间（纳秒）。\n  - 同时提供原始时间和按 CPU 频率缩放后的时间（`ac_utimescaled` / `ac_stimescaled`）。\n\n- **退出与特权标志**：\n  - 根据任务标志（如 `PF_EXITING`、`PF_SUPERPRIV` 等）设置 `ac_flag` 中的对应位（`AXSIG`、`ASU` 等）。\n\n### 扩展记账实现细节（`CONFIG_TASK_XACCT`）\n\n- **内存积分算法**：\n  - 通过 `__acct_update_integrals()` 定期累积 `RSS × 时间` 和 `VM × 时间`。\n  - 积分单位为“页·纳秒”，右移 10 位（即除以 1024）防止溢出。\n  - 最终在 `xacct_add_tsk()` 中转换为 **MB·微秒**（通过 `PAGE_SIZE / (1000 * KB)`）。\n\n- **高水位内存统计**：\n  - 从 `mm_struct` 中获取历史最高 RSS 和 VM 值，并转换为 KB 单位。\n\n- **I/O 统计**：\n  - 从 `task_struct->ioac` 获取字符级和字节级的读写统计。\n  - 使用 `KB_MASK` 对结果向下对齐到 KB 边界（即清除低 10 位）。\n  - 若未启用 `CONFIG_TASK_IO_ACCOUNTING`，则 I/O 字节字段置零。\n\n- **中断安全更新**：\n  - `acct_update_integrals()` 使用 `local_irq_save/restore` 禁用本地中断，确保在中断上下文中安全更新。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/tsacct_kern.h>`：定义 `taskstats` 结构和相关接口。\n  - `<linux/acct.h>`：提供记账相关的常量和类型。\n  - `<linux/sched/*.h>`：访问任务调度、CPU 时间、凭证等信息。\n  - `<linux/mm.h>`：访问内存管理结构（如 `mm_struct`）。\n  - `<linux/jiffies.h>` 和 `<linux/kernel.h>`：时间转换和基础宏。\n\n- **配置依赖**：\n  - 基本记账功能始终编译。\n  - 扩展记账功能（`xacct_add_tsk` 及相关函数）依赖 `CONFIG_TASK_XACCT`。\n  - I/O 字节统计依赖 `CONFIG_TASK_IO_ACCOUNTING`。\n\n- **与其他子系统交互**：\n  - **调度子系统**：通过 `task_cputime()` 获取 CPU 时间。\n  - **内存管理子系统**：通过 `get_task_mm()` 和 `get_mm_hiwater_*` 获取内存使用情况。\n  - **用户命名空间**：通过 `user_ns` 参数进行 UID/GID 映射。\n  - **进程管理**：访问 `task_struct` 的各种字段（如 `start_time`、`exit_code`、`flags` 等）。\n\n## 5. 使用场景\n\n- **用户空间监控工具**：如 `nmon`、`atop`、`sadc` 等通过 taskstats netlink 接口获取进程资源使用详情。\n- **作业调度系统**：HPC 或容器平台（如 Slurm、Kubernetes）利用扩展记账数据进行资源配额和计费。\n- **系统审计**：记录进程的 CPU、内存、I/O 消耗，用于安全分析或性能瓶颈定位。\n- **内核自身记账**：在进程退出或通过 `TASKSTATS_CMD_ATTR_PID` 查询时，填充并返回 `taskstats` 数据。\n- **cgroup v1/v2 集成**：部分记账数据可被 cgroup 控制器复用或聚合。",
      "similarity": 0.6299216151237488,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/tsacct.c",
          "start_line": 20,
          "end_line": 133,
          "content": [
            "void bacct_add_tsk(struct user_namespace *user_ns,",
            "\t\t   struct pid_namespace *pid_ns,",
            "\t\t   struct taskstats *stats, struct task_struct *tsk)",
            "{",
            "\tconst struct cred *tcred;",
            "\tu64 utime, stime, utimescaled, stimescaled;",
            "\tu64 now_ns, delta;",
            "\ttime64_t btime;",
            "",
            "\tBUILD_BUG_ON(TS_COMM_LEN < TASK_COMM_LEN);",
            "",
            "\t/* calculate task elapsed time in nsec */",
            "\tnow_ns = ktime_get_ns();",
            "\t/* store whole group time first */",
            "\tdelta = now_ns - tsk->group_leader->start_time;",
            "\t/* Convert to micro seconds */",
            "\tdo_div(delta, NSEC_PER_USEC);",
            "\tstats->ac_tgetime = delta;",
            "\tdelta = now_ns - tsk->start_time;",
            "\tdo_div(delta, NSEC_PER_USEC);",
            "\tstats->ac_etime = delta;",
            "\t/* Convert to seconds for btime (note y2106 limit) */",
            "\tbtime = ktime_get_real_seconds() - div_u64(delta, USEC_PER_SEC);",
            "\tstats->ac_btime = clamp_t(time64_t, btime, 0, U32_MAX);",
            "\tstats->ac_btime64 = btime;",
            "",
            "\tif (tsk->flags & PF_EXITING)",
            "\t\tstats->ac_exitcode = tsk->exit_code;",
            "\tif (thread_group_leader(tsk) && (tsk->flags & PF_FORKNOEXEC))",
            "\t\tstats->ac_flag |= AFORK;",
            "\tif (tsk->flags & PF_SUPERPRIV)",
            "\t\tstats->ac_flag |= ASU;",
            "\tif (tsk->flags & PF_DUMPCORE)",
            "\t\tstats->ac_flag |= ACORE;",
            "\tif (tsk->flags & PF_SIGNALED)",
            "\t\tstats->ac_flag |= AXSIG;",
            "\tstats->ac_nice\t = task_nice(tsk);",
            "\tstats->ac_sched\t = tsk->policy;",
            "\tstats->ac_pid\t = task_pid_nr_ns(tsk, pid_ns);",
            "\tstats->ac_tgid   = task_tgid_nr_ns(tsk, pid_ns);",
            "\trcu_read_lock();",
            "\ttcred = __task_cred(tsk);",
            "\tstats->ac_uid\t = from_kuid_munged(user_ns, tcred->uid);",
            "\tstats->ac_gid\t = from_kgid_munged(user_ns, tcred->gid);",
            "\tstats->ac_ppid\t = pid_alive(tsk) ?",
            "\t\ttask_tgid_nr_ns(rcu_dereference(tsk->real_parent), pid_ns) : 0;",
            "\trcu_read_unlock();",
            "",
            "\ttask_cputime(tsk, &utime, &stime);",
            "\tstats->ac_utime = div_u64(utime, NSEC_PER_USEC);",
            "\tstats->ac_stime = div_u64(stime, NSEC_PER_USEC);",
            "",
            "\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);",
            "\tstats->ac_utimescaled = div_u64(utimescaled, NSEC_PER_USEC);",
            "\tstats->ac_stimescaled = div_u64(stimescaled, NSEC_PER_USEC);",
            "",
            "\tstats->ac_minflt = tsk->min_flt;",
            "\tstats->ac_majflt = tsk->maj_flt;",
            "",
            "\tstrscpy_pad(stats->ac_comm, tsk->comm);",
            "}",
            "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)",
            "{",
            "\tstruct mm_struct *mm;",
            "",
            "\t/* convert pages-nsec/1024 to Mbyte-usec, see __acct_update_integrals */",
            "\tstats->coremem = p->acct_rss_mem1 * PAGE_SIZE;",
            "\tdo_div(stats->coremem, 1000 * KB);",
            "\tstats->virtmem = p->acct_vm_mem1 * PAGE_SIZE;",
            "\tdo_div(stats->virtmem, 1000 * KB);",
            "\tmm = get_task_mm(p);",
            "\tif (mm) {",
            "\t\t/* adjust to KB unit */",
            "\t\tstats->hiwater_rss   = get_mm_hiwater_rss(mm) * PAGE_SIZE / KB;",
            "\t\tstats->hiwater_vm    = get_mm_hiwater_vm(mm)  * PAGE_SIZE / KB;",
            "\t\tmmput(mm);",
            "\t}",
            "\tstats->read_char\t= p->ioac.rchar & KB_MASK;",
            "\tstats->write_char\t= p->ioac.wchar & KB_MASK;",
            "\tstats->read_syscalls\t= p->ioac.syscr & KB_MASK;",
            "\tstats->write_syscalls\t= p->ioac.syscw & KB_MASK;",
            "#ifdef CONFIG_TASK_IO_ACCOUNTING",
            "\tstats->read_bytes\t= p->ioac.read_bytes & KB_MASK;",
            "\tstats->write_bytes\t= p->ioac.write_bytes & KB_MASK;",
            "\tstats->cancelled_write_bytes = p->ioac.cancelled_write_bytes & KB_MASK;",
            "#else",
            "\tstats->read_bytes\t= 0;",
            "\tstats->write_bytes\t= 0;",
            "\tstats->cancelled_write_bytes = 0;",
            "#endif",
            "}",
            "static void __acct_update_integrals(struct task_struct *tsk,",
            "\t\t\t\t    u64 utime, u64 stime)",
            "{",
            "\tu64 time, delta;",
            "",
            "\tif (!likely(tsk->mm))",
            "\t\treturn;",
            "",
            "\ttime = stime + utime;",
            "\tdelta = time - tsk->acct_timexpd;",
            "",
            "\tif (delta < TICK_NSEC)",
            "\t\treturn;",
            "",
            "\ttsk->acct_timexpd = time;",
            "\t/*",
            "\t * Divide by 1024 to avoid overflow, and to avoid division.",
            "\t * The final unit reported to userspace is Mbyte-usecs,",
            "\t * the rest of the math is done in xacct_add_tsk.",
            "\t */",
            "\ttsk->acct_rss_mem1 += delta * get_mm_rss(tsk->mm) >> 10;",
            "\ttsk->acct_vm_mem1 += delta * READ_ONCE(tsk->mm->total_vm) >> 10;",
            "}"
          ],
          "function_name": "bacct_add_tsk, xacct_add_tsk, __acct_update_integrals",
          "description": "bacct_add_tsk填充任务基本信息（如PID、用户UID/GID、调度策略、时间戳等），xacct_add_tsk统计内存及I/O数据，__acct_update_integrals计算并累加CPU时间与内存使用积分",
          "similarity": 0.6017787456512451
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/tsacct.c",
          "start_line": 152,
          "end_line": 171,
          "content": [
            "void acct_update_integrals(struct task_struct *tsk)",
            "{",
            "\tu64 utime, stime;",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\ttask_cputime(tsk, &utime, &stime);",
            "\t__acct_update_integrals(tsk, utime, stime);",
            "\tlocal_irq_restore(flags);",
            "}",
            "void acct_account_cputime(struct task_struct *tsk)",
            "{",
            "\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);",
            "}",
            "void acct_clear_integrals(struct task_struct *tsk)",
            "{",
            "\ttsk->acct_timexpd = 0;",
            "\ttsk->acct_rss_mem1 = 0;",
            "\ttsk->acct_vm_mem1 = 0;",
            "}"
          ],
          "function_name": "acct_update_integrals, acct_account_cputime, acct_clear_integrals",
          "description": "acct_update_integrals获取当前CPU时间并更新积分数据，acct_account_cputime直接记录任务CPU时间到积分，acct_clear_integrals重置任务积分相关统计变量",
          "similarity": 0.5701661705970764
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/tsacct.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * tsacct.c - System accounting over taskstats interface",
            " *",
            " * Copyright (C) Jay Lan,\t<jlan@sgi.com>",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/mm.h>",
            "",
            "/*",
            " * fill in basic accounting fields",
            " */"
          ],
          "function_name": null,
          "description": "定义系统任务统计（taskstats）接口的会计模块，包含基础头文件和注释，声明TS_COMM_LEN常量，为后续会计字段填充提供上下文；上下文不完整",
          "similarity": 0.5342001914978027
        }
      ]
    },
    {
      "source_file": "kernel/ptrace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ptrace.c`\n\n---\n\n# ptrace.c 技术文档\n\n## 1. 文件概述\n\n`ptrace.c` 是 Linux 内核中实现 **ptrace**（进程跟踪）机制的核心通用代码文件。该文件提供了跨架构的 ptrace 公共接口和基础功能，避免在每个体系结构中重复实现相同逻辑。ptrace 机制允许一个进程（tracer，通常是调试器）观察和控制另一个进程（tracee）的执行，包括读写其内存、寄存器状态、拦截系统调用等，是调试器（如 GDB）、系统调用追踪工具（如 strace）和安全监控工具的基础。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`ptrace_access_vm()`**  \n  安全地访问被跟踪进程（tracee）的虚拟内存空间，用于读写其内存内容。\n\n- **`__ptrace_link()`**  \n  将被跟踪进程链接到跟踪进程（tracer）的 `ptraced` 链表中，并设置其父进程为 tracer。\n\n- **`ptrace_link()`**  \n  封装 `__ptrace_link()`，使用当前进程的凭证建立跟踪关系。\n\n- **`__ptrace_unlink()`**  \n  解除跟踪关系：将被跟踪进程从 tracer 的链表中移除，恢复其原始父进程，并根据进程组停止状态调整其任务状态（如从 `TASK_TRACED` 转为 `TASK_STOPPED` 或唤醒）。\n\n- **`ptrace_freeze_traced()`** / **`ptrace_unfreeze_traced()`**  \n  在执行 ptrace 操作期间临时冻结被跟踪进程，防止其被意外唤醒（即使是 SIGKILL），确保操作的原子性和一致性。\n\n- **`ptrace_check_attach()`**  \n  验证当前进程是否有权对目标进程执行 ptrace 操作，并确保目标进程处于合适的跟踪状态（可选）。\n\n- **`looks_like_a_spurious_pid()`**  \n  辅助函数，用于检测因线程组 leader 更换（如 `de_thread()`）导致的“虚假”ptrace 事件，避免对已销毁进程的误操作。\n\n### 关键数据结构字段（在 `task_struct` 中）\n\n- `ptrace`：标志位，表示进程是否被跟踪。\n- `parent` / `real_parent`：分别表示当前父进程（通常是 tracer）和原始父进程。\n- `ptraced`：链表头，包含所有被当前进程跟踪的子进程。\n- `ptrace_entry`：链表节点，用于加入 tracer 的 `ptraced` 链表。\n- `ptracer_cred`：跟踪进程的凭证（credentials），用于权限检查。\n- `jobctl`：任务控制标志，包含 `JOBCTL_PTRACE_FROZEN`、`JOBCTL_TRACED`、`JOBCTL_STOP_PENDING` 等 ptrace 相关状态。\n\n## 3. 关键实现\n\n### 安全内存访问 (`ptrace_access_vm`)\n- 通过 `get_task_mm()` 获取目标进程的内存描述符 `mm_struct`。\n- 执行严格的权限检查：\n  - 目标进程必须正在被跟踪（`tsk->ptrace` 非零）。\n  - 当前进程必须是目标进程的直接父进程（`current == tsk->parent`）。\n  - 或者当前进程在目标进程的用户命名空间中具有 `CAP_SYS_PTRACE` 能力（通过 `ptracer_capable()` 检查）。\n- 使用 `__access_remote_vm()` 安全地读写目标进程内存，避免直接遍历页表。\n\n### 跟踪关系管理\n- **链接**：`ptrace_link()` 在持有 `tasklist_lock` 写锁时调用 `__ptrace_link()`，将 tracee 加入 tracer 的 `ptraced` 链表，并保存 tracer 的凭证。\n- **解链接**：`__ptrace_unlink()` 在 detach 或 tracer 退出时调用：\n  - 清除 syscall trace/emu 标志。\n  - 恢复 `real_parent`。\n  - 清除 `ptrace` 标志和 jobctl 中的 trap 相关位。\n  - 根据进程组停止状态决定是否设置 `JOBCTL_STOP_PENDING` 并唤醒进程（`ptrace_signal_wake_up()`）。\n\n### 进程状态冻结机制\n- 在执行 ptrace 操作前调用 `ptrace_freeze_traced()`：\n  - 若 tracee 处于 `TASK_TRACED` 且无致命信号待处理，则设置 `JOBCTL_PTRACE_FROZEN` 标志，使其无法被唤醒。\n- 操作完成后调用 `ptrace_unfreeze_traced()`：\n  - 清除冻结标志。\n  - 若存在致命信号（如 SIGKILL），则清除 `JOBCTL_TRACED` 并唤醒进程以处理信号。\n\n### 权限与状态验证 (`ptrace_check_attach`)\n- 在 `tasklist_lock` 读锁保护下验证：\n  - 目标进程确由当前进程跟踪（`child->ptrace && child->parent == current`）。\n  - 若 `ignore_state=false`，则进一步冻结 tracee 以确保其处于稳定状态。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`mm_struct`、`sighand_struct` 等核心数据结构，以及 `wake_up_state()`、`task_is_traced()` 等调度状态管理函数。\n- **内存管理**：通过 `get_task_mm()`、`mmput()` 和 `__access_remote_vm()` 访问远程进程内存。\n- **信号处理**：大量使用 `siglock`、`jobctl`、`signal_struct` 等信号相关机制管理进程状态转换。\n- **安全模块**：集成 LSM（Linux Security Module）钩子（`security_ptrace_access_check`）和能力检查（`capable()`）。\n- **审计与通知**：与 `audit` 和 `cn_proc`（进程事件连接器）交互，记录 ptrace 事件。\n- **体系结构相关代码**：依赖 `asm/syscall.h` 提供的 `syscall_get_*` 接口获取系统调用信息。\n- **硬件断点**：通过 `hw_breakpoint.h` 支持硬件断点调试功能。\n\n## 5. 使用场景\n\n- **调试器（如 GDB）**：attach 到目标进程，读取/修改寄存器和内存，设置断点，单步执行。\n- **系统调用追踪（如 strace）**：拦截并记录目标进程的所有系统调用及其参数和返回值。\n- **安全监控工具**：监控可疑进程的行为，如检测恶意代码注入或提权操作。\n- **容器与沙箱**：在用户命名空间中实现进程隔离和监控。\n- **内核测试**：用于内核自检和调试，验证进程行为和系统调用处理。\n- **进程注入与热补丁**：通过修改运行中进程的内存和寄存器状态实现代码注入或修复。",
      "similarity": 0.6057714223861694,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/ptrace.c",
          "start_line": 647,
          "end_line": 799,
          "content": [
            "int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tif (copy_from_user(buf, src, this_len))",
            "\t\t\treturn -EFAULT;",
            "\t\tretval = ptrace_access_vm(tsk, dst, buf, this_len,",
            "\t\t\t\tFOLL_FORCE | FOLL_WRITE);",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}",
            "static int ptrace_setoptions(struct task_struct *child, unsigned long data)",
            "{",
            "\tunsigned flags;",
            "\tint ret;",
            "",
            "\tret = check_ptrace_options(data);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* Avoid intermediate state when all opts are cleared */",
            "\tflags = child->ptrace;",
            "\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);",
            "\tflags |= (data << PT_OPT_FLAG_SHIFT);",
            "\tchild->ptrace = flags;",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(info, child->last_siginfo);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(child->last_siginfo, info);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_peek_siginfo(struct task_struct *child,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long data)",
            "{",
            "\tstruct ptrace_peeksiginfo_args arg;",
            "\tstruct sigpending *pending;",
            "\tstruct sigqueue *q;",
            "\tint ret, i;",
            "",
            "\tret = copy_from_user(&arg, (void __user *) addr,",
            "\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)",
            "\t\treturn -EINVAL; /* unknown flags */",
            "",
            "\tif (arg.nr < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure arg.off fits in an unsigned long */",
            "\tif (arg.off > ULONG_MAX)",
            "\t\treturn 0;",
            "",
            "\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)",
            "\t\tpending = &child->signal->shared_pending;",
            "\telse",
            "\t\tpending = &child->pending;",
            "",
            "\tfor (i = 0; i < arg.nr; ) {",
            "\t\tkernel_siginfo_t info;",
            "\t\tunsigned long off = arg.off + i;",
            "\t\tbool found = false;",
            "",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tlist_for_each_entry(q, &pending->list, list) {",
            "\t\t\tif (!off--) {",
            "\t\t\t\tfound = true;",
            "\t\t\t\tcopy_siginfo(&info, &q->info);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tif (!found) /* beyond the end of the list */",
            "\t\t\tbreak;",
            "",
            "#ifdef CONFIG_COMPAT",
            "\t\tif (unlikely(in_compat_syscall())) {",
            "\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);",
            "",
            "\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t} else",
            "#endif",
            "\t\t{",
            "\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;",
            "",
            "\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tdata += sizeof(siginfo_t);",
            "\t\ti++;",
            "",
            "\t\tif (signal_pending(current))",
            "\t\t\tbreak;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\tif (i > 0)",
            "\t\treturn i;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_writedata, ptrace_setoptions, ptrace_getsiginfo, ptrace_setsiginfo, ptrace_peek_siginfo",
          "description": "实现ptrace_writedata用于将数据写入被跟踪进程的内存，通过循环拷贝并处理错误；ptrace_setoptions用于更新跟踪选项标志位；ptrace_getsiginfo/ptrace_setsiginfo用于获取和设置进程的最后一个信号信息；ptrace_peek_siginfo用于遍历信号队列并复制信号信息到用户空间",
          "similarity": 0.6405858397483826
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/ptrace.c",
          "start_line": 967,
          "end_line": 1267,
          "content": [
            "static unsigned long",
            "ptrace_get_syscall_info_exit(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t     struct ptrace_syscall_info *info)",
            "{",
            "\tinfo->op = PTRACE_SYSCALL_INFO_EXIT;",
            "\tinfo->exit.rval = syscall_get_error(child, regs);",
            "\tinfo->exit.is_error = !!info->exit.rval;",
            "\tif (!info->exit.is_error)",
            "\t\tinfo->exit.rval = syscall_get_return_value(child, regs);",
            "",
            "\t/* is_error is the last field in struct ptrace_syscall_info.exit */",
            "\treturn offsetofend(struct ptrace_syscall_info, exit.is_error);",
            "}",
            "static int",
            "ptrace_get_syscall_info(struct task_struct *child, unsigned long user_size,",
            "\t\t\tvoid __user *datavp)",
            "{",
            "\tstruct pt_regs *regs = task_pt_regs(child);",
            "\tstruct ptrace_syscall_info info = {",
            "\t\t.op = PTRACE_SYSCALL_INFO_NONE,",
            "\t\t.arch = syscall_get_arch(child),",
            "\t\t.instruction_pointer = instruction_pointer(regs),",
            "\t\t.stack_pointer = user_stack_pointer(regs),",
            "\t};",
            "\tunsigned long actual_size = offsetof(struct ptrace_syscall_info, entry);",
            "\tunsigned long write_size;",
            "",
            "\t/*",
            "\t * This does not need lock_task_sighand() to access",
            "\t * child->last_siginfo because ptrace_freeze_traced()",
            "\t * called earlier by ptrace_check_attach() ensures that",
            "\t * the tracee cannot go away and clear its last_siginfo.",
            "\t */",
            "\tswitch (child->last_siginfo ? child->last_siginfo->si_code : 0) {",
            "\tcase SIGTRAP | 0x80:",
            "\t\tswitch (child->ptrace_message) {",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_ENTRY:",
            "\t\t\tactual_size = ptrace_get_syscall_info_entry(child, regs,",
            "\t\t\t\t\t\t\t\t    &info);",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_EXIT:",
            "\t\t\tactual_size = ptrace_get_syscall_info_exit(child, regs,",
            "\t\t\t\t\t\t\t\t   &info);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase SIGTRAP | (PTRACE_EVENT_SECCOMP << 8):",
            "\t\tactual_size = ptrace_get_syscall_info_seccomp(child, regs,",
            "\t\t\t\t\t\t\t      &info);",
            "\t\tbreak;",
            "\t}",
            "",
            "\twrite_size = min(actual_size, user_size);",
            "\treturn copy_to_user(datavp, &info, write_size) ? -EFAULT : actual_size;",
            "}",
            "int ptrace_request(struct task_struct *child, long request,",
            "\t\t   unsigned long addr, unsigned long data)",
            "{",
            "\tbool seized = child->ptrace & PT_SEIZED;",
            "\tint ret = -EIO;",
            "\tkernel_siginfo_t siginfo, *si;",
            "\tvoid __user *datavp = (void __user *) data;",
            "\tunsigned long __user *datalp = datavp;",
            "\tunsigned long flags;",
            "",
            "\tswitch (request) {",
            "\tcase PTRACE_PEEKTEXT:",
            "\tcase PTRACE_PEEKDATA:",
            "\t\treturn generic_ptrace_peekdata(child, addr, data);",
            "\tcase PTRACE_POKETEXT:",
            "\tcase PTRACE_POKEDATA:",
            "\t\treturn generic_ptrace_pokedata(child, addr, data);",
            "",
            "#ifdef PTRACE_OLDSETOPTIONS",
            "\tcase PTRACE_OLDSETOPTIONS:",
            "#endif",
            "\tcase PTRACE_SETOPTIONS:",
            "\t\tret = ptrace_setoptions(child, data);",
            "\t\tbreak;",
            "\tcase PTRACE_GETEVENTMSG:",
            "\t\tret = put_user(child->ptrace_message, datalp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_PEEKSIGINFO:",
            "\t\tret = ptrace_peek_siginfo(child, addr, data);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGINFO:",
            "\t\tret = ptrace_getsiginfo(child, &siginfo);",
            "\t\tif (!ret)",
            "\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SETSIGINFO:",
            "\t\tret = copy_siginfo_from_user(&siginfo, datavp);",
            "\t\tif (!ret)",
            "\t\t\tret = ptrace_setsiginfo(child, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGMASK: {",
            "\t\tsigset_t *mask;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (test_tsk_restore_sigmask(child))",
            "\t\t\tmask = &child->saved_sigmask;",
            "\t\telse",
            "\t\t\tmask = &child->blocked;",
            "",
            "\t\tif (copy_to_user(datavp, mask, sizeof(sigset_t)))",
            "\t\t\tret = -EFAULT;",
            "\t\telse",
            "\t\t\tret = 0;",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_SETSIGMASK: {",
            "\t\tsigset_t new_set;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (copy_from_user(&new_set, datavp, sizeof(sigset_t))) {",
            "\t\t\tret = -EFAULT;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));",
            "",
            "\t\t/*",
            "\t\t * Every thread does recalc_sigpending() after resume, so",
            "\t\t * retarget_shared_pending() and recalc_sigpending() are not",
            "\t\t * called here.",
            "\t\t */",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tchild->blocked = new_set;",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tclear_tsk_restore_sigmask(child);",
            "",
            "\t\tret = 0;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_INTERRUPT:",
            "\t\t/*",
            "\t\t * Stop tracee without any side-effect on signal or job",
            "\t\t * control.  At least one trap is guaranteed to happen",
            "\t\t * after this request.  If @child is already trapped, the",
            "\t\t * current trap is not disturbed and another trap will",
            "\t\t * happen after the current trap is ended with PTRACE_CONT.",
            "\t\t *",
            "\t\t * The actual trap might not be PTRACE_EVENT_STOP trap but",
            "\t\t * the pending condition is cleared regardless.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * INTERRUPT doesn't disturb existing trap sans one",
            "\t\t * exception.  If ptracer issued LISTEN for the current",
            "\t\t * STOP, this INTERRUPT should clear LISTEN and re-trap",
            "\t\t * tracee into STOP.",
            "\t\t */",
            "\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))",
            "\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);",
            "",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tret = 0;",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_LISTEN:",
            "\t\t/*",
            "\t\t * Listen for events.  Tracee must be in STOP.  It's not",
            "\t\t * resumed per-se but is not considered to be in TRACED by",
            "\t\t * wait(2) or ptrace(2).  If an async event (e.g. group",
            "\t\t * stop state change) happens, tracee will enter STOP trap",
            "\t\t * again.  Alternatively, ptracer can issue INTERRUPT to",
            "\t\t * finish listening and re-trap tracee into STOP.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\tsi = child->last_siginfo;",
            "\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {",
            "\t\t\tchild->jobctl |= JOBCTL_LISTENING;",
            "\t\t\t/*",
            "\t\t\t * If NOTIFY is set, it means event happened between",
            "\t\t\t * start of this trap and now.  Trigger re-trap.",
            "\t\t\t */",
            "\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)",
            "\t\t\t\tptrace_signal_wake_up(child, true);",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_DETACH:\t /* detach a process that was attached. */",
            "\t\tret = ptrace_detach(child, data);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_BINFMT_ELF_FDPIC",
            "\tcase PTRACE_GETFDPIC: {",
            "\t\tstruct mm_struct *mm = get_task_mm(child);",
            "\t\tunsigned long tmp = 0;",
            "",
            "\t\tret = -ESRCH;",
            "\t\tif (!mm)",
            "\t\t\tbreak;",
            "",
            "\t\tswitch (addr) {",
            "\t\tcase PTRACE_GETFDPIC_EXEC:",
            "\t\t\ttmp = mm->context.exec_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_GETFDPIC_INTERP:",
            "\t\t\ttmp = mm->context.interp_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tmmput(mm);",
            "",
            "\t\tret = put_user(tmp, datalp);",
            "\t\tbreak;",
            "\t}",
            "#endif",
            "",
            "\tcase PTRACE_SINGLESTEP:",
            "#ifdef PTRACE_SINGLEBLOCK",
            "\tcase PTRACE_SINGLEBLOCK:",
            "#endif",
            "#ifdef PTRACE_SYSEMU",
            "\tcase PTRACE_SYSEMU:",
            "\tcase PTRACE_SYSEMU_SINGLESTEP:",
            "#endif",
            "\tcase PTRACE_SYSCALL:",
            "\tcase PTRACE_CONT:",
            "\t\treturn ptrace_resume(child, request, data);",
            "",
            "\tcase PTRACE_KILL:",
            "\t\tsend_sig_info(SIGKILL, SEND_SIG_NOINFO, child);",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_HAVE_ARCH_TRACEHOOK",
            "\tcase PTRACE_GETREGSET:",
            "\tcase PTRACE_SETREGSET: {",
            "\t\tstruct iovec kiov;",
            "\t\tstruct iovec __user *uiov = datavp;",
            "",
            "\t\tif (!access_ok(uiov, sizeof(*uiov)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||",
            "\t\t    __get_user(kiov.iov_len, &uiov->iov_len))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tret = ptrace_regset(child, request, addr, &kiov);",
            "\t\tif (!ret)",
            "\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_GET_SYSCALL_INFO:",
            "\t\tret = ptrace_get_syscall_info(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SECCOMP_GET_FILTER:",
            "\t\tret = seccomp_get_filter(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SECCOMP_GET_METADATA:",
            "\t\tret = seccomp_get_metadata(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_RSEQ",
            "\tcase PTRACE_GET_RSEQ_CONFIGURATION:",
            "\t\tret = ptrace_get_rseq_configuration(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_set_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_get_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_get_syscall_info_exit, ptrace_get_syscall_info, ptrace_request",
          "description": "ptrace_get_syscall_info根据进程最后信号信息构造系统调用详细数据结构；ptrace_request作为ptrace系统调用的核心分发函数，处理包括中断、继续执行、获取/设置信号掩码、获取系统调用信息等各类请求",
          "similarity": 0.6334840059280396
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/ptrace.c",
          "start_line": 44,
          "end_line": 148,
          "content": [
            "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,",
            "\t\t     void *buf, int len, unsigned int gup_flags)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint ret;",
            "",
            "\tmm = get_task_mm(tsk);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tif (!tsk->ptrace ||",
            "\t    (current != tsk->parent) ||",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptracer_capable(tsk, mm->user_ns))) {",
            "\t\tmmput(mm);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = __access_remote_vm(mm, addr, buf, len, gup_flags);",
            "\tmmput(mm);",
            "",
            "\treturn ret;",
            "}",
            "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,",
            "\t\t   const struct cred *ptracer_cred)",
            "{",
            "\tBUG_ON(!list_empty(&child->ptrace_entry));",
            "\tlist_add(&child->ptrace_entry, &new_parent->ptraced);",
            "\tchild->parent = new_parent;",
            "\tchild->ptracer_cred = get_cred(ptracer_cred);",
            "}",
            "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)",
            "{",
            "\t__ptrace_link(child, new_parent, current_cred());",
            "}",
            "void __ptrace_unlink(struct task_struct *child)",
            "{",
            "\tconst struct cred *old_cred;",
            "\tBUG_ON(!child->ptrace);",
            "",
            "\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tchild->parent = child->real_parent;",
            "\tlist_del_init(&child->ptrace_entry);",
            "\told_cred = child->ptracer_cred;",
            "\tchild->ptracer_cred = NULL;",
            "\tput_cred(old_cred);",
            "",
            "\tspin_lock(&child->sighand->siglock);",
            "\tchild->ptrace = 0;",
            "\t/*",
            "\t * Clear all pending traps and TRAPPING.  TRAPPING should be",
            "\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.",
            "\t */",
            "\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);",
            "\ttask_clear_jobctl_trapping(child);",
            "",
            "\t/*",
            "\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and",
            "\t * @child isn't dead.",
            "\t */",
            "\tif (!(child->flags & PF_EXITING) &&",
            "\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||",
            "\t     child->signal->group_stop_count)) {",
            "\t\tchild->jobctl |= JOBCTL_STOP_PENDING;",
            "",
            "\t\t/*",
            "\t\t * This is only possible if this thread was cloned by the",
            "\t\t * traced task running in the stopped group, set the signal",
            "\t\t * for the future reports.",
            "\t\t * FIXME: we should change ptrace_init_task() to handle this",
            "\t\t * case.",
            "\t\t */",
            "\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))",
            "\t\t\tchild->jobctl |= SIGSTOP;",
            "\t}",
            "",
            "\t/*",
            "\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick",
            "\t * @child in the butt.  Note that @resume should be used iff @child",
            "\t * is in TASK_TRACED; otherwise, we might unduly disrupt",
            "\t * TASK_KILLABLE sleeps.",
            "\t */",
            "\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))",
            "\t\tptrace_signal_wake_up(child, true);",
            "",
            "\tspin_unlock(&child->sighand->siglock);",
            "}",
            "static bool looks_like_a_spurious_pid(struct task_struct *task)",
            "{",
            "\tif (task->exit_code != ((PTRACE_EVENT_EXEC << 8) | SIGTRAP))",
            "\t\treturn false;",
            "",
            "\tif (task_pid_vnr(task) == task->ptrace_message)",
            "\t\treturn false;",
            "\t/*",
            "\t * The tracee changed its pid but the PTRACE_EVENT_EXEC event",
            "\t * was not wait()'ed, most probably debugger targets the old",
            "\t * leader which was destroyed in de_thread().",
            "\t */",
            "\treturn true;",
            "}"
          ],
          "function_name": "ptrace_access_vm, __ptrace_link, ptrace_link, __ptrace_unlink, looks_like_a_spurious_pid",
          "description": "实现进程跟踪核心操作，包含访问目标进程地址空间、维护跟踪链表、解除跟踪关系及检测虚假PID逻辑，用于安全控制和状态同步。",
          "similarity": 0.6327906847000122
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/ptrace.c",
          "start_line": 806,
          "end_line": 922,
          "content": [
            "static long ptrace_get_rseq_configuration(struct task_struct *task,",
            "\t\t\t\t\t  unsigned long size, void __user *data)",
            "{",
            "\tstruct ptrace_rseq_configuration conf = {",
            "\t\t.rseq_abi_pointer = (u64)(uintptr_t)task->rseq,",
            "\t\t.rseq_abi_size = task->rseq_len,",
            "\t\t.signature = task->rseq_sig,",
            "\t\t.flags = 0,",
            "\t};",
            "",
            "\tsize = min_t(unsigned long, size, sizeof(conf));",
            "\tif (copy_to_user(data, &conf, size))",
            "\t\treturn -EFAULT;",
            "\treturn sizeof(conf);",
            "}",
            "static int ptrace_resume(struct task_struct *child, long request,",
            "\t\t\t unsigned long data)",
            "{",
            "\tif (!valid_signal(data))",
            "\t\treturn -EIO;",
            "",
            "\tif (request == PTRACE_SYSCALL)",
            "\t\tset_task_syscall_work(child, SYSCALL_TRACE);",
            "\telse",
            "\t\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tif (request == PTRACE_SYSEMU || request == PTRACE_SYSEMU_SINGLESTEP)",
            "\t\tset_task_syscall_work(child, SYSCALL_EMU);",
            "\telse",
            "\t\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tif (is_singleblock(request)) {",
            "\t\tif (unlikely(!arch_has_block_step()))",
            "\t\t\treturn -EIO;",
            "\t\tuser_enable_block_step(child);",
            "\t} else if (is_singlestep(request) || is_sysemu_singlestep(request)) {",
            "\t\tif (unlikely(!arch_has_single_step()))",
            "\t\t\treturn -EIO;",
            "\t\tuser_enable_single_step(child);",
            "\t} else {",
            "\t\tuser_disable_single_step(child);",
            "\t}",
            "",
            "\t/*",
            "\t * Change ->exit_code and ->state under siglock to avoid the race",
            "\t * with wait_task_stopped() in between; a non-zero ->exit_code will",
            "\t * wrongly look like another report from tracee.",
            "\t *",
            "\t * Note that we need siglock even if ->exit_code == data and/or this",
            "\t * status was not reported yet, the new status must not be cleared by",
            "\t * wait_task_stopped() after resume.",
            "\t */",
            "\tspin_lock_irq(&child->sighand->siglock);",
            "\tchild->exit_code = data;",
            "\tchild->jobctl &= ~JOBCTL_TRACED;",
            "\twake_up_state(child, __TASK_TRACED);",
            "\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_regset(struct task_struct *task, int req, unsigned int type,",
            "\t\t\t struct iovec *kiov)",
            "{",
            "\tconst struct user_regset_view *view = task_user_regset_view(task);",
            "\tconst struct user_regset *regset = find_regset(view, type);",
            "\tint regset_no;",
            "",
            "\tif (!regset || (kiov->iov_len % regset->size) != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tregset_no = regset - view->regsets;",
            "\tkiov->iov_len = min(kiov->iov_len,",
            "\t\t\t    (__kernel_size_t) (regset->n * regset->size));",
            "",
            "\tif (req == PTRACE_GETREGSET)",
            "\t\treturn copy_regset_to_user(task, view, regset_no, 0,",
            "\t\t\t\t\t   kiov->iov_len, kiov->iov_base);",
            "\telse",
            "\t\treturn copy_regset_from_user(task, view, regset_no, 0,",
            "\t\t\t\t\t     kiov->iov_len, kiov->iov_base);",
            "}",
            "static unsigned long",
            "ptrace_get_syscall_info_entry(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t      struct ptrace_syscall_info *info)",
            "{",
            "\tunsigned long args[ARRAY_SIZE(info->entry.args)];",
            "\tint i;",
            "",
            "\tinfo->op = PTRACE_SYSCALL_INFO_ENTRY;",
            "\tinfo->entry.nr = syscall_get_nr(child, regs);",
            "\tsyscall_get_arguments(child, regs, args);",
            "\tfor (i = 0; i < ARRAY_SIZE(args); i++)",
            "\t\tinfo->entry.args[i] = args[i];",
            "",
            "\t/* args is the last field in struct ptrace_syscall_info.entry */",
            "\treturn offsetofend(struct ptrace_syscall_info, entry.args);",
            "}",
            "static unsigned long",
            "ptrace_get_syscall_info_seccomp(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t\tstruct ptrace_syscall_info *info)",
            "{",
            "\t/*",
            "\t * As struct ptrace_syscall_info.entry is currently a subset",
            "\t * of struct ptrace_syscall_info.seccomp, it makes sense to",
            "\t * initialize that subset using ptrace_get_syscall_info_entry().",
            "\t * This can be reconsidered in the future if these structures",
            "\t * diverge significantly enough.",
            "\t */",
            "\tptrace_get_syscall_info_entry(child, regs, info);",
            "\tinfo->op = PTRACE_SYSCALL_INFO_SECCOMP;",
            "\tinfo->seccomp.ret_data = child->ptrace_message;",
            "",
            "\t/* ret_data is the last field in struct ptrace_syscall_info.seccomp */",
            "\treturn offsetofend(struct ptrace_syscall_info, seccomp.ret_data);",
            "}"
          ],
          "function_name": "ptrace_get_rseq_configuration, ptrace_resume, ptrace_regset, ptrace_get_syscall_info_entry, ptrace_get_syscall_info_seccomp",
          "description": "ptrace_get_rseq_configuration获取RSEQ配置信息；ptrace_resume控制跟踪进程的恢复状态，包括系统调用跟踪、单步执行和信号处理；ptrace_regset处理用户寄存器集合的读写；ptrace_get_syscall_info_*系列函数构建系统调用相关信息结构体",
          "similarity": 0.6225336790084839
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/ptrace.c",
          "start_line": 501,
          "end_line": 618,
          "content": [
            "static int ptrace_traceme(void)",
            "{",
            "\tint ret = -EPERM;",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\t/* Are we already being traced? */",
            "\tif (!current->ptrace) {",
            "\t\tret = security_ptrace_traceme(current->parent);",
            "\t\t/*",
            "\t\t * Check PF_EXITING to ensure ->real_parent has not passed",
            "\t\t * exit_ptrace(). Otherwise we don't report the error but",
            "\t\t * pretend ->real_parent untraces us right after return.",
            "\t\t */",
            "\t\tif (!ret && !(current->real_parent->flags & PF_EXITING)) {",
            "\t\t\tcurrent->ptrace = PT_PTRACED;",
            "\t\t\tptrace_link(current, current->real_parent);",
            "\t\t}",
            "\t}",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\treturn ret;",
            "}",
            "static int ignoring_children(struct sighand_struct *sigh)",
            "{",
            "\tint ret;",
            "\tspin_lock(&sigh->siglock);",
            "\tret = (sigh->action[SIGCHLD-1].sa.sa_handler == SIG_IGN) ||",
            "\t      (sigh->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT);",
            "\tspin_unlock(&sigh->siglock);",
            "\treturn ret;",
            "}",
            "static bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)",
            "{",
            "\tbool dead;",
            "",
            "\t__ptrace_unlink(p);",
            "",
            "\tif (p->exit_state != EXIT_ZOMBIE)",
            "\t\treturn false;",
            "",
            "\tdead = !thread_group_leader(p);",
            "",
            "\tif (!dead && thread_group_empty(p)) {",
            "\t\tif (!same_thread_group(p->real_parent, tracer))",
            "\t\t\tdead = do_notify_parent(p, p->exit_signal);",
            "\t\telse if (ignoring_children(tracer->sighand)) {",
            "\t\t\t__wake_up_parent(p, tracer);",
            "\t\t\tdead = true;",
            "\t\t}",
            "\t}",
            "\t/* Mark it as in the process of being reaped. */",
            "\tif (dead)",
            "\t\tp->exit_state = EXIT_DEAD;",
            "\treturn dead;",
            "}",
            "static int ptrace_detach(struct task_struct *child, unsigned int data)",
            "{",
            "\tif (!valid_signal(data))",
            "\t\treturn -EIO;",
            "",
            "\t/* Architecture-specific hardware disable .. */",
            "\tptrace_disable(child);",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\t/*",
            "\t * We rely on ptrace_freeze_traced(). It can't be killed and",
            "\t * untraced by another thread, it can't be a zombie.",
            "\t */",
            "\tWARN_ON(!child->ptrace || child->exit_state);",
            "\t/*",
            "\t * tasklist_lock avoids the race with wait_task_stopped(), see",
            "\t * the comment in ptrace_resume().",
            "\t */",
            "\tchild->exit_code = data;",
            "\t__ptrace_detach(current, child);",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\tproc_ptrace_connector(child, PTRACE_DETACH);",
            "",
            "\treturn 0;",
            "}",
            "void exit_ptrace(struct task_struct *tracer, struct list_head *dead)",
            "{",
            "\tstruct task_struct *p, *n;",
            "",
            "\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {",
            "\t\tif (unlikely(p->ptrace & PT_EXITKILL))",
            "\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);",
            "",
            "\t\tif (__ptrace_detach(tracer, p))",
            "\t\t\tlist_add(&p->ptrace_entry, dead);",
            "\t}",
            "}",
            "int ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tretval = ptrace_access_vm(tsk, src, buf, this_len, FOLL_FORCE);",
            "",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tif (copy_to_user(dst, buf, retval))",
            "\t\t\treturn -EFAULT;",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}"
          ],
          "function_name": "ptrace_traceme, ignoring_children, __ptrace_detach, ptrace_detach, exit_ptrace, ptrace_readdata",
          "description": "完成跟踪关系建立与终止，包含被跟踪进程自我注册、子进程忽略信号检测、跟踪分离及资源释放逻辑，处理进程退出时的跟踪清理。",
          "similarity": 0.5913777947425842
        }
      ]
    }
  ]
}