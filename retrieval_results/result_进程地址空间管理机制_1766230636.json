{
  "query": "进程地址空间管理机制",
  "timestamp": "2025-12-20 19:37:16",
  "retrieved_files": [
    {
      "source_file": "kernel/pid.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:16:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid.c`\n\n---\n\n# `pid.c` 技术文档\n\n## 1. 文件概述\n\n`pid.c` 是 Linux 内核中实现进程标识符（PID）管理和分配机制的核心文件。它提供了可扩展、时间有界的 PID 分配器，支持 PID 哈希表（pidhash）以及 PID 命名空间（pid namespace）功能。该文件负责 PID 的分配、释放、引用计数管理，并确保在多处理器（SMP）环境下的线程安全性。其设计目标是在高并发场景下高效、无锁地分配和回收 PID，同时支持容器化环境中的 PID 隔离。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct pid`**  \n  表示一个 PID 实例，包含：\n  - 引用计数（`count`）\n  - 多种任务类型链表（`tasks[PIDTYPE_MAX]`），用于关联不同类型的进程（如线程组、会话等）\n  - PID 层级（`level`），用于命名空间嵌套\n  - `numbers[]` 数组：每个命名空间层级对应的 `struct upid`（包含实际 PID 编号 `nr` 和所属命名空间 `ns`）\n  - `rcu` 字段：用于 RCU 安全释放\n  - `wait_pidfd`：用于 pidfd 机制的等待队列\n  - `inodes`：关联的 pidfs inode 列表\n\n- **`struct pid_namespace`**  \n  PID 命名空间结构，包含：\n  - IDR（整数 ID 映射）结构 `idr`，用于高效 PID 分配\n  - `pid_allocated`：当前已分配 PID 数量（含特殊状态如 `PIDNS_ADDING`）\n  - `child_reaper`：命名空间中的 init 进程（子进程回收者）\n  - `level`：命名空间嵌套层级\n  - `pid_cachep`：用于分配 `struct pid` 的 slab 缓存\n\n- **全局变量**\n  - `init_struct_pid`：初始 PID 结构（PID 0，用于 idle 进程）\n  - `init_pid_ns`：初始 PID 命名空间\n  - `pid_max` / `pid_max_min` / `pid_max_max`：PID 分配上限控制\n  - `pidfs_ino`：pidfs 文件系统的 inode 编号起始值\n  - `pidmap_lock`：保护 IDR 和 `pid_allocated` 的自旋锁（SMP 对齐）\n\n### 主要函数\n\n- **`alloc_pid(struct pid_namespace *ns, pid_t *set_tid, size_t set_tid_size)`**  \n  在指定 PID 命名空间中分配一个新的 PID。支持通过 `set_tid` 数组在嵌套命名空间中预设 PID（用于容器恢复等场景）。\n\n- **`free_pid(struct pid *pid)`**  \n  释放 PID 资源，从所有嵌套命名空间的 IDR 中移除，并减少 `pid_allocated` 计数。若命名空间中仅剩 reaper 进程，则唤醒它。\n\n- **`put_pid(struct pid *pid)`**  \n  减少 PID 引用计数，若引用归零则释放内存并减少命名空间引用。\n\n- **`delayed_put_pid(struct rcu_head *rhp)`**  \n  RCU 回调函数，用于安全释放 PID 结构。\n\n## 3. 关键实现\n\n### PID 分配机制\n- 使用 **IDR（Integer ID Allocator）** 替代传统的位图（bitmap），实现 O(1) 分配与释放。\n- 默认采用**循环分配策略**（`idr_alloc_cyclic`），从 `RESERVED_PIDS`（通常为 300）开始，避免低编号 PID 被耗尽。\n- 支持**预设 PID 分配**：通过 `set_tid` 参数在创建进程时指定特定 PID（需具备 `CAP_CHECKPOINT_RESTORE` 权限），用于容器快照恢复。\n\n### 命名空间支持\n- 每个 PID 在嵌套的命名空间中拥有不同的编号（`upid->nr`），通过 `pid->numbers[]` 数组维护层级关系。\n- `pid->level` 表示该 PID 所属的最深命名空间层级。\n- 分配时从最深层命名空间向上遍历至根命名空间，逐层分配 PID。\n\n### 并发与同步\n- **`pidmap_lock`**：保护 IDR 操作和 `pid_allocated` 计数器，使用 `spin_lock_irqsave` 禁用本地中断，防止与 `tasklist_lock` 的死锁。\n- **RCU 释放**：`free_pid` 通过 `call_rcu` 延迟释放 PID 结构，避免在持有锁时执行内存释放。\n- **引用计数**：`struct pid` 使用 `refcount_t` 管理生命周期，确保多任务共享 PID 时的安全释放。\n\n### 特殊状态处理\n- **`PIDNS_ADDING`**：标记命名空间正在添加新进程，防止在 fork 失败时错误减少计数。\n- **Reaper 唤醒**：当命名空间中 PID 数量降至 1 或 2 时，唤醒 `child_reaper`（通常为 init 进程），用于处理命名空间退出（`zap_pid_ns_processes`）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pid_namespace.h>`：PID 命名空间定义\n  - `<linux/idr.h>`：IDR 分配器实现\n  - `<linux/rculist.h>`：RCU 安全链表操作\n  - `<linux/sched/task.h>`、`<linux/sched/signal.h>`：任务调度与信号处理\n  - `<linux/pidfs.h>`、`<uapi/linux/pidfd.h>`：pidfd 和 pidfs 支持\n  - `<linux/refcount.h>`：引用计数机制\n\n- **内核模块交互**：\n  - **进程管理子系统**：与 `fork`/`clone` 系统调用集成，分配 PID 并关联到 `task_struct`\n  - **命名空间子系统**：与 `pidns_operations` 协同实现 PID 隔离\n  - **VFS 子系统**：通过 `pidfs_ino` 为 `/proc/[pid]` 提供 inode 编号\n  - **内存管理**：使用 slab 分配器（`kmem_cache_alloc`）管理 `struct pid` 内存\n\n## 5. 使用场景\n\n- **进程创建**：在 `copy_process` 中调用 `alloc_pid` 为新进程分配唯一 PID。\n- **容器运行时**：通过 `clone(CLONE_NEWPID)` 创建 PID 命名空间，实现容器内 PID 隔离。\n- **检查点/恢复（CRIU）**：使用 `set_tid` 参数在恢复进程时精确还原原始 PID。\n- **pidfd 机制**：`pid->wait_pidfd` 支持通过文件描述符等待进程退出（`pidfd_send_signal` 等系统调用）。\n- **命名空间清理**：当容器退出时，`free_pid` 触发 reaper 唤醒，确保孤儿进程被正确回收。",
      "similarity": 0.6430699825286865,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/pid.c",
          "start_line": 109,
          "end_line": 221,
          "content": [
            "void put_pid(struct pid *pid)",
            "{",
            "\tstruct pid_namespace *ns;",
            "",
            "\tif (!pid)",
            "\t\treturn;",
            "",
            "\tns = pid->numbers[pid->level].ns;",
            "\tif (refcount_dec_and_test(&pid->count)) {",
            "\t\tkmem_cache_free(ns->pid_cachep, pid);",
            "\t\tput_pid_ns(ns);",
            "\t}",
            "}",
            "static void delayed_put_pid(struct rcu_head *rhp)",
            "{",
            "\tstruct pid *pid = container_of(rhp, struct pid, rcu);",
            "\tput_pid(pid);",
            "}",
            "void free_pid(struct pid *pid)",
            "{",
            "\t/* We can be called with write_lock_irq(&tasklist_lock) held */",
            "\tint i;",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&pidmap_lock, flags);",
            "\tfor (i = 0; i <= pid->level; i++) {",
            "\t\tstruct upid *upid = pid->numbers + i;",
            "\t\tstruct pid_namespace *ns = upid->ns;",
            "\t\tswitch (--ns->pid_allocated) {",
            "\t\tcase 2:",
            "\t\tcase 1:",
            "\t\t\t/* When all that is left in the pid namespace",
            "\t\t\t * is the reaper wake up the reaper.  The reaper",
            "\t\t\t * may be sleeping in zap_pid_ns_processes().",
            "\t\t\t */",
            "\t\t\twake_up_process(ns->child_reaper);",
            "\t\t\tbreak;",
            "\t\tcase PIDNS_ADDING:",
            "\t\t\t/* Handle a fork failure of the first process */",
            "\t\t\tWARN_ON(ns->child_reaper);",
            "\t\t\tns->pid_allocated = 0;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tidr_remove(&ns->idr, upid->nr);",
            "\t}",
            "\tpidfs_remove_pid(pid);",
            "\tspin_unlock_irqrestore(&pidmap_lock, flags);",
            "",
            "\tcall_rcu(&pid->rcu, delayed_put_pid);",
            "}",
            "void disable_pid_allocation(struct pid_namespace *ns)",
            "{",
            "\tspin_lock_irq(&pidmap_lock);",
            "\tns->pid_allocated &= ~PIDNS_ADDING;",
            "\tspin_unlock_irq(&pidmap_lock);",
            "}",
            "void attach_pid(struct task_struct *task, enum pid_type type)",
            "{",
            "\tstruct pid *pid = *task_pid_ptr(task, type);",
            "\thlist_add_head_rcu(&task->pid_links[type], &pid->tasks[type]);",
            "}",
            "static void __change_pid(struct task_struct *task, enum pid_type type,",
            "\t\t\tstruct pid *new)",
            "{",
            "\tstruct pid **pid_ptr = task_pid_ptr(task, type);",
            "\tstruct pid *pid;",
            "\tint tmp;",
            "",
            "\tpid = *pid_ptr;",
            "",
            "\thlist_del_rcu(&task->pid_links[type]);",
            "\t*pid_ptr = new;",
            "",
            "\tif (type == PIDTYPE_PID) {",
            "\t\tWARN_ON_ONCE(pid_has_task(pid, PIDTYPE_PID));",
            "\t\twake_up_all(&pid->wait_pidfd);",
            "\t}",
            "",
            "\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )",
            "\t\tif (pid_has_task(pid, tmp))",
            "\t\t\treturn;",
            "",
            "\tfree_pid(pid);",
            "}",
            "void detach_pid(struct task_struct *task, enum pid_type type)",
            "{",
            "\t__change_pid(task, type, NULL);",
            "}",
            "void change_pid(struct task_struct *task, enum pid_type type,",
            "\t\tstruct pid *pid)",
            "{",
            "\t__change_pid(task, type, pid);",
            "\tattach_pid(task, type);",
            "}",
            "void exchange_tids(struct task_struct *left, struct task_struct *right)",
            "{",
            "\tstruct pid *pid1 = left->thread_pid;",
            "\tstruct pid *pid2 = right->thread_pid;",
            "\tstruct hlist_head *head1 = &pid1->tasks[PIDTYPE_PID];",
            "\tstruct hlist_head *head2 = &pid2->tasks[PIDTYPE_PID];",
            "",
            "\t/* Swap the single entry tid lists */",
            "\thlists_swap_heads_rcu(head1, head2);",
            "",
            "\t/* Swap the per task_struct pid */",
            "\trcu_assign_pointer(left->thread_pid, pid2);",
            "\trcu_assign_pointer(right->thread_pid, pid1);",
            "",
            "\t/* Swap the cached value */",
            "\tWRITE_ONCE(left->pid, pid_nr(pid2));",
            "\tWRITE_ONCE(right->pid, pid_nr(pid1));",
            "}"
          ],
          "function_name": "put_pid, delayed_put_pid, free_pid, disable_pid_allocation, attach_pid, __change_pid, detach_pid, change_pid, exchange_tids",
          "description": "实现PID引用计数管理、释放逻辑及任务PID绑定操作，通过锁保护PID分配状态变更，利用RCU机制延迟释放内存，并处理进程ID类型切换和线程ID交换。",
          "similarity": 0.6078485250473022
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/pid.c",
          "start_line": 1,
          "end_line": 108,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Generic pidhash and scalable, time-bounded PID allocator",
            " *",
            " * (C) 2002-2003 Nadia Yvette Chambers, IBM",
            " * (C) 2004 Nadia Yvette Chambers, Oracle",
            " * (C) 2002-2004 Ingo Molnar, Red Hat",
            " *",
            " * pid-structures are backing objects for tasks sharing a given ID to chain",
            " * against. There is very little to them aside from hashing them and",
            " * parking tasks using given ID's on a list.",
            " *",
            " * The hash is always changed with the tasklist_lock write-acquired,",
            " * and the hash is only accessed with the tasklist_lock at least",
            " * read-acquired, so there's no additional SMP locking needed here.",
            " *",
            " * We have a list of bitmap pages, which bitmaps represent the PID space.",
            " * Allocating and freeing PIDs is completely lockless. The worst-case",
            " * allocation scenario when all but one out of 1 million PIDs possible are",
            " * allocated already: the scanning of 32 list entries and at most PAGE_SIZE",
            " * bytes. The typical fastpath is a single successful setbit. Freeing is O(1).",
            " *",
            " * Pid namespaces:",
            " *    (C) 2007 Pavel Emelyanov <xemul@openvz.org>, OpenVZ, SWsoft Inc.",
            " *    (C) 2007 Sukadev Bhattiprolu <sukadev@us.ibm.com>, IBM",
            " *     Many thanks to Oleg Nesterov for comments and help",
            " *",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/rculist.h>",
            "#include <linux/memblock.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/refcount.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/idr.h>",
            "#include <linux/pidfs.h>",
            "#include <linux/seqlock.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/pidfd.h>",
            "",
            "struct pid init_struct_pid = {",
            "\t.count\t\t= REFCOUNT_INIT(1),",
            "\t.tasks\t\t= {",
            "\t\t{ .first = NULL },",
            "\t\t{ .first = NULL },",
            "\t\t{ .first = NULL },",
            "\t},",
            "\t.level\t\t= 0,",
            "\t.numbers\t= { {",
            "\t\t.nr\t\t= 0,",
            "\t\t.ns\t\t= &init_pid_ns,",
            "\t}, }",
            "};",
            "",
            "int pid_max = PID_MAX_DEFAULT;",
            "",
            "int pid_max_min = RESERVED_PIDS + 1;",
            "int pid_max_max = PID_MAX_LIMIT;",
            "",
            "/*",
            " * PID-map pages start out as NULL, they get allocated upon",
            " * first use and are never deallocated. This way a low pid_max",
            " * value does not cause lots of bitmaps to be allocated, but",
            " * the scheme scales to up to 4 million PIDs, runtime.",
            " */",
            "struct pid_namespace init_pid_ns = {",
            "\t.ns.count = REFCOUNT_INIT(2),",
            "\t.idr = IDR_INIT(init_pid_ns.idr),",
            "\t.pid_allocated = PIDNS_ADDING,",
            "\t.level = 0,",
            "\t.child_reaper = &init_task,",
            "\t.user_ns = &init_user_ns,",
            "\t.ns.inum = PROC_PID_INIT_INO,",
            "#ifdef CONFIG_PID_NS",
            "\t.ns.ops = &pidns_operations,",
            "#endif",
            "#if defined(CONFIG_SYSCTL) && defined(CONFIG_MEMFD_CREATE)",
            "\t.memfd_noexec_scope = MEMFD_NOEXEC_SCOPE_EXEC,",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_pid_ns);",
            "",
            "/*",
            " * Note: disable interrupts while the pidmap_lock is held as an",
            " * interrupt might come in and do read_lock(&tasklist_lock).",
            " *",
            " * If we don't disable interrupts there is a nasty deadlock between",
            " * detach_pid()->free_pid() and another cpu that does",
            " * spin_lock(&pidmap_lock) followed by an interrupt routine that does",
            " * read_lock(&tasklist_lock);",
            " *",
            " * After we clean up the tasklist_lock and know there are no",
            " * irq handlers that take it we can leave the interrupts enabled.",
            " * For now it is easier to be safe than to prove it can't happen.",
            " */",
            "",
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);",
            "seqcount_spinlock_t pidmap_lock_seq = SEQCNT_SPINLOCK_ZERO(pidmap_lock_seq, &pidmap_lock);",
            ""
          ],
          "function_name": null,
          "description": "定义了PID命名空间和PID结构体的初始状态，包括全局PID最大值限制、PID映射锁及序列化机制，用于支持多层级PID分配和命名空间隔离。",
          "similarity": 0.5693567395210266
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/pid.c",
          "start_line": 402,
          "end_line": 488,
          "content": [
            "void transfer_pid(struct task_struct *old, struct task_struct *new,",
            "\t\t\t   enum pid_type type)",
            "{",
            "\tWARN_ON_ONCE(type == PIDTYPE_PID);",
            "\thlist_replace_rcu(&old->pid_links[type], &new->pid_links[type]);",
            "}",
            "pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)",
            "{",
            "\tstruct upid *upid;",
            "\tpid_t nr = 0;",
            "",
            "\tif (pid && ns->level <= pid->level) {",
            "\t\tupid = &pid->numbers[ns->level];",
            "\t\tif (upid->ns == ns)",
            "\t\t\tnr = upid->nr;",
            "\t}",
            "\treturn nr;",
            "}",
            "pid_t pid_vnr(struct pid *pid)",
            "{",
            "\treturn pid_nr_ns(pid, task_active_pid_ns(current));",
            "}",
            "pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,",
            "\t\t\tstruct pid_namespace *ns)",
            "{",
            "\tpid_t nr = 0;",
            "",
            "\trcu_read_lock();",
            "\tif (!ns)",
            "\t\tns = task_active_pid_ns(current);",
            "\tnr = pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);",
            "\trcu_read_unlock();",
            "",
            "\treturn nr;",
            "}",
            "static int pidfd_create(struct pid *pid, unsigned int flags)",
            "{",
            "\tint pidfd;",
            "\tstruct file *pidfd_file;",
            "",
            "\tpidfd = pidfd_prepare(pid, flags, &pidfd_file);",
            "\tif (pidfd < 0)",
            "\t\treturn pidfd;",
            "",
            "\tfd_install(pidfd, pidfd_file);",
            "\treturn pidfd;",
            "}",
            "void __init pid_idr_init(void)",
            "{",
            "\t/* Verify no one has done anything silly: */",
            "\tBUILD_BUG_ON(PID_MAX_LIMIT >= PIDNS_ADDING);",
            "",
            "\t/* bump default and minimum pid_max based on number of cpus */",
            "\tpid_max = min(pid_max_max, max_t(int, pid_max,",
            "\t\t\t\tPIDS_PER_CPU_DEFAULT * num_possible_cpus()));",
            "\tpid_max_min = max_t(int, pid_max_min,",
            "\t\t\t\tPIDS_PER_CPU_MIN * num_possible_cpus());",
            "\tpr_info(\"pid_max: default: %u minimum: %u\\n\", pid_max, pid_max_min);",
            "",
            "\tidr_init(&init_pid_ns.idr);",
            "",
            "\tinit_pid_ns.pid_cachep = kmem_cache_create(\"pid\",",
            "\t\t\tstruct_size_t(struct pid, numbers, 1),",
            "\t\t\t__alignof__(struct pid),",
            "\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT,",
            "\t\t\tNULL);",
            "}",
            "static int pidfd_getfd(struct pid *pid, int fd)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct file *file;",
            "\tint ret;",
            "",
            "\ttask = get_pid_task(pid, PIDTYPE_PID);",
            "\tif (!task)",
            "\t\treturn -ESRCH;",
            "",
            "\tfile = __pidfd_fget(task, fd);",
            "\tput_task_struct(task);",
            "\tif (IS_ERR(file))",
            "\t\treturn PTR_ERR(file);",
            "",
            "\tret = receive_fd(file, O_CLOEXEC);",
            "\tfput(file);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "transfer_pid, pid_nr_ns, pid_vnr, __task_pid_nr_ns, pidfd_create, pid_idr_init, pidfd_getfd",
          "description": "提供跨命名空间PID查询接口及文件描述符创建功能，初始化ID分配器并配置PID命名空间层级关系，支持基于IDR的高效PID索引管理。",
          "similarity": 0.5677196979522705
        }
      ]
    },
    {
      "source_file": "kernel/pid_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:16:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_namespace.c`\n\n---\n\n# `pid_namespace.c` 技术文档\n\n## 1. 文件概述\n\n`pid_namespace.c` 是 Linux 内核中实现 **PID 命名空间（PID Namespace）** 的核心源文件。PID 命名空间是 Linux 容器技术（如 Docker、LXC）的关键基础组件之一，用于为不同进程组提供隔离的进程 ID 视图。每个 PID 命名空间拥有独立的 PID 分配空间，使得不同命名空间中的进程可以拥有相同的 PID 而互不干扰。\n\n该文件负责 PID 命名空间的创建、销毁、引用计数管理、资源回收以及命名空间内进程的批量终止（如容器退出时清理所有子进程）等核心功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct pid_namespace`：表示一个 PID 命名空间，包含：\n  - `level`：命名空间层级（init_pid_ns 为 0，子命名空间依次递增）\n  - `parent`：指向父命名空间的指针\n  - `user_ns`：关联的用户命名空间\n  - `idr`：用于分配和管理 PID 的 IDR（整数到指针映射）结构\n  - `pid_cachep`：用于分配 `struct pid` 对象的 slab 缓存\n  - `pid_allocated`：当前命名空间中已分配的 PID 数量\n  - `ucounts`：用于限制用户命名空间下 PID 命名空间数量的计数器\n\n### 主要函数\n- `create_pid_cachep(unsigned int level)`  \n  为指定层级的 PID 命名空间创建专用的 `struct pid` slab 缓存。\n  \n- `create_pid_namespace(struct user_namespace *user_ns, struct pid_namespace *parent_pid_ns)`  \n  创建一个新的 PID 命名空间，设置层级、父命名空间、用户命名空间等属性，并初始化 IDR 和引用计数。\n\n- `copy_pid_ns(unsigned long flags, struct user_namespace *user_ns, struct pid_namespace *old_ns)`  \n  在 `clone()` 或 `unshare()` 系统调用中被调用，根据 `CLONE_NEWPID` 标志决定是否创建新的 PID 命名空间。\n\n- `put_pid_ns(struct pid_namespace *ns)`  \n  递减 PID 命名空间的引用计数，若引用计数归零则递归销毁该命名空间及其子命名空间。\n\n- `zap_pid_ns_processes(struct pid_namespace *pid_ns)`  \n  在 PID 命名空间的 init 进程退出时调用，向命名空间内所有剩余进程发送 `SIGKILL`，并等待其全部退出，确保命名空间干净回收。\n\n- `delayed_free_pidns(struct rcu_head *p)`  \n  通过 RCU 机制延迟释放 PID 命名空间结构体，确保所有并发读取完成后再释放内存。\n\n## 3. 关键实现\n\n### PID 命名空间层级与缓存管理\n- PID 命名空间支持嵌套，最大深度由 `MAX_PID_NS_LEVEL` 限制（通常为 32）。\n- 每个层级使用独立的 slab 缓存（`pid_cache[level - 1]`）来分配 `struct pid`，因为 `struct pid` 中的 `numbers[]` 数组大小依赖于命名空间层级（`level + 1`）。\n- 缓存创建通过 `create_pid_cachep()` 实现，使用互斥锁 `pid_caches_mutex` 避免并发创建冲突。\n\n### 引用计数与生命周期管理\n- 使用 `refcount_t` 管理命名空间引用计数。\n- `put_pid_ns()` 采用**尾递归方式**向上遍历父命名空间链，逐级释放无引用的命名空间。\n- 实际内存释放通过 RCU 回调 `delayed_free_pidns()` 延迟执行，保证并发安全。\n\n### 命名空间退出清理机制（`zap_pid_ns_processes`）\n- **禁用新 PID 分配**：调用 `disable_pid_allocation()` 阻止新进程加入。\n- **忽略 SIGCHLD**：使 init 进程自动回收僵尸子进程，避免阻塞。\n- **批量 SIGKILL**：遍历 IDR 中所有 PID，向对应进程发送 `SIGKILL`。\n- **等待所有进程退出**：通过 `kernel_wait4()` 回收直接子进程，并通过检查 `pid_allocated == init_pids` 确保所有进程（包括跨命名空间 fork 的僵尸进程）均已退出。\n- **RCU 安全调度**：在等待循环中调用 `exit_tasks_rcu_stop/start()` 避免与 `synchronize_rcu_tasks()` 死锁。\n\n### 资源限制\n- 通过 `inc_pid_namespaces()` / `dec_pid_namespaces()` 调用 `ucounts` 机制，限制每个用户命名空间可创建的 PID 命名空间数量，防止资源耗尽。\n\n## 4. 依赖关系\n\n- **`<linux/pid.h>` / `<linux/pid_namespace.h>`**：定义 `struct pid` 和 `struct pid_namespace`。\n- **`<linux/user_namespace.h>`**：依赖用户命名空间进行权限和资源限制。\n- **`<linux/idr.h>`**：使用 IDR 数据结构管理 PID 分配。\n- **`<linux/slab.h>`**：使用 kmem_cache 管理内存分配。\n- **`<linux/sched/*.h>`**：访问任务结构、信号处理、RCU 任务同步等。\n- **`<linux/proc_ns.h>`**：支持 `/proc/[pid]/ns/pid` 接口。\n- **`\"pid_sysctl.h\"`**：提供 sysctl 配置（如 `memfd_noexec_scope`）。\n- **`<linux/acct.h>`**：在命名空间销毁时清理进程会计信息。\n\n## 5. 使用场景\n\n- **容器启动**：当执行 `unshare(CLONE_NEWPID)` 或 `clone(CLONE_NEWPID)` 时，内核调用 `copy_pid_ns()` 创建新的 PID 命名空间，使容器内进程拥有独立的 PID 视图（容器内 PID 1 对应宿主机某个高 PID）。\n- **容器退出**：当容器的 init 进程（PID 1）退出时，内核自动调用 `zap_pid_ns_processes()` 终止命名空间内所有剩余进程，防止孤儿进程泄漏。\n- **命名空间嵌套**：支持多层容器或 sandbox 场景，如 systemd-nspawn 嵌套运行容器。\n- **资源隔离与限制**：结合用户命名空间，限制非特权用户创建过多 PID 命名空间，提升系统安全性。\n- **进程迁移与检查点**：配合 CRIU（Checkpoint/Restore in Userspace）等工具，通过 sysctl 接口控制命名空间行为（如 memfd 执行权限）。",
      "similarity": 0.6294424533843994,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 68,
          "end_line": 208,
          "content": [
            "static void dec_pid_namespaces(struct ucounts *ucounts)",
            "{",
            "\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);",
            "}",
            "static void delayed_free_pidns(struct rcu_head *p)",
            "{",
            "\tstruct pid_namespace *ns = container_of(p, struct pid_namespace, rcu);",
            "",
            "\tdec_pid_namespaces(ns->ucounts);",
            "\tput_user_ns(ns->user_ns);",
            "",
            "\tkmem_cache_free(pid_ns_cachep, ns);",
            "}",
            "static void destroy_pid_namespace(struct pid_namespace *ns)",
            "{",
            "\tns_free_inum(&ns->ns);",
            "",
            "\tidr_destroy(&ns->idr);",
            "\tcall_rcu(&ns->rcu, delayed_free_pidns);",
            "}",
            "void put_pid_ns(struct pid_namespace *ns)",
            "{",
            "\tstruct pid_namespace *parent;",
            "",
            "\twhile (ns != &init_pid_ns) {",
            "\t\tparent = ns->parent;",
            "\t\tif (!refcount_dec_and_test(&ns->ns.count))",
            "\t\t\tbreak;",
            "\t\tdestroy_pid_namespace(ns);",
            "\t\tns = parent;",
            "\t}",
            "}",
            "void zap_pid_ns_processes(struct pid_namespace *pid_ns)",
            "{",
            "\tint nr;",
            "\tint rc;",
            "\tstruct task_struct *task, *me = current;",
            "\tint init_pids = thread_group_leader(me) ? 1 : 2;",
            "\tstruct pid *pid;",
            "",
            "\t/* Don't allow any more processes into the pid namespace */",
            "\tdisable_pid_allocation(pid_ns);",
            "",
            "\t/*",
            "\t * Ignore SIGCHLD causing any terminated children to autoreap.",
            "\t * This speeds up the namespace shutdown, plus see the comment",
            "\t * below.",
            "\t */",
            "\tspin_lock_irq(&me->sighand->siglock);",
            "\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;",
            "\tspin_unlock_irq(&me->sighand->siglock);",
            "",
            "\t/*",
            "\t * The last thread in the cgroup-init thread group is terminating.",
            "\t * Find remaining pid_ts in the namespace, signal and wait for them",
            "\t * to exit.",
            "\t *",
            "\t * Note:  This signals each threads in the namespace - even those that",
            "\t * \t  belong to the same thread group, To avoid this, we would have",
            "\t * \t  to walk the entire tasklist looking a processes in this",
            "\t * \t  namespace, but that could be unnecessarily expensive if the",
            "\t * \t  pid namespace has just a few processes. Or we need to",
            "\t * \t  maintain a tasklist for each pid namespace.",
            "\t *",
            "\t */",
            "\trcu_read_lock();",
            "\tread_lock(&tasklist_lock);",
            "\tnr = 2;",
            "\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {",
            "\t\ttask = pid_task(pid, PIDTYPE_PID);",
            "\t\tif (task && !__fatal_signal_pending(task))",
            "\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.",
            "\t * kernel_wait4() will also block until our children traced from the",
            "\t * parent namespace are detached and become EXIT_DEAD.",
            "\t */",
            "\tdo {",
            "\t\tclear_thread_flag(TIF_SIGPENDING);",
            "\t\tclear_thread_flag(TIF_NOTIFY_SIGNAL);",
            "\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);",
            "\t} while (rc != -ECHILD);",
            "",
            "\t/*",
            "\t * kernel_wait4() misses EXIT_DEAD children, and EXIT_ZOMBIE",
            "\t * process whose parents processes are outside of the pid",
            "\t * namespace.  Such processes are created with setns()+fork().",
            "\t *",
            "\t * If those EXIT_ZOMBIE processes are not reaped by their",
            "\t * parents before their parents exit, they will be reparented",
            "\t * to pid_ns->child_reaper.  Thus pidns->child_reaper needs to",
            "\t * stay valid until they all go away.",
            "\t *",
            "\t * The code relies on the pid_ns->child_reaper ignoring",
            "\t * SIGCHILD to cause those EXIT_ZOMBIE processes to be",
            "\t * autoreaped if reparented.",
            "\t *",
            "\t * Semantically it is also desirable to wait for EXIT_ZOMBIE",
            "\t * processes before allowing the child_reaper to be reaped, as",
            "\t * that gives the invariant that when the init process of a",
            "\t * pid namespace is reaped all of the processes in the pid",
            "\t * namespace are gone.",
            "\t *",
            "\t * Once all of the other tasks are gone from the pid_namespace",
            "\t * free_pid() will awaken this task.",
            "\t */",
            "\tfor (;;) {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tif (pid_ns->pid_allocated == init_pids)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * Release tasks_rcu_exit_srcu to avoid following deadlock:",
            "\t\t *",
            "\t\t * 1) TASK A unshare(CLONE_NEWPID)",
            "\t\t * 2) TASK A fork() twice -> TASK B (child reaper for new ns)",
            "\t\t *    and TASK C",
            "\t\t * 3) TASK B exits, kills TASK C, waits for TASK A to reap it",
            "\t\t * 4) TASK A calls synchronize_rcu_tasks()",
            "\t\t *                   -> synchronize_srcu(tasks_rcu_exit_srcu)",
            "\t\t * 5) *DEADLOCK*",
            "\t\t *",
            "\t\t * It is considered safe to release tasks_rcu_exit_srcu here",
            "\t\t * because we assume the current task can not be concurrently",
            "\t\t * reaped at this point.",
            "\t\t */",
            "\t\texit_tasks_rcu_stop();",
            "\t\tschedule();",
            "\t\texit_tasks_rcu_start();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tif (pid_ns->reboot)",
            "\t\tcurrent->signal->group_exit_code = pid_ns->reboot;",
            "",
            "\tacct_exit_ns(pid_ns);",
            "\treturn;",
            "}"
          ],
          "function_name": "dec_pid_namespaces, delayed_free_pidns, destroy_pid_namespace, put_pid_ns, zap_pid_ns_processes",
          "description": "包含销毁pid命名空间相关函数，其中destroy_pid_namespace通过RCU机制延迟释放资源，zap_pid_ns_processes强制终止命名空间内所有进程并回收资源，put_pid_ns管理命名空间引用计数",
          "similarity": 0.6370430588722229
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 281,
          "end_line": 379,
          "content": [
            "static int pid_ns_ctl_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);",
            "\tstruct ctl_table tmp = *table;",
            "\tint ret, next;",
            "",
            "\tif (write && !checkpoint_restore_ns_capable(pid_ns->user_ns))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Writing directly to ns' last_pid field is OK, since this field",
            "\t * is volatile in a living namespace anyway and a code writing to",
            "\t * it should synchronize its usage with external means.",
            "\t */",
            "",
            "\tnext = idr_get_cursor(&pid_ns->idr) - 1;",
            "",
            "\ttmp.data = &next;",
            "\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);",
            "\tif (!ret && write)",
            "\t\tidr_set_cursor(&pid_ns->idr, next + 1);",
            "",
            "\treturn ret;",
            "}",
            "int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)",
            "{",
            "\tif (pid_ns == &init_pid_ns)",
            "\t\treturn 0;",
            "",
            "\tswitch (cmd) {",
            "\tcase LINUX_REBOOT_CMD_RESTART2:",
            "\tcase LINUX_REBOOT_CMD_RESTART:",
            "\t\tpid_ns->reboot = SIGHUP;",
            "\t\tbreak;",
            "",
            "\tcase LINUX_REBOOT_CMD_POWER_OFF:",
            "\tcase LINUX_REBOOT_CMD_HALT:",
            "\t\tpid_ns->reboot = SIGINT;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tsend_sig(SIGKILL, pid_ns->child_reaper, 1);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tdo_exit(0);",
            "",
            "\t/* Not reached */",
            "\treturn 0;",
            "}",
            "static void pidns_put(struct ns_common *ns)",
            "{",
            "\tput_pid_ns(to_pid_ns(ns));",
            "}",
            "static int pidns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct nsproxy *nsproxy = nsset->nsproxy;",
            "\tstruct pid_namespace *active = task_active_pid_ns(current);",
            "\tstruct pid_namespace *ancestor, *new = to_pid_ns(ns);",
            "",
            "\tif (!ns_capable(new->user_ns, CAP_SYS_ADMIN) ||",
            "\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Only allow entering the current active pid namespace",
            "\t * or a child of the current active pid namespace.",
            "\t *",
            "\t * This is required for fork to return a usable pid value and",
            "\t * this maintains the property that processes and their",
            "\t * children can not escape their current pid namespace.",
            "\t */",
            "\tif (new->level < active->level)",
            "\t\treturn -EINVAL;",
            "",
            "\tancestor = new;",
            "\twhile (ancestor->level > active->level)",
            "\t\tancestor = ancestor->parent;",
            "\tif (ancestor != active)",
            "\t\treturn -EINVAL;",
            "",
            "\tput_pid_ns(nsproxy->pid_ns_for_children);",
            "\tnsproxy->pid_ns_for_children = get_pid_ns(new);",
            "\treturn 0;",
            "}",
            "static __init int pid_namespaces_init(void)",
            "{",
            "\tpid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC | SLAB_ACCOUNT);",
            "",
            "#ifdef CONFIG_CHECKPOINT_RESTORE",
            "\tregister_sysctl_init(\"kernel\", pid_ns_ctl_table);",
            "#endif",
            "",
            "\tregister_pid_ns_sysctl_table_vm();",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pid_ns_ctl_handler, reboot_pid_ns, pidns_put, pidns_install, pid_namespaces_init",
          "description": "包含pid命名空间控制接口处理函数pid_ns_ctl_handler，reboot_pid_ns设置命名空间重启信号，pidns_install验证命名空间层级权限并进行安装操作，pid_namespaces_init完成核心数据结构初始化和sysctl注册",
          "similarity": 0.6148794293403625
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 1,
          "end_line": 67,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Pid namespaces",
            " *",
            " * Authors:",
            " *    (C) 2007 Pavel Emelyanov <xemul@openvz.org>, OpenVZ, SWsoft Inc.",
            " *    (C) 2007 Sukadev Bhattiprolu <sukadev@us.ibm.com>, IBM",
            " *     Many thanks to Oleg Nesterov for comments and help",
            " *",
            " */",
            "",
            "#include <linux/pid.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cred.h>",
            "#include <linux/err.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/reboot.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/idr.h>",
            "#include <uapi/linux/wait.h>",
            "#include \"pid_sysctl.h\"",
            "",
            "static DEFINE_MUTEX(pid_caches_mutex);",
            "static struct kmem_cache *pid_ns_cachep;",
            "/* Write once array, filled from the beginning. */",
            "static struct kmem_cache *pid_cache[MAX_PID_NS_LEVEL];",
            "",
            "/*",
            " * creates the kmem cache to allocate pids from.",
            " * @level: pid namespace level",
            " */",
            "",
            "static struct kmem_cache *create_pid_cachep(unsigned int level)",
            "{",
            "\t/* Level 0 is init_pid_ns.pid_cachep */",
            "\tstruct kmem_cache **pkc = &pid_cache[level - 1];",
            "\tstruct kmem_cache *kc;",
            "\tchar name[4 + 10 + 1];",
            "\tunsigned int len;",
            "",
            "\tkc = READ_ONCE(*pkc);",
            "\tif (kc)",
            "\t\treturn kc;",
            "",
            "\tsnprintf(name, sizeof(name), \"pid_%u\", level + 1);",
            "\tlen = struct_size_t(struct pid, numbers, level + 1);",
            "\tmutex_lock(&pid_caches_mutex);",
            "\t/* Name collision forces to do allocation under mutex. */",
            "\tif (!*pkc)",
            "\t\t*pkc = kmem_cache_create(name, len, 0,",
            "\t\t\t\t\t SLAB_HWCACHE_ALIGN | SLAB_ACCOUNT, NULL);",
            "\tmutex_unlock(&pid_caches_mutex);",
            "\t/* current can fail, but someone else can succeed. */",
            "\treturn READ_ONCE(*pkc);",
            "}",
            "",
            "static struct ucounts *inc_pid_namespaces(struct user_namespace *ns)",
            "{",
            "\treturn inc_ucount(ns, current_euid(), UCOUNT_PID_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用于管理pid命名空间的kmem缓存创建函数create_pid_cachep，根据层级参数为不同pid命名空间级别创建专用内存池；inc_pid_namespaces函数用于增加用户命名空间的使用计数",
          "similarity": 0.560853123664856
        }
      ]
    },
    {
      "source_file": "kernel/pid_sysctl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_sysctl.h`\n\n---\n\n# `pid_sysctl.h` 技术文档\n\n## 1. 文件概述\n\n`pid_sysctl.h` 是 Linux 内核中用于定义与 PID 命名空间（`pid_namespace`）相关的系统控制（sysctl）接口的头文件。其核心功能是提供对 `memfd_noexec` 系统策略的运行时配置支持，该策略用于控制通过 `memfd_create()` 创建的内存文件是否允许执行代码。该配置具有层级继承语义：子 PID 命名空间的策略不能比其父命名空间更宽松，以确保安全策略的向下兼容性和强制性。\n\n## 2. 核心功能\n\n### 函数\n\n- **`pid_mfd_noexec_dointvec_minmax`**  \n  自定义的 sysctl 处理函数，用于读写 `memfd_noexec` 策略值。在写入时执行权限检查和策略继承约束验证。\n\n- **`register_pid_ns_sysctl_table_vm`**  \n  内联函数，用于向内核 sysctl 子系统注册 `vm.memfd_noexec` 控制项（仅在 `CONFIG_SYSCTL` 和 `CONFIG_MEMFD_CREATE` 同时启用时有效）。\n\n### 数据结构\n\n- **`pid_ns_ctl_table_vm`**  \n  `ctl_table` 类型的静态数组，定义了 `vm.memfd_noexec` sysctl 条目，包括其名称、数据指针、访问权限、处理函数及取值范围（0 到 2）。\n\n## 3. 关键实现\n\n- **权限控制**：  \n  在写入 `memfd_noexec` 值时，调用 `ns_capable(ns->user_ns, CAP_SYS_ADMIN)` 检查当前任务是否在对应用户命名空间中拥有 `CAP_SYS_ADMIN` 能力，防止非特权用户修改安全策略。\n\n- **策略继承约束**：  \n  通过 `pidns_memfd_noexec_scope(ns->parent)` 获取父 PID 命名空间的策略值 `parent_scope`，并确保当前命名空间的策略值 `scope` 不小于父策略（即不能更宽松）。实际写入前使用 `max(READ_ONCE(ns->memfd_noexec_scope), parent_scope)` 保证该约束。\n\n- **原子读写**：  \n  使用 `READ_ONCE()` 和 `WRITE_ONCE()` 对 `ns->memfd_noexec_scope` 进行访问，确保在并发环境下内存访问的可见性和顺序性。\n\n- **sysctl 注册**：  \n  通过 `register_sysctl(\"vm\", pid_ns_ctl_table_vm)` 将控制项注册到 `/proc/sys/vm/memfd_noexec` 路径下，供用户空间通过标准 sysctl 接口访问。\n\n- **条件编译**：  \n  整个功能仅在 `CONFIG_SYSCTL`（启用 sysctl 支持）和 `CONFIG_MEMFD_CREATE`（启用 memfd_create 系统调用）同时配置时编译，否则 `register_pid_ns_sysctl_table_vm` 为空内联函数，避免代码膨胀。\n\n## 4. 依赖关系\n\n- **`<linux/pid_namespace.h>`**：  \n  提供 `struct pid_namespace` 定义及辅助函数如 `task_active_pid_ns()` 和 `pidns_memfd_noexec_scope()`。\n\n- **`CONFIG_SYSCTL`**：  \n  内核配置选项，启用 sysctl 框架支持，提供 `register_sysctl`、`proc_dointvec_minmax` 等接口。\n\n- **`CONFIG_MEMFD_CREATE`**：  \n  内核配置选项，启用 `memfd_create()` 系统调用及相关功能（如 `memfd_noexec_scope` 字段）。\n\n- **能力子系统（Capabilities）**：  \n  依赖 `ns_capable()` 进行命名空间感知的权限检查。\n\n## 5. 使用场景\n\n- **安全策略配置**：  \n  系统管理员或容器运行时可通过写入 `/proc/sys/vm/memfd_noexec` 设置当前 PID 命名空间中 `memfd` 文件的执行限制级别（0=允许执行，1=禁止执行但可覆盖，2=严格禁止执行），用于防御基于内存文件的代码注入攻击。\n\n- **容器隔离**：  \n  在容器化环境中，不同容器运行在独立的 PID 命名空间中。父命名空间（如宿主机）可设置较严格的 `memfd_noexec` 策略，子容器无法降低该策略级别，从而实现自上而下的安全策略强制。\n\n- **运行时动态调整**：  \n  允许在系统运行期间动态调整 `memfd` 执行策略，无需重启或重新加载内核模块，提升系统灵活性与安全性。",
      "similarity": 0.6292639970779419,
      "chunks": []
    }
  ]
}