{
  "query": "Linux页表管理源码分析",
  "timestamp": "2025-12-20 17:28:45",
  "retrieved_files": [
    {
      "source_file": "mm/swap.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:25:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `swap.c`\n\n---\n\n# swap.c 技术文档\n\n## 1. 文件概述\n\n`swap.c` 是 Linux 内核内存管理子系统（MM）中的核心文件之一，主要负责页面回收（page reclaim）、LRU（Least Recently Used）链表管理、页面释放以及与交换（swap）机制相关的底层支持逻辑。尽管文件名为 `swap.c`，但其功能不仅限于交换，而是涵盖了通用的页面生命周期管理、LRU 链表操作、页面引用计数释放、可回收性判断等关键内存管理任务。该文件为页面缓存（page cache）、匿名页（anonymous pages）和大页（huge pages）提供统一的释放与 LRU 管理接口。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `page_cluster`：控制一次 I/O 操作中尝试换入/换出的页面数量（以 2 的幂表示），默认值由系统配置决定。\n- `page_cluster_max`：`page_cluster` 的最大允许值（31，即最多 2^31 页，实际受架构限制）。\n\n### 主要数据结构\n- `struct lru_rotate`：每个 CPU 私有的结构，用于在中断禁用上下文中批量处理需移至 LRU 链表尾部的页面（如 `folio_rotate_reclaimable` 场景）。\n- `struct cpu_fbatches`：每个 CPU 私有的 folio 批处理结构，包含多个 folio_batch，用于高效地向 LRU 链表添加、停用或激活页面，避免频繁获取 LRU 锁。\n\n### 主要函数\n- `__folio_put()`：释放一个 folio 的核心函数，根据 folio 类型（设备内存、大页、普通页）调用相应的释放路径。\n- `put_pages_list()`：批量释放通过 `lru` 字段链接的页面列表，常用于网络子系统或 compound page 释放。\n- `lru_add_fn()`：将 folio 添加到对应 LRU 链表的回调函数，处理可回收性（evictable/unevictable）状态转换和统计计数。\n- `folio_batch_move_lru()`：批量执行 LRU 操作（如添加、移动），在持有 LRU 锁期间完成所有 folio 的处理。\n- `folio_rotate_reclaimable()`：在写回完成后，若页面仍可回收，则将其移至 inactive LRU 链表尾部，以延迟其被回收的时间。\n- `lru_note_cost()`：记录 LRU 扫描过程中的 I/O 和旋转（rotation）成本，用于后续调整 anon/file LRU 的扫描比例。\n\n## 3. 关键实现\n\n### LRU 批处理机制\n为减少 LRU 锁竞争，内核采用 per-CPU 批处理（`folio_batch`）方式暂存待处理的 folio。当批处理满或遇到大页（`folio_test_large`）时，才批量获取 LRU 锁并执行操作（如 `lru_add_fn`）。这显著提升了高并发场景下的性能。\n\n### 可回收性管理\n页面是否可回收由 `folio_evictable()` 判断，主要依据是否被 mlock 锁定。在添加到 LRU 时：\n- 若页面变为可回收（原为 unevictable），则增加 `UNEVICTABLE_PGRESCUED` 统计；\n- 若页面不可回收，则清除 active 标志，设置 unevictable 标志，并重置 `mlock_count`，同时增加 `UNEVICTABLE_PGCULLED` 统计。\n\n### 页面释放路径\n`__folio_put()` 是 folio 引用计数归零后的释放入口：\n1. 设备内存 folio 调用 `free_zone_device_folio()`\n2. 大页 folio 调用 `free_huge_folio()`\n3. 普通 folio 先从 LRU 移除（若在 LRU 上），然后解绑内存控制组（memcg），最后调用 `free_unref_page()` 释放到伙伴系统。\n\n### LRU 旋转优化\n`folio_rotate_reclaimable()` 在写回结束时，若页面干净且未锁定，则将其移至 inactive LRU 尾部。此操作通过 per-CPU 的 `lru_rotate` 批处理完成，仅在必要时获取 LRU 锁，避免影响写回关键路径性能。\n\n### 成本跟踪\n`lru_note_cost()` 通过累加 `nr_io * SWAP_CLUSTER_MAX + nr_rotated` 来量化扫描成本，用于动态调整匿名页与文件页 LRU 的扫描比例，优化内存回收效率。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/pagevec.h>`、`\"internal.h\"` 等，使用伙伴系统、LRU 框架、内存控制组（memcg）等基础组件。\n- **交换子系统**：虽不直接实现 swap read/write，但为 `vmscan.c` 中的页面回收提供 LRU 操作接口，是 swap 机制的支撑模块。\n- **大页支持**：通过 `hugetlb.h` 与大页子系统交互，特殊处理大页释放。\n- **设备内存**：通过 `memremap.h` 支持持久内存（pmem）等 zone device 页面的释放。\n- **跟踪与统计**：使用 tracepoint（`trace/events/pagemap.h`）和 VM 统计（`kernel_stat.h`）进行性能分析。\n- **SMP 支持**：大量使用 per-CPU 变量（`DEFINE_PER_CPU`）和本地锁（`local_lock_t`）优化多核性能。\n\n## 5. 使用场景\n\n- **页面回收（Reclaim）**：当内存压力触发 kswapd 或 direct reclaim 时，`vmscan.c` 调用本文件的 LRU 操作函数来隔离、释放页面。\n- **页面缓存释放**：文件系统或网络子系统在释放 page cache 页面时，通过 `__folio_put()` 或 `put_pages_list()` 触发 LRU 移除和内存释放。\n- **写回完成处理**：块设备或文件系统在完成脏页写回后，调用 `folio_rotate_reclaimable()` 更新页面在 LRU 中的位置。\n- **内存控制组（cgroup）**：memcg 回收内存时，复用本文件的 LRU 批处理和 folio 释放逻辑。\n- **大页与设备内存管理**：透明大页（THP）或持久内存应用释放页面时，通过统一的 `__folio_put()` 接口分发到专用释放函数。\n- **系统调优**：管理员通过 `/proc/sys/vm/page-cluster` 调整 `page_cluster` 值，影响 swap 和 page cache 的 I/O 批量大小。",
      "similarity": 0.625924825668335,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/swap.c",
          "start_line": 77,
          "end_line": 190,
          "content": [
            "static void __page_cache_release(struct folio *folio, struct lruvec **lruvecp,",
            "\t\tunsigned long *flagsp)",
            "{",
            "\tif (folio_test_lru(folio)) {",
            "\t\tfolio_lruvec_relock_irqsave(folio, lruvecp, flagsp);",
            "\t\tlruvec_del_folio(*lruvecp, folio);",
            "\t\t__folio_clear_lru_flags(folio);",
            "\t}",
            "}",
            "static void page_cache_release(struct folio *folio)",
            "{",
            "\tstruct lruvec *lruvec = NULL;",
            "\tunsigned long flags;",
            "",
            "\t__page_cache_release(folio, &lruvec, &flags);",
            "\tif (lruvec)",
            "\t\tunlock_page_lruvec_irqrestore(lruvec, flags);",
            "}",
            "void __folio_put(struct folio *folio)",
            "{",
            "\tif (unlikely(folio_is_zone_device(folio))) {",
            "\t\tfree_zone_device_folio(folio);",
            "\t\treturn;",
            "\t} else if (folio_test_hugetlb(folio)) {",
            "\t\tfree_huge_folio(folio);",
            "\t\treturn;",
            "\t}",
            "",
            "\tpage_cache_release(folio);",
            "\tfolio_unqueue_deferred_split(folio);",
            "\tmem_cgroup_uncharge(folio);",
            "\tfree_unref_page(&folio->page, folio_order(folio));",
            "}",
            "void put_pages_list(struct list_head *pages)",
            "{",
            "\tstruct folio_batch fbatch;",
            "\tstruct folio *folio, *next;",
            "",
            "\tfolio_batch_init(&fbatch);",
            "\tlist_for_each_entry_safe(folio, next, pages, lru) {",
            "\t\tif (!folio_put_testzero(folio))",
            "\t\t\tcontinue;",
            "\t\tif (folio_test_hugetlb(folio)) {",
            "\t\t\tfree_huge_folio(folio);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/* LRU flag must be clear because it's passed using the lru */",
            "\t\tif (folio_batch_add(&fbatch, folio) > 0)",
            "\t\t\tcontinue;",
            "\t\tfree_unref_folios(&fbatch);",
            "\t}",
            "",
            "\tif (fbatch.nr)",
            "\t\tfree_unref_folios(&fbatch);",
            "\tINIT_LIST_HEAD(pages);",
            "}",
            "static void lru_add_fn(struct lruvec *lruvec, struct folio *folio)",
            "{",
            "\tint was_unevictable = folio_test_clear_unevictable(folio);",
            "\tlong nr_pages = folio_nr_pages(folio);",
            "",
            "\tVM_BUG_ON_FOLIO(folio_test_lru(folio), folio);",
            "",
            "\t/*",
            "\t * Is an smp_mb__after_atomic() still required here, before",
            "\t * folio_evictable() tests the mlocked flag, to rule out the possibility",
            "\t * of stranding an evictable folio on an unevictable LRU?  I think",
            "\t * not, because __munlock_folio() only clears the mlocked flag",
            "\t * while the LRU lock is held.",
            "\t *",
            "\t * (That is not true of __page_cache_release(), and not necessarily",
            "\t * true of folios_put(): but those only clear the mlocked flag after",
            "\t * folio_put_testzero() has excluded any other users of the folio.)",
            "\t */",
            "\tif (folio_evictable(folio)) {",
            "\t\tif (was_unevictable)",
            "\t\t\t__count_vm_events(UNEVICTABLE_PGRESCUED, nr_pages);",
            "\t} else {",
            "\t\tfolio_clear_active(folio);",
            "\t\tfolio_set_unevictable(folio);",
            "\t\t/*",
            "\t\t * folio->mlock_count = !!folio_test_mlocked(folio)?",
            "\t\t * But that leaves __mlock_folio() in doubt whether another",
            "\t\t * actor has already counted the mlock or not.  Err on the",
            "\t\t * safe side, underestimate, let page reclaim fix it, rather",
            "\t\t * than leaving a page on the unevictable LRU indefinitely.",
            "\t\t */",
            "\t\tfolio->mlock_count = 0;",
            "\t\tif (!was_unevictable)",
            "\t\t\t__count_vm_events(UNEVICTABLE_PGCULLED, nr_pages);",
            "\t}",
            "",
            "\tlruvec_add_folio(lruvec, folio);",
            "\ttrace_mm_lru_insertion(folio);",
            "}",
            "static void folio_batch_move_lru(struct folio_batch *fbatch, move_fn_t move_fn)",
            "{",
            "\tint i;",
            "\tstruct lruvec *lruvec = NULL;",
            "\tunsigned long flags = 0;",
            "",
            "\tfor (i = 0; i < folio_batch_count(fbatch); i++) {",
            "\t\tstruct folio *folio = fbatch->folios[i];",
            "",
            "\t\tfolio_lruvec_relock_irqsave(folio, &lruvec, &flags);",
            "\t\tmove_fn(lruvec, folio);",
            "",
            "\t\tfolio_set_lru(folio);",
            "\t}",
            "",
            "\tif (lruvec)",
            "\t\tunlock_page_lruvec_irqrestore(lruvec, flags);",
            "\tfolios_put(fbatch);",
            "}"
          ],
          "function_name": "__page_cache_release, page_cache_release, __folio_put, put_pages_list, lru_add_fn, folio_batch_move_lru",
          "description": "实现了页面缓存释放和LRU列表维护逻辑，包含__page_cache_release用于从LRU列表移除页面，page_cache_release处理普通页面释放流程，__folio_put负责释放非设备映射和大页，put_pages_list批量处理页面释放，lru_add_fn将页面添加到LRU列表并根据是否可交换设置相应标志。",
          "similarity": 0.5840109586715698
        },
        {
          "chunk_id": 4,
          "file_path": "mm/swap.c",
          "start_line": 496,
          "end_line": 600,
          "content": [
            "void folio_add_lru(struct folio *folio)",
            "{",
            "\tstruct folio_batch *fbatch;",
            "",
            "\tVM_BUG_ON_FOLIO(folio_test_active(folio) &&",
            "\t\t\tfolio_test_unevictable(folio), folio);",
            "\tVM_BUG_ON_FOLIO(folio_test_lru(folio), folio);",
            "",
            "\t/* see the comment in lru_gen_add_folio() */",
            "\tif (lru_gen_enabled() && !folio_test_unevictable(folio) &&",
            "\t    lru_gen_in_fault() && !(current->flags & PF_MEMALLOC))",
            "\t\tfolio_set_active(folio);",
            "",
            "\tfolio_get(folio);",
            "\tlocal_lock(&cpu_fbatches.lock);",
            "\tfbatch = this_cpu_ptr(&cpu_fbatches.lru_add);",
            "\tfolio_batch_add_and_move(fbatch, folio, lru_add_fn);",
            "\tlocal_unlock(&cpu_fbatches.lock);",
            "}",
            "void folio_add_lru_vma(struct folio *folio, struct vm_area_struct *vma)",
            "{",
            "\tVM_BUG_ON_FOLIO(folio_test_lru(folio), folio);",
            "",
            "\tif (unlikely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) == VM_LOCKED))",
            "\t\tmlock_new_folio(folio);",
            "\telse",
            "\t\tfolio_add_lru(folio);",
            "}",
            "static void lru_deactivate_file_fn(struct lruvec *lruvec, struct folio *folio)",
            "{",
            "\tbool active = folio_test_active(folio);",
            "\tlong nr_pages = folio_nr_pages(folio);",
            "",
            "\tif (folio_test_unevictable(folio))",
            "\t\treturn;",
            "",
            "\t/* Some processes are using the folio */",
            "\tif (folio_mapped(folio))",
            "\t\treturn;",
            "",
            "\tlruvec_del_folio(lruvec, folio);",
            "\tfolio_clear_active(folio);",
            "\tfolio_clear_referenced(folio);",
            "",
            "\tif (folio_test_writeback(folio) || folio_test_dirty(folio)) {",
            "\t\t/*",
            "\t\t * Setting the reclaim flag could race with",
            "\t\t * folio_end_writeback() and confuse readahead.  But the",
            "\t\t * race window is _really_ small and  it's not a critical",
            "\t\t * problem.",
            "\t\t */",
            "\t\tlruvec_add_folio(lruvec, folio);",
            "\t\tfolio_set_reclaim(folio);",
            "\t} else {",
            "\t\t/*",
            "\t\t * The folio's writeback ended while it was in the batch.",
            "\t\t * We move that folio to the tail of the inactive list.",
            "\t\t */",
            "\t\tlruvec_add_folio_tail(lruvec, folio);",
            "\t\t__count_vm_events(PGROTATED, nr_pages);",
            "\t}",
            "",
            "\tif (active) {",
            "\t\t__count_vm_events(PGDEACTIVATE, nr_pages);",
            "\t\t__count_memcg_events(lruvec_memcg(lruvec), PGDEACTIVATE,",
            "\t\t\t\t     nr_pages);",
            "\t}",
            "}",
            "static void lru_deactivate_fn(struct lruvec *lruvec, struct folio *folio)",
            "{",
            "\tif (!folio_test_unevictable(folio) && (folio_test_active(folio) || lru_gen_enabled())) {",
            "\t\tlong nr_pages = folio_nr_pages(folio);",
            "",
            "\t\tlruvec_del_folio(lruvec, folio);",
            "\t\tfolio_clear_active(folio);",
            "\t\tfolio_clear_referenced(folio);",
            "\t\tlruvec_add_folio(lruvec, folio);",
            "",
            "\t\t__count_vm_events(PGDEACTIVATE, nr_pages);",
            "\t\t__count_memcg_events(lruvec_memcg(lruvec), PGDEACTIVATE,",
            "\t\t\t\t     nr_pages);",
            "\t}",
            "}",
            "static void lru_lazyfree_fn(struct lruvec *lruvec, struct folio *folio)",
            "{",
            "\tif (folio_test_anon(folio) && folio_test_swapbacked(folio) &&",
            "\t    !folio_test_swapcache(folio) && !folio_test_unevictable(folio)) {",
            "\t\tlong nr_pages = folio_nr_pages(folio);",
            "",
            "\t\tlruvec_del_folio(lruvec, folio);",
            "\t\tfolio_clear_active(folio);",
            "\t\tfolio_clear_referenced(folio);",
            "\t\t/*",
            "\t\t * Lazyfree folios are clean anonymous folios.  They have",
            "\t\t * the swapbacked flag cleared, to distinguish them from normal",
            "\t\t * anonymous folios",
            "\t\t */",
            "\t\tfolio_clear_swapbacked(folio);",
            "\t\tlruvec_add_folio(lruvec, folio);",
            "",
            "\t\t__count_vm_events(PGLAZYFREE, nr_pages);",
            "\t\t__count_memcg_events(lruvec_memcg(lruvec), PGLAZYFREE,",
            "\t\t\t\t     nr_pages);",
            "\t}",
            "}"
          ],
          "function_name": "folio_add_lru, folio_add_lru_vma, lru_deactivate_file_fn, lru_deactivate_fn, lru_lazyfree_fn",
          "description": "包含页面LRU列表插入和状态转换逻辑，folio_add_lru将页面加入LRU列表，folio_add_lru_vma处理VMA特定的页面添加，lru_deactivate_file_fn和lru_deactivate_fn处理文件页去激活操作，lru_lazyfree_fn处理延迟释放的匿名页面，均通过统一接口修改页面状态并触发统计事件。",
          "similarity": 0.5210212469100952
        },
        {
          "chunk_id": 0,
          "file_path": "mm/swap.c",
          "start_line": 1,
          "end_line": 76,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/mm/swap.c",
            " *",
            " *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds",
            " */",
            "",
            "/*",
            " * This file contains the default values for the operation of the",
            " * Linux VM subsystem. Fine-tuning documentation can be found in",
            " * Documentation/admin-guide/sysctl/vm.rst.",
            " * Started 18.12.91",
            " * Swap aging added 23.2.95, Stephen Tweedie.",
            " * Buffermem limits added 12.3.98, Rik van Riel.",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uio.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/buffer_head.h>",
            "",
            "#include \"internal.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/pagemap.h>",
            "",
            "/* How many pages do we try to swap or page in/out together? As a power of 2 */",
            "int page_cluster;",
            "const int page_cluster_max = 31;",
            "",
            "/* Protecting only lru_rotate.fbatch which requires disabling interrupts */",
            "struct lru_rotate {",
            "\tlocal_lock_t lock;",
            "\tstruct folio_batch fbatch;",
            "};",
            "static DEFINE_PER_CPU(struct lru_rotate, lru_rotate) = {",
            "\t.lock = INIT_LOCAL_LOCK(lock),",
            "};",
            "",
            "/*",
            " * The following folio batches are grouped together because they are protected",
            " * by disabling preemption (and interrupts remain enabled).",
            " */",
            "struct cpu_fbatches {",
            "\tlocal_lock_t lock;",
            "\tstruct folio_batch lru_add;",
            "\tstruct folio_batch lru_deactivate_file;",
            "\tstruct folio_batch lru_deactivate;",
            "\tstruct folio_batch lru_lazyfree;",
            "#ifdef CONFIG_SMP",
            "\tstruct folio_batch activate;",
            "#endif",
            "};",
            "static DEFINE_PER_CPU(struct cpu_fbatches, cpu_fbatches) = {",
            "\t.lock = INIT_LOCAL_LOCK(lock),",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了与Linux虚拟内存子系统默认操作相关的全局变量和结构体，包括控制页面集群大小的page_cluster参数，以及用于保护LRU旋转操作的本地锁结构lru_rotate和CPU级的folio批次结构cpu_fbatches，用于管理不同场景下的页面批量操作。",
          "similarity": 0.5158964991569519
        },
        {
          "chunk_id": 8,
          "file_path": "mm/swap.c",
          "start_line": 1079,
          "end_line": 1111,
          "content": [
            "void __folio_batch_release(struct folio_batch *fbatch)",
            "{",
            "\tif (!fbatch->percpu_pvec_drained) {",
            "\t\tlru_add_drain();",
            "\t\tfbatch->percpu_pvec_drained = true;",
            "\t}",
            "\tfolios_put(fbatch);",
            "}",
            "void folio_batch_remove_exceptionals(struct folio_batch *fbatch)",
            "{",
            "\tunsigned int i, j;",
            "",
            "\tfor (i = 0, j = 0; i < folio_batch_count(fbatch); i++) {",
            "\t\tstruct folio *folio = fbatch->folios[i];",
            "\t\tif (!xa_is_value(folio))",
            "\t\t\tfbatch->folios[j++] = folio;",
            "\t}",
            "\tfbatch->nr = j;",
            "}",
            "void __init swap_setup(void)",
            "{",
            "\tunsigned long megs = totalram_pages() >> (20 - PAGE_SHIFT);",
            "",
            "\t/* Use a smaller cluster for small-memory machines */",
            "\tif (megs < 16)",
            "\t\tpage_cluster = 2;",
            "\telse",
            "\t\tpage_cluster = 3;",
            "\t/*",
            "\t * Right now other parts of the system means that we",
            "\t * _really_ don't want to cluster much more",
            "\t */",
            "}"
          ],
          "function_name": "__folio_batch_release, folio_batch_remove_exceptionals, swap_setup",
          "description": "__folio_batch_release 标记并释放页面批次引用，folio_batch_remove_exceptionals 清理异常条目；swap_setup 初始化页面聚类参数，根据内存大小调整page_cluster值。",
          "similarity": 0.5107839703559875
        },
        {
          "chunk_id": 3,
          "file_path": "mm/swap.c",
          "start_line": 332,
          "end_line": 460,
          "content": [
            "static void folio_activate_drain(int cpu)",
            "{",
            "\tstruct folio_batch *fbatch = &per_cpu(cpu_fbatches.activate, cpu);",
            "",
            "\tif (folio_batch_count(fbatch))",
            "\t\tfolio_batch_move_lru(fbatch, folio_activate_fn);",
            "}",
            "void folio_activate(struct folio *folio)",
            "{",
            "\tif (!folio_test_active(folio) && !folio_test_unevictable(folio)) {",
            "\t\tstruct folio_batch *fbatch;",
            "",
            "\t\tfolio_get(folio);",
            "\t\tif (!folio_test_clear_lru(folio)) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tlocal_lock(&cpu_fbatches.lock);",
            "\t\tfbatch = this_cpu_ptr(&cpu_fbatches.activate);",
            "\t\tfolio_batch_add_and_move(fbatch, folio, folio_activate_fn);",
            "\t\tlocal_unlock(&cpu_fbatches.lock);",
            "\t}",
            "}",
            "static inline void folio_activate_drain(int cpu)",
            "{",
            "}",
            "void folio_activate(struct folio *folio)",
            "{",
            "\tstruct lruvec *lruvec;",
            "",
            "\tif (folio_test_clear_lru(folio)) {",
            "\t\tlruvec = folio_lruvec_lock_irq(folio);",
            "\t\tfolio_activate_fn(lruvec, folio);",
            "\t\tunlock_page_lruvec_irq(lruvec);",
            "\t\tfolio_set_lru(folio);",
            "\t}",
            "}",
            "static void __lru_cache_activate_folio(struct folio *folio)",
            "{",
            "\tstruct folio_batch *fbatch;",
            "\tint i;",
            "",
            "\tlocal_lock(&cpu_fbatches.lock);",
            "\tfbatch = this_cpu_ptr(&cpu_fbatches.lru_add);",
            "",
            "\t/*",
            "\t * Search backwards on the optimistic assumption that the folio being",
            "\t * activated has just been added to this batch. Note that only",
            "\t * the local batch is examined as a !LRU folio could be in the",
            "\t * process of being released, reclaimed, migrated or on a remote",
            "\t * batch that is currently being drained. Furthermore, marking",
            "\t * a remote batch's folio active potentially hits a race where",
            "\t * a folio is marked active just after it is added to the inactive",
            "\t * list causing accounting errors and BUG_ON checks to trigger.",
            "\t */",
            "\tfor (i = folio_batch_count(fbatch) - 1; i >= 0; i--) {",
            "\t\tstruct folio *batch_folio = fbatch->folios[i];",
            "",
            "\t\tif (batch_folio == folio) {",
            "\t\t\tfolio_set_active(folio);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tlocal_unlock(&cpu_fbatches.lock);",
            "}",
            "static void folio_inc_refs(struct folio *folio)",
            "{",
            "\tunsigned long new_flags, old_flags = READ_ONCE(folio->flags);",
            "",
            "\tif (folio_test_unevictable(folio))",
            "\t\treturn;",
            "",
            "\tif (!folio_test_referenced(folio)) {",
            "\t\tfolio_set_referenced(folio);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!folio_test_workingset(folio)) {",
            "\t\tfolio_set_workingset(folio);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* see the comment on MAX_NR_TIERS */",
            "\tdo {",
            "\t\tnew_flags = old_flags & LRU_REFS_MASK;",
            "\t\tif (new_flags == LRU_REFS_MASK)",
            "\t\t\tbreak;",
            "",
            "\t\tnew_flags += BIT(LRU_REFS_PGOFF);",
            "\t\tnew_flags |= old_flags & ~LRU_REFS_MASK;",
            "\t} while (!try_cmpxchg(&folio->flags, &old_flags, new_flags));",
            "}",
            "static void folio_inc_refs(struct folio *folio)",
            "{",
            "}",
            "void folio_mark_accessed(struct folio *folio)",
            "{",
            "\tif (lru_gen_enabled()) {",
            "\t\tfolio_inc_refs(folio);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!folio_test_referenced(folio)) {",
            "\t\tfolio_set_referenced(folio);",
            "\t} else if (folio_test_unevictable(folio)) {",
            "\t\t/*",
            "\t\t * Unevictable pages are on the \"LRU_UNEVICTABLE\" list. But,",
            "\t\t * this list is never rotated or maintained, so marking an",
            "\t\t * unevictable page accessed has no effect.",
            "\t\t */",
            "\t} else if (!folio_test_active(folio)) {",
            "\t\t/*",
            "\t\t * If the folio is on the LRU, queue it for activation via",
            "\t\t * cpu_fbatches.activate. Otherwise, assume the folio is in a",
            "\t\t * folio_batch, mark it active and it'll be moved to the active",
            "\t\t * LRU on the next drain.",
            "\t\t */",
            "\t\tif (folio_test_lru(folio))",
            "\t\t\tfolio_activate(folio);",
            "\t\telse",
            "\t\t\t__lru_cache_activate_folio(folio);",
            "\t\tfolio_clear_referenced(folio);",
            "\t\tworkingset_activation(folio);",
            "\t}",
            "\tif (folio_test_idle(folio))",
            "\t\tfolio_clear_idle(folio);",
            "}"
          ],
          "function_name": "folio_activate_drain, folio_activate, folio_activate_drain, folio_activate, __lru_cache_activate_folio, folio_inc_refs, folio_inc_refs, folio_mark_accessed",
          "description": "实现页面激活和引用计数管理，folio_activate_drain和folio_activate将页面从非活动列表转至活动列表，__lru_cache_activate_folio处理本地批次中的页面激活，folio_inc_refs更新页面引用标志，folio_mark_accessed标记页面访问状态并触发激活流程。",
          "similarity": 0.5089820623397827
        }
      ]
    },
    {
      "source_file": "mm/pgalloc-track.h",
      "md_summary": "> 自动生成时间: 2025-12-07 17:11:54\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pgalloc-track.h`\n\n---\n\n# pgalloc-track.h 技术文档\n\n## 1. 文件概述\n\n`pgalloc-track.h` 是 Linux 内核中用于页表分配与修改追踪的辅助头文件。该文件提供了一组带“追踪”（track）功能的页表分配接口，能够在分配缺失的页表层级时，自动记录哪些页表层级被修改，以便后续进行 TLB 刷新、内存同步或其他页表一致性维护操作。这些接口主要用于支持内核在处理缺页异常或动态映射时高效地构建多级页表结构，并精确标记被修改的页表层级。\n\n## 2. 核心功能\n\n### 函数列表\n\n- `p4d_alloc_track(struct mm_struct *mm, pgd_t *pgd, unsigned long address, pgtbl_mod_mask *mod_mask)`  \n  分配并返回指定地址对应的 P4D（Page 4-level Directory）项指针，若原 PGD 项为空则分配新 P4D 表，并设置 `PGTBL_PGD_MODIFIED` 标志。\n\n- `pud_alloc_track(struct mm_struct *mm, p4d_t *p4d, unsigned long address, pgtbl_mod_mask *mod_mask)`  \n  分配并返回 PUD（Page Upper Directory）项指针，若原 P4D 项为空则分配新 PUD 表，并设置 `PGTBL_P4D_MODIFIED` 标志。\n\n- `pmd_alloc_track(struct mm_struct *mm, pud_t *pud, unsigned long address, pgtbl_mod_mask *mod_mask)`  \n  分配并返回 PMD（Page Middle Directory）项指针，若原 PUD 项为空则分配新 PMD 表，并设置 `PGTBL_PUD_MODIFIED` 标志。\n\n- `pte_alloc_kernel_track(pmd, address, mask)`（宏）  \n  为内核地址空间分配 PTE（Page Table Entry）页表，若原 PMD 项为空则调用 `__pte_alloc_kernel` 分配，并设置 `PGTBL_PMD_MODIFIED` 标志。\n\n### 数据结构依赖\n\n- `struct mm_struct`：进程内存描述符。\n- `pgd_t`, `p4d_t`, `pud_t`, `pmd_t`：各级页表项类型。\n- `pgtbl_mod_mask`：位掩码类型，用于记录哪些页表层级被修改（如 `PGTBL_PGD_MODIFIED` 等常量）。\n\n> 注：上述函数仅在 `CONFIG_MMU` 配置启用时定义，即仅适用于支持 MMU 的架构。\n\n## 3. 关键实现\n\n- **条件分配机制**：所有 `_alloc_track` 函数均采用“按需分配”策略。仅当上级页表项为 `none`（即未分配）时，才调用底层分配函数（如 `__p4d_alloc`）创建下一级页表。\n  \n- **修改标记追踪**：每次成功分配新的页表层级后，通过位或操作（`|=`）将对应的修改标志（如 `PGTBL_P4D_MODIFIED`）写入传入的 `mod_mask` 指针所指向的掩码变量中。这使得调用者能够精确知道在本次页表遍历过程中哪些层级发生了变更。\n\n- **内联与宏优化**：所有函数均为 `static inline`，以减少函数调用开销；`pte_alloc_kernel_track` 使用宏实现，结合三元运算符和语句表达式（`({...})`）在单行中完成条件判断、分配、标记和返回。\n\n- **错误处理**：若底层分配函数（如 `__pud_alloc`）失败，函数直接返回 `NULL`，由上层调用者处理错误。\n\n## 4. 依赖关系\n\n- **配置依赖**：依赖 `CONFIG_MMU` 内核配置选项，仅在支持虚拟内存管理单元（MMU）的系统上编译相关函数。\n- **头文件依赖**：隐式依赖以下内核头文件（虽未显式包含，但使用其定义）：\n  - `<linux/mm_types.h>`：定义 `struct mm_struct` 和页表项类型。\n  - `<asm/pgtable.h>`：提供 `pgd_none`、`p4d_offset` 等页表操作宏及 `__p4d_alloc` 等分配函数。\n  - `<linux/pgtable.h>`：可能定义 `pgtbl_mod_mask` 及相关修改标志（如 `PGTBL_PGD_MODIFIED`）。\n- **函数依赖**：依赖底层页表分配函数 `__p4d_alloc`、`__pud_alloc`、`__pmd_alloc` 和 `__pte_alloc_kernel`，这些通常由架构相关代码或通用内存管理模块提供。\n\n## 5. 使用场景\n\n- **缺页异常处理**：在 `handle_mm_fault()` 或类似路径中，当需要为用户或内核地址建立完整页表映射时，逐级调用这些 `_alloc_track` 函数构建页表，并收集修改掩码用于后续 TLB 批量刷新。\n  \n- **内核动态映射**：在内核需要动态映射物理内存（如 `ioremap`、`vmalloc` 等）时，使用 `pte_alloc_kernel_track` 安全地分配内核 PTE 页表并记录 PMD 修改状态。\n\n- **页表预分配或扩展**：在内存管理子系统预分配页表或扩展现有 VMA 映射范围时，利用该接口确保页表结构完整性并精确追踪变更。\n\n- **性能敏感路径**：由于采用内联和轻量级检查，适用于对性能要求较高的内存管理关键路径，同时保证修改信息的准确性以支持高效的 TLB 管理。",
      "similarity": 0.6237692832946777,
      "chunks": []
    },
    {
      "source_file": "mm/pgtable-generic.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:12:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pgtable-generic.c`\n\n---\n\n# pgtable-generic.c 技术文档\n\n## 1. 文件概述\n\n`pgtable-generic.c` 是 Linux 内核内存管理子系统中的一个通用页表操作实现文件，位于 `mm/` 目录下。该文件提供了在不同架构上通用的页表项（Page Table Entry, PTE）及相关高层页表项（如 PMD、PUD、P4D、PGD）的操作函数。这些函数主要用于处理页表项的清除、访问标志设置、TLB 刷新、透明大页（Transparent Huge Page, THP）管理等核心内存管理任务。\n\n当特定架构未提供优化的汇编或内联实现（通过 `__HAVE_ARCH_*` 宏判断）时，内核将回退使用本文件中提供的通用 C 语言实现，确保跨架构的一致性和功能完整性。\n\n## 2. 核心功能\n\n### 主要函数列表：\n\n- **页表项错误处理**：\n  - `pgd_clear_bad(pgd_t *pgd)`\n  - `p4d_clear_bad(p4d_t *p4d)`（若未折叠）\n  - `pud_clear_bad(pud_t *pud)`（若未折叠）\n  - `pmd_clear_bad(pmd_t *pmd)`\n\n- **PTE 访问控制与刷新**：\n  - `ptep_set_access_flags()`：设置 PTE 的访问/脏位及写权限\n  - `ptep_clear_flush_young()`：清除并返回 PTE 的 young 位，并刷新 TLB\n  - `ptep_clear_flush()`：原子清除 PTE 并刷新 TLB（若可访问）\n\n- **透明大页（THP）相关操作**：\n  - `pmdp_set_access_flags()`：为 PMD 设置访问标志\n  - `pmdp_clear_flush_young()`：清除 PMD 的 young 位并刷新 TLB\n  - `pmdp_huge_clear_flush()`：清除 huge PMD 并刷新 TLB\n  - `pudp_huge_clear_flush()`（若支持 PUD THP）：清除 huge PUD 并刷新 TLB\n  - `pgtable_trans_huge_deposit()` / `pgtable_trans_huge_withdraw()`：管理与 PMD 关联的页表页（用于拆分/合并 THP）\n  - `pmdp_invalidate()` / `pmdp_invalidate_ad()`：使 PMD 无效\n  - `pmdp_collapse_flush()`：在 THP 折叠过程中清除 PMD 并刷新对应范围的 TLB\n\n- **延迟释放 PTE 页表**：\n  - `pte_free_defer()`：通过 RCU 延迟释放 PTE 页表页\n\n- **无锁 PTE 映射辅助**：\n  - `__pte_offset_map()`：安全地映射 PTE 页表（考虑 SMP 和迁移条目）\n\n## 3. 关键实现\n\n### 3.1 页表项“坏”状态处理\n当页表遍历过程中发现非法或损坏的页表项（如保留位被置位），调用 `*_clear_bad()` 函数：\n- 首先通过 `*_ERROR()` 宏记录错误（通常打印警告）\n- 然后调用 `*_clear()` 将该项置为“空”（none），防止后续误用\n- 这些函数通常由 `p?d_none_or_clear_bad` 宏在检测到 bad entry 时调用\n\n### 3.2 访问标志更新与 TLB 一致性\n- `ptep_set_access_flags()` 仅在 PTE 实际发生变化时才更新页表并调用 `flush_tlb_fix_spurious_fault()`，避免不必要的 TLB 刷新。\n- 类似逻辑应用于 `pmdp_set_access_flags()`，但刷新范围是整个大页（`HPAGE_PMD_SIZE`）。\n\n### 3.3 透明大页（THP）管理\n- **页表页沉积/提取**：`pgtable_trans_huge_deposit/withdraw` 使用链表 FIFO 管理与 PMD 关联的 PTE 页表页，用于 THP 拆分时恢复原始 PTE。\n- **PMD 无效化**：`pmdp_invalidate` 使用 `pmdp_establish` 原子地将 PMD 置为无效状态，并刷新对应 TLB 范围。\n- **折叠刷新**：`pmdp_collapse_flush` 在 THP 创建过程中清除 PMD，但刷新的是整个地址范围（而非仅 PMD 粒度），因为此时底层 PTE 仍存在。\n\n### 3.4 无锁 PTE 映射（`__pte_offset_map`）\n- 在 CONFIG_GUP_GET_PXX_LOW_HIGH 且 SMP/RCU_PREEMPT 下，通过禁用本地中断确保 `pmdp_get_lockless()` 读取的高低半字属于同一 PMD 值（防止 TLB 刷新导致不一致）。\n- 检查 PMD 是否为 none、迁移条目、透明大页或 bad，若任一条件成立则返回 NULL。\n- 否则调用 `__pte_map()` 返回实际 PTE 地址，并保持 RCU 锁定。\n\n### 3.5 RCU 延迟释放\n- `pte_free_defer` 将待释放的页表页加入 RCU 回调，在宽限期结束后调用 `pte_free_now` 执行实际释放，确保并发访问安全。\n\n## 4. 依赖关系\n\n### 头文件依赖：\n- `<linux/pagemap.h>`：页面缓存相关\n- `<linux/hugetlb.h>`：大页支持\n- `<linux/pgtable.h>`：页表抽象接口\n- `<linux/swap.h>` / `<linux/swapops.h>`：交换机制\n- `<linux/mm_inline.h>`：内联内存管理函数\n- `<asm/pgalloc.h>`：架构相关的页表分配\n- `<asm/tlb.h>`：TLB 刷新接口\n\n### 架构依赖：\n- 依赖架构是否定义了 `__PAGETABLE_P4D_FOLDED`、`__PAGETABLE_PUD_FOLDED` 等宏来决定是否编译对应层级的函数。\n- 若架构定义了 `__HAVE_ARCH_*` 宏（如 `__HAVE_ARCH_PTEP_SET_ACCESS_FLAGS`），则跳过通用实现，使用架构优化版本。\n- 依赖 `CONFIG_TRANSPARENT_HUGEPAGE` 配置选项启用 THP 相关代码。\n\n### 内核子系统交互：\n- **内存管理（MM）**：与 VMA、mm_struct、页表锁等紧密集成\n- **TLB 管理**：调用 `flush_tlb_*` 系列函数维护 CPU 缓存一致性\n- **RCU 子系统**：用于安全延迟释放页表页\n- **交换子系统**：处理迁移页表项（migration entries）\n\n## 5. 使用场景\n\n- **页错误处理**：在缺页异常中更新 PTE/PMD 的访问/脏位时调用 `ptep/pmdp_set_access_flags`。\n- **内存回收与迁移**：在页面迁移或回收过程中，可能需要清除 young 位（`ptep/pmdp_clear_flush_young`）或完全清除页表项（`ptep/pmdp_clear_flush`）。\n- **透明大页操作**：\n  - THP 合并（collapse）时调用 `pmdp_collapse_flush`\n  - THP 拆分（split）时通过 `pgtable_trans_huge_withdraw` 获取原始 PTE 页表\n  - THP 无效化时调用 `pmdp_invalidate`\n- **GUP（Get User Pages）**：`__pte_offset_map` 被 `gup` 系列函数用于无锁安全地访问 PTE。\n- **页表初始化/清理**：在进程创建/销毁或内存映射变更时，可能触发 bad 页表项清理。\n- **延迟释放**：在大量页表释放场景（如进程退出）中，`pte_free_defer` 提供高效且安全的释放机制。",
      "similarity": 0.6237092614173889,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/pgtable-generic.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  mm/pgtable-generic.c",
            " *",
            " *  Generic pgtable methods declared in linux/pgtable.h",
            " *",
            " *  Copyright (C) 2010  Linus Torvalds",
            " */",
            "",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/swap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "",
            "/*",
            " * If a p?d_bad entry is found while walking page tables, report",
            " * the error, before resetting entry to p?d_none.  Usually (but",
            " * very seldom) called out from the p?d_none_or_clear_bad macros.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "该代码片段属于Linux内核内存管理模块中的通用页表实现文件，主要职责是提供跨架构的页表操作基础支持。当前代码段仅包含头文件引用和注释说明，未展示具体函数实现，因此无法确认其完整的功能性细节。上下文不完整，需结合后续代码分析具体行为。",
          "similarity": 0.6781018376350403
        },
        {
          "chunk_id": 1,
          "file_path": "mm/pgtable-generic.c",
          "start_line": 25,
          "end_line": 130,
          "content": [
            "void pgd_clear_bad(pgd_t *pgd)",
            "{",
            "\tpgd_ERROR(*pgd);",
            "\tpgd_clear(pgd);",
            "}",
            "void p4d_clear_bad(p4d_t *p4d)",
            "{",
            "\tp4d_ERROR(*p4d);",
            "\tp4d_clear(p4d);",
            "}",
            "void pud_clear_bad(pud_t *pud)",
            "{",
            "\tpud_ERROR(*pud);",
            "\tpud_clear(pud);",
            "}",
            "void pmd_clear_bad(pmd_t *pmd)",
            "{",
            "\tpmd_ERROR(*pmd);",
            "\tpmd_clear(pmd);",
            "}",
            "int ptep_set_access_flags(struct vm_area_struct *vma,",
            "\t\t\t  unsigned long address, pte_t *ptep,",
            "\t\t\t  pte_t entry, int dirty)",
            "{",
            "\tint changed = !pte_same(ptep_get(ptep), entry);",
            "\tif (changed) {",
            "\t\tset_pte_at(vma->vm_mm, address, ptep, entry);",
            "\t\tflush_tlb_fix_spurious_fault(vma, address, ptep);",
            "\t}",
            "\treturn changed;",
            "}",
            "int ptep_clear_flush_young(struct vm_area_struct *vma,",
            "\t\t\t   unsigned long address, pte_t *ptep)",
            "{",
            "\tint young;",
            "\tyoung = ptep_test_and_clear_young(vma, address, ptep);",
            "\tif (young)",
            "\t\tflush_tlb_page(vma, address);",
            "\treturn young;",
            "}",
            "pte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,",
            "\t\t       pte_t *ptep)",
            "{",
            "\tstruct mm_struct *mm = (vma)->vm_mm;",
            "\tpte_t pte;",
            "\tpte = ptep_get_and_clear(mm, address, ptep);",
            "\tif (pte_accessible(mm, pte))",
            "\t\tflush_tlb_page(vma, address);",
            "\treturn pte;",
            "}",
            "int pmdp_set_access_flags(struct vm_area_struct *vma,",
            "\t\t\t  unsigned long address, pmd_t *pmdp,",
            "\t\t\t  pmd_t entry, int dirty)",
            "{",
            "\tint changed = !pmd_same(*pmdp, entry);",
            "\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);",
            "\tif (changed) {",
            "\t\tset_pmd_at(vma->vm_mm, address, pmdp, entry);",
            "\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\t}",
            "\treturn changed;",
            "}",
            "int pmdp_clear_flush_young(struct vm_area_struct *vma,",
            "\t\t\t   unsigned long address, pmd_t *pmdp)",
            "{",
            "\tint young;",
            "\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);",
            "\tyoung = pmdp_test_and_clear_young(vma, address, pmdp);",
            "\tif (young)",
            "\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\treturn young;",
            "}",
            "pmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma, unsigned long address,",
            "\t\t\t    pmd_t *pmdp)",
            "{",
            "\tpmd_t pmd;",
            "\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);",
            "\tVM_BUG_ON(pmd_present(*pmdp) && !pmd_trans_huge(*pmdp) &&",
            "\t\t\t   !pmd_devmap(*pmdp));",
            "\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);",
            "\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\treturn pmd;",
            "}",
            "pud_t pudp_huge_clear_flush(struct vm_area_struct *vma, unsigned long address,",
            "\t\t\t    pud_t *pudp)",
            "{",
            "\tpud_t pud;",
            "",
            "\tVM_BUG_ON(address & ~HPAGE_PUD_MASK);",
            "\tVM_BUG_ON(!pud_trans_huge(*pudp) && !pud_devmap(*pudp));",
            "\tpud = pudp_huge_get_and_clear(vma->vm_mm, address, pudp);",
            "\tflush_pud_tlb_range(vma, address, address + HPAGE_PUD_SIZE);",
            "\treturn pud;",
            "}",
            "void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,",
            "\t\t\t\tpgtable_t pgtable)",
            "{",
            "\tassert_spin_locked(pmd_lockptr(mm, pmdp));",
            "",
            "\t/* FIFO */",
            "\tif (!pmd_huge_pte(mm, pmdp))",
            "\t\tINIT_LIST_HEAD(&pgtable->lru);",
            "\telse",
            "\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);",
            "\tpmd_huge_pte(mm, pmdp) = pgtable;",
            "}"
          ],
          "function_name": "pgd_clear_bad, p4d_clear_bad, pud_clear_bad, pmd_clear_bad, ptep_set_access_flags, ptep_clear_flush_young, ptep_clear_flush, pmdp_set_access_flags, pmdp_clear_flush_young, pmdp_huge_clear_flush, pudp_huge_clear_flush, pgtable_trans_huge_deposit",
          "description": "该代码段实现了针对多级页表（PGD/P4D/PUD/PMD/PTE）的错误清除、访问标志设置及TLB刷新功能，主要用于处理大页（Huge Page）场景下的页表维护。各函数通过清除页表项的无效状态、更新访问属性并触发TLB失效，确保内存访问一致性；其中`pgtable_trans_huge_deposit`负责管理透明大页（THP）的LRU缓存。  \n由于代码未包含完整上下文（如全局变量或外部依赖），部分函数行为需结合内核其他模块进一步确认。",
          "similarity": 0.615369975566864
        },
        {
          "chunk_id": 2,
          "file_path": "mm/pgtable-generic.c",
          "start_line": 181,
          "end_line": 252,
          "content": [
            "pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)",
            "{",
            "\tpgtable_t pgtable;",
            "",
            "\tassert_spin_locked(pmd_lockptr(mm, pmdp));",
            "",
            "\t/* FIFO */",
            "\tpgtable = pmd_huge_pte(mm, pmdp);",
            "\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,",
            "\t\t\t\t\t\t\t  struct page, lru);",
            "\tif (pmd_huge_pte(mm, pmdp))",
            "\t\tlist_del(&pgtable->lru);",
            "\treturn pgtable;",
            "}",
            "pmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,",
            "\t\t     pmd_t *pmdp)",
            "{",
            "\tVM_WARN_ON_ONCE(!pmd_present(*pmdp));",
            "\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mkinvalid(*pmdp));",
            "\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\treturn old;",
            "}",
            "pmd_t pmdp_invalidate_ad(struct vm_area_struct *vma, unsigned long address,",
            "\t\t\t pmd_t *pmdp)",
            "{",
            "\tVM_WARN_ON_ONCE(!pmd_present(*pmdp));",
            "\treturn pmdp_invalidate(vma, address, pmdp);",
            "}",
            "pmd_t pmdp_collapse_flush(struct vm_area_struct *vma, unsigned long address,",
            "\t\t\t  pmd_t *pmdp)",
            "{",
            "\t/*",
            "\t * pmd and hugepage pte format are same. So we could",
            "\t * use the same function.",
            "\t */",
            "\tpmd_t pmd;",
            "",
            "\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);",
            "\tVM_BUG_ON(pmd_trans_huge(*pmdp));",
            "\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);",
            "",
            "\t/* collapse entails shooting down ptes not pmd */",
            "\tflush_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\treturn pmd;",
            "}",
            "static void pte_free_now(struct rcu_head *head)",
            "{",
            "\tstruct page *page;",
            "",
            "\tpage = container_of(head, struct page, rcu_head);",
            "\tpte_free(NULL /* mm not passed and not used */, (pgtable_t)page);",
            "}",
            "void pte_free_defer(struct mm_struct *mm, pgtable_t pgtable)",
            "{",
            "\tstruct page *page;",
            "",
            "\tpage = pgtable;",
            "\tcall_rcu(&page->rcu_head, pte_free_now);",
            "}",
            "static unsigned long pmdp_get_lockless_start(void)",
            "{",
            "\tunsigned long irqflags;",
            "",
            "\tlocal_irq_save(irqflags);",
            "\treturn irqflags;",
            "}",
            "static void pmdp_get_lockless_end(unsigned long irqflags)",
            "{",
            "\tlocal_irq_restore(irqflags);",
            "}",
            "static unsigned long pmdp_get_lockless_start(void) { return 0; }",
            "static void pmdp_get_lockless_end(unsigned long irqflags) { }"
          ],
          "function_name": "pgtable_trans_huge_withdraw, pmdp_invalidate, pmdp_invalidate_ad, pmdp_collapse_flush, pte_free_now, pte_free_defer, pmdp_get_lockless_start, pmdp_get_lockless_end, pmdp_get_lockless_start, pmdp_get_lockless_end",
          "description": "该代码段主要处理大页（HugeTLB）相关页表操作及回收机制，包含页表项无效化、大页折叠、延迟释放等功能。  \n其中`pmdp_invalidate`系列函数负责使PMD无效并触发TLB刷新，`pte_free_defer`通过RCU机制延迟释放页表项，而`pmdp_get_lockless_start/end`因重复定义导致上下文不完整。",
          "similarity": 0.5907578468322754
        }
      ]
    }
  ]
}