{
  "query": "Linux内核虚拟内存实现细节",
  "timestamp": "2025-12-20 17:28:45",
  "retrieved_files": [
    {
      "source_file": "mm/percpu-vm.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:10:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `percpu-vm.c`\n\n---\n\n# percpu-vm.c 技术文档\n\n## 1. 文件概述\n\n`percpu-vm.c` 是 Linux 内核中 per-CPU（每 CPU）内存管理子系统的核心实现文件之一，负责基于 **vmalloc 虚拟地址空间** 的 per-CPU chunk（块）分配器。该文件实现了将物理页面动态映射到 per-CPU 虚拟地址区域的功能，是 per-CPU 子系统的默认 chunk 分配器。\n\n其核心思想是：为每个 CPU 单元在 vmalloc 区域中预留连续的虚拟地址空间，但底层物理页面按需分配和映射，从而支持灵活、可扩展的 per-CPU 内存布局。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `pcpu_chunk_page()` | 通过虚拟地址反查对应 struct page（仅用于非 immutable chunk） |\n| `pcpu_get_pages()` | 获取全局临时 pages 数组，用于暂存待分配/释放的页面指针 |\n| `pcpu_alloc_pages()` | 为所有 CPU 单元分配指定范围的物理页面 |\n| `pcpu_free_pages()` | 释放指定范围内的物理页面 |\n| `pcpu_map_pages()` | 将物理页面映射到 per-CPU chunk 的虚拟地址，并建立反向映射（page → chunk） |\n| `pcpu_unmap_pages()` | 解除虚拟地址到物理页面的映射，并记录页面指针供后续释放 |\n| `pcpu_pre_unmap_flush()` | 在解映射前执行 cache flush（针对整个区域） |\n| `pcpu_post_unmap_tlb_flush()` | 解映射后执行 TLB 刷新（针对整个区域） |\n| `pcpu_post_map_flush()` | 映射完成后执行 cache flush（针对整个区域） |\n\n### 关键辅助函数\n- `__pcpu_map_pages()`：调用 `vmap_pages_range_noflush()` 执行实际映射\n- `__pcpu_unmap_pages()`：调用 `vunmap_range_noflush()` 执行实际解映射\n\n## 3. 关键实现\n\n### 3.1 页面索引机制\n- 使用 `pcpu_page_idx(cpu, page_idx)` 宏将二维坐标 `(cpu, page_idx)` 映射为一维数组索引。\n- 全局临时数组 `pages[]` 由 `pcpu_get_pages()` 提供，大小为 `pcpu_nr_units * pcpu_unit_pages`，受 `pcpu_alloc_mutex` 保护。\n\n### 3.2 内存分配策略\n- 调用 `alloc_pages_node(cpu_to_node(cpu), gfp | __GFP_HIGHMEM, 0)` 为每个 CPU 在其本地 NUMA 节点分配单页。\n- 支持 HIGHMEM 页面，提高内存利用率。\n\n### 3.3 批量缓存与 TLB 管理\n- **避免逐 CPU 刷新**：所有 flush 操作（cache 和 TLB）均作用于 **整个 per-CPU 区域**，从 `pcpu_low_unit_cpu` 到 `pcpu_high_unit_cpu`。\n- 使用 `noflush` 版本的 vmap/vunmap 函数（如 `vmap_pages_range_noflush`），由调用者统一控制刷新时机，减少开销。\n\n### 3.4 错误处理与回滚\n- `pcpu_alloc_pages()` 和 `pcpu_map_pages()` 在失败时会回滚已分配/映射的资源，确保状态一致性。\n- 回滚逻辑按 CPU 顺序释放，避免遗漏。\n\n### 3.5 反向映射支持\n- `pcpu_map_pages()` 中调用 `pcpu_set_page_chunk(page, chunk)`，建立物理页面到所属 chunk 的关联，用于后续内存追踪和调试。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `mm/internal.h`：包含 per-CPU 内存管理的内部定义\n  - `pcpu_*` 系列宏和函数（如 `pcpu_chunk_addr`, `pcpu_page_idx`, `pcpu_set_page_chunk`）\n  - 全局变量：`pcpu_alloc_mutex`, `pcpu_nr_units`, `pcpu_unit_pages`, `pcpu_low_unit_cpu`, `pcpu_high_unit_cpu`\n\n- **外部依赖**：\n  - **vmalloc 子系统**：使用 `vmalloc_to_page()`, `vmap_pages_range_noflush()`, `vunmap_range_noflush()` 等接口\n  - **内存管理子系统**：依赖 `alloc_pages_node()`, `__free_page()` 等页面分配器\n  - **体系结构相关**：依赖 `flush_cache_vmap()`, `flush_cache_vunmap()`, `flush_tlb_kernel_range()` 等架构特定的缓存/TLB 操作\n\n## 5. 使用场景\n\n- **Per-CPU 内存初始化**：系统启动时为 per-CPU 变量分配初始内存块。\n- **动态扩展**：当现有 per-CPU chunk 空间不足时，分配新的 chunk 并映射物理页面。\n- **内存热插拔**：在 CPU 热插拔过程中，为新上线 CPU 分配 per-CPU 内存。\n- **模块加载**：内核模块使用 `DEFINE_PER_CPU` 定义变量时，可能触发新的 per-CPU 内存分配。\n- **内存回收**：当 chunk 被释放时，解映射并释放其占用的物理页面。\n\n该文件作为 per-CPU 子系统的默认分配器，在大多数架构（尤其是 x86、ARM64 等）上被广泛使用，提供了高效、可扩展的 per-CPU 内存管理能力。",
      "similarity": 0.6299090385437012,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/percpu-vm.c",
          "start_line": 54,
          "end_line": 170,
          "content": [
            "static void pcpu_free_pages(struct pcpu_chunk *chunk,",
            "\t\t\t    struct page **pages, int page_start, int page_end)",
            "{",
            "\tunsigned int cpu;",
            "\tint i;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tfor (i = page_start; i < page_end; i++) {",
            "\t\t\tstruct page *page = pages[pcpu_page_idx(cpu, i)];",
            "",
            "\t\t\tif (page)",
            "\t\t\t\t__free_page(page);",
            "\t\t}",
            "\t}",
            "}",
            "static int pcpu_alloc_pages(struct pcpu_chunk *chunk,",
            "\t\t\t    struct page **pages, int page_start, int page_end,",
            "\t\t\t    gfp_t gfp)",
            "{",
            "\tunsigned int cpu, tcpu;",
            "\tint i;",
            "",
            "\tgfp |= __GFP_HIGHMEM;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tfor (i = page_start; i < page_end; i++) {",
            "\t\t\tstruct page **pagep = &pages[pcpu_page_idx(cpu, i)];",
            "",
            "\t\t\t*pagep = alloc_pages_node(cpu_to_node(cpu), gfp, 0);",
            "\t\t\tif (!*pagep)",
            "\t\t\t\tgoto err;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "",
            "err:",
            "\twhile (--i >= page_start)",
            "\t\t__free_page(pages[pcpu_page_idx(cpu, i)]);",
            "",
            "\tfor_each_possible_cpu(tcpu) {",
            "\t\tif (tcpu == cpu)",
            "\t\t\tbreak;",
            "\t\tfor (i = page_start; i < page_end; i++)",
            "\t\t\t__free_page(pages[pcpu_page_idx(tcpu, i)]);",
            "\t}",
            "\treturn -ENOMEM;",
            "}",
            "static void pcpu_pre_unmap_flush(struct pcpu_chunk *chunk,",
            "\t\t\t\t int page_start, int page_end)",
            "{",
            "\tflush_cache_vunmap(",
            "\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),",
            "\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));",
            "}",
            "static void __pcpu_unmap_pages(unsigned long addr, int nr_pages)",
            "{",
            "\tvunmap_range_noflush(addr, addr + (nr_pages << PAGE_SHIFT));",
            "}",
            "static void pcpu_unmap_pages(struct pcpu_chunk *chunk,",
            "\t\t\t     struct page **pages, int page_start, int page_end)",
            "{",
            "\tunsigned int cpu;",
            "\tint i;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tfor (i = page_start; i < page_end; i++) {",
            "\t\t\tstruct page *page;",
            "",
            "\t\t\tpage = pcpu_chunk_page(chunk, cpu, i);",
            "\t\t\tWARN_ON(!page);",
            "\t\t\tpages[pcpu_page_idx(cpu, i)] = page;",
            "\t\t}",
            "\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, cpu, page_start),",
            "\t\t\t\t   page_end - page_start);",
            "\t}",
            "}",
            "static void pcpu_post_unmap_tlb_flush(struct pcpu_chunk *chunk,",
            "\t\t\t\t      int page_start, int page_end)",
            "{",
            "\tflush_tlb_kernel_range(",
            "\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),",
            "\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));",
            "}",
            "static int __pcpu_map_pages(unsigned long addr, struct page **pages,",
            "\t\t\t    int nr_pages)",
            "{",
            "\treturn vmap_pages_range_noflush(addr, addr + (nr_pages << PAGE_SHIFT),",
            "\t\t\t\t\tPAGE_KERNEL, pages, PAGE_SHIFT);",
            "}",
            "static int pcpu_map_pages(struct pcpu_chunk *chunk,",
            "\t\t\t  struct page **pages, int page_start, int page_end)",
            "{",
            "\tunsigned int cpu, tcpu;",
            "\tint i, err;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\terr = __pcpu_map_pages(pcpu_chunk_addr(chunk, cpu, page_start),",
            "\t\t\t\t       &pages[pcpu_page_idx(cpu, page_start)],",
            "\t\t\t\t       page_end - page_start);",
            "\t\tif (err < 0)",
            "\t\t\tgoto err;",
            "",
            "\t\tfor (i = page_start; i < page_end; i++)",
            "\t\t\tpcpu_set_page_chunk(pages[pcpu_page_idx(cpu, i)],",
            "\t\t\t\t\t    chunk);",
            "\t}",
            "\treturn 0;",
            "err:",
            "\tfor_each_possible_cpu(tcpu) {",
            "\t\tif (tcpu == cpu)",
            "\t\t\tbreak;",
            "\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, tcpu, page_start),",
            "\t\t\t\t   page_end - page_start);",
            "\t}",
            "\tpcpu_post_unmap_tlb_flush(chunk, page_start, page_end);",
            "\treturn err;",
            "}"
          ],
          "function_name": "pcpu_free_pages, pcpu_alloc_pages, pcpu_pre_unmap_flush, __pcpu_unmap_pages, pcpu_unmap_pages, pcpu_post_unmap_tlb_flush, __pcpu_map_pages, pcpu_map_pages",
          "description": "实现PCPU块的页面分配/释放、虚拟地址映射/解映射操作，包含跨CPU的页面分配（pcpu_alloc_pages）、TLB刷新（pcpu_pre_unmap_flush/pcpu_post_unmap_tlb_flush）、以及页面到虚拟地址的批量映射（pcpu_map_pages）",
          "similarity": 0.5823858976364136
        },
        {
          "chunk_id": 2,
          "file_path": "mm/percpu-vm.c",
          "start_line": 255,
          "end_line": 335,
          "content": [
            "static void pcpu_post_map_flush(struct pcpu_chunk *chunk,",
            "\t\t\t\tint page_start, int page_end)",
            "{",
            "\tflush_cache_vmap(",
            "\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),",
            "\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));",
            "}",
            "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,",
            "\t\t\t       int page_start, int page_end, gfp_t gfp)",
            "{",
            "\tstruct page **pages;",
            "",
            "\tpages = pcpu_get_pages();",
            "\tif (!pages)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (pcpu_alloc_pages(chunk, pages, page_start, page_end, gfp))",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (pcpu_map_pages(chunk, pages, page_start, page_end)) {",
            "\t\tpcpu_free_pages(chunk, pages, page_start, page_end);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tpcpu_post_map_flush(chunk, page_start, page_end);",
            "",
            "\treturn 0;",
            "}",
            "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,",
            "\t\t\t\t  int page_start, int page_end)",
            "{",
            "\tstruct page **pages;",
            "",
            "\t/*",
            "\t * If control reaches here, there must have been at least one",
            "\t * successful population attempt so the temp pages array must",
            "\t * be available now.",
            "\t */",
            "\tpages = pcpu_get_pages();",
            "\tBUG_ON(!pages);",
            "",
            "\t/* unmap and free */",
            "\tpcpu_pre_unmap_flush(chunk, page_start, page_end);",
            "",
            "\tpcpu_unmap_pages(chunk, pages, page_start, page_end);",
            "",
            "\tpcpu_free_pages(chunk, pages, page_start, page_end);",
            "}",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk)",
            "{",
            "\tif (!chunk)",
            "\t\treturn;",
            "",
            "\tpcpu_stats_chunk_dealloc();",
            "\ttrace_percpu_destroy_chunk(chunk->base_addr);",
            "",
            "\tif (chunk->data)",
            "\t\tpcpu_free_vm_areas(chunk->data, pcpu_nr_groups);",
            "\tpcpu_free_chunk(chunk);",
            "}",
            "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai)",
            "{",
            "\t/* no extra restriction */",
            "\treturn 0;",
            "}",
            "static bool pcpu_should_reclaim_chunk(struct pcpu_chunk *chunk)",
            "{",
            "\t/* do not reclaim either the first chunk or reserved chunk */",
            "\tif (chunk == pcpu_first_chunk || chunk == pcpu_reserved_chunk)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * If it is isolated, it may be on the sidelined list so move it back to",
            "\t * the to_depopulate list.  If we hit at least 1/4 pages empty pages AND",
            "\t * there is no system-wide shortage of empty pages aside from this",
            "\t * chunk, move it to the to_depopulate list.",
            "\t */",
            "\treturn ((chunk->isolated && chunk->nr_empty_pop_pages) ||",
            "\t\t(pcpu_nr_empty_pop_pages >",
            "\t\t (PCPU_EMPTY_POP_PAGES_HIGH + chunk->nr_empty_pop_pages) &&",
            "\t\t chunk->nr_empty_pop_pages >= chunk->nr_pages / 4));",
            "}"
          ],
          "function_name": "pcpu_post_map_flush, pcpu_populate_chunk, pcpu_depopulate_chunk, pcpu_destroy_chunk, pcpu_verify_alloc_info, pcpu_should_reclaim_chunk",
          "description": "提供PCPU块生命周期管理函数，包括块填充（pcpu_populate_chunk）、数据清除（pcpu_depopulate_chunk）、块销毁（pcpu_destroy_chunk）及回收判定（pcpu_should_reclaim_chunk），实现动态资源管理与内存优化",
          "similarity": 0.4760715663433075
        },
        {
          "chunk_id": 0,
          "file_path": "mm/percpu-vm.c",
          "start_line": 1,
          "end_line": 53,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * mm/percpu-vm.c - vmalloc area based chunk allocation",
            " *",
            " * Copyright (C) 2010\t\tSUSE Linux Products GmbH",
            " * Copyright (C) 2010\t\tTejun Heo <tj@kernel.org>",
            " *",
            " * Chunks are mapped into vmalloc areas and populated page by page.",
            " * This is the default chunk allocator.",
            " */",
            "#include \"internal.h\"",
            "",
            "static struct page *pcpu_chunk_page(struct pcpu_chunk *chunk,",
            "\t\t\t\t    unsigned int cpu, int page_idx)",
            "{",
            "\t/* must not be used on pre-mapped chunk */",
            "\tWARN_ON(chunk->immutable);",
            "",
            "\treturn vmalloc_to_page((void *)pcpu_chunk_addr(chunk, cpu, page_idx));",
            "}",
            "",
            "/**",
            " * pcpu_get_pages - get temp pages array",
            " *",
            " * Returns pointer to array of pointers to struct page which can be indexed",
            " * with pcpu_page_idx().  Note that there is only one array and accesses",
            " * should be serialized by pcpu_alloc_mutex.",
            " *",
            " * RETURNS:",
            " * Pointer to temp pages array on success.",
            " */",
            "static struct page **pcpu_get_pages(void)",
            "{",
            "\tstatic struct page **pages;",
            "\tsize_t pages_size = pcpu_nr_units * pcpu_unit_pages * sizeof(pages[0]);",
            "",
            "\tlockdep_assert_held(&pcpu_alloc_mutex);",
            "",
            "\tif (!pages)",
            "\t\tpages = pcpu_mem_zalloc(pages_size, GFP_KERNEL);",
            "\treturn pages;",
            "}",
            "",
            "/**",
            " * pcpu_free_pages - free pages which were allocated for @chunk",
            " * @chunk: chunk pages were allocated for",
            " * @pages: array of pages to be freed, indexed by pcpu_page_idx()",
            " * @page_start: page index of the first page to be freed",
            " * @page_end: page index of the last page to be freed + 1",
            " *",
            " * Free pages [@page_start and @page_end) in @pages for all units.",
            " * The pages were allocated for @chunk.",
            " */"
          ],
          "function_name": null,
          "description": "定义了PCPU块的页面分配与管理辅助函数，包括获取临时页面数组的pcpu_get_pages及释放指定范围页面的pcpu_free_pages函数，用于支持基于vmalloc区域的PCPU块分配机制",
          "similarity": 0.473257839679718
        }
      ]
    },
    {
      "source_file": "mm/memblock.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memblock.c`\n\n---\n\n# memblock.c 技术文档\n\n## 1. 文件概述\n\n`memblock.c` 实现了 Linux 内核早期启动阶段的内存管理机制——**memblock**。该机制用于在常规内存分配器（如 buddy allocator）尚未初始化之前，对物理内存进行粗粒度的区域管理。它将系统内存抽象为若干连续的内存区域（regions），支持“可用内存”（memory）、“保留内存”（reserved）和“物理内存”（physmem，部分架构支持）三种类型，为内核早期初始化提供内存添加、查询和分配能力。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct memblock_region`：表示一个连续的物理内存区域，包含基地址（base）、大小（size）、NUMA 节点 ID 和属性标志。\n- `struct memblock_type`：管理一类内存区域的集合，包含区域数组、当前数量（cnt）、最大容量（max）和名称。\n- `struct memblock`：全局 memblock 管理结构，包含 `memory` 和 `reserved` 两种类型的 `memblock_type`，以及分配方向（bottom_up）和当前分配上限（current_limit）。\n- `physmem`（条件编译）：描述不受 `mem=` 参数限制的实际物理内存布局。\n\n### 主要函数与变量\n- `memblock_add()` / `memblock_add_node()`：向 memblock 添加可用内存区域。\n- `memblock_reserve()`：标记内存区域为保留（不可用于动态分配）。\n- `memblock_phys_alloc*()` / `memblock_alloc*()`：分配物理或虚拟地址的内存。\n- `memblock_overlaps_region()`：判断指定区域是否与某类 memblock 区域重叠。\n- `__memblock_find_range_bottom_up()`：从低地址向高地址查找满足条件的空闲内存范围。\n- 全局变量 `memblock`：静态初始化的主 memblock 结构体。\n- `max_low_pfn`, `min_low_pfn`, `max_pfn`, `max_possible_pfn`：记录 PFN（页帧号）边界信息。\n\n### 配置宏\n- `INIT_MEMBLOCK_REGIONS`：初始内存/保留区域数组大小（默认 128）。\n- `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 类型支持。\n- `CONFIG_MEMBLOCK_KHO_SCRATCH`：支持仅从特定标记（KHO_SCRATCH）区域分配内存。\n- `CONFIG_ARCH_KEEP_MEMBLOCK`：决定是否在初始化完成后保留 memblock 数据结构。\n\n## 3. 关键实现\n\n### 初始化与存储\n- `memblock` 结构体在编译时静态初始化，其 `memory` 和 `reserved` 的区域数组分别使用 `memblock_memory_init_regions` 和 `memblock_reserved_init_regions`，初始容量由 `INIT_MEMBLOCK_*_REGIONS` 定义。\n- 每个 `memblock_type` 的 `cnt` 初始设为 1，但实际第一个条目为空的占位符，有效区域从索引 1 开始（后续代码处理）。\n- 支持通过 `memblock_allow_resize()` 动态扩容区域数组，但需谨慎避免与 initrd 等关键区域冲突。\n\n### 内存区域管理\n- 使用 `for_each_memblock_type` 宏遍历指定类型的区域。\n- `memblock_addrs_overlap()` 通过比较区间端点判断两个物理内存区域是否重叠。\n- `memblock_overlaps_region()` 封装了对某类所有区域的重叠检测。\n\n### 分配策略\n- 默认采用 **top-down**（从高地址向低地址）分配策略，可通过 `memblock_set_bottom_up(true)` 切换为 **bottom-up**。\n- 分配时受 `current_limit` 限制（默认 `MEMBLOCK_ALLOC_ANYWHERE` 表示无限制）。\n- 支持基于 NUMA 节点、对齐要求、内存属性（如 `MEMBLOCK_MIRROR`、`MEMBLOCK_KHO_SCRATCH`）的精细控制。\n- `choose_memblock_flags()` 根据 `kho_scratch_only` 和镜像内存存在性动态选择分配标志。\n\n### 安全与调试\n- `memblock_cap_size()` 防止地址计算溢出（确保 `base + size <= PHYS_ADDR_MAX`）。\n- 条件编译的 `memblock_dbg()` 宏用于调试输出（需开启 `memblock_debug`）。\n- 使用 `__initdata_memblock` 属性标记仅在初始化阶段使用的数据，便于后续释放。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memblock.h>`：定义 memblock API 和数据结构。\n  - `<linux/kernel.h>`, `<linux/init.h>`：提供基础内核功能和初始化宏。\n  - `<linux/pfn.h>`：PFN 相关操作。\n  - `<asm/sections.h>`：访问内核链接段信息。\n  - 架构相关头文件（如 `internal.h`）。\n- **配置依赖**：\n  - `CONFIG_NUMA`：影响 `contig_page_data` 的定义。\n  - `CONFIG_KEXEC_HANDOVER`：引入 kexec 相关头文件。\n  - `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 支持。\n- **后续移交**：在 `mem_init()` 中，memblock 管理的内存会被释放给 buddy allocator，完成内存管理权移交。\n\n## 5. 使用场景\n\n- **内核早期初始化**：在 `start_kernel()` 初期，架构代码（如 `setup_arch()`）调用 `memblock_add()` 注册可用物理内存，调用 `memblock_reserve()` 保留内核镜像、设备树、initrd 等关键区域。\n- **早期内存分配**：在 slab/buddy 分配器就绪前，使用 `memblock_alloc()` 分配大块连续内存（如页表、中断向量表、ACPI 表解析缓冲区）。\n- **内存布局查询**：通过 `for_each_memblock()` 等宏遍历内存区域，用于构建 e820 表、EFI 内存映射或 NUMA 拓扑。\n- **特殊分配需求**：支持从镜像内存（`MEMBLOCK_MIRROR`）或 KHO scratch 区域分配，满足安全启动或崩溃转储等场景。\n- **调试与分析**：通过 debugfs 接口（未在片段中体现）导出 memblock 布局，辅助内存问题诊断。",
      "similarity": 0.629161536693573,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "mm/memblock.c",
          "start_line": 1607,
          "end_line": 1734,
          "content": [
            "phys_addr_t __init memblock_phys_alloc_range(phys_addr_t size,",
            "\t\t\t\t\t     phys_addr_t align,",
            "\t\t\t\t\t     phys_addr_t start,",
            "\t\t\t\t\t     phys_addr_t end)",
            "{",
            "\tmemblock_dbg(\"%s: %llu bytes align=0x%llx from=%pa max_addr=%pa %pS\\n\",",
            "\t\t     __func__, (u64)size, (u64)align, &start, &end,",
            "\t\t     (void *)_RET_IP_);",
            "\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,",
            "\t\t\t\t\tfalse);",
            "}",
            "phys_addr_t __init memblock_phys_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)",
            "{",
            "\treturn memblock_alloc_range_nid(size, align, 0,",
            "\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid, false);",
            "}",
            "void __init memblock_free_late(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t cursor, end;",
            "",
            "\tend = base + size - 1;",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\",",
            "\t\t     __func__, &base, &end, (void *)_RET_IP_);",
            "\tkmemleak_free_part_phys(base, size);",
            "\tcursor = PFN_UP(base);",
            "\tend = PFN_DOWN(base + size);",
            "",
            "\tfor (; cursor < end; cursor++) {",
            "\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);",
            "\t\ttotalram_pages_inc();",
            "\t}",
            "}",
            "phys_addr_t __init_memblock memblock_reserved_kern_size(phys_addr_t limit, int nid)",
            "{",
            "\tstruct memblock_region *r;",
            "\tphys_addr_t total = 0;",
            "",
            "\tfor_each_reserved_mem_region(r) {",
            "\t\tphys_addr_t size = r->size;",
            "",
            "\t\tif (r->base > limit)",
            "\t\t\tbreak;",
            "",
            "\t\tif (r->base + r->size > limit)",
            "\t\t\tsize = limit - r->base;",
            "",
            "\t\tif (nid == memblock_get_region_node(r) || !numa_valid_node(nid))",
            "\t\t\tif (r->flags & MEMBLOCK_RSRV_KERN)",
            "\t\t\t\ttotal += size;",
            "\t}",
            "",
            "\treturn total;",
            "}",
            "unsigned long __init memblock_estimated_nr_free_pages(void)",
            "{",
            "\treturn PHYS_PFN(memblock_phys_mem_size() - memblock_reserved_size());",
            "}",
            "static phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr = PHYS_ADDR_MAX;",
            "\tstruct memblock_region *r;",
            "",
            "\t/*",
            "\t * translate the memory @limit size into the max address within one of",
            "\t * the memory memblock regions, if the @limit exceeds the total size",
            "\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX",
            "\t */",
            "\tfor_each_mem_region(r) {",
            "\t\tif (limit <= r->size) {",
            "\t\t\tmax_addr = r->base + limit;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tlimit -= r->size;",
            "\t}",
            "",
            "\treturn max_addr;",
            "}",
            "void __init memblock_enforce_memory_limit(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\t/* truncate both memory and reserved regions */",
            "\tmemblock_remove_range(&memblock.memory, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "\tmemblock_remove_range(&memblock.reserved, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "}",
            "void __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint start_rgn, end_rgn;",
            "\tint i, ret;",
            "",
            "\tif (!size)",
            "\t\treturn;",
            "",
            "\tif (!memblock_memory->total_size) {",
            "\t\tpr_warn(\"%s: No memory registered yet\\n\", __func__);",
            "\t\treturn;",
            "\t}",
            "",
            "\tret = memblock_isolate_range(&memblock.memory, base, size,",
            "\t\t\t\t\t\t&start_rgn, &end_rgn);",
            "\tif (ret)",
            "\t\treturn;",
            "",
            "\t/* remove all the MAP regions */",
            "\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\tfor (i = start_rgn - 1; i >= 0; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\t/* truncate the reserved regions */",
            "\tmemblock_remove_range(&memblock.reserved, 0, base);",
            "\tmemblock_remove_range(&memblock.reserved,",
            "\t\t\tbase + size, PHYS_ADDR_MAX);",
            "}"
          ],
          "function_name": "memblock_phys_alloc_range, memblock_phys_alloc_try_nid, memblock_free_late, memblock_reserved_kern_size, memblock_estimated_nr_free_pages, __find_max_addr, memblock_enforce_memory_limit, memblock_cap_memory_range",
          "description": "实现物理内存分配/释放控制，包含内存上限强制限制、空闲页面估算、内存区域截断等管理功能，支持对保留内存的容量统计",
          "similarity": 0.5983673334121704
        },
        {
          "chunk_id": 4,
          "file_path": "mm/memblock.c",
          "start_line": 730,
          "end_line": 842,
          "content": [
            "int __init_memblock memblock_add_node(phys_addr_t base, phys_addr_t size,",
            "\t\t\t\t      int nid, enum memblock_flags flags)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] nid=%d flags=%x %pS\\n\", __func__,",
            "\t\t     &base, &end, nid, flags, (void *)_RET_IP_);",
            "",
            "\treturn memblock_add_range(&memblock.memory, base, size, nid, flags);",
            "}",
            "int __init_memblock memblock_add(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\", __func__,",
            "\t\t     &base, &end, (void *)_RET_IP_);",
            "",
            "\treturn memblock_add_range(&memblock.memory, base, size, MAX_NUMNODES, 0);",
            "}",
            "bool __init_memblock memblock_validate_numa_coverage(unsigned long threshold_bytes)",
            "{",
            "\tunsigned long nr_pages = 0;",
            "\tunsigned long start_pfn, end_pfn, mem_size_mb;",
            "\tint nid, i;",
            "",
            "\t/* calculate lose page */",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {",
            "\t\tif (!numa_valid_node(nid))",
            "\t\t\tnr_pages += end_pfn - start_pfn;",
            "\t}",
            "",
            "\tif ((nr_pages << PAGE_SHIFT) > threshold_bytes) {",
            "\t\tmem_size_mb = memblock_phys_mem_size() >> 20;",
            "\t\tpr_err(\"NUMA: no nodes coverage for %luMB of %luMB RAM\\n\",",
            "\t\t       (nr_pages << PAGE_SHIFT) >> 20, mem_size_mb);",
            "\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static int __init_memblock memblock_isolate_range(struct memblock_type *type,",
            "\t\t\t\t\tphys_addr_t base, phys_addr_t size,",
            "\t\t\t\t\tint *start_rgn, int *end_rgn)",
            "{",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "\tint idx;",
            "\tstruct memblock_region *rgn;",
            "",
            "\t*start_rgn = *end_rgn = 0;",
            "",
            "\tif (!size)",
            "\t\treturn 0;",
            "",
            "\t/* we'll create at most two more regions */",
            "\twhile (type->cnt + 2 > type->max)",
            "\t\tif (memblock_double_array(type, base, size) < 0)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tphys_addr_t rbase = rgn->base;",
            "\t\tphys_addr_t rend = rbase + rgn->size;",
            "",
            "\t\tif (rbase >= end)",
            "\t\t\tbreak;",
            "\t\tif (rend <= base)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (rbase < base) {",
            "\t\t\t/*",
            "\t\t\t * @rgn intersects from below.  Split and continue",
            "\t\t\t * to process the next region - the new top half.",
            "\t\t\t */",
            "\t\t\trgn->base = base;",
            "\t\t\trgn->size -= base - rbase;",
            "\t\t\ttype->total_size -= base - rbase;",
            "\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,",
            "\t\t\t\t\t       memblock_get_region_node(rgn),",
            "\t\t\t\t\t       rgn->flags);",
            "\t\t} else if (rend > end) {",
            "\t\t\t/*",
            "\t\t\t * @rgn intersects from above.  Split and redo the",
            "\t\t\t * current region - the new bottom half.",
            "\t\t\t */",
            "\t\t\trgn->base = end;",
            "\t\t\trgn->size -= end - rbase;",
            "\t\t\ttype->total_size -= end - rbase;",
            "\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,",
            "\t\t\t\t\t       memblock_get_region_node(rgn),",
            "\t\t\t\t\t       rgn->flags);",
            "\t\t} else {",
            "\t\t\t/* @rgn is fully contained, record it */",
            "\t\t\tif (!*end_rgn)",
            "\t\t\t\t*start_rgn = idx;",
            "\t\t\t*end_rgn = idx + 1;",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init_memblock memblock_remove_range(struct memblock_type *type,",
            "\t\t\t\t\t  phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint start_rgn, end_rgn;",
            "\tint i, ret;",
            "",
            "\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tfor (i = end_rgn - 1; i >= start_rgn; i--)",
            "\t\tmemblock_remove_region(type, i);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "memblock_add_node, memblock_add, memblock_validate_numa_coverage, memblock_isolate_range, memblock_remove_range",
          "description": "实现节点内存添加（add_node/add）、NUMA覆盖率校验（validate_numa_coverage）及内存范围隔离（isolate_range/remove_range）功能。",
          "similarity": 0.5979975461959839
        },
        {
          "chunk_id": 11,
          "file_path": "mm/memblock.c",
          "start_line": 2094,
          "end_line": 2203,
          "content": [
            "static void __init_memblock memblock_dump(struct memblock_type *type)",
            "{",
            "\tphys_addr_t base, end, size;",
            "\tenum memblock_flags flags;",
            "\tint idx;",
            "\tstruct memblock_region *rgn;",
            "",
            "\tpr_info(\" %s.cnt  = 0x%lx\\n\", type->name, type->cnt);",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tchar nid_buf[32] = \"\";",
            "",
            "\t\tbase = rgn->base;",
            "\t\tsize = rgn->size;",
            "\t\tend = base + size - 1;",
            "\t\tflags = rgn->flags;",
            "#ifdef CONFIG_NUMA",
            "\t\tif (numa_valid_node(memblock_get_region_node(rgn)))",
            "\t\t\tsnprintf(nid_buf, sizeof(nid_buf), \" on node %d\",",
            "\t\t\t\t memblock_get_region_node(rgn));",
            "#endif",
            "\t\tpr_info(\" %s[%#x]\\t[%pa-%pa], %pa bytes%s flags: %#x\\n\",",
            "\t\t\ttype->name, idx, &base, &end, &size, nid_buf, flags);",
            "\t}",
            "}",
            "void __init memblock_allow_resize(void)",
            "{",
            "\tmemblock_can_resize = 1;",
            "}",
            "static int __init early_memblock(char *p)",
            "{",
            "\tif (p && strstr(p, \"debug\"))",
            "\t\tmemblock_debug = 1;",
            "\treturn 0;",
            "}",
            "static void __init free_memmap(unsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tstruct page *start_pg, *end_pg;",
            "\tphys_addr_t pg, pgend;",
            "",
            "\t/*",
            "\t * Convert start_pfn/end_pfn to a struct page pointer.",
            "\t */",
            "\tstart_pg = pfn_to_page(start_pfn - 1) + 1;",
            "\tend_pg = pfn_to_page(end_pfn - 1) + 1;",
            "",
            "\t/*",
            "\t * Convert to physical addresses, and round start upwards and end",
            "\t * downwards.",
            "\t */",
            "\tpg = PAGE_ALIGN(__pa(start_pg));",
            "\tpgend = __pa(end_pg) & PAGE_MASK;",
            "",
            "\t/*",
            "\t * If there are free pages between these, free the section of the",
            "\t * memmap array.",
            "\t */",
            "\tif (pg < pgend)",
            "\t\tmemblock_phys_free(pg, pgend - pg);",
            "}",
            "static void __init free_unused_memmap(void)",
            "{",
            "\tunsigned long start, end, prev_end = 0;",
            "\tint i;",
            "",
            "\tif (!IS_ENABLED(CONFIG_HAVE_ARCH_PFN_VALID) ||",
            "\t    IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This relies on each bank being in address order.",
            "\t * The banks are sorted previously in bootmem_init().",
            "\t */",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, NULL) {",
            "#ifdef CONFIG_SPARSEMEM",
            "\t\t/*",
            "\t\t * Take care not to free memmap entries that don't exist",
            "\t\t * due to SPARSEMEM sections which aren't present.",
            "\t\t */",
            "\t\tstart = min(start, ALIGN(prev_end, PAGES_PER_SECTION));",
            "#endif",
            "\t\t/*",
            "\t\t * Align down here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tstart = pageblock_start_pfn(start);",
            "",
            "\t\t/*",
            "\t\t * If we had a previous bank, and there is a space",
            "\t\t * between the current bank and the previous, free it.",
            "\t\t */",
            "\t\tif (prev_end && prev_end < start)",
            "\t\t\tfree_memmap(prev_end, start);",
            "",
            "\t\t/*",
            "\t\t * Align up here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tprev_end = pageblock_align(end);",
            "\t}",
            "",
            "#ifdef CONFIG_SPARSEMEM",
            "\tif (!IS_ALIGNED(prev_end, PAGES_PER_SECTION)) {",
            "\t\tprev_end = pageblock_align(end);",
            "\t\tfree_memmap(prev_end, ALIGN(prev_end, PAGES_PER_SECTION));",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "memblock_dump, memblock_allow_resize, early_memblock, free_memmap, free_unused_memmap",
          "description": "提供内存块状态调试、调整支持、早期内存处理及未使用memmap释放功能，用于优化内存映射管理",
          "similarity": 0.5783066749572754
        },
        {
          "chunk_id": 14,
          "file_path": "mm/memblock.c",
          "start_line": 2553,
          "end_line": 2689,
          "content": [
            "static int __init reserve_mem_init(void)",
            "{",
            "\tint err;",
            "",
            "\tif (!kho_is_enabled() || !reserved_mem_count)",
            "\t\treturn 0;",
            "",
            "\terr = prepare_kho_fdt();",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = register_kho_notifier(&reserve_mem_kho_nb);",
            "\tif (err) {",
            "\t\tput_page(kho_fdt);",
            "\t\tkho_fdt = NULL;",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "static bool __init reserve_mem_kho_revive(const char *name, phys_addr_t size,",
            "\t\t\t\t\t  phys_addr_t align)",
            "{",
            "\tint err, len_start, len_size, offset;",
            "\tconst phys_addr_t *p_start, *p_size;",
            "\tconst void *fdt;",
            "",
            "\tfdt = reserve_mem_kho_retrieve_fdt();",
            "\tif (!fdt)",
            "\t\treturn false;",
            "",
            "\toffset = fdt_subnode_offset(fdt, 0, name);",
            "\tif (offset < 0) {",
            "\t\tpr_warn(\"FDT '%s' has no child '%s': %d\\n\",",
            "\t\t\tMEMBLOCK_KHO_FDT, name, offset);",
            "\t\treturn false;",
            "\t}",
            "\terr = fdt_node_check_compatible(fdt, offset, RESERVE_MEM_KHO_NODE_COMPATIBLE);",
            "\tif (err) {",
            "\t\tpr_warn(\"Node '%s' is incompatible with '%s': %d\\n\",",
            "\t\t\tname, RESERVE_MEM_KHO_NODE_COMPATIBLE, err);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tp_start = fdt_getprop(fdt, offset, \"start\", &len_start);",
            "\tp_size = fdt_getprop(fdt, offset, \"size\", &len_size);",
            "\tif (!p_start || len_start != sizeof(*p_start) || !p_size ||",
            "\t    len_size != sizeof(*p_size)) {",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (*p_start & (align - 1)) {",
            "\t\tpr_warn(\"KHO reserve-mem '%s' has wrong alignment (0x%lx, 0x%lx)\\n\",",
            "\t\t\tname, (long)align, (long)*p_start);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (*p_size != size) {",
            "\t\tpr_warn(\"KHO reserve-mem '%s' has wrong size (0x%lx != 0x%lx)\\n\",",
            "\t\t\tname, (long)*p_size, (long)size);",
            "\t\treturn false;",
            "\t}",
            "",
            "\treserved_mem_add(*p_start, size, name);",
            "\tpr_info(\"Revived memory reservation '%s' from KHO\\n\", name);",
            "",
            "\treturn true;",
            "}",
            "static bool __init reserve_mem_kho_revive(const char *name, phys_addr_t size,",
            "\t\t\t\t\t  phys_addr_t align)",
            "{",
            "\treturn false;",
            "}",
            "static int __init reserve_mem(char *p)",
            "{",
            "\tphys_addr_t start, size, align, tmp;",
            "\tchar *name;",
            "\tchar *oldp;",
            "\tint len;",
            "",
            "\tif (!p)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Check if there's room for more reserved memory */",
            "\tif (reserved_mem_count >= RESERVE_MEM_MAX_ENTRIES)",
            "\t\treturn -EBUSY;",
            "",
            "\toldp = p;",
            "\tsize = memparse(p, &p);",
            "\tif (!size || p == oldp)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (*p != ':')",
            "\t\treturn -EINVAL;",
            "",
            "\talign = memparse(p+1, &p);",
            "\tif (*p != ':')",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * memblock_phys_alloc() doesn't like a zero size align,",
            "\t * but it is OK for this command to have it.",
            "\t */",
            "\tif (align < SMP_CACHE_BYTES)",
            "\t\talign = SMP_CACHE_BYTES;",
            "",
            "\tname = p + 1;",
            "\tlen = strlen(name);",
            "",
            "\t/* name needs to have length but not too big */",
            "\tif (!len || len >= RESERVE_MEM_NAME_SIZE)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Make sure that name has text */",
            "\tfor (p = name; *p; p++) {",
            "\t\tif (!isspace(*p))",
            "\t\t\tbreak;",
            "\t}",
            "\tif (!*p)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Make sure the name is not already used */",
            "\tif (reserve_mem_find_by_name(name, &start, &tmp))",
            "\t\treturn -EBUSY;",
            "",
            "\t/* Pick previous allocations up from KHO if available */",
            "\tif (reserve_mem_kho_revive(name, size, align))",
            "\t\treturn 1;",
            "",
            "\t/* TODO: Allocation must be outside of scratch region */",
            "\tstart = memblock_phys_alloc(size, align);",
            "\tif (!start)",
            "\t\treturn -ENOMEM;",
            "",
            "\treserved_mem_add(start, size, name);",
            "",
            "\treturn 1;",
            "}"
          ],
          "function_name": "reserve_mem_init, reserve_mem_kho_revive, reserve_mem_kho_revive, reserve_mem",
          "description": "实现预留内存的KHO恢复机制和命令行参数解析接口，用于动态注册预留内存区域并验证兼容性",
          "similarity": 0.5703813433647156
        },
        {
          "chunk_id": 10,
          "file_path": "mm/memblock.c",
          "start_line": 1954,
          "end_line": 2057,
          "content": [
            "void __init memblock_mem_limit_remove_map(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\tmemblock_cap_memory_range(0, max_addr);",
            "}",
            "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)",
            "{",
            "\tunsigned int left = 0, right = type->cnt;",
            "",
            "\tdo {",
            "\t\tunsigned int mid = (right + left) / 2;",
            "",
            "\t\tif (addr < type->regions[mid].base)",
            "\t\t\tright = mid;",
            "\t\telse if (addr >= (type->regions[mid].base +",
            "\t\t\t\t  type->regions[mid].size))",
            "\t\t\tleft = mid + 1;",
            "\t\telse",
            "\t\t\treturn mid;",
            "\t} while (left < right);",
            "\treturn -1;",
            "}",
            "bool __init_memblock memblock_is_reserved(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.reserved, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_memory(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.memory, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_map_memory(phys_addr_t addr)",
            "{",
            "\tint i = memblock_search(&memblock.memory, addr);",
            "",
            "\tif (i == -1)",
            "\t\treturn false;",
            "\treturn !memblock_is_nomap(&memblock.memory.regions[i]);",
            "}",
            "int __init_memblock memblock_search_pfn_nid(unsigned long pfn,",
            "\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)",
            "{",
            "\tstruct memblock_type *type = &memblock.memory;",
            "\tint mid = memblock_search(type, PFN_PHYS(pfn));",
            "",
            "\tif (mid == -1)",
            "\t\treturn -1;",
            "",
            "\t*start_pfn = PFN_DOWN(type->regions[mid].base);",
            "\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);",
            "",
            "\treturn memblock_get_region_node(&type->regions[mid]);",
            "}",
            "bool __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint idx = memblock_search(&memblock.memory, base);",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "",
            "\tif (idx == -1)",
            "\t\treturn false;",
            "\treturn (memblock.memory.regions[idx].base +",
            "\t\t memblock.memory.regions[idx].size) >= end;",
            "}",
            "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_overlaps_region(&memblock.reserved, base, size);",
            "}",
            "void __init_memblock memblock_trim_memory(phys_addr_t align)",
            "{",
            "\tphys_addr_t start, end, orig_start, orig_end;",
            "\tstruct memblock_region *r;",
            "",
            "\tfor_each_mem_region(r) {",
            "\t\torig_start = r->base;",
            "\t\torig_end = r->base + r->size;",
            "\t\tstart = round_up(orig_start, align);",
            "\t\tend = round_down(orig_end, align);",
            "",
            "\t\tif (start == orig_start && end == orig_end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start < end) {",
            "\t\t\tr->base = start;",
            "\t\t\tr->size = end - start;",
            "\t\t} else {",
            "\t\t\tmemblock_remove_region(&memblock.memory,",
            "\t\t\t\t\t       r - memblock.memory.regions);",
            "\t\t\tr--;",
            "\t\t}",
            "\t}",
            "}",
            "void __init_memblock memblock_set_current_limit(phys_addr_t limit)",
            "{",
            "\tmemblock.current_limit = limit;",
            "}"
          ],
          "function_name": "memblock_mem_limit_remove_map, memblock_search, memblock_is_reserved, memblock_is_memory, memblock_is_map_memory, memblock_search_pfn_nid, memblock_is_region_memory, memblock_is_region_reserved, memblock_trim_memory, memblock_set_current_limit",
          "description": "实现内存块限制移除、搜索和区域判断逻辑，用于管理内存和保留区域的地址范围查询及修剪操作",
          "similarity": 0.5684453845024109
        }
      ]
    },
    {
      "source_file": "mm/secretmem.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:16:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `secretmem.c`\n\n---\n\n# secretmem.c 技术文档\n\n## 1. 文件概述\n\n`secretmem.c` 实现了 Linux 内核中的 **Secret Memory（秘密内存）** 功能，提供了一种安全的、不可交换（non-swappable）、不可转储（non-dumpable）且对内核页表隐藏的匿名内存区域。该功能通过新增系统调用 `memfd_secret(2)` 暴露给用户空间，用于创建具有特殊安全属性的内存文件描述符。此类内存主要用于存储敏感数据（如加密密钥），防止其被意外泄露到 swap、core dump 或通过 `/proc/pid/maps` 被探测。\n\n## 2. 核心功能\n\n### 主要函数\n- `memfd_secret(unsigned int flags)`：系统调用入口，创建 secret memory 文件描述符。\n- `secretmem_fault(struct vm_fault *vmf)`：处理缺页异常，按需分配并锁定秘密内存页。\n- `secretmem_mmap(struct file *file, struct vm_area_struct *vma)`：设置 VMA 属性，启用 `VM_LOCKED | VM_DONTDUMP` 并绑定 fault handler。\n- `secretmem_release(struct inode *inode, struct file *file)`：释放文件时减少用户计数。\n- `secretmem_file_create(unsigned long flags)`：创建基于伪文件系统的 secret memory 文件对象。\n- `secretmem_init(void)`：模块初始化，挂载 secretmem 伪文件系统。\n\n### 关键数据结构\n- `secretmem_fops`：文件操作结构体，定义 `.mmap` 和 `.release` 方法。\n- `secretmem_vm_ops`：VMA 操作结构体，仅实现 `.fault` 回调。\n- `secretmem_aops`：地址空间操作结构体，包含：\n  - `.free_folio`：释放页面前恢复直接映射并清零。\n  - `.migrate_folio`：返回 `-EBUSY` 禁止迁移。\n  - `.dirty_folio`：空操作（`noop_dirty_folio`），禁止脏页标记。\n- `secretmem_iops`：inode 操作结构体，限制文件大小不可修改（除初始为 0 外）。\n\n### 全局变量\n- `secretmem_enable`：模块参数，控制是否启用 secretmem 功能（默认启用）。\n- `secretmem_users`：原子计数器，跟踪当前活跃的 secret memory 用户数量。\n- `secretmem_mnt`：指向 secretmem 伪文件系统的内核挂载点。\n\n## 3. 关键实现\n\n### 内存安全性保障\n- **直接映射移除**：在 `secretmem_fault()` 中分配新页后，调用 `set_direct_map_invalid_noflush()` 将该物理页从内核直接映射区（direct map）中移除，使内核无法通过常规线性地址访问该页内容，增强对抗内核漏洞利用的能力。\n- **页面清零与恢复**：在 `secretmem_free_folio()` 中，先调用 `set_direct_map_default_noflush()` 恢复直接映射，再使用 `folio_zero_segment()` 安全清零页面内容，防止敏感数据残留。\n- **TLB 刷新**：分配新页并修改直接映射后，调用 `flush_tlb_kernel_range()` 刷新内核 TLB，确保 CPU 不再缓存旧映射。\n\n### 内存管理特性\n- **不可交换 & 不可回收**：通过 `mapping_set_unevictable()` 标记 address_space 为不可驱逐，确保页面不会被 swap 出或被内存回收机制回收。\n- **禁止迁移**：`.migrate_folio` 返回 `-EBUSY`，阻止 CMA、内存热插拔等场景下的页面迁移。\n- **禁止写脏**：使用 `noop_dirty_folio` 防止页面被标记为 dirty，避免写回行为。\n- **强制锁定**：`secretmem_mmap()` 强制设置 `VM_LOCKED`，结合 `mlock_future_ok()` 检查，确保内存常驻物理 RAM。\n\n### 文件系统与权限控制\n- 基于 `anon_inode` 构建伪文件系统（magic: `SECRETMEM_MAGIC`），挂载时设置 `MNT_NOEXEC` 禁止执行。\n- 文件大小只能为 0，`setattr` 操作拒绝任何非零的 `ATTR_SIZE` 修改。\n- 文件描述符默认具有 `O_RDWR` 权限，但实际 I/O 通过 mmap 访问。\n\n### 系统调用验证\n- 仅当 `secretmem_enable=1` 且平台支持 `can_set_direct_map()`（如 x86 的 `set_memory_valid()`）时才启用。\n- 参数 `flags` 必须为 `O_CLOEXEC` 或 0，其他位均视为非法。\n\n## 4. 依赖关系\n\n- **架构支持**：依赖 `asm/tlbflush.h` 和 `set_memory.h` 提供的 `set_direct_map_*` 及 TLB 刷新接口，目前主要在 x86 上实现。\n- **内存管理子系统**：重度依赖 `mm/` 下的 `filemap`、`folio`、`mlock`、`swap` 等机制。\n- **VFS 层**：使用 `pseudo_fs.h` 和 `anon_inode` 基础设施创建安全 inode。\n- **UAPI**：通过 `uapi/linux/magic.h` 定义文件系统 magic number。\n- **模块参数**：使用 `module_param_named` 提供运行时开关。\n\n## 5. 使用场景\n\n- **敏感数据保护**：应用程序（如加密库、密钥管理服务）可使用 `memfd_secret()` 创建内存区域存储私钥、会话密钥等，防止其出现在 swap 分区或 core dump 文件中。\n- **安全隔离**：由于页面从内核直接映射中移除，即使内核存在任意地址读取漏洞，攻击者也难以直接定位和提取 secret memory 中的数据。\n- **高性能安全内存**：相比传统 `mlock()` + `mmap()` 方案，secret memory 提供更严格的访问控制和自动清零机制，适用于对安全性要求极高的场景。\n- **容器与虚拟化**：可在容器或 VM 中为可信应用提供受保护的内存空间，降低侧信道攻击风险。",
      "similarity": 0.6254967451095581,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/secretmem.c",
          "start_line": 45,
          "end_line": 163,
          "content": [
            "bool secretmem_active(void)",
            "{",
            "\treturn !!atomic_read(&secretmem_users);",
            "}",
            "static vm_fault_t secretmem_fault(struct vm_fault *vmf)",
            "{",
            "\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;",
            "\tstruct inode *inode = file_inode(vmf->vma->vm_file);",
            "\tpgoff_t offset = vmf->pgoff;",
            "\tgfp_t gfp = vmf->gfp_mask;",
            "\tunsigned long addr;",
            "\tstruct page *page;",
            "\tstruct folio *folio;",
            "\tvm_fault_t ret;",
            "\tint err;",
            "",
            "\tif (((loff_t)vmf->pgoff << PAGE_SHIFT) >= i_size_read(inode))",
            "\t\treturn vmf_error(-EINVAL);",
            "",
            "\tfilemap_invalidate_lock_shared(mapping);",
            "",
            "retry:",
            "\tpage = find_lock_page(mapping, offset);",
            "\tif (!page) {",
            "\t\tfolio = folio_alloc(gfp | __GFP_ZERO, 0);",
            "\t\tif (!folio) {",
            "\t\t\tret = VM_FAULT_OOM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tpage = &folio->page;",
            "\t\terr = set_direct_map_invalid_noflush(page);",
            "\t\tif (err) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\tret = vmf_error(err);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\t__folio_mark_uptodate(folio);",
            "\t\terr = filemap_add_folio(mapping, folio, offset, gfp);",
            "\t\tif (unlikely(err)) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\t/*",
            "\t\t\t * If a split of large page was required, it",
            "\t\t\t * already happened when we marked the page invalid",
            "\t\t\t * which guarantees that this call won't fail",
            "\t\t\t */",
            "\t\t\tset_direct_map_default_noflush(page);",
            "\t\t\tif (err == -EEXIST)",
            "\t\t\t\tgoto retry;",
            "",
            "\t\t\tret = vmf_error(err);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\taddr = (unsigned long)page_address(page);",
            "\t\tflush_tlb_kernel_range(addr, addr + PAGE_SIZE);",
            "\t}",
            "",
            "\tvmf->page = page;",
            "\tret = VM_FAULT_LOCKED;",
            "",
            "out:",
            "\tfilemap_invalidate_unlock_shared(mapping);",
            "\treturn ret;",
            "}",
            "static int secretmem_release(struct inode *inode, struct file *file)",
            "{",
            "\tatomic_dec(&secretmem_users);",
            "\treturn 0;",
            "}",
            "static int secretmem_mmap(struct file *file, struct vm_area_struct *vma)",
            "{",
            "\tunsigned long len = vma->vm_end - vma->vm_start;",
            "",
            "\tif ((vma->vm_flags & (VM_SHARED | VM_MAYSHARE)) == 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!mlock_future_ok(vma->vm_mm, vma->vm_flags | VM_LOCKED, len))",
            "\t\treturn -EAGAIN;",
            "",
            "\tvm_flags_set(vma, VM_LOCKED | VM_DONTDUMP);",
            "\tvma->vm_ops = &secretmem_vm_ops;",
            "",
            "\treturn 0;",
            "}",
            "bool vma_is_secretmem(struct vm_area_struct *vma)",
            "{",
            "\treturn vma->vm_ops == &secretmem_vm_ops;",
            "}",
            "static int secretmem_migrate_folio(struct address_space *mapping,",
            "\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)",
            "{",
            "\treturn -EBUSY;",
            "}",
            "static void secretmem_free_folio(struct folio *folio)",
            "{",
            "\tset_direct_map_default_noflush(&folio->page);",
            "\tfolio_zero_segment(folio, 0, folio_size(folio));",
            "}",
            "static int secretmem_setattr(struct mnt_idmap *idmap,",
            "\t\t\t     struct dentry *dentry, struct iattr *iattr)",
            "{",
            "\tstruct inode *inode = d_inode(dentry);",
            "\tstruct address_space *mapping = inode->i_mapping;",
            "\tunsigned int ia_valid = iattr->ia_valid;",
            "\tint ret;",
            "",
            "\tfilemap_invalidate_lock(mapping);",
            "",
            "\tif ((ia_valid & ATTR_SIZE) && inode->i_size)",
            "\t\tret = -EINVAL;",
            "\telse",
            "\t\tret = simple_setattr(idmap, dentry, iattr);",
            "",
            "\tfilemap_invalidate_unlock(mapping);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "secretmem_active, secretmem_fault, secretmem_release, secretmem_mmap, vma_is_secretmem, secretmem_migrate_folio, secretmem_free_folio, secretmem_setattr",
          "description": "实现secretmem核心功能，包括检查是否启用、处理页面故障时分配并标记不可执行页面、管理VMA标志、验证文件属性等内存加密相关操作",
          "similarity": 0.596387505531311
        },
        {
          "chunk_id": 2,
          "file_path": "mm/secretmem.c",
          "start_line": 262,
          "end_line": 279,
          "content": [
            "static int secretmem_init_fs_context(struct fs_context *fc)",
            "{",
            "\treturn init_pseudo(fc, SECRETMEM_MAGIC) ? 0 : -ENOMEM;",
            "}",
            "static int __init secretmem_init(void)",
            "{",
            "\tif (!secretmem_enable || !can_set_direct_map())",
            "\t\treturn 0;",
            "",
            "\tsecretmem_mnt = kern_mount(&secretmem_fs);",
            "\tif (IS_ERR(secretmem_mnt))",
            "\t\treturn PTR_ERR(secretmem_mnt);",
            "",
            "\t/* prevent secretmem mappings from ever getting PROT_EXEC */",
            "\tsecretmem_mnt->mnt_flags |= MNT_NOEXEC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "secretmem_init_fs_context, secretmem_init",
          "description": "初始化secretmem伪文件系统，通过kern_mount创建挂载点并设置MNT_NOEXEC标志，防止秘密内存区域被赋予执行权限",
          "similarity": 0.580609917640686
        },
        {
          "chunk_id": 0,
          "file_path": "mm/secretmem.c",
          "start_line": 1,
          "end_line": 44,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright IBM Corporation, 2021",
            " *",
            " * Author: Mike Rapoport <rppt@linux.ibm.com>",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/memfd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/printk.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/sched/signal.h>",
            "",
            "#include <uapi/linux/magic.h>",
            "",
            "#include <asm/tlbflush.h>",
            "",
            "#include \"internal.h\"",
            "",
            "#undef pr_fmt",
            "#define pr_fmt(fmt) \"secretmem: \" fmt",
            "",
            "/*",
            " * Define mode and flag masks to allow validation of the system call",
            " * parameters.",
            " */",
            "#define SECRETMEM_MODE_MASK\t(0x0)",
            "#define SECRETMEM_FLAGS_MASK\tSECRETMEM_MODE_MASK",
            "",
            "static bool secretmem_enable __ro_after_init = 1;",
            "module_param_named(enable, secretmem_enable, bool, 0400);",
            "MODULE_PARM_DESC(secretmem_enable,",
            "\t\t \"Enable secretmem and memfd_secret(2) system call\");",
            "",
            "static atomic_t secretmem_users;",
            ""
          ],
          "function_name": null,
          "description": "定义secretmem模块的许可证和基本包含头文件，声明全局变量secretmem_enable用于控制功能启用状态，并注册模块参数供外部配置",
          "similarity": 0.5550715923309326
        }
      ]
    }
  ]
}