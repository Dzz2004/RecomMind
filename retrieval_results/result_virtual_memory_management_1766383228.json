{
  "query": "virtual memory management",
  "timestamp": "2025-12-22 14:00:28",
  "retrieved_files": [
    {
      "source_file": "mm/memory_hotplug.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:43:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memory_hotplug.c`\n\n---\n\n# memory_hotplug.c 技术文档\n\n## 1. 文件概述\n\n`memory_hotplug.c` 是 Linux 内核中实现内存热插拔（Memory Hotplug）功能的核心源文件，位于 `mm/` 子系统目录下。该文件提供了在系统运行时动态添加或移除物理内存区域的能力，包括内存资源注册、页表映射管理、内存上线策略控制、以及与 NUMA 架构的协同支持。它主要处理热添加内存时的初始化、内存块（memory block）管理、vmemmap 映射优化、以及在线策略配置等关键逻辑。\n\n## 2. 核心功能\n\n### 主要全局变量与参数\n- `memmap_mode`：控制是否启用“内存上的 memmap”（memmap on memory）特性，支持 `disable`、`enable` 和 `force` 三种模式。\n- `online_policy`：定义内存上线时的默认区域分配策略，可选 `contig-zones`（保持区域连续）或 `auto-movable`（自动分配到 ZONE_MOVABLE）。\n- `auto_movable_ratio`：在 `auto-movable` 策略下，系统允许的 MOVABLE 与 KERNEL 内存的最大百分比比例（默认 301%，即约 3:1）。\n- `auto_movable_numa_aware`（仅 CONFIG_NUMA）：是否在 `auto-movable` 策略中考虑 NUMA 节点级别的内存统计。\n- `mhp_default_online_type`：内存热插拔时的默认上线类型（如 `MMOP_ONLINE_KERNEL`、`MMOP_ONLINE_MOVABLE` 等）。\n- `movable_node_enabled`：标志是否启用了可移动节点（movable node）功能。\n- `max_mem_size`：系统允许的最大内存大小上限（默认为 `U64_MAX`）。\n\n### 主要函数与接口\n- `get_online_mems()` / `put_online_mems()`：获取/释放内存热插拔读锁，用于保护内存上线/下线操作。\n- `mem_hotplug_begin()` / `mem_hotplug_done()`：执行内存热插拔写操作前后的同步原语，同时持有 CPU 热插拔读锁和内存热插拔写锁。\n- `mhp_get_default_online_type()` / `mhp_set_default_online_type()`：获取或设置内存热插拔的默认上线类型。\n- `register_memory_resource()`：将新添加的内存区域注册为 I/O 资源（`System RAM` 类型），并检查是否超出 `max_mem_size` 限制。\n- `mhp_memmap_on_memory()`：判断当前是否启用了 memmap on memory 特性。\n- `memory_block_memmap_on_memory_pages()`：计算在 memmap on memory 模式下，每个内存块所需的额外页数（可能因对齐而浪费内存）。\n\n### 回调机制\n- `online_page_callback`：指向当前用于上线单个页面的回调函数，默认为 `generic_online_page`。\n- `set_online_page_callback()` / `restore_online_page_callback()`（声明未在片段中，但有注释说明）：用于动态替换或恢复页面上线回调。\n\n### 内核参数（module_param）\n- `memmap_on_memory`：启用 memmap on memory 功能（Y/N/force）。\n- `online_policy`：设置默认上线策略。\n- `auto_movable_ratio`：设置 MOVABLE/KERNEL 内存比例上限。\n- `auto_movable_numa_aware`：是否在 NUMA 感知下应用 auto-movable 策略。\n- 启动参数 `memhp_default_state=`：通过内核命令行设置默认上线状态。\n\n## 3. 关键实现\n\n### Memmap on Memory 机制\n当启用 `CONFIG_MHP_MEMMAP_ON_MEMORY` 时，内核尝试将描述物理页的 `struct page` 数组（即 vmemmap）直接放置在待热插拔的内存区域内，而非依赖预先保留的虚拟地址空间。这减少了对固定 vmemmap 区域的依赖，提升灵活性：\n- **ENABLE 模式**：仅当 vmemmap 大小能被页块（pageblock）整除时才启用。\n- **FORCE 模式**：强制对齐到页块边界，即使造成内存浪费（通过 `pageblock_align()` 实现），确保总能使用该内存区域存放 memmap。\n\n### 内存上线策略\n- **contig-zones（默认）**：将新内存添加到现有内存区域末尾，保持 ZONE_NORMAL 等区域的物理连续性。\n- **auto-movable**：根据全局（及 NUMA 节点）的 KERNEL 与 MOVABLE 内存比例，智能决定是否将新内存加入 ZONE_MOVABLE，以提高内存可迁移性和碎片整理效率。比例由 `auto_movable_ratio` 控制。\n\n### 并发控制\n使用 `percpu_rwsem mem_hotplug_lock` 作为内存热插拔操作的主同步机制：\n- 读操作（如内存访问路径）调用 `get/put_online_mems()` 获取读锁。\n- 写操作（如 add_memory）调用 `mem_hotplug_begin/done()` 获取写锁，并同时持有 `cpus_read_lock()` 防止 CPU 热插拔干扰。\n\n### 资源与大小限制\n- 通过 `mhp_range_allowed()` 检查待添加内存是否超出 `max_mem_size`。\n- 使用 `register_memory_resource()` 将内存注册为 `IORESOURCE_SYSTEM_RAM` 资源，若资源名非 \"System RAM\" 则标记为驱动管理（`IORESOURCE_SYSRAM_DRIVER_MANAGED`）。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `mm.h`、`page-isolation.h`、`migrate.h`、`compaction.h` 等，用于页面分配、隔离、迁移和压缩。\n- **体系结构相关**：包含 `asm/tlbflush.h` 用于 TLB 刷新；依赖 `pfn.h`、`memblock.h` 处理物理页帧和启动内存布局。\n- **设备模型与 sysfs**：通过 `memory.h` 与用户空间交互（如 `/sys/devices/system/memory/`）。\n- **NUMA 支持**：在 `CONFIG_NUMA` 下使用节点感知策略。\n- **虚拟内存**：依赖 `vmalloc.h` 和 `memremap.h` 管理 vmemmap 映射。\n- **电源管理**：包含 `suspend.h`，可能与休眠/唤醒流程协调。\n- **固件接口**：使用 `firmware-map.h` 与平台固件交互内存布局信息。\n\n## 5. 使用场景\n\n- **物理内存热添加**：在支持内存热插拔的服务器（如 IBM Power、x86 ACPI 系统）上，动态增加 DIMM 或内存模块后，内核通过此文件完成内存初始化和上线。\n- **虚拟化环境**：KVM、Xen 等 hypervisor 向客户机热添加内存时，客户机内核调用此模块处理新增内存。\n- **内存故障恢复**：在某些 RAS（Reliability, Availability, Serviceability）场景中，隔离坏页后重新上线备用内存。\n- **测试与开发**：通过 sysfs 接口（如 `echo online > /sys/devices/system/memory/memoryX/state`）手动上线内存块，配合 `online_policy` 和 `memmap_on_memory` 参数进行功能验证。\n- **容器与云平台**：支持弹性内存扩展，按需分配物理内存资源。",
      "similarity": 0.6198397874832153,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 1529,
          "end_line": 1660,
          "content": [
            "int __ref __add_memory(int nid, u64 start, u64 size, mhp_t mhp_flags)",
            "{",
            "\tstruct resource *res;",
            "\tint ret;",
            "",
            "\tres = register_memory_resource(start, size, \"System RAM\");",
            "\tif (IS_ERR(res))",
            "\t\treturn PTR_ERR(res);",
            "",
            "\tret = add_memory_resource(nid, res, mhp_flags);",
            "\tif (ret < 0)",
            "\t\trelease_memory_resource(res);",
            "\treturn ret;",
            "}",
            "int add_memory(int nid, u64 start, u64 size, mhp_t mhp_flags)",
            "{",
            "\tint rc;",
            "",
            "\tlock_device_hotplug();",
            "\trc = __add_memory(nid, start, size, mhp_flags);",
            "\tunlock_device_hotplug();",
            "",
            "\treturn rc;",
            "}",
            "int add_memory_driver_managed(int nid, u64 start, u64 size,",
            "\t\t\t      const char *resource_name, mhp_t mhp_flags)",
            "{",
            "\tstruct resource *res;",
            "\tint rc;",
            "",
            "\tif (!resource_name ||",
            "\t    strstr(resource_name, \"System RAM (\") != resource_name ||",
            "\t    resource_name[strlen(resource_name) - 1] != ')')",
            "\t\treturn -EINVAL;",
            "",
            "\tlock_device_hotplug();",
            "",
            "\tres = register_memory_resource(start, size, resource_name);",
            "\tif (IS_ERR(res)) {",
            "\t\trc = PTR_ERR(res);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\trc = add_memory_resource(nid, res, mhp_flags);",
            "\tif (rc < 0)",
            "\t\trelease_memory_resource(res);",
            "",
            "out_unlock:",
            "\tunlock_device_hotplug();",
            "\treturn rc;",
            "}",
            "struct range __weak arch_get_mappable_range(void)",
            "{",
            "\tstruct range mhp_range = {",
            "\t\t.start = 0UL,",
            "\t\t.end = -1ULL,",
            "\t};",
            "\treturn mhp_range;",
            "}",
            "struct range mhp_get_pluggable_range(bool need_mapping)",
            "{",
            "\tconst u64 max_phys = PHYSMEM_END;",
            "\tstruct range mhp_range;",
            "",
            "\tif (need_mapping) {",
            "\t\tmhp_range = arch_get_mappable_range();",
            "\t\tif (mhp_range.start > max_phys) {",
            "\t\t\tmhp_range.start = 0;",
            "\t\t\tmhp_range.end = 0;",
            "\t\t}",
            "\t\tmhp_range.end = min_t(u64, mhp_range.end, max_phys);",
            "\t} else {",
            "\t\tmhp_range.start = 0;",
            "\t\tmhp_range.end = max_phys;",
            "\t}",
            "\treturn mhp_range;",
            "}",
            "bool mhp_range_allowed(u64 start, u64 size, bool need_mapping)",
            "{",
            "\tstruct range mhp_range = mhp_get_pluggable_range(need_mapping);",
            "\tu64 end = start + size;",
            "",
            "\tif (start < end && start >= mhp_range.start && (end - 1) <= mhp_range.end)",
            "\t\treturn true;",
            "",
            "\tpr_warn(\"Hotplug memory [%#llx-%#llx] exceeds maximum addressable range [%#llx-%#llx]\\n\",",
            "\t\tstart, end, mhp_range.start, mhp_range.end);",
            "\treturn false;",
            "}",
            "static int scan_movable_pages(unsigned long start, unsigned long end,",
            "\t\t\t      unsigned long *movable_pfn)",
            "{",
            "\tunsigned long pfn;",
            "",
            "\tfor_each_valid_pfn(pfn, start, end) {",
            "\t\tstruct page *page;",
            "\t\tstruct folio *folio;",
            "",
            "\t\tpage = pfn_to_page(pfn);",
            "\t\tif (PageLRU(page))",
            "\t\t\tgoto found;",
            "\t\tif (__PageMovable(page))",
            "\t\t\tgoto found;",
            "",
            "\t\t/*",
            "\t\t * PageOffline() pages that are not marked __PageMovable() and",
            "\t\t * have a reference count > 0 (after MEM_GOING_OFFLINE) are",
            "\t\t * definitely unmovable. If their reference count would be 0,",
            "\t\t * they could at least be skipped when offlining memory.",
            "\t\t */",
            "\t\tif (PageOffline(page) && page_count(page))",
            "\t\t\treturn -EBUSY;",
            "",
            "\t\tif (!PageHuge(page))",
            "\t\t\tcontinue;",
            "\t\tfolio = page_folio(page);",
            "\t\t/*",
            "\t\t * This test is racy as we hold no reference or lock.  The",
            "\t\t * hugetlb page could have been free'ed and head is no longer",
            "\t\t * a hugetlb page before the following check.  In such unlikely",
            "\t\t * cases false positives and negatives are possible.  Calling",
            "\t\t * code must deal with these scenarios.",
            "\t\t */",
            "\t\tif (folio_test_hugetlb_migratable(folio))",
            "\t\t\tgoto found;",
            "\t\tpfn |= folio_nr_pages(folio) - 1;",
            "\t}",
            "\treturn -ENOENT;",
            "found:",
            "\t*movable_pfn = pfn;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__add_memory, add_memory, add_memory_driver_managed, arch_get_mappable_range, mhp_get_pluggable_range, mhp_range_allowed, scan_movable_pages",
          "description": "__add_memory 和 add_memory 添加内存资源；add_memory_driver_managed 处理驱动管理内存资源；arch_get_mappable_range 获取可映射范围；mhp_get_pluggable_range 确定可插入内存范围；mhp_range_allowed 检查地址有效性；scan_movable_pages 扫描可移动页面",
          "similarity": 0.6096619367599487
        },
        {
          "chunk_id": 13,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 2233,
          "end_line": 2352,
          "content": [
            "void __remove_memory(u64 start, u64 size)",
            "{",
            "",
            "\t/*",
            "\t * trigger BUG() if some memory is not offlined prior to calling this",
            "\t * function",
            "\t */",
            "\tif (try_remove_memory(start, size))",
            "\t\tBUG();",
            "}",
            "int remove_memory(u64 start, u64 size)",
            "{",
            "\tint rc;",
            "",
            "\tlock_device_hotplug();",
            "\trc = try_remove_memory(start, size);",
            "\tunlock_device_hotplug();",
            "",
            "\treturn rc;",
            "}",
            "static int try_offline_memory_block(struct memory_block *mem, void *arg)",
            "{",
            "\tuint8_t online_type = MMOP_ONLINE_KERNEL;",
            "\tuint8_t **online_types = arg;",
            "\tstruct page *page;",
            "\tint rc;",
            "",
            "\t/*",
            "\t * Sense the online_type via the zone of the memory block. Offlining",
            "\t * with multiple zones within one memory block will be rejected",
            "\t * by offlining code ... so we don't care about that.",
            "\t */",
            "\tpage = pfn_to_online_page(section_nr_to_pfn(mem->start_section_nr));",
            "\tif (page && zone_idx(page_zone(page)) == ZONE_MOVABLE)",
            "\t\tonline_type = MMOP_ONLINE_MOVABLE;",
            "",
            "\trc = device_offline(&mem->dev);",
            "\t/*",
            "\t * Default is MMOP_OFFLINE - change it only if offlining succeeded,",
            "\t * so try_reonline_memory_block() can do the right thing.",
            "\t */",
            "\tif (!rc)",
            "\t\t**online_types = online_type;",
            "",
            "\t(*online_types)++;",
            "\t/* Ignore if already offline. */",
            "\treturn rc < 0 ? rc : 0;",
            "}",
            "static int try_reonline_memory_block(struct memory_block *mem, void *arg)",
            "{",
            "\tuint8_t **online_types = arg;",
            "\tint rc;",
            "",
            "\tif (**online_types != MMOP_OFFLINE) {",
            "\t\tmem->online_type = **online_types;",
            "\t\trc = device_online(&mem->dev);",
            "\t\tif (rc < 0)",
            "\t\t\tpr_warn(\"%s: Failed to re-online memory: %d\",",
            "\t\t\t\t__func__, rc);",
            "\t}",
            "",
            "\t/* Continue processing all remaining memory blocks. */",
            "\t(*online_types)++;",
            "\treturn 0;",
            "}",
            "int offline_and_remove_memory(u64 start, u64 size)",
            "{",
            "\tconst unsigned long mb_count = size / memory_block_size_bytes();",
            "\tuint8_t *online_types, *tmp;",
            "\tint rc;",
            "",
            "\tif (!IS_ALIGNED(start, memory_block_size_bytes()) ||",
            "\t    !IS_ALIGNED(size, memory_block_size_bytes()) || !size)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * We'll remember the old online type of each memory block, so we can",
            "\t * try to revert whatever we did when offlining one memory block fails",
            "\t * after offlining some others succeeded.",
            "\t */",
            "\tonline_types = kmalloc_array(mb_count, sizeof(*online_types),",
            "\t\t\t\t     GFP_KERNEL);",
            "\tif (!online_types)",
            "\t\treturn -ENOMEM;",
            "\t/*",
            "\t * Initialize all states to MMOP_OFFLINE, so when we abort processing in",
            "\t * try_offline_memory_block(), we'll skip all unprocessed blocks in",
            "\t * try_reonline_memory_block().",
            "\t */",
            "\tmemset(online_types, MMOP_OFFLINE, mb_count);",
            "",
            "\tlock_device_hotplug();",
            "",
            "\ttmp = online_types;",
            "\trc = walk_memory_blocks(start, size, &tmp, try_offline_memory_block);",
            "",
            "\t/*",
            "\t * In case we succeeded to offline all memory, remove it.",
            "\t * This cannot fail as it cannot get onlined in the meantime.",
            "\t */",
            "\tif (!rc) {",
            "\t\trc = try_remove_memory(start, size);",
            "\t\tif (rc)",
            "\t\t\tpr_err(\"%s: Failed to remove memory: %d\", __func__, rc);",
            "\t}",
            "",
            "\t/*",
            "\t * Rollback what we did. While memory onlining might theoretically fail",
            "\t * (nacked by a notifier), it barely ever happens.",
            "\t */",
            "\tif (rc) {",
            "\t\ttmp = online_types;",
            "\t\twalk_memory_blocks(start, size, &tmp,",
            "\t\t\t\t   try_reonline_memory_block);",
            "\t}",
            "\tunlock_device_hotplug();",
            "",
            "\tkfree(online_types);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "__remove_memory, remove_memory, try_offline_memory_block, try_reonline_memory_block, offline_and_remove_memory",
          "description": "offline_and_remove_memory 管理内存块的离线与移除流程，记录各内存块原始在线类型，在部分失败时回滚操作；try_offline_memory_block 和 try_reonline_memory_block 分别用于设置内存块离线状态及恢复在线状态",
          "similarity": 0.6053276658058167
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 52,
          "end_line": 153,
          "content": [
            "static inline unsigned long memory_block_memmap_size(void)",
            "{",
            "\treturn PHYS_PFN(memory_block_size_bytes()) * sizeof(struct page);",
            "}",
            "static inline unsigned long memory_block_memmap_on_memory_pages(void)",
            "{",
            "\tunsigned long nr_pages = PFN_UP(memory_block_memmap_size());",
            "",
            "\t/*",
            "\t * In \"forced\" memmap_on_memory mode, we add extra pages to align the",
            "\t * vmemmap size to cover full pageblocks. That way, we can add memory",
            "\t * even if the vmemmap size is not properly aligned, however, we might waste",
            "\t * memory.",
            "\t */",
            "\tif (memmap_mode == MEMMAP_ON_MEMORY_FORCE)",
            "\t\treturn pageblock_align(nr_pages);",
            "\treturn nr_pages;",
            "}",
            "static int set_memmap_mode(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint ret, mode;",
            "\tbool enabled;",
            "",
            "\tif (sysfs_streq(val, \"force\") ||  sysfs_streq(val, \"FORCE\")) {",
            "\t\tmode = MEMMAP_ON_MEMORY_FORCE;",
            "\t} else {",
            "\t\tret = kstrtobool(val, &enabled);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t\tif (enabled)",
            "\t\t\tmode = MEMMAP_ON_MEMORY_ENABLE;",
            "\t\telse",
            "\t\t\tmode = MEMMAP_ON_MEMORY_DISABLE;",
            "\t}",
            "\t*((int *)kp->arg) = mode;",
            "\tif (mode == MEMMAP_ON_MEMORY_FORCE) {",
            "\t\tunsigned long memmap_pages = memory_block_memmap_on_memory_pages();",
            "",
            "\t\tpr_info_once(\"Memory hotplug will waste %ld pages in each memory block\\n\",",
            "\t\t\t     memmap_pages - PFN_UP(memory_block_memmap_size()));",
            "\t}",
            "\treturn 0;",
            "}",
            "static int get_memmap_mode(char *buffer, const struct kernel_param *kp)",
            "{",
            "\tint mode = *((int *)kp->arg);",
            "",
            "\tif (mode == MEMMAP_ON_MEMORY_FORCE)",
            "\t\treturn sprintf(buffer, \"force\\n\");",
            "\treturn sprintf(buffer, \"%c\\n\", mode ? 'Y' : 'N');",
            "}",
            "static inline bool mhp_memmap_on_memory(void)",
            "{",
            "\treturn memmap_mode != MEMMAP_ON_MEMORY_DISABLE;",
            "}",
            "static inline bool mhp_memmap_on_memory(void)",
            "{",
            "\treturn false;",
            "}",
            "static int set_online_policy(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint ret = sysfs_match_string(online_policy_to_str, val);",
            "",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\t*((int *)kp->arg) = ret;",
            "\treturn 0;",
            "}",
            "static int get_online_policy(char *buffer, const struct kernel_param *kp)",
            "{",
            "\treturn sprintf(buffer, \"%s\\n\", online_policy_to_str[*((int *)kp->arg)]);",
            "}",
            "void get_online_mems(void)",
            "{",
            "\tpercpu_down_read(&mem_hotplug_lock);",
            "}",
            "void put_online_mems(void)",
            "{",
            "\tpercpu_up_read(&mem_hotplug_lock);",
            "}",
            "int mhp_get_default_online_type(void)",
            "{",
            "\tif (mhp_default_online_type >= 0)",
            "\t\treturn mhp_default_online_type;",
            "",
            "\tif (IS_ENABLED(CONFIG_MHP_DEFAULT_ONLINE_TYPE_OFFLINE))",
            "\t\tmhp_default_online_type = MMOP_OFFLINE;",
            "\telse if (IS_ENABLED(CONFIG_MHP_DEFAULT_ONLINE_TYPE_ONLINE_AUTO))",
            "\t\tmhp_default_online_type = MMOP_ONLINE;",
            "\telse if (IS_ENABLED(CONFIG_MHP_DEFAULT_ONLINE_TYPE_ONLINE_KERNEL))",
            "\t\tmhp_default_online_type = MMOP_ONLINE_KERNEL;",
            "\telse if (IS_ENABLED(CONFIG_MHP_DEFAULT_ONLINE_TYPE_ONLINE_MOVABLE))",
            "\t\tmhp_default_online_type = MMOP_ONLINE_MOVABLE;",
            "\telse",
            "\t\tmhp_default_online_type = MMOP_OFFLINE;",
            "",
            "\treturn mhp_default_online_type;",
            "}",
            "void mhp_set_default_online_type(int online_type)",
            "{",
            "\tmhp_default_online_type = online_type;",
            "}"
          ],
          "function_name": "memory_block_memmap_size, memory_block_memmap_on_memory_pages, set_memmap_mode, get_memmap_mode, mhp_memmap_on_memory, mhp_memmap_on_memory, set_online_policy, get_online_policy, get_online_mems, put_online_mems, mhp_get_default_online_type, mhp_set_default_online_type",
          "description": "提供内存映射模式配置接口(set/get)，实现memmap_on_memory策略判断逻辑，包含在线策略设置与获取函数及默认类型处理逻辑。",
          "similarity": 0.6018813848495483
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 1,
          "end_line": 51,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/mm/memory_hotplug.c",
            " *",
            " *  Copyright (C)",
            " */",
            "",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/cpu.h>",
            "#include <linux/memory.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/ioport.h>",
            "#include <linux/delay.h>",
            "#include <linux/migrate.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/pfn.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memblock.h>",
            "#include <linux/compaction.h>",
            "#include <linux/rmap.h>",
            "#include <linux/module.h>",
            "",
            "#include <asm/tlbflush.h>",
            "",
            "#include \"internal.h\"",
            "#include \"shuffle.h\"",
            "",
            "enum {",
            "\tMEMMAP_ON_MEMORY_DISABLE = 0,",
            "\tMEMMAP_ON_MEMORY_ENABLE,",
            "\tMEMMAP_ON_MEMORY_FORCE,",
            "};",
            "",
            "static int memmap_mode __read_mostly = MEMMAP_ON_MEMORY_DISABLE;",
            ""
          ],
          "function_name": null,
          "description": "声明内存热插拔相关枚举常量和全局变量，定义memmap_mode控制内存映射策略，包含必要的内核头文件和模块化实现依赖项。",
          "similarity": 0.5671135187149048
        },
        {
          "chunk_id": 6,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 855,
          "end_line": 970,
          "content": [
            "static bool auto_movable_can_online_movable(int nid, struct memory_group *group,",
            "\t\t\t\t\t    unsigned long nr_pages)",
            "{",
            "\tunsigned long kernel_early_pages, movable_pages;",
            "\tstruct auto_movable_group_stats group_stats = {};",
            "\tstruct auto_movable_stats stats = {};",
            "\tpg_data_t *pgdat = NODE_DATA(nid);",
            "\tstruct zone *zone;",
            "\tint i;",
            "",
            "\t/* Walk all relevant zones and collect MOVABLE vs. KERNEL stats. */",
            "\tif (nid == NUMA_NO_NODE) {",
            "\t\t/* TODO: cache values */",
            "\t\tfor_each_populated_zone(zone)",
            "\t\t\tauto_movable_stats_account_zone(&stats, zone);",
            "\t} else {",
            "\t\tfor (i = 0; i < MAX_NR_ZONES; i++) {",
            "\t\t\tzone = pgdat->node_zones + i;",
            "\t\t\tif (populated_zone(zone))",
            "\t\t\t\tauto_movable_stats_account_zone(&stats, zone);",
            "\t\t}",
            "\t}",
            "",
            "\tkernel_early_pages = stats.kernel_early_pages;",
            "\tmovable_pages = stats.movable_pages;",
            "",
            "\t/*",
            "\t * Kernel memory inside dynamic memory group allows for more MOVABLE",
            "\t * memory within the same group. Remove the effect of all but the",
            "\t * current group from the stats.",
            "\t */",
            "\twalk_dynamic_memory_groups(nid, auto_movable_stats_account_group,",
            "\t\t\t\t   group, &group_stats);",
            "\tif (kernel_early_pages <= group_stats.req_kernel_early_pages)",
            "\t\treturn false;",
            "\tkernel_early_pages -= group_stats.req_kernel_early_pages;",
            "\tmovable_pages -= group_stats.movable_pages;",
            "",
            "\tif (group && group->is_dynamic)",
            "\t\tkernel_early_pages += group->present_kernel_pages;",
            "",
            "\t/*",
            "\t * Test if we could online the given number of pages to ZONE_MOVABLE",
            "\t * and still stay in the configured ratio.",
            "\t */",
            "\tmovable_pages += nr_pages;",
            "\treturn movable_pages <= (auto_movable_ratio * kernel_early_pages) / 100;",
            "}",
            "void adjust_present_page_count(struct page *page, struct memory_group *group,",
            "\t\t\t       long nr_pages)",
            "{",
            "\tstruct zone *zone = page_zone(page);",
            "\tconst bool movable = zone_idx(zone) == ZONE_MOVABLE;",
            "",
            "\t/*",
            "\t * We only support onlining/offlining/adding/removing of complete",
            "\t * memory blocks; therefore, either all is either early or hotplugged.",
            "\t */",
            "\tif (early_section(__pfn_to_section(page_to_pfn(page))))",
            "\t\tzone->present_early_pages += nr_pages;",
            "\tzone->present_pages += nr_pages;",
            "\tzone->zone_pgdat->node_present_pages += nr_pages;",
            "",
            "\tif (group && movable)",
            "\t\tgroup->present_movable_pages += nr_pages;",
            "\telse if (group && !movable)",
            "\t\tgroup->present_kernel_pages += nr_pages;",
            "}",
            "int mhp_init_memmap_on_memory(unsigned long pfn, unsigned long nr_pages,",
            "\t\t\t      struct zone *zone)",
            "{",
            "\tunsigned long end_pfn = pfn + nr_pages;",
            "\tint ret, i;",
            "",
            "\tret = kasan_add_zero_shadow(__va(PFN_PHYS(pfn)), PFN_PHYS(nr_pages));",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tmove_pfn_range_to_zone(zone, pfn, nr_pages, NULL, MIGRATE_UNMOVABLE);",
            "",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tstruct page *page = pfn_to_page(pfn + i);",
            "",
            "\t\t__ClearPageOffline(page);",
            "\t\tSetPageVmemmapSelfHosted(page);",
            "\t}",
            "",
            "\t/*",
            "\t * It might be that the vmemmap_pages fully span sections. If that is",
            "\t * the case, mark those sections online here as otherwise they will be",
            "\t * left offline.",
            "\t */",
            "\tif (nr_pages >= PAGES_PER_SECTION)",
            "\t        online_mem_sections(pfn, ALIGN_DOWN(end_pfn, PAGES_PER_SECTION));",
            "",
            "\treturn ret;",
            "}",
            "void mhp_deinit_memmap_on_memory(unsigned long pfn, unsigned long nr_pages)",
            "{",
            "\tunsigned long end_pfn = pfn + nr_pages;",
            "",
            "\t/*",
            "\t * It might be that the vmemmap_pages fully span sections. If that is",
            "\t * the case, mark those sections offline here as otherwise they will be",
            "\t * left online.",
            "\t */",
            "\tif (nr_pages >= PAGES_PER_SECTION)",
            "\t\toffline_mem_sections(pfn, ALIGN_DOWN(end_pfn, PAGES_PER_SECTION));",
            "",
            "        /*",
            "\t * The pages associated with this vmemmap have been offlined, so",
            "\t * we can reset its state here.",
            "\t */",
            "\tremove_pfn_range_from_zone(page_zone(pfn_to_page(pfn)), pfn, nr_pages);",
            "\tkasan_remove_zero_shadow(__va(PFN_PHYS(pfn)), PFN_PHYS(nr_pages));",
            "}"
          ],
          "function_name": "auto_movable_can_online_movable, adjust_present_page_count, mhp_init_memmap_on_memory, mhp_deinit_memmap_on_memory",
          "description": "auto_movable_can_online_movable 判断是否可添加可移动页面；adjust_present_page_count 更新zone的present_pages等统计；mhp_init_memmap_on_memory 初始化内存映射并标记为在线；mhp_deinit_memmap_on_memory 清理内存映射并标记为离线",
          "similarity": 0.5547775030136108
        }
      ]
    },
    {
      "source_file": "mm/sparse-vmemmap.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:24:15\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sparse-vmemmap.c`\n\n---\n\n# sparse-vmemmap.c 技术文档\n\n## 1. 文件概述\n\n`sparse-vmemmap.c` 是 Linux 内核中用于实现 **虚拟内存映射（Virtual Memory Map, vmemmap）** 的核心文件之一。该机制为稀疏内存模型（sparse memory model）提供支持，使得 `pfn_to_page()`、`page_to_pfn()`、`virt_to_page()` 和 `page_address()` 等页管理原语可以通过简单的地址偏移计算实现，而无需访问内存中的间接结构。\n\n在支持 1:1 物理地址映射的架构上，vmemmap 利用已有的页表和 TLB 映射，仅需额外分配少量页面来构建一个连续的虚拟地址空间，用于存放所有物理页对应的 `struct page` 结构体。此文件主要负责在系统初始化阶段动态填充 vmemmap 所需的页表项，并支持使用替代内存分配器（如 ZONE_DEVICE 提供的 altmap）进行底层内存分配。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `vmemmap_alloc_block()` | 分配用于 vmemmap 或其页表的内存块，优先使用 slab 分配器，早期启动阶段回退到 memblock |\n| `vmemmap_alloc_block_buf()` | 封装分配接口，支持通过 `vmem_altmap` 指定替代内存源 |\n| `altmap_alloc_block_buf()` | 使用 `vmem_altmap` 提供的预留内存区域分配 vmemmap 缓冲区 |\n| `vmemmap_populate_address()` | 为指定虚拟地址填充完整的四级（或五级）页表路径（PGD → P4D → PUD → PMD → PTE） |\n| `vmemmap_populate_range()` | 批量填充一段虚拟地址范围的页表 |\n| `vmemmap_populate_basepages()` | 公开接口，用于以基本页（4KB）粒度填充 vmemmap 区域 |\n| `vmemmap_pte_populate()` / `vmemmap_pmd_populate()` / ... | 各级页表项的按需填充函数 |\n| `vmemmap_verify()` | 验证分配的 `struct page` 是否位于预期 NUMA 节点，避免跨节点性能问题 |\n\n### 关键数据结构\n\n- **`struct vmem_altmap`**  \n  由外部（如 device-dax 或 pmem 驱动）提供，描述一块预留的物理内存区域，可用于替代常规内存分配 vmemmap 所需的 `struct page` 存储空间。包含字段：\n  - `base_pfn`：起始物理页帧号\n  - `reserve`：保留页数（通常用于元数据）\n  - `alloc`：已分配页数\n  - `align`：对齐填充页数\n  - `free`：总可用页数\n\n## 3. 关键实现\n\n### 内存分配策略\n- **运行时分配**：当 slab 分配器可用时（`slab_is_available()` 返回 true），使用 `alloc_pages_node()` 分配高阶页面。\n- **早期启动分配**：在 slab 不可用时，调用 `memblock_alloc_try_nid_raw()` 从 bootmem 分配器获取内存。\n- **替代内存支持**：通过 `vmem_altmap` 参数，允许将 `struct page` 存储在设备内存（如持久内存）中，减少对系统 DRAM 的占用。\n\n### 页表填充机制\n- 采用 **按需填充（on-demand population）** 策略，仅在访问 vmemmap 虚拟地址时构建对应页表。\n- 支持完整的 x86_64 / ARM64 等架构的多级页表（PGD → P4D → PUD → PMD → PTE）。\n- 每级页表项若为空（`*_none()`），则分配一个 4KB 页面作为下一级页表，并通过 `*_populate()` 填充。\n- 叶子 PTE 指向实际存储 `struct page` 的物理页面，权限设为 `PAGE_KERNEL`。\n\n### 对齐与验证\n- `altmap_alloc_block_buf()` 中实现 **动态对齐**：根据请求大小计算所需对齐边界（2 的幂），确保分配地址满足页表项对齐要求。\n- `vmemmap_verify()` 在调试/警告模式下检查分配的 `struct page` 所在 NUMA 节点是否与目标节点“本地”，避免远程访问开销。\n\n### 架构钩子函数\n- 提供弱符号（`__weak`）钩子如 `kernel_pte_init()`、`pmd_init()` 等，允许特定架构在分配页表页面后执行初始化操作（如设置特殊属性位）。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：\n  - `<linux/mm.h>`、`<linux/mmzone.h>`：页帧、内存域、NUMA 节点管理\n  - `<linux/memblock.h>`：早期内存分配\n  - `<linux/vmalloc.h>`：虚拟内存管理（间接）\n- **页表操作**：\n  - `<asm/pgalloc.h>`：架构相关的页表分配/释放\n  - 依赖 `pgd_offset_k()`、`pud_populate()` 等架构宏/函数\n- **稀疏内存模型**：\n  - 与 `sparse.c` 协同工作，`sparse_buffer_alloc()` 用于复用预分配的缓冲区\n- **设备内存支持**：\n  - `<linux/memremap.h>`：`vmem_altmap` 定义，用于 ZONE_DEVICE 场景\n\n## 5. 使用场景\n\n1. **稀疏内存模型初始化**  \n   在 `sparse_init()` 过程中，为每个内存 section 调用 `vmemmap_populate_basepages()` 填充对应的 `struct page` 数组。\n\n2. **热插拔内存（Memory Hotplug）**  \n   新增内存区域时，动态填充其 vmemmap 映射，使新页可被内核页管理器识别。\n\n3. **持久内存（Persistent Memory）/ DAX 设备**  \n   通过 `vmem_altmap` 将 `struct page` 存储在设备自身内存中，避免消耗系统 RAM，典型用于 `fsdax` 或 `device-dax`。\n\n4. **大页优化（未完成功能）**  \n   文件末尾存在 `vmemmap_populate_hugepages()` 声明，表明未来可能支持使用透明大页（如 2MB PMD）映射 vmemmap，减少 TLB 压力（当前实现可能不完整或依赖架构支持）。\n\n5. **NUMA 感知分配**  \n   所有分配均指定目标 NUMA 节点（`node` 参数），确保 `struct page` 尽可能靠近其所描述的物理内存，优化访问延迟。",
      "similarity": 0.6049228310585022,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/sparse-vmemmap.c",
          "start_line": 1,
          "end_line": 90,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Virtual Memory Map support",
            " *",
            " * (C) 2007 sgi. Christoph Lameter.",
            " *",
            " * Virtual memory maps allow VM primitives pfn_to_page, page_to_pfn,",
            " * virt_to_page, page_address() to be implemented as a base offset",
            " * calculation without memory access.",
            " *",
            " * However, virtual mappings need a page table and TLBs. Many Linux",
            " * architectures already map their physical space using 1-1 mappings",
            " * via TLBs. For those arches the virtual memory map is essentially",
            " * for free if we use the same page size as the 1-1 mappings. In that",
            " * case the overhead consists of a few additional pages that are",
            " * allocated to create a view of memory for vmemmap.",
            " *",
            " * The architecture is expected to provide a vmemmap_populate() function",
            " * to instantiate the mapping.",
            " */",
            "#include <linux/mm.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/memblock.h>",
            "#include <linux/memremap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched.h>",
            "",
            "#include <asm/dma.h>",
            "#include <asm/pgalloc.h>",
            "",
            "/*",
            " * Allocate a block of memory to be used to back the virtual memory map",
            " * or to back the page tables that are used to create the mapping.",
            " * Uses the main allocators if they are available, else bootmem.",
            " */",
            "",
            "static void * __ref __earlyonly_bootmem_alloc(int node,",
            "\t\t\t\tunsigned long size,",
            "\t\t\t\tunsigned long align,",
            "\t\t\t\tunsigned long goal)",
            "{",
            "\treturn memblock_alloc_try_nid_raw(size, align, goal,",
            "\t\t\t\t\t       MEMBLOCK_ALLOC_ACCESSIBLE, node);",
            "}",
            "",
            "void * __meminit vmemmap_alloc_block(unsigned long size, int node)",
            "{",
            "\t/* If the main allocator is up use that, fallback to bootmem. */",
            "\tif (slab_is_available()) {",
            "\t\tgfp_t gfp_mask = GFP_KERNEL|__GFP_RETRY_MAYFAIL|__GFP_NOWARN;",
            "\t\tint order = get_order(size);",
            "\t\tstatic bool warned;",
            "\t\tstruct page *page;",
            "",
            "\t\tpage = alloc_pages_node(node, gfp_mask, order);",
            "\t\tif (page)",
            "\t\t\treturn page_address(page);",
            "",
            "\t\tif (!warned) {",
            "\t\t\twarn_alloc(gfp_mask & ~__GFP_NOWARN, NULL,",
            "\t\t\t\t   \"vmemmap alloc failure: order:%u\", order);",
            "\t\t\twarned = true;",
            "\t\t}",
            "\t\treturn NULL;",
            "\t} else",
            "\t\treturn __earlyonly_bootmem_alloc(node, size, size,",
            "\t\t\t\t__pa(MAX_DMA_ADDRESS));",
            "}",
            "",
            "static void * __meminit altmap_alloc_block_buf(unsigned long size,",
            "\t\t\t\t\t       struct vmem_altmap *altmap);",
            "",
            "/* need to make sure size is all the same during early stage */",
            "void * __meminit vmemmap_alloc_block_buf(unsigned long size, int node,",
            "\t\t\t\t\t struct vmem_altmap *altmap)",
            "{",
            "\tvoid *ptr;",
            "",
            "\tif (altmap)",
            "\t\treturn altmap_alloc_block_buf(size, altmap);",
            "",
            "\tptr = sparse_buffer_alloc(size);",
            "\tif (!ptr)",
            "\t\tptr = vmemmap_alloc_block(size, node);",
            "\treturn ptr;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了用于分配虚拟内存映射所需内存块的函数，包括对slab分配器和bootmem分配器的选择逻辑，用于在系统初始化期间为vmentry结构体分配物理存储",
          "similarity": 0.6070583462715149
        },
        {
          "chunk_id": 1,
          "file_path": "mm/sparse-vmemmap.c",
          "start_line": 91,
          "end_line": 203,
          "content": [
            "static unsigned long __meminit vmem_altmap_next_pfn(struct vmem_altmap *altmap)",
            "{",
            "\treturn altmap->base_pfn + altmap->reserve + altmap->alloc",
            "\t\t+ altmap->align;",
            "}",
            "static unsigned long __meminit vmem_altmap_nr_free(struct vmem_altmap *altmap)",
            "{",
            "\tunsigned long allocated = altmap->alloc + altmap->align;",
            "",
            "\tif (altmap->free > allocated)",
            "\t\treturn altmap->free - allocated;",
            "\treturn 0;",
            "}",
            "void __meminit vmemmap_verify(pte_t *pte, int node,",
            "\t\t\t\tunsigned long start, unsigned long end)",
            "{",
            "\tunsigned long pfn = pte_pfn(ptep_get(pte));",
            "\tint actual_node = early_pfn_to_nid(pfn);",
            "",
            "\tif (node_distance(actual_node, node) > LOCAL_DISTANCE)",
            "\t\tpr_warn_once(\"[%lx-%lx] potential offnode page_structs\\n\",",
            "\t\t\tstart, end - 1);",
            "}",
            "void __weak __meminit kernel_pte_init(void *addr)",
            "{",
            "}",
            "void __weak __meminit pmd_init(void *addr)",
            "{",
            "}",
            "void __weak __meminit pud_init(void *addr)",
            "{",
            "}",
            "static int __meminit vmemmap_populate_range(unsigned long start,",
            "\t\t\t\t\t    unsigned long end, int node,",
            "\t\t\t\t\t    struct vmem_altmap *altmap,",
            "\t\t\t\t\t    struct page *reuse)",
            "{",
            "\tunsigned long addr = start;",
            "\tpte_t *pte;",
            "",
            "\tfor (; addr < end; addr += PAGE_SIZE) {",
            "\t\tpte = vmemmap_populate_address(addr, node, altmap, reuse);",
            "\t\tif (!pte)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int __meminit vmemmap_populate_basepages(unsigned long start, unsigned long end,",
            "\t\t\t\t\t int node, struct vmem_altmap *altmap)",
            "{",
            "\treturn vmemmap_populate_range(start, end, node, altmap, NULL);",
            "}",
            "void __weak __meminit vmemmap_set_pmd(pmd_t *pmd, void *p, int node,",
            "\t\t\t\t      unsigned long addr, unsigned long next)",
            "{",
            "}",
            "int __weak __meminit vmemmap_check_pmd(pmd_t *pmd, int node,",
            "\t\t\t\t       unsigned long addr, unsigned long next)",
            "{",
            "\treturn 0;",
            "}",
            "int __meminit vmemmap_populate_hugepages(unsigned long start, unsigned long end,",
            "\t\t\t\t\t int node, struct vmem_altmap *altmap)",
            "{",
            "\tunsigned long addr;",
            "\tunsigned long next;",
            "\tpgd_t *pgd;",
            "\tp4d_t *p4d;",
            "\tpud_t *pud;",
            "\tpmd_t *pmd;",
            "",
            "\tfor (addr = start; addr < end; addr = next) {",
            "\t\tnext = pmd_addr_end(addr, end);",
            "",
            "\t\tpgd = vmemmap_pgd_populate(addr, node);",
            "\t\tif (!pgd)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\tp4d = vmemmap_p4d_populate(pgd, addr, node);",
            "\t\tif (!p4d)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\tpud = vmemmap_pud_populate(p4d, addr, node);",
            "\t\tif (!pud)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\tpmd = pmd_offset(pud, addr);",
            "\t\tif (pmd_none(READ_ONCE(*pmd))) {",
            "\t\t\tvoid *p;",
            "",
            "\t\t\tp = vmemmap_alloc_block_buf(PMD_SIZE, node, altmap);",
            "\t\t\tif (p) {",
            "\t\t\t\tvmemmap_set_pmd(pmd, p, node, addr, next);",
            "\t\t\t\tcontinue;",
            "\t\t\t} else if (altmap) {",
            "\t\t\t\t/*",
            "\t\t\t\t * No fallback: In any case we care about, the",
            "\t\t\t\t * altmap should be reasonably sized and aligned",
            "\t\t\t\t * such that vmemmap_alloc_block_buf() will always",
            "\t\t\t\t * succeed. For consistency with the PTE case,",
            "\t\t\t\t * return an error here as failure could indicate",
            "\t\t\t\t * a configuration issue with the size of the altmap.",
            "\t\t\t\t */",
            "\t\t\t\treturn -ENOMEM;",
            "\t\t\t}",
            "\t\t} else if (vmemmap_check_pmd(pmd, node, addr, next))",
            "\t\t\tcontinue;",
            "\t\tif (vmemmap_populate_basepages(addr, next, node, altmap))",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "vmem_altmap_next_pfn, vmem_altmap_nr_free, vmemmap_verify, kernel_pte_init, pmd_init, pud_init, vmemmap_populate_range, vmemmap_populate_basepages, vmemmap_set_pmd, vmemmap_check_pmd, vmemmap_populate_hugepages",
          "description": "实现了虚拟内存映射验证、页表初始化及大页填充逻辑，包含检查页表项节点一致性、弱函数声明以及递归填充连续地址范围的辅助函数",
          "similarity": 0.5765093564987183
        },
        {
          "chunk_id": 2,
          "file_path": "mm/sparse-vmemmap.c",
          "start_line": 377,
          "end_line": 435,
          "content": [
            "static bool __meminit reuse_compound_section(unsigned long start_pfn,",
            "\t\t\t\t\t     struct dev_pagemap *pgmap)",
            "{",
            "\tunsigned long nr_pages = pgmap_vmemmap_nr(pgmap);",
            "\tunsigned long offset = start_pfn -",
            "\t\tPHYS_PFN(pgmap->ranges[pgmap->nr_range].start);",
            "",
            "\treturn !IS_ALIGNED(offset, nr_pages) && nr_pages > PAGES_PER_SUBSECTION;",
            "}",
            "static int __meminit vmemmap_populate_compound_pages(unsigned long start_pfn,",
            "\t\t\t\t\t\t     unsigned long start,",
            "\t\t\t\t\t\t     unsigned long end, int node,",
            "\t\t\t\t\t\t     struct dev_pagemap *pgmap)",
            "{",
            "\tunsigned long size, addr;",
            "\tpte_t *pte;",
            "\tint rc;",
            "",
            "\tif (reuse_compound_section(start_pfn, pgmap)) {",
            "\t\tpte = compound_section_tail_page(start);",
            "\t\tif (!pte)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/*",
            "\t\t * Reuse the page that was populated in the prior iteration",
            "\t\t * with just tail struct pages.",
            "\t\t */",
            "\t\treturn vmemmap_populate_range(start, end, node, NULL,",
            "\t\t\t\t\t      pte_page(ptep_get(pte)));",
            "\t}",
            "",
            "\tsize = min(end - start, pgmap_vmemmap_nr(pgmap) * sizeof(struct page));",
            "\tfor (addr = start; addr < end; addr += size) {",
            "\t\tunsigned long next, last = addr + size;",
            "",
            "\t\t/* Populate the head page vmemmap page */",
            "\t\tpte = vmemmap_populate_address(addr, node, NULL, NULL);",
            "\t\tif (!pte)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/* Populate the tail pages vmemmap page */",
            "\t\tnext = addr + PAGE_SIZE;",
            "\t\tpte = vmemmap_populate_address(next, node, NULL, NULL);",
            "\t\tif (!pte)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/*",
            "\t\t * Reuse the previous page for the rest of tail pages",
            "\t\t * See layout diagram in Documentation/mm/vmemmap_dedup.rst",
            "\t\t */",
            "\t\tnext += PAGE_SIZE;",
            "\t\trc = vmemmap_populate_range(next, last, node, NULL,",
            "\t\t\t\t\t    pte_page(ptep_get(pte)));",
            "\t\tif (rc)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "reuse_compound_section, vmemmap_populate_compound_pages",
          "description": "提供复合页面内存复用机制，通过判断偏移对齐情况决定是否复用上一次迭代产生的尾部页面，从而优化vmentry结构体的内存分配效率",
          "similarity": 0.5652921795845032
        }
      ]
    },
    {
      "source_file": "mm/vmstat.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:34:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `vmstat.c`\n\n---\n\n# vmstat.c 技术文档\n\n## 1. 文件概述\n\n`vmstat.c` 是 Linux 内核内存管理子系统（MM）中的核心统计模块，负责维护和管理虚拟内存相关的各类计数器。该文件实现了以下三类主要统计信息：\n\n- **全局/区域级内存统计**（zone/node 级别）\n- **NUMA 架构下的内存访问统计**\n- **虚拟内存事件计数器**（如页面分配、回收、交换等）\n\n这些统计数据通过 `/proc/vmstat`、`/sys/kernel/debug/` 等接口暴露给用户空间，用于性能监控、调优和故障诊断。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `vm_zone_stat[NR_VM_ZONE_STAT_ITEMS]`：全局区域级内存统计计数器（如空闲页、活跃页等）\n- `vm_node_stat[NR_VM_NODE_STAT_ITEMS]`：NUMA 节点级内存统计计数器\n- `vm_numa_event[NR_VM_NUMA_EVENT_ITEMS]`：NUMA 相关事件计数器（如本地/远程页面分配）\n- `vm_event_states`（per-CPU）：每个 CPU 的虚拟内存事件状态\n- `per_cpu_zonestats` / `per_cpu_nodestats`：每个 CPU 对应的区域/节点统计结构\n\n### 主要函数\n- **NUMA 统计控制**：\n  - `sysctl_vm_numa_stat_handler()`：通过 sysctl 接口动态启用/禁用 NUMA 统计\n  - `invalid_numa_statistics()`：清除所有 NUMA 计数器\n  - `fold_vm_numa_events()`：将 per-CPU NUMA 事件聚合到全局计数器\n\n- **VM 事件管理**（需 CONFIG_VM_EVENT_COUNTERS）：\n  - `all_vm_events()`：汇总所有 CPU 的 VM 事件计数\n  - `vm_events_fold_cpu()`：将指定 CPU 的事件折叠到全局计数器\n\n- **阈值计算与刷新**（SMP 系统）：\n  - `calculate_normal_threshold()`：基于 CPU 数量和内存大小计算正常统计更新阈值\n  - `calculate_pressure_threshold()`：计算内存压力下的保守阈值\n  - `refresh_zone_stat_thresholds()`：为所有区域和节点刷新 per-CPU 统计阈值\n\n## 3. 关键实现\n\n### Per-CPU 统计与延迟更新机制\n为避免频繁原子操作带来的性能开销，内核采用 **per-CPU 缓存 + 延迟批量更新** 策略：\n- 每个 CPU 维护自己的统计副本（如 `per_cpu_zonestats`）\n- 当本地计数器超过预设阈值（`stat_threshold`）时，才将增量同步到全局原子变量\n- 阈值通过 `calculate_normal_threshold()` 动态调整，平衡精度与性能\n\n### NUMA 统计动态开关\n通过静态分支（`static_branch_enable/disable`）实现零开销切换：\n- 启用时：记录本地/远程页面分配等 NUMA 行为\n- 禁用时：立即清零所有相关计数器，避免无效统计\n\n### 内存水位线与漂移容忍\n在 `refresh_zone_stat_thresholds()` 中考虑了统计延迟导致的“漂移”问题：\n- 计算最大可能漂移量：`max_drift = num_online_cpus() * threshold`\n- 若漂移可能掩盖 min watermark 违规，则设置 `percpu_drift_mark` 作为更严格的警戒线\n\n### 高效聚合算法\n- 使用 `xchg()` 原子交换清零 per-CPU 计数器，避免读-改-写竞争\n- 全局聚合时加 `cpus_read_lock()` 防止 CPU 热插拔导致的数据不一致\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/mm.h>`：内存管理核心定义\n- `<linux/vmstat.h>`：VM 统计相关的宏和类型\n- `<linux/percpu.h>`（隐含）：Per-CPU 变量支持\n- `\"internal.h\"`：MM 子系统内部接口\n\n### 配置选项依赖\n- `CONFIG_NUMA`：启用 NUMA 统计相关代码\n- `CONFIG_VM_EVENT_COUNTERS`：启用详细的 VM 事件计数\n- `CONFIG_SMP`：多处理器阈值计算逻辑\n\n### 符号导出\n- `EXPORT_SYMBOL(vm_zone_stat)` / `vm_node_stat`：供其他模块（如 compaction、vmscan）读取统计\n- `EXPORT_SYMBOL_GPL(all_vm_events)`：供 tracing 或 debug 模块使用\n\n## 5. 使用场景\n\n### 内核内部使用\n- **内存回收**（kswapd）：根据 `NR_FREE_PAGES` 等统计决定回收时机\n- **页面分配器**：更新分配路径的统计（如 `alloc_pages` 调用 `count_vm_event`）\n- **内存压缩**（compaction）：监控迁移成功率等指标\n- **OOM Killer**：评估系统内存压力\n\n### 用户空间监控\n- **`/proc/vmstat`**：提供全局 VM 统计（由 `fs/proc/proc_misc.c` 调用 `all_vm_events` 生成）\n- **`/sys/kernel/debug/`**：debugfs 接口暴露详细 per-zone 统计\n- **性能分析工具**：如 `sar -r`, `vmstat`, `perf` 依赖这些计数器\n- **NUMA 调优**：通过 `numastat` 工具分析跨节点访问开销\n\n### 动态调优\n- 管理员可通过 `sysctl vm.numa_stat=0/1` 动态关闭 NUMA 统计以降低开销\n- 内核根据系统规模自动调整统计更新频率，适应从嵌入式设备到大型服务器的不同场景",
      "similarity": 0.6035853028297424,
      "chunks": [
        {
          "chunk_id": 11,
          "file_path": "mm/vmstat.c",
          "start_line": 1773,
          "end_line": 1875,
          "content": [
            "static int zoneinfo_show(struct seq_file *m, void *arg)",
            "{",
            "\tpg_data_t *pgdat = (pg_data_t *)arg;",
            "\twalk_zones_in_node(m, pgdat, false, false, zoneinfo_show_print);",
            "\treturn 0;",
            "}",
            "static int vmstat_show(struct seq_file *m, void *arg)",
            "{",
            "\tunsigned long *l = arg;",
            "\tunsigned long off = l - (unsigned long *)m->private;",
            "",
            "\tseq_puts(m, vmstat_text[off]);",
            "\tseq_put_decimal_ull(m, \" \", *l);",
            "\tseq_putc(m, '\\n');",
            "",
            "\tif (off == NR_VMSTAT_ITEMS - 1) {",
            "\t\t/*",
            "\t\t * We've come to the end - add any deprecated counters to avoid",
            "\t\t * breaking userspace which might depend on them being present.",
            "\t\t */",
            "\t\tseq_puts(m, \"nr_unstable 0\\n\");",
            "\t}",
            "\treturn 0;",
            "}",
            "static void vmstat_stop(struct seq_file *m, void *arg)",
            "{",
            "\tkfree(m->private);",
            "\tm->private = NULL;",
            "}",
            "static void refresh_vm_stats(struct work_struct *work)",
            "{",
            "\trefresh_cpu_vm_stats(true);",
            "}",
            "int vmstat_refresh(struct ctl_table *table, int write,",
            "\t\t   void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tlong val;",
            "\tint err;",
            "\tint i;",
            "",
            "\t/*",
            "\t * The regular update, every sysctl_stat_interval, may come later",
            "\t * than expected: leaving a significant amount in per_cpu buckets.",
            "\t * This is particularly misleading when checking a quantity of HUGE",
            "\t * pages, immediately after running a test.  /proc/sys/vm/stat_refresh,",
            "\t * which can equally be echo'ed to or cat'ted from (by root),",
            "\t * can be used to update the stats just before reading them.",
            "\t *",
            "\t * Oh, and since global_zone_page_state() etc. are so careful to hide",
            "\t * transiently negative values, report an error here if any of",
            "\t * the stats is negative, so we know to go looking for imbalance.",
            "\t */",
            "\terr = schedule_on_each_cpu(refresh_vm_stats);",
            "\tif (err)",
            "\t\treturn err;",
            "\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++) {",
            "\t\t/*",
            "\t\t * Skip checking stats known to go negative occasionally.",
            "\t\t */",
            "\t\tswitch (i) {",
            "\t\tcase NR_ZONE_WRITE_PENDING:",
            "\t\tcase NR_FREE_CMA_PAGES:",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tval = atomic_long_read(&vm_zone_stat[i]);",
            "\t\tif (val < 0) {",
            "\t\t\tpr_warn(\"%s: %s %ld\\n\",",
            "\t\t\t\t__func__, zone_stat_name(i), val);",
            "\t\t}",
            "\t}",
            "\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {",
            "\t\t/*",
            "\t\t * Skip checking stats known to go negative occasionally.",
            "\t\t */",
            "\t\tswitch (i) {",
            "\t\tcase NR_WRITEBACK:",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tval = atomic_long_read(&vm_node_stat[i]);",
            "\t\tif (val < 0) {",
            "\t\t\tpr_warn(\"%s: %s %ld\\n\",",
            "\t\t\t\t__func__, node_stat_name(i), val);",
            "\t\t}",
            "\t}",
            "\tif (write)",
            "\t\t*ppos += *lenp;",
            "\telse",
            "\t\t*lenp = 0;",
            "\treturn 0;",
            "}",
            "static void vmstat_update(struct work_struct *w)",
            "{",
            "\tif (refresh_cpu_vm_stats(true)) {",
            "\t\t/*",
            "\t\t * Counters were updated so we expect more updates",
            "\t\t * to occur in the future. Keep on running the",
            "\t\t * update worker thread.",
            "\t\t */",
            "\t\tqueue_delayed_work_on(smp_processor_id(), mm_percpu_wq,",
            "\t\t\t\tthis_cpu_ptr(&vmstat_work),",
            "\t\t\t\tround_jiffies_relative(sysctl_stat_interval));",
            "\t}",
            "}"
          ],
          "function_name": "zoneinfo_show, vmstat_show, vmstat_stop, refresh_vm_stats, vmstat_refresh, vmstat_update",
          "description": "提供虚拟内存统计项的显示与刷新功能，支持通过sysctl接口手动刷新统计数据，包含跨CPU的统计更新及异常值检查逻辑",
          "similarity": 0.6201196908950806
        },
        {
          "chunk_id": 12,
          "file_path": "mm/vmstat.c",
          "start_line": 1966,
          "end_line": 2071,
          "content": [
            "static bool need_update(int cpu)",
            "{",
            "\tpg_data_t *last_pgdat = NULL;",
            "\tstruct zone *zone;",
            "",
            "\tfor_each_populated_zone(zone) {",
            "\t\tstruct per_cpu_zonestat *pzstats = per_cpu_ptr(zone->per_cpu_zonestats, cpu);",
            "\t\tstruct per_cpu_nodestat *n;",
            "",
            "\t\t/*",
            "\t\t * The fast way of checking if there are any vmstat diffs.",
            "\t\t */",
            "\t\tif (memchr_inv(pzstats->vm_stat_diff, 0, sizeof(pzstats->vm_stat_diff)))",
            "\t\t\treturn true;",
            "",
            "\t\tif (last_pgdat == zone->zone_pgdat)",
            "\t\t\tcontinue;",
            "\t\tlast_pgdat = zone->zone_pgdat;",
            "\t\tn = per_cpu_ptr(zone->zone_pgdat->per_cpu_nodestats, cpu);",
            "\t\tif (memchr_inv(n->vm_node_stat_diff, 0, sizeof(n->vm_node_stat_diff)))",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "void quiet_vmstat(void)",
            "{",
            "\tif (system_state != SYSTEM_RUNNING)",
            "\t\treturn;",
            "",
            "\tif (!delayed_work_pending(this_cpu_ptr(&vmstat_work)))",
            "\t\treturn;",
            "",
            "\tif (!need_update(smp_processor_id()))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Just refresh counters and do not care about the pending delayed",
            "\t * vmstat_update. It doesn't fire that often to matter and canceling",
            "\t * it would be too expensive from this path.",
            "\t * vmstat_shepherd will take care about that for us.",
            "\t */",
            "\trefresh_cpu_vm_stats(false);",
            "}",
            "static void vmstat_shepherd(struct work_struct *w)",
            "{",
            "\tint cpu;",
            "",
            "\tcpus_read_lock();",
            "\t/* Check processors whose vmstat worker threads have been disabled */",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct delayed_work *dw = &per_cpu(vmstat_work, cpu);",
            "",
            "\t\t/*",
            "\t\t * In kernel users of vmstat counters either require the precise value and",
            "\t\t * they are using zone_page_state_snapshot interface or they can live with",
            "\t\t * an imprecision as the regular flushing can happen at arbitrary time and",
            "\t\t * cumulative error can grow (see calculate_normal_threshold).",
            "\t\t *",
            "\t\t * From that POV the regular flushing can be postponed for CPUs that have",
            "\t\t * been isolated from the kernel interference without critical",
            "\t\t * infrastructure ever noticing. Skip regular flushing from vmstat_shepherd",
            "\t\t * for all isolated CPUs to avoid interference with the isolated workload.",
            "\t\t */",
            "\t\tif (cpu_is_isolated(cpu))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (!delayed_work_pending(dw) && need_update(cpu))",
            "\t\t\tqueue_delayed_work_on(cpu, mm_percpu_wq, dw, 0);",
            "",
            "\t\tcond_resched();",
            "\t}",
            "\tcpus_read_unlock();",
            "",
            "\tschedule_delayed_work(&shepherd,",
            "\t\tround_jiffies_relative(sysctl_stat_interval));",
            "}",
            "static void __init start_shepherd_timer(void)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tINIT_DEFERRABLE_WORK(per_cpu_ptr(&vmstat_work, cpu),",
            "\t\t\tvmstat_update);",
            "",
            "\tschedule_delayed_work(&shepherd,",
            "\t\tround_jiffies_relative(sysctl_stat_interval));",
            "}",
            "static void __init init_cpu_node_state(void)",
            "{",
            "\tint node;",
            "",
            "\tfor_each_online_node(node) {",
            "\t\tif (!cpumask_empty(cpumask_of_node(node)))",
            "\t\t\tnode_set_state(node, N_CPU);",
            "\t}",
            "}",
            "static int vmstat_cpu_online(unsigned int cpu)",
            "{",
            "\trefresh_zone_stat_thresholds();",
            "",
            "\tif (!node_state(cpu_to_node(cpu), N_CPU)) {",
            "\t\tnode_set_state(cpu_to_node(cpu), N_CPU);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "need_update, quiet_vmstat, vmstat_shepherd, start_shepherd_timer, init_cpu_node_state, vmstat_cpu_online",
          "description": "管理vmstat统计更新的延迟工作队列，处理CPU热插拔事件的统计维护，包含CPU在线/离线状态下的统计阈值调整与工作队列调度",
          "similarity": 0.5997763872146606
        },
        {
          "chunk_id": 13,
          "file_path": "mm/vmstat.c",
          "start_line": 2093,
          "end_line": 2211,
          "content": [
            "static int vmstat_cpu_down_prep(unsigned int cpu)",
            "{",
            "\tcancel_delayed_work_sync(&per_cpu(vmstat_work, cpu));",
            "\treturn 0;",
            "}",
            "static int vmstat_cpu_dead(unsigned int cpu)",
            "{",
            "\tconst struct cpumask *node_cpus;",
            "\tint node;",
            "",
            "\tnode = cpu_to_node(cpu);",
            "",
            "\trefresh_zone_stat_thresholds();",
            "\tnode_cpus = cpumask_of_node(node);",
            "\tif (!cpumask_empty(node_cpus))",
            "\t\treturn 0;",
            "",
            "\tnode_clear_state(node, N_CPU);",
            "",
            "\treturn 0;",
            "}",
            "void __init init_mm_internals(void)",
            "{",
            "\tint ret __maybe_unused;",
            "",
            "\tmm_percpu_wq = alloc_workqueue(\"mm_percpu_wq\", WQ_MEM_RECLAIM, 0);",
            "",
            "#ifdef CONFIG_SMP",
            "\tret = cpuhp_setup_state_nocalls(CPUHP_MM_VMSTAT_DEAD, \"mm/vmstat:dead\",",
            "\t\t\t\t\tNULL, vmstat_cpu_dead);",
            "\tif (ret < 0)",
            "\t\tpr_err(\"vmstat: failed to register 'dead' hotplug state\\n\");",
            "",
            "\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, \"mm/vmstat:online\",",
            "\t\t\t\t\tvmstat_cpu_online,",
            "\t\t\t\t\tvmstat_cpu_down_prep);",
            "\tif (ret < 0)",
            "\t\tpr_err(\"vmstat: failed to register 'online' hotplug state\\n\");",
            "",
            "\tcpus_read_lock();",
            "\tinit_cpu_node_state();",
            "\tcpus_read_unlock();",
            "",
            "\tstart_shepherd_timer();",
            "#endif",
            "#ifdef CONFIG_PROC_FS",
            "\tproc_create_seq(\"buddyinfo\", 0444, NULL, &fragmentation_op);",
            "\tproc_create_seq(\"pagetypeinfo\", 0400, NULL, &pagetypeinfo_op);",
            "\tproc_create_seq(\"vmstat\", 0444, NULL, &vmstat_op);",
            "\tproc_create_seq(\"zoneinfo\", 0444, NULL, &zoneinfo_op);",
            "#endif",
            "}",
            "static int unusable_free_index(unsigned int order,",
            "\t\t\t\tstruct contig_page_info *info)",
            "{",
            "\t/* No free memory is interpreted as all free memory is unusable */",
            "\tif (info->free_pages == 0)",
            "\t\treturn 1000;",
            "",
            "\t/*",
            "\t * Index should be a value between 0 and 1. Return a value to 3",
            "\t * decimal places.",
            "\t *",
            "\t * 0 => no fragmentation",
            "\t * 1 => high fragmentation",
            "\t */",
            "\treturn div_u64((info->free_pages - (info->free_blocks_suitable << order)) * 1000ULL, info->free_pages);",
            "",
            "}",
            "static void unusable_show_print(struct seq_file *m,",
            "\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tunsigned int order;",
            "\tint index;",
            "\tstruct contig_page_info info;",
            "",
            "\tseq_printf(m, \"Node %d, zone %8s \",",
            "\t\t\t\tpgdat->node_id,",
            "\t\t\t\tzone->name);",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; ++order) {",
            "\t\tfill_contig_page_info(zone, order, &info);",
            "\t\tindex = unusable_free_index(order, &info);",
            "\t\tseq_printf(m, \"%d.%03d \", index / 1000, index % 1000);",
            "\t}",
            "",
            "\tseq_putc(m, '\\n');",
            "}",
            "static int unusable_show(struct seq_file *m, void *arg)",
            "{",
            "\tpg_data_t *pgdat = (pg_data_t *)arg;",
            "",
            "\t/* check memoryless node */",
            "\tif (!node_state(pgdat->node_id, N_MEMORY))",
            "\t\treturn 0;",
            "",
            "\twalk_zones_in_node(m, pgdat, true, false, unusable_show_print);",
            "",
            "\treturn 0;",
            "}",
            "static void extfrag_show_print(struct seq_file *m,",
            "\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tunsigned int order;",
            "\tint index;",
            "",
            "\t/* Alloc on stack as interrupts are disabled for zone walk */",
            "\tstruct contig_page_info info;",
            "",
            "\tseq_printf(m, \"Node %d, zone %8s \",",
            "\t\t\t\tpgdat->node_id,",
            "\t\t\t\tzone->name);",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; ++order) {",
            "\t\tfill_contig_page_info(zone, order, &info);",
            "\t\tindex = __fragmentation_index(order, &info);",
            "\t\tseq_printf(m, \"%2d.%03d \", index / 1000, index % 1000);",
            "\t}",
            "",
            "\tseq_putc(m, '\\n');",
            "}"
          ],
          "function_name": "vmstat_cpu_down_prep, vmstat_cpu_dead, init_mm_internals, unusable_free_index, unusable_show_print, unusable_show, extfrag_show_print",
          "description": "初始化内存管理内部结构体并注册proc文件系统接口，实现不可用内存碎片率计算及扩展碎片化指数的输出功能",
          "similarity": 0.5492457151412964
        },
        {
          "chunk_id": 9,
          "file_path": "mm/vmstat.c",
          "start_line": 1474,
          "end_line": 1578,
          "content": [
            "static void frag_show_print(struct seq_file *m, pg_data_t *pgdat,",
            "\t\t\t\t\t\tstruct zone *zone)",
            "{",
            "\tint order;",
            "",
            "\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; ++order)",
            "\t\t/*",
            "\t\t * Access to nr_free is lockless as nr_free is used only for",
            "\t\t * printing purposes. Use data_race to avoid KCSAN warning.",
            "\t\t */",
            "\t\tseq_printf(m, \"%6lu \", data_race(zone->free_area[order].nr_free));",
            "\tseq_putc(m, '\\n');",
            "}",
            "static int frag_show(struct seq_file *m, void *arg)",
            "{",
            "\tpg_data_t *pgdat = (pg_data_t *)arg;",
            "\twalk_zones_in_node(m, pgdat, true, false, frag_show_print);",
            "\treturn 0;",
            "}",
            "static void pagetypeinfo_showfree_print(struct seq_file *m,",
            "\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tint order, mtype;",
            "",
            "\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++) {",
            "\t\tseq_printf(m, \"Node %4d, zone %8s, type %12s \",",
            "\t\t\t\t\tpgdat->node_id,",
            "\t\t\t\t\tzone->name,",
            "\t\t\t\t\tmigratetype_names[mtype]);",
            "\t\tfor (order = 0; order < NR_PAGE_ORDERS; ++order) {",
            "\t\t\tunsigned long freecount = 0;",
            "\t\t\tstruct free_area *area;",
            "\t\t\tstruct list_head *curr;",
            "\t\t\tbool overflow = false;",
            "",
            "\t\t\tarea = &(zone->free_area[order]);",
            "",
            "\t\t\tlist_for_each(curr, &area->free_list[mtype]) {",
            "\t\t\t\t/*",
            "\t\t\t\t * Cap the free_list iteration because it might",
            "\t\t\t\t * be really large and we are under a spinlock",
            "\t\t\t\t * so a long time spent here could trigger a",
            "\t\t\t\t * hard lockup detector. Anyway this is a",
            "\t\t\t\t * debugging tool so knowing there is a handful",
            "\t\t\t\t * of pages of this order should be more than",
            "\t\t\t\t * sufficient.",
            "\t\t\t\t */",
            "\t\t\t\tif (++freecount >= 100000) {",
            "\t\t\t\t\toverflow = true;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tseq_printf(m, \"%s%6lu \", overflow ? \">\" : \"\", freecount);",
            "\t\t\tspin_unlock_irq(&zone->lock);",
            "\t\t\tcond_resched();",
            "\t\t\tspin_lock_irq(&zone->lock);",
            "\t\t}",
            "\t\tseq_putc(m, '\\n');",
            "\t}",
            "}",
            "static void pagetypeinfo_showfree(struct seq_file *m, void *arg)",
            "{",
            "\tint order;",
            "\tpg_data_t *pgdat = (pg_data_t *)arg;",
            "",
            "\t/* Print header */",
            "\tseq_printf(m, \"%-43s \", \"Free pages count per migrate type at order\");",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; ++order)",
            "\t\tseq_printf(m, \"%6d \", order);",
            "\tseq_putc(m, '\\n');",
            "",
            "\twalk_zones_in_node(m, pgdat, true, false, pagetypeinfo_showfree_print);",
            "}",
            "static void pagetypeinfo_showblockcount_print(struct seq_file *m,",
            "\t\t\t\t\tpg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tint mtype;",
            "\tunsigned long pfn;",
            "\tunsigned long start_pfn = zone->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(zone);",
            "\tunsigned long count[MIGRATE_TYPES] = { 0, };",
            "",
            "\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {",
            "\t\tstruct page *page;",
            "",
            "\t\tpage = pfn_to_online_page(pfn);",
            "\t\tif (!page)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (page_zone(page) != zone)",
            "\t\t\tcontinue;",
            "",
            "\t\tmtype = get_pageblock_migratetype(page);",
            "",
            "\t\tif (mtype < MIGRATE_TYPES)",
            "\t\t\tcount[mtype]++;",
            "\t}",
            "",
            "\t/* Print counts */",
            "\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);",
            "\tfor (mtype = 0; mtype < MIGRATE_TYPES; mtype++)",
            "\t\tseq_printf(m, \"%12lu \", count[mtype]);",
            "\tseq_putc(m, '\\n');",
            "}"
          ],
          "function_name": "frag_show_print, frag_show, pagetypeinfo_showfree_print, pagetypeinfo_showfree, pagetypeinfo_showblockcount_print",
          "description": "实现内存状态序列化展示接口，包括按订单级别显示空闲页统计、迁移类型分组空闲页追踪及物理块分配单元计数功能。",
          "similarity": 0.547171950340271
        },
        {
          "chunk_id": 1,
          "file_path": "mm/vmstat.c",
          "start_line": 38,
          "end_line": 142,
          "content": [
            "static void zero_zone_numa_counters(struct zone *zone)",
            "{",
            "\tint item, cpu;",
            "",
            "\tfor (item = 0; item < NR_VM_NUMA_EVENT_ITEMS; item++) {",
            "\t\tatomic_long_set(&zone->vm_numa_event[item], 0);",
            "\t\tfor_each_online_cpu(cpu) {",
            "\t\t\tper_cpu_ptr(zone->per_cpu_zonestats, cpu)->vm_numa_event[item]",
            "\t\t\t\t\t\t= 0;",
            "\t\t}",
            "\t}",
            "}",
            "static void zero_zones_numa_counters(void)",
            "{",
            "\tstruct zone *zone;",
            "",
            "\tfor_each_populated_zone(zone)",
            "\t\tzero_zone_numa_counters(zone);",
            "}",
            "static void zero_global_numa_counters(void)",
            "{",
            "\tint item;",
            "",
            "\tfor (item = 0; item < NR_VM_NUMA_EVENT_ITEMS; item++)",
            "\t\tatomic_long_set(&vm_numa_event[item], 0);",
            "}",
            "static void invalid_numa_statistics(void)",
            "{",
            "\tzero_zones_numa_counters();",
            "\tzero_global_numa_counters();",
            "}",
            "int sysctl_vm_numa_stat_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *length, loff_t *ppos)",
            "{",
            "\tint ret, oldval;",
            "",
            "\tmutex_lock(&vm_numa_stat_lock);",
            "\tif (write)",
            "\t\toldval = sysctl_vm_numa_stat;",
            "\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);",
            "\tif (ret || !write)",
            "\t\tgoto out;",
            "",
            "\tif (oldval == sysctl_vm_numa_stat)",
            "\t\tgoto out;",
            "\telse if (sysctl_vm_numa_stat == ENABLE_NUMA_STAT) {",
            "\t\tstatic_branch_enable(&vm_numa_stat_key);",
            "\t\tpr_info(\"enable numa statistics\\n\");",
            "\t} else {",
            "\t\tstatic_branch_disable(&vm_numa_stat_key);",
            "\t\tinvalid_numa_statistics();",
            "\t\tpr_info(\"disable numa statistics, and clear numa counters\\n\");",
            "\t}",
            "",
            "out:",
            "\tmutex_unlock(&vm_numa_stat_lock);",
            "\treturn ret;",
            "}",
            "static void sum_vm_events(unsigned long *ret)",
            "{",
            "\tint cpu;",
            "\tint i;",
            "",
            "\tmemset(ret, 0, NR_VM_EVENT_ITEMS * sizeof(unsigned long));",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct vm_event_state *this = &per_cpu(vm_event_states, cpu);",
            "",
            "\t\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++)",
            "\t\t\tret[i] += this->event[i];",
            "\t}",
            "}",
            "void all_vm_events(unsigned long *ret)",
            "{",
            "\tcpus_read_lock();",
            "\tsum_vm_events(ret);",
            "\tcpus_read_unlock();",
            "}",
            "void vm_events_fold_cpu(int cpu)",
            "{",
            "\tstruct vm_event_state *fold_state = &per_cpu(vm_event_states, cpu);",
            "\tint i;",
            "",
            "\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++) {",
            "\t\tcount_vm_events(i, fold_state->event[i]);",
            "\t\tfold_state->event[i] = 0;",
            "\t}",
            "}",
            "static void fold_vm_zone_numa_events(struct zone *zone)",
            "{",
            "\tunsigned long zone_numa_events[NR_VM_NUMA_EVENT_ITEMS] = { 0, };",
            "\tint cpu;",
            "\tenum numa_stat_item item;",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct per_cpu_zonestat *pzstats;",
            "",
            "\t\tpzstats = per_cpu_ptr(zone->per_cpu_zonestats, cpu);",
            "\t\tfor (item = 0; item < NR_VM_NUMA_EVENT_ITEMS; item++)",
            "\t\t\tzone_numa_events[item] += xchg(&pzstats->vm_numa_event[item], 0);",
            "\t}",
            "",
            "\tfor (item = 0; item < NR_VM_NUMA_EVENT_ITEMS; item++)",
            "\t\tzone_numa_event_add(zone_numa_events[item], zone, item);",
            "}"
          ],
          "function_name": "zero_zone_numa_counters, zero_zones_numa_counters, zero_global_numa_counters, invalid_numa_statistics, sysctl_vm_numa_stat_handler, sum_vm_events, all_vm_events, vm_events_fold_cpu, fold_vm_zone_numa_events",
          "description": "实现NUMA统计计数器的重置逻辑，包含zero_zone_numa_counters用于清空单个zone的统计计数器，sysctl_vm_numa_stat_handler用于动态开关NUMA统计功能，以及fold_vm_zone_numa_events用于汇总多CPU的NUMA事件统计",
          "similarity": 0.5425297617912292
        }
      ]
    }
  ]
}