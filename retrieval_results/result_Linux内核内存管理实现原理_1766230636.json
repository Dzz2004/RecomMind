{
  "query": "Linux内核内存管理实现原理",
  "timestamp": "2025-12-20 19:37:16",
  "retrieved_files": [
    {
      "source_file": "mm/show_mem.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:18:59\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `show_mem.c`\n\n---\n\n# show_mem.c 技术文档\n\n## 1. 文件概述\n\n`show_mem.c` 是 Linux 内核中用于提供内存状态信息查询和展示功能的核心实现文件。该文件实现了通用的 `show_mem()` 相关接口，用于在系统调试、内存压力分析或 OOM（Out-Of-Memory）诊断等场景下，输出当前系统的内存使用状况，包括各内存区域（zone）的空闲页数、活跃/非活跃匿名页与文件页、可回收内存、高内存统计等关键指标。此外，还提供了用户空间可通过 `/proc/meminfo` 等接口间接调用的内存信息获取函数。\n\n## 2. 核心功能\n\n### 全局变量\n- `atomic_long_t _totalram_pages`：系统总物理内存页数（以页为单位），标记为 `__read_mostly` 优化缓存局部性。\n- `unsigned long totalreserve_pages`：系统保留内存页数，用于保障关键内核操作。\n- `unsigned long totalcma_pages`：CMA（Contiguous Memory Allocator）区域总页数。\n\n### 主要函数\n- `si_mem_available(void)`：估算当前可用于用户空间分配而不触发交换或 OOM 的内存页数。\n- `si_meminfo(struct sysinfo *val)`：填充 `sysinfo` 结构体，提供全局内存统计信息（如总内存、空闲内存、共享内存等）。\n- `si_meminfo_node(struct sysinfo *val, int nid)`（仅当 `CONFIG_NUMA` 启用时）：为指定 NUMA 节点填充内存信息。\n- `show_free_areas(unsigned int filter, nodemask_t *nodemask, int max_zone_idx)`：打印详细的内存使用和空闲区域信息，支持按 NUMA 节点过滤。\n- `show_mem_node_skip(...)`：根据传入标志和 cpuset 策略判断是否跳过显示某 NUMA 节点。\n- `show_migration_types(...)`：将页面迁移类型位图转换为可读字符（如 'U' 表示不可移动，'M' 表示可移动等）。\n- `node_has_managed_zones(...)`：判断指定节点在给定最大 zone 索引范围内是否存在受管内存。\n\n## 3. 关键实现\n\n### 内存可用性估算 (`si_mem_available`)\n该函数通过以下步骤估算“安全可用”内存：\n1. **基础可用内存** = 全局空闲页数 - 系统保留页数。\n2. **可释放的 Page Cache**：取活跃/非活跃文件页之和，减去其一半与所有 zone 低水位线总和中的较小值（防止过度回收导致 thrashing）。\n3. **可回收内核内存**：包括可回收 slab 和其他可回收内核内存，同样减去其一半与低水位线的较小值。\n4. 最终结果不低于 0。\n\n此算法旨在提供一个保守但实用的“不会引发交换或 OOM”的可用内存估计值，被 `/proc/meminfo` 中的 `MemAvailable` 字段使用。\n\n### NUMA 感知的内存信息展示\n- 在 `CONFIG_NUMA` 配置下，`show_free_areas` 和 `si_meminfo_node` 按节点分别统计内存。\n- 通过 `show_mem_node_skip` 函数结合 `SHOW_MEM_FILTER_NODES` 标志和当前进程的 `cpuset_current_mems_allowed`，实现仅显示当前任务允许访问的 NUMA 节点内存信息，提升诊断相关性。\n\n### 内存统计项输出\n`show_free_areas` 输出两类信息：\n- **全局统计**：包括各类 LRU 链表页数、脏页、回写页、slab、页表、bounce buffer、free_pcp（每 CPU 页面缓存）、CMA 空闲页等。\n- **按节点统计**：每个在线且有受管内存的节点单独一行，包含 kB 单位的各项内存使用量，并标注节点是否“all_unreclaimable”。\n\n### 迁移类型可视化\n`show_migration_types` 将 buddy allocator 中的迁移类型位图（如 `MIGRATE_UNMOVABLE`, `MIGRATE_MOVABLE`, `MIGRATE_CMA` 等）映射为单字符标识，便于在调试输出中快速识别内存碎片特性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`, `<linux/mmzone.h>`：核心内存管理数据结构和宏定义。\n  - `<linux/vmstat.h>`：提供 `global_node_page_state()` 等全局内存计数器访问接口。\n  - `<linux/cma.h>`, `<linux/hugetlb.h>`：CMA 和大页支持。\n  - `<linux/cpuset.h>`：NUMA 节点过滤依赖 cpuset 的内存策略。\n  - `\"internal.h\"`, `\"swap.h\"`：内核 MM 子系统内部头文件。\n\n- **配置选项依赖**：\n  - `CONFIG_NUMA`：启用 NUMA 相关函数和节点过滤逻辑。\n  - `CONFIG_HIGHMEM`：高内存统计支持。\n  - `CONFIG_CMA` / `CONFIG_MEMORY_ISOLATION`：影响迁移类型字符映射。\n  - `CONFIG_TRANSPARENT_HUGEPAGE`：在节点统计中增加透明大页相关字段。\n\n- **导出符号**：\n  - `_totalram_pages`（GPL 例外）\n  - `si_mem_available()`（GPL）\n  - `si_meminfo()`（GPL）\n\n供其他内核模块（如 procfs、OOM killer、内存热插拔等）使用。\n\n## 5. 使用场景\n\n- **系统调试与监控**：通过 `/proc/meminfo`、`/proc/zoneinfo` 或内核日志（如 OOM 日志）查看详细内存分布。\n- **OOM Killer 触发时**：`show_free_areas()` 被调用以打印完整的内存状态快照，辅助分析内存耗尽原因。\n- **内存压力评估**：`si_mem_available()` 为用户空间提供可靠的可用内存估计，避免应用因错误判断空闲内存而崩溃。\n- **NUMA 系统调优**：在多节点系统中，按节点展示内存使用情况，帮助识别内存不平衡或局部耗尽问题。\n- **内核开发与测试**：开发者可通过手动触发内存信息打印（如通过 SysRq）验证内存分配、回收行为是否符合预期。",
      "similarity": 0.6757081747055054,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/show_mem.c",
          "start_line": 26,
          "end_line": 129,
          "content": [
            "static inline void show_node(struct zone *zone)",
            "{",
            "\tif (IS_ENABLED(CONFIG_NUMA))",
            "\t\tprintk(\"Node %d \", zone_to_nid(zone));",
            "}",
            "long si_mem_available(void)",
            "{",
            "\tlong available;",
            "\tunsigned long pagecache;",
            "\tunsigned long wmark_low = 0;",
            "\tunsigned long pages[NR_LRU_LISTS];",
            "\tunsigned long reclaimable;",
            "\tstruct zone *zone;",
            "\tint lru;",
            "",
            "\tfor (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)",
            "\t\tpages[lru] = global_node_page_state(NR_LRU_BASE + lru);",
            "",
            "\tfor_each_zone(zone)",
            "\t\twmark_low += low_wmark_pages(zone);",
            "",
            "\t/*",
            "\t * Estimate the amount of memory available for userspace allocations,",
            "\t * without causing swapping or OOM.",
            "\t */",
            "\tavailable = global_zone_page_state(NR_FREE_PAGES) - totalreserve_pages;",
            "",
            "\t/*",
            "\t * Not all the page cache can be freed, otherwise the system will",
            "\t * start swapping or thrashing. Assume at least half of the page",
            "\t * cache, or the low watermark worth of cache, needs to stay.",
            "\t */",
            "\tpagecache = pages[LRU_ACTIVE_FILE] + pages[LRU_INACTIVE_FILE];",
            "\tpagecache -= min(pagecache / 2, wmark_low);",
            "\tavailable += pagecache;",
            "",
            "\t/*",
            "\t * Part of the reclaimable slab and other kernel memory consists of",
            "\t * items that are in use, and cannot be freed. Cap this estimate at the",
            "\t * low watermark.",
            "\t */",
            "\treclaimable = global_node_page_state_pages(NR_SLAB_RECLAIMABLE_B) +",
            "\t\tglobal_node_page_state(NR_KERNEL_MISC_RECLAIMABLE);",
            "\tavailable += reclaimable - min(reclaimable / 2, wmark_low);",
            "",
            "\tif (available < 0)",
            "\t\tavailable = 0;",
            "\treturn available;",
            "}",
            "void si_meminfo(struct sysinfo *val)",
            "{",
            "\tval->totalram = totalram_pages();",
            "\tval->sharedram = global_node_page_state(NR_SHMEM);",
            "\tval->freeram = global_zone_page_state(NR_FREE_PAGES);",
            "\tval->bufferram = nr_blockdev_pages();",
            "\tval->totalhigh = totalhigh_pages();",
            "\tval->freehigh = nr_free_highpages();",
            "\tval->mem_unit = PAGE_SIZE;",
            "}",
            "void si_meminfo_node(struct sysinfo *val, int nid)",
            "{",
            "\tint zone_type;\t\t/* needs to be signed */",
            "\tunsigned long managed_pages = 0;",
            "\tunsigned long managed_highpages = 0;",
            "\tunsigned long free_highpages = 0;",
            "\tpg_data_t *pgdat = NODE_DATA(nid);",
            "",
            "\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)",
            "\t\tmanaged_pages += zone_managed_pages(&pgdat->node_zones[zone_type]);",
            "\tval->totalram = managed_pages;",
            "\tval->sharedram = node_page_state(pgdat, NR_SHMEM);",
            "\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);",
            "#ifdef CONFIG_HIGHMEM",
            "\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {",
            "\t\tstruct zone *zone = &pgdat->node_zones[zone_type];",
            "",
            "\t\tif (is_highmem(zone)) {",
            "\t\t\tmanaged_highpages += zone_managed_pages(zone);",
            "\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);",
            "\t\t}",
            "\t}",
            "\tval->totalhigh = managed_highpages;",
            "\tval->freehigh = free_highpages;",
            "#else",
            "\tval->totalhigh = managed_highpages;",
            "\tval->freehigh = free_highpages;",
            "#endif",
            "\tval->mem_unit = PAGE_SIZE;",
            "}",
            "static bool show_mem_node_skip(unsigned int flags, int nid, nodemask_t *nodemask)",
            "{",
            "\tif (!(flags & SHOW_MEM_FILTER_NODES))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * no node mask - aka implicit memory numa policy. Do not bother with",
            "\t * the synchronization - read_mems_allowed_begin - because we do not",
            "\t * have to be precise here.",
            "\t */",
            "\tif (!nodemask)",
            "\t\tnodemask = &cpuset_current_mems_allowed;",
            "",
            "\treturn !node_isset(nid, *nodemask);",
            "}"
          ],
          "function_name": "show_node, si_mem_available, si_meminfo, si_meminfo_node, show_mem_node_skip",
          "description": "实现内存统计相关函数，si_mem_available估算可用内存并考虑页面缓存与slab回收，si_meminfo填充sysinfo结构体展示内存总量，show_node打印NUMA节点信息。",
          "similarity": 0.5518925189971924
        },
        {
          "chunk_id": 3,
          "file_path": "mm/show_mem.c",
          "start_line": 403,
          "end_line": 455,
          "content": [
            "void __show_mem(unsigned int filter, nodemask_t *nodemask, int max_zone_idx)",
            "{",
            "\tunsigned long total = 0, reserved = 0, highmem = 0;",
            "\tstruct zone *zone;",
            "",
            "\tprintk(\"Mem-Info:\\n\");",
            "\tshow_free_areas(filter, nodemask, max_zone_idx);",
            "",
            "\tfor_each_populated_zone(zone) {",
            "",
            "\t\ttotal += zone->present_pages;",
            "\t\treserved += zone->present_pages - zone_managed_pages(zone);",
            "",
            "\t\tif (is_highmem(zone))",
            "\t\t\thighmem += zone->present_pages;",
            "\t}",
            "",
            "\tprintk(\"%lu pages RAM\\n\", total);",
            "\tprintk(\"%lu pages HighMem/MovableOnly\\n\", highmem);",
            "\tprintk(\"%lu pages reserved\\n\", reserved);",
            "#ifdef CONFIG_CMA",
            "\tprintk(\"%lu pages cma reserved\\n\", totalcma_pages);",
            "#endif",
            "#ifdef CONFIG_MEMORY_FAILURE",
            "\tprintk(\"%lu pages hwpoisoned\\n\", atomic_long_read(&num_poisoned_pages));",
            "#endif",
            "#ifdef CONFIG_MEM_ALLOC_PROFILING",
            "\t{",
            "\t\tstruct codetag_bytes tags[10];",
            "\t\tsize_t i, nr;",
            "",
            "\t\tnr = alloc_tag_top_users(tags, ARRAY_SIZE(tags), false);",
            "\t\tif (nr) {",
            "\t\t\tpr_notice(\"Memory allocations:\\n\");",
            "\t\t\tfor (i = 0; i < nr; i++) {",
            "\t\t\t\tstruct codetag *ct = tags[i].ct;",
            "\t\t\t\tstruct alloc_tag *tag = ct_to_alloc_tag(ct);",
            "\t\t\t\tstruct alloc_tag_counters counter = alloc_tag_read(tag);",
            "",
            "\t\t\t\t/* Same as alloc_tag_to_text() but w/o intermediate buffer */",
            "\t\t\t\tif (ct->modname)",
            "\t\t\t\t\tpr_notice(\"%12lli %8llu %s:%u [%s] func:%s\\n\",",
            "\t\t\t\t\t\t  counter.bytes, counter.calls, ct->filename,",
            "\t\t\t\t\t\t  ct->lineno, ct->modname, ct->function);",
            "\t\t\t\telse",
            "\t\t\t\t\tpr_notice(\"%12lli %8llu %s:%u func:%s\\n\",",
            "\t\t\t\t\t\t  counter.bytes, counter.calls, ct->filename,",
            "\t\t\t\t\t\t  ct->lineno, ct->function);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "__show_mem",
          "description": "汇总内存信息并输出，__show_mem调用show_free_areas后统计总RAM、HighMem及保留页数量，包含CMA和硬件损坏页的特殊信息输出。",
          "similarity": 0.5210139751434326
        },
        {
          "chunk_id": 2,
          "file_path": "mm/show_mem.c",
          "start_line": 144,
          "end_line": 444,
          "content": [
            "static void show_migration_types(unsigned char type)",
            "{",
            "\tstatic const char types[MIGRATE_TYPES] = {",
            "\t\t[MIGRATE_UNMOVABLE]\t= 'U',",
            "\t\t[MIGRATE_MOVABLE]\t= 'M',",
            "\t\t[MIGRATE_RECLAIMABLE]\t= 'E',",
            "\t\t[MIGRATE_HIGHATOMIC]\t= 'H',",
            "#ifdef CONFIG_CMA",
            "\t\t[MIGRATE_CMA]\t\t= 'C',",
            "#endif",
            "#ifdef CONFIG_MEMORY_ISOLATION",
            "\t\t[MIGRATE_ISOLATE]\t= 'I',",
            "#endif",
            "\t};",
            "\tchar tmp[MIGRATE_TYPES + 1];",
            "\tchar *p = tmp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < MIGRATE_TYPES; i++) {",
            "\t\tif (type & (1 << i))",
            "\t\t\t*p++ = types[i];",
            "\t}",
            "",
            "\t*p = '\\0';",
            "\tprintk(KERN_CONT \"(%s) \", tmp);",
            "}",
            "static bool node_has_managed_zones(pg_data_t *pgdat, int max_zone_idx)",
            "{",
            "\tint zone_idx;",
            "\tfor (zone_idx = 0; zone_idx <= max_zone_idx; zone_idx++)",
            "\t\tif (zone_managed_pages(pgdat->node_zones + zone_idx))",
            "\t\t\treturn true;",
            "\treturn false;",
            "}",
            "static void show_free_areas(unsigned int filter, nodemask_t *nodemask, int max_zone_idx)",
            "{",
            "\tunsigned long free_pcp = 0;",
            "\tint cpu, nid;",
            "\tstruct zone *zone;",
            "\tpg_data_t *pgdat;",
            "",
            "\tfor_each_populated_zone(zone) {",
            "\t\tif (zone_idx(zone) > max_zone_idx)",
            "\t\t\tcontinue;",
            "\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))",
            "\t\t\tcontinue;",
            "",
            "\t\tfor_each_online_cpu(cpu)",
            "\t\t\tfree_pcp += per_cpu_ptr(zone->per_cpu_pageset, cpu)->count;",
            "\t}",
            "",
            "\tprintk(\"active_anon:%lu inactive_anon:%lu isolated_anon:%lu\\n\"",
            "\t\t\" active_file:%lu inactive_file:%lu isolated_file:%lu\\n\"",
            "\t\t\" unevictable:%lu dirty:%lu writeback:%lu\\n\"",
            "\t\t\" slab_reclaimable:%lu slab_unreclaimable:%lu\\n\"",
            "\t\t\" mapped:%lu shmem:%lu pagetables:%lu\\n\"",
            "\t\t\" sec_pagetables:%lu bounce:%lu\\n\"",
            "\t\t\" kernel_misc_reclaimable:%lu\\n\"",
            "\t\t\" free:%lu free_pcp:%lu free_cma:%lu\\n\",",
            "\t\tglobal_node_page_state(NR_ACTIVE_ANON),",
            "\t\tglobal_node_page_state(NR_INACTIVE_ANON),",
            "\t\tglobal_node_page_state(NR_ISOLATED_ANON),",
            "\t\tglobal_node_page_state(NR_ACTIVE_FILE),",
            "\t\tglobal_node_page_state(NR_INACTIVE_FILE),",
            "\t\tglobal_node_page_state(NR_ISOLATED_FILE),",
            "\t\tglobal_node_page_state(NR_UNEVICTABLE),",
            "\t\tglobal_node_page_state(NR_FILE_DIRTY),",
            "\t\tglobal_node_page_state(NR_WRITEBACK),",
            "\t\tglobal_node_page_state_pages(NR_SLAB_RECLAIMABLE_B),",
            "\t\tglobal_node_page_state_pages(NR_SLAB_UNRECLAIMABLE_B),",
            "\t\tglobal_node_page_state(NR_FILE_MAPPED),",
            "\t\tglobal_node_page_state(NR_SHMEM),",
            "\t\tglobal_node_page_state(NR_PAGETABLE),",
            "\t\tglobal_node_page_state(NR_SECONDARY_PAGETABLE),",
            "\t\tglobal_zone_page_state(NR_BOUNCE),",
            "\t\tglobal_node_page_state(NR_KERNEL_MISC_RECLAIMABLE),",
            "\t\tglobal_zone_page_state(NR_FREE_PAGES),",
            "\t\tfree_pcp,",
            "\t\tglobal_zone_page_state(NR_FREE_CMA_PAGES));",
            "",
            "\tfor_each_online_pgdat(pgdat) {",
            "\t\tif (show_mem_node_skip(filter, pgdat->node_id, nodemask))",
            "\t\t\tcontinue;",
            "\t\tif (!node_has_managed_zones(pgdat, max_zone_idx))",
            "\t\t\tcontinue;",
            "",
            "\t\tprintk(\"Node %d\"",
            "\t\t\t\" active_anon:%lukB\"",
            "\t\t\t\" inactive_anon:%lukB\"",
            "\t\t\t\" active_file:%lukB\"",
            "\t\t\t\" inactive_file:%lukB\"",
            "\t\t\t\" unevictable:%lukB\"",
            "\t\t\t\" isolated(anon):%lukB\"",
            "\t\t\t\" isolated(file):%lukB\"",
            "\t\t\t\" mapped:%lukB\"",
            "\t\t\t\" dirty:%lukB\"",
            "\t\t\t\" writeback:%lukB\"",
            "\t\t\t\" shmem:%lukB\"",
            "#ifdef CONFIG_TRANSPARENT_HUGEPAGE",
            "\t\t\t\" shmem_thp:%lukB\"",
            "\t\t\t\" shmem_pmdmapped:%lukB\"",
            "\t\t\t\" anon_thp:%lukB\"",
            "#endif",
            "\t\t\t\" writeback_tmp:%lukB\"",
            "\t\t\t\" kernel_stack:%lukB\"",
            "#ifdef CONFIG_SHADOW_CALL_STACK",
            "\t\t\t\" shadow_call_stack:%lukB\"",
            "#endif",
            "\t\t\t\" pagetables:%lukB\"",
            "\t\t\t\" sec_pagetables:%lukB\"",
            "\t\t\t\" all_unreclaimable? %s\"",
            "\t\t\t\"\\n\",",
            "\t\t\tpgdat->node_id,",
            "\t\t\tK(node_page_state(pgdat, NR_ACTIVE_ANON)),",
            "\t\t\tK(node_page_state(pgdat, NR_INACTIVE_ANON)),",
            "\t\t\tK(node_page_state(pgdat, NR_ACTIVE_FILE)),",
            "\t\t\tK(node_page_state(pgdat, NR_INACTIVE_FILE)),",
            "\t\t\tK(node_page_state(pgdat, NR_UNEVICTABLE)),",
            "\t\t\tK(node_page_state(pgdat, NR_ISOLATED_ANON)),",
            "\t\t\tK(node_page_state(pgdat, NR_ISOLATED_FILE)),",
            "\t\t\tK(node_page_state(pgdat, NR_FILE_MAPPED)),",
            "\t\t\tK(node_page_state(pgdat, NR_FILE_DIRTY)),",
            "\t\t\tK(node_page_state(pgdat, NR_WRITEBACK)),",
            "\t\t\tK(node_page_state(pgdat, NR_SHMEM)),",
            "#ifdef CONFIG_TRANSPARENT_HUGEPAGE",
            "\t\t\tK(node_page_state(pgdat, NR_SHMEM_THPS)),",
            "\t\t\tK(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)),",
            "\t\t\tK(node_page_state(pgdat, NR_ANON_THPS)),",
            "#endif",
            "\t\t\tK(node_page_state(pgdat, NR_WRITEBACK_TEMP)),",
            "\t\t\tnode_page_state(pgdat, NR_KERNEL_STACK_KB),",
            "#ifdef CONFIG_SHADOW_CALL_STACK",
            "\t\t\tnode_page_state(pgdat, NR_KERNEL_SCS_KB),",
            "#endif",
            "\t\t\tK(node_page_state(pgdat, NR_PAGETABLE)),",
            "\t\t\tK(node_page_state(pgdat, NR_SECONDARY_PAGETABLE)),",
            "\t\t\tpgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ?",
            "\t\t\t\t\"yes\" : \"no\");",
            "\t}",
            "",
            "\tfor_each_populated_zone(zone) {",
            "\t\tint i;",
            "",
            "\t\tif (zone_idx(zone) > max_zone_idx)",
            "\t\t\tcontinue;",
            "\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))",
            "\t\t\tcontinue;",
            "",
            "\t\tfree_pcp = 0;",
            "\t\tfor_each_online_cpu(cpu)",
            "\t\t\tfree_pcp += per_cpu_ptr(zone->per_cpu_pageset, cpu)->count;",
            "",
            "\t\tshow_node(zone);",
            "\t\tprintk(KERN_CONT",
            "\t\t\t\"%s\"",
            "\t\t\t\" free:%lukB\"",
            "\t\t\t\" boost:%lukB\"",
            "\t\t\t\" min:%lukB\"",
            "\t\t\t\" low:%lukB\"",
            "\t\t\t\" high:%lukB\"",
            "\t\t\t\" reserved_highatomic:%luKB\"",
            "\t\t\t\" active_anon:%lukB\"",
            "\t\t\t\" inactive_anon:%lukB\"",
            "\t\t\t\" active_file:%lukB\"",
            "\t\t\t\" inactive_file:%lukB\"",
            "\t\t\t\" unevictable:%lukB\"",
            "\t\t\t\" writepending:%lukB\"",
            "\t\t\t\" present:%lukB\"",
            "\t\t\t\" managed:%lukB\"",
            "\t\t\t\" mlocked:%lukB\"",
            "\t\t\t\" bounce:%lukB\"",
            "\t\t\t\" free_pcp:%lukB\"",
            "\t\t\t\" local_pcp:%ukB\"",
            "\t\t\t\" free_cma:%lukB\"",
            "\t\t\t\"\\n\",",
            "\t\t\tzone->name,",
            "\t\t\tK(zone_page_state(zone, NR_FREE_PAGES)),",
            "\t\t\tK(zone->watermark_boost),",
            "\t\t\tK(min_wmark_pages(zone)),",
            "\t\t\tK(low_wmark_pages(zone)),",
            "\t\t\tK(high_wmark_pages(zone)),",
            "\t\t\tK(zone->nr_reserved_highatomic),",
            "\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),",
            "\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),",
            "\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),",
            "\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),",
            "\t\t\tK(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),",
            "\t\t\tK(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),",
            "\t\t\tK(zone->present_pages),",
            "\t\t\tK(zone_managed_pages(zone)),",
            "\t\t\tK(zone_page_state(zone, NR_MLOCK)),",
            "\t\t\tK(zone_page_state(zone, NR_BOUNCE)),",
            "\t\t\tK(free_pcp),",
            "\t\t\tK(this_cpu_read(zone->per_cpu_pageset->count)),",
            "\t\t\tK(zone_page_state(zone, NR_FREE_CMA_PAGES)));",
            "\t\tprintk(\"lowmem_reserve[]:\");",
            "\t\tfor (i = 0; i < MAX_NR_ZONES; i++)",
            "\t\t\tprintk(KERN_CONT \" %ld\", zone->lowmem_reserve[i]);",
            "\t\tprintk(KERN_CONT \"\\n\");",
            "\t}",
            "",
            "\tfor_each_populated_zone(zone) {",
            "\t\tunsigned int order;",
            "\t\tunsigned long nr[NR_PAGE_ORDERS], flags, total = 0;",
            "\t\tunsigned char types[NR_PAGE_ORDERS];",
            "",
            "\t\tif (zone_idx(zone) > max_zone_idx)",
            "\t\t\tcontinue;",
            "\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))",
            "\t\t\tcontinue;",
            "\t\tshow_node(zone);",
            "\t\tprintk(KERN_CONT \"%s: \", zone->name);",
            "",
            "\t\tspin_lock_irqsave(&zone->lock, flags);",
            "\t\tfor (order = 0; order < NR_PAGE_ORDERS; order++) {",
            "\t\t\tstruct free_area *area = &zone->free_area[order];",
            "\t\t\tint type;",
            "",
            "\t\t\tnr[order] = area->nr_free;",
            "\t\t\ttotal += nr[order] << order;",
            "",
            "\t\t\ttypes[order] = 0;",
            "\t\t\tfor (type = 0; type < MIGRATE_TYPES; type++) {",
            "\t\t\t\tif (!free_area_empty(area, type))",
            "\t\t\t\t\ttypes[order] |= 1 << type;",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock_irqrestore(&zone->lock, flags);",
            "\t\tfor (order = 0; order < NR_PAGE_ORDERS; order++) {",
            "\t\t\tprintk(KERN_CONT \"%lu*%lukB \",",
            "\t\t\t       nr[order], K(1UL) << order);",
            "\t\t\tif (nr[order])",
            "\t\t\t\tshow_migration_types(types[order]);",
            "\t\t}",
            "\t\tprintk(KERN_CONT \"= %lukB\\n\", K(total));",
            "\t}",
            "",
            "\tfor_each_online_node(nid) {",
            "\t\tif (show_mem_node_skip(filter, nid, nodemask))",
            "\t\t\tcontinue;",
            "\t\thugetlb_show_meminfo_node(nid);",
            "\t}",
            "",
            "\tprintk(\"%ld total pagecache pages\\n\", global_node_page_state(NR_FILE_PAGES));",
            "",
            "\tshow_swap_cache_info();",
            "}",
            "",
            "void __show_mem(unsigned int filter, nodemask_t *nodemask, int max_zone_idx)",
            "{",
            "\tunsigned long total = 0, reserved = 0, highmem = 0;",
            "\tstruct zone *zone;",
            "",
            "\tprintk(\"Mem-Info:\\n\");",
            "\tshow_free_areas(filter, nodemask, max_zone_idx);",
            "",
            "\tfor_each_populated_zone(zone) {",
            "",
            "\t\ttotal += zone->present_pages;",
            "\t\treserved += zone->present_pages - zone_managed_pages(zone);",
            "",
            "\t\tif (is_highmem(zone))",
            "\t\t\thighmem += zone->present_pages;",
            "\t}",
            "",
            "\tprintk(\"%lu pages RAM\\n\", total);",
            "\tprintk(\"%lu pages HighMem/MovableOnly\\n\", highmem);",
            "\tprintk(\"%lu pages reserved\\n\", reserved);",
            "#ifdef CONFIG_CMA",
            "\tprintk(\"%lu pages cma reserved\\n\", totalcma_pages);",
            "#endif",
            "#ifdef CONFIG_MEMORY_FAILURE",
            "\tprintk(\"%lu pages hwpoisoned\\n\", atomic_long_read(&num_poisoned_pages));",
            "#endif",
            "#ifdef CONFIG_MEM_ALLOC_PROFILING",
            "\t{",
            "\t\tstruct codetag_bytes tags[10];",
            "\t\tsize_t i, nr;",
            "",
            "\t\tnr = alloc_tag_top_users(tags, ARRAY_SIZE(tags), false);",
            "\t\tif (nr) {",
            "\t\t\tpr_notice(\"Memory allocations:\\n\");",
            "\t\t\tfor (i = 0; i < nr; i++) {",
            "\t\t\t\tstruct codetag *ct = tags[i].ct;",
            "\t\t\t\tstruct alloc_tag *tag = ct_to_alloc_tag(ct);",
            "\t\t\t\tstruct alloc_tag_counters counter = alloc_tag_read(tag);",
            "",
            "\t\t\t\t/* Same as alloc_tag_to_text() but w/o intermediate buffer */",
            "\t\t\t\tif (ct->modname)",
            "\t\t\t\t\tpr_notice(\"%12lli %8llu %s:%u [%s] func:%s\\n\",",
            "\t\t\t\t\t\t  counter.bytes, counter.calls, ct->filename,",
            "\t\t\t\t\t\t  ct->lineno, ct->modname, ct->function);",
            "\t\t\t\telse",
            "\t\t\t\t\tpr_notice(\"%12lli %8llu %s:%u func:%s\\n\",",
            "\t\t\t\t\t\t  counter.bytes, counter.calls, ct->filename,",
            "\t\t\t\t\t\t  ct->lineno, ct->function);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "show_migration_types, node_has_managed_zones, show_free_areas",
          "description": "展示内存区域详细信息，show_free_areas输出各zone的页面状态统计，node_has_managed_zones检测节点管理分区，show_migration_types将迁移类型编码为字符显示。",
          "similarity": 0.5023683905601501
        },
        {
          "chunk_id": 0,
          "file_path": "mm/show_mem.c",
          "start_line": 1,
          "end_line": 25,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Generic show_mem() implementation",
            " *",
            " * Copyright (C) 2008 Johannes Weiner <hannes@saeurebad.de>",
            " */",
            "",
            "#include <linux/blkdev.h>",
            "#include <linux/cma.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmstat.h>",
            "",
            "#include \"internal.h\"",
            "#include \"swap.h\"",
            "",
            "atomic_long_t _totalram_pages __read_mostly;",
            "EXPORT_SYMBOL(_totalram_pages);",
            "unsigned long totalreserve_pages __read_mostly;",
            "unsigned long totalcma_pages __read_mostly;",
            ""
          ],
          "function_name": null,
          "description": "声明全局变量用于跟踪系统内存统计信息，包括_totalram_pages记录总RAM页数，totalreserve_pages表示保留页数，totalcma_pages记录CMA区域大小。",
          "similarity": 0.46266674995422363
        }
      ]
    },
    {
      "source_file": "mm/memblock.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memblock.c`\n\n---\n\n# memblock.c 技术文档\n\n## 1. 文件概述\n\n`memblock.c` 实现了 Linux 内核早期启动阶段的内存管理机制——**memblock**。该机制用于在常规内存分配器（如 buddy allocator）尚未初始化之前，对物理内存进行粗粒度的区域管理。它将系统内存抽象为若干连续的内存区域（regions），支持“可用内存”（memory）、“保留内存”（reserved）和“物理内存”（physmem，部分架构支持）三种类型，为内核早期初始化提供内存添加、查询和分配能力。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct memblock_region`：表示一个连续的物理内存区域，包含基地址（base）、大小（size）、NUMA 节点 ID 和属性标志。\n- `struct memblock_type`：管理一类内存区域的集合，包含区域数组、当前数量（cnt）、最大容量（max）和名称。\n- `struct memblock`：全局 memblock 管理结构，包含 `memory` 和 `reserved` 两种类型的 `memblock_type`，以及分配方向（bottom_up）和当前分配上限（current_limit）。\n- `physmem`（条件编译）：描述不受 `mem=` 参数限制的实际物理内存布局。\n\n### 主要函数与变量\n- `memblock_add()` / `memblock_add_node()`：向 memblock 添加可用内存区域。\n- `memblock_reserve()`：标记内存区域为保留（不可用于动态分配）。\n- `memblock_phys_alloc*()` / `memblock_alloc*()`：分配物理或虚拟地址的内存。\n- `memblock_overlaps_region()`：判断指定区域是否与某类 memblock 区域重叠。\n- `__memblock_find_range_bottom_up()`：从低地址向高地址查找满足条件的空闲内存范围。\n- 全局变量 `memblock`：静态初始化的主 memblock 结构体。\n- `max_low_pfn`, `min_low_pfn`, `max_pfn`, `max_possible_pfn`：记录 PFN（页帧号）边界信息。\n\n### 配置宏\n- `INIT_MEMBLOCK_REGIONS`：初始内存/保留区域数组大小（默认 128）。\n- `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 类型支持。\n- `CONFIG_MEMBLOCK_KHO_SCRATCH`：支持仅从特定标记（KHO_SCRATCH）区域分配内存。\n- `CONFIG_ARCH_KEEP_MEMBLOCK`：决定是否在初始化完成后保留 memblock 数据结构。\n\n## 3. 关键实现\n\n### 初始化与存储\n- `memblock` 结构体在编译时静态初始化，其 `memory` 和 `reserved` 的区域数组分别使用 `memblock_memory_init_regions` 和 `memblock_reserved_init_regions`，初始容量由 `INIT_MEMBLOCK_*_REGIONS` 定义。\n- 每个 `memblock_type` 的 `cnt` 初始设为 1，但实际第一个条目为空的占位符，有效区域从索引 1 开始（后续代码处理）。\n- 支持通过 `memblock_allow_resize()` 动态扩容区域数组，但需谨慎避免与 initrd 等关键区域冲突。\n\n### 内存区域管理\n- 使用 `for_each_memblock_type` 宏遍历指定类型的区域。\n- `memblock_addrs_overlap()` 通过比较区间端点判断两个物理内存区域是否重叠。\n- `memblock_overlaps_region()` 封装了对某类所有区域的重叠检测。\n\n### 分配策略\n- 默认采用 **top-down**（从高地址向低地址）分配策略，可通过 `memblock_set_bottom_up(true)` 切换为 **bottom-up**。\n- 分配时受 `current_limit` 限制（默认 `MEMBLOCK_ALLOC_ANYWHERE` 表示无限制）。\n- 支持基于 NUMA 节点、对齐要求、内存属性（如 `MEMBLOCK_MIRROR`、`MEMBLOCK_KHO_SCRATCH`）的精细控制。\n- `choose_memblock_flags()` 根据 `kho_scratch_only` 和镜像内存存在性动态选择分配标志。\n\n### 安全与调试\n- `memblock_cap_size()` 防止地址计算溢出（确保 `base + size <= PHYS_ADDR_MAX`）。\n- 条件编译的 `memblock_dbg()` 宏用于调试输出（需开启 `memblock_debug`）。\n- 使用 `__initdata_memblock` 属性标记仅在初始化阶段使用的数据，便于后续释放。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memblock.h>`：定义 memblock API 和数据结构。\n  - `<linux/kernel.h>`, `<linux/init.h>`：提供基础内核功能和初始化宏。\n  - `<linux/pfn.h>`：PFN 相关操作。\n  - `<asm/sections.h>`：访问内核链接段信息。\n  - 架构相关头文件（如 `internal.h`）。\n- **配置依赖**：\n  - `CONFIG_NUMA`：影响 `contig_page_data` 的定义。\n  - `CONFIG_KEXEC_HANDOVER`：引入 kexec 相关头文件。\n  - `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 支持。\n- **后续移交**：在 `mem_init()` 中，memblock 管理的内存会被释放给 buddy allocator，完成内存管理权移交。\n\n## 5. 使用场景\n\n- **内核早期初始化**：在 `start_kernel()` 初期，架构代码（如 `setup_arch()`）调用 `memblock_add()` 注册可用物理内存，调用 `memblock_reserve()` 保留内核镜像、设备树、initrd 等关键区域。\n- **早期内存分配**：在 slab/buddy 分配器就绪前，使用 `memblock_alloc()` 分配大块连续内存（如页表、中断向量表、ACPI 表解析缓冲区）。\n- **内存布局查询**：通过 `for_each_memblock()` 等宏遍历内存区域，用于构建 e820 表、EFI 内存映射或 NUMA 拓扑。\n- **特殊分配需求**：支持从镜像内存（`MEMBLOCK_MIRROR`）或 KHO scratch 区域分配，满足安全启动或崩溃转储等场景。\n- **调试与分析**：通过 debugfs 接口（未在片段中体现）导出 memblock 布局，辅助内存问题诊断。",
      "similarity": 0.6696176528930664,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "mm/memblock.c",
          "start_line": 1954,
          "end_line": 2057,
          "content": [
            "void __init memblock_mem_limit_remove_map(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\tmemblock_cap_memory_range(0, max_addr);",
            "}",
            "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)",
            "{",
            "\tunsigned int left = 0, right = type->cnt;",
            "",
            "\tdo {",
            "\t\tunsigned int mid = (right + left) / 2;",
            "",
            "\t\tif (addr < type->regions[mid].base)",
            "\t\t\tright = mid;",
            "\t\telse if (addr >= (type->regions[mid].base +",
            "\t\t\t\t  type->regions[mid].size))",
            "\t\t\tleft = mid + 1;",
            "\t\telse",
            "\t\t\treturn mid;",
            "\t} while (left < right);",
            "\treturn -1;",
            "}",
            "bool __init_memblock memblock_is_reserved(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.reserved, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_memory(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.memory, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_map_memory(phys_addr_t addr)",
            "{",
            "\tint i = memblock_search(&memblock.memory, addr);",
            "",
            "\tif (i == -1)",
            "\t\treturn false;",
            "\treturn !memblock_is_nomap(&memblock.memory.regions[i]);",
            "}",
            "int __init_memblock memblock_search_pfn_nid(unsigned long pfn,",
            "\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)",
            "{",
            "\tstruct memblock_type *type = &memblock.memory;",
            "\tint mid = memblock_search(type, PFN_PHYS(pfn));",
            "",
            "\tif (mid == -1)",
            "\t\treturn -1;",
            "",
            "\t*start_pfn = PFN_DOWN(type->regions[mid].base);",
            "\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);",
            "",
            "\treturn memblock_get_region_node(&type->regions[mid]);",
            "}",
            "bool __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint idx = memblock_search(&memblock.memory, base);",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "",
            "\tif (idx == -1)",
            "\t\treturn false;",
            "\treturn (memblock.memory.regions[idx].base +",
            "\t\t memblock.memory.regions[idx].size) >= end;",
            "}",
            "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_overlaps_region(&memblock.reserved, base, size);",
            "}",
            "void __init_memblock memblock_trim_memory(phys_addr_t align)",
            "{",
            "\tphys_addr_t start, end, orig_start, orig_end;",
            "\tstruct memblock_region *r;",
            "",
            "\tfor_each_mem_region(r) {",
            "\t\torig_start = r->base;",
            "\t\torig_end = r->base + r->size;",
            "\t\tstart = round_up(orig_start, align);",
            "\t\tend = round_down(orig_end, align);",
            "",
            "\t\tif (start == orig_start && end == orig_end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start < end) {",
            "\t\t\tr->base = start;",
            "\t\t\tr->size = end - start;",
            "\t\t} else {",
            "\t\t\tmemblock_remove_region(&memblock.memory,",
            "\t\t\t\t\t       r - memblock.memory.regions);",
            "\t\t\tr--;",
            "\t\t}",
            "\t}",
            "}",
            "void __init_memblock memblock_set_current_limit(phys_addr_t limit)",
            "{",
            "\tmemblock.current_limit = limit;",
            "}"
          ],
          "function_name": "memblock_mem_limit_remove_map, memblock_search, memblock_is_reserved, memblock_is_memory, memblock_is_map_memory, memblock_search_pfn_nid, memblock_is_region_memory, memblock_is_region_reserved, memblock_trim_memory, memblock_set_current_limit",
          "description": "实现内存块限制移除、搜索和区域判断逻辑，用于管理内存和保留区域的地址范围查询及修剪操作",
          "similarity": 0.6570223569869995
        },
        {
          "chunk_id": 9,
          "file_path": "mm/memblock.c",
          "start_line": 1607,
          "end_line": 1734,
          "content": [
            "phys_addr_t __init memblock_phys_alloc_range(phys_addr_t size,",
            "\t\t\t\t\t     phys_addr_t align,",
            "\t\t\t\t\t     phys_addr_t start,",
            "\t\t\t\t\t     phys_addr_t end)",
            "{",
            "\tmemblock_dbg(\"%s: %llu bytes align=0x%llx from=%pa max_addr=%pa %pS\\n\",",
            "\t\t     __func__, (u64)size, (u64)align, &start, &end,",
            "\t\t     (void *)_RET_IP_);",
            "\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,",
            "\t\t\t\t\tfalse);",
            "}",
            "phys_addr_t __init memblock_phys_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)",
            "{",
            "\treturn memblock_alloc_range_nid(size, align, 0,",
            "\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid, false);",
            "}",
            "void __init memblock_free_late(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t cursor, end;",
            "",
            "\tend = base + size - 1;",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\",",
            "\t\t     __func__, &base, &end, (void *)_RET_IP_);",
            "\tkmemleak_free_part_phys(base, size);",
            "\tcursor = PFN_UP(base);",
            "\tend = PFN_DOWN(base + size);",
            "",
            "\tfor (; cursor < end; cursor++) {",
            "\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);",
            "\t\ttotalram_pages_inc();",
            "\t}",
            "}",
            "phys_addr_t __init_memblock memblock_reserved_kern_size(phys_addr_t limit, int nid)",
            "{",
            "\tstruct memblock_region *r;",
            "\tphys_addr_t total = 0;",
            "",
            "\tfor_each_reserved_mem_region(r) {",
            "\t\tphys_addr_t size = r->size;",
            "",
            "\t\tif (r->base > limit)",
            "\t\t\tbreak;",
            "",
            "\t\tif (r->base + r->size > limit)",
            "\t\t\tsize = limit - r->base;",
            "",
            "\t\tif (nid == memblock_get_region_node(r) || !numa_valid_node(nid))",
            "\t\t\tif (r->flags & MEMBLOCK_RSRV_KERN)",
            "\t\t\t\ttotal += size;",
            "\t}",
            "",
            "\treturn total;",
            "}",
            "unsigned long __init memblock_estimated_nr_free_pages(void)",
            "{",
            "\treturn PHYS_PFN(memblock_phys_mem_size() - memblock_reserved_size());",
            "}",
            "static phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr = PHYS_ADDR_MAX;",
            "\tstruct memblock_region *r;",
            "",
            "\t/*",
            "\t * translate the memory @limit size into the max address within one of",
            "\t * the memory memblock regions, if the @limit exceeds the total size",
            "\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX",
            "\t */",
            "\tfor_each_mem_region(r) {",
            "\t\tif (limit <= r->size) {",
            "\t\t\tmax_addr = r->base + limit;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tlimit -= r->size;",
            "\t}",
            "",
            "\treturn max_addr;",
            "}",
            "void __init memblock_enforce_memory_limit(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\t/* truncate both memory and reserved regions */",
            "\tmemblock_remove_range(&memblock.memory, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "\tmemblock_remove_range(&memblock.reserved, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "}",
            "void __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint start_rgn, end_rgn;",
            "\tint i, ret;",
            "",
            "\tif (!size)",
            "\t\treturn;",
            "",
            "\tif (!memblock_memory->total_size) {",
            "\t\tpr_warn(\"%s: No memory registered yet\\n\", __func__);",
            "\t\treturn;",
            "\t}",
            "",
            "\tret = memblock_isolate_range(&memblock.memory, base, size,",
            "\t\t\t\t\t\t&start_rgn, &end_rgn);",
            "\tif (ret)",
            "\t\treturn;",
            "",
            "\t/* remove all the MAP regions */",
            "\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\tfor (i = start_rgn - 1; i >= 0; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\t/* truncate the reserved regions */",
            "\tmemblock_remove_range(&memblock.reserved, 0, base);",
            "\tmemblock_remove_range(&memblock.reserved,",
            "\t\t\tbase + size, PHYS_ADDR_MAX);",
            "}"
          ],
          "function_name": "memblock_phys_alloc_range, memblock_phys_alloc_try_nid, memblock_free_late, memblock_reserved_kern_size, memblock_estimated_nr_free_pages, __find_max_addr, memblock_enforce_memory_limit, memblock_cap_memory_range",
          "description": "实现物理内存分配/释放控制，包含内存上限强制限制、空闲页面估算、内存区域截断等管理功能，支持对保留内存的容量统计",
          "similarity": 0.6423068046569824
        },
        {
          "chunk_id": 11,
          "file_path": "mm/memblock.c",
          "start_line": 2094,
          "end_line": 2203,
          "content": [
            "static void __init_memblock memblock_dump(struct memblock_type *type)",
            "{",
            "\tphys_addr_t base, end, size;",
            "\tenum memblock_flags flags;",
            "\tint idx;",
            "\tstruct memblock_region *rgn;",
            "",
            "\tpr_info(\" %s.cnt  = 0x%lx\\n\", type->name, type->cnt);",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tchar nid_buf[32] = \"\";",
            "",
            "\t\tbase = rgn->base;",
            "\t\tsize = rgn->size;",
            "\t\tend = base + size - 1;",
            "\t\tflags = rgn->flags;",
            "#ifdef CONFIG_NUMA",
            "\t\tif (numa_valid_node(memblock_get_region_node(rgn)))",
            "\t\t\tsnprintf(nid_buf, sizeof(nid_buf), \" on node %d\",",
            "\t\t\t\t memblock_get_region_node(rgn));",
            "#endif",
            "\t\tpr_info(\" %s[%#x]\\t[%pa-%pa], %pa bytes%s flags: %#x\\n\",",
            "\t\t\ttype->name, idx, &base, &end, &size, nid_buf, flags);",
            "\t}",
            "}",
            "void __init memblock_allow_resize(void)",
            "{",
            "\tmemblock_can_resize = 1;",
            "}",
            "static int __init early_memblock(char *p)",
            "{",
            "\tif (p && strstr(p, \"debug\"))",
            "\t\tmemblock_debug = 1;",
            "\treturn 0;",
            "}",
            "static void __init free_memmap(unsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tstruct page *start_pg, *end_pg;",
            "\tphys_addr_t pg, pgend;",
            "",
            "\t/*",
            "\t * Convert start_pfn/end_pfn to a struct page pointer.",
            "\t */",
            "\tstart_pg = pfn_to_page(start_pfn - 1) + 1;",
            "\tend_pg = pfn_to_page(end_pfn - 1) + 1;",
            "",
            "\t/*",
            "\t * Convert to physical addresses, and round start upwards and end",
            "\t * downwards.",
            "\t */",
            "\tpg = PAGE_ALIGN(__pa(start_pg));",
            "\tpgend = __pa(end_pg) & PAGE_MASK;",
            "",
            "\t/*",
            "\t * If there are free pages between these, free the section of the",
            "\t * memmap array.",
            "\t */",
            "\tif (pg < pgend)",
            "\t\tmemblock_phys_free(pg, pgend - pg);",
            "}",
            "static void __init free_unused_memmap(void)",
            "{",
            "\tunsigned long start, end, prev_end = 0;",
            "\tint i;",
            "",
            "\tif (!IS_ENABLED(CONFIG_HAVE_ARCH_PFN_VALID) ||",
            "\t    IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This relies on each bank being in address order.",
            "\t * The banks are sorted previously in bootmem_init().",
            "\t */",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, NULL) {",
            "#ifdef CONFIG_SPARSEMEM",
            "\t\t/*",
            "\t\t * Take care not to free memmap entries that don't exist",
            "\t\t * due to SPARSEMEM sections which aren't present.",
            "\t\t */",
            "\t\tstart = min(start, ALIGN(prev_end, PAGES_PER_SECTION));",
            "#endif",
            "\t\t/*",
            "\t\t * Align down here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tstart = pageblock_start_pfn(start);",
            "",
            "\t\t/*",
            "\t\t * If we had a previous bank, and there is a space",
            "\t\t * between the current bank and the previous, free it.",
            "\t\t */",
            "\t\tif (prev_end && prev_end < start)",
            "\t\t\tfree_memmap(prev_end, start);",
            "",
            "\t\t/*",
            "\t\t * Align up here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tprev_end = pageblock_align(end);",
            "\t}",
            "",
            "#ifdef CONFIG_SPARSEMEM",
            "\tif (!IS_ALIGNED(prev_end, PAGES_PER_SECTION)) {",
            "\t\tprev_end = pageblock_align(end);",
            "\t\tfree_memmap(prev_end, ALIGN(prev_end, PAGES_PER_SECTION));",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "memblock_dump, memblock_allow_resize, early_memblock, free_memmap, free_unused_memmap",
          "description": "提供内存块状态调试、调整支持、早期内存处理及未使用memmap释放功能，用于优化内存映射管理",
          "similarity": 0.6223063468933105
        },
        {
          "chunk_id": 12,
          "file_path": "mm/memblock.c",
          "start_line": 2233,
          "end_line": 2340,
          "content": [
            "static void __init __free_pages_memory(unsigned long start, unsigned long end)",
            "{",
            "\tint order;",
            "",
            "\twhile (start < end) {",
            "\t\t/*",
            "\t\t * Free the pages in the largest chunks alignment allows.",
            "\t\t *",
            "\t\t * __ffs() behaviour is undefined for 0. start == 0 is",
            "\t\t * MAX_PAGE_ORDER-aligned, set order to MAX_PAGE_ORDER for",
            "\t\t * the case.",
            "\t\t */",
            "\t\tif (start)",
            "\t\t\torder = min_t(int, MAX_PAGE_ORDER, __ffs(start));",
            "\t\telse",
            "\t\t\torder = MAX_PAGE_ORDER;",
            "",
            "\t\twhile (start + (1UL << order) > end)",
            "\t\t\torder--;",
            "",
            "\t\tmemblock_free_pages(pfn_to_page(start), start, order);",
            "",
            "\t\tstart += (1UL << order);",
            "\t}",
            "}",
            "static unsigned long __init __free_memory_core(phys_addr_t start,",
            "\t\t\t\t phys_addr_t end)",
            "{",
            "\tunsigned long start_pfn = PFN_UP(start);",
            "\tunsigned long end_pfn = min_t(unsigned long,",
            "\t\t\t\t      PFN_DOWN(end), max_low_pfn);",
            "",
            "\tif (start_pfn >= end_pfn)",
            "\t\treturn 0;",
            "",
            "\t__free_pages_memory(start_pfn, end_pfn);",
            "",
            "\treturn end_pfn - start_pfn;",
            "}",
            "static void __init memmap_init_reserved_pages(void)",
            "{",
            "\tstruct memblock_region *region;",
            "\tphys_addr_t start, end;",
            "\tint nid;",
            "\tunsigned long max_reserved;",
            "",
            "\t/*",
            "\t * set nid on all reserved pages and also treat struct",
            "\t * pages for the NOMAP regions as PageReserved",
            "\t */",
            "repeat:",
            "\tmax_reserved = memblock.reserved.max;",
            "\tfor_each_mem_region(region) {",
            "\t\tnid = memblock_get_region_node(region);",
            "\t\tstart = region->base;",
            "\t\tend = start + region->size;",
            "",
            "\t\tif (memblock_is_nomap(region))",
            "\t\t\treserve_bootmem_region(start, end, nid);",
            "",
            "\t\tmemblock_set_node(start, region->size, &memblock.reserved, nid);",
            "\t}",
            "\t/*",
            "\t * 'max' is changed means memblock.reserved has been doubled its",
            "\t * array, which may result a new reserved region before current",
            "\t * 'start'. Now we should repeat the procedure to set its node id.",
            "\t */",
            "\tif (max_reserved != memblock.reserved.max)",
            "\t\tgoto repeat;",
            "",
            "\t/*",
            "\t * initialize struct pages for reserved regions that don't have",
            "\t * the MEMBLOCK_RSRV_NOINIT flag set",
            "\t */",
            "\tfor_each_reserved_mem_region(region) {",
            "\t\tif (!memblock_is_reserved_noinit(region)) {",
            "\t\t\tnid = memblock_get_region_node(region);",
            "\t\t\tstart = region->base;",
            "\t\t\tend = start + region->size;",
            "",
            "\t\t\tif (!numa_valid_node(nid))",
            "\t\t\t\tnid = early_pfn_to_nid(PFN_DOWN(start));",
            "",
            "\t\t\treserve_bootmem_region(start, end, nid);",
            "\t\t}",
            "\t}",
            "}",
            "static unsigned long __init free_low_memory_core_early(void)",
            "{",
            "\tunsigned long count = 0;",
            "\tphys_addr_t start, end;",
            "\tu64 i;",
            "",
            "\tmemblock_clear_hotplug(0, -1);",
            "",
            "\tmemmap_init_reserved_pages();",
            "",
            "\t/*",
            "\t * We need to use NUMA_NO_NODE instead of NODE_DATA(0)->node_id",
            "\t *  because in some case like Node0 doesn't have RAM installed",
            "\t *  low ram will be on Node1",
            "\t */",
            "\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,",
            "\t\t\t\tNULL)",
            "\t\tcount += __free_memory_core(start, end);",
            "",
            "\treturn count;",
            "}"
          ],
          "function_name": "__free_pages_memory, __free_memory_core, memmap_init_reserved_pages, free_low_memory_core_early",
          "description": "核心实现内存页面释放逻辑，初始化保留区域页结构并处理低内存核心区域的提前释放操作",
          "similarity": 0.6159067153930664
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memblock.c",
          "start_line": 537,
          "end_line": 685,
          "content": [
            "static void __init_memblock memblock_merge_regions(struct memblock_type *type,",
            "\t\t\t\t\t\t   unsigned long start_rgn,",
            "\t\t\t\t\t\t   unsigned long end_rgn)",
            "{",
            "\tint i = 0;",
            "\tif (start_rgn)",
            "\t\ti = start_rgn - 1;",
            "\tend_rgn = min(end_rgn, type->cnt - 1);",
            "\twhile (i < end_rgn) {",
            "\t\tstruct memblock_region *this = &type->regions[i];",
            "\t\tstruct memblock_region *next = &type->regions[i + 1];",
            "",
            "\t\tif (this->base + this->size != next->base ||",
            "\t\t    memblock_get_region_node(this) !=",
            "\t\t    memblock_get_region_node(next) ||",
            "\t\t    this->flags != next->flags) {",
            "\t\t\tBUG_ON(this->base + this->size > next->base);",
            "\t\t\ti++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tthis->size += next->size;",
            "\t\t/* move forward from next + 1, index of which is i + 2 */",
            "\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));",
            "\t\ttype->cnt--;",
            "\t\tend_rgn--;",
            "\t}",
            "}",
            "static void __init_memblock memblock_insert_region(struct memblock_type *type,",
            "\t\t\t\t\t\t   int idx, phys_addr_t base,",
            "\t\t\t\t\t\t   phys_addr_t size,",
            "\t\t\t\t\t\t   int nid,",
            "\t\t\t\t\t\t   enum memblock_flags flags)",
            "{",
            "\tstruct memblock_region *rgn = &type->regions[idx];",
            "",
            "\tBUG_ON(type->cnt >= type->max);",
            "\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));",
            "\trgn->base = base;",
            "\trgn->size = size;",
            "\trgn->flags = flags;",
            "\tmemblock_set_region_node(rgn, nid);",
            "\ttype->cnt++;",
            "\ttype->total_size += size;",
            "}",
            "static int __init_memblock memblock_add_range(struct memblock_type *type,",
            "\t\t\t\tphys_addr_t base, phys_addr_t size,",
            "\t\t\t\tint nid, enum memblock_flags flags)",
            "{",
            "\tbool insert = false;",
            "\tphys_addr_t obase = base;",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "\tint idx, nr_new, start_rgn = -1, end_rgn;",
            "\tstruct memblock_region *rgn;",
            "",
            "\tif (!size)",
            "\t\treturn 0;",
            "",
            "\t/* special case for empty array */",
            "\tif (type->regions[0].size == 0) {",
            "\t\tWARN_ON(type->cnt != 1 || type->total_size);",
            "\t\ttype->regions[0].base = base;",
            "\t\ttype->regions[0].size = size;",
            "\t\ttype->regions[0].flags = flags;",
            "\t\tmemblock_set_region_node(&type->regions[0], nid);",
            "\t\ttype->total_size = size;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * The worst case is when new range overlaps all existing regions,",
            "\t * then we'll need type->cnt + 1 empty regions in @type. So if",
            "\t * type->cnt * 2 + 1 is less than or equal to type->max, we know",
            "\t * that there is enough empty regions in @type, and we can insert",
            "\t * regions directly.",
            "\t */",
            "\tif (type->cnt * 2 + 1 <= type->max)",
            "\t\tinsert = true;",
            "",
            "repeat:",
            "\t/*",
            "\t * The following is executed twice.  Once with %false @insert and",
            "\t * then with %true.  The first counts the number of regions needed",
            "\t * to accommodate the new area.  The second actually inserts them.",
            "\t */",
            "\tbase = obase;",
            "\tnr_new = 0;",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tphys_addr_t rbase = rgn->base;",
            "\t\tphys_addr_t rend = rbase + rgn->size;",
            "",
            "\t\tif (rbase >= end)",
            "\t\t\tbreak;",
            "\t\tif (rend <= base)",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * @rgn overlaps.  If it separates the lower part of new",
            "\t\t * area, insert that portion.",
            "\t\t */",
            "\t\tif (rbase > base) {",
            "#ifdef CONFIG_NUMA",
            "\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));",
            "#endif",
            "\t\t\tWARN_ON(flags != MEMBLOCK_NONE && flags != rgn->flags);",
            "\t\t\tnr_new++;",
            "\t\t\tif (insert) {",
            "\t\t\t\tif (start_rgn == -1)",
            "\t\t\t\t\tstart_rgn = idx;",
            "\t\t\t\tend_rgn = idx + 1;",
            "\t\t\t\tmemblock_insert_region(type, idx++, base,",
            "\t\t\t\t\t\t       rbase - base, nid,",
            "\t\t\t\t\t\t       flags);",
            "\t\t\t}",
            "\t\t}",
            "\t\t/* area below @rend is dealt with, forget about it */",
            "\t\tbase = min(rend, end);",
            "\t}",
            "",
            "\t/* insert the remaining portion */",
            "\tif (base < end) {",
            "\t\tnr_new++;",
            "\t\tif (insert) {",
            "\t\t\tif (start_rgn == -1)",
            "\t\t\t\tstart_rgn = idx;",
            "\t\t\tend_rgn = idx + 1;",
            "\t\t\tmemblock_insert_region(type, idx, base, end - base,",
            "\t\t\t\t\t       nid, flags);",
            "\t\t}",
            "\t}",
            "",
            "\tif (!nr_new)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * If this was the first round, resize array and repeat for actual",
            "\t * insertions; otherwise, merge and return.",
            "\t */",
            "\tif (!insert) {",
            "\t\twhile (type->cnt + nr_new > type->max)",
            "\t\t\tif (memblock_double_array(type, obase, size) < 0)",
            "\t\t\t\treturn -ENOMEM;",
            "\t\tinsert = true;",
            "\t\tgoto repeat;",
            "\t} else {",
            "\t\tmemblock_merge_regions(type, start_rgn, end_rgn);",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "function_name": "memblock_merge_regions, memblock_insert_region, memblock_add_range",
          "description": "实现内存区域合并（merge_regions）与插入（insert_region）逻辑，处理新增内存范围的拆分与整合，优化连续区域管理。",
          "similarity": 0.6072049140930176
        }
      ]
    },
    {
      "source_file": "mm/mempolicy.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:44:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mempolicy.c`\n\n---\n\n# mempolicy.c 技术文档\n\n## 1. 文件概述\n\n`mempolicy.c` 实现了 Linux 内核中的 NUMA（Non-Uniform Memory Access）内存策略机制，允许用户通过系统调用为进程或虚拟内存区域（VMA）指定内存分配偏好。该机制支持多种内存分配策略，包括本地优先、绑定节点、轮询交错和基于权重的交错分配等，以优化多节点 NUMA 系统上的内存访问性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct mempolicy`：表示内存策略的核心结构，包含策略模式（如 MPOL_INTERLEAVE、MPOL_BIND、MPOL_PREFERRED 等）、节点掩码（nodemask）和引用计数。\n- `struct weighted_interleave_state`：用于实现加权交错分配策略，包含每个节点的权重表（iw_table）和自动模式标志。\n- `default_policy`：全局默认内存策略，初始为 MPOL_LOCAL（本地节点优先）。\n- `preferred_node_policy[MAX_NUMNODES]`：为每个节点预定义的首选策略数组。\n\n### 主要函数与接口\n- `get_il_weight(int node)`：获取指定节点在加权交错策略中的权重。\n- `reduce_interleave_weights(unsigned int *bw, u8 *new_iw)`：将带宽值转换为归一化的交错权重。\n- `mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)`：根据节点性能坐标（读/写带宽）动态更新加权交错策略。\n- 多个辅助函数用于策略创建、复制、合并、验证及与 VMA 和进程上下文的集成。\n\n### 全局变量\n- `policy_cache` / `sn_cache`：用于高效分配 mempolicy 和相关子结构的 slab 缓存。\n- `policy_zone`：标识受策略控制的最高内存区域类型（zone_type），低区域（如 GFP_DMA）不应用策略。\n- `wi_state`：RCU 保护的加权交错状态指针。\n- `node_bw_table`：存储各节点带宽信息，用于动态权重计算。\n- `weightiness`：权重归一化常量（值为 32），平衡权重精度与分配公平性。\n\n## 3. 关键实现\n\n### 策略优先级与作用域\n- **VMA 策略优先于进程策略**：页错误处理时，若 VMA 有策略则使用 VMA 策略，否则回退到当前进程的策略。\n- **中断上下文忽略策略**：所有中断相关的内存分配始终尝试在本地 CPU 节点分配。\n- **策略不跨 swap 保留**：进程策略在页面换出/换入时不被保留。\n\n### 加权交错分配（Weighted Interleave）\n- 基于各 NUMA 节点的读/写带宽动态计算分配权重。\n- 使用 `weightiness=32` 对带宽进行缩放，并通过 GCD（最大公约数）约简权重以减少分配周期长度。\n- 权重状态通过 RCU 机制安全更新，读路径无锁，写路径由 `wi_state_lock` 互斥锁保护。\n\n### 策略类型详解\n- **interleave**：按偏移量（VMA）或进程计数器（进程）在节点集上轮询分配。\n- **weighted interleave**：按节点权重比例分配（如权重 [2,1] 表示节点0:节点1 = 2:1）。\n- **bind**：严格限制在指定节点集分配，无回退（当前实现按节点顺序分配，非最优）。\n- **preferred / preferred many**：优先在指定单个/多个节点分配，失败后回退到默认策略。\n- **default / local**：优先本地节点分配，VMA 中则继承进程策略。\n\n### 内存区域限制\n- 仅对 **最高 zone 层级**（如 NORMAL 或 MOVABLE）应用策略，GFP_DMA、HIGHMEM 等低层级分配忽略策略。\n\n### 特殊共享内存处理\n- **shmem/tmpfs**：策略在所有映射进程间共享，即使无活跃映射也持久保存。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `<linux/mm.h>`、`<linux/vm_area_struct.h>`、`<linux/page-flags.h>` 等进行页分配、VMA 操作和页表遍历。\n- **NUMA 感知调度**：与 `<linux/sched/numa_balancing.h>` 协同，支持自动 NUMA 迁移。\n- **CPUSET 子系统**：通过 `<linux/cpuset.h>` 集成节点可用性约束。\n- **Slab 分配器**：使用 kmem_cache 管理 mempolicy 对象生命周期。\n- **RCU 机制**：用于加权交错状态的无锁读取。\n- **系统调用接口**：通过 `sys_mbind()`、`sys_set_mempolicy()` 等提供用户空间配置入口。\n- **安全模块**：调用 LSM hooks（`security_task_movememory()`）进行权限检查。\n\n## 5. 使用场景\n\n- **高性能计算（HPC）应用**：通过 `mbind()` 将关键数据结构绑定到特定 NUMA 节点，减少远程内存访问延迟。\n- **数据库系统**：使用交错策略均衡多节点内存带宽，提升吞吐量。\n- **虚拟化环境**：VMM 可为不同虚拟机设置独立内存策略，隔离资源并优化性能。\n- **自动 NUMA 优化**：内核 NUMA balancing 机制结合默认策略，自动迁移热点页面至访问 CPU 所在节点。\n- **实时系统**：通过 `MPOL_BIND` 严格限制内存位置，确保确定性访问延迟。\n- **大页（HugeTLB）分配**：策略同样适用于透明大页和显式 HugeTLB 页面分配。",
      "similarity": 0.6651121973991394,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "mm/mempolicy.c",
          "start_line": 880,
          "end_line": 996,
          "content": [
            "static long",
            "queue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,",
            "\t\tnodemask_t *nodes, unsigned long flags,",
            "\t\tstruct list_head *pagelist)",
            "{",
            "\tint err;",
            "\tstruct queue_pages qp = {",
            "\t\t.pagelist = pagelist,",
            "\t\t.flags = flags,",
            "\t\t.nmask = nodes,",
            "\t\t.start = start,",
            "\t\t.end = end,",
            "\t\t.first = NULL,",
            "\t};",
            "\tconst struct mm_walk_ops *ops = (flags & MPOL_MF_WRLOCK) ?",
            "\t\t\t&queue_pages_lock_vma_walk_ops : &queue_pages_walk_ops;",
            "",
            "\terr = walk_page_range(mm, start, end, ops, &qp);",
            "",
            "\tif (!qp.first)",
            "\t\t/* whole range in hole */",
            "\t\terr = -EFAULT;",
            "",
            "\treturn err ? : qp.nr_failed;",
            "}",
            "static int vma_replace_policy(struct vm_area_struct *vma,",
            "\t\t\t\tstruct mempolicy *pol)",
            "{",
            "\tint err;",
            "\tstruct mempolicy *old;",
            "\tstruct mempolicy *new;",
            "",
            "\tvma_assert_write_locked(vma);",
            "",
            "\tnew = mpol_dup(pol);",
            "\tif (IS_ERR(new))",
            "\t\treturn PTR_ERR(new);",
            "",
            "\tif (vma->vm_ops && vma->vm_ops->set_policy) {",
            "\t\terr = vma->vm_ops->set_policy(vma, new);",
            "\t\tif (err)",
            "\t\t\tgoto err_out;",
            "\t}",
            "",
            "\told = vma->vm_policy;",
            "\tvma->vm_policy = new; /* protected by mmap_lock */",
            "\tmpol_put(old);",
            "",
            "\treturn 0;",
            " err_out:",
            "\tmpol_put(new);",
            "\treturn err;",
            "}",
            "static int mbind_range(struct vma_iterator *vmi, struct vm_area_struct *vma,",
            "\t\tstruct vm_area_struct **prev, unsigned long start,",
            "\t\tunsigned long end, struct mempolicy *new_pol)",
            "{",
            "\tunsigned long vmstart, vmend;",
            "",
            "\tvmend = min(end, vma->vm_end);",
            "\tif (start > vma->vm_start) {",
            "\t\t*prev = vma;",
            "\t\tvmstart = start;",
            "\t} else {",
            "\t\tvmstart = vma->vm_start;",
            "\t}",
            "",
            "\tif (mpol_equal(vma->vm_policy, new_pol)) {",
            "\t\t*prev = vma;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tvma =  vma_modify_policy(vmi, *prev, vma, vmstart, vmend, new_pol);",
            "\tif (IS_ERR(vma))",
            "\t\treturn PTR_ERR(vma);",
            "",
            "\t*prev = vma;",
            "\treturn vma_replace_policy(vma, new_pol);",
            "}",
            "static long do_set_mempolicy(unsigned short mode, unsigned short flags,",
            "\t\t\t     nodemask_t *nodes)",
            "{",
            "\tstruct mempolicy *new, *old;",
            "\tNODEMASK_SCRATCH(scratch);",
            "\tint ret;",
            "",
            "\tif (!scratch)",
            "\t\treturn -ENOMEM;",
            "",
            "\tnew = mpol_new(mode, flags, nodes);",
            "\tif (IS_ERR(new)) {",
            "\t\tret = PTR_ERR(new);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\ttask_lock(current);",
            "\tret = mpol_set_nodemask(new, nodes, scratch);",
            "\tif (ret) {",
            "\t\ttask_unlock(current);",
            "\t\tmpol_put(new);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\told = current->mempolicy;",
            "\tcurrent->mempolicy = new;",
            "\tif (new && (new->mode == MPOL_INTERLEAVE ||",
            "\t\t    new->mode == MPOL_WEIGHTED_INTERLEAVE)) {",
            "\t\tcurrent->il_prev = MAX_NUMNODES-1;",
            "\t\tcurrent->il_weight = 0;",
            "\t}",
            "\ttask_unlock(current);",
            "\tmpol_put(old);",
            "\tret = 0;",
            "out:",
            "\tNODEMASK_SCRATCH_FREE(scratch);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "queue_pages_range, vma_replace_policy, mbind_range, do_set_mempolicy",
          "description": "实现内存策略设置，通过queue_pages_range队列页面，vma_replace_policy替换VMA策略，mbind_range绑定指定范围策略，do_set_mempolicy设置当前进程全局内存策略",
          "similarity": 0.5843645930290222
        },
        {
          "chunk_id": 11,
          "file_path": "mm/mempolicy.c",
          "start_line": 1855,
          "end_line": 1971,
          "content": [
            "static int kernel_get_mempolicy(int __user *policy,",
            "\t\t\t\tunsigned long __user *nmask,",
            "\t\t\t\tunsigned long maxnode,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long flags)",
            "{",
            "\tint err;",
            "\tint pval;",
            "\tnodemask_t nodes;",
            "",
            "\tif (nmask != NULL && maxnode < nr_node_ids)",
            "\t\treturn -EINVAL;",
            "",
            "\taddr = untagged_addr(addr);",
            "",
            "\terr = do_get_mempolicy(&pval, &nodes, addr, flags);",
            "",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (policy && put_user(pval, policy))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (nmask)",
            "\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);",
            "",
            "\treturn err;",
            "}",
            "bool vma_migratable(struct vm_area_struct *vma)",
            "{",
            "\tif (vma->vm_flags & (VM_IO | VM_PFNMAP))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * DAX device mappings require predictable access latency, so avoid",
            "\t * incurring periodic faults.",
            "\t */",
            "\tif (vma_is_dax(vma))",
            "\t\treturn false;",
            "",
            "\tif (is_vm_hugetlb_page(vma) &&",
            "\t\t!hugepage_migration_supported(hstate_vma(vma)))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Migration allocates pages in the highest zone. If we cannot",
            "\t * do so then migration (at least from node to node) is not",
            "\t * possible.",
            "\t */",
            "\tif (vma->vm_file &&",
            "\t\tgfp_zone(mapping_gfp_mask(vma->vm_file->f_mapping))",
            "\t\t\t< policy_zone)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "bool vma_policy_mof(struct vm_area_struct *vma)",
            "{",
            "\tstruct mempolicy *pol;",
            "",
            "\tif (vma->vm_ops && vma->vm_ops->get_policy) {",
            "\t\tbool ret = false;",
            "\t\tpgoff_t ilx;\t\t/* ignored here */",
            "",
            "\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start, &ilx);",
            "\t\tif (pol && (pol->flags & MPOL_F_MOF))",
            "\t\t\tret = true;",
            "\t\tmpol_cond_put(pol);",
            "",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tpol = vma->vm_policy;",
            "\tif (!pol)",
            "\t\tpol = get_task_policy(current);",
            "",
            "\treturn pol->flags & MPOL_F_MOF;",
            "}",
            "bool apply_policy_zone(struct mempolicy *policy, enum zone_type zone)",
            "{",
            "\tenum zone_type dynamic_policy_zone = policy_zone;",
            "",
            "\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);",
            "",
            "\t/*",
            "\t * if policy->nodes has movable memory only,",
            "\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.",
            "\t *",
            "\t * policy->nodes is intersect with node_states[N_MEMORY].",
            "\t * so if the following test fails, it implies",
            "\t * policy->nodes has movable memory only.",
            "\t */",
            "\tif (!nodes_intersects(policy->nodes, node_states[N_HIGH_MEMORY]))",
            "\t\tdynamic_policy_zone = ZONE_MOVABLE;",
            "",
            "\treturn zone >= dynamic_policy_zone;",
            "}",
            "static unsigned int weighted_interleave_nodes(struct mempolicy *policy)",
            "{",
            "\tunsigned int node;",
            "\tunsigned int cpuset_mems_cookie;",
            "",
            "retry:",
            "\t/* to prevent miscount use tsk->mems_allowed_seq to detect rebind */",
            "\tcpuset_mems_cookie = read_mems_allowed_begin();",
            "\tnode = current->il_prev;",
            "\tif (!current->il_weight || !node_isset(node, policy->nodes)) {",
            "\t\tnode = next_node_in(node, policy->nodes);",
            "\t\tif (read_mems_allowed_retry(cpuset_mems_cookie))",
            "\t\t\tgoto retry;",
            "\t\tif (node == MAX_NUMNODES)",
            "\t\t\treturn node;",
            "\t\tcurrent->il_prev = node;",
            "\t\tcurrent->il_weight = get_il_weight(node);",
            "\t}",
            "\tcurrent->il_weight--;",
            "\treturn node;",
            "}"
          ],
          "function_name": "kernel_get_mempolicy, vma_migratable, vma_policy_mof, apply_policy_zone, weighted_interleave_nodes",
          "description": "kernel_get_mempolicy 获取当前内存策略参数并复制到用户空间；vma_migratable 判断虚拟内存区域是否支持迁移；vma_policy_mof 检查VMA是否启用了MOF（Migration On Fault）策略；apply_policy_zone 确定当前zone是否满足策略要求；weighted_interleave_nodes 计算加权交错分配的目标节点。",
          "similarity": 0.5660622119903564
        },
        {
          "chunk_id": 13,
          "file_path": "mm/mempolicy.c",
          "start_line": 2149,
          "end_line": 2255,
          "content": [
            "static unsigned int interleave_nid(struct mempolicy *pol, pgoff_t ilx)",
            "{",
            "\tnodemask_t nodemask;",
            "\tunsigned int target, nnodes;",
            "\tint i;",
            "\tint nid;",
            "",
            "\tnnodes = read_once_policy_nodemask(pol, &nodemask);",
            "\tif (!nnodes)",
            "\t\treturn numa_node_id();",
            "\ttarget = ilx % nnodes;",
            "\tnid = first_node(nodemask);",
            "\tfor (i = 0; i < target; i++)",
            "\t\tnid = next_node(nid, nodemask);",
            "\treturn nid;",
            "}",
            "int huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,",
            "\t\tstruct mempolicy **mpol, nodemask_t **nodemask)",
            "{",
            "\tpgoff_t ilx;",
            "\tint nid;",
            "",
            "\tnid = numa_node_id();",
            "\t*mpol = get_vma_policy(vma, addr, hstate_vma(vma)->order, &ilx);",
            "\t*nodemask = policy_nodemask(gfp_flags, *mpol, ilx, &nid);",
            "\treturn nid;",
            "}",
            "bool init_nodemask_of_mempolicy(nodemask_t *mask)",
            "{",
            "\tstruct mempolicy *mempolicy;",
            "",
            "\tif (!(mask && current->mempolicy))",
            "\t\treturn false;",
            "",
            "\ttask_lock(current);",
            "\tmempolicy = current->mempolicy;",
            "\tswitch (mempolicy->mode) {",
            "\tcase MPOL_PREFERRED:",
            "\tcase MPOL_PREFERRED_MANY:",
            "\tcase MPOL_BIND:",
            "\tcase MPOL_INTERLEAVE:",
            "\tcase MPOL_WEIGHTED_INTERLEAVE:",
            "\t\t*mask = mempolicy->nodes;",
            "\t\tbreak;",
            "",
            "\tcase MPOL_LOCAL:",
            "\t\tinit_nodemask_of_node(mask, numa_node_id());",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "\ttask_unlock(current);",
            "",
            "\treturn true;",
            "}",
            "bool mempolicy_in_oom_domain(struct task_struct *tsk,",
            "\t\t\t\t\tconst nodemask_t *mask)",
            "{",
            "\tstruct mempolicy *mempolicy;",
            "\tbool ret = true;",
            "",
            "\tif (!mask)",
            "\t\treturn ret;",
            "",
            "\ttask_lock(tsk);",
            "\tmempolicy = tsk->mempolicy;",
            "\tif (mempolicy && mempolicy->mode == MPOL_BIND)",
            "\t\tret = nodes_intersects(mempolicy->nodes, *mask);",
            "\ttask_unlock(tsk);",
            "",
            "\treturn ret;",
            "}",
            "static unsigned long alloc_pages_bulk_array_interleave(gfp_t gfp,",
            "\t\tstruct mempolicy *pol, unsigned long nr_pages,",
            "\t\tstruct page **page_array)",
            "{",
            "\tint nodes;",
            "\tunsigned long nr_pages_per_node;",
            "\tint delta;",
            "\tint i;",
            "\tunsigned long nr_allocated;",
            "\tunsigned long total_allocated = 0;",
            "",
            "\tnodes = nodes_weight(pol->nodes);",
            "\tnr_pages_per_node = nr_pages / nodes;",
            "\tdelta = nr_pages - nodes * nr_pages_per_node;",
            "",
            "\tfor (i = 0; i < nodes; i++) {",
            "\t\tif (delta) {",
            "\t\t\tnr_allocated = alloc_pages_bulk_noprof(gfp,",
            "\t\t\t\t\tinterleave_nodes(pol), NULL,",
            "\t\t\t\t\tnr_pages_per_node + 1, NULL,",
            "\t\t\t\t\tpage_array);",
            "\t\t\tdelta--;",
            "\t\t} else {",
            "\t\t\tnr_allocated = alloc_pages_bulk_noprof(gfp,",
            "\t\t\t\t\tinterleave_nodes(pol), NULL,",
            "\t\t\t\t\tnr_pages_per_node, NULL, page_array);",
            "\t\t}",
            "",
            "\t\tpage_array += nr_allocated;",
            "\t\ttotal_allocated += nr_allocated;",
            "\t}",
            "",
            "\treturn total_allocated;",
            "}"
          ],
          "function_name": "interleave_nid, huge_node, init_nodemask_of_mempolicy, mempolicy_in_oom_domain, alloc_pages_bulk_array_interleave",
          "description": "interleave_nid 计算简单交错分配的目标节点；huge_node 结合HugeTLB策略确定大页分配节点；init_nodemask_of_mempolicy 初始化当前进程的内存策略节点掩码；mempolicy_in_oom_domain 检查策略节点是否与OOM域重叠；alloc_pages_bulk_array_interleave 执行批量交错分配。",
          "similarity": 0.5557047128677368
        },
        {
          "chunk_id": 10,
          "file_path": "mm/mempolicy.c",
          "start_line": 1735,
          "end_line": 1838,
          "content": [
            "static long kernel_set_mempolicy(int mode, const unsigned long __user *nmask,",
            "\t\t\t\t unsigned long maxnode)",
            "{",
            "\tunsigned short mode_flags;",
            "\tnodemask_t nodes;",
            "\tint lmode = mode;",
            "\tint err;",
            "",
            "\terr = sanitize_mpol_flags(&lmode, &mode_flags);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = get_nodes(&nodes, nmask, maxnode);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn do_set_mempolicy(lmode, mode_flags, &nodes);",
            "}",
            "static int kernel_migrate_pages(pid_t pid, unsigned long maxnode,",
            "\t\t\t\tconst unsigned long __user *old_nodes,",
            "\t\t\t\tconst unsigned long __user *new_nodes)",
            "{",
            "\tstruct mm_struct *mm = NULL;",
            "\tstruct task_struct *task;",
            "\tnodemask_t task_nodes;",
            "\tint err;",
            "\tnodemask_t *old;",
            "\tnodemask_t *new;",
            "\tNODEMASK_SCRATCH(scratch);",
            "",
            "\tif (!scratch)",
            "\t\treturn -ENOMEM;",
            "",
            "\told = &scratch->mask1;",
            "\tnew = &scratch->mask2;",
            "",
            "\terr = get_nodes(old, old_nodes, maxnode);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\terr = get_nodes(new, new_nodes, maxnode);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\t/* Find the mm_struct */",
            "\trcu_read_lock();",
            "\ttask = pid ? find_task_by_vpid(pid) : current;",
            "\tif (!task) {",
            "\t\trcu_read_unlock();",
            "\t\terr = -ESRCH;",
            "\t\tgoto out;",
            "\t}",
            "\tget_task_struct(task);",
            "",
            "\terr = -EINVAL;",
            "",
            "\t/*",
            "\t * Check if this process has the right to modify the specified process.",
            "\t * Use the regular \"ptrace_may_access()\" checks.",
            "\t */",
            "\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\trcu_read_unlock();",
            "\t\terr = -EPERM;",
            "\t\tgoto out_put;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\ttask_nodes = cpuset_mems_allowed(task);",
            "\t/* Is the user allowed to access the target nodes? */",
            "\tif (!nodes_subset(*new, task_nodes) && !capable(CAP_SYS_NICE)) {",
            "\t\terr = -EPERM;",
            "\t\tgoto out_put;",
            "\t}",
            "",
            "\ttask_nodes = cpuset_mems_allowed(current);",
            "\tnodes_and(*new, *new, task_nodes);",
            "\tif (nodes_empty(*new))",
            "\t\tgoto out_put;",
            "",
            "\terr = security_task_movememory(task);",
            "\tif (err)",
            "\t\tgoto out_put;",
            "",
            "\tmm = get_task_mm(task);",
            "\tput_task_struct(task);",
            "",
            "\tif (!mm) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terr = do_migrate_pages(mm, old, new,",
            "\t\tcapable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);",
            "",
            "\tmmput(mm);",
            "out:",
            "\tNODEMASK_SCRATCH_FREE(scratch);",
            "",
            "\treturn err;",
            "",
            "out_put:",
            "\tput_task_struct(task);",
            "\tgoto out;",
            "}"
          ],
          "function_name": "kernel_set_mempolicy, kernel_migrate_pages",
          "description": "kernel_set_mempolicy 设置进程的内存放置策略，通过sanitize_mpol_flags验证模式标志并调用do_set_mempolicy应用策略；kernel_migrate_pages 实现页面迁移，检查目标进程权限，限制迁移节点范围，并调用do_migrate_pages进行实际迁移操作。",
          "similarity": 0.5556261539459229
        },
        {
          "chunk_id": 19,
          "file_path": "mm/mempolicy.c",
          "start_line": 3268,
          "end_line": 3394,
          "content": [
            "void numa_default_policy(void)",
            "{",
            "\tdo_set_mempolicy(MPOL_DEFAULT, 0, NULL);",
            "}",
            "int mpol_parse_str(char *str, struct mempolicy **mpol)",
            "{",
            "\tstruct mempolicy *new = NULL;",
            "\tunsigned short mode_flags;",
            "\tnodemask_t nodes;",
            "\tchar *nodelist = strchr(str, ':');",
            "\tchar *flags = strchr(str, '=');",
            "\tint err = 1, mode;",
            "",
            "\tif (flags)",
            "\t\t*flags++ = '\\0';\t/* terminate mode string */",
            "",
            "\tif (nodelist) {",
            "\t\t/* NUL-terminate mode or flags string */",
            "\t\t*nodelist++ = '\\0';",
            "\t\tif (nodelist_parse(nodelist, nodes))",
            "\t\t\tgoto out;",
            "\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))",
            "\t\t\tgoto out;",
            "\t} else",
            "\t\tnodes_clear(nodes);",
            "",
            "\tmode = match_string(policy_modes, MPOL_MAX, str);",
            "\tif (mode < 0)",
            "\t\tgoto out;",
            "",
            "\tswitch (mode) {",
            "\tcase MPOL_PREFERRED:",
            "\t\t/*",
            "\t\t * Insist on a nodelist of one node only, although later",
            "\t\t * we use first_node(nodes) to grab a single node, so here",
            "\t\t * nodelist (or nodes) cannot be empty.",
            "\t\t */",
            "\t\tif (nodelist) {",
            "\t\t\tchar *rest = nodelist;",
            "\t\t\twhile (isdigit(*rest))",
            "\t\t\t\trest++;",
            "\t\t\tif (*rest)",
            "\t\t\t\tgoto out;",
            "\t\t\tif (nodes_empty(nodes))",
            "\t\t\t\tgoto out;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase MPOL_INTERLEAVE:",
            "\tcase MPOL_WEIGHTED_INTERLEAVE:",
            "\t\t/*",
            "\t\t * Default to online nodes with memory if no nodelist",
            "\t\t */",
            "\t\tif (!nodelist)",
            "\t\t\tnodes = node_states[N_MEMORY];",
            "\t\tbreak;",
            "\tcase MPOL_LOCAL:",
            "\t\t/*",
            "\t\t * Don't allow a nodelist;  mpol_new() checks flags",
            "\t\t */",
            "\t\tif (nodelist)",
            "\t\t\tgoto out;",
            "\t\tbreak;",
            "\tcase MPOL_DEFAULT:",
            "\t\t/*",
            "\t\t * Insist on a empty nodelist",
            "\t\t */",
            "\t\tif (!nodelist)",
            "\t\t\terr = 0;",
            "\t\tgoto out;",
            "\tcase MPOL_PREFERRED_MANY:",
            "\tcase MPOL_BIND:",
            "\t\t/*",
            "\t\t * Insist on a nodelist",
            "\t\t */",
            "\t\tif (!nodelist)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tmode_flags = 0;",
            "\tif (flags) {",
            "\t\t/*",
            "\t\t * Currently, we only support two mutually exclusive",
            "\t\t * mode flags.",
            "\t\t */",
            "\t\tif (!strcmp(flags, \"static\"))",
            "\t\t\tmode_flags |= MPOL_F_STATIC_NODES;",
            "\t\telse if (!strcmp(flags, \"relative\"))",
            "\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;",
            "\t\telse",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tnew = mpol_new(mode, mode_flags, &nodes);",
            "\tif (IS_ERR(new))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Save nodes for mpol_to_str() to show the tmpfs mount options",
            "\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.",
            "\t */",
            "\tif (mode != MPOL_PREFERRED) {",
            "\t\tnew->nodes = nodes;",
            "\t} else if (nodelist) {",
            "\t\tnodes_clear(new->nodes);",
            "\t\tnode_set(first_node(nodes), new->nodes);",
            "\t} else {",
            "\t\tnew->mode = MPOL_LOCAL;",
            "\t}",
            "",
            "\t/*",
            "\t * Save nodes for contextualization: this will be used to \"clone\"",
            "\t * the mempolicy in a specific context [cpuset] at a later time.",
            "\t */",
            "\tnew->w.user_nodemask = nodes;",
            "",
            "\terr = 0;",
            "",
            "out:",
            "\t/* Restore string for error message */",
            "\tif (nodelist)",
            "\t\t*--nodelist = ':';",
            "\tif (flags)",
            "\t\t*--flags = '=';",
            "\tif (!err)",
            "\t\t*mpol = new;",
            "\treturn err;",
            "}"
          ],
          "function_name": "numa_default_policy, mpol_parse_str",
          "description": "numa_default_policy设置系统默认内存策略为默认模式，mpol_parse_str解析内存策略字符串，根据模式类型处理节点列表和标志位，构建对应的内存策略结构体。",
          "similarity": 0.5481172800064087
        }
      ]
    }
  ]
}