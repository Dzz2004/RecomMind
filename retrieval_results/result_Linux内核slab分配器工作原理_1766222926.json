{
  "query": "Linux内核slab分配器工作原理",
  "timestamp": "2025-12-20 17:28:46",
  "retrieved_files": [
    {
      "source_file": "mm/failslab.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:00:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `failslab.c`\n\n---\n\n# failslab.c 技术文档\n\n## 1. 文件概述\n\n`failslab.c` 是 Linux 内核中用于实现 slab 分配器故障注入（fault injection）机制的核心文件。该机制允许在内存分配过程中人为地模拟分配失败，主要用于测试内核代码在内存不足或分配失败情况下的健壮性和错误处理路径。通过此功能，开发者可以验证内核子系统对 `ENOMEM` 等错误的响应是否正确，从而提升系统稳定性。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`failslab` 全局结构体**  \n  包含：\n  - `attr`：`struct fault_attr` 类型，用于配置故障注入的行为（如概率、间隔、堆栈跟踪等）\n  - `ignore_gfp_reclaim`：布尔值，控制是否忽略带有 `__GFP_DIRECT_RECLAIM` 标志的分配请求\n  - `cache_filter`：布尔值，启用后仅对设置了 `SLAB_FAILSLAB` 标志的 slab 缓存进行故障注入\n\n### 主要函数\n- **`should_failslab(struct kmem_cache *s, gfp_t gfpflags)`**  \n  判断当前 slab 分配请求是否应被强制失败。若满足注入条件，返回 `-ENOMEM`；否则返回 `0`。\n  \n- **`setup_failslab(char *str)`**  \n  内核启动参数解析函数，用于通过 `failslab=` 命令行参数初始化故障注入属性。\n\n- **`failslab_debugfs_init(void)`**（条件编译）  \n  在启用了 `CONFIG_FAULT_INJECTION_DEBUG_FS` 时，创建 debugfs 接口，允许运行时动态配置故障注入行为。\n\n### 宏与注解\n- **`ALLOW_ERROR_INJECTION(should_failslab, ERRNO)`**  \n  注册 `should_failslab` 函数为可被 error-injection 框架拦截的函数，支持通过 ftrace 或其他机制动态修改其返回值。\n\n## 3. 关键实现\n\n- **故障注入条件判断逻辑**：\n  1. **跳过 bootstrap cache**：若分配请求来自 `kmem_cache`（即 slab 自身的元数据缓存），则永不注入故障，防止系统初始化失败。\n  2. **跳过 `__GFP_NOFAIL` 请求**：该标志表示分配必须成功，因此不进行故障注入。\n  3. **可选跳过 reclaim 路径**：若 `ignore_gfp_reclaim` 为真且分配请求包含 `__GFP_DIRECT_RECLAIM`（即允许直接回收内存），则跳过注入，避免干扰内存回收关键路径。\n  4. **缓存过滤机制**：若启用 `cache_filter`，仅当目标 slab 缓存设置了 `SLAB_FAILSLAB` 标志时才进行注入，实现细粒度控制。\n  5. **静默模式支持**：若分配请求包含 `__GFP_NOWARN`，则传递 `FAULT_NOWARN` 标志给底层故障注入框架，避免打印警告信息（防止死锁，参考 commit 6b9dbedbe349）。\n\n- **debugfs 接口**：\n  - 创建 `/sys/kernel/debug/failslab/` 目录\n  - 提供 `ignore-gfp-wait`（实际对应 `ignore_gfp_reclaim`）和 `cache-filter` 两个可读写布尔文件，用于运行时调整行为\n\n- **启动参数支持**：  \n  通过 `failslab=<attributes>` 内核命令行参数（如 `failslab=probability:10,interval:100`）初始化故障注入策略。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/fault-inject.h>`：提供通用故障注入框架（`struct fault_attr`, `should_fail_ex()` 等）\n  - `<linux/error-injection.h>`：提供 `ALLOW_ERROR_INJECTION` 宏\n  - `<linux/slab.h>` 和 `\"slab.h\"`：提供 slab 分配器相关定义（`kmem_cache`, `SLAB_FAILSLAB` 等）\n  - `<linux/mm.h>`：提供 GFP 标志定义（如 `__GFP_NOFAIL`, `__GFP_DIRECT_RECLAIM`）\n\n- **内核配置依赖**：\n  - `CONFIG_FAULT_INJECTION`：必须启用才能使用故障注入功能\n  - `CONFIG_FAULT_INJECTION_DEBUG_FS`：启用 debugfs 接口（可选）\n\n- **与其他模块交互**：\n  - 被 slab/slub/slob 分配器调用（通过 `should_failslab()`）\n  - 与内核错误注入框架（error-injection）集成，支持动态返回值修改\n\n## 5. 使用场景\n\n- **内核开发与测试**：\n  - 验证内核子系统在内存分配失败时的错误处理逻辑（如驱动、文件系统、网络协议栈等）\n  - 模拟极端内存压力场景，测试 OOM（Out-Of-Memory）路径的正确性\n\n- **运行时调试**：\n  - 通过 debugfs 动态开启/关闭故障注入，无需重启系统\n  - 结合 `cache-filter` 精准针对特定 slab 缓存（如 `kmalloc-64`）进行测试\n\n- **自动化测试框架集成**：\n  - 作为 LTP（Linux Test Project）、KASAN、KFENCE 等测试工具的底层支持组件\n  - 用于 CI/CD 流水线中的健壮性回归测试\n\n- **安全与可靠性研究**：\n  - 分析内核在资源受限条件下的行为，发现潜在的内存泄漏或未处理错误路径",
      "similarity": 0.6738272309303284,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/failslab.c",
          "start_line": 18,
          "end_line": 66,
          "content": [
            "int should_failslab(struct kmem_cache *s, gfp_t gfpflags)",
            "{",
            "\tint flags = 0;",
            "",
            "\t/* No fault-injection for bootstrap cache */",
            "\tif (unlikely(s == kmem_cache))",
            "\t\treturn 0;",
            "",
            "\tif (gfpflags & __GFP_NOFAIL)",
            "\t\treturn 0;",
            "",
            "\tif (failslab.ignore_gfp_reclaim &&",
            "\t\t\t(gfpflags & __GFP_DIRECT_RECLAIM))",
            "\t\treturn 0;",
            "",
            "\tif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * In some cases, it expects to specify __GFP_NOWARN",
            "\t * to avoid printing any information(not just a warning),",
            "\t * thus avoiding deadlocks. See commit 6b9dbedbe349 for",
            "\t * details.",
            "\t */",
            "\tif (gfpflags & __GFP_NOWARN)",
            "\t\tflags |= FAULT_NOWARN;",
            "",
            "\treturn should_fail_ex(&failslab.attr, s->object_size, flags) ? -ENOMEM : 0;",
            "}",
            "static int __init setup_failslab(char *str)",
            "{",
            "\treturn setup_fault_attr(&failslab.attr, str);",
            "}",
            "static int __init failslab_debugfs_init(void)",
            "{",
            "\tstruct dentry *dir;",
            "\tumode_t mode = S_IFREG | 0600;",
            "",
            "\tdir = fault_create_debugfs_attr(\"failslab\", NULL, &failslab.attr);",
            "\tif (IS_ERR(dir))",
            "\t\treturn PTR_ERR(dir);",
            "",
            "\tdebugfs_create_bool(\"ignore-gfp-wait\", mode, dir,",
            "\t\t\t    &failslab.ignore_gfp_reclaim);",
            "\tdebugfs_create_bool(\"cache-filter\", mode, dir,",
            "\t\t\t    &failslab.cache_filter);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "should_failslab, setup_failslab, failslab_debugfs_init",
          "description": "实现should_failslab函数判断是否触发内存分配故障，setup_failslab初始化故障属性，failslab_debugfs_init创建调试接口用于配置故障注入参数",
          "similarity": 0.6084309816360474
        },
        {
          "chunk_id": 0,
          "file_path": "mm/failslab.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/fault-inject.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include \"slab.h\"",
            "",
            "static struct {",
            "\tstruct fault_attr attr;",
            "\tbool ignore_gfp_reclaim;",
            "\tbool cache_filter;",
            "} failslab = {",
            "\t.attr = FAULT_ATTR_INITIALIZER,",
            "\t.ignore_gfp_reclaim = true,",
            "\t.cache_filter = false,",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义failslab结构体，用于存储故障注入配置属性(ignore_gfp_reclaim和cache_filter标志位)及故障属性(attr)，控制内存分配时的错误注入行为",
          "similarity": 0.6042513847351074
        }
      ]
    },
    {
      "source_file": "mm/slab.h",
      "md_summary": "> 自动生成时间: 2025-12-07 17:22:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `slab.h`\n\n---\n\n# `slab.h` 技术文档\n\n## 1. 文件概述\n\n`slab.h` 是 Linux 内核内存管理子系统中 SLAB/SLUB 分配器的核心内部头文件，定义了 slab 分配器所使用的底层数据结构（如 `struct slab` 和 `struct kmem_cache`）、关键宏和辅助函数。该文件主要用于在页（`struct page`）与 slab 表示之间进行安全转换，并提供对 slab 元数据的原子访问机制，以支持高性能、可扩展的对象缓存分配。\n\n此头文件专供内核内存管理内部使用，不对外暴露给模块开发者，是实现 SLUB（默认）或 SLAB 分配器的关键基础设施。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`freelist_aba_t`**  \n  联合体，将空闲对象指针（`freelist`）与计数器（`counter`）打包为一个原子单元，用于避免 ABA 问题（Compare-and-Swap 中因值重复导致的逻辑错误）。\n\n- **`struct slab`**  \n  slab 的内部表示，复用 `struct page` 的内存布局。包含：\n  - 所属的 `kmem_cache`\n  - 空闲对象链表（`freelist`）\n  - 对象使用计数（`inuse`）、总对象数（`objects`）\n  - 冻结状态（`frozen`，用于调试）\n  - RCU 回收头（`rcu_head`）\n  - 引用计数（`__page_refcount`）\n  - 可选的 per-object 扩展数据（`obj_exts`）\n\n- **`struct kmem_cache_order_objects`**  \n  封装 slab 阶数（order）与对象数量的复合值，支持原子读写。\n\n- **`struct kmem_cache`**  \n  slab 缓存描述符，包含：\n  - 每 CPU 缓存（`cpu_slab`）\n  - 对象大小（`size`, `object_size`）\n  - 构造函数（`ctor`）\n  - 对齐要求（`align`）\n  - 分配标志（`allocflags`）\n  - NUMA 相关参数（如 `remote_node_defrag_ratio`）\n  - 安全特性（如 `random` 用于 freelist 加固）\n\n### 主要宏与辅助函数\n\n- **类型安全转换宏**：\n  - `folio_slab()` / `slab_folio()`：在 `folio` 与 `slab` 之间安全转换\n  - `page_slab()` / `slab_page()`：兼容旧代码，在 `page` 与 `slab` 之间转换\n\n- **slab 属性访问函数**：\n  - `slab_address()`：获取 slab 起始虚拟地址\n  - `slab_nid()` / `slab_pgdat()`：获取所属 NUMA 节点和内存域\n  - `slab_order()` / `slab_size()`：获取分配阶数和总字节数\n\n- **pfmemalloc 标志操作**：\n  - `slab_test_pfmemalloc()` / `slab_set_pfmemalloc()` 等：标记 slab 是否来自紧急内存预留区（用于网络交换等场景）\n\n- **每 CPU partial slab 支持（`CONFIG_SLUB_CPU_PARTIAL`）**：\n  - `slub_percpu_partial()` 等宏：管理每 CPU 的 partial slab 链表\n\n## 3. 关键实现\n\n### 内存布局复用与静态断言\n\n- `struct slab` 并非独立分配，而是直接复用 `struct page` 的内存空间。通过 `static_assert` 确保关键字段偏移一致（如 `flags` ↔ `__page_flags`），保证类型转换安全。\n- 整个 `struct slab` 大小不超过 `struct page`，确保无越界访问。\n\n### ABA 问题防护\n\n- 在支持 `cmpxchg128`（64 位）或 `cmpxchg64`（32 位）的架构上，启用 `freelist_aba_t` 结构，将 `freelist` 指针与递增计数器打包为单个原子单元。\n- 使用 `try_cmpxchg_freelist` 进行原子更新，防止因指针值循环重用导致的 ABA 错误。\n- 若系统不支持对齐的 `struct page`（`!CONFIG_HAVE_ALIGNED_STRUCT_PAGE`），则禁用此优化。\n\n### 类型安全转换\n\n- 使用 C11 `_Generic` 实现类型安全的 `folio`/`slab`/`page` 转换，避免强制类型转换带来的风险，并为未来重构（如完全迁移到 folio）预留接口。\n\n### pfmemalloc 标志复用\n\n- 利用 `folio` 的 `PG_active` 位存储 `pfmemalloc` 标志，指示该 slab 是否从紧急内存池分配，用于网络子系统在内存压力下仍能分配 skb 等关键结构。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/page.h>` / `<linux/folio.h>`：通过 `folio_*` 系列函数操作底层内存\n  - `<linux/reciprocal_div.h>`：用于快速除法（计算对象索引）\n  - `<linux/rcupdate.h>`：通过 `rcu_head` 支持 RCU 安全的 slab 回收\n\n- **可选依赖（由 Kconfig 控制）**：\n  - `CONFIG_SLUB_CPU_PARTIAL`：每 CPU partial slab 优化\n  - `CONFIG_SLAB_OBJ_EXT`：per-object 扩展元数据\n  - `CONFIG_SLAB_FREELIST_HARDENED`：freelist 指针随机化加固\n  - `CONFIG_NUMA`：NUMA 感知分配与碎片整理\n  - `CONFIG_KASAN` / `CONFIG_KFENCE`：内存错误检测集成\n\n- **与内存控制器集成**：\n  - 通过 `memcg_data` 字段（复用 `obj_exts`）支持 memcg 内存统计\n\n## 5. 使用场景\n\n- **SLUB 分配器内部**：作为 `slub.c` 的核心数据结构定义，用于管理 slab 生命周期、对象分配/释放。\n- **内存回收路径**：在 direct reclaim 或 kswapd 中，通过 `slab_folio` 获取 folio 信息以决策回收策略。\n- **调试与监控**：sysfs (`kobj`)、KASAN/KFENCE 集成依赖此结构获取 slab 元数据。\n- **网络子系统**：通过 `pfmemalloc` 标志识别紧急内存分配，确保高优先级数据包处理不被阻塞。\n- **NUMA 优化**：在远程节点分配时使用 `remote_node_defrag_ratio` 参数控制跨节点分配行为。\n- **安全加固**：`SLAB_FREELIST_HARDENED` 利用 `random` 字段混淆 freelist 指针，防止堆利用攻击。",
      "similarity": 0.6730191111564636,
      "chunks": []
    },
    {
      "source_file": "mm/slub.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:23:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `slub.c`\n\n---\n\n# slub.c 技术文档\n\n## 1. 文件概述\n\n`slub.c` 是 Linux 内核中 SLUB（Simple Low-overhead Unqueued Allocator）内存分配器的核心实现文件。SLUB 是一种高效的 slab 分配器，旨在减少缓存行使用并避免在每个 CPU 和节点上维护复杂的对象队列。它通过 per-slab 锁或原子操作进行同步，仅在管理部分填充的 slab 池时使用集中式锁。该分配器优化了常见路径的性能，同时支持调试、内存检测和热插拔等高级功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `kmem_cache`: slab 缓存描述符，包含对象大小、对齐方式、构造函数等元数据\n- `kmem_cache_cpu`: 每 CPU 的 slab 管理结构，包含当前 CPU 的活跃 slab 和局部 freelist\n- `slab`: slab 描述符（通常嵌入在 page 结构中），包含 freelist、inuse 计数、objects 总数和 frozen 状态\n\n### 关键机制\n- **CPU slab**: 每个 CPU 分配专用的 slab 进行快速分配\n- **Partial slab 列表**: 节点级别的部分填充 slab 列表\n- **CPU partial slab**: CPU 本地的部分填充 slab 缓存，用于加速释放操作\n- **Frozen slab**: 冻结状态的 slab，免于全局列表管理\n\n### 锁机制层次\n1. `slab_mutex` - 全局互斥锁，保护所有 slab 列表和元数据变更\n2. `node->list_lock` - 自旋锁，保护节点的 partial/full 列表\n3. `kmem_cache->cpu_slab->lock` - 本地锁，保护慢路径的 per-CPU 字段\n4. `slab_lock(slab)` - slab 锁（仅在不支持 `cmpxchg_double` 的架构上使用）\n5. `object_map_lock` - 调试用途的对象映射锁\n\n## 3. 关键实现\n\n### 锁无关快速路径\n- 分配 (`slab_alloc_node()`) 和释放 (`do_slab_free()`) 操作在满足条件时完全无锁\n- 使用事务 ID (tid) 字段检测抢占或 CPU 迁移\n- 在支持 `cmpxchg_double` 的架构上避免使用 slab_lock\n\n### Slab 状态管理\n- **Node partial slab**: `PG_Workingset && !frozen`\n- **CPU partial slab**: `!PG_Workingset && !frozen`\n- **CPU slab**: `!PG_Workingset && frozen`\n- **Full slab**: `!PG_Workingset && !frozen`\n\n### PREEMPT_RT 支持\n- 在 RT 内核中禁用锁无关快速路径\n- 使用 `migrate_disable()/enable()` 替代 `preempt_disable()/enable()`\n- 本地锁始终被获取以确保 RT 安全性\n\n### 内存管理优化\n- 最小化 slab 设置/拆卸开销，依赖页分配器的 per-CPU 缓存\n- 空 slab 直接释放回页分配器\n- CPU partial slab 机制加速批量释放操作\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **内存管理**: `<linux/mm.h>`, `<linux/swap.h>`, `<linux/memory.h>`\n- **同步原语**: `<linux/bit_spinlock.h>`, `<linux/interrupt.h>`\n- **调试支持**: `<linux/kasan.h>`, `<linux/kmsan.h>`, `<linux/kfence.h>`, `<linux/debugobjects.h>`\n- **系统设施**: `<linux/module.h>`, `<linux/proc_fs.h>`, `<linux/debugfs.h>`\n- **内存控制**: `<linux/memcontrol.h>`, `<linux/cpuset.h>`, `<linux/mempolicy.h>`\n- **测试框架**: `<kunit/test.h>`\n\n### 内部依赖\n- `\"slab.h\"` - slab 分配器通用接口\n- `\"internal.h\"` - 内存管理内部实现\n\n### 子系统交互\n- **页分配器**: 作为底层内存来源\n- **内存热插拔**: 通过 `slab_mutex` 同步回调\n- **内存控制器**: 集成 memcg 功能\n- **跟踪系统**: 通过 `trace/events/kmem.h` 提供分配事件跟踪\n\n## 5. 使用场景\n\n### 内核内存分配\n- 为内核对象（如 task_struct、inode、dentry 等）提供高效的小内存分配\n- 作为 `kmalloc()` 系列函数的底层实现\n- 支持不同大小类别的内存请求（8 字节到几 KB）\n\n### 性能关键路径\n- 中断上下文中的内存分配（通过适当的锁机制保证安全）\n- 高频分配/释放场景（利用 per-CPU slab 和 lockless 快速路径）\n- 批量分配操作（通过 CPU partial slab 优化）\n\n### 调试和监控\n- 内存错误检测（KASAN、KMSAN、KFENCE 集成）\n- 内存泄漏检测（kmemleak 集成）\n- 性能分析（通过 `/proc/slabinfo` 和 debugfs 接口）\n- 故障注入测试（fault-inject 支持）\n\n### 特殊环境支持\n- 实时系统（PREEMPT_RT 配置）\n- 内存受限系统（CONFIG_SLUB_TINY 优化）\n- NUMA 系统（节点感知分配）\n- 内存热插拔环境",
      "similarity": 0.6520533561706543,
      "chunks": [
        {
          "chunk_id": 20,
          "file_path": "mm/slub.c",
          "start_line": 4277,
          "end_line": 4387,
          "content": [
            "static void __slab_free(struct kmem_cache *s, struct slab *slab,",
            "\t\t\tvoid *head, void *tail, int cnt,",
            "\t\t\tunsigned long addr)",
            "",
            "{",
            "\tvoid *prior;",
            "\tint was_frozen;",
            "\tstruct slab new;",
            "\tunsigned long counters;",
            "\tstruct kmem_cache_node *n = NULL;",
            "\tunsigned long flags;",
            "\tbool on_node_partial;",
            "",
            "\tstat(s, FREE_SLOWPATH);",
            "",
            "\tif (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) {",
            "\t\tfree_to_partial_list(s, slab, head, tail, cnt, addr);",
            "\t\treturn;",
            "\t}",
            "",
            "\tdo {",
            "\t\tif (unlikely(n)) {",
            "\t\t\tspin_unlock_irqrestore(&n->list_lock, flags);",
            "\t\t\tn = NULL;",
            "\t\t}",
            "\t\tprior = slab->freelist;",
            "\t\tcounters = slab->counters;",
            "\t\tset_freepointer(s, tail, prior);",
            "\t\tnew.counters = counters;",
            "\t\twas_frozen = new.frozen;",
            "\t\tnew.inuse -= cnt;",
            "\t\tif ((!new.inuse || !prior) && !was_frozen) {",
            "\t\t\t/* Needs to be taken off a list */",
            "\t\t\tif (!kmem_cache_has_cpu_partial(s) || prior) {",
            "",
            "\t\t\t\tn = get_node(s, slab_nid(slab));",
            "\t\t\t\t/*",
            "\t\t\t\t * Speculatively acquire the list_lock.",
            "\t\t\t\t * If the cmpxchg does not succeed then we may",
            "\t\t\t\t * drop the list_lock without any processing.",
            "\t\t\t\t *",
            "\t\t\t\t * Otherwise the list_lock will synchronize with",
            "\t\t\t\t * other processors updating the list of slabs.",
            "\t\t\t\t */",
            "\t\t\t\tspin_lock_irqsave(&n->list_lock, flags);",
            "",
            "\t\t\t\ton_node_partial = slab_test_node_partial(slab);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t} while (!slab_update_freelist(s, slab,",
            "\t\tprior, counters,",
            "\t\thead, new.counters,",
            "\t\t\"__slab_free\"));",
            "",
            "\tif (likely(!n)) {",
            "",
            "\t\tif (likely(was_frozen)) {",
            "\t\t\t/*",
            "\t\t\t * The list lock was not taken therefore no list",
            "\t\t\t * activity can be necessary.",
            "\t\t\t */",
            "\t\t\tstat(s, FREE_FROZEN);",
            "\t\t} else if (kmem_cache_has_cpu_partial(s) && !prior) {",
            "\t\t\t/*",
            "\t\t\t * If we started with a full slab then put it onto the",
            "\t\t\t * per cpu partial list.",
            "\t\t\t */",
            "\t\t\tput_cpu_partial(s, slab, 1);",
            "\t\t\tstat(s, CPU_PARTIAL_FREE);",
            "\t\t}",
            "",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * This slab was partially empty but not on the per-node partial list,",
            "\t * in which case we shouldn't manipulate its list, just return.",
            "\t */",
            "\tif (prior && !on_node_partial) {",
            "\t\tspin_unlock_irqrestore(&n->list_lock, flags);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial))",
            "\t\tgoto slab_empty;",
            "",
            "\t/*",
            "\t * Objects left in the slab. If it was not on the partial list before",
            "\t * then add it.",
            "\t */",
            "\tif (!kmem_cache_has_cpu_partial(s) && unlikely(!prior)) {",
            "\t\tadd_partial(n, slab, DEACTIVATE_TO_TAIL);",
            "\t\tstat(s, FREE_ADD_PARTIAL);",
            "\t}",
            "\tspin_unlock_irqrestore(&n->list_lock, flags);",
            "\treturn;",
            "",
            "slab_empty:",
            "\tif (prior) {",
            "\t\t/*",
            "\t\t * Slab on the partial list.",
            "\t\t */",
            "\t\tremove_partial(n, slab);",
            "\t\tstat(s, FREE_REMOVE_PARTIAL);",
            "\t}",
            "",
            "\tspin_unlock_irqrestore(&n->list_lock, flags);",
            "\tstat(s, FREE_SLAB);",
            "\tdiscard_slab(s, slab);",
            "}"
          ],
          "function_name": "__slab_free",
          "description": "实现SLUB分配器的慢速路径释放逻辑，负责更新slab的空闲指针、计数器及管理部分空闲slab的节点挂载，处理并发场景下的slab状态变更和列表迁移。",
          "similarity": 0.6876222491264343
        },
        {
          "chunk_id": 15,
          "file_path": "mm/slub.c",
          "start_line": 2916,
          "end_line": 3045,
          "content": [
            "static void init_kmem_cache_cpus(struct kmem_cache *s)",
            "{",
            "\tint cpu;",
            "\tstruct kmem_cache_cpu *c;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tc = per_cpu_ptr(s->cpu_slab, cpu);",
            "\t\tlocal_lock_init(&c->lock);",
            "\t\tc->tid = init_tid(cpu);",
            "\t}",
            "}",
            "static void deactivate_slab(struct kmem_cache *s, struct slab *slab,",
            "\t\t\t    void *freelist)",
            "{",
            "\tstruct kmem_cache_node *n = get_node(s, slab_nid(slab));",
            "\tint free_delta = 0;",
            "\tvoid *nextfree, *freelist_iter, *freelist_tail;",
            "\tint tail = DEACTIVATE_TO_HEAD;",
            "\tunsigned long flags = 0;",
            "\tstruct slab new;",
            "\tstruct slab old;",
            "",
            "\tif (READ_ONCE(slab->freelist)) {",
            "\t\tstat(s, DEACTIVATE_REMOTE_FREES);",
            "\t\ttail = DEACTIVATE_TO_TAIL;",
            "\t}",
            "",
            "\t/*",
            "\t * Stage one: Count the objects on cpu's freelist as free_delta and",
            "\t * remember the last object in freelist_tail for later splicing.",
            "\t */",
            "\tfreelist_tail = NULL;",
            "\tfreelist_iter = freelist;",
            "\twhile (freelist_iter) {",
            "\t\tnextfree = get_freepointer(s, freelist_iter);",
            "",
            "\t\t/*",
            "\t\t * If 'nextfree' is invalid, it is possible that the object at",
            "\t\t * 'freelist_iter' is already corrupted.  So isolate all objects",
            "\t\t * starting at 'freelist_iter' by skipping them.",
            "\t\t */",
            "\t\tif (freelist_corrupted(s, slab, &freelist_iter, nextfree))",
            "\t\t\tbreak;",
            "",
            "\t\tfreelist_tail = freelist_iter;",
            "\t\tfree_delta++;",
            "",
            "\t\tfreelist_iter = nextfree;",
            "\t}",
            "",
            "\t/*",
            "\t * Stage two: Unfreeze the slab while splicing the per-cpu",
            "\t * freelist to the head of slab's freelist.",
            "\t */",
            "\tdo {",
            "\t\told.freelist = READ_ONCE(slab->freelist);",
            "\t\told.counters = READ_ONCE(slab->counters);",
            "\t\tVM_BUG_ON(!old.frozen);",
            "",
            "\t\t/* Determine target state of the slab */",
            "\t\tnew.counters = old.counters;",
            "\t\tnew.frozen = 0;",
            "\t\tif (freelist_tail) {",
            "\t\t\tnew.inuse -= free_delta;",
            "\t\t\tset_freepointer(s, freelist_tail, old.freelist);",
            "\t\t\tnew.freelist = freelist;",
            "\t\t} else {",
            "\t\t\tnew.freelist = old.freelist;",
            "\t\t}",
            "\t} while (!slab_update_freelist(s, slab,",
            "\t\told.freelist, old.counters,",
            "\t\tnew.freelist, new.counters,",
            "\t\t\"unfreezing slab\"));",
            "",
            "\t/*",
            "\t * Stage three: Manipulate the slab list based on the updated state.",
            "\t */",
            "\tif (!new.inuse && n->nr_partial >= s->min_partial) {",
            "\t\tstat(s, DEACTIVATE_EMPTY);",
            "\t\tdiscard_slab(s, slab);",
            "\t\tstat(s, FREE_SLAB);",
            "\t} else if (new.freelist) {",
            "\t\tspin_lock_irqsave(&n->list_lock, flags);",
            "\t\tadd_partial(n, slab, tail);",
            "\t\tspin_unlock_irqrestore(&n->list_lock, flags);",
            "\t\tstat(s, tail);",
            "\t} else {",
            "\t\tstat(s, DEACTIVATE_FULL);",
            "\t}",
            "}",
            "static void __put_partials(struct kmem_cache *s, struct slab *partial_slab)",
            "{",
            "\tstruct kmem_cache_node *n = NULL, *n2 = NULL;",
            "\tstruct slab *slab, *slab_to_discard = NULL;",
            "\tunsigned long flags = 0;",
            "",
            "\twhile (partial_slab) {",
            "\t\tslab = partial_slab;",
            "\t\tpartial_slab = slab->next;",
            "",
            "\t\tn2 = get_node(s, slab_nid(slab));",
            "\t\tif (n != n2) {",
            "\t\t\tif (n)",
            "\t\t\t\tspin_unlock_irqrestore(&n->list_lock, flags);",
            "",
            "\t\t\tn = n2;",
            "\t\t\tspin_lock_irqsave(&n->list_lock, flags);",
            "\t\t}",
            "",
            "\t\tif (unlikely(!slab->inuse && n->nr_partial >= s->min_partial)) {",
            "\t\t\tslab->next = slab_to_discard;",
            "\t\t\tslab_to_discard = slab;",
            "\t\t} else {",
            "\t\t\tadd_partial(n, slab, DEACTIVATE_TO_TAIL);",
            "\t\t\tstat(s, FREE_ADD_PARTIAL);",
            "\t\t}",
            "\t}",
            "",
            "\tif (n)",
            "\t\tspin_unlock_irqrestore(&n->list_lock, flags);",
            "",
            "\twhile (slab_to_discard) {",
            "\t\tslab = slab_to_discard;",
            "\t\tslab_to_discard = slab_to_discard->next;",
            "",
            "\t\tstat(s, DEACTIVATE_EMPTY);",
            "\t\tdiscard_slab(s, slab);",
            "\t\tstat(s, FREE_SLAB);",
            "\t}",
            "}"
          ],
          "function_name": "init_kmem_cache_cpus, deactivate_slab, __put_partials",
          "description": "该代码段实现SLUB内存分配器中多CPU协作与内存回收机制。  \n`init_kmem_cache_cpus` 初始化每个CPU的本地slab结构并设置tid；`deactivate_slab` 解冻slab并调整其freelist与计数器，决定是否丢弃或迁移至部分链表；`__put_partials` 管理部分填充slab的回收，判断是否满足空闲条件后进行丢弃。  \n上下文完整，涵盖SLUB分配器中CPU本地缓存同步、slab状态转换及部分对象回收逻辑。",
          "similarity": 0.6781452894210815
        },
        {
          "chunk_id": 32,
          "file_path": "mm/slub.c",
          "start_line": 6074,
          "end_line": 6180,
          "content": [
            "static int add_location(struct loc_track *t, struct kmem_cache *s,",
            "\t\t\t\tconst struct track *track,",
            "\t\t\t\tunsigned int orig_size)",
            "{",
            "\tlong start, end, pos;",
            "\tstruct location *l;",
            "\tunsigned long caddr, chandle, cwaste;",
            "\tunsigned long age = jiffies - track->when;",
            "\tdepot_stack_handle_t handle = 0;",
            "\tunsigned int waste = s->object_size - orig_size;",
            "",
            "#ifdef CONFIG_STACKDEPOT",
            "\thandle = READ_ONCE(track->handle);",
            "#endif",
            "\tstart = -1;",
            "\tend = t->count;",
            "",
            "\tfor ( ; ; ) {",
            "\t\tpos = start + (end - start + 1) / 2;",
            "",
            "\t\t/*",
            "\t\t * There is nothing at \"end\". If we end up there",
            "\t\t * we need to add something to before end.",
            "\t\t */",
            "\t\tif (pos == end)",
            "\t\t\tbreak;",
            "",
            "\t\tl = &t->loc[pos];",
            "\t\tcaddr = l->addr;",
            "\t\tchandle = l->handle;",
            "\t\tcwaste = l->waste;",
            "\t\tif ((track->addr == caddr) && (handle == chandle) &&",
            "\t\t\t(waste == cwaste)) {",
            "",
            "\t\t\tl->count++;",
            "\t\t\tif (track->when) {",
            "\t\t\t\tl->sum_time += age;",
            "\t\t\t\tif (age < l->min_time)",
            "\t\t\t\t\tl->min_time = age;",
            "\t\t\t\tif (age > l->max_time)",
            "\t\t\t\t\tl->max_time = age;",
            "",
            "\t\t\t\tif (track->pid < l->min_pid)",
            "\t\t\t\t\tl->min_pid = track->pid;",
            "\t\t\t\tif (track->pid > l->max_pid)",
            "\t\t\t\t\tl->max_pid = track->pid;",
            "",
            "\t\t\t\tcpumask_set_cpu(track->cpu,",
            "\t\t\t\t\t\tto_cpumask(l->cpus));",
            "\t\t\t}",
            "\t\t\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);",
            "\t\t\treturn 1;",
            "\t\t}",
            "",
            "\t\tif (track->addr < caddr)",
            "\t\t\tend = pos;",
            "\t\telse if (track->addr == caddr && handle < chandle)",
            "\t\t\tend = pos;",
            "\t\telse if (track->addr == caddr && handle == chandle &&",
            "\t\t\t\twaste < cwaste)",
            "\t\t\tend = pos;",
            "\t\telse",
            "\t\t\tstart = pos;",
            "\t}",
            "",
            "\t/*",
            "\t * Not found. Insert new tracking element.",
            "\t */",
            "\tif (t->count >= t->max && !alloc_loc_track(t, 2 * t->max, GFP_ATOMIC))",
            "\t\treturn 0;",
            "",
            "\tl = t->loc + pos;",
            "\tif (pos < t->count)",
            "\t\tmemmove(l + 1, l,",
            "\t\t\t(t->count - pos) * sizeof(struct location));",
            "\tt->count++;",
            "\tl->count = 1;",
            "\tl->addr = track->addr;",
            "\tl->sum_time = age;",
            "\tl->min_time = age;",
            "\tl->max_time = age;",
            "\tl->min_pid = track->pid;",
            "\tl->max_pid = track->pid;",
            "\tl->handle = handle;",
            "\tl->waste = waste;",
            "\tcpumask_clear(to_cpumask(l->cpus));",
            "\tcpumask_set_cpu(track->cpu, to_cpumask(l->cpus));",
            "\tnodes_clear(l->nodes);",
            "\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);",
            "\treturn 1;",
            "}",
            "static void process_slab(struct loc_track *t, struct kmem_cache *s,",
            "\t\tstruct slab *slab, enum track_item alloc,",
            "\t\tunsigned long *obj_map)",
            "{",
            "\tvoid *addr = slab_address(slab);",
            "\tbool is_alloc = (alloc == TRACK_ALLOC);",
            "\tvoid *p;",
            "",
            "\t__fill_map(obj_map, s, slab);",
            "",
            "\tfor_each_object(p, s, addr, slab->objects)",
            "\t\tif (!test_bit(__obj_to_index(s, addr, p), obj_map))",
            "\t\t\tadd_location(t, s, get_track(s, p, alloc),",
            "\t\t\t\t     is_alloc ? get_orig_size(s, p) :",
            "\t\t\t\t\t\ts->object_size);",
            "}"
          ],
          "function_name": "add_location, process_slab",
          "description": "记录对象分配位置信息，遍历slab对象并更新追踪数据，支持调试分析内存分配路径和来源。",
          "similarity": 0.6764546632766724
        },
        {
          "chunk_id": 31,
          "file_path": "mm/slub.c",
          "start_line": 5928,
          "end_line": 6034,
          "content": [
            "static int count_inuse(struct slab *slab)",
            "{",
            "\treturn slab->inuse;",
            "}",
            "static int count_total(struct slab *slab)",
            "{",
            "\treturn slab->objects;",
            "}",
            "static void validate_slab(struct kmem_cache *s, struct slab *slab,",
            "\t\t\t  unsigned long *obj_map)",
            "{",
            "\tvoid *p;",
            "\tvoid *addr = slab_address(slab);",
            "",
            "\tif (!check_slab(s, slab) || !on_freelist(s, slab, NULL))",
            "\t\treturn;",
            "",
            "\t/* Now we know that a valid freelist exists */",
            "\t__fill_map(obj_map, s, slab);",
            "\tfor_each_object(p, s, addr, slab->objects) {",
            "\t\tu8 val = test_bit(__obj_to_index(s, addr, p), obj_map) ?",
            "\t\t\t SLUB_RED_INACTIVE : SLUB_RED_ACTIVE;",
            "",
            "\t\tif (!check_object(s, slab, p, val))",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "static int validate_slab_node(struct kmem_cache *s,",
            "\t\tstruct kmem_cache_node *n, unsigned long *obj_map)",
            "{",
            "\tunsigned long count = 0;",
            "\tstruct slab *slab;",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&n->list_lock, flags);",
            "",
            "\tlist_for_each_entry(slab, &n->partial, slab_list) {",
            "\t\tvalidate_slab(s, slab, obj_map);",
            "\t\tcount++;",
            "\t}",
            "\tif (count != n->nr_partial) {",
            "\t\tpr_err(\"SLUB %s: %ld partial slabs counted but counter=%ld\\n\",",
            "\t\t       s->name, count, n->nr_partial);",
            "\t\tslab_add_kunit_errors();",
            "\t}",
            "",
            "\tif (!(s->flags & SLAB_STORE_USER))",
            "\t\tgoto out;",
            "",
            "\tlist_for_each_entry(slab, &n->full, slab_list) {",
            "\t\tvalidate_slab(s, slab, obj_map);",
            "\t\tcount++;",
            "\t}",
            "\tif (count != node_nr_slabs(n)) {",
            "\t\tpr_err(\"SLUB: %s %ld slabs counted but counter=%ld\\n\",",
            "\t\t       s->name, count, node_nr_slabs(n));",
            "\t\tslab_add_kunit_errors();",
            "\t}",
            "",
            "out:",
            "\tspin_unlock_irqrestore(&n->list_lock, flags);",
            "\treturn count;",
            "}",
            "long validate_slab_cache(struct kmem_cache *s)",
            "{",
            "\tint node;",
            "\tunsigned long count = 0;",
            "\tstruct kmem_cache_node *n;",
            "\tunsigned long *obj_map;",
            "",
            "\tobj_map = bitmap_alloc(oo_objects(s->oo), GFP_KERNEL);",
            "\tif (!obj_map)",
            "\t\treturn -ENOMEM;",
            "",
            "\tflush_all(s);",
            "\tfor_each_kmem_cache_node(s, node, n)",
            "\t\tcount += validate_slab_node(s, n, obj_map);",
            "",
            "\tbitmap_free(obj_map);",
            "",
            "\treturn count;",
            "}",
            "static void free_loc_track(struct loc_track *t)",
            "{",
            "\tif (t->max)",
            "\t\tfree_pages((unsigned long)t->loc,",
            "\t\t\tget_order(sizeof(struct location) * t->max));",
            "}",
            "static int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)",
            "{",
            "\tstruct location *l;",
            "\tint order;",
            "",
            "\torder = get_order(sizeof(struct location) * max);",
            "",
            "\tl = (void *)__get_free_pages(flags, order);",
            "\tif (!l)",
            "\t\treturn 0;",
            "",
            "\tif (t->count) {",
            "\t\tmemcpy(l, t->loc, sizeof(struct location) * t->count);",
            "\t\tfree_loc_track(t);",
            "\t}",
            "\tt->max = max;",
            "\tt->loc = l;",
            "\treturn 1;",
            "}"
          ],
          "function_name": "count_inuse, count_total, validate_slab, validate_slab_node, validate_slab_cache, free_loc_track, alloc_loc_track",
          "description": "验证slab对象有效性，检查对象状态并记录跟踪信息，管理跟踪数据的内存分配与释放，用于调试和错误检测。",
          "similarity": 0.6609644889831543
        },
        {
          "chunk_id": 17,
          "file_path": "mm/slub.c",
          "start_line": 3191,
          "end_line": 3333,
          "content": [
            "static void flush_cpu_slab(struct work_struct *w)",
            "{",
            "\tstruct kmem_cache *s;",
            "\tstruct kmem_cache_cpu *c;",
            "\tstruct slub_flush_work *sfw;",
            "",
            "\tsfw = container_of(w, struct slub_flush_work, work);",
            "",
            "\ts = sfw->s;",
            "\tc = this_cpu_ptr(s->cpu_slab);",
            "",
            "\tif (c->slab)",
            "\t\tflush_slab(s, c);",
            "",
            "\tput_partials(s);",
            "}",
            "static bool has_cpu_slab(int cpu, struct kmem_cache *s)",
            "{",
            "\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);",
            "",
            "\treturn c->slab || slub_percpu_partial(c);",
            "}",
            "static void flush_all_cpus_locked(struct kmem_cache *s)",
            "{",
            "\tstruct slub_flush_work *sfw;",
            "\tunsigned int cpu;",
            "",
            "\tlockdep_assert_cpus_held();",
            "\tmutex_lock(&flush_lock);",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tsfw = &per_cpu(slub_flush, cpu);",
            "\t\tif (!has_cpu_slab(cpu, s)) {",
            "\t\t\tsfw->skip = true;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tINIT_WORK(&sfw->work, flush_cpu_slab);",
            "\t\tsfw->skip = false;",
            "\t\tsfw->s = s;",
            "\t\tqueue_work_on(cpu, flushwq, &sfw->work);",
            "\t}",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tsfw = &per_cpu(slub_flush, cpu);",
            "\t\tif (sfw->skip)",
            "\t\t\tcontinue;",
            "\t\tflush_work(&sfw->work);",
            "\t}",
            "",
            "\tmutex_unlock(&flush_lock);",
            "}",
            "static void flush_all(struct kmem_cache *s)",
            "{",
            "\tcpus_read_lock();",
            "\tflush_all_cpus_locked(s);",
            "\tcpus_read_unlock();",
            "}",
            "static int slub_cpu_dead(unsigned int cpu)",
            "{",
            "\tstruct kmem_cache *s;",
            "",
            "\tmutex_lock(&slab_mutex);",
            "\tlist_for_each_entry(s, &slab_caches, list)",
            "\t\t__flush_cpu_slab(s, cpu);",
            "\tmutex_unlock(&slab_mutex);",
            "\treturn 0;",
            "}",
            "static inline void flush_all_cpus_locked(struct kmem_cache *s) { }",
            "static inline void flush_all(struct kmem_cache *s) { }",
            "static inline void __flush_cpu_slab(struct kmem_cache *s, int cpu) { }",
            "static inline int slub_cpu_dead(unsigned int cpu) { return 0; }",
            "static inline int node_match(struct slab *slab, int node)",
            "{",
            "#ifdef CONFIG_NUMA",
            "\tif (node != NUMA_NO_NODE && slab_nid(slab) != node)",
            "\t\treturn 0;",
            "#endif",
            "\treturn 1;",
            "}",
            "static int count_free(struct slab *slab)",
            "{",
            "\treturn slab->objects - slab->inuse;",
            "}",
            "static inline unsigned long node_nr_objs(struct kmem_cache_node *n)",
            "{",
            "\treturn atomic_long_read(&n->total_objects);",
            "}",
            "static inline bool free_debug_processing(struct kmem_cache *s,",
            "\tstruct slab *slab, void *head, void *tail, int *bulk_cnt,",
            "\tunsigned long addr, depot_stack_handle_t handle)",
            "{",
            "\tbool checks_ok = false;",
            "\tvoid *object = head;",
            "\tint cnt = 0;",
            "",
            "\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {",
            "\t\tif (!check_slab(s, slab))",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tif (slab->inuse < *bulk_cnt) {",
            "\t\tslab_err(s, slab, \"Slab has %d allocated objects but %d are to be freed\\n\",",
            "\t\t\t slab->inuse, *bulk_cnt);",
            "\t\tgoto out;",
            "\t}",
            "",
            "next_object:",
            "",
            "\tif (++cnt > *bulk_cnt)",
            "\t\tgoto out_cnt;",
            "",
            "\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {",
            "\t\tif (!free_consistency_checks(s, slab, object, addr))",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tif (s->flags & SLAB_STORE_USER)",
            "\t\tset_track_update(s, object, TRACK_FREE, addr, handle);",
            "\ttrace(s, slab, object, 0);",
            "\t/* Freepointer not overwritten by init_object(), SLAB_POISON moved it */",
            "\tinit_object(s, object, SLUB_RED_INACTIVE);",
            "",
            "\t/* Reached end of constructed freelist yet? */",
            "\tif (object != tail) {",
            "\t\tobject = get_freepointer(s, object);",
            "\t\tgoto next_object;",
            "\t}",
            "\tchecks_ok = true;",
            "",
            "out_cnt:",
            "\tif (cnt != *bulk_cnt) {",
            "\t\tslab_err(s, slab, \"Bulk free expected %d objects but found %d\\n\",",
            "\t\t\t *bulk_cnt, cnt);",
            "\t\t*bulk_cnt = cnt;",
            "\t}",
            "",
            "out:",
            "",
            "\tif (!checks_ok)",
            "\t\tslab_fix(s, \"Object at 0x%p not freed\", object);",
            "",
            "\treturn checks_ok;",
            "}"
          ],
          "function_name": "flush_cpu_slab, has_cpu_slab, flush_all_cpus_locked, flush_all, slub_cpu_dead, flush_all_cpus_locked, flush_all, __flush_cpu_slab, slub_cpu_dead, node_match, count_free, node_nr_objs, free_debug_processing",
          "description": "该代码段实现了SLUB内存分配器中CPU本地缓存的刷新与清理机制，核心功能包括多CPU协作的slab数据同步及异常情况下（如CPU下线）的资源回收。  \n`flush_all_cpus_locked`协调所有CPU执行slab刷新任务，通过工作队列异步处理；`slub_cpu_dead`在CPU死亡时遍历全局slab进行清理，而`has_cpu_slab`等辅助函数用于判断CPU缓存状态。  \n注：部分函数（如`__flush_cpu_slab`）仅声明未实现，上下文不完整。",
          "similarity": 0.6444675922393799
        }
      ]
    }
  ]
}