{
  "query": "/proc 文件系统 进程跟踪",
  "timestamp": "2025-12-26 14:34:19",
  "retrieved_files": [
    {
      "source_file": "kernel/ptrace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ptrace.c`\n\n---\n\n# ptrace.c 技术文档\n\n## 1. 文件概述\n\n`ptrace.c` 是 Linux 内核中实现 **ptrace**（进程跟踪）机制的核心通用代码文件。该文件提供了跨架构的 ptrace 公共接口和基础功能，避免在每个体系结构中重复实现相同逻辑。ptrace 机制允许一个进程（tracer，通常是调试器）观察和控制另一个进程（tracee）的执行，包括读写其内存、寄存器状态、拦截系统调用等，是调试器（如 GDB）、系统调用追踪工具（如 strace）和安全监控工具的基础。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`ptrace_access_vm()`**  \n  安全地访问被跟踪进程（tracee）的虚拟内存空间，用于读写其内存内容。\n\n- **`__ptrace_link()`**  \n  将被跟踪进程链接到跟踪进程（tracer）的 `ptraced` 链表中，并设置其父进程为 tracer。\n\n- **`ptrace_link()`**  \n  封装 `__ptrace_link()`，使用当前进程的凭证建立跟踪关系。\n\n- **`__ptrace_unlink()`**  \n  解除跟踪关系：将被跟踪进程从 tracer 的链表中移除，恢复其原始父进程，并根据进程组停止状态调整其任务状态（如从 `TASK_TRACED` 转为 `TASK_STOPPED` 或唤醒）。\n\n- **`ptrace_freeze_traced()`** / **`ptrace_unfreeze_traced()`**  \n  在执行 ptrace 操作期间临时冻结被跟踪进程，防止其被意外唤醒（即使是 SIGKILL），确保操作的原子性和一致性。\n\n- **`ptrace_check_attach()`**  \n  验证当前进程是否有权对目标进程执行 ptrace 操作，并确保目标进程处于合适的跟踪状态（可选）。\n\n- **`looks_like_a_spurious_pid()`**  \n  辅助函数，用于检测因线程组 leader 更换（如 `de_thread()`）导致的“虚假”ptrace 事件，避免对已销毁进程的误操作。\n\n### 关键数据结构字段（在 `task_struct` 中）\n\n- `ptrace`：标志位，表示进程是否被跟踪。\n- `parent` / `real_parent`：分别表示当前父进程（通常是 tracer）和原始父进程。\n- `ptraced`：链表头，包含所有被当前进程跟踪的子进程。\n- `ptrace_entry`：链表节点，用于加入 tracer 的 `ptraced` 链表。\n- `ptracer_cred`：跟踪进程的凭证（credentials），用于权限检查。\n- `jobctl`：任务控制标志，包含 `JOBCTL_PTRACE_FROZEN`、`JOBCTL_TRACED`、`JOBCTL_STOP_PENDING` 等 ptrace 相关状态。\n\n## 3. 关键实现\n\n### 安全内存访问 (`ptrace_access_vm`)\n- 通过 `get_task_mm()` 获取目标进程的内存描述符 `mm_struct`。\n- 执行严格的权限检查：\n  - 目标进程必须正在被跟踪（`tsk->ptrace` 非零）。\n  - 当前进程必须是目标进程的直接父进程（`current == tsk->parent`）。\n  - 或者当前进程在目标进程的用户命名空间中具有 `CAP_SYS_PTRACE` 能力（通过 `ptracer_capable()` 检查）。\n- 使用 `__access_remote_vm()` 安全地读写目标进程内存，避免直接遍历页表。\n\n### 跟踪关系管理\n- **链接**：`ptrace_link()` 在持有 `tasklist_lock` 写锁时调用 `__ptrace_link()`，将 tracee 加入 tracer 的 `ptraced` 链表，并保存 tracer 的凭证。\n- **解链接**：`__ptrace_unlink()` 在 detach 或 tracer 退出时调用：\n  - 清除 syscall trace/emu 标志。\n  - 恢复 `real_parent`。\n  - 清除 `ptrace` 标志和 jobctl 中的 trap 相关位。\n  - 根据进程组停止状态决定是否设置 `JOBCTL_STOP_PENDING` 并唤醒进程（`ptrace_signal_wake_up()`）。\n\n### 进程状态冻结机制\n- 在执行 ptrace 操作前调用 `ptrace_freeze_traced()`：\n  - 若 tracee 处于 `TASK_TRACED` 且无致命信号待处理，则设置 `JOBCTL_PTRACE_FROZEN` 标志，使其无法被唤醒。\n- 操作完成后调用 `ptrace_unfreeze_traced()`：\n  - 清除冻结标志。\n  - 若存在致命信号（如 SIGKILL），则清除 `JOBCTL_TRACED` 并唤醒进程以处理信号。\n\n### 权限与状态验证 (`ptrace_check_attach`)\n- 在 `tasklist_lock` 读锁保护下验证：\n  - 目标进程确由当前进程跟踪（`child->ptrace && child->parent == current`）。\n  - 若 `ignore_state=false`，则进一步冻结 tracee 以确保其处于稳定状态。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`mm_struct`、`sighand_struct` 等核心数据结构，以及 `wake_up_state()`、`task_is_traced()` 等调度状态管理函数。\n- **内存管理**：通过 `get_task_mm()`、`mmput()` 和 `__access_remote_vm()` 访问远程进程内存。\n- **信号处理**：大量使用 `siglock`、`jobctl`、`signal_struct` 等信号相关机制管理进程状态转换。\n- **安全模块**：集成 LSM（Linux Security Module）钩子（`security_ptrace_access_check`）和能力检查（`capable()`）。\n- **审计与通知**：与 `audit` 和 `cn_proc`（进程事件连接器）交互，记录 ptrace 事件。\n- **体系结构相关代码**：依赖 `asm/syscall.h` 提供的 `syscall_get_*` 接口获取系统调用信息。\n- **硬件断点**：通过 `hw_breakpoint.h` 支持硬件断点调试功能。\n\n## 5. 使用场景\n\n- **调试器（如 GDB）**：attach 到目标进程，读取/修改寄存器和内存，设置断点，单步执行。\n- **系统调用追踪（如 strace）**：拦截并记录目标进程的所有系统调用及其参数和返回值。\n- **安全监控工具**：监控可疑进程的行为，如检测恶意代码注入或提权操作。\n- **容器与沙箱**：在用户命名空间中实现进程隔离和监控。\n- **内核测试**：用于内核自检和调试，验证进程行为和系统调用处理。\n- **进程注入与热补丁**：通过修改运行中进程的内存和寄存器状态实现代码注入或修复。",
      "similarity": 0.6676080226898193,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/ptrace.c",
          "start_line": 44,
          "end_line": 148,
          "content": [
            "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,",
            "\t\t     void *buf, int len, unsigned int gup_flags)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint ret;",
            "",
            "\tmm = get_task_mm(tsk);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tif (!tsk->ptrace ||",
            "\t    (current != tsk->parent) ||",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptracer_capable(tsk, mm->user_ns))) {",
            "\t\tmmput(mm);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = __access_remote_vm(mm, addr, buf, len, gup_flags);",
            "\tmmput(mm);",
            "",
            "\treturn ret;",
            "}",
            "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,",
            "\t\t   const struct cred *ptracer_cred)",
            "{",
            "\tBUG_ON(!list_empty(&child->ptrace_entry));",
            "\tlist_add(&child->ptrace_entry, &new_parent->ptraced);",
            "\tchild->parent = new_parent;",
            "\tchild->ptracer_cred = get_cred(ptracer_cred);",
            "}",
            "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)",
            "{",
            "\t__ptrace_link(child, new_parent, current_cred());",
            "}",
            "void __ptrace_unlink(struct task_struct *child)",
            "{",
            "\tconst struct cred *old_cred;",
            "\tBUG_ON(!child->ptrace);",
            "",
            "\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tchild->parent = child->real_parent;",
            "\tlist_del_init(&child->ptrace_entry);",
            "\told_cred = child->ptracer_cred;",
            "\tchild->ptracer_cred = NULL;",
            "\tput_cred(old_cred);",
            "",
            "\tspin_lock(&child->sighand->siglock);",
            "\tchild->ptrace = 0;",
            "\t/*",
            "\t * Clear all pending traps and TRAPPING.  TRAPPING should be",
            "\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.",
            "\t */",
            "\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);",
            "\ttask_clear_jobctl_trapping(child);",
            "",
            "\t/*",
            "\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and",
            "\t * @child isn't dead.",
            "\t */",
            "\tif (!(child->flags & PF_EXITING) &&",
            "\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||",
            "\t     child->signal->group_stop_count)) {",
            "\t\tchild->jobctl |= JOBCTL_STOP_PENDING;",
            "",
            "\t\t/*",
            "\t\t * This is only possible if this thread was cloned by the",
            "\t\t * traced task running in the stopped group, set the signal",
            "\t\t * for the future reports.",
            "\t\t * FIXME: we should change ptrace_init_task() to handle this",
            "\t\t * case.",
            "\t\t */",
            "\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))",
            "\t\t\tchild->jobctl |= SIGSTOP;",
            "\t}",
            "",
            "\t/*",
            "\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick",
            "\t * @child in the butt.  Note that @resume should be used iff @child",
            "\t * is in TASK_TRACED; otherwise, we might unduly disrupt",
            "\t * TASK_KILLABLE sleeps.",
            "\t */",
            "\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))",
            "\t\tptrace_signal_wake_up(child, true);",
            "",
            "\tspin_unlock(&child->sighand->siglock);",
            "}",
            "static bool looks_like_a_spurious_pid(struct task_struct *task)",
            "{",
            "\tif (task->exit_code != ((PTRACE_EVENT_EXEC << 8) | SIGTRAP))",
            "\t\treturn false;",
            "",
            "\tif (task_pid_vnr(task) == task->ptrace_message)",
            "\t\treturn false;",
            "\t/*",
            "\t * The tracee changed its pid but the PTRACE_EVENT_EXEC event",
            "\t * was not wait()'ed, most probably debugger targets the old",
            "\t * leader which was destroyed in de_thread().",
            "\t */",
            "\treturn true;",
            "}"
          ],
          "function_name": "ptrace_access_vm, __ptrace_link, ptrace_link, __ptrace_unlink, looks_like_a_spurious_pid",
          "description": "实现进程跟踪核心操作，包含访问目标进程地址空间、维护跟踪链表、解除跟踪关系及检测虚假PID逻辑，用于安全控制和状态同步。",
          "similarity": 0.6637402772903442
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/ptrace.c",
          "start_line": 360,
          "end_line": 490,
          "content": [
            "bool ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tint err;",
            "\ttask_lock(task);",
            "\terr = __ptrace_may_access(task, mode);",
            "\ttask_unlock(task);",
            "\treturn !err;",
            "}",
            "static int check_ptrace_options(unsigned long data)",
            "{",
            "\tif (data & ~(unsigned long)PTRACE_O_MASK)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {",
            "\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||",
            "\t\t    !IS_ENABLED(CONFIG_SECCOMP))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (!capable(CAP_SYS_ADMIN))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||",
            "\t\t    current->ptrace & PT_SUSPEND_SECCOMP)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "\treturn 0;",
            "}",
            "static inline void ptrace_set_stopped(struct task_struct *task)",
            "{",
            "\tguard(spinlock)(&task->sighand->siglock);",
            "",
            "\t/*",
            "\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and",
            "\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING",
            "\t * will be cleared if the child completes the transition or any",
            "\t * event which clears the group stop states happens.  We'll wait",
            "\t * for the transition to complete before returning from this",
            "\t * function.",
            "\t *",
            "\t * This hides STOPPED -> RUNNING -> TRACED transition from the",
            "\t * attaching thread but a different thread in the same group can",
            "\t * still observe the transient RUNNING state.  IOW, if another",
            "\t * thread's WNOHANG wait(2) on the stopped tracee races against",
            "\t * ATTACH, the wait(2) may fail due to the transient RUNNING.",
            "\t *",
            "\t * The following task_is_stopped() test is safe as both transitions",
            "\t * in and out of STOPPED are protected by siglock.",
            "\t */",
            "\tif (task_is_stopped(task) &&",
            "\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING)) {",
            "\t\ttask->jobctl &= ~JOBCTL_STOPPED;",
            "\t\tsignal_wake_up_state(task, __TASK_STOPPED);",
            "\t}",
            "}",
            "static int ptrace_attach(struct task_struct *task, long request,",
            "\t\t\t unsigned long addr,",
            "\t\t\t unsigned long flags)",
            "{",
            "\tbool seize = (request == PTRACE_SEIZE);",
            "\tint retval;",
            "",
            "\tif (seize) {",
            "\t\tif (addr != 0)",
            "\t\t\treturn -EIO;",
            "\t\t/*",
            "\t\t * This duplicates the check in check_ptrace_options() because",
            "\t\t * ptrace_attach() and ptrace_setoptions() have historically",
            "\t\t * used different error codes for unknown ptrace options.",
            "\t\t */",
            "\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)",
            "\t\t\treturn -EIO;",
            "",
            "\t\tretval = check_ptrace_options(flags);",
            "\t\tif (retval)",
            "\t\t\treturn retval;",
            "\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);",
            "\t} else {",
            "\t\tflags = PT_PTRACED;",
            "\t}",
            "",
            "\taudit_ptrace(task);",
            "",
            "\tif (unlikely(task->flags & PF_KTHREAD))",
            "\t\treturn -EPERM;",
            "\tif (same_thread_group(task, current))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Protect exec's credential calculations against our interference;",
            "\t * SUID, SGID and LSM creds get determined differently",
            "\t * under ptrace.",
            "\t */",
            "\tscoped_cond_guard (mutex_intr, return -ERESTARTNOINTR,",
            "\t\t\t   &task->signal->cred_guard_mutex) {",
            "",
            "\t\tscoped_guard (task_lock, task) {",
            "\t\t\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);",
            "\t\t\tif (retval)",
            "\t\t\t\treturn retval;",
            "\t\t}",
            "",
            "\t\tscoped_guard (write_lock_irq, &tasklist_lock) {",
            "\t\t\tif (unlikely(task->exit_state))",
            "\t\t\t\treturn -EPERM;",
            "\t\t\tif (task->ptrace)",
            "\t\t\t\treturn -EPERM;",
            "",
            "\t\t\ttask->ptrace = flags;",
            "",
            "\t\t\tptrace_link(task, current);",
            "",
            "\t\t\t/* SEIZE doesn't trap tracee on attach */",
            "\t\t\tif (!seize)",
            "\t\t\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);",
            "",
            "\t\t\tptrace_set_stopped(task);",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * We do not bother to change retval or clear JOBCTL_TRAPPING",
            "\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will",
            "\t * not return to user-mode, it will exit and clear this bit in",
            "\t * __ptrace_unlink() if it wasn't already cleared by the tracee;",
            "\t * and until then nobody can ptrace this task.",
            "\t */",
            "\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);",
            "\tproc_ptrace_connector(task, PTRACE_ATTACH);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "ptrace_may_access, check_ptrace_options, ptrace_set_stopped, ptrace_attach",
          "description": "实现ptrace附加流程，包含权限校验、选项解析、停止状态设置及实际附加操作，协调信号传递和跟踪标志位更新。",
          "similarity": 0.6133445501327515
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/ptrace.c",
          "start_line": 195,
          "end_line": 336,
          "content": [
            "static bool ptrace_freeze_traced(struct task_struct *task)",
            "{",
            "\tbool ret = false;",
            "",
            "\t/* Lockless, nobody but us can set this flag */",
            "\tif (task->jobctl & JOBCTL_LISTENING)",
            "\t\treturn ret;",
            "",
            "\tspin_lock_irq(&task->sighand->siglock);",
            "\tif (task_is_traced(task) && !looks_like_a_spurious_pid(task) &&",
            "\t    !__fatal_signal_pending(task)) {",
            "\t\ttask->jobctl |= JOBCTL_PTRACE_FROZEN;",
            "\t\tret = true;",
            "\t}",
            "\tspin_unlock_irq(&task->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void ptrace_unfreeze_traced(struct task_struct *task)",
            "{",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * The child may be awake and may have cleared",
            "\t * JOBCTL_PTRACE_FROZEN (see ptrace_resume).  The child will",
            "\t * not set JOBCTL_PTRACE_FROZEN or enter __TASK_TRACED anew.",
            "\t */",
            "\tif (lock_task_sighand(task, &flags)) {",
            "\t\ttask->jobctl &= ~JOBCTL_PTRACE_FROZEN;",
            "\t\tif (__fatal_signal_pending(task)) {",
            "\t\t\ttask->jobctl &= ~JOBCTL_TRACED;",
            "\t\t\twake_up_state(task, __TASK_TRACED);",
            "\t\t}",
            "\t\tunlock_task_sighand(task, &flags);",
            "\t}",
            "}",
            "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)",
            "{",
            "\tint ret = -ESRCH;",
            "",
            "\t/*",
            "\t * We take the read lock around doing both checks to close a",
            "\t * possible race where someone else was tracing our child and",
            "\t * detached between these two checks.  After this locked check,",
            "\t * we are sure that this is our traced child and that can only",
            "\t * be changed by us so it's not changing right after this.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tif (child->ptrace && child->parent == current) {",
            "\t\t/*",
            "\t\t * child->sighand can't be NULL, release_task()",
            "\t\t * does ptrace_unlink() before __exit_signal().",
            "\t\t */",
            "\t\tif (ignore_state || ptrace_freeze_traced(child))",
            "\t\t\tret = 0;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tif (!ret && !ignore_state &&",
            "\t    WARN_ON_ONCE(!wait_task_inactive(child, __TASK_TRACED|TASK_FROZEN)))",
            "\t\tret = -ESRCH;",
            "",
            "\treturn ret;",
            "}",
            "static bool ptrace_has_cap(struct user_namespace *ns, unsigned int mode)",
            "{",
            "\tif (mode & PTRACE_MODE_NOAUDIT)",
            "\t\treturn ns_capable_noaudit(ns, CAP_SYS_PTRACE);",
            "\treturn ns_capable(ns, CAP_SYS_PTRACE);",
            "}",
            "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tconst struct cred *cred = current_cred(), *tcred;",
            "\tstruct mm_struct *mm;",
            "\tkuid_t caller_uid;",
            "\tkgid_t caller_gid;",
            "",
            "\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {",
            "\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* May we inspect the given task?",
            "\t * This check is used both for attaching with ptrace",
            "\t * and for allowing access to sensitive information in /proc.",
            "\t *",
            "\t * ptrace_attach denies several cases that /proc allows",
            "\t * because setting up the necessary parent/child relationship",
            "\t * or halting the specified task is impossible.",
            "\t */",
            "",
            "\t/* Don't let security modules deny introspection */",
            "\tif (same_thread_group(task, current))",
            "\t\treturn 0;",
            "\trcu_read_lock();",
            "\tif (mode & PTRACE_MODE_FSCREDS) {",
            "\t\tcaller_uid = cred->fsuid;",
            "\t\tcaller_gid = cred->fsgid;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Using the euid would make more sense here, but something",
            "\t\t * in userland might rely on the old behavior, and this",
            "\t\t * shouldn't be a security problem since",
            "\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly",
            "\t\t * used a syscall that requests access to another process",
            "\t\t * (and not a filesystem syscall to procfs).",
            "\t\t */",
            "\t\tcaller_uid = cred->uid;",
            "\t\tcaller_gid = cred->gid;",
            "\t}",
            "\ttcred = __task_cred(task);",
            "\tif (uid_eq(caller_uid, tcred->euid) &&",
            "\t    uid_eq(caller_uid, tcred->suid) &&",
            "\t    uid_eq(caller_uid, tcred->uid)  &&",
            "\t    gid_eq(caller_gid, tcred->egid) &&",
            "\t    gid_eq(caller_gid, tcred->sgid) &&",
            "\t    gid_eq(caller_gid, tcred->gid))",
            "\t\tgoto ok;",
            "\tif (ptrace_has_cap(tcred->user_ns, mode))",
            "\t\tgoto ok;",
            "\trcu_read_unlock();",
            "\treturn -EPERM;",
            "ok:",
            "\trcu_read_unlock();",
            "\t/*",
            "\t * If a task drops privileges and becomes nondumpable (through a syscall",
            "\t * like setresuid()) while we are trying to access it, we must ensure",
            "\t * that the dumpability is read after the credentials; otherwise,",
            "\t * we may be able to attach to a task that we shouldn't be able to",
            "\t * attach to (as if the task had dropped privileges without becoming",
            "\t * nondumpable).",
            "\t * Pairs with a write barrier in commit_creds().",
            "\t */",
            "\tsmp_rmb();",
            "\tmm = task->mm;",
            "\tif (mm &&",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptrace_has_cap(mm->user_ns, mode)))",
            "\t    return -EPERM;",
            "",
            "\treturn security_ptrace_access_check(task, mode);",
            "}"
          ],
          "function_name": "ptrace_freeze_traced, ptrace_unfreeze_traced, ptrace_check_attach, ptrace_has_cap, __ptrace_may_access",
          "description": "处理跟踪进程的冻结/解冻机制，检查附加合法性并验证能力权限，确保跟踪操作符合安全策略和内核状态约束。",
          "similarity": 0.5917259454727173
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/ptrace.c",
          "start_line": 501,
          "end_line": 618,
          "content": [
            "static int ptrace_traceme(void)",
            "{",
            "\tint ret = -EPERM;",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\t/* Are we already being traced? */",
            "\tif (!current->ptrace) {",
            "\t\tret = security_ptrace_traceme(current->parent);",
            "\t\t/*",
            "\t\t * Check PF_EXITING to ensure ->real_parent has not passed",
            "\t\t * exit_ptrace(). Otherwise we don't report the error but",
            "\t\t * pretend ->real_parent untraces us right after return.",
            "\t\t */",
            "\t\tif (!ret && !(current->real_parent->flags & PF_EXITING)) {",
            "\t\t\tcurrent->ptrace = PT_PTRACED;",
            "\t\t\tptrace_link(current, current->real_parent);",
            "\t\t}",
            "\t}",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\treturn ret;",
            "}",
            "static int ignoring_children(struct sighand_struct *sigh)",
            "{",
            "\tint ret;",
            "\tspin_lock(&sigh->siglock);",
            "\tret = (sigh->action[SIGCHLD-1].sa.sa_handler == SIG_IGN) ||",
            "\t      (sigh->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT);",
            "\tspin_unlock(&sigh->siglock);",
            "\treturn ret;",
            "}",
            "static bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)",
            "{",
            "\tbool dead;",
            "",
            "\t__ptrace_unlink(p);",
            "",
            "\tif (p->exit_state != EXIT_ZOMBIE)",
            "\t\treturn false;",
            "",
            "\tdead = !thread_group_leader(p);",
            "",
            "\tif (!dead && thread_group_empty(p)) {",
            "\t\tif (!same_thread_group(p->real_parent, tracer))",
            "\t\t\tdead = do_notify_parent(p, p->exit_signal);",
            "\t\telse if (ignoring_children(tracer->sighand)) {",
            "\t\t\t__wake_up_parent(p, tracer);",
            "\t\t\tdead = true;",
            "\t\t}",
            "\t}",
            "\t/* Mark it as in the process of being reaped. */",
            "\tif (dead)",
            "\t\tp->exit_state = EXIT_DEAD;",
            "\treturn dead;",
            "}",
            "static int ptrace_detach(struct task_struct *child, unsigned int data)",
            "{",
            "\tif (!valid_signal(data))",
            "\t\treturn -EIO;",
            "",
            "\t/* Architecture-specific hardware disable .. */",
            "\tptrace_disable(child);",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\t/*",
            "\t * We rely on ptrace_freeze_traced(). It can't be killed and",
            "\t * untraced by another thread, it can't be a zombie.",
            "\t */",
            "\tWARN_ON(!child->ptrace || child->exit_state);",
            "\t/*",
            "\t * tasklist_lock avoids the race with wait_task_stopped(), see",
            "\t * the comment in ptrace_resume().",
            "\t */",
            "\tchild->exit_code = data;",
            "\t__ptrace_detach(current, child);",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\tproc_ptrace_connector(child, PTRACE_DETACH);",
            "",
            "\treturn 0;",
            "}",
            "void exit_ptrace(struct task_struct *tracer, struct list_head *dead)",
            "{",
            "\tstruct task_struct *p, *n;",
            "",
            "\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {",
            "\t\tif (unlikely(p->ptrace & PT_EXITKILL))",
            "\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);",
            "",
            "\t\tif (__ptrace_detach(tracer, p))",
            "\t\t\tlist_add(&p->ptrace_entry, dead);",
            "\t}",
            "}",
            "int ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tretval = ptrace_access_vm(tsk, src, buf, this_len, FOLL_FORCE);",
            "",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tif (copy_to_user(dst, buf, retval))",
            "\t\t\treturn -EFAULT;",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}"
          ],
          "function_name": "ptrace_traceme, ignoring_children, __ptrace_detach, ptrace_detach, exit_ptrace, ptrace_readdata",
          "description": "完成跟踪关系建立与终止，包含被跟踪进程自我注册、子进程忽略信号检测、跟踪分离及资源释放逻辑，处理进程退出时的跟踪清理。",
          "similarity": 0.5900337100028992
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/ptrace.c",
          "start_line": 647,
          "end_line": 799,
          "content": [
            "int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tif (copy_from_user(buf, src, this_len))",
            "\t\t\treturn -EFAULT;",
            "\t\tretval = ptrace_access_vm(tsk, dst, buf, this_len,",
            "\t\t\t\tFOLL_FORCE | FOLL_WRITE);",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}",
            "static int ptrace_setoptions(struct task_struct *child, unsigned long data)",
            "{",
            "\tunsigned flags;",
            "\tint ret;",
            "",
            "\tret = check_ptrace_options(data);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* Avoid intermediate state when all opts are cleared */",
            "\tflags = child->ptrace;",
            "\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);",
            "\tflags |= (data << PT_OPT_FLAG_SHIFT);",
            "\tchild->ptrace = flags;",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(info, child->last_siginfo);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(child->last_siginfo, info);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_peek_siginfo(struct task_struct *child,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long data)",
            "{",
            "\tstruct ptrace_peeksiginfo_args arg;",
            "\tstruct sigpending *pending;",
            "\tstruct sigqueue *q;",
            "\tint ret, i;",
            "",
            "\tret = copy_from_user(&arg, (void __user *) addr,",
            "\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)",
            "\t\treturn -EINVAL; /* unknown flags */",
            "",
            "\tif (arg.nr < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure arg.off fits in an unsigned long */",
            "\tif (arg.off > ULONG_MAX)",
            "\t\treturn 0;",
            "",
            "\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)",
            "\t\tpending = &child->signal->shared_pending;",
            "\telse",
            "\t\tpending = &child->pending;",
            "",
            "\tfor (i = 0; i < arg.nr; ) {",
            "\t\tkernel_siginfo_t info;",
            "\t\tunsigned long off = arg.off + i;",
            "\t\tbool found = false;",
            "",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tlist_for_each_entry(q, &pending->list, list) {",
            "\t\t\tif (!off--) {",
            "\t\t\t\tfound = true;",
            "\t\t\t\tcopy_siginfo(&info, &q->info);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tif (!found) /* beyond the end of the list */",
            "\t\t\tbreak;",
            "",
            "#ifdef CONFIG_COMPAT",
            "\t\tif (unlikely(in_compat_syscall())) {",
            "\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);",
            "",
            "\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t} else",
            "#endif",
            "\t\t{",
            "\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;",
            "",
            "\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tdata += sizeof(siginfo_t);",
            "\t\ti++;",
            "",
            "\t\tif (signal_pending(current))",
            "\t\t\tbreak;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\tif (i > 0)",
            "\t\treturn i;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_writedata, ptrace_setoptions, ptrace_getsiginfo, ptrace_setsiginfo, ptrace_peek_siginfo",
          "description": "实现ptrace_writedata用于将数据写入被跟踪进程的内存，通过循环拷贝并处理错误；ptrace_setoptions用于更新跟踪选项标志位；ptrace_getsiginfo/ptrace_setsiginfo用于获取和设置进程的最后一个信号信息；ptrace_peek_siginfo用于遍历信号队列并复制信号信息到用户空间",
          "similarity": 0.5877898931503296
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_fprobe.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:24:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_fprobe.c`\n\n---\n\n# `trace_fprobe.c` 技术文档\n\n## 1. 文件概述\n\n`trace_fprobe.c` 是 Linux 内核动态追踪子系统的一部分，用于实现基于 **fprobe**（Function Probe）机制的动态追踪事件。该文件将 fprobe 与内核的通用追踪框架（如 `trace_event`、`dyn_event`）集成，支持在函数入口（entry）和/或返回（exit）处动态插入追踪点，并可采集函数参数、返回值、栈信息等上下文数据。它同时支持常规的 tracefs 接口追踪和 perf_events 性能事件接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct trace_fprobe`**  \n  核心结构体，封装了 fprobe、动态事件（`dyn_event`）、追踪探针（`trace_probe`）、符号信息、模块引用及可选的 tracepoint 引用，用于管理一个 fprobe 追踪事件实例。\n\n- **`struct dyn_event_operations trace_fprobe_ops`**  \n  实现动态事件操作接口，包括创建、显示、释放、忙状态检查和匹配逻辑，使 fprobe 事件能被统一管理。\n\n### 主要函数\n\n- **`trace_fprobe_create()`**  \n  解析用户命令（如通过 tracefs 写入），创建并注册新的 fprobe 追踪事件。\n\n- **`trace_fprobe_match()` / `trace_fprobe_match_command_head()`**  \n  实现事件匹配逻辑，用于根据系统名、事件名和参数查找对应的动态事件。\n\n- **`trace_fprobe_is_busy()`**  \n  判断 fprobe 事件是否处于启用状态（即是否被追踪或 perf 使用）。\n\n- **`process_fetch_insn()`**  \n  执行 fetch 指令，从寄存器、栈、函数参数或返回值中提取数据，供追踪记录使用。\n\n- **`fentry_trace_func()` / `__fentry_trace_func()`**  \n  函数入口追踪处理函数，当被探测函数被调用时触发，将入口信息写入追踪环形缓冲区。\n\n- **`trace_fprobe_entry_handler()`**  \n  fprobe 入口回调，用于在函数入口处保存入口数据（如参数），供后续 exit 处理使用。\n\n- **`fexit_trace_func()` / `__fexit_trace_func()`**  \n  函数返回追踪处理函数，在函数返回时触发，记录入口地址、返回地址及上下文数据。\n\n- **`fentry_perf_func()`**（仅当 `CONFIG_PERF_EVENTS` 启用）  \n  支持 perf_events 接口的入口追踪处理，将数据提交给 perf 子系统。\n\n## 3. 关键实现\n\n### 动态事件集成\n- 通过 `dyn_event` 框架注册 `trace_fprobe_ops`，使 fprobe 事件可被 `tracefs` 的 `dyn_events` 接口统一管理（如创建、删除、列出）。\n- 使用 `for_each_trace_fprobe` 宏遍历所有 fprobe 类型的动态事件。\n\n### fprobe 与 trace_probe 融合\n- `trace_fprobe` 结构体同时包含 `fprobe`（用于函数探测）和 `trace_probe`（用于参数提取和事件定义），实现探测逻辑与数据采集逻辑的解耦。\n- 支持 entry-only 和 entry/exit（return）两种模式，通过 `fp.exit_handler` 是否为 NULL 判断。\n\n### 数据采集机制\n- `process_fetch_insn()` 支持多种数据源：\n  - `FETCH_OP_STACK`：从内核栈获取指定偏移的数据。\n  - `FETCH_OP_STACKP`：获取当前栈指针。\n  - `FETCH_OP_RETVAL`：获取函数返回值（仅 exit 时有效）。\n  - `FETCH_OP_ARG`（需 `CONFIG_HAVE_FUNCTION_ARG_ACCESS_API`）：获取函数参数。\n  - `FETCH_OP_EDATA`：访问入口处理时保存的私有数据（用于 exit 时关联 entry 数据）。\n- 数据通过 `store_trace_args()` 存储到追踪事件缓冲区。\n\n### 追踪路径分离\n- **tracefs 路径**：通过 `trace_event_buffer_reserve/commit` 将数据写入 ftrace 环形缓冲区。\n- **perf 路径**：通过 `perf_trace_buf_alloc/submit` 将数据提交给 perf 子系统（条件编译）。\n\n### 安全与稳定性\n- 所有核心处理函数标记为 `NOKPROBE_SYMBOL`，防止在 kprobe 上下文中被递归探测。\n- 使用 RCU 保护事件文件链接遍历（`trace_probe_for_each_link_rcu`）。\n- 对 `trace_file` 的 event_call 进行 `WARN_ON_ONCE` 校验，确保一致性。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/fprobe.h>`：提供 fprobe 注册/注销及回调机制。\n  - `\"trace_probe.h\"` / `\"trace_probe_kernel.h\"`：提供通用探针数据结构、参数解析和存储逻辑。\n  - `\"trace_dynevent.h\"`：动态事件管理框架。\n  - `<linux/tracepoint.h>`：支持将 fprobe 与 tracepoint 关联（用于特殊场景）。\n- **可选依赖**：\n  - `CONFIG_PERF_EVENTS`：启用 perf_events 支持。\n  - `CONFIG_HAVE_FUNCTION_ARG_ACCESS_API`：启用函数参数访问能力。\n- **架构依赖**：\n  - `<asm/ptrace.h>`：访问寄存器和栈的架构相关接口（如 `regs_get_kernel_argument`）。\n\n## 5. 使用场景\n\n- **动态函数追踪**：用户可通过 tracefs 接口（如 `echo 'p:myprobe do_sys_open' > /sys/kernel/tracing/dynevents`）动态在任意内核函数入口/出口插入追踪点，无需重新编译内核。\n- **性能分析**：结合 perf 工具，对特定函数的调用频率、延迟、参数分布进行采样分析。\n- **调试与诊断**：在生产环境中临时启用函数级追踪，捕获函数调用上下文（如参数、返回值、调用栈），用于定位复杂问题。\n- **安全监控**：监控敏感内核函数（如系统调用、内存管理函数）的调用行为，检测异常活动。",
      "similarity": 0.645905077457428,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_fprobe.c",
          "start_line": 207,
          "end_line": 327,
          "content": [
            "static void",
            "fentry_trace_func(struct trace_fprobe *tf, unsigned long entry_ip,",
            "\t\t  struct ftrace_regs *fregs)",
            "{",
            "\tstruct event_file_link *link;",
            "",
            "\ttrace_probe_for_each_link_rcu(link, &tf->tp)",
            "\t\t__fentry_trace_func(tf, entry_ip, fregs, link->file);",
            "}",
            "static nokprobe_inline",
            "void store_fprobe_entry_data(void *edata, struct trace_probe *tp, struct ftrace_regs *fregs)",
            "{",
            "\tstruct probe_entry_arg *earg = tp->entry_arg;",
            "\tunsigned long val = 0;",
            "\tint i;",
            "",
            "\tif (!earg)",
            "\t\treturn;",
            "",
            "\tfor (i = 0; i < earg->size; i++) {",
            "\t\tstruct fetch_insn *code = &earg->code[i];",
            "",
            "\t\tswitch (code->op) {",
            "\t\tcase FETCH_OP_ARG:",
            "\t\t\tval = ftrace_regs_get_argument(fregs, code->param);",
            "\t\t\tbreak;",
            "\t\tcase FETCH_OP_ST_EDATA:",
            "\t\t\t*(unsigned long *)((unsigned long)edata + code->offset) = val;",
            "\t\t\tbreak;",
            "\t\tcase FETCH_OP_END:",
            "\t\t\tgoto end;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "end:",
            "\treturn;",
            "}",
            "static int trace_fprobe_entry_handler(struct fprobe *fp, unsigned long entry_ip,",
            "\t\t\t\tunsigned long ret_ip, struct ftrace_regs *fregs,",
            "\t\t\t\tvoid *entry_data)",
            "{",
            "\tstruct trace_fprobe *tf = container_of(fp, struct trace_fprobe, fp);",
            "",
            "\tif (tf->tp.entry_arg)",
            "\t\tstore_fprobe_entry_data(entry_data, &tf->tp, fregs);",
            "",
            "\treturn 0;",
            "}",
            "static nokprobe_inline void",
            "__fexit_trace_func(struct trace_fprobe *tf, unsigned long entry_ip,",
            "\t\t   unsigned long ret_ip, struct ftrace_regs *fregs,",
            "\t\t   void *entry_data, struct trace_event_file *trace_file)",
            "{",
            "\tstruct fexit_trace_entry_head *entry;",
            "\tstruct trace_event_buffer fbuffer;",
            "\tstruct trace_event_call *call = trace_probe_event_call(&tf->tp);",
            "\tint dsize;",
            "",
            "\tif (WARN_ON_ONCE(call != trace_file->event_call))",
            "\t\treturn;",
            "",
            "\tif (trace_trigger_soft_disabled(trace_file))",
            "\t\treturn;",
            "",
            "\tdsize = __get_data_size(&tf->tp, fregs, entry_data);",
            "",
            "\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,",
            "\t\t\t\t\t   sizeof(*entry) + tf->tp.size + dsize);",
            "\tif (!entry)",
            "\t\treturn;",
            "",
            "\tfbuffer.regs = ftrace_get_regs(fregs);",
            "\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);",
            "\tentry->func = entry_ip;",
            "\tentry->ret_ip = ret_ip;",
            "\tstore_trace_args(&entry[1], &tf->tp, fregs, entry_data, sizeof(*entry), dsize);",
            "",
            "\ttrace_event_buffer_commit(&fbuffer);",
            "}",
            "static void",
            "fexit_trace_func(struct trace_fprobe *tf, unsigned long entry_ip,",
            "\t\t unsigned long ret_ip, struct ftrace_regs *fregs, void *entry_data)",
            "{",
            "\tstruct event_file_link *link;",
            "",
            "\ttrace_probe_for_each_link_rcu(link, &tf->tp)",
            "\t\t__fexit_trace_func(tf, entry_ip, ret_ip, fregs, entry_data, link->file);",
            "}",
            "static int fentry_perf_func(struct trace_fprobe *tf, unsigned long entry_ip,",
            "\t\t\t    struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_event_call *call = trace_probe_event_call(&tf->tp);",
            "\tstruct fentry_trace_entry_head *entry;",
            "\tstruct hlist_head *head;",
            "\tint size, __size, dsize;",
            "\tstruct pt_regs *regs;",
            "\tint rctx;",
            "",
            "\thead = this_cpu_ptr(call->perf_events);",
            "\tif (hlist_empty(head))",
            "\t\treturn 0;",
            "",
            "\tdsize = __get_data_size(&tf->tp, fregs, NULL);",
            "\t__size = sizeof(*entry) + tf->tp.size + dsize;",
            "\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));",
            "\tsize -= sizeof(u32);",
            "",
            "\tentry = perf_trace_buf_alloc(size, &regs, &rctx);",
            "\tif (!entry)",
            "\t\treturn 0;",
            "",
            "\tregs = ftrace_fill_perf_regs(fregs, regs);",
            "",
            "\tentry->ip = entry_ip;",
            "\tmemset(&entry[1], 0, dsize);",
            "\tstore_trace_args(&entry[1], &tf->tp, fregs, NULL, sizeof(*entry), dsize);",
            "\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,",
            "\t\t\t      head, NULL);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "fentry_trace_func, store_fprobe_entry_data, trace_fprobe_entry_handler, __fexit_trace_func, fexit_trace_func, fentry_perf_func",
          "description": "实现入口/出口事件的具体处理流程，包括数据存储、探针回调注册及perf事件支持，通过dispatch机制将事件分发至不同追踪路径（trace/tracepoint/perf）。",
          "similarity": 0.63279128074646
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_fprobe.c",
          "start_line": 53,
          "end_line": 172,
          "content": [
            "static bool is_trace_fprobe(struct dyn_event *ev)",
            "{",
            "\treturn ev->ops == &trace_fprobe_ops;",
            "}",
            "static bool trace_fprobe_is_return(struct trace_fprobe *tf)",
            "{",
            "\treturn tf->fp.exit_handler != NULL;",
            "}",
            "static bool trace_fprobe_is_tracepoint(struct trace_fprobe *tf)",
            "{",
            "\treturn tf->tpoint != NULL;",
            "}",
            "static bool trace_fprobe_is_busy(struct dyn_event *ev)",
            "{",
            "\tstruct trace_fprobe *tf = to_trace_fprobe(ev);",
            "",
            "\treturn trace_probe_is_enabled(&tf->tp);",
            "}",
            "static bool trace_fprobe_match_command_head(struct trace_fprobe *tf,",
            "\t\t\t\t\t    int argc, const char **argv)",
            "{",
            "\tchar buf[MAX_ARGSTR_LEN + 1];",
            "",
            "\tif (!argc)",
            "\t\treturn true;",
            "",
            "\tsnprintf(buf, sizeof(buf), \"%s\", trace_fprobe_symbol(tf));",
            "\tif (strcmp(buf, argv[0]))",
            "\t\treturn false;",
            "\targc--; argv++;",
            "",
            "\treturn trace_probe_match_command_args(&tf->tp, argc, argv);",
            "}",
            "static bool trace_fprobe_match(const char *system, const char *event,",
            "\t\t\tint argc, const char **argv, struct dyn_event *ev)",
            "{",
            "\tstruct trace_fprobe *tf = to_trace_fprobe(ev);",
            "",
            "\tif (event[0] != '\\0' && strcmp(trace_probe_name(&tf->tp), event))",
            "\t\treturn false;",
            "",
            "\tif (system && strcmp(trace_probe_group_name(&tf->tp), system))",
            "\t\treturn false;",
            "",
            "\treturn trace_fprobe_match_command_head(tf, argc, argv);",
            "}",
            "static bool trace_fprobe_is_registered(struct trace_fprobe *tf)",
            "{",
            "\treturn fprobe_is_registered(&tf->fp);",
            "}",
            "static int",
            "process_fetch_insn(struct fetch_insn *code, void *rec, void *edata,",
            "\t\t   void *dest, void *base)",
            "{",
            "\tstruct ftrace_regs *fregs = rec;",
            "\tunsigned long val;",
            "\tint ret;",
            "",
            "retry:",
            "\t/* 1st stage: get value from context */",
            "\tswitch (code->op) {",
            "\tcase FETCH_OP_STACK:",
            "\t\tval = ftrace_regs_get_kernel_stack_nth(fregs, code->param);",
            "\t\tbreak;",
            "\tcase FETCH_OP_STACKP:",
            "\t\tval = ftrace_regs_get_stack_pointer(fregs);",
            "\t\tbreak;",
            "\tcase FETCH_OP_RETVAL:",
            "\t\tval = ftrace_regs_get_return_value(fregs);",
            "\t\tbreak;",
            "#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API",
            "\tcase FETCH_OP_ARG:",
            "\t\tval = ftrace_regs_get_argument(fregs, code->param);",
            "\t\tbreak;",
            "\tcase FETCH_OP_EDATA:",
            "\t\tval = *(unsigned long *)((unsigned long)edata + code->offset);",
            "\t\tbreak;",
            "#endif",
            "\tcase FETCH_NOP_SYMBOL:\t/* Ignore a place holder */",
            "\t\tcode++;",
            "\t\tgoto retry;",
            "\tdefault:",
            "\t\tret = process_common_fetch_insn(code, &val);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t}",
            "\tcode++;",
            "",
            "\treturn process_fetch_insn_bottom(code, val, dest, base);",
            "}",
            "static nokprobe_inline void",
            "__fentry_trace_func(struct trace_fprobe *tf, unsigned long entry_ip,",
            "\t\t    struct ftrace_regs *fregs,",
            "\t\t    struct trace_event_file *trace_file)",
            "{",
            "\tstruct fentry_trace_entry_head *entry;",
            "\tstruct trace_event_call *call = trace_probe_event_call(&tf->tp);",
            "\tstruct trace_event_buffer fbuffer;",
            "\tint dsize;",
            "",
            "\tif (WARN_ON_ONCE(call != trace_file->event_call))",
            "\t\treturn;",
            "",
            "\tif (trace_trigger_soft_disabled(trace_file))",
            "\t\treturn;",
            "",
            "\tdsize = __get_data_size(&tf->tp, fregs, NULL);",
            "",
            "\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,",
            "\t\t\t\t\t   sizeof(*entry) + tf->tp.size + dsize);",
            "\tif (!entry)",
            "\t\treturn;",
            "",
            "\tfbuffer.regs = ftrace_get_regs(fregs);",
            "\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);",
            "\tentry->ip = entry_ip;",
            "\tstore_trace_args(&entry[1], &tf->tp, fregs, NULL, sizeof(*entry), dsize);",
            "",
            "\ttrace_event_buffer_commit(&fbuffer);",
            "}"
          ],
          "function_name": "is_trace_fprobe, trace_fprobe_is_return, trace_fprobe_is_tracepoint, trace_fprobe_is_busy, trace_fprobe_match_command_head, trace_fprobe_match, trace_fprobe_is_registered, process_fetch_insn, __fentry_trace_func",
          "description": "实现FProbe事件匹配、busy状态检测及指令提取逻辑，包含入口和出口事件处理函数，支持通过fetch_insn获取上下文数据并填充trace缓冲区。",
          "similarity": 0.5980522632598877
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/trace/trace_fprobe.c",
          "start_line": 1074,
          "end_line": 1259,
          "content": [
            "static int __trace_fprobe_create(int argc, const char *argv[])",
            "{",
            "\t/*",
            "\t * Argument syntax:",
            "\t *  - Add fentry probe:",
            "\t *      f[:[GRP/][EVENT]] [MOD:]KSYM [FETCHARGS]",
            "\t *  - Add fexit probe:",
            "\t *      f[N][:[GRP/][EVENT]] [MOD:]KSYM%return [FETCHARGS]",
            "\t *  - Add tracepoint probe:",
            "\t *      t[:[GRP/][EVENT]] TRACEPOINT [FETCHARGS]",
            "\t *",
            "\t * Fetch args:",
            "\t *  $retval\t: fetch return value",
            "\t *  $stack\t: fetch stack address",
            "\t *  $stackN\t: fetch Nth entry of stack (N:0-)",
            "\t *  $argN\t: fetch Nth argument (N:1-)",
            "\t *  $comm       : fetch current task comm",
            "\t *  @ADDR\t: fetch memory at ADDR (ADDR should be in kernel)",
            "\t *  @SYM[+|-offs] : fetch memory at SYM +|- offs (SYM is a data symbol)",
            "\t * Dereferencing memory fetch:",
            "\t *  +|-offs(ARG) : fetch memory at ARG +|- offs address.",
            "\t * Alias name of args:",
            "\t *  NAME=FETCHARG : set NAME as alias of FETCHARG.",
            "\t * Type of args:",
            "\t *  FETCHARG:TYPE : use TYPE instead of unsigned long.",
            "\t */",
            "\tstruct trace_fprobe *tf = NULL;",
            "\tint i, new_argc = 0, ret = 0;",
            "\tbool is_return = false;",
            "\tchar *symbol = NULL;",
            "\tconst char *event = NULL, *group = FPROBE_EVENT_SYSTEM;",
            "\tconst char **new_argv = NULL;",
            "\tchar buf[MAX_EVENT_NAME_LEN];",
            "\tchar gbuf[MAX_EVENT_NAME_LEN];",
            "\tchar sbuf[KSYM_NAME_LEN];",
            "\tchar abuf[MAX_BTF_ARGS_LEN];",
            "\tbool is_tracepoint = false;",
            "\tstruct module *tp_mod = NULL;",
            "\tstruct tracepoint *tpoint = NULL;",
            "\tstruct traceprobe_parse_context ctx = {",
            "\t\t.flags = TPARG_FL_KERNEL | TPARG_FL_FPROBE,",
            "\t};",
            "",
            "\tif ((argv[0][0] != 'f' && argv[0][0] != 't') || argc < 2)",
            "\t\treturn -ECANCELED;",
            "",
            "\tif (argv[0][0] == 't') {",
            "\t\tis_tracepoint = true;",
            "\t\tgroup = TRACEPOINT_EVENT_SYSTEM;",
            "\t}",
            "",
            "\ttrace_probe_log_init(\"trace_fprobe\", argc, argv);",
            "",
            "\tif (argv[0][1] != '\\0') {",
            "\t\tif (argv[0][1] != ':') {",
            "\t\t\ttrace_probe_log_set_index(0);",
            "\t\t\ttrace_probe_log_err(1, BAD_MAXACT);",
            "\t\t\tgoto parse_error;",
            "\t\t}",
            "\t\tevent = &argv[0][2];",
            "\t}",
            "",
            "\ttrace_probe_log_set_index(1);",
            "",
            "\t/* a symbol(or tracepoint) must be specified */",
            "\tret = parse_symbol_and_return(argc, argv, &symbol, &is_return, is_tracepoint);",
            "\tif (ret < 0)",
            "\t\tgoto parse_error;",
            "",
            "\ttrace_probe_log_set_index(0);",
            "\tif (event) {",
            "\t\tret = traceprobe_parse_event_name(&event, &group, gbuf,",
            "\t\t\t\t\t\t  event - argv[0]);",
            "\t\tif (ret)",
            "\t\t\tgoto parse_error;",
            "\t}",
            "",
            "\tif (!event) {",
            "\t\t/* Make a new event name */",
            "\t\tif (is_tracepoint)",
            "\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%s%s\",",
            "\t\t\t\t isdigit(*symbol) ? \"_\" : \"\", symbol);",
            "\t\telse",
            "\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%s__%s\", symbol,",
            "\t\t\t\t is_return ? \"exit\" : \"entry\");",
            "\t\tsanitize_event_name(buf);",
            "\t\tevent = buf;",
            "\t}",
            "",
            "\tif (is_return)",
            "\t\tctx.flags |= TPARG_FL_RETURN;",
            "\telse",
            "\t\tctx.flags |= TPARG_FL_FENTRY;",
            "",
            "\tif (is_tracepoint) {",
            "\t\tctx.flags |= TPARG_FL_TPOINT;",
            "\t\ttpoint = find_tracepoint(symbol, &tp_mod);",
            "\t\tif (tpoint) {",
            "\t\t\tctx.funcname = kallsyms_lookup(",
            "\t\t\t\t(unsigned long)tpoint->probestub,",
            "\t\t\t\tNULL, NULL, NULL, sbuf);",
            "\t\t} else if (IS_ENABLED(CONFIG_MODULES)) {",
            "\t\t\t\t/* This *may* be loaded afterwards */",
            "\t\t\t\ttpoint = TRACEPOINT_STUB;",
            "\t\t\t\tctx.funcname = symbol;",
            "\t\t} else {",
            "\t\t\ttrace_probe_log_set_index(1);",
            "\t\t\ttrace_probe_log_err(0, NO_TRACEPOINT);",
            "\t\t\tgoto parse_error;",
            "\t\t}",
            "\t} else",
            "\t\tctx.funcname = symbol;",
            "",
            "\targc -= 2; argv += 2;",
            "\tnew_argv = traceprobe_expand_meta_args(argc, argv, &new_argc,",
            "\t\t\t\t\t       abuf, MAX_BTF_ARGS_LEN, &ctx);",
            "\tif (IS_ERR(new_argv)) {",
            "\t\tret = PTR_ERR(new_argv);",
            "\t\tnew_argv = NULL;",
            "\t\tgoto out;",
            "\t}",
            "\tif (new_argv) {",
            "\t\targc = new_argc;",
            "\t\targv = new_argv;",
            "\t}",
            "\tif (argc > MAX_TRACE_ARGS) {",
            "\t\tret = -E2BIG;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* setup a probe */",
            "\ttf = alloc_trace_fprobe(group, event, symbol, tpoint, tp_mod,",
            "\t\t\t\targc, is_return);",
            "\tif (IS_ERR(tf)) {",
            "\t\tret = PTR_ERR(tf);",
            "\t\t/* This must return -ENOMEM, else there is a bug */",
            "\t\tWARN_ON_ONCE(ret != -ENOMEM);",
            "\t\tgoto out;\t/* We know tf is not allocated */",
            "\t}",
            "",
            "\t/* parse arguments */",
            "\tfor (i = 0; i < argc; i++) {",
            "\t\ttrace_probe_log_set_index(i + 2);",
            "\t\tctx.offset = 0;",
            "\t\tret = traceprobe_parse_probe_arg(&tf->tp, i, argv[i], &ctx);",
            "\t\tif (ret)",
            "\t\t\tgoto error;\t/* This can be -ENOMEM */",
            "\t}",
            "",
            "\tif (is_return && tf->tp.entry_arg) {",
            "\t\ttf->fp.entry_handler = trace_fprobe_entry_handler;",
            "\t\ttf->fp.entry_data_size = traceprobe_get_entry_data_size(&tf->tp);",
            "\t}",
            "",
            "\tret = traceprobe_set_print_fmt(&tf->tp,",
            "\t\t\tis_return ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL);",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "",
            "\tret = register_trace_fprobe(tf);",
            "\tif (ret) {",
            "\t\ttrace_probe_log_set_index(1);",
            "\t\tif (ret == -EILSEQ)",
            "\t\t\ttrace_probe_log_err(0, BAD_INSN_BNDRY);",
            "\t\telse if (ret == -ENOENT)",
            "\t\t\ttrace_probe_log_err(0, BAD_PROBE_ADDR);",
            "\t\telse if (ret != -ENOMEM && ret != -EEXIST)",
            "\t\t\ttrace_probe_log_err(0, FAIL_REG_PROBE);",
            "\t\tgoto error;",
            "\t}",
            "",
            "out:",
            "\tif (tp_mod)",
            "\t\tmodule_put(tp_mod);",
            "\ttraceprobe_finish_parse(&ctx);",
            "\ttrace_probe_log_clear();",
            "\tkfree(new_argv);",
            "\tkfree(symbol);",
            "\treturn ret;",
            "",
            "parse_error:",
            "\tret = -EINVAL;",
            "error:",
            "\tfree_trace_fprobe(tf);",
            "\tgoto out;",
            "}"
          ],
          "function_name": "__trace_fprobe_create",
          "description": "解析fprobe命令行参数，构建trace_fprobe结构体，设置事件名称和参数，完成探针创建流程",
          "similarity": 0.5743117332458496
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_fprobe.c",
          "start_line": 1,
          "end_line": 52,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Fprobe-based tracing events",
            " * Copyright (C) 2022 Google LLC.",
            " */",
            "#define pr_fmt(fmt)\t\"trace_fprobe: \" fmt",
            "#include <asm/ptrace.h>",
            "",
            "#include <linux/fprobe.h>",
            "#include <linux/module.h>",
            "#include <linux/rculist.h>",
            "#include <linux/security.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include \"trace_dynevent.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_probe_kernel.h\"",
            "#include \"trace_probe_tmpl.h\"",
            "",
            "#define FPROBE_EVENT_SYSTEM \"fprobes\"",
            "#define TRACEPOINT_EVENT_SYSTEM \"tracepoints\"",
            "#define RETHOOK_MAXACTIVE_MAX 4096",
            "#define TRACEPOINT_STUB ERR_PTR(-ENOENT)",
            "",
            "static int trace_fprobe_create(const char *raw_command);",
            "static int trace_fprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_fprobe_release(struct dyn_event *ev);",
            "static bool trace_fprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_fprobe_match(const char *system, const char *event,",
            "\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "",
            "static struct dyn_event_operations trace_fprobe_ops = {",
            "\t.create = trace_fprobe_create,",
            "\t.show = trace_fprobe_show,",
            "\t.is_busy = trace_fprobe_is_busy,",
            "\t.free = trace_fprobe_release,",
            "\t.match = trace_fprobe_match,",
            "};",
            "",
            "/*",
            " * Fprobe event core functions",
            " */",
            "struct trace_fprobe {",
            "\tstruct dyn_event\tdevent;",
            "\tstruct fprobe\t\tfp;",
            "\tconst char\t\t*symbol;",
            "\tstruct tracepoint\t*tpoint;",
            "\tstruct module\t\t*mod;",
            "\tstruct trace_probe\ttp;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义FProbe事件的核心结构和操作接口，包含动态事件操作函数声明及trace_fprobe结构体，用于管理基于fprobe的跟踪事件。",
          "similarity": 0.5700812935829163
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/trace/trace_fprobe.c",
          "start_line": 1261,
          "end_line": 1335,
          "content": [
            "static int trace_fprobe_create(const char *raw_command)",
            "{",
            "\treturn trace_probe_create(raw_command, __trace_fprobe_create);",
            "}",
            "static int trace_fprobe_release(struct dyn_event *ev)",
            "{",
            "\tstruct trace_fprobe *tf = to_trace_fprobe(ev);",
            "\tint ret = unregister_trace_fprobe(tf);",
            "",
            "\tif (!ret)",
            "\t\tfree_trace_fprobe(tf);",
            "\treturn ret;",
            "}",
            "static int trace_fprobe_show(struct seq_file *m, struct dyn_event *ev)",
            "{",
            "\tstruct trace_fprobe *tf = to_trace_fprobe(ev);",
            "\tint i;",
            "",
            "\tif (trace_fprobe_is_tracepoint(tf))",
            "\t\tseq_putc(m, 't');",
            "\telse",
            "\t\tseq_putc(m, 'f');",
            "\tseq_printf(m, \":%s/%s\", trace_probe_group_name(&tf->tp),",
            "\t\t\t\ttrace_probe_name(&tf->tp));",
            "",
            "\tseq_printf(m, \" %s%s\", trace_fprobe_symbol(tf),",
            "\t\t\t       trace_fprobe_is_return(tf) ? \"%return\" : \"\");",
            "",
            "\tfor (i = 0; i < tf->tp.nr_args; i++)",
            "\t\tseq_printf(m, \" %s=%s\", tf->tp.args[i].name, tf->tp.args[i].comm);",
            "\tseq_putc(m, '\\n');",
            "",
            "\treturn 0;",
            "}",
            "static int fprobe_register(struct trace_event_call *event,",
            "\t\t\t   enum trace_reg type, void *data)",
            "{",
            "\tstruct trace_event_file *file = data;",
            "",
            "\tswitch (type) {",
            "\tcase TRACE_REG_REGISTER:",
            "\t\treturn enable_trace_fprobe(event, file);",
            "\tcase TRACE_REG_UNREGISTER:",
            "\t\treturn disable_trace_fprobe(event, file);",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "\tcase TRACE_REG_PERF_REGISTER:",
            "\t\treturn enable_trace_fprobe(event, NULL);",
            "\tcase TRACE_REG_PERF_UNREGISTER:",
            "\t\treturn disable_trace_fprobe(event, NULL);",
            "\tcase TRACE_REG_PERF_OPEN:",
            "\tcase TRACE_REG_PERF_CLOSE:",
            "\tcase TRACE_REG_PERF_ADD:",
            "\tcase TRACE_REG_PERF_DEL:",
            "\t\treturn 0;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}",
            "static __init int init_fprobe_trace_early(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = dyn_event_register(&trace_fprobe_ops);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "#ifdef CONFIG_MODULES",
            "\tret = register_tracepoint_module_notifier(&tracepoint_module_nb);",
            "\tif (ret)",
            "\t\treturn ret;",
            "#endif",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "trace_fprobe_create, trace_fprobe_release, trace_fprobe_show, fprobe_register, init_fprobe_trace_early",
          "description": "实现fprobe动态事件创建与释放接口，提供探针展示功能，注册trace_event回调及早期初始化入口",
          "similarity": 0.5645990371704102
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_sched_wakeup.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:35:56\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_sched_wakeup.c`\n\n---\n\n# `trace_sched_wakeup.c` 技术文档\n\n## 1. 文件概述\n\n`trace_sched_wakeup.c` 是 Linux 内核中用于追踪任务唤醒延迟（wakeup latency）的关键调度器跟踪模块。该文件实现了 **wakeup tracer**，用于记录从一个高优先级任务被唤醒（例如通过 `wake_up_process()`）到它实际获得 CPU 执行之间的时间延迟。该 tracer 主要用于实时系统性能分析和调度延迟调试，是内核 ftrace 框架的一部分。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `wakeup_trace`：指向当前 wakeup tracer 实例的 `struct trace_array`。\n- `tracer_enabled`：标记 tracer 是否启用。\n- `wakeup_task`：当前被追踪唤醒的目标任务。\n- `wakeup_cpu` / `wakeup_current_cpu`：记录目标任务所在 CPU 和当前执行 CPU。\n- `wakeup_prio`：目标任务的优先级（初始为 -1 表示无效）。\n- `wakeup_rt` / `wakeup_dl` / `tracing_dl`：标志位，分别表示是否为实时任务（RT）、截止时间任务（Deadline）以及是否正在追踪 Deadline 任务。\n- `wakeup_lock`：用于保护关键数据结构的自旋锁。\n\n### 主要函数\n- `func_prolog_preempt_disable()`：函数追踪的前置处理，用于判断是否应记录当前函数调用，并禁用抢占。\n- `wakeup_tracer_call()`：函数追踪回调函数，记录函数调用事件。\n- `wakeup_graph_entry()` / `wakeup_graph_return()`：函数图追踪（function graph tracer）的入口和返回钩子。\n- `register_wakeup_function()` / `unregister_wakeup_function()`：注册/注销函数追踪回调。\n- `wakeup_function_set()`：处理 `TRACE_ITER_FUNCTION` 标志变更。\n- `wakeup_flag_changed()`：处理 tracer 标志变化（如启用函数追踪或函数图追踪）。\n- `wakeup_print_line()` / `wakeup_print_header()`：格式化输出追踪结果。\n- `wakeup_trace_open()` / `wakeup_trace_close()`：追踪迭代器的打开/关闭回调。\n\n### 回调结构体\n- `fgraph_wakeup_ops`：定义了用于函数图追踪的入口和返回回调函数。\n\n## 3. 关键实现\n\n### 唤醒追踪机制\n- 当一个高优先级任务被唤醒时，wakeup tracer 会记录该任务信息（`wakeup_task`、`wakeup_prio`、CPU 等）。\n- 在后续调度过程中，tracer 会追踪从唤醒点到该任务实际运行之间的所有函数调用（如果启用了函数追踪）。\n- 通过比较时间戳，可计算出唤醒延迟（latency），并记录最大延迟值（`tr->max_latency`）。\n\n### 函数追踪集成\n- 若启用 `CONFIG_FUNCTION_TRACER`，tracer 会注册 `wakeup_tracer_call` 作为函数追踪回调。\n- 若同时启用 `CONFIG_FUNCTION_GRAPH_TRACER`，则使用 `fgraph_wakeup_ops` 实现函数调用图追踪，记录完整的调用栈。\n- 使用 `func_prolog_preempt_disable()` 确保只在追踪目标 CPU 上记录，并通过 `data->disabled` 原子计数防止嵌套追踪。\n\n### 并发与抢占控制\n- 使用 `preempt_disable_notrace()` 禁用抢占以保证追踪上下文一致性。\n- 使用 `local_irq_save/restore()` 保护关键追踪路径。\n- 通过 `arch_spinlock_t wakeup_lock` 保护共享状态（虽在代码片段中未直接使用，但为全局同步预留）。\n\n### 动态追踪模式切换\n- 支持在运行时切换普通函数追踪与函数图追踪模式（通过 `TRACE_ITER_DISPLAY_GRAPH` 标志）。\n- 切换时会重置追踪状态（`wakeup_reset`）并重新注册对应的追踪回调。\n\n## 4. 依赖关系\n\n- **ftrace 框架**：依赖 `ftrace.h` 提供的函数追踪基础设施。\n- **调度子系统**：通过 `trace/events/sched.h` 接收任务唤醒事件（如 `sched_wakeup`、`sched_wakeup_new`）。\n- **实时调度类**：包含对 `SCHED_FIFO`/`SCHED_RR`（RT）和 `SCHED_DEADLINE` 调度策略的特殊处理。\n- **函数图追踪**：若启用 `CONFIG_FUNCTION_GRAPH_TRACER`，依赖其回调机制和栈管理。\n- **内核符号解析**：通过 `kallsyms.h` 支持函数名解析（间接依赖）。\n\n## 5. 使用场景\n\n- **实时系统延迟分析**：用于测量高优先级 RT 或 Deadline 任务从唤醒到执行的延迟，验证系统是否满足实时性要求。\n- **调度器调试**：帮助开发者分析调度延迟来源，如中断处理、锁竞争、低优先级任务占用 CPU 等。\n- **性能调优**：结合函数追踪或函数图追踪，定位导致唤醒延迟的具体代码路径。\n- **内核测试**：作为 `ftrace` 的标准 tracer 之一，可通过 `/sys/kernel/debug/tracing/current_tracer` 设置为 `wakeup` 或 `wakeup_rt` 进行测试。",
      "similarity": 0.6386418342590332,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 445,
          "end_line": 613,
          "content": [
            "static void notrace",
            "probe_wakeup_sched_switch(void *ignore, bool preempt,",
            "\t\t\t  struct task_struct *prev, struct task_struct *next,",
            "\t\t\t  unsigned int prev_state)",
            "{",
            "\tstruct trace_array_cpu *data;",
            "\tu64 T0, T1, delta;",
            "\tunsigned long flags;",
            "\tlong disabled;",
            "\tint cpu;",
            "\tunsigned int trace_ctx;",
            "",
            "\ttracing_record_cmdline(prev);",
            "",
            "\tif (unlikely(!tracer_enabled))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * When we start a new trace, we set wakeup_task to NULL",
            "\t * and then set tracer_enabled = 1. We want to make sure",
            "\t * that another CPU does not see the tracer_enabled = 1",
            "\t * and the wakeup_task with an older task, that might",
            "\t * actually be the same as next.",
            "\t */",
            "\tsmp_rmb();",
            "",
            "\tif (next != wakeup_task)",
            "\t\treturn;",
            "",
            "\t/* disable local data, not wakeup_cpu data */",
            "\tcpu = raw_smp_processor_id();",
            "\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "\tif (likely(disabled != 1))",
            "\t\tgoto out;",
            "",
            "\tlocal_irq_save(flags);",
            "\ttrace_ctx = tracing_gen_ctx_flags(flags);",
            "",
            "\tarch_spin_lock(&wakeup_lock);",
            "",
            "\t/* We could race with grabbing wakeup_lock */",
            "\tif (unlikely(!tracer_enabled || next != wakeup_task))",
            "\t\tgoto out_unlock;",
            "",
            "\t/* The task we are waiting for is waking up */",
            "\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);",
            "",
            "\t__trace_function(wakeup_trace, CALLER_ADDR0, CALLER_ADDR1, trace_ctx);",
            "\ttracing_sched_switch_trace(wakeup_trace, prev, next, trace_ctx);",
            "\t__trace_stack(wakeup_trace, trace_ctx, 0);",
            "",
            "\tT0 = data->preempt_timestamp;",
            "\tT1 = ftrace_now(cpu);",
            "\tdelta = T1-T0;",
            "",
            "\tif (!report_latency(wakeup_trace, delta))",
            "\t\tgoto out_unlock;",
            "",
            "\tif (likely(!is_tracing_stopped())) {",
            "\t\twakeup_trace->max_latency = delta;",
            "\t\tupdate_max_tr(wakeup_trace, wakeup_task, wakeup_cpu, NULL);",
            "\t}",
            "",
            "out_unlock:",
            "\t__wakeup_reset(wakeup_trace);",
            "\tarch_spin_unlock(&wakeup_lock);",
            "\tlocal_irq_restore(flags);",
            "out:",
            "\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "}",
            "static void __wakeup_reset(struct trace_array *tr)",
            "{",
            "\twakeup_cpu = -1;",
            "\twakeup_prio = -1;",
            "\ttracing_dl = false;",
            "",
            "\tif (wakeup_task)",
            "\t\tput_task_struct(wakeup_task);",
            "",
            "\twakeup_task = NULL;",
            "}",
            "static void wakeup_reset(struct trace_array *tr)",
            "{",
            "\tunsigned long flags;",
            "",
            "\ttracing_reset_online_cpus(&tr->array_buffer);",
            "",
            "\tlocal_irq_save(flags);",
            "\tarch_spin_lock(&wakeup_lock);",
            "\t__wakeup_reset(tr);",
            "\tarch_spin_unlock(&wakeup_lock);",
            "\tlocal_irq_restore(flags);",
            "}",
            "static void",
            "probe_wakeup(void *ignore, struct task_struct *p)",
            "{",
            "\tstruct trace_array_cpu *data;",
            "\tint cpu = smp_processor_id();",
            "\tlong disabled;",
            "\tunsigned int trace_ctx;",
            "",
            "\tif (likely(!tracer_enabled))",
            "\t\treturn;",
            "",
            "\ttracing_record_cmdline(p);",
            "\ttracing_record_cmdline(current);",
            "",
            "\t/*",
            "\t * Semantic is like this:",
            "\t *  - wakeup tracer handles all tasks in the system, independently",
            "\t *    from their scheduling class;",
            "\t *  - wakeup_rt tracer handles tasks belonging to sched_dl and",
            "\t *    sched_rt class;",
            "\t *  - wakeup_dl handles tasks belonging to sched_dl class only.",
            "\t */",
            "\tif (tracing_dl || (wakeup_dl && !dl_task(p)) ||",
            "\t    (wakeup_rt && !rt_or_dl_task(p)) ||",
            "\t    (!dl_task(p) && (p->prio >= wakeup_prio || p->prio >= current->prio)))",
            "\t\treturn;",
            "",
            "\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "\tif (unlikely(disabled != 1))",
            "\t\tgoto out;",
            "",
            "\ttrace_ctx = tracing_gen_ctx();",
            "",
            "\t/* interrupts should be off from try_to_wake_up */",
            "\tarch_spin_lock(&wakeup_lock);",
            "",
            "\t/* check for races. */",
            "\tif (!tracer_enabled || tracing_dl ||",
            "\t    (!dl_task(p) && p->prio >= wakeup_prio))",
            "\t\tgoto out_locked;",
            "",
            "\t/* reset the trace */",
            "\t__wakeup_reset(wakeup_trace);",
            "",
            "\twakeup_cpu = task_cpu(p);",
            "\twakeup_current_cpu = wakeup_cpu;",
            "\twakeup_prio = p->prio;",
            "",
            "\t/*",
            "\t * Once you start tracing a -deadline task, don't bother tracing",
            "\t * another task until the first one wakes up.",
            "\t */",
            "\tif (dl_task(p))",
            "\t\ttracing_dl = true;",
            "\telse",
            "\t\ttracing_dl = false;",
            "",
            "\twakeup_task = get_task_struct(p);",
            "",
            "\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);",
            "\tdata->preempt_timestamp = ftrace_now(cpu);",
            "\ttracing_sched_wakeup_trace(wakeup_trace, p, current, trace_ctx);",
            "\t__trace_stack(wakeup_trace, trace_ctx, 0);",
            "",
            "\t/*",
            "\t * We must be careful in using CALLER_ADDR2. But since wake_up",
            "\t * is not called by an assembly function  (where as schedule is)",
            "\t * it should be safe to use it here.",
            "\t */",
            "\t__trace_function(wakeup_trace, CALLER_ADDR1, CALLER_ADDR2, trace_ctx);",
            "",
            "out_locked:",
            "\tarch_spin_unlock(&wakeup_lock);",
            "out:",
            "\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "}"
          ],
          "function_name": "probe_wakeup_sched_switch, __wakeup_reset, wakeup_reset, probe_wakeup",
          "description": "通过探针函数捕获任务唤醒事件，维护当前跟踪目标任务状态，同步时间戳并触发相应跟踪记录操作。",
          "similarity": 0.6083303093910217
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 67,
          "end_line": 173,
          "content": [
            "static int",
            "func_prolog_preempt_disable(struct trace_array *tr,",
            "\t\t\t    struct trace_array_cpu **data,",
            "\t\t\t    unsigned int *trace_ctx)",
            "{",
            "\tlong disabled;",
            "\tint cpu;",
            "",
            "\tif (likely(!wakeup_task))",
            "\t\treturn 0;",
            "",
            "\t*trace_ctx = tracing_gen_ctx();",
            "\tpreempt_disable_notrace();",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\tif (cpu != wakeup_current_cpu)",
            "\t\tgoto out_enable;",
            "",
            "\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "\tdisabled = atomic_inc_return(&(*data)->disabled);",
            "\tif (unlikely(disabled != 1))",
            "\t\tgoto out;",
            "",
            "\treturn 1;",
            "",
            "out:",
            "\tatomic_dec(&(*data)->disabled);",
            "",
            "out_enable:",
            "\tpreempt_enable_notrace();",
            "\treturn 0;",
            "}",
            "static int wakeup_display_graph(struct trace_array *tr, int set)",
            "{",
            "\tif (!(is_graph(tr) ^ set))",
            "\t\treturn 0;",
            "",
            "\tstop_func_tracer(tr, !set);",
            "",
            "\twakeup_reset(wakeup_trace);",
            "\ttr->max_latency = 0;",
            "",
            "\treturn start_func_tracer(tr, set);",
            "}",
            "static int wakeup_graph_entry(struct ftrace_graph_ent *trace,",
            "\t\t\t      struct fgraph_ops *gops,",
            "\t\t\t      struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = wakeup_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint ret = 0;",
            "",
            "\tif (ftrace_graph_ignore_func(gops, trace))",
            "\t\treturn 0;",
            "\t/*",
            "\t * Do not trace a function if it's filtered by set_graph_notrace.",
            "\t * Make the index of ret stack negative to indicate that it should",
            "\t * ignore further functions.  But it needs its own ret stack entry",
            "\t * to recover the original index in order to continue tracing after",
            "\t * returning from the function.",
            "\t */",
            "\tif (ftrace_graph_notrace_addr(trace->func))",
            "\t\treturn 1;",
            "",
            "\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))",
            "\t\treturn 0;",
            "",
            "\tcalltime = fgraph_reserve_data(gops->idx, sizeof(*calltime));",
            "\tif (!calltime)",
            "\t\treturn 0;",
            "",
            "\t*calltime = trace_clock_local();",
            "",
            "\tret = __trace_graph_entry(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "\tpreempt_enable_notrace();",
            "",
            "\treturn ret;",
            "}",
            "static void wakeup_graph_return(struct ftrace_graph_ret *trace,",
            "\t\t\t\tstruct fgraph_ops *gops,",
            "\t\t\t\tstruct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = wakeup_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint size;",
            "",
            "\tftrace_graph_addr_finish(gops, trace);",
            "",
            "\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))",
            "\t\treturn;",
            "",
            "\tcalltime = fgraph_retrieve_data(gops->idx, &size);",
            "\tif (!calltime)",
            "\t\treturn;",
            "\ttrace->calltime = *calltime;",
            "",
            "\t__trace_graph_return(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "",
            "\tpreempt_enable_notrace();",
            "\treturn;",
            "}"
          ],
          "function_name": "func_prolog_preempt_disable, wakeup_display_graph, wakeup_graph_entry, wakeup_graph_return",
          "description": "实现抢占禁用、图形跟踪模式切换及函数入口/返回的跟踪逻辑，用于管理跟踪上下文和数据采集。",
          "similarity": 0.6026039123535156
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 618,
          "end_line": 723,
          "content": [
            "static void start_wakeup_tracer(struct trace_array *tr)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_trace_sched_wakeup(probe_wakeup, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_wakeup\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_wakeup_new\\n\");",
            "\t\tgoto fail_deprobe;",
            "\t}",
            "",
            "\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_switch\\n\");",
            "\t\tgoto fail_deprobe_wake_new;",
            "\t}",
            "",
            "\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_migrate_task\\n\");",
            "\t\tgoto fail_deprobe_sched_switch;",
            "\t}",
            "",
            "\twakeup_reset(tr);",
            "",
            "\t/*",
            "\t * Don't let the tracer_enabled = 1 show up before",
            "\t * the wakeup_task is reset. This may be overkill since",
            "\t * wakeup_reset does a spin_unlock after setting the",
            "\t * wakeup_task to NULL, but I want to be safe.",
            "\t * This is a slow path anyway.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tif (start_func_tracer(tr, is_graph(tr)))",
            "\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");",
            "",
            "\treturn;",
            "fail_deprobe_sched_switch:",
            "\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);",
            "fail_deprobe_wake_new:",
            "\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);",
            "fail_deprobe:",
            "\tunregister_trace_sched_wakeup(probe_wakeup, NULL);",
            "}",
            "static void stop_wakeup_tracer(struct trace_array *tr)",
            "{",
            "\ttracer_enabled = 0;",
            "\tstop_func_tracer(tr, is_graph(tr));",
            "\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);",
            "\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);",
            "\tunregister_trace_sched_wakeup(probe_wakeup, NULL);",
            "\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);",
            "}",
            "static int __wakeup_tracer_init(struct trace_array *tr)",
            "{",
            "\tsave_flags = tr->trace_flags;",
            "",
            "\t/* non overwrite screws up the latency tracers */",
            "\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);",
            "\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);",
            "",
            "\ttr->max_latency = 0;",
            "\twakeup_trace = tr;",
            "\tftrace_init_array_ops(tr, wakeup_tracer_call);",
            "\tstart_wakeup_tracer(tr);",
            "",
            "\twakeup_busy = true;",
            "\treturn 0;",
            "}",
            "static int wakeup_tracer_init(struct trace_array *tr)",
            "{",
            "\tif (wakeup_busy)",
            "\t\treturn -EBUSY;",
            "",
            "\twakeup_dl = false;",
            "\twakeup_rt = false;",
            "\treturn __wakeup_tracer_init(tr);",
            "}",
            "static int wakeup_rt_tracer_init(struct trace_array *tr)",
            "{",
            "\tif (wakeup_busy)",
            "\t\treturn -EBUSY;",
            "",
            "\twakeup_dl = false;",
            "\twakeup_rt = true;",
            "\treturn __wakeup_tracer_init(tr);",
            "}",
            "static int wakeup_dl_tracer_init(struct trace_array *tr)",
            "{",
            "\tif (wakeup_busy)",
            "\t\treturn -EBUSY;",
            "",
            "\twakeup_dl = true;",
            "\twakeup_rt = false;",
            "\treturn __wakeup_tracer_init(tr);",
            "}"
          ],
          "function_name": "start_wakeup_tracer, stop_wakeup_tracer, __wakeup_tracer_init, wakeup_tracer_init, wakeup_rt_tracer_init, wakeup_dl_tracer_init",
          "description": "实现调度唤醒跟踪器的启动逻辑，注册 sched_wakeup、sched_switch 等 tracepoint 探针，处理注册失败时的资源清理，并通过 smp_wmb() 确保内存屏障顺序。",
          "similarity": 0.5489407181739807
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 309,
          "end_line": 430,
          "content": [
            "static void wakeup_trace_open(struct trace_iterator *iter) { }",
            "static void wakeup_trace_close(struct trace_iterator *iter) { }",
            "static void wakeup_print_header(struct seq_file *s)",
            "{",
            "\ttrace_default_header(s);",
            "}",
            "static void",
            "__trace_function(struct trace_array *tr,",
            "\t\t unsigned long ip, unsigned long parent_ip,",
            "\t\t unsigned int trace_ctx)",
            "{",
            "\tif (is_graph(tr))",
            "\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);",
            "\telse",
            "\t\ttrace_function(tr, ip, parent_ip, trace_ctx);",
            "}",
            "static int wakeup_flag_changed(struct trace_array *tr, u32 mask, int set)",
            "{",
            "\tstruct tracer *tracer = tr->current_trace;",
            "",
            "\tif (wakeup_function_set(tr, mask, set))",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_FUNCTION_GRAPH_TRACER",
            "\tif (mask & TRACE_ITER_DISPLAY_GRAPH)",
            "\t\treturn wakeup_display_graph(tr, set);",
            "#endif",
            "",
            "\treturn trace_keep_overwrite(tracer, mask, set);",
            "}",
            "static int start_func_tracer(struct trace_array *tr, int graph)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_wakeup_function(tr, graph, 0);",
            "",
            "\tif (!ret && tracing_is_enabled())",
            "\t\ttracer_enabled = 1;",
            "\telse",
            "\t\ttracer_enabled = 0;",
            "",
            "\treturn ret;",
            "}",
            "static void stop_func_tracer(struct trace_array *tr, int graph)",
            "{",
            "\ttracer_enabled = 0;",
            "",
            "\tunregister_wakeup_function(tr, graph);",
            "}",
            "static bool report_latency(struct trace_array *tr, u64 delta)",
            "{",
            "\tif (tracing_thresh) {",
            "\t\tif (delta < tracing_thresh)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\tif (delta <= tr->max_latency)",
            "\t\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void",
            "probe_wakeup_migrate_task(void *ignore, struct task_struct *task, int cpu)",
            "{",
            "\tif (task != wakeup_task)",
            "\t\treturn;",
            "",
            "\twakeup_current_cpu = cpu;",
            "}",
            "static void",
            "tracing_sched_switch_trace(struct trace_array *tr,",
            "\t\t\t   struct task_struct *prev,",
            "\t\t\t   struct task_struct *next,",
            "\t\t\t   unsigned int trace_ctx)",
            "{",
            "\tstruct trace_event_call *call = &event_context_switch;",
            "\tstruct trace_buffer *buffer = tr->array_buffer.buffer;",
            "\tstruct ring_buffer_event *event;",
            "\tstruct ctx_switch_entry *entry;",
            "",
            "\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,",
            "\t\t\t\t\t  sizeof(*entry), trace_ctx);",
            "\tif (!event)",
            "\t\treturn;",
            "\tentry\t= ring_buffer_event_data(event);",
            "\tentry->prev_pid\t\t\t= prev->pid;",
            "\tentry->prev_prio\t\t= prev->prio;",
            "\tentry->prev_state\t\t= task_state_index(prev);",
            "\tentry->next_pid\t\t\t= next->pid;",
            "\tentry->next_prio\t\t= next->prio;",
            "\tentry->next_state\t\t= task_state_index(next);",
            "\tentry->next_cpu\t= task_cpu(next);",
            "",
            "\tif (!call_filter_check_discard(call, entry, buffer, event))",
            "\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);",
            "}",
            "static void",
            "tracing_sched_wakeup_trace(struct trace_array *tr,",
            "\t\t\t   struct task_struct *wakee,",
            "\t\t\t   struct task_struct *curr,",
            "\t\t\t   unsigned int trace_ctx)",
            "{",
            "\tstruct trace_event_call *call = &event_wakeup;",
            "\tstruct ring_buffer_event *event;",
            "\tstruct ctx_switch_entry *entry;",
            "\tstruct trace_buffer *buffer = tr->array_buffer.buffer;",
            "",
            "\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,",
            "\t\t\t\t\t  sizeof(*entry), trace_ctx);",
            "\tif (!event)",
            "\t\treturn;",
            "\tentry\t= ring_buffer_event_data(event);",
            "\tentry->prev_pid\t\t\t= curr->pid;",
            "\tentry->prev_prio\t\t= curr->prio;",
            "\tentry->prev_state\t\t= task_state_index(curr);",
            "\tentry->next_pid\t\t\t= wakee->pid;",
            "\tentry->next_prio\t\t= wakee->prio;",
            "\tentry->next_state\t\t= task_state_index(wakee);",
            "\tentry->next_cpu\t\t\t= task_cpu(wakee);",
            "",
            "\tif (!call_filter_check_discard(call, entry, buffer, event))",
            "\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);",
            "}"
          ],
          "function_name": "wakeup_trace_open, wakeup_trace_close, wakeup_print_header, __trace_function, wakeup_flag_changed, start_func_tracer, stop_func_tracer, report_latency, probe_wakeup_migrate_task, tracing_sched_switch_trace, tracing_sched_wakeup_trace",
          "description": "实现任务切换和唤醒事件的记录功能，包含延迟上报判断、时间戳计算及事件数据的缓冲区管理。",
          "similarity": 0.5449910759925842
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 732,
          "end_line": 772,
          "content": [
            "static void wakeup_tracer_reset(struct trace_array *tr)",
            "{",
            "\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;",
            "\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;",
            "",
            "\tstop_wakeup_tracer(tr);",
            "\t/* make sure we put back any tasks we are tracing */",
            "\twakeup_reset(tr);",
            "",
            "\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);",
            "\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);",
            "\tftrace_reset_array_ops(tr);",
            "\twakeup_busy = false;",
            "}",
            "static void wakeup_tracer_start(struct trace_array *tr)",
            "{",
            "\twakeup_reset(tr);",
            "\ttracer_enabled = 1;",
            "}",
            "static void wakeup_tracer_stop(struct trace_array *tr)",
            "{",
            "\ttracer_enabled = 0;",
            "}",
            "__init static int init_wakeup_tracer(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_tracer(&wakeup_tracer);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = register_tracer(&wakeup_rt_tracer);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = register_tracer(&wakeup_dl_tracer);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "wakeup_tracer_reset, wakeup_tracer_start, wakeup_tracer_stop, init_wakeup_tracer",
          "description": "提供调度唤醒跟踪器的重置、启动与停止接口，其中 init_wakeup_tracer 注册三种调度跟踪器（常规/实时/延迟）到内核跟踪系统。",
          "similarity": 0.5400710105895996
        }
      ]
    }
  ]
}