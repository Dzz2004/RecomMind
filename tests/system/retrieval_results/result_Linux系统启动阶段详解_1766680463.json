{
  "query": "Linux系统启动阶段详解",
  "timestamp": "2025-12-26 00:34:23",
  "retrieved_files": [
    {
      "source_file": "kernel/reboot.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:51:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `reboot.c`\n\n---\n\n# reboot.c 技术文档\n\n## 1. 文件概述\n\n`reboot.c` 是 Linux 内核中负责系统重启、关机和紧急重启逻辑的核心实现文件。它提供了统一的接口用于注册重启通知器、处理重启准备流程、执行系统重启，并支持多种重启模式（如硬重启、软重启、kexec 等）。该文件协调设备关闭、用户空间辅助进程禁用、CPU 迁移等关键步骤，确保系统在重启前处于安全状态，并为架构无关代码提供标准化的重启抽象。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `C_A_D`：控制是否允许通过 Ctrl+Alt+Del 组合键触发重启（默认启用）。\n- `cad_pid`：指向处理 Ctrl+Alt+Del 信号的进程 PID（导出供其他模块使用）。\n- `reboot_mode`：当前系统重启模式（如 `REBOOT_HARD`、`REBOOT_SOFT` 等），ARM 架构默认为硬重启。\n- `panic_reboot_mode`：内核 panic 时使用的重启模式。\n- `reboot_default`：标识 `reboot=` 内核参数是否被显式设置，用于控制 DMI 重启 quirks 的启用。\n- `reboot_cpu` / `reboot_type` / `reboot_force`：控制重启目标 CPU、重启方式（如 ACPI、EFI 等）及是否强制重启。\n- `pm_power_off`：弱符号函数指针，作为遗留关机接口的临时占位符。\n\n### 主要函数\n- `emergency_restart()`：在紧急情况下（如死锁、严重错误）立即重启系统，可在中断上下文调用。\n- `kernel_restart_prepare()`：执行重启前的标准准备流程（通知链、设备关闭等）。\n- `kernel_restart()`：执行完整的系统重启流程，包括迁移至指定 CPU、关闭 syscore、调用底层 `machine_restart()`。\n- `register_reboot_notifier()` / `unregister_reboot_notifier()`：注册/注销重启通知器（阻塞型）。\n- `devm_register_reboot_notifier()`：基于设备资源管理的重启通知器注册。\n- `register_restart_handler()` / `unregister_restart_handler()`：注册/注销重启处理器（原子型，高优先级）。\n- `do_kernel_restart()`：调用已注册的重启处理器链，尝试执行架构无关的重启。\n- `migrate_to_reboot_cpu()`：将当前任务迁移到指定的重启 CPU（默认为 CPU 0 或首个在线 CPU）。\n- `do_kernel_restart_prepare()`：调用重启准备通知链，用于预处理。\n\n### 通知链\n- `reboot_notifier_list`（阻塞）：用于常规重启前的通知。\n- `restart_handler_list`（原子）：用于实际执行重启操作的高优先级处理器。\n- `restart_prep_handler_list`（阻塞）：用于重启前的额外准备步骤。\n\n## 3. 关键实现\n\n### 重启流程控制\n- **标准重启** (`kernel_restart`)：依次执行通知链 → 设备关闭 → 用户空间 helper 禁用 → 迁移到指定 CPU → syscore 关闭 → 调用架构相关 `machine_restart()`。\n- **紧急重启** (`emergency_restart`)：跳过大部分清理步骤，直接调用 `machine_emergency_restart()`，适用于系统已不稳定的情况。\n- **重启处理器机制**：通过 `register_restart_handler()` 注册的处理器（如 watchdog 驱动）可在 `machine_restart()` 中被调用（若其实现调用了 `do_kernel_restart()`），实现架构无关的重启能力。\n\n### CPU 迁移策略\n- `migrate_to_reboot_cpu()` 确保重启操作在指定 CPU（`reboot_cpu`）上执行，若该 CPU 离线则回退到首个在线 CPU。\n- 设置 `PF_NO_SETAFFINITY` 标志防止其他任务修改当前任务的 CPU 亲和性，保证迁移的可靠性。\n\n### 重启模式与参数\n- `reboot_mode` 允许内核或用户空间指定重启类型（硬/软/kexec），影响底层硬件操作方式。\n- `reboot_default` 变量用于判断是否通过内核命令行显式设置了 `reboot=` 参数，从而决定是否跳过 DMI 重启 quirks 扫描，便于覆盖错误的固件行为。\n\n### 资源管理\n- `devm_register_reboot_notifier()` 使用设备资源管理（devres）自动注销通知器，避免资源泄漏。\n\n## 4. 依赖关系\n\n- **架构相关代码**：依赖 `machine_restart()` 和 `machine_emergency_restart()` 的架构特定实现（位于 `arch/*/kernel/reboot.c` 等）。\n- **设备模型**：调用 `device_shutdown()` 关闭设备，依赖驱动模型。\n- **电源管理**：与 `suspend.h` 和遗留的 `pm_power_off` 接口交互。\n- **kexec**：支持通过 `kexec` 实现快速重启，依赖 `kexec.h`。\n- **内核通知机制**：使用 `notifier.h` 提供的阻塞和原子通知链。\n- **用户空间交互**：通过 `syscalls.h` 暴露系统调用接口（如 `reboot()` 系统调用）。\n- **日志系统**：使用 `kmsg_dump()` 在重启前转储内核日志。\n\n## 5. 使用场景\n\n- **系统调用处理**：`sys_reboot()` 系统调用最终调用 `kernel_restart()` 或 `kernel_halt()` 等函数。\n- **内核 Panic**：当配置了 panic 后自动重启时，调用 `emergency_restart()` 或 `kernel_restart()`。\n- **硬件驱动**：Watchdog 或电源管理芯片驱动通过 `register_restart_handler()` 注册硬件级重启能力。\n- **用户空间工具**：`reboot`、`shutdown` 等命令通过系统调用触发内核重启流程。\n- **kexec 快速启动**：配合 kexec 实现无需固件介入的内核切换。\n- **调试与恢复**：在系统卡死时通过 Magic SysRq 或硬件看门狗触发紧急重启。",
      "similarity": 0.6178193092346191,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/reboot.c",
          "start_line": 1219,
          "end_line": 1267,
          "content": [
            "static ssize_t cpu_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%d\\n\", reboot_cpu);",
            "}",
            "static ssize_t cpu_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t  const char *buf, size_t count)",
            "{",
            "\tunsigned int cpunum;",
            "\tint rc;",
            "",
            "\tif (!capable(CAP_SYS_BOOT))",
            "\t\treturn -EPERM;",
            "",
            "\trc = kstrtouint(buf, 0, &cpunum);",
            "",
            "\tif (rc)",
            "\t\treturn rc;",
            "",
            "\tif (cpunum >= num_possible_cpus())",
            "\t\treturn -ERANGE;",
            "",
            "\treboot_default = 0;",
            "\treboot_cpu = cpunum;",
            "",
            "\treturn count;",
            "}",
            "static void __init kernel_reboot_sysctls_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kern_reboot_table);",
            "}",
            "static int __init reboot_ksysfs_init(void)",
            "{",
            "\tstruct kobject *reboot_kobj;",
            "\tint ret;",
            "",
            "\treboot_kobj = kobject_create_and_add(\"reboot\", kernel_kobj);",
            "\tif (!reboot_kobj)",
            "\t\treturn -ENOMEM;",
            "",
            "\tret = sysfs_create_group(reboot_kobj, &reboot_attr_group);",
            "\tif (ret) {",
            "\t\tkobject_put(reboot_kobj);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tkernel_reboot_sysctls_init();",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "cpu_show, cpu_store, kernel_reboot_sysctls_init, reboot_ksysfs_init",
          "description": "实现了CPU重启控制(sysfs/cpu)及sysctl初始化逻辑，包含cpu参数读写接口与sysfs目录创建函数，用于指定特定CPU触发系统重启操作。",
          "similarity": 0.5403605103492737
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/reboot.c",
          "start_line": 1,
          "end_line": 73,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/reboot.c",
            " *",
            " *  Copyright (C) 2013  Linus Torvalds",
            " */",
            "",
            "#define pr_fmt(fmt)\t\"reboot: \" fmt",
            "",
            "#include <linux/atomic.h>",
            "#include <linux/ctype.h>",
            "#include <linux/export.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/uaccess.h>",
            "",
            "/*",
            " * this indicates whether you can reboot with ctrl-alt-del: the default is yes",
            " */",
            "",
            "static int C_A_D = 1;",
            "struct pid *cad_pid;",
            "EXPORT_SYMBOL(cad_pid);",
            "",
            "#if defined(CONFIG_ARM)",
            "#define DEFAULT_REBOOT_MODE\t\t= REBOOT_HARD",
            "#else",
            "#define DEFAULT_REBOOT_MODE",
            "#endif",
            "enum reboot_mode reboot_mode DEFAULT_REBOOT_MODE;",
            "EXPORT_SYMBOL_GPL(reboot_mode);",
            "enum reboot_mode panic_reboot_mode = REBOOT_UNDEFINED;",
            "",
            "/*",
            " * This variable is used privately to keep track of whether or not",
            " * reboot_type is still set to its default value (i.e., reboot= hasn't",
            " * been set on the command line).  This is needed so that we can",
            " * suppress DMI scanning for reboot quirks.  Without it, it's",
            " * impossible to override a faulty reboot quirk without recompiling.",
            " */",
            "int reboot_default = 1;",
            "int reboot_cpu;",
            "enum reboot_type reboot_type = BOOT_ACPI;",
            "int reboot_force;",
            "",
            "struct sys_off_handler {",
            "\tstruct notifier_block nb;",
            "\tint (*sys_off_cb)(struct sys_off_data *data);",
            "\tvoid *cb_data;",
            "\tenum sys_off_mode mode;",
            "\tbool blocking;",
            "\tvoid *list;",
            "};",
            "",
            "/*",
            " * Temporary stub that prevents linkage failure while we're in process",
            " * of removing all uses of legacy pm_power_off() around the kernel.",
            " */",
            "void __weak (*pm_power_off)(void);",
            "",
            "/**",
            " *\temergency_restart - reboot the system",
            " *",
            " *\tWithout shutting down any hardware or taking any locks",
            " *\treboot the system.  This is called when we know we are in",
            " *\ttrouble so this is our best effort to reboot.  This is",
            " *\tsafe to call in interrupt context.",
            " */"
          ],
          "function_name": null,
          "description": "定义了与系统重启相关的全局变量和枚举类型，包括重启模式（reboot_mode）、默认重启类型（reboot_type）以及用于跟踪重启处理器的变量（reboot_cpu）。声明了sys_off_handler结构体，用于管理系统关机回调函数。",
          "similarity": 0.5369308590888977
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/reboot.c",
          "start_line": 74,
          "end_line": 181,
          "content": [
            "void emergency_restart(void)",
            "{",
            "\tkmsg_dump(KMSG_DUMP_EMERG);",
            "\tsystem_state = SYSTEM_RESTART;",
            "\tmachine_emergency_restart();",
            "}",
            "void kernel_restart_prepare(char *cmd)",
            "{",
            "\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);",
            "\tsystem_state = SYSTEM_RESTART;",
            "\tusermodehelper_disable();",
            "\tdevice_shutdown();",
            "}",
            "int register_reboot_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&reboot_notifier_list, nb);",
            "}",
            "int unregister_reboot_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);",
            "}",
            "static void devm_unregister_reboot_notifier(struct device *dev, void *res)",
            "{",
            "\tWARN_ON(unregister_reboot_notifier(*(struct notifier_block **)res));",
            "}",
            "int devm_register_reboot_notifier(struct device *dev, struct notifier_block *nb)",
            "{",
            "\tstruct notifier_block **rcnb;",
            "\tint ret;",
            "",
            "\trcnb = devres_alloc(devm_unregister_reboot_notifier,",
            "\t\t\t    sizeof(*rcnb), GFP_KERNEL);",
            "\tif (!rcnb)",
            "\t\treturn -ENOMEM;",
            "",
            "\tret = register_reboot_notifier(nb);",
            "\tif (!ret) {",
            "\t\t*rcnb = nb;",
            "\t\tdevres_add(dev, rcnb);",
            "\t} else {",
            "\t\tdevres_free(rcnb);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "int register_restart_handler(struct notifier_block *nb)",
            "{",
            "\treturn atomic_notifier_chain_register(&restart_handler_list, nb);",
            "}",
            "int unregister_restart_handler(struct notifier_block *nb)",
            "{",
            "\treturn atomic_notifier_chain_unregister(&restart_handler_list, nb);",
            "}",
            "void do_kernel_restart(char *cmd)",
            "{",
            "\tatomic_notifier_call_chain(&restart_handler_list, reboot_mode, cmd);",
            "}",
            "void migrate_to_reboot_cpu(void)",
            "{",
            "\t/* The boot cpu is always logical cpu 0 */",
            "\tint cpu = reboot_cpu;",
            "",
            "\tcpu_hotplug_disable();",
            "",
            "\t/* Make certain the cpu I'm about to reboot on is online */",
            "\tif (!cpu_online(cpu))",
            "\t\tcpu = cpumask_first(cpu_online_mask);",
            "",
            "\t/* Prevent races with other tasks migrating this task */",
            "\tcurrent->flags |= PF_NO_SETAFFINITY;",
            "",
            "\t/* Make certain I only run on the appropriate processor */",
            "\tset_cpus_allowed_ptr(current, cpumask_of(cpu));",
            "}",
            "static void do_kernel_restart_prepare(void)",
            "{",
            "\tblocking_notifier_call_chain(&restart_prep_handler_list, 0, NULL);",
            "}",
            "void kernel_restart(char *cmd)",
            "{",
            "\tkernel_restart_prepare(cmd);",
            "\tdo_kernel_restart_prepare();",
            "\tmigrate_to_reboot_cpu();",
            "\tsyscore_shutdown();",
            "\tif (!cmd)",
            "\t\tpr_emerg(\"Restarting system\\n\");",
            "\telse",
            "\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);",
            "\tkmsg_dump(KMSG_DUMP_SHUTDOWN);",
            "\tmachine_restart(cmd);",
            "}",
            "static void kernel_shutdown_prepare(enum system_states state)",
            "{",
            "\tblocking_notifier_call_chain(&reboot_notifier_list,",
            "\t\t(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, NULL);",
            "\tsystem_state = state;",
            "\tusermodehelper_disable();",
            "\tdevice_shutdown();",
            "}",
            "void kernel_halt(void)",
            "{",
            "\tkernel_shutdown_prepare(SYSTEM_HALT);",
            "\tmigrate_to_reboot_cpu();",
            "\tsyscore_shutdown();",
            "\tpr_emerg(\"System halted\\n\");",
            "\tkmsg_dump(KMSG_DUMP_SHUTDOWN);",
            "\tmachine_halt();",
            "}"
          ],
          "function_name": "emergency_restart, kernel_restart_prepare, register_reboot_notifier, unregister_reboot_notifier, devm_unregister_reboot_notifier, devm_register_reboot_notifier, register_restart_handler, unregister_restart_handler, do_kernel_restart, migrate_to_reboot_cpu, do_kernel_restart_prepare, kernel_restart, kernel_shutdown_prepare, kernel_halt",
          "description": "实现了系统重启、关机和休眠的准备逻辑，包含注册/注销重启通知链、迁移CPU到指定核心、执行设备关闭操作等功能。通过notifier_call_chain触发各阶段的回调处理。",
          "similarity": 0.5265659689903259
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/reboot.c",
          "start_line": 871,
          "end_line": 1010,
          "content": [
            "static void poweroff_work_func(struct work_struct *work)",
            "{",
            "\t__orderly_poweroff(poweroff_force);",
            "}",
            "void orderly_poweroff(bool force)",
            "{",
            "\tif (force) /* do not override the pending \"true\" */",
            "\t\tpoweroff_force = true;",
            "\tschedule_work(&poweroff_work);",
            "}",
            "static void reboot_work_func(struct work_struct *work)",
            "{",
            "\t__orderly_reboot();",
            "}",
            "void orderly_reboot(void)",
            "{",
            "\tschedule_work(&reboot_work);",
            "}",
            "static void hw_failure_emergency_poweroff_func(struct work_struct *work)",
            "{",
            "\t/*",
            "\t * We have reached here after the emergency shutdown waiting period has",
            "\t * expired. This means orderly_poweroff has not been able to shut off",
            "\t * the system for some reason.",
            "\t *",
            "\t * Try to shut down the system immediately using kernel_power_off",
            "\t * if populated",
            "\t */",
            "\tpr_emerg(\"Hardware protection timed-out. Trying forced poweroff\\n\");",
            "\tkernel_power_off();",
            "",
            "\t/*",
            "\t * Worst of the worst case trigger emergency restart",
            "\t */",
            "\tpr_emerg(\"Hardware protection shutdown failed. Trying emergency restart\\n\");",
            "\temergency_restart();",
            "}",
            "static void hw_failure_emergency_poweroff(int poweroff_delay_ms)",
            "{",
            "\tif (poweroff_delay_ms <= 0)",
            "\t\treturn;",
            "\tschedule_delayed_work(&hw_failure_emergency_poweroff_work,",
            "\t\t\t      msecs_to_jiffies(poweroff_delay_ms));",
            "}",
            "void hw_protection_shutdown(const char *reason, int ms_until_forced)",
            "{",
            "\tstatic atomic_t allow_proceed = ATOMIC_INIT(1);",
            "",
            "\tpr_emerg(\"HARDWARE PROTECTION shutdown (%s)\\n\", reason);",
            "",
            "\t/* Shutdown should be initiated only once. */",
            "\tif (!atomic_dec_and_test(&allow_proceed))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Queue a backup emergency shutdown in the event of",
            "\t * orderly_poweroff failure",
            "\t */",
            "\thw_failure_emergency_poweroff(ms_until_forced);",
            "\torderly_poweroff(true);",
            "}",
            "static int __init reboot_setup(char *str)",
            "{",
            "\tfor (;;) {",
            "\t\tenum reboot_mode *mode;",
            "",
            "\t\t/*",
            "\t\t * Having anything passed on the command line via",
            "\t\t * reboot= will cause us to disable DMI checking",
            "\t\t * below.",
            "\t\t */",
            "\t\treboot_default = 0;",
            "",
            "\t\tif (!strncmp(str, \"panic_\", 6)) {",
            "\t\t\tmode = &panic_reboot_mode;",
            "\t\t\tstr += 6;",
            "\t\t} else {",
            "\t\t\tmode = &reboot_mode;",
            "\t\t}",
            "",
            "\t\tswitch (*str) {",
            "\t\tcase 'w':",
            "\t\t\t*mode = REBOOT_WARM;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'c':",
            "\t\t\t*mode = REBOOT_COLD;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'h':",
            "\t\t\t*mode = REBOOT_HARD;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 's':",
            "\t\t\t/*",
            "\t\t\t * reboot_cpu is s[mp]#### with #### being the processor",
            "\t\t\t * to be used for rebooting. Skip 's' or 'smp' prefix.",
            "\t\t\t */",
            "\t\t\tstr += str[1] == 'm' && str[2] == 'p' ? 3 : 1;",
            "",
            "\t\t\tif (isdigit(str[0])) {",
            "\t\t\t\tint cpu = simple_strtoul(str, NULL, 0);",
            "",
            "\t\t\t\tif (cpu >= num_possible_cpus()) {",
            "\t\t\t\t\tpr_err(\"Ignoring the CPU number in reboot= option. \"",
            "\t\t\t\t\t\"CPU %d exceeds possible cpu number %d\\n\",",
            "\t\t\t\t\tcpu, num_possible_cpus());",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\treboot_cpu = cpu;",
            "\t\t\t} else",
            "\t\t\t\t*mode = REBOOT_SOFT;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'g':",
            "\t\t\t*mode = REBOOT_GPIO;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'b':",
            "\t\tcase 'a':",
            "\t\tcase 'k':",
            "\t\tcase 't':",
            "\t\tcase 'e':",
            "\t\tcase 'p':",
            "\t\t\treboot_type = *str;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'f':",
            "\t\t\treboot_force = 1;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tstr = strchr(str, ',');",
            "\t\tif (str)",
            "\t\t\tstr++;",
            "\t\telse",
            "\t\t\tbreak;",
            "\t}",
            "\treturn 1;",
            "}"
          ],
          "function_name": "poweroff_work_func, orderly_poweroff, reboot_work_func, orderly_reboot, hw_failure_emergency_poweroff_func, hw_failure_emergency_poweroff, hw_protection_shutdown, reboot_setup",
          "description": "通过工作队列实现延迟关机/重启操作（poweroff_work_func/reboot_work_func），处理硬件保护超时后的应急关机（hw_failure_emergency_poweroff_func），并通过reboot_setup解析内核命令行参数配置重启模式。",
          "similarity": 0.5076236128807068
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/reboot.c",
          "start_line": 609,
          "end_line": 728,
          "content": [
            "void unregister_platform_power_off(void (*power_off)(void))",
            "{",
            "\tif (platform_power_off_handler &&",
            "\t    platform_power_off_handler->cb_data == power_off) {",
            "\t\tunregister_sys_off_handler(platform_power_off_handler);",
            "\t\tplatform_power_off_handler = NULL;",
            "\t}",
            "}",
            "static int legacy_pm_power_off(struct sys_off_data *data)",
            "{",
            "\tif (pm_power_off)",
            "\t\tpm_power_off();",
            "",
            "\treturn NOTIFY_DONE;",
            "}",
            "static void do_kernel_power_off_prepare(void)",
            "{",
            "\tblocking_notifier_call_chain(&power_off_prep_handler_list, 0, NULL);",
            "}",
            "void do_kernel_power_off(void)",
            "{",
            "\tstruct sys_off_handler *sys_off = NULL;",
            "",
            "\t/*",
            "\t * Register sys-off handlers for legacy PM callback. This allows",
            "\t * legacy PM callbacks temporary co-exist with the new sys-off API.",
            "\t *",
            "\t * TODO: Remove legacy handlers once all legacy PM users will be",
            "\t *       switched to the sys-off based APIs.",
            "\t */",
            "\tif (pm_power_off)",
            "\t\tsys_off = register_sys_off_handler(SYS_OFF_MODE_POWER_OFF,",
            "\t\t\t\t\t\t   SYS_OFF_PRIO_DEFAULT,",
            "\t\t\t\t\t\t   legacy_pm_power_off, NULL);",
            "",
            "\tatomic_notifier_call_chain(&power_off_handler_list, 0, NULL);",
            "",
            "\tunregister_sys_off_handler(sys_off);",
            "}",
            "bool kernel_can_power_off(void)",
            "{",
            "\treturn !atomic_notifier_call_chain_is_empty(&power_off_handler_list) ||",
            "\t\tpm_power_off;",
            "}",
            "void kernel_power_off(void)",
            "{",
            "\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);",
            "\tdo_kernel_power_off_prepare();",
            "\tmigrate_to_reboot_cpu();",
            "\tsyscore_shutdown();",
            "\tpr_emerg(\"Power down\\n\");",
            "\tkmsg_dump(KMSG_DUMP_SHUTDOWN);",
            "\tmachine_power_off();",
            "}",
            "static void deferred_cad(struct work_struct *dummy)",
            "{",
            "\tkernel_restart(NULL);",
            "}",
            "void ctrl_alt_del(void)",
            "{",
            "\tstatic DECLARE_WORK(cad_work, deferred_cad);",
            "",
            "\tif (C_A_D)",
            "\t\tschedule_work(&cad_work);",
            "\telse",
            "\t\tkill_cad_pid(SIGINT, 1);",
            "}",
            "static int run_cmd(const char *cmd)",
            "{",
            "\tchar **argv;",
            "\tstatic char *envp[] = {",
            "\t\t\"HOME=/\",",
            "\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",",
            "\t\tNULL",
            "\t};",
            "\tint ret;",
            "\targv = argv_split(GFP_KERNEL, cmd, NULL);",
            "\tif (argv) {",
            "\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);",
            "\t\targv_free(argv);",
            "\t} else {",
            "\t\tret = -ENOMEM;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __orderly_reboot(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = run_cmd(reboot_cmd);",
            "",
            "\tif (ret) {",
            "\t\tpr_warn(\"Failed to start orderly reboot: forcing the issue\\n\");",
            "\t\temergency_sync();",
            "\t\tkernel_restart(NULL);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __orderly_poweroff(bool force)",
            "{",
            "\tint ret;",
            "",
            "\tret = run_cmd(poweroff_cmd);",
            "",
            "\tif (ret && force) {",
            "\t\tpr_warn(\"Failed to start orderly shutdown: forcing the issue\\n\");",
            "",
            "\t\t/*",
            "\t\t * I guess this should try to kick off some daemon to sync and",
            "\t\t * poweroff asap.  Or not even bother syncing if we're doing an",
            "\t\t * emergency shutdown?",
            "\t\t */",
            "\t\temergency_sync();",
            "\t\tkernel_power_off();",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "unregister_platform_power_off, legacy_pm_power_off, do_kernel_power_off_prepare, do_kernel_power_off, kernel_can_power_off, kernel_power_off, deferred_cad, ctrl_alt_del, run_cmd, __orderly_reboot, __orderly_poweroff",
          "description": "处理传统PM电源关闭接口兼容性，实现kernel_power_off强制关机逻辑，包含Ctrl+Alt+Del热键处理（deferred_cad）、命令行执行（run_cmd）以及有序重启/关机的兜底方案（__orderly_reboot/__orderly_poweroff）。",
          "similarity": 0.4874376654624939
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_boot.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:13:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_boot.c`\n\n---\n\n# `trace_boot.c` 技术文档\n\n## 1. 文件概述\n\n`trace_boot.c` 是 Linux 内核中用于在系统启动阶段（boot-time）配置和启用 ftrace 跟踪功能的核心实现文件。该文件通过解析内核启动参数中由 BootConfig（`/bootconfig`）提供的配置项，动态设置跟踪实例（`trace_array`）的各项参数，包括跟踪选项、事件启用、缓冲区大小、CPU 掩码、时钟源等，并支持高级功能如 kprobe 事件、合成事件（synthetic events）和直方图触发器（histogram triggers）。其目标是在内核初始化早期阶段完成跟踪系统的自动化配置，无需用户空间干预。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`trace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)`**  \n  解析 BootConfig 节点中与跟踪实例相关的通用配置项，设置 `tracing_on`、`trace_clock`、`buffer_size`、`cpumask` 和通用 ftrace 选项。\n\n- **`trace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)`**（需 `CONFIG_EVENT_TRACING`）  \n  根据 BootConfig 中的 `events` 数组启用指定的静态跟踪事件。\n\n- **`trace_boot_add_kprobe_event(struct xbc_node *node, const char *event)`**（需 `CONFIG_KPROBE_EVENTS`）  \n  动态创建并注册 kprobe 类型的动态事件，支持在启动时注入探针。\n\n- **`trace_boot_add_synth_event(struct xbc_node *node, const char *event)`**（需 `CONFIG_SYNTH_EVENTS`）  \n  根据 BootConfig 定义创建合成事件（synthetic event），用于组合多个事件数据。\n\n- **`trace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)`**（需 `CONFIG_HIST_TRIGGERS`）  \n  将 BootConfig 中的直方图触发器配置转换为内核可识别的命令字符串，用于设置复杂的事件触发逻辑（如 `onmax`、`onmatch` 等）。\n\n- **辅助函数（仅 `CONFIG_HIST_TRIGGERS` 下）**：\n  - `append_printf()`：安全地向缓冲区追加格式化字符串。\n  - `append_str_nospace()`：追加去除空白字符的字符串。\n  - `trace_boot_hist_add_array()`：处理直方图的数组型参数（如 `keys`、`values`）。\n  - `trace_boot_hist_add_one_handler()`：构建单个触发动作（如 `onmax(...).save(...)`）。\n  - `trace_boot_hist_add_handlers()`：处理多个或默认的触发器实例。\n\n## 3. 关键实现\n\n- **BootConfig 集成**：  \n  所有配置均通过 `xbc_node` 接口从 BootConfig 树中读取。使用 `xbc_node_find_value()` 获取标量值，`xbc_node_for_each_array_value()` 遍历数组，`xbc_node_for_each_subkey()` 处理嵌套结构。\n\n- **动态事件创建**：  \n  利用 `dynevent_cmd` 框架（`kprobe_event_cmd_init` / `synth_event_cmd_init`）构建动态事件命令，通过 `*_gen_cmd_start/end` 完成注册，确保与运行时动态事件机制一致。\n\n- **直方图触发器语法转换**：  \n  将 BootConfig 的树形结构（如 `hist { keys = ...; onmax.0 { var=...; save=... } }`）转换为内核直方图子系统所需的线性命令字符串（如 `\"hist:keys=...:onmax(var).save(...)\"`），通过递归解析子节点和参数完成。\n\n- **错误处理与日志**：  \n  所有配置项解析失败时均通过 `pr_err()` 输出错误信息，但不中断整体启动流程，保证系统稳定性。\n\n- **内存安全**：  \n  使用固定大小缓冲区（`MAX_BUF_LEN = 256`）并配合 `strscpy()` 防止溢出；CPU 掩码操作使用 `alloc_cpumask_var()` 动态分配。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/bootconfig.h>`：BootConfig 解析接口。\n  - `<linux/ftrace.h>`、`<linux/trace.h>`、`\"trace.h\"`：ftrace 核心 API 和内部结构。\n  - `<linux/trace_events.h>`：事件跟踪基础设施。\n\n- **条件编译依赖**：\n  - `CONFIG_EVENT_TRACING`：启用静态事件跟踪。\n  - `CONFIG_KPROBE_EVENTS`：支持 kprobe 动态事件。\n  - `CONFIG_SYNTH_EVENTS`：支持合成事件。\n  - `CONFIG_HIST_TRIGGERS`：支持直方图触发器。\n\n- **内核子系统交互**：\n  - **ftrace 子系统**：通过 `trace_set_options()`、`tracer_tracing_on/off()` 等接口控制跟踪行为。\n  - **Ring Buffer**：通过 `tracing_resize_ring_buffer()` 调整缓冲区。\n  - **CPU 热插拔**：通过 `tracing_set_cpumask()` 设置参与跟踪的 CPU 集合。\n\n## 5. 使用场景\n\n- **内核启动调试**：  \n  在系统早期初始化阶段自动启用特定跟踪事件（如调度器、内存分配），捕获传统用户空间工具无法观测的启动路径。\n\n- **自动化性能分析**：  \n  通过预置 BootConfig 配置，在每次启动时自动收集性能数据（如函数调用图、事件延迟），用于持续集成或基准测试。\n\n- **动态探针部署**：  \n  在无用户空间介入的情况下，于启动时注入 kprobe 探针监控关键函数，适用于嵌入式或安全受限环境。\n\n- **复杂事件关联**：  \n  利用合成事件和直方图触发器，在启动阶段实现跨事件的数据聚合与条件触发（如“当某函数延迟超过阈值时保存上下文”）。\n\n- **资源受限系统优化**：  \n  通过 `buffer_size` 和 `cpumask` 精确控制跟踪开销，避免在低内存或单核系统上影响启动性能。",
      "similarity": 0.6028772592544556,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace_boot.c",
            " * Tracing kernel boot-time",
            " */",
            "",
            "#define pr_fmt(fmt)\t\"trace_boot: \" fmt",
            "",
            "#include <linux/bootconfig.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace.h>",
            "#include <linux/trace_events.h>",
            "",
            "#include \"trace.h\"",
            "",
            "#define MAX_BUF_LEN 256",
            ""
          ],
          "function_name": null,
          "description": "定义trace_boot模块的基础头文件和宏，为跟踪启动时间相关功能提供基础设施。",
          "similarity": 0.5459886193275452
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 591,
          "end_line": 663,
          "content": [
            "static void __init",
            "trace_boot_enable_tracer(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tconst char *p;",
            "",
            "\ttrace_boot_set_ftrace_filter(tr, node);",
            "",
            "\tp = xbc_node_find_value(node, \"tracer\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (tracing_set_tracer(tr, p) < 0)",
            "\t\t\tpr_err(\"Failed to set given tracer: %s\\n\", p);",
            "\t}",
            "",
            "\t/* Since tracer can free snapshot buffer, allocate snapshot here.*/",
            "\tif (xbc_node_find_value(node, \"alloc_snapshot\", NULL)) {",
            "\t\tif (tracing_alloc_snapshot_instance(tr) < 0)",
            "\t\t\tpr_err(\"Failed to allocate snapshot buffer\\n\");",
            "\t}",
            "}",
            "static void __init",
            "trace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\ttrace_boot_set_instance_options(tr, node);",
            "\ttrace_boot_init_events(tr, node);",
            "\ttrace_boot_enable_events(tr, node);",
            "\ttrace_boot_enable_tracer(tr, node);",
            "}",
            "static void __init",
            "trace_boot_init_instances(struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *inode;",
            "\tstruct trace_array *tr;",
            "\tconst char *p;",
            "",
            "\tnode = xbc_node_find_subkey(node, \"instance\");",
            "\tif (!node)",
            "\t\treturn;",
            "",
            "\txbc_node_for_each_subkey(node, inode) {",
            "\t\tp = xbc_node_get_data(inode);",
            "\t\tif (!p || *p == '\\0')",
            "\t\t\tcontinue;",
            "",
            "\t\ttr = trace_array_get_by_name(p, NULL);",
            "\t\tif (!tr) {",
            "\t\t\tpr_err(\"Failed to get trace instance %s\\n\", p);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\ttrace_boot_init_one_instance(tr, inode);",
            "\t\ttrace_array_put(tr);",
            "\t}",
            "}",
            "static int __init trace_boot_init(void)",
            "{",
            "\tstruct xbc_node *trace_node;",
            "\tstruct trace_array *tr;",
            "",
            "\ttrace_node = xbc_find_node(\"ftrace\");",
            "\tif (!trace_node)",
            "\t\treturn 0;",
            "",
            "\ttr = top_trace_array();",
            "\tif (!tr)",
            "\t\treturn 0;",
            "",
            "\t/* Global trace array is also one instance */",
            "\ttrace_boot_init_one_instance(tr, trace_node);",
            "\ttrace_boot_init_instances(trace_node);",
            "",
            "\tdisable_tracing_selftest(\"running boot-time tracing\");",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "trace_boot_enable_tracer, trace_boot_init_one_instance, trace_boot_init_instances, trace_boot_init",
          "description": "该代码段实现了Boot-Time Tracing的初始化逻辑，核心功能是根据Xenon Boot Config（xbc）节点动态创建和配置跟踪实例。  \n`trace_boot_enable_tracer`启用指定tracer并分配快照缓冲区，`trace_boot_init_one_instance`初始化单个跟踪实例的事件与选项，`trace_boot_init_instances`遍历xbc节点注册多实例跟踪配置。  \n上下文不完整，缺少xbc_node结构体定义及部分辅助函数实现。",
          "similarity": 0.5119556188583374
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 453,
          "end_line": 577,
          "content": [
            "static void __init",
            "trace_boot_init_histograms(struct trace_event_file *file,",
            "\t\t\t   struct xbc_node *hnode, char *buf, size_t size)",
            "{",
            "\t/* do nothing */",
            "}",
            "static void __init",
            "trace_boot_init_one_event(struct trace_array *tr, struct xbc_node *gnode,",
            "\t\t\t  struct xbc_node *enode)",
            "{",
            "\tstruct trace_event_file *file;",
            "\tstruct xbc_node *anode;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tconst char *p, *group, *event;",
            "",
            "\tgroup = xbc_node_get_data(gnode);",
            "\tevent = xbc_node_get_data(enode);",
            "",
            "\tif (!strcmp(group, \"kprobes\"))",
            "\t\tif (trace_boot_add_kprobe_event(enode, event) < 0)",
            "\t\t\treturn;",
            "\tif (!strcmp(group, \"synthetic\"))",
            "\t\tif (trace_boot_add_synth_event(enode, event) < 0)",
            "\t\t\treturn;",
            "",
            "\tmutex_lock(&event_mutex);",
            "\tfile = find_event_file(tr, group, event);",
            "\tif (!file) {",
            "\t\tpr_err(\"Failed to find event: %s:%s\\n\", group, event);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tp = xbc_node_find_value(enode, \"filter\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0)",
            "\t\t\tpr_err(\"filter string is too long: %s\\n\", p);",
            "\t\telse if (apply_event_filter(file, buf) < 0)",
            "\t\t\tpr_err(\"Failed to apply filter: %s\\n\", buf);",
            "\t}",
            "",
            "\tif (IS_ENABLED(CONFIG_HIST_TRIGGERS)) {",
            "\t\txbc_node_for_each_array_value(enode, \"actions\", anode, p) {",
            "\t\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0)",
            "\t\t\t\tpr_err(\"action string is too long: %s\\n\", p);",
            "\t\t\telse if (trigger_process_regex(file, buf) < 0)",
            "\t\t\t\tpr_err(\"Failed to apply an action: %s\\n\", p);",
            "\t\t}",
            "\t\tanode = xbc_node_find_subkey(enode, \"hist\");",
            "\t\tif (anode)",
            "\t\t\ttrace_boot_init_histograms(file, anode, buf, ARRAY_SIZE(buf));",
            "\t} else if (xbc_node_find_value(enode, \"actions\", NULL))",
            "\t\tpr_err(\"Failed to apply event actions because CONFIG_HIST_TRIGGERS is not set.\\n\");",
            "",
            "\tif (xbc_node_find_value(enode, \"enable\", NULL)) {",
            "\t\tif (trace_event_enable_disable(file, 1, 0) < 0)",
            "\t\t\tpr_err(\"Failed to enable event node: %s:%s\\n\",",
            "\t\t\t\tgroup, event);",
            "\t}",
            "out:",
            "\tmutex_unlock(&event_mutex);",
            "}",
            "static void __init",
            "trace_boot_init_events(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *gnode, *enode;",
            "\tbool enable, enable_all = false;",
            "\tconst char *data;",
            "",
            "\tnode = xbc_node_find_subkey(node, \"event\");",
            "\tif (!node)",
            "\t\treturn;",
            "\t/* per-event key starts with \"event.GROUP.EVENT\" */",
            "\txbc_node_for_each_subkey(node, gnode) {",
            "\t\tdata = xbc_node_get_data(gnode);",
            "\t\tif (!strcmp(data, \"enable\")) {",
            "\t\t\tenable_all = true;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tenable = false;",
            "\t\txbc_node_for_each_subkey(gnode, enode) {",
            "\t\t\tdata = xbc_node_get_data(enode);",
            "\t\t\tif (!strcmp(data, \"enable\")) {",
            "\t\t\t\tenable = true;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\ttrace_boot_init_one_event(tr, gnode, enode);",
            "\t\t}",
            "\t\t/* Event enablement must be done after event settings */",
            "\t\tif (enable) {",
            "\t\t\tdata = xbc_node_get_data(gnode);",
            "\t\t\ttrace_array_set_clr_event(tr, data, NULL, true);",
            "\t\t}",
            "\t}",
            "\t/* Ditto */",
            "\tif (enable_all)",
            "\t\ttrace_array_set_clr_event(tr, NULL, NULL, true);",
            "}",
            "static void __init",
            "trace_boot_set_ftrace_filter(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *anode;",
            "\tconst char *p;",
            "\tchar *q;",
            "",
            "\txbc_node_for_each_array_value(node, \"ftrace.filters\", anode, p) {",
            "\t\tq = kstrdup(p, GFP_KERNEL);",
            "\t\tif (!q)",
            "\t\t\treturn;",
            "\t\tif (ftrace_set_filter(tr->ops, q, strlen(q), 0) < 0)",
            "\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);",
            "\t\telse",
            "\t\t\tftrace_filter_param = true;",
            "\t\tkfree(q);",
            "\t}",
            "\txbc_node_for_each_array_value(node, \"ftrace.notraces\", anode, p) {",
            "\t\tq = kstrdup(p, GFP_KERNEL);",
            "\t\tif (!q)",
            "\t\t\treturn;",
            "\t\tif (ftrace_set_notrace(tr->ops, q, strlen(q), 0) < 0)",
            "\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);",
            "\t\telse",
            "\t\t\tftrace_filter_param = true;",
            "\t\tkfree(q);",
            "\t}",
            "}"
          ],
          "function_name": "trace_boot_init_histograms, trace_boot_init_one_event, trace_boot_init_events, trace_boot_set_ftrace_filter",
          "description": "初始化事件及其过滤器设置，包含被覆盖的空实现函数及事件启用逻辑，处理ftrace过滤器参数注册。",
          "similarity": 0.4626009464263916
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 297,
          "end_line": 427,
          "content": [
            "static int __init",
            "trace_boot_hist_add_handlers(struct xbc_node *hnode, char **bufp,",
            "\t\t\t     char *end, const char *param)",
            "{",
            "\tstruct xbc_node *node;",
            "\tconst char *p, *handler;",
            "\tint ret = 0;",
            "",
            "\thandler = xbc_node_get_data(hnode);",
            "",
            "\txbc_node_for_each_subkey(hnode, node) {",
            "\t\tp = xbc_node_get_data(node);",
            "\t\tif (!isdigit(p[0]))",
            "\t\t\tcontinue;",
            "\t\t/* All digit started node should be instances. */",
            "\t\tret = trace_boot_hist_add_one_handler(node, bufp, end, handler, param);",
            "\t\tif (ret < 0)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\tif (xbc_node_find_subkey(hnode, param))",
            "\t\tret = trace_boot_hist_add_one_handler(hnode, bufp, end, handler, param);",
            "",
            "\treturn ret;",
            "}",
            "static int __init",
            "trace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)",
            "{",
            "\tstruct xbc_node *node, *knode;",
            "\tchar *end = buf + size;",
            "\tconst char *p;",
            "\tint ret = 0;",
            "",
            "\tappend_printf(&buf, end, \"hist\");",
            "",
            "\tret = trace_boot_hist_add_array(hnode, &buf, end, \"keys\");",
            "\tif (ret < 0) {",
            "\t\tif (ret == -ENOENT)",
            "\t\t\tpr_err(\"hist requires keys.\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tret = trace_boot_hist_add_array(hnode, &buf, end, \"values\");",
            "\tif (ret == -EINVAL)",
            "\t\treturn ret;",
            "\tret = trace_boot_hist_add_array(hnode, &buf, end, \"sort\");",
            "\tif (ret == -EINVAL)",
            "\t\treturn ret;",
            "",
            "\tp = xbc_node_find_value(hnode, \"size\", NULL);",
            "\tif (p)",
            "\t\tappend_printf(&buf, end, \":size=%s\", p);",
            "",
            "\tp = xbc_node_find_value(hnode, \"name\", NULL);",
            "\tif (p)",
            "\t\tappend_printf(&buf, end, \":name=%s\", p);",
            "",
            "\tnode = xbc_node_find_subkey(hnode, \"var\");",
            "\tif (node) {",
            "\t\txbc_node_for_each_key_value(node, knode, p) {",
            "\t\t\t/* Expression must not include spaces. */",
            "\t\t\tappend_printf(&buf, end, \":%s=\",",
            "\t\t\t\t      xbc_node_get_data(knode));",
            "\t\t\tappend_str_nospace(&buf, end, p);",
            "\t\t}",
            "\t}",
            "",
            "\t/* Histogram control attributes (mutual exclusive) */",
            "\tif (xbc_node_find_value(hnode, \"pause\", NULL))",
            "\t\tappend_printf(&buf, end, \":pause\");",
            "\telse if (xbc_node_find_value(hnode, \"continue\", NULL))",
            "\t\tappend_printf(&buf, end, \":continue\");",
            "\telse if (xbc_node_find_value(hnode, \"clear\", NULL))",
            "\t\tappend_printf(&buf, end, \":clear\");",
            "",
            "\t/* Histogram handler and actions */",
            "\tnode = xbc_node_find_subkey(hnode, \"onmax\");",
            "\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)",
            "\t\treturn -EINVAL;",
            "\tnode = xbc_node_find_subkey(hnode, \"onchange\");",
            "\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)",
            "\t\treturn -EINVAL;",
            "\tnode = xbc_node_find_subkey(hnode, \"onmatch\");",
            "\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"event\") < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tp = xbc_node_find_value(hnode, \"filter\", NULL);",
            "\tif (p)",
            "\t\tappend_printf(&buf, end, \" if %s\", p);",
            "",
            "\tif (buf == end) {",
            "\t\tpr_err(\"hist exceeds the max command length.\\n\");",
            "\t\treturn -E2BIG;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void __init",
            "trace_boot_init_histograms(struct trace_event_file *file,",
            "\t\t\t   struct xbc_node *hnode, char *buf, size_t size)",
            "{",
            "\tstruct xbc_node *node;",
            "\tconst char *p;",
            "\tchar *tmp;",
            "",
            "\txbc_node_for_each_subkey(hnode, node) {",
            "\t\tp = xbc_node_get_data(node);",
            "\t\tif (!isdigit(p[0]))",
            "\t\t\tcontinue;",
            "\t\t/* All digit started node should be instances. */",
            "\t\tif (trace_boot_compose_hist_cmd(node, buf, size) == 0) {",
            "\t\t\ttmp = kstrdup(buf, GFP_KERNEL);",
            "\t\t\tif (!tmp)",
            "\t\t\t\treturn;",
            "\t\t\tif (trigger_process_regex(file, buf) < 0)",
            "\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);",
            "\t\t\tkfree(tmp);",
            "\t\t}",
            "\t}",
            "",
            "\tif (xbc_node_find_subkey(hnode, \"keys\")) {",
            "\t\tif (trace_boot_compose_hist_cmd(hnode, buf, size) == 0) {",
            "\t\t\ttmp = kstrdup(buf, GFP_KERNEL);",
            "\t\t\tif (!tmp)",
            "\t\t\t\treturn;",
            "\t\t\tif (trigger_process_regex(file, buf) < 0)",
            "\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);",
            "\t\t\tkfree(tmp);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "trace_boot_hist_add_handlers, trace_boot_compose_hist_cmd, trace_boot_init_histograms",
          "description": "构建直方图控制命令字符串，组合关键字、值、排序等参数，并处理事件触发动作配置。",
          "similarity": 0.41129690408706665
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 24,
          "end_line": 129,
          "content": [
            "static void __init",
            "trace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *anode;",
            "\tconst char *p;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tunsigned long v = 0;",
            "",
            "\t/* Common ftrace options */",
            "\txbc_node_for_each_array_value(node, \"options\", anode, p) {",
            "\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0) {",
            "\t\t\tpr_err(\"String is too long: %s\\n\", p);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (trace_set_options(tr, buf) < 0)",
            "\t\t\tpr_err(\"Failed to set option: %s\\n\", buf);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"tracing_on\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (kstrtoul(p, 10, &v))",
            "\t\t\tpr_err(\"Failed to set tracing on: %s\\n\", p);",
            "\t\tif (v)",
            "\t\t\ttracer_tracing_on(tr);",
            "\t\telse",
            "\t\t\ttracer_tracing_off(tr);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"trace_clock\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (tracing_set_clock(tr, p) < 0)",
            "\t\t\tpr_err(\"Failed to set trace clock: %s\\n\", p);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"buffer_size\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tv = memparse(p, NULL);",
            "\t\tif (v < PAGE_SIZE)",
            "\t\t\tpr_err(\"Buffer size is too small: %s\\n\", p);",
            "\t\tif (tracing_resize_ring_buffer(tr, v, RING_BUFFER_ALL_CPUS) < 0)",
            "\t\t\tpr_err(\"Failed to resize trace buffer to %s\\n\", p);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"cpumask\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tcpumask_var_t new_mask;",
            "",
            "\t\tif (alloc_cpumask_var(&new_mask, GFP_KERNEL)) {",
            "\t\t\tif (cpumask_parse(p, new_mask) < 0 ||",
            "\t\t\t    tracing_set_cpumask(tr, new_mask) < 0)",
            "\t\t\t\tpr_err(\"Failed to set new CPU mask %s\\n\", p);",
            "\t\t\tfree_cpumask_var(new_mask);",
            "\t\t}",
            "\t}",
            "}",
            "static void __init",
            "trace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *anode;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tconst char *p;",
            "",
            "\txbc_node_for_each_array_value(node, \"events\", anode, p) {",
            "\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0) {",
            "\t\t\tpr_err(\"String is too long: %s\\n\", p);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (ftrace_set_clr_event(tr, buf, 1) < 0)",
            "\t\t\tpr_err(\"Failed to enable event: %s\\n\", p);",
            "\t}",
            "}",
            "static int __init",
            "trace_boot_add_kprobe_event(struct xbc_node *node, const char *event)",
            "{",
            "\tstruct dynevent_cmd cmd;",
            "\tstruct xbc_node *anode;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tconst char *val;",
            "\tint ret = 0;",
            "",
            "\txbc_node_for_each_array_value(node, \"probes\", anode, val) {",
            "\t\tkprobe_event_cmd_init(&cmd, buf, MAX_BUF_LEN);",
            "",
            "\t\tret = kprobe_event_gen_cmd_start(&cmd, event, val);",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"Failed to generate probe: %s\\n\", buf);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tret = kprobe_event_gen_cmd_end(&cmd);",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"Failed to add probe: %s\\n\", buf);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static inline int __init",
            "trace_boot_add_kprobe_event(struct xbc_node *node, const char *event)",
            "{",
            "\tpr_err(\"Kprobe event is not supported.\\n\");",
            "\treturn -ENOTSUPP;",
            "}"
          ],
          "function_name": "trace_boot_set_instance_options, trace_boot_enable_events, trace_boot_add_kprobe_event, trace_boot_add_kprobe_event",
          "description": "实现初始化跟踪实例选项设置、事件启用、kprobe事件添加等功能，包含重复定义的函数导致潜在冲突。",
          "similarity": 0.40720105171203613
        }
      ]
    },
    {
      "source_file": "kernel/exec_domain.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:26:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `exec_domain.c`\n\n---\n\n# exec_domain.c 技术文档\n\n## 1. 文件概述\n\n`exec_domain.c` 是 Linux 内核中用于管理不同 ABI（Application Binary Interface，应用程序二进制接口）执行域（execution domains）的核心文件。该文件实现了对“personality”机制的支持，允许进程在运行时切换其行为模式，以兼容不同操作系统或 ABI 的语义，例如信号处理、系统调用编号映射等。当前实现主要保留了基础框架，并默认仅支持标准 Linux personality。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`SYSCALL_DEFINE1(personality, unsigned int, personality)`**  \n  系统调用入口，用于获取或设置当前进程的 personality。若传入参数不为 `0xffffffff`，则调用 `set_personality()` 更新当前进程的 personality；无论是否更新，均返回旧值。\n\n- **`execdomains_proc_show(struct seq_file *m, void *v)`**（条件编译）  \n  在 `/proc/execdomains` 文件中输出当前内核支持的执行域列表。当前仅输出标准 Linux 执行域（ID 0-0）。\n\n- **`proc_execdomains_init(void)`**（条件编译）  \n  初始化 `/proc/execdomains` 接口，仅在 `CONFIG_PROC_FS` 配置启用时编译。\n\n## 3. 关键实现\n\n- **Personality 机制**：  \n  每个进程的 `task_struct` 中包含 `personality` 字段，用于标识其当前的执行域行为。通过 `personality()` 系统调用可动态切换该值，从而影响内核对信号、路径解析、系统调用等行为的处理方式。\n\n- **执行域注册与查询**：  \n  历史上 Linux 支持多种执行域（如 SVr4、BSD、OSF 等），但现代内核已移除大部分实现，仅保留 Linux 原生执行域（ID 0）。`/proc/execdomains` 接口静态返回 `\"0-0\\tLinux\\t[kernel]\\n\"`，表明当前仅支持标准 Linux ABI。\n\n- **系统调用接口**：  \n  `personality()` 系统调用是用户空间与内核 personality 机制交互的唯一入口。传入 `0xffffffff` 可用于仅查询当前值而不修改。\n\n- **模块初始化**：  \n  若启用了 `CONFIG_PROC_FS`，则在内核初始化阶段通过 `module_init()` 注册 `/proc/execdomains` 文件，供用户空间查询支持的执行域。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/personality.h>`：定义 personality 相关常量和 `set_personality()` 函数。\n  - `<linux/sched.h>`：访问 `current` 宏以获取当前进程的 `task_struct`。\n  - `<linux/proc_fs.h>` 和 `<linux/seq_file.h>`：用于实现 `/proc/execdomains` 接口。\n  - `<linux/syscalls.h>`：用于定义系统调用。\n  - 其他通用内核头文件（如 `init.h`, `kernel.h`, `module.h` 等）。\n\n- **内核配置依赖**：\n  - `CONFIG_PROC_FS`：控制是否编译 `/proc/execdomains` 接口。\n\n- **外部模块交互**：\n  - 该文件不导出符号供其他模块使用，属于内核核心 ABI 支持层。\n  - `set_personality()` 的具体实现位于 `kernel/sys.c` 中。\n\n## 5. 使用场景\n\n- **兼容性运行环境**：  \n  在早期 Linux 中，用于运行非 Linux 二进制程序（如通过 binfmt 模块加载的 SVr4 或 BSD 程序），通过设置特定 personality 使内核模拟目标系统的 ABI 行为。\n\n- **调试与沙箱**：  \n  用户空间程序可通过 `personality(PER_LINUX)` 或其他标志（如 `ADDR_NO_RANDOMIZE`）临时修改进程行为，例如禁用 ASLR 以辅助调试。\n\n- **系统信息查询**：  \n  用户可通过读取 `/proc/execdomains` 了解当前内核支持的执行域类型（尽管现代系统通常仅显示 Linux）。\n\n- **容器与虚拟化**：  \n  在某些轻量级虚拟化场景中，可通过 personality 机制微调进程的系统调用行为，但现代方案更多依赖 seccomp 或 namespaces。",
      "similarity": 0.5842471122741699,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/exec_domain.c",
          "start_line": 24,
          "end_line": 33,
          "content": [
            "static int execdomains_proc_show(struct seq_file *m, void *v)",
            "{",
            "\tseq_puts(m, \"0-0\\tLinux           \\t[kernel]\\n\");",
            "\treturn 0;",
            "}",
            "static int __init proc_execdomains_init(void)",
            "{",
            "\tproc_create_single(\"execdomains\", 0, NULL, execdomains_proc_show);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "execdomains_proc_show, proc_execdomains_init",
          "description": "定义用于 /proc/execdomains 文件的读取回调函数及初始化函数，通过 proc_create_single 创建 proc 文件节点以暴露当前系统运行的执行域标识及其关联的 ABI 类型信息",
          "similarity": 0.45534417033195496
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/exec_domain.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Handling of different ABIs (personalities).",
            " *",
            " * We group personalities into execution domains which have their",
            " * own handlers for kernel entry points, signal mapping, etc...",
            " *",
            " * 2001-05-06\tComplete rewrite,  Christoph Hellwig (hch@infradead.org)",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kmod.h>",
            "#include <linux/module.h>",
            "#include <linux/personality.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/types.h>",
            "",
            "#ifdef CONFIG_PROC_FS"
          ],
          "function_name": null,
          "description": "此代码块包含执行域（exec domain）相关的头文件声明，启用对 PROC_FS 的支持以实现 ABI 特性处理，因代码片段未展示核心逻辑故标记上下文不完整",
          "similarity": 0.42561662197113037
        }
      ]
    }
  ]
}