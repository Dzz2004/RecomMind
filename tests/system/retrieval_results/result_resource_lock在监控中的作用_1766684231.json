{
  "query": "resource_lock在监控中的作用",
  "timestamp": "2025-12-26 01:37:11",
  "retrieved_files": [
    {
      "source_file": "kernel/trace/rethook.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:06:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\rethook.c`\n\n---\n\n# `trace/rethook.c` 技术文档\n\n## 1. 文件概述\n\n`rethook.c` 实现了 Linux 内核中的 **rethook（Return Hook）** 机制，这是一种通用的函数返回拦截框架，用于在函数返回时执行回调处理。该机制为 kretprobes、ftrace 等动态追踪工具提供底层支持，允许在函数返回点安全地插入处理逻辑，同时管理返回地址的重写与恢复。rethook 使用 per-task 的无锁链表（LLIST）作为“影子栈”来跟踪活跃的 hook 节点，并结合 RCU 和引用计数实现内存安全的生命周期管理。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct rethook`：rethook 实例，包含回调函数指针、私有数据、节点池（freelist）和引用计数。\n- `struct rethook_node`：单个 hook 节点，嵌入在用户数据结构中，包含返回地址、帧指针、所属 rethook 指针及链表/空闲链表节点。\n\n### 主要函数\n| 函数 | 功能描述 |\n|------|--------|\n| `rethook_alloc()` | 分配并初始化一个新的 `rethook` 实例 |\n| `rethook_free()` / `rethook_stop()` | 停止并异步释放 `rethook` 实例 |\n| `rethook_add_node()` | 向 rethook 添加预分配的节点 |\n| `rethook_try_get()` | 从 rethook 的空闲池中获取一个未使用的节点（需禁用抢占） |\n| `rethook_hook()` | 在函数入口处注册返回 hook，将节点加入当前任务的 rethook 链表 |\n| `rethook_recycle()` | 回收 hook 节点：若 rethook 有效则归还到空闲池，否则异步释放 |\n| `rethook_find_ret_addr()` | 在指定任务的 rethook 链表中查找与给定帧指针对应的真实返回地址 |\n| `rethook_flush_task()` | 在任务退出时清理其所有未返回的 rethook 节点 |\n\n## 3. 关键实现\n\n### 影子栈与任务绑定\n- 每个 `task_struct` 包含一个 `rethooks` 字段（`struct llist_head`），用于存储该任务当前活跃的所有 `rethook_node`。\n- 使用无锁链表（LLIST）实现高效、并发安全的插入（`__llist_add`）和批量删除（`__llist_del_all`）。\n\n### 内存与生命周期管理\n- **引用计数**：`rethook` 的 `ref` 字段初始为 1，每添加一个节点加 1；节点回收时减 1。当引用归零且节点池清空后，`rethook` 本体被释放。\n- **RCU 安全**：通过 `rcu_assign_pointer()` 和 `rcu_dereference_check()` 管理 `handler` 指针的读写，确保在 RCU 读侧临界区内安全访问。\n- **延迟释放**：`rethook_free()` 和无效节点的回收均通过 `call_rcu()` 异步执行，避免在中断或原子上下文中释放内存。\n\n### 上下文感知的 Hook 注入\n- `rethook_hook()` 接收 `mcount` 参数区分调用上下文（ftrace vs kprobe），由架构相关代码（`arch_rethook_prepare()`）决定如何修改返回地址（例如插入 trampoline）。\n- 要求调用者处于 RCU 可用上下文（`rcu_is_watching()`），确保后续的 RCU 回调能正确执行。\n\n### 返回地址恢复\n- `rethook_find_ret_addr()` 遍历任务的 rethook 链表，跳过 trampoline 地址，返回与指定栈帧匹配的真实返回地址，用于栈回溯修正。\n\n## 4. 依赖关系\n\n- **架构依赖**：依赖 `arch_rethook_prepare()` 和 `arch_rethook_trampoline`（由各架构实现），用于实际修改返回地址和提供 trampoline 函数。\n- **内核子系统**：\n  - `<linux/rcu.h>`：RCU 同步机制\n  - `<linux/slab.h>`：动态内存分配\n  - `<linux/preempt.h>`：抢占控制\n  - `<linux/kprobes.h>`：与 kretprobes 集成\n  - `<linux/freelist.h>`：无锁空闲链表实现\n- **任务管理**：依赖 `task_struct::rethooks` 字段和 `delayed_put_task_struct()` 回调。\n\n## 5. 使用场景\n\n- **kretprobes 实现**：作为 kretprobe 的底层机制，拦截函数返回并执行用户定义的处理函数。\n- **ftrace 动态追踪**：在 function graph tracer 等场景中，用于捕获函数返回事件。\n- **内核栈回溯修正**：当函数返回地址被 trampoline 覆盖时，通过 `rethook_find_ret_addr()` 恢复原始调用栈。\n- **安全监控与性能分析**：第三方模块可基于 rethook 框架实现函数级的返回行为监控或统计。",
      "similarity": 0.5955362319946289,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/rethook.c",
          "start_line": 22,
          "end_line": 131,
          "content": [
            "void rethook_flush_task(struct task_struct *tk)",
            "{",
            "\tstruct rethook_node *rhn;",
            "\tstruct llist_node *node;",
            "",
            "\tnode = __llist_del_all(&tk->rethooks);",
            "\twhile (node) {",
            "\t\trhn = container_of(node, struct rethook_node, llist);",
            "\t\tnode = node->next;",
            "\t\tpreempt_disable();",
            "\t\trethook_recycle(rhn);",
            "\t\tpreempt_enable();",
            "\t}",
            "}",
            "static void rethook_free_rcu(struct rcu_head *head)",
            "{",
            "\tstruct rethook *rh = container_of(head, struct rethook, rcu);",
            "\tobjpool_fini(&rh->pool);",
            "}",
            "void rethook_stop(struct rethook *rh)",
            "{",
            "\trcu_assign_pointer(rh->handler, NULL);",
            "}",
            "void rethook_free(struct rethook *rh)",
            "{",
            "\trethook_stop(rh);",
            "",
            "\tcall_rcu(&rh->rcu, rethook_free_rcu);",
            "}",
            "static int rethook_init_node(void *nod, void *context)",
            "{",
            "\tstruct rethook_node *node = nod;",
            "",
            "\tnode->rethook = context;",
            "\treturn 0;",
            "}",
            "static int rethook_fini_pool(struct objpool_head *head, void *context)",
            "{",
            "\tkfree(context);",
            "\treturn 0;",
            "}",
            "static inline rethook_handler_t rethook_get_handler(struct rethook *rh)",
            "{",
            "\treturn (rethook_handler_t)rcu_dereference_check(rh->handler,",
            "\t\t\t\t\t\t\trcu_read_lock_any_held());",
            "}",
            "static void free_rethook_node_rcu(struct rcu_head *head)",
            "{",
            "\tstruct rethook_node *node = container_of(head, struct rethook_node, rcu);",
            "\tstruct rethook *rh = node->rethook;",
            "",
            "\tobjpool_drop(node, &rh->pool);",
            "}",
            "void rethook_recycle(struct rethook_node *node)",
            "{",
            "\trethook_handler_t handler;",
            "",
            "\thandler = rethook_get_handler(node->rethook);",
            "\tif (likely(handler))",
            "\t\tobjpool_push(node, &node->rethook->pool);",
            "\telse",
            "\t\tcall_rcu(&node->rcu, free_rethook_node_rcu);",
            "}",
            "void rethook_hook(struct rethook_node *node, struct pt_regs *regs, bool mcount)",
            "{",
            "\tarch_rethook_prepare(node, regs, mcount);",
            "\t__llist_add(&node->llist, &current->rethooks);",
            "}",
            "static unsigned long __rethook_find_ret_addr(struct task_struct *tsk,",
            "\t\t\t\t\t     struct llist_node **cur)",
            "{",
            "\tstruct rethook_node *rh = NULL;",
            "\tstruct llist_node *node = *cur;",
            "",
            "\tif (!node)",
            "\t\tnode = tsk->rethooks.first;",
            "\telse",
            "\t\tnode = node->next;",
            "",
            "\twhile (node) {",
            "\t\trh = container_of(node, struct rethook_node, llist);",
            "\t\tif (rh->ret_addr != (unsigned long)arch_rethook_trampoline) {",
            "\t\t\t*cur = node;",
            "\t\t\treturn rh->ret_addr;",
            "\t\t}",
            "\t\tnode = node->next;",
            "\t}",
            "\treturn 0;",
            "}",
            "unsigned long rethook_find_ret_addr(struct task_struct *tsk, unsigned long frame,",
            "\t\t\t\t    struct llist_node **cur)",
            "{",
            "\tstruct rethook_node *rhn = NULL;",
            "\tunsigned long ret;",
            "",
            "\tif (WARN_ON_ONCE(!cur))",
            "\t\treturn 0;",
            "",
            "\tif (WARN_ON_ONCE(tsk != current && task_is_running(tsk)))",
            "\t\treturn 0;",
            "",
            "\tdo {",
            "\t\tret = __rethook_find_ret_addr(tsk, cur);",
            "\t\tif (!ret)",
            "\t\t\tbreak;",
            "\t\trhn = container_of(*cur, struct rethook_node, llist);",
            "\t} while (rhn->frame != frame);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "rethook_flush_task, rethook_free_rcu, rethook_stop, rethook_free, rethook_init_node, rethook_fini_pool, rethook_get_handler, free_rethook_node_rcu, rethook_recycle, rethook_hook, __rethook_find_ret_addr, rethook_find_ret_addr",
          "description": "实现rethook节点的生命周期管理，包含RCU安全释放、池化内存管理、影子堆栈操作及异常返回地址查找逻辑",
          "similarity": 0.545533299446106
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/rethook.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#define pr_fmt(fmt) \"rethook: \" fmt",
            "",
            "#include <linux/bug.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/preempt.h>",
            "#include <linux/rethook.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "",
            "/* Return hook list (shadow stack by list) */",
            "",
            "/*",
            " * This function is called from delayed_put_task_struct() when a task is",
            " * dead and cleaned up to recycle any kretprobe instances associated with",
            " * this task. These left over instances represent probed functions that",
            " * have been called but will never return.",
            " */"
          ],
          "function_name": null,
          "description": "定义rethook模块的基础结构及函数声明，用于在任务终止时回收关联的kretprobe实例，防止僵尸探针残留",
          "similarity": 0.5134559869766235
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/rethook.c",
          "start_line": 267,
          "end_line": 334,
          "content": [
            "void __weak arch_rethook_fixup_return(struct pt_regs *regs,",
            "\t\t\t\t      unsigned long correct_ret_addr)",
            "{",
            "\t/*",
            "\t * Do nothing by default. If the architecture which uses a",
            "\t * frame pointer to record real return address on the stack,",
            "\t * it should fill this function to fixup the return address",
            "\t * so that stacktrace works from the rethook handler.",
            "\t */",
            "}",
            "unsigned long rethook_trampoline_handler(struct pt_regs *regs,",
            "\t\t\t\t\t unsigned long frame)",
            "{",
            "\tstruct llist_node *first, *node = NULL;",
            "\tunsigned long correct_ret_addr;",
            "\trethook_handler_t handler;",
            "\tstruct rethook_node *rhn;",
            "",
            "\tcorrect_ret_addr = __rethook_find_ret_addr(current, &node);",
            "\tif (!correct_ret_addr) {",
            "\t\tpr_err(\"rethook: Return address not found! Maybe there is a bug in the kernel\\n\");",
            "\t\tBUG_ON(1);",
            "\t}",
            "",
            "\tinstruction_pointer_set(regs, correct_ret_addr);",
            "",
            "\t/*",
            "\t * These loops must be protected from rethook_free_rcu() because those",
            "\t * are accessing 'rhn->rethook'.",
            "\t */",
            "\tpreempt_disable_notrace();",
            "",
            "\t/*",
            "\t * Run the handler on the shadow stack. Do not unlink the list here because",
            "\t * stackdump inside the handlers needs to decode it.",
            "\t */",
            "\tfirst = current->rethooks.first;",
            "\twhile (first) {",
            "\t\trhn = container_of(first, struct rethook_node, llist);",
            "\t\tif (WARN_ON_ONCE(rhn->frame != frame))",
            "\t\t\tbreak;",
            "\t\thandler = rethook_get_handler(rhn->rethook);",
            "\t\tif (handler)",
            "\t\t\thandler(rhn, rhn->rethook->data,",
            "\t\t\t\tcorrect_ret_addr, regs);",
            "",
            "\t\tif (first == node)",
            "\t\t\tbreak;",
            "\t\tfirst = first->next;",
            "\t}",
            "",
            "\t/* Fixup registers for returning to correct address. */",
            "\tarch_rethook_fixup_return(regs, correct_ret_addr);",
            "",
            "\t/* Unlink used shadow stack */",
            "\tfirst = current->rethooks.first;",
            "\tcurrent->rethooks.first = node->next;",
            "\tnode->next = NULL;",
            "",
            "\twhile (first) {",
            "\t\trhn = container_of(first, struct rethook_node, llist);",
            "\t\tfirst = first->next;",
            "\t\trethook_recycle(rhn);",
            "\t}",
            "\tpreempt_enable_notrace();",
            "",
            "\treturn correct_ret_addr;",
            "}"
          ],
          "function_name": "arch_rethook_fixup_return, rethook_trampoline_handler",
          "description": "提供架构无关的返回地址修复接口与trampoline处理函数，协调影子堆栈遍历、处理程序执行及寄存器状态恢复流程",
          "similarity": 0.45217788219451904
        }
      ]
    },
    {
      "source_file": "kernel/trace/rv/rv.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:10:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\rv\\rv.c`\n\n---\n\n# `trace/rv/rv.c` 技术文档\n\n## 1. 文件概述\n\n`rv.c` 是 Linux 内核中运行时验证（Runtime Verification, RV）子系统的主接口实现文件。该文件提供了注册、启用、禁用运行时监控器（monitor）的统一接口，并实现了用户空间与内核 RV 子系统交互的 tracefs 文件系统接口。RV 通过将内核实际执行轨迹与形式化规范进行比对，实现对关键行为的实时监控与异常响应，适用于安全关键系统。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct rv_monitor`**  \n  定义运行时监控器的回调接口，包括 `enable()` 和 `disable()` 等函数指针，用于挂载/卸载内核追踪点。\n\n- **`struct rv_monitor_def`**  \n  监控器定义结构体，封装 `rv_monitor` 实例及其元数据（如名称、描述、启用状态等）。\n\n- **`struct rv_interface`**  \n  表示 RV 子系统的根接口结构，包含 tracefs 目录项（如 `monitors_dir`）。\n\n- **`task_monitor_slots[]` 与 `task_monitor_count`**  \n  管理 per-task 监控器槽位的位图与计数器，限制同时启用的 per-task 监控器数量（上限为 `RV_PER_TASK_MONITORS`）。\n\n### 主要函数\n\n- **`rv_register_monitor()` / `rv_unregister_monitor()`**  \n  用于向 RV 子系统注册或注销一个监控器。\n\n- **`rv_get_task_monitor_slot()` / `rv_put_task_monitor_slot()`**  \n  分配和释放 per-task 监控器槽位，确保不超过系统限制。\n\n- **`__rv_disable_monitor()` / `rv_disable_monitor()`**  \n  禁用已启用的监控器，可选择是否同步等待所有追踪点执行完成（通过 `tracepoint_synchronize_unregister()`）。\n\n- **`monitor_enable_read_data()`**  \n  实现 tracefs 中每个监控器目录下 `enable` 文件的读取操作，返回当前启用状态（\"0\\n\" 或 \"1\\n\"）。\n\n- **`get_monitors_root()`**  \n  返回 tracefs 中 `monitors/` 目录的 dentry，供其他模块创建子目录使用。\n\n## 3. 关键实现\n\n- **互斥锁保护**  \n  全局互斥锁 `rv_interface_lock` 保护所有监控器注册、启用/禁用及槽位分配操作，确保并发安全。\n\n- **槽位管理机制**  \n  使用位图 `task_monitor_slots[]` 和计数器 `task_monitor_count` 跟踪 per-task 监控器资源使用情况，防止超额分配。\n\n- **同步禁用机制**  \n  在禁用监控器时调用 `tracepoint_synchronize_unregister()`，确保所有 CPU 上的追踪点回调执行完毕后再释放资源，避免竞态导致的数据不一致。\n\n- **tracefs 接口布局**  \n  模仿内核 tracing 子系统的 `events/` 目录结构，在 tracefs 下创建：\n  - `available_monitors`：列出所有已注册监控器\n  - `enabled_monitors`：控制监控器启用/禁用（支持前缀 `!` 禁用和清空禁用全部）\n  - `monitoring_on`：全局开关，暂停所有监控逻辑但不卸载追踪点\n  - `monitors/<name>/`：每个监控器的专属目录，包含 `desc`（描述）和 `enable`（状态控制）文件\n\n- **Lockdep 断言**  \n  关键函数（如槽位分配/释放、监控器禁用）使用 `lockdep_assert_held(&rv_interface_lock)` 确保调用者已持有锁，增强代码健壮性。\n\n## 4. 依赖关系\n\n- **内核追踪子系统**  \n  依赖 tracepoint 机制实现事件注入，使用 `tracepoint_synchronize_unregister()` 进行同步。\n  \n- **tracefs 文件系统**  \n  通过 tracefs 暴露用户接口，依赖 `<linux/fs.h>` 和 dentry 操作。\n\n- **内存管理**  \n  使用 `kmalloc()`/`kfree()`（通过 `rv.h` 中的封装）管理监控器定义结构体内存。\n\n- **模块系统**  \n  作为可加载模块实现（`MODULE_LICENSE(\"GPL\")`），支持动态加载/卸载。\n\n- **RV 子系统头文件**  \n  包含本地头文件 `\"rv.h\"`，定义监控器结构、常量（如 `RV_PER_TASK_MONITORS`）和辅助函数。\n\n- **DA_MON_EVENTS 支持**  \n  若配置 `CONFIG_DA_MON_EVENTS`，则生成 RV 专用追踪点（`<trace/events/rv.h>`）。\n\n## 5. 使用场景\n\n- **形式化验证集成**  \n  作为学术研究（如论文 *Efficient formal verification for the Linux kernel*）的工程实现，将自动机模型与内核实例绑定。\n\n- **实时行为监控**  \n  在安全关键系统（如工业控制、自动驾驶）中监控内核行为是否违反预定义规范（如“禁止在中断上下文中睡眠”）。\n\n- **调试与诊断**  \n  开发者通过启用特定监控器（如 `wip`、`wwnr`）捕获复杂并发 bug 或时序违规。\n\n- **动态策略执行**  \n  用户空间可通过写入 `enabled_monitors` 动态切换监控策略，无需重启系统。\n\n- **资源受限环境**  \n  per-task 监控器槽位限制机制确保 RV 子系统在资源受限设备上可控运行。",
      "similarity": 0.5896366238594055,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 170,
          "end_line": 278,
          "content": [
            "int rv_get_task_monitor_slot(void)",
            "{",
            "\tint i;",
            "",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (task_monitor_count == RV_PER_TASK_MONITORS)",
            "\t\treturn -EBUSY;",
            "",
            "\ttask_monitor_count++;",
            "",
            "\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++) {",
            "\t\tif (task_monitor_slots[i] == false) {",
            "\t\t\ttask_monitor_slots[i] = true;",
            "\t\t\treturn i;",
            "\t\t}",
            "\t}",
            "",
            "\tWARN_ONCE(1, \"RV task_monitor_count and slots are out of sync\\n\");",
            "",
            "\treturn -EINVAL;",
            "}",
            "void rv_put_task_monitor_slot(int slot)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (slot < 0 || slot >= RV_PER_TASK_MONITORS) {",
            "\t\tWARN_ONCE(1, \"RV releasing an invalid slot!: %d\\n\", slot);",
            "\t\treturn;",
            "\t}",
            "",
            "\tWARN_ONCE(!task_monitor_slots[slot], \"RV releasing unused task_monitor_slots: %d\\n\",",
            "\t\t  slot);",
            "",
            "\ttask_monitor_count--;",
            "\ttask_monitor_slots[slot] = false;",
            "}",
            "static ssize_t monitor_enable_read_data(struct file *filp, char __user *user_buf, size_t count,",
            "\t\t\t\t\tloff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tconst char *buff;",
            "",
            "\tbuff = mdef->monitor->enabled ? \"1\\n\" : \"0\\n\";",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff)+1);",
            "}",
            "static int __rv_disable_monitor(struct rv_monitor_def *mdef, bool sync)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (mdef->monitor->enabled) {",
            "\t\tmdef->monitor->enabled = 0;",
            "\t\tmdef->monitor->disable();",
            "",
            "\t\t/*",
            "\t\t * Wait for the execution of all events to finish.",
            "\t\t * Otherwise, the data used by the monitor could",
            "\t\t * be inconsistent. i.e., if the monitor is re-enabled.",
            "\t\t */",
            "\t\tif (sync)",
            "\t\t\ttracepoint_synchronize_unregister();",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "int rv_disable_monitor(struct rv_monitor_def *mdef)",
            "{",
            "\t__rv_disable_monitor(mdef, true);",
            "\treturn 0;",
            "}",
            "int rv_enable_monitor(struct rv_monitor_def *mdef)",
            "{",
            "\tint retval;",
            "",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (mdef->monitor->enabled)",
            "\t\treturn 0;",
            "",
            "\tretval = mdef->monitor->enable();",
            "",
            "\tif (!retval)",
            "\t\tmdef->monitor->enabled = 1;",
            "",
            "\treturn retval;",
            "}",
            "static ssize_t monitor_enable_write_data(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t\t size_t count, loff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tint retval;",
            "\tbool val;",
            "",
            "\tretval = kstrtobool_from_user(user_buf, count, &val);",
            "\tif (retval)",
            "\t\treturn retval;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tif (val)",
            "\t\tretval = rv_enable_monitor(mdef);",
            "\telse",
            "\t\tretval = rv_disable_monitor(mdef);",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "",
            "\treturn retval ? : count;",
            "}"
          ],
          "function_name": "rv_get_task_monitor_slot, rv_put_task_monitor_slot, monitor_enable_read_data, __rv_disable_monitor, rv_disable_monitor, rv_enable_monitor, monitor_enable_write_data",
          "description": "管理任务级监控槽位分配与回收，实现监控启停控制逻辑，通过互斥锁保护监控状态变更并同步跟踪事件处理。",
          "similarity": 0.6390455365180969
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 586,
          "end_line": 710,
          "content": [
            "bool rv_monitoring_on(void)",
            "{",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_rmb();",
            "\treturn READ_ONCE(monitoring_on);",
            "}",
            "static ssize_t monitoring_on_read_data(struct file *filp, char __user *user_buf,",
            "\t\t\t\t       size_t count, loff_t *ppos)",
            "{",
            "\tconst char *buff;",
            "",
            "\tbuff = rv_monitoring_on() ? \"1\\n\" : \"0\\n\";",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);",
            "}",
            "static void turn_monitoring_off(void)",
            "{",
            "\tWRITE_ONCE(monitoring_on, false);",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_wmb();",
            "}",
            "static void reset_all_monitors(void)",
            "{",
            "\tstruct rv_monitor_def *mdef;",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list) {",
            "\t\tif (mdef->monitor->enabled)",
            "\t\t\tmdef->monitor->reset();",
            "\t}",
            "}",
            "static void turn_monitoring_on(void)",
            "{",
            "\tWRITE_ONCE(monitoring_on, true);",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_wmb();",
            "}",
            "static void turn_monitoring_on_with_reset(void)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (rv_monitoring_on())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Monitors might be out of sync with the system if events were not",
            "\t * processed because of !rv_monitoring_on().",
            "\t *",
            "\t * Reset all monitors, forcing a re-sync.",
            "\t */",
            "\treset_all_monitors();",
            "\tturn_monitoring_on();",
            "}",
            "static ssize_t monitoring_on_write_data(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t\tsize_t count, loff_t *ppos)",
            "{",
            "\tint retval;",
            "\tbool val;",
            "",
            "\tretval = kstrtobool_from_user(user_buf, count, &val);",
            "\tif (retval)",
            "\t\treturn retval;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tif (val)",
            "\t\tturn_monitoring_on_with_reset();",
            "\telse",
            "\t\tturn_monitoring_off();",
            "",
            "\t/*",
            "\t * Wait for the execution of all events to finish",
            "\t * before returning to user-space.",
            "\t */",
            "\ttracepoint_synchronize_unregister();",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "",
            "\treturn count;",
            "}",
            "static void destroy_monitor_dir(struct rv_monitor_def *mdef)",
            "{",
            "\treactor_cleanup_monitor(mdef);",
            "\trv_remove(mdef->root_d);",
            "}",
            "int rv_register_monitor(struct rv_monitor *monitor)",
            "{",
            "\tstruct rv_monitor_def *r;",
            "\tint retval = 0;",
            "",
            "\tif (strlen(monitor->name) >= MAX_RV_MONITOR_NAME_SIZE) {",
            "\t\tpr_info(\"Monitor %s has a name longer than %d\\n\", monitor->name,",
            "\t\t\tMAX_RV_MONITOR_NAME_SIZE);",
            "\t\treturn -1;",
            "\t}",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry(r, &rv_monitors_list, list) {",
            "\t\tif (strcmp(monitor->name, r->monitor->name) == 0) {",
            "\t\t\tpr_info(\"Monitor %s is already registered\\n\", monitor->name);",
            "\t\t\tretval = -1;",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "\t}",
            "",
            "\tr = kzalloc(sizeof(struct rv_monitor_def), GFP_KERNEL);",
            "\tif (!r) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tr->monitor = monitor;",
            "",
            "\tretval = create_monitor_dir(r);",
            "\tif (retval) {",
            "\t\tkfree(r);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tlist_add_tail(&r->list, &rv_monitors_list);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "rv_monitoring_on, monitoring_on_read_data, turn_monitoring_off, reset_all_monitors, turn_monitoring_on, turn_monitoring_on_with_reset, monitoring_on_write_data, destroy_monitor_dir, rv_register_monitor",
          "description": "控制整体监控开关状态，提供监控开关切换接口，包含监控状态同步和异常恢复机制，确保监控器与系统状态一致性。",
          "similarity": 0.5917520523071289
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 317,
          "end_line": 459,
          "content": [
            "static ssize_t monitor_desc_read_data(struct file *filp, char __user *user_buf, size_t count,",
            "\t\t\t\t      loff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tchar buff[256];",
            "",
            "\tmemset(buff, 0, sizeof(buff));",
            "",
            "\tsnprintf(buff, sizeof(buff), \"%s\\n\", mdef->monitor->description);",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);",
            "}",
            "static int create_monitor_dir(struct rv_monitor_def *mdef)",
            "{",
            "\tstruct dentry *root = get_monitors_root();",
            "\tconst char *name = mdef->monitor->name;",
            "\tstruct dentry *tmp;",
            "\tint retval;",
            "",
            "\tmdef->root_d = rv_create_dir(name, root);",
            "\tif (!mdef->root_d)",
            "\t\treturn -ENOMEM;",
            "",
            "\ttmp = rv_create_file(\"enable\", RV_MODE_WRITE, mdef->root_d, mdef, &interface_enable_fops);",
            "\tif (!tmp) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_remove_root;",
            "\t}",
            "",
            "\ttmp = rv_create_file(\"desc\", RV_MODE_READ, mdef->root_d, mdef, &interface_desc_fops);",
            "\tif (!tmp) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_remove_root;",
            "\t}",
            "",
            "\tretval = reactor_populate_monitor(mdef);",
            "\tif (retval)",
            "\t\tgoto out_remove_root;",
            "",
            "\treturn 0;",
            "",
            "out_remove_root:",
            "\trv_remove(mdef->root_d);",
            "\treturn retval;",
            "}",
            "static int monitors_show(struct seq_file *m, void *p)",
            "{",
            "\tstruct rv_monitor_def *mon_def = p;",
            "",
            "\tseq_printf(m, \"%s\\n\", mon_def->monitor->name);",
            "\treturn 0;",
            "}",
            "static void monitors_stop(struct seq_file *m, void *p)",
            "{",
            "\tmutex_unlock(&rv_interface_lock);",
            "}",
            "static int available_monitors_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn seq_open(file, &available_monitors_seq_ops);",
            "};",
            "static void disable_all_monitors(void)",
            "{",
            "\tstruct rv_monitor_def *mdef;",
            "\tint enabled = 0;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list)",
            "\t\tenabled += __rv_disable_monitor(mdef, false);",
            "",
            "\tif (enabled) {",
            "\t\t/*",
            "\t\t * Wait for the execution of all events to finish.",
            "\t\t * Otherwise, the data used by the monitor could",
            "\t\t * be inconsistent. i.e., if the monitor is re-enabled.",
            "\t\t */",
            "\t\ttracepoint_synchronize_unregister();",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "}",
            "static int enabled_monitors_open(struct inode *inode, struct file *file)",
            "{",
            "\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC))",
            "\t\tdisable_all_monitors();",
            "",
            "\treturn seq_open(file, &enabled_monitors_seq_ops);",
            "};",
            "static ssize_t enabled_monitors_write(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t      size_t count, loff_t *ppos)",
            "{",
            "\tchar buff[MAX_RV_MONITOR_NAME_SIZE + 2];",
            "\tstruct rv_monitor_def *mdef;",
            "\tint retval = -EINVAL;",
            "\tbool enable = true;",
            "\tchar *ptr;",
            "\tint len;",
            "",
            "\tif (count < 1 || count > MAX_RV_MONITOR_NAME_SIZE + 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tmemset(buff, 0, sizeof(buff));",
            "",
            "\tretval = simple_write_to_buffer(buff, sizeof(buff) - 1, ppos, user_buf, count);",
            "\tif (retval < 0)",
            "\t\treturn -EFAULT;",
            "",
            "\tptr = strim(buff);",
            "",
            "\tif (ptr[0] == '!') {",
            "\t\tenable = false;",
            "\t\tptr++;",
            "\t}",
            "",
            "\tlen = strlen(ptr);",
            "\tif (!len)",
            "\t\treturn count;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tretval = -EINVAL;",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list) {",
            "\t\tif (strcmp(ptr, mdef->monitor->name) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Monitor found!",
            "\t\t */",
            "\t\tif (enable)",
            "\t\t\tretval = rv_enable_monitor(mdef);",
            "\t\telse",
            "\t\t\tretval = rv_disable_monitor(mdef);",
            "",
            "\t\tif (!retval)",
            "\t\t\tretval = count;",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "monitor_desc_read_data, create_monitor_dir, monitors_show, monitors_stop, available_monitors_open, disable_all_monitors, enabled_monitors_open, enabled_monitors_write",
          "description": "创建监控专用目录结构，实现监控描述信息读取和可用监控列表展示，支持动态监控使能状态管理和全局禁用操作。",
          "similarity": 0.5498855710029602
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 742,
          "end_line": 798,
          "content": [
            "int rv_unregister_monitor(struct rv_monitor *monitor)",
            "{",
            "\tstruct rv_monitor_def *ptr, *next;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry_safe(ptr, next, &rv_monitors_list, list) {",
            "\t\tif (strcmp(monitor->name, ptr->monitor->name) == 0) {",
            "\t\t\trv_disable_monitor(ptr);",
            "\t\t\tlist_del(&ptr->list);",
            "\t\t\tdestroy_monitor_dir(ptr);",
            "\t\t}",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn 0;",
            "}",
            "int __init rv_init_interface(void)",
            "{",
            "\tstruct dentry *tmp;",
            "\tint retval;",
            "",
            "\trv_root.root_dir = rv_create_dir(\"rv\", NULL);",
            "\tif (!rv_root.root_dir)",
            "\t\tgoto out_err;",
            "",
            "\trv_root.monitors_dir = rv_create_dir(\"monitors\", rv_root.root_dir);",
            "\tif (!rv_root.monitors_dir)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"available_monitors\", RV_MODE_READ, rv_root.root_dir, NULL,",
            "\t\t\t     &available_monitors_ops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"enabled_monitors\", RV_MODE_WRITE, rv_root.root_dir, NULL,",
            "\t\t\t     &enabled_monitors_ops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"monitoring_on\", RV_MODE_WRITE, rv_root.root_dir, NULL,",
            "\t\t\t     &monitoring_on_fops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "\tretval = init_rv_reactors(rv_root.root_dir);",
            "\tif (retval)",
            "\t\tgoto out_err;",
            "",
            "\tturn_monitoring_on();",
            "",
            "\treturn 0;",
            "",
            "out_err:",
            "\trv_remove(rv_root.root_dir);",
            "\tprintk(KERN_ERR \"RV: Error while creating the RV interface\\n\");",
            "\treturn 1;",
            "}"
          ],
          "function_name": "rv_unregister_monitor, rv_init_interface",
          "description": "实现监控器注册注销流程，完成RV接口初始化，建立监控管理核心结构并注册基础控制接口，处理初始化失败时的资源清理。",
          "similarity": 0.5421971678733826
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 1,
          "end_line": 169,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2019-2022 Red Hat, Inc. Daniel Bristot de Oliveira <bristot@kernel.org>",
            " *",
            " * This is the online Runtime Verification (RV) interface.",
            " *",
            " * RV is a lightweight (yet rigorous) method that complements classical",
            " * exhaustive verification techniques (such as model checking and",
            " * theorem proving) with a more practical approach to complex systems.",
            " *",
            " * RV works by analyzing the trace of the system's actual execution,",
            " * comparing it against a formal specification of the system behavior.",
            " * RV can give precise information on the runtime behavior of the",
            " * monitored system while enabling the reaction for unexpected",
            " * events, avoiding, for example, the propagation of a failure on",
            " * safety-critical systems.",
            " *",
            " * The development of this interface roots in the development of the",
            " * paper:",
            " *",
            " * De Oliveira, Daniel Bristot; Cucinotta, Tommaso; De Oliveira, Romulo",
            " * Silva. Efficient formal verification for the Linux kernel. In:",
            " * International Conference on Software Engineering and Formal Methods.",
            " * Springer, Cham, 2019. p. 315-332.",
            " *",
            " * And:",
            " *",
            " * De Oliveira, Daniel Bristot, et al. Automata-based formal analysis",
            " * and verification of the real-time Linux kernel. PhD Thesis, 2020.",
            " *",
            " * == Runtime monitor interface ==",
            " *",
            " * A monitor is the central part of the runtime verification of a system.",
            " *",
            " * The monitor stands in between the formal specification of the desired",
            " * (or undesired) behavior, and the trace of the actual system.",
            " *",
            " * In Linux terms, the runtime verification monitors are encapsulated",
            " * inside the \"RV monitor\" abstraction. A RV monitor includes a reference",
            " * model of the system, a set of instances of the monitor (per-cpu monitor,",
            " * per-task monitor, and so on), and the helper functions that glue the",
            " * monitor to the system via trace. Generally, a monitor includes some form",
            " * of trace output as a reaction for event parsing and exceptions,",
            " * as depicted bellow:",
            " *",
            " * Linux  +----- RV Monitor ----------------------------------+ Formal",
            " *  Realm |                                                   |  Realm",
            " *  +-------------------+     +----------------+     +-----------------+",
            " *  |   Linux kernel    |     |     Monitor    |     |     Reference   |",
            " *  |     Tracing       |  -> |   Instance(s)  | <-  |       Model     |",
            " *  | (instrumentation) |     | (verification) |     | (specification) |",
            " *  +-------------------+     +----------------+     +-----------------+",
            " *         |                          |                       |",
            " *         |                          V                       |",
            " *         |                     +----------+                 |",
            " *         |                     | Reaction |                 |",
            " *         |                     +--+--+--+-+                 |",
            " *         |                        |  |  |                   |",
            " *         |                        |  |  +-> trace output ?  |",
            " *         +------------------------|--|----------------------+",
            " *                                  |  +----> panic ?",
            " *                                  +-------> <user-specified>",
            " *",
            " * This file implements the interface for loading RV monitors, and",
            " * to control the verification session.",
            " *",
            " * == Registering monitors ==",
            " *",
            " * The struct rv_monitor defines a set of callback functions to control",
            " * a verification session. For instance, when a given monitor is enabled,",
            " * the \"enable\" callback function is called to hook the instrumentation",
            " * functions to the kernel trace events. The \"disable\" function is called",
            " * when disabling the verification session.",
            " *",
            " * A RV monitor is registered via:",
            " *   int rv_register_monitor(struct rv_monitor *monitor);",
            " * And unregistered via:",
            " *   int rv_unregister_monitor(struct rv_monitor *monitor);",
            " *",
            " * == User interface ==",
            " *",
            " * The user interface resembles kernel tracing interface. It presents",
            " * these files:",
            " *",
            " *  \"available_monitors\"",
            " *    - List the available monitors, one per line.",
            " *",
            " *    For example:",
            " *      # cat available_monitors",
            " *      wip",
            " *      wwnr",
            " *",
            " *  \"enabled_monitors\"",
            " *    - Lists the enabled monitors, one per line;",
            " *    - Writing to it enables a given monitor;",
            " *    - Writing a monitor name with a '!' prefix disables it;",
            " *    - Truncating the file disables all enabled monitors.",
            " *",
            " *    For example:",
            " *      # cat enabled_monitors",
            " *      # echo wip > enabled_monitors",
            " *      # echo wwnr >> enabled_monitors",
            " *      # cat enabled_monitors",
            " *      wip",
            " *      wwnr",
            " *      # echo '!wip' >> enabled_monitors",
            " *      # cat enabled_monitors",
            " *      wwnr",
            " *      # echo > enabled_monitors",
            " *      # cat enabled_monitors",
            " *      #",
            " *",
            " *    Note that more than one monitor can be enabled concurrently.",
            " *",
            " *  \"monitoring_on\"",
            " *    - It is an on/off general switcher for monitoring. Note",
            " *    that it does not disable enabled monitors or detach events,",
            " *    but stops the per-entity monitors from monitoring the events",
            " *    received from the instrumentation. It resembles the \"tracing_on\"",
            " *    switcher.",
            " *",
            " *  \"monitors/\"",
            " *    Each monitor will have its own directory inside \"monitors/\". There",
            " *    the monitor specific files will be presented.",
            " *    The \"monitors/\" directory resembles the \"events\" directory on",
            " *    tracefs.",
            " *",
            " *    For example:",
            " *      # cd monitors/wip/",
            " *      # ls",
            " *      desc  enable",
            " *      # cat desc",
            " *      auto-generated wakeup in preemptive monitor.",
            " *      # cat enable",
            " *      0",
            " *",
            " *  For further information, see:",
            " *   Documentation/trace/rv/runtime-verification.rst",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "",
            "#ifdef CONFIG_DA_MON_EVENTS",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/rv.h>",
            "#endif",
            "",
            "#include \"rv.h\"",
            "",
            "DEFINE_MUTEX(rv_interface_lock);",
            "",
            "static struct rv_interface rv_root;",
            "",
            "struct dentry *get_monitors_root(void)",
            "{",
            "\treturn rv_root.monitors_dir;",
            "}",
            "",
            "/*",
            " * Interface for the monitor register.",
            " */",
            "static LIST_HEAD(rv_monitors_list);",
            "",
            "static int task_monitor_count;",
            "static bool task_monitor_slots[RV_PER_TASK_MONITORS];",
            ""
          ],
          "function_name": null,
          "description": "定义RV监控接口的基础结构，包括互斥锁、全局监控根节点及监控列表，为后续监控注册和管理提供基础设施。",
          "similarity": 0.5214300155639648
        }
      ]
    },
    {
      "source_file": "kernel/watchdog.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:51:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watchdog.c`\n\n---\n\n# watchdog.c 技术文档\n\n## 1. 文件概述\n\n`watchdog.c` 是 Linux 内核中实现 **硬锁死（hard lockup）** 和 **软锁死（soft lockup）** 检测机制的核心文件。该机制用于监控系统中 CPU 是否因长时间禁用中断或陷入无限循环而无法响应，从而帮助诊断系统挂死问题。硬锁死指 CPU 完全停止响应中断（包括 NMI），软锁死指内核线程长时间占用 CPU 且未调度其他任务。本文件主要聚焦于硬锁死检测的通用框架和部分实现，软锁死检测逻辑主要在其他文件（如 `softlockup.c`）中实现，但两者共享部分配置和控制逻辑。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `watchdog_enabled`：位掩码，表示当前启用的 watchdog 类型（软/硬锁死检测）。\n- `watchdog_user_enabled`：用户空间是否启用 watchdog（默认 1）。\n- `watchdog_hardlockup_user_enabled`：用户空间是否启用硬锁死检测（默认值取决于架构）。\n- `watchdog_softlockup_user_enabled`：用户空间是否启用软锁死检测（默认 1）。\n- `watchdog_thresh`：锁死检测阈值（秒，默认 10 秒）。\n- `watchdog_cpumask`：参与 watchdog 检测的 CPU 掩码。\n- `hardlockup_panic`：硬锁死发生时是否触发内核 panic（默认由 `CONFIG_BOOTPARAM_HARDLOCKUP_PANIC` 决定）。\n- `sysctl_hardlockup_all_cpu_backtrace`（SMP）：硬锁死时是否打印所有 CPU 的 backtrace。\n- `hardlockup_count`（SYSFS）：记录硬锁死事件发生次数。\n\n### 主要函数\n- `hardlockup_detector_disable(void)`：在启动早期禁用硬锁死检测（例如虚拟机环境）。\n- `hardlockup_panic_setup(char *str)`：解析内核启动参数 `nmi_watchdog=`，配置硬锁死行为。\n- `arch_touch_nmi_watchdog(void)`：架构相关函数，用于在关键路径“触摸”硬 watchdog，防止误报（导出符号）。\n- `watchdog_hardlockup_touch_cpu(unsigned int cpu)`：标记指定 CPU 已被“触摸”。\n- `is_hardlockup(unsigned int cpu)`：检查指定 CPU 是否发生硬锁死（基于高精度定时器中断计数）。\n- `watchdog_hardlockup_kick(void)`：在高精度定时器中断中“踢”硬 watchdog（更新中断计数）。\n- `watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs)`：执行硬锁死检测逻辑，打印诊断信息并可能触发 panic。\n- `watchdog_hardlockup_enable/disable(unsigned int cpu)`：弱符号函数，由具体硬 watchdog 实现（如 perf-based）覆盖，用于启停 per-CPU 检测。\n- `watchdog_hardlockup_probe(void)`：弱符号函数，由具体实现提供，用于探测硬 watchdog 硬件/机制是否可用。\n\n### 核心数据结构（Per-CPU）\n- `hrtimer_interrupts`：高精度定时器中断计数器（原子变量）。\n- `hrtimer_interrupts_saved`：上次保存的中断计数值。\n- `watchdog_hardlockup_warned`：是否已为该 CPU 打印过硬锁死警告。\n- `watchdog_hardlockup_touched`：该 CPU 是否被“触摸”过（用于豁免检测）。\n\n## 3. 关键实现\n\n### 硬锁死检测机制（基于高精度定时器）\n当配置 `CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER` 时，硬锁死检测通过监控 **高精度定时器（hrtimer）中断** 的发生频率实现：\n1. **计数更新**：每次 hrtimer 中断发生时，调用 `watchdog_hardlockup_kick()` 原子递增 per-CPU 计数器 `hrtimer_interrupts`。\n2. **检测逻辑**：在 NMI（不可屏蔽中断）上下文（或其他检测点）调用 `watchdog_hardlockup_check()`：\n   - 若 CPU 被“触摸”（`watchdog_hardlockup_touched` 为真），则清除此标记并跳过检测。\n   - 否则调用 `is_hardlockup()`：比较当前 `hrtimer_interrupts` 与上次保存值 `hrtimer_interrupts_saved`。若相等，说明在检测周期内无 hrtimer 中断，判定为硬锁死。\n3. **告警与处理**：\n   - 首次检测到硬锁死时，打印紧急日志（CPU 信息、模块列表、中断跟踪、寄存器状态或栈回溯）。\n   - 若启用 `sysctl_hardlockup_all_cpu_backtrace`，触发其他 CPU 的 backtrace。\n   - 若 `hardlockup_panic` 为真，调用 `nmi_panic()` 触发内核 panic。\n   - 设置 `watchdog_hardlockup_warned` 避免重复告警。\n\n### 启动参数与配置\n- **`nmi_watchdog=` 参数**：通过 `__setup` 宏注册，支持以下值：\n  - `panic`/`nopanic`：设置 `hardlockup_panic`。\n  - `0`/`1`：启用/禁用硬锁死检测。\n  - `r...`：传递参数给 perf-based 检测器（`hardlockup_config_perf_event`）。\n- **早期禁用**：`hardlockup_detector_disable()` 可在解析命令行前禁用硬检测（如 KVM guest）。\n\n### 架构交互与豁免\n- **`arch_touch_nmi_watchdog()`**：允许架构代码或关键内核路径（如 printk）临时豁免硬 watchdog 检测，防止在已知安全的长操作中误报。使用 `raw_cpu_write` 确保在抢占/中断使能环境下安全。\n\n### 弱符号扩展点\n- `watchdog_hardlockup_enable/disable/probe` 声明为 `__weak`，允许不同架构或检测方法（如基于 perf event 的 NMI watchdog）提供具体实现，实现检测机制的可插拔。\n\n## 4. 依赖关系\n\n- **内核子系统**：\n  - `<linux/nmi.h>`：NMI 处理框架，硬锁死检测通常在 NMI 上下文触发。\n  - `<linux/hrtimer.h>`（隐含）：高精度定时器中断作为检测心跳源。\n  - `<linux/sched/*.h>`：调度器相关（`print_irqtrace_events`, `dump_stack`）。\n  - `<linux/sysctl.h>`：提供 `sysctl_hardlockup_all_cpu_backtrace` 控制接口。\n  - `<linux/sysfs.h>`：暴露 `hardlockup_count` 到 sysfs。\n  - `<asm/irq_regs.h>`：获取中断上下文寄存器状态（`show_regs`）。\n- **配置选项**：\n  - `CONFIG_HARDLOCKUP_DETECTOR`：启用硬锁死检测框架。\n  - `CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER`：使用 hrtimer 中断计数实现检测。\n  - `CONFIG_HARDLOCKUP_DETECTOR_SPARC64`：SPARC64 架构默认启用硬检测。\n  - `CONFIG_BOOTPARAM_HARDLOCKUP_PANIC`：设置默认 panic 行为。\n  - `CONFIG_SMP`：多核支持（`all_cpu_backtrace` 功能）。\n  - `CONFIG_SYSFS`：sysfs 接口支持。\n- **其他模块**：依赖具体架构的 NMI 实现（如 x86 的 perf-based NMI watchdog）提供检测触发点。\n\n## 5. 使用场景\n\n- **系统稳定性监控**：在生产服务器或嵌入式设备中持续监控 CPU 响应性，及时发现硬件故障、驱动 bug 或内核死锁导致的系统挂死。\n- **内核调试**：开发人员通过 watchdog 触发的 backtrace 和寄存器转储，定位导致系统无响应的代码路径。\n- **虚拟化环境**：在 hypervisor guest 中可选择性禁用硬 watchdog（因虚拟化开销可能导致误报），通过 `hardlockup_detector_disable()` 或启动参数控制。\n- **实时系统**：结合 CPU 隔离（`isolcpus`）和 watchdog 配置，确保关键 CPU 核心的响应性，同时避免在非关键核上产生干扰。\n- **panic 策略**：通过 `hardlockup_panic` 配置，使系统在硬锁死时自动重启，提高无人值守系统的可用性。",
      "similarity": 0.5846731066703796,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/watchdog.c",
          "start_line": 946,
          "end_line": 1059,
          "content": [
            "void lockup_detector_reconfigure(void)",
            "{",
            "\tmutex_lock(&watchdog_mutex);",
            "\t__lockup_detector_reconfigure(false);",
            "\tmutex_unlock(&watchdog_mutex);",
            "}",
            "static __init void lockup_detector_setup(void)",
            "{",
            "\t/*",
            "\t * If sysctl is off and watchdog got disabled on the command line,",
            "\t * nothing to do here.",
            "\t */",
            "\tlockup_detector_update_enable();",
            "",
            "\tif (!IS_ENABLED(CONFIG_SYSCTL) &&",
            "\t    !(watchdog_enabled && watchdog_thresh))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "\t__lockup_detector_reconfigure(false);",
            "\tsoftlockup_initialized = true;",
            "\tmutex_unlock(&watchdog_mutex);",
            "}",
            "static void __lockup_detector_reconfigure(bool thresh_changed)",
            "{",
            "\tcpus_read_lock();",
            "\twatchdog_hardlockup_stop();",
            "\tif (thresh_changed)",
            "\t\twatchdog_thresh = READ_ONCE(watchdog_thresh_next);",
            "\tlockup_detector_update_enable();",
            "\twatchdog_hardlockup_start();",
            "\tcpus_read_unlock();",
            "}",
            "void lockup_detector_reconfigure(void)",
            "{",
            "\t__lockup_detector_reconfigure(false);",
            "}",
            "static inline void lockup_detector_setup(void)",
            "{",
            "\t__lockup_detector_reconfigure(false);",
            "}",
            "void lockup_detector_soft_poweroff(void)",
            "{",
            "\twatchdog_enabled = 0;",
            "}",
            "static void proc_watchdog_update(bool thresh_changed)",
            "{",
            "\t/* Remove impossible cpus to keep sysctl output clean. */",
            "\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);",
            "\t__lockup_detector_reconfigure(thresh_changed);",
            "}",
            "static int proc_watchdog_common(int which, struct ctl_table *table, int write,",
            "\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint err, old, *param = table->data;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "",
            "\told = *param;",
            "\tif (!write) {",
            "\t\t/*",
            "\t\t * On read synchronize the userspace interface. This is a",
            "\t\t * racy snapshot.",
            "\t\t */",
            "\t\t*param = (watchdog_enabled & which) != 0;",
            "\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\t\t*param = old;",
            "\t} else {",
            "\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\t\tif (!err && old != READ_ONCE(*param))",
            "\t\t\tproc_watchdog_update(false);",
            "\t}",
            "\tmutex_unlock(&watchdog_mutex);",
            "\treturn err;",
            "}",
            "int proc_watchdog(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn proc_watchdog_common(WATCHDOG_HARDLOCKUP_ENABLED |",
            "\t\t\t\t    WATCHDOG_SOFTOCKUP_ENABLED,",
            "\t\t\t\t    table, write, buffer, lenp, ppos);",
            "}",
            "int proc_nmi_watchdog(struct ctl_table *table, int write,",
            "\t\t      void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tif (!watchdog_hardlockup_available && write)",
            "\t\treturn -ENOTSUPP;",
            "\treturn proc_watchdog_common(WATCHDOG_HARDLOCKUP_ENABLED,",
            "\t\t\t\t    table, write, buffer, lenp, ppos);",
            "}",
            "int proc_soft_watchdog(struct ctl_table *table, int write,",
            "\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn proc_watchdog_common(WATCHDOG_SOFTOCKUP_ENABLED,",
            "\t\t\t\t    table, write, buffer, lenp, ppos);",
            "}",
            "int proc_watchdog_thresh(struct ctl_table *table, int write,",
            "\t\t\t void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint err, old;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "",
            "\twatchdog_thresh_next = READ_ONCE(watchdog_thresh);",
            "",
            "\told = watchdog_thresh_next;",
            "\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "",
            "\tif (!err && write && old != READ_ONCE(watchdog_thresh_next))",
            "\t\tproc_watchdog_update(true);",
            "",
            "\tmutex_unlock(&watchdog_mutex);",
            "\treturn err;",
            "}"
          ],
          "function_name": "lockup_detector_reconfigure, lockup_detector_setup, __lockup_detector_reconfigure, lockup_detector_reconfigure, lockup_detector_setup, lockup_detector_soft_poweroff, proc_watchdog_update, proc_watchdog_common, proc_watchdog, proc_nmi_watchdog, proc_soft_watchdog, proc_watchdog_thresh",
          "description": "提供看门狗参数动态配置接口，包含阈值更新、CPU掩码同步、sysctl参数读写控制逻辑，支持硬/软锁步检测模式切换和阈值调节",
          "similarity": 0.548885703086853
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/watchdog.c",
          "start_line": 833,
          "end_line": 936,
          "content": [
            "static void watchdog_enable(unsigned int cpu)",
            "{",
            "\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);",
            "\tstruct completion *done = this_cpu_ptr(&softlockup_completion);",
            "",
            "\tWARN_ON_ONCE(cpu != smp_processor_id());",
            "",
            "\tinit_completion(done);",
            "\tcomplete(done);",
            "",
            "\t/*",
            "\t * Start the timer first to prevent the hardlockup watchdog triggering",
            "\t * before the timer has a chance to fire.",
            "\t */",
            "\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);",
            "\thrtimer->function = watchdog_timer_fn;",
            "\thrtimer_start(hrtimer, ns_to_ktime(sample_period),",
            "\t\t      HRTIMER_MODE_REL_PINNED_HARD);",
            "",
            "\t/* Initialize timestamp */",
            "\tupdate_touch_ts();",
            "\t/* Enable the hardlockup detector */",
            "\tif (watchdog_enabled & WATCHDOG_HARDLOCKUP_ENABLED)",
            "\t\twatchdog_hardlockup_enable(cpu);",
            "}",
            "static void watchdog_disable(unsigned int cpu)",
            "{",
            "\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);",
            "",
            "\tWARN_ON_ONCE(cpu != smp_processor_id());",
            "",
            "\t/*",
            "\t * Disable the hardlockup detector first. That prevents that a large",
            "\t * delay between disabling the timer and disabling the hardlockup",
            "\t * detector causes a false positive.",
            "\t */",
            "\twatchdog_hardlockup_disable(cpu);",
            "\thrtimer_cancel(hrtimer);",
            "\twait_for_completion(this_cpu_ptr(&softlockup_completion));",
            "}",
            "static int softlockup_stop_fn(void *data)",
            "{",
            "\twatchdog_disable(smp_processor_id());",
            "\treturn 0;",
            "}",
            "static void softlockup_stop_all(void)",
            "{",
            "\tint cpu;",
            "",
            "\tif (!softlockup_initialized)",
            "\t\treturn;",
            "",
            "\tfor_each_cpu(cpu, &watchdog_allowed_mask)",
            "\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);",
            "",
            "\tcpumask_clear(&watchdog_allowed_mask);",
            "}",
            "static int softlockup_start_fn(void *data)",
            "{",
            "\twatchdog_enable(smp_processor_id());",
            "\treturn 0;",
            "}",
            "static void softlockup_start_all(void)",
            "{",
            "\tint cpu;",
            "",
            "\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);",
            "\tfor_each_cpu(cpu, &watchdog_allowed_mask)",
            "\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);",
            "}",
            "int lockup_detector_online_cpu(unsigned int cpu)",
            "{",
            "\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))",
            "\t\twatchdog_enable(cpu);",
            "\treturn 0;",
            "}",
            "int lockup_detector_offline_cpu(unsigned int cpu)",
            "{",
            "\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))",
            "\t\twatchdog_disable(cpu);",
            "\treturn 0;",
            "}",
            "static void __lockup_detector_reconfigure(bool thresh_changed)",
            "{",
            "\tcpus_read_lock();",
            "\twatchdog_hardlockup_stop();",
            "",
            "\tsoftlockup_stop_all();",
            "\t/*",
            "\t * To prevent watchdog_timer_fn from using the old interval and",
            "\t * the new watchdog_thresh at the same time, which could lead to",
            "\t * false softlockup reports, it is necessary to update the",
            "\t * watchdog_thresh after the softlockup is completed.",
            "\t */",
            "\tif (thresh_changed)",
            "\t\twatchdog_thresh = READ_ONCE(watchdog_thresh_next);",
            "\tset_sample_period();",
            "\tlockup_detector_update_enable();",
            "\tif (watchdog_enabled && watchdog_thresh)",
            "\t\tsoftlockup_start_all();",
            "",
            "\twatchdog_hardlockup_start();",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "watchdog_enable, watchdog_disable, softlockup_stop_fn, softlockup_stop_all, softlockup_start_fn, softlockup_start_all, lockup_detector_online_cpu, lockup_detector_offline_cpu, __lockup_detector_reconfigure",
          "description": "定义看门狗启用/禁用逻辑，通过per-CPU定时器实现软锁步检测，包含初始化完成符、启动/取消高精度定时器、关联硬锁步检测模块的操作",
          "similarity": 0.5439980030059814
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/watchdog.c",
          "start_line": 73,
          "end_line": 217,
          "content": [
            "static ssize_t hardlockup_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\t     char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%u\\n\", hardlockup_count);",
            "}",
            "static __init int kernel_hardlockup_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &hardlockup_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "void __init hardlockup_detector_disable(void)",
            "{",
            "\twatchdog_hardlockup_user_enabled = 0;",
            "}",
            "static int __init hardlockup_panic_setup(char *str)",
            "{",
            "next:",
            "\tif (!strncmp(str, \"panic\", 5))",
            "\t\thardlockup_panic = 1;",
            "\telse if (!strncmp(str, \"nopanic\", 7))",
            "\t\thardlockup_panic = 0;",
            "\telse if (!strncmp(str, \"0\", 1))",
            "\t\twatchdog_hardlockup_user_enabled = 0;",
            "\telse if (!strncmp(str, \"1\", 1))",
            "\t\twatchdog_hardlockup_user_enabled = 1;",
            "\telse if (!strncmp(str, \"r\", 1))",
            "\t\thardlockup_config_perf_event(str + 1);",
            "\twhile (*(str++)) {",
            "\t\tif (*str == ',') {",
            "\t\t\tstr++;",
            "\t\t\tgoto next;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}",
            "notrace void arch_touch_nmi_watchdog(void)",
            "{",
            "\t/*",
            "\t * Using __raw here because some code paths have",
            "\t * preemption enabled.  If preemption is enabled",
            "\t * then interrupts should be enabled too, in which",
            "\t * case we shouldn't have to worry about the watchdog",
            "\t * going off.",
            "\t */",
            "\traw_cpu_write(watchdog_hardlockup_touched, true);",
            "}",
            "void watchdog_hardlockup_touch_cpu(unsigned int cpu)",
            "{",
            "\tper_cpu(watchdog_hardlockup_touched, cpu) = true;",
            "}",
            "static bool is_hardlockup(unsigned int cpu)",
            "{",
            "\tint hrint = atomic_read(&per_cpu(hrtimer_interrupts, cpu));",
            "",
            "\tif (per_cpu(hrtimer_interrupts_saved, cpu) == hrint)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * NOTE: we don't need any fancy atomic_t or READ_ONCE/WRITE_ONCE",
            "\t * for hrtimer_interrupts_saved. hrtimer_interrupts_saved is",
            "\t * written/read by a single CPU.",
            "\t */",
            "\tper_cpu(hrtimer_interrupts_saved, cpu) = hrint;",
            "",
            "\treturn false;",
            "}",
            "static void watchdog_hardlockup_kick(void)",
            "{",
            "\tint new_interrupts;",
            "",
            "\tnew_interrupts = atomic_inc_return(this_cpu_ptr(&hrtimer_interrupts));",
            "\twatchdog_buddy_check_hardlockup(new_interrupts);",
            "}",
            "void watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs)",
            "{",
            "\tif (per_cpu(watchdog_hardlockup_touched, cpu)) {",
            "\t\tper_cpu(watchdog_hardlockup_touched, cpu) = false;",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Check for a hardlockup by making sure the CPU's timer",
            "\t * interrupt is incrementing. The timer interrupt should have",
            "\t * fired multiple times before we overflow'd. If it hasn't",
            "\t * then this is a good indication the cpu is stuck",
            "\t */",
            "\tif (is_hardlockup(cpu)) {",
            "\t\tunsigned int this_cpu = smp_processor_id();",
            "\t\tunsigned long flags;",
            "",
            "#ifdef CONFIG_SYSFS",
            "\t\t++hardlockup_count;",
            "#endif",
            "",
            "\t\t/* Only print hardlockups once. */",
            "\t\tif (per_cpu(watchdog_hardlockup_warned, cpu))",
            "\t\t\treturn;",
            "",
            "\t\t/*",
            "\t\t * Prevent multiple hard-lockup reports if one cpu is already",
            "\t\t * engaged in dumping all cpu back traces.",
            "\t\t */",
            "\t\tif (sysctl_hardlockup_all_cpu_backtrace) {",
            "\t\t\tif (test_and_set_bit_lock(0, &hard_lockup_nmi_warn))",
            "\t\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * NOTE: we call printk_cpu_sync_get_irqsave() after printing",
            "\t\t * the lockup message. While it would be nice to serialize",
            "\t\t * that printout, we really want to make sure that if some",
            "\t\t * other CPU somehow locked up while holding the lock associated",
            "\t\t * with printk_cpu_sync_get_irqsave() that we can still at least",
            "\t\t * get the message about the lockup out.",
            "\t\t */",
            "\t\tpr_emerg(\"CPU%u: Watchdog detected hard LOCKUP on cpu %u\\n\", this_cpu, cpu);",
            "\t\tprintk_cpu_sync_get_irqsave(flags);",
            "",
            "\t\tprint_modules();",
            "\t\tprint_irqtrace_events(current);",
            "\t\tif (cpu == this_cpu) {",
            "\t\t\tif (regs)",
            "\t\t\t\tshow_regs(regs);",
            "\t\t\telse",
            "\t\t\t\tdump_stack();",
            "\t\t\tprintk_cpu_sync_put_irqrestore(flags);",
            "\t\t} else {",
            "\t\t\tprintk_cpu_sync_put_irqrestore(flags);",
            "\t\t\ttrigger_single_cpu_backtrace(cpu);",
            "\t\t}",
            "",
            "\t\tif (sysctl_hardlockup_all_cpu_backtrace) {",
            "\t\t\ttrigger_allbutcpu_cpu_backtrace(cpu);",
            "\t\t\tif (!hardlockup_panic)",
            "\t\t\t\tclear_bit_unlock(0, &hard_lockup_nmi_warn);",
            "\t\t}",
            "",
            "\t\tif (hardlockup_panic)",
            "\t\t\tnmi_panic(regs, \"Hard LOCKUP\");",
            "",
            "\t\tper_cpu(watchdog_hardlockup_warned, cpu) = true;",
            "\t} else {",
            "\t\tper_cpu(watchdog_hardlockup_warned, cpu) = false;",
            "\t}",
            "}"
          ],
          "function_name": "hardlockup_count_show, kernel_hardlockup_sysfs_init, hardlockup_detector_disable, hardlockup_panic_setup, arch_touch_nmi_watchdog, watchdog_hardlockup_touch_cpu, is_hardlockup, watchdog_hardlockup_kick, watchdog_hardlockup_check",
          "description": "实现硬锁检测核心逻辑，包含硬锁判断、计数统计、NMI触发电路及异常上报功能，通过中断计数器检测CPU卡顿。",
          "similarity": 0.5360995531082153
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watchdog.c",
          "start_line": 257,
          "end_line": 357,
          "content": [
            "static inline void watchdog_hardlockup_kick(void) { }",
            "void __weak watchdog_hardlockup_enable(unsigned int cpu) { }",
            "void __weak watchdog_hardlockup_disable(unsigned int cpu) { }",
            "int __weak __init watchdog_hardlockup_probe(void)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "void __weak watchdog_hardlockup_stop(void) { }",
            "void __weak watchdog_hardlockup_start(void) { }",
            "static void lockup_detector_update_enable(void)",
            "{",
            "\twatchdog_enabled = 0;",
            "\tif (!watchdog_user_enabled)",
            "\t\treturn;",
            "\tif (watchdog_hardlockup_available && watchdog_hardlockup_user_enabled)",
            "\t\twatchdog_enabled |= WATCHDOG_HARDLOCKUP_ENABLED;",
            "\tif (watchdog_softlockup_user_enabled)",
            "\t\twatchdog_enabled |= WATCHDOG_SOFTOCKUP_ENABLED;",
            "}",
            "static ssize_t softlockup_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\t     char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%u\\n\", softlockup_count);",
            "}",
            "static __init int kernel_softlockup_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &softlockup_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "static int __init softlockup_panic_setup(char *str)",
            "{",
            "\tsoftlockup_panic = simple_strtoul(str, NULL, 0);",
            "\treturn 1;",
            "}",
            "static int __init nowatchdog_setup(char *str)",
            "{",
            "\twatchdog_user_enabled = 0;",
            "\treturn 1;",
            "}",
            "static int __init nosoftlockup_setup(char *str)",
            "{",
            "\twatchdog_softlockup_user_enabled = 0;",
            "\treturn 1;",
            "}",
            "static int __init watchdog_thresh_setup(char *str)",
            "{",
            "\tget_option(&str, &watchdog_thresh);",
            "\treturn 1;",
            "}",
            "static u16 get_16bit_precision(u64 data_ns)",
            "{",
            "\treturn data_ns >> 24LL; /* 2^24ns ~= 16.8ms */",
            "}",
            "static void update_cpustat(void)",
            "{",
            "\tint i;",
            "\tu8 util;",
            "\tu16 old_stat, new_stat;",
            "\tstruct kernel_cpustat kcpustat;",
            "\tu64 *cpustat = kcpustat.cpustat;",
            "\tu8 tail = __this_cpu_read(cpustat_tail);",
            "\tu16 sample_period_16 = get_16bit_precision(sample_period);",
            "",
            "\tkcpustat_cpu_fetch(&kcpustat, smp_processor_id());",
            "",
            "\tfor (i = 0; i < NUM_STATS_PER_GROUP; i++) {",
            "\t\told_stat = __this_cpu_read(cpustat_old[i]);",
            "\t\tnew_stat = get_16bit_precision(cpustat[tracked_stats[i]]);",
            "\t\tutil = DIV_ROUND_UP(100 * (new_stat - old_stat), sample_period_16);",
            "\t\t__this_cpu_write(cpustat_util[tail][i], util);",
            "\t\t__this_cpu_write(cpustat_old[i], new_stat);",
            "\t}",
            "",
            "\t__this_cpu_write(cpustat_tail, (tail + 1) % NUM_SAMPLE_PERIODS);",
            "}",
            "static void print_cpustat(void)",
            "{",
            "\tint i, group;",
            "\tu8 tail = __this_cpu_read(cpustat_tail);",
            "\tu64 sample_period_second = sample_period;",
            "",
            "\tdo_div(sample_period_second, NSEC_PER_SEC);",
            "",
            "\t/*",
            "\t * Outputting the \"watchdog\" prefix on every line is redundant and not",
            "\t * concise, and the original alarm information is sufficient for",
            "\t * positioning in logs, hence here printk() is used instead of pr_crit().",
            "\t */",
            "\tprintk(KERN_CRIT \"CPU#%d Utilization every %llus during lockup:\\n\",",
            "\t       smp_processor_id(), sample_period_second);",
            "",
            "\tfor (i = 0; i < NUM_SAMPLE_PERIODS; i++) {",
            "\t\tgroup = (tail + i) % NUM_SAMPLE_PERIODS;",
            "\t\tprintk(KERN_CRIT \"\\t#%d: %3u%% system,\\t%3u%% softirq,\\t\"",
            "\t\t\t\"%3u%% hardirq,\\t%3u%% idle\\n\", i + 1,",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_SYSTEM]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_SOFTIRQ]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_HARDIRQ]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_IDLE]));",
            "\t}",
            "}"
          ],
          "function_name": "watchdog_hardlockup_kick, watchdog_hardlockup_enable, watchdog_hardlockup_disable, watchdog_hardlockup_probe, watchdog_hardlockup_stop, watchdog_hardlockup_start, lockup_detector_update_enable, softlockup_count_show, kernel_softlockup_sysfs_init, softlockup_panic_setup, nowatchdog_setup, nosoftlockup_setup, watchdog_thresh_setup, get_16bit_precision, update_cpustat, print_cpustat",
          "description": "提供软锁检测支持，包含统计周期设置、CPU利用率采集、中断事件追踪等辅助功能，维护软锁检测相关状态机。",
          "similarity": 0.5267214775085449
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/watchdog.c",
          "start_line": 494,
          "end_line": 595,
          "content": [
            "static void tabulate_irq_count(struct irq_counts *irq_counts, int irq, u32 counts, int rank)",
            "{",
            "\tint i;",
            "\tstruct irq_counts new_count = {irq, counts};",
            "",
            "\tfor (i = 0; i < rank; i++) {",
            "\t\tif (counts > irq_counts[i].counts)",
            "\t\t\tswap(new_count, irq_counts[i]);",
            "\t}",
            "}",
            "static bool need_counting_irqs(void)",
            "{",
            "\tu8 util;",
            "\tint tail = __this_cpu_read(cpustat_tail);",
            "",
            "\ttail = (tail + NUM_HARDIRQ_REPORT - 1) % NUM_HARDIRQ_REPORT;",
            "\tutil = __this_cpu_read(cpustat_util[tail][STATS_HARDIRQ]);",
            "\treturn util > HARDIRQ_PERCENT_THRESH;",
            "}",
            "static void start_counting_irqs(void)",
            "{",
            "\tif (!__this_cpu_read(snapshot_taken)) {",
            "\t\tkstat_snapshot_irqs();",
            "\t\t__this_cpu_write(snapshot_taken, true);",
            "\t}",
            "}",
            "static void stop_counting_irqs(void)",
            "{",
            "\t__this_cpu_write(snapshot_taken, false);",
            "}",
            "static void print_irq_counts(void)",
            "{",
            "\tunsigned int i, count;",
            "\tstruct irq_counts irq_counts_sorted[NUM_HARDIRQ_REPORT] = {",
            "\t\t{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}",
            "\t};",
            "",
            "\tif (__this_cpu_read(snapshot_taken)) {",
            "\t\tfor_each_active_irq(i) {",
            "\t\t\tcount = kstat_get_irq_since_snapshot(i);",
            "\t\t\ttabulate_irq_count(irq_counts_sorted, i, count, NUM_HARDIRQ_REPORT);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Outputting the \"watchdog\" prefix on every line is redundant and not",
            "\t\t * concise, and the original alarm information is sufficient for",
            "\t\t * positioning in logs, hence here printk() is used instead of pr_crit().",
            "\t\t */",
            "\t\tprintk(KERN_CRIT \"CPU#%d Detect HardIRQ Time exceeds %d%%. Most frequent HardIRQs:\\n\",",
            "\t\t       smp_processor_id(), HARDIRQ_PERCENT_THRESH);",
            "",
            "\t\tfor (i = 0; i < NUM_HARDIRQ_REPORT; i++) {",
            "\t\t\tif (irq_counts_sorted[i].irq == -1)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\tprintk(KERN_CRIT \"\\t#%u: %-10u\\tirq#%d\\n\",",
            "\t\t\t       i + 1, irq_counts_sorted[i].counts,",
            "\t\t\t       irq_counts_sorted[i].irq);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If the hardirq time is less than HARDIRQ_PERCENT_THRESH% in the last",
            "\t\t * sample_period, then we suspect the interrupt storm might be subsiding.",
            "\t\t */",
            "\t\tif (!need_counting_irqs())",
            "\t\t\tstop_counting_irqs();",
            "\t}",
            "}",
            "static void report_cpu_status(void)",
            "{",
            "\tprint_cpustat();",
            "\tprint_irq_counts();",
            "}",
            "static inline void update_cpustat(void) { }",
            "static inline void report_cpu_status(void) { }",
            "static inline bool need_counting_irqs(void) { return false; }",
            "static inline void start_counting_irqs(void) { }",
            "static inline void stop_counting_irqs(void) { }",
            "static int get_softlockup_thresh(void)",
            "{",
            "\treturn watchdog_thresh * 2;",
            "}",
            "static unsigned long get_timestamp(void)",
            "{",
            "\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */",
            "}",
            "static void set_sample_period(void)",
            "{",
            "\t/*",
            "\t * convert watchdog_thresh from seconds to ns",
            "\t * the divide by 5 is to give hrtimer several chances (two",
            "\t * or three with the current relation between the soft",
            "\t * and hard thresholds) to increment before the",
            "\t * hardlockup detector generates a warning",
            "\t */",
            "\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / NUM_SAMPLE_PERIODS);",
            "\twatchdog_update_hrtimer_threshold(sample_period);",
            "}",
            "static void update_report_ts(void)",
            "{",
            "\t__this_cpu_write(watchdog_report_ts, get_timestamp());",
            "}"
          ],
          "function_name": "tabulate_irq_count, need_counting_irqs, start_counting_irqs, stop_counting_irqs, print_irq_counts, report_cpu_status, update_cpustat, report_cpu_status, need_counting_irqs, start_counting_irqs, stop_counting_irqs, get_softlockup_thresh, get_timestamp, set_sample_period, update_report_ts",
          "description": "实现中断统计分析模块，通过记录中断次数分布识别潜在中断风暴，为软锁检测提供上下文信息。",
          "similarity": 0.5252774357795715
        }
      ]
    }
  ]
}