{
  "query": "操作系统核心功能与实现原理",
  "timestamp": "2025-12-25 23:32:17",
  "retrieved_files": [
    {
      "source_file": "kernel/time/timekeeping.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:55:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timekeeping.c`\n\n---\n\n# timekeeping.c 技术文档\n\n## 1. 文件概述\n\n`timekeeping.c` 是 Linux 内核中负责时间保持（timekeeping）的核心实现文件。它维护系统时间的连续性和准确性，提供高精度的时间读取接口，并处理与 NTP（网络时间协议）、时钟源（clocksource）、系统挂起/恢复等相关的时间同步逻辑。该文件实现了单调时钟（monotonic）、原始时钟（raw）、实时时钟（wall-clock）等多种时间视图，并确保在中断上下文、NMI（不可屏蔽中断）等特殊场景下也能安全读取时间。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct timekeeper`**  \n  核心时间保持结构体，包含当前时间、时钟偏移、TAI 偏移、启动时间偏移等关键字段。\n\n- **`struct tk_read_base`**  \n  用于快速时间读取的基础结构，包含时钟源指针、乘数（mult）、移位（shift）、掩码（mask）和上次周期值（cycle_last）等。\n\n- **`struct tk_fast`**  \n  专为 NMI 和中断上下文设计的快速时间读取结构，使用双缓冲（latch-based seqcount）机制实现无锁安全读取。\n\n- **`tk_core`**  \n  全局核心时间保持对象，包含一个 `seqcount_raw_spinlock_t` 序列锁和 `timekeeper` 实例，对齐到 64 字节缓存行以优化性能。\n\n- **`shadow_timekeeper`**  \n  时间保持器的影子副本，用于在更新过程中暂存新值，避免直接修改主结构导致不一致。\n\n- **`dummy_clock`**  \n  早期启动阶段使用的虚拟时钟源，基于 `local_clock()`，在真实时钟源注册前提供基本时间服务。\n\n### 主要函数与宏\n\n- **`tk_normalize_xtime()`**  \n  将纳秒部分规范化，确保 `xtime_nsec` 不超过每秒纳秒数的表示范围。\n\n- **`tk_xtime()` / `tk_set_xtime()` / `tk_xtime_add()`**  \n  用于获取、设置和累加系统实时时钟（wall time）。\n\n- **`tk_set_wall_to_mono()`**  \n  设置 wall-to-monotonic 偏移，并同步更新 `offs_real` 和 `offs_tai`。\n\n- **`tk_update_sleep_time()`**  \n  在系统从挂起状态恢复时，更新启动时间偏移（`offs_boot`）。\n\n- **`tk_clock_read()`**  \n  安全读取当前时钟源的周期值，防止在时钟源切换过程中发生崩溃。\n\n- **`timekeeping_check_update()`（仅调试模式）**  \n  检查时钟周期偏移是否超出安全范围，防止溢出或下溢。\n\n- **`update_fast_timekeeper()`（未完整显示但被引用）**  \n  更新 `tk_fast_mono` 和 `tk_fast_raw`，用于 NMI 安全的时间读取。\n\n### 全局变量\n\n- `timekeeper_lock`：保护 `tk_core` 的原始自旋锁。\n- `timekeeping_suspended`：标志系统时间保持是否处于挂起状态。\n- `cycles_at_suspend`：系统挂起时记录的时钟周期值。\n- `tk_fast_mono` / `tk_fast_raw`：分别用于单调时间和原始时间的快速读取路径。\n\n## 3. 关键实现\n\n### 时间读取的无锁安全机制\n\n为支持在 NMI、中断等不可睡眠上下文中安全读取时间，内核引入了 `tk_fast` 结构。它使用 `seqcount_latch_t`（一种双缓冲序列计数器），通过切换两个 `tk_read_base` 实例（索引由序列计数器最低位决定）来实现更新与读取的分离。读取时只需读取当前有效的副本，无需加锁。\n\n### 时间规范化与溢出处理\n\n`tk_normalize_xtime()` 确保纳秒字段不会超过 `NSEC_PER_SEC << shift`，避免在时间计算中出现逻辑错误。同时，`CONFIG_DEBUG_TIMEKEEPING` 启用时会检查周期偏移是否超过时钟源的 `max_cycles`，防止因时钟源回绕或频率异常导致时间跳变。\n\n### 早期启动支持\n\n在系统早期启动阶段，真实时钟源尚未注册，此时使用 `dummy_clock` 作为占位时钟源。其 `read` 函数返回 `local_clock()`（通常基于 TSC 或 jiffies），并设置 `mult=1, shift=0`，因为 `local_clock()` 直接返回纳秒值，无需转换。\n\n### 挂起/恢复处理\n\n当系统挂起时，`timekeeping_suspend()` 会记录当前时钟周期值到 `cycles_at_suspend`，并将 `dummy_clock` 的 `read` 函数改为返回该固定值，防止挂起期间时间继续推进。恢复时再切换回真实时钟源并补偿睡眠时间。\n\n### 序列锁保护\n\n主时间保持结构 `tk_core` 使用 `seqcount_raw_spinlock_t` 保护。写操作需持有 `timekeeper_lock`，读操作通过 `read_seqcount_begin()` / `read_seqcount_retry()` 实现无锁但一致的读取，适用于大多数用户空间时间查询路径（如 VDSO）。\n\n## 4. 依赖关系\n\n- **`<linux/clocksource.h>`**：依赖时钟源抽象，用于获取高精度硬件计时器。\n- **`<linux/tick.h>` / `tick-internal.h`**：与 tick 管理子系统交互，处理周期性时间更新。\n- **`ntp_internal.h`**：集成 NTP 频率调整和闰秒处理逻辑。\n- **`timekeeping_internal.h`**：包含内部辅助函数和结构定义。\n- **`<linux/vdso.h>` / `pvclock_gtod.h`**：为 VDSO 和虚拟化环境（如 Xen、KVM）提供高效时间读取支持。\n- **`<linux/sched/clock.h>`**：使用 `local_clock()` 作为早期启动和虚拟时钟源。\n- **`<linux/stop_machine.h>`**：在某些关键更新路径中可能使用 stop-machine 机制确保全局一致性。\n\n## 5. 使用场景\n\n- **系统调用时间查询**：如 `clock_gettime(CLOCK_REALTIME)`、`CLOCK_MONOTONIC` 等通过此模块获取高精度时间。\n- **VDSO 加速**：用户空间通过 VDSO 直接读取 `tk_fast` 结构，避免陷入内核。\n- **NMI 和中断处理**：在不可睡眠上下文中安全获取时间戳（如 perf、ftrace、oops 打印）。\n- **系统挂起/恢复**：在 suspend/resume 流程中冻结和恢复时间推进。\n- **NTP 时间同步**：接收用户空间 `adjtimex` 调用，调整时钟频率和偏移。\n- **内核日志时间戳**：`printk` 等日志系统依赖此模块提供单调或实时时钟。\n- **调度器和负载计算**：`update_wall_time()` 被 tick 中断定期调用，驱动时间推进，影响调度、负载均衡等子系统。",
      "similarity": 0.6132850646972656,
      "chunks": [
        {
          "chunk_id": 11,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 1840,
          "end_line": 1985,
          "content": [
            "int timekeeping_suspend(void)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned long flags;",
            "\tstruct timespec64\t\tdelta, delta_delta;",
            "\tstatic struct timespec64\told_delta;",
            "\tstruct clocksource *curr_clock;",
            "\tu64 cycle_now;",
            "",
            "\tread_persistent_clock64(&timekeeping_suspend_time);",
            "",
            "\t/*",
            "\t * On some systems the persistent_clock can not be detected at",
            "\t * timekeeping_init by its return value, so if we see a valid",
            "\t * value returned, update the persistent_clock_exists flag.",
            "\t */",
            "\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)",
            "\t\tpersistent_clock_exists = true;",
            "",
            "\tsuspend_timing_needed = true;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "\ttimekeeping_forward_now(tk);",
            "\ttimekeeping_suspended = 1;",
            "",
            "\t/*",
            "\t * Since we've called forward_now, cycle_last stores the value",
            "\t * just read from the current clocksource. Save this to potentially",
            "\t * use in suspend timing.",
            "\t */",
            "\tcurr_clock = tk->tkr_mono.clock;",
            "\tcycle_now = tk->tkr_mono.cycle_last;",
            "\tclocksource_start_suspend_timing(curr_clock, cycle_now);",
            "",
            "\tif (persistent_clock_exists) {",
            "\t\t/*",
            "\t\t * To avoid drift caused by repeated suspend/resumes,",
            "\t\t * which each can add ~1 second drift error,",
            "\t\t * try to compensate so the difference in system time",
            "\t\t * and persistent_clock time stays close to constant.",
            "\t\t */",
            "\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);",
            "\t\tdelta_delta = timespec64_sub(delta, old_delta);",
            "\t\tif (abs(delta_delta.tv_sec) >= 2) {",
            "\t\t\t/*",
            "\t\t\t * if delta_delta is too large, assume time correction",
            "\t\t\t * has occurred and set old_delta to the current delta.",
            "\t\t\t */",
            "\t\t\told_delta = delta;",
            "\t\t} else {",
            "\t\t\t/* Otherwise try to adjust old_system to compensate */",
            "\t\t\ttimekeeping_suspend_time =",
            "\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);",
            "\t\t}",
            "\t}",
            "",
            "\ttimekeeping_update(tk, TK_MIRROR);",
            "\thalt_fast_timekeeper(tk);",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\ttick_suspend();",
            "\tclocksource_suspend();",
            "\tclockevents_suspend();",
            "",
            "\treturn 0;",
            "}",
            "static int __init timekeeping_init_ops(void)",
            "{",
            "\tregister_syscore_ops(&timekeeping_syscore_ops);",
            "\treturn 0;",
            "}",
            "static __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,",
            "\t\t\t\t\t\t\t s64 offset,",
            "\t\t\t\t\t\t\t s32 mult_adj)",
            "{",
            "\ts64 interval = tk->cycle_interval;",
            "",
            "\tif (mult_adj == 0) {",
            "\t\treturn;",
            "\t} else if (mult_adj == -1) {",
            "\t\tinterval = -interval;",
            "\t\toffset = -offset;",
            "\t} else if (mult_adj != 1) {",
            "\t\tinterval *= mult_adj;",
            "\t\toffset *= mult_adj;",
            "\t}",
            "",
            "\t/*",
            "\t * So the following can be confusing.",
            "\t *",
            "\t * To keep things simple, lets assume mult_adj == 1 for now.",
            "\t *",
            "\t * When mult_adj != 1, remember that the interval and offset values",
            "\t * have been appropriately scaled so the math is the same.",
            "\t *",
            "\t * The basic idea here is that we're increasing the multiplier",
            "\t * by one, this causes the xtime_interval to be incremented by",
            "\t * one cycle_interval. This is because:",
            "\t *\txtime_interval = cycle_interval * mult",
            "\t * So if mult is being incremented by one:",
            "\t *\txtime_interval = cycle_interval * (mult + 1)",
            "\t * Its the same as:",
            "\t *\txtime_interval = (cycle_interval * mult) + cycle_interval",
            "\t * Which can be shortened to:",
            "\t *\txtime_interval += cycle_interval",
            "\t *",
            "\t * So offset stores the non-accumulated cycles. Thus the current",
            "\t * time (in shifted nanoseconds) is:",
            "\t *\tnow = (offset * adj) + xtime_nsec",
            "\t * Now, even though we're adjusting the clock frequency, we have",
            "\t * to keep time consistent. In other words, we can't jump back",
            "\t * in time, and we also want to avoid jumping forward in time.",
            "\t *",
            "\t * So given the same offset value, we need the time to be the same",
            "\t * both before and after the freq adjustment.",
            "\t *\tnow = (offset * adj_1) + xtime_nsec_1",
            "\t *\tnow = (offset * adj_2) + xtime_nsec_2",
            "\t * So:",
            "\t *\t(offset * adj_1) + xtime_nsec_1 =",
            "\t *\t\t(offset * adj_2) + xtime_nsec_2",
            "\t * And we know:",
            "\t *\tadj_2 = adj_1 + 1",
            "\t * So:",
            "\t *\t(offset * adj_1) + xtime_nsec_1 =",
            "\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2",
            "\t *\t(offset * adj_1) + xtime_nsec_1 =",
            "\t *\t\t(offset * adj_1) + offset + xtime_nsec_2",
            "\t * Canceling the sides:",
            "\t *\txtime_nsec_1 = offset + xtime_nsec_2",
            "\t * Which gives us:",
            "\t *\txtime_nsec_2 = xtime_nsec_1 - offset",
            "\t * Which simplifies to:",
            "\t *\txtime_nsec -= offset",
            "\t */",
            "\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {",
            "\t\t/* NTP adjustment caused clocksource mult overflow */",
            "\t\tWARN_ON_ONCE(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\ttk->tkr_mono.mult += mult_adj;",
            "\ttk->xtime_interval += interval;",
            "\ttk->tkr_mono.xtime_nsec -= offset;",
            "}"
          ],
          "function_name": "timekeeping_suspend, timekeeping_init_ops, timekeeping_apply_adjustment",
          "description": "实现系统挂起时的持久化时间记录与调整逻辑，初始化时间管理核心操作，应用频率调整参数以保持时间一致性",
          "similarity": 0.6089425086975098
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 1689,
          "end_line": 1793,
          "content": [
            "static void __timekeeping_inject_sleeptime(struct timekeeper *tk,",
            "\t\t\t\t\t   const struct timespec64 *delta)",
            "{",
            "\tif (!timespec64_valid_strict(delta)) {",
            "\t\tprintk_deferred(KERN_WARNING",
            "\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"",
            "\t\t\t\t\"sleep delta value!\\n\");",
            "\t\treturn;",
            "\t}",
            "\ttk_xtime_add(tk, delta);",
            "\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));",
            "\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));",
            "\ttk_debug_account_sleep_time(delta);",
            "}",
            "bool timekeeping_rtc_skipresume(void)",
            "{",
            "\treturn !suspend_timing_needed;",
            "}",
            "bool timekeeping_rtc_skipsuspend(void)",
            "{",
            "\treturn persistent_clock_exists;",
            "}",
            "void timekeeping_inject_sleeptime64(const struct timespec64 *delta)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\tsuspend_timing_needed = false;",
            "",
            "\ttimekeeping_forward_now(tk);",
            "",
            "\t__timekeeping_inject_sleeptime(tk, delta);",
            "",
            "\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);",
            "",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\t/* Signal hrtimers about time change */",
            "\tclock_was_set(CLOCK_SET_WALL | CLOCK_SET_BOOT);",
            "}",
            "void timekeeping_resume(void)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tstruct clocksource *clock = tk->tkr_mono.clock;",
            "\tunsigned long flags;",
            "\tstruct timespec64 ts_new, ts_delta;",
            "\tu64 cycle_now, nsec;",
            "\tbool inject_sleeptime = false;",
            "",
            "\tread_persistent_clock64(&ts_new);",
            "",
            "\tclockevents_resume();",
            "\tclocksource_resume();",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\t/*",
            "\t * After system resumes, we need to calculate the suspended time and",
            "\t * compensate it for the OS time. There are 3 sources that could be",
            "\t * used: Nonstop clocksource during suspend, persistent clock and rtc",
            "\t * device.",
            "\t *",
            "\t * One specific platform may have 1 or 2 or all of them, and the",
            "\t * preference will be:",
            "\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc",
            "\t * The less preferred source will only be tried if there is no better",
            "\t * usable source. The rtc part is handled separately in rtc core code.",
            "\t */",
            "\tcycle_now = tk_clock_read(&tk->tkr_mono);",
            "\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);",
            "\tif (nsec > 0) {",
            "\t\tts_delta = ns_to_timespec64(nsec);",
            "\t\tinject_sleeptime = true;",
            "\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {",
            "\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);",
            "\t\tinject_sleeptime = true;",
            "\t}",
            "",
            "\tif (inject_sleeptime) {",
            "\t\tsuspend_timing_needed = false;",
            "\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);",
            "\t}",
            "",
            "\t/* Re-base the last cycle value */",
            "\ttk->tkr_mono.cycle_last = cycle_now;",
            "\ttk->tkr_raw.cycle_last  = cycle_now;",
            "",
            "\ttk->ntp_error = 0;",
            "\ttimekeeping_suspended = 0;",
            "\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\ttouch_softlockup_watchdog();",
            "",
            "\t/* Resume the clockevent device(s) and hrtimers */",
            "\ttick_resume();",
            "\t/* Notify timerfd as resume is equivalent to clock_was_set() */",
            "\ttimerfd_resume();",
            "}"
          ],
          "function_name": "__timekeeping_inject_sleeptime, timekeeping_rtc_skipresume, timekeeping_rtc_skipsuspend, timekeeping_inject_sleeptime64, timekeeping_resume",
          "description": "处理系统挂起/恢复时的时间调整，注入睡眠时间到时间保持器，控制RTC跳过逻辑，并通过clocksource计算周期差补偿系统时间",
          "similarity": 0.5420597791671753
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 2423,
          "end_line": 2497,
          "content": [
            "int do_adjtimex(struct __kernel_timex *txc)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tstruct audit_ntp_data ad;",
            "\tbool clock_set = false;",
            "\tstruct timespec64 ts;",
            "\tunsigned long flags;",
            "\ts32 orig_tai, tai;",
            "\tint ret;",
            "",
            "\t/* Validate the data before disabling interrupts */",
            "\tret = timekeeping_validate_timex(txc);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tadd_device_randomness(txc, sizeof(*txc));",
            "",
            "\tif (txc->modes & ADJ_SETOFFSET) {",
            "\t\tstruct timespec64 delta;",
            "\t\tdelta.tv_sec  = txc->time.tv_sec;",
            "\t\tdelta.tv_nsec = txc->time.tv_usec;",
            "\t\tif (!(txc->modes & ADJ_NANO))",
            "\t\t\tdelta.tv_nsec *= 1000;",
            "\t\tret = timekeeping_inject_offset(&delta);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "",
            "\t\taudit_tk_injoffset(delta);",
            "\t}",
            "",
            "\taudit_ntp_init(&ad);",
            "",
            "\tktime_get_real_ts64(&ts);",
            "\tadd_device_randomness(&ts, sizeof(ts));",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\torig_tai = tai = tk->tai_offset;",
            "\tret = __do_adjtimex(txc, &ts, &tai, &ad);",
            "",
            "\tif (tai != orig_tai) {",
            "\t\t__timekeeping_set_tai_offset(tk, tai);",
            "\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);",
            "\t\tclock_set = true;",
            "\t}",
            "\ttk_update_leap_state(tk);",
            "",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\taudit_ntp_log(&ad);",
            "",
            "\t/* Update the multiplier immediately if frequency was set directly */",
            "\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))",
            "\t\tclock_set |= timekeeping_advance(TK_ADV_FREQ);",
            "",
            "\tif (clock_set)",
            "\t\tclock_was_set(CLOCK_SET_WALL);",
            "",
            "\tntp_notify_cmos_timer();",
            "",
            "\treturn ret;",
            "}",
            "void hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\t__hardpps(phase_ts, raw_ts);",
            "",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "}"
          ],
          "function_name": "do_adjtimex, hardpps",
          "description": "该代码段实现时间调整与硬件脉冲信号处理功能。do_adjtimex函数负责解析并应用用户空间通过TIMEX接口提交的时间校准请求（如偏移量设置、频率调整），通过锁定时间保持器并更新TAI偏移量实现系统时间同步，同时记录审计日志。hardpps函数作为硬件PPS信号处理入口，通过加锁机制将相位时间戳传递给底层时间校准逻辑以修正系统时钟。",
          "similarity": 0.511757493019104
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 1,
          "end_line": 78,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  Kernel timekeeping code and accessor functions. Based on code from",
            " *  timer.c, moved in commit 8524070b7982.",
            " */",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/tick.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/compiler.h>",
            "#include <linux/audit.h>",
            "#include <linux/random.h>",
            "",
            "#include \"tick-internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"timekeeping_internal.h\"",
            "",
            "#define TK_CLEAR_NTP\t\t(1 << 0)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "",
            "enum timekeeping_adv_mode {",
            "\t/* Update timekeeper when a tick has passed */",
            "\tTK_ADV_TICK,",
            "",
            "\t/* Update timekeeper on a direct frequency change */",
            "\tTK_ADV_FREQ",
            "};",
            "",
            "DEFINE_RAW_SPINLOCK(timekeeper_lock);",
            "",
            "/*",
            " * The most important data for readout fits into a single 64 byte",
            " * cache line.",
            " */",
            "static struct {",
            "\tseqcount_raw_spinlock_t\tseq;",
            "\tstruct timekeeper\ttimekeeper;",
            "} tk_core ____cacheline_aligned = {",
            "\t.seq = SEQCNT_RAW_SPINLOCK_ZERO(tk_core.seq, &timekeeper_lock),",
            "};",
            "",
            "static struct timekeeper shadow_timekeeper;",
            "",
            "/* flag for if timekeeping is suspended */",
            "int __read_mostly timekeeping_suspended;",
            "",
            "/**",
            " * struct tk_fast - NMI safe timekeeper",
            " * @seq:\tSequence counter for protecting updates. The lowest bit",
            " *\t\tis the index for the tk_read_base array",
            " * @base:\ttk_read_base array. Access is indexed by the lowest bit of",
            " *\t\t@seq.",
            " *",
            " * See @update_fast_timekeeper() below.",
            " */",
            "struct tk_fast {",
            "\tseqcount_latch_t\tseq;",
            "\tstruct tk_read_base\tbase[2];",
            "};",
            "",
            "/* Suspend-time cycles value for halted fast timekeeper. */",
            "static u64 cycles_at_suspend;",
            ""
          ],
          "function_name": null,
          "description": "定义时间保持器核心结构体和锁，声明TK标志位枚举及全局时间保持器实例，提供NMI安全时间记录结构体tk_fast的定义，用于保护时间数据更新的序列计数器和基础读取结构体",
          "similarity": 0.4884222149848938
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 581,
          "end_line": 699,
          "content": [
            "u64 ktime_get_real_fast_ns(void)",
            "{",
            "\treturn __ktime_get_real_fast(&tk_fast_mono, NULL);",
            "}",
            "void ktime_get_fast_timestamps(struct ktime_timestamps *snapshot)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "",
            "\tsnapshot->real = __ktime_get_real_fast(&tk_fast_mono, &snapshot->mono);",
            "\tsnapshot->boot = snapshot->mono + ktime_to_ns(data_race(tk->offs_boot));",
            "}",
            "static void halt_fast_timekeeper(const struct timekeeper *tk)",
            "{",
            "\tstatic struct tk_read_base tkr_dummy;",
            "\tconst struct tk_read_base *tkr = &tk->tkr_mono;",
            "",
            "\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));",
            "\tcycles_at_suspend = tk_clock_read(tkr);",
            "\ttkr_dummy.clock = &dummy_clock;",
            "\ttkr_dummy.base_real = tkr->base + tk->offs_real;",
            "\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_mono);",
            "",
            "\ttkr = &tk->tkr_raw;",
            "\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));",
            "\ttkr_dummy.clock = &dummy_clock;",
            "\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_raw);",
            "}",
            "static void update_pvclock_gtod(struct timekeeper *tk, bool was_set)",
            "{",
            "\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);",
            "}",
            "int pvclock_gtod_register_notifier(struct notifier_block *nb)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\tret = raw_notifier_chain_register(&pvclock_gtod_chain, nb);",
            "\tupdate_pvclock_gtod(tk, true);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "int pvclock_gtod_unregister_notifier(struct notifier_block *nb)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\tret = raw_notifier_chain_unregister(&pvclock_gtod_chain, nb);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "static inline void tk_update_leap_state(struct timekeeper *tk)",
            "{",
            "\ttk->next_leap_ktime = ntp_get_next_leap();",
            "\tif (tk->next_leap_ktime != KTIME_MAX)",
            "\t\t/* Convert to monotonic time */",
            "\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);",
            "}",
            "static inline void tk_update_ktime_data(struct timekeeper *tk)",
            "{",
            "\tu64 seconds;",
            "\tu32 nsec;",
            "",
            "\t/*",
            "\t * The xtime based monotonic readout is:",
            "\t *\tnsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();",
            "\t * The ktime based monotonic readout is:",
            "\t *\tnsec = base_mono + now();",
            "\t * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec",
            "\t */",
            "\tseconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);",
            "\tnsec = (u32) tk->wall_to_monotonic.tv_nsec;",
            "\ttk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);",
            "",
            "\t/*",
            "\t * The sum of the nanoseconds portions of xtime and",
            "\t * wall_to_monotonic can be greater/equal one second. Take",
            "\t * this into account before updating tk->ktime_sec.",
            "\t */",
            "\tnsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);",
            "\tif (nsec >= NSEC_PER_SEC)",
            "\t\tseconds++;",
            "\ttk->ktime_sec = seconds;",
            "",
            "\t/* Update the monotonic raw base */",
            "\ttk->tkr_raw.base = ns_to_ktime(tk->raw_sec * NSEC_PER_SEC);",
            "}",
            "static void timekeeping_update(struct timekeeper *tk, unsigned int action)",
            "{",
            "\tif (action & TK_CLEAR_NTP) {",
            "\t\ttk->ntp_error = 0;",
            "\t\tntp_clear();",
            "\t}",
            "",
            "\ttk_update_leap_state(tk);",
            "\ttk_update_ktime_data(tk);",
            "",
            "\tupdate_vsyscall(tk);",
            "\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);",
            "",
            "\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;",
            "\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);",
            "\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);",
            "",
            "\tif (action & TK_CLOCK_WAS_SET)",
            "\t\ttk->clock_was_set_seq++;",
            "\t/*",
            "\t * The mirroring of the data to the shadow-timekeeper needs",
            "\t * to happen last here to ensure we don't over-write the",
            "\t * timekeeper structure on the next update with stale data",
            "\t */",
            "\tif (action & TK_MIRROR)",
            "\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,",
            "\t\t       sizeof(tk_core.timekeeper));",
            "}"
          ],
          "function_name": "ktime_get_real_fast_ns, ktime_get_fast_timestamps, halt_fast_timekeeper, update_pvclock_gtod, pvclock_gtod_register_notifier, pvclock_gtod_unregister_notifier, tk_update_leap_state, tk_update_ktime_data, timekeeping_update",
          "description": "更新PVClock时间数据并触发通知链回调，维护时间同步状态和闰年信息，将时间保持器数据同步到虚拟系统调用表，并处理时间设置标记的传播逻辑",
          "similarity": 0.48741817474365234
        }
      ]
    },
    {
      "source_file": "kernel/power/main.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:21:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\main.c`\n\n---\n\n# `power/main.c` 技术文档\n\n## 1. 文件概述\n\n`power/main.c` 是 Linux 内核电源管理（Power Management, PM）子系统的核心实现文件，负责提供系统级电源状态转换（如挂起、休眠）所需的基础功能。该文件实现了电源管理通知机制、内存分配策略控制、系统睡眠锁、异步设备挂起控制、同步行为配置以及调试支持等功能，是连接用户空间接口与底层 PM 实现的关键枢纽。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`pm_restrict_gfp_mask()` / `pm_restore_gfp_mask()`**  \n  在系统睡眠转换期间临时限制内存分配标志（禁止 `__GFP_IO` 和 `__GFP_FS`），防止在设备已挂起时执行 I/O 操作。\n\n- **`lock_system_sleep()` / `unlock_system_sleep()`**  \n  获取/释放系统睡眠互斥锁（`system_transition_mutex`），并设置当前进程的 `PF_NOFREEZE` 标志以避免在关键路径中被冻结。\n\n- **`ksys_sync_helper()`**  \n  执行文件系统同步（`sync`）并记录耗时，用于挂起前的数据一致性保障。\n\n- **`register_pm_notifier()` / `unregister_pm_notifier()`**  \n  注册/注销电源管理状态变更通知回调。\n\n- **`pm_notifier_call_chain()` / `pm_notifier_call_chain_robust()`**  \n  触发电源管理通知链，通知各子系统 PM 状态变化。\n\n- **`pm_report_hw_sleep_time()` / `pm_report_max_hw_sleep()`**  \n  上报硬件实际睡眠时间，用于统计和调试。\n\n- **`mem_sleep_show()` / `mem_sleep_store()`**  \n  通过 sysfs 接口（`/sys/power/mem_sleep`）查询和设置当前使用的内存挂起状态（如 `s2idle`、`shallow`、`deep`）。\n\n- **`sync_on_suspend_show()` / `sync_on_suspend_store()`**  \n  控制是否在挂起前自动执行 `sync` 操作。\n\n- **`pm_test_show()` / `pm_test_store()`**  \n  （调试功能）设置 PM 挂起流程的测试点，用于逐步验证挂起各阶段。\n\n### 主要数据结构与变量\n\n- **`pm_chain_head`**  \n  `BLOCKING_NOTIFIER_HEAD` 类型的通知链头，用于 PM 状态变更广播。\n\n- **`pm_async_enabled`**  \n  全局标志，控制设备挂起/恢复是否允许异步执行（默认启用）。\n\n- **`sync_on_suspend_enabled`**  \n  控制挂起前是否自动同步文件系统（默认启用，除非配置 `CONFIG_SUSPEND_SKIP_SYNC`）。\n\n- **`pm_test_level`**  \n  调试用变量，指定 PM 挂起流程的测试阶段（如 `core`、`devices`、`freezer` 等）。\n\n- **`saved_gfp_mask`**  \n  保存原始 `gfp_allowed_mask`，用于在限制后恢复。\n\n## 3. 关键实现\n\n### 系统睡眠互斥与冻结控制\n- 使用 `system_transition_mutex` 保证系统睡眠状态转换的原子性。\n- `lock_system_sleep()` 设置 `PF_NOFREEZE` 防止当前线程在关键路径中被 freezer 冻结，避免死锁（尤其在休眠快照读写时）。\n- `unlock_system_sleep()` 在释放锁前不清除 `PF_NOFREEZE`（除非原无此标志），确保 freezer 仅在安全时机生效。\n\n### GFP 掩码限制机制\n- 在挂起/休眠准备阶段调用 `pm_restrict_gfp_mask()`，屏蔽可能导致 I/O 的内存分配标志。\n- 该操作必须在持有 `system_transition_mutex` 下进行，防止与并发的 PM 操作冲突。\n- 恢复时通过 `pm_restore_gfp_mask()` 还原原始掩码。\n\n### 通知链机制\n- 基于 `blocking_notifier_chain` 实现 PM 状态通知。\n- 支持普通通知（`pm_notifier_call_chain`）和健壮通知（`_robust`，可区分进入/退出状态）。\n\n### Sysfs 接口实现\n- 通过 `power_attr()` 宏定义 sysfs 属性（如 `pm_async`、`mem_sleep`、`sync_on_suspend`）。\n- `mem_sleep` 接口动态过滤不可用状态（如 CXL 内存活跃时跳过 `PM_SUSPEND_MEM`）。\n- 输入解析使用 `kstrtoul` 或字符串匹配，确保值合法性。\n\n### 调试支持\n- `CONFIG_PM_SLEEP_DEBUG` 启用 `pm_test` 接口，允许用户指定挂起流程的测试点，用于逐步验证各阶段行为。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/suspend.h>`：挂起/休眠核心定义\n  - `<linux/pm_runtime.h>`：运行时 PM 支持\n  - `<linux/acpi.h>`：ACPI 电源管理集成\n  - `<linux/notifier.h>`（隐式）：通知链机制\n  - `\"power.h\"`：本地 PM 子系统内部头文件\n\n- **内核配置依赖**：\n  - `CONFIG_PM_SLEEP`：启用睡眠相关功能（挂起/休眠）\n  - `CONFIG_SUSPEND`：启用挂起（suspend-to-RAM）支持\n  - `CONFIG_PM_SLEEP_DEBUG`：启用 PM 调试接口\n\n- **外部模块交互**：\n  - 与 freezer 子系统协同（通过 `PF_NOFREEZE`）\n  - 与设备驱动模型交互（通过 PM 通知链）\n  - 与内存管理子系统交互（通过 `gfp_allowed_mask`）\n\n## 5. 使用场景\n\n- **系统挂起（Suspend-to-RAM）**：  \n  用户写入 `/sys/power/state` 触发挂起流程，本文件提供状态验证、同步控制、通知广播等核心逻辑。\n\n- **休眠（Hibernation）**：  \n  在创建/恢复内存快照时调用 `lock_system_sleep()` 避免冻结，确保快照操作完整性。\n\n- **运行时电源管理协调**：  \n  通过 PM 通知链告知设备驱动系统即将进入低功耗状态，协调 runtime PM 状态。\n\n- **调试与性能分析**：  \n  开发者可通过 `pm_test` 接口逐步测试挂起流程；通过 `pm_report_hw_sleep_time()` 分析硬件实际睡眠效率。\n\n- **用户空间策略控制**：  \n  系统管理员可通过 sysfs 调整 `mem_sleep` 状态、启用/禁用异步挂起或挂起前同步行为，优化功耗与响应性。",
      "similarity": 0.6073126196861267,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/power/main.c",
          "start_line": 1,
          "end_line": 34,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * kernel/power/main.c - PM subsystem core functionality.",
            " *",
            " * Copyright (c) 2003 Patrick Mochel",
            " * Copyright (c) 2003 Open Source Development Lab",
            " */",
            "",
            "#include <linux/acpi.h>",
            "#include <linux/export.h>",
            "#include <linux/kobject.h>",
            "#include <linux/string.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/suspend.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pm_runtime.h>",
            "",
            "#include \"power.h\"",
            "",
            "#ifdef CONFIG_PM_SLEEP",
            "/*",
            " * The following functions are used by the suspend/hibernate code to temporarily",
            " * change gfp_allowed_mask in order to avoid using I/O during memory allocations",
            " * while devices are suspended.  To avoid races with the suspend/hibernate code,",
            " * they should always be called with system_transition_mutex held",
            " * (gfp_allowed_mask also should only be modified with system_transition_mutex",
            " * held, unless the suspend/hibernate code is guaranteed not to run in parallel",
            " * with that modification).",
            " */",
            "static gfp_t saved_gfp_mask;",
            ""
          ],
          "function_name": null,
          "description": "定义了PM子系统核心功能，包含用于_suspend/_hibernate的gfp_allowed_mask保存与恢复逻辑，声明了保存当前GFP掩码的静态变量saved_gfp_mask，为后续修改内存分配限制提供基础",
          "similarity": 0.5739048719406128
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/power/main.c",
          "start_line": 682,
          "end_line": 786,
          "content": [
            "static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t   const char *buf, size_t n)",
            "{",
            "\tsuspend_state_t state;",
            "\tint error;",
            "",
            "\terror = pm_autosleep_lock();",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\tif (pm_autosleep_state() > PM_SUSPEND_ON) {",
            "\t\terror = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tstate = decode_state(buf, n);",
            "\tif (state < PM_SUSPEND_MAX) {",
            "\t\tif (state == PM_SUSPEND_MEM)",
            "\t\t\tstate = mem_sleep_current;",
            "",
            "\t\terror = pm_suspend(state);",
            "\t} else if (state == PM_SUSPEND_MAX) {",
            "\t\terror = hibernate();",
            "\t} else {",
            "\t\terror = -EINVAL;",
            "\t}",
            "",
            " out:",
            "\tpm_autosleep_unlock();",
            "\treturn error ? error : n;",
            "}",
            "static ssize_t wakeup_count_show(struct kobject *kobj,",
            "\t\t\t\tstruct kobj_attribute *attr,",
            "\t\t\t\tchar *buf)",
            "{",
            "\tunsigned int val;",
            "",
            "\treturn pm_get_wakeup_count(&val, true) ?",
            "\t\tsysfs_emit(buf, \"%u\\n\", val) : -EINTR;",
            "}",
            "static ssize_t wakeup_count_store(struct kobject *kobj,",
            "\t\t\t\tstruct kobj_attribute *attr,",
            "\t\t\t\tconst char *buf, size_t n)",
            "{",
            "\tunsigned int val;",
            "\tint error;",
            "",
            "\terror = pm_autosleep_lock();",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\tif (pm_autosleep_state() > PM_SUSPEND_ON) {",
            "\t\terror = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terror = -EINVAL;",
            "\tif (sscanf(buf, \"%u\", &val) == 1) {",
            "\t\tif (pm_save_wakeup_count(val))",
            "\t\t\terror = n;",
            "\t\telse",
            "\t\t\tpm_print_active_wakeup_sources();",
            "\t}",
            "",
            " out:",
            "\tpm_autosleep_unlock();",
            "\treturn error;",
            "}",
            "static ssize_t autosleep_show(struct kobject *kobj,",
            "\t\t\t      struct kobj_attribute *attr,",
            "\t\t\t      char *buf)",
            "{",
            "\tsuspend_state_t state = pm_autosleep_state();",
            "",
            "\tif (state == PM_SUSPEND_ON)",
            "\t\treturn sysfs_emit(buf, \"off\\n\");",
            "",
            "#ifdef CONFIG_SUSPEND",
            "\tif (state < PM_SUSPEND_MAX)",
            "\t\treturn sysfs_emit(buf, \"%s\\n\", pm_states[state] ?",
            "\t\t\t\t\tpm_states[state] : \"error\");",
            "#endif",
            "#ifdef CONFIG_HIBERNATION",
            "\treturn sysfs_emit(buf, \"disk\\n\");",
            "#else",
            "\treturn sysfs_emit(buf, \"error\\n\");",
            "#endif",
            "}",
            "static ssize_t autosleep_store(struct kobject *kobj,",
            "\t\t\t       struct kobj_attribute *attr,",
            "\t\t\t       const char *buf, size_t n)",
            "{",
            "\tsuspend_state_t state = decode_state(buf, n);",
            "\tint error;",
            "",
            "\tif (state == PM_SUSPEND_ON",
            "\t    && strcmp(buf, \"off\") && strcmp(buf, \"off\\n\"))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (state == PM_SUSPEND_MEM)",
            "\t\tstate = mem_sleep_current;",
            "",
            "\terror = pm_autosleep_set_state(state);",
            "\treturn error ? error : n;",
            "}"
          ],
          "function_name": "state_store, wakeup_count_show, wakeup_count_store, autosleep_show, autosleep_store",
          "description": "实现系统挂起状态设置接口，通过解析输入缓冲区确定挂起模式（普通挂起/休眠），调用pm_suspend或hiberate执行挂起操作，并通过互斥锁保证线程安全。同时提供唤醒计数器读取与设置、自动睡眠状态查询与修改等功能。",
          "similarity": 0.540805459022522
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/power/main.c",
          "start_line": 35,
          "end_line": 137,
          "content": [
            "void pm_restore_gfp_mask(void)",
            "{",
            "\tWARN_ON(!mutex_is_locked(&system_transition_mutex));",
            "\tif (saved_gfp_mask) {",
            "\t\tgfp_allowed_mask = saved_gfp_mask;",
            "\t\tsaved_gfp_mask = 0;",
            "\t}",
            "}",
            "void pm_restrict_gfp_mask(void)",
            "{",
            "\tWARN_ON(!mutex_is_locked(&system_transition_mutex));",
            "\tWARN_ON(saved_gfp_mask);",
            "\tsaved_gfp_mask = gfp_allowed_mask;",
            "\tgfp_allowed_mask &= ~(__GFP_IO | __GFP_FS);",
            "}",
            "unsigned int lock_system_sleep(void)",
            "{",
            "\tunsigned int flags = current->flags;",
            "\tcurrent->flags |= PF_NOFREEZE;",
            "\tmutex_lock(&system_transition_mutex);",
            "\treturn flags;",
            "}",
            "void unlock_system_sleep(unsigned int flags)",
            "{",
            "\t/*",
            "\t * Don't use freezer_count() because we don't want the call to",
            "\t * try_to_freeze() here.",
            "\t *",
            "\t * Reason:",
            "\t * Fundamentally, we just don't need it, because freezing condition",
            "\t * doesn't come into effect until we release the",
            "\t * system_transition_mutex lock, since the freezer always works with",
            "\t * system_transition_mutex held.",
            "\t *",
            "\t * More importantly, in the case of hibernation,",
            "\t * unlock_system_sleep() gets called in snapshot_read() and",
            "\t * snapshot_write() when the freezing condition is still in effect.",
            "\t * Which means, if we use try_to_freeze() here, it would make them",
            "\t * enter the refrigerator, thus causing hibernation to lockup.",
            "\t */",
            "\tif (!(flags & PF_NOFREEZE))",
            "\t\tcurrent->flags &= ~PF_NOFREEZE;",
            "\tmutex_unlock(&system_transition_mutex);",
            "}",
            "void ksys_sync_helper(void)",
            "{",
            "\tktime_t start;",
            "\tlong elapsed_msecs;",
            "",
            "\tstart = ktime_get();",
            "\tksys_sync();",
            "\telapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));",
            "\tpr_info(\"Filesystems sync: %ld.%03ld seconds\\n\",",
            "\t\telapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);",
            "}",
            "int register_pm_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&pm_chain_head, nb);",
            "}",
            "int unregister_pm_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);",
            "}",
            "void pm_report_hw_sleep_time(u64 t)",
            "{",
            "\tsuspend_stats.last_hw_sleep = t;",
            "\tsuspend_stats.total_hw_sleep += t;",
            "}",
            "void pm_report_max_hw_sleep(u64 t)",
            "{",
            "\tsuspend_stats.max_hw_sleep = t;",
            "}",
            "int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)",
            "{",
            "\tint ret;",
            "",
            "\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);",
            "",
            "\treturn notifier_to_errno(ret);",
            "}",
            "int pm_notifier_call_chain(unsigned long val)",
            "{",
            "\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);",
            "}",
            "static ssize_t pm_async_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t     char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%d\\n\", pm_async_enabled);",
            "}",
            "static ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t      const char *buf, size_t n)",
            "{",
            "\tunsigned long val;",
            "",
            "\tif (kstrtoul(buf, 10, &val))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (val > 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tpm_async_enabled = val;",
            "\treturn n;",
            "}"
          ],
          "function_name": "pm_restore_gfp_mask, pm_restrict_gfp_mask, lock_system_sleep, unlock_system_sleep, ksys_sync_helper, register_pm_notifier, unregister_pm_notifier, pm_report_hw_sleep_time, pm_report_max_hw_sleep, pm_notifier_call_chain_robust, pm_notifier_call_chain, pm_async_show, pm_async_store",
          "description": "实现了系统睡眠状态转换期间的GFP掩码控制函数，包含锁定/解锁睡眠状态的current->flags修改逻辑，同步辅助函数，注册注销通知链接口，硬件睡眠时间统计函数，以及控制异步操作的sysfs属性实现",
          "similarity": 0.5378497838973999
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/power/main.c",
          "start_line": 168,
          "end_line": 275,
          "content": [
            "static ssize_t mem_sleep_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t      char *buf)",
            "{",
            "\tssize_t count = 0;",
            "\tsuspend_state_t i;",
            "",
            "\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++) {",
            "\t\tif (i >= PM_SUSPEND_MEM && cxl_mem_active())",
            "\t\t\tcontinue;",
            "\t\tif (mem_sleep_states[i]) {",
            "\t\t\tconst char *label = mem_sleep_states[i];",
            "",
            "\t\t\tif (mem_sleep_current == i)",
            "\t\t\t\tcount += sysfs_emit_at(buf, count, \"[%s] \", label);",
            "\t\t\telse",
            "\t\t\t\tcount += sysfs_emit_at(buf, count, \"%s \", label);",
            "\t\t}",
            "\t}",
            "",
            "\t/* Convert the last space to a newline if needed. */",
            "\tif (count > 0)",
            "\t\tbuf[count - 1] = '\\n';",
            "",
            "\treturn count;",
            "}",
            "static suspend_state_t decode_suspend_state(const char *buf, size_t n)",
            "{",
            "\tsuspend_state_t state;",
            "\tchar *p;",
            "\tint len;",
            "",
            "\tp = memchr(buf, '\\n', n);",
            "\tlen = p ? p - buf : n;",
            "",
            "\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {",
            "\t\tconst char *label = mem_sleep_states[state];",
            "",
            "\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))",
            "\t\t\treturn state;",
            "\t}",
            "",
            "\treturn PM_SUSPEND_ON;",
            "}",
            "static ssize_t mem_sleep_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t       const char *buf, size_t n)",
            "{",
            "\tsuspend_state_t state;",
            "\tint error;",
            "",
            "\terror = pm_autosleep_lock();",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\tif (pm_autosleep_state() > PM_SUSPEND_ON) {",
            "\t\terror = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tstate = decode_suspend_state(buf, n);",
            "\tif (state < PM_SUSPEND_MAX && state > PM_SUSPEND_ON)",
            "\t\tmem_sleep_current = state;",
            "\telse",
            "\t\terror = -EINVAL;",
            "",
            " out:",
            "\tpm_autosleep_unlock();",
            "\treturn error ? error : n;",
            "}",
            "static ssize_t sync_on_suspend_show(struct kobject *kobj,",
            "\t\t\t\t   struct kobj_attribute *attr, char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%d\\n\", sync_on_suspend_enabled);",
            "}",
            "static ssize_t sync_on_suspend_store(struct kobject *kobj,",
            "\t\t\t\t    struct kobj_attribute *attr,",
            "\t\t\t\t    const char *buf, size_t n)",
            "{",
            "\tunsigned long val;",
            "",
            "\tif (kstrtoul(buf, 10, &val))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (val > 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tsync_on_suspend_enabled = !!val;",
            "\treturn n;",
            "}",
            "static ssize_t pm_test_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\tchar *buf)",
            "{",
            "\tssize_t count = 0;",
            "\tint level;",
            "",
            "\tfor (level = TEST_FIRST; level <= TEST_MAX; level++)",
            "\t\tif (pm_tests[level]) {",
            "\t\t\tif (level == pm_test_level)",
            "\t\t\t\tcount += sysfs_emit_at(buf, count, \"[%s] \", pm_tests[level]);",
            "\t\t\telse",
            "\t\t\t\tcount += sysfs_emit_at(buf, count, \"%s \", pm_tests[level]);",
            "\t\t}",
            "",
            "\t/* Convert the last space to a newline if needed. */",
            "\tif (count > 0)",
            "\t\tbuf[count - 1] = '\\n';",
            "",
            "\treturn count;",
            "}"
          ],
          "function_name": "mem_sleep_show, decode_suspend_state, mem_sleep_store, sync_on_suspend_show, sync_on_suspend_store, pm_test_show",
          "description": "提供了内存睡眠状态的读写接口，支持通过sysfs设置目标睡眠状态，包含同步挂起使能控制功能，展示并设置测试模式选项，用于调试和控制系统挂起行为",
          "similarity": 0.5181236267089844
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/power/main.c",
          "start_line": 830,
          "end_line": 922,
          "content": [
            "static ssize_t wake_lock_show(struct kobject *kobj,",
            "\t\t\t      struct kobj_attribute *attr,",
            "\t\t\t      char *buf)",
            "{",
            "\treturn pm_show_wakelocks(buf, true);",
            "}",
            "static ssize_t wake_lock_store(struct kobject *kobj,",
            "\t\t\t       struct kobj_attribute *attr,",
            "\t\t\t       const char *buf, size_t n)",
            "{",
            "\tint error = pm_wake_lock(buf);",
            "\treturn error ? error : n;",
            "}",
            "static ssize_t wake_unlock_show(struct kobject *kobj,",
            "\t\t\t\tstruct kobj_attribute *attr,",
            "\t\t\t\tchar *buf)",
            "{",
            "\treturn pm_show_wakelocks(buf, false);",
            "}",
            "static ssize_t wake_unlock_store(struct kobject *kobj,",
            "\t\t\t\t struct kobj_attribute *attr,",
            "\t\t\t\t const char *buf, size_t n)",
            "{",
            "\tint error = pm_wake_unlock(buf);",
            "\treturn error ? error : n;",
            "}",
            "static ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t     char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%d\\n\", pm_trace_enabled);",
            "}",
            "static ssize_t",
            "pm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t       const char *buf, size_t n)",
            "{",
            "\tint val;",
            "",
            "\tif (sscanf(buf, \"%d\", &val) == 1) {",
            "\t\tpm_trace_enabled = !!val;",
            "\t\tif (pm_trace_enabled) {",
            "\t\t\tpr_warn(\"PM: Enabling pm_trace changes system date and time during resume.\\n\"",
            "\t\t\t\t\"PM: Correct system time has to be restored manually after resume.\\n\");",
            "\t\t}",
            "\t\treturn n;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static ssize_t pm_trace_dev_match_show(struct kobject *kobj,",
            "\t\t\t\t       struct kobj_attribute *attr,",
            "\t\t\t\t       char *buf)",
            "{",
            "\treturn show_trace_dev_match(buf, PAGE_SIZE);",
            "}",
            "static ssize_t pm_freeze_timeout_show(struct kobject *kobj,",
            "\t\t\t\t      struct kobj_attribute *attr, char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%u\\n\", freeze_timeout_msecs);",
            "}",
            "static ssize_t pm_freeze_timeout_store(struct kobject *kobj,",
            "\t\t\t\t       struct kobj_attribute *attr,",
            "\t\t\t\t       const char *buf, size_t n)",
            "{",
            "\tunsigned long val;",
            "",
            "\tif (kstrtoul(buf, 10, &val))",
            "\t\treturn -EINVAL;",
            "",
            "\tfreeze_timeout_msecs = val;",
            "\treturn n;",
            "}",
            "static int __init pm_start_workqueue(void)",
            "{",
            "\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);",
            "",
            "\treturn pm_wq ? 0 : -ENOMEM;",
            "}",
            "static int __init pm_init(void)",
            "{",
            "\tint error = pm_start_workqueue();",
            "\tif (error)",
            "\t\treturn error;",
            "\thibernate_image_size_init();",
            "\thibernate_reserved_size_init();",
            "\tpm_states_init();",
            "\tpower_kobj = kobject_create_and_add(\"power\", NULL);",
            "\tif (!power_kobj)",
            "\t\treturn -ENOMEM;",
            "\terror = sysfs_create_groups(power_kobj, attr_groups);",
            "\tif (error)",
            "\t\treturn error;",
            "\tpm_print_times_init();",
            "\treturn pm_autosleep_init();",
            "}"
          ],
          "function_name": "wake_lock_show, wake_lock_store, wake_unlock_show, wake_unlock_store, pm_trace_show, pm_trace_store, pm_trace_dev_match_show, pm_freeze_timeout_show, pm_freeze_timeout_store, pm_start_workqueue, pm_init",
          "description": "提供唤醒锁状态监控与控制接口，支持显示/添加/移除唤醒锁；管理电源跟踪功能开关及设备匹配规则显示；配置冻结超时参数；初始化电源管理工作队列及sysfs属性组，完成电源管理子系统的整体注册与资源初始化。",
          "similarity": 0.5101456642150879
        }
      ]
    },
    {
      "source_file": "mm/damon/core.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:46:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `damon\\core.c`\n\n---\n\n# `damon/core.c` 技术文档\n\n## 1. 文件概述\n\n`damon/core.c` 是 Linux 内核中 **Data Access MONitor (DAMON)** 子系统的核心实现文件。DAMON 是一个轻量级、可扩展的内存访问监控框架，用于动态跟踪用户空间或内核空间中内存区域的访问模式。该文件提供了 DAMON 的基础数据结构管理、操作集注册机制、区域（region）生命周期控制、目标地址范围设置以及数据访问模式方案（scheme）和过滤器（filter）的创建与销毁等核心功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct damon_region`：表示被监控的连续虚拟内存区域，包含起止地址、访问次数、年龄等元数据。\n- `struct damon_target`：表示一个被监控的目标（如进程地址空间），包含区域链表。\n- `struct damon_ctx`：DAMON 上下文，持有操作集（ops）、目标列表、方案（schemes）等运行时状态。\n- `struct damos`：DAMON Scheme，定义基于访问模式触发的操作（如内存回收、迁移等）。\n- `struct damos_filter`：用于在应用 scheme 前对目标进行过滤（如按内存类型、VMA 属性等）。\n- `struct damon_operations`：抽象不同监控后端（如针对用户空间、内核空间、虚拟机等）的操作接口。\n\n### 主要函数\n- **操作集管理**：\n  - `damon_register_ops()`：注册一个 `damon_operations` 实例。\n  - `damon_select_ops()`：为指定上下文选择已注册的操作集。\n  - `damon_is_registered_ops()`：检查指定 ID 的操作集是否已注册。\n- **区域管理**：\n  - `damon_new_region()` / `damon_free_region()`：分配/释放区域对象（使用 slab 缓存优化）。\n  - `damon_add_region()` / `damon_destroy_region()`：将区域加入目标或从目标中移除并释放。\n  - `damon_set_regions()`：根据给定的地址范围数组更新目标的监控区域集合。\n- **方案与过滤器管理**：\n  - `damon_new_scheme()`：创建新的 DAMON 方案。\n  - `damos_new_filter()` / `damos_destroy_filter()`：创建/销毁方案过滤器。\n  - `damos_add_filter()`：将过滤器添加到方案中。\n- **辅助函数**：\n  - `damon_intersect()`：判断两个地址范围是否相交。\n  - `damon_fill_regions_holes()`：在相邻区域之间填充空洞以形成连续覆盖。\n\n## 3. 关键实现\n\n### 操作集注册机制\n- 使用全局数组 `damon_registered_ops[NR_DAMON_OPS]` 存储已注册的操作集。\n- 通过 `damon_ops_lock` 互斥锁保护并发访问。\n- 注册时检查 ID 是否有效且未被占用；选择操作集时验证其存在性。\n- 支持运行时动态注册不同监控后端（如 `DAMON_OPS_VADDR`, `DAMON_OPS_FVADDR` 等）。\n\n### 区域管理与对齐\n- 所有区域通过专用 slab 缓存 `damon_region_cache` 分配，提升性能。\n- 在 `damon_set_regions()` 中，新区域的边界会按 `DAMON_MIN_REGION` 对齐（通常为页大小），确保最小监控粒度。\n- 区域更新逻辑分为两步：\n  1. 移除与新范围无交集的旧区域；\n  2. 对每个新范围：\n     - 若无交集区域，则新建对齐后的区域；\n     - 若有交集区域，则扩展首尾区域边界，并调用 `damon_fill_regions_holes()` 填补中间空洞，保证连续覆盖。\n\n### 内存安全与并发控制\n- 全局 `damon_lock` 用于保护 DAMON 上下文的运行状态（如 `nr_running_ctxs` 和 `running_exclusive_ctxs`）。\n- 区域和过滤器的增删均使用标准内核链表操作，并维护计数（如 `t->nr_regions`）。\n- 所有内存分配使用 `GFP_KERNEL`，适用于进程上下文。\n\n### 可测试性支持\n- 通过 `CONFIG_DAMON_KUNIT_TEST` 宏可在测试时将 `DAMON_MIN_REGION` 设为 1，便于单元测试精确控制区域边界。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/damon.h>`：DAMON 核心数据结构和 API 定义。\n  - `<linux/kthread.h>`：用于后台监控线程（kdamond）管理。\n  - `<linux/mm.h>`：内存管理相关定义（如页对齐宏）。\n  - `<linux/slab.h>`：slab 分配器接口。\n  - `<trace/events/damon.h>`：DAMON 跟踪点定义（用于 ftrace）。\n- **模块依赖**：\n  - 依赖底层监控操作实现（如 `damon/vaddr.c` 提供用户空间虚拟地址监控 ops）。\n  - 被 DAMON 用户接口模块（如 `sysfs` 或 `debugfs` 接口）调用以配置监控上下文。\n  - 与内存管理子系统（mm）紧密集成，用于访问检测和内存操作（如 madvise）。\n\n## 5. 使用场景\n\n- **内存访问模式分析**：为内存管理优化（如 THP、内存回收、NUMA 迁移）提供实时访问热度数据。\n- **自适应内存管理策略**：通过 `damos` 方案自动执行基于访问模式的操作（如对冷内存调用 `MADV_PAGEOUT`）。\n- **性能剖析工具**：作为 eBPF、perf 等工具的数据源，分析应用内存行为。\n- **云环境资源优化**：在虚拟化或容器环境中识别低效内存使用，实现自动压缩或迁移。\n- **内核子系统集成**：其他内核组件（如 DAMOS-based memory reclaim）可复用 DAMON 的监控能力，无需重复实现访问跟踪逻辑。",
      "similarity": 0.6046577095985413,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "mm/damon/core.c",
          "start_line": 1538,
          "end_line": 1587,
          "content": [
            "static int walk_system_ram(struct resource *res, void *arg)",
            "{",
            "\tstruct damon_system_ram_region *a = arg;",
            "",
            "\tif (a->end - a->start < resource_size(res)) {",
            "\t\ta->start = res->start;",
            "\t\ta->end = res->end;",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool damon_find_biggest_system_ram(unsigned long *start,",
            "\t\t\t\t\t\tunsigned long *end)",
            "",
            "{",
            "\tstruct damon_system_ram_region arg = {};",
            "",
            "\twalk_system_ram_res(0, ULONG_MAX, &arg, walk_system_ram);",
            "\tif (arg.end <= arg.start)",
            "\t\treturn false;",
            "",
            "\t*start = arg.start;",
            "\t*end = arg.end;",
            "\treturn true;",
            "}",
            "int damon_set_region_biggest_system_ram_default(struct damon_target *t,",
            "\t\t\tunsigned long *start, unsigned long *end)",
            "{",
            "\tstruct damon_addr_range addr_range;",
            "",
            "\tif (*start > *end)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!*start && !*end &&",
            "\t\t!damon_find_biggest_system_ram(start, end))",
            "\t\treturn -EINVAL;",
            "",
            "\taddr_range.start = *start;",
            "\taddr_range.end = *end;",
            "\treturn damon_set_regions(t, &addr_range, 1);",
            "}",
            "static int __init damon_init(void)",
            "{",
            "\tdamon_region_cache = KMEM_CACHE(damon_region, 0);",
            "\tif (unlikely(!damon_region_cache)) {",
            "\t\tpr_err(\"creating damon_region_cache fails\\n\");",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "walk_system_ram, damon_find_biggest_system_ram, damon_set_region_biggest_system_ram_default, damon_init",
          "description": "该代码块核心功能是识别并设置系统中最大的连续可用内存区域作为DAMON监控目标的默认范围。`walk_system_ram`遍历内存资源以记录最大区域，`damon_find_biggest_system_ram`通过遍历发现最大内存区间，`damon_set_region_biggest_system_ram_default`负责将找到的区间设置到指定目标。由于`walk_system_ram_res`和`damon_set_regions`等关键函数未在片段中定义，上下文信息不完整。",
          "similarity": 0.611647367477417
        },
        {
          "chunk_id": 0,
          "file_path": "mm/damon/core.c",
          "start_line": 1,
          "end_line": 34,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Data Access Monitor",
            " *",
            " * Author: SeongJae Park <sjpark@amazon.de>",
            " */",
            "",
            "#define pr_fmt(fmt) \"damon: \" fmt",
            "",
            "#include <linux/damon.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/damon.h>",
            "",
            "#ifdef CONFIG_DAMON_KUNIT_TEST",
            "#undef DAMON_MIN_REGION",
            "#define DAMON_MIN_REGION 1",
            "#endif",
            "",
            "static DEFINE_MUTEX(damon_lock);",
            "static int nr_running_ctxs;",
            "static bool running_exclusive_ctxs;",
            "",
            "static DEFINE_MUTEX(damon_ops_lock);",
            "static struct damon_operations damon_registered_ops[NR_DAMON_OPS];",
            "",
            "static struct kmem_cache *damon_region_cache __ro_after_init;",
            "",
            "/* Should be called under damon_ops_lock with id smaller than NR_DAMON_OPS */"
          ],
          "function_name": null,
          "description": "定义DAMON内核模块的核心结构和全局变量，包括操作注册表、互斥锁及内存缓存，用于管理监控区域和操作集。",
          "similarity": 0.5899749994277954
        },
        {
          "chunk_id": 9,
          "file_path": "mm/damon/core.c",
          "start_line": 1359,
          "end_line": 1518,
          "content": [
            "static void kdamond_usleep(unsigned long usecs)",
            "{",
            "\t/* See Documentation/timers/timers-howto.rst for the thresholds */",
            "\tif (usecs > 20 * USEC_PER_MSEC)",
            "\t\tschedule_timeout_idle(usecs_to_jiffies(usecs));",
            "\telse",
            "\t\tusleep_idle_range(usecs, usecs + 1);",
            "}",
            "static int kdamond_wait_activation(struct damon_ctx *ctx)",
            "{",
            "\tstruct damos *s;",
            "\tunsigned long wait_time;",
            "\tunsigned long min_wait_time = 0;",
            "\tbool init_wait_time = false;",
            "",
            "\twhile (!kdamond_need_stop(ctx)) {",
            "\t\tdamon_for_each_scheme(s, ctx) {",
            "\t\t\twait_time = damos_wmark_wait_us(s);",
            "\t\t\tif (!init_wait_time || wait_time < min_wait_time) {",
            "\t\t\t\tinit_wait_time = true;",
            "\t\t\t\tmin_wait_time = wait_time;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (!min_wait_time)",
            "\t\t\treturn 0;",
            "",
            "\t\tkdamond_usleep(min_wait_time);",
            "",
            "\t\tif (ctx->callback.after_wmarks_check &&",
            "\t\t\t\tctx->callback.after_wmarks_check(ctx))",
            "\t\t\tbreak;",
            "\t}",
            "\treturn -EBUSY;",
            "}",
            "static void kdamond_init_intervals_sis(struct damon_ctx *ctx)",
            "{",
            "\tunsigned long sample_interval = ctx->attrs.sample_interval ?",
            "\t\tctx->attrs.sample_interval : 1;",
            "\tunsigned long apply_interval;",
            "\tstruct damos *scheme;",
            "",
            "\tctx->passed_sample_intervals = 0;",
            "\tctx->next_aggregation_sis = ctx->attrs.aggr_interval / sample_interval;",
            "\tctx->next_ops_update_sis = ctx->attrs.ops_update_interval /",
            "\t\tsample_interval;",
            "",
            "\tdamon_for_each_scheme(scheme, ctx) {",
            "\t\tapply_interval = scheme->apply_interval_us ?",
            "\t\t\tscheme->apply_interval_us : ctx->attrs.aggr_interval;",
            "\t\tscheme->next_apply_sis = apply_interval / sample_interval;",
            "\t}",
            "}",
            "static int kdamond_fn(void *data)",
            "{",
            "\tstruct damon_ctx *ctx = data;",
            "\tstruct damon_target *t;",
            "\tstruct damon_region *r, *next;",
            "\tunsigned int max_nr_accesses = 0;",
            "\tunsigned long sz_limit = 0;",
            "",
            "\tpr_debug(\"kdamond (%d) starts\\n\", current->pid);",
            "",
            "\tcomplete(&ctx->kdamond_started);",
            "\tkdamond_init_intervals_sis(ctx);",
            "",
            "\tif (ctx->ops.init)",
            "\t\tctx->ops.init(ctx);",
            "\tif (ctx->callback.before_start && ctx->callback.before_start(ctx))",
            "\t\tgoto done;",
            "",
            "\tsz_limit = damon_region_sz_limit(ctx);",
            "",
            "\twhile (!kdamond_need_stop(ctx)) {",
            "\t\t/*",
            "\t\t * ctx->attrs and ctx->next_{aggregation,ops_update}_sis could",
            "\t\t * be changed from after_wmarks_check() or after_aggregation()",
            "\t\t * callbacks.  Read the values here, and use those for this",
            "\t\t * iteration.  That is, damon_set_attrs() updated new values",
            "\t\t * are respected from next iteration.",
            "\t\t */",
            "\t\tunsigned long next_aggregation_sis = ctx->next_aggregation_sis;",
            "\t\tunsigned long next_ops_update_sis = ctx->next_ops_update_sis;",
            "\t\tunsigned long sample_interval = ctx->attrs.sample_interval;",
            "",
            "\t\tif (kdamond_wait_activation(ctx))",
            "\t\t\tbreak;",
            "",
            "\t\tif (ctx->ops.prepare_access_checks)",
            "\t\t\tctx->ops.prepare_access_checks(ctx);",
            "\t\tif (ctx->callback.after_sampling &&",
            "\t\t\t\tctx->callback.after_sampling(ctx))",
            "\t\t\tbreak;",
            "",
            "\t\tkdamond_usleep(sample_interval);",
            "\t\tctx->passed_sample_intervals++;",
            "",
            "\t\tif (ctx->ops.check_accesses)",
            "\t\t\tmax_nr_accesses = ctx->ops.check_accesses(ctx);",
            "",
            "\t\tif (ctx->passed_sample_intervals >= next_aggregation_sis) {",
            "\t\t\tkdamond_merge_regions(ctx,",
            "\t\t\t\t\tmax_nr_accesses / 10,",
            "\t\t\t\t\tsz_limit);",
            "\t\t\tif (ctx->callback.after_aggregation &&",
            "\t\t\t\t\tctx->callback.after_aggregation(ctx))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * do kdamond_apply_schemes() after kdamond_merge_regions() if",
            "\t\t * possible, to reduce overhead",
            "\t\t */",
            "\t\tif (!list_empty(&ctx->schemes))",
            "\t\t\tkdamond_apply_schemes(ctx);",
            "",
            "\t\tsample_interval = ctx->attrs.sample_interval ?",
            "\t\t\tctx->attrs.sample_interval : 1;",
            "\t\tif (ctx->passed_sample_intervals >= next_aggregation_sis) {",
            "\t\t\tctx->next_aggregation_sis = next_aggregation_sis +",
            "\t\t\t\tctx->attrs.aggr_interval / sample_interval;",
            "",
            "\t\t\tkdamond_reset_aggregated(ctx);",
            "\t\t\tkdamond_split_regions(ctx);",
            "\t\t\tif (ctx->ops.reset_aggregated)",
            "\t\t\t\tctx->ops.reset_aggregated(ctx);",
            "\t\t}",
            "",
            "\t\tif (ctx->passed_sample_intervals >= next_ops_update_sis) {",
            "\t\t\tctx->next_ops_update_sis = next_ops_update_sis +",
            "\t\t\t\tctx->attrs.ops_update_interval /",
            "\t\t\t\tsample_interval;",
            "\t\t\tif (ctx->ops.update)",
            "\t\t\t\tctx->ops.update(ctx);",
            "\t\t\tsz_limit = damon_region_sz_limit(ctx);",
            "\t\t}",
            "\t}",
            "done:",
            "\tdamon_for_each_target(t, ctx) {",
            "\t\tdamon_for_each_region_safe(r, next, t)",
            "\t\t\tdamon_destroy_region(r, t);",
            "\t}",
            "",
            "\tif (ctx->callback.before_terminate)",
            "\t\tctx->callback.before_terminate(ctx);",
            "\tif (ctx->ops.cleanup)",
            "\t\tctx->ops.cleanup(ctx);",
            "",
            "\tpr_debug(\"kdamond (%d) finishes\\n\", current->pid);",
            "\tmutex_lock(&ctx->kdamond_lock);",
            "\tctx->kdamond = NULL;",
            "\tmutex_unlock(&ctx->kdamond_lock);",
            "",
            "\tmutex_lock(&damon_lock);",
            "\tnr_running_ctxs--;",
            "\tif (!nr_running_ctxs && running_exclusive_ctxs)",
            "\t\trunning_exclusive_ctxs = false;",
            "\tmutex_unlock(&damon_lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "kdamond_usleep, kdamond_wait_activation, kdamond_init_intervals_sis, kdamond_fn",
          "description": "主循环管理DAMON进程，休眠指定时间后检查激活条件；执行区域合并和方案应用；处理属性变更和回调函数；最终清理资源并退出线程",
          "similarity": 0.553928017616272
        },
        {
          "chunk_id": 1,
          "file_path": "mm/damon/core.c",
          "start_line": 35,
          "end_line": 186,
          "content": [
            "static bool __damon_is_registered_ops(enum damon_ops_id id)",
            "{",
            "\tstruct damon_operations empty_ops = {};",
            "",
            "\tif (!memcmp(&empty_ops, &damon_registered_ops[id], sizeof(empty_ops)))",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "bool damon_is_registered_ops(enum damon_ops_id id)",
            "{",
            "\tbool registered;",
            "",
            "\tif (id >= NR_DAMON_OPS)",
            "\t\treturn false;",
            "\tmutex_lock(&damon_ops_lock);",
            "\tregistered = __damon_is_registered_ops(id);",
            "\tmutex_unlock(&damon_ops_lock);",
            "\treturn registered;",
            "}",
            "int damon_register_ops(struct damon_operations *ops)",
            "{",
            "\tint err = 0;",
            "",
            "\tif (ops->id >= NR_DAMON_OPS)",
            "\t\treturn -EINVAL;",
            "\tmutex_lock(&damon_ops_lock);",
            "\t/* Fail for already registered ops */",
            "\tif (__damon_is_registered_ops(ops->id)) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "\tdamon_registered_ops[ops->id] = *ops;",
            "out:",
            "\tmutex_unlock(&damon_ops_lock);",
            "\treturn err;",
            "}",
            "int damon_select_ops(struct damon_ctx *ctx, enum damon_ops_id id)",
            "{",
            "\tint err = 0;",
            "",
            "\tif (id >= NR_DAMON_OPS)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&damon_ops_lock);",
            "\tif (!__damon_is_registered_ops(id))",
            "\t\terr = -EINVAL;",
            "\telse",
            "\t\tctx->ops = damon_registered_ops[id];",
            "\tmutex_unlock(&damon_ops_lock);",
            "\treturn err;",
            "}",
            "void damon_add_region(struct damon_region *r, struct damon_target *t)",
            "{",
            "\tlist_add_tail(&r->list, &t->regions_list);",
            "\tt->nr_regions++;",
            "}",
            "static void damon_del_region(struct damon_region *r, struct damon_target *t)",
            "{",
            "\tlist_del(&r->list);",
            "\tt->nr_regions--;",
            "}",
            "static void damon_free_region(struct damon_region *r)",
            "{",
            "\tkmem_cache_free(damon_region_cache, r);",
            "}",
            "void damon_destroy_region(struct damon_region *r, struct damon_target *t)",
            "{",
            "\tdamon_del_region(r, t);",
            "\tdamon_free_region(r);",
            "}",
            "static bool damon_intersect(struct damon_region *r,",
            "\t\tstruct damon_addr_range *re)",
            "{",
            "\treturn !(r->ar.end <= re->start || re->end <= r->ar.start);",
            "}",
            "static int damon_fill_regions_holes(struct damon_region *first,",
            "\t\tstruct damon_region *last, struct damon_target *t)",
            "{",
            "\tstruct damon_region *r = first;",
            "",
            "\tdamon_for_each_region_from(r, t) {",
            "\t\tstruct damon_region *next, *newr;",
            "",
            "\t\tif (r == last)",
            "\t\t\tbreak;",
            "\t\tnext = damon_next_region(r);",
            "\t\tif (r->ar.end != next->ar.start) {",
            "\t\t\tnewr = damon_new_region(r->ar.end, next->ar.start);",
            "\t\t\tif (!newr)",
            "\t\t\t\treturn -ENOMEM;",
            "\t\t\tdamon_insert_region(newr, r, next, t);",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "int damon_set_regions(struct damon_target *t, struct damon_addr_range *ranges,",
            "\t\tunsigned int nr_ranges)",
            "{",
            "\tstruct damon_region *r, *next;",
            "\tunsigned int i;",
            "\tint err;",
            "",
            "\t/* Remove regions which are not in the new ranges */",
            "\tdamon_for_each_region_safe(r, next, t) {",
            "\t\tfor (i = 0; i < nr_ranges; i++) {",
            "\t\t\tif (damon_intersect(r, &ranges[i]))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (i == nr_ranges)",
            "\t\t\tdamon_destroy_region(r, t);",
            "\t}",
            "",
            "\tr = damon_first_region(t);",
            "\t/* Add new regions or resize existing regions to fit in the ranges */",
            "\tfor (i = 0; i < nr_ranges; i++) {",
            "\t\tstruct damon_region *first = NULL, *last, *newr;",
            "\t\tstruct damon_addr_range *range;",
            "",
            "\t\trange = &ranges[i];",
            "\t\t/* Get the first/last regions intersecting with the range */",
            "\t\tdamon_for_each_region_from(r, t) {",
            "\t\t\tif (damon_intersect(r, range)) {",
            "\t\t\t\tif (!first)",
            "\t\t\t\t\tfirst = r;",
            "\t\t\t\tlast = r;",
            "\t\t\t}",
            "\t\t\tif (r->ar.start >= range->end)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (!first) {",
            "\t\t\t/* no region intersects with this range */",
            "\t\t\tnewr = damon_new_region(",
            "\t\t\t\t\tALIGN_DOWN(range->start,",
            "\t\t\t\t\t\tDAMON_MIN_REGION),",
            "\t\t\t\t\tALIGN(range->end, DAMON_MIN_REGION));",
            "\t\t\tif (!newr)",
            "\t\t\t\treturn -ENOMEM;",
            "\t\t\tdamon_insert_region(newr, damon_prev_region(r), r, t);",
            "\t\t} else {",
            "\t\t\t/* resize intersecting regions to fit in this range */",
            "\t\t\tfirst->ar.start = ALIGN_DOWN(range->start,",
            "\t\t\t\t\tDAMON_MIN_REGION);",
            "\t\t\tlast->ar.end = ALIGN(range->end, DAMON_MIN_REGION);",
            "",
            "\t\t\t/* fill possible holes in the range */",
            "\t\t\terr = damon_fill_regions_holes(first, last, t);",
            "\t\t\tif (err)",
            "\t\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__damon_is_registered_ops, damon_is_registered_ops, damon_register_ops, damon_select_ops, damon_add_region, damon_del_region, damon_free_region, damon_destroy_region, damon_intersect, damon_fill_regions_holes, damon_set_regions",
          "description": "提供操作注册与验证接口，实现区域增删改逻辑，支持动态调整监控范围并填充潜在空洞，用于维护监控区域集合。",
          "similarity": 0.5213565826416016
        },
        {
          "chunk_id": 2,
          "file_path": "mm/damon/core.c",
          "start_line": 280,
          "end_line": 380,
          "content": [
            "void damos_add_filter(struct damos *s, struct damos_filter *f)",
            "{",
            "\tlist_add_tail(&f->list, &s->filters);",
            "}",
            "static void damos_del_filter(struct damos_filter *f)",
            "{",
            "\tlist_del(&f->list);",
            "}",
            "static void damos_free_filter(struct damos_filter *f)",
            "{",
            "\tkfree(f);",
            "}",
            "void damos_destroy_filter(struct damos_filter *f)",
            "{",
            "\tdamos_del_filter(f);",
            "\tdamos_free_filter(f);",
            "}",
            "static void damos_set_next_apply_sis(struct damos *s, struct damon_ctx *ctx)",
            "{",
            "\tunsigned long sample_interval = ctx->attrs.sample_interval ?",
            "\t\tctx->attrs.sample_interval : 1;",
            "\tunsigned long apply_interval = s->apply_interval_us ?",
            "\t\ts->apply_interval_us : ctx->attrs.aggr_interval;",
            "",
            "\ts->next_apply_sis = ctx->passed_sample_intervals +",
            "\t\tapply_interval / sample_interval;",
            "}",
            "void damon_add_scheme(struct damon_ctx *ctx, struct damos *s)",
            "{",
            "\tlist_add_tail(&s->list, &ctx->schemes);",
            "\tdamos_set_next_apply_sis(s, ctx);",
            "}",
            "static void damon_del_scheme(struct damos *s)",
            "{",
            "\tlist_del(&s->list);",
            "}",
            "static void damon_free_scheme(struct damos *s)",
            "{",
            "\tkfree(s);",
            "}",
            "void damon_destroy_scheme(struct damos *s)",
            "{",
            "\tstruct damos_filter *f, *next;",
            "",
            "\tdamos_for_each_filter_safe(f, next, s)",
            "\t\tdamos_destroy_filter(f);",
            "\tdamon_del_scheme(s);",
            "\tdamon_free_scheme(s);",
            "}",
            "void damon_add_target(struct damon_ctx *ctx, struct damon_target *t)",
            "{",
            "\tlist_add_tail(&t->list, &ctx->adaptive_targets);",
            "}",
            "bool damon_targets_empty(struct damon_ctx *ctx)",
            "{",
            "\treturn list_empty(&ctx->adaptive_targets);",
            "}",
            "static void damon_del_target(struct damon_target *t)",
            "{",
            "\tlist_del(&t->list);",
            "}",
            "void damon_free_target(struct damon_target *t)",
            "{",
            "\tstruct damon_region *r, *next;",
            "",
            "\tdamon_for_each_region_safe(r, next, t)",
            "\t\tdamon_free_region(r);",
            "\tkfree(t);",
            "}",
            "void damon_destroy_target(struct damon_target *t)",
            "{",
            "\tdamon_del_target(t);",
            "\tdamon_free_target(t);",
            "}",
            "unsigned int damon_nr_regions(struct damon_target *t)",
            "{",
            "\treturn t->nr_regions;",
            "}",
            "static void damon_destroy_targets(struct damon_ctx *ctx)",
            "{",
            "\tstruct damon_target *t, *next_t;",
            "",
            "\tif (ctx->ops.cleanup) {",
            "\t\tctx->ops.cleanup(ctx);",
            "\t\treturn;",
            "\t}",
            "",
            "\tdamon_for_each_target_safe(t, next_t, ctx)",
            "\t\tdamon_destroy_target(t);",
            "}",
            "void damon_destroy_ctx(struct damon_ctx *ctx)",
            "{",
            "\tstruct damos *s, *next_s;",
            "",
            "\tdamon_destroy_targets(ctx);",
            "",
            "\tdamon_for_each_scheme_safe(s, next_s, ctx)",
            "\t\tdamon_destroy_scheme(s);",
            "",
            "\tkfree(ctx);",
            "}"
          ],
          "function_name": "damos_add_filter, damos_del_filter, damos_free_filter, damos_destroy_filter, damos_set_next_apply_sis, damon_add_scheme, damon_del_scheme, damon_free_scheme, damon_destroy_scheme, damon_add_target, damon_targets_empty, damon_del_target, damon_free_target, damon_destroy_target, damon_nr_regions, damon_destroy_targets, damon_destroy_ctx",
          "description": "管理过滤器、方案和目标对象生命周期，包含添加/移除操作及资源释放函数，用于构建复杂的监控策略配置体系。",
          "similarity": 0.520453929901123
        }
      ]
    }
  ]
}