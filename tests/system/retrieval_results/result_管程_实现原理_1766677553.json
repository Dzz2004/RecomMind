{
  "query": "管程 实现原理",
  "timestamp": "2025-12-25 23:45:53",
  "retrieved_files": [
    {
      "source_file": "kernel/watch_queue.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:50:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watch_queue.c`\n\n---\n\n# watch_queue.c 技术文档\n\n## 文件概述\n\n`watch_queue.c` 实现了 Linux 内核中的**监视队列**（Watch Queue）机制，这是一种基于管道（pipe）构建的通用事件通知系统。该机制允许内核子系统（如文件系统、密钥管理、设备驱动等）向用户空间异步发送结构化通知。用户空间通过创建特殊类型的管道并关联监视队列，即可接收来自内核的各类事件通知。该文件定义了通知的投递、过滤、缓冲管理及与管道集成的核心逻辑。\n\n## 核心功能\n\n### 主要函数\n\n- **`__post_watch_notification()`**  \n  核心通知投递函数。遍历指定 `watch_list` 中所有匹配 `id` 的监视器（`watch`），对每个关联的 `watch_queue` 应用过滤规则、安全检查，并将通知写入底层管道。\n\n- **`post_one_notification()`**  \n  将单个通知写入指定 `watch_queue` 的底层管道缓冲区。负责从预分配的通知页中获取空闲槽位、填充数据、更新管道头指针并唤醒等待读取的进程。\n\n- **`filter_watch_notification()`**  \n  根据 `watch_filter` 中的类型、子类型和信息掩码规则，判断是否允许特定通知通过。\n\n- **`watch_queue_set_size()`**  \n  为监视队列分配预分配的通知缓冲区（页数组和位图），并调整底层管道的环形缓冲区大小。\n\n- **`watch_queue_pipe_buf_release()`**  \n  管道缓冲区释放回调。当用户空间读取完通知后，将对应的通知槽位在位图中标记为空闲，供后续复用。\n\n### 关键数据结构\n\n- **`struct watch_queue`**  \n  表示一个监视队列，包含：\n  - 指向底层 `pipe_inode_info` 的指针\n  - 预分配的通知页数组（`notes`）\n  - 通知槽位空闲位图（`notes_bitmap`）\n  - 通知过滤器（`filter`）\n  - 保护锁（`lock`）\n\n- **`struct watch_notification`**  \n  通用通知记录格式，包含类型（`type`）、子类型（`subtype`）、信息字段（`info`，含长度和ID）及可变负载。\n\n- **`struct watch_filter` / `struct watch_type_filter`**  \n  定义通知过滤规则，支持按类型、子类型及信息字段的位掩码进行精确过滤。\n\n- **`watch_queue_pipe_buf_ops`**  \n  自定义的 `pipe_buf_operations`，用于管理监视队列专用管道缓冲区的生命周期。\n\n## 关键实现\n\n### 基于管道的通知传输\n- 监视队列复用内核管道（`pipe_inode_info`）作为通知传输通道，利用其成熟的读写、轮询、异步通知机制。\n- 通过自定义 `pipe_buf_operations`（`watch_queue_pipe_buf_ops`）实现通知槽位的回收：当用户读取通知后，`release` 回调将对应槽位在 `notes_bitmap` 中置位，标记为空闲。\n\n### 预分配通知缓冲区\n- 通知数据存储在预分配的内核页（`notes`）中，每页划分为多个固定大小（128字节）的槽位（`WATCH_QUEUE_NOTE_SIZE`）。\n- 使用位图（`notes_bitmap`）跟踪槽位使用状态，1 表示空闲。投递通知时通过 `find_first_bit()` 快速查找空闲槽位。\n- 缓冲区大小由用户通过 `watch_queue_set_size()` 设置（1-512个通知），并受管道缓冲区配额限制。\n\n### 通知投递流程\n1. **匹配监视器**：遍历 `watch_list`，查找 `id` 匹配的 `watch`。\n2. **应用过滤**：若队列配置了过滤器，调用 `filter_watch_notification()` 决定是否丢弃。\n3. **安全检查**：调用 LSM 钩子 `security_post_notification()` 进行权限验证。\n4. **写入管道**：\n   - 获取空闲通知槽位，复制通知数据。\n   - 构造 `pipe_buffer` 指向该槽位，设置自定义操作集。\n   - 更新管道 `head` 指针，唤醒等待读取的进程。\n   - 若缓冲区满，标记前一个缓冲区为 `PIPE_BUF_FLAG_LOSS` 表示丢包。\n\n### 并发与同步\n- **RCU 保护**：`watch_list` 和 `watch_queue` 的访问通过 RCU 机制保护，确保遍历时结构体不被释放。\n- **自旋锁**：\n  - `wqueue->lock`：保护 `wqueue` 状态（如 `pipe` 指针有效性）。\n  - `pipe->rd_wait.lock`：保护管道环形缓冲区的读写操作。\n- **原子操作**：管道 `head` 指针使用 `smp_store_release()` 更新，确保与 `pipe_read()` 的同步。\n\n## 依赖关系\n\n- **管道子系统**（`fs/pipe.c`）  \n  依赖管道的核心数据结构（`pipe_inode_info`、`pipe_buffer`）和操作接口（`pipe_buf()`、`pipe_full()`、`generic_pipe_buf_*`）。\n\n- **内存管理**  \n  使用 `alloc_page()`、`kmap_atomic()` 管理通知缓冲区页，`bitmap_alloc()` 管理槽位位图。\n\n- **安全模块**（LSM）  \n  通过 `security_post_notification()` 钩子集成安全策略。\n\n- **用户空间接口**  \n  与 `fs/watch_queue.c` 中的系统调用（如 `watch_queue_set_size()`）协同工作，后者负责创建监视队列并与管道关联。\n\n- **头文件依赖**  \n  `linux/watch_queue.h`（核心数据结构定义）、`linux/pipe_fs_i.h`（管道内部接口）。\n\n## 使用场景\n\n- **文件系统事件监控**  \n  如 `fsnotify` 子系统可通过监视队列向用户空间报告文件访问、修改等事件。\n\n- **密钥管理通知**  \n  内核密钥环（`KEYS`）子系统使用该机制通知密钥状态变更（如过期、撤销）。\n\n- **设备事件上报**  \n  设备驱动可利用监视队列异步上报硬件状态变化或错误事件。\n\n- **通用内核事件分发**  \n  任何需要向特权用户空间守护进程（如 `systemd`）发送结构化事件的内核子系统均可集成此机制。\n\n- **用户空间消费**  \n  应用程序通过 `open(\"/dev/watch_queue\")` 获取监视队列文件描述符，调用 `ioctl()` 设置缓冲区大小和过滤器，然后像读取普通管道一样接收通知。",
      "similarity": 0.5297272205352783,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/watch_queue.c",
          "start_line": 42,
          "end_line": 154,
          "content": [
            "static inline bool lock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_lock_bh(&wqueue->lock);",
            "\tif (unlikely(!wqueue->pipe)) {",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static inline void unlock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_unlock_bh(&wqueue->lock);",
            "}",
            "static void watch_queue_pipe_buf_release(struct pipe_inode_info *pipe,",
            "\t\t\t\t\t struct pipe_buffer *buf)",
            "{",
            "\tstruct watch_queue *wqueue = (struct watch_queue *)buf->private;",
            "\tstruct page *page;",
            "\tunsigned int bit;",
            "",
            "\t/* We need to work out which note within the page this refers to, but",
            "\t * the note might have been maximum size, so merely ANDing the offset",
            "\t * off doesn't work.  OTOH, the note must've been more than zero size.",
            "\t */",
            "\tbit = buf->offset + buf->len;",
            "\tif ((bit & (WATCH_QUEUE_NOTE_SIZE - 1)) == 0)",
            "\t\tbit -= WATCH_QUEUE_NOTE_SIZE;",
            "\tbit /= WATCH_QUEUE_NOTE_SIZE;",
            "",
            "\tpage = buf->page;",
            "\tbit += page->index;",
            "",
            "\tset_bit(bit, wqueue->notes_bitmap);",
            "\tgeneric_pipe_buf_release(pipe, buf);",
            "}",
            "static bool post_one_notification(struct watch_queue *wqueue,",
            "\t\t\t\t  struct watch_notification *n)",
            "{",
            "\tvoid *p;",
            "\tstruct pipe_inode_info *pipe = wqueue->pipe;",
            "\tstruct pipe_buffer *buf;",
            "\tstruct page *page;",
            "\tunsigned int head, tail, note, offset, len;",
            "\tbool done = false;",
            "",
            "\tspin_lock_irq(&pipe->rd_wait.lock);",
            "",
            "\thead = pipe->head;",
            "\ttail = pipe->tail;",
            "\tif (pipe_full(head, tail, pipe->ring_size))",
            "\t\tgoto lost;",
            "",
            "\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);",
            "\tif (note >= wqueue->nr_notes)",
            "\t\tgoto lost;",
            "",
            "\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];",
            "\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;",
            "\tget_page(page);",
            "\tlen = n->info & WATCH_INFO_LENGTH;",
            "\tp = kmap_atomic(page);",
            "\tmemcpy(p + offset, n, len);",
            "\tkunmap_atomic(p);",
            "",
            "\tbuf = pipe_buf(pipe, head);",
            "\tbuf->page = page;",
            "\tbuf->private = (unsigned long)wqueue;",
            "\tbuf->ops = &watch_queue_pipe_buf_ops;",
            "\tbuf->offset = offset;",
            "\tbuf->len = len;",
            "\tbuf->flags = PIPE_BUF_FLAG_WHOLE;",
            "\tsmp_store_release(&pipe->head, head + 1); /* vs pipe_read() */",
            "",
            "\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {",
            "\t\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\t\tBUG();",
            "\t}",
            "\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);",
            "\tdone = true;",
            "",
            "out:",
            "\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\tif (done)",
            "\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);",
            "\treturn done;",
            "",
            "lost:",
            "\tbuf = pipe_buf(pipe, head - 1);",
            "\tbuf->flags |= PIPE_BUF_FLAG_LOSS;",
            "\tgoto out;",
            "}",
            "static bool filter_watch_notification(const struct watch_filter *wf,",
            "\t\t\t\t      const struct watch_notification *n)",
            "{",
            "\tconst struct watch_type_filter *wt;",
            "\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;",
            "\tunsigned int st_index = n->subtype / st_bits;",
            "\tunsigned int st_bit = 1U << (n->subtype % st_bits);",
            "\tint i;",
            "",
            "\tif (!test_bit(n->type, wf->type_filter))",
            "\t\treturn false;",
            "",
            "\tfor (i = 0; i < wf->nr_filters; i++) {",
            "\t\twt = &wf->filters[i];",
            "\t\tif (n->type == wt->type &&",
            "\t\t    (wt->subtype_filter[st_index] & st_bit) &&",
            "\t\t    (n->info & wt->info_mask) == wt->info_filter)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false; /* If there is a filter, the default is to reject. */",
            "}"
          ],
          "function_name": "lock_wqueue, unlock_wqueue, watch_queue_pipe_buf_release, post_one_notification, filter_watch_notification",
          "description": "实现了watch_queue的锁操作、缓冲区释放、通知提交及过滤逻辑。lock_wqueue/unlock_wqueue用于保护队列访问，watch_queue_pipe_buf_release处理缓冲区回收并更新位图，post_one_notification将通知数据写入管道，filter_watch_notification进行类型和子类型的匹配判断。",
          "similarity": 0.507676362991333
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/watch_queue.c",
          "start_line": 602,
          "end_line": 680,
          "content": [
            "void watch_queue_clear(struct watch_queue *wqueue)",
            "{",
            "\tstruct watch_list *wlist;",
            "\tstruct watch *watch;",
            "\tbool release;",
            "",
            "\trcu_read_lock();",
            "\tspin_lock_bh(&wqueue->lock);",
            "",
            "\t/*",
            "\t * This pipe can be freed by callers like free_pipe_info().",
            "\t * Removing this reference also prevents new notifications.",
            "\t */",
            "\twqueue->pipe = NULL;",
            "",
            "\twhile (!hlist_empty(&wqueue->watches)) {",
            "\t\twatch = hlist_entry(wqueue->watches.first, struct watch, queue_node);",
            "\t\thlist_del_init_rcu(&watch->queue_node);",
            "\t\t/* We now own a ref on the watch. */",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "",
            "\t\t/* We can't do the next bit under the queue lock as we need to",
            "\t\t * get the list lock - which would cause a deadlock if someone",
            "\t\t * was removing from the opposite direction at the same time or",
            "\t\t * posting a notification.",
            "\t\t */",
            "\t\twlist = rcu_dereference(watch->watch_list);",
            "\t\tif (wlist) {",
            "\t\t\tvoid (*release_watch)(struct watch *);",
            "",
            "\t\t\tspin_lock(&wlist->lock);",
            "",
            "\t\t\trelease = !hlist_unhashed(&watch->list_node);",
            "\t\t\tif (release) {",
            "\t\t\t\thlist_del_init_rcu(&watch->list_node);",
            "\t\t\t\trcu_assign_pointer(watch->watch_list, NULL);",
            "",
            "\t\t\t\t/* We now own a second ref on the watch. */",
            "\t\t\t}",
            "",
            "\t\t\trelease_watch = wlist->release_watch;",
            "\t\t\tspin_unlock(&wlist->lock);",
            "",
            "\t\t\tif (release) {",
            "\t\t\t\tif (release_watch) {",
            "\t\t\t\t\trcu_read_unlock();",
            "\t\t\t\t\t/* This might need to call dput(), so",
            "\t\t\t\t\t * we have to drop all the locks.",
            "\t\t\t\t\t */",
            "\t\t\t\t\t(*release_watch)(watch);",
            "\t\t\t\t\trcu_read_lock();",
            "\t\t\t\t}",
            "\t\t\t\tput_watch(watch);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tput_watch(watch);",
            "\t\tspin_lock_bh(&wqueue->lock);",
            "\t}",
            "",
            "\tspin_unlock_bh(&wqueue->lock);",
            "\trcu_read_unlock();",
            "}",
            "int watch_queue_init(struct pipe_inode_info *pipe)",
            "{",
            "\tstruct watch_queue *wqueue;",
            "",
            "\twqueue = kzalloc(sizeof(*wqueue), GFP_KERNEL);",
            "\tif (!wqueue)",
            "\t\treturn -ENOMEM;",
            "",
            "\twqueue->pipe = pipe;",
            "\tkref_init(&wqueue->usage);",
            "\tspin_lock_init(&wqueue->lock);",
            "\tINIT_HLIST_HEAD(&wqueue->watches);",
            "",
            "\tpipe->watch_queue = wqueue;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "watch_queue_clear, watch_queue_init",
          "description": "该代码实现了监视队列的初始化与清理功能。  \n`watch_queue_clear`通过RCU和自旋锁机制安全地移除所有监视项并释放资源，`watch_queue_init`初始化监视队列结构并绑定至管道对象。  \n上下文不完整：`release_watch`等关键函数依赖外部定义，部分RCU回调逻辑未完全展示。",
          "similarity": 0.4973997175693512
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/watch_queue.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Watch queue and general notification mechanism, built on pipes",
            " *",
            " * Copyright (C) 2020 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " *",
            " * See Documentation/core-api/watch_queue.rst",
            " */",
            "",
            "#define pr_fmt(fmt) \"watchq: \" fmt",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/pipe_fs_i.h>",
            "",
            "MODULE_DESCRIPTION(\"Watch queue\");",
            "MODULE_AUTHOR(\"Red Hat, Inc.\");",
            "",
            "#define WATCH_QUEUE_NOTE_SIZE 128",
            "#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)",
            "",
            "/*",
            " * This must be called under the RCU read-lock, which makes",
            " * sure that the wqueue still exists. It can then take the lock,",
            " * and check that the wqueue hasn't been destroyed, which in",
            " * turn makes sure that the notification pipe still exists.",
            " */"
          ],
          "function_name": null,
          "description": "定义了watch_queue模块的头部信息，包含常量WATCH_QUEUE_NOTE_SIZE和NOTES_PER_PAGE，声明模块许可证及作者信息，并引入相关内核头文件，为后续实现提供基础框架。",
          "similarity": 0.4685291647911072
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/watch_queue.c",
          "start_line": 315,
          "end_line": 422,
          "content": [
            "long watch_queue_set_filter(struct pipe_inode_info *pipe,",
            "\t\t\t    struct watch_notification_filter __user *_filter)",
            "{",
            "\tstruct watch_notification_type_filter *tf;",
            "\tstruct watch_notification_filter filter;",
            "\tstruct watch_type_filter *q;",
            "\tstruct watch_filter *wfilter;",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tint ret, nr_filter = 0, i;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (!_filter) {",
            "\t\t/* Remove the old filter */",
            "\t\twfilter = NULL;",
            "\t\tgoto set;",
            "\t}",
            "",
            "\t/* Grab the user's filter specification */",
            "\tif (copy_from_user(&filter, _filter, sizeof(filter)) != 0)",
            "\t\treturn -EFAULT;",
            "\tif (filter.nr_filters == 0 ||",
            "\t    filter.nr_filters > 16 ||",
            "\t    filter.__reserved != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\ttf = memdup_array_user(_filter->filters, filter.nr_filters, sizeof(*tf));",
            "\tif (IS_ERR(tf))",
            "\t\treturn PTR_ERR(tf);",
            "",
            "\tret = -EINVAL;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif ((tf[i].info_filter & ~tf[i].info_mask) ||",
            "\t\t    tf[i].info_mask & WATCH_INFO_LENGTH)",
            "\t\t\tgoto err_filter;",
            "\t\t/* Ignore any unknown types */",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "\t\tnr_filter++;",
            "\t}",
            "",
            "\t/* Now we need to build the internal filter from only the relevant",
            "\t * user-specified filters.",
            "\t */",
            "\tret = -ENOMEM;",
            "\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);",
            "\tif (!wfilter)",
            "\t\tgoto err_filter;",
            "\twfilter->nr_filters = nr_filter;",
            "",
            "\tq = wfilter->filters;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "",
            "\t\tq->type\t\t\t= tf[i].type;",
            "\t\tq->info_filter\t\t= tf[i].info_filter;",
            "\t\tq->info_mask\t\t= tf[i].info_mask;",
            "\t\tq->subtype_filter[0]\t= tf[i].subtype_filter[0];",
            "\t\t__set_bit(q->type, wfilter->type_filter);",
            "\t\tq++;",
            "\t}",
            "",
            "\tkfree(tf);",
            "set:",
            "\tpipe_lock(pipe);",
            "\twfilter = rcu_replace_pointer(wqueue->filter, wfilter,",
            "\t\t\t\t      lockdep_is_held(&pipe->mutex));",
            "\tpipe_unlock(pipe);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\treturn 0;",
            "",
            "err_filter:",
            "\tkfree(tf);",
            "\treturn ret;",
            "}",
            "static void __put_watch_queue(struct kref *kref)",
            "{",
            "\tstruct watch_queue *wqueue =",
            "\t\tcontainer_of(kref, struct watch_queue, usage);",
            "\tstruct watch_filter *wfilter;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < wqueue->nr_pages; i++)",
            "\t\t__free_page(wqueue->notes[i]);",
            "\tkfree(wqueue->notes);",
            "\tbitmap_free(wqueue->notes_bitmap);",
            "",
            "\twfilter = rcu_access_pointer(wqueue->filter);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\tkfree_rcu(wqueue, rcu);",
            "}",
            "void put_watch_queue(struct watch_queue *wqueue)",
            "{",
            "\tkref_put(&wqueue->usage, __put_watch_queue);",
            "}",
            "static void free_watch(struct rcu_head *rcu)",
            "{",
            "\tstruct watch *watch = container_of(rcu, struct watch, rcu);",
            "",
            "\tput_watch_queue(rcu_access_pointer(watch->queue));",
            "\tatomic_dec(&watch->cred->user->nr_watches);",
            "\tput_cred(watch->cred);",
            "\tkfree(watch);",
            "}"
          ],
          "function_name": "watch_queue_set_filter, __put_watch_queue, put_watch_queue, free_watch",
          "description": "watch_queue_set_filter设置过滤规则并转换为内核内部结构，__put_watch_queue释放watch_queue相关资源包括页面、位图和过滤器，put_watch_queue通过引用计数管理watch_queue生命周期，free_watch执行RCU回调完成最终释放。",
          "similarity": 0.4525350332260132
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watch_queue.c",
          "start_line": 193,
          "end_line": 304,
          "content": [
            "void __post_watch_notification(struct watch_list *wlist,",
            "\t\t\t       struct watch_notification *n,",
            "\t\t\t       const struct cred *cred,",
            "\t\t\t       u64 id)",
            "{",
            "\tconst struct watch_filter *wf;",
            "\tstruct watch_queue *wqueue;",
            "\tstruct watch *watch;",
            "",
            "\tif (((n->info & WATCH_INFO_LENGTH) >> WATCH_INFO_LENGTH__SHIFT) == 0) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\trcu_read_lock();",
            "",
            "\thlist_for_each_entry_rcu(watch, &wlist->watchers, list_node) {",
            "\t\tif (watch->id != id)",
            "\t\t\tcontinue;",
            "\t\tn->info &= ~WATCH_INFO_ID;",
            "\t\tn->info |= watch->info_id;",
            "",
            "\t\twqueue = rcu_dereference(watch->queue);",
            "\t\twf = rcu_dereference(wqueue->filter);",
            "\t\tif (wf && !filter_watch_notification(wf, n))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (security_post_notification(watch->cred, cred, n) < 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (lock_wqueue(wqueue)) {",
            "\t\t\tpost_one_notification(wqueue, n);",
            "\t\t\tunlock_wqueue(wqueue);",
            "\t\t}",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "}",
            "long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)",
            "{",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tstruct page **pages;",
            "\tunsigned long *bitmap;",
            "\tunsigned long user_bufs;",
            "\tint ret, i, nr_pages;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "\tif (wqueue->notes)",
            "\t\treturn -EBUSY;",
            "",
            "\tif (nr_notes < 1 ||",
            "\t    nr_notes > 512) /* TODO: choose a better hard limit */",
            "\t\treturn -EINVAL;",
            "",
            "\tnr_pages = (nr_notes + WATCH_QUEUE_NOTES_PER_PAGE - 1);",
            "\tnr_pages /= WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tuser_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_pages);",
            "",
            "\tif (nr_pages > pipe->max_usage &&",
            "\t    (too_many_pipe_buffers_hard(user_bufs) ||",
            "\t     too_many_pipe_buffers_soft(user_bufs)) &&",
            "\t    pipe_is_unprivileged_user()) {",
            "\t\tret = -EPERM;",
            "\t\tgoto error;",
            "\t}",
            "",
            "\tnr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "",
            "\t/*",
            "\t * pipe_resize_ring() does not update nr_accounted for watch_queue",
            "\t * pipes, because the above vastly overprovisions. Set nr_accounted on",
            "\t * and max_usage this pipe to the number that was actually charged to",
            "\t * the user above via account_pipe_buffers.",
            "\t */",
            "\tpipe->max_usage = nr_pages;",
            "\tpipe->nr_accounted = nr_pages;",
            "",
            "\tret = -ENOMEM;",
            "\tpages = kcalloc(sizeof(struct page *), nr_pages, GFP_KERNEL);",
            "\tif (!pages)",
            "\t\tgoto error;",
            "",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tpages[i] = alloc_page(GFP_KERNEL);",
            "\t\tif (!pages[i])",
            "\t\t\tgoto error_p;",
            "\t\tpages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\t}",
            "",
            "\tbitmap = bitmap_alloc(nr_notes, GFP_KERNEL);",
            "\tif (!bitmap)",
            "\t\tgoto error_p;",
            "",
            "\tbitmap_fill(bitmap, nr_notes);",
            "\twqueue->notes = pages;",
            "\twqueue->notes_bitmap = bitmap;",
            "\twqueue->nr_pages = nr_pages;",
            "\twqueue->nr_notes = nr_notes;",
            "\treturn 0;",
            "",
            "error_p:",
            "\twhile (--i >= 0)",
            "\t\t__free_page(pages[i]);",
            "\tkfree(pages);",
            "error:",
            "\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->nr_accounted);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__post_watch_notification, watch_queue_set_size",
          "description": "__post_watch_notification遍历watch列表并应用过滤器后提交通知，watch_queue_set_size动态调整管道容量，通过计算所需页数和位图分配，限制最大容量为512个笔记，支持扩展性需求。",
          "similarity": 0.4424293637275696
        }
      ]
    },
    {
      "source_file": "mm/memory-tiers.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:41:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memory-tiers.c`\n\n---\n\n# memory-tiers.c 技术文档\n\n## 1. 文件概述\n\n`memory-tiers.c` 是 Linux 内核中实现 **内存层级（Memory Tiering）** 功能的核心模块。该文件负责根据抽象距离（abstract distance, adistance）对 NUMA 节点进行分层管理，支持将不同性能特性的内存（如 DRAM、PMEM、HBM 等）组织成层级结构，并为页面迁移（demotion/promotion）和 NUMA 平衡提供基础支持。通过 sysfs 暴露内存层级信息，便于用户空间监控和策略配置。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct memory_tier`  \n  表示一个内存层级，包含：\n  - `adistance_start`：该层级的起始抽象距离（按 `MEMTIER_CHUNK_SIZE` 对齐）\n  - `memory_types`：属于该层级的所有内存设备类型（`memory_dev_type`）链表\n  - `lower_tier_mask`：所有更低层级（更高延迟/更低性能）节点的位掩码\n  - `dev`：对应的 sysfs 设备对象\n\n- `struct demotion_nodes`  \n  用于记录每个节点在页面降级（demotion）时的首选目标节点集合。\n\n- `struct node_memory_type_map`  \n  每个 NUMA 节点到其内存设备类型的映射及引用计数。\n\n- `node_demotion[]`（仅 `CONFIG_MIGRATION`）  \n  全局数组，存储每个节点的降级目标偏好。\n\n### 主要函数与接口\n\n- `find_create_memory_tier()`  \n  根据给定内存设备类型的抽象距离，查找或创建对应的 `memory_tier` 实例，并将其加入全局层级链表（按 `adistance_start` 升序排列）。\n\n- `__node_get_memory_tier()` / `node_is_toptier()`  \n  查询指定 NUMA 节点所属的内存层级；`node_is_toptier()` 判断节点是否属于顶层（最高性能）内存层级。\n\n- `node_get_allowed_targets()`  \n  获取指定节点在页面迁移时允许的目标节点集合（即其所在层级之下的所有节点）。\n\n- `next_demotion_node()`（未完整展示）  \n  返回从给定节点出发，在降级路径中的下一个目标节点 ID。\n\n- `folio_use_access_time()`（仅 `CONFIG_NUMA_BALANCING`）  \n  在启用内存层级模式的 NUMA 平衡中，判断是否将 folio 的 `_last_cpupid` 字段复用为访问时间戳（仅适用于非顶层内存节点）。\n\n- `nodelist_show()`  \n  sysfs 属性回调，输出当前内存层级包含的所有 NUMA 节点列表。\n\n## 3. 关键实现\n\n### 内存层级构建逻辑\n- 所有内存设备类型（`memory_dev_type`）通过其 `adistance` 值被归入特定层级。\n- 层级按 `adistance_start = round_down(adistance, MEMTIER_CHUNK_SIZE)` 分组，确保同一层级内设备具有相近的性能特征。\n- 全局链表 `memory_tiers` 维护层级顺序（从低 `adistance` 到高），反映从高性能到低性能的层级结构。\n\n### 层级间依赖关系\n- 每个 `memory_tier` 的 `lower_tier_mask` 记录了所有比它性能更低（`adistance` 更高）的层级所包含的节点集合，用于快速确定迁移目标范围。\n- 顶层层级由全局变量 `top_tier_adistance` 定义，通常对应最低 `adistance` 值的层级（如 CPU 本地 DRAM）。\n\n### RCU 与锁机制\n- 使用 `memory_tier_lock`（互斥锁）保护全局层级结构和设备注册。\n- 节点到层级的映射（`pgdat->memtier`）通过 RCU 机制更新和读取，确保在无锁路径（如页面访问）中的高效性。\n- `synchronize_rcu()` 用于在释放 `memory_tier` 前确保无并发 RCU 读者。\n\n### sysfs 集成\n- 每个 `memory_tier` 注册为 `memory_tiering` 子系统下的设备（`memory_tierX`）。\n- 通过 `nodelist` 属性暴露该层级包含的 NUMA 节点，格式为位图字符串（如 `\"0-3,8-11\"`）。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/memory.h>`：NUMA 节点和内存管理基础\n  - `<linux/memory-tiers.h>`：内存层级公共接口定义\n  - `\"internal.h\"`：内部辅助函数\n- **可选依赖**：\n  - `CONFIG_NUMA_BALANCING`：提供 `folio_use_access_time()`，支持基于访问时间的页面迁移\n  - `CONFIG_MIGRATION`：提供 `node_demotion` 结构和 `next_demotion_node()` 等迁移相关功能\n- **子系统交互**：\n  - 与内存热插拔（`memory_hotplug`）协同，动态更新层级结构\n  - 为自动 NUMA 平衡（AutoNUMA）和页面迁移框架提供层级拓扑信息\n\n## 5. 使用场景\n\n- **异构内存系统管理**：在包含 DRAM、PMEM、CXL 内存等多类型内存的系统中，自动构建性能层级视图。\n- **智能页面迁移**：作为 `migrate_pages()` 和后台 demotion daemon 的决策依据，将冷页从高性能内存迁移到大容量低速内存。\n- **NUMA 负载均衡优化**：在 `CONFIG_NUMA_BALANCING` 启用时，结合访问时间戳和层级信息，优先将热页保留在顶层内存。\n- **用户空间监控与调优**：通过 `/sys/devices/memory_tiering/memory_tier*/nodelist` 查看各层级节点分布，辅助制定应用部署策略。",
      "similarity": 0.5237172842025757,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/memory-tiers.c",
          "start_line": 59,
          "end_line": 170,
          "content": [
            "bool folio_use_access_time(struct folio *folio)",
            "{",
            "\treturn (sysctl_numa_balancing_mode & NUMA_BALANCING_MEMORY_TIERING) &&",
            "\t       !node_is_toptier(folio_nid(folio));",
            "}",
            "static __always_inline nodemask_t get_memtier_nodemask(struct memory_tier *memtier)",
            "{",
            "\tnodemask_t nodes = NODE_MASK_NONE;",
            "\tstruct memory_dev_type *memtype;",
            "",
            "\tlist_for_each_entry(memtype, &memtier->memory_types, tier_sibling)",
            "\t\tnodes_or(nodes, nodes, memtype->nodes);",
            "",
            "\treturn nodes;",
            "}",
            "static void memory_tier_device_release(struct device *dev)",
            "{",
            "\tstruct memory_tier *tier = to_memory_tier(dev);",
            "\t/*",
            "\t * synchronize_rcu in clear_node_memory_tier makes sure",
            "\t * we don't have rcu access to this memory tier.",
            "\t */",
            "\tkfree(tier);",
            "}",
            "static ssize_t nodelist_show(struct device *dev,",
            "\t\t\t     struct device_attribute *attr, char *buf)",
            "{",
            "\tint ret;",
            "\tnodemask_t nmask;",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\tnmask = get_memtier_nodemask(to_memory_tier(dev));",
            "\tret = sysfs_emit(buf, \"%*pbl\\n\", nodemask_pr_args(&nmask));",
            "\tmutex_unlock(&memory_tier_lock);",
            "\treturn ret;",
            "}",
            "bool node_is_toptier(int node)",
            "{",
            "\tbool toptier;",
            "\tpg_data_t *pgdat;",
            "\tstruct memory_tier *memtier;",
            "",
            "\tpgdat = NODE_DATA(node);",
            "\tif (!pgdat)",
            "\t\treturn false;",
            "",
            "\trcu_read_lock();",
            "\tmemtier = rcu_dereference(pgdat->memtier);",
            "\tif (!memtier) {",
            "\t\ttoptier = true;",
            "\t\tgoto out;",
            "\t}",
            "\tif (memtier->adistance_start <= top_tier_adistance)",
            "\t\ttoptier = true;",
            "\telse",
            "\t\ttoptier = false;",
            "out:",
            "\trcu_read_unlock();",
            "\treturn toptier;",
            "}",
            "void node_get_allowed_targets(pg_data_t *pgdat, nodemask_t *targets)",
            "{",
            "\tstruct memory_tier *memtier;",
            "",
            "\t/*",
            "\t * pg_data_t.memtier updates includes a synchronize_rcu()",
            "\t * which ensures that we either find NULL or a valid memtier",
            "\t * in NODE_DATA. protect the access via rcu_read_lock();",
            "\t */",
            "\trcu_read_lock();",
            "\tmemtier = rcu_dereference(pgdat->memtier);",
            "\tif (memtier)",
            "\t\t*targets = memtier->lower_tier_mask;",
            "\telse",
            "\t\t*targets = NODE_MASK_NONE;",
            "\trcu_read_unlock();",
            "}",
            "int next_demotion_node(int node)",
            "{",
            "\tstruct demotion_nodes *nd;",
            "\tint target;",
            "",
            "\tif (!node_demotion)",
            "\t\treturn NUMA_NO_NODE;",
            "",
            "\tnd = &node_demotion[node];",
            "",
            "\t/*",
            "\t * node_demotion[] is updated without excluding this",
            "\t * function from running.",
            "\t *",
            "\t * Make sure to use RCU over entire code blocks if",
            "\t * node_demotion[] reads need to be consistent.",
            "\t */",
            "\trcu_read_lock();",
            "\t/*",
            "\t * If there are multiple target nodes, just select one",
            "\t * target node randomly.",
            "\t *",
            "\t * In addition, we can also use round-robin to select",
            "\t * target node, but we should introduce another variable",
            "\t * for node_demotion[] to record last selected target node,",
            "\t * that may cause cache ping-pong due to the changing of",
            "\t * last target node. Or introducing per-cpu data to avoid",
            "\t * caching issue, which seems more complicated. So selecting",
            "\t * target node randomly seems better until now.",
            "\t */",
            "\ttarget = node_random(&nd->preferred);",
            "\trcu_read_unlock();",
            "",
            "\treturn target;",
            "}"
          ],
          "function_name": "folio_use_access_time, get_memtier_nodemask, memory_tier_device_release, nodelist_show, node_is_toptier, node_get_allowed_targets, next_demotion_node",
          "description": "实现内存分层核心功能，包括判断页是否使用访问时间、获取内存分层节点掩码、设备释放、节点列表展示、判断是否为顶层节点、获取允许目标节点以及选择下一个降级节点的算法实现。",
          "similarity": 0.5139017701148987
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memory-tiers.c",
          "start_line": 1,
          "end_line": 58,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/memory.h>",
            "#include <linux/memory-tiers.h>",
            "#include <linux/notifier.h>",
            "#include <linux/sched/sysctl.h>",
            "",
            "#include \"internal.h\"",
            "",
            "struct memory_tier {",
            "\t/* hierarchy of memory tiers */",
            "\tstruct list_head list;",
            "\t/* list of all memory types part of this tier */",
            "\tstruct list_head memory_types;",
            "\t/*",
            "\t * start value of abstract distance. memory tier maps",
            "\t * an abstract distance  range,",
            "\t * adistance_start .. adistance_start + MEMTIER_CHUNK_SIZE",
            "\t */",
            "\tint adistance_start;",
            "\tstruct device dev;",
            "\t/* All the nodes that are part of all the lower memory tiers. */",
            "\tnodemask_t lower_tier_mask;",
            "};",
            "",
            "struct demotion_nodes {",
            "\tnodemask_t preferred;",
            "};",
            "",
            "struct node_memory_type_map {",
            "\tstruct memory_dev_type *memtype;",
            "\tint map_count;",
            "};",
            "",
            "static DEFINE_MUTEX(memory_tier_lock);",
            "static LIST_HEAD(memory_tiers);",
            "static struct node_memory_type_map node_memory_types[MAX_NUMNODES];",
            "struct memory_dev_type *default_dram_type;",
            "",
            "static struct bus_type memory_tier_subsys = {",
            "\t.name = \"memory_tiering\",",
            "\t.dev_name = \"memory_tier\",",
            "};",
            "",
            "#ifdef CONFIG_NUMA_BALANCING",
            "/**",
            " * folio_use_access_time - check if a folio reuses cpupid for page access time",
            " * @folio: folio to check",
            " *",
            " * folio's _last_cpupid field is repurposed by memory tiering. In memory",
            " * tiering mode, cpupid of slow memory folio (not toptier memory) is used to",
            " * record page access time.",
            " *",
            " * Return: the folio _last_cpupid is used to record page access time",
            " */"
          ],
          "function_name": null,
          "description": "定义memory_tier结构体及辅助数据结构，用于管理内存分层体系。声明全局锁和链表头，注册内存分层子系统，并定义默认DRAM类型指针。包含用于内存分层的抽象距离相关内联函数原型。",
          "similarity": 0.5105596780776978
        },
        {
          "chunk_id": 4,
          "file_path": "mm/memory-tiers.c",
          "start_line": 688,
          "end_line": 801,
          "content": [
            "int mt_perf_to_adistance(struct access_coordinate *perf, int *adist)",
            "{",
            "\tif (default_dram_perf_error)",
            "\t\treturn -EIO;",
            "",
            "\tif (default_dram_perf_ref_nid == NUMA_NO_NODE)",
            "\t\treturn -ENOENT;",
            "",
            "\tif (perf->read_latency + perf->write_latency == 0 ||",
            "\t    perf->read_bandwidth + perf->write_bandwidth == 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\t/*",
            "\t * The abstract distance of a memory node is in direct proportion to",
            "\t * its memory latency (read + write) and inversely proportional to its",
            "\t * memory bandwidth (read + write).  The abstract distance, memory",
            "\t * latency, and memory bandwidth of the default DRAM nodes are used as",
            "\t * the base.",
            "\t */",
            "\t*adist = MEMTIER_ADISTANCE_DRAM *",
            "\t\t(perf->read_latency + perf->write_latency) /",
            "\t\t(default_dram_perf.read_latency + default_dram_perf.write_latency) *",
            "\t\t(default_dram_perf.read_bandwidth + default_dram_perf.write_bandwidth) /",
            "\t\t(perf->read_bandwidth + perf->write_bandwidth);",
            "\tmutex_unlock(&memory_tier_lock);",
            "",
            "\treturn 0;",
            "}",
            "int register_mt_adistance_algorithm(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&mt_adistance_algorithms, nb);",
            "}",
            "int unregister_mt_adistance_algorithm(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&mt_adistance_algorithms, nb);",
            "}",
            "int mt_calc_adistance(int node, int *adist)",
            "{",
            "\treturn blocking_notifier_call_chain(&mt_adistance_algorithms, node, adist);",
            "}",
            "static int __meminit memtier_hotplug_callback(struct notifier_block *self,",
            "\t\t\t\t\t      unsigned long action, void *_arg)",
            "{",
            "\tstruct memory_tier *memtier;",
            "\tstruct memory_notify *arg = _arg;",
            "",
            "\t/*",
            "\t * Only update the node migration order when a node is",
            "\t * changing status, like online->offline.",
            "\t */",
            "\tif (arg->status_change_nid < 0)",
            "\t\treturn notifier_from_errno(0);",
            "",
            "\tswitch (action) {",
            "\tcase MEM_OFFLINE:",
            "\t\tmutex_lock(&memory_tier_lock);",
            "\t\tif (clear_node_memory_tier(arg->status_change_nid))",
            "\t\t\testablish_demotion_targets();",
            "\t\tmutex_unlock(&memory_tier_lock);",
            "\t\tbreak;",
            "\tcase MEM_ONLINE:",
            "\t\tmutex_lock(&memory_tier_lock);",
            "\t\tmemtier = set_node_memory_tier(arg->status_change_nid);",
            "\t\tif (!IS_ERR(memtier))",
            "\t\t\testablish_demotion_targets();",
            "\t\tmutex_unlock(&memory_tier_lock);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn notifier_from_errno(0);",
            "}",
            "static int __init memory_tier_init(void)",
            "{",
            "\tint ret, node;",
            "\tstruct memory_tier *memtier;",
            "",
            "\tret = subsys_virtual_register(&memory_tier_subsys, NULL);",
            "\tif (ret)",
            "\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);",
            "",
            "#ifdef CONFIG_MIGRATION",
            "\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),",
            "\t\t\t\tGFP_KERNEL);",
            "\tWARN_ON(!node_demotion);",
            "#endif",
            "\tmutex_lock(&memory_tier_lock);",
            "\t/*",
            "\t * For now we can have 4 faster memory tiers with smaller adistance",
            "\t * than default DRAM tier.",
            "\t */",
            "\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);",
            "\tif (IS_ERR(default_dram_type))",
            "\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);",
            "",
            "\t/*",
            "\t * Look at all the existing N_MEMORY nodes and add them to",
            "\t * default memory tier or to a tier if we already have memory",
            "\t * types assigned.",
            "\t */",
            "\tfor_each_node_state(node, N_MEMORY) {",
            "\t\tmemtier = set_node_memory_tier(node);",
            "\t\tif (IS_ERR(memtier))",
            "\t\t\t/*",
            "\t\t\t * Continue with memtiers we are able to setup",
            "\t\t\t */",
            "\t\t\tbreak;",
            "\t}",
            "\testablish_demotion_targets();",
            "\tmutex_unlock(&memory_tier_lock);",
            "",
            "\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "mt_perf_to_adistance, register_mt_adistance_algorithm, unregister_mt_adistance_algorithm, mt_calc_adistance, memtier_hotplug_callback, memory_tier_init",
          "description": "提供抽象距离计算接口和内存分层热插拔回调。初始化内存分层子系统，分配默认DRAM类型，遍历所有节点建立初始内存分层结构，并注册内存状态变化通知处理函数。",
          "similarity": 0.5083824396133423
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memory-tiers.c",
          "start_line": 481,
          "end_line": 635,
          "content": [
            "static inline void establish_demotion_targets(void) {}",
            "static inline void __init_node_memory_type(int node, struct memory_dev_type *memtype)",
            "{",
            "\tif (!node_memory_types[node].memtype)",
            "\t\tnode_memory_types[node].memtype = memtype;",
            "\t/*",
            "\t * for each device getting added in the same NUMA node",
            "\t * with this specific memtype, bump the map count. We",
            "\t * Only take memtype device reference once, so that",
            "\t * changing a node memtype can be done by droping the",
            "\t * only reference count taken here.",
            "\t */",
            "",
            "\tif (node_memory_types[node].memtype == memtype) {",
            "\t\tif (!node_memory_types[node].map_count++)",
            "\t\t\tkref_get(&memtype->kref);",
            "\t}",
            "}",
            "static void destroy_memory_tier(struct memory_tier *memtier)",
            "{",
            "\tlist_del(&memtier->list);",
            "\tdevice_unregister(&memtier->dev);",
            "}",
            "static bool clear_node_memory_tier(int node)",
            "{",
            "\tbool cleared = false;",
            "\tpg_data_t *pgdat;",
            "\tstruct memory_tier *memtier;",
            "",
            "\tpgdat = NODE_DATA(node);",
            "\tif (!pgdat)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Make sure that anybody looking at NODE_DATA who finds",
            "\t * a valid memtier finds memory_dev_types with nodes still",
            "\t * linked to the memtier. We achieve this by waiting for",
            "\t * rcu read section to finish using synchronize_rcu.",
            "\t * This also enables us to free the destroyed memory tier",
            "\t * with kfree instead of kfree_rcu",
            "\t */",
            "\tmemtier = __node_get_memory_tier(node);",
            "\tif (memtier) {",
            "\t\tstruct memory_dev_type *memtype;",
            "",
            "\t\trcu_assign_pointer(pgdat->memtier, NULL);",
            "\t\tsynchronize_rcu();",
            "\t\tmemtype = node_memory_types[node].memtype;",
            "\t\tnode_clear(node, memtype->nodes);",
            "\t\tif (nodes_empty(memtype->nodes)) {",
            "\t\t\tlist_del_init(&memtype->tier_sibling);",
            "\t\t\tif (list_empty(&memtier->memory_types))",
            "\t\t\t\tdestroy_memory_tier(memtier);",
            "\t\t}",
            "\t\tcleared = true;",
            "\t}",
            "\treturn cleared;",
            "}",
            "static void release_memtype(struct kref *kref)",
            "{",
            "\tstruct memory_dev_type *memtype;",
            "",
            "\tmemtype = container_of(kref, struct memory_dev_type, kref);",
            "\tkfree(memtype);",
            "}",
            "void put_memory_type(struct memory_dev_type *memtype)",
            "{",
            "\tkref_put(&memtype->kref, release_memtype);",
            "}",
            "void init_node_memory_type(int node, struct memory_dev_type *memtype)",
            "{",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\t__init_node_memory_type(node, memtype);",
            "\tmutex_unlock(&memory_tier_lock);",
            "}",
            "void clear_node_memory_type(int node, struct memory_dev_type *memtype)",
            "{",
            "\tmutex_lock(&memory_tier_lock);",
            "\tif (node_memory_types[node].memtype == memtype || !memtype)",
            "\t\tnode_memory_types[node].map_count--;",
            "\t/*",
            "\t * If we umapped all the attached devices to this node,",
            "\t * clear the node memory type.",
            "\t */",
            "\tif (!node_memory_types[node].map_count) {",
            "\t\tmemtype = node_memory_types[node].memtype;",
            "\t\tnode_memory_types[node].memtype = NULL;",
            "\t\tput_memory_type(memtype);",
            "\t}",
            "\tmutex_unlock(&memory_tier_lock);",
            "}",
            "static void dump_hmem_attrs(struct access_coordinate *coord, const char *prefix)",
            "{",
            "\tpr_info(",
            "\"%sread_latency: %u, write_latency: %u, read_bandwidth: %u, write_bandwidth: %u\\n\",",
            "\t\tprefix, coord->read_latency, coord->write_latency,",
            "\t\tcoord->read_bandwidth, coord->write_bandwidth);",
            "}",
            "int mt_set_default_dram_perf(int nid, struct access_coordinate *perf,",
            "\t\t\t     const char *source)",
            "{",
            "\tint rc = 0;",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\tif (default_dram_perf_error) {",
            "\t\trc = -EIO;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (perf->read_latency + perf->write_latency == 0 ||",
            "\t    perf->read_bandwidth + perf->write_bandwidth == 0) {",
            "\t\trc = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (default_dram_perf_ref_nid == NUMA_NO_NODE) {",
            "\t\tdefault_dram_perf = *perf;",
            "\t\tdefault_dram_perf_ref_nid = nid;",
            "\t\tdefault_dram_perf_ref_source = kstrdup(source, GFP_KERNEL);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * The performance of all default DRAM nodes is expected to be",
            "\t * same (that is, the variation is less than 10%).  And it",
            "\t * will be used as base to calculate the abstract distance of",
            "\t * other memory nodes.",
            "\t */",
            "\tif (abs(perf->read_latency - default_dram_perf.read_latency) * 10 >",
            "\t    default_dram_perf.read_latency ||",
            "\t    abs(perf->write_latency - default_dram_perf.write_latency) * 10 >",
            "\t    default_dram_perf.write_latency ||",
            "\t    abs(perf->read_bandwidth - default_dram_perf.read_bandwidth) * 10 >",
            "\t    default_dram_perf.read_bandwidth ||",
            "\t    abs(perf->write_bandwidth - default_dram_perf.write_bandwidth) * 10 >",
            "\t    default_dram_perf.write_bandwidth) {",
            "\t\tpr_info(",
            "\"memory-tiers: the performance of DRAM node %d mismatches that of the reference\\n\"",
            "\"DRAM node %d.\\n\", nid, default_dram_perf_ref_nid);",
            "\t\tpr_info(\"  performance of reference DRAM node %d:\\n\",",
            "\t\t\tdefault_dram_perf_ref_nid);",
            "\t\tdump_hmem_attrs(&default_dram_perf, \"    \");",
            "\t\tpr_info(\"  performance of DRAM node %d:\\n\", nid);",
            "\t\tdump_hmem_attrs(perf, \"    \");",
            "\t\tpr_info(",
            "\"  disable default DRAM node performance based abstract distance algorithm.\\n\");",
            "\t\tdefault_dram_perf_error = true;",
            "\t\trc = -EINVAL;",
            "\t}",
            "",
            "out:",
            "\tmutex_unlock(&memory_tier_lock);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "establish_demotion_targets, __init_node_memory_type, destroy_memory_tier, clear_node_memory_tier, release_memtype, put_memory_type, init_node_memory_type, clear_node_memory_type, dump_hmem_attrs, mt_set_default_dram_perf",
          "description": "实现内存类型管理系统，包含初始化/清除节点内存类型、引用计数管理、性能属性打印、默认DRAM性能设置等功能。通过kref机制跟踪内存类型引用，确保内存分层结构的正确释放。",
          "similarity": 0.467419296503067
        },
        {
          "chunk_id": 2,
          "file_path": "mm/memory-tiers.c",
          "start_line": 357,
          "end_line": 472,
          "content": [
            "static void disable_all_demotion_targets(void)",
            "{",
            "\tstruct memory_tier *memtier;",
            "\tint node;",
            "",
            "\tfor_each_node_state(node, N_MEMORY) {",
            "\t\tnode_demotion[node].preferred = NODE_MASK_NONE;",
            "\t\t/*",
            "\t\t * We are holding memory_tier_lock, it is safe",
            "\t\t * to access pgda->memtier.",
            "\t\t */",
            "\t\tmemtier = __node_get_memory_tier(node);",
            "\t\tif (memtier)",
            "\t\t\tmemtier->lower_tier_mask = NODE_MASK_NONE;",
            "\t}",
            "\t/*",
            "\t * Ensure that the \"disable\" is visible across the system.",
            "\t * Readers will see either a combination of before+disable",
            "\t * state or disable+after.  They will never see before and",
            "\t * after state together.",
            "\t */",
            "\tsynchronize_rcu();",
            "}",
            "static void establish_demotion_targets(void)",
            "{",
            "\tstruct memory_tier *memtier;",
            "\tstruct demotion_nodes *nd;",
            "\tint target = NUMA_NO_NODE, node;",
            "\tint distance, best_distance;",
            "\tnodemask_t tier_nodes, lower_tier;",
            "",
            "\tlockdep_assert_held_once(&memory_tier_lock);",
            "",
            "\tif (!node_demotion)",
            "\t\treturn;",
            "",
            "\tdisable_all_demotion_targets();",
            "",
            "\tfor_each_node_state(node, N_MEMORY) {",
            "\t\tbest_distance = -1;",
            "\t\tnd = &node_demotion[node];",
            "",
            "\t\tmemtier = __node_get_memory_tier(node);",
            "\t\tif (!memtier || list_is_last(&memtier->list, &memory_tiers))",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * Get the lower memtier to find the  demotion node list.",
            "\t\t */",
            "\t\tmemtier = list_next_entry(memtier, list);",
            "\t\ttier_nodes = get_memtier_nodemask(memtier);",
            "\t\t/*",
            "\t\t * find_next_best_node, use 'used' nodemask as a skip list.",
            "\t\t * Add all memory nodes except the selected memory tier",
            "\t\t * nodelist to skip list so that we find the best node from the",
            "\t\t * memtier nodelist.",
            "\t\t */",
            "\t\tnodes_andnot(tier_nodes, node_states[N_MEMORY], tier_nodes);",
            "",
            "\t\t/*",
            "\t\t * Find all the nodes in the memory tier node list of same best distance.",
            "\t\t * add them to the preferred mask. We randomly select between nodes",
            "\t\t * in the preferred mask when allocating pages during demotion.",
            "\t\t */",
            "\t\tdo {",
            "\t\t\ttarget = find_next_best_node(node, &tier_nodes);",
            "\t\t\tif (target == NUMA_NO_NODE)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\tdistance = node_distance(node, target);",
            "\t\t\tif (distance == best_distance || best_distance == -1) {",
            "\t\t\t\tbest_distance = distance;",
            "\t\t\t\tnode_set(target, nd->preferred);",
            "\t\t\t} else {",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t} while (1);",
            "\t}",
            "\t/*",
            "\t * Promotion is allowed from a memory tier to higher",
            "\t * memory tier only if the memory tier doesn't include",
            "\t * compute. We want to skip promotion from a memory tier,",
            "\t * if any node that is part of the memory tier have CPUs.",
            "\t * Once we detect such a memory tier, we consider that tier",
            "\t * as top tiper from which promotion is not allowed.",
            "\t */",
            "\tlist_for_each_entry_reverse(memtier, &memory_tiers, list) {",
            "\t\ttier_nodes = get_memtier_nodemask(memtier);",
            "\t\tnodes_and(tier_nodes, node_states[N_CPU], tier_nodes);",
            "\t\tif (!nodes_empty(tier_nodes)) {",
            "\t\t\t/*",
            "\t\t\t * abstract distance below the max value of this memtier",
            "\t\t\t * is considered toptier.",
            "\t\t\t */",
            "\t\t\ttop_tier_adistance = memtier->adistance_start +",
            "\t\t\t\t\t\tMEMTIER_CHUNK_SIZE - 1;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\t/*",
            "\t * Now build the lower_tier mask for each node collecting node mask from",
            "\t * all memory tier below it. This allows us to fallback demotion page",
            "\t * allocation to a set of nodes that is closer the above selected",
            "\t * perferred node.",
            "\t */",
            "\tlower_tier = node_states[N_MEMORY];",
            "\tlist_for_each_entry(memtier, &memory_tiers, list) {",
            "\t\t/*",
            "\t\t * Keep removing current tier from lower_tier nodes,",
            "\t\t * This will remove all nodes in current and above",
            "\t\t * memory tier from the lower_tier mask.",
            "\t\t */",
            "\t\ttier_nodes = get_memtier_nodemask(memtier);",
            "\t\tnodes_andnot(lower_tier, lower_tier, tier_nodes);",
            "\t\tmemtier->lower_tier_mask = lower_tier;",
            "\t}",
            "}"
          ],
          "function_name": "disable_all_demotion_targets, establish_demotion_targets",
          "description": "负责维护内存分层间的降级目标关系，通过遍历所有节点计算最佳距离并更新lower_tier_mask。同步RCU保证内存分层变更的可见性，最终构建各节点的下层内存掩码供后续页面迁移使用。",
          "similarity": 0.466152548789978
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_probe_tmpl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 17:34:21\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_probe_tmpl.h`\n\n---\n\n# `trace/trace_probe_tmpl.h` 技术文档\n\n## 1. 文件概述\n\n`trace/trace_probe_tmpl.h` 是 Linux 内核动态追踪（ftrace/kprobe/uprobe）子系统中的一个内联函数模板头文件，主要用于实现 **trace probe 参数提取（fetch）机制**。该文件提供了一系列内联函数，用于从内核或用户空间中提取、转换、存储探针（probe）触发时的参数值（如寄存器值、内存内容、字符串、符号名等），并支持动态数据（如字符串）的处理和位域操作。这些函数被 `kprobe` 和 `uprobe` 的 trace event 实现所复用，是构建动态追踪事件参数处理逻辑的核心组件。\n\n## 2. 核心功能\n\n### 主要内联函数\n\n- **`fetch_store_raw`**  \n  根据指令指定的大小（1/2/4/8 字节或默认 `unsigned long`），将原始数值写入目标缓冲区。\n\n- **`fetch_apply_bitfield`**  \n  对已存储的值应用位域操作（左移 `lshift` 后右移 `rshift`），用于提取结构体中的位字段。\n\n- **`process_common_fetch_insn`**  \n  处理第一阶段的 fetch 指令（立即数、当前进程名、数据指针）。\n\n- **`process_fetch_insn_bottom`**  \n  **核心函数**：实现完整的四阶段参数提取流程（解引用、存储、位域修改、数组循环）。\n\n- **`fetch_store_string` / `fetch_store_string_user`**  \n  从内核/用户空间读取以 null 结尾的字符串并存储。\n\n- **`fetch_store_strlen` / `fetch_store_strlen_user`**  \n  计算内核/用户空间字符串长度（不含终止符）。\n\n- **`fetch_store_symstring` / `fetch_store_symstrlen`**  \n  将地址转换为符号名（如 `func+0x10/0x100`）并存储或计算其长度。\n\n- **`__get_data_size`**  \n  遍历所有动态参数（如字符串），计算所需动态数据区总大小。\n\n- **`store_trace_args`**  \n  遍历所有参数，调用 `process_fetch_insn` 提取并存储到 trace 记录中。\n\n### 关键数据结构（隐式依赖）\n\n- **`struct fetch_insn`**  \n  fetch 指令结构体，包含操作码（`op`）、偏移量（`offset`）、大小（`size`）、立即数（`immediate`）等字段，用于描述如何提取参数。\n\n- **`struct trace_probe`**  \n  trace probe 描述符，包含参数数量（`nr_args`）、参数数组（`args`）等。\n\n- **`struct probe_arg`**  \n  单个参数描述，包含 fetch 指令链（`code`）、偏移（`offset`）、是否为动态类型（`dynamic`）等。\n\n## 3. 关键实现\n\n### 四阶段参数提取流程（`process_fetch_insn_bottom`）\n\n1. **第一阶段（由调用者处理）**：  \n   通过 `process_common_fetch_insn` 获取初始值（如寄存器值、立即数等）。\n\n2. **第二阶段（解引用）**：  \n   循环处理 `FETCH_OP_DEREF`（内核空间）或 `FETCH_OP_UDEREF`（用户空间）指令，从地址读取指针值，支持多级解引用。\n\n3. **第三阶段（存储）**：  \n   根据操作码将值存入缓冲区：\n   - `ST_RAW`：直接存储原始值\n   - `ST_MEM`/`ST_UMEM`：从内存读取固定大小数据\n   - `ST_STRING`/`ST_USTRING`/`ST_SYMSTR`：处理动态字符串（使用 data location 机制）\n\n4. **第四阶段（位域修改）**：  \n   若存在 `FETCH_OP_MOD_BF` 指令，对存储值应用位域掩码。\n\n5. **数组处理**：  \n   若存在 `FETCH_OP_LP_ARRAY` 指令，循环处理数组元素，动态更新目标地址和值地址。\n\n### 动态数据处理机制\n\n- **Data Location 机制**：  \n  动态数据（如字符串）不直接存入主记录，而是在主记录中存储一个 32 位的 **data location** 值（高 16 位为长度，低 16 位为相对于 base 的偏移）。\n- **两阶段处理**：  \n  1. **预计算阶段**（`dest == NULL`）：调用 `process_fetch_insn` 仅计算所需动态数据大小\n  2. **存储阶段**：分配动态数据区，实际存储字符串内容\n\n### 内存安全访问\n\n- 使用 `probe_mem_read` 和 `probe_mem_read_user` 安全读取内核/用户内存，避免因无效地址导致系统崩溃。\n- 所有函数标记为 `nokprobe_inline`，确保可在 kprobe 上下文中安全执行。\n\n## 4. 依赖关系\n\n- **依赖头文件**：\n  - `<linux/kernel.h>`：基础内核 API\n  - `<linux/uaccess.h>`：用户空间内存访问（`probe_mem_read_user`）\n  - `<linux/kallsyms.h>`：符号解析（`sprint_symbol`）\n  - `trace_probe.h`：`struct trace_probe`、`struct probe_arg`、`struct fetch_insn` 等定义\n  - `trace.h`：trace event 相关宏和函数\n\n- **被依赖模块**：\n  - `kernel/trace/trace_kprobe.c`：kprobe trace event 实现\n  - `kernel/trace/trace_uprobe.c`：uprobe trace event 实现\n  - 其他基于 trace probe 的动态追踪模块\n\n## 5. 使用场景\n\n- **动态追踪事件参数捕获**：  \n  当用户通过 ftrace 接口（如 `/sys/kernel/debug/tracing/kprobe_events`）定义带有参数的 kprobe/uprobe 事件时，内核使用此文件中的函数提取指定参数值。\n\n- **复杂参数类型支持**：  \n  支持提取结构体成员（通过偏移和解引用）、位域、字符串、符号地址等复杂数据类型。\n\n- **用户空间和内核空间统一处理**：  \n  通过 `*_user` 系列函数，统一处理内核探针和用户空间探针（uprobe）的参数提取逻辑。\n\n- **高效内存管理**：  \n  通过 data location 机制和两阶段处理，高效管理变长数据（如字符串）的存储，避免 trace buffer 浪费。",
      "similarity": 0.5236626267433167,
      "chunks": []
    }
  ]
}