{
  "query": "进程调度",
  "timestamp": "2025-12-26 00:00:50",
  "retrieved_files": [
    {
      "source_file": "kernel/ptrace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ptrace.c`\n\n---\n\n# ptrace.c 技术文档\n\n## 1. 文件概述\n\n`ptrace.c` 是 Linux 内核中实现 **ptrace**（进程跟踪）机制的核心通用代码文件。该文件提供了跨架构的 ptrace 公共接口和基础功能，避免在每个体系结构中重复实现相同逻辑。ptrace 机制允许一个进程（tracer，通常是调试器）观察和控制另一个进程（tracee）的执行，包括读写其内存、寄存器状态、拦截系统调用等，是调试器（如 GDB）、系统调用追踪工具（如 strace）和安全监控工具的基础。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`ptrace_access_vm()`**  \n  安全地访问被跟踪进程（tracee）的虚拟内存空间，用于读写其内存内容。\n\n- **`__ptrace_link()`**  \n  将被跟踪进程链接到跟踪进程（tracer）的 `ptraced` 链表中，并设置其父进程为 tracer。\n\n- **`ptrace_link()`**  \n  封装 `__ptrace_link()`，使用当前进程的凭证建立跟踪关系。\n\n- **`__ptrace_unlink()`**  \n  解除跟踪关系：将被跟踪进程从 tracer 的链表中移除，恢复其原始父进程，并根据进程组停止状态调整其任务状态（如从 `TASK_TRACED` 转为 `TASK_STOPPED` 或唤醒）。\n\n- **`ptrace_freeze_traced()`** / **`ptrace_unfreeze_traced()`**  \n  在执行 ptrace 操作期间临时冻结被跟踪进程，防止其被意外唤醒（即使是 SIGKILL），确保操作的原子性和一致性。\n\n- **`ptrace_check_attach()`**  \n  验证当前进程是否有权对目标进程执行 ptrace 操作，并确保目标进程处于合适的跟踪状态（可选）。\n\n- **`looks_like_a_spurious_pid()`**  \n  辅助函数，用于检测因线程组 leader 更换（如 `de_thread()`）导致的“虚假”ptrace 事件，避免对已销毁进程的误操作。\n\n### 关键数据结构字段（在 `task_struct` 中）\n\n- `ptrace`：标志位，表示进程是否被跟踪。\n- `parent` / `real_parent`：分别表示当前父进程（通常是 tracer）和原始父进程。\n- `ptraced`：链表头，包含所有被当前进程跟踪的子进程。\n- `ptrace_entry`：链表节点，用于加入 tracer 的 `ptraced` 链表。\n- `ptracer_cred`：跟踪进程的凭证（credentials），用于权限检查。\n- `jobctl`：任务控制标志，包含 `JOBCTL_PTRACE_FROZEN`、`JOBCTL_TRACED`、`JOBCTL_STOP_PENDING` 等 ptrace 相关状态。\n\n## 3. 关键实现\n\n### 安全内存访问 (`ptrace_access_vm`)\n- 通过 `get_task_mm()` 获取目标进程的内存描述符 `mm_struct`。\n- 执行严格的权限检查：\n  - 目标进程必须正在被跟踪（`tsk->ptrace` 非零）。\n  - 当前进程必须是目标进程的直接父进程（`current == tsk->parent`）。\n  - 或者当前进程在目标进程的用户命名空间中具有 `CAP_SYS_PTRACE` 能力（通过 `ptracer_capable()` 检查）。\n- 使用 `__access_remote_vm()` 安全地读写目标进程内存，避免直接遍历页表。\n\n### 跟踪关系管理\n- **链接**：`ptrace_link()` 在持有 `tasklist_lock` 写锁时调用 `__ptrace_link()`，将 tracee 加入 tracer 的 `ptraced` 链表，并保存 tracer 的凭证。\n- **解链接**：`__ptrace_unlink()` 在 detach 或 tracer 退出时调用：\n  - 清除 syscall trace/emu 标志。\n  - 恢复 `real_parent`。\n  - 清除 `ptrace` 标志和 jobctl 中的 trap 相关位。\n  - 根据进程组停止状态决定是否设置 `JOBCTL_STOP_PENDING` 并唤醒进程（`ptrace_signal_wake_up()`）。\n\n### 进程状态冻结机制\n- 在执行 ptrace 操作前调用 `ptrace_freeze_traced()`：\n  - 若 tracee 处于 `TASK_TRACED` 且无致命信号待处理，则设置 `JOBCTL_PTRACE_FROZEN` 标志，使其无法被唤醒。\n- 操作完成后调用 `ptrace_unfreeze_traced()`：\n  - 清除冻结标志。\n  - 若存在致命信号（如 SIGKILL），则清除 `JOBCTL_TRACED` 并唤醒进程以处理信号。\n\n### 权限与状态验证 (`ptrace_check_attach`)\n- 在 `tasklist_lock` 读锁保护下验证：\n  - 目标进程确由当前进程跟踪（`child->ptrace && child->parent == current`）。\n  - 若 `ignore_state=false`，则进一步冻结 tracee 以确保其处于稳定状态。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`mm_struct`、`sighand_struct` 等核心数据结构，以及 `wake_up_state()`、`task_is_traced()` 等调度状态管理函数。\n- **内存管理**：通过 `get_task_mm()`、`mmput()` 和 `__access_remote_vm()` 访问远程进程内存。\n- **信号处理**：大量使用 `siglock`、`jobctl`、`signal_struct` 等信号相关机制管理进程状态转换。\n- **安全模块**：集成 LSM（Linux Security Module）钩子（`security_ptrace_access_check`）和能力检查（`capable()`）。\n- **审计与通知**：与 `audit` 和 `cn_proc`（进程事件连接器）交互，记录 ptrace 事件。\n- **体系结构相关代码**：依赖 `asm/syscall.h` 提供的 `syscall_get_*` 接口获取系统调用信息。\n- **硬件断点**：通过 `hw_breakpoint.h` 支持硬件断点调试功能。\n\n## 5. 使用场景\n\n- **调试器（如 GDB）**：attach 到目标进程，读取/修改寄存器和内存，设置断点，单步执行。\n- **系统调用追踪（如 strace）**：拦截并记录目标进程的所有系统调用及其参数和返回值。\n- **安全监控工具**：监控可疑进程的行为，如检测恶意代码注入或提权操作。\n- **容器与沙箱**：在用户命名空间中实现进程隔离和监控。\n- **内核测试**：用于内核自检和调试，验证进程行为和系统调用处理。\n- **进程注入与热补丁**：通过修改运行中进程的内存和寄存器状态实现代码注入或修复。",
      "similarity": 0.6364158391952515,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/ptrace.c",
          "start_line": 44,
          "end_line": 148,
          "content": [
            "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,",
            "\t\t     void *buf, int len, unsigned int gup_flags)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint ret;",
            "",
            "\tmm = get_task_mm(tsk);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tif (!tsk->ptrace ||",
            "\t    (current != tsk->parent) ||",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptracer_capable(tsk, mm->user_ns))) {",
            "\t\tmmput(mm);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = __access_remote_vm(mm, addr, buf, len, gup_flags);",
            "\tmmput(mm);",
            "",
            "\treturn ret;",
            "}",
            "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,",
            "\t\t   const struct cred *ptracer_cred)",
            "{",
            "\tBUG_ON(!list_empty(&child->ptrace_entry));",
            "\tlist_add(&child->ptrace_entry, &new_parent->ptraced);",
            "\tchild->parent = new_parent;",
            "\tchild->ptracer_cred = get_cred(ptracer_cred);",
            "}",
            "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)",
            "{",
            "\t__ptrace_link(child, new_parent, current_cred());",
            "}",
            "void __ptrace_unlink(struct task_struct *child)",
            "{",
            "\tconst struct cred *old_cred;",
            "\tBUG_ON(!child->ptrace);",
            "",
            "\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tchild->parent = child->real_parent;",
            "\tlist_del_init(&child->ptrace_entry);",
            "\told_cred = child->ptracer_cred;",
            "\tchild->ptracer_cred = NULL;",
            "\tput_cred(old_cred);",
            "",
            "\tspin_lock(&child->sighand->siglock);",
            "\tchild->ptrace = 0;",
            "\t/*",
            "\t * Clear all pending traps and TRAPPING.  TRAPPING should be",
            "\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.",
            "\t */",
            "\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);",
            "\ttask_clear_jobctl_trapping(child);",
            "",
            "\t/*",
            "\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and",
            "\t * @child isn't dead.",
            "\t */",
            "\tif (!(child->flags & PF_EXITING) &&",
            "\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||",
            "\t     child->signal->group_stop_count)) {",
            "\t\tchild->jobctl |= JOBCTL_STOP_PENDING;",
            "",
            "\t\t/*",
            "\t\t * This is only possible if this thread was cloned by the",
            "\t\t * traced task running in the stopped group, set the signal",
            "\t\t * for the future reports.",
            "\t\t * FIXME: we should change ptrace_init_task() to handle this",
            "\t\t * case.",
            "\t\t */",
            "\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))",
            "\t\t\tchild->jobctl |= SIGSTOP;",
            "\t}",
            "",
            "\t/*",
            "\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick",
            "\t * @child in the butt.  Note that @resume should be used iff @child",
            "\t * is in TASK_TRACED; otherwise, we might unduly disrupt",
            "\t * TASK_KILLABLE sleeps.",
            "\t */",
            "\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))",
            "\t\tptrace_signal_wake_up(child, true);",
            "",
            "\tspin_unlock(&child->sighand->siglock);",
            "}",
            "static bool looks_like_a_spurious_pid(struct task_struct *task)",
            "{",
            "\tif (task->exit_code != ((PTRACE_EVENT_EXEC << 8) | SIGTRAP))",
            "\t\treturn false;",
            "",
            "\tif (task_pid_vnr(task) == task->ptrace_message)",
            "\t\treturn false;",
            "\t/*",
            "\t * The tracee changed its pid but the PTRACE_EVENT_EXEC event",
            "\t * was not wait()'ed, most probably debugger targets the old",
            "\t * leader which was destroyed in de_thread().",
            "\t */",
            "\treturn true;",
            "}"
          ],
          "function_name": "ptrace_access_vm, __ptrace_link, ptrace_link, __ptrace_unlink, looks_like_a_spurious_pid",
          "description": "实现进程跟踪核心操作，包含访问目标进程地址空间、维护跟踪链表、解除跟踪关系及检测虚假PID逻辑，用于安全控制和状态同步。",
          "similarity": 0.6629105806350708
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/ptrace.c",
          "start_line": 806,
          "end_line": 922,
          "content": [
            "static long ptrace_get_rseq_configuration(struct task_struct *task,",
            "\t\t\t\t\t  unsigned long size, void __user *data)",
            "{",
            "\tstruct ptrace_rseq_configuration conf = {",
            "\t\t.rseq_abi_pointer = (u64)(uintptr_t)task->rseq,",
            "\t\t.rseq_abi_size = task->rseq_len,",
            "\t\t.signature = task->rseq_sig,",
            "\t\t.flags = 0,",
            "\t};",
            "",
            "\tsize = min_t(unsigned long, size, sizeof(conf));",
            "\tif (copy_to_user(data, &conf, size))",
            "\t\treturn -EFAULT;",
            "\treturn sizeof(conf);",
            "}",
            "static int ptrace_resume(struct task_struct *child, long request,",
            "\t\t\t unsigned long data)",
            "{",
            "\tif (!valid_signal(data))",
            "\t\treturn -EIO;",
            "",
            "\tif (request == PTRACE_SYSCALL)",
            "\t\tset_task_syscall_work(child, SYSCALL_TRACE);",
            "\telse",
            "\t\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tif (request == PTRACE_SYSEMU || request == PTRACE_SYSEMU_SINGLESTEP)",
            "\t\tset_task_syscall_work(child, SYSCALL_EMU);",
            "\telse",
            "\t\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tif (is_singleblock(request)) {",
            "\t\tif (unlikely(!arch_has_block_step()))",
            "\t\t\treturn -EIO;",
            "\t\tuser_enable_block_step(child);",
            "\t} else if (is_singlestep(request) || is_sysemu_singlestep(request)) {",
            "\t\tif (unlikely(!arch_has_single_step()))",
            "\t\t\treturn -EIO;",
            "\t\tuser_enable_single_step(child);",
            "\t} else {",
            "\t\tuser_disable_single_step(child);",
            "\t}",
            "",
            "\t/*",
            "\t * Change ->exit_code and ->state under siglock to avoid the race",
            "\t * with wait_task_stopped() in between; a non-zero ->exit_code will",
            "\t * wrongly look like another report from tracee.",
            "\t *",
            "\t * Note that we need siglock even if ->exit_code == data and/or this",
            "\t * status was not reported yet, the new status must not be cleared by",
            "\t * wait_task_stopped() after resume.",
            "\t */",
            "\tspin_lock_irq(&child->sighand->siglock);",
            "\tchild->exit_code = data;",
            "\tchild->jobctl &= ~JOBCTL_TRACED;",
            "\twake_up_state(child, __TASK_TRACED);",
            "\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_regset(struct task_struct *task, int req, unsigned int type,",
            "\t\t\t struct iovec *kiov)",
            "{",
            "\tconst struct user_regset_view *view = task_user_regset_view(task);",
            "\tconst struct user_regset *regset = find_regset(view, type);",
            "\tint regset_no;",
            "",
            "\tif (!regset || (kiov->iov_len % regset->size) != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tregset_no = regset - view->regsets;",
            "\tkiov->iov_len = min(kiov->iov_len,",
            "\t\t\t    (__kernel_size_t) (regset->n * regset->size));",
            "",
            "\tif (req == PTRACE_GETREGSET)",
            "\t\treturn copy_regset_to_user(task, view, regset_no, 0,",
            "\t\t\t\t\t   kiov->iov_len, kiov->iov_base);",
            "\telse",
            "\t\treturn copy_regset_from_user(task, view, regset_no, 0,",
            "\t\t\t\t\t     kiov->iov_len, kiov->iov_base);",
            "}",
            "static unsigned long",
            "ptrace_get_syscall_info_entry(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t      struct ptrace_syscall_info *info)",
            "{",
            "\tunsigned long args[ARRAY_SIZE(info->entry.args)];",
            "\tint i;",
            "",
            "\tinfo->op = PTRACE_SYSCALL_INFO_ENTRY;",
            "\tinfo->entry.nr = syscall_get_nr(child, regs);",
            "\tsyscall_get_arguments(child, regs, args);",
            "\tfor (i = 0; i < ARRAY_SIZE(args); i++)",
            "\t\tinfo->entry.args[i] = args[i];",
            "",
            "\t/* args is the last field in struct ptrace_syscall_info.entry */",
            "\treturn offsetofend(struct ptrace_syscall_info, entry.args);",
            "}",
            "static unsigned long",
            "ptrace_get_syscall_info_seccomp(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t\tstruct ptrace_syscall_info *info)",
            "{",
            "\t/*",
            "\t * As struct ptrace_syscall_info.entry is currently a subset",
            "\t * of struct ptrace_syscall_info.seccomp, it makes sense to",
            "\t * initialize that subset using ptrace_get_syscall_info_entry().",
            "\t * This can be reconsidered in the future if these structures",
            "\t * diverge significantly enough.",
            "\t */",
            "\tptrace_get_syscall_info_entry(child, regs, info);",
            "\tinfo->op = PTRACE_SYSCALL_INFO_SECCOMP;",
            "\tinfo->seccomp.ret_data = child->ptrace_message;",
            "",
            "\t/* ret_data is the last field in struct ptrace_syscall_info.seccomp */",
            "\treturn offsetofend(struct ptrace_syscall_info, seccomp.ret_data);",
            "}"
          ],
          "function_name": "ptrace_get_rseq_configuration, ptrace_resume, ptrace_regset, ptrace_get_syscall_info_entry, ptrace_get_syscall_info_seccomp",
          "description": "ptrace_get_rseq_configuration获取RSEQ配置信息；ptrace_resume控制跟踪进程的恢复状态，包括系统调用跟踪、单步执行和信号处理；ptrace_regset处理用户寄存器集合的读写；ptrace_get_syscall_info_*系列函数构建系统调用相关信息结构体",
          "similarity": 0.6199493408203125
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/ptrace.c",
          "start_line": 360,
          "end_line": 490,
          "content": [
            "bool ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tint err;",
            "\ttask_lock(task);",
            "\terr = __ptrace_may_access(task, mode);",
            "\ttask_unlock(task);",
            "\treturn !err;",
            "}",
            "static int check_ptrace_options(unsigned long data)",
            "{",
            "\tif (data & ~(unsigned long)PTRACE_O_MASK)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {",
            "\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||",
            "\t\t    !IS_ENABLED(CONFIG_SECCOMP))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (!capable(CAP_SYS_ADMIN))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||",
            "\t\t    current->ptrace & PT_SUSPEND_SECCOMP)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "\treturn 0;",
            "}",
            "static inline void ptrace_set_stopped(struct task_struct *task)",
            "{",
            "\tguard(spinlock)(&task->sighand->siglock);",
            "",
            "\t/*",
            "\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and",
            "\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING",
            "\t * will be cleared if the child completes the transition or any",
            "\t * event which clears the group stop states happens.  We'll wait",
            "\t * for the transition to complete before returning from this",
            "\t * function.",
            "\t *",
            "\t * This hides STOPPED -> RUNNING -> TRACED transition from the",
            "\t * attaching thread but a different thread in the same group can",
            "\t * still observe the transient RUNNING state.  IOW, if another",
            "\t * thread's WNOHANG wait(2) on the stopped tracee races against",
            "\t * ATTACH, the wait(2) may fail due to the transient RUNNING.",
            "\t *",
            "\t * The following task_is_stopped() test is safe as both transitions",
            "\t * in and out of STOPPED are protected by siglock.",
            "\t */",
            "\tif (task_is_stopped(task) &&",
            "\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING)) {",
            "\t\ttask->jobctl &= ~JOBCTL_STOPPED;",
            "\t\tsignal_wake_up_state(task, __TASK_STOPPED);",
            "\t}",
            "}",
            "static int ptrace_attach(struct task_struct *task, long request,",
            "\t\t\t unsigned long addr,",
            "\t\t\t unsigned long flags)",
            "{",
            "\tbool seize = (request == PTRACE_SEIZE);",
            "\tint retval;",
            "",
            "\tif (seize) {",
            "\t\tif (addr != 0)",
            "\t\t\treturn -EIO;",
            "\t\t/*",
            "\t\t * This duplicates the check in check_ptrace_options() because",
            "\t\t * ptrace_attach() and ptrace_setoptions() have historically",
            "\t\t * used different error codes for unknown ptrace options.",
            "\t\t */",
            "\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)",
            "\t\t\treturn -EIO;",
            "",
            "\t\tretval = check_ptrace_options(flags);",
            "\t\tif (retval)",
            "\t\t\treturn retval;",
            "\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);",
            "\t} else {",
            "\t\tflags = PT_PTRACED;",
            "\t}",
            "",
            "\taudit_ptrace(task);",
            "",
            "\tif (unlikely(task->flags & PF_KTHREAD))",
            "\t\treturn -EPERM;",
            "\tif (same_thread_group(task, current))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Protect exec's credential calculations against our interference;",
            "\t * SUID, SGID and LSM creds get determined differently",
            "\t * under ptrace.",
            "\t */",
            "\tscoped_cond_guard (mutex_intr, return -ERESTARTNOINTR,",
            "\t\t\t   &task->signal->cred_guard_mutex) {",
            "",
            "\t\tscoped_guard (task_lock, task) {",
            "\t\t\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);",
            "\t\t\tif (retval)",
            "\t\t\t\treturn retval;",
            "\t\t}",
            "",
            "\t\tscoped_guard (write_lock_irq, &tasklist_lock) {",
            "\t\t\tif (unlikely(task->exit_state))",
            "\t\t\t\treturn -EPERM;",
            "\t\t\tif (task->ptrace)",
            "\t\t\t\treturn -EPERM;",
            "",
            "\t\t\ttask->ptrace = flags;",
            "",
            "\t\t\tptrace_link(task, current);",
            "",
            "\t\t\t/* SEIZE doesn't trap tracee on attach */",
            "\t\t\tif (!seize)",
            "\t\t\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);",
            "",
            "\t\t\tptrace_set_stopped(task);",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * We do not bother to change retval or clear JOBCTL_TRAPPING",
            "\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will",
            "\t * not return to user-mode, it will exit and clear this bit in",
            "\t * __ptrace_unlink() if it wasn't already cleared by the tracee;",
            "\t * and until then nobody can ptrace this task.",
            "\t */",
            "\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);",
            "\tproc_ptrace_connector(task, PTRACE_ATTACH);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "ptrace_may_access, check_ptrace_options, ptrace_set_stopped, ptrace_attach",
          "description": "实现ptrace附加流程，包含权限校验、选项解析、停止状态设置及实际附加操作，协调信号传递和跟踪标志位更新。",
          "similarity": 0.6126598119735718
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/ptrace.c",
          "start_line": 647,
          "end_line": 799,
          "content": [
            "int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tif (copy_from_user(buf, src, this_len))",
            "\t\t\treturn -EFAULT;",
            "\t\tretval = ptrace_access_vm(tsk, dst, buf, this_len,",
            "\t\t\t\tFOLL_FORCE | FOLL_WRITE);",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}",
            "static int ptrace_setoptions(struct task_struct *child, unsigned long data)",
            "{",
            "\tunsigned flags;",
            "\tint ret;",
            "",
            "\tret = check_ptrace_options(data);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* Avoid intermediate state when all opts are cleared */",
            "\tflags = child->ptrace;",
            "\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);",
            "\tflags |= (data << PT_OPT_FLAG_SHIFT);",
            "\tchild->ptrace = flags;",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(info, child->last_siginfo);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(child->last_siginfo, info);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_peek_siginfo(struct task_struct *child,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long data)",
            "{",
            "\tstruct ptrace_peeksiginfo_args arg;",
            "\tstruct sigpending *pending;",
            "\tstruct sigqueue *q;",
            "\tint ret, i;",
            "",
            "\tret = copy_from_user(&arg, (void __user *) addr,",
            "\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)",
            "\t\treturn -EINVAL; /* unknown flags */",
            "",
            "\tif (arg.nr < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure arg.off fits in an unsigned long */",
            "\tif (arg.off > ULONG_MAX)",
            "\t\treturn 0;",
            "",
            "\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)",
            "\t\tpending = &child->signal->shared_pending;",
            "\telse",
            "\t\tpending = &child->pending;",
            "",
            "\tfor (i = 0; i < arg.nr; ) {",
            "\t\tkernel_siginfo_t info;",
            "\t\tunsigned long off = arg.off + i;",
            "\t\tbool found = false;",
            "",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tlist_for_each_entry(q, &pending->list, list) {",
            "\t\t\tif (!off--) {",
            "\t\t\t\tfound = true;",
            "\t\t\t\tcopy_siginfo(&info, &q->info);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tif (!found) /* beyond the end of the list */",
            "\t\t\tbreak;",
            "",
            "#ifdef CONFIG_COMPAT",
            "\t\tif (unlikely(in_compat_syscall())) {",
            "\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);",
            "",
            "\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t} else",
            "#endif",
            "\t\t{",
            "\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;",
            "",
            "\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tdata += sizeof(siginfo_t);",
            "\t\ti++;",
            "",
            "\t\tif (signal_pending(current))",
            "\t\t\tbreak;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\tif (i > 0)",
            "\t\treturn i;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_writedata, ptrace_setoptions, ptrace_getsiginfo, ptrace_setsiginfo, ptrace_peek_siginfo",
          "description": "实现ptrace_writedata用于将数据写入被跟踪进程的内存，通过循环拷贝并处理错误；ptrace_setoptions用于更新跟踪选项标志位；ptrace_getsiginfo/ptrace_setsiginfo用于获取和设置进程的最后一个信号信息；ptrace_peek_siginfo用于遍历信号队列并复制信号信息到用户空间",
          "similarity": 0.6117827892303467
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/ptrace.c",
          "start_line": 967,
          "end_line": 1267,
          "content": [
            "static unsigned long",
            "ptrace_get_syscall_info_exit(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t     struct ptrace_syscall_info *info)",
            "{",
            "\tinfo->op = PTRACE_SYSCALL_INFO_EXIT;",
            "\tinfo->exit.rval = syscall_get_error(child, regs);",
            "\tinfo->exit.is_error = !!info->exit.rval;",
            "\tif (!info->exit.is_error)",
            "\t\tinfo->exit.rval = syscall_get_return_value(child, regs);",
            "",
            "\t/* is_error is the last field in struct ptrace_syscall_info.exit */",
            "\treturn offsetofend(struct ptrace_syscall_info, exit.is_error);",
            "}",
            "static int",
            "ptrace_get_syscall_info(struct task_struct *child, unsigned long user_size,",
            "\t\t\tvoid __user *datavp)",
            "{",
            "\tstruct pt_regs *regs = task_pt_regs(child);",
            "\tstruct ptrace_syscall_info info = {",
            "\t\t.op = PTRACE_SYSCALL_INFO_NONE,",
            "\t\t.arch = syscall_get_arch(child),",
            "\t\t.instruction_pointer = instruction_pointer(regs),",
            "\t\t.stack_pointer = user_stack_pointer(regs),",
            "\t};",
            "\tunsigned long actual_size = offsetof(struct ptrace_syscall_info, entry);",
            "\tunsigned long write_size;",
            "",
            "\t/*",
            "\t * This does not need lock_task_sighand() to access",
            "\t * child->last_siginfo because ptrace_freeze_traced()",
            "\t * called earlier by ptrace_check_attach() ensures that",
            "\t * the tracee cannot go away and clear its last_siginfo.",
            "\t */",
            "\tswitch (child->last_siginfo ? child->last_siginfo->si_code : 0) {",
            "\tcase SIGTRAP | 0x80:",
            "\t\tswitch (child->ptrace_message) {",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_ENTRY:",
            "\t\t\tactual_size = ptrace_get_syscall_info_entry(child, regs,",
            "\t\t\t\t\t\t\t\t    &info);",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_EXIT:",
            "\t\t\tactual_size = ptrace_get_syscall_info_exit(child, regs,",
            "\t\t\t\t\t\t\t\t   &info);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase SIGTRAP | (PTRACE_EVENT_SECCOMP << 8):",
            "\t\tactual_size = ptrace_get_syscall_info_seccomp(child, regs,",
            "\t\t\t\t\t\t\t      &info);",
            "\t\tbreak;",
            "\t}",
            "",
            "\twrite_size = min(actual_size, user_size);",
            "\treturn copy_to_user(datavp, &info, write_size) ? -EFAULT : actual_size;",
            "}",
            "int ptrace_request(struct task_struct *child, long request,",
            "\t\t   unsigned long addr, unsigned long data)",
            "{",
            "\tbool seized = child->ptrace & PT_SEIZED;",
            "\tint ret = -EIO;",
            "\tkernel_siginfo_t siginfo, *si;",
            "\tvoid __user *datavp = (void __user *) data;",
            "\tunsigned long __user *datalp = datavp;",
            "\tunsigned long flags;",
            "",
            "\tswitch (request) {",
            "\tcase PTRACE_PEEKTEXT:",
            "\tcase PTRACE_PEEKDATA:",
            "\t\treturn generic_ptrace_peekdata(child, addr, data);",
            "\tcase PTRACE_POKETEXT:",
            "\tcase PTRACE_POKEDATA:",
            "\t\treturn generic_ptrace_pokedata(child, addr, data);",
            "",
            "#ifdef PTRACE_OLDSETOPTIONS",
            "\tcase PTRACE_OLDSETOPTIONS:",
            "#endif",
            "\tcase PTRACE_SETOPTIONS:",
            "\t\tret = ptrace_setoptions(child, data);",
            "\t\tbreak;",
            "\tcase PTRACE_GETEVENTMSG:",
            "\t\tret = put_user(child->ptrace_message, datalp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_PEEKSIGINFO:",
            "\t\tret = ptrace_peek_siginfo(child, addr, data);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGINFO:",
            "\t\tret = ptrace_getsiginfo(child, &siginfo);",
            "\t\tif (!ret)",
            "\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SETSIGINFO:",
            "\t\tret = copy_siginfo_from_user(&siginfo, datavp);",
            "\t\tif (!ret)",
            "\t\t\tret = ptrace_setsiginfo(child, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGMASK: {",
            "\t\tsigset_t *mask;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (test_tsk_restore_sigmask(child))",
            "\t\t\tmask = &child->saved_sigmask;",
            "\t\telse",
            "\t\t\tmask = &child->blocked;",
            "",
            "\t\tif (copy_to_user(datavp, mask, sizeof(sigset_t)))",
            "\t\t\tret = -EFAULT;",
            "\t\telse",
            "\t\t\tret = 0;",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_SETSIGMASK: {",
            "\t\tsigset_t new_set;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (copy_from_user(&new_set, datavp, sizeof(sigset_t))) {",
            "\t\t\tret = -EFAULT;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));",
            "",
            "\t\t/*",
            "\t\t * Every thread does recalc_sigpending() after resume, so",
            "\t\t * retarget_shared_pending() and recalc_sigpending() are not",
            "\t\t * called here.",
            "\t\t */",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tchild->blocked = new_set;",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tclear_tsk_restore_sigmask(child);",
            "",
            "\t\tret = 0;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_INTERRUPT:",
            "\t\t/*",
            "\t\t * Stop tracee without any side-effect on signal or job",
            "\t\t * control.  At least one trap is guaranteed to happen",
            "\t\t * after this request.  If @child is already trapped, the",
            "\t\t * current trap is not disturbed and another trap will",
            "\t\t * happen after the current trap is ended with PTRACE_CONT.",
            "\t\t *",
            "\t\t * The actual trap might not be PTRACE_EVENT_STOP trap but",
            "\t\t * the pending condition is cleared regardless.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * INTERRUPT doesn't disturb existing trap sans one",
            "\t\t * exception.  If ptracer issued LISTEN for the current",
            "\t\t * STOP, this INTERRUPT should clear LISTEN and re-trap",
            "\t\t * tracee into STOP.",
            "\t\t */",
            "\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))",
            "\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);",
            "",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tret = 0;",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_LISTEN:",
            "\t\t/*",
            "\t\t * Listen for events.  Tracee must be in STOP.  It's not",
            "\t\t * resumed per-se but is not considered to be in TRACED by",
            "\t\t * wait(2) or ptrace(2).  If an async event (e.g. group",
            "\t\t * stop state change) happens, tracee will enter STOP trap",
            "\t\t * again.  Alternatively, ptracer can issue INTERRUPT to",
            "\t\t * finish listening and re-trap tracee into STOP.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\tsi = child->last_siginfo;",
            "\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {",
            "\t\t\tchild->jobctl |= JOBCTL_LISTENING;",
            "\t\t\t/*",
            "\t\t\t * If NOTIFY is set, it means event happened between",
            "\t\t\t * start of this trap and now.  Trigger re-trap.",
            "\t\t\t */",
            "\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)",
            "\t\t\t\tptrace_signal_wake_up(child, true);",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_DETACH:\t /* detach a process that was attached. */",
            "\t\tret = ptrace_detach(child, data);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_BINFMT_ELF_FDPIC",
            "\tcase PTRACE_GETFDPIC: {",
            "\t\tstruct mm_struct *mm = get_task_mm(child);",
            "\t\tunsigned long tmp = 0;",
            "",
            "\t\tret = -ESRCH;",
            "\t\tif (!mm)",
            "\t\t\tbreak;",
            "",
            "\t\tswitch (addr) {",
            "\t\tcase PTRACE_GETFDPIC_EXEC:",
            "\t\t\ttmp = mm->context.exec_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_GETFDPIC_INTERP:",
            "\t\t\ttmp = mm->context.interp_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tmmput(mm);",
            "",
            "\t\tret = put_user(tmp, datalp);",
            "\t\tbreak;",
            "\t}",
            "#endif",
            "",
            "\tcase PTRACE_SINGLESTEP:",
            "#ifdef PTRACE_SINGLEBLOCK",
            "\tcase PTRACE_SINGLEBLOCK:",
            "#endif",
            "#ifdef PTRACE_SYSEMU",
            "\tcase PTRACE_SYSEMU:",
            "\tcase PTRACE_SYSEMU_SINGLESTEP:",
            "#endif",
            "\tcase PTRACE_SYSCALL:",
            "\tcase PTRACE_CONT:",
            "\t\treturn ptrace_resume(child, request, data);",
            "",
            "\tcase PTRACE_KILL:",
            "\t\tsend_sig_info(SIGKILL, SEND_SIG_NOINFO, child);",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_HAVE_ARCH_TRACEHOOK",
            "\tcase PTRACE_GETREGSET:",
            "\tcase PTRACE_SETREGSET: {",
            "\t\tstruct iovec kiov;",
            "\t\tstruct iovec __user *uiov = datavp;",
            "",
            "\t\tif (!access_ok(uiov, sizeof(*uiov)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||",
            "\t\t    __get_user(kiov.iov_len, &uiov->iov_len))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tret = ptrace_regset(child, request, addr, &kiov);",
            "\t\tif (!ret)",
            "\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_GET_SYSCALL_INFO:",
            "\t\tret = ptrace_get_syscall_info(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SECCOMP_GET_FILTER:",
            "\t\tret = seccomp_get_filter(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SECCOMP_GET_METADATA:",
            "\t\tret = seccomp_get_metadata(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_RSEQ",
            "\tcase PTRACE_GET_RSEQ_CONFIGURATION:",
            "\t\tret = ptrace_get_rseq_configuration(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_set_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_get_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_get_syscall_info_exit, ptrace_get_syscall_info, ptrace_request",
          "description": "ptrace_get_syscall_info根据进程最后信号信息构造系统调用详细数据结构；ptrace_request作为ptrace系统调用的核心分发函数，处理包括中断、继续执行、获取/设置信号掩码、获取系统调用信息等各类请求",
          "similarity": 0.595283031463623
        }
      ]
    },
    {
      "source_file": "kernel/sched/core_sched.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:00:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\core_sched.c`\n\n---\n\n# `sched/core_sched.c` 技术文档\n\n## 1. 文件概述\n\n`sched/core_sched.c` 是 Linux 内核调度器中用于实现 **核心调度（Core Scheduling）** 功能的核心文件之一。核心调度是一种安全机制，旨在防止来自不同安全上下文的任务在同一个物理 CPU 核心（特别是超线程/SMT 共享核心）上并发执行，从而缓解侧信道攻击（如 Spectre、MDS 等）。\n\n该文件主要负责管理任务的 **调度 cookie**（`core_cookie`），通过引用计数的 cookie 对象将具有相同安全上下文的任务分组，确保只有拥有相同 cookie 的任务才能在同一个 CPU 核心上并发运行。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct sched_core_cookie`**  \n  表示一个调度 cookie，仅包含一个引用计数器 `refcnt`。其内存地址本身即作为 cookie 值使用。\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `sched_core_alloc_cookie()` | 分配一个新的 `sched_core_cookie` 对象，初始化引用计数为 1，并启用核心调度全局状态。返回 cookie 地址（转换为 `unsigned long`）。 |\n| `sched_core_put_cookie(unsigned long cookie)` | 释放 cookie 引用；若引用计数归零，则释放内存并关闭核心调度全局状态。 |\n| `sched_core_get_cookie(unsigned long cookie)` | 增加 cookie 引用计数，返回原 cookie 值。 |\n| `sched_core_update_cookie(struct task_struct *p, unsigned long cookie)` | 原子地更新任务 `p` 的 `core_cookie`，处理任务在运行队列中的入队/出队，并在必要时触发重调度。 |\n| `sched_core_clone_cookie(struct task_struct *p)` | 安全地复制任务 `p` 的当前 cookie（带锁保护），用于 fork 或共享操作。 |\n| `sched_core_fork(struct task_struct *p)` | 在 `fork()` 时初始化子任务的核心调度状态，继承父进程的 cookie。 |\n| `sched_core_free(struct task_struct *p)` | 在任务退出时释放其持有的 cookie 引用。 |\n| `__sched_core_set(struct task_struct *p, unsigned long cookie)` | 设置任务 `p` 的 cookie，自动处理引用计数的获取与释放。 |\n| `sched_core_share_pid(...)` | 用户空间通过 `prctl(PR_SCHED_CORE, ...)` 调用的核心接口，支持创建、查询、共享 cookie。 |\n| `__sched_core_account_forceidle(struct rq *rq)` | （仅当 `CONFIG_SCHEDSTATS` 启用）统计核心强制空闲（force-idle）时间，并分摊到相关任务。 |\n| `__sched_core_tick(struct rq *rq)` | 在调度 tick 中调用，用于更新强制空闲时间统计。 |\n\n## 3. 关键实现\n\n### Cookie 生命周期管理\n- Cookie 通过 `kmalloc` 动态分配，其地址作为唯一标识。\n- 使用 `refcount_t` 实现线程安全的引用计数。\n- `sched_core_get()` / `sched_core_put()` 控制全局核心调度使能状态。\n\n### 任务 Cookie 更新\n- 在 `task_rq_lock()` 保护下更新 `p->core_cookie`，确保调度器一致性。\n- 若任务已在运行队列中，先出队再根据新 cookie 决定是否重新入队。\n- 若任务正在 CPU 上运行，调用 `resched_curr()` 触发重调度，以确保新 cookie 策略立即生效。\n\n### 安全访问控制\n- 通过 `ptrace_may_access()` 检查调用者是否有权限操作目标进程的 cookie。\n- 仅当系统存在 SMT（超线程）时（`sched_smt_present` 为真），才允许使用核心调度功能。\n\n### prctl 接口支持\n- 支持四种命令：\n  - `PR_SCHED_CORE_CREATE`：创建新 cookie。\n  - `PR_SCHED_CORE_SHARE_TO`：将当前进程的 cookie 应用于目标进程（或进程组）。\n  - `PR_SCHED_CORE_SHARE_FROM`：将目标进程的 cookie 应用于当前进程。\n  - `PR_SCHED_CORE_GET`：获取目标进程的 cookie 哈希值（用于用户空间识别）。\n- 支持作用域：线程（`PIDTYPE_PID`）、线程组（`PIDTYPE_TGID`）、进程组（`PIDTYPE_PGID`）。\n\n### 强制空闲时间统计（`CONFIG_SCHEDSTATS`）\n- 当核心因 cookie 不兼容而进入强制空闲状态时，记录空闲时间。\n- 时间按 `core_forceidle_count / core_forceidle_occupation` 比例分摊到所有相关 CPU 上的非 idle 任务。\n- 通过 `__account_forceidle_time()` 更新任务的调度统计信息。\n\n## 4. 依赖关系\n\n- **调度器核心**：依赖 `kernel/sched/` 下的通用调度器基础设施，如 `task_rq_lock()`、`resched_curr()`、`rq` 结构等。\n- **SMT 检测**：依赖 `sched_smt_present` 静态分支判断系统是否支持超线程。\n- **内存管理**：使用 `kmalloc`/`kfree` 进行动态内存分配。\n- **进程管理**：依赖 `find_task_by_vpid()`、`tasklist_lock`、`do_each_pid_thread` 等进程遍历机制。\n- **安全机制**：依赖 `ptrace_may_access()` 进行权限检查。\n- **调度统计**：`__sched_core_account_forceidle` 依赖 `CONFIG_SCHEDSTATS` 和 `__account_forceidle_time`。\n\n## 5. 使用场景\n\n- **安全敏感应用**：如浏览器、虚拟机监控器（VMM）、加密服务等，需防止跨任务的侧信道攻击。\n- **用户空间控制**：通过 `prctl(PR_SCHED_CORE, ...)` 接口，应用程序可显式创建和共享调度 cookie，将信任的任务分组。\n- **进程 fork 行为**：子进程自动继承父进程的 cookie，确保同源任务保持调度兼容性。\n- **系统资源隔离**：在多租户或容器环境中，确保不同租户的任务不会在同一个物理核心上并发执行。\n- **性能调优与监控**：通过 `CONFIG_SCHEDSTATS` 收集核心强制空闲开销，评估安全策略对性能的影响。",
      "similarity": 0.6344527006149292,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 11,
          "end_line": 216,
          "content": [
            "static unsigned long sched_core_alloc_cookie(void)",
            "{",
            "\tstruct sched_core_cookie *ck = kmalloc(sizeof(*ck), GFP_KERNEL);",
            "\tif (!ck)",
            "\t\treturn 0;",
            "",
            "\trefcount_set(&ck->refcnt, 1);",
            "\tsched_core_get();",
            "",
            "\treturn (unsigned long)ck;",
            "}",
            "static void sched_core_put_cookie(unsigned long cookie)",
            "{",
            "\tstruct sched_core_cookie *ptr = (void *)cookie;",
            "",
            "\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {",
            "\t\tkfree(ptr);",
            "\t\tsched_core_put();",
            "\t}",
            "}",
            "static unsigned long sched_core_get_cookie(unsigned long cookie)",
            "{",
            "\tstruct sched_core_cookie *ptr = (void *)cookie;",
            "",
            "\tif (ptr)",
            "\t\trefcount_inc(&ptr->refcnt);",
            "",
            "\treturn cookie;",
            "}",
            "static unsigned long sched_core_update_cookie(struct task_struct *p,",
            "\t\t\t\t\t      unsigned long cookie)",
            "{",
            "\tunsigned long old_cookie;",
            "\tstruct rq_flags rf;",
            "\tstruct rq *rq;",
            "",
            "\trq = task_rq_lock(p, &rf);",
            "",
            "\t/*",
            "\t * Since creating a cookie implies sched_core_get(), and we cannot set",
            "\t * a cookie until after we've created it, similarly, we cannot destroy",
            "\t * a cookie until after we've removed it, we must have core scheduling",
            "\t * enabled here.",
            "\t */",
            "\tSCHED_WARN_ON((p->core_cookie || cookie) && !sched_core_enabled(rq));",
            "",
            "\tif (sched_core_enqueued(p))",
            "\t\tsched_core_dequeue(rq, p, DEQUEUE_SAVE);",
            "",
            "\told_cookie = p->core_cookie;",
            "\tp->core_cookie = cookie;",
            "",
            "\t/*",
            "\t * Consider the cases: !prev_cookie and !cookie.",
            "\t */",
            "\tif (cookie && task_on_rq_queued(p))",
            "\t\tsched_core_enqueue(rq, p);",
            "",
            "\t/*",
            "\t * If task is currently running, it may not be compatible anymore after",
            "\t * the cookie change, so enter the scheduler on its CPU to schedule it",
            "\t * away.",
            "\t *",
            "\t * Note that it is possible that as a result of this cookie change, the",
            "\t * core has now entered/left forced idle state. Defer accounting to the",
            "\t * next scheduling edge, rather than always forcing a reschedule here.",
            "\t */",
            "\tif (task_on_cpu(rq, p))",
            "\t\tresched_curr(rq);",
            "",
            "\ttask_rq_unlock(rq, p, &rf);",
            "",
            "\treturn old_cookie;",
            "}",
            "static unsigned long sched_core_clone_cookie(struct task_struct *p)",
            "{",
            "\tunsigned long cookie, flags;",
            "",
            "\traw_spin_lock_irqsave(&p->pi_lock, flags);",
            "\tcookie = sched_core_get_cookie(p->core_cookie);",
            "\traw_spin_unlock_irqrestore(&p->pi_lock, flags);",
            "",
            "\treturn cookie;",
            "}",
            "void sched_core_fork(struct task_struct *p)",
            "{",
            "\tRB_CLEAR_NODE(&p->core_node);",
            "\tp->core_cookie = sched_core_clone_cookie(current);",
            "}",
            "void sched_core_free(struct task_struct *p)",
            "{",
            "\tsched_core_put_cookie(p->core_cookie);",
            "}",
            "static void __sched_core_set(struct task_struct *p, unsigned long cookie)",
            "{",
            "\tcookie = sched_core_get_cookie(cookie);",
            "\tcookie = sched_core_update_cookie(p, cookie);",
            "\tsched_core_put_cookie(cookie);",
            "}",
            "int sched_core_share_pid(unsigned int cmd, pid_t pid, enum pid_type type,",
            "\t\t\t unsigned long uaddr)",
            "{",
            "\tunsigned long cookie = 0, id = 0;",
            "\tstruct task_struct *task, *p;",
            "\tstruct pid *grp;",
            "\tint err = 0;",
            "",
            "\tif (!static_branch_likely(&sched_smt_present))",
            "\t\treturn -ENODEV;",
            "",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD != PIDTYPE_PID);",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD_GROUP != PIDTYPE_TGID);",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_PROCESS_GROUP != PIDTYPE_PGID);",
            "",
            "\tif (type > PIDTYPE_PGID || cmd >= PR_SCHED_CORE_MAX || pid < 0 ||",
            "\t    (cmd != PR_SCHED_CORE_GET && uaddr))",
            "\t\treturn -EINVAL;",
            "",
            "\trcu_read_lock();",
            "\tif (pid == 0) {",
            "\t\ttask = current;",
            "\t} else {",
            "\t\ttask = find_task_by_vpid(pid);",
            "\t\tif (!task) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\treturn -ESRCH;",
            "\t\t}",
            "\t}",
            "\tget_task_struct(task);",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Check if this process has the right to modify the specified",
            "\t * process. Use the regular \"ptrace_may_access()\" checks.",
            "\t */",
            "\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\terr = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tswitch (cmd) {",
            "\tcase PR_SCHED_CORE_GET:",
            "\t\tif (type != PIDTYPE_PID || uaddr & 7) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tcookie = sched_core_clone_cookie(task);",
            "\t\tif (cookie) {",
            "\t\t\t/* XXX improve ? */",
            "\t\t\tptr_to_hashval((void *)cookie, &id);",
            "\t\t}",
            "\t\terr = put_user(id, (u64 __user *)uaddr);",
            "\t\tgoto out;",
            "",
            "\tcase PR_SCHED_CORE_CREATE:",
            "\t\tcookie = sched_core_alloc_cookie();",
            "\t\tif (!cookie) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase PR_SCHED_CORE_SHARE_TO:",
            "\t\tcookie = sched_core_clone_cookie(current);",
            "\t\tbreak;",
            "",
            "\tcase PR_SCHED_CORE_SHARE_FROM:",
            "\t\tif (type != PIDTYPE_PID) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tcookie = sched_core_clone_cookie(task);",
            "\t\t__sched_core_set(current, cookie);",
            "\t\tgoto out;",
            "",
            "\tdefault:",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (type == PIDTYPE_PID) {",
            "\t\t__sched_core_set(task, cookie);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tgrp = task_pid_type(task, type);",
            "",
            "\tdo_each_pid_thread(grp, type, p) {",
            "\t\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\t\terr = -EPERM;",
            "\t\t\tgoto out_tasklist;",
            "\t\t}",
            "\t} while_each_pid_thread(grp, type, p);",
            "",
            "\tdo_each_pid_thread(grp, type, p) {",
            "\t\t__sched_core_set(p, cookie);",
            "\t} while_each_pid_thread(grp, type, p);",
            "out_tasklist:",
            "\tread_unlock(&tasklist_lock);",
            "",
            "out:",
            "\tsched_core_put_cookie(cookie);",
            "\tput_task_struct(task);",
            "\treturn err;",
            "}"
          ],
          "function_name": "sched_core_alloc_cookie, sched_core_put_cookie, sched_core_get_cookie, sched_core_update_cookie, sched_core_clone_cookie, sched_core_fork, sched_core_free, __sched_core_set, sched_core_share_pid",
          "description": "实现了核心调度 cookie 的分配、释放、获取和更新机制，包含 cookie 分配/回收、任务核心绑定变更、进程克隆共享及核心调度策略控制等功能",
          "similarity": 0.6437729597091675
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 240,
          "end_line": 297,
          "content": [
            "void __sched_core_account_forceidle(struct rq *rq)",
            "{",
            "\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));",
            "\tu64 delta, now = rq_clock(rq->core);",
            "\tstruct rq *rq_i;",
            "\tstruct task_struct *p;",
            "\tint i;",
            "",
            "\tlockdep_assert_rq_held(rq);",
            "",
            "\tWARN_ON_ONCE(!rq->core->core_forceidle_count);",
            "",
            "\tif (rq->core->core_forceidle_start == 0)",
            "\t\treturn;",
            "",
            "\tdelta = now - rq->core->core_forceidle_start;",
            "\tif (unlikely((s64)delta <= 0))",
            "\t\treturn;",
            "",
            "\trq->core->core_forceidle_start = now;",
            "",
            "\tif (WARN_ON_ONCE(!rq->core->core_forceidle_occupation)) {",
            "\t\t/* can't be forced idle without a running task */",
            "\t} else if (rq->core->core_forceidle_count > 1 ||",
            "\t\t   rq->core->core_forceidle_occupation > 1) {",
            "\t\t/*",
            "\t\t * For larger SMT configurations, we need to scale the charged",
            "\t\t * forced idle amount since there can be more than one forced",
            "\t\t * idle sibling and more than one running cookied task.",
            "\t\t */",
            "\t\tdelta *= rq->core->core_forceidle_count;",
            "\t\tdelta = div_u64(delta, rq->core->core_forceidle_occupation);",
            "\t}",
            "",
            "\tfor_each_cpu(i, smt_mask) {",
            "\t\trq_i = cpu_rq(i);",
            "\t\tp = rq_i->core_pick ?: rq_i->curr;",
            "",
            "\t\tif (p == rq_i->idle)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Note: this will account forceidle to the current cpu, even",
            "\t\t * if it comes from our SMT sibling.",
            "\t\t */",
            "\t\t__account_forceidle_time(p, delta);",
            "\t}",
            "}",
            "void __sched_core_tick(struct rq *rq)",
            "{",
            "\tif (!rq->core->core_forceidle_count)",
            "\t\treturn;",
            "",
            "\tif (rq != rq->core)",
            "\t\tupdate_rq_clock(rq->core);",
            "",
            "\t__sched_core_account_forceidle(rq);",
            "}"
          ],
          "function_name": "__sched_core_account_forceidle, __sched_core_tick",
          "description": "提供强制空闲时间统计功能，通过遍历 SMT 核心计算并分摊强制空闲时间消耗，tick 中断触发强制空闲会计入逻辑",
          "similarity": 0.5216597318649292
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 1,
          "end_line": 10,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "/*",
            " * A simple wrapper around refcount. An allocated sched_core_cookie's",
            " * address is used to compute the cookie of the task.",
            " */",
            "struct sched_core_cookie {",
            "\trefcount_t refcnt;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了 sched_core_cookie 结构体，用于核心调度系统中管理任务的 cookie 引用计数，通过结构体地址计算 cookie 值",
          "similarity": 0.4924463927745819
        }
      ]
    },
    {
      "source_file": "kernel/sched/stop_task.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:17:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\stop_task.c`\n\n---\n\n# `sched/stop_task.c` 技术文档\n\n## 1. 文件概述\n\n`sched/stop_task.c` 实现了 Linux 内核调度器中的 **stop 调度类（stop scheduling class）**。该调度类用于管理 per-CPU 的 **stop 任务（stop task）**，这些任务具有系统中最高的调度优先级，能够抢占所有其他任务，且自身不会被任何任务抢占。stop 任务主要用于需要在所有 CPU 上立即停止常规调度活动的场景，例如 CPU 热插拔、内核模块卸载或 `stop_machine()` 机制执行期间。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `select_task_rq_stop()`：在 SMP 系统中，确保 stop 任务始终运行在其初始 CPU 上，禁止迁移。\n- `balance_stop()`：在负载均衡时判断当前运行队列上是否有可运行的 stop 任务。\n- `wakeup_preempt_stop()`：空实现，因为 stop 任务不会被抢占。\n- `set_next_task_stop()`：设置下一个运行的 stop 任务，并记录其执行起始时间。\n- `pick_task_stop()`：从运行队列中选择 stop 任务（如果存在且可运行）。\n- `enqueue_task_stop()` / `dequeue_task_stop()`：将 stop 任务加入/移出运行队列，并更新运行任务计数。\n- `yield_task_stop()`：触发 `BUG()`，因为 stop 任务绝不应主动让出 CPU。\n- `put_prev_task_stop()`：在切换出 stop 任务时更新其运行统计（调用通用更新函数）。\n- `task_tick_stop()`：空实现，stop 任务不受调度 tick 影响。\n- `switched_to_stop()` / `prio_changed_stop()`：均触发 `BUG()`，因为任务不能动态切换到 stop 调度类，也无优先级概念。\n- `update_curr_stop()`：空实现，stop 任务不参与常规的运行时间更新逻辑。\n\n### 数据结构\n\n- `DEFINE_SCHED_CLASS(stop)`：定义并初始化名为 `stop` 的调度类实例，实现了 `struct sched_class` 接口的所有必要回调函数。\n\n## 3. 关键实现\n\n- **最高优先级保证**：stop 调度类在调度类层级中位于最顶端（高于 `rt`、`fair`、`idle`），确保其任务总是优先获得 CPU。\n- **禁止迁移**：在 `CONFIG_SMP` 下，`select_task_rq_stop()` 强制 stop 任务绑定到其创建时的 CPU，防止跨 CPU 迁移，保证操作的局部性和确定性。\n- **无抢占逻辑**：所有与抢占相关的函数（如 `wakeup_preempt_stop`）均为空或触发错误，因为 stop 任务运行期间系统处于“停止”状态，不应被中断。\n- **错误防护机制**：任何试图动态切换到 stop 调度类、修改其优先级或主动让出 CPU 的行为都会触发 `BUG()`，防止误用。\n- **轻量级统计**：虽然调用 `update_curr_common()` 更新运行时间，但 `update_curr_stop()` 本身为空，表明 stop 任务不参与复杂的调度实体（`sched_entity`）时间计算。\n- **与 `stop_machine` 协同**：该文件与 `kernel/stop_machine.c` 紧密配合，为 `stop_machine()` 提供底层调度支持，确保在所有 CPU 上同步执行关键操作。\n\n## 4. 依赖关系\n\n- **调度核心**：依赖 `kernel/sched/core.c` 中定义的调度类框架、运行队列（`rq`）结构和通用辅助函数（如 `add_nr_running`、`update_curr_common`）。\n- **SMP 支持**：在 `CONFIG_SMP` 编译选项下，依赖 `kernel/sched/sched.h` 中的 `set_cpus_allowed_common` 函数。\n- **Stop Machine 机制**：与 `kernel/stop_machine.c` 深度集成，后者负责创建和管理 per-CPU stop 任务，并触发其执行。\n- **时间子系统**：使用 `rq_clock_task()` 获取任务执行时间戳，依赖内核时间管理基础设施。\n\n## 5. 使用场景\n\n- **`stop_machine()` 执行**：当内核需要在所有在线 CPU 上同步执行一段不能被中断的代码时（如修改全局数据结构、CPU 热插拔），会激活所有 CPU 的 stop 任务。\n- **CPU 热插拔**：在 CPU 上线或下线过程中，使用 stop 任务确保目标 CPU 处于可控状态，避免调度干扰。\n- **内核关键路径保护**：在极少数需要完全禁止调度器干预的内核关键操作中，临时启用 stop 任务以获得独占 CPU 的能力。\n- **调试与诊断**：某些内核调试机制可能利用 stop 任务来冻结系统状态进行分析。",
      "similarity": 0.6236129999160767,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 12,
          "end_line": 64,
          "content": [
            "static int",
            "select_task_rq_stop(struct task_struct *p, int cpu, int flags)",
            "{",
            "\treturn task_cpu(p); /* stop tasks as never migrate */",
            "}",
            "static int",
            "balance_stop(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)",
            "{",
            "\treturn sched_stop_runnable(rq);",
            "}",
            "static void",
            "wakeup_preempt_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\t/* we're never preempted */",
            "}",
            "static void set_next_task_stop(struct rq *rq, struct task_struct *stop, bool first)",
            "{",
            "\tstop->se.exec_start = rq_clock_task(rq);",
            "}",
            "static void",
            "enqueue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tadd_nr_running(rq, 1);",
            "}",
            "static bool",
            "dequeue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tsub_nr_running(rq, 1);",
            "\treturn true;",
            "}",
            "static void yield_task_stop(struct rq *rq)",
            "{",
            "\tBUG(); /* the stop task should never yield, its pointless. */",
            "}",
            "static void put_prev_task_stop(struct rq *rq, struct task_struct *prev, struct task_struct *next)",
            "{",
            "\tupdate_curr_common(rq);",
            "}",
            "static void task_tick_stop(struct rq *rq, struct task_struct *curr, int queued)",
            "{",
            "}",
            "static void switched_to_stop(struct rq *rq, struct task_struct *p)",
            "{",
            "\tBUG(); /* its impossible to change to this class */",
            "}",
            "static void",
            "prio_changed_stop(struct rq *rq, struct task_struct *p, int oldprio)",
            "{",
            "\tBUG(); /* how!?, what priority? */",
            "}",
            "static void update_curr_stop(struct rq *rq)",
            "{",
            "}"
          ],
          "function_name": "select_task_rq_stop, balance_stop, wakeup_preempt_stop, set_next_task_stop, enqueue_task_stop, dequeue_task_stop, yield_task_stop, put_prev_task_stop, task_tick_stop, switched_to_stop, prio_changed_stop, update_curr_stop",
          "description": "实现stop任务调度类的核心操作，包括CPU选择、负载均衡、抢占唤醒、任务添加删除、时间统计更新等，强制禁止任务迁移和抢占以保证系统中断处理优先级",
          "similarity": 0.654525637626648
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * stop-task scheduling class.",
            " *",
            " * The stop task is the highest priority task in the system, it preempts",
            " * everything and will be preempted by nothing.",
            " *",
            " * See kernel/stop_machine.c",
            " */",
            "",
            "#ifdef CONFIG_SMP"
          ],
          "function_name": null,
          "description": "定义stop任务调度类的框架，启用SMP配置时提供最高优先级调度策略，通过禁用任务迁移和抢占实现系统级中断控制",
          "similarity": 0.6066009998321533
        }
      ]
    }
  ]
}