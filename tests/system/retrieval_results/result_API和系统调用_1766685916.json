{
  "query": "API和系统调用",
  "timestamp": "2025-12-26 02:05:16",
  "retrieved_files": [
    {
      "source_file": "kernel/entry/common.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:19:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\common.c`\n\n---\n\n# entry\\common.c 技术文档\n\n## 文件概述\n\n`entry\\common.c` 是 Linux 内核中处理系统调用入口/出口以及中断入口/出口路径的通用逻辑实现文件。该文件提供了一套架构无关的通用函数，用于在用户态与内核态之间切换时执行必要的上下文跟踪、审计、跟踪点、安全检查（如 seccomp）、信号处理、调度等工作。其目标是统一不同架构在系统调用和中断处理路径上的共性逻辑，减少重复代码。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `syscall_trace_enter()` | 系统调用进入时的通用处理函数，依次处理用户态分发、ptrace 跟踪、seccomp 安全检查、tracepoint 和审计 |\n| `syscall_enter_from_user_mode_prepare()` | 从用户模式进入系统调用前的准备，启用中断并进入内核上下文 |\n| `exit_to_user_mode_loop()` | 在返回用户空间前循环处理所有待办工作项（如调度、信号、uprobe、livepatch 等） |\n| `syscall_exit_work()` | 系统调用退出时的通用处理，包括审计、tracepoint、ptrace 退出报告等 |\n| `irqentry_enter()` / `irqentry_exit()` | 中断入口/出口的通用处理，管理 RCU、上下文跟踪、KMSAN、lockdep 等 |\n| `irqentry_enter_from_user_mode()` / `irqentry_exit_to_user_mode()` | 从中断上下文进入/退出用户模式的专用路径 |\n| `raw_irqentry_exit_cond_resched()` | 中断退出时的条件调度检查（仅在非抢占计数为 0 时） |\n\n### 关键数据结构\n\n- `irqentry_state_t`：记录中断入口状态，主要用于判断是否需要在退出时执行 RCU 相关操作。\n- `SYSCALL_WORK_*` 和 `_TIF_*` 标志位：用于标识待处理的工作类型（如 trace、seccomp、信号、调度等）。\n\n## 关键实现\n\n### 系统调用入口处理流程（`syscall_trace_enter`）\n\n1. **Syscall User Dispatch 优先处理**：若设置了 `SYSCALL_WORK_SYSCALL_USER_DISPATCH`，调用 `syscall_user_dispatch()`，若返回 true 则直接终止系统调用（返回 `-1`），因为此时 ABI 可能无效。\n2. **Ptrace 跟踪**：若设置了 `SYSCALL_WORK_SYSCALL_TRACE` 或 `SYSCALL_WORK_SYSCALL_EMU`，调用 `ptrace_report_syscall_entry()`。若 tracer 修改了行为或启用了 `SYSCALL_EMU`，则终止系统调用。\n3. **Seccomp 安全检查**：在 ptrace 之后执行，以捕获 tracer 可能引入的变更。调用 `__secure_computing()`，若返回 `-1` 则拒绝系统调用。\n4. **重新获取系统调用号**：上述步骤可能修改了系统调用号，需重新通过 `syscall_get_nr()` 获取。\n5. **Tracepoint 触发**：若启用 `SYSCALL_WORK_SYSCALL_TRACEPOINT`，触发 `trace_sys_enter`，并再次重新获取系统调用号（因 BPF 或 kprobe 可能修改）。\n6. **审计日志**：调用 `syscall_enter_audit()` 记录审计事件。\n7. **返回最终系统调用号或错误码**。\n\n### 返回用户空间前的工作循环（`exit_to_user_mode_loop`）\n\n- 使用 `while (ti_work & EXIT_TO_USER_MODE_WORK)` 循环处理所有待办工作，确保在返回用户态前完成：\n  - 调度（`_TIF_NEED_RESCHED`）\n  - Uprobe 通知（`_TIF_UPROBE`）\n  - Livepatch 状态更新（`_TIF_PATCH_PENDING`）\n  - 信号处理（`_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL`）\n  - 用户态恢复工作（`_TIF_NOTIFY_RESUME`）\n  - 架构特定工作（`arch_exit_to_user_mode_work`）\n- 每次循环启用中断（`local_irq_enable_exit_to_user`），处理完后再关闭中断并重新读取线程标志（`read_thread_flags()`），以应对处理过程中新产生的工作项。\n- 最后调用 `tick_nohz_user_enter_prepare()` 处理 NO_HZ 模式下的 tick 准备。\n\n### 中断入口/出口的 RCU 与上下文管理\n\n- **从中断进入用户态**：调用 `enter_from_user_mode()`，启用中断。\n- **从内核态中断入口**：\n  - 若当前是 idle 任务且非 `TINY_RCU`，无条件调用 `ct_irq_enter()` 以确保 RCU 状态一致（避免嵌套中断导致 grace period 错误结束）。\n  - 否则调用 `rcu_irq_enter_check_tick()`。\n- 所有路径均正确处理 `lockdep`、`KMSAN`（解除寄存器毒化）和 `trace_hardirqs_off` 的顺序，确保调试和安全工具正常工作。\n\n### 条件调度支持（Preemption）\n\n- `raw_irqentry_exit_cond_resched()` 在中断退出且 `preempt_count() == 0` 时检查是否需要调度。\n- 支持动态抢占（`CONFIG_PREEMPT_DYNAMIC`），通过 `static_call` 或 `static_key` 实现运行时切换，避免编译时硬编码。\n\n## 依赖关系\n\n### 头文件依赖\n- `<linux/context_tracking.h>`：上下文跟踪（用户/内核态切换）\n- `<linux/resume_user_mode.h>`：用户态恢复工作\n- `<linux/seccomp.h>`（隐式通过 `__secure_computing`）：系统调用过滤\n- `<linux/audit.h>`：审计子系统\n- `<linux/ptrace.h>`（隐式）：ptrace 跟踪\n- `<linux/livepatch.h>`：内核热补丁\n- `<linux/uprobes.h>`（隐式）：用户态探针\n- `<linux/rcupdate.h>`：RCU 机制\n- `<linux/kmsan.h>`：Kernel Memory Sanitizer 支持\n- `<trace/events/syscalls.h>`：系统调用跟踪点\n\n### 架构依赖\n- 依赖架构特定实现：\n  - `syscall_get_arguments()` / `syscall_get_nr()` / `syscall_get_return_value()`\n  - `user_mode()` / `regs_irqs_disabled()`\n  - `arch_do_signal_or_restart()`（弱符号，默认空实现）\n  - `arch_exit_to_user_mode_work()`\n\n### 子系统交互\n- **RCU**：管理中断和用户态切换时的宽限期\n- **Scheduler**：处理 `need_resched()` 和 `schedule()`\n- **Security**：seccomp、audit\n- **Tracing**：ftrace、kprobe、uprobe、BPF\n- **Livepatch**：动态补丁状态更新\n\n## 使用场景\n\n1. **系统调用入口路径**：  \n   当用户程序执行 `syscall` 指令（或其他系统调用机制）进入内核时，架构代码调用 `syscall_trace_enter()` 执行通用预处理。\n\n2. **系统调用出口路径**：  \n   系统调用返回前，若存在待处理工作（如审计、tracepoint），调用 `syscall_exit_work()`。\n\n3. **中断处理返回用户空间**：  \n   中断处理完成后，若返回用户态，调用 `irqentry_exit_to_user_mode()`，进而触发 `exit_to_user_mode_loop()` 处理所有 pending work。\n\n4. **中断嵌套与 idle 任务处理**：  \n   在 idle 任务中发生中断时，确保 RCU 正确进入 IRQ 上下文，防止 grace period 错误终止。\n\n5. **动态抢占支持**：  \n   在支持动态抢占的系统中，中断退出时根据运行时配置决定是否执行条件调度。\n\n6. **调试与安全工具集成**：  \n   为 KMSAN、Lockdep、ftrace、audit、seccomp 等子系统提供统一的入口/出口钩子，确保工具链在系统调用和中断路径上正常工作。",
      "similarity": 0.6016270518302917,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/common.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/context_tracking.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/highmem.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmsan.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/audit.h>",
            "#include <linux/tick.h>",
            "",
            "#include \"common.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/syscalls.h>",
            ""
          ],
          "function_name": null,
          "description": "声明系统调用通用功能所需头文件，包含审计、跟踪、KMSAN、LivePatch等模块的接口定义，为后续系统调用入口处理提供基础依赖",
          "similarity": 0.6187151670455933
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/common.c",
          "start_line": 18,
          "end_line": 124,
          "content": [
            "static inline void syscall_enter_audit(struct pt_regs *regs, long syscall)",
            "{",
            "\tif (unlikely(audit_context())) {",
            "\t\tunsigned long args[6];",
            "",
            "\t\tsyscall_get_arguments(current, regs, args);",
            "\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);",
            "\t}",
            "}",
            "long syscall_trace_enter(struct pt_regs *regs, long syscall,",
            "\t\t\t\tunsigned long work)",
            "{",
            "\tlong ret = 0;",
            "",
            "\t/*",
            "\t * Handle Syscall User Dispatch.  This must comes first, since",
            "\t * the ABI here can be something that doesn't make sense for",
            "\t * other syscall_work features.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (syscall_user_dispatch(regs))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Handle ptrace */",
            "\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {",
            "\t\tret = ptrace_report_syscall_entry(regs);",
            "\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Do seccomp after ptrace, to catch any tracer changes. */",
            "\tif (work & SYSCALL_WORK_SECCOMP) {",
            "\t\tret = __secure_computing(NULL);",
            "\t\tif (ret == -1L)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/* Either of the above might have changed the syscall number */",
            "\tsyscall = syscall_get_nr(current, regs);",
            "",
            "\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT)) {",
            "\t\ttrace_sys_enter(regs, syscall);",
            "\t\t/*",
            "\t\t * Probes or BPF hooks in the tracepoint may have changed the",
            "\t\t * system call number as well.",
            "\t\t */",
            "\t\tsyscall = syscall_get_nr(current, regs);",
            "\t}",
            "",
            "\tsyscall_enter_audit(regs, syscall);",
            "",
            "\treturn ret ? : syscall;",
            "}",
            "noinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "\tinstrumentation_begin();",
            "\tlocal_irq_enable();",
            "\tinstrumentation_end();",
            "}",
            "void __weak arch_do_signal_or_restart(struct pt_regs *regs) { }",
            "__always_inline unsigned long exit_to_user_mode_loop(struct pt_regs *regs,",
            "\t\t\t\t\t\t     unsigned long ti_work)",
            "{",
            "\t/*",
            "\t * Before returning to user space ensure that all pending work",
            "\t * items have been completed.",
            "\t */",
            "\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {",
            "",
            "\t\tlocal_irq_enable_exit_to_user(ti_work);",
            "",
            "\t\tif (ti_work & _TIF_NEED_RESCHED)",
            "\t\t\tschedule();",
            "",
            "\t\tif (ti_work & _TIF_UPROBE)",
            "\t\t\tuprobe_notify_resume(regs);",
            "",
            "\t\tif (ti_work & _TIF_PATCH_PENDING)",
            "\t\t\tklp_update_patch_state(current);",
            "",
            "\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))",
            "\t\t\tarch_do_signal_or_restart(regs);",
            "",
            "\t\tif (ti_work & _TIF_NOTIFY_RESUME)",
            "\t\t\tresume_user_mode_work(regs);",
            "",
            "\t\t/* Architecture specific TIF work */",
            "\t\tarch_exit_to_user_mode_work(regs, ti_work);",
            "",
            "\t\t/*",
            "\t\t * Disable interrupts and reevaluate the work flags as they",
            "\t\t * might have changed while interrupts and preemption was",
            "\t\t * enabled above.",
            "\t\t */",
            "\t\tlocal_irq_disable_exit_to_user();",
            "",
            "\t\t/* Check if any of the above work has queued a deferred wakeup */",
            "\t\ttick_nohz_user_enter_prepare();",
            "",
            "\t\tti_work = read_thread_flags();",
            "\t}",
            "",
            "\t/* Return the latest work state for arch_exit_to_user_mode() */",
            "\treturn ti_work;",
            "}"
          ],
          "function_name": "syscall_enter_audit, syscall_trace_enter, syscall_enter_from_user_mode_prepare, arch_do_signal_or_restart, exit_to_user_mode_loop",
          "description": "实现系统调用入口处理逻辑，依次处理审计追踪、指针观察、seccomp过滤及架构特定工作，通过位掩码控制不同安全机制的触发顺序并更新系统调用号",
          "similarity": 0.6136586666107178
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/common.c",
          "start_line": 141,
          "end_line": 250,
          "content": [
            "static inline bool report_single_step(unsigned long work)",
            "{",
            "\tif (work & SYSCALL_WORK_SYSCALL_EMU)",
            "\t\treturn false;",
            "",
            "\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;",
            "}",
            "void syscall_exit_work(struct pt_regs *regs, unsigned long work)",
            "{",
            "\tbool step;",
            "",
            "\t/*",
            "\t * If the syscall was rolled back due to syscall user dispatching,",
            "\t * then the tracers below are not invoked for the same reason as",
            "\t * the entry side was not invoked in syscall_trace_enter(): The ABI",
            "\t * of these syscalls is unknown.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {",
            "\t\t\tcurrent->syscall_dispatch.on_dispatch = false;",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\taudit_syscall_exit(regs);",
            "",
            "\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)",
            "\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));",
            "",
            "\tstep = report_single_step(work);",
            "\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)",
            "\t\tptrace_report_syscall_exit(regs, step);",
            "}",
            "noinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "}",
            "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)",
            "{",
            "\tinstrumentation_begin();",
            "\texit_to_user_mode_prepare(regs);",
            "\tinstrumentation_end();",
            "\texit_to_user_mode();",
            "}",
            "noinstr irqentry_state_t irqentry_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t ret = {",
            "\t\t.exit_rcu = false,",
            "\t};",
            "",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_enter_from_user_mode(regs);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If this entry hit the idle task invoke ct_irq_enter() whether",
            "\t * RCU is watching or not.",
            "\t *",
            "\t * Interrupts can nest when the first interrupt invokes softirq",
            "\t * processing on return which enables interrupts.",
            "\t *",
            "\t * Scheduler ticks in the idle task can mark quiescent state and",
            "\t * terminate a grace period, if and only if the timer interrupt is",
            "\t * not nested into another interrupt.",
            "\t *",
            "\t * Checking for rcu_is_watching() here would prevent the nesting",
            "\t * interrupt to invoke ct_irq_enter(). If that nested interrupt is",
            "\t * the tick then rcu_flavor_sched_clock_irq() would wrongfully",
            "\t * assume that it is the first interrupt and eventually claim",
            "\t * quiescent state and end grace periods prematurely.",
            "\t *",
            "\t * Unconditionally invoke ct_irq_enter() so RCU state stays",
            "\t * consistent.",
            "\t *",
            "\t * TINY_RCU does not support EQS, so let the compiler eliminate",
            "\t * this part when enabled.",
            "\t */",
            "\tif (!IS_ENABLED(CONFIG_TINY_RCU) && is_idle_task(current)) {",
            "\t\t/*",
            "\t\t * If RCU is not watching then the same careful",
            "\t\t * sequence vs. lockdep and tracing is required",
            "\t\t * as in irqentry_enter_from_user_mode().",
            "\t\t */",
            "\t\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\t\tct_irq_enter();",
            "\t\tinstrumentation_begin();",
            "\t\tkmsan_unpoison_entry_regs(regs);",
            "\t\ttrace_hardirqs_off_finish();",
            "\t\tinstrumentation_end();",
            "",
            "\t\tret.exit_rcu = true;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If RCU is watching then RCU only wants to check whether it needs",
            "\t * to restart the tick in NOHZ mode. rcu_irq_enter_check_tick()",
            "\t * already contains a warning when RCU is not watching, so no point",
            "\t * in having another one here.",
            "\t */",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\trcu_irq_enter_check_tick();",
            "\ttrace_hardirqs_off_finish();",
            "\tinstrumentation_end();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "report_single_step, syscall_exit_work, irqentry_enter_from_user_mode, irqentry_exit_to_user_mode, irqentry_enter",
          "description": "处理系统调用退出阶段工作，包括审计退出记录、单步调试报告和跟踪点事件，同时管理中断返回时的RCU状态转换和锁依赖检查",
          "similarity": 0.56116783618927
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/entry/common.c",
          "start_line": 256,
          "end_line": 347,
          "content": [
            "void raw_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!preempt_count()) {",
            "\t\t/* Sanity check RCU and thread stack */",
            "\t\trcu_irq_exit_check_preempt();",
            "\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))",
            "\t\t\tWARN_ON_ONCE(!on_thread_stack());",
            "\t\tif (need_resched())",
            "\t\t\tpreempt_schedule_irq();",
            "\t}",
            "}",
            "void dynamic_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!static_branch_unlikely(&sk_dynamic_irqentry_exit_cond_resched))",
            "\t\treturn;",
            "\traw_irqentry_exit_cond_resched();",
            "}",
            "noinstr void irqentry_exit(struct pt_regs *regs, irqentry_state_t state)",
            "{",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\t/* Check whether this returns to user mode */",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_exit_to_user_mode(regs);",
            "\t} else if (!regs_irqs_disabled(regs)) {",
            "\t\t/*",
            "\t\t * If RCU was not watching on entry this needs to be done",
            "\t\t * carefully and needs the same ordering of lockdep/tracing",
            "\t\t * and RCU as the return to user mode path.",
            "\t\t */",
            "\t\tif (state.exit_rcu) {",
            "\t\t\tinstrumentation_begin();",
            "\t\t\t/* Tell the tracer that IRET will enable interrupts */",
            "\t\t\ttrace_hardirqs_on_prepare();",
            "\t\t\tlockdep_hardirqs_on_prepare();",
            "\t\t\tinstrumentation_end();",
            "\t\t\tct_irq_exit();",
            "\t\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tinstrumentation_begin();",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPTION))",
            "\t\t\tirqentry_exit_cond_resched();",
            "",
            "\t\t/* Covers both tracing and lockdep */",
            "\t\ttrace_hardirqs_on();",
            "\t\tinstrumentation_end();",
            "\t} else {",
            "\t\t/*",
            "\t\t * IRQ flags state is correct already. Just tell RCU if it",
            "\t\t * was not watching on entry.",
            "\t\t */",
            "\t\tif (state.exit_rcu)",
            "\t\t\tct_irq_exit();",
            "\t}",
            "}",
            "irqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t irq_state;",
            "",
            "\tirq_state.lockdep = lockdep_hardirqs_enabled();",
            "",
            "\t__nmi_enter();",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tlockdep_hardirq_enter();",
            "\tct_nmi_enter();",
            "",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\ttrace_hardirqs_off_finish();",
            "\tftrace_nmi_enter();",
            "\tinstrumentation_end();",
            "",
            "\treturn irq_state;",
            "}",
            "void noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state)",
            "{",
            "\tinstrumentation_begin();",
            "\tftrace_nmi_exit();",
            "\tif (irq_state.lockdep) {",
            "\t\ttrace_hardirqs_on_prepare();",
            "\t\tlockdep_hardirqs_on_prepare();",
            "\t}",
            "\tinstrumentation_end();",
            "",
            "\tct_nmi_exit();",
            "\tlockdep_hardirq_exit();",
            "\tif (irq_state.lockdep)",
            "\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t__nmi_exit();",
            "}"
          ],
          "function_name": "raw_irqentry_exit_cond_resched, dynamic_irqentry_exit_cond_resched, irqentry_exit, irqentry_nmi_enter, irqentry_nmi_exit",
          "description": "实现中断退出路径的条件调度检查和NMI上下文切换，维护中断标志状态一致性，处理RCU状态转换、锁依赖标记恢复及异常中断返回时的上下文还原",
          "similarity": 0.559529185295105
        }
      ]
    },
    {
      "source_file": "kernel/entry/syscall_user_dispatch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:20:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\syscall_user_dispatch.c`\n\n---\n\n# entry/syscall_user_dispatch.c 技术文档\n\n## 1. 文件概述\n\n`entry/syscall_user_dispatch.c` 实现了 **系统调用用户分发（Syscall User Dispatch, SUD）** 机制，该机制允许用户空间程序通过 `prctl()` 系统调用配置一个“选择器”（selector），用于在特定条件下拦截或允许系统调用的执行。当系统调用指令指针位于指定区域之外且选择器状态为“阻塞”时，内核会回滚该系统调用并向进程发送 `SIGSYS` 信号，从而实现对系统调用的细粒度控制。此功能常用于沙箱、安全监控或调试场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trigger_sigsys(struct pt_regs *regs)`  \n  构造并强制发送 `SIGSYS` 信号，携带被拦截系统调用的详细信息（如地址、系统调用号、架构等）。\n\n- `syscall_user_dispatch(struct pt_regs *regs)`  \n  系统调用入口处的分发判断逻辑。根据当前指令指针位置和用户选择器状态决定是否拦截系统调用。\n\n- `task_set_syscall_user_dispatch(struct task_struct *task, ...)`  \n  为指定任务设置系统调用用户分发配置（开启/关闭、偏移、长度、选择器地址）。\n\n- `set_syscall_user_dispatch(...)`  \n  为当前任务设置系统调用用户分发配置的封装接口，供 `prctl()` 调用。\n\n- `syscall_user_dispatch_get_config(...)`  \n  通过 `ptrace` 获取指定任务的 SUD 配置。\n\n- `syscall_user_dispatch_set_config(...)`  \n  通过 `ptrace` 设置指定任务的 SUD 配置。\n\n### 关键数据结构\n\n- `struct syscall_user_dispatch`（定义在 `<linux/syscall_user_dispatch.h>`）  \n  存储每个任务的 SUD 配置：\n  - `selector`：指向用户空间选择器字节的指针\n  - `offset` / `len`：允许直接执行系统调用的代码区域（[offset, offset+len)）\n  - `on_dispatch`：标志位，表示当前是否处于分发拦截状态\n\n- `struct ptrace_sud_config`  \n  用于 `ptrace` 接口传递 SUD 配置的结构体，包含 `mode`、`offset`、`len` 和 `selector`。\n\n## 3. 关键实现\n\n### 系统调用拦截逻辑\n\n1. **区域检查**：若当前指令指针（`instruction_pointer(regs)`）落在 `[offset, offset + len)` 范围内，则**允许**系统调用直接执行，不进行拦截。\n2. **vdso 例外**：若系统调用来自 vDSO 中的 `sigreturn`（如 `arch_syscall_is_vdso_sigreturn()` 返回 true），则跳过拦截，避免干扰信号返回路径。\n3. **选择器读取**：若配置了 `selector`，则从用户空间读取一个字节的状态值：\n   - `SYSCALL_DISPATCH_FILTER_ALLOW`（0）：允许系统调用\n   - `SYSCALL_DISPATCH_FILTER_BLOCK`（1）：触发拦截\n   - 其他值：视为非法，发送 `SIGSYS`\n4. **拦截处理**：\n   - 设置 `on_dispatch = true`\n   - 调用 `syscall_rollback()` 回滚系统调用（恢复寄存器状态）\n   - 调用 `trigger_sigsys()` 发送 `SIGSYS` 信号\n\n### 安全与健壮性设计\n\n- **地址合法性校验**：在设置 `selector` 时使用 `access_ok(untagged_addr(selector), ...)`，确保地址可访问，并处理内存标记（如 ARM MTE）场景下调试器（tracer）与被调试进程（tracee）地址标记不一致的问题。\n- **溢出防护**：检查 `offset + len <= offset` 防止整数溢出导致无效区域。\n- **权限隔离**：`ptrace` 接口允许调试器配置其他进程的 SUD，但需具备相应权限。\n\n### 信号信息构造\n\n`trigger_sigsys()` 构造的 `siginfo_t` 包含：\n- `si_signo = SIGSYS`\n- `si_code = SYS_USER_DISPATCH`\n- `si_call_addr`：触发系统调用的用户空间地址\n- `si_syscall`：系统调用号\n- `si_arch`：系统调用架构（如 x86_64、AArch64）\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/prctl.h>`：定义 `PR_SYS_DISPATCH_*` 常量\n  - `<linux/syscall_user_dispatch.h>`：定义 `struct syscall_user_dispatch` 和相关常量\n  - `<asm/syscall.h>`：提供 `syscall_get_arch()`、`syscall_get_nr()` 等架构相关接口\n  - `\"common.h\"`：可能包含内核入口通用辅助函数\n- **内核子系统**：\n  - **调度器（sched）**：访问 `current` 任务结构\n  - **信号子系统（signal）**：发送 `SIGSYS` 信号\n  - **内存管理（uaccess）**：用户空间内存访问（`__get_user`, `access_ok`）\n  - **ptrace**：支持调试器配置 SUD\n  - **ELF**：可能用于架构识别（间接依赖）\n\n## 5. 使用场景\n\n- **沙箱环境**：限制应用只能在特定代码段发起系统调用，防止恶意代码绕过安全策略。\n- **动态二进制插桩（DBI）**：工具（如 Valgrind、Intel Pin）可拦截系统调用进行分析或重定向。\n- **安全监控**：监控程序可配置选择器为“阻塞”，在 `SIGSYS` 信号处理程序中记录或审查系统调用。\n- **调试与测试**：通过 `ptrace` 动态启用/禁用 SUD，用于测试系统调用拦截逻辑。\n- **W^X 策略增强**：结合代码段只读与 SUD，确保只有可信代码路径可发起系统调用。",
      "similarity": 0.5823736190795898,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 127,
          "end_line": 163,
          "content": [
            "int syscall_user_dispatch_get_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &task->syscall_dispatch;",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (test_task_syscall_work(task, SYSCALL_USER_DISPATCH))",
            "\t\tcfg.mode = PR_SYS_DISPATCH_ON;",
            "\telse",
            "\t\tcfg.mode = PR_SYS_DISPATCH_OFF;",
            "",
            "\tcfg.offset = sd->offset;",
            "\tcfg.len = sd->len;",
            "\tcfg.selector = (__u64)(uintptr_t)sd->selector;",
            "",
            "\tif (copy_to_user(data, &cfg, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn 0;",
            "}",
            "int syscall_user_dispatch_set_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (copy_from_user(&cfg, data, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn task_set_syscall_user_dispatch(task, cfg.mode, cfg.offset, cfg.len,",
            "\t\t\t\t\t      (char __user *)(uintptr_t)cfg.selector);",
            "}"
          ],
          "function_name": "syscall_user_dispatch_get_config, syscall_user_dispatch_set_config",
          "description": "提供系统调用分发配置的获取与设置接口，通过用户态指针操作实现配置参数的双向传递",
          "similarity": 0.6276156902313232
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2020 Collabora Ltd.",
            " */",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/signal.h>",
            "#include <linux/elf.h>",
            "",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task_stack.h>",
            "",
            "#include <asm/syscall.h>",
            "",
            "#include \"common.h\"",
            ""
          ],
          "function_name": null,
          "description": "包含系统调用用户分发功能所需头文件及通用定义，提供架构相关接口和内核调度必要声明",
          "similarity": 0.6089075207710266
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 20,
          "end_line": 122,
          "content": [
            "static void trigger_sigsys(struct pt_regs *regs)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSYS;",
            "\tinfo.si_code = SYS_USER_DISPATCH;",
            "\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_arch = syscall_get_arch(current);",
            "\tinfo.si_syscall = syscall_get_nr(current, regs);",
            "",
            "\tforce_sig_info(&info);",
            "}",
            "bool syscall_user_dispatch(struct pt_regs *regs)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;",
            "\tchar state;",
            "",
            "\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))",
            "\t\treturn false;",
            "",
            "\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))",
            "\t\treturn false;",
            "",
            "\tif (likely(sd->selector)) {",
            "\t\t/*",
            "\t\t * access_ok() is performed once, at prctl time, when",
            "\t\t * the selector is loaded by userspace.",
            "\t\t */",
            "\t\tif (unlikely(__get_user(state, sd->selector))) {",
            "\t\t\tforce_exit_sig(SIGSEGV);",
            "\t\t\treturn true;",
            "\t\t}",
            "",
            "\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))",
            "\t\t\treturn false;",
            "",
            "\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {",
            "\t\t\tforce_exit_sig(SIGSYS);",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tsd->on_dispatch = true;",
            "\tsyscall_rollback(current, regs);",
            "\ttrigger_sigsys(regs);",
            "",
            "\treturn true;",
            "}",
            "static int task_set_syscall_user_dispatch(struct task_struct *task, unsigned long mode,",
            "\t\t\t\t\t  unsigned long offset, unsigned long len,",
            "\t\t\t\t\t  char __user *selector)",
            "{",
            "\tswitch (mode) {",
            "\tcase PR_SYS_DISPATCH_OFF:",
            "\t\tif (offset || len || selector)",
            "\t\t\treturn -EINVAL;",
            "\t\tbreak;",
            "\tcase PR_SYS_DISPATCH_ON:",
            "\t\t/*",
            "\t\t * Validate the direct dispatcher region just for basic",
            "\t\t * sanity against overflow and a 0-sized dispatcher",
            "\t\t * region.  If the user is able to submit a syscall from",
            "\t\t * an address, that address is obviously valid.",
            "\t\t */",
            "\t\tif (offset && offset + len <= offset)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * access_ok() will clear memory tags for tagged addresses",
            "\t\t * if current has memory tagging enabled.",
            "",
            "\t\t * To enable a tracer to set a tracees selector the",
            "\t\t * selector address must be untagged for access_ok(),",
            "\t\t * otherwise an untagged tracer will always fail to set a",
            "\t\t * tagged tracees selector.",
            "\t\t */",
            "\t\tif (selector && !access_ok(untagged_addr(selector), sizeof(*selector)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttask->syscall_dispatch.selector = selector;",
            "\ttask->syscall_dispatch.offset = offset;",
            "\ttask->syscall_dispatch.len = len;",
            "\ttask->syscall_dispatch.on_dispatch = false;",
            "",
            "\tif (mode == PR_SYS_DISPATCH_ON)",
            "\t\tset_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "\telse",
            "\t\tclear_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "",
            "\treturn 0;",
            "}",
            "int set_syscall_user_dispatch(unsigned long mode, unsigned long offset,",
            "\t\t\t      unsigned long len, char __user *selector)",
            "{",
            "\treturn task_set_syscall_user_dispatch(current, mode, offset, len, selector);",
            "}"
          ],
          "function_name": "trigger_sigsys, syscall_user_dispatch, task_set_syscall_user_dispatch, set_syscall_user_dispatch",
          "description": "实现系统调用用户分发核心逻辑，包含触发SIGSYS信号处理、配置验证、拦截判断及模式切换功能",
          "similarity": 0.6040974259376526
        }
      ]
    },
    {
      "source_file": "mm/process_vm_access.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:13:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `process_vm_access.c`\n\n---\n\n# `process_vm_access.c` 技术文档\n\n## 1. 文件概述\n\n`process_vm_access.c` 是 Linux 内核中实现跨进程虚拟内存读写功能的核心文件，提供了系统调用 `process_vm_readv` 和 `process_vm_writev` 的底层支持。该机制允许一个进程在无需目标进程协作的情况下，安全地从另一个进程中读取或向其写入数据，常用于调试器、容器运行时、性能分析工具等需要跨进程内存访问的场景。其实现基于内核的页表管理和用户页锁定（`pin_user_pages_remote`）机制，在保证安全性的同时避免了传统 `ptrace` 方式的上下文切换开销。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`process_vm_rw_pages`**  \n  执行实际的页面级内存拷贝操作，根据 `vm_write` 标志决定是将本地数据写入目标页（`copy_page_from_iter`）还是从目标页读取到本地（`copy_page_to_iter`）。\n\n- **`process_vm_rw_single_vec`**  \n  处理单个内存区域（由起始地址和长度定义）的读写操作。负责计算所需页数、通过 `pin_user_pages_remote` 锁定目标进程的物理页，并调用 `process_vm_rw_pages` 执行拷贝。\n\n- **`process_vm_rw_core`**  \n  核心调度函数，遍历远程进程的 iovec 数组（`rvec`），对每个内存段调用 `process_vm_rw_single_vec`。管理页指针数组的分配（栈上或动态）、目标进程查找（`find_get_task_by_vpid`）及内存描述符访问（`mm_access`）。\n\n- **`process_vm_rw`**  \n  系统调用入口的封装层，负责验证并导入用户态传入的本地（`lvec`）和远程（`rvec`）iovec 数组，初始化 `iov_iter` 迭代器，并调用 `process_vm_rw_core`。\n\n- **`SYSCALL_DEFINE6(process_vm_readv, ...)`**  \n  `process_vm_readv` 系统调用的定义（代码片段截断，但完整实现会在此处调用 `process_vm_rw` 并设置 `vm_write=0`）。\n\n- **`SYSCALL_DEFINE6(process_vm_writev, ...)`**  \n  （隐含存在）`process_vm_writev` 系统调用的定义，调用 `process_vm_rw` 并设置 `vm_write=1`。\n\n### 关键数据结构与常量\n\n- **`PVM_MAX_PP_ARRAY_COUNT`** (`16`)  \n  栈上预分配的 `struct page*` 数组的最大元素数量，用于存储待操作页的指针，避免小规模操作时的动态分配。\n\n- **`PVM_MAX_KMALLOC_PAGES`** (`PAGE_SIZE * 2`)  \n  动态分配 `struct page*` 数组时的最大内存限制（以字节计），确保 `kmalloc` 调用的可靠性。\n\n- **`iov_iter`**  \n  内核通用的 I/O 迭代器，用于高效遍历本地缓冲区（`lvec`）。\n\n## 3. 关键实现\n\n- **分页处理与批量锁定**：  \n  函数 `process_vm_rw_single_vec` 将大块内存访问拆分为多个页面批次处理。每批次最多处理 `PVM_MAX_KMALLOC_PAGES / sizeof(struct page*)` 个页，通过 `pin_user_pages_remote` 在目标进程的 `mm_struct` 上下文中锁定物理页，确保在拷贝期间页不会被换出或释放。\n\n- **内存安全与权限检查**：  \n  使用 `mm_access(task, PTRACE_MODE_ATTACH_REALCREDS)` 检查调用者是否有权访问目标进程的内存，该模式要求调用者具有 `CAP_SYS_PTRACE` 能力或满足 ptrace 附加条件。若返回 `-EACCES`，则转换为更合适的 `-EPERM` 错误码。\n\n- **资源管理与错误处理**：  \n  - 页指针数组优先使用栈空间（`pp_stack`），超出 `PVM_MAX_PP_ARRAY_COUNT` 时才动态分配。\n  - 拷贝过程中若发生部分成功（`total_len > 0`），即使后续出错也返回已成功传输的字节数。\n  - 使用 `unpin_user_pages_dirty_lock` 释放锁定的页，若为写操作（`vm_write=1`）则标记页为脏（`dirty`），确保修改能回写。\n\n- **I/O 向量化支持**：  \n  通过 `import_iovec` 和 `iovec_from_user` 处理用户态传入的分散/聚集 I/O 向量（iovec），支持非连续内存区域的高效批量传输。\n\n## 4. 依赖关系\n\n- **内存管理子系统 (`<linux/mm.h>`, `<linux/highmem.h>`)**：  \n  依赖 `pin_user_pages_remote`、`unpin_user_pages_dirty_lock`、`copy_page_to/from_iter` 等核心内存操作函数。\n  \n- **进程管理 (`<linux/sched.h>`, `<linux/sched/mm.h>`)**：  \n  使用 `find_get_task_by_vpid` 查找目标进程，`mm_access` 获取并验证其内存描述符。\n\n- **I/O 子系统 (`<linux/uio.h>`)**：  \n  基于 `iov_iter` 框架实现高效的 I/O 向量处理。\n\n- **系统调用接口 (`<linux/syscalls.h>`)**：  \n  通过 `SYSCALL_DEFINE6` 定义用户态可调用的系统调用入口。\n\n- **兼容层 (`<linux/compat.h>`)**：  \n  支持 32 位用户程序在 64 位内核上的调用（`in_compat_syscall()`）。\n\n- **安全框架 (`<linux/ptrace.h>`)**：  \n  复用 ptrace 的权限检查模型（`PTRACE_MODE_ATTACH_REALCREDS`）确保内存访问安全。\n\n## 5. 使用场景\n\n- **调试与监控工具**：  \n  如 `gdb`、`strace` 等工具通过 `process_vm_readv` 直接读取被调试进程的内存状态，避免频繁的 `ptrace` 陷入内核。\n\n- **容器与沙箱技术**：  \n  容器运行时（如 Docker、Kata Containers）利用此接口在不侵入容器内部的情况下，从宿主机读取或注入容器进程的内存数据。\n\n- **高性能进程间通信 (IPC)**：  \n  在特定场景下替代传统的管道、共享内存等 IPC 机制，实现零拷贝或低开销的跨进程数据交换。\n\n- **内核自检与故障注入**：  \n  内核测试框架可通过此接口模拟内存错误或验证进程内存布局。\n\n- **安全审计工具**：  \n  如 `auditd` 或自定义 LSM 模块，用于监控敏感进程的内存活动。",
      "similarity": 0.578041672706604,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/process_vm_access.c",
          "start_line": 253,
          "end_line": 289,
          "content": [
            "static ssize_t process_vm_rw(pid_t pid,",
            "\t\t\t     const struct iovec __user *lvec,",
            "\t\t\t     unsigned long liovcnt,",
            "\t\t\t     const struct iovec __user *rvec,",
            "\t\t\t     unsigned long riovcnt,",
            "\t\t\t     unsigned long flags, int vm_write)",
            "{",
            "\tstruct iovec iovstack_l[UIO_FASTIOV];",
            "\tstruct iovec iovstack_r[UIO_FASTIOV];",
            "\tstruct iovec *iov_l = iovstack_l;",
            "\tstruct iovec *iov_r;",
            "\tstruct iov_iter iter;",
            "\tssize_t rc;",
            "\tint dir = vm_write ? ITER_SOURCE : ITER_DEST;",
            "",
            "\tif (flags != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Check iovecs */",
            "\trc = import_iovec(dir, lvec, liovcnt, UIO_FASTIOV, &iov_l, &iter);",
            "\tif (rc < 0)",
            "\t\treturn rc;",
            "\tif (!iov_iter_count(&iter))",
            "\t\tgoto free_iov_l;",
            "\tiov_r = iovec_from_user(rvec, riovcnt, UIO_FASTIOV, iovstack_r,",
            "\t\t\t\tin_compat_syscall());",
            "\tif (IS_ERR(iov_r)) {",
            "\t\trc = PTR_ERR(iov_r);",
            "\t\tgoto free_iov_l;",
            "\t}",
            "\trc = process_vm_rw_core(pid, &iter, iov_r, riovcnt, flags, vm_write);",
            "\tif (iov_r != iovstack_r)",
            "\t\tkfree(iov_r);",
            "free_iov_l:",
            "\tkfree(iov_l);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "process_vm_rw",
          "description": "实现process_vm_rw函数，整合用户态iovec数据到内核迭代器，通过import_iovec解析输入向量，调用核心处理流程完成跨进程内存读写操作",
          "similarity": 0.5248709321022034
        },
        {
          "chunk_id": 1,
          "file_path": "mm/process_vm_access.c",
          "start_line": 27,
          "end_line": 203,
          "content": [
            "static int process_vm_rw_pages(struct page **pages,",
            "\t\t\t       unsigned offset,",
            "\t\t\t       size_t len,",
            "\t\t\t       struct iov_iter *iter,",
            "\t\t\t       int vm_write)",
            "{",
            "\t/* Do the copy for each page */",
            "\twhile (len && iov_iter_count(iter)) {",
            "\t\tstruct page *page = *pages++;",
            "\t\tsize_t copy = PAGE_SIZE - offset;",
            "\t\tsize_t copied;",
            "",
            "\t\tif (copy > len)",
            "\t\t\tcopy = len;",
            "",
            "\t\tif (vm_write)",
            "\t\t\tcopied = copy_page_from_iter(page, offset, copy, iter);",
            "\t\telse",
            "\t\t\tcopied = copy_page_to_iter(page, offset, copy, iter);",
            "",
            "\t\tlen -= copied;",
            "\t\tif (copied < copy && iov_iter_count(iter))",
            "\t\t\treturn -EFAULT;",
            "\t\toffset = 0;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int process_vm_rw_single_vec(unsigned long addr,",
            "\t\t\t\t    unsigned long len,",
            "\t\t\t\t    struct iov_iter *iter,",
            "\t\t\t\t    struct page **process_pages,",
            "\t\t\t\t    struct mm_struct *mm,",
            "\t\t\t\t    struct task_struct *task,",
            "\t\t\t\t    int vm_write)",
            "{",
            "\tunsigned long pa = addr & PAGE_MASK;",
            "\tunsigned long start_offset = addr - pa;",
            "\tunsigned long nr_pages;",
            "\tssize_t rc = 0;",
            "\tunsigned long max_pages_per_loop = PVM_MAX_KMALLOC_PAGES",
            "\t\t/ sizeof(struct pages *);",
            "\tunsigned int flags = 0;",
            "",
            "\t/* Work out address and page range required */",
            "\tif (len == 0)",
            "\t\treturn 0;",
            "\tnr_pages = (addr + len - 1) / PAGE_SIZE - addr / PAGE_SIZE + 1;",
            "",
            "\tif (vm_write)",
            "\t\tflags |= FOLL_WRITE;",
            "",
            "\twhile (!rc && nr_pages && iov_iter_count(iter)) {",
            "\t\tint pinned_pages = min(nr_pages, max_pages_per_loop);",
            "\t\tint locked = 1;",
            "\t\tsize_t bytes;",
            "",
            "\t\t/*",
            "\t\t * Get the pages we're interested in.  We must",
            "\t\t * access remotely because task/mm might not",
            "\t\t * current/current->mm",
            "\t\t */",
            "\t\tmmap_read_lock(mm);",
            "\t\tpinned_pages = pin_user_pages_remote(mm, pa, pinned_pages,",
            "\t\t\t\t\t\t     flags, process_pages,",
            "\t\t\t\t\t\t     &locked);",
            "\t\tif (locked)",
            "\t\t\tmmap_read_unlock(mm);",
            "\t\tif (pinned_pages <= 0)",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbytes = pinned_pages * PAGE_SIZE - start_offset;",
            "\t\tif (bytes > len)",
            "\t\t\tbytes = len;",
            "",
            "\t\trc = process_vm_rw_pages(process_pages,",
            "\t\t\t\t\t start_offset, bytes, iter,",
            "\t\t\t\t\t vm_write);",
            "\t\tlen -= bytes;",
            "\t\tstart_offset = 0;",
            "\t\tnr_pages -= pinned_pages;",
            "\t\tpa += pinned_pages * PAGE_SIZE;",
            "",
            "\t\t/* If vm_write is set, the pages need to be made dirty: */",
            "\t\tunpin_user_pages_dirty_lock(process_pages, pinned_pages,",
            "\t\t\t\t\t    vm_write);",
            "\t}",
            "",
            "\treturn rc;",
            "}",
            "static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,",
            "\t\t\t\t  const struct iovec *rvec,",
            "\t\t\t\t  unsigned long riovcnt,",
            "\t\t\t\t  unsigned long flags, int vm_write)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];",
            "\tstruct page **process_pages = pp_stack;",
            "\tstruct mm_struct *mm;",
            "\tunsigned long i;",
            "\tssize_t rc = 0;",
            "\tunsigned long nr_pages = 0;",
            "\tunsigned long nr_pages_iov;",
            "\tssize_t iov_len;",
            "\tsize_t total_len = iov_iter_count(iter);",
            "",
            "\t/*",
            "\t * Work out how many pages of struct pages we're going to need",
            "\t * when eventually calling get_user_pages",
            "\t */",
            "\tfor (i = 0; i < riovcnt; i++) {",
            "\t\tiov_len = rvec[i].iov_len;",
            "\t\tif (iov_len > 0) {",
            "\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base",
            "\t\t\t\t\t+ iov_len)",
            "\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base",
            "\t\t\t\t/ PAGE_SIZE + 1;",
            "\t\t\tnr_pages = max(nr_pages, nr_pages_iov);",
            "\t\t}",
            "\t}",
            "",
            "\tif (nr_pages == 0)",
            "\t\treturn 0;",
            "",
            "\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {",
            "\t\t/* For reliability don't try to kmalloc more than",
            "\t\t   2 pages worth */",
            "\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,",
            "\t\t\t\t\t      sizeof(struct pages *)*nr_pages),",
            "\t\t\t\t\tGFP_KERNEL);",
            "",
            "\t\tif (!process_pages)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\t/* Get process information */",
            "\ttask = find_get_task_by_vpid(pid);",
            "\tif (!task) {",
            "\t\trc = -ESRCH;",
            "\t\tgoto free_proc_pages;",
            "\t}",
            "",
            "\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);",
            "\tif (!mm || IS_ERR(mm)) {",
            "\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;",
            "\t\t/*",
            "\t\t * Explicitly map EACCES to EPERM as EPERM is a more",
            "\t\t * appropriate error code for process_vw_readv/writev",
            "\t\t */",
            "\t\tif (rc == -EACCES)",
            "\t\t\trc = -EPERM;",
            "\t\tgoto put_task_struct;",
            "\t}",
            "",
            "\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)",
            "\t\trc = process_vm_rw_single_vec(",
            "\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,",
            "\t\t\titer, process_pages, mm, task, vm_write);",
            "",
            "\t/* copied = space before - space after */",
            "\ttotal_len -= iov_iter_count(iter);",
            "",
            "\t/* If we have managed to copy any data at all then",
            "\t   we return the number of bytes copied. Otherwise",
            "\t   we return the error code */",
            "\tif (total_len)",
            "\t\trc = total_len;",
            "",
            "\tmmput(mm);",
            "",
            "put_task_struct:",
            "\tput_task_struct(task);",
            "",
            "free_proc_pages:",
            "\tif (process_pages != pp_stack)",
            "\t\tkfree(process_pages);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "process_vm_rw_pages, process_vm_rw_single_vec, process_vm_rw_core",
          "description": "实现process_vm_rw_pages通过循环处理页面数据拷贝，process_vm_rw_single_vec获取远程页面并调用核心处理逻辑，process_vm_rw_core协调多进程地址范围映射与页面锁定操作",
          "similarity": 0.5231981873512268
        },
        {
          "chunk_id": 0,
          "file_path": "mm/process_vm_access.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * linux/mm/process_vm_access.c",
            " *",
            " * Copyright (C) 2010-2011 Christopher Yeoh <cyeoh@au1.ibm.com>, IBM Corp.",
            " */",
            "",
            "#include <linux/compat.h>",
            "#include <linux/mm.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "",
            "/**",
            " * process_vm_rw_pages - read/write pages from task specified",
            " * @pages: array of pointers to pages we want to copy",
            " * @offset: offset in page to start copying from/to",
            " * @len: number of bytes to copy",
            " * @iter: where to copy to/from locally",
            " * @vm_write: 0 means copy from, 1 means copy to",
            " * Returns 0 on success, error code otherwise",
            " */"
          ],
          "function_name": null,
          "description": "声明process_vm_rw_pages函数，用于从指定任务的页面进行读写操作，接受页面指针数组、偏移量、长度、迭代器及写标志，返回操作结果状态码",
          "similarity": 0.46319663524627686
        }
      ]
    }
  ]
}