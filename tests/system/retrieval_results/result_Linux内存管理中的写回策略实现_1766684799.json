{
  "query": "Linux内存管理中的写回策略实现",
  "timestamp": "2025-12-26 01:46:39",
  "retrieved_files": [
    {
      "source_file": "mm/mempolicy.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:44:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mempolicy.c`\n\n---\n\n# mempolicy.c 技术文档\n\n## 1. 文件概述\n\n`mempolicy.c` 实现了 Linux 内核中的 NUMA（Non-Uniform Memory Access）内存策略机制，允许用户通过系统调用为进程或虚拟内存区域（VMA）指定内存分配偏好。该机制支持多种内存分配策略，包括本地优先、绑定节点、轮询交错和基于权重的交错分配等，以优化多节点 NUMA 系统上的内存访问性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct mempolicy`：表示内存策略的核心结构，包含策略模式（如 MPOL_INTERLEAVE、MPOL_BIND、MPOL_PREFERRED 等）、节点掩码（nodemask）和引用计数。\n- `struct weighted_interleave_state`：用于实现加权交错分配策略，包含每个节点的权重表（iw_table）和自动模式标志。\n- `default_policy`：全局默认内存策略，初始为 MPOL_LOCAL（本地节点优先）。\n- `preferred_node_policy[MAX_NUMNODES]`：为每个节点预定义的首选策略数组。\n\n### 主要函数与接口\n- `get_il_weight(int node)`：获取指定节点在加权交错策略中的权重。\n- `reduce_interleave_weights(unsigned int *bw, u8 *new_iw)`：将带宽值转换为归一化的交错权重。\n- `mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)`：根据节点性能坐标（读/写带宽）动态更新加权交错策略。\n- 多个辅助函数用于策略创建、复制、合并、验证及与 VMA 和进程上下文的集成。\n\n### 全局变量\n- `policy_cache` / `sn_cache`：用于高效分配 mempolicy 和相关子结构的 slab 缓存。\n- `policy_zone`：标识受策略控制的最高内存区域类型（zone_type），低区域（如 GFP_DMA）不应用策略。\n- `wi_state`：RCU 保护的加权交错状态指针。\n- `node_bw_table`：存储各节点带宽信息，用于动态权重计算。\n- `weightiness`：权重归一化常量（值为 32），平衡权重精度与分配公平性。\n\n## 3. 关键实现\n\n### 策略优先级与作用域\n- **VMA 策略优先于进程策略**：页错误处理时，若 VMA 有策略则使用 VMA 策略，否则回退到当前进程的策略。\n- **中断上下文忽略策略**：所有中断相关的内存分配始终尝试在本地 CPU 节点分配。\n- **策略不跨 swap 保留**：进程策略在页面换出/换入时不被保留。\n\n### 加权交错分配（Weighted Interleave）\n- 基于各 NUMA 节点的读/写带宽动态计算分配权重。\n- 使用 `weightiness=32` 对带宽进行缩放，并通过 GCD（最大公约数）约简权重以减少分配周期长度。\n- 权重状态通过 RCU 机制安全更新，读路径无锁，写路径由 `wi_state_lock` 互斥锁保护。\n\n### 策略类型详解\n- **interleave**：按偏移量（VMA）或进程计数器（进程）在节点集上轮询分配。\n- **weighted interleave**：按节点权重比例分配（如权重 [2,1] 表示节点0:节点1 = 2:1）。\n- **bind**：严格限制在指定节点集分配，无回退（当前实现按节点顺序分配，非最优）。\n- **preferred / preferred many**：优先在指定单个/多个节点分配，失败后回退到默认策略。\n- **default / local**：优先本地节点分配，VMA 中则继承进程策略。\n\n### 内存区域限制\n- 仅对 **最高 zone 层级**（如 NORMAL 或 MOVABLE）应用策略，GFP_DMA、HIGHMEM 等低层级分配忽略策略。\n\n### 特殊共享内存处理\n- **shmem/tmpfs**：策略在所有映射进程间共享，即使无活跃映射也持久保存。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `<linux/mm.h>`、`<linux/vm_area_struct.h>`、`<linux/page-flags.h>` 等进行页分配、VMA 操作和页表遍历。\n- **NUMA 感知调度**：与 `<linux/sched/numa_balancing.h>` 协同，支持自动 NUMA 迁移。\n- **CPUSET 子系统**：通过 `<linux/cpuset.h>` 集成节点可用性约束。\n- **Slab 分配器**：使用 kmem_cache 管理 mempolicy 对象生命周期。\n- **RCU 机制**：用于加权交错状态的无锁读取。\n- **系统调用接口**：通过 `sys_mbind()`、`sys_set_mempolicy()` 等提供用户空间配置入口。\n- **安全模块**：调用 LSM hooks（`security_task_movememory()`）进行权限检查。\n\n## 5. 使用场景\n\n- **高性能计算（HPC）应用**：通过 `mbind()` 将关键数据结构绑定到特定 NUMA 节点，减少远程内存访问延迟。\n- **数据库系统**：使用交错策略均衡多节点内存带宽，提升吞吐量。\n- **虚拟化环境**：VMM 可为不同虚拟机设置独立内存策略，隔离资源并优化性能。\n- **自动 NUMA 优化**：内核 NUMA balancing 机制结合默认策略，自动迁移热点页面至访问 CPU 所在节点。\n- **实时系统**：通过 `MPOL_BIND` 严格限制内存位置，确保确定性访问延迟。\n- **大页（HugeTLB）分配**：策略同样适用于透明大页和显式 HugeTLB 页面分配。",
      "similarity": 0.6413843035697937,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "mm/mempolicy.c",
          "start_line": 880,
          "end_line": 996,
          "content": [
            "static long",
            "queue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,",
            "\t\tnodemask_t *nodes, unsigned long flags,",
            "\t\tstruct list_head *pagelist)",
            "{",
            "\tint err;",
            "\tstruct queue_pages qp = {",
            "\t\t.pagelist = pagelist,",
            "\t\t.flags = flags,",
            "\t\t.nmask = nodes,",
            "\t\t.start = start,",
            "\t\t.end = end,",
            "\t\t.first = NULL,",
            "\t};",
            "\tconst struct mm_walk_ops *ops = (flags & MPOL_MF_WRLOCK) ?",
            "\t\t\t&queue_pages_lock_vma_walk_ops : &queue_pages_walk_ops;",
            "",
            "\terr = walk_page_range(mm, start, end, ops, &qp);",
            "",
            "\tif (!qp.first)",
            "\t\t/* whole range in hole */",
            "\t\terr = -EFAULT;",
            "",
            "\treturn err ? : qp.nr_failed;",
            "}",
            "static int vma_replace_policy(struct vm_area_struct *vma,",
            "\t\t\t\tstruct mempolicy *pol)",
            "{",
            "\tint err;",
            "\tstruct mempolicy *old;",
            "\tstruct mempolicy *new;",
            "",
            "\tvma_assert_write_locked(vma);",
            "",
            "\tnew = mpol_dup(pol);",
            "\tif (IS_ERR(new))",
            "\t\treturn PTR_ERR(new);",
            "",
            "\tif (vma->vm_ops && vma->vm_ops->set_policy) {",
            "\t\terr = vma->vm_ops->set_policy(vma, new);",
            "\t\tif (err)",
            "\t\t\tgoto err_out;",
            "\t}",
            "",
            "\told = vma->vm_policy;",
            "\tvma->vm_policy = new; /* protected by mmap_lock */",
            "\tmpol_put(old);",
            "",
            "\treturn 0;",
            " err_out:",
            "\tmpol_put(new);",
            "\treturn err;",
            "}",
            "static int mbind_range(struct vma_iterator *vmi, struct vm_area_struct *vma,",
            "\t\tstruct vm_area_struct **prev, unsigned long start,",
            "\t\tunsigned long end, struct mempolicy *new_pol)",
            "{",
            "\tunsigned long vmstart, vmend;",
            "",
            "\tvmend = min(end, vma->vm_end);",
            "\tif (start > vma->vm_start) {",
            "\t\t*prev = vma;",
            "\t\tvmstart = start;",
            "\t} else {",
            "\t\tvmstart = vma->vm_start;",
            "\t}",
            "",
            "\tif (mpol_equal(vma->vm_policy, new_pol)) {",
            "\t\t*prev = vma;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tvma =  vma_modify_policy(vmi, *prev, vma, vmstart, vmend, new_pol);",
            "\tif (IS_ERR(vma))",
            "\t\treturn PTR_ERR(vma);",
            "",
            "\t*prev = vma;",
            "\treturn vma_replace_policy(vma, new_pol);",
            "}",
            "static long do_set_mempolicy(unsigned short mode, unsigned short flags,",
            "\t\t\t     nodemask_t *nodes)",
            "{",
            "\tstruct mempolicy *new, *old;",
            "\tNODEMASK_SCRATCH(scratch);",
            "\tint ret;",
            "",
            "\tif (!scratch)",
            "\t\treturn -ENOMEM;",
            "",
            "\tnew = mpol_new(mode, flags, nodes);",
            "\tif (IS_ERR(new)) {",
            "\t\tret = PTR_ERR(new);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\ttask_lock(current);",
            "\tret = mpol_set_nodemask(new, nodes, scratch);",
            "\tif (ret) {",
            "\t\ttask_unlock(current);",
            "\t\tmpol_put(new);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\told = current->mempolicy;",
            "\tcurrent->mempolicy = new;",
            "\tif (new && (new->mode == MPOL_INTERLEAVE ||",
            "\t\t    new->mode == MPOL_WEIGHTED_INTERLEAVE)) {",
            "\t\tcurrent->il_prev = MAX_NUMNODES-1;",
            "\t\tcurrent->il_weight = 0;",
            "\t}",
            "\ttask_unlock(current);",
            "\tmpol_put(old);",
            "\tret = 0;",
            "out:",
            "\tNODEMASK_SCRATCH_FREE(scratch);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "queue_pages_range, vma_replace_policy, mbind_range, do_set_mempolicy",
          "description": "实现内存策略设置，通过queue_pages_range队列页面，vma_replace_policy替换VMA策略，mbind_range绑定指定范围策略，do_set_mempolicy设置当前进程全局内存策略",
          "similarity": 0.6535901427268982
        },
        {
          "chunk_id": 10,
          "file_path": "mm/mempolicy.c",
          "start_line": 1735,
          "end_line": 1838,
          "content": [
            "static long kernel_set_mempolicy(int mode, const unsigned long __user *nmask,",
            "\t\t\t\t unsigned long maxnode)",
            "{",
            "\tunsigned short mode_flags;",
            "\tnodemask_t nodes;",
            "\tint lmode = mode;",
            "\tint err;",
            "",
            "\terr = sanitize_mpol_flags(&lmode, &mode_flags);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = get_nodes(&nodes, nmask, maxnode);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn do_set_mempolicy(lmode, mode_flags, &nodes);",
            "}",
            "static int kernel_migrate_pages(pid_t pid, unsigned long maxnode,",
            "\t\t\t\tconst unsigned long __user *old_nodes,",
            "\t\t\t\tconst unsigned long __user *new_nodes)",
            "{",
            "\tstruct mm_struct *mm = NULL;",
            "\tstruct task_struct *task;",
            "\tnodemask_t task_nodes;",
            "\tint err;",
            "\tnodemask_t *old;",
            "\tnodemask_t *new;",
            "\tNODEMASK_SCRATCH(scratch);",
            "",
            "\tif (!scratch)",
            "\t\treturn -ENOMEM;",
            "",
            "\told = &scratch->mask1;",
            "\tnew = &scratch->mask2;",
            "",
            "\terr = get_nodes(old, old_nodes, maxnode);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\terr = get_nodes(new, new_nodes, maxnode);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\t/* Find the mm_struct */",
            "\trcu_read_lock();",
            "\ttask = pid ? find_task_by_vpid(pid) : current;",
            "\tif (!task) {",
            "\t\trcu_read_unlock();",
            "\t\terr = -ESRCH;",
            "\t\tgoto out;",
            "\t}",
            "\tget_task_struct(task);",
            "",
            "\terr = -EINVAL;",
            "",
            "\t/*",
            "\t * Check if this process has the right to modify the specified process.",
            "\t * Use the regular \"ptrace_may_access()\" checks.",
            "\t */",
            "\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\trcu_read_unlock();",
            "\t\terr = -EPERM;",
            "\t\tgoto out_put;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\ttask_nodes = cpuset_mems_allowed(task);",
            "\t/* Is the user allowed to access the target nodes? */",
            "\tif (!nodes_subset(*new, task_nodes) && !capable(CAP_SYS_NICE)) {",
            "\t\terr = -EPERM;",
            "\t\tgoto out_put;",
            "\t}",
            "",
            "\ttask_nodes = cpuset_mems_allowed(current);",
            "\tnodes_and(*new, *new, task_nodes);",
            "\tif (nodes_empty(*new))",
            "\t\tgoto out_put;",
            "",
            "\terr = security_task_movememory(task);",
            "\tif (err)",
            "\t\tgoto out_put;",
            "",
            "\tmm = get_task_mm(task);",
            "\tput_task_struct(task);",
            "",
            "\tif (!mm) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terr = do_migrate_pages(mm, old, new,",
            "\t\tcapable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);",
            "",
            "\tmmput(mm);",
            "out:",
            "\tNODEMASK_SCRATCH_FREE(scratch);",
            "",
            "\treturn err;",
            "",
            "out_put:",
            "\tput_task_struct(task);",
            "\tgoto out;",
            "}"
          ],
          "function_name": "kernel_set_mempolicy, kernel_migrate_pages",
          "description": "kernel_set_mempolicy 设置进程的内存放置策略，通过sanitize_mpol_flags验证模式标志并调用do_set_mempolicy应用策略；kernel_migrate_pages 实现页面迁移，检查目标进程权限，限制迁移节点范围，并调用do_migrate_pages进行实际迁移操作。",
          "similarity": 0.6250782608985901
        },
        {
          "chunk_id": 1,
          "file_path": "mm/mempolicy.c",
          "start_line": 168,
          "end_line": 268,
          "content": [
            "static u8 get_il_weight(int node)",
            "{",
            "\tstruct weighted_interleave_state *state;",
            "\tu8 weight = 1;",
            "",
            "\trcu_read_lock();",
            "\tstate = rcu_dereference(wi_state);",
            "\tif (state)",
            "\t\tweight = state->iw_table[node];",
            "\trcu_read_unlock();",
            "\treturn weight;",
            "}",
            "static void reduce_interleave_weights(unsigned int *bw, u8 *new_iw)",
            "{",
            "\tu64 sum_bw = 0;",
            "\tunsigned int cast_sum_bw, scaling_factor = 1, iw_gcd = 0;",
            "\tint nid;",
            "",
            "\tfor_each_node_state(nid, N_MEMORY)",
            "\t\tsum_bw += bw[nid];",
            "",
            "\t/* Scale bandwidths to whole numbers in the range [1, weightiness] */",
            "\tfor_each_node_state(nid, N_MEMORY) {",
            "\t\t/*",
            "\t\t * Try not to perform 64-bit division.",
            "\t\t * If sum_bw < scaling_factor, then sum_bw < U32_MAX.",
            "\t\t * If sum_bw > scaling_factor, then round the weight up to 1.",
            "\t\t */",
            "\t\tscaling_factor = weightiness * bw[nid];",
            "\t\tif (bw[nid] && sum_bw < scaling_factor) {",
            "\t\t\tcast_sum_bw = (unsigned int)sum_bw;",
            "\t\t\tnew_iw[nid] = scaling_factor / cast_sum_bw;",
            "\t\t} else {",
            "\t\t\tnew_iw[nid] = 1;",
            "\t\t}",
            "\t\tif (!iw_gcd)",
            "\t\t\tiw_gcd = new_iw[nid];",
            "\t\tiw_gcd = gcd(iw_gcd, new_iw[nid]);",
            "\t}",
            "",
            "\t/* 1:2 is strictly better than 16:32. Reduce by the weights' GCD. */",
            "\tfor_each_node_state(nid, N_MEMORY)",
            "\t\tnew_iw[nid] /= iw_gcd;",
            "}",
            "int mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)",
            "{",
            "\tstruct weighted_interleave_state *new_wi_state, *old_wi_state = NULL;",
            "\tunsigned int *old_bw, *new_bw;",
            "\tunsigned int bw_val;",
            "\tint i;",
            "",
            "\tbw_val = min(coords->read_bandwidth, coords->write_bandwidth);",
            "\tnew_bw = kcalloc(nr_node_ids, sizeof(unsigned int), GFP_KERNEL);",
            "\tif (!new_bw)",
            "\t\treturn -ENOMEM;",
            "",
            "\tnew_wi_state = kmalloc(struct_size(new_wi_state, iw_table, nr_node_ids),",
            "\t\t\t       GFP_KERNEL);",
            "\tif (!new_wi_state) {",
            "\t\tkfree(new_bw);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tnew_wi_state->mode_auto = true;",
            "\tfor (i = 0; i < nr_node_ids; i++)",
            "\t\tnew_wi_state->iw_table[i] = 1;",
            "",
            "\t/*",
            "\t * Update bandwidth info, even in manual mode. That way, when switching",
            "\t * to auto mode in the future, iw_table can be overwritten using",
            "\t * accurate bw data.",
            "\t */",
            "\tmutex_lock(&wi_state_lock);",
            "",
            "\told_bw = node_bw_table;",
            "\tif (old_bw)",
            "\t\tmemcpy(new_bw, old_bw, nr_node_ids * sizeof(*old_bw));",
            "\tnew_bw[node] = bw_val;",
            "\tnode_bw_table = new_bw;",
            "",
            "\told_wi_state = rcu_dereference_protected(wi_state,",
            "\t\t\t\t\tlockdep_is_held(&wi_state_lock));",
            "\tif (old_wi_state && !old_wi_state->mode_auto) {",
            "\t\t/* Manual mode; skip reducing weights and updating wi_state */",
            "\t\tmutex_unlock(&wi_state_lock);",
            "\t\tkfree(new_wi_state);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* NULL wi_state assumes auto=true; reduce weights and update wi_state*/",
            "\treduce_interleave_weights(new_bw, new_wi_state->iw_table);",
            "\trcu_assign_pointer(wi_state, new_wi_state);",
            "",
            "\tmutex_unlock(&wi_state_lock);",
            "\tif (old_wi_state) {",
            "\t\tsynchronize_rcu();",
            "\t\tkfree(old_wi_state);",
            "\t}",
            "out:",
            "\tkfree(old_bw);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_il_weight, reduce_interleave_weights, mempolicy_set_node_perf",
          "description": "实现带权交错策略的权重计算与调整逻辑，通过获取节点带宽数据动态修改权重比例，支持根据性能参数更新节点间内存分配优先级。",
          "similarity": 0.6214586496353149
        },
        {
          "chunk_id": 11,
          "file_path": "mm/mempolicy.c",
          "start_line": 1855,
          "end_line": 1971,
          "content": [
            "static int kernel_get_mempolicy(int __user *policy,",
            "\t\t\t\tunsigned long __user *nmask,",
            "\t\t\t\tunsigned long maxnode,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long flags)",
            "{",
            "\tint err;",
            "\tint pval;",
            "\tnodemask_t nodes;",
            "",
            "\tif (nmask != NULL && maxnode < nr_node_ids)",
            "\t\treturn -EINVAL;",
            "",
            "\taddr = untagged_addr(addr);",
            "",
            "\terr = do_get_mempolicy(&pval, &nodes, addr, flags);",
            "",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (policy && put_user(pval, policy))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (nmask)",
            "\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);",
            "",
            "\treturn err;",
            "}",
            "bool vma_migratable(struct vm_area_struct *vma)",
            "{",
            "\tif (vma->vm_flags & (VM_IO | VM_PFNMAP))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * DAX device mappings require predictable access latency, so avoid",
            "\t * incurring periodic faults.",
            "\t */",
            "\tif (vma_is_dax(vma))",
            "\t\treturn false;",
            "",
            "\tif (is_vm_hugetlb_page(vma) &&",
            "\t\t!hugepage_migration_supported(hstate_vma(vma)))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Migration allocates pages in the highest zone. If we cannot",
            "\t * do so then migration (at least from node to node) is not",
            "\t * possible.",
            "\t */",
            "\tif (vma->vm_file &&",
            "\t\tgfp_zone(mapping_gfp_mask(vma->vm_file->f_mapping))",
            "\t\t\t< policy_zone)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "bool vma_policy_mof(struct vm_area_struct *vma)",
            "{",
            "\tstruct mempolicy *pol;",
            "",
            "\tif (vma->vm_ops && vma->vm_ops->get_policy) {",
            "\t\tbool ret = false;",
            "\t\tpgoff_t ilx;\t\t/* ignored here */",
            "",
            "\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start, &ilx);",
            "\t\tif (pol && (pol->flags & MPOL_F_MOF))",
            "\t\t\tret = true;",
            "\t\tmpol_cond_put(pol);",
            "",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tpol = vma->vm_policy;",
            "\tif (!pol)",
            "\t\tpol = get_task_policy(current);",
            "",
            "\treturn pol->flags & MPOL_F_MOF;",
            "}",
            "bool apply_policy_zone(struct mempolicy *policy, enum zone_type zone)",
            "{",
            "\tenum zone_type dynamic_policy_zone = policy_zone;",
            "",
            "\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);",
            "",
            "\t/*",
            "\t * if policy->nodes has movable memory only,",
            "\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.",
            "\t *",
            "\t * policy->nodes is intersect with node_states[N_MEMORY].",
            "\t * so if the following test fails, it implies",
            "\t * policy->nodes has movable memory only.",
            "\t */",
            "\tif (!nodes_intersects(policy->nodes, node_states[N_HIGH_MEMORY]))",
            "\t\tdynamic_policy_zone = ZONE_MOVABLE;",
            "",
            "\treturn zone >= dynamic_policy_zone;",
            "}",
            "static unsigned int weighted_interleave_nodes(struct mempolicy *policy)",
            "{",
            "\tunsigned int node;",
            "\tunsigned int cpuset_mems_cookie;",
            "",
            "retry:",
            "\t/* to prevent miscount use tsk->mems_allowed_seq to detect rebind */",
            "\tcpuset_mems_cookie = read_mems_allowed_begin();",
            "\tnode = current->il_prev;",
            "\tif (!current->il_weight || !node_isset(node, policy->nodes)) {",
            "\t\tnode = next_node_in(node, policy->nodes);",
            "\t\tif (read_mems_allowed_retry(cpuset_mems_cookie))",
            "\t\t\tgoto retry;",
            "\t\tif (node == MAX_NUMNODES)",
            "\t\t\treturn node;",
            "\t\tcurrent->il_prev = node;",
            "\t\tcurrent->il_weight = get_il_weight(node);",
            "\t}",
            "\tcurrent->il_weight--;",
            "\treturn node;",
            "}"
          ],
          "function_name": "kernel_get_mempolicy, vma_migratable, vma_policy_mof, apply_policy_zone, weighted_interleave_nodes",
          "description": "kernel_get_mempolicy 获取当前内存策略参数并复制到用户空间；vma_migratable 判断虚拟内存区域是否支持迁移；vma_policy_mof 检查VMA是否启用了MOF（Migration On Fault）策略；apply_policy_zone 确定当前zone是否满足策略要求；weighted_interleave_nodes 计算加权交错分配的目标节点。",
          "similarity": 0.6191204786300659
        },
        {
          "chunk_id": 12,
          "file_path": "mm/mempolicy.c",
          "start_line": 2024,
          "end_line": 2135,
          "content": [
            "static unsigned int interleave_nodes(struct mempolicy *policy)",
            "{",
            "\tunsigned int nid;",
            "\tunsigned int cpuset_mems_cookie;",
            "",
            "\t/* to prevent miscount, use tsk->mems_allowed_seq to detect rebind */",
            "\tdo {",
            "\t\tcpuset_mems_cookie = read_mems_allowed_begin();",
            "\t\tnid = next_node_in(current->il_prev, policy->nodes);",
            "\t} while (read_mems_allowed_retry(cpuset_mems_cookie));",
            "",
            "\tif (nid < MAX_NUMNODES)",
            "\t\tcurrent->il_prev = nid;",
            "\treturn nid;",
            "}",
            "unsigned int mempolicy_slab_node(void)",
            "{",
            "\tstruct mempolicy *policy;",
            "\tint node = numa_mem_id();",
            "",
            "\tif (!in_task())",
            "\t\treturn node;",
            "",
            "\tpolicy = current->mempolicy;",
            "\tif (!policy)",
            "\t\treturn node;",
            "",
            "\tswitch (policy->mode) {",
            "\tcase MPOL_PREFERRED:",
            "\t\treturn first_node(policy->nodes);",
            "",
            "\tcase MPOL_INTERLEAVE:",
            "\t\treturn interleave_nodes(policy);",
            "",
            "\tcase MPOL_WEIGHTED_INTERLEAVE:",
            "\t\treturn weighted_interleave_nodes(policy);",
            "",
            "\tcase MPOL_BIND:",
            "\tcase MPOL_PREFERRED_MANY:",
            "\t{",
            "\t\tstruct zoneref *z;",
            "",
            "\t\t/*",
            "\t\t * Follow bind policy behavior and start allocation at the",
            "\t\t * first node.",
            "\t\t */",
            "\t\tstruct zonelist *zonelist;",
            "\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);",
            "\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];",
            "\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,",
            "\t\t\t\t\t\t\t&policy->nodes);",
            "\t\treturn z->zone ? zone_to_nid(z->zone) : node;",
            "\t}",
            "\tcase MPOL_LOCAL:",
            "\t\treturn node;",
            "",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "static unsigned int read_once_policy_nodemask(struct mempolicy *pol,",
            "\t\t\t\t\t      nodemask_t *mask)",
            "{",
            "\t/*",
            "\t * barrier stabilizes the nodemask locally so that it can be iterated",
            "\t * over safely without concern for changes. Allocators validate node",
            "\t * selection does not violate mems_allowed, so this is safe.",
            "\t */",
            "\tbarrier();",
            "\tmemcpy(mask, &pol->nodes, sizeof(nodemask_t));",
            "\tbarrier();",
            "\treturn nodes_weight(*mask);",
            "}",
            "static unsigned int weighted_interleave_nid(struct mempolicy *pol, pgoff_t ilx)",
            "{",
            "\tstruct weighted_interleave_state *state;",
            "\tnodemask_t nodemask;",
            "\tunsigned int target, nr_nodes;",
            "\tu8 *table = NULL;",
            "\tunsigned int weight_total = 0;",
            "\tu8 weight;",
            "\tint nid = 0;",
            "",
            "\tnr_nodes = read_once_policy_nodemask(pol, &nodemask);",
            "\tif (!nr_nodes)",
            "\t\treturn numa_node_id();",
            "",
            "\trcu_read_lock();",
            "",
            "\tstate = rcu_dereference(wi_state);",
            "\t/* Uninitialized wi_state means we should assume all weights are 1 */",
            "\tif (state)",
            "\t\ttable = state->iw_table;",
            "",
            "\t/* calculate the total weight */",
            "\tfor_each_node_mask(nid, nodemask)",
            "\t\tweight_total += table ? table[nid] : 1;",
            "",
            "\t/* Calculate the node offset based on totals */",
            "\ttarget = ilx % weight_total;",
            "\tnid = first_node(nodemask);",
            "\twhile (target) {",
            "\t\t/* detect system default usage */",
            "\t\tweight = table ? table[nid] : 1;",
            "\t\tif (target < weight)",
            "\t\t\tbreak;",
            "\t\ttarget -= weight;",
            "\t\tnid = next_node_in(nid, nodemask);",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn nid;",
            "}"
          ],
          "function_name": "interleave_nodes, mempolicy_slab_node, read_once_policy_nodemask, weighted_interleave_nid",
          "description": "interleave_nodes 计算交错分配的下一个节点；mempolicy_slab_node 根据内存策略返回Slab分配的节点；read_once_policy_nodemask 安全读取策略节点掩码；weighted_interleave_nid 基于权重计算加权交错分配的目标节点。",
          "similarity": 0.6178343892097473
        }
      ]
    },
    {
      "source_file": "kernel/pid_sysctl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_sysctl.h`\n\n---\n\n# `pid_sysctl.h` 技术文档\n\n## 1. 文件概述\n\n`pid_sysctl.h` 是 Linux 内核中用于定义与 PID 命名空间（`pid_namespace`）相关的系统控制（sysctl）接口的头文件。其核心功能是提供对 `memfd_noexec` 系统策略的运行时配置支持，该策略用于控制通过 `memfd_create()` 创建的内存文件是否允许执行代码。该配置具有层级继承语义：子 PID 命名空间的策略不能比其父命名空间更宽松，以确保安全策略的向下兼容性和强制性。\n\n## 2. 核心功能\n\n### 函数\n\n- **`pid_mfd_noexec_dointvec_minmax`**  \n  自定义的 sysctl 处理函数，用于读写 `memfd_noexec` 策略值。在写入时执行权限检查和策略继承约束验证。\n\n- **`register_pid_ns_sysctl_table_vm`**  \n  内联函数，用于向内核 sysctl 子系统注册 `vm.memfd_noexec` 控制项（仅在 `CONFIG_SYSCTL` 和 `CONFIG_MEMFD_CREATE` 同时启用时有效）。\n\n### 数据结构\n\n- **`pid_ns_ctl_table_vm`**  \n  `ctl_table` 类型的静态数组，定义了 `vm.memfd_noexec` sysctl 条目，包括其名称、数据指针、访问权限、处理函数及取值范围（0 到 2）。\n\n## 3. 关键实现\n\n- **权限控制**：  \n  在写入 `memfd_noexec` 值时，调用 `ns_capable(ns->user_ns, CAP_SYS_ADMIN)` 检查当前任务是否在对应用户命名空间中拥有 `CAP_SYS_ADMIN` 能力，防止非特权用户修改安全策略。\n\n- **策略继承约束**：  \n  通过 `pidns_memfd_noexec_scope(ns->parent)` 获取父 PID 命名空间的策略值 `parent_scope`，并确保当前命名空间的策略值 `scope` 不小于父策略（即不能更宽松）。实际写入前使用 `max(READ_ONCE(ns->memfd_noexec_scope), parent_scope)` 保证该约束。\n\n- **原子读写**：  \n  使用 `READ_ONCE()` 和 `WRITE_ONCE()` 对 `ns->memfd_noexec_scope` 进行访问，确保在并发环境下内存访问的可见性和顺序性。\n\n- **sysctl 注册**：  \n  通过 `register_sysctl(\"vm\", pid_ns_ctl_table_vm)` 将控制项注册到 `/proc/sys/vm/memfd_noexec` 路径下，供用户空间通过标准 sysctl 接口访问。\n\n- **条件编译**：  \n  整个功能仅在 `CONFIG_SYSCTL`（启用 sysctl 支持）和 `CONFIG_MEMFD_CREATE`（启用 memfd_create 系统调用）同时配置时编译，否则 `register_pid_ns_sysctl_table_vm` 为空内联函数，避免代码膨胀。\n\n## 4. 依赖关系\n\n- **`<linux/pid_namespace.h>`**：  \n  提供 `struct pid_namespace` 定义及辅助函数如 `task_active_pid_ns()` 和 `pidns_memfd_noexec_scope()`。\n\n- **`CONFIG_SYSCTL`**：  \n  内核配置选项，启用 sysctl 框架支持，提供 `register_sysctl`、`proc_dointvec_minmax` 等接口。\n\n- **`CONFIG_MEMFD_CREATE`**：  \n  内核配置选项，启用 `memfd_create()` 系统调用及相关功能（如 `memfd_noexec_scope` 字段）。\n\n- **能力子系统（Capabilities）**：  \n  依赖 `ns_capable()` 进行命名空间感知的权限检查。\n\n## 5. 使用场景\n\n- **安全策略配置**：  \n  系统管理员或容器运行时可通过写入 `/proc/sys/vm/memfd_noexec` 设置当前 PID 命名空间中 `memfd` 文件的执行限制级别（0=允许执行，1=禁止执行但可覆盖，2=严格禁止执行），用于防御基于内存文件的代码注入攻击。\n\n- **容器隔离**：  \n  在容器化环境中，不同容器运行在独立的 PID 命名空间中。父命名空间（如宿主机）可设置较严格的 `memfd_noexec` 策略，子容器无法降低该策略级别，从而实现自上而下的安全策略强制。\n\n- **运行时动态调整**：  \n  允许在系统运行期间动态调整 `memfd` 执行策略，无需重启或重新加载内核模块，提升系统灵活性与安全性。",
      "similarity": 0.6239564418792725,
      "chunks": []
    },
    {
      "source_file": "mm/page-writeback.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:59:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page-writeback.c`\n\n---\n\n# page-writeback.c 技术文档\n\n## 1. 文件概述\n\n`page-writeback.c` 是 Linux 内核内存管理子系统（MM）中的核心文件，负责实现**脏页回写（dirty page writeback）机制**。该机制用于控制和协调将修改过的页面（即“脏页”）从内存写回到持久化存储（如磁盘）的过程，以确保数据一致性、防止内存耗尽，并在系统负载与 I/O 带宽之间取得平衡。\n\n该文件主要提供以下功能：\n- 脏页数量的全局与每 BDI（Backing Device Info）级别的阈值管理\n- 脏页生成速率的动态限流（throttling）\n- 后台回写线程（如 `writeback` 线程）的触发逻辑\n- 支持基于 cgroup 的内存回写控制（当启用 `CONFIG_CGROUP_WRITEBACK` 时）\n- 与 `/proc/sys/vm` 中可调参数的交互接口\n\n## 2. 核心功能\n\n### 主要全局变量（可通过 sysctl 调整）\n| 变量名 | 默认值 | 说明 |\n|--------|--------|------|\n| `dirty_background_ratio` | 10 | 当脏页占可用内存比例达到此值时，启动后台回写 |\n| `vm_dirty_ratio` | 20 | 脏页比例硬上限，超过则阻塞写进程进行同步回写 |\n| `dirty_background_bytes` | 0 | 以字节为单位指定后台回写阈值（优先级高于 ratio） |\n| `vm_dirty_bytes` | 0 | 以字节为单位指定脏页硬上限（优先级高于 ratio） |\n| `dirty_writeback_interval` | 500 (5秒) | 后台回写线程的唤醒间隔（单位：厘秒） |\n| `dirty_expire_interval` | 3000 (30秒) | 脏页最大存活时间，超时强制回写 |\n| `laptop_mode` | 0 | 笔记本模式开关，减少磁盘活动以省电 |\n| `ratelimit_pages` | 32 | 每 CPU 脏页速率限制阈值 |\n\n### 关键数据结构\n- **`struct wb_domain`**  \n  回写域（writeback domain），用于聚合多个 BDI 的回写状态，支持全局或 per-memcg 的回写控制。\n  \n- **`struct dirty_throttle_control` (dtc)**  \n  脏页限流控制上下文，包含：\n  - `avail`：当前可脏化的内存总量\n  - `dirty`：当前脏页数量\n  - `thresh` / `bg_thresh`：硬/软回写阈值\n  - `wb_dirty` / `wb_thresh` / `wb_bg_thresh`：per-BDI 级别的对应值\n  - `pos_ratio`：用于计算回写速率的比例因子\n\n- **条件编译支持**  \n  通过 `CONFIG_CGROUP_WRITEBACK` 区分是否支持 memcg 级别的回写控制，提供 `GDTC_INIT`、`MDTC_INIT` 等宏及辅助函数（如 `mdtc_valid()`、`wb_min_max_ratio()`）。\n\n### 核心辅助函数（部分在截断代码中未完整显示）\n- `node_dirtyable_memory()`：计算指定 NUMA 节点中可用于脏页缓存的内存总量（包括空闲页 + 文件缓存页 - 保留页）。\n- `balance_dirty_pages()`：主限流函数，在进程写入时被调用，根据当前脏页水位决定是否休眠或触发回写。\n- `balance_dirty_pages_ratelimited()`：带速率限制的脏页平衡入口，避免频繁调用开销。\n\n## 3. 关键实现\n\n### 脏页阈值计算逻辑\n- 脏页上限基于 **“dirtyable memory”** 计算，即 `(free pages + file cache pages - kernel reserves)`。\n- 支持两种配置方式：**百分比（ratio）** 或 **绝对字节数（bytes）**，后者优先。\n- 当启用 `vm_highmem_is_dirtyable` 时，highmem 区域的空闲页也计入 dirtyable memory。\n\n### 动态限流机制\n- 使用 **`MAX_PAUSE`（最大 200ms）** 限制单次 `balance_dirty_pages()` 的休眠时间。\n- 引入 **`DIRTY_POLL_THRESH`（128KB）** 作为调用间隔优化阈值：若脏页增长过快，则提升休眠时间至最大值。\n- 通过 **`BANDWIDTH_INTERVAL`（200ms）** 动态估算存储设备的写入带宽，用于调整回写速率。\n\n### cgroup writeback 支持\n- 在 `CONFIG_CGROUP_WRITEBACK` 启用时：\n  - 每个 memcg 有独立的 `wb_domain`\n  - `dirty_throttle_control` 可关联全局（gdtc）或 memcg（mdtc）上下文\n  - BDI 的 min/max_ratio 根据其实际带宽动态缩放，实现公平分配\n\n### 老化与完成计数\n- 使用 `fprop_local_percpu` 结构跟踪每个 BDI 的回写完成情况。\n- `VM_COMPLETIONS_PERIOD_LEN`（3 秒）定义了回写完成率的老化周期，影响带宽估算的响应速度。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/swap.h>`、`<linux/pagevec.h>` 等，与页分配、回收机制紧密集成。\n- **VFS 层**：通过 `<linux/fs.h>`、`<linux/pagemap.h>` 与 address_space 和 inode 交互。\n- **块设备层**：通过 `<linux/blkdev.h>`、`<linux/backing-dev.h>` 获取 BDI 信息和 I/O 能力。\n- **调度与同步**：使用 `<linux/sched.h>`、`<linux/spinlock.h>`、`<linux/timer.h>` 实现休眠、锁和定时器。\n- **追踪系统**：集成 `<trace/events/writeback.h>` 提供回写事件追踪点。\n- **内部头文件**：包含 `\"internal.h\"` 获取 MM 子系统内部接口。\n\n## 5. 使用场景\n\n1. **用户空间写入文件**  \n   当进程通过 `write()` 修改文件页时，页被标记为脏，随后调用 `balance_dirty_pages_ratelimited()` 触发脏页控制。\n\n2. **内存压力下的页面回收**  \n   kswapd 或直接回收路径在需要释放内存时，可能调用回写逻辑清理脏页。\n\n3. **定期后台回写**  \n   `writeback` 内核线程按 `dirty_writeback_interval` 周期唤醒，检查并回写超过 `dirty_expire_interval` 的脏页。\n\n4. **系统关闭或 sync 调用**  \n   虽然主要同步逻辑在其他文件，但本文件提供的阈值和状态是决策基础。\n\n5. **容器环境中的资源隔离**  \n   启用 cgroup writeback 后，不同 memcg 的脏页回写相互隔离，避免一个容器的大量写入影响其他容器性能。\n\n6. **笔记本省电模式**  \n   当 `laptop_mode` 启用时，延迟回写以减少磁盘旋转时间，延长电池寿命。",
      "similarity": 0.6167752146720886,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "mm/page-writeback.c",
          "start_line": 495,
          "end_line": 600,
          "content": [
            "bool node_dirty_ok(struct pglist_data *pgdat)",
            "{",
            "\tunsigned long limit = node_dirty_limit(pgdat);",
            "\tunsigned long nr_pages = 0;",
            "",
            "\tnr_pages += node_page_state(pgdat, NR_FILE_DIRTY);",
            "\tnr_pages += node_page_state(pgdat, NR_WRITEBACK);",
            "",
            "\treturn nr_pages <= limit;",
            "}",
            "static int dirty_background_ratio_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret;",
            "",
            "\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write)",
            "\t\tdirty_background_bytes = 0;",
            "\treturn ret;",
            "}",
            "static int dirty_background_bytes_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret;",
            "\tunsigned long old_bytes = dirty_background_bytes;",
            "",
            "\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write) {",
            "\t\tif (DIV_ROUND_UP(dirty_background_bytes, PAGE_SIZE) >",
            "\t\t\t\t\t\t\t\tUINT_MAX) {",
            "\t\t\tdirty_background_bytes = old_bytes;",
            "\t\t\treturn -ERANGE;",
            "\t\t}",
            "\t\tdirty_background_ratio = 0;",
            "\t}",
            "\treturn ret;",
            "}",
            "static int dirty_ratio_handler(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos)",
            "{",
            "\tint old_ratio = vm_dirty_ratio;",
            "\tint ret;",
            "",
            "\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write && vm_dirty_ratio != old_ratio) {",
            "\t\tvm_dirty_bytes = 0;",
            "\t\twriteback_set_ratelimit();",
            "\t}",
            "\treturn ret;",
            "}",
            "static int dirty_bytes_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tunsigned long old_bytes = vm_dirty_bytes;",
            "\tint ret;",
            "",
            "\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write && vm_dirty_bytes != old_bytes) {",
            "\t\tif (DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE) > UINT_MAX) {",
            "\t\t\tvm_dirty_bytes = old_bytes;",
            "\t\t\treturn -ERANGE;",
            "\t\t}",
            "\t\twriteback_set_ratelimit();",
            "\t\tvm_dirty_ratio = 0;",
            "\t}",
            "\treturn ret;",
            "}",
            "static unsigned long wp_next_time(unsigned long cur_time)",
            "{",
            "\tcur_time += VM_COMPLETIONS_PERIOD_LEN;",
            "\t/* 0 has a special meaning... */",
            "\tif (!cur_time)",
            "\t\treturn 1;",
            "\treturn cur_time;",
            "}",
            "static void wb_domain_writeout_add(struct wb_domain *dom,",
            "\t\t\t\t   struct fprop_local_percpu *completions,",
            "\t\t\t\t   unsigned int max_prop_frac, long nr)",
            "{",
            "\t__fprop_add_percpu_max(&dom->completions, completions,",
            "\t\t\t       max_prop_frac, nr);",
            "\t/* First event after period switching was turned off? */",
            "\tif (unlikely(!dom->period_time)) {",
            "\t\t/*",
            "\t\t * We can race with other __bdi_writeout_inc calls here but",
            "\t\t * it does not cause any harm since the resulting time when",
            "\t\t * timer will fire and what is in writeout_period_time will be",
            "\t\t * roughly the same.",
            "\t\t */",
            "\t\tdom->period_time = wp_next_time(jiffies);",
            "\t\tmod_timer(&dom->period_timer, dom->period_time);",
            "\t}",
            "}",
            "static inline void __wb_writeout_add(struct bdi_writeback *wb, long nr)",
            "{",
            "\tstruct wb_domain *cgdom;",
            "",
            "\twb_stat_mod(wb, WB_WRITTEN, nr);",
            "\twb_domain_writeout_add(&global_wb_domain, &wb->completions,",
            "\t\t\t       wb->bdi->max_prop_frac, nr);",
            "",
            "\tcgdom = mem_cgroup_wb_domain(wb);",
            "\tif (cgdom)",
            "\t\twb_domain_writeout_add(cgdom, wb_memcg_completions(wb),",
            "\t\t\t\t       wb->bdi->max_prop_frac, nr);",
            "}"
          ],
          "function_name": "node_dirty_ok, dirty_background_ratio_handler, dirty_background_bytes_handler, dirty_ratio_handler, dirty_bytes_handler, wp_next_time, wb_domain_writeout_add, __wb_writeout_add",
          "description": "通过sysctl接口动态调整脏页写回参数，维护写回统计信息并周期性触发写回检查，确保系统内存使用符合预设策略。",
          "similarity": 0.7050877809524536
        },
        {
          "chunk_id": 4,
          "file_path": "mm/page-writeback.c",
          "start_line": 615,
          "end_line": 719,
          "content": [
            "void wb_writeout_inc(struct bdi_writeback *wb)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\t__wb_writeout_add(wb, 1);",
            "\tlocal_irq_restore(flags);",
            "}",
            "static void writeout_period(struct timer_list *t)",
            "{",
            "\tstruct wb_domain *dom = from_timer(dom, t, period_timer);",
            "\tint miss_periods = (jiffies - dom->period_time) /",
            "\t\t\t\t\t\t VM_COMPLETIONS_PERIOD_LEN;",
            "",
            "\tif (fprop_new_period(&dom->completions, miss_periods + 1)) {",
            "\t\tdom->period_time = wp_next_time(dom->period_time +",
            "\t\t\t\tmiss_periods * VM_COMPLETIONS_PERIOD_LEN);",
            "\t\tmod_timer(&dom->period_timer, dom->period_time);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Aging has zeroed all fractions. Stop wasting CPU on period",
            "\t\t * updates.",
            "\t\t */",
            "\t\tdom->period_time = 0;",
            "\t}",
            "}",
            "int wb_domain_init(struct wb_domain *dom, gfp_t gfp)",
            "{",
            "\tmemset(dom, 0, sizeof(*dom));",
            "",
            "\tspin_lock_init(&dom->lock);",
            "",
            "\ttimer_setup(&dom->period_timer, writeout_period, TIMER_DEFERRABLE);",
            "",
            "\tdom->dirty_limit_tstamp = jiffies;",
            "",
            "\treturn fprop_global_init(&dom->completions, gfp);",
            "}",
            "void wb_domain_exit(struct wb_domain *dom)",
            "{",
            "\tdel_timer_sync(&dom->period_timer);",
            "\tfprop_global_destroy(&dom->completions);",
            "}",
            "static int bdi_check_pages_limit(unsigned long pages)",
            "{",
            "\tunsigned long max_dirty_pages = global_dirtyable_memory();",
            "",
            "\tif (pages > max_dirty_pages)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static unsigned long bdi_ratio_from_pages(unsigned long pages)",
            "{",
            "\tunsigned long background_thresh;",
            "\tunsigned long dirty_thresh;",
            "\tunsigned long ratio;",
            "",
            "\tglobal_dirty_limits(&background_thresh, &dirty_thresh);",
            "\tratio = div64_u64(pages * 100ULL * BDI_RATIO_SCALE, dirty_thresh);",
            "",
            "\treturn ratio;",
            "}",
            "static u64 bdi_get_bytes(unsigned int ratio)",
            "{",
            "\tunsigned long background_thresh;",
            "\tunsigned long dirty_thresh;",
            "\tu64 bytes;",
            "",
            "\tglobal_dirty_limits(&background_thresh, &dirty_thresh);",
            "\tbytes = (dirty_thresh * PAGE_SIZE * ratio) / BDI_RATIO_SCALE / 100;",
            "",
            "\treturn bytes;",
            "}",
            "static int __bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)",
            "{",
            "\tunsigned int delta;",
            "\tint ret = 0;",
            "",
            "\tif (min_ratio > 100 * BDI_RATIO_SCALE)",
            "\t\treturn -EINVAL;",
            "\tmin_ratio *= BDI_RATIO_SCALE;",
            "",
            "\tspin_lock_bh(&bdi_lock);",
            "\tif (min_ratio > bdi->max_ratio) {",
            "\t\tret = -EINVAL;",
            "\t} else {",
            "\t\tif (min_ratio < bdi->min_ratio) {",
            "\t\t\tdelta = bdi->min_ratio - min_ratio;",
            "\t\t\tbdi_min_ratio -= delta;",
            "\t\t\tbdi->min_ratio = min_ratio;",
            "\t\t} else {",
            "\t\t\tdelta = min_ratio - bdi->min_ratio;",
            "\t\t\tif (bdi_min_ratio + delta < 100 * BDI_RATIO_SCALE) {",
            "\t\t\t\tbdi_min_ratio += delta;",
            "\t\t\t\tbdi->min_ratio = min_ratio;",
            "\t\t\t} else {",
            "\t\t\t\tret = -EINVAL;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tspin_unlock_bh(&bdi_lock);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "wb_writeout_inc, writeout_period, wb_domain_init, wb_domain_exit, bdi_check_pages_limit, bdi_ratio_from_pages, bdi_get_bytes, __bdi_set_min_ratio",
          "description": "实现写回统计增量记录、定时器驱动的写回周期校准及内存设备（bdi）的脏页限制验证与参数转换逻辑，支撑动态写回策略调整。",
          "similarity": 0.6899436712265015
        },
        {
          "chunk_id": 11,
          "file_path": "mm/page-writeback.c",
          "start_line": 2176,
          "end_line": 2404,
          "content": [
            "static int dirty_writeback_centisecs_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *length, loff_t *ppos)",
            "{",
            "\tunsigned int old_interval = dirty_writeback_interval;",
            "\tint ret;",
            "",
            "\tret = proc_dointvec(table, write, buffer, length, ppos);",
            "",
            "\t/*",
            "\t * Writing 0 to dirty_writeback_interval will disable periodic writeback",
            "\t * and a different non-zero value will wakeup the writeback threads.",
            "\t * wb_wakeup_delayed() would be more appropriate, but it's a pain to",
            "\t * iterate over all bdis and wbs.",
            "\t * The reason we do this is to make the change take effect immediately.",
            "\t */",
            "\tif (!ret && write && dirty_writeback_interval &&",
            "\t\tdirty_writeback_interval != old_interval)",
            "\t\twakeup_flusher_threads(WB_REASON_PERIODIC);",
            "",
            "\treturn ret;",
            "}",
            "void laptop_mode_timer_fn(struct timer_list *t)",
            "{",
            "\tstruct backing_dev_info *backing_dev_info =",
            "\t\tfrom_timer(backing_dev_info, t, laptop_mode_wb_timer);",
            "",
            "\twakeup_flusher_threads_bdi(backing_dev_info, WB_REASON_LAPTOP_TIMER);",
            "}",
            "void laptop_io_completion(struct backing_dev_info *info)",
            "{",
            "\tmod_timer(&info->laptop_mode_wb_timer, jiffies + laptop_mode);",
            "}",
            "void laptop_sync_completion(void)",
            "{",
            "\tstruct backing_dev_info *bdi;",
            "",
            "\trcu_read_lock();",
            "",
            "\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list)",
            "\t\tdel_timer(&bdi->laptop_mode_wb_timer);",
            "",
            "\trcu_read_unlock();",
            "}",
            "void writeback_set_ratelimit(void)",
            "{",
            "\tstruct wb_domain *dom = &global_wb_domain;",
            "\tunsigned long background_thresh;",
            "\tunsigned long dirty_thresh;",
            "",
            "\tglobal_dirty_limits(&background_thresh, &dirty_thresh);",
            "\tdom->dirty_limit = dirty_thresh;",
            "\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);",
            "\tif (ratelimit_pages < 16)",
            "\t\tratelimit_pages = 16;",
            "}",
            "static int page_writeback_cpu_online(unsigned int cpu)",
            "{",
            "\twriteback_set_ratelimit();",
            "\treturn 0;",
            "}",
            "void __init page_writeback_init(void)",
            "{",
            "\tBUG_ON(wb_domain_init(&global_wb_domain, GFP_KERNEL));",
            "",
            "\tcpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/writeback:online\",",
            "\t\t\t  page_writeback_cpu_online, NULL);",
            "\tcpuhp_setup_state(CPUHP_MM_WRITEBACK_DEAD, \"mm/writeback:dead\", NULL,",
            "\t\t\t  page_writeback_cpu_online);",
            "#ifdef CONFIG_SYSCTL",
            "\tregister_sysctl_init(\"vm\", vm_page_writeback_sysctls);",
            "#endif",
            "}",
            "void tag_pages_for_writeback(struct address_space *mapping,",
            "\t\t\t     pgoff_t start, pgoff_t end)",
            "{",
            "\tXA_STATE(xas, &mapping->i_pages, start);",
            "\tunsigned int tagged = 0;",
            "\tvoid *page;",
            "",
            "\txas_lock_irq(&xas);",
            "\txas_for_each_marked(&xas, page, end, PAGECACHE_TAG_DIRTY) {",
            "\t\txas_set_mark(&xas, PAGECACHE_TAG_TOWRITE);",
            "\t\tif (++tagged % XA_CHECK_SCHED)",
            "\t\t\tcontinue;",
            "",
            "\t\txas_pause(&xas);",
            "\t\txas_unlock_irq(&xas);",
            "\t\tcond_resched();",
            "\t\txas_lock_irq(&xas);",
            "\t}",
            "\txas_unlock_irq(&xas);",
            "}",
            "int write_cache_pages(struct address_space *mapping,",
            "\t\t      struct writeback_control *wbc, writepage_t writepage,",
            "\t\t      void *data)",
            "{",
            "\tint ret = 0;",
            "\tint done = 0;",
            "\tint error;",
            "\tstruct folio_batch fbatch;",
            "\tint nr_folios;",
            "\tpgoff_t index;",
            "\tpgoff_t end;\t\t/* Inclusive */",
            "\tpgoff_t done_index;",
            "\tint range_whole = 0;",
            "\txa_mark_t tag;",
            "",
            "\tfolio_batch_init(&fbatch);",
            "\tif (wbc->range_cyclic) {",
            "\t\tindex = mapping->writeback_index; /* prev offset */",
            "\t\tend = -1;",
            "\t} else {",
            "\t\tindex = wbc->range_start >> PAGE_SHIFT;",
            "\t\tend = wbc->range_end >> PAGE_SHIFT;",
            "\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)",
            "\t\t\trange_whole = 1;",
            "\t}",
            "\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages) {",
            "\t\ttag_pages_for_writeback(mapping, index, end);",
            "\t\ttag = PAGECACHE_TAG_TOWRITE;",
            "\t} else {",
            "\t\ttag = PAGECACHE_TAG_DIRTY;",
            "\t}",
            "\tdone_index = index;",
            "\twhile (!done && (index <= end)) {",
            "\t\tint i;",
            "",
            "\t\tnr_folios = filemap_get_folios_tag(mapping, &index, end,",
            "\t\t\t\ttag, &fbatch);",
            "",
            "\t\tif (nr_folios == 0)",
            "\t\t\tbreak;",
            "",
            "\t\tfor (i = 0; i < nr_folios; i++) {",
            "\t\t\tstruct folio *folio = fbatch.folios[i];",
            "\t\t\tunsigned long nr;",
            "",
            "\t\t\tdone_index = folio->index;",
            "",
            "\t\t\tfolio_lock(folio);",
            "",
            "\t\t\t/*",
            "\t\t\t * Page truncated or invalidated. We can freely skip it",
            "\t\t\t * then, even for data integrity operations: the page",
            "\t\t\t * has disappeared concurrently, so there could be no",
            "\t\t\t * real expectation of this data integrity operation",
            "\t\t\t * even if there is now a new, dirty page at the same",
            "\t\t\t * pagecache address.",
            "\t\t\t */",
            "\t\t\tif (unlikely(folio->mapping != mapping)) {",
            "continue_unlock:",
            "\t\t\t\tfolio_unlock(folio);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tif (!folio_test_dirty(folio)) {",
            "\t\t\t\t/* someone wrote it for us */",
            "\t\t\t\tgoto continue_unlock;",
            "\t\t\t}",
            "",
            "\t\t\tif (folio_test_writeback(folio)) {",
            "\t\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)",
            "\t\t\t\t\tfolio_wait_writeback(folio);",
            "\t\t\t\telse",
            "\t\t\t\t\tgoto continue_unlock;",
            "\t\t\t}",
            "",
            "\t\t\tBUG_ON(folio_test_writeback(folio));",
            "\t\t\tif (!folio_clear_dirty_for_io(folio))",
            "\t\t\t\tgoto continue_unlock;",
            "",
            "\t\t\ttrace_wbc_writepage(wbc, inode_to_bdi(mapping->host));",
            "\t\t\terror = writepage(folio, wbc, data);",
            "\t\t\tnr = folio_nr_pages(folio);",
            "\t\t\tif (unlikely(error)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * Handle errors according to the type of",
            "\t\t\t\t * writeback. There's no need to continue for",
            "\t\t\t\t * background writeback. Just push done_index",
            "\t\t\t\t * past this page so media errors won't choke",
            "\t\t\t\t * writeout for the entire file. For integrity",
            "\t\t\t\t * writeback, we must process the entire dirty",
            "\t\t\t\t * set regardless of errors because the fs may",
            "\t\t\t\t * still have state to clear for each page. In",
            "\t\t\t\t * that case we continue processing and return",
            "\t\t\t\t * the first error.",
            "\t\t\t\t */",
            "\t\t\t\tif (error == AOP_WRITEPAGE_ACTIVATE) {",
            "\t\t\t\t\tfolio_unlock(folio);",
            "\t\t\t\t\terror = 0;",
            "\t\t\t\t} else if (wbc->sync_mode != WB_SYNC_ALL) {",
            "\t\t\t\t\tret = error;",
            "\t\t\t\t\tdone_index = folio->index + nr;",
            "\t\t\t\t\tdone = 1;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tif (!ret)",
            "\t\t\t\t\tret = error;",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * We stop writing back only if we are not doing",
            "\t\t\t * integrity sync. In case of integrity sync we have to",
            "\t\t\t * keep going until we have written all the pages",
            "\t\t\t * we tagged for writeback prior to entering this loop.",
            "\t\t\t */",
            "\t\t\twbc->nr_to_write -= nr;",
            "\t\t\tif (wbc->nr_to_write <= 0 &&",
            "\t\t\t    wbc->sync_mode == WB_SYNC_NONE) {",
            "\t\t\t\tdone = 1;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tfolio_batch_release(&fbatch);",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\t/*",
            "\t * If we hit the last page and there is more work to be done: wrap",
            "\t * back the index back to the start of the file for the next",
            "\t * time we are called.",
            "\t */",
            "\tif (wbc->range_cyclic && !done)",
            "\t\tdone_index = 0;",
            "\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))",
            "\t\tmapping->writeback_index = done_index;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "dirty_writeback_centisecs_handler, laptop_mode_timer_fn, laptop_io_completion, laptop_sync_completion, writeback_set_ratelimit, page_writeback_cpu_online, page_writeback_init, tag_pages_for_writeback, write_cache_pages",
          "description": "dirty_writeback_centisecs_handler 设置脏页写回间隔，laptop_mode_timer_fn 处理笔记本模式下定时触发写回。writeback_set_ratelimit 根据CPU数量动态调整速率限制参数。tag_pages_for_writeback 标记待写回页面，write_cache_pages 执行实际的缓存页面写回流程。",
          "similarity": 0.6117996573448181
        },
        {
          "chunk_id": 7,
          "file_path": "mm/page-writeback.c",
          "start_line": 1221,
          "end_line": 1472,
          "content": [
            "static void wb_update_write_bandwidth(struct bdi_writeback *wb,",
            "\t\t\t\t      unsigned long elapsed,",
            "\t\t\t\t      unsigned long written)",
            "{",
            "\tconst unsigned long period = roundup_pow_of_two(3 * HZ);",
            "\tunsigned long avg = wb->avg_write_bandwidth;",
            "\tunsigned long old = wb->write_bandwidth;",
            "\tu64 bw;",
            "",
            "\t/*",
            "\t * bw = written * HZ / elapsed",
            "\t *",
            "\t *                   bw * elapsed + write_bandwidth * (period - elapsed)",
            "\t * write_bandwidth = ---------------------------------------------------",
            "\t *                                          period",
            "\t *",
            "\t * @written may have decreased due to folio_redirty_for_writepage().",
            "\t * Avoid underflowing @bw calculation.",
            "\t */",
            "\tbw = written - min(written, wb->written_stamp);",
            "\tbw *= HZ;",
            "\tif (unlikely(elapsed > period)) {",
            "\t\tbw = div64_ul(bw, elapsed);",
            "\t\tavg = bw;",
            "\t\tgoto out;",
            "\t}",
            "\tbw += (u64)wb->write_bandwidth * (period - elapsed);",
            "\tbw >>= ilog2(period);",
            "",
            "\t/*",
            "\t * one more level of smoothing, for filtering out sudden spikes",
            "\t */",
            "\tif (avg > old && old >= (unsigned long)bw)",
            "\t\tavg -= (avg - old) >> 3;",
            "",
            "\tif (avg < old && old <= (unsigned long)bw)",
            "\t\tavg += (old - avg) >> 3;",
            "",
            "out:",
            "\t/* keep avg > 0 to guarantee that tot > 0 if there are dirty wbs */",
            "\tavg = max(avg, 1LU);",
            "\tif (wb_has_dirty_io(wb)) {",
            "\t\tlong delta = avg - wb->avg_write_bandwidth;",
            "\t\tWARN_ON_ONCE(atomic_long_add_return(delta,",
            "\t\t\t\t\t&wb->bdi->tot_write_bandwidth) <= 0);",
            "\t}",
            "\twb->write_bandwidth = bw;",
            "\tWRITE_ONCE(wb->avg_write_bandwidth, avg);",
            "}",
            "static void update_dirty_limit(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct wb_domain *dom = dtc_dom(dtc);",
            "\tunsigned long thresh = dtc->thresh;",
            "\tunsigned long limit = dom->dirty_limit;",
            "",
            "\t/*",
            "\t * Follow up in one step.",
            "\t */",
            "\tif (limit < thresh) {",
            "\t\tlimit = thresh;",
            "\t\tgoto update;",
            "\t}",
            "",
            "\t/*",
            "\t * Follow down slowly. Use the higher one as the target, because thresh",
            "\t * may drop below dirty. This is exactly the reason to introduce",
            "\t * dom->dirty_limit which is guaranteed to lie above the dirty pages.",
            "\t */",
            "\tthresh = max(thresh, dtc->dirty);",
            "\tif (limit > thresh) {",
            "\t\tlimit -= (limit - thresh) >> 5;",
            "\t\tgoto update;",
            "\t}",
            "\treturn;",
            "update:",
            "\tdom->dirty_limit = limit;",
            "}",
            "static void domain_update_dirty_limit(struct dirty_throttle_control *dtc,",
            "\t\t\t\t      unsigned long now)",
            "{",
            "\tstruct wb_domain *dom = dtc_dom(dtc);",
            "",
            "\t/*",
            "\t * check locklessly first to optimize away locking for the most time",
            "\t */",
            "\tif (time_before(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL))",
            "\t\treturn;",
            "",
            "\tspin_lock(&dom->lock);",
            "\tif (time_after_eq(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL)) {",
            "\t\tupdate_dirty_limit(dtc);",
            "\t\tdom->dirty_limit_tstamp = now;",
            "\t}",
            "\tspin_unlock(&dom->lock);",
            "}",
            "static void wb_update_dirty_ratelimit(struct dirty_throttle_control *dtc,",
            "\t\t\t\t      unsigned long dirtied,",
            "\t\t\t\t      unsigned long elapsed)",
            "{",
            "\tstruct bdi_writeback *wb = dtc->wb;",
            "\tunsigned long dirty = dtc->dirty;",
            "\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);",
            "\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);",
            "\tunsigned long setpoint = (freerun + limit) / 2;",
            "\tunsigned long write_bw = wb->avg_write_bandwidth;",
            "\tunsigned long dirty_ratelimit = wb->dirty_ratelimit;",
            "\tunsigned long dirty_rate;",
            "\tunsigned long task_ratelimit;",
            "\tunsigned long balanced_dirty_ratelimit;",
            "\tunsigned long step;",
            "\tunsigned long x;",
            "\tunsigned long shift;",
            "",
            "\t/*",
            "\t * The dirty rate will match the writeout rate in long term, except",
            "\t * when dirty pages are truncated by userspace or re-dirtied by FS.",
            "\t */",
            "\tdirty_rate = (dirtied - wb->dirtied_stamp) * HZ / elapsed;",
            "",
            "\t/*",
            "\t * task_ratelimit reflects each dd's dirty rate for the past 200ms.",
            "\t */",
            "\ttask_ratelimit = (u64)dirty_ratelimit *",
            "\t\t\t\t\tdtc->pos_ratio >> RATELIMIT_CALC_SHIFT;",
            "\ttask_ratelimit++; /* it helps rampup dirty_ratelimit from tiny values */",
            "",
            "\t/*",
            "\t * A linear estimation of the \"balanced\" throttle rate. The theory is,",
            "\t * if there are N dd tasks, each throttled at task_ratelimit, the wb's",
            "\t * dirty_rate will be measured to be (N * task_ratelimit). So the below",
            "\t * formula will yield the balanced rate limit (write_bw / N).",
            "\t *",
            "\t * Note that the expanded form is not a pure rate feedback:",
            "\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate)\t\t     (1)",
            "\t * but also takes pos_ratio into account:",
            "\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate) * pos_ratio  (2)",
            "\t *",
            "\t * (1) is not realistic because pos_ratio also takes part in balancing",
            "\t * the dirty rate.  Consider the state",
            "\t *\tpos_ratio = 0.5\t\t\t\t\t\t     (3)",
            "\t *\trate = 2 * (write_bw / N)\t\t\t\t     (4)",
            "\t * If (1) is used, it will stuck in that state! Because each dd will",
            "\t * be throttled at",
            "\t *\ttask_ratelimit = pos_ratio * rate = (write_bw / N)\t     (5)",
            "\t * yielding",
            "\t *\tdirty_rate = N * task_ratelimit = write_bw\t\t     (6)",
            "\t * put (6) into (1) we get",
            "\t *\trate_(i+1) = rate_(i)\t\t\t\t\t     (7)",
            "\t *",
            "\t * So we end up using (2) to always keep",
            "\t *\trate_(i+1) ~= (write_bw / N)\t\t\t\t     (8)",
            "\t * regardless of the value of pos_ratio. As long as (8) is satisfied,",
            "\t * pos_ratio is able to drive itself to 1.0, which is not only where",
            "\t * the dirty count meet the setpoint, but also where the slope of",
            "\t * pos_ratio is most flat and hence task_ratelimit is least fluctuated.",
            "\t */",
            "\tbalanced_dirty_ratelimit = div_u64((u64)task_ratelimit * write_bw,",
            "\t\t\t\t\t   dirty_rate | 1);",
            "\t/*",
            "\t * balanced_dirty_ratelimit ~= (write_bw / N) <= write_bw",
            "\t */",
            "\tif (unlikely(balanced_dirty_ratelimit > write_bw))",
            "\t\tbalanced_dirty_ratelimit = write_bw;",
            "",
            "\t/*",
            "\t * We could safely do this and return immediately:",
            "\t *",
            "\t *\twb->dirty_ratelimit = balanced_dirty_ratelimit;",
            "\t *",
            "\t * However to get a more stable dirty_ratelimit, the below elaborated",
            "\t * code makes use of task_ratelimit to filter out singular points and",
            "\t * limit the step size.",
            "\t *",
            "\t * The below code essentially only uses the relative value of",
            "\t *",
            "\t *\ttask_ratelimit - dirty_ratelimit",
            "\t *\t= (pos_ratio - 1) * dirty_ratelimit",
            "\t *",
            "\t * which reflects the direction and size of dirty position error.",
            "\t */",
            "",
            "\t/*",
            "\t * dirty_ratelimit will follow balanced_dirty_ratelimit iff",
            "\t * task_ratelimit is on the same side of dirty_ratelimit, too.",
            "\t * For example, when",
            "\t * - dirty_ratelimit > balanced_dirty_ratelimit",
            "\t * - dirty_ratelimit > task_ratelimit (dirty pages are above setpoint)",
            "\t * lowering dirty_ratelimit will help meet both the position and rate",
            "\t * control targets. Otherwise, don't update dirty_ratelimit if it will",
            "\t * only help meet the rate target. After all, what the users ultimately",
            "\t * feel and care are stable dirty rate and small position error.",
            "\t *",
            "\t * |task_ratelimit - dirty_ratelimit| is used to limit the step size",
            "\t * and filter out the singular points of balanced_dirty_ratelimit. Which",
            "\t * keeps jumping around randomly and can even leap far away at times",
            "\t * due to the small 200ms estimation period of dirty_rate (we want to",
            "\t * keep that period small to reduce time lags).",
            "\t */",
            "\tstep = 0;",
            "",
            "\t/*",
            "\t * For strictlimit case, calculations above were based on wb counters",
            "\t * and limits (starting from pos_ratio = wb_position_ratio() and up to",
            "\t * balanced_dirty_ratelimit = task_ratelimit * write_bw / dirty_rate).",
            "\t * Hence, to calculate \"step\" properly, we have to use wb_dirty as",
            "\t * \"dirty\" and wb_setpoint as \"setpoint\".",
            "\t *",
            "\t * We rampup dirty_ratelimit forcibly if wb_dirty is low because",
            "\t * it's possible that wb_thresh is close to zero due to inactivity",
            "\t * of backing device.",
            "\t */",
            "\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {",
            "\t\tdirty = dtc->wb_dirty;",
            "\t\tif (dtc->wb_dirty < 8)",
            "\t\t\tsetpoint = dtc->wb_dirty + 1;",
            "\t\telse",
            "\t\t\tsetpoint = (dtc->wb_thresh + dtc->wb_bg_thresh) / 2;",
            "\t}",
            "",
            "\tif (dirty < setpoint) {",
            "\t\tx = min3(wb->balanced_dirty_ratelimit,",
            "\t\t\t balanced_dirty_ratelimit, task_ratelimit);",
            "\t\tif (dirty_ratelimit < x)",
            "\t\t\tstep = x - dirty_ratelimit;",
            "\t} else {",
            "\t\tx = max3(wb->balanced_dirty_ratelimit,",
            "\t\t\t balanced_dirty_ratelimit, task_ratelimit);",
            "\t\tif (dirty_ratelimit > x)",
            "\t\t\tstep = dirty_ratelimit - x;",
            "\t}",
            "",
            "\t/*",
            "\t * Don't pursue 100% rate matching. It's impossible since the balanced",
            "\t * rate itself is constantly fluctuating. So decrease the track speed",
            "\t * when it gets close to the target. Helps eliminate pointless tremors.",
            "\t */",
            "\tshift = dirty_ratelimit / (2 * step + 1);",
            "\tif (shift < BITS_PER_LONG)",
            "\t\tstep = DIV_ROUND_UP(step >> shift, 8);",
            "\telse",
            "\t\tstep = 0;",
            "",
            "\tif (dirty_ratelimit < balanced_dirty_ratelimit)",
            "\t\tdirty_ratelimit += step;",
            "\telse",
            "\t\tdirty_ratelimit -= step;",
            "",
            "\tWRITE_ONCE(wb->dirty_ratelimit, max(dirty_ratelimit, 1UL));",
            "\twb->balanced_dirty_ratelimit = balanced_dirty_ratelimit;",
            "",
            "\ttrace_bdi_dirty_ratelimit(wb, dirty_rate, task_ratelimit);",
            "}"
          ],
          "function_name": "wb_update_write_bandwidth, update_dirty_limit, domain_update_dirty_limit, wb_update_dirty_ratelimit",
          "description": "实现写带宽统计更新逻辑，包含平滑写入速率变化的算法，更新脏页限制的动态调整机制，以及根据当前脏页速率与写入能力计算目标脏页产生速率的控制逻辑，通过分层限速策略维持系统稳定。",
          "similarity": 0.610584557056427
        },
        {
          "chunk_id": 15,
          "file_path": "mm/page-writeback.c",
          "start_line": 3088,
          "end_line": 3109,
          "content": [
            "void folio_wait_writeback(struct folio *folio)",
            "{",
            "\twhile (folio_test_writeback(folio)) {",
            "\t\ttrace_folio_wait_writeback(folio, folio_mapping(folio));",
            "\t\tfolio_wait_bit(folio, PG_writeback);",
            "\t}",
            "}",
            "int folio_wait_writeback_killable(struct folio *folio)",
            "{",
            "\twhile (folio_test_writeback(folio)) {",
            "\t\ttrace_folio_wait_writeback(folio, folio_mapping(folio));",
            "\t\tif (folio_wait_bit_killable(folio, PG_writeback))",
            "\t\t\treturn -EINTR;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void folio_wait_stable(struct folio *folio)",
            "{",
            "\tif (mapping_stable_writes(folio_mapping(folio)))",
            "\t\tfolio_wait_writeback(folio);",
            "}"
          ],
          "function_name": "folio_wait_writeback, folio_wait_writeback_killable, folio_wait_stable",
          "description": "该代码段实现了与页面写回状态相关的同步机制。`folio_wait_writeback`持续阻塞直至指定页的writeback标志清除，`folio_wait_writeback_killable`则允许在等待期间被信号中断并返回-EINTR。`folio_wait_stable`通过判断映射稳定性决定是否触发写回等待，确保数据持久化后再执行后续操作。",
          "similarity": 0.6071354150772095
        }
      ]
    }
  ]
}