{
  "query": "SUNRPC协议错误处理与重传机制",
  "timestamp": "2025-12-26 01:26:21",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/spurious.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:09:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\spurious.c`\n\n---\n\n# `irq/spurious.c` 技术文档\n\n## 1. 文件概述\n\n`irq/spurious.c` 是 Linux 内核中断子系统中的一个关键组件，负责处理**伪中断**（spurious interrupts）和**错误路由中断**（misrouted interrupts）。当硬件中断未被任何中断处理程序正确处理（返回 `IRQ_NONE`）时，内核会怀疑该中断是伪中断或被错误路由到当前 IRQ 线。该文件实现了检测、诊断和恢复机制，包括：\n\n- 统计未处理中断次数并判断是否为“卡住”的 IRQ\n- 在启用 `irqfixup` 选项时尝试在其他 IRQ 线上查找真正的中断源（中断错位恢复）\n- 定期轮询被禁用的伪中断线以尝试恢复共享中断设备\n- 提供诊断信息（如调用栈和注册的处理函数列表）\n\n该机制对于提高系统在硬件或固件存在缺陷时的鲁棒性至关重要。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `irqfixup`：模块参数，控制伪中断修复行为（0=禁用，1=仅对未处理中断尝试修复，2=对标记为 `IRQF_IRQPOLL` 的中断也尝试修复）\n- `poll_spurious_irq_timer`：定时器，用于定期轮询被标记为 `IRQS_SPURIOUS_DISABLED` 的中断线\n- `irq_poll_cpu`：记录当前正在执行轮询任务的 CPU ID\n- `irq_poll_active`：原子变量，防止多个 CPU 同时执行轮询\n\n### 主要函数\n- `irq_wait_for_poll(struct irq_desc *desc)`  \n  等待轮询操作完成，避免与轮询线程竞争。在 SMP 系统中自旋等待 `IRQS_POLL_INPROGRESS` 标志清除。\n  \n- `try_one_irq(struct irq_desc *desc, bool force)`  \n  尝试在指定中断描述符上执行中断处理。跳过 PER_CPU、嵌套线程和显式标记为轮询的中断。若中断被禁用，则仅在 `force=true` 时处理。支持共享中断的 `IRQS_PENDING` 重试机制。\n\n- `misrouted_irq(int irq)`  \n  遍历所有 IRQ（除 0 和当前 IRQ），调用 `try_one_irq()` 尝试在其他线上找到真正的中断源。用于中断错位恢复。\n\n- `poll_spurious_irqs(struct timer_list *unused)`  \n  定时器回调函数，轮询所有被标记为 `IRQS_SPURIOUS_DISABLED` 的中断线，强制尝试处理（`force=true`）。\n\n- `__report_bad_irq()` / `report_bad_irq()`  \n  打印伪中断诊断信息，包括中断号、错误返回值、调用栈及所有注册的处理函数。\n\n- `try_misrouted_irq()`  \n  根据 `irqfixup` 级别判断是否应尝试中断错位恢复。\n\n- `note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)`  \n  中断处理结果分析入口。统计未处理中断，触发伪中断检测、诊断和恢复逻辑。\n\n## 3. 关键实现\n\n### 伪中断检测机制\n- 当 `note_interrupt()` 收到 `IRQ_NONE` 时，会递增中断描述符的未处理计数。\n- 若在 100,000 次中断中有 99,900 次未处理，则判定该 IRQ “卡住”，打印诊断信息并建议使用 `irqpoll` 启动参数。\n- 诊断信息包含所有注册的处理函数地址及符号名，便于调试。\n\n### 中断错位恢复（Misrouted IRQ Recovery）\n- 通过 `irqfixup` 内核参数启用（启动时传入 `irqfixup=1` 或 `2`）。\n- 当当前 IRQ 未被处理时，遍历其他所有 IRQ 线，尝试调用其处理函数（`try_one_irq()`）。\n- 仅适用于共享中断（`IRQF_SHARED`）且非 PER_CPU/嵌套线程类型。\n- 使用 `IRQS_POLL_INPROGRESS` 标志防止与正常中断处理冲突。\n\n### 轮询恢复机制\n- 被判定为伪中断的 IRQ 会被标记 `IRQS_SPURIOUS_DISABLED` 并禁用。\n- 启用 `irqfixup` 时，启动定时器 `poll_spurious_irq_timer`（间隔 100ms）。\n- 定时器回调 `poll_spurious_irqs()` 遍历所有 `IRQS_SPURIOUS_DISABLED` 的 IRQ，强制尝试处理（即使已禁用）。\n- 通过 `local_irq_disable/enable()` 保证轮询期间本地中断关闭，避免嵌套。\n\n### SMP 安全性\n- 使用 `irq_poll_active` 原子变量确保同一时间仅一个 CPU 执行轮询。\n- `irq_wait_for_poll()` 在 SMP 下自旋等待轮询完成，防止死锁。\n- 所有关键操作均在 `desc->lock` 保护下进行。\n\n### 线程化中断处理支持\n- 若主处理函数返回 `IRQ_WAKE_THREAD`，则延迟伪中断判断至下一次硬件中断，以等待线程处理结果。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：中断核心数据结构和 API\n  - `<linux/timer.h>`：定时器支持（用于轮询）\n  - `\"internals.h\"`：中断子系统内部接口\n\n- **内核配置依赖**：\n  - `CONFIG_SMP`：影响 `irq_wait_for_poll()` 的实现\n  - `irqfixup` 模块参数：控制恢复行为\n\n- **与其他模块交互**：\n  - 被通用中断处理流程（如 `handle_irq_event()`）调用\n  - 与中断描述符管理（`irq_desc`）紧密集成\n  - 依赖内核打印和栈回溯机制（`dump_stack()`）\n\n## 5. 使用场景\n\n1. **硬件/固件缺陷处理**：  \n   当 BIOS 或硬件错误地将设备中断路由到错误的 IRQ 线时，通过 `irqfixup` 机制尝试在其他线上找到真正的处理函数。\n\n2. **共享中断线故障恢复**：  \n   在多个设备共享同一 IRQ 线时，若其中一个设备故障产生持续中断但无处理函数响应，内核可禁用该线并定期轮询，避免系统被中断风暴拖垮。\n\n3. **系统调试与诊断**：  \n   当出现“nobody cared”中断错误时，自动打印详细的处理函数列表和调用栈，帮助开发者定位问题设备或驱动。\n\n4. **高可用性系统**：  \n   在无法立即修复硬件问题的生产环境中，通过 `irqpoll` 启动参数启用轮询机制，维持系统基本运行。\n\n5. **传统 PC 兼容性**：  \n   特别处理 IRQ 0（系统定时器），因其在传统 PC 架构中的特殊地位，即使在 `irqfixup=2` 模式下也始终尝试恢复。",
      "similarity": 0.5467616319656372,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 436,
          "end_line": 467,
          "content": [
            "int noirqdebug_setup(char *str)",
            "{",
            "\tnoirqdebug = 1;",
            "\tprintk(KERN_INFO \"IRQ lockup detection disabled\\n\");",
            "",
            "\treturn 1;",
            "}",
            "static int __init irqfixup_setup(char *str)",
            "{",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\tpr_warn(\"irqfixup boot option not supported with PREEMPT_RT\\n\");",
            "\t\treturn 1;",
            "\t}",
            "\tirqfixup = 1;",
            "\tprintk(KERN_WARNING \"Misrouted IRQ fixup support enabled.\\n\");",
            "\tprintk(KERN_WARNING \"This may impact system performance.\\n\");",
            "",
            "\treturn 1;",
            "}",
            "static int __init irqpoll_setup(char *str)",
            "{",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\tpr_warn(\"irqpoll boot option not supported with PREEMPT_RT\\n\");",
            "\t\treturn 1;",
            "\t}",
            "\tirqfixup = 2;",
            "\tprintk(KERN_WARNING \"Misrouted IRQ fixup and polling support \"",
            "\t\t\t\t\"enabled\\n\");",
            "\tprintk(KERN_WARNING \"This may significantly impact system \"",
            "\t\t\t\t\"performance\\n\");",
            "\treturn 1;",
            "}"
          ],
          "function_name": "noirqdebug_setup, irqfixup_setup, irqpoll_setup",
          "description": "提供启动参数配置接口，用于启用或禁用irqfixup和irqpoll功能，并输出相应警告信息。",
          "similarity": 0.5119408369064331
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 36,
          "end_line": 136,
          "content": [
            "bool irq_wait_for_poll(struct irq_desc *desc)",
            "\t__must_hold(&desc->lock)",
            "{",
            "\tif (WARN_ONCE(irq_poll_cpu == smp_processor_id(),",
            "\t\t      \"irq poll in progress on cpu %d for irq %d\\n\",",
            "\t\t      smp_processor_id(), desc->irq_data.irq))",
            "\t\treturn false;",
            "",
            "#ifdef CONFIG_SMP",
            "\tdo {",
            "\t\traw_spin_unlock(&desc->lock);",
            "\t\twhile (irqd_irq_inprogress(&desc->irq_data))",
            "\t\t\tcpu_relax();",
            "\t\traw_spin_lock(&desc->lock);",
            "\t} while (irqd_irq_inprogress(&desc->irq_data));",
            "\t/* Might have been disabled in meantime */",
            "\treturn !irqd_irq_disabled(&desc->irq_data) && desc->action;",
            "#else",
            "\treturn false;",
            "#endif",
            "}",
            "static int try_one_irq(struct irq_desc *desc, bool force)",
            "{",
            "\tirqreturn_t ret = IRQ_NONE;",
            "\tstruct irqaction *action;",
            "",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\t/*",
            "\t * PER_CPU, nested thread interrupts and interrupts explicitly",
            "\t * marked polled are excluded from polling.",
            "\t */",
            "\tif (irq_settings_is_per_cpu(desc) ||",
            "\t    irq_settings_is_nested_thread(desc) ||",
            "\t    irq_settings_is_polled(desc))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Do not poll disabled interrupts unless the spurious",
            "\t * disabled poller asks explicitly.",
            "\t */",
            "\tif (irqd_irq_disabled(&desc->irq_data) && !force)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * All handlers must agree on IRQF_SHARED, so we test just the",
            "\t * first.",
            "\t */",
            "\taction = desc->action;",
            "\tif (!action || !(action->flags & IRQF_SHARED) ||",
            "\t    (action->flags & __IRQF_TIMER))",
            "\t\tgoto out;",
            "",
            "\t/* Already running on another processor */",
            "\tif (irqd_irq_inprogress(&desc->irq_data)) {",
            "\t\t/*",
            "\t\t * Already running: If it is shared get the other",
            "\t\t * CPU to go looking for our mystery interrupt too",
            "\t\t */",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Mark it poll in progress */",
            "\tdesc->istate |= IRQS_POLL_INPROGRESS;",
            "\tdo {",
            "\t\tif (handle_irq_event(desc) == IRQ_HANDLED)",
            "\t\t\tret = IRQ_HANDLED;",
            "\t\t/* Make sure that there is still a valid action */",
            "\t\taction = desc->action;",
            "\t} while ((desc->istate & IRQS_PENDING) && action);",
            "\tdesc->istate &= ~IRQS_POLL_INPROGRESS;",
            "out:",
            "\traw_spin_unlock(&desc->lock);",
            "\treturn ret == IRQ_HANDLED;",
            "}",
            "static int misrouted_irq(int irq)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint i, ok = 0;",
            "",
            "\tif (atomic_inc_return(&irq_poll_active) != 1)",
            "\t\tgoto out;",
            "",
            "\tirq_poll_cpu = smp_processor_id();",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\tif (!i)",
            "\t\t\t continue;",
            "",
            "\t\tif (i == irq)\t/* Already tried */",
            "\t\t\tcontinue;",
            "",
            "\t\tif (try_one_irq(desc, false))",
            "\t\t\tok = 1;",
            "\t}",
            "out:",
            "\tatomic_dec(&irq_poll_active);",
            "\t/* So the caller can adjust the irq error counts */",
            "\treturn ok;",
            "}"
          ],
          "function_name": "irq_wait_for_poll, try_one_irq, misrouted_irq",
          "description": "实现了irq_wait_for_poll用于等待轮询完成，try_one_irq尝试处理单个中断，misrouted_irq尝试修复误路由中断。",
          "similarity": 0.48198777437210083
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 144,
          "end_line": 256,
          "content": [
            "static void poll_spurious_irqs(struct timer_list *unused)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint i;",
            "",
            "\tif (atomic_inc_return(&irq_poll_active) != 1)",
            "\t\tgoto out;",
            "\tirq_poll_cpu = smp_processor_id();",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\tunsigned int state;",
            "",
            "\t\tif (!i)",
            "\t\t\t continue;",
            "",
            "\t\t/* Racy but it doesn't matter */",
            "\t\tstate = desc->istate;",
            "\t\tbarrier();",
            "\t\tif (!(state & IRQS_SPURIOUS_DISABLED))",
            "\t\t\tcontinue;",
            "",
            "\t\tlocal_irq_disable();",
            "\t\ttry_one_irq(desc, true);",
            "\t\tlocal_irq_enable();",
            "\t}",
            "out:",
            "\tatomic_dec(&irq_poll_active);",
            "\tmod_timer(&poll_spurious_irq_timer,",
            "\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);",
            "}",
            "static inline int bad_action_ret(irqreturn_t action_ret)",
            "{",
            "\tunsigned int r = action_ret;",
            "",
            "\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))",
            "\t\treturn 0;",
            "\treturn 1;",
            "}",
            "static void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)",
            "{",
            "\tunsigned int irq = irq_desc_get_irq(desc);",
            "\tstruct irqaction *action;",
            "\tunsigned long flags;",
            "",
            "\tif (bad_action_ret(action_ret)) {",
            "\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",",
            "\t\t\t\tirq, action_ret);",
            "\t} else {",
            "\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"",
            "\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);",
            "\t}",
            "\tdump_stack();",
            "\tprintk(KERN_ERR \"handlers:\\n\");",
            "",
            "\t/*",
            "\t * We need to take desc->lock here. note_interrupt() is called",
            "\t * w/o desc->lock held, but IRQ_PROGRESS set. We might race",
            "\t * with something else removing an action. It's ok to take",
            "\t * desc->lock here. See synchronize_irq().",
            "\t */",
            "\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\tfor_each_action_of_desc(desc, action) {",
            "\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);",
            "\t\tif (action->thread_fn)",
            "\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",",
            "\t\t\t\t\taction->thread_fn, action->thread_fn);",
            "\t\tprintk(KERN_CONT \"\\n\");",
            "\t}",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "}",
            "static void report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)",
            "{",
            "\tstatic int count = 100;",
            "",
            "\tif (count > 0) {",
            "\t\tcount--;",
            "\t\t__report_bad_irq(desc, action_ret);",
            "\t}",
            "}",
            "static inline int",
            "try_misrouted_irq(unsigned int irq, struct irq_desc *desc,",
            "\t\t  irqreturn_t action_ret)",
            "{",
            "\tstruct irqaction *action;",
            "",
            "\tif (!irqfixup)",
            "\t\treturn 0;",
            "",
            "\t/* We didn't actually handle the IRQ - see if it was misrouted? */",
            "\tif (action_ret == IRQ_NONE)",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * But for 'irqfixup == 2' we also do it for handled interrupts if",
            "\t * they are marked as IRQF_IRQPOLL (or for irq zero, which is the",
            "\t * traditional PC timer interrupt.. Legacy)",
            "\t */",
            "\tif (irqfixup < 2)",
            "\t\treturn 0;",
            "",
            "\tif (!irq)",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * Since we don't get the descriptor lock, \"action\" can",
            "\t * change under us.  We don't really care, but we don't",
            "\t * want to follow a NULL pointer. So tell the compiler to",
            "\t * just load it once by using a barrier.",
            "\t */",
            "\taction = desc->action;",
            "\tbarrier();",
            "\treturn action && (action->flags & IRQF_IRQPOLL);",
            "}"
          ],
          "function_name": "poll_spurious_irqs, bad_action_ret, __report_bad_irq, report_bad_irq, try_misrouted_irq",
          "description": "poll_spurious_irqs定时扫描中断描述符并处理疑似虚假中断，包含错误报告辅助函数和误路由检测逻辑。",
          "similarity": 0.47773584723472595
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 272,
          "end_line": 432,
          "content": [
            "void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)",
            "{",
            "\tunsigned int irq;",
            "",
            "\tif (desc->istate & IRQS_POLL_INPROGRESS ||",
            "\t    irq_settings_is_polled(desc))",
            "\t\treturn;",
            "",
            "\tif (bad_action_ret(action_ret)) {",
            "\t\treport_bad_irq(desc, action_ret);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * We cannot call note_interrupt from the threaded handler",
            "\t * because we need to look at the compound of all handlers",
            "\t * (primary and threaded). Aside of that in the threaded",
            "\t * shared case we have no serialization against an incoming",
            "\t * hardware interrupt while we are dealing with a threaded",
            "\t * result.",
            "\t *",
            "\t * So in case a thread is woken, we just note the fact and",
            "\t * defer the analysis to the next hardware interrupt.",
            "\t *",
            "\t * The threaded handlers store whether they successfully",
            "\t * handled an interrupt and we check whether that number",
            "\t * changed versus the last invocation.",
            "\t *",
            "\t * We could handle all interrupts with the delayed by one",
            "\t * mechanism, but for the non forced threaded case we'd just",
            "\t * add pointless overhead to the straight hardirq interrupts",
            "\t * for the sake of a few lines less code.",
            "\t */",
            "\tif (action_ret & IRQ_WAKE_THREAD) {",
            "\t\t/*",
            "\t\t * There is a thread woken. Check whether one of the",
            "\t\t * shared primary handlers returned IRQ_HANDLED. If",
            "\t\t * not we defer the spurious detection to the next",
            "\t\t * interrupt.",
            "\t\t */",
            "\t\tif (action_ret == IRQ_WAKE_THREAD) {",
            "\t\t\tint handled;",
            "\t\t\t/*",
            "\t\t\t * We use bit 31 of thread_handled_last to",
            "\t\t\t * denote the deferred spurious detection",
            "\t\t\t * active. No locking necessary as",
            "\t\t\t * thread_handled_last is only accessed here",
            "\t\t\t * and we have the guarantee that hard",
            "\t\t\t * interrupts are not reentrant.",
            "\t\t\t */",
            "\t\t\tif (!(desc->threads_handled_last & SPURIOUS_DEFERRED)) {",
            "\t\t\t\tdesc->threads_handled_last |= SPURIOUS_DEFERRED;",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\t/*",
            "\t\t\t * Check whether one of the threaded handlers",
            "\t\t\t * returned IRQ_HANDLED since the last",
            "\t\t\t * interrupt happened.",
            "\t\t\t *",
            "\t\t\t * For simplicity we just set bit 31, as it is",
            "\t\t\t * set in threads_handled_last as well. So we",
            "\t\t\t * avoid extra masking. And we really do not",
            "\t\t\t * care about the high bits of the handled",
            "\t\t\t * count. We just care about the count being",
            "\t\t\t * different than the one we saw before.",
            "\t\t\t */",
            "\t\t\thandled = atomic_read(&desc->threads_handled);",
            "\t\t\thandled |= SPURIOUS_DEFERRED;",
            "\t\t\tif (handled != desc->threads_handled_last) {",
            "\t\t\t\taction_ret = IRQ_HANDLED;",
            "\t\t\t\t/*",
            "\t\t\t\t * Note: We keep the SPURIOUS_DEFERRED",
            "\t\t\t\t * bit set. We are handling the",
            "\t\t\t\t * previous invocation right now.",
            "\t\t\t\t * Keep it for the current one, so the",
            "\t\t\t\t * next hardware interrupt will",
            "\t\t\t\t * account for it.",
            "\t\t\t\t */",
            "\t\t\t\tdesc->threads_handled_last = handled;",
            "\t\t\t} else {",
            "\t\t\t\t/*",
            "\t\t\t\t * None of the threaded handlers felt",
            "\t\t\t\t * responsible for the last interrupt",
            "\t\t\t\t *",
            "\t\t\t\t * We keep the SPURIOUS_DEFERRED bit",
            "\t\t\t\t * set in threads_handled_last as we",
            "\t\t\t\t * need to account for the current",
            "\t\t\t\t * interrupt as well.",
            "\t\t\t\t */",
            "\t\t\t\taction_ret = IRQ_NONE;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * One of the primary handlers returned",
            "\t\t\t * IRQ_HANDLED. So we don't care about the",
            "\t\t\t * threaded handlers on the same line. Clear",
            "\t\t\t * the deferred detection bit.",
            "\t\t\t *",
            "\t\t\t * In theory we could/should check whether the",
            "\t\t\t * deferred bit is set and take the result of",
            "\t\t\t * the previous run into account here as",
            "\t\t\t * well. But it's really not worth the",
            "\t\t\t * trouble. If every other interrupt is",
            "\t\t\t * handled we never trigger the spurious",
            "\t\t\t * detector. And if this is just the one out",
            "\t\t\t * of 100k unhandled ones which is handled",
            "\t\t\t * then we merily delay the spurious detection",
            "\t\t\t * by one hard interrupt. Not a real problem.",
            "\t\t\t */",
            "\t\t\tdesc->threads_handled_last &= ~SPURIOUS_DEFERRED;",
            "\t\t}",
            "\t}",
            "",
            "\tif (unlikely(action_ret == IRQ_NONE)) {",
            "\t\t/*",
            "\t\t * If we are seeing only the odd spurious IRQ caused by",
            "\t\t * bus asynchronicity then don't eventually trigger an error,",
            "\t\t * otherwise the counter becomes a doomsday timer for otherwise",
            "\t\t * working systems",
            "\t\t */",
            "\t\tif (time_after(jiffies, desc->last_unhandled + HZ/10))",
            "\t\t\tdesc->irqs_unhandled = 1;",
            "\t\telse",
            "\t\t\tdesc->irqs_unhandled++;",
            "\t\tdesc->last_unhandled = jiffies;",
            "\t}",
            "",
            "\tirq = irq_desc_get_irq(desc);",
            "\tif (unlikely(try_misrouted_irq(irq, desc, action_ret))) {",
            "\t\tint ok = misrouted_irq(irq);",
            "\t\tif (action_ret == IRQ_NONE)",
            "\t\t\tdesc->irqs_unhandled -= ok;",
            "\t}",
            "",
            "\tif (likely(!desc->irqs_unhandled))",
            "\t\treturn;",
            "",
            "\t/* Now getting into unhandled irq detection */",
            "\tdesc->irq_count++;",
            "\tif (likely(desc->irq_count < 100000))",
            "\t\treturn;",
            "",
            "\tdesc->irq_count = 0;",
            "\tif (unlikely(desc->irqs_unhandled > 99900)) {",
            "\t\t/*",
            "\t\t * The interrupt is stuck",
            "\t\t */",
            "\t\t__report_bad_irq(desc, action_ret);",
            "\t\t/*",
            "\t\t * Now kill the IRQ",
            "\t\t */",
            "\t\tprintk(KERN_EMERG \"Disabling IRQ #%d\\n\", irq);",
            "\t\tdesc->istate |= IRQS_SPURIOUS_DISABLED;",
            "\t\tdesc->depth++;",
            "\t\tirq_disable(desc);",
            "",
            "\t\tmod_timer(&poll_spurious_irq_timer,",
            "\t\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);",
            "\t}",
            "\tdesc->irqs_unhandled = 0;",
            "}"
          ],
          "function_name": "note_interrupt",
          "description": "note_interrupt记录中断事件，检测未处理中断并触发报告，处理线程唤醒场景下的特殊逻辑。",
          "similarity": 0.4728127121925354
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 1,
          "end_line": 35,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2004 Linus Torvalds, Ingo Molnar",
            " *",
            " * This file contains spurious interrupt handling.",
            " */",
            "",
            "#include <linux/jiffies.h>",
            "#include <linux/irq.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/timer.h>",
            "",
            "#include \"internals.h\"",
            "",
            "static int irqfixup __read_mostly;",
            "",
            "#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)",
            "static void poll_spurious_irqs(struct timer_list *unused);",
            "static DEFINE_TIMER(poll_spurious_irq_timer, poll_spurious_irqs);",
            "static int irq_poll_cpu;",
            "static atomic_t irq_poll_active;",
            "",
            "/*",
            " * We wait here for a poller to finish.",
            " *",
            " * If the poll runs on this CPU, then we yell loudly and return",
            " * false. That will leave the interrupt line disabled in the worst",
            " * case, but it should never happen.",
            " *",
            " * We wait until the poller is done and then recheck disabled and",
            " * action (about to be disabled). Only if it's still active, we return",
            " * true and let the handler run.",
            " */"
          ],
          "function_name": null,
          "description": "定义了处理虚假中断的相关变量和定时器，用于周期性地扫描和处理可能存在的虚假中断。",
          "similarity": 0.4589344561100006
        }
      ]
    },
    {
      "source_file": "kernel/bpf/reuseport_array.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:29:05\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\reuseport_array.c`\n\n---\n\n# `bpf/reuseport_array.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/reuseport_array.c` 实现了一个特殊的 BPF map 类型——**reuseport array**，用于将支持 `SO_REUSEPORT` 的 TCP/UDP socket 与 BPF 程序关联。该 map 允许用户空间通过文件描述符（fd）将 socket 注册到 map 中，BPF 程序（如 `BPF_SK_REUSEPORT_SELECT`）可在运行时根据负载均衡策略选择目标 socket。此机制主要用于实现用户态可编程的 socket 选择逻辑，提升高并发网络服务的负载均衡能力。\n\n## 2. 核心功能\n\n### 数据结构\n- **`struct reuseport_array`**  \n  继承自 `struct bpf_map`，其 `ptrs[]` 成员是一个 RCU 保护的 `struct sock *` 数组，每个元素指向一个已注册的 `SO_REUSEPORT` socket。\n\n### 主要函数\n- **`bpf_sk_reuseport_detach(struct sock *sk)`**  \n  从 reuseport array 中安全移除指定 socket，通常在 socket 关闭或断开连接时调用。\n  \n- **`reuseport_array_alloc_check()`**  \n  验证 map 创建参数，仅允许 `value_size` 为 `sizeof(u32)` 或 `sizeof(u64)`（用于传递 fd）。\n\n- **`reuseport_array_lookup_elem()`**  \n  通过 key（索引）查找对应的 socket 指针（RCU 读取）。\n\n- **`reuseport_array_delete_elem()`**  \n  从 map 中删除指定索引的 socket（需持有 `reuseport_lock`）。\n\n- **`reuseport_array_free()`**  \n  释放整个 reuseport array，清理所有关联的 socket 引用。\n\n- **`reuseport_array_alloc()`**  \n  分配并初始化 reuseport array 内存。\n\n- **`bpf_fd_reuseport_array_lookup_elem()`**  \n  用户态 lookup 接口：返回 socket 的 cookie（`u64`），而非内核指针。\n\n- **`bpf_fd_reuseport_array_update_elem()`**  \n  用户态 update 接口：通过 fd 将 socket 注册到 map 指定索引位置。\n\n- **`reuseport_array_get_next_key()`**  \n  支持遍历 map 的下一个有效 key（代码片段未完整，但功能明确）。\n\n- **`reuseport_array_update_check()`**  \n  验证待注册 socket 是否满足条件（协议、地址族、SO_REUSEPORT 状态等）。\n\n## 3. 关键实现\n\n### 并发安全机制\n- **双重锁保护**：  \n  - `reuseport_lock`（全局自旋锁）：保护 map 与 reuseport 组的一致性。  \n  - `sk->sk_callback_lock`（socket 自旋锁）：保护 `sk_user_data` 字段的读写，避免与 `bpf_sk_reuseport_detach()` 竞争。\n- **RCU 机制**：  \n  `ptrs[]` 数组通过 RCU 读取（`rcu_dereference()`），写入时使用 `RCU_INIT_POINTER()` 或 `rcu_assign_pointer()`，确保无锁读取的安全性。\n- **引用解耦**：  \n  在 `reuseport_array_free()` 中，通过 `sk_callback_lock` 清理 `sk_user_data`，确保 array 释放前所有 socket 停止引用它。\n\n### Socket 注册验证\n`reuseport_array_update_check()` 严格校验 socket：\n- 协议必须为 TCP/UDP；\n- 地址族必须为 IPv4/IPv6；\n- socket 必须已绑定（`sk_hashed`）且启用 `SO_REUSEPORT`（`sk_reuseport_cb` 非空）；\n- `sk_user_data` 未被占用（避免重复注册）。\n\n### 用户态接口设计\n- **Update 操作**：传入 fd，内核通过 `sockfd_lookup()` 获取 socket，并验证其有效性。\n- **Lookup 操作**：返回 `__sock_gen_cookie(sk)`（唯一 socket 标识），而非内核地址，防止信息泄露。\n\n### 内存布局\n- 使用 `struct_size(array, ptrs, max_entries)` 动态分配连续内存，包含 map 元数据和指针数组。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：  \n  依赖 `bpf_map` 基础框架（`<linux/bpf.h>`），通过 `bpf_map_area_alloc/free` 管理内存。\n- **网络子系统**：  \n  - `SO_REUSEPORT` 机制（`<net/sock_reuseport.h>`）；  \n  - socket 核心结构（`struct sock`）及其状态标志（`sk_hashed`, `sk_reuseport_cb`）；  \n  - socket 生命周期管理（`sock_diag.h`）。\n- **同步原语**：  \n  依赖 RCU、自旋锁（`reuseport_lock`）和 BH 锁（`sk_callback_lock`）。\n- **BTF 支持**：  \n  通过 `BTF_ID` 宏导出类型信息（`<linux/btf_ids.h>`）。\n\n## 5. 使用场景\n\n1. **用户态负载均衡**：  \n   应用程序创建多个 `SO_REUSEPORT` socket，通过 BPF map 注册到内核。BPF 程序（如 `BPF_SK_REUSEPORT_SELECT`）根据自定义策略（如一致性哈希）选择目标 socket，实现高效分发。\n\n2. **服务热更新**：  \n   新旧服务实例的 socket 可同时注册到 map，BPF 程序平滑切换流量，避免连接中断。\n\n3. **安全隔离**：  \n   通过 BPF 程序限制特定流量仅路由到指定 socket，增强服务安全性。\n\n4. **性能监控**：  \n   结合 BPF tracepoint，监控 reuseport socket 的选择分布，优化负载均衡策略。",
      "similarity": 0.5439526438713074,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/reuseport_array.c",
          "start_line": 22,
          "end_line": 132,
          "content": [
            "void bpf_sk_reuseport_detach(struct sock *sk)",
            "{",
            "\tstruct sock __rcu **socks;",
            "",
            "\twrite_lock_bh(&sk->sk_callback_lock);",
            "\tsocks = __locked_read_sk_user_data_with_flags(sk, SK_USER_DATA_BPF);",
            "\tif (socks) {",
            "\t\tWRITE_ONCE(sk->sk_user_data, NULL);",
            "\t\t/*",
            "\t\t * Do not move this NULL assignment outside of",
            "\t\t * sk->sk_callback_lock because there is",
            "\t\t * a race with reuseport_array_free()",
            "\t\t * which does not hold the reuseport_lock.",
            "\t\t */",
            "\t\tRCU_INIT_POINTER(*socks, NULL);",
            "\t}",
            "\twrite_unlock_bh(&sk->sk_callback_lock);",
            "}",
            "static int reuseport_array_alloc_check(union bpf_attr *attr)",
            "{",
            "\tif (attr->value_size != sizeof(u32) &&",
            "\t    attr->value_size != sizeof(u64))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn array_map_alloc_check(attr);",
            "}",
            "static long reuseport_array_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\tstruct reuseport_array *array = reuseport_array(map);",
            "\tu32 index = *(u32 *)key;",
            "\tstruct sock *sk;",
            "\tint err;",
            "",
            "\tif (index >= map->max_entries)",
            "\t\treturn -E2BIG;",
            "",
            "\tif (!rcu_access_pointer(array->ptrs[index]))",
            "\t\treturn -ENOENT;",
            "",
            "\tspin_lock_bh(&reuseport_lock);",
            "",
            "\tsk = rcu_dereference_protected(array->ptrs[index],",
            "\t\t\t\t       lockdep_is_held(&reuseport_lock));",
            "\tif (sk) {",
            "\t\twrite_lock_bh(&sk->sk_callback_lock);",
            "\t\tWRITE_ONCE(sk->sk_user_data, NULL);",
            "\t\tRCU_INIT_POINTER(array->ptrs[index], NULL);",
            "\t\twrite_unlock_bh(&sk->sk_callback_lock);",
            "\t\terr = 0;",
            "\t} else {",
            "\t\terr = -ENOENT;",
            "\t}",
            "",
            "\tspin_unlock_bh(&reuseport_lock);",
            "",
            "\treturn err;",
            "}",
            "static void reuseport_array_free(struct bpf_map *map)",
            "{",
            "\tstruct reuseport_array *array = reuseport_array(map);",
            "\tstruct sock *sk;",
            "\tu32 i;",
            "",
            "\t/*",
            "\t * ops->map_*_elem() will not be able to access this",
            "\t * array now. Hence, this function only races with",
            "\t * bpf_sk_reuseport_detach() which was triggered by",
            "\t * close() or disconnect().",
            "\t *",
            "\t * This function and bpf_sk_reuseport_detach() are",
            "\t * both removing sk from \"array\".  Who removes it",
            "\t * first does not matter.",
            "\t *",
            "\t * The only concern here is bpf_sk_reuseport_detach()",
            "\t * may access \"array\" which is being freed here.",
            "\t * bpf_sk_reuseport_detach() access this \"array\"",
            "\t * through sk->sk_user_data _and_ with sk->sk_callback_lock",
            "\t * held which is enough because this \"array\" is not freed",
            "\t * until all sk->sk_user_data has stopped referencing this \"array\".",
            "\t *",
            "\t * Hence, due to the above, taking \"reuseport_lock\" is not",
            "\t * needed here.",
            "\t */",
            "",
            "\t/*",
            "\t * Since reuseport_lock is not taken, sk is accessed under",
            "\t * rcu_read_lock()",
            "\t */",
            "\trcu_read_lock();",
            "\tfor (i = 0; i < map->max_entries; i++) {",
            "\t\tsk = rcu_dereference(array->ptrs[i]);",
            "\t\tif (sk) {",
            "\t\t\twrite_lock_bh(&sk->sk_callback_lock);",
            "\t\t\t/*",
            "\t\t\t * No need for WRITE_ONCE(). At this point,",
            "\t\t\t * no one is reading it without taking the",
            "\t\t\t * sk->sk_callback_lock.",
            "\t\t\t */",
            "\t\t\tsk->sk_user_data = NULL;",
            "\t\t\twrite_unlock_bh(&sk->sk_callback_lock);",
            "\t\t\tRCU_INIT_POINTER(array->ptrs[i], NULL);",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Once reaching here, all sk->sk_user_data is not",
            "\t * referencing this \"array\". \"array\" can be freed now.",
            "\t */",
            "\tbpf_map_area_free(array);",
            "}"
          ],
          "function_name": "bpf_sk_reuseport_detach, reuseport_array_alloc_check, reuseport_array_delete_elem, reuseport_array_free",
          "description": "实现重用端口数组的操作函数，包括从套接字分离、分配检查、删除元素和释放内存。通过锁和RCU机制确保并发安全性，处理套接字引用计数和数组元素的原子操作。",
          "similarity": 0.5631632208824158
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/reuseport_array.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (c) 2018 Facebook",
            " */",
            "#include <linux/bpf.h>",
            "#include <linux/err.h>",
            "#include <linux/sock_diag.h>",
            "#include <net/sock_reuseport.h>",
            "#include <linux/btf_ids.h>",
            "",
            "struct reuseport_array {",
            "\tstruct bpf_map map;",
            "\tstruct sock __rcu *ptrs[];",
            "};",
            "",
            "static struct reuseport_array *reuseport_array(struct bpf_map *map)",
            "{",
            "\treturn (struct reuseport_array *)map;",
            "}",
            "",
            "/* The caller must hold the reuseport_lock */"
          ],
          "function_name": null,
          "description": "定义reuseport_array结构体，包含bpf_map和指向sock的指针数组，提供将bpf_map转换为该结构的辅助函数，用于实现BPF重用端口数组的数据结构。",
          "similarity": 0.5166563987731934
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/reuseport_array.c",
          "start_line": 165,
          "end_line": 306,
          "content": [
            "int bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t       void *value)",
            "{",
            "\tstruct sock *sk;",
            "\tint err;",
            "",
            "\tif (map->value_size != sizeof(u64))",
            "\t\treturn -ENOSPC;",
            "",
            "\trcu_read_lock();",
            "\tsk = reuseport_array_lookup_elem(map, key);",
            "\tif (sk) {",
            "\t\t*(u64 *)value = __sock_gen_cookie(sk);",
            "\t\terr = 0;",
            "\t} else {",
            "\t\terr = -ENOENT;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn err;",
            "}",
            "static int",
            "reuseport_array_update_check(const struct reuseport_array *array,",
            "\t\t\t     const struct sock *nsk,",
            "\t\t\t     const struct sock *osk,",
            "\t\t\t     const struct sock_reuseport *nsk_reuse,",
            "\t\t\t     u32 map_flags)",
            "{",
            "\tif (osk && map_flags == BPF_NOEXIST)",
            "\t\treturn -EEXIST;",
            "",
            "\tif (!osk && map_flags == BPF_EXIST)",
            "\t\treturn -ENOENT;",
            "",
            "\tif (nsk->sk_protocol != IPPROTO_UDP && nsk->sk_protocol != IPPROTO_TCP)",
            "\t\treturn -ENOTSUPP;",
            "",
            "\tif (nsk->sk_family != AF_INET && nsk->sk_family != AF_INET6)",
            "\t\treturn -ENOTSUPP;",
            "",
            "\tif (nsk->sk_type != SOCK_STREAM && nsk->sk_type != SOCK_DGRAM)",
            "\t\treturn -ENOTSUPP;",
            "",
            "\t/*",
            "\t * sk must be hashed (i.e. listening in the TCP case or binded",
            "\t * in the UDP case) and",
            "\t * it must also be a SO_REUSEPORT sk (i.e. reuse cannot be NULL).",
            "\t *",
            "\t * Also, sk will be used in bpf helper that is protected by",
            "\t * rcu_read_lock().",
            "\t */",
            "\tif (!sock_flag(nsk, SOCK_RCU_FREE) || !sk_hashed(nsk) || !nsk_reuse)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* READ_ONCE because the sk->sk_callback_lock may not be held here */",
            "\tif (READ_ONCE(nsk->sk_user_data))",
            "\t\treturn -EBUSY;",
            "",
            "\treturn 0;",
            "}",
            "int bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t       void *value, u64 map_flags)",
            "{",
            "\tstruct reuseport_array *array = reuseport_array(map);",
            "\tstruct sock *free_osk = NULL, *osk, *nsk;",
            "\tstruct sock_reuseport *reuse;",
            "\tu32 index = *(u32 *)key;",
            "\tuintptr_t sk_user_data;",
            "\tstruct socket *socket;",
            "\tint err, fd;",
            "",
            "\tif (map_flags > BPF_EXIST)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (index >= map->max_entries)",
            "\t\treturn -E2BIG;",
            "",
            "\tif (map->value_size == sizeof(u64)) {",
            "\t\tu64 fd64 = *(u64 *)value;",
            "",
            "\t\tif (fd64 > S32_MAX)",
            "\t\t\treturn -EINVAL;",
            "\t\tfd = fd64;",
            "\t} else {",
            "\t\tfd = *(int *)value;",
            "\t}",
            "",
            "\tsocket = sockfd_lookup(fd, &err);",
            "\tif (!socket)",
            "\t\treturn err;",
            "",
            "\tnsk = socket->sk;",
            "\tif (!nsk) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto put_file;",
            "\t}",
            "",
            "\t/* Quick checks before taking reuseport_lock */",
            "\terr = reuseport_array_update_check(array, nsk,",
            "\t\t\t\t\t   rcu_access_pointer(array->ptrs[index]),",
            "\t\t\t\t\t   rcu_access_pointer(nsk->sk_reuseport_cb),",
            "\t\t\t\t\t   map_flags);",
            "\tif (err)",
            "\t\tgoto put_file;",
            "",
            "\tspin_lock_bh(&reuseport_lock);",
            "\t/*",
            "\t * Some of the checks only need reuseport_lock",
            "\t * but it is done under sk_callback_lock also",
            "\t * for simplicity reason.",
            "\t */",
            "\twrite_lock_bh(&nsk->sk_callback_lock);",
            "",
            "\tosk = rcu_dereference_protected(array->ptrs[index],",
            "\t\t\t\t\tlockdep_is_held(&reuseport_lock));",
            "\treuse = rcu_dereference_protected(nsk->sk_reuseport_cb,",
            "\t\t\t\t\t  lockdep_is_held(&reuseport_lock));",
            "\terr = reuseport_array_update_check(array, nsk, osk, reuse, map_flags);",
            "\tif (err)",
            "\t\tgoto put_file_unlock;",
            "",
            "\tsk_user_data = (uintptr_t)&array->ptrs[index] | SK_USER_DATA_NOCOPY |",
            "\t\tSK_USER_DATA_BPF;",
            "\tWRITE_ONCE(nsk->sk_user_data, (void *)sk_user_data);",
            "\trcu_assign_pointer(array->ptrs[index], nsk);",
            "\tfree_osk = osk;",
            "\terr = 0;",
            "",
            "put_file_unlock:",
            "\twrite_unlock_bh(&nsk->sk_callback_lock);",
            "",
            "\tif (free_osk) {",
            "\t\twrite_lock_bh(&free_osk->sk_callback_lock);",
            "\t\tWRITE_ONCE(free_osk->sk_user_data, NULL);",
            "\t\twrite_unlock_bh(&free_osk->sk_callback_lock);",
            "\t}",
            "",
            "\tspin_unlock_bh(&reuseport_lock);",
            "put_file:",
            "\tfput(socket->file);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_fd_reuseport_array_lookup_elem, reuseport_array_update_check, bpf_fd_reuseport_array_update_elem",
          "description": "实现重用端口数组的查询和更新操作，包含校验新套接字属性、绑定操作及更新数组元素。通过锁保护关键区域，确保在更新过程中正确关联套接字与数组索引。",
          "similarity": 0.48882153630256653
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/reuseport_array.c",
          "start_line": 316,
          "end_line": 339,
          "content": [
            "static int reuseport_array_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\t\tvoid *next_key)",
            "{",
            "\tstruct reuseport_array *array = reuseport_array(map);",
            "\tu32 index = key ? *(u32 *)key : U32_MAX;",
            "\tu32 *next = (u32 *)next_key;",
            "",
            "\tif (index >= array->map.max_entries) {",
            "\t\t*next = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (index == array->map.max_entries - 1)",
            "\t\treturn -ENOENT;",
            "",
            "\t*next = index + 1;",
            "\treturn 0;",
            "}",
            "static u64 reuseport_array_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct reuseport_array *array;",
            "",
            "\treturn struct_size(array, ptrs, map->max_entries);",
            "}"
          ],
          "function_name": "reuseport_array_get_next_key, reuseport_array_mem_usage",
          "description": "提供数组遍历和内存统计功能，get_next_key用于索引递增迭代，mem_usage计算结构体及其动态数组的总内存占用。",
          "similarity": 0.402610719203949
        }
      ]
    },
    {
      "source_file": "kernel/seccomp.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:23:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `seccomp.c`\n\n---\n\n# seccomp.c 技术文档\n\n## 文件概述\n\n`seccomp.c` 是 Linux 内核中实现安全计算（Secure Computing，简称 seccomp）机制的核心文件。该机制用于限制进程可执行的系统调用，从而提升系统安全性。文件支持两种主要模式：\n\n- **Mode 1（严格模式）**：仅允许 `read`、`write`、`exit` 和 `sigreturn` 四个系统调用。\n- **Mode 2（过滤器模式）**：允许用户通过 Berkeley Packet Filter（BPF）形式定义自定义的系统调用过滤规则。\n\n此外，该文件还实现了 **用户空间通知（user-space notification）** 功能，允许内核在遇到特定系统调用时暂停执行并通知用户态监听器进行处理。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct seccomp_filter`**  \n  表示一个 seccomp BPF 过滤器实例，包含：\n  - 引用计数（`refs` 和 `users`）\n  - BPF 程序指针（`prog`）\n  - 通知相关结构（`notif`、`notify_lock`、`wqh`）\n  - 动作缓存（`cache`）\n  - 指向前一个过滤器的指针（`prev`），构成过滤器链\n\n- **`struct notification`**  \n  管理用户空间通知的容器，包含请求计数器、标志位、下一个通知 ID 和通知链表。\n\n- **`struct seccomp_knotif`**  \n  表示一个待处理的用户通知请求，记录触发通知的任务、系统调用数据、状态（INIT/SENT/REPLIED）、返回值及完成信号量。\n\n- **`struct seccomp_kaddfd`**  \n  用于 `SECCOMP_IOCTL_NOTIF_ADDFD` 操作，允许监听器向目标进程注入文件描述符。\n\n- **`struct action_cache`**（条件编译）  \n  针对原生和兼容架构的系统调用动作缓存，用于快速判断是否允许某系统调用，避免重复执行 BPF 程序。\n\n### 关键枚举与常量\n\n- **`enum notify_state`**：通知状态机（INIT → SENT → REPLIED）\n- **`SECCOMP_MODE_DEAD`**：内部使用的特殊模式，表示进程已进入不可恢复的 seccomp 状态\n- **`MAX_INSNS_PER_PATH`**：限制 BPF 指令路径总长度不超过 256KB，防止资源耗尽\n\n### 特殊兼容性处理\n\n- **`SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR`**：为兼容早期错误的 ioctl 命令方向而保留的旧定义\n\n## 关键实现\n\n### 过滤器生命周期管理\n\n- 使用双重引用计数机制：\n  - `refs`：控制对象内存释放（包括任务引用、依赖过滤器、通知监听器）\n  - `users`：跟踪直接或间接使用该过滤器的任务数量，用于判断是否还能被新任务继承\n- 过滤器一旦附加到任务，除引用计数外不可修改，确保并发安全\n\n### 用户空间通知机制\n\n- 当 BPF 程序返回 `SECCOMP_RET_USER_NOTIF` 时，内核创建 `seccomp_knotif` 并加入通知队列\n- 用户态通过文件描述符读取通知，内核将状态置为 `SENT`\n- 监听器通过 `ioctl` 回复结果，状态转为 `REPLIED`，触发 `completion` 使原任务继续执行\n- 支持通过 `SECCOMP_IOCTL_NOTIF_ADDFD` 向目标进程注入文件描述符\n\n### 动作缓存优化（`action_cache`）\n\n- 在支持 `SECCOMP_ARCH_NATIVE` 的架构上，为每个系统调用编号维护一个“始终允许”位图\n- 若缓存命中（即该系统调用在所有路径下均返回 `ALLOW`），可跳过 BPF 执行，提升性能\n- 分别处理原生（native）和兼容（compat）系统调用空间\n\n### 安全与资源限制\n\n- 限制 BPF 指令总路径长度，防止深度嵌套或循环导致 DoS\n- 通知机制使用互斥锁（`notify_lock`）和完成量（`completion`）保证状态一致性\n- 支持 `wait_killable_recv` 选项，使等待通知回复的进程可被信号中断\n\n## 依赖关系\n\n- **BPF 子系统**：依赖 `linux/filter.h` 提供的 socket filter/BPF 执行引擎\n- **进程管理**：与 `sched.h`、`task_struct` 紧密集成，管理 per-task seccomp 状态\n- **文件系统与 fd 管理**：通过 `file.h`、`uaccess.h` 实现跨进程 fd 注入\n- **审计与日志**：集成 `audit.h` 支持 seccomp 事件审计\n- **架构相关代码**：通过 `asm/syscall.h` 获取系统调用号和参数\n- **能力机制**：依赖 `capability.h` 检查特权操作权限\n- **内存管理**：使用 `slab.h` 分配过滤器和通知结构\n\n## 使用场景\n\n1. **容器安全**：Docker、LXC 等容器运行时使用 seccomp 过滤器限制容器内进程的系统调用，防止逃逸\n2. **沙箱应用**：Chromium、Firefox 等浏览器使用 seccomp 构建渲染进程沙箱\n3. **最小权限原则**：特权服务（如 systemd、sshd）在初始化后启用 seccomp 以减少攻击面\n4. **动态策略执行**：通过 `SECCOMP_RET_USER_NOTIF` 实现用户态代理系统调用（如 ptrace 替代方案）\n5. **安全审计**：结合 `SECCOMP_RET_LOG` 记录所有被拦截或允许的系统调用行为\n6. **系统加固**：在不可信环境中运行程序时，强制限制其系统调用能力",
      "similarity": 0.5356714129447937,
      "chunks": [
        {
          "chunk_id": 8,
          "file_path": "kernel/seccomp.c",
          "start_line": 1340,
          "end_line": 1443,
          "content": [
            "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,",
            "\t\t\t    const bool recheck_after_trace)",
            "{",
            "\tBUG();",
            "",
            "\treturn -1;",
            "}",
            "int __secure_computing(const struct seccomp_data *sd)",
            "{",
            "\tint mode = current->seccomp.mode;",
            "\tint this_syscall;",
            "",
            "\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&",
            "\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))",
            "\t\treturn 0;",
            "",
            "\tthis_syscall = sd ? sd->nr :",
            "\t\tsyscall_get_nr(current, current_pt_regs());",
            "",
            "\tswitch (mode) {",
            "\tcase SECCOMP_MODE_STRICT:",
            "\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */",
            "\t\treturn 0;",
            "\tcase SECCOMP_MODE_FILTER:",
            "\t\treturn __seccomp_filter(this_syscall, sd, false);",
            "\t/* Surviving SECCOMP_RET_KILL_* must be proactively impossible. */",
            "\tcase SECCOMP_MODE_DEAD:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tdo_exit(SIGKILL);",
            "\t\treturn -1;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "long prctl_get_seccomp(void)",
            "{",
            "\treturn current->seccomp.mode;",
            "}",
            "static long seccomp_set_mode_strict(void)",
            "{",
            "\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;",
            "\tlong ret = -EINVAL;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "",
            "\tif (!seccomp_may_assign_mode(seccomp_mode))",
            "\t\tgoto out;",
            "",
            "#ifdef TIF_NOTSC",
            "\tdisable_TSC();",
            "#endif",
            "\tseccomp_assign_mode(current, seccomp_mode, 0);",
            "\tret = 0;",
            "",
            "out:",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void seccomp_notify_free(struct seccomp_filter *filter)",
            "{",
            "\tkfree(filter->notif);",
            "\tfilter->notif = NULL;",
            "}",
            "static void seccomp_notify_detach(struct seccomp_filter *filter)",
            "{",
            "\tstruct seccomp_knotif *knotif;",
            "",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "",
            "\t/*",
            "\t * If this file is being closed because e.g. the task who owned it",
            "\t * died, let's wake everyone up who was waiting on us.",
            "\t */",
            "\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {",
            "\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)",
            "\t\t\tcontinue;",
            "",
            "\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\t\tknotif->error = -ENOSYS;",
            "\t\tknotif->val = 0;",
            "",
            "\t\t/*",
            "\t\t * We do not need to wake up any pending addfd messages, as",
            "\t\t * the notifier will do that for us, as this just looks",
            "\t\t * like a standard reply.",
            "\t\t */",
            "\t\tcomplete(&knotif->ready);",
            "\t}",
            "",
            "\tseccomp_notify_free(filter);",
            "\tmutex_unlock(&filter->notify_lock);",
            "}",
            "static int seccomp_notify_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "",
            "\tseccomp_notify_detach(filter);",
            "\t__put_seccomp_filter(filter);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__seccomp_filter, __secure_computing, prctl_get_seccomp, seccomp_set_mode_strict, seccomp_notify_free, seccomp_notify_detach, seccomp_notify_release",
          "description": "提供seccomp模式切换接口(prctl_get_seccomp/seccomp_set_mode_strict)，实现通知资源释放(detach/release)机制",
          "similarity": 0.5619423389434814
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/seccomp.c",
          "start_line": 1477,
          "end_line": 1578,
          "content": [
            "static int recv_wake_function(wait_queue_entry_t *wait, unsigned int mode, int sync,",
            "\t\t\t\t  void *key)",
            "{",
            "\t/* Avoid a wakeup if event not interesting for us. */",
            "\tif (key && !(key_to_poll(key) & (EPOLLIN | EPOLLERR)))",
            "\t\treturn 0;",
            "\treturn autoremove_wake_function(wait, mode, sync, key);",
            "}",
            "static int recv_wait_event(struct seccomp_filter *filter)",
            "{",
            "\tDEFINE_WAIT_FUNC(wait, recv_wake_function);",
            "\tint ret;",
            "",
            "\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)",
            "\t\treturn 0;",
            "",
            "\tfor (;;) {",
            "\t\tret = prepare_to_wait_event(&filter->wqh, &wait, TASK_INTERRUPTIBLE);",
            "",
            "\t\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)",
            "\t\t\tbreak;",
            "",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "",
            "\t\tschedule();",
            "\t}",
            "\tfinish_wait(&filter->wqh, &wait);",
            "\treturn 0;",
            "}",
            "static long seccomp_notify_recv(struct seccomp_filter *filter,",
            "\t\t\t\tvoid __user *buf)",
            "{",
            "\tstruct seccomp_knotif *knotif = NULL, *cur;",
            "\tstruct seccomp_notif unotif;",
            "\tssize_t ret;",
            "",
            "\t/* Verify that we're not given garbage to keep struct extensible. */",
            "\tret = check_zeroed_user(buf, sizeof(unotif));",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\tif (!ret)",
            "\t\treturn -EINVAL;",
            "",
            "\tmemset(&unotif, 0, sizeof(unotif));",
            "",
            "\tret = recv_wait_event(filter);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "\tlist_for_each_entry(cur, &filter->notif->notifications, list) {",
            "\t\tif (cur->state == SECCOMP_NOTIFY_INIT) {",
            "\t\t\tknotif = cur;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * If we didn't find a notification, it could be that the task was",
            "\t * interrupted by a fatal signal between the time we were woken and",
            "\t * when we were able to acquire the rw lock.",
            "\t */",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tunotif.id = knotif->id;",
            "\tunotif.pid = task_pid_vnr(knotif->task);",
            "\tunotif.data = *(knotif->data);",
            "",
            "\tknotif->state = SECCOMP_NOTIFY_SENT;",
            "\twake_up_poll(&filter->wqh, EPOLLOUT | EPOLLWRNORM);",
            "\tret = 0;",
            "out:",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\tif (ret == 0 && copy_to_user(buf, &unotif, sizeof(unotif))) {",
            "\t\tret = -EFAULT;",
            "",
            "\t\t/*",
            "\t\t * Userspace screwed up. To make sure that we keep this",
            "\t\t * notification alive, let's reset it back to INIT. It",
            "\t\t * may have died when we released the lock, so we need to make",
            "\t\t * sure it's still around.",
            "\t\t */",
            "\t\tmutex_lock(&filter->notify_lock);",
            "\t\tknotif = find_notification(filter, unotif.id);",
            "\t\tif (knotif) {",
            "\t\t\t/* Reset the process to make sure it's not stuck */",
            "\t\t\tif (should_sleep_killable(filter, knotif))",
            "\t\t\t\tcomplete(&knotif->ready);",
            "\t\t\tknotif->state = SECCOMP_NOTIFY_INIT;",
            "\t\t\tatomic_inc(&filter->notif->requests);",
            "\t\t\twake_up_poll(&filter->wqh, EPOLLIN | EPOLLRDNORM);",
            "\t\t}",
            "\t\tmutex_unlock(&filter->notify_lock);",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "recv_wake_function, recv_wait_event, seccomp_notify_recv",
          "description": "实现通知接收等待队列管理(recv_wait_event)和用户态数据接收(seccomp_notify_recv)的同步控制",
          "similarity": 0.5425825119018555
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/seccomp.c",
          "start_line": 811,
          "end_line": 914,
          "content": [
            "static void seccomp_cache_prepare_bitmap(struct seccomp_filter *sfilter,",
            "\t\t\t\t\t void *bitmap, const void *bitmap_prev,",
            "\t\t\t\t\t size_t bitmap_size, int arch)",
            "{",
            "\tstruct sock_fprog_kern *fprog = sfilter->prog->orig_prog;",
            "\tstruct seccomp_data sd;",
            "\tint nr;",
            "",
            "\tif (bitmap_prev) {",
            "\t\t/* The new filter must be as restrictive as the last. */",
            "\t\tbitmap_copy(bitmap, bitmap_prev, bitmap_size);",
            "\t} else {",
            "\t\t/* Before any filters, all syscalls are always allowed. */",
            "\t\tbitmap_fill(bitmap, bitmap_size);",
            "\t}",
            "",
            "\tfor (nr = 0; nr < bitmap_size; nr++) {",
            "\t\t/* No bitmap change: not a cacheable action. */",
            "\t\tif (!test_bit(nr, bitmap))",
            "\t\t\tcontinue;",
            "",
            "\t\tsd.nr = nr;",
            "\t\tsd.arch = arch;",
            "",
            "\t\t/* No bitmap change: continue to always allow. */",
            "\t\tif (seccomp_is_const_allow(fprog, &sd))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Not a cacheable action: always run filters.",
            "\t\t * atomic clear_bit() not needed, filter not visible yet.",
            "\t\t */",
            "\t\t__clear_bit(nr, bitmap);",
            "\t}",
            "}",
            "static void seccomp_cache_prepare(struct seccomp_filter *sfilter)",
            "{",
            "\tstruct action_cache *cache = &sfilter->cache;",
            "\tconst struct action_cache *cache_prev =",
            "\t\tsfilter->prev ? &sfilter->prev->cache : NULL;",
            "",
            "\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_native,",
            "\t\t\t\t     cache_prev ? cache_prev->allow_native : NULL,",
            "\t\t\t\t     SECCOMP_ARCH_NATIVE_NR,",
            "\t\t\t\t     SECCOMP_ARCH_NATIVE);",
            "",
            "#ifdef SECCOMP_ARCH_COMPAT",
            "\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_compat,",
            "\t\t\t\t     cache_prev ? cache_prev->allow_compat : NULL,",
            "\t\t\t\t     SECCOMP_ARCH_COMPAT_NR,",
            "\t\t\t\t     SECCOMP_ARCH_COMPAT);",
            "#endif /* SECCOMP_ARCH_COMPAT */",
            "}",
            "static long seccomp_attach_filter(unsigned int flags,",
            "\t\t\t\t  struct seccomp_filter *filter)",
            "{",
            "\tunsigned long total_insns;",
            "\tstruct seccomp_filter *walker;",
            "",
            "\tassert_spin_locked(&current->sighand->siglock);",
            "",
            "\t/* Validate resulting filter length. */",
            "\ttotal_insns = filter->prog->len;",
            "\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)",
            "\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */",
            "\tif (total_insns > MAX_INSNS_PER_PATH)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* If thread sync has been requested, check that it is possible. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {",
            "\t\tint ret;",
            "",
            "\t\tret = seccomp_can_sync_threads();",
            "\t\tif (ret) {",
            "\t\t\tif (flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH)",
            "\t\t\t\treturn -ESRCH;",
            "\t\t\telse",
            "\t\t\t\treturn ret;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Set log flag, if present. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_LOG)",
            "\t\tfilter->log = true;",
            "",
            "\t/* Set wait killable flag, if present. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV)",
            "\t\tfilter->wait_killable_recv = true;",
            "",
            "\t/*",
            "\t * If there is an existing filter, make it the prev and don't drop its",
            "\t * task reference.",
            "\t */",
            "\tfilter->prev = current->seccomp.filter;",
            "\tseccomp_cache_prepare(filter);",
            "\tcurrent->seccomp.filter = filter;",
            "\tatomic_inc(&current->seccomp.filter_count);",
            "",
            "\t/* Now that the new filter is in place, synchronize to all threads. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)",
            "\t\tseccomp_sync_threads(flags);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "seccomp_cache_prepare_bitmap, seccomp_cache_prepare, seccomp_attach_filter",
          "description": "实现过滤器预处理逻辑，seccomp_cache_prepare_bitmap构建允许位图，seccomp_cache_prepare初始化缓存，seccomp_attach_filter附加新过滤器并进行参数验证及线程同步。",
          "similarity": 0.5355274677276611
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/seccomp.c",
          "start_line": 1783,
          "end_line": 1952,
          "content": [
            "static long seccomp_notify_ioctl(struct file *file, unsigned int cmd,",
            "\t\t\t\t unsigned long arg)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "\tvoid __user *buf = (void __user *)arg;",
            "",
            "\t/* Fixed-size ioctls */",
            "\tswitch (cmd) {",
            "\tcase SECCOMP_IOCTL_NOTIF_RECV:",
            "\t\treturn seccomp_notify_recv(filter, buf);",
            "\tcase SECCOMP_IOCTL_NOTIF_SEND:",
            "\t\treturn seccomp_notify_send(filter, buf);",
            "\tcase SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR:",
            "\tcase SECCOMP_IOCTL_NOTIF_ID_VALID:",
            "\t\treturn seccomp_notify_id_valid(filter, buf);",
            "\tcase SECCOMP_IOCTL_NOTIF_SET_FLAGS:",
            "\t\treturn seccomp_notify_set_flags(filter, arg);",
            "\t}",
            "",
            "\t/* Extensible Argument ioctls */",
            "#define EA_IOCTL(cmd)\t((cmd) & ~(IOC_INOUT | IOCSIZE_MASK))",
            "\tswitch (EA_IOCTL(cmd)) {",
            "\tcase EA_IOCTL(SECCOMP_IOCTL_NOTIF_ADDFD):",
            "\t\treturn seccomp_notify_addfd(filter, buf, _IOC_SIZE(cmd));",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "}",
            "static __poll_t seccomp_notify_poll(struct file *file,",
            "\t\t\t\t    struct poll_table_struct *poll_tab)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "\t__poll_t ret = 0;",
            "\tstruct seccomp_knotif *cur;",
            "",
            "\tpoll_wait(file, &filter->wqh, poll_tab);",
            "",
            "\tif (mutex_lock_interruptible(&filter->notify_lock) < 0)",
            "\t\treturn EPOLLERR;",
            "",
            "\tlist_for_each_entry(cur, &filter->notif->notifications, list) {",
            "\t\tif (cur->state == SECCOMP_NOTIFY_INIT)",
            "\t\t\tret |= EPOLLIN | EPOLLRDNORM;",
            "\t\tif (cur->state == SECCOMP_NOTIFY_SENT)",
            "\t\t\tret |= EPOLLOUT | EPOLLWRNORM;",
            "\t\tif ((ret & EPOLLIN) && (ret & EPOLLOUT))",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\tif (refcount_read(&filter->users) == 0)",
            "\t\tret |= EPOLLHUP;",
            "",
            "\treturn ret;",
            "}",
            "static bool has_duplicate_listener(struct seccomp_filter *new_child)",
            "{",
            "\tstruct seccomp_filter *cur;",
            "",
            "\t/* must be protected against concurrent TSYNC */",
            "\tlockdep_assert_held(&current->sighand->siglock);",
            "",
            "\tif (!new_child->notif)",
            "\t\treturn false;",
            "\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {",
            "\t\tif (cur->notif)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static long seccomp_set_mode_filter(unsigned int flags,",
            "\t\t\t\t    const char __user *filter)",
            "{",
            "\tconst unsigned long seccomp_mode = SECCOMP_MODE_FILTER;",
            "\tstruct seccomp_filter *prepared = NULL;",
            "\tlong ret = -EINVAL;",
            "\tint listener = -1;",
            "\tstruct file *listener_f = NULL;",
            "",
            "\t/* Validate flags. */",
            "\tif (flags & ~SECCOMP_FILTER_FLAG_MASK)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * In the successful case, NEW_LISTENER returns the new listener fd.",
            "\t * But in the failure case, TSYNC returns the thread that died. If you",
            "\t * combine these two flags, there's no way to tell whether something",
            "\t * succeeded or failed. So, let's disallow this combination if the user",
            "\t * has not explicitly requested no errors from TSYNC.",
            "\t */",
            "\tif ((flags & SECCOMP_FILTER_FLAG_TSYNC) &&",
            "\t    (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) &&",
            "\t    ((flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH) == 0))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * The SECCOMP_FILTER_FLAG_WAIT_KILLABLE_SENT flag doesn't make sense",
            "\t * without the SECCOMP_FILTER_FLAG_NEW_LISTENER flag.",
            "\t */",
            "\tif ((flags & SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV) &&",
            "\t    ((flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) == 0))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Prepare the new filter before holding any locks. */",
            "\tprepared = seccomp_prepare_user_filter(filter);",
            "\tif (IS_ERR(prepared))",
            "\t\treturn PTR_ERR(prepared);",
            "",
            "\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {",
            "\t\tlistener = get_unused_fd_flags(O_CLOEXEC);",
            "\t\tif (listener < 0) {",
            "\t\t\tret = listener;",
            "\t\t\tgoto out_free;",
            "\t\t}",
            "",
            "\t\tlistener_f = init_listener(prepared);",
            "\t\tif (IS_ERR(listener_f)) {",
            "\t\t\tput_unused_fd(listener);",
            "\t\t\tret = PTR_ERR(listener_f);",
            "\t\t\tgoto out_free;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Make sure we cannot change seccomp or nnp state via TSYNC",
            "\t * while another thread is in the middle of calling exec.",
            "\t */",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC &&",
            "\t    mutex_lock_killable(&current->signal->cred_guard_mutex))",
            "\t\tgoto out_put_fd;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "",
            "\tif (!seccomp_may_assign_mode(seccomp_mode))",
            "\t\tgoto out;",
            "",
            "\tif (has_duplicate_listener(prepared)) {",
            "\t\tret = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = seccomp_attach_filter(flags, prepared);",
            "\tif (ret)",
            "\t\tgoto out;",
            "\t/* Do not free the successfully attached filter. */",
            "\tprepared = NULL;",
            "",
            "\tseccomp_assign_mode(current, seccomp_mode, flags);",
            "out:",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)",
            "\t\tmutex_unlock(&current->signal->cred_guard_mutex);",
            "out_put_fd:",
            "\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {",
            "\t\tif (ret) {",
            "\t\t\tlistener_f->private_data = NULL;",
            "\t\t\tfput(listener_f);",
            "\t\t\tput_unused_fd(listener);",
            "\t\t\tseccomp_notify_detach(prepared);",
            "\t\t} else {",
            "\t\t\tfd_install(listener, listener_f);",
            "\t\t\tret = listener;",
            "\t\t}",
            "\t}",
            "out_free:",
            "\tseccomp_filter_free(prepared);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "seccomp_notify_ioctl, seccomp_notify_poll, has_duplicate_listener, seccomp_set_mode_filter",
          "description": "该代码段实现seccomp过滤器的通知机制与模式配置功能。  \n`seccomp_notify_ioctl`处理通知相关的IOCTL命令，支持接收/发送通知及扩展参数操作；`seccomp_notify_poll`通过轮询检测过滤器状态变化并设置对应epoll掩码；`has_duplicate_listener`检查是否存在重复监听器以避免资源冲突，`seccomp_set_mode_filter`负责设置过滤模式并管理监听器创建与同步。  \n注：代码未展示全部上下文，如`seccomp_prepare_user_filter`等辅助函数的具体实现。",
          "similarity": 0.5234477519989014
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/seccomp.c",
          "start_line": 1111,
          "end_line": 1212,
          "content": [
            "static bool should_sleep_killable(struct seccomp_filter *match,",
            "\t\t\t\t  struct seccomp_knotif *n)",
            "{",
            "\treturn match->wait_killable_recv && n->state == SECCOMP_NOTIFY_SENT;",
            "}",
            "static int seccomp_do_user_notification(int this_syscall,",
            "\t\t\t\t\tstruct seccomp_filter *match,",
            "\t\t\t\t\tconst struct seccomp_data *sd)",
            "{",
            "\tint err;",
            "\tu32 flags = 0;",
            "\tlong ret = 0;",
            "\tstruct seccomp_knotif n = {};",
            "\tstruct seccomp_kaddfd *addfd, *tmp;",
            "",
            "\tmutex_lock(&match->notify_lock);",
            "\terr = -ENOSYS;",
            "\tif (!match->notif)",
            "\t\tgoto out;",
            "",
            "\tn.task = current;",
            "\tn.state = SECCOMP_NOTIFY_INIT;",
            "\tn.data = sd;",
            "\tn.id = seccomp_next_notify_id(match);",
            "\tinit_completion(&n.ready);",
            "\tlist_add_tail(&n.list, &match->notif->notifications);",
            "\tINIT_LIST_HEAD(&n.addfd);",
            "",
            "\tatomic_inc(&match->notif->requests);",
            "\tif (match->notif->flags & SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\twake_up_poll_on_current_cpu(&match->wqh, EPOLLIN | EPOLLRDNORM);",
            "\telse",
            "\t\twake_up_poll(&match->wqh, EPOLLIN | EPOLLRDNORM);",
            "",
            "\t/*",
            "\t * This is where we wait for a reply from userspace.",
            "\t */",
            "\tdo {",
            "\t\tbool wait_killable = should_sleep_killable(match, &n);",
            "",
            "\t\tmutex_unlock(&match->notify_lock);",
            "\t\tif (wait_killable)",
            "\t\t\terr = wait_for_completion_killable(&n.ready);",
            "\t\telse",
            "\t\t\terr = wait_for_completion_interruptible(&n.ready);",
            "\t\tmutex_lock(&match->notify_lock);",
            "",
            "\t\tif (err != 0) {",
            "\t\t\t/*",
            "\t\t\t * Check to see if the notifcation got picked up and",
            "\t\t\t * whether we should switch to wait killable.",
            "\t\t\t */",
            "\t\t\tif (!wait_killable && should_sleep_killable(match, &n))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tgoto interrupted;",
            "\t\t}",
            "",
            "\t\taddfd = list_first_entry_or_null(&n.addfd,",
            "\t\t\t\t\t\t struct seccomp_kaddfd, list);",
            "\t\t/* Check if we were woken up by a addfd message */",
            "\t\tif (addfd)",
            "\t\t\tseccomp_handle_addfd(addfd, &n);",
            "",
            "\t}  while (n.state != SECCOMP_NOTIFY_REPLIED);",
            "",
            "\tret = n.val;",
            "\terr = n.error;",
            "\tflags = n.flags;",
            "",
            "interrupted:",
            "\t/* If there were any pending addfd calls, clear them out */",
            "\tlist_for_each_entry_safe(addfd, tmp, &n.addfd, list) {",
            "\t\t/* The process went away before we got a chance to handle it */",
            "\t\taddfd->ret = -ESRCH;",
            "\t\tlist_del_init(&addfd->list);",
            "\t\tcomplete(&addfd->completion);",
            "\t}",
            "",
            "\t/*",
            "\t * Note that it's possible the listener died in between the time when",
            "\t * we were notified of a response (or a signal) and when we were able to",
            "\t * re-acquire the lock, so only delete from the list if the",
            "\t * notification actually exists.",
            "\t *",
            "\t * Also note that this test is only valid because there's no way to",
            "\t * *reattach* to a notifier right now. If one is added, we'll need to",
            "\t * keep track of the notif itself and make sure they match here.",
            "\t */",
            "\tif (match->notif)",
            "\t\tlist_del(&n.list);",
            "out:",
            "\tmutex_unlock(&match->notify_lock);",
            "",
            "\t/* Userspace requests to continue the syscall. */",
            "\tif (flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE)",
            "\t\treturn 0;",
            "",
            "\tsyscall_set_return_value(current, current_pt_regs(),",
            "\t\t\t\t err, ret);",
            "\treturn -1;",
            "}"
          ],
          "function_name": "should_sleep_killable, seccomp_do_user_notification",
          "description": "实现用户空间通知等待逻辑，seccomp_do_user_notification处理通知状态转换、文件描述符传递及超时控制",
          "similarity": 0.5172701478004456
        }
      ]
    }
  ]
}