{
  "query": "系统调用处理",
  "timestamp": "2025-12-26 02:10:23",
  "retrieved_files": [
    {
      "source_file": "kernel/entry/syscall_user_dispatch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:20:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\syscall_user_dispatch.c`\n\n---\n\n# entry/syscall_user_dispatch.c 技术文档\n\n## 1. 文件概述\n\n`entry/syscall_user_dispatch.c` 实现了 **系统调用用户分发（Syscall User Dispatch, SUD）** 机制，该机制允许用户空间程序通过 `prctl()` 系统调用配置一个“选择器”（selector），用于在特定条件下拦截或允许系统调用的执行。当系统调用指令指针位于指定区域之外且选择器状态为“阻塞”时，内核会回滚该系统调用并向进程发送 `SIGSYS` 信号，从而实现对系统调用的细粒度控制。此功能常用于沙箱、安全监控或调试场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trigger_sigsys(struct pt_regs *regs)`  \n  构造并强制发送 `SIGSYS` 信号，携带被拦截系统调用的详细信息（如地址、系统调用号、架构等）。\n\n- `syscall_user_dispatch(struct pt_regs *regs)`  \n  系统调用入口处的分发判断逻辑。根据当前指令指针位置和用户选择器状态决定是否拦截系统调用。\n\n- `task_set_syscall_user_dispatch(struct task_struct *task, ...)`  \n  为指定任务设置系统调用用户分发配置（开启/关闭、偏移、长度、选择器地址）。\n\n- `set_syscall_user_dispatch(...)`  \n  为当前任务设置系统调用用户分发配置的封装接口，供 `prctl()` 调用。\n\n- `syscall_user_dispatch_get_config(...)`  \n  通过 `ptrace` 获取指定任务的 SUD 配置。\n\n- `syscall_user_dispatch_set_config(...)`  \n  通过 `ptrace` 设置指定任务的 SUD 配置。\n\n### 关键数据结构\n\n- `struct syscall_user_dispatch`（定义在 `<linux/syscall_user_dispatch.h>`）  \n  存储每个任务的 SUD 配置：\n  - `selector`：指向用户空间选择器字节的指针\n  - `offset` / `len`：允许直接执行系统调用的代码区域（[offset, offset+len)）\n  - `on_dispatch`：标志位，表示当前是否处于分发拦截状态\n\n- `struct ptrace_sud_config`  \n  用于 `ptrace` 接口传递 SUD 配置的结构体，包含 `mode`、`offset`、`len` 和 `selector`。\n\n## 3. 关键实现\n\n### 系统调用拦截逻辑\n\n1. **区域检查**：若当前指令指针（`instruction_pointer(regs)`）落在 `[offset, offset + len)` 范围内，则**允许**系统调用直接执行，不进行拦截。\n2. **vdso 例外**：若系统调用来自 vDSO 中的 `sigreturn`（如 `arch_syscall_is_vdso_sigreturn()` 返回 true），则跳过拦截，避免干扰信号返回路径。\n3. **选择器读取**：若配置了 `selector`，则从用户空间读取一个字节的状态值：\n   - `SYSCALL_DISPATCH_FILTER_ALLOW`（0）：允许系统调用\n   - `SYSCALL_DISPATCH_FILTER_BLOCK`（1）：触发拦截\n   - 其他值：视为非法，发送 `SIGSYS`\n4. **拦截处理**：\n   - 设置 `on_dispatch = true`\n   - 调用 `syscall_rollback()` 回滚系统调用（恢复寄存器状态）\n   - 调用 `trigger_sigsys()` 发送 `SIGSYS` 信号\n\n### 安全与健壮性设计\n\n- **地址合法性校验**：在设置 `selector` 时使用 `access_ok(untagged_addr(selector), ...)`，确保地址可访问，并处理内存标记（如 ARM MTE）场景下调试器（tracer）与被调试进程（tracee）地址标记不一致的问题。\n- **溢出防护**：检查 `offset + len <= offset` 防止整数溢出导致无效区域。\n- **权限隔离**：`ptrace` 接口允许调试器配置其他进程的 SUD，但需具备相应权限。\n\n### 信号信息构造\n\n`trigger_sigsys()` 构造的 `siginfo_t` 包含：\n- `si_signo = SIGSYS`\n- `si_code = SYS_USER_DISPATCH`\n- `si_call_addr`：触发系统调用的用户空间地址\n- `si_syscall`：系统调用号\n- `si_arch`：系统调用架构（如 x86_64、AArch64）\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/prctl.h>`：定义 `PR_SYS_DISPATCH_*` 常量\n  - `<linux/syscall_user_dispatch.h>`：定义 `struct syscall_user_dispatch` 和相关常量\n  - `<asm/syscall.h>`：提供 `syscall_get_arch()`、`syscall_get_nr()` 等架构相关接口\n  - `\"common.h\"`：可能包含内核入口通用辅助函数\n- **内核子系统**：\n  - **调度器（sched）**：访问 `current` 任务结构\n  - **信号子系统（signal）**：发送 `SIGSYS` 信号\n  - **内存管理（uaccess）**：用户空间内存访问（`__get_user`, `access_ok`）\n  - **ptrace**：支持调试器配置 SUD\n  - **ELF**：可能用于架构识别（间接依赖）\n\n## 5. 使用场景\n\n- **沙箱环境**：限制应用只能在特定代码段发起系统调用，防止恶意代码绕过安全策略。\n- **动态二进制插桩（DBI）**：工具（如 Valgrind、Intel Pin）可拦截系统调用进行分析或重定向。\n- **安全监控**：监控程序可配置选择器为“阻塞”，在 `SIGSYS` 信号处理程序中记录或审查系统调用。\n- **调试与测试**：通过 `ptrace` 动态启用/禁用 SUD，用于测试系统调用拦截逻辑。\n- **W^X 策略增强**：结合代码段只读与 SUD，确保只有可信代码路径可发起系统调用。",
      "similarity": 0.6283758282661438,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 20,
          "end_line": 122,
          "content": [
            "static void trigger_sigsys(struct pt_regs *regs)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSYS;",
            "\tinfo.si_code = SYS_USER_DISPATCH;",
            "\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_arch = syscall_get_arch(current);",
            "\tinfo.si_syscall = syscall_get_nr(current, regs);",
            "",
            "\tforce_sig_info(&info);",
            "}",
            "bool syscall_user_dispatch(struct pt_regs *regs)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;",
            "\tchar state;",
            "",
            "\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))",
            "\t\treturn false;",
            "",
            "\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))",
            "\t\treturn false;",
            "",
            "\tif (likely(sd->selector)) {",
            "\t\t/*",
            "\t\t * access_ok() is performed once, at prctl time, when",
            "\t\t * the selector is loaded by userspace.",
            "\t\t */",
            "\t\tif (unlikely(__get_user(state, sd->selector))) {",
            "\t\t\tforce_exit_sig(SIGSEGV);",
            "\t\t\treturn true;",
            "\t\t}",
            "",
            "\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))",
            "\t\t\treturn false;",
            "",
            "\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {",
            "\t\t\tforce_exit_sig(SIGSYS);",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tsd->on_dispatch = true;",
            "\tsyscall_rollback(current, regs);",
            "\ttrigger_sigsys(regs);",
            "",
            "\treturn true;",
            "}",
            "static int task_set_syscall_user_dispatch(struct task_struct *task, unsigned long mode,",
            "\t\t\t\t\t  unsigned long offset, unsigned long len,",
            "\t\t\t\t\t  char __user *selector)",
            "{",
            "\tswitch (mode) {",
            "\tcase PR_SYS_DISPATCH_OFF:",
            "\t\tif (offset || len || selector)",
            "\t\t\treturn -EINVAL;",
            "\t\tbreak;",
            "\tcase PR_SYS_DISPATCH_ON:",
            "\t\t/*",
            "\t\t * Validate the direct dispatcher region just for basic",
            "\t\t * sanity against overflow and a 0-sized dispatcher",
            "\t\t * region.  If the user is able to submit a syscall from",
            "\t\t * an address, that address is obviously valid.",
            "\t\t */",
            "\t\tif (offset && offset + len <= offset)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * access_ok() will clear memory tags for tagged addresses",
            "\t\t * if current has memory tagging enabled.",
            "",
            "\t\t * To enable a tracer to set a tracees selector the",
            "\t\t * selector address must be untagged for access_ok(),",
            "\t\t * otherwise an untagged tracer will always fail to set a",
            "\t\t * tagged tracees selector.",
            "\t\t */",
            "\t\tif (selector && !access_ok(untagged_addr(selector), sizeof(*selector)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttask->syscall_dispatch.selector = selector;",
            "\ttask->syscall_dispatch.offset = offset;",
            "\ttask->syscall_dispatch.len = len;",
            "\ttask->syscall_dispatch.on_dispatch = false;",
            "",
            "\tif (mode == PR_SYS_DISPATCH_ON)",
            "\t\tset_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "\telse",
            "\t\tclear_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "",
            "\treturn 0;",
            "}",
            "int set_syscall_user_dispatch(unsigned long mode, unsigned long offset,",
            "\t\t\t      unsigned long len, char __user *selector)",
            "{",
            "\treturn task_set_syscall_user_dispatch(current, mode, offset, len, selector);",
            "}"
          ],
          "function_name": "trigger_sigsys, syscall_user_dispatch, task_set_syscall_user_dispatch, set_syscall_user_dispatch",
          "description": "实现系统调用用户分发核心逻辑，包含触发SIGSYS信号处理、配置验证、拦截判断及模式切换功能",
          "similarity": 0.696205198764801
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 127,
          "end_line": 163,
          "content": [
            "int syscall_user_dispatch_get_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &task->syscall_dispatch;",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (test_task_syscall_work(task, SYSCALL_USER_DISPATCH))",
            "\t\tcfg.mode = PR_SYS_DISPATCH_ON;",
            "\telse",
            "\t\tcfg.mode = PR_SYS_DISPATCH_OFF;",
            "",
            "\tcfg.offset = sd->offset;",
            "\tcfg.len = sd->len;",
            "\tcfg.selector = (__u64)(uintptr_t)sd->selector;",
            "",
            "\tif (copy_to_user(data, &cfg, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn 0;",
            "}",
            "int syscall_user_dispatch_set_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (copy_from_user(&cfg, data, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn task_set_syscall_user_dispatch(task, cfg.mode, cfg.offset, cfg.len,",
            "\t\t\t\t\t      (char __user *)(uintptr_t)cfg.selector);",
            "}"
          ],
          "function_name": "syscall_user_dispatch_get_config, syscall_user_dispatch_set_config",
          "description": "提供系统调用分发配置的获取与设置接口，通过用户态指针操作实现配置参数的双向传递",
          "similarity": 0.6591352820396423
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2020 Collabora Ltd.",
            " */",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/signal.h>",
            "#include <linux/elf.h>",
            "",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task_stack.h>",
            "",
            "#include <asm/syscall.h>",
            "",
            "#include \"common.h\"",
            ""
          ],
          "function_name": null,
          "description": "包含系统调用用户分发功能所需头文件及通用定义，提供架构相关接口和内核调度必要声明",
          "similarity": 0.6282889246940613
        }
      ]
    },
    {
      "source_file": "kernel/sys.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:30:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sys.c`\n\n---\n\n# `sys.c` 内核源码技术文档\n\n## 1. 文件概述\n\n`sys.c` 是 Linux 内核中实现系统调用（system calls）的核心源文件之一，位于 `kernel/` 目录下。该文件主要负责处理与进程调度优先级、用户/组 ID 溢出处理、系统信息查询等相关的通用系统调用。其历史可追溯至 Linus Torvalds 早期开发阶段，是内核中提供 POSIX 兼容性的重要组成部分。当前文档所涵盖的代码片段聚焦于 `setpriority` 和 `getpriority` 系统调用的实现，以及与 UID/GID 溢出相关的全局变量定义。\n\n## 2. 核心功能\n\n### 全局变量\n- `overflowuid` / `overflowgid`：用于在 32 位 UID/GID 架构中表示无法表示的旧式 16 位 UID/GID 的回退值，默认为 `DEFAULT_OVERFLOWUID`/`DEFAULT_OVERFLOWGID`。\n- `fs_overflowuid` / `fs_overflowgid`：专用于仅支持 16 位 UID/GID 的文件系统的溢出回退值，适用于所有架构。\n\n### 主要函数\n- `set_one_prio_perm(struct task_struct *p)`：检查当前进程是否有权限修改目标进程 `p` 的调度优先级（nice 值）。\n- `set_one_prio(struct task_struct *p, int niceval, int error)`：在权限检查通过后，实际设置目标进程的 nice 值。\n- `SYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)`：实现 `setpriority(2)` 系统调用，支持按进程、进程组或用户 ID 修改一组进程的优先级。\n- `SYSCALL_DEFINE2(getpriority, int, which, int, who)`：实现 `getpriority(2)` 系统调用，返回指定范围（进程、进程组、用户）内最高优先级（即最小 nice 值）对应的兼容值。\n\n## 3. 关键实现\n\n### 权限控制机制\n- `set_one_prio_perm()` 函数通过比较当前进程的有效 UID（`euid`）与目标进程的 UID 或有效 UID 是否相等来判断基本权限。\n- 若不满足 UID 匹配，则检查当前进程是否在目标进程所属的用户命名空间（`user_ns`）中拥有 `CAP_SYS_NICE` 能力。\n- 所有凭证（`cred`）访问均在 RCU 读锁保护下进行，确保并发安全。\n\n### 优先级设置逻辑\n- `setpriority` 系统调用首先将用户传入的 `niceval` 限制在 `[MIN_NICE, MAX_NICE]` 范围内（通常为 -20 到 19）。\n- 根据 `which` 参数（`PRIO_PROCESS`、`PRIO_PGRP` 或 `PRIO_USER`）分别处理：\n  - **进程**：通过 `find_task_by_vpid()` 查找目标进程。\n  - **进程组**：使用 `do_each_pid_thread()` 遍历指定进程组内的所有线程。\n  - **用户**：遍历所有进程，筛选 UID 匹配的进程；若目标 UID 非当前用户，则通过 `find_user()` 获取用户结构并最终 `free_uid()` 释放引用。\n- 实际设置前调用 LSM（Linux Security Module）钩子 `security_task_setnice()` 进行安全策略检查。\n\n### 优先级获取的兼容性处理\n- `getpriority` 返回值采用历史兼容格式：将实际 nice 值（-20~19）转换为 `20 - nice`，即返回 1~40 的正整数。\n- 该转换通过 `nice_to_rlimit()` 宏实现（定义在 `<linux/resource.h>` 中）。\n- 返回的是指定范围内**最高优先级**（即最大 `nice_to_rlimit` 值，对应最小实际 nice 值）。\n\n### 架构无关性处理\n- 文件开头通过一系列 `#ifndef` 宏定义（如 `SET_UNALIGN_CTL`、`GET_FP_MODE` 等）为不支持特定 CPU 控制功能的架构提供默认 `-EINVAL` 返回值，避免编译错误。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **调度子系统**：`<linux/sched.h>` 及其子头文件（如 `sched/task.h`、`sched/cputime.h`）提供任务结构、nice 值操作和遍历接口。\n- **用户/组管理**：`<linux/cred.h>`、`<linux/uidgid.h>`、`<linux/user_namespace.h>` 处理凭证、UID/GID 映射及命名空间。\n- **安全模块**：`<linux/security.h>`、`<linux/capability.h>` 提供 LSM 钩子和能力检查。\n- **进程管理**：`<linux/pid.h>`（通过 `find_vpid` 等）、`<linux/rcupdate.h>`（RCU 锁）、`<linux/task_io_accounting_ops.h>`。\n- **系统调用框架**：`<linux/syscalls.h>`、`<linux/uaccess.h>`。\n- **其他**：`<linux/resource.h>`（`nice_to_rlimit`）、`<linux/utsname.h>`（系统信息）、`<generated/utsrelease.h>`（内核版本）。\n\n### 内核子系统交互\n- **调度器**：通过 `set_user_nice()` 和 `task_nice()` 与核心调度逻辑交互。\n- **用户命名空间**：在 UID 比较和能力检查中依赖用户命名空间隔离机制。\n- **LSM 框架**：调用 `security_task_setnice()` 允许安全模块（如 SELinux、AppArmor）拦截优先级修改。\n- **进程遍历机制**：使用 `for_each_process_thread()` 和 `do_each_pid_thread()` 安全遍历进程列表。\n\n## 5. 使用场景\n\n- **用户空间程序调用 `setpriority()`/`getpriority()`**：如 `nice`、`renice` 命令，或应用程序动态调整自身/子进程 CPU 调度优先级。\n- **系统初始化**：`overflowuid`/`overflowgid` 等变量在内核启动时初始化，供 VFS 和 IPC 子系统在处理旧式 16 位 UID/GID 时使用。\n- **容器与命名空间环境**：在用户命名空间中，`setpriority` 的权限检查基于目标进程的用户命名空间，确保容器内进程无法越权修改宿主机进程优先级。\n- **安全审计与限制**：通过 LSM 钩子，系统可记录或阻止非特权进程提升优先级的行为。\n- **跨架构兼容**：为不支持浮点控制、对齐控制等特性的 CPU 架构提供统一的系统调用接口，避免架构特定代码污染通用逻辑。",
      "similarity": 0.6108381152153015,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/sys.c",
          "start_line": 458,
          "end_line": 628,
          "content": [
            "long __sys_setgid(gid_t gid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t kgid;",
            "",
            "\tkgid = make_kgid(ns, gid);",
            "\tif (!gid_valid(kgid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_sgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t\tiee_set_cred_gid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->gid = new->egid = new->sgid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->egid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse",
            "\t\tgoto error;",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_ID);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "static int set_user(struct cred *new)",
            "{",
            "\tstruct user_struct *new_user;",
            "",
            "\tnew_user = alloc_uid(new->uid);",
            "\tif (!new_user)",
            "\t\treturn -EAGAIN;",
            "",
            "\tfree_uid(new->user);",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_user(new, new_user);",
            "\t#else",
            "\tnew->user = new_user;",
            "\t#endif",
            "\treturn 0;",
            "}",
            "static void flag_nproc_exceeded(struct cred *new)",
            "{",
            "\tif (new->ucounts == current_ucounts())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * We don't fail in case of NPROC limit excess here because too many",
            "\t * poorly written programs don't check set*uid() return code, assuming",
            "\t * it never fails if called by root.  We may still enforce NPROC limit",
            "\t * for programs doing set*uid()+execve() by harmlessly deferring the",
            "\t * failure to the execve() stage.",
            "\t */",
            "\tif (is_rlimit_overlimit(new->ucounts, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC)) &&",
            "\t\t\tnew->user != INIT_USER)",
            "\t\tcurrent->flags |= PF_NPROC_EXCEEDED;",
            "\telse",
            "\t\tcurrent->flags &= ~PF_NPROC_EXCEEDED;",
            "}",
            "long __sys_setreuid(uid_t ruid, uid_t euid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kruid, keuid;",
            "",
            "\tkruid = make_kuid(ns, ruid);",
            "\tkeuid = make_kuid(ns, euid);",
            "",
            "\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))",
            "\t\treturn -EINVAL;",
            "\tif ((euid != (uid_t) -1) && !uid_valid(keuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ruid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kruid);",
            "\t\t#else",
            "\t\tnew->uid = kruid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, kruid) &&",
            "\t\t    !uid_eq(old->euid, kruid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (euid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_euid(new, keuid);",
            "\t\t#else",
            "\t\tnew->euid = keuid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, keuid) &&",
            "\t\t    !uid_eq(old->euid, keuid) &&",
            "\t\t    !uid_eq(old->suid, keuid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (!uid_eq(new->uid, old->uid)) {",
            "\t\tretval = set_user(new);",
            "\t\tif (retval < 0)",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (ruid != (uid_t) -1 ||",
            "\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_suid(new, new->euid);",
            "\t\t#else",
            "\t\tnew->suid = new->euid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(new, new->euid);",
            "\t#else",
            "\tnew->fsuid = new->euid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_RE);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "__sys_setgid, if, set_user, flag_nproc_exceeded, __sys_setreuid",
          "description": "实现用户ID调整逻辑，包含用户结构体分配、NPROC限制检测及用户命名空间权限校验，更新进程的有效/实始用户ID。",
          "similarity": 0.5893315672874451
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sys.c",
          "start_line": 666,
          "end_line": 811,
          "content": [
            "long __sys_setuid(uid_t uid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kuid;",
            "",
            "\tkuid = make_kuid(ns, uid);",
            "\tif (!uid_valid(kuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ns_capable_setid(old->user_ns, CAP_SETUID)) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kuid);",
            "\t\tiee_set_cred_suid(new, kuid);",
            "\t\t#else",
            "\t\tnew->suid = new->uid = kuid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(kuid, old->uid)) {",
            "\t\t\tretval = set_user(new);",
            "\t\t\tif (retval < 0)",
            "\t\t\t\tgoto error;",
            "\t\t}",
            "\t} else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {",
            "\t\tgoto error;",
            "\t}",
            "",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_euid(new, kuid);",
            "\tiee_set_cred_fsuid(new, kuid);",
            "\t#else",
            "\tnew->fsuid = new->euid = kuid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_ID);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kruid, keuid, ksuid;",
            "\tbool ruid_new, euid_new, suid_new;",
            "",
            "\tkruid = make_kuid(ns, ruid);",
            "\tkeuid = make_kuid(ns, euid);",
            "\tksuid = make_kuid(ns, suid);",
            "",
            "\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((euid != (uid_t) -1) && !uid_valid(keuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((suid != (uid_t) -1) && !uid_valid(ksuid))",
            "\t\treturn -EINVAL;",
            "",
            "\told = current_cred();",
            "",
            "\t/* check for no-op */",
            "\tif ((ruid == (uid_t) -1 || uid_eq(kruid, old->uid)) &&",
            "\t    (euid == (uid_t) -1 || (uid_eq(keuid, old->euid) &&",
            "\t\t\t\t    uid_eq(keuid, old->fsuid))) &&",
            "\t    (suid == (uid_t) -1 || uid_eq(ksuid, old->suid)))",
            "\t\treturn 0;",
            "",
            "\truid_new = ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&",
            "\t\t   !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid);",
            "\teuid_new = euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&",
            "\t\t   !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid);",
            "\tsuid_new = suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&",
            "\t\t   !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid);",
            "\tif ((ruid_new || euid_new || suid_new) &&",
            "\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\treturn -EPERM;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (ruid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kruid);",
            "\t\t#else",
            "\t\tnew->uid = kruid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(kruid, old->uid)) {",
            "\t\t\tretval = set_user(new);",
            "\t\t\tif (retval < 0)",
            "\t\t\t\tgoto error;",
            "\t\t}",
            "\t}",
            "\tif (euid != (uid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_euid(new, keuid);",
            "\t\t#else",
            "\t\tnew->euid = keuid;",
            "\t\t#endif",
            "\tif (suid != (uid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_suid(new, ksuid);",
            "\t\t#else",
            "\t\tnew->suid = ksuid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(new, new->euid);",
            "\t#else",
            "\tnew->fsuid = new->euid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_RES);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "__sys_setuid, __sys_setresuid",
          "description": "实现用户ID调整接口，支持基础UID设置与资源管理UID设置，包含完整性校验和用户结构体更新操作。",
          "similarity": 0.5808011293411255
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/sys.c",
          "start_line": 851,
          "end_line": 966,
          "content": [
            "long __sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t krgid, kegid, ksgid;",
            "\tbool rgid_new, egid_new, sgid_new;",
            "",
            "\tkrgid = make_kgid(ns, rgid);",
            "\tkegid = make_kgid(ns, egid);",
            "\tksgid = make_kgid(ns, sgid);",
            "",
            "\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))",
            "\t\treturn -EINVAL;",
            "\tif ((egid != (gid_t) -1) && !gid_valid(kegid))",
            "\t\treturn -EINVAL;",
            "\tif ((sgid != (gid_t) -1) && !gid_valid(ksgid))",
            "\t\treturn -EINVAL;",
            "",
            "\told = current_cred();",
            "",
            "\t/* check for no-op */",
            "\tif ((rgid == (gid_t) -1 || gid_eq(krgid, old->gid)) &&",
            "\t    (egid == (gid_t) -1 || (gid_eq(kegid, old->egid) &&",
            "\t\t\t\t    gid_eq(kegid, old->fsgid))) &&",
            "\t    (sgid == (gid_t) -1 || gid_eq(ksgid, old->sgid)))",
            "\t\treturn 0;",
            "",
            "\trgid_new = rgid != (gid_t) -1        && !gid_eq(krgid, old->gid) &&",
            "\t\t   !gid_eq(krgid, old->egid) && !gid_eq(krgid, old->sgid);",
            "\tegid_new = egid != (gid_t) -1        && !gid_eq(kegid, old->gid) &&",
            "\t\t   !gid_eq(kegid, old->egid) && !gid_eq(kegid, old->sgid);",
            "\tsgid_new = sgid != (gid_t) -1        && !gid_eq(ksgid, old->gid) &&",
            "\t\t   !gid_eq(ksgid, old->egid) && !gid_eq(ksgid, old->sgid);",
            "\tif ((rgid_new || egid_new || sgid_new) &&",
            "\t    !ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\treturn -EPERM;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (rgid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_gid(new, krgid);",
            "\t\t#else",
            "\t\tnew->gid = krgid;",
            "\t\t#endif",
            "\tif (egid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_egid(new, kegid);",
            "\t\t#else",
            "\t\tnew->egid = kegid;",
            "\t\t#endif",
            "\tif (sgid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_sgid(new, ksgid);",
            "\t\t#else",
            "\t\tnew->sgid = ksgid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsgid(new, new->egid);",
            "\t#else",
            "\tnew->fsgid = new->egid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_RES);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "long __sys_setfsuid(uid_t uid)",
            "{",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tuid_t old_fsuid;",
            "\tkuid_t kuid;",
            "",
            "\told = current_cred();",
            "\told_fsuid = from_kuid_munged(old->user_ns, old->fsuid);",
            "",
            "\tkuid = make_kuid(old->user_ns, uid);",
            "\tif (!uid_valid(kuid))",
            "\t\treturn old_fsuid;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn old_fsuid;",
            "",
            "\tif (uid_eq(kuid, old->uid)  || uid_eq(kuid, old->euid)  ||",
            "\t    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||",
            "\t    ns_capable_setid(old->user_ns, CAP_SETUID)) {",
            "\t\tif (!uid_eq(kuid, old->fsuid)) {",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_fsuid(new, kuid);",
            "\t\t\t#else",
            "\t\t\tnew->fsuid = kuid;",
            "\t\t\t#endif",
            "\t\t\tif (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)",
            "\t\t\t\tgoto change_okay;",
            "\t\t}",
            "\t}",
            "",
            "\tabort_creds(new);",
            "\treturn old_fsuid;",
            "",
            "change_okay:",
            "\tcommit_creds(new);",
            "\treturn old_fsuid;",
            "}"
          ],
          "function_name": "__sys_setresgid, __sys_setfsuid",
          "description": "实现组ID资源管理接口及文件系统用户ID设置，包含组ID字段更新和文件系统用户ID的权限控制逻辑。",
          "similarity": 0.5754661560058594
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sys.c",
          "start_line": 182,
          "end_line": 286,
          "content": [
            "static bool set_one_prio_perm(struct task_struct *p)",
            "{",
            "\tconst struct cred *cred = current_cred(), *pcred = __task_cred(p);",
            "",
            "\tif (uid_eq(pcred->uid,  cred->euid) ||",
            "\t    uid_eq(pcred->euid, cred->euid))",
            "\t\treturn true;",
            "\tif (ns_capable(pcred->user_ns, CAP_SYS_NICE))",
            "\t\treturn true;",
            "\treturn false;",
            "}",
            "static int set_one_prio(struct task_struct *p, int niceval, int error)",
            "{",
            "\tint no_nice;",
            "",
            "\tif (!set_one_prio_perm(p)) {",
            "\t\terror = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "\tif (niceval < task_nice(p) && !can_nice(p, niceval)) {",
            "\t\terror = -EACCES;",
            "\t\tgoto out;",
            "\t}",
            "\tno_nice = security_task_setnice(p, niceval);",
            "\tif (no_nice) {",
            "\t\terror = no_nice;",
            "\t\tgoto out;",
            "\t}",
            "\tif (error == -ESRCH)",
            "\t\terror = 0;",
            "\tset_user_nice(p, niceval);",
            "out:",
            "\treturn error;",
            "}",
            "long __sys_setregid(gid_t rgid, gid_t egid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t krgid, kegid;",
            "",
            "\tkrgid = make_kgid(ns, rgid);",
            "\tkegid = make_kgid(ns, egid);",
            "",
            "\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))",
            "\t\treturn -EINVAL;",
            "\tif ((egid != (gid_t) -1) && !gid_valid(kegid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (rgid != (gid_t) -1) {",
            "\t\tif (gid_eq(old->gid, krgid) ||",
            "\t\t    gid_eq(old->egid, krgid) ||",
            "\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_gid(new, krgid);",
            "\t\t\t#else",
            "\t\t\tnew->gid = krgid;",
            "\t\t\t#endif",
            "\t\telse",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (egid != (gid_t) -1) {",
            "\t\tif (gid_eq(old->gid, kegid) ||",
            "\t\t    gid_eq(old->egid, kegid) ||",
            "\t\t    gid_eq(old->sgid, kegid) ||",
            "\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_egid(new, kegid);",
            "\t\t\t#else",
            "\t\t\tnew->egid = kegid;",
            "\t\t\t#endif",
            "\t\telse",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (rgid != (gid_t) -1 ||",
            "\t    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_sgid(new, new->egid);",
            "\t\t#else",
            "\t\tnew->sgid = new->egid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsgid(new, new->egid);",
            "\t#else",
            "\tnew->fsgid = new->egid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_RE);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "set_one_prio_perm, set_one_prio, __sys_setregid",
          "description": "实现组ID调整逻辑，包含优先级调整权限验证及组ID设置，通过cred结构体更新目标进程的gid/egid字段。",
          "similarity": 0.5671355724334717
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/sys.c",
          "start_line": 1755,
          "end_line": 1795,
          "content": [
            "static void rlim64_to_rlim(const struct rlimit64 *rlim64, struct rlimit *rlim)",
            "{",
            "\tif (rlim64_is_infinity(rlim64->rlim_cur))",
            "\t\trlim->rlim_cur = RLIM_INFINITY;",
            "\telse",
            "\t\trlim->rlim_cur = (unsigned long)rlim64->rlim_cur;",
            "\tif (rlim64_is_infinity(rlim64->rlim_max))",
            "\t\trlim->rlim_max = RLIM_INFINITY;",
            "\telse",
            "\t\trlim->rlim_max = (unsigned long)rlim64->rlim_max;",
            "}",
            "static int check_prlimit_permission(struct task_struct *task,",
            "\t\t\t\t    unsigned int flags)",
            "{",
            "\tconst struct cred *cred = current_cred(), *tcred;",
            "\tbool id_match;",
            "",
            "\tif (current == task)",
            "\t\treturn 0;",
            "",
            "\ttcred = __task_cred(task);",
            "\tid_match = (uid_eq(cred->uid, tcred->euid) &&",
            "\t\t    uid_eq(cred->uid, tcred->suid) &&",
            "\t\t    uid_eq(cred->uid, tcred->uid)  &&",
            "\t\t    gid_eq(cred->gid, tcred->egid) &&",
            "\t\t    gid_eq(cred->gid, tcred->sgid) &&",
            "\t\t    gid_eq(cred->gid, tcred->gid));",
            "\tif (!id_match && !ns_capable(tcred->user_ns, CAP_SYS_RESOURCE))",
            "\t\treturn -EPERM;",
            "",
            "\treturn security_task_prlimit(cred, tcred, flags);",
            "}",
            "static void accumulate_thread_rusage(struct task_struct *t, struct rusage *r)",
            "{",
            "\tr->ru_nvcsw += t->nvcsw;",
            "\tr->ru_nivcsw += t->nivcsw;",
            "\tr->ru_minflt += t->min_flt;",
            "\tr->ru_majflt += t->maj_flt;",
            "\tr->ru_inblock += task_io_get_inblock(t);",
            "\tr->ru_oublock += task_io_get_oublock(t);",
            "}"
          ],
          "function_name": "rlim64_to_rlim, check_prlimit_permission, accumulate_thread_rusage",
          "description": "该代码块包含三个辅助函数：  \n1. `rlim64_to_rlim` 实现从64位资源限制结构体到传统32位`struct rlimit`的类型转换，处理无穷大的边界条件；  \n2. `check_prlimit_permission` 检查当前进程对目标任务执行`prlimit`系统调用的权限，通过对比有效UID/GID及命名空间能力进行访问控制；  \n3. `accumulate_thread_rusage` 累加子线程的资源使用统计信息至父线程的`rusage`结构，用于进程资源消耗追踪。  \n\n所有函数均基于完整上下文实现，未引入额外API或机制。",
          "similarity": 0.5329033136367798
        }
      ]
    },
    {
      "source_file": "kernel/entry/common.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:19:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\common.c`\n\n---\n\n# entry\\common.c 技术文档\n\n## 文件概述\n\n`entry\\common.c` 是 Linux 内核中处理系统调用入口/出口以及中断入口/出口路径的通用逻辑实现文件。该文件提供了一套架构无关的通用函数，用于在用户态与内核态之间切换时执行必要的上下文跟踪、审计、跟踪点、安全检查（如 seccomp）、信号处理、调度等工作。其目标是统一不同架构在系统调用和中断处理路径上的共性逻辑，减少重复代码。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `syscall_trace_enter()` | 系统调用进入时的通用处理函数，依次处理用户态分发、ptrace 跟踪、seccomp 安全检查、tracepoint 和审计 |\n| `syscall_enter_from_user_mode_prepare()` | 从用户模式进入系统调用前的准备，启用中断并进入内核上下文 |\n| `exit_to_user_mode_loop()` | 在返回用户空间前循环处理所有待办工作项（如调度、信号、uprobe、livepatch 等） |\n| `syscall_exit_work()` | 系统调用退出时的通用处理，包括审计、tracepoint、ptrace 退出报告等 |\n| `irqentry_enter()` / `irqentry_exit()` | 中断入口/出口的通用处理，管理 RCU、上下文跟踪、KMSAN、lockdep 等 |\n| `irqentry_enter_from_user_mode()` / `irqentry_exit_to_user_mode()` | 从中断上下文进入/退出用户模式的专用路径 |\n| `raw_irqentry_exit_cond_resched()` | 中断退出时的条件调度检查（仅在非抢占计数为 0 时） |\n\n### 关键数据结构\n\n- `irqentry_state_t`：记录中断入口状态，主要用于判断是否需要在退出时执行 RCU 相关操作。\n- `SYSCALL_WORK_*` 和 `_TIF_*` 标志位：用于标识待处理的工作类型（如 trace、seccomp、信号、调度等）。\n\n## 关键实现\n\n### 系统调用入口处理流程（`syscall_trace_enter`）\n\n1. **Syscall User Dispatch 优先处理**：若设置了 `SYSCALL_WORK_SYSCALL_USER_DISPATCH`，调用 `syscall_user_dispatch()`，若返回 true 则直接终止系统调用（返回 `-1`），因为此时 ABI 可能无效。\n2. **Ptrace 跟踪**：若设置了 `SYSCALL_WORK_SYSCALL_TRACE` 或 `SYSCALL_WORK_SYSCALL_EMU`，调用 `ptrace_report_syscall_entry()`。若 tracer 修改了行为或启用了 `SYSCALL_EMU`，则终止系统调用。\n3. **Seccomp 安全检查**：在 ptrace 之后执行，以捕获 tracer 可能引入的变更。调用 `__secure_computing()`，若返回 `-1` 则拒绝系统调用。\n4. **重新获取系统调用号**：上述步骤可能修改了系统调用号，需重新通过 `syscall_get_nr()` 获取。\n5. **Tracepoint 触发**：若启用 `SYSCALL_WORK_SYSCALL_TRACEPOINT`，触发 `trace_sys_enter`，并再次重新获取系统调用号（因 BPF 或 kprobe 可能修改）。\n6. **审计日志**：调用 `syscall_enter_audit()` 记录审计事件。\n7. **返回最终系统调用号或错误码**。\n\n### 返回用户空间前的工作循环（`exit_to_user_mode_loop`）\n\n- 使用 `while (ti_work & EXIT_TO_USER_MODE_WORK)` 循环处理所有待办工作，确保在返回用户态前完成：\n  - 调度（`_TIF_NEED_RESCHED`）\n  - Uprobe 通知（`_TIF_UPROBE`）\n  - Livepatch 状态更新（`_TIF_PATCH_PENDING`）\n  - 信号处理（`_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL`）\n  - 用户态恢复工作（`_TIF_NOTIFY_RESUME`）\n  - 架构特定工作（`arch_exit_to_user_mode_work`）\n- 每次循环启用中断（`local_irq_enable_exit_to_user`），处理完后再关闭中断并重新读取线程标志（`read_thread_flags()`），以应对处理过程中新产生的工作项。\n- 最后调用 `tick_nohz_user_enter_prepare()` 处理 NO_HZ 模式下的 tick 准备。\n\n### 中断入口/出口的 RCU 与上下文管理\n\n- **从中断进入用户态**：调用 `enter_from_user_mode()`，启用中断。\n- **从内核态中断入口**：\n  - 若当前是 idle 任务且非 `TINY_RCU`，无条件调用 `ct_irq_enter()` 以确保 RCU 状态一致（避免嵌套中断导致 grace period 错误结束）。\n  - 否则调用 `rcu_irq_enter_check_tick()`。\n- 所有路径均正确处理 `lockdep`、`KMSAN`（解除寄存器毒化）和 `trace_hardirqs_off` 的顺序，确保调试和安全工具正常工作。\n\n### 条件调度支持（Preemption）\n\n- `raw_irqentry_exit_cond_resched()` 在中断退出且 `preempt_count() == 0` 时检查是否需要调度。\n- 支持动态抢占（`CONFIG_PREEMPT_DYNAMIC`），通过 `static_call` 或 `static_key` 实现运行时切换，避免编译时硬编码。\n\n## 依赖关系\n\n### 头文件依赖\n- `<linux/context_tracking.h>`：上下文跟踪（用户/内核态切换）\n- `<linux/resume_user_mode.h>`：用户态恢复工作\n- `<linux/seccomp.h>`（隐式通过 `__secure_computing`）：系统调用过滤\n- `<linux/audit.h>`：审计子系统\n- `<linux/ptrace.h>`（隐式）：ptrace 跟踪\n- `<linux/livepatch.h>`：内核热补丁\n- `<linux/uprobes.h>`（隐式）：用户态探针\n- `<linux/rcupdate.h>`：RCU 机制\n- `<linux/kmsan.h>`：Kernel Memory Sanitizer 支持\n- `<trace/events/syscalls.h>`：系统调用跟踪点\n\n### 架构依赖\n- 依赖架构特定实现：\n  - `syscall_get_arguments()` / `syscall_get_nr()` / `syscall_get_return_value()`\n  - `user_mode()` / `regs_irqs_disabled()`\n  - `arch_do_signal_or_restart()`（弱符号，默认空实现）\n  - `arch_exit_to_user_mode_work()`\n\n### 子系统交互\n- **RCU**：管理中断和用户态切换时的宽限期\n- **Scheduler**：处理 `need_resched()` 和 `schedule()`\n- **Security**：seccomp、audit\n- **Tracing**：ftrace、kprobe、uprobe、BPF\n- **Livepatch**：动态补丁状态更新\n\n## 使用场景\n\n1. **系统调用入口路径**：  \n   当用户程序执行 `syscall` 指令（或其他系统调用机制）进入内核时，架构代码调用 `syscall_trace_enter()` 执行通用预处理。\n\n2. **系统调用出口路径**：  \n   系统调用返回前，若存在待处理工作（如审计、tracepoint），调用 `syscall_exit_work()`。\n\n3. **中断处理返回用户空间**：  \n   中断处理完成后，若返回用户态，调用 `irqentry_exit_to_user_mode()`，进而触发 `exit_to_user_mode_loop()` 处理所有 pending work。\n\n4. **中断嵌套与 idle 任务处理**：  \n   在 idle 任务中发生中断时，确保 RCU 正确进入 IRQ 上下文，防止 grace period 错误终止。\n\n5. **动态抢占支持**：  \n   在支持动态抢占的系统中，中断退出时根据运行时配置决定是否执行条件调度。\n\n6. **调试与安全工具集成**：  \n   为 KMSAN、Lockdep、ftrace、audit、seccomp 等子系统提供统一的入口/出口钩子，确保工具链在系统调用和中断路径上正常工作。",
      "similarity": 0.5930094718933105,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/common.c",
          "start_line": 141,
          "end_line": 250,
          "content": [
            "static inline bool report_single_step(unsigned long work)",
            "{",
            "\tif (work & SYSCALL_WORK_SYSCALL_EMU)",
            "\t\treturn false;",
            "",
            "\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;",
            "}",
            "void syscall_exit_work(struct pt_regs *regs, unsigned long work)",
            "{",
            "\tbool step;",
            "",
            "\t/*",
            "\t * If the syscall was rolled back due to syscall user dispatching,",
            "\t * then the tracers below are not invoked for the same reason as",
            "\t * the entry side was not invoked in syscall_trace_enter(): The ABI",
            "\t * of these syscalls is unknown.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {",
            "\t\t\tcurrent->syscall_dispatch.on_dispatch = false;",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\taudit_syscall_exit(regs);",
            "",
            "\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)",
            "\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));",
            "",
            "\tstep = report_single_step(work);",
            "\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)",
            "\t\tptrace_report_syscall_exit(regs, step);",
            "}",
            "noinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "}",
            "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)",
            "{",
            "\tinstrumentation_begin();",
            "\texit_to_user_mode_prepare(regs);",
            "\tinstrumentation_end();",
            "\texit_to_user_mode();",
            "}",
            "noinstr irqentry_state_t irqentry_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t ret = {",
            "\t\t.exit_rcu = false,",
            "\t};",
            "",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_enter_from_user_mode(regs);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If this entry hit the idle task invoke ct_irq_enter() whether",
            "\t * RCU is watching or not.",
            "\t *",
            "\t * Interrupts can nest when the first interrupt invokes softirq",
            "\t * processing on return which enables interrupts.",
            "\t *",
            "\t * Scheduler ticks in the idle task can mark quiescent state and",
            "\t * terminate a grace period, if and only if the timer interrupt is",
            "\t * not nested into another interrupt.",
            "\t *",
            "\t * Checking for rcu_is_watching() here would prevent the nesting",
            "\t * interrupt to invoke ct_irq_enter(). If that nested interrupt is",
            "\t * the tick then rcu_flavor_sched_clock_irq() would wrongfully",
            "\t * assume that it is the first interrupt and eventually claim",
            "\t * quiescent state and end grace periods prematurely.",
            "\t *",
            "\t * Unconditionally invoke ct_irq_enter() so RCU state stays",
            "\t * consistent.",
            "\t *",
            "\t * TINY_RCU does not support EQS, so let the compiler eliminate",
            "\t * this part when enabled.",
            "\t */",
            "\tif (!IS_ENABLED(CONFIG_TINY_RCU) && is_idle_task(current)) {",
            "\t\t/*",
            "\t\t * If RCU is not watching then the same careful",
            "\t\t * sequence vs. lockdep and tracing is required",
            "\t\t * as in irqentry_enter_from_user_mode().",
            "\t\t */",
            "\t\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\t\tct_irq_enter();",
            "\t\tinstrumentation_begin();",
            "\t\tkmsan_unpoison_entry_regs(regs);",
            "\t\ttrace_hardirqs_off_finish();",
            "\t\tinstrumentation_end();",
            "",
            "\t\tret.exit_rcu = true;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If RCU is watching then RCU only wants to check whether it needs",
            "\t * to restart the tick in NOHZ mode. rcu_irq_enter_check_tick()",
            "\t * already contains a warning when RCU is not watching, so no point",
            "\t * in having another one here.",
            "\t */",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\trcu_irq_enter_check_tick();",
            "\ttrace_hardirqs_off_finish();",
            "\tinstrumentation_end();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "report_single_step, syscall_exit_work, irqentry_enter_from_user_mode, irqentry_exit_to_user_mode, irqentry_enter",
          "description": "处理系统调用退出阶段工作，包括审计退出记录、单步调试报告和跟踪点事件，同时管理中断返回时的RCU状态转换和锁依赖检查",
          "similarity": 0.6765221953392029
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/common.c",
          "start_line": 18,
          "end_line": 124,
          "content": [
            "static inline void syscall_enter_audit(struct pt_regs *regs, long syscall)",
            "{",
            "\tif (unlikely(audit_context())) {",
            "\t\tunsigned long args[6];",
            "",
            "\t\tsyscall_get_arguments(current, regs, args);",
            "\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);",
            "\t}",
            "}",
            "long syscall_trace_enter(struct pt_regs *regs, long syscall,",
            "\t\t\t\tunsigned long work)",
            "{",
            "\tlong ret = 0;",
            "",
            "\t/*",
            "\t * Handle Syscall User Dispatch.  This must comes first, since",
            "\t * the ABI here can be something that doesn't make sense for",
            "\t * other syscall_work features.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (syscall_user_dispatch(regs))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Handle ptrace */",
            "\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {",
            "\t\tret = ptrace_report_syscall_entry(regs);",
            "\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Do seccomp after ptrace, to catch any tracer changes. */",
            "\tif (work & SYSCALL_WORK_SECCOMP) {",
            "\t\tret = __secure_computing(NULL);",
            "\t\tif (ret == -1L)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/* Either of the above might have changed the syscall number */",
            "\tsyscall = syscall_get_nr(current, regs);",
            "",
            "\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT)) {",
            "\t\ttrace_sys_enter(regs, syscall);",
            "\t\t/*",
            "\t\t * Probes or BPF hooks in the tracepoint may have changed the",
            "\t\t * system call number as well.",
            "\t\t */",
            "\t\tsyscall = syscall_get_nr(current, regs);",
            "\t}",
            "",
            "\tsyscall_enter_audit(regs, syscall);",
            "",
            "\treturn ret ? : syscall;",
            "}",
            "noinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "\tinstrumentation_begin();",
            "\tlocal_irq_enable();",
            "\tinstrumentation_end();",
            "}",
            "void __weak arch_do_signal_or_restart(struct pt_regs *regs) { }",
            "__always_inline unsigned long exit_to_user_mode_loop(struct pt_regs *regs,",
            "\t\t\t\t\t\t     unsigned long ti_work)",
            "{",
            "\t/*",
            "\t * Before returning to user space ensure that all pending work",
            "\t * items have been completed.",
            "\t */",
            "\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {",
            "",
            "\t\tlocal_irq_enable_exit_to_user(ti_work);",
            "",
            "\t\tif (ti_work & _TIF_NEED_RESCHED)",
            "\t\t\tschedule();",
            "",
            "\t\tif (ti_work & _TIF_UPROBE)",
            "\t\t\tuprobe_notify_resume(regs);",
            "",
            "\t\tif (ti_work & _TIF_PATCH_PENDING)",
            "\t\t\tklp_update_patch_state(current);",
            "",
            "\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))",
            "\t\t\tarch_do_signal_or_restart(regs);",
            "",
            "\t\tif (ti_work & _TIF_NOTIFY_RESUME)",
            "\t\t\tresume_user_mode_work(regs);",
            "",
            "\t\t/* Architecture specific TIF work */",
            "\t\tarch_exit_to_user_mode_work(regs, ti_work);",
            "",
            "\t\t/*",
            "\t\t * Disable interrupts and reevaluate the work flags as they",
            "\t\t * might have changed while interrupts and preemption was",
            "\t\t * enabled above.",
            "\t\t */",
            "\t\tlocal_irq_disable_exit_to_user();",
            "",
            "\t\t/* Check if any of the above work has queued a deferred wakeup */",
            "\t\ttick_nohz_user_enter_prepare();",
            "",
            "\t\tti_work = read_thread_flags();",
            "\t}",
            "",
            "\t/* Return the latest work state for arch_exit_to_user_mode() */",
            "\treturn ti_work;",
            "}"
          ],
          "function_name": "syscall_enter_audit, syscall_trace_enter, syscall_enter_from_user_mode_prepare, arch_do_signal_or_restart, exit_to_user_mode_loop",
          "description": "实现系统调用入口处理逻辑，依次处理审计追踪、指针观察、seccomp过滤及架构特定工作，通过位掩码控制不同安全机制的触发顺序并更新系统调用号",
          "similarity": 0.6602418422698975
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/common.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/context_tracking.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/highmem.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmsan.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/audit.h>",
            "#include <linux/tick.h>",
            "",
            "#include \"common.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/syscalls.h>",
            ""
          ],
          "function_name": null,
          "description": "声明系统调用通用功能所需头文件，包含审计、跟踪、KMSAN、LivePatch等模块的接口定义，为后续系统调用入口处理提供基础依赖",
          "similarity": 0.6023842096328735
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/entry/common.c",
          "start_line": 256,
          "end_line": 347,
          "content": [
            "void raw_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!preempt_count()) {",
            "\t\t/* Sanity check RCU and thread stack */",
            "\t\trcu_irq_exit_check_preempt();",
            "\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))",
            "\t\t\tWARN_ON_ONCE(!on_thread_stack());",
            "\t\tif (need_resched())",
            "\t\t\tpreempt_schedule_irq();",
            "\t}",
            "}",
            "void dynamic_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!static_branch_unlikely(&sk_dynamic_irqentry_exit_cond_resched))",
            "\t\treturn;",
            "\traw_irqentry_exit_cond_resched();",
            "}",
            "noinstr void irqentry_exit(struct pt_regs *regs, irqentry_state_t state)",
            "{",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\t/* Check whether this returns to user mode */",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_exit_to_user_mode(regs);",
            "\t} else if (!regs_irqs_disabled(regs)) {",
            "\t\t/*",
            "\t\t * If RCU was not watching on entry this needs to be done",
            "\t\t * carefully and needs the same ordering of lockdep/tracing",
            "\t\t * and RCU as the return to user mode path.",
            "\t\t */",
            "\t\tif (state.exit_rcu) {",
            "\t\t\tinstrumentation_begin();",
            "\t\t\t/* Tell the tracer that IRET will enable interrupts */",
            "\t\t\ttrace_hardirqs_on_prepare();",
            "\t\t\tlockdep_hardirqs_on_prepare();",
            "\t\t\tinstrumentation_end();",
            "\t\t\tct_irq_exit();",
            "\t\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tinstrumentation_begin();",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPTION))",
            "\t\t\tirqentry_exit_cond_resched();",
            "",
            "\t\t/* Covers both tracing and lockdep */",
            "\t\ttrace_hardirqs_on();",
            "\t\tinstrumentation_end();",
            "\t} else {",
            "\t\t/*",
            "\t\t * IRQ flags state is correct already. Just tell RCU if it",
            "\t\t * was not watching on entry.",
            "\t\t */",
            "\t\tif (state.exit_rcu)",
            "\t\t\tct_irq_exit();",
            "\t}",
            "}",
            "irqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t irq_state;",
            "",
            "\tirq_state.lockdep = lockdep_hardirqs_enabled();",
            "",
            "\t__nmi_enter();",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tlockdep_hardirq_enter();",
            "\tct_nmi_enter();",
            "",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\ttrace_hardirqs_off_finish();",
            "\tftrace_nmi_enter();",
            "\tinstrumentation_end();",
            "",
            "\treturn irq_state;",
            "}",
            "void noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state)",
            "{",
            "\tinstrumentation_begin();",
            "\tftrace_nmi_exit();",
            "\tif (irq_state.lockdep) {",
            "\t\ttrace_hardirqs_on_prepare();",
            "\t\tlockdep_hardirqs_on_prepare();",
            "\t}",
            "\tinstrumentation_end();",
            "",
            "\tct_nmi_exit();",
            "\tlockdep_hardirq_exit();",
            "\tif (irq_state.lockdep)",
            "\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t__nmi_exit();",
            "}"
          ],
          "function_name": "raw_irqentry_exit_cond_resched, dynamic_irqentry_exit_cond_resched, irqentry_exit, irqentry_nmi_enter, irqentry_nmi_exit",
          "description": "实现中断退出路径的条件调度检查和NMI上下文切换，维护中断标志状态一致性，处理RCU状态转换、锁依赖标记恢复及异常中断返回时的上下文还原",
          "similarity": 0.5724852681159973
        }
      ]
    }
  ]
}