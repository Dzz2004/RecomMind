{
  "query": "privilege levels",
  "timestamp": "2025-12-25 23:59:23",
  "retrieved_files": [
    {
      "source_file": "kernel/capability.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:39:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `capability.c`\n\n---\n\n# capability.c 技术文档\n\n## 1. 文件概述\n\n`capability.c` 是 Linux 内核中实现 POSIX 能力（Capabilities）机制的核心文件，位于 `kernel/` 目录下。该文件主要负责提供用户空间与内核之间进行能力获取（`capget`）和设置（`capset`）的系统调用接口，并维护能力模型的版本兼容性、安全策略检查以及与 LSM（Linux Security Module）框架的集成。能力机制允许将传统超级用户权限细分为多个独立的特权单元，从而实现最小权限原则。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `file_caps_enabled`：控制是否启用文件能力（File Capabilities）功能的全局开关，默认启用。可通过内核启动参数 `no_file_caps` 禁用。\n\n### 主要函数\n- **`cap_validate_magic()`**：验证用户传入的能力结构体版本号，支持 v1、v2、v3 版本，并对旧版本发出警告。\n- **`cap_get_target_pid()`**：安全地获取指定进程（通过 PID）的有效（Effective）、可继承（Inheritable）和允许（Permitted）能力集。\n- **`sys_capget()`**：`capget(2)` 系统调用的实现，用于查询指定进程的能力集。\n- **`sys_capset()`**：`capset(2)` 系统调用的实现，用于设置当前进程的能力集（仅限自身）。\n- **`mk_kernel_cap()`**：将用户空间传入的高低 32 位能力值组合成内核内部的 `kernel_cap_t` 类型。\n- **`has_ns_capability()`**（截断）：检查指定任务在给定用户命名空间中是否拥有某项能力（函数体在提供的代码中被截断）。\n\n### 辅助函数\n- `warn_legacy_capability_use()`：对使用 v1（32 位）能力接口的应用程序发出一次性警告。\n- `warn_deprecated_v2()`：对使用已弃用的 v2 能力接口的应用程序发出一次性警告。\n\n## 3. 关键实现\n\n### 能力版本兼容性处理\n- 支持三种能力结构版本：\n  - **v1 (`_LINUX_CAPABILITY_VERSION_1`)**：仅支持 32 位能力（旧版），调用时触发 `warn_legacy_capability_use()`。\n  - **v2 (`_LINUX_CAPABILITY_VERSION_2`)**：支持 64 位能力但存在安全风险，调用时触发 `warn_deprecated_v2()`。\n  - **v3 (`_LINUX_CAPABILITY_VERSION_3`)**：当前推荐版本，功能等同于 v2 但通过头文件变更避免误用。\n- 对于无效版本，内核会尝试将当前支持的版本号写回用户空间并返回 `-EINVAL`。\n\n### 能力数据传输格式\n- 用户空间使用两个 `__user_cap_data_struct` 结构体（`kdata[2]`）来表示 64 位能力值：\n  - `kdata[0]` 存储低 32 位\n  - `kdata[1]` 存储高 32 位\n- 在 `capget` 中，内核能力值被拆分为高低 32 位写入用户缓冲区；在 `capset` 中则反向组合。\n- **向后兼容策略**：当用户空间请求的版本只支持 32 位（`tocopy = 1`）时，内核会静默丢弃高 32 位能力，避免旧版 `libcap` 应用崩溃。\n\n### 安全限制\n- **`capset` 限制**：仅允许进程修改自身能力（`pid` 必须为 0 或当前进程 PID），修改其他进程能力的功能已被移除。\n- **能力设置规则**（由 LSM 实现，如 `security_capset`）：\n  - 新的 **可继承集（I）** 和 **允许集（P）** 只能是旧允许集的子集。\n  - 新的 **有效集（E）** 必须是新允许集的子集。\n- 使用 `prepare_creds()` / `commit_creds()` 机制安全地更新进程凭证（credentials），并在失败时通过 `abort_creds()` 回滚。\n\n### 并发与锁机制\n- 获取**其他进程**能力时，使用 `rcu_read_lock()` 保护对进程链表的访问（通过 `find_task_by_vpid()`）。\n- 获取**当前进程**能力时无需加锁，因为能力修改是原子的（通过凭证替换）。\n\n### 审计与日志\n- `capset` 成功时调用 `audit_log_capset()` 记录能力变更事件，用于安全审计。\n- 对旧版能力接口的使用通过 `pr_info_once()` 发出一次性内核日志警告。\n\n## 4. 依赖关系\n\n- **LSM 框架**：通过 `security_capget()` 和 `security_capset()` 钩子与安全模块（如 SELinux、AppArmor）交互，实际的能力检查和设置策略由 LSM 实现。\n- **凭证子系统**：依赖 `cred` 结构体管理进程权限，使用 `prepare_creds()`、`commit_creds()` 等函数安全更新。\n- **命名空间**：支持用户命名空间（`user_namespace.h`），能力检查与命名空间隔离相关（体现在 `has_ns_capability` 等函数中）。\n- **审计子系统**：通过 `audit.h` 提供能力变更的审计日志。\n- **系统调用接口**：通过 `SYSCALL_DEFINE2` 定义 `capget` 和 `capset` 系统调用。\n- **用户空间访问**：使用 `uaccess.h` 中的 `copy_to_user()` 和 `copy_from_user()` 安全传输数据。\n\n## 5. 使用场景\n\n- **容器与沙箱**：容器运行时（如 Docker、runc）通过 `capset` 限制容器内进程的能力集，实现权限隔离。\n- **特权程序降权**：需要临时提升权限的程序（如 `ping` 使用 `CAP_NET_RAW`）可在执行关键操作后通过 `capset` 丢弃多余能力。\n- **安全策略实施**：系统管理员或安全模块通过限制进程能力，遵循最小权限原则，减少攻击面。\n- **调试与监控**：安全工具（如 `getpcaps`）通过 `capget` 查询进程当前能力状态，用于诊断或合规检查。\n- **文件能力加载**：虽然本文件不直接处理文件能力，但 `file_caps_enabled` 开关控制是否启用基于文件扩展属性（xattr）的能力加载机制（由 `fs/` 子系统实现）。",
      "similarity": 0.5142742395401001,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/capability.c",
          "start_line": 25,
          "end_line": 125,
          "content": [
            "static int __init file_caps_disable(char *str)",
            "{",
            "\tfile_caps_enabled = 0;",
            "\treturn 1;",
            "}",
            "static void warn_legacy_capability_use(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static void warn_deprecated_v2(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)",
            "{",
            "\t__u32 version;",
            "",
            "\tif (get_user(version, &header->version))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (version) {",
            "\tcase _LINUX_CAPABILITY_VERSION_1:",
            "\t\twarn_legacy_capability_use();",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;",
            "\t\tbreak;",
            "\tcase _LINUX_CAPABILITY_VERSION_2:",
            "\t\twarn_deprecated_v2();",
            "\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */",
            "\tcase _LINUX_CAPABILITY_VERSION_3:",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))",
            "\t\t\treturn -EFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,",
            "\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)",
            "{",
            "\tint ret;",
            "",
            "\tif (pid && (pid != task_pid_vnr(current))) {",
            "\t\tconst struct task_struct *target;",
            "",
            "\t\trcu_read_lock();",
            "",
            "\t\ttarget = find_task_by_vpid(pid);",
            "\t\tif (!target)",
            "\t\t\tret = -ESRCH;",
            "\t\telse",
            "\t\t\tret = security_capget(target, pEp, pIp, pPp);",
            "",
            "\t\trcu_read_unlock();",
            "\t} else",
            "\t\tret = security_capget(current, pEp, pIp, pPp);",
            "",
            "\treturn ret;",
            "}",
            "static kernel_cap_t mk_kernel_cap(u32 low, u32 high)",
            "{",
            "\treturn (kernel_cap_t) { (low | ((u64)high << 32)) & CAP_VALID_MASK };",
            "}",
            "bool has_ns_capability(struct task_struct *t,",
            "\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability(t, &init_user_ns, cap);",
            "}",
            "bool has_ns_capability_noaudit(struct task_struct *t,",
            "\t\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability_noaudit(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);",
            "}"
          ],
          "function_name": "file_caps_disable, warn_legacy_capability_use, warn_deprecated_v2, cap_validate_magic, cap_get_target_pid, mk_kernel_cap, has_ns_capability, has_capability, has_ns_capability_noaudit, has_capability_noaudit",
          "description": "提供能力相关辅助函数，包括禁用文件能力标志、版本验证警告、目标进程能力获取及能力结构构建，实现命名空间能力检查和权限验证逻辑",
          "similarity": 0.5312972068786621
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/capability.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/capability.c",
            " *",
            " * Copyright (C) 1997  Andrew Main <zefram@fysh.org>",
            " *",
            " * Integrated into 2.1.97+,  Andrew G. Morgan <morgan@kernel.org>",
            " * 30 May 2002:\tCleanup, Robert M. Love <rml@tech9.net>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/uaccess.h>",
            "",
            "int file_caps_enabled = 1;",
            ""
          ],
          "function_name": null,
          "description": "声明模块许可证并包含必要的头文件，定义控制文件能力启用状态的全局变量file_caps_enabled",
          "similarity": 0.5047114491462708
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/capability.c",
          "start_line": 351,
          "end_line": 424,
          "content": [
            "static bool ns_capable_common(struct user_namespace *ns,",
            "\t\t\t      int cap,",
            "\t\t\t      unsigned int opts)",
            "{",
            "\tint capable;",
            "",
            "\tif (unlikely(!cap_valid(cap))) {",
            "\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);",
            "\t\tBUG();",
            "\t}",
            "",
            "\tcapable = security_capable(current_cred(), ns, cap, opts);",
            "\tif (capable == 0) {",
            "\t\tcurrent->flags |= PF_SUPERPRIV;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "bool ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);",
            "}",
            "bool ns_capable_noaudit(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);",
            "}",
            "bool ns_capable_setid(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);",
            "}",
            "bool capable(int cap)",
            "{",
            "\treturn ns_capable(&init_user_ns, cap);",
            "}",
            "bool file_ns_capable(const struct file *file, struct user_namespace *ns,",
            "\t\t     int cap)",
            "{",
            "",
            "\tif (WARN_ON_ONCE(!cap_valid(cap)))",
            "\t\treturn false;",
            "",
            "\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,",
            "\t\t\t\t struct mnt_idmap *idmap,",
            "\t\t\t\t const struct inode *inode)",
            "{",
            "\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&",
            "\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));",
            "}",
            "bool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,",
            "\t\t\t      const struct inode *inode, int cap)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "",
            "\treturn ns_capable(ns, cap) &&",
            "\t       privileged_wrt_inode_uidgid(ns, idmap, inode);",
            "}",
            "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)",
            "{",
            "\tint ret = 0;  /* An absent tracer adds no restrictions */",
            "\tconst struct cred *cred;",
            "",
            "\trcu_read_lock();",
            "\tcred = rcu_dereference(tsk->ptracer_cred);",
            "\tif (cred)",
            "\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,",
            "\t\t\t\t       CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "\treturn (ret == 0);",
            "}"
          ],
          "function_name": "ns_capable_common, ns_capable, ns_capable_noaudit, ns_capable_setid, capable, file_ns_capable, privileged_wrt_inode_uidgid, capable_wrt_inode_uidgid, ptracer_capable",
          "description": "实现核心能力检查函数，包含通用命名空间能力检测、当前命名空间能力检查、文件能力验证、基于inode UID/GID的特权判断及跟踪者能力检查等功能",
          "similarity": 0.47506454586982727
        }
      ]
    },
    {
      "source_file": "kernel/printk/nbcon.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:32:39\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `printk\\nbcon.c`\n\n---\n\n# printk/nbcon.c 技术文档\n\n## 文件概述\n\n`printk/nbcon.c` 实现了新一代的 printk 控制台（nbcon，即 \"new console\"）打印机制，该机制不依赖传统的 `console_lock` 互斥锁，而是采用基于原子操作的状态机模型来管理控制台访问。其核心目标是支持高优先级上下文（如中断、NMI、panic）安全、高效地抢占低优先级上下文对控制台的使用权，同时避免死锁和优先级反转问题。该机制特别适用于实时系统和 panic 场景下的可靠日志输出。\n\n## 核心功能\n\n### 主要数据结构\n- **`struct nbcon_state`**：封装控制台状态的原子变量，包含以下关键字段：\n  - `prio`：当前持有控制台的上下文优先级（0 表示未锁定）\n  - `cpu`：当前持有控制台的 CPU 编号\n  - `req_prio`：请求友好移交的更高优先级上下文的优先级\n  - `unsafe`：标志当前是否处于不安全状态（如正在操作共享资源）\n  - `unsafe_takeover`：标志是否发生过不安全的强制接管\n\n### 主要函数\n- **`nbcon_state_set()`**：初始化或重置控制台状态（仅限未注册或初始化阶段使用）\n- **`nbcon_state_read()`**：原子读取当前控制台状态\n- **`nbcon_state_try_cmpxchg()`**：原子比较并交换控制台状态\n- **`nbcon_seq_read()`**：读取控制台当前应打印的 printk 记录序列号\n- **`nbcon_seq_force()`**：强制设置控制台序列号（用于初始化或 panic 场景）\n- **`nbcon_seq_try_update()`**：尝试原子更新控制台序列号\n- **`nbcon_context_try_acquire_direct()`**：尝试直接获取控制台所有权（核心获取逻辑之一）\n\n## 关键实现\n\n### 控制台状态管理机制\n控制台状态通过 `nbcon_state` 原子变量管理，支持三种获取策略：\n1. **直接获取**：当控制台未被占用，或当前持有者优先级更低且处于安全状态时，直接抢占。\n2. **友好移交**：当持有者优先级更低但处于不安全状态时，请求者设置 `req_prio`，持有者在退出不安全状态后主动释放。\n3. **强制接管**：仅在 `panic()` 的最后尝试中使用，无视不安全状态强制接管（标记 `unsafe_takeover`）。\n\n### 安全状态标记\n- **`unsafe` 字段**：在操作共享资源或控制台设备时置位，操作完成后清除。确保高优先级上下文不会在设备不一致状态下接管。\n- **`unsafe_takeover` 字段**：记录强制接管事件，后续需重新初始化控制台状态。\n\n### 序列号管理\n- 使用 64 位序列号跟踪下一条待打印的 printk 记录。\n- 在 32 位系统上，仅存储低 32 位，高 32 位通过 ringbuffer 中的有效序列号推导。\n- `nbcon_seq_force()` 确保设置的序列号不低于 ringbuffer 中最早的有效记录。\n\n### 优先级与 CPU 绑定\n- 优先级数值越大表示优先级越高（`NBCON_PRIO_NONE = 0` 表示无持有者）。\n- `cpu` 字段防止同 CPU 上的忙等待，并处理复杂场景下优先级相同但 CPU 切换的情况。\n\n## 依赖关系\n\n- **内部依赖**：\n  - `printk_ringbuffer.h`：提供 printk 环形缓冲区操作接口（如 `prb_first_valid_seq()`）\n  - `internal.h`：包含 nbcon 内部定义的辅助宏和类型（如 `ACCESS_PRIVATE`、`__ulseq_to_u64seq`）\n- **内核核心模块**：\n  - `linux/atomic.h`：提供原子操作支持\n  - `linux/console.h`：定义 `struct console` 及相关常量\n  - `linux/irqflags.h`：用于中断上下文判断\n  - `linux/smp.h`：SMP 相关支持（如 `smp_processor_id()`）\n- **关键子系统**：\n  - **Printk 子系统**：作为 printk 输出后端，与 ringbuffer 紧密集成\n  - **调度器/中断子系统**：依赖上下文优先级模型（如 NMI > IRQ > 进程）\n\n## 使用场景\n\n1. **常规 printk 输出**：\n   - 高优先级中断/NMI 日志可安全抢占低优先级进程的控制台输出。\n   - 每条 printk 记录独立输出，被抢占时由新持有者重试整条记录。\n\n2. **Panic 处理**：\n   - 在 `panic()` 流程中，通过强制接管机制确保最后的日志能输出。\n   - 使用独立的 panic 记录缓冲区，避免因不安全状态导致数据损坏。\n\n3. **实时系统**：\n   - 避免传统 `console_lock` 导致的优先级反转问题。\n   - 保证高优先级任务/中断的日志能及时输出。\n\n4. **控制台驱动实现**：\n   - 控制台驱动需在关键操作（如设备寄存器访问）前后标记 `unsafe` 状态。\n   - 驱动需在每次输出字符后检查移交请求（`req_prio`），及时释放控制台。",
      "similarity": 0.4961662292480469,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 335,
          "end_line": 473,
          "content": [
            "static int nbcon_context_try_acquire_requested(struct nbcon_context *ctxt,",
            "\t\t\t\t\t       struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\t/* Note that the caller must still remove the request! */",
            "\tif (other_cpu_in_panic())",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Note that the waiter will also change if there was an unsafe",
            "\t * hostile takeover.",
            "\t */",
            "\tif (!nbcon_waiter_matches(cur, ctxt->prio))",
            "\t\treturn -EPERM;",
            "",
            "\t/* If still locked, caller should continue waiting. */",
            "\tif (cur->prio != NBCON_PRIO_NONE)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * The previous owner should have never released ownership",
            "\t * in an unsafe region.",
            "\t */",
            "\tWARN_ON_ONCE(cur->unsafe);",
            "",
            "\tnew.atom = cur->atom;",
            "\tnew.prio\t= ctxt->prio;",
            "\tnew.req_prio\t= NBCON_PRIO_NONE;",
            "\tnew.unsafe\t= cur->unsafe_takeover;",
            "\tnew.cpu\t\t= cpu;",
            "",
            "\tif (!nbcon_state_try_cmpxchg(con, cur, &new)) {",
            "\t\t/*",
            "\t\t * The acquire could fail only when it has been taken",
            "\t\t * over by a higher priority context.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(nbcon_waiter_matches(cur, ctxt->prio));",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* Handover success. This context now owns the console. */",
            "\treturn 0;",
            "}",
            "static int nbcon_context_try_acquire_handover(struct nbcon_context *ctxt,",
            "\t\t\t\t\t      struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "\tint timeout;",
            "\tint request_err = -EBUSY;",
            "",
            "\t/*",
            "\t * Check that the handover is called when the direct acquire failed",
            "\t * with -EBUSY.",
            "\t */",
            "\tWARN_ON_ONCE(ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio);",
            "\tWARN_ON_ONCE(!cur->unsafe);",
            "",
            "\t/* Handover is not possible on the same CPU. */",
            "\tif (cur->cpu == cpu)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * Console stays unsafe after an unsafe takeover until re-initialized.",
            "\t * Waiting is not going to help in this case.",
            "\t */",
            "\tif (cur->unsafe_takeover)",
            "\t\treturn -EBUSY;",
            "",
            "\t/* Is the caller willing to wait? */",
            "\tif (ctxt->spinwait_max_us == 0)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * Setup a request for the handover. The caller should try to acquire",
            "\t * the console directly when the current state has been modified.",
            "\t */",
            "\tnew.atom = cur->atom;",
            "\tnew.req_prio = ctxt->prio;",
            "\tif (!nbcon_state_try_cmpxchg(con, cur, &new))",
            "\t\treturn -EAGAIN;",
            "",
            "\tcur->atom = new.atom;",
            "",
            "\t/* Wait until there is no owner and then acquire the console. */",
            "\tfor (timeout = ctxt->spinwait_max_us; timeout >= 0; timeout--) {",
            "\t\t/* On successful acquire, this request is cleared. */",
            "\t\trequest_err = nbcon_context_try_acquire_requested(ctxt, cur);",
            "\t\tif (!request_err)",
            "\t\t\treturn 0;",
            "",
            "\t\t/*",
            "\t\t * If the acquire should be aborted, it must be ensured",
            "\t\t * that the request is removed before returning to caller.",
            "\t\t */",
            "\t\tif (request_err == -EPERM)",
            "\t\t\tbreak;",
            "",
            "\t\tudelay(1);",
            "",
            "\t\t/* Re-read the state because some time has passed. */",
            "\t\tnbcon_state_read(con, cur);",
            "\t}",
            "",
            "\t/* Timed out or aborted. Carefully remove handover request. */",
            "\tdo {",
            "\t\t/*",
            "\t\t * No need to remove request if there is a new waiter. This",
            "\t\t * can only happen if a higher priority context has taken over",
            "\t\t * the console or the handover request.",
            "\t\t */",
            "\t\tif (!nbcon_waiter_matches(cur, ctxt->prio))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t/* Unset request for handover. */",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.req_prio = NBCON_PRIO_NONE;",
            "\t\tif (nbcon_state_try_cmpxchg(con, cur, &new)) {",
            "\t\t\t/*",
            "\t\t\t * Request successfully unset. Report failure of",
            "\t\t\t * acquiring via handover.",
            "\t\t\t */",
            "\t\t\tcur->atom = new.atom;",
            "\t\t\treturn request_err;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Unable to remove request. Try to acquire in case",
            "\t\t * the owner has released the lock.",
            "\t\t */",
            "\t} while (nbcon_context_try_acquire_requested(ctxt, cur));",
            "",
            "\t/* Lucky timing. The acquire succeeded while removing the request. */",
            "\treturn 0;",
            "}"
          ],
          "function_name": "nbcon_context_try_acquire_requested, nbcon_context_try_acquire_handover",
          "description": "实现友好移交机制，通过设置请求优先级并轮询等待所有者释放，包含超时控制和状态同步，确保高优先级任务可中断低优先级控制台输出。",
          "similarity": 0.5371215343475342
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 524,
          "end_line": 629,
          "content": [
            "static int nbcon_context_try_acquire_hostile(struct nbcon_context *ctxt,",
            "\t\t\t\t\t     struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\tif (!ctxt->allow_unsafe_takeover)",
            "\t\treturn -EPERM;",
            "",
            "\t/* Ensure caller is allowed to perform unsafe hostile takeovers. */",
            "\tif (WARN_ON_ONCE(ctxt->prio != NBCON_PRIO_PANIC))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Check that try_acquire_direct() and try_acquire_handover() returned",
            "\t * -EBUSY in the right situation.",
            "\t */",
            "\tWARN_ON_ONCE(ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio);",
            "\tWARN_ON_ONCE(cur->unsafe != true);",
            "",
            "\tdo {",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.cpu\t\t\t= cpu;",
            "\t\tnew.prio\t\t= ctxt->prio;",
            "\t\tnew.unsafe\t\t|= cur->unsafe_takeover;",
            "\t\tnew.unsafe_takeover\t|= cur->unsafe;",
            "",
            "\t} while (!nbcon_state_try_cmpxchg(con, cur, &new));",
            "",
            "\treturn 0;",
            "}",
            "static bool nbcon_context_try_acquire(struct nbcon_context *ctxt)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "\tint err;",
            "",
            "\tnbcon_state_read(con, &cur);",
            "try_again:",
            "\terr = nbcon_context_try_acquire_direct(ctxt, &cur);",
            "\tif (err != -EBUSY)",
            "\t\tgoto out;",
            "",
            "\terr = nbcon_context_try_acquire_handover(ctxt, &cur);",
            "\tif (err == -EAGAIN)",
            "\t\tgoto try_again;",
            "\tif (err != -EBUSY)",
            "\t\tgoto out;",
            "",
            "\terr = nbcon_context_try_acquire_hostile(ctxt, &cur);",
            "out:",
            "\tif (err)",
            "\t\treturn false;",
            "",
            "\t/* Acquire succeeded. */",
            "",
            "\t/* Assign the appropriate buffer for this context. */",
            "\tif (atomic_read(&panic_cpu) == cpu)",
            "\t\tctxt->pbufs = &panic_nbcon_pbufs;",
            "\telse",
            "\t\tctxt->pbufs = con->pbufs;",
            "",
            "\t/* Set the record sequence for this context to print. */",
            "\tctxt->seq = nbcon_seq_read(ctxt->console);",
            "",
            "\treturn true;",
            "}",
            "static bool nbcon_owner_matches(struct nbcon_state *cur, int expected_cpu,",
            "\t\t\t\tint expected_prio)",
            "{",
            "\t/*",
            "\t * A similar function, nbcon_waiter_matches(), only deals with",
            "\t * EMERGENCY and PANIC priorities. However, this function must also",
            "\t * deal with the NORMAL priority, which requires additional checks",
            "\t * and constraints.",
            "\t *",
            "\t * For the case where preemption and interrupts are disabled, it is",
            "\t * enough to also verify that the owning CPU has not changed.",
            "\t *",
            "\t * For the case where preemption or interrupts are enabled, an",
            "\t * external synchronization method *must* be used. In particular,",
            "\t * the driver-specific locking mechanism used in device_lock()",
            "\t * (including disabling migration) should be used. It prevents",
            "\t * scenarios such as:",
            "\t *",
            "\t * 1. [Task A] owns a context with NBCON_PRIO_NORMAL on [CPU X] and",
            "\t *    is scheduled out.",
            "\t * 2. Another context takes over the lock with NBCON_PRIO_EMERGENCY",
            "\t *    and releases it.",
            "\t * 3. [Task B] acquires a context with NBCON_PRIO_NORMAL on [CPU X]",
            "\t *    and is scheduled out.",
            "\t * 4. [Task A] gets running on [CPU X] and sees that the console is",
            "\t *    still owned by a task on [CPU X] with NBON_PRIO_NORMAL. Thus",
            "\t *    [Task A] thinks it is the owner when it is not.",
            "\t */",
            "",
            "\tif (cur->prio != expected_prio)",
            "\t\treturn false;",
            "",
            "\tif (cur->cpu != expected_cpu)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "nbcon_context_try_acquire_hostile, nbcon_context_try_acquire, nbcon_owner_matches",
          "description": "处理强制接管（hostile takeover）逻辑，仅限panic优先级使用，标记控制台为永久不安全状态，提供统一的获取入口函数并关联缓冲区选择。",
          "similarity": 0.5232555866241455
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 128,
          "end_line": 242,
          "content": [
            "static inline void nbcon_state_set(struct console *con, struct nbcon_state *new)",
            "{",
            "\tatomic_set(&ACCESS_PRIVATE(con, nbcon_state), new->atom);",
            "}",
            "static inline void nbcon_state_read(struct console *con, struct nbcon_state *state)",
            "{",
            "\tstate->atom = atomic_read(&ACCESS_PRIVATE(con, nbcon_state));",
            "}",
            "static inline bool nbcon_state_try_cmpxchg(struct console *con, struct nbcon_state *cur,",
            "\t\t\t\t\t   struct nbcon_state *new)",
            "{",
            "\treturn atomic_try_cmpxchg(&ACCESS_PRIVATE(con, nbcon_state), &cur->atom, new->atom);",
            "}",
            "u64 nbcon_seq_read(struct console *con)",
            "{",
            "\tunsigned long nbcon_seq = atomic_long_read(&ACCESS_PRIVATE(con, nbcon_seq));",
            "",
            "\treturn __ulseq_to_u64seq(prb, nbcon_seq);",
            "}",
            "void nbcon_seq_force(struct console *con, u64 seq)",
            "{",
            "\t/*",
            "\t * If the specified record no longer exists, the oldest available record",
            "\t * is chosen. This is especially important on 32bit systems because only",
            "\t * the lower 32 bits of the sequence number are stored. The upper 32 bits",
            "\t * are derived from the sequence numbers available in the ringbuffer.",
            "\t */",
            "\tu64 valid_seq = max_t(u64, seq, prb_first_valid_seq(prb));",
            "",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_seq), __u64seq_to_ulseq(valid_seq));",
            "}",
            "static void nbcon_seq_try_update(struct nbcon_context *ctxt, u64 new_seq)",
            "{",
            "\tunsigned long nbcon_seq = __u64seq_to_ulseq(ctxt->seq);",
            "\tstruct console *con = ctxt->console;",
            "",
            "\tif (atomic_long_try_cmpxchg(&ACCESS_PRIVATE(con, nbcon_seq), &nbcon_seq,",
            "\t\t\t\t    __u64seq_to_ulseq(new_seq))) {",
            "\t\tctxt->seq = new_seq;",
            "\t} else {",
            "\t\tctxt->seq = nbcon_seq_read(con);",
            "\t}",
            "}",
            "static int nbcon_context_try_acquire_direct(struct nbcon_context *ctxt,",
            "\t\t\t\t\t    struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\tdo {",
            "\t\t/*",
            "\t\t * Panic does not imply that the console is owned. However, it",
            "\t\t * is critical that non-panic CPUs during panic are unable to",
            "\t\t * acquire ownership in order to satisfy the assumptions of",
            "\t\t * nbcon_waiter_matches(). In particular, the assumption that",
            "\t\t * lower priorities are ignored during panic.",
            "\t\t */",
            "\t\tif (other_cpu_in_panic())",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio)",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (cur->unsafe)",
            "\t\t\treturn -EBUSY;",
            "",
            "\t\t/*",
            "\t\t * The console should never be safe for a direct acquire",
            "\t\t * if an unsafe hostile takeover has ever happened.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(cur->unsafe_takeover);",
            "",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.prio\t= ctxt->prio;",
            "\t\tnew.req_prio\t= NBCON_PRIO_NONE;",
            "\t\tnew.unsafe\t= cur->unsafe_takeover;",
            "\t\tnew.cpu\t\t= cpu;",
            "",
            "\t} while (!nbcon_state_try_cmpxchg(con, cur, &new));",
            "",
            "\treturn 0;",
            "}",
            "static bool nbcon_waiter_matches(struct nbcon_state *cur, int expected_prio)",
            "{",
            "\t/*",
            "\t * The request context is well defined by the @req_prio because:",
            "\t *",
            "\t * - Only a context with a priority higher than the owner can become",
            "\t *   a waiter.",
            "\t * - Only a context with a priority higher than the waiter can",
            "\t *   directly take over the request.",
            "\t * - There are only three priorities.",
            "\t * - Only one CPU is allowed to request PANIC priority.",
            "\t * - Lower priorities are ignored during panic() until reboot.",
            "\t *",
            "\t * As a result, the following scenario is *not* possible:",
            "\t *",
            "\t * 1. This context is currently a waiter.",
            "\t * 2. Another context with a higher priority than this context",
            "\t *    directly takes ownership.",
            "\t * 3. The higher priority context releases the ownership.",
            "\t * 4. Another lower priority context takes the ownership.",
            "\t * 5. Another context with the same priority as this context",
            "\t *    creates a request and starts waiting.",
            "\t *",
            "\t * Event #1 implies this context is EMERGENCY.",
            "\t * Event #2 implies the new context is PANIC.",
            "\t * Event #3 occurs when panic() has flushed the console.",
            "\t * Events #4 and #5 are not possible due to the other_cpu_in_panic()",
            "\t * check in nbcon_context_try_acquire_direct().",
            "\t */",
            "",
            "\treturn (cur->req_prio == expected_prio);",
            "}"
          ],
          "function_name": "nbcon_state_set, nbcon_state_read, nbcon_state_try_cmpxchg, nbcon_seq_read, nbcon_seq_force, nbcon_seq_try_update, nbcon_context_try_acquire_direct, nbcon_waiter_matches",
          "description": "实现直接获取控制台的逻辑，包含优先级检查、安全状态验证和状态原子更新，通过cmpxchg保证并发安全性，处理跨CPU和panic场景下的所有权转移规则。",
          "similarity": 0.5102545022964478
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 1619,
          "end_line": 1720,
          "content": [
            "void nbcon_atomic_flush_unsafe(void)",
            "{",
            "\t__nbcon_atomic_flush_pending(prb_next_reserve_seq(prb), true);",
            "}",
            "void nbcon_cpu_emergency_enter(void)",
            "{",
            "\tunsigned int *cpu_emergency_nesting;",
            "",
            "\tpreempt_disable();",
            "",
            "\tcpu_emergency_nesting = nbcon_get_cpu_emergency_nesting();",
            "\t(*cpu_emergency_nesting)++;",
            "}",
            "void nbcon_cpu_emergency_exit(void)",
            "{",
            "\tunsigned int *cpu_emergency_nesting;",
            "",
            "\tcpu_emergency_nesting = nbcon_get_cpu_emergency_nesting();",
            "",
            "\tif (!WARN_ON_ONCE(*cpu_emergency_nesting == 0))",
            "\t\t(*cpu_emergency_nesting)--;",
            "",
            "\tpreempt_enable();",
            "}",
            "bool nbcon_alloc(struct console *con)",
            "{",
            "\tstruct nbcon_state state = { };",
            "",
            "\t/* The write_thread() callback is mandatory. */",
            "\tif (WARN_ON(!con->write_thread))",
            "\t\treturn false;",
            "",
            "\trcuwait_init(&con->rcuwait);",
            "\tinit_irq_work(&con->irq_work, nbcon_irq_work);",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_prev_seq), -1UL);",
            "\tnbcon_state_set(con, &state);",
            "",
            "\t/*",
            "\t * Initialize @nbcon_seq to the highest possible sequence number so",
            "\t * that practically speaking it will have nothing to print until a",
            "\t * desired initial sequence number has been set via nbcon_seq_force().",
            "\t */",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_seq), ULSEQ_MAX(prb));",
            "",
            "\tif (con->flags & CON_BOOT) {",
            "\t\t/*",
            "\t\t * Boot console printing is synchronized with legacy console",
            "\t\t * printing, so boot consoles can share the same global printk",
            "\t\t * buffers.",
            "\t\t */",
            "\t\tcon->pbufs = &printk_shared_pbufs;",
            "\t} else {",
            "\t\tcon->pbufs = kmalloc(sizeof(*con->pbufs), GFP_KERNEL);",
            "\t\tif (!con->pbufs) {",
            "\t\t\tcon_printk(KERN_ERR, con, \"failed to allocate printing buffer\\n\");",
            "\t\t\treturn false;",
            "\t\t}",
            "",
            "\t\tif (printk_kthreads_running) {",
            "\t\t\tif (!nbcon_kthread_create(con)) {",
            "\t\t\t\tkfree(con->pbufs);",
            "\t\t\t\tcon->pbufs = NULL;",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "void nbcon_free(struct console *con)",
            "{",
            "\tstruct nbcon_state state = { };",
            "",
            "\tif (printk_kthreads_running)",
            "\t\tnbcon_kthread_stop(con);",
            "",
            "\tnbcon_state_set(con, &state);",
            "",
            "\t/* Boot consoles share global printk buffers. */",
            "\tif (!(con->flags & CON_BOOT))",
            "\t\tkfree(con->pbufs);",
            "",
            "\tcon->pbufs = NULL;",
            "}",
            "bool nbcon_device_try_acquire(struct console *con)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(con, nbcon_device_ctxt);",
            "",
            "\tcant_migrate();",
            "",
            "\tmemset(ctxt, 0, sizeof(*ctxt));",
            "\tctxt->console\t= con;",
            "\tctxt->prio\t= NBCON_PRIO_NORMAL;",
            "",
            "\tif (!nbcon_context_try_acquire(ctxt))",
            "\t\treturn false;",
            "",
            "\tif (!nbcon_context_enter_unsafe(ctxt))",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "nbcon_atomic_flush_unsafe, nbcon_cpu_emergency_enter, nbcon_cpu_emergency_exit, nbcon_alloc, nbcon_free, nbcon_device_try_acquire",
          "description": "包含CPU紧急模式的嵌套计数器增减接口，控制台资源分配释放逻辑(nbcon_alloc/free)，以及设备抢占尝试函数nbcon_device_try_acquire，用于协调控制台设备的并发访问。",
          "similarity": 0.4871302843093872
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 1,
          "end_line": 127,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "// Copyright (C) 2022 Linutronix GmbH, John Ogness",
            "// Copyright (C) 2022 Intel, Thomas Gleixner",
            "",
            "#include <linux/atomic.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/delay.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kthread.h>",
            "#include <linux/minmax.h>",
            "#include <linux/percpu.h>",
            "#include <linux/preempt.h>",
            "#include <linux/slab.h>",
            "#include <linux/smp.h>",
            "#include <linux/stddef.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include \"internal.h\"",
            "#include \"printk_ringbuffer.h\"",
            "/*",
            " * Printk console printing implementation for consoles which does not depend",
            " * on the legacy style console_lock mechanism.",
            " *",
            " * The state of the console is maintained in the \"nbcon_state\" atomic",
            " * variable.",
            " *",
            " * The console is locked when:",
            " *",
            " *   - The 'prio' field contains the priority of the context that owns the",
            " *     console. Only higher priority contexts are allowed to take over the",
            " *     lock. A value of 0 (NBCON_PRIO_NONE) means the console is not locked.",
            " *",
            " *   - The 'cpu' field denotes on which CPU the console is locked. It is used",
            " *     to prevent busy waiting on the same CPU. Also it informs the lock owner",
            " *     that it has lost the lock in a more complex scenario when the lock was",
            " *     taken over by a higher priority context, released, and taken on another",
            " *     CPU with the same priority as the interrupted owner.",
            " *",
            " * The acquire mechanism uses a few more fields:",
            " *",
            " *   - The 'req_prio' field is used by the handover approach to make the",
            " *     current owner aware that there is a context with a higher priority",
            " *     waiting for the friendly handover.",
            " *",
            " *   - The 'unsafe' field allows to take over the console in a safe way in the",
            " *     middle of emitting a message. The field is set only when accessing some",
            " *     shared resources or when the console device is manipulated. It can be",
            " *     cleared, for example, after emitting one character when the console",
            " *     device is in a consistent state.",
            " *",
            " *   - The 'unsafe_takeover' field is set when a hostile takeover took the",
            " *     console in an unsafe state. The console will stay in the unsafe state",
            " *     until re-initialized.",
            " *",
            " * The acquire mechanism uses three approaches:",
            " *",
            " *   1) Direct acquire when the console is not owned or is owned by a lower",
            " *      priority context and is in a safe state.",
            " *",
            " *   2) Friendly handover mechanism uses a request/grant handshake. It is used",
            " *      when the current owner has lower priority and the console is in an",
            " *      unsafe state.",
            " *",
            " *      The requesting context:",
            " *",
            " *        a) Sets its priority into the 'req_prio' field.",
            " *",
            " *        b) Waits (with a timeout) for the owning context to unlock the",
            " *           console.",
            " *",
            " *        c) Takes the lock and clears the 'req_prio' field.",
            " *",
            " *      The owning context:",
            " *",
            " *        a) Observes the 'req_prio' field set on exit from the unsafe",
            " *           console state.",
            " *",
            " *        b) Gives up console ownership by clearing the 'prio' field.",
            " *",
            " *   3) Unsafe hostile takeover allows to take over the lock even when the",
            " *      console is an unsafe state. It is used only in panic() by the final",
            " *      attempt to flush consoles in a try and hope mode.",
            " *",
            " *      Note that separate record buffers are used in panic(). As a result,",
            " *      the messages can be read and formatted without any risk even after",
            " *      using the hostile takeover in unsafe state.",
            " *",
            " * The release function simply clears the 'prio' field.",
            " *",
            " * All operations on @console::nbcon_state are atomic cmpxchg based to",
            " * handle concurrency.",
            " *",
            " * The acquire/release functions implement only minimal policies:",
            " *",
            " *   - Preference for higher priority contexts.",
            " *   - Protection of the panic CPU.",
            " *",
            " * All other policy decisions must be made at the call sites:",
            " *",
            " *   - What is marked as an unsafe section.",
            " *   - Whether to spin-wait if there is already an owner and the console is",
            " *     in an unsafe state.",
            " *   - Whether to attempt an unsafe hostile takeover.",
            " *",
            " * The design allows to implement the well known:",
            " *",
            " *     acquire()",
            " *     output_one_printk_record()",
            " *     release()",
            " *",
            " * The output of one printk record might be interrupted with a higher priority",
            " * context. The new owner is supposed to reprint the entire interrupted record",
            " * from scratch.",
            " */",
            "",
            "/**",
            " * nbcon_state_set - Helper function to set the console state",
            " * @con:\tConsole to update",
            " * @new:\tThe new state to write",
            " *",
            " * Only to be used when the console is not yet or no longer visible in the",
            " * system. Otherwise use nbcon_state_try_cmpxchg().",
            " */"
          ],
          "function_name": null,
          "description": "定义了非阻塞控制台（nbcon）的状态管理和序列号操作函数，提供设置、读取和原子比较交换操作，用于维护控制台锁状态及记录序列号，支持多优先级抢占式控制台访问策略。",
          "similarity": 0.4635258913040161
        }
      ]
    },
    {
      "source_file": "kernel/sched/features.h",
      "md_summary": "> 自动生成时间: 2025-10-25 16:09:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\features.h`\n\n---\n\n# `sched/features.h` 技术文档\n\n## 1. 文件概述\n\n`sched/features.h` 是 Linux 内核调度器（CFS 和 EEVDF 调度类）中用于定义和管理**调度特性（Scheduling Features）** 的头文件。该文件通过宏 `SCHED_FEAT(name, enabled)` 声明一系列可配置的调度行为开关，用于控制调度器在运行时的各种策略，如任务放置、抢占、迁移、缓存局部性优化、延迟处理、利用率估计等。这些特性通常在编译时默认启用或禁用，但部分可通过 `/sys/kernel/debug/sched_features` 在运行时动态调整。\n\n## 2. 核心功能\n\n本文件不包含函数或数据结构定义，而是通过一系列 `SCHED_FEAT(feature_name, default_value)` 宏声明调度器的**可配置特性标志**。每个特性对应一个布尔开关，控制调度器某一方面的行为逻辑。主要特性包括：\n\n- **任务放置策略**：`PLACE_LAG`、`PLACE_DEADLINE_INITIAL`、`PLACE_REL_DEADLINE`\n- **抢占控制**：`RUN_TO_PARITY`、`PREEMPT_SHORT`、`WAKEUP_PREEMPTION`\n- **缓存局部性优化**：`NEXT_BUDDY`、`CACHE_HOT_BUDDY`\n- **延迟出队机制**：`DELAY_DEQUEUE`、`DELAY_ZERO`\n- **高精度定时器支持**：`HRTICK`、`HRTICK_DL`\n- **CPU 容量与负载管理**：`NONTASK_CAPACITY`、`ATTACH_AGE_LOAD`\n- **唤醒优化**：`TTWU_QUEUE`、`SIS_UTIL`\n- **实时任务调度优化**：`RT_PUSH_IPI`、`RT_RUNTIME_SHARE`\n- **利用率估计**：`UTIL_EST`、`UTIL_EST_FASTUP`\n- **调试与告警**：`WARN_DOUBLE_CLOCK`、`LATENCY_WARN`\n\n## 3. 关键实现\n\n- **`SCHED_FEAT` 宏机制**：  \n  该宏在 `kernel/sched/features.h` 中定义（通常通过 `#define SCHED_FEAT(x, enabled) SCHED_FEAT_##x`），最终在 `kernel/sched/core.c` 中展开为位图（`sysctl_sched_features`）中的位标志。调度器代码通过 `sched_feat(FEAT_NAME)` 宏查询某特性是否启用。\n\n- **EEVDF 相关特性**：\n  - `PLACE_LAG`：启用后，任务在睡眠/唤醒周期中保留其虚拟运行时间（avg_vruntime）的“滞后”（lag），确保公平性。这是 EEVDF（Earliest Eligible Virtual Deadline First）调度器的核心策略之一。\n  - `PLACE_DEADLINE_INITIAL`：新任务初始虚拟截止时间设为当前时间加半个时间片，避免新任务因虚拟截止时间过早而过度抢占。\n  - `PLACE_REL_DEADLINE`：任务迁移时保持其相对于当前虚拟时间的截止时间偏移，维持调度公平性。\n\n- **抢占抑制与唤醒抢占**：\n  - `RUN_TO_PARITY`：禁止唤醒抢占，直到当前任务达到“零滞后点”（即其虚拟运行时间追平队列平均值）或耗尽时间片。\n  - `PREEMPT_SHORT`：允许具有更短时间片的唤醒任务抢占当前任务，即使 `RESPECT_SLICE` 被设置。\n  - `WAKEUP_PREEMPTION`：启用唤醒时的抢占检查，是 CFS/EEVDF 实现低延迟响应的关键。\n\n- **缓存局部性优化**：\n  - `NEXT_BUDDY`（默认关闭）：优先调度最近被唤醒但未成功抢占的任务，因其可能复用刚访问的数据。\n  - `CACHE_HOT_BUDDY`：将 buddy 任务视为缓存热任务，降低其被迁移的概率。\n\n- **延迟出队（`DELAY_DEQUEUE`）**：  \n  非就绪任务（如睡眠中）不会立即从运行队列移除，使其保留在调度竞争中以“消耗”负滞后（negative lag），当选中时自然具有正滞后，提升调度平滑性。`DELAY_ZERO` 则在出队或唤醒时将滞后裁剪为 0。\n\n- **TTWU_QUEUE 优化**：  \n  在非 `PREEMPT_RT` 配置下，默认启用远程唤醒排队机制，通过调度 IPI 异步处理跨 CPU 唤醒，减少运行队列锁竞争。\n\n- **利用率估计（Utilization Estimation）**：  \n  `UTIL_EST` 启用基于 PELT（Per-Entity Load Tracking）信号的 CPU 利用率估计，`UTIL_EST_FASTUP` 允许利用率快速上升以响应突发负载，用于 EAS（Energy Aware Scheduling）等场景。\n\n- **RT 调度优化**：  \n  `RT_PUSH_IPI` 在支持 `HAVE_RT_PUSH_IPI` 的平台上启用，通过 IPI 推送高优先级 RT 任务，避免多 CPU 同时争抢单个运行队列锁导致的“惊群”问题。\n\n## 4. 依赖关系\n\n- **依赖头文件**：通常由 `kernel/sched/sched.h` 或 `kernel/sched/core.c` 包含。\n- **依赖配置选项**：\n  - `CONFIG_PREEMPT_RT`：影响 `TTWU_QUEUE` 默认值。\n  - `HAVE_RT_PUSH_IPI`：决定 `RT_PUSH_IPI` 特性是否定义。\n- **依赖调度核心模块**：特性标志在 `kernel/sched/core.c`、`kernel/sched/fair.c`（CFS/EEVDF）、`kernel/sched/rt.c`（实时调度）中被实际使用。\n- **依赖调试接口**：部分特性（如 `WARN_DOUBLE_CLOCK`、`LATENCY_WARN`）依赖内核调试基础设施。\n\n## 5. 使用场景\n\n- **调度策略调优**：系统管理员或开发者可通过 `/sys/kernel/debug/sched_features` 动态开启/关闭特性，以优化特定工作负载（如低延迟、高吞吐、能效）下的调度行为。\n- **EEVDF 调度器支持**：`PLACE_LAG`、`PLACE_DEADLINE_INITIAL` 等特性是 Linux 6.6+ 引入的 EEVDF 调度器实现公平性和响应性的关键。\n- **实时系统优化**：`RT_PUSH_IPI`、`RT_RUNTIME_SHARE` 等用于改善实时任务的调度延迟和 CPU 资源分配。\n- **能效调度（EAS）**：`UTIL_EST` 和 `UTIL_EST_FASTUP` 为 EAS 提供准确的 CPU 利用率预测，用于任务放置决策。\n- **性能调试**：`LATENCY_WARN`、`WARN_DOUBLE_CLOCK` 等特性用于检测调度器内部异常或性能瓶颈。\n- **多核扩展性优化**：`TTWU_QUEUE`、`SIS_UTIL` 减少跨 CPU 唤醒和 LLC 域扫描开销，提升大规模系统可扩展性。",
      "similarity": 0.4831022024154663,
      "chunks": []
    }
  ]
}