{
  "query": "schedule函数",
  "timestamp": "2025-12-26 00:43:16",
  "retrieved_files": [
    {
      "source_file": "kernel/time/timeconv.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:53:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timeconv.c`\n\n---\n\n# time/timeconv.c 技术文档\n\n## 1. 文件概述\n\n`time/timeconv.c` 是 Linux 内核中用于将日历时间（自 Unix 纪元 1970-01-01 00:00:00 UTC 起的秒数）转换为本地“分解时间”（broken-down time）表示的核心实现文件。该文件提供了一个高效、精确且支持 64 位时间戳（`time64_t`）的转换函数，适用于跨越 2038 年的时间处理需求。其算法基于 Cassio Neri 与 Schneider 提出的欧几里得仿射函数方法，具有良好的数学严谨性和性能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`time64_to_tm(time64_t totalsecs, int offset, struct tm *result)`**  \n  将 64 位日历时间（UTC 秒数）结合时区偏移量转换为本地分解时间结构体 `struct tm`。\n\n### 数据结构\n\n- **`struct tm`**（定义于 `<linux/time.h>`）  \n  表示分解时间的标准结构体，包含年、月、日、时、分、秒、星期、年内日等字段。\n\n### 宏定义\n\n- `SECS_PER_HOUR`：每小时秒数（3600）\n- `SECS_PER_DAY`：每天秒数（86400）\n\n## 3. 关键实现\n\n### 时间归一化\n函数首先将输入的总秒数 `totalsecs` 与偏移量 `offset` 相加，并通过循环调整，确保秒数部分 `rem` 落在 `[0, SECS_PER_DAY)` 范围内，同时相应调整天数 `days`。这一步处理了跨日边界的情况（如负偏移导致前一天）。\n\n### 时分秒计算\n基于归一化后的 `rem`，直接通过整除和取模运算得出 `tm_hour`、`tm_min` 和 `tm_sec`。\n\n### 星期计算\n利用已知事实“1970 年 1 月 1 日是星期四”，通过 `(4 + days) % 7` 计算星期几（`tm_wday`），并确保结果为非负。\n\n### 日期计算（核心算法）\n采用 **“计算日历”**（computational calendar）方法，该日历将每年起点设为 **3 月 1 日**（即 3 月为第 0 月，次年 2 月为第 13 月），从而消除闰年对年内日计算的影响：\n\n1. **天数偏移**：将 `days` 加上常量 `2305843009213814918ULL`，使日历对齐到便于计算的周期起点。\n2. **世纪与年内日分解**：\n   - 使用 `div64_u64_rem` 将总天数按 400 年周期（146097 天）分解为世纪数 `century` 和世纪内天数 `day_of_century`。\n   - 进一步将 `day_of_century` 分解为年份偏移 `year_of_century` 和年内日 `day_of_year`。\n3. **月份与日计算**：\n   - 利用线性近似 `2141 * day_of_year + 132377` 的高 16 位作为月份索引，低 16 位除以 2141 得到日。\n4. **日历转换**：\n   - 判断是否为 1 月或 2 月（即 `day_of_year >= 306`），据此调整年、月、日及年内日 `tm_yday`。\n   - 通过减去大常量 `6313183731940000ULL` 将计算年份映射回实际 Gregorian 年份。\n5. **结果适配**：\n   - `tm_year` 设为实际年份减 1900（符合 POSIX 规范）。\n   - `tm_mon` 为 0 起始（0=1月），`tm_mday` 为 1 起始。\n\n该算法避免了传统循环或查表方式，完全基于整数算术，高效且无分支预测惩罚。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/time.h>`：提供 `time64_t`、`struct tm` 等时间相关定义\n  - `<linux/module.h>`：提供 `EXPORT_SYMBOL` 宏\n  - `<linux/kernel.h>`：提供 `div_s64_rem`、`div64_u64_rem`、`upper_32_bits`、`lower_32_bits` 等内核数学辅助函数\n- **导出符号**：\n  - `time64_to_tm` 通过 `EXPORT_SYMBOL` 导出，可供其他内核模块使用\n\n## 5. 使用场景\n\n- **系统调用实现**：如 `localtime()`、`gmtime()` 等用户空间时间转换函数的内核支持\n- **文件系统时间戳处理**：在需要将 inode 时间戳转换为可读日期时使用\n- **日志与调试**：内核日志中打印人类可读的时间信息\n- **网络协议栈**：处理 HTTP、NTP 等协议中的日期字段\n- **定时器与调度**：在需要将绝对时间转换为日历时间进行调度决策时\n- **Y2038 安全**：作为 64 位时间基础设施的一部分，确保内核在 2038 年后仍能正确处理时间",
      "similarity": 0.5461184978485107,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/timeconv.c",
          "start_line": 47,
          "end_line": 140,
          "content": [
            "void time64_to_tm(time64_t totalsecs, int offset, struct tm *result)",
            "{",
            "\tu32 u32tmp, day_of_century, year_of_century, day_of_year, month, day;",
            "\tu64 u64tmp, udays, century, year;",
            "\tbool is_Jan_or_Feb, is_leap_year;",
            "\tlong days, rem;",
            "\tint remainder;",
            "",
            "\tdays = div_s64_rem(totalsecs, SECS_PER_DAY, &remainder);",
            "\trem = remainder;",
            "\trem += offset;",
            "\twhile (rem < 0) {",
            "\t\trem += SECS_PER_DAY;",
            "\t\t--days;",
            "\t}",
            "\twhile (rem >= SECS_PER_DAY) {",
            "\t\trem -= SECS_PER_DAY;",
            "\t\t++days;",
            "\t}",
            "",
            "\tresult->tm_hour = rem / SECS_PER_HOUR;",
            "\trem %= SECS_PER_HOUR;",
            "\tresult->tm_min = rem / 60;",
            "\tresult->tm_sec = rem % 60;",
            "",
            "\t/* January 1, 1970 was a Thursday. */",
            "\tresult->tm_wday = (4 + days) % 7;",
            "\tif (result->tm_wday < 0)",
            "\t\tresult->tm_wday += 7;",
            "",
            "\t/*",
            "\t * The following algorithm is, basically, Proposition 6.3 of Neri",
            "\t * and Schneider [1]. In a few words: it works on the computational",
            "\t * (fictitious) calendar where the year starts in March, month = 2",
            "\t * (*), and finishes in February, month = 13. This calendar is",
            "\t * mathematically convenient because the day of the year does not",
            "\t * depend on whether the year is leap or not. For instance:",
            "\t *",
            "\t * March 1st\t\t0-th day of the year;",
            "\t * ...",
            "\t * April 1st\t\t31-st day of the year;",
            "\t * ...",
            "\t * January 1st\t\t306-th day of the year; (Important!)",
            "\t * ...",
            "\t * February 28th\t364-th day of the year;",
            "\t * February 29th\t365-th day of the year (if it exists).",
            "\t *",
            "\t * After having worked out the date in the computational calendar",
            "\t * (using just arithmetics) it's easy to convert it to the",
            "\t * corresponding date in the Gregorian calendar.",
            "\t *",
            "\t * [1] \"Euclidean Affine Functions and Applications to Calendar",
            "\t * Algorithms\". https://arxiv.org/abs/2102.06959",
            "\t *",
            "\t * (*) The numbering of months follows tm more closely and thus,",
            "\t * is slightly different from [1].",
            "\t */",
            "",
            "\tudays\t= ((u64) days) + 2305843009213814918ULL;",
            "",
            "\tu64tmp\t\t= 4 * udays + 3;",
            "\tcentury\t\t= div64_u64_rem(u64tmp, 146097, &u64tmp);",
            "\tday_of_century\t= (u32) (u64tmp / 4);",
            "",
            "\tu32tmp\t\t= 4 * day_of_century + 3;",
            "\tu64tmp\t\t= 2939745ULL * u32tmp;",
            "\tyear_of_century\t= upper_32_bits(u64tmp);",
            "\tday_of_year\t= lower_32_bits(u64tmp) / 2939745 / 4;",
            "",
            "\tyear\t\t= 100 * century + year_of_century;",
            "\tis_leap_year\t= year_of_century ? !(year_of_century % 4) : !(century % 4);",
            "",
            "\tu32tmp\t\t= 2141 * day_of_year + 132377;",
            "\tmonth\t\t= u32tmp >> 16;",
            "\tday\t\t= ((u16) u32tmp) / 2141;",
            "",
            "\t/*",
            "\t * Recall that January 1st is the 306-th day of the year in the",
            "\t * computational (not Gregorian) calendar.",
            "\t */",
            "\tis_Jan_or_Feb\t= day_of_year >= 306;",
            "",
            "\t/* Convert to the Gregorian calendar and adjust to Unix time. */",
            "\tyear\t\t= year + is_Jan_or_Feb - 6313183731940000ULL;",
            "\tmonth\t\t= is_Jan_or_Feb ? month - 12 : month;",
            "\tday\t\t= day + 1;",
            "\tday_of_year\t+= is_Jan_or_Feb ? -306 : 31 + 28 + is_leap_year;",
            "",
            "\t/* Convert to tm's format. */",
            "\tresult->tm_year = (long) (year - 1900);",
            "\tresult->tm_mon  = (int) month;",
            "\tresult->tm_mday = (int) day;",
            "\tresult->tm_yday = (int) day_of_year;",
            "}"
          ],
          "function_name": "time64_to_tm",
          "description": "该函数实现将64位时间戳转换为tm结构体，通过计算天数、处理闰年规则、应用纪元起始日星期信息，并采用基于数学推导的格里高利历算法进行月日转换，最终填充tm结构体成员",
          "similarity": 0.5534329414367676
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/timeconv.c",
          "start_line": 1,
          "end_line": 46,
          "content": [
            "// SPDX-License-Identifier: LGPL-2.0+",
            "/*",
            " * Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.",
            " * This file is part of the GNU C Library.",
            " * Contributed by Paul Eggert (eggert@twinsun.com).",
            " *",
            " * The GNU C Library is free software; you can redistribute it and/or",
            " * modify it under the terms of the GNU Library General Public License as",
            " * published by the Free Software Foundation; either version 2 of the",
            " * License, or (at your option) any later version.",
            " *",
            " * The GNU C Library is distributed in the hope that it will be useful,",
            " * but WITHOUT ANY WARRANTY; without even the implied warranty of",
            " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            " * Library General Public License for more details.",
            " *",
            " * You should have received a copy of the GNU Library General Public",
            " * License along with the GNU C Library; see the file COPYING.LIB.  If not,",
            " * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,",
            " * Boston, MA 02111-1307, USA.",
            " */",
            "",
            "/*",
            " * Converts the calendar time to broken-down time representation",
            " *",
            " * 2009-7-14:",
            " *   Moved from glibc-2.6 to kernel by Zhaolei<zhaolei@cn.fujitsu.com>",
            " * 2021-06-02:",
            " *   Reimplemented by Cassio Neri <cassio.neri@gmail.com>",
            " */",
            "",
            "#include <linux/time.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "",
            "#define SECS_PER_HOUR\t(60 * 60)",
            "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
            "",
            "/**",
            " * time64_to_tm - converts the calendar time to local broken-down time",
            " *",
            " * @totalsecs:\tthe number of seconds elapsed since 00:00:00 on January 1, 1970,",
            " *\t\tCoordinated Universal Time (UTC).",
            " * @offset:\toffset seconds adding to totalsecs.",
            " * @result:\tpointer to struct tm variable to receive broken-down time",
            " */"
          ],
          "function_name": null,
          "description": "此代码块定义了time64_to_tm函数的原型，用于将Unix时间戳（以秒为单位）转换为本地分解时间结构体tm，接受总秒数、时区偏移量和结果缓冲区参数，但未包含函数实现细节",
          "similarity": 0.5227640867233276
        }
      ]
    },
    {
      "source_file": "kernel/sched/clock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:58:20\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\clock.c`\n\n---\n\n# `sched/clock.c` 技术文档\n\n## 1. 文件概述\n\n`sched/clock.c` 实现了 Linux 内核中用于调度器的高分辨率时间戳机制 `sched_clock()`，特别针对 **不稳定 CPU 时钟源**（如 TSC 在某些硬件上不可靠）的场景。该文件提供了一个在单 CPU 上单调递增、高精度（纳秒级）、可在任意上下文（包括 NMI）中调用的时间源，并通过混合全局时间（GTOD）与本地时钟（如 TSC）来在多核系统中尽量减少时钟漂移。\n\n**重要警告**：不同 CPU 上的 `cpu_clock(i)` 与 `cpu_clock(j)`（i ≠ j）之间 **不保证全局单调性**，时间可能“倒退”。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 说明 |\n|------|------|\n| `sched_clock()` | 弱符号默认实现，基于 jiffies 提供低精度时间戳；架构可覆盖 |\n| `local_clock()` | 宏定义，等价于当前 CPU 的 `cpu_clock(smp_processor_id())` |\n| `cpu_clock(int cpu)` | 返回指定 CPU 的高分辨率时间戳（纳秒） |\n| `sched_clock_stable()` | 判断当前系统是否已进入“稳定时钟”模式（TSC 可靠） |\n| `clear_sched_clock_stable()` | 标记时钟为不稳定（如检测到 TSC 异常），触发修复流程 |\n| `sched_clock_init()` / `sched_clock_init_late()` | 初始化时钟子系统，分早期和晚期阶段 |\n\n### 关键数据结构\n\n```c\nstruct sched_clock_data {\n    u64 tick_raw;   // 上次更新时的原始 sched_clock() 值（如 TSC）\n    u64 tick_gtod;  // 上次更新时的全局时间（ktime_get_ns()）\n    u64 clock;      // 当前推算出的本地高精度单调时间\n};\n```\n\n- 每个 CPU 拥有一个 `sched_clock_data` 实例（`per_cpu` 变量）\n- 全局偏移量：\n  - `__sched_clock_offset`：原始时钟到稳定时间的偏移\n  - `__gtod_offset`：GTOD 到稳定时间的偏移\n\n### 静态键（Static Keys）\n\n- `sched_clock_running`：标记时钟子系统是否已初始化\n- `__sched_clock_stable`：标记时钟源是否稳定（TSC 可靠）\n- `__sched_clock_stable_early`：启动早期假设时钟稳定，避免多次切换\n\n## 3. 关键实现\n\n### 3.1 两种模式\n\n- **稳定模式**（`CONFIG_HAVE_UNSTABLE_SCHED_CLOCK` 未定义）：  \n  直接使用架构提供的 `sched_clock()`，假定其全局同步且高精度（如 ARM64 的 arch counter）。\n\n- **不稳定模式**（`CONFIG_HAVE_UNSTABLE_SCHED_CLOCK` 定义）：  \n  混合 GTOD（`ktime_get_ns()`）与原始 `sched_clock()`（如 TSC）：\n  - 以 GTOD 为基准，利用 `sched_clock()` 的高分辨率 delta 提升精度\n  - 通过 `__sched_clock_offset` 和 `__gtod_offset` 对齐两个时钟源\n\n### 3.2 时钟对齐与漂移控制\n\n- 初始化时通过 `__sched_clock_gtod_offset()` 计算初始偏移量，确保切换时连续\n- `sched_clock_local()` 函数实现核心逻辑：\n  - 计算自上次更新以来的原始时钟增量（`delta = now - tick_raw`）\n  - 将 GTOD 基准时间（`tick_gtod + __gtod_offset`）加上 `delta` 得到新时间\n  - 使用 `wrap_min`/`wrap_max` 处理 64 位回绕，并限制时间跳跃范围（防止 TSC 异常）\n\n### 3.3 稳定性动态切换\n\n- **启动时假设稳定**：`__sched_clock_stable_early = 1`\n- **晚期初始化**（`late_initcall`）：\n  - 若仍认为稳定，则调用 `__set_sched_clock_stable()` 完成对齐并启用稳定模式\n  - 若驱动（如 ACPI/Intel Idle）标记 TSC 不稳定，则调用 `clear_sched_clock_stable()`\n- **不稳定处理**：\n  - 调度工作队列 `sched_clock_work`\n  - 重新以 GTOD 为基准重置所有 CPU 的 `sched_clock_data`\n\n### 3.4 中断与抢占安全\n\n- 关键操作（如 stamp、offset 计算）使用 `local_irq_disable()` 保证原子性\n- `notrace` 属性避免被 ftrace 拦截，确保在 NMI 等上下文中可用\n\n## 4. 依赖关系\n\n- **时间子系统**：\n  - 依赖 `ktime_get_ns()`（GTOD，来自 `kernel/time/`）\n  - 依赖 `jiffies` 和 `HZ`（用于默认 `sched_clock` 实现）\n- **调度器**：为 `kernel/sched/` 提供高精度时间戳（如 `rq->clock` 更新）\n- **时钟事件/源**：与 `tick` 子系统交互（`TICK_DEP_BIT_CLOCK_UNSTABLE`）\n- **架构支持**：\n  - 若架构定义 `CONFIG_HAVE_UNSTABLE_SCHED_CLOCK`，则启用混合模式\n  - 架构可提供自己的 `sched_clock()` 实现（如 x86 使用 TSC）\n\n## 5. 使用场景\n\n- **调度器时间统计**：计算任务运行时间、就绪队列时钟等\n- **延迟跟踪**：`ftrace`、`perf` 等性能工具依赖 `local_clock()` 获取精确时间戳\n- **锁竞争分析**：`lockdep` 使用 `sched_clock()` 记录锁持有时间\n- **RCU、中断处理**：需要高精度、低开销时间戳的内核子系统\n- **虚拟化与电源管理**：在 CPU 进入/退出 idle 时校正时钟（通过 `sched_clock_idle_*` 钩子，虽未在本文件实现但相关）",
      "similarity": 0.5346930027008057,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/clock.c",
          "start_line": 62,
          "end_line": 177,
          "content": [
            "notrace unsigned long long __weak sched_clock(void)",
            "{",
            "\treturn (unsigned long long)(jiffies - INITIAL_JIFFIES)",
            "\t\t\t\t\t* (NSEC_PER_SEC / HZ);",
            "}",
            "notrace int sched_clock_stable(void)",
            "{",
            "\treturn static_branch_likely(&__sched_clock_stable);",
            "}",
            "notrace static void __scd_stamp(struct sched_clock_data *scd)",
            "{",
            "\tscd->tick_gtod = ktime_get_ns();",
            "\tscd->tick_raw = sched_clock();",
            "}",
            "notrace static void __set_sched_clock_stable(void)",
            "{",
            "\tstruct sched_clock_data *scd;",
            "",
            "\t/*",
            "\t * Since we're still unstable and the tick is already running, we have",
            "\t * to disable IRQs in order to get a consistent scd->tick* reading.",
            "\t */",
            "\tlocal_irq_disable();",
            "\tscd = this_scd();",
            "\t/*",
            "\t * Attempt to make the (initial) unstable->stable transition continuous.",
            "\t */",
            "\t__sched_clock_offset = (scd->tick_gtod + __gtod_offset) - (scd->tick_raw);",
            "\tlocal_irq_enable();",
            "",
            "\tprintk(KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\",",
            "\t\t\tscd->tick_gtod, __gtod_offset,",
            "\t\t\tscd->tick_raw,  __sched_clock_offset);",
            "",
            "\tstatic_branch_enable(&__sched_clock_stable);",
            "\ttick_dep_clear(TICK_DEP_BIT_CLOCK_UNSTABLE);",
            "}",
            "notrace static void __sched_clock_work(struct work_struct *work)",
            "{",
            "\tstruct sched_clock_data *scd;",
            "\tint cpu;",
            "",
            "\t/* take a current timestamp and set 'now' */",
            "\tpreempt_disable();",
            "\tscd = this_scd();",
            "\t__scd_stamp(scd);",
            "\tscd->clock = scd->tick_gtod + __gtod_offset;",
            "\tpreempt_enable();",
            "",
            "\t/* clone to all CPUs */",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tper_cpu(sched_clock_data, cpu) = *scd;",
            "",
            "\tprintk(KERN_WARNING \"TSC found unstable after boot, most likely due to broken BIOS. Use 'tsc=unstable'.\\n\");",
            "\tprintk(KERN_INFO \"sched_clock: Marking unstable (%lld, %lld)<-(%lld, %lld)\\n\",",
            "\t\t\tscd->tick_gtod, __gtod_offset,",
            "\t\t\tscd->tick_raw,  __sched_clock_offset);",
            "",
            "\tstatic_branch_disable(&__sched_clock_stable);",
            "}",
            "notrace static void __clear_sched_clock_stable(void)",
            "{",
            "\tif (!sched_clock_stable())",
            "\t\treturn;",
            "",
            "\ttick_dep_set(TICK_DEP_BIT_CLOCK_UNSTABLE);",
            "\tschedule_work(&sched_clock_work);",
            "}",
            "notrace void clear_sched_clock_stable(void)",
            "{",
            "\t__sched_clock_stable_early = 0;",
            "",
            "\tsmp_mb(); /* matches sched_clock_init_late() */",
            "",
            "\tif (static_key_count(&sched_clock_running.key) == 2)",
            "\t\t__clear_sched_clock_stable();",
            "}",
            "notrace static void __sched_clock_gtod_offset(void)",
            "{",
            "\tstruct sched_clock_data *scd = this_scd();",
            "",
            "\t__scd_stamp(scd);",
            "\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;",
            "}",
            "void __init sched_clock_init(void)",
            "{",
            "\t/*",
            "\t * Set __gtod_offset such that once we mark sched_clock_running,",
            "\t * sched_clock_tick() continues where sched_clock() left off.",
            "\t *",
            "\t * Even if TSC is buggered, we're still UP at this point so it",
            "\t * can't really be out of sync.",
            "\t */",
            "\tlocal_irq_disable();",
            "\t__sched_clock_gtod_offset();",
            "\tlocal_irq_enable();",
            "",
            "\tstatic_branch_inc(&sched_clock_running);",
            "}",
            "static int __init sched_clock_init_late(void)",
            "{",
            "\tstatic_branch_inc(&sched_clock_running);",
            "\t/*",
            "\t * Ensure that it is impossible to not do a static_key update.",
            "\t *",
            "\t * Either {set,clear}_sched_clock_stable() must see sched_clock_running",
            "\t * and do the update, or we must see their __sched_clock_stable_early",
            "\t * and do the update, or both.",
            "\t */",
            "\tsmp_mb(); /* matches {set,clear}_sched_clock_stable() */",
            "",
            "\tif (__sched_clock_stable_early)",
            "\t\t__set_sched_clock_stable();",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "sched_clock, sched_clock_stable, __scd_stamp, __set_sched_clock_stable, __sched_clock_work, __clear_sched_clock_stable, clear_sched_clock_stable, __sched_clock_gtod_offset, sched_clock_init, sched_clock_init_late",
          "description": "实现调度器时钟状态管理，包含sched_clock函数默认实现、稳定性检测、时钟数据同步逻辑(__set_sched_clock_stable/__clear_sched_clock_stable)、初始化流程(sched_clock_init/sched_clock_init_late)及工作队列处理(__sched_clock_work)，用于动态调整时钟偏移与稳定性标志。",
          "similarity": 0.576175332069397
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/clock.c",
          "start_line": 1,
          "end_line": 61,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * sched_clock() for unstable CPU clocks",
            " *",
            " *  Copyright (C) 2008 Red Hat, Inc., Peter Zijlstra",
            " *",
            " *  Updates and enhancements:",
            " *    Copyright (C) 2008 Red Hat, Inc. Steven Rostedt <srostedt@redhat.com>",
            " *",
            " * Based on code by:",
            " *   Ingo Molnar <mingo@redhat.com>",
            " *   Guillaume Chazarain <guichaz@gmail.com>",
            " *",
            " *",
            " * What this file implements:",
            " *",
            " * cpu_clock(i) provides a fast (execution time) high resolution",
            " * clock with bounded drift between CPUs. The value of cpu_clock(i)",
            " * is monotonic for constant i. The timestamp returned is in nanoseconds.",
            " *",
            " * ######################### BIG FAT WARNING ##########################",
            " * # when comparing cpu_clock(i) to cpu_clock(j) for i != j, time can #",
            " * # go backwards !!                                                  #",
            " * ####################################################################",
            " *",
            " * There is no strict promise about the base, although it tends to start",
            " * at 0 on boot (but people really shouldn't rely on that).",
            " *",
            " * cpu_clock(i)       -- can be used from any context, including NMI.",
            " * local_clock()      -- is cpu_clock() on the current CPU.",
            " *",
            " * sched_clock_cpu(i)",
            " *",
            " * How it is implemented:",
            " *",
            " * The implementation either uses sched_clock() when",
            " * !CONFIG_HAVE_UNSTABLE_SCHED_CLOCK, which means in that case the",
            " * sched_clock() is assumed to provide these properties (mostly it means",
            " * the architecture provides a globally synchronized highres time source).",
            " *",
            " * Otherwise it tries to create a semi stable clock from a mixture of other",
            " * clocks, including:",
            " *",
            " *  - GTOD (clock monotonic)",
            " *  - sched_clock()",
            " *  - explicit idle events",
            " *",
            " * We use GTOD as base and use sched_clock() deltas to improve resolution. The",
            " * deltas are filtered to provide monotonicity and keeping it within an",
            " * expected window.",
            " *",
            " * Furthermore, explicit sleep and wakeup hooks allow us to account for time",
            " * that is otherwise invisible (TSC gets stopped).",
            " *",
            " */",
            "",
            "/*",
            " * Scheduler clock - returns current time in nanosec units.",
            " * This is default implementation.",
            " * Architectures and sub-architectures can override this.",
            " */"
          ],
          "function_name": null,
          "description": "定义sched_clock函数，用于获取当前时间戳，在非稳定时钟配置下依赖架构提供的全局同步高精度时钟，通过混合GTOD、sched_clock及显式空闲事件实现半稳定时钟，支持跨CPU比较但需注意非单调性警告。",
          "similarity": 0.5631016492843628
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/clock.c",
          "start_line": 247,
          "end_line": 369,
          "content": [
            "static __always_inline u64 wrap_min(u64 x, u64 y)",
            "{",
            "\treturn (s64)(x - y) < 0 ? x : y;",
            "}",
            "static __always_inline u64 wrap_max(u64 x, u64 y)",
            "{",
            "\treturn (s64)(x - y) > 0 ? x : y;",
            "}",
            "static __always_inline u64 sched_clock_local(struct sched_clock_data *scd)",
            "{",
            "\tu64 now, clock, old_clock, min_clock, max_clock, gtod;",
            "\ts64 delta;",
            "",
            "again:",
            "\tnow = sched_clock_noinstr();",
            "\tdelta = now - scd->tick_raw;",
            "\tif (unlikely(delta < 0))",
            "\t\tdelta = 0;",
            "",
            "\told_clock = scd->clock;",
            "",
            "\t/*",
            "\t * scd->clock = clamp(scd->tick_gtod + delta,",
            "\t *\t\t      max(scd->tick_gtod, scd->clock),",
            "\t *\t\t      scd->tick_gtod + TICK_NSEC);",
            "\t */",
            "",
            "\tgtod = scd->tick_gtod + __gtod_offset;",
            "\tclock = gtod + delta;",
            "\tmin_clock = wrap_max(gtod, old_clock);",
            "\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);",
            "",
            "\tclock = wrap_max(clock, min_clock);",
            "\tclock = wrap_min(clock, max_clock);",
            "",
            "\tif (!raw_try_cmpxchg64(&scd->clock, &old_clock, clock))",
            "\t\tgoto again;",
            "",
            "\treturn clock;",
            "}",
            "noinstr u64 local_clock_noinstr(void)",
            "{",
            "\tu64 clock;",
            "",
            "\tif (static_branch_likely(&__sched_clock_stable))",
            "\t\treturn sched_clock_noinstr() + __sched_clock_offset;",
            "",
            "\tif (!static_branch_likely(&sched_clock_running))",
            "\t\treturn sched_clock_noinstr();",
            "",
            "\tclock = sched_clock_local(this_scd());",
            "",
            "\treturn clock;",
            "}",
            "u64 local_clock(void)",
            "{",
            "\tu64 now;",
            "\tpreempt_disable_notrace();",
            "\tnow = local_clock_noinstr();",
            "\tpreempt_enable_notrace();",
            "\treturn now;",
            "}",
            "static notrace u64 sched_clock_remote(struct sched_clock_data *scd)",
            "{",
            "\tstruct sched_clock_data *my_scd = this_scd();",
            "\tu64 this_clock, remote_clock;",
            "\tu64 *ptr, old_val, val;",
            "",
            "#if BITS_PER_LONG != 64",
            "again:",
            "\t/*",
            "\t * Careful here: The local and the remote clock values need to",
            "\t * be read out atomic as we need to compare the values and",
            "\t * then update either the local or the remote side. So the",
            "\t * cmpxchg64 below only protects one readout.",
            "\t *",
            "\t * We must reread via sched_clock_local() in the retry case on",
            "\t * 32-bit kernels as an NMI could use sched_clock_local() via the",
            "\t * tracer and hit between the readout of",
            "\t * the low 32-bit and the high 32-bit portion.",
            "\t */",
            "\tthis_clock = sched_clock_local(my_scd);",
            "\t/*",
            "\t * We must enforce atomic readout on 32-bit, otherwise the",
            "\t * update on the remote CPU can hit inbetween the readout of",
            "\t * the low 32-bit and the high 32-bit portion.",
            "\t */",
            "\tremote_clock = cmpxchg64(&scd->clock, 0, 0);",
            "#else",
            "\t/*",
            "\t * On 64-bit kernels the read of [my]scd->clock is atomic versus the",
            "\t * update, so we can avoid the above 32-bit dance.",
            "\t */",
            "\tsched_clock_local(my_scd);",
            "again:",
            "\tthis_clock = my_scd->clock;",
            "\tremote_clock = scd->clock;",
            "#endif",
            "",
            "\t/*",
            "\t * Use the opportunity that we have both locks",
            "\t * taken to couple the two clocks: we take the",
            "\t * larger time as the latest time for both",
            "\t * runqueues. (this creates monotonic movement)",
            "\t */",
            "\tif (likely((s64)(remote_clock - this_clock) < 0)) {",
            "\t\tptr = &scd->clock;",
            "\t\told_val = remote_clock;",
            "\t\tval = this_clock;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Should be rare, but possible:",
            "\t\t */",
            "\t\tptr = &my_scd->clock;",
            "\t\told_val = this_clock;",
            "\t\tval = remote_clock;",
            "\t}",
            "",
            "\tif (!try_cmpxchg64(ptr, &old_val, val))",
            "\t\tgoto again;",
            "",
            "\treturn val;",
            "}"
          ],
          "function_name": "wrap_min, wrap_max, sched_clock_local, local_clock_noinstr, local_clock, sched_clock_remote",
          "description": "提供时间戳范围约束函数(wrap_min/wrap_max)及本地/远程时钟访问接口(sched_clock_local/local_clock_noinstr)，通过cmpxchg64原子操作保障多CPU间时间戳的一致性，特别处理32位系统下的原子读取问题，确保时间戳单调递增。",
          "similarity": 0.5438917875289917
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sched/clock.c",
          "start_line": 388,
          "end_line": 477,
          "content": [
            "notrace u64 sched_clock_cpu(int cpu)",
            "{",
            "\tstruct sched_clock_data *scd;",
            "\tu64 clock;",
            "",
            "\tif (sched_clock_stable())",
            "\t\treturn sched_clock() + __sched_clock_offset;",
            "",
            "\tif (!static_branch_likely(&sched_clock_running))",
            "\t\treturn sched_clock();",
            "",
            "\tpreempt_disable_notrace();",
            "\tscd = cpu_sdc(cpu);",
            "",
            "\tif (cpu != smp_processor_id())",
            "\t\tclock = sched_clock_remote(scd);",
            "\telse",
            "\t\tclock = sched_clock_local(scd);",
            "\tpreempt_enable_notrace();",
            "",
            "\treturn clock;",
            "}",
            "notrace void sched_clock_tick(void)",
            "{",
            "\tstruct sched_clock_data *scd;",
            "",
            "\tif (sched_clock_stable())",
            "\t\treturn;",
            "",
            "\tif (!static_branch_likely(&sched_clock_running))",
            "\t\treturn;",
            "",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\tscd = this_scd();",
            "\t__scd_stamp(scd);",
            "\tsched_clock_local(scd);",
            "}",
            "notrace void sched_clock_tick_stable(void)",
            "{",
            "\tif (!sched_clock_stable())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Called under watchdog_lock.",
            "\t *",
            "\t * The watchdog just found this TSC to (still) be stable, so now is a",
            "\t * good moment to update our __gtod_offset. Because once we find the",
            "\t * TSC to be unstable, any computation will be computing crap.",
            "\t */",
            "\tlocal_irq_disable();",
            "\t__sched_clock_gtod_offset();",
            "\tlocal_irq_enable();",
            "}",
            "notrace void sched_clock_idle_sleep_event(void)",
            "{",
            "\tsched_clock_cpu(smp_processor_id());",
            "}",
            "notrace void sched_clock_idle_wakeup_event(void)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (sched_clock_stable())",
            "\t\treturn;",
            "",
            "\tif (unlikely(timekeeping_suspended))",
            "\t\treturn;",
            "",
            "\tlocal_irq_save(flags);",
            "\tsched_clock_tick();",
            "\tlocal_irq_restore(flags);",
            "}",
            "void __init sched_clock_init(void)",
            "{",
            "\tstatic_branch_inc(&sched_clock_running);",
            "\tlocal_irq_disable();",
            "\tgeneric_sched_clock_init();",
            "\tlocal_irq_enable();",
            "}",
            "notrace u64 sched_clock_cpu(int cpu)",
            "{",
            "\tif (!static_branch_likely(&sched_clock_running))",
            "\t\treturn 0;",
            "",
            "\treturn sched_clock();",
            "}",
            "notrace u64 __weak running_clock(void)",
            "{",
            "\treturn local_clock();",
            "}"
          ],
          "function_name": "sched_clock_cpu, sched_clock_tick, sched_clock_tick_stable, sched_clock_idle_sleep_event, sched_clock_idle_wakeup_event, sched_clock_init, sched_clock_cpu, running_clock",
          "description": "实现CPU级时间戳查询(sched_clock_cpu)、时钟滴答事件处理(sched_clock_tick)、空闲状态事件记录(sched_clock_idle_*event)及初始化流程(sched_clock_init)，包含稳定/非稳定时钟模式切换逻辑，通过running_clock弱定义提供默认本地时钟访问接口。",
          "similarity": 0.5436844825744629
        }
      ]
    },
    {
      "source_file": "kernel/time/sched_clock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:46:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\sched_clock.c`\n\n---\n\n# `time/sched_clock.c` 技术文档\n\n## 1. 文件概述\n\n`time/sched_clock.c` 实现了 Linux 内核中通用的 `sched_clock()` 机制，用于将底层硬件计数器（如 TSC、ARM arch timer 等）扩展为 64 位纳秒级单调时间戳。该机制为调度器、延迟跟踪、性能分析等子系统提供高精度、低开销的时间基准。文件通过双缓冲（双副本）+ 序列锁（`seqcount_latch_t`）的方式，确保即使在 NMI（不可屏蔽中断）上下文中调用 `sched_clock()` 也能获得一致、无撕裂的时间读数。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct clock_data`**  \n  全局状态结构体，包含：\n  - `seq`: `seqcount_latch_t` 类型的序列计数器，用于同步读写。\n  - `read_data[2]`: 双缓冲数组，分别存储当前有效和更新中的读取参数。\n  - `wrap_kt`: 计数器溢出前的最大持续时间（ktime_t 格式）。\n  - `rate`: 当前注册的时钟源频率（Hz）。\n  - `actual_read_sched_clock`: 指向底层硬件读取函数的指针。\n\n- **`struct clock_read_data`**（定义在头文件中）  \n  包含读取 `sched_clock` 所需的关键参数：\n  - `read_sched_clock`: 当前使用的读取函数（可能为挂起状态下的特殊函数）。\n  - `sched_clock_mask`: 计数器位宽掩码（如 `CLOCKSOURCE_MASK(bits)`）。\n  - `mult/shift`: 用于将计数器周期转换为纳秒的乘法/移位因子。\n  - `epoch_cyc/epoch_ns`: 上次校准时刻的计数器值和对应的纳秒时间戳。\n\n### 主要函数\n\n- **`sched_clock_noinstr(void)`**  \n  无插桩（noinstr）版本的 `sched_clock()`，在禁用抢占的上下文中直接读取并计算纳秒时间，使用序列锁保证一致性。\n\n- **`sched_clock(void)`**  \n  对外公开的 `sched_clock()` 接口，内部调用 `sched_clock_noinstr()` 并确保抢占被禁用。\n\n- **`sched_clock_register(read, bits, rate)`**  \n  注册新的底层硬件时钟源。计算 `mult/shift` 转换参数，更新全局 `clock_data`，并启动防溢出定时器。\n\n- **`generic_sched_clock_init(void)`**  \n  初始化通用 `sched_clock` 机制。若未注册硬件时钟，则回退到基于 `jiffies` 的实现，并启动周期性更新定时器。\n\n- **`sched_clock_suspend()/sched_clock_resume()`**  \n  系统挂起/恢复时的回调函数。挂起时切换读取函数为返回最后校准值的静态函数，恢复时重新同步并启用硬件读取。\n\n- **`update_sched_clock()`**  \n  更新 `epoch_cyc` 和 `epoch_ns`，防止因计数器长时间运行导致转换溢出。\n\n- **`sched_clock_poll()`**  \n  高精度定时器（hrtimer）回调函数，周期性调用 `update_sched_clock()`。\n\n## 3. 关键实现\n\n### 双缓冲 + Latch 序列锁机制\n\n- 使用 `seqcount_latch_t` 实现无锁读取：读操作通过 `sched_clock_read_begin()` 获取当前有效副本索引（`seq & 1`），并在末尾通过 `sched_clock_read_retry()` 验证读取期间未发生更新。\n- 写操作（如 `update_clock_read_data()`）先更新奇数副本（索引 1），通过 `raw_write_seqcount_latch()` 切换读者到奇数副本；再更新偶数副本（索引 0），再次切换回偶数副本。确保读者始终看到一致的旧数据或新数据，不会看到中间状态。\n\n### 时间转换与防溢出\n\n- 使用 `clocks_calc_mult_shift()` 计算最优的 `mult/shift` 对，将硬件计数器周期高效转换为纳秒（公式：`ns = (cyc * mult) >> shift`）。\n- 通过 `clocks_calc_max_nsecs()` 计算计数器在溢出前可安全表示的最大纳秒数，并以此设置 `hrtimer` 的超时时间（`wrap_kt`），定期调用 `update_sched_clock()` 重置 `epoch`，避免 64 位中间结果溢出。\n\n### 挂起/恢复处理\n\n- 系统挂起时，将 `read_sched_clock` 替换为 `suspended_sched_clock_read()`，该函数返回最后一次校准的 `epoch_cyc`，使 `sched_clock()` 在挂起期间表现为“冻结”。\n- 恢复时重新读取硬件计数器作为新的 `epoch_cyc`，并恢复原始读取函数。\n\n### 中断上下文安全\n\n- 所有读路径（`sched_clock*`）标记为 `notrace` 和 `noinstr`，避免在关键路径引入追踪或插桩开销。\n- 写操作（如注册、更新）在关中断（`local_irq_save`）下执行，确保与 NMI 上下文的读操作互斥。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/clocksource.h>`：提供 `CLOCKSOURCE_MASK`、`clocks_calc_mult_shift` 等时钟源工具。\n  - `<linux/hrtimer.h>`：用于实现防溢出定时器。\n  - `<linux/seqlock.h>`：提供 `seqcount_latch_t` 及相关操作。\n  - `\"timekeeping.h\"`：内核时间管理内部头文件。\n  - `<linux/sched/clock.h>`：定义 `sched_clock()` 接口及 `enable_sched_clock_irqtime()`。\n\n- **模块交互**：\n  - **调度器（scheduler）**：`sched_clock()` 是 `rq_clock()` 等调度时间基准的底层实现。\n  - **时间子系统（timekeeping）**：与 `ktime_get()` 等接口协同，但 `sched_clock()` 更侧重低开销、单调性。\n  - **电源管理（PM）**：通过 `syscore_ops` 注册挂起/恢复回调。\n  - **中断子系统**：若时钟频率 ≥ 1MHz 且 `irqtime` 未禁用，则启用中断时间统计（`enable_sched_clock_irqtime()`）。\n\n## 5. 使用场景\n\n- **调度延迟测量**：调度器使用 `sched_clock()` 计算任务运行时间、睡眠时间及调度延迟。\n- **性能分析工具**：如 `ftrace`、`perf` 使用 `sched_clock()` 作为事件时间戳。\n- **内核延迟跟踪**：`irqsoff`、`preemptoff` 等 tracer 依赖高精度单调时钟。\n- **硬件计数器抽象**：为架构特定的高精度计数器（如 x86 TSC、ARM arch timer）提供统一的 64 位纳秒接口。\n- **系统挂起/恢复**：在 Suspend-to-RAM 等场景下保持时间连续性，避免挂起期间时间“跳跃”。",
      "similarity": 0.5307058691978455,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 1,
          "end_line": 51,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Generic sched_clock() support, to extend low level hardware time",
            " * counters to full 64-bit ns values.",
            " */",
            "#include <linux/clocksource.h>",
            "#include <linux/init.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/math.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/bitops.h>",
            "",
            "#include \"timekeeping.h\"",
            "",
            "/**",
            " * struct clock_data - all data needed for sched_clock() (including",
            " *                     registration of a new clock source)",
            " *",
            " * @seq:\t\tSequence counter for protecting updates. The lowest",
            " *\t\t\tbit is the index for @read_data.",
            " * @read_data:\t\tData required to read from sched_clock.",
            " * @wrap_kt:\t\tDuration for which clock can run before wrapping.",
            " * @rate:\t\tTick rate of the registered clock.",
            " * @actual_read_sched_clock: Registered hardware level clock read function.",
            " *",
            " * The ordering of this structure has been chosen to optimize cache",
            " * performance. In particular 'seq' and 'read_data[0]' (combined) should fit",
            " * into a single 64-byte cache line.",
            " */",
            "struct clock_data {",
            "\tseqcount_latch_t\tseq;",
            "\tstruct clock_read_data\tread_data[2];",
            "\tktime_t\t\t\twrap_kt;",
            "\tunsigned long\t\trate;",
            "",
            "\tu64 (*actual_read_sched_clock)(void);",
            "};",
            "",
            "static struct hrtimer sched_clock_timer;",
            "static int irqtime = -1;",
            "",
            "core_param(irqtime, irqtime, int, 0400);",
            ""
          ],
          "function_name": null,
          "description": "定义调度时钟所需的数据结构和全局变量，其中struct clock_data用于存储时钟读取数据、序列计数器、包装时间、速率及实际读取函数指针，通过结构体布局优化缓存性能",
          "similarity": 0.5012657642364502
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 237,
          "end_line": 285,
          "content": [
            "void __init generic_sched_clock_init(void)",
            "{",
            "\t/*",
            "\t * If no sched_clock() function has been provided at that point,",
            "\t * make it the final one.",
            "\t */",
            "\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)",
            "\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);",
            "",
            "\tupdate_sched_clock();",
            "",
            "\t/*",
            "\t * Start the timer to keep sched_clock() properly updated and",
            "\t * sets the initial epoch.",
            "\t */",
            "\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);",
            "\tsched_clock_timer.function = sched_clock_poll;",
            "\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);",
            "}",
            "static u64 notrace suspended_sched_clock_read(void)",
            "{",
            "\tunsigned int seq = raw_read_seqcount_latch(&cd.seq);",
            "",
            "\treturn cd.read_data[seq & 1].epoch_cyc;",
            "}",
            "int sched_clock_suspend(void)",
            "{",
            "\tstruct clock_read_data *rd = &cd.read_data[0];",
            "",
            "\tupdate_sched_clock();",
            "\thrtimer_cancel(&sched_clock_timer);",
            "\trd->read_sched_clock = suspended_sched_clock_read;",
            "",
            "\treturn 0;",
            "}",
            "void sched_clock_resume(void)",
            "{",
            "\tstruct clock_read_data *rd = &cd.read_data[0];",
            "",
            "\trd->epoch_cyc = cd.actual_read_sched_clock();",
            "\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);",
            "\trd->read_sched_clock = cd.actual_read_sched_clock;",
            "}",
            "static int __init sched_clock_syscore_init(void)",
            "{",
            "\tregister_syscore_ops(&sched_clock_ops);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "generic_sched_clock_init, suspended_sched_clock_read, sched_clock_suspend, sched_clock_resume, sched_clock_syscore_init",
          "description": "提供调度时钟初始化、挂起/恢复处理及系统核心操作注册，初始化阶段设置默认时钟源并启动更新定时器，挂起时切换至专用读取函数以保持时间连续性",
          "similarity": 0.4737541973590851
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 52,
          "end_line": 202,
          "content": [
            "static u64 notrace jiffy_sched_clock_read(void)",
            "{",
            "\t/*",
            "\t * We don't need to use get_jiffies_64 on 32-bit arches here",
            "\t * because we register with BITS_PER_LONG",
            "\t */",
            "\treturn (u64)(jiffies - INITIAL_JIFFIES);",
            "}",
            "static __always_inline u64 cyc_to_ns(u64 cyc, u32 mult, u32 shift)",
            "{",
            "\treturn (cyc * mult) >> shift;",
            "}",
            "notrace int sched_clock_read_retry(unsigned int seq)",
            "{",
            "\treturn raw_read_seqcount_latch_retry(&cd.seq, seq);",
            "}",
            "unsigned long long noinstr sched_clock_noinstr(void)",
            "{",
            "\tstruct clock_read_data *rd;",
            "\tunsigned int seq;",
            "\tu64 cyc, res;",
            "",
            "\tdo {",
            "\t\tseq = raw_read_seqcount_latch(&cd.seq);",
            "\t\trd = cd.read_data + (seq & 1);",
            "",
            "\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &",
            "\t\t      rd->sched_clock_mask;",
            "\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);",
            "\t} while (raw_read_seqcount_latch_retry(&cd.seq, seq));",
            "",
            "\treturn res;",
            "}",
            "unsigned long long notrace sched_clock(void)",
            "{",
            "\tunsigned long long ns;",
            "\tpreempt_disable_notrace();",
            "\tns = sched_clock_noinstr();",
            "\tpreempt_enable_notrace();",
            "\treturn ns;",
            "}",
            "static void update_clock_read_data(struct clock_read_data *rd)",
            "{",
            "\t/* update the backup (odd) copy with the new data */",
            "\tcd.read_data[1] = *rd;",
            "",
            "\t/* steer readers towards the odd copy */",
            "\traw_write_seqcount_latch(&cd.seq);",
            "",
            "\t/* now its safe for us to update the normal (even) copy */",
            "\tcd.read_data[0] = *rd;",
            "",
            "\t/* switch readers back to the even copy */",
            "\traw_write_seqcount_latch(&cd.seq);",
            "}",
            "static void update_sched_clock(void)",
            "{",
            "\tu64 cyc;",
            "\tu64 ns;",
            "\tstruct clock_read_data rd;",
            "",
            "\trd = cd.read_data[0];",
            "",
            "\tcyc = cd.actual_read_sched_clock();",
            "\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);",
            "",
            "\trd.epoch_ns = ns;",
            "\trd.epoch_cyc = cyc;",
            "",
            "\tupdate_clock_read_data(&rd);",
            "}",
            "static enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)",
            "{",
            "\tupdate_sched_clock();",
            "\thrtimer_forward_now(hrt, cd.wrap_kt);",
            "",
            "\treturn HRTIMER_RESTART;",
            "}",
            "void __init",
            "sched_clock_register(u64 (*read)(void), int bits, unsigned long rate)",
            "{",
            "\tu64 res, wrap, new_mask, new_epoch, cyc, ns;",
            "\tu32 new_mult, new_shift;",
            "\tunsigned long r, flags;",
            "\tchar r_unit;",
            "\tstruct clock_read_data rd;",
            "",
            "\tif (cd.rate > rate)",
            "\t\treturn;",
            "",
            "\t/* Cannot register a sched_clock with interrupts on */",
            "\tlocal_irq_save(flags);",
            "",
            "\t/* Calculate the mult/shift to convert counter ticks to ns. */",
            "\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);",
            "",
            "\tnew_mask = CLOCKSOURCE_MASK(bits);",
            "\tcd.rate = rate;",
            "",
            "\t/* Calculate how many nanosecs until we risk wrapping */",
            "\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);",
            "\tcd.wrap_kt = ns_to_ktime(wrap);",
            "",
            "\trd = cd.read_data[0];",
            "",
            "\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/",
            "\tnew_epoch = read();",
            "\tcyc = cd.actual_read_sched_clock();",
            "\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);",
            "\tcd.actual_read_sched_clock = read;",
            "",
            "\trd.read_sched_clock\t= read;",
            "\trd.sched_clock_mask\t= new_mask;",
            "\trd.mult\t\t\t= new_mult;",
            "\trd.shift\t\t= new_shift;",
            "\trd.epoch_cyc\t\t= new_epoch;",
            "\trd.epoch_ns\t\t= ns;",
            "",
            "\tupdate_clock_read_data(&rd);",
            "",
            "\tif (sched_clock_timer.function != NULL) {",
            "\t\t/* update timeout for clock wrap */",
            "\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt,",
            "\t\t\t      HRTIMER_MODE_REL_HARD);",
            "\t}",
            "",
            "\tr = rate;",
            "\tif (r >= 4000000) {",
            "\t\tr = DIV_ROUND_CLOSEST(r, 1000000);",
            "\t\tr_unit = 'M';",
            "\t} else if (r >= 4000) {",
            "\t\tr = DIV_ROUND_CLOSEST(r, 1000);",
            "\t\tr_unit = 'k';",
            "\t} else {",
            "\t\tr_unit = ' ';",
            "\t}",
            "",
            "\t/* Calculate the ns resolution of this counter */",
            "\tres = cyc_to_ns(1ULL, new_mult, new_shift);",
            "",
            "\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",",
            "\t\tbits, r, r_unit, res, wrap);",
            "",
            "\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */",
            "\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))",
            "\t\tenable_sched_clock_irqtime();",
            "",
            "\tlocal_irq_restore(flags);",
            "",
            "\tpr_debug(\"Registered %pS as sched_clock source\\n\", read);",
            "}"
          ],
          "function_name": "jiffy_sched_clock_read, cyc_to_ns, sched_clock_read_retry, sched_clock_noinstr, sched_clock, update_clock_read_data, update_sched_clock, sched_clock_poll, sched_clock_register",
          "description": "实现调度时钟读取逻辑，包含周期到纳秒转换、时钟数据更新、定时器回调及注册接口，支持多版本读取数据的原子更新和时钟包装检测",
          "similarity": 0.4726727604866028
        }
      ]
    }
  ]
}