{
  "query": "设备驱动程序如何与硬件交互",
  "timestamp": "2025-12-25 23:50:52",
  "retrieved_files": [
    {
      "source_file": "kernel/hardware_message.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:43:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `hardware_message.c`\n\n---\n\n# hardware_message.c 技术文档\n\n## 文件概述\n\n`hardware_message.c` 是麒麟操作系统（Kylin Linux Advanced Desktop/Server，简称 KLAS/KLAD）内核中用于向用户发出硬件或驱动程序支持状态警告的专用模块。该文件定义了一系列函数，用于在内核启动或驱动加载过程中，根据硬件或驱动的生命周期状态（如“已弃用”、“不再维护”、“已禁用”或“技术预览”）向系统日志输出高优先级的 `pr_crit()` 警告信息。这些函数仅在启用了 `CONFIG_KYLIN_DIFFERENCES` 内核配置选项时生效，体现了麒麟操作系统对特定硬件兼容性与支持策略的管理机制。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `mark_hardware_unmaintained()` | 标记特定硬件设备为“不再维护”，输出包含设备描述的严重警告 |\n| `mark_driver_unmaintained()` | 标记驱动程序为“不再维护”，适用于无法关联具体硬件的通用驱动 |\n| `mark_hardware_deprecated()` | 标记特定硬件为“已弃用”，提示将在未来版本停止维护 |\n| `mark_driver_deprecated()` | 标记驱动为“已弃用”，适用于抽象或高层驱动 |\n| `mark_hardware_disabled()` | 标记硬件支持已被完全禁用，设备无法在当前版本使用 |\n| `mark_tech_preview()` | 标记驱动或子系统为“技术预览”状态（函数声明未完整实现） |\n\n### 数据结构与常量\n\n- `DEV_DESC_LEN`：定义设备描述字符串的最大长度（256 字节）\n- 使用 `va_list` 和可变参数处理设备描述格式化\n\n### 导出符号\n\n所有上述函数均通过 `EXPORT_SYMBOL()` 导出，可供其他内核模块调用。\n\n## 关键实现\n\n### 条件编译控制\n\n所有函数的实现均被 `#ifdef CONFIG_KYLIN_DIFFERENCES` 包裹，确保仅在麒麟定制内核中启用该功能，避免对上游 Linux 内核造成影响。\n\n### 驱动/模块名称解析逻辑\n\n函数优先使用传入的 `driver_name` 参数；若为空且启用了 `CONFIG_MODULES`，则回退到从 `struct module *mod` 中提取模块名；若两者均不可用，则使用默认字符串 `\"Kernel\"`。\n\n### 可变参数处理\n\n对于硬件相关的函数（`_hardware_*`），使用 `va_start`/`vsnprintf`/`va_end` 机制格式化设备描述信息，支持动态构造设备标识（如 PCI ID、设备型号等）。\n\n### 日志级别\n\n统一使用 `pr_crit()` 输出 **Critical** 级别日志，确保警告信息在系统日志中高亮显示，引起管理员注意。\n\n### 生命周期状态语义\n\n- **Deprecated（已弃用）**：当前仍可用，但计划在未来主版本中转为“不再维护”或“禁用”\n- **Unmaintained（不再维护）**：仅修复安全或严重问题，常规更新已停止\n- **Disabled（已禁用）**：当前版本已完全移除支持\n- **Tech Preview（技术预览）**：新功能，测试有限，不保证稳定性与支持（函数未完整实现）\n\n## 依赖关系\n\n### 头文件依赖\n\n- `<linux/kernel.h>`：提供 `pr_crit()`、`vsnprintf()`、`va_list` 等内核日志与字符串处理接口\n- `<linux/module.h>`：提供 `struct module` 定义及模块相关信息\n\n### 内核配置依赖\n\n- **必需**：`CONFIG_KYLIN_DIFFERENCES` — 启用麒麟特有差异功能\n- **可选**：`CONFIG_MODULES` — 支持从模块指针获取名称（若未启用模块，则跳过该路径）\n\n### 符号导出\n\n所有函数通过 `EXPORT_SYMBOL()` 导出，供其他驱动模块在初始化时调用，以声明自身支持状态。\n\n## 使用场景\n\n1. **驱动弃用通知**  \n   当某硬件厂商停止维护某款网卡，麒麟内核团队决定在下一主版本移除支持。当前版本中，该驱动在 `probe()` 时调用 `mark_hardware_deprecated()`，提示用户规划迁移。\n\n2. **通用驱动生命周期管理**  \n   某旧版 RAID 管理驱动因上游废弃，麒麟将其标记为“不再维护”，调用 `mark_driver_unmaintained()`，适用于所有使用该驱动的系统。\n\n3. **已禁用硬件检测**  \n   用户尝试加载已被内核配置禁用的旧显卡驱动，驱动框架调用 `mark_hardware_disabled()` 明确告知设备不可用。\n\n4. **新技术预览**  \n   引入实验性文件系统或新硬件支持时，通过 `mark_tech_preview()` 声明其非生产就绪状态（注：当前代码中该函数未实现完整逻辑）。\n\n5. **发布合规性**  \n   所有调用必须记录于 KLAS/KLAD 发行说明，并获得管理层审批，确保用户对硬件支持变更有明确预期。",
      "similarity": 0.6105849146842957,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/hardware_message.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Author: Jackie Liu <liuyun01@kylinos.cn>",
            " * Copyright (C) 2024, KylinSoft Corporation.",
            " *",
            " * The following functions are used by 'Kylin Linux Advanced Desktop/Server",
            " * Operation System' to indicate to users that hardware and drivers are",
            " * unsupported, or have limited support in KLAS/KLAD major and minor releases.",
            " * These functions output loud warning messages to the end user and should",
            " * be USED WITH CAUTION.",
            " *",
            " * Any use of these functions _MUST_ be documented in the KLAS/KLAD Release",
            " * Notes, and have approval of management.",
            " *",
            " * Generally, the process of disabling a driver or device in KLAS/KLAD requires",
            " * the driver or device to be marked as 'deprecated' in all existing releases,",
            " * and then either 'unmaintained' or 'disabled' in a future release.",
            " *",
            " * In general, deprecated and unmaintained drivers continue to receive security",
            " * related fixes until they are disabled.",
            " */",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "",
            "#define DEV_DESC_LEN 256",
            "",
            "/**",
            " * mark_hardware_unmaintained() - Mark hardware as unmaintained.",
            " * @driver_name: driver name",
            " * @mod: module pointer",
            " * @fmt: format for device description",
            " * @...: args for device description",
            " *",
            " * Called to notify users that the device will no longer be tested on a routine",
            " * basis and driver code associated with this device is no longer being updated.",
            " * KYLIN may fix security-related and critical issues. Support for this device",
            " * will be disabled in a future major release and users deploying this device",
            " * should plan to replace the device in production systems.",
            " *",
            " * This function should be used when the driver's usage can be tied to a",
            " * specific hardware device. For example, a network device driver loading on a",
            " * specific device that is no longer maintained by the manufacturer.",
            " */"
          ],
          "function_name": null,
          "description": "此代码块定义了用于标记硬件和驱动状态的函数原型，描述了各函数的用途及使用规范，核心功能是通知用户硬件/驱动的支持状态变化，但未提供函数实现，上下文不完整",
          "similarity": 0.6218682527542114
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/hardware_message.c",
          "start_line": 44,
          "end_line": 145,
          "content": [
            "void mark_hardware_unmaintained(const char *driver_name, struct module *mod,",
            "\t\t\t\tchar *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Unmaintained hardware is detected: %s:%s\\n\",",
            "\t\tname ?: \"Kernel\",",
            "\t\tdevice_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_driver_unmaintained(const char *driver_name, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tpr_crit(\"Warning: Unmaintained driver is detected: %s\\n\",",
            "\t\tname ?: \"Kernel\");",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_hardware_deprecated(const char *driver_name, struct module *mod,",
            "\t\t\t      char *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Deprecated Hardware is detected: %s:%s will not be \"",
            "\t\t\"maintained in a future major release and may be disabled.\\n\",",
            "\t\tname ?: \"Kernel\", device_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_driver_deprecated(const char *driver_name, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tpr_crit(\"Warning: Deprecated Driver is detected: %s will not be \"",
            "\t\t\"maintained in a future major release and may be disabled.\\n\",",
            "\t\tname ?: \"Kernel\");",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_hardware_disabled(const char *driver_name, struct module *mod,",
            "\t\t\t    char *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Disabled Hardware is detected: %s:%s is no longer \"",
            "\t\t\"enabled in this release.\\n\",",
            "\t\tname ?: \"Kernel\", device_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}"
          ],
          "function_name": "mark_hardware_unmaintained, mark_driver_unmaintained, mark_hardware_deprecated, mark_driver_deprecated, mark_hardware_disabled",
          "description": "实现了标记硬件/驱动状态的五个函数，通过变参处理构建设备描述信息并输出内核警告日志，核心功能是根据配置条件触发不同级别硬件/驱动支持状态的警告提示",
          "similarity": 0.6040768027305603
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/hardware_message.c",
          "start_line": 230,
          "end_line": 283,
          "content": [
            "void mark_tech_preview(const char *msg, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *str = NULL;",
            "",
            "\tif (msg)",
            "\t\tstr = msg;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tstr = mod->name;",
            "#endif",
            "",
            "\tpr_warn(\"TECH PREVIEW: %s may not be fully supported.\\n\"",
            "\t\t\"Please review provided documentation for limitations.\\n\",",
            "\t\tstr ?: \"kernel\");",
            "\tadd_taint(TAINT_AUX, LOCKDEP_STILL_OK);",
            "#ifdef CONFIG_MODULES",
            "\tif (mod)",
            "\t\tmod->taints |= (1U << TAINT_AUX);",
            "#endif",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_partner_supported(const char *msg, const char *partner,",
            "\t\t\t    struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *str = NULL;",
            "",
            "\tif (msg)",
            "\t\tstr = msg;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tstr = mod->name;",
            "#endif",
            "",
            "\tpr_warn(\"Warning: %s is a partner (%s) supported and not supported \"",
            "\t\t\"directly by KylinSoft Corporation.\\n\",",
            "\t\tstr ?: \"Kernel\", partner ?: \"Unknown\");",
            "\tadd_taint(TAINT_PARTNER_SUPPORTED, LOCKDEP_STILL_OK);",
            "#ifdef CONFIG_MODULES",
            "\tif (mod)",
            "\t\tmod->taints |= (1U << TAINT_PARTNER_SUPPORTED);",
            "#endif",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_partner_supported_module(const char *partner, struct module *mod)",
            "{",
            "#if defined(CONFIG_KYLIN_DIFFERENCES) && defined(CONFIG_MODULES)",
            "\tif (!mod)",
            "\t\treturn;",
            "",
            "\tmark_partner_supported(NULL, partner, mod);",
            "#endif",
            "}"
          ],
          "function_name": "mark_tech_preview, mark_partner_supported, mark_partner_supported_module",
          "description": "实现了与合作伙伴支持相关联的标记函数，通过添加特定污点标识和模块状态修改，核心功能是标注技术预览特性或第三方合作组件的非官方支持状态",
          "similarity": 0.5074306726455688
        }
      ]
    },
    {
      "source_file": "kernel/dma/coherent.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:10:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma\\coherent.c`\n\n---\n\n# `dma/coherent.c` 技术文档\n\n## 1. 文件概述\n\n`dma/coherent.c` 实现了 Linux 内核中**设备专属一致性 DMA 内存池**（per-device coherent DMA memory pool）的管理机制。该机制允许平台代码（如设备树解析代码）为特定设备预分配一块物理连续、CPU 与设备均可高效访问的内存区域，并通过标准的 `dma_alloc_coherent()` 接口从该内存池中分配内存，从而避免通用 DMA 分配器的开销或满足硬件对 DMA 地址范围的特殊要求。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct dma_coherent_mem`**  \n  描述一个设备专属的一致性 DMA 内存池：\n  - `virt_base`：CPU 虚拟地址（通过 `memremap()` 映射）\n  - `device_base`：设备视角的起始 DMA 地址\n  - `pfn_base`：物理内存起始页帧号（PFN）\n  - `size`：内存池大小（以页为单位）\n  - `bitmap`：位图，用于跟踪已分配/空闲页面\n  - `spinlock`：保护位图操作的自旋锁\n  - `use_dev_dma_pfn_offset`：是否使用设备特定的 PFN 偏移转换 DMA 地址\n\n### 主要函数\n\n- **`dma_declare_coherent_memory()`**  \n  由平台代码调用，为设备注册一个一致性 DMA 内存池。\n  \n- **`dma_release_coherent_memory()`**  \n  释放设备关联的一致性内存池资源。\n\n- **`dma_alloc_from_dev_coherent()`**  \n  供架构相关 `dma_alloc_coherent()` 实现调用，尝试从设备专属内存池分配内存。\n\n- **`dma_release_from_dev_coherent()`**  \n  供架构相关 `dma_free_coherent()` 实现调用，尝试释放内存到设备专属内存池。\n\n- **`dma_mmap_from_dev_coherent()`**  \n  供 `dma_mmap_coherent()` 实现调用，将设备专属内存映射到用户空间。\n\n- **内部辅助函数**  \n  - `dma_init_coherent_memory()`：初始化内存池结构\n  - `_dma_release_coherent_memory()`：释放内存池资源\n  - `dma_assign_coherent_memory()`：将内存池绑定到设备\n  - `__dma_alloc_from_coherent()` / `__dma_release_from_coherent()` / `__dma_mmap_from_coherent()`：核心分配/释放/映射逻辑\n\n## 3. 关键实现\n\n### 内存池初始化\n- 使用 `memremap(phys_addr, size, MEMREMAP_WC)` 将指定物理地址映射为 CPU 可访问的虚拟地址（通常使用写合并 WC 属性）。\n- 通过 `bitmap_zalloc()` 分配位图，用于管理页级别的内存分配。\n- 支持两种 DMA 地址计算方式：\n  - 直接使用传入的 `device_addr`\n  - 通过 `phys_to_dma()` 转换物理地址（当 `use_dev_dma_pfn_offset=true` 时）\n\n### 内存分配算法\n- 使用 `bitmap_find_free_region()` 在位图中查找连续的空闲页面块（按 2 的幂对齐）。\n- 分配成功后返回虚拟地址和对应的设备 DMA 地址。\n- 分配的内存会被 `memset()` 清零。\n\n### 线程安全\n- 所有位图操作（分配/释放）均通过 `spinlock` 保护，确保 SMP 环境下的安全性。\n- 使用 `spin_lock_irqsave()`/`spin_unlock_irqrestore()` 禁用本地中断，防止死锁。\n\n### 地址验证\n- 释放和 mmap 操作前会验证虚拟地址是否落在设备内存池范围内，确保操作的安全性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/io.h>`：提供 `memremap()`/`memunmap()`\n  - `<linux/slab.h>`：提供 `kzalloc()`/`kfree()`\n  - `<linux/dma-direct.h>`：提供 `phys_to_dma()`\n  - `<linux/dma-map-ops.h>`：DMA 映射操作接口\n  - `<linux/bitmap.h>`：位图操作（隐式包含）\n\n- **架构依赖**：\n  - 依赖架构特定的 `dma_alloc_coherent()` 实现调用 `dma_alloc_from_dev_coherent()` 等接口。\n  - 依赖 `phys_to_dma()` 的正确实现（在 `dma-direct.c` 中定义）。\n\n- **配置依赖**：\n  - `CONFIG_DMA_GLOBAL_POOL`：文件末尾有未完成的条件编译代码（可能用于全局 DMA 池扩展）。\n\n## 5. 使用场景\n\n1. **嵌入式/SoC 平台**  \n   当设备（如 GPU、DSP、网络控制器）要求 DMA 内存位于特定物理地址范围（如 DDR 的保留区域）时，平台代码通过设备树解析调用 `dma_declare_coherent_memory()` 预注册内存池。\n\n2. **性能敏感场景**  \n   避免通用 DMA 分配器（如 CMA）的运行时开销，为高频 DMA 操作提供快速、确定性的内存分配。\n\n3. **IOMMU 旁路场景**  \n   在无 IOMMU 或 IOMMU 被绕过的系统中，确保设备能直接访问物理连续内存。\n\n4. **用户空间映射**  \n   通过 `dma_mmap_from_dev_coherent()` 支持将设备专属 DMA 缓冲区直接映射到用户空间（如 V4L2、DRM 驱动）。",
      "similarity": 0.5891563892364502,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/dma/coherent.c",
          "start_line": 271,
          "end_line": 359,
          "content": [
            "int dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,",
            "\t\t\t   void *vaddr, size_t size, int *ret)",
            "{",
            "\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);",
            "",
            "\treturn __dma_mmap_from_coherent(mem, vma, vaddr, size, ret);",
            "}",
            "int dma_release_from_global_coherent(int order, void *vaddr)",
            "{",
            "\tif (!dma_coherent_default_memory)",
            "\t\treturn 0;",
            "",
            "\treturn __dma_release_from_coherent(dma_coherent_default_memory, order,",
            "\t\t\tvaddr);",
            "}",
            "int dma_mmap_from_global_coherent(struct vm_area_struct *vma, void *vaddr,",
            "\t\t\t\t   size_t size, int *ret)",
            "{",
            "\tif (!dma_coherent_default_memory)",
            "\t\treturn 0;",
            "",
            "\treturn __dma_mmap_from_coherent(dma_coherent_default_memory, vma,",
            "\t\t\t\t\tvaddr, size, ret);",
            "}",
            "int dma_init_global_coherent(phys_addr_t phys_addr, size_t size)",
            "{",
            "\tstruct dma_coherent_mem *mem;",
            "",
            "\tmem = dma_init_coherent_memory(phys_addr, phys_addr, size, true);",
            "\tif (IS_ERR(mem))",
            "\t\treturn PTR_ERR(mem);",
            "\tdma_coherent_default_memory = mem;",
            "\tpr_info(\"DMA: default coherent area is set\\n\");",
            "\treturn 0;",
            "}",
            "static int rmem_dma_device_init(struct reserved_mem *rmem, struct device *dev)",
            "{",
            "\tif (!rmem->priv) {",
            "\t\tstruct dma_coherent_mem *mem;",
            "",
            "\t\tmem = dma_init_coherent_memory(rmem->base, rmem->base,",
            "\t\t\t\t\t       rmem->size, true);",
            "\t\tif (IS_ERR(mem))",
            "\t\t\treturn PTR_ERR(mem);",
            "\t\trmem->priv = mem;",
            "\t}",
            "\tdma_assign_coherent_memory(dev, rmem->priv);",
            "\treturn 0;",
            "}",
            "static void rmem_dma_device_release(struct reserved_mem *rmem,",
            "\t\t\t\t    struct device *dev)",
            "{",
            "\tif (dev)",
            "\t\tdev->dma_mem = NULL;",
            "}",
            "static int __init rmem_dma_setup(struct reserved_mem *rmem)",
            "{",
            "\tunsigned long node = rmem->fdt_node;",
            "",
            "\tif (of_get_flat_dt_prop(node, \"reusable\", NULL))",
            "\t\treturn -EINVAL;",
            "",
            "#ifdef CONFIG_ARM",
            "\tif (!of_get_flat_dt_prop(node, \"no-map\", NULL)) {",
            "\t\tpr_err(\"Reserved memory: regions without no-map are not yet supported\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_DMA_GLOBAL_POOL",
            "\tif (of_get_flat_dt_prop(node, \"linux,dma-default\", NULL)) {",
            "\t\tWARN(dma_reserved_default_memory,",
            "\t\t     \"Reserved memory: region for default DMA coherent area is redefined\\n\");",
            "\t\tdma_reserved_default_memory = rmem;",
            "\t}",
            "#endif",
            "",
            "\trmem->ops = &rmem_dma_ops;",
            "\tpr_info(\"Reserved memory: created DMA memory pool at %pa, size %ld MiB\\n\",",
            "\t\t&rmem->base, (unsigned long)rmem->size / SZ_1M);",
            "\treturn 0;",
            "}",
            "static int __init dma_init_reserved_memory(void)",
            "{",
            "\tif (!dma_reserved_default_memory)",
            "\t\treturn -ENOMEM;",
            "\treturn dma_init_global_coherent(dma_reserved_default_memory->base,",
            "\t\t\t\t\tdma_reserved_default_memory->size);",
            "}"
          ],
          "function_name": "dma_mmap_from_dev_coherent, dma_release_from_global_coherent, dma_mmap_from_global_coherent, dma_init_global_coherent, rmem_dma_device_init, rmem_dma_device_release, rmem_dma_setup, dma_init_reserved_memory",
          "description": "该代码段实现了DMA相干内存的全局与设备级管理，核心功能包括：  \n1. 提供`dma_init_global_coherent`等函数初始化全局默认的DMA相干内存区域，并通过`dma_mmap_from_global_coherent`/`dma_release_from_global_coherent`管理其虚拟映射与释放；  \n2. `rmem_dma_setup`等函数通过保留内存机制（reserved memory）动态分配并注册DMA相干池，支持设备级内存绑定；  \n3. 上下文包含未完全展示的辅助函数（如`dma_init_coherent_memory`）及`rmem_dma_ops`操作符定义，需结合完整代码进一步验证。",
          "similarity": 0.5417435765266418
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/dma/coherent.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Coherent per-device memory handling.",
            " * Borrowed from i386",
            " */",
            "#include <linux/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "",
            "struct dma_coherent_mem {",
            "\tvoid\t\t*virt_base;",
            "\tdma_addr_t\tdevice_base;",
            "\tunsigned long\tpfn_base;",
            "\tint\t\tsize;",
            "\tunsigned long\t*bitmap;",
            "\tspinlock_t\tspinlock;",
            "\tbool\t\tuse_dev_dma_pfn_offset;",
            "};",
            "",
            "static inline struct dma_coherent_mem *dev_get_coherent_memory(struct device *dev)",
            "{",
            "\tif (dev && dev->dma_mem)",
            "\t\treturn dev->dma_mem;",
            "\treturn NULL;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了dma_coherent_mem结构体，用于管理设备DMA一致性内存区域，包含虚拟地址基址、设备物理地址基址、PFN基址、大小及位图锁等字段，提供获取设备DMA内存的辅助函数。",
          "similarity": 0.5312477350234985
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/dma/coherent.c",
          "start_line": 30,
          "end_line": 132,
          "content": [
            "static inline dma_addr_t dma_get_device_base(struct device *dev,",
            "\t\t\t\t\t     struct dma_coherent_mem * mem)",
            "{",
            "\tif (mem->use_dev_dma_pfn_offset)",
            "\t\treturn phys_to_dma(dev, PFN_PHYS(mem->pfn_base));",
            "\treturn mem->device_base;",
            "}",
            "static void _dma_release_coherent_memory(struct dma_coherent_mem *mem)",
            "{",
            "\tif (!mem)",
            "\t\treturn;",
            "",
            "\tmemunmap(mem->virt_base);",
            "\tbitmap_free(mem->bitmap);",
            "\tkfree(mem);",
            "}",
            "static int dma_assign_coherent_memory(struct device *dev,",
            "\t\t\t\t      struct dma_coherent_mem *mem)",
            "{",
            "\tif (!dev)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (dev->dma_mem)",
            "\t\treturn -EBUSY;",
            "",
            "\tdev->dma_mem = mem;",
            "\treturn 0;",
            "}",
            "int dma_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,",
            "\t\t\t\tdma_addr_t device_addr, size_t size)",
            "{",
            "\tstruct dma_coherent_mem *mem;",
            "\tint ret;",
            "",
            "\tmem = dma_init_coherent_memory(phys_addr, device_addr, size, false);",
            "\tif (IS_ERR(mem))",
            "\t\treturn PTR_ERR(mem);",
            "",
            "\tret = dma_assign_coherent_memory(dev, mem);",
            "\tif (ret)",
            "\t\t_dma_release_coherent_memory(mem);",
            "\treturn ret;",
            "}",
            "void dma_release_coherent_memory(struct device *dev)",
            "{",
            "\tif (dev) {",
            "\t\t_dma_release_coherent_memory(dev->dma_mem);",
            "\t\tdev->dma_mem = NULL;",
            "\t}",
            "}",
            "int dma_alloc_from_dev_coherent(struct device *dev, ssize_t size,",
            "\t\tdma_addr_t *dma_handle, void **ret)",
            "{",
            "\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);",
            "",
            "\tif (!mem)",
            "\t\treturn 0;",
            "",
            "\t*ret = __dma_alloc_from_coherent(dev, mem, size, dma_handle);",
            "\treturn 1;",
            "}",
            "static int __dma_release_from_coherent(struct dma_coherent_mem *mem,",
            "\t\t\t\t       int order, void *vaddr)",
            "{",
            "\tif (mem && vaddr >= mem->virt_base && vaddr <",
            "\t\t   (mem->virt_base + ((dma_addr_t)mem->size << PAGE_SHIFT))) {",
            "\t\tint page = (vaddr - mem->virt_base) >> PAGE_SHIFT;",
            "\t\tunsigned long flags;",
            "",
            "\t\tspin_lock_irqsave(&mem->spinlock, flags);",
            "\t\tbitmap_release_region(mem->bitmap, page, order);",
            "\t\tspin_unlock_irqrestore(&mem->spinlock, flags);",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "int dma_release_from_dev_coherent(struct device *dev, int order, void *vaddr)",
            "{",
            "\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);",
            "",
            "\treturn __dma_release_from_coherent(mem, order, vaddr);",
            "}",
            "static int __dma_mmap_from_coherent(struct dma_coherent_mem *mem,",
            "\t\tstruct vm_area_struct *vma, void *vaddr, size_t size, int *ret)",
            "{",
            "\tif (mem && vaddr >= mem->virt_base && vaddr + size <=",
            "\t\t   (mem->virt_base + ((dma_addr_t)mem->size << PAGE_SHIFT))) {",
            "\t\tunsigned long off = vma->vm_pgoff;",
            "\t\tint start = (vaddr - mem->virt_base) >> PAGE_SHIFT;",
            "\t\tunsigned long user_count = vma_pages(vma);",
            "\t\tint count = PAGE_ALIGN(size) >> PAGE_SHIFT;",
            "",
            "\t\t*ret = -ENXIO;",
            "\t\tif (off < count && user_count <= count - off) {",
            "\t\t\tunsigned long pfn = mem->pfn_base + start + off;",
            "\t\t\t*ret = remap_pfn_range(vma, vma->vm_start, pfn,",
            "\t\t\t\t\t       user_count << PAGE_SHIFT,",
            "\t\t\t\t\t       vma->vm_page_prot);",
            "\t\t}",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "dma_get_device_base, _dma_release_coherent_memory, dma_assign_coherent_memory, dma_declare_coherent_memory, dma_release_coherent_memory, dma_alloc_from_dev_coherent, __dma_release_from_coherent, dma_release_from_dev_coherent, __dma_mmap_from_coherent",
          "description": "实现了DMA一致性内存的分配/释放逻辑，包括声明设备特定DMA区域、分配/释放内存块、处理页表映射及释放操作，通过位图管理内存使用状态并处理不同架构下的DMA地址转换。",
          "similarity": 0.5051523447036743
        }
      ]
    },
    {
      "source_file": "kernel/power/console.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:19:20\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\console.c`\n\n---\n\n# power/console.c 技术文档\n\n## 1. 文件概述\n\n`power/console.c` 是 Linux 内核电源管理子系统中的一个组件，负责在系统挂起（suspend）和恢复（resume）过程中对控制台（console）进行保存与恢复操作。其主要目标是通过虚拟终端（VT）切换机制，确保在系统休眠期间控制台状态的正确性和可视性，同时支持部分图形或控制台驱动实现“无闪烁”（flicker-free）的挂起/恢复流程。\n\n该文件最初源自 `swsusp`（Software Suspend）项目，现用于协调多个控制台驱动对 VT 切换的需求，避免不必要的屏幕闪烁，并在必要时将内核日志重定向到专用的挂起控制台。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `pm_vt_switch_required(struct device *dev, bool required)`  \n  注册设备对 VT 切换的需求。若 `required` 为 `true`，表示该设备驱动在挂起/恢复时需要进行 VT 切换；若为 `false`，则表示支持无切换挂起。\n\n- `pm_vt_switch_unregister(struct device *dev)`  \n  注销设备的 VT 切换需求，将其从跟踪列表中移除。\n\n- `pm_prepare_console(void)`  \n  在系统挂起前准备控制台：若需要 VT 切换，则切换到专用的挂起控制台（`SUSPEND_CONSOLE`），并重定向内核消息输出。\n\n- `pm_restore_console(void)`  \n  在系统恢复后还原控制台：切换回原始前台控制台，并恢复内核消息的原始重定向目标。\n\n### 主要数据结构\n\n- `struct pm_vt_switch`  \n  表示一个设备对 VT 切换的需求：\n  ```c\n  struct pm_vt_switch {\n      struct list_head head;   // 链表节点\n      struct device *dev;      // 关联的设备\n      bool required;           // 是否需要 VT 切换\n  };\n  ```\n\n- 全局变量：\n  - `orig_fgconsole`：原始前台控制台编号。\n  - `orig_kmsg`：原始内核消息重定向目标控制台。\n  - `vt_switch_done`：标志位，表示是否已执行 VT 切换。\n  - `pm_vt_switch_list`：所有注册设备的 VT 切换需求链表。\n  - `vt_switch_mutex`：保护链表操作的互斥锁。\n\n## 3. 关键实现\n\n### VT 切换决策逻辑（`pm_vt_switch()`）\n\n系统是否执行 VT 切换由以下三个条件之一触发：\n1. **无任何驱动注册需求**：保留传统行为（默认切换）。\n2. **`console_suspend_enabled` 被禁用**（通过内核命令行参数 `no_console_suspend`）：需显示挂起/恢复期间的调试信息。\n3. **任一已注册驱动声明需要 VT 切换**（`required == true`）。\n\n只有当**所有已注册驱动都明确声明不需要 VT 切换**，且 `console_suspend_enabled` 为 `true` 时，才可跳过 VT 切换，实现无闪烁恢复。\n\n### 控制台保存与恢复流程\n\n- **挂起前（`pm_prepare_console`）**：\n  - 若需切换，调用 `vt_move_to_console(SUSPEND_CONSOLE, 1)` 切换到专用控制台（编号 `MAX_NR_CONSOLES-1`）。\n  - 使用 `vt_kmsg_redirect()` 将内核日志重定向至该控制台。\n  - 记录原始前台控制台编号和原始重定向目标。\n\n- **恢复后（`pm_restore_console`）**：\n  - 若曾执行切换，调用 `vt_move_to_console(orig_fgconsole, 0)` 切回原前台控制台。\n  - 恢复内核消息重定向至原始目标。\n  - 清除 `vt_switch_done` 标志。\n\n### 线程安全\n\n所有对 `pm_vt_switch_list` 的访问均受 `vt_switch_mutex` 互斥锁保护，确保在并发注册/注销场景下的数据一致性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/console.h>`：控制台核心接口。\n  - `<linux/vt_kern.h>` 和 `<linux/vt.h>`：虚拟终端内核接口，提供 `vt_move_to_console()` 和 `vt_kmsg_redirect()`。\n  - `<linux/kbd_kern.h>`：键盘相关（虽未直接使用，但 VT 子系统依赖）。\n  - `\"power.h\"`：本地电源管理头文件（可能定义 `console_suspend_enabled` 等）。\n\n- **内核子系统依赖**：\n  - **VT 子系统**：提供虚拟终端管理和切换能力。\n  - **电源管理核心（PM Core）**：本文件被 PM Core 在挂起/恢复流程中调用。\n  - **控制台驱动**：如 `fbcon`、`vgacon` 等可通过 `pm_vt_switch_required()` 声明自身需求。\n\n- **导出符号**：\n  - `pm_vt_switch_required` 和 `pm_vt_switch_unregister` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如显卡驱动）调用。\n\n## 5. 使用场景\n\n- **系统挂起/恢复流程**：  \n  在 `suspend` 阶段调用 `pm_prepare_console()`，在 `resume` 阶段调用 `pm_restore_console()`，确保控制台状态一致。\n\n- **图形驱动优化**：  \n  支持现代显示驱动（如 DRM/KMS 驱动）在挂起/恢复时自行管理显示状态，无需 VT 切换，从而避免屏幕闪烁，提升用户体验。\n\n- **调试支持**：  \n  当启用 `no_console_suspend` 内核参数时，强制进行 VT 切换并将内核日志输出到可见控制台，便于调试挂起/恢复问题。\n\n- **多控制台环境协调**：  \n  在存在多个控制台驱动（如文本控制台与帧缓冲控制台共存）时，统一协调 VT 切换策略，防止冲突。",
      "similarity": 0.5854570865631104,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/power/console.c",
          "start_line": 1,
          "end_line": 46,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Functions for saving/restoring console.",
            " *",
            " * Originally from swsusp.",
            " */",
            "",
            "#include <linux/console.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include \"power.h\"",
            "",
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)",
            "",
            "static int orig_fgconsole, orig_kmsg;",
            "static bool vt_switch_done;",
            "",
            "static DEFINE_MUTEX(vt_switch_mutex);",
            "",
            "struct pm_vt_switch {",
            "\tstruct list_head head;",
            "\tstruct device *dev;",
            "\tbool required;",
            "};",
            "",
            "static LIST_HEAD(pm_vt_switch_list);",
            "",
            "",
            "/**",
            " * pm_vt_switch_required - indicate VT switch at suspend requirements",
            " * @dev: device",
            " * @required: if true, caller needs VT switch at suspend/resume time",
            " *",
            " * The different console drivers may or may not require VT switches across",
            " * suspend/resume, depending on how they handle restoring video state and",
            " * what may be running.",
            " *",
            " * Drivers can indicate support for switchless suspend/resume, which can",
            " * save time and flicker, by using this routine and passing 'false' as",
            " * the argument.  If any loaded driver needs VT switching, or the",
            " * no_console_suspend argument has been passed on the command line, VT",
            " * switches will occur.",
            " */"
          ],
          "function_name": null,
          "description": "定义控制台保存/恢复相关全局变量及结构体，用于记录原始前台控制台和kmsg重定向信息，声明PM VT切换需求管理接口，包含VT切换所需锁和链表结构",
          "similarity": 0.4862169623374939
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/power/console.c",
          "start_line": 47,
          "end_line": 132,
          "content": [
            "void pm_vt_switch_required(struct device *dev, bool required)",
            "{",
            "\tstruct pm_vt_switch *entry, *tmp;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {",
            "\t\tif (tmp->dev == dev) {",
            "\t\t\t/* already registered, update requirement */",
            "\t\t\ttmp->required = required;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);",
            "\tif (!entry)",
            "\t\tgoto out;",
            "",
            "\tentry->required = required;",
            "\tentry->dev = dev;",
            "",
            "\tlist_add(&entry->head, &pm_vt_switch_list);",
            "out:",
            "\tmutex_unlock(&vt_switch_mutex);",
            "}",
            "void pm_vt_switch_unregister(struct device *dev)",
            "{",
            "\tstruct pm_vt_switch *tmp;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {",
            "\t\tif (tmp->dev == dev) {",
            "\t\t\tlist_del(&tmp->head);",
            "\t\t\tkfree(tmp);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&vt_switch_mutex);",
            "}",
            "static bool pm_vt_switch(void)",
            "{",
            "\tstruct pm_vt_switch *entry;",
            "\tbool ret = true;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tif (list_empty(&pm_vt_switch_list))",
            "\t\tgoto out;",
            "",
            "\tif (!console_suspend_enabled)",
            "\t\tgoto out;",
            "",
            "\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {",
            "\t\tif (entry->required)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tret = false;",
            "out:",
            "\tmutex_unlock(&vt_switch_mutex);",
            "\treturn ret;",
            "}",
            "void pm_prepare_console(void)",
            "{",
            "\tif (!pm_vt_switch())",
            "\t\treturn;",
            "",
            "\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);",
            "\tif (orig_fgconsole < 0)",
            "\t\treturn;",
            "",
            "\tvt_switch_done = true;",
            "",
            "\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);",
            "\treturn;",
            "}",
            "void pm_restore_console(void)",
            "{",
            "\tif (!pm_vt_switch() && !vt_switch_done)",
            "\t\treturn;",
            "",
            "\tif (orig_fgconsole >= 0) {",
            "\t\tvt_move_to_console(orig_fgconsole, 0);",
            "\t\tvt_kmsg_redirect(orig_kmsg);",
            "\t}",
            "",
            "\tvt_switch_done = false;",
            "}"
          ],
          "function_name": "pm_vt_switch_required, pm_vt_switch_unregister, pm_vt_switch, pm_prepare_console, pm_restore_console",
          "description": "实现VT切换需求注册/注销操作，判断是否需执行VT切换的辅助函数，以及准备/恢复控制台状态的完整流程，包含控制台切换和kmsg重定向的原子操作",
          "similarity": 0.46576982736587524
        }
      ]
    }
  ]
}