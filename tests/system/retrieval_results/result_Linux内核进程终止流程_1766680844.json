{
  "query": "Linux内核进程终止流程",
  "timestamp": "2025-12-26 00:40:44",
  "retrieved_files": [
    {
      "source_file": "kernel/exit.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:27:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `exit.c`\n\n---\n\n# `exit.c` 技术文档\n\n## 1. 文件概述\n\n`exit.c` 是 Linux 内核中负责进程退出（termination）核心逻辑的关键源文件，位于 `kernel/` 目录下。该文件实现了进程终止时的资源回收、信号处理、线程组清理、引用计数释放以及与用户空间和内核其他子系统的协调机制。其主要职责包括：\n\n- 安全地释放进程占用的内核资源（如内存、文件描述符、信号处理结构等）\n- 更新进程组和会话的统计信息\n- 通知父进程子进程已退出（通过 `SIGCHLD` 信号）\n- 管理僵尸进程（zombie）的生命周期\n- 支持线程组（thread group）的协同退出\n- 提供与 oops（内核异常）相关的计数和限制机制\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|---------|\n| `__unhash_process()` | 从内核的进程哈希表和链表中移除进程，减少线程计数 |\n| `__exit_signal()` | 清理进程的信号相关资源，累加 CPU 时间和 I/O 统计到 `signal_struct` |\n| `delayed_put_task_struct()` | RCU 回调函数，延迟释放 `task_struct` 及其关联资源 |\n| `put_task_struct_rcu_user()` | 安全地减少 `task_struct` 的 RCU 用户引用计数，并在为零时调度延迟释放 |\n| `release_thread()` | 架构相关的线程资源释放钩子（弱符号，可由架构代码覆盖） |\n| `release_task()` | 主进程释放入口函数，协调整个退出流程，包括通知父进程、释放资源等 |\n| `rcuwait_wake_up()` | 唤醒等待在 `rcuwait` 上的任务（代码片段未完整） |\n\n### 关键数据结构与变量\n\n| 名称 | 类型/说明 |\n|------|----------|\n| `oops_limit` | `unsigned int`，限制内核 oops 发生次数的阈值（默认 10000） |\n| `oops_count` | `atomic_t`，原子计数器，记录系统发生 oops 的总次数 |\n| `kern_exit_table` | `ctl_table`，用于 `/proc/sys/kernel/oops_limit` 的 sysctl 接口 |\n| `oops_count_attr` | `kobj_attribute`，用于 `/sys/kernel/oops_count` 的 sysfs 接口 |\n\n## 3. 关键实现\n\n### 进程退出流程\n\n1. **资源统计聚合**：  \n   在 `__exit_signal()` 中，将退出线程的 CPU 时间（`utime`/`stime`）、I/O 操作、上下文切换次数等统计信息累加到所属线程组的 `signal_struct` 中，确保即使线程组 leader 尚未退出，也能被 `wait4()` 等系统调用正确获取。\n\n2. **线程组协同退出**：  \n   - 若当前退出的是线程组 leader（`group_dead == true`），则清理整个线程组的 PID 类型（TGID、PGID、SID），并从全局任务链表中移除。\n   - 若非 leader，则仅减少线程组计数，并可能更新 `curr_target`（用于信号投递）。\n\n3. **僵尸进程处理**：  \n   在 `release_task()` 中，检查线程组 leader 是否已变为僵尸状态。若是且当前线程是最后一个成员，则调用 `do_notify_parent()` 通知其父进程。若父进程忽略 `SIGCHLD`，则直接将 leader 状态置为 `EXIT_DEAD` 并递归释放。\n\n4. **延迟释放机制**：  \n   通过 RCU（Read-Copy-Update）机制安全释放 `task_struct`。`put_task_struct_rcu_user()` 在引用计数归零时调用 `call_rcu()`，由 `delayed_put_task_struct()` 在 RCU 宽限期后执行实际释放，确保并发读取安全。\n\n5. **Oops 计数与限制**：  \n   提供 `oops_count`（只读）和 `oops_limit`（可调）两个接口，用于监控和限制内核异常次数，防止因频繁崩溃导致资源耗尽或引用计数溢出。\n\n### 锁与同步\n\n- **`tasklist_lock`**：写锁保护进程链表和 PID 哈希表的修改。\n- **`sighand->siglock`**：自旋锁保护信号处理结构。\n- **`signal->stats_lock`**：顺序锁（seqlock）保护线程组统计信息的聚合。\n- **RCU**：用于安全地延迟释放 `task_struct`，避免在遍历任务链表时访问已释放内存。\n\n## 4. 依赖关系\n\n`exit.c` 与内核多个子系统紧密耦合，主要依赖包括：\n\n- **调度器（SCHED）**：`<linux/sched/*.h>`，用于任务状态管理、CPU 时间统计、任务链表操作。\n- **内存管理（MM）**：`<linux/mm.h>`、`<linux/slab.h>`，用于内存释放和 slab 分配器交互。\n- **文件系统（VFS）**：`<linux/file.h>`、`<linux/fdtable.h>`、`<linux/fs_struct.h>`，用于关闭文件描述符和释放文件系统上下文。\n- **进程间通信（IPC）**：`<linux/shm.h>`、`<linux/posix-timers.h>`，用于清理共享内存和定时器资源。\n- **安全与审计**：`<linux/audit.h>`、`<linux/seccomp.h>`（通过 `seccomp_filter_release`），用于释放安全策略和审计上下文。\n- **cgroup 与资源控制**：`<linux/cgroup.h>`、`<linux/resource.h>`，用于资源计数释放和限制检查。\n- **跟踪与性能**：`<linux/perf_event.h>`、`<trace/events/sched.h>`，用于性能事件清理和调度跟踪点。\n- **架构相关代码**：`<asm/mmu_context.h>`、`release_thread()` 弱符号，允许架构层定制线程释放逻辑。\n\n## 5. 使用场景\n\n- **进程正常退出**：当用户程序调用 `exit()` 或 `exit_group()` 系统调用时，内核通过此文件执行清理。\n- **进程被信号终止**：如收到 `SIGKILL` 或 `SIGTERM` 后，内核调度退出路径。\n- **线程退出**：POSIX 线程（通过 `pthread_exit()` 或线程函数返回）触发 `release_task()` 清理单个线程。\n- **内核 Oops/panic 处理**：每次内核异常会递增 `oops_count`，用于监控系统稳定性。\n- **僵尸进程回收**：父进程调用 `wait()` 系列系统调用后，内核最终通过 `release_task()` 释放僵尸进程的内核结构。\n- **容器/命名空间退出**：在 PID 命名空间或 cgroup 中进程退出时，协调资源释放和通知机制。",
      "similarity": 0.6774088740348816,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/exit.c",
          "start_line": 546,
          "end_line": 686,
          "content": [
            "static void exit_mm(void)",
            "{",
            "\tstruct mm_struct *mm = current->mm;",
            "",
            "\texit_mm_release(current, mm);",
            "\tif (!mm)",
            "\t\treturn;",
            "\tsync_mm_rss(mm);",
            "\tmmap_read_lock(mm);",
            "\tmmgrab_lazy_tlb(mm);",
            "\tBUG_ON(mm != current->active_mm);",
            "\t/* more a memory barrier than a real lock */",
            "\ttask_lock(current);",
            "\t/*",
            "\t * When a thread stops operating on an address space, the loop",
            "\t * in membarrier_private_expedited() may not observe that",
            "\t * tsk->mm, and the loop in membarrier_global_expedited() may",
            "\t * not observe a MEMBARRIER_STATE_GLOBAL_EXPEDITED",
            "\t * rq->membarrier_state, so those would not issue an IPI.",
            "\t * Membarrier requires a memory barrier after accessing",
            "\t * user-space memory, before clearing tsk->mm or the",
            "\t * rq->membarrier_state.",
            "\t */",
            "\tsmp_mb__after_spinlock();",
            "\tlocal_irq_disable();",
            "\tcurrent->mm = NULL;",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(current, NULL);",
            "\t#endif",
            "\tmembarrier_update_current_mm(NULL);",
            "\tenter_lazy_tlb(mm, current);",
            "\tlocal_irq_enable();",
            "\ttask_unlock(current);",
            "\tmmap_read_unlock(mm);",
            "\tmm_update_next_owner(mm);",
            "\tmmput(mm);",
            "\tif (test_thread_flag(TIF_MEMDIE))",
            "\t\texit_oom_victim();",
            "}",
            "static void reparent_leader(struct task_struct *father, struct task_struct *p,",
            "\t\t\t\tstruct list_head *dead)",
            "{",
            "\tif (unlikely(p->exit_state == EXIT_DEAD))",
            "\t\treturn;",
            "",
            "\t/* We don't want people slaying init. */",
            "\tp->exit_signal = SIGCHLD;",
            "",
            "\t/* If it has exited notify the new parent about this child's death. */",
            "\tif (!p->ptrace &&",
            "\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {",
            "\t\tif (do_notify_parent(p, p->exit_signal)) {",
            "\t\t\tp->exit_state = EXIT_DEAD;",
            "\t\t\tlist_add(&p->ptrace_entry, dead);",
            "\t\t}",
            "\t}",
            "",
            "\tkill_orphaned_pgrp(p, father);",
            "}",
            "static void forget_original_parent(struct task_struct *father,",
            "\t\t\t\t\tstruct list_head *dead)",
            "{",
            "\tstruct task_struct *p, *t, *reaper;",
            "",
            "\tif (unlikely(!list_empty(&father->ptraced)))",
            "\t\texit_ptrace(father, dead);",
            "",
            "\t/* Can drop and reacquire tasklist_lock */",
            "\treaper = find_child_reaper(father, dead);",
            "\tif (list_empty(&father->children))",
            "\t\treturn;",
            "",
            "\treaper = find_new_reaper(father, reaper);",
            "\tlist_for_each_entry(p, &father->children, sibling) {",
            "\t\tfor_each_thread(p, t) {",
            "\t\t\tRCU_INIT_POINTER(t->real_parent, reaper);",
            "\t\t\tBUG_ON((!t->ptrace) != (rcu_access_pointer(t->parent) == father));",
            "\t\t\tif (likely(!t->ptrace))",
            "\t\t\t\tt->parent = t->real_parent;",
            "\t\t\tif (t->pdeath_signal)",
            "\t\t\t\tgroup_send_sig_info(t->pdeath_signal,",
            "\t\t\t\t\t\t    SEND_SIG_NOINFO, t,",
            "\t\t\t\t\t\t    PIDTYPE_TGID);",
            "\t\t}",
            "\t\t/*",
            "\t\t * If this is a threaded reparent there is no need to",
            "\t\t * notify anyone anything has happened.",
            "\t\t */",
            "\t\tif (!same_thread_group(reaper, father))",
            "\t\t\treparent_leader(father, p, dead);",
            "\t}",
            "\tlist_splice_tail_init(&father->children, &reaper->children);",
            "}",
            "static void exit_notify(struct task_struct *tsk, int group_dead)",
            "{",
            "\tbool autoreap;",
            "\tstruct task_struct *p, *n;",
            "\tLIST_HEAD(dead);",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\tforget_original_parent(tsk, &dead);",
            "",
            "\tif (group_dead)",
            "\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);",
            "",
            "\ttsk->exit_state = EXIT_ZOMBIE;",
            "\t/*",
            "\t * sub-thread or delay_group_leader(), wake up the",
            "\t * PIDFD_THREAD waiters.",
            "\t */",
            "\tif (!thread_group_empty(tsk))",
            "\t\tdo_notify_pidfd(tsk);",
            "",
            "\tif (unlikely(tsk->ptrace)) {",
            "\t\tint sig = thread_group_leader(tsk) &&",
            "\t\t\t\tthread_group_empty(tsk) &&",
            "\t\t\t\t!ptrace_reparented(tsk) ?",
            "\t\t\ttsk->exit_signal : SIGCHLD;",
            "\t\tautoreap = do_notify_parent(tsk, sig);",
            "\t} else if (thread_group_leader(tsk)) {",
            "\t\tautoreap = thread_group_empty(tsk) &&",
            "\t\t\tdo_notify_parent(tsk, tsk->exit_signal);",
            "\t} else {",
            "\t\tautoreap = true;",
            "\t}",
            "",
            "\tif (autoreap) {",
            "\t\ttsk->exit_state = EXIT_DEAD;",
            "\t\tlist_add(&tsk->ptrace_entry, &dead);",
            "\t}",
            "",
            "\t/* mt-exec, de_thread() is waiting for group leader */",
            "\tif (unlikely(tsk->signal->notify_count < 0))",
            "\t\twake_up_process(tsk->signal->group_exec_task);",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {",
            "\t\tlist_del_init(&p->ptrace_entry);",
            "\t\trelease_task(p);",
            "\t}",
            "}"
          ],
          "function_name": "exit_mm, reparent_leader, forget_original_parent, exit_notify",
          "description": "完成内存映射释放、父进程重定位、原始父进程解除关联及进程退出状态通知流程。",
          "similarity": 0.6799224615097046
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/exit.c",
          "start_line": 354,
          "end_line": 526,
          "content": [
            "int is_current_pgrp_orphaned(void)",
            "{",
            "\tint retval;",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\treturn retval;",
            "}",
            "static bool has_stopped_jobs(struct pid *pgrp)",
            "{",
            "\tstruct task_struct *p;",
            "",
            "\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {",
            "\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)",
            "\t\t\treturn true;",
            "\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);",
            "",
            "\treturn false;",
            "}",
            "static void",
            "kill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)",
            "{",
            "\tstruct pid *pgrp = task_pgrp(tsk);",
            "\tstruct task_struct *ignored_task = tsk;",
            "",
            "\tif (!parent)",
            "\t\t/* exit: our father is in a different pgrp than",
            "\t\t * we are and we were the only connection outside.",
            "\t\t */",
            "\t\tparent = tsk->real_parent;",
            "\telse",
            "\t\t/* reparent: our child is in a different pgrp than",
            "\t\t * we are, and it was the only connection outside.",
            "\t\t */",
            "\t\tignored_task = NULL;",
            "",
            "\tif (task_pgrp(parent) != pgrp &&",
            "\t    task_session(parent) == task_session(tsk) &&",
            "\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&",
            "\t    has_stopped_jobs(pgrp)) {",
            "\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);",
            "\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);",
            "\t}",
            "}",
            "static void coredump_task_exit(struct task_struct *tsk)",
            "{",
            "\tstruct core_state *core_state;",
            "",
            "\t/*",
            "\t * Serialize with any possible pending coredump.",
            "\t * We must hold siglock around checking core_state",
            "\t * and setting PF_POSTCOREDUMP.  The core-inducing thread",
            "\t * will increment ->nr_threads for each thread in the",
            "\t * group without PF_POSTCOREDUMP set.",
            "\t */",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "\ttsk->flags |= PF_POSTCOREDUMP;",
            "\tcore_state = tsk->signal->core_state;",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\t/* The vhost_worker does not particpate in coredumps */",
            "\tif (core_state &&",
            "\t    ((tsk->flags & (PF_IO_WORKER | PF_USER_WORKER)) != PF_USER_WORKER)) {",
            "\t\tstruct core_thread self;",
            "",
            "\t\tself.task = current;",
            "\t\tif (self.task->flags & PF_SIGNALED)",
            "\t\t\tself.next = xchg(&core_state->dumper.next, &self);",
            "\t\telse",
            "\t\t\tself.task = NULL;",
            "\t\t/*",
            "\t\t * Implies mb(), the result of xchg() must be visible",
            "\t\t * to core_state->dumper.",
            "\t\t */",
            "\t\tif (atomic_dec_and_test(&core_state->nr_threads))",
            "\t\t\tcomplete(&core_state->startup);",
            "",
            "\t\tfor (;;) {",
            "\t\t\tset_current_state(TASK_UNINTERRUPTIBLE|TASK_FREEZABLE);",
            "\t\t\tif (!self.task) /* see coredump_finish() */",
            "\t\t\t\tbreak;",
            "\t\t\tschedule();",
            "\t\t}",
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t}",
            "}",
            "void mm_update_next_owner(struct mm_struct *mm)",
            "{",
            "\tstruct task_struct *c, *g, *p = current;",
            "",
            "retry:",
            "\t/*",
            "\t * If the exiting or execing task is not the owner, it's",
            "\t * someone else's problem.",
            "\t */",
            "\tif (mm->owner != p)",
            "\t\treturn;",
            "\t/*",
            "\t * The current owner is exiting/execing and there are no other",
            "\t * candidates.  Do not leave the mm pointing to a possibly",
            "\t * freed task structure.",
            "\t */",
            "\tif (atomic_read(&mm->mm_users) <= 1) {",
            "\t\tWRITE_ONCE(mm->owner, NULL);",
            "\t\treturn;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\t/*",
            "\t * Search in the children",
            "\t */",
            "\tlist_for_each_entry(c, &p->children, sibling) {",
            "\t\tif (c->mm == mm)",
            "\t\t\tgoto assign_new_owner;",
            "\t}",
            "",
            "\t/*",
            "\t * Search in the siblings",
            "\t */",
            "\tlist_for_each_entry(c, &p->real_parent->children, sibling) {",
            "\t\tif (c->mm == mm)",
            "\t\t\tgoto assign_new_owner;",
            "\t}",
            "",
            "\t/*",
            "\t * Search through everything else, we should not get here often.",
            "\t */",
            "\tfor_each_process(g) {",
            "\t\tif (atomic_read(&mm->mm_users) <= 1)",
            "\t\t\tbreak;",
            "\t\tif (g->flags & PF_KTHREAD)",
            "\t\t\tcontinue;",
            "\t\tfor_each_thread(g, c) {",
            "\t\t\tif (c->mm == mm)",
            "\t\t\t\tgoto assign_new_owner;",
            "\t\t\tif (c->mm)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "\t/*",
            "\t * We found no owner yet mm_users > 1: this implies that we are",
            "\t * most likely racing with swapoff (try_to_unuse()) or /proc or",
            "\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.",
            "\t */",
            "\tWRITE_ONCE(mm->owner, NULL);",
            "\treturn;",
            "",
            "assign_new_owner:",
            "\tBUG_ON(c == p);",
            "\tget_task_struct(c);",
            "\t/*",
            "\t * The task_lock protects c->mm from changing.",
            "\t * We always want mm->owner->mm == mm",
            "\t */",
            "\ttask_lock(c);",
            "\t/*",
            "\t * Delay read_unlock() till we have the task_lock()",
            "\t * to ensure that c does not slip away underneath us",
            "\t */",
            "\tread_unlock(&tasklist_lock);",
            "\tif (c->mm != mm) {",
            "\t\ttask_unlock(c);",
            "\t\tput_task_struct(c);",
            "\t\tgoto retry;",
            "\t}",
            "\tWRITE_ONCE(mm->owner, c);",
            "\tlru_gen_migrate_mm(mm);",
            "\ttask_unlock(c);",
            "\tput_task_struct(c);",
            "}"
          ],
          "function_name": "is_current_pgrp_orphaned, has_stopped_jobs, kill_orphaned_pgrp, coredump_task_exit, mm_update_next_owner",
          "description": "实现进程组孤儿检测、停止状态判断、异常终止信号分发及核心转储协调逻辑。",
          "similarity": 0.607349157333374
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/exit.c",
          "start_line": 948,
          "end_line": 1066,
          "content": [
            "void __noreturn make_task_dead(int signr)",
            "{",
            "\t/*",
            "\t * Take the task off the cpu after something catastrophic has",
            "\t * happened.",
            "\t *",
            "\t * We can get here from a kernel oops, sometimes with preemption off.",
            "\t * Start by checking for critical errors.",
            "\t * Then fix up important state like USER_DS and preemption.",
            "\t * Then do everything else.",
            "\t */",
            "\tstruct task_struct *tsk = current;",
            "\tunsigned int limit;",
            "",
            "\tif (unlikely(in_interrupt()))",
            "\t\tpanic(\"Aiee, killing interrupt handler!\");",
            "\tif (unlikely(!tsk->pid))",
            "\t\tpanic(\"Attempted to kill the idle task!\");",
            "",
            "\tif (unlikely(irqs_disabled())) {",
            "\t\tpr_info(\"note: %s[%d] exited with irqs disabled\\n\",",
            "\t\t\tcurrent->comm, task_pid_nr(current));",
            "\t\tlocal_irq_enable();",
            "\t}",
            "\tif (unlikely(in_atomic())) {",
            "\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",",
            "\t\t\tcurrent->comm, task_pid_nr(current),",
            "\t\t\tpreempt_count());",
            "\t\tpreempt_count_set(PREEMPT_ENABLED);",
            "\t}",
            "",
            "\t/*",
            "\t * Every time the system oopses, if the oops happens while a reference",
            "\t * to an object was held, the reference leaks.",
            "\t * If the oops doesn't also leak memory, repeated oopsing can cause",
            "\t * reference counters to wrap around (if they're not using refcount_t).",
            "\t * This means that repeated oopsing can make unexploitable-looking bugs",
            "\t * exploitable through repeated oopsing.",
            "\t * To make sure this can't happen, place an upper bound on how often the",
            "\t * kernel may oops without panic().",
            "\t */",
            "\tlimit = READ_ONCE(oops_limit);",
            "\tif (atomic_inc_return(&oops_count) >= limit && limit)",
            "\t\tpanic(\"Oopsed too often (kernel.oops_limit is %d)\", limit);",
            "",
            "\t/*",
            "\t * We're taking recursive faults here in make_task_dead. Safest is to just",
            "\t * leave this task alone and wait for reboot.",
            "\t */",
            "\tif (unlikely(tsk->flags & PF_EXITING)) {",
            "\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");",
            "\t\tfutex_exit_recursive(tsk);",
            "\t\ttsk->exit_state = EXIT_DEAD;",
            "\t\trefcount_inc(&tsk->rcu_users);",
            "\t\tdo_task_dead();",
            "\t}",
            "",
            "\tdo_exit(signr);",
            "}",
            "void __noreturn",
            "do_group_exit(int exit_code)",
            "{",
            "\tstruct signal_struct *sig = current->signal;",
            "",
            "\tif (sig->flags & SIGNAL_GROUP_EXIT)",
            "\t\texit_code = sig->group_exit_code;",
            "\telse if (sig->group_exec_task)",
            "\t\texit_code = 0;",
            "\telse {",
            "\t\tstruct sighand_struct *const sighand = current->sighand;",
            "",
            "\t\tspin_lock_irq(&sighand->siglock);",
            "\t\tif (sig->flags & SIGNAL_GROUP_EXIT)",
            "\t\t\t/* Another thread got here before we took the lock.  */",
            "\t\t\texit_code = sig->group_exit_code;",
            "\t\telse if (sig->group_exec_task)",
            "\t\t\texit_code = 0;",
            "\t\telse {",
            "\t\t\tsig->group_exit_code = exit_code;",
            "\t\t\tsig->flags = SIGNAL_GROUP_EXIT;",
            "\t\t\tzap_other_threads(current);",
            "\t\t}",
            "\t\tspin_unlock_irq(&sighand->siglock);",
            "\t}",
            "",
            "\tdo_exit(exit_code);",
            "\t/* NOTREACHED */",
            "}",
            "static int eligible_pid(struct wait_opts *wo, struct task_struct *p)",
            "{",
            "\treturn\two->wo_type == PIDTYPE_MAX ||",
            "\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;",
            "}",
            "static int",
            "eligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)",
            "{",
            "\tif (!eligible_pid(wo, p))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * Wait for all children (clone and not) if __WALL is set or",
            "\t * if it is traced by us.",
            "\t */",
            "\tif (ptrace || (wo->wo_flags & __WALL))",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * Otherwise, wait for clone children *only* if __WCLONE is set;",
            "\t * otherwise, wait for non-clone children *only*.",
            "\t *",
            "\t * Note: a \"clone\" child here is one that reports to its parent",
            "\t * using a signal other than SIGCHLD, or a non-leader thread which",
            "\t * we can only see if it is traced by us.",
            "\t */",
            "\tif ((p->exit_signal != SIGCHLD) ^ !!(wo->wo_flags & __WCLONE))",
            "\t\treturn 0;",
            "",
            "\treturn 1;",
            "}"
          ],
          "function_name": "make_task_dead, do_group_exit, eligible_pid, eligible_child",
          "description": "make_task_dead处理致命错误导致的进程终止，通过do_exit完成退出流程；do_group_exit用于线程组统一退出，设置退出码并触发do_exit；eligible_pid和eligible_child用于过滤符合等待条件的子进程，根据PID类型和跟踪标志进行匹配。",
          "similarity": 0.600475013256073
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/exit.c",
          "start_line": 791,
          "end_line": 942,
          "content": [
            "static void check_stack_usage(void)",
            "{",
            "\tstatic DEFINE_SPINLOCK(low_water_lock);",
            "\tstatic int lowest_to_date = THREAD_SIZE;",
            "\tunsigned long free;",
            "",
            "\tfree = stack_not_used(current);",
            "",
            "\tif (free >= lowest_to_date)",
            "\t\treturn;",
            "",
            "\tspin_lock(&low_water_lock);",
            "\tif (free < lowest_to_date) {",
            "\t\tpr_info(\"%s (%d) used greatest stack depth: %lu bytes left\\n\",",
            "\t\t\tcurrent->comm, task_pid_nr(current), free);",
            "\t\tlowest_to_date = free;",
            "\t}",
            "\tspin_unlock(&low_water_lock);",
            "}",
            "static inline void check_stack_usage(void) {}",
            "static void synchronize_group_exit(struct task_struct *tsk, long code)",
            "{",
            "\tstruct sighand_struct *sighand = tsk->sighand;",
            "\tstruct signal_struct *signal = tsk->signal;",
            "",
            "\tspin_lock_irq(&sighand->siglock);",
            "\tsignal->quick_threads--;",
            "\tif ((signal->quick_threads == 0) &&",
            "\t    !(signal->flags & SIGNAL_GROUP_EXIT)) {",
            "\t\tsignal->flags = SIGNAL_GROUP_EXIT;",
            "\t\tsignal->group_exit_code = code;",
            "\t\tsignal->group_stop_count = 0;",
            "\t}",
            "\tspin_unlock_irq(&sighand->siglock);",
            "}",
            "void __noreturn do_exit(long code)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tint group_dead;",
            "",
            "\tWARN_ON(irqs_disabled());",
            "",
            "\tsynchronize_group_exit(tsk, code);",
            "",
            "\tWARN_ON(tsk->plug);",
            "",
            "\tkcov_task_exit(tsk);",
            "\tkmsan_task_exit(tsk);",
            "",
            "\tcoredump_task_exit(tsk);",
            "\tptrace_event(PTRACE_EVENT_EXIT, code);",
            "\tuser_events_exit(tsk);",
            "",
            "\tio_uring_files_cancel();",
            "\texit_signals(tsk);  /* sets PF_EXITING */",
            "",
            "\t/* sync mm's RSS info before statistics gathering */",
            "\tif (tsk->mm)",
            "\t\tsync_mm_rss(tsk->mm);",
            "\tacct_update_integrals(tsk);",
            "\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);",
            "\tif (group_dead) {",
            "\t\t/*",
            "\t\t * If the last thread of global init has exited, panic",
            "\t\t * immediately to get a useable coredump.",
            "\t\t */",
            "\t\tif (unlikely(is_global_init(tsk)))",
            "\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",",
            "\t\t\t\ttsk->signal->group_exit_code ?: (int)code);",
            "",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\t\thrtimer_cancel(&tsk->signal->real_timer);",
            "\t\texit_itimers(tsk);",
            "#endif",
            "\t\tif (tsk->mm)",
            "\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);",
            "\t}",
            "\tacct_collect(code, group_dead);",
            "\tif (group_dead)",
            "\t\ttty_audit_exit();",
            "\taudit_free(tsk);",
            "",
            "\ttsk->exit_code = code;",
            "\ttaskstats_exit(tsk, group_dead);",
            "",
            "\t/*",
            "\t * Since sampling can touch ->mm, make sure to stop everything before we",
            "\t * tear it down.",
            "\t *",
            "\t * Also flushes inherited counters to the parent - before the parent",
            "\t * gets woken up by child-exit notifications.",
            "\t */",
            "\tperf_event_exit_task(tsk);",
            "",
            "\texit_mm();",
            "",
            "\tif (group_dead)",
            "\t\tacct_process();",
            "\ttrace_sched_process_exit(tsk);",
            "",
            "\texit_sem(tsk);",
            "\texit_shm(tsk);",
            "\texit_files(tsk);",
            "\texit_fs(tsk);",
            "\tif (group_dead)",
            "\t\tdisassociate_ctty(1);",
            "\texit_task_namespaces(tsk);",
            "\texit_task_work(tsk);",
            "\texit_thread(tsk);",
            "",
            "\tsched_autogroup_exit_task(tsk);",
            "\tcgroup_exit(tsk);",
            "",
            "\t/*",
            "\t * FIXME: do that only when needed, using sched_exit tracepoint",
            "\t */",
            "\tflush_ptrace_hw_breakpoint(tsk);",
            "",
            "\texit_tasks_rcu_start();",
            "\texit_notify(tsk, group_dead);",
            "\tproc_exit_connector(tsk);",
            "\tmpol_put_task_policy(tsk);",
            "#ifdef CONFIG_FUTEX",
            "\tif (unlikely(current->pi_state_cache))",
            "\t\tkfree(current->pi_state_cache);",
            "#endif",
            "\t/*",
            "\t * Make sure we are holding no locks:",
            "\t */",
            "\tdebug_check_no_locks_held();",
            "",
            "\tif (tsk->io_context)",
            "\t\texit_io_context(tsk);",
            "",
            "\tif (tsk->splice_pipe)",
            "\t\tfree_pipe_info(tsk->splice_pipe);",
            "",
            "\tif (tsk->task_frag.page)",
            "\t\tput_page(tsk->task_frag.page);",
            "",
            "\texit_task_stack_account(tsk);",
            "",
            "\tcheck_stack_usage();",
            "\tpreempt_disable();",
            "\tif (tsk->nr_dirtied)",
            "\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);",
            "\texit_rcu();",
            "\texit_tasks_rcu_finish();",
            "",
            "\tlockdep_free_task(tsk);",
            "\tdo_task_dead();",
            "}"
          ],
          "function_name": "check_stack_usage, check_stack_usage, synchronize_group_exit, do_exit",
          "description": "do_exit函数负责处理进程退出流程，包括同步线程组退出、释放资源、更新统计信息、清理内存映射、解除命名空间关联等操作。其中synchronize_group_exit用于减少信号量计数并标记线程组退出状态，check_stack_usage监控最大堆栈使用量。",
          "similarity": 0.5865259766578674
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/exit.c",
          "start_line": 102,
          "end_line": 209,
          "content": [
            "static __init int kernel_exit_sysctls_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kern_exit_table);",
            "\treturn 0;",
            "}",
            "static ssize_t oops_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t       char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%d\\n\", atomic_read(&oops_count));",
            "}",
            "static __init int kernel_exit_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &oops_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "static void __unhash_process(struct task_struct *p, bool group_dead)",
            "{",
            "\tnr_threads--;",
            "\tdetach_pid(p, PIDTYPE_PID);",
            "\tif (group_dead) {",
            "\t\tdetach_pid(p, PIDTYPE_TGID);",
            "\t\tdetach_pid(p, PIDTYPE_PGID);",
            "\t\tdetach_pid(p, PIDTYPE_SID);",
            "",
            "\t\tlist_del_rcu(&p->tasks);",
            "\t\tlist_del_init(&p->sibling);",
            "\t\t__this_cpu_dec(process_counts);",
            "\t}",
            "\tlist_del_rcu(&p->thread_group);",
            "\tlist_del_rcu(&p->thread_node);",
            "}",
            "static void __exit_signal(struct task_struct *tsk)",
            "{",
            "\tstruct signal_struct *sig = tsk->signal;",
            "\tbool group_dead = thread_group_leader(tsk);",
            "\tstruct sighand_struct *sighand;",
            "\tstruct tty_struct *tty;",
            "\tu64 utime, stime;",
            "",
            "\tsighand = rcu_dereference_check(tsk->sighand,",
            "\t\t\t\t\tlockdep_tasklist_lock_is_held());",
            "\tspin_lock(&sighand->siglock);",
            "",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\tposix_cpu_timers_exit(tsk);",
            "\tif (group_dead)",
            "\t\tposix_cpu_timers_exit_group(tsk);",
            "#endif",
            "",
            "\tif (group_dead) {",
            "\t\ttty = sig->tty;",
            "\t\tsig->tty = NULL;",
            "\t} else {",
            "\t\t/*",
            "\t\t * If there is any task waiting for the group exit",
            "\t\t * then notify it:",
            "\t\t */",
            "\t\tif (sig->notify_count > 0 && !--sig->notify_count)",
            "\t\t\twake_up_process(sig->group_exec_task);",
            "",
            "\t\tif (tsk == sig->curr_target)",
            "\t\t\tsig->curr_target = next_thread(tsk);",
            "\t}",
            "",
            "\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,",
            "\t\t\t      sizeof(unsigned long long));",
            "",
            "\t/*",
            "\t * Accumulate here the counters for all threads as they die. We could",
            "\t * skip the group leader because it is the last user of signal_struct,",
            "\t * but we want to avoid the race with thread_group_cputime() which can",
            "\t * see the empty ->thread_head list.",
            "\t */",
            "\ttask_cputime(tsk, &utime, &stime);",
            "\twrite_seqlock(&sig->stats_lock);",
            "\tsig->utime += utime;",
            "\tsig->stime += stime;",
            "\tsig->gtime += task_gtime(tsk);",
            "\tsig->min_flt += tsk->min_flt;",
            "\tsig->maj_flt += tsk->maj_flt;",
            "\tsig->nvcsw += tsk->nvcsw;",
            "\tsig->nivcsw += tsk->nivcsw;",
            "\tsig->inblock += task_io_get_inblock(tsk);",
            "\tsig->oublock += task_io_get_oublock(tsk);",
            "\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);",
            "\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;",
            "\tsig->nr_threads--;",
            "\t__unhash_process(tsk, group_dead);",
            "\twrite_sequnlock(&sig->stats_lock);",
            "",
            "\ttsk->sighand = NULL;",
            "\tspin_unlock(&sighand->siglock);",
            "",
            "\t__cleanup_sighand(sighand);",
            "\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);",
            "\tif (group_dead)",
            "\t\ttty_kref_put(tty);",
            "}",
            "static void delayed_put_task_struct(struct rcu_head *rhp)",
            "{",
            "\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);",
            "",
            "\tkprobe_flush_task(tsk);",
            "\trethook_flush_task(tsk);",
            "\tperf_event_delayed_put(tsk);",
            "\ttrace_sched_process_free(tsk);",
            "\tput_task_struct(tsk);",
            "}"
          ],
          "function_name": "kernel_exit_sysctls_init, oops_count_show, kernel_exit_sysfs_init, __unhash_process, __exit_signal, delayed_put_task_struct",
          "description": "初始化sysctl和sysfs接口，实现进程卸载、信号处理、线程组分离及统计信息汇总功能。",
          "similarity": 0.5486850738525391
        }
      ]
    },
    {
      "source_file": "kernel/panic.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:14:29\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `panic.c`\n\n---\n\n# panic.c 技术文档\n\n## 文件概述\n\n`panic.c` 是 Linux 内核中实现系统崩溃（panic）处理机制的核心文件。当内核检测到无法恢复的严重错误（如内存损坏、死锁、硬件异常等）时，会调用 `panic()` 函数终止系统运行，并输出诊断信息。该文件负责协调崩溃流程中的关键操作，包括打印错误信息、通知注册的回调、停止其他 CPU、触发 kdump/kexec 崩溃转储、以及最终系统停机或重启。它还提供了对 WARN() 警告的限流和自动 panic 支持，并支持通过 sysctl 和 sysfs 暴露控制接口。\n\n## 核心功能\n\n### 主要函数\n- **`panic(const char *fmt, ...)`**：内核 panic 的主入口函数，格式化输出错误信息，执行清理和停机流程，永不返回。\n- **`nmi_panic(struct pt_regs *regs, const char *msg)`**：在 NMI（不可屏蔽中断）上下文中安全地触发 panic，避免多 CPU 同时 panic。\n- **`nmi_panic_self_stop(struct pt_regs *regs)`**：当其他 CPU 已 panic 时，当前 CPU 在 NMI 上下文中自旋等待，可被架构代码覆盖以保存寄存器状态。\n- **`panic_smp_self_stop(void)`**：panic 的 CPU 在停止其他 CPU 后自旋等待，可被架构代码覆盖。\n- **`crash_smp_send_stop(void)`**：向其他 CPU 发送停止信号，用于崩溃转储前的准备，可被架构代码覆盖以保存 CPU 状态。\n- **`check_panic_on_warn(const char *origin)`**：检查是否因 WARN() 触发 panic（基于 `panic_on_warn` 或 `warn_limit`）。\n- **`panic_other_cpus_shutdown(bool crash_kexec)`**：辅助函数，根据 `panic_print` 设置决定是否触发所有 CPU 的 backtrace，然后停止其他 CPU。\n- **`panic_print_sys_info(bool console_flush)`**：根据 `panic_print` 位掩码打印各类系统诊断信息（任务、内存、锁、ftrace 等）。\n\n### 关键数据结构与变量\n- **`panic_notifier_list`**：原子通知链，允许其他子系统注册 panic 事件回调。\n- **`panic_timeout`**：panic 后自动重启/关机的超时时间（秒），0 表示无限等待，负值表示立即关机。\n- **`panic_print`**：位掩码，控制 panic 时打印哪些额外的系统信息（任务状态、内存、锁等）。\n- **`panic_on_oops`**：若置位，内核 oops（严重错误但非致命）将升级为 panic。\n- **`panic_on_warn`**：若置位，任何 `WARN()` 调用将触发 panic。\n- **`warn_limit` / `warn_count`**：限制 `WARN()` 调用次数，超过阈值则触发 panic。\n- **`panic_cpu`**：原子变量，记录当前触发 panic 的 CPU ID，防止多 CPU 同时 panic。\n- **`panic_blink`**：函数指针，用于在 panic 时通过 LED 闪烁指示状态（如键盘 Caps Lock）。\n- **`sysctl_oops_all_cpu_backtrace`**（SMP）：控制 oops 时是否打印所有 CPU 的 backtrace。\n- **`crash_kexec_post_notifiers`**：控制是否在通知链和 kmsg_dump 之后再执行 crash_kexec。\n\n## 关键实现\n\n### Panic 流程控制\n1. **单点进入**：通过 `panic_cpu` 原子变量确保只有一个 CPU 执行完整的 panic 流程，其他 CPU 调用 `nmi_panic_self_stop()` 自旋。\n2. **中断禁用**：panic CPU 禁用本地中断，防止在自旋等待时被中断打断。\n3. **信息输出**：格式化 panic 消息，根据 `panic_print` 位掩码选择性输出系统状态（任务、内存、锁、ftrace、阻塞任务等）。\n4. **通知与转储**：\n   - 若 `crash_kexec_post_notifiers` 为假，则先尝试执行 crash_kexec（崩溃转储）。\n   - 调用 `atomic_notifier_call_chain()` 通知所有 panic 回调。\n   - 调用 `kmsg_dump(KMSG_DUMP_PANIC)` 转储内核日志。\n   - 若 `crash_kexec_post_notifiers` 为真，则在此之后执行 crash_kexec。\n5. **多 CPU 停止**：\n   - 根据 `panic_print & PANIC_PRINT_ALL_CPU_BT` 决定是否先触发所有 CPU 的 NMI backtrace。\n   - 调用 `crash_smp_send_stop()`（用于崩溃转储）或 `smp_send_stop()` 停止其他 CPU。\n6. **最终停机**：\n   - 若 `panic_timeout > 0`，启动定时器并在超时后重启/关机。\n   - 启用 `panic_blink`（如键盘 LED 闪烁）提供视觉指示。\n   - 调用 `panic_smp_self_stop()` 进入无限循环。\n\n### NMI 安全 Panic\n- `nmi_panic()` 专为 NMI 上下文设计，通过 `panic_cpu` 检查避免竞争。\n- 若当前 CPU 非首个 panic CPU，则调用 `nmi_panic_self_stop()`，允许架构代码在此保存寄存器状态用于崩溃分析。\n\n### 警告限流与自动 Panic\n- `check_panic_on_warn()` 被 `WARN()` 宏调用，检查 `panic_on_warn` 或 `warn_count` 是否超过 `warn_limit`，若是则触发 panic。\n- `warn_count` 通过原子操作计数，并通过 sysfs (`/sys/kernel/warn_count`) 暴露。\n\n### 可配置性\n- **Sysctl 接口**：`/proc/sys/kernel/oops_all_cpu_backtrace`（SMP）、`/proc/sys/kernel/warn_limit`。\n- **Sysfs 接口**：`/sys/kernel/warn_count`。\n- **内核参数**：`panic=`, `panic_on_oops=`, `panic_on_warn=`, `warn_limit=`, `panic_print=` 等。\n\n## 依赖关系\n\n- **架构相关代码**：依赖 `asm/sections.h` 和弱符号函数（`panic_smp_self_stop`, `nmi_panic_self_stop`, `crash_smp_send_stop`），由各架构实现提供崩溃转储支持。\n- **调度器**：使用 `show_state()`, `show_state_filter()` 打印任务信息。\n- **内存管理**：调用 `show_mem()` 输出内存状态。\n- **锁调试**：集成 `debug_show_all_locks()` 检测死锁。\n- **ftrace**：通过 `ftrace_dump()` 输出函数跟踪信息。\n- **kexec/kdump**：与 `linux/kexec.h` 协作执行崩溃内核加载。\n- **通知机制**：使用 `linux/notifier.h` 的原子通知链。\n- **控制台**：通过 `console_flush_on_panic()` 刷新日志。\n- **SysRq**：调用 `sysrq_timer_list_show()` 打印定时器信息。\n- **调试支持**：集成 `kgdb`, `kmsg_dump`, `bug.h`（WARN 处理）等。\n\n## 使用场景\n\n1. **内核严重错误处理**：当内核遇到不可恢复错误（如空指针解引用、死锁、内存破坏）时，通过 `panic()` 终止系统，防止数据损坏。\n2. **Oops 升级为 Panic**：当 `panic_on_oops=1` 时，普通 oops（如页错误）会触发完整 panic 流程。\n3. **调试辅助**：开发人员通过 `panic_print` 位掩码在 panic 时自动收集系统状态（如所有 CPU backtrace、锁状态），加速问题定位。\n4. **自动崩溃转储**：结合 kexec/kdump，在 panic 时自动保存内存镜像供离线分析。\n5. **生产环境防护**：通过 `warn_limit` 限制内核警告频率，避免因频繁警告导致系统不稳定，超限时自动 panic 触发高可用切换。\n6. **NMI 错误处理**：硬件错误（如 MCE）在 NMI 上下文中通过 `nmi_panic()` 安全触发 panic。\n7. **系统监控**：通过 sysfs 的 `warn_count` 监控内核警告发生次数，评估系统健康度。",
      "similarity": 0.6324235796928406,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/panic.c",
          "start_line": 285,
          "end_line": 474,
          "content": [
            "void panic(const char *fmt, ...)",
            "{",
            "\tstatic char buf[1024];",
            "\tva_list args;",
            "\tlong i, i_next = 0, len;",
            "\tint state = 0;",
            "\tint old_cpu, this_cpu;",
            "\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;",
            "",
            "\tif (panic_on_warn) {",
            "\t\t/*",
            "\t\t * This thread may hit another WARN() in the panic path.",
            "\t\t * Resetting this prevents additional WARN() from panicking the",
            "\t\t * system on this thread.  Other threads are blocked by the",
            "\t\t * panic_mutex in panic().",
            "\t\t */",
            "\t\tpanic_on_warn = 0;",
            "\t}",
            "",
            "\t/*",
            "\t * Disable local interrupts. This will prevent panic_smp_self_stop",
            "\t * from deadlocking the first cpu that invokes the panic, since",
            "\t * there is nothing to prevent an interrupt handler (that runs",
            "\t * after setting panic_cpu) from invoking panic() again.",
            "\t */",
            "\tlocal_irq_disable();",
            "\tpreempt_disable_notrace();",
            "",
            "\t/*",
            "\t * It's possible to come here directly from a panic-assertion and",
            "\t * not have preempt disabled. Some functions called from here want",
            "\t * preempt to be disabled. No point enabling it later though...",
            "\t *",
            "\t * Only one CPU is allowed to execute the panic code from here. For",
            "\t * multiple parallel invocations of panic, all other CPUs either",
            "\t * stop themself or will wait until they are stopped by the 1st CPU",
            "\t * with smp_send_stop().",
            "\t *",
            "\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which",
            "\t * comes here, so go ahead.",
            "\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets",
            "\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.",
            "\t */",
            "\tthis_cpu = raw_smp_processor_id();",
            "\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);",
            "",
            "\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)",
            "\t\tpanic_smp_self_stop();",
            "",
            "\tconsole_verbose();",
            "\tbust_spinlocks(1);",
            "\tva_start(args, fmt);",
            "\tlen = vscnprintf(buf, sizeof(buf), fmt, args);",
            "\tva_end(args);",
            "",
            "\tif (len && buf[len - 1] == '\\n')",
            "\t\tbuf[len - 1] = '\\0';",
            "",
            "\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);",
            "#ifdef CONFIG_DEBUG_BUGVERBOSE",
            "\t/*",
            "\t * Avoid nested stack-dumping if a panic occurs during oops processing",
            "\t */",
            "\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)",
            "\t\tdump_stack();",
            "#endif",
            "",
            "\t/*",
            "\t * If kgdb is enabled, give it a chance to run before we stop all",
            "\t * the other CPUs or else we won't be able to debug processes left",
            "\t * running on them.",
            "\t */",
            "\tkgdb_panic(buf);",
            "",
            "\t/*",
            "\t * If we have crashed and we have a crash kernel loaded let it handle",
            "\t * everything else.",
            "\t * If we want to run this after calling panic_notifiers, pass",
            "\t * the \"crash_kexec_post_notifiers\" option to the kernel.",
            "\t *",
            "\t * Bypass the panic_cpu check and call __crash_kexec directly.",
            "\t */",
            "\tif (!_crash_kexec_post_notifiers)",
            "\t\t__crash_kexec(NULL);",
            "",
            "\tpanic_other_cpus_shutdown(_crash_kexec_post_notifiers);",
            "",
            "\tprintk_legacy_allow_panic_sync();",
            "",
            "\t/*",
            "\t * Run any panic handlers, including those that might need to",
            "\t * add information to the kmsg dump output.",
            "\t */",
            "\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);",
            "",
            "\tpanic_print_sys_info(false);",
            "",
            "\tkmsg_dump(KMSG_DUMP_PANIC);",
            "",
            "\t/*",
            "\t * If you doubt kdump always works fine in any situation,",
            "\t * \"crash_kexec_post_notifiers\" offers you a chance to run",
            "\t * panic_notifiers and dumping kmsg before kdump.",
            "\t * Note: since some panic_notifiers can make crashed kernel",
            "\t * more unstable, it can increase risks of the kdump failure too.",
            "\t *",
            "\t * Bypass the panic_cpu check and call __crash_kexec directly.",
            "\t */",
            "\tif (_crash_kexec_post_notifiers)",
            "\t\t__crash_kexec(NULL);",
            "",
            "\tconsole_unblank();",
            "",
            "\t/*",
            "\t * We may have ended up stopping the CPU holding the lock (in",
            "\t * smp_send_stop()) while still having some valuable data in the console",
            "\t * buffer.  Try to acquire the lock then release it regardless of the",
            "\t * result.  The release will also print the buffers out.  Locks debug",
            "\t * should be disabled to avoid reporting bad unlock balance when",
            "\t * panic() is not being callled from OOPS.",
            "\t */",
            "\tdebug_locks_off();",
            "\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);",
            "",
            "\tpanic_print_sys_info(true);",
            "",
            "\tif (!panic_blink)",
            "\t\tpanic_blink = no_blink;",
            "",
            "\tif (panic_timeout > 0) {",
            "\t\t/*",
            "\t\t * Delay timeout seconds before rebooting the machine.",
            "\t\t * We can't use the \"normal\" timers since we just panicked.",
            "\t\t */",
            "\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);",
            "",
            "\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {",
            "\t\t\ttouch_nmi_watchdog();",
            "\t\t\tif (i >= i_next) {",
            "\t\t\t\ti += panic_blink(state ^= 1);",
            "\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;",
            "\t\t\t}",
            "\t\t\tmdelay(PANIC_TIMER_STEP);",
            "\t\t}",
            "\t}",
            "\tif (panic_timeout != 0) {",
            "\t\t/*",
            "\t\t * This will not be a clean reboot, with everything",
            "\t\t * shutting down.  But if there is a chance of",
            "\t\t * rebooting the system it will be rebooted.",
            "\t\t */",
            "\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)",
            "\t\t\treboot_mode = panic_reboot_mode;",
            "\t\temergency_restart();",
            "\t}",
            "#ifdef __sparc__",
            "\t{",
            "\t\textern int stop_a_enabled;",
            "\t\t/* Make sure the user can actually press Stop-A (L1-A) */",
            "\t\tstop_a_enabled = 1;",
            "\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"",
            "\t\t\t \"twice on console to return to the boot prom\\n\");",
            "\t}",
            "#endif",
            "#if defined(CONFIG_S390)",
            "\tdisabled_wait();",
            "#endif",
            "\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);",
            "",
            "\t/* Do not scroll important messages printed above */",
            "\tsuppress_printk = 1;",
            "",
            "\t/*",
            "\t * The final messages may not have been printed if in a context that",
            "\t * defers printing (such as NMI) and irq_work is not available.",
            "\t * Explicitly flush the kernel log buffer one last time.",
            "\t */",
            "\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);",
            "\tnbcon_atomic_flush_unsafe();",
            "",
            "\tlocal_irq_enable();",
            "\tfor (i = 0; ; i += PANIC_TIMER_STEP) {",
            "\t\ttouch_softlockup_watchdog();",
            "\t\tif (i >= i_next) {",
            "\t\t\ti += panic_blink(state ^= 1);",
            "\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;",
            "\t\t}",
            "\t\tmdelay(PANIC_TIMER_STEP);",
            "\t}",
            "}"
          ],
          "function_name": "panic",
          "description": "实现内核恐慌主函数，处理中断禁用、CPU同步、日志输出、kgdb回调、crash_kexec触发、panic通知链调用、系统重启延迟及最终panic信息打印。",
          "similarity": 0.5956997871398926
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/panic.c",
          "start_line": 548,
          "end_line": 676,
          "content": [
            "int test_taint(unsigned flag)",
            "{",
            "\treturn test_bit(flag, &tainted_mask);",
            "}",
            "unsigned long get_taint(void)",
            "{",
            "\treturn tainted_mask;",
            "}",
            "void add_taint(unsigned flag, enum lockdep_ok lockdep_ok)",
            "{",
            "#ifndef CONFIG_KYLIN_DIFFERENCES",
            "\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())",
            "\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");",
            "#endif",
            "",
            "\tset_bit(flag, &tainted_mask);",
            "",
            "\tif (tainted_mask & panic_on_taint) {",
            "\t\tpanic_on_taint = 0;",
            "\t\tpanic(\"panic_on_taint set ...\");",
            "\t}",
            "}",
            "static void spin_msec(int msecs)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < msecs; i++) {",
            "\t\ttouch_nmi_watchdog();",
            "\t\tmdelay(1);",
            "\t}",
            "}",
            "static void do_oops_enter_exit(void)",
            "{",
            "\tunsigned long flags;",
            "\tstatic int spin_counter;",
            "",
            "\tif (!pause_on_oops)",
            "\t\treturn;",
            "",
            "\tspin_lock_irqsave(&pause_on_oops_lock, flags);",
            "\tif (pause_on_oops_flag == 0) {",
            "\t\t/* This CPU may now print the oops message */",
            "\t\tpause_on_oops_flag = 1;",
            "\t} else {",
            "\t\t/* We need to stall this CPU */",
            "\t\tif (!spin_counter) {",
            "\t\t\t/* This CPU gets to do the counting */",
            "\t\t\tspin_counter = pause_on_oops;",
            "\t\t\tdo {",
            "\t\t\t\tspin_unlock(&pause_on_oops_lock);",
            "\t\t\t\tspin_msec(MSEC_PER_SEC);",
            "\t\t\t\tspin_lock(&pause_on_oops_lock);",
            "\t\t\t} while (--spin_counter);",
            "\t\t\tpause_on_oops_flag = 0;",
            "\t\t} else {",
            "\t\t\t/* This CPU waits for a different one */",
            "\t\t\twhile (spin_counter) {",
            "\t\t\t\tspin_unlock(&pause_on_oops_lock);",
            "\t\t\t\tspin_msec(1);",
            "\t\t\t\tspin_lock(&pause_on_oops_lock);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);",
            "}",
            "bool oops_may_print(void)",
            "{",
            "\treturn pause_on_oops_flag == 0;",
            "}",
            "void oops_enter(void)",
            "{",
            "\tnbcon_cpu_emergency_enter();",
            "\ttracing_off();",
            "\t/* can't trust the integrity of the kernel anymore: */",
            "\tdebug_locks_off();",
            "\tdo_oops_enter_exit();",
            "",
            "\tif (sysctl_oops_all_cpu_backtrace)",
            "\t\ttrigger_all_cpu_backtrace();",
            "}",
            "static void print_oops_end_marker(void)",
            "{",
            "\tpr_warn(\"---[ end trace %016llx ]---\\n\", 0ULL);",
            "}",
            "void oops_exit(void)",
            "{",
            "\tdo_oops_enter_exit();",
            "\tprint_oops_end_marker();",
            "\tnbcon_cpu_emergency_exit();",
            "\tkmsg_dump(KMSG_DUMP_OOPS);",
            "}",
            "void __warn(const char *file, int line, void *caller, unsigned taint,",
            "\t    struct pt_regs *regs, struct warn_args *args)",
            "{",
            "\tnbcon_cpu_emergency_enter();",
            "",
            "\tdisable_trace_on_warning();",
            "",
            "\tif (file)",
            "\t\tpr_warn(\"WARNING: CPU: %d PID: %d at %s:%d %pS\\n\",",
            "\t\t\traw_smp_processor_id(), current->pid, file, line,",
            "\t\t\tcaller);",
            "\telse",
            "\t\tpr_warn(\"WARNING: CPU: %d PID: %d at %pS\\n\",",
            "\t\t\traw_smp_processor_id(), current->pid, caller);",
            "",
            "\tif (args)",
            "\t\tvprintk(args->fmt, args->args);",
            "",
            "\tprint_modules();",
            "",
            "\tif (regs)",
            "\t\tshow_regs(regs);",
            "",
            "\tcheck_panic_on_warn(\"kernel\");",
            "",
            "\tif (!regs)",
            "\t\tdump_stack();",
            "",
            "\tprint_irqtrace_events(current);",
            "",
            "\tprint_oops_end_marker();",
            "\ttrace_error_report_end(ERROR_DETECTOR_WARN, (unsigned long)caller);",
            "",
            "\t/* Just a warning, don't kill lockdep. */",
            "\tadd_taint(taint, LOCKDEP_STILL_OK);",
            "",
            "\tnbcon_cpu_emergency_exit();",
            "}"
          ],
          "function_name": "test_taint, get_taint, add_taint, spin_msec, do_oops_enter_exit, oops_may_print, oops_enter, print_oops_end_marker, oops_exit, __warn",
          "description": "提供内核污染状态管理接口，实现Oops处理上下文切换逻辑，包含锁调试关闭、堆栈跟踪触发、警告信息记录及panic触发条件判断等功能。",
          "similarity": 0.5835570693016052
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/panic.c",
          "start_line": 1,
          "end_line": 106,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/panic.c",
            " *",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " */",
            "",
            "/*",
            " * This function is used through-out the kernel (including mm and fs)",
            " * to indicate a major problem.",
            " */",
            "#include <linux/debug_locks.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/delay.h>",
            "#include <linux/kexec.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/sched.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/console.h>",
            "#include <linux/bug.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/context_tracking.h>",
            "#include <trace/events/error_report.h>",
            "#include <asm/sections.h>",
            "",
            "#define PANIC_TIMER_STEP 100",
            "#define PANIC_BLINK_SPD 18",
            "",
            "#ifdef CONFIG_SMP",
            "/*",
            " * Should we dump all CPUs backtraces in an oops event?",
            " * Defaults to 0, can be changed via sysctl.",
            " */",
            "static unsigned int __read_mostly sysctl_oops_all_cpu_backtrace;",
            "#else",
            "#define sysctl_oops_all_cpu_backtrace 0",
            "#endif /* CONFIG_SMP */",
            "",
            "int panic_on_oops = CONFIG_PANIC_ON_OOPS_VALUE;",
            "static unsigned long tainted_mask =",
            "\tIS_ENABLED(CONFIG_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
            "static int pause_on_oops;",
            "static int pause_on_oops_flag;",
            "static DEFINE_SPINLOCK(pause_on_oops_lock);",
            "bool crash_kexec_post_notifiers;",
            "int panic_on_warn __read_mostly;",
            "unsigned long panic_on_taint;",
            "bool panic_on_taint_nousertaint = false;",
            "static unsigned int warn_limit __read_mostly;",
            "",
            "bool panic_triggering_all_cpu_backtrace;",
            "",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "EXPORT_SYMBOL_GPL(panic_timeout);",
            "",
            "#define PANIC_PRINT_TASK_INFO\t\t0x00000001",
            "#define PANIC_PRINT_MEM_INFO\t\t0x00000002",
            "#define PANIC_PRINT_TIMER_INFO\t\t0x00000004",
            "#define PANIC_PRINT_LOCK_INFO\t\t0x00000008",
            "#define PANIC_PRINT_FTRACE_INFO\t\t0x00000010",
            "#define PANIC_PRINT_ALL_PRINTK_MSG\t0x00000020",
            "#define PANIC_PRINT_ALL_CPU_BT\t\t0x00000040",
            "#define PANIC_PRINT_BLOCKED_TASKS\t0x00000080",
            "unsigned long panic_print;",
            "",
            "ATOMIC_NOTIFIER_HEAD(panic_notifier_list);",
            "",
            "EXPORT_SYMBOL(panic_notifier_list);",
            "",
            "#ifdef CONFIG_SYSCTL",
            "static struct ctl_table kern_panic_table[] = {",
            "#ifdef CONFIG_SMP",
            "\t{",
            "\t\t.procname       = \"oops_all_cpu_backtrace\",",
            "\t\t.data           = &sysctl_oops_all_cpu_backtrace,",
            "\t\t.maxlen         = sizeof(int),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = proc_dointvec_minmax,",
            "\t\t.extra1         = SYSCTL_ZERO,",
            "\t\t.extra2         = SYSCTL_ONE,",
            "\t},",
            "#endif",
            "\t{",
            "\t\t.procname       = \"warn_limit\",",
            "\t\t.data           = &warn_limit,",
            "\t\t.maxlen         = sizeof(warn_limit),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = proc_douintvec,",
            "\t},",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义内核恐慌相关全局变量和配置参数，初始化panic_timeout导出符号，声明panic_notifier_list通知链表，注册sysctl接口用于动态调整panic行为。",
          "similarity": 0.5547177791595459
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/panic.c",
          "start_line": 107,
          "end_line": 225,
          "content": [
            "static __init int kernel_panic_sysctls_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kern_panic_table);",
            "\treturn 0;",
            "}",
            "static ssize_t warn_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t       char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%d\\n\", atomic_read(&warn_count));",
            "}",
            "static __init int kernel_panic_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &warn_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "static long no_blink(int state)",
            "{",
            "\treturn 0;",
            "}",
            "void __weak __noreturn panic_smp_self_stop(void)",
            "{",
            "\twhile (1)",
            "\t\tcpu_relax();",
            "}",
            "void __weak __noreturn nmi_panic_self_stop(struct pt_regs *regs)",
            "{",
            "\tpanic_smp_self_stop();",
            "}",
            "void __weak crash_smp_send_stop(void)",
            "{",
            "\tstatic int cpus_stopped;",
            "",
            "\t/*",
            "\t * This function can be called twice in panic path, but obviously",
            "\t * we execute this only once.",
            "\t */",
            "\tif (cpus_stopped)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Note smp_send_stop is the usual smp shutdown function, which",
            "\t * unfortunately means it may not be hardened to work in a panic",
            "\t * situation.",
            "\t */",
            "\tsmp_send_stop();",
            "\tcpus_stopped = 1;",
            "}",
            "void nmi_panic(struct pt_regs *regs, const char *msg)",
            "{",
            "\tint old_cpu, cpu;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\told_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);",
            "",
            "\tif (old_cpu == PANIC_CPU_INVALID)",
            "\t\tpanic(\"%s\", msg);",
            "\telse if (old_cpu != cpu)",
            "\t\tnmi_panic_self_stop(regs);",
            "}",
            "static void panic_print_sys_info(bool console_flush)",
            "{",
            "\tif (console_flush) {",
            "\t\tif (panic_print & PANIC_PRINT_ALL_PRINTK_MSG)",
            "\t\t\tconsole_flush_on_panic(CONSOLE_REPLAY_ALL);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (panic_print & PANIC_PRINT_TASK_INFO)",
            "\t\tshow_state();",
            "",
            "\tif (panic_print & PANIC_PRINT_MEM_INFO)",
            "\t\tshow_mem();",
            "",
            "\tif (panic_print & PANIC_PRINT_TIMER_INFO)",
            "\t\tsysrq_timer_list_show();",
            "",
            "\tif (panic_print & PANIC_PRINT_LOCK_INFO)",
            "\t\tdebug_show_all_locks();",
            "",
            "\tif (panic_print & PANIC_PRINT_FTRACE_INFO)",
            "\t\tftrace_dump(DUMP_ALL);",
            "",
            "\tif (panic_print & PANIC_PRINT_BLOCKED_TASKS)",
            "\t\tshow_state_filter(TASK_UNINTERRUPTIBLE);",
            "}",
            "void check_panic_on_warn(const char *origin)",
            "{",
            "\tunsigned int limit;",
            "",
            "\tif (panic_on_warn)",
            "\t\tpanic(\"%s: panic_on_warn set ...\\n\", origin);",
            "",
            "\tlimit = READ_ONCE(warn_limit);",
            "\tif (atomic_inc_return(&warn_count) >= limit && limit)",
            "\t\tpanic(\"%s: system warned too often (kernel.warn_limit is %d)\",",
            "\t\t      origin, limit);",
            "}",
            "static void panic_other_cpus_shutdown(bool crash_kexec)",
            "{",
            "\tif (panic_print & PANIC_PRINT_ALL_CPU_BT) {",
            "\t\t/* Temporary allow non-panic CPUs to write their backtraces. */",
            "\t\tpanic_triggering_all_cpu_backtrace = true;",
            "\t\ttrigger_all_cpu_backtrace();",
            "\t\tpanic_triggering_all_cpu_backtrace = false;",
            "\t}",
            "",
            "\t/*",
            "\t * Note that smp_send_stop() is the usual SMP shutdown function,",
            "\t * which unfortunately may not be hardened to work in a panic",
            "\t * situation. If we want to do crash dump after notifier calls",
            "\t * and kmsg_dump, we will need architecture dependent extra",
            "\t * bits in addition to stopping other CPUs, hence we rely on",
            "\t * crash_smp_send_stop() for that.",
            "\t */",
            "\tif (!crash_kexec)",
            "\t\tsmp_send_stop();",
            "\telse",
            "\t\tcrash_smp_send_stop();",
            "}"
          ],
          "function_name": "kernel_panic_sysctls_init, warn_count_show, kernel_panic_sysfs_init, no_blink, panic_smp_self_stop, nmi_panic_self_stop, crash_smp_send_stop, nmi_panic, panic_print_sys_info, check_panic_on_warn, panic_other_cpus_shutdown",
          "description": "实现panic处理辅助函数，包括sysctl注册、NMI恐慌处理、多CPU停止逻辑、系统信息打印、警告计数检查及跨CPU shutdown操作。",
          "similarity": 0.5516332983970642
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/panic.c",
          "start_line": 730,
          "end_line": 821,
          "content": [
            "void warn_slowpath_fmt(const char *file, int line, unsigned taint,",
            "\t\t       const char *fmt, ...)",
            "{",
            "\tbool rcu = warn_rcu_enter();",
            "\tstruct warn_args args;",
            "",
            "\tpr_warn(CUT_HERE);",
            "",
            "\tif (!fmt) {",
            "\t\t__warn(file, line, __builtin_return_address(0), taint,",
            "\t\t       NULL, NULL);",
            "\t\twarn_rcu_exit(rcu);",
            "\t\treturn;",
            "\t}",
            "",
            "\targs.fmt = fmt;",
            "\tva_start(args.args, fmt);",
            "\t__warn(file, line, __builtin_return_address(0), taint, NULL, &args);",
            "\tva_end(args.args);",
            "\twarn_rcu_exit(rcu);",
            "}",
            "void __warn_printk(const char *fmt, ...)",
            "{",
            "\tbool rcu = warn_rcu_enter();",
            "\tva_list args;",
            "",
            "\tpr_warn(CUT_HERE);",
            "",
            "\tva_start(args, fmt);",
            "\tvprintk(fmt, args);",
            "\tva_end(args);",
            "\twarn_rcu_exit(rcu);",
            "}",
            "static int clear_warn_once_set(void *data, u64 val)",
            "{",
            "\tgeneric_bug_clear_once();",
            "\tmemset(__start_once, 0, __end_once - __start_once);",
            "\treturn 0;",
            "}",
            "static __init int register_warn_debugfs(void)",
            "{",
            "\t/* Don't care about failure */",
            "\tdebugfs_create_file_unsafe(\"clear_warn_once\", 0200, NULL, NULL,",
            "\t\t\t\t   &clear_warn_once_fops);",
            "\treturn 0;",
            "}",
            "__visible noinstr void __stack_chk_fail(void)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tinstrumentation_begin();",
            "\tflags = user_access_save();",
            "",
            "\tpanic(\"stack-protector: Kernel stack is corrupted in: %pB\",",
            "\t\t__builtin_return_address(0));",
            "",
            "\tuser_access_restore(flags);",
            "\tinstrumentation_end();",
            "}",
            "static int __init oops_setup(char *s)",
            "{",
            "\tif (!s)",
            "\t\treturn -EINVAL;",
            "\tif (!strcmp(s, \"panic\"))",
            "\t\tpanic_on_oops = 1;",
            "\treturn 0;",
            "}",
            "static int __init panic_on_taint_setup(char *s)",
            "{",
            "\tchar *taint_str;",
            "",
            "\tif (!s)",
            "\t\treturn -EINVAL;",
            "",
            "\ttaint_str = strsep(&s, \",\");",
            "\tif (kstrtoul(taint_str, 16, &panic_on_taint))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* make sure panic_on_taint doesn't hold out-of-range TAINT flags */",
            "\tpanic_on_taint &= TAINT_FLAGS_MAX;",
            "",
            "\tif (!panic_on_taint)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (s && !strcmp(s, \"nousertaint\"))",
            "\t\tpanic_on_taint_nousertaint = true;",
            "",
            "\tpr_info(\"panic_on_taint: bitmask=0x%lx nousertaint_mode=%s\\n\",",
            "\t\tpanic_on_taint, str_enabled_disabled(panic_on_taint_nousertaint));",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "warn_slowpath_fmt, __warn_printk, clear_warn_once_set, register_warn_debugfs, __stack_chk_fail, oops_setup, panic_on_taint_setup",
          "description": "实现运行时警告处理机制，包含栈保护校验失败处理、Oops配置参数解析、警告信息格式化输出及调试文件系统注册等功能模块。",
          "similarity": 0.5134953260421753
        }
      ]
    },
    {
      "source_file": "kernel/freezer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:30:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `freezer.c`\n\n---\n\n# freezer.c 技术文档\n\n## 文件概述\n\n`freezer.c` 是 Linux 内核中实现任务冻结（freezing）机制的核心文件，用于在系统挂起（suspend）、休眠（hibernation）或 cgroup freezer 控制等场景下，将用户空间进程和部分内核线程临时挂起（冻结），使其进入 `TASK_FROZEN` 状态，从而确保系统状态一致性。该机制允许内核在不终止进程的情况下暂停其执行，并在系统恢复时安全地唤醒它们。\n\n## 核心功能\n\n### 全局变量\n- `freezer_active`：静态键（static key），表示当前是否有冻结条件生效，用于快速路径判断。\n- `pm_freezing`：布尔值，表示电源管理（PM）冻结是否生效（受 `system_transition_mutex` 保护）。\n- `pm_nosig_freezing`：布尔值，表示是否启用无信号冻结模式（通常用于 cgroup freezer）。\n- `freezer_lock`：自旋锁，保护冻结/解冻状态转换的原子性。\n\n### 主要函数\n- `freezing_slow_path(struct task_struct *p)`：冻结慢路径判断函数，决定任务是否应被冻结。\n- `frozen(struct task_struct *p)`：检查任务是否已处于冻结状态。\n- `__refrigerator(bool check_kthr_stop)`：任务进入“冰箱”（冻结等待循环）的主函数。\n- `__set_task_frozen(struct task_struct *p, void *arg)`：将可冻结任务的状态切换为 `TASK_FROZEN`。\n- `__freeze_task(struct task_struct *p)`：尝试冻结指定任务。\n- `freeze_task(struct task_struct *p)`：向任务发送冻结请求，必要时唤醒以进入冻结状态。\n- `__restore_freezer_state(struct task_struct *p, void *arg)`：恢复任务冻结前的状态。\n- `__thaw_task(struct task_struct *p)`：解冻指定任务。\n- `set_freezable(void)`：将当前任务标记为可冻结，并尝试立即冻结。\n\n## 关键实现\n\n### 冻结判断逻辑\n`freezing_slow_path()` 是冻结判断的核心逻辑：\n- 排除设置了 `PF_NOFREEZE`（不可冻结）或 `PF_SUSPEND_TASK`（挂起专用任务）的进程。\n- 排除正在处理内存回收（`TIF_MEMDIE`）的任务。\n- 若 `pm_nosig_freezing` 为真（如 cgroup freezer 场景）或任务属于冻结 cgroup，则应冻结。\n- 若 `pm_freezing` 为真且任务不是内核线程（`PF_KTHREAD`），则应冻结。\n\n### 冻结状态管理\n- 任务状态通过 `task_struct->__state` 字段管理，冻结状态为 `TASK_FROZEN`。\n- `saved_state` 字段用于保存冻结前的原始状态，以便解冻时恢复。\n- 使用 `WRITE_ONCE()` 和 `READ_ONCE()` 确保状态读写的原子性和内存序。\n\n### 冻结唤醒机制\n- 用户空间任务通过 `fake_signal_wake_up()` 发送伪信号（调用 `signal_wake_up()`）促使其进入冻结。\n- 内核线程通过 `wake_up_state(p, TASK_NORMAL)` 唤醒，使其在调度循环中检测冻结条件并进入 `__refrigerator()`。\n\n### 冻结安全检查\n- 在 `__set_task_frozen()` 中，通过 `WARN_ON_ONCE()` 检查：\n  - 只有 `TASK_NORMAL` 状态的任务可被标记为 `TASK_FREEZABLE`。\n  - 若启用了 `CONFIG_LOCKDEP`，则警告在持有锁的情况下冻结任务（可能导致死锁）。\n\n### 冻结/解冻原子性\n- 所有状态转换均在 `freezer_lock` 保护下进行，确保并发安全。\n- `__thaw_task()` 在解冻时先尝试恢复原始状态，若失败（如任务已在运行）则显式唤醒 `TASK_FROZEN` 状态的任务。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/freezer.h>`：提供冻结相关的宏和函数声明。\n  - `<linux/suspend.h>`：与电源管理挂起机制集成。\n  - `<linux/cgroup.h>`（隐式）：通过 `cgroup_freezing()` 与 cgroup freezer 子系统交互。\n  - `<linux/kthread.h>`：处理内核线程的特殊冻结逻辑（如 `kthread_should_stop()`）。\n- **内核子系统**：\n  - **电源管理（PM）**：系统挂起/休眠时触发全局冻结。\n  - **cgroup freezer**：通过 cgroup 接口对任务组进行冻结控制。\n  - **调度器（Scheduler）**：依赖 `task_call_func()`、`wake_up_state()` 等调度接口操作任务状态。\n  - **信号子系统**：通过 `signal_wake_up()` 唤醒用户空间任务。\n\n## 使用场景\n\n1. **系统挂起/休眠**：\n   - 在进入 suspend/hibernation 前，内核设置 `pm_freezing = true` 并冻结所有用户空间进程，确保系统状态一致。\n   - 恢复时调用 `__thaw_task()` 解冻任务。\n\n2. **cgroup freezer 控制**：\n   - 用户通过写入 cgroup 的 `freezer.state` 文件冻结/解冻任务组。\n   - 触发 `pm_nosig_freezing = true`，使用无信号方式冻结任务。\n\n3. **内核线程协作冻结**：\n   - 可冻结的内核线程需定期调用 `try_to_freeze()` 或 `set_freezable()`。\n   - 在 `__refrigerator()` 中循环等待冻结条件解除。\n\n4. **内存回收（OOM）保护**：\n   - 正在处理 OOM 的任务（`TIF_MEMDIE`）被排除在冻结之外，避免干扰关键内存回收流程。\n\n5. **驱动/子系统集成**：\n   - 驱动在 suspend 回调中可依赖冻结机制确保用户空间无活动 I/O。\n   - 文件系统、网络栈等子系统在冻结期间暂停用户请求处理。",
      "similarity": 0.6311847567558289,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/freezer.c",
          "start_line": 38,
          "end_line": 142,
          "content": [
            "bool freezing_slow_path(struct task_struct *p)",
            "{",
            "\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))",
            "\t\treturn false;",
            "",
            "\tif (test_tsk_thread_flag(p, TIF_MEMDIE))",
            "\t\treturn false;",
            "",
            "\tif (pm_nosig_freezing || cgroup_freezing(p))",
            "\t\treturn true;",
            "",
            "\tif (pm_freezing && !(p->flags & PF_KTHREAD))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "bool frozen(struct task_struct *p)",
            "{",
            "\treturn READ_ONCE(p->__state) & TASK_FROZEN;",
            "}",
            "bool __refrigerator(bool check_kthr_stop)",
            "{",
            "\tunsigned int state = get_current_state();",
            "\tbool was_frozen = false;",
            "",
            "\tpr_debug(\"%s entered refrigerator\\n\", current->comm);",
            "",
            "\tWARN_ON_ONCE(state && !(state & TASK_NORMAL));",
            "",
            "\tfor (;;) {",
            "\t\tbool freeze;",
            "",
            "\t\traw_spin_lock_irq(&current->pi_lock);",
            "\t\tWRITE_ONCE(current->__state, TASK_FROZEN);",
            "\t\t/* unstale saved_state so that __thaw_task() will wake us up */",
            "\t\tcurrent->saved_state = TASK_RUNNING;",
            "\t\traw_spin_unlock_irq(&current->pi_lock);",
            "",
            "\t\tspin_lock_irq(&freezer_lock);",
            "\t\tfreeze = freezing(current) && !(check_kthr_stop && kthread_should_stop());",
            "\t\tspin_unlock_irq(&freezer_lock);",
            "",
            "\t\tif (!freeze)",
            "\t\t\tbreak;",
            "",
            "\t\twas_frozen = true;",
            "\t\tschedule();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tpr_debug(\"%s left refrigerator\\n\", current->comm);",
            "",
            "\treturn was_frozen;",
            "}",
            "static void fake_signal_wake_up(struct task_struct *p)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (lock_task_sighand(p, &flags)) {",
            "\t\tsignal_wake_up(p, 0);",
            "\t\tunlock_task_sighand(p, &flags);",
            "\t}",
            "}",
            "static int __set_task_frozen(struct task_struct *p, void *arg)",
            "{",
            "\tunsigned int state = READ_ONCE(p->__state);",
            "",
            "\t/*",
            "\t * Allow freezing the sched_delayed tasks; they will not execute until",
            "\t * ttwu() fixes them up, so it is safe to swap their state now, instead",
            "\t * of waiting for them to get fully dequeued.",
            "\t */",
            "\tif (task_is_runnable(p))",
            "\t\treturn 0;",
            "",
            "\tif (p != current && task_curr(p))",
            "\t\treturn 0;",
            "",
            "\tif (!(state & (TASK_FREEZABLE | __TASK_STOPPED | __TASK_TRACED)))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * Only TASK_NORMAL can be augmented with TASK_FREEZABLE, since they",
            "\t * can suffer spurious wakeups.",
            "\t */",
            "\tif (state & TASK_FREEZABLE)",
            "\t\tWARN_ON_ONCE(!(state & TASK_NORMAL));",
            "",
            "#ifdef CONFIG_LOCKDEP",
            "\t/*",
            "\t * It's dangerous to freeze with locks held; there be dragons there.",
            "\t */",
            "\tif (!(state & __TASK_FREEZABLE_UNSAFE))",
            "\t\tWARN_ON_ONCE(debug_locks && p->lockdep_depth);",
            "#endif",
            "",
            "\tp->saved_state = p->__state;",
            "\tWRITE_ONCE(p->__state, TASK_FROZEN);",
            "\treturn TASK_FROZEN;",
            "}",
            "static bool __freeze_task(struct task_struct *p)",
            "{",
            "\t/* TASK_FREEZABLE|TASK_STOPPED|TASK_TRACED -> TASK_FROZEN */",
            "\treturn task_call_func(p, __set_task_frozen, NULL);",
            "}"
          ],
          "function_name": "freezing_slow_path, frozen, __refrigerator, fake_signal_wake_up, __set_task_frozen, __freeze_task",
          "description": "实现冻结路径核心逻辑，包含判断任务是否可冻结的slow_path函数、检测任务冻结状态的frozen函数、通过__refrigerator将当前任务置入冻结状态并循环等待解冻的机制，以及设置任务冻结状态和模拟信号唤醒的辅助函数。",
          "similarity": 0.5315389037132263
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/freezer.c",
          "start_line": 1,
          "end_line": 37,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * kernel/freezer.c - Function to freeze a process",
            " *",
            " * Originally from kernel/power/process.c",
            " */",
            "",
            "#include <linux/interrupt.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "",
            "/* total number of freezing conditions in effect */",
            "DEFINE_STATIC_KEY_FALSE(freezer_active);",
            "EXPORT_SYMBOL(freezer_active);",
            "",
            "/*",
            " * indicate whether PM freezing is in effect, protected by",
            " * system_transition_mutex",
            " */",
            "bool pm_freezing;",
            "bool pm_nosig_freezing;",
            "",
            "/* protects freezing and frozen transitions */",
            "static DEFINE_SPINLOCK(freezer_lock);",
            "",
            "/**",
            " * freezing_slow_path - slow path for testing whether a task needs to be frozen",
            " * @p: task to be tested",
            " *",
            " * This function is called by freezing() if freezer_active isn't zero",
            " * and tests whether @p needs to enter and stay in frozen state.  Can be",
            " * called under any context.  The freezers are responsible for ensuring the",
            " * target tasks see the updated state.",
            " */"
          ],
          "function_name": null,
          "description": "定义了与进程冻结相关的全局变量和锁，包括标记冻结活动状态的静态键、PM冻结标志位及自旋锁。声明了freezing_slow_path函数原型，用于判断任务是否需进入冻结状态。",
          "similarity": 0.5061954259872437
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/freezer.c",
          "start_line": 163,
          "end_line": 213,
          "content": [
            "bool freeze_task(struct task_struct *p)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&freezer_lock, flags);",
            "\tif (!freezing(p) || frozen(p) || __freeze_task(p)) {",
            "\t\tspin_unlock_irqrestore(&freezer_lock, flags);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (!(p->flags & PF_KTHREAD))",
            "\t\tfake_signal_wake_up(p);",
            "\telse",
            "\t\twake_up_state(p, TASK_NORMAL);",
            "",
            "\tspin_unlock_irqrestore(&freezer_lock, flags);",
            "\treturn true;",
            "}",
            "static int __restore_freezer_state(struct task_struct *p, void *arg)",
            "{",
            "\tunsigned int state = p->saved_state;",
            "",
            "\tif (state != TASK_RUNNING) {",
            "\t\tWRITE_ONCE(p->__state, state);",
            "\t\tp->saved_state = TASK_RUNNING;",
            "\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __thaw_task(struct task_struct *p)",
            "{",
            "\tguard(spinlock_irqsave)(&freezer_lock);",
            "\tif (frozen(p) && !task_call_func(p, __restore_freezer_state, NULL))",
            "\t\twake_up_state(p, TASK_FROZEN);",
            "}",
            "bool set_freezable(void)",
            "{",
            "\tmight_sleep();",
            "",
            "\t/*",
            "\t * Modify flags while holding freezer_lock.  This ensures the",
            "\t * freezer notices that we aren't frozen yet or the freezing",
            "\t * condition is visible to try_to_freeze() below.",
            "\t */",
            "\tspin_lock_irq(&freezer_lock);",
            "\tcurrent->flags &= ~PF_NOFREEZE;",
            "\tspin_unlock_irq(&freezer_lock);",
            "",
            "\treturn try_to_freeze();",
            "}"
          ],
          "function_name": "freeze_task, __restore_freezer_state, __thaw_task, set_freezable",
          "description": "提供冻结任务接口freeze_task，通过__restore_freezer_state恢复保存状态并唤醒任务的__thaw_task函数，以及set_freezable函数用于标记当前任务可冻结并尝试触发冻结操作。所有操作均通过freezer_lock进行同步保护。",
          "similarity": 0.46996814012527466
        }
      ]
    }
  ]
}