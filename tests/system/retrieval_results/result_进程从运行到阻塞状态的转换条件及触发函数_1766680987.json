{
  "query": "进程从运行到阻塞状态的转换条件及触发函数",
  "timestamp": "2025-12-26 00:43:07",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/stop_task.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:17:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\stop_task.c`\n\n---\n\n# `sched/stop_task.c` 技术文档\n\n## 1. 文件概述\n\n`sched/stop_task.c` 实现了 Linux 内核调度器中的 **stop 调度类（stop scheduling class）**。该调度类用于管理 per-CPU 的 **stop 任务（stop task）**，这些任务具有系统中最高的调度优先级，能够抢占所有其他任务，且自身不会被任何任务抢占。stop 任务主要用于需要在所有 CPU 上立即停止常规调度活动的场景，例如 CPU 热插拔、内核模块卸载或 `stop_machine()` 机制执行期间。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `select_task_rq_stop()`：在 SMP 系统中，确保 stop 任务始终运行在其初始 CPU 上，禁止迁移。\n- `balance_stop()`：在负载均衡时判断当前运行队列上是否有可运行的 stop 任务。\n- `wakeup_preempt_stop()`：空实现，因为 stop 任务不会被抢占。\n- `set_next_task_stop()`：设置下一个运行的 stop 任务，并记录其执行起始时间。\n- `pick_task_stop()`：从运行队列中选择 stop 任务（如果存在且可运行）。\n- `enqueue_task_stop()` / `dequeue_task_stop()`：将 stop 任务加入/移出运行队列，并更新运行任务计数。\n- `yield_task_stop()`：触发 `BUG()`，因为 stop 任务绝不应主动让出 CPU。\n- `put_prev_task_stop()`：在切换出 stop 任务时更新其运行统计（调用通用更新函数）。\n- `task_tick_stop()`：空实现，stop 任务不受调度 tick 影响。\n- `switched_to_stop()` / `prio_changed_stop()`：均触发 `BUG()`，因为任务不能动态切换到 stop 调度类，也无优先级概念。\n- `update_curr_stop()`：空实现，stop 任务不参与常规的运行时间更新逻辑。\n\n### 数据结构\n\n- `DEFINE_SCHED_CLASS(stop)`：定义并初始化名为 `stop` 的调度类实例，实现了 `struct sched_class` 接口的所有必要回调函数。\n\n## 3. 关键实现\n\n- **最高优先级保证**：stop 调度类在调度类层级中位于最顶端（高于 `rt`、`fair`、`idle`），确保其任务总是优先获得 CPU。\n- **禁止迁移**：在 `CONFIG_SMP` 下，`select_task_rq_stop()` 强制 stop 任务绑定到其创建时的 CPU，防止跨 CPU 迁移，保证操作的局部性和确定性。\n- **无抢占逻辑**：所有与抢占相关的函数（如 `wakeup_preempt_stop`）均为空或触发错误，因为 stop 任务运行期间系统处于“停止”状态，不应被中断。\n- **错误防护机制**：任何试图动态切换到 stop 调度类、修改其优先级或主动让出 CPU 的行为都会触发 `BUG()`，防止误用。\n- **轻量级统计**：虽然调用 `update_curr_common()` 更新运行时间，但 `update_curr_stop()` 本身为空，表明 stop 任务不参与复杂的调度实体（`sched_entity`）时间计算。\n- **与 `stop_machine` 协同**：该文件与 `kernel/stop_machine.c` 紧密配合，为 `stop_machine()` 提供底层调度支持，确保在所有 CPU 上同步执行关键操作。\n\n## 4. 依赖关系\n\n- **调度核心**：依赖 `kernel/sched/core.c` 中定义的调度类框架、运行队列（`rq`）结构和通用辅助函数（如 `add_nr_running`、`update_curr_common`）。\n- **SMP 支持**：在 `CONFIG_SMP` 编译选项下，依赖 `kernel/sched/sched.h` 中的 `set_cpus_allowed_common` 函数。\n- **Stop Machine 机制**：与 `kernel/stop_machine.c` 深度集成，后者负责创建和管理 per-CPU stop 任务，并触发其执行。\n- **时间子系统**：使用 `rq_clock_task()` 获取任务执行时间戳，依赖内核时间管理基础设施。\n\n## 5. 使用场景\n\n- **`stop_machine()` 执行**：当内核需要在所有在线 CPU 上同步执行一段不能被中断的代码时（如修改全局数据结构、CPU 热插拔），会激活所有 CPU 的 stop 任务。\n- **CPU 热插拔**：在 CPU 上线或下线过程中，使用 stop 任务确保目标 CPU 处于可控状态，避免调度干扰。\n- **内核关键路径保护**：在极少数需要完全禁止调度器干预的内核关键操作中，临时启用 stop 任务以获得独占 CPU 的能力。\n- **调试与诊断**：某些内核调试机制可能利用 stop 任务来冻结系统状态进行分析。",
      "similarity": 0.6139005422592163,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 12,
          "end_line": 64,
          "content": [
            "static int",
            "select_task_rq_stop(struct task_struct *p, int cpu, int flags)",
            "{",
            "\treturn task_cpu(p); /* stop tasks as never migrate */",
            "}",
            "static int",
            "balance_stop(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)",
            "{",
            "\treturn sched_stop_runnable(rq);",
            "}",
            "static void",
            "wakeup_preempt_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\t/* we're never preempted */",
            "}",
            "static void set_next_task_stop(struct rq *rq, struct task_struct *stop, bool first)",
            "{",
            "\tstop->se.exec_start = rq_clock_task(rq);",
            "}",
            "static void",
            "enqueue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tadd_nr_running(rq, 1);",
            "}",
            "static bool",
            "dequeue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tsub_nr_running(rq, 1);",
            "\treturn true;",
            "}",
            "static void yield_task_stop(struct rq *rq)",
            "{",
            "\tBUG(); /* the stop task should never yield, its pointless. */",
            "}",
            "static void put_prev_task_stop(struct rq *rq, struct task_struct *prev, struct task_struct *next)",
            "{",
            "\tupdate_curr_common(rq);",
            "}",
            "static void task_tick_stop(struct rq *rq, struct task_struct *curr, int queued)",
            "{",
            "}",
            "static void switched_to_stop(struct rq *rq, struct task_struct *p)",
            "{",
            "\tBUG(); /* its impossible to change to this class */",
            "}",
            "static void",
            "prio_changed_stop(struct rq *rq, struct task_struct *p, int oldprio)",
            "{",
            "\tBUG(); /* how!?, what priority? */",
            "}",
            "static void update_curr_stop(struct rq *rq)",
            "{",
            "}"
          ],
          "function_name": "select_task_rq_stop, balance_stop, wakeup_preempt_stop, set_next_task_stop, enqueue_task_stop, dequeue_task_stop, yield_task_stop, put_prev_task_stop, task_tick_stop, switched_to_stop, prio_changed_stop, update_curr_stop",
          "description": "实现stop任务调度类的核心操作，包括CPU选择、负载均衡、抢占唤醒、任务添加删除、时间统计更新等，强制禁止任务迁移和抢占以保证系统中断处理优先级",
          "similarity": 0.5833749771118164
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * stop-task scheduling class.",
            " *",
            " * The stop task is the highest priority task in the system, it preempts",
            " * everything and will be preempted by nothing.",
            " *",
            " * See kernel/stop_machine.c",
            " */",
            "",
            "#ifdef CONFIG_SMP"
          ],
          "function_name": null,
          "description": "定义stop任务调度类的框架，启用SMP配置时提供最高优先级调度策略，通过禁用任务迁移和抢占实现系统级中断控制",
          "similarity": 0.5741194486618042
        }
      ]
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5939301252365112,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.6155964136123657
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5612813234329224
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.5000016689300537
        }
      ]
    },
    {
      "source_file": "kernel/task_work.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:33:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `task_work.c`\n\n---\n\n# task_work.c 技术文档\n\n## 文件概述\n\n`task_work.c` 实现了 Linux 内核中的 **任务工作（task work）机制**，允许内核在特定时机（如任务返回用户态、收到信号或处于 NMI 上下文）异步执行回调函数。该机制主要用于在不阻塞当前执行路径的前提下，将工作延迟到目标任务的合适上下文中执行，常用于安全模块（如 seccomp）、用户态通知、延迟清理等场景。\n\n任务工作队列是 **LIFO（后进先出）** 的，且不保证多个工作项之间的执行顺序。该机制支持多种通知模式，以适应不同的延迟和中断需求。\n\n## 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `task_work_add()` | 向指定任务添加一个回调工作项，并根据通知模式触发相应通知 |\n| `task_work_run()` | 执行当前任务的所有挂起工作项，通常在返回用户态或任务退出前调用 |\n| `task_work_cancel_match()` | 根据自定义匹配函数取消队列中的某个工作项 |\n| `task_work_cancel_func()` | 取消队列中第一个函数指针匹配指定函数的工作项 |\n| `task_work_cancel()` | 取消队列中指定的回调结构体（精确匹配指针） |\n\n### 主要数据结构\n\n- `struct callback_head`：通用回调结构体，包含 `next` 指针和 `func` 回调函数指针。\n- `enum task_work_notify_mode`：通知模式枚举，包括：\n  - `TWA_NONE`：不通知\n  - `TWA_RESUME`：在任务返回用户态或进入 guest 模式前执行\n  - `TWA_SIGNAL`：类似信号，可中断内核态任务并立即调度执行\n  - `TWA_SIGNAL_NO_IPI`：类似 `TWA_SIGNAL`，但不发送 IPI 强制重调度\n  - `TWA_NMI_CURRENT`：仅用于当前任务且在 NMI 上下文中，通过 IRQ work 触发\n\n### 全局变量\n\n- `work_exited`：特殊标记，表示任务已退出，不能再接受新工作。\n- `irq_work_NMI_resume`（per-CPU）：用于 `TWA_NMI_CURRENT` 模式下触发 `TIF_NOTIFY_RESUME` 标志。\n\n## 关键实现\n\n### 1. 无锁队列插入（LIFO）\n\n`task_work_add()` 使用 `try_cmpxchg()` 原子操作将新工作项插入到 `task->task_works` 链表头部，实现无锁并发插入。若发现 `task_works == &work_exited`，说明任务正在退出，返回 `-ESRCH`。\n\n### 2. 多种通知机制\n\n- **`TWA_RESUME`**：调用 `set_notify_resume(task)`，设置 `TIF_NOTIFY_RESUME` 标志，确保任务在 `exit_to_user_mode()` 路径中调用 `task_work_run()`。\n- **`TWA_SIGNAL` / `TWA_SIGNAL_NO_IPI`**：分别调用 `set_notify_signal()` 和 `__set_notify_signal()`，设置 `TIF_NOTIFY_SIGNAL` 标志，并可能发送 IPI 强制目标 CPU 重调度。\n- **`TWA_NMI_CURRENT`**：在 NMI 上下文中，通过 per-CPU 的 `irq_work` 触发软中断，在 IRQ 上下文中设置 `TIF_NOTIFY_RESUME`。\n\n### 3. 安全退出处理\n\n`task_work_run()` 在循环中：\n- 原子地将 `task_works` 置为 `NULL`（或 `&work_exited`，若任务正在退出）。\n- 若任务正在退出（`PF_EXITING`），则标记为 `work_exited`，防止后续 `task_work_add()` 成功。\n- 执行所有取出的工作项，每个 `work->func(work)` 可能再次调用 `task_work_add()`，因此需循环处理。\n\n### 4. 并发取消机制\n\n`task_work_cancel_match()` 使用 `task->pi_lock` 保护遍历和删除操作：\n- 遍历链表查找匹配项。\n- 使用 `try_cmpxchg()` 原子地移除节点，避免与 `task_work_add()` 或 `task_work_run()` 冲突。\n- 特别地，`task_work_run()` 在执行前会短暂获取 `pi_lock`，确保取消操作不会在执行过程中移除正在运行的工作项。\n\n### 5. KASAN 辅助栈记录\n\n在 `task_work_add()` 中，根据 `TWAF_NO_ALLOC` 标志调用 `kasan_record_aux_stack()` 或 `kasan_record_aux_stack_noalloc()`，用于在 KASAN 报告中显示工作项的分配调用栈。\n\n## 依赖关系\n\n- **`<linux/irq_work.h>`**：提供 `irq_work` 机制，用于 `TWA_NMI_CURRENT` 模式。\n- **`<linux/resume_user_mode.h>`**：提供 `set_notify_resume()` 等接口，用于在返回用户态时触发回调。\n- **`<linux/spinlock.h>`**：使用 `raw_spinlock_t`（`pi_lock`）保护取消操作。\n- **`<linux/task_work.h>`**：定义 `task_work_notify_mode`、`callback_head` 等核心类型。\n- **调度子系统**：依赖 `TIF_NOTIFY_RESUME` / `TIF_NOTIFY_SIGNAL` 标志位，在调度路径中调用 `task_work_run()`。\n- **KASAN**：集成内存错误检测的调用栈记录功能。\n\n## 使用场景\n\n1. **Seccomp 通知**：当 seccomp 策略需要异步通知用户态代理时，通过 `task_work_add()` 添加回调。\n2. **用户态延迟操作**：内核模块需要在任务下次返回用户态时执行清理或通知，使用 `TWA_RESUME`。\n3. **NMI 上下文延迟处理**：在不可睡眠的 NMI 处理程序中，通过 `TWA_NMI_CURRENT` 安全地安排后续工作。\n4. **信号式中断执行**：需要立即中断目标任务（即使在内核态）以执行高优先级工作，使用 `TWA_SIGNAL`。\n5. **资源回收**：在任务退出路径中，确保所有挂起工作被执行或清理。\n6. **动态取消机制**：如 seccomp 可能需要在条件变化时取消之前安排的工作，使用 `task_work_cancel_func()`。",
      "similarity": 0.5821064710617065,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/task_work.c",
          "start_line": 1,
          "end_line": 9,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/task_work.h>",
            "#include <linux/resume_user_mode.h>",
            "",
            "static struct callback_head work_exited; /* all we need is ->next == NULL */",
            "",
            "#ifdef CONFIG_IRQ_WORK"
          ],
          "function_name": null,
          "description": "声明用于任务工作通知的静态变量work_exited，该变量通过next指针判断任务工作链表是否为空，上下文不完整",
          "similarity": 0.5256614685058594
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/task_work.c",
          "start_line": 10,
          "end_line": 125,
          "content": [
            "static void task_work_set_notify_irq(struct irq_work *entry)",
            "{",
            "\ttest_and_set_tsk_thread_flag(current, TIF_NOTIFY_RESUME);",
            "}",
            "int task_work_add(struct task_struct *task, struct callback_head *work,",
            "\t\t  enum task_work_notify_mode notify)",
            "{",
            "\tstruct callback_head *head;",
            "\tint flags = notify & TWA_FLAGS;",
            "",
            "\tnotify &= ~TWA_FLAGS;",
            "\tif (notify == TWA_NMI_CURRENT) {",
            "\t\tif (WARN_ON_ONCE(task != current))",
            "\t\t\treturn -EINVAL;",
            "\t\tif (!IS_ENABLED(CONFIG_IRQ_WORK))",
            "\t\t\treturn -EINVAL;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Record the work call stack in order to print it in KASAN",
            "\t\t * reports.",
            "\t\t *",
            "\t\t * Note that stack allocation can fail if TWAF_NO_ALLOC flag",
            "\t\t * is set and new page is needed to expand the stack buffer.",
            "\t\t */",
            "\t\tif (flags & TWAF_NO_ALLOC)",
            "\t\t\tkasan_record_aux_stack_noalloc(work);",
            "\t\telse",
            "\t\t\tkasan_record_aux_stack(work);",
            "\t}",
            "",
            "\thead = READ_ONCE(task->task_works);",
            "\tdo {",
            "\t\tif (unlikely(head == &work_exited))",
            "\t\t\treturn -ESRCH;",
            "\t\twork->next = head;",
            "\t} while (!try_cmpxchg(&task->task_works, &head, work));",
            "",
            "\tswitch (notify) {",
            "\tcase TWA_NONE:",
            "\t\tbreak;",
            "\tcase TWA_RESUME:",
            "\t\tset_notify_resume(task);",
            "\t\tbreak;",
            "\tcase TWA_SIGNAL:",
            "\t\tset_notify_signal(task);",
            "\t\tbreak;",
            "\tcase TWA_SIGNAL_NO_IPI:",
            "\t\t__set_notify_signal(task);",
            "\t\tbreak;",
            "#ifdef CONFIG_IRQ_WORK",
            "\tcase TWA_NMI_CURRENT:",
            "\t\tirq_work_queue(this_cpu_ptr(&irq_work_NMI_resume));",
            "\t\tbreak;",
            "#endif",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static bool task_work_func_match(struct callback_head *cb, void *data)",
            "{",
            "\treturn cb->func == data;",
            "}",
            "static bool task_work_match(struct callback_head *cb, void *data)",
            "{",
            "\treturn cb == data;",
            "}",
            "bool task_work_cancel(struct task_struct *task, struct callback_head *cb)",
            "{",
            "\tstruct callback_head *ret;",
            "",
            "\tret = task_work_cancel_match(task, task_work_match, cb);",
            "",
            "\treturn ret == cb;",
            "}",
            "void task_work_run(void)",
            "{",
            "\tstruct task_struct *task = current;",
            "\tstruct callback_head *work, *head, *next;",
            "",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * work->func() can do task_work_add(), do not set",
            "\t\t * work_exited unless the list is empty.",
            "\t\t */",
            "\t\twork = READ_ONCE(task->task_works);",
            "\t\tdo {",
            "\t\t\thead = NULL;",
            "\t\t\tif (!work) {",
            "\t\t\t\tif (task->flags & PF_EXITING)",
            "\t\t\t\t\thead = &work_exited;",
            "\t\t\t\telse",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t} while (!try_cmpxchg(&task->task_works, &work, head));",
            "",
            "\t\tif (!work)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * Synchronize with task_work_cancel_match(). It can not remove",
            "\t\t * the first entry == work, cmpxchg(task_works) must fail.",
            "\t\t * But it can remove another entry from the ->next list.",
            "\t\t */",
            "\t\traw_spin_lock_irq(&task->pi_lock);",
            "\t\traw_spin_unlock_irq(&task->pi_lock);",
            "",
            "\t\tdo {",
            "\t\t\tnext = work->next;",
            "\t\t\twork->func(work);",
            "\t\t\twork = next;",
            "\t\t\tcond_resched();",
            "\t\t} while (work);",
            "\t}",
            "}"
          ],
          "function_name": "task_work_set_notify_irq, task_work_add, task_work_func_match, task_work_match, task_work_cancel, task_work_run",
          "description": "实现任务工作队列的添加、匹配、取消及执行逻辑，支持多种通知模式（如RESUME/SIGNAL/NMI），通过原子操作维护链表并同步执行回调函数",
          "similarity": 0.5183180570602417
        }
      ]
    }
  ]
}