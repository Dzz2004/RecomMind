{
  "query": "写回与写直达在BPF程序中的应用",
  "timestamp": "2025-12-26 01:46:39",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/btf.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:03:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\btf.c`\n\n---\n\n# `bpf/btf.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/btf.c` 是 Linux 内核中实现 **BPF Type Format (BTF)** 核心功能的源文件。BTF 是一种用于描述 BPF 程序和映射（map）中数据类型的元数据格式，本质上是对 C 语言类型系统的紧凑二进制编码。该文件负责 BTF 数据的解析、验证、内存管理、引用计数、ID 分配以及与 BPF 子系统（如验证器、结构体操作、kfunc 调用等）的集成。BTF 使得 BPF 程序能够进行类型安全检查、CO-RE（Compile Once – Run Everywhere）重定位，并支持高级调试和内省功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct btf`**  \n  BTF 对象的核心结构体，包含：\n  - 原始 BTF 数据 (`data`, `nohdr_data`)\n  - 解析后的类型指针数组 (`types`)\n  - 已解析类型的 ID 和大小缓存 (`resolved_ids`, `resolved_sizes`)\n  - 字符串表指针 (`strings`)\n  - BTF 头部信息 (`hdr`)\n  - 类型数量、数据大小等元信息\n  - 引用计数 (`refcnt`) 和 RCU 回收机制 (`rcu`)\n  - kfunc 集合表 (`kfunc_set_tab`)\n  - 析构函数表 (`dtor_kfunc_tab`)\n  - 结构体操作描述符表 (`struct_ops` 相关字段，代码截断)\n\n- **`struct btf_kfunc_set_tab`**  \n  管理不同 BPF 钩子上下文（如 XDP、TC、Tracing 等）下允许调用的内核函数（kfunc）集合。\n\n- **`struct btf_id_dtor_kfunc_tab`**  \n  存储与特定类型关联的析构函数（destructor kfunc），用于资源自动清理。\n\n- **`enum btf_kfunc_hook`**  \n  定义 BPF 程序可挂载的不同执行上下文类型，用于 kfunc 权限控制。\n\n- **`DEFINE_IDR(btf_idr)` 和 `btf_idr_lock`**  \n  全局 IDR（Integer ID Allocator）用于为每个加载的 BTF 对象分配唯一 ID，并配合自旋锁保证并发安全。\n\n### 关键宏定义\n\n- **BTF 验证与布局宏**  \n  - `BTF_MAX_SIZE`: BTF 数据最大允许大小（16MB）\n  - `BTF_TYPE_ID_VALID`, `BTF_STR_OFFSET_VALID`: 类型 ID 和字符串偏移合法性检查\n  - `BITS_ROUNDUP_BYTES` 等：位宽与字节转换工具\n\n- **遍历宏**  \n  - `for_each_member_from`: 遍历结构体/联合体成员\n  - `for_each_vsi_from`: 遍历变量段信息（Variable Section Info）\n\n## 3. 关键实现\n\n### BTF 验证两阶段模型\n\n- **第一阶段（收集与初步验证）**  \n  遍历原始 BTF 类型段，将每个 `struct btf_type` 及其附属数据（如数组、函数参数等）按 4 字节对齐解析，并存入 `btf->types[]` 数组。此阶段验证：\n  - 类型结构完整性\n  - 字符串偏移是否在合法范围内\n  - 基本类型属性合法性\n\n- **第二阶段（类型解析与循环检测）**  \n  对需要解析的类型（如结构体、指针、数组等）执行深度优先搜索（DFS）：\n  - 递归解析类型引用链\n  - 检测类型定义中的循环依赖（如结构体 A 包含结构体 B，B 又包含 A）\n  - 特殊处理指针类型：允许 `struct A { struct A *next; }` 这类合法递归\n  - 缓存已解析类型的大小和最终类型 ID，避免重复计算\n\n### BTF 对象生命周期管理\n\n- 使用 `refcount_t` 实现引用计数\n- 通过 RCU 机制安全释放内存，确保在 BPF 程序或映射仍在使用 BTF 时不会被提前销毁\n- 全局 `btf_idr` 提供 BTF 对象的全局唯一标识，支持通过 `bpf_btf_get_fd_by_id()` 等系统调用访问\n\n### kfunc 与析构函数集成\n\n- `btf_kfunc_set_tab` 为不同 BPF 钩子上下文维护允许调用的内核函数白名单\n- `dtor_kfunc_tab` 支持为特定类型注册析构函数，在 BPF map 元素删除时自动调用，实现资源管理\n- 通过 `btf_kfunc_hook_filter` 支持对 kfunc 调用进行额外过滤（如 LSM 策略）\n\n### CO-RE 与重定位支持\n\n- BTF 为 `libbpf` 的 CO-RE 重定位提供类型信息基础\n- 内核通过解析 BTF 中的类型结构，理解 BPF 程序期望访问的内核数据结构布局，从而在运行时进行字段偏移调整\n\n## 4. 依赖关系\n\n- **BPF 子系统**  \n  - `bpf_verifier.c`: BPF 验证器依赖 BTF 进行类型检查和内存安全分析\n  - `bpf_map.c`: BPF 映射使用 BTF 描述 key/value 类型\n  - `bpf_struct_ops.c`: 基于 BTF 定义内核结构体操作接口\n  - `bpf_lsm.c`: LSM 钩子使用 BTF 类型信息进行策略匹配\n\n- **网络子系统**  \n  - XDP、TC、Socket、Netfilter 等网络 BPF 钩子通过 BTF 注册和验证 kfunc\n\n- **用户空间接口**  \n  - 通过 `bpf(BPF_BTF_LOAD)` 系统调用加载 BTF\n  - `/sys/kernel/btf/` sysfs 接口暴露内核 BTF（vmlinux BTF）\n\n- **工具链依赖**  \n  - 依赖 `../tools/lib/bpf/relo_core.h` 中的 CO-RE 重定位定义\n\n- **内核通用机制**  \n  - IDR（ID 分配）、RCU（内存回收）、SLAB（内存分配）、Sysfs（调试接口）\n\n## 5. 使用场景\n\n- **BPF 程序加载**  \n  用户空间通过 `bpf(BPF_PROG_LOAD)` 加载程序时，可附带 BTF 信息，供验证器进行类型检查。\n\n- **BPF Map 类型描述**  \n  创建 BPF map 时指定 `btf_key_type_id` 和 `btf_value_type_id`，使内核理解 map 中存储的数据结构。\n\n- **内核函数调用（kfunc）**  \n  BPF 程序通过 `bpf_call` 调用内核函数时，BTF 用于验证函数签名、参数类型及调用上下文合法性。\n\n- **结构体操作（struct_ops）**  \n  定义 BPF 可实现的内核回调接口（如 TCP congestion control），BTF 描述接口结构体布局。\n\n- **CO-RE 程序运行**  \n  在不同内核版本上运行预编译的 BPF 程序时，内核 BTF（`vmlinux BTF`）与程序 BTF 对比，自动重定位字段访问。\n\n- **调试与内省**  \n  通过 `bpftool btf dump` 等工具查看 BTF 内容，辅助 BPF 程序开发和问题诊断。\n\n- **安全策略实施**  \n  LSM 模块利用 BTF 类型信息对 BPF 程序行为进行细粒度访问控制。",
      "similarity": 0.6264116764068604,
      "chunks": [
        {
          "chunk_id": 33,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 6004,
          "end_line": 6136,
          "content": [
            "static int btf_validate_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,",
            "\t\t\t\t      const struct btf_type *t, int arg,",
            "\t\t\t\t      enum bpf_prog_type prog_type,",
            "\t\t\t\t      enum bpf_attach_type attach_type)",
            "{",
            "\tconst struct btf_type *ctx_type;",
            "\tconst char *tname, *ctx_tname;",
            "",
            "\tif (!btf_is_ptr(t)) {",
            "\t\tbpf_log(log, \"arg#%d type isn't a pointer\\n\", arg);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t/* KPROBE and PERF_EVENT programs allow bpf_user_pt_regs_t typedef */",
            "\tif (prog_type == BPF_PROG_TYPE_KPROBE || prog_type == BPF_PROG_TYPE_PERF_EVENT) {",
            "\t\twhile (btf_type_is_modifier(t) && !btf_type_is_typedef(t))",
            "\t\t\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t\tif (btf_type_is_typedef(t)) {",
            "\t\t\ttname = btf_name_by_offset(btf, t->name_off);",
            "\t\t\tif (tname && strcmp(tname, \"bpf_user_pt_regs_t\") == 0)",
            "\t\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\t/* all other program types don't use typedefs for context type */",
            "\twhile (btf_type_is_modifier(t))",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t/* `void *ctx __arg_ctx` is always valid */",
            "\tif (btf_type_is_void(t))",
            "\t\treturn 0;",
            "",
            "\ttname = btf_name_by_offset(btf, t->name_off);",
            "\tif (str_is_empty(tname)) {",
            "\t\tbpf_log(log, \"arg#%d type doesn't have a name\\n\", arg);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* special cases */",
            "\tswitch (prog_type) {",
            "\tcase BPF_PROG_TYPE_KPROBE:",
            "\t\tif (__btf_type_is_struct(t) && strcmp(tname, \"pt_regs\") == 0)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_PERF_EVENT:",
            "\t\tif (__builtin_types_compatible_p(bpf_user_pt_regs_t, struct pt_regs) &&",
            "\t\t    __btf_type_is_struct(t) && strcmp(tname, \"pt_regs\") == 0)",
            "\t\t\treturn 0;",
            "\t\tif (__builtin_types_compatible_p(bpf_user_pt_regs_t, struct user_pt_regs) &&",
            "\t\t    __btf_type_is_struct(t) && strcmp(tname, \"user_pt_regs\") == 0)",
            "\t\t\treturn 0;",
            "\t\tif (__builtin_types_compatible_p(bpf_user_pt_regs_t, struct user_regs_struct) &&",
            "\t\t    __btf_type_is_struct(t) && strcmp(tname, \"user_regs_struct\") == 0)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:",
            "\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:",
            "\t\t/* allow u64* as ctx */",
            "\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_TRACING:",
            "\t\tswitch (attach_type) {",
            "\t\tcase BPF_TRACE_RAW_TP:",
            "\t\t\t/* tp_btf program is TRACING, so need special case here */",
            "\t\t\tif (__btf_type_is_struct(t) &&",
            "\t\t\t    strcmp(tname, \"bpf_raw_tracepoint_args\") == 0)",
            "\t\t\t\treturn 0;",
            "\t\t\t/* allow u64* as ctx */",
            "\t\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\t\treturn 0;",
            "\t\t\tbreak;",
            "\t\tcase BPF_TRACE_ITER:",
            "\t\t\t/* allow struct bpf_iter__xxx types only */",
            "\t\t\tif (__btf_type_is_struct(t) &&",
            "\t\t\t    strncmp(tname, \"bpf_iter__\", sizeof(\"bpf_iter__\") - 1) == 0)",
            "\t\t\t\treturn 0;",
            "\t\t\tbreak;",
            "\t\tcase BPF_TRACE_FENTRY:",
            "\t\tcase BPF_TRACE_FEXIT:",
            "\t\tcase BPF_MODIFY_RETURN:",
            "\t\t\t/* allow u64* as ctx */",
            "\t\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\t\treturn 0;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_LSM:",
            "\tcase BPF_PROG_TYPE_STRUCT_OPS:",
            "\t\t/* allow u64* as ctx */",
            "\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_TRACEPOINT:",
            "\tcase BPF_PROG_TYPE_SYSCALL:",
            "\tcase BPF_PROG_TYPE_EXT:",
            "\t\treturn 0; /* anything goes */",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\tctx_type = find_canonical_prog_ctx_type(prog_type);",
            "\tif (!ctx_type) {",
            "\t\t/* should not happen */",
            "\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* resolve typedefs and check that underlying structs are matching as well */",
            "\twhile (btf_type_is_modifier(ctx_type))",
            "\t\tctx_type = btf_type_by_id(btf_vmlinux, ctx_type->type);",
            "",
            "\t/* if program type doesn't have distinctly named struct type for",
            "\t * context, then __arg_ctx argument can only be `void *`, which we",
            "\t * already checked above",
            "\t */",
            "\tif (!__btf_type_is_struct(ctx_type)) {",
            "\t\tbpf_log(log, \"arg#%d should be void pointer\\n\", arg);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_type->name_off);",
            "\tif (!__btf_type_is_struct(t) || strcmp(ctx_tname, tname) != 0) {",
            "\t\tbpf_log(log, \"arg#%d should be `struct %s *`\\n\", arg, ctx_tname);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "btf_validate_prog_ctx_type",
          "description": "验证BPF程序上下文类型有效性，针对不同程序类型处理特殊指针类型兼容性检查，确保类型与内核期望的上下文结构匹配。",
          "similarity": 0.5968586206436157
        },
        {
          "chunk_id": 19,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 3532,
          "end_line": 3693,
          "content": [
            "static int btf_repeat_fields(struct btf_field_info *info, int info_cnt,",
            "\t\t\t     u32 field_cnt, u32 repeat_cnt, u32 elem_size)",
            "{",
            "\tu32 i, j;",
            "\tu32 cur;",
            "",
            "\t/* Ensure not repeating fields that should not be repeated. */",
            "\tfor (i = 0; i < field_cnt; i++) {",
            "\t\tswitch (info[i].type) {",
            "\t\tcase BPF_KPTR_UNREF:",
            "\t\tcase BPF_KPTR_REF:",
            "\t\tcase BPF_KPTR_PERCPU:",
            "\t\tcase BPF_UPTR:",
            "\t\tcase BPF_LIST_HEAD:",
            "\t\tcase BPF_RB_ROOT:",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\t/* The type of struct size or variable size is u32,",
            "\t * so the multiplication will not overflow.",
            "\t */",
            "\tif (field_cnt * (repeat_cnt + 1) > info_cnt)",
            "\t\treturn -E2BIG;",
            "",
            "\tcur = field_cnt;",
            "\tfor (i = 0; i < repeat_cnt; i++) {",
            "\t\tmemcpy(&info[cur], &info[0], field_cnt * sizeof(info[0]));",
            "\t\tfor (j = 0; j < field_cnt; j++)",
            "\t\t\tinfo[cur++].off += (i + 1) * elem_size;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int btf_find_nested_struct(const struct btf *btf, const struct btf_type *t,",
            "\t\t\t\t  u32 off, u32 nelems,",
            "\t\t\t\t  u32 field_mask, struct btf_field_info *info,",
            "\t\t\t\t  int info_cnt, u32 level)",
            "{",
            "\tint ret, err, i;",
            "",
            "\tlevel++;",
            "\tif (level >= MAX_RESOLVE_DEPTH)",
            "\t\treturn -E2BIG;",
            "",
            "\tret = btf_find_struct_field(btf, t, field_mask, info, info_cnt, level);",
            "",
            "\tif (ret <= 0)",
            "\t\treturn ret;",
            "",
            "\t/* Shift the offsets of the nested struct fields to the offsets",
            "\t * related to the container.",
            "\t */",
            "\tfor (i = 0; i < ret; i++)",
            "\t\tinfo[i].off += off;",
            "",
            "\tif (nelems > 1) {",
            "\t\terr = btf_repeat_fields(info, info_cnt, ret, nelems - 1, t->size);",
            "\t\tif (err == 0)",
            "\t\t\tret *= nelems;",
            "\t\telse",
            "\t\t\tret = err;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int btf_find_field_one(const struct btf *btf,",
            "\t\t\t      const struct btf_type *var,",
            "\t\t\t      const struct btf_type *var_type,",
            "\t\t\t      int var_idx,",
            "\t\t\t      u32 off, u32 expected_size,",
            "\t\t\t      u32 field_mask, u32 *seen_mask,",
            "\t\t\t      struct btf_field_info *info, int info_cnt,",
            "\t\t\t      u32 level)",
            "{",
            "\tint ret, align, sz, field_type;",
            "\tstruct btf_field_info tmp;",
            "\tconst struct btf_array *array;",
            "\tu32 i, nelems = 1;",
            "",
            "\t/* Walk into array types to find the element type and the number of",
            "\t * elements in the (flattened) array.",
            "\t */",
            "\tfor (i = 0; i < MAX_RESOLVE_DEPTH && btf_type_is_array(var_type); i++) {",
            "\t\tarray = btf_array(var_type);",
            "\t\tnelems *= array->nelems;",
            "\t\tvar_type = btf_type_by_id(btf, array->type);",
            "\t}",
            "\tif (i == MAX_RESOLVE_DEPTH)",
            "\t\treturn -E2BIG;",
            "\tif (nelems == 0)",
            "\t\treturn 0;",
            "",
            "\tfield_type = btf_get_field_type(btf, var_type,",
            "\t\t\t\t\tfield_mask, seen_mask, &align, &sz);",
            "\t/* Look into variables of struct types */",
            "\tif (!field_type && __btf_type_is_struct(var_type)) {",
            "\t\tsz = var_type->size;",
            "\t\tif (expected_size && expected_size != sz * nelems)",
            "\t\t\treturn 0;",
            "\t\tret = btf_find_nested_struct(btf, var_type, off, nelems, field_mask,",
            "\t\t\t\t\t     &info[0], info_cnt, level);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tif (field_type == 0)",
            "\t\treturn 0;",
            "\tif (field_type < 0)",
            "\t\treturn field_type;",
            "",
            "\tif (expected_size && expected_size != sz * nelems)",
            "\t\treturn 0;",
            "\tif (off % align)",
            "\t\treturn 0;",
            "",
            "\tswitch (field_type) {",
            "\tcase BPF_SPIN_LOCK:",
            "\tcase BPF_TIMER:",
            "\tcase BPF_WORKQUEUE:",
            "\tcase BPF_LIST_NODE:",
            "\tcase BPF_RB_NODE:",
            "\tcase BPF_REFCOUNT:",
            "\t\tret = btf_find_struct(btf, var_type, off, sz, field_type,",
            "\t\t\t\t      info_cnt ? &info[0] : &tmp);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t\tbreak;",
            "\tcase BPF_KPTR_UNREF:",
            "\tcase BPF_KPTR_REF:",
            "\tcase BPF_KPTR_PERCPU:",
            "\tcase BPF_UPTR:",
            "\t\tret = btf_find_kptr(btf, var_type, off, sz,",
            "\t\t\t\t    info_cnt ? &info[0] : &tmp, field_mask);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t\tbreak;",
            "\tcase BPF_LIST_HEAD:",
            "\tcase BPF_RB_ROOT:",
            "\t\tret = btf_find_graph_root(btf, var, var_type,",
            "\t\t\t\t\t  var_idx, off, sz,",
            "\t\t\t\t\t  info_cnt ? &info[0] : &tmp,",
            "\t\t\t\t\t  field_type);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tif (ret == BTF_FIELD_IGNORE)",
            "\t\treturn 0;",
            "\tif (!info_cnt)",
            "\t\treturn -E2BIG;",
            "\tif (nelems > 1) {",
            "\t\tret = btf_repeat_fields(info, info_cnt, 1, nelems - 1, sz);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t}",
            "\treturn nelems;",
            "}"
          ],
          "function_name": "btf_repeat_fields, btf_find_nested_struct, btf_find_field_one",
          "description": "该代码段实现了BPF类型系统中对结构体字段的解析与重复逻辑，包含三个关键函数：  \n1. `btf_repeat_fields`用于复制字段信息并调整偏移量，处理数组类型中重复字段的布局；  \n2. `btf_find_nested_struct`定位嵌套结构体字段，通过偏移调整适配容器地址，并在多元素场景下调用`btf_repeat_fields`；  \n3. `btf_find_field_one`解析单一字段类型，根据结构体/指针/图节点等不同情况调用相应处理函数，并管理字段重复逻辑。",
          "similarity": 0.5960903763771057
        },
        {
          "chunk_id": 21,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 3864,
          "end_line": 4016,
          "content": [
            "static int btf_parse_graph_root(const struct btf *btf,",
            "\t\t\t\tstruct btf_field *field,",
            "\t\t\t\tstruct btf_field_info *info,",
            "\t\t\t\tconst char *node_type_name,",
            "\t\t\t\tsize_t node_type_align)",
            "{",
            "\tconst struct btf_type *t, *n = NULL;",
            "\tconst struct btf_member *member;",
            "\tu32 offset;",
            "\tint i;",
            "",
            "\tt = btf_type_by_id(btf, info->graph_root.value_btf_id);",
            "\t/* We've already checked that value_btf_id is a struct type. We",
            "\t * just need to figure out the offset of the list_node, and",
            "\t * verify its type.",
            "\t */",
            "\tfor_each_member(i, t, member) {",
            "\t\tif (strcmp(info->graph_root.node_name,",
            "\t\t\t   __btf_name_by_offset(btf, member->name_off)))",
            "\t\t\tcontinue;",
            "\t\t/* Invalid BTF, two members with same name */",
            "\t\tif (n)",
            "\t\t\treturn -EINVAL;",
            "\t\tn = btf_type_by_id(btf, member->type);",
            "\t\tif (!__btf_type_is_struct(n))",
            "\t\t\treturn -EINVAL;",
            "\t\tif (strcmp(node_type_name, __btf_name_by_offset(btf, n->name_off)))",
            "\t\t\treturn -EINVAL;",
            "\t\toffset = __btf_member_bit_offset(n, member);",
            "\t\tif (offset % 8)",
            "\t\t\treturn -EINVAL;",
            "\t\toffset /= 8;",
            "\t\tif (offset % node_type_align)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tfield->graph_root.btf = (struct btf *)btf;",
            "\t\tfield->graph_root.value_btf_id = info->graph_root.value_btf_id;",
            "\t\tfield->graph_root.node_offset = offset;",
            "\t}",
            "\tif (!n)",
            "\t\treturn -ENOENT;",
            "\treturn 0;",
            "}",
            "static int btf_parse_list_head(const struct btf *btf, struct btf_field *field,",
            "\t\t\t       struct btf_field_info *info)",
            "{",
            "\treturn btf_parse_graph_root(btf, field, info, \"bpf_list_node\",",
            "\t\t\t\t\t    __alignof__(struct bpf_list_node));",
            "}",
            "static int btf_parse_rb_root(const struct btf *btf, struct btf_field *field,",
            "\t\t\t     struct btf_field_info *info)",
            "{",
            "\treturn btf_parse_graph_root(btf, field, info, \"bpf_rb_node\",",
            "\t\t\t\t\t    __alignof__(struct bpf_rb_node));",
            "}",
            "static int btf_field_cmp(const void *_a, const void *_b, const void *priv)",
            "{",
            "\tconst struct btf_field *a = (const struct btf_field *)_a;",
            "\tconst struct btf_field *b = (const struct btf_field *)_b;",
            "",
            "\tif (a->offset < b->offset)",
            "\t\treturn -1;",
            "\telse if (a->offset > b->offset)",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "int btf_check_and_fixup_fields(const struct btf *btf, struct btf_record *rec)",
            "{",
            "\tint i;",
            "",
            "\t/* There are three types that signify ownership of some other type:",
            "\t *  kptr_ref, bpf_list_head, bpf_rb_root.",
            "\t * kptr_ref only supports storing kernel types, which can't store",
            "\t * references to program allocated local types.",
            "\t *",
            "\t * Hence we only need to ensure that bpf_{list_head,rb_root} ownership",
            "\t * does not form cycles.",
            "\t */",
            "\tif (IS_ERR_OR_NULL(rec) || !(rec->field_mask & (BPF_GRAPH_ROOT | BPF_UPTR)))",
            "\t\treturn 0;",
            "\tfor (i = 0; i < rec->cnt; i++) {",
            "\t\tstruct btf_struct_meta *meta;",
            "\t\tconst struct btf_type *t;",
            "\t\tu32 btf_id;",
            "",
            "\t\tif (rec->fields[i].type == BPF_UPTR) {",
            "\t\t\t/* The uptr only supports pinning one page and cannot",
            "\t\t\t * point to a kernel struct",
            "\t\t\t */",
            "\t\t\tif (btf_is_kernel(rec->fields[i].kptr.btf))",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\tt = btf_type_by_id(rec->fields[i].kptr.btf,",
            "\t\t\t\t\t   rec->fields[i].kptr.btf_id);",
            "\t\t\tif (!t->size)",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\tif (t->size > PAGE_SIZE)",
            "\t\t\t\treturn -E2BIG;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!(rec->fields[i].type & BPF_GRAPH_ROOT))",
            "\t\t\tcontinue;",
            "\t\tbtf_id = rec->fields[i].graph_root.value_btf_id;",
            "\t\tmeta = btf_find_struct_meta(btf, btf_id);",
            "\t\tif (!meta)",
            "\t\t\treturn -EFAULT;",
            "\t\trec->fields[i].graph_root.value_rec = meta->record;",
            "",
            "\t\t/* We need to set value_rec for all root types, but no need",
            "\t\t * to check ownership cycle for a type unless it's also a",
            "\t\t * node type.",
            "\t\t */",
            "\t\tif (!(rec->field_mask & BPF_GRAPH_NODE))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* We need to ensure ownership acyclicity among all types. The",
            "\t\t * proper way to do it would be to topologically sort all BTF",
            "\t\t * IDs based on the ownership edges, since there can be multiple",
            "\t\t * bpf_{list_head,rb_node} in a type. Instead, we use the",
            "\t\t * following resaoning:",
            "\t\t *",
            "\t\t * - A type can only be owned by another type in user BTF if it",
            "\t\t *   has a bpf_{list,rb}_node. Let's call these node types.",
            "\t\t * - A type can only _own_ another type in user BTF if it has a",
            "\t\t *   bpf_{list_head,rb_root}. Let's call these root types.",
            "\t\t *",
            "\t\t * We ensure that if a type is both a root and node, its",
            "\t\t * element types cannot be root types.",
            "\t\t *",
            "\t\t * To ensure acyclicity:",
            "\t\t *",
            "\t\t * When A is an root type but not a node, its ownership",
            "\t\t * chain can be:",
            "\t\t *\tA -> B -> C",
            "\t\t * Where:",
            "\t\t * - A is an root, e.g. has bpf_rb_root.",
            "\t\t * - B is both a root and node, e.g. has bpf_rb_node and",
            "\t\t *   bpf_list_head.",
            "\t\t * - C is only an root, e.g. has bpf_list_node",
            "\t\t *",
            "\t\t * When A is both a root and node, some other type already",
            "\t\t * owns it in the BTF domain, hence it can not own",
            "\t\t * another root type through any of the ownership edges.",
            "\t\t *\tA -> B",
            "\t\t * Where:",
            "\t\t * - A is both an root and node.",
            "\t\t * - B is only an node.",
            "\t\t */",
            "\t\tif (meta->record->field_mask & BPF_GRAPH_ROOT)",
            "\t\t\treturn -ELOOP;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "btf_parse_graph_root, btf_parse_list_head, btf_parse_rb_root, btf_field_cmp, btf_check_and_fixup_fields",
          "description": "该代码段主要处理BPF程序中图结构类型的解析与校验。btf_parse_*系列函数用于解析链表头、红黑树根等图结构字段的元数据，通过遍历类型成员验证节点类型一致性及对齐要求；btf_check_and_fixup_fields则检查所有权关系是否存在环形依赖，防止因bpf_list_head/rb_root形成循环引用导致的问题。",
          "similarity": 0.5803227424621582
        },
        {
          "chunk_id": 35,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 6539,
          "end_line": 6786,
          "content": [
            "bool btf_ctx_access(int off, int size, enum bpf_access_type type,",
            "\t\t    const struct bpf_prog *prog,",
            "\t\t    struct bpf_insn_access_aux *info)",
            "{",
            "\tconst struct btf_type *t = prog->aux->attach_func_proto;",
            "\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;",
            "\tstruct btf *btf = bpf_prog_get_target_btf(prog);",
            "\tconst char *tname = prog->aux->attach_func_name;",
            "\tstruct bpf_verifier_log *log = info->log;",
            "\tconst struct btf_param *args;",
            "\tbool ptr_err_raw_tp = false;",
            "\tconst char *tag_value;",
            "\tu32 nr_args, arg;",
            "\tint i, ret;",
            "",
            "\tif (off % 8) {",
            "\t\tbpf_log(log, \"func '%s' offset %d is not multiple of 8\\n\",",
            "\t\t\ttname, off);",
            "\t\treturn false;",
            "\t}",
            "\targ = btf_ctx_arg_idx(btf, t, off);",
            "\targs = (const struct btf_param *)(t + 1);",
            "\t/* if (t == NULL) Fall back to default BPF prog with",
            "\t * MAX_BPF_FUNC_REG_ARGS u64 arguments.",
            "\t */",
            "\tnr_args = t ? btf_type_vlen(t) : MAX_BPF_FUNC_REG_ARGS;",
            "\tif (prog->aux->attach_btf_trace) {",
            "\t\t/* skip first 'void *__data' argument in btf_trace_##name typedef */",
            "\t\targs++;",
            "\t\tnr_args--;",
            "\t}",
            "",
            "\tif (arg > nr_args) {",
            "\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",",
            "\t\t\ttname, arg + 1);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (arg == nr_args) {",
            "\t\tswitch (prog->expected_attach_type) {",
            "\t\tcase BPF_LSM_MAC:",
            "\t\t\t/* mark we are accessing the return value */",
            "\t\t\tinfo->is_retval = true;",
            "\t\t\tfallthrough;",
            "\t\tcase BPF_LSM_CGROUP:",
            "\t\tcase BPF_TRACE_FEXIT:",
            "\t\t\t/* When LSM programs are attached to void LSM hooks",
            "\t\t\t * they use FEXIT trampolines and when attached to",
            "\t\t\t * int LSM hooks, they use MODIFY_RETURN trampolines.",
            "\t\t\t *",
            "\t\t\t * While the LSM programs are BPF_MODIFY_RETURN-like",
            "\t\t\t * the check:",
            "\t\t\t *",
            "\t\t\t *\tif (ret_type != 'int')",
            "\t\t\t *\t\treturn -EINVAL;",
            "\t\t\t *",
            "\t\t\t * is _not_ done here. This is still safe as LSM hooks",
            "\t\t\t * have only void and int return types.",
            "\t\t\t */",
            "\t\t\tif (!t)",
            "\t\t\t\treturn true;",
            "\t\t\tt = btf_type_by_id(btf, t->type);",
            "\t\t\tbreak;",
            "\t\tcase BPF_MODIFY_RETURN:",
            "\t\t\t/* For now the BPF_MODIFY_RETURN can only be attached to",
            "\t\t\t * functions that return an int.",
            "\t\t\t */",
            "\t\t\tif (!t)",
            "\t\t\t\treturn false;",
            "",
            "\t\t\tt = btf_type_skip_modifiers(btf, t->type, NULL);",
            "\t\t\tif (!btf_type_is_small_int(t)) {",
            "\t\t\t\tbpf_log(log,",
            "\t\t\t\t\t\"ret type %s not allowed for fmod_ret\\n\",",
            "\t\t\t\t\tbtf_type_str(t));",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",",
            "\t\t\t\ttname, arg + 1);",
            "\t\t\treturn false;",
            "\t\t}",
            "\t} else {",
            "\t\tif (!t)",
            "\t\t\t/* Default prog with MAX_BPF_FUNC_REG_ARGS args */",
            "\t\t\treturn true;",
            "\t\tt = btf_type_by_id(btf, args[arg].type);",
            "\t}",
            "",
            "\t/* skip modifiers */",
            "\twhile (btf_type_is_modifier(t))",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "\tif (btf_type_is_small_int(t) || btf_is_any_enum(t) || __btf_type_is_struct(t))",
            "\t\t/* accessing a scalar */",
            "\t\treturn true;",
            "\tif (!btf_type_is_ptr(t)) {",
            "\t\tbpf_log(log,",
            "\t\t\t\"func '%s' arg%d '%s' has type %s. Only pointer access is allowed\\n\",",
            "\t\t\ttname, arg,",
            "\t\t\t__btf_name_by_offset(btf, t->name_off),",
            "\t\t\tbtf_type_str(t));",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (size != sizeof(u64)) {",
            "\t\tbpf_log(log, \"func '%s' size %d must be 8\\n\",",
            "\t\t\ttname, size);",
            "\t\treturn false;",
            "\t}",
            "",
            "\t/* check for PTR_TO_RDONLY_BUF_OR_NULL or PTR_TO_RDWR_BUF_OR_NULL */",
            "\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {",
            "\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];",
            "\t\tu32 type, flag;",
            "",
            "\t\ttype = base_type(ctx_arg_info->reg_type);",
            "\t\tflag = type_flag(ctx_arg_info->reg_type);",
            "\t\tif (ctx_arg_info->offset == off && type == PTR_TO_BUF &&",
            "\t\t    (flag & PTR_MAYBE_NULL)) {",
            "\t\t\tinfo->reg_type = ctx_arg_info->reg_type;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tif (t->type == 0)",
            "\t\t/* This is a pointer to void.",
            "\t\t * It is the same as scalar from the verifier safety pov.",
            "\t\t * No further pointer walking is allowed.",
            "\t\t */",
            "\t\treturn true;",
            "",
            "\tif (is_int_ptr(btf, t))",
            "\t\treturn true;",
            "",
            "\t/* this is a pointer to another type */",
            "\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {",
            "\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];",
            "",
            "\t\tif (ctx_arg_info->offset == off) {",
            "\t\t\tif (!ctx_arg_info->btf_id) {",
            "\t\t\t\tbpf_log(log,\"invalid btf_id for context argument offset %u\\n\", off);",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "",
            "\t\t\tinfo->reg_type = ctx_arg_info->reg_type;",
            "\t\t\tinfo->btf = ctx_arg_info->btf ? : btf_vmlinux;",
            "\t\t\tinfo->btf_id = ctx_arg_info->btf_id;",
            "\t\t\tinfo->ref_obj_id = ctx_arg_info->ref_obj_id;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tinfo->reg_type = PTR_TO_BTF_ID;",
            "\tif (prog_args_trusted(prog))",
            "\t\tinfo->reg_type |= PTR_TRUSTED;",
            "",
            "\tif (btf_param_match_suffix(btf, &args[arg], \"__nullable\"))",
            "\t\tinfo->reg_type |= PTR_MAYBE_NULL;",
            "",
            "\tif (prog->expected_attach_type == BPF_TRACE_RAW_TP) {",
            "\t\tstruct btf *btf = prog->aux->attach_btf;",
            "\t\tconst struct btf_type *t;",
            "\t\tconst char *tname;",
            "",
            "\t\t/* BTF lookups cannot fail, return false on error */",
            "\t\tt = btf_type_by_id(btf, prog->aux->attach_btf_id);",
            "\t\tif (!t)",
            "\t\t\treturn false;",
            "\t\ttname = btf_name_by_offset(btf, t->name_off);",
            "\t\tif (!tname)",
            "\t\t\treturn false;",
            "\t\t/* Checked by bpf_check_attach_target */",
            "\t\ttname += sizeof(\"btf_trace_\") - 1;",
            "\t\tfor (i = 0; i < ARRAY_SIZE(raw_tp_null_args); i++) {",
            "\t\t\t/* Is this a func with potential NULL args? */",
            "\t\t\tif (strcmp(tname, raw_tp_null_args[i].func))",
            "\t\t\t\tcontinue;",
            "\t\t\tif (raw_tp_null_args[i].mask & (0x1 << (arg * 4)))",
            "\t\t\t\tinfo->reg_type |= PTR_MAYBE_NULL;",
            "\t\t\t/* Is the current arg IS_ERR? */",
            "\t\t\tif (raw_tp_null_args[i].mask & (0x2 << (arg * 4)))",
            "\t\t\t\tptr_err_raw_tp = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t/* If we don't know NULL-ness specification and the tracepoint",
            "\t\t * is coming from a loadable module, be conservative and mark",
            "\t\t * argument as PTR_MAYBE_NULL.",
            "\t\t */",
            "\t\tif (i == ARRAY_SIZE(raw_tp_null_args) && btf_is_module(btf))",
            "\t\t\tinfo->reg_type |= PTR_MAYBE_NULL;",
            "\t}",
            "",
            "\tif (tgt_prog) {",
            "\t\tenum bpf_prog_type tgt_type;",
            "",
            "\t\tif (tgt_prog->type == BPF_PROG_TYPE_EXT)",
            "\t\t\ttgt_type = tgt_prog->aux->saved_dst_prog_type;",
            "\t\telse",
            "\t\t\ttgt_type = tgt_prog->type;",
            "",
            "\t\tret = btf_translate_to_vmlinux(log, btf, t, tgt_type, arg);",
            "\t\tif (ret > 0) {",
            "\t\t\tinfo->btf = btf_vmlinux;",
            "\t\t\tinfo->btf_id = ret;",
            "\t\t\treturn true;",
            "\t\t} else {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "",
            "\tinfo->btf = btf;",
            "\tinfo->btf_id = t->type;",
            "\tt = btf_type_by_id(btf, t->type);",
            "",
            "\tif (btf_type_is_type_tag(t)) {",
            "\t\ttag_value = __btf_name_by_offset(btf, t->name_off);",
            "\t\tif (strcmp(tag_value, \"user\") == 0)",
            "\t\t\tinfo->reg_type |= MEM_USER;",
            "\t\tif (strcmp(tag_value, \"percpu\") == 0)",
            "\t\t\tinfo->reg_type |= MEM_PERCPU;",
            "\t}",
            "",
            "\t/* skip modifiers */",
            "\twhile (btf_type_is_modifier(t)) {",
            "\t\tinfo->btf_id = t->type;",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "\t}",
            "\tif (!btf_type_is_struct(t)) {",
            "\t\tbpf_log(log,",
            "\t\t\t\"func '%s' arg%d type %s is not a struct\\n\",",
            "\t\t\ttname, arg, btf_type_str(t));",
            "\t\treturn false;",
            "\t}",
            "\tbpf_log(log, \"func '%s' arg%d has btf_id %d type %s '%s'\\n\",",
            "\t\ttname, arg, info->btf_id, btf_type_str(t),",
            "\t\t__btf_name_by_offset(btf, t->name_off));",
            "",
            "\t/* Perform all checks on the validity of type for this argument, but if",
            "\t * we know it can be IS_ERR at runtime, scrub pointer type and mark as",
            "\t * scalar.",
            "\t */",
            "\tif (ptr_err_raw_tp) {",
            "\t\tbpf_log(log, \"marking pointer arg%d as scalar as it may encode error\", arg);",
            "\t\tinfo->reg_type = SCALAR_VALUE;",
            "\t}",
            "\treturn true;",
            "}"
          ],
          "function_name": "btf_ctx_access",
          "description": "函数btf_ctx_access用于验证BPF程序对上下文指针的访问合法性，检查偏移量是否对齐、参数是否存在、类型是否为指针，并根据目标函数签名确定寄存器类型和BTF标识符。",
          "similarity": 0.576515793800354
        },
        {
          "chunk_id": 34,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 6138,
          "end_line": 6240,
          "content": [
            "static int btf_translate_to_vmlinux(struct bpf_verifier_log *log,",
            "\t\t\t\t     struct btf *btf,",
            "\t\t\t\t     const struct btf_type *t,",
            "\t\t\t\t     enum bpf_prog_type prog_type,",
            "\t\t\t\t     int arg)",
            "{",
            "\tif (!btf_is_prog_ctx_type(log, btf, t, prog_type, arg))",
            "\t\treturn -ENOENT;",
            "\treturn find_kern_ctx_type_id(prog_type);",
            "}",
            "int get_kern_ctx_btf_id(struct bpf_verifier_log *log, enum bpf_prog_type prog_type)",
            "{",
            "\tconst struct btf_member *kctx_member;",
            "\tconst struct btf_type *conv_struct;",
            "\tconst struct btf_type *kctx_type;",
            "\tu32 kctx_type_id;",
            "",
            "\tconv_struct = bpf_ctx_convert.t;",
            "\t/* get member for kernel ctx type */",
            "\tkctx_member = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2 + 1;",
            "\tkctx_type_id = kctx_member->type;",
            "\tkctx_type = btf_type_by_id(btf_vmlinux, kctx_type_id);",
            "\tif (!btf_type_is_struct(kctx_type)) {",
            "\t\tbpf_log(log, \"kern ctx type id %u is not a struct\\n\", kctx_type_id);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn kctx_type_id;",
            "}",
            "static __u32 btf_relocate_id(const struct btf *btf, __u32 id)",
            "{",
            "\tif (!btf->base_btf || !btf->base_id_map)",
            "\t\treturn id;",
            "\treturn btf->base_id_map[id];",
            "}",
            "static bool is_int_ptr(struct btf *btf, const struct btf_type *t)",
            "{",
            "\t/* skip modifiers */",
            "\tt = btf_type_skip_modifiers(btf, t->type, NULL);",
            "",
            "\treturn btf_type_is_int(t);",
            "}",
            "u32 btf_ctx_arg_idx(struct btf *btf, const struct btf_type *func_proto,",
            "\t\t    int off)",
            "{",
            "\tconst struct btf_param *args;",
            "\tconst struct btf_type *t;",
            "\tu32 offset = 0, nr_args;",
            "\tint i;",
            "",
            "\tif (!func_proto)",
            "\t\treturn off / 8;",
            "",
            "\tnr_args = btf_type_vlen(func_proto);",
            "\targs = (const struct btf_param *)(func_proto + 1);",
            "\tfor (i = 0; i < nr_args; i++) {",
            "\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);",
            "\t\toffset += btf_type_is_ptr(t) ? 8 : roundup(t->size, 8);",
            "\t\tif (off < offset)",
            "\t\t\treturn i;",
            "\t}",
            "",
            "\tt = btf_type_skip_modifiers(btf, func_proto->type, NULL);",
            "\toffset += btf_type_is_ptr(t) ? 8 : roundup(t->size, 8);",
            "\tif (off < offset)",
            "\t\treturn nr_args;",
            "",
            "\treturn nr_args + 1;",
            "}",
            "static bool prog_args_trusted(const struct bpf_prog *prog)",
            "{",
            "\tenum bpf_attach_type atype = prog->expected_attach_type;",
            "",
            "\tswitch (prog->type) {",
            "\tcase BPF_PROG_TYPE_TRACING:",
            "\t\treturn atype == BPF_TRACE_RAW_TP || atype == BPF_TRACE_ITER;",
            "\tcase BPF_PROG_TYPE_LSM:",
            "\t\treturn bpf_lsm_is_trusted(prog);",
            "\tcase BPF_PROG_TYPE_STRUCT_OPS:",
            "\t\treturn true;",
            "\tdefault:",
            "\t\treturn false;",
            "\t}",
            "}",
            "int btf_ctx_arg_offset(const struct btf *btf, const struct btf_type *func_proto,",
            "\t\t       u32 arg_no)",
            "{",
            "\tconst struct btf_param *args;",
            "\tconst struct btf_type *t;",
            "\tint off = 0, i;",
            "\tu32 sz;",
            "",
            "\targs = btf_params(func_proto);",
            "\tfor (i = 0; i < arg_no; i++) {",
            "\t\tt = btf_type_by_id(btf, args[i].type);",
            "\t\tt = btf_resolve_size(btf, t, &sz);",
            "\t\tif (IS_ERR(t))",
            "\t\t\treturn PTR_ERR(t);",
            "\t\toff += roundup(sz, 8);",
            "\t}",
            "",
            "\treturn off;",
            "}"
          ],
          "function_name": "btf_translate_to_vmlinux, get_kern_ctx_btf_id, btf_relocate_id, is_int_ptr, btf_ctx_arg_idx, prog_args_trusted, btf_ctx_arg_offset",
          "description": "实现BTF类型到内核类型的映射转换，提供上下文参数索引/偏移计算功能，支持可信参数检查及类型ID重定位操作。",
          "similarity": 0.5735329389572144
        }
      ]
    },
    {
      "source_file": "kernel/bpf/dispatcher.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:10:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\dispatcher.c`\n\n---\n\n# `bpf/dispatcher.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/dispatcher.c` 实现了 BPF（Berkeley Packet Filter）调度器（dispatcher）机制，其核心目标是通过生成多路分支的直接调用代码，避免在启用 retpoline（用于缓解 Spectre v2 攻击的间接跳转防护机制）时因间接调用带来的性能开销。该调度器通过劫持一个 trampoline 函数的 `__fentry__` 入口，动态生成包含多个 BPF 程序直接调用的跳转逻辑，从而将原本的间接调用转换为高效的直接调用。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct bpf_dispatcher`：BPF 调度器主结构体，包含：\n  - `progs[BPF_DISPATCHER_MAX]`：最多支持 `BPF_DISPATCHER_MAX` 个 BPF 程序的注册项\n  - `num_progs`：当前注册的程序数量\n  - `image` 和 `rw_image`：分别指向只读可执行（RO+X）和可读写（RW）的代码页\n  - `image_off`：用于双缓冲机制的偏移量\n  - `mutex`：保护调度器状态的互斥锁\n  - `ksym`：用于内核符号管理的 ksym 结构\n- `struct bpf_dispatcher_prog`：调度器中每个 BPF 程序的注册项，包含：\n  - `prog`：指向注册的 `struct bpf_prog`\n  - `users`：引用计数\n\n### 主要函数\n- `bpf_dispatcher_find_prog()`：在调度器中查找指定 BPF 程序的注册项\n- `bpf_dispatcher_find_free()`：查找空闲的注册槽位\n- `bpf_dispatcher_add_prog()`：向调度器注册一个 BPF 程序（带引用计数）\n- `bpf_dispatcher_remove_prog()`：从调度器注销一个 BPF 程序（引用计数减一，若为零则真正移除）\n- `arch_prepare_bpf_dispatcher()`（弱符号）：架构相关函数，用于生成实际的多路分支机器码\n- `bpf_dispatcher_prepare()`：准备调度器代码镜像，收集所有已注册 BPF 程序的入口地址\n- `bpf_dispatcher_update()`：更新调度器的可执行代码，使用双缓冲机制避免执行时修改代码\n- `bpf_dispatcher_change_prog()`：主入口函数，用于将一个 BPF 程序替换为另一个，并触发调度器代码更新\n\n## 3. 关键实现\n\n### 调度器工作原理\n调度器维护一个最多包含 `BPF_DISPATCHER_MAX` 个 BPF 程序的列表。当有程序注册或注销时，调度器会重新生成一段包含所有有效程序直接调用的机器码（多路分支），并通过 trampoline 机制被调用。\n\n### 双缓冲代码更新机制\n为避免在 CPU 执行调度器代码时修改代码页导致崩溃，采用双缓冲策略：\n- 调度器分配两个半页（共一页）的内存：`image`（RO+X）和 `rw_image`（RW）\n- `image_off` 在 `0` 和 `PAGE_SIZE/2` 之间切换，指示当前活跃的半页\n- 新代码先在 `rw_image` 的非活跃半页中生成，再通过 `bpf_arch_text_copy` 原子复制到 `image` 的对应位置\n- 调用 `synchronize_rcu()` 确保所有 CPU 退出旧代码后再切换活跃半页\n\n### 引用计数管理\n每个注册的 BPF 程序通过 `refcount_t users` 管理引用计数，允许多次注册同一程序（仅增加引用计数），只有当引用归零时才真正从调度器中移除并释放程序。\n\n### 架构无关与相关分离\n- 架构无关逻辑（如程序管理、缓冲区切换）在本文件实现\n- 架构相关代码生成由 `arch_prepare_bpf_dispatcher()` 实现（通常在 `arch/xxx/net/bpf_dispatcher.c` 中），若未实现则返回 `-ENOTSUPP`\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/hash.h>`：哈希辅助（虽未直接使用，但可能为未来扩展预留）\n  - `<linux/bpf.h>` 和 `<linux/filter.h>`：BPF 核心数据结构（`bpf_prog`、`bpf_insn` 等）\n  - `<linux/static_call.h>`：静态调用优化支持（用于 `__BPF_DISPATCHER_UPDATE` 宏）\n- **内核模块依赖**：\n  - BPF JIT 子系统：通过 `bpf_prog_pack_alloc()`、`bpf_jit_alloc_exec()` 分配可执行内存\n  - 内存管理：使用 `bpf_prog_inc()`/`bpf_prog_put()` 管理 BPF 程序生命周期\n  - RCU 机制：通过 `synchronize_rcu()` 实现安全的代码更新\n  - 架构特定代码复制：依赖 `bpf_arch_text_copy()`（通常基于 `text_poke()`）\n\n## 5. 使用场景\n\n- **BPF 程序热替换**：当 attach 到 tracepoint、kprobe、perf event 等的 BPF 程序被替换时，通过 `bpf_dispatcher_change_prog()` 更新调度器，避免间接调用开销。\n- **高性能 BPF 执行路径**：在需要极致性能的场景（如网络数据包处理、系统调用跟踪），调度器可显著提升 BPF 程序调用效率，尤其在启用 retpoline 的系统上。\n- **多程序共享调度器**：多个相同类型的 BPF 程序（如多个 socket filter）可共享同一个调度器实例，统一管理直接调用入口。",
      "similarity": 0.6221035718917847,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/dispatcher.c",
          "start_line": 1,
          "end_line": 42,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright(c) 2019 Intel Corporation. */",
            "",
            "#include <linux/hash.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/static_call.h>",
            "",
            "/* The BPF dispatcher is a multiway branch code generator. The",
            " * dispatcher is a mechanism to avoid the performance penalty of an",
            " * indirect call, which is expensive when retpolines are enabled. A",
            " * dispatch client registers a BPF program into the dispatcher, and if",
            " * there is available room in the dispatcher a direct call to the BPF",
            " * program will be generated. All calls to the BPF programs called via",
            " * the dispatcher will then be a direct call, instead of an",
            " * indirect. The dispatcher hijacks a trampoline function it via the",
            " * __fentry__ of the trampoline. The trampoline function has the",
            " * following signature:",
            " *",
            " * unsigned int trampoline(const void *ctx, const struct bpf_insn *insnsi,",
            " *                         unsigned int (*bpf_func)(const void *,",
            " *                                                  const struct bpf_insn *));",
            " */",
            "",
            "static struct bpf_dispatcher_prog *bpf_dispatcher_find_prog(",
            "\tstruct bpf_dispatcher *d, struct bpf_prog *prog)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < BPF_DISPATCHER_MAX; i++) {",
            "\t\tif (prog == d->progs[i].prog)",
            "\t\t\treturn &d->progs[i];",
            "\t}",
            "\treturn NULL;",
            "}",
            "",
            "static struct bpf_dispatcher_prog *bpf_dispatcher_find_free(",
            "\tstruct bpf_dispatcher *d)",
            "{",
            "\treturn bpf_dispatcher_find_prog(d, NULL);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "该代码块定义了BPF调度器的辅助函数，用于查找已注册的BPF程序或空闲槽位。bpf_dispatcher_find_prog遍历调度器槽位以匹配指定程序，返回对应项指针；bpf_dispatcher_find_free用于定位未占用的槽位，为后续程序注册做准备。",
          "similarity": 0.5699930191040039
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/dispatcher.c",
          "start_line": 43,
          "end_line": 166,
          "content": [
            "static bool bpf_dispatcher_add_prog(struct bpf_dispatcher *d,",
            "\t\t\t\t    struct bpf_prog *prog)",
            "{",
            "\tstruct bpf_dispatcher_prog *entry;",
            "",
            "\tif (!prog)",
            "\t\treturn false;",
            "",
            "\tentry = bpf_dispatcher_find_prog(d, prog);",
            "\tif (entry) {",
            "\t\trefcount_inc(&entry->users);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tentry = bpf_dispatcher_find_free(d);",
            "\tif (!entry)",
            "\t\treturn false;",
            "",
            "\tbpf_prog_inc(prog);",
            "\tentry->prog = prog;",
            "\trefcount_set(&entry->users, 1);",
            "\td->num_progs++;",
            "\treturn true;",
            "}",
            "static bool bpf_dispatcher_remove_prog(struct bpf_dispatcher *d,",
            "\t\t\t\t       struct bpf_prog *prog)",
            "{",
            "\tstruct bpf_dispatcher_prog *entry;",
            "",
            "\tif (!prog)",
            "\t\treturn false;",
            "",
            "\tentry = bpf_dispatcher_find_prog(d, prog);",
            "\tif (!entry)",
            "\t\treturn false;",
            "",
            "\tif (refcount_dec_and_test(&entry->users)) {",
            "\t\tentry->prog = NULL;",
            "\t\tbpf_prog_put(prog);",
            "\t\td->num_progs--;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "int __weak arch_prepare_bpf_dispatcher(void *image, void *buf, s64 *funcs, int num_funcs)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static int bpf_dispatcher_prepare(struct bpf_dispatcher *d, void *image, void *buf)",
            "{",
            "\ts64 ips[BPF_DISPATCHER_MAX] = {}, *ipsp = &ips[0];",
            "\tint i;",
            "",
            "\tfor (i = 0; i < BPF_DISPATCHER_MAX; i++) {",
            "\t\tif (d->progs[i].prog)",
            "\t\t\t*ipsp++ = (s64)(uintptr_t)d->progs[i].prog->bpf_func;",
            "\t}",
            "\treturn arch_prepare_bpf_dispatcher(image, buf, &ips[0], d->num_progs);",
            "}",
            "static void bpf_dispatcher_update(struct bpf_dispatcher *d, int prev_num_progs)",
            "{",
            "\tvoid *new, *tmp;",
            "\tu32 noff = 0;",
            "",
            "\tif (prev_num_progs)",
            "\t\tnoff = d->image_off ^ (PAGE_SIZE / 2);",
            "",
            "\tnew = d->num_progs ? d->image + noff : NULL;",
            "\ttmp = d->num_progs ? d->rw_image + noff : NULL;",
            "\tif (new) {",
            "\t\t/* Prepare the dispatcher in d->rw_image. Then use",
            "\t\t * bpf_arch_text_copy to update d->image, which is RO+X.",
            "\t\t */",
            "\t\tif (bpf_dispatcher_prepare(d, new, tmp))",
            "\t\t\treturn;",
            "\t\tif (IS_ERR(bpf_arch_text_copy(new, tmp, PAGE_SIZE / 2)))",
            "\t\t\treturn;",
            "\t}",
            "",
            "\t__BPF_DISPATCHER_UPDATE(d, new ?: (void *)&bpf_dispatcher_nop_func);",
            "",
            "\t/* Make sure all the callers executing the previous/old half of the",
            "\t * image leave it, so following update call can modify it safely.",
            "\t */",
            "\tsynchronize_rcu();",
            "",
            "\tif (new)",
            "\t\td->image_off = noff;",
            "}",
            "void bpf_dispatcher_change_prog(struct bpf_dispatcher *d, struct bpf_prog *from,",
            "\t\t\t\tstruct bpf_prog *to)",
            "{",
            "\tbool changed = false;",
            "\tint prev_num_progs;",
            "",
            "\tif (from == to)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&d->mutex);",
            "\tif (!d->image) {",
            "\t\td->image = bpf_prog_pack_alloc(PAGE_SIZE, bpf_jit_fill_hole_with_zero);",
            "\t\tif (!d->image)",
            "\t\t\tgoto out;",
            "\t\td->rw_image = bpf_jit_alloc_exec(PAGE_SIZE);",
            "\t\tif (!d->rw_image) {",
            "\t\t\tbpf_prog_pack_free(d->image, PAGE_SIZE);",
            "\t\t\td->image = NULL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tbpf_image_ksym_init(d->image, PAGE_SIZE, &d->ksym);",
            "\t\tbpf_image_ksym_add(&d->ksym);",
            "\t}",
            "",
            "\tprev_num_progs = d->num_progs;",
            "\tchanged |= bpf_dispatcher_remove_prog(d, from);",
            "\tchanged |= bpf_dispatcher_add_prog(d, to);",
            "",
            "\tif (!changed)",
            "\t\tgoto out;",
            "",
            "\tbpf_dispatcher_update(d, prev_num_progs);",
            "out:",
            "\tmutex_unlock(&d->mutex);",
            "}"
          ],
          "function_name": "bpf_dispatcher_add_prog, bpf_dispatcher_remove_prog, arch_prepare_bpf_dispatcher, bpf_dispatcher_prepare, bpf_dispatcher_update, bpf_dispatcher_change_prog",
          "description": "该代码块实现了BPF调度器的增删改逻辑及图像更新。bpf_dispatcher_add_prog/bpf_dispatcher_remove_prog管理程序注册与解注册，arch_prepare_bpf_dispatcher为架构弱符号接口，bpf_dispatcher_prepare收集程序函数地址，bpf_dispatcher_update执行安全的图像更新，bpf_dispatcher_change_prog协调程序替换流程并触发更新操作。",
          "similarity": 0.5588346123695374
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_log2l.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:59:34\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_log2l.c`\n\n---\n\n# bpf_log2l.c 技术文档\n\n## 文件概述\n\n`bpf/bpf_log2l.c` 实现了一个名为 `bpf_log2l` 的 BPF 内核函数（kfunc），用于计算正整数 `unsigned long` 类型值以 2 为底的对数向下取整结果。该函数通过 BPF kfunc 机制暴露给多种 BPF 程序类型使用，便于在 BPF 程序中高效执行对数运算，常用于性能分析、哈希桶索引计算等场景。\n\n## 核心功能\n\n### 函数\n\n- **`bpf_log2l(unsigned long v)`**  \n  计算正整数 `v` 的 floor(log₂(v))，返回 `unsigned int` 类型结果。  \n  该函数被标记为 `__bpf_kfunc`，表示其为可被 BPF 程序调用的内核函数。\n\n- **`bpf_log2l_kfunc_init(void)`**  \n  模块初始化函数，负责将 `bpf_log2l` 注册到多个 BPF 程序类型中，使其在对应上下文中可用。\n\n### 数据结构\n\n- **`bpf_log2l_ids`**  \n  BTF（BPF Type Format）ID 集合，通过 `BTF_SET8_START/END` 宏定义，包含 `bpf_log2l` 函数的 BTF 标识及其标志。\n\n- **`log2l_kfunc_set`**  \n  `struct btf_kfunc_id_set` 类型的静态常量结构体，将 `bpf_log2l_ids` 与当前模块（`THIS_MODULE`）绑定，用于 kfunc 注册。\n\n## 关键实现\n\n- **对数计算逻辑**：  \n  函数 `bpf_log2l` 并非直接计算对数，而是通过组合内核已有函数实现：\n  ```c\n  return ilog2(roundup_pow_of_two(v));\n  ```\n  其中：\n  - `roundup_pow_of_two(v)` 将 `v` 向上舍入到不小于它的最小 2 的幂；\n  - `ilog2(x)` 返回 `x` 的以 2 为底的对数（要求 `x` 为 2 的幂）。\n  \n  该组合等价于 `floor(log2(v))`。例如：\n  - 若 `v = 5`，`roundup_pow_of_two(5) = 8`，`ilog2(8) = 3`，即 ⌊log₂5⌋ = 2？  \n    **注意**：此处存在逻辑偏差。实际上，`ilog2(roundup_pow_of_two(v))` 等于 `ceil(log2(v))`（当 `v` 不是 2 的幂时），而非 `floor(log2(v))`。\n\n  **更正说明**：  \n  根据 Linux 内核 `ilog2` 和 `roundup_pow_of_two` 的行为：\n  - 当 `v` 是 2 的幂时，`roundup_pow_of_two(v) == v`，结果正确；\n  - 当 `v` 不是 2 的幂时，`roundup_pow_of_two(v) = 1UL << (fls(v-1))`，因此 `ilog2(...)` 返回的是 `fls(v-1)`，即 `floor(log2(v)) + 1`，**这实际上是 `ceil(log2(v))`**。\n\n  **正确实现应为**：\n  ```c\n  return v ? ilog2(v) : 0; // 或处理 v==0 的情况\n  ```\n  但当前代码采用 `ilog2(roundup_pow_of_two(v))`，其语义为 **“不小于 log₂(v) 的最小整数”**，即向上取整（当 v>1 且非 2 的幂时）。  \n  **文档注释中“floor”描述有误，实际行为为 ceil(log2(v))（v>0）**。\n\n- **BPF kfunc 注册机制**：  \n  使用 `BTF_SET8_START/END` 宏定义函数 ID 集合，并通过 `register_btf_kfunc_id_set()` 将该集合注册到多个 BPF 程序类型，确保 BPF 验证器允许这些程序调用 `bpf_log2l`。\n\n- **初始化时机**：  \n  通过 `late_initcall` 宏注册初始化函数，保证在内核启动后期、BPF 子系统已初始化后执行注册。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/bpf.h>`：提供 BPF 相关宏和类型定义；\n  - `<linux/btf_ids.h>`：提供 BTF kfunc ID 集合定义宏（如 `BTF_SET8_START`）；\n  - `<linux/log2.h>`：提供 `ilog2()` 和 `roundup_pow_of_two()` 函数；\n  - `<linux/init.h>`：提供 `__init` 和 `late_initcall`；\n  - `<linux/module.h>`：提供 `THIS_MODULE`。\n\n- **内核子系统依赖**：\n  - BPF 子系统：依赖 BPF kfunc 注册机制和 BTF 类型信息；\n  - 内核通用库：依赖 `ilog2` 等位操作函数。\n\n## 使用场景\n\n- **BPF 程序中的对数计算**：  \n  在需要根据数值大小动态选择桶索引、计算哈希表层级、或进行性能采样率调整等场景中，BPF 程序可调用 `bpf_log2l` 快速获取对数近似值。\n\n- **支持的 BPF 程序类型**：\n  - `BPF_PROG_TYPE_SOCKET_FILTER`：网络包过滤；\n  - `BPF_PROG_TYPE_TRACING`：fentry/fexit、raw tracepoint 等跟踪程序；\n  - `BPF_PROG_TYPE_SYSCALL`：系统调用拦截；\n  - `BPF_PROG_TYPE_LSM`：Linux 安全模块钩子；\n  - `BPF_PROG_TYPE_STRUCT_OPS`：结构体操作重载；\n  - `BPF_PROG_TYPE_UNSPEC`：通用注册（可能用于未来扩展）。\n\n- **典型应用示例**：\n  ```c\n  // BPF 程序中\n  unsigned long size = ...;\n  int bucket = bpf_log2l(size); // 用于索引直方图数组\n  ```",
      "similarity": 0.6169313788414001,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_log2l.c",
          "start_line": 29,
          "end_line": 58,
          "content": [
            "__bpf_kfunc unsigned int bpf_log2l(unsigned long v)",
            "{",
            "\treturn ilog2(roundup_pow_of_two(v));",
            "}",
            "static int __init bpf_log2l_kfunc_init(void)",
            "{",
            "\t/* Array of BPF program types to register the kfunc for.",
            "\t * Extend this list for new program types.",
            "\t */",
            "\tint prog_types[] = {",
            "\t\tBPF_PROG_TYPE_SOCKET_FILTER,",
            "\t\tBPF_PROG_TYPE_TRACING,",
            "\t\tBPF_PROG_TYPE_SYSCALL,",
            "\t\tBPF_PROG_TYPE_LSM,",
            "\t\tBPF_PROG_TYPE_STRUCT_OPS,",
            "\t\tBPF_PROG_TYPE_UNSPEC,",
            "\t};",
            "",
            "\tfor (int i = 0; i < ARRAY_SIZE(prog_types); i++) {",
            "\t\tint err = register_btf_kfunc_id_set(prog_types[i],",
            "\t\t\t\t\t\t    &log2l_kfunc_set);",
            "\t\tif (err) {",
            "\t\t\tpr_err(\"Failed to register bpf_log2l for prog type %d: %d\\n\",",
            "\t\t\t       prog_types[i], err);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_log2l, bpf_log2l_kfunc_init",
          "description": "实现bpf_log2l函数计算逻辑并通过bpf_log2l_kfunc_init注册到多种BPF程序类型，通过向上取整后应用ilog2获取二进制位数",
          "similarity": 0.5766377449035645
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_log2l.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * This file contains the implementation of the bpf_log2l function, which",
            " * computes the floor of the base-2 logarithm of a positive long integer. It",
            " * is exposed as a BPF kernel function (kfunc) to be used by various BPF",
            " * program types.",
            " *",
            " * Copyright (C) 2025 KylinSoft Corporation",
            " * Author: Jackie Liu <liuyun01@kylinos.cn>",
            " *",
            " */",
            "#include <linux/bpf.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/log2.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>  /* Provides THIS_MODULE */",
            "",
            "__bpf_kfunc_start_defs();",
            "",
            "/**",
            " * bpf_log2l - Compute the floor of the base-2 logarithm of a positive long.",
            " * @v: A positive long integer.",
            " *",
            " * This function returns the floor of log2(v) for positive values.",
            " * It is exposed as a BPF kernel function (kfunc) so that various BPF",
            " * program types can call it.",
            " */"
          ],
          "function_name": null,
          "description": "定义bpf_log2l函数原型，作为BPF内核函数暴露给BPF程序使用，计算正long整数的以2为底的对数下取整值",
          "similarity": 0.5760570764541626
        }
      ]
    }
  ]
}