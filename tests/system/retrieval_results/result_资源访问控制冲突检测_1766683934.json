{
  "query": "资源访问控制冲突检测",
  "timestamp": "2025-12-26 01:32:14",
  "retrieved_files": [
    {
      "source_file": "kernel/kcsan/core.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:17:10\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kcsan\\core.c`\n\n---\n\n# kcsan/core.c 技术文档\n\n## 文件概述\n\n`kcsan/core.c` 是内核竞争条件检测器（KCSAN, Kernel Concurrency Sanitizer）的核心运行时实现文件。该文件负责管理观察点（watchpoints）的设置、查找与清除，实现对并发内存访问冲突的动态检测。KCSAN 通过概率性地监视内存访问，无需对所有内存访问进行插桩，从而在较低性能开销下检测数据竞争。\n\n## 核心功能\n\n### 主要全局变量\n- `kcsan_enabled`：控制 KCSAN 是否启用的全局开关。\n- `watchpoints[]`：原子长整型数组，用于存储编码后的观察点信息。\n- `kcsan_cpu_ctx`：每个 CPU 的上下文结构，用于中断上下文中的 KCSAN 状态管理。\n- 模块参数（可通过 `/sys/module/kcsan/parameters/` 调整）：\n  - `early_enable`：是否在早期启动阶段启用 KCSAN。\n  - `udelay_task` / `udelay_interrupt`：任务/中断上下文中检测前的延迟微秒数。\n  - `skip_watch`：跳过监视的指令计数器。\n  - `interrupt_watcher`：是否监视中断上下文中的访问。\n  - `weak_memory`（仅当 `CONFIG_KCSAN_WEAK_MEMORY` 启用）：是否启用弱内存序检测。\n\n### 主要函数\n- `find_watchpoint()`：在观察点表中查找与给定地址范围匹配的观察点。\n- `insert_watchpoint()`：尝试将新的观察点插入观察点表。\n- `try_consume_watchpoint()` / `consume_watchpoint()` / `remove_watchpoint()`：管理观察点的消费与移除。\n- `get_ctx()`：获取当前执行上下文（任务或中断）的 KCSAN 上下文。\n- `kcsan_check_scoped_accesses()`：检查当前上下文中注册的作用域访问（scoped accesses）。\n\n### 核心数据结构\n- `struct kcsan_ctx`：KCSAN 执行上下文，包含作用域访问链表、禁用标志等。\n- `struct kcsan_scoped_access`：表示一个作用域内的内存访问，用于延迟检查。\n\n## 关键实现\n\n### 观察点管理\n- **编码存储**：每个观察点通过 `encode_watchpoint()` 编码为单个 `atomic_long_t`，包含地址、大小和访问类型（读/写），避免使用锁。\n- **槽位索引策略**：\n  - 使用 `watchpoint_slot(addr)` 将地址映射到主槽位。\n  - 通过 `SLOT_IDX` 和 `SLOT_IDX_FAST` 宏支持检查相邻槽位（由 `KCSAN_CHECK_ADJACENT` 控制），以处理跨槽访问和槽位冲突。\n  - 数组大小为 `CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS - 1`，避免快速路径中的取模运算。\n- **无锁操作**：使用 `atomic_long_try_cmpxchg_relaxed()` 实现观察点的原子插入和消费。\n\n### 上下文管理\n- **双上下文支持**：任务上下文使用 `current->kcsan_ctx`，中断上下文使用 per-CPU 变量 `kcsan_cpu_ctx`。\n- **作用域访问**：通过链表管理延迟检查的访问（如 `kcsan_check_scoped_accesses()`），避免在禁用区域内重复检查。\n\n### 检测逻辑\n- **概率性检测**：通过 `kcsan_skip` 计数器和随机延迟（`kcsan_udelay_*`）控制检测频率，平衡开销与覆盖率。\n- **原子访问识别**：根据访问类型标志（`KCSAN_ACCESS_ATOMIC`、`KCSAN_ACCESS_ASSERT`）和配置（`CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC`）判断访问是否为原子操作，避免误报。\n\n## 依赖关系\n\n- **内部依赖**：\n  - `encoding.h`：提供观察点的编码/解码函数。\n  - `kcsan.h`：定义核心数据结构和常量。\n  - `permissive.h`：提供宽松模式下的行为控制。\n- **内核子系统**：\n  - 调度器（`linux/sched.h`）：用于获取当前任务上下文。\n  - 原子操作（`linux/atomic.h`）：实现无锁观察点管理。\n  - Per-CPU 变量（`linux/percpu.h`）：管理中断上下文状态。\n  - 内存访问（`linux/uaccess.h`）：处理用户空间访问区域。\n\n## 使用场景\n\n- **数据竞争检测**：在 SMP 系统中检测未同步的并发内存访问（如未加锁的共享变量读写）。\n- **开发与调试**：内核开发者启用 KCSAN 后，可在运行时捕获竞争条件，通过报告定位问题代码。\n- **中断与任务交互**：通过 `kcsan_interrupt_watcher` 参数控制是否检测中断与任务之间的竞争。\n- **弱内存序系统**：在启用 `CONFIG_KCSAN_WEAK_MEMORY` 的架构（如 ARM、RISC-V）上检测内存重排序导致的竞争。",
      "similarity": 0.6060331463813782,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/kcsan/core.c",
          "start_line": 315,
          "end_line": 418,
          "content": [
            "static __always_inline bool kcsan_is_enabled(struct kcsan_ctx *ctx)",
            "{",
            "\treturn READ_ONCE(kcsan_enabled) && !ctx->disable_count;",
            "}",
            "static void delay_access(int type)",
            "{",
            "\tunsigned int delay = in_task() ? kcsan_udelay_task : kcsan_udelay_interrupt;",
            "\t/* For certain access types, skew the random delay to be longer. */",
            "\tunsigned int skew_delay_order =",
            "\t\t(type & (KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_ASSERT)) ? 1 : 0;",
            "",
            "\tdelay -= IS_ENABLED(CONFIG_KCSAN_DELAY_RANDOMIZE) ?",
            "\t\t\t       kcsan_prandom_u32_max(delay >> skew_delay_order) :",
            "\t\t\t       0;",
            "\tudelay(delay);",
            "}",
            "static __always_inline u64 read_instrumented_memory(const volatile void *ptr, size_t size)",
            "{",
            "\t/*",
            "\t * In the below we don't necessarily need the read of the location to",
            "\t * be atomic, and we don't use READ_ONCE(), since all we need for race",
            "\t * detection is to observe 2 different values.",
            "\t *",
            "\t * Furthermore, on certain architectures (such as arm64), READ_ONCE()",
            "\t * may turn into more complex instructions than a plain load that cannot",
            "\t * do unaligned accesses.",
            "\t */",
            "\tswitch (size) {",
            "\tcase 1:  return *(const volatile u8 *)ptr;",
            "\tcase 2:  return *(const volatile u16 *)ptr;",
            "\tcase 4:  return *(const volatile u32 *)ptr;",
            "\tcase 8:  return *(const volatile u64 *)ptr;",
            "\tdefault: return 0; /* Ignore; we do not diff the values. */",
            "\t}",
            "}",
            "void kcsan_save_irqtrace(struct task_struct *task)",
            "{",
            "#ifdef CONFIG_TRACE_IRQFLAGS",
            "\ttask->kcsan_save_irqtrace = task->irqtrace;",
            "#endif",
            "}",
            "void kcsan_restore_irqtrace(struct task_struct *task)",
            "{",
            "#ifdef CONFIG_TRACE_IRQFLAGS",
            "\ttask->irqtrace = task->kcsan_save_irqtrace;",
            "#endif",
            "}",
            "static __always_inline int get_kcsan_stack_depth(void)",
            "{",
            "#ifdef CONFIG_KCSAN_WEAK_MEMORY",
            "\treturn current->kcsan_stack_depth;",
            "#else",
            "\tBUILD_BUG();",
            "\treturn 0;",
            "#endif",
            "}",
            "static __always_inline void add_kcsan_stack_depth(int val)",
            "{",
            "#ifdef CONFIG_KCSAN_WEAK_MEMORY",
            "\tcurrent->kcsan_stack_depth += val;",
            "#else",
            "\tBUILD_BUG();",
            "#endif",
            "}",
            "static __always_inline bool",
            "find_reorder_access(struct kcsan_ctx *ctx, const volatile void *ptr, size_t size,",
            "\t\t    int type, unsigned long ip)",
            "{",
            "\tstruct kcsan_scoped_access *reorder_access = get_reorder_access(ctx);",
            "",
            "\tif (!reorder_access)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Note: If accesses are repeated while reorder_access is identical,",
            "\t * never matches the new access, because !(type & KCSAN_ACCESS_SCOPED).",
            "\t */",
            "\treturn reorder_access->ptr == ptr && reorder_access->size == size &&",
            "\t       reorder_access->type == type && reorder_access->ip == ip;",
            "}",
            "static inline void",
            "set_reorder_access(struct kcsan_ctx *ctx, const volatile void *ptr, size_t size,",
            "\t\t   int type, unsigned long ip)",
            "{",
            "\tstruct kcsan_scoped_access *reorder_access = get_reorder_access(ctx);",
            "",
            "\tif (!reorder_access || !kcsan_weak_memory)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * To avoid nested interrupts or scheduler (which share kcsan_ctx)",
            "\t * reading an inconsistent reorder_access, ensure that the below has",
            "\t * exclusive access to reorder_access by disallowing concurrent use.",
            "\t */",
            "\tctx->disable_scoped++;",
            "\tbarrier();",
            "\treorder_access->ptr\t\t= ptr;",
            "\treorder_access->size\t\t= size;",
            "\treorder_access->type\t\t= type | KCSAN_ACCESS_SCOPED;",
            "\treorder_access->ip\t\t= ip;",
            "\treorder_access->stack_depth\t= get_kcsan_stack_depth();",
            "\tbarrier();",
            "\tctx->disable_scoped--;",
            "}"
          ],
          "function_name": "kcsan_is_enabled, delay_access, read_instrumented_memory, kcsan_save_irqtrace, kcsan_restore_irqtrace, get_kcsan_stack_depth, add_kcsan_stack_depth, find_reorder_access, set_reorder_access",
          "description": "包含内存访问检查基础设施，提供延迟注入、受监控内存读取、中断跟踪保护及重排访问追踪功能，支持栈深度管理与跨中断上下文的访问顺序检测。",
          "similarity": 0.6410513520240784
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/kcsan/core.c",
          "start_line": 718,
          "end_line": 821,
          "content": [
            "static __always_inline void",
            "check_access(const volatile void *ptr, size_t size, int type, unsigned long ip)",
            "{",
            "\tatomic_long_t *watchpoint;",
            "\tlong encoded_watchpoint;",
            "",
            "\t/*",
            "\t * Do nothing for 0 sized check; this comparison will be optimized out",
            "\t * for constant sized instrumentation (__tsan_{read,write}N).",
            "\t */",
            "\tif (unlikely(size == 0))",
            "\t\treturn;",
            "",
            "again:",
            "\t/*",
            "\t * Avoid user_access_save in fast-path: find_watchpoint is safe without",
            "\t * user_access_save, as the address that ptr points to is only used to",
            "\t * check if a watchpoint exists; ptr is never dereferenced.",
            "\t */",
            "\twatchpoint = find_watchpoint((unsigned long)ptr, size,",
            "\t\t\t\t     !(type & KCSAN_ACCESS_WRITE),",
            "\t\t\t\t     &encoded_watchpoint);",
            "\t/*",
            "\t * It is safe to check kcsan_is_enabled() after find_watchpoint in the",
            "\t * slow-path, as long as no state changes that cause a race to be",
            "\t * detected and reported have occurred until kcsan_is_enabled() is",
            "\t * checked.",
            "\t */",
            "",
            "\tif (unlikely(watchpoint != NULL))",
            "\t\tkcsan_found_watchpoint(ptr, size, type, ip, watchpoint, encoded_watchpoint);",
            "\telse {",
            "\t\tstruct kcsan_ctx *ctx = get_ctx(); /* Call only once in fast-path. */",
            "",
            "\t\tif (unlikely(should_watch(ctx, ptr, size, type))) {",
            "\t\t\tkcsan_setup_watchpoint(ptr, size, type, ip);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tif (!(type & KCSAN_ACCESS_SCOPED)) {",
            "\t\t\tstruct kcsan_scoped_access *reorder_access = get_reorder_access(ctx);",
            "",
            "\t\t\tif (reorder_access) {",
            "\t\t\t\t/*",
            "\t\t\t\t * reorder_access check: simulates reordering of",
            "\t\t\t\t * the access after subsequent operations.",
            "\t\t\t\t */",
            "\t\t\t\tptr = reorder_access->ptr;",
            "\t\t\t\ttype = reorder_access->type;",
            "\t\t\t\tip = reorder_access->ip;",
            "\t\t\t\t/*",
            "\t\t\t\t * Upon a nested interrupt, this context's",
            "\t\t\t\t * reorder_access can be modified (shared ctx).",
            "\t\t\t\t * We know that upon return, reorder_access is",
            "\t\t\t\t * always invalidated by setting size to 0 via",
            "\t\t\t\t * __tsan_func_exit(). Therefore we must read",
            "\t\t\t\t * and check size after the other fields.",
            "\t\t\t\t */",
            "\t\t\t\tbarrier();",
            "\t\t\t\tsize = READ_ONCE(reorder_access->size);",
            "\t\t\t\tif (size)",
            "\t\t\t\t\tgoto again;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Always checked last, right before returning from runtime;",
            "\t\t * if reorder_access is valid, checked after it was checked.",
            "\t\t */",
            "\t\tif (unlikely(ctx->scoped_accesses.prev))",
            "\t\t\tkcsan_check_scoped_accesses();",
            "\t}",
            "}",
            "void __init kcsan_init(void)",
            "{",
            "\tint cpu;",
            "",
            "\tBUG_ON(!in_task());",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tper_cpu(kcsan_rand_state, cpu) = (u32)get_cycles();",
            "",
            "\t/*",
            "\t * We are in the init task, and no other tasks should be running;",
            "\t * WRITE_ONCE without memory barrier is sufficient.",
            "\t */",
            "\tif (kcsan_early_enable) {",
            "\t\tpr_info(\"enabled early\\n\");",
            "\t\tWRITE_ONCE(kcsan_enabled, true);",
            "\t}",
            "",
            "\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) ||",
            "\t    IS_ENABLED(CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC) ||",
            "\t    IS_ENABLED(CONFIG_KCSAN_PERMISSIVE) ||",
            "\t    IS_ENABLED(CONFIG_KCSAN_IGNORE_ATOMICS)) {",
            "\t\tpr_warn(\"non-strict mode configured - use CONFIG_KCSAN_STRICT=y to see all data races\\n\");",
            "\t} else {",
            "\t\tpr_info(\"strict mode configured\\n\");",
            "\t}",
            "}",
            "void kcsan_disable_current(void)",
            "{",
            "\t++get_ctx()->disable_count;",
            "}"
          ],
          "function_name": "check_access, kcsan_init, kcsan_disable_current",
          "description": "实现核心访问检查入口(check_access)及系统初始化(kcsan_init)与禁用接口(kcsan_disable_current)，建立上下文感知的监控机制并初始化必要的运行时环境。",
          "similarity": 0.5778949856758118
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/kcsan/core.c",
          "start_line": 1111,
          "end_line": 1171,
          "content": [
            "noinline void __tsan_func_exit(void)",
            "{",
            "\tstruct kcsan_scoped_access *reorder_access;",
            "",
            "\tif (!IS_ENABLED(CONFIG_KCSAN_WEAK_MEMORY))",
            "\t\treturn;",
            "",
            "\treorder_access = get_reorder_access(get_ctx());",
            "\tif (!reorder_access)",
            "\t\tgoto out;",
            "",
            "\tif (get_kcsan_stack_depth() <= reorder_access->stack_depth) {",
            "\t\t/*",
            "\t\t * Access check to catch cases where write without a barrier",
            "\t\t * (supposed release) was last access in function: because",
            "\t\t * instrumentation is inserted before the real access, a data",
            "\t\t * race due to the write giving up a c-s would only be caught if",
            "\t\t * we do the conflicting access after.",
            "\t\t */",
            "\t\tcheck_access(reorder_access->ptr, reorder_access->size,",
            "\t\t\t     reorder_access->type, reorder_access->ip);",
            "\t\treorder_access->size = 0;",
            "\t\treorder_access->stack_depth = INT_MIN;",
            "\t}",
            "out:",
            "\tadd_kcsan_stack_depth(-1);",
            "}",
            "void __tsan_init(void)",
            "{",
            "}",
            "static __always_inline void kcsan_atomic_builtin_memorder(int memorder)",
            "{",
            "\tif (memorder == __ATOMIC_RELEASE ||",
            "\t    memorder == __ATOMIC_SEQ_CST ||",
            "\t    memorder == __ATOMIC_ACQ_REL)",
            "\t\t__kcsan_release();",
            "}",
            "void __tsan_atomic_thread_fence(int memorder)",
            "{",
            "\tkcsan_atomic_builtin_memorder(memorder);",
            "\t__atomic_thread_fence(memorder);",
            "}",
            "noinline void __tsan_atomic_signal_fence(int memorder)",
            "{",
            "\tswitch (memorder) {",
            "\tcase __KCSAN_BARRIER_TO_SIGNAL_FENCE_mb:",
            "\t\t__kcsan_mb();",
            "\t\tbreak;",
            "\tcase __KCSAN_BARRIER_TO_SIGNAL_FENCE_wmb:",
            "\t\t__kcsan_wmb();",
            "\t\tbreak;",
            "\tcase __KCSAN_BARRIER_TO_SIGNAL_FENCE_rmb:",
            "\t\t__kcsan_rmb();",
            "\t\tbreak;",
            "\tcase __KCSAN_BARRIER_TO_SIGNAL_FENCE_release:",
            "\t\t__kcsan_release();",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "}"
          ],
          "function_name": "__tsan_func_exit, __tsan_init, kcsan_atomic_builtin_memorder, __tsan_atomic_thread_fence, __tsan_atomic_signal_fence",
          "description": "该代码块实现KCSAN的内存序处理与函数边界检查逻辑。__tsan_func_exit在函数退出时检查潜在的数据竞争，通过比较堆栈深度判断是否需执行访问检查。__tsan_init为空实现。kcsan_atomic_builtin_memorder根据内存序类型注入对应的KCSAN释放屏障。__tsan_atomic_*系列函数封装了对原子内存屏障（thread_fence/signal_fence）的插桩处理，通过条件分支选择不同类型的内存屏障指令以满足不同的同步需求。",
          "similarity": 0.5632646083831787
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kcsan/core.c",
          "start_line": 182,
          "end_line": 286,
          "content": [
            "static __always_inline bool",
            "try_consume_watchpoint(atomic_long_t *watchpoint, long encoded_watchpoint)",
            "{",
            "\treturn atomic_long_try_cmpxchg_relaxed(watchpoint, &encoded_watchpoint, CONSUMED_WATCHPOINT);",
            "}",
            "static inline bool consume_watchpoint(atomic_long_t *watchpoint)",
            "{",
            "\treturn atomic_long_xchg_relaxed(watchpoint, CONSUMED_WATCHPOINT) != CONSUMED_WATCHPOINT;",
            "}",
            "static inline void remove_watchpoint(atomic_long_t *watchpoint)",
            "{",
            "\tatomic_long_set(watchpoint, INVALID_WATCHPOINT);",
            "}",
            "static noinline void kcsan_check_scoped_accesses(void)",
            "{",
            "\tstruct kcsan_ctx *ctx = get_ctx();",
            "\tstruct kcsan_scoped_access *scoped_access;",
            "",
            "\tif (ctx->disable_scoped)",
            "\t\treturn;",
            "",
            "\tctx->disable_scoped++;",
            "\tlist_for_each_entry(scoped_access, &ctx->scoped_accesses, list) {",
            "\t\tcheck_access(scoped_access->ptr, scoped_access->size,",
            "\t\t\t     scoped_access->type, scoped_access->ip);",
            "\t}",
            "\tctx->disable_scoped--;",
            "}",
            "static __always_inline bool",
            "is_atomic(struct kcsan_ctx *ctx, const volatile void *ptr, size_t size, int type)",
            "{",
            "\tif (type & KCSAN_ACCESS_ATOMIC)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Unless explicitly declared atomic, never consider an assertion access",
            "\t * as atomic. This allows using them also in atomic regions, such as",
            "\t * seqlocks, without implicitly changing their semantics.",
            "\t */",
            "\tif (type & KCSAN_ACCESS_ASSERT)",
            "\t\treturn false;",
            "",
            "\tif (IS_ENABLED(CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC) &&",
            "\t    (type & KCSAN_ACCESS_WRITE) && size <= sizeof(long) &&",
            "\t    !(type & KCSAN_ACCESS_COMPOUND) && IS_ALIGNED((unsigned long)ptr, size))",
            "\t\treturn true; /* Assume aligned writes up to word size are atomic. */",
            "",
            "\tif (ctx->atomic_next > 0) {",
            "\t\t/*",
            "\t\t * Because we do not have separate contexts for nested",
            "\t\t * interrupts, in case atomic_next is set, we simply assume that",
            "\t\t * the outer interrupt set atomic_next. In the worst case, we",
            "\t\t * will conservatively consider operations as atomic. This is a",
            "\t\t * reasonable trade-off to make, since this case should be",
            "\t\t * extremely rare; however, even if extremely rare, it could",
            "\t\t * lead to false positives otherwise.",
            "\t\t */",
            "\t\tif ((hardirq_count() >> HARDIRQ_SHIFT) < 2)",
            "\t\t\t--ctx->atomic_next; /* in task, or outer interrupt */",
            "\t\treturn true;",
            "\t}",
            "",
            "\treturn ctx->atomic_nest_count > 0 || ctx->in_flat_atomic;",
            "}",
            "static __always_inline bool",
            "should_watch(struct kcsan_ctx *ctx, const volatile void *ptr, size_t size, int type)",
            "{",
            "\t/*",
            "\t * Never set up watchpoints when memory operations are atomic.",
            "\t *",
            "\t * Need to check this first, before kcsan_skip check below: (1) atomics",
            "\t * should not count towards skipped instructions, and (2) to actually",
            "\t * decrement kcsan_atomic_next for consecutive instruction stream.",
            "\t */",
            "\tif (is_atomic(ctx, ptr, size, type))",
            "\t\treturn false;",
            "",
            "\tif (this_cpu_dec_return(kcsan_skip) >= 0)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * NOTE: If we get here, kcsan_skip must always be reset in slow path",
            "\t * via reset_kcsan_skip() to avoid underflow.",
            "\t */",
            "",
            "\t/* this operation should be watched */",
            "\treturn true;",
            "}",
            "static u32 kcsan_prandom_u32_max(u32 ep_ro)",
            "{",
            "\tu32 state = this_cpu_read(kcsan_rand_state);",
            "",
            "\tstate = 1664525 * state + 1013904223;",
            "\tthis_cpu_write(kcsan_rand_state, state);",
            "",
            "\treturn state % ep_ro;",
            "}",
            "static inline void reset_kcsan_skip(void)",
            "{",
            "\tlong skip_count = kcsan_skip_watch -",
            "\t\t\t  (IS_ENABLED(CONFIG_KCSAN_SKIP_WATCH_RANDOMIZE) ?",
            "\t\t\t\t   kcsan_prandom_u32_max(kcsan_skip_watch) :",
            "\t\t\t\t   0);",
            "\tthis_cpu_write(kcsan_skip, skip_count);",
            "}"
          ],
          "function_name": "try_consume_watchpoint, consume_watchpoint, remove_watchpoint, kcsan_check_scoped_accesses, is_atomic, should_watch, kcsan_prandom_u32_max, reset_kcsan_skip",
          "description": "实现了监视点状态管理相关函数（try_consume_watchpoint、consume_watchpoint等），提供原子性判断、跳过指令计数控制及随机数生成功能，用于动态决策是否需设置监视点。",
          "similarity": 0.5565584897994995
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/kcsan/core.c",
          "start_line": 455,
          "end_line": 715,
          "content": [
            "static noinline void kcsan_found_watchpoint(const volatile void *ptr,",
            "\t\t\t\t\t    size_t size,",
            "\t\t\t\t\t    int type,",
            "\t\t\t\t\t    unsigned long ip,",
            "\t\t\t\t\t    atomic_long_t *watchpoint,",
            "\t\t\t\t\t    long encoded_watchpoint)",
            "{",
            "\tconst bool is_assert = (type & KCSAN_ACCESS_ASSERT) != 0;",
            "\tstruct kcsan_ctx *ctx = get_ctx();",
            "\tunsigned long flags;",
            "\tbool consumed;",
            "",
            "\t/*",
            "\t * We know a watchpoint exists. Let's try to keep the race-window",
            "\t * between here and finally consuming the watchpoint below as small as",
            "\t * possible -- avoid unneccessarily complex code until consumed.",
            "\t */",
            "",
            "\tif (!kcsan_is_enabled(ctx))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * The access_mask check relies on value-change comparison. To avoid",
            "\t * reporting a race where e.g. the writer set up the watchpoint, but the",
            "\t * reader has access_mask!=0, we have to ignore the found watchpoint.",
            "\t *",
            "\t * reorder_access is never created from an access with access_mask set.",
            "\t */",
            "\tif (ctx->access_mask && !find_reorder_access(ctx, ptr, size, type, ip))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * If the other thread does not want to ignore the access, and there was",
            "\t * a value change as a result of this thread's operation, we will still",
            "\t * generate a report of unknown origin.",
            "\t *",
            "\t * Use CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN=n to filter.",
            "\t */",
            "\tif (!is_assert && kcsan_ignore_address(ptr))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Consuming the watchpoint must be guarded by kcsan_is_enabled() to",
            "\t * avoid erroneously triggering reports if the context is disabled.",
            "\t */",
            "\tconsumed = try_consume_watchpoint(watchpoint, encoded_watchpoint);",
            "",
            "\t/* keep this after try_consume_watchpoint */",
            "\tflags = user_access_save();",
            "",
            "\tif (consumed) {",
            "\t\tkcsan_save_irqtrace(current);",
            "\t\tkcsan_report_set_info(ptr, size, type, ip, watchpoint - watchpoints);",
            "\t\tkcsan_restore_irqtrace(current);",
            "\t} else {",
            "\t\t/*",
            "\t\t * The other thread may not print any diagnostics, as it has",
            "\t\t * already removed the watchpoint, or another thread consumed",
            "\t\t * the watchpoint before this thread.",
            "\t\t */",
            "\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_REPORT_RACES]);",
            "\t}",
            "",
            "\tif (is_assert)",
            "\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_ASSERT_FAILURES]);",
            "\telse",
            "\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_DATA_RACES]);",
            "",
            "\tuser_access_restore(flags);",
            "}",
            "static noinline void",
            "kcsan_setup_watchpoint(const volatile void *ptr, size_t size, int type, unsigned long ip)",
            "{",
            "\tconst bool is_write = (type & KCSAN_ACCESS_WRITE) != 0;",
            "\tconst bool is_assert = (type & KCSAN_ACCESS_ASSERT) != 0;",
            "\tatomic_long_t *watchpoint;",
            "\tu64 old, new, diff;",
            "\tenum kcsan_value_change value_change = KCSAN_VALUE_CHANGE_MAYBE;",
            "\tbool interrupt_watcher = kcsan_interrupt_watcher;",
            "\tunsigned long ua_flags = user_access_save();",
            "\tstruct kcsan_ctx *ctx = get_ctx();",
            "\tunsigned long access_mask = ctx->access_mask;",
            "\tunsigned long irq_flags = 0;",
            "\tbool is_reorder_access;",
            "",
            "\t/*",
            "\t * Always reset kcsan_skip counter in slow-path to avoid underflow; see",
            "\t * should_watch().",
            "\t */",
            "\treset_kcsan_skip();",
            "",
            "\tif (!kcsan_is_enabled(ctx))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Check to-ignore addresses after kcsan_is_enabled(), as we may access",
            "\t * memory that is not yet initialized during early boot.",
            "\t */",
            "\tif (!is_assert && kcsan_ignore_address(ptr))",
            "\t\tgoto out;",
            "",
            "\tif (!check_encodable((unsigned long)ptr, size)) {",
            "\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_UNENCODABLE_ACCESSES]);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * The local CPU cannot observe reordering of its own accesses, and",
            "\t * therefore we need to take care of 2 cases to avoid false positives:",
            "\t *",
            "\t *\t1. Races of the reordered access with interrupts. To avoid, if",
            "\t *\t   the current access is reorder_access, disable interrupts.",
            "\t *\t2. Avoid races of scoped accesses from nested interrupts (below).",
            "\t */",
            "\tis_reorder_access = find_reorder_access(ctx, ptr, size, type, ip);",
            "\tif (is_reorder_access)",
            "\t\tinterrupt_watcher = false;",
            "\t/*",
            "\t * Avoid races of scoped accesses from nested interrupts (or scheduler).",
            "\t * Assume setting up a watchpoint for a non-scoped (normal) access that",
            "\t * also conflicts with a current scoped access. In a nested interrupt,",
            "\t * which shares the context, it would check a conflicting scoped access.",
            "\t * To avoid, disable scoped access checking.",
            "\t */",
            "\tctx->disable_scoped++;",
            "",
            "\t/*",
            "\t * Save and restore the IRQ state trace touched by KCSAN, since KCSAN's",
            "\t * runtime is entered for every memory access, and potentially useful",
            "\t * information is lost if dirtied by KCSAN.",
            "\t */",
            "\tkcsan_save_irqtrace(current);",
            "\tif (!interrupt_watcher)",
            "\t\tlocal_irq_save(irq_flags);",
            "",
            "\twatchpoint = insert_watchpoint((unsigned long)ptr, size, is_write);",
            "\tif (watchpoint == NULL) {",
            "\t\t/*",
            "\t\t * Out of capacity: the size of 'watchpoints', and the frequency",
            "\t\t * with which should_watch() returns true should be tweaked so",
            "\t\t * that this case happens very rarely.",
            "\t\t */",
            "\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_NO_CAPACITY]);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_SETUP_WATCHPOINTS]);",
            "\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_USED_WATCHPOINTS]);",
            "",
            "\t/*",
            "\t * Read the current value, to later check and infer a race if the data",
            "\t * was modified via a non-instrumented access, e.g. from a device.",
            "\t */",
            "\told = is_reorder_access ? 0 : read_instrumented_memory(ptr, size);",
            "",
            "\t/*",
            "\t * Delay this thread, to increase probability of observing a racy",
            "\t * conflicting access.",
            "\t */",
            "\tdelay_access(type);",
            "",
            "\t/*",
            "\t * Re-read value, and check if it is as expected; if not, we infer a",
            "\t * racy access.",
            "\t */",
            "\tif (!is_reorder_access) {",
            "\t\tnew = read_instrumented_memory(ptr, size);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Reordered accesses cannot be used for value change detection,",
            "\t\t * because the memory location may no longer be accessible and",
            "\t\t * could result in a fault.",
            "\t\t */",
            "\t\tnew = 0;",
            "\t\taccess_mask = 0;",
            "\t}",
            "",
            "\tdiff = old ^ new;",
            "\tif (access_mask)",
            "\t\tdiff &= access_mask;",
            "",
            "\t/*",
            "\t * Check if we observed a value change.",
            "\t *",
            "\t * Also check if the data race should be ignored (the rules depend on",
            "\t * non-zero diff); if it is to be ignored, the below rules for",
            "\t * KCSAN_VALUE_CHANGE_MAYBE apply.",
            "\t */",
            "\tif (diff && !kcsan_ignore_data_race(size, type, old, new, diff))",
            "\t\tvalue_change = KCSAN_VALUE_CHANGE_TRUE;",
            "",
            "\t/* Check if this access raced with another. */",
            "\tif (!consume_watchpoint(watchpoint)) {",
            "\t\t/*",
            "\t\t * Depending on the access type, map a value_change of MAYBE to",
            "\t\t * TRUE (always report) or FALSE (never report).",
            "\t\t */",
            "\t\tif (value_change == KCSAN_VALUE_CHANGE_MAYBE) {",
            "\t\t\tif (access_mask != 0) {",
            "\t\t\t\t/*",
            "\t\t\t\t * For access with access_mask, we require a",
            "\t\t\t\t * value-change, as it is likely that races on",
            "\t\t\t\t * ~access_mask bits are expected.",
            "\t\t\t\t */",
            "\t\t\t\tvalue_change = KCSAN_VALUE_CHANGE_FALSE;",
            "\t\t\t} else if (size > 8 || is_assert) {",
            "\t\t\t\t/* Always assume a value-change. */",
            "\t\t\t\tvalue_change = KCSAN_VALUE_CHANGE_TRUE;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * No need to increment 'data_races' counter, as the racing",
            "\t\t * thread already did.",
            "\t\t *",
            "\t\t * Count 'assert_failures' for each failed ASSERT access,",
            "\t\t * therefore both this thread and the racing thread may",
            "\t\t * increment this counter.",
            "\t\t */",
            "\t\tif (is_assert && value_change == KCSAN_VALUE_CHANGE_TRUE)",
            "\t\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_ASSERT_FAILURES]);",
            "",
            "\t\tkcsan_report_known_origin(ptr, size, type, ip,",
            "\t\t\t\t\t  value_change, watchpoint - watchpoints,",
            "\t\t\t\t\t  old, new, access_mask);",
            "\t} else if (value_change == KCSAN_VALUE_CHANGE_TRUE) {",
            "\t\t/* Inferring a race, since the value should not have changed. */",
            "",
            "\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_RACES_UNKNOWN_ORIGIN]);",
            "\t\tif (is_assert)",
            "\t\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_ASSERT_FAILURES]);",
            "",
            "\t\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN) || is_assert) {",
            "\t\t\tkcsan_report_unknown_origin(ptr, size, type, ip,",
            "\t\t\t\t\t\t    old, new, access_mask);",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Remove watchpoint; must be after reporting, since the slot may be",
            "\t * reused after this point.",
            "\t */",
            "\tremove_watchpoint(watchpoint);",
            "\tatomic_long_dec(&kcsan_counters[KCSAN_COUNTER_USED_WATCHPOINTS]);",
            "",
            "out_unlock:",
            "\tif (!interrupt_watcher)",
            "\t\tlocal_irq_restore(irq_flags);",
            "\tkcsan_restore_irqtrace(current);",
            "\tctx->disable_scoped--;",
            "",
            "\t/*",
            "\t * Reordered accesses cannot be used for value change detection,",
            "\t * therefore never consider for reordering if access_mask is set.",
            "\t * ASSERT_EXCLUSIVE are not real accesses, ignore them as well.",
            "\t */",
            "\tif (!access_mask && !is_assert)",
            "\t\tset_reorder_access(ctx, ptr, size, type, ip);",
            "out:",
            "\tuser_access_restore(ua_flags);",
            "}"
          ],
          "function_name": "kcsan_found_watchpoint, kcsan_setup_watchpoint",
          "description": "处理监视点命中后的竞态分析流程，通过值变化检测区分真实竞态与预期变更，根据配置策略生成不同类型的报告，并维护各类统计计数器以评估检测效果。",
          "similarity": 0.5485262870788574
        }
      ]
    },
    {
      "source_file": "kernel/resource_kunit.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:53:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `resource_kunit.c`\n\n---\n\n# resource_kunit.c 技术文档\n\n## 1. 文件概述\n\n`resource_kunit.c` 是 Linux 内核中用于测试资源管理核心 API 的 KUnit 单元测试文件。该文件主要验证 `resource.c` 和 `ioport.h` 中提供的资源区间操作函数（如 `resource_union` 和 `resource_intersection`）的正确性。通过预定义的资源区间组合及其预期结果，系统性地覆盖各种重叠、包含、分离等边界情况，确保资源合并与交集计算逻辑的可靠性。\n\n## 2. 核心功能\n\n### 数据结构\n- **`struct result`**：用于描述测试用例的输入与预期输出，包含两个输入资源指针、预期结果资源结构体和布尔返回值。\n- **预定义资源对象**：`r0` ~ `r4`，代表不同起止地址的资源区间，用于构造测试场景。\n- **测试用例数组**：\n  - `results_for_union[]`：定义 `resource_union` 函数的测试用例。\n  - `results_for_intersection[]`：定义 `resource_intersection` 函数的测试用例。\n\n### 主要函数\n- **`resource_do_test()`**：通用断言函数，用于比较实际结果与预期结果（包括返回值和资源区间）。\n- **`resource_do_union_test()`**：执行单个资源合并测试用例，并验证参数顺序交换后的对称性。\n- **`resource_test_union()`**：遍历所有合并测试用例并执行。\n- **`resource_do_intersection_test()`**：执行单个资源交集测试用例，并验证参数顺序交换后的对称性。\n- **`resource_test_intersection()`**：遍历所有交集测试用例并执行。\n\n## 3. 关键实现\n\n- **对称性验证**：在 `resource_do_union_test` 和 `resource_do_intersection_test` 中，对每对输入资源 `(r1, r2)` 同时测试 `(r1, r2)` 和 `(r2, r1)` 两种顺序，确保函数行为满足交换律。\n- **结果初始化**：每次测试前使用 `memset(&result, 0, sizeof(result))` 清零结果结构体，避免残留数据干扰测试。\n- **全面覆盖边界情况**：\n  - 完全包含（如 `r1` 被 `r0` 包含）\n  - 部分重叠（如 `r4` 与 `r1`、`r3` 与 `r4`）\n  - 无重叠（如 `r2` 与 `r1`、`r2` 与 `r3`）\n- **KUnit 断言机制**：使用 `KUNIT_EXPECT_EQ_MSG` 提供带上下文信息的断言，便于调试失败用例。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<kunit/test.h>`：KUnit 测试框架核心接口。\n  - `<linux/ioport.h>`：提供 `struct resource` 定义及 `resource_union`/`resource_intersection` 函数声明。\n  - `<linux/kernel.h>` 和 `<linux/string.h>`：提供基础内核函数（如 `memset`）。\n- **被测模块**：依赖 `resource.c` 中实现的资源操作函数，属于内核资源管理子系统的一部分。\n- **构建系统**：通过 `kunit_test_suite()` 宏注册测试套件，由 KUnit 框架自动发现并执行。\n\n## 5. 使用场景\n\n- **内核开发与维护**：在修改资源管理逻辑（如 `resource.c`）后运行此测试，确保核心 API 行为未被破坏。\n- **CI/CD 流水线**：作为内核持续集成测试的一部分，自动验证资源操作函数的正确性。\n- **新架构支持**：在为新硬件平台添加资源管理支持时，通过此测试验证底层资源操作的兼容性。\n- **边界条件验证**：专门用于检测资源区间合并与交集计算在复杂重叠场景下的逻辑缺陷。",
      "similarity": 0.6004728078842163,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/resource_kunit.c",
          "start_line": 83,
          "end_line": 134,
          "content": [
            "static void resource_do_test(struct kunit *test, bool ret, struct resource *r,",
            "\t\t\t     bool exp_ret, struct resource *exp_r,",
            "\t\t\t     struct resource *r1, struct resource *r2)",
            "{",
            "\tKUNIT_EXPECT_EQ_MSG(test, ret, exp_ret, \"Resources %pR %pR\", r1, r2);",
            "\tKUNIT_EXPECT_EQ_MSG(test, r->start, exp_r->start, \"Start elements are not equal\");",
            "\tKUNIT_EXPECT_EQ_MSG(test, r->end, exp_r->end, \"End elements are not equal\");",
            "}",
            "static void resource_do_union_test(struct kunit *test, struct result *r)",
            "{",
            "\tstruct resource result;",
            "\tbool ret;",
            "",
            "\tmemset(&result, 0, sizeof(result));",
            "\tret = resource_union(r->r1, r->r2, &result);",
            "\tresource_do_test(test, ret, &result, r->ret, &r->r, r->r1, r->r2);",
            "",
            "\tmemset(&result, 0, sizeof(result));",
            "\tret = resource_union(r->r2, r->r1, &result);",
            "\tresource_do_test(test, ret, &result, r->ret, &r->r, r->r2, r->r1);",
            "}",
            "static void resource_test_union(struct kunit *test)",
            "{",
            "\tstruct result *r = results_for_union;",
            "\tunsigned int i = 0;",
            "",
            "\tdo {",
            "\t\tresource_do_union_test(test, &r[i]);",
            "\t} while (++i < ARRAY_SIZE(results_for_union));",
            "}",
            "static void resource_do_intersection_test(struct kunit *test, struct result *r)",
            "{",
            "\tstruct resource result;",
            "\tbool ret;",
            "",
            "\tmemset(&result, 0, sizeof(result));",
            "\tret = resource_intersection(r->r1, r->r2, &result);",
            "\tresource_do_test(test, ret, &result, r->ret, &r->r, r->r1, r->r2);",
            "",
            "\tmemset(&result, 0, sizeof(result));",
            "\tret = resource_intersection(r->r2, r->r1, &result);",
            "\tresource_do_test(test, ret, &result, r->ret, &r->r, r->r2, r->r1);",
            "}",
            "static void resource_test_intersection(struct kunit *test)",
            "{",
            "\tstruct result *r = results_for_intersection;",
            "\tunsigned int i = 0;",
            "",
            "\tdo {",
            "\t\tresource_do_intersection_test(test, &r[i]);",
            "\t} while (++i < ARRAY_SIZE(results_for_intersection));",
            "}"
          ],
          "function_name": "resource_do_test, resource_do_union_test, resource_test_union, resource_do_intersection_test, resource_test_intersection",
          "description": "实现资源操作测试逻辑，通过遍历预设测试用例验证资源并集/交集计算结果，包含断言校验与结果比对功能。",
          "similarity": 0.6475926041603088
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/resource_kunit.c",
          "start_line": 1,
          "end_line": 82,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Test cases for API provided by resource.c and ioport.h",
            " */",
            "",
            "#include <kunit/test.h>",
            "#include <linux/ioport.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "",
            "#define R0_START\t0x0000",
            "#define R0_END\t\t0xffff",
            "#define R1_START\t0x1234",
            "#define R1_END\t\t0x2345",
            "#define R2_START\t0x4567",
            "#define R2_END\t\t0x5678",
            "#define R3_START\t0x6789",
            "#define R3_END\t\t0x789a",
            "#define R4_START\t0x2000",
            "#define R4_END\t\t0x7000",
            "",
            "static struct resource r0 = { .start = R0_START, .end = R0_END };",
            "static struct resource r1 = { .start = R1_START, .end = R1_END };",
            "static struct resource r2 = { .start = R2_START, .end = R2_END };",
            "static struct resource r3 = { .start = R3_START, .end = R3_END };",
            "static struct resource r4 = { .start = R4_START, .end = R4_END };",
            "",
            "struct result {",
            "\tstruct resource *r1;",
            "\tstruct resource *r2;",
            "\tstruct resource r;",
            "\tbool ret;",
            "};",
            "",
            "static struct result results_for_union[] = {",
            "\t{",
            "\t\t.r1 = &r1, .r2 = &r0, .r.start = R0_START, .r.end = R0_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r2, .r2 = &r0, .r.start = R0_START, .r.end = R0_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r3, .r2 = &r0, .r.start = R0_START, .r.end = R0_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r4, .r2 = &r0, .r.start = R0_START, .r.end = R0_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r2, .r2 = &r1, .ret = false,",
            "\t}, {",
            "\t\t.r1 = &r3, .r2 = &r1, .ret = false,",
            "\t}, {",
            "\t\t.r1 = &r4, .r2 = &r1, .r.start = R1_START, .r.end = R4_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r2, .r2 = &r3, .ret = false,",
            "\t}, {",
            "\t\t.r1 = &r2, .r2 = &r4, .r.start = R4_START, .r.end = R4_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r3, .r2 = &r4, .r.start = R4_START, .r.end = R3_END, .ret = true,",
            "\t},",
            "};",
            "",
            "static struct result results_for_intersection[] = {",
            "\t{",
            "\t\t.r1 = &r1, .r2 = &r0, .r.start = R1_START, .r.end = R1_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r2, .r2 = &r0, .r.start = R2_START, .r.end = R2_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r3, .r2 = &r0, .r.start = R3_START, .r.end = R3_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r4, .r2 = &r0, .r.start = R4_START, .r.end = R4_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r2, .r2 = &r1, .ret = false,",
            "\t}, {",
            "\t\t.r1 = &r3, .r2 = &r1, .ret = false,",
            "\t}, {",
            "\t\t.r1 = &r4, .r2 = &r1, .r.start = R4_START, .r.end = R1_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r2, .r2 = &r3, .ret = false,",
            "\t}, {",
            "\t\t.r1 = &r2, .r2 = &r4, .r.start = R2_START, .r.end = R2_END, .ret = true,",
            "\t}, {",
            "\t\t.r1 = &r3, .r2 = &r4, .r.start = R3_START, .r.end = R4_END, .ret = true,",
            "\t},",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义资源操作测试用例数据，包含多个资源结构体及预期结果，用于验证resource_union与resource_intersection函数的正确性。",
          "similarity": 0.6402524709701538
        }
      ]
    },
    {
      "source_file": "kernel/resource.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:53:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `resource.c`\n\n---\n\n# resource.c 技术文档\n\n## 1. 文件概述\n\n`resource.c` 是 Linux 内核中用于管理和分配系统资源（如 I/O 端口和内存区域）的核心实现文件。它提供了一套通用的资源树管理机制，支持资源的申请、释放、查找和冲突检测。该文件维护了两个全局根资源节点：`ioport_resource`（用于 I/O 端口空间）和 `iomem_resource`（用于内存映射 I/O 空间），并通过树形结构组织所有已分配的子资源，确保资源分配的唯一性和安全性。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `struct resource ioport_resource`：I/O 端口资源的根节点，范围为 `[0, IO_SPACE_LIMIT]`，标志为 `IORESOURCE_IO`。\n- `struct resource iomem_resource`：内存映射 I/O 资源的根节点，范围为 `[0, -1]`（即全地址空间），标志为 `IORESOURCE_MEM`。\n- `struct resource_constraint`：用于描述资源分配时的约束条件（最小/最大地址、对齐要求及自定义对齐函数）。\n\n### 关键函数\n- `request_resource(struct resource *root, struct resource *new)`：尝试在指定根资源下申请一段新资源，成功返回 0，冲突返回 `-EBUSY`。\n- `request_resource_conflict(...)`：与 `request_resource` 类似，但冲突时直接返回冲突的资源指针。\n- `release_resource(struct resource *old)`：释放已分配的资源。\n- `release_child_resources(struct resource *r)`：递归释放指定资源的所有子资源。\n- `find_next_iomem_res(...)`：在 `iomem_resource` 树中查找与指定区间 `[start, end]` 重叠且满足标志和描述符条件的下一个内存资源。\n- `for_each_resource` 宏：遍历资源树的通用宏，支持是否跳过子树的选项。\n\n### /proc 接口（条件编译）\n- 通过 `CONFIG_PROC_FS` 启用时，注册 `/proc/ioports` 和 `/proc/iomem` 文件，以树形格式展示当前系统中已分配的 I/O 端口和内存资源（仅对 `CAP_SYS_ADMIN` 权限用户显示实际地址）。\n\n## 3. 关键实现\n\n### 资源树结构\n- 资源以多叉树形式组织，每个 `struct resource` 包含 `child`（第一个子节点）、`sibling`（下一个兄弟节点）和 `parent` 指针。\n- 树内节点按起始地址升序排列，便于快速查找和插入。\n\n### 资源申请（`__request_resource`）\n- 在持有写锁 `resource_lock` 的前提下，遍历根节点的子链表。\n- 若新资源与现有节点无重叠，则按地址顺序插入；若存在重叠，则返回冲突节点。\n- 插入操作维护树的有序性：新节点插入到第一个起始地址大于其结束地址的节点之前。\n\n### 资源释放（`__release_resource`）\n- 支持两种模式：完全释放（含子资源）或仅提升子资源（当 `release_child=false` 时，将子节点直接挂到父节点下）。\n- 释放时调整兄弟链表指针，确保树结构完整性。\n\n### 资源遍历\n- `next_resource()`：深度优先遍历（先子节点，再兄弟节点）。\n- `next_resource_skip_children()`：仅遍历同级兄弟节点，跳过子树。\n- `/proc` 显示使用深度优先遍历，并限制最大显示层级（`MAX_IORES_LEVEL=5`）以避免过深嵌套。\n\n### 内存管理\n- 资源结构体通过 `alloc_resource()`（即 `kzalloc`）分配，通过 `free_resource()` 释放。\n- 注释指出：若资源由早期 `memblock` 分配，则无法安全释放（因非页对齐），会轻微泄漏，这是有意为之的简化设计。\n\n### 并发控制\n- 使用读写锁 `resource_lock` 保护全局资源树：\n  - 读操作（如 `/proc` 显示、`find_next_iomem_res`）使用 `read_lock`。\n  - 写操作（申请/释放资源）使用 `write_lock`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ioport.h>`：定义 `struct resource` 及相关宏（如 `IORESOURCE_IO`）。\n  - `<linux/proc_fs.h>`、`<linux/seq_file.h>`：实现 `/proc` 接口。\n  - `<linux/slab.h>`：资源结构体的动态分配。\n  - `<linux/spinlock.h>`：读写锁 `resource_lock` 的实现。\n  - `<asm/io.h>`：架构相关的 I/O 定义（如 `IO_SPACE_LIMIT`）。\n- **导出符号**：\n  - `ioport_resource`、`iomem_resource`、`request_resource`、`release_resource` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如 PCI、platform_device 驱动）使用。\n- **配置依赖**：\n  - `/proc` 接口依赖 `CONFIG_PROC_FS`。\n\n## 5. 使用场景\n\n- **设备驱动资源管理**：PCI、platform 等总线驱动在探测设备时，调用 `request_resource()` 申请 I/O 端口或内存区域，防止资源冲突。\n- **固件/ACPI 资源解析**：内核解析 ACPI 表或 EFI 内存映射时，将保留区域注册到 `iomem_resource` 树中。\n- **系统调试与监控**：用户空间通过 `/proc/ioports` 和 `/proc/iomem` 查看硬件资源分配情况（需 root 权限）。\n- **内核子系统协作**：内存管理子系统（如 `devm_request_mem_region`）、DMA 引擎等依赖此机制确保物理地址资源的独占使用。\n- **热插拔支持**：设备移除时调用 `release_resource()` 释放资源，供后续设备重用。",
      "similarity": 0.5957027077674866,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/resource.c",
          "start_line": 104,
          "end_line": 208,
          "content": [
            "static void r_stop(struct seq_file *m, void *v)",
            "\t__releases(resource_lock)",
            "{",
            "\tread_unlock(&resource_lock);",
            "}",
            "static int r_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct resource *root = pde_data(file_inode(m->file));",
            "\tstruct resource *r = v, *p;",
            "\tunsigned long long start, end;",
            "\tint width = root->end < 0x10000 ? 4 : 8;",
            "\tint depth;",
            "",
            "\tfor (depth = 0, p = r; depth < MAX_IORES_LEVEL; depth++, p = p->parent)",
            "\t\tif (p->parent == root)",
            "\t\t\tbreak;",
            "",
            "\tif (file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN)) {",
            "\t\tstart = r->start;",
            "\t\tend = r->end;",
            "\t} else {",
            "\t\tstart = end = 0;",
            "\t}",
            "",
            "\tseq_printf(m, \"%*s%0*llx-%0*llx : %s\\n\",",
            "\t\t\tdepth * 2, \"\",",
            "\t\t\twidth, start,",
            "\t\t\twidth, end,",
            "\t\t\tr->name ? r->name : \"<BAD>\");",
            "\treturn 0;",
            "}",
            "static int __init ioresources_init(void)",
            "{",
            "\tproc_create_seq_data(\"ioports\", 0, NULL, &resource_op,",
            "\t\t\t&ioport_resource);",
            "\tproc_create_seq_data(\"iomem\", 0, NULL, &resource_op, &iomem_resource);",
            "\treturn 0;",
            "}",
            "static void free_resource(struct resource *res)",
            "{",
            "\t/**",
            "\t * If the resource was allocated using memblock early during boot",
            "\t * we'll leak it here: we can only return full pages back to the",
            "\t * buddy and trying to be smart and reusing them eventually in",
            "\t * alloc_resource() overcomplicates resource handling.",
            "\t */",
            "\tif (res && PageSlab(virt_to_head_page(res)))",
            "\t\tkfree(res);",
            "}",
            "static int __release_resource(struct resource *old, bool release_child)",
            "{",
            "\tstruct resource *tmp, **p, *chd;",
            "",
            "\tp = &old->parent->child;",
            "\tfor (;;) {",
            "\t\ttmp = *p;",
            "\t\tif (!tmp)",
            "\t\t\tbreak;",
            "\t\tif (tmp == old) {",
            "\t\t\tif (release_child || !(tmp->child)) {",
            "\t\t\t\t*p = tmp->sibling;",
            "\t\t\t} else {",
            "\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {",
            "\t\t\t\t\tchd->parent = tmp->parent;",
            "\t\t\t\t\tif (!(chd->sibling))",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\t*p = tmp->child;",
            "\t\t\t\tchd->sibling = tmp->sibling;",
            "\t\t\t}",
            "\t\t\told->parent = NULL;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tp = &tmp->sibling;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static void __release_child_resources(struct resource *r)",
            "{",
            "\tstruct resource *tmp, *p;",
            "\tresource_size_t size;",
            "",
            "\tp = r->child;",
            "\tr->child = NULL;",
            "\twhile (p) {",
            "\t\ttmp = p;",
            "\t\tp = p->sibling;",
            "",
            "\t\ttmp->parent = NULL;",
            "\t\ttmp->sibling = NULL;",
            "\t\t__release_child_resources(tmp);",
            "",
            "\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);",
            "\t\t/* need to restore size, and keep flags */",
            "\t\tsize = resource_size(tmp);",
            "\t\ttmp->start = 0;",
            "\t\ttmp->end = size - 1;",
            "\t}",
            "}",
            "void release_child_resources(struct resource *r)",
            "{",
            "\twrite_lock(&resource_lock);",
            "\t__release_child_resources(r);",
            "\twrite_unlock(&resource_lock);",
            "}"
          ],
          "function_name": "r_stop, r_show, ioresources_init, free_resource, __release_resource, __release_child_resources, release_child_resources",
          "description": "实现资源遍历显示接口、资源释放逻辑及初始化函数，提供资源冲突检测、子资源释放、内存区域遍历等功能，支持进程命名空间下的资源访问控制。",
          "similarity": 0.6660645604133606
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/resource.c",
          "start_line": 802,
          "end_line": 912,
          "content": [
            "int allocate_resource(struct resource *root, struct resource *new,",
            "\t\t      resource_size_t size, resource_size_t min,",
            "\t\t      resource_size_t max, resource_size_t align,",
            "\t\t      resource_size_t (*alignf)(void *,",
            "\t\t\t\t\t\tconst struct resource *,",
            "\t\t\t\t\t\tresource_size_t,",
            "\t\t\t\t\t\tresource_size_t),",
            "\t\t      void *alignf_data)",
            "{",
            "\tint err;",
            "\tstruct resource_constraint constraint;",
            "",
            "\tif (!alignf)",
            "\t\talignf = simple_align_resource;",
            "",
            "\tconstraint.min = min;",
            "\tconstraint.max = max;",
            "\tconstraint.align = align;",
            "\tconstraint.alignf = alignf;",
            "\tconstraint.alignf_data = alignf_data;",
            "",
            "\tif ( new->parent ) {",
            "\t\t/* resource is already allocated, try reallocating with",
            "\t\t   the new constraints */",
            "\t\treturn reallocate_resource(root, new, size, &constraint);",
            "\t}",
            "",
            "\twrite_lock(&resource_lock);",
            "\terr = find_resource(root, new, size, &constraint);",
            "\tif (err >= 0 && __request_resource(root, new))",
            "\t\terr = -EBUSY;",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}",
            "int insert_resource(struct resource *parent, struct resource *new)",
            "{",
            "\tstruct resource *conflict;",
            "",
            "\tconflict = insert_resource_conflict(parent, new);",
            "\treturn conflict ? -EBUSY : 0;",
            "}",
            "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)",
            "{",
            "\tif (new->parent)",
            "\t\treturn;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tconflict = __insert_resource(root, new);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\tif (conflict == root)",
            "\t\t\tbreak;",
            "",
            "\t\t/* Ok, expand resource to cover the conflict, then try again .. */",
            "\t\tif (conflict->start < new->start)",
            "\t\t\tnew->start = conflict->start;",
            "\t\tif (conflict->end > new->end)",
            "\t\t\tnew->end = conflict->end;",
            "",
            "\t\tpr_info(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);",
            "\t}",
            "\twrite_unlock(&resource_lock);",
            "}",
            "int remove_resource(struct resource *old)",
            "{",
            "\tint retval;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tretval = __release_resource(old, false);",
            "\twrite_unlock(&resource_lock);",
            "\treturn retval;",
            "}",
            "static int __adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t\t\tresource_size_t size)",
            "{",
            "\tstruct resource *tmp, *parent = res->parent;",
            "\tresource_size_t end = start + size - 1;",
            "\tint result = -EBUSY;",
            "",
            "\tif (!parent)",
            "\t\tgoto skip;",
            "",
            "\tif ((start < parent->start) || (end > parent->end))",
            "\t\tgoto out;",
            "",
            "\tif (res->sibling && (res->sibling->start <= end))",
            "\t\tgoto out;",
            "",
            "\ttmp = parent->child;",
            "\tif (tmp != res) {",
            "\t\twhile (tmp->sibling != res)",
            "\t\t\ttmp = tmp->sibling;",
            "\t\tif (start <= tmp->end)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "skip:",
            "\tfor (tmp = res->child; tmp; tmp = tmp->sibling)",
            "\t\tif ((tmp->start < start) || (tmp->end > end))",
            "\t\t\tgoto out;",
            "",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tresult = 0;",
            "",
            " out:",
            "\treturn result;",
            "}"
          ],
          "function_name": "allocate_resource, insert_resource, insert_resource_expand_to_fit, remove_resource, __adjust_resource",
          "description": "实现资源分配逻辑，支持带约束条件的资源查找与申请，处理资源冲突及扩展调整，提供基础资源管理框架。",
          "similarity": 0.6480728387832642
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/resource.c",
          "start_line": 492,
          "end_line": 601,
          "content": [
            "int walk_mem_res(u64 start, u64 end, void *arg,",
            "\t\t int (*func)(struct resource *, void *))",
            "{",
            "\tunsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;",
            "",
            "\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,",
            "\t\t\t\t     func);",
            "}",
            "int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,",
            "\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))",
            "{",
            "\tresource_size_t start, end;",
            "\tunsigned long flags;",
            "\tstruct resource res;",
            "\tunsigned long pfn, end_pfn;",
            "\tint ret = -EINVAL;",
            "",
            "\tstart = (u64) start_pfn << PAGE_SHIFT;",
            "\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;",
            "\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;",
            "\twhile (start < end &&",
            "\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res)) {",
            "\t\tpfn = PFN_UP(res.start);",
            "\t\tend_pfn = PFN_DOWN(res.end + 1);",
            "\t\tif (end_pfn > pfn)",
            "\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t\tstart = res.end + 1;",
            "\t}",
            "\treturn ret;",
            "}",
            "static int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)",
            "{",
            "\treturn 1;",
            "}",
            "int __weak page_is_ram(unsigned long pfn)",
            "{",
            "\treturn walk_system_ram_range(pfn, 1, NULL, __is_ram) == 1;",
            "}",
            "static int __region_intersects(struct resource *parent, resource_size_t start,",
            "\t\t\t       size_t size, unsigned long flags,",
            "\t\t\t       unsigned long desc)",
            "{",
            "\tresource_size_t ostart, oend;",
            "\tint type = 0; int other = 0;",
            "\tstruct resource *p, *dp;",
            "\tbool is_type, covered;",
            "\tstruct resource res;",
            "",
            "\tres.start = start;",
            "\tres.end = start + size - 1;",
            "",
            "\tfor (p = parent->child; p ; p = p->sibling) {",
            "\t\tif (!resource_overlaps(p, &res))",
            "\t\t\tcontinue;",
            "\t\tis_type = (p->flags & flags) == flags &&",
            "\t\t\t(desc == IORES_DESC_NONE || desc == p->desc);",
            "\t\tif (is_type) {",
            "\t\t\ttype++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Continue to search in descendant resources as if the",
            "\t\t * matched descendant resources cover some ranges of 'p'.",
            "\t\t *",
            "\t\t * |------------- \"CXL Window 0\" ------------|",
            "\t\t * |-- \"System RAM\" --|",
            "\t\t *",
            "\t\t * will behave similar as the following fake resource",
            "\t\t * tree when searching \"System RAM\".",
            "\t\t *",
            "\t\t * |-- \"System RAM\" --||-- \"CXL Window 0a\" --|",
            "\t\t */",
            "\t\tcovered = false;",
            "\t\tostart = max(res.start, p->start);",
            "\t\toend = min(res.end, p->end);",
            "\t\tfor_each_resource(p, dp, false) {",
            "\t\t\tif (!resource_overlaps(dp, &res))",
            "\t\t\t\tcontinue;",
            "\t\t\tis_type = (dp->flags & flags) == flags &&",
            "\t\t\t\t(desc == IORES_DESC_NONE || desc == dp->desc);",
            "\t\t\tif (is_type) {",
            "\t\t\t\ttype++;",
            "\t\t\t\t/*",
            "\t\t\t\t * Range from 'ostart' to 'dp->start'",
            "\t\t\t\t * isn't covered by matched resource.",
            "\t\t\t\t */",
            "\t\t\t\tif (dp->start > ostart)",
            "\t\t\t\t\tbreak;",
            "\t\t\t\tif (dp->end >= oend) {",
            "\t\t\t\t\tcovered = true;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\t/* Remove covered range */",
            "\t\t\t\tostart = max(ostart, dp->end + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (!covered)",
            "\t\t\tother++;",
            "\t}",
            "",
            "\tif (type == 0)",
            "\t\treturn REGION_DISJOINT;",
            "",
            "\tif (other == 0)",
            "\t\treturn REGION_INTERSECTS;",
            "",
            "\treturn REGION_MIXED;",
            "}"
          ],
          "function_name": "walk_mem_res, walk_system_ram_range, __is_ram, page_is_ram, __region_intersects",
          "description": "提供内存资源遍历接口，将物理地址转换为资源结构进行处理，包含判断内存区域是否为RAM的弱符号实现及区域交集检测逻辑。",
          "similarity": 0.6479790210723877
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/resource.c",
          "start_line": 1072,
          "end_line": 1180,
          "content": [
            "int adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t    resource_size_t size)",
            "{",
            "\tint result;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tresult = __adjust_resource(res, start, size);",
            "\twrite_unlock(&resource_lock);",
            "\treturn result;",
            "}",
            "static void __init",
            "__reserve_region_with_split(struct resource *root, resource_size_t start,",
            "\t\t\t    resource_size_t end, const char *name)",
            "{",
            "\tstruct resource *parent = root;",
            "\tstruct resource *conflict;",
            "\tstruct resource *res = alloc_resource(GFP_ATOMIC);",
            "\tstruct resource *next_res = NULL;",
            "\tint type = resource_type(root);",
            "",
            "\tif (!res)",
            "\t\treturn;",
            "",
            "\tres->name = name;",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tres->flags = type | IORESOURCE_BUSY;",
            "\tres->desc = IORES_DESC_NONE;",
            "",
            "\twhile (1) {",
            "",
            "\t\tconflict = __request_resource(parent, res);",
            "\t\tif (!conflict) {",
            "\t\t\tif (!next_res)",
            "\t\t\t\tbreak;",
            "\t\t\tres = next_res;",
            "\t\t\tnext_res = NULL;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/* conflict covered whole area */",
            "\t\tif (conflict->start <= res->start &&",
            "\t\t\t\tconflict->end >= res->end) {",
            "\t\t\tfree_resource(res);",
            "\t\t\tWARN_ON(next_res);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* failed, split and try again */",
            "\t\tif (conflict->start > res->start) {",
            "\t\t\tend = res->end;",
            "\t\t\tres->end = conflict->start - 1;",
            "\t\t\tif (conflict->end < end) {",
            "\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);",
            "\t\t\t\tif (!next_res) {",
            "\t\t\t\t\tfree_resource(res);",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tnext_res->name = name;",
            "\t\t\t\tnext_res->start = conflict->end + 1;",
            "\t\t\t\tnext_res->end = end;",
            "\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;",
            "\t\t\t\tnext_res->desc = IORES_DESC_NONE;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tres->start = conflict->end + 1;",
            "\t\t}",
            "\t}",
            "",
            "}",
            "void __init",
            "reserve_region_with_split(struct resource *root, resource_size_t start,",
            "\t\t\t  resource_size_t end, const char *name)",
            "{",
            "\tint abort = 0;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tif (root->start > start || root->end < end) {",
            "\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",",
            "\t\t       (unsigned long long)start, (unsigned long long)end,",
            "\t\t       root);",
            "\t\tif (start > root->end || end < root->start)",
            "\t\t\tabort = 1;",
            "\t\telse {",
            "\t\t\tif (end > root->end)",
            "\t\t\t\tend = root->end;",
            "\t\t\tif (start < root->start)",
            "\t\t\t\tstart = root->start;",
            "\t\t\tpr_err(\"fixing request to [0x%llx-0x%llx]\\n\",",
            "\t\t\t       (unsigned long long)start,",
            "\t\t\t       (unsigned long long)end);",
            "\t\t}",
            "\t\tdump_stack();",
            "\t}",
            "\tif (!abort)",
            "\t\t__reserve_region_with_split(root, start, end, name);",
            "\twrite_unlock(&resource_lock);",
            "}",
            "resource_size_t resource_alignment(struct resource *res)",
            "{",
            "\tswitch (res->flags & (IORESOURCE_SIZEALIGN | IORESOURCE_STARTALIGN)) {",
            "\tcase IORESOURCE_SIZEALIGN:",
            "\t\treturn resource_size(res);",
            "\tcase IORESOURCE_STARTALIGN:",
            "\t\treturn res->start;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "function_name": "adjust_resource, __reserve_region_with_split, reserve_region_with_split, resource_alignment",
          "description": "实现资源区域分裂分配逻辑，处理大范围资源请求时的冲突分裂与重叠区域处理，提供资源对齐策略查询接口。",
          "similarity": 0.6339846849441528
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/resource.c",
          "start_line": 1739,
          "end_line": 1846,
          "content": [
            "int iomem_map_sanity_check(resource_size_t addr, unsigned long size)",
            "{",
            "\tstruct resource *p = &iomem_resource;",
            "\tresource_size_t end = addr + size - 1;",
            "\tint err = 0;",
            "\tloff_t l;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {",
            "\t\t/*",
            "\t\t * We can probably skip the resources without",
            "\t\t * IORESOURCE_IO attribute?",
            "\t\t */",
            "\t\tif (p->start > end)",
            "\t\t\tcontinue;",
            "\t\tif (p->end < addr)",
            "\t\t\tcontinue;",
            "\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&",
            "\t\t    PFN_DOWN(p->end) >= PFN_DOWN(end))",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * if a resource is \"BUSY\", it's not a hardware resource",
            "\t\t * but a driver mapping of such a resource; we don't want",
            "\t\t * to warn for those; some drivers legitimately map only",
            "\t\t * partial hardware resources. (example: vesafb)",
            "\t\t */",
            "\t\tif (p->flags & IORESOURCE_BUSY)",
            "\t\t\tcontinue;",
            "",
            "\t\tpr_warn(\"resource sanity check: requesting [mem %pa-%pa], which spans more than %s %pR\\n\",",
            "\t\t\t&addr, &end, p->name, p);",
            "\t\terr = -1;",
            "\t\tbreak;",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool resource_is_exclusive(struct resource *root, u64 addr, resource_size_t size)",
            "{",
            "\tconst unsigned int exclusive_system_ram = IORESOURCE_SYSTEM_RAM |",
            "\t\t\t\t\t\t  IORESOURCE_EXCLUSIVE;",
            "\tbool skip_children = false, err = false;",
            "\tstruct resource *p;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor_each_resource(root, p, skip_children) {",
            "\t\tif (p->start >= addr + size)",
            "\t\t\tbreak;",
            "\t\tif (p->end < addr) {",
            "\t\t\tskip_children = true;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tskip_children = false;",
            "",
            "\t\t/*",
            "\t\t * IORESOURCE_SYSTEM_RAM resources are exclusive if",
            "\t\t * IORESOURCE_EXCLUSIVE is set, even if they",
            "\t\t * are not busy and even if \"iomem=relaxed\" is set. The",
            "\t\t * responsible driver dynamically adds/removes system RAM within",
            "\t\t * such an area and uncontrolled access is dangerous.",
            "\t\t */",
            "\t\tif ((p->flags & exclusive_system_ram) == exclusive_system_ram) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * A resource is exclusive if IORESOURCE_EXCLUSIVE is set",
            "\t\t * or CONFIG_IO_STRICT_DEVMEM is enabled and the",
            "\t\t * resource is busy.",
            "\t\t */",
            "\t\tif (!strict_iomem_checks || !(p->flags & IORESOURCE_BUSY))",
            "\t\t\tcontinue;",
            "\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)",
            "\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool iomem_is_exclusive(u64 addr)",
            "{",
            "\treturn resource_is_exclusive(&iomem_resource, addr & PAGE_MASK,",
            "\t\t\t\t     PAGE_SIZE);",
            "}",
            "void resource_list_free(struct list_head *head)",
            "{",
            "\tstruct resource_entry *entry, *tmp;",
            "",
            "\tlist_for_each_entry_safe(entry, tmp, head, node)",
            "\t\tresource_list_destroy_entry(entry);",
            "}",
            "static resource_size_t gfr_start(struct resource *base, resource_size_t size,",
            "\t\t\t\t resource_size_t align, unsigned long flags)",
            "{",
            "\tif (flags & GFR_DESCENDING) {",
            "\t\tresource_size_t end;",
            "",
            "\t\tend = min_t(resource_size_t, base->end, PHYSMEM_END);",
            "\t\treturn end - size + 1;",
            "\t}",
            "",
            "\treturn ALIGN(base->start, align);",
            "}"
          ],
          "function_name": "iomem_map_sanity_check, resource_is_exclusive, iomem_is_exclusive, resource_list_free, gfr_start",
          "description": "iomem_map_sanity_check 检查新请求的I/O内存区域是否与现有资源冲突，若存在覆盖则返回-1；resource_is_exclusive 判断目标地址是否属于独占资源，依据IORESOURCE_EXCLUSIVE标志及CONFIG_IO_STRICT_DEVMEM配置；iomem_is_exclusive 简化调用resource_is_exclusive检查单个地址；resource_list_free 遍历并销毁指定链表中的所有resource_entry；gfr_start 根据对齐方向计算起始地址，支持降序分配模式。",
          "similarity": 0.6313291192054749
        }
      ]
    }
  ]
}