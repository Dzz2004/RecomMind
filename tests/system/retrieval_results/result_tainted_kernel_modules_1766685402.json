{
  "query": "tainted kernel modules",
  "timestamp": "2025-12-26 01:56:42",
  "retrieved_files": [
    {
      "source_file": "kernel/module/tracking.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:08:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\tracking.c`\n\n---\n\n# module/tracking.c 技术文档\n\n## 1. 文件概述\n\n`module/tracking.c` 实现了对已卸载但带有污染标记（tainted）的内核模块的跟踪机制。该功能用于记录那些在卸载时已被标记为“污染”（tainted）的模块信息，包括模块名称、污染标志类型以及重复卸载的次数。这些信息可用于内核调试、安全审计或故障分析，帮助开发者识别可能导致系统不稳定或不可信状态的模块行为。\n\n## 2. 核心功能\n\n### 数据结构\n- `struct mod_unload_taint`（定义在 `internal.h` 中）：\n  - `name`：模块名称（最多 `MODULE_NAME_LEN` 字节）\n  - `taints`：模块的污染标志位掩码\n  - `count`：该模块（同名且污染标志有交集）被卸载的次数\n  - `list`：用于链入全局链表 `unloaded_tainted_modules`\n\n### 全局变量\n- `unloaded_tainted_modules`：全局 RCU 保护的链表头，存储所有已卸载的污染模块记录\n- `mod_debugfs_root`：外部声明的 debugfs 根目录入口（由模块子系统提供）\n\n### 主要函数\n- `try_add_tainted_module(struct module *mod)`  \n  尝试将带有污染标志的模块添加到跟踪列表中。若同名模块且污染标志有重叠，则仅递增计数；否则分配新条目并加入链表。\n\n- `print_unloaded_tainted_modules(void)`  \n  在内核日志中打印所有已跟踪的卸载污染模块信息，格式为：`模块名(污染标志):计数`。\n\n- `unloaded_tainted_modules_seq_*` 系列函数（仅当 `CONFIG_DEBUG_FS` 启用时）  \n  实现 debugfs 接口 `/sys/kernel/debug/modules/unloaded_tainted`，以 seq_file 方式暴露跟踪数据。\n\n- `unloaded_tainted_modules_init(void)`  \n  模块初始化函数，注册 debugfs 文件。\n\n## 3. 关键实现\n\n### 污染模块去重与计数逻辑\n- 在 `try_add_tainted_module()` 中，通过遍历 `unloaded_tainted_modules` 链表，检查是否存在**同名**且**污染标志有交集**（`mod_taint->taints & mod->taints`）的条目。\n- 若存在，则仅将 `count` 字段加一，避免重复记录相同污染行为。\n- 若不存在，则分配新 `mod_unload_taint` 结构体，拷贝模块名和污染标志，并初始化 `count` 为 1，然后通过 `list_add_rcu()` 安全加入链表。\n\n### 并发安全机制\n- 所有链表遍历操作均使用 **RCU（Read-Copy-Update）** 机制保护：\n  - 写操作（如 `list_add_rcu`）在持有 `module_mutex` 时执行（由 `module_assert_mutex_or_preempt()` 保证）\n  - 读操作（如 `print_unloaded_tainted_modules` 和 debugfs 序列化函数）使用 `rcu_read_lock()` / `rcu_read_unlock()`\n- `list_for_each_entry_rcu` 宏配合 `lockdep_is_held(&module_mutex)` 提供锁依赖检查，确保正确性。\n\n### DebugFS 接口实现\n- 使用标准 `seq_file` 接口实现高效、可分页的文件读取。\n- `unloaded_tainted_modules_seq_start/next/stop` 封装了 RCU 读端临界区。\n- `unloaded_tainted_modules_seq_show` 调用 `module_flags_taint()` 将污染位掩码转换为可读字符串（如 \"P\", \"O\", \"E\" 等）。\n\n### 内存管理\n- 动态分配 `mod_unload_taint` 结构体使用 `kmalloc(..., GFP_KERNEL)`，失败时返回 `-ENOMEM`。\n- 条目一旦加入链表，其生命周期由 RCU 机制管理，但当前代码未实现显式释放（通常在系统关机或模块子系统清理时处理）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：模块核心定义、`module_mutex`、污染标志相关 API\n  - `<linux/rculist.h>`：RCU 安全的链表操作\n  - `<linux/debugfs.h>`：debugfs 文件系统支持\n  - `\"internal.h\"`：包含 `struct mod_unload_taint` 定义及 `module_flags_taint()` 声明\n\n- **外部符号**：\n  - `mod_debugfs_root`：由 `kernel/module.c` 导出，作为模块子系统的 debugfs 根目录\n  - `module_flags_taint()`：在 `kernel/module.c` 中实现，用于将污染位转换为字符串\n\n- **配置依赖**：\n  - `CONFIG_DEBUG_FS`：控制是否编译 debugfs 接口\n\n## 5. 使用场景\n\n- **内核崩溃或错误诊断**：当系统出现异常时，可通过 `print_unloaded_tainted_modules()` 输出或 debugfs 文件查看历史上卸载的污染模块，辅助定位问题根源。\n- **安全审计**：系统管理员可通过 `/sys/kernel/debug/modules/unloaded_tainted` 监控是否有加载过带污染标志（如专有模块、强制加载等）的模块，即使这些模块已被卸载。\n- **内核测试与验证**：在自动化测试中，可验证模块污染行为是否被正确记录和跟踪。\n- **模块生命周期分析**：结合其他跟踪机制，分析模块加载/卸载模式及其对系统可信状态的影响。",
      "similarity": 0.5916799902915955,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/tracking.c",
          "start_line": 20,
          "end_line": 95,
          "content": [
            "int try_add_tainted_module(struct module *mod)",
            "{",
            "\tstruct mod_unload_taint *mod_taint;",
            "",
            "\tmodule_assert_mutex_or_preempt();",
            "",
            "\tif (!mod->taints)",
            "\t\tgoto out;",
            "",
            "\tlist_for_each_entry_rcu(mod_taint, &unloaded_tainted_modules, list,",
            "\t\t\t\tlockdep_is_held(&module_mutex)) {",
            "\t\tif (!strcmp(mod_taint->name, mod->name) &&",
            "\t\t    mod_taint->taints & mod->taints) {",
            "\t\t\tmod_taint->count++;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tmod_taint = kmalloc(sizeof(*mod_taint), GFP_KERNEL);",
            "\tif (unlikely(!mod_taint))",
            "\t\treturn -ENOMEM;",
            "\tstrscpy(mod_taint->name, mod->name, MODULE_NAME_LEN);",
            "\tmod_taint->taints = mod->taints;",
            "\tlist_add_rcu(&mod_taint->list, &unloaded_tainted_modules);",
            "\tmod_taint->count = 1;",
            "out:",
            "\treturn 0;",
            "}",
            "void print_unloaded_tainted_modules(void)",
            "{",
            "\tstruct mod_unload_taint *mod_taint;",
            "\tchar buf[MODULE_FLAGS_BUF_SIZE];",
            "",
            "\tif (!list_empty(&unloaded_tainted_modules)) {",
            "\t\tprintk(KERN_DEFAULT \"Unloaded tainted modules:\");",
            "\t\tlist_for_each_entry_rcu(mod_taint, &unloaded_tainted_modules,",
            "\t\t\t\t\tlist) {",
            "\t\t\tsize_t l;",
            "",
            "\t\t\tl = module_flags_taint(mod_taint->taints, buf);",
            "\t\t\tbuf[l++] = '\\0';",
            "\t\t\tpr_cont(\" %s(%s):%llu\", mod_taint->name, buf,",
            "\t\t\t\tmod_taint->count);",
            "\t\t}",
            "\t}",
            "}",
            "static void unloaded_tainted_modules_seq_stop(struct seq_file *m, void *p)",
            "\t__releases(rcu)",
            "{",
            "\trcu_read_unlock();",
            "}",
            "static int unloaded_tainted_modules_seq_show(struct seq_file *m, void *p)",
            "{",
            "\tstruct mod_unload_taint *mod_taint;",
            "\tchar buf[MODULE_FLAGS_BUF_SIZE];",
            "\tsize_t l;",
            "",
            "\tmod_taint = list_entry(p, struct mod_unload_taint, list);",
            "\tl = module_flags_taint(mod_taint->taints, buf);",
            "\tbuf[l++] = '\\0';",
            "",
            "\tseq_printf(m, \"%s (%s) %llu\", mod_taint->name, buf, mod_taint->count);",
            "\tseq_puts(m, \"\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static int unloaded_tainted_modules_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn seq_open(file, &unloaded_tainted_modules_seq_ops);",
            "}",
            "static int __init unloaded_tainted_modules_init(void)",
            "{",
            "\tdebugfs_create_file(\"unloaded_tainted\", 0444, mod_debugfs_root, NULL,",
            "\t\t\t    &unloaded_tainted_modules_fops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "try_add_tainted_module, print_unloaded_tainted_modules, unloaded_tainted_modules_seq_stop, unloaded_tainted_modules_seq_show, unloaded_tainted_modules_open, unloaded_tainted_modules_init",
          "description": "实现污点模块追踪功能，包含添加污点模块记录、遍历打印污点模块信息、调试文件系统接口注册等，核心功能是维护和展示卸载模块的污点状态",
          "similarity": 0.5196366310119629
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/tracking.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module taint unload tracking support",
            " *",
            " * Copyright (C) 2022 Aaron Tomlin",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/rculist.h>",
            "#include \"internal.h\"",
            "",
            "static LIST_HEAD(unloaded_tainted_modules);",
            "extern struct dentry *mod_debugfs_root;",
            ""
          ],
          "function_name": null,
          "description": "定义用于跟踪卸载污点模块的链表头及调试文件系统根目录引用，核心功能是管理卸载模块的污点状态数据结构",
          "similarity": 0.4727499485015869
        }
      ]
    },
    {
      "source_file": "mm/hwpoison-inject.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:08:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `hwpoison-inject.c`\n\n---\n\n# hwpoison-inject.c 技术文档\n\n## 1. 文件概述\n\n`hwpoison-inject.c` 是 Linux 内核中用于**软件模拟硬件内存故障（Hardware Poison）注入与清除**的调试模块。该模块通过 debugfs 接口，允许具有 `CAP_SYS_ADMIN` 权限的用户空间程序向指定物理页帧号（PFN）注入或清除“坏页”标记（`PG_hwpoison`），主要用于测试内核内存错误处理机制（如 `memory_failure()` 路径）在无真实硬件故障情况下的行为。\n\n## 2. 核心功能\n\n### 主要函数\n- **`hwpoison_inject(void *data, u64 val)`**  \n  向指定 PFN 注入硬件内存故障。执行权限检查、页有效性验证、过滤器判断后调用 `memory_failure()`。\n  \n- **`hwpoison_unpoison(void *data, u64 val)`**  \n  清除指定 PFN 的硬件内存故障标记，调用 `unpoison_memory()`。\n\n- **`pfn_inject_init(void)`**  \n  模块初始化函数，创建 debugfs 目录及控制文件。\n\n- **`pfn_inject_exit(void)`**  \n  模块退出函数，清理 debugfs 条目并禁用过滤器。\n\n### 主要数据结构/全局变量\n- **`hwpoison_dir`**：debugfs 目录入口（`/sys/kernel/debug/hwpoison/`）。\n- **`hwpoison_fops` / `unpoison_fops`**：debugfs 文件操作接口，分别用于写入 corrupt/unpoison 请求。\n- **`hwpoison_filter_enable` 等全局变量**：控制 hwpoison 过滤器的行为参数（通过 debugfs 可配置）。\n\n## 3. 关键实现\n\n### 故障注入流程 (`hwpoison_inject`)\n1. **权限与有效性校验**：仅允许 `CAP_SYS_ADMIN` 用户操作，并确保输入 PFN 有效（`pfn_valid()`）。\n2. **页类型过滤**：\n   - 若 `hwpoison_filter_enable=0`，跳过过滤直接注入。\n   - 否则，仅对 **LRU 页**、**HugeTLB 页** 或 **空闲 Buddy 页** 允许注入，其他非 LRU 页（如 slab、匿名映射未加入 LRU 的页）被忽略。\n3. **过滤器检查**：调用 `hwpoison_filter()` 执行基于设备号、页标志、memcg 等条件的精细过滤（racy check，最终由 `memory_failure()` 在持锁下确认）。\n4. **触发内存故障处理**：调用 `memory_failure(pfn, MF_SW_SIMULATED)`，其中 `MF_SW_SIMULATED` 表示软件模拟故障。\n\n### 故障清除流程 (`hwpoison_unpoison`)\n- 直接调用通用接口 `unpoison_memory()` 清除 `PG_hwpoison` 标记，适用于已标记为坏页的页面。\n\n### DebugFS 接口设计\n- **`corrupt-pfn`**：写入 PFN 触发注入（权限 `0200`，仅写）。\n- **`unpoison-pfn`**：写入 PFN 触发清除（权限 `0200`，仅写）。\n- **过滤器控制参数**：提供 `corrupt-filter-*` 系列文件动态配置过滤条件（如设备号、页标志掩码、memcg ID）。\n\n## 4. 依赖关系\n\n- **核心内存管理子系统**：\n  - `<linux/mm.h>`、`<linux/pagemap.h>`：页结构、PFN 转换、LRU 状态检查。\n  - `<linux/hugetlb.h>`：HugeTLB 页支持。\n  - `\"internal.h\"`：内核 MM 内部接口（如 `shake_folio()`、`hwpoison_filter()`）。\n- **内存故障处理框架**：\n  - `memory_failure()` 和 `unpoison_memory()`：定义于 `mm/memory-failure.c`，负责实际坏页处理逻辑。\n- **DebugFS 基础设施**：依赖 `<linux/debugfs.h>` 提供用户态交互接口。\n- **可选依赖**：\n  - `CONFIG_MEMCG`：若启用内存控制组，则支持基于 memcg 的过滤。\n\n## 5. 使用场景\n\n- **内核开发与测试**：\n  - 验证 `memory_failure()` 路径对不同类型页面（匿名页、文件页、HugeTLB 页等）的处理正确性。\n  - 测试 hwpoison 过滤器逻辑（如基于设备、memcg 的隔离策略）。\n- **系统可靠性验证**：\n  - 模拟硬件内存故障，评估应用程序和内核在坏页注入下的恢复能力（如进程终止、页面迁移）。\n- **故障注入工具集成**：\n  - 作为底层接口被用户态工具（如 `mce-inject` 或自定义脚本）调用，实现可控的内存错误注入实验。",
      "similarity": 0.5550825595855713,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/hwpoison-inject.c",
          "start_line": 1,
          "end_line": 13,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Inject a hwpoison memory failure on a arbitrary pfn */",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include \"internal.h\"",
            "",
            "static struct dentry *hwpoison_dir;",
            ""
          ],
          "function_name": null,
          "description": "定义并初始化用于硬件中毒注入的调试文件系统目录结构",
          "similarity": 0.5448978543281555
        },
        {
          "chunk_id": 1,
          "file_path": "mm/hwpoison-inject.c",
          "start_line": 14,
          "end_line": 103,
          "content": [
            "static int hwpoison_inject(void *data, u64 val)",
            "{",
            "\tunsigned long pfn = val;",
            "\tstruct page *p;",
            "\tstruct folio *folio;",
            "\tint err;",
            "",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tif (!pfn_valid(pfn))",
            "\t\treturn -ENXIO;",
            "",
            "\tp = pfn_to_page(pfn);",
            "\tfolio = page_folio(p);",
            "",
            "\tif (!hwpoison_filter_enable)",
            "\t\tgoto inject;",
            "",
            "\tshake_folio(folio);",
            "\t/*",
            "\t * This implies unable to support non-LRU pages except free page.",
            "\t */",
            "\tif (!folio_test_lru(folio) && !folio_test_hugetlb(folio) &&",
            "\t    !is_free_buddy_page(p))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * do a racy check to make sure PG_hwpoison will only be set for",
            "\t * the targeted owner (or on a free page).",
            "\t * memory_failure() will redo the check reliably inside page lock.",
            "\t */",
            "\terr = hwpoison_filter(&folio->page);",
            "\tif (err)",
            "\t\treturn 0;",
            "",
            "inject:",
            "\tpr_info(\"Injecting memory failure at pfn %#lx\\n\", pfn);",
            "\terr = memory_failure(pfn, MF_SW_SIMULATED);",
            "\treturn (err == -EOPNOTSUPP) ? 0 : err;",
            "}",
            "static int hwpoison_unpoison(void *data, u64 val)",
            "{",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\treturn unpoison_memory(val);",
            "}",
            "static void __exit pfn_inject_exit(void)",
            "{",
            "\thwpoison_filter_enable = 0;",
            "\tdebugfs_remove_recursive(hwpoison_dir);",
            "}",
            "static int __init pfn_inject_init(void)",
            "{",
            "\thwpoison_dir = debugfs_create_dir(\"hwpoison\", NULL);",
            "",
            "\t/*",
            "\t * Note that the below poison/unpoison interfaces do not involve",
            "\t * hardware status change, hence do not require hardware support.",
            "\t * They are mainly for testing hwpoison in software level.",
            "\t */",
            "\tdebugfs_create_file(\"corrupt-pfn\", 0200, hwpoison_dir, NULL,",
            "\t\t\t    &hwpoison_fops);",
            "",
            "\tdebugfs_create_file(\"unpoison-pfn\", 0200, hwpoison_dir, NULL,",
            "\t\t\t    &unpoison_fops);",
            "",
            "\tdebugfs_create_u32(\"corrupt-filter-enable\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_enable);",
            "",
            "\tdebugfs_create_u32(\"corrupt-filter-dev-major\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_dev_major);",
            "",
            "\tdebugfs_create_u32(\"corrupt-filter-dev-minor\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_dev_minor);",
            "",
            "\tdebugfs_create_u64(\"corrupt-filter-flags-mask\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_flags_mask);",
            "",
            "\tdebugfs_create_u64(\"corrupt-filter-flags-value\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_flags_value);",
            "",
            "#ifdef CONFIG_MEMCG",
            "\tdebugfs_create_u64(\"corrupt-filter-memcg\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_memcg);",
            "#endif",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "hwpoison_inject, hwpoison_unpoison, pfn_inject_exit, pfn_inject_init",
          "description": "提供硬件中毒注入与解除接口，包含权限校验、PFN有效性检查、页面状态修改及debugfs控制接口注册功能",
          "similarity": 0.5309356451034546
        }
      ]
    },
    {
      "source_file": "kernel/module/internal.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:01:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\internal.h`\n\n---\n\n# `module/internal.h` 技术文档\n\n## 1. 文件概述\n\n`module/internal.h` 是 Linux 内核模块子系统的核心内部头文件，定义了模块加载、符号解析、内存布局、调试统计等关键内部数据结构和辅助函数。该文件仅供内核模块子系统内部使用，不对外暴露给模块开发者。它封装了模块加载过程中的中间状态、符号查找逻辑、内存管理细节以及与架构相关的重定位处理，并集成了模块压缩、热补丁（livepatch）、污点追踪（taint tracking）和调试统计等可选功能的支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct kernel_symbol`**  \n  内核符号的内部表示，支持两种模式：  \n  - 普通模式：直接存储符号值（`value`）、名称（`name`）和命名空间（`namespace`）指针。  \n  - `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 模式：使用偏移量（`value_offset` 等）以节省内存并支持位置无关代码。\n\n- **`struct load_info`**  \n  模块加载过程中的临时信息容器，包含 ELF 头、节头表、字符串表、符号表、各节偏移、签名状态、解压页信息等，贯穿整个 `load_module()` 流程。\n\n- **`struct find_symbol_arg`**  \n  符号查找的输入/输出参数结构，用于 `find_symbol()` 函数，支持按名称、GPL 许可限制进行符号搜索。\n\n- **`enum fail_dup_mod_reason`**  \n  定义重复模块加载失败的两种场景：`FAIL_DUP_MOD_BECOMING`（早期检查阶段发现重复）和 `FAIL_DUP_MOD_LOAD`（分配内存后发现重复）。\n\n- **`struct mod_fail_load`**（仅当 `CONFIG_MODULE_STATS` 启用）  \n  用于统计重复加载失败的模块信息。\n\n- **`struct mod_unload_taint`**（仅当 `CONFIG_MODULE_UNLOAD_TAINT_TRACKING` 启用）  \n  记录卸载时带有污点（taint）的模块信息。\n\n### 主要函数\n\n- **符号管理**  \n  - `find_symbol()`：在全局符号表中查找指定名称的符号。  \n  - `kernel_symbol_value()`：获取 `kernel_symbol` 结构中符号的实际地址。\n\n- **模块加载辅助**  \n  - `mod_verify_sig()`：验证模块签名。  \n  - `try_to_force_load()`：在特定条件下强制加载被拒绝的模块（如 taint 原因）。  \n  - `module_get_offset_and_type()`：计算模块节在目标内存布局中的偏移和内存类型。  \n  - `module_flags()` / `module_flags_taint()`：生成模块状态或污点标志的字符串表示。\n\n- **模块信息解析**  \n  - `module_next_tag_pair()`：解析模块信息（modinfo）中的键值对。  \n  - `for_each_modinfo_entry`：遍历指定名称的 modinfo 条目。\n\n- **热补丁支持**（`CONFIG_LIVEPATCH`）  \n  - `copy_module_elf()` / `free_module_elf()`：复制或释放模块的 ELF 原始数据，供 livepatch 使用。  \n  - `set_livepatch_module()`：标记模块为 livepatch 模块。\n\n- **统计与调试**（条件编译）  \n  - `try_add_failed_module()`：记录重复加载失败事件。  \n  - `mod_stat_bump_invalid()` / `mod_stat_bump_becoming()`：更新无效或正在加载的模块统计。  \n  - `try_add_tainted_module()` / `print_unloaded_tainted_modules()`：跟踪并打印卸载时带污点的模块。  \n  - `kmod_dup_request_exists_wait()` / `kmod_dup_request_announce()`：用于调试自动加载重复请求。\n\n- **解压支持**（`CONFIG_MODULE_DECOMPRESS`）  \n  - `module_decompress()` / `module_decompress_cleanup()`：解压压缩的模块镜像。\n\n### 全局变量\n\n- `module_mutex`：保护模块列表和状态的全局互斥锁。  \n- `modules`：已加载模块的全局链表。  \n- `modinfo_attrs[]` / `modinfo_attrs_count`：模块信息属性数组及其数量。  \n- `__start___ksymtab[]` 等：链接器生成的内核符号表起止标记。  \n- 各类统计计数器（如 `total_mod_size`, `modcount` 等，仅当 `CONFIG_MODULE_STATS` 启用）。\n\n## 3. 关键实现\n\n### 符号表与重定位优化\n- 通过 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 支持使用 32 位相对偏移代替 64 位绝对指针，显著减少符号表内存占用，尤其在 64 位系统上。\n- `kernel_symbol_value()` 宏根据配置自动选择解析方式，对上层透明。\n\n### 节类型编码\n- 利用 ELF 节头 `sh_entsize` 的高 4 位存储 `mod_mem_type`（内存类型），低 28/60 位存储偏移量。\n- 定义了 `SH_ENTSIZE_TYPE_BITS`、`SH_ENTSIZE_TYPE_MASK` 等宏进行位操作，确保在 32/64 位系统上正确分离类型与偏移。\n\n### 模块加载状态保护\n- `module_assert_mutex_or_preempt()` 利用 `lockdep` 和 `rcu_read_lock_sched_held()` 确保关键操作在持有 `module_mutex` 或处于 RCU 读临界区中执行，防止并发错误。\n\n### 重复模块检测\n- `enum fail_dup_mod_reason` 精确区分重复模块在加载流程中被发现的两个关键点，有助于分析资源浪费（如 vmap 空间）和竞态条件。\n\n### 条件编译功能集成\n- 通过 `#ifdef CONFIG_XXX` 将模块统计、污点追踪、自动加载调试、解压、热补丁等功能模块化，保持核心逻辑简洁，按需启用。\n\n## 4. 依赖关系\n\n- **内核核心头文件**：  \n  - `<linux/elf.h>`：ELF 格式定义。  \n  - `<linux/module.h>`：模块公共接口。  \n  - `<linux/mutex.h>`, `<linux/rculist.h>`, `<linux/rcupdate.h>`：同步原语。  \n  - `<linux/mm.h>`：内存管理相关定义。\n\n- **架构相关**：  \n  - `ARCH_SHF_SMALL`：架构特定的节标志，用于小内存模型。\n\n- **可选子系统**：  \n  - `CONFIG_KALLSYMS`：内核符号表支持。  \n  - `CONFIG_LIVEPATCH`：内核热补丁。  \n  - `CONFIG_MODULE_DECOMPRESS`：模块解压。  \n  - `CONFIG_MODULE_STATS` / `CONFIG_MODULE_DEBUGFS` / `CONFIG_MODULE_UNLOAD_TAINT_TRACKING` / `CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS`：各类调试与统计功能。\n\n- **链接器脚本**：  \n  - 依赖链接器生成的 `__start___ksymtab`、`__stop___ksymtab_gpl` 等符号，用于遍历内建符号表。\n\n## 5. 使用场景\n\n- **模块加载流程**：`load_module()` 及其辅助函数使用 `struct load_info` 传递解析后的 ELF 信息，并调用 `mod_verify_sig()`、`module_decompress()` 等进行预处理。\n- **符号解析**：`find_symbol()` 被 `kernel/module.c` 中的符号导出/导入机制调用，实现模块间及内核与模块间的符号链接。\n- **内存布局**：`module_get_offset_and_type()` 在 `layout_and_allocate()` 阶段确定各节在模块内存映像中的位置。\n- **调试与监控**：  \n  - `module_flags()` 用于 `/sys/module/<name>/taint` 等接口显示模块状态。  \n  - 统计功能（`CONFIG_MODULE_STATS`）帮助分析模块加载性能与失败原因。  \n  - 污点追踪（`CONFIG_MODULE_UNLOAD_TAINT_TRACKING`）记录可能导致系统不稳定模块的卸载信息。\n- **热补丁**：livepatch 子系统通过 `copy_module_elf()` 保留原始 ELF 用于补丁验证和回滚。\n- **并发控制**：所有修改全局模块列表或状态的操作必须通过 `module_mutex` 保护，`module_assert_mutex_or_preempt()` 用于运行时检查。",
      "similarity": 0.5384735465049744,
      "chunks": []
    }
  ]
}