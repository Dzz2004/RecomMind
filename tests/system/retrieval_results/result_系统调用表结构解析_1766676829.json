{
  "query": "系统调用表结构解析",
  "timestamp": "2025-12-25 23:33:49",
  "retrieved_files": [
    {
      "source_file": "kernel/entry/syscall_user_dispatch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:20:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\syscall_user_dispatch.c`\n\n---\n\n# entry/syscall_user_dispatch.c 技术文档\n\n## 1. 文件概述\n\n`entry/syscall_user_dispatch.c` 实现了 **系统调用用户分发（Syscall User Dispatch, SUD）** 机制，该机制允许用户空间程序通过 `prctl()` 系统调用配置一个“选择器”（selector），用于在特定条件下拦截或允许系统调用的执行。当系统调用指令指针位于指定区域之外且选择器状态为“阻塞”时，内核会回滚该系统调用并向进程发送 `SIGSYS` 信号，从而实现对系统调用的细粒度控制。此功能常用于沙箱、安全监控或调试场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trigger_sigsys(struct pt_regs *regs)`  \n  构造并强制发送 `SIGSYS` 信号，携带被拦截系统调用的详细信息（如地址、系统调用号、架构等）。\n\n- `syscall_user_dispatch(struct pt_regs *regs)`  \n  系统调用入口处的分发判断逻辑。根据当前指令指针位置和用户选择器状态决定是否拦截系统调用。\n\n- `task_set_syscall_user_dispatch(struct task_struct *task, ...)`  \n  为指定任务设置系统调用用户分发配置（开启/关闭、偏移、长度、选择器地址）。\n\n- `set_syscall_user_dispatch(...)`  \n  为当前任务设置系统调用用户分发配置的封装接口，供 `prctl()` 调用。\n\n- `syscall_user_dispatch_get_config(...)`  \n  通过 `ptrace` 获取指定任务的 SUD 配置。\n\n- `syscall_user_dispatch_set_config(...)`  \n  通过 `ptrace` 设置指定任务的 SUD 配置。\n\n### 关键数据结构\n\n- `struct syscall_user_dispatch`（定义在 `<linux/syscall_user_dispatch.h>`）  \n  存储每个任务的 SUD 配置：\n  - `selector`：指向用户空间选择器字节的指针\n  - `offset` / `len`：允许直接执行系统调用的代码区域（[offset, offset+len)）\n  - `on_dispatch`：标志位，表示当前是否处于分发拦截状态\n\n- `struct ptrace_sud_config`  \n  用于 `ptrace` 接口传递 SUD 配置的结构体，包含 `mode`、`offset`、`len` 和 `selector`。\n\n## 3. 关键实现\n\n### 系统调用拦截逻辑\n\n1. **区域检查**：若当前指令指针（`instruction_pointer(regs)`）落在 `[offset, offset + len)` 范围内，则**允许**系统调用直接执行，不进行拦截。\n2. **vdso 例外**：若系统调用来自 vDSO 中的 `sigreturn`（如 `arch_syscall_is_vdso_sigreturn()` 返回 true），则跳过拦截，避免干扰信号返回路径。\n3. **选择器读取**：若配置了 `selector`，则从用户空间读取一个字节的状态值：\n   - `SYSCALL_DISPATCH_FILTER_ALLOW`（0）：允许系统调用\n   - `SYSCALL_DISPATCH_FILTER_BLOCK`（1）：触发拦截\n   - 其他值：视为非法，发送 `SIGSYS`\n4. **拦截处理**：\n   - 设置 `on_dispatch = true`\n   - 调用 `syscall_rollback()` 回滚系统调用（恢复寄存器状态）\n   - 调用 `trigger_sigsys()` 发送 `SIGSYS` 信号\n\n### 安全与健壮性设计\n\n- **地址合法性校验**：在设置 `selector` 时使用 `access_ok(untagged_addr(selector), ...)`，确保地址可访问，并处理内存标记（如 ARM MTE）场景下调试器（tracer）与被调试进程（tracee）地址标记不一致的问题。\n- **溢出防护**：检查 `offset + len <= offset` 防止整数溢出导致无效区域。\n- **权限隔离**：`ptrace` 接口允许调试器配置其他进程的 SUD，但需具备相应权限。\n\n### 信号信息构造\n\n`trigger_sigsys()` 构造的 `siginfo_t` 包含：\n- `si_signo = SIGSYS`\n- `si_code = SYS_USER_DISPATCH`\n- `si_call_addr`：触发系统调用的用户空间地址\n- `si_syscall`：系统调用号\n- `si_arch`：系统调用架构（如 x86_64、AArch64）\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/prctl.h>`：定义 `PR_SYS_DISPATCH_*` 常量\n  - `<linux/syscall_user_dispatch.h>`：定义 `struct syscall_user_dispatch` 和相关常量\n  - `<asm/syscall.h>`：提供 `syscall_get_arch()`、`syscall_get_nr()` 等架构相关接口\n  - `\"common.h\"`：可能包含内核入口通用辅助函数\n- **内核子系统**：\n  - **调度器（sched）**：访问 `current` 任务结构\n  - **信号子系统（signal）**：发送 `SIGSYS` 信号\n  - **内存管理（uaccess）**：用户空间内存访问（`__get_user`, `access_ok`）\n  - **ptrace**：支持调试器配置 SUD\n  - **ELF**：可能用于架构识别（间接依赖）\n\n## 5. 使用场景\n\n- **沙箱环境**：限制应用只能在特定代码段发起系统调用，防止恶意代码绕过安全策略。\n- **动态二进制插桩（DBI）**：工具（如 Valgrind、Intel Pin）可拦截系统调用进行分析或重定向。\n- **安全监控**：监控程序可配置选择器为“阻塞”，在 `SIGSYS` 信号处理程序中记录或审查系统调用。\n- **调试与测试**：通过 `ptrace` 动态启用/禁用 SUD，用于测试系统调用拦截逻辑。\n- **W^X 策略增强**：结合代码段只读与 SUD，确保只有可信代码路径可发起系统调用。",
      "similarity": 0.6138179302215576,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2020 Collabora Ltd.",
            " */",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/signal.h>",
            "#include <linux/elf.h>",
            "",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task_stack.h>",
            "",
            "#include <asm/syscall.h>",
            "",
            "#include \"common.h\"",
            ""
          ],
          "function_name": null,
          "description": "包含系统调用用户分发功能所需头文件及通用定义，提供架构相关接口和内核调度必要声明",
          "similarity": 0.6391171216964722
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 20,
          "end_line": 122,
          "content": [
            "static void trigger_sigsys(struct pt_regs *regs)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSYS;",
            "\tinfo.si_code = SYS_USER_DISPATCH;",
            "\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_arch = syscall_get_arch(current);",
            "\tinfo.si_syscall = syscall_get_nr(current, regs);",
            "",
            "\tforce_sig_info(&info);",
            "}",
            "bool syscall_user_dispatch(struct pt_regs *regs)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;",
            "\tchar state;",
            "",
            "\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))",
            "\t\treturn false;",
            "",
            "\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))",
            "\t\treturn false;",
            "",
            "\tif (likely(sd->selector)) {",
            "\t\t/*",
            "\t\t * access_ok() is performed once, at prctl time, when",
            "\t\t * the selector is loaded by userspace.",
            "\t\t */",
            "\t\tif (unlikely(__get_user(state, sd->selector))) {",
            "\t\t\tforce_exit_sig(SIGSEGV);",
            "\t\t\treturn true;",
            "\t\t}",
            "",
            "\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))",
            "\t\t\treturn false;",
            "",
            "\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {",
            "\t\t\tforce_exit_sig(SIGSYS);",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tsd->on_dispatch = true;",
            "\tsyscall_rollback(current, regs);",
            "\ttrigger_sigsys(regs);",
            "",
            "\treturn true;",
            "}",
            "static int task_set_syscall_user_dispatch(struct task_struct *task, unsigned long mode,",
            "\t\t\t\t\t  unsigned long offset, unsigned long len,",
            "\t\t\t\t\t  char __user *selector)",
            "{",
            "\tswitch (mode) {",
            "\tcase PR_SYS_DISPATCH_OFF:",
            "\t\tif (offset || len || selector)",
            "\t\t\treturn -EINVAL;",
            "\t\tbreak;",
            "\tcase PR_SYS_DISPATCH_ON:",
            "\t\t/*",
            "\t\t * Validate the direct dispatcher region just for basic",
            "\t\t * sanity against overflow and a 0-sized dispatcher",
            "\t\t * region.  If the user is able to submit a syscall from",
            "\t\t * an address, that address is obviously valid.",
            "\t\t */",
            "\t\tif (offset && offset + len <= offset)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * access_ok() will clear memory tags for tagged addresses",
            "\t\t * if current has memory tagging enabled.",
            "",
            "\t\t * To enable a tracer to set a tracees selector the",
            "\t\t * selector address must be untagged for access_ok(),",
            "\t\t * otherwise an untagged tracer will always fail to set a",
            "\t\t * tagged tracees selector.",
            "\t\t */",
            "\t\tif (selector && !access_ok(untagged_addr(selector), sizeof(*selector)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttask->syscall_dispatch.selector = selector;",
            "\ttask->syscall_dispatch.offset = offset;",
            "\ttask->syscall_dispatch.len = len;",
            "\ttask->syscall_dispatch.on_dispatch = false;",
            "",
            "\tif (mode == PR_SYS_DISPATCH_ON)",
            "\t\tset_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "\telse",
            "\t\tclear_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "",
            "\treturn 0;",
            "}",
            "int set_syscall_user_dispatch(unsigned long mode, unsigned long offset,",
            "\t\t\t      unsigned long len, char __user *selector)",
            "{",
            "\treturn task_set_syscall_user_dispatch(current, mode, offset, len, selector);",
            "}"
          ],
          "function_name": "trigger_sigsys, syscall_user_dispatch, task_set_syscall_user_dispatch, set_syscall_user_dispatch",
          "description": "实现系统调用用户分发核心逻辑，包含触发SIGSYS信号处理、配置验证、拦截判断及模式切换功能",
          "similarity": 0.5926955938339233
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 127,
          "end_line": 163,
          "content": [
            "int syscall_user_dispatch_get_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &task->syscall_dispatch;",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (test_task_syscall_work(task, SYSCALL_USER_DISPATCH))",
            "\t\tcfg.mode = PR_SYS_DISPATCH_ON;",
            "\telse",
            "\t\tcfg.mode = PR_SYS_DISPATCH_OFF;",
            "",
            "\tcfg.offset = sd->offset;",
            "\tcfg.len = sd->len;",
            "\tcfg.selector = (__u64)(uintptr_t)sd->selector;",
            "",
            "\tif (copy_to_user(data, &cfg, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn 0;",
            "}",
            "int syscall_user_dispatch_set_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (copy_from_user(&cfg, data, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn task_set_syscall_user_dispatch(task, cfg.mode, cfg.offset, cfg.len,",
            "\t\t\t\t\t      (char __user *)(uintptr_t)cfg.selector);",
            "}"
          ],
          "function_name": "syscall_user_dispatch_get_config, syscall_user_dispatch_set_config",
          "description": "提供系统调用分发配置的获取与设置接口，通过用户态指针操作实现配置参数的双向传递",
          "similarity": 0.5903674364089966
        }
      ]
    },
    {
      "source_file": "kernel/trace/pid_list.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:04:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\pid_list.c`\n\n---\n\n# `trace/pid_list.c` 技术文档\n\n## 1. 文件概述\n\n`trace/pid_list.c` 实现了一个高效、可扩展的 PID（进程标识符）集合管理机制，用于 Linux 内核跟踪子系统（ftrace）中对特定进程的过滤控制。该文件通过三级位图结构（upper1 → upper2 → lower）将 PID 空间分层组织，支持快速的 PID 设置、清除、查询及遍历操作，同时兼顾内存使用效率和并发安全性。该实现特别适用于需要动态跟踪大量进程但又不能占用过多连续内存的场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trace_pid_list_is_set()`：检查指定 PID 是否在列表中（用于调度时快速判断是否应跟踪该任务）。\n- `trace_pid_list_set()`：将指定 PID 加入跟踪列表。\n- `trace_pid_list_clear()`：从跟踪列表中移除指定 PID，并在对应位图块为空时自动释放内存。\n- `trace_pid_list_next()`：从给定 PID 开始查找下一个存在于列表中的 PID（用于遍历所有被跟踪的 PID）。\n\n### 辅助内联函数\n\n- `get_lower_chunk()` / `put_lower_chunk()`：从空闲链表中分配或归还底层位图块（`lower_chunk`）。\n- `get_upper_chunk()` / `put_upper_chunk()`：从空闲链表中分配或归还上层索引块（`upper_chunk`）。\n- `upper_empty()`：判断一个 `upper_chunk` 是否完全为空（所有 `lower_chunk` 均为 NULL）。\n- `pid_split()` / `pid_join()`：将 PID 拆分为三级索引（upper1, upper2, lower）或将三级索引合并为 PID。\n\n### 关键数据结构（定义于 `pid_list.h`）\n\n- `struct trace_pid_list`：PID 列表的主结构体，包含：\n  - 两级指针数组：`upper[UPPER_MAX]` 指向 `upper_chunk`。\n  - 空闲块链表：`lower_list` 和 `upper_list` 用于缓存未使用的块。\n  - 计数器：`free_lower_chunks` 和 `free_upper_chunks`。\n  - 自旋锁：`lock` 保证并发安全。\n  - 中断工作队列：`refill_irqwork` 用于异步补充空闲块。\n- `union upper_chunk`：包含一个指针数组 `data[UPPER_MAX]`，每个元素指向一个 `lower_chunk`。\n- `union lower_chunk`：包含一个位图数组 `data[LOWER_SIZE]`，用于存储 `LOWER_MAX` 个 PID 的存在状态。\n\n## 3. 关键实现\n\n### 三级分层位图结构\n- **设计目的**：避免为整个 PID 空间（最大 `PID_MAX_LIMIT`，通常为 4194304）分配连续大内存。\n- **层级划分**：\n  - **Upper1**：最高位，索引 `trace_pid_list->upper[]` 数组（大小 `UPPER_MAX`）。\n  - **Upper2**：中间位，索引 `upper_chunk->data[]` 数组（大小 `UPPER_MAX`）。\n  - **Lower**：最低位，索引 `lower_chunk->data` 位图中的具体位（范围 `0` 到 `LOWER_MAX-1`）。\n- **内存效率**：仅当某 PID 范围被使用时才动态分配对应的 `upper_chunk` 和 `lower_chunk`。\n\n### 并发与内存管理\n- **自旋锁保护**：所有操作均在 `pid_list->lock` 保护下进行，使用 `raw_spin_lock_irqsave()` 禁用本地中断以确保在硬中断上下文（如调度器）中的安全性。\n- **空闲块缓存**：通过 `lower_list` 和 `upper_list` 链表缓存已释放的块，避免频繁的内存分配/释放。\n- **异步补充机制**：当空闲块数量低于阈值 `CHUNK_REALLOC` 时，通过 `irq_work_queue()` 触发中断上下文工作（`refill_irqwork`）来补充空闲块，避免在持有调度器锁时执行耗时的内存分配。\n\n### 动态释放\n- 在 `trace_pid_list_clear()` 中，清除位后检查 `lower_chunk` 是否全零：\n  - 若是，则将其归还到 `lower_list` 并置空 `upper_chunk->data[upper2]`。\n  - 进一步检查 `upper_chunk` 是否完全为空（所有 `data[]` 为 NULL），若是则归还到 `upper_list` 并置空 `pid_list->upper[upper1]`。\n\n### PID 遍历算法\n- `trace_pid_list_next()` 从给定 PID 的拆分索引开始，按 `upper1 → upper2 → lower` 顺序遍历：\n  - 外层循环遍历 `upper1`（从起始值到 `UPPER_MASK`）。\n  - 内层循环遍历 `upper2`（从起始值或 0 到 `UPPER_MASK`）。\n  - 在有效的 `lower_chunk` 中使用 `find_next_bit()` 查找下一个置位的 PID。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/spinlock.h>`：提供自旋锁原语。\n  - `<linux/irq_work.h>`：提供中断上下文工作队列机制。\n  - `<linux/slab.h>`：提供内存分配接口（由 `pid_list.h` 或其他文件间接使用）。\n  - `\"trace.h\"`：包含跟踪子系统通用定义及 `pid_list.h`。\n- **数据结构依赖**：依赖 `pid_list.h` 中定义的 `struct trace_pid_list`、`union upper_chunk`、`union lower_chunk` 及相关常量（如 `UPPER_MASK`、`LOWER_MASK`、`CHUNK_REALLOC` 等）。\n- **内核子系统**：作为 ftrace 跟踪过滤机制的核心组件，被调度器（`kernel/sched/`）和 tracefs 接口（`kernel/trace/`）调用。\n\n## 5. 使用场景\n\n- **动态进程跟踪**：用户通过 tracefs 接口（如 `set_ftrace_pid`）指定要跟踪的进程 PID，内核调用 `trace_pid_list_set()` 将其加入列表。\n- **调度器过滤**：在任务切换时（`__schedule()`），调度器调用 `trace_pid_list_is_set()` 快速判断当前任务是否应被跟踪，决定是否触发跟踪事件。\n- **进程生命周期管理**：\n  - **Fork**：若父进程在跟踪列表中且配置了跟踪子进程，则新进程 PID 通过 `trace_pid_list_set()` 加入列表。\n  - **Exit**：任务退出时，若其 PID 在列表中，则通过 `trace_pid_list_clear()` 移除。\n- **PID 列表遍历**：调试工具或内核接口需要枚举所有被跟踪的 PID 时，调用 `trace_pid_list_next()` 进行迭代。\n- **内存压力处理**：在高并发设置/清除 PID 时，通过异步 `irq_work` 补充空闲块，避免在关键路径（如调度器）中阻塞。",
      "similarity": 0.5979319214820862,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 457,
          "end_line": 495,
          "content": [
            "void trace_pid_list_free(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *upper;",
            "\tunion lower_chunk *lower;",
            "\tint i, j;",
            "",
            "\tif (!pid_list)",
            "\t\treturn;",
            "",
            "\tirq_work_sync(&pid_list->refill_irqwork);",
            "",
            "\twhile (pid_list->lower_list) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->lower_list;",
            "\t\tpid_list->lower_list = pid_list->lower_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\twhile (pid_list->upper_list) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->upper_list;",
            "\t\tpid_list->upper_list = pid_list->upper_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\tfor (i = 0; i < UPPER1_SIZE; i++) {",
            "\t\tupper = pid_list->upper[i];",
            "\t\tif (upper) {",
            "\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {",
            "\t\t\t\tlower = upper->data[j];",
            "\t\t\t\tkfree(lower);",
            "\t\t\t}",
            "\t\t\tkfree(upper);",
            "\t\t}",
            "\t}",
            "\tkfree(pid_list);",
            "}"
          ],
          "function_name": "trace_pid_list_free",
          "description": "释放trace_pid_list及其关联的所有内存资源，递归回收上层块和下层块链表，彻底清理PID跟踪结构体占用的内存量。",
          "similarity": 0.5423918962478638
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2021 VMware Inc, Steven Rostedt <rostedt@goodmis.org>",
            " */",
            "#include <linux/spinlock.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include \"trace.h\"",
            "",
            "/* See pid_list.h for details */",
            "",
            "static inline union lower_chunk *get_lower_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion lower_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->lower_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->lower_list;",
            "\tpid_list->lower_list = chunk->next;",
            "\tpid_list->free_lower_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_lower_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_lower_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            "",
            "static inline union upper_chunk *get_upper_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->upper_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->upper_list;",
            "\tpid_list->upper_list = chunk->next;",
            "\tpid_list->free_upper_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_upper_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_upper_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现从trace_pid_list结构中获取下层和上层块的函数，通过原子操作减少空闲块计数并可能触发异步补充分配，用于动态管理PID跟踪的内存块。",
          "similarity": 0.5306159853935242
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 221,
          "end_line": 377,
          "content": [
            "int trace_pid_list_clear(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (!upper_chunk)",
            "\t\tgoto out;",
            "",
            "\tlower_chunk = upper_chunk->data[upper2];",
            "\tif (!lower_chunk)",
            "\t\tgoto out;",
            "",
            "\tclear_bit(lower, lower_chunk->data);",
            "",
            "\t/* if there's no more bits set, add it to the free list */",
            "\tif (find_first_bit(lower_chunk->data, LOWER_MAX) >= LOWER_MAX) {",
            "\t\tput_lower_chunk(pid_list, lower_chunk);",
            "\t\tupper_chunk->data[upper2] = NULL;",
            "\t\tif (upper_empty(upper_chunk)) {",
            "\t\t\tput_upper_chunk(pid_list, upper_chunk);",
            "\t\t\tpid_list->upper[upper1] = NULL;",
            "\t\t}",
            "\t}",
            " out:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_next(struct trace_pid_list *pid_list, unsigned int pid,",
            "\t\t\tunsigned int *next)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tfor (; upper1 <= UPPER_MASK; upper1++, upper2 = 0) {",
            "\t\tupper_chunk = pid_list->upper[upper1];",
            "",
            "\t\tif (!upper_chunk)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (; upper2 <= UPPER_MASK; upper2++, lower = 0) {",
            "\t\t\tlower_chunk = upper_chunk->data[upper2];",
            "\t\t\tif (!lower_chunk)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tlower = find_next_bit(lower_chunk->data, LOWER_MAX,",
            "\t\t\t\t\t    lower);",
            "\t\t\tif (lower < LOWER_MAX)",
            "\t\t\t\tgoto found;",
            "\t\t}",
            "\t}",
            "",
            " found:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\tif (upper1 > UPPER_MASK)",
            "\t\treturn -1;",
            "",
            "\t*next = pid_join(upper1, upper2, lower);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_first(struct trace_pid_list *pid_list, unsigned int *pid)",
            "{",
            "\treturn trace_pid_list_next(pid_list, 0, pid);",
            "}",
            "static void pid_list_refill_irq(struct irq_work *iwork)",
            "{",
            "\tstruct trace_pid_list *pid_list = container_of(iwork, struct trace_pid_list,",
            "\t\t\t\t\t\t       refill_irqwork);",
            "\tunion upper_chunk *upper = NULL;",
            "\tunion lower_chunk *lower = NULL;",
            "\tunion upper_chunk **upper_next = &upper;",
            "\tunion lower_chunk **lower_next = &lower;",
            "\tint upper_count;",
            "\tint lower_count;",
            "\tint ucnt = 0;",
            "\tint lcnt = 0;",
            "",
            " again:",
            "\traw_spin_lock(&pid_list->lock);",
            "\tupper_count = CHUNK_ALLOC - pid_list->free_upper_chunks;",
            "\tlower_count = CHUNK_ALLOC - pid_list->free_lower_chunks;",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\tif (upper_count <= 0 && lower_count <= 0)",
            "\t\treturn;",
            "",
            "\twhile (upper_count-- > 0) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*upper_next = chunk;",
            "\t\tupper_next = &chunk->next;",
            "\t\tucnt++;",
            "\t}",
            "",
            "\twhile (lower_count-- > 0) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*lower_next = chunk;",
            "\t\tlower_next = &chunk->next;",
            "\t\tlcnt++;",
            "\t}",
            "",
            "\traw_spin_lock(&pid_list->lock);",
            "\tif (upper) {",
            "\t\t*upper_next = pid_list->upper_list;",
            "\t\tpid_list->upper_list = upper;",
            "\t\tpid_list->free_upper_chunks += ucnt;",
            "\t}",
            "\tif (lower) {",
            "\t\t*lower_next = pid_list->lower_list;",
            "\t\tpid_list->lower_list = lower;",
            "\t\tpid_list->free_lower_chunks += lcnt;",
            "\t}",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\t/*",
            "\t * On success of allocating all the chunks, both counters",
            "\t * will be less than zero. If they are not, then an allocation",
            "\t * failed, and we should not try again.",
            "\t */",
            "\tif (upper_count >= 0 || lower_count >= 0)",
            "\t\treturn;",
            "\t/*",
            "\t * When the locks were released, free chunks could have",
            "\t * been used and allocation needs to be done again. Might as",
            "\t * well allocate it now.",
            "\t */",
            "\tgoto again;",
            "}"
          ],
          "function_name": "trace_pid_list_clear, trace_pid_list_next, trace_pid_list_first, pid_list_refill_irq",
          "description": "实现PID集合的遍历与清理功能，包含按序查找下一个PID、首次PID查询及异步内存补充分配逻辑，支持动态扩展存储结构以避免内存耗尽。",
          "similarity": 0.5268539190292358
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 60,
          "end_line": 180,
          "content": [
            "static inline void put_lower_chunk(struct trace_pid_list *pid_list,",
            "\t\t\t\t   union lower_chunk *chunk)",
            "{",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tchunk->next = pid_list->lower_list;",
            "\tpid_list->lower_list = chunk;",
            "\tpid_list->free_lower_chunks++;",
            "}",
            "static inline void put_upper_chunk(struct trace_pid_list *pid_list,",
            "\t\t\t\t   union upper_chunk *chunk)",
            "{",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tchunk->next = pid_list->upper_list;",
            "\tpid_list->upper_list = chunk;",
            "\tpid_list->free_upper_chunks++;",
            "}",
            "static inline bool upper_empty(union upper_chunk *chunk)",
            "{",
            "\t/*",
            "\t * If chunk->data has no lower chunks, it will be the same",
            "\t * as a zeroed bitmask. Use find_first_bit() to test it",
            "\t * and if it doesn't find any bits set, then the array",
            "\t * is empty.",
            "\t */",
            "\tint bit = find_first_bit((unsigned long *)chunk->data,",
            "\t\t\t\t sizeof(chunk->data) * 8);",
            "\treturn bit >= sizeof(chunk->data) * 8;",
            "}",
            "static inline int pid_split(unsigned int pid, unsigned int *upper1,",
            "\t\t\t     unsigned int *upper2, unsigned int *lower)",
            "{",
            "\t/* MAX_PID should cover all pids */",
            "\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);",
            "",
            "\t/* In case a bad pid is passed in, then fail */",
            "\tif (unlikely(pid >= MAX_PID))",
            "\t\treturn -1;",
            "",
            "\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;",
            "\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;",
            "\t*lower = pid & LOWER_MASK;",
            "",
            "\treturn 0;",
            "}",
            "static inline unsigned int pid_join(unsigned int upper1,",
            "\t\t\t\t    unsigned int upper2, unsigned int lower)",
            "{",
            "\treturn ((upper1 & UPPER_MASK) << UPPER1_SHIFT) |",
            "\t\t((upper2 & UPPER_MASK) << UPPER2_SHIFT) |",
            "\t\t(lower & LOWER_MASK);",
            "}",
            "bool trace_pid_list_is_set(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "\tbool ret = false;",
            "",
            "\tif (!pid_list)",
            "\t\treturn false;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn false;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (upper_chunk) {",
            "\t\tlower_chunk = upper_chunk->data[upper2];",
            "\t\tif (lower_chunk)",
            "\t\t\tret = test_bit(lower, lower_chunk->data);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "int trace_pid_list_set(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "\tint ret;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (!upper_chunk) {",
            "\t\tupper_chunk = get_upper_chunk(pid_list);",
            "\t\tif (!upper_chunk) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tpid_list->upper[upper1] = upper_chunk;",
            "\t}",
            "\tlower_chunk = upper_chunk->data[upper2];",
            "\tif (!lower_chunk) {",
            "\t\tlower_chunk = get_lower_chunk(pid_list);",
            "\t\tif (!lower_chunk) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tupper_chunk->data[upper2] = lower_chunk;",
            "\t}",
            "\tset_bit(lower, lower_chunk->data);",
            "\tret = 0;",
            " out:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "put_lower_chunk, put_upper_chunk, upper_empty, pid_split, pid_join, trace_pid_list_is_set, trace_pid_list_set",
          "description": "提供PID存储结构的辅助操作，包括块回收、位掩码操作、PID地址转换及集合状态查询与更新，实现基于多级位图的高效PID追踪。",
          "similarity": 0.4931398332118988
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_syscalls.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:39:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_syscalls.c`\n\n---\n\n# `trace_syscalls.c` 技术文档\n\n## 1. 文件概述\n\n`trace_syscalls.c` 是 Linux 内核中用于实现系统调用追踪（syscall tracing）的核心文件。它通过 ftrace 框架提供对系统调用入口（enter）和出口（exit）事件的动态追踪能力，支持将系统调用的名称、参数及返回值记录到内核追踪缓冲区中，供用户空间工具（如 `trace-cmd`、`perf`）分析使用。该文件负责注册系统调用追踪事件、解析系统调用元数据、格式化输出内容，并与架构相关的系统调用接口进行适配。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct syscall_metadata`：描述单个系统调用的元数据，包括名称、参数数量、参数类型、参数名、以及对应的 enter/exit 追踪事件。\n- `syscall_trace_enter` / `syscall_trace_exit`：用于在追踪缓冲区中记录系统调用进入和退出事件的数据结构。\n- `syscalls_metadata_sparse`（XArray）：在 `CONFIG_HAVE_SPARSE_SYSCALL_NR` 启用时，使用 XArray 存储稀疏的系统调用元数据映射。\n- `syscalls_metadata`（数组）：传统稠密数组形式的系统调用元数据索引。\n\n### 主要函数\n- `find_syscall_meta()`：根据系统调用函数地址查找对应的 `syscall_metadata`。\n- `syscall_nr_to_meta()`：根据系统调用号（syscall number）获取元数据。\n- `get_syscall_name()`：根据系统调用号返回其名称字符串。\n- `print_syscall_enter()` / `print_syscall_exit()`：格式化输出系统调用进入/退出事件到追踪序列。\n- `ftrace_syscall_enter()` / `ftrace_syscall_exit()`：ftrace 探针回调函数，在系统调用入口/出口处被调用，负责写入追踪事件。\n- `syscall_enter_define_fields()`：为追踪事件定义字段（用于过滤和解析）。\n- `set_syscall_print_fmt()` / `free_syscall_print_fmt()`：动态生成并管理追踪事件的打印格式字符串。\n- `syscall_enter_register()` / `syscall_exit_register()`：追踪事件注册/注销回调函数。\n- `trace_get_syscall_nr()`：获取当前任务的系统调用号，支持架构特定的兼容性处理（如忽略 32 位兼容调用）。\n\n## 3. 关键实现\n\n### 系统调用元数据管理\n- 系统调用元数据由编译器通过 `__start_syscalls_metadata` 和 `__stop_syscalls_metadata` 符号自动收集，形成一个静态数组。\n- 支持两种索引方式：\n  - **稠密数组**：`syscalls_metadata[nr]` 直接通过系统调用号索引（适用于系统调用号连续的架构）。\n  - **稀疏 XArray**：当启用 `CONFIG_HAVE_SPARSE_SYSCALL_NR` 时，使用 XArray 存储非连续的系统调用号映射，节省内存。\n\n### 架构适配机制\n- **符号名匹配**：通过 `arch_syscall_match_sym_name()` 忽略符号前缀差异（如 `sys_`、`.SyS_`、`.sys_`），确保正确匹配系统调用函数。\n- **兼容系统调用处理**：若定义 `ARCH_TRACE_IGNORE_COMPAT_SYSCALLS`，则通过 `arch_trace_is_compat_syscall()` 判断并忽略 32 位兼容系统调用，避免追踪错误。\n\n### 追踪事件格式化\n- **动态生成 print_fmt**：`__set_enter_print_fmt()` 根据系统调用的参数数量和名称，动态构造格式化字符串（如 `\"arg1: 0x%016lx, arg2: 0x%016lx\"`），用于 `trace_printk` 风格的输出。\n- **字段定义**：`syscall_enter_define_fields()` 为每个参数注册字段信息，支持后续的过滤和解析（如 `trace-cmd filter`）。\n\n### 安全与性能\n- **抢占保护**：在 `ftrace_syscall_enter/exit` 中使用 `guard(preempt_notrace)()` 禁用抢占，确保对 per-CPU ring buffer 的安全访问。\n- **RCU 保护**：通过 `rcu_dereference_sched()` 安全访问 per-tracer 的系统调用文件指针数组。\n- **软禁用检查**：调用 `trace_trigger_soft_disabled()` 检查是否临时禁用该追踪点，避免不必要的开销。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<trace/syscall.h>`：定义 `struct syscall_metadata` 等核心结构。\n  - `<trace/events/syscalls.h>`：声明系统调用追踪事件（`TRACE_EVENT` 宏生成）。\n  - `<asm/syscall.h>`：提供架构相关的 `syscall_get_nr()` 等函数。\n  - `\"trace.h\"` / `\"trace_output.h\"`：ftrace 核心接口和输出工具。\n- **内核子系统**：\n  - **ftrace**：作为 ftrace 的事件提供者，注册动态追踪点。\n  - **perf_events**：可通过 perf 接口启用系统调用追踪。\n  - **kallsyms**：用于通过地址反查符号名（`kallsyms_lookup`）。\n  - **XArray**：用于稀疏系统调用号的高效存储（`CONFIG_XARRAY`）。\n- **架构支持**：依赖架构实现 `syscall_get_nr()`、`arch_trace_is_compat_syscall()`（可选）等函数。\n\n## 5. 使用场景\n\n- **系统调用行为分析**：通过 `echo 1 > /sys/kernel/debug/tracing/events/syscalls/enable` 启用所有系统调用追踪，观察应用程序的系统调用序列、参数及返回值。\n- **性能剖析**：结合 `perf` 工具，统计特定系统调用的调用频率、延迟分布。\n- **安全审计**：监控敏感系统调用（如 `execve`、`open`）的使用情况。\n- **调试内核问题**：在系统调用路径上插入追踪点，辅助定位死锁、异常返回等问题。\n- **动态追踪框架集成**：作为 ftrace 事件源，被 `trace-cmd`、`bpftrace` 等高级追踪工具调用。",
      "similarity": 0.5974105596542358,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 1,
          "end_line": 37,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <trace/syscall.h>",
            "#include <trace/events/syscalls.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/ftrace.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/xarray.h>",
            "#include <asm/syscall.h>",
            "",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "",
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "",
            "static int syscall_enter_register(struct trace_event_call *event,",
            "\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,",
            "\t\t\t\t enum trace_reg type, void *data);",
            "",
            "static struct list_head *",
            "syscall_get_enter_fields(struct trace_event_call *call)",
            "{",
            "\tstruct syscall_metadata *entry = call->data;",
            "",
            "\treturn &entry->enter_fields;",
            "}",
            "",
            "extern struct syscall_metadata *__start_syscalls_metadata[];",
            "extern struct syscall_metadata *__stop_syscalls_metadata[];",
            "",
            "static DEFINE_XARRAY(syscalls_metadata_sparse);",
            "static struct syscall_metadata **syscalls_metadata;",
            "",
            "#ifndef ARCH_HAS_SYSCALL_MATCH_SYM_NAME"
          ],
          "function_name": null,
          "description": "定义系统调用跟踪所需的数据结构和锁，声明元数据数组及辅助函数，用于管理系统调用跟踪的注册与注销流程。",
          "similarity": 0.649560809135437
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 38,
          "end_line": 163,
          "content": [
            "static inline bool arch_syscall_match_sym_name(const char *sym, const char *name)",
            "{",
            "\t/*",
            "\t * Only compare after the \"sys\" prefix. Archs that use",
            "\t * syscall wrappers may have syscalls symbols aliases prefixed",
            "\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted",
            "\t * mismatch.",
            "\t */",
            "\treturn !strcmp(sym + 3, name + 3);",
            "}",
            "static int",
            "trace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)",
            "{",
            "\tif (unlikely(arch_trace_is_compat_syscall(regs)))",
            "\t\treturn -1;",
            "",
            "\treturn syscall_get_nr(task, regs);",
            "}",
            "static inline int",
            "trace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)",
            "{",
            "\treturn syscall_get_nr(task, regs);",
            "}",
            "static enum print_line_t",
            "print_syscall_enter(struct trace_iterator *iter, int flags,",
            "\t\t    struct trace_event *event)",
            "{",
            "\tstruct trace_array *tr = iter->tr;",
            "\tstruct trace_seq *s = &iter->seq;",
            "\tstruct trace_entry *ent = iter->ent;",
            "\tstruct syscall_trace_enter *trace;",
            "\tstruct syscall_metadata *entry;",
            "\tint i, syscall;",
            "",
            "\ttrace = (typeof(trace))ent;",
            "\tsyscall = trace->nr;",
            "\tentry = syscall_nr_to_meta(syscall);",
            "",
            "\tif (!entry)",
            "\t\tgoto end;",
            "",
            "\tif (entry->enter_event->event.type != ent->type) {",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tgoto end;",
            "\t}",
            "",
            "\ttrace_seq_printf(s, \"%s(\", entry->name);",
            "",
            "\tfor (i = 0; i < entry->nb_args; i++) {",
            "",
            "\t\tif (trace_seq_has_overflowed(s))",
            "\t\t\tgoto end;",
            "",
            "\t\t/* parameter types */",
            "\t\tif (tr && tr->trace_flags & TRACE_ITER_VERBOSE)",
            "\t\t\ttrace_seq_printf(s, \"%s \", entry->types[i]);",
            "",
            "\t\t/* parameter values */",
            "\t\ttrace_seq_printf(s, \"%s: %lx%s\", entry->args[i],",
            "\t\t\t\t trace->args[i],",
            "\t\t\t\t i == entry->nb_args - 1 ? \"\" : \", \");",
            "\t}",
            "",
            "\ttrace_seq_putc(s, ')');",
            "end:",
            "\ttrace_seq_putc(s, '\\n');",
            "",
            "\treturn trace_handle_return(s);",
            "}",
            "static enum print_line_t",
            "print_syscall_exit(struct trace_iterator *iter, int flags,",
            "\t\t   struct trace_event *event)",
            "{",
            "\tstruct trace_seq *s = &iter->seq;",
            "\tstruct trace_entry *ent = iter->ent;",
            "\tstruct syscall_trace_exit *trace;",
            "\tint syscall;",
            "\tstruct syscall_metadata *entry;",
            "",
            "\ttrace = (typeof(trace))ent;",
            "\tsyscall = trace->nr;",
            "\tentry = syscall_nr_to_meta(syscall);",
            "",
            "\tif (!entry) {",
            "\t\ttrace_seq_putc(s, '\\n');",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (entry->exit_event->event.type != ent->type) {",
            "\t\tWARN_ON_ONCE(1);",
            "\t\treturn TRACE_TYPE_UNHANDLED;",
            "\t}",
            "",
            "\ttrace_seq_printf(s, \"%s -> 0x%lx\\n\", entry->name,",
            "\t\t\t\ttrace->ret);",
            "",
            " out:",
            "\treturn trace_handle_return(s);",
            "}",
            "static int __init",
            "__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)",
            "{",
            "\tint i;",
            "\tint pos = 0;",
            "",
            "\t/* When len=0, we just calculate the needed length */",
            "#define LEN_OR_ZERO (len ? len - pos : 0)",
            "",
            "\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");",
            "\tfor (i = 0; i < entry->nb_args; i++) {",
            "\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",",
            "\t\t\t\tentry->args[i], sizeof(unsigned long),",
            "\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");",
            "\t}",
            "\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");",
            "",
            "\tfor (i = 0; i < entry->nb_args; i++) {",
            "\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,",
            "\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);",
            "\t}",
            "",
            "#undef LEN_OR_ZERO",
            "",
            "\t/* return the length of print_fmt */",
            "\treturn pos;",
            "}"
          ],
          "function_name": "arch_syscall_match_sym_name, trace_get_syscall_nr, trace_get_syscall_nr, print_syscall_enter, print_syscall_exit, __set_enter_print_fmt",
          "description": "实现系统调用号解析、符号匹配逻辑，以及跟踪事件打印函数，动态构造并输出系统调用参数和返回值的详细信息。",
          "similarity": 0.6429588198661804
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 676,
          "end_line": 795,
          "content": [
            "\tstruct syscall_tp_t {",
            "\t\tstruct trace_entry ent;",
            "\t\tunsigned long syscall_nr;",
            "\t\tunsigned long ret;",
            "\t} __aligned(8) param;",
            "",
            "\t/* bpf prog requires 'regs' to be the first member in the ctx (a.k.a. &param) */",
            "\tperf_fetch_caller_regs(regs);",
            "\t*(struct pt_regs **)&param = regs;",
            "\tparam.syscall_nr = rec->nr;",
            "\tparam.ret = rec->ret;",
            "\treturn trace_call_bpf(call, &param);",
            "}",
            "",
            "static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)",
            "{",
            "\tstruct syscall_metadata *sys_data;",
            "\tstruct syscall_trace_exit *rec;",
            "\tstruct pt_regs *fake_regs;",
            "\tstruct hlist_head *head;",
            "\tbool valid_prog_array;",
            "\tint syscall_nr;",
            "\tint rctx;",
            "\tint size;",
            "",
            "\tsyscall_nr = trace_get_syscall_nr(current, regs);",
            "\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)",
            "\t\treturn;",
            "\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))",
            "\t\treturn;",
            "",
            "\tsys_data = syscall_nr_to_meta(syscall_nr);",
            "\tif (!sys_data)",
            "\t\treturn;",
            "",
            "\thead = this_cpu_ptr(sys_data->exit_event->perf_events);",
            "\tvalid_prog_array = bpf_prog_array_valid(sys_data->exit_event);",
            "\tif (!valid_prog_array && hlist_empty(head))",
            "\t\treturn;",
            "",
            "\t/* We can probably do that at build time */",
            "\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));",
            "\tsize -= sizeof(u32);",
            "",
            "\trec = perf_trace_buf_alloc(size, &fake_regs, &rctx);",
            "\tif (!rec)",
            "\t\treturn;",
            "",
            "\trec->nr = syscall_nr;",
            "\trec->ret = syscall_get_return_value(current, regs);",
            "",
            "\tif ((valid_prog_array &&",
            "\t     !perf_call_bpf_exit(sys_data->exit_event, fake_regs, rec)) ||",
            "\t    hlist_empty(head)) {",
            "\t\tperf_swevent_put_recursion_context(rctx);",
            "\t\treturn;",
            "\t}",
            "",
            "\tperf_trace_buf_submit(rec, size, rctx, sys_data->exit_event->event.type,",
            "\t\t\t      1, regs, head, NULL);",
            "}",
            "static int perf_sysexit_enable(struct trace_event_call *call)",
            "{",
            "\tint ret = 0;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tif (!sys_perf_refcount_exit)",
            "\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");",
            "\t} else {",
            "\t\tset_bit(num, enabled_perf_exit_syscalls);",
            "\t\tsys_perf_refcount_exit++;",
            "\t}",
            "\tmutex_unlock(&syscall_trace_lock);",
            "\treturn ret;",
            "}",
            "static void perf_sysexit_disable(struct trace_event_call *call)",
            "{",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tsys_perf_refcount_exit--;",
            "\tclear_bit(num, enabled_perf_exit_syscalls);",
            "\tif (!sys_perf_refcount_exit)",
            "\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);",
            "\tmutex_unlock(&syscall_trace_lock);",
            "}",
            "static int syscall_enter_register(struct trace_event_call *event,",
            "\t\t\t\t enum trace_reg type, void *data)",
            "{",
            "\tstruct trace_event_file *file = data;",
            "",
            "\tswitch (type) {",
            "\tcase TRACE_REG_REGISTER:",
            "\t\treturn reg_event_syscall_enter(file, event);",
            "\tcase TRACE_REG_UNREGISTER:",
            "\t\tunreg_event_syscall_enter(file, event);",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "\tcase TRACE_REG_PERF_REGISTER:",
            "\t\treturn perf_sysenter_enable(event);",
            "\tcase TRACE_REG_PERF_UNREGISTER:",
            "\t\tperf_sysenter_disable(event);",
            "\t\treturn 0;",
            "\tcase TRACE_REG_PERF_OPEN:",
            "\tcase TRACE_REG_PERF_CLOSE:",
            "\tcase TRACE_REG_PERF_ADD:",
            "\tcase TRACE_REG_PERF_DEL:",
            "\t\treturn 0;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__aligned, perf_sysexit_enable, perf_sysexit_disable, syscall_enter_register",
          "description": "定义了系统调用退出跟踪相关的结构体和辅助函数，通过perf事件框架实现系统调用返回值捕获与BPF程序调用，包含启用/禁用跟踪点注册及入口事件处理逻辑",
          "similarity": 0.6110904812812805
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 569,
          "end_line": 669,
          "content": [
            "\tstruct syscall_tp_t {",
            "\t\tstruct trace_entry ent;",
            "\t\tunsigned long syscall_nr;",
            "\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];",
            "\t} __aligned(8) param;",
            "\tint i;",
            "",
            "\tBUILD_BUG_ON(sizeof(param.ent) < sizeof(void *));",
            "",
            "\t/* bpf prog requires 'regs' to be the first member in the ctx (a.k.a. &param) */",
            "\tperf_fetch_caller_regs(regs);",
            "\t*(struct pt_regs **)&param = regs;",
            "\tparam.syscall_nr = rec->nr;",
            "\tfor (i = 0; i < sys_data->nb_args; i++)",
            "\t\tparam.args[i] = rec->args[i];",
            "\treturn trace_call_bpf(call, &param);",
            "}",
            "",
            "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)",
            "{",
            "\tstruct syscall_metadata *sys_data;",
            "\tstruct syscall_trace_enter *rec;",
            "\tstruct pt_regs *fake_regs;",
            "\tstruct hlist_head *head;",
            "\tunsigned long args[6];",
            "\tbool valid_prog_array;",
            "\tint syscall_nr;",
            "\tint rctx;",
            "\tint size;",
            "",
            "\tsyscall_nr = trace_get_syscall_nr(current, regs);",
            "\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)",
            "\t\treturn;",
            "\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))",
            "\t\treturn;",
            "",
            "\tsys_data = syscall_nr_to_meta(syscall_nr);",
            "\tif (!sys_data)",
            "\t\treturn;",
            "",
            "\thead = this_cpu_ptr(sys_data->enter_event->perf_events);",
            "\tvalid_prog_array = bpf_prog_array_valid(sys_data->enter_event);",
            "\tif (!valid_prog_array && hlist_empty(head))",
            "\t\treturn;",
            "",
            "\t/* get the size after alignment with the u32 buffer size field */",
            "\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);",
            "\tsize = ALIGN(size + sizeof(u32), sizeof(u64));",
            "\tsize -= sizeof(u32);",
            "",
            "\trec = perf_trace_buf_alloc(size, &fake_regs, &rctx);",
            "\tif (!rec)",
            "\t\treturn;",
            "",
            "\trec->nr = syscall_nr;",
            "\tsyscall_get_arguments(current, regs, args);",
            "\tmemcpy(&rec->args, args, sizeof(unsigned long) * sys_data->nb_args);",
            "",
            "\tif ((valid_prog_array &&",
            "\t     !perf_call_bpf_enter(sys_data->enter_event, fake_regs, sys_data, rec)) ||",
            "\t    hlist_empty(head)) {",
            "\t\tperf_swevent_put_recursion_context(rctx);",
            "\t\treturn;",
            "\t}",
            "",
            "\tperf_trace_buf_submit(rec, size, rctx,",
            "\t\t\t      sys_data->enter_event->event.type, 1, regs,",
            "\t\t\t      head, NULL);",
            "}",
            "static int perf_sysenter_enable(struct trace_event_call *call)",
            "{",
            "\tint ret = 0;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tif (!sys_perf_refcount_enter)",
            "\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");",
            "\t} else {",
            "\t\tset_bit(num, enabled_perf_enter_syscalls);",
            "\t\tsys_perf_refcount_enter++;",
            "\t}",
            "\tmutex_unlock(&syscall_trace_lock);",
            "\treturn ret;",
            "}",
            "static void perf_sysenter_disable(struct trace_event_call *call)",
            "{",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tsys_perf_refcount_enter--;",
            "\tclear_bit(num, enabled_perf_enter_syscalls);",
            "\tif (!sys_perf_refcount_enter)",
            "\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);",
            "\tmutex_unlock(&syscall_trace_lock);",
            "}"
          ],
          "function_name": "__aligned, perf_sysenter_enable, perf_sysenter_disable",
          "description": "实现基于性能事件的系统调用入口跟踪逻辑，包含BPF程序调用支持，提供启用/禁用系统调用入口跟踪的控制接口。",
          "similarity": 0.6031151413917542
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 380,
          "end_line": 515,
          "content": [
            "static int reg_event_syscall_enter(struct trace_event_file *file,",
            "\t\t\t\t   struct trace_event_call *call)",
            "{",
            "\tstruct trace_array *tr = file->tr;",
            "\tint ret = 0;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))",
            "\t\treturn -ENOSYS;",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tif (!tr->sys_refcount_enter)",
            "\t\tret = register_trace_sys_enter(ftrace_syscall_enter, tr);",
            "\tif (!ret) {",
            "\t\trcu_assign_pointer(tr->enter_syscall_files[num], file);",
            "\t\ttr->sys_refcount_enter++;",
            "\t}",
            "\tmutex_unlock(&syscall_trace_lock);",
            "\treturn ret;",
            "}",
            "static void unreg_event_syscall_enter(struct trace_event_file *file,",
            "\t\t\t\t      struct trace_event_call *call)",
            "{",
            "\tstruct trace_array *tr = file->tr;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))",
            "\t\treturn;",
            "\tmutex_lock(&syscall_trace_lock);",
            "\ttr->sys_refcount_enter--;",
            "\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);",
            "\tif (!tr->sys_refcount_enter)",
            "\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);",
            "\tmutex_unlock(&syscall_trace_lock);",
            "}",
            "static int reg_event_syscall_exit(struct trace_event_file *file,",
            "\t\t\t\t  struct trace_event_call *call)",
            "{",
            "\tstruct trace_array *tr = file->tr;",
            "\tint ret = 0;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))",
            "\t\treturn -ENOSYS;",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tif (!tr->sys_refcount_exit)",
            "\t\tret = register_trace_sys_exit(ftrace_syscall_exit, tr);",
            "\tif (!ret) {",
            "\t\trcu_assign_pointer(tr->exit_syscall_files[num], file);",
            "\t\ttr->sys_refcount_exit++;",
            "\t}",
            "\tmutex_unlock(&syscall_trace_lock);",
            "\treturn ret;",
            "}",
            "static void unreg_event_syscall_exit(struct trace_event_file *file,",
            "\t\t\t\t     struct trace_event_call *call)",
            "{",
            "\tstruct trace_array *tr = file->tr;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))",
            "\t\treturn;",
            "\tmutex_lock(&syscall_trace_lock);",
            "\ttr->sys_refcount_exit--;",
            "\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);",
            "\tif (!tr->sys_refcount_exit)",
            "\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);",
            "\tmutex_unlock(&syscall_trace_lock);",
            "}",
            "static int __init init_syscall_trace(struct trace_event_call *call)",
            "{",
            "\tint id;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (num < 0 || num >= NR_syscalls) {",
            "\t\tpr_debug(\"syscall %s metadata not mapped, disabling ftrace event\\n\",",
            "\t\t\t\t((struct syscall_metadata *)call->data)->name);",
            "\t\treturn -ENOSYS;",
            "\t}",
            "",
            "\tif (set_syscall_print_fmt(call) < 0)",
            "\t\treturn -ENOMEM;",
            "",
            "\tid = trace_event_raw_init(call);",
            "",
            "\tif (id < 0) {",
            "\t\tfree_syscall_print_fmt(call);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn id;",
            "}",
            "unsigned long __init __weak arch_syscall_addr(int nr)",
            "{",
            "\treturn (unsigned long)sys_call_table[nr];",
            "}",
            "void __init init_ftrace_syscalls(void)",
            "{",
            "\tstruct syscall_metadata *meta;",
            "\tunsigned long addr;",
            "\tint i;",
            "\tvoid *ret;",
            "",
            "\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {",
            "\t\tsyscalls_metadata = kcalloc(NR_syscalls,",
            "\t\t\t\t\tsizeof(*syscalls_metadata),",
            "\t\t\t\t\tGFP_KERNEL);",
            "\t\tif (!syscalls_metadata) {",
            "\t\t\tWARN_ON(1);",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\tfor (i = 0; i < NR_syscalls; i++) {",
            "\t\taddr = arch_syscall_addr(i);",
            "\t\tmeta = find_syscall_meta(addr);",
            "\t\tif (!meta)",
            "\t\t\tcontinue;",
            "",
            "\t\tmeta->syscall_nr = i;",
            "",
            "\t\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {",
            "\t\t\tsyscalls_metadata[i] = meta;",
            "\t\t} else {",
            "\t\t\tret = xa_store(&syscalls_metadata_sparse, i, meta,",
            "\t\t\t\t\tGFP_KERNEL);",
            "\t\t\tWARN(xa_is_err(ret),",
            "\t\t\t\t\"Syscall memory allocation failed\\n\");",
            "\t\t}",
            "",
            "\t}",
            "}"
          ],
          "function_name": "reg_event_syscall_enter, unreg_event_syscall_enter, reg_event_syscall_exit, unreg_event_syscall_exit, init_syscall_trace, arch_syscall_addr, init_ftrace_syscalls",
          "description": "管理系统调用跟踪事件的注册与取消注册操作，初始化系统调用跟踪元数据映射关系，建立系统调用号与跟踪文件的关联。",
          "similarity": 0.5997096300125122
        }
      ]
    }
  ]
}