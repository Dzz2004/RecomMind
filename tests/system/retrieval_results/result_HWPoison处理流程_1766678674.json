{
  "query": "HWPoison处理流程",
  "timestamp": "2025-12-26 00:04:34",
  "retrieved_files": [
    {
      "source_file": "mm/hwpoison-inject.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:08:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `hwpoison-inject.c`\n\n---\n\n# hwpoison-inject.c 技术文档\n\n## 1. 文件概述\n\n`hwpoison-inject.c` 是 Linux 内核中用于**软件模拟硬件内存故障（Hardware Poison）注入与清除**的调试模块。该模块通过 debugfs 接口，允许具有 `CAP_SYS_ADMIN` 权限的用户空间程序向指定物理页帧号（PFN）注入或清除“坏页”标记（`PG_hwpoison`），主要用于测试内核内存错误处理机制（如 `memory_failure()` 路径）在无真实硬件故障情况下的行为。\n\n## 2. 核心功能\n\n### 主要函数\n- **`hwpoison_inject(void *data, u64 val)`**  \n  向指定 PFN 注入硬件内存故障。执行权限检查、页有效性验证、过滤器判断后调用 `memory_failure()`。\n  \n- **`hwpoison_unpoison(void *data, u64 val)`**  \n  清除指定 PFN 的硬件内存故障标记，调用 `unpoison_memory()`。\n\n- **`pfn_inject_init(void)`**  \n  模块初始化函数，创建 debugfs 目录及控制文件。\n\n- **`pfn_inject_exit(void)`**  \n  模块退出函数，清理 debugfs 条目并禁用过滤器。\n\n### 主要数据结构/全局变量\n- **`hwpoison_dir`**：debugfs 目录入口（`/sys/kernel/debug/hwpoison/`）。\n- **`hwpoison_fops` / `unpoison_fops`**：debugfs 文件操作接口，分别用于写入 corrupt/unpoison 请求。\n- **`hwpoison_filter_enable` 等全局变量**：控制 hwpoison 过滤器的行为参数（通过 debugfs 可配置）。\n\n## 3. 关键实现\n\n### 故障注入流程 (`hwpoison_inject`)\n1. **权限与有效性校验**：仅允许 `CAP_SYS_ADMIN` 用户操作，并确保输入 PFN 有效（`pfn_valid()`）。\n2. **页类型过滤**：\n   - 若 `hwpoison_filter_enable=0`，跳过过滤直接注入。\n   - 否则，仅对 **LRU 页**、**HugeTLB 页** 或 **空闲 Buddy 页** 允许注入，其他非 LRU 页（如 slab、匿名映射未加入 LRU 的页）被忽略。\n3. **过滤器检查**：调用 `hwpoison_filter()` 执行基于设备号、页标志、memcg 等条件的精细过滤（racy check，最终由 `memory_failure()` 在持锁下确认）。\n4. **触发内存故障处理**：调用 `memory_failure(pfn, MF_SW_SIMULATED)`，其中 `MF_SW_SIMULATED` 表示软件模拟故障。\n\n### 故障清除流程 (`hwpoison_unpoison`)\n- 直接调用通用接口 `unpoison_memory()` 清除 `PG_hwpoison` 标记，适用于已标记为坏页的页面。\n\n### DebugFS 接口设计\n- **`corrupt-pfn`**：写入 PFN 触发注入（权限 `0200`，仅写）。\n- **`unpoison-pfn`**：写入 PFN 触发清除（权限 `0200`，仅写）。\n- **过滤器控制参数**：提供 `corrupt-filter-*` 系列文件动态配置过滤条件（如设备号、页标志掩码、memcg ID）。\n\n## 4. 依赖关系\n\n- **核心内存管理子系统**：\n  - `<linux/mm.h>`、`<linux/pagemap.h>`：页结构、PFN 转换、LRU 状态检查。\n  - `<linux/hugetlb.h>`：HugeTLB 页支持。\n  - `\"internal.h\"`：内核 MM 内部接口（如 `shake_folio()`、`hwpoison_filter()`）。\n- **内存故障处理框架**：\n  - `memory_failure()` 和 `unpoison_memory()`：定义于 `mm/memory-failure.c`，负责实际坏页处理逻辑。\n- **DebugFS 基础设施**：依赖 `<linux/debugfs.h>` 提供用户态交互接口。\n- **可选依赖**：\n  - `CONFIG_MEMCG`：若启用内存控制组，则支持基于 memcg 的过滤。\n\n## 5. 使用场景\n\n- **内核开发与测试**：\n  - 验证 `memory_failure()` 路径对不同类型页面（匿名页、文件页、HugeTLB 页等）的处理正确性。\n  - 测试 hwpoison 过滤器逻辑（如基于设备、memcg 的隔离策略）。\n- **系统可靠性验证**：\n  - 模拟硬件内存故障，评估应用程序和内核在坏页注入下的恢复能力（如进程终止、页面迁移）。\n- **故障注入工具集成**：\n  - 作为底层接口被用户态工具（如 `mce-inject` 或自定义脚本）调用，实现可控的内存错误注入实验。",
      "similarity": 0.508253812789917,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/hwpoison-inject.c",
          "start_line": 14,
          "end_line": 103,
          "content": [
            "static int hwpoison_inject(void *data, u64 val)",
            "{",
            "\tunsigned long pfn = val;",
            "\tstruct page *p;",
            "\tstruct folio *folio;",
            "\tint err;",
            "",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tif (!pfn_valid(pfn))",
            "\t\treturn -ENXIO;",
            "",
            "\tp = pfn_to_page(pfn);",
            "\tfolio = page_folio(p);",
            "",
            "\tif (!hwpoison_filter_enable)",
            "\t\tgoto inject;",
            "",
            "\tshake_folio(folio);",
            "\t/*",
            "\t * This implies unable to support non-LRU pages except free page.",
            "\t */",
            "\tif (!folio_test_lru(folio) && !folio_test_hugetlb(folio) &&",
            "\t    !is_free_buddy_page(p))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * do a racy check to make sure PG_hwpoison will only be set for",
            "\t * the targeted owner (or on a free page).",
            "\t * memory_failure() will redo the check reliably inside page lock.",
            "\t */",
            "\terr = hwpoison_filter(&folio->page);",
            "\tif (err)",
            "\t\treturn 0;",
            "",
            "inject:",
            "\tpr_info(\"Injecting memory failure at pfn %#lx\\n\", pfn);",
            "\terr = memory_failure(pfn, MF_SW_SIMULATED);",
            "\treturn (err == -EOPNOTSUPP) ? 0 : err;",
            "}",
            "static int hwpoison_unpoison(void *data, u64 val)",
            "{",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\treturn unpoison_memory(val);",
            "}",
            "static void __exit pfn_inject_exit(void)",
            "{",
            "\thwpoison_filter_enable = 0;",
            "\tdebugfs_remove_recursive(hwpoison_dir);",
            "}",
            "static int __init pfn_inject_init(void)",
            "{",
            "\thwpoison_dir = debugfs_create_dir(\"hwpoison\", NULL);",
            "",
            "\t/*",
            "\t * Note that the below poison/unpoison interfaces do not involve",
            "\t * hardware status change, hence do not require hardware support.",
            "\t * They are mainly for testing hwpoison in software level.",
            "\t */",
            "\tdebugfs_create_file(\"corrupt-pfn\", 0200, hwpoison_dir, NULL,",
            "\t\t\t    &hwpoison_fops);",
            "",
            "\tdebugfs_create_file(\"unpoison-pfn\", 0200, hwpoison_dir, NULL,",
            "\t\t\t    &unpoison_fops);",
            "",
            "\tdebugfs_create_u32(\"corrupt-filter-enable\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_enable);",
            "",
            "\tdebugfs_create_u32(\"corrupt-filter-dev-major\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_dev_major);",
            "",
            "\tdebugfs_create_u32(\"corrupt-filter-dev-minor\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_dev_minor);",
            "",
            "\tdebugfs_create_u64(\"corrupt-filter-flags-mask\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_flags_mask);",
            "",
            "\tdebugfs_create_u64(\"corrupt-filter-flags-value\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_flags_value);",
            "",
            "#ifdef CONFIG_MEMCG",
            "\tdebugfs_create_u64(\"corrupt-filter-memcg\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_memcg);",
            "#endif",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "hwpoison_inject, hwpoison_unpoison, pfn_inject_exit, pfn_inject_init",
          "description": "提供硬件中毒注入与解除接口，包含权限校验、PFN有效性检查、页面状态修改及debugfs控制接口注册功能",
          "similarity": 0.3984791040420532
        },
        {
          "chunk_id": 0,
          "file_path": "mm/hwpoison-inject.c",
          "start_line": 1,
          "end_line": 13,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Inject a hwpoison memory failure on a arbitrary pfn */",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include \"internal.h\"",
            "",
            "static struct dentry *hwpoison_dir;",
            ""
          ],
          "function_name": null,
          "description": "定义并初始化用于硬件中毒注入的调试文件系统目录结构",
          "similarity": 0.3932609260082245
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bloom_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:56:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bloom_filter.c`\n\n---\n\n# `bpf/bloom_filter.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了 Linux 内核中 eBPF（extended Berkeley Packet Filter）子系统所支持的 **布隆过滤器（Bloom Filter）映射类型**。布隆过滤器是一种空间高效的概率型数据结构，用于快速判断某个元素是否**可能存在于集合中**（允许假阳性，但不允许假阴性）。该映射类型专为只写入、只查询、不可删除的场景设计，适用于高性能、低内存开销的成员存在性检测。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_bloom_filter`**  \n  布隆过滤器的具体实现结构体，包含：\n  - `struct bpf_map map`：继承自通用 eBPF 映射结构。\n  - `u32 bitset_mask`：位图掩码，用于快速取模（因位图大小为 2 的幂）。\n  - `u32 hash_seed`：哈希种子，用于初始化哈希函数（可选随机化）。\n  - `u32 nr_hash_funcs`：使用的哈希函数数量（1–15，由 `map_extra` 指定）。\n  - `unsigned long bitset[]`：柔性数组，存储位图数据。\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `hash()` | 根据输入值、哈希种子和索引计算哈希值，并通过 `bitset_mask` 取模得到位图索引。支持 4 字节对齐和非对齐数据。 |\n| `bloom_map_peek_elem()` | 查询元素是否存在：对每个哈希函数计算位图位置，若任一位为 0 则返回 `-ENOENT`（不存在）；否则返回 0（可能存在）。 |\n| `bloom_map_push_elem()` | 插入元素：对每个哈希函数计算位图位置并置位。仅支持 `BPF_ANY` 标志。 |\n| `bloom_map_alloc()` | 分配并初始化布隆过滤器映射。根据 `max_entries` 和 `map_extra`（哈希函数数）计算最优位图大小，并向上取整为 2 的幂。 |\n| `bloom_map_free()` | 释放布隆过滤器占用的内存。 |\n| `bloom_map_alloc_check()` | 在创建映射前校验参数合法性（如 `value_size` 不超过 `KMALLOC_MAX_SIZE`）。 |\n| `bloom_map_check_btf()` | BTF（BPF Type Format）校验：要求 key 类型为 `void`（无 key）。 |\n| `bloom_map_mem_usage()` | 返回该映射实际占用的内存大小（含位图）。 |\n\n### 不支持的操作（返回 `-EOPNOTSUPP` 或 `-EINVAL`）\n\n- `bloom_map_pop_elem()`：不支持弹出元素。\n- `bloom_map_delete_elem()`：不支持删除元素。\n- `bloom_map_get_next_key()`：不支持遍历。\n- `bloom_map_lookup_elem()` / `bloom_map_update_elem()`：eBPF 程序应使用 `map_peek_elem` 和 `map_push_elem` 替代。\n\n### 映射操作表\n\n- `bloom_filter_map_ops`：定义了该映射类型支持的所有操作回调函数，注册到 eBPF 子系统。\n\n## 3. 关键实现\n\n### 布隆过滤器参数计算\n\n- **哈希函数数量**：由用户通过 `attr->map_extra & 0xF` 指定（1–15），若为 0 则默认使用 5 个。\n- **位图大小计算**：\n  - 理论最优位数：`n * k / ln(2)`，其中 `n = max_entries`，`k = nr_hash_funcs`。\n  - 代码使用 `7/5 ≈ 1/ln(2)` 近似计算：`nr_bits = (max_entries * k * 7) / 5`。\n  - 为提升哈希效率，将 `nr_bits` **向上取整为 2 的幂**，从而可用 `& (size - 1)` 替代取模运算。\n  - 若计算溢出（> 2^31），则使用最大位图（`U32_MAX` 位，约 512 MB）。\n\n### 哈希函数\n\n- 使用内核提供的 `jhash()` 和 `jhash2()`（Jenkins 哈希）。\n- 每个哈希函数通过 `hash_seed + index` 区分，确保独立性。\n- 支持任意长度的 `value`（由 `value_size` 指定），自动选择对齐/非对齐版本。\n\n### 内存分配\n\n- 使用 `bpf_map_area_alloc()` 分配连续内存，包含结构体头和位图。\n- 位图大小按 `unsigned long` 对齐，确保位操作效率。\n\n### 安全与校验\n\n- 严格校验创建参数：`key_size` 必须为 0，`value_size` 和 `max_entries` 必须 > 0。\n- 仅允许特定 `map_flags`（`BPF_F_NUMA_NODE`、`BPF_F_ZERO_SEED`、`BPF_F_ACCESS_MASK`）。\n- BTF 校验强制 key 类型为 `void`，符合“无 key”设计。\n\n## 4. 依赖关系\n\n- **内核头文件**：\n  - `<linux/bitmap.h>`：提供 `test_bit()`、`set_bit()` 等位操作。\n  - `<linux/bpf.h>`：eBPF 核心定义（`bpf_map`、操作码等）。\n  - `<linux/btf.h>`：BTF 类型系统支持。\n  - `<linux/jhash.h>`：Jenkins 哈希函数实现。\n  - `<linux/random.h>`：`get_random_u32()` 用于生成哈希种子。\n- **eBPF 子系统**：通过 `bpf_map_ops` 机制集成到 eBPF 映射框架中。\n- **内存管理**：依赖 `bpf_map_area_alloc/free` 进行 NUMA 感知内存分配。\n\n## 5. 使用场景\n\n- **网络数据包过滤**：快速判断 IP 地址、端口等是否在可疑集合中。\n- **安全监控**：检测进程、文件路径是否属于已知恶意样本（允许少量误报）。\n- **性能分析**：记录已观测到的事件 ID，避免重复处理。\n- **资源去重**：在无法存储完整集合的场景下，高效判断元素是否已存在。\n\n> **注意**：由于布隆过滤器**不支持删除操作**，且存在**假阳性**，适用于“写一次、查多次”且可容忍少量误报的场景。eBPF 程序需通过 `bpf_map_peek_elem()` 查询，通过 `bpf_map_push_elem()` 插入。",
      "similarity": 0.4556615352630615,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 23,
          "end_line": 117,
          "content": [
            "static u32 hash(struct bpf_bloom_filter *bloom, void *value,",
            "\t\tu32 value_size, u32 index)",
            "{",
            "\tu32 h;",
            "",
            "\tif (likely(value_size % 4 == 0))",
            "\t\th = jhash2(value, value_size / 4, bloom->hash_seed + index);",
            "\telse",
            "\t\th = jhash(value, value_size, bloom->hash_seed + index);",
            "",
            "\treturn h & bloom->bitset_mask;",
            "}",
            "static long bloom_map_peek_elem(struct bpf_map *map, void *value)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tif (!test_bit(h, bloom->bitset))",
            "\t\t\treturn -ENOENT;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_push_elem(struct bpf_map *map, void *value, u64 flags)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tif (flags != BPF_ANY)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tset_bit(h, bloom->bitset);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_pop_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static long bloom_map_delete_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_get_next_key(struct bpf_map *map, void *key, void *next_key)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_alloc_check(union bpf_attr *attr)",
            "{",
            "\tif (attr->value_size > KMALLOC_MAX_SIZE)",
            "\t\t/* if value_size is bigger, the user space won't be able to",
            "\t\t * access the elements.",
            "\t\t */",
            "\t\treturn -E2BIG;",
            "",
            "\treturn 0;",
            "}",
            "static void bloom_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "",
            "\tbpf_map_area_free(bloom);",
            "}",
            "static long bloom_map_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t  void *value, u64 flags)",
            "{",
            "\t/* The eBPF program should use map_push_elem instead */",
            "\treturn -EINVAL;",
            "}",
            "static int bloom_map_check_btf(const struct bpf_map *map,",
            "\t\t\t       const struct btf *btf,",
            "\t\t\t       const struct btf_type *key_type,",
            "\t\t\t       const struct btf_type *value_type)",
            "{",
            "\t/* Bloom filter maps are keyless */",
            "\treturn btf_type_is_void(key_type) ? 0 : -EINVAL;",
            "}",
            "static u64 bloom_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom;",
            "\tu64 bitset_bytes;",
            "",
            "\tbloom = container_of(map, struct bpf_bloom_filter, map);",
            "\tbitset_bytes = BITS_TO_BYTES((u64)bloom->bitset_mask + 1);",
            "\tbitset_bytes = roundup(bitset_bytes, sizeof(unsigned long));",
            "\treturn sizeof(*bloom) + bitset_bytes;",
            "}"
          ],
          "function_name": "hash, bloom_map_peek_elem, bloom_map_push_elem, bloom_map_pop_elem, bloom_map_delete_elem, bloom_map_get_next_key, bloom_map_alloc_check, bloom_map_free, bloom_map_update_elem, bloom_map_check_btf, bloom_map_mem_usage",
          "description": "实现Bloom过滤器核心操作，包括哈希计算、元素存在性检测、插入操作、内存校验、资源释放及内存占用统计，部分接口暂不支持并返回相应错误码",
          "similarity": 0.47034937143325806
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2021 Facebook */",
            "",
            "#include <linux/bitmap.h>",
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/err.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#define BLOOM_CREATE_FLAG_MASK \\",
            "\t(BPF_F_NUMA_NODE | BPF_F_ZERO_SEED | BPF_F_ACCESS_MASK)",
            "",
            "struct bpf_bloom_filter {",
            "\tstruct bpf_map map;",
            "\tu32 bitset_mask;",
            "\tu32 hash_seed;",
            "\tu32 nr_hash_funcs;",
            "\tunsigned long bitset[];",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义Bloom过滤器内核结构体，包含位图掩码、哈希种子、哈希函数数及动态扩展的位集合数组，用于eBPF程序中的布隆过滤器实现",
          "similarity": 0.3940581977367401
        }
      ]
    },
    {
      "source_file": "kernel/locking/qspinlock_paravirt.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:46:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\qspinlock_paravirt.h`\n\n---\n\n# `locking/qspinlock_paravirt.h` 技术文档\n\n## 1. 文件概述\n\n`qspinlock_paravirt.h` 是 Linux 内核中用于实现 **半虚拟化（paravirtualized, PV）队列自旋锁（qspinlock）** 的头文件。其核心目标是在虚拟化环境中优化自旋锁行为：当虚拟 CPU（vCPU）无法立即获取锁时，不进行忙等待（busy-waiting），而是通过 **挂起（halt）** 当前 vCPU 并等待被唤醒，从而显著降低在锁竞争激烈或宿主机过载（overcommitted）场景下的 CPU 资源浪费和延迟。\n\n该文件依赖架构层提供的两个关键半虚拟化超调用（hypercall）：\n- `pv_wait(u8 *ptr, u8 val)`：当 `*ptr == val` 时挂起当前 vCPU。\n- `pv_kick(cpu)`：唤醒指定的已挂起 vCPU。\n\n此文件 **不能直接包含**，必须通过定义 `_GEN_PV_LOCK_SLOWPATH` 宏后由其他文件（如 `qspinlock.c`）条件包含，以替换原生的慢路径锁实现。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`enum vcpu_state`**  \n  表示 vCPU 在锁等待队列中的状态：\n  - `vcpu_running`：正在运行（默认状态）。\n  - `vcpu_halted`：已挂起，等待被唤醒（仅用于 `pv_wait_node`）。\n  - `vcpu_hashed`：已挂起且其节点信息已加入哈希表（用于快速查找）。\n\n- **`struct pv_node`**  \n  扩展的 MCS 锁节点，包含：\n  - `mcs`：标准 MCS 自旋锁节点。\n  - `cpu`：关联的 CPU ID。\n  - `state`：当前 vCPU 状态（`vcpu_state` 枚举值）。\n\n- **`struct pv_hash_entry`**  \n  哈希表条目，用于快速映射锁地址到对应的 `pv_node`：\n  - `lock`：指向 `qspinlock` 的指针。\n  - `node`：指向 `pv_node` 的指针。\n\n### 主要函数与宏\n\n- **`pv_hybrid_queued_unfair_trylock()`**  \n  实现混合模式的锁尝试获取逻辑，结合了公平队列锁与非公平锁的优点。\n\n- **`set_pending()` / `trylock_clear_pending()`**  \n  操作锁的 `pending` 位，用于协调队列头 vCPU 与新到来的竞争者。\n\n- **`__pv_init_lock_hash()`**  \n  初始化 PV 锁哈希表，分配足够大的内存空间以支持所有可能的 CPU。\n\n- **`pv_hash()` / `pv_unhash()`**  \n  在哈希表中插入/删除锁与节点的映射关系，用于快速唤醒等待者。\n\n- **`pv_wait_early()`**  \n  （代码不完整）用于判断是否应提前检查前驱节点状态并挂起当前 vCPU。\n\n### 关键宏定义\n\n- **`PV_PREV_CHECK_MASK`**  \n  控制检查前驱节点状态的频率（每 256 次循环检查一次），避免缓存行抖动。\n\n- **`_Q_SLOW_VAL`**  \n  表示锁处于慢路径状态的值（`locked=1, pending=1`）。\n\n- **`queued_spin_trylock`**  \n  重定义为 `pv_hybrid_queued_unfair_trylock`，启用混合锁机制。\n\n## 3. 关键实现\n\n### 混合 PV 队列/非公平锁机制\n\n该实现采用 **混合策略**：\n- 当锁的 MCS 等待队列为空或 `pending` 位未设置时，新竞争者尝试 **非公平方式抢锁**（直接 CAS `locked` 位），提升低竞争场景性能。\n- 一旦有 vCPU 进入等待队列并成为队列头，它会设置 `pending` 位，**禁止后续抢锁**，强制新竞争者进入公平队列，避免锁饥饿。\n- 队列头 vCPU 在自旋等待锁释放时保持 `pending=1`，确保公平性。\n\n### 自适应挂起（Adaptive Spinning）\n\n- 等待队列中的 vCPU 会周期性（由 `PV_PREV_CHECK_MASK` 控制）检查 **前驱节点是否正在运行**。\n- 若前驱 **未运行**（如已挂起），当前 vCPU 也立即挂起，避免无意义的忙等。\n- 此机制在虚拟化过载环境中显著减少 CPU 浪费，同时在非过载场景下通过一次抢锁尝试维持性能。\n\n### 锁-节点哈希表\n\n- 为支持 `pv_kick()` 快速定位等待某锁的 vCPU，内核维护一个全局哈希表 `pv_lock_hash`。\n- 哈希表大小为 `4 * num_possible_cpus()`，确保即使在最大嵌套深度（4 层）下也有足够条目。\n- 使用 **开放寻址法**，每缓存行存放多个条目（`PV_HE_PER_LINE`），减少缓存未命中。\n- 锁持有者在释放锁前必须调用 `pv_unhash()` 移除映射，保证哈希表一致性。\n\n### Pending 位操作优化\n\n- 根据 `_Q_PENDING_BITS` 是否为 8（即 `pending` 字段是否独立字节），提供两种实现：\n  - **独立字节**：直接写 `pending` 字段，使用 `cmpxchg_acquire` 尝试获取锁。\n  - **共享字段**：使用原子位操作（`atomic_or` / `atomic_cmpxchg_acquire`）修改 `val`。\n\n## 4. 依赖关系\n\n- **架构依赖**：必须由底层架构（如 x86 KVM/Xen）提供 `pv_wait()` 和 `pv_kick()` 超调用。\n- **头文件依赖**：\n  - `<linux/hash.h>`：提供 `hash_ptr()` 哈希函数。\n  - `<linux/memblock.h>`：用于早期内存分配（`alloc_large_system_hash`）。\n  - `<linux/debug_locks.h>`：锁调试支持。\n- **锁核心依赖**：基于 `qspinlock` 和 `mcs_spinlock` 实现，需与 `locking/qspinlock.c` 协同工作。\n- **编译依赖**：必须由定义了 `_GEN_PV_LOCK_SLOWPATH` 的源文件包含，不能独立编译。\n\n## 5. 使用场景\n\n- **虚拟化环境**：主要在 KVM、Xen 等半虚拟化 Hypervisor 上启用，优化多 vCPU 虚拟机中的锁竞争。\n- **高竞争锁场景**：当多个 vCPU 频繁争用同一自旋锁时，避免忙等待导致的宿主机 CPU 资源耗尽。\n- **过载宿主机**：在物理 CPU 资源不足时，挂起等待锁的 vCPU 可减少调度开销和上下文切换延迟。\n- **混合工作负载**：通过混合锁机制，在低竞争时保持高性能，高竞争时保证公平性，适用于通用服务器场景。",
      "similarity": 0.4545236825942993,
      "chunks": []
    }
  ]
}