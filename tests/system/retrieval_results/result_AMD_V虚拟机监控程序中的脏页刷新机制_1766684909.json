{
  "query": "AMD-V虚拟机监控程序中的脏页刷新机制",
  "timestamp": "2025-12-26 01:48:29",
  "retrieved_files": [
    {
      "source_file": "mm/mapping_dirty_helpers.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:37:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mapping_dirty_helpers.c`\n\n---\n\n# mapping_dirty_helpers.c 技术文档\n\n## 1. 文件概述\n\n`mapping_dirty_helpers.c` 是 Linux 内核中用于管理共享映射（shared mapping）页面脏状态和写保护的核心辅助模块。该文件提供了一组基于页表遍历（pagewalk）机制的函数，用于在指定地址空间范围内对 PTE（页表项）执行写保护（write-protect）或清理脏位（clean dirty bit）操作，并高效地记录受影响的虚拟地址范围以进行 TLB 刷新和 MMU 通知。此功能主要用于内存管理子系统中的脏页跟踪、回写控制和 COW（Copy-On-Write）优化等场景。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct wp_walk`**  \n  页表遍历回调的私有上下文结构，用于记录：\n  - `range`：MMU 通知器作用范围\n  - `tlbflush_start` / `tlbflush_end`：需要刷新 TLB 的最小/最大虚拟地址\n  - `total`：被修改的 PTE 总数\n\n- **`struct clean_walk`**  \n  继承自 `wp_walk`，专用于 `clean_record_pte` 场景，额外包含：\n  - `bitmap_pgoff`：位图对应的起始页偏移\n  - `bitmap`：记录脏页偏移的位图\n  - `start` / `end`：位图中被设置位的最小/最大偏移（相对 `bitmap_pgoff`）\n\n### 主要函数\n\n- **`wp_pte()`**  \n  对可写的 PTE 执行写保护操作，更新 TLB 刷新范围并计数。\n\n- **`clean_record_pte()`**  \n  清除 PTE 的脏位，同时将对应页偏移记录到位图中，并更新 TLB 刷新范围。\n\n- **`wp_clean_pmd_entry()` / `wp_clean_pud_entry()`**  \n  处理 PMD/PUD 级别的巨页（huge page）条目，**不拆分巨页**，仅对可写或脏的巨页发出警告。\n\n- **`wp_clean_pre_vma()` / `wp_clean_post_vma()`**  \n  VMA 遍历前/后回调：初始化 MMU 通知、缓存刷新、TLB 刷新准备与执行。\n\n- **`wp_clean_test_walk()`**  \n  过滤不适用的 VMA：仅处理具有 `VM_SHARED | VM_MAYWRITE` 且非 `VM_HUGETLB` 的共享可写映射。\n\n- **`wp_shared_mapping_range()`**（未完整展示）  \n  公共接口函数，对指定地址空间范围内的所有 PTE 执行写保护。\n\n### 操作集定义\n\n- **`clean_walk_ops`**：用于清理脏位并记录位图的页表遍历操作集。\n- **`wp_walk_ops`**：仅执行写保护的页表遍历操作集。\n\n## 3. 关键实现\n\n### 页表遍历与原子修改\n- 使用 `ptep_get()` 安全读取 PTE。\n- 通过 `ptep_modify_prot_start()` / `ptep_modify_prot_commit()` 原子地修改 PTE 的保护属性，确保 SMP 和并发访问安全。\n- 对于写保护：调用 `pte_wrprotect()`；对于清理脏位：调用 `pte_mkclean()`。\n\n### TLB 刷新优化\n- 不使用 `tlb_gather_mmu()`（因其记录整个 VMA 范围），而是动态维护实际修改的最小/最大地址 (`tlbflush_start`/`end`)。\n- 在 `post_vma` 阶段根据是否发生嵌套 TLB 刷新 (`mm_tlb_flush_nested()`) 决定刷新整个 VMA 范围还是精确子范围。\n\n### 巨页处理策略\n- **明确禁止拆分透明巨页（THP）**：在 PMD/PUD 回调中检测到可写或脏的巨页时仅发出 `WARN_ON`，依赖缺页异常处理器后续处理。\n- 此设计避免在遍历过程中因拆分巨页导致脏信息丢失。\n\n### 位图记录机制\n- `clean_record_pte` 将虚拟地址转换为地址空间页偏移（`pgoff`），再相对于位图起始偏移计算位索引。\n- 使用 `__set_bit()` 设置位图，并维护被设置位的连续范围 (`start`/`end`)，便于后续高效处理。\n\n### VMA 过滤逻辑\n- 仅处理满足 `(VM_SHARED | VM_MAYWRITE)` 且 **不包含** `VM_HUGETLB` 的 VMA，确保操作对象是普通共享可写映射。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pagewalk.h>`：页表遍历框架\n  - `<linux/hugetlb.h>`：巨页相关宏（如 `pmd_trans_huge`）\n  - `<linux/bitops.h>`：位图操作（`__set_bit`）\n  - `<linux/mmu_notifier.h>`：MMU 通知机制\n  - `<linux/mm_inline.h>`：内联内存管理函数\n  - `<asm/cacheflush.h>` / `<asm/tlbflush.h>`：体系结构相关的缓存和 TLB 刷新\n\n- **内核子系统**：\n  - 内存管理（MM）子系统：VMA、页表、PTE 操作\n  - 虚拟内存区域（VMA）管理\n  - MMU 通知框架\n  - 透明巨页（THP）支持\n\n## 5. 使用场景\n\n- **脏页跟踪（Dirty Tracking）**：在回写（writeback）或检查点（checkpointing）前，清除 PTE 脏位并记录哪些页被修改过。\n- **写时复制（COW）优化**：对共享映射执行写保护，使得后续写入触发缺页异常，从而实现 COW。\n- **内存快照/迁移**：在创建内存快照或迁移页面前，暂停写入并捕获脏页信息。\n- **文件系统一致性**：某些文件系统（如 NFS、CIFS）可能利用此机制跟踪共享映射的修改，确保数据一致性。\n- **用户态内存监控工具**：通过内核接口对特定映射范围进行写保护，监控应用程序的写行为。",
      "similarity": 0.6015917062759399,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/mapping_dirty_helpers.c",
          "start_line": 34,
          "end_line": 141,
          "content": [
            "static int wp_pte(pte_t *pte, unsigned long addr, unsigned long end,",
            "\t\t  struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "\tpte_t ptent = ptep_get(pte);",
            "",
            "\tif (pte_write(ptent)) {",
            "\t\tpte_t old_pte = ptep_modify_prot_start(walk->vma, addr, pte);",
            "",
            "\t\tptent = pte_wrprotect(old_pte);",
            "\t\tptep_modify_prot_commit(walk->vma, addr, pte, old_pte, ptent);",
            "\t\twpwalk->total++;",
            "\t\twpwalk->tlbflush_start = min(wpwalk->tlbflush_start, addr);",
            "\t\twpwalk->tlbflush_end = max(wpwalk->tlbflush_end,",
            "\t\t\t\t\t   addr + PAGE_SIZE);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int clean_record_pte(pte_t *pte, unsigned long addr,",
            "\t\t\t    unsigned long end, struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "\tstruct clean_walk *cwalk = to_clean_walk(wpwalk);",
            "\tpte_t ptent = ptep_get(pte);",
            "",
            "\tif (pte_dirty(ptent)) {",
            "\t\tpgoff_t pgoff = ((addr - walk->vma->vm_start) >> PAGE_SHIFT) +",
            "\t\t\twalk->vma->vm_pgoff - cwalk->bitmap_pgoff;",
            "\t\tpte_t old_pte = ptep_modify_prot_start(walk->vma, addr, pte);",
            "",
            "\t\tptent = pte_mkclean(old_pte);",
            "\t\tptep_modify_prot_commit(walk->vma, addr, pte, old_pte, ptent);",
            "",
            "\t\twpwalk->total++;",
            "\t\twpwalk->tlbflush_start = min(wpwalk->tlbflush_start, addr);",
            "\t\twpwalk->tlbflush_end = max(wpwalk->tlbflush_end,",
            "\t\t\t\t\t   addr + PAGE_SIZE);",
            "",
            "\t\t__set_bit(pgoff, cwalk->bitmap);",
            "\t\tcwalk->start = min(cwalk->start, pgoff);",
            "\t\tcwalk->end = max(cwalk->end, pgoff + 1);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int wp_clean_pmd_entry(pmd_t *pmd, unsigned long addr, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "\tpmd_t pmdval = pmdp_get_lockless(pmd);",
            "",
            "\t/* Do not split a huge pmd, present or migrated */",
            "\tif (pmd_trans_huge(pmdval) || pmd_devmap(pmdval)) {",
            "\t\tWARN_ON(pmd_write(pmdval) || pmd_dirty(pmdval));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int wp_clean_pud_entry(pud_t *pud, unsigned long addr, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD",
            "\tpud_t pudval = READ_ONCE(*pud);",
            "",
            "\t/* Do not split a huge pud */",
            "\tif (pud_trans_huge(pudval) || pud_devmap(pudval)) {",
            "\t\tWARN_ON(pud_write(pudval) || pud_dirty(pudval));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}",
            "static int wp_clean_pre_vma(unsigned long start, unsigned long end,",
            "\t\t\t    struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "",
            "\twpwalk->tlbflush_start = end;",
            "\twpwalk->tlbflush_end = start;",
            "",
            "\tmmu_notifier_range_init(&wpwalk->range, MMU_NOTIFY_PROTECTION_PAGE, 0,",
            "\t\t\t\twalk->mm, start, end);",
            "\tmmu_notifier_invalidate_range_start(&wpwalk->range);",
            "\tflush_cache_range(walk->vma, start, end);",
            "",
            "\t/*",
            "\t * We're not using tlb_gather_mmu() since typically",
            "\t * only a small subrange of PTEs are affected, whereas",
            "\t * tlb_gather_mmu() records the full range.",
            "\t */",
            "\tinc_tlb_flush_pending(walk->mm);",
            "",
            "\treturn 0;",
            "}",
            "static void wp_clean_post_vma(struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "",
            "\tif (mm_tlb_flush_nested(walk->mm))",
            "\t\tflush_tlb_range(walk->vma, wpwalk->range.start,",
            "\t\t\t\twpwalk->range.end);",
            "\telse if (wpwalk->tlbflush_end > wpwalk->tlbflush_start)",
            "\t\tflush_tlb_range(walk->vma, wpwalk->tlbflush_start,",
            "\t\t\t\twpwalk->tlbflush_end);",
            "",
            "\tmmu_notifier_invalidate_range_end(&wpwalk->range);",
            "\tdec_tlb_flush_pending(walk->mm);",
            "}"
          ],
          "function_name": "wp_pte, clean_record_pte, wp_clean_pmd_entry, wp_clean_pud_entry, wp_clean_pre_vma, wp_clean_post_vma",
          "description": "实现页表项写保护与脏页清除逻辑，通过遍历页表修改PTE标志位，处理huge pmd/pud避免拆分，预/后处理VMA时设置TLB刷新范围并触发缓存/TLB无效操作。",
          "similarity": 0.600588858127594
        },
        {
          "chunk_id": 2,
          "file_path": "mm/mapping_dirty_helpers.c",
          "start_line": 218,
          "end_line": 267,
          "content": [
            "static int wp_clean_test_walk(unsigned long start, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "\tunsigned long vm_flags = READ_ONCE(walk->vma->vm_flags);",
            "",
            "\t/* Skip non-applicable VMAs */",
            "\tif ((vm_flags & (VM_SHARED | VM_MAYWRITE | VM_HUGETLB)) !=",
            "\t    (VM_SHARED | VM_MAYWRITE))",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "unsigned long wp_shared_mapping_range(struct address_space *mapping,",
            "\t\t\t\t      pgoff_t first_index, pgoff_t nr)",
            "{",
            "\tstruct wp_walk wpwalk = { .total = 0 };",
            "",
            "\ti_mmap_lock_read(mapping);",
            "\tWARN_ON(walk_page_mapping(mapping, first_index, nr, &wp_walk_ops,",
            "\t\t\t\t  &wpwalk));",
            "\ti_mmap_unlock_read(mapping);",
            "",
            "\treturn wpwalk.total;",
            "}",
            "unsigned long clean_record_shared_mapping_range(struct address_space *mapping,",
            "\t\t\t\t\t\tpgoff_t first_index, pgoff_t nr,",
            "\t\t\t\t\t\tpgoff_t bitmap_pgoff,",
            "\t\t\t\t\t\tunsigned long *bitmap,",
            "\t\t\t\t\t\tpgoff_t *start,",
            "\t\t\t\t\t\tpgoff_t *end)",
            "{",
            "\tbool none_set = (*start >= *end);",
            "\tstruct clean_walk cwalk = {",
            "\t\t.base = { .total = 0 },",
            "\t\t.bitmap_pgoff = bitmap_pgoff,",
            "\t\t.bitmap = bitmap,",
            "\t\t.start = none_set ? nr : *start,",
            "\t\t.end = none_set ? 0 : *end,",
            "\t};",
            "",
            "\ti_mmap_lock_read(mapping);",
            "\tWARN_ON(walk_page_mapping(mapping, first_index, nr, &clean_walk_ops,",
            "\t\t\t\t  &cwalk.base));",
            "\ti_mmap_unlock_read(mapping);",
            "",
            "\t*start = cwalk.start;",
            "\t*end = cwalk.end;",
            "",
            "\treturn cwalk.base.total;",
            "}"
          ],
          "function_name": "wp_clean_test_walk, wp_shared_mapping_range, clean_record_shared_mapping_range",
          "description": "提供共享映射范围检测函数，统计共享页面数量并记录脏页偏移至位图，通过i_mmap锁保护遍历页面映射关系，支持批量清理共享内存的脏页追踪。",
          "similarity": 0.5977715849876404
        },
        {
          "chunk_id": 0,
          "file_path": "mm/mapping_dirty_helpers.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/pagewalk.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/tlbflush.h>",
            "",
            "/**",
            " * struct wp_walk - Private struct for pagetable walk callbacks",
            " * @range: Range for mmu notifiers",
            " * @tlbflush_start: Address of first modified pte",
            " * @tlbflush_end: Address of last modified pte + 1",
            " * @total: Total number of modified ptes",
            " */",
            "struct wp_walk {",
            "\tstruct mmu_notifier_range range;",
            "\tunsigned long tlbflush_start;",
            "\tunsigned long tlbflush_end;",
            "\tunsigned long total;",
            "};",
            "",
            "/**",
            " * wp_pte - Write-protect a pte",
            " * @pte: Pointer to the pte",
            " * @addr: The start of protecting virtual address",
            " * @end: The end of protecting virtual address",
            " * @walk: pagetable walk callback argument",
            " *",
            " * The function write-protects a pte and records the range in",
            " * virtual address space of touched ptes for efficient range TLB flushes.",
            " */"
          ],
          "function_name": null,
          "description": "定义wp_walk结构体，用于在页表遍历回调中记录MMU通知范围、TLB刷新地址区间及修改的页表项数量，并声明wp_pte函数用于写保护页表项并记录修改范围。",
          "similarity": 0.4032837748527527
        }
      ]
    },
    {
      "source_file": "mm/page-writeback.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:59:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page-writeback.c`\n\n---\n\n# page-writeback.c 技术文档\n\n## 1. 文件概述\n\n`page-writeback.c` 是 Linux 内核内存管理子系统（MM）中的核心文件，负责实现**脏页回写（dirty page writeback）机制**。该机制用于控制和协调将修改过的页面（即“脏页”）从内存写回到持久化存储（如磁盘）的过程，以确保数据一致性、防止内存耗尽，并在系统负载与 I/O 带宽之间取得平衡。\n\n该文件主要提供以下功能：\n- 脏页数量的全局与每 BDI（Backing Device Info）级别的阈值管理\n- 脏页生成速率的动态限流（throttling）\n- 后台回写线程（如 `writeback` 线程）的触发逻辑\n- 支持基于 cgroup 的内存回写控制（当启用 `CONFIG_CGROUP_WRITEBACK` 时）\n- 与 `/proc/sys/vm` 中可调参数的交互接口\n\n## 2. 核心功能\n\n### 主要全局变量（可通过 sysctl 调整）\n| 变量名 | 默认值 | 说明 |\n|--------|--------|------|\n| `dirty_background_ratio` | 10 | 当脏页占可用内存比例达到此值时，启动后台回写 |\n| `vm_dirty_ratio` | 20 | 脏页比例硬上限，超过则阻塞写进程进行同步回写 |\n| `dirty_background_bytes` | 0 | 以字节为单位指定后台回写阈值（优先级高于 ratio） |\n| `vm_dirty_bytes` | 0 | 以字节为单位指定脏页硬上限（优先级高于 ratio） |\n| `dirty_writeback_interval` | 500 (5秒) | 后台回写线程的唤醒间隔（单位：厘秒） |\n| `dirty_expire_interval` | 3000 (30秒) | 脏页最大存活时间，超时强制回写 |\n| `laptop_mode` | 0 | 笔记本模式开关，减少磁盘活动以省电 |\n| `ratelimit_pages` | 32 | 每 CPU 脏页速率限制阈值 |\n\n### 关键数据结构\n- **`struct wb_domain`**  \n  回写域（writeback domain），用于聚合多个 BDI 的回写状态，支持全局或 per-memcg 的回写控制。\n  \n- **`struct dirty_throttle_control` (dtc)**  \n  脏页限流控制上下文，包含：\n  - `avail`：当前可脏化的内存总量\n  - `dirty`：当前脏页数量\n  - `thresh` / `bg_thresh`：硬/软回写阈值\n  - `wb_dirty` / `wb_thresh` / `wb_bg_thresh`：per-BDI 级别的对应值\n  - `pos_ratio`：用于计算回写速率的比例因子\n\n- **条件编译支持**  \n  通过 `CONFIG_CGROUP_WRITEBACK` 区分是否支持 memcg 级别的回写控制，提供 `GDTC_INIT`、`MDTC_INIT` 等宏及辅助函数（如 `mdtc_valid()`、`wb_min_max_ratio()`）。\n\n### 核心辅助函数（部分在截断代码中未完整显示）\n- `node_dirtyable_memory()`：计算指定 NUMA 节点中可用于脏页缓存的内存总量（包括空闲页 + 文件缓存页 - 保留页）。\n- `balance_dirty_pages()`：主限流函数，在进程写入时被调用，根据当前脏页水位决定是否休眠或触发回写。\n- `balance_dirty_pages_ratelimited()`：带速率限制的脏页平衡入口，避免频繁调用开销。\n\n## 3. 关键实现\n\n### 脏页阈值计算逻辑\n- 脏页上限基于 **“dirtyable memory”** 计算，即 `(free pages + file cache pages - kernel reserves)`。\n- 支持两种配置方式：**百分比（ratio）** 或 **绝对字节数（bytes）**，后者优先。\n- 当启用 `vm_highmem_is_dirtyable` 时，highmem 区域的空闲页也计入 dirtyable memory。\n\n### 动态限流机制\n- 使用 **`MAX_PAUSE`（最大 200ms）** 限制单次 `balance_dirty_pages()` 的休眠时间。\n- 引入 **`DIRTY_POLL_THRESH`（128KB）** 作为调用间隔优化阈值：若脏页增长过快，则提升休眠时间至最大值。\n- 通过 **`BANDWIDTH_INTERVAL`（200ms）** 动态估算存储设备的写入带宽，用于调整回写速率。\n\n### cgroup writeback 支持\n- 在 `CONFIG_CGROUP_WRITEBACK` 启用时：\n  - 每个 memcg 有独立的 `wb_domain`\n  - `dirty_throttle_control` 可关联全局（gdtc）或 memcg（mdtc）上下文\n  - BDI 的 min/max_ratio 根据其实际带宽动态缩放，实现公平分配\n\n### 老化与完成计数\n- 使用 `fprop_local_percpu` 结构跟踪每个 BDI 的回写完成情况。\n- `VM_COMPLETIONS_PERIOD_LEN`（3 秒）定义了回写完成率的老化周期，影响带宽估算的响应速度。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/swap.h>`、`<linux/pagevec.h>` 等，与页分配、回收机制紧密集成。\n- **VFS 层**：通过 `<linux/fs.h>`、`<linux/pagemap.h>` 与 address_space 和 inode 交互。\n- **块设备层**：通过 `<linux/blkdev.h>`、`<linux/backing-dev.h>` 获取 BDI 信息和 I/O 能力。\n- **调度与同步**：使用 `<linux/sched.h>`、`<linux/spinlock.h>`、`<linux/timer.h>` 实现休眠、锁和定时器。\n- **追踪系统**：集成 `<trace/events/writeback.h>` 提供回写事件追踪点。\n- **内部头文件**：包含 `\"internal.h\"` 获取 MM 子系统内部接口。\n\n## 5. 使用场景\n\n1. **用户空间写入文件**  \n   当进程通过 `write()` 修改文件页时，页被标记为脏，随后调用 `balance_dirty_pages_ratelimited()` 触发脏页控制。\n\n2. **内存压力下的页面回收**  \n   kswapd 或直接回收路径在需要释放内存时，可能调用回写逻辑清理脏页。\n\n3. **定期后台回写**  \n   `writeback` 内核线程按 `dirty_writeback_interval` 周期唤醒，检查并回写超过 `dirty_expire_interval` 的脏页。\n\n4. **系统关闭或 sync 调用**  \n   虽然主要同步逻辑在其他文件，但本文件提供的阈值和状态是决策基础。\n\n5. **容器环境中的资源隔离**  \n   启用 cgroup writeback 后，不同 memcg 的脏页回写相互隔离，避免一个容器的大量写入影响其他容器性能。\n\n6. **笔记本省电模式**  \n   当 `laptop_mode` 启用时，延迟回写以减少磁盘旋转时间，延长电池寿命。",
      "similarity": 0.5870525240898132,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "mm/page-writeback.c",
          "start_line": 1662,
          "end_line": 1988,
          "content": [
            "static inline void wb_dirty_limits(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct bdi_writeback *wb = dtc->wb;",
            "\tunsigned long wb_reclaimable;",
            "",
            "\t/*",
            "\t * wb_thresh is not treated as some limiting factor as",
            "\t * dirty_thresh, due to reasons",
            "\t * - in JBOD setup, wb_thresh can fluctuate a lot",
            "\t * - in a system with HDD and USB key, the USB key may somehow",
            "\t *   go into state (wb_dirty >> wb_thresh) either because",
            "\t *   wb_dirty starts high, or because wb_thresh drops low.",
            "\t *   In this case we don't want to hard throttle the USB key",
            "\t *   dirtiers for 100 seconds until wb_dirty drops under",
            "\t *   wb_thresh. Instead the auxiliary wb control line in",
            "\t *   wb_position_ratio() will let the dirtier task progress",
            "\t *   at some rate <= (write_bw / 2) for bringing down wb_dirty.",
            "\t */",
            "\tdtc->wb_thresh = __wb_calc_thresh(dtc);",
            "\tdtc->wb_bg_thresh = dtc->thresh ?",
            "\t\tdiv_u64((u64)dtc->wb_thresh * dtc->bg_thresh, dtc->thresh) : 0;",
            "",
            "\t/*",
            "\t * In order to avoid the stacked BDI deadlock we need",
            "\t * to ensure we accurately count the 'dirty' pages when",
            "\t * the threshold is low.",
            "\t *",
            "\t * Otherwise it would be possible to get thresh+n pages",
            "\t * reported dirty, even though there are thresh-m pages",
            "\t * actually dirty; with m+n sitting in the percpu",
            "\t * deltas.",
            "\t */",
            "\tif (dtc->wb_thresh < 2 * wb_stat_error()) {",
            "\t\twb_reclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);",
            "\t\tdtc->wb_dirty = wb_reclaimable + wb_stat_sum(wb, WB_WRITEBACK);",
            "\t} else {",
            "\t\twb_reclaimable = wb_stat(wb, WB_RECLAIMABLE);",
            "\t\tdtc->wb_dirty = wb_reclaimable + wb_stat(wb, WB_WRITEBACK);",
            "\t}",
            "}",
            "static int balance_dirty_pages(struct bdi_writeback *wb,",
            "\t\t\t       unsigned long pages_dirtied, unsigned int flags)",
            "{",
            "\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };",
            "\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };",
            "\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;",
            "\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?",
            "\t\t\t\t\t\t     &mdtc_stor : NULL;",
            "\tstruct dirty_throttle_control *sdtc;",
            "\tunsigned long nr_dirty;",
            "\tlong period;",
            "\tlong pause;",
            "\tlong max_pause;",
            "\tlong min_pause;",
            "\tint nr_dirtied_pause;",
            "\tbool dirty_exceeded = false;",
            "\tunsigned long task_ratelimit;",
            "\tunsigned long dirty_ratelimit;",
            "\tstruct backing_dev_info *bdi = wb->bdi;",
            "\tbool strictlimit = bdi->capabilities & BDI_CAP_STRICTLIMIT;",
            "\tunsigned long start_time = jiffies;",
            "\tint ret = 0;",
            "",
            "\tfor (;;) {",
            "\t\tunsigned long now = jiffies;",
            "\t\tunsigned long dirty, thresh, bg_thresh;",
            "\t\tunsigned long m_dirty = 0;\t/* stop bogus uninit warnings */",
            "\t\tunsigned long m_thresh = 0;",
            "\t\tunsigned long m_bg_thresh = 0;",
            "",
            "\t\tnr_dirty = global_node_page_state(NR_FILE_DIRTY);",
            "\t\tgdtc->avail = global_dirtyable_memory();",
            "\t\tgdtc->dirty = nr_dirty + global_node_page_state(NR_WRITEBACK);",
            "",
            "\t\tdomain_dirty_limits(gdtc);",
            "",
            "\t\tif (unlikely(strictlimit)) {",
            "\t\t\twb_dirty_limits(gdtc);",
            "",
            "\t\t\tdirty = gdtc->wb_dirty;",
            "\t\t\tthresh = gdtc->wb_thresh;",
            "\t\t\tbg_thresh = gdtc->wb_bg_thresh;",
            "\t\t} else {",
            "\t\t\tdirty = gdtc->dirty;",
            "\t\t\tthresh = gdtc->thresh;",
            "\t\t\tbg_thresh = gdtc->bg_thresh;",
            "\t\t}",
            "",
            "\t\tif (mdtc) {",
            "\t\t\tunsigned long filepages, headroom, writeback;",
            "",
            "\t\t\t/*",
            "\t\t\t * If @wb belongs to !root memcg, repeat the same",
            "\t\t\t * basic calculations for the memcg domain.",
            "\t\t\t */",
            "\t\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom,",
            "\t\t\t\t\t    &mdtc->dirty, &writeback);",
            "\t\t\tmdtc->dirty += writeback;",
            "\t\t\tmdtc_calc_avail(mdtc, filepages, headroom);",
            "",
            "\t\t\tdomain_dirty_limits(mdtc);",
            "",
            "\t\t\tif (unlikely(strictlimit)) {",
            "\t\t\t\twb_dirty_limits(mdtc);",
            "\t\t\t\tm_dirty = mdtc->wb_dirty;",
            "\t\t\t\tm_thresh = mdtc->wb_thresh;",
            "\t\t\t\tm_bg_thresh = mdtc->wb_bg_thresh;",
            "\t\t\t} else {",
            "\t\t\t\tm_dirty = mdtc->dirty;",
            "\t\t\t\tm_thresh = mdtc->thresh;",
            "\t\t\t\tm_bg_thresh = mdtc->bg_thresh;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * In laptop mode, we wait until hitting the higher threshold",
            "\t\t * before starting background writeout, and then write out all",
            "\t\t * the way down to the lower threshold.  So slow writers cause",
            "\t\t * minimal disk activity.",
            "\t\t *",
            "\t\t * In normal mode, we start background writeout at the lower",
            "\t\t * background_thresh, to keep the amount of dirty memory low.",
            "\t\t */",
            "\t\tif (!laptop_mode && nr_dirty > gdtc->bg_thresh &&",
            "\t\t    !writeback_in_progress(wb))",
            "\t\t\twb_start_background_writeback(wb);",
            "",
            "\t\t/*",
            "\t\t * Throttle it only when the background writeback cannot",
            "\t\t * catch-up. This avoids (excessively) small writeouts",
            "\t\t * when the wb limits are ramping up in case of !strictlimit.",
            "\t\t *",
            "\t\t * In strictlimit case make decision based on the wb counters",
            "\t\t * and limits. Small writeouts when the wb limits are ramping",
            "\t\t * up are the price we consciously pay for strictlimit-ing.",
            "\t\t *",
            "\t\t * If memcg domain is in effect, @dirty should be under",
            "\t\t * both global and memcg freerun ceilings.",
            "\t\t */",
            "\t\tif (dirty <= dirty_freerun_ceiling(thresh, bg_thresh) &&",
            "\t\t    (!mdtc ||",
            "\t\t     m_dirty <= dirty_freerun_ceiling(m_thresh, m_bg_thresh))) {",
            "\t\t\tunsigned long intv;",
            "\t\t\tunsigned long m_intv;",
            "",
            "free_running:",
            "\t\t\tintv = dirty_poll_interval(dirty, thresh);",
            "\t\t\tm_intv = ULONG_MAX;",
            "",
            "\t\t\tcurrent->dirty_paused_when = now;",
            "\t\t\tcurrent->nr_dirtied = 0;",
            "\t\t\tif (mdtc)",
            "\t\t\t\tm_intv = dirty_poll_interval(m_dirty, m_thresh);",
            "\t\t\tcurrent->nr_dirtied_pause = min(intv, m_intv);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Start writeback even when in laptop mode */",
            "\t\tif (unlikely(!writeback_in_progress(wb)))",
            "\t\t\twb_start_background_writeback(wb);",
            "",
            "\t\tmem_cgroup_flush_foreign(wb);",
            "",
            "\t\t/*",
            "\t\t * Calculate global domain's pos_ratio and select the",
            "\t\t * global dtc by default.",
            "\t\t */",
            "\t\tif (!strictlimit) {",
            "\t\t\twb_dirty_limits(gdtc);",
            "",
            "\t\t\tif ((current->flags & PF_LOCAL_THROTTLE) &&",
            "\t\t\t    gdtc->wb_dirty <",
            "\t\t\t    dirty_freerun_ceiling(gdtc->wb_thresh,",
            "\t\t\t\t\t\t  gdtc->wb_bg_thresh))",
            "\t\t\t\t/*",
            "\t\t\t\t * LOCAL_THROTTLE tasks must not be throttled",
            "\t\t\t\t * when below the per-wb freerun ceiling.",
            "\t\t\t\t */",
            "\t\t\t\tgoto free_running;",
            "\t\t}",
            "",
            "\t\tdirty_exceeded = (gdtc->wb_dirty > gdtc->wb_thresh) &&",
            "\t\t\t((gdtc->dirty > gdtc->thresh) || strictlimit);",
            "",
            "\t\twb_position_ratio(gdtc);",
            "\t\tsdtc = gdtc;",
            "",
            "\t\tif (mdtc) {",
            "\t\t\t/*",
            "\t\t\t * If memcg domain is in effect, calculate its",
            "\t\t\t * pos_ratio.  @wb should satisfy constraints from",
            "\t\t\t * both global and memcg domains.  Choose the one",
            "\t\t\t * w/ lower pos_ratio.",
            "\t\t\t */",
            "\t\t\tif (!strictlimit) {",
            "\t\t\t\twb_dirty_limits(mdtc);",
            "",
            "\t\t\t\tif ((current->flags & PF_LOCAL_THROTTLE) &&",
            "\t\t\t\t    mdtc->wb_dirty <",
            "\t\t\t\t    dirty_freerun_ceiling(mdtc->wb_thresh,",
            "\t\t\t\t\t\t\t  mdtc->wb_bg_thresh))",
            "\t\t\t\t\t/*",
            "\t\t\t\t\t * LOCAL_THROTTLE tasks must not be",
            "\t\t\t\t\t * throttled when below the per-wb",
            "\t\t\t\t\t * freerun ceiling.",
            "\t\t\t\t\t */",
            "\t\t\t\t\tgoto free_running;",
            "\t\t\t}",
            "\t\t\tdirty_exceeded |= (mdtc->wb_dirty > mdtc->wb_thresh) &&",
            "\t\t\t\t((mdtc->dirty > mdtc->thresh) || strictlimit);",
            "",
            "\t\t\twb_position_ratio(mdtc);",
            "\t\t\tif (mdtc->pos_ratio < gdtc->pos_ratio)",
            "\t\t\t\tsdtc = mdtc;",
            "\t\t}",
            "",
            "\t\tif (dirty_exceeded != wb->dirty_exceeded)",
            "\t\t\twb->dirty_exceeded = dirty_exceeded;",
            "",
            "\t\tif (time_is_before_jiffies(READ_ONCE(wb->bw_time_stamp) +",
            "\t\t\t\t\t   BANDWIDTH_INTERVAL))",
            "\t\t\t__wb_update_bandwidth(gdtc, mdtc, true);",
            "",
            "\t\t/* throttle according to the chosen dtc */",
            "\t\tdirty_ratelimit = READ_ONCE(wb->dirty_ratelimit);",
            "\t\ttask_ratelimit = ((u64)dirty_ratelimit * sdtc->pos_ratio) >>",
            "\t\t\t\t\t\t\tRATELIMIT_CALC_SHIFT;",
            "\t\tmax_pause = wb_max_pause(wb, sdtc->wb_dirty);",
            "\t\tmin_pause = wb_min_pause(wb, max_pause,",
            "\t\t\t\t\t task_ratelimit, dirty_ratelimit,",
            "\t\t\t\t\t &nr_dirtied_pause);",
            "",
            "\t\tif (unlikely(task_ratelimit == 0)) {",
            "\t\t\tperiod = max_pause;",
            "\t\t\tpause = max_pause;",
            "\t\t\tgoto pause;",
            "\t\t}",
            "\t\tperiod = HZ * pages_dirtied / task_ratelimit;",
            "\t\tpause = period;",
            "\t\tif (current->dirty_paused_when)",
            "\t\t\tpause -= now - current->dirty_paused_when;",
            "\t\t/*",
            "\t\t * For less than 1s think time (ext3/4 may block the dirtier",
            "\t\t * for up to 800ms from time to time on 1-HDD; so does xfs,",
            "\t\t * however at much less frequency), try to compensate it in",
            "\t\t * future periods by updating the virtual time; otherwise just",
            "\t\t * do a reset, as it may be a light dirtier.",
            "\t\t */",
            "\t\tif (pause < min_pause) {",
            "\t\t\ttrace_balance_dirty_pages(wb,",
            "\t\t\t\t\t\t  sdtc->thresh,",
            "\t\t\t\t\t\t  sdtc->bg_thresh,",
            "\t\t\t\t\t\t  sdtc->dirty,",
            "\t\t\t\t\t\t  sdtc->wb_thresh,",
            "\t\t\t\t\t\t  sdtc->wb_dirty,",
            "\t\t\t\t\t\t  dirty_ratelimit,",
            "\t\t\t\t\t\t  task_ratelimit,",
            "\t\t\t\t\t\t  pages_dirtied,",
            "\t\t\t\t\t\t  period,",
            "\t\t\t\t\t\t  min(pause, 0L),",
            "\t\t\t\t\t\t  start_time);",
            "\t\t\tif (pause < -HZ) {",
            "\t\t\t\tcurrent->dirty_paused_when = now;",
            "\t\t\t\tcurrent->nr_dirtied = 0;",
            "\t\t\t} else if (period) {",
            "\t\t\t\tcurrent->dirty_paused_when += period;",
            "\t\t\t\tcurrent->nr_dirtied = 0;",
            "\t\t\t} else if (current->nr_dirtied_pause <= pages_dirtied)",
            "\t\t\t\tcurrent->nr_dirtied_pause += pages_dirtied;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (unlikely(pause > max_pause)) {",
            "\t\t\t/* for occasional dropped task_ratelimit */",
            "\t\t\tnow += min(pause - max_pause, max_pause);",
            "\t\t\tpause = max_pause;",
            "\t\t}",
            "",
            "pause:",
            "\t\ttrace_balance_dirty_pages(wb,",
            "\t\t\t\t\t  sdtc->thresh,",
            "\t\t\t\t\t  sdtc->bg_thresh,",
            "\t\t\t\t\t  sdtc->dirty,",
            "\t\t\t\t\t  sdtc->wb_thresh,",
            "\t\t\t\t\t  sdtc->wb_dirty,",
            "\t\t\t\t\t  dirty_ratelimit,",
            "\t\t\t\t\t  task_ratelimit,",
            "\t\t\t\t\t  pages_dirtied,",
            "\t\t\t\t\t  period,",
            "\t\t\t\t\t  pause,",
            "\t\t\t\t\t  start_time);",
            "\t\tif (flags & BDP_ASYNC) {",
            "\t\t\tret = -EAGAIN;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t__set_current_state(TASK_KILLABLE);",
            "\t\tbdi->last_bdp_sleep = jiffies;",
            "\t\tio_schedule_timeout(pause);",
            "",
            "\t\tcurrent->dirty_paused_when = now + pause;",
            "\t\tcurrent->nr_dirtied = 0;",
            "\t\tcurrent->nr_dirtied_pause = nr_dirtied_pause;",
            "",
            "\t\t/*",
            "\t\t * This is typically equal to (dirty < thresh) and can also",
            "\t\t * keep \"1000+ dd on a slow USB stick\" under control.",
            "\t\t */",
            "\t\tif (task_ratelimit)",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * In the case of an unresponsive NFS server and the NFS dirty",
            "\t\t * pages exceeds dirty_thresh, give the other good wb's a pipe",
            "\t\t * to go through, so that tasks on them still remain responsive.",
            "\t\t *",
            "\t\t * In theory 1 page is enough to keep the consumer-producer",
            "\t\t * pipe going: the flusher cleans 1 page => the task dirties 1",
            "\t\t * more page. However wb_dirty has accounting errors.  So use",
            "\t\t * the larger and more IO friendly wb_stat_error.",
            "\t\t */",
            "\t\tif (sdtc->wb_dirty <= wb_stat_error())",
            "\t\t\tbreak;",
            "",
            "\t\tif (fatal_signal_pending(current))",
            "\t\t\tbreak;",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "wb_dirty_limits, balance_dirty_pages",
          "description": "实现脏页管理核心逻辑，包含确定当前脏页限制的计算函数和脏页平衡主函数，通过多级阈值检测、动态速率限制、暂停时间控制等机制，在保证系统响应性的同时防止内存过载，支持严格限制模式下的特殊处理。",
          "similarity": 0.634479284286499
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page-writeback.c",
          "start_line": 495,
          "end_line": 600,
          "content": [
            "bool node_dirty_ok(struct pglist_data *pgdat)",
            "{",
            "\tunsigned long limit = node_dirty_limit(pgdat);",
            "\tunsigned long nr_pages = 0;",
            "",
            "\tnr_pages += node_page_state(pgdat, NR_FILE_DIRTY);",
            "\tnr_pages += node_page_state(pgdat, NR_WRITEBACK);",
            "",
            "\treturn nr_pages <= limit;",
            "}",
            "static int dirty_background_ratio_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret;",
            "",
            "\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write)",
            "\t\tdirty_background_bytes = 0;",
            "\treturn ret;",
            "}",
            "static int dirty_background_bytes_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret;",
            "\tunsigned long old_bytes = dirty_background_bytes;",
            "",
            "\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write) {",
            "\t\tif (DIV_ROUND_UP(dirty_background_bytes, PAGE_SIZE) >",
            "\t\t\t\t\t\t\t\tUINT_MAX) {",
            "\t\t\tdirty_background_bytes = old_bytes;",
            "\t\t\treturn -ERANGE;",
            "\t\t}",
            "\t\tdirty_background_ratio = 0;",
            "\t}",
            "\treturn ret;",
            "}",
            "static int dirty_ratio_handler(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos)",
            "{",
            "\tint old_ratio = vm_dirty_ratio;",
            "\tint ret;",
            "",
            "\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write && vm_dirty_ratio != old_ratio) {",
            "\t\tvm_dirty_bytes = 0;",
            "\t\twriteback_set_ratelimit();",
            "\t}",
            "\treturn ret;",
            "}",
            "static int dirty_bytes_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tunsigned long old_bytes = vm_dirty_bytes;",
            "\tint ret;",
            "",
            "\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write && vm_dirty_bytes != old_bytes) {",
            "\t\tif (DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE) > UINT_MAX) {",
            "\t\t\tvm_dirty_bytes = old_bytes;",
            "\t\t\treturn -ERANGE;",
            "\t\t}",
            "\t\twriteback_set_ratelimit();",
            "\t\tvm_dirty_ratio = 0;",
            "\t}",
            "\treturn ret;",
            "}",
            "static unsigned long wp_next_time(unsigned long cur_time)",
            "{",
            "\tcur_time += VM_COMPLETIONS_PERIOD_LEN;",
            "\t/* 0 has a special meaning... */",
            "\tif (!cur_time)",
            "\t\treturn 1;",
            "\treturn cur_time;",
            "}",
            "static void wb_domain_writeout_add(struct wb_domain *dom,",
            "\t\t\t\t   struct fprop_local_percpu *completions,",
            "\t\t\t\t   unsigned int max_prop_frac, long nr)",
            "{",
            "\t__fprop_add_percpu_max(&dom->completions, completions,",
            "\t\t\t       max_prop_frac, nr);",
            "\t/* First event after period switching was turned off? */",
            "\tif (unlikely(!dom->period_time)) {",
            "\t\t/*",
            "\t\t * We can race with other __bdi_writeout_inc calls here but",
            "\t\t * it does not cause any harm since the resulting time when",
            "\t\t * timer will fire and what is in writeout_period_time will be",
            "\t\t * roughly the same.",
            "\t\t */",
            "\t\tdom->period_time = wp_next_time(jiffies);",
            "\t\tmod_timer(&dom->period_timer, dom->period_time);",
            "\t}",
            "}",
            "static inline void __wb_writeout_add(struct bdi_writeback *wb, long nr)",
            "{",
            "\tstruct wb_domain *cgdom;",
            "",
            "\twb_stat_mod(wb, WB_WRITTEN, nr);",
            "\twb_domain_writeout_add(&global_wb_domain, &wb->completions,",
            "\t\t\t       wb->bdi->max_prop_frac, nr);",
            "",
            "\tcgdom = mem_cgroup_wb_domain(wb);",
            "\tif (cgdom)",
            "\t\twb_domain_writeout_add(cgdom, wb_memcg_completions(wb),",
            "\t\t\t\t       wb->bdi->max_prop_frac, nr);",
            "}"
          ],
          "function_name": "node_dirty_ok, dirty_background_ratio_handler, dirty_background_bytes_handler, dirty_ratio_handler, dirty_bytes_handler, wp_next_time, wb_domain_writeout_add, __wb_writeout_add",
          "description": "通过sysctl接口动态调整脏页写回参数，维护写回统计信息并周期性触发写回检查，确保系统内存使用符合预设策略。",
          "similarity": 0.613195538520813
        },
        {
          "chunk_id": 7,
          "file_path": "mm/page-writeback.c",
          "start_line": 1221,
          "end_line": 1472,
          "content": [
            "static void wb_update_write_bandwidth(struct bdi_writeback *wb,",
            "\t\t\t\t      unsigned long elapsed,",
            "\t\t\t\t      unsigned long written)",
            "{",
            "\tconst unsigned long period = roundup_pow_of_two(3 * HZ);",
            "\tunsigned long avg = wb->avg_write_bandwidth;",
            "\tunsigned long old = wb->write_bandwidth;",
            "\tu64 bw;",
            "",
            "\t/*",
            "\t * bw = written * HZ / elapsed",
            "\t *",
            "\t *                   bw * elapsed + write_bandwidth * (period - elapsed)",
            "\t * write_bandwidth = ---------------------------------------------------",
            "\t *                                          period",
            "\t *",
            "\t * @written may have decreased due to folio_redirty_for_writepage().",
            "\t * Avoid underflowing @bw calculation.",
            "\t */",
            "\tbw = written - min(written, wb->written_stamp);",
            "\tbw *= HZ;",
            "\tif (unlikely(elapsed > period)) {",
            "\t\tbw = div64_ul(bw, elapsed);",
            "\t\tavg = bw;",
            "\t\tgoto out;",
            "\t}",
            "\tbw += (u64)wb->write_bandwidth * (period - elapsed);",
            "\tbw >>= ilog2(period);",
            "",
            "\t/*",
            "\t * one more level of smoothing, for filtering out sudden spikes",
            "\t */",
            "\tif (avg > old && old >= (unsigned long)bw)",
            "\t\tavg -= (avg - old) >> 3;",
            "",
            "\tif (avg < old && old <= (unsigned long)bw)",
            "\t\tavg += (old - avg) >> 3;",
            "",
            "out:",
            "\t/* keep avg > 0 to guarantee that tot > 0 if there are dirty wbs */",
            "\tavg = max(avg, 1LU);",
            "\tif (wb_has_dirty_io(wb)) {",
            "\t\tlong delta = avg - wb->avg_write_bandwidth;",
            "\t\tWARN_ON_ONCE(atomic_long_add_return(delta,",
            "\t\t\t\t\t&wb->bdi->tot_write_bandwidth) <= 0);",
            "\t}",
            "\twb->write_bandwidth = bw;",
            "\tWRITE_ONCE(wb->avg_write_bandwidth, avg);",
            "}",
            "static void update_dirty_limit(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct wb_domain *dom = dtc_dom(dtc);",
            "\tunsigned long thresh = dtc->thresh;",
            "\tunsigned long limit = dom->dirty_limit;",
            "",
            "\t/*",
            "\t * Follow up in one step.",
            "\t */",
            "\tif (limit < thresh) {",
            "\t\tlimit = thresh;",
            "\t\tgoto update;",
            "\t}",
            "",
            "\t/*",
            "\t * Follow down slowly. Use the higher one as the target, because thresh",
            "\t * may drop below dirty. This is exactly the reason to introduce",
            "\t * dom->dirty_limit which is guaranteed to lie above the dirty pages.",
            "\t */",
            "\tthresh = max(thresh, dtc->dirty);",
            "\tif (limit > thresh) {",
            "\t\tlimit -= (limit - thresh) >> 5;",
            "\t\tgoto update;",
            "\t}",
            "\treturn;",
            "update:",
            "\tdom->dirty_limit = limit;",
            "}",
            "static void domain_update_dirty_limit(struct dirty_throttle_control *dtc,",
            "\t\t\t\t      unsigned long now)",
            "{",
            "\tstruct wb_domain *dom = dtc_dom(dtc);",
            "",
            "\t/*",
            "\t * check locklessly first to optimize away locking for the most time",
            "\t */",
            "\tif (time_before(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL))",
            "\t\treturn;",
            "",
            "\tspin_lock(&dom->lock);",
            "\tif (time_after_eq(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL)) {",
            "\t\tupdate_dirty_limit(dtc);",
            "\t\tdom->dirty_limit_tstamp = now;",
            "\t}",
            "\tspin_unlock(&dom->lock);",
            "}",
            "static void wb_update_dirty_ratelimit(struct dirty_throttle_control *dtc,",
            "\t\t\t\t      unsigned long dirtied,",
            "\t\t\t\t      unsigned long elapsed)",
            "{",
            "\tstruct bdi_writeback *wb = dtc->wb;",
            "\tunsigned long dirty = dtc->dirty;",
            "\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);",
            "\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);",
            "\tunsigned long setpoint = (freerun + limit) / 2;",
            "\tunsigned long write_bw = wb->avg_write_bandwidth;",
            "\tunsigned long dirty_ratelimit = wb->dirty_ratelimit;",
            "\tunsigned long dirty_rate;",
            "\tunsigned long task_ratelimit;",
            "\tunsigned long balanced_dirty_ratelimit;",
            "\tunsigned long step;",
            "\tunsigned long x;",
            "\tunsigned long shift;",
            "",
            "\t/*",
            "\t * The dirty rate will match the writeout rate in long term, except",
            "\t * when dirty pages are truncated by userspace or re-dirtied by FS.",
            "\t */",
            "\tdirty_rate = (dirtied - wb->dirtied_stamp) * HZ / elapsed;",
            "",
            "\t/*",
            "\t * task_ratelimit reflects each dd's dirty rate for the past 200ms.",
            "\t */",
            "\ttask_ratelimit = (u64)dirty_ratelimit *",
            "\t\t\t\t\tdtc->pos_ratio >> RATELIMIT_CALC_SHIFT;",
            "\ttask_ratelimit++; /* it helps rampup dirty_ratelimit from tiny values */",
            "",
            "\t/*",
            "\t * A linear estimation of the \"balanced\" throttle rate. The theory is,",
            "\t * if there are N dd tasks, each throttled at task_ratelimit, the wb's",
            "\t * dirty_rate will be measured to be (N * task_ratelimit). So the below",
            "\t * formula will yield the balanced rate limit (write_bw / N).",
            "\t *",
            "\t * Note that the expanded form is not a pure rate feedback:",
            "\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate)\t\t     (1)",
            "\t * but also takes pos_ratio into account:",
            "\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate) * pos_ratio  (2)",
            "\t *",
            "\t * (1) is not realistic because pos_ratio also takes part in balancing",
            "\t * the dirty rate.  Consider the state",
            "\t *\tpos_ratio = 0.5\t\t\t\t\t\t     (3)",
            "\t *\trate = 2 * (write_bw / N)\t\t\t\t     (4)",
            "\t * If (1) is used, it will stuck in that state! Because each dd will",
            "\t * be throttled at",
            "\t *\ttask_ratelimit = pos_ratio * rate = (write_bw / N)\t     (5)",
            "\t * yielding",
            "\t *\tdirty_rate = N * task_ratelimit = write_bw\t\t     (6)",
            "\t * put (6) into (1) we get",
            "\t *\trate_(i+1) = rate_(i)\t\t\t\t\t     (7)",
            "\t *",
            "\t * So we end up using (2) to always keep",
            "\t *\trate_(i+1) ~= (write_bw / N)\t\t\t\t     (8)",
            "\t * regardless of the value of pos_ratio. As long as (8) is satisfied,",
            "\t * pos_ratio is able to drive itself to 1.0, which is not only where",
            "\t * the dirty count meet the setpoint, but also where the slope of",
            "\t * pos_ratio is most flat and hence task_ratelimit is least fluctuated.",
            "\t */",
            "\tbalanced_dirty_ratelimit = div_u64((u64)task_ratelimit * write_bw,",
            "\t\t\t\t\t   dirty_rate | 1);",
            "\t/*",
            "\t * balanced_dirty_ratelimit ~= (write_bw / N) <= write_bw",
            "\t */",
            "\tif (unlikely(balanced_dirty_ratelimit > write_bw))",
            "\t\tbalanced_dirty_ratelimit = write_bw;",
            "",
            "\t/*",
            "\t * We could safely do this and return immediately:",
            "\t *",
            "\t *\twb->dirty_ratelimit = balanced_dirty_ratelimit;",
            "\t *",
            "\t * However to get a more stable dirty_ratelimit, the below elaborated",
            "\t * code makes use of task_ratelimit to filter out singular points and",
            "\t * limit the step size.",
            "\t *",
            "\t * The below code essentially only uses the relative value of",
            "\t *",
            "\t *\ttask_ratelimit - dirty_ratelimit",
            "\t *\t= (pos_ratio - 1) * dirty_ratelimit",
            "\t *",
            "\t * which reflects the direction and size of dirty position error.",
            "\t */",
            "",
            "\t/*",
            "\t * dirty_ratelimit will follow balanced_dirty_ratelimit iff",
            "\t * task_ratelimit is on the same side of dirty_ratelimit, too.",
            "\t * For example, when",
            "\t * - dirty_ratelimit > balanced_dirty_ratelimit",
            "\t * - dirty_ratelimit > task_ratelimit (dirty pages are above setpoint)",
            "\t * lowering dirty_ratelimit will help meet both the position and rate",
            "\t * control targets. Otherwise, don't update dirty_ratelimit if it will",
            "\t * only help meet the rate target. After all, what the users ultimately",
            "\t * feel and care are stable dirty rate and small position error.",
            "\t *",
            "\t * |task_ratelimit - dirty_ratelimit| is used to limit the step size",
            "\t * and filter out the singular points of balanced_dirty_ratelimit. Which",
            "\t * keeps jumping around randomly and can even leap far away at times",
            "\t * due to the small 200ms estimation period of dirty_rate (we want to",
            "\t * keep that period small to reduce time lags).",
            "\t */",
            "\tstep = 0;",
            "",
            "\t/*",
            "\t * For strictlimit case, calculations above were based on wb counters",
            "\t * and limits (starting from pos_ratio = wb_position_ratio() and up to",
            "\t * balanced_dirty_ratelimit = task_ratelimit * write_bw / dirty_rate).",
            "\t * Hence, to calculate \"step\" properly, we have to use wb_dirty as",
            "\t * \"dirty\" and wb_setpoint as \"setpoint\".",
            "\t *",
            "\t * We rampup dirty_ratelimit forcibly if wb_dirty is low because",
            "\t * it's possible that wb_thresh is close to zero due to inactivity",
            "\t * of backing device.",
            "\t */",
            "\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {",
            "\t\tdirty = dtc->wb_dirty;",
            "\t\tif (dtc->wb_dirty < 8)",
            "\t\t\tsetpoint = dtc->wb_dirty + 1;",
            "\t\telse",
            "\t\t\tsetpoint = (dtc->wb_thresh + dtc->wb_bg_thresh) / 2;",
            "\t}",
            "",
            "\tif (dirty < setpoint) {",
            "\t\tx = min3(wb->balanced_dirty_ratelimit,",
            "\t\t\t balanced_dirty_ratelimit, task_ratelimit);",
            "\t\tif (dirty_ratelimit < x)",
            "\t\t\tstep = x - dirty_ratelimit;",
            "\t} else {",
            "\t\tx = max3(wb->balanced_dirty_ratelimit,",
            "\t\t\t balanced_dirty_ratelimit, task_ratelimit);",
            "\t\tif (dirty_ratelimit > x)",
            "\t\t\tstep = dirty_ratelimit - x;",
            "\t}",
            "",
            "\t/*",
            "\t * Don't pursue 100% rate matching. It's impossible since the balanced",
            "\t * rate itself is constantly fluctuating. So decrease the track speed",
            "\t * when it gets close to the target. Helps eliminate pointless tremors.",
            "\t */",
            "\tshift = dirty_ratelimit / (2 * step + 1);",
            "\tif (shift < BITS_PER_LONG)",
            "\t\tstep = DIV_ROUND_UP(step >> shift, 8);",
            "\telse",
            "\t\tstep = 0;",
            "",
            "\tif (dirty_ratelimit < balanced_dirty_ratelimit)",
            "\t\tdirty_ratelimit += step;",
            "\telse",
            "\t\tdirty_ratelimit -= step;",
            "",
            "\tWRITE_ONCE(wb->dirty_ratelimit, max(dirty_ratelimit, 1UL));",
            "\twb->balanced_dirty_ratelimit = balanced_dirty_ratelimit;",
            "",
            "\ttrace_bdi_dirty_ratelimit(wb, dirty_rate, task_ratelimit);",
            "}"
          ],
          "function_name": "wb_update_write_bandwidth, update_dirty_limit, domain_update_dirty_limit, wb_update_dirty_ratelimit",
          "description": "实现写带宽统计更新逻辑，包含平滑写入速率变化的算法，更新脏页限制的动态调整机制，以及根据当前脏页速率与写入能力计算目标脏页产生速率的控制逻辑，通过分层限速策略维持系统稳定。",
          "similarity": 0.6129032373428345
        },
        {
          "chunk_id": 4,
          "file_path": "mm/page-writeback.c",
          "start_line": 615,
          "end_line": 719,
          "content": [
            "void wb_writeout_inc(struct bdi_writeback *wb)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\t__wb_writeout_add(wb, 1);",
            "\tlocal_irq_restore(flags);",
            "}",
            "static void writeout_period(struct timer_list *t)",
            "{",
            "\tstruct wb_domain *dom = from_timer(dom, t, period_timer);",
            "\tint miss_periods = (jiffies - dom->period_time) /",
            "\t\t\t\t\t\t VM_COMPLETIONS_PERIOD_LEN;",
            "",
            "\tif (fprop_new_period(&dom->completions, miss_periods + 1)) {",
            "\t\tdom->period_time = wp_next_time(dom->period_time +",
            "\t\t\t\tmiss_periods * VM_COMPLETIONS_PERIOD_LEN);",
            "\t\tmod_timer(&dom->period_timer, dom->period_time);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Aging has zeroed all fractions. Stop wasting CPU on period",
            "\t\t * updates.",
            "\t\t */",
            "\t\tdom->period_time = 0;",
            "\t}",
            "}",
            "int wb_domain_init(struct wb_domain *dom, gfp_t gfp)",
            "{",
            "\tmemset(dom, 0, sizeof(*dom));",
            "",
            "\tspin_lock_init(&dom->lock);",
            "",
            "\ttimer_setup(&dom->period_timer, writeout_period, TIMER_DEFERRABLE);",
            "",
            "\tdom->dirty_limit_tstamp = jiffies;",
            "",
            "\treturn fprop_global_init(&dom->completions, gfp);",
            "}",
            "void wb_domain_exit(struct wb_domain *dom)",
            "{",
            "\tdel_timer_sync(&dom->period_timer);",
            "\tfprop_global_destroy(&dom->completions);",
            "}",
            "static int bdi_check_pages_limit(unsigned long pages)",
            "{",
            "\tunsigned long max_dirty_pages = global_dirtyable_memory();",
            "",
            "\tif (pages > max_dirty_pages)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static unsigned long bdi_ratio_from_pages(unsigned long pages)",
            "{",
            "\tunsigned long background_thresh;",
            "\tunsigned long dirty_thresh;",
            "\tunsigned long ratio;",
            "",
            "\tglobal_dirty_limits(&background_thresh, &dirty_thresh);",
            "\tratio = div64_u64(pages * 100ULL * BDI_RATIO_SCALE, dirty_thresh);",
            "",
            "\treturn ratio;",
            "}",
            "static u64 bdi_get_bytes(unsigned int ratio)",
            "{",
            "\tunsigned long background_thresh;",
            "\tunsigned long dirty_thresh;",
            "\tu64 bytes;",
            "",
            "\tglobal_dirty_limits(&background_thresh, &dirty_thresh);",
            "\tbytes = (dirty_thresh * PAGE_SIZE * ratio) / BDI_RATIO_SCALE / 100;",
            "",
            "\treturn bytes;",
            "}",
            "static int __bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)",
            "{",
            "\tunsigned int delta;",
            "\tint ret = 0;",
            "",
            "\tif (min_ratio > 100 * BDI_RATIO_SCALE)",
            "\t\treturn -EINVAL;",
            "\tmin_ratio *= BDI_RATIO_SCALE;",
            "",
            "\tspin_lock_bh(&bdi_lock);",
            "\tif (min_ratio > bdi->max_ratio) {",
            "\t\tret = -EINVAL;",
            "\t} else {",
            "\t\tif (min_ratio < bdi->min_ratio) {",
            "\t\t\tdelta = bdi->min_ratio - min_ratio;",
            "\t\t\tbdi_min_ratio -= delta;",
            "\t\t\tbdi->min_ratio = min_ratio;",
            "\t\t} else {",
            "\t\t\tdelta = min_ratio - bdi->min_ratio;",
            "\t\t\tif (bdi_min_ratio + delta < 100 * BDI_RATIO_SCALE) {",
            "\t\t\t\tbdi_min_ratio += delta;",
            "\t\t\t\tbdi->min_ratio = min_ratio;",
            "\t\t\t} else {",
            "\t\t\t\tret = -EINVAL;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tspin_unlock_bh(&bdi_lock);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "wb_writeout_inc, writeout_period, wb_domain_init, wb_domain_exit, bdi_check_pages_limit, bdi_ratio_from_pages, bdi_get_bytes, __bdi_set_min_ratio",
          "description": "实现写回统计增量记录、定时器驱动的写回周期校准及内存设备（bdi）的脏页限制验证与参数转换逻辑，支撑动态写回策略调整。",
          "similarity": 0.599766194820404
        },
        {
          "chunk_id": 6,
          "file_path": "mm/page-writeback.c",
          "start_line": 883,
          "end_line": 1126,
          "content": [
            "static unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct wb_domain *dom = dtc_dom(dtc);",
            "\tunsigned long thresh = dtc->thresh;",
            "\tu64 wb_thresh;",
            "\tunsigned long numerator, denominator;",
            "\tunsigned long wb_min_ratio, wb_max_ratio;",
            "",
            "\t/*",
            "\t * Calculate this BDI's share of the thresh ratio.",
            "\t */",
            "\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,",
            "\t\t\t      &numerator, &denominator);",
            "",
            "\twb_thresh = (thresh * (100 * BDI_RATIO_SCALE - bdi_min_ratio)) / (100 * BDI_RATIO_SCALE);",
            "\twb_thresh *= numerator;",
            "\twb_thresh = div64_ul(wb_thresh, denominator);",
            "",
            "\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);",
            "",
            "\twb_thresh += (thresh * wb_min_ratio) / (100 * BDI_RATIO_SCALE);",
            "\tif (wb_thresh > (thresh * wb_max_ratio) / (100 * BDI_RATIO_SCALE))",
            "\t\twb_thresh = thresh * wb_max_ratio / (100 * BDI_RATIO_SCALE);",
            "",
            "\treturn wb_thresh;",
            "}",
            "unsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh)",
            "{",
            "\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb),",
            "\t\t\t\t\t       .thresh = thresh };",
            "\treturn __wb_calc_thresh(&gdtc);",
            "}",
            "unsigned long cgwb_calc_thresh(struct bdi_writeback *wb)",
            "{",
            "\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };",
            "\tstruct dirty_throttle_control mdtc = { MDTC_INIT(wb, &gdtc) };",
            "\tunsigned long filepages = 0, headroom = 0, writeback = 0;",
            "",
            "\tgdtc.avail = global_dirtyable_memory();",
            "\tgdtc.dirty = global_node_page_state(NR_FILE_DIRTY) +",
            "\t\t     global_node_page_state(NR_WRITEBACK);",
            "",
            "\tmem_cgroup_wb_stats(wb, &filepages, &headroom,",
            "\t\t\t    &mdtc.dirty, &writeback);",
            "\tmdtc.dirty += writeback;",
            "\tmdtc_calc_avail(&mdtc, filepages, headroom);",
            "\tdomain_dirty_limits(&mdtc);",
            "",
            "\treturn __wb_calc_thresh(&mdtc);",
            "}",
            "static long long pos_ratio_polynom(unsigned long setpoint,",
            "\t\t\t\t\t  unsigned long dirty,",
            "\t\t\t\t\t  unsigned long limit)",
            "{",
            "\tlong long pos_ratio;",
            "\tlong x;",
            "",
            "\tx = div64_s64(((s64)setpoint - (s64)dirty) << RATELIMIT_CALC_SHIFT,",
            "\t\t      (limit - setpoint) | 1);",
            "\tpos_ratio = x;",
            "\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;",
            "\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;",
            "\tpos_ratio += 1 << RATELIMIT_CALC_SHIFT;",
            "",
            "\treturn clamp(pos_ratio, 0LL, 2LL << RATELIMIT_CALC_SHIFT);",
            "}",
            "static void wb_position_ratio(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct bdi_writeback *wb = dtc->wb;",
            "\tunsigned long write_bw = READ_ONCE(wb->avg_write_bandwidth);",
            "\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);",
            "\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);",
            "\tunsigned long wb_thresh = dtc->wb_thresh;",
            "\tunsigned long x_intercept;",
            "\tunsigned long setpoint;\t\t/* dirty pages' target balance point */",
            "\tunsigned long wb_setpoint;",
            "\tunsigned long span;",
            "\tlong long pos_ratio;\t\t/* for scaling up/down the rate limit */",
            "\tlong x;",
            "",
            "\tdtc->pos_ratio = 0;",
            "",
            "\tif (unlikely(dtc->dirty >= limit))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * global setpoint",
            "\t *",
            "\t * See comment for pos_ratio_polynom().",
            "\t */",
            "\tsetpoint = (freerun + limit) / 2;",
            "\tpos_ratio = pos_ratio_polynom(setpoint, dtc->dirty, limit);",
            "",
            "\t/*",
            "\t * The strictlimit feature is a tool preventing mistrusted filesystems",
            "\t * from growing a large number of dirty pages before throttling. For",
            "\t * such filesystems balance_dirty_pages always checks wb counters",
            "\t * against wb limits. Even if global \"nr_dirty\" is under \"freerun\".",
            "\t * This is especially important for fuse which sets bdi->max_ratio to",
            "\t * 1% by default. Without strictlimit feature, fuse writeback may",
            "\t * consume arbitrary amount of RAM because it is accounted in",
            "\t * NR_WRITEBACK_TEMP which is not involved in calculating \"nr_dirty\".",
            "\t *",
            "\t * Here, in wb_position_ratio(), we calculate pos_ratio based on",
            "\t * two values: wb_dirty and wb_thresh. Let's consider an example:",
            "\t * total amount of RAM is 16GB, bdi->max_ratio is equal to 1%, global",
            "\t * limits are set by default to 10% and 20% (background and throttle).",
            "\t * Then wb_thresh is 1% of 20% of 16GB. This amounts to ~8K pages.",
            "\t * wb_calc_thresh(wb, bg_thresh) is about ~4K pages. wb_setpoint is",
            "\t * about ~6K pages (as the average of background and throttle wb",
            "\t * limits). The 3rd order polynomial will provide positive feedback if",
            "\t * wb_dirty is under wb_setpoint and vice versa.",
            "\t *",
            "\t * Note, that we cannot use global counters in these calculations",
            "\t * because we want to throttle process writing to a strictlimit wb",
            "\t * much earlier than global \"freerun\" is reached (~23MB vs. ~2.3GB",
            "\t * in the example above).",
            "\t */",
            "\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {",
            "\t\tlong long wb_pos_ratio;",
            "",
            "\t\tif (dtc->wb_dirty < 8) {",
            "\t\t\tdtc->pos_ratio = min_t(long long, pos_ratio * 2,",
            "\t\t\t\t\t   2 << RATELIMIT_CALC_SHIFT);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tif (dtc->wb_dirty >= wb_thresh)",
            "\t\t\treturn;",
            "",
            "\t\twb_setpoint = dirty_freerun_ceiling(wb_thresh,",
            "\t\t\t\t\t\t    dtc->wb_bg_thresh);",
            "",
            "\t\tif (wb_setpoint == 0 || wb_setpoint == wb_thresh)",
            "\t\t\treturn;",
            "",
            "\t\twb_pos_ratio = pos_ratio_polynom(wb_setpoint, dtc->wb_dirty,",
            "\t\t\t\t\t\t wb_thresh);",
            "",
            "\t\t/*",
            "\t\t * Typically, for strictlimit case, wb_setpoint << setpoint",
            "\t\t * and pos_ratio >> wb_pos_ratio. In the other words global",
            "\t\t * state (\"dirty\") is not limiting factor and we have to",
            "\t\t * make decision based on wb counters. But there is an",
            "\t\t * important case when global pos_ratio should get precedence:",
            "\t\t * global limits are exceeded (e.g. due to activities on other",
            "\t\t * wb's) while given strictlimit wb is below limit.",
            "\t\t *",
            "\t\t * \"pos_ratio * wb_pos_ratio\" would work for the case above,",
            "\t\t * but it would look too non-natural for the case of all",
            "\t\t * activity in the system coming from a single strictlimit wb",
            "\t\t * with bdi->max_ratio == 100%.",
            "\t\t *",
            "\t\t * Note that min() below somewhat changes the dynamics of the",
            "\t\t * control system. Normally, pos_ratio value can be well over 3",
            "\t\t * (when globally we are at freerun and wb is well below wb",
            "\t\t * setpoint). Now the maximum pos_ratio in the same situation",
            "\t\t * is 2. We might want to tweak this if we observe the control",
            "\t\t * system is too slow to adapt.",
            "\t\t */",
            "\t\tdtc->pos_ratio = min(pos_ratio, wb_pos_ratio);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * We have computed basic pos_ratio above based on global situation. If",
            "\t * the wb is over/under its share of dirty pages, we want to scale",
            "\t * pos_ratio further down/up. That is done by the following mechanism.",
            "\t */",
            "",
            "\t/*",
            "\t * wb setpoint",
            "\t *",
            "\t *        f(wb_dirty) := 1.0 + k * (wb_dirty - wb_setpoint)",
            "\t *",
            "\t *                        x_intercept - wb_dirty",
            "\t *                     := --------------------------",
            "\t *                        x_intercept - wb_setpoint",
            "\t *",
            "\t * The main wb control line is a linear function that subjects to",
            "\t *",
            "\t * (1) f(wb_setpoint) = 1.0",
            "\t * (2) k = - 1 / (8 * write_bw)  (in single wb case)",
            "\t *     or equally: x_intercept = wb_setpoint + 8 * write_bw",
            "\t *",
            "\t * For single wb case, the dirty pages are observed to fluctuate",
            "\t * regularly within range",
            "\t *        [wb_setpoint - write_bw/2, wb_setpoint + write_bw/2]",
            "\t * for various filesystems, where (2) can yield in a reasonable 12.5%",
            "\t * fluctuation range for pos_ratio.",
            "\t *",
            "\t * For JBOD case, wb_thresh (not wb_dirty!) could fluctuate up to its",
            "\t * own size, so move the slope over accordingly and choose a slope that",
            "\t * yields 100% pos_ratio fluctuation on suddenly doubled wb_thresh.",
            "\t */",
            "\tif (unlikely(wb_thresh > dtc->thresh))",
            "\t\twb_thresh = dtc->thresh;",
            "\t/*",
            "\t * It's very possible that wb_thresh is close to 0 not because the",
            "\t * device is slow, but that it has remained inactive for long time.",
            "\t * Honour such devices a reasonable good (hopefully IO efficient)",
            "\t * threshold, so that the occasional writes won't be blocked and active",
            "\t * writes can rampup the threshold quickly.",
            "\t */",
            "\twb_thresh = max(wb_thresh, (limit - dtc->dirty) / 8);",
            "\t/*",
            "\t * scale global setpoint to wb's:",
            "\t *\twb_setpoint = setpoint * wb_thresh / thresh",
            "\t */",
            "\tx = div_u64((u64)wb_thresh << 16, dtc->thresh | 1);",
            "\twb_setpoint = setpoint * (u64)x >> 16;",
            "\t/*",
            "\t * Use span=(8*write_bw) in single wb case as indicated by",
            "\t * (thresh - wb_thresh ~= 0) and transit to wb_thresh in JBOD case.",
            "\t *",
            "\t *        wb_thresh                    thresh - wb_thresh",
            "\t * span = --------- * (8 * write_bw) + ------------------ * wb_thresh",
            "\t *         thresh                           thresh",
            "\t */",
            "\tspan = (dtc->thresh - wb_thresh + 8 * write_bw) * (u64)x >> 16;",
            "\tx_intercept = wb_setpoint + span;",
            "",
            "\tif (dtc->wb_dirty < x_intercept - span / 4) {",
            "\t\tpos_ratio = div64_u64(pos_ratio * (x_intercept - dtc->wb_dirty),",
            "\t\t\t\t      (x_intercept - wb_setpoint) | 1);",
            "\t} else",
            "\t\tpos_ratio /= 4;",
            "",
            "\t/*",
            "\t * wb reserve area, safeguard against dirty pool underrun and disk idle",
            "\t * It may push the desired control point of global dirty pages higher",
            "\t * than setpoint.",
            "\t */",
            "\tx_intercept = wb_thresh / 2;",
            "\tif (dtc->wb_dirty < x_intercept) {",
            "\t\tif (dtc->wb_dirty > x_intercept / 8)",
            "\t\t\tpos_ratio = div_u64(pos_ratio * x_intercept,",
            "\t\t\t\t\t    dtc->wb_dirty);",
            "\t\telse",
            "\t\t\tpos_ratio *= 8;",
            "\t}",
            "",
            "\tdtc->pos_ratio = pos_ratio;",
            "}"
          ],
          "function_name": "__wb_calc_thresh, wb_calc_thresh, cgwb_calc_thresh, pos_ratio_polynom, wb_position_ratio",
          "description": "实现基于脏页阈值的动态调节算法，包含计算全局和内存控制组的脏页阈值、基于多项式的位置比值计算、根据写入带宽和当前脏页状态调整控制参数等功能，通过多级阈值和反馈机制平衡系统负载。",
          "similarity": 0.5982793569564819
        }
      ]
    },
    {
      "source_file": "kernel/watchdog_buddy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:51:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watchdog_buddy.c`\n\n---\n\n# watchdog_buddy.c 技术文档\n\n## 1. 文件概述\n\n`watchdog_buddy.c` 实现了 Linux 内核硬锁定检测（hardlockup detection）机制中的“伙伴检查”（buddy checking）逻辑。该机制通过让一个 CPU 负责监控其“下一个”CPU 的高精度定时器（hrtimer）中断是否正常触发，从而检测目标 CPU 是否陷入硬锁定状态（即完全停止响应中断）。该文件通过维护一个在线 CPU 掩码（`watchdog_cpus`）并定义 CPU 之间的监控关系，避免在 CPU 上下线过程中产生误报。\n\n## 2. 核心功能\n\n### 数据结构\n- `watchdog_cpus`：静态的 `cpumask_t` 类型变量，记录当前参与硬锁定检测的所有在线 CPU，使用 `__read_mostly` 优化缓存访问。\n\n### 主要函数\n- `watchdog_next_cpu(unsigned int cpu)`：根据 `watchdog_cpus` 掩码，返回指定 CPU 的下一个参与监控的 CPU；若已到末尾则回绕到第一个；若掩码中仅有一个 CPU，则返回 `nr_cpu_ids`（表示无效）。\n- `watchdog_hardlockup_probe(void)`：硬锁定探测初始化函数（当前实现为空，返回 0）。\n- `watchdog_hardlockup_enable(unsigned int cpu)`：启用指定 CPU 的硬锁定检测功能，将其加入 `watchdog_cpus` 掩码，并通过“触摸”（touch）机制防止上下线过程中的误报。\n- `watchdog_hardlockup_disable(unsigned int cpu)`：禁用指定 CPU 的硬锁定检测功能，将其从 `watchdog_cpus` 掩码中移除，并同样通过“触摸”机制防止误报。\n- `watchdog_buddy_check_hardlockup(int hrtimer_interrupts)`：由当前 CPU 调用，周期性检查其“伙伴”（下一个）CPU 是否发生硬锁定。\n\n## 3. 关键实现\n\n### 伙伴监控机制\n- 每个 CPU 不监控自身，而是监控 `watchdog_cpus` 掩码中逻辑上的“下一个”CPU（通过 `watchdog_next_cpu()` 确定）。\n- 检查频率为每 3 次 hrtimer 中断执行一次（`hrtimer_interrupts % 3 == 0`），对应时间约为 `watchdog_thresh * 1.2` 秒，略大于默认阈值，以平衡灵敏度与开销。\n\n### 防止误报的“触摸”策略\n- **CPU 上线时**：新上线的 CPU 和其下一个 CPU 都会被“触摸”（调用 `watchdog_hardlockup_touch_cpu()`），确保它们的看门狗计数器被重置，避免其他 CPU 在其 hrtimer 首次运行前误判为锁定。\n- **CPU 下线时**：下线 CPU 的下一个 CPU 会被“触摸”，防止前一个 CPU 立即检查该目标而触发误报。\n\n### 内存屏障同步\n- 在修改 `watchdog_cpus` 掩码前后使用 `smp_wmb()`（写内存屏障），确保“触摸”操作在掩码更新前对其他 CPU 可见。\n- 在读取伙伴 CPU 状态前使用 `smp_rmb()`（读内存屏障），确保能观察到最新的掩码状态和触摸操作，维持检查逻辑的一致性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/cpu.h>`：CPU 热插拔相关接口。\n  - `<linux/cpumask.h>`：CPU 掩码操作函数（如 `cpumask_next`, `cpumask_first`）。\n  - `<linux/kernel.h>`：基础内核定义。\n  - `<linux/nmi.h>`：包含硬锁定检测相关函数声明（如 `watchdog_hardlockup_touch_cpu`, `watchdog_hardlockup_check`）。\n  - `<linux/percpu-defs.h>`：每 CPU 变量支持。\n- **外部函数依赖**：\n  - `watchdog_hardlockup_touch_cpu()` 和 `watchdog_hardlockup_check()`：由其他 watchdog 模块（如 `nmi_watchdog.c`）实现，用于重置看门狗计数器和执行实际锁定检测。\n- **配置依赖**：该文件通常在 `CONFIG_HARDLOCKUP_DETECTOR` 或相关看门狗配置启用时编译。\n\n## 5. 使用场景\n\n- **硬锁定检测**：作为内核 NMI 看门狗（NMI watchdog）的一部分，在启用了硬锁定检测功能的系统中运行。\n- **CPU 热插拔**：在 CPU 动态上线（`CPU_ONLINE`）或下线（`CPU_DEAD`）事件中被调用，确保监控拓扑正确更新且不产生误报。\n- **高可靠性系统**：在服务器、实时系统等对稳定性要求高的环境中，用于及时发现并处理 CPU 完全挂死的严重故障。\n- **调试与诊断**：当系统疑似因内核 bug 导致某 CPU 停止响应时，该机制可触发 panic 或记录日志，辅助问题定位。",
      "similarity": 0.5752986669540405,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/watchdog_buddy.c",
          "start_line": 11,
          "end_line": 109,
          "content": [
            "static unsigned int watchdog_next_cpu(unsigned int cpu)",
            "{",
            "\tunsigned int next_cpu;",
            "",
            "\tnext_cpu = cpumask_next(cpu, &watchdog_cpus);",
            "\tif (next_cpu >= nr_cpu_ids)",
            "\t\tnext_cpu = cpumask_first(&watchdog_cpus);",
            "",
            "\tif (next_cpu == cpu)",
            "\t\treturn nr_cpu_ids;",
            "",
            "\treturn next_cpu;",
            "}",
            "int __init watchdog_hardlockup_probe(void)",
            "{",
            "\treturn 0;",
            "}",
            "void watchdog_hardlockup_enable(unsigned int cpu)",
            "{",
            "\tunsigned int next_cpu;",
            "",
            "\t/*",
            "\t * The new CPU will be marked online before the hrtimer interrupt",
            "\t * gets a chance to run on it. If another CPU tests for a",
            "\t * hardlockup on the new CPU before it has run its the hrtimer",
            "\t * interrupt, it will get a false positive. Touch the watchdog on",
            "\t * the new CPU to delay the check for at least 3 sampling periods",
            "\t * to guarantee one hrtimer has run on the new CPU.",
            "\t */",
            "\twatchdog_hardlockup_touch_cpu(cpu);",
            "",
            "\t/*",
            "\t * We are going to check the next CPU. Our watchdog_hrtimer",
            "\t * need not be zero if the CPU has already been online earlier.",
            "\t * Touch the watchdog on the next CPU to avoid false positive",
            "\t * if we try to check it in less then 3 interrupts.",
            "\t */",
            "\tnext_cpu = watchdog_next_cpu(cpu);",
            "\tif (next_cpu < nr_cpu_ids)",
            "\t\twatchdog_hardlockup_touch_cpu(next_cpu);",
            "",
            "\t/*",
            "\t * Makes sure that watchdog is touched on this CPU before",
            "\t * other CPUs could see it in watchdog_cpus. The counter",
            "\t * part is in watchdog_buddy_check_hardlockup().",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tcpumask_set_cpu(cpu, &watchdog_cpus);",
            "}",
            "void watchdog_hardlockup_disable(unsigned int cpu)",
            "{",
            "\tunsigned int next_cpu = watchdog_next_cpu(cpu);",
            "",
            "\t/*",
            "\t * Offlining this CPU will cause the CPU before this one to start",
            "\t * checking the one after this one. If this CPU just finished checking",
            "\t * the next CPU and updating hrtimer_interrupts_saved, and then the",
            "\t * previous CPU checks it within one sample period, it will trigger a",
            "\t * false positive. Touch the watchdog on the next CPU to prevent it.",
            "\t */",
            "\tif (next_cpu < nr_cpu_ids)",
            "\t\twatchdog_hardlockup_touch_cpu(next_cpu);",
            "",
            "\t/*",
            "\t * Makes sure that watchdog is touched on the next CPU before",
            "\t * this CPU disappear in watchdog_cpus. The counter part is in",
            "\t * watchdog_buddy_check_hardlockup().",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tcpumask_clear_cpu(cpu, &watchdog_cpus);",
            "}",
            "void watchdog_buddy_check_hardlockup(int hrtimer_interrupts)",
            "{",
            "\tunsigned int next_cpu;",
            "",
            "\t/*",
            "\t * Test for hardlockups every 3 samples. The sample period is",
            "\t *  watchdog_thresh * 2 / 5, so 3 samples gets us back to slightly over",
            "\t *  watchdog_thresh (over by 20%).",
            "\t */",
            "\tif (hrtimer_interrupts % 3 != 0)",
            "\t\treturn;",
            "",
            "\t/* check for a hardlockup on the next CPU */",
            "\tnext_cpu = watchdog_next_cpu(smp_processor_id());",
            "\tif (next_cpu >= nr_cpu_ids)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Make sure that the watchdog was touched on next CPU when",
            "\t * watchdog_next_cpu() returned another one because of",
            "\t * a change in watchdog_hardlockup_enable()/disable().",
            "\t */",
            "\tsmp_rmb();",
            "",
            "\twatchdog_hardlockup_check(next_cpu, NULL);",
            "}"
          ],
          "function_name": "watchdog_next_cpu, watchdog_hardlockup_probe, watchdog_hardlockup_enable, watchdog_hardlockup_disable, watchdog_buddy_check_hardlockup",
          "description": "实现了看门狗硬锁死检测的CPU管理逻辑，包含CPU遍历、启用/禁用操作及检测触发机制，通过内存屏障保证多CPU状态更新的可见性，提供周期性硬锁死检查功能。",
          "similarity": 0.5972554683685303
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/watchdog_buddy.c",
          "start_line": 1,
          "end_line": 10,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu-defs.h>",
            "",
            "static cpumask_t __read_mostly watchdog_cpus;",
            ""
          ],
          "function_name": null,
          "description": "定义了一个全局的CPU掩码变量watchdog_cpus，用于跟踪当前参与看门狗机制的CPU列表，初始化为只读属性。",
          "similarity": 0.5253241062164307
        }
      ]
    }
  ]
}