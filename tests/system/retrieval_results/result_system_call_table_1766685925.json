{
  "query": "system call table",
  "timestamp": "2025-12-26 02:05:25",
  "retrieved_files": [
    {
      "source_file": "kernel/futex/syscalls.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:35:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `futex\\syscalls.c`\n\n---\n\n# futex/syscalls.c 技术文档\n\n## 1. 文件概述\n\n`futex/syscalls.c` 是 Linux 内核中实现 futex（Fast Userspace muTEX）系统调用的核心文件之一。该文件主要负责处理与 futex 相关的用户空间系统调用接口，包括基础 futex 操作、健壮 futex（robust futex）支持以及多 futex 等待（`futex_waitv`）功能。futex 是一种高效的用户态同步原语，内核仅在必要时（如竞争或阻塞）介入，从而在无竞争场景下实现零内核开销。\n\n## 2. 核心功能\n\n### 主要系统调用函数：\n\n- `sys_set_robust_list()`：为当前任务设置健壮 futex 列表头指针。\n- `sys_get_robust_list()`：获取指定任务（或当前任务）的健壮 futex 列表头指针。\n- `sys_futex()`：主 futex 系统调用，支持多种操作（如 `FUTEX_WAIT`、`FUTEX_WAKE`、`FUTEX_LOCK_PI` 等）。\n- `sys_futex_waitv()`：等待多个 futex 中任意一个被唤醒（尚未完整实现，仅声明）。\n\n### 辅助函数：\n\n- `do_futex()`：统一调度所有 futex 操作的核心分发函数。\n- `futex_cmd_has_timeout()`：判断指定 futex 命令是否支持超时。\n- `futex_init_timeout()`：解析并转换用户提供的超时时间（支持 `CLOCK_REALTIME` 和 `CLOCK_MONOTONIC`）。\n- `futex_parse_waitv()`：从用户空间解析 `futex_waitv` 数组，验证并初始化内核侧等待结构。\n- `futex2_setup_timeout()` / `futex2_destroy_timeout()`：为 `futex_waitv` 设置和销毁高精度定时器。\n\n### 关键数据结构（引用）：\n\n- `struct robust_list_head`：健壮 futex 列表头，由用户空间维护。\n- `struct futex_waitv`：用于 `futex_waitv` 的用户空间输入结构，包含地址、期望值和标志。\n- `struct futex_vector`：内核侧表示多个 futex 等待项的结构。\n\n## 3. 关键实现\n\n### 健壮 Futex（Robust Futex）机制\n- 用户空间为每个线程维护一个持有锁的链表（`robust_list`）。\n- 当线程异常退出时，内核遍历该链表，将所有属于该线程的 futex 标记为 `FUTEX_OWNER_DIED` 并唤醒等待者。\n- 通过 `list_op_pending` 字段处理“已加锁但尚未加入链表”的临界状态，确保清理完整性。\n- `set_robust_list` / `get_robust_list` 系统调用用于注册和查询该链表。\n\n### Futex 操作分发\n- `do_futex()` 根据操作码（`op & FUTEX_CMD_MASK`）分发到具体实现函数（如 `futex_wait`、`futex_wake`、`futex_lock_pi` 等）。\n- 支持多种 futex 类型：普通 futex、PI（优先级继承）futex、bitset futex、requeue 操作等。\n- 对于带超时的操作（如 `FUTEX_WAIT`），根据是否使用 `FUTEX_CLOCK_REALTIME` 标志决定使用绝对时间还是相对时间，并进行时间命名空间转换（`timens_ktime_to_host`）。\n\n### 多 Futex 等待（`futex_waitv`）\n- 允许线程同时等待多个 futex，任一 futex 被唤醒即返回。\n- 用户传入 `futex_waitv` 数组，每个元素包含独立的地址、期望值和标志（如私有/共享、size）。\n- 使用 `futex2_to_flags()` 将用户标志转换为内核内部标志，并验证合法性。\n- 超时使用高精度定时器（`hrtimer`），支持 `CLOCK_REALTIME` 或 `CLOCK_MONOTONIC`。\n\n### 时间处理\n- 超时参数通过 `__kernel_timespec` 传入，经 `get_timespec64()` 转换为 `timespec64`。\n- `futex_init_timeout()` 根据命令类型和时钟标志，将用户时间转换为内核 `ktime_t`，并处理绝对/相对时间语义。\n- 时间命名空间支持：非 `REALTIME` 的单调时钟时间会通过 `timens_ktime_to_host()` 转换为主机时间。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/syscalls.h>`：系统调用宏定义（如 `SYSCALL_DEFINE*`）。\n  - `<linux/time_namespace.h>`：时间命名空间支持（`timens_ktime_to_host`）。\n  - `\"futex.h\"`：futex 内部实现头文件，包含核心函数声明、标志定义和数据结构。\n\n- **内核模块依赖**：\n  - **Futex 核心逻辑**：实际的等待、唤醒、锁操作由 `futex.c` 中的函数（如 `futex_wait`、`futex_wake`）实现。\n  - **调度器与 PI 机制**：PI futex 依赖内核的优先级继承和 RT 调度支持。\n  - **高精度定时器（hrtimer）**：用于实现精确超时。\n  - **RCU 机制**：`get_robust_list` 使用 RCU 保护任务结构体访问。\n  - **Ptrace 安全检查**：`get_robust_list` 调用 `ptrace_may_access` 验证权限。\n\n## 5. 使用场景\n\n- **用户态同步原语实现**：glibc 的 `pthread_mutex`、`semaphore` 等在无竞争时完全在用户态运行，仅在需要阻塞或唤醒时调用 `futex` 系统调用。\n- **健壮互斥锁**：当持有互斥锁的线程崩溃时，其他线程可通过 `FUTEX_OWNER_DIED` 检测并恢复锁状态，避免死锁。\n- **高性能事件通知**：一个线程可等待多个事件源（如 I/O 完成、信号量、条件变量），通过 `futex_waitv` 实现“任一触发即返回”的语义。\n- **实时应用**：通过 `FUTEX_CLOCK_REALTIME` 支持基于系统实时钟的绝对超时，适用于需要与外部时间对齐的场景。\n- **容器与命名空间**：时间命名空间支持确保容器内 futex 超时行为符合容器视角的时间。",
      "similarity": 0.5703824758529663,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/futex/syscalls.c",
          "start_line": 1,
          "end_line": 83,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "",
            "#include <linux/syscalls.h>",
            "#include <linux/time_namespace.h>",
            "",
            "#include \"futex.h\"",
            "",
            "/*",
            " * Support for robust futexes: the kernel cleans up held futexes at",
            " * thread exit time.",
            " *",
            " * Implementation: user-space maintains a per-thread list of locks it",
            " * is holding. Upon do_exit(), the kernel carefully walks this list,",
            " * and marks all locks that are owned by this thread with the",
            " * FUTEX_OWNER_DIED bit, and wakes up a waiter (if any). The list is",
            " * always manipulated with the lock held, so the list is private and",
            " * per-thread. Userspace also maintains a per-thread 'list_op_pending'",
            " * field, to allow the kernel to clean up if the thread dies after",
            " * acquiring the lock, but just before it could have added itself to",
            " * the list. There can only be one such pending lock.",
            " */",
            "",
            "/**",
            " * sys_set_robust_list() - Set the robust-futex list head of a task",
            " * @head:\tpointer to the list-head",
            " * @len:\tlength of the list-head, as userspace expects",
            " */",
            "SYSCALL_DEFINE2(set_robust_list, struct robust_list_head __user *, head,",
            "\t\tsize_t, len)",
            "{",
            "\t/*",
            "\t * The kernel knows only one size for now:",
            "\t */",
            "\tif (unlikely(len != sizeof(*head)))",
            "\t\treturn -EINVAL;",
            "",
            "\tcurrent->robust_list = head;",
            "",
            "\treturn 0;",
            "}",
            "",
            "/**",
            " * sys_get_robust_list() - Get the robust-futex list head of a task",
            " * @pid:\tpid of the process [zero for current task]",
            " * @head_ptr:\tpointer to a list-head pointer, the kernel fills it in",
            " * @len_ptr:\tpointer to a length field, the kernel fills in the header size",
            " */",
            "SYSCALL_DEFINE3(get_robust_list, int, pid,",
            "\t\tstruct robust_list_head __user * __user *, head_ptr,",
            "\t\tsize_t __user *, len_ptr)",
            "{",
            "\tstruct robust_list_head __user *head;",
            "\tunsigned long ret;",
            "\tstruct task_struct *p;",
            "",
            "\trcu_read_lock();",
            "",
            "\tret = -ESRCH;",
            "\tif (!pid)",
            "\t\tp = current;",
            "\telse {",
            "\t\tp = find_task_by_vpid(pid);",
            "\t\tif (!p)",
            "\t\t\tgoto err_unlock;",
            "\t}",
            "",
            "\tret = -EPERM;",
            "\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))",
            "\t\tgoto err_unlock;",
            "",
            "\thead = p->robust_list;",
            "\trcu_read_unlock();",
            "",
            "\tif (put_user(sizeof(*head), len_ptr))",
            "\t\treturn -EFAULT;",
            "\treturn put_user(head, head_ptr);",
            "",
            "err_unlock:",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现set_robust_list和get_robust_list系统调用，用于设置/获取当前任务的robust-futex列表头，支持线程退出时自动清理持有锁的机制",
          "similarity": 0.5089616179466248
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/futex/syscalls.c",
          "start_line": 224,
          "end_line": 261,
          "content": [
            "static int futex2_setup_timeout(struct __kernel_timespec __user *timeout,",
            "\t\t\t\tclockid_t clockid, struct hrtimer_sleeper *to)",
            "{",
            "\tint flag_clkid = 0, flag_init = 0;",
            "\tstruct timespec64 ts;",
            "\tktime_t time;",
            "\tint ret;",
            "",
            "\tif (!timeout)",
            "\t\treturn 0;",
            "",
            "\tif (clockid == CLOCK_REALTIME) {",
            "\t\tflag_clkid = FLAGS_CLOCKRT;",
            "\t\tflag_init = FUTEX_CLOCK_REALTIME;",
            "\t}",
            "",
            "\tif (clockid != CLOCK_REALTIME && clockid != CLOCK_MONOTONIC)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (get_timespec64(&ts, timeout))",
            "\t\treturn -EFAULT;",
            "",
            "\t/*",
            "\t * Since there's no opcode for futex_waitv, use",
            "\t * FUTEX_WAIT_BITSET that uses absolute timeout as well",
            "\t */",
            "\tret = futex_init_timeout(FUTEX_WAIT_BITSET, flag_init, &ts, &time);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tfutex_setup_timer(&time, to, flag_clkid, 0);",
            "\treturn 0;",
            "}",
            "static inline void futex2_destroy_timeout(struct hrtimer_sleeper *to)",
            "{",
            "\thrtimer_cancel(&to->timer);",
            "\tdestroy_hrtimer_on_stack(&to->timer);",
            "}"
          ],
          "function_name": "futex2_setup_timeout, futex2_destroy_timeout",
          "description": "futex2_setup_timeout将用户态超时参数转换为内核时间戳并初始化定时器，futex2_destroy_timeout负责安全地取消和销毁定时器资源",
          "similarity": 0.42048779129981995
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/futex/syscalls.c",
          "start_line": 84,
          "end_line": 187,
          "content": [
            "long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,",
            "\t\tu32 __user *uaddr2, u32 val2, u32 val3)",
            "{",
            "\tunsigned int flags = futex_to_flags(op);",
            "\tint cmd = op & FUTEX_CMD_MASK;",
            "",
            "\tif (flags & FLAGS_CLOCKRT) {",
            "\t\tif (cmd != FUTEX_WAIT_BITSET &&",
            "\t\t    cmd != FUTEX_WAIT_REQUEUE_PI &&",
            "\t\t    cmd != FUTEX_LOCK_PI2)",
            "\t\t\treturn -ENOSYS;",
            "\t}",
            "",
            "\tswitch (cmd) {",
            "\tcase FUTEX_WAIT:",
            "\t\tval3 = FUTEX_BITSET_MATCH_ANY;",
            "\t\tfallthrough;",
            "\tcase FUTEX_WAIT_BITSET:",
            "\t\treturn futex_wait(uaddr, flags, val, timeout, val3);",
            "\tcase FUTEX_WAKE:",
            "\t\tval3 = FUTEX_BITSET_MATCH_ANY;",
            "\t\tfallthrough;",
            "\tcase FUTEX_WAKE_BITSET:",
            "\t\treturn futex_wake(uaddr, flags, val, val3);",
            "\tcase FUTEX_REQUEUE:",
            "\t\treturn futex_requeue(uaddr, flags, uaddr2, flags, val, val2, NULL, 0);",
            "\tcase FUTEX_CMP_REQUEUE:",
            "\t\treturn futex_requeue(uaddr, flags, uaddr2, flags, val, val2, &val3, 0);",
            "\tcase FUTEX_WAKE_OP:",
            "\t\treturn futex_wake_op(uaddr, flags, uaddr2, val, val2, val3);",
            "\tcase FUTEX_LOCK_PI:",
            "\t\tflags |= FLAGS_CLOCKRT;",
            "\t\tfallthrough;",
            "\tcase FUTEX_LOCK_PI2:",
            "\t\treturn futex_lock_pi(uaddr, flags, timeout, 0);",
            "\tcase FUTEX_UNLOCK_PI:",
            "\t\treturn futex_unlock_pi(uaddr, flags);",
            "\tcase FUTEX_TRYLOCK_PI:",
            "\t\treturn futex_lock_pi(uaddr, flags, NULL, 1);",
            "\tcase FUTEX_WAIT_REQUEUE_PI:",
            "\t\tval3 = FUTEX_BITSET_MATCH_ANY;",
            "\t\treturn futex_wait_requeue_pi(uaddr, flags, val, timeout, val3,",
            "\t\t\t\t\t     uaddr2);",
            "\tcase FUTEX_CMP_REQUEUE_PI:",
            "\t\treturn futex_requeue(uaddr, flags, uaddr2, flags, val, val2, &val3, 1);",
            "\t}",
            "\treturn -ENOSYS;",
            "}",
            "static __always_inline bool futex_cmd_has_timeout(u32 cmd)",
            "{",
            "\tswitch (cmd) {",
            "\tcase FUTEX_WAIT:",
            "\tcase FUTEX_LOCK_PI:",
            "\tcase FUTEX_LOCK_PI2:",
            "\tcase FUTEX_WAIT_BITSET:",
            "\tcase FUTEX_WAIT_REQUEUE_PI:",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static __always_inline int",
            "futex_init_timeout(u32 cmd, u32 op, struct timespec64 *ts, ktime_t *t)",
            "{",
            "\tif (!timespec64_valid(ts))",
            "\t\treturn -EINVAL;",
            "",
            "\t*t = timespec64_to_ktime(*ts);",
            "\tif (cmd == FUTEX_WAIT)",
            "\t\t*t = ktime_add_safe(ktime_get(), *t);",
            "\telse if (cmd != FUTEX_LOCK_PI && !(op & FUTEX_CLOCK_REALTIME))",
            "\t\t*t = timens_ktime_to_host(CLOCK_MONOTONIC, *t);",
            "\treturn 0;",
            "}",
            "static int futex_parse_waitv(struct futex_vector *futexv,",
            "\t\t\t     struct futex_waitv __user *uwaitv,",
            "\t\t\t     unsigned int nr_futexes)",
            "{",
            "\tstruct futex_waitv aux;",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < nr_futexes; i++) {",
            "\t\tunsigned int flags;",
            "",
            "\t\tif (copy_from_user(&aux, &uwaitv[i], sizeof(aux)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif ((aux.flags & ~FUTEX2_VALID_MASK) || aux.__reserved)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tflags = futex2_to_flags(aux.flags);",
            "\t\tif (!futex_flags_valid(flags))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (!futex_validate_input(flags, aux.val))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tfutexv[i].w.flags = flags;",
            "\t\tfutexv[i].w.val = aux.val;",
            "\t\tfutexv[i].w.uaddr = aux.uaddr;",
            "\t\tfutexv[i].q = futex_q_init;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "do_futex, futex_cmd_has_timeout, futex_init_timeout, futex_parse_waitv",
          "description": "do_futex处理各类futex操作命令，包含超时检测逻辑和waitv参数解析，通过条件判断分发到相应子函数实现不同操作",
          "similarity": 0.41896384954452515
        }
      ]
    },
    {
      "source_file": "kernel/static_call_inline.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:29:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `static_call_inline.c`\n\n---\n\n# static_call_inline.c 技术文档\n\n## 1. 文件概述\n\n`static_call_inline.c` 是 Linux 内核中实现 **静态调用（Static Call）** 机制的核心文件之一。静态调用是一种运行时可动态更新的函数调用优化技术，它在编译时将函数调用点内联为对跳板（trampoline）的直接跳转，而在运行时可通过 `__static_call_update()` 动态修改所有调用点，使其跳转到新的目标函数，从而避免传统函数指针调用的间接开销。该机制常用于性能敏感路径（如调度、RCU、tracepoint 等），同时支持模块热插拔和初始化阶段的特殊处理。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `static_call_force_reinit(void)`  \n  强制重新初始化静态调用机制，用于调试或特殊场景，必须在 `early_initcall()` 之前调用。\n\n- `__static_call_update(struct static_call_key *key, void *tramp, void *func)`  \n  核心更新函数：将指定 `key` 对应的所有静态调用点更新为调用 `func`，并更新跳板 `tramp`。支持内核和模块中的调用点。\n\n- `__static_call_init(struct module *mod, struct static_call_site *start, struct static_call_site *stop)`  \n  初始化静态调用站点，对站点按 `key` 排序，并建立 `key` 到站点的映射关系，同时执行首次 `arch_static_call_transform`。\n\n- `__static_call_text_reserved(...)`  \n  检查指定代码区间是否与活跃的静态调用站点冲突，用于内存热插拔或代码修改前的安全校验。\n\n### 主要数据结构\n\n- `struct static_call_site`  \n  描述一个静态调用点的位置（`addr`）和关联的 `key`（带标志位）。\n\n- `struct static_call_key`  \n  静态调用的“键”，用于将多个调用点分组。包含当前函数指针 `func` 和类型/模块信息。\n\n- `struct static_call_mod`  \n  用于模块场景下，将模块与该模块中属于某 `key` 的调用点列表关联。\n\n- 全局符号：\n  - `__start_static_call_sites[]` / `__stop_static_call_sites[]`：内核镜像中所有静态调用点的链接器生成数组。\n  - `__start_static_call_tramp_key[]` / `__stop_static_call_tramp_key[]`：跳板与 key 的映射。\n\n### 辅助函数与宏\n\n- `static_call_addr(site)`：计算调用点的实际地址（处理重定位）。\n- `static_call_key(site)`：从站点中提取 `static_call_key*`（忽略标志位）。\n- `static_call_is_init(site)` / `static_call_is_tail(site)`：检查站点是否位于 `__init` 段或是否为尾调用。\n- `static_call_sort_entries()`：对站点按 `key` 排序，便于批量处理。\n- `static_call_key_has_mods()` / `static_call_key_sites()`：判断 key 是否关联模块或直接站点。\n\n## 3. 关键实现\n\n### 地址重定位处理\n由于静态调用站点在编译时使用相对地址存储，`static_call_addr()` 和 `__static_call_key()` 通过 `(long)field + (long)&field` 的方式计算出运行时绝对地址，这是处理位置无关代码（PIC）和内核重定位的关键技巧。\n\n### 站点组织与模块支持\n- **内核（vmlinux）场景**：为节省内存和避免早期内存分配，将首个站点指针直接编码到 `key->type` 的低有效位中（通过 `| 1` 标记）。\n- **模块场景**：使用 `static_call_mod` 链表管理不同模块中属于同一 `key` 的站点，支持模块加载/卸载时的动态注册。\n\n### 初始化与更新流程\n1. **初始化**（`__static_call_init`）：\n   - 对站点按 `key` 排序。\n   - 标记位于 `__init` 段的站点（后续更新可跳过）。\n   - 建立 `key` 到站点的映射。\n   - 调用架构相关 `arch_static_call_transform` 执行首次转换（通常设为跳板）。\n\n2. **更新**（`__static_call_update`）：\n   - 更新 `key->func`。\n   - 更新跳板 `tramp` 指向新函数。\n   - 遍历所有关联站点（包括模块），调用 `arch_static_call_transform` 修改调用点指令（如 x86 的 `jmp` 目标）。\n   - 跳过 `__init` 段中已初始化的站点（因不会被执行）。\n\n### 安全与并发控制\n- 使用 `cpus_read_lock()` 防止 CPU 热插拔期间的并发问题。\n- 使用 `static_call_mutex` 保护 `key` 和站点数据结构的修改。\n- 通过 `kernel_text_address()` 验证调用点是否在可执行内核文本段，避免修改无效地址。\n\n## 4. 依赖关系\n\n- **架构依赖**：依赖 `asm/sections.h` 和 `arch_static_call_transform()`（由各架构实现，如 x86、ARM64）。\n- **内核子系统**：\n  - `linux/module.h`：模块加载/卸载时的静态调用站点管理。\n  - `linux/cpu.h` / `linux/smp.h`：CPU 热插拔和并发控制。\n  - `linux/sort.h`：站点排序。\n  - `linux/slab.h`：模块场景下的动态内存分配。\n- **链接器脚本**：依赖链接器生成的 `__start/stop_static_call_sites` 等符号，这些在 `vmlinux.lds` 中定义。\n\n## 5. 使用场景\n\n- **内核核心优化**：在调度器、RCU、中断处理等高频路径中替代函数指针，减少间接调用开销。\n- **动态追踪（ftrace）**：作为 tracepoint 或 kprobe 的底层机制，实现零开销探针。\n- **模块热插拔**：模块加载时注册其静态调用站点，卸载时自动清理，确保调用点始终有效。\n- **初始化优化**：`__init` 段的调用点在初始化完成后可被安全忽略，减少运行时开销。\n- **安全代码修改**：在 livepatch 或内核热补丁中，安全地替换函数实现而不影响运行中的调用。",
      "similarity": 0.5677705407142639,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 23,
          "end_line": 176,
          "content": [
            "void static_call_force_reinit(void)",
            "{",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\treturn;",
            "",
            "\tstatic_call_initialized++;",
            "}",
            "static void static_call_lock(void)",
            "{",
            "\tmutex_lock(&static_call_mutex);",
            "}",
            "static void static_call_unlock(void)",
            "{",
            "\tmutex_unlock(&static_call_mutex);",
            "}",
            "static inline unsigned long __static_call_key(const struct static_call_site *site)",
            "{",
            "\treturn (long)site->key + (long)&site->key;",
            "}",
            "static inline bool static_call_is_init(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;",
            "}",
            "static inline bool static_call_is_tail(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;",
            "}",
            "static inline void static_call_set_init(struct static_call_site *site)",
            "{",
            "\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -",
            "\t\t    (long)&site->key;",
            "}",
            "static int static_call_site_cmp(const void *_a, const void *_b)",
            "{",
            "\tconst struct static_call_site *a = _a;",
            "\tconst struct static_call_site *b = _b;",
            "\tconst struct static_call_key *key_a = static_call_key(a);",
            "\tconst struct static_call_key *key_b = static_call_key(b);",
            "",
            "\tif (key_a < key_b)",
            "\t\treturn -1;",
            "",
            "\tif (key_a > key_b)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static void static_call_site_swap(void *_a, void *_b, int size)",
            "{",
            "\tlong delta = (unsigned long)_a - (unsigned long)_b;",
            "\tstruct static_call_site *a = _a;",
            "\tstruct static_call_site *b = _b;",
            "\tstruct static_call_site tmp = *a;",
            "",
            "\ta->addr = b->addr  - delta;",
            "\ta->key  = b->key   - delta;",
            "",
            "\tb->addr = tmp.addr + delta;",
            "\tb->key  = tmp.key  + delta;",
            "}",
            "static inline void static_call_sort_entries(struct static_call_site *start,",
            "\t\t\t\t\t    struct static_call_site *stop)",
            "{",
            "\tsort(start, stop - start, sizeof(struct static_call_site),",
            "\t     static_call_site_cmp, static_call_site_swap);",
            "}",
            "static inline bool static_call_key_has_mods(struct static_call_key *key)",
            "{",
            "\treturn !(key->type & 1);",
            "}",
            "void __static_call_update(struct static_call_key *key, void *tramp, void *func)",
            "{",
            "\tstruct static_call_site *site, *stop;",
            "\tstruct static_call_mod *site_mod, first;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tif (key->func == func)",
            "\t\tgoto done;",
            "",
            "\tkey->func = func;",
            "",
            "\tarch_static_call_transform(NULL, tramp, func, false);",
            "",
            "\t/*",
            "\t * If uninitialized, we'll not update the callsites, but they still",
            "\t * point to the trampoline and we just patched that.",
            "\t */",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\tgoto done;",
            "",
            "\tfirst = (struct static_call_mod){",
            "\t\t.next = static_call_key_next(key),",
            "\t\t.mod = NULL,",
            "\t\t.sites = static_call_key_sites(key),",
            "\t};",
            "",
            "\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {",
            "\t\tbool init = system_state < SYSTEM_RUNNING;",
            "\t\tstruct module *mod = site_mod->mod;",
            "",
            "\t\tif (!site_mod->sites) {",
            "\t\t\t/*",
            "\t\t\t * This can happen if the static call key is defined in",
            "\t\t\t * a module which doesn't use it.",
            "\t\t\t *",
            "\t\t\t * It also happens in the has_mods case, where the",
            "\t\t\t * 'first' entry has no sites associated with it.",
            "\t\t\t */",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tstop = __stop_static_call_sites;",
            "",
            "\t\tif (mod) {",
            "#ifdef CONFIG_MODULES",
            "\t\t\tstop = mod->static_call_sites +",
            "\t\t\t       mod->num_static_call_sites;",
            "\t\t\tinit = mod->state == MODULE_STATE_COMING;",
            "#endif",
            "\t\t}",
            "",
            "\t\tfor (site = site_mod->sites;",
            "\t\t     site < stop && static_call_key(site) == key; site++) {",
            "\t\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\t\tif (!init && static_call_is_init(site))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * This skips patching built-in __exit, which",
            "\t\t\t\t * is part of init_section_contains() but is",
            "\t\t\t\t * not part of kernel_text_address().",
            "\t\t\t\t *",
            "\t\t\t\t * Skipping built-in __exit is fine since it",
            "\t\t\t\t * will never be executed.",
            "\t\t\t\t */",
            "\t\t\t\tWARN_ONCE(!static_call_is_init(site),",
            "\t\t\t\t\t  \"can't patch static call site at %pS\",",
            "\t\t\t\t\t  site_addr);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tarch_static_call_transform(site_addr, NULL, func,",
            "\t\t\t\t\t\t   static_call_is_tail(site));",
            "\t\t}",
            "\t}",
            "",
            "done:",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "static_call_force_reinit, static_call_lock, static_call_unlock, __static_call_key, static_call_is_init, static_call_is_tail, static_call_set_init, static_call_site_cmp, static_call_site_swap, static_call_sort_entries, static_call_key_has_mods, __static_call_update",
          "description": "实现静态调用的互斥锁控制、键值计算、站点排序及更新逻辑，包含地址冲突检测和模块间调用关系维护功能。",
          "similarity": 0.5228919386863708
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/init.h>",
            "#include <linux/static_call.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/cpu.h>",
            "#include <linux/processor.h>",
            "#include <asm/sections.h>",
            "",
            "extern struct static_call_site __start_static_call_sites[],",
            "\t\t\t       __stop_static_call_sites[];",
            "extern struct static_call_tramp_key __start_static_call_tramp_key[],",
            "\t\t\t\t    __stop_static_call_tramp_key[];",
            "",
            "int static_call_initialized;",
            "",
            "/*",
            " * Must be called before early_initcall() to be effective.",
            " */"
          ],
          "function_name": null,
          "description": "声明静态调用相关的全局变量和外部符号，定义静态调用初始化标志位，为后续静态调用站点管理和地址转换提供基础结构。",
          "similarity": 0.5210756063461304
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 453,
          "end_line": 552,
          "content": [
            "static int static_call_module_notify(struct notifier_block *nb,",
            "\t\t\t\t     unsigned long val, void *data)",
            "{",
            "\tstruct module *mod = data;",
            "\tint ret = 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tswitch (val) {",
            "\tcase MODULE_STATE_COMING:",
            "\t\tret = static_call_add_module(mod);",
            "\t\tif (ret) {",
            "\t\t\tpr_warn(\"Failed to allocate memory for static calls\\n\");",
            "\t\t\tstatic_call_del_module(mod);",
            "\t\t}",
            "\t\tbreak;",
            "\tcase MODULE_STATE_GOING:",
            "\t\tstatic_call_del_module(mod);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\treturn notifier_from_errno(ret);",
            "}",
            "int klp_static_call_register(struct module *mod)",
            "{",
            "\tint ret;",
            "",
            "\tret = static_call_module_notify(&static_call_module_nb, MODULE_STATE_COMING, mod);",
            "\treturn notifier_to_errno(ret);",
            "}",
            "static inline int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\treturn 0;",
            "}",
            "int static_call_text_reserved(void *start, void *end)",
            "{",
            "\tbool init = system_state < SYSTEM_RUNNING;",
            "\tint ret = __static_call_text_reserved(__start_static_call_sites,",
            "\t\t\t__stop_static_call_sites, start, end, init);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn __static_call_mod_text_reserved(start, end);",
            "}",
            "int __init static_call_init(void)",
            "{",
            "\tint ret;",
            "",
            "\t/* See static_call_force_reinit(). */",
            "\tif (static_call_initialized == 1)",
            "\t\treturn 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "\tret = __static_call_init(NULL, __start_static_call_sites,",
            "\t\t\t\t __stop_static_call_sites);",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate memory for static_call!\\n\");",
            "\t\tBUG();",
            "\t}",
            "",
            "#ifdef CONFIG_MODULES",
            "\tif (!static_call_initialized)",
            "\t\tregister_module_notifier(&static_call_module_nb);",
            "#endif",
            "",
            "\tstatic_call_initialized = 1;",
            "\treturn 0;",
            "}",
            "static int func_a(int x)",
            "{",
            "\treturn x+1;",
            "}",
            "static int func_b(int x)",
            "{",
            "\treturn x+2;",
            "}",
            "static int __init test_static_call_init(void)",
            "{",
            "      int i;",
            "",
            "      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {",
            "\t      struct static_call_data *scd = &static_call_data[i];",
            "",
            "              if (scd->func)",
            "                      static_call_update(sc_selftest, scd->func);",
            "",
            "              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);",
            "      }",
            "",
            "      return 0;",
            "}"
          ],
          "function_name": "static_call_module_notify, klp_static_call_register, __static_call_mod_text_reserved, static_call_text_reserved, static_call_init, func_a, func_b, test_static_call_init",
          "description": "实现模块状态变更通知机制，完成静态调用系统的初始化注册，包含测试函数用于验证静态调用逻辑的正确性。",
          "similarity": 0.5153239965438843
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 347,
          "end_line": 449,
          "content": [
            "static unsigned long tramp_key_lookup(unsigned long addr)",
            "{",
            "\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *tramp_key;",
            "",
            "\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {",
            "\t\tunsigned long tramp;",
            "",
            "\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;",
            "\t\tif (tramp == addr)",
            "\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int static_call_add_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = start + mod->num_static_call_sites;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn 0;",
            "#endif",
            "",
            "\tfor (site = start; site != stop; site++) {",
            "\t\tunsigned long s_key = __static_call_key(site);",
            "\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;",
            "\t\tunsigned long key;",
            "",
            "\t\t/*",
            "\t\t * Is the key is exported, 'addr' points to the key, which",
            "\t\t * means modules are allowed to call static_call_update() on",
            "\t\t * it.",
            "\t\t *",
            "\t\t * Otherwise, the key isn't exported, and 'addr' points to the",
            "\t\t * trampoline so we need to lookup the key.",
            "\t\t *",
            "\t\t * We go through this dance to prevent crazy modules from",
            "\t\t * abusing sensitive static calls.",
            "\t\t */",
            "\t\tif (!kernel_text_address(addr))",
            "\t\t\tcontinue;",
            "",
            "\t\tkey = tramp_key_lookup(addr);",
            "\t\tif (!key) {",
            "\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",",
            "\t\t\t\tstatic_call_addr(site));",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;",
            "\t\tsite->key = key - (long)&site->key;",
            "\t}",
            "",
            "\treturn __static_call_init(mod, start, stop);",
            "}",
            "static void static_call_del_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = mod->static_call_sites +",
            "\t\t\t\t\tmod->num_static_call_sites;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod, **prev;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn;",
            "#endif",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tkey = static_call_key(site);",
            "",
            "\t\t/*",
            "\t\t * If the key was not updated due to a memory allocation",
            "\t\t * failure in __static_call_init() then treating key::sites",
            "\t\t * as key::mods in the code below would cause random memory",
            "\t\t * access and #GP. In that case all subsequent sites have",
            "\t\t * not been touched either, so stop iterating.",
            "\t\t */",
            "\t\tif (!static_call_key_has_mods(key))",
            "\t\t\tbreak;",
            "",
            "\t\tif (key == prev_key)",
            "\t\t\tcontinue;",
            "",
            "\t\tprev_key = key;",
            "",
            "\t\tfor (prev = &key->mods, site_mod = key->mods;",
            "\t\t     site_mod && site_mod->mod != mod;",
            "\t\t     prev = &site_mod->next, site_mod = site_mod->next)",
            "\t\t\t;",
            "",
            "\t\tif (!site_mod)",
            "\t\t\tcontinue;",
            "",
            "\t\t*prev = site_mod->next;",
            "\t\tkfree(site_mod);",
            "\t}",
            "}"
          ],
          "function_name": "tramp_key_lookup, static_call_add_module, static_call_del_module",
          "description": "处理模块动态加载/卸载时的静态调用更新，通过键查找机制确保跨模块调用正确性，并维护静态调用站点的模块绑定关系。",
          "similarity": 0.49624964594841003
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 220,
          "end_line": 340,
          "content": [
            "static int __static_call_init(struct module *mod,",
            "\t\t\t      struct static_call_site *start,",
            "\t\t\t      struct static_call_site *stop)",
            "{",
            "\tstruct static_call_site *site;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod;",
            "",
            "\tif (start == stop)",
            "\t\treturn 0;",
            "",
            "\tstatic_call_sort_entries(start, stop);",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||",
            "\t\t    (!mod && init_section_contains(site_addr, 1)))",
            "\t\t\tstatic_call_set_init(site);",
            "",
            "\t\tkey = static_call_key(site);",
            "\t\tif (key != prev_key) {",
            "\t\t\tprev_key = key;",
            "",
            "\t\t\t/*",
            "\t\t\t * For vmlinux (!mod) avoid the allocation by storing",
            "\t\t\t * the sites pointer in the key itself. Also see",
            "\t\t\t * __static_call_update()'s @first.",
            "\t\t\t *",
            "\t\t\t * This allows architectures (eg. x86) to call",
            "\t\t\t * static_call_init() before memory allocation works.",
            "\t\t\t */",
            "\t\t\tif (!mod) {",
            "\t\t\t\tkey->sites = site;",
            "\t\t\t\tkey->type |= 1;",
            "\t\t\t\tgoto do_transform;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\tif (!site_mod)",
            "\t\t\t\treturn -ENOMEM;",
            "",
            "\t\t\t/*",
            "\t\t\t * When the key has a direct sites pointer, extract",
            "\t\t\t * that into an explicit struct static_call_mod, so we",
            "\t\t\t * can have a list of modules.",
            "\t\t\t */",
            "\t\t\tif (static_call_key_sites(key)) {",
            "\t\t\t\tsite_mod->mod = NULL;",
            "\t\t\t\tsite_mod->next = NULL;",
            "\t\t\t\tsite_mod->sites = static_call_key_sites(key);",
            "",
            "\t\t\t\tkey->mods = site_mod;",
            "",
            "\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\t\tif (!site_mod)",
            "\t\t\t\t\treturn -ENOMEM;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod->mod = mod;",
            "\t\t\tsite_mod->sites = site;",
            "\t\t\tsite_mod->next = static_call_key_next(key);",
            "\t\t\tkey->mods = site_mod;",
            "\t\t}",
            "",
            "do_transform:",
            "\t\tarch_static_call_transform(site_addr, NULL, key->func,",
            "\t\t\t\tstatic_call_is_tail(site));",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int addr_conflict(struct static_call_site *site, void *start, void *end)",
            "{",
            "\tunsigned long addr = (unsigned long)static_call_addr(site);",
            "",
            "\tif (addr <= (unsigned long)end &&",
            "\t    addr + CALL_INSN_SIZE > (unsigned long)start)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_text_reserved(struct static_call_site *iter_start,",
            "\t\t\t\t       struct static_call_site *iter_stop,",
            "\t\t\t\t       void *start, void *end, bool init)",
            "{",
            "\tstruct static_call_site *iter = iter_start;",
            "",
            "\twhile (iter < iter_stop) {",
            "\t\tif (init || !static_call_is_init(iter)) {",
            "\t\t\tif (addr_conflict(iter, start, end))",
            "\t\t\t\treturn 1;",
            "\t\t}",
            "\t\titer++;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\tstruct module *mod;",
            "\tint ret;",
            "",
            "\tpreempt_disable();",
            "\tmod = __module_text_address((unsigned long)start);",
            "\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);",
            "\tif (!try_module_get(mod))",
            "\t\tmod = NULL;",
            "\tpreempt_enable();",
            "",
            "\tif (!mod)",
            "\t\treturn 0;",
            "",
            "\tret = __static_call_text_reserved(mod->static_call_sites,",
            "\t\t\tmod->static_call_sites + mod->num_static_call_sites,",
            "\t\t\tstart, end, mod->state == MODULE_STATE_COMING);",
            "",
            "\tmodule_put(mod);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__static_call_init, addr_conflict, __static_call_text_reserved, __static_call_mod_text_reserved",
          "description": "执行静态调用初始化流程，分配模块关联结构体并进行地址转换，实现文本区域预留检查以避免内存覆盖。",
          "similarity": 0.48451945185661316
        }
      ]
    },
    {
      "source_file": "kernel/sched/syscalls.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:19:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\syscalls.c`\n\n---\n\n# `sched/syscalls.c` 技术文档\n\n## 1. 文件概述\n\n`sched/syscalls.c` 是 Linux 内核调度子系统的核心源文件之一，主要负责实现与调度相关的系统调用接口和优先级管理逻辑。该文件封装了任务优先级计算、nice 值设置、CPU 空闲状态判断等关键功能，为用户空间提供 `nice()` 等系统调用的内核支持，并为调度器内部模块提供优先级操作原语。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `__normal_prio()`：根据调度策略（SCHED_NORMAL/SCHED_BATCH/SCHED_IDLE、SCHED_FIFO/SCHED_RR、SCHED_DEADLINE）计算任务的“正常”优先级。\n- `normal_prio()`：基于任务当前策略、实时优先级和静态 nice 值计算其正常优先级。\n- `effective_prio()`：计算任务当前实际生效的调度优先级，考虑 RT 继承或提升。\n- `set_user_nice()`：安全地修改指定任务的 nice 值，更新其静态优先级和调度权重，并触发调度器重评估。\n- `is_nice_reduction()` / `can_nice()`：检查任务是否具备降低 nice 值（即提高优先级）的权限。\n- `sys_nice()`：实现 `nice(2)` 系统调用，允许当前进程调整自身优先级。\n- `task_prio()`：返回任务在 `/proc` 中对外暴露的用户可见优先级值。\n- `idle_cpu()` / `available_idle_cpu()`：判断指定 CPU 是否处于空闲状态。\n- `idle_task()`：获取指定 CPU 的 idle 任务结构体。\n- `update_other_load_avgs()`（SMP）：更新除 CFS 外其他调度类（RT、DL、IRQ）的负载平均值。\n- `effective_cpu_util()`（SMP）：计算 CPU 的有效利用率，用于频率调节（如 CPUFreq）。\n\n### 关键数据结构\n- 无独立定义的数据结构，主要操作 `struct task_struct` 和 `struct rq`（运行队列）。\n\n## 3. 关键实现\n\n### 优先级计算模型\n- **优先级映射**：\n  - 用户态 nice 值范围 `[-20, 19]` 映射到内核静态优先级 `[100, 139]`（通过 `NICE_TO_PRIO`）。\n  - 实时任务（RT/DL）使用 `[0, 99]` 的高优先级范围（`MAX_RT_PRIO = 100`）。\n  - `task_prio()` 返回值将内核优先级转换为用户可见格式：普通任务为 `[0,39]`，RT 任务为 `[-2,-100]`，DL 任务为 `-101`。\n- **有效优先级**：`effective_prio()` 区分“正常优先级”与“被提升的优先级”。若任务当前优先级为 RT/DL（即 `rt_or_dl_prio(p->prio)` 为真），则保留提升后的值；否则使用 `normal_prio`。\n\n### Nice 值修改安全机制\n- `set_user_nice()` 在修改 nice 值前：\n  1. 获取任务所在 CPU 的运行队列锁（`task_rq_lock`），防止并发调度。\n  2. 对 RT/DL 任务仅更新 `static_prio`（不影响调度行为）。\n  3. 对普通任务，先从运行队列中移除（若已入队或正在运行），更新 `static_prio` 和负载权重（`set_load_weight`），重新计算 `prio`，再重新入队。\n  4. 调用调度类的 `prio_changed` 回调，通知调度器优先级变更。\n\n### 权限控制\n- `can_nice()` 结合资源限制（`RLIMIT_NICE`）和特权（`CAP_SYS_NICE`）判断是否允许降低 nice 值（提高优先级）。\n- `nice_to_rlimit()` 将 nice 值 `[19,-20]` 转换为 rlimit 格式 `[1,40]` 以匹配 `RLIMIT_NICE` 的语义。\n\n### CPU 空闲判断\n- `idle_cpu()` 检查：\n  - 当前运行任务是否为 idle 任务。\n  - 运行队列中无其他可运行任务（`nr_running == 0`）。\n  - （SMP）无待处理的远程唤醒（`ttwu_pending == 0`）。\n- `available_idle_cpu()` 额外检查虚拟化场景下 CPU 是否被抢占（`vcpu_is_preempted`）。\n\n### 负载与利用率计算（SMP）\n- `update_other_load_avgs()` 周期性更新 RT、DL、IRQ 和硬件压力的负载平均值。\n- `effective_cpu_util()` 聚合 CFS、RT、DL、IRQ 的利用率，并考虑 DL 带宽预留，输出用于 CPU 频率调节的有效利用率。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/sched.h>`：核心调度数据结构和 API。\n  - `<linux/cpuset.h>`：CPU 亲和性相关（间接影响调度）。\n  - `\"sched.h\"`（本地）：调度器内部实现细节。\n  - `\"autogroup.h\"`：自动任务分组支持。\n- **调度类依赖**：\n  - 调用各调度类（CFS、RT、DL）的回调函数（如 `prio_changed`、`enqueue_task` 等）。\n- **安全模块**：调用 LSM 钩子 `security_task_setnice()`。\n- **架构相关**：\n  - `arch_scale_cpu_capacity()` / `arch_scale_hw_pressure()`：架构特定的 CPU 容量和硬件压力缩放。\n  - `__ARCH_WANT_SYS_NICE`：控制 `sys_nice` 是否编译进内核。\n\n## 5. 使用场景\n\n- **系统调用处理**：为 `nice(2)` 系统调用提供内核实现，允许用户进程动态调整自身优先级。\n- **调度器内部操作**：\n  - 在 `fork()`、`sched_setscheduler()` 等操作中计算任务优先级。\n  - 调度类在任务入队/出队时更新优先级和负载。\n- **资源监控与管理**：\n  - `/proc/[pid]/stat` 中的优先级字段通过 `task_prio()` 获取。\n  - 负载均衡器和 CPUFreq 驱动使用 `effective_cpu_util()` 获取 CPU 利用率。\n- **空闲检测**：\n  - 负载均衡、任务迁移、节能策略（如 cpuidle）依赖 `idle_cpu()` 和 `available_idle_cpu()` 判断 CPU 状态。\n- **权限控制**：在设置优先级时执行安全检查，防止非特权进程提升调度优先级。",
      "similarity": 0.5607544183731079,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/syscalls.c",
          "start_line": 1,
          "end_line": 18,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  kernel/sched/syscalls.c",
            " *",
            " *  Core kernel scheduler syscalls related code",
            " *",
            " *  Copyright (C) 1991-2002  Linus Torvalds",
            " *  Copyright (C) 1998-2024  Ingo Molnar, Red Hat",
            " */",
            "#include <linux/sched.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/sched/debug.h>",
            "",
            "#include <uapi/linux/sched/types.h>",
            "",
            "#include \"sched.h\"",
            "#include \"autogroup.h\"",
            ""
          ],
          "function_name": null,
          "description": "声明调度器系统调用相关头文件，包含调度策略、CPU集、调试信息及内核调度器和自动分组模块的实现依赖",
          "similarity": 0.5438331961631775
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/syscalls.c",
          "start_line": 226,
          "end_line": 330,
          "content": [
            "int available_idle_cpu(int cpu)",
            "{",
            "\tif (!idle_cpu(cpu))",
            "\t\treturn 0;",
            "",
            "\tif (vcpu_is_preempted(cpu))",
            "\t\treturn 0;",
            "",
            "\treturn 1;",
            "}",
            "int sched_core_idle_cpu(int cpu)",
            "{",
            "\tstruct rq *rq = cpu_rq(cpu);",
            "",
            "\tif (sched_core_enabled(rq) && rq->curr == rq->idle)",
            "\t\treturn 1;",
            "",
            "\treturn idle_cpu(cpu);",
            "}",
            "bool update_other_load_avgs(struct rq *rq)",
            "{",
            "\tu64 now = rq_clock_pelt(rq);",
            "\tconst struct sched_class *curr_class = rq->curr->sched_class;",
            "\tunsigned long hw_pressure = arch_scale_hw_pressure(cpu_of(rq));",
            "",
            "\tlockdep_assert_rq_held(rq);",
            "",
            "\treturn update_rt_rq_load_avg(now, rq, curr_class == &rt_sched_class) |",
            "\t\tupdate_dl_rq_load_avg(now, rq, curr_class == &dl_sched_class) |",
            "\t\tupdate_hw_load_avg(now, rq, hw_pressure) |",
            "\t\tupdate_irq_load_avg(rq, 0);",
            "}",
            "unsigned long effective_cpu_util(int cpu, unsigned long util_cfs,",
            "\t\t\t\t unsigned long *min,",
            "\t\t\t\t unsigned long *max)",
            "{",
            "\tunsigned long util, irq, scale;",
            "\tstruct rq *rq = cpu_rq(cpu);",
            "",
            "\tscale = arch_scale_cpu_capacity(cpu);",
            "",
            "\t/*",
            "\t * Early check to see if IRQ/steal time saturates the CPU, can be",
            "\t * because of inaccuracies in how we track these -- see",
            "\t * update_irq_load_avg().",
            "\t */",
            "\tirq = cpu_util_irq(rq);",
            "\tif (unlikely(irq >= scale)) {",
            "\t\tif (min)",
            "\t\t\t*min = scale;",
            "\t\tif (max)",
            "\t\t\t*max = scale;",
            "\t\treturn scale;",
            "\t}",
            "",
            "\tif (min) {",
            "\t\t/*",
            "\t\t * The minimum utilization returns the highest level between:",
            "\t\t * - the computed DL bandwidth needed with the IRQ pressure which",
            "\t\t *   steals time to the deadline task.",
            "\t\t * - The minimum performance requirement for CFS and/or RT.",
            "\t\t */",
            "\t\t*min = max(irq + cpu_bw_dl(rq), uclamp_rq_get(rq, UCLAMP_MIN));",
            "",
            "\t\t/*",
            "\t\t * When an RT task is runnable and uclamp is not used, we must",
            "\t\t * ensure that the task will run at maximum compute capacity.",
            "\t\t */",
            "\t\tif (!uclamp_is_used() && rt_rq_is_runnable(&rq->rt))",
            "\t\t\t*min = max(*min, scale);",
            "\t}",
            "",
            "\t/*",
            "\t * Because the time spend on RT/DL tasks is visible as 'lost' time to",
            "\t * CFS tasks and we use the same metric to track the effective",
            "\t * utilization (PELT windows are synchronized) we can directly add them",
            "\t * to obtain the CPU's actual utilization.",
            "\t */",
            "\tutil = util_cfs + cpu_util_rt(rq);",
            "\tutil += cpu_util_dl(rq);",
            "",
            "\t/*",
            "\t * The maximum hint is a soft bandwidth requirement, which can be lower",
            "\t * than the actual utilization because of uclamp_max requirements.",
            "\t */",
            "\tif (max)",
            "\t\t*max = min(scale, uclamp_rq_get(rq, UCLAMP_MAX));",
            "",
            "\tif (util >= scale)",
            "\t\treturn scale;",
            "",
            "\t/*",
            "\t * There is still idle time; further improve the number by using the",
            "\t * irq metric. Because IRQ/steal time is hidden from the task clock we",
            "\t * need to scale the task numbers:",
            "\t *",
            "\t *              max - irq",
            "\t *   U' = irq + --------- * U",
            "\t *                 max",
            "\t */",
            "\tutil = scale_irq_capacity(util, irq, scale);",
            "\tutil += irq;",
            "",
            "\treturn min(scale, util);",
            "}"
          ],
          "function_name": "available_idle_cpu, sched_core_idle_cpu, update_other_load_avgs, effective_cpu_util",
          "description": "提供CPU空闲检测、负载平均值更新及有效CPU利用率计算接口，整合CFS、RT和DL任务的利用率统计与中断/窃取时间处理",
          "similarity": 0.518386960029602
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/sched/syscalls.c",
          "start_line": 889,
          "end_line": 1002,
          "content": [
            "static int _sched_setscheduler(struct task_struct *p, int policy,",
            "\t\t\t       const struct sched_param *param, bool check)",
            "{",
            "\tstruct sched_attr attr = {",
            "\t\t.sched_policy   = policy,",
            "\t\t.sched_priority = param->sched_priority,",
            "\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),",
            "\t};",
            "",
            "\tif (p->se.custom_slice)",
            "\t\tattr.sched_runtime = p->se.slice;",
            "",
            "\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */",
            "\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {",
            "\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;",
            "\t\tpolicy &= ~SCHED_RESET_ON_FORK;",
            "\t\tattr.sched_policy = policy;",
            "\t}",
            "",
            "\treturn __sched_setscheduler(p, &attr, check, true);",
            "}",
            "int sched_setscheduler(struct task_struct *p, int policy,",
            "\t\t       const struct sched_param *param)",
            "{",
            "\treturn _sched_setscheduler(p, policy, param, true);",
            "}",
            "int sched_setattr(struct task_struct *p, const struct sched_attr *attr)",
            "{",
            "\treturn __sched_setscheduler(p, attr, true, true);",
            "}",
            "int sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)",
            "{",
            "\treturn __sched_setscheduler(p, attr, false, true);",
            "}",
            "int sched_setscheduler_nocheck(struct task_struct *p, int policy,",
            "\t\t\t       const struct sched_param *param)",
            "{",
            "\treturn _sched_setscheduler(p, policy, param, false);",
            "}",
            "void sched_set_fifo(struct task_struct *p)",
            "{",
            "\tstruct sched_param sp = { .sched_priority = MAX_RT_PRIO / 2 };",
            "\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);",
            "}",
            "void sched_set_fifo_low(struct task_struct *p)",
            "{",
            "\tstruct sched_param sp = { .sched_priority = 1 };",
            "\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);",
            "}",
            "void sched_set_normal(struct task_struct *p, int nice)",
            "{",
            "\tstruct sched_attr attr = {",
            "\t\t.sched_policy = SCHED_NORMAL,",
            "\t\t.sched_nice = nice,",
            "\t};",
            "\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);",
            "}",
            "static int",
            "do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)",
            "{",
            "\tstruct sched_param lparam;",
            "",
            "\tif (!param || pid < 0)",
            "\t\treturn -EINVAL;",
            "\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))",
            "\t\treturn -EFAULT;",
            "",
            "\tCLASS(find_get_task, p)(pid);",
            "\tif (!p)",
            "\t\treturn -ESRCH;",
            "",
            "\treturn sched_setscheduler(p, policy, &lparam);",
            "}",
            "static int sched_copy_attr(struct sched_attr __user *uattr, struct sched_attr *attr)",
            "{",
            "\tu32 size;",
            "\tint ret;",
            "",
            "\t/* Zero the full structure, so that a short copy will be nice: */",
            "\tmemset(attr, 0, sizeof(*attr));",
            "",
            "\tret = get_user(size, &uattr->size);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* ABI compatibility quirk: */",
            "\tif (!size)",
            "\t\tsize = SCHED_ATTR_SIZE_VER0;",
            "\tif (size < SCHED_ATTR_SIZE_VER0 || size > PAGE_SIZE)",
            "\t\tgoto err_size;",
            "",
            "\tret = copy_struct_from_user(attr, sizeof(*attr), uattr, size);",
            "\tif (ret) {",
            "\t\tif (ret == -E2BIG)",
            "\t\t\tgoto err_size;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tif ((attr->sched_flags & SCHED_FLAG_UTIL_CLAMP) &&",
            "\t    size < SCHED_ATTR_SIZE_VER1)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * XXX: Do we want to be lenient like existing syscalls; or do we want",
            "\t * to be strict and return an error on out-of-bounds values?",
            "\t */",
            "\tattr->sched_nice = clamp(attr->sched_nice, MIN_NICE, MAX_NICE);",
            "",
            "\treturn 0;",
            "",
            "err_size:",
            "\tput_user(sizeof(*attr), &uattr->size);",
            "\treturn -E2BIG;",
            "}"
          ],
          "function_name": "_sched_setscheduler, sched_setscheduler, sched_setattr, sched_setattr_nocheck, sched_setscheduler_nocheck, sched_set_fifo, sched_set_fifo_low, sched_set_normal, do_sched_setscheduler, sched_copy_attr",
          "description": "提供多种调度参数设置接口，包括_sched_setscheduler及其变种函数。通过封装将用户参数转化为sched_attr结构，调用底层__sched_setscheduler实现。包含针对特定调度策略（FIFO/NORMAL）的专用接口，以及参数复制和校验逻辑。",
          "similarity": 0.5146758556365967
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sched/syscalls.c",
          "start_line": 375,
          "end_line": 487,
          "content": [
            "unsigned long sched_cpu_util(int cpu)",
            "{",
            "\treturn effective_cpu_util(cpu, cpu_util_cfs(cpu), NULL, NULL);",
            "}",
            "static void __setscheduler_params(struct task_struct *p,",
            "\t\tconst struct sched_attr *attr)",
            "{",
            "\tint policy = attr->sched_policy;",
            "",
            "\tif (policy == SETPARAM_POLICY)",
            "\t\tpolicy = p->policy;",
            "",
            "\tp->policy = policy;",
            "",
            "\tif (dl_policy(policy)) {",
            "\t\t__setparam_dl(p, attr);",
            "\t} else if (fair_policy(policy)) {",
            "\t\tp->static_prio = NICE_TO_PRIO(attr->sched_nice);",
            "\t\tif (attr->sched_runtime) {",
            "\t\t\tp->se.custom_slice = 1;",
            "\t\t\tp->se.slice = clamp_t(u64, attr->sched_runtime,",
            "\t\t\t\t\t      NSEC_PER_MSEC/10,   /* HZ=1000 * 10 */",
            "\t\t\t\t\t      NSEC_PER_MSEC*100); /* HZ=100  / 10 */",
            "\t\t} else {",
            "\t\t\tp->se.custom_slice = 0;",
            "\t\t\tp->se.slice = sysctl_sched_base_slice;",
            "\t\t}",
            "\t}",
            "",
            "\t/* rt-policy tasks do not have a timerslack */",
            "\tif (rt_or_dl_task_policy(p)) {",
            "\t\tp->timer_slack_ns = 0;",
            "\t} else if (p->timer_slack_ns == 0) {",
            "\t\t/* when switching back to non-rt policy, restore timerslack */",
            "\t\tp->timer_slack_ns = p->default_timer_slack_ns;",
            "\t}",
            "",
            "\t/*",
            "\t * __sched_setscheduler() ensures attr->sched_priority == 0 when",
            "\t * !rt_policy. Always setting this ensures that things like",
            "\t * getparam()/getattr() don't report silly values for !rt tasks.",
            "\t */",
            "\tp->rt_priority = attr->sched_priority;",
            "\tp->normal_prio = normal_prio(p);",
            "\tset_load_weight(p, true);",
            "}",
            "static bool check_same_owner(struct task_struct *p)",
            "{",
            "\tconst struct cred *cred = current_cred(), *pcred;",
            "\tguard(rcu)();",
            "",
            "\tpcred = __task_cred(p);",
            "\treturn (uid_eq(cred->euid, pcred->euid) ||",
            "\t\tuid_eq(cred->euid, pcred->uid));",
            "}",
            "static int uclamp_validate(struct task_struct *p,",
            "\t\t\t   const struct sched_attr *attr)",
            "{",
            "\tint util_min = p->uclamp_req[UCLAMP_MIN].value;",
            "\tint util_max = p->uclamp_req[UCLAMP_MAX].value;",
            "",
            "\tif (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MIN) {",
            "\t\tutil_min = attr->sched_util_min;",
            "",
            "\t\tif (util_min + 1 > SCHED_CAPACITY_SCALE + 1)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MAX) {",
            "\t\tutil_max = attr->sched_util_max;",
            "",
            "\t\tif (util_max + 1 > SCHED_CAPACITY_SCALE + 1)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (util_min != -1 && util_max != -1 && util_min > util_max)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * We have valid uclamp attributes; make sure uclamp is enabled.",
            "\t *",
            "\t * We need to do that here, because enabling static branches is a",
            "\t * blocking operation which obviously cannot be done while holding",
            "\t * scheduler locks.",
            "\t */",
            "\tsched_uclamp_enable();",
            "",
            "\treturn 0;",
            "}",
            "static bool uclamp_reset(const struct sched_attr *attr,",
            "\t\t\t enum uclamp_id clamp_id,",
            "\t\t\t struct uclamp_se *uc_se)",
            "{",
            "\t/* Reset on sched class change for a non user-defined clamp value. */",
            "\tif (likely(!(attr->sched_flags & SCHED_FLAG_UTIL_CLAMP)) &&",
            "\t    !uc_se->user_defined)",
            "\t\treturn true;",
            "",
            "\t/* Reset on sched_util_{min,max} == -1. */",
            "\tif (clamp_id == UCLAMP_MIN &&",
            "\t    attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MIN &&",
            "\t    attr->sched_util_min == -1) {",
            "\t\treturn true;",
            "\t}",
            "",
            "\tif (clamp_id == UCLAMP_MAX &&",
            "\t    attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MAX &&",
            "\t    attr->sched_util_max == -1) {",
            "\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "sched_cpu_util, __setscheduler_params, check_same_owner, uclamp_validate, uclamp_reset",
          "description": "实现调度参数配置、uclamp属性验证及调度器上下文检查，包含任务策略切换、时间片设置、用户权限校验及uclamp默认值处理逻辑",
          "similarity": 0.5072951316833496
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/sched/syscalls.c",
          "start_line": 1065,
          "end_line": 1186,
          "content": [
            "static void get_params(struct task_struct *p, struct sched_attr *attr)",
            "{",
            "\tif (task_has_dl_policy(p)) {",
            "\t\t__getparam_dl(p, attr);",
            "\t} else if (task_has_rt_policy(p)) {",
            "\t\tattr->sched_priority = p->rt_priority;",
            "\t} else {",
            "\t\tattr->sched_nice = task_nice(p);",
            "\t\tattr->sched_runtime = p->se.slice;",
            "\t}",
            "}",
            "static int",
            "sched_attr_copy_to_user(struct sched_attr __user *uattr,",
            "\t\t\tstruct sched_attr *kattr,",
            "\t\t\tunsigned int usize)",
            "{",
            "\tunsigned int ksize = sizeof(*kattr);",
            "",
            "\tif (!access_ok(uattr, usize))",
            "\t\treturn -EFAULT;",
            "",
            "\t/*",
            "\t * sched_getattr() ABI forwards and backwards compatibility:",
            "\t *",
            "\t * If usize == ksize then we just copy everything to user-space and all is good.",
            "\t *",
            "\t * If usize < ksize then we only copy as much as user-space has space for,",
            "\t * this keeps ABI compatibility as well. We skip the rest.",
            "\t *",
            "\t * If usize > ksize then user-space is using a newer version of the ABI,",
            "\t * which part the kernel doesn't know about. Just ignore it - tooling can",
            "\t * detect the kernel's knowledge of attributes from the attr->size value",
            "\t * which is set to ksize in this case.",
            "\t */",
            "\tkattr->size = min(usize, ksize);",
            "",
            "\tif (copy_to_user(uattr, kattr, kattr->size))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn 0;",
            "}",
            "int dl_task_check_affinity(struct task_struct *p, const struct cpumask *mask)",
            "{",
            "\t/*",
            "\t * If the task isn't a deadline task or admission control is",
            "\t * disabled then we don't care about affinity changes.",
            "\t */",
            "\tif (!task_has_dl_policy(p) || !dl_bandwidth_enabled())",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * Since bandwidth control happens on root_domain basis,",
            "\t * if admission test is enabled, we only admit -deadline",
            "\t * tasks allowed to run on all the CPUs in the task's",
            "\t * root_domain.",
            "\t */",
            "\tguard(rcu)();",
            "\tif (!cpumask_subset(task_rq(p)->rd->span, mask))",
            "\t\treturn -EBUSY;",
            "",
            "\treturn 0;",
            "}",
            "int __sched_setaffinity(struct task_struct *p, struct affinity_context *ctx)",
            "{",
            "\tint retval;",
            "\tcpumask_var_t cpus_allowed, new_mask;",
            "",
            "\tif (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL))",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_free_cpus_allowed;",
            "\t}",
            "",
            "\tcpuset_cpus_allowed(p, cpus_allowed);",
            "\tcpumask_and(new_mask, ctx->new_mask, cpus_allowed);",
            "",
            "\tctx->new_mask = new_mask;",
            "\tctx->flags |= SCA_CHECK;",
            "",
            "\tretval = dl_task_check_affinity(p, new_mask);",
            "\tif (retval)",
            "\t\tgoto out_free_new_mask;",
            "",
            "\tretval = __set_cpus_allowed_ptr(p, ctx);",
            "\tif (retval)",
            "\t\tgoto out_free_new_mask;",
            "",
            "\tcpuset_cpus_allowed(p, cpus_allowed);",
            "\tif (!cpumask_subset(new_mask, cpus_allowed)) {",
            "\t\t/*",
            "\t\t * We must have raced with a concurrent cpuset update.",
            "\t\t * Just reset the cpumask to the cpuset's cpus_allowed.",
            "\t\t */",
            "\t\tcpumask_copy(new_mask, cpus_allowed);",
            "",
            "\t\t/*",
            "\t\t * If SCA_USER is set, a 2nd call to __set_cpus_allowed_ptr()",
            "\t\t * will restore the previous user_cpus_ptr value.",
            "\t\t *",
            "\t\t * In the unlikely event a previous user_cpus_ptr exists,",
            "\t\t * we need to further restrict the mask to what is allowed",
            "\t\t * by that old user_cpus_ptr.",
            "\t\t */",
            "\t\tif (unlikely((ctx->flags & SCA_USER) && ctx->user_mask)) {",
            "\t\t\tbool empty = !cpumask_and(new_mask, new_mask,",
            "\t\t\t\t\t\t  ctx->user_mask);",
            "",
            "\t\t\tif (empty)",
            "\t\t\t\tcpumask_copy(new_mask, cpus_allowed);",
            "\t\t}",
            "\t\t__set_cpus_allowed_ptr(p, ctx);",
            "\t\tretval = -EINVAL;",
            "\t}",
            "",
            "out_free_new_mask:",
            "\tfree_cpumask_var(new_mask);",
            "out_free_cpus_allowed:",
            "\tfree_cpumask_var(cpus_allowed);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "get_params, sched_attr_copy_to_user, dl_task_check_affinity, __sched_setaffinity",
          "description": "实现调度参数获取与亲和性检查功能。get_params提取任务调度参数，sched_attr_copy_to_user完成内核参数向用户空间复制。dl_task_check_affinity验证截止时间任务的CPU亲和性有效性，__sched_setaffinity处理任务CPU亲和性设置及约束检查。",
          "similarity": 0.497328519821167
        }
      ]
    }
  ]
}