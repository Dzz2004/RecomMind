{
  "query": "C标准库函数与系统调用的映射关系",
  "timestamp": "2025-12-26 02:06:50",
  "retrieved_files": [
    {
      "source_file": "kernel/static_call.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:28:20\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `static_call.c`\n\n---\n\n# static_call.c 技术文档\n\n## 1. 文件概述\n\n`static_call.c` 是 Linux 内核中静态调用（Static Call）机制的辅助实现文件，主要用于提供一个通用的、返回零值的静态调用桩函数（stub function）。该函数作为静态调用机制的默认实现，在未被特定实现替换时被调用，确保静态调用点始终有合法的函数可执行。\n\n## 2. 核心功能\n\n- **函数 `__static_call_return0`**  \n  一个返回 `long` 类型值 0 的简单函数，用作静态调用的默认桩函数。\n\n- **符号导出**  \n  通过 `EXPORT_SYMBOL_GPL` 将 `__static_call_return0` 导出，供其他 GPL 兼容的内核模块使用。\n\n## 3. 关键实现\n\n- 函数 `__static_call_return0` 实现极其简洁，仅包含一条返回语句 `return 0;`，其目的是在静态调用机制初始化或未被覆盖时提供一个安全、无副作用的默认行为。\n- 该函数通常被静态调用基础设施（如 `static_call()` 宏）在初始化阶段用作跳转目标，后续可通过运行时修改指令指针将其替换为实际的目标函数，从而实现高效的间接调用优化。\n- 使用 `__static_call_return0` 作为默认桩函数可避免空函数指针调用，提升系统稳定性。\n\n## 4. 依赖关系\n\n- 依赖头文件 `<linux/static_call.h>`，该头文件定义了静态调用相关的宏、数据结构和接口。\n- 与内核的静态调用核心机制（通常实现在 `kernel/static_call.c` 或架构相关代码中）紧密配合，作为其默认实现的一部分。\n- 被多个内核子系统（如调度器、RCU、跟踪系统等）在使用静态调用特性时间接引用。\n\n## 5. 使用场景\n\n- 在启用 `CONFIG_HAVE_STATIC_CALL` 或类似配置选项的架构上，作为静态调用点的初始目标函数。\n- 当某个静态调用点尚未被注册具体实现时，调用该函数以返回默认值（0），防止未定义行为。\n- 用于性能敏感路径中，通过静态调用机制在编译时或运行时动态替换为更具体的实现，而无需函数指针间接调用开销。\n- 在模块加载或功能初始化完成前，提供安全的占位实现。",
      "similarity": 0.5588371753692627,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/static_call.c",
          "start_line": 1,
          "end_line": 3,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/static_call.h>",
            ""
          ],
          "function_name": null,
          "description": "引入静态调用相关头文件以支持后续静态调用表的声明与实现",
          "similarity": 0.5699372291564941
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/static_call.c",
          "start_line": 4,
          "end_line": 7,
          "content": [
            "long __static_call_return0(void)",
            "{",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__static_call_return0",
          "description": "定义静态调用返回类型为long的空函数，用于处理无需参数的静态调用目标函数",
          "similarity": 0.5298413634300232
        }
      ]
    },
    {
      "source_file": "kernel/compat.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `compat.c`\n\n---\n\n# compat.c 技术文档\n\n## 文件概述\n\n`compat.c` 是 Linux 内核中用于提供 32 位系统调用兼容性支持的核心文件，主要运行在 64 位内核上。该文件实现了将 32 位用户空间程序发出的系统调用转换为内核内部 64 位数据结构和接口所需的适配逻辑，确保 32 位应用程序能够在 64 位系统上正常运行。其核心功能包括信号处理、资源使用统计（rusage）、CPU 亲和性设置、位图操作以及信号集转换等兼容层封装。\n\n## 核心功能\n\n### 主要函数\n\n- `compat_sigprocmask`：32 位兼容版的 `sigprocmask` 系统调用，用于操作进程的信号掩码。\n- `put_compat_rusage`：将内核的 `struct rusage` 转换为 32 位兼容格式并复制到用户空间。\n- `compat_get_user_cpu_mask`：从用户空间读取 32 位 CPU 亲和性位图并转换为内核 `cpumask`。\n- `compat_sched_setaffinity` / `compat_sched_getaffinity`：32 位兼容的 CPU 亲和性设置与获取系统调用。\n- `get_compat_sigevent`：将 32 位 `sigevent` 结构从用户空间复制并转换为内核格式。\n- `compat_get_bitmap` / `compat_put_bitmap`：在 32 位用户空间与 64 位内核之间安全地传输位图数据。\n- `get_compat_sigset`：将 32 位信号集（`compat_sigset_t`）转换为内核内部的 `sigset_t`。\n\n### 关键数据结构\n\n- `compat_sigset_t`：32 位信号集表示。\n- `compat_rusage`：32 位资源使用统计结构。\n- `compat_sigevent`：32 位信号事件描述结构。\n- `compat_ulong_t`：32 位无符号长整型（通常为 `u32`）。\n\n## 关键实现\n\n### 信号掩码处理（`compat_sigprocmask`）\n\n该函数仅操作信号掩码的第一个字（32 位），通过 `compat_sig_setmask` 直接内存拷贝实现 `SIG_SETMASK` 行为。对于 `SIG_BLOCK` 和 `SIG_UNBLOCK`，则调用内核通用的 `sigaddsetmask` 和 `sigdelsetmask` 辅助函数。特别地，它会自动屏蔽 `SIGKILL` 和 `SIGSTOP`，因为这两个信号不可被阻塞。\n\n### 位图转换（`compat_get_bitmap` / `compat_put_bitmap`）\n\n由于 64 位内核中 `unsigned long` 为 64 位，而 32 位用户空间使用 32 位 `compat_ulong_t`，位图需进行高低位重组：\n- **读取**：每两个 32 位值组合成一个 64 位内核值（低位在前，高位在后）。\n- **写入**：将一个 64 位内核值拆分为两个 32 位值写回用户空间。\n使用 `user_read_access_begin`/`user_write_access_end` 配合 `unsafe_get/put_user` 实现高效、安全的批量访问。\n\n### 字节序处理（`get_compat_sigset`）\n\n在大端（Big-Endian）架构上，32 位信号集的高低 32 位在内存中的排列与小端不同，需显式重组为 64 位内核信号字。小端架构可直接内存拷贝。\n\n### CPU 亲和性兼容（`sched_setaffinity`/`getaffinity`）\n\n- **设置**：通过 `compat_get_user_cpu_mask` 将用户传入的 32 位位图转换为内核 `cpumask`，再调用通用 `sched_setaffinity`。\n- **获取**：先调用通用接口获取内核 `cpumask`，再通过 `compat_put_bitmap` 转换回 32 位格式返回给用户。返回长度为实际写入的字节数。\n\n### 资源使用统计（`put_compat_rusage`）\n\n逐字段将 64 位 `rusage` 中的时间（`tv_sec`/`tv_usec`）及其他统计值复制到 32 位结构体，确保字段对齐和截断安全，最后通过 `copy_to_user` 返回。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/compat.h>`：提供兼容层宏定义和类型（如 `COMPAT_SYSCALL_DEFINE`）。\n  - `<linux/uaccess.h>`：用户空间内存访问接口（`get_user`、`put_user` 等）。\n  - `<linux/sched.h>`、`<linux/cpumask.h>`：调度和 CPU 亲和性相关 API。\n  - `<linux/signal.h>`：信号处理核心接口。\n  - `<linux/posix-timers.h>`：`sigevent` 相关定义。\n- **内核模块依赖**：\n  - 调度子系统（`kernel/sched/`）：`sched_setaffinity`/`getaffinity` 实现。\n  - 信号子系统（`kernel/signal.c`）：信号掩码操作函数。\n  - 内存管理：`GFP_KERNEL` 内存分配。\n- **架构依赖**：通过 `__ARCH_WANT_SYS_SIGPROCMASK` 宏控制是否编译 `sigprocmask` 兼容实现，依赖 `__BIG_ENDIAN` 处理字节序差异。\n\n## 使用场景\n\n1. **32 位应用程序在 64 位内核上运行**：当 32 位 ELF 程序执行系统调用（如 `sigprocmask`、`sched_setaffinity`）时，内核通过此文件中的兼容层函数处理参数转换。\n2. **跨架构二进制兼容**：在 x86_64、ARM64 等支持 32 位兼容模式的架构上，该文件是运行旧版 32 位软件的关键组件。\n3. **系统调用拦截与转换**：安全模块（如 SELinux）或容器运行时可能依赖此兼容层正确解析 32 位进程的系统调用参数。\n4. **性能监控工具**：32 位 `getrusage` 调用通过 `put_compat_rusage` 获取资源统计信息。\n5. **实时/多线程应用**：32 位程序使用 `timer_create` 等 POSIX 定时器接口时，`sigevent` 结构通过 `get_compat_sigevent` 转换。",
      "similarity": 0.5546242594718933,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/compat.c",
          "start_line": 1,
          "end_line": 34,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/compat.c",
            " *",
            " *  Kernel compatibililty routines for e.g. 32 bit syscall support",
            " *  on 64 bit kernels.",
            " *",
            " *  Copyright (C) 2002-2003 Stephen Rothwell, IBM Corporation",
            " */",
            "",
            "#include <linux/linkage.h>",
            "#include <linux/compat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/signal.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/times.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#ifdef __ARCH_WANT_SYS_SIGPROCMASK",
            "",
            "/*",
            " * sys_sigprocmask SIG_SETMASK sets the first (compat) word of the",
            " * blocked set of signals to the supplied signal set",
            " */"
          ],
          "function_name": null,
          "description": "此代码块包含兼容性支持所需的基础头文件和注释，定义了处理32位系统调用兼容性的框架，主要用于实现64位内核对32位进程的信号集操作等兼容逻辑。",
          "similarity": 0.4850532114505768
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/compat.c",
          "start_line": 35,
          "end_line": 144,
          "content": [
            "static inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)",
            "{",
            "\tmemcpy(blocked->sig, &set, sizeof(set));",
            "}",
            "int put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)",
            "{",
            "\tstruct compat_rusage r32;",
            "\tmemset(&r32, 0, sizeof(r32));",
            "\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;",
            "\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;",
            "\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;",
            "\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;",
            "\tr32.ru_maxrss = r->ru_maxrss;",
            "\tr32.ru_ixrss = r->ru_ixrss;",
            "\tr32.ru_idrss = r->ru_idrss;",
            "\tr32.ru_isrss = r->ru_isrss;",
            "\tr32.ru_minflt = r->ru_minflt;",
            "\tr32.ru_majflt = r->ru_majflt;",
            "\tr32.ru_nswap = r->ru_nswap;",
            "\tr32.ru_inblock = r->ru_inblock;",
            "\tr32.ru_oublock = r->ru_oublock;",
            "\tr32.ru_msgsnd = r->ru_msgsnd;",
            "\tr32.ru_msgrcv = r->ru_msgrcv;",
            "\tr32.ru_nsignals = r->ru_nsignals;",
            "\tr32.ru_nvcsw = r->ru_nvcsw;",
            "\tr32.ru_nivcsw = r->ru_nivcsw;",
            "\tif (copy_to_user(ru, &r32, sizeof(r32)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "static int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,",
            "\t\t\t\t    unsigned len, struct cpumask *new_mask)",
            "{",
            "\tunsigned long *k;",
            "",
            "\tif (len < cpumask_size())",
            "\t\tmemset(new_mask, 0, cpumask_size());",
            "\telse if (len > cpumask_size())",
            "\t\tlen = cpumask_size();",
            "",
            "\tk = cpumask_bits(new_mask);",
            "\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);",
            "}",
            "int get_compat_sigevent(struct sigevent *event,",
            "\t\tconst struct compat_sigevent __user *u_event)",
            "{",
            "\tmemset(event, 0, sizeof(*event));",
            "\treturn (!access_ok(u_event, sizeof(*u_event)) ||",
            "\t\t__get_user(event->sigev_value.sival_int,",
            "\t\t\t&u_event->sigev_value.sival_int) ||",
            "\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||",
            "\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||",
            "\t\t__get_user(event->sigev_notify_thread_id,",
            "\t\t\t&u_event->sigev_notify_thread_id))",
            "\t\t? -EFAULT : 0;",
            "}",
            "long compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,",
            "\t\t       unsigned long bitmap_size)",
            "{",
            "\tunsigned long nr_compat_longs;",
            "",
            "\t/* align bitmap up to nearest compat_long_t boundary */",
            "\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);",
            "\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);",
            "",
            "\tif (!user_read_access_begin(umask, bitmap_size / 8))",
            "\t\treturn -EFAULT;",
            "",
            "\twhile (nr_compat_longs > 1) {",
            "\t\tcompat_ulong_t l1, l2;",
            "\t\tunsafe_get_user(l1, umask++, Efault);",
            "\t\tunsafe_get_user(l2, umask++, Efault);",
            "\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;",
            "\t\tnr_compat_longs -= 2;",
            "\t}",
            "\tif (nr_compat_longs)",
            "\t\tunsafe_get_user(*mask, umask++, Efault);",
            "\tuser_read_access_end();",
            "\treturn 0;",
            "",
            "Efault:",
            "\tuser_read_access_end();",
            "\treturn -EFAULT;",
            "}",
            "long compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,",
            "\t\t       unsigned long bitmap_size)",
            "{",
            "\tunsigned long nr_compat_longs;",
            "",
            "\t/* align bitmap up to nearest compat_long_t boundary */",
            "\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);",
            "\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);",
            "",
            "\tif (!user_write_access_begin(umask, bitmap_size / 8))",
            "\t\treturn -EFAULT;",
            "",
            "\twhile (nr_compat_longs > 1) {",
            "\t\tunsigned long m = *mask++;",
            "\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);",
            "\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);",
            "\t\tnr_compat_longs -= 2;",
            "\t}",
            "\tif (nr_compat_longs)",
            "\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);",
            "\tuser_write_access_end();",
            "\treturn 0;",
            "Efault:",
            "\tuser_write_access_end();",
            "\treturn -EFAULT;",
            "}"
          ],
          "function_name": "compat_sig_setmask, put_compat_rusage, compat_get_user_cpu_mask, get_compat_sigevent, compat_get_bitmap, compat_put_bitmap",
          "description": "实现多个兼容性转换函数，包括将rusage结构体转换为32位格式、处理CPU掩码位图转换、提取sigevent事件信息以及双向转换信号集位图，核心功能是解决64位内核与32位用户态数据类型的差异。",
          "similarity": 0.4842885732650757
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/compat.c",
          "start_line": 249,
          "end_line": 270,
          "content": [
            "int",
            "get_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)",
            "{",
            "#ifdef __BIG_ENDIAN",
            "\tcompat_sigset_t v;",
            "\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))",
            "\t\treturn -EFAULT;",
            "\tswitch (_NSIG_WORDS) {",
            "\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );",
            "\t}",
            "#else",
            "\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))",
            "\t\treturn -EFAULT;",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_compat_sigset",
          "description": "将用户态的兼容信号集（compat_sigset_t）转换为内核态sigset_t结构，在大端架构下通过字节序调整确保信号掩码的正确解析，实现信号集的跨字节序兼容转换。",
          "similarity": 0.4322790801525116
        }
      ]
    },
    {
      "source_file": "kernel/bpf/syscall.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:31:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\syscall.c`\n\n---\n\n# `bpf/syscall.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/syscall.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统的核心实现文件之一，主要负责处理与 BPF 相关的系统调用逻辑。该文件实现了 BPF 程序、映射（map）和链接（link）对象的创建、更新、查询、删除等操作的底层支持，并管理这些对象的生命周期、权限控制、内存布局以及与用户空间的交互。此外，它还包含对 BPF 对象中用户指针（uptr）的内存固定（pinning）机制，确保内核安全访问用户空间内存。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `bpf_map_ops`：定义各类 BPF 映射的操作函数集，通过 `bpf_map_types[]` 数组按类型索引。\n- `bpf_map`：BPF 映射的通用抽象结构，包含类型、键/值大小、操作函数指针等。\n- IDR（Integer ID Allocator）结构：\n  - `prog_idr` / `map_idr` / `link_idr`：分别用于分配和管理 BPF 程序、映射和链接的全局唯一 ID。\n- `btf_record` 与 `btf_field`：用于描述 BPF 对象中包含的 BTF（BPF Type Format）元数据字段，特别是 `BPF_UPTR` 类型字段。\n\n### 主要函数\n- `bpf_check_uarg_tail_zero()`：验证用户传入的结构体尾部未使用字节是否为零，用于向前兼容。\n- `bpf_map_value_size()`：根据映射类型计算实际存储值的大小（如 per-CPU 映射需乘以 CPU 数）。\n- `bpf_map_update_value()`：统一入口，根据映射类型分发到对应的更新实现。\n- `bpf_obj_pin_uptrs()` / `bpf_obj_unpin_uptrs()`：对 BPF 对象中 `BPF_UPTR` 字段指向的用户空间内存进行长期固定（pin）或释放。\n- `maybe_wait_bpf_programs()`：在更新某些映射（如 map-in-map）后同步等待正在运行的 BPF 程序完成。\n- `bpf_map_write_active*()`：提供映射写入活跃状态的原子计数机制。\n\n### 全局变量\n- `sysctl_unprivileged_bpf_disabled`：控制非特权用户是否可使用 BPF 的运行时开关。\n- `bpf_prog_active`（per-CPU）：跟踪当前 CPU 上是否正在执行 BPF 程序。\n- `bpf_map_offload_ops`：用于硬件卸载（offload）场景的映射操作集。\n\n### 宏定义\n- `IS_FD_*` 系列宏：用于快速判断映射是否存储文件描述符（如程序、其他映射等）。\n- `BPF_OBJ_FLAG_MASK`：定义 BPF 对象创建时允许的标志位掩码。\n\n## 3. 关键实现\n\n### 用户参数兼容性检查\n`bpf_check_uarg_tail_zero()` 函数确保当用户空间传递比内核预期更大的结构体时，超出部分必须全为零。这防止新版本用户空间依赖尚未实现的内核特性，保障 ABI 的向前兼容性。该函数区分内核指针和用户指针，分别使用 `memchr_inv()` 和 `check_zeroed_user()` 进行检查。\n\n### BPF 映射值大小计算\n`bpf_map_value_size()` 根据映射类型动态计算实际存储开销：\n- 对于 per-CPU 类型（如 `PERCPU_HASH`、`PERCPU_ARRAY`），值大小需对齐到 8 字节并乘以可能的 CPU 数量。\n- 对于存储文件描述符的映射（如 `PROG_ARRAY`、`ARRAY_OF_MAPS`），值大小固定为 `sizeof(u32)`。\n- 其他类型直接使用 `map->value_size`。\n\n### 用户指针（uptr）内存固定机制\nBPF 支持在映射值或程序上下文中包含指向用户空间内存的指针（`BPF_UPTR`）。为确保内核安全访问：\n1. `bpf_obj_pin_uptrs()` 使用 `pin_user_pages_fast()` 将用户页长期固定（`FOLL_LONGTERM`），防止被换出。\n2. 要求目标结构体不能跨页（避免复杂性），且不支持高端内存（`PageHighMem`）。\n3. 固定成功后，将用户虚拟地址转换为内核线性映射地址存储。\n4. 出错时通过 `__bpf_obj_unpin_uptrs()` 回滚已固定的页。\n\n### 映射更新分发逻辑\n`bpf_map_update_value()` 是映射更新的核心分发函数：\n- 硬件卸载映射调用 `bpf_map_offload_update_elem()`。\n- 特殊映射（如 `CPUMAP`、`SOCKMAP`）调用其专属更新函数。\n- 文件描述符类映射（`PROG_ARRAY`、`ARRAY_OF_MAPS` 等）在 RCU 读锁保护下更新，确保并发安全。\n- per-CPU 映射调用对应的 per-CPU 更新函数。\n- 更新前调用 `bpf_disable_instrumentation()` 避免追踪干扰。\n\n### 同步机制\n- 对于 `HASH_OF_MAPS` 和 `ARRAY_OF_MAPS`，更新后调用 `synchronize_rcu()` 确保所有 CPU 上正在运行的 BPF 程序看到新值。\n- per-CPU 计数器 `bpf_prog_active` 用于检测 BPF 程序递归调用或死锁。\n\n## 4. 依赖关系\n\n- **BPF 子系统内部**：\n  - 依赖 `bpf_map_types.h` 自动生成的映射操作函数表。\n  - 与 `bpf_verifier.c`（验证器）、`bpf_helpers.c`（辅助函数）、各类映射实现（如 `arraymap.c`、`hashtab.c`）紧密协作。\n- **内存管理**：\n  - 使用 `pin_user_pages_fast()` / `unpin_user_page()` 管理用户页固定。\n  - 依赖 `mm/` 子系统的页表和内存分配机制。\n- **RCU 机制**：\n  - 在更新共享映射时使用 RCU 保证并发安全。\n- **BTF（BPF Type Format）**：\n  - 依赖 `btf.c` 提供的类型信息解析 `BPF_UPTR` 字段。\n- **网络子系统**：\n  - 包含 `netfilter/nf_bpf_link.h`、`netkit.h`、`tcx.h` 等头文件，支持网络相关的 BPF 链接类型。\n- **安全模块**：\n  - 与 LSM（`bpf_lsm.h`）、审计（`audit.h`）集成，实施权限检查。\n\n## 5. 使用场景\n\n- **系统调用处理**：作为 `bpf(2)` 系统调用的后端实现，处理 `BPF_MAP_CREATE`、`BPF_MAP_UPDATE_ELEM`、`BPF_PROG_LOAD` 等命令。\n- **eBPF 程序执行**：为运行中的 BPF 程序提供映射访问、程序调用（通过 `PROG_ARRAY`）等运行时支持。\n- **容器与 cgroup 集成**：通过 `CGROUP_ARRAY` 等映射类型实现资源控制策略。\n- **性能监控**：`PERF_EVENT_ARRAY` 映射用于将 BPF 程序与 perf 事件关联。\n- **网络数据平面**：`SOCKMAP`、`XSKMAP` 等用于加速 socket 和 AF_XDP 数据路径。\n- **内核追踪**：与 ftrace、kprobe 等子系统结合，实现动态追踪。\n- **安全策略实施**：通过 BPF LSM 钩子执行自定义安全策略。\n- **用户空间内存安全访问**：在需要内核直接访问用户缓冲区的场景（如某些高级 BPF 程序）中，通过 `BPF_UPTR` 机制安全固定内存。",
      "similarity": 0.5493046641349792,
      "chunks": [
        {
          "chunk_id": 26,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 4444,
          "end_line": 4818,
          "content": [
            "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)",
            "{",
            "\tstruct bpf_prog *prog;",
            "\tu32 id = attr->prog_id;",
            "\tint fd;",
            "",
            "\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tprog = bpf_prog_by_id(id);",
            "\tif (IS_ERR(prog))",
            "\t\treturn PTR_ERR(prog);",
            "",
            "\tfd = bpf_prog_new_fd(prog);",
            "\tif (fd < 0)",
            "\t\tbpf_prog_put(prog);",
            "",
            "\treturn fd;",
            "}",
            "static int bpf_map_get_fd_by_id(const union bpf_attr *attr)",
            "{",
            "\tstruct bpf_map *map;",
            "\tu32 id = attr->map_id;",
            "\tint f_flags;",
            "\tint fd;",
            "",
            "\tif (CHECK_ATTR(BPF_MAP_GET_FD_BY_ID) ||",
            "\t    attr->open_flags & ~BPF_OBJ_FLAG_MASK)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tf_flags = bpf_get_file_flag(attr->open_flags);",
            "\tif (f_flags < 0)",
            "\t\treturn f_flags;",
            "",
            "\tspin_lock_bh(&map_idr_lock);",
            "\tmap = idr_find(&map_idr, id);",
            "\tif (map)",
            "\t\tmap = __bpf_map_inc_not_zero(map, true);",
            "\telse",
            "\t\tmap = ERR_PTR(-ENOENT);",
            "\tspin_unlock_bh(&map_idr_lock);",
            "",
            "\tif (IS_ERR(map))",
            "\t\treturn PTR_ERR(map);",
            "",
            "\tfd = bpf_map_new_fd(map, f_flags);",
            "\tif (fd < 0)",
            "\t\tbpf_map_put_with_uref(map);",
            "",
            "\treturn fd;",
            "}",
            "static int set_info_rec_size(struct bpf_prog_info *info)",
            "{",
            "\t/*",
            "\t * Ensure info.*_rec_size is the same as kernel expected size",
            "\t *",
            "\t * or",
            "\t *",
            "\t * Only allow zero *_rec_size if both _rec_size and _cnt are",
            "\t * zero.  In this case, the kernel will set the expected",
            "\t * _rec_size back to the info.",
            "\t */",
            "",
            "\tif ((info->nr_func_info || info->func_info_rec_size) &&",
            "\t    info->func_info_rec_size != sizeof(struct bpf_func_info))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((info->nr_line_info || info->line_info_rec_size) &&",
            "\t    info->line_info_rec_size != sizeof(struct bpf_line_info))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((info->nr_jited_line_info || info->jited_line_info_rec_size) &&",
            "\t    info->jited_line_info_rec_size != sizeof(__u64))",
            "\t\treturn -EINVAL;",
            "",
            "\tinfo->func_info_rec_size = sizeof(struct bpf_func_info);",
            "\tinfo->line_info_rec_size = sizeof(struct bpf_line_info);",
            "\tinfo->jited_line_info_rec_size = sizeof(__u64);",
            "",
            "\treturn 0;",
            "}",
            "static int bpf_prog_get_info_by_fd(struct file *file,",
            "\t\t\t\t   struct bpf_prog *prog,",
            "\t\t\t\t   const union bpf_attr *attr,",
            "\t\t\t\t   union bpf_attr __user *uattr)",
            "{",
            "\tstruct bpf_prog_info __user *uinfo = u64_to_user_ptr(attr->info.info);",
            "\tstruct btf *attach_btf = bpf_prog_get_target_btf(prog);",
            "\tstruct bpf_prog_info info;",
            "\tu32 info_len = attr->info.info_len;",
            "\tstruct bpf_prog_kstats stats;",
            "\tchar __user *uinsns;",
            "\tu32 ulen;",
            "\tint err;",
            "",
            "\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);",
            "\tif (err)",
            "\t\treturn err;",
            "\tinfo_len = min_t(u32, sizeof(info), info_len);",
            "",
            "\tmemset(&info, 0, sizeof(info));",
            "\tif (copy_from_user(&info, uinfo, info_len))",
            "\t\treturn -EFAULT;",
            "",
            "\tinfo.type = prog->type;",
            "\tinfo.id = prog->aux->id;",
            "\tinfo.load_time = prog->aux->load_time;",
            "\tinfo.created_by_uid = from_kuid_munged(current_user_ns(),",
            "\t\t\t\t\t       prog->aux->user->uid);",
            "\tinfo.gpl_compatible = prog->gpl_compatible;",
            "",
            "\tmemcpy(info.tag, prog->tag, sizeof(prog->tag));",
            "\tmemcpy(info.name, prog->aux->name, sizeof(prog->aux->name));",
            "",
            "\tmutex_lock(&prog->aux->used_maps_mutex);",
            "\tulen = info.nr_map_ids;",
            "\tinfo.nr_map_ids = prog->aux->used_map_cnt;",
            "\tulen = min_t(u32, info.nr_map_ids, ulen);",
            "\tif (ulen) {",
            "\t\tu32 __user *user_map_ids = u64_to_user_ptr(info.map_ids);",
            "\t\tu32 i;",
            "",
            "\t\tfor (i = 0; i < ulen; i++)",
            "\t\t\tif (put_user(prog->aux->used_maps[i]->id,",
            "\t\t\t\t     &user_map_ids[i])) {",
            "\t\t\t\tmutex_unlock(&prog->aux->used_maps_mutex);",
            "\t\t\t\treturn -EFAULT;",
            "\t\t\t}",
            "\t}",
            "\tmutex_unlock(&prog->aux->used_maps_mutex);",
            "",
            "\terr = set_info_rec_size(&info);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tbpf_prog_get_stats(prog, &stats);",
            "\tinfo.run_time_ns = stats.nsecs;",
            "\tinfo.run_cnt = stats.cnt;",
            "\tinfo.recursion_misses = stats.misses;",
            "",
            "\tinfo.verified_insns = prog->aux->verified_insns;",
            "\tif (prog->aux->btf)",
            "\t\tinfo.btf_id = btf_obj_id(prog->aux->btf);",
            "",
            "\tif (!bpf_capable()) {",
            "\t\tinfo.jited_prog_len = 0;",
            "\t\tinfo.xlated_prog_len = 0;",
            "\t\tinfo.nr_jited_ksyms = 0;",
            "\t\tinfo.nr_jited_func_lens = 0;",
            "\t\tinfo.nr_func_info = 0;",
            "\t\tinfo.nr_line_info = 0;",
            "\t\tinfo.nr_jited_line_info = 0;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\tulen = info.xlated_prog_len;",
            "\tinfo.xlated_prog_len = bpf_prog_insn_size(prog);",
            "\tif (info.xlated_prog_len && ulen) {",
            "\t\tstruct bpf_insn *insns_sanitized;",
            "\t\tbool fault;",
            "",
            "\t\tif (prog->blinded && !bpf_dump_raw_ok(file->f_cred)) {",
            "\t\t\tinfo.xlated_prog_insns = 0;",
            "\t\t\tgoto done;",
            "\t\t}",
            "\t\tinsns_sanitized = bpf_insn_prepare_dump(prog, file->f_cred);",
            "\t\tif (!insns_sanitized)",
            "\t\t\treturn -ENOMEM;",
            "\t\tuinsns = u64_to_user_ptr(info.xlated_prog_insns);",
            "\t\tulen = min_t(u32, info.xlated_prog_len, ulen);",
            "\t\tfault = copy_to_user(uinsns, insns_sanitized, ulen);",
            "\t\tkfree(insns_sanitized);",
            "\t\tif (fault)",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tif (bpf_prog_is_offloaded(prog->aux)) {",
            "\t\terr = bpf_prog_offload_info_fill(&info, prog);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\t/* NOTE: the following code is supposed to be skipped for offload.",
            "\t * bpf_prog_offload_info_fill() is the place to fill similar fields",
            "\t * for offload.",
            "\t */",
            "\tulen = info.jited_prog_len;",
            "\tif (prog->aux->func_cnt) {",
            "\t\tu32 i;",
            "",
            "\t\tinfo.jited_prog_len = 0;",
            "\t\tfor (i = 0; i < prog->aux->func_cnt; i++)",
            "\t\t\tinfo.jited_prog_len += prog->aux->func[i]->jited_len;",
            "\t} else {",
            "\t\tinfo.jited_prog_len = prog->jited_len;",
            "\t}",
            "",
            "\tif (info.jited_prog_len && ulen) {",
            "\t\tif (bpf_dump_raw_ok(file->f_cred)) {",
            "\t\t\tuinsns = u64_to_user_ptr(info.jited_prog_insns);",
            "\t\t\tulen = min_t(u32, info.jited_prog_len, ulen);",
            "",
            "\t\t\t/* for multi-function programs, copy the JITed",
            "\t\t\t * instructions for all the functions",
            "\t\t\t */",
            "\t\t\tif (prog->aux->func_cnt) {",
            "\t\t\t\tu32 len, free, i;",
            "\t\t\t\tu8 *img;",
            "",
            "\t\t\t\tfree = ulen;",
            "\t\t\t\tfor (i = 0; i < prog->aux->func_cnt; i++) {",
            "\t\t\t\t\tlen = prog->aux->func[i]->jited_len;",
            "\t\t\t\t\tlen = min_t(u32, len, free);",
            "\t\t\t\t\timg = (u8 *) prog->aux->func[i]->bpf_func;",
            "\t\t\t\t\tif (copy_to_user(uinsns, img, len))",
            "\t\t\t\t\t\treturn -EFAULT;",
            "\t\t\t\t\tuinsns += len;",
            "\t\t\t\t\tfree -= len;",
            "\t\t\t\t\tif (!free)",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t} else {",
            "\t\t\t\tif (copy_to_user(uinsns, prog->bpf_func, ulen))",
            "\t\t\t\t\treturn -EFAULT;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tinfo.jited_prog_insns = 0;",
            "\t\t}",
            "\t}",
            "",
            "\tulen = info.nr_jited_ksyms;",
            "\tinfo.nr_jited_ksyms = prog->aux->func_cnt ? : 1;",
            "\tif (ulen) {",
            "\t\tif (bpf_dump_raw_ok(file->f_cred)) {",
            "\t\t\tunsigned long ksym_addr;",
            "\t\t\tu64 __user *user_ksyms;",
            "\t\t\tu32 i;",
            "",
            "\t\t\t/* copy the address of the kernel symbol",
            "\t\t\t * corresponding to each function",
            "\t\t\t */",
            "\t\t\tulen = min_t(u32, info.nr_jited_ksyms, ulen);",
            "\t\t\tuser_ksyms = u64_to_user_ptr(info.jited_ksyms);",
            "\t\t\tif (prog->aux->func_cnt) {",
            "\t\t\t\tfor (i = 0; i < ulen; i++) {",
            "\t\t\t\t\tksym_addr = (unsigned long)",
            "\t\t\t\t\t\tprog->aux->func[i]->bpf_func;",
            "\t\t\t\t\tif (put_user((u64) ksym_addr,",
            "\t\t\t\t\t\t     &user_ksyms[i]))",
            "\t\t\t\t\t\treturn -EFAULT;",
            "\t\t\t\t}",
            "\t\t\t} else {",
            "\t\t\t\tksym_addr = (unsigned long) prog->bpf_func;",
            "\t\t\t\tif (put_user((u64) ksym_addr, &user_ksyms[0]))",
            "\t\t\t\t\treturn -EFAULT;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tinfo.jited_ksyms = 0;",
            "\t\t}",
            "\t}",
            "",
            "\tulen = info.nr_jited_func_lens;",
            "\tinfo.nr_jited_func_lens = prog->aux->func_cnt ? : 1;",
            "\tif (ulen) {",
            "\t\tif (bpf_dump_raw_ok(file->f_cred)) {",
            "\t\t\tu32 __user *user_lens;",
            "\t\t\tu32 func_len, i;",
            "",
            "\t\t\t/* copy the JITed image lengths for each function */",
            "\t\t\tulen = min_t(u32, info.nr_jited_func_lens, ulen);",
            "\t\t\tuser_lens = u64_to_user_ptr(info.jited_func_lens);",
            "\t\t\tif (prog->aux->func_cnt) {",
            "\t\t\t\tfor (i = 0; i < ulen; i++) {",
            "\t\t\t\t\tfunc_len =",
            "\t\t\t\t\t\tprog->aux->func[i]->jited_len;",
            "\t\t\t\t\tif (put_user(func_len, &user_lens[i]))",
            "\t\t\t\t\t\treturn -EFAULT;",
            "\t\t\t\t}",
            "\t\t\t} else {",
            "\t\t\t\tfunc_len = prog->jited_len;",
            "\t\t\t\tif (put_user(func_len, &user_lens[0]))",
            "\t\t\t\t\treturn -EFAULT;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tinfo.jited_func_lens = 0;",
            "\t\t}",
            "\t}",
            "",
            "\tinfo.attach_btf_id = prog->aux->attach_btf_id;",
            "\tif (attach_btf)",
            "\t\tinfo.attach_btf_obj_id = btf_obj_id(attach_btf);",
            "",
            "\tulen = info.nr_func_info;",
            "\tinfo.nr_func_info = prog->aux->func_info_cnt;",
            "\tif (info.nr_func_info && ulen) {",
            "\t\tchar __user *user_finfo;",
            "",
            "\t\tuser_finfo = u64_to_user_ptr(info.func_info);",
            "\t\tulen = min_t(u32, info.nr_func_info, ulen);",
            "\t\tif (copy_to_user(user_finfo, prog->aux->func_info,",
            "\t\t\t\t info.func_info_rec_size * ulen))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tulen = info.nr_line_info;",
            "\tinfo.nr_line_info = prog->aux->nr_linfo;",
            "\tif (info.nr_line_info && ulen) {",
            "\t\t__u8 __user *user_linfo;",
            "",
            "\t\tuser_linfo = u64_to_user_ptr(info.line_info);",
            "\t\tulen = min_t(u32, info.nr_line_info, ulen);",
            "\t\tif (copy_to_user(user_linfo, prog->aux->linfo,",
            "\t\t\t\t info.line_info_rec_size * ulen))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tulen = info.nr_jited_line_info;",
            "\tif (prog->aux->jited_linfo)",
            "\t\tinfo.nr_jited_line_info = prog->aux->nr_linfo;",
            "\telse",
            "\t\tinfo.nr_jited_line_info = 0;",
            "\tif (info.nr_jited_line_info && ulen) {",
            "\t\tif (bpf_dump_raw_ok(file->f_cred)) {",
            "\t\t\tunsigned long line_addr;",
            "\t\t\t__u64 __user *user_linfo;",
            "\t\t\tu32 i;",
            "",
            "\t\t\tuser_linfo = u64_to_user_ptr(info.jited_line_info);",
            "\t\t\tulen = min_t(u32, info.nr_jited_line_info, ulen);",
            "\t\t\tfor (i = 0; i < ulen; i++) {",
            "\t\t\t\tline_addr = (unsigned long)prog->aux->jited_linfo[i];",
            "\t\t\t\tif (put_user((__u64)line_addr, &user_linfo[i]))",
            "\t\t\t\t\treturn -EFAULT;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tinfo.jited_line_info = 0;",
            "\t\t}",
            "\t}",
            "",
            "\tulen = info.nr_prog_tags;",
            "\tinfo.nr_prog_tags = prog->aux->func_cnt ? : 1;",
            "\tif (ulen) {",
            "\t\t__u8 __user (*user_prog_tags)[BPF_TAG_SIZE];",
            "\t\tu32 i;",
            "",
            "\t\tuser_prog_tags = u64_to_user_ptr(info.prog_tags);",
            "\t\tulen = min_t(u32, info.nr_prog_tags, ulen);",
            "\t\tif (prog->aux->func_cnt) {",
            "\t\t\tfor (i = 0; i < ulen; i++) {",
            "\t\t\t\tif (copy_to_user(user_prog_tags[i],",
            "\t\t\t\t\t\t prog->aux->func[i]->tag,",
            "\t\t\t\t\t\t BPF_TAG_SIZE))",
            "\t\t\t\t\treturn -EFAULT;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tif (copy_to_user(user_prog_tags[0],",
            "\t\t\t\t\t prog->tag, BPF_TAG_SIZE))",
            "\t\t\t\treturn -EFAULT;",
            "\t\t}",
            "\t}",
            "",
            "done:",
            "\tif (copy_to_user(uinfo, &info, info_len) ||",
            "\t    put_user(info_len, &uattr->info.info_len))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_prog_get_fd_by_id, bpf_map_get_fd_by_id, set_info_rec_size, bpf_prog_get_info_by_fd",
          "description": "提供基于ID获取BPF程序/映射文件描述符的接口，设置并校验信息记录大小，实现程序详细信息的填充与返回。",
          "similarity": 0.5171688199043274
        },
        {
          "chunk_id": 32,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 5689,
          "end_line": 5842,
          "content": [
            "static int token_create(union bpf_attr *attr)",
            "{",
            "\tif (CHECK_ATTR(BPF_TOKEN_CREATE))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* no flags are supported yet */",
            "\tif (attr->token_create.flags)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn bpf_token_create(attr);",
            "}",
            "static int __sys_bpf(int cmd, bpfptr_t uattr, unsigned int size)",
            "{",
            "\tunion bpf_attr attr;",
            "\tint err;",
            "",
            "\terr = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size);",
            "\tif (err)",
            "\t\treturn err;",
            "\tsize = min_t(u32, size, sizeof(attr));",
            "",
            "\t/* copy attributes from user space, may be less than sizeof(bpf_attr) */",
            "\tmemset(&attr, 0, sizeof(attr));",
            "\tif (copy_from_bpfptr(&attr, uattr, size) != 0)",
            "\t\treturn -EFAULT;",
            "",
            "\terr = security_bpf(cmd, &attr, size);",
            "\tif (err < 0)",
            "\t\treturn err;",
            "",
            "\tswitch (cmd) {",
            "\tcase BPF_MAP_CREATE:",
            "\t\terr = map_create(&attr);",
            "\t\tbreak;",
            "\tcase BPF_MAP_LOOKUP_ELEM:",
            "\t\terr = map_lookup_elem(&attr);",
            "\t\tbreak;",
            "\tcase BPF_MAP_UPDATE_ELEM:",
            "\t\terr = map_update_elem(&attr, uattr);",
            "\t\tbreak;",
            "\tcase BPF_MAP_DELETE_ELEM:",
            "\t\terr = map_delete_elem(&attr, uattr);",
            "\t\tbreak;",
            "\tcase BPF_MAP_GET_NEXT_KEY:",
            "\t\terr = map_get_next_key(&attr);",
            "\t\tbreak;",
            "\tcase BPF_MAP_FREEZE:",
            "\t\terr = map_freeze(&attr);",
            "\t\tbreak;",
            "\tcase BPF_PROG_LOAD:",
            "\t\terr = bpf_prog_load(&attr, uattr, size);",
            "\t\tbreak;",
            "\tcase BPF_OBJ_PIN:",
            "\t\terr = bpf_obj_pin(&attr);",
            "\t\tbreak;",
            "\tcase BPF_OBJ_GET:",
            "\t\terr = bpf_obj_get(&attr);",
            "\t\tbreak;",
            "\tcase BPF_PROG_ATTACH:",
            "\t\terr = bpf_prog_attach(&attr);",
            "\t\tbreak;",
            "\tcase BPF_PROG_DETACH:",
            "\t\terr = bpf_prog_detach(&attr);",
            "\t\tbreak;",
            "\tcase BPF_PROG_QUERY:",
            "\t\terr = bpf_prog_query(&attr, uattr.user);",
            "\t\tbreak;",
            "\tcase BPF_PROG_TEST_RUN:",
            "\t\terr = bpf_prog_test_run(&attr, uattr.user);",
            "\t\tbreak;",
            "\tcase BPF_PROG_GET_NEXT_ID:",
            "\t\terr = bpf_obj_get_next_id(&attr, uattr.user,",
            "\t\t\t\t\t  &prog_idr, &prog_idr_lock);",
            "\t\tbreak;",
            "\tcase BPF_MAP_GET_NEXT_ID:",
            "\t\terr = bpf_obj_get_next_id(&attr, uattr.user,",
            "\t\t\t\t\t  &map_idr, &map_idr_lock);",
            "\t\tbreak;",
            "\tcase BPF_BTF_GET_NEXT_ID:",
            "\t\terr = bpf_obj_get_next_id(&attr, uattr.user,",
            "\t\t\t\t\t  &btf_idr, &btf_idr_lock);",
            "\t\tbreak;",
            "\tcase BPF_PROG_GET_FD_BY_ID:",
            "\t\terr = bpf_prog_get_fd_by_id(&attr);",
            "\t\tbreak;",
            "\tcase BPF_MAP_GET_FD_BY_ID:",
            "\t\terr = bpf_map_get_fd_by_id(&attr);",
            "\t\tbreak;",
            "\tcase BPF_OBJ_GET_INFO_BY_FD:",
            "\t\terr = bpf_obj_get_info_by_fd(&attr, uattr.user);",
            "\t\tbreak;",
            "\tcase BPF_RAW_TRACEPOINT_OPEN:",
            "\t\terr = bpf_raw_tracepoint_open(&attr);",
            "\t\tbreak;",
            "\tcase BPF_BTF_LOAD:",
            "\t\terr = bpf_btf_load(&attr, uattr, size);",
            "\t\tbreak;",
            "\tcase BPF_BTF_GET_FD_BY_ID:",
            "\t\terr = bpf_btf_get_fd_by_id(&attr);",
            "\t\tbreak;",
            "\tcase BPF_TASK_FD_QUERY:",
            "\t\terr = bpf_task_fd_query(&attr, uattr.user);",
            "\t\tbreak;",
            "\tcase BPF_MAP_LOOKUP_AND_DELETE_ELEM:",
            "\t\terr = map_lookup_and_delete_elem(&attr);",
            "\t\tbreak;",
            "\tcase BPF_MAP_LOOKUP_BATCH:",
            "\t\terr = bpf_map_do_batch(&attr, uattr.user, BPF_MAP_LOOKUP_BATCH);",
            "\t\tbreak;",
            "\tcase BPF_MAP_LOOKUP_AND_DELETE_BATCH:",
            "\t\terr = bpf_map_do_batch(&attr, uattr.user,",
            "\t\t\t\t       BPF_MAP_LOOKUP_AND_DELETE_BATCH);",
            "\t\tbreak;",
            "\tcase BPF_MAP_UPDATE_BATCH:",
            "\t\terr = bpf_map_do_batch(&attr, uattr.user, BPF_MAP_UPDATE_BATCH);",
            "\t\tbreak;",
            "\tcase BPF_MAP_DELETE_BATCH:",
            "\t\terr = bpf_map_do_batch(&attr, uattr.user, BPF_MAP_DELETE_BATCH);",
            "\t\tbreak;",
            "\tcase BPF_LINK_CREATE:",
            "\t\terr = link_create(&attr, uattr);",
            "\t\tbreak;",
            "\tcase BPF_LINK_UPDATE:",
            "\t\terr = link_update(&attr);",
            "\t\tbreak;",
            "\tcase BPF_LINK_GET_FD_BY_ID:",
            "\t\terr = bpf_link_get_fd_by_id(&attr);",
            "\t\tbreak;",
            "\tcase BPF_LINK_GET_NEXT_ID:",
            "\t\terr = bpf_obj_get_next_id(&attr, uattr.user,",
            "\t\t\t\t\t  &link_idr, &link_idr_lock);",
            "\t\tbreak;",
            "\tcase BPF_ENABLE_STATS:",
            "\t\terr = bpf_enable_stats(&attr);",
            "\t\tbreak;",
            "\tcase BPF_ITER_CREATE:",
            "\t\terr = bpf_iter_create(&attr);",
            "\t\tbreak;",
            "\tcase BPF_LINK_DETACH:",
            "\t\terr = link_detach(&attr);",
            "\t\tbreak;",
            "\tcase BPF_PROG_BIND_MAP:",
            "\t\terr = bpf_prog_bind_map(&attr);",
            "\t\tbreak;",
            "\tcase BPF_TOKEN_CREATE:",
            "\t\terr = token_create(&attr);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\terr = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "token_create, __sys_bpf",
          "description": "系统调用入口点处理BPF指令集，根据命令类型分发至相应实现函数，处理参数校验和上下文传递",
          "similarity": 0.5100023150444031
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 2300,
          "end_line": 2402,
          "content": [
            "static void __bpf_prog_put_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);",
            "",
            "\tkvfree(aux->func_info);",
            "\tkfree(aux->func_info_aux);",
            "\tfree_uid(aux->user);",
            "\tsecurity_bpf_prog_free(aux->prog);",
            "\tbpf_prog_free(aux->prog);",
            "}",
            "static void __bpf_prog_put_noref(struct bpf_prog *prog, bool deferred)",
            "{",
            "\tbpf_prog_kallsyms_del_all(prog);",
            "\tbtf_put(prog->aux->btf);",
            "\tmodule_put(prog->aux->mod);",
            "\tkvfree(prog->aux->jited_linfo);",
            "\tkvfree(prog->aux->linfo);",
            "\tkfree(prog->aux->kfunc_tab);",
            "\tkfree(prog->aux->ctx_arg_info);",
            "\tif (prog->aux->attach_btf)",
            "\t\tbtf_put(prog->aux->attach_btf);",
            "",
            "\tif (deferred) {",
            "\t\tif (prog->sleepable)",
            "\t\t\tcall_rcu_tasks_trace(&prog->aux->rcu, __bpf_prog_put_rcu);",
            "\t\telse",
            "\t\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);",
            "\t} else {",
            "\t\t__bpf_prog_put_rcu(&prog->aux->rcu);",
            "\t}",
            "}",
            "static void bpf_prog_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_prog_aux *aux;",
            "\tstruct bpf_prog *prog;",
            "",
            "\taux = container_of(work, struct bpf_prog_aux, work);",
            "\tprog = aux->prog;",
            "\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_UNLOAD, 0);",
            "\tbpf_audit_prog(prog, BPF_AUDIT_UNLOAD);",
            "\tbpf_prog_free_id(prog);",
            "\t__bpf_prog_put_noref(prog, true);",
            "}",
            "static void __bpf_prog_put(struct bpf_prog *prog)",
            "{",
            "\tstruct bpf_prog_aux *aux = prog->aux;",
            "",
            "\tif (atomic64_dec_and_test(&aux->refcnt)) {",
            "\t\tif (in_irq() || irqs_disabled()) {",
            "\t\t\tINIT_WORK(&aux->work, bpf_prog_put_deferred);",
            "\t\t\tschedule_work(&aux->work);",
            "\t\t} else {",
            "\t\t\tbpf_prog_put_deferred(&aux->work);",
            "\t\t}",
            "\t}",
            "}",
            "void bpf_prog_put(struct bpf_prog *prog)",
            "{",
            "\t__bpf_prog_put(prog);",
            "}",
            "static int bpf_prog_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_prog *prog = filp->private_data;",
            "",
            "\tbpf_prog_put(prog);",
            "\treturn 0;",
            "}",
            "void notrace bpf_prog_inc_misses_counter(struct bpf_prog *prog)",
            "{",
            "\tstruct bpf_prog_stats *stats;",
            "\tunsigned int flags;",
            "",
            "\tstats = this_cpu_ptr(prog->stats);",
            "\tflags = u64_stats_update_begin_irqsave(&stats->syncp);",
            "\tu64_stats_inc(&stats->misses);",
            "\tu64_stats_update_end_irqrestore(&stats->syncp, flags);",
            "}",
            "static void bpf_prog_get_stats(const struct bpf_prog *prog,",
            "\t\t\t       struct bpf_prog_kstats *stats)",
            "{",
            "\tu64 nsecs = 0, cnt = 0, misses = 0;",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tconst struct bpf_prog_stats *st;",
            "\t\tunsigned int start;",
            "\t\tu64 tnsecs, tcnt, tmisses;",
            "",
            "\t\tst = per_cpu_ptr(prog->stats, cpu);",
            "\t\tdo {",
            "\t\t\tstart = u64_stats_fetch_begin(&st->syncp);",
            "\t\t\ttnsecs = u64_stats_read(&st->nsecs);",
            "\t\t\ttcnt = u64_stats_read(&st->cnt);",
            "\t\t\ttmisses = u64_stats_read(&st->misses);",
            "\t\t} while (u64_stats_fetch_retry(&st->syncp, start));",
            "\t\tnsecs += tnsecs;",
            "\t\tcnt += tcnt;",
            "\t\tmisses += tmisses;",
            "\t}",
            "\tstats->nsecs = nsecs;",
            "\tstats->cnt = cnt;",
            "\tstats->misses = misses;",
            "}"
          ],
          "function_name": "__bpf_prog_put_rcu, __bpf_prog_put_noref, bpf_prog_put_deferred, __bpf_prog_put, bpf_prog_put, bpf_prog_release, bpf_prog_inc_misses_counter, bpf_prog_get_stats",
          "description": "该代码段实现了BPF程序的资源释放与统计管理，核心功能包括：通过RCU机制安全释放BPF辅助数据结构及关联资源，并支持延迟释放以避免中断上下文直接操作；  \n函数`__bpf_prog_put_noref`清理非引用计数相关资源并调度RCU释放，`bpf_prog_put`通过引用计数控制释放时机，`bpf_prog_release`作为文件操作回调触发程序释放；  \n统计函数`bpf_prog_inc_misses_counter`与`bpf_prog_get_stats`分别用于记录BPF程序命中次数并聚合多CPU统计信息。",
          "similarity": 0.5068835616111755
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 86,
          "end_line": 220,
          "content": [
            "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,",
            "\t\t\t     size_t expected_size,",
            "\t\t\t     size_t actual_size)",
            "{",
            "\tint res;",
            "",
            "\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */",
            "\t\treturn -E2BIG;",
            "",
            "\tif (actual_size <= expected_size)",
            "\t\treturn 0;",
            "",
            "\tif (uaddr.is_kernel)",
            "\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,",
            "\t\t\t\t actual_size - expected_size) == NULL;",
            "\telse",
            "\t\tres = check_zeroed_user(uaddr.user + expected_size,",
            "\t\t\t\t\tactual_size - expected_size);",
            "\tif (res < 0)",
            "\t\treturn res;",
            "\treturn res ? 0 : -E2BIG;",
            "}",
            "static void bpf_map_write_active_inc(struct bpf_map *map)",
            "{",
            "\tatomic64_inc(&map->writecnt);",
            "}",
            "static void bpf_map_write_active_dec(struct bpf_map *map)",
            "{",
            "\tatomic64_dec(&map->writecnt);",
            "}",
            "bool bpf_map_write_active(const struct bpf_map *map)",
            "{",
            "\treturn atomic64_read(&map->writecnt) != 0;",
            "}",
            "static u32 bpf_map_value_size(const struct bpf_map *map)",
            "{",
            "\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||",
            "\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||",
            "\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||",
            "\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)",
            "\t\treturn round_up(map->value_size, 8) * num_possible_cpus();",
            "\telse if (IS_FD_MAP(map))",
            "\t\treturn sizeof(u32);",
            "\telse",
            "\t\treturn  map->value_size;",
            "}",
            "static void maybe_wait_bpf_programs(struct bpf_map *map)",
            "{",
            "\t/* Wait for any running BPF programs to complete so that",
            "\t * userspace, when we return to it, knows that all programs",
            "\t * that could be running use the new map value.",
            "\t */",
            "\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||",
            "\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)",
            "\t\tsynchronize_rcu();",
            "}",
            "static void unpin_uptr_kaddr(void *kaddr)",
            "{",
            "\tif (kaddr)",
            "\t\tunpin_user_page(virt_to_page(kaddr));",
            "}",
            "static void __bpf_obj_unpin_uptrs(struct btf_record *rec, u32 cnt, void *obj)",
            "{",
            "\tconst struct btf_field *field;",
            "\tvoid **uptr_addr;",
            "\tint i;",
            "",
            "\tfor (i = 0, field = rec->fields; i < cnt; i++, field++) {",
            "\t\tif (field->type != BPF_UPTR)",
            "\t\t\tcontinue;",
            "",
            "\t\tuptr_addr = obj + field->offset;",
            "\t\tunpin_uptr_kaddr(*uptr_addr);",
            "\t}",
            "}",
            "static void bpf_obj_unpin_uptrs(struct btf_record *rec, void *obj)",
            "{",
            "\tif (!btf_record_has_field(rec, BPF_UPTR))",
            "\t\treturn;",
            "",
            "\t__bpf_obj_unpin_uptrs(rec, rec->cnt, obj);",
            "}",
            "static int bpf_obj_pin_uptrs(struct btf_record *rec, void *obj)",
            "{",
            "\tconst struct btf_field *field;",
            "\tconst struct btf_type *t;",
            "\tunsigned long start, end;",
            "\tstruct page *page;",
            "\tvoid **uptr_addr;",
            "\tint i, err;",
            "",
            "\tif (!btf_record_has_field(rec, BPF_UPTR))",
            "\t\treturn 0;",
            "",
            "\tfor (i = 0, field = rec->fields; i < rec->cnt; i++, field++) {",
            "\t\tif (field->type != BPF_UPTR)",
            "\t\t\tcontinue;",
            "",
            "\t\tuptr_addr = obj + field->offset;",
            "\t\tstart = *(unsigned long *)uptr_addr;",
            "\t\tif (!start)",
            "\t\t\tcontinue;",
            "",
            "\t\tt = btf_type_by_id(field->kptr.btf, field->kptr.btf_id);",
            "\t\t/* t->size was checked for zero before */",
            "\t\tif (check_add_overflow(start, t->size - 1, &end)) {",
            "\t\t\terr = -EFAULT;",
            "\t\t\tgoto unpin_all;",
            "\t\t}",
            "",
            "\t\t/* The uptr's struct cannot span across two pages */",
            "\t\tif ((start & PAGE_MASK) != (end & PAGE_MASK)) {",
            "\t\t\terr = -EOPNOTSUPP;",
            "\t\t\tgoto unpin_all;",
            "\t\t}",
            "",
            "\t\terr = pin_user_pages_fast(start, 1, FOLL_LONGTERM | FOLL_WRITE, &page);",
            "\t\tif (err != 1)",
            "\t\t\tgoto unpin_all;",
            "",
            "\t\tif (PageHighMem(page)) {",
            "\t\t\terr = -EOPNOTSUPP;",
            "\t\t\tunpin_user_page(page);",
            "\t\t\tgoto unpin_all;",
            "\t\t}",
            "",
            "\t\t*uptr_addr = page_address(page) + offset_in_page(start);",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "unpin_all:",
            "\t__bpf_obj_unpin_uptrs(rec, i, obj);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_check_uarg_tail_zero, bpf_map_write_active_inc, bpf_map_write_active_dec, bpf_map_write_active, bpf_map_value_size, maybe_wait_bpf_programs, unpin_uptr_kaddr, __bpf_obj_unpin_uptrs, bpf_obj_unpin_uptrs, bpf_obj_pin_uptrs",
          "description": "提供BPF map操作辅助函数，包括参数校验、写活性管理、值大小计算、等待程序同步及用户指针安全绑定",
          "similarity": 0.5012296438217163
        },
        {
          "chunk_id": 31,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 5520,
          "end_line": 5668,
          "content": [
            "static int bpf_link_get_fd_by_id(const union bpf_attr *attr)",
            "{",
            "\tstruct bpf_link *link;",
            "\tu32 id = attr->link_id;",
            "\tint fd;",
            "",
            "\tif (CHECK_ATTR(BPF_LINK_GET_FD_BY_ID))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tlink = bpf_link_by_id(id);",
            "\tif (IS_ERR(link))",
            "\t\treturn PTR_ERR(link);",
            "",
            "\tfd = bpf_link_new_fd(link);",
            "\tif (fd < 0)",
            "\t\tbpf_link_put_direct(link);",
            "",
            "\treturn fd;",
            "}",
            "static int bpf_stats_release(struct inode *inode, struct file *file)",
            "{",
            "\tmutex_lock(&bpf_stats_enabled_mutex);",
            "\tstatic_key_slow_dec(&bpf_stats_enabled_key.key);",
            "\tmutex_unlock(&bpf_stats_enabled_mutex);",
            "\treturn 0;",
            "}",
            "static int bpf_enable_runtime_stats(void)",
            "{",
            "\tint fd;",
            "",
            "\tmutex_lock(&bpf_stats_enabled_mutex);",
            "",
            "\t/* Set a very high limit to avoid overflow */",
            "\tif (static_key_count(&bpf_stats_enabled_key.key) > INT_MAX / 2) {",
            "\t\tmutex_unlock(&bpf_stats_enabled_mutex);",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tfd = anon_inode_getfd(\"bpf-stats\", &bpf_stats_fops, NULL, O_CLOEXEC);",
            "\tif (fd >= 0)",
            "\t\tstatic_key_slow_inc(&bpf_stats_enabled_key.key);",
            "",
            "\tmutex_unlock(&bpf_stats_enabled_mutex);",
            "\treturn fd;",
            "}",
            "static int bpf_enable_stats(union bpf_attr *attr)",
            "{",
            "",
            "\tif (CHECK_ATTR(BPF_ENABLE_STATS))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tswitch (attr->enable_stats.type) {",
            "\tcase BPF_STATS_RUN_TIME:",
            "\t\treturn bpf_enable_runtime_stats();",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static int bpf_iter_create(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_link *link;",
            "\tint err;",
            "",
            "\tif (CHECK_ATTR(BPF_ITER_CREATE))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (attr->iter_create.flags)",
            "\t\treturn -EINVAL;",
            "",
            "\tlink = bpf_link_get_from_fd(attr->iter_create.link_fd);",
            "\tif (IS_ERR(link))",
            "\t\treturn PTR_ERR(link);",
            "",
            "\terr = bpf_iter_new_fd(link);",
            "\tbpf_link_put_direct(link);",
            "",
            "\treturn err;",
            "}",
            "static int bpf_prog_bind_map(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_prog *prog;",
            "\tstruct bpf_map *map;",
            "\tstruct bpf_map **used_maps_old, **used_maps_new;",
            "\tint i, ret = 0;",
            "",
            "\tif (CHECK_ATTR(BPF_PROG_BIND_MAP))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (attr->prog_bind_map.flags)",
            "\t\treturn -EINVAL;",
            "",
            "\tprog = bpf_prog_get(attr->prog_bind_map.prog_fd);",
            "\tif (IS_ERR(prog))",
            "\t\treturn PTR_ERR(prog);",
            "",
            "\tmap = bpf_map_get(attr->prog_bind_map.map_fd);",
            "\tif (IS_ERR(map)) {",
            "\t\tret = PTR_ERR(map);",
            "\t\tgoto out_prog_put;",
            "\t}",
            "",
            "\tmutex_lock(&prog->aux->used_maps_mutex);",
            "",
            "\tused_maps_old = prog->aux->used_maps;",
            "",
            "\tfor (i = 0; i < prog->aux->used_map_cnt; i++)",
            "\t\tif (used_maps_old[i] == map) {",
            "\t\t\tbpf_map_put(map);",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "",
            "\tused_maps_new = kmalloc_array(prog->aux->used_map_cnt + 1,",
            "\t\t\t\t      sizeof(used_maps_new[0]),",
            "\t\t\t\t      GFP_KERNEL);",
            "\tif (!used_maps_new) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\t/* The bpf program will not access the bpf map, but for the sake of",
            "\t * simplicity, increase sleepable_refcnt for sleepable program as well.",
            "\t */",
            "\tif (prog->sleepable)",
            "\t\tatomic64_inc(&map->sleepable_refcnt);",
            "\tmemcpy(used_maps_new, used_maps_old,",
            "\t       sizeof(used_maps_old[0]) * prog->aux->used_map_cnt);",
            "\tused_maps_new[prog->aux->used_map_cnt] = map;",
            "",
            "\tprog->aux->used_map_cnt++;",
            "\tprog->aux->used_maps = used_maps_new;",
            "",
            "\tkfree(used_maps_old);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&prog->aux->used_maps_mutex);",
            "",
            "\tif (ret)",
            "\t\tbpf_map_put(map);",
            "out_prog_put:",
            "\tbpf_prog_put(prog);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_link_get_fd_by_id, bpf_stats_release, bpf_enable_runtime_stats, bpf_enable_stats, bpf_iter_create, bpf_prog_bind_map",
          "description": "提供链接ID查询、统计控制、迭代器创建、程序与映射绑定等功能，包含权限检查和资源管理",
          "similarity": 0.495896577835083
        }
      ]
    }
  ]
}