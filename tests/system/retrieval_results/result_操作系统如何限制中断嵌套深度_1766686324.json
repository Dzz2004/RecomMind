{
  "query": "操作系统如何限制中断嵌套深度",
  "timestamp": "2025-12-26 02:12:04",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/settings.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:08:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\settings.h`\n\n---\n\n# `irq/settings.h` 技术文档\n\n## 1. 文件概述\n\n`irq/settings.h` 是 Linux 内核中断子系统中的一个内部头文件，用于封装对 `irq_desc` 结构体中中断状态（原 `status` 字段，现为 `status_use_accessors`）的访问逻辑。该文件通过定义一组带下划线前缀的枚举常量（如 `_IRQ_PER_CPU`）映射原始中断标志（如 `IRQ_PER_CPU`），并提供一系列内联函数以安全、统一的方式读取和修改中断描述符的配置属性。同时，文件通过将原始标志宏（如 `IRQ_PER_CPU`）重定义为无效值（`GOT_YOU_MORON`），强制开发者使用封装后的访问器函数，避免直接操作底层状态位，从而提升代码的可维护性和安全性。\n\n## 2. 核心功能\n\n### 枚举常量\n- `_IRQ_DEFAULT_INIT_FLAGS`：中断描述符的默认初始化标志。\n- `_IRQ_PER_CPU`：表示该中断仅绑定到特定 CPU。\n- `_IRQ_LEVEL`：表示该中断为电平触发。\n- `_IRQ_NOPROBE`：禁止对该中断进行探测。\n- `_IRQ_NOREQUEST`：禁止通过 `request_irq()` 请求该中断。\n- `_IRQ_NOTHREAD`：禁止为该中断创建线程化处理程序。\n- `_IRQ_NOAUTOEN`：中断不会在注册后自动启用。\n- `_IRQ_MOVE_PCNTXT`：允许在进程上下文中迁移该中断。\n- `_IRQ_NO_BALANCING`：禁用中断负载均衡。\n- `_IRQ_NESTED_THREAD`：表示该中断是嵌套线程化中断。\n- `_IRQ_PER_CPU_DEVID`：表示该中断为 per-CPU 类型，且使用设备 ID。\n- `_IRQ_IS_POLLED`：表示该中断由轮询机制处理。\n- `_IRQ_DISABLE_UNLAZY`：禁用 lazy disable 优化。\n- `_IRQ_HIDDEN`：该中断对用户空间隐藏。\n- `_IRQ_NO_DEBUG`：禁用对该中断的调试跟踪。\n- `_IRQF_MODIFY_MASK`：定义哪些标志位允许被修改。\n\n### 内联函数\n- **通用操作**：\n  - `irq_settings_clr_and_set()`：原子地清除和设置指定的中断标志位。\n- **Per-CPU 相关**：\n  - `irq_settings_is_per_cpu()` / `irq_settings_set_per_cpu()`\n  - `irq_settings_is_per_cpu_devid()`\n- **负载均衡**：\n  - `irq_settings_set_no_balancing()` / `irq_settings_has_no_balance_set()`\n- **触发类型**：\n  - `irq_settings_get_trigger_mask()` / `irq_settings_set_trigger_mask()`\n  - `irq_settings_is_level()` / `irq_settings_set_level()` / `irq_settings_clr_level()`\n- **请求与探测控制**：\n  - `irq_settings_can_request()` / `irq_settings_set_norequest()` / `irq_settings_clr_norequest()`\n  - `irq_settings_can_probe()` / `irq_settings_set_noprobe()` / `irq_settings_clr_noprobe()`\n- **线程化处理**：\n  - `irq_settings_can_thread()` / `irq_settings_set_nothread()` / `irq_settings_clr_nothread()`\n  - `irq_settings_is_nested_thread()`\n- **其他属性**：\n  - `irq_settings_can_move_pcntxt()`\n  - `irq_settings_can_autoenable()`\n  - `irq_settings_is_polled()`\n  - `irq_settings_disable_unlazy()` / `irq_settings_clr_disable_unlazy()`\n  - `irq_settings_is_hidden()`\n  - `irq_settings_no_debug()` / `irq_settings_set_no_debug()`\n\n## 3. 关键实现\n\n- **标志位封装**：所有原始中断标志（如 `IRQ_PER_CPU`）被重定义为无效标识符（`GOT_YOU_MORON`），强制开发者使用带下划线前缀的枚举值（如 `_IRQ_PER_CPU`）配合封装函数进行操作，防止直接访问 `irq_desc->status_use_accessors`。\n- **安全位操作**：`irq_settings_clr_and_set()` 函数在修改标志位时，会与 `_IRQF_MODIFY_MASK` 进行掩码操作，确保只有允许修改的位被更新，防止意外覆盖关键状态。\n- **触发类型管理**：通过 `IRQ_TYPE_SENSE_MASK` 掩码单独管理中断触发类型（如边沿/电平），与其他标志位解耦。\n- **布尔语义封装**：对于“禁止”类标志（如 `_IRQ_NOREQUEST`），封装函数（如 `irq_settings_can_request()`）返回其逻辑否定值，使接口语义更直观（“能否请求”而非“是否禁止请求”）。\n\n## 4. 依赖关系\n\n- **依赖头文件**：隐式依赖 `linux/irq.h` 或 `linux/interrupt.h`，其中定义了原始中断标志（如 `IRQ_PER_CPU`、`IRQ_TYPE_SENSE_MASK`）和 `struct irq_desc`。\n- **被依赖模块**：\n  - 中断核心子系统（`kernel/irq/` 下的 `.c` 文件）：如 `irqdesc.c`、`manage.c` 等，在初始化、配置和管理中断描述符时调用本文件提供的访问器函数。\n  - 中断控制器驱动（如 GIC、APIC 驱动）：在设置特定中断属性时使用这些封装接口。\n  - 线程化中断和中断亲和性管理模块：依赖 per-CPU、线程化、负载均衡等相关接口。\n\n## 5. 使用场景\n\n- **中断描述符初始化**：在 `alloc_desc()` 或 `irq_setup_virq()` 等函数中，使用 `irq_settings_set_*` 系列函数设置中断的初始属性（如 per-CPU、触发类型等）。\n- **中断注册与配置**：在 `request_irq()`、`devm_request_irq()` 或驱动的中断设置路径中，通过 `irq_settings_can_request()` 等函数检查中断是否可被请求，并通过 `irq_settings_set_norequest()` 等函数动态调整属性。\n- **中断迁移与负载均衡**：在 `irq_set_affinity()` 或中断均衡逻辑中，使用 `irq_settings_has_no_balance_set()` 判断是否跳过均衡处理。\n- **调试与监控**：调试子系统通过 `irq_settings_no_debug()` 判断是否应跳过特定中断的跟踪。\n- **电源管理与轮询**：在中断休眠或轮询模式下，通过 `irq_settings_is_polled()` 和 `irq_settings_disable_unlazy()` 控制中断行为。",
      "similarity": 0.5978206396102905,
      "chunks": []
    },
    {
      "source_file": "kernel/irq/irqdesc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:59:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\irqdesc.c`\n\n---\n\n# `irq/irqdesc.c` 技术文档\n\n## 1. 文件概述\n\n`irq/irqdesc.c` 是 Linux 内核通用中断子系统（Generic IRQ）的核心实现文件之一，负责中断描述符（`struct irq_desc`）的分配、初始化、管理和释放。该文件实现了中断描述符的生命周期管理，包括在稀疏 IRQ（`CONFIG_SPARSE_IRQ`）配置下的动态分配机制，以及与 SMP（对称多处理）相关的中断亲和性（affinity）管理。它为上层中断处理（如设备驱动注册中断处理函数）和底层硬件中断控制器（通过 `irq_chip`）之间提供了统一的抽象层。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct irq_desc`**：中断描述符，代表一个逻辑中断号（IRQ number），包含中断状态、处理函数、统计信息、锁、亲和性掩码等。\n- **`struct irq_data`**：嵌入在 `irq_desc` 中，包含与硬件中断控制器相关的数据（如 `irq_chip`、`hwirq`、`irq_domain` 等）。\n- **`struct irq_common_data`**：`irq_desc` 和 `irq_data` 共享的数据，如 MSI 描述符、亲和性掩码等。\n- **`sparse_irqs`**：基于 Maple Tree 的稀疏 IRQ 描述符存储结构，用于动态分配 IRQ 号。\n\n### 主要函数\n- **`init_desc()`**：初始化一个 `irq_desc` 实例，包括分配 per-CPU 统计结构、SMP 掩码、初始化锁和默认值。\n- **`desc_set_defaults()`**：设置 `irq_desc` 的默认初始状态（如禁用、屏蔽、默认处理函数为 `handle_bad_irq`）。\n- **`alloc_masks()` / `free_masks()` / `desc_smp_init()`**：SMP 相关的亲和性掩码（affinity、effective_affinity、pending_mask）的分配、释放和初始化。\n- **`irq_find_free_area()` / `irq_find_at_or_after()`**：在稀疏 IRQ 模式下查找可用的 IRQ 号范围或下一个可用 IRQ。\n- **`irq_insert_desc()` / `delete_irq_desc()`**：将 `irq_desc` 插入或从稀疏 IRQ 的 Maple Tree 中删除。\n- **`init_irq_default_affinity()`**：初始化默认的中断亲和性掩码（通常为所有 CPU）。\n- **`irq_kobj_release()` 及相关 sysfs 属性函数**：实现 IRQ 描述符的 sysfs 接口（如 `per_cpu_count`、`chip_name`、`hwirq` 等）。\n\n### 全局变量\n- **`nr_irqs`**：系统支持的最大 IRQ 数量，可被平台代码覆盖。\n- **`irq_default_affinity`**：默认的中断亲和性 CPU 掩码（SMP 模式下）。\n- **`irq_desc_lock_class`**：用于 lockdep 的 IRQ 描述符自旋锁的统一锁类。\n\n## 3. 关键实现\n\n### 稀疏 IRQ 管理（`CONFIG_SPARSE_IRQ`）\n- 使用 **Maple Tree** 数据结构（`sparse_irqs`）替代传统的静态数组，支持动态分配 IRQ 描述符。\n- `irq_find_free_area()` 利用 Maple Tree 的空闲区间查找功能，高效分配连续的 IRQ 号。\n- `irq_insert_desc()` 和 `delete_irq_desc()` 通过 RCU 安全地插入/删除描述符，支持运行时 IRQ 的动态增删。\n- 每个 `irq_desc` 作为独立的 kobject，通过 sysfs 暴露属性（如中断计数、芯片名称等）。\n\n### SMP 中断亲和性\n- **亲和性掩码**：每个 IRQ 可配置其允许运行的 CPU 集合（`affinity`），支持负载均衡和局部性优化。\n- **有效亲和性**（`effective_affinity`）：实际生效的亲和性（可能受中断迁移或 pending 状态影响）。\n- **Pending 掩码**（`pending_mask`）：用于在中断迁移过程中暂存中断事件。\n- 启动参数 `irqaffinity=` 可设置全局默认亲和性，但至少包含引导 CPU 以防配置错误。\n\n### 描述符初始化\n- `init_desc()` 完成描述符的完整初始化：\n  - 分配 per-CPU 中断统计结构（`kstat_irqs`）。\n  - 初始化 SMP 相关掩码（若启用）。\n  - 设置自旋锁（带 lockdep 类）和互斥锁（`request_mutex`）。\n  - 调用 `desc_set_defaults()` 设置默认状态（禁用、屏蔽、无效处理函数）。\n  - 初始化 RCU 回调（用于稀疏 IRQ 的延迟释放）。\n\n### 锁与并发控制\n- **`desc->lock`**：raw spinlock，保护描述符关键字段（如状态、处理函数），在中断上下文中使用。\n- **`desc->request_mutex`**：mutex，用于串行化中断请求/释放操作（如 `request_irq()`）。\n- **Maple Tree 操作**：通过外部互斥锁（`sparse_irq_lock`）和 RCU 保证并发安全。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：IRQ 子系统核心 API 和数据结构。\n  - `<linux/irqdomain.h>`：硬件中断号（hwirq）到逻辑 IRQ 号的映射。\n  - `<linux/maple_tree.h>`：稀疏 IRQ 的底层存储实现。\n  - `<linux/sysfs.h>`：sysfs 属性支持。\n  - `\"internals.h\"`：IRQ 子系统内部函数和宏。\n- **配置依赖**：\n  - `CONFIG_SMP`：启用多处理器支持（亲和性掩码管理）。\n  - `CONFIG_SPARSE_IRQ`：启用动态 IRQ 分配（替代静态数组）。\n  - `CONFIG_GENERIC_PENDING_IRQ` / `CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK`：扩展的 SMP 中断管理功能。\n- **模块交互**：\n  - **中断控制器驱动**：通过 `irq_chip` 操作硬件，依赖 `irq_desc` 提供的抽象。\n  - **设备驱动**：通过 `request_irq()` 等接口注册中断处理函数，操作 `irq_desc`。\n  - **电源管理**：通过 `wakeup` 属性控制中断的唤醒能力。\n\n## 5. 使用场景\n\n- **系统启动阶段**：\n  - 初始化默认中断亲和性（`init_irq_default_affinity()`）。\n  - 预分配或动态创建平台所需的 IRQ 描述符（通过 `alloc_descs()` 等）。\n- **设备驱动加载/卸载**：\n  - 动态分配 IRQ 描述符（稀疏 IRQ 模式下通过 `irq_alloc_desc()`）。\n  - 注册/注销中断处理函数（修改 `handle_irq` 和 action 链表）。\n- **运行时中断管理**：\n  - 修改中断亲和性（`/proc/irq/<n>/smp_affinity`）。\n  - 查询中断统计信息（`/proc/interrupts`，通过 per-CPU 计数）。\n  - 通过 sysfs 查看 IRQ 属性（芯片名称、硬件 IRQ 号、触发类型等）。\n- **中断迁移**（SMP）：\n  - 在 CPU 热插拔或负载均衡时，更新 `affinity` 和 `pending_mask`。\n- **错误处理**：\n  - 未处理的中断由 `handle_bad_irq` 处理，记录到 `irqs_unhandled`。",
      "similarity": 0.5854600667953491,
      "chunks": [
        {
          "chunk_id": 7,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 938,
          "end_line": 1027,
          "content": [
            "int irq_set_percpu_devid(unsigned int irq)",
            "{",
            "\treturn irq_set_percpu_devid_partition(irq, NULL);",
            "}",
            "int irq_get_percpu_devid_partition(unsigned int irq, struct cpumask *affinity)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc || !desc->percpu_enabled)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (affinity)",
            "\t\tcpumask_copy(affinity, desc->percpu_affinity);",
            "",
            "\treturn 0;",
            "}",
            "void kstat_incr_irq_this_cpu(unsigned int irq)",
            "{",
            "\tkstat_incr_irqs_this_cpu(irq_to_desc(irq));",
            "}",
            "unsigned int kstat_irqs_cpu(unsigned int irq, int cpu)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\treturn desc && desc->kstat_irqs ? per_cpu(desc->kstat_irqs->cnt, cpu) : 0;",
            "}",
            "static bool irq_is_nmi(struct irq_desc *desc)",
            "{",
            "\treturn desc->istate & IRQS_NMI;",
            "}",
            "unsigned int kstat_irqs_desc(struct irq_desc *desc, const struct cpumask *cpumask)",
            "{",
            "\tunsigned int sum = 0;",
            "\tint cpu;",
            "",
            "\tif (!irq_settings_is_per_cpu_devid(desc) &&",
            "\t    !irq_settings_is_per_cpu(desc) &&",
            "\t    !irq_is_nmi(desc))",
            "\t\treturn data_race(desc->tot_count);",
            "",
            "\tfor_each_cpu(cpu, cpumask)",
            "\t\tsum += data_race(per_cpu(desc->kstat_irqs->cnt, cpu));",
            "\treturn sum;",
            "}",
            "static unsigned int kstat_irqs(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc || !desc->kstat_irqs)",
            "\t\treturn 0;",
            "\treturn kstat_irqs_desc(desc, cpu_possible_mask);",
            "}",
            "void kstat_snapshot_irqs(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tunsigned int irq;",
            "",
            "\tfor_each_irq_desc(irq, desc) {",
            "\t\tif (!desc->kstat_irqs)",
            "\t\t\tcontinue;",
            "\t\tthis_cpu_write(desc->kstat_irqs->ref, this_cpu_read(desc->kstat_irqs->cnt));",
            "\t}",
            "}",
            "unsigned int kstat_get_irq_since_snapshot(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc || !desc->kstat_irqs)",
            "\t\treturn 0;",
            "\treturn this_cpu_read(desc->kstat_irqs->cnt) - this_cpu_read(desc->kstat_irqs->ref);",
            "}",
            "unsigned int kstat_irqs_usr(unsigned int irq)",
            "{",
            "\tunsigned int sum;",
            "",
            "\trcu_read_lock();",
            "\tsum = kstat_irqs(irq);",
            "\trcu_read_unlock();",
            "\treturn sum;",
            "}",
            "void __irq_set_lockdep_class(unsigned int irq, struct lock_class_key *lock_class,",
            "\t\t\t     struct lock_class_key *request_class)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (desc) {",
            "\t\tlockdep_set_class(&desc->lock, lock_class);",
            "\t\tlockdep_set_class(&desc->request_mutex, request_class);",
            "\t}",
            "}"
          ],
          "function_name": "irq_set_percpu_devid, irq_get_percpu_devid_partition, kstat_incr_irq_this_cpu, kstat_irqs_cpu, irq_is_nmi, kstat_irqs_desc, kstat_irqs, kstat_snapshot_irqs, kstat_get_irq_since_snapshot, kstat_irqs_usr, __irq_set_lockdep_class",
          "description": "irq_set_percpu_devid 设置中断为每个CPU专用模式。irq_get_percpu_devid_partition 获取中断的亲和性掩码。kstat_incr_irq_this_cpu 增加当前CPU的中断统计计数。kstat_irqs_cpu 查询指定CPU的中断次数。irq_is_nmi 判断中断是否为NMI。kstat_irqs_desc 计算指定CPU掩码下的中断总数。kstat_snapshot_irqs 快照中断统计数据。kstat_get_irq_since_snapshot 获取自快照后的中断次数。__irq_set_lockdep_class 设置中断描述符锁的锁跟踪类别。",
          "similarity": 0.5947679281234741
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 27,
          "end_line": 127,
          "content": [
            "static int __init irq_affinity_setup(char *str)",
            "{",
            "\talloc_bootmem_cpumask_var(&irq_default_affinity);",
            "\tcpulist_parse(str, irq_default_affinity);",
            "\t/*",
            "\t * Set at least the boot cpu. We don't want to end up with",
            "\t * bugreports caused by random commandline masks",
            "\t */",
            "\tcpumask_set_cpu(smp_processor_id(), irq_default_affinity);",
            "\treturn 1;",
            "}",
            "static void __init init_irq_default_affinity(void)",
            "{",
            "\tif (!cpumask_available(irq_default_affinity))",
            "\t\tzalloc_cpumask_var(&irq_default_affinity, GFP_NOWAIT);",
            "\tif (cpumask_empty(irq_default_affinity))",
            "\t\tcpumask_setall(irq_default_affinity);",
            "}",
            "static void __init init_irq_default_affinity(void)",
            "{",
            "}",
            "static int alloc_masks(struct irq_desc *desc, int node)",
            "{",
            "\tif (!zalloc_cpumask_var_node(&desc->irq_common_data.affinity,",
            "\t\t\t\t     GFP_KERNEL, node))",
            "\t\treturn -ENOMEM;",
            "",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\tif (!zalloc_cpumask_var_node(&desc->irq_common_data.effective_affinity,",
            "\t\t\t\t     GFP_KERNEL, node)) {",
            "\t\tfree_cpumask_var(desc->irq_common_data.affinity);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\tif (!zalloc_cpumask_var_node(&desc->pending_mask, GFP_KERNEL, node)) {",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\t\tfree_cpumask_var(desc->irq_common_data.effective_affinity);",
            "#endif",
            "\t\tfree_cpumask_var(desc->irq_common_data.affinity);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}",
            "static void desc_smp_init(struct irq_desc *desc, int node,",
            "\t\t\t  const struct cpumask *affinity)",
            "{",
            "\tif (!affinity)",
            "\t\taffinity = irq_default_affinity;",
            "\tcpumask_copy(desc->irq_common_data.affinity, affinity);",
            "",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\tcpumask_clear(desc->pending_mask);",
            "#endif",
            "#ifdef CONFIG_NUMA",
            "\tdesc->irq_common_data.node = node;",
            "#endif",
            "}",
            "static void free_masks(struct irq_desc *desc)",
            "{",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\tfree_cpumask_var(desc->pending_mask);",
            "#endif",
            "\tfree_cpumask_var(desc->irq_common_data.affinity);",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\tfree_cpumask_var(desc->irq_common_data.effective_affinity);",
            "#endif",
            "}",
            "static inline int",
            "alloc_masks(struct irq_desc *desc, int node) { return 0; }",
            "static inline void",
            "desc_smp_init(struct irq_desc *desc, int node, const struct cpumask *affinity) { }",
            "static inline void free_masks(struct irq_desc *desc) { }",
            "static void desc_set_defaults(unsigned int irq, struct irq_desc *desc, int node,",
            "\t\t\t      const struct cpumask *affinity, struct module *owner)",
            "{",
            "\tint cpu;",
            "",
            "\tdesc->irq_common_data.handler_data = NULL;",
            "\tdesc->irq_common_data.msi_desc = NULL;",
            "",
            "\tdesc->irq_data.common = &desc->irq_common_data;",
            "\tdesc->irq_data.irq = irq;",
            "\tdesc->irq_data.chip = &no_irq_chip;",
            "\tdesc->irq_data.chip_data = NULL;",
            "\tirq_settings_clr_and_set(desc, ~0, _IRQ_DEFAULT_INIT_FLAGS);",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);",
            "\tdesc->handle_irq = handle_bad_irq;",
            "\tdesc->depth = 1;",
            "\tdesc->irq_count = 0;",
            "\tdesc->irqs_unhandled = 0;",
            "\tdesc->tot_count = 0;",
            "\tdesc->name = NULL;",
            "\tdesc->owner = owner;",
            "\tfor_each_possible_cpu(cpu)",
            "\t\t*per_cpu_ptr(desc->kstat_irqs, cpu) = (struct irqstat) { };",
            "\tdesc_smp_init(desc, node, affinity);",
            "}"
          ],
          "function_name": "irq_affinity_setup, init_irq_default_affinity, init_irq_default_affinity, alloc_masks, desc_smp_init, free_masks, alloc_masks, desc_smp_init, free_masks, desc_set_defaults",
          "description": "包含中断亲和性初始化与内存分配相关函数，负责设置默认CPU亲和掩码、分配irq_desc结构体的affinity字段、初始化SMP相关信息及释放相关资源。存在多处函数重载实现，体现不同配置条件下的差异化处理。",
          "similarity": 0.5450239181518555
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 562,
          "end_line": 667,
          "content": [
            "int __init early_irq_init(void)",
            "{",
            "\tint i, initcnt, node = first_online_node;",
            "\tstruct irq_desc *desc;",
            "",
            "\tinit_irq_default_affinity();",
            "",
            "\t/* Let arch update nr_irqs and return the nr of preallocated irqs */",
            "\tinitcnt = arch_probe_nr_irqs();",
            "\tprintk(KERN_INFO \"NR_IRQS: %d, nr_irqs: %d, preallocated irqs: %d\\n\",",
            "\t       NR_IRQS, nr_irqs, initcnt);",
            "",
            "\tif (WARN_ON(nr_irqs > MAX_SPARSE_IRQS))",
            "\t\tnr_irqs = MAX_SPARSE_IRQS;",
            "",
            "\tif (WARN_ON(initcnt > MAX_SPARSE_IRQS))",
            "\t\tinitcnt = MAX_SPARSE_IRQS;",
            "",
            "\tif (initcnt > nr_irqs)",
            "\t\tnr_irqs = initcnt;",
            "",
            "\tfor (i = 0; i < initcnt; i++) {",
            "\t\tdesc = alloc_desc(i, node, 0, NULL, NULL);",
            "\t\tirq_insert_desc(i, desc);",
            "\t}",
            "\treturn arch_early_irq_init();",
            "}",
            "int __init early_irq_init(void)",
            "{",
            "\tint count, i, node = first_online_node;",
            "\tint ret;",
            "",
            "\tinit_irq_default_affinity();",
            "",
            "\tprintk(KERN_INFO \"NR_IRQS: %d\\n\", NR_IRQS);",
            "",
            "\tcount = ARRAY_SIZE(irq_desc);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tret = init_desc(irq_desc + i, i, node, 0, NULL, NULL);",
            "\t\tif (unlikely(ret))",
            "\t\t\tgoto __free_desc_res;",
            "\t}",
            "",
            "\treturn arch_early_irq_init();",
            "",
            "__free_desc_res:",
            "\twhile (--i >= 0) {",
            "\t\tfree_masks(irq_desc + i);",
            "\t\tfree_percpu(irq_desc[i].kstat_irqs);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static void free_desc(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\tdesc_set_defaults(irq, desc, irq_desc_get_node(desc), NULL, NULL);",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\tdelete_irq_desc(irq);",
            "}",
            "static inline int alloc_descs(unsigned int start, unsigned int cnt, int node,",
            "\t\t\t      const struct irq_affinity_desc *affinity,",
            "\t\t\t      struct module *owner)",
            "{",
            "\tu32 i;",
            "",
            "\tfor (i = 0; i < cnt; i++) {",
            "\t\tstruct irq_desc *desc = irq_to_desc(start + i);",
            "",
            "\t\tdesc->owner = owner;",
            "\t\tirq_insert_desc(start + i, desc);",
            "\t}",
            "\treturn start;",
            "}",
            "static int irq_expand_nr_irqs(unsigned int nr)",
            "{",
            "\treturn -ENOMEM;",
            "}",
            "void irq_mark_irq(unsigned int irq)",
            "{",
            "\tmutex_lock(&sparse_irq_lock);",
            "\tirq_insert_desc(irq, irq_desc + irq);",
            "\tmutex_unlock(&sparse_irq_lock);",
            "}",
            "void irq_init_desc(unsigned int irq)",
            "{",
            "\tfree_desc(irq);",
            "}",
            "int handle_irq_desc(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *data;",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tdata = irq_desc_get_irq_data(desc);",
            "\tif (WARN_ON_ONCE(!in_hardirq() && handle_enforce_irqctx(data)))",
            "\t\treturn -EPERM;",
            "",
            "\tgeneric_handle_irq_desc(desc);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "early_irq_init, early_irq_init, free_desc, alloc_descs, irq_expand_nr_irqs, irq_mark_irq, irq_init_desc, handle_irq_desc",
          "description": "early_irq_init 初始化早期中断描述符，调用架构特定函数确定中断数量并分配初始中断描述符。free_desc 释放中断描述符并重置为其默认状态。alloc_descs 批量分配中断描述符到指定范围。irq_mark_irq 将中断标记为已初始化。irq_init_desc 初始化指定中断描述符。handle_irq_desc 处理中断描述符，检查硬中断上下文并调用通用处理函数。",
          "similarity": 0.5440912246704102
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 705,
          "end_line": 824,
          "content": [
            "int generic_handle_irq(unsigned int irq)",
            "{",
            "\treturn handle_irq_desc(irq_to_desc(irq));",
            "}",
            "int generic_handle_irq_safe(unsigned int irq)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tlocal_irq_save(flags);",
            "\tret = handle_irq_desc(irq_to_desc(irq));",
            "\tlocal_irq_restore(flags);",
            "\treturn ret;",
            "}",
            "int generic_handle_domain_irq(struct irq_domain *domain, unsigned int hwirq)",
            "{",
            "\treturn handle_irq_desc(irq_resolve_mapping(domain, hwirq));",
            "}",
            "int generic_handle_domain_irq_safe(struct irq_domain *domain, unsigned int hwirq)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tlocal_irq_save(flags);",
            "\tret = handle_irq_desc(irq_resolve_mapping(domain, hwirq));",
            "\tlocal_irq_restore(flags);",
            "\treturn ret;",
            "}",
            "int generic_handle_domain_nmi(struct irq_domain *domain, unsigned int hwirq)",
            "{",
            "\tWARN_ON_ONCE(!in_nmi());",
            "\treturn handle_irq_desc(irq_resolve_mapping(domain, hwirq));",
            "}",
            "void irq_free_descs(unsigned int from, unsigned int cnt)",
            "{",
            "\tint i;",
            "",
            "\tif (from >= nr_irqs || (from + cnt) > nr_irqs)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&sparse_irq_lock);",
            "\tfor (i = 0; i < cnt; i++)",
            "\t\tfree_desc(from + i);",
            "",
            "\tmutex_unlock(&sparse_irq_lock);",
            "}",
            "int __ref",
            "__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,",
            "\t\t  struct module *owner, const struct irq_affinity_desc *affinity)",
            "{",
            "\tint start, ret;",
            "",
            "\tif (!cnt)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (irq >= 0) {",
            "\t\tif (from > irq)",
            "\t\t\treturn -EINVAL;",
            "\t\tfrom = irq;",
            "\t} else {",
            "\t\t/*",
            "\t\t * For interrupts which are freely allocated the",
            "\t\t * architecture can force a lower bound to the @from",
            "\t\t * argument. x86 uses this to exclude the GSI space.",
            "\t\t */",
            "\t\tfrom = arch_dynirq_lower_bound(from);",
            "\t}",
            "",
            "\tmutex_lock(&sparse_irq_lock);",
            "",
            "\tstart = irq_find_free_area(from, cnt);",
            "\tret = -EEXIST;",
            "\tif (irq >=0 && start != irq)",
            "\t\tgoto unlock;",
            "",
            "\tif (start + cnt > nr_irqs) {",
            "\t\tret = irq_expand_nr_irqs(start + cnt);",
            "\t\tif (ret)",
            "\t\t\tgoto unlock;",
            "\t}",
            "\tret = alloc_descs(start, cnt, node, affinity, owner);",
            "unlock:",
            "\tmutex_unlock(&sparse_irq_lock);",
            "\treturn ret;",
            "}",
            "unsigned int irq_get_next_irq(unsigned int offset)",
            "{",
            "\treturn irq_find_at_or_after(offset);",
            "}",
            "void __irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags, bool bus)",
            "\t__releases(&desc->lock)",
            "{",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\tif (bus)",
            "\t\tchip_bus_sync_unlock(desc);",
            "}",
            "int irq_set_percpu_devid_partition(unsigned int irq,",
            "\t\t\t\t   const struct cpumask *affinity)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (desc->percpu_enabled)",
            "\t\treturn -EINVAL;",
            "",
            "\tdesc->percpu_enabled = kzalloc(sizeof(*desc->percpu_enabled), GFP_KERNEL);",
            "",
            "\tif (!desc->percpu_enabled)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (affinity)",
            "\t\tdesc->percpu_affinity = affinity;",
            "\telse",
            "\t\tdesc->percpu_affinity = cpu_possible_mask;",
            "",
            "\tirq_set_percpu_devid_flags(irq);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "generic_handle_irq, generic_handle_irq_safe, generic_handle_domain_irq, generic_handle_domain_irq_safe, generic_handle_domain_nmi, irq_free_descs, __irq_alloc_descs, irq_get_next_irq, __irq_put_desc_unlock, irq_set_percpu_devid_partition",
          "description": "generic_handle_irq 安全处理通用中断，调用handle_irq_desc。generic_handle_domain_irq 处理IRQ domain映射的硬件中断。irq_free_descs 释放指定范围的中断描述符。__irq_alloc_descs 动态分配连续中断号并初始化描述符。irq_get_next_irq 获取下一个可用中断号。__irq_put_desc_unlock 解锁中断描述符并同步总线。irq_set_percpu_devid_partition 设置中断亲和性分区。",
          "similarity": 0.5413433909416199
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 422,
          "end_line": 523,
          "content": [
            "static void irq_sysfs_add(int irq, struct irq_desc *desc) {}",
            "static void irq_sysfs_del(struct irq_desc *desc) {}",
            "void irq_lock_sparse(void)",
            "{",
            "\tmutex_lock(&sparse_irq_lock);",
            "}",
            "void irq_unlock_sparse(void)",
            "{",
            "\tmutex_unlock(&sparse_irq_lock);",
            "}",
            "static void irq_kobj_release(struct kobject *kobj)",
            "{",
            "\tstruct irq_desc *desc = container_of(kobj, struct irq_desc, kobj);",
            "",
            "\tfree_masks(desc);",
            "\tfree_percpu(desc->kstat_irqs);",
            "\tkfree(desc);",
            "}",
            "static void delayed_free_desc(struct rcu_head *rhp)",
            "{",
            "\tstruct irq_desc *desc = container_of(rhp, struct irq_desc, rcu);",
            "",
            "\tkobject_put(&desc->kobj);",
            "}",
            "static void free_desc(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tirq_remove_debugfs_entry(desc);",
            "\tunregister_irq_proc(irq, desc);",
            "",
            "\t/*",
            "\t * sparse_irq_lock protects also show_interrupts() and",
            "\t * kstat_irq_usr(). Once we deleted the descriptor from the",
            "\t * sparse tree we can free it. Access in proc will fail to",
            "\t * lookup the descriptor.",
            "\t *",
            "\t * The sysfs entry must be serialized against a concurrent",
            "\t * irq_sysfs_init() as well.",
            "\t */",
            "\tirq_sysfs_del(desc);",
            "\tdelete_irq_desc(irq);",
            "",
            "\t/*",
            "\t * We free the descriptor, masks and stat fields via RCU. That",
            "\t * allows demultiplex interrupts to do rcu based management of",
            "\t * the child interrupts.",
            "\t * This also allows us to use rcu in kstat_irqs_usr().",
            "\t */",
            "\tcall_rcu(&desc->rcu, delayed_free_desc);",
            "}",
            "static int alloc_descs(unsigned int start, unsigned int cnt, int node,",
            "\t\t       const struct irq_affinity_desc *affinity,",
            "\t\t       struct module *owner)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint i;",
            "",
            "\t/* Validate affinity mask(s) */",
            "\tif (affinity) {",
            "\t\tfor (i = 0; i < cnt; i++) {",
            "\t\t\tif (cpumask_empty(&affinity[i].mask))",
            "\t\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\tfor (i = 0; i < cnt; i++) {",
            "\t\tconst struct cpumask *mask = NULL;",
            "\t\tunsigned int flags = 0;",
            "",
            "\t\tif (affinity) {",
            "\t\t\tif (affinity->is_managed) {",
            "\t\t\t\tflags = IRQD_AFFINITY_MANAGED |",
            "\t\t\t\t\tIRQD_MANAGED_SHUTDOWN;",
            "\t\t\t}",
            "\t\t\tflags |= IRQD_AFFINITY_SET;",
            "\t\t\tmask = &affinity->mask;",
            "\t\t\tnode = cpu_to_node(cpumask_first(mask));",
            "\t\t\taffinity++;",
            "\t\t}",
            "",
            "\t\tdesc = alloc_desc(start + i, node, flags, mask, owner);",
            "\t\tif (!desc)",
            "\t\t\tgoto err;",
            "\t\tirq_insert_desc(start + i, desc);",
            "\t\tirq_sysfs_add(start + i, desc);",
            "\t\tirq_add_debugfs_entry(start + i, desc);",
            "\t}",
            "\treturn start;",
            "",
            "err:",
            "\tfor (i--; i >= 0; i--)",
            "\t\tfree_desc(start + i);",
            "\treturn -ENOMEM;",
            "}",
            "static int irq_expand_nr_irqs(unsigned int nr)",
            "{",
            "\tif (nr > MAX_SPARSE_IRQS)",
            "\t\treturn -ENOMEM;",
            "\tnr_irqs = nr;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "irq_sysfs_add, irq_sysfs_del, irq_lock_sparse, irq_unlock_sparse, irq_kobj_release, delayed_free_desc, free_desc, alloc_descs, irq_expand_nr_irqs",
          "description": "包含中断描述符的延迟释放机制与批量分配逻辑，利用RCU机制安全释放资源，实现中断描述符的动态扩展与回收，支持多CPU环境下对中断资源的高效管理。",
          "similarity": 0.5274339914321899
        }
      ]
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5845195651054382,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5347417593002319
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.5184036493301392
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.48938459157943726
        }
      ]
    }
  ]
}