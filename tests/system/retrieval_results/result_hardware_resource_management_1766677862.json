{
  "query": "hardware resource management",
  "timestamp": "2025-12-25 23:51:02",
  "retrieved_files": [
    {
      "source_file": "kernel/cgroup/rdma.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:50:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\rdma.c`\n\n---\n\n# cgroup/rdma.c 技术文档\n\n## 文件概述\n\n`cgroup/rdma.c` 实现了 RDMA（Remote Direct Memory Access）资源限制控制器，作为 cgroup 子系统的一部分。该模块用于限制 cgroup 层级结构中的进程在达到指定资源上限后无法继续消耗额外的 RDMA 资源。通过为每个 cgroup 和每个 RDMA 设备维护资源池，实现对 RDMA 资源（如 HCA 句柄和对象）的精细化配额管理与层级化计费（charge/uncharge）。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`rdmacg_resource`**  \n  表示单个 RDMA 资源类型的使用情况，包含 `max`（最大限额）和 `usage`（当前使用量）。\n\n- **`rdmacg_resource_pool`**  \n  表示一个 cgroup 在特定 RDMA 设备上的资源池，包含：\n  - 指向 `rdmacg_device` 的指针\n  - 各类资源的 `rdmacg_resource` 数组\n  - 双向链表节点（分别链接到 cgroup 和设备的资源池列表）\n  - `usage_sum`：该池中所有资源的总使用计数\n  - `num_max_cnt`：设置为 `S32_MAX`（即无限制）的资源项数量\n\n- **`rdmacg_resource_names`**  \n  用户可见的资源名称映射表，当前支持：\n  - `\"hca_handle\"` → `RDMACG_RESOURCE_HCA_HANDLE`\n  - `\"hca_object\"` → `RDMACG_RESOURCE_HCA_OBJECT`\n\n### 主要函数\n\n- **`rdmacg_try_charge()`**  \n  尝试在 cgroup 层级中为指定 RDMA 设备和资源类型进行资源计费。从当前 cgroup 向上遍历至根，逐级检查并增加使用量。若任一层级超出限额，则回滚并返回 `-EAGAIN`。\n\n- **`rdmacg_uncharge()`**  \n  在 cgroup 层级中释放指定资源的使用量，从当前 cgroup 向上遍历至根，逐级减少使用量。\n\n- **`rdmacg_uncharge_hierarchy()`**  \n  支持在指定停止点（`stop_cg`）前的层级范围内执行资源释放，用于更灵活的资源回收场景。\n\n- **`get_cg_rpool_locked()` / `find_cg_rpool_locked()`**  \n  在加锁状态下查找或创建指定 cgroup 与设备对应的资源池。\n\n- **`free_cg_rpool_locked()`**  \n  当资源池的 `usage_sum` 为 0 且所有资源均设为 `max`（即未显式限制）时，安全释放该资源池。\n\n## 关键实现\n\n### 层级化资源计费机制\n\nRDMA cgroup 采用**自底向上计费、自顶向下限制**的策略：\n- **计费（charge）**：从当前任务所属 cgroup 开始，逐级向上（至根 cgroup）尝试增加资源使用量。任一祖先 cgroup 超限即失败。\n- **释放（uncharge）**：同样沿层级向上释放，确保资源使用量始终反映实际占用。\n\n### 资源池生命周期管理\n\n- 每个 `(cgroup, device)` 对应一个 `rdmacg_resource_pool`。\n- 资源池在首次计费时按需创建（`get_cg_rpool_locked`）。\n- 当 `usage_sum == 0` 且所有资源项均为 `max`（即无显式限制）时，自动释放资源池以节省内存。\n\n### 限额表示\n\n- 使用 `S32_MAX` 表示“无限制”（即 `max` 值）。\n- `num_max_cnt` 用于快速判断是否所有资源均为无限制状态，从而决定是否可安全释放资源池。\n\n### 并发控制\n\n- 全局互斥锁 `rdmacg_mutex` 保护：\n  - 所有 cgroup 的资源池链表（`cg->rpools`）\n  - 所有 RDMA 设备的资源池链表（`device->rpools`）\n  - 全局设备列表 `rdmacg_devices`\n- 所有资源池操作（创建、查找、释放）均在锁保护下进行。\n\n## 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/cgroup.h>`：cgroup 核心框架\n  - `<linux/cgroup_rdma.h>`：RDMA cgroup 接口定义（如 `rdma_cgroup`、`rdmacg_device` 等）\n  - `<linux/ib_verbs.h>`（隐含）：RDMA 资源类型定义（如 `RDMACG_RESOURCE_HCA_HANDLE`）\n- **导出符号**：\n  - `rdmacg_uncharge()`：供 RDMA 驱动（如 InfiniBand、RoCE 驱动）在释放资源时调用\n- **cgroup 子系统集成**：\n  - 通过 `rdma_cgrp_id` 获取当前任务的 cgroup 上下文\n  - 依赖 cgroup 的层级遍历机制（`css.parent`）\n\n## 使用场景\n\n1. **RDMA 驱动资源分配**  \n   当用户空间应用通过 verbs API 创建 QP、CQ、MR 等对象时，底层驱动调用 `rdmacg_try_charge()` 检查是否允许分配。若成功，则在对象销毁时调用 `rdmacg_uncharge()` 释放配额。\n\n2. **多租户 RDMA 资源隔离**  \n   在容器化或虚拟化环境中，管理员可通过 cgroup v1/v2 接口为不同租户设置 RDMA 资源上限（如最大 HCA 对象数），防止资源耗尽攻击。\n\n3. **动态资源回收**  \n   当 cgroup 中所有任务退出且无 RDMA 资源占用时，自动清理对应的资源池，避免内存泄漏。\n\n4. **层级配额继承**  \n   子 cgroup 的资源使用量计入所有祖先 cgroup，确保父级配额对整个子树生效，实现严格的资源隔离。",
      "similarity": 0.5684353709220886,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 316,
          "end_line": 464,
          "content": [
            "void rdmacg_register_device(struct rdmacg_device *device)",
            "{",
            "\tINIT_LIST_HEAD(&device->dev_node);",
            "\tINIT_LIST_HEAD(&device->rpools);",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "\tlist_add_tail(&device->dev_node, &rdmacg_devices);",
            "\tmutex_unlock(&rdmacg_mutex);",
            "}",
            "void rdmacg_unregister_device(struct rdmacg_device *device)",
            "{",
            "\tstruct rdmacg_resource_pool *rpool, *tmp;",
            "",
            "\t/*",
            "\t * Synchronize with any active resource settings,",
            "\t * usage query happening via configfs.",
            "\t */",
            "\tmutex_lock(&rdmacg_mutex);",
            "\tlist_del_init(&device->dev_node);",
            "",
            "\t/*",
            "\t * Now that this device is off the cgroup list, its safe to free",
            "\t * all the rpool resources.",
            "\t */",
            "\tlist_for_each_entry_safe(rpool, tmp, &device->rpools, dev_node)",
            "\t\tfree_cg_rpool_locked(rpool);",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "}",
            "static int parse_resource(char *c, int *intval)",
            "{",
            "\tsubstring_t argstr;",
            "\tchar *name, *value = c;",
            "\tsize_t len;",
            "\tint ret, i;",
            "",
            "\tname = strsep(&value, \"=\");",
            "\tif (!name || !value)",
            "\t\treturn -EINVAL;",
            "",
            "\ti = match_string(rdmacg_resource_names, RDMACG_RESOURCE_MAX, name);",
            "\tif (i < 0)",
            "\t\treturn i;",
            "",
            "\tlen = strlen(value);",
            "",
            "\targstr.from = value;",
            "\targstr.to = value + len;",
            "",
            "\tret = match_int(&argstr, intval);",
            "\tif (ret >= 0) {",
            "\t\tif (*intval < 0)",
            "\t\t\treturn -EINVAL;",
            "\t\treturn i;",
            "\t}",
            "\tif (strncmp(value, RDMACG_MAX_STR, len) == 0) {",
            "\t\t*intval = S32_MAX;",
            "\t\treturn i;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static int rdmacg_parse_limits(char *options,",
            "\t\t\t       int *new_limits, unsigned long *enables)",
            "{",
            "\tchar *c;",
            "\tint err = -EINVAL;",
            "",
            "\t/* parse resource options */",
            "\twhile ((c = strsep(&options, \" \")) != NULL) {",
            "\t\tint index, intval;",
            "",
            "\t\tindex = parse_resource(c, &intval);",
            "\t\tif (index < 0)",
            "\t\t\tgoto err;",
            "",
            "\t\tnew_limits[index] = intval;",
            "\t\t*enables |= BIT(index);",
            "\t}",
            "\treturn 0;",
            "",
            "err:",
            "\treturn err;",
            "}",
            "static ssize_t rdmacg_resource_set_max(struct kernfs_open_file *of,",
            "\t\t\t\t       char *buf, size_t nbytes, loff_t off)",
            "{",
            "\tstruct rdma_cgroup *cg = css_rdmacg(of_css(of));",
            "\tconst char *dev_name;",
            "\tstruct rdmacg_resource_pool *rpool;",
            "\tstruct rdmacg_device *device;",
            "\tchar *options = strstrip(buf);",
            "\tint *new_limits;",
            "\tunsigned long enables = 0;",
            "\tint i = 0, ret = 0;",
            "",
            "\t/* extract the device name first */",
            "\tdev_name = strsep(&options, \" \");",
            "\tif (!dev_name) {",
            "\t\tret = -EINVAL;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tnew_limits = kcalloc(RDMACG_RESOURCE_MAX, sizeof(int), GFP_KERNEL);",
            "\tif (!new_limits) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tret = rdmacg_parse_limits(options, new_limits, &enables);",
            "\tif (ret)",
            "\t\tgoto parse_err;",
            "",
            "\t/* acquire lock to synchronize with hot plug devices */",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tdevice = rdmacg_get_device_locked(dev_name);",
            "\tif (!device) {",
            "\t\tret = -ENODEV;",
            "\t\tgoto dev_err;",
            "\t}",
            "",
            "\trpool = get_cg_rpool_locked(cg, device);",
            "\tif (IS_ERR(rpool)) {",
            "\t\tret = PTR_ERR(rpool);",
            "\t\tgoto dev_err;",
            "\t}",
            "",
            "\t/* now set the new limits of the rpool */",
            "\tfor_each_set_bit(i, &enables, RDMACG_RESOURCE_MAX)",
            "\t\tset_resource_limit(rpool, i, new_limits[i]);",
            "",
            "\tif (rpool->usage_sum == 0 &&",
            "\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {",
            "\t\t/*",
            "\t\t * No user of the rpool and all entries are set to max, so",
            "\t\t * safe to delete this rpool.",
            "\t\t */",
            "\t\tfree_cg_rpool_locked(rpool);",
            "\t}",
            "",
            "dev_err:",
            "\tmutex_unlock(&rdmacg_mutex);",
            "",
            "parse_err:",
            "\tkfree(new_limits);",
            "",
            "err:",
            "\treturn ret ?: nbytes;",
            "}"
          ],
          "function_name": "rdmacg_register_device, rdmacg_unregister_device, parse_resource, rdmacg_parse_limits, rdmacg_resource_set_max",
          "description": "实现设备注册注销流程、资源参数解析及限制设置功能，通过parse_resource解析资源名与数值，rdmacg_parse_limits组织限制定义，rdmacg_resource_set_max应用新限制并触发资源池清理。",
          "similarity": 0.6228137612342834
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 82,
          "end_line": 214,
          "content": [
            "static void set_resource_limit(struct rdmacg_resource_pool *rpool,",
            "\t\t\t       int index, int new_max)",
            "{",
            "\tif (new_max == S32_MAX) {",
            "\t\tif (rpool->resources[index].max != S32_MAX)",
            "\t\t\trpool->num_max_cnt++;",
            "\t} else {",
            "\t\tif (rpool->resources[index].max == S32_MAX)",
            "\t\t\trpool->num_max_cnt--;",
            "\t}",
            "\trpool->resources[index].max = new_max;",
            "}",
            "static void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)",
            "\t\tset_resource_limit(rpool, i, S32_MAX);",
            "}",
            "static void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)",
            "{",
            "\tlockdep_assert_held(&rdmacg_mutex);",
            "",
            "\tlist_del(&rpool->cg_node);",
            "\tlist_del(&rpool->dev_node);",
            "\tkfree(rpool);",
            "}",
            "static void",
            "uncharge_cg_locked(struct rdma_cgroup *cg,",
            "\t\t   struct rdmacg_device *device,",
            "\t\t   enum rdmacg_resource_type index)",
            "{",
            "\tstruct rdmacg_resource_pool *rpool;",
            "",
            "\trpool = find_cg_rpool_locked(cg, device);",
            "",
            "\t/*",
            "\t * rpool cannot be null at this stage. Let kernel operate in case",
            "\t * if there a bug in IB stack or rdma controller, instead of crashing",
            "\t * the system.",
            "\t */",
            "\tif (unlikely(!rpool)) {",
            "\t\tpr_warn(\"Invalid device %p or rdma cgroup %p\\n\", cg, device);",
            "\t\treturn;",
            "\t}",
            "",
            "\trpool->resources[index].usage--;",
            "",
            "\t/*",
            "\t * A negative count (or overflow) is invalid,",
            "\t * it indicates a bug in the rdma controller.",
            "\t */",
            "\tWARN_ON_ONCE(rpool->resources[index].usage < 0);",
            "\trpool->usage_sum--;",
            "\tif (rpool->usage_sum == 0 &&",
            "\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {",
            "\t\t/*",
            "\t\t * No user of the rpool and all entries are set to max, so",
            "\t\t * safe to delete this rpool.",
            "\t\t */",
            "\t\tfree_cg_rpool_locked(rpool);",
            "\t}",
            "}",
            "static void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,",
            "\t\t\t\t     struct rdmacg_device *device,",
            "\t\t\t\t     struct rdma_cgroup *stop_cg,",
            "\t\t\t\t     enum rdmacg_resource_type index)",
            "{",
            "\tstruct rdma_cgroup *p;",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))",
            "\t\tuncharge_cg_locked(p, device, index);",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "",
            "\tcss_put(&cg->css);",
            "}",
            "void rdmacg_uncharge(struct rdma_cgroup *cg,",
            "\t\t     struct rdmacg_device *device,",
            "\t\t     enum rdmacg_resource_type index)",
            "{",
            "\tif (index >= RDMACG_RESOURCE_MAX)",
            "\t\treturn;",
            "",
            "\trdmacg_uncharge_hierarchy(cg, device, NULL, index);",
            "}",
            "int rdmacg_try_charge(struct rdma_cgroup **rdmacg,",
            "\t\t      struct rdmacg_device *device,",
            "\t\t      enum rdmacg_resource_type index)",
            "{",
            "\tstruct rdma_cgroup *cg, *p;",
            "\tstruct rdmacg_resource_pool *rpool;",
            "\ts64 new;",
            "\tint ret = 0;",
            "",
            "\tif (index >= RDMACG_RESOURCE_MAX)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * hold on to css, as cgroup can be removed but resource",
            "\t * accounting happens on css.",
            "\t */",
            "\tcg = get_current_rdmacg();",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "\tfor (p = cg; p; p = parent_rdmacg(p)) {",
            "\t\trpool = get_cg_rpool_locked(p, device);",
            "\t\tif (IS_ERR(rpool)) {",
            "\t\t\tret = PTR_ERR(rpool);",
            "\t\t\tgoto err;",
            "\t\t} else {",
            "\t\t\tnew = rpool->resources[index].usage + 1;",
            "\t\t\tif (new > rpool->resources[index].max) {",
            "\t\t\t\tret = -EAGAIN;",
            "\t\t\t\tgoto err;",
            "\t\t\t} else {",
            "\t\t\t\trpool->resources[index].usage = new;",
            "\t\t\t\trpool->usage_sum++;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&rdmacg_mutex);",
            "",
            "\t*rdmacg = cg;",
            "\treturn 0;",
            "",
            "err:",
            "\tmutex_unlock(&rdmacg_mutex);",
            "\trdmacg_uncharge_hierarchy(cg, device, p, index);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "set_resource_limit, set_all_resource_max_limit, free_cg_rpool_locked, uncharge_cg_locked, rdmacg_uncharge_hierarchy, rdmacg_uncharge, rdmacg_try_charge",
          "description": "实现资源限制调整、资源释放及充电逻辑，包含设置资源上限、释放资源池、递归层级资源释放、尝试充电检查及错误恢复机制，维护资源使用计数和最大值统计。",
          "similarity": 0.5698589086532593
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 1,
          "end_line": 81,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * RDMA resource limiting controller for cgroups.",
            " *",
            " * Used to allow a cgroup hierarchy to stop processes from consuming",
            " * additional RDMA resources after a certain limit is reached.",
            " *",
            " * Copyright (C) 2016 Parav Pandit <pandit.parav@gmail.com>",
            " */",
            "",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup_rdma.h>",
            "",
            "#define RDMACG_MAX_STR \"max\"",
            "",
            "/*",
            " * Protects list of resource pools maintained on per cgroup basis",
            " * and rdma device list.",
            " */",
            "static DEFINE_MUTEX(rdmacg_mutex);",
            "static LIST_HEAD(rdmacg_devices);",
            "",
            "enum rdmacg_file_type {",
            "\tRDMACG_RESOURCE_TYPE_MAX,",
            "\tRDMACG_RESOURCE_TYPE_STAT,",
            "};",
            "",
            "/*",
            " * resource table definition as to be seen by the user.",
            " * Need to add entries to it when more resources are",
            " * added/defined at IB verb/core layer.",
            " */",
            "static char const *rdmacg_resource_names[] = {",
            "\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",",
            "\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",",
            "};",
            "",
            "/* resource tracker for each resource of rdma cgroup */",
            "struct rdmacg_resource {",
            "\tint max;",
            "\tint usage;",
            "};",
            "",
            "/*",
            " * resource pool object which represents per cgroup, per device",
            " * resources. There are multiple instances of this object per cgroup,",
            " * therefore it cannot be embedded within rdma_cgroup structure. It",
            " * is maintained as list.",
            " */",
            "struct rdmacg_resource_pool {",
            "\tstruct rdmacg_device\t*device;",
            "\tstruct rdmacg_resource\tresources[RDMACG_RESOURCE_MAX];",
            "",
            "\tstruct list_head\tcg_node;",
            "\tstruct list_head\tdev_node;",
            "",
            "\t/* count active user tasks of this pool */",
            "\tu64\t\t\tusage_sum;",
            "\t/* total number counts which are set to max */",
            "\tint\t\t\tnum_max_cnt;",
            "};",
            "",
            "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)",
            "{",
            "\treturn container_of(css, struct rdma_cgroup, css);",
            "}",
            "",
            "static struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)",
            "{",
            "\treturn css_rdmacg(cg->css.parent);",
            "}",
            "",
            "static inline struct rdma_cgroup *get_current_rdmacg(void)",
            "{",
            "\treturn css_rdmacg(task_get_css(current, rdma_cgrp_id));",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义RDMA cgroup资源管理的基础结构，包括互斥锁保护的设备列表、资源类型枚举、资源名称映射及rdmacg_resource_pool结构体，提供从css获取rdma_cgroup的辅助函数。",
          "similarity": 0.5465108752250671
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 494,
          "end_line": 562,
          "content": [
            "static void print_rpool_values(struct seq_file *sf,",
            "\t\t\t       struct rdmacg_resource_pool *rpool)",
            "{",
            "\tenum rdmacg_file_type sf_type;",
            "\tint i;",
            "\tu32 value;",
            "",
            "\tsf_type = seq_cft(sf)->private;",
            "",
            "\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++) {",
            "\t\tseq_puts(sf, rdmacg_resource_names[i]);",
            "\t\tseq_putc(sf, '=');",
            "\t\tif (sf_type == RDMACG_RESOURCE_TYPE_MAX) {",
            "\t\t\tif (rpool)",
            "\t\t\t\tvalue = rpool->resources[i].max;",
            "\t\t\telse",
            "\t\t\t\tvalue = S32_MAX;",
            "\t\t} else {",
            "\t\t\tif (rpool)",
            "\t\t\t\tvalue = rpool->resources[i].usage;",
            "\t\t\telse",
            "\t\t\t\tvalue = 0;",
            "\t\t}",
            "",
            "\t\tif (value == S32_MAX)",
            "\t\t\tseq_puts(sf, RDMACG_MAX_STR);",
            "\t\telse",
            "\t\t\tseq_printf(sf, \"%d\", value);",
            "\t\tseq_putc(sf, ' ');",
            "\t}",
            "}",
            "static int rdmacg_resource_read(struct seq_file *sf, void *v)",
            "{",
            "\tstruct rdmacg_device *device;",
            "\tstruct rdmacg_resource_pool *rpool;",
            "\tstruct rdma_cgroup *cg = css_rdmacg(seq_css(sf));",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tlist_for_each_entry(device, &rdmacg_devices, dev_node) {",
            "\t\tseq_printf(sf, \"%s \", device->name);",
            "",
            "\t\trpool = find_cg_rpool_locked(cg, device);",
            "\t\tprint_rpool_values(sf, rpool);",
            "",
            "\t\tseq_putc(sf, '\\n');",
            "\t}",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "\treturn 0;",
            "}",
            "static void rdmacg_css_free(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct rdma_cgroup *cg = css_rdmacg(css);",
            "",
            "\tkfree(cg);",
            "}",
            "static void rdmacg_css_offline(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct rdma_cgroup *cg = css_rdmacg(css);",
            "\tstruct rdmacg_resource_pool *rpool;",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tlist_for_each_entry(rpool, &cg->rpools, cg_node)",
            "\t\tset_all_resource_max_limit(rpool);",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "}"
          ],
          "function_name": "print_rpool_values, rdmacg_resource_read, rdmacg_css_free, rdmacg_css_offline",
          "description": "实现资源状态序列化输出、CSS销毁时资源强制设为最大及子系统离线处理，包含资源使用量打印函数和cgroup子系统状态清理逻辑。",
          "similarity": 0.5212047696113586
        }
      ]
    },
    {
      "source_file": "kernel/sched/rt.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:14:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\rt.c`\n\n---\n\n# `sched/rt.c` 技术文档\n\n## 1. 文件概述\n\n`sched/rt.c` 是 Linux 内核调度子系统中实现实时（Real-Time, RT）调度类的核心文件，主要支持 `SCHED_FIFO` 和 `SCHED_RR` 两种 POSIX 实时调度策略。该文件负责管理实时任务的运行队列、优先级调度、时间片分配、带宽限制（RT throttling）以及在多核系统（SMP）下的负载均衡机制。此外，它还提供了对实时任务组调度（RT Group Scheduling）的支持，允许通过 cgroups 对实时任务的 CPU 使用进行资源控制。\n\n## 2. 核心功能\n\n### 全局变量\n- `sched_rr_timeslice`：定义 `SCHED_RR` 策略的默认时间片长度（单位：调度 tick）。\n- `max_rt_runtime`：实时任务在单个周期内可使用的最大运行时间上限（通常为 4 小时以上）。\n- `sysctl_sched_rt_period`：实时带宽控制的周期，默认为 1,000,000 微秒（1 秒）。\n- `sysctl_sched_rt_runtime`：每个周期内允许实时任务运行的时间，默认为 950,000 微秒（0.95 秒）。\n\n### sysctl 接口（`CONFIG_SYSCTL` 启用时）\n- `/proc/sys/kernel/sched_rt_period_us`：设置 RT 带宽控制周期。\n- `/proc/sys/kernel/sched_rt_runtime_us`：设置 RT 带宽控制运行时间（可设为 -1 表示无限制）。\n- `/proc/sys/kernel/sched_rr_timeslice_ms`：设置 `SCHED_RR` 时间片（毫秒）。\n\n### 主要函数\n- `init_rt_rq(struct rt_rq *rt_rq)`：初始化实时运行队列（`rt_rq`），包括优先级位图、链表、SMP 相关字段及带宽控制状态。\n- `init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)`：初始化 RT 带宽控制结构，配置高精度定时器。\n- `sched_rt_period_timer(struct hrtimer *timer)`：高精度定时器回调函数，用于周期性重置 RT 运行时间配额。\n- `start_rt_bandwidth(struct rt_bandwidth *rt_b)`：启动 RT 带宽控制定时器。\n- `alloc_rt_sched_group / free_rt_sched_group / unregister_rt_sched_group`：管理实时任务组（task group）的资源分配与释放。\n- `init_tg_rt_entry`：初始化任务组在指定 CPU 上的 RT 调度实体和运行队列。\n- `rt_task_of / rq_of_rt_rq / rt_rq_of_se / rq_of_rt_se`：辅助函数，用于在调度实体、任务、运行队列和 CPU 队列之间相互转换。\n\n### SMP 支持函数（`CONFIG_SMP` 启用时）\n- `need_pull_rt_task`：判断是否需要从其他 CPU 拉取高优先级 RT 任务。\n- `rt_overloaded` / `rt_set_overload`：用于跟踪系统中是否存在过载的 RT 运行队列，支持 RT 任务迁移。\n\n## 3. 关键实现\n\n### 实时运行队列（`rt_rq`）管理\n- 使用 `rt_prio_array` 结构维护 0 到 `MAX_RT_PRIO-1`（通常为 99）共 100 个优先级的双向链表。\n- 通过位图（`bitmap`）快速查找最高优先级的可运行任务，`__set_bit(MAX_RT_PRIO, bitmap)` 作为位图搜索的终止标记。\n- `rt_queued` 标志表示是否有 RT 任务入队；`highest_prio.curr/next` 跟踪当前和下一个最高优先级（SMP 专用）。\n\n### RT 带宽控制（Throttling）\n- 通过 `rt_bandwidth` 结构限制 RT 任务在每个 `rt_period` 内最多使用 `rt_runtime` 的 CPU 时间。\n- 使用高精度定时器（`hrtimer`）实现周期性重置：每经过 `rt_period`，将 `rt_time` 清零并解除 throttling。\n- 若 `rt_runtime == RUNTIME_INF`（即 -1），则禁用带宽限制。\n- 定时器回调 `sched_rt_period_timer` 支持处理定时器 overrun（跳过多个周期），确保带宽控制的准确性。\n\n### RT 任务组调度（`CONFIG_RT_GROUP_SCHED`）\n- 每个 `task_group` 拥有 per-CPU 的 `rt_rq` 和 `sched_rt_entity`。\n- 根叶节点（普通任务）的 `rt_se` 直接链接到 CPU 的全局 `rt_rq`；非叶节点（cgroup）的 `rt_se` 链接到父组的 `rt_rq`，形成调度树。\n- `rt_entity_is_task()` 用于区分调度实体是任务还是任务组。\n\n### SMP 负载均衡\n- 当某 CPU 上运行的 RT 任务优先级降低（如被抢占或阻塞），若其当前最高优先级高于刚被替换的任务，则触发 `need_pull_rt_task`，尝试从其他 CPU 拉取更高优先级的 RT 任务。\n- `overloaded` 标志和 `pushable_tasks` 链表用于支持 RT 任务的主动推送（push）和拉取（pull）机制，确保高优先级任务尽快运行。\n\n## 4. 依赖关系\n\n- **调度核心**：依赖 `kernel/sched/core.c` 提供的通用调度框架、运行队列（`rq`）结构和调度类注册机制。\n- **高精度定时器**：使用 `kernel/time/hrtimer.c` 实现 RT 带宽控制的周期性重置。\n- **SMP 调度**：与 `kernel/sched/topology.c` 和 `kernel/sched/fair.c` 协同实现跨 CPU 的 RT 任务迁移。\n- **cgroups**：当启用 `CONFIG_RT_GROUP_SCHED` 时，与 `kernel/cgroup/` 子系统集成，支持基于 cgroup v1/v2 的 RT 带宽分配。\n- **sysctl**：通过 `kernel/sysctl.c` 暴露运行时可调参数。\n\n## 5. 使用场景\n\n- **实时应用调度**：为音视频处理、工业控制、机器人等需要确定性延迟的应用提供 `SCHED_FIFO`/`SCHED_RR` 调度支持。\n- **系统资源保护**：通过 `sched_rt_runtime_us` 限制 RT 任务的 CPU 占用率（默认 95%），防止其独占 CPU 导致系统僵死。\n- **多租户 RT 资源隔离**：在容器或虚拟化环境中，利用 RT 任务组调度为不同租户分配独立的 RT 带宽配额。\n- **SMP 实时性能优化**：在多核系统中，通过 RT 任务迁移机制减少高优先级任务的调度延迟，提升实时响应能力。",
      "similarity": 0.5600898265838623,
      "chunks": [
        {
          "chunk_id": 13,
          "file_path": "kernel/sched/rt.c",
          "start_line": 1776,
          "end_line": 1992,
          "content": [
            "static int pick_rt_task(struct rq *rq, struct task_struct *p, int cpu)",
            "{",
            "\tif (!task_on_cpu(rq, p) &&",
            "\t    cpumask_test_cpu(cpu, &p->cpus_mask))",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int find_lowest_rq(struct task_struct *task)",
            "{",
            "\tstruct sched_domain *sd;",
            "\tstruct cpumask *lowest_mask = this_cpu_cpumask_var_ptr(local_cpu_mask);",
            "\tint this_cpu = smp_processor_id();",
            "\tint cpu      = task_cpu(task);",
            "\tint ret;",
            "",
            "\t/* Make sure the mask is initialized first */",
            "\tif (unlikely(!lowest_mask))",
            "\t\treturn -1;",
            "",
            "\tif (task->nr_cpus_allowed == 1)",
            "\t\treturn -1; /* No other targets possible */",
            "",
            "\t/*",
            "\t * If we're on asym system ensure we consider the different capacities",
            "\t * of the CPUs when searching for the lowest_mask.",
            "\t */",
            "\tif (sched_asym_cpucap_active()) {",
            "",
            "\t\tret = cpupri_find_fitness(&task_rq(task)->rd->cpupri,",
            "\t\t\t\t\t  task, lowest_mask,",
            "\t\t\t\t\t  rt_task_fits_capacity);",
            "\t} else {",
            "",
            "\t\tret = cpupri_find(&task_rq(task)->rd->cpupri,",
            "\t\t\t\t  task, lowest_mask);",
            "\t}",
            "",
            "\tif (!ret)",
            "\t\treturn -1; /* No targets found */",
            "",
            "\t/*",
            "\t * At this point we have built a mask of CPUs representing the",
            "\t * lowest priority tasks in the system.  Now we want to elect",
            "\t * the best one based on our affinity and topology.",
            "\t *",
            "\t * We prioritize the last CPU that the task executed on since",
            "\t * it is most likely cache-hot in that location.",
            "\t */",
            "\tif (cpumask_test_cpu(cpu, lowest_mask))",
            "\t\treturn cpu;",
            "",
            "\t/*",
            "\t * Otherwise, we consult the sched_domains span maps to figure",
            "\t * out which CPU is logically closest to our hot cache data.",
            "\t */",
            "\tif (!cpumask_test_cpu(this_cpu, lowest_mask))",
            "\t\tthis_cpu = -1; /* Skip this_cpu opt if not among lowest */",
            "",
            "\trcu_read_lock();",
            "\tfor_each_domain(cpu, sd) {",
            "\t\tif (sd->flags & SD_WAKE_AFFINE) {",
            "\t\t\tint best_cpu;",
            "",
            "\t\t\t/*",
            "\t\t\t * \"this_cpu\" is cheaper to preempt than a",
            "\t\t\t * remote processor.",
            "\t\t\t */",
            "\t\t\tif (this_cpu != -1 &&",
            "\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {",
            "\t\t\t\trcu_read_unlock();",
            "\t\t\t\treturn this_cpu;",
            "\t\t\t}",
            "",
            "\t\t\tbest_cpu = cpumask_any_and_distribute(lowest_mask,",
            "\t\t\t\t\t\t\t      sched_domain_span(sd));",
            "\t\t\tif (best_cpu < nr_cpu_ids) {",
            "\t\t\t\trcu_read_unlock();",
            "\t\t\t\treturn best_cpu;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * And finally, if there were no matches within the domains",
            "\t * just give the caller *something* to work with from the compatible",
            "\t * locations.",
            "\t */",
            "\tif (this_cpu != -1)",
            "\t\treturn this_cpu;",
            "",
            "\tcpu = cpumask_any_distribute(lowest_mask);",
            "\tif (cpu < nr_cpu_ids)",
            "\t\treturn cpu;",
            "",
            "\treturn -1;",
            "}",
            "static int push_rt_task(struct rq *rq, bool pull)",
            "{",
            "\tstruct task_struct *next_task;",
            "\tstruct rq *lowest_rq;",
            "\tint ret = 0;",
            "",
            "\tif (!rq->rt.overloaded)",
            "\t\treturn 0;",
            "",
            "\tnext_task = pick_next_pushable_task(rq);",
            "\tif (!next_task)",
            "\t\treturn 0;",
            "",
            "retry:",
            "\t/*",
            "\t * It's possible that the next_task slipped in of",
            "\t * higher priority than current. If that's the case",
            "\t * just reschedule current.",
            "\t */",
            "\tif (unlikely(next_task->prio < rq->curr->prio)) {",
            "\t\tresched_curr(rq);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (is_migration_disabled(next_task)) {",
            "\t\tstruct task_struct *push_task = NULL;",
            "\t\tint cpu;",
            "",
            "\t\tif (!pull || rq->push_busy)",
            "\t\t\treturn 0;",
            "",
            "\t\t/*",
            "\t\t * Invoking find_lowest_rq() on anything but an RT task doesn't",
            "\t\t * make sense. Per the above priority check, curr has to",
            "\t\t * be of higher priority than next_task, so no need to",
            "\t\t * reschedule when bailing out.",
            "\t\t *",
            "\t\t * Note that the stoppers are masqueraded as SCHED_FIFO",
            "\t\t * (cf. sched_set_stop_task()), so we can't rely on rt_task().",
            "\t\t */",
            "\t\tif (rq->curr->sched_class != &rt_sched_class)",
            "\t\t\treturn 0;",
            "",
            "\t\tcpu = find_lowest_rq(rq->curr);",
            "\t\tif (cpu == -1 || cpu == rq->cpu)",
            "\t\t\treturn 0;",
            "",
            "\t\t/*",
            "\t\t * Given we found a CPU with lower priority than @next_task,",
            "\t\t * therefore it should be running. However we cannot migrate it",
            "\t\t * to this other CPU, instead attempt to push the current",
            "\t\t * running task on this CPU away.",
            "\t\t */",
            "\t\tpush_task = get_push_task(rq);",
            "\t\tif (push_task) {",
            "\t\t\tpreempt_disable();",
            "\t\t\traw_spin_rq_unlock(rq);",
            "\t\t\tstop_one_cpu_nowait(rq->cpu, push_cpu_stop,",
            "\t\t\t\t\t    push_task, &rq->push_work);",
            "\t\t\tpreempt_enable();",
            "\t\t\traw_spin_rq_lock(rq);",
            "\t\t}",
            "",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (WARN_ON(next_task == rq->curr))",
            "\t\treturn 0;",
            "",
            "\t/* We might release rq lock */",
            "\tget_task_struct(next_task);",
            "",
            "\t/* find_lock_lowest_rq locks the rq if found */",
            "\tlowest_rq = find_lock_lowest_rq(next_task, rq);",
            "\tif (!lowest_rq) {",
            "\t\tstruct task_struct *task;",
            "\t\t/*",
            "\t\t * find_lock_lowest_rq releases rq->lock",
            "\t\t * so it is possible that next_task has migrated.",
            "\t\t *",
            "\t\t * We need to make sure that the task is still on the same",
            "\t\t * run-queue and is also still the next task eligible for",
            "\t\t * pushing.",
            "\t\t */",
            "\t\ttask = pick_next_pushable_task(rq);",
            "\t\tif (task == next_task) {",
            "\t\t\t/*",
            "\t\t\t * The task hasn't migrated, and is still the next",
            "\t\t\t * eligible task, but we failed to find a run-queue",
            "\t\t\t * to push it to.  Do not retry in this case, since",
            "\t\t\t * other CPUs will pull from us when ready.",
            "\t\t\t */",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tif (!task)",
            "\t\t\t/* No more tasks, just exit */",
            "\t\t\tgoto out;",
            "",
            "\t\t/*",
            "\t\t * Something has shifted, try again.",
            "\t\t */",
            "\t\tput_task_struct(next_task);",
            "\t\tnext_task = task;",
            "\t\tgoto retry;",
            "\t}",
            "",
            "\tdeactivate_task(rq, next_task, 0);",
            "\tset_task_cpu(next_task, lowest_rq->cpu);",
            "\tactivate_task(lowest_rq, next_task, 0);",
            "\tresched_curr(lowest_rq);",
            "\tret = 1;",
            "",
            "\tdouble_unlock_balance(rq, lowest_rq);",
            "out:",
            "\tput_task_struct(next_task);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "pick_rt_task, find_lowest_rq, push_rt_task",
          "description": "实现实时任务选择算法、低优先级CPU搜索及强制迁移逻辑，支持异构系统下的能效优化和拓扑感知调度。",
          "similarity": 0.5504130125045776
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/sched/rt.c",
          "start_line": 1066,
          "end_line": 1170,
          "content": [
            "static void",
            "inc_rt_prio_smp(struct rt_rq *rt_rq, int prio, int prev_prio)",
            "{",
            "\tstruct rq *rq = rq_of_rt_rq(rt_rq);",
            "",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\t/*",
            "\t * Change rq's cpupri only if rt_rq is the top queue.",
            "\t */",
            "\tif (&rq->rt != rt_rq)",
            "\t\treturn;",
            "#endif",
            "\tif (rq->online && prio < prev_prio)",
            "\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, prio);",
            "}",
            "static void",
            "dec_rt_prio_smp(struct rt_rq *rt_rq, int prio, int prev_prio)",
            "{",
            "\tstruct rq *rq = rq_of_rt_rq(rt_rq);",
            "",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\t/*",
            "\t * Change rq's cpupri only if rt_rq is the top queue.",
            "\t */",
            "\tif (&rq->rt != rt_rq)",
            "\t\treturn;",
            "#endif",
            "\tif (rq->online && rt_rq->highest_prio.curr != prev_prio)",
            "\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, rt_rq->highest_prio.curr);",
            "}",
            "static inline",
            "void inc_rt_prio_smp(struct rt_rq *rt_rq, int prio, int prev_prio) {}",
            "static inline",
            "void dec_rt_prio_smp(struct rt_rq *rt_rq, int prio, int prev_prio) {}",
            "static void",
            "inc_rt_prio(struct rt_rq *rt_rq, int prio)",
            "{",
            "\tint prev_prio = rt_rq->highest_prio.curr;",
            "",
            "\tif (prio < prev_prio)",
            "\t\trt_rq->highest_prio.curr = prio;",
            "",
            "\tinc_rt_prio_smp(rt_rq, prio, prev_prio);",
            "}",
            "static void",
            "dec_rt_prio(struct rt_rq *rt_rq, int prio)",
            "{",
            "\tint prev_prio = rt_rq->highest_prio.curr;",
            "",
            "\tif (rt_rq->rt_nr_running) {",
            "",
            "\t\tWARN_ON(prio < prev_prio);",
            "",
            "\t\t/*",
            "\t\t * This may have been our highest task, and therefore",
            "\t\t * we may have some recomputation to do",
            "\t\t */",
            "\t\tif (prio == prev_prio) {",
            "\t\t\tstruct rt_prio_array *array = &rt_rq->active;",
            "",
            "\t\t\trt_rq->highest_prio.curr =",
            "\t\t\t\tsched_find_first_bit(array->bitmap);",
            "\t\t}",
            "",
            "\t} else {",
            "\t\trt_rq->highest_prio.curr = MAX_RT_PRIO-1;",
            "\t}",
            "",
            "\tdec_rt_prio_smp(rt_rq, prio, prev_prio);",
            "}",
            "static inline void inc_rt_prio(struct rt_rq *rt_rq, int prio) {}",
            "static inline void dec_rt_prio(struct rt_rq *rt_rq, int prio) {}",
            "static void",
            "inc_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)",
            "{",
            "\tif (rt_se_boosted(rt_se))",
            "\t\trt_rq->rt_nr_boosted++;",
            "",
            "\tif (rt_rq->tg)",
            "\t\tstart_rt_bandwidth(&rt_rq->tg->rt_bandwidth);",
            "}",
            "static void",
            "dec_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)",
            "{",
            "\tif (rt_se_boosted(rt_se))",
            "\t\trt_rq->rt_nr_boosted--;",
            "",
            "\tWARN_ON(!rt_rq->rt_nr_running && rt_rq->rt_nr_boosted);",
            "}",
            "static void",
            "inc_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)",
            "{",
            "}",
            "static inline",
            "void dec_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq) {}",
            "static inline",
            "unsigned int rt_se_nr_running(struct sched_rt_entity *rt_se)",
            "{",
            "\tstruct rt_rq *group_rq = group_rt_rq(rt_se);",
            "",
            "\tif (group_rq)",
            "\t\treturn group_rq->rt_nr_running;",
            "\telse",
            "\t\treturn 1;",
            "}"
          ],
          "function_name": "inc_rt_prio_smp, dec_rt_prio_smp, inc_rt_prio_smp, dec_rt_prio_smp, inc_rt_prio, dec_rt_prio, inc_rt_prio, dec_rt_prio, inc_rt_group, dec_rt_group, inc_rt_group, dec_rt_group, rt_se_nr_running",
          "description": "`inc_rt_prio/dec_rt_prio`维护实时队列最高优先级，`inc_rt_group/dec_rt_group`处理调度组的资源计数，`rt_se_nr_running`查询任务所属组的运行数量",
          "similarity": 0.5483521223068237
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/sched/rt.c",
          "start_line": 1339,
          "end_line": 1439,
          "content": [
            "static inline void",
            "update_stats_dequeue_rt(struct rt_rq *rt_rq, struct sched_rt_entity *rt_se,",
            "\t\t\tint flags)",
            "{",
            "\tstruct task_struct *p = NULL;",
            "",
            "\tif (!schedstat_enabled())",
            "\t\treturn;",
            "",
            "\tif (rt_entity_is_task(rt_se))",
            "\t\tp = rt_task_of(rt_se);",
            "",
            "\tif ((flags & DEQUEUE_SLEEP) && p) {",
            "\t\tunsigned int state;",
            "",
            "\t\tstate = READ_ONCE(p->__state);",
            "\t\tif (state & TASK_INTERRUPTIBLE)",
            "\t\t\t__schedstat_set(p->stats.sleep_start,",
            "\t\t\t\t\trq_clock(rq_of_rt_rq(rt_rq)));",
            "",
            "\t\tif (state & TASK_UNINTERRUPTIBLE)",
            "\t\t\t__schedstat_set(p->stats.block_start,",
            "\t\t\t\t\trq_clock(rq_of_rt_rq(rt_rq)));",
            "\t}",
            "}",
            "static void __enqueue_rt_entity(struct sched_rt_entity *rt_se, unsigned int flags)",
            "{",
            "\tstruct rt_rq *rt_rq = rt_rq_of_se(rt_se);",
            "\tstruct rt_prio_array *array = &rt_rq->active;",
            "\tstruct rt_rq *group_rq = group_rt_rq(rt_se);",
            "\tstruct list_head *queue = array->queue + rt_se_prio(rt_se);",
            "",
            "\t/*",
            "\t * Don't enqueue the group if its throttled, or when empty.",
            "\t * The latter is a consequence of the former when a child group",
            "\t * get throttled and the current group doesn't have any other",
            "\t * active members.",
            "\t */",
            "\tif (group_rq && (rt_rq_throttled(group_rq) || !group_rq->rt_nr_running)) {",
            "\t\tif (rt_se->on_list)",
            "\t\t\t__delist_rt_entity(rt_se, array);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (move_entity(flags)) {",
            "\t\tWARN_ON_ONCE(rt_se->on_list);",
            "\t\tif (flags & ENQUEUE_HEAD)",
            "\t\t\tlist_add(&rt_se->run_list, queue);",
            "\t\telse",
            "\t\t\tlist_add_tail(&rt_se->run_list, queue);",
            "",
            "\t\t__set_bit(rt_se_prio(rt_se), array->bitmap);",
            "\t\trt_se->on_list = 1;",
            "\t}",
            "\trt_se->on_rq = 1;",
            "",
            "\tinc_rt_tasks(rt_se, rt_rq);",
            "}",
            "static void __dequeue_rt_entity(struct sched_rt_entity *rt_se, unsigned int flags)",
            "{",
            "\tstruct rt_rq *rt_rq = rt_rq_of_se(rt_se);",
            "\tstruct rt_prio_array *array = &rt_rq->active;",
            "",
            "\tif (move_entity(flags)) {",
            "\t\tWARN_ON_ONCE(!rt_se->on_list);",
            "\t\t__delist_rt_entity(rt_se, array);",
            "\t}",
            "\trt_se->on_rq = 0;",
            "",
            "\tdec_rt_tasks(rt_se, rt_rq);",
            "}",
            "static void dequeue_rt_stack(struct sched_rt_entity *rt_se, unsigned int flags)",
            "{",
            "\tstruct sched_rt_entity *back = NULL;",
            "\tunsigned int rt_nr_running;",
            "",
            "\tfor_each_sched_rt_entity(rt_se) {",
            "\t\trt_se->back = back;",
            "\t\tback = rt_se;",
            "\t}",
            "",
            "\trt_nr_running = rt_rq_of_se(back)->rt_nr_running;",
            "",
            "\tfor (rt_se = back; rt_se; rt_se = rt_se->back) {",
            "\t\tif (on_rt_rq(rt_se))",
            "\t\t\t__dequeue_rt_entity(rt_se, flags);",
            "\t}",
            "",
            "\tdequeue_top_rt_rq(rt_rq_of_se(back), rt_nr_running);",
            "}",
            "static void enqueue_rt_entity(struct sched_rt_entity *rt_se, unsigned int flags)",
            "{",
            "\tstruct rq *rq = rq_of_rt_se(rt_se);",
            "",
            "\tupdate_stats_enqueue_rt(rt_rq_of_se(rt_se), rt_se, flags);",
            "",
            "\tdequeue_rt_stack(rt_se, flags);",
            "\tfor_each_sched_rt_entity(rt_se)",
            "\t\t__enqueue_rt_entity(rt_se, flags);",
            "\tenqueue_top_rt_rq(&rq->rt);",
            "}"
          ],
          "function_name": "update_stats_dequeue_rt, __enqueue_rt_entity, __dequeue_rt_entity, dequeue_rt_stack, enqueue_rt_entity",
          "description": "处理实时任务的统计更新、入队和出队操作，管理优先级队列和位图，协调多层级调度实体的栈式处理。",
          "similarity": 0.5476011037826538
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/sched/rt.c",
          "start_line": 934,
          "end_line": 1036,
          "content": [
            "static inline void sched_rt_rq_enqueue(struct rt_rq *rt_rq)",
            "{",
            "\tstruct rq *rq = rq_of_rt_rq(rt_rq);",
            "",
            "\tif (!rt_rq->rt_nr_running)",
            "\t\treturn;",
            "",
            "\tenqueue_top_rt_rq(rt_rq);",
            "\tresched_curr(rq);",
            "}",
            "static inline void sched_rt_rq_dequeue(struct rt_rq *rt_rq)",
            "{",
            "\tdequeue_top_rt_rq(rt_rq, rt_rq->rt_nr_running);",
            "}",
            "static inline int rt_rq_throttled(struct rt_rq *rt_rq)",
            "{",
            "\treturn false;",
            "}",
            "static void __enable_runtime(struct rq *rq) { }",
            "static void __disable_runtime(struct rq *rq) { }",
            "static inline int rt_se_prio(struct sched_rt_entity *rt_se)",
            "{",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\tstruct rt_rq *rt_rq = group_rt_rq(rt_se);",
            "",
            "\tif (rt_rq)",
            "\t\treturn rt_rq->highest_prio.curr;",
            "#endif",
            "",
            "\treturn rt_task_of(rt_se)->prio;",
            "}",
            "static void update_curr_rt(struct rq *rq)",
            "{",
            "\tstruct task_struct *curr = rq->curr;",
            "\ts64 delta_exec;",
            "",
            "\tif (curr->sched_class != &rt_sched_class)",
            "\t\treturn;",
            "",
            "\tdelta_exec = update_curr_common(rq);",
            "\tif (unlikely(delta_exec <= 0))",
            "\t\treturn;",
            "",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\tstruct sched_rt_entity *rt_se = &curr->rt;",
            "",
            "\tif (!rt_bandwidth_enabled())",
            "\t\treturn;",
            "",
            "\tfor_each_sched_rt_entity(rt_se) {",
            "\t\tstruct rt_rq *rt_rq = rt_rq_of_se(rt_se);",
            "\t\tint exceeded;",
            "",
            "\t\tif (sched_rt_runtime(rt_rq) != RUNTIME_INF) {",
            "\t\t\traw_spin_lock(&rt_rq->rt_runtime_lock);",
            "\t\t\trt_rq->rt_time += delta_exec;",
            "\t\t\texceeded = sched_rt_runtime_exceeded(rt_rq);",
            "\t\t\tif (exceeded)",
            "\t\t\t\tresched_curr(rq);",
            "\t\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);",
            "\t\t\tif (exceeded)",
            "\t\t\t\tdo_start_rt_bandwidth(sched_rt_bandwidth(rt_rq));",
            "\t\t}",
            "\t}",
            "#endif",
            "}",
            "static void",
            "dequeue_top_rt_rq(struct rt_rq *rt_rq, unsigned int count)",
            "{",
            "\tstruct rq *rq = rq_of_rt_rq(rt_rq);",
            "",
            "\tBUG_ON(&rq->rt != rt_rq);",
            "",
            "\tif (!rt_rq->rt_queued)",
            "\t\treturn;",
            "",
            "\tBUG_ON(!rq->nr_running);",
            "",
            "\tsub_nr_running(rq, count);",
            "\trt_rq->rt_queued = 0;",
            "",
            "}",
            "static void",
            "enqueue_top_rt_rq(struct rt_rq *rt_rq)",
            "{",
            "\tstruct rq *rq = rq_of_rt_rq(rt_rq);",
            "",
            "\tBUG_ON(&rq->rt != rt_rq);",
            "",
            "\tif (rt_rq->rt_queued)",
            "\t\treturn;",
            "",
            "\tif (rt_rq_throttled(rt_rq))",
            "\t\treturn;",
            "",
            "\tif (rt_rq->rt_nr_running) {",
            "\t\tadd_nr_running(rq, rt_rq->rt_nr_running);",
            "\t\trt_rq->rt_queued = 1;",
            "\t}",
            "",
            "\t/* Kick cpufreq (see the comment in kernel/sched/sched.h). */",
            "\tcpufreq_update_util(rq, 0);",
            "}"
          ],
          "function_name": "sched_rt_rq_enqueue, sched_rt_rq_dequeue, rt_rq_throttled, __enable_runtime, __disable_runtime, rt_se_prio, update_curr_rt, dequeue_top_rt_rq, enqueue_top_rt_rq",
          "description": "`sched_rt_rq_enqueue/dequeue`管理实时队列的挂载/卸载，`rt_rq_throttled`判断是否节流，`update_curr_rt`更新当前任务的运行时间并检查节流策略",
          "similarity": 0.546839714050293
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/rt.c",
          "start_line": 57,
          "end_line": 159,
          "content": [
            "static int __init sched_rt_sysctl_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", sched_rt_sysctls);",
            "\treturn 0;",
            "}",
            "void init_rt_rq(struct rt_rq *rt_rq)",
            "{",
            "\tstruct rt_prio_array *array;",
            "\tint i;",
            "",
            "\tarray = &rt_rq->active;",
            "\tfor (i = 0; i < MAX_RT_PRIO; i++) {",
            "\t\tINIT_LIST_HEAD(array->queue + i);",
            "\t\t__clear_bit(i, array->bitmap);",
            "\t}",
            "\t/* delimiter for bitsearch: */",
            "\t__set_bit(MAX_RT_PRIO, array->bitmap);",
            "",
            "#if defined CONFIG_SMP",
            "\trt_rq->highest_prio.curr = MAX_RT_PRIO-1;",
            "\trt_rq->highest_prio.next = MAX_RT_PRIO-1;",
            "\trt_rq->overloaded = 0;",
            "\tplist_head_init(&rt_rq->pushable_tasks);",
            "#endif /* CONFIG_SMP */",
            "\t/* We start is dequeued state, because no RT tasks are queued */",
            "\trt_rq->rt_queued = 0;",
            "",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\trt_rq->rt_time = 0;",
            "\trt_rq->rt_throttled = 0;",
            "\trt_rq->rt_runtime = 0;",
            "\traw_spin_lock_init(&rt_rq->rt_runtime_lock);",
            "#endif",
            "}",
            "static enum hrtimer_restart sched_rt_period_timer(struct hrtimer *timer)",
            "{",
            "\tstruct rt_bandwidth *rt_b =",
            "\t\tcontainer_of(timer, struct rt_bandwidth, rt_period_timer);",
            "\tint idle = 0;",
            "\tint overrun;",
            "",
            "\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\tfor (;;) {",
            "\t\toverrun = hrtimer_forward_now(timer, rt_b->rt_period);",
            "\t\tif (!overrun)",
            "\t\t\tbreak;",
            "",
            "\t\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "\t\tidle = do_sched_rt_period_timer(rt_b, overrun);",
            "\t\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\t}",
            "\tif (idle)",
            "\t\trt_b->rt_period_active = 0;",
            "\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "",
            "\treturn idle ? HRTIMER_NORESTART : HRTIMER_RESTART;",
            "}",
            "void init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)",
            "{",
            "\trt_b->rt_period = ns_to_ktime(period);",
            "\trt_b->rt_runtime = runtime;",
            "",
            "\traw_spin_lock_init(&rt_b->rt_runtime_lock);",
            "",
            "\thrtimer_init(&rt_b->rt_period_timer, CLOCK_MONOTONIC,",
            "\t\t     HRTIMER_MODE_REL_HARD);",
            "\trt_b->rt_period_timer.function = sched_rt_period_timer;",
            "}",
            "static inline void do_start_rt_bandwidth(struct rt_bandwidth *rt_b)",
            "{",
            "\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\tif (!rt_b->rt_period_active) {",
            "\t\trt_b->rt_period_active = 1;",
            "\t\t/*",
            "\t\t * SCHED_DEADLINE updates the bandwidth, as a run away",
            "\t\t * RT task with a DL task could hog a CPU. But DL does",
            "\t\t * not reset the period. If a deadline task was running",
            "\t\t * without an RT task running, it can cause RT tasks to",
            "\t\t * throttle when they start up. Kick the timer right away",
            "\t\t * to update the period.",
            "\t\t */",
            "\t\thrtimer_forward_now(&rt_b->rt_period_timer, ns_to_ktime(0));",
            "\t\thrtimer_start_expires(&rt_b->rt_period_timer,",
            "\t\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);",
            "\t}",
            "\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "}",
            "static void start_rt_bandwidth(struct rt_bandwidth *rt_b)",
            "{",
            "\tif (!rt_bandwidth_enabled() || rt_b->rt_runtime == RUNTIME_INF)",
            "\t\treturn;",
            "",
            "\tdo_start_rt_bandwidth(rt_b);",
            "}",
            "static void destroy_rt_bandwidth(struct rt_bandwidth *rt_b)",
            "{",
            "\thrtimer_cancel(&rt_b->rt_period_timer);",
            "}",
            "void unregister_rt_sched_group(struct task_group *tg)",
            "{",
            "\tif (tg->rt_se)",
            "\t\tdestroy_rt_bandwidth(&tg->rt_bandwidth);",
            "}"
          ],
          "function_name": "sched_rt_sysctl_init, init_rt_rq, sched_rt_period_timer, init_rt_bandwidth, do_start_rt_bandwidth, start_rt_bandwidth, destroy_rt_bandwidth, unregister_rt_sched_group",
          "description": "初始化实时调度相关数据结构，管理实时任务周期定时器，控制实时带宽分配与回收，实现基于时间片轮转的调度策略。",
          "similarity": 0.5360850095748901
        }
      ]
    },
    {
      "source_file": "kernel/resource.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:53:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `resource.c`\n\n---\n\n# resource.c 技术文档\n\n## 1. 文件概述\n\n`resource.c` 是 Linux 内核中用于管理和分配系统资源（如 I/O 端口和内存区域）的核心实现文件。它提供了一套通用的资源树管理机制，支持资源的申请、释放、查找和冲突检测。该文件维护了两个全局根资源节点：`ioport_resource`（用于 I/O 端口空间）和 `iomem_resource`（用于内存映射 I/O 空间），并通过树形结构组织所有已分配的子资源，确保资源分配的唯一性和安全性。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `struct resource ioport_resource`：I/O 端口资源的根节点，范围为 `[0, IO_SPACE_LIMIT]`，标志为 `IORESOURCE_IO`。\n- `struct resource iomem_resource`：内存映射 I/O 资源的根节点，范围为 `[0, -1]`（即全地址空间），标志为 `IORESOURCE_MEM`。\n- `struct resource_constraint`：用于描述资源分配时的约束条件（最小/最大地址、对齐要求及自定义对齐函数）。\n\n### 关键函数\n- `request_resource(struct resource *root, struct resource *new)`：尝试在指定根资源下申请一段新资源，成功返回 0，冲突返回 `-EBUSY`。\n- `request_resource_conflict(...)`：与 `request_resource` 类似，但冲突时直接返回冲突的资源指针。\n- `release_resource(struct resource *old)`：释放已分配的资源。\n- `release_child_resources(struct resource *r)`：递归释放指定资源的所有子资源。\n- `find_next_iomem_res(...)`：在 `iomem_resource` 树中查找与指定区间 `[start, end]` 重叠且满足标志和描述符条件的下一个内存资源。\n- `for_each_resource` 宏：遍历资源树的通用宏，支持是否跳过子树的选项。\n\n### /proc 接口（条件编译）\n- 通过 `CONFIG_PROC_FS` 启用时，注册 `/proc/ioports` 和 `/proc/iomem` 文件，以树形格式展示当前系统中已分配的 I/O 端口和内存资源（仅对 `CAP_SYS_ADMIN` 权限用户显示实际地址）。\n\n## 3. 关键实现\n\n### 资源树结构\n- 资源以多叉树形式组织，每个 `struct resource` 包含 `child`（第一个子节点）、`sibling`（下一个兄弟节点）和 `parent` 指针。\n- 树内节点按起始地址升序排列，便于快速查找和插入。\n\n### 资源申请（`__request_resource`）\n- 在持有写锁 `resource_lock` 的前提下，遍历根节点的子链表。\n- 若新资源与现有节点无重叠，则按地址顺序插入；若存在重叠，则返回冲突节点。\n- 插入操作维护树的有序性：新节点插入到第一个起始地址大于其结束地址的节点之前。\n\n### 资源释放（`__release_resource`）\n- 支持两种模式：完全释放（含子资源）或仅提升子资源（当 `release_child=false` 时，将子节点直接挂到父节点下）。\n- 释放时调整兄弟链表指针，确保树结构完整性。\n\n### 资源遍历\n- `next_resource()`：深度优先遍历（先子节点，再兄弟节点）。\n- `next_resource_skip_children()`：仅遍历同级兄弟节点，跳过子树。\n- `/proc` 显示使用深度优先遍历，并限制最大显示层级（`MAX_IORES_LEVEL=5`）以避免过深嵌套。\n\n### 内存管理\n- 资源结构体通过 `alloc_resource()`（即 `kzalloc`）分配，通过 `free_resource()` 释放。\n- 注释指出：若资源由早期 `memblock` 分配，则无法安全释放（因非页对齐），会轻微泄漏，这是有意为之的简化设计。\n\n### 并发控制\n- 使用读写锁 `resource_lock` 保护全局资源树：\n  - 读操作（如 `/proc` 显示、`find_next_iomem_res`）使用 `read_lock`。\n  - 写操作（申请/释放资源）使用 `write_lock`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ioport.h>`：定义 `struct resource` 及相关宏（如 `IORESOURCE_IO`）。\n  - `<linux/proc_fs.h>`、`<linux/seq_file.h>`：实现 `/proc` 接口。\n  - `<linux/slab.h>`：资源结构体的动态分配。\n  - `<linux/spinlock.h>`：读写锁 `resource_lock` 的实现。\n  - `<asm/io.h>`：架构相关的 I/O 定义（如 `IO_SPACE_LIMIT`）。\n- **导出符号**：\n  - `ioport_resource`、`iomem_resource`、`request_resource`、`release_resource` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如 PCI、platform_device 驱动）使用。\n- **配置依赖**：\n  - `/proc` 接口依赖 `CONFIG_PROC_FS`。\n\n## 5. 使用场景\n\n- **设备驱动资源管理**：PCI、platform 等总线驱动在探测设备时，调用 `request_resource()` 申请 I/O 端口或内存区域，防止资源冲突。\n- **固件/ACPI 资源解析**：内核解析 ACPI 表或 EFI 内存映射时，将保留区域注册到 `iomem_resource` 树中。\n- **系统调试与监控**：用户空间通过 `/proc/ioports` 和 `/proc/iomem` 查看硬件资源分配情况（需 root 权限）。\n- **内核子系统协作**：内存管理子系统（如 `devm_request_mem_region`）、DMA 引擎等依赖此机制确保物理地址资源的独占使用。\n- **热插拔支持**：设备移除时调用 `release_resource()` 释放资源，供后续设备重用。",
      "similarity": 0.5525325536727905,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "kernel/resource.c",
          "start_line": 1561,
          "end_line": 1661,
          "content": [
            "static void devm_resource_release(struct device *dev, void *ptr)",
            "{",
            "\tstruct resource **r = ptr;",
            "",
            "\trelease_resource(*r);",
            "}",
            "int devm_request_resource(struct device *dev, struct resource *root,",
            "\t\t\t  struct resource *new)",
            "{",
            "\tstruct resource *conflict, **ptr;",
            "",
            "\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);",
            "\tif (!ptr)",
            "\t\treturn -ENOMEM;",
            "",
            "\t*ptr = new;",
            "",
            "\tconflict = request_resource_conflict(root, new);",
            "\tif (conflict) {",
            "\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",",
            "\t\t\tnew, conflict->name, conflict);",
            "\t\tdevres_free(ptr);",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tdevres_add(dev, ptr);",
            "\treturn 0;",
            "}",
            "static int devm_resource_match(struct device *dev, void *res, void *data)",
            "{",
            "\tstruct resource **ptr = res;",
            "",
            "\treturn *ptr == data;",
            "}",
            "void devm_release_resource(struct device *dev, struct resource *new)",
            "{",
            "\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,",
            "\t\t\t       new));",
            "}",
            "static void devm_region_release(struct device *dev, void *res)",
            "{",
            "\tstruct region_devres *this = res;",
            "",
            "\t__release_region(this->parent, this->start, this->n);",
            "}",
            "static int devm_region_match(struct device *dev, void *res, void *match_data)",
            "{",
            "\tstruct region_devres *this = res, *match = match_data;",
            "",
            "\treturn this->parent == match->parent &&",
            "\t\tthis->start == match->start && this->n == match->n;",
            "}",
            "void __devm_release_region(struct device *dev, struct resource *parent,",
            "\t\t\t   resource_size_t start, resource_size_t n)",
            "{",
            "\tstruct region_devres match_data = { parent, start, n };",
            "",
            "\t__release_region(parent, start, n);",
            "\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,",
            "\t\t\t       &match_data));",
            "}",
            "static int __init reserve_setup(char *str)",
            "{",
            "\tstatic int reserved;",
            "\tstatic struct resource reserve[MAXRESERVE];",
            "",
            "\tfor (;;) {",
            "\t\tunsigned int io_start, io_num;",
            "\t\tint x = reserved;",
            "\t\tstruct resource *parent;",
            "",
            "\t\tif (get_option(&str, &io_start) != 2)",
            "\t\t\tbreak;",
            "\t\tif (get_option(&str, &io_num) == 0)",
            "\t\t\tbreak;",
            "\t\tif (x < MAXRESERVE) {",
            "\t\t\tstruct resource *res = reserve + x;",
            "",
            "\t\t\t/*",
            "\t\t\t * If the region starts below 0x10000, we assume it's",
            "\t\t\t * I/O port space; otherwise assume it's memory.",
            "\t\t\t */",
            "\t\t\tif (io_start < 0x10000) {",
            "\t\t\t\tres->flags = IORESOURCE_IO;",
            "\t\t\t\tparent = &ioport_resource;",
            "\t\t\t} else {",
            "\t\t\t\tres->flags = IORESOURCE_MEM;",
            "\t\t\t\tparent = &iomem_resource;",
            "\t\t\t}",
            "\t\t\tres->name = \"reserved\";",
            "\t\t\tres->start = io_start;",
            "\t\t\tres->end = io_start + io_num - 1;",
            "\t\t\tres->flags |= IORESOURCE_BUSY;",
            "\t\t\tres->desc = IORES_DESC_NONE;",
            "\t\t\tres->child = NULL;",
            "\t\t\tif (request_resource(parent, res) == 0)",
            "\t\t\t\treserved = x+1;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}"
          ],
          "function_name": "devm_resource_release, devm_request_resource, devm_resource_match, devm_release_resource, devm_region_release, devm_region_match, __devm_release_region, reserve_setup",
          "description": "实现设备资源管理器（devm）的资源申请/释放机制，包含预留资源初始化及设备资源生命周期绑定功能。",
          "similarity": 0.5907121896743774
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/resource.c",
          "start_line": 1407,
          "end_line": 1533,
          "content": [
            "void release_mem_region_adjustable(resource_size_t start, resource_size_t size)",
            "{",
            "\tstruct resource *parent = &iomem_resource;",
            "\tstruct resource *new_res = NULL;",
            "\tbool alloc_nofail = false;",
            "\tstruct resource **p;",
            "\tstruct resource *res;",
            "\tresource_size_t end;",
            "",
            "\tend = start + size - 1;",
            "\tif (WARN_ON_ONCE((start < parent->start) || (end > parent->end)))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * We free up quite a lot of memory on memory hotunplug (esp., memap),",
            "\t * just before releasing the region. This is highly unlikely to",
            "\t * fail - let's play save and make it never fail as the caller cannot",
            "\t * perform any error handling (e.g., trying to re-add memory will fail",
            "\t * similarly).",
            "\t */",
            "retry:",
            "\tnew_res = alloc_resource(GFP_KERNEL | (alloc_nofail ? __GFP_NOFAIL : 0));",
            "",
            "\tp = &parent->child;",
            "\twrite_lock(&resource_lock);",
            "",
            "\twhile ((res = *p)) {",
            "\t\tif (res->start >= end)",
            "\t\t\tbreak;",
            "",
            "\t\t/* look for the next resource if it does not fit into */",
            "\t\tif (res->start > start || res->end < end) {",
            "\t\t\tp = &res->sibling;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!(res->flags & IORESOURCE_MEM))",
            "\t\t\tbreak;",
            "",
            "\t\tif (!(res->flags & IORESOURCE_BUSY)) {",
            "\t\t\tp = &res->child;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/* found the target resource; let's adjust accordingly */",
            "\t\tif (res->start == start && res->end == end) {",
            "\t\t\t/* free the whole entry */",
            "\t\t\t*p = res->sibling;",
            "\t\t\tfree_resource(res);",
            "\t\t} else if (res->start == start && res->end != end) {",
            "\t\t\t/* adjust the start */",
            "\t\t\tWARN_ON_ONCE(__adjust_resource(res, end + 1,",
            "\t\t\t\t\t\t       res->end - end));",
            "\t\t} else if (res->start != start && res->end == end) {",
            "\t\t\t/* adjust the end */",
            "\t\t\tWARN_ON_ONCE(__adjust_resource(res, res->start,",
            "\t\t\t\t\t\t       start - res->start));",
            "\t\t} else {",
            "\t\t\t/* split into two entries - we need a new resource */",
            "\t\t\tif (!new_res) {",
            "\t\t\t\tnew_res = alloc_resource(GFP_ATOMIC);",
            "\t\t\t\tif (!new_res) {",
            "\t\t\t\t\talloc_nofail = true;",
            "\t\t\t\t\twrite_unlock(&resource_lock);",
            "\t\t\t\t\tgoto retry;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tnew_res->name = res->name;",
            "\t\t\tnew_res->start = end + 1;",
            "\t\t\tnew_res->end = res->end;",
            "\t\t\tnew_res->flags = res->flags;",
            "\t\t\tnew_res->desc = res->desc;",
            "\t\t\tnew_res->parent = res->parent;",
            "\t\t\tnew_res->sibling = res->sibling;",
            "\t\t\tnew_res->child = NULL;",
            "",
            "\t\t\tif (WARN_ON_ONCE(__adjust_resource(res, res->start,",
            "\t\t\t\t\t\t\t   start - res->start)))",
            "\t\t\t\tbreak;",
            "\t\t\tres->sibling = new_res;",
            "\t\t\tnew_res = NULL;",
            "\t\t}",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\twrite_unlock(&resource_lock);",
            "\tfree_resource(new_res);",
            "}",
            "static bool system_ram_resources_mergeable(struct resource *r1,",
            "\t\t\t\t\t   struct resource *r2)",
            "{",
            "\t/* We assume either r1 or r2 is IORESOURCE_SYSRAM_MERGEABLE. */",
            "\treturn r1->flags == r2->flags && r1->end + 1 == r2->start &&",
            "\t       r1->name == r2->name && r1->desc == r2->desc &&",
            "\t       !r1->child && !r2->child;",
            "}",
            "void merge_system_ram_resource(struct resource *res)",
            "{",
            "\tconst unsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;",
            "\tstruct resource *cur;",
            "",
            "\tif (WARN_ON_ONCE((res->flags & flags) != flags))",
            "\t\treturn;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tres->flags |= IORESOURCE_SYSRAM_MERGEABLE;",
            "",
            "\t/* Try to merge with next item in the list. */",
            "\tcur = res->sibling;",
            "\tif (cur && system_ram_resources_mergeable(res, cur)) {",
            "\t\tres->end = cur->end;",
            "\t\tres->sibling = cur->sibling;",
            "\t\tfree_resource(cur);",
            "\t}",
            "",
            "\t/* Try to merge with previous item in the list. */",
            "\tcur = res->parent->child;",
            "\twhile (cur && cur->sibling != res)",
            "\t\tcur = cur->sibling;",
            "\tif (cur && system_ram_resources_mergeable(cur, res)) {",
            "\t\tcur->end = res->end;",
            "\t\tcur->sibling = res->sibling;",
            "\t\tfree_resource(res);",
            "\t}",
            "\twrite_unlock(&resource_lock);",
            "}"
          ],
          "function_name": "release_mem_region_adjustable, system_ram_resources_mergeable, merge_system_ram_resource",
          "description": "实现可调整内存区域释放与系统RAM资源合并功能，支持热插拔场景下的动态资源调整与碎片化优化。",
          "similarity": 0.5882494449615479
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/resource.c",
          "start_line": 802,
          "end_line": 912,
          "content": [
            "int allocate_resource(struct resource *root, struct resource *new,",
            "\t\t      resource_size_t size, resource_size_t min,",
            "\t\t      resource_size_t max, resource_size_t align,",
            "\t\t      resource_size_t (*alignf)(void *,",
            "\t\t\t\t\t\tconst struct resource *,",
            "\t\t\t\t\t\tresource_size_t,",
            "\t\t\t\t\t\tresource_size_t),",
            "\t\t      void *alignf_data)",
            "{",
            "\tint err;",
            "\tstruct resource_constraint constraint;",
            "",
            "\tif (!alignf)",
            "\t\talignf = simple_align_resource;",
            "",
            "\tconstraint.min = min;",
            "\tconstraint.max = max;",
            "\tconstraint.align = align;",
            "\tconstraint.alignf = alignf;",
            "\tconstraint.alignf_data = alignf_data;",
            "",
            "\tif ( new->parent ) {",
            "\t\t/* resource is already allocated, try reallocating with",
            "\t\t   the new constraints */",
            "\t\treturn reallocate_resource(root, new, size, &constraint);",
            "\t}",
            "",
            "\twrite_lock(&resource_lock);",
            "\terr = find_resource(root, new, size, &constraint);",
            "\tif (err >= 0 && __request_resource(root, new))",
            "\t\terr = -EBUSY;",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}",
            "int insert_resource(struct resource *parent, struct resource *new)",
            "{",
            "\tstruct resource *conflict;",
            "",
            "\tconflict = insert_resource_conflict(parent, new);",
            "\treturn conflict ? -EBUSY : 0;",
            "}",
            "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)",
            "{",
            "\tif (new->parent)",
            "\t\treturn;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tconflict = __insert_resource(root, new);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\tif (conflict == root)",
            "\t\t\tbreak;",
            "",
            "\t\t/* Ok, expand resource to cover the conflict, then try again .. */",
            "\t\tif (conflict->start < new->start)",
            "\t\t\tnew->start = conflict->start;",
            "\t\tif (conflict->end > new->end)",
            "\t\t\tnew->end = conflict->end;",
            "",
            "\t\tpr_info(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);",
            "\t}",
            "\twrite_unlock(&resource_lock);",
            "}",
            "int remove_resource(struct resource *old)",
            "{",
            "\tint retval;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tretval = __release_resource(old, false);",
            "\twrite_unlock(&resource_lock);",
            "\treturn retval;",
            "}",
            "static int __adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t\t\tresource_size_t size)",
            "{",
            "\tstruct resource *tmp, *parent = res->parent;",
            "\tresource_size_t end = start + size - 1;",
            "\tint result = -EBUSY;",
            "",
            "\tif (!parent)",
            "\t\tgoto skip;",
            "",
            "\tif ((start < parent->start) || (end > parent->end))",
            "\t\tgoto out;",
            "",
            "\tif (res->sibling && (res->sibling->start <= end))",
            "\t\tgoto out;",
            "",
            "\ttmp = parent->child;",
            "\tif (tmp != res) {",
            "\t\twhile (tmp->sibling != res)",
            "\t\t\ttmp = tmp->sibling;",
            "\t\tif (start <= tmp->end)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "skip:",
            "\tfor (tmp = res->child; tmp; tmp = tmp->sibling)",
            "\t\tif ((tmp->start < start) || (tmp->end > end))",
            "\t\t\tgoto out;",
            "",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tresult = 0;",
            "",
            " out:",
            "\treturn result;",
            "}"
          ],
          "function_name": "allocate_resource, insert_resource, insert_resource_expand_to_fit, remove_resource, __adjust_resource",
          "description": "实现资源分配逻辑，支持带约束条件的资源查找与申请，处理资源冲突及扩展调整，提供基础资源管理框架。",
          "similarity": 0.5833776593208313
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/resource.c",
          "start_line": 637,
          "end_line": 763,
          "content": [
            "int region_intersects(resource_size_t start, size_t size, unsigned long flags,",
            "\t\t      unsigned long desc)",
            "{",
            "\tint ret;",
            "",
            "\tread_lock(&resource_lock);",
            "\tret = __region_intersects(&iomem_resource, start, size, flags, desc);",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn ret;",
            "}",
            "void __weak arch_remove_reservations(struct resource *avail)",
            "{",
            "}",
            "static resource_size_t simple_align_resource(void *data,",
            "\t\t\t\t\t     const struct resource *avail,",
            "\t\t\t\t\t     resource_size_t size,",
            "\t\t\t\t\t     resource_size_t align)",
            "{",
            "\treturn avail->start;",
            "}",
            "static void resource_clip(struct resource *res, resource_size_t min,",
            "\t\t\t  resource_size_t max)",
            "{",
            "\tif (res->start < min)",
            "\t\tres->start = min;",
            "\tif (res->end > max)",
            "\t\tres->end = max;",
            "}",
            "static int __find_resource(struct resource *root, struct resource *old,",
            "\t\t\t struct resource *new,",
            "\t\t\t resource_size_t  size,",
            "\t\t\t struct resource_constraint *constraint)",
            "{",
            "\tstruct resource *this = root->child;",
            "\tstruct resource tmp = *new, avail, alloc;",
            "",
            "\ttmp.start = root->start;",
            "\t/*",
            "\t * Skip past an allocated resource that starts at 0, since the assignment",
            "\t * of this->start - 1 to tmp->end below would cause an underflow.",
            "\t */",
            "\tif (this && this->start == root->start) {",
            "\t\ttmp.start = (this == old) ? old->start : this->end + 1;",
            "\t\tthis = this->sibling;",
            "\t}",
            "\tfor(;;) {",
            "\t\tif (this)",
            "\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;",
            "\t\telse",
            "\t\t\ttmp.end = root->end;",
            "",
            "\t\tif (tmp.end < tmp.start)",
            "\t\t\tgoto next;",
            "",
            "\t\tresource_clip(&tmp, constraint->min, constraint->max);",
            "\t\tarch_remove_reservations(&tmp);",
            "",
            "\t\t/* Check for overflow after ALIGN() */",
            "\t\tavail.start = ALIGN(tmp.start, constraint->align);",
            "\t\tavail.end = tmp.end;",
            "\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;",
            "\t\tif (avail.start >= tmp.start) {",
            "\t\t\talloc.flags = avail.flags;",
            "\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,",
            "\t\t\t\t\tsize, constraint->align);",
            "\t\t\talloc.end = alloc.start + size - 1;",
            "\t\t\tif (alloc.start <= alloc.end &&",
            "\t\t\t    resource_contains(&avail, &alloc)) {",
            "\t\t\t\tnew->start = alloc.start;",
            "\t\t\t\tnew->end = alloc.end;",
            "\t\t\t\treturn 0;",
            "\t\t\t}",
            "\t\t}",
            "",
            "next:\t\tif (!this || this->end == root->end)",
            "\t\t\tbreak;",
            "",
            "\t\tif (this != old)",
            "\t\t\ttmp.start = this->end + 1;",
            "\t\tthis = this->sibling;",
            "\t}",
            "\treturn -EBUSY;",
            "}",
            "static int find_resource(struct resource *root, struct resource *new,",
            "\t\t\tresource_size_t size,",
            "\t\t\tstruct resource_constraint  *constraint)",
            "{",
            "\treturn  __find_resource(root, NULL, new, size, constraint);",
            "}",
            "static int reallocate_resource(struct resource *root, struct resource *old,",
            "\t\t\t       resource_size_t newsize,",
            "\t\t\t       struct resource_constraint *constraint)",
            "{",
            "\tint err=0;",
            "\tstruct resource new = *old;",
            "\tstruct resource *conflict;",
            "",
            "\twrite_lock(&resource_lock);",
            "",
            "\tif ((err = __find_resource(root, old, &new, newsize, constraint)))",
            "\t\tgoto out;",
            "",
            "\tif (resource_contains(&new, old)) {",
            "\t\told->start = new.start;",
            "\t\told->end = new.end;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (old->child) {",
            "\t\terr = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (resource_contains(old, &new)) {",
            "\t\told->start = new.start;",
            "\t\told->end = new.end;",
            "\t} else {",
            "\t\t__release_resource(old, true);",
            "\t\t*old = new;",
            "\t\tconflict = __request_resource(root, old);",
            "\t\tBUG_ON(conflict);",
            "\t}",
            "out:",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}"
          ],
          "function_name": "region_intersects, arch_remove_reservations, simple_align_resource, resource_clip, __find_resource, find_resource, reallocate_resource",
          "description": "实现资源分配策略核心逻辑，包含资源位置查找、尺寸调整、冲突检测等关键功能，支持带约束条件的资源重新分配与位置确定。",
          "similarity": 0.5575991868972778
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/resource.c",
          "start_line": 492,
          "end_line": 601,
          "content": [
            "int walk_mem_res(u64 start, u64 end, void *arg,",
            "\t\t int (*func)(struct resource *, void *))",
            "{",
            "\tunsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;",
            "",
            "\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,",
            "\t\t\t\t     func);",
            "}",
            "int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,",
            "\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))",
            "{",
            "\tresource_size_t start, end;",
            "\tunsigned long flags;",
            "\tstruct resource res;",
            "\tunsigned long pfn, end_pfn;",
            "\tint ret = -EINVAL;",
            "",
            "\tstart = (u64) start_pfn << PAGE_SHIFT;",
            "\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;",
            "\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;",
            "\twhile (start < end &&",
            "\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res)) {",
            "\t\tpfn = PFN_UP(res.start);",
            "\t\tend_pfn = PFN_DOWN(res.end + 1);",
            "\t\tif (end_pfn > pfn)",
            "\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t\tstart = res.end + 1;",
            "\t}",
            "\treturn ret;",
            "}",
            "static int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)",
            "{",
            "\treturn 1;",
            "}",
            "int __weak page_is_ram(unsigned long pfn)",
            "{",
            "\treturn walk_system_ram_range(pfn, 1, NULL, __is_ram) == 1;",
            "}",
            "static int __region_intersects(struct resource *parent, resource_size_t start,",
            "\t\t\t       size_t size, unsigned long flags,",
            "\t\t\t       unsigned long desc)",
            "{",
            "\tresource_size_t ostart, oend;",
            "\tint type = 0; int other = 0;",
            "\tstruct resource *p, *dp;",
            "\tbool is_type, covered;",
            "\tstruct resource res;",
            "",
            "\tres.start = start;",
            "\tres.end = start + size - 1;",
            "",
            "\tfor (p = parent->child; p ; p = p->sibling) {",
            "\t\tif (!resource_overlaps(p, &res))",
            "\t\t\tcontinue;",
            "\t\tis_type = (p->flags & flags) == flags &&",
            "\t\t\t(desc == IORES_DESC_NONE || desc == p->desc);",
            "\t\tif (is_type) {",
            "\t\t\ttype++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Continue to search in descendant resources as if the",
            "\t\t * matched descendant resources cover some ranges of 'p'.",
            "\t\t *",
            "\t\t * |------------- \"CXL Window 0\" ------------|",
            "\t\t * |-- \"System RAM\" --|",
            "\t\t *",
            "\t\t * will behave similar as the following fake resource",
            "\t\t * tree when searching \"System RAM\".",
            "\t\t *",
            "\t\t * |-- \"System RAM\" --||-- \"CXL Window 0a\" --|",
            "\t\t */",
            "\t\tcovered = false;",
            "\t\tostart = max(res.start, p->start);",
            "\t\toend = min(res.end, p->end);",
            "\t\tfor_each_resource(p, dp, false) {",
            "\t\t\tif (!resource_overlaps(dp, &res))",
            "\t\t\t\tcontinue;",
            "\t\t\tis_type = (dp->flags & flags) == flags &&",
            "\t\t\t\t(desc == IORES_DESC_NONE || desc == dp->desc);",
            "\t\t\tif (is_type) {",
            "\t\t\t\ttype++;",
            "\t\t\t\t/*",
            "\t\t\t\t * Range from 'ostart' to 'dp->start'",
            "\t\t\t\t * isn't covered by matched resource.",
            "\t\t\t\t */",
            "\t\t\t\tif (dp->start > ostart)",
            "\t\t\t\t\tbreak;",
            "\t\t\t\tif (dp->end >= oend) {",
            "\t\t\t\t\tcovered = true;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\t/* Remove covered range */",
            "\t\t\t\tostart = max(ostart, dp->end + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (!covered)",
            "\t\t\tother++;",
            "\t}",
            "",
            "\tif (type == 0)",
            "\t\treturn REGION_DISJOINT;",
            "",
            "\tif (other == 0)",
            "\t\treturn REGION_INTERSECTS;",
            "",
            "\treturn REGION_MIXED;",
            "}"
          ],
          "function_name": "walk_mem_res, walk_system_ram_range, __is_ram, page_is_ram, __region_intersects",
          "description": "提供内存资源遍历接口，将物理地址转换为资源结构进行处理，包含判断内存区域是否为RAM的弱符号实现及区域交集检测逻辑。",
          "similarity": 0.557357907295227
        }
      ]
    }
  ]
}