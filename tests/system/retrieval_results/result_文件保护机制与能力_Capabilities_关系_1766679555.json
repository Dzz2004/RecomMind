{
  "query": "文件保护机制与能力(Capabilities)关系",
  "timestamp": "2025-12-26 00:19:15",
  "retrieved_files": [
    {
      "source_file": "kernel/capability.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:39:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `capability.c`\n\n---\n\n# capability.c 技术文档\n\n## 1. 文件概述\n\n`capability.c` 是 Linux 内核中实现 POSIX 能力（Capabilities）机制的核心文件，位于 `kernel/` 目录下。该文件主要负责提供用户空间与内核之间进行能力获取（`capget`）和设置（`capset`）的系统调用接口，并维护能力模型的版本兼容性、安全策略检查以及与 LSM（Linux Security Module）框架的集成。能力机制允许将传统超级用户权限细分为多个独立的特权单元，从而实现最小权限原则。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `file_caps_enabled`：控制是否启用文件能力（File Capabilities）功能的全局开关，默认启用。可通过内核启动参数 `no_file_caps` 禁用。\n\n### 主要函数\n- **`cap_validate_magic()`**：验证用户传入的能力结构体版本号，支持 v1、v2、v3 版本，并对旧版本发出警告。\n- **`cap_get_target_pid()`**：安全地获取指定进程（通过 PID）的有效（Effective）、可继承（Inheritable）和允许（Permitted）能力集。\n- **`sys_capget()`**：`capget(2)` 系统调用的实现，用于查询指定进程的能力集。\n- **`sys_capset()`**：`capset(2)` 系统调用的实现，用于设置当前进程的能力集（仅限自身）。\n- **`mk_kernel_cap()`**：将用户空间传入的高低 32 位能力值组合成内核内部的 `kernel_cap_t` 类型。\n- **`has_ns_capability()`**（截断）：检查指定任务在给定用户命名空间中是否拥有某项能力（函数体在提供的代码中被截断）。\n\n### 辅助函数\n- `warn_legacy_capability_use()`：对使用 v1（32 位）能力接口的应用程序发出一次性警告。\n- `warn_deprecated_v2()`：对使用已弃用的 v2 能力接口的应用程序发出一次性警告。\n\n## 3. 关键实现\n\n### 能力版本兼容性处理\n- 支持三种能力结构版本：\n  - **v1 (`_LINUX_CAPABILITY_VERSION_1`)**：仅支持 32 位能力（旧版），调用时触发 `warn_legacy_capability_use()`。\n  - **v2 (`_LINUX_CAPABILITY_VERSION_2`)**：支持 64 位能力但存在安全风险，调用时触发 `warn_deprecated_v2()`。\n  - **v3 (`_LINUX_CAPABILITY_VERSION_3`)**：当前推荐版本，功能等同于 v2 但通过头文件变更避免误用。\n- 对于无效版本，内核会尝试将当前支持的版本号写回用户空间并返回 `-EINVAL`。\n\n### 能力数据传输格式\n- 用户空间使用两个 `__user_cap_data_struct` 结构体（`kdata[2]`）来表示 64 位能力值：\n  - `kdata[0]` 存储低 32 位\n  - `kdata[1]` 存储高 32 位\n- 在 `capget` 中，内核能力值被拆分为高低 32 位写入用户缓冲区；在 `capset` 中则反向组合。\n- **向后兼容策略**：当用户空间请求的版本只支持 32 位（`tocopy = 1`）时，内核会静默丢弃高 32 位能力，避免旧版 `libcap` 应用崩溃。\n\n### 安全限制\n- **`capset` 限制**：仅允许进程修改自身能力（`pid` 必须为 0 或当前进程 PID），修改其他进程能力的功能已被移除。\n- **能力设置规则**（由 LSM 实现，如 `security_capset`）：\n  - 新的 **可继承集（I）** 和 **允许集（P）** 只能是旧允许集的子集。\n  - 新的 **有效集（E）** 必须是新允许集的子集。\n- 使用 `prepare_creds()` / `commit_creds()` 机制安全地更新进程凭证（credentials），并在失败时通过 `abort_creds()` 回滚。\n\n### 并发与锁机制\n- 获取**其他进程**能力时，使用 `rcu_read_lock()` 保护对进程链表的访问（通过 `find_task_by_vpid()`）。\n- 获取**当前进程**能力时无需加锁，因为能力修改是原子的（通过凭证替换）。\n\n### 审计与日志\n- `capset` 成功时调用 `audit_log_capset()` 记录能力变更事件，用于安全审计。\n- 对旧版能力接口的使用通过 `pr_info_once()` 发出一次性内核日志警告。\n\n## 4. 依赖关系\n\n- **LSM 框架**：通过 `security_capget()` 和 `security_capset()` 钩子与安全模块（如 SELinux、AppArmor）交互，实际的能力检查和设置策略由 LSM 实现。\n- **凭证子系统**：依赖 `cred` 结构体管理进程权限，使用 `prepare_creds()`、`commit_creds()` 等函数安全更新。\n- **命名空间**：支持用户命名空间（`user_namespace.h`），能力检查与命名空间隔离相关（体现在 `has_ns_capability` 等函数中）。\n- **审计子系统**：通过 `audit.h` 提供能力变更的审计日志。\n- **系统调用接口**：通过 `SYSCALL_DEFINE2` 定义 `capget` 和 `capset` 系统调用。\n- **用户空间访问**：使用 `uaccess.h` 中的 `copy_to_user()` 和 `copy_from_user()` 安全传输数据。\n\n## 5. 使用场景\n\n- **容器与沙箱**：容器运行时（如 Docker、runc）通过 `capset` 限制容器内进程的能力集，实现权限隔离。\n- **特权程序降权**：需要临时提升权限的程序（如 `ping` 使用 `CAP_NET_RAW`）可在执行关键操作后通过 `capset` 丢弃多余能力。\n- **安全策略实施**：系统管理员或安全模块通过限制进程能力，遵循最小权限原则，减少攻击面。\n- **调试与监控**：安全工具（如 `getpcaps`）通过 `capget` 查询进程当前能力状态，用于诊断或合规检查。\n- **文件能力加载**：虽然本文件不直接处理文件能力，但 `file_caps_enabled` 开关控制是否启用基于文件扩展属性（xattr）的能力加载机制（由 `fs/` 子系统实现）。",
      "similarity": 0.6734607815742493,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/capability.c",
          "start_line": 25,
          "end_line": 125,
          "content": [
            "static int __init file_caps_disable(char *str)",
            "{",
            "\tfile_caps_enabled = 0;",
            "\treturn 1;",
            "}",
            "static void warn_legacy_capability_use(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static void warn_deprecated_v2(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)",
            "{",
            "\t__u32 version;",
            "",
            "\tif (get_user(version, &header->version))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (version) {",
            "\tcase _LINUX_CAPABILITY_VERSION_1:",
            "\t\twarn_legacy_capability_use();",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;",
            "\t\tbreak;",
            "\tcase _LINUX_CAPABILITY_VERSION_2:",
            "\t\twarn_deprecated_v2();",
            "\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */",
            "\tcase _LINUX_CAPABILITY_VERSION_3:",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))",
            "\t\t\treturn -EFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,",
            "\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)",
            "{",
            "\tint ret;",
            "",
            "\tif (pid && (pid != task_pid_vnr(current))) {",
            "\t\tconst struct task_struct *target;",
            "",
            "\t\trcu_read_lock();",
            "",
            "\t\ttarget = find_task_by_vpid(pid);",
            "\t\tif (!target)",
            "\t\t\tret = -ESRCH;",
            "\t\telse",
            "\t\t\tret = security_capget(target, pEp, pIp, pPp);",
            "",
            "\t\trcu_read_unlock();",
            "\t} else",
            "\t\tret = security_capget(current, pEp, pIp, pPp);",
            "",
            "\treturn ret;",
            "}",
            "static kernel_cap_t mk_kernel_cap(u32 low, u32 high)",
            "{",
            "\treturn (kernel_cap_t) { (low | ((u64)high << 32)) & CAP_VALID_MASK };",
            "}",
            "bool has_ns_capability(struct task_struct *t,",
            "\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability(t, &init_user_ns, cap);",
            "}",
            "bool has_ns_capability_noaudit(struct task_struct *t,",
            "\t\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability_noaudit(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);",
            "}"
          ],
          "function_name": "file_caps_disable, warn_legacy_capability_use, warn_deprecated_v2, cap_validate_magic, cap_get_target_pid, mk_kernel_cap, has_ns_capability, has_capability, has_ns_capability_noaudit, has_capability_noaudit",
          "description": "提供能力相关辅助函数，包括禁用文件能力标志、版本验证警告、目标进程能力获取及能力结构构建，实现命名空间能力检查和权限验证逻辑",
          "similarity": 0.6384126543998718
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/capability.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/capability.c",
            " *",
            " * Copyright (C) 1997  Andrew Main <zefram@fysh.org>",
            " *",
            " * Integrated into 2.1.97+,  Andrew G. Morgan <morgan@kernel.org>",
            " * 30 May 2002:\tCleanup, Robert M. Love <rml@tech9.net>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/uaccess.h>",
            "",
            "int file_caps_enabled = 1;",
            ""
          ],
          "function_name": null,
          "description": "声明模块许可证并包含必要的头文件，定义控制文件能力启用状态的全局变量file_caps_enabled",
          "similarity": 0.5791597366333008
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/capability.c",
          "start_line": 351,
          "end_line": 424,
          "content": [
            "static bool ns_capable_common(struct user_namespace *ns,",
            "\t\t\t      int cap,",
            "\t\t\t      unsigned int opts)",
            "{",
            "\tint capable;",
            "",
            "\tif (unlikely(!cap_valid(cap))) {",
            "\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);",
            "\t\tBUG();",
            "\t}",
            "",
            "\tcapable = security_capable(current_cred(), ns, cap, opts);",
            "\tif (capable == 0) {",
            "\t\tcurrent->flags |= PF_SUPERPRIV;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "bool ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);",
            "}",
            "bool ns_capable_noaudit(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);",
            "}",
            "bool ns_capable_setid(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);",
            "}",
            "bool capable(int cap)",
            "{",
            "\treturn ns_capable(&init_user_ns, cap);",
            "}",
            "bool file_ns_capable(const struct file *file, struct user_namespace *ns,",
            "\t\t     int cap)",
            "{",
            "",
            "\tif (WARN_ON_ONCE(!cap_valid(cap)))",
            "\t\treturn false;",
            "",
            "\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,",
            "\t\t\t\t struct mnt_idmap *idmap,",
            "\t\t\t\t const struct inode *inode)",
            "{",
            "\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&",
            "\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));",
            "}",
            "bool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,",
            "\t\t\t      const struct inode *inode, int cap)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "",
            "\treturn ns_capable(ns, cap) &&",
            "\t       privileged_wrt_inode_uidgid(ns, idmap, inode);",
            "}",
            "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)",
            "{",
            "\tint ret = 0;  /* An absent tracer adds no restrictions */",
            "\tconst struct cred *cred;",
            "",
            "\trcu_read_lock();",
            "\tcred = rcu_dereference(tsk->ptracer_cred);",
            "\tif (cred)",
            "\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,",
            "\t\t\t\t       CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "\treturn (ret == 0);",
            "}"
          ],
          "function_name": "ns_capable_common, ns_capable, ns_capable_noaudit, ns_capable_setid, capable, file_ns_capable, privileged_wrt_inode_uidgid, capable_wrt_inode_uidgid, ptracer_capable",
          "description": "实现核心能力检查函数，包含通用命名空间能力检测、当前命名空间能力检查、文件能力验证、基于inode UID/GID的特权判断及跟踪者能力检查等功能",
          "similarity": 0.57021164894104
        }
      ]
    },
    {
      "source_file": "mm/memcontrol-v1.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memcontrol-v1.c`\n\n---\n\n# memcontrol-v1.c 技术文档\n\n## 1. 文件概述\n\n`memcontrol-v1.c` 是 Linux 内核内存控制组（Memory Cgroup）v1 接口的核心实现文件之一，主要负责基于软限制（soft limit）的内存回收机制、OOM 事件通知以及与 cgroup v1 兼容的资源统计和管理功能。该文件维护了一个独立于 cgroup 层级结构的红黑树（RB-Tree），用于高效地追踪和选择超出软限制最多的内存控制组进行内存回收。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mem_cgroup_tree_per_node`**  \n  每个 NUMA 节点对应的红黑树结构，用于存储超出软限制的 `mem_cgroup_per_node` 实例。\n  - `rb_root`: 红黑树根节点\n  - `rb_rightmost`: 指向使用量超出软限制最多的节点（树中最右侧节点）\n  - `lock`: 保护该树的自旋锁\n\n- **`struct mem_cgroup_tree`**  \n  全局软限制树结构，包含每个 NUMA 节点对应的 `mem_cgroup_tree_per_node`。\n\n- **`struct mem_cgroup_eventfd_list`**  \n  用于 OOM 事件通知的 eventfd 列表项。\n\n- **`struct mem_cgroup_event`**  \n  表示用户空间注册的内存事件（如 OOM、阈值触发等），支持通过 eventfd 通知用户空间。\n\n- **枚举常量 `RES_*`**  \n  定义了 cgroup v1 接口中可读写的资源属性类型（如使用量、限制、最大使用量、失败计数、软限制等）。\n\n### 主要函数\n\n- **`__mem_cgroup_insert_exceeded()` / `__mem_cgroup_remove_exceeded()`**  \n  在指定节点的软限制红黑树中插入或移除一个 `mem_cgroup_per_node` 节点。\n\n- **`memcg1_update_tree()`**  \n  根据当前内存使用量与软限制的差值，更新指定 memcg 及其所有祖先在软限制树中的位置。\n\n- **`memcg1_remove_from_trees()`**  \n  在 memcg 销毁时，将其从所有 NUMA 节点的软限制树中移除。\n\n- **`mem_cgroup_largest_soft_limit_node()`**  \n  从指定节点的软限制树中找出超出软限制最多的 memcg 节点，用于优先回收。\n\n- **`mem_cgroup_soft_reclaim()`**  \n  对指定 memcg 层级结构执行软限制驱动的内存回收。\n\n- **`memcg1_soft_limit_reclaim()`**（未完整显示）  \n  全局软限制回收入口函数，由内存短缺路径调用，尝试从超出软限制的 memcg 中回收内存。\n\n## 3. 关键实现\n\n### 软限制红黑树机制\n\n- 所有超出软限制（`memory.usage > soft_limit`）的 `mem_cgroup_per_node` 实例被组织到 per-NUMA-node 的红黑树中。\n- 树按 `usage_in_excess = usage - soft_limit` 升序排列，最右侧节点即为超出最多的 memcg。\n- 当 memcg 的内存使用量变化或软限制被修改时，调用 `memcg1_update_tree()` 更新其在树中的位置（先删除再重新插入）。\n- 回收时优先选择 `rb_rightmost` 节点，确保优先回收“最违规”的 memcg。\n\n### 层级遍历与祖先更新\n\n- 在启用 cgroup 层级模式时，子 memcg 的内存使用会影响父 memcg 的统计。\n- 因此，当子 memcg 的使用量变化时，需向上遍历所有祖先，更新它们在软限制树中的状态。\n\n### 防止无限循环的回收控制\n\n- `MEM_CGROUP_MAX_RECLAIM_LOOPS`（100）和 `MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS`（2）用于限制回收循环次数。\n- 若一轮遍历未回收足够内存（`total < excess >> 2`），最多再尝试一次。\n\n### 与 LRU_GEN 的集成\n\n- 若启用了多代 LRU（`lru_gen_enabled()`），则绕过红黑树机制，直接调用 `lru_gen_soft_reclaim()` 进行软限制回收。\n\n### 事件通知机制\n\n- 支持通过 `eventfd` 向用户空间发送 OOM 或其他内存事件通知。\n- 使用 `poll_table` 和 `wait_queue` 实现 eventfd 的自动注销（当 fd 关闭时）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memcontrol.h>`：内存控制组核心接口\n  - `<linux/swap.h>`, `\"swap.h\"`：交换子系统支持\n  - `<linux/eventfd.h>`, `<linux/poll.h>`：事件通知机制\n  - `\"internal.h\"`：内核内存管理内部接口\n\n- **功能依赖**：\n  - 依赖 `page_counter` 子系统进行内存使用量统计\n  - 依赖 `mem_cgroup_iter()` 实现层级遍历\n  - 依赖 `mem_cgroup_shrink_node()` 执行实际页面回收\n  - 可选依赖 `lru_gen` 多代 LRU 回收器\n\n- **配置依赖**：\n  - `CONFIG_MEMCG`：必须启用内存 cgroup\n  - `CONFIG_LOCKDEP`：仅在调试时定义锁依赖映射\n\n## 5. 使用场景\n\n- **内存压力下的软限制回收**：当系统内存紧张时，`kswapd` 或直接回收路径会调用 `memcg1_soft_limit_reclaim()`，优先从超出软限制的 memcg 中回收内存，以维持服务质量（QoS）。\n- **cgroup v1 接口兼容**：为 `/sys/fs/cgroup/memory/` 下的 `memory.soft_limit_in_bytes` 等文件提供后端支持。\n- **OOM 事件通知**：当 memcg 触发 OOM 时，通过预先注册的 eventfd 向用户空间守护进程（如容器运行时）发送通知。\n- **动态资源调整**：当用户通过写入 `memory.soft_limit_in_bytes` 修改软限制时，触发 `memcg1_update_tree()` 更新红黑树结构。\n- **memcg 销毁清理**：在 cgroup 被删除时，确保其从所有软限制树中正确移除，防止悬挂指针。",
      "similarity": 0.5396016240119934,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 404,
          "end_line": 520,
          "content": [
            "static u64 mem_cgroup_move_charge_read(struct cgroup_subsys_state *css,",
            "\t\t\t\tstruct cftype *cft)",
            "{",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,",
            "\t\t\t\t struct cftype *cft, u64 val)",
            "{",
            "\tpr_warn_once(\"Cgroup memory moving (move_charge_at_immigrate) is deprecated. \"",
            "\t\t     \"Please report your usecase to linux-mm@kvack.org if you \"",
            "\t\t     \"depend on this functionality.\\n\");",
            "",
            "\tif (val != 0)",
            "\t\treturn -EINVAL;",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,",
            "\t\t\t\t struct cftype *cft, u64 val)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "static void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)",
            "{",
            "\tstruct mem_cgroup_threshold_ary *t;",
            "\tunsigned long usage;",
            "\tint i;",
            "",
            "\trcu_read_lock();",
            "\tif (!swap)",
            "\t\tt = rcu_dereference(memcg->thresholds.primary);",
            "\telse",
            "\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);",
            "",
            "\tif (!t)",
            "\t\tgoto unlock;",
            "",
            "\tusage = mem_cgroup_usage(memcg, swap);",
            "",
            "\t/*",
            "\t * current_threshold points to threshold just below or equal to usage.",
            "\t * If it's not true, a threshold was crossed after last",
            "\t * call of __mem_cgroup_threshold().",
            "\t */",
            "\ti = t->current_threshold;",
            "",
            "\t/*",
            "\t * Iterate backward over array of thresholds starting from",
            "\t * current_threshold and check if a threshold is crossed.",
            "\t * If none of thresholds below usage is crossed, we read",
            "\t * only one element of the array here.",
            "\t */",
            "\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)",
            "\t\teventfd_signal(t->entries[i].eventfd);",
            "",
            "\t/* i = current_threshold + 1 */",
            "\ti++;",
            "",
            "\t/*",
            "\t * Iterate forward over array of thresholds starting from",
            "\t * current_threshold+1 and check if a threshold is crossed.",
            "\t * If none of thresholds above usage is crossed, we read",
            "\t * only one element of the array here.",
            "\t */",
            "\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)",
            "\t\teventfd_signal(t->entries[i].eventfd);",
            "",
            "\t/* Update current_threshold */",
            "\tt->current_threshold = i - 1;",
            "unlock:",
            "\trcu_read_unlock();",
            "}",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg)",
            "{",
            "\twhile (memcg) {",
            "\t\t__mem_cgroup_threshold(memcg, false);",
            "\t\tif (do_memsw_account())",
            "\t\t\t__mem_cgroup_threshold(memcg, true);",
            "",
            "\t\tmemcg = parent_mem_cgroup(memcg);",
            "\t}",
            "}",
            "static void memcg1_charge_statistics(struct mem_cgroup *memcg, int nr_pages)",
            "{",
            "\t/* pagein of a big page is an event. So, ignore page size */",
            "\tif (nr_pages > 0)",
            "\t\t__count_memcg_events(memcg, PGPGIN, 1);",
            "\telse {",
            "\t\t__count_memcg_events(memcg, PGPGOUT, 1);",
            "\t\tnr_pages = -nr_pages; /* for event */",
            "\t}",
            "",
            "\t__this_cpu_add(memcg->events_percpu->nr_page_events, nr_pages);",
            "}",
            "static bool memcg1_event_ratelimit(struct mem_cgroup *memcg,",
            "\t\t\t\tenum mem_cgroup_events_target target)",
            "{",
            "\tunsigned long val, next;",
            "",
            "\tval = __this_cpu_read(memcg->events_percpu->nr_page_events);",
            "\tnext = __this_cpu_read(memcg->events_percpu->targets[target]);",
            "\t/* from time_after() in jiffies.h */",
            "\tif ((long)(next - val) < 0) {",
            "\t\tswitch (target) {",
            "\t\tcase MEM_CGROUP_TARGET_THRESH:",
            "\t\t\tnext = val + THRESHOLDS_EVENTS_TARGET;",
            "\t\t\tbreak;",
            "\t\tcase MEM_CGROUP_TARGET_SOFTLIMIT:",
            "\t\t\tnext = val + SOFTLIMIT_EVENTS_TARGET;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t__this_cpu_write(memcg->events_percpu->targets[target], next);",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}"
          ],
          "function_name": "mem_cgroup_move_charge_read, mem_cgroup_move_charge_write, mem_cgroup_move_charge_write, __mem_cgroup_threshold, mem_cgroup_threshold, memcg1_charge_statistics, memcg1_event_ratelimit",
          "description": "实现内存使用阈值监测与事件触发机制，包含阈值比较排序、事件信号发送及页面事件统计功能，通过事件限速机制控制通知频率，支持软限制和交换空间双重阈值监控。",
          "similarity": 0.5058907270431519
        },
        {
          "chunk_id": 8,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 1222,
          "end_line": 1369,
          "content": [
            "void memcg1_oom_recover(struct mem_cgroup *memcg)",
            "{",
            "\t/*",
            "\t * For the following lockless ->under_oom test, the only required",
            "\t * guarantee is that it must see the state asserted by an OOM when",
            "\t * this function is called as a result of userland actions",
            "\t * triggered by the notification of the OOM.  This is trivially",
            "\t * achieved by invoking mem_cgroup_mark_under_oom() before",
            "\t * triggering notification.",
            "\t */",
            "\tif (memcg && memcg->under_oom)",
            "\t\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);",
            "}",
            "bool mem_cgroup_oom_synchronize(bool handle)",
            "{",
            "\tstruct mem_cgroup *memcg = current->memcg_in_oom;",
            "\tstruct oom_wait_info owait;",
            "\tbool locked;",
            "",
            "\t/* OOM is global, do not handle */",
            "\tif (!memcg)",
            "\t\treturn false;",
            "",
            "\tif (!handle)",
            "\t\tgoto cleanup;",
            "",
            "\towait.memcg = memcg;",
            "\towait.wait.flags = 0;",
            "\towait.wait.func = memcg_oom_wake_function;",
            "\towait.wait.private = current;",
            "\tINIT_LIST_HEAD(&owait.wait.entry);",
            "",
            "\tprepare_to_wait(&memcg_oom_waitq, &owait.wait, TASK_KILLABLE);",
            "\tmem_cgroup_mark_under_oom(memcg);",
            "",
            "\tlocked = mem_cgroup_oom_trylock(memcg);",
            "",
            "\tif (locked)",
            "\t\tmem_cgroup_oom_notify(memcg);",
            "",
            "\tschedule();",
            "\tmem_cgroup_unmark_under_oom(memcg);",
            "\tfinish_wait(&memcg_oom_waitq, &owait.wait);",
            "",
            "\tif (locked)",
            "\t\tmem_cgroup_oom_unlock(memcg);",
            "cleanup:",
            "\tcurrent->memcg_in_oom = NULL;",
            "\tcss_put(&memcg->css);",
            "\treturn true;",
            "}",
            "bool memcg1_oom_prepare(struct mem_cgroup *memcg, bool *locked)",
            "{",
            "\t/*",
            "\t * We are in the middle of the charge context here, so we",
            "\t * don't want to block when potentially sitting on a callstack",
            "\t * that holds all kinds of filesystem and mm locks.",
            "\t *",
            "\t * cgroup1 allows disabling the OOM killer and waiting for outside",
            "\t * handling until the charge can succeed; remember the context and put",
            "\t * the task to sleep at the end of the page fault when all locks are",
            "\t * released.",
            "\t *",
            "\t * On the other hand, in-kernel OOM killer allows for an async victim",
            "\t * memory reclaim (oom_reaper) and that means that we are not solely",
            "\t * relying on the oom victim to make a forward progress and we can",
            "\t * invoke the oom killer here.",
            "\t *",
            "\t * Please note that mem_cgroup_out_of_memory might fail to find a",
            "\t * victim and then we have to bail out from the charge path.",
            "\t */",
            "\tif (READ_ONCE(memcg->oom_kill_disable)) {",
            "\t\tif (current->in_user_fault) {",
            "\t\t\tcss_get(&memcg->css);",
            "\t\t\tcurrent->memcg_in_oom = memcg;",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "",
            "\tmem_cgroup_mark_under_oom(memcg);",
            "",
            "\t*locked = mem_cgroup_oom_trylock(memcg);",
            "",
            "\tif (*locked)",
            "\t\tmem_cgroup_oom_notify(memcg);",
            "",
            "\tmem_cgroup_unmark_under_oom(memcg);",
            "",
            "\treturn true;",
            "}",
            "void memcg1_oom_finish(struct mem_cgroup *memcg, bool locked)",
            "{",
            "\tif (locked)",
            "\t\tmem_cgroup_oom_unlock(memcg);",
            "}",
            "static int mem_cgroup_resize_max(struct mem_cgroup *memcg,",
            "\t\t\t\t unsigned long max, bool memsw)",
            "{",
            "\tbool enlarge = false;",
            "\tbool drained = false;",
            "\tint ret;",
            "\tbool limits_invariant;",
            "\tstruct page_counter *counter = memsw ? &memcg->memsw : &memcg->memory;",
            "",
            "\tdo {",
            "\t\tif (signal_pending(current)) {",
            "\t\t\tret = -EINTR;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tmutex_lock(&memcg_max_mutex);",
            "\t\t/*",
            "\t\t * Make sure that the new limit (memsw or memory limit) doesn't",
            "\t\t * break our basic invariant rule memory.max <= memsw.max.",
            "\t\t */",
            "\t\tlimits_invariant = memsw ? max >= READ_ONCE(memcg->memory.max) :",
            "\t\t\t\t\t   max <= memcg->memsw.max;",
            "\t\tif (!limits_invariant) {",
            "\t\t\tmutex_unlock(&memcg_max_mutex);",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (max > counter->max)",
            "\t\t\tenlarge = true;",
            "\t\tret = page_counter_set_max(counter, max);",
            "\t\tmutex_unlock(&memcg_max_mutex);",
            "",
            "\t\tif (!ret)",
            "\t\t\tbreak;",
            "",
            "\t\tif (!drained) {",
            "\t\t\tdrain_all_stock(memcg);",
            "\t\t\tdrained = true;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!try_to_free_mem_cgroup_pages(memcg, 1, GFP_KERNEL,",
            "\t\t\t\t\tmemsw ? 0 : MEMCG_RECLAIM_MAY_SWAP)) {",
            "\t\t\tret = -EBUSY;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t} while (true);",
            "",
            "\tif (!ret && enlarge)",
            "\t\tmemcg1_oom_recover(memcg);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "memcg1_oom_recover, mem_cgroup_oom_synchronize, memcg1_oom_prepare, memcg1_oom_finish, mem_cgroup_resize_max",
          "description": "实现OOM恢复、同步及内存限制调整功能。包含OOM唤醒队列通知、OOM同步处理、内存限制动态调整及页面回收逻辑，通过循环尝试释放页面直到满足新限制条件。",
          "similarity": 0.4815910756587982
        },
        {
          "chunk_id": 10,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 1544,
          "end_line": 1646,
          "content": [
            "static ssize_t mem_cgroup_write(struct kernfs_open_file *of,",
            "\t\t\t\tchar *buf, size_t nbytes, loff_t off)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));",
            "\tunsigned long nr_pages;",
            "\tint ret;",
            "",
            "\tbuf = strstrip(buf);",
            "\tret = page_counter_memparse(buf, \"-1\", &nr_pages);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {",
            "\tcase RES_LIMIT:",
            "\t\tif (mem_cgroup_is_root(memcg)) { /* Can't set limit on root */",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {",
            "\t\tcase _MEM:",
            "\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, false);",
            "\t\t\tbreak;",
            "\t\tcase _MEMSWAP:",
            "\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, true);",
            "\t\t\tbreak;",
            "\t\tcase _KMEM:",
            "\t\t\tpr_warn_once(\"kmem.limit_in_bytes is deprecated and will be removed. \"",
            "\t\t\t\t     \"Writing any value to this file has no effect. \"",
            "\t\t\t\t     \"Please report your usecase to linux-mm@kvack.org if you \"",
            "\t\t\t\t     \"depend on this functionality.\\n\");",
            "\t\t\tret = 0;",
            "\t\t\tbreak;",
            "\t\tcase _TCP:",
            "\t\t\tret = memcg_update_tcp_max(memcg, nr_pages);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase RES_SOFT_LIMIT:",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\t\tret = -EOPNOTSUPP;",
            "\t\t} else {",
            "\t\t\tWRITE_ONCE(memcg->soft_limit, nr_pages);",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t\tbreak;",
            "\t}",
            "\treturn ret ?: nbytes;",
            "}",
            "static ssize_t mem_cgroup_reset(struct kernfs_open_file *of, char *buf,",
            "\t\t\t\tsize_t nbytes, loff_t off)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));",
            "\tstruct page_counter *counter;",
            "",
            "\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {",
            "\tcase _MEM:",
            "\t\tcounter = &memcg->memory;",
            "\t\tbreak;",
            "\tcase _MEMSWAP:",
            "\t\tcounter = &memcg->memsw;",
            "\t\tbreak;",
            "\tcase _KMEM:",
            "\t\tcounter = &memcg->kmem;",
            "\t\tbreak;",
            "\tcase _TCP:",
            "\t\tcounter = &memcg->tcpmem;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {",
            "\tcase RES_MAX_USAGE:",
            "\t\tpage_counter_reset_watermark(counter);",
            "\t\tbreak;",
            "\tcase RES_FAILCNT:",
            "\t\tcounter->failcnt = 0;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\treturn nbytes;",
            "}",
            "static unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,",
            "\t\t\t\tint nid, unsigned int lru_mask, bool tree)",
            "{",
            "\tstruct lruvec *lruvec = mem_cgroup_lruvec(memcg, NODE_DATA(nid));",
            "\tunsigned long nr = 0;",
            "\tenum lru_list lru;",
            "",
            "\tVM_BUG_ON((unsigned)nid >= nr_node_ids);",
            "",
            "\tfor_each_lru(lru) {",
            "\t\tif (!(BIT(lru) & lru_mask))",
            "\t\t\tcontinue;",
            "\t\tif (tree)",
            "\t\t\tnr += lruvec_page_state(lruvec, NR_LRU_BASE + lru);",
            "\t\telse",
            "\t\t\tnr += lruvec_page_state_local(lruvec, NR_LRU_BASE + lru);",
            "\t}",
            "\treturn nr;",
            "}"
          ],
          "function_name": "mem_cgroup_write, mem_cgroup_reset, mem_cgroup_node_nr_lru_pages",
          "description": "实现内存控制组的写操作接口，根据不同的属性类型设置内存限制（如RES_LIMIT、RES_SOFT_LIMIT），对根控制组禁止设置限制并处理相应错误码。",
          "similarity": 0.4784390330314636
        },
        {
          "chunk_id": 4,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 537,
          "end_line": 698,
          "content": [
            "static void memcg1_check_events(struct mem_cgroup *memcg, int nid)",
            "{",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT))",
            "\t\treturn;",
            "",
            "\t/* threshold event is triggered in finer grain than soft limit */",
            "\tif (unlikely(memcg1_event_ratelimit(memcg,",
            "\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {",
            "\t\tbool do_softlimit;",
            "",
            "\t\tdo_softlimit = memcg1_event_ratelimit(memcg,",
            "\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);",
            "\t\tmem_cgroup_threshold(memcg);",
            "\t\tif (unlikely(do_softlimit))",
            "\t\t\tmemcg1_update_tree(memcg, nid);",
            "\t}",
            "}",
            "void memcg1_commit_charge(struct folio *folio, struct mem_cgroup *memcg)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\tmemcg1_charge_statistics(memcg, folio_nr_pages(folio));",
            "\tmemcg1_check_events(memcg, folio_nid(folio));",
            "\tlocal_irq_restore(flags);",
            "}",
            "void memcg1_swapout(struct folio *folio, struct mem_cgroup *memcg)",
            "{",
            "\t/*",
            "\t * Interrupts should be disabled here because the caller holds the",
            "\t * i_pages lock which is taken with interrupts-off. It is",
            "\t * important here to have the interrupts disabled because it is the",
            "\t * only synchronisation we have for updating the per-CPU variables.",
            "\t */",
            "\tpreempt_disable_nested();",
            "\tVM_WARN_ON_IRQS_ENABLED();",
            "\tmemcg1_charge_statistics(memcg, -folio_nr_pages(folio));",
            "\tpreempt_enable_nested();",
            "\tmemcg1_check_events(memcg, folio_nid(folio));",
            "}",
            "void memcg1_uncharge_batch(struct mem_cgroup *memcg, unsigned long pgpgout,",
            "\t\t\t   unsigned long nr_memory, int nid)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\t__count_memcg_events(memcg, PGPGOUT, pgpgout);",
            "\t__this_cpu_add(memcg->events_percpu->nr_page_events, nr_memory);",
            "\tmemcg1_check_events(memcg, nid);",
            "\tlocal_irq_restore(flags);",
            "}",
            "static int compare_thresholds(const void *a, const void *b)",
            "{",
            "\tconst struct mem_cgroup_threshold *_a = a;",
            "\tconst struct mem_cgroup_threshold *_b = b;",
            "",
            "\tif (_a->threshold > _b->threshold)",
            "\t\treturn 1;",
            "",
            "\tif (_a->threshold < _b->threshold)",
            "\t\treturn -1;",
            "",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_oom_notify_cb(struct mem_cgroup *memcg)",
            "{",
            "\tstruct mem_cgroup_eventfd_list *ev;",
            "",
            "\tspin_lock(&memcg_oom_lock);",
            "",
            "\tlist_for_each_entry(ev, &memcg->oom_notify, list)",
            "\t\teventfd_signal(ev->eventfd);",
            "",
            "\tspin_unlock(&memcg_oom_lock);",
            "\treturn 0;",
            "}",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg)",
            "{",
            "\tstruct mem_cgroup *iter;",
            "",
            "\tfor_each_mem_cgroup_tree(iter, memcg)",
            "\t\tmem_cgroup_oom_notify_cb(iter);",
            "}",
            "static int __mem_cgroup_usage_register_event(struct mem_cgroup *memcg,",
            "\tstruct eventfd_ctx *eventfd, const char *args, enum res_type type)",
            "{",
            "\tstruct mem_cgroup_thresholds *thresholds;",
            "\tstruct mem_cgroup_threshold_ary *new;",
            "\tunsigned long threshold;",
            "\tunsigned long usage;",
            "\tint i, size, ret;",
            "",
            "\tret = page_counter_memparse(args, \"-1\", &threshold);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tmutex_lock(&memcg->thresholds_lock);",
            "",
            "\tif (type == _MEM) {",
            "\t\tthresholds = &memcg->thresholds;",
            "\t\tusage = mem_cgroup_usage(memcg, false);",
            "\t} else if (type == _MEMSWAP) {",
            "\t\tthresholds = &memcg->memsw_thresholds;",
            "\t\tusage = mem_cgroup_usage(memcg, true);",
            "\t} else",
            "\t\tBUG();",
            "",
            "\t/* Check if a threshold crossed before adding a new one */",
            "\tif (thresholds->primary)",
            "\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);",
            "",
            "\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;",
            "",
            "\t/* Allocate memory for new array of thresholds */",
            "\tnew = kmalloc(struct_size(new, entries, size), GFP_KERNEL);",
            "\tif (!new) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto unlock;",
            "\t}",
            "\tnew->size = size;",
            "",
            "\t/* Copy thresholds (if any) to new array */",
            "\tif (thresholds->primary)",
            "\t\tmemcpy(new->entries, thresholds->primary->entries,",
            "\t\t       flex_array_size(new, entries, size - 1));",
            "",
            "\t/* Add new threshold */",
            "\tnew->entries[size - 1].eventfd = eventfd;",
            "\tnew->entries[size - 1].threshold = threshold;",
            "",
            "\t/* Sort thresholds. Registering of new threshold isn't time-critical */",
            "\tsort(new->entries, size, sizeof(*new->entries),",
            "\t\t\tcompare_thresholds, NULL);",
            "",
            "\t/* Find current threshold */",
            "\tnew->current_threshold = -1;",
            "\tfor (i = 0; i < size; i++) {",
            "\t\tif (new->entries[i].threshold <= usage) {",
            "\t\t\t/*",
            "\t\t\t * new->current_threshold will not be used until",
            "\t\t\t * rcu_assign_pointer(), so it's safe to increment",
            "\t\t\t * it here.",
            "\t\t\t */",
            "\t\t\t++new->current_threshold;",
            "\t\t} else",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\t/* Free old spare buffer and save old primary buffer as spare */",
            "\tkfree(thresholds->spare);",
            "\tthresholds->spare = thresholds->primary;",
            "",
            "\trcu_assign_pointer(thresholds->primary, new);",
            "",
            "\t/* To be sure that nobody uses thresholds */",
            "\tsynchronize_rcu();",
            "",
            "unlock:",
            "\tmutex_unlock(&memcg->thresholds_lock);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "memcg1_check_events, memcg1_commit_charge, memcg1_swapout, memcg1_uncharge_batch, compare_thresholds, mem_cgroup_oom_notify_cb, mem_cgroup_oom_notify, __mem_cgroup_usage_register_event",
          "description": "集成内存使用事件检测与通知系统，包含页面计数更新、事件触发检查、OOM通知传播等功能，通过RCU机制安全更新阈值数组，并处理内存分配/释放时的统计与监控任务。",
          "similarity": 0.4765787124633789
        },
        {
          "chunk_id": 12,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 1838,
          "end_line": 1934,
          "content": [
            "static u64 mem_cgroup_swappiness_read(struct cgroup_subsys_state *css,",
            "\t\t\t\t      struct cftype *cft)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);",
            "",
            "\treturn mem_cgroup_swappiness(memcg);",
            "}",
            "static int mem_cgroup_swappiness_write(struct cgroup_subsys_state *css,",
            "\t\t\t\t       struct cftype *cft, u64 val)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);",
            "",
            "\tif (val > 200)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!mem_cgroup_is_root(memcg))",
            "\t\tWRITE_ONCE(memcg->swappiness, val);",
            "\telse",
            "\t\tWRITE_ONCE(vm_swappiness, val);",
            "",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_oom_control_read(struct seq_file *sf, void *v)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_seq(sf);",
            "",
            "\tseq_printf(sf, \"oom_kill_disable %d\\n\", READ_ONCE(memcg->oom_kill_disable));",
            "\tseq_printf(sf, \"under_oom %d\\n\", (bool)memcg->under_oom);",
            "\tseq_printf(sf, \"oom_kill %lu\\n\",",
            "\t\t   atomic_long_read(&memcg->memory_events[MEMCG_OOM_KILL]));",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_oom_control_write(struct cgroup_subsys_state *css,",
            "\tstruct cftype *cft, u64 val)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);",
            "",
            "\t/* cannot set to root cgroup and only 0 and 1 are allowed */",
            "\tif (mem_cgroup_is_root(memcg) || !((val == 0) || (val == 1)))",
            "\t\treturn -EINVAL;",
            "",
            "\tWRITE_ONCE(memcg->oom_kill_disable, val);",
            "\tif (!val)",
            "\t\tmemcg1_oom_recover(memcg);",
            "",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_slab_show(struct seq_file *m, void *p)",
            "{",
            "\t/*",
            "\t * Deprecated.",
            "\t * Please, take a look at tools/cgroup/memcg_slabinfo.py .",
            "\t */",
            "\treturn 0;",
            "}",
            "void memcg1_account_kmem(struct mem_cgroup *memcg, int nr_pages)",
            "{",
            "\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys)) {",
            "\t\tif (nr_pages > 0)",
            "\t\t\tpage_counter_charge(&memcg->kmem, nr_pages);",
            "\t\telse",
            "\t\t\tpage_counter_uncharge(&memcg->kmem, -nr_pages);",
            "\t}",
            "}",
            "bool memcg1_charge_skmem(struct mem_cgroup *memcg, unsigned int nr_pages,",
            "\t\t\t gfp_t gfp_mask)",
            "{",
            "\tstruct page_counter *fail;",
            "",
            "\tif (page_counter_try_charge(&memcg->tcpmem, nr_pages, &fail)) {",
            "\t\tmemcg->tcpmem_pressure = 0;",
            "\t\treturn true;",
            "\t}",
            "\tmemcg->tcpmem_pressure = 1;",
            "\tif (gfp_mask & __GFP_NOFAIL) {",
            "\t\tpage_counter_charge(&memcg->tcpmem, nr_pages);",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static int __init memcg1_init(void)",
            "{",
            "\tint node;",
            "",
            "\tfor_each_node(node) {",
            "\t\tstruct mem_cgroup_tree_per_node *rtpn;",
            "",
            "\t\trtpn = kzalloc_node(sizeof(*rtpn), GFP_KERNEL, node);",
            "",
            "\t\trtpn->rb_root = RB_ROOT;",
            "\t\trtpn->rb_rightmost = NULL;",
            "\t\tspin_lock_init(&rtpn->lock);",
            "\t\tsoft_limit_tree.rb_tree_per_node[node] = rtpn;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "mem_cgroup_swappiness_read, mem_cgroup_swappiness_write, mem_cgroup_oom_control_read, mem_cgroup_oom_control_write, mem_cgroup_slab_show, memcg1_account_kmem, memcg1_charge_skmem, memcg1_init",
          "description": "实现swappiness参数读写、OOM控制策略配置、Slab信息展示及内核内存计费逻辑，初始化节点级红黑树结构以支持层级内存控制。",
          "similarity": 0.47456955909729004
        }
      ]
    },
    {
      "source_file": "mm/mprotect.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:55:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mprotect.c`\n\n---\n\n# mprotect.c 技术文档\n\n## 1. 文件概述\n\n`mm/mprotect.c` 是 Linux 内核内存管理子系统中的核心文件，主要负责实现 `mprotect()` 系统调用的底层逻辑。该文件提供了对虚拟内存区域（VMA）中页表项（PTE）保护属性进行动态修改的能力，包括读、写、执行权限以及特殊标志（如 userfaultfd 写保护、NUMA 迁移提示等）的调整。它确保在修改页表权限时正确处理共享/私有映射、写时复制（COW）、脏页跟踪、软脏位、KSM 页面、迁移条目、设备私有内存等多种复杂场景，并维护 TLB 一致性与内存安全性。\n\n## 2. 核心功能\n\n### 主要函数\n- **`can_change_pte_writable()`**  \n  判断在不触发缺页异常的前提下，是否可以直接将某个 PTE 标记为可写。该函数综合考虑了 VMA 的写权限、软脏位跟踪、userfaultfd 写保护（uffd-wp）以及共享/私有映射语义等因素。\n\n- **`change_pte_range()`**  \n  核心函数，遍历指定地址范围内的页表项（PTE），根据传入的新保护属性（`newprot`）和控制标志（`cp_flags`）更新每个 PTE。支持处理以下类型条目：\n  - 普通物理页（present PTE）\n  - 交换条目（swap PTE），包括迁移条目、设备私有/独占条目、PTE 标记等\n  - 空 PTE（none PTE），主要用于 userfaultfd 场景\n\n### 关键数据结构与标志\n- **`cp_flags` 控制标志**：\n  - `MM_CP_PROT_NUMA`：用于 NUMA 平衡，避免不必要的 TLB 刷新\n  - `MM_CP_UFFD_WP`：启用 userfaultfd 写保护\n  - `MM_CP_UFFD_WP_RESOLVE`：解除 userfaultfd 写保护\n  - `MM_CP_TRY_CHANGE_WRITABLE`：尝试直接设置 PTE 可写而不触发缺页\n\n- **页表项类型处理**：\n  - 普通匿名页、文件页\n  - KSM（Kernel Samepage Merging）页面\n  - 设备私有/独占内存（HMM/ZONE_DEVICE）\n  - 迁移条目（migration entries）\n  - PTE 标记（pte markers），用于 userfaultfd 错误处理\n\n## 3. 关键实现\n\n### 权限修改的安全性检查\n`can_change_pte_writable()` 函数实现了精细的权限判断逻辑：\n- 仅当 VMA 具有 `VM_WRITE` 标志时才允许写操作\n- 跳过不可读的 PTE（`pte_protnone`）\n- 若启用了软脏位跟踪但 PTE 未标记软脏，则需保留写保护以触发缺页记录\n- 若启用了 userfaultfd 写保护，则不能直接设为可写\n\n对于私有映射（`MAP_PRIVATE`），仅当页面是**独占匿名页**（`PageAnonExclusive`）时才可安全设为可写；对于共享映射（`MAP_SHARED`），仅当页面已为脏（`pte_dirty`）时才可设为可写，以确保文件系统已收到写通知。\n\n### NUMA 平衡优化\n在 `MM_CP_PROT_NUMA` 模式下，`change_pte_range()` 会跳过以下页面以避免不必要的 TLB 刷新和迁移开销：\n- 已位于当前 CPU 所在 NUMA 节点的页面\n- 顶层内存层级（top-tier）节点上的页面（若 NUMA 平衡被禁用）\n- KSM 页面、设备页面、共享 COW 页面、脏文件页等不适合迁移的页面\n\n### 交换条目处理\n对非 present PTE（即 swap PTE），函数会根据条目类型进行相应转换：\n- **可写迁移条目** → 转换为只读迁移条目\n- **可写设备私有/独占条目** → 转换为只读版本\n- **PTE 标记**：若为 poisoned 条目则跳过；若需解除 uffd-wp 且使用 marker，则直接清除 PTE\n\n### Userfaultfd 写保护集成\n通过 `MM_CP_UFFD_WP` 和 `MM_CP_UFFD_WP_RESOLVE` 标志，支持动态启用/禁用 userfaultfd 的写保护机制：\n- 对 present PTE：使用 `pte_mkuffd_wp()` / `pte_clear_uffd_wp()`\n- 对 swap PTE：使用对应的 `pte_swp_mkuffd_wp()` / `pte_swp_clear_uffd_wp()`\n- 对空 PTE：在支持 marker 的 VMA 中安装 PTE marker 以拦截后续写操作\n\n### TLB 与缓存一致性\n- 使用 `tlb_flush_pte_range()` 在 PTE 修改后刷新 TLB\n- 调用 `arch_enter_lazy_mmu_mode()` 优化批量 MMU 操作\n- 在修改前调用 `flush_tlb_batched_pending()` 确保 pending TLB flush 已完成\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n- **内存管理核心**：`<linux/mm.h>`, `\"internal.h\"`, `<linux/pgtable.h>`\n- **页表遍历**：`<linux/pagewalk.h>`\n- **特殊内存类型**：`<linux/hugetlb.h>`, `<linux/ksm.h>`, `<linux/shm.h>`\n- **NUMA 与迁移**：`<linux/mempolicy.h>`, `<linux/migrate.h>`, `<linux/memory-tiers.h>`\n- **用户态交互**：`<linux/syscalls.h>`, `<linux/uaccess.h>`\n- **安全与审计**：`<linux/security.h>`, `<linux/perf_event.h>`\n- **体系结构相关**：`<asm/cacheflush.h>`, `<asm/tlbflush.h>`, `<asm/mmu_context.h>`\n\n### 功能模块交互\n- **Userfaultfd 子系统**：通过 `userfaultfd_pte_wp()`、`userfaultfd_wp_use_markers()` 等接口集成写保护功能\n- **KSM（同页合并）**：识别并跳过 KSM 页面以避免破坏共享语义\n- **HMM（异构内存管理）**：处理设备私有/独占内存的 PTE 条目\n- **Soft-dirty 跟踪**：维护软脏位状态以支持 checkpoint/restore\n- **NUMA Balancing**：与 `sysctl_numa_balancing_mode` 交互实现智能页面迁移\n\n## 5. 使用场景\n\n### 系统调用层\n- **`mprotect(2)` 系统调用**：用户程序通过此调用修改内存段的访问权限（如去除写权限实现写保护，或添加执行权限用于 JIT）\n- **`pkey_mprotect(2)`**：结合保护键（protection keys）进行更细粒度的内存保护\n\n### 内核子系统\n- **Userfaultfd 机制**：在用户态缺页处理中动态应用/解除写保护\n- **Checkpoint/Restore（CRIU）**：利用软脏位跟踪配合 mprotect 实现增量内存快照\n- **JIT 编译器**：先分配 RW 内存写入代码，再通过 mprotect 切换为 RX 权限\n- **沙箱与安全模块**：动态限制进程内存访问能力（如 seccomp、SELinux 策略）\n- **NUMA 自动平衡**：内核周期性调用 mprotect 类操作来迁移页面并更新 PTE 访问提示\n\n### 特殊内存管理\n- **透明大页（THP）降级**：在需要修改部分 PTE 权限时拆分大页\n- **内存热插拔/迁移**：在页面迁移过程中临时修改 PTE 权限\n- **设备内存映射**：管理 GPU/FPGA 等设备内存的 CPU 访问权限",
      "similarity": 0.5362844467163086,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/mprotect.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  mm/mprotect.c",
            " *",
            " *  (C) Copyright 1994 Linus Torvalds",
            " *  (C) Copyright 2002 Christoph Hellwig",
            " *",
            " *  Address space accounting code\t<alan@lxorguk.ukuu.org.uk>",
            " *  (C) Copyright 2002 Red Hat Inc, All Rights Reserved",
            " */",
            "",
            "#include <linux/pagewalk.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shm.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/migrate.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/ksm.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memory-tiers.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "",
            "#include \"internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "包含头文件并声明内部辅助函数，为地址空间保护修改提供基础设施。",
          "similarity": 0.5917494297027588
        },
        {
          "chunk_id": 5,
          "file_path": "mm/mprotect.c",
          "start_line": 671,
          "end_line": 816,
          "content": [
            "static int do_mprotect_pkey(unsigned long start, size_t len,",
            "\t\tunsigned long prot, int pkey)",
            "{",
            "\tunsigned long nstart, end, tmp, reqprot;",
            "\tstruct vm_area_struct *vma, *prev;",
            "\tint error;",
            "\tconst int grows = prot & (PROT_GROWSDOWN|PROT_GROWSUP);",
            "\tconst bool rier = (current->personality & READ_IMPLIES_EXEC) &&",
            "\t\t\t\t(prot & PROT_READ);",
            "\tstruct mmu_gather tlb;",
            "\tstruct vma_iterator vmi;",
            "",
            "\tstart = untagged_addr(start);",
            "",
            "\tprot &= ~(PROT_GROWSDOWN|PROT_GROWSUP);",
            "\tif (grows == (PROT_GROWSDOWN|PROT_GROWSUP)) /* can't be both */",
            "\t\treturn -EINVAL;",
            "",
            "\tif (start & ~PAGE_MASK)",
            "\t\treturn -EINVAL;",
            "\tif (!len)",
            "\t\treturn 0;",
            "\tlen = PAGE_ALIGN(len);",
            "\tend = start + len;",
            "\tif (end <= start)",
            "\t\treturn -ENOMEM;",
            "\tif (!arch_validate_prot(prot, start))",
            "\t\treturn -EINVAL;",
            "",
            "\treqprot = prot;",
            "",
            "\tif (mmap_write_lock_killable(current->mm))",
            "\t\treturn -EINTR;",
            "",
            "\t/*",
            "\t * If userspace did not allocate the pkey, do not let",
            "\t * them use it here.",
            "\t */",
            "\terror = -EINVAL;",
            "\tif ((pkey != -1) && !mm_pkey_is_allocated(current->mm, pkey))",
            "\t\tgoto out;",
            "",
            "\tvma_iter_init(&vmi, current->mm, start);",
            "\tvma = vma_find(&vmi, end);",
            "\terror = -ENOMEM;",
            "\tif (!vma)",
            "\t\tgoto out;",
            "",
            "\tif (unlikely(grows & PROT_GROWSDOWN)) {",
            "\t\tif (vma->vm_start >= end)",
            "\t\t\tgoto out;",
            "\t\tstart = vma->vm_start;",
            "\t\terror = -EINVAL;",
            "\t\tif (!(vma->vm_flags & VM_GROWSDOWN))",
            "\t\t\tgoto out;",
            "\t} else {",
            "\t\tif (vma->vm_start > start)",
            "\t\t\tgoto out;",
            "\t\tif (unlikely(grows & PROT_GROWSUP)) {",
            "\t\t\tend = vma->vm_end;",
            "\t\t\terror = -EINVAL;",
            "\t\t\tif (!(vma->vm_flags & VM_GROWSUP))",
            "\t\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tprev = vma_prev(&vmi);",
            "\tif (start > vma->vm_start)",
            "\t\tprev = vma;",
            "",
            "\ttlb_gather_mmu(&tlb, current->mm);",
            "\tnstart = start;",
            "\ttmp = vma->vm_start;",
            "\tfor_each_vma_range(vmi, vma, end) {",
            "\t\tunsigned long mask_off_old_flags;",
            "\t\tunsigned long newflags;",
            "\t\tint new_vma_pkey;",
            "",
            "\t\tif (vma->vm_start != tmp) {",
            "\t\t\terror = -ENOMEM;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Does the application expect PROT_READ to imply PROT_EXEC */",
            "\t\tif (rier && (vma->vm_flags & VM_MAYEXEC))",
            "\t\t\tprot |= PROT_EXEC;",
            "",
            "\t\t/*",
            "\t\t * Each mprotect() call explicitly passes r/w/x permissions.",
            "\t\t * If a permission is not passed to mprotect(), it must be",
            "\t\t * cleared from the VMA.",
            "\t\t */",
            "\t\tmask_off_old_flags = VM_ACCESS_FLAGS | VM_FLAGS_CLEAR;",
            "",
            "\t\tnew_vma_pkey = arch_override_mprotect_pkey(vma, prot, pkey);",
            "\t\tnewflags = calc_vm_prot_bits(prot, new_vma_pkey);",
            "\t\tnewflags |= (vma->vm_flags & ~mask_off_old_flags);",
            "",
            "\t\t/* newflags >> 4 shift VM_MAY% in place of VM_% */",
            "\t\tif ((newflags & ~(newflags >> 4)) & VM_ACCESS_FLAGS) {",
            "\t\t\terror = -EACCES;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (map_deny_write_exec(vma->vm_flags, newflags)) {",
            "\t\t\terror = -EACCES;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Allow architectures to sanity-check the new flags */",
            "\t\tif (!arch_validate_flags(newflags)) {",
            "\t\t\terror = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\terror = security_file_mprotect(vma, reqprot, prot);",
            "\t\tif (error)",
            "\t\t\tbreak;",
            "",
            "\t\ttmp = vma->vm_end;",
            "\t\tif (tmp > end)",
            "\t\t\ttmp = end;",
            "",
            "\t\tif (vma->vm_ops && vma->vm_ops->mprotect) {",
            "\t\t\terror = vma->vm_ops->mprotect(vma, nstart, tmp, newflags);",
            "\t\t\tif (error)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\terror = mprotect_fixup(&vmi, &tlb, vma, &prev, nstart, tmp, newflags);",
            "\t\tif (error)",
            "\t\t\tbreak;",
            "",
            "\t\ttmp = vma_iter_end(&vmi);",
            "\t\tnstart = tmp;",
            "\t\tprot = reqprot;",
            "\t}",
            "\ttlb_finish_mmu(&tlb);",
            "",
            "\tif (!error && tmp < end)",
            "\t\terror = -ENOMEM;",
            "",
            "out:",
            "\tmmap_write_unlock(current->mm);",
            "\treturn error;",
            "}"
          ],
          "function_name": "do_mprotect_pkey",
          "description": "该代码实现`do_mprotect_pkey`函数，用于处理带页键（PKey）的`mprotect`系统调用，核心功能是修改指定范围内存段的访问权限并关联页键。函数通过遍历目标VMA区域，校验地址合法性、权限兼容性及页键分配状态，结合架构特定的保护策略（如`arch_validate_prot`）和安全钩子（`security_file_mprotect`），最终更新页表保护位并触发TLB无效化。",
          "similarity": 0.5813581943511963
        },
        {
          "chunk_id": 3,
          "file_path": "mm/mprotect.c",
          "start_line": 439,
          "end_line": 541,
          "content": [
            "static inline long change_pud_range(struct mmu_gather *tlb,",
            "\t\tstruct vm_area_struct *vma, p4d_t *p4d, unsigned long addr,",
            "\t\tunsigned long end, pgprot_t newprot, unsigned long cp_flags)",
            "{",
            "\tpud_t *pud;",
            "\tunsigned long next;",
            "\tlong pages = 0, ret;",
            "",
            "\tpud = pud_offset(p4d, addr);",
            "\tdo {",
            "\t\tnext = pud_addr_end(addr, end);",
            "\t\tret = change_prepare(vma, pud, pmd, addr, cp_flags);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t\tif (pud_none_or_clear_bad(pud))",
            "\t\t\tcontinue;",
            "\t\tpages += change_pmd_range(tlb, vma, pud, addr, next, newprot,",
            "\t\t\t\t\t  cp_flags);",
            "\t} while (pud++, addr = next, addr != end);",
            "",
            "\treturn pages;",
            "}",
            "static inline long change_p4d_range(struct mmu_gather *tlb,",
            "\t\tstruct vm_area_struct *vma, pgd_t *pgd, unsigned long addr,",
            "\t\tunsigned long end, pgprot_t newprot, unsigned long cp_flags)",
            "{",
            "\tp4d_t *p4d;",
            "\tunsigned long next;",
            "\tlong pages = 0, ret;",
            "",
            "\tp4d = p4d_offset(pgd, addr);",
            "\tdo {",
            "\t\tnext = p4d_addr_end(addr, end);",
            "\t\tret = change_prepare(vma, p4d, pud, addr, cp_flags);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t\tif (p4d_none_or_clear_bad(p4d))",
            "\t\t\tcontinue;",
            "\t\tpages += change_pud_range(tlb, vma, p4d, addr, next, newprot,",
            "\t\t\t\t\t  cp_flags);",
            "\t} while (p4d++, addr = next, addr != end);",
            "",
            "\treturn pages;",
            "}",
            "static long change_protection_range(struct mmu_gather *tlb,",
            "\t\tstruct vm_area_struct *vma, unsigned long addr,",
            "\t\tunsigned long end, pgprot_t newprot, unsigned long cp_flags)",
            "{",
            "\tstruct mm_struct *mm = vma->vm_mm;",
            "\tpgd_t *pgd;",
            "\tunsigned long next;",
            "\tlong pages = 0, ret;",
            "",
            "\tBUG_ON(addr >= end);",
            "\tpgd = pgd_offset(mm, addr);",
            "\ttlb_start_vma(tlb, vma);",
            "\tdo {",
            "\t\tnext = pgd_addr_end(addr, end);",
            "\t\tret = change_prepare(vma, pgd, p4d, addr, cp_flags);",
            "\t\tif (ret) {",
            "\t\t\tpages = ret;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (pgd_none_or_clear_bad(pgd))",
            "\t\t\tcontinue;",
            "\t\tpages += change_p4d_range(tlb, vma, pgd, addr, next, newprot,",
            "\t\t\t\t\t  cp_flags);",
            "\t} while (pgd++, addr = next, addr != end);",
            "",
            "\ttlb_end_vma(tlb, vma);",
            "",
            "\treturn pages;",
            "}",
            "long change_protection(struct mmu_gather *tlb,",
            "\t\t       struct vm_area_struct *vma, unsigned long start,",
            "\t\t       unsigned long end, unsigned long cp_flags)",
            "{",
            "\tpgprot_t newprot = vma->vm_page_prot;",
            "\tlong pages;",
            "",
            "\tBUG_ON((cp_flags & MM_CP_UFFD_WP_ALL) == MM_CP_UFFD_WP_ALL);",
            "",
            "#ifdef CONFIG_NUMA_BALANCING",
            "\t/*",
            "\t * Ordinary protection updates (mprotect, uffd-wp, softdirty tracking)",
            "\t * are expected to reflect their requirements via VMA flags such that",
            "\t * vma_set_page_prot() will adjust vma->vm_page_prot accordingly.",
            "\t */",
            "\tif (cp_flags & MM_CP_PROT_NUMA)",
            "\t\tnewprot = PAGE_NONE;",
            "#else",
            "\tWARN_ON_ONCE(cp_flags & MM_CP_PROT_NUMA);",
            "#endif",
            "",
            "\tif (is_vm_hugetlb_page(vma))",
            "\t\tpages = hugetlb_change_protection(vma, start, end, newprot,",
            "\t\t\t\t\t\t  cp_flags);",
            "\telse",
            "\t\tpages = change_protection_range(tlb, vma, start, end, newprot,",
            "\t\t\t\t\t\tcp_flags);",
            "",
            "\treturn pages;",
            "}"
          ],
          "function_name": "change_pud_range, change_p4d_range, change_protection_range, change_protection",
          "description": "change_pud_range/change_p4d_range/change_protection_range按页表层级递归修改保护属性，change_protection统一入口调用不同层级处理函数。",
          "similarity": 0.5271400213241577
        },
        {
          "chunk_id": 4,
          "file_path": "mm/mprotect.c",
          "start_line": 546,
          "end_line": 656,
          "content": [
            "static int prot_none_pte_entry(pte_t *pte, unsigned long addr,",
            "\t\t\t       unsigned long next, struct mm_walk *walk)",
            "{",
            "\treturn pfn_modify_allowed(pte_pfn(ptep_get(pte)),",
            "\t\t\t\t  *(pgprot_t *)(walk->private)) ?",
            "\t\t0 : -EACCES;",
            "}",
            "static int prot_none_hugetlb_entry(pte_t *pte, unsigned long hmask,",
            "\t\t\t\t   unsigned long addr, unsigned long next,",
            "\t\t\t\t   struct mm_walk *walk)",
            "{",
            "\treturn pfn_modify_allowed(pte_pfn(ptep_get(pte)),",
            "\t\t\t\t  *(pgprot_t *)(walk->private)) ?",
            "\t\t0 : -EACCES;",
            "}",
            "static int prot_none_test(unsigned long addr, unsigned long next,",
            "\t\t\t  struct mm_walk *walk)",
            "{",
            "\treturn 0;",
            "}",
            "int",
            "mprotect_fixup(struct vma_iterator *vmi, struct mmu_gather *tlb,",
            "\t       struct vm_area_struct *vma, struct vm_area_struct **pprev,",
            "\t       unsigned long start, unsigned long end, unsigned long newflags)",
            "{",
            "\tstruct mm_struct *mm = vma->vm_mm;",
            "\tunsigned long oldflags = vma->vm_flags;",
            "\tlong nrpages = (end - start) >> PAGE_SHIFT;",
            "\tunsigned int mm_cp_flags = 0;",
            "\tunsigned long charged = 0;",
            "\tint error;",
            "",
            "\tif (newflags == oldflags) {",
            "\t\t*pprev = vma;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * Do PROT_NONE PFN permission checks here when we can still",
            "\t * bail out without undoing a lot of state. This is a rather",
            "\t * uncommon case, so doesn't need to be very optimized.",
            "\t */",
            "\tif (arch_has_pfn_modify_check() &&",
            "\t    (vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&",
            "\t    (newflags & VM_ACCESS_FLAGS) == 0) {",
            "\t\tpgprot_t new_pgprot = vm_get_page_prot(newflags);",
            "",
            "\t\terror = walk_page_range(current->mm, start, end,",
            "\t\t\t\t&prot_none_walk_ops, &new_pgprot);",
            "\t\tif (error)",
            "\t\t\treturn error;",
            "\t}",
            "",
            "\t/*",
            "\t * If we make a private mapping writable we increase our commit;",
            "\t * but (without finer accounting) cannot reduce our commit if we",
            "\t * make it unwritable again. hugetlb mapping were accounted for",
            "\t * even if read-only so there is no need to account for them here",
            "\t */",
            "\tif (newflags & VM_WRITE) {",
            "\t\t/* Check space limits when area turns into data. */",
            "\t\tif (!may_expand_vm(mm, newflags, nrpages) &&",
            "\t\t\t\tmay_expand_vm(mm, oldflags, nrpages))",
            "\t\t\treturn -ENOMEM;",
            "\t\tif (!(oldflags & (VM_ACCOUNT|VM_WRITE|VM_HUGETLB|",
            "\t\t\t\t\t\tVM_SHARED|VM_NORESERVE))) {",
            "\t\t\tcharged = nrpages;",
            "\t\t\tif (security_vm_enough_memory_mm(mm, charged))",
            "\t\t\t\treturn -ENOMEM;",
            "\t\t\tnewflags |= VM_ACCOUNT;",
            "\t\t}",
            "\t}",
            "",
            "\tvma = vma_modify_flags(vmi, *pprev, vma, start, end, newflags);",
            "\tif (IS_ERR(vma)) {",
            "\t\terror = PTR_ERR(vma);",
            "\t\tgoto fail;",
            "\t}",
            "",
            "\t*pprev = vma;",
            "",
            "\t/*",
            "\t * vm_flags and vm_page_prot are protected by the mmap_lock",
            "\t * held in write mode.",
            "\t */",
            "\tvma_start_write(vma);",
            "\tvm_flags_reset(vma, newflags);",
            "\tif (vma_wants_manual_pte_write_upgrade(vma))",
            "\t\tmm_cp_flags |= MM_CP_TRY_CHANGE_WRITABLE;",
            "\tvma_set_page_prot(vma);",
            "",
            "\tchange_protection(tlb, vma, start, end, mm_cp_flags);",
            "",
            "\t/*",
            "\t * Private VM_LOCKED VMA becoming writable: trigger COW to avoid major",
            "\t * fault on access.",
            "\t */",
            "\tif ((oldflags & (VM_WRITE | VM_SHARED | VM_LOCKED)) == VM_LOCKED &&",
            "\t\t\t(newflags & VM_WRITE)) {",
            "\t\tpopulate_vma_page_range(vma, start, end, NULL);",
            "\t}",
            "",
            "\tvm_stat_account(mm, oldflags, -nrpages);",
            "\tvm_stat_account(mm, newflags, nrpages);",
            "\tperf_event_mmap(vma);",
            "\treturn 0;",
            "",
            "fail:",
            "\tvm_unacct_memory(charged);",
            "\treturn error;",
            "}"
          ],
          "function_name": "prot_none_pte_entry, prot_none_hugetlb_entry, prot_none_test, mprotect_fixup",
          "description": "prot_none系列函数检查PFN修改权限，mprotect_fixup协调VMA标志修改、内存配额检查和页表保护变更，通过change_protection触发底层修改。",
          "similarity": 0.5144452452659607
        },
        {
          "chunk_id": 1,
          "file_path": "mm/mprotect.c",
          "start_line": 42,
          "end_line": 290,
          "content": [
            "bool can_change_pte_writable(struct vm_area_struct *vma, unsigned long addr,",
            "\t\t\t     pte_t pte)",
            "{",
            "\tstruct page *page;",
            "",
            "\tif (WARN_ON_ONCE(!(vma->vm_flags & VM_WRITE)))",
            "\t\treturn false;",
            "",
            "\t/* Don't touch entries that are not even readable. */",
            "\tif (pte_protnone(pte))",
            "\t\treturn false;",
            "",
            "\t/* Do we need write faults for softdirty tracking? */",
            "\tif (vma_soft_dirty_enabled(vma) && !pte_soft_dirty(pte))",
            "\t\treturn false;",
            "",
            "\t/* Do we need write faults for uffd-wp tracking? */",
            "\tif (userfaultfd_pte_wp(vma, pte))",
            "\t\treturn false;",
            "",
            "\tif (!(vma->vm_flags & VM_SHARED)) {",
            "\t\t/*",
            "\t\t * Writable MAP_PRIVATE mapping: We can only special-case on",
            "\t\t * exclusive anonymous pages, because we know that our",
            "\t\t * write-fault handler similarly would map them writable without",
            "\t\t * any additional checks while holding the PT lock.",
            "\t\t */",
            "\t\tpage = vm_normal_page(vma, addr, pte);",
            "\t\treturn page && PageAnon(page) && PageAnonExclusive(page);",
            "\t}",
            "",
            "\t/*",
            "\t * Writable MAP_SHARED mapping: \"clean\" might indicate that the FS still",
            "\t * needs a real write-fault for writenotify",
            "\t * (see vma_wants_writenotify()). If \"dirty\", the assumption is that the",
            "\t * FS was already notified and we can simply mark the PTE writable",
            "\t * just like the write-fault handler would do.",
            "\t */",
            "\treturn pte_dirty(pte);",
            "}",
            "static long change_pte_range(struct mmu_gather *tlb,",
            "\t\tstruct vm_area_struct *vma, pmd_t *pmd, unsigned long addr,",
            "\t\tunsigned long end, pgprot_t newprot, unsigned long cp_flags)",
            "{",
            "\tpte_t *pte, oldpte;",
            "\tspinlock_t *ptl;",
            "\tlong pages = 0;",
            "\tint target_node = NUMA_NO_NODE;",
            "\tbool prot_numa = cp_flags & MM_CP_PROT_NUMA;",
            "\tbool uffd_wp = cp_flags & MM_CP_UFFD_WP;",
            "\tbool uffd_wp_resolve = cp_flags & MM_CP_UFFD_WP_RESOLVE;",
            "",
            "\ttlb_change_page_size(tlb, PAGE_SIZE);",
            "\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);",
            "\tif (!pte)",
            "\t\treturn -EAGAIN;",
            "",
            "\t/* Get target node for single threaded private VMAs */",
            "\tif (prot_numa && !(vma->vm_flags & VM_SHARED) &&",
            "\t    atomic_read(&vma->vm_mm->mm_users) == 1)",
            "\t\ttarget_node = numa_node_id();",
            "",
            "\tflush_tlb_batched_pending(vma->vm_mm);",
            "\tarch_enter_lazy_mmu_mode();",
            "\tdo {",
            "\t\toldpte = ptep_get(pte);",
            "\t\tif (pte_present(oldpte)) {",
            "\t\t\tpte_t ptent;",
            "",
            "\t\t\t/*",
            "\t\t\t * Avoid trapping faults against the zero or KSM",
            "\t\t\t * pages. See similar comment in change_huge_pmd.",
            "\t\t\t */",
            "\t\t\tif (prot_numa) {",
            "\t\t\t\tstruct folio *folio;",
            "\t\t\t\tint nid;",
            "\t\t\t\tbool toptier;",
            "",
            "\t\t\t\t/* Avoid TLB flush if possible */",
            "\t\t\t\tif (pte_protnone(oldpte))",
            "\t\t\t\t\tcontinue;",
            "",
            "\t\t\t\tfolio = vm_normal_folio(vma, addr, oldpte);",
            "\t\t\t\tif (!folio || folio_is_zone_device(folio) ||",
            "\t\t\t\t    folio_test_ksm(folio))",
            "\t\t\t\t\tcontinue;",
            "",
            "\t\t\t\t/* Also skip shared copy-on-write pages */",
            "\t\t\t\tif (is_cow_mapping(vma->vm_flags) &&",
            "\t\t\t\t    (folio_maybe_dma_pinned(folio) ||",
            "\t\t\t\t     folio_likely_mapped_shared(folio)))",
            "\t\t\t\t\tcontinue;",
            "",
            "\t\t\t\t/*",
            "\t\t\t\t * While migration can move some dirty pages,",
            "\t\t\t\t * it cannot move them all from MIGRATE_ASYNC",
            "\t\t\t\t * context.",
            "\t\t\t\t */",
            "\t\t\t\tif (folio_is_file_lru(folio) &&",
            "\t\t\t\t    folio_test_dirty(folio))",
            "\t\t\t\t\tcontinue;",
            "",
            "\t\t\t\t/*",
            "\t\t\t\t * Don't mess with PTEs if page is already on the node",
            "\t\t\t\t * a single-threaded process is running on.",
            "\t\t\t\t */",
            "\t\t\t\tnid = folio_nid(folio);",
            "\t\t\t\tif (target_node == nid)",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\ttoptier = node_is_toptier(nid);",
            "",
            "\t\t\t\t/*",
            "\t\t\t\t * Skip scanning top tier node if normal numa",
            "\t\t\t\t * balancing is disabled",
            "\t\t\t\t */",
            "\t\t\t\tif (!(sysctl_numa_balancing_mode & NUMA_BALANCING_NORMAL) &&",
            "\t\t\t\t    toptier)",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\tif (folio_use_access_time(folio))",
            "\t\t\t\t\tfolio_xchg_access_time(folio,",
            "\t\t\t\t\t\tjiffies_to_msecs(jiffies));",
            "\t\t\t}",
            "",
            "\t\t\toldpte = ptep_modify_prot_start(vma, addr, pte);",
            "\t\t\tptent = pte_modify(oldpte, newprot);",
            "",
            "\t\t\tif (uffd_wp)",
            "\t\t\t\tptent = pte_mkuffd_wp(ptent);",
            "\t\t\telse if (uffd_wp_resolve)",
            "\t\t\t\tptent = pte_clear_uffd_wp(ptent);",
            "",
            "\t\t\t/*",
            "\t\t\t * In some writable, shared mappings, we might want",
            "\t\t\t * to catch actual write access -- see",
            "\t\t\t * vma_wants_writenotify().",
            "\t\t\t *",
            "\t\t\t * In all writable, private mappings, we have to",
            "\t\t\t * properly handle COW.",
            "\t\t\t *",
            "\t\t\t * In both cases, we can sometimes still change PTEs",
            "\t\t\t * writable and avoid the write-fault handler, for",
            "\t\t\t * example, if a PTE is already dirty and no other",
            "\t\t\t * COW or special handling is required.",
            "\t\t\t */",
            "\t\t\tif ((cp_flags & MM_CP_TRY_CHANGE_WRITABLE) &&",
            "\t\t\t    !pte_write(ptent) &&",
            "\t\t\t    can_change_pte_writable(vma, addr, ptent))",
            "\t\t\t\tptent = pte_mkwrite(ptent, vma);",
            "",
            "\t\t\tptep_modify_prot_commit(vma, addr, pte, oldpte, ptent);",
            "\t\t\tif (pte_needs_flush(oldpte, ptent))",
            "\t\t\t\ttlb_flush_pte_range(tlb, addr, PAGE_SIZE);",
            "\t\t\tpages++;",
            "\t\t} else if (is_swap_pte(oldpte)) {",
            "\t\t\tswp_entry_t entry = pte_to_swp_entry(oldpte);",
            "\t\t\tpte_t newpte;",
            "",
            "\t\t\tif (is_writable_migration_entry(entry)) {",
            "\t\t\t\tstruct folio *folio = pfn_swap_entry_folio(entry);",
            "",
            "\t\t\t\t/*",
            "\t\t\t\t * A protection check is difficult so",
            "\t\t\t\t * just be safe and disable write",
            "\t\t\t\t */",
            "\t\t\t\tif (folio_test_anon(folio))",
            "\t\t\t\t\tentry = make_readable_exclusive_migration_entry(",
            "\t\t\t\t\t\t\t     swp_offset(entry));",
            "\t\t\t\telse",
            "\t\t\t\t\tentry = make_readable_migration_entry(swp_offset(entry));",
            "\t\t\t\tnewpte = swp_entry_to_pte(entry);",
            "\t\t\t\tif (pte_swp_soft_dirty(oldpte))",
            "\t\t\t\t\tnewpte = pte_swp_mksoft_dirty(newpte);",
            "\t\t\t} else if (is_writable_device_private_entry(entry)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * We do not preserve soft-dirtiness. See",
            "\t\t\t\t * copy_nonpresent_pte() for explanation.",
            "\t\t\t\t */",
            "\t\t\t\tentry = make_readable_device_private_entry(",
            "\t\t\t\t\t\t\tswp_offset(entry));",
            "\t\t\t\tnewpte = swp_entry_to_pte(entry);",
            "\t\t\t\tif (pte_swp_uffd_wp(oldpte))",
            "\t\t\t\t\tnewpte = pte_swp_mkuffd_wp(newpte);",
            "\t\t\t} else if (is_writable_device_exclusive_entry(entry)) {",
            "\t\t\t\tentry = make_readable_device_exclusive_entry(",
            "\t\t\t\t\t\t\tswp_offset(entry));",
            "\t\t\t\tnewpte = swp_entry_to_pte(entry);",
            "\t\t\t\tif (pte_swp_soft_dirty(oldpte))",
            "\t\t\t\t\tnewpte = pte_swp_mksoft_dirty(newpte);",
            "\t\t\t\tif (pte_swp_uffd_wp(oldpte))",
            "\t\t\t\t\tnewpte = pte_swp_mkuffd_wp(newpte);",
            "\t\t\t} else if (is_pte_marker_entry(entry)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * Ignore error swap entries unconditionally,",
            "\t\t\t\t * because any access should sigbus anyway.",
            "\t\t\t\t */",
            "\t\t\t\tif (is_poisoned_swp_entry(entry))",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t/*",
            "\t\t\t\t * If this is uffd-wp pte marker and we'd like",
            "\t\t\t\t * to unprotect it, drop it; the next page",
            "\t\t\t\t * fault will trigger without uffd trapping.",
            "\t\t\t\t */",
            "\t\t\t\tif (uffd_wp_resolve) {",
            "\t\t\t\t\tpte_clear(vma->vm_mm, addr, pte);",
            "\t\t\t\t\tpages++;",
            "\t\t\t\t}",
            "\t\t\t\tcontinue;",
            "\t\t\t} else {",
            "\t\t\t\tnewpte = oldpte;",
            "\t\t\t}",
            "",
            "\t\t\tif (uffd_wp)",
            "\t\t\t\tnewpte = pte_swp_mkuffd_wp(newpte);",
            "\t\t\telse if (uffd_wp_resolve)",
            "\t\t\t\tnewpte = pte_swp_clear_uffd_wp(newpte);",
            "",
            "\t\t\tif (!pte_same(oldpte, newpte)) {",
            "\t\t\t\tset_pte_at(vma->vm_mm, addr, pte, newpte);",
            "\t\t\t\tpages++;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\t/* It must be an none page, or what else?.. */",
            "\t\t\tWARN_ON_ONCE(!pte_none(oldpte));",
            "",
            "\t\t\t/*",
            "\t\t\t * Nobody plays with any none ptes besides",
            "\t\t\t * userfaultfd when applying the protections.",
            "\t\t\t */",
            "\t\t\tif (likely(!uffd_wp))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (userfaultfd_wp_use_markers(vma)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * For file-backed mem, we need to be able to",
            "\t\t\t\t * wr-protect a none pte, because even if the",
            "\t\t\t\t * pte is none, the page/swap cache could",
            "\t\t\t\t * exist.  Doing that by install a marker.",
            "\t\t\t\t */",
            "\t\t\t\tset_pte_at(vma->vm_mm, addr, pte,",
            "\t\t\t\t\t   make_pte_marker(PTE_MARKER_UFFD_WP));",
            "\t\t\t\tpages++;",
            "\t\t\t}",
            "\t\t}",
            "\t} while (pte++, addr += PAGE_SIZE, addr != end);",
            "\tarch_leave_lazy_mmu_mode();",
            "\tpte_unmap_unlock(pte - 1, ptl);",
            "",
            "\treturn pages;",
            "}"
          ],
          "function_name": "can_change_pte_writable, change_pte_range",
          "description": "can_change_pte_writable检查是否允许修改pte为可写，change_pte_range遍历并修改指定范围的pte保护属性，处理共享/私有映射及NUMA策略。",
          "similarity": 0.4547208845615387
        }
      ]
    }
  ]
}