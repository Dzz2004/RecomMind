{
  "query": "tracepoints在系统调优中的应用",
  "timestamp": "2025-12-26 01:39:23",
  "retrieved_files": [
    {
      "source_file": "kernel/tracepoint.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:41:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `tracepoint.c`\n\n---\n\n# tracepoint.c 技术文档\n\n## 1. 文件概述\n\n`tracepoint.c` 是 Linux 内核中实现 **tracepoint（跟踪点）核心机制** 的关键源文件。它提供了动态添加/删除探针（probe）函数到内核中预定义跟踪点的能力，支持运行时动态追踪内核行为，是 ftrace、perf、eBPF 等性能分析和调试工具的基础。该文件负责管理探针函数的注册、优先级排序、内存回收（通过 RCU 和 SRCU 机制），并利用静态调用（static call）优化单探针场景的性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `enum tp_func_state`：表示跟踪点关联探针函数数量的状态（0、1、2、N）。\n- `struct tp_probes`：封装探针数组及其 RCU 回调头，用于延迟释放。\n- `struct tp_transition_snapshot`：记录 RCU/SRCU 同步状态，用于安全过渡。\n- `enum tp_transition_sync`：定义不同探针数量变化场景下的同步类型。\n\n### 关键函数\n- `func_add()`：向跟踪点添加新的探针函数，支持按优先级排序，返回旧探针数组。\n- `func_remove()`：从跟踪点移除指定探针函数，若分配失败则使用 `tp_stub_func` 占位。\n- `tracepoint_update_call()`：根据当前探针数量更新静态调用目标（优化单探针路径）。\n- `release_probes()`：通过 RCU + SRCU 链式回调安全释放旧探针内存。\n- `tp_rcu_get_state()` / `tp_rcu_cond_sync()`：管理探针状态转换时的同步屏障。\n- `release_early_probes()`：在 SRCU 初始化后释放早期注册的探针。\n\n### 全局变量\n- `tracepoint_srcu`：SRCU（Sleepable RCU）实例，用于保护可睡眠上下文中的探针访问。\n- `early_probes`：在 SRCU 初始化前暂存待释放的探针。\n- `ok_to_free_tracepoints`：标志位，指示是否可安全释放探针内存。\n- `tracepoint_module_list`（仅 CONFIG_MODULES）：模块跟踪点列表。\n- `tracepoints_mutex`：保护内置和模块跟踪点的全局互斥锁。\n\n## 3. 关键实现\n\n### 探针管理与内存安全\n- 使用 **双重 RCU 保护**（sched RCU + SRCU）确保探针在任意上下文（包括可睡眠路径）中安全访问。\n- 探针数组通过 `struct tp_probes` 封装，释放时先调用 `call_rcu()`，再在 RCU 回调中触发 `call_srcu()`，形成链式同步。\n- 在 SRCU 初始化前（`postcore_initcall` 阶段），待释放探针暂存于 `early_probes` 链表，避免内存泄漏。\n\n### 动态探针增删\n- **添加探针**：遍历现有探针检查重复，按 `prio` 字段降序插入新探针，保证高优先级探针先执行。\n- **删除探针**：若内存分配失败，将目标探针替换为无操作的 `tp_stub_func`，避免执行无效函数。\n- 探针数组以 `NULL` 结尾，便于遍历。\n\n### 性能优化：静态调用（Static Call）\n- 当跟踪点仅关联 **一个有效探针** 时，通过 `__static_call_update()` 直接将调用点重定向到该探针函数，绕过多探针分发逻辑，显著提升性能。\n- 多探针或无探针时，回退到通用迭代器 `tp->iterator`。\n\n### 同步机制\n- 使用 `tp_transition_snapshot` 记录状态转换（如 1→0→1 或 N→2→1）时的 RCU/SRCU 快照。\n- `tp_rcu_cond_sync()` 确保在状态变更后等待所有旧读者完成，防止使用已释放内存。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/tracepoint.h>`：定义 tracepoint 核心 API 和数据结构。\n  - `<linux/rcupdate.h>` / `<linux/srcu.h>`：提供 RCU 和 SRCU 同步原语。\n  - `<linux/static_key.h>`：支持静态调用优化。\n  - `<linux/slab.h>`：内存分配（`kmalloc`/`kfree`）。\n- **链接依赖**：\n  - 依赖链接脚本导出的 `__start___tracepoints_ptrs` 和 `__stop___tracepoints_ptrs` 符号，用于遍历所有内置跟踪点。\n- **模块支持**：\n  - 若启用 `CONFIG_MODULES`，通过 `tracepoint_module_list` 管理模块注册的跟踪点，并使用独立互斥锁保护。\n\n## 5. 使用场景\n\n- **内核动态追踪**：perf、ftrace 等工具通过 `tracepoint_probe_register()` 向内核跟踪点（如 `sched_switch`、`sys_enter`）注册回调函数。\n- **eBPF 程序挂载**：eBPF 程序可附加到 tracepoint，在事件触发时执行用户定义逻辑。\n- **内核调试与性能分析**：开发者通过 tracepoint 监控关键路径（如中断、调度、内存分配）的行为。\n- **模块跟踪点注册**：内核模块可在加载时注册自己的 tracepoint，并在卸载时自动清理探针。\n- **高性能单探针路径**：当仅有一个监控者时（如单一 perf 事件），静态调用机制消除函数指针间接调用开销。",
      "similarity": 0.6613621115684509,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/tracepoint.c",
          "start_line": 816,
          "end_line": 828,
          "content": [
            "void syscall_unregfunc(void)",
            "{",
            "\tstruct task_struct *p, *t;",
            "",
            "\tsys_tracepoint_refcount--;",
            "\tif (!sys_tracepoint_refcount) {",
            "\t\tread_lock(&tasklist_lock);",
            "\t\tfor_each_process_thread(p, t) {",
            "\t\t\tclear_task_syscall_work(t, SYSCALL_TRACEPOINT);",
            "\t\t}",
            "\t\tread_unlock(&tasklist_lock);",
            "\t}",
            "}"
          ],
          "function_name": "syscall_unregfunc",
          "description": "该代码段实现系统调用跟踪点的引用计数清理逻辑，核心功能是当全局引用计数降为零时，触发对所有任务的跟踪点状态清除。函数通过减少`sys_tracepoint_refcount`并判断其是否为零，若为零则持有读锁遍历所有任务，清除其`SYSCALL_TRACEPOINT`标志位以终止跟踪点注册。代码依赖`tasklist_lock`读锁保护遍历任务链表的安全性，但未提供`sys_tracepoint_refcount`的定义及`clear_task_syscall_work`的具体实现细节，上下文存在缺失。",
          "similarity": 0.5666655898094177
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/tracepoint.c",
          "start_line": 323,
          "end_line": 453,
          "content": [
            "static int tracepoint_add_func(struct tracepoint *tp,",
            "\t\t\t       struct tracepoint_func *func, int prio,",
            "\t\t\t       bool warn)",
            "{",
            "\tstruct tracepoint_func *old, *tp_funcs;",
            "\tint ret;",
            "",
            "\tif (tp->regfunc && !static_key_enabled(&tp->key)) {",
            "\t\tret = tp->regfunc();",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\ttp_funcs = rcu_dereference_protected(tp->funcs,",
            "\t\t\tlockdep_is_held(&tracepoints_mutex));",
            "\told = func_add(&tp_funcs, func, prio);",
            "\tif (IS_ERR(old)) {",
            "\t\tWARN_ON_ONCE(warn && PTR_ERR(old) != -ENOMEM);",
            "\t\treturn PTR_ERR(old);",
            "\t}",
            "",
            "\t/*",
            "\t * rcu_assign_pointer has as smp_store_release() which makes sure",
            "\t * that the new probe callbacks array is consistent before setting",
            "\t * a pointer to it.  This array is referenced by __DO_TRACE from",
            "\t * include/linux/tracepoint.h using rcu_dereference_sched().",
            "\t */",
            "\tswitch (nr_func_state(tp_funcs)) {",
            "\tcase TP_FUNC_1:\t\t/* 0->1 */",
            "\t\t/*",
            "\t\t * Make sure new static func never uses old data after a",
            "\t\t * 1->0->1 transition sequence.",
            "\t\t */",
            "\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_1_0_1);",
            "\t\t/* Set static call to first function */",
            "\t\ttracepoint_update_call(tp, tp_funcs);",
            "\t\t/* Both iterator and static call handle NULL tp->funcs */",
            "\t\trcu_assign_pointer(tp->funcs, tp_funcs);",
            "\t\tstatic_key_enable(&tp->key);",
            "\t\tbreak;",
            "\tcase TP_FUNC_2:\t\t/* 1->2 */",
            "\t\t/* Set iterator static call */",
            "\t\ttracepoint_update_call(tp, tp_funcs);",
            "\t\t/*",
            "\t\t * Iterator callback installed before updating tp->funcs.",
            "\t\t * Requires ordering between RCU assign/dereference and",
            "\t\t * static call update/call.",
            "\t\t */",
            "\t\tfallthrough;",
            "\tcase TP_FUNC_N:\t\t/* N->N+1 (N>1) */",
            "\t\trcu_assign_pointer(tp->funcs, tp_funcs);",
            "\t\t/*",
            "\t\t * Make sure static func never uses incorrect data after a",
            "\t\t * N->...->2->1 (N>1) transition sequence.",
            "\t\t */",
            "\t\tif (tp_funcs[0].data != old[0].data)",
            "\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "",
            "\trelease_probes(old);",
            "\treturn 0;",
            "}",
            "static int tracepoint_remove_func(struct tracepoint *tp,",
            "\t\tstruct tracepoint_func *func)",
            "{",
            "\tstruct tracepoint_func *old, *tp_funcs;",
            "",
            "\ttp_funcs = rcu_dereference_protected(tp->funcs,",
            "\t\t\tlockdep_is_held(&tracepoints_mutex));",
            "\told = func_remove(&tp_funcs, func);",
            "\tif (WARN_ON_ONCE(IS_ERR(old)))",
            "\t\treturn PTR_ERR(old);",
            "",
            "\tif (tp_funcs == old)",
            "\t\t/* Failed allocating new tp_funcs, replaced func with stub */",
            "\t\treturn 0;",
            "",
            "\tswitch (nr_func_state(tp_funcs)) {",
            "\tcase TP_FUNC_0:\t\t/* 1->0 */",
            "\t\t/* Removed last function */",
            "\t\tif (tp->unregfunc && static_key_enabled(&tp->key))",
            "\t\t\ttp->unregfunc();",
            "",
            "\t\tstatic_key_disable(&tp->key);",
            "\t\t/* Set iterator static call */",
            "\t\ttracepoint_update_call(tp, tp_funcs);",
            "\t\t/* Both iterator and static call handle NULL tp->funcs */",
            "\t\trcu_assign_pointer(tp->funcs, NULL);",
            "\t\t/*",
            "\t\t * Make sure new static func never uses old data after a",
            "\t\t * 1->0->1 transition sequence.",
            "\t\t */",
            "\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_1_0_1);",
            "\t\tbreak;",
            "\tcase TP_FUNC_1:\t\t/* 2->1 */",
            "\t\trcu_assign_pointer(tp->funcs, tp_funcs);",
            "\t\t/*",
            "\t\t * Make sure static func never uses incorrect data after a",
            "\t\t * N->...->2->1 (N>2) transition sequence. If the first",
            "\t\t * element's data has changed, then force the synchronization",
            "\t\t * to prevent current readers that have loaded the old data",
            "\t\t * from calling the new function.",
            "\t\t */",
            "\t\tif (tp_funcs[0].data != old[0].data)",
            "\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);",
            "\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_N_2_1);",
            "\t\t/* Set static call to first function */",
            "\t\ttracepoint_update_call(tp, tp_funcs);",
            "\t\tbreak;",
            "\tcase TP_FUNC_2:\t\t/* N->N-1 (N>2) */",
            "\t\tfallthrough;",
            "\tcase TP_FUNC_N:",
            "\t\trcu_assign_pointer(tp->funcs, tp_funcs);",
            "\t\t/*",
            "\t\t * Make sure static func never uses incorrect data after a",
            "\t\t * N->...->2->1 (N>2) transition sequence.",
            "\t\t */",
            "\t\tif (tp_funcs[0].data != old[0].data)",
            "\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "\trelease_probes(old);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "tracepoint_add_func, tracepoint_remove_func",
          "description": "处理跟踪点探针的增删操作，在互斥锁保护下更新函数列表，通过RCU同步机制保障多线程环境下的安全性。",
          "similarity": 0.5448591709136963
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/tracepoint.c",
          "start_line": 47,
          "end_line": 148,
          "content": [
            "static void tp_rcu_get_state(enum tp_transition_sync sync)",
            "{",
            "\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];",
            "",
            "\t/* Keep the latest get_state snapshot. */",
            "\tsnapshot->rcu = get_state_synchronize_rcu();",
            "\tsnapshot->srcu = start_poll_synchronize_srcu(&tracepoint_srcu);",
            "\tsnapshot->ongoing = true;",
            "}",
            "static void tp_rcu_cond_sync(enum tp_transition_sync sync)",
            "{",
            "\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];",
            "",
            "\tif (!snapshot->ongoing)",
            "\t\treturn;",
            "\tcond_synchronize_rcu(snapshot->rcu);",
            "\tif (!poll_state_synchronize_srcu(&tracepoint_srcu, snapshot->srcu))",
            "\t\tsynchronize_srcu(&tracepoint_srcu);",
            "\tsnapshot->ongoing = false;",
            "}",
            "static void tp_stub_func(void)",
            "{",
            "\treturn;",
            "}",
            "static void srcu_free_old_probes(struct rcu_head *head)",
            "{",
            "\tkfree(container_of(head, struct tp_probes, rcu));",
            "}",
            "static void rcu_free_old_probes(struct rcu_head *head)",
            "{",
            "\tcall_srcu(&tracepoint_srcu, head, srcu_free_old_probes);",
            "}",
            "static __init int release_early_probes(void)",
            "{",
            "\tstruct rcu_head *tmp;",
            "",
            "\tok_to_free_tracepoints = true;",
            "",
            "\twhile (early_probes) {",
            "\t\ttmp = early_probes;",
            "\t\tearly_probes = tmp->next;",
            "\t\tcall_rcu(tmp, rcu_free_old_probes);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline void release_probes(struct tracepoint_func *old)",
            "{",
            "\tif (old) {",
            "\t\tstruct tp_probes *tp_probes = container_of(old,",
            "\t\t\tstruct tp_probes, probes[0]);",
            "",
            "\t\t/*",
            "\t\t * We can't free probes if SRCU is not initialized yet.",
            "\t\t * Postpone the freeing till after SRCU is initialized.",
            "\t\t */",
            "\t\tif (unlikely(!ok_to_free_tracepoints)) {",
            "\t\t\ttp_probes->rcu.next = early_probes;",
            "\t\t\tearly_probes = &tp_probes->rcu;",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Tracepoint probes are protected by both sched RCU and SRCU,",
            "\t\t * by calling the SRCU callback in the sched RCU callback we",
            "\t\t * cover both cases. So let us chain the SRCU and sched RCU",
            "\t\t * callbacks to wait for both grace periods.",
            "\t\t */",
            "\t\tcall_rcu(&tp_probes->rcu, rcu_free_old_probes);",
            "\t}",
            "}",
            "static void debug_print_probes(struct tracepoint_func *funcs)",
            "{",
            "\tint i;",
            "",
            "\tif (!tracepoint_debug || !funcs)",
            "\t\treturn;",
            "",
            "\tfor (i = 0; funcs[i].func; i++)",
            "\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);",
            "}",
            "static enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)",
            "{",
            "\tif (!tp_funcs)",
            "\t\treturn TP_FUNC_0;",
            "\tif (!tp_funcs[1].func)",
            "\t\treturn TP_FUNC_1;",
            "\tif (!tp_funcs[2].func)",
            "\t\treturn TP_FUNC_2;",
            "\treturn TP_FUNC_N;\t/* 3 or more */",
            "}",
            "static void tracepoint_update_call(struct tracepoint *tp, struct tracepoint_func *tp_funcs)",
            "{",
            "\tvoid *func = tp->iterator;",
            "",
            "\t/* Synthetic events do not have static call sites */",
            "\tif (!tp->static_call_key)",
            "\t\treturn;",
            "\tif (nr_func_state(tp_funcs) == TP_FUNC_1)",
            "\t\tfunc = tp_funcs[0].func;",
            "\t__static_call_update(tp->static_call_key, tp->static_call_tramp, func);",
            "}"
          ],
          "function_name": "tp_rcu_get_state, tp_rcu_cond_sync, tp_stub_func, srcu_free_old_probes, rcu_free_old_probes, release_early_probes, release_probes, debug_print_probes, nr_func_state, tracepoint_update_call",
          "description": "实现RCU/SRCU同步控制、探针释放、调试打印及函数状态判断逻辑，确保跟踪点操作的线程安全与内存可见性。",
          "similarity": 0.5342004299163818
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/tracepoint.c",
          "start_line": 1,
          "end_line": 46,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Copyright (C) 2008-2014 Mathieu Desnoyers",
            " */",
            "#include <linux/module.h>",
            "#include <linux/mutex.h>",
            "#include <linux/types.h>",
            "#include <linux/jhash.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/static_key.h>",
            "",
            "enum tp_func_state {",
            "\tTP_FUNC_0,",
            "\tTP_FUNC_1,",
            "\tTP_FUNC_2,",
            "\tTP_FUNC_N,",
            "};",
            "",
            "extern tracepoint_ptr_t __start___tracepoints_ptrs[];",
            "extern tracepoint_ptr_t __stop___tracepoints_ptrs[];",
            "",
            "DEFINE_SRCU(tracepoint_srcu);",
            "EXPORT_SYMBOL_GPL(tracepoint_srcu);",
            "",
            "enum tp_transition_sync {",
            "\tTP_TRANSITION_SYNC_1_0_1,",
            "\tTP_TRANSITION_SYNC_N_2_1,",
            "",
            "\t_NR_TP_TRANSITION_SYNC,",
            "};",
            "",
            "struct tp_transition_snapshot {",
            "\tunsigned long rcu;",
            "\tunsigned long srcu;",
            "\tbool ongoing;",
            "};",
            "",
            "/* Protected by tracepoints_mutex */",
            "static struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];",
            ""
          ],
          "function_name": null,
          "description": "定义跟踪点状态转换相关枚举和结构体，初始化SRCU结构用于管理读复制更新机制，并声明用于同步状态转换的快照数组。",
          "similarity": 0.5306883454322815
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/tracepoint.c",
          "start_line": 472,
          "end_line": 595,
          "content": [
            "int tracepoint_probe_register_prio_may_exist(struct tracepoint *tp, void *probe,",
            "\t\t\t\t\t     void *data, int prio)",
            "{",
            "\tstruct tracepoint_func tp_func;",
            "\tint ret;",
            "",
            "\tmutex_lock(&tracepoints_mutex);",
            "\ttp_func.func = probe;",
            "\ttp_func.data = data;",
            "\ttp_func.prio = prio;",
            "\tret = tracepoint_add_func(tp, &tp_func, prio, false);",
            "\tmutex_unlock(&tracepoints_mutex);",
            "\treturn ret;",
            "}",
            "int tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,",
            "\t\t\t\t   void *data, int prio)",
            "{",
            "\tstruct tracepoint_func tp_func;",
            "\tint ret;",
            "",
            "\tmutex_lock(&tracepoints_mutex);",
            "\ttp_func.func = probe;",
            "\ttp_func.data = data;",
            "\ttp_func.prio = prio;",
            "\tret = tracepoint_add_func(tp, &tp_func, prio, true);",
            "\tmutex_unlock(&tracepoints_mutex);",
            "\treturn ret;",
            "}",
            "int tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)",
            "{",
            "\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);",
            "}",
            "int tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)",
            "{",
            "\tstruct tracepoint_func tp_func;",
            "\tint ret;",
            "",
            "\tmutex_lock(&tracepoints_mutex);",
            "\ttp_func.func = probe;",
            "\ttp_func.data = data;",
            "\tret = tracepoint_remove_func(tp, &tp_func);",
            "\tmutex_unlock(&tracepoints_mutex);",
            "\treturn ret;",
            "}",
            "static void for_each_tracepoint_range(",
            "\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,",
            "\t\tvoid (*fct)(struct tracepoint *tp, void *priv),",
            "\t\tvoid *priv)",
            "{",
            "\ttracepoint_ptr_t *iter;",
            "",
            "\tif (!begin)",
            "\t\treturn;",
            "\tfor (iter = begin; iter < end; iter++)",
            "\t\tfct(tracepoint_ptr_deref(iter), priv);",
            "}",
            "bool trace_module_has_bad_taint(struct module *mod)",
            "{",
            "\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |",
            "\t\t\t\t(1 << TAINT_UNSIGNED_MODULE) | (1 << TAINT_TEST) |",
            "\t\t\t\t(1 << TAINT_LIVEPATCH));",
            "}",
            "int register_tracepoint_module_notifier(struct notifier_block *nb)",
            "{",
            "\tstruct tp_module *tp_mod;",
            "\tint ret;",
            "",
            "\tmutex_lock(&tracepoint_module_list_mutex);",
            "\tret = blocking_notifier_chain_register(&tracepoint_notify_list, nb);",
            "\tif (ret)",
            "\t\tgoto end;",
            "\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)",
            "\t\t(void) nb->notifier_call(nb, MODULE_STATE_COMING, tp_mod);",
            "end:",
            "\tmutex_unlock(&tracepoint_module_list_mutex);",
            "\treturn ret;",
            "}",
            "int unregister_tracepoint_module_notifier(struct notifier_block *nb)",
            "{",
            "\tstruct tp_module *tp_mod;",
            "\tint ret;",
            "",
            "\tmutex_lock(&tracepoint_module_list_mutex);",
            "\tret = blocking_notifier_chain_unregister(&tracepoint_notify_list, nb);",
            "\tif (ret)",
            "\t\tgoto end;",
            "\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)",
            "\t\t(void) nb->notifier_call(nb, MODULE_STATE_GOING, tp_mod);",
            "end:",
            "\tmutex_unlock(&tracepoint_module_list_mutex);",
            "\treturn ret;",
            "",
            "}",
            "static void tp_module_going_check_quiescent(struct tracepoint *tp, void *priv)",
            "{",
            "\tWARN_ON_ONCE(tp->funcs);",
            "}",
            "static int tracepoint_module_coming(struct module *mod)",
            "{",
            "\tstruct tp_module *tp_mod;",
            "",
            "\tif (!mod->num_tracepoints)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * We skip modules that taint the kernel, especially those with different",
            "\t * module headers (for forced load), to make sure we don't cause a crash.",
            "\t * Staging, out-of-tree, unsigned GPL, and test modules are fine.",
            "\t */",
            "\tif (trace_module_has_bad_taint(mod))",
            "\t\treturn 0;",
            "",
            "\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);",
            "\tif (!tp_mod)",
            "\t\treturn -ENOMEM;",
            "\ttp_mod->mod = mod;",
            "",
            "\tmutex_lock(&tracepoint_module_list_mutex);",
            "\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);",
            "\tblocking_notifier_call_chain(&tracepoint_notify_list,",
            "\t\t\tMODULE_STATE_COMING, tp_mod);",
            "\tmutex_unlock(&tracepoint_module_list_mutex);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "tracepoint_probe_register_prio_may_exist, tracepoint_probe_register_prio, tracepoint_probe_register, tracepoint_probe_unregister, for_each_tracepoint_range, trace_module_has_bad_taint, register_tracepoint_module_notifier, unregister_tracepoint_module_notifier, tp_module_going_check_quiescent, tracepoint_module_coming",
          "description": "提供跟踪点注册/注销接口及模块通知机制，包含模块追踪点遍历、污点检查及模块生命周期回调处理。",
          "similarity": 0.5255739688873291
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_benchmark.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:12:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_benchmark.c`\n\n---\n\n# `trace/trace_benchmark.c` 技术文档\n\n## 1. 文件概述\n\n`trace_benchmark.c` 是 Linux 内核 ftrace 框架中的一个基准测试模块，用于测量 tracepoint（跟踪点）写入操作的性能开销。该模块通过在内核线程中循环触发一个专用的 tracepoint（`trace_benchmark_event`），记录每次写入所消耗的时间，并动态计算和更新统计信息（如最小值、最大值、平均值、标准差等），并将这些统计结果作为 tracepoint 的参数输出到跟踪缓冲区中。该功能主要用于评估和调试 ftrace 子系统的性能开销。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`trace_do_benchmark(void)`**  \n  核心性能测量函数。在 tracepoint 启用且 tracing 处于开启状态时，禁用本地中断，使用高精度本地时钟（`trace_clock_local()`）测量单次 `trace_benchmark_event` tracepoint 的写入耗时，并更新全局统计变量。\n\n- **`benchmark_event_kthread(void *arg)`**  \n  内核线程主函数。在 tracepoint 启用后由 `trace_benchmark_reg()` 创建，持续调用 `trace_do_benchmark()`，并通过 `cond_resched_tasks_rcu_qs()` 主动让出 CPU 以避免阻塞 RCU 任务同步。\n\n- **`trace_benchmark_reg(void)`**  \n  tracepoint 启用回调函数。当用户通过 tracing 接口启用 `benchmark` 事件时被调用，负责创建并启动 `benchmark_event_kthread` 内核线程。\n\n- **`trace_benchmark_unreg(void)`**  \n  tracepoint 禁用回调函数。当用户禁用 `benchmark` 事件时被调用，负责停止内核线程并重置所有统计状态。\n\n- **`ok_to_run_trace_benchmark(void)`**  \n  早期初始化回调（`early_initcall`），用于设置 `ok_to_run` 标志为 `true`，允许通过 tracing 接口动态启用 benchmark 功能（禁止通过内核命令行直接启动）。\n\n### 主要全局变量\n\n- `bm_event_thread`：指向 benchmark 内核线程的 `task_struct` 指针。\n- `bm_str`：用于存储 tracepoint 输出字符串的缓冲区（长度为 `BENCHMARK_EVENT_STRLEN`）。\n- `bm_total`, `bm_totalsq`：分别累计所有测量值的总和及其平方和，用于计算均值和方差。\n- `bm_last`, `bm_max`, `bm_min`, `bm_first`：分别记录最近一次、最大、最小和首次（冷缓存）的测量值。\n- `bm_cnt`：已执行的测量次数。\n- `bm_avg`, `bm_std`, `bm_stddev`：分别缓存当前的平均值、标准差和方差（标准差的平方）。\n- `ok_to_run`：布尔标志，控制是否允许注册 benchmark 线程。\n\n## 3. 关键实现\n\n### 性能测量机制\n- 使用 `local_irq_disable()`/`local_irq_enable()` 包裹 tracepoint 调用，确保测量不受中断干扰。\n- 采用 `trace_clock_local()` 获取高精度、低开销的本地 CPU 时间戳。\n- 首次测量（`bm_cnt == 1`）被视为“冷缓存”场景，单独记录为 `bm_first`，不参与后续统计计算。\n\n### 统计计算\n- **均值（avg）**：通过 `bm_total / bm_cnt` 计算。\n- **方差（stddev）**：使用公式  \n  `stddev = (n * Σx² - (Σx)²) / (n * (n - 1))`  \n  其中 `n = bm_cnt`，`Σx = bm_total`，`Σx² = bm_totalsq`。\n- **标准差（std）**：对方差 `stddev` 使用牛顿迭代法（初始值为均值）近似计算平方根，最多迭代 10 次。\n\n### 防溢出保护\n- 当测量次数 `bm_cnt` 超过 `UINT_MAX` 时，停止更新统计值，仅输出当前缓存的统计结果，避免整数溢出导致计算错误。\n\n### RCU 友好调度\n- 内核线程使用 `cond_resched_tasks_rcu_qs()` 而非普通 `cond_resched()`，确保在让出 CPU 时向 RCU 任务机制报告 quiescent state，防止阻塞 `synchronize_rcu_tasks()`。\n\n### 安全启动控制\n- 通过 `early_initcall` 设置 `ok_to_run = true`，确保 benchmark 功能只能通过运行时 tracing 接口启用，不能通过内核命令行参数直接激活，防止意外性能影响。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/delay.h>`：提供 `msleep()`。\n  - `<linux/module.h>`：模块基础设施。\n  - `<linux/kthread.h>`：内核线程 API（`kthread_run`, `kthread_stop` 等）。\n  - `<linux/trace_clock.h>`：提供 `trace_clock_local()`。\n- **Tracepoint 机制**：\n  - 依赖 `CREATE_TRACE_POINTS` 宏定义和 `trace_benchmark.h` 头文件生成实际的 tracepoint 代码。\n  - 调用 `trace_benchmark_event_enabled()` 和 `tracing_is_on()` 查询 tracepoint 和全局 tracing 状态。\n- **ftrace 子系统**：作为 ftrace 的一部分，其输出通过 ftrace 的 ring buffer 机制记录。\n\n## 5. 使用场景\n\n- **ftrace 性能调优**：开发人员可通过启用 `benchmark` 事件，观察 tracepoint 写入延迟的分布情况，评估不同配置（如 ring buffer 大小、tracer 类型）对性能的影响。\n- **系统开销分析**：在实时或低延迟系统中，使用该模块量化 ftrace 引入的确定性开销（如最小/最大延迟）。\n- **回归测试**：在内核版本迭代中，通过对比 benchmark 结果检测 ftrace 性能退化。\n- **冷热缓存效应研究**：通过 `first` 字段区分首次（冷缓存）和后续（热缓存）调用的开销差异。\n\n> **启用方式**：  \n> ```bash\n> echo 1 > /sys/kernel/debug/tracing/events/benchmark/enable\n> cat /sys/kernel/debug/tracing/trace_pipe  # 查看实时输出\n> echo 0 > /sys/kernel/debug/tracing/events/benchmark/enable  # 停止并重置\n> ```",
      "similarity": 0.6212190389633179,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_benchmark.c",
          "start_line": 37,
          "end_line": 145,
          "content": [
            "static void trace_do_benchmark(void)",
            "{",
            "\tu64 start;",
            "\tu64 stop;",
            "\tu64 delta;",
            "\tu64 stddev;",
            "\tu64 seed;",
            "\tu64 last_seed;",
            "\tunsigned int avg;",
            "\tunsigned int std = 0;",
            "",
            "\t/* Only run if the tracepoint is actually active */",
            "\tif (!trace_benchmark_event_enabled() || !tracing_is_on())",
            "\t\treturn;",
            "",
            "\tlocal_irq_disable();",
            "\tstart = trace_clock_local();",
            "\ttrace_benchmark_event(bm_str, bm_last);",
            "\tstop = trace_clock_local();",
            "\tlocal_irq_enable();",
            "",
            "\tbm_cnt++;",
            "",
            "\tdelta = stop - start;",
            "",
            "\t/*",
            "\t * The first read is cold cached, keep it separate from the",
            "\t * other calculations.",
            "\t */",
            "\tif (bm_cnt == 1) {",
            "\t\tbm_first = delta;",
            "\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,",
            "\t\t\t  \"first=%llu [COLD CACHED]\", bm_first);",
            "\t\treturn;",
            "\t}",
            "",
            "\tbm_last = delta;",
            "",
            "\tif (delta > bm_max)",
            "\t\tbm_max = delta;",
            "\tif (!bm_min || delta < bm_min)",
            "\t\tbm_min = delta;",
            "",
            "\t/*",
            "\t * When bm_cnt is greater than UINT_MAX, it breaks the statistics",
            "\t * accounting. Freeze the statistics when that happens.",
            "\t * We should have enough data for the avg and stddev anyway.",
            "\t */",
            "\tif (bm_cnt > UINT_MAX) {",
            "\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,",
            "\t\t    \"last=%llu first=%llu max=%llu min=%llu ** avg=%u std=%d std^2=%lld\",",
            "\t\t\t  bm_last, bm_first, bm_max, bm_min, bm_avg, bm_std, bm_stddev);",
            "\t\treturn;",
            "\t}",
            "",
            "\tbm_total += delta;",
            "\tbm_totalsq += delta * delta;",
            "",
            "",
            "\tif (bm_cnt > 1) {",
            "\t\t/*",
            "\t\t * Apply Welford's method to calculate standard deviation:",
            "\t\t * s^2 = 1 / (n * (n-1)) * (n * \\Sum (x_i)^2 - (\\Sum x_i)^2)",
            "\t\t */",
            "\t\tstddev = (u64)bm_cnt * bm_totalsq - bm_total * bm_total;",
            "\t\tdo_div(stddev, (u32)bm_cnt);",
            "\t\tdo_div(stddev, (u32)bm_cnt - 1);",
            "\t} else",
            "\t\tstddev = 0;",
            "",
            "\tdelta = bm_total;",
            "\tdo_div(delta, bm_cnt);",
            "\tavg = delta;",
            "",
            "\tif (stddev > 0) {",
            "\t\tint i = 0;",
            "\t\t/*",
            "\t\t * stddev is the square of standard deviation but",
            "\t\t * we want the actually number. Use the average",
            "\t\t * as our seed to find the std.",
            "\t\t *",
            "\t\t * The next try is:",
            "\t\t *  x = (x + N/x) / 2",
            "\t\t *",
            "\t\t * Where N is the squared number to find the square",
            "\t\t * root of.",
            "\t\t */",
            "\t\tseed = avg;",
            "\t\tdo {",
            "\t\t\tlast_seed = seed;",
            "\t\t\tseed = stddev;",
            "\t\t\tif (!last_seed)",
            "\t\t\t\tbreak;",
            "\t\t\tdo_div(seed, last_seed);",
            "\t\t\tseed += last_seed;",
            "\t\t\tdo_div(seed, 2);",
            "\t\t} while (i++ < 10 && last_seed != seed);",
            "",
            "\t\tstd = seed;",
            "\t}",
            "",
            "\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,",
            "\t\t  \"last=%llu first=%llu max=%llu min=%llu avg=%u std=%d std^2=%lld\",",
            "\t\t  bm_last, bm_first, bm_max, bm_min, avg, std, stddev);",
            "",
            "\tbm_std = std;",
            "\tbm_avg = avg;",
            "\tbm_stddev = stddev;",
            "}"
          ],
          "function_name": "trace_do_benchmark",
          "description": "实现基准测试时间统计逻辑，通过循环记录tracepoint写入耗时并计算平均值、最大值、最小值及标准差，采用Welford算法优化方差计算",
          "similarity": 0.6258031725883484
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_benchmark.c",
          "start_line": 1,
          "end_line": 36,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/delay.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/trace_clock.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include \"trace_benchmark.h\"",
            "",
            "static struct task_struct *bm_event_thread;",
            "",
            "static char bm_str[BENCHMARK_EVENT_STRLEN] = \"START\";",
            "",
            "static u64 bm_total;",
            "static u64 bm_totalsq;",
            "static u64 bm_last;",
            "static u64 bm_max;",
            "static u64 bm_min;",
            "static u64 bm_first;",
            "static u64 bm_cnt;",
            "static u64 bm_stddev;",
            "static unsigned int bm_avg;",
            "static unsigned int bm_std;",
            "",
            "static bool ok_to_run;",
            "",
            "/*",
            " * This gets called in a loop recording the time it took to write",
            " * the tracepoint. What it writes is the time statistics of the last",
            " * tracepoint write. As there is nothing to write the first time",
            " * it simply writes \"START\". As the first write is cold cache and",
            " * the rest is hot, we save off that time in bm_first and it is",
            " * reported as \"first\", which is shown in the second write to the",
            " * tracepoint. The \"first\" field is written within the statics from",
            " * then on but never changes.",
            " */"
          ],
          "function_name": null,
          "description": "定义基准测试相关全局变量及辅助函数，用于存储时间统计信息和控制标记，核心功能是初始化和配置基准测试所需的数据结构",
          "similarity": 0.47531658411026
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_benchmark.c",
          "start_line": 147,
          "end_line": 215,
          "content": [
            "static int benchmark_event_kthread(void *arg)",
            "{",
            "\t/* sleep a bit to make sure the tracepoint gets activated */",
            "\tmsleep(100);",
            "",
            "\twhile (!kthread_should_stop()) {",
            "",
            "\t\ttrace_do_benchmark();",
            "",
            "\t\t/*",
            "\t\t * We don't go to sleep, but let others run as well.",
            "\t\t * This is basically a \"yield()\" to let any task that",
            "\t\t * wants to run, schedule in, but if the CPU is idle,",
            "\t\t * we'll keep burning cycles.",
            "\t\t *",
            "\t\t * Note the tasks_rcu_qs() version of cond_resched() will",
            "\t\t * notify synchronize_rcu_tasks() that this thread has",
            "\t\t * passed a quiescent state for rcu_tasks. Otherwise",
            "\t\t * this thread will never voluntarily schedule which would",
            "\t\t * block synchronize_rcu_tasks() indefinitely.",
            "\t\t */",
            "\t\tcond_resched_tasks_rcu_qs();",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int trace_benchmark_reg(void)",
            "{",
            "\tif (!ok_to_run) {",
            "\t\tpr_warn(\"trace benchmark cannot be started via kernel command line\\n\");",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tbm_event_thread = kthread_run(benchmark_event_kthread,",
            "\t\t\t\t      NULL, \"event_benchmark\");",
            "\tif (IS_ERR(bm_event_thread)) {",
            "\t\tpr_warn(\"trace benchmark failed to create kernel thread\\n\");",
            "\t\treturn PTR_ERR(bm_event_thread);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void trace_benchmark_unreg(void)",
            "{",
            "\tif (!bm_event_thread)",
            "\t\treturn;",
            "",
            "\tkthread_stop(bm_event_thread);",
            "\tbm_event_thread = NULL;",
            "",
            "\tstrcpy(bm_str, \"START\");",
            "\tbm_total = 0;",
            "\tbm_totalsq = 0;",
            "\tbm_last = 0;",
            "\tbm_max = 0;",
            "\tbm_min = 0;",
            "\tbm_cnt = 0;",
            "\t/* These don't need to be reset but reset them anyway */",
            "\tbm_first = 0;",
            "\tbm_std = 0;",
            "\tbm_avg = 0;",
            "\tbm_stddev = 0;",
            "}",
            "static __init int ok_to_run_trace_benchmark(void)",
            "{",
            "\tok_to_run = true;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "benchmark_event_kthread, trace_benchmark_reg, trace_benchmark_unreg, ok_to_run_trace_benchmark",
          "description": "包含基准测试线程入口函数和注册/注销接口，负责创建内核线程并管理统计状态，在模块加载时启用基准测试权限控制标志",
          "similarity": 0.4559350609779358
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_eprobe.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:17:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_eprobe.c`\n\n---\n\n# `trace/trace_eprobe.c` 技术文档\n\n## 1. 文件概述\n\n`trace/trace_eprobe.c` 实现了 Linux 内核动态追踪子系统中的 **事件探针（event probe，简称 eprobe）** 功能。eprobe 允许用户在已有的 tracepoint 事件上附加自定义的探测逻辑，包括参数提取、过滤条件和动态事件注册，从而扩展 tracepoint 的观测能力。该机制基于动态事件（`dyn_event`）框架，支持通过 `tracefs` 接口进行运行时创建、查询和销毁。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct trace_eprobe`**  \n  表示一个事件探针实例，包含：\n  - 目标 tracepoint 的系统名（`event_system`）和事件名（`event_name`）\n  - 可选的过滤字符串（`filter_str`）\n  - 指向目标 `trace_event_call` 的引用（`event`）\n  - 嵌入的通用探针结构 `trace_probe tp`\n  - 动态事件接口 `dyn_event devent`\n\n- **`struct eprobe_data`**  \n  用于在事件回调中传递上下文，包含关联的 `trace_event_file` 和 `trace_eprobe`。\n\n- **`eprobe_dyn_event_ops`**  \n  实现 `dyn_event_operations` 接口，提供 eprobe 的动态事件生命周期管理方法。\n\n### 主要函数\n\n- **`eprobe_dyn_event_create()`**  \n  解析用户命令并调用 `__trace_eprobe_create()` 创建 eprobe。\n\n- **`eprobe_dyn_event_show()`**  \n  格式化输出 eprobe 的定义信息（用于 `/sys/kernel/debug/tracing/available_events` 等）。\n\n- **`unregister_trace_eprobe()` / `eprobe_dyn_event_release()`**  \n  安全注销并释放 eprobe 资源，确保无并发使用。\n\n- **`eprobe_dyn_event_match()`**  \n  实现动态事件匹配逻辑，支持按系统、事件名及附加参数进行筛选。\n\n- **`alloc_event_probe()`**  \n  分配并初始化 `trace_eprobe` 结构，绑定到目标 tracepoint。\n\n- **`print_eprobe_event()`**  \n  自定义事件打印函数，在追踪输出中显示 eprobe 触发信息及提取的参数。\n\n- **`get_event_field()`**  \n  从 tracepoint 记录中提取指定字段的值，支持字符串和数值类型。\n\n## 3. 关键实现\n\n### 动态事件集成\neprobe 通过 `dyn_event` 框架注册，实现统一的动态追踪接口。所有 eprobe 实例通过 `devent` 字段链接到全局动态事件链表，支持通过 tracefs 进行枚举和管理。\n\n### 目标事件绑定\neprobe 通过 `event_system` 和 `event_name` 定位目标 tracepoint，并持有其 `trace_event_call` 引用（通过 `trace_event_get_ref()`），确保目标事件在 eprobe 存活期间不会被卸载。\n\n### 参数提取机制\n复用 `trace_probe` 的参数提取框架（`fetch_insn`），支持从 tracepoint 的原始记录中动态提取字段值。`get_event_field()` 处理不同类型的字段（静态/动态字符串、有符号/无符号整数等），为上层提供统一的值访问接口。\n\n### 安全注销\n`unregister_trace_eprobe()` 在注销前检查：\n- 是否有其他探针共享同一目标事件（`trace_probe_has_sibling()`）\n- 探针是否处于启用状态（`trace_probe_is_enabled()`）\n- 是否被 ftrace 或 perf 使用（`trace_probe_unregister_event_call()`）\n确保资源释放的安全性。\n\n### 事件匹配逻辑\n`eprobe_dyn_event_match()` 支持灵活的匹配模式：\n- 仅指定事件名：匹配所有同名 eprobe\n- 指定系统和事件名：精确匹配\n- 指定附加参数：要求完全匹配参数定义\n\n## 4. 依赖关系\n\n- **`trace_dynevent.h`**：动态事件核心框架\n- **`trace_probe.h` / `trace_probe_tmpl.h`**：通用探针基础设施（参数解析、事件注册等）\n- **`trace_probe_kernel.h`**：内核探针特定功能\n- **`ftrace.h`**：事件查找（`ftrace_find_event()`）和底层追踪机制\n- **`trace_events.h`**：tracepoint 事件模型（`trace_event_call`, `trace_event_field`）\n\n## 5. 使用场景\n\n- **动态扩展 tracepoint**：在不修改内核代码的情况下，为现有 tracepoint 添加自定义数据提取或过滤逻辑。\n- **性能分析**：结合 perf 或 ftrace，在特定 tracepoint 触发时捕获额外上下文（如进程状态、堆栈）。\n- **调试与监控**：通过 eprobe 快速构建针对特定内核事件的观测点，用于问题诊断或系统行为监控。\n- **用户空间接口**：通过 `tracefs` 的 `events/eprobes/` 目录或 `synthetic_events` 机制，由用户空间工具（如 `perf`, `trace-cmd`）动态创建和管理 eprobe。",
      "similarity": 0.5888971090316772,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_eprobe.c",
          "start_line": 355,
          "end_line": 465,
          "content": [
            "static int get_eprobe_size(struct trace_probe *tp, void *rec)",
            "{",
            "\tstruct fetch_insn *code;",
            "\tstruct probe_arg *arg;",
            "\tint i, len, ret = 0;",
            "",
            "\tfor (i = 0; i < tp->nr_args; i++) {",
            "\t\targ = tp->args + i;",
            "\t\tif (arg->dynamic) {",
            "\t\t\tunsigned long val;",
            "",
            "\t\t\tcode = arg->code;",
            " retry:",
            "\t\t\tswitch (code->op) {",
            "\t\t\tcase FETCH_OP_TP_ARG:",
            "\t\t\t\tval = get_event_field(code, rec);",
            "\t\t\t\tbreak;",
            "\t\t\tcase FETCH_NOP_SYMBOL:\t/* Ignore a place holder */",
            "\t\t\t\tcode++;",
            "\t\t\t\tgoto retry;",
            "\t\t\tdefault:",
            "\t\t\t\tif (process_common_fetch_insn(code, &val) < 0)",
            "\t\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tcode++;",
            "\t\t\tlen = process_fetch_insn_bottom(code, val, NULL, NULL);",
            "\t\t\tif (len > 0)",
            "\t\t\t\tret += len;",
            "\t\t}",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int",
            "process_fetch_insn(struct fetch_insn *code, void *rec, void *edata,",
            "\t\t   void *dest, void *base)",
            "{",
            "\tunsigned long val;",
            "\tint ret;",
            "",
            " retry:",
            "\tswitch (code->op) {",
            "\tcase FETCH_OP_TP_ARG:",
            "\t\tval = get_event_field(code, rec);",
            "\t\tbreak;",
            "\tcase FETCH_NOP_SYMBOL:\t/* Ignore a place holder */",
            "\t\tcode++;",
            "\t\tgoto retry;",
            "\tdefault:",
            "\t\tret = process_common_fetch_insn(code, &val);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t}",
            "\tcode++;",
            "\treturn process_fetch_insn_bottom(code, val, dest, base);",
            "}",
            "NOKPROBE_SYMBOL(process_fetch_insn)",
            "",
            "/* eprobe handler */",
            "static inline void",
            "__eprobe_trace_func(struct eprobe_data *edata, void *rec)",
            "{",
            "\tstruct eprobe_trace_entry_head *entry;",
            "\tstruct trace_event_call *call = trace_probe_event_call(&edata->ep->tp);",
            "\tstruct trace_event_buffer fbuffer;",
            "\tint dsize;",
            "",
            "\tif (WARN_ON_ONCE(call != edata->file->event_call))",
            "\t\treturn;",
            "",
            "\tif (trace_trigger_soft_disabled(edata->file))",
            "\t\treturn;",
            "",
            "\tdsize = get_eprobe_size(&edata->ep->tp, rec);",
            "",
            "\tentry = trace_event_buffer_reserve(&fbuffer, edata->file,",
            "\t\t\t\t\t   sizeof(*entry) + edata->ep->tp.size + dsize);",
            "",
            "\tif (!entry)",
            "\t\treturn;",
            "",
            "\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);",
            "\tstore_trace_args(&entry[1], &edata->ep->tp, rec, NULL, sizeof(*entry), dsize);",
            "",
            "\ttrace_event_buffer_commit(&fbuffer);",
            "}",
            "static int eprobe_trigger_init(struct event_trigger_data *data)",
            "{",
            "\treturn 0;",
            "}",
            "static void eprobe_trigger_free(struct event_trigger_data *data)",
            "{",
            "",
            "}",
            "static int eprobe_trigger_print(struct seq_file *m,",
            "\t\t\t\tstruct event_trigger_data *data)",
            "{",
            "\t/* Do not print eprobe event triggers */",
            "\treturn 0;",
            "}",
            "static void eprobe_trigger_func(struct event_trigger_data *data,",
            "\t\t\t\tstruct trace_buffer *buffer, void *rec,",
            "\t\t\t\tstruct ring_buffer_event *rbe)",
            "{",
            "\tstruct eprobe_data *edata = data->private_data;",
            "",
            "\tif (unlikely(!rec))",
            "\t\treturn;",
            "",
            "\t__eprobe_trace_func(edata, rec);",
            "}"
          ],
          "function_name": "get_eprobe_size, process_fetch_insn, __eprobe_trace_func, eprobe_trigger_init, eprobe_trigger_free, eprobe_trigger_print, eprobe_trigger_func",
          "description": "实现事件数据采集与触发处理逻辑，包含缓冲区大小计算、指令处理、实际记录函数及触发器回调。通过__eprobe_trace_func完成事件数据捕获和存储，提供触发器初始化、释放和执行函数支持动态追踪功能。",
          "similarity": 0.530325174331665
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/trace/trace_eprobe.c",
          "start_line": 864,
          "end_line": 981,
          "content": [
            "static int __trace_eprobe_create(int argc, const char *argv[])",
            "{",
            "\t/*",
            "\t * Argument syntax:",
            "\t *      e[:[GRP/][ENAME]] SYSTEM.EVENT [FETCHARGS] [if FILTER]",
            "\t * Fetch args (no space):",
            "\t *  <name>=$<field>[:TYPE]",
            "\t */",
            "\tconst char *event = NULL, *group = EPROBE_EVENT_SYSTEM;",
            "\tconst char *sys_event = NULL, *sys_name = NULL;",
            "\tstruct trace_event_call *event_call;",
            "\tstruct trace_eprobe *ep = NULL;",
            "\tchar buf1[MAX_EVENT_NAME_LEN];",
            "\tchar buf2[MAX_EVENT_NAME_LEN];",
            "\tchar gbuf[MAX_EVENT_NAME_LEN];",
            "\tint ret = 0, filter_idx = 0;",
            "\tint i, filter_cnt;",
            "",
            "\tif (argc < 2 || argv[0][0] != 'e')",
            "\t\treturn -ECANCELED;",
            "",
            "\ttrace_probe_log_init(\"event_probe\", argc, argv);",
            "",
            "\tevent = strchr(&argv[0][1], ':');",
            "\tif (event) {",
            "\t\tevent++;",
            "\t\tret = traceprobe_parse_event_name(&event, &group, gbuf,",
            "\t\t\t\t\t\t  event - argv[0]);",
            "\t\tif (ret)",
            "\t\t\tgoto parse_error;",
            "\t}",
            "",
            "\ttrace_probe_log_set_index(1);",
            "\tsys_event = argv[1];",
            "\tret = traceprobe_parse_event_name(&sys_event, &sys_name, buf2, 0);",
            "\tif (ret || !sys_event || !sys_name) {",
            "\t\ttrace_probe_log_err(0, NO_EVENT_INFO);",
            "\t\tgoto parse_error;",
            "\t}",
            "",
            "\tif (!event) {",
            "\t\tstrscpy(buf1, sys_event, MAX_EVENT_NAME_LEN);",
            "\t\tevent = buf1;",
            "\t}",
            "",
            "\tfor (i = 2; i < argc; i++) {",
            "\t\tif (!strcmp(argv[i], \"if\")) {",
            "\t\t\tfilter_idx = i + 1;",
            "\t\t\tfilter_cnt = argc - filter_idx;",
            "\t\t\targc = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (argc - 2 > MAX_TRACE_ARGS) {",
            "\t\tret = -E2BIG;",
            "\t\tgoto error;",
            "\t}",
            "",
            "\tmutex_lock(&event_mutex);",
            "\tevent_call = find_and_get_event(sys_name, sys_event);",
            "\tep = alloc_event_probe(group, event, event_call, argc - 2);",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\tif (IS_ERR(ep)) {",
            "\t\tret = PTR_ERR(ep);",
            "\t\tif (ret == -ENODEV)",
            "\t\t\ttrace_probe_log_err(0, BAD_ATTACH_EVENT);",
            "\t\t/* This must return -ENOMEM or missing event, else there is a bug */",
            "\t\tWARN_ON_ONCE(ret != -ENOMEM && ret != -ENODEV);",
            "\t\tep = NULL;",
            "\t\tgoto error;",
            "\t}",
            "",
            "\tif (filter_idx) {",
            "\t\ttrace_probe_log_set_index(filter_idx);",
            "\t\tret = trace_eprobe_parse_filter(ep, filter_cnt, argv + filter_idx);",
            "\t\tif (ret)",
            "\t\t\tgoto parse_error;",
            "\t} else",
            "\t\tep->filter_str = NULL;",
            "",
            "\targc -= 2; argv += 2;",
            "\t/* parse arguments */",
            "\tfor (i = 0; i < argc; i++) {",
            "\t\ttrace_probe_log_set_index(i + 2);",
            "\t\tret = trace_eprobe_tp_update_arg(ep, argv, i);",
            "\t\tif (ret)",
            "\t\t\tgoto error;",
            "\t}",
            "\tret = traceprobe_set_print_fmt(&ep->tp, PROBE_PRINT_EVENT);",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "\tinit_trace_eprobe_call(ep);",
            "\tmutex_lock(&event_mutex);",
            "\tret = trace_probe_register_event_call(&ep->tp);",
            "\tif (ret) {",
            "\t\tif (ret == -EEXIST) {",
            "\t\t\ttrace_probe_log_set_index(0);",
            "\t\t\ttrace_probe_log_err(0, EVENT_EXIST);",
            "\t\t}",
            "\t\tmutex_unlock(&event_mutex);",
            "\t\tgoto error;",
            "\t}",
            "\tret = dyn_event_add(&ep->devent, &ep->tp.event->call);",
            "\tif (ret < 0) {",
            "\t\ttrace_probe_unregister_event_call(&ep->tp);",
            "\t\tmutex_unlock(&event_mutex);",
            "\t\tgoto error;",
            "\t}",
            "\tmutex_unlock(&event_mutex);",
            "\treturn ret;",
            "parse_error:",
            "\tret = -EINVAL;",
            "error:",
            "\ttrace_event_probe_cleanup(ep);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__trace_eprobe_create",
          "description": "创建并初始化跟踪探针实例，解析事件名称和参数，应用过滤条件，分配资源并完成动态事件注册流程，处理参数更新与格式化设置",
          "similarity": 0.5152881145477295
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_eprobe.c",
          "start_line": 701,
          "end_line": 828,
          "content": [
            "static int disable_trace_eprobe(struct trace_event_call *call,",
            "\t\t\t\tstruct trace_event_file *file)",
            "{",
            "\tstruct trace_probe *tp;",
            "\tstruct trace_eprobe *ep;",
            "",
            "\ttp = trace_probe_primary_from_call(call);",
            "\tif (WARN_ON_ONCE(!tp))",
            "\t\treturn -ENODEV;",
            "",
            "\tif (file) {",
            "\t\tif (!trace_probe_get_file_link(tp, file))",
            "\t\t\treturn -ENOENT;",
            "\t\tif (!trace_probe_has_single_file(tp))",
            "\t\t\tgoto out;",
            "\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);",
            "\t} else",
            "\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);",
            "",
            "\tif (!trace_probe_is_enabled(tp)) {",
            "\t\tfor_each_trace_eprobe_tp(ep, tp)",
            "\t\t\tdisable_eprobe(ep, file->tr);",
            "\t}",
            "",
            " out:",
            "\tif (file)",
            "\t\t/*",
            "\t\t * Synchronization is done in below function. For perf event,",
            "\t\t * file == NULL and perf_trace_event_unreg() calls",
            "\t\t * tracepoint_synchronize_unregister() to ensure synchronize",
            "\t\t * event. We don't need to care about it.",
            "\t\t */",
            "\t\ttrace_probe_remove_file(tp, file);",
            "",
            "\treturn 0;",
            "}",
            "static int eprobe_register(struct trace_event_call *event,",
            "\t\t\t   enum trace_reg type, void *data)",
            "{",
            "\tstruct trace_event_file *file = data;",
            "",
            "\tswitch (type) {",
            "\tcase TRACE_REG_REGISTER:",
            "\t\treturn enable_trace_eprobe(event, file);",
            "\tcase TRACE_REG_UNREGISTER:",
            "\t\treturn disable_trace_eprobe(event, file);",
            "#ifdef CONFIG_PERF_EVENTS",
            "\tcase TRACE_REG_PERF_REGISTER:",
            "\tcase TRACE_REG_PERF_UNREGISTER:",
            "\tcase TRACE_REG_PERF_OPEN:",
            "\tcase TRACE_REG_PERF_CLOSE:",
            "\tcase TRACE_REG_PERF_ADD:",
            "\tcase TRACE_REG_PERF_DEL:",
            "\t\treturn 0;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}",
            "static inline void init_trace_eprobe_call(struct trace_eprobe *ep)",
            "{",
            "\tstruct trace_event_call *call = trace_probe_event_call(&ep->tp);",
            "",
            "\tcall->flags = TRACE_EVENT_FL_EPROBE;",
            "\tcall->event.funcs = &eprobe_funcs;",
            "\tcall->class->fields_array = eprobe_fields_array;",
            "\tcall->class->reg = eprobe_register;",
            "}",
            "static int trace_eprobe_tp_update_arg(struct trace_eprobe *ep, const char *argv[], int i)",
            "{",
            "\tstruct traceprobe_parse_context ctx = {",
            "\t\t.event = ep->event,",
            "\t\t.flags = TPARG_FL_KERNEL | TPARG_FL_TEVENT,",
            "\t};",
            "\tint ret;",
            "",
            "\tret = traceprobe_parse_probe_arg(&ep->tp, i, argv[i], &ctx);",
            "\t/* Handle symbols \"@\" */",
            "\tif (!ret)",
            "\t\tret = traceprobe_update_arg(&ep->tp.args[i]);",
            "",
            "\ttraceprobe_finish_parse(&ctx);",
            "\treturn ret;",
            "}",
            "static int trace_eprobe_parse_filter(struct trace_eprobe *ep, int argc, const char *argv[])",
            "{",
            "\tstruct event_filter *dummy = NULL;",
            "\tint i, ret, len = 0;",
            "\tchar *p;",
            "",
            "\tif (argc == 0) {",
            "\t\ttrace_probe_log_err(0, NO_EP_FILTER);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* Recover the filter string */",
            "\tfor (i = 0; i < argc; i++)",
            "\t\tlen += strlen(argv[i]) + 1;",
            "",
            "\tep->filter_str = kzalloc(len, GFP_KERNEL);",
            "\tif (!ep->filter_str)",
            "\t\treturn -ENOMEM;",
            "",
            "\tp = ep->filter_str;",
            "\tfor (i = 0; i < argc; i++) {",
            "\t\tif (i)",
            "\t\t\tret = snprintf(p, len, \" %s\", argv[i]);",
            "\t\telse",
            "\t\t\tret = snprintf(p, len, \"%s\", argv[i]);",
            "\t\tp += ret;",
            "\t\tlen -= ret;",
            "\t}",
            "",
            "\t/*",
            "\t * Ensure the filter string can be parsed correctly. Note, this",
            "\t * filter string is for the original event, not for the eprobe.",
            "\t */",
            "\tret = create_event_filter(top_trace_array(), ep->event, ep->filter_str,",
            "\t\t\t\t  true, &dummy);",
            "\tfree_event_filter(dummy);",
            "\tif (ret)",
            "\t\tgoto error;",
            "",
            "\treturn 0;",
            "error:",
            "\tkfree(ep->filter_str);",
            "\tep->filter_str = NULL;",
            "\treturn ret;",
            "}"
          ],
          "function_name": "disable_trace_eprobe, eprobe_register, init_trace_eprobe_call, trace_eprobe_tp_update_arg, trace_eprobe_parse_filter",
          "description": "实现跟踪探针的注册与注销逻辑，处理不同类型的事件注册请求，支持PERF_EVENTS扩展，通过标记清除控制探针状态，并管理探针与文件链接的同步关系",
          "similarity": 0.5078850984573364
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_eprobe.c",
          "start_line": 488,
          "end_line": 624,
          "content": [
            "static int eprobe_trigger_cmd_parse(struct event_command *cmd_ops,",
            "\t\t\t\t    struct trace_event_file *file,",
            "\t\t\t\t    char *glob, char *cmd,",
            "\t\t\t\t    char *param_and_filter)",
            "{",
            "\treturn -1;",
            "}",
            "static int eprobe_trigger_reg_func(char *glob,",
            "\t\t\t\t   struct event_trigger_data *data,",
            "\t\t\t\t   struct trace_event_file *file)",
            "{",
            "\treturn -1;",
            "}",
            "static void eprobe_trigger_unreg_func(char *glob,",
            "\t\t\t\t      struct event_trigger_data *data,",
            "\t\t\t\t      struct trace_event_file *file)",
            "{",
            "",
            "}",
            "static int enable_eprobe(struct trace_eprobe *ep,",
            "\t\t\t struct trace_event_file *eprobe_file)",
            "{",
            "\tstruct event_trigger_data *trigger;",
            "\tstruct trace_event_file *file;",
            "\tstruct trace_array *tr = eprobe_file->tr;",
            "",
            "\tfile = find_event_file(tr, ep->event_system, ep->event_name);",
            "\tif (!file)",
            "\t\treturn -ENOENT;",
            "\ttrigger = new_eprobe_trigger(ep, eprobe_file);",
            "\tif (IS_ERR(trigger))",
            "\t\treturn PTR_ERR(trigger);",
            "",
            "\tlist_add_tail_rcu(&trigger->list, &file->triggers);",
            "",
            "\ttrace_event_trigger_enable_disable(file, 1);",
            "\tupdate_cond_flag(file);",
            "",
            "\treturn 0;",
            "}",
            "static int disable_eprobe(struct trace_eprobe *ep,",
            "\t\t\t  struct trace_array *tr)",
            "{",
            "\tstruct event_trigger_data *trigger = NULL, *iter;",
            "\tstruct trace_event_file *file;",
            "\tstruct event_filter *filter;",
            "\tstruct eprobe_data *edata;",
            "",
            "\tfile = find_event_file(tr, ep->event_system, ep->event_name);",
            "\tif (!file)",
            "\t\treturn -ENOENT;",
            "",
            "\tlist_for_each_entry(iter, &file->triggers, list) {",
            "\t\tif (!(iter->flags & EVENT_TRIGGER_FL_PROBE))",
            "\t\t\tcontinue;",
            "\t\tedata = iter->private_data;",
            "\t\tif (edata->ep == ep) {",
            "\t\t\ttrigger = iter;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tif (!trigger)",
            "\t\treturn -ENODEV;",
            "",
            "\tlist_del_rcu(&trigger->list);",
            "",
            "\ttrace_event_trigger_enable_disable(file, 0);",
            "\tupdate_cond_flag(file);",
            "",
            "\t/* Make sure nothing is using the edata or trigger */",
            "\ttracepoint_synchronize_unregister();",
            "",
            "\tfilter = rcu_access_pointer(trigger->filter);",
            "",
            "\tif (filter)",
            "\t\tfree_event_filter(filter);",
            "\tkfree(edata);",
            "\tkfree(trigger);",
            "",
            "\treturn 0;",
            "}",
            "static int enable_trace_eprobe(struct trace_event_call *call,",
            "\t\t\t       struct trace_event_file *file)",
            "{",
            "\tstruct trace_probe *tp;",
            "\tstruct trace_eprobe *ep;",
            "\tbool enabled;",
            "\tint ret = 0;",
            "\tint cnt = 0;",
            "",
            "\ttp = trace_probe_primary_from_call(call);",
            "\tif (WARN_ON_ONCE(!tp))",
            "\t\treturn -ENODEV;",
            "\tenabled = trace_probe_is_enabled(tp);",
            "",
            "\t/* This also changes \"enabled\" state */",
            "\tif (file) {",
            "\t\tret = trace_probe_add_file(tp, file);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t} else",
            "\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);",
            "",
            "\tif (enabled)",
            "\t\treturn 0;",
            "",
            "\tfor_each_trace_eprobe_tp(ep, tp) {",
            "\t\tret = enable_eprobe(ep, file);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t\tenabled = true;",
            "\t\tcnt++;",
            "\t}",
            "",
            "\tif (ret) {",
            "\t\t/* Failed to enable one of them. Roll back all */",
            "\t\tif (enabled) {",
            "\t\t\t/*",
            "\t\t\t * It's a bug if one failed for something other than memory",
            "\t\t\t * not being available but another eprobe succeeded.",
            "\t\t\t */",
            "\t\t\tWARN_ON_ONCE(ret != -ENOMEM);",
            "",
            "\t\t\tfor_each_trace_eprobe_tp(ep, tp) {",
            "\t\t\t\tdisable_eprobe(ep, file->tr);",
            "\t\t\t\tif (!--cnt)",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (file)",
            "\t\t\ttrace_probe_remove_file(tp, file);",
            "\t\telse",
            "\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "eprobe_trigger_cmd_parse, eprobe_trigger_reg_func, eprobe_trigger_unreg_func, enable_eprobe, disable_eprobe, enable_trace_eprobe",
          "description": "实现探针使能/失能控制逻辑，包含触发命令解析、注册注销函数及探针状态管理。通过enable/disable接口协调事件文件与探针实例，支持批量使能多个关联探针并处理失败回滚，确保系统一致性。",
          "similarity": 0.500993549823761
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_eprobe.c",
          "start_line": 1,
          "end_line": 49,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * event probes",
            " *",
            " * Part of this code was copied from kernel/trace/trace_kprobe.c written by",
            " * Masami Hiramatsu <mhiramat@kernel.org>",
            " *",
            " * Copyright (C) 2021, VMware Inc, Steven Rostedt <rostedt@goodmis.org>",
            " * Copyright (C) 2021, VMware Inc, Tzvetomir Stoyanov tz.stoyanov@gmail.com>",
            " *",
            " */",
            "#include <linux/module.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ftrace.h>",
            "",
            "#include \"trace_dynevent.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe_kernel.h\"",
            "",
            "#define EPROBE_EVENT_SYSTEM \"eprobes\"",
            "",
            "struct trace_eprobe {",
            "\t/* tracepoint system */",
            "\tconst char *event_system;",
            "",
            "\t/* tracepoint event */",
            "\tconst char *event_name;",
            "",
            "\t/* filter string for the tracepoint */",
            "\tchar *filter_str;",
            "",
            "\tstruct trace_event_call *event;",
            "",
            "\tstruct dyn_event\tdevent;",
            "\tstruct trace_probe\ttp;",
            "};",
            "",
            "struct eprobe_data {",
            "\tstruct trace_event_file\t*file;",
            "\tstruct trace_eprobe\t*ep;",
            "};",
            "",
            "",
            "#define for_each_trace_eprobe_tp(ep, _tp) \\",
            "\tlist_for_each_entry(ep, trace_probe_probe_list(_tp), tp.list)",
            "",
            "static int __trace_eprobe_create(int argc, const char *argv[]);",
            ""
          ],
          "function_name": null,
          "description": "定义事件探针（eprobes）相关结构体和辅助函数，包括trace_eprobe结构体用于存储事件探针元数据，以及动态事件相关操作函数声明。包含事件系统、事件名称、过滤字符串等关键字段，并引入必要的头文件和宏定义。",
          "similarity": 0.49044740200042725
        }
      ]
    }
  ]
}