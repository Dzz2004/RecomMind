{
  "query": "如何通过接口标准化提升系统可扩展性",
  "timestamp": "2025-12-26 02:01:53",
  "retrieved_files": [
    {
      "source_file": "kernel/entry/common.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:19:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\common.c`\n\n---\n\n# entry\\common.c 技术文档\n\n## 文件概述\n\n`entry\\common.c` 是 Linux 内核中处理系统调用入口/出口以及中断入口/出口路径的通用逻辑实现文件。该文件提供了一套架构无关的通用函数，用于在用户态与内核态之间切换时执行必要的上下文跟踪、审计、跟踪点、安全检查（如 seccomp）、信号处理、调度等工作。其目标是统一不同架构在系统调用和中断处理路径上的共性逻辑，减少重复代码。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `syscall_trace_enter()` | 系统调用进入时的通用处理函数，依次处理用户态分发、ptrace 跟踪、seccomp 安全检查、tracepoint 和审计 |\n| `syscall_enter_from_user_mode_prepare()` | 从用户模式进入系统调用前的准备，启用中断并进入内核上下文 |\n| `exit_to_user_mode_loop()` | 在返回用户空间前循环处理所有待办工作项（如调度、信号、uprobe、livepatch 等） |\n| `syscall_exit_work()` | 系统调用退出时的通用处理，包括审计、tracepoint、ptrace 退出报告等 |\n| `irqentry_enter()` / `irqentry_exit()` | 中断入口/出口的通用处理，管理 RCU、上下文跟踪、KMSAN、lockdep 等 |\n| `irqentry_enter_from_user_mode()` / `irqentry_exit_to_user_mode()` | 从中断上下文进入/退出用户模式的专用路径 |\n| `raw_irqentry_exit_cond_resched()` | 中断退出时的条件调度检查（仅在非抢占计数为 0 时） |\n\n### 关键数据结构\n\n- `irqentry_state_t`：记录中断入口状态，主要用于判断是否需要在退出时执行 RCU 相关操作。\n- `SYSCALL_WORK_*` 和 `_TIF_*` 标志位：用于标识待处理的工作类型（如 trace、seccomp、信号、调度等）。\n\n## 关键实现\n\n### 系统调用入口处理流程（`syscall_trace_enter`）\n\n1. **Syscall User Dispatch 优先处理**：若设置了 `SYSCALL_WORK_SYSCALL_USER_DISPATCH`，调用 `syscall_user_dispatch()`，若返回 true 则直接终止系统调用（返回 `-1`），因为此时 ABI 可能无效。\n2. **Ptrace 跟踪**：若设置了 `SYSCALL_WORK_SYSCALL_TRACE` 或 `SYSCALL_WORK_SYSCALL_EMU`，调用 `ptrace_report_syscall_entry()`。若 tracer 修改了行为或启用了 `SYSCALL_EMU`，则终止系统调用。\n3. **Seccomp 安全检查**：在 ptrace 之后执行，以捕获 tracer 可能引入的变更。调用 `__secure_computing()`，若返回 `-1` 则拒绝系统调用。\n4. **重新获取系统调用号**：上述步骤可能修改了系统调用号，需重新通过 `syscall_get_nr()` 获取。\n5. **Tracepoint 触发**：若启用 `SYSCALL_WORK_SYSCALL_TRACEPOINT`，触发 `trace_sys_enter`，并再次重新获取系统调用号（因 BPF 或 kprobe 可能修改）。\n6. **审计日志**：调用 `syscall_enter_audit()` 记录审计事件。\n7. **返回最终系统调用号或错误码**。\n\n### 返回用户空间前的工作循环（`exit_to_user_mode_loop`）\n\n- 使用 `while (ti_work & EXIT_TO_USER_MODE_WORK)` 循环处理所有待办工作，确保在返回用户态前完成：\n  - 调度（`_TIF_NEED_RESCHED`）\n  - Uprobe 通知（`_TIF_UPROBE`）\n  - Livepatch 状态更新（`_TIF_PATCH_PENDING`）\n  - 信号处理（`_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL`）\n  - 用户态恢复工作（`_TIF_NOTIFY_RESUME`）\n  - 架构特定工作（`arch_exit_to_user_mode_work`）\n- 每次循环启用中断（`local_irq_enable_exit_to_user`），处理完后再关闭中断并重新读取线程标志（`read_thread_flags()`），以应对处理过程中新产生的工作项。\n- 最后调用 `tick_nohz_user_enter_prepare()` 处理 NO_HZ 模式下的 tick 准备。\n\n### 中断入口/出口的 RCU 与上下文管理\n\n- **从中断进入用户态**：调用 `enter_from_user_mode()`，启用中断。\n- **从内核态中断入口**：\n  - 若当前是 idle 任务且非 `TINY_RCU`，无条件调用 `ct_irq_enter()` 以确保 RCU 状态一致（避免嵌套中断导致 grace period 错误结束）。\n  - 否则调用 `rcu_irq_enter_check_tick()`。\n- 所有路径均正确处理 `lockdep`、`KMSAN`（解除寄存器毒化）和 `trace_hardirqs_off` 的顺序，确保调试和安全工具正常工作。\n\n### 条件调度支持（Preemption）\n\n- `raw_irqentry_exit_cond_resched()` 在中断退出且 `preempt_count() == 0` 时检查是否需要调度。\n- 支持动态抢占（`CONFIG_PREEMPT_DYNAMIC`），通过 `static_call` 或 `static_key` 实现运行时切换，避免编译时硬编码。\n\n## 依赖关系\n\n### 头文件依赖\n- `<linux/context_tracking.h>`：上下文跟踪（用户/内核态切换）\n- `<linux/resume_user_mode.h>`：用户态恢复工作\n- `<linux/seccomp.h>`（隐式通过 `__secure_computing`）：系统调用过滤\n- `<linux/audit.h>`：审计子系统\n- `<linux/ptrace.h>`（隐式）：ptrace 跟踪\n- `<linux/livepatch.h>`：内核热补丁\n- `<linux/uprobes.h>`（隐式）：用户态探针\n- `<linux/rcupdate.h>`：RCU 机制\n- `<linux/kmsan.h>`：Kernel Memory Sanitizer 支持\n- `<trace/events/syscalls.h>`：系统调用跟踪点\n\n### 架构依赖\n- 依赖架构特定实现：\n  - `syscall_get_arguments()` / `syscall_get_nr()` / `syscall_get_return_value()`\n  - `user_mode()` / `regs_irqs_disabled()`\n  - `arch_do_signal_or_restart()`（弱符号，默认空实现）\n  - `arch_exit_to_user_mode_work()`\n\n### 子系统交互\n- **RCU**：管理中断和用户态切换时的宽限期\n- **Scheduler**：处理 `need_resched()` 和 `schedule()`\n- **Security**：seccomp、audit\n- **Tracing**：ftrace、kprobe、uprobe、BPF\n- **Livepatch**：动态补丁状态更新\n\n## 使用场景\n\n1. **系统调用入口路径**：  \n   当用户程序执行 `syscall` 指令（或其他系统调用机制）进入内核时，架构代码调用 `syscall_trace_enter()` 执行通用预处理。\n\n2. **系统调用出口路径**：  \n   系统调用返回前，若存在待处理工作（如审计、tracepoint），调用 `syscall_exit_work()`。\n\n3. **中断处理返回用户空间**：  \n   中断处理完成后，若返回用户态，调用 `irqentry_exit_to_user_mode()`，进而触发 `exit_to_user_mode_loop()` 处理所有 pending work。\n\n4. **中断嵌套与 idle 任务处理**：  \n   在 idle 任务中发生中断时，确保 RCU 正确进入 IRQ 上下文，防止 grace period 错误终止。\n\n5. **动态抢占支持**：  \n   在支持动态抢占的系统中，中断退出时根据运行时配置决定是否执行条件调度。\n\n6. **调试与安全工具集成**：  \n   为 KMSAN、Lockdep、ftrace、audit、seccomp 等子系统提供统一的入口/出口钩子，确保工具链在系统调用和中断路径上正常工作。",
      "similarity": 0.5555939674377441,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/common.c",
          "start_line": 18,
          "end_line": 124,
          "content": [
            "static inline void syscall_enter_audit(struct pt_regs *regs, long syscall)",
            "{",
            "\tif (unlikely(audit_context())) {",
            "\t\tunsigned long args[6];",
            "",
            "\t\tsyscall_get_arguments(current, regs, args);",
            "\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);",
            "\t}",
            "}",
            "long syscall_trace_enter(struct pt_regs *regs, long syscall,",
            "\t\t\t\tunsigned long work)",
            "{",
            "\tlong ret = 0;",
            "",
            "\t/*",
            "\t * Handle Syscall User Dispatch.  This must comes first, since",
            "\t * the ABI here can be something that doesn't make sense for",
            "\t * other syscall_work features.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (syscall_user_dispatch(regs))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Handle ptrace */",
            "\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {",
            "\t\tret = ptrace_report_syscall_entry(regs);",
            "\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Do seccomp after ptrace, to catch any tracer changes. */",
            "\tif (work & SYSCALL_WORK_SECCOMP) {",
            "\t\tret = __secure_computing(NULL);",
            "\t\tif (ret == -1L)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/* Either of the above might have changed the syscall number */",
            "\tsyscall = syscall_get_nr(current, regs);",
            "",
            "\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT)) {",
            "\t\ttrace_sys_enter(regs, syscall);",
            "\t\t/*",
            "\t\t * Probes or BPF hooks in the tracepoint may have changed the",
            "\t\t * system call number as well.",
            "\t\t */",
            "\t\tsyscall = syscall_get_nr(current, regs);",
            "\t}",
            "",
            "\tsyscall_enter_audit(regs, syscall);",
            "",
            "\treturn ret ? : syscall;",
            "}",
            "noinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "\tinstrumentation_begin();",
            "\tlocal_irq_enable();",
            "\tinstrumentation_end();",
            "}",
            "void __weak arch_do_signal_or_restart(struct pt_regs *regs) { }",
            "__always_inline unsigned long exit_to_user_mode_loop(struct pt_regs *regs,",
            "\t\t\t\t\t\t     unsigned long ti_work)",
            "{",
            "\t/*",
            "\t * Before returning to user space ensure that all pending work",
            "\t * items have been completed.",
            "\t */",
            "\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {",
            "",
            "\t\tlocal_irq_enable_exit_to_user(ti_work);",
            "",
            "\t\tif (ti_work & _TIF_NEED_RESCHED)",
            "\t\t\tschedule();",
            "",
            "\t\tif (ti_work & _TIF_UPROBE)",
            "\t\t\tuprobe_notify_resume(regs);",
            "",
            "\t\tif (ti_work & _TIF_PATCH_PENDING)",
            "\t\t\tklp_update_patch_state(current);",
            "",
            "\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))",
            "\t\t\tarch_do_signal_or_restart(regs);",
            "",
            "\t\tif (ti_work & _TIF_NOTIFY_RESUME)",
            "\t\t\tresume_user_mode_work(regs);",
            "",
            "\t\t/* Architecture specific TIF work */",
            "\t\tarch_exit_to_user_mode_work(regs, ti_work);",
            "",
            "\t\t/*",
            "\t\t * Disable interrupts and reevaluate the work flags as they",
            "\t\t * might have changed while interrupts and preemption was",
            "\t\t * enabled above.",
            "\t\t */",
            "\t\tlocal_irq_disable_exit_to_user();",
            "",
            "\t\t/* Check if any of the above work has queued a deferred wakeup */",
            "\t\ttick_nohz_user_enter_prepare();",
            "",
            "\t\tti_work = read_thread_flags();",
            "\t}",
            "",
            "\t/* Return the latest work state for arch_exit_to_user_mode() */",
            "\treturn ti_work;",
            "}"
          ],
          "function_name": "syscall_enter_audit, syscall_trace_enter, syscall_enter_from_user_mode_prepare, arch_do_signal_or_restart, exit_to_user_mode_loop",
          "description": "实现系统调用入口处理逻辑，依次处理审计追踪、指针观察、seccomp过滤及架构特定工作，通过位掩码控制不同安全机制的触发顺序并更新系统调用号",
          "similarity": 0.5559462308883667
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/common.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/context_tracking.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/highmem.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmsan.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/audit.h>",
            "#include <linux/tick.h>",
            "",
            "#include \"common.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/syscalls.h>",
            ""
          ],
          "function_name": null,
          "description": "声明系统调用通用功能所需头文件，包含审计、跟踪、KMSAN、LivePatch等模块的接口定义，为后续系统调用入口处理提供基础依赖",
          "similarity": 0.5320448875427246
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/entry/common.c",
          "start_line": 256,
          "end_line": 347,
          "content": [
            "void raw_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!preempt_count()) {",
            "\t\t/* Sanity check RCU and thread stack */",
            "\t\trcu_irq_exit_check_preempt();",
            "\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))",
            "\t\t\tWARN_ON_ONCE(!on_thread_stack());",
            "\t\tif (need_resched())",
            "\t\t\tpreempt_schedule_irq();",
            "\t}",
            "}",
            "void dynamic_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!static_branch_unlikely(&sk_dynamic_irqentry_exit_cond_resched))",
            "\t\treturn;",
            "\traw_irqentry_exit_cond_resched();",
            "}",
            "noinstr void irqentry_exit(struct pt_regs *regs, irqentry_state_t state)",
            "{",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\t/* Check whether this returns to user mode */",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_exit_to_user_mode(regs);",
            "\t} else if (!regs_irqs_disabled(regs)) {",
            "\t\t/*",
            "\t\t * If RCU was not watching on entry this needs to be done",
            "\t\t * carefully and needs the same ordering of lockdep/tracing",
            "\t\t * and RCU as the return to user mode path.",
            "\t\t */",
            "\t\tif (state.exit_rcu) {",
            "\t\t\tinstrumentation_begin();",
            "\t\t\t/* Tell the tracer that IRET will enable interrupts */",
            "\t\t\ttrace_hardirqs_on_prepare();",
            "\t\t\tlockdep_hardirqs_on_prepare();",
            "\t\t\tinstrumentation_end();",
            "\t\t\tct_irq_exit();",
            "\t\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tinstrumentation_begin();",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPTION))",
            "\t\t\tirqentry_exit_cond_resched();",
            "",
            "\t\t/* Covers both tracing and lockdep */",
            "\t\ttrace_hardirqs_on();",
            "\t\tinstrumentation_end();",
            "\t} else {",
            "\t\t/*",
            "\t\t * IRQ flags state is correct already. Just tell RCU if it",
            "\t\t * was not watching on entry.",
            "\t\t */",
            "\t\tif (state.exit_rcu)",
            "\t\t\tct_irq_exit();",
            "\t}",
            "}",
            "irqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t irq_state;",
            "",
            "\tirq_state.lockdep = lockdep_hardirqs_enabled();",
            "",
            "\t__nmi_enter();",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tlockdep_hardirq_enter();",
            "\tct_nmi_enter();",
            "",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\ttrace_hardirqs_off_finish();",
            "\tftrace_nmi_enter();",
            "\tinstrumentation_end();",
            "",
            "\treturn irq_state;",
            "}",
            "void noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state)",
            "{",
            "\tinstrumentation_begin();",
            "\tftrace_nmi_exit();",
            "\tif (irq_state.lockdep) {",
            "\t\ttrace_hardirqs_on_prepare();",
            "\t\tlockdep_hardirqs_on_prepare();",
            "\t}",
            "\tinstrumentation_end();",
            "",
            "\tct_nmi_exit();",
            "\tlockdep_hardirq_exit();",
            "\tif (irq_state.lockdep)",
            "\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t__nmi_exit();",
            "}"
          ],
          "function_name": "raw_irqentry_exit_cond_resched, dynamic_irqentry_exit_cond_resched, irqentry_exit, irqentry_nmi_enter, irqentry_nmi_exit",
          "description": "实现中断退出路径的条件调度检查和NMI上下文切换，维护中断标志状态一致性，处理RCU状态转换、锁依赖标记恢复及异常中断返回时的上下文还原",
          "similarity": 0.5289907455444336
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/common.c",
          "start_line": 141,
          "end_line": 250,
          "content": [
            "static inline bool report_single_step(unsigned long work)",
            "{",
            "\tif (work & SYSCALL_WORK_SYSCALL_EMU)",
            "\t\treturn false;",
            "",
            "\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;",
            "}",
            "void syscall_exit_work(struct pt_regs *regs, unsigned long work)",
            "{",
            "\tbool step;",
            "",
            "\t/*",
            "\t * If the syscall was rolled back due to syscall user dispatching,",
            "\t * then the tracers below are not invoked for the same reason as",
            "\t * the entry side was not invoked in syscall_trace_enter(): The ABI",
            "\t * of these syscalls is unknown.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {",
            "\t\t\tcurrent->syscall_dispatch.on_dispatch = false;",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\taudit_syscall_exit(regs);",
            "",
            "\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)",
            "\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));",
            "",
            "\tstep = report_single_step(work);",
            "\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)",
            "\t\tptrace_report_syscall_exit(regs, step);",
            "}",
            "noinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "}",
            "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)",
            "{",
            "\tinstrumentation_begin();",
            "\texit_to_user_mode_prepare(regs);",
            "\tinstrumentation_end();",
            "\texit_to_user_mode();",
            "}",
            "noinstr irqentry_state_t irqentry_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t ret = {",
            "\t\t.exit_rcu = false,",
            "\t};",
            "",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_enter_from_user_mode(regs);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If this entry hit the idle task invoke ct_irq_enter() whether",
            "\t * RCU is watching or not.",
            "\t *",
            "\t * Interrupts can nest when the first interrupt invokes softirq",
            "\t * processing on return which enables interrupts.",
            "\t *",
            "\t * Scheduler ticks in the idle task can mark quiescent state and",
            "\t * terminate a grace period, if and only if the timer interrupt is",
            "\t * not nested into another interrupt.",
            "\t *",
            "\t * Checking for rcu_is_watching() here would prevent the nesting",
            "\t * interrupt to invoke ct_irq_enter(). If that nested interrupt is",
            "\t * the tick then rcu_flavor_sched_clock_irq() would wrongfully",
            "\t * assume that it is the first interrupt and eventually claim",
            "\t * quiescent state and end grace periods prematurely.",
            "\t *",
            "\t * Unconditionally invoke ct_irq_enter() so RCU state stays",
            "\t * consistent.",
            "\t *",
            "\t * TINY_RCU does not support EQS, so let the compiler eliminate",
            "\t * this part when enabled.",
            "\t */",
            "\tif (!IS_ENABLED(CONFIG_TINY_RCU) && is_idle_task(current)) {",
            "\t\t/*",
            "\t\t * If RCU is not watching then the same careful",
            "\t\t * sequence vs. lockdep and tracing is required",
            "\t\t * as in irqentry_enter_from_user_mode().",
            "\t\t */",
            "\t\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\t\tct_irq_enter();",
            "\t\tinstrumentation_begin();",
            "\t\tkmsan_unpoison_entry_regs(regs);",
            "\t\ttrace_hardirqs_off_finish();",
            "\t\tinstrumentation_end();",
            "",
            "\t\tret.exit_rcu = true;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If RCU is watching then RCU only wants to check whether it needs",
            "\t * to restart the tick in NOHZ mode. rcu_irq_enter_check_tick()",
            "\t * already contains a warning when RCU is not watching, so no point",
            "\t * in having another one here.",
            "\t */",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\trcu_irq_enter_check_tick();",
            "\ttrace_hardirqs_off_finish();",
            "\tinstrumentation_end();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "report_single_step, syscall_exit_work, irqentry_enter_from_user_mode, irqentry_exit_to_user_mode, irqentry_enter",
          "description": "处理系统调用退出阶段工作，包括审计退出记录、单步调试报告和跟踪点事件，同时管理中断返回时的RCU状态转换和锁依赖检查",
          "similarity": 0.4602673351764679
        }
      ]
    },
    {
      "source_file": "kernel/compat.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `compat.c`\n\n---\n\n# compat.c 技术文档\n\n## 文件概述\n\n`compat.c` 是 Linux 内核中用于提供 32 位系统调用兼容性支持的核心文件，主要运行在 64 位内核上。该文件实现了将 32 位用户空间程序发出的系统调用转换为内核内部 64 位数据结构和接口所需的适配逻辑，确保 32 位应用程序能够在 64 位系统上正常运行。其核心功能包括信号处理、资源使用统计（rusage）、CPU 亲和性设置、位图操作以及信号集转换等兼容层封装。\n\n## 核心功能\n\n### 主要函数\n\n- `compat_sigprocmask`：32 位兼容版的 `sigprocmask` 系统调用，用于操作进程的信号掩码。\n- `put_compat_rusage`：将内核的 `struct rusage` 转换为 32 位兼容格式并复制到用户空间。\n- `compat_get_user_cpu_mask`：从用户空间读取 32 位 CPU 亲和性位图并转换为内核 `cpumask`。\n- `compat_sched_setaffinity` / `compat_sched_getaffinity`：32 位兼容的 CPU 亲和性设置与获取系统调用。\n- `get_compat_sigevent`：将 32 位 `sigevent` 结构从用户空间复制并转换为内核格式。\n- `compat_get_bitmap` / `compat_put_bitmap`：在 32 位用户空间与 64 位内核之间安全地传输位图数据。\n- `get_compat_sigset`：将 32 位信号集（`compat_sigset_t`）转换为内核内部的 `sigset_t`。\n\n### 关键数据结构\n\n- `compat_sigset_t`：32 位信号集表示。\n- `compat_rusage`：32 位资源使用统计结构。\n- `compat_sigevent`：32 位信号事件描述结构。\n- `compat_ulong_t`：32 位无符号长整型（通常为 `u32`）。\n\n## 关键实现\n\n### 信号掩码处理（`compat_sigprocmask`）\n\n该函数仅操作信号掩码的第一个字（32 位），通过 `compat_sig_setmask` 直接内存拷贝实现 `SIG_SETMASK` 行为。对于 `SIG_BLOCK` 和 `SIG_UNBLOCK`，则调用内核通用的 `sigaddsetmask` 和 `sigdelsetmask` 辅助函数。特别地，它会自动屏蔽 `SIGKILL` 和 `SIGSTOP`，因为这两个信号不可被阻塞。\n\n### 位图转换（`compat_get_bitmap` / `compat_put_bitmap`）\n\n由于 64 位内核中 `unsigned long` 为 64 位，而 32 位用户空间使用 32 位 `compat_ulong_t`，位图需进行高低位重组：\n- **读取**：每两个 32 位值组合成一个 64 位内核值（低位在前，高位在后）。\n- **写入**：将一个 64 位内核值拆分为两个 32 位值写回用户空间。\n使用 `user_read_access_begin`/`user_write_access_end` 配合 `unsafe_get/put_user` 实现高效、安全的批量访问。\n\n### 字节序处理（`get_compat_sigset`）\n\n在大端（Big-Endian）架构上，32 位信号集的高低 32 位在内存中的排列与小端不同，需显式重组为 64 位内核信号字。小端架构可直接内存拷贝。\n\n### CPU 亲和性兼容（`sched_setaffinity`/`getaffinity`）\n\n- **设置**：通过 `compat_get_user_cpu_mask` 将用户传入的 32 位位图转换为内核 `cpumask`，再调用通用 `sched_setaffinity`。\n- **获取**：先调用通用接口获取内核 `cpumask`，再通过 `compat_put_bitmap` 转换回 32 位格式返回给用户。返回长度为实际写入的字节数。\n\n### 资源使用统计（`put_compat_rusage`）\n\n逐字段将 64 位 `rusage` 中的时间（`tv_sec`/`tv_usec`）及其他统计值复制到 32 位结构体，确保字段对齐和截断安全，最后通过 `copy_to_user` 返回。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/compat.h>`：提供兼容层宏定义和类型（如 `COMPAT_SYSCALL_DEFINE`）。\n  - `<linux/uaccess.h>`：用户空间内存访问接口（`get_user`、`put_user` 等）。\n  - `<linux/sched.h>`、`<linux/cpumask.h>`：调度和 CPU 亲和性相关 API。\n  - `<linux/signal.h>`：信号处理核心接口。\n  - `<linux/posix-timers.h>`：`sigevent` 相关定义。\n- **内核模块依赖**：\n  - 调度子系统（`kernel/sched/`）：`sched_setaffinity`/`getaffinity` 实现。\n  - 信号子系统（`kernel/signal.c`）：信号掩码操作函数。\n  - 内存管理：`GFP_KERNEL` 内存分配。\n- **架构依赖**：通过 `__ARCH_WANT_SYS_SIGPROCMASK` 宏控制是否编译 `sigprocmask` 兼容实现，依赖 `__BIG_ENDIAN` 处理字节序差异。\n\n## 使用场景\n\n1. **32 位应用程序在 64 位内核上运行**：当 32 位 ELF 程序执行系统调用（如 `sigprocmask`、`sched_setaffinity`）时，内核通过此文件中的兼容层函数处理参数转换。\n2. **跨架构二进制兼容**：在 x86_64、ARM64 等支持 32 位兼容模式的架构上，该文件是运行旧版 32 位软件的关键组件。\n3. **系统调用拦截与转换**：安全模块（如 SELinux）或容器运行时可能依赖此兼容层正确解析 32 位进程的系统调用参数。\n4. **性能监控工具**：32 位 `getrusage` 调用通过 `put_compat_rusage` 获取资源统计信息。\n5. **实时/多线程应用**：32 位程序使用 `timer_create` 等 POSIX 定时器接口时，`sigevent` 结构通过 `get_compat_sigevent` 转换。",
      "similarity": 0.5549609065055847,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/compat.c",
          "start_line": 249,
          "end_line": 270,
          "content": [
            "int",
            "get_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)",
            "{",
            "#ifdef __BIG_ENDIAN",
            "\tcompat_sigset_t v;",
            "\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))",
            "\t\treturn -EFAULT;",
            "\tswitch (_NSIG_WORDS) {",
            "\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );",
            "\t}",
            "#else",
            "\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))",
            "\t\treturn -EFAULT;",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_compat_sigset",
          "description": "将用户态的兼容信号集（compat_sigset_t）转换为内核态sigset_t结构，在大端架构下通过字节序调整确保信号掩码的正确解析，实现信号集的跨字节序兼容转换。",
          "similarity": 0.5817114114761353
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/compat.c",
          "start_line": 35,
          "end_line": 144,
          "content": [
            "static inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)",
            "{",
            "\tmemcpy(blocked->sig, &set, sizeof(set));",
            "}",
            "int put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)",
            "{",
            "\tstruct compat_rusage r32;",
            "\tmemset(&r32, 0, sizeof(r32));",
            "\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;",
            "\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;",
            "\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;",
            "\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;",
            "\tr32.ru_maxrss = r->ru_maxrss;",
            "\tr32.ru_ixrss = r->ru_ixrss;",
            "\tr32.ru_idrss = r->ru_idrss;",
            "\tr32.ru_isrss = r->ru_isrss;",
            "\tr32.ru_minflt = r->ru_minflt;",
            "\tr32.ru_majflt = r->ru_majflt;",
            "\tr32.ru_nswap = r->ru_nswap;",
            "\tr32.ru_inblock = r->ru_inblock;",
            "\tr32.ru_oublock = r->ru_oublock;",
            "\tr32.ru_msgsnd = r->ru_msgsnd;",
            "\tr32.ru_msgrcv = r->ru_msgrcv;",
            "\tr32.ru_nsignals = r->ru_nsignals;",
            "\tr32.ru_nvcsw = r->ru_nvcsw;",
            "\tr32.ru_nivcsw = r->ru_nivcsw;",
            "\tif (copy_to_user(ru, &r32, sizeof(r32)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "static int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,",
            "\t\t\t\t    unsigned len, struct cpumask *new_mask)",
            "{",
            "\tunsigned long *k;",
            "",
            "\tif (len < cpumask_size())",
            "\t\tmemset(new_mask, 0, cpumask_size());",
            "\telse if (len > cpumask_size())",
            "\t\tlen = cpumask_size();",
            "",
            "\tk = cpumask_bits(new_mask);",
            "\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);",
            "}",
            "int get_compat_sigevent(struct sigevent *event,",
            "\t\tconst struct compat_sigevent __user *u_event)",
            "{",
            "\tmemset(event, 0, sizeof(*event));",
            "\treturn (!access_ok(u_event, sizeof(*u_event)) ||",
            "\t\t__get_user(event->sigev_value.sival_int,",
            "\t\t\t&u_event->sigev_value.sival_int) ||",
            "\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||",
            "\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||",
            "\t\t__get_user(event->sigev_notify_thread_id,",
            "\t\t\t&u_event->sigev_notify_thread_id))",
            "\t\t? -EFAULT : 0;",
            "}",
            "long compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,",
            "\t\t       unsigned long bitmap_size)",
            "{",
            "\tunsigned long nr_compat_longs;",
            "",
            "\t/* align bitmap up to nearest compat_long_t boundary */",
            "\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);",
            "\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);",
            "",
            "\tif (!user_read_access_begin(umask, bitmap_size / 8))",
            "\t\treturn -EFAULT;",
            "",
            "\twhile (nr_compat_longs > 1) {",
            "\t\tcompat_ulong_t l1, l2;",
            "\t\tunsafe_get_user(l1, umask++, Efault);",
            "\t\tunsafe_get_user(l2, umask++, Efault);",
            "\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;",
            "\t\tnr_compat_longs -= 2;",
            "\t}",
            "\tif (nr_compat_longs)",
            "\t\tunsafe_get_user(*mask, umask++, Efault);",
            "\tuser_read_access_end();",
            "\treturn 0;",
            "",
            "Efault:",
            "\tuser_read_access_end();",
            "\treturn -EFAULT;",
            "}",
            "long compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,",
            "\t\t       unsigned long bitmap_size)",
            "{",
            "\tunsigned long nr_compat_longs;",
            "",
            "\t/* align bitmap up to nearest compat_long_t boundary */",
            "\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);",
            "\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);",
            "",
            "\tif (!user_write_access_begin(umask, bitmap_size / 8))",
            "\t\treturn -EFAULT;",
            "",
            "\twhile (nr_compat_longs > 1) {",
            "\t\tunsigned long m = *mask++;",
            "\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);",
            "\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);",
            "\t\tnr_compat_longs -= 2;",
            "\t}",
            "\tif (nr_compat_longs)",
            "\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);",
            "\tuser_write_access_end();",
            "\treturn 0;",
            "Efault:",
            "\tuser_write_access_end();",
            "\treturn -EFAULT;",
            "}"
          ],
          "function_name": "compat_sig_setmask, put_compat_rusage, compat_get_user_cpu_mask, get_compat_sigevent, compat_get_bitmap, compat_put_bitmap",
          "description": "实现多个兼容性转换函数，包括将rusage结构体转换为32位格式、处理CPU掩码位图转换、提取sigevent事件信息以及双向转换信号集位图，核心功能是解决64位内核与32位用户态数据类型的差异。",
          "similarity": 0.542335033416748
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/compat.c",
          "start_line": 1,
          "end_line": 34,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/compat.c",
            " *",
            " *  Kernel compatibililty routines for e.g. 32 bit syscall support",
            " *  on 64 bit kernels.",
            " *",
            " *  Copyright (C) 2002-2003 Stephen Rothwell, IBM Corporation",
            " */",
            "",
            "#include <linux/linkage.h>",
            "#include <linux/compat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/signal.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/times.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#ifdef __ARCH_WANT_SYS_SIGPROCMASK",
            "",
            "/*",
            " * sys_sigprocmask SIG_SETMASK sets the first (compat) word of the",
            " * blocked set of signals to the supplied signal set",
            " */"
          ],
          "function_name": null,
          "description": "此代码块包含兼容性支持所需的基础头文件和注释，定义了处理32位系统调用兼容性的框架，主要用于实现64位内核对32位进程的信号集操作等兼容逻辑。",
          "similarity": 0.5029051899909973
        }
      ]
    },
    {
      "source_file": "kernel/jump_label.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:12:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `jump_label.c`\n\n---\n\n# jump_label.c 技术文档\n\n## 1. 文件概述\n\n`jump_label.c` 实现了 Linux 内核中的 **Jump Label（跳转标签）** 机制，这是一种运行时动态代码路径优化技术。该机制允许内核在编译时将条件分支（如调试、跟踪、安全检查等可选功能）默认编译为“跳过”状态（即无条件跳转），在运行时根据配置动态启用或禁用这些分支，从而避免传统条件判断带来的性能开销。该文件提供了对 `static_key` 的管理、引用计数控制以及底层跳转指令的动态修改功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct jump_entry`：描述一个跳转点的元数据，包含代码地址（`code`）、目标地址（`target`）和关联的 `static_key`（`key`）。\n- `struct static_key`：跳转标签的控制结构，核心成员为 `atomic_t enabled`，用于跟踪启用状态和引用计数。\n\n### 主要函数\n\n#### 锁与同步\n- `jump_label_lock()` / `jump_label_unlock()`：提供对跳转标签表操作的互斥保护。\n\n#### 排序与初始化\n- `jump_label_cmp()`：比较两个 `jump_entry`，按 `key` 和 `code` 地址排序。\n- `jump_label_swap()`：支持相对地址编码架构（`CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE`）的交换函数。\n- `jump_label_sort_entries()`：对跳转条目数组进行排序，为后续二分查找做准备。\n\n#### 引用计数与状态管理\n- `static_key_count()`：返回 `static_key` 的当前引用计数（若为 `-1` 表示正在启用中，返回 `1`）。\n- `static_key_fast_inc_not_disabled()`：快速增加已启用 `static_key` 的引用计数（无锁，仅适用于已启用状态）。\n- `static_key_slow_inc()` / `static_key_slow_inc_cpuslocked()`：安全地增加引用计数，若从 0 启用则触发跳转指令更新。\n- `static_key_enable()` / `static_key_enable_cpuslocked()`：显式启用一个 `static_key`（引用计数设为 1）。\n- `static_key_disable()` / `static_key_disable_cpuslocked()`：显式禁用一个 `static_key`（引用计数设为 0）。\n- `static_key_dec_not_one()`：尝试减少引用计数，若计数 ≤1 则返回 `false` 触发慢路径。\n- `__static_key_slow_dec_cpuslocked()`：慢路径减少引用计数（代码片段未完整，但逻辑为：若减至 0 则更新跳转指令）。\n\n#### 核心更新机制\n- `jump_label_update()`：（声明）根据 `static_key` 的启用状态，批量更新所有关联的跳转指令（实际实现在其他文件如 `kernel/jump_label.c`）。\n\n## 3. 关键实现\n\n### 引用计数语义\n- `enabled` 字段的值具有特殊含义：\n  - **> 0**：已启用，值为引用计数。\n  - **0**：已禁用。\n  - **-1**：**正在启用过程中**（序列化首次启用操作，防止并发冲突）。\n- 快速路径（`_fast_`）仅适用于已启用（`enabled > 0`）的状态，避免锁开销。\n- 慢路径（`_slow_`）处理从 0 → 1 或 1 → 0 的状态转换，需持有 `jump_label_mutex` 和 CPU 读锁（`cpus_read_lock()`）。\n\n### 并发控制\n- 使用 `jump_label_mutex` 保护跳转表的修改，确保 `jump_label_update()` 的原子性。\n- 使用 `cpus_read_lock()` 防止 CPU 热插拔期间修改代码，保证所有 CPU 可见性。\n- 通过 `atomic_try_cmpxchg` 实现无锁引用计数增减，仅在边界条件（0/1）时进入慢路径。\n\n### 架构适配\n- 支持相对地址编码（`CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE`）：`jump_label_swap()` 在排序时动态调整相对偏移，避免绝对地址重定位问题。\n\n### 内存排序\n- 启用完成后使用 `atomic_set_release()`，确保跳转指令修改对其他 CPU 可见后再更新 `enabled` 状态。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/static_key.h>`：定义 `static_key` 结构和宏。\n  - `<linux/jump_label_ratelimit.h>`：可能用于限速更新（未在片段中体现）。\n  - `<asm/sections.h>`：访问内核段（如 `__start___jump_table`）。\n  - 其他基础头文件（`memory.h`, `module.h`, `cpu.h` 等）。\n- **架构依赖**：\n  - 依赖 `asm/jump_label.h` 提供 `jump_entry` 定义和 `jump_label_update()` 实现。\n  - `CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE` 控制相对地址处理逻辑。\n- **内核子系统**：\n  - Tracepoints、Lockdep、Kprobes、BPF 等大量使用 Jump Label 优化条件分支。\n\n## 5. 使用场景\n\n- **Tracepoints**：默认禁用跟踪点，启用时动态插入跳转到处理函数。\n- **Lockdep**：调试锁依赖时动态启用检查代码。\n- **Security Modules**：如 SELinux 的条件策略检查。\n- **Kprobes/Jprobes**：动态插入探针时修改指令流。\n- **性能敏感路径**：任何需要“零开销”条件编译的场景（如 `if (static_branch_unlikely(&key))`）。\n- **模块加载/卸载**：模块中的跳转标签需在加载时注册，卸载时清理。",
      "similarity": 0.5542356371879578,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/jump_label.c",
          "start_line": 183,
          "end_line": 302,
          "content": [
            "bool static_key_slow_inc(struct static_key *key)",
            "{",
            "\tbool ret;",
            "",
            "\tcpus_read_lock();",
            "\tret = static_key_slow_inc_cpuslocked(key);",
            "\tcpus_read_unlock();",
            "\treturn ret;",
            "}",
            "void static_key_enable_cpuslocked(struct static_key *key)",
            "{",
            "\tSTATIC_KEY_CHECK_USE(key);",
            "\tlockdep_assert_cpus_held();",
            "",
            "\tif (atomic_read(&key->enabled) > 0) {",
            "\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 1);",
            "\t\treturn;",
            "\t}",
            "",
            "\tjump_label_lock();",
            "\tif (atomic_read(&key->enabled) == 0) {",
            "\t\tatomic_set(&key->enabled, -1);",
            "\t\tjump_label_update(key);",
            "\t\t/*",
            "\t\t * See static_key_slow_inc().",
            "\t\t */",
            "\t\tatomic_set_release(&key->enabled, 1);",
            "\t}",
            "\tjump_label_unlock();",
            "}",
            "void static_key_enable(struct static_key *key)",
            "{",
            "\tcpus_read_lock();",
            "\tstatic_key_enable_cpuslocked(key);",
            "\tcpus_read_unlock();",
            "}",
            "void static_key_disable_cpuslocked(struct static_key *key)",
            "{",
            "\tSTATIC_KEY_CHECK_USE(key);",
            "\tlockdep_assert_cpus_held();",
            "",
            "\tif (atomic_read(&key->enabled) != 1) {",
            "\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 0);",
            "\t\treturn;",
            "\t}",
            "",
            "\tjump_label_lock();",
            "\tif (atomic_cmpxchg(&key->enabled, 1, 0) == 1)",
            "\t\tjump_label_update(key);",
            "\tjump_label_unlock();",
            "}",
            "void static_key_disable(struct static_key *key)",
            "{",
            "\tcpus_read_lock();",
            "\tstatic_key_disable_cpuslocked(key);",
            "\tcpus_read_unlock();",
            "}",
            "static bool static_key_dec_not_one(struct static_key *key)",
            "{",
            "\tint v;",
            "",
            "\t/*",
            "\t * Go into the slow path if key::enabled is less than or equal than",
            "\t * one. One is valid to shut down the key, anything less than one",
            "\t * is an imbalance, which is handled at the call site.",
            "\t *",
            "\t * That includes the special case of '-1' which is set in",
            "\t * static_key_slow_inc_cpuslocked(), but that's harmless as it is",
            "\t * fully serialized in the slow path below. By the time this task",
            "\t * acquires the jump label lock the value is back to one and the",
            "\t * retry under the lock must succeed.",
            "\t */",
            "\tv = atomic_read(&key->enabled);",
            "\tdo {",
            "\t\t/*",
            "\t\t * Warn about the '-1' case though; since that means a",
            "\t\t * decrement is concurrent with a first (0->1) increment. IOW",
            "\t\t * people are trying to disable something that wasn't yet fully",
            "\t\t * enabled. This suggests an ordering problem on the user side.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(v < 0);",
            "",
            "\t\t/*",
            "\t\t * Warn about underflow, and lie about success in an attempt to",
            "\t\t * not make things worse.",
            "\t\t */",
            "\t\tif (WARN_ON_ONCE(v == 0))",
            "\t\t\treturn true;",
            "",
            "\t\tif (v <= 1)",
            "\t\t\treturn false;",
            "\t} while (!likely(atomic_try_cmpxchg(&key->enabled, &v, v - 1)));",
            "",
            "\treturn true;",
            "}",
            "static void __static_key_slow_dec_cpuslocked(struct static_key *key)",
            "{",
            "\tlockdep_assert_cpus_held();",
            "\tint val;",
            "",
            "\tif (static_key_dec_not_one(key))",
            "\t\treturn;",
            "",
            "\tguard(mutex)(&jump_label_mutex);",
            "\tval = atomic_read(&key->enabled);",
            "\t/*",
            "\t * It should be impossible to observe -1 with jump_label_mutex held,",
            "\t * see static_key_slow_inc_cpuslocked().",
            "\t */",
            "\tif (WARN_ON_ONCE(val == -1))",
            "\t\treturn;",
            "\t/*",
            "\t * Cannot already be 0, something went sideways.",
            "\t */",
            "\tif (WARN_ON_ONCE(val == 0))",
            "\t\treturn;",
            "",
            "\tif (atomic_dec_and_test(&key->enabled))",
            "\t\tjump_label_update(key);",
            "}"
          ],
          "function_name": "static_key_slow_inc, static_key_enable_cpuslocked, static_key_enable, static_key_disable_cpuslocked, static_key_disable, static_key_dec_not_one, __static_key_slow_dec_cpuslocked",
          "description": "实现静态键的启用/禁用逻辑，通过原子操作和互斥锁同步跳转标签更新过程，确保多CPU环境下的正确性。",
          "similarity": 0.5310813188552856
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/jump_label.c",
          "start_line": 25,
          "end_line": 150,
          "content": [
            "void jump_label_lock(void)",
            "{",
            "\tmutex_lock(&jump_label_mutex);",
            "}",
            "void jump_label_unlock(void)",
            "{",
            "\tmutex_unlock(&jump_label_mutex);",
            "}",
            "static int jump_label_cmp(const void *a, const void *b)",
            "{",
            "\tconst struct jump_entry *jea = a;",
            "\tconst struct jump_entry *jeb = b;",
            "",
            "\t/*",
            "\t * Entrires are sorted by key.",
            "\t */",
            "\tif (jump_entry_key(jea) < jump_entry_key(jeb))",
            "\t\treturn -1;",
            "",
            "\tif (jump_entry_key(jea) > jump_entry_key(jeb))",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * In the batching mode, entries should also be sorted by the code",
            "\t * inside the already sorted list of entries, enabling a bsearch in",
            "\t * the vector.",
            "\t */",
            "\tif (jump_entry_code(jea) < jump_entry_code(jeb))",
            "\t\treturn -1;",
            "",
            "\tif (jump_entry_code(jea) > jump_entry_code(jeb))",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static void jump_label_swap(void *a, void *b, int size)",
            "{",
            "\tlong delta = (unsigned long)a - (unsigned long)b;",
            "\tstruct jump_entry *jea = a;",
            "\tstruct jump_entry *jeb = b;",
            "\tstruct jump_entry tmp = *jea;",
            "",
            "\tjea->code\t= jeb->code - delta;",
            "\tjea->target\t= jeb->target - delta;",
            "\tjea->key\t= jeb->key - delta;",
            "",
            "\tjeb->code\t= tmp.code + delta;",
            "\tjeb->target\t= tmp.target + delta;",
            "\tjeb->key\t= tmp.key + delta;",
            "}",
            "static void",
            "jump_label_sort_entries(struct jump_entry *start, struct jump_entry *stop)",
            "{",
            "\tunsigned long size;",
            "\tvoid *swapfn = NULL;",
            "",
            "\tif (IS_ENABLED(CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE))",
            "\t\tswapfn = jump_label_swap;",
            "",
            "\tsize = (((unsigned long)stop - (unsigned long)start)",
            "\t\t\t\t\t/ sizeof(struct jump_entry));",
            "\tsort(start, size, sizeof(struct jump_entry), jump_label_cmp, swapfn);",
            "}",
            "int static_key_count(struct static_key *key)",
            "{",
            "\t/*",
            "\t * -1 means the first static_key_slow_inc() is in progress.",
            "\t *  static_key_enabled() must return true, so return 1 here.",
            "\t */",
            "\tint n = atomic_read(&key->enabled);",
            "",
            "\treturn n >= 0 ? n : 1;",
            "}",
            "bool static_key_fast_inc_not_disabled(struct static_key *key)",
            "{",
            "\tint v;",
            "",
            "\tSTATIC_KEY_CHECK_USE(key);",
            "\t/*",
            "\t * Negative key->enabled has a special meaning: it sends",
            "\t * static_key_slow_inc/dec() down the slow path, and it is non-zero",
            "\t * so it counts as \"enabled\" in jump_label_update().  Note that",
            "\t * atomic_inc_unless_negative() checks >= 0, so roll our own.",
            "\t */",
            "\tv = atomic_read(&key->enabled);",
            "\tdo {",
            "\t\tif (v <= 0 || (v + 1) < 0)",
            "\t\t\treturn false;",
            "\t} while (!likely(atomic_try_cmpxchg(&key->enabled, &v, v + 1)));",
            "",
            "\treturn true;",
            "}",
            "bool static_key_slow_inc_cpuslocked(struct static_key *key)",
            "{",
            "\tlockdep_assert_cpus_held();",
            "",
            "\t/*",
            "\t * Careful if we get concurrent static_key_slow_inc/dec() calls;",
            "\t * later calls must wait for the first one to _finish_ the",
            "\t * jump_label_update() process.  At the same time, however,",
            "\t * the jump_label_update() call below wants to see",
            "\t * static_key_enabled(&key) for jumps to be updated properly.",
            "\t */",
            "\tif (static_key_fast_inc_not_disabled(key))",
            "\t\treturn true;",
            "",
            "\tguard(mutex)(&jump_label_mutex);",
            "\t/* Try to mark it as 'enabling in progress. */",
            "\tif (!atomic_cmpxchg(&key->enabled, 0, -1)) {",
            "\t\tjump_label_update(key);",
            "\t\t/*",
            "\t\t * Ensure that when static_key_fast_inc_not_disabled() or",
            "\t\t * static_key_dec_not_one() observe the positive value,",
            "\t\t * they must also observe all the text changes.",
            "\t\t */",
            "\t\tatomic_set_release(&key->enabled, 1);",
            "\t} else {",
            "\t\t/*",
            "\t\t * While holding the mutex this should never observe",
            "\t\t * anything else than a value >= 1 and succeed",
            "\t\t */",
            "\t\tif (WARN_ON_ONCE(!static_key_fast_inc_not_disabled(key)))",
            "\t\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}"
          ],
          "function_name": "jump_label_lock, jump_label_unlock, jump_label_cmp, jump_label_swap, jump_label_sort_entries, static_key_count, static_key_fast_inc_not_disabled, static_key_slow_inc_cpuslocked",
          "description": "提供跳转标签排序、比较、交换逻辑及静态键计数和状态控制函数，实现对jump_entry结构的有序管理和启用状态跟踪。",
          "similarity": 0.5135208368301392
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/jump_label.c",
          "start_line": 462,
          "end_line": 565,
          "content": [
            "static bool jump_label_can_update(struct jump_entry *entry, bool init)",
            "{",
            "\t/*",
            "\t * Cannot update code that was in an init text area.",
            "\t */",
            "\tif (!init && jump_entry_is_init(entry))",
            "\t\treturn false;",
            "",
            "\tif (!kernel_text_address(jump_entry_code(entry))) {",
            "\t\t/*",
            "\t\t * This skips patching built-in __exit, which",
            "\t\t * is part of init_section_contains() but is",
            "\t\t * not part of kernel_text_address().",
            "\t\t *",
            "\t\t * Skipping built-in __exit is fine since it",
            "\t\t * will never be executed.",
            "\t\t */",
            "\t\tWARN_ONCE(!jump_entry_is_init(entry),",
            "\t\t\t  \"can't patch jump_label at %pS\",",
            "\t\t\t  (void *)jump_entry_code(entry));",
            "\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static void __jump_label_update(struct static_key *key,",
            "\t\t\t\tstruct jump_entry *entry,",
            "\t\t\t\tstruct jump_entry *stop,",
            "\t\t\t\tbool init)",
            "{",
            "\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {",
            "\t\tif (jump_label_can_update(entry, init))",
            "\t\t\tarch_jump_label_transform(entry, jump_label_type(entry));",
            "\t}",
            "}",
            "static void __jump_label_update(struct static_key *key,",
            "\t\t\t\tstruct jump_entry *entry,",
            "\t\t\t\tstruct jump_entry *stop,",
            "\t\t\t\tbool init)",
            "{",
            "\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {",
            "",
            "\t\tif (!jump_label_can_update(entry, init))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (!arch_jump_label_transform_queue(entry, jump_label_type(entry))) {",
            "\t\t\t/*",
            "\t\t\t * Queue is full: Apply the current queue and try again.",
            "\t\t\t */",
            "\t\t\tarch_jump_label_transform_apply();",
            "\t\t\tBUG_ON(!arch_jump_label_transform_queue(entry, jump_label_type(entry)));",
            "\t\t}",
            "\t}",
            "\tarch_jump_label_transform_apply();",
            "}",
            "void __init jump_label_init(void)",
            "{",
            "\tstruct jump_entry *iter_start = __start___jump_table;",
            "\tstruct jump_entry *iter_stop = __stop___jump_table;",
            "\tstruct static_key *key = NULL;",
            "\tstruct jump_entry *iter;",
            "",
            "\t/*",
            "\t * Since we are initializing the static_key.enabled field with",
            "\t * with the 'raw' int values (to avoid pulling in atomic.h) in",
            "\t * jump_label.h, let's make sure that is safe. There are only two",
            "\t * cases to check since we initialize to 0 or 1.",
            "\t */",
            "\tBUILD_BUG_ON((int)ATOMIC_INIT(0) != 0);",
            "\tBUILD_BUG_ON((int)ATOMIC_INIT(1) != 1);",
            "",
            "\tif (static_key_initialized)",
            "\t\treturn;",
            "",
            "\tcpus_read_lock();",
            "\tjump_label_lock();",
            "\tjump_label_sort_entries(iter_start, iter_stop);",
            "",
            "\tfor (iter = iter_start; iter < iter_stop; iter++) {",
            "\t\tstruct static_key *iterk;",
            "\t\tbool in_init;",
            "",
            "\t\t/* rewrite NOPs */",
            "\t\tif (jump_label_type(iter) == JUMP_LABEL_NOP)",
            "\t\t\tarch_jump_label_transform_static(iter, JUMP_LABEL_NOP);",
            "",
            "\t\tin_init = init_section_contains((void *)jump_entry_code(iter), 1);",
            "\t\tjump_entry_set_init(iter, in_init);",
            "",
            "\t\titerk = jump_entry_key(iter);",
            "\t\tif (iterk == key)",
            "\t\t\tcontinue;",
            "",
            "\t\tkey = iterk;",
            "\t\tstatic_key_set_entries(key, iter);",
            "\t}",
            "\tstatic_key_initialized = true;",
            "\tjump_label_unlock();",
            "\tcpus_read_unlock();",
            "}",
            "static inline bool static_key_sealed(struct static_key *key)",
            "{",
            "\treturn (key->type & JUMP_TYPE_LINKED) && !(key->type & ~JUMP_TYPE_MASK);",
            "}"
          ],
          "function_name": "jump_label_can_update, __jump_label_update, __jump_label_update, jump_label_init, static_key_sealed",
          "description": "初始化阶段遍历所有跳转标签条目，进行排序和架构特定转换，建立静态键与跳转条目的映射关系。",
          "similarity": 0.4948357343673706
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/jump_label.c",
          "start_line": 774,
          "end_line": 886,
          "content": [
            "static void jump_label_del_module(struct module *mod)",
            "{",
            "\tstruct jump_entry *iter_start = mod->jump_entries;",
            "\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;",
            "\tstruct jump_entry *iter;",
            "\tstruct static_key *key = NULL;",
            "\tstruct static_key_mod *jlm, **prev;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn;",
            "#endif",
            "",
            "\tfor (iter = iter_start; iter < iter_stop; iter++) {",
            "\t\tif (jump_entry_key(iter) == key)",
            "\t\t\tcontinue;",
            "",
            "\t\tkey = jump_entry_key(iter);",
            "",
            "\t\tif (within_module((unsigned long)key, mod))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* No @jlm allocated because key was sealed at init. */",
            "\t\tif (static_key_sealed(key))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* No memory during module load */",
            "\t\tif (WARN_ON(!static_key_linked(key)))",
            "\t\t\tcontinue;",
            "",
            "\t\tprev = &key->next;",
            "\t\tjlm = static_key_mod(key);",
            "",
            "\t\twhile (jlm && jlm->mod != mod) {",
            "\t\t\tprev = &jlm->next;",
            "\t\t\tjlm = jlm->next;",
            "\t\t}",
            "",
            "\t\t/* No memory during module load */",
            "\t\tif (WARN_ON(!jlm))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (prev == &key->next)",
            "\t\t\tstatic_key_set_mod(key, jlm->next);",
            "\t\telse",
            "\t\t\t*prev = jlm->next;",
            "",
            "\t\tkfree(jlm);",
            "",
            "\t\tjlm = static_key_mod(key);",
            "\t\t/* if only one etry is left, fold it back into the static_key */",
            "\t\tif (jlm->next == NULL) {",
            "\t\t\tstatic_key_set_entries(key, jlm->entries);",
            "\t\t\tstatic_key_clear_linked(key);",
            "\t\t\tkfree(jlm);",
            "\t\t}",
            "\t}",
            "}",
            "static int",
            "jump_label_module_notify(struct notifier_block *self, unsigned long val,",
            "\t\t\t void *data)",
            "{",
            "\tstruct module *mod = data;",
            "\tint ret = 0;",
            "",
            "\tcpus_read_lock();",
            "\tjump_label_lock();",
            "",
            "\tswitch (val) {",
            "\tcase MODULE_STATE_COMING:",
            "\t\tret = jump_label_add_module(mod);",
            "\t\tif (ret) {",
            "\t\t\tWARN(1, \"Failed to allocate memory: jump_label may not work properly.\\n\");",
            "\t\t\tjump_label_del_module(mod);",
            "\t\t}",
            "\t\tbreak;",
            "\tcase MODULE_STATE_GOING:",
            "\t\tjump_label_del_module(mod);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tjump_label_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\treturn notifier_from_errno(ret);",
            "}",
            "int jump_label_register(struct module *mod)",
            "{",
            "\tint ret;",
            "",
            "\tret = jump_label_module_notify(&jump_label_module_nb,",
            "\t\t\tMODULE_STATE_COMING, mod);",
            "",
            "\treturn notifier_to_errno(ret);",
            "}",
            "static __init int jump_label_init_module(void)",
            "{",
            "\treturn register_module_notifier(&jump_label_module_nb);",
            "}",
            "int jump_label_text_reserved(void *start, void *end)",
            "{",
            "\tbool init = system_state < SYSTEM_RUNNING;",
            "\tint ret = __jump_label_text_reserved(__start___jump_table,",
            "\t\t\t__stop___jump_table, start, end, init);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "#ifdef CONFIG_MODULES",
            "\tret = __jump_label_mod_text_reserved(start, end);",
            "#endif",
            "\treturn ret;",
            "}"
          ],
          "function_name": "jump_label_del_module, jump_label_module_notify, jump_label_register, jump_label_init_module, jump_label_text_reserved",
          "description": "该代码块处理模块生命周期中的跳转标签管理，包含模块卸载时清除相关静态键引用、注册模块状态变更回调通知，并通过通知链机制在模块加载/卸载时调用jump_label_add_module/jump_label_del_module进行状态同步。",
          "similarity": 0.49314308166503906
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/jump_label.c",
          "start_line": 315,
          "end_line": 423,
          "content": [
            "static void __static_key_slow_dec(struct static_key *key)",
            "{",
            "\tcpus_read_lock();",
            "\t__static_key_slow_dec_cpuslocked(key);",
            "\tcpus_read_unlock();",
            "}",
            "void jump_label_update_timeout(struct work_struct *work)",
            "{",
            "\tstruct static_key_deferred *key =",
            "\t\tcontainer_of(work, struct static_key_deferred, work.work);",
            "\t__static_key_slow_dec(&key->key);",
            "}",
            "void static_key_slow_dec(struct static_key *key)",
            "{",
            "\tSTATIC_KEY_CHECK_USE(key);",
            "\t__static_key_slow_dec(key);",
            "}",
            "void static_key_slow_dec_cpuslocked(struct static_key *key)",
            "{",
            "\tSTATIC_KEY_CHECK_USE(key);",
            "\t__static_key_slow_dec_cpuslocked(key);",
            "}",
            "void __static_key_slow_dec_deferred(struct static_key *key,",
            "\t\t\t\t    struct delayed_work *work,",
            "\t\t\t\t    unsigned long timeout)",
            "{",
            "\tSTATIC_KEY_CHECK_USE(key);",
            "",
            "\tif (static_key_dec_not_one(key))",
            "\t\treturn;",
            "",
            "\tschedule_delayed_work(work, timeout);",
            "}",
            "void __static_key_deferred_flush(void *key, struct delayed_work *work)",
            "{",
            "\tSTATIC_KEY_CHECK_USE(key);",
            "\tflush_delayed_work(work);",
            "}",
            "void jump_label_rate_limit(struct static_key_deferred *key,",
            "\t\tunsigned long rl)",
            "{",
            "\tSTATIC_KEY_CHECK_USE(key);",
            "\tkey->timeout = rl;",
            "\tINIT_DELAYED_WORK(&key->work, jump_label_update_timeout);",
            "}",
            "static int addr_conflict(struct jump_entry *entry, void *start, void *end)",
            "{",
            "\tif (jump_entry_code(entry) <= (unsigned long)end &&",
            "\t    jump_entry_code(entry) + jump_entry_size(entry) > (unsigned long)start)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int __jump_label_text_reserved(struct jump_entry *iter_start,",
            "\t\tstruct jump_entry *iter_stop, void *start, void *end, bool init)",
            "{",
            "\tstruct jump_entry *iter;",
            "",
            "\titer = iter_start;",
            "\twhile (iter < iter_stop) {",
            "\t\tif (init || !jump_entry_is_init(iter)) {",
            "\t\t\tif (addr_conflict(iter, start, end))",
            "\t\t\t\treturn 1;",
            "\t\t}",
            "\t\titer++;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void arch_jump_label_transform_static(struct jump_entry *entry,",
            "\t\t\t\t\t     enum jump_label_type type)",
            "{",
            "\t/* nothing to do on most architectures */",
            "}",
            "static inline bool static_key_type(struct static_key *key)",
            "{",
            "\treturn key->type & JUMP_TYPE_TRUE;",
            "}",
            "static inline bool static_key_linked(struct static_key *key)",
            "{",
            "\treturn key->type & JUMP_TYPE_LINKED;",
            "}",
            "static inline void static_key_clear_linked(struct static_key *key)",
            "{",
            "\tkey->type &= ~JUMP_TYPE_LINKED;",
            "}",
            "static inline void static_key_set_linked(struct static_key *key)",
            "{",
            "\tkey->type |= JUMP_TYPE_LINKED;",
            "}",
            "static void static_key_set_entries(struct static_key *key,",
            "\t\t\t\t   struct jump_entry *entries)",
            "{",
            "\tunsigned long type;",
            "",
            "\tWARN_ON_ONCE((unsigned long)entries & JUMP_TYPE_MASK);",
            "\ttype = key->type & JUMP_TYPE_MASK;",
            "\tkey->entries = entries;",
            "\tkey->type |= type;",
            "}",
            "static enum jump_label_type jump_label_type(struct jump_entry *entry)",
            "{",
            "\tstruct static_key *key = jump_entry_key(entry);",
            "\tbool enabled = static_key_enabled(key);",
            "\tbool branch = jump_entry_is_branch(entry);",
            "",
            "\t/* See the comment in linux/jump_label.h */",
            "\treturn enabled ^ branch;",
            "}"
          ],
          "function_name": "__static_key_slow_dec, jump_label_update_timeout, static_key_slow_dec, static_key_slow_dec_cpuslocked, __static_key_slow_dec_deferred, __static_key_deferred_flush, jump_label_rate_limit, addr_conflict, __jump_label_text_reserved, arch_jump_label_transform_static, static_key_type, static_key_linked, static_key_clear_linked, static_key_set_linked, static_key_set_entries, jump_label_type",
          "description": "包含延迟更新调度、地址冲突检测及架构无关的跳转标签类型判断函数，支持动态调整跳转标签行为。",
          "similarity": 0.4911835789680481
        }
      ]
    }
  ]
}