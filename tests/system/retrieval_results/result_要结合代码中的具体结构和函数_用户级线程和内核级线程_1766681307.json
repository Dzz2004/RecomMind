{
  "query": "要结合代码中的具体结构和函数 用户级线程和内核级线程",
  "timestamp": "2025-12-26 00:48:27",
  "retrieved_files": [
    {
      "source_file": "kernel/user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:58\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user.c`\n\n---\n\n# user.c 技术文档\n\n## 1. 文件概述\n\n`user.c` 实现了 Linux 内核中的 **用户缓存（user cache）** 机制，用于跟踪每个用户（以 UID 标识）所占用的系统资源（如进程数、打开文件数等），从而支持基于用户的资源限制（per-user limits）。该文件维护了一个全局的哈希表，用于快速查找和管理 `user_struct` 结构体实例，并提供了用户结构的分配、引用计数管理和释放接口。此外，文件还定义了初始用户命名空间 `init_user_ns` 和根用户结构 `root_user`，为系统启动和用户命名空间功能提供基础支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`init_user_ns`**：全局初始用户命名空间（`struct user_namespace`），作为所有用户命名空间的根，包含完整的 UID/GID/ProjID 映射（0~2³²-1），引用计数初始化为 3。\n- **`root_user`**：代表 UID 为 0 的根用户的 `struct user_struct` 实例，引用计数初始化为 1（供 init 进程使用）。\n- **`uidhash_table`**：大小为 `2^UIDHASH_BITS`（通常为 128）的哈希表，用于存储 `user_struct` 实例，实现 O(1) 平均查找复杂度。\n- **`uid_cachep`**：SLAB 缓存，用于高效分配和释放 `struct user_struct` 对象。\n\n### 主要函数\n\n- **`alloc_uid(kuid_t uid)`**：根据 UID 查找或创建对应的 `user_struct`。若不存在则分配新结构体，初始化资源计数器（如 epoll watches），并插入哈希表；若已存在则增加引用计数。处理并发创建的竞争条件。\n- **`find_user(kuid_t uid)`**：在哈希表中查找指定 UID 的 `user_struct`，若找到则增加引用计数并返回，否则返回 NULL。\n- **`free_uid(struct user_struct *up)`**：减少 `user_struct` 的引用计数，若计数归零则调用 `free_user` 释放资源。\n- **`free_user(struct user_struct *up, unsigned long flags)`**：内部函数，从哈希表中移除用户结构，释放 epoll 计数器，并通过 SLAB 缓存回收内存。\n- **`uid_cache_init(void)`**：初始化函数（通过 `subsys_initcall` 注册），创建 SLAB 缓存、初始化哈希表、为 `root_user` 分配 epoll 计数器，并将 `root_user` 插入哈希表。\n\n### 辅助函数\n\n- **`uid_hash_insert/remove/find`**：哈希表操作的内部封装，必须在持有 `uidhash_lock` 自旋锁时调用。\n- **`user_epoll_alloc/free`**：条件编译函数，用于初始化/销毁 `user_struct` 中的 epoll watches per-CPU 计数器（仅当 `CONFIG_EPOLL` 启用时有效）。\n\n## 3. 关键实现\n\n### 哈希表设计与并发控制\n\n- **哈希函数**：使用 `__uidhashfn(uid) = ((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK`，将 32 位 UID 映射到 `UIDHASH_SZ`（默认 128）个桶中，减少冲突。\n- **锁机制**：使用 `DEFINE_SPINLOCK(uidhash_lock)` 保护哈希表操作。该锁需 **软中断安全（softirq-safe）**，因为 `free_uid()` 可能在 RCU 回调（软中断上下文）中被调用。\n- **中断处理**：所有哈希表操作均使用 `spin_lock_irqsave/restore` 或 `spin_lock_irq/unlock`，确保在中断上下文和进程上下文间的正确同步。\n\n### 引用计数与资源管理\n\n- **引用计数**：`user_struct.__count` 使用 `refcount_t` 类型，确保原子操作。`alloc_uid` 返回时已持有引用，调用者必须通过 `free_uid` 释放。\n- **延迟释放**：`free_uid` 使用 `refcount_dec_and_lock_irqsave` 原子地减少计数并在归零时获取锁，避免竞态条件。\n- **资源初始化**：新创建的 `user_struct` 会初始化速率限制器（`ratelimit`）和 epoll watches 计数器（若启用）。\n\n### 初始化与竞态处理\n\n- **`root_user` 预置**：在 `uid_cache_init` 中预先将 `root_user` 插入哈希表，确保 init 进程可直接使用。\n- **双重检查**：`alloc_uid` 在分配新结构后再次检查哈希表，防止多线程同时创建同一 UID 的 `user_struct`，确保唯一性。\n\n### 用户命名空间支持\n\n- **`init_user_ns`**：作为初始用户命名空间，其 UID/GID 映射覆盖全范围（0 到 2³²-1），标志位 `USERNS_INIT_FLAGS` 启用特定行为（如允许 setgroups）。\n- **密钥环支持**：若启用 `CONFIG_KEYS`，`init_user_ns` 包含密钥环名称列表和读写信号量。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/sched/user.h>`：定义 `struct user_struct`。\n  - `<linux/user_namespace.h>`：定义 `struct user_namespace` 和相关操作。\n  - `<linux/key.h>`：提供密钥环支持（条件编译）。\n  - `<linux/percpu_counter.h>`（隐含）：用于 epoll watches 计数（通过 `CONFIG_EPOLL`）。\n- **内核配置依赖**：\n  - `CONFIG_EPOLL`：控制 epoll watches 计数器的编译。\n  - `CONFIG_USER_NS`：控制用户命名空间操作函数的绑定。\n  - `CONFIG_KEYS`：控制密钥环相关字段的初始化。\n- **子系统依赖**：\n  - **进程调度子系统**：`user_struct` 被嵌入到进程凭证（`cred`）中，用于资源统计。\n  - **用户命名空间子系统**：`init_user_ns` 是用户命名空间层次结构的根。\n  - **内存管理子系统**：依赖 SLAB 分配器管理 `user_struct` 对象。\n\n## 5. 使用场景\n\n- **进程凭证管理**：当进程通过 `setuid()`、`setreuid()` 等系统调用切换用户身份时，内核调用 `alloc_uid` 获取目标 UID 的 `user_struct`，并更新进程凭证中的用户引用。\n- **资源限制实施**：内核在创建进程、打开文件、分配内存等操作时，通过 `current_uid()` 获取当前用户的 `user_struct`，检查并更新资源使用计数（如 `processes`、`files` 字段），确保不超过 `ulimit` 限制。\n- **用户命名空间创建**：新用户命名空间的创建依赖 `init_user_ns` 作为父命名空间，并继承其映射逻辑。\n- **系统初始化**：在内核启动早期（`subsys_initcall` 阶段），初始化用户缓存和根用户结构，为 init 进程（PID 1）提供用户上下文。\n- **资源回收**：当进程退出或切换用户时，通过 `free_uid` 释放不再需要的 `user_struct` 引用，最终在引用计数归零时回收内存和相关资源（如 epoll 计数器）。",
      "similarity": 0.6312613487243652,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/user.c",
          "start_line": 1,
          "end_line": 107,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * The \"user cache\".",
            " *",
            " * (C) Copyright 1991-2000 Linus Torvalds",
            " *",
            " * We have a per-user structure to keep track of how many",
            " * processes, files etc the user has claimed, in order to be",
            " * able to have per-user limits for system resources. ",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "",
            "/*",
            " * userns count is 1 for root user, 1 for init_uts_ns,",
            " * and 1 for... ?",
            " */",
            "struct user_namespace init_user_ns = {",
            "\t.uid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.gid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.projid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.ns.count = REFCOUNT_INIT(3),",
            "\t.owner = GLOBAL_ROOT_UID,",
            "\t.group = GLOBAL_ROOT_GID,",
            "\t.ns.inum = PROC_USER_INIT_INO,",
            "#ifdef CONFIG_USER_NS",
            "\t.ns.ops = &userns_operations,",
            "#endif",
            "\t.flags = USERNS_INIT_FLAGS,",
            "#ifdef CONFIG_KEYS",
            "\t.keyring_name_list = LIST_HEAD_INIT(init_user_ns.keyring_name_list),",
            "\t.keyring_sem = __RWSEM_INITIALIZER(init_user_ns.keyring_sem),",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_user_ns);",
            "",
            "/*",
            " * UID task count cache, to get fast user lookup in \"alloc_uid\"",
            " * when changing user ID's (ie setuid() and friends).",
            " */",
            "",
            "#define UIDHASH_BITS\t(CONFIG_BASE_SMALL ? 3 : 7)",
            "#define UIDHASH_SZ\t(1 << UIDHASH_BITS)",
            "#define UIDHASH_MASK\t\t(UIDHASH_SZ - 1)",
            "#define __uidhashfn(uid)\t(((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK)",
            "#define uidhashentry(uid)\t(uidhash_table + __uidhashfn((__kuid_val(uid))))",
            "",
            "static struct kmem_cache *uid_cachep;",
            "static struct hlist_head uidhash_table[UIDHASH_SZ];",
            "",
            "/*",
            " * The uidhash_lock is mostly taken from process context, but it is",
            " * occasionally also taken from softirq/tasklet context, when",
            " * task-structs get RCU-freed. Hence all locking must be softirq-safe.",
            " * But free_uid() is also called with local interrupts disabled, and running",
            " * local_bh_enable() with local interrupts disabled is an error - we'll run",
            " * softirq callbacks, and they can unconditionally enable interrupts, and",
            " * the caller of free_uid() didn't expect that..",
            " */",
            "static DEFINE_SPINLOCK(uidhash_lock);",
            "",
            "/* root_user.__count is 1, for init task cred */",
            "struct user_struct root_user = {",
            "\t.__count\t= REFCOUNT_INIT(1),",
            "\t.uid\t\t= GLOBAL_ROOT_UID,",
            "\t.ratelimit\t= RATELIMIT_STATE_INIT(root_user.ratelimit, 0, 0),",
            "};",
            "",
            "/*",
            " * These routines must be called with the uidhash spinlock held!",
            " */"
          ],
          "function_name": null,
          "description": "定义初始用户命名空间init_user_ns，配置UID/GID/PROJID映射关系并初始化引用计数，建立全局根用户user_struct结构，通过uidhash_table构建基于哈希的UID快速查找表，设置UID哈希锁及缓存参数",
          "similarity": 0.605334997177124
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/user.c",
          "start_line": 108,
          "end_line": 167,
          "content": [
            "static void uid_hash_insert(struct user_struct *up, struct hlist_head *hashent)",
            "{",
            "\thlist_add_head(&up->uidhash_node, hashent);",
            "}",
            "static void uid_hash_remove(struct user_struct *up)",
            "{",
            "\thlist_del_init(&up->uidhash_node);",
            "}",
            "static int user_epoll_alloc(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\treturn percpu_counter_init(&up->epoll_watches, 0, GFP_KERNEL);",
            "#else",
            "\treturn 0;",
            "#endif",
            "}",
            "static void user_epoll_free(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\tpercpu_counter_destroy(&up->epoll_watches);",
            "#endif",
            "}",
            "static void free_user(struct user_struct *up, unsigned long flags)",
            "\t__releases(&uidhash_lock)",
            "{",
            "\tuid_hash_remove(up);",
            "\tspin_unlock_irqrestore(&uidhash_lock, flags);",
            "\tuser_epoll_free(up);",
            "\tkmem_cache_free(uid_cachep, up);",
            "}",
            "void free_uid(struct user_struct *up)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!up)",
            "\t\treturn;",
            "",
            "\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))",
            "\t\tfree_user(up, flags);",
            "}",
            "static int __init uid_cache_init(void)",
            "{",
            "\tint n;",
            "",
            "\tuid_cachep = kmem_cache_create(\"uid_cache\", sizeof(struct user_struct),",
            "\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);",
            "",
            "\tfor(n = 0; n < UIDHASH_SZ; ++n)",
            "\t\tINIT_HLIST_HEAD(uidhash_table + n);",
            "",
            "\tif (user_epoll_alloc(&root_user))",
            "\t\tpanic(\"root_user epoll percpu counter alloc failed\");",
            "",
            "\t/* Insert the root user immediately (init already runs as root) */",
            "\tspin_lock_irq(&uidhash_lock);",
            "\tuid_hash_insert(&root_user, uidhashentry(GLOBAL_ROOT_UID));",
            "\tspin_unlock_irq(&uidhash_lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "uid_hash_insert, uid_hash_remove, user_epoll_alloc, user_epoll_free, free_user, free_uid, uid_cache_init",
          "description": "实现用户结构体在UID哈希表中的增删操作，管理epoll计数器资源分配释放，提供free_user/free_uid接口完成用户结构销毁流程，初始化uid_cache缓存及哈希表基础结构并注册根用户",
          "similarity": 0.5713909864425659
        }
      ]
    },
    {
      "source_file": "kernel/rseq.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:54:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rseq.c`\n\n---\n\n# rseq.c 技术文档\n\n## 文件概述\n\n`rseq.c` 实现了 Linux 内核对 **Restartable Sequences（可重启序列）** 系统调用的支持。该机制允许用户空间程序在不使用重量级原子操作的前提下，高效地执行与调度器抢占、信号投递和 CPU 迁移相关的**伪原子操作**，特别适用于高性能的每 CPU（per-CPU）数据结构操作。该文件负责管理用户空间注册的 `struct rseq` TLS（线程局部存储）区域，并在任务被抢占、迁移或收到信号时，安全地中止并重定向用户空间执行流。\n\n## 核心功能\n\n### 主要数据结构\n- `struct rseq`：用户空间注册的 TLS 结构，包含 `cpu_id_start`、`cpu_id`、`node_id`、`mm_cid` 和 `rseq_cs`（critical section 描述符指针）等字段。\n- `struct rseq_cs`：用户空间关键区（critical section）的描述结构，包含起始地址、提交地址、中止地址和标志位。\n\n### 主要函数\n- `rseq_update_cpu_node_id(struct task_struct *t)`  \n  更新任务的 `rseq` TLS 区域中的 CPU ID、NUMA 节点 ID 和内存上下文 ID（mm_cid），用于反映当前执行上下文。\n  \n- `rseq_reset_rseq_cpu_node_id(struct task_struct *t)`  \n  将任务的 `rseq` TLS 区域重置为初始状态（`cpu_id` 设为 `RSEQ_CPU_ID_UNINITIALIZED`）。\n\n- `rseq_get_rseq_cs_ptr_val(struct rseq __user *rseq, u64 *rseq_cs)`  \n  从用户空间 `rseq` 结构中安全读取 `rseq_cs` 指针值。\n\n- `rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)`  \n  若 `rseq_cs` 指针有效，则从用户空间复制并验证 `struct rseq_cs` 内容（代码片段未完整展示）。\n\n- `rseq_validate_ro_fields(struct task_struct *t)`（仅在 `CONFIG_DEBUG_RSEQ` 下启用）  \n  验证用户空间 `rseq` 结构中应为只读的字段是否与内核副本一致，防止用户空间篡改。\n\n### 宏定义\n- `rseq_unsafe_put_user()`：在写入用户空间 `rseq` 字段的同时，同步更新内核中的副本（调试模式下），确保状态一致性。\n- `RSEQ_CS_NO_RESTART_FLAGS`：定义关键区中禁止因抢占、信号或迁移而重启的标志组合。\n\n## 关键实现\n\n### 可重启序列执行模型\n用户空间关键区执行流程如下：\n1. 将关键区描述符地址写入 TLS 的 `rseq->rseq_cs`；\n2. 比较 `cpu_id_start` 与当前 `cpu_id`，不一致则跳转至 `abort_ip`；\n3. 执行关键区操作；\n4. 成功提交后继续正常执行。\n\n若在步骤 1–3 之间发生**抢占、CPU 迁移或信号投递**，内核会：\n- 清空 `rseq->rseq_cs`（设为 NULL）；\n- 将用户空间返回地址设置为 `abort_ip`；\n- 恢复执行时跳转至中止处理逻辑。\n\n### 安全访问与调试支持\n- 使用 `user_read_access_begin/end()` 和 `user_write_access_begin/end()` 确保对用户空间内存的安全访问。\n- 在 `CONFIG_DEBUG_RSEQ` 模式下，内核维护 `rseq` 字段的内核副本，并在每次更新前后校验用户空间只读字段的一致性，防止恶意或错误的用户空间修改。\n- 通过 `trace_rseq_update()` 提供跟踪点，便于性能分析和调试。\n\n### 兼容性处理\n- 原始 `rseq` 结构大小为 32 字节（`ORIG_RSEQ_SIZE`）；\n- 对于扩展字段（如 `mm_cid`），仅在 `t->rseq_len > ORIG_RSEQ_SIZE` 时才进行更新或重置，确保向后兼容。\n\n## 依赖关系\n\n- **调度子系统**：依赖 `raw_smp_processor_id()` 获取当前 CPU，`task_mm_cid()` 获取内存上下文 ID。\n- **内存管理**：使用 `cpu_to_node()` 获取 NUMA 节点信息。\n- **用户空间访问**：依赖 `uaccess.h` 提供的安全用户空间读写原语（如 `unsafe_get_user`/`unsafe_put_user`）。\n- **跟踪系统**：通过 `trace/events/rseq.h` 集成内核跟踪基础设施。\n- **架构支持**：依赖 `asm/ptrace.h` 处理信号/抢占后的用户空间返回地址重定向（完整实现位于架构相关代码中）。\n\n## 使用场景\n\n- **高性能 per-CPU 操作**：如无锁计数器、每 CPU 队列等，避免传统原子操作或锁的开销。\n- **实时/低延迟应用**：减少因内核同步原语引入的延迟抖动。\n- **用户空间调度器/运行时**：如 Go、Java 虚拟机等，用于实现高效的线程本地状态管理。\n- **系统调用 `sys_rseq()`**：由用户空间通过 `rseq(2)` 系统调用注册或注销 `rseq` TLS 区域，本文件提供内核侧支持逻辑（注册/注销时调用 `rseq_update_cpu_node_id` 或 `rseq_reset_rseq_cpu_node_id`）。",
      "similarity": 0.6264297962188721,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/rseq.c",
          "start_line": 242,
          "end_line": 346,
          "content": [
            "static int rseq_get_rseq_cs_ptr_val(struct rseq __user *rseq, u64 *rseq_cs)",
            "{",
            "\tif (!rseq_cs)",
            "\t\treturn -EFAULT;",
            "",
            "#ifdef CONFIG_64BIT",
            "\tif (get_user(*rseq_cs, &rseq->rseq_cs))",
            "\t\treturn -EFAULT;",
            "#else",
            "\tif (copy_from_user(rseq_cs, &rseq->rseq_cs, sizeof(*rseq_cs)))",
            "\t\treturn -EFAULT;",
            "#endif",
            "",
            "\treturn 0;",
            "}",
            "static int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)",
            "{",
            "\tstruct rseq_cs __user *urseq_cs;",
            "\tu64 ptr;",
            "\tu32 __user *usig;",
            "\tu32 sig;",
            "\tint ret;",
            "",
            "\tret = rseq_get_rseq_cs_ptr_val(t->rseq, &ptr);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* If the rseq_cs pointer is NULL, return a cleared struct rseq_cs. */",
            "\tif (!ptr) {",
            "\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));",
            "\t\treturn 0;",
            "\t}",
            "\t/* Check that the pointer value fits in the user-space process space. */",
            "\tif (ptr >= TASK_SIZE)",
            "\t\treturn -EINVAL;",
            "\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;",
            "\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (rseq_cs->start_ip >= TASK_SIZE ||",
            "\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||",
            "\t    rseq_cs->abort_ip >= TASK_SIZE ||",
            "\t    rseq_cs->version > 0)",
            "\t\treturn -EINVAL;",
            "\t/* Check for overflow. */",
            "\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)",
            "\t\treturn -EINVAL;",
            "\t/* Ensure that abort_ip is not in the critical section. */",
            "\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)",
            "\t\treturn -EINVAL;",
            "",
            "\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));",
            "\tret = get_user(sig, usig);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (current->rseq_sig != sig) {",
            "\t\tprintk_ratelimited(KERN_WARNING",
            "\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",",
            "\t\t\tsig, current->rseq_sig, current->pid, usig);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool rseq_warn_flags(const char *str, u32 flags)",
            "{",
            "\tu32 test_flags;",
            "",
            "\tif (!flags)",
            "\t\treturn false;",
            "\ttest_flags = flags & RSEQ_CS_NO_RESTART_FLAGS;",
            "\tif (test_flags)",
            "\t\tpr_warn_once(\"Deprecated flags (%u) in %s ABI structure\", test_flags, str);",
            "\ttest_flags = flags & ~RSEQ_CS_NO_RESTART_FLAGS;",
            "\tif (test_flags)",
            "\t\tpr_warn_once(\"Unknown flags (%u) in %s ABI structure\", test_flags, str);",
            "\treturn true;",
            "}",
            "static int rseq_need_restart(struct task_struct *t, u32 cs_flags)",
            "{",
            "\tu32 flags, event_mask;",
            "\tint ret;",
            "",
            "\tif (rseq_warn_flags(\"rseq_cs\", cs_flags))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Get thread flags. */",
            "\tret = get_user(flags, &t->rseq->flags);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (rseq_warn_flags(\"rseq\", flags))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Load and clear event mask atomically with respect to",
            "\t * scheduler preemption.",
            "\t */",
            "\tpreempt_disable();",
            "\tevent_mask = t->rseq_event_mask;",
            "\tt->rseq_event_mask = 0;",
            "\tpreempt_enable();",
            "",
            "\treturn !!event_mask;",
            "}"
          ],
          "function_name": "rseq_get_rseq_cs_ptr_val, rseq_get_rseq_cs, rseq_warn_flags, rseq_need_restart",
          "description": "提供rseq_cs指针解析、结构体验证、标志位检查及是否需要重启的判定逻辑，保障安全性和兼容性。",
          "similarity": 0.5720404982566833
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/rseq.c",
          "start_line": 1,
          "end_line": 34,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Restartable sequences system call",
            " *",
            " * Copyright (C) 2015, Google, Inc.,",
            " * Paul Turner <pjt@google.com> and Andrew Hunter <ahh@google.com>",
            " * Copyright (C) 2015-2018, EfficiOS Inc.,",
            " * Mathieu Desnoyers <mathieu.desnoyers@efficios.com>",
            " */",
            "",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/rseq.h>",
            "#include <linux/types.h>",
            "#include <linux/ratelimit.h>",
            "#include <asm/ptrace.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/rseq.h>",
            "",
            "/* The original rseq structure size (including padding) is 32 bytes. */",
            "#define ORIG_RSEQ_SIZE\t\t32",
            "",
            "#define RSEQ_CS_NO_RESTART_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT | \\",
            "\t\t\t\t  RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL | \\",
            "\t\t\t\t  RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE)",
            "",
            "#ifdef CONFIG_DEBUG_RSEQ",
            "static struct rseq *rseq_kernel_fields(struct task_struct *t)",
            "{",
            "\treturn (struct rseq *) t->rseq_fields;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义rseq内核字段访问函数，用于获取当前任务的rseq结构体指针，供后续验证和操作使用。",
          "similarity": 0.5700629949569702
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/rseq.c",
          "start_line": 35,
          "end_line": 159,
          "content": [
            "static int rseq_validate_ro_fields(struct task_struct *t)",
            "{",
            "\tstatic DEFINE_RATELIMIT_STATE(_rs,",
            "\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,",
            "\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
            "\tu32 cpu_id_start, cpu_id, node_id, mm_cid;",
            "\tstruct rseq __user *rseq = t->rseq;",
            "",
            "\t/*",
            "\t * Validate fields which are required to be read-only by",
            "\t * user-space.",
            "\t */",
            "\tif (!user_read_access_begin(rseq, t->rseq_len))",
            "\t\tgoto efault;",
            "\tunsafe_get_user(cpu_id_start, &rseq->cpu_id_start, efault_end);",
            "\tunsafe_get_user(cpu_id, &rseq->cpu_id, efault_end);",
            "\tunsafe_get_user(node_id, &rseq->node_id, efault_end);",
            "\tunsafe_get_user(mm_cid, &rseq->mm_cid, efault_end);",
            "\tuser_read_access_end();",
            "",
            "\tif ((cpu_id_start != rseq_kernel_fields(t)->cpu_id_start ||",
            "\t    cpu_id != rseq_kernel_fields(t)->cpu_id ||",
            "\t    node_id != rseq_kernel_fields(t)->node_id ||",
            "\t    mm_cid != rseq_kernel_fields(t)->mm_cid) && __ratelimit(&_rs)) {",
            "",
            "\t\tpr_warn(\"Detected rseq corruption for pid: %d, name: %s\\n\"",
            "\t\t\t\"\\tcpu_id_start: %u ?= %u\\n\"",
            "\t\t\t\"\\tcpu_id:       %u ?= %u\\n\"",
            "\t\t\t\"\\tnode_id:      %u ?= %u\\n\"",
            "\t\t\t\"\\tmm_cid:       %u ?= %u\\n\",",
            "\t\t\tt->pid, t->comm,",
            "\t\t\tcpu_id_start, rseq_kernel_fields(t)->cpu_id_start,",
            "\t\t\tcpu_id, rseq_kernel_fields(t)->cpu_id,",
            "\t\t\tnode_id, rseq_kernel_fields(t)->node_id,",
            "\t\t\tmm_cid, rseq_kernel_fields(t)->mm_cid);",
            "\t}",
            "",
            "\t/* For now, only print a console warning on mismatch. */",
            "\treturn 0;",
            "",
            "efault_end:",
            "\tuser_read_access_end();",
            "efault:",
            "\treturn -EFAULT;",
            "}",
            "static int rseq_validate_ro_fields(struct task_struct *t)",
            "{",
            "\treturn 0;",
            "}",
            "static int rseq_update_cpu_node_id(struct task_struct *t)",
            "{",
            "\tstruct rseq __user *rseq = t->rseq;",
            "\tu32 cpu_id = raw_smp_processor_id();",
            "\tu32 node_id = cpu_to_node(cpu_id);",
            "\tu32 mm_cid = task_mm_cid(t);",
            "",
            "\t/*",
            "\t * Validate read-only rseq fields.",
            "\t */",
            "\tif (rseq_validate_ro_fields(t))",
            "\t\tgoto efault;",
            "\tWARN_ON_ONCE((int) mm_cid < 0);",
            "\tif (!user_write_access_begin(rseq, t->rseq_len))",
            "\t\tgoto efault;",
            "",
            "\trseq_unsafe_put_user(t, cpu_id, cpu_id_start, efault_end);",
            "\trseq_unsafe_put_user(t, cpu_id, cpu_id, efault_end);",
            "\trseq_unsafe_put_user(t, node_id, node_id, efault_end);",
            "\trseq_unsafe_put_user(t, mm_cid, mm_cid, efault_end);",
            "",
            "\t/*",
            "\t * Additional feature fields added after ORIG_RSEQ_SIZE",
            "\t * need to be conditionally updated only if",
            "\t * t->rseq_len != ORIG_RSEQ_SIZE.",
            "\t */",
            "\tuser_write_access_end();",
            "\ttrace_rseq_update(t);",
            "\treturn 0;",
            "",
            "efault_end:",
            "\tuser_write_access_end();",
            "efault:",
            "\treturn -EFAULT;",
            "}",
            "static int rseq_reset_rseq_cpu_node_id(struct task_struct *t)",
            "{",
            "\tstruct rseq __user *rseq = t->rseq;",
            "\tu32 cpu_id_start = 0, cpu_id = RSEQ_CPU_ID_UNINITIALIZED, node_id = 0,",
            "\t    mm_cid = 0;",
            "",
            "\t/*",
            "\t * Validate read-only rseq fields.",
            "\t */",
            "\tif (rseq_validate_ro_fields(t))",
            "\t\tgoto efault;",
            "",
            "\tif (!user_write_access_begin(rseq, t->rseq_len))",
            "\t\tgoto efault;",
            "",
            "\t/*",
            "\t * Reset all fields to their initial state.",
            "\t *",
            "\t * All fields have an initial state of 0 except cpu_id which is set to",
            "\t * RSEQ_CPU_ID_UNINITIALIZED, so that any user coming in after",
            "\t * unregistration can figure out that rseq needs to be registered",
            "\t * again.",
            "\t */",
            "\trseq_unsafe_put_user(t, cpu_id_start, cpu_id_start, efault_end);",
            "\trseq_unsafe_put_user(t, cpu_id, cpu_id, efault_end);",
            "\trseq_unsafe_put_user(t, node_id, node_id, efault_end);",
            "\trseq_unsafe_put_user(t, mm_cid, mm_cid, efault_end);",
            "",
            "\t/*",
            "\t * Additional feature fields added after ORIG_RSEQ_SIZE",
            "\t * need to be conditionally reset only if",
            "\t * t->rseq_len != ORIG_RSEQ_SIZE.",
            "\t */",
            "\tuser_write_access_end();",
            "\treturn 0;",
            "",
            "efault_end:",
            "\tuser_write_access_end();",
            "efault:",
            "\treturn -EFAULT;",
            "}"
          ],
          "function_name": "rseq_validate_ro_fields, rseq_validate_ro_fields, rseq_update_cpu_node_id, rseq_reset_rseq_cpu_node_id",
          "description": "实现rseq只读字段校验、CPU/节点ID更新及重置功能，检测并防止用户态对只读字段的篡改。",
          "similarity": 0.5321809649467468
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/rseq.c",
          "start_line": 355,
          "end_line": 442,
          "content": [
            "static int clear_rseq_cs(struct rseq __user *rseq)",
            "{",
            "\t/*",
            "\t * The rseq_cs field is set to NULL on preemption or signal",
            "\t * delivery on top of rseq assembly block, as well as on top",
            "\t * of code outside of the rseq assembly block. This performs",
            "\t * a lazy clear of the rseq_cs field.",
            "\t *",
            "\t * Set rseq_cs to NULL.",
            "\t */",
            "#ifdef CONFIG_64BIT",
            "\treturn put_user(0UL, &rseq->rseq_cs);",
            "#else",
            "\tif (clear_user(&rseq->rseq_cs, sizeof(rseq->rseq_cs)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "#endif",
            "}",
            "static bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)",
            "{",
            "\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;",
            "}",
            "static int rseq_ip_fixup(struct pt_regs *regs)",
            "{",
            "\tunsigned long ip = instruction_pointer(regs);",
            "\tstruct task_struct *t = current;",
            "\tstruct rseq_cs rseq_cs;",
            "\tint ret;",
            "",
            "\tret = rseq_get_rseq_cs(t, &rseq_cs);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/*",
            "\t * Handle potentially not being within a critical section.",
            "\t * If not nested over a rseq critical section, restart is useless.",
            "\t * Clear the rseq_cs pointer and return.",
            "\t */",
            "\tif (!in_rseq_cs(ip, &rseq_cs))",
            "\t\treturn clear_rseq_cs(t->rseq);",
            "\tret = rseq_need_restart(t, rseq_cs.flags);",
            "\tif (ret <= 0)",
            "\t\treturn ret;",
            "\tret = clear_rseq_cs(t->rseq);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,",
            "\t\t\t    rseq_cs.abort_ip);",
            "\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);",
            "\treturn 0;",
            "}",
            "void __rseq_handle_notify_resume(struct ksignal *ksig, struct pt_regs *regs)",
            "{",
            "\tstruct task_struct *t = current;",
            "\tint ret, sig;",
            "",
            "\tif (unlikely(t->flags & PF_EXITING))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * regs is NULL if and only if the caller is in a syscall path.  Skip",
            "\t * fixup and leave rseq_cs as is so that rseq_sycall() will detect and",
            "\t * kill a misbehaving userspace on debug kernels.",
            "\t */",
            "\tif (regs) {",
            "\t\tret = rseq_ip_fixup(regs);",
            "\t\tif (unlikely(ret < 0))",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (unlikely(rseq_update_cpu_node_id(t)))",
            "\t\tgoto error;",
            "\treturn;",
            "",
            "error:",
            "\tsig = ksig ? ksig->sig : 0;",
            "\tforce_sigsegv(sig);",
            "}",
            "void rseq_syscall(struct pt_regs *regs)",
            "{",
            "\tunsigned long ip = instruction_pointer(regs);",
            "\tstruct task_struct *t = current;",
            "\tstruct rseq_cs rseq_cs;",
            "",
            "\tif (!t->rseq)",
            "\t\treturn;",
            "\tif (rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))",
            "\t\tforce_sig(SIGSEGV);",
            "}"
          ],
          "function_name": "clear_rseq_cs, in_rseq_cs, rseq_ip_fixup, __rseq_handle_notify_resume, rseq_syscall",
          "description": "实现rseq异常处理流程，包括临界区IP修复、通知恢复处理和系统调用保护，确保rseq执行的安全边界。",
          "similarity": 0.5272397994995117
        }
      ]
    },
    {
      "source_file": "kernel/user-return-notifier.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user-return-notifier.c`\n\n---\n\n# user-return-notifier.c 技术文档\n\n## 1. 文件概述\n\n`user-return-notifier.c` 实现了用户态返回通知机制（User Return Notifier），允许内核子系统在当前 CPU 即将从内核态返回用户态时注册回调函数。该机制用于在特定内核事件（如安全策略更新、性能监控等）发生后，延迟执行某些操作，直到进程真正返回用户空间，从而避免在关键内核路径中引入额外开销或竞态条件。\n\n## 2. 核心功能\n\n### 数据结构\n- `return_notifier_list`：每 CPU 变量（per-CPU variable），类型为 `struct hlist_head`，用于存储当前 CPU 上注册的所有用户返回通知器链表。\n\n### 主要函数\n- `user_return_notifier_register(struct user_return_notifier *urn)`  \n  注册一个用户返回通知器，将其加入当前 CPU 的通知链表，并设置当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `user_return_notifier_unregister(struct user_return_notifier *urn)`  \n  从当前 CPU 的通知链表中移除指定的通知器；若链表变为空，则清除当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `fire_user_return_notifiers(void)`  \n  遍历并调用当前 CPU 上所有已注册的通知器的回调函数 `on_user_return`，通常在内核即将返回用户态前由调度或系统调用退出路径调用。\n\n## 3. 关键实现\n\n- **每 CPU 链表设计**：使用 `DEFINE_PER_CPU` 定义 per-CPU 的哈希链表头，确保每个 CPU 维护独立的通知器列表，避免跨 CPU 同步开销。\n  \n- **原子上下文要求**：注册和注销操作必须在原子上下文中执行（不可睡眠），因为它们操作 per-CPU 数据且可能在中断或调度关键路径中被调用。\n\n- **线程标志位控制**：通过设置/清除任务结构体中的 `TIF_USER_RETURN_NOTIFY` 标志位（`TIF_` 表示 Thread Info Flag），通知内核在返回用户态前需调用 `fire_user_return_notifiers()`。\n\n- **安全遍历与调用**：`fire_user_return_notifiers()` 使用 `hlist_for_each_entry_safe` 安全遍历链表，允许回调函数在执行过程中注销自身或其他通知器。\n\n- **CPU 变量访问**：使用 `get_cpu_var()` 和 `put_cpu_var()` 保证在访问 per-CPU 变量期间禁止内核抢占，确保操作的 CPU 一致性。\n\n## 4. 依赖关系\n\n- `<linux/user-return-notifier.h>`：定义 `struct user_return_notifier` 及相关 API。\n- `<linux/percpu.h>`：提供 per-CPU 变量支持。\n- `<linux/sched.h>`：提供任务结构体（`current`）和线程标志位操作函数（如 `set_tsk_thread_flag`）。\n- `<linux/export.h>`：导出符号供其他内核模块使用（`EXPORT_SYMBOL_GPL`）。\n- 依赖架构相关的线程信息标志（`TIF_USER_RETURN_NOTIFY`）在 `thread_info` 中的定义。\n\n## 5. 使用场景\n\n- **安全模块**：如 SELinux 或 LSM 框架在策略更新后，需通知用户态进程重新评估权限，可延迟到返回用户态时触发。\n- **性能监控与跟踪**：在系统调用或中断处理完成后，于返回用户态前收集上下文切换或延迟信息。\n- **延迟工作调度**：某些不适合在中断或原子上下文中执行的操作，可注册为用户返回通知，在安全的用户态切换点执行。\n- **虚拟化与容器**：在客户机或容器退出内核时同步状态或注入事件。\n\n该机制是内核“延迟通知”模式的典型实现，确保高优先级内核路径不受回调逻辑影响，同时保证通知在正确的执行上下文中触发。",
      "similarity": 0.6237353086471558,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 15,
          "end_line": 36,
          "content": [
            "void user_return_notifier_register(struct user_return_notifier *urn)",
            "{",
            "\tset_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "\thlist_add_head(&urn->link, this_cpu_ptr(&return_notifier_list));",
            "}",
            "void user_return_notifier_unregister(struct user_return_notifier *urn)",
            "{",
            "\thlist_del(&urn->link);",
            "\tif (hlist_empty(this_cpu_ptr(&return_notifier_list)))",
            "\t\tclear_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "}",
            "void fire_user_return_notifiers(void)",
            "{",
            "\tstruct user_return_notifier *urn;",
            "\tstruct hlist_node *tmp2;",
            "\tstruct hlist_head *head;",
            "",
            "\thead = &get_cpu_var(return_notifier_list);",
            "\thlist_for_each_entry_safe(urn, tmp2, head, link)",
            "\t\turn->on_user_return(urn);",
            "\tput_cpu_var(return_notifier_list);",
            "}"
          ],
          "function_name": "user_return_notifier_register, user_return_notifier_unregister, fire_user_return_notifiers",
          "description": "实现用户态返回通知器的注册/注销与触发机制。register 函数将通知器链接到当前 CPU 的链表并设置 TIF_USER_RETURN_NOTIFY 标志；unregister 函数移除节点并清理标志；fire 函数遍历当前 CPU 链表执行所有注册的 on_user_return 回调函数。",
          "similarity": 0.6113566160202026
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "",
            "static DEFINE_PER_CPU(struct hlist_head, return_notifier_list);",
            "",
            "/*",
            " * Request a notification when the current cpu returns to userspace.  Must be",
            " * called in atomic context.  The notifier will also be called in atomic",
            " * context.",
            " */"
          ],
          "function_name": null,
          "description": "定义了一个 per-CPU 的哈希列表头结构 return_notifier_list，用于存储用户态返回通知器注册项。该结构通过 DEFINE_PER_CPU 宏为每个 CPU 创建独立的链表头，支持多 CPU 环境下的并发访问。",
          "similarity": 0.5816825032234192
        }
      ]
    }
  ]
}