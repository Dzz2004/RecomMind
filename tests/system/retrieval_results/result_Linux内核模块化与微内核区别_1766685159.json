{
  "query": "Linux内核模块化与微内核区别",
  "timestamp": "2025-12-26 01:52:39",
  "retrieved_files": [
    {
      "source_file": "kernel/module/main.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:04:44\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\main.c`\n\n---\n\n# `module/main.c` 技术文档\n\n## 1. 文件概述\n\n`module/main.c` 是 Linux 内核模块子系统的核心实现文件，负责模块的加载、卸载、符号解析、内存管理、状态跟踪以及模块间依赖关系的维护。该文件实现了内核模块机制的基础框架，包括模块列表管理、模块内存布局控制、符号查找、模块通知机制、模块引用计数等关键功能，是内核动态加载模块能力的核心支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mod_tree_root mod_tree`**：用于加速地址到模块映射的全局模块地址范围树，包含 `addr_min`/`addr_max`（及可选的 `data_addr_min`/`data_addr_max`）。\n- **`LIST_HEAD(modules)`**：全局模块链表，存储所有已加载模块。\n- **`DEFINE_MUTEX(module_mutex)`**：保护模块列表、模块使用关系及地址边界的关键互斥锁。\n- **`struct symsearch`**：用于描述符号搜索范围，包含符号起止位置、CRC 校验数组及许可证类型。\n- **`struct find_symbol_arg`**：符号查找的参数结构体，用于传递查找目标及接收结果（所有者、符号指针、CRC、许可证等）。\n\n### 主要函数与接口\n\n- **模块注册/注销通知**：\n  - `register_module_notifier()` / `unregister_module_notifier()`：注册/注销模块生命周期事件通知回调。\n- **模块引用管理**：\n  - `strong_try_module_get()`：强引用获取，拒绝处于 `COMING` 状态的模块。\n  - `__module_put_and_kthread_exit()`：专用于内核线程在退出前释放模块引用。\n- **模块内存边界管理**：\n  - `__mod_update_bounds()` / `mod_update_bounds()`：更新全局模块地址范围，用于加速 `__module_address()`。\n- **ELF 节区辅助函数**：\n  - `find_sec()` / `find_any_sec()`：根据名称查找 ELF 节区索引。\n  - `section_addr()` / `section_objs()`：获取节区地址及对象数量。\n- **符号查找**：\n  - `find_symbol()`：在内核及已加载模块中查找导出符号。\n  - `find_exported_symbol_in_section()`：在指定符号段中二分查找符号。\n- **模块状态与安全**：\n  - `add_taint_module()`：为模块添加污点标记（taint flag）。\n- **全局控制**：\n  - `modules_disabled`：通过 `nomodule` 内核参数控制是否禁用模块加载。\n\n### 全局变量与工作队列\n\n- **`init_free_wq`**：用于异步释放模块初始化段（`.init`）内存的工作队列。\n- **`init_free_list`**：待释放初始化内存的无锁链表。\n- **`module_wq`**：等待模块初始化完成的等待队列。\n\n## 3. 关键实现\n\n### 模块地址范围加速\n\n通过 `mod_tree` 全局结构维护所有模块（或核心数据）的最小/最大虚拟地址。`__module_address()` 可先检查目标地址是否落在 `[addr_min, addr_max]` 范围内，若不在则直接返回 `NULL`，避免遍历整个模块链表，显著提升性能。\n\n### 符号查找机制\n\n- 使用 `bsearch()` 在已排序的导出符号表中进行二分查找，时间复杂度为 O(log n)。\n- 支持符号命名空间（namespace）和 GPL 许可证检查：非 GPL 模块无法使用 `GPL_ONLY` 符号。\n- 通过 `symsearch` 数组统一管理内核及各模块的符号段，实现统一查找接口。\n\n### 模块内存管理\n\n- 模块内存按 `mod_mem_type`（如代码、只读数据、可写数据、初始化段等）分类管理。\n- 初始化段（`.init`）在模块初始化成功后通过工作队列异步释放，节省内存。\n- 支持 `CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC` 架构选项，将模块数据段单独纳入地址范围管理。\n\n### 模块状态与引用安全\n\n- `strong_try_module_get()` 确保不会对处于 `MODULE_STATE_COMING`（正在初始化）或 `MODULE_STATE_UNFORMED`（未形成）状态的模块增加引用，防止竞态。\n- `__module_put_and_kthread_exit()` 为内核线程提供安全退出路径，在释放模块引用后终止线程。\n\n### 模块通知机制\n\n基于 `blocking_notifier_chain` 实现模块生命周期事件（如加载、卸载、初始化完成等）的通知，允许其他子系统（如 livepatch、ftrace）监听并响应模块状态变化。\n\n### 构建标识与版本校验\n\n- 通过 `INCLUDE_VERMAGIC` 宏包含模块魔数（vermagic）信息，用于加载时内核版本兼容性检查。\n- 支持 `CONFIG_MODVERSIONS`，在符号查找时返回 CRC 校验值，确保符号 ABI 兼容性。\n\n## 4. 依赖关系\n\n- **架构相关**：\n  - 依赖 `asm/cacheflush.h`、`asm/mmu_context.h`、`asm/sections.h` 等架构头文件，处理指令缓存刷新、内存映射等。\n  - 使用 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 优化符号字符串存储。\n- **内核子系统**：\n  - **内存管理**：`vmalloc`、`slab` 用于模块内存分配。\n  - **安全机制**：`capability`、`audit`、`module_signature` 用于模块加载权限和签名验证。\n  - **调试与追踪**：`kallsyms`、`trace_events`、`ftrace`、`dynamic_debug`、`debugfs` 提供模块调试支持。\n  - **并发控制**：`RCU`、`mutex`、`percpu` 用于同步。\n  - **文件系统**：`fs.h`、`kernel_read_file.h` 用于从文件加载模块。\n- **内部依赖**：\n  - 依赖同目录下的 `internal.h`，包含模块子系统内部数据结构和函数声明。\n  - 使用 `uapi/linux/module.h` 定义用户空间接口常量。\n\n## 5. 使用场景\n\n- **动态加载内核模块**：通过 `init_module()` 或 `finit_module()` 系统调用加载 `.ko` 文件时，该文件中的函数负责解析 ELF、重定位、符号解析、执行初始化函数。\n- **模块卸载**：通过 `delete_module()` 系统调用卸载模块时，管理模块引用计数、执行清理函数、释放内存。\n- **内核符号解析**：当模块或内核其他部分调用 `symbol_get()` 或通过 `EXPORT_SYMBOL` 机制访问符号时，`find_symbol()` 被调用。\n- **运行时模块查询**：`/proc/modules`、`/sys/module/` 等接口依赖此文件维护的模块列表和状态信息。\n- **内核热补丁（Livepatch）**：依赖模块通知机制和符号查找功能实现函数替换。\n- **内核调试与性能分析**：ftrace、kprobes 等工具依赖模块地址范围和符号信息进行函数跟踪。",
      "similarity": 0.6100622415542603,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "kernel/module/main.c",
          "start_line": 1925,
          "end_line": 2029,
          "content": [
            "static int copy_chunked_from_user(void *dst, const void __user *usrc, unsigned long len)",
            "{",
            "\tdo {",
            "\t\tunsigned long n = min(len, COPY_CHUNK_SIZE);",
            "",
            "\t\tif (copy_from_user(dst, usrc, n) != 0)",
            "\t\t\treturn -EFAULT;",
            "\t\tcond_resched();",
            "\t\tdst += n;",
            "\t\tusrc += n;",
            "\t\tlen -= n;",
            "\t} while (len);",
            "\treturn 0;",
            "}",
            "static int check_modinfo_livepatch(struct module *mod, struct load_info *info)",
            "{",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (!get_modinfo(info, \"livepatch\")) {",
            "\t\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_NONE);",
            "\t\treturn 0;",
            "\t}",
            "\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_UNDO);",
            "#else /* !CONFIG_LIVEPATCH_WO_FTRACE */",
            "\tif (!get_modinfo(info, \"livepatch\"))",
            "\t\t/* Nothing more to do */",
            "\t\treturn 0;",
            "#endif /* CONFIG_LIVEPATCH_WO_FTRACE */",
            "",
            "\tif (set_livepatch_module(mod))",
            "\t\treturn 0;",
            "",
            "\tpr_err(\"%s: module is marked as livepatch module, but livepatch support is disabled\",",
            "\t       mod->name);",
            "\treturn -ENOEXEC;",
            "}",
            "static void check_modinfo_retpoline(struct module *mod, struct load_info *info)",
            "{",
            "\tif (retpoline_module_ok(get_modinfo(info, \"retpoline\")))",
            "\t\treturn;",
            "",
            "\tpr_warn(\"%s: loading module not compiled with retpoline compiler.\\n\",",
            "\t\tmod->name);",
            "}",
            "static int copy_module_from_user(const void __user *umod, unsigned long len,",
            "\t\t\t\t  struct load_info *info)",
            "{",
            "\tint err;",
            "",
            "\tinfo->len = len;",
            "\tif (info->len < sizeof(*(info->hdr)))",
            "\t\treturn -ENOEXEC;",
            "",
            "\terr = security_kernel_load_data(LOADING_MODULE, true);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Suck in entire file: we'll want most of it. */",
            "\tinfo->hdr = __vmalloc(info->len, GFP_KERNEL | __GFP_NOWARN);",
            "\tif (!info->hdr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (copy_chunked_from_user(info->hdr, umod, info->len) != 0) {",
            "\t\terr = -EFAULT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terr = security_kernel_post_load_data((char *)info->hdr, info->len,",
            "\t\t\t\t\t     LOADING_MODULE, \"init_module\");",
            "out:",
            "\tif (err)",
            "\t\tvfree(info->hdr);",
            "",
            "\treturn err;",
            "}",
            "static void free_copy(struct load_info *info, int flags)",
            "{",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tmodule_decompress_cleanup(info);",
            "\telse",
            "\t\tvfree(info->hdr);",
            "}",
            "static int rewrite_section_headers(struct load_info *info, int flags)",
            "{",
            "\tunsigned int i;",
            "",
            "\t/* This should always be true, but let's be sure. */",
            "\tinfo->sechdrs[0].sh_addr = 0;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "",
            "\t\t/*",
            "\t\t * Mark all sections sh_addr with their address in the",
            "\t\t * temporary image.",
            "\t\t */",
            "\t\tshdr->sh_addr = (size_t)info->hdr + shdr->sh_offset;",
            "",
            "\t}",
            "",
            "\t/* Track but don't keep modinfo and version sections. */",
            "\tinfo->sechdrs[info->index.vers].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "\tinfo->sechdrs[info->index.info].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_chunked_from_user, check_modinfo_livepatch, check_modinfo_retpoline, copy_module_from_user, free_copy, rewrite_section_headers",
          "description": "实现分块从用户空间复制数据到内核缓冲区，检查模块livepatch属性，校验retpoline标志，复制模块元信息到内核，释放动态分配的模块数据，重写ELF节头地址以匹配实际内存布局",
          "similarity": 0.5662636756896973
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/main.c",
          "start_line": 96,
          "end_line": 202,
          "content": [
            "static void __mod_update_bounds(enum mod_mem_type type __maybe_unused, void *base,",
            "\t\t\t\tunsigned int size, struct mod_tree_root *tree)",
            "{",
            "\tunsigned long min = (unsigned long)base;",
            "\tunsigned long max = min + size;",
            "",
            "#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC",
            "\tif (mod_mem_type_is_core_data(type)) {",
            "\t\tif (min < tree->data_addr_min)",
            "\t\t\ttree->data_addr_min = min;",
            "\t\tif (max > tree->data_addr_max)",
            "\t\t\ttree->data_addr_max = max;",
            "\t\treturn;",
            "\t}",
            "#endif",
            "\tif (min < tree->addr_min)",
            "\t\ttree->addr_min = min;",
            "\tif (max > tree->addr_max)",
            "\t\ttree->addr_max = max;",
            "}",
            "static void mod_update_bounds(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size)",
            "\t\t\t__mod_update_bounds(type, mod_mem->base, mod_mem->size, &mod_tree);",
            "\t}",
            "}",
            "int register_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&module_notify_list, nb);",
            "}",
            "int unregister_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);",
            "}",
            "static inline int strong_try_module_get(struct module *mod)",
            "{",
            "\tBUG_ON(mod && mod->state == MODULE_STATE_UNFORMED);",
            "\tif (mod && mod->state == MODULE_STATE_COMING)",
            "\t\treturn -EBUSY;",
            "\tif (try_module_get(mod))",
            "\t\treturn 0;",
            "\telse",
            "\t\treturn -ENOENT;",
            "}",
            "static inline void add_taint_module(struct module *mod, unsigned flag,",
            "\t\t\t\t    enum lockdep_ok lockdep_ok)",
            "{",
            "\tadd_taint(flag, lockdep_ok);",
            "\tset_bit(flag, &mod->taints);",
            "}",
            "void __noreturn __module_put_and_kthread_exit(struct module *mod, long code)",
            "{",
            "\tmodule_put(mod);",
            "\tkthread_exit(code);",
            "}",
            "static unsigned int find_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\t/* Alloc bit cleared means \"ignore it.\" */",
            "\t\tif ((shdr->sh_flags & SHF_ALLOC)",
            "\t\t    && strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "static unsigned int find_any_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tif (strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "int cmp_name(const void *name, const void *sym)",
            "{",
            "\treturn strcmp(name, kernel_symbol_name(sym));",
            "}",
            "static bool find_exported_symbol_in_section(const struct symsearch *syms,",
            "\t\t\t\t\t    struct module *owner,",
            "\t\t\t\t\t    struct find_symbol_arg *fsa)",
            "{",
            "\tstruct kernel_symbol *sym;",
            "",
            "\tif (!fsa->gplok && syms->license == GPL_ONLY)",
            "\t\treturn false;",
            "",
            "\tsym = bsearch(fsa->name, syms->start, syms->stop - syms->start,",
            "\t\t\tsizeof(struct kernel_symbol), cmp_name);",
            "\tif (!sym)",
            "\t\treturn false;",
            "",
            "\tfsa->owner = owner;",
            "\tfsa->crc = symversion(syms->crcs, sym - syms->start);",
            "\tfsa->sym = sym;",
            "\tfsa->license = syms->license;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "__mod_update_bounds, mod_update_bounds, register_module_notifier, unregister_module_notifier, strong_try_module_get, add_taint_module, __module_put_and_kthread_exit, find_sec, find_any_sec, cmp_name, find_exported_symbol_in_section",
          "description": "实现模块内存边界更新逻辑、模块状态变更通知注册与注销接口，以及强引用获取检查函数，用于维护模块内存范围并控制模块生命周期事件。",
          "similarity": 0.530397355556488
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/module/main.c",
          "start_line": 1071,
          "end_line": 1218,
          "content": [
            "static int verify_namespace_is_imported(const struct load_info *info,",
            "\t\t\t\t\tconst struct kernel_symbol *sym,",
            "\t\t\t\t\tstruct module *mod)",
            "{",
            "\tconst char *namespace;",
            "\tchar *imported_namespace;",
            "",
            "\tnamespace = kernel_symbol_namespace(sym);",
            "\tif (namespace && namespace[0]) {",
            "\t\tfor_each_modinfo_entry(imported_namespace, info, \"import_ns\") {",
            "\t\t\tif (strcmp(namespace, imported_namespace) == 0)",
            "\t\t\t\treturn 0;",
            "\t\t}",
            "#ifdef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\tpr_warn(",
            "#else",
            "\t\tpr_err(",
            "#endif",
            "\t\t\t\"%s: module uses symbol (%s) from namespace %s, but does not import it.\\n\",",
            "\t\t\tmod->name, kernel_symbol_name(sym), namespace);",
            "#ifndef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\treturn -EINVAL;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool inherit_taint(struct module *mod, struct module *owner, const char *name)",
            "{",
            "\tif (!owner || !test_bit(TAINT_PROPRIETARY_MODULE, &owner->taints))",
            "\t\treturn true;",
            "",
            "\tif (mod->using_gplonly_symbols) {",
            "\t\tpr_err(\"%s: module using GPL-only symbols uses symbols %s from proprietary module %s.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (!test_bit(TAINT_PROPRIETARY_MODULE, &mod->taints)) {",
            "\t\tpr_warn(\"%s: module uses symbols %s from proprietary module %s, inheriting taint.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\tset_bit(TAINT_PROPRIETARY_MODULE, &mod->taints);",
            "\t}",
            "\treturn true;",
            "}",
            "void __weak module_memfree(void *module_region)",
            "{",
            "\t/*",
            "\t * This memory may be RO, and freeing RO memory in an interrupt is not",
            "\t * supported by vmalloc.",
            "\t */",
            "\tWARN_ON(in_interrupt());",
            "\tvfree(module_region);",
            "}",
            "void __weak module_arch_cleanup(struct module *mod)",
            "{",
            "}",
            "void __weak module_arch_freeing_init(struct module *mod)",
            "{",
            "}",
            "static bool mod_mem_use_vmalloc(enum mod_mem_type type)",
            "{",
            "\treturn IS_ENABLED(CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC) &&",
            "\t\tmod_mem_type_is_core_data(type);",
            "}",
            "static void module_memory_free(void *ptr, enum mod_mem_type type,",
            "\t\t\t       bool unload_codetags)",
            "{",
            "\tif (!unload_codetags && mod_mem_type_is_core_data(type))",
            "\t\treturn;",
            "",
            "\tif (mod_mem_use_vmalloc(type))",
            "\t\tvfree(ptr);",
            "\telse",
            "\t\tmodule_memfree(ptr);",
            "}",
            "static void free_mod_mem(struct module *mod, bool unload_codetags)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (type == MOD_DATA)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Free lock-classes; relies on the preceding sync_rcu(). */",
            "\t\tlockdep_free_key_range(mod_mem->base, mod_mem->size);",
            "\t\tif (mod_mem->size)",
            "\t\t\tmodule_memory_free(mod_mem->base, type,",
            "\t\t\t\t\t   unload_codetags);",
            "\t}",
            "",
            "\t/* MOD_DATA hosts mod, so free it at last */",
            "\tlockdep_free_key_range(mod->mem[MOD_DATA].base, mod->mem[MOD_DATA].size);",
            "\tmodule_memory_free(mod->mem[MOD_DATA].base, MOD_DATA, unload_codetags);",
            "}",
            "static void free_module(struct module *mod)",
            "{",
            "\tbool unload_codetags;",
            "",
            "\ttrace_module_free(mod);",
            "",
            "\tunload_codetags = codetag_unload_module(mod);",
            "\tif (!unload_codetags)",
            "\t\tpr_warn(\"%s: memory allocation(s) from the module still alive, cannot unload cleanly\\n\",",
            "\t\t\tmod->name);",
            "",
            "\tmod_sysfs_teardown(mod);",
            "",
            "\t/*",
            "\t * We leave it in list to prevent duplicate loads, but make sure",
            "\t * that noone uses it while it's being deconstructed.",
            "\t */",
            "\tmutex_lock(&module_mutex);",
            "\tmod->state = MODULE_STATE_UNFORMED;",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* Arch-specific cleanup. */",
            "\tmodule_arch_cleanup(mod);",
            "",
            "\t/* Module unload stuff */",
            "\tmodule_unload_free(mod);",
            "",
            "\t/* Free any allocated parameters. */",
            "\tdestroy_params(mod->kp, mod->num_kp);",
            "",
            "\tif (is_livepatch_module(mod))",
            "\t\tfree_module_elf(mod);",
            "",
            "\t/* Now we can delete it from the lists */",
            "\tmutex_lock(&module_mutex);",
            "\t/* Unlink carefully: kallsyms could be walking list. */",
            "\tlist_del_rcu(&mod->list);",
            "\tmod_tree_remove(mod);",
            "\t/* Remove this module from bug list, this uses list_del_rcu */",
            "\tmodule_bug_cleanup(mod);",
            "\t/* Wait for RCU-sched synchronizing before releasing mod->list and buglist. */",
            "\tsynchronize_rcu();",
            "\tif (try_add_tainted_module(mod))",
            "\t\tpr_err(\"%s: adding tainted module to the unloaded tainted modules list failed.\\n\",",
            "\t\t       mod->name);",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* This may be empty, but that's OK */",
            "\tmodule_arch_freeing_init(mod);",
            "\tkfree(mod->args);",
            "\tpercpu_modfree(mod);",
            "",
            "\tfree_mod_mem(mod, unload_codetags);",
            "}"
          ],
          "function_name": "verify_namespace_is_imported, inherit_taint, module_memfree, module_arch_cleanup, module_arch_freeing_init, mod_mem_use_vmalloc, module_memory_free, free_mod_mem, free_module",
          "description": "实现模块符号命名空间验证(verify_namespace_is_imported)、污点继承逻辑(herit_taint)、内存释放(module_memory_free/free_mod_mem)及架构特定清理(module_arch_cleanup/module_arch_freeing_init)，包含弱符号声明供架构扩展。",
          "similarity": 0.5298987030982971
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/main.c",
          "start_line": 303,
          "end_line": 412,
          "content": [
            "bool find_symbol(struct find_symbol_arg *fsa)",
            "{",
            "\tstatic const struct symsearch arr[] = {",
            "\t\t{ __start___ksymtab, __stop___ksymtab, __start___kcrctab,",
            "\t\t  NOT_GPL_ONLY },",
            "\t\t{ __start___ksymtab_gpl, __stop___ksymtab_gpl,",
            "\t\t  __start___kcrctab_gpl,",
            "\t\t  GPL_ONLY },",
            "\t};",
            "\tstruct module *mod;",
            "\tunsigned int i;",
            "",
            "\tmodule_assert_mutex_or_preempt();",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(arr); i++)",
            "\t\tif (find_exported_symbol_in_section(&arr[i], NULL, fsa))",
            "\t\t\treturn true;",
            "",
            "\tlist_for_each_entry_rcu(mod, &modules, list,",
            "\t\t\t\tlockdep_is_held(&module_mutex)) {",
            "\t\tstruct symsearch arr[] = {",
            "\t\t\t{ mod->syms, mod->syms + mod->num_syms, mod->crcs,",
            "\t\t\t  NOT_GPL_ONLY },",
            "\t\t\t{ mod->gpl_syms, mod->gpl_syms + mod->num_gpl_syms,",
            "\t\t\t  mod->gpl_crcs,",
            "\t\t\t  GPL_ONLY },",
            "\t\t};",
            "",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (i = 0; i < ARRAY_SIZE(arr); i++)",
            "\t\t\tif (find_exported_symbol_in_section(&arr[i], mod, fsa))",
            "\t\t\t\treturn true;",
            "\t}",
            "",
            "\tpr_debug(\"Failed to find symbol %s\\n\", fsa->name);",
            "\treturn false;",
            "}",
            "static int percpu_modalloc(struct module *mod, struct load_info *info)",
            "{",
            "\tElf_Shdr *pcpusec = &info->sechdrs[info->index.pcpu];",
            "\tunsigned long align = pcpusec->sh_addralign;",
            "",
            "\tif (!pcpusec->sh_size)",
            "\t\treturn 0;",
            "",
            "\tif (align > PAGE_SIZE) {",
            "\t\tpr_warn(\"%s: per-cpu alignment %li > %li\\n\",",
            "\t\t\tmod->name, align, PAGE_SIZE);",
            "\t\talign = PAGE_SIZE;",
            "\t}",
            "",
            "\tmod->percpu = __alloc_reserved_percpu(pcpusec->sh_size, align);",
            "\tif (!mod->percpu) {",
            "\t\tpr_warn(\"%s: Could not allocate %lu bytes percpu data\\n\",",
            "\t\t\tmod->name, (unsigned long)pcpusec->sh_size);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tmod->percpu_size = pcpusec->sh_size;",
            "\treturn 0;",
            "}",
            "static void percpu_modfree(struct module *mod)",
            "{",
            "\tfree_percpu(mod->percpu);",
            "}",
            "static unsigned int find_pcpusec(struct load_info *info)",
            "{",
            "\treturn find_sec(info, \".data..percpu\");",
            "}",
            "static void percpu_modcopy(struct module *mod,",
            "\t\t\t   const void *from, unsigned long size)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tmemcpy(per_cpu_ptr(mod->percpu, cpu), from, size);",
            "}",
            "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)",
            "{",
            "\tstruct module *mod;",
            "\tunsigned int cpu;",
            "",
            "\tpreempt_disable();",
            "",
            "\tlist_for_each_entry_rcu(mod, &modules, list) {",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "\t\tif (!mod->percpu_size)",
            "\t\t\tcontinue;",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tvoid *start = per_cpu_ptr(mod->percpu, cpu);",
            "\t\t\tvoid *va = (void *)addr;",
            "",
            "\t\t\tif (va >= start && va < start + mod->percpu_size) {",
            "\t\t\t\tif (can_addr) {",
            "\t\t\t\t\t*can_addr = (unsigned long) (va - start);",
            "\t\t\t\t\t*can_addr += (unsigned long)",
            "\t\t\t\t\t\tper_cpu_ptr(mod->percpu,",
            "\t\t\t\t\t\t\t    get_boot_cpu_id());",
            "\t\t\t\t}",
            "\t\t\t\tpreempt_enable();",
            "\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tpreempt_enable();",
            "\treturn false;",
            "}"
          ],
          "function_name": "find_symbol, percpu_modalloc, percpu_modfree, find_pcpusec, percpu_modcopy, __is_module_percpu_address",
          "description": "提供符号查找核心实现，通过遍历内核符号表和模块符号表定位目标符号；实现Per-CPU数据区的动态分配、复制和释放机制，确保多CPU环境下模块数据的正确访问。",
          "similarity": 0.5199881792068481
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/module/main.c",
          "start_line": 2256,
          "end_line": 2359,
          "content": [
            "static int move_module(struct module *mod, struct load_info *info)",
            "{",
            "\tint i;",
            "\tvoid *ptr;",
            "\tenum mod_mem_type t = 0;",
            "\tint ret = -ENOMEM;",
            "",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tif (!mod->mem[type].size) {",
            "\t\t\tmod->mem[type].base = NULL;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tmod->mem[type].size = PAGE_ALIGN(mod->mem[type].size);",
            "\t\tptr = module_memory_alloc(mod->mem[type].size, type);",
            "\t\t/*",
            "                 * The pointer to these blocks of memory are stored on the module",
            "                 * structure and we keep that around so long as the module is",
            "                 * around. We only free that memory when we unload the module.",
            "                 * Just mark them as not being a leak then. The .init* ELF",
            "                 * sections *do* get freed after boot so we *could* treat them",
            "                 * slightly differently with kmemleak_ignore() and only grey",
            "                 * them out as they work as typical memory allocations which",
            "                 * *do* eventually get freed, but let's just keep things simple",
            "                 * and avoid *any* false positives.",
            "\t\t */",
            "\t\tkmemleak_not_leak(ptr);",
            "\t\tif (!ptr) {",
            "\t\t\tt = type;",
            "\t\t\tgoto out_enomem;",
            "\t\t}",
            "\t\tmemset(ptr, 0, mod->mem[type].size);",
            "\t\tmod->mem[type].base = ptr;",
            "\t}",
            "",
            "\t/* Transfer each section which specifies SHF_ALLOC */",
            "\tpr_debug(\"Final section addresses for %s:\\n\", mod->name);",
            "\tfor (i = 0; i < info->hdr->e_shnum; i++) {",
            "\t\tvoid *dest;",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tenum mod_mem_type type = shdr->sh_entsize >> SH_ENTSIZE_TYPE_SHIFT;",
            "",
            "\t\tif (!(shdr->sh_flags & SHF_ALLOC))",
            "\t\t\tcontinue;",
            "",
            "\t\tdest = mod->mem[type].base + (shdr->sh_entsize & SH_ENTSIZE_OFFSET_MASK);",
            "",
            "\t\tif (shdr->sh_type != SHT_NOBITS) {",
            "\t\t\t/*",
            "\t\t\t * Our ELF checker already validated this, but let's",
            "\t\t\t * be pedantic and make the goal clearer. We actually",
            "\t\t\t * end up copying over all modifications made to the",
            "\t\t\t * userspace copy of the entire struct module.",
            "\t\t\t */",
            "\t\t\tif (i == info->index.mod &&",
            "\t\t\t   (WARN_ON_ONCE(shdr->sh_size != sizeof(struct module)))) {",
            "\t\t\t\tret = -ENOEXEC;",
            "\t\t\t\tgoto out_enomem;",
            "\t\t\t}",
            "\t\t\tmemcpy(dest, (void *)shdr->sh_addr, shdr->sh_size);",
            "\t\t}",
            "\t\t/*",
            "\t\t * Update the userspace copy's ELF section address to point to",
            "\t\t * our newly allocated memory as a pure convenience so that",
            "\t\t * users of info can keep taking advantage and using the newly",
            "\t\t * minted official memory area.",
            "\t\t */",
            "\t\tshdr->sh_addr = (unsigned long)dest;",
            "\t\tpr_debug(\"\\t0x%lx 0x%.8lx %s\\n\", (long)shdr->sh_addr,",
            "\t\t\t (long)shdr->sh_size, info->secstrings + shdr->sh_name);",
            "\t}",
            "",
            "\treturn 0;",
            "out_enomem:",
            "\tfor (t--; t >= 0; t--)",
            "\t\tmodule_memory_free(mod->mem[t].base, t, true);",
            "\treturn ret;",
            "}",
            "static int check_export_symbol_versions(struct module *mod)",
            "{",
            "#ifdef CONFIG_MODVERSIONS",
            "\tif ((mod->num_syms && !mod->crcs) ||",
            "\t    (mod->num_gpl_syms && !mod->gpl_crcs)) {",
            "\t\treturn try_to_force_load(mod,",
            "\t\t\t\t\t \"no versions for exported symbols\");",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}",
            "void flush_module_icache(const struct module *mod)",
            "{",
            "\t/*",
            "\t * Flush the instruction cache, since we've played with text.",
            "\t * Do it before processing of module parameters, so the module",
            "\t * can provide parameter accessor functions of its own.",
            "\t */",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tconst struct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size) {",
            "\t\t\tflush_icache_range((unsigned long)mod_mem->base,",
            "\t\t\t\t\t   (unsigned long)mod_mem->base + mod_mem->size);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "move_module, check_export_symbol_versions, flush_module_icache",
          "description": "为模块各内存类型分配物理页框，将ELF节区内容拷贝至对应内存区域，检查导出符号版本一致性，刷新指令高速缓存以确保新代码可见",
          "similarity": 0.5193657875061035
        }
      ]
    },
    {
      "source_file": "kernel/module/procfs.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:05:15\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\procfs.c`\n\n---\n\n# module/procfs.c 技术文档\n\n## 1. 文件概述\n\n`module/procfs.c` 是 Linux 内核中用于在 `/proc/modules` 文件中导出已加载内核模块信息的实现文件。该文件通过 procfs 接口向用户空间提供模块名称、大小、引用计数、依赖关系、加载状态、内存地址以及污染标志等关键信息，是内核模块管理与调试的重要组成部分。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `print_unload_info(struct seq_file *m, struct module *mod)`  \n  根据是否启用 `CONFIG_MODULE_UNLOAD` 配置，输出模块的引用计数和依赖模块列表，或占位符。\n\n- `m_start(struct seq_file *m, loff_t *pos)`  \n  seq_file 迭代器的起始函数，获取模块列表的互斥锁并定位起始位置。\n\n- `m_next(struct seq_file *m, void *p, loff_t *pos)`  \n  seq_file 迭代器的下一个元素函数。\n\n- `m_stop(struct seq_file *m, void *p)`  \n  seq_file 迭代器的结束函数，释放模块列表互斥锁。\n\n- `module_total_size(struct module *mod)`  \n  计算模块所有内存段（如代码、只读数据、可写数据等）的总大小。\n\n- `m_show(struct seq_file *m, void *p)`  \n  格式化输出单个模块的详细信息到 seq_file。\n\n- `modules_open(struct inode *inode, struct file *file)`  \n  打开 `/proc/modules` 文件时的回调，初始化 seq_file 并根据权限决定是否隐藏内核地址。\n\n- `proc_modules_init(void)`  \n  模块初始化函数，注册 `/proc/modules` 条目。\n\n### 主要数据结构\n\n- `modules_op`：`seq_operations` 结构体，定义了遍历模块列表的迭代器操作。\n- `modules_proc_ops`：`proc_ops` 结构体，定义了 `/proc/modules` 文件的文件操作接口。\n\n## 3. 关键实现\n\n### 模块信息格式化输出\n`m_show()` 函数按照固定格式输出每行模块信息：\n```\n<name> <total_size> <refcount> <deps>, <state> <address> [taint_flags]\n```\n- **引用计数与依赖**：在启用 `CONFIG_MODULE_UNLOAD` 时，遍历 `mod->source_list` 输出依赖该模块的其他模块；若模块无 `exit` 函数，则标记为 `[permanent]`。\n- **地址隐藏机制**：通过 `kallsyms_show_value()` 判断当前凭证是否有权查看内核地址。若无权限，`seq_file->private` 被设为非 NULL（值为 `(void *)8ul`），`m_show()` 中据此将地址输出为 `0x0`（实际由 `%px` 在私有模式下自动处理为 `0`）。\n- **模块状态**：根据 `mod->state` 显示 “Loading”、“Unloading” 或 “Live”。\n\n### 内存大小计算\n`module_total_size()` 遍历所有 `mod_mem_type` 类型（如 `MOD_TEXT`, `MOD_RODATA`, `MOD_DATA` 等），累加各段内存大小，反映模块实际占用的内核内存总量。\n\n### 安全与权限控制\n复用 `/proc/kallsyms` 的地址可见性逻辑，确保只有具备 `CAP_SYSLOG` 权限的进程才能查看模块的内核内存地址，防止信息泄露。\n\n### 模块状态过滤\n自动跳过 `MODULE_STATE_UNFORMED` 状态的模块（尚未完全初始化），避免输出不完整或无效信息。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：模块核心数据结构和 API。\n  - `<linux/kallsyms.h>`：提供 `kallsyms_show_value()` 用于地址可见性判断。\n  - `<linux/proc_fs.h>` 和 `<linux/seq_file.h>`：procfs 和 seq_file 接口。\n  - `\"internal.h\"`：模块子系统内部头文件，包含 `module_mem_type` 等定义。\n\n- **内核配置依赖**：\n  - `CONFIG_MODULE_UNLOAD`：决定是否支持模块卸载及引用计数/依赖信息输出。\n\n- **全局数据结构**：\n  - `modules`：全局模块链表（定义于 `kernel/module/main.c`）。\n  - `module_mutex`：保护模块链表的全局互斥锁。\n\n## 5. 使用场景\n\n- **系统监控与调试**：用户通过 `cat /proc/modules` 查看当前加载的模块及其状态，用于诊断模块加载问题或内存占用。\n- **依赖分析**：工具（如 `lsmod`）解析依赖字段，构建模块依赖图，辅助安全审计或卸载顺序决策。\n- **性能分析**：oprofile 等性能工具利用模块地址信息进行符号解析和性能采样。\n- **安全审计**：通过模块污染标志（taints）判断系统是否加载了非官方或专有模块，评估系统可信度。\n- **自动化脚本**：系统服务或安装程序通过解析 `/proc/modules` 内容判断特定模块是否已加载。",
      "similarity": 0.5914161205291748,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/procfs.c",
          "start_line": 16,
          "end_line": 104,
          "content": [
            "static inline void print_unload_info(struct seq_file *m, struct module *mod)",
            "{",
            "\tstruct module_use *use;",
            "\tint printed_something = 0;",
            "",
            "\tseq_printf(m, \" %i \", module_refcount(mod));",
            "",
            "\t/*",
            "\t * Always include a trailing , so userspace can differentiate",
            "\t * between this and the old multi-field proc format.",
            "\t */",
            "\tlist_for_each_entry(use, &mod->source_list, source_list) {",
            "\t\tprinted_something = 1;",
            "\t\tseq_printf(m, \"%s,\", use->source->name);",
            "\t}",
            "",
            "\tif (mod->init && !mod->exit) {",
            "\t\tprinted_something = 1;",
            "\t\tseq_puts(m, \"[permanent],\");",
            "\t}",
            "",
            "\tif (!printed_something)",
            "\t\tseq_puts(m, \"-\");",
            "}",
            "static inline void print_unload_info(struct seq_file *m, struct module *mod)",
            "{",
            "\t/* We don't know the usage count, or what modules are using. */",
            "\tseq_puts(m, \" - -\");",
            "}",
            "static void m_stop(struct seq_file *m, void *p)",
            "{",
            "\tmutex_unlock(&module_mutex);",
            "}",
            "static unsigned int module_total_size(struct module *mod)",
            "{",
            "\tint size = 0;",
            "",
            "\tfor_each_mod_mem_type(type)",
            "\t\tsize += mod->mem[type].size;",
            "\treturn size;",
            "}",
            "static int m_show(struct seq_file *m, void *p)",
            "{",
            "\tstruct module *mod = list_entry(p, struct module, list);",
            "\tchar buf[MODULE_FLAGS_BUF_SIZE];",
            "\tvoid *value;",
            "\tunsigned int size;",
            "",
            "\t/* We always ignore unformed modules. */",
            "\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\treturn 0;",
            "",
            "\tsize = module_total_size(mod);",
            "\tseq_printf(m, \"%s %u\", mod->name, size);",
            "\tprint_unload_info(m, mod);",
            "",
            "\t/* Informative for users. */",
            "\tseq_printf(m, \" %s\",",
            "\t\t   mod->state == MODULE_STATE_GOING ? \"Unloading\" :",
            "\t\t   mod->state == MODULE_STATE_COMING ? \"Loading\" :",
            "\t\t   \"Live\");",
            "\t/* Used by oprofile and other similar tools. */",
            "\tvalue = m->private ? NULL : mod->mem[MOD_TEXT].base;",
            "\tseq_printf(m, \" 0x%px\", value);",
            "",
            "\t/* Taints info */",
            "\tif (mod->taints)",
            "\t\tseq_printf(m, \" %s\", module_flags(mod, buf, true));",
            "",
            "\tseq_puts(m, \"\\n\");",
            "\treturn 0;",
            "}",
            "static int modules_open(struct inode *inode, struct file *file)",
            "{",
            "\tint err = seq_open(file, &modules_op);",
            "",
            "\tif (!err) {",
            "\t\tstruct seq_file *m = file->private_data;",
            "",
            "\t\tm->private = kallsyms_show_value(file->f_cred) ? NULL : (void *)8ul;",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "static int __init proc_modules_init(void)",
            "{",
            "\tproc_create(\"modules\", 0, NULL, &modules_proc_ops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "print_unload_info, print_unload_info, m_stop, module_total_size, m_show, modules_open, proc_modules_init",
          "description": "该代码块实现 /proc/modules 接口的模块信息展示功能，主要处理模块状态、依赖关系及内存统计。  \nprint_unload_info 用于输出模块引用计数及使用者名称（存在两个重名函数，上下文不完整），m_show 格式化模块详细信息至 seq_file，module_total_size 计算模块总内存占用。  \nproc_modules_init 注册 proc 文件节点，通过互斥锁保护和内存遍历实现模块状态动态追踪与展示。",
          "similarity": 0.500961422920227
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/procfs.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module proc support",
            " *",
            " * Copyright (C) 2008 Alexey Dobriyan",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"internal.h\"",
            "",
            "#ifdef CONFIG_MODULE_UNLOAD"
          ],
          "function_name": null,
          "description": "该代码片段属于模块proc文件系统支持的一部分，用于在启用CONFIG_MODULE_UNLOAD配置选项时提供模块卸载相关的proc接口。由于上下文不完整，仅能确认其作为模块卸载功能与proc文件系统交互的入口点，具体实现需结合后续代码分析。",
          "similarity": 0.4209715723991394
        }
      ]
    },
    {
      "source_file": "mm/mm_init.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:50:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mm_init.c`\n\n---\n\n# mm_init.c 技术文档\n\n## 1. 文件概述\n\n`mm_init.c` 是 Linux 内核内存管理子系统（Memory Management, MM）中的一个初始化和调试辅助文件。其主要作用包括：\n\n- 提供内存初始化过程的验证与调试功能（在 `CONFIG_DEBUG_MEMORY_INIT` 启用时）\n- 初始化内存相关的全局参数和 sysfs 接口\n- 解析内核启动命令行参数（如 `kernelcore` 和 `movablecore`），用于控制不可移动与可移动内存区域的分配策略\n- 在 SMP 系统中动态计算 `vm_committed_as` 的批处理阈值，以优化内存提交统计的性能\n\n该文件不直接参与页分配或虚拟内存管理的核心逻辑，而是为内存子系统的正确性验证、配置和可观测性提供支持。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `mminit_verify_zonelist()` | 验证并打印每个 NUMA 节点的 zonelist 结构，用于调试内存区域组织 |\n| `mminit_verify_pageflags_layout()` | 验证 `struct page` 中用于存储节点、区域、节区等元数据的位域布局是否无重叠且对齐正确 |\n| `set_mminit_loglevel()` | 解析 `mminit_loglevel` 内核参数，设置内存初始化调试日志级别 |\n| `mm_compute_batch()` | 根据系统内存总量和 CPU 数量，计算 `vm_committed_as` per-CPU 计数器的批处理阈值 |\n| `mm_compute_batch_notifier()` | 内存热插拔事件回调，重新计算 `vm_committed_as` 批处理值 |\n| `mm_sysfs_init()` | 创建 `/sys/kernel/mm` sysfs 目录，用于暴露内存子系统信息 |\n| `cmdline_parse_core()` | 辅助函数，解析带百分比或字节单位的内存大小参数 |\n| `cmdline_parse_kernelcore()` / `cmdline_parse_movablecore()` | 解析 `kernelcore=` 和 `movablecore=` 内核启动参数 |\n\n### 主要全局变量\n\n| 变量名 | 类型/说明 |\n|--------|---------|\n| `mminit_loglevel` | 调试日志级别（仅当 `CONFIG_DEBUG_MEMORY_INIT` 启用） |\n| `mm_kobj` | 指向 `/sys/kernel/mm` 的 kobject 指针 |\n| `vm_committed_as_batch` | `vm_committed_as` per-CPU 计数器的批处理阈值（SMP） |\n| `required_kernelcore` / `required_kernelcore_percent` | 用户指定的不可移动内存需求（页数或百分比） |\n| `required_movablecore` / `required_movablecore_percent` | 用户指定的可移动内存需求（页数或百分比） |\n| `mirrored_kernelcore` | 是否启用镜像式 kernelcore 布局 |\n| `arch_zone_lowest_possible_pfn[]` / `arch_zone_highest_possible_pfn[]` | 架构定义的各内存区域（ZONE）的 PFN 范围 |\n| `zone_movable_pfn[]` | 各 NUMA 节点上 ZONE_MOVABLE 的起始 PFN |\n| `deferred_struct_pages` | 标记是否延迟初始化 struct page 实例 |\n\n## 3. 关键实现\n\n### 3.1 内存初始化调试（`CONFIG_DEBUG_MEMORY_INIT`）\n\n- **Zonelist 验证**：`mminit_verify_zonelist()` 遍历所有在线 NUMA 节点，打印其“通用”（general）和“本节点优先”（thisnode）两种 zonelist 的组成，帮助开发者确认内存区域的 fallback 顺序是否符合预期。\n- **Page Flags 布局验证**：`mminit_verify_pageflags_layout()` 检查 `struct page` 中用于编码物理位置（section/node/zone）的位域是否：\n  - 总宽度不超过 `BITS_PER_LONG`\n  - 各字段偏移（`_PGSHIFT`）与宽度一致\n  - 位掩码无重叠（通过 `or_mask == add_mask` 验证）\n\n### 3.2 内存区域划分策略\n\n- 通过 `kernelcore=` 和 `movablecore=` 参数，用户可显式指定系统中用于**不可移动分配**（如内核数据结构）和**可移动分配**（如用户页、可迁移 slab）的内存大小。\n- 支持 `kernelcore=mirror` 模式，在支持内存镜像的平台上启用特殊布局。\n- 参数值可为绝对字节数（如 `512M`）或总内存百分比（如 `40%`）。\n\n### 3.3 `vm_committed_as` 批处理优化（SMP）\n\n- `vm_committed_as` 是一个 per-CPU 计数器，跟踪已提交虚拟内存总量。\n- 为减少原子操作开销，当本地计数器变化超过 `vm_committed_as_batch` 时才同步到全局值。\n- `mm_compute_batch()` 根据 overcommit 策略动态调整 batch 大小：\n  - `OVERCOMMIT_NEVER`：batch = 总内存 / CPU数 / 256（约 0.4%）\n  - 其他策略：batch = 总内存 / CPU数 / 4（25%）\n- 注册内存热插拔通知器，确保内存容量变化后重新计算 batch 值。\n\n### 3.4 Sysfs 接口初始化\n\n- `mm_sysfs_init()` 在内核早期创建 `/sys/kernel/mm` 目录，作为内存子系统其他模块（如 compaction、numa、transparent_hugepage 等）注册 sysfs 属性的基础。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memory.h>`、`<linux/memblock.h>`：内存块和热插拔管理\n  - `<linux/page-isolation.h>`、`<linux/cma.h>`：连续内存分配和页面隔离\n  - `\"internal.h\"`、`\"slab.h\"`：MM 子系统内部接口\n  - `<asm/setup.h>`：架构相关内存布局信息\n- **配置依赖**：\n  - `CONFIG_DEBUG_MEMORY_INIT`：启用调试验证功能\n  - `CONFIG_SMP`：启用 `vm_committed_as_batch` 优化\n  - `CONFIG_SYSFS`：支持 mm sysfs 目录创建\n- **被依赖模块**：\n  - 内存初始化流程（`mm_init()` in `init/main.c`）\n  - 页面分配器（`page_alloc.c`）使用 `zone_movable_pfn` 等变量\n  - 内存热插拔子系统调用 batch 重计算回调\n\n## 5. 使用场景\n\n- **内核开发与调试**：开发者启用 `CONFIG_DEBUG_MEMORY_INIT` 并设置 `mminit_loglevel`，可在启动时验证内存拓扑结构和 page 结构体布局的正确性。\n- **系统部署调优**：管理员通过 `kernelcore=` 或 `movablecore=` 参数，强制划分不可移动/可移动内存区域，以优化透明大页（THP）或避免内存碎片。\n- **高可靠性系统**：使用 `kernelcore=mirror` 在支持的硬件上启用内存镜像，提升容错能力。\n- **大规模 SMP 系统**：自动调整 `vm_committed_as_batch` 减少锁竞争，提升多进程内存密集型应用的性能。\n- **运行时监控**：`/sys/kernel/mm` 为用户空间工具（如 `numastat`、`cma` 调试接口）提供统一入口点。",
      "similarity": 0.5881034731864929,
      "chunks": [
        {
          "chunk_id": 11,
          "file_path": "mm/mm_init.c",
          "start_line": 1637,
          "end_line": 1738,
          "content": [
            "static void __init alloc_node_mem_map(struct pglist_data *pgdat)",
            "{",
            "\tunsigned long start, offset, size, end;",
            "\tstruct page *map;",
            "",
            "\t/* Skip empty nodes */",
            "\tif (!pgdat->node_spanned_pages)",
            "\t\treturn;",
            "",
            "\tstart = pgdat->node_start_pfn & ~(MAX_ORDER_NR_PAGES - 1);",
            "\toffset = pgdat->node_start_pfn - start;",
            "\t/*",
            "\t\t * The zone's endpoints aren't required to be MAX_PAGE_ORDER",
            "\t * aligned but the node_mem_map endpoints must be in order",
            "\t * for the buddy allocator to function correctly.",
            "\t */",
            "\tend = ALIGN(pgdat_end_pfn(pgdat), MAX_ORDER_NR_PAGES);",
            "\tsize =  (end - start) * sizeof(struct page);",
            "\tmap = memmap_alloc(size, SMP_CACHE_BYTES, MEMBLOCK_LOW_LIMIT,",
            "\t\t\t   pgdat->node_id, false);",
            "\tif (!map)",
            "\t\tpanic(\"Failed to allocate %ld bytes for node %d memory map\\n\",",
            "\t\t      size, pgdat->node_id);",
            "\tpgdat->node_mem_map = map + offset;",
            "\tpr_debug(\"%s: node %d, pgdat %08lx, node_mem_map %08lx\\n\",",
            "\t\t __func__, pgdat->node_id, (unsigned long)pgdat,",
            "\t\t (unsigned long)pgdat->node_mem_map);",
            "#ifndef CONFIG_NUMA",
            "\t/* the global mem_map is just set as node 0's */",
            "\tif (pgdat == NODE_DATA(0)) {",
            "\t\tmem_map = NODE_DATA(0)->node_mem_map;",
            "\t\tif (page_to_pfn(mem_map) != pgdat->node_start_pfn)",
            "\t\t\tmem_map -= offset;",
            "\t}",
            "#endif",
            "}",
            "static inline void alloc_node_mem_map(struct pglist_data *pgdat) { }",
            "void __init get_pfn_range_for_nid(unsigned int nid,",
            "\t\t\tunsigned long *start_pfn, unsigned long *end_pfn)",
            "{",
            "\tunsigned long this_start_pfn, this_end_pfn;",
            "\tint i;",
            "",
            "\t*start_pfn = -1UL;",
            "\t*end_pfn = 0;",
            "",
            "\tfor_each_mem_pfn_range(i, nid, &this_start_pfn, &this_end_pfn, NULL) {",
            "\t\t*start_pfn = min(*start_pfn, this_start_pfn);",
            "\t\t*end_pfn = max(*end_pfn, this_end_pfn);",
            "\t}",
            "",
            "\tif (*start_pfn == -1UL)",
            "\t\t*start_pfn = 0;",
            "}",
            "static void __init free_area_init_node(int nid)",
            "{",
            "\tpg_data_t *pgdat = NODE_DATA(nid);",
            "\tunsigned long start_pfn = 0;",
            "\tunsigned long end_pfn = 0;",
            "",
            "\t/* pg_data_t should be reset to zero when it's allocated */",
            "\tWARN_ON(pgdat->nr_zones || pgdat->kswapd_highest_zoneidx);",
            "",
            "\tget_pfn_range_for_nid(nid, &start_pfn, &end_pfn);",
            "",
            "\tpgdat->node_id = nid;",
            "\tpgdat->node_start_pfn = start_pfn;",
            "\tpgdat->per_cpu_nodestats = NULL;",
            "",
            "\tif (start_pfn != end_pfn) {",
            "\t\tpr_info(\"Initmem setup node %d [mem %#018Lx-%#018Lx]\\n\", nid,",
            "\t\t\t(u64)start_pfn << PAGE_SHIFT,",
            "\t\t\tend_pfn ? ((u64)end_pfn << PAGE_SHIFT) - 1 : 0);",
            "",
            "\t\tcalculate_node_totalpages(pgdat, start_pfn, end_pfn);",
            "\t} else {",
            "\t\tpr_info(\"Initmem setup node %d as memoryless\\n\", nid);",
            "",
            "\t\treset_memoryless_node_totalpages(pgdat);",
            "\t}",
            "",
            "\talloc_node_mem_map(pgdat);",
            "\tpgdat_set_deferred_range(pgdat);",
            "",
            "\tfree_area_init_core(pgdat);",
            "\tlru_gen_init_pgdat(pgdat);",
            "}",
            "static void __init check_for_memory(pg_data_t *pgdat)",
            "{",
            "\tenum zone_type zone_type;",
            "",
            "\tfor (zone_type = 0; zone_type <= ZONE_MOVABLE - 1; zone_type++) {",
            "\t\tstruct zone *zone = &pgdat->node_zones[zone_type];",
            "\t\tif (populated_zone(zone)) {",
            "\t\t\tif (IS_ENABLED(CONFIG_HIGHMEM))",
            "\t\t\t\tnode_set_state(pgdat->node_id, N_HIGH_MEMORY);",
            "\t\t\tif (zone_type <= ZONE_NORMAL)",
            "\t\t\t\tnode_set_state(pgdat->node_id, N_NORMAL_MEMORY);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "alloc_node_mem_map, alloc_node_mem_map, get_pfn_range_for_nid, free_area_init_node, check_for_memory",
          "description": "该代码段主要负责Linux内核中内存节点（NUMA）的初始化工作。  \n`alloc_node_mem_map`用于为每个节点分配连续的页表映射缓冲区（node_mem_map），并通过`get_pfn_range_for_nid`获取节点的物理页面范围，`free_area_init_node`据此初始化区管理信息并设置节点属性，而`check_for_memory`检测内存区域类型以标记高/正常内存状态。",
          "similarity": 0.5319756269454956
        },
        {
          "chunk_id": 2,
          "file_path": "mm/mm_init.c",
          "start_line": 151,
          "end_line": 259,
          "content": [
            "static __init int set_mminit_loglevel(char *str)",
            "{",
            "\tget_option(&str, &mminit_loglevel);",
            "\treturn 0;",
            "}",
            "void mm_compute_batch(int overcommit_policy)",
            "{",
            "\tu64 memsized_batch;",
            "\ts32 nr = num_present_cpus();",
            "\ts32 batch = max_t(s32, nr*2, 32);",
            "\tunsigned long ram_pages = totalram_pages();",
            "",
            "\t/*",
            "\t * For policy OVERCOMMIT_NEVER, set batch size to 0.4% of",
            "\t * (total memory/#cpus), and lift it to 25% for other policies",
            "\t * to easy the possible lock contention for percpu_counter",
            "\t * vm_committed_as, while the max limit is INT_MAX",
            "\t */",
            "\tif (overcommit_policy == OVERCOMMIT_NEVER)",
            "\t\tmemsized_batch = min_t(u64, ram_pages/nr/256, INT_MAX);",
            "\telse",
            "\t\tmemsized_batch = min_t(u64, ram_pages/nr/4, INT_MAX);",
            "",
            "\tvm_committed_as_batch = max_t(s32, memsized_batch, batch);",
            "}",
            "static int __meminit mm_compute_batch_notifier(struct notifier_block *self,",
            "\t\t\t\t\tunsigned long action, void *arg)",
            "{",
            "\tswitch (action) {",
            "\tcase MEM_ONLINE:",
            "\tcase MEM_OFFLINE:",
            "\t\tmm_compute_batch(sysctl_overcommit_memory);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "\treturn NOTIFY_OK;",
            "}",
            "static int __init mm_compute_batch_init(void)",
            "{",
            "\tmm_compute_batch(sysctl_overcommit_memory);",
            "\thotplug_memory_notifier(mm_compute_batch_notifier, MM_COMPUTE_BATCH_PRI);",
            "\treturn 0;",
            "}",
            "static int __init mm_sysfs_init(void)",
            "{",
            "\tmm_kobj = kobject_create_and_add(\"mm\", kernel_kobj);",
            "\tif (!mm_kobj)",
            "\t\treturn -ENOMEM;",
            "",
            "\treturn 0;",
            "}",
            "static int __init cmdline_parse_core(char *p, unsigned long *core,",
            "\t\t\t\t     unsigned long *percent)",
            "{",
            "\tunsigned long long coremem;",
            "\tchar *endptr;",
            "",
            "\tif (!p)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Value may be a percentage of total memory, otherwise bytes */",
            "\tcoremem = simple_strtoull(p, &endptr, 0);",
            "\tif (*endptr == '%') {",
            "\t\t/* Paranoid check for percent values greater than 100 */",
            "\t\tWARN_ON(coremem > 100);",
            "",
            "\t\t*percent = coremem;",
            "\t} else {",
            "\t\tcoremem = memparse(p, &p);",
            "\t\t/* Paranoid check that UL is enough for the coremem value */",
            "\t\tWARN_ON((coremem >> PAGE_SHIFT) > ULONG_MAX);",
            "",
            "\t\t*core = coremem >> PAGE_SHIFT;",
            "\t\t*percent = 0UL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int __init cmdline_parse_kernelcore(char *p)",
            "{",
            "\t/* parse kernelcore=mirror */",
            "\tif (parse_option_str(p, \"mirror\")) {",
            "\t\tmirrored_kernelcore = true;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn cmdline_parse_core(p, &required_kernelcore,",
            "\t\t\t\t  &required_kernelcore_percent);",
            "}",
            "static int __init cmdline_parse_movablecore(char *p)",
            "{",
            "\treturn cmdline_parse_core(p, &required_movablecore,",
            "\t\t\t\t  &required_movablecore_percent);",
            "}",
            "static unsigned long __init early_calculate_totalpages(void)",
            "{",
            "\tunsigned long totalpages = 0;",
            "\tunsigned long start_pfn, end_pfn;",
            "\tint i, nid;",
            "",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {",
            "\t\tunsigned long pages = end_pfn - start_pfn;",
            "",
            "\t\ttotalpages += pages;",
            "\t\tif (pages)",
            "\t\t\tnode_set_state(nid, N_MEMORY);",
            "\t}",
            "\treturn totalpages;",
            "}"
          ],
          "function_name": "set_mminit_loglevel, mm_compute_batch, mm_compute_batch_notifier, mm_compute_batch_init, mm_sysfs_init, cmdline_parse_core, cmdline_parse_kernelcore, cmdline_parse_movablecore, early_calculate_totalpages",
          "description": "初始化内存批次计算逻辑，注册内存变化通知回调，解析命令行参数以确定内核核心和可移动内存需求",
          "similarity": 0.5148300528526306
        },
        {
          "chunk_id": 9,
          "file_path": "mm/mm_init.c",
          "start_line": 1313,
          "end_line": 1420,
          "content": [
            "static unsigned long __init calc_memmap_size(unsigned long spanned_pages,",
            "\t\t\t\t\t\tunsigned long present_pages)",
            "{",
            "\tunsigned long pages = spanned_pages;",
            "",
            "\t/*",
            "\t * Provide a more accurate estimation if there are holes within",
            "\t * the zone and SPARSEMEM is in use. If there are holes within the",
            "\t * zone, each populated memory region may cost us one or two extra",
            "\t * memmap pages due to alignment because memmap pages for each",
            "\t * populated regions may not be naturally aligned on page boundary.",
            "\t * So the (present_pages >> 4) heuristic is a tradeoff for that.",
            "\t */",
            "\tif (spanned_pages > present_pages + (present_pages >> 4) &&",
            "\t    IS_ENABLED(CONFIG_SPARSEMEM))",
            "\t\tpages = present_pages;",
            "",
            "\treturn PAGE_ALIGN(pages * sizeof(struct page)) >> PAGE_SHIFT;",
            "}",
            "static void pgdat_init_split_queue(struct pglist_data *pgdat)",
            "{",
            "\tstruct deferred_split *ds_queue = &pgdat->deferred_split_queue;",
            "",
            "\tspin_lock_init(&ds_queue->split_queue_lock);",
            "\tINIT_LIST_HEAD(&ds_queue->split_queue);",
            "\tds_queue->split_queue_len = 0;",
            "}",
            "static void pgdat_init_split_queue(struct pglist_data *pgdat) {}",
            "static void pgdat_init_kcompactd(struct pglist_data *pgdat)",
            "{",
            "\tinit_waitqueue_head(&pgdat->kcompactd_wait);",
            "}",
            "static void pgdat_init_kcompactd(struct pglist_data *pgdat) {}",
            "static void __meminit pgdat_init_internals(struct pglist_data *pgdat)",
            "{",
            "\tint i;",
            "",
            "\tpgdat_resize_init(pgdat);",
            "\tpgdat_kswapd_lock_init(pgdat);",
            "",
            "\tpgdat_init_split_queue(pgdat);",
            "\tpgdat_init_kcompactd(pgdat);",
            "",
            "\tinit_waitqueue_head(&pgdat->kswapd_wait);",
            "\tinit_waitqueue_head(&pgdat->pfmemalloc_wait);",
            "",
            "\tfor (i = 0; i < NR_VMSCAN_THROTTLE; i++)",
            "\t\tinit_waitqueue_head(&pgdat->reclaim_wait[i]);",
            "",
            "\tpgdat_page_ext_init(pgdat);",
            "\tlruvec_init(&pgdat->__lruvec);",
            "}",
            "static void __meminit zone_init_internals(struct zone *zone, enum zone_type idx, int nid,",
            "\t\t\t\t\t\t\tunsigned long remaining_pages)",
            "{",
            "\tatomic_long_set(&zone->managed_pages, remaining_pages);",
            "\tzone_set_nid(zone, nid);",
            "\tzone->name = zone_names[idx];",
            "\tzone->zone_pgdat = NODE_DATA(nid);",
            "\tspin_lock_init(&zone->lock);",
            "\tzone_seqlock_init(zone);",
            "\tzone_pcp_init(zone);",
            "}",
            "static void __meminit zone_init_free_lists(struct zone *zone)",
            "{",
            "\tunsigned int order, t;",
            "\tfor_each_migratetype_order(order, t) {",
            "\t\tINIT_LIST_HEAD(&zone->free_area[order].free_list[t]);",
            "\t\tzone->free_area[order].nr_free = 0;",
            "\t}",
            "",
            "#ifdef CONFIG_UNACCEPTED_MEMORY",
            "\tINIT_LIST_HEAD(&zone->unaccepted_pages);",
            "#endif",
            "}",
            "void __meminit init_currently_empty_zone(struct zone *zone,",
            "\t\t\t\t\tunsigned long zone_start_pfn,",
            "\t\t\t\t\tunsigned long size)",
            "{",
            "\tstruct pglist_data *pgdat = zone->zone_pgdat;",
            "\tint zone_idx = zone_idx(zone) + 1;",
            "",
            "\tif (zone_idx > pgdat->nr_zones)",
            "\t\tpgdat->nr_zones = zone_idx;",
            "",
            "\tzone->zone_start_pfn = zone_start_pfn;",
            "",
            "\tmminit_dprintk(MMINIT_TRACE, \"memmap_init\",",
            "\t\t\t\"Initialising map node %d zone %lu pfns %lu -> %lu\\n\",",
            "\t\t\tpgdat->node_id,",
            "\t\t\t(unsigned long)zone_idx(zone),",
            "\t\t\tzone_start_pfn, (zone_start_pfn + size));",
            "",
            "\tzone_init_free_lists(zone);",
            "\tzone->initialized = 1;",
            "}",
            "static unsigned long __init usemap_size(unsigned long zone_start_pfn, unsigned long zonesize)",
            "{",
            "\tunsigned long usemapsize;",
            "",
            "\tzonesize += zone_start_pfn & (pageblock_nr_pages-1);",
            "\tusemapsize = roundup(zonesize, pageblock_nr_pages);",
            "\tusemapsize = usemapsize >> pageblock_order;",
            "\tusemapsize *= NR_PAGEBLOCK_BITS;",
            "\tusemapsize = roundup(usemapsize, BITS_PER_LONG);",
            "",
            "\treturn usemapsize / BITS_PER_BYTE;",
            "}"
          ],
          "function_name": "calc_memmap_size, pgdat_init_split_queue, pgdat_init_split_queue, pgdat_init_kcompactd, pgdat_init_kcompactd, pgdat_init_internals, zone_init_internals, zone_init_free_lists, init_currently_empty_zone, usemap_size",
          "description": "计算内存映射所需大小，初始化split队列、kcompactd等待队列等内部结构，并配置区的自由列表及空闲页面管理机制。",
          "similarity": 0.5048665404319763
        },
        {
          "chunk_id": 0,
          "file_path": "mm/mm_init.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * mm_init.c - Memory initialisation verification and debugging",
            " *",
            " * Copyright 2008 IBM Corporation, 2008",
            " * Author Mel Gorman <mel@csn.ul.ie>",
            " *",
            " */",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/memblock.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/padata.h>",
            "#include <linux/nmi.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kfence.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/pti.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/swap.h>",
            "#include <linux/cma.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/kexec_handover.h>",
            "#include \"internal.h\"",
            "#include \"slab.h\"",
            "#include \"shuffle.h\"",
            "",
            "#include <asm/setup.h>",
            "",
            "#ifdef CONFIG_DEBUG_MEMORY_INIT",
            "int __meminitdata mminit_loglevel;",
            "",
            "/* The zonelists are simply reported, validation is manual. */"
          ],
          "function_name": null,
          "description": "声明头文件和全局变量，用于内存初始化验证和调试功能，包含日志级别控制及zonelist手动验证相关定义",
          "similarity": 0.49657347798347473
        },
        {
          "chunk_id": 6,
          "file_path": "mm/mm_init.c",
          "start_line": 912,
          "end_line": 1017,
          "content": [
            "static void __init memmap_init_zone_range(struct zone *zone,",
            "\t\t\t\t\t  unsigned long start_pfn,",
            "\t\t\t\t\t  unsigned long end_pfn,",
            "\t\t\t\t\t  unsigned long *hole_pfn)",
            "{",
            "\tunsigned long zone_start_pfn = zone->zone_start_pfn;",
            "\tunsigned long zone_end_pfn = zone_start_pfn + zone->spanned_pages;",
            "\tint nid = zone_to_nid(zone), zone_id = zone_idx(zone);",
            "",
            "\tstart_pfn = clamp(start_pfn, zone_start_pfn, zone_end_pfn);",
            "\tend_pfn = clamp(end_pfn, zone_start_pfn, zone_end_pfn);",
            "",
            "\tif (start_pfn >= end_pfn)",
            "\t\treturn;",
            "",
            "\tmemmap_init_range(end_pfn - start_pfn, nid, zone_id, start_pfn,",
            "\t\t\t  zone_end_pfn, MEMINIT_EARLY, NULL, MIGRATE_MOVABLE);",
            "",
            "\tif (*hole_pfn < start_pfn)",
            "\t\tinit_unavailable_range(*hole_pfn, start_pfn, zone_id, nid);",
            "",
            "\t*hole_pfn = end_pfn;",
            "}",
            "static void __init memmap_init(void)",
            "{",
            "\tunsigned long start_pfn, end_pfn;",
            "\tunsigned long hole_pfn = 0;",
            "\tint i, j, zone_id = 0, nid;",
            "",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {",
            "\t\tstruct pglist_data *node = NODE_DATA(nid);",
            "",
            "\t\tfor (j = 0; j < MAX_NR_ZONES; j++) {",
            "\t\t\tstruct zone *zone = node->node_zones + j;",
            "",
            "\t\t\tif (!populated_zone(zone))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tmemmap_init_zone_range(zone, start_pfn, end_pfn,",
            "\t\t\t\t\t       &hole_pfn);",
            "\t\t\tzone_id = j;",
            "\t\t}",
            "\t}",
            "",
            "#ifdef CONFIG_SPARSEMEM",
            "\t/*",
            "\t * Initialize the memory map for hole in the range [memory_end,",
            "\t * section_end].",
            "\t * Append the pages in this hole to the highest zone in the last",
            "\t * node.",
            "\t * The call to init_unavailable_range() is outside the ifdef to",
            "\t * silence the compiler warining about zone_id set but not used;",
            "\t * for FLATMEM it is a nop anyway",
            "\t */",
            "\tend_pfn = round_up(end_pfn, PAGES_PER_SECTION);",
            "\tif (hole_pfn < end_pfn)",
            "#endif",
            "\t\tinit_unavailable_range(hole_pfn, end_pfn, zone_id, nid);",
            "}",
            "static void __ref __init_zone_device_page(struct page *page, unsigned long pfn,",
            "\t\t\t\t\t  unsigned long zone_idx, int nid,",
            "\t\t\t\t\t  struct dev_pagemap *pgmap)",
            "{",
            "",
            "\t__init_single_page(page, pfn, zone_idx, nid);",
            "",
            "\t/*",
            "\t * Mark page reserved as it will need to wait for onlining",
            "\t * phase for it to be fully associated with a zone.",
            "\t *",
            "\t * We can use the non-atomic __set_bit operation for setting",
            "\t * the flag as we are still initializing the pages.",
            "\t */",
            "\t__SetPageReserved(page);",
            "",
            "\t/*",
            "\t * ZONE_DEVICE pages union ->lru with a ->pgmap back pointer",
            "\t * and zone_device_data.  It is a bug if a ZONE_DEVICE page is",
            "\t * ever freed or placed on a driver-private list.",
            "\t */",
            "\tpage->pgmap = pgmap;",
            "\tpage->zone_device_data = NULL;",
            "",
            "\t/*",
            "\t * Mark the block movable so that blocks are reserved for",
            "\t * movable at startup. This will force kernel allocations",
            "\t * to reserve their blocks rather than leaking throughout",
            "\t * the address space during boot when many long-lived",
            "\t * kernel allocations are made.",
            "\t *",
            "\t * Please note that MEMINIT_HOTPLUG path doesn't clear memmap",
            "\t * because this is done early in section_activate()",
            "\t */",
            "\tif (pageblock_aligned(pfn)) {",
            "\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\t/*",
            "\t * ZONE_DEVICE pages are released directly to the driver page allocator",
            "\t * which will set the page count to 1 when allocating the page.",
            "\t */",
            "\tif (pgmap->type == MEMORY_DEVICE_PRIVATE ||",
            "\t    pgmap->type == MEMORY_DEVICE_COHERENT)",
            "\t\tset_page_count(page, 0);",
            "}"
          ],
          "function_name": "memmap_init_zone_range, memmap_init, __init_zone_device_page",
          "description": "遍历各节点和区，调用memmap_init_range初始化内存映射，处理稀疏内存中洞的不可用范围，并调整ZONE_MOVABLE范围以适应架构需求。",
          "similarity": 0.4888758063316345
        }
      ]
    }
  ]
}