{
  "query": "块设备驱动与文件系统交互机制",
  "timestamp": "2025-12-25 23:27:31",
  "retrieved_files": [
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.599733829498291,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.5532478094100952
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.49733829498291016
        }
      ]
    },
    {
      "source_file": "kernel/trace/blktrace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:59:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\blktrace.c`\n\n---\n\n# `trace/blktrace.c` 技术文档\n\n## 1. 文件概述\n\n`trace/blktrace.c` 是 Linux 内核中块设备 I/O 跟踪（blktrace）机制的核心实现文件。该文件提供了对块设备 I/O 请求的全生命周期跟踪能力，包括请求的生成、调度、下发、完成等各个阶段。它支持两种输出模式：传统的 relayfs-based 输出（通过 `/sys/kernel/debug/block/`）和基于 ftrace 的统一跟踪输出。该机制广泛用于性能分析、I/O 行为调试和存储子系统优化。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct blk_trace`：每个被跟踪的块设备对应的跟踪上下文，包含设备信息、过滤条件、relay 通道等。\n- `struct blk_io_trace`：I/O 跟踪记录的基本单元，包含时间戳、设备号、扇区、字节数、操作类型、PID、CPU 等信息。\n- `blk_tracer_opts` / `blk_tracer_flags`：控制跟踪输出格式的选项，如是否启用 cgroup 信息、是否使用经典格式等。\n- 全局变量：\n  - `blktrace_seq`：用于避免重复记录进程信息的序列号。\n  - `running_trace_list`：当前所有活跃的 `blk_trace` 实例链表。\n  - `blk_tracer_enabled`：指示是否启用了基于 ftrace 的 blk tracer。\n\n### 主要函数\n\n- `trace_note()`：通用通知记录函数，用于记录非 I/O 操作类事件（如进程名、时间戳、用户消息等）。\n- `trace_note_tsk()`：为当前任务记录一次进程信息（`BLK_TN_PROCESS`），避免重复记录。\n- `trace_note_time()`：记录绝对时间戳（`BLK_TN_TIMESTAMP`），用于同步跟踪时间。\n- `__blk_trace_note_message()`：允许内核其他模块向 blktrace 输出自定义消息（`BLK_TN_MESSAGE`），支持 cgroup 上下文。\n- `act_log_check()`：根据跟踪配置（动作掩码、LBA 范围、PID 过滤）判断是否应记录某次 I/O。\n- `__blk_add_trace()`：核心 I/O 跟踪函数，将 I/O 事件封装为 `blk_io_trace` 并写入 relay buffer 或 ftrace ring buffer。\n\n## 3. 关键实现\n\n### 双输出路径支持\n代码同时支持两种后端：\n- **RelayFS 路径**：传统 blktrace 使用 `relay_reserve()` 向 per-CPU relay buffer 写入原始二进制数据，用户空间通过 `blkparse` 解析。\n- **Ftrace 路径**：当 `blk_tracer_enabled` 为真时，使用 `trace_buffer_lock_reserve()` 将数据写入 ftrace 的全局 ring buffer，可通过 `trace_pipe` 或 `trace` 文件读取。\n\n### 动作类型编码\n通过位操作将 `bio`/`request` 的标志（如 `REQ_SYNC`、`REQ_META`、`REQ_FUA` 等）映射到 blktrace 的动作类型（`BLK_TC_*`）。使用宏 `MASK_TC_BIT` 实现高效转换，利用编译期常量优化。\n\n### 进程与 cgroup 上下文\n- **进程去重**：通过 `tsk->btrace_seq` 与全局 `blktrace_seq` 比较，确保每个进程在跟踪期间只记录一次名称。\n- **cgroup 支持**：当启用 `TRACE_BLK_OPT_CGROUP` 时，在跟踪记录中附加 cgroup ID（`cgid`），用于 I/O 资源隔离分析。\n\n### 中断上下文安全\n在 relay 路径中，使用 `local_irq_save()` 保护 `relay_reserve()`，防止中断处理程序干扰 per-CPU buffer 分配。\n\n### 过滤机制\n`act_log_check()` 实现三层过滤：\n1. **动作类型过滤**：通过 `act_mask` 位掩码控制记录哪些操作（读/写/flush 等）。\n2. **LBA 范围过滤**：仅记录指定扇区范围内的 I/O。\n3. **PID 过滤**：仅记录指定进程发起的 I/O。\n\n## 4. 依赖关系\n\n- **块设备层**：依赖 `<linux/blkdev.h>` 和 `../../block/blk.h` 获取块设备和请求队列信息。\n- **跟踪子系统**：\n  - 基于 ftrace 的实现依赖 `trace/events/block.h` 和 `trace_output.h`。\n  - 使用 `tracing_gen_ctx_flags()`、`trace_buffer_lock_reserve()` 等 ftrace 核心 API。\n- **cgroup 子系统**：当 `CONFIG_BLK_CGROUP` 启用时，依赖 `cgroup_id()` 获取 cgroup 标识。\n- **内存与同步原语**：使用 `percpu`、`slab`、`mutex`、`raw_spinlock` 等内核基础设施。\n- **用户空间接口**：通过 `debugfs` 暴露控制接口（虽未在本文件实现，但为 blktrace 整体机制的一部分）。\n\n## 5. 使用场景\n\n- **I/O 性能分析**：结合 `blktrace` + `blkparse` + `btt` 工具链，分析磁盘 I/O 延迟、队列深度、请求合并等行为。\n- **存储栈调试**：跟踪 I/O 在 block layer、设备驱动、硬件间的流转过程，定位性能瓶颈或异常。\n- **cgroup I/O 隔离验证**：通过 `blk_cgname` 选项，关联 I/O 请求与具体 cgroup，验证 blk-iocost 或 bfq 等控制器效果。\n- **内核开发与测试**：在块设备驱动或 I/O 调度器开发中，验证请求处理逻辑是否符合预期。\n- **系统监控**：通过 ftrace 接口实时监控关键 I/O 事件，集成到系统级性能监控框架中。",
      "similarity": 0.5916909575462341,
      "chunks": [
        {
          "chunk_id": 12,
          "file_path": "kernel/trace/blktrace.c",
          "start_line": 1627,
          "end_line": 1735,
          "content": [
            "static int blk_trace_setup_queue(struct request_queue *q,",
            "\t\t\t\t struct block_device *bdev)",
            "{",
            "\tstruct blk_trace *bt = NULL;",
            "\tint ret = -ENOMEM;",
            "",
            "\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);",
            "\tif (!bt)",
            "\t\treturn -ENOMEM;",
            "",
            "\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));",
            "\tif (!bt->msg_data)",
            "\t\tgoto free_bt;",
            "",
            "\tbt->dev = bdev->bd_dev;",
            "\tbt->act_mask = (u16)-1;",
            "",
            "\tblk_trace_setup_lba(bt, bdev);",
            "",
            "\trcu_assign_pointer(q->blk_trace, bt);",
            "\tget_probe_ref();",
            "\treturn 0;",
            "",
            "free_bt:",
            "\tblk_trace_free(q, bt);",
            "\treturn ret;",
            "}",
            "static int blk_trace_str2mask(const char *str)",
            "{",
            "\tint i;",
            "\tint mask = 0;",
            "\tchar *buf, *s, *token;",
            "",
            "\tbuf = kstrdup(str, GFP_KERNEL);",
            "\tif (buf == NULL)",
            "\t\treturn -ENOMEM;",
            "\ts = strstrip(buf);",
            "",
            "\twhile (1) {",
            "\t\ttoken = strsep(&s, \",\");",
            "\t\tif (token == NULL)",
            "\t\t\tbreak;",
            "",
            "\t\tif (*token == '\\0')",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {",
            "\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {",
            "\t\t\t\tmask |= mask_maps[i].mask;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (i == ARRAY_SIZE(mask_maps)) {",
            "\t\t\tmask = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tkfree(buf);",
            "",
            "\treturn mask;",
            "}",
            "static ssize_t blk_trace_mask2str(char *buf, int mask)",
            "{",
            "\tint i;",
            "\tchar *p = buf;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {",
            "\t\tif (mask & mask_maps[i].mask) {",
            "\t\t\tp += sprintf(p, \"%s%s\",",
            "\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);",
            "\t\t}",
            "\t}",
            "\t*p++ = '\\n';",
            "",
            "\treturn p - buf;",
            "}",
            "static ssize_t sysfs_blk_trace_attr_show(struct device *dev,",
            "\t\t\t\t\t struct device_attribute *attr,",
            "\t\t\t\t\t char *buf)",
            "{",
            "\tstruct block_device *bdev = dev_to_bdev(dev);",
            "\tstruct request_queue *q = bdev_get_queue(bdev);",
            "\tstruct blk_trace *bt;",
            "\tssize_t ret = -ENXIO;",
            "",
            "\tmutex_lock(&q->debugfs_mutex);",
            "",
            "\tbt = rcu_dereference_protected(q->blk_trace,",
            "\t\t\t\t       lockdep_is_held(&q->debugfs_mutex));",
            "\tif (attr == &dev_attr_enable) {",
            "\t\tret = sprintf(buf, \"%u\\n\", !!bt);",
            "\t\tgoto out_unlock_bdev;",
            "\t}",
            "",
            "\tif (bt == NULL)",
            "\t\tret = sprintf(buf, \"disabled\\n\");",
            "\telse if (attr == &dev_attr_act_mask)",
            "\t\tret = blk_trace_mask2str(buf, bt->act_mask);",
            "\telse if (attr == &dev_attr_pid)",
            "\t\tret = sprintf(buf, \"%u\\n\", bt->pid);",
            "\telse if (attr == &dev_attr_start_lba)",
            "\t\tret = sprintf(buf, \"%llu\\n\", bt->start_lba);",
            "\telse if (attr == &dev_attr_end_lba)",
            "\t\tret = sprintf(buf, \"%llu\\n\", bt->end_lba);",
            "",
            "out_unlock_bdev:",
            "\tmutex_unlock(&q->debugfs_mutex);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "blk_trace_setup_queue, blk_trace_str2mask, blk_trace_mask2str, sysfs_blk_trace_attr_show",
          "description": "提供了块设备跟踪参数的配置接口，包含跟踪器初始化/移除逻辑、动作掩码字符串转换函数及sysfs属性读取实现，用于动态配置跟踪行为。",
          "similarity": 0.6206978559494019
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/trace/blktrace.c",
          "start_line": 1073,
          "end_line": 1179,
          "content": [
            "void blk_add_driver_data(struct request *rq, void *data, size_t len)",
            "{",
            "\tstruct blk_trace *bt;",
            "",
            "\trcu_read_lock();",
            "\tbt = rcu_dereference(rq->q->blk_trace);",
            "\tif (likely(!bt)) {",
            "\t\trcu_read_unlock();",
            "\t\treturn;",
            "\t}",
            "",
            "\t__blk_add_trace(bt, blk_rq_trace_sector(rq), blk_rq_bytes(rq), 0,",
            "\t\t\t\tBLK_TA_DRV_DATA, 0, len, data,",
            "\t\t\t\tblk_trace_request_get_cgid(rq));",
            "\trcu_read_unlock();",
            "}",
            "static void blk_register_tracepoints(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_getrq(blk_add_trace_getrq, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_plug(blk_add_trace_plug, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_unplug(blk_add_trace_unplug, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_split(blk_add_trace_split, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);",
            "\tWARN_ON(ret);",
            "\tret = register_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);",
            "\tWARN_ON(ret);",
            "}",
            "static void blk_unregister_tracepoints(void)",
            "{",
            "\tunregister_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);",
            "\tunregister_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);",
            "\tunregister_trace_block_split(blk_add_trace_split, NULL);",
            "\tunregister_trace_block_unplug(blk_add_trace_unplug, NULL);",
            "\tunregister_trace_block_plug(blk_add_trace_plug, NULL);",
            "\tunregister_trace_block_getrq(blk_add_trace_getrq, NULL);",
            "\tunregister_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);",
            "\tunregister_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);",
            "\tunregister_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);",
            "\tunregister_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);",
            "\tunregister_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);",
            "\tunregister_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);",
            "\tunregister_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);",
            "\tunregister_trace_block_rq_merge(blk_add_trace_rq_merge, NULL);",
            "\tunregister_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);",
            "\tunregister_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);",
            "",
            "\ttracepoint_synchronize_unregister();",
            "}",
            "static void fill_rwbs(char *rwbs, const struct blk_io_trace *t)",
            "{",
            "\tint i = 0;",
            "\tint tc = t->action >> BLK_TC_SHIFT;",
            "",
            "\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {",
            "\t\trwbs[i++] = 'N';",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (tc & BLK_TC_FLUSH)",
            "\t\trwbs[i++] = 'F';",
            "",
            "\tif (tc & BLK_TC_DISCARD)",
            "\t\trwbs[i++] = 'D';",
            "\telse if (tc & BLK_TC_WRITE)",
            "\t\trwbs[i++] = 'W';",
            "\telse if (t->bytes)",
            "\t\trwbs[i++] = 'R';",
            "\telse",
            "\t\trwbs[i++] = 'N';",
            "",
            "\tif (tc & BLK_TC_FUA)",
            "\t\trwbs[i++] = 'F';",
            "\tif (tc & BLK_TC_AHEAD)",
            "\t\trwbs[i++] = 'A';",
            "\tif (tc & BLK_TC_SYNC)",
            "\t\trwbs[i++] = 'S';",
            "\tif (tc & BLK_TC_META)",
            "\t\trwbs[i++] = 'M';",
            "out:",
            "\trwbs[i] = '\\0';",
            "}"
          ],
          "function_name": "blk_add_driver_data, blk_register_tracepoints, blk_unregister_tracepoints, fill_rwbs",
          "description": "该代码块主要实现块设备跟踪系统的初始化、注册及数据填充功能。  \n`blk_add_driver_data` 将驱动数据附加至请求队列的跟踪记录，`blk_register_tracepoints` 和 `blk_unregister_tracepoints` 分别注册与卸载块设备各关键操作阶段的跟踪点，`fill_rwbs` 根据 I/O 操作特性填充字符缓冲区以标识请求类型。  \n上下文不完整，部分 tracepoint 回调函数定义未展示，但核心机制已明确。",
          "similarity": 0.6083440780639648
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/trace/blktrace.c",
          "start_line": 1482,
          "end_line": 1591,
          "content": [
            "static enum print_line_t print_one_line(struct trace_iterator *iter,",
            "\t\t\t\t\tbool classic)",
            "{",
            "\tstruct trace_array *tr = iter->tr;",
            "\tstruct trace_seq *s = &iter->seq;",
            "\tconst struct blk_io_trace *t;",
            "\tu16 what;",
            "\tbool long_act;",
            "\tblk_log_action_t *log_action;",
            "\tbool has_cg;",
            "",
            "\tt\t   = te_blk_io_trace(iter->ent);",
            "\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;",
            "\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);",
            "\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;",
            "\thas_cg\t   = t->action & __BLK_TA_CGROUP;",
            "",
            "\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {",
            "\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);",
            "\t\tblk_log_msg(s, iter->ent, has_cg);",
            "\t\treturn trace_handle_return(s);",
            "\t}",
            "",
            "\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))",
            "\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);",
            "\telse {",
            "\t\tlog_action(iter, what2act[what].act[long_act], has_cg);",
            "\t\twhat2act[what].print(s, iter->ent, has_cg);",
            "\t}",
            "",
            "\treturn trace_handle_return(s);",
            "}",
            "static enum print_line_t blk_trace_event_print(struct trace_iterator *iter,",
            "\t\t\t\t\t       int flags, struct trace_event *event)",
            "{",
            "\treturn print_one_line(iter, false);",
            "}",
            "static void blk_trace_synthesize_old_trace(struct trace_iterator *iter)",
            "{",
            "\tstruct trace_seq *s = &iter->seq;",
            "\tstruct blk_io_trace *t = (struct blk_io_trace *)iter->ent;",
            "\tconst int offset = offsetof(struct blk_io_trace, sector);",
            "\tstruct blk_io_trace old = {",
            "\t\t.magic\t  = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION,",
            "\t\t.time     = iter->ts,",
            "\t};",
            "",
            "\ttrace_seq_putmem(s, &old, offset);",
            "\ttrace_seq_putmem(s, &t->sector,",
            "\t\t\t sizeof(old) - offset + t->pdu_len);",
            "}",
            "static enum print_line_t",
            "blk_trace_event_print_binary(struct trace_iterator *iter, int flags,",
            "\t\t\t     struct trace_event *event)",
            "{",
            "\tblk_trace_synthesize_old_trace(iter);",
            "",
            "\treturn trace_handle_return(&iter->seq);",
            "}",
            "static enum print_line_t blk_tracer_print_line(struct trace_iterator *iter)",
            "{",
            "\tif ((iter->ent->type != TRACE_BLK) ||",
            "\t    !(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))",
            "\t\treturn TRACE_TYPE_UNHANDLED;",
            "",
            "\treturn print_one_line(iter, true);",
            "}",
            "static int",
            "blk_tracer_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)",
            "{",
            "\t/* don't output context-info for blk_classic output */",
            "\tif (bit == TRACE_BLK_OPT_CLASSIC) {",
            "\t\tif (set)",
            "\t\t\ttr->trace_flags &= ~TRACE_ITER_CONTEXT_INFO;",
            "\t\telse",
            "\t\t\ttr->trace_flags |= TRACE_ITER_CONTEXT_INFO;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int __init init_blk_tracer(void)",
            "{",
            "\tif (!register_trace_event(&trace_blk_event)) {",
            "\t\tpr_warn(\"Warning: could not register block events\\n\");",
            "\t\treturn 1;",
            "\t}",
            "",
            "\tif (register_tracer(&blk_tracer) != 0) {",
            "\t\tpr_warn(\"Warning: could not register the block tracer\\n\");",
            "\t\tunregister_trace_event(&trace_blk_event);",
            "\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int blk_trace_remove_queue(struct request_queue *q)",
            "{",
            "\tstruct blk_trace *bt;",
            "",
            "\tbt = rcu_replace_pointer(q->blk_trace, NULL,",
            "\t\t\t\t lockdep_is_held(&q->debugfs_mutex));",
            "\tif (bt == NULL)",
            "\t\treturn -EINVAL;",
            "",
            "\tblk_trace_stop(bt);",
            "",
            "\tput_probe_ref();",
            "\tsynchronize_rcu();",
            "\tblk_trace_free(q, bt);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "print_one_line, blk_trace_event_print, blk_trace_synthesize_old_trace, blk_trace_event_print_binary, blk_tracer_print_line, blk_tracer_set_flag, init_blk_tracer, blk_trace_remove_queue",
          "description": "实现块设备跟踪事件的解析与打印逻辑，支持经典模式与非经典模式下的事件格式转换，包含旧格式兼容处理和跟踪器标志位设置功能。",
          "similarity": 0.5973693132400513
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/trace/blktrace.c",
          "start_line": 1342,
          "end_line": 1443,
          "content": [
            "static void blk_log_generic(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)",
            "{",
            "\tchar cmd[TASK_COMM_LEN];",
            "",
            "\ttrace_find_cmdline(ent->pid, cmd);",
            "",
            "\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {",
            "\t\ttrace_seq_printf(s, \"%u \", t_bytes(ent));",
            "\t\tblk_log_dump_pdu(s, ent, has_cg);",
            "\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);",
            "\t} else {",
            "\t\tif (t_sec(ent))",
            "\t\t\ttrace_seq_printf(s, \"%llu + %u [%s]\\n\",",
            "\t\t\t\t\t\tt_sector(ent), t_sec(ent), cmd);",
            "\t\telse",
            "\t\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);",
            "\t}",
            "}",
            "static void blk_log_with_error(struct trace_seq *s,",
            "\t\t\t      const struct trace_entry *ent, bool has_cg)",
            "{",
            "\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {",
            "\t\tblk_log_dump_pdu(s, ent, has_cg);",
            "\t\ttrace_seq_printf(s, \"[%d]\\n\", t_error(ent));",
            "\t} else {",
            "\t\tif (t_sec(ent))",
            "\t\t\ttrace_seq_printf(s, \"%llu + %u [%d]\\n\",",
            "\t\t\t\t\t t_sector(ent),",
            "\t\t\t\t\t t_sec(ent), t_error(ent));",
            "\t\telse",
            "\t\t\ttrace_seq_printf(s, \"%llu [%d]\\n\",",
            "\t\t\t\t\t t_sector(ent), t_error(ent));",
            "\t}",
            "}",
            "static void blk_log_remap(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)",
            "{",
            "\tconst struct blk_io_trace_remap *__r = pdu_start(ent, has_cg);",
            "",
            "\ttrace_seq_printf(s, \"%llu + %u <- (%d,%d) %llu\\n\",",
            "\t\t\t t_sector(ent), t_sec(ent),",
            "\t\t\t MAJOR(be32_to_cpu(__r->device_from)),",
            "\t\t\t MINOR(be32_to_cpu(__r->device_from)),",
            "\t\t\t be64_to_cpu(__r->sector_from));",
            "}",
            "static void blk_log_plug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)",
            "{",
            "\tchar cmd[TASK_COMM_LEN];",
            "",
            "\ttrace_find_cmdline(ent->pid, cmd);",
            "",
            "\ttrace_seq_printf(s, \"[%s]\\n\", cmd);",
            "}",
            "static void blk_log_unplug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)",
            "{",
            "\tchar cmd[TASK_COMM_LEN];",
            "",
            "\ttrace_find_cmdline(ent->pid, cmd);",
            "",
            "\ttrace_seq_printf(s, \"[%s] %llu\\n\", cmd, get_pdu_int(ent, has_cg));",
            "}",
            "static void blk_log_split(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)",
            "{",
            "\tchar cmd[TASK_COMM_LEN];",
            "",
            "\ttrace_find_cmdline(ent->pid, cmd);",
            "",
            "\ttrace_seq_printf(s, \"%llu / %llu [%s]\\n\", t_sector(ent),",
            "\t\t\t get_pdu_int(ent, has_cg), cmd);",
            "}",
            "static void blk_log_msg(struct trace_seq *s, const struct trace_entry *ent,",
            "\t\t\tbool has_cg)",
            "{",
            "",
            "\ttrace_seq_putmem(s, pdu_start(ent, has_cg),",
            "\t\tpdu_real_len(ent, has_cg));",
            "\ttrace_seq_putc(s, '\\n');",
            "}",
            "static void blk_tracer_print_header(struct seq_file *m)",
            "{",
            "\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))",
            "\t\treturn;",
            "\tseq_puts(m, \"# DEV   CPU TIMESTAMP     PID ACT FLG\\n\"",
            "\t\t    \"#  |     |     |           |   |   |\\n\");",
            "}",
            "static void blk_tracer_start(struct trace_array *tr)",
            "{",
            "\tblk_tracer_enabled = true;",
            "}",
            "static int blk_tracer_init(struct trace_array *tr)",
            "{",
            "\tblk_tr = tr;",
            "\tblk_tracer_start(tr);",
            "\treturn 0;",
            "}",
            "static void blk_tracer_stop(struct trace_array *tr)",
            "{",
            "\tblk_tracer_enabled = false;",
            "}",
            "static void blk_tracer_reset(struct trace_array *tr)",
            "{",
            "\tblk_tracer_stop(tr);",
            "}"
          ],
          "function_name": "blk_log_generic, blk_log_with_error, blk_log_remap, blk_log_plug, blk_log_unplug, blk_log_split, blk_log_msg, blk_tracer_print_header, blk_tracer_start, blk_tracer_init, blk_tracer_stop, blk_tracer_reset",
          "description": "定义了块设备跟踪的日志记录函数，用于将I/O操作、错误、重映射等事件格式化为可追踪的文本格式，包含对不同跟踪动作的处理逻辑及跟踪器启停控制。",
          "similarity": 0.592505693435669
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/blktrace.c",
          "start_line": 1,
          "end_line": 68,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2006 Jens Axboe <axboe@kernel.dk>",
            " *",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/export.h>",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/blk-cgroup.h>",
            "",
            "#include \"../../block/blk.h\"",
            "",
            "#include <trace/events/block.h>",
            "",
            "#include \"trace_output.h\"",
            "",
            "#ifdef CONFIG_BLK_DEV_IO_TRACE",
            "",
            "static unsigned int blktrace_seq __read_mostly = 1;",
            "",
            "static struct trace_array *blk_tr;",
            "static bool blk_tracer_enabled __read_mostly;",
            "",
            "static LIST_HEAD(running_trace_list);",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(running_trace_lock);",
            "",
            "/* Select an alternative, minimalistic output than the original one */",
            "#define TRACE_BLK_OPT_CLASSIC\t0x1",
            "#define TRACE_BLK_OPT_CGROUP\t0x2",
            "#define TRACE_BLK_OPT_CGNAME\t0x4",
            "",
            "static struct tracer_opt blk_tracer_opts[] = {",
            "\t/* Default disable the minimalistic output */",
            "\t{ TRACER_OPT(blk_classic, TRACE_BLK_OPT_CLASSIC) },",
            "#ifdef CONFIG_BLK_CGROUP",
            "\t{ TRACER_OPT(blk_cgroup, TRACE_BLK_OPT_CGROUP) },",
            "\t{ TRACER_OPT(blk_cgname, TRACE_BLK_OPT_CGNAME) },",
            "#endif",
            "\t{ }",
            "};",
            "",
            "static struct tracer_flags blk_tracer_flags = {",
            "\t.val  = 0,",
            "\t.opts = blk_tracer_opts,",
            "};",
            "",
            "/* Global reference count of probes */",
            "static DEFINE_MUTEX(blk_probe_mutex);",
            "static int blk_probes_ref;",
            "",
            "static void blk_register_tracepoints(void);",
            "static void blk_unregister_tracepoints(void);",
            "",
            "/*",
            " * Send out a notify message.",
            " */"
          ],
          "function_name": null,
          "description": "定义块设备跟踪的全局变量和选项结构，初始化跟踪模块的基础设施，包括trace数组、锁、跟踪选项及注册跟踪点的互斥控制。",
          "similarity": 0.5866556167602539
        }
      ]
    },
    {
      "source_file": "kernel/irq/devres.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:52:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\devres.c`\n\n---\n\n# `irq/devres.c` 技术文档\n\n## 1. 文件概述\n\n`irq/devres.c` 是 Linux 内核中用于实现**设备资源管理（Device Resource Management, devres）感知的中断（IRQ）申请与释放机制**的核心文件。该文件封装了标准 IRQ 操作（如 `request_irq`、`free_irq` 等）为“可自动释放”的资源管理版本，确保在设备驱动卸载或设备移除时，已申请的中断资源能被自动、安全地释放，避免资源泄漏。\n\n该机制基于内核的 `devres`（Device Resource）框架，将 IRQ 资源与 `struct device` 生命周期绑定，极大简化了驱动开发中的资源管理逻辑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct irq_devres`**  \n  用于跟踪通过 `devm_*` 接口申请的中断资源，包含：\n  - `irq`：中断号\n  - `dev_id`：传递给中断处理函数的设备标识（用于共享中断的区分）\n\n- **`struct irq_desc_devres`**  \n  用于跟踪通过 `__devm_irq_alloc_descs` 分配的中断描述符范围，包含：\n  - `from`：分配的起始中断号\n  - `cnt`：分配的中断数量\n\n- **`struct irq_generic_chip_devres`**  \n  用于跟踪通过 `devm_irq_setup_generic_chip` 设置的通用中断芯片资源，包含：\n  - `gc`：指向 `irq_chip_generic` 结构的指针\n  - `msk`、`clr`、`set`：用于在释放时还原中断状态的参数\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `devm_request_threaded_irq` | 为设备申请带线程化处理的中断，自动管理生命周期 |\n| `devm_request_any_context_irq` | 为设备申请可在任意上下文（硬中断或线程）处理的中断 |\n| `devm_free_irq` | 手动释放由 `devm_*` 接口申请的中断（通常不需要调用） |\n| `__devm_irq_alloc_descs` | 为设备分配并管理一组中断描述符（IRQ descriptors） |\n| `devm_irq_alloc_generic_chip` | 为设备分配并初始化一个通用中断芯片结构（`irq_chip_generic`） |\n| `devm_irq_setup_generic_chip` | 为设备设置通用中断芯片的中断范围，并注册资源释放回调 |\n\n## 3. 关键实现\n\n### 资源自动释放机制\n- 所有 `devm_*` 接口在成功申请资源后，会通过 `devres_alloc()` 分配一个资源描述结构（如 `irq_devres`），并注册对应的释放函数（如 `devm_irq_release`）。\n- 该资源结构通过 `devres_add()` 绑定到 `struct device`。\n- 当设备被移除（`device_del`）或驱动卸载时，内核自动调用所有注册的 `devres` 释放函数，确保 `free_irq()` 或 `irq_free_descs()` 被正确调用。\n\n### 中断匹配逻辑\n- `devm_free_irq()` 使用 `devm_irq_match` 函数通过 `irq` 和 `dev_id` 精确匹配要释放的资源，确保不会误删其他中断。\n\n### 通用中断芯片支持\n- `devm_irq_alloc_generic_chip` 使用 `devm_kzalloc` 分配内存，确保芯片结构随设备生命周期自动释放。\n- `devm_irq_setup_generic_chip` 在设置芯片后注册 `devm_irq_remove_generic_chip` 回调，在设备移除时自动调用 `irq_remove_generic_chip` 清理中断配置。\n\n### 错误处理\n- 所有分配操作（如 `devres_alloc`）失败时返回 `-ENOMEM`。\n- 底层 IRQ 申请失败时，会释放已分配的 `devres` 结构，避免内存泄漏。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/device.h>`：提供 `devres` 框架接口（`devres_alloc`, `devres_add`, `devres_destroy` 等）\n  - `<linux/interrupt.h>`：提供标准 IRQ 接口（`request_threaded_irq`, `free_irq` 等）\n  - `<linux/irq.h>`：提供中断描述符管理接口（`__irq_alloc_descs`, `irq_free_descs`）\n  - `\"internals.h\"`：包含 IRQ 子系统内部实现细节\n\n- **内核配置依赖**：\n  - `CONFIG_GENERIC_IRQ_CHIP`：启用通用中断芯片支持（影响 `devm_irq_alloc_generic_chip` 和 `devm_irq_setup_generic_chip` 的编译）\n\n- **模块导出**：\n  - `devm_request_threaded_irq`、`devm_request_any_context_irq`、`devm_free_irq` 通过 `EXPORT_SYMBOL` 导出，供其他模块使用。\n  - 中断描述符和通用芯片相关函数通过 `EXPORT_SYMBOL_GPL` 导出，仅限 GPL 兼容模块使用。\n\n## 5. 使用场景\n\n- **驱动开发**：设备驱动在 `probe` 函数中使用 `devm_request_threaded_irq()` 申请中断，无需在 `remove` 函数中显式调用 `free_irq()`，简化代码并避免遗漏。\n- **虚拟中断分配**：平台驱动或中断控制器驱动使用 `__devm_irq_alloc_descs()` 为虚拟设备分配中断号范围，确保在设备移除时自动释放描述符。\n- **通用中断控制器**：使用 `devm_irq_alloc_generic_chip()` 和 `devm_irq_setup_generic_chip()` 管理基于 `irq_chip_generic` 的中断控制器，适用于 GPIO、I2C、SPI 等子系统中的中断复用场景。\n- **资源安全释放**：在驱动异常退出或设备热插拔场景下，内核自动释放 IRQ 资源，防止中断悬挂或资源冲突。",
      "similarity": 0.5667628049850464,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/devres.c",
          "start_line": 18,
          "end_line": 122,
          "content": [
            "static void devm_irq_release(struct device *dev, void *res)",
            "{",
            "\tstruct irq_devres *this = res;",
            "",
            "\tfree_irq(this->irq, this->dev_id);",
            "}",
            "static int devm_irq_match(struct device *dev, void *res, void *data)",
            "{",
            "\tstruct irq_devres *this = res, *match = data;",
            "",
            "\treturn this->irq == match->irq && this->dev_id == match->dev_id;",
            "}",
            "int devm_request_threaded_irq(struct device *dev, unsigned int irq,",
            "\t\t\t      irq_handler_t handler, irq_handler_t thread_fn,",
            "\t\t\t      unsigned long irqflags, const char *devname,",
            "\t\t\t      void *dev_id)",
            "{",
            "\tstruct irq_devres *dr;",
            "\tint rc;",
            "",
            "\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),",
            "\t\t\t  GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!devname)",
            "\t\tdevname = dev_name(dev);",
            "",
            "\trc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,",
            "\t\t\t\t  dev_id);",
            "\tif (rc) {",
            "\t\tdevres_free(dr);",
            "\t\treturn rc;",
            "\t}",
            "",
            "\tdr->irq = irq;",
            "\tdr->dev_id = dev_id;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn 0;",
            "}",
            "int devm_request_any_context_irq(struct device *dev, unsigned int irq,",
            "\t\t\t      irq_handler_t handler, unsigned long irqflags,",
            "\t\t\t      const char *devname, void *dev_id)",
            "{",
            "\tstruct irq_devres *dr;",
            "\tint rc;",
            "",
            "\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),",
            "\t\t\t  GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!devname)",
            "\t\tdevname = dev_name(dev);",
            "",
            "\trc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);",
            "\tif (rc < 0) {",
            "\t\tdevres_free(dr);",
            "\t\treturn rc;",
            "\t}",
            "",
            "\tdr->irq = irq;",
            "\tdr->dev_id = dev_id;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn rc;",
            "}",
            "void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)",
            "{",
            "\tstruct irq_devres match_data = { irq, dev_id };",
            "",
            "\tWARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,",
            "\t\t\t       &match_data));",
            "\tfree_irq(irq, dev_id);",
            "}",
            "static void devm_irq_desc_release(struct device *dev, void *res)",
            "{",
            "\tstruct irq_desc_devres *this = res;",
            "",
            "\tirq_free_descs(this->from, this->cnt);",
            "}",
            "int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,",
            "\t\t\t   unsigned int cnt, int node, struct module *owner,",
            "\t\t\t   const struct irq_affinity_desc *affinity)",
            "{",
            "\tstruct irq_desc_devres *dr;",
            "\tint base;",
            "",
            "\tdr = devres_alloc(devm_irq_desc_release, sizeof(*dr), GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tbase = __irq_alloc_descs(irq, from, cnt, node, owner, affinity);",
            "\tif (base < 0) {",
            "\t\tdevres_free(dr);",
            "\t\treturn base;",
            "\t}",
            "",
            "\tdr->from = base;",
            "\tdr->cnt = cnt;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn base;",
            "}"
          ],
          "function_name": "devm_irq_release, devm_irq_match, devm_request_threaded_irq, devm_request_any_context_irq, devm_free_irq, devm_irq_desc_release, __devm_irq_alloc_descs",
          "description": "实现设备资源管理的中断申请与释放逻辑，包含中断线程处理注册、任意上下文中断申请、中断释放及中断描述符分配等功能，通过devres框架实现资源自动管理。",
          "similarity": 0.519720196723938
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/devres.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "/*",
            " * Device resource management aware IRQ request/free implementation.",
            " */",
            "struct irq_devres {",
            "\tunsigned int irq;",
            "\tvoid *dev_id;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义irq_devres结构体，用于存储中断号和设备ID，作为设备资源管理中断请求的辅助数据结构。",
          "similarity": 0.48455750942230225
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/devres.c",
          "start_line": 240,
          "end_line": 266,
          "content": [
            "static void devm_irq_remove_generic_chip(struct device *dev, void *res)",
            "{",
            "\tstruct irq_generic_chip_devres *this = res;",
            "",
            "\tirq_remove_generic_chip(this->gc, this->msk, this->clr, this->set);",
            "}",
            "int devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,",
            "\t\t\t\tu32 msk, enum irq_gc_flags flags,",
            "\t\t\t\tunsigned int clr, unsigned int set)",
            "{",
            "\tstruct irq_generic_chip_devres *dr;",
            "",
            "\tdr = devres_alloc(devm_irq_remove_generic_chip,",
            "\t\t\t  sizeof(*dr), GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tirq_setup_generic_chip(gc, msk, flags, clr, set);",
            "",
            "\tdr->gc = gc;",
            "\tdr->msk = msk;",
            "\tdr->clr = clr;",
            "\tdr->set = set;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "devm_irq_remove_generic_chip, devm_irq_setup_generic_chip",
          "description": "提供通用中断芯片的配置与清理接口，用于在设备初始化时设置中断控制器参数并在设备移除时安全地移除通用中断芯片配置。",
          "similarity": 0.4739907681941986
        }
      ]
    }
  ]
}