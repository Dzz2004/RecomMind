{
  "query": "进程终止时PCB的信号通知机制",
  "timestamp": "2025-12-26 00:45:13",
  "retrieved_files": [
    {
      "source_file": "kernel/cpu_pm.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:55:54\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cpu_pm.c`\n\n---\n\n# cpu_pm.c 技术文档\n\n## 1. 文件概述\n\n`cpu_pm.c` 实现了 Linux 内核中 CPU 电源管理（CPU PM）的通知机制，用于在 CPU 或 CPU 集群进入/退出低功耗状态时通知相关驱动程序。该机制允许驱动程序在 CPU 电源状态变化前后执行必要的上下文保存与恢复操作（如 VFP 协处理器、中断控制器、本地定时器等），以确保系统在低功耗状态切换后仍能正常运行。该文件特别考虑了实时内核（PREEMPT_RT）下的锁行为，使用 `raw_spinlock_t` 保证在中断禁用上下文中安全执行。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `cpu_pm_notifier`：包含一个 `raw_notifier_head` 通知链和一个 `raw_spinlock_t` 锁，用于管理 CPU PM 事件的通知。\n\n### 主要函数\n- `cpu_pm_register_notifier(struct notifier_block *nb)`  \n  注册一个 CPU PM 事件通知回调。\n- `cpu_pm_unregister_notifier(struct notifier_block *nb)`  \n  注销一个已注册的 CPU PM 事件通知回调。\n- `cpu_pm_enter(void)`  \n  通知所有监听者：当前 CPU 即将进入可能导致同电源域硬件复位的低功耗状态。\n- `cpu_pm_exit(void)`  \n  通知所有监听者：当前 CPU 正在退出低功耗状态。\n- `cpu_cluster_pm_enter(void)`  \n  通知所有监听者：整个 CPU 集群（电源域）即将进入低功耗状态。\n- `cpu_cluster_pm_exit(void)`  \n  通知所有监听者：整个 CPU 集群正在退出低功耗状态。\n\n### 内部辅助函数\n- `cpu_pm_notify(enum cpu_pm_event event)`  \n  调用通知链，适用于单向事件（如 EXIT）。\n- `cpu_pm_notify_robust(enum cpu_pm_event event_up, enum cpu_pm_event event_down)`  \n  调用健壮通知链（robust notifier），在通知失败时可回滚，适用于 ENTER 类操作。\n\n## 3. 关键实现\n\n### 使用 raw_spinlock 而非 spinlock\n由于在 PREEMPT_RT 内核中，普通 `spinlock_t` 可能导致睡眠，而 CPU PM 通知由 idle 任务在中断禁用上下文中调用，不能阻塞。因此，该模块使用 `raw_spinlock_t` 保证在任何配置下都能在原子上下文中安全执行。\n\n### 健壮通知机制（Robust Notification）\n- `cpu_pm_enter()` 和 `cpu_cluster_pm_enter()` 使用 `raw_notifier_call_chain_robust()`：\n  - 先按顺序发送 `*_ENTER` 事件；\n  - 若任一回调失败，则反向发送 `*_ENTER_FAILED` 事件，允许已成功执行的驱动回滚操作。\n- `cpu_pm_exit()` 和 `cpu_cluster_pm_exit()` 使用普通通知链，因为退出操作通常不可逆，无需回滚。\n\n### 中断上下文要求\n所有 `cpu_pm_*` 和 `cpu_cluster_pm_*` 函数**必须在中断禁用的上下文中调用**，因为：\n- 被通知的驱动可能操作不能被中断的硬件（如本地定时器、VFP 协处理器）；\n- 防止在上下文保存/恢复过程中被抢占或中断，导致状态不一致。\n\n### 系统核心电源管理集成（CONFIG_PM）\n当启用 `CONFIG_PM` 时：\n- 注册 `syscore_ops` 回调，在系统挂起到 RAM（suspend-to-RAM）期间自动调用 `cpu_pm_suspend()` 和 `cpu_pm_resume()`；\n- `cpu_pm_suspend()` 依次调用 `cpu_pm_enter()` 和 `cpu_cluster_pm_enter()`；\n- `cpu_pm_resume()` 依次调用 `cpu_cluster_pm_exit()` 和 `cpu_pm_exit()`；\n- 通过 `core_initcall` 在内核初始化早期注册该机制。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/cpu_pm.h>`：定义 `cpu_pm_event` 枚举和通知函数原型；\n  - `<linux/notifier.h>`：提供通知链基础设施；\n  - `<linux/spinlock.h>`：提供 `raw_spinlock_t` 支持；\n  - `<linux/syscore_ops.h>`：用于系统 suspend/resume 集成；\n  - `<linux/rcupdate.h>`（隐式）：`rcu_read_lock/unlock` 用于安全遍历通知链。\n\n- **内核配置依赖**：\n  - `CONFIG_PM`：启用系统级 suspend/resume 集成；\n  - `CONFIG_PREEMPT_RT`：影响锁的选择逻辑（虽不直接依赖，但设计考虑了其实现差异）。\n\n- **被依赖模块**：\n  - 需要保存/恢复 CPU 相关硬件上下文的驱动（如 ARM 架构的 VFP、GIC 中断控制器、arch-timer 等）会调用注册/注销接口。\n\n## 5. 使用场景\n\n1. **CPU 热插拔或 idle 深度睡眠**  \n   当 CPU 进入 `WFI`/`WFE` 或更深度的 idle 状态（如 ARM 的 `cpuidle` 驱动）时，调用 `cpu_pm_enter()`/`cpu_pm_exit()` 通知驱动保存/恢复上下文。\n\n2. **CPU 集群电源门控（Cluster Power Gating）**  \n   在 big.LITTLE 或多簇 ARM 系统中，当整个 CPU 集群断电时，先对每个 CPU 调用 `cpu_pm_enter()`，再调用 `cpu_cluster_pm_enter()`；唤醒时顺序相反。\n\n3. **系统挂起（Suspend-to-RAM）**  \n   通过 `syscore_ops` 集成，在 `suspend` 过程中自动触发 CPU 和集群 PM 通知，确保系统 resume 后 CPU 相关硬件状态正确。\n\n4. **实时系统（PREEMPT_RT）兼容性**  \n   在 RT 内核中，确保 CPU PM 通知路径不会因锁而阻塞，维持 idle 路径的确定性。",
      "similarity": 0.6812502145767212,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/cpu_pm.c",
          "start_line": 29,
          "end_line": 106,
          "content": [
            "static int cpu_pm_notify(enum cpu_pm_event event)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = raw_notifier_call_chain(&cpu_pm_notifier.chain, event, NULL);",
            "\trcu_read_unlock();",
            "",
            "\treturn notifier_to_errno(ret);",
            "}",
            "static int cpu_pm_notify_robust(enum cpu_pm_event event_up, enum cpu_pm_event event_down)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\traw_spin_lock_irqsave(&cpu_pm_notifier.lock, flags);",
            "\tret = raw_notifier_call_chain_robust(&cpu_pm_notifier.chain, event_up, event_down, NULL);",
            "\traw_spin_unlock_irqrestore(&cpu_pm_notifier.lock, flags);",
            "",
            "\treturn notifier_to_errno(ret);",
            "}",
            "int cpu_pm_register_notifier(struct notifier_block *nb)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\traw_spin_lock_irqsave(&cpu_pm_notifier.lock, flags);",
            "\tret = raw_notifier_chain_register(&cpu_pm_notifier.chain, nb);",
            "\traw_spin_unlock_irqrestore(&cpu_pm_notifier.lock, flags);",
            "\treturn ret;",
            "}",
            "int cpu_pm_unregister_notifier(struct notifier_block *nb)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\traw_spin_lock_irqsave(&cpu_pm_notifier.lock, flags);",
            "\tret = raw_notifier_chain_unregister(&cpu_pm_notifier.chain, nb);",
            "\traw_spin_unlock_irqrestore(&cpu_pm_notifier.lock, flags);",
            "\treturn ret;",
            "}",
            "int cpu_pm_enter(void)",
            "{",
            "\treturn cpu_pm_notify_robust(CPU_PM_ENTER, CPU_PM_ENTER_FAILED);",
            "}",
            "int cpu_pm_exit(void)",
            "{",
            "\treturn cpu_pm_notify(CPU_PM_EXIT);",
            "}",
            "int cpu_cluster_pm_enter(void)",
            "{",
            "\treturn cpu_pm_notify_robust(CPU_CLUSTER_PM_ENTER, CPU_CLUSTER_PM_ENTER_FAILED);",
            "}",
            "int cpu_cluster_pm_exit(void)",
            "{",
            "\treturn cpu_pm_notify(CPU_CLUSTER_PM_EXIT);",
            "}",
            "static int cpu_pm_suspend(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = cpu_pm_enter();",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = cpu_cluster_pm_enter();",
            "\treturn ret;",
            "}",
            "static void cpu_pm_resume(void)",
            "{",
            "\tcpu_cluster_pm_exit();",
            "\tcpu_pm_exit();",
            "}",
            "static int cpu_pm_init(void)",
            "{",
            "\tregister_syscore_ops(&cpu_pm_syscore_ops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "cpu_pm_notify, cpu_pm_notify_robust, cpu_pm_register_notifier, cpu_pm_unregister_notifier, cpu_pm_enter, cpu_pm_exit, cpu_cluster_pm_enter, cpu_cluster_pm_exit, cpu_pm_suspend, cpu_pm_resume, cpu_pm_init",
          "description": "该代码段实现CPU及集群电源管理的异步通知机制，通过`notifier chain`管理注册的回调函数，支持注册/注销监听器并触发相应事件。  \n关键函数`cpu_pm_enter/exit`和`cpu_cluster_pm_enter/exit`分别用于CPU/集群的电源状态切换通知，`cpu_pm_suspend/resume`串联了挂起/恢复流程中的电源管理操作。  \n代码定义了基于RCU和自旋锁的线程安全通知链，用于协调硬件电源状态变更与软件层的响应。",
          "similarity": 0.659604549407959
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cpu_pm.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (C) 2011 Google, Inc.",
            " *",
            " * Author:",
            " *\tColin Cross <ccross@android.com>",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/cpu_pm.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscore_ops.h>",
            "",
            "/*",
            " * atomic_notifiers use a spinlock_t, which can block under PREEMPT_RT.",
            " * Notifications for cpu_pm will be issued by the idle task itself, which can",
            " * never block, IOW it requires using a raw_spinlock_t.",
            " */",
            "static struct {",
            "\tstruct raw_notifier_head chain;",
            "\traw_spinlock_t lock;",
            "} cpu_pm_notifier = {",
            "\t.chain = RAW_NOTIFIER_INIT(cpu_pm_notifier.chain),",
            "\t.lock  = __RAW_SPIN_LOCK_UNLOCKED(cpu_pm_notifier.lock),",
            "};",
            ""
          ],
          "function_name": null,
          "description": "此代码定义了一个用于CPU电源管理的通知链结构体`cpu_pm_notifier`，包含一个`raw_notifier_head`链表头和一个`raw_spinlock_t`自旋锁，用于同步对CPU休眠/唤醒事件的异步回调注册。其核心作用是在CPU进入低功耗状态时，通过`raw_notifier_call_chain`触发预注册的回调函数，且采用`raw_spinlock`保证在PREEMPT_RT配置下的无阻塞特性。由于仅展示结构体定义，未包含具体回调函数实现，故上下文不完整。",
          "similarity": 0.6527791023254395
        }
      ]
    },
    {
      "source_file": "kernel/user-return-notifier.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user-return-notifier.c`\n\n---\n\n# user-return-notifier.c 技术文档\n\n## 1. 文件概述\n\n`user-return-notifier.c` 实现了用户态返回通知机制（User Return Notifier），允许内核子系统在当前 CPU 即将从内核态返回用户态时注册回调函数。该机制用于在特定内核事件（如安全策略更新、性能监控等）发生后，延迟执行某些操作，直到进程真正返回用户空间，从而避免在关键内核路径中引入额外开销或竞态条件。\n\n## 2. 核心功能\n\n### 数据结构\n- `return_notifier_list`：每 CPU 变量（per-CPU variable），类型为 `struct hlist_head`，用于存储当前 CPU 上注册的所有用户返回通知器链表。\n\n### 主要函数\n- `user_return_notifier_register(struct user_return_notifier *urn)`  \n  注册一个用户返回通知器，将其加入当前 CPU 的通知链表，并设置当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `user_return_notifier_unregister(struct user_return_notifier *urn)`  \n  从当前 CPU 的通知链表中移除指定的通知器；若链表变为空，则清除当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `fire_user_return_notifiers(void)`  \n  遍历并调用当前 CPU 上所有已注册的通知器的回调函数 `on_user_return`，通常在内核即将返回用户态前由调度或系统调用退出路径调用。\n\n## 3. 关键实现\n\n- **每 CPU 链表设计**：使用 `DEFINE_PER_CPU` 定义 per-CPU 的哈希链表头，确保每个 CPU 维护独立的通知器列表，避免跨 CPU 同步开销。\n  \n- **原子上下文要求**：注册和注销操作必须在原子上下文中执行（不可睡眠），因为它们操作 per-CPU 数据且可能在中断或调度关键路径中被调用。\n\n- **线程标志位控制**：通过设置/清除任务结构体中的 `TIF_USER_RETURN_NOTIFY` 标志位（`TIF_` 表示 Thread Info Flag），通知内核在返回用户态前需调用 `fire_user_return_notifiers()`。\n\n- **安全遍历与调用**：`fire_user_return_notifiers()` 使用 `hlist_for_each_entry_safe` 安全遍历链表，允许回调函数在执行过程中注销自身或其他通知器。\n\n- **CPU 变量访问**：使用 `get_cpu_var()` 和 `put_cpu_var()` 保证在访问 per-CPU 变量期间禁止内核抢占，确保操作的 CPU 一致性。\n\n## 4. 依赖关系\n\n- `<linux/user-return-notifier.h>`：定义 `struct user_return_notifier` 及相关 API。\n- `<linux/percpu.h>`：提供 per-CPU 变量支持。\n- `<linux/sched.h>`：提供任务结构体（`current`）和线程标志位操作函数（如 `set_tsk_thread_flag`）。\n- `<linux/export.h>`：导出符号供其他内核模块使用（`EXPORT_SYMBOL_GPL`）。\n- 依赖架构相关的线程信息标志（`TIF_USER_RETURN_NOTIFY`）在 `thread_info` 中的定义。\n\n## 5. 使用场景\n\n- **安全模块**：如 SELinux 或 LSM 框架在策略更新后，需通知用户态进程重新评估权限，可延迟到返回用户态时触发。\n- **性能监控与跟踪**：在系统调用或中断处理完成后，于返回用户态前收集上下文切换或延迟信息。\n- **延迟工作调度**：某些不适合在中断或原子上下文中执行的操作，可注册为用户返回通知，在安全的用户态切换点执行。\n- **虚拟化与容器**：在客户机或容器退出内核时同步状态或注入事件。\n\n该机制是内核“延迟通知”模式的典型实现，确保高优先级内核路径不受回调逻辑影响，同时保证通知在正确的执行上下文中触发。",
      "similarity": 0.6790817379951477,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 15,
          "end_line": 36,
          "content": [
            "void user_return_notifier_register(struct user_return_notifier *urn)",
            "{",
            "\tset_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "\thlist_add_head(&urn->link, this_cpu_ptr(&return_notifier_list));",
            "}",
            "void user_return_notifier_unregister(struct user_return_notifier *urn)",
            "{",
            "\thlist_del(&urn->link);",
            "\tif (hlist_empty(this_cpu_ptr(&return_notifier_list)))",
            "\t\tclear_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "}",
            "void fire_user_return_notifiers(void)",
            "{",
            "\tstruct user_return_notifier *urn;",
            "\tstruct hlist_node *tmp2;",
            "\tstruct hlist_head *head;",
            "",
            "\thead = &get_cpu_var(return_notifier_list);",
            "\thlist_for_each_entry_safe(urn, tmp2, head, link)",
            "\t\turn->on_user_return(urn);",
            "\tput_cpu_var(return_notifier_list);",
            "}"
          ],
          "function_name": "user_return_notifier_register, user_return_notifier_unregister, fire_user_return_notifiers",
          "description": "实现用户态返回通知器的注册/注销与触发机制。register 函数将通知器链接到当前 CPU 的链表并设置 TIF_USER_RETURN_NOTIFY 标志；unregister 函数移除节点并清理标志；fire 函数遍历当前 CPU 链表执行所有注册的 on_user_return 回调函数。",
          "similarity": 0.5883561968803406
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "",
            "static DEFINE_PER_CPU(struct hlist_head, return_notifier_list);",
            "",
            "/*",
            " * Request a notification when the current cpu returns to userspace.  Must be",
            " * called in atomic context.  The notifier will also be called in atomic",
            " * context.",
            " */"
          ],
          "function_name": null,
          "description": "定义了一个 per-CPU 的哈希列表头结构 return_notifier_list，用于存储用户态返回通知器注册项。该结构通过 DEFINE_PER_CPU 宏为每个 CPU 创建独立的链表头，支持多 CPU 环境下的并发访问。",
          "similarity": 0.5568477511405945
        }
      ]
    },
    {
      "source_file": "kernel/time/tick-broadcast.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:48:04\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\tick-broadcast.c`\n\n---\n\n# `time/tick-broadcast.c` 技术文档\n\n## 1. 文件概述\n\n`tick-broadcast.c` 实现了 Linux 内核中的 **时钟事件广播机制（tick broadcast）**，用于在某些硬件平台（如部分 x86 系统）上，当本地 APIC 定时器在深度 C 状态（如 C3）下停止工作时，通过一个全局的、始终可用的广播时钟事件设备（broadcast clock event device）来为多个 CPU 提供周期性或单次（oneshot）的时钟中断服务。该机制确保即使本地定时器失效，系统仍能维持正确的调度、时间管理和电源管理功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `tick_broadcast_device`：全局的广播时钟设备封装（`struct tick_device`）\n- `tick_broadcast_mask`：记录当前依赖广播机制接收 tick 的 CPU 掩码\n- `tick_broadcast_on`：记录处于周期性广播模式的 CPU 掩码\n- `tmpmask`：临时 CPU 掩码，用于内部计算\n- `tick_broadcast_forced`：标志位，指示是否强制启用广播模式\n- `tick_oneshot_wakeup_device`（per-CPU）：每个 CPU 可选的专用单次唤醒设备（用于优化）\n\n### 主要函数\n\n- `tick_install_broadcast_device()`：安装或替换广播时钟设备\n- `tick_device_uses_broadcast()`：判断某 CPU 的本地设备是否需依赖广播\n- `tick_is_broadcast_device()`：检查设备是否为当前广播设备\n- `tick_broadcast_update_freq()`：更新广播设备频率\n- `tick_get_broadcast_device()` / `tick_get_broadcast_mask()`：调试接口\n- `tick_set_oneshot_wakeup_device()`：为 CPU 设置专用单次唤醒设备\n- `tick_broadcast_setup_oneshot()` / `tick_broadcast_clear_oneshot()`：管理单次广播模式\n- `tick_oneshot_wakeup_handler()`：专用唤醒设备的中断处理函数\n\n## 3. 关键实现\n\n### 广播设备选择策略\n- 通过 `tick_check_broadcast_device()` 评估候选设备：\n  - 排除 `DUMMY`、`PERCPU` 或 `C3STOP` 特性的设备\n  - 在 oneshot 模式下要求设备支持 `ONESHOT`\n  - 优先选择 `rating` 更高的设备\n\n### 两种广播模式\n- **周期性模式（Periodic）**：通过 `tick_broadcast_start_periodic()` 启动固定频率中断\n- **单次模式（Oneshot）**：通过 `tick_broadcast_setup_oneshot()` 动态编程下次中断时间\n\n### CPU 依赖管理\n- 当 CPU 的本地设备不支持深度睡眠（无 `C3STOP`）或功能不全时，将其加入 `tick_broadcast_mask`\n- 支持为特定 CPU 分配专用的 `tick_oneshot_wakeup_device`，避免全局广播开销\n\n### 安全机制\n- 使用 `tick_broadcast_lock` 自旋锁保护全局状态\n- 通过 `try_module_get()` 确保设备驱动模块不会在使用中被卸载\n- 提供 `err_broadcast()` 作为兜底处理，防止系统完全失去 tick\n\n### 模式切换\n- 若系统已运行在 oneshot 模式，新注册的广播设备会自动切换至 oneshot\n- 通过 `tick_clock_notify()` 通知所有 CPU 重新评估 tick 模式\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `tick-internal.h`：tick 子系统内部接口\n  - `clockevents` 框架：设备注册、频率更新、事件处理\n  - `tick-sched.c`：与 per-CPU tick 调度器交互\n- **外部依赖**：\n  - `CONFIG_GENERIC_CLOCKEVENTS`：时钟事件设备基础框架\n  - `CONFIG_TICK_ONESHOT`：单次 tick 模式支持（可选）\n  - `CONFIG_HOTPLUG_CPU`：CPU 热插拔时的广播状态管理（可选）\n- **头文件**：\n  - `<linux/cpumask.h>`、`<linux/smp.h>`：CPU 掩码和 SMP 操作\n  - `<linux/interrupt.h>`、`<linux/hrtimer.h>`：中断和高精度定时器支持\n\n## 5. 使用场景\n\n1. **x86 C3+ 电源状态**：在 Intel/AMD 处理器进入 C3 或更深睡眠状态时，本地 APIC 定时器停止，必须依赖 HPET 或 TSC_DEADLINE 等全局设备广播 tick。\n2. **无本地定时器的架构**：某些嵌入式或旧平台可能缺乏 per-CPU 定时器，完全依赖广播机制。\n3. **调试与监控**：通过 `timer_list` 等工具可查看广播设备状态，辅助诊断 tick 相关问题。\n4. **CPU 热插拔**：在线 CPU 下线时，需将其从广播掩码中移除（`tick_broadcast_oneshot_offline`）。\n5. **动态 tick 模式切换**：系统在周期性 tick 与 NO_HZ（动态 tick）模式间切换时，广播设备需同步调整工作模式。",
      "similarity": 0.6480075716972351,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 328,
          "end_line": 488,
          "content": [
            "int tick_receive_broadcast(void)",
            "{",
            "\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);",
            "\tstruct clock_event_device *evt = td->evtdev;",
            "",
            "\tif (!evt)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (!evt->event_handler)",
            "\t\treturn -EINVAL;",
            "",
            "\tevt->event_handler(evt);",
            "\treturn 0;",
            "}",
            "static bool tick_do_broadcast(struct cpumask *mask)",
            "{",
            "\tint cpu = smp_processor_id();",
            "\tstruct tick_device *td;",
            "\tbool local = false;",
            "",
            "\t/*",
            "\t * Check, if the current cpu is in the mask",
            "\t */",
            "\tif (cpumask_test_cpu(cpu, mask)) {",
            "\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;",
            "",
            "\t\tcpumask_clear_cpu(cpu, mask);",
            "\t\t/*",
            "\t\t * We only run the local handler, if the broadcast",
            "\t\t * device is not hrtimer based. Otherwise we run into",
            "\t\t * a hrtimer recursion.",
            "\t\t *",
            "\t\t * local timer_interrupt()",
            "\t\t *   local_handler()",
            "\t\t *     expire_hrtimers()",
            "\t\t *       bc_handler()",
            "\t\t *         local_handler()",
            "\t\t *\t     expire_hrtimers()",
            "\t\t */",
            "\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);",
            "\t}",
            "",
            "\tif (!cpumask_empty(mask)) {",
            "\t\t/*",
            "\t\t * It might be necessary to actually check whether the devices",
            "\t\t * have different broadcast functions. For now, just use the",
            "\t\t * one of the first device. This works as long as we have this",
            "\t\t * misfeature only on x86 (lapic)",
            "\t\t */",
            "\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));",
            "\t\ttd->evtdev->broadcast(mask);",
            "\t}",
            "\treturn local;",
            "}",
            "static bool tick_do_periodic_broadcast(void)",
            "{",
            "\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);",
            "\treturn tick_do_broadcast(tmpmask);",
            "}",
            "static void tick_handle_periodic_broadcast(struct clock_event_device *dev)",
            "{",
            "\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);",
            "\tbool bc_local;",
            "",
            "\traw_spin_lock(&tick_broadcast_lock);",
            "",
            "\t/* Handle spurious interrupts gracefully */",
            "\tif (clockevent_state_shutdown(tick_broadcast_device.evtdev)) {",
            "\t\traw_spin_unlock(&tick_broadcast_lock);",
            "\t\treturn;",
            "\t}",
            "",
            "\tbc_local = tick_do_periodic_broadcast();",
            "",
            "\tif (clockevent_state_oneshot(dev)) {",
            "\t\tktime_t next = ktime_add_ns(dev->next_event, TICK_NSEC);",
            "",
            "\t\tclockevents_program_event(dev, next, true);",
            "\t}",
            "\traw_spin_unlock(&tick_broadcast_lock);",
            "",
            "\t/*",
            "\t * We run the handler of the local cpu after dropping",
            "\t * tick_broadcast_lock because the handler might deadlock when",
            "\t * trying to switch to oneshot mode.",
            "\t */",
            "\tif (bc_local)",
            "\t\ttd->evtdev->event_handler(td->evtdev);",
            "}",
            "void tick_broadcast_control(enum tick_broadcast_mode mode)",
            "{",
            "\tstruct clock_event_device *bc, *dev;",
            "\tstruct tick_device *td;",
            "\tint cpu, bc_stopped;",
            "\tunsigned long flags;",
            "",
            "\t/* Protects also the local clockevent device. */",
            "\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);",
            "\ttd = this_cpu_ptr(&tick_cpu_device);",
            "\tdev = td->evtdev;",
            "",
            "\t/*",
            "\t * Is the device not affected by the powerstate ?",
            "\t */",
            "\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_C3STOP))",
            "\t\tgoto out;",
            "",
            "\tif (!tick_device_is_functional(dev))",
            "\t\tgoto out;",
            "",
            "\tcpu = smp_processor_id();",
            "\tbc = tick_broadcast_device.evtdev;",
            "\tbc_stopped = cpumask_empty(tick_broadcast_mask);",
            "",
            "\tswitch (mode) {",
            "\tcase TICK_BROADCAST_FORCE:",
            "\t\ttick_broadcast_forced = 1;",
            "\t\tfallthrough;",
            "\tcase TICK_BROADCAST_ON:",
            "\t\tcpumask_set_cpu(cpu, tick_broadcast_on);",
            "\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_mask)) {",
            "\t\t\t/*",
            "\t\t\t * Only shutdown the cpu local device, if:",
            "\t\t\t *",
            "\t\t\t * - the broadcast device exists",
            "\t\t\t * - the broadcast device is not a hrtimer based one",
            "\t\t\t * - the broadcast device is in periodic mode to",
            "\t\t\t *   avoid a hiccup during switch to oneshot mode",
            "\t\t\t */",
            "\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER) &&",
            "\t\t\t    tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)",
            "\t\t\t\tclockevents_shutdown(dev);",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase TICK_BROADCAST_OFF:",
            "\t\tif (tick_broadcast_forced)",
            "\t\t\tbreak;",
            "\t\tcpumask_clear_cpu(cpu, tick_broadcast_on);",
            "\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_mask)) {",
            "\t\t\tif (tick_broadcast_device.mode ==",
            "\t\t\t    TICKDEV_MODE_PERIODIC)",
            "\t\t\t\ttick_setup_periodic(dev, 0);",
            "\t\t}",
            "\t\tbreak;",
            "\t}",
            "",
            "\tif (bc) {",
            "\t\tif (cpumask_empty(tick_broadcast_mask)) {",
            "\t\t\tif (!bc_stopped)",
            "\t\t\t\tclockevents_shutdown(bc);",
            "\t\t} else if (bc_stopped) {",
            "\t\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)",
            "\t\t\t\ttick_broadcast_start_periodic(bc);",
            "\t\t\telse",
            "\t\t\t\ttick_broadcast_setup_oneshot(bc, false);",
            "\t\t}",
            "\t}",
            "out:",
            "\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);",
            "}"
          ],
          "function_name": "tick_receive_broadcast, tick_do_broadcast, tick_do_periodic_broadcast, tick_handle_periodic_broadcast, tick_broadcast_control",
          "description": "实现广播中断接收、分发及控制逻辑，包含周期性广播处理、中断状态管理及广播模式开关操作，处理多CPU间同步与状态一致性保障。",
          "similarity": 0.6048421859741211
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 670,
          "end_line": 772,
          "content": [
            "void tick_check_oneshot_broadcast_this_cpu(void)",
            "{",
            "\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {",
            "\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);",
            "",
            "\t\t/*",
            "\t\t * We might be in the middle of switching over from",
            "\t\t * periodic to oneshot. If the CPU has not yet",
            "\t\t * switched over, leave the device alone.",
            "\t\t */",
            "\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {",
            "\t\t\tclockevents_switch_state(td->evtdev,",
            "\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);",
            "\t\t}",
            "\t}",
            "}",
            "static void tick_handle_oneshot_broadcast(struct clock_event_device *dev)",
            "{",
            "\tstruct tick_device *td;",
            "\tktime_t now, next_event;",
            "\tint cpu, next_cpu = 0;",
            "\tbool bc_local;",
            "",
            "\traw_spin_lock(&tick_broadcast_lock);",
            "\tdev->next_event = KTIME_MAX;",
            "\tnext_event = KTIME_MAX;",
            "\tcpumask_clear(tmpmask);",
            "\tnow = ktime_get();",
            "\t/* Find all expired events */",
            "\tfor_each_cpu(cpu, tick_broadcast_oneshot_mask) {",
            "\t\t/*",
            "\t\t * Required for !SMP because for_each_cpu() reports",
            "\t\t * unconditionally CPU0 as set on UP kernels.",
            "\t\t */",
            "\t\tif (!IS_ENABLED(CONFIG_SMP) &&",
            "\t\t    cpumask_empty(tick_broadcast_oneshot_mask))",
            "\t\t\tbreak;",
            "",
            "\t\ttd = &per_cpu(tick_cpu_device, cpu);",
            "\t\tif (td->evtdev->next_event <= now) {",
            "\t\t\tcpumask_set_cpu(cpu, tmpmask);",
            "\t\t\t/*",
            "\t\t\t * Mark the remote cpu in the pending mask, so",
            "\t\t\t * it can avoid reprogramming the cpu local",
            "\t\t\t * timer in tick_broadcast_oneshot_control().",
            "\t\t\t */",
            "\t\t\tcpumask_set_cpu(cpu, tick_broadcast_pending_mask);",
            "\t\t} else if (td->evtdev->next_event < next_event) {",
            "\t\t\tnext_event = td->evtdev->next_event;",
            "\t\t\tnext_cpu = cpu;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Remove the current cpu from the pending mask. The event is",
            "\t * delivered immediately in tick_do_broadcast() !",
            "\t */",
            "\tcpumask_clear_cpu(smp_processor_id(), tick_broadcast_pending_mask);",
            "",
            "\t/* Take care of enforced broadcast requests */",
            "\tcpumask_or(tmpmask, tmpmask, tick_broadcast_force_mask);",
            "\tcpumask_clear(tick_broadcast_force_mask);",
            "",
            "\t/*",
            "\t * Sanity check. Catch the case where we try to broadcast to",
            "\t * offline cpus.",
            "\t */",
            "\tif (WARN_ON_ONCE(!cpumask_subset(tmpmask, cpu_online_mask)))",
            "\t\tcpumask_and(tmpmask, tmpmask, cpu_online_mask);",
            "",
            "\t/*",
            "\t * Wakeup the cpus which have an expired event.",
            "\t */",
            "\tbc_local = tick_do_broadcast(tmpmask);",
            "",
            "\t/*",
            "\t * Two reasons for reprogram:",
            "\t *",
            "\t * - The global event did not expire any CPU local",
            "\t * events. This happens in dyntick mode, as the maximum PIT",
            "\t * delta is quite small.",
            "\t *",
            "\t * - There are pending events on sleeping CPUs which were not",
            "\t * in the event mask",
            "\t */",
            "\tif (next_event != KTIME_MAX)",
            "\t\ttick_broadcast_set_event(dev, next_cpu, next_event);",
            "",
            "\traw_spin_unlock(&tick_broadcast_lock);",
            "",
            "\tif (bc_local) {",
            "\t\ttd = this_cpu_ptr(&tick_cpu_device);",
            "\t\ttd->evtdev->event_handler(td->evtdev);",
            "\t}",
            "}",
            "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)",
            "{",
            "\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))",
            "\t\treturn 0;",
            "\tif (bc->next_event == KTIME_MAX)",
            "\t\treturn 0;",
            "\treturn bc->bound_on == cpu ? -EBUSY : 0;",
            "}"
          ],
          "function_name": "tick_check_oneshot_broadcast_this_cpu, tick_handle_oneshot_broadcast, broadcast_needs_cpu",
          "description": "tick_check_oneshot_broadcast_this_cpu检查当前CPU是否在单次广播掩码中，若处于单次模式则切换到CLOCK_EVT_STATE_ONESHOT状态；tick_handle_oneshot_broadcast遍历所有广播CPU寻找已到期事件，唤醒相应CPU并设置下次触发时间；broadcast_needs_cpu判断HRTIMER类型设备是否需要当前CPU处理",
          "similarity": 0.583011269569397
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 779,
          "end_line": 931,
          "content": [
            "static void broadcast_shutdown_local(struct clock_event_device *bc,",
            "\t\t\t\t     struct clock_event_device *dev)",
            "{",
            "\t/*",
            "\t * For hrtimer based broadcasting we cannot shutdown the cpu",
            "\t * local device if our own event is the first one to expire or",
            "\t * if we own the broadcast timer.",
            "\t */",
            "\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {",
            "\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))",
            "\t\t\treturn;",
            "\t\tif (dev->next_event < bc->next_event)",
            "\t\t\treturn;",
            "\t}",
            "\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);",
            "}",
            "static int ___tick_broadcast_oneshot_control(enum tick_broadcast_state state,",
            "\t\t\t\t\t     struct tick_device *td,",
            "\t\t\t\t\t     int cpu)",
            "{",
            "\tstruct clock_event_device *bc, *dev = td->evtdev;",
            "\tint ret = 0;",
            "\tktime_t now;",
            "",
            "\traw_spin_lock(&tick_broadcast_lock);",
            "\tbc = tick_broadcast_device.evtdev;",
            "",
            "\tif (state == TICK_BROADCAST_ENTER) {",
            "\t\t/*",
            "\t\t * If the current CPU owns the hrtimer broadcast",
            "\t\t * mechanism, it cannot go deep idle and we do not add",
            "\t\t * the CPU to the broadcast mask. We don't have to go",
            "\t\t * through the EXIT path as the local timer is not",
            "\t\t * shutdown.",
            "\t\t */",
            "\t\tret = broadcast_needs_cpu(bc, cpu);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "",
            "\t\t/*",
            "\t\t * If the broadcast device is in periodic mode, we",
            "\t\t * return.",
            "\t\t */",
            "\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {",
            "\t\t\t/* If it is a hrtimer based broadcast, return busy */",
            "\t\t\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER)",
            "\t\t\t\tret = -EBUSY;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_oneshot_mask)) {",
            "\t\t\tWARN_ON_ONCE(cpumask_test_cpu(cpu, tick_broadcast_pending_mask));",
            "",
            "\t\t\t/* Conditionally shut down the local timer. */",
            "\t\t\tbroadcast_shutdown_local(bc, dev);",
            "",
            "\t\t\t/*",
            "\t\t\t * We only reprogram the broadcast timer if we",
            "\t\t\t * did not mark ourself in the force mask and",
            "\t\t\t * if the cpu local event is earlier than the",
            "\t\t\t * broadcast event. If the current CPU is in",
            "\t\t\t * the force mask, then we are going to be",
            "\t\t\t * woken by the IPI right away; we return",
            "\t\t\t * busy, so the CPU does not try to go deep",
            "\t\t\t * idle.",
            "\t\t\t */",
            "\t\t\tif (cpumask_test_cpu(cpu, tick_broadcast_force_mask)) {",
            "\t\t\t\tret = -EBUSY;",
            "\t\t\t} else if (dev->next_event < bc->next_event) {",
            "\t\t\t\ttick_broadcast_set_event(bc, cpu, dev->next_event);",
            "\t\t\t\t/*",
            "\t\t\t\t * In case of hrtimer broadcasts the",
            "\t\t\t\t * programming might have moved the",
            "\t\t\t\t * timer to this cpu. If yes, remove",
            "\t\t\t\t * us from the broadcast mask and",
            "\t\t\t\t * return busy.",
            "\t\t\t\t */",
            "\t\t\t\tret = broadcast_needs_cpu(bc, cpu);",
            "\t\t\t\tif (ret) {",
            "\t\t\t\t\tcpumask_clear_cpu(cpu,",
            "\t\t\t\t\t\ttick_broadcast_oneshot_mask);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t} else {",
            "\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_oneshot_mask)) {",
            "\t\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);",
            "\t\t\t/*",
            "\t\t\t * The cpu which was handling the broadcast",
            "\t\t\t * timer marked this cpu in the broadcast",
            "\t\t\t * pending mask and fired the broadcast",
            "\t\t\t * IPI. So we are going to handle the expired",
            "\t\t\t * event anyway via the broadcast IPI",
            "\t\t\t * handler. No need to reprogram the timer",
            "\t\t\t * with an already expired event.",
            "\t\t\t */",
            "\t\t\tif (cpumask_test_and_clear_cpu(cpu,",
            "\t\t\t\t       tick_broadcast_pending_mask))",
            "\t\t\t\tgoto out;",
            "",
            "\t\t\t/*",
            "\t\t\t * Bail out if there is no next event.",
            "\t\t\t */",
            "\t\t\tif (dev->next_event == KTIME_MAX)",
            "\t\t\t\tgoto out;",
            "\t\t\t/*",
            "\t\t\t * If the pending bit is not set, then we are",
            "\t\t\t * either the CPU handling the broadcast",
            "\t\t\t * interrupt or we got woken by something else.",
            "\t\t\t *",
            "\t\t\t * We are no longer in the broadcast mask, so",
            "\t\t\t * if the cpu local expiry time is already",
            "\t\t\t * reached, we would reprogram the cpu local",
            "\t\t\t * timer with an already expired event.",
            "\t\t\t *",
            "\t\t\t * This can lead to a ping-pong when we return",
            "\t\t\t * to idle and therefore rearm the broadcast",
            "\t\t\t * timer before the cpu local timer was able",
            "\t\t\t * to fire. This happens because the forced",
            "\t\t\t * reprogramming makes sure that the event",
            "\t\t\t * will happen in the future and depending on",
            "\t\t\t * the min_delta setting this might be far",
            "\t\t\t * enough out that the ping-pong starts.",
            "\t\t\t *",
            "\t\t\t * If the cpu local next_event has expired",
            "\t\t\t * then we know that the broadcast timer",
            "\t\t\t * next_event has expired as well and",
            "\t\t\t * broadcast is about to be handled. So we",
            "\t\t\t * avoid reprogramming and enforce that the",
            "\t\t\t * broadcast handler, which did not run yet,",
            "\t\t\t * will invoke the cpu local handler.",
            "\t\t\t *",
            "\t\t\t * We cannot call the handler directly from",
            "\t\t\t * here, because we might be in a NOHZ phase",
            "\t\t\t * and we did not go through the irq_enter()",
            "\t\t\t * nohz fixups.",
            "\t\t\t */",
            "\t\t\tnow = ktime_get();",
            "\t\t\tif (dev->next_event <= now) {",
            "\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);",
            "\t\t\t\tgoto out;",
            "\t\t\t}",
            "\t\t\t/*",
            "\t\t\t * We got woken by something else. Reprogram",
            "\t\t\t * the cpu local timer device.",
            "\t\t\t */",
            "\t\t\ttick_program_event(dev->next_event, 1);",
            "\t\t}",
            "\t}",
            "out:",
            "\traw_spin_unlock(&tick_broadcast_lock);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "broadcast_shutdown_local, ___tick_broadcast_oneshot_control",
          "description": "broadcast_shutdown_local根据HRTIMER特征决定是否关闭本地定时器；___tick_broadcast_oneshot_control处理单次模式状态转换，包括CPU加入/移出广播掩码、本地定时器关闭及下次事件设置逻辑",
          "similarity": 0.5705206394195557
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 209,
          "end_line": 317,
          "content": [
            "int tick_is_broadcast_device(struct clock_event_device *dev)",
            "{",
            "\treturn (dev && tick_broadcast_device.evtdev == dev);",
            "}",
            "int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)",
            "{",
            "\tint ret = -ENODEV;",
            "",
            "\tif (tick_is_broadcast_device(dev)) {",
            "\t\traw_spin_lock(&tick_broadcast_lock);",
            "\t\tret = __clockevents_update_freq(dev, freq);",
            "\t\traw_spin_unlock(&tick_broadcast_lock);",
            "\t}",
            "\treturn ret;",
            "}",
            "static void err_broadcast(const struct cpumask *mask)",
            "{",
            "\tpr_crit_once(\"Failed to broadcast timer tick. Some CPUs may be unresponsive.\\n\");",
            "}",
            "static void tick_device_setup_broadcast_func(struct clock_event_device *dev)",
            "{",
            "\tif (!dev->broadcast)",
            "\t\tdev->broadcast = tick_broadcast;",
            "\tif (!dev->broadcast) {",
            "\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",",
            "\t\t\t     dev->name);",
            "\t\tdev->broadcast = err_broadcast;",
            "\t}",
            "}",
            "int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)",
            "{",
            "\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;",
            "\tunsigned long flags;",
            "\tint ret = 0;",
            "",
            "\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);",
            "",
            "\t/*",
            "\t * Devices might be registered with both periodic and oneshot",
            "\t * mode disabled. This signals, that the device needs to be",
            "\t * operated from the broadcast device and is a placeholder for",
            "\t * the cpu local device.",
            "\t */",
            "\tif (!tick_device_is_functional(dev)) {",
            "\t\tdev->event_handler = tick_handle_periodic;",
            "\t\ttick_device_setup_broadcast_func(dev);",
            "\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);",
            "\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)",
            "\t\t\ttick_broadcast_start_periodic(bc);",
            "\t\telse",
            "\t\t\ttick_broadcast_setup_oneshot(bc, false);",
            "\t\tret = 1;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Clear the broadcast bit for this cpu if the",
            "\t\t * device is not power state affected.",
            "\t\t */",
            "\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))",
            "\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);",
            "\t\telse",
            "\t\t\ttick_device_setup_broadcast_func(dev);",
            "",
            "\t\t/*",
            "\t\t * Clear the broadcast bit if the CPU is not in",
            "\t\t * periodic broadcast on state.",
            "\t\t */",
            "\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))",
            "\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);",
            "",
            "\t\tswitch (tick_broadcast_device.mode) {",
            "\t\tcase TICKDEV_MODE_ONESHOT:",
            "\t\t\t/*",
            "\t\t\t * If the system is in oneshot mode we can",
            "\t\t\t * unconditionally clear the oneshot mask bit,",
            "\t\t\t * because the CPU is running and therefore",
            "\t\t\t * not in an idle state which causes the power",
            "\t\t\t * state affected device to stop. Let the",
            "\t\t\t * caller initialize the device.",
            "\t\t\t */",
            "\t\t\ttick_broadcast_clear_oneshot(cpu);",
            "\t\t\tret = 0;",
            "\t\t\tbreak;",
            "",
            "\t\tcase TICKDEV_MODE_PERIODIC:",
            "\t\t\t/*",
            "\t\t\t * If the system is in periodic mode, check",
            "\t\t\t * whether the broadcast device can be",
            "\t\t\t * switched off now.",
            "\t\t\t */",
            "\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)",
            "\t\t\t\tclockevents_shutdown(bc);",
            "\t\t\t/*",
            "\t\t\t * If we kept the cpu in the broadcast mask,",
            "\t\t\t * tell the caller to leave the per cpu device",
            "\t\t\t * in shutdown state. The periodic interrupt",
            "\t\t\t * is delivered by the broadcast device, if",
            "\t\t\t * the broadcast device exists and is not",
            "\t\t\t * hrtimer based.",
            "\t\t\t */",
            "\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))",
            "\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "tick_is_broadcast_device, tick_broadcast_update_freq, err_broadcast, tick_device_setup_broadcast_func, tick_device_uses_broadcast",
          "description": "提供广播设备识别、频率更新及设备功能设置接口，动态调整CPU广播掩码并根据设备特性选择处理方式，处理设备功能缺失时的备用方案。",
          "similarity": 0.559428334236145
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 1,
          "end_line": 44,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * This file contains functions which emulate a local clock-event",
            " * device via a broadcast event source.",
            " *",
            " * Copyright(C) 2005-2006, Thomas Gleixner <tglx@linutronix.de>",
            " * Copyright(C) 2005-2007, Red Hat, Inc., Ingo Molnar",
            " * Copyright(C) 2006-2007, Timesys Corp., Thomas Gleixner",
            " */",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "",
            "#include \"tick-internal.h\"",
            "",
            "/*",
            " * Broadcast support for broken x86 hardware, where the local apic",
            " * timer stops in C3 state.",
            " */",
            "",
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask __cpumask_var_read_mostly;",
            "static cpumask_var_t tick_broadcast_on __cpumask_var_read_mostly;",
            "static cpumask_var_t tmpmask __cpumask_var_read_mostly;",
            "static int tick_broadcast_forced;",
            "",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
            "",
            "#ifdef CONFIG_TICK_ONESHOT",
            "static DEFINE_PER_CPU(struct clock_event_device *, tick_oneshot_wakeup_device);",
            "",
            "static void tick_broadcast_setup_oneshot(struct clock_event_device *bc, bool from_periodic);",
            "static void tick_broadcast_clear_oneshot(int cpu);",
            "static void tick_resume_broadcast_oneshot(struct clock_event_device *bc);",
            "# ifdef CONFIG_HOTPLUG_CPU",
            "static void tick_broadcast_oneshot_offline(unsigned int cpu);",
            "# endif",
            "#else"
          ],
          "function_name": null,
          "description": "定义广播时钟设备所需的数据结构和锁，支持x86硬件中因C3状态导致本地APIC定时器停转的问题，包含广播设备、掩码及锁的全局变量，条件编译部分未展开。",
          "similarity": 0.5543908476829529
        }
      ]
    }
  ]
}