{
  "query": "IPC机制",
  "timestamp": "2025-12-26 01:14:06",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/ipi-mux.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:57:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\ipi-mux.c`\n\n---\n\n# `irq/ipi-mux.c` 技术文档\n\n## 1. 文件概述\n\n`ipi-mux.c` 实现了一个虚拟 IPI（Inter-Processor Interrupt，处理器间中断）多路复用机制，允许多个逻辑 IPI 共享一个底层硬件 IPI。该机制通过软件方式在每个 CPU 上维护一个位图，记录哪些虚拟 IPI 处于挂起（pending）或使能（enabled）状态，并在需要时触发底层硬件 IPI。此设计适用于硬件 IPI 资源受限但需要支持多个逻辑 IPI 的系统架构（如某些 RISC-V 或定制 SoC 平台）。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct ipi_mux_cpu`**  \n  每个 CPU 的私有状态结构，包含两个原子变量：\n  - `enable`：表示当前 CPU 上哪些虚拟 IPI 已被使能（unmasked）。\n  - `bits`：表示当前 CPU 上哪些虚拟 IPI 处于挂起状态（pending）。\n\n- **全局变量**\n  - `ipi_mux_pcpu`：指向 per-CPU 的 `ipi_mux_cpu` 实例。\n  - `ipi_mux_domain`：指向虚拟 IPI 的 IRQ domain。\n  - `ipi_mux_send`：回调函数，用于向指定 CPU 发送底层硬件 IPI。\n\n### 主要函数\n\n- **`ipi_mux_mask()` / `ipi_mux_unmask()`**  \n  实现虚拟 IPI 的屏蔽与解除屏蔽逻辑，通过操作 `enable` 字段控制中断使能状态。\n\n- **`ipi_mux_send_mask()`**  \n  实现 `ipi_send_mask` 接口，用于向指定 CPU 集合发送特定虚拟 IPI。通过设置 `bits` 字段标记挂起状态，并在必要时触发底层 IPI。\n\n- **`ipi_mux_process()`**  \n  在底层 IPI 中断处理上下文中调用，读取并清除当前 CPU 的挂起虚拟 IPI 位图，并调用对应的中断处理程序。\n\n- **`ipi_mux_create()`**  \n  初始化整个虚拟 IPI 多路复用系统，包括分配 per-CPU 数据、创建 IRQ domain、分配虚拟 IRQ 号，并注册回调函数。\n\n### IRQ 芯片与 Domain 操作\n\n- **`ipi_mux_chip`**：定义了虚拟 IPI 的 `irq_chip` 操作集。\n- **`ipi_mux_domain_ops`**：定义了 IRQ domain 的分配与释放操作。\n\n## 3. 关键实现\n\n### 虚拟 IPI 状态管理\n\n每个 CPU 维护两个位图：\n- `enable`：记录哪些虚拟 IPI 当前被允许触发（即未被 mask）。\n- `bits`：记录哪些虚拟 IPI 已被请求但尚未处理（pending）。\n\n当调用 `ipi_send_mask()` 时，对应位被置入 `bits`；若该位同时在 `enable` 中置位，则立即触发底层 IPI。\n\n### 内存顺序与同步\n\n- 使用 `atomic_fetch_or_release()` 和 `smp_mb__after_atomic()` 确保：\n  - 对 `bits` 的写入在读取 `enable` 之前完成，避免与 `ipi_mux_unmask()` 竞争。\n  - 虚拟 IPI 标志的设置在触发底层 IPI 前对目标 CPU 可见。\n- 在 `ipi_mux_process()` 中使用 `atomic_fetch_andnot()` 原子地清除已使能且挂起的位，确保中断处理的精确性。\n\n### 中断处理流程\n\n1. 软件调用 `ipi_send_mask()` 发送虚拟 IPI。\n2. 目标 CPU 的 `bits` 对应位置位；若已使能，则调用 `ipi_mux_send()` 触发硬件 IPI。\n3. 硬件 IPI 到达后，调用 `ipi_mux_process()`。\n4. `ipi_mux_process()` 读取 `enable` 与 `bits`，计算需处理的虚拟 IPI 集合，并调用 `generic_handle_domain_irq()` 分发至对应处理函数。\n\n### IRQ Domain 管理\n\n- 使用线性 IRQ domain，虚拟 IPI 的 `hwirq` 编号从 0 开始连续分配。\n- 设置 `IRQ_DOMAIN_FLAG_IPI_SINGLE` 和 `DOMAIN_BUS_IPI` 标志，表明该 domain 专用于 IPI。\n- 每个虚拟 IPI 被配置为 per-CPU 中断（`irq_set_percpu_devid`），使用 `handle_percpu_devid_irq` 处理器。\n\n## 4. 依赖关系\n\n- **`<linux/irq.h>` / `<linux/irqdomain.h>`**：IRQ 子系统核心接口，用于注册 IRQ domain 和管理中断。\n- **`<linux/irqchip/chained_irq.h>`**：提供链式中断处理支持（虽未直接使用，但属于 IPI 架构上下文）。\n- **`<linux/percpu.h>`**：用于分配和访问 per-CPU 数据结构。\n- **`<linux/smp.h>` / `<linux/cpu.h>`**：SMP 相关功能，如 CPU 掩码遍历和处理器 ID 获取。\n- **`<linux/jump_label.h>`**：可能用于优化（当前未显式使用，但包含在头文件中）。\n- **底层平台代码**：必须提供 `mux_send` 回调函数，用于实际触发硬件 IPI。\n\n## 5. 使用场景\n\n- **硬件 IPI 资源受限的 SoC**：当物理 IPI 通道数量少于所需逻辑中断类型时（如仅 1 个硬件 IPI 但需支持 timer、reschedule、call-function 等多种 IPI），使用此机制进行软件复用。\n- **RISC-V 或定制架构平台**：如 Asahi Linux（Apple Silicon）或 Ventana Micro 的 RISC-V 实现，这些平台可能缺乏丰富的硬件 IPI 支持。\n- **内核 SMP 初始化阶段**：在 `ipi_mux_create()` 成功后，其他子系统（如调度器、RCU）可通过分配的虚拟 IPI 实现跨 CPU 通信。\n- **替代传统 IPI 向量机制**：在不支持多向量 IPI 的架构上，提供类似 x86 的多类型 IPI 功能。",
      "similarity": 0.5621917247772217,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/ipi-mux.c",
          "start_line": 29,
          "end_line": 176,
          "content": [
            "static void ipi_mux_mask(struct irq_data *d)",
            "{",
            "\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);",
            "",
            "\tatomic_andnot(BIT(irqd_to_hwirq(d)), &icpu->enable);",
            "}",
            "static void ipi_mux_unmask(struct irq_data *d)",
            "{",
            "\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);",
            "\tu32 ibit = BIT(irqd_to_hwirq(d));",
            "",
            "\tatomic_or(ibit, &icpu->enable);",
            "",
            "\t/*",
            "\t * The atomic_or() above must complete before the atomic_read()",
            "\t * below to avoid racing ipi_mux_send_mask().",
            "\t */",
            "\tsmp_mb__after_atomic();",
            "",
            "\t/* If a pending IPI was unmasked, raise a parent IPI immediately. */",
            "\tif (atomic_read(&icpu->bits) & ibit)",
            "\t\tipi_mux_send(smp_processor_id());",
            "}",
            "static void ipi_mux_send_mask(struct irq_data *d, const struct cpumask *mask)",
            "{",
            "\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);",
            "\tu32 ibit = BIT(irqd_to_hwirq(d));",
            "\tunsigned long pending;",
            "\tint cpu;",
            "",
            "\tfor_each_cpu(cpu, mask) {",
            "\t\ticpu = per_cpu_ptr(ipi_mux_pcpu, cpu);",
            "",
            "\t\t/*",
            "\t\t * This sequence is the mirror of the one in ipi_mux_unmask();",
            "\t\t * see the comment there. Additionally, release semantics",
            "\t\t * ensure that the vIPI flag set is ordered after any shared",
            "\t\t * memory accesses that precede it. This therefore also pairs",
            "\t\t * with the atomic_fetch_andnot in ipi_mux_process().",
            "\t\t */",
            "\t\tpending = atomic_fetch_or_release(ibit, &icpu->bits);",
            "",
            "\t\t/*",
            "\t\t * The atomic_fetch_or_release() above must complete",
            "\t\t * before the atomic_read() below to avoid racing with",
            "\t\t * ipi_mux_unmask().",
            "\t\t */",
            "\t\tsmp_mb__after_atomic();",
            "",
            "\t\t/*",
            "\t\t * The flag writes must complete before the physical IPI is",
            "\t\t * issued to another CPU. This is implied by the control",
            "\t\t * dependency on the result of atomic_read() below, which is",
            "\t\t * itself already ordered after the vIPI flag write.",
            "\t\t */",
            "\t\tif (!(pending & ibit) && (atomic_read(&icpu->enable) & ibit))",
            "\t\t\tipi_mux_send(cpu);",
            "\t}",
            "}",
            "static int ipi_mux_domain_alloc(struct irq_domain *d, unsigned int virq,",
            "\t\t\t\tunsigned int nr_irqs, void *arg)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < nr_irqs; i++) {",
            "\t\tirq_set_percpu_devid(virq + i);",
            "\t\tirq_domain_set_info(d, virq + i, i, &ipi_mux_chip, NULL,",
            "\t\t\t\t    handle_percpu_devid_irq, NULL, NULL);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void ipi_mux_process(void)",
            "{",
            "\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);",
            "\tirq_hw_number_t hwirq;",
            "\tunsigned long ipis;",
            "\tunsigned int en;",
            "",
            "\t/*",
            "\t * Reading enable mask does not need to be ordered as long as",
            "\t * this function is called from interrupt handler because only",
            "\t * the CPU itself can change it's own enable mask.",
            "\t */",
            "\ten = atomic_read(&icpu->enable);",
            "",
            "\t/*",
            "\t * Clear the IPIs we are about to handle. This pairs with the",
            "\t * atomic_fetch_or_release() in ipi_mux_send_mask().",
            "\t */",
            "\tipis = atomic_fetch_andnot(en, &icpu->bits) & en;",
            "",
            "\tfor_each_set_bit(hwirq, &ipis, BITS_PER_TYPE(int))",
            "\t\tgeneric_handle_domain_irq(ipi_mux_domain, hwirq);",
            "}",
            "int ipi_mux_create(unsigned int nr_ipi, void (*mux_send)(unsigned int cpu))",
            "{",
            "\tstruct fwnode_handle *fwnode;",
            "\tstruct irq_domain *domain;",
            "\tint rc;",
            "",
            "\tif (ipi_mux_domain)",
            "\t\treturn -EEXIST;",
            "",
            "\tif (BITS_PER_TYPE(int) < nr_ipi || !mux_send)",
            "\t\treturn -EINVAL;",
            "",
            "\tipi_mux_pcpu = alloc_percpu(typeof(*ipi_mux_pcpu));",
            "\tif (!ipi_mux_pcpu)",
            "\t\treturn -ENOMEM;",
            "",
            "\tfwnode = irq_domain_alloc_named_fwnode(\"IPI-Mux\");",
            "\tif (!fwnode) {",
            "\t\tpr_err(\"unable to create IPI Mux fwnode\\n\");",
            "\t\trc = -ENOMEM;",
            "\t\tgoto fail_free_cpu;",
            "\t}",
            "",
            "\tdomain = irq_domain_create_linear(fwnode, nr_ipi,",
            "\t\t\t\t\t  &ipi_mux_domain_ops, NULL);",
            "\tif (!domain) {",
            "\t\tpr_err(\"unable to add IPI Mux domain\\n\");",
            "\t\trc = -ENOMEM;",
            "\t\tgoto fail_free_fwnode;",
            "\t}",
            "",
            "\tdomain->flags |= IRQ_DOMAIN_FLAG_IPI_SINGLE;",
            "\tirq_domain_update_bus_token(domain, DOMAIN_BUS_IPI);",
            "",
            "\trc = irq_domain_alloc_irqs(domain, nr_ipi, NUMA_NO_NODE, NULL);",
            "\tif (rc <= 0) {",
            "\t\tpr_err(\"unable to alloc IRQs from IPI Mux domain\\n\");",
            "\t\tgoto fail_free_domain;",
            "\t}",
            "",
            "\tipi_mux_domain = domain;",
            "\tipi_mux_send = mux_send;",
            "",
            "\treturn rc;",
            "",
            "fail_free_domain:",
            "\tirq_domain_remove(domain);",
            "fail_free_fwnode:",
            "\tirq_domain_free_fwnode(fwnode);",
            "fail_free_cpu:",
            "\tfree_percpu(ipi_mux_pcpu);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "ipi_mux_mask, ipi_mux_unmask, ipi_mux_send_mask, ipi_mux_domain_alloc, ipi_mux_process, ipi_mux_create",
          "description": "实现了IPI多路复用器的核心逻辑，包括中断屏蔽/解除屏蔽操作、批量发送IPI标记、中断域分配、中断处理流程及初始化创建函数，通过原子操作和内存屏障保证跨CPU状态同步与顺序性。",
          "similarity": 0.5238648653030396
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/ipi-mux.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Multiplex several virtual IPIs over a single HW IPI.",
            " *",
            " * Copyright The Asahi Linux Contributors",
            " * Copyright (c) 2022 Ventana Micro Systems Inc.",
            " */",
            "",
            "#define pr_fmt(fmt) \"ipi-mux: \" fmt",
            "#include <linux/cpu.h>",
            "#include <linux/init.h>",
            "#include <linux/irq.h>",
            "#include <linux/irqchip.h>",
            "#include <linux/irqchip/chained_irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/percpu.h>",
            "#include <linux/smp.h>",
            "",
            "struct ipi_mux_cpu {",
            "\tatomic_t\t\t\tenable;",
            "\tatomic_t\t\t\tbits;",
            "};",
            "",
            "static struct ipi_mux_cpu __percpu *ipi_mux_pcpu;",
            "static struct irq_domain *ipi_mux_domain;",
            "static void (*ipi_mux_send)(unsigned int cpu);",
            ""
          ],
          "function_name": null,
          "description": "定义了用于多路复用虚拟IPI的CPU状态结构体ipi_mux_cpu，包含启用位掩码和位计数器。声明了全局的per-CPU指针数组ipi_mux_pcpu，中断域ipi_mux_domain，及发送回调函数指针ipi_mux_send。",
          "similarity": 0.47911781072616577
        }
      ]
    },
    {
      "source_file": "kernel/irq/ipi.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:58:10\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\ipi.c`\n\n---\n\n# `irq/ipi.c` 技术文档\n\n## 1. 文件概述\n\n`irq/ipi.c` 是 Linux 内核通用中断子系统（genirq）中用于管理处理器间中断（Inter-Processor Interrupt, IPI）的核心实现文件。该文件提供了一套统一的 API，用于在多核系统中动态分配、释放和发送 IPI。它抽象了底层硬件差异，支持两种 IPI 实现模式：\n- **单硬件中断模式（single IPI）**：所有 CPU 共享同一个硬件中断号；\n- **每 CPU 硬件中断模式（per-CPU IPI）**：每个 CPU 拥有独立的硬件中断号。\n\n该文件为架构无关的 IPI 管理提供了基础支持，使上层驱动或核心代码能够以统一方式使用 IPI 功能。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `irq_reserve_ipi()` | 为指定 CPU 掩码分配一个或多个 Linux 虚拟 IRQ（virq），用于后续发送 IPI |\n| `irq_destroy_ipi()` | 释放之前通过 `irq_reserve_ipi()` 分配的 IPI 资源 |\n| `ipi_get_hwirq()` | 获取指定 CPU 对应的硬件中断号（hwirq），用于协处理器通信等场景 |\n| `__ipi_send_single()` | 向单个目标 CPU 发送 IPI（仅供架构或核心代码使用） |\n| `__ipi_send_mask()` | 向多个目标 CPU（通过 cpumask 指定）发送 IPI（仅供架构或核心代码使用） |\n\n### 辅助函数\n\n- `ipi_send_verify()`：验证 IPI 发送参数的合法性（仅在 DEBUG 模式下启用完整检查）\n\n### 关键数据结构字段（扩展）\n\n- `struct irq_common_data::ipi_offset`：记录 IPI 分配时的起始 CPU 编号，用于 per-CPU 模式下计算偏移\n- `IRQ_NO_BALANCING`：设置该标志防止中断负载均衡器迁移 IPI\n\n## 3. 关键实现\n\n### IPI 分配策略\n\n- **单中断模式（`irq_domain_is_ipi_single`）**：\n  - 无论目标 CPU 掩码包含多少 CPU，仅分配 **1 个 virq**\n  - 底层 `irq_chip` 负责处理多 CPU 目标路由\n  - 允许目标掩码存在“空洞”（非连续 CPU）\n\n- **每 CPU 中断模式（`irq_domain_is_ipi_per_cpu`）**：\n  - 为每个目标 CPU 分配独立的 virq（数量 = `cpumask_weight(dest)`）\n  - **要求目标 CPU 掩码必须连续**（无空洞），否则返回 `-EINVAL`\n  - 使用 `ipi_offset = cpumask_first(dest)` 作为基准偏移量\n\n### 中断亲和性设置\n\n在 `irq_reserve_ipi()` 中，为每个分配的 virq 设置：\n```c\ncpumask_copy(data->common->affinity, dest);\ndata->common->ipi_offset = offset;\nirq_set_status_flags(virq + i, IRQ_NO_BALANCING);\n```\n确保中断仅在指定 CPU 上处理，且不会被内核的中断均衡机制迁移。\n\n### IPI 发送机制\n\n- 优先使用 `chip->ipi_send_mask()`（批量发送）\n- 若不支持，则回退到循环调用 `chip->ipi_send_single()`\n- 在 per-CPU 模式下，需根据目标 CPU 动态计算对应的 `irq_data`：\n  ```c\n  data = irq_get_irq_data(irq + cpu - data->common->ipi_offset);\n  ```\n\n### 错误处理与资源回收\n\n- 分配失败时通过 `goto free_descs` 回收已分配的中断描述符\n- 严格校验输入参数（如 CPU 掩码是否在 `cpu_possible_mask` 范围内）\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/irqdomain.h>`：提供 `irq_domain` 操作接口和 IPI 域类型判断宏（如 `irq_domain_is_ipi_*`）\n- `<linux/irq.h>`：提供中断核心 API（如 `irq_alloc_descs`, `irq_get_irq_data` 等）\n\n### 内核子系统依赖\n- **通用中断子系统（genirq）**：依赖其虚拟 IRQ 管理、中断域（irqdomain）和中断芯片（irqchip）抽象\n- **CPU 掩码操作**：依赖 `cpumask_*` 系列函数进行 CPU 集合操作\n- **NUMA 支持**：使用 `NUMA_NO_NODE` 表示无特定 NUMA 节点偏好\n\n### 导出符号\n- `ipi_get_hwirq` 通过 `EXPORT_SYMBOL_GPL` 导出，供其他 GPL 模块使用\n\n## 5. 使用场景\n\n### 典型使用流程\n1. **分配 IPI**：驱动或核心代码调用 `irq_reserve_ipi(domain, dest_mask)` 获取 virq\n2. **注册处理函数**：使用 `request_irq()` 或 `irq_set_handler()` 设置 IPI 处理回调\n3. **发送 IPI**：\n   - 架构代码调用 `__ipi_send_single()` / `__ipi_send_mask()`\n   - 或通过标准中断触发机制（如 `raise_softirq()` 底层可能使用 IPI）\n4. **释放资源**：调用 `irq_destroy_ipi()` 释放 virq\n\n### 具体应用场景\n- **SMP 核心功能**：如调度器负载均衡、TLB 刷新、CPU 热插拔通知\n- **自定义 IPI 驱动**：如某些 SoC 的私有消息传递机制\n- **协处理器通信**：通过 `ipi_get_hwirq()` 获取 hwirq 供协处理器使用\n- **实时内核扩展**：实现低延迟核间通信\n\n> **注意**：`__ipi_send_*` 系列函数明确标注“**不可用于驱动代码**”，仅限可信的架构或核心代码调用，以避免安全性和稳定性问题。",
      "similarity": 0.5395292639732361,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/ipi.c",
          "start_line": 23,
          "end_line": 140,
          "content": [
            "int irq_reserve_ipi(struct irq_domain *domain,",
            "\t\t\t     const struct cpumask *dest)",
            "{",
            "\tunsigned int nr_irqs, offset;",
            "\tstruct irq_data *data;",
            "\tint virq, i;",
            "",
            "\tif (!domain ||!irq_domain_is_ipi(domain)) {",
            "\t\tpr_warn(\"Reservation on a non IPI domain\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (!cpumask_subset(dest, cpu_possible_mask)) {",
            "\t\tpr_warn(\"Reservation is not in possible_cpu_mask\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tnr_irqs = cpumask_weight(dest);",
            "\tif (!nr_irqs) {",
            "\t\tpr_warn(\"Reservation for empty destination mask\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (irq_domain_is_ipi_single(domain)) {",
            "\t\t/*",
            "\t\t * If the underlying implementation uses a single HW irq on",
            "\t\t * all cpus then we only need a single Linux irq number for",
            "\t\t * it. We have no restrictions vs. the destination mask. The",
            "\t\t * underlying implementation can deal with holes nicely.",
            "\t\t */",
            "\t\tnr_irqs = 1;",
            "\t\toffset = 0;",
            "\t} else {",
            "\t\tunsigned int next;",
            "",
            "\t\t/*",
            "\t\t * The IPI requires a separate HW irq on each CPU. We require",
            "\t\t * that the destination mask is consecutive. If an",
            "\t\t * implementation needs to support holes, it can reserve",
            "\t\t * several IPI ranges.",
            "\t\t */",
            "\t\toffset = cpumask_first(dest);",
            "\t\t/*",
            "\t\t * Find a hole and if found look for another set bit after the",
            "\t\t * hole. For now we don't support this scenario.",
            "\t\t */",
            "\t\tnext = cpumask_next_zero(offset, dest);",
            "\t\tif (next < nr_cpu_ids)",
            "\t\t\tnext = cpumask_next(next, dest);",
            "\t\tif (next < nr_cpu_ids) {",
            "\t\t\tpr_warn(\"Destination mask has holes\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\tvirq = irq_domain_alloc_descs(-1, nr_irqs, 0, NUMA_NO_NODE, NULL);",
            "\tif (virq <= 0) {",
            "\t\tpr_warn(\"Can't reserve IPI, failed to alloc descs\\n\");",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tvirq = __irq_domain_alloc_irqs(domain, virq, nr_irqs, NUMA_NO_NODE,",
            "\t\t\t\t       (void *) dest, true, NULL);",
            "",
            "\tif (virq <= 0) {",
            "\t\tpr_warn(\"Can't reserve IPI, failed to alloc hw irqs\\n\");",
            "\t\tgoto free_descs;",
            "\t}",
            "",
            "\tfor (i = 0; i < nr_irqs; i++) {",
            "\t\tdata = irq_get_irq_data(virq + i);",
            "\t\tcpumask_copy(data->common->affinity, dest);",
            "\t\tdata->common->ipi_offset = offset;",
            "\t\tirq_set_status_flags(virq + i, IRQ_NO_BALANCING);",
            "\t}",
            "\treturn virq;",
            "",
            "free_descs:",
            "\tirq_free_descs(virq, nr_irqs);",
            "\treturn -EBUSY;",
            "}",
            "int irq_destroy_ipi(unsigned int irq, const struct cpumask *dest)",
            "{",
            "\tstruct irq_data *data = irq_get_irq_data(irq);",
            "\tconst struct cpumask *ipimask;",
            "\tstruct irq_domain *domain;",
            "\tunsigned int nr_irqs;",
            "",
            "\tif (!irq || !data)",
            "\t\treturn -EINVAL;",
            "",
            "\tdomain = data->domain;",
            "\tif (WARN_ON(domain == NULL))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!irq_domain_is_ipi(domain)) {",
            "\t\tpr_warn(\"Trying to destroy a non IPI domain!\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tipimask = irq_data_get_affinity_mask(data);",
            "\tif (!ipimask || WARN_ON(!cpumask_subset(dest, ipimask)))",
            "\t\t/*",
            "\t\t * Must be destroying a subset of CPUs to which this IPI",
            "\t\t * was set up to target",
            "\t\t */",
            "\t\treturn -EINVAL;",
            "",
            "\tif (irq_domain_is_ipi_per_cpu(domain)) {",
            "\t\tirq = irq + cpumask_first(dest) - data->common->ipi_offset;",
            "\t\tnr_irqs = cpumask_weight(dest);",
            "\t} else {",
            "\t\tnr_irqs = 1;",
            "\t}",
            "",
            "\tirq_domain_free_irqs(irq, nr_irqs);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "irq_reserve_ipi, irq_destroy_ipi",
          "description": "实现irq_reserve_ipi分配IPI中断资源并设置亲和性，irq_destroy_ipi释放已分配的IPI中断资源",
          "similarity": 0.5392274856567383
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/ipi.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2015 Imagination Technologies Ltd",
            " * Author: Qais Yousef <qais.yousef@imgtec.com>",
            " *",
            " * This file contains driver APIs to the IPI subsystem.",
            " */",
            "",
            "#define pr_fmt(fmt) \"genirq/ipi: \" fmt",
            "",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "",
            "/**",
            " * irq_reserve_ipi() - Setup an IPI to destination cpumask",
            " * @domain:\tIPI domain",
            " * @dest:\tcpumask of CPUs which can receive the IPI",
            " *",
            " * Allocate a virq that can be used to send IPI to any CPU in dest mask.",
            " *",
            " * Return: Linux IRQ number on success or error code on failure",
            " */"
          ],
          "function_name": null,
          "description": "定义irq_reserve_ipi函数原型，用于为指定CPU掩码分配IPI中断，返回Linux IRQ编号或错误码",
          "similarity": 0.5049498081207275
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/ipi.c",
          "start_line": 313,
          "end_line": 334,
          "content": [
            "int ipi_send_single(unsigned int virq, unsigned int cpu)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(virq);",
            "\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;",
            "\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;",
            "",
            "\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn __ipi_send_single(desc, cpu);",
            "}",
            "int ipi_send_mask(unsigned int virq, const struct cpumask *dest)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(virq);",
            "\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;",
            "\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;",
            "",
            "\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn __ipi_send_mask(desc, dest);",
            "}"
          ],
          "function_name": "ipi_send_single, ipi_send_mask",
          "description": "提供ipi_send_single/ipi_send_mask接口函数，封装IPI发送操作并执行参数验证",
          "similarity": 0.4992123544216156
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/ipi.c",
          "start_line": 163,
          "end_line": 277,
          "content": [
            "irq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu)",
            "{",
            "\tstruct irq_data *data = irq_get_irq_data(irq);",
            "\tconst struct cpumask *ipimask;",
            "",
            "\tif (!data || cpu >= nr_cpu_ids)",
            "\t\treturn INVALID_HWIRQ;",
            "",
            "\tipimask = irq_data_get_affinity_mask(data);",
            "\tif (!ipimask || !cpumask_test_cpu(cpu, ipimask))",
            "\t\treturn INVALID_HWIRQ;",
            "",
            "\t/*",
            "\t * Get the real hardware irq number if the underlying implementation",
            "\t * uses a separate irq per cpu. If the underlying implementation uses",
            "\t * a single hardware irq for all cpus then the IPI send mechanism",
            "\t * needs to take care of the cpu destinations.",
            "\t */",
            "\tif (irq_domain_is_ipi_per_cpu(data->domain))",
            "\t\tdata = irq_get_irq_data(irq + cpu - data->common->ipi_offset);",
            "",
            "\treturn data ? irqd_to_hwirq(data) : INVALID_HWIRQ;",
            "}",
            "static int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,",
            "\t\t\t   const struct cpumask *dest, unsigned int cpu)",
            "{",
            "\tconst struct cpumask *ipimask;",
            "",
            "\tif (!chip || !data)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!chip->ipi_send_single && !chip->ipi_send_mask)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (cpu >= nr_cpu_ids)",
            "\t\treturn -EINVAL;",
            "",
            "\tipimask = irq_data_get_affinity_mask(data);",
            "\tif (!ipimask)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (dest) {",
            "\t\tif (!cpumask_subset(dest, ipimask))",
            "\t\t\treturn -EINVAL;",
            "\t} else {",
            "\t\tif (!cpumask_test_cpu(cpu, ipimask))",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "int __ipi_send_single(struct irq_desc *desc, unsigned int cpu)",
            "{",
            "\tstruct irq_data *data = irq_desc_get_irq_data(desc);",
            "\tstruct irq_chip *chip = irq_data_get_irq_chip(data);",
            "",
            "#ifdef DEBUG",
            "\t/*",
            "\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.",
            "\t * Since the callers should be arch or core code which is generally",
            "\t * trusted, only check for errors when debugging.",
            "\t */",
            "\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))",
            "\t\treturn -EINVAL;",
            "#endif",
            "\tif (!chip->ipi_send_single) {",
            "\t\tchip->ipi_send_mask(data, cpumask_of(cpu));",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* FIXME: Store this information in irqdata flags */",
            "\tif (irq_domain_is_ipi_per_cpu(data->domain) &&",
            "\t    cpu != data->common->ipi_offset) {",
            "\t\t/* use the correct data for that cpu */",
            "\t\tunsigned irq = data->irq + cpu - data->common->ipi_offset;",
            "",
            "\t\tdata = irq_get_irq_data(irq);",
            "\t}",
            "\tchip->ipi_send_single(data, cpu);",
            "\treturn 0;",
            "}",
            "int __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest)",
            "{",
            "\tstruct irq_data *data = irq_desc_get_irq_data(desc);",
            "\tstruct irq_chip *chip = irq_data_get_irq_chip(data);",
            "\tunsigned int cpu;",
            "",
            "#ifdef DEBUG",
            "\t/*",
            "\t * Minimise the overhead by omitting the checks for Linux SMP IPIs.",
            "\t * Since the callers should be arch or core code which is generally",
            "\t * trusted, only check for errors when debugging.",
            "\t */",
            "\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))",
            "\t\treturn -EINVAL;",
            "#endif",
            "\tif (chip->ipi_send_mask) {",
            "\t\tchip->ipi_send_mask(data, dest);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (irq_domain_is_ipi_per_cpu(data->domain)) {",
            "\t\tunsigned int base = data->irq;",
            "",
            "\t\tfor_each_cpu(cpu, dest) {",
            "\t\t\tunsigned irq = base + cpu - data->common->ipi_offset;",
            "",
            "\t\t\tdata = irq_get_irq_data(irq);",
            "\t\t\tchip->ipi_send_single(data, cpu);",
            "\t\t}",
            "\t} else {",
            "\t\tfor_each_cpu(cpu, dest)",
            "\t\t\tchip->ipi_send_single(data, cpu);",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "ipi_get_hwirq, ipi_send_verify, __ipi_send_single, __ipi_send_mask",
          "description": "实现ipi_get_hwirq获取物理中断号，ipi_send_verify验证发送参数有效性，__ipi_send_single/__ipi_send_mask处理单CPU/多CPUIPI发送逻辑",
          "similarity": 0.4859764873981476
        }
      ]
    },
    {
      "source_file": "kernel/irq/proc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:06:44\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\proc.c`\n\n---\n\n# `irq/proc.c` 技术文档\n\n## 1. 文件概述\n\n`irq/proc.c` 是 Linux 内核中负责管理 `/proc/irq/` 目录下中断相关 proc 文件的实现模块。该文件提供了用户空间通过 `/proc` 文件系统查询和配置中断属性（如 CPU 亲和性、默认亲和性、中断统计信息等）的接口。其核心目标是在保证并发安全的前提下，暴露中断描述符（`irq_desc`）的关键信息，并允许用户动态调整中断的 CPU 亲和性策略。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `root_irq_dir`：指向 `/proc/irq` 根目录的 `proc_dir_entry` 指针。\n- `no_irq_affinity`：全局标志，用于禁用所有中断亲和性设置（通常用于调试或特定架构）。\n\n### 主要函数\n\n#### 中断亲和性相关（SMP 环境）\n- `show_irq_affinity()`：根据类型（AFFINITY/AFFINITY_LIST/EFFECTIVE/EFFECTIVE_LIST）格式化输出中断的 CPU 亲和性掩码。\n- `irq_affinity_proc_show()` / `irq_affinity_list_proc_show()`：分别以十六进制位图或 CPU 列表格式显示当前中断的亲和性。\n- `irq_affinity_proc_write()` / `irq_affinity_list_proc_write()`：解析用户输入并设置中断的 CPU 亲和性。\n- `irq_affinity_hint_proc_show()`：显示中断的亲和性提示（`affinity_hint`）。\n- `default_affinity_show()` / `default_affinity_write()`：读写全局默认中断亲和性掩码（`irq_default_affinity`）。\n- `irq_node_proc_show()`：显示中断所属的 NUMA 节点编号。\n\n#### 中断统计信息\n- `irq_spurious_proc_show()`：输出中断的异常统计信息，包括总触发次数、未处理次数及上次未处理时间。\n\n#### 工具函数\n- `name_unique()`：检查新注册的中断处理程序名称在当前中断线上是否唯一（代码片段截断，但功能明确）。\n- `irq_select_affinity_usr()`：在特定配置下（如 `CONFIG_AUTO_IRQ_AFFINITY`）尝试为中断自动选择合适的 CPU 亲和性。\n\n#### 文件操作结构体\n- `irq_affinity_proc_ops` / `irq_affinity_list_proc_ops`：定义 `/proc/irq/N/smp_affinity` 和 `/proc/irq/N/smp_affinity_list` 的文件操作。\n- `default_affinity_proc_ops`：定义 `/proc/irq/default_smp_affinity` 的文件操作。\n\n## 3. 关键实现\n\n### 并发安全机制\n- **中断描述符生命周期保护**：通过 `procfs` 自身的同步机制（`remove_proc_entry()` 阻塞新访问并等待现有操作完成）确保在 `/proc/irq/N/` 文件被访问期间，对应的 `irq_desc` 不会被释放。因此，在文件操作回调中调用 `irq_to_desc()` 是安全的。\n- **中断描述符内部数据保护**：访问 `irq_desc` 内部字段（如 `affinity_hint`）时，使用 `desc->lock` 自旋锁进行保护。\n- **全局中断列表保护**：访问 `/proc/interrupts` 时需使用 `sparse_irq_lock`（注释提及，但本文件未直接实现该文件）。\n\n### 亲和性设置逻辑\n- **有效性检查**：写入亲和性掩码时，强制要求至少包含一个在线 CPU（`cpumask_intersects(new_value, cpu_online_mask)`），防止系统因中断无法投递而挂起。\n- **空掩码特殊处理**：若用户写入空掩码，尝试调用 `irq_select_affinity_usr()` 触发自动亲和性分配（仅在 `CONFIG_AUTO_IRQ_AFFINITY` 下有效），否则返回错误。\n- **格式支持**：同时支持位图格式（`%pb`，用于 `smp_affinity`）和 CPU 列表格式（`%pbl`，用于 `smp_affinity_list`）的读写。\n\n### 特性条件编译\n- **SMP 支持**：大部分亲和性相关代码受 `CONFIG_SMP` 宏保护。\n- **有效亲和性掩码**：`EFFECTIVE` 相关接口依赖 `CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK`。\n- **自动亲和性**：`irq_select_affinity_usr()` 的行为由 `CONFIG_AUTO_IRQ_AFFINITY` 控制。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>` / `<linux/interrupt.h>`：中断核心数据结构和 API。\n  - `<linux/proc_fs.h>` / `<linux/seq_file.h>`：proc 文件系统和序列化文件操作。\n  - `<linux/kernel_stat.h>`：内核统计信息（如中断计数）。\n  - `\"internals.h\"`：中断子系统内部头文件，包含 `irq_to_desc()` 等内部函数。\n- **内核配置依赖**：\n  - `CONFIG_SMP`：多处理器支持（亲和性功能的前提）。\n  - `CONFIG_GENERIC_PENDING_IRQ`：处理挂起的亲和性变更。\n  - `CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK`：支持有效亲和性掩码。\n  - `CONFIG_AUTO_IRQ_AFFINITY`：启用自动亲和性选择（历史遗留特性）。\n- **其他模块**：\n  - 依赖中断描述符管理模块（`irqdesc.c`）提供 `irq_to_desc()` 和 `irq_set_affinity()`。\n  - 依赖 CPU 掩码操作（`cpumask_*`）和内存分配（`zalloc_cpumask_var`）。\n\n## 5. 使用场景\n\n- **系统监控**：用户通过读取 `/proc/irq/N/spurious` 诊断中断异常（如频繁未处理中断）。\n- **性能调优**：管理员通过修改 `/proc/irq/N/smp_affinity` 或 `smp_affinity_list` 将特定中断绑定到指定 CPU，优化缓存局部性或隔离关键中断。\n- **NUMA 优化**：通过 `/proc/irq/N/node` 了解中断与 NUMA 节点的关联，辅助内存和中断亲和性配置。\n- **默认策略配置**：通过 `/proc/irq/default_smp_affinity` 设置新注册中断的默认 CPU 亲和性。\n- **驱动调试**：验证中断处理程序名称唯一性（`name_unique`），避免命名冲突。",
      "similarity": 0.5261951684951782,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/proc.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2004 Linus Torvalds, Ingo Molnar",
            " *",
            " * This file contains the /proc/irq/ handling code.",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/gfp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mutex.h>",
            "",
            "#include \"internals.h\"",
            "",
            "/*",
            " * Access rules:",
            " *",
            " * procfs protects read/write of /proc/irq/N/ files against a",
            " * concurrent free of the interrupt descriptor. remove_proc_entry()",
            " * immediately prevents new read/writes to happen and waits for",
            " * already running read/write functions to complete.",
            " *",
            " * We remove the proc entries first and then delete the interrupt",
            " * descriptor from the radix tree and free it. So it is guaranteed",
            " * that irq_to_desc(N) is valid as long as the read/writes are",
            " * permitted by procfs.",
            " *",
            " * The read from /proc/interrupts is a different problem because there",
            " * is no protection. So the lookup and the access to irqdesc",
            " * information must be protected by sparse_irq_lock.",
            " */",
            "static struct proc_dir_entry *root_irq_dir;",
            "",
            "#ifdef CONFIG_SMP",
            "",
            "enum {",
            "\tAFFINITY,",
            "\tAFFINITY_LIST,",
            "\tEFFECTIVE,",
            "\tEFFECTIVE_LIST,",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义/proc/irq目录结构及中断亲和性相关常量，建立proc文件系统的访问控制规则，确保在删除中断描述符前禁止并发访问。",
          "similarity": 0.48193445801734924
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/proc.c",
          "start_line": 179,
          "end_line": 291,
          "content": [
            "static ssize_t irq_affinity_proc_write(struct file *file,",
            "\t\tconst char __user *buffer, size_t count, loff_t *pos)",
            "{",
            "\treturn write_irq_affinity(0, file, buffer, count, pos);",
            "}",
            "static ssize_t irq_affinity_list_proc_write(struct file *file,",
            "\t\tconst char __user *buffer, size_t count, loff_t *pos)",
            "{",
            "\treturn write_irq_affinity(1, file, buffer, count, pos);",
            "}",
            "static int irq_affinity_proc_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn single_open(file, irq_affinity_proc_show, pde_data(inode));",
            "}",
            "static int irq_affinity_list_proc_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn single_open(file, irq_affinity_list_proc_show, pde_data(inode));",
            "}",
            "static int irq_effective_aff_proc_show(struct seq_file *m, void *v)",
            "{",
            "\treturn show_irq_affinity(EFFECTIVE, m);",
            "}",
            "static int irq_effective_aff_list_proc_show(struct seq_file *m, void *v)",
            "{",
            "\treturn show_irq_affinity(EFFECTIVE_LIST, m);",
            "}",
            "static int default_affinity_show(struct seq_file *m, void *v)",
            "{",
            "\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(irq_default_affinity));",
            "\treturn 0;",
            "}",
            "static ssize_t default_affinity_write(struct file *file,",
            "\t\tconst char __user *buffer, size_t count, loff_t *ppos)",
            "{",
            "\tcpumask_var_t new_value;",
            "\tint err;",
            "",
            "\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = cpumask_parse_user(buffer, count, new_value);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Do not allow disabling IRQs completely - it's a too easy",
            "\t * way to make the system unusable accidentally :-) At least",
            "\t * one online CPU still has to be targeted.",
            "\t */",
            "\tif (!cpumask_intersects(new_value, cpu_online_mask)) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tcpumask_copy(irq_default_affinity, new_value);",
            "\terr = count;",
            "",
            "out:",
            "\tfree_cpumask_var(new_value);",
            "\treturn err;",
            "}",
            "static int default_affinity_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn single_open(file, default_affinity_show, pde_data(inode));",
            "}",
            "static int irq_node_proc_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc((long) m->private);",
            "",
            "\tseq_printf(m, \"%d\\n\", irq_desc_get_node(desc));",
            "\treturn 0;",
            "}",
            "static int irq_spurious_proc_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc((long) m->private);",
            "",
            "\tseq_printf(m, \"count %u\\n\" \"unhandled %u\\n\" \"last_unhandled %u ms\\n\",",
            "\t\t   desc->irq_count, desc->irqs_unhandled,",
            "\t\t   jiffies_to_msecs(desc->last_unhandled));",
            "\treturn 0;",
            "}",
            "static int name_unique(unsigned int irq, struct irqaction *new_action)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "\tstruct irqaction *action;",
            "\tunsigned long flags;",
            "\tint ret = 1;",
            "",
            "\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\tfor_each_action_of_desc(desc, action) {",
            "\t\tif ((action != new_action) && action->name &&",
            "\t\t\t\t!strcmp(new_action->name, action->name)) {",
            "\t\t\tret = 0;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\treturn ret;",
            "}",
            "void register_handler_proc(unsigned int irq, struct irqaction *action)",
            "{",
            "\tchar name [MAX_NAMELEN];",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc->dir || action->dir || !action->name ||",
            "\t\t\t\t\t!name_unique(irq, action))",
            "\t\treturn;",
            "",
            "\tsnprintf(name, MAX_NAMELEN, \"%s\", action->name);",
            "",
            "\t/* create /proc/irq/1234/handler/ */",
            "\taction->dir = proc_mkdir(name, desc->dir);",
            "}"
          ],
          "function_name": "irq_affinity_proc_write, irq_affinity_list_proc_write, irq_affinity_proc_open, irq_affinity_list_proc_open, irq_effective_aff_proc_show, irq_effective_aff_list_proc_show, default_affinity_show, default_affinity_write, default_affinity_open, irq_node_proc_show, irq_spurious_proc_show, name_unique, register_handler_proc",
          "description": "创建/proc/irq子项的文件操作函数，包含默认亲和性配置、中断节点信息、异常统计展示以及处理程序名称唯一性校验逻辑。",
          "similarity": 0.4816446900367737
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/proc.c",
          "start_line": 46,
          "end_line": 167,
          "content": [
            "static int show_irq_affinity(int type, struct seq_file *m)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc((long)m->private);",
            "\tconst struct cpumask *mask;",
            "",
            "\tswitch (type) {",
            "\tcase AFFINITY:",
            "\tcase AFFINITY_LIST:",
            "\t\tmask = desc->irq_common_data.affinity;",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))",
            "\t\t\tmask = desc->pending_mask;",
            "#endif",
            "\t\tbreak;",
            "\tcase EFFECTIVE:",
            "\tcase EFFECTIVE_LIST:",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);",
            "\t\tbreak;",
            "#endif",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tswitch (type) {",
            "\tcase AFFINITY_LIST:",
            "\tcase EFFECTIVE_LIST:",
            "\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));",
            "\t\tbreak;",
            "\tcase AFFINITY:",
            "\tcase EFFECTIVE:",
            "\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));",
            "\t\tbreak;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int irq_affinity_hint_proc_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc((long)m->private);",
            "\tunsigned long flags;",
            "\tcpumask_var_t mask;",
            "",
            "\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL))",
            "\t\treturn -ENOMEM;",
            "",
            "\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\tif (desc->affinity_hint)",
            "\t\tcpumask_copy(mask, desc->affinity_hint);",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "",
            "\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));",
            "\tfree_cpumask_var(mask);",
            "",
            "\treturn 0;",
            "}",
            "static int irq_affinity_proc_show(struct seq_file *m, void *v)",
            "{",
            "\treturn show_irq_affinity(AFFINITY, m);",
            "}",
            "static int irq_affinity_list_proc_show(struct seq_file *m, void *v)",
            "{",
            "\treturn show_irq_affinity(AFFINITY_LIST, m);",
            "}",
            "static inline int irq_select_affinity_usr(unsigned int irq)",
            "{",
            "\t/*",
            "\t * If the interrupt is started up already then this fails. The",
            "\t * interrupt is assigned to an online CPU already. There is no",
            "\t * point to move it around randomly. Tell user space that the",
            "\t * selected mask is bogus.",
            "\t *",
            "\t * If not then any change to the affinity is pointless because the",
            "\t * startup code invokes irq_setup_affinity() which will select",
            "\t * a online CPU anyway.",
            "\t */",
            "\treturn -EINVAL;",
            "}",
            "static inline int irq_select_affinity_usr(unsigned int irq)",
            "{",
            "\treturn irq_select_affinity(irq);",
            "}",
            "static ssize_t write_irq_affinity(int type, struct file *file,",
            "\t\tconst char __user *buffer, size_t count, loff_t *pos)",
            "{",
            "\tunsigned int irq = (int)(long)pde_data(file_inode(file));",
            "\tcpumask_var_t new_value;",
            "\tint err;",
            "",
            "\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)",
            "\t\treturn -EIO;",
            "",
            "\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (type)",
            "\t\terr = cpumask_parselist_user(buffer, count, new_value);",
            "\telse",
            "\t\terr = cpumask_parse_user(buffer, count, new_value);",
            "\tif (err)",
            "\t\tgoto free_cpumask;",
            "",
            "\t/*",
            "\t * Do not allow disabling IRQs completely - it's a too easy",
            "\t * way to make the system unusable accidentally :-) At least",
            "\t * one online CPU still has to be targeted.",
            "\t */",
            "\tif (!cpumask_intersects(new_value, cpu_online_mask)) {",
            "\t\t/*",
            "\t\t * Special case for empty set - allow the architecture code",
            "\t\t * to set default SMP affinity.",
            "\t\t */",
            "\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;",
            "\t} else {",
            "\t\terr = irq_set_affinity(irq, new_value);",
            "\t\tif (!err)",
            "\t\t\terr = count;",
            "\t}",
            "",
            "free_cpumask:",
            "\tfree_cpumask_var(new_value);",
            "\treturn err;",
            "}"
          ],
          "function_name": "show_irq_affinity, irq_affinity_hint_proc_show, irq_affinity_proc_show, irq_affinity_list_proc_show, irq_select_affinity_usr, irq_select_affinity_usr, write_irq_affinity",
          "description": "实现中断亲和性信息的读取与设置接口，支持显示当前亲和性掩码、有效亲和性掩码、解析用户输入并更新中断绑定关系。",
          "similarity": 0.42283564805984497
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/proc.c",
          "start_line": 338,
          "end_line": 441,
          "content": [
            "void register_irq_proc(unsigned int irq, struct irq_desc *desc)",
            "{",
            "\tstatic DEFINE_MUTEX(register_lock);",
            "\tvoid __maybe_unused *irqp = (void *)(unsigned long) irq;",
            "\tchar name [MAX_NAMELEN];",
            "",
            "\tif (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * irq directories are registered only when a handler is",
            "\t * added, not when the descriptor is created, so multiple",
            "\t * tasks might try to register at the same time.",
            "\t */",
            "\tmutex_lock(&register_lock);",
            "",
            "\tif (desc->dir)",
            "\t\tgoto out_unlock;",
            "",
            "\tsprintf(name, \"%d\", irq);",
            "",
            "\t/* create /proc/irq/1234 */",
            "\tdesc->dir = proc_mkdir(name, root_irq_dir);",
            "\tif (!desc->dir)",
            "\t\tgoto out_unlock;",
            "",
            "#ifdef CONFIG_SMP",
            "\t/* create /proc/irq/<irq>/smp_affinity */",
            "\tproc_create_data(\"smp_affinity\", 0644, desc->dir,",
            "\t\t\t &irq_affinity_proc_ops, irqp);",
            "",
            "\t/* create /proc/irq/<irq>/affinity_hint */",
            "\tproc_create_single_data(\"affinity_hint\", 0444, desc->dir,",
            "\t\t\tirq_affinity_hint_proc_show, irqp);",
            "",
            "\t/* create /proc/irq/<irq>/smp_affinity_list */",
            "\tproc_create_data(\"smp_affinity_list\", 0644, desc->dir,",
            "\t\t\t &irq_affinity_list_proc_ops, irqp);",
            "",
            "\tproc_create_single_data(\"node\", 0444, desc->dir, irq_node_proc_show,",
            "\t\t\tirqp);",
            "# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\tproc_create_single_data(\"effective_affinity\", 0444, desc->dir,",
            "\t\t\tirq_effective_aff_proc_show, irqp);",
            "\tproc_create_single_data(\"effective_affinity_list\", 0444, desc->dir,",
            "\t\t\tirq_effective_aff_list_proc_show, irqp);",
            "# endif",
            "#endif",
            "\tproc_create_single_data(\"spurious\", 0444, desc->dir,",
            "\t\t\tirq_spurious_proc_show, (void *)(long)irq);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&register_lock);",
            "}",
            "void unregister_irq_proc(unsigned int irq, struct irq_desc *desc)",
            "{",
            "\tchar name [MAX_NAMELEN];",
            "",
            "\tif (!root_irq_dir || !desc->dir)",
            "\t\treturn;",
            "#ifdef CONFIG_SMP",
            "\tremove_proc_entry(\"smp_affinity\", desc->dir);",
            "\tremove_proc_entry(\"affinity_hint\", desc->dir);",
            "\tremove_proc_entry(\"smp_affinity_list\", desc->dir);",
            "\tremove_proc_entry(\"node\", desc->dir);",
            "# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\tremove_proc_entry(\"effective_affinity\", desc->dir);",
            "\tremove_proc_entry(\"effective_affinity_list\", desc->dir);",
            "# endif",
            "#endif",
            "\tremove_proc_entry(\"spurious\", desc->dir);",
            "",
            "\tsprintf(name, \"%u\", irq);",
            "\tremove_proc_entry(name, root_irq_dir);",
            "}",
            "void unregister_handler_proc(unsigned int irq, struct irqaction *action)",
            "{",
            "\tproc_remove(action->dir);",
            "}",
            "static void register_default_affinity_proc(void)",
            "{",
            "#ifdef CONFIG_SMP",
            "\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,",
            "\t\t    &default_affinity_proc_ops);",
            "#endif",
            "}",
            "void init_irq_proc(void)",
            "{",
            "\tunsigned int irq;",
            "\tstruct irq_desc *desc;",
            "",
            "\t/* create /proc/irq */",
            "\troot_irq_dir = proc_mkdir(\"irq\", NULL);",
            "\tif (!root_irq_dir)",
            "\t\treturn;",
            "",
            "\tregister_default_affinity_proc();",
            "",
            "\t/*",
            "\t * Create entries for all existing IRQs.",
            "\t */",
            "\tfor_each_irq_desc(irq, desc)",
            "\t\tregister_irq_proc(irq, desc);",
            "}"
          ],
          "function_name": "register_irq_proc, unregister_irq_proc, unregister_handler_proc, register_default_affinity_proc, init_irq_proc",
          "description": "动态注册/注销中断的proc条目，创建中断专属目录及其子项文件，初始化全局中断亲和性配置入口点。",
          "similarity": 0.41739124059677124
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/proc.c",
          "start_line": 451,
          "end_line": 529,
          "content": [
            "int __weak arch_show_interrupts(struct seq_file *p, int prec)",
            "{",
            "\treturn 0;",
            "}",
            "int show_interrupts(struct seq_file *p, void *v)",
            "{",
            "\tstatic int prec;",
            "",
            "\tunsigned long flags, any_count = 0;",
            "\tint i = *(loff_t *) v, j;",
            "\tstruct irqaction *action;",
            "\tstruct irq_desc *desc;",
            "",
            "\tif (i > ACTUAL_NR_IRQS)",
            "\t\treturn 0;",
            "",
            "\tif (i == ACTUAL_NR_IRQS)",
            "\t\treturn arch_show_interrupts(p, prec);",
            "",
            "\t/* print header and calculate the width of the first column */",
            "\tif (i == 0) {",
            "\t\tfor (prec = 3, j = 1000; prec < 10 && j <= nr_irqs; ++prec)",
            "\t\t\tj *= 10;",
            "",
            "\t\tseq_printf(p, \"%*s\", prec + 8, \"\");",
            "\t\tfor_each_online_cpu(j)",
            "\t\t\tseq_printf(p, \"CPU%-8d\", j);",
            "\t\tseq_putc(p, '\\n');",
            "\t}",
            "",
            "\trcu_read_lock();",
            "\tdesc = irq_to_desc(i);",
            "\tif (!desc || irq_settings_is_hidden(desc))",
            "\t\tgoto outsparse;",
            "",
            "\tif (desc->kstat_irqs)",
            "\t\tany_count = kstat_irqs_desc(desc, cpu_online_mask);",
            "",
            "\tif ((!desc->action || irq_desc_is_chained(desc)) && !any_count)",
            "\t\tgoto outsparse;",
            "",
            "\tseq_printf(p, \"%*d: \", prec, i);",
            "\tfor_each_online_cpu(j)",
            "\t\tseq_printf(p, \"%10u \", desc->kstat_irqs ? per_cpu(desc->kstat_irqs->cnt, j) : 0);",
            "",
            "\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\tif (desc->irq_data.chip) {",
            "\t\tif (desc->irq_data.chip->irq_print_chip)",
            "\t\t\tdesc->irq_data.chip->irq_print_chip(&desc->irq_data, p);",
            "\t\telse if (desc->irq_data.chip->name)",
            "\t\t\tseq_printf(p, \" %8s\", desc->irq_data.chip->name);",
            "\t\telse",
            "\t\t\tseq_printf(p, \" %8s\", \"-\");",
            "\t} else {",
            "\t\tseq_printf(p, \" %8s\", \"None\");",
            "\t}",
            "\tif (desc->irq_data.domain)",
            "\t\tseq_printf(p, \" %*lu\", prec, desc->irq_data.hwirq);",
            "\telse",
            "\t\tseq_printf(p, \" %*s\", prec, \"\");",
            "#ifdef CONFIG_GENERIC_IRQ_SHOW_LEVEL",
            "\tseq_printf(p, \" %-8s\", irqd_is_level_type(&desc->irq_data) ? \"Level\" : \"Edge\");",
            "#endif",
            "\tif (desc->name)",
            "\t\tseq_printf(p, \"-%-8s\", desc->name);",
            "",
            "\taction = desc->action;",
            "\tif (action) {",
            "\t\tseq_printf(p, \"  %s\", action->name);",
            "\t\twhile ((action = action->next) != NULL)",
            "\t\t\tseq_printf(p, \", %s\", action->name);",
            "\t}",
            "",
            "\tseq_putc(p, '\\n');",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "outsparse:",
            "\trcu_read_unlock();",
            "\treturn 0;",
            "}"
          ],
          "function_name": "arch_show_interrupts, show_interrupts",
          "description": "实现标准中断统计信息展示接口，遍历所有中断描述符收集各CPU的中断计数值并格式化输出至序列文件。",
          "similarity": 0.404360830783844
        }
      ]
    }
  ]
}