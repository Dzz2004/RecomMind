{
  "query": "network communication",
  "timestamp": "2025-12-26 01:21:29",
  "retrieved_files": [
    {
      "source_file": "kernel/task_work.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:33:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `task_work.c`\n\n---\n\n# task_work.c 技术文档\n\n## 文件概述\n\n`task_work.c` 实现了 Linux 内核中的 **任务工作（task work）机制**，允许内核在特定时机（如任务返回用户态、收到信号或处于 NMI 上下文）异步执行回调函数。该机制主要用于在不阻塞当前执行路径的前提下，将工作延迟到目标任务的合适上下文中执行，常用于安全模块（如 seccomp）、用户态通知、延迟清理等场景。\n\n任务工作队列是 **LIFO（后进先出）** 的，且不保证多个工作项之间的执行顺序。该机制支持多种通知模式，以适应不同的延迟和中断需求。\n\n## 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `task_work_add()` | 向指定任务添加一个回调工作项，并根据通知模式触发相应通知 |\n| `task_work_run()` | 执行当前任务的所有挂起工作项，通常在返回用户态或任务退出前调用 |\n| `task_work_cancel_match()` | 根据自定义匹配函数取消队列中的某个工作项 |\n| `task_work_cancel_func()` | 取消队列中第一个函数指针匹配指定函数的工作项 |\n| `task_work_cancel()` | 取消队列中指定的回调结构体（精确匹配指针） |\n\n### 主要数据结构\n\n- `struct callback_head`：通用回调结构体，包含 `next` 指针和 `func` 回调函数指针。\n- `enum task_work_notify_mode`：通知模式枚举，包括：\n  - `TWA_NONE`：不通知\n  - `TWA_RESUME`：在任务返回用户态或进入 guest 模式前执行\n  - `TWA_SIGNAL`：类似信号，可中断内核态任务并立即调度执行\n  - `TWA_SIGNAL_NO_IPI`：类似 `TWA_SIGNAL`，但不发送 IPI 强制重调度\n  - `TWA_NMI_CURRENT`：仅用于当前任务且在 NMI 上下文中，通过 IRQ work 触发\n\n### 全局变量\n\n- `work_exited`：特殊标记，表示任务已退出，不能再接受新工作。\n- `irq_work_NMI_resume`（per-CPU）：用于 `TWA_NMI_CURRENT` 模式下触发 `TIF_NOTIFY_RESUME` 标志。\n\n## 关键实现\n\n### 1. 无锁队列插入（LIFO）\n\n`task_work_add()` 使用 `try_cmpxchg()` 原子操作将新工作项插入到 `task->task_works` 链表头部，实现无锁并发插入。若发现 `task_works == &work_exited`，说明任务正在退出，返回 `-ESRCH`。\n\n### 2. 多种通知机制\n\n- **`TWA_RESUME`**：调用 `set_notify_resume(task)`，设置 `TIF_NOTIFY_RESUME` 标志，确保任务在 `exit_to_user_mode()` 路径中调用 `task_work_run()`。\n- **`TWA_SIGNAL` / `TWA_SIGNAL_NO_IPI`**：分别调用 `set_notify_signal()` 和 `__set_notify_signal()`，设置 `TIF_NOTIFY_SIGNAL` 标志，并可能发送 IPI 强制目标 CPU 重调度。\n- **`TWA_NMI_CURRENT`**：在 NMI 上下文中，通过 per-CPU 的 `irq_work` 触发软中断，在 IRQ 上下文中设置 `TIF_NOTIFY_RESUME`。\n\n### 3. 安全退出处理\n\n`task_work_run()` 在循环中：\n- 原子地将 `task_works` 置为 `NULL`（或 `&work_exited`，若任务正在退出）。\n- 若任务正在退出（`PF_EXITING`），则标记为 `work_exited`，防止后续 `task_work_add()` 成功。\n- 执行所有取出的工作项，每个 `work->func(work)` 可能再次调用 `task_work_add()`，因此需循环处理。\n\n### 4. 并发取消机制\n\n`task_work_cancel_match()` 使用 `task->pi_lock` 保护遍历和删除操作：\n- 遍历链表查找匹配项。\n- 使用 `try_cmpxchg()` 原子地移除节点，避免与 `task_work_add()` 或 `task_work_run()` 冲突。\n- 特别地，`task_work_run()` 在执行前会短暂获取 `pi_lock`，确保取消操作不会在执行过程中移除正在运行的工作项。\n\n### 5. KASAN 辅助栈记录\n\n在 `task_work_add()` 中，根据 `TWAF_NO_ALLOC` 标志调用 `kasan_record_aux_stack()` 或 `kasan_record_aux_stack_noalloc()`，用于在 KASAN 报告中显示工作项的分配调用栈。\n\n## 依赖关系\n\n- **`<linux/irq_work.h>`**：提供 `irq_work` 机制，用于 `TWA_NMI_CURRENT` 模式。\n- **`<linux/resume_user_mode.h>`**：提供 `set_notify_resume()` 等接口，用于在返回用户态时触发回调。\n- **`<linux/spinlock.h>`**：使用 `raw_spinlock_t`（`pi_lock`）保护取消操作。\n- **`<linux/task_work.h>`**：定义 `task_work_notify_mode`、`callback_head` 等核心类型。\n- **调度子系统**：依赖 `TIF_NOTIFY_RESUME` / `TIF_NOTIFY_SIGNAL` 标志位，在调度路径中调用 `task_work_run()`。\n- **KASAN**：集成内存错误检测的调用栈记录功能。\n\n## 使用场景\n\n1. **Seccomp 通知**：当 seccomp 策略需要异步通知用户态代理时，通过 `task_work_add()` 添加回调。\n2. **用户态延迟操作**：内核模块需要在任务下次返回用户态时执行清理或通知，使用 `TWA_RESUME`。\n3. **NMI 上下文延迟处理**：在不可睡眠的 NMI 处理程序中，通过 `TWA_NMI_CURRENT` 安全地安排后续工作。\n4. **信号式中断执行**：需要立即中断目标任务（即使在内核态）以执行高优先级工作，使用 `TWA_SIGNAL`。\n5. **资源回收**：在任务退出路径中，确保所有挂起工作被执行或清理。\n6. **动态取消机制**：如 seccomp 可能需要在条件变化时取消之前安排的工作，使用 `task_work_cancel_func()`。",
      "similarity": 0.49679630994796753,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/task_work.c",
          "start_line": 10,
          "end_line": 125,
          "content": [
            "static void task_work_set_notify_irq(struct irq_work *entry)",
            "{",
            "\ttest_and_set_tsk_thread_flag(current, TIF_NOTIFY_RESUME);",
            "}",
            "int task_work_add(struct task_struct *task, struct callback_head *work,",
            "\t\t  enum task_work_notify_mode notify)",
            "{",
            "\tstruct callback_head *head;",
            "\tint flags = notify & TWA_FLAGS;",
            "",
            "\tnotify &= ~TWA_FLAGS;",
            "\tif (notify == TWA_NMI_CURRENT) {",
            "\t\tif (WARN_ON_ONCE(task != current))",
            "\t\t\treturn -EINVAL;",
            "\t\tif (!IS_ENABLED(CONFIG_IRQ_WORK))",
            "\t\t\treturn -EINVAL;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Record the work call stack in order to print it in KASAN",
            "\t\t * reports.",
            "\t\t *",
            "\t\t * Note that stack allocation can fail if TWAF_NO_ALLOC flag",
            "\t\t * is set and new page is needed to expand the stack buffer.",
            "\t\t */",
            "\t\tif (flags & TWAF_NO_ALLOC)",
            "\t\t\tkasan_record_aux_stack_noalloc(work);",
            "\t\telse",
            "\t\t\tkasan_record_aux_stack(work);",
            "\t}",
            "",
            "\thead = READ_ONCE(task->task_works);",
            "\tdo {",
            "\t\tif (unlikely(head == &work_exited))",
            "\t\t\treturn -ESRCH;",
            "\t\twork->next = head;",
            "\t} while (!try_cmpxchg(&task->task_works, &head, work));",
            "",
            "\tswitch (notify) {",
            "\tcase TWA_NONE:",
            "\t\tbreak;",
            "\tcase TWA_RESUME:",
            "\t\tset_notify_resume(task);",
            "\t\tbreak;",
            "\tcase TWA_SIGNAL:",
            "\t\tset_notify_signal(task);",
            "\t\tbreak;",
            "\tcase TWA_SIGNAL_NO_IPI:",
            "\t\t__set_notify_signal(task);",
            "\t\tbreak;",
            "#ifdef CONFIG_IRQ_WORK",
            "\tcase TWA_NMI_CURRENT:",
            "\t\tirq_work_queue(this_cpu_ptr(&irq_work_NMI_resume));",
            "\t\tbreak;",
            "#endif",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static bool task_work_func_match(struct callback_head *cb, void *data)",
            "{",
            "\treturn cb->func == data;",
            "}",
            "static bool task_work_match(struct callback_head *cb, void *data)",
            "{",
            "\treturn cb == data;",
            "}",
            "bool task_work_cancel(struct task_struct *task, struct callback_head *cb)",
            "{",
            "\tstruct callback_head *ret;",
            "",
            "\tret = task_work_cancel_match(task, task_work_match, cb);",
            "",
            "\treturn ret == cb;",
            "}",
            "void task_work_run(void)",
            "{",
            "\tstruct task_struct *task = current;",
            "\tstruct callback_head *work, *head, *next;",
            "",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * work->func() can do task_work_add(), do not set",
            "\t\t * work_exited unless the list is empty.",
            "\t\t */",
            "\t\twork = READ_ONCE(task->task_works);",
            "\t\tdo {",
            "\t\t\thead = NULL;",
            "\t\t\tif (!work) {",
            "\t\t\t\tif (task->flags & PF_EXITING)",
            "\t\t\t\t\thead = &work_exited;",
            "\t\t\t\telse",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t} while (!try_cmpxchg(&task->task_works, &work, head));",
            "",
            "\t\tif (!work)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * Synchronize with task_work_cancel_match(). It can not remove",
            "\t\t * the first entry == work, cmpxchg(task_works) must fail.",
            "\t\t * But it can remove another entry from the ->next list.",
            "\t\t */",
            "\t\traw_spin_lock_irq(&task->pi_lock);",
            "\t\traw_spin_unlock_irq(&task->pi_lock);",
            "",
            "\t\tdo {",
            "\t\t\tnext = work->next;",
            "\t\t\twork->func(work);",
            "\t\t\twork = next;",
            "\t\t\tcond_resched();",
            "\t\t} while (work);",
            "\t}",
            "}"
          ],
          "function_name": "task_work_set_notify_irq, task_work_add, task_work_func_match, task_work_match, task_work_cancel, task_work_run",
          "description": "实现任务工作队列的添加、匹配、取消及执行逻辑，支持多种通知模式（如RESUME/SIGNAL/NMI），通过原子操作维护链表并同步执行回调函数",
          "similarity": 0.5140827894210815
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/task_work.c",
          "start_line": 1,
          "end_line": 9,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/task_work.h>",
            "#include <linux/resume_user_mode.h>",
            "",
            "static struct callback_head work_exited; /* all we need is ->next == NULL */",
            "",
            "#ifdef CONFIG_IRQ_WORK"
          ],
          "function_name": null,
          "description": "声明用于任务工作通知的静态变量work_exited，该变量通过next指针判断任务工作链表是否为空，上下文不完整",
          "similarity": 0.448221355676651
        }
      ]
    },
    {
      "source_file": "kernel/notifier.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:11:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `notifier.c`\n\n---\n\n# notifier.c 技术文档\n\n## 1. 文件概述\n\n`notifier.c` 是 Linux 内核中实现通知链（notifier chain）机制的核心文件。通知链是一种回调机制，允许内核子系统在特定事件发生时（如系统关机、硬件状态变化等）注册回调函数并被依次调用。该文件提供了原子通知链（atomic notifier chain）和阻塞通知链（blocking notifier chain）的通用注册、注销和调用逻辑，并定义了系统关机时使用的 `reboot_notifier_list`。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct notifier_block`：通知回调的基本单元，包含回调函数指针 `notifier_call`、优先级 `priority` 和下一个节点指针 `next`。\n- `struct atomic_notifier_head`：原子通知链头结构，包含自旋锁 `lock` 和链表头 `head`。\n- `struct blocking_notifier_head`：阻塞通知链头结构，包含读写信号量 `rwsem` 和链表头 `head`。\n- `reboot_notifier_list`：全局阻塞通知链，用于系统关机/重启时通知各子系统。\n\n### 主要函数\n- **通用内部函数**：\n  - `notifier_chain_register()`：将通知块插入链表（按优先级排序）。\n  - `notifier_chain_unregister()`：从链表中移除指定通知块。\n  - `notifier_call_chain()`：遍历并调用通知链中的回调函数。\n  - `notifier_call_chain_robust()`：支持错误回滚的通知调用（先 `val_up`，失败则 `val_down`）。\n\n- **原子通知链接口（导出）**：\n  - `atomic_notifier_chain_register()`\n  - `atomic_notifier_chain_register_unique_prio()`\n  - `atomic_notifier_chain_unregister()`\n  - `atomic_notifier_call_chain()`\n  - `atomic_notifier_call_chain_is_empty()`\n\n- **阻塞通知链接口（部分在文件后续定义）**：\n  - `__blocking_notifier_chain_register()`（内部辅助函数）\n\n## 3. 关键实现\n\n### 通知链注册逻辑\n- 通知块按 `priority` 字段**降序插入**链表（高优先级在前）。\n- `notifier_chain_register()` 支持 `unique_priority` 模式：若启用，则不允许相同优先级的多个通知块共存（返回 `-EBUSY`）。\n- 使用 `rcu_assign_pointer()` 安全地更新指针，确保 RCU 读端可见性。\n- 重复注册同一回调函数会触发 `WARN()` 并返回 `-EEXIST`。\n\n### 通知调用机制\n- `notifier_call_chain()` 遍历链表，依次调用每个 `notifier_call` 回调。\n- 若回调返回值包含 `NOTIFY_STOP_MASK`（如 `NOTIFY_STOP` 或 `NOTIFY_BAD`），则立即终止调用。\n- 支持限制调用数量（`nr_to_call`）和记录已调用数量（`nr_calls`）。\n- 在 `CONFIG_DEBUG_NOTIFIERS` 启用时，会验证回调函数地址是否在内核代码段，防止非法调用。\n\n### 同步机制\n- **原子通知链**：注册/注销使用 `spinlock`（`spin_lock_irqsave`），调用使用 `rcu_read_lock()`，适用于中断上下文。\n- **阻塞通知链**：注册/注销使用 `rwsem`（读写信号量），但**在系统启动阶段**（`SYSTEM_BOOTING`）会绕过锁，直接调用底层注册函数以避免死锁。\n- 注销原子通知块后调用 `synchronize_rcu()` 确保所有读者完成。\n\n### 回滚机制\n- `notifier_call_chain_robust()` 先尝试 `val_up` 事件，若中途失败（返回 `NOTIFY_STOP_MASK`），则反向调用前 `nr-1` 个回调并传入 `val_down` 事件，实现资源回滚。\n\n### 跟踪点支持\n- 通过 `trace/events/notifier.h` 定义了三个跟踪点：\n  - `notifier_register`：注册时触发\n  - `notifier_unregister`：注销时触发  \n  - `notifier_run`：调用回调时触发\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/notifier.h>`：定义通知链核心数据结构和宏（如 `BLOCKING_NOTIFIER_HEAD`）\n  - `<linux/rcupdate.h>`：提供 RCU 同步原语（`rcu_assign_pointer`, `rcu_dereference_raw` 等）\n  - `<linux/spinlock.h>` / `<linux/rwsem.h>`：通过 `notifier.h` 间接依赖，用于同步\n  - `<linux/tracepoint.h>`：通过 `trace/events/notifier.h` 实现跟踪点\n  - `<linux/kdebug.h>`：提供 `func_ptr_is_kernel_text()` 用于调试验证\n  - `<linux/reboot.h>`：声明 `reboot_notifier_list` 的外部使用者\n\n- **导出符号**：\n  - 所有 `atomic_notifier_*` 函数通过 `EXPORT_SYMBOL_GPL` 导出，供其他内核模块使用。\n\n- **架构约束**：\n  - `notifier_call_chain` 和 `atomic_notifier_call_chain` 标记为 `NOKPROBE_SYMBOL`，禁止 kprobes 插桩，确保关键路径稳定性。\n\n## 5. 使用场景\n\n- **系统关机/重启**：`reboot_notifier_list` 被 `kernel/reboot.c` 使用，在 `kernel_restart()`、`kernel_halt()` 等路径中通知驱动停止 DMA、保存状态等。\n- **硬件事件通知**：如 CPU 热插拔、内存热插拔等子系统通过原子或阻塞通知链广播状态变化。\n- **内核子系统解耦**：允许模块在不直接依赖的情况下响应全局事件（如网络子系统监听设备状态变化）。\n- **错误恢复**：`notifier_call_chain_robust()` 用于需要事务性语义的场景（如设备初始化失败时回滚已分配资源）。\n- **调试与追踪**：通过 ftrace 跟踪通知链的注册、注销和调用行为，辅助内核调试。",
      "similarity": 0.4967804551124573,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/notifier.c",
          "start_line": 25,
          "end_line": 136,
          "content": [
            "static int notifier_chain_register(struct notifier_block **nl,",
            "\t\t\t\t   struct notifier_block *n,",
            "\t\t\t\t   bool unique_priority)",
            "{",
            "\twhile ((*nl) != NULL) {",
            "\t\tif (unlikely((*nl) == n)) {",
            "\t\t\tWARN(1, \"notifier callback %ps already registered\",",
            "\t\t\t     n->notifier_call);",
            "\t\t\treturn -EEXIST;",
            "\t\t}",
            "\t\tif (n->priority > (*nl)->priority)",
            "\t\t\tbreak;",
            "\t\tif (n->priority == (*nl)->priority && unique_priority)",
            "\t\t\treturn -EBUSY;",
            "\t\tnl = &((*nl)->next);",
            "\t}",
            "\tn->next = *nl;",
            "\trcu_assign_pointer(*nl, n);",
            "\ttrace_notifier_register((void *)n->notifier_call);",
            "\treturn 0;",
            "}",
            "static int notifier_chain_unregister(struct notifier_block **nl,",
            "\t\tstruct notifier_block *n)",
            "{",
            "\twhile ((*nl) != NULL) {",
            "\t\tif ((*nl) == n) {",
            "\t\t\trcu_assign_pointer(*nl, n->next);",
            "\t\t\ttrace_notifier_unregister((void *)n->notifier_call);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tnl = &((*nl)->next);",
            "\t}",
            "\treturn -ENOENT;",
            "}",
            "static int notifier_call_chain(struct notifier_block **nl,",
            "\t\t\t       unsigned long val, void *v,",
            "\t\t\t       int nr_to_call, int *nr_calls)",
            "{",
            "\tint ret = NOTIFY_DONE;",
            "\tstruct notifier_block *nb, *next_nb;",
            "",
            "\tnb = rcu_dereference_raw(*nl);",
            "",
            "\twhile (nb && nr_to_call) {",
            "\t\tnext_nb = rcu_dereference_raw(nb->next);",
            "",
            "#ifdef CONFIG_DEBUG_NOTIFIERS",
            "\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {",
            "\t\t\tWARN(1, \"Invalid notifier called!\");",
            "\t\t\tnb = next_nb;",
            "\t\t\tcontinue;",
            "\t\t}",
            "#endif",
            "\t\ttrace_notifier_run((void *)nb->notifier_call);",
            "\t\tret = nb->notifier_call(nb, val, v);",
            "",
            "\t\tif (nr_calls)",
            "\t\t\t(*nr_calls)++;",
            "",
            "\t\tif (ret & NOTIFY_STOP_MASK)",
            "\t\t\tbreak;",
            "\t\tnb = next_nb;",
            "\t\tnr_to_call--;",
            "\t}",
            "\treturn ret;",
            "}",
            "static int notifier_call_chain_robust(struct notifier_block **nl,",
            "\t\t\t\t     unsigned long val_up, unsigned long val_down,",
            "\t\t\t\t     void *v)",
            "{",
            "\tint ret, nr = 0;",
            "",
            "\tret = notifier_call_chain(nl, val_up, v, -1, &nr);",
            "\tif (ret & NOTIFY_STOP_MASK)",
            "\t\tnotifier_call_chain(nl, val_down, v, nr-1, NULL);",
            "",
            "\treturn ret;",
            "}",
            "int atomic_notifier_chain_register(struct atomic_notifier_head *nh,",
            "\t\tstruct notifier_block *n)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tspin_lock_irqsave(&nh->lock, flags);",
            "\tret = notifier_chain_register(&nh->head, n, false);",
            "\tspin_unlock_irqrestore(&nh->lock, flags);",
            "\treturn ret;",
            "}",
            "int atomic_notifier_chain_register_unique_prio(struct atomic_notifier_head *nh,",
            "\t\t\t\t\t       struct notifier_block *n)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tspin_lock_irqsave(&nh->lock, flags);",
            "\tret = notifier_chain_register(&nh->head, n, true);",
            "\tspin_unlock_irqrestore(&nh->lock, flags);",
            "\treturn ret;",
            "}",
            "int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,",
            "\t\tstruct notifier_block *n)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tspin_lock_irqsave(&nh->lock, flags);",
            "\tret = notifier_chain_unregister(&nh->head, n);",
            "\tspin_unlock_irqrestore(&nh->lock, flags);",
            "\tsynchronize_rcu();",
            "\treturn ret;",
            "}"
          ],
          "function_name": "notifier_chain_register, notifier_chain_unregister, notifier_call_chain, notifier_call_chain_robust, atomic_notifier_chain_register, atomic_notifier_chain_register_unique_prio, atomic_notifier_chain_unregister",
          "description": "实现通用通知链的注册/注销与调用逻辑，支持优先级排序与冲突检测，使用RCU指针保证内存安全，包含原子、阻塞等变体的注册接口。",
          "similarity": 0.5405746698379517
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/notifier.c",
          "start_line": 225,
          "end_line": 325,
          "content": [
            "int atomic_notifier_call_chain(struct atomic_notifier_head *nh,",
            "\t\t\t       unsigned long val, void *v)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "bool atomic_notifier_call_chain_is_empty(struct atomic_notifier_head *nh)",
            "{",
            "\treturn !rcu_access_pointer(nh->head);",
            "}",
            "static int __blocking_notifier_chain_register(struct blocking_notifier_head *nh,",
            "\t\t\t\t\t      struct notifier_block *n,",
            "\t\t\t\t\t      bool unique_priority)",
            "{",
            "\tint ret;",
            "",
            "\t/*",
            "\t * This code gets used during boot-up, when task switching is",
            "\t * not yet working and interrupts must remain disabled.  At",
            "\t * such times we must not call down_write().",
            "\t */",
            "\tif (unlikely(system_state == SYSTEM_BOOTING))",
            "\t\treturn notifier_chain_register(&nh->head, n, unique_priority);",
            "",
            "\tdown_write(&nh->rwsem);",
            "\tret = notifier_chain_register(&nh->head, n, unique_priority);",
            "\tup_write(&nh->rwsem);",
            "\treturn ret;",
            "}",
            "int blocking_notifier_chain_register(struct blocking_notifier_head *nh,",
            "\t\tstruct notifier_block *n)",
            "{",
            "\treturn __blocking_notifier_chain_register(nh, n, false);",
            "}",
            "int blocking_notifier_chain_register_unique_prio(struct blocking_notifier_head *nh,",
            "\t\t\t\t\t\t struct notifier_block *n)",
            "{",
            "\treturn __blocking_notifier_chain_register(nh, n, true);",
            "}",
            "int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,",
            "\t\tstruct notifier_block *n)",
            "{",
            "\tint ret;",
            "",
            "\t/*",
            "\t * This code gets used during boot-up, when task switching is",
            "\t * not yet working and interrupts must remain disabled.  At",
            "\t * such times we must not call down_write().",
            "\t */",
            "\tif (unlikely(system_state == SYSTEM_BOOTING))",
            "\t\treturn notifier_chain_unregister(&nh->head, n);",
            "",
            "\tdown_write(&nh->rwsem);",
            "\tret = notifier_chain_unregister(&nh->head, n);",
            "\tup_write(&nh->rwsem);",
            "\treturn ret;",
            "}",
            "int blocking_notifier_call_chain_robust(struct blocking_notifier_head *nh,",
            "\t\tunsigned long val_up, unsigned long val_down, void *v)",
            "{",
            "\tint ret = NOTIFY_DONE;",
            "",
            "\t/*",
            "\t * We check the head outside the lock, but if this access is",
            "\t * racy then it does not matter what the result of the test",
            "\t * is, we re-check the list after having taken the lock anyway:",
            "\t */",
            "\tif (rcu_access_pointer(nh->head)) {",
            "\t\tdown_read(&nh->rwsem);",
            "\t\tret = notifier_call_chain_robust(&nh->head, val_up, val_down, v);",
            "\t\tup_read(&nh->rwsem);",
            "\t}",
            "\treturn ret;",
            "}",
            "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,",
            "\t\tunsigned long val, void *v)",
            "{",
            "\tint ret = NOTIFY_DONE;",
            "",
            "\t/*",
            "\t * We check the head outside the lock, but if this access is",
            "\t * racy then it does not matter what the result of the test",
            "\t * is, we re-check the list after having taken the lock anyway:",
            "\t */",
            "\tif (rcu_access_pointer(nh->head)) {",
            "\t\tdown_read(&nh->rwsem);",
            "\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);",
            "\t\tup_read(&nh->rwsem);",
            "\t}",
            "\treturn ret;",
            "}",
            "int raw_notifier_chain_register(struct raw_notifier_head *nh,",
            "\t\tstruct notifier_block *n)",
            "{",
            "\treturn notifier_chain_register(&nh->head, n, false);",
            "}"
          ],
          "function_name": "atomic_notifier_call_chain, atomic_notifier_call_chain_is_empty, __blocking_notifier_chain_register, blocking_notifier_chain_register, blocking_notifier_chain_register_unique_prio, blocking_notifier_chain_unregister, blocking_notifier_call_chain_robust, blocking_notifier_call_chain, raw_notifier_chain_register",
          "description": "提供原子通知链的调用接口及阻塞通知链的注册/注销方法，处理系统启动初期特殊场景下的同步限制，包含带恢复机制的调用链处理函数。",
          "similarity": 0.5215671062469482
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/notifier.c",
          "start_line": 427,
          "end_line": 519,
          "content": [
            "int raw_notifier_chain_unregister(struct raw_notifier_head *nh,",
            "\t\tstruct notifier_block *n)",
            "{",
            "\treturn notifier_chain_unregister(&nh->head, n);",
            "}",
            "int raw_notifier_call_chain_robust(struct raw_notifier_head *nh,",
            "\t\tunsigned long val_up, unsigned long val_down, void *v)",
            "{",
            "\treturn notifier_call_chain_robust(&nh->head, val_up, val_down, v);",
            "}",
            "int raw_notifier_call_chain(struct raw_notifier_head *nh,",
            "\t\tunsigned long val, void *v)",
            "{",
            "\treturn notifier_call_chain(&nh->head, val, v, -1, NULL);",
            "}",
            "int srcu_notifier_chain_register(struct srcu_notifier_head *nh,",
            "\t\tstruct notifier_block *n)",
            "{",
            "\tint ret;",
            "",
            "\t/*",
            "\t * This code gets used during boot-up, when task switching is",
            "\t * not yet working and interrupts must remain disabled.  At",
            "\t * such times we must not call mutex_lock().",
            "\t */",
            "\tif (unlikely(system_state == SYSTEM_BOOTING))",
            "\t\treturn notifier_chain_register(&nh->head, n, false);",
            "",
            "\tmutex_lock(&nh->mutex);",
            "\tret = notifier_chain_register(&nh->head, n, false);",
            "\tmutex_unlock(&nh->mutex);",
            "\treturn ret;",
            "}",
            "int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,",
            "\t\tstruct notifier_block *n)",
            "{",
            "\tint ret;",
            "",
            "\t/*",
            "\t * This code gets used during boot-up, when task switching is",
            "\t * not yet working and interrupts must remain disabled.  At",
            "\t * such times we must not call mutex_lock().",
            "\t */",
            "\tif (unlikely(system_state == SYSTEM_BOOTING))",
            "\t\treturn notifier_chain_unregister(&nh->head, n);",
            "",
            "\tmutex_lock(&nh->mutex);",
            "\tret = notifier_chain_unregister(&nh->head, n);",
            "\tmutex_unlock(&nh->mutex);",
            "\tsynchronize_srcu(&nh->srcu);",
            "\treturn ret;",
            "}",
            "int srcu_notifier_call_chain(struct srcu_notifier_head *nh,",
            "\t\tunsigned long val, void *v)",
            "{",
            "\tint ret;",
            "\tint idx;",
            "",
            "\tidx = srcu_read_lock(&nh->srcu);",
            "\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);",
            "\tsrcu_read_unlock(&nh->srcu, idx);",
            "\treturn ret;",
            "}",
            "void srcu_init_notifier_head(struct srcu_notifier_head *nh)",
            "{",
            "\tmutex_init(&nh->mutex);",
            "\tif (init_srcu_struct(&nh->srcu) < 0)",
            "\t\tBUG();",
            "\tnh->head = NULL;",
            "}",
            "int notrace notify_die(enum die_val val, const char *str,",
            "\t       struct pt_regs *regs, long err, int trap, int sig)",
            "{",
            "\tstruct die_args args = {",
            "\t\t.regs\t= regs,",
            "\t\t.str\t= str,",
            "\t\t.err\t= err,",
            "\t\t.trapnr\t= trap,",
            "\t\t.signr\t= sig,",
            "",
            "\t};",
            "\tRCU_LOCKDEP_WARN(!rcu_is_watching(),",
            "\t\t\t   \"notify_die called but RCU thinks we're quiescent\");",
            "\treturn atomic_notifier_call_chain(&die_chain, val, &args);",
            "}",
            "int register_die_notifier(struct notifier_block *nb)",
            "{",
            "\treturn atomic_notifier_chain_register(&die_chain, nb);",
            "}",
            "int unregister_die_notifier(struct notifier_block *nb)",
            "{",
            "\treturn atomic_notifier_chain_unregister(&die_chain, nb);",
            "}"
          ],
          "function_name": "raw_notifier_chain_unregister, raw_notifier_call_chain_robust, raw_notifier_call_chain, srcu_notifier_chain_register, srcu_notifier_chain_unregister, srcu_notifier_call_chain, srcu_init_notifier_head, notify_die, register_die_notifier, unregister_die_notifier",
          "description": "实现基于SRCU的同步通知链操作及死亡通知处理，包含初始化函数、异常通知入口点notify_die，以及注册/注销死亡通知回调的接口。",
          "similarity": 0.48861101269721985
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/notifier.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/reboot.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/notifier.h>",
            "",
            "/*",
            " *\tNotifier list for kernel code which wants to be called",
            " *\tat shutdown. This is used to stop any idling DMA operations",
            " *\tand the like.",
            " */",
            "BLOCKING_NOTIFIER_HEAD(reboot_notifier_list);",
            "",
            "/*",
            " *\tNotifier chain core routines.  The exported routines below",
            " *\tare layered on top of these, with appropriate locking added.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "声明并初始化全局重启通知链头reboot_notifier_list，用于注册系统关机前执行的回调函数，如停止DMA操作。",
          "similarity": 0.4403182566165924
        }
      ]
    },
    {
      "source_file": "kernel/bpf/net_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:21:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\net_namespace.c`\n\n---\n\n# `bpf/net_namespace.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/net_namespace.c` 实现了 BPF（Berkeley Packet Filter）程序与网络命名空间（netns）的绑定机制。该文件提供了将 BPF 程序附加到特定网络命名空间的能力，并通过 `bpf_link` 抽象支持动态附加、更新、查询和自动清理。核心目标是允许 BPF 程序在特定网络命名空间上下文中执行，例如用于 socket 查找（`SK_LOOKUP`）或流量解析（`FLOW_DISSECTOR`）等场景，同时确保在命名空间销毁时自动解除绑定，避免资源泄漏。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_netns_link`**  \n  表示一个附加到网络命名空间的 BPF 链接对象，包含：\n  - `link`：继承自通用 `bpf_link` 结构\n  - `type`：标准 BPF 附加类型（如 `BPF_SK_LOOKUP`）\n  - `netns_type`：内部网络命名空间专用的附加类型（如 `NETNS_BPF_SK_LOOKUP`）\n  - `net`：指向所属 `struct net` 的指针（不持有引用，依赖锁保护）\n  - `node`：用于将链接加入 per-netns、per-type 的链表\n\n- **`netns_bpf_mutex`**  \n  全局互斥锁，保护所有对网络命名空间中 BPF 附加状态的并发修改。\n\n### 主要函数\n\n- **`bpf_netns_link_release()`**  \n  释放 BPF 链接：从链表中删除，更新运行数组，减少静态分支计数器。\n\n- **`bpf_netns_link_detach()`**  \n  用户触发的解绑操作，调用 `release` 逻辑。\n\n- **`bpf_netns_link_dealloc()`**  \n  释放链接结构体内存。\n\n- **`bpf_netns_link_update_prog()`**  \n  安全地替换链接中的 BPF 程序（需类型一致）。\n\n- **`bpf_netns_link_fill_info()` / `bpf_netns_link_show_fdinfo()`**  \n  提供链接信息查询接口，用于 `bpf_obj_get_info_by_fd` 和 `/proc/<pid>/fdinfo/`。\n\n- **`netns_bpf_prog_query()`**  \n  查询指定网络命名空间中某类型已附加的 BPF 程序 ID 列表。\n\n- **`netns_bpf_prog_attach()`**  \n  将 BPF 程序直接附加到当前网络命名空间（仅支持部分类型，且不允许与 `bpf_link` 混用）。\n\n- **`netns_bpf_attach_type_need()` / `netns_bpf_attach_type_unneed()`**  \n  管理静态分支（static key）的启用/禁用，用于性能优化（如 `bpf_sk_lookup_enabled`）。\n\n- **`__netns_bpf_prog_query()`**  \n  内部查询实现，需在 `netns_bpf_mutex` 保护下调用。\n\n- **`link_index()` / `link_count()` / `fill_prog_array()`**  \n  辅助函数，用于维护链接链表与运行程序数组的映射关系。\n\n## 3. 关键实现\n\n### 自动解绑机制\n- `bpf_netns_link` 不持有 `struct net` 的引用计数，而是依赖网络命名空间销毁流程中的 `pre_exit` 回调（在其他文件中实现）将 `net` 字段置为 `NULL`。\n- 所有访问 `net` 字段的操作必须在 `netns_bpf_mutex` 保护下进行，以避免与命名空间销毁过程竞争。\n\n### 运行数组管理\n- 每个网络命名空间的 `struct net->bpf.run_array[type]` 是一个 RCU 保护的 `bpf_prog_array`，存储当前激活的 BPF 程序指针。\n- 添加/删除链接时，会重新分配并填充新的 `bpf_prog_array`，然后通过 RCU 原子替换，确保执行路径无锁。\n\n### 静态分支优化\n- 对于 `NETNS_BPF_SK_LOOKUP` 等关键路径，使用 `static_branch_inc/dec` 控制内联优化开关（`bpf_sk_lookup_enabled`），避免在无程序附加时产生性能开销。\n\n### 附加模式互斥\n- `netns_bpf_prog_attach()` 仅允许在没有 `bpf_link` 附加的情况下直接附加程序（通过检查 `list_empty(&net->bpf.links[type])`），防止传统附加与链接机制混用导致状态不一致。\n\n### 安全更新\n- `bpf_netns_link_update_prog()` 使用 `link_index()` 定位程序在数组中的位置，并通过 `bpf_prog_array_update_at()` 原子替换，确保更新过程线程安全。\n\n## 4. 依赖关系\n\n- **`<linux/bpf.h>` / `<linux/filter.h>`**：BPF 核心基础设施，包括 `bpf_link`、`bpf_prog`、`bpf_prog_array` 等定义。\n- **`<linux/bpf-netns.h>`**：定义网络命名空间专用的 BPF 附加类型（`enum netns_bpf_attach_type`）和辅助函数（如 `to_netns_bpf_attach_type()`）。\n- **`<net/net_namespace.h>`**：提供 `struct net` 及其 `bpf` 子结构（包含 `links[]` 和 `run_array[]`）。\n- **`CONFIG_INET`**：`SK_LOOKUP` 功能依赖 IPv4/IPv6 网络栈支持。\n- **`flow_dissector_bpf_prog_attach_check()`**：来自网络核心层，用于验证 `FLOW_DISSECTOR` 程序的合法性。\n\n## 5. 使用场景\n\n- **Socket 查找重定向**：用户通过 `BPF_SK_LOOKUP` 类型将 BPF 程序附加到 netns，实现自定义 socket 匹配逻辑（如服务网格、负载均衡）。\n- **流量解析扩展**：通过 `BPF_FLOW_DISSECTOR` 附加程序，扩展内核对非标准协议的解析能力。\n- **命名空间隔离的 BPF 策略**：在容器或虚拟化环境中，为每个网络命名空间部署独立的 BPF 网络策略。\n- **动态程序管理**：通过 `bpf_link` API 实现程序的原子更新、查询和自动清理，适用于长时间运行的服务。\n- **调试与监控**：通过 `fdinfo` 或 `bpf_obj_get_info_by_fd` 获取链接的命名空间和附加类型信息，辅助调试。",
      "similarity": 0.4961147904396057,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/net_namespace.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/filter.h>",
            "#include <net/net_namespace.h>",
            "",
            "/*",
            " * Functions to manage BPF programs attached to netns",
            " */",
            "",
            "struct bpf_netns_link {",
            "\tstruct bpf_link\tlink;",
            "\tenum bpf_attach_type type;",
            "\tenum netns_bpf_attach_type netns_type;",
            "",
            "\t/* We don't hold a ref to net in order to auto-detach the link",
            "\t * when netns is going away. Instead we rely on pernet",
            "\t * pre_exit callback to clear this pointer. Must be accessed",
            "\t * with netns_bpf_mutex held.",
            "\t */",
            "\tstruct net *net;",
            "\tstruct list_head node; /* node in list of links attached to net */",
            "};",
            "",
            "/* Protects updates to netns_bpf */",
            "DEFINE_MUTEX(netns_bpf_mutex);",
            ""
          ],
          "function_name": null,
          "description": "定义了用于管理BPF程序在网络命名空间中链接的结构体bpf_netns_link，包含指向net结构的指针和链表节点，通过netns_bpf_mutex保护对网络命名空间BPF数据的修改。",
          "similarity": 0.49186378717422485
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/net_namespace.c",
          "start_line": 150,
          "end_line": 254,
          "content": [
            "static int bpf_netns_link_detach(struct bpf_link *link)",
            "{",
            "\tbpf_netns_link_release(link);",
            "\treturn 0;",
            "}",
            "static void bpf_netns_link_dealloc(struct bpf_link *link)",
            "{",
            "\tstruct bpf_netns_link *net_link =",
            "\t\tcontainer_of(link, struct bpf_netns_link, link);",
            "",
            "\tkfree(net_link);",
            "}",
            "static int bpf_netns_link_update_prog(struct bpf_link *link,",
            "\t\t\t\t      struct bpf_prog *new_prog,",
            "\t\t\t\t      struct bpf_prog *old_prog)",
            "{",
            "\tstruct bpf_netns_link *net_link =",
            "\t\tcontainer_of(link, struct bpf_netns_link, link);",
            "\tenum netns_bpf_attach_type type = net_link->netns_type;",
            "\tstruct bpf_prog_array *run_array;",
            "\tstruct net *net;",
            "\tint idx, ret;",
            "",
            "\tif (old_prog && old_prog != link->prog)",
            "\t\treturn -EPERM;",
            "\tif (new_prog->type != link->prog->type)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&netns_bpf_mutex);",
            "",
            "\tnet = net_link->net;",
            "\tif (!net || !check_net(net)) {",
            "\t\t/* Link auto-detached or netns dying */",
            "\t\tret = -ENOLINK;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\trun_array = rcu_dereference_protected(net->bpf.run_array[type],",
            "\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));",
            "\tidx = link_index(net, type, net_link);",
            "\tret = bpf_prog_array_update_at(run_array, idx, new_prog);",
            "\tif (ret)",
            "\t\tgoto out_unlock;",
            "",
            "\told_prog = xchg(&link->prog, new_prog);",
            "\tbpf_prog_put(old_prog);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&netns_bpf_mutex);",
            "\treturn ret;",
            "}",
            "static int bpf_netns_link_fill_info(const struct bpf_link *link,",
            "\t\t\t\t    struct bpf_link_info *info)",
            "{",
            "\tconst struct bpf_netns_link *net_link =",
            "\t\tcontainer_of(link, struct bpf_netns_link, link);",
            "\tunsigned int inum = 0;",
            "\tstruct net *net;",
            "",
            "\tmutex_lock(&netns_bpf_mutex);",
            "\tnet = net_link->net;",
            "\tif (net && check_net(net))",
            "\t\tinum = net->ns.inum;",
            "\tmutex_unlock(&netns_bpf_mutex);",
            "",
            "\tinfo->netns.netns_ino = inum;",
            "\tinfo->netns.attach_type = net_link->type;",
            "\treturn 0;",
            "}",
            "static void bpf_netns_link_show_fdinfo(const struct bpf_link *link,",
            "\t\t\t\t       struct seq_file *seq)",
            "{",
            "\tstruct bpf_link_info info = {};",
            "",
            "\tbpf_netns_link_fill_info(link, &info);",
            "\tseq_printf(seq,",
            "\t\t   \"netns_ino:\\t%u\\n\"",
            "\t\t   \"attach_type:\\t%u\\n\",",
            "\t\t   info.netns.netns_ino,",
            "\t\t   info.netns.attach_type);",
            "}",
            "static int __netns_bpf_prog_query(const union bpf_attr *attr,",
            "\t\t\t\t  union bpf_attr __user *uattr,",
            "\t\t\t\t  struct net *net,",
            "\t\t\t\t  enum netns_bpf_attach_type type)",
            "{",
            "\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);",
            "\tstruct bpf_prog_array *run_array;",
            "\tu32 prog_cnt = 0, flags = 0;",
            "",
            "\trun_array = rcu_dereference_protected(net->bpf.run_array[type],",
            "\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));",
            "\tif (run_array)",
            "\t\tprog_cnt = bpf_prog_array_length(run_array);",
            "",
            "\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))",
            "\t\treturn -EFAULT;",
            "\tif (copy_to_user(&uattr->query.prog_cnt, &prog_cnt, sizeof(prog_cnt)))",
            "\t\treturn -EFAULT;",
            "\tif (!attr->query.prog_cnt || !prog_ids || !prog_cnt)",
            "\t\treturn 0;",
            "",
            "\treturn bpf_prog_array_copy_to_user(run_array, prog_ids,",
            "\t\t\t\t\t   attr->query.prog_cnt);",
            "}"
          ],
          "function_name": "bpf_netns_link_detach, bpf_netns_link_dealloc, bpf_netns_link_update_prog, bpf_netns_link_fill_info, bpf_netns_link_show_fdinfo, __netns_bpf_prog_query",
          "description": "提供BPF链接的销毁、程序更新、信息填充和展示功能，支持通过文件描述符获取网络命名空间信息，并实现程序查询接口。",
          "similarity": 0.4814637303352356
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/net_namespace.c",
          "start_line": 529,
          "end_line": 558,
          "content": [
            "static int __net_init netns_bpf_pernet_init(struct net *net)",
            "{",
            "\tint type;",
            "",
            "\tfor (type = 0; type < MAX_NETNS_BPF_ATTACH_TYPE; type++)",
            "\t\tINIT_LIST_HEAD(&net->bpf.links[type]);",
            "",
            "\treturn 0;",
            "}",
            "static void __net_exit netns_bpf_pernet_pre_exit(struct net *net)",
            "{",
            "\tenum netns_bpf_attach_type type;",
            "\tstruct bpf_netns_link *net_link;",
            "",
            "\tmutex_lock(&netns_bpf_mutex);",
            "\tfor (type = 0; type < MAX_NETNS_BPF_ATTACH_TYPE; type++) {",
            "\t\tnetns_bpf_run_array_detach(net, type);",
            "\t\tlist_for_each_entry(net_link, &net->bpf.links[type], node) {",
            "\t\t\tnet_link->net = NULL; /* auto-detach link */",
            "\t\t\tnetns_bpf_attach_type_unneed(type);",
            "\t\t}",
            "\t\tif (net->bpf.progs[type])",
            "\t\t\tbpf_prog_put(net->bpf.progs[type]);",
            "\t}",
            "\tmutex_unlock(&netns_bpf_mutex);",
            "}",
            "static int __init netns_bpf_init(void)",
            "{",
            "\treturn register_pernet_subsys(&netns_bpf_pernet_ops);",
            "}"
          ],
          "function_name": "netns_bpf_pernet_init, netns_bpf_pernet_pre_exit, netns_bpf_init",
          "description": "该代码块实现了网络命名空间中BPF程序的生命周期管理。`netns_bpf_pernet_init`初始化各类型的BPF链接链表，`netns_bpf_pernet_pre_exit`负责在命名空间销毁时安全释放BPF程序引用并标记链接自动分离，`netns_bpf_init`注册了per-net子系统以支持跨命名空间的BPF扩展。",
          "similarity": 0.46396535634994507
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/net_namespace.c",
          "start_line": 383,
          "end_line": 524,
          "content": [
            "int netns_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)",
            "{",
            "\tenum netns_bpf_attach_type type;",
            "\tstruct bpf_prog *prog;",
            "\tint ret;",
            "",
            "\tif (attr->target_fd)",
            "\t\treturn -EINVAL;",
            "",
            "\ttype = to_netns_bpf_attach_type(attr->attach_type);",
            "\tif (type < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);",
            "\tif (IS_ERR(prog))",
            "\t\treturn PTR_ERR(prog);",
            "",
            "\tmutex_lock(&netns_bpf_mutex);",
            "\tret = __netns_bpf_prog_detach(current->nsproxy->net_ns, type, prog);",
            "\tmutex_unlock(&netns_bpf_mutex);",
            "",
            "\tbpf_prog_put(prog);",
            "",
            "\treturn ret;",
            "}",
            "static int netns_bpf_max_progs(enum netns_bpf_attach_type type)",
            "{",
            "\tswitch (type) {",
            "\tcase NETNS_BPF_FLOW_DISSECTOR:",
            "\t\treturn 1;",
            "\tcase NETNS_BPF_SK_LOOKUP:",
            "\t\treturn 64;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static int netns_bpf_link_attach(struct net *net, struct bpf_link *link,",
            "\t\t\t\t enum netns_bpf_attach_type type)",
            "{",
            "\tstruct bpf_netns_link *net_link =",
            "\t\tcontainer_of(link, struct bpf_netns_link, link);",
            "\tstruct bpf_prog_array *run_array;",
            "\tint cnt, err;",
            "",
            "\tmutex_lock(&netns_bpf_mutex);",
            "",
            "\tcnt = link_count(net, type);",
            "\tif (cnt >= netns_bpf_max_progs(type)) {",
            "\t\terr = -E2BIG;",
            "\t\tgoto out_unlock;",
            "\t}",
            "\t/* Links are not compatible with attaching prog directly */",
            "\tif (net->bpf.progs[type]) {",
            "\t\terr = -EEXIST;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tswitch (type) {",
            "\tcase NETNS_BPF_FLOW_DISSECTOR:",
            "\t\terr = flow_dissector_bpf_prog_attach_check(net, link->prog);",
            "\t\tbreak;",
            "\tcase NETNS_BPF_SK_LOOKUP:",
            "\t\terr = 0; /* nothing to check */",
            "\t\tbreak;",
            "\tdefault:",
            "\t\terr = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "\tif (err)",
            "\t\tgoto out_unlock;",
            "",
            "\trun_array = bpf_prog_array_alloc(cnt + 1, GFP_KERNEL);",
            "\tif (!run_array) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tlist_add_tail(&net_link->node, &net->bpf.links[type]);",
            "",
            "\tfill_prog_array(net, type, run_array);",
            "\trun_array = rcu_replace_pointer(net->bpf.run_array[type], run_array,",
            "\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));",
            "\tbpf_prog_array_free(run_array);",
            "",
            "\t/* Mark attach point as used */",
            "\tnetns_bpf_attach_type_need(type);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&netns_bpf_mutex);",
            "\treturn err;",
            "}",
            "int netns_bpf_link_create(const union bpf_attr *attr, struct bpf_prog *prog)",
            "{",
            "\tenum netns_bpf_attach_type netns_type;",
            "\tstruct bpf_link_primer link_primer;",
            "\tstruct bpf_netns_link *net_link;",
            "\tenum bpf_attach_type type;",
            "\tstruct net *net;",
            "\tint err;",
            "",
            "\tif (attr->link_create.flags)",
            "\t\treturn -EINVAL;",
            "",
            "\ttype = attr->link_create.attach_type;",
            "\tnetns_type = to_netns_bpf_attach_type(type);",
            "\tif (netns_type < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tnet = get_net_ns_by_fd(attr->link_create.target_fd);",
            "\tif (IS_ERR(net))",
            "\t\treturn PTR_ERR(net);",
            "",
            "\tnet_link = kzalloc(sizeof(*net_link), GFP_USER);",
            "\tif (!net_link) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_put_net;",
            "\t}",
            "\tbpf_link_init(&net_link->link, BPF_LINK_TYPE_NETNS,",
            "\t\t      &bpf_netns_link_ops, prog);",
            "\tnet_link->net = net;",
            "\tnet_link->type = type;",
            "\tnet_link->netns_type = netns_type;",
            "",
            "\terr = bpf_link_prime(&net_link->link, &link_primer);",
            "\tif (err) {",
            "\t\tkfree(net_link);",
            "\t\tgoto out_put_net;",
            "\t}",
            "",
            "\terr = netns_bpf_link_attach(net, &net_link->link, netns_type);",
            "\tif (err) {",
            "\t\tbpf_link_cleanup(&link_primer);",
            "\t\tgoto out_put_net;",
            "\t}",
            "",
            "\tput_net(net);",
            "\treturn bpf_link_settle(&link_primer);",
            "",
            "out_put_net:",
            "\tput_net(net);",
            "\treturn err;",
            "}"
          ],
          "function_name": "netns_bpf_prog_detach, netns_bpf_max_progs, netns_bpf_link_attach, netns_bpf_link_create",
          "description": "创建BPF网络命名空间链接，检查最大程序数限制，将新链接插入到指定类型列表中，更新对应的运行程序数组并标记附加点为已使用状态。",
          "similarity": 0.4448019862174988
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/net_namespace.c",
          "start_line": 29,
          "end_line": 141,
          "content": [
            "static void netns_bpf_attach_type_unneed(enum netns_bpf_attach_type type)",
            "{",
            "\tswitch (type) {",
            "#ifdef CONFIG_INET",
            "\tcase NETNS_BPF_SK_LOOKUP:",
            "\t\tstatic_branch_dec(&bpf_sk_lookup_enabled);",
            "\t\tbreak;",
            "#endif",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "}",
            "static void netns_bpf_attach_type_need(enum netns_bpf_attach_type type)",
            "{",
            "\tswitch (type) {",
            "#ifdef CONFIG_INET",
            "\tcase NETNS_BPF_SK_LOOKUP:",
            "\t\tstatic_branch_inc(&bpf_sk_lookup_enabled);",
            "\t\tbreak;",
            "#endif",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "}",
            "static void netns_bpf_run_array_detach(struct net *net,",
            "\t\t\t\t       enum netns_bpf_attach_type type)",
            "{",
            "\tstruct bpf_prog_array *run_array;",
            "",
            "\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,",
            "\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));",
            "\tbpf_prog_array_free(run_array);",
            "}",
            "static int link_index(struct net *net, enum netns_bpf_attach_type type,",
            "\t\t      struct bpf_netns_link *link)",
            "{",
            "\tstruct bpf_netns_link *pos;",
            "\tint i = 0;",
            "",
            "\tlist_for_each_entry(pos, &net->bpf.links[type], node) {",
            "\t\tif (pos == link)",
            "\t\t\treturn i;",
            "\t\ti++;",
            "\t}",
            "\treturn -ENOENT;",
            "}",
            "static int link_count(struct net *net, enum netns_bpf_attach_type type)",
            "{",
            "\tstruct list_head *pos;",
            "\tint i = 0;",
            "",
            "\tlist_for_each(pos, &net->bpf.links[type])",
            "\t\ti++;",
            "\treturn i;",
            "}",
            "static void fill_prog_array(struct net *net, enum netns_bpf_attach_type type,",
            "\t\t\t    struct bpf_prog_array *prog_array)",
            "{",
            "\tstruct bpf_netns_link *pos;",
            "\tunsigned int i = 0;",
            "",
            "\tlist_for_each_entry(pos, &net->bpf.links[type], node) {",
            "\t\tprog_array->items[i].prog = pos->link.prog;",
            "\t\ti++;",
            "\t}",
            "}",
            "static void bpf_netns_link_release(struct bpf_link *link)",
            "{",
            "\tstruct bpf_netns_link *net_link =",
            "\t\tcontainer_of(link, struct bpf_netns_link, link);",
            "\tenum netns_bpf_attach_type type = net_link->netns_type;",
            "\tstruct bpf_prog_array *old_array, *new_array;",
            "\tstruct net *net;",
            "\tint cnt, idx;",
            "",
            "\tmutex_lock(&netns_bpf_mutex);",
            "",
            "\t/* We can race with cleanup_net, but if we see a non-NULL",
            "\t * struct net pointer, pre_exit has not run yet and wait for",
            "\t * netns_bpf_mutex.",
            "\t */",
            "\tnet = net_link->net;",
            "\tif (!net)",
            "\t\tgoto out_unlock;",
            "",
            "\t/* Mark attach point as unused */",
            "\tnetns_bpf_attach_type_unneed(type);",
            "",
            "\t/* Remember link position in case of safe delete */",
            "\tidx = link_index(net, type, net_link);",
            "\tlist_del(&net_link->node);",
            "",
            "\tcnt = link_count(net, type);",
            "\tif (!cnt) {",
            "\t\tnetns_bpf_run_array_detach(net, type);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\told_array = rcu_dereference_protected(net->bpf.run_array[type],",
            "\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));",
            "\tnew_array = bpf_prog_array_alloc(cnt, GFP_KERNEL);",
            "\tif (!new_array) {",
            "\t\tWARN_ON(bpf_prog_array_delete_safe_at(old_array, idx));",
            "\t\tgoto out_unlock;",
            "\t}",
            "\tfill_prog_array(net, type, new_array);",
            "\trcu_assign_pointer(net->bpf.run_array[type], new_array);",
            "\tbpf_prog_array_free(old_array);",
            "",
            "out_unlock:",
            "\tnet_link->net = NULL;",
            "\tmutex_unlock(&netns_bpf_mutex);",
            "}"
          ],
          "function_name": "netns_bpf_attach_type_unneed, netns_bpf_attach_type_need, netns_bpf_run_array_detach, link_index, link_count, fill_prog_array, bpf_netns_link_release",
          "description": "实现了BPF程序附加类型状态管理、运行数组更新、链接位置查找及释放逻辑，当链接被移除时会更新对应的运行程序数组并释放旧数组。",
          "similarity": 0.43317800760269165
        }
      ]
    }
  ]
}