{
  "query": "FIFO文件系统中管道缓冲区管理",
  "timestamp": "2025-12-26 01:15:48",
  "retrieved_files": [
    {
      "source_file": "kernel/watch_queue.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:50:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watch_queue.c`\n\n---\n\n# watch_queue.c 技术文档\n\n## 文件概述\n\n`watch_queue.c` 实现了 Linux 内核中的**监视队列**（Watch Queue）机制，这是一种基于管道（pipe）构建的通用事件通知系统。该机制允许内核子系统（如文件系统、密钥管理、设备驱动等）向用户空间异步发送结构化通知。用户空间通过创建特殊类型的管道并关联监视队列，即可接收来自内核的各类事件通知。该文件定义了通知的投递、过滤、缓冲管理及与管道集成的核心逻辑。\n\n## 核心功能\n\n### 主要函数\n\n- **`__post_watch_notification()`**  \n  核心通知投递函数。遍历指定 `watch_list` 中所有匹配 `id` 的监视器（`watch`），对每个关联的 `watch_queue` 应用过滤规则、安全检查，并将通知写入底层管道。\n\n- **`post_one_notification()`**  \n  将单个通知写入指定 `watch_queue` 的底层管道缓冲区。负责从预分配的通知页中获取空闲槽位、填充数据、更新管道头指针并唤醒等待读取的进程。\n\n- **`filter_watch_notification()`**  \n  根据 `watch_filter` 中的类型、子类型和信息掩码规则，判断是否允许特定通知通过。\n\n- **`watch_queue_set_size()`**  \n  为监视队列分配预分配的通知缓冲区（页数组和位图），并调整底层管道的环形缓冲区大小。\n\n- **`watch_queue_pipe_buf_release()`**  \n  管道缓冲区释放回调。当用户空间读取完通知后，将对应的通知槽位在位图中标记为空闲，供后续复用。\n\n### 关键数据结构\n\n- **`struct watch_queue`**  \n  表示一个监视队列，包含：\n  - 指向底层 `pipe_inode_info` 的指针\n  - 预分配的通知页数组（`notes`）\n  - 通知槽位空闲位图（`notes_bitmap`）\n  - 通知过滤器（`filter`）\n  - 保护锁（`lock`）\n\n- **`struct watch_notification`**  \n  通用通知记录格式，包含类型（`type`）、子类型（`subtype`）、信息字段（`info`，含长度和ID）及可变负载。\n\n- **`struct watch_filter` / `struct watch_type_filter`**  \n  定义通知过滤规则，支持按类型、子类型及信息字段的位掩码进行精确过滤。\n\n- **`watch_queue_pipe_buf_ops`**  \n  自定义的 `pipe_buf_operations`，用于管理监视队列专用管道缓冲区的生命周期。\n\n## 关键实现\n\n### 基于管道的通知传输\n- 监视队列复用内核管道（`pipe_inode_info`）作为通知传输通道，利用其成熟的读写、轮询、异步通知机制。\n- 通过自定义 `pipe_buf_operations`（`watch_queue_pipe_buf_ops`）实现通知槽位的回收：当用户读取通知后，`release` 回调将对应槽位在 `notes_bitmap` 中置位，标记为空闲。\n\n### 预分配通知缓冲区\n- 通知数据存储在预分配的内核页（`notes`）中，每页划分为多个固定大小（128字节）的槽位（`WATCH_QUEUE_NOTE_SIZE`）。\n- 使用位图（`notes_bitmap`）跟踪槽位使用状态，1 表示空闲。投递通知时通过 `find_first_bit()` 快速查找空闲槽位。\n- 缓冲区大小由用户通过 `watch_queue_set_size()` 设置（1-512个通知），并受管道缓冲区配额限制。\n\n### 通知投递流程\n1. **匹配监视器**：遍历 `watch_list`，查找 `id` 匹配的 `watch`。\n2. **应用过滤**：若队列配置了过滤器，调用 `filter_watch_notification()` 决定是否丢弃。\n3. **安全检查**：调用 LSM 钩子 `security_post_notification()` 进行权限验证。\n4. **写入管道**：\n   - 获取空闲通知槽位，复制通知数据。\n   - 构造 `pipe_buffer` 指向该槽位，设置自定义操作集。\n   - 更新管道 `head` 指针，唤醒等待读取的进程。\n   - 若缓冲区满，标记前一个缓冲区为 `PIPE_BUF_FLAG_LOSS` 表示丢包。\n\n### 并发与同步\n- **RCU 保护**：`watch_list` 和 `watch_queue` 的访问通过 RCU 机制保护，确保遍历时结构体不被释放。\n- **自旋锁**：\n  - `wqueue->lock`：保护 `wqueue` 状态（如 `pipe` 指针有效性）。\n  - `pipe->rd_wait.lock`：保护管道环形缓冲区的读写操作。\n- **原子操作**：管道 `head` 指针使用 `smp_store_release()` 更新，确保与 `pipe_read()` 的同步。\n\n## 依赖关系\n\n- **管道子系统**（`fs/pipe.c`）  \n  依赖管道的核心数据结构（`pipe_inode_info`、`pipe_buffer`）和操作接口（`pipe_buf()`、`pipe_full()`、`generic_pipe_buf_*`）。\n\n- **内存管理**  \n  使用 `alloc_page()`、`kmap_atomic()` 管理通知缓冲区页，`bitmap_alloc()` 管理槽位位图。\n\n- **安全模块**（LSM）  \n  通过 `security_post_notification()` 钩子集成安全策略。\n\n- **用户空间接口**  \n  与 `fs/watch_queue.c` 中的系统调用（如 `watch_queue_set_size()`）协同工作，后者负责创建监视队列并与管道关联。\n\n- **头文件依赖**  \n  `linux/watch_queue.h`（核心数据结构定义）、`linux/pipe_fs_i.h`（管道内部接口）。\n\n## 使用场景\n\n- **文件系统事件监控**  \n  如 `fsnotify` 子系统可通过监视队列向用户空间报告文件访问、修改等事件。\n\n- **密钥管理通知**  \n  内核密钥环（`KEYS`）子系统使用该机制通知密钥状态变更（如过期、撤销）。\n\n- **设备事件上报**  \n  设备驱动可利用监视队列异步上报硬件状态变化或错误事件。\n\n- **通用内核事件分发**  \n  任何需要向特权用户空间守护进程（如 `systemd`）发送结构化事件的内核子系统均可集成此机制。\n\n- **用户空间消费**  \n  应用程序通过 `open(\"/dev/watch_queue\")` 获取监视队列文件描述符，调用 `ioctl()` 设置缓冲区大小和过滤器，然后像读取普通管道一样接收通知。",
      "similarity": 0.6221644282341003,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/watch_queue.c",
          "start_line": 42,
          "end_line": 154,
          "content": [
            "static inline bool lock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_lock_bh(&wqueue->lock);",
            "\tif (unlikely(!wqueue->pipe)) {",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static inline void unlock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_unlock_bh(&wqueue->lock);",
            "}",
            "static void watch_queue_pipe_buf_release(struct pipe_inode_info *pipe,",
            "\t\t\t\t\t struct pipe_buffer *buf)",
            "{",
            "\tstruct watch_queue *wqueue = (struct watch_queue *)buf->private;",
            "\tstruct page *page;",
            "\tunsigned int bit;",
            "",
            "\t/* We need to work out which note within the page this refers to, but",
            "\t * the note might have been maximum size, so merely ANDing the offset",
            "\t * off doesn't work.  OTOH, the note must've been more than zero size.",
            "\t */",
            "\tbit = buf->offset + buf->len;",
            "\tif ((bit & (WATCH_QUEUE_NOTE_SIZE - 1)) == 0)",
            "\t\tbit -= WATCH_QUEUE_NOTE_SIZE;",
            "\tbit /= WATCH_QUEUE_NOTE_SIZE;",
            "",
            "\tpage = buf->page;",
            "\tbit += page->index;",
            "",
            "\tset_bit(bit, wqueue->notes_bitmap);",
            "\tgeneric_pipe_buf_release(pipe, buf);",
            "}",
            "static bool post_one_notification(struct watch_queue *wqueue,",
            "\t\t\t\t  struct watch_notification *n)",
            "{",
            "\tvoid *p;",
            "\tstruct pipe_inode_info *pipe = wqueue->pipe;",
            "\tstruct pipe_buffer *buf;",
            "\tstruct page *page;",
            "\tunsigned int head, tail, note, offset, len;",
            "\tbool done = false;",
            "",
            "\tspin_lock_irq(&pipe->rd_wait.lock);",
            "",
            "\thead = pipe->head;",
            "\ttail = pipe->tail;",
            "\tif (pipe_full(head, tail, pipe->ring_size))",
            "\t\tgoto lost;",
            "",
            "\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);",
            "\tif (note >= wqueue->nr_notes)",
            "\t\tgoto lost;",
            "",
            "\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];",
            "\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;",
            "\tget_page(page);",
            "\tlen = n->info & WATCH_INFO_LENGTH;",
            "\tp = kmap_atomic(page);",
            "\tmemcpy(p + offset, n, len);",
            "\tkunmap_atomic(p);",
            "",
            "\tbuf = pipe_buf(pipe, head);",
            "\tbuf->page = page;",
            "\tbuf->private = (unsigned long)wqueue;",
            "\tbuf->ops = &watch_queue_pipe_buf_ops;",
            "\tbuf->offset = offset;",
            "\tbuf->len = len;",
            "\tbuf->flags = PIPE_BUF_FLAG_WHOLE;",
            "\tsmp_store_release(&pipe->head, head + 1); /* vs pipe_read() */",
            "",
            "\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {",
            "\t\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\t\tBUG();",
            "\t}",
            "\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);",
            "\tdone = true;",
            "",
            "out:",
            "\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\tif (done)",
            "\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);",
            "\treturn done;",
            "",
            "lost:",
            "\tbuf = pipe_buf(pipe, head - 1);",
            "\tbuf->flags |= PIPE_BUF_FLAG_LOSS;",
            "\tgoto out;",
            "}",
            "static bool filter_watch_notification(const struct watch_filter *wf,",
            "\t\t\t\t      const struct watch_notification *n)",
            "{",
            "\tconst struct watch_type_filter *wt;",
            "\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;",
            "\tunsigned int st_index = n->subtype / st_bits;",
            "\tunsigned int st_bit = 1U << (n->subtype % st_bits);",
            "\tint i;",
            "",
            "\tif (!test_bit(n->type, wf->type_filter))",
            "\t\treturn false;",
            "",
            "\tfor (i = 0; i < wf->nr_filters; i++) {",
            "\t\twt = &wf->filters[i];",
            "\t\tif (n->type == wt->type &&",
            "\t\t    (wt->subtype_filter[st_index] & st_bit) &&",
            "\t\t    (n->info & wt->info_mask) == wt->info_filter)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false; /* If there is a filter, the default is to reject. */",
            "}"
          ],
          "function_name": "lock_wqueue, unlock_wqueue, watch_queue_pipe_buf_release, post_one_notification, filter_watch_notification",
          "description": "实现了watch_queue的锁操作、缓冲区释放、通知提交及过滤逻辑。lock_wqueue/unlock_wqueue用于保护队列访问，watch_queue_pipe_buf_release处理缓冲区回收并更新位图，post_one_notification将通知数据写入管道，filter_watch_notification进行类型和子类型的匹配判断。",
          "similarity": 0.5768950581550598
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watch_queue.c",
          "start_line": 193,
          "end_line": 304,
          "content": [
            "void __post_watch_notification(struct watch_list *wlist,",
            "\t\t\t       struct watch_notification *n,",
            "\t\t\t       const struct cred *cred,",
            "\t\t\t       u64 id)",
            "{",
            "\tconst struct watch_filter *wf;",
            "\tstruct watch_queue *wqueue;",
            "\tstruct watch *watch;",
            "",
            "\tif (((n->info & WATCH_INFO_LENGTH) >> WATCH_INFO_LENGTH__SHIFT) == 0) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\trcu_read_lock();",
            "",
            "\thlist_for_each_entry_rcu(watch, &wlist->watchers, list_node) {",
            "\t\tif (watch->id != id)",
            "\t\t\tcontinue;",
            "\t\tn->info &= ~WATCH_INFO_ID;",
            "\t\tn->info |= watch->info_id;",
            "",
            "\t\twqueue = rcu_dereference(watch->queue);",
            "\t\twf = rcu_dereference(wqueue->filter);",
            "\t\tif (wf && !filter_watch_notification(wf, n))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (security_post_notification(watch->cred, cred, n) < 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (lock_wqueue(wqueue)) {",
            "\t\t\tpost_one_notification(wqueue, n);",
            "\t\t\tunlock_wqueue(wqueue);",
            "\t\t}",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "}",
            "long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)",
            "{",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tstruct page **pages;",
            "\tunsigned long *bitmap;",
            "\tunsigned long user_bufs;",
            "\tint ret, i, nr_pages;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "\tif (wqueue->notes)",
            "\t\treturn -EBUSY;",
            "",
            "\tif (nr_notes < 1 ||",
            "\t    nr_notes > 512) /* TODO: choose a better hard limit */",
            "\t\treturn -EINVAL;",
            "",
            "\tnr_pages = (nr_notes + WATCH_QUEUE_NOTES_PER_PAGE - 1);",
            "\tnr_pages /= WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tuser_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_pages);",
            "",
            "\tif (nr_pages > pipe->max_usage &&",
            "\t    (too_many_pipe_buffers_hard(user_bufs) ||",
            "\t     too_many_pipe_buffers_soft(user_bufs)) &&",
            "\t    pipe_is_unprivileged_user()) {",
            "\t\tret = -EPERM;",
            "\t\tgoto error;",
            "\t}",
            "",
            "\tnr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "",
            "\t/*",
            "\t * pipe_resize_ring() does not update nr_accounted for watch_queue",
            "\t * pipes, because the above vastly overprovisions. Set nr_accounted on",
            "\t * and max_usage this pipe to the number that was actually charged to",
            "\t * the user above via account_pipe_buffers.",
            "\t */",
            "\tpipe->max_usage = nr_pages;",
            "\tpipe->nr_accounted = nr_pages;",
            "",
            "\tret = -ENOMEM;",
            "\tpages = kcalloc(sizeof(struct page *), nr_pages, GFP_KERNEL);",
            "\tif (!pages)",
            "\t\tgoto error;",
            "",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tpages[i] = alloc_page(GFP_KERNEL);",
            "\t\tif (!pages[i])",
            "\t\t\tgoto error_p;",
            "\t\tpages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\t}",
            "",
            "\tbitmap = bitmap_alloc(nr_notes, GFP_KERNEL);",
            "\tif (!bitmap)",
            "\t\tgoto error_p;",
            "",
            "\tbitmap_fill(bitmap, nr_notes);",
            "\twqueue->notes = pages;",
            "\twqueue->notes_bitmap = bitmap;",
            "\twqueue->nr_pages = nr_pages;",
            "\twqueue->nr_notes = nr_notes;",
            "\treturn 0;",
            "",
            "error_p:",
            "\twhile (--i >= 0)",
            "\t\t__free_page(pages[i]);",
            "\tkfree(pages);",
            "error:",
            "\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->nr_accounted);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__post_watch_notification, watch_queue_set_size",
          "description": "__post_watch_notification遍历watch列表并应用过滤器后提交通知，watch_queue_set_size动态调整管道容量，通过计算所需页数和位图分配，限制最大容量为512个笔记，支持扩展性需求。",
          "similarity": 0.4980880618095398
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/watch_queue.c",
          "start_line": 602,
          "end_line": 680,
          "content": [
            "void watch_queue_clear(struct watch_queue *wqueue)",
            "{",
            "\tstruct watch_list *wlist;",
            "\tstruct watch *watch;",
            "\tbool release;",
            "",
            "\trcu_read_lock();",
            "\tspin_lock_bh(&wqueue->lock);",
            "",
            "\t/*",
            "\t * This pipe can be freed by callers like free_pipe_info().",
            "\t * Removing this reference also prevents new notifications.",
            "\t */",
            "\twqueue->pipe = NULL;",
            "",
            "\twhile (!hlist_empty(&wqueue->watches)) {",
            "\t\twatch = hlist_entry(wqueue->watches.first, struct watch, queue_node);",
            "\t\thlist_del_init_rcu(&watch->queue_node);",
            "\t\t/* We now own a ref on the watch. */",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "",
            "\t\t/* We can't do the next bit under the queue lock as we need to",
            "\t\t * get the list lock - which would cause a deadlock if someone",
            "\t\t * was removing from the opposite direction at the same time or",
            "\t\t * posting a notification.",
            "\t\t */",
            "\t\twlist = rcu_dereference(watch->watch_list);",
            "\t\tif (wlist) {",
            "\t\t\tvoid (*release_watch)(struct watch *);",
            "",
            "\t\t\tspin_lock(&wlist->lock);",
            "",
            "\t\t\trelease = !hlist_unhashed(&watch->list_node);",
            "\t\t\tif (release) {",
            "\t\t\t\thlist_del_init_rcu(&watch->list_node);",
            "\t\t\t\trcu_assign_pointer(watch->watch_list, NULL);",
            "",
            "\t\t\t\t/* We now own a second ref on the watch. */",
            "\t\t\t}",
            "",
            "\t\t\trelease_watch = wlist->release_watch;",
            "\t\t\tspin_unlock(&wlist->lock);",
            "",
            "\t\t\tif (release) {",
            "\t\t\t\tif (release_watch) {",
            "\t\t\t\t\trcu_read_unlock();",
            "\t\t\t\t\t/* This might need to call dput(), so",
            "\t\t\t\t\t * we have to drop all the locks.",
            "\t\t\t\t\t */",
            "\t\t\t\t\t(*release_watch)(watch);",
            "\t\t\t\t\trcu_read_lock();",
            "\t\t\t\t}",
            "\t\t\t\tput_watch(watch);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tput_watch(watch);",
            "\t\tspin_lock_bh(&wqueue->lock);",
            "\t}",
            "",
            "\tspin_unlock_bh(&wqueue->lock);",
            "\trcu_read_unlock();",
            "}",
            "int watch_queue_init(struct pipe_inode_info *pipe)",
            "{",
            "\tstruct watch_queue *wqueue;",
            "",
            "\twqueue = kzalloc(sizeof(*wqueue), GFP_KERNEL);",
            "\tif (!wqueue)",
            "\t\treturn -ENOMEM;",
            "",
            "\twqueue->pipe = pipe;",
            "\tkref_init(&wqueue->usage);",
            "\tspin_lock_init(&wqueue->lock);",
            "\tINIT_HLIST_HEAD(&wqueue->watches);",
            "",
            "\tpipe->watch_queue = wqueue;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "watch_queue_clear, watch_queue_init",
          "description": "该代码实现了监视队列的初始化与清理功能。  \n`watch_queue_clear`通过RCU和自旋锁机制安全地移除所有监视项并释放资源，`watch_queue_init`初始化监视队列结构并绑定至管道对象。  \n上下文不完整：`release_watch`等关键函数依赖外部定义，部分RCU回调逻辑未完全展示。",
          "similarity": 0.49736249446868896
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/watch_queue.c",
          "start_line": 315,
          "end_line": 422,
          "content": [
            "long watch_queue_set_filter(struct pipe_inode_info *pipe,",
            "\t\t\t    struct watch_notification_filter __user *_filter)",
            "{",
            "\tstruct watch_notification_type_filter *tf;",
            "\tstruct watch_notification_filter filter;",
            "\tstruct watch_type_filter *q;",
            "\tstruct watch_filter *wfilter;",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tint ret, nr_filter = 0, i;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (!_filter) {",
            "\t\t/* Remove the old filter */",
            "\t\twfilter = NULL;",
            "\t\tgoto set;",
            "\t}",
            "",
            "\t/* Grab the user's filter specification */",
            "\tif (copy_from_user(&filter, _filter, sizeof(filter)) != 0)",
            "\t\treturn -EFAULT;",
            "\tif (filter.nr_filters == 0 ||",
            "\t    filter.nr_filters > 16 ||",
            "\t    filter.__reserved != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\ttf = memdup_array_user(_filter->filters, filter.nr_filters, sizeof(*tf));",
            "\tif (IS_ERR(tf))",
            "\t\treturn PTR_ERR(tf);",
            "",
            "\tret = -EINVAL;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif ((tf[i].info_filter & ~tf[i].info_mask) ||",
            "\t\t    tf[i].info_mask & WATCH_INFO_LENGTH)",
            "\t\t\tgoto err_filter;",
            "\t\t/* Ignore any unknown types */",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "\t\tnr_filter++;",
            "\t}",
            "",
            "\t/* Now we need to build the internal filter from only the relevant",
            "\t * user-specified filters.",
            "\t */",
            "\tret = -ENOMEM;",
            "\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);",
            "\tif (!wfilter)",
            "\t\tgoto err_filter;",
            "\twfilter->nr_filters = nr_filter;",
            "",
            "\tq = wfilter->filters;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "",
            "\t\tq->type\t\t\t= tf[i].type;",
            "\t\tq->info_filter\t\t= tf[i].info_filter;",
            "\t\tq->info_mask\t\t= tf[i].info_mask;",
            "\t\tq->subtype_filter[0]\t= tf[i].subtype_filter[0];",
            "\t\t__set_bit(q->type, wfilter->type_filter);",
            "\t\tq++;",
            "\t}",
            "",
            "\tkfree(tf);",
            "set:",
            "\tpipe_lock(pipe);",
            "\twfilter = rcu_replace_pointer(wqueue->filter, wfilter,",
            "\t\t\t\t      lockdep_is_held(&pipe->mutex));",
            "\tpipe_unlock(pipe);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\treturn 0;",
            "",
            "err_filter:",
            "\tkfree(tf);",
            "\treturn ret;",
            "}",
            "static void __put_watch_queue(struct kref *kref)",
            "{",
            "\tstruct watch_queue *wqueue =",
            "\t\tcontainer_of(kref, struct watch_queue, usage);",
            "\tstruct watch_filter *wfilter;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < wqueue->nr_pages; i++)",
            "\t\t__free_page(wqueue->notes[i]);",
            "\tkfree(wqueue->notes);",
            "\tbitmap_free(wqueue->notes_bitmap);",
            "",
            "\twfilter = rcu_access_pointer(wqueue->filter);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\tkfree_rcu(wqueue, rcu);",
            "}",
            "void put_watch_queue(struct watch_queue *wqueue)",
            "{",
            "\tkref_put(&wqueue->usage, __put_watch_queue);",
            "}",
            "static void free_watch(struct rcu_head *rcu)",
            "{",
            "\tstruct watch *watch = container_of(rcu, struct watch, rcu);",
            "",
            "\tput_watch_queue(rcu_access_pointer(watch->queue));",
            "\tatomic_dec(&watch->cred->user->nr_watches);",
            "\tput_cred(watch->cred);",
            "\tkfree(watch);",
            "}"
          ],
          "function_name": "watch_queue_set_filter, __put_watch_queue, put_watch_queue, free_watch",
          "description": "watch_queue_set_filter设置过滤规则并转换为内核内部结构，__put_watch_queue释放watch_queue相关资源包括页面、位图和过滤器，put_watch_queue通过引用计数管理watch_queue生命周期，free_watch执行RCU回调完成最终释放。",
          "similarity": 0.43732255697250366
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/watch_queue.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Watch queue and general notification mechanism, built on pipes",
            " *",
            " * Copyright (C) 2020 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " *",
            " * See Documentation/core-api/watch_queue.rst",
            " */",
            "",
            "#define pr_fmt(fmt) \"watchq: \" fmt",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/pipe_fs_i.h>",
            "",
            "MODULE_DESCRIPTION(\"Watch queue\");",
            "MODULE_AUTHOR(\"Red Hat, Inc.\");",
            "",
            "#define WATCH_QUEUE_NOTE_SIZE 128",
            "#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)",
            "",
            "/*",
            " * This must be called under the RCU read-lock, which makes",
            " * sure that the wqueue still exists. It can then take the lock,",
            " * and check that the wqueue hasn't been destroyed, which in",
            " * turn makes sure that the notification pipe still exists.",
            " */"
          ],
          "function_name": null,
          "description": "定义了watch_queue模块的头部信息，包含常量WATCH_QUEUE_NOTE_SIZE和NOTES_PER_PAGE，声明模块许可证及作者信息，并引入相关内核头文件，为后续实现提供基础框架。",
          "similarity": 0.4324270784854889
        }
      ]
    },
    {
      "source_file": "kernel/pid_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:16:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_namespace.c`\n\n---\n\n# `pid_namespace.c` 技术文档\n\n## 1. 文件概述\n\n`pid_namespace.c` 是 Linux 内核中实现 **PID 命名空间（PID Namespace）** 的核心源文件。PID 命名空间是 Linux 容器技术（如 Docker、LXC）的关键基础组件之一，用于为不同进程组提供隔离的进程 ID 视图。每个 PID 命名空间拥有独立的 PID 分配空间，使得不同命名空间中的进程可以拥有相同的 PID 而互不干扰。\n\n该文件负责 PID 命名空间的创建、销毁、引用计数管理、资源回收以及命名空间内进程的批量终止（如容器退出时清理所有子进程）等核心功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct pid_namespace`：表示一个 PID 命名空间，包含：\n  - `level`：命名空间层级（init_pid_ns 为 0，子命名空间依次递增）\n  - `parent`：指向父命名空间的指针\n  - `user_ns`：关联的用户命名空间\n  - `idr`：用于分配和管理 PID 的 IDR（整数到指针映射）结构\n  - `pid_cachep`：用于分配 `struct pid` 对象的 slab 缓存\n  - `pid_allocated`：当前命名空间中已分配的 PID 数量\n  - `ucounts`：用于限制用户命名空间下 PID 命名空间数量的计数器\n\n### 主要函数\n- `create_pid_cachep(unsigned int level)`  \n  为指定层级的 PID 命名空间创建专用的 `struct pid` slab 缓存。\n  \n- `create_pid_namespace(struct user_namespace *user_ns, struct pid_namespace *parent_pid_ns)`  \n  创建一个新的 PID 命名空间，设置层级、父命名空间、用户命名空间等属性，并初始化 IDR 和引用计数。\n\n- `copy_pid_ns(unsigned long flags, struct user_namespace *user_ns, struct pid_namespace *old_ns)`  \n  在 `clone()` 或 `unshare()` 系统调用中被调用，根据 `CLONE_NEWPID` 标志决定是否创建新的 PID 命名空间。\n\n- `put_pid_ns(struct pid_namespace *ns)`  \n  递减 PID 命名空间的引用计数，若引用计数归零则递归销毁该命名空间及其子命名空间。\n\n- `zap_pid_ns_processes(struct pid_namespace *pid_ns)`  \n  在 PID 命名空间的 init 进程退出时调用，向命名空间内所有剩余进程发送 `SIGKILL`，并等待其全部退出，确保命名空间干净回收。\n\n- `delayed_free_pidns(struct rcu_head *p)`  \n  通过 RCU 机制延迟释放 PID 命名空间结构体，确保所有并发读取完成后再释放内存。\n\n## 3. 关键实现\n\n### PID 命名空间层级与缓存管理\n- PID 命名空间支持嵌套，最大深度由 `MAX_PID_NS_LEVEL` 限制（通常为 32）。\n- 每个层级使用独立的 slab 缓存（`pid_cache[level - 1]`）来分配 `struct pid`，因为 `struct pid` 中的 `numbers[]` 数组大小依赖于命名空间层级（`level + 1`）。\n- 缓存创建通过 `create_pid_cachep()` 实现，使用互斥锁 `pid_caches_mutex` 避免并发创建冲突。\n\n### 引用计数与生命周期管理\n- 使用 `refcount_t` 管理命名空间引用计数。\n- `put_pid_ns()` 采用**尾递归方式**向上遍历父命名空间链，逐级释放无引用的命名空间。\n- 实际内存释放通过 RCU 回调 `delayed_free_pidns()` 延迟执行，保证并发安全。\n\n### 命名空间退出清理机制（`zap_pid_ns_processes`）\n- **禁用新 PID 分配**：调用 `disable_pid_allocation()` 阻止新进程加入。\n- **忽略 SIGCHLD**：使 init 进程自动回收僵尸子进程，避免阻塞。\n- **批量 SIGKILL**：遍历 IDR 中所有 PID，向对应进程发送 `SIGKILL`。\n- **等待所有进程退出**：通过 `kernel_wait4()` 回收直接子进程，并通过检查 `pid_allocated == init_pids` 确保所有进程（包括跨命名空间 fork 的僵尸进程）均已退出。\n- **RCU 安全调度**：在等待循环中调用 `exit_tasks_rcu_stop/start()` 避免与 `synchronize_rcu_tasks()` 死锁。\n\n### 资源限制\n- 通过 `inc_pid_namespaces()` / `dec_pid_namespaces()` 调用 `ucounts` 机制，限制每个用户命名空间可创建的 PID 命名空间数量，防止资源耗尽。\n\n## 4. 依赖关系\n\n- **`<linux/pid.h>` / `<linux/pid_namespace.h>`**：定义 `struct pid` 和 `struct pid_namespace`。\n- **`<linux/user_namespace.h>`**：依赖用户命名空间进行权限和资源限制。\n- **`<linux/idr.h>`**：使用 IDR 数据结构管理 PID 分配。\n- **`<linux/slab.h>`**：使用 kmem_cache 管理内存分配。\n- **`<linux/sched/*.h>`**：访问任务结构、信号处理、RCU 任务同步等。\n- **`<linux/proc_ns.h>`**：支持 `/proc/[pid]/ns/pid` 接口。\n- **`\"pid_sysctl.h\"`**：提供 sysctl 配置（如 `memfd_noexec_scope`）。\n- **`<linux/acct.h>`**：在命名空间销毁时清理进程会计信息。\n\n## 5. 使用场景\n\n- **容器启动**：当执行 `unshare(CLONE_NEWPID)` 或 `clone(CLONE_NEWPID)` 时，内核调用 `copy_pid_ns()` 创建新的 PID 命名空间，使容器内进程拥有独立的 PID 视图（容器内 PID 1 对应宿主机某个高 PID）。\n- **容器退出**：当容器的 init 进程（PID 1）退出时，内核自动调用 `zap_pid_ns_processes()` 终止命名空间内所有剩余进程，防止孤儿进程泄漏。\n- **命名空间嵌套**：支持多层容器或 sandbox 场景，如 systemd-nspawn 嵌套运行容器。\n- **资源隔离与限制**：结合用户命名空间，限制非特权用户创建过多 PID 命名空间，提升系统安全性。\n- **进程迁移与检查点**：配合 CRIU（Checkpoint/Restore in Userspace）等工具，通过 sysctl 接口控制命名空间行为（如 memfd 执行权限）。",
      "similarity": 0.5687899589538574,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 1,
          "end_line": 67,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Pid namespaces",
            " *",
            " * Authors:",
            " *    (C) 2007 Pavel Emelyanov <xemul@openvz.org>, OpenVZ, SWsoft Inc.",
            " *    (C) 2007 Sukadev Bhattiprolu <sukadev@us.ibm.com>, IBM",
            " *     Many thanks to Oleg Nesterov for comments and help",
            " *",
            " */",
            "",
            "#include <linux/pid.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cred.h>",
            "#include <linux/err.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/reboot.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/idr.h>",
            "#include <uapi/linux/wait.h>",
            "#include \"pid_sysctl.h\"",
            "",
            "static DEFINE_MUTEX(pid_caches_mutex);",
            "static struct kmem_cache *pid_ns_cachep;",
            "/* Write once array, filled from the beginning. */",
            "static struct kmem_cache *pid_cache[MAX_PID_NS_LEVEL];",
            "",
            "/*",
            " * creates the kmem cache to allocate pids from.",
            " * @level: pid namespace level",
            " */",
            "",
            "static struct kmem_cache *create_pid_cachep(unsigned int level)",
            "{",
            "\t/* Level 0 is init_pid_ns.pid_cachep */",
            "\tstruct kmem_cache **pkc = &pid_cache[level - 1];",
            "\tstruct kmem_cache *kc;",
            "\tchar name[4 + 10 + 1];",
            "\tunsigned int len;",
            "",
            "\tkc = READ_ONCE(*pkc);",
            "\tif (kc)",
            "\t\treturn kc;",
            "",
            "\tsnprintf(name, sizeof(name), \"pid_%u\", level + 1);",
            "\tlen = struct_size_t(struct pid, numbers, level + 1);",
            "\tmutex_lock(&pid_caches_mutex);",
            "\t/* Name collision forces to do allocation under mutex. */",
            "\tif (!*pkc)",
            "\t\t*pkc = kmem_cache_create(name, len, 0,",
            "\t\t\t\t\t SLAB_HWCACHE_ALIGN | SLAB_ACCOUNT, NULL);",
            "\tmutex_unlock(&pid_caches_mutex);",
            "\t/* current can fail, but someone else can succeed. */",
            "\treturn READ_ONCE(*pkc);",
            "}",
            "",
            "static struct ucounts *inc_pid_namespaces(struct user_namespace *ns)",
            "{",
            "\treturn inc_ucount(ns, current_euid(), UCOUNT_PID_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用于管理pid命名空间的kmem缓存创建函数create_pid_cachep，根据层级参数为不同pid命名空间级别创建专用内存池；inc_pid_namespaces函数用于增加用户命名空间的使用计数",
          "similarity": 0.511748731136322
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 281,
          "end_line": 379,
          "content": [
            "static int pid_ns_ctl_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);",
            "\tstruct ctl_table tmp = *table;",
            "\tint ret, next;",
            "",
            "\tif (write && !checkpoint_restore_ns_capable(pid_ns->user_ns))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Writing directly to ns' last_pid field is OK, since this field",
            "\t * is volatile in a living namespace anyway and a code writing to",
            "\t * it should synchronize its usage with external means.",
            "\t */",
            "",
            "\tnext = idr_get_cursor(&pid_ns->idr) - 1;",
            "",
            "\ttmp.data = &next;",
            "\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);",
            "\tif (!ret && write)",
            "\t\tidr_set_cursor(&pid_ns->idr, next + 1);",
            "",
            "\treturn ret;",
            "}",
            "int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)",
            "{",
            "\tif (pid_ns == &init_pid_ns)",
            "\t\treturn 0;",
            "",
            "\tswitch (cmd) {",
            "\tcase LINUX_REBOOT_CMD_RESTART2:",
            "\tcase LINUX_REBOOT_CMD_RESTART:",
            "\t\tpid_ns->reboot = SIGHUP;",
            "\t\tbreak;",
            "",
            "\tcase LINUX_REBOOT_CMD_POWER_OFF:",
            "\tcase LINUX_REBOOT_CMD_HALT:",
            "\t\tpid_ns->reboot = SIGINT;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tsend_sig(SIGKILL, pid_ns->child_reaper, 1);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tdo_exit(0);",
            "",
            "\t/* Not reached */",
            "\treturn 0;",
            "}",
            "static void pidns_put(struct ns_common *ns)",
            "{",
            "\tput_pid_ns(to_pid_ns(ns));",
            "}",
            "static int pidns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct nsproxy *nsproxy = nsset->nsproxy;",
            "\tstruct pid_namespace *active = task_active_pid_ns(current);",
            "\tstruct pid_namespace *ancestor, *new = to_pid_ns(ns);",
            "",
            "\tif (!ns_capable(new->user_ns, CAP_SYS_ADMIN) ||",
            "\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Only allow entering the current active pid namespace",
            "\t * or a child of the current active pid namespace.",
            "\t *",
            "\t * This is required for fork to return a usable pid value and",
            "\t * this maintains the property that processes and their",
            "\t * children can not escape their current pid namespace.",
            "\t */",
            "\tif (new->level < active->level)",
            "\t\treturn -EINVAL;",
            "",
            "\tancestor = new;",
            "\twhile (ancestor->level > active->level)",
            "\t\tancestor = ancestor->parent;",
            "\tif (ancestor != active)",
            "\t\treturn -EINVAL;",
            "",
            "\tput_pid_ns(nsproxy->pid_ns_for_children);",
            "\tnsproxy->pid_ns_for_children = get_pid_ns(new);",
            "\treturn 0;",
            "}",
            "static __init int pid_namespaces_init(void)",
            "{",
            "\tpid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC | SLAB_ACCOUNT);",
            "",
            "#ifdef CONFIG_CHECKPOINT_RESTORE",
            "\tregister_sysctl_init(\"kernel\", pid_ns_ctl_table);",
            "#endif",
            "",
            "\tregister_pid_ns_sysctl_table_vm();",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pid_ns_ctl_handler, reboot_pid_ns, pidns_put, pidns_install, pid_namespaces_init",
          "description": "包含pid命名空间控制接口处理函数pid_ns_ctl_handler，reboot_pid_ns设置命名空间重启信号，pidns_install验证命名空间层级权限并进行安装操作，pid_namespaces_init完成核心数据结构初始化和sysctl注册",
          "similarity": 0.5075894594192505
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 68,
          "end_line": 208,
          "content": [
            "static void dec_pid_namespaces(struct ucounts *ucounts)",
            "{",
            "\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);",
            "}",
            "static void delayed_free_pidns(struct rcu_head *p)",
            "{",
            "\tstruct pid_namespace *ns = container_of(p, struct pid_namespace, rcu);",
            "",
            "\tdec_pid_namespaces(ns->ucounts);",
            "\tput_user_ns(ns->user_ns);",
            "",
            "\tkmem_cache_free(pid_ns_cachep, ns);",
            "}",
            "static void destroy_pid_namespace(struct pid_namespace *ns)",
            "{",
            "\tns_free_inum(&ns->ns);",
            "",
            "\tidr_destroy(&ns->idr);",
            "\tcall_rcu(&ns->rcu, delayed_free_pidns);",
            "}",
            "void put_pid_ns(struct pid_namespace *ns)",
            "{",
            "\tstruct pid_namespace *parent;",
            "",
            "\twhile (ns != &init_pid_ns) {",
            "\t\tparent = ns->parent;",
            "\t\tif (!refcount_dec_and_test(&ns->ns.count))",
            "\t\t\tbreak;",
            "\t\tdestroy_pid_namespace(ns);",
            "\t\tns = parent;",
            "\t}",
            "}",
            "void zap_pid_ns_processes(struct pid_namespace *pid_ns)",
            "{",
            "\tint nr;",
            "\tint rc;",
            "\tstruct task_struct *task, *me = current;",
            "\tint init_pids = thread_group_leader(me) ? 1 : 2;",
            "\tstruct pid *pid;",
            "",
            "\t/* Don't allow any more processes into the pid namespace */",
            "\tdisable_pid_allocation(pid_ns);",
            "",
            "\t/*",
            "\t * Ignore SIGCHLD causing any terminated children to autoreap.",
            "\t * This speeds up the namespace shutdown, plus see the comment",
            "\t * below.",
            "\t */",
            "\tspin_lock_irq(&me->sighand->siglock);",
            "\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;",
            "\tspin_unlock_irq(&me->sighand->siglock);",
            "",
            "\t/*",
            "\t * The last thread in the cgroup-init thread group is terminating.",
            "\t * Find remaining pid_ts in the namespace, signal and wait for them",
            "\t * to exit.",
            "\t *",
            "\t * Note:  This signals each threads in the namespace - even those that",
            "\t * \t  belong to the same thread group, To avoid this, we would have",
            "\t * \t  to walk the entire tasklist looking a processes in this",
            "\t * \t  namespace, but that could be unnecessarily expensive if the",
            "\t * \t  pid namespace has just a few processes. Or we need to",
            "\t * \t  maintain a tasklist for each pid namespace.",
            "\t *",
            "\t */",
            "\trcu_read_lock();",
            "\tread_lock(&tasklist_lock);",
            "\tnr = 2;",
            "\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {",
            "\t\ttask = pid_task(pid, PIDTYPE_PID);",
            "\t\tif (task && !__fatal_signal_pending(task))",
            "\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.",
            "\t * kernel_wait4() will also block until our children traced from the",
            "\t * parent namespace are detached and become EXIT_DEAD.",
            "\t */",
            "\tdo {",
            "\t\tclear_thread_flag(TIF_SIGPENDING);",
            "\t\tclear_thread_flag(TIF_NOTIFY_SIGNAL);",
            "\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);",
            "\t} while (rc != -ECHILD);",
            "",
            "\t/*",
            "\t * kernel_wait4() misses EXIT_DEAD children, and EXIT_ZOMBIE",
            "\t * process whose parents processes are outside of the pid",
            "\t * namespace.  Such processes are created with setns()+fork().",
            "\t *",
            "\t * If those EXIT_ZOMBIE processes are not reaped by their",
            "\t * parents before their parents exit, they will be reparented",
            "\t * to pid_ns->child_reaper.  Thus pidns->child_reaper needs to",
            "\t * stay valid until they all go away.",
            "\t *",
            "\t * The code relies on the pid_ns->child_reaper ignoring",
            "\t * SIGCHILD to cause those EXIT_ZOMBIE processes to be",
            "\t * autoreaped if reparented.",
            "\t *",
            "\t * Semantically it is also desirable to wait for EXIT_ZOMBIE",
            "\t * processes before allowing the child_reaper to be reaped, as",
            "\t * that gives the invariant that when the init process of a",
            "\t * pid namespace is reaped all of the processes in the pid",
            "\t * namespace are gone.",
            "\t *",
            "\t * Once all of the other tasks are gone from the pid_namespace",
            "\t * free_pid() will awaken this task.",
            "\t */",
            "\tfor (;;) {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tif (pid_ns->pid_allocated == init_pids)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * Release tasks_rcu_exit_srcu to avoid following deadlock:",
            "\t\t *",
            "\t\t * 1) TASK A unshare(CLONE_NEWPID)",
            "\t\t * 2) TASK A fork() twice -> TASK B (child reaper for new ns)",
            "\t\t *    and TASK C",
            "\t\t * 3) TASK B exits, kills TASK C, waits for TASK A to reap it",
            "\t\t * 4) TASK A calls synchronize_rcu_tasks()",
            "\t\t *                   -> synchronize_srcu(tasks_rcu_exit_srcu)",
            "\t\t * 5) *DEADLOCK*",
            "\t\t *",
            "\t\t * It is considered safe to release tasks_rcu_exit_srcu here",
            "\t\t * because we assume the current task can not be concurrently",
            "\t\t * reaped at this point.",
            "\t\t */",
            "\t\texit_tasks_rcu_stop();",
            "\t\tschedule();",
            "\t\texit_tasks_rcu_start();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tif (pid_ns->reboot)",
            "\t\tcurrent->signal->group_exit_code = pid_ns->reboot;",
            "",
            "\tacct_exit_ns(pid_ns);",
            "\treturn;",
            "}"
          ],
          "function_name": "dec_pid_namespaces, delayed_free_pidns, destroy_pid_namespace, put_pid_ns, zap_pid_ns_processes",
          "description": "包含销毁pid命名空间相关函数，其中destroy_pid_namespace通过RCU机制延迟释放资源，zap_pid_ns_processes强制终止命名空间内所有进程并回收资源，put_pid_ns管理命名空间引用计数",
          "similarity": 0.4951576888561249
        }
      ]
    },
    {
      "source_file": "kernel/bpf/inode.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:12:33\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\inode.c`\n\n---\n\n# `bpf/inode.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/inode.c` 实现了一个轻量级的虚拟文件系统（称为 **bpffs**），用于支持 eBPF 对象（包括 BPF 程序、映射和链接）的 **pinning（持久化）机制**。该文件系统允许用户空间通过标准文件系统操作（如 `mkdir`、`create`、`unlink` 等）将 BPF 对象绑定到文件系统路径，从而在进程退出后仍能保持对这些对象的引用，避免被内核自动释放。此机制是 `bpf(2)` 系统调用中 `BPF_OBJ_PIN` 和 `BPF_OBJ_GET` 功能的后端支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `enum bpf_type`：枚举类型，标识 BPF 对象类型（`BPF_TYPE_PROG`、`BPF_TYPE_MAP`、`BPF_TYPE_LINK`）。\n- `struct map_iter`：用于 BPF map 序列化遍历的迭代器结构，包含当前 key 和完成标志。\n- `const struct inode_operations`：分别为目录、程序、映射、链接定义的 inode 操作集合（`bpf_dir_iops`、`bpf_prog_iops` 等）。\n- `const struct file_operations`：\n  - `bpffs_map_fops`：支持对支持 `seq_show` 的 BPF map 进行 `cat` 读取。\n  - `bpffs_obj_fops`：通用只读文件操作，打开即返回 `-EIO`，防止误操作。\n\n### 主要函数\n\n- `bpf_any_get()` / `bpf_any_put()`：根据对象类型统一增加/减少引用计数。\n- `bpf_fd_probe_obj()`：通过文件描述符探测并获取对应的 BPF 对象及其类型。\n- `bpf_get_inode()`：为 bpffs 创建新的 inode（支持目录、普通文件、符号链接）。\n- `bpf_inode_type()`：根据 inode 的 `i_op` 字段反推其对应的 BPF 对象类型。\n- `bpf_dentry_finalize()`：完成 dentry 与 inode 的绑定并更新父目录时间戳。\n- `bpf_mkdir()`：实现 bpffs 中的目录创建。\n- `bpf_mkprog()` / `bpf_mkmap()` / `bpf_mklink()`：分别创建 BPF 程序、映射、链接对应的文件 inode。\n- `map_iter_alloc()` / `map_iter_free()`：管理 map 遍历迭代器的生命周期。\n- `map_seq_*` 系列函数：实现 BPF map 的 `seq_file` 遍历接口，用于 `cat` 输出。\n- `bpffs_map_open()` / `bpffs_map_release()`：map 文件的打开与释放，初始化 seq_file 上下文。\n- `bpf_lookup()`：自定义 lookup 逻辑，禁止文件名中包含 `.`（保留用于未来扩展）。\n\n## 3. 关键实现\n\n### BPF 对象引用管理\n通过 `bpf_any_get()` 和 `bpf_any_put()` 封装不同 BPF 对象（prog/map/link）的引用计数操作，确保在 inode 创建和销毁时正确持有/释放内核对象，防止内存泄漏或提前释放。\n\n### 对象类型识别\n利用 `inode->i_op` 指针的唯一性（分别指向 `bpf_prog_iops`、`bpf_map_iops` 等空结构体）作为类型标签，在运行时通过指针比较快速判断 inode 对应的 BPF 对象类型。\n\n### BPF Map 的可读性支持\n对于支持 `map_seq_show_elem` 操作的 BPF map（如 hash、array 等），通过 `seq_file` 机制实现 `cat /sys/fs/bpf/map_name` 输出内容。输出包含警告信息，强调格式不稳定，仅用于调试。\n\n### 安全与扩展性设计\n- 文件名中禁止出现 `.` 字符（如 `foo.bar`），为未来在 bpffs 中引入特殊文件（如元数据、控制接口）预留命名空间。\n- 普通 BPF 对象文件（prog/link 或不支持 seq_show 的 map）使用 `bpffs_obj_fops`，其 `open` 返回 `-EIO`，防止用户误读/误写导致未定义行为。\n\n### 虚拟文件系统集成\n基于 `simple_fs` 框架（如 `simple_dir_operations`、`simple_lookup`）构建，仅重写必要操作（如 `mkdir`、`lookup`、`create` 逻辑由上层调用 `bpf_mk*` 实现），保持代码简洁。\n\n## 4. 依赖关系\n\n- **BPF 子系统核心**：依赖 `<linux/bpf.h>`、`<linux/filter.h>` 提供的 `bpf_prog_*`、`bpf_map_*`、`bpf_link_*` 等核心 API。\n- **VFS 层**：依赖标准 VFS 接口（`<linux/fs.h>`、`<linux/namei.h>`、`<linux/dcache.h>`）实现 inode、dentry、file 操作。\n- **预加载机制**：包含 `\"preload/bpf_preload.h\"`，可能用于内核启动时预加载 BPF 对象。\n- **迭代器支持**：若 BPF link 为 iterator 类型，会使用 `bpf_iter_fops`（定义在其他文件中）。\n\n## 5. 使用场景\n\n- **BPF 对象持久化**：用户空间工具（如 `bpftool`）调用 `bpf(BPF_OBJ_PIN, ...)` 将 map/prog/link pin 到 `/sys/fs/bpf/` 下的路径，内核通过本文件创建对应 inode 并持有对象引用。\n- **跨进程共享 BPF 对象**：多个进程可通过 `bpf(BPF_OBJ_GET, ...)` 从同一 bpffs 路径获取已 pin 对象的 fd，实现共享。\n- **调试与可观测性**：支持 `seq_show` 的 map 可通过 `cat` 命令查看内容，辅助开发调试（注意：非稳定接口）。\n- **系统启动预加载**：结合 `bpf_preload` 机制，在内核初始化阶段将关键 BPF 程序/映射 pin 到 bpffs，供后续服务使用。",
      "similarity": 0.5679490566253662,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 680,
          "end_line": 783,
          "content": [
            "static void seq_print_delegate_opts(struct seq_file *m,",
            "\t\t\t\t    const char *opt_name,",
            "\t\t\t\t    const struct btf *btf,",
            "\t\t\t\t    const struct btf_type *enum_t,",
            "\t\t\t\t    const char *prefix,",
            "\t\t\t\t    u64 delegate_msk, u64 any_msk)",
            "{",
            "\tconst struct btf_enum *e;",
            "\tbool first = true;",
            "\tconst char *name;",
            "\tu64 msk;",
            "\tint i, n, pfx_len = strlen(prefix);",
            "",
            "\tdelegate_msk &= any_msk; /* clear unknown bits */",
            "",
            "\tif (delegate_msk == 0)",
            "\t\treturn;",
            "",
            "\tseq_printf(m, \",%s\", opt_name);",
            "\tif (delegate_msk == any_msk) {",
            "\t\tseq_printf(m, \"=any\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (btf && enum_t) {",
            "\t\tfor (i = 0, n = btf_vlen(enum_t); i < n; i++) {",
            "\t\t\te = &btf_enum(enum_t)[i];",
            "\t\t\tname = btf_name_by_offset(btf, e->name_off);",
            "\t\t\tif (!name || strncasecmp(name, prefix, pfx_len) != 0)",
            "\t\t\t\tcontinue;",
            "\t\t\tmsk = 1ULL << e->val;",
            "\t\t\tif (delegate_msk & msk) {",
            "\t\t\t\t/* emit lower-case name without prefix */",
            "\t\t\t\tseq_printf(m, \"%c\", first ? '=' : ':');",
            "\t\t\t\tname += pfx_len;",
            "\t\t\t\twhile (*name) {",
            "\t\t\t\t\tseq_printf(m, \"%c\", tolower(*name));",
            "\t\t\t\t\tname++;",
            "\t\t\t\t}",
            "",
            "\t\t\t\tdelegate_msk &= ~msk;",
            "\t\t\t\tfirst = false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif (delegate_msk)",
            "\t\tseq_printf(m, \"%c0x%llx\", first ? '=' : ':', delegate_msk);",
            "}",
            "static int bpf_show_options(struct seq_file *m, struct dentry *root)",
            "{",
            "\tstruct inode *inode = d_inode(root);",
            "\tumode_t mode = inode->i_mode & S_IALLUGO & ~S_ISVTX;",
            "\tstruct bpf_mount_opts *opts = root->d_sb->s_fs_info;",
            "\tu64 mask;",
            "",
            "\tif (!uid_eq(inode->i_uid, GLOBAL_ROOT_UID))",
            "\t\tseq_printf(m, \",uid=%u\",",
            "\t\t\t   from_kuid_munged(&init_user_ns, inode->i_uid));",
            "\tif (!gid_eq(inode->i_gid, GLOBAL_ROOT_GID))",
            "\t\tseq_printf(m, \",gid=%u\",",
            "\t\t\t   from_kgid_munged(&init_user_ns, inode->i_gid));",
            "\tif (mode != S_IRWXUGO)",
            "\t\tseq_printf(m, \",mode=%o\", mode);",
            "",
            "\tif (opts->delegate_cmds || opts->delegate_maps ||",
            "\t    opts->delegate_progs || opts->delegate_attachs) {",
            "\t\tstruct bpffs_btf_enums info;",
            "",
            "\t\t/* ignore errors, fallback to hex */",
            "\t\t(void)find_bpffs_btf_enums(&info);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_cmds\",",
            "\t\t\t\t\tinfo.btf, info.cmd_t, \"BPF_\",",
            "\t\t\t\t\topts->delegate_cmds, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_maps\",",
            "\t\t\t\t\tinfo.btf, info.map_t, \"BPF_MAP_TYPE_\",",
            "\t\t\t\t\topts->delegate_maps, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_progs\",",
            "\t\t\t\t\tinfo.btf, info.prog_t, \"BPF_PROG_TYPE_\",",
            "\t\t\t\t\topts->delegate_progs, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_attachs\",",
            "\t\t\t\t\tinfo.btf, info.attach_t, \"BPF_\",",
            "\t\t\t\t\topts->delegate_attachs, mask);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_free_inode(struct inode *inode)",
            "{",
            "\tenum bpf_type type;",
            "",
            "\tif (S_ISLNK(inode->i_mode))",
            "\t\tkfree(inode->i_link);",
            "\tif (!bpf_inode_type(inode, &type))",
            "\t\tbpf_any_put(inode->i_private, type);",
            "\tfree_inode_nonrcu(inode);",
            "}"
          ],
          "function_name": "seq_print_delegate_opts, bpf_show_options, bpf_free_inode",
          "description": "展示文件系统挂载参数，处理委托选项打印及inode释放时的资源回收操作",
          "similarity": 0.5490429401397705
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 53,
          "end_line": 155,
          "content": [
            "static void bpf_any_put(void *raw, enum bpf_type type)",
            "{",
            "\tswitch (type) {",
            "\tcase BPF_TYPE_PROG:",
            "\t\tbpf_prog_put(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_MAP:",
            "\t\tbpf_map_put_with_uref(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_LINK:",
            "\t\tbpf_link_put(raw);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "}",
            "static int bpf_inode_type(const struct inode *inode, enum bpf_type *type)",
            "{",
            "\t*type = BPF_TYPE_UNSPEC;",
            "\tif (inode->i_op == &bpf_prog_iops)",
            "\t\t*type = BPF_TYPE_PROG;",
            "\telse if (inode->i_op == &bpf_map_iops)",
            "\t\t*type = BPF_TYPE_MAP;",
            "\telse if (inode->i_op == &bpf_link_iops)",
            "\t\t*type = BPF_TYPE_LINK;",
            "\telse",
            "\t\treturn -EACCES;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,",
            "\t\t\t\tstruct inode *dir)",
            "{",
            "\td_instantiate(dentry, inode);",
            "\tdget(dentry);",
            "",
            "\tdir->i_mtime = inode_set_ctime_current(dir);",
            "}",
            "static int bpf_mkdir(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t     struct dentry *dentry, umode_t mode)",
            "{",
            "\tstruct inode *inode;",
            "",
            "\tinode = bpf_get_inode(dir->i_sb, dir, mode | S_IFDIR);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_dir_iops;",
            "\tinode->i_fop = &simple_dir_operations;",
            "",
            "\tinc_nlink(inode);",
            "\tinc_nlink(dir);",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static void map_iter_free(struct map_iter *iter)",
            "{",
            "\tif (iter) {",
            "\t\tkfree(iter->key);",
            "\t\tkfree(iter);",
            "\t}",
            "}",
            "static void map_seq_stop(struct seq_file *m, void *v)",
            "{",
            "}",
            "static int map_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct bpf_map *map = seq_file_to_map(m);",
            "\tvoid *key = map_iter(m)->key;",
            "",
            "\tif (unlikely(v == SEQ_START_TOKEN)) {",
            "\t\tseq_puts(m, \"# WARNING!! The output is for debug purpose only\\n\");",
            "\t\tseq_puts(m, \"# WARNING!! The output format will change\\n\");",
            "\t} else {",
            "\t\tmap->ops->map_seq_show_elem(map, key, m);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int bpffs_map_open(struct inode *inode, struct file *file)",
            "{",
            "\tstruct bpf_map *map = inode->i_private;",
            "\tstruct map_iter *iter;",
            "\tstruct seq_file *m;",
            "\tint err;",
            "",
            "\titer = map_iter_alloc(map);",
            "\tif (!iter)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = seq_open(file, &bpffs_map_seq_ops);",
            "\tif (err) {",
            "\t\tmap_iter_free(iter);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tm = file->private_data;",
            "\tm->private = iter;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_any_put, bpf_inode_type, bpf_dentry_finalize, bpf_mkdir, map_iter_free, map_seq_stop, map_seq_show, bpffs_map_open",
          "description": "实现BPF对象引用释放逻辑，inode类型识别，目录创建，迭代器管理及序列化展示功能",
          "similarity": 0.542218804359436
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 948,
          "end_line": 1061,
          "content": [
            "static bool bpf_preload_mod_get(void)",
            "{",
            "\t/* If bpf_preload.ko wasn't loaded earlier then load it now.",
            "\t * When bpf_preload is built into vmlinux the module's __init",
            "\t * function will populate it.",
            "\t */",
            "\tif (!bpf_preload_ops) {",
            "\t\trequest_module(\"bpf_preload\");",
            "\t\tif (!bpf_preload_ops)",
            "\t\t\treturn false;",
            "\t}",
            "\t/* And grab the reference, so the module doesn't disappear while the",
            "\t * kernel is interacting with the kernel module and its UMD.",
            "\t */",
            "\tif (!try_module_get(bpf_preload_ops->owner)) {",
            "\t\tpr_err(\"bpf_preload module get failed.\\n\");",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void bpf_preload_mod_put(void)",
            "{",
            "\tif (bpf_preload_ops)",
            "\t\t/* now user can \"rmmod bpf_preload\" if necessary */",
            "\t\tmodule_put(bpf_preload_ops->owner);",
            "}",
            "static int populate_bpffs(struct dentry *parent)",
            "{",
            "\tstruct bpf_preload_info objs[BPF_PRELOAD_LINKS] = {};",
            "\tint err = 0, i;",
            "",
            "\t/* grab the mutex to make sure the kernel interactions with bpf_preload",
            "\t * are serialized",
            "\t */",
            "\tmutex_lock(&bpf_preload_lock);",
            "",
            "\t/* if bpf_preload.ko wasn't built into vmlinux then load it */",
            "\tif (!bpf_preload_mod_get())",
            "\t\tgoto out;",
            "",
            "\terr = bpf_preload_ops->preload(objs);",
            "\tif (err)",
            "\t\tgoto out_put;",
            "\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {",
            "\t\tbpf_link_inc(objs[i].link);",
            "\t\terr = bpf_iter_link_pin_kernel(parent,",
            "\t\t\t\t\t       objs[i].link_name, objs[i].link);",
            "\t\tif (err) {",
            "\t\t\tbpf_link_put(objs[i].link);",
            "\t\t\tgoto out_put;",
            "\t\t}",
            "\t}",
            "out_put:",
            "\tbpf_preload_mod_put();",
            "out:",
            "\tmutex_unlock(&bpf_preload_lock);",
            "\treturn err;",
            "}",
            "static int bpf_fill_super(struct super_block *sb, struct fs_context *fc)",
            "{",
            "\tstatic const struct tree_descr bpf_rfiles[] = { { \"\" } };",
            "\tstruct bpf_mount_opts *opts = sb->s_fs_info;",
            "\tstruct inode *inode;",
            "\tint ret;",
            "",
            "\t/* Mounting an instance of BPF FS requires privileges */",
            "\tif (fc->user_ns != &init_user_ns && !capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tret = simple_fill_super(sb, BPF_FS_MAGIC, bpf_rfiles);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tsb->s_op = &bpf_super_ops;",
            "",
            "\tinode = sb->s_root->d_inode;",
            "\tinode->i_uid = opts->uid;",
            "\tinode->i_gid = opts->gid;",
            "\tinode->i_op = &bpf_dir_iops;",
            "\tinode->i_mode &= ~S_IALLUGO;",
            "\tpopulate_bpffs(sb->s_root);",
            "\tinode->i_mode |= S_ISVTX | opts->mode;",
            "\treturn 0;",
            "}",
            "static int bpf_get_tree(struct fs_context *fc)",
            "{",
            "\treturn get_tree_nodev(fc, bpf_fill_super);",
            "}",
            "static void bpf_free_fc(struct fs_context *fc)",
            "{",
            "\tkfree(fc->s_fs_info);",
            "}",
            "static int bpf_init_fs_context(struct fs_context *fc)",
            "{",
            "\tstruct bpf_mount_opts *opts;",
            "",
            "\topts = kzalloc(sizeof(struct bpf_mount_opts), GFP_KERNEL);",
            "\tif (!opts)",
            "\t\treturn -ENOMEM;",
            "",
            "\topts->mode = S_IRWXUGO;",
            "\topts->uid = current_fsuid();",
            "\topts->gid = current_fsgid();",
            "",
            "\t/* start out with no BPF token delegation enabled */",
            "\topts->delegate_cmds = 0;",
            "\topts->delegate_maps = 0;",
            "\topts->delegate_progs = 0;",
            "\topts->delegate_attachs = 0;",
            "",
            "\tfc->s_fs_info = opts;",
            "\tfc->ops = &bpf_context_ops;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_preload_mod_get, bpf_preload_mod_put, populate_bpffs, bpf_fill_super, bpf_get_tree, bpf_free_fc, bpf_init_fs_context",
          "description": "管理BPF预加载模块引用计数，填充BPF文件系统超级块数据，初始化文件系统上下文并设置默认挂载选项",
          "similarity": 0.5409075617790222
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 1080,
          "end_line": 1100,
          "content": [
            "static void bpf_kill_super(struct super_block *sb)",
            "{",
            "\tstruct bpf_mount_opts *opts = sb->s_fs_info;",
            "",
            "\tkill_litter_super(sb);",
            "\tkfree(opts);",
            "}",
            "static int __init bpf_init(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = sysfs_create_mount_point(fs_kobj, \"bpf\");",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = register_filesystem(&bpf_fs_type);",
            "\tif (ret)",
            "\t\tsysfs_remove_mount_point(fs_kobj, \"bpf\");",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_kill_super, bpf_init",
          "description": "注销BPF文件系统时释放超级块资源，初始化BPF文件系统类型并注册到sysfs挂载点",
          "similarity": 0.49902111291885376
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 479,
          "end_line": 593,
          "content": [
            "int bpf_obj_pin_user(u32 ufd, int path_fd, const char __user *pathname)",
            "{",
            "\tenum bpf_type type;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\traw = bpf_fd_probe_obj(ufd, &type);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tret = bpf_obj_do_pin(path_fd, pathname, raw, type);",
            "\tif (ret != 0)",
            "\t\tbpf_any_put(raw, type);",
            "",
            "\treturn ret;",
            "}",
            "int bpf_obj_get_user(int path_fd, const char __user *pathname, int flags)",
            "{",
            "\tenum bpf_type type = BPF_TYPE_UNSPEC;",
            "\tint f_flags;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\tf_flags = bpf_get_file_flag(flags);",
            "\tif (f_flags < 0)",
            "\t\treturn f_flags;",
            "",
            "\traw = bpf_obj_do_get(path_fd, pathname, &type, f_flags);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tif (type == BPF_TYPE_PROG)",
            "\t\tret = bpf_prog_new_fd(raw);",
            "\telse if (type == BPF_TYPE_MAP)",
            "\t\tret = bpf_map_new_fd(raw, f_flags);",
            "\telse if (type == BPF_TYPE_LINK)",
            "\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);",
            "\telse",
            "\t\treturn -ENOENT;",
            "",
            "\tif (ret < 0)",
            "\t\tbpf_any_put(raw, type);",
            "\treturn ret;",
            "}",
            "static int find_bpffs_btf_enums(struct bpffs_btf_enums *info)",
            "{",
            "\tconst struct btf *btf;",
            "\tconst struct btf_type *t;",
            "\tconst char *name;",
            "\tint i, n;",
            "",
            "\tmemset(info, 0, sizeof(*info));",
            "",
            "\tbtf = bpf_get_btf_vmlinux();",
            "\tif (IS_ERR(btf))",
            "\t\treturn PTR_ERR(btf);",
            "\tif (!btf)",
            "\t\treturn -ENOENT;",
            "",
            "\tinfo->btf = btf;",
            "",
            "\tfor (i = 1, n = btf_nr_types(btf); i < n; i++) {",
            "\t\tt = btf_type_by_id(btf, i);",
            "\t\tif (!btf_type_is_enum(t))",
            "\t\t\tcontinue;",
            "",
            "\t\tname = btf_name_by_offset(btf, t->name_off);",
            "\t\tif (!name)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (strcmp(name, \"bpf_cmd\") == 0)",
            "\t\t\tinfo->cmd_t = t;",
            "\t\telse if (strcmp(name, \"bpf_map_type\") == 0)",
            "\t\t\tinfo->map_t = t;",
            "\t\telse if (strcmp(name, \"bpf_prog_type\") == 0)",
            "\t\t\tinfo->prog_t = t;",
            "\t\telse if (strcmp(name, \"bpf_attach_type\") == 0)",
            "\t\t\tinfo->attach_t = t;",
            "\t\telse",
            "\t\t\tcontinue;",
            "",
            "\t\tif (info->cmd_t && info->map_t && info->prog_t && info->attach_t)",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\treturn -ESRCH;",
            "}",
            "static bool find_btf_enum_const(const struct btf *btf, const struct btf_type *enum_t,",
            "\t\t\t\tconst char *prefix, const char *str, int *value)",
            "{",
            "\tconst struct btf_enum *e;",
            "\tconst char *name;",
            "\tint i, n, pfx_len = strlen(prefix);",
            "",
            "\t*value = 0;",
            "",
            "\tif (!btf || !enum_t)",
            "\t\treturn false;",
            "",
            "\tfor (i = 0, n = btf_vlen(enum_t); i < n; i++) {",
            "\t\te = &btf_enum(enum_t)[i];",
            "",
            "\t\tname = btf_name_by_offset(btf, e->name_off);",
            "\t\tif (!name || strncasecmp(name, prefix, pfx_len) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* match symbolic name case insensitive and ignoring prefix */",
            "\t\tif (strcasecmp(name + pfx_len, str) == 0) {",
            "\t\t\t*value = e->val;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "bpf_obj_pin_user, bpf_obj_get_user, find_bpffs_btf_enums, find_btf_enum_const",
          "description": "实现用户空间对象pin操作，对象获取逻辑及BTF枚举常量解析功能",
          "similarity": 0.48459190130233765
        }
      ]
    }
  ]
}