{
  "query": "仅加载当前需要的模块 系统调用接口",
  "timestamp": "2025-12-26 02:03:30",
  "retrieved_files": [
    {
      "source_file": "kernel/module/kmod.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:03:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\kmod.c`\n\n---\n\n# `module/kmod.c` 技术文档\n\n## 1. 文件概述\n\n`kmod.c` 是 Linux 内核中负责**内核模块自动加载机制**的核心实现文件。它提供了从内核空间调用用户态 `modprobe` 工具以动态加载缺失模块的能力。该机制允许内核在运行时按需加载驱动或功能模块（例如当设备被探测到但对应驱动未加载时），从而提升系统灵活性和资源利用率。\n\n该文件实现了 `__request_module()` 接口，作为内核其他子系统请求模块加载的统一入口，并通过 `call_usermodehelper` 机制安全地调用用户空间的 `/sbin/modprobe`（或由 `modprobe_path` 指定的路径）。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__request_module(bool wait, const char *fmt, ...)`**  \n  内核模块加载的主入口函数。支持格式化模块名，可选择同步（`wait=true`）或异步（`wait=false`）执行。返回值为 0 表示成功启动加载过程，负值为错误码，正值为 `modprobe` 的退出码。\n\n- **`call_modprobe(char *orig_module_name, int wait)`**  \n  封装对用户态 `modprobe` 的调用。构造命令行参数（`modprobe -q -- <module_name>`）和环境变量，通过 `call_usermodehelper_setup()` 和 `call_usermodehelper_exec()` 执行。\n\n- **`free_modprobe_argv(struct subprocess_info *info)`**  \n  释放 `call_modprobe` 中分配的参数内存，作为 `call_usermodehelper_setup()` 的清理回调。\n\n### 关键数据结构与变量\n\n- **`modprobe_path[KMOD_PATH_LEN]`**  \n  全局可配置的 `modprobe` 可执行文件路径，默认为 `CONFIG_MODPROBE_PATH`（通常为 `\"/sbin/modprobe\"`），可通过 `/proc/sys/kernel/modprobe` 修改。\n\n- **`kmod_concurrent_max`**  \n  信号量，限制同时进行的模块加载请求数量，上限为 `MAX_KMOD_CONCURRENT`（50），防止资源耗尽或递归依赖导致的死锁。\n\n- **`MAX_KMOD_ALL_BUSY_TIMEOUT`**  \n  超时阈值（5 秒），当所有并发槽位被占用超过此时间，判定为可能的模块依赖循环，拒绝新请求。\n\n## 3. 关键实现\n\n### 并发控制与死锁预防\n\n- 使用 `down_timeout(&kmod_concurrent_max, ...)` 限制并发加载线程数，避免系统资源（如内存、进程数）被大量 `modprobe` 进程耗尽。\n- 若所有 50 个并发槽位在 5 秒内未释放，内核判定为**模块依赖循环**（如 A 依赖 B，B 又依赖 A），主动拒绝请求并打印警告，防止无限递归。\n- 通过 `WARN_ON_ONCE(wait && current_is_async())` 禁止在异步上下文（如 workqueue、async 任务）中执行**同步**模块加载，避免与 `async_synchronize_full()` 产生死锁。\n\n### 安全与资源管理\n\n- 调用 `security_kernel_module_request()` 执行 LSM（Linux Security Module）安全检查，允许安全模块（如 SELinux、AppArmor）控制模块加载权限。\n- 使用 `UMH_KILLABLE` 标志使 `modprobe` 进程可被信号中断，提升系统响应性。\n- 通过 `kmod_dup_request_exists_wait()` 检测重复的模块加载请求，避免对同一模块发起多次 `modprobe` 调用，提升效率。\n\n### 用户态交互\n\n- 构造标准环境变量（`HOME=/`, `PATH=/sbin:/usr/sbin:/bin:/usr/bin`）确保 `modprobe` 在受限但可用的环境中执行。\n- 使用 `call_usermodehelper` 子系统创建内核线程执行用户态程序，该机制处理了凭证（cred）、文件描述符、挂载命名空间等上下文隔离。\n\n### 跟踪与调试\n\n- 集成 `trace_module_request` 跟踪点，可通过 ftrace 或 perf 监控模块加载请求。\n- 调用 `kmod_dup_request_announce()` 记录重复请求或失败事件，便于诊断。\n\n## 4. 依赖关系\n\n- **内核子系统依赖**：\n  - `call_usermodehelper`（`<linux/unistd.h>`, `<linux/binfmts.h>`）：用于执行用户态 helper 程序。\n  - LSM 框架（`<linux/security.h>`）：执行模块加载安全策略。\n  - 内存管理（`<linux/slab.h>`）：动态分配参数字符串。\n  - 同步原语（`<linux/semaphore.h>` via `DEFINE_SEMAPHORE`）：并发控制。\n  - 调试与跟踪（`<trace/events/module.h>`）：性能分析支持。\n- **配置依赖**：\n  - `CONFIG_MODULES`：模块支持必须启用。\n  - `CONFIG_MODPROBE_PATH`：定义默认 `modprobe` 路径。\n- **内部依赖**：\n  - `internal.h`：包含模块子系统内部声明（如 `kmod_dup_request_exists_wait`）。\n\n## 5. 使用场景\n\n- **设备驱动自动加载**：当内核探测到新硬件（如 USB 设备）但无对应驱动时，通过 `__request_module(\"usb:vXXXXpXXXX...\")` 触发驱动加载。\n- **文件系统按需挂载**：挂载未知文件系统类型时（如 `mount -t foo`），内核调用 `__request_module(\"fs-foo\")` 加载文件系统模块。\n- **网络协议模块加载**：使用未加载的网络协议（如 `AF_PHONET`）时自动加载对应模块。\n- **内核特性动态扩展**：如加密算法、压缩模块等在首次使用时按需加载。\n- **内核模块依赖解析**：当模块 A 依赖模块 B，而 B 未加载时，`insmod`/`modprobe` 内部会通过此机制加载 B。\n\n> **注意**：成功返回仅表示 `modprobe` 已启动，不保证模块最终加载成功。调用者必须验证所需功能是否可用。",
      "similarity": 0.6091122627258301,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/kmod.c",
          "start_line": 66,
          "end_line": 161,
          "content": [
            "static void free_modprobe_argv(struct subprocess_info *info)",
            "{",
            "\tkfree(info->argv[3]); /* check call_modprobe() */",
            "\tkfree(info->argv);",
            "}",
            "static int call_modprobe(char *orig_module_name, int wait)",
            "{",
            "\tstruct subprocess_info *info;",
            "\tstatic char *envp[] = {",
            "\t\t\"HOME=/\",",
            "\t\t\"TERM=linux\",",
            "\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",",
            "\t\tNULL",
            "\t};",
            "\tchar *module_name;",
            "\tint ret;",
            "",
            "\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);",
            "\tif (!argv)",
            "\t\tgoto out;",
            "",
            "\tmodule_name = kstrdup(orig_module_name, GFP_KERNEL);",
            "\tif (!module_name)",
            "\t\tgoto free_argv;",
            "",
            "\targv[0] = modprobe_path;",
            "\targv[1] = \"-q\";",
            "\targv[2] = \"--\";",
            "\targv[3] = module_name;\t/* check free_modprobe_argv() */",
            "\targv[4] = NULL;",
            "",
            "\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,",
            "\t\t\t\t\t NULL, free_modprobe_argv, NULL);",
            "\tif (!info)",
            "\t\tgoto free_module_name;",
            "",
            "\tret = call_usermodehelper_exec(info, wait | UMH_KILLABLE);",
            "\tkmod_dup_request_announce(orig_module_name, ret);",
            "\treturn ret;",
            "",
            "free_module_name:",
            "\tkfree(module_name);",
            "free_argv:",
            "\tkfree(argv);",
            "out:",
            "\tkmod_dup_request_announce(orig_module_name, -ENOMEM);",
            "\treturn -ENOMEM;",
            "}",
            "int __request_module(bool wait, const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "\tchar module_name[MODULE_NAME_LEN];",
            "\tint ret, dup_ret;",
            "",
            "\t/*",
            "\t * We don't allow synchronous module loading from async.  Module",
            "\t * init may invoke async_synchronize_full() which will end up",
            "\t * waiting for this task which already is waiting for the module",
            "\t * loading to complete, leading to a deadlock.",
            "\t */",
            "\tWARN_ON_ONCE(wait && current_is_async());",
            "",
            "\tif (!modprobe_path[0])",
            "\t\treturn -ENOENT;",
            "",
            "\tva_start(args, fmt);",
            "\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);",
            "\tva_end(args);",
            "\tif (ret >= MODULE_NAME_LEN)",
            "\t\treturn -ENAMETOOLONG;",
            "",
            "\tret = security_kernel_module_request(module_name);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = down_timeout(&kmod_concurrent_max, MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);",
            "\tif (ret) {",
            "\t\tpr_warn_ratelimited(\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\",",
            "\t\t\t\t    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ttrace_module_request(module_name, wait, _RET_IP_);",
            "",
            "\tif (kmod_dup_request_exists_wait(module_name, wait, &dup_ret)) {",
            "\t\tret = dup_ret;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);",
            "",
            "out:",
            "\tup(&kmod_concurrent_max);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "free_modprobe_argv, call_modprobe, __request_module",
          "description": "实现模块请求处理逻辑，通过调用modprobe执行模块加载，包含参数构造、子进程管理及并发控制机制",
          "similarity": 0.6543385982513428
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/kmod.c",
          "start_line": 1,
          "end_line": 65,
          "content": [
            "/*",
            " * kmod - the kernel module loader",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/cred.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/resource.h>",
            "#include <linux/notifier.h>",
            "#include <linux/suspend.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/async.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include <trace/events/module.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * Assuming:",
            " *",
            " * threads = div64_u64((u64) totalram_pages * (u64) PAGE_SIZE,",
            " *\t\t       (u64) THREAD_SIZE * 8UL);",
            " *",
            " * If you need less than 50 threads would mean we're dealing with systems",
            " * smaller than 3200 pages. This assumes you are capable of having ~13M memory,",
            " * and this would only be an upper limit, after which the OOM killer would take",
            " * effect. Systems like these are very unlikely if modules are enabled.",
            " */",
            "#define MAX_KMOD_CONCURRENT 50",
            "static DEFINE_SEMAPHORE(kmod_concurrent_max, MAX_KMOD_CONCURRENT);",
            "",
            "/*",
            " * This is a restriction on having *all* MAX_KMOD_CONCURRENT threads",
            " * running at the same time without returning. When this happens we",
            " * believe you've somehow ended up with a recursive module dependency",
            " * creating a loop.",
            " *",
            " * We have no option but to fail.",
            " *",
            " * Userspace should proactively try to detect and prevent these.",
            " */",
            "#define MAX_KMOD_ALL_BUSY_TIMEOUT 5",
            "",
            "/*",
            "\tmodprobe_path is set via /proc/sys.",
            "*/",
            "char modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;",
            ""
          ],
          "function_name": null,
          "description": "定义模块加载并发控制相关常量与全局变量，包含模块加载所需头文件并初始化modprobe路径",
          "similarity": 0.6054458618164062
        }
      ]
    },
    {
      "source_file": "kernel/static_call_inline.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:29:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `static_call_inline.c`\n\n---\n\n# static_call_inline.c 技术文档\n\n## 1. 文件概述\n\n`static_call_inline.c` 是 Linux 内核中实现 **静态调用（Static Call）** 机制的核心文件之一。静态调用是一种运行时可动态更新的函数调用优化技术，它在编译时将函数调用点内联为对跳板（trampoline）的直接跳转，而在运行时可通过 `__static_call_update()` 动态修改所有调用点，使其跳转到新的目标函数，从而避免传统函数指针调用的间接开销。该机制常用于性能敏感路径（如调度、RCU、tracepoint 等），同时支持模块热插拔和初始化阶段的特殊处理。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `static_call_force_reinit(void)`  \n  强制重新初始化静态调用机制，用于调试或特殊场景，必须在 `early_initcall()` 之前调用。\n\n- `__static_call_update(struct static_call_key *key, void *tramp, void *func)`  \n  核心更新函数：将指定 `key` 对应的所有静态调用点更新为调用 `func`，并更新跳板 `tramp`。支持内核和模块中的调用点。\n\n- `__static_call_init(struct module *mod, struct static_call_site *start, struct static_call_site *stop)`  \n  初始化静态调用站点，对站点按 `key` 排序，并建立 `key` 到站点的映射关系，同时执行首次 `arch_static_call_transform`。\n\n- `__static_call_text_reserved(...)`  \n  检查指定代码区间是否与活跃的静态调用站点冲突，用于内存热插拔或代码修改前的安全校验。\n\n### 主要数据结构\n\n- `struct static_call_site`  \n  描述一个静态调用点的位置（`addr`）和关联的 `key`（带标志位）。\n\n- `struct static_call_key`  \n  静态调用的“键”，用于将多个调用点分组。包含当前函数指针 `func` 和类型/模块信息。\n\n- `struct static_call_mod`  \n  用于模块场景下，将模块与该模块中属于某 `key` 的调用点列表关联。\n\n- 全局符号：\n  - `__start_static_call_sites[]` / `__stop_static_call_sites[]`：内核镜像中所有静态调用点的链接器生成数组。\n  - `__start_static_call_tramp_key[]` / `__stop_static_call_tramp_key[]`：跳板与 key 的映射。\n\n### 辅助函数与宏\n\n- `static_call_addr(site)`：计算调用点的实际地址（处理重定位）。\n- `static_call_key(site)`：从站点中提取 `static_call_key*`（忽略标志位）。\n- `static_call_is_init(site)` / `static_call_is_tail(site)`：检查站点是否位于 `__init` 段或是否为尾调用。\n- `static_call_sort_entries()`：对站点按 `key` 排序，便于批量处理。\n- `static_call_key_has_mods()` / `static_call_key_sites()`：判断 key 是否关联模块或直接站点。\n\n## 3. 关键实现\n\n### 地址重定位处理\n由于静态调用站点在编译时使用相对地址存储，`static_call_addr()` 和 `__static_call_key()` 通过 `(long)field + (long)&field` 的方式计算出运行时绝对地址，这是处理位置无关代码（PIC）和内核重定位的关键技巧。\n\n### 站点组织与模块支持\n- **内核（vmlinux）场景**：为节省内存和避免早期内存分配，将首个站点指针直接编码到 `key->type` 的低有效位中（通过 `| 1` 标记）。\n- **模块场景**：使用 `static_call_mod` 链表管理不同模块中属于同一 `key` 的站点，支持模块加载/卸载时的动态注册。\n\n### 初始化与更新流程\n1. **初始化**（`__static_call_init`）：\n   - 对站点按 `key` 排序。\n   - 标记位于 `__init` 段的站点（后续更新可跳过）。\n   - 建立 `key` 到站点的映射。\n   - 调用架构相关 `arch_static_call_transform` 执行首次转换（通常设为跳板）。\n\n2. **更新**（`__static_call_update`）：\n   - 更新 `key->func`。\n   - 更新跳板 `tramp` 指向新函数。\n   - 遍历所有关联站点（包括模块），调用 `arch_static_call_transform` 修改调用点指令（如 x86 的 `jmp` 目标）。\n   - 跳过 `__init` 段中已初始化的站点（因不会被执行）。\n\n### 安全与并发控制\n- 使用 `cpus_read_lock()` 防止 CPU 热插拔期间的并发问题。\n- 使用 `static_call_mutex` 保护 `key` 和站点数据结构的修改。\n- 通过 `kernel_text_address()` 验证调用点是否在可执行内核文本段，避免修改无效地址。\n\n## 4. 依赖关系\n\n- **架构依赖**：依赖 `asm/sections.h` 和 `arch_static_call_transform()`（由各架构实现，如 x86、ARM64）。\n- **内核子系统**：\n  - `linux/module.h`：模块加载/卸载时的静态调用站点管理。\n  - `linux/cpu.h` / `linux/smp.h`：CPU 热插拔和并发控制。\n  - `linux/sort.h`：站点排序。\n  - `linux/slab.h`：模块场景下的动态内存分配。\n- **链接器脚本**：依赖链接器生成的 `__start/stop_static_call_sites` 等符号，这些在 `vmlinux.lds` 中定义。\n\n## 5. 使用场景\n\n- **内核核心优化**：在调度器、RCU、中断处理等高频路径中替代函数指针，减少间接调用开销。\n- **动态追踪（ftrace）**：作为 tracepoint 或 kprobe 的底层机制，实现零开销探针。\n- **模块热插拔**：模块加载时注册其静态调用站点，卸载时自动清理，确保调用点始终有效。\n- **初始化优化**：`__init` 段的调用点在初始化完成后可被安全忽略，减少运行时开销。\n- **安全代码修改**：在 livepatch 或内核热补丁中，安全地替换函数实现而不影响运行中的调用。",
      "similarity": 0.6019256114959717,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 220,
          "end_line": 340,
          "content": [
            "static int __static_call_init(struct module *mod,",
            "\t\t\t      struct static_call_site *start,",
            "\t\t\t      struct static_call_site *stop)",
            "{",
            "\tstruct static_call_site *site;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod;",
            "",
            "\tif (start == stop)",
            "\t\treturn 0;",
            "",
            "\tstatic_call_sort_entries(start, stop);",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||",
            "\t\t    (!mod && init_section_contains(site_addr, 1)))",
            "\t\t\tstatic_call_set_init(site);",
            "",
            "\t\tkey = static_call_key(site);",
            "\t\tif (key != prev_key) {",
            "\t\t\tprev_key = key;",
            "",
            "\t\t\t/*",
            "\t\t\t * For vmlinux (!mod) avoid the allocation by storing",
            "\t\t\t * the sites pointer in the key itself. Also see",
            "\t\t\t * __static_call_update()'s @first.",
            "\t\t\t *",
            "\t\t\t * This allows architectures (eg. x86) to call",
            "\t\t\t * static_call_init() before memory allocation works.",
            "\t\t\t */",
            "\t\t\tif (!mod) {",
            "\t\t\t\tkey->sites = site;",
            "\t\t\t\tkey->type |= 1;",
            "\t\t\t\tgoto do_transform;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\tif (!site_mod)",
            "\t\t\t\treturn -ENOMEM;",
            "",
            "\t\t\t/*",
            "\t\t\t * When the key has a direct sites pointer, extract",
            "\t\t\t * that into an explicit struct static_call_mod, so we",
            "\t\t\t * can have a list of modules.",
            "\t\t\t */",
            "\t\t\tif (static_call_key_sites(key)) {",
            "\t\t\t\tsite_mod->mod = NULL;",
            "\t\t\t\tsite_mod->next = NULL;",
            "\t\t\t\tsite_mod->sites = static_call_key_sites(key);",
            "",
            "\t\t\t\tkey->mods = site_mod;",
            "",
            "\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\t\tif (!site_mod)",
            "\t\t\t\t\treturn -ENOMEM;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod->mod = mod;",
            "\t\t\tsite_mod->sites = site;",
            "\t\t\tsite_mod->next = static_call_key_next(key);",
            "\t\t\tkey->mods = site_mod;",
            "\t\t}",
            "",
            "do_transform:",
            "\t\tarch_static_call_transform(site_addr, NULL, key->func,",
            "\t\t\t\tstatic_call_is_tail(site));",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int addr_conflict(struct static_call_site *site, void *start, void *end)",
            "{",
            "\tunsigned long addr = (unsigned long)static_call_addr(site);",
            "",
            "\tif (addr <= (unsigned long)end &&",
            "\t    addr + CALL_INSN_SIZE > (unsigned long)start)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_text_reserved(struct static_call_site *iter_start,",
            "\t\t\t\t       struct static_call_site *iter_stop,",
            "\t\t\t\t       void *start, void *end, bool init)",
            "{",
            "\tstruct static_call_site *iter = iter_start;",
            "",
            "\twhile (iter < iter_stop) {",
            "\t\tif (init || !static_call_is_init(iter)) {",
            "\t\t\tif (addr_conflict(iter, start, end))",
            "\t\t\t\treturn 1;",
            "\t\t}",
            "\t\titer++;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\tstruct module *mod;",
            "\tint ret;",
            "",
            "\tpreempt_disable();",
            "\tmod = __module_text_address((unsigned long)start);",
            "\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);",
            "\tif (!try_module_get(mod))",
            "\t\tmod = NULL;",
            "\tpreempt_enable();",
            "",
            "\tif (!mod)",
            "\t\treturn 0;",
            "",
            "\tret = __static_call_text_reserved(mod->static_call_sites,",
            "\t\t\tmod->static_call_sites + mod->num_static_call_sites,",
            "\t\t\tstart, end, mod->state == MODULE_STATE_COMING);",
            "",
            "\tmodule_put(mod);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__static_call_init, addr_conflict, __static_call_text_reserved, __static_call_mod_text_reserved",
          "description": "执行静态调用初始化流程，分配模块关联结构体并进行地址转换，实现文本区域预留检查以避免内存覆盖。",
          "similarity": 0.660751223564148
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 453,
          "end_line": 552,
          "content": [
            "static int static_call_module_notify(struct notifier_block *nb,",
            "\t\t\t\t     unsigned long val, void *data)",
            "{",
            "\tstruct module *mod = data;",
            "\tint ret = 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tswitch (val) {",
            "\tcase MODULE_STATE_COMING:",
            "\t\tret = static_call_add_module(mod);",
            "\t\tif (ret) {",
            "\t\t\tpr_warn(\"Failed to allocate memory for static calls\\n\");",
            "\t\t\tstatic_call_del_module(mod);",
            "\t\t}",
            "\t\tbreak;",
            "\tcase MODULE_STATE_GOING:",
            "\t\tstatic_call_del_module(mod);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\treturn notifier_from_errno(ret);",
            "}",
            "int klp_static_call_register(struct module *mod)",
            "{",
            "\tint ret;",
            "",
            "\tret = static_call_module_notify(&static_call_module_nb, MODULE_STATE_COMING, mod);",
            "\treturn notifier_to_errno(ret);",
            "}",
            "static inline int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\treturn 0;",
            "}",
            "int static_call_text_reserved(void *start, void *end)",
            "{",
            "\tbool init = system_state < SYSTEM_RUNNING;",
            "\tint ret = __static_call_text_reserved(__start_static_call_sites,",
            "\t\t\t__stop_static_call_sites, start, end, init);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn __static_call_mod_text_reserved(start, end);",
            "}",
            "int __init static_call_init(void)",
            "{",
            "\tint ret;",
            "",
            "\t/* See static_call_force_reinit(). */",
            "\tif (static_call_initialized == 1)",
            "\t\treturn 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "\tret = __static_call_init(NULL, __start_static_call_sites,",
            "\t\t\t\t __stop_static_call_sites);",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate memory for static_call!\\n\");",
            "\t\tBUG();",
            "\t}",
            "",
            "#ifdef CONFIG_MODULES",
            "\tif (!static_call_initialized)",
            "\t\tregister_module_notifier(&static_call_module_nb);",
            "#endif",
            "",
            "\tstatic_call_initialized = 1;",
            "\treturn 0;",
            "}",
            "static int func_a(int x)",
            "{",
            "\treturn x+1;",
            "}",
            "static int func_b(int x)",
            "{",
            "\treturn x+2;",
            "}",
            "static int __init test_static_call_init(void)",
            "{",
            "      int i;",
            "",
            "      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {",
            "\t      struct static_call_data *scd = &static_call_data[i];",
            "",
            "              if (scd->func)",
            "                      static_call_update(sc_selftest, scd->func);",
            "",
            "              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);",
            "      }",
            "",
            "      return 0;",
            "}"
          ],
          "function_name": "static_call_module_notify, klp_static_call_register, __static_call_mod_text_reserved, static_call_text_reserved, static_call_init, func_a, func_b, test_static_call_init",
          "description": "实现模块状态变更通知机制，完成静态调用系统的初始化注册，包含测试函数用于验证静态调用逻辑的正确性。",
          "similarity": 0.6517117023468018
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 347,
          "end_line": 449,
          "content": [
            "static unsigned long tramp_key_lookup(unsigned long addr)",
            "{",
            "\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *tramp_key;",
            "",
            "\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {",
            "\t\tunsigned long tramp;",
            "",
            "\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;",
            "\t\tif (tramp == addr)",
            "\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int static_call_add_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = start + mod->num_static_call_sites;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn 0;",
            "#endif",
            "",
            "\tfor (site = start; site != stop; site++) {",
            "\t\tunsigned long s_key = __static_call_key(site);",
            "\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;",
            "\t\tunsigned long key;",
            "",
            "\t\t/*",
            "\t\t * Is the key is exported, 'addr' points to the key, which",
            "\t\t * means modules are allowed to call static_call_update() on",
            "\t\t * it.",
            "\t\t *",
            "\t\t * Otherwise, the key isn't exported, and 'addr' points to the",
            "\t\t * trampoline so we need to lookup the key.",
            "\t\t *",
            "\t\t * We go through this dance to prevent crazy modules from",
            "\t\t * abusing sensitive static calls.",
            "\t\t */",
            "\t\tif (!kernel_text_address(addr))",
            "\t\t\tcontinue;",
            "",
            "\t\tkey = tramp_key_lookup(addr);",
            "\t\tif (!key) {",
            "\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",",
            "\t\t\t\tstatic_call_addr(site));",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;",
            "\t\tsite->key = key - (long)&site->key;",
            "\t}",
            "",
            "\treturn __static_call_init(mod, start, stop);",
            "}",
            "static void static_call_del_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = mod->static_call_sites +",
            "\t\t\t\t\tmod->num_static_call_sites;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod, **prev;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn;",
            "#endif",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tkey = static_call_key(site);",
            "",
            "\t\t/*",
            "\t\t * If the key was not updated due to a memory allocation",
            "\t\t * failure in __static_call_init() then treating key::sites",
            "\t\t * as key::mods in the code below would cause random memory",
            "\t\t * access and #GP. In that case all subsequent sites have",
            "\t\t * not been touched either, so stop iterating.",
            "\t\t */",
            "\t\tif (!static_call_key_has_mods(key))",
            "\t\t\tbreak;",
            "",
            "\t\tif (key == prev_key)",
            "\t\t\tcontinue;",
            "",
            "\t\tprev_key = key;",
            "",
            "\t\tfor (prev = &key->mods, site_mod = key->mods;",
            "\t\t     site_mod && site_mod->mod != mod;",
            "\t\t     prev = &site_mod->next, site_mod = site_mod->next)",
            "\t\t\t;",
            "",
            "\t\tif (!site_mod)",
            "\t\t\tcontinue;",
            "",
            "\t\t*prev = site_mod->next;",
            "\t\tkfree(site_mod);",
            "\t}",
            "}"
          ],
          "function_name": "tramp_key_lookup, static_call_add_module, static_call_del_module",
          "description": "处理模块动态加载/卸载时的静态调用更新，通过键查找机制确保跨模块调用正确性，并维护静态调用站点的模块绑定关系。",
          "similarity": 0.6462756395339966
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 23,
          "end_line": 176,
          "content": [
            "void static_call_force_reinit(void)",
            "{",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\treturn;",
            "",
            "\tstatic_call_initialized++;",
            "}",
            "static void static_call_lock(void)",
            "{",
            "\tmutex_lock(&static_call_mutex);",
            "}",
            "static void static_call_unlock(void)",
            "{",
            "\tmutex_unlock(&static_call_mutex);",
            "}",
            "static inline unsigned long __static_call_key(const struct static_call_site *site)",
            "{",
            "\treturn (long)site->key + (long)&site->key;",
            "}",
            "static inline bool static_call_is_init(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;",
            "}",
            "static inline bool static_call_is_tail(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;",
            "}",
            "static inline void static_call_set_init(struct static_call_site *site)",
            "{",
            "\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -",
            "\t\t    (long)&site->key;",
            "}",
            "static int static_call_site_cmp(const void *_a, const void *_b)",
            "{",
            "\tconst struct static_call_site *a = _a;",
            "\tconst struct static_call_site *b = _b;",
            "\tconst struct static_call_key *key_a = static_call_key(a);",
            "\tconst struct static_call_key *key_b = static_call_key(b);",
            "",
            "\tif (key_a < key_b)",
            "\t\treturn -1;",
            "",
            "\tif (key_a > key_b)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static void static_call_site_swap(void *_a, void *_b, int size)",
            "{",
            "\tlong delta = (unsigned long)_a - (unsigned long)_b;",
            "\tstruct static_call_site *a = _a;",
            "\tstruct static_call_site *b = _b;",
            "\tstruct static_call_site tmp = *a;",
            "",
            "\ta->addr = b->addr  - delta;",
            "\ta->key  = b->key   - delta;",
            "",
            "\tb->addr = tmp.addr + delta;",
            "\tb->key  = tmp.key  + delta;",
            "}",
            "static inline void static_call_sort_entries(struct static_call_site *start,",
            "\t\t\t\t\t    struct static_call_site *stop)",
            "{",
            "\tsort(start, stop - start, sizeof(struct static_call_site),",
            "\t     static_call_site_cmp, static_call_site_swap);",
            "}",
            "static inline bool static_call_key_has_mods(struct static_call_key *key)",
            "{",
            "\treturn !(key->type & 1);",
            "}",
            "void __static_call_update(struct static_call_key *key, void *tramp, void *func)",
            "{",
            "\tstruct static_call_site *site, *stop;",
            "\tstruct static_call_mod *site_mod, first;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tif (key->func == func)",
            "\t\tgoto done;",
            "",
            "\tkey->func = func;",
            "",
            "\tarch_static_call_transform(NULL, tramp, func, false);",
            "",
            "\t/*",
            "\t * If uninitialized, we'll not update the callsites, but they still",
            "\t * point to the trampoline and we just patched that.",
            "\t */",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\tgoto done;",
            "",
            "\tfirst = (struct static_call_mod){",
            "\t\t.next = static_call_key_next(key),",
            "\t\t.mod = NULL,",
            "\t\t.sites = static_call_key_sites(key),",
            "\t};",
            "",
            "\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {",
            "\t\tbool init = system_state < SYSTEM_RUNNING;",
            "\t\tstruct module *mod = site_mod->mod;",
            "",
            "\t\tif (!site_mod->sites) {",
            "\t\t\t/*",
            "\t\t\t * This can happen if the static call key is defined in",
            "\t\t\t * a module which doesn't use it.",
            "\t\t\t *",
            "\t\t\t * It also happens in the has_mods case, where the",
            "\t\t\t * 'first' entry has no sites associated with it.",
            "\t\t\t */",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tstop = __stop_static_call_sites;",
            "",
            "\t\tif (mod) {",
            "#ifdef CONFIG_MODULES",
            "\t\t\tstop = mod->static_call_sites +",
            "\t\t\t       mod->num_static_call_sites;",
            "\t\t\tinit = mod->state == MODULE_STATE_COMING;",
            "#endif",
            "\t\t}",
            "",
            "\t\tfor (site = site_mod->sites;",
            "\t\t     site < stop && static_call_key(site) == key; site++) {",
            "\t\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\t\tif (!init && static_call_is_init(site))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * This skips patching built-in __exit, which",
            "\t\t\t\t * is part of init_section_contains() but is",
            "\t\t\t\t * not part of kernel_text_address().",
            "\t\t\t\t *",
            "\t\t\t\t * Skipping built-in __exit is fine since it",
            "\t\t\t\t * will never be executed.",
            "\t\t\t\t */",
            "\t\t\t\tWARN_ONCE(!static_call_is_init(site),",
            "\t\t\t\t\t  \"can't patch static call site at %pS\",",
            "\t\t\t\t\t  site_addr);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tarch_static_call_transform(site_addr, NULL, func,",
            "\t\t\t\t\t\t   static_call_is_tail(site));",
            "\t\t}",
            "\t}",
            "",
            "done:",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "static_call_force_reinit, static_call_lock, static_call_unlock, __static_call_key, static_call_is_init, static_call_is_tail, static_call_set_init, static_call_site_cmp, static_call_site_swap, static_call_sort_entries, static_call_key_has_mods, __static_call_update",
          "description": "实现静态调用的互斥锁控制、键值计算、站点排序及更新逻辑，包含地址冲突检测和模块间调用关系维护功能。",
          "similarity": 0.6355518698692322
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/init.h>",
            "#include <linux/static_call.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/cpu.h>",
            "#include <linux/processor.h>",
            "#include <asm/sections.h>",
            "",
            "extern struct static_call_site __start_static_call_sites[],",
            "\t\t\t       __stop_static_call_sites[];",
            "extern struct static_call_tramp_key __start_static_call_tramp_key[],",
            "\t\t\t\t    __stop_static_call_tramp_key[];",
            "",
            "int static_call_initialized;",
            "",
            "/*",
            " * Must be called before early_initcall() to be effective.",
            " */"
          ],
          "function_name": null,
          "description": "声明静态调用相关的全局变量和外部符号，定义静态调用初始化标志位，为后续静态调用站点管理和地址转换提供基础结构。",
          "similarity": 0.566657304763794
        }
      ]
    },
    {
      "source_file": "kernel/module/kdb.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:02:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\kdb.c`\n\n---\n\n# module/kdb.c 技术文档\n\n## 文件概述\n\n`module/kdb.c` 是 Linux 内核调试器（KDB）中用于支持内核模块信息查询的实现文件。该文件提供了一个名为 `kdb_lsmod` 的 KDB 命令，用于在内核调试状态下列出当前已加载的内核模块及其详细信息，功能类似于用户空间的 `lsmod` 命令。\n\n## 核心功能\n\n- **函数 `kdb_lsmod`**  \n  实现 KDB 调试器中的 `lsmod` 命令，用于打印当前系统中所有已加载内核模块的状态、内存布局、引用计数及依赖关系。\n\n- **数据结构依赖**  \n  - `struct module`：内核模块的核心结构体，包含模块名称、状态、内存区域、引用计数等信息。\n  - `struct module_use`：用于描述模块间的依赖关系（在 `CONFIG_MODULE_UNLOAD` 启用时使用）。\n\n## 关键实现\n\n- **命令参数校验**  \n  `kdb_lsmod` 要求命令不带任何参数（`argc == 0`），否则返回 `KDB_ARGCOUNT` 错误。\n\n- **模块状态过滤**  \n  跳过状态为 `MODULE_STATE_UNFORMED` 的模块（尚未完全初始化的模块）。\n\n- **内存区域信息展示**  \n  打印模块四个主要内存段的大小与基地址：\n  - `MOD_TEXT`：可执行代码段\n  - `MOD_RODATA`：只读数据段\n  - `MOD_RO_AFTER_INIT`：初始化后变为只读的数据段\n  - `MOD_DATA`：可写数据段\n\n- **模块状态标识**  \n  根据模块的 `state` 字段显示其当前状态：\n  - `(Loading)`：`MODULE_STATE_COMING`\n  - `(Unloading)`：`MODULE_STATE_GOING`\n  - `(Live)`：正常运行状态\n\n- **模块引用与依赖关系（条件编译）**  \n  若启用了 `CONFIG_MODULE_UNLOAD` 配置项：\n  - 显示模块的引用计数（`module_refcount(mod)`）\n  - 遍历 `mod->source_list`，列出所有依赖当前模块的其他模块名称\n\n- **格式化输出**  \n  使用 `kdb_printf` 进行对齐输出，确保信息清晰可读，包括模块名、各段大小/地址、状态及依赖列表。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：提供 `struct module` 等模块核心定义\n  - `<linux/kdb.h>`：提供 KDB 调试器接口（如 `kdb_printf`、`KDB_ARGCOUNT`）\n  - `\"internal.h\"`：模块子系统内部头文件，可能包含未公开的辅助函数或结构\n\n- **配置依赖**：\n  - `CONFIG_KGDB_KDB`：必须启用 KDB 调试器支持\n  - `CONFIG_MODULE_UNLOAD`：控制是否显示模块引用计数和依赖关系\n\n- **内核子系统依赖**：\n  - 内核模块加载/卸载子系统（`kernel/module.c`）\n  - KDB 调试框架\n\n## 使用场景\n\n- **内核调试阶段**：当系统进入 KDB 调试模式（如通过 SysRq 触发或硬件断点）时，开发者可执行 `lsmod` 命令查看当前加载的模块列表。\n- **模块状态诊断**：用于检查模块是否处于加载/卸载中间状态，辅助定位模块卸载卡死或重复加载等问题。\n- **内存布局分析**：通过显示各内存段的基地址和大小，帮助分析模块代码/数据布局，辅助调试内存越界或符号解析问题。\n- **依赖关系排查**：在 `CONFIG_MODULE_UNLOAD` 启用时，可查看模块间的依赖链，判断为何某模块无法卸载（被其他模块引用）。",
      "similarity": 0.5900761485099792,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/kdb.c",
          "start_line": 17,
          "end_line": 63,
          "content": [
            "int kdb_lsmod(int argc, const char **argv)",
            "{",
            "\tstruct module *mod;",
            "",
            "\tif (argc != 0)",
            "\t\treturn KDB_ARGCOUNT;",
            "",
            "\tkdb_printf(\"Module                  Size  modstruct     Used by\\n\");",
            "\tlist_for_each_entry(mod, &modules, list) {",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "",
            "\t\tkdb_printf(\"%-20s%8u\", mod->name, mod->mem[MOD_TEXT].size);",
            "\t\tkdb_printf(\"/%8u\", mod->mem[MOD_RODATA].size);",
            "\t\tkdb_printf(\"/%8u\", mod->mem[MOD_RO_AFTER_INIT].size);",
            "\t\tkdb_printf(\"/%8u\", mod->mem[MOD_DATA].size);",
            "",
            "\t\tkdb_printf(\"  0x%px \", (void *)mod);",
            "#ifdef CONFIG_MODULE_UNLOAD",
            "\t\tkdb_printf(\"%4d \", module_refcount(mod));",
            "#endif",
            "\t\tif (mod->state == MODULE_STATE_GOING)",
            "\t\t\tkdb_printf(\" (Unloading)\");",
            "\t\telse if (mod->state == MODULE_STATE_COMING)",
            "\t\t\tkdb_printf(\" (Loading)\");",
            "\t\telse",
            "\t\t\tkdb_printf(\" (Live)\");",
            "\t\tkdb_printf(\" 0x%px\", mod->mem[MOD_TEXT].base);",
            "\t\tkdb_printf(\"/0x%px\", mod->mem[MOD_RODATA].base);",
            "\t\tkdb_printf(\"/0x%px\", mod->mem[MOD_RO_AFTER_INIT].base);",
            "\t\tkdb_printf(\"/0x%px\", mod->mem[MOD_DATA].base);",
            "",
            "#ifdef CONFIG_MODULE_UNLOAD",
            "\t\t{",
            "\t\t\tstruct module_use *use;",
            "",
            "\t\t\tkdb_printf(\" [ \");",
            "\t\t\tlist_for_each_entry(use, &mod->source_list,",
            "\t\t\t\t\t    source_list)",
            "\t\t\t\tkdb_printf(\"%s \", use->target->name);",
            "\t\t\tkdb_printf(\"]\\n\");",
            "\t\t}",
            "#endif",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "kdb_lsmod",
          "description": "该代码块实现了kdb_lsmod函数，遍历系统中所有模块链表，过滤掉未形成模块的状态，然后按照特定格式输出每个模块的名称、内存占用情况、引用计数及状态信息，支持模块卸载时显示依赖关系。",
          "similarity": 0.5657257437705994
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/kdb.c",
          "start_line": 1,
          "end_line": 16,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module kdb support",
            " *",
            " * Copyright (C) 2010 Jason Wessel",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/kdb.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * kdb_lsmod - This function implements the 'lsmod' command.  Lists",
            " *\tcurrently loaded kernel modules.",
            " *\tMostly taken from userland lsmod.",
            " */"
          ],
          "function_name": null,
          "description": "该代码块定义了kdb_lsmod函数的原型，用于实现内核调试器(kdb)中的'lsmod'命令，用于列出当前加载的内核模块。函数参数与返回值类型表明其接受命令行参数并返回整型状态码。",
          "similarity": 0.5378592014312744
        }
      ]
    }
  ]
}