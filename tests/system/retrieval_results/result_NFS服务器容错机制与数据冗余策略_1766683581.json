{
  "query": "NFS服务器容错机制与数据冗余策略",
  "timestamp": "2025-12-26 01:26:21",
  "retrieved_files": [
    {
      "source_file": "mm/mempolicy.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:44:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mempolicy.c`\n\n---\n\n# mempolicy.c 技术文档\n\n## 1. 文件概述\n\n`mempolicy.c` 实现了 Linux 内核中的 NUMA（Non-Uniform Memory Access）内存策略机制，允许用户通过系统调用为进程或虚拟内存区域（VMA）指定内存分配偏好。该机制支持多种内存分配策略，包括本地优先、绑定节点、轮询交错和基于权重的交错分配等，以优化多节点 NUMA 系统上的内存访问性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct mempolicy`：表示内存策略的核心结构，包含策略模式（如 MPOL_INTERLEAVE、MPOL_BIND、MPOL_PREFERRED 等）、节点掩码（nodemask）和引用计数。\n- `struct weighted_interleave_state`：用于实现加权交错分配策略，包含每个节点的权重表（iw_table）和自动模式标志。\n- `default_policy`：全局默认内存策略，初始为 MPOL_LOCAL（本地节点优先）。\n- `preferred_node_policy[MAX_NUMNODES]`：为每个节点预定义的首选策略数组。\n\n### 主要函数与接口\n- `get_il_weight(int node)`：获取指定节点在加权交错策略中的权重。\n- `reduce_interleave_weights(unsigned int *bw, u8 *new_iw)`：将带宽值转换为归一化的交错权重。\n- `mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)`：根据节点性能坐标（读/写带宽）动态更新加权交错策略。\n- 多个辅助函数用于策略创建、复制、合并、验证及与 VMA 和进程上下文的集成。\n\n### 全局变量\n- `policy_cache` / `sn_cache`：用于高效分配 mempolicy 和相关子结构的 slab 缓存。\n- `policy_zone`：标识受策略控制的最高内存区域类型（zone_type），低区域（如 GFP_DMA）不应用策略。\n- `wi_state`：RCU 保护的加权交错状态指针。\n- `node_bw_table`：存储各节点带宽信息，用于动态权重计算。\n- `weightiness`：权重归一化常量（值为 32），平衡权重精度与分配公平性。\n\n## 3. 关键实现\n\n### 策略优先级与作用域\n- **VMA 策略优先于进程策略**：页错误处理时，若 VMA 有策略则使用 VMA 策略，否则回退到当前进程的策略。\n- **中断上下文忽略策略**：所有中断相关的内存分配始终尝试在本地 CPU 节点分配。\n- **策略不跨 swap 保留**：进程策略在页面换出/换入时不被保留。\n\n### 加权交错分配（Weighted Interleave）\n- 基于各 NUMA 节点的读/写带宽动态计算分配权重。\n- 使用 `weightiness=32` 对带宽进行缩放，并通过 GCD（最大公约数）约简权重以减少分配周期长度。\n- 权重状态通过 RCU 机制安全更新，读路径无锁，写路径由 `wi_state_lock` 互斥锁保护。\n\n### 策略类型详解\n- **interleave**：按偏移量（VMA）或进程计数器（进程）在节点集上轮询分配。\n- **weighted interleave**：按节点权重比例分配（如权重 [2,1] 表示节点0:节点1 = 2:1）。\n- **bind**：严格限制在指定节点集分配，无回退（当前实现按节点顺序分配，非最优）。\n- **preferred / preferred many**：优先在指定单个/多个节点分配，失败后回退到默认策略。\n- **default / local**：优先本地节点分配，VMA 中则继承进程策略。\n\n### 内存区域限制\n- 仅对 **最高 zone 层级**（如 NORMAL 或 MOVABLE）应用策略，GFP_DMA、HIGHMEM 等低层级分配忽略策略。\n\n### 特殊共享内存处理\n- **shmem/tmpfs**：策略在所有映射进程间共享，即使无活跃映射也持久保存。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `<linux/mm.h>`、`<linux/vm_area_struct.h>`、`<linux/page-flags.h>` 等进行页分配、VMA 操作和页表遍历。\n- **NUMA 感知调度**：与 `<linux/sched/numa_balancing.h>` 协同，支持自动 NUMA 迁移。\n- **CPUSET 子系统**：通过 `<linux/cpuset.h>` 集成节点可用性约束。\n- **Slab 分配器**：使用 kmem_cache 管理 mempolicy 对象生命周期。\n- **RCU 机制**：用于加权交错状态的无锁读取。\n- **系统调用接口**：通过 `sys_mbind()`、`sys_set_mempolicy()` 等提供用户空间配置入口。\n- **安全模块**：调用 LSM hooks（`security_task_movememory()`）进行权限检查。\n\n## 5. 使用场景\n\n- **高性能计算（HPC）应用**：通过 `mbind()` 将关键数据结构绑定到特定 NUMA 节点，减少远程内存访问延迟。\n- **数据库系统**：使用交错策略均衡多节点内存带宽，提升吞吐量。\n- **虚拟化环境**：VMM 可为不同虚拟机设置独立内存策略，隔离资源并优化性能。\n- **自动 NUMA 优化**：内核 NUMA balancing 机制结合默认策略，自动迁移热点页面至访问 CPU 所在节点。\n- **实时系统**：通过 `MPOL_BIND` 严格限制内存位置，确保确定性访问延迟。\n- **大页（HugeTLB）分配**：策略同样适用于透明大页和显式 HugeTLB 页面分配。",
      "similarity": 0.5999064445495605,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/mempolicy.c",
          "start_line": 168,
          "end_line": 268,
          "content": [
            "static u8 get_il_weight(int node)",
            "{",
            "\tstruct weighted_interleave_state *state;",
            "\tu8 weight = 1;",
            "",
            "\trcu_read_lock();",
            "\tstate = rcu_dereference(wi_state);",
            "\tif (state)",
            "\t\tweight = state->iw_table[node];",
            "\trcu_read_unlock();",
            "\treturn weight;",
            "}",
            "static void reduce_interleave_weights(unsigned int *bw, u8 *new_iw)",
            "{",
            "\tu64 sum_bw = 0;",
            "\tunsigned int cast_sum_bw, scaling_factor = 1, iw_gcd = 0;",
            "\tint nid;",
            "",
            "\tfor_each_node_state(nid, N_MEMORY)",
            "\t\tsum_bw += bw[nid];",
            "",
            "\t/* Scale bandwidths to whole numbers in the range [1, weightiness] */",
            "\tfor_each_node_state(nid, N_MEMORY) {",
            "\t\t/*",
            "\t\t * Try not to perform 64-bit division.",
            "\t\t * If sum_bw < scaling_factor, then sum_bw < U32_MAX.",
            "\t\t * If sum_bw > scaling_factor, then round the weight up to 1.",
            "\t\t */",
            "\t\tscaling_factor = weightiness * bw[nid];",
            "\t\tif (bw[nid] && sum_bw < scaling_factor) {",
            "\t\t\tcast_sum_bw = (unsigned int)sum_bw;",
            "\t\t\tnew_iw[nid] = scaling_factor / cast_sum_bw;",
            "\t\t} else {",
            "\t\t\tnew_iw[nid] = 1;",
            "\t\t}",
            "\t\tif (!iw_gcd)",
            "\t\t\tiw_gcd = new_iw[nid];",
            "\t\tiw_gcd = gcd(iw_gcd, new_iw[nid]);",
            "\t}",
            "",
            "\t/* 1:2 is strictly better than 16:32. Reduce by the weights' GCD. */",
            "\tfor_each_node_state(nid, N_MEMORY)",
            "\t\tnew_iw[nid] /= iw_gcd;",
            "}",
            "int mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)",
            "{",
            "\tstruct weighted_interleave_state *new_wi_state, *old_wi_state = NULL;",
            "\tunsigned int *old_bw, *new_bw;",
            "\tunsigned int bw_val;",
            "\tint i;",
            "",
            "\tbw_val = min(coords->read_bandwidth, coords->write_bandwidth);",
            "\tnew_bw = kcalloc(nr_node_ids, sizeof(unsigned int), GFP_KERNEL);",
            "\tif (!new_bw)",
            "\t\treturn -ENOMEM;",
            "",
            "\tnew_wi_state = kmalloc(struct_size(new_wi_state, iw_table, nr_node_ids),",
            "\t\t\t       GFP_KERNEL);",
            "\tif (!new_wi_state) {",
            "\t\tkfree(new_bw);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tnew_wi_state->mode_auto = true;",
            "\tfor (i = 0; i < nr_node_ids; i++)",
            "\t\tnew_wi_state->iw_table[i] = 1;",
            "",
            "\t/*",
            "\t * Update bandwidth info, even in manual mode. That way, when switching",
            "\t * to auto mode in the future, iw_table can be overwritten using",
            "\t * accurate bw data.",
            "\t */",
            "\tmutex_lock(&wi_state_lock);",
            "",
            "\told_bw = node_bw_table;",
            "\tif (old_bw)",
            "\t\tmemcpy(new_bw, old_bw, nr_node_ids * sizeof(*old_bw));",
            "\tnew_bw[node] = bw_val;",
            "\tnode_bw_table = new_bw;",
            "",
            "\told_wi_state = rcu_dereference_protected(wi_state,",
            "\t\t\t\t\tlockdep_is_held(&wi_state_lock));",
            "\tif (old_wi_state && !old_wi_state->mode_auto) {",
            "\t\t/* Manual mode; skip reducing weights and updating wi_state */",
            "\t\tmutex_unlock(&wi_state_lock);",
            "\t\tkfree(new_wi_state);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* NULL wi_state assumes auto=true; reduce weights and update wi_state*/",
            "\treduce_interleave_weights(new_bw, new_wi_state->iw_table);",
            "\trcu_assign_pointer(wi_state, new_wi_state);",
            "",
            "\tmutex_unlock(&wi_state_lock);",
            "\tif (old_wi_state) {",
            "\t\tsynchronize_rcu();",
            "\t\tkfree(old_wi_state);",
            "\t}",
            "out:",
            "\tkfree(old_bw);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_il_weight, reduce_interleave_weights, mempolicy_set_node_perf",
          "description": "实现带权交错策略的权重计算与调整逻辑，通过获取节点带宽数据动态修改权重比例，支持根据性能参数更新节点间内存分配优先级。",
          "similarity": 0.6038230657577515
        },
        {
          "chunk_id": 11,
          "file_path": "mm/mempolicy.c",
          "start_line": 1855,
          "end_line": 1971,
          "content": [
            "static int kernel_get_mempolicy(int __user *policy,",
            "\t\t\t\tunsigned long __user *nmask,",
            "\t\t\t\tunsigned long maxnode,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long flags)",
            "{",
            "\tint err;",
            "\tint pval;",
            "\tnodemask_t nodes;",
            "",
            "\tif (nmask != NULL && maxnode < nr_node_ids)",
            "\t\treturn -EINVAL;",
            "",
            "\taddr = untagged_addr(addr);",
            "",
            "\terr = do_get_mempolicy(&pval, &nodes, addr, flags);",
            "",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (policy && put_user(pval, policy))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (nmask)",
            "\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);",
            "",
            "\treturn err;",
            "}",
            "bool vma_migratable(struct vm_area_struct *vma)",
            "{",
            "\tif (vma->vm_flags & (VM_IO | VM_PFNMAP))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * DAX device mappings require predictable access latency, so avoid",
            "\t * incurring periodic faults.",
            "\t */",
            "\tif (vma_is_dax(vma))",
            "\t\treturn false;",
            "",
            "\tif (is_vm_hugetlb_page(vma) &&",
            "\t\t!hugepage_migration_supported(hstate_vma(vma)))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Migration allocates pages in the highest zone. If we cannot",
            "\t * do so then migration (at least from node to node) is not",
            "\t * possible.",
            "\t */",
            "\tif (vma->vm_file &&",
            "\t\tgfp_zone(mapping_gfp_mask(vma->vm_file->f_mapping))",
            "\t\t\t< policy_zone)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "bool vma_policy_mof(struct vm_area_struct *vma)",
            "{",
            "\tstruct mempolicy *pol;",
            "",
            "\tif (vma->vm_ops && vma->vm_ops->get_policy) {",
            "\t\tbool ret = false;",
            "\t\tpgoff_t ilx;\t\t/* ignored here */",
            "",
            "\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start, &ilx);",
            "\t\tif (pol && (pol->flags & MPOL_F_MOF))",
            "\t\t\tret = true;",
            "\t\tmpol_cond_put(pol);",
            "",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tpol = vma->vm_policy;",
            "\tif (!pol)",
            "\t\tpol = get_task_policy(current);",
            "",
            "\treturn pol->flags & MPOL_F_MOF;",
            "}",
            "bool apply_policy_zone(struct mempolicy *policy, enum zone_type zone)",
            "{",
            "\tenum zone_type dynamic_policy_zone = policy_zone;",
            "",
            "\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);",
            "",
            "\t/*",
            "\t * if policy->nodes has movable memory only,",
            "\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.",
            "\t *",
            "\t * policy->nodes is intersect with node_states[N_MEMORY].",
            "\t * so if the following test fails, it implies",
            "\t * policy->nodes has movable memory only.",
            "\t */",
            "\tif (!nodes_intersects(policy->nodes, node_states[N_HIGH_MEMORY]))",
            "\t\tdynamic_policy_zone = ZONE_MOVABLE;",
            "",
            "\treturn zone >= dynamic_policy_zone;",
            "}",
            "static unsigned int weighted_interleave_nodes(struct mempolicy *policy)",
            "{",
            "\tunsigned int node;",
            "\tunsigned int cpuset_mems_cookie;",
            "",
            "retry:",
            "\t/* to prevent miscount use tsk->mems_allowed_seq to detect rebind */",
            "\tcpuset_mems_cookie = read_mems_allowed_begin();",
            "\tnode = current->il_prev;",
            "\tif (!current->il_weight || !node_isset(node, policy->nodes)) {",
            "\t\tnode = next_node_in(node, policy->nodes);",
            "\t\tif (read_mems_allowed_retry(cpuset_mems_cookie))",
            "\t\t\tgoto retry;",
            "\t\tif (node == MAX_NUMNODES)",
            "\t\t\treturn node;",
            "\t\tcurrent->il_prev = node;",
            "\t\tcurrent->il_weight = get_il_weight(node);",
            "\t}",
            "\tcurrent->il_weight--;",
            "\treturn node;",
            "}"
          ],
          "function_name": "kernel_get_mempolicy, vma_migratable, vma_policy_mof, apply_policy_zone, weighted_interleave_nodes",
          "description": "kernel_get_mempolicy 获取当前内存策略参数并复制到用户空间；vma_migratable 判断虚拟内存区域是否支持迁移；vma_policy_mof 检查VMA是否启用了MOF（Migration On Fault）策略；apply_policy_zone 确定当前zone是否满足策略要求；weighted_interleave_nodes 计算加权交错分配的目标节点。",
          "similarity": 0.5906164646148682
        },
        {
          "chunk_id": 12,
          "file_path": "mm/mempolicy.c",
          "start_line": 2024,
          "end_line": 2135,
          "content": [
            "static unsigned int interleave_nodes(struct mempolicy *policy)",
            "{",
            "\tunsigned int nid;",
            "\tunsigned int cpuset_mems_cookie;",
            "",
            "\t/* to prevent miscount, use tsk->mems_allowed_seq to detect rebind */",
            "\tdo {",
            "\t\tcpuset_mems_cookie = read_mems_allowed_begin();",
            "\t\tnid = next_node_in(current->il_prev, policy->nodes);",
            "\t} while (read_mems_allowed_retry(cpuset_mems_cookie));",
            "",
            "\tif (nid < MAX_NUMNODES)",
            "\t\tcurrent->il_prev = nid;",
            "\treturn nid;",
            "}",
            "unsigned int mempolicy_slab_node(void)",
            "{",
            "\tstruct mempolicy *policy;",
            "\tint node = numa_mem_id();",
            "",
            "\tif (!in_task())",
            "\t\treturn node;",
            "",
            "\tpolicy = current->mempolicy;",
            "\tif (!policy)",
            "\t\treturn node;",
            "",
            "\tswitch (policy->mode) {",
            "\tcase MPOL_PREFERRED:",
            "\t\treturn first_node(policy->nodes);",
            "",
            "\tcase MPOL_INTERLEAVE:",
            "\t\treturn interleave_nodes(policy);",
            "",
            "\tcase MPOL_WEIGHTED_INTERLEAVE:",
            "\t\treturn weighted_interleave_nodes(policy);",
            "",
            "\tcase MPOL_BIND:",
            "\tcase MPOL_PREFERRED_MANY:",
            "\t{",
            "\t\tstruct zoneref *z;",
            "",
            "\t\t/*",
            "\t\t * Follow bind policy behavior and start allocation at the",
            "\t\t * first node.",
            "\t\t */",
            "\t\tstruct zonelist *zonelist;",
            "\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);",
            "\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];",
            "\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,",
            "\t\t\t\t\t\t\t&policy->nodes);",
            "\t\treturn z->zone ? zone_to_nid(z->zone) : node;",
            "\t}",
            "\tcase MPOL_LOCAL:",
            "\t\treturn node;",
            "",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "static unsigned int read_once_policy_nodemask(struct mempolicy *pol,",
            "\t\t\t\t\t      nodemask_t *mask)",
            "{",
            "\t/*",
            "\t * barrier stabilizes the nodemask locally so that it can be iterated",
            "\t * over safely without concern for changes. Allocators validate node",
            "\t * selection does not violate mems_allowed, so this is safe.",
            "\t */",
            "\tbarrier();",
            "\tmemcpy(mask, &pol->nodes, sizeof(nodemask_t));",
            "\tbarrier();",
            "\treturn nodes_weight(*mask);",
            "}",
            "static unsigned int weighted_interleave_nid(struct mempolicy *pol, pgoff_t ilx)",
            "{",
            "\tstruct weighted_interleave_state *state;",
            "\tnodemask_t nodemask;",
            "\tunsigned int target, nr_nodes;",
            "\tu8 *table = NULL;",
            "\tunsigned int weight_total = 0;",
            "\tu8 weight;",
            "\tint nid = 0;",
            "",
            "\tnr_nodes = read_once_policy_nodemask(pol, &nodemask);",
            "\tif (!nr_nodes)",
            "\t\treturn numa_node_id();",
            "",
            "\trcu_read_lock();",
            "",
            "\tstate = rcu_dereference(wi_state);",
            "\t/* Uninitialized wi_state means we should assume all weights are 1 */",
            "\tif (state)",
            "\t\ttable = state->iw_table;",
            "",
            "\t/* calculate the total weight */",
            "\tfor_each_node_mask(nid, nodemask)",
            "\t\tweight_total += table ? table[nid] : 1;",
            "",
            "\t/* Calculate the node offset based on totals */",
            "\ttarget = ilx % weight_total;",
            "\tnid = first_node(nodemask);",
            "\twhile (target) {",
            "\t\t/* detect system default usage */",
            "\t\tweight = table ? table[nid] : 1;",
            "\t\tif (target < weight)",
            "\t\t\tbreak;",
            "\t\ttarget -= weight;",
            "\t\tnid = next_node_in(nid, nodemask);",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn nid;",
            "}"
          ],
          "function_name": "interleave_nodes, mempolicy_slab_node, read_once_policy_nodemask, weighted_interleave_nid",
          "description": "interleave_nodes 计算交错分配的下一个节点；mempolicy_slab_node 根据内存策略返回Slab分配的节点；read_once_policy_nodemask 安全读取策略节点掩码；weighted_interleave_nid 基于权重计算加权交错分配的目标节点。",
          "similarity": 0.5884760022163391
        },
        {
          "chunk_id": 13,
          "file_path": "mm/mempolicy.c",
          "start_line": 2149,
          "end_line": 2255,
          "content": [
            "static unsigned int interleave_nid(struct mempolicy *pol, pgoff_t ilx)",
            "{",
            "\tnodemask_t nodemask;",
            "\tunsigned int target, nnodes;",
            "\tint i;",
            "\tint nid;",
            "",
            "\tnnodes = read_once_policy_nodemask(pol, &nodemask);",
            "\tif (!nnodes)",
            "\t\treturn numa_node_id();",
            "\ttarget = ilx % nnodes;",
            "\tnid = first_node(nodemask);",
            "\tfor (i = 0; i < target; i++)",
            "\t\tnid = next_node(nid, nodemask);",
            "\treturn nid;",
            "}",
            "int huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,",
            "\t\tstruct mempolicy **mpol, nodemask_t **nodemask)",
            "{",
            "\tpgoff_t ilx;",
            "\tint nid;",
            "",
            "\tnid = numa_node_id();",
            "\t*mpol = get_vma_policy(vma, addr, hstate_vma(vma)->order, &ilx);",
            "\t*nodemask = policy_nodemask(gfp_flags, *mpol, ilx, &nid);",
            "\treturn nid;",
            "}",
            "bool init_nodemask_of_mempolicy(nodemask_t *mask)",
            "{",
            "\tstruct mempolicy *mempolicy;",
            "",
            "\tif (!(mask && current->mempolicy))",
            "\t\treturn false;",
            "",
            "\ttask_lock(current);",
            "\tmempolicy = current->mempolicy;",
            "\tswitch (mempolicy->mode) {",
            "\tcase MPOL_PREFERRED:",
            "\tcase MPOL_PREFERRED_MANY:",
            "\tcase MPOL_BIND:",
            "\tcase MPOL_INTERLEAVE:",
            "\tcase MPOL_WEIGHTED_INTERLEAVE:",
            "\t\t*mask = mempolicy->nodes;",
            "\t\tbreak;",
            "",
            "\tcase MPOL_LOCAL:",
            "\t\tinit_nodemask_of_node(mask, numa_node_id());",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "\ttask_unlock(current);",
            "",
            "\treturn true;",
            "}",
            "bool mempolicy_in_oom_domain(struct task_struct *tsk,",
            "\t\t\t\t\tconst nodemask_t *mask)",
            "{",
            "\tstruct mempolicy *mempolicy;",
            "\tbool ret = true;",
            "",
            "\tif (!mask)",
            "\t\treturn ret;",
            "",
            "\ttask_lock(tsk);",
            "\tmempolicy = tsk->mempolicy;",
            "\tif (mempolicy && mempolicy->mode == MPOL_BIND)",
            "\t\tret = nodes_intersects(mempolicy->nodes, *mask);",
            "\ttask_unlock(tsk);",
            "",
            "\treturn ret;",
            "}",
            "static unsigned long alloc_pages_bulk_array_interleave(gfp_t gfp,",
            "\t\tstruct mempolicy *pol, unsigned long nr_pages,",
            "\t\tstruct page **page_array)",
            "{",
            "\tint nodes;",
            "\tunsigned long nr_pages_per_node;",
            "\tint delta;",
            "\tint i;",
            "\tunsigned long nr_allocated;",
            "\tunsigned long total_allocated = 0;",
            "",
            "\tnodes = nodes_weight(pol->nodes);",
            "\tnr_pages_per_node = nr_pages / nodes;",
            "\tdelta = nr_pages - nodes * nr_pages_per_node;",
            "",
            "\tfor (i = 0; i < nodes; i++) {",
            "\t\tif (delta) {",
            "\t\t\tnr_allocated = alloc_pages_bulk_noprof(gfp,",
            "\t\t\t\t\tinterleave_nodes(pol), NULL,",
            "\t\t\t\t\tnr_pages_per_node + 1, NULL,",
            "\t\t\t\t\tpage_array);",
            "\t\t\tdelta--;",
            "\t\t} else {",
            "\t\t\tnr_allocated = alloc_pages_bulk_noprof(gfp,",
            "\t\t\t\t\tinterleave_nodes(pol), NULL,",
            "\t\t\t\t\tnr_pages_per_node, NULL, page_array);",
            "\t\t}",
            "",
            "\t\tpage_array += nr_allocated;",
            "\t\ttotal_allocated += nr_allocated;",
            "\t}",
            "",
            "\treturn total_allocated;",
            "}"
          ],
          "function_name": "interleave_nid, huge_node, init_nodemask_of_mempolicy, mempolicy_in_oom_domain, alloc_pages_bulk_array_interleave",
          "description": "interleave_nid 计算简单交错分配的目标节点；huge_node 结合HugeTLB策略确定大页分配节点；init_nodemask_of_mempolicy 初始化当前进程的内存策略节点掩码；mempolicy_in_oom_domain 检查策略节点是否与OOM域重叠；alloc_pages_bulk_array_interleave 执行批量交错分配。",
          "similarity": 0.5785263180732727
        },
        {
          "chunk_id": 16,
          "file_path": "mm/mempolicy.c",
          "start_line": 2846,
          "end_line": 2946,
          "content": [
            "static void sp_free(struct sp_node *n)",
            "{",
            "\tmpol_put(n->policy);",
            "\tkmem_cache_free(sn_cache, n);",
            "}",
            "int mpol_misplaced(struct folio *folio, struct vm_fault *vmf,",
            "\t\t   unsigned long addr)",
            "{",
            "\tstruct mempolicy *pol;",
            "\tpgoff_t ilx;",
            "\tstruct zoneref *z;",
            "\tint curnid = folio_nid(folio);",
            "\tstruct vm_area_struct *vma = vmf->vma;",
            "\tint thiscpu = raw_smp_processor_id();",
            "\tint thisnid = numa_node_id();",
            "\tint polnid = NUMA_NO_NODE;",
            "\tint ret = NUMA_NO_NODE;",
            "",
            "\t/*",
            "\t * Make sure ptl is held so that we don't preempt and we",
            "\t * have a stable smp processor id",
            "\t */",
            "\tlockdep_assert_held(vmf->ptl);",
            "\tpol = get_vma_policy(vma, addr, folio_order(folio), &ilx);",
            "\tif (!(pol->flags & MPOL_F_MOF))",
            "\t\tgoto out;",
            "",
            "\tswitch (pol->mode) {",
            "\tcase MPOL_INTERLEAVE:",
            "\t\tpolnid = interleave_nid(pol, ilx);",
            "\t\tbreak;",
            "",
            "\tcase MPOL_WEIGHTED_INTERLEAVE:",
            "\t\tpolnid = weighted_interleave_nid(pol, ilx);",
            "\t\tbreak;",
            "",
            "\tcase MPOL_PREFERRED:",
            "\t\tif (node_isset(curnid, pol->nodes))",
            "\t\t\tgoto out;",
            "\t\tpolnid = first_node(pol->nodes);",
            "\t\tbreak;",
            "",
            "\tcase MPOL_LOCAL:",
            "\t\tpolnid = numa_node_id();",
            "\t\tbreak;",
            "",
            "\tcase MPOL_BIND:",
            "\tcase MPOL_PREFERRED_MANY:",
            "\t\t/*",
            "\t\t * Even though MPOL_PREFERRED_MANY can allocate pages outside",
            "\t\t * policy nodemask we don't allow numa migration to nodes",
            "\t\t * outside policy nodemask for now. This is done so that if we",
            "\t\t * want demotion to slow memory to happen, before allocating",
            "\t\t * from some DRAM node say 'x', we will end up using a",
            "\t\t * MPOL_PREFERRED_MANY mask excluding node 'x'. In such scenario",
            "\t\t * we should not promote to node 'x' from slow memory node.",
            "\t\t */",
            "\t\tif (pol->flags & MPOL_F_MORON) {",
            "\t\t\t/*",
            "\t\t\t * Optimize placement among multiple nodes",
            "\t\t\t * via NUMA balancing",
            "\t\t\t */",
            "\t\t\tif (node_isset(thisnid, pol->nodes))",
            "\t\t\t\tbreak;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * use current page if in policy nodemask,",
            "\t\t * else select nearest allowed node, if any.",
            "\t\t * If no allowed nodes, use current [!misplaced].",
            "\t\t */",
            "\t\tif (node_isset(curnid, pol->nodes))",
            "\t\t\tgoto out;",
            "\t\tz = first_zones_zonelist(",
            "\t\t\t\tnode_zonelist(thisnid, GFP_HIGHUSER),",
            "\t\t\t\tgfp_zone(GFP_HIGHUSER),",
            "\t\t\t\t&pol->nodes);",
            "\t\tpolnid = zone_to_nid(z->zone);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\t/* Migrate the folio towards the node whose CPU is referencing it */",
            "\tif (pol->flags & MPOL_F_MORON) {",
            "\t\tpolnid = thisnid;",
            "",
            "\t\tif (!should_numa_migrate_memory(current, folio, curnid,",
            "\t\t\t\t\t\tthiscpu))",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tif (curnid != polnid)",
            "\t\tret = polnid;",
            "out:",
            "\tmpol_cond_put(pol);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "sp_free, mpol_misplaced",
          "description": "sp_free释放共享策略节点资源，mpol_misplaced判断页面是否符合内存策略节点要求，若不符合则计算应迁移的目标节点，支持多种策略模式下的节点选择逻辑。",
          "similarity": 0.5693347454071045
        }
      ]
    },
    {
      "source_file": "mm/fail_page_alloc.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:59:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fail_page_alloc.c`\n\n---\n\n# `fail_page_alloc.c` 技术文档\n\n## 1. 文件概述\n\n`fail_page_alloc.c` 是 Linux 内核中用于实现内存页分配故障注入（fault injection）机制的模块。该文件通过模拟 `alloc_pages()` 等内存分配函数失败的情形，帮助开发者测试内核在内存分配失败时的错误处理路径和健壮性。它基于通用的故障注入框架（`fault-inject.h`），并提供了运行时可配置的控制参数。\n\n## 2. 核心功能\n\n### 数据结构\n- **`fail_page_alloc`**：全局静态结构体，包含：\n  - `attr`：标准的 `fault_attr` 故障属性，用于控制故障注入的概率、间隔等行为。\n  - `ignore_gfp_highmem`：布尔值，若为 `true`，则忽略带有 `__GFP_HIGHMEM` 标志的分配请求。\n  - `ignore_gfp_reclaim`：布尔值，若为 `true`，则忽略带有 `__GFP_DIRECT_RECLAIM` 标志的分配请求。\n  - `min_order`：无符号 32 位整数，指定只对大于等于此阶数（order）的页分配进行故障注入。\n\n### 主要函数\n- **`setup_fail_page_alloc(char *str)`**：内核启动参数解析函数，用于通过 `fail_page_alloc=` 内核命令行参数初始化故障属性。\n- **`should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)`**：核心判断函数，根据当前分配请求的 `gfp_mask` 和 `order` 决定是否注入分配失败。\n- **`fail_page_alloc_debugfs(void)`**（条件编译）：在启用了 `CONFIG_FAULT_INJECTION_DEBUG_FS` 时，创建 debugfs 接口以动态调整故障注入参数。\n\n### 宏与注解\n- **`__setup(\"fail_page_alloc=\", setup_fail_page_alloc)`**：注册内核启动参数处理函数。\n- **`ALLOW_ERROR_INJECTION(should_fail_alloc_page, TRUE)`**：声明该函数可被错误注入框架拦截，支持动态启用/禁用。\n\n## 3. 关键实现\n\n- **故障注入条件判断**：\n  - 仅当请求的 `order >= min_order` 时才考虑注入失败。\n  - 若分配标志包含 `__GFP_NOFAIL`（表示分配必须成功），则跳过注入。\n  - 可选择性忽略高内存（`__GFP_HIGHMEM`）或直接回收（`__GFP_DIRECT_RECLAIM`）类型的分配请求。\n  - 若分配请求设置了 `__GFP_NOWARN`，则传递 `FAULT_NOWARN` 标志给底层故障注入逻辑，避免打印警告信息。\n\n- **debugfs 接口**（当 `CONFIG_FAULT_INJECTION_DEBUG_FS` 启用时）：\n  - 在 `/sys/kernel/debug/fail_page_alloc/` 目录下创建以下可调参数：\n    - `ignore-gfp-wait`：对应 `ignore_gfp_reclaim`（注：变量名与 debugfs 名称存在历史命名差异，实际控制 `__GFP_DIRECT_RECLAIM`）。\n    - `ignore-gfp-highmem`：控制是否忽略高内存分配。\n    - `min-order`：设置最小注入阶数。\n\n- **故障决策**：最终调用 `should_fail_ex()`，传入按 `order` 缩放的权重（`1 << order`），使得大块内存分配更容易被注入失败，更贴近真实场景。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/fault-inject.h>`：提供通用故障注入框架（如 `fault_attr`, `should_fail_ex`, `setup_fault_attr` 等）。\n  - `<linux/error-injection.h>`：提供 `ALLOW_ERROR_INJECTION` 宏，用于支持动态错误注入。\n  - `<linux/mm.h>`：提供内存管理相关定义，如 `gfp_t`、`__GFP_*` 标志等。\n\n- **内核配置依赖**：\n  - 必须启用 `CONFIG_FAULT_INJECTION` 才能使用基础故障注入功能。\n  - `CONFIG_FAULT_INJECTION_DEBUG_FS` 控制是否生成 debugfs 接口。\n\n- **调用关系**：\n  - `should_fail_alloc_page()` 被内存分配路径（如 `__alloc_pages()`）调用，通常通过 `__alloc_pages_nodemask()` 中的 `should_fail_alloc_page()` 检查点触发。\n\n## 5. 使用场景\n\n- **内核开发与测试**：\n  - 开发者可通过内核启动参数（如 `fail_page_alloc=10`）或 debugfs 接口动态开启页分配失败模拟，验证内核路径在内存不足时的行为。\n  - 用于测试文件系统、网络子系统、设备驱动等模块在 `kmalloc`/`alloc_pages` 失败时的错误恢复能力。\n\n- **压力测试与稳定性验证**：\n  - 结合 `failslab` 等其他故障注入模块，构建全面的内存压力测试环境。\n  - 验证 `__GFP_NOFAIL` 等关键分配是否被正确处理，防止死锁或崩溃。\n\n- **调试特定问题**：\n  - 当怀疑某段代码未正确处理内存分配失败时，可针对性地启用该模块，复现并定位问题。",
      "similarity": 0.5733560919761658,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/fail_page_alloc.c",
          "start_line": 1,
          "end_line": 18,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/fault-inject.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/mm.h>",
            "",
            "static struct {",
            "\tstruct fault_attr attr;",
            "",
            "\tbool ignore_gfp_highmem;",
            "\tbool ignore_gfp_reclaim;",
            "\tu32 min_order;",
            "} fail_page_alloc = {",
            "\t.attr = FAULT_ATTR_INITIALIZER,",
            "\t.ignore_gfp_reclaim = true,",
            "\t.ignore_gfp_highmem = true,",
            "\t.min_order = 1,",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了一个用于配置页面分配错误注入的结构体fail_page_alloc，包含故障属性、忽略GFP标志位和最小订单等参数，用于控制内存分配失败测试场景。",
          "similarity": 0.5722992420196533
        },
        {
          "chunk_id": 1,
          "file_path": "mm/fail_page_alloc.c",
          "start_line": 19,
          "end_line": 58,
          "content": [
            "static int __init setup_fail_page_alloc(char *str)",
            "{",
            "\treturn setup_fault_attr(&fail_page_alloc.attr, str);",
            "}",
            "bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)",
            "{",
            "\tint flags = 0;",
            "",
            "\tif (order < fail_page_alloc.min_order)",
            "\t\treturn false;",
            "\tif (gfp_mask & __GFP_NOFAIL)",
            "\t\treturn false;",
            "\tif (fail_page_alloc.ignore_gfp_highmem && (gfp_mask & __GFP_HIGHMEM))",
            "\t\treturn false;",
            "\tif (fail_page_alloc.ignore_gfp_reclaim &&",
            "\t\t\t(gfp_mask & __GFP_DIRECT_RECLAIM))",
            "\t\treturn false;",
            "",
            "\t/* See comment in __should_failslab() */",
            "\tif (gfp_mask & __GFP_NOWARN)",
            "\t\tflags |= FAULT_NOWARN;",
            "",
            "\treturn should_fail_ex(&fail_page_alloc.attr, 1 << order, flags);",
            "}",
            "static int __init fail_page_alloc_debugfs(void)",
            "{",
            "\tumode_t mode = S_IFREG | 0600;",
            "\tstruct dentry *dir;",
            "",
            "\tdir = fault_create_debugfs_attr(\"fail_page_alloc\", NULL,",
            "\t\t\t\t\t&fail_page_alloc.attr);",
            "",
            "\tdebugfs_create_bool(\"ignore-gfp-wait\", mode, dir,",
            "\t\t\t    &fail_page_alloc.ignore_gfp_reclaim);",
            "\tdebugfs_create_bool(\"ignore-gfp-highmem\", mode, dir,",
            "\t\t\t    &fail_page_alloc.ignore_gfp_highmem);",
            "\tdebugfs_create_u32(\"min-order\", mode, dir, &fail_page_alloc.min_order);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "setup_fail_page_alloc, should_fail_alloc_page, fail_page_alloc_debugfs",
          "description": "实现了页面分配错误注入的初始化、判定逻辑和调试接口，通过解析命令行参数、检查GFP标志位及订单大小，决定是否模拟页面分配失败，并提供调试文件系统配置接口。",
          "similarity": 0.5190243721008301
        }
      ]
    },
    {
      "source_file": "mm/failslab.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:00:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `failslab.c`\n\n---\n\n# failslab.c 技术文档\n\n## 1. 文件概述\n\n`failslab.c` 是 Linux 内核中用于实现 slab 分配器故障注入（fault injection）机制的核心文件。该机制允许在内存分配过程中人为地模拟分配失败，主要用于测试内核代码在内存不足或分配失败情况下的健壮性和错误处理路径。通过此功能，开发者可以验证内核子系统对 `ENOMEM` 等错误的响应是否正确，从而提升系统稳定性。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`failslab` 全局结构体**  \n  包含：\n  - `attr`：`struct fault_attr` 类型，用于配置故障注入的行为（如概率、间隔、堆栈跟踪等）\n  - `ignore_gfp_reclaim`：布尔值，控制是否忽略带有 `__GFP_DIRECT_RECLAIM` 标志的分配请求\n  - `cache_filter`：布尔值，启用后仅对设置了 `SLAB_FAILSLAB` 标志的 slab 缓存进行故障注入\n\n### 主要函数\n- **`should_failslab(struct kmem_cache *s, gfp_t gfpflags)`**  \n  判断当前 slab 分配请求是否应被强制失败。若满足注入条件，返回 `-ENOMEM`；否则返回 `0`。\n  \n- **`setup_failslab(char *str)`**  \n  内核启动参数解析函数，用于通过 `failslab=` 命令行参数初始化故障注入属性。\n\n- **`failslab_debugfs_init(void)`**（条件编译）  \n  在启用了 `CONFIG_FAULT_INJECTION_DEBUG_FS` 时，创建 debugfs 接口，允许运行时动态配置故障注入行为。\n\n### 宏与注解\n- **`ALLOW_ERROR_INJECTION(should_failslab, ERRNO)`**  \n  注册 `should_failslab` 函数为可被 error-injection 框架拦截的函数，支持通过 ftrace 或其他机制动态修改其返回值。\n\n## 3. 关键实现\n\n- **故障注入条件判断逻辑**：\n  1. **跳过 bootstrap cache**：若分配请求来自 `kmem_cache`（即 slab 自身的元数据缓存），则永不注入故障，防止系统初始化失败。\n  2. **跳过 `__GFP_NOFAIL` 请求**：该标志表示分配必须成功，因此不进行故障注入。\n  3. **可选跳过 reclaim 路径**：若 `ignore_gfp_reclaim` 为真且分配请求包含 `__GFP_DIRECT_RECLAIM`（即允许直接回收内存），则跳过注入，避免干扰内存回收关键路径。\n  4. **缓存过滤机制**：若启用 `cache_filter`，仅当目标 slab 缓存设置了 `SLAB_FAILSLAB` 标志时才进行注入，实现细粒度控制。\n  5. **静默模式支持**：若分配请求包含 `__GFP_NOWARN`，则传递 `FAULT_NOWARN` 标志给底层故障注入框架，避免打印警告信息（防止死锁，参考 commit 6b9dbedbe349）。\n\n- **debugfs 接口**：\n  - 创建 `/sys/kernel/debug/failslab/` 目录\n  - 提供 `ignore-gfp-wait`（实际对应 `ignore_gfp_reclaim`）和 `cache-filter` 两个可读写布尔文件，用于运行时调整行为\n\n- **启动参数支持**：  \n  通过 `failslab=<attributes>` 内核命令行参数（如 `failslab=probability:10,interval:100`）初始化故障注入策略。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/fault-inject.h>`：提供通用故障注入框架（`struct fault_attr`, `should_fail_ex()` 等）\n  - `<linux/error-injection.h>`：提供 `ALLOW_ERROR_INJECTION` 宏\n  - `<linux/slab.h>` 和 `\"slab.h\"`：提供 slab 分配器相关定义（`kmem_cache`, `SLAB_FAILSLAB` 等）\n  - `<linux/mm.h>`：提供 GFP 标志定义（如 `__GFP_NOFAIL`, `__GFP_DIRECT_RECLAIM`）\n\n- **内核配置依赖**：\n  - `CONFIG_FAULT_INJECTION`：必须启用才能使用故障注入功能\n  - `CONFIG_FAULT_INJECTION_DEBUG_FS`：启用 debugfs 接口（可选）\n\n- **与其他模块交互**：\n  - 被 slab/slub/slob 分配器调用（通过 `should_failslab()`）\n  - 与内核错误注入框架（error-injection）集成，支持动态返回值修改\n\n## 5. 使用场景\n\n- **内核开发与测试**：\n  - 验证内核子系统在内存分配失败时的错误处理逻辑（如驱动、文件系统、网络协议栈等）\n  - 模拟极端内存压力场景，测试 OOM（Out-Of-Memory）路径的正确性\n\n- **运行时调试**：\n  - 通过 debugfs 动态开启/关闭故障注入，无需重启系统\n  - 结合 `cache-filter` 精准针对特定 slab 缓存（如 `kmalloc-64`）进行测试\n\n- **自动化测试框架集成**：\n  - 作为 LTP（Linux Test Project）、KASAN、KFENCE 等测试工具的底层支持组件\n  - 用于 CI/CD 流水线中的健壮性回归测试\n\n- **安全与可靠性研究**：\n  - 分析内核在资源受限条件下的行为，发现潜在的内存泄漏或未处理错误路径",
      "similarity": 0.5632321834564209,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/failslab.c",
          "start_line": 18,
          "end_line": 66,
          "content": [
            "int should_failslab(struct kmem_cache *s, gfp_t gfpflags)",
            "{",
            "\tint flags = 0;",
            "",
            "\t/* No fault-injection for bootstrap cache */",
            "\tif (unlikely(s == kmem_cache))",
            "\t\treturn 0;",
            "",
            "\tif (gfpflags & __GFP_NOFAIL)",
            "\t\treturn 0;",
            "",
            "\tif (failslab.ignore_gfp_reclaim &&",
            "\t\t\t(gfpflags & __GFP_DIRECT_RECLAIM))",
            "\t\treturn 0;",
            "",
            "\tif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * In some cases, it expects to specify __GFP_NOWARN",
            "\t * to avoid printing any information(not just a warning),",
            "\t * thus avoiding deadlocks. See commit 6b9dbedbe349 for",
            "\t * details.",
            "\t */",
            "\tif (gfpflags & __GFP_NOWARN)",
            "\t\tflags |= FAULT_NOWARN;",
            "",
            "\treturn should_fail_ex(&failslab.attr, s->object_size, flags) ? -ENOMEM : 0;",
            "}",
            "static int __init setup_failslab(char *str)",
            "{",
            "\treturn setup_fault_attr(&failslab.attr, str);",
            "}",
            "static int __init failslab_debugfs_init(void)",
            "{",
            "\tstruct dentry *dir;",
            "\tumode_t mode = S_IFREG | 0600;",
            "",
            "\tdir = fault_create_debugfs_attr(\"failslab\", NULL, &failslab.attr);",
            "\tif (IS_ERR(dir))",
            "\t\treturn PTR_ERR(dir);",
            "",
            "\tdebugfs_create_bool(\"ignore-gfp-wait\", mode, dir,",
            "\t\t\t    &failslab.ignore_gfp_reclaim);",
            "\tdebugfs_create_bool(\"cache-filter\", mode, dir,",
            "\t\t\t    &failslab.cache_filter);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "should_failslab, setup_failslab, failslab_debugfs_init",
          "description": "实现should_failslab函数判断是否触发内存分配故障，setup_failslab初始化故障属性，failslab_debugfs_init创建调试接口用于配置故障注入参数",
          "similarity": 0.554135799407959
        },
        {
          "chunk_id": 0,
          "file_path": "mm/failslab.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/fault-inject.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include \"slab.h\"",
            "",
            "static struct {",
            "\tstruct fault_attr attr;",
            "\tbool ignore_gfp_reclaim;",
            "\tbool cache_filter;",
            "} failslab = {",
            "\t.attr = FAULT_ATTR_INITIALIZER,",
            "\t.ignore_gfp_reclaim = true,",
            "\t.cache_filter = false,",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义failslab结构体，用于存储故障注入配置属性(ignore_gfp_reclaim和cache_filter标志位)及故障属性(attr)，控制内存分配时的错误注入行为",
          "similarity": 0.5530263185501099
        }
      ]
    }
  ]
}