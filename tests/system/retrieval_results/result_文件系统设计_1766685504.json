{
  "query": "文件系统设计",
  "timestamp": "2025-12-26 01:58:24",
  "retrieved_files": [
    {
      "source_file": "mm/fadvise.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:59:19\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fadvise.c`\n\n---\n\n# fadvise.c 技术文档\n\n## 1. 文件概述\n\n`fadvise.c` 是 Linux 内核中实现 POSIX `posix_fadvise()` 系统调用的核心文件，位于 `mm/` 子系统目录下。该文件提供了一种机制，允许应用程序向内核提供关于其未来如何访问文件数据的“建议”（advice），从而帮助内核优化页面缓存（page cache）行为、预读（readahead）策略和内存回收策略。通过这些提示，内核可以更高效地管理内存资源，提升 I/O 性能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`generic_fadvise(struct file *file, loff_t offset, loff_t len, int advice)`**  \n  实现 POSIX fadvise 建议的通用处理逻辑，是大多数文件系统的默认实现。\n\n- **`vfs_fadvise(struct file *file, loff_t offset, loff_t len, int advice)`**  \n  虚拟文件系统（VFS）层的 fadvise 入口，优先调用文件操作结构体中自定义的 `fadvise` 方法，若未提供则回退到 `generic_fadvise`。\n\n- **`ksys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice)`**  \n  系统调用的内核服务例程，负责从用户空间获取文件描述符并调用 `vfs_fadvise`。\n\n- **系统调用接口**：\n  - `SYSCALL_DEFINE4(fadvise64_64, ...)`\n  - `SYSCALL_DEFINE4(fadvise64, ...)`（架构可选）\n  - `COMPAT_SYSCALL_DEFINE6(fadvise64_64, ...)`（兼容 32 位）\n\n### 支持的建议类型（POSIX_FADV_*）\n\n| 建议类型 | 作用 |\n|--------|------|\n| `POSIX_FADV_NORMAL` | 恢复默认预读行为 |\n| `POSIX_FADV_RANDOM` | 禁用顺序预读，标记为随机访问 |\n| `POSIX_FADV_SEQUENTIAL` | 启用双倍预读，优化顺序访问 |\n| `POSIX_FADV_WILLNEED` | 主动触发预读，将数据加载到 page cache |\n| `POSIX_FADV_NOREUSE` | 标记页面为“不再重用”，影响 LRU 行为（当前仅设置标志） |\n| `POSIX_FADV_DONTNEED` | 异步写回脏页并从 page cache 中移除指定范围的干净页 |\n\n## 3. 关键实现\n\n### 3.1 输入参数处理\n- 使用无符号 64 位算术计算 `endbyte = offset + len - 1`，防止有符号整数溢出。\n- 若 `len == 0` 或发生溢出，则将范围设为 `[offset, LLONG_MAX]`，表示“尽可能多”。\n\n### 3.2 特殊文件系统处理\n- 对 **FIFO** 返回 `-ESPIPE`（不支持）。\n- 对 **DAX（Direct Access）设备** 或使用 `noop_backing_dev_info` 的文件系统（如 tmpfs、ramfs），所有建议均被忽略（返回 0），因为这些存储不涉及传统块设备 I/O 和 page cache。\n\n### 3.3 各建议的具体实现\n- **NORMAL / RANDOM / SEQUENTIAL**：  \n  通过修改 `file->f_mode` 中的 `FMODE_RANDOM` 标志和调整 `file->f_ra.ra_pages`（预读页数）来控制后续 readahead 行为。\n  \n- **WILLNEED**：  \n  计算起止页号（`start_index`, `end_index`），调用 `force_page_cache_readahead()` 主动触发预读。\n\n- **NOREUSE**：  \n  仅设置 `FMODE_NOREUSE` 标志，目前内核未基于此标志做特殊处理（注释表明未来可能用于去激活页面并清除引用位）。\n\n- **DONTNEED**（最复杂）：\n  1. 调用 `__filemap_fdatawrite_range()` 异步回写指定范围内的脏页。\n  2. **精确计算要丢弃的完整页范围**：\n     - 起始页：向上对齐（跳过首部 partial page）\n     - 结束页：向下对齐（跳过尾部 partial page），除非 `endbyte` 恰好是文件末尾或页边界。\n  3. 调用 `lru_add_drain()` 清空本地 CPU 的 LRU 批量添加队列，提高后续无效化效率。\n  4. 使用 `mapping_try_invalidate()` 尝试移除 page cache 中的页面。\n  5. 若有失败（通常因页面在远程 CPU 的 LRU 上），则调用 `lru_add_drain_all()` 并重试 `invalidate_mapping_pages()`。\n\n### 3.4 锁与并发\n- 修改 `file->f_mode` 时使用 `file->f_lock` 自旋锁保护，确保线程安全。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/mm.h>`、`<linux/pagemap.h>`：页面缓存、地址空间操作\n- `<linux/writeback.h>`、`<linux/backing-dev.h>`：回写控制、后备设备信息\n- `<linux/file.h>`、`<linux/fs.h>`：VFS 层文件和 inode 结构\n- `\"internal.h\"`：MM 子系统内部函数（如 `force_page_cache_readahead`）\n\n### 内核子系统交互\n- **VFS 层**：通过 `file->f_op->fadvise` 支持文件系统自定义行为\n- **Memory Management (MM)**：操作 page cache、LRU 链表、预读机制\n- **Block Layer**：通过 backing_dev_info 获取设备 I/O 特性（如 `ra_pages`）\n- **DAX 子系统**：识别 DAX inode 并跳过缓存操作\n\n## 5. 使用场景\n\n- **应用程序性能优化**：\n  - 数据库系统在批量扫描前使用 `FADV_SEQUENTIAL`\n  - 流媒体应用使用 `FADV_WILLNEED` 预加载即将播放的数据\n  - 临时文件处理后使用 `FADV_DONTNEED` 释放缓存内存\n\n- **内存压力缓解**：\n  - 在内存紧张时，应用主动丢弃不再需要的缓存页（`FADV_DONTNEED`）\n\n- **I/O 模式适配**：\n  - 随机访问大文件时禁用预读（`FADV_RANDOM`），避免污染 page cache\n\n- **系统调用路径**：\n  - 用户空间调用 `posix_fadvise()` → 内核系统调用入口 → `vfs_fadvise()` → `generic_fadvise()`（或文件系统特定实现）",
      "similarity": 0.5681046843528748,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/fadvise.c",
          "start_line": 180,
          "end_line": 199,
          "content": [
            "int vfs_fadvise(struct file *file, loff_t offset, loff_t len, int advice)",
            "{",
            "\tif (file->f_op->fadvise)",
            "\t\treturn file->f_op->fadvise(file, offset, len, advice);",
            "",
            "\treturn generic_fadvise(file, offset, len, advice);",
            "}",
            "int ksys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice)",
            "{",
            "\tstruct fd f = fdget(fd);",
            "\tint ret;",
            "",
            "\tif (!f.file)",
            "\t\treturn -EBADF;",
            "",
            "\tret = vfs_fadvise(f.file, offset, len, advice);",
            "",
            "\tfdput(f);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "vfs_fadvise, ksys_fadvise64_64",
          "description": "该代码段实现了文件预读建议（fadvise）的通用处理逻辑。  \n`vfs_fadvise` 作为分发函数，优先调用文件系统特定的 `fadvise` 方法，否则使用通用实现 `generic_fadvise`。  \n`ksys_fadvise64_64` 是系统调用入口，负责解析文件描述符并转发请求至 `vfs_fadvise`，但缺少 `generic_fadvise` 具体实现细节，上下文不完整。",
          "similarity": 0.5356611013412476
        },
        {
          "chunk_id": 1,
          "file_path": "mm/fadvise.c",
          "start_line": 31,
          "end_line": 177,
          "content": [
            "int generic_fadvise(struct file *file, loff_t offset, loff_t len, int advice)",
            "{",
            "\tstruct inode *inode;",
            "\tstruct address_space *mapping;",
            "\tstruct backing_dev_info *bdi;",
            "\tloff_t endbyte;\t\t\t/* inclusive */",
            "\tpgoff_t start_index;",
            "\tpgoff_t end_index;",
            "\tunsigned long nrpages;",
            "",
            "\tinode = file_inode(file);",
            "\tif (S_ISFIFO(inode->i_mode))",
            "\t\treturn -ESPIPE;",
            "",
            "\tmapping = file->f_mapping;",
            "\tif (!mapping || len < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tbdi = inode_to_bdi(mapping->host);",
            "",
            "\tif (IS_DAX(inode) || (bdi == &noop_backing_dev_info)) {",
            "\t\tswitch (advice) {",
            "\t\tcase POSIX_FADV_NORMAL:",
            "\t\tcase POSIX_FADV_RANDOM:",
            "\t\tcase POSIX_FADV_SEQUENTIAL:",
            "\t\tcase POSIX_FADV_WILLNEED:",
            "\t\tcase POSIX_FADV_NOREUSE:",
            "\t\tcase POSIX_FADV_DONTNEED:",
            "\t\t\t/* no bad return value, but ignore advice */",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * Careful about overflows. Len == 0 means \"as much as possible\".  Use",
            "\t * unsigned math because signed overflows are undefined and UBSan",
            "\t * complains.",
            "\t */",
            "\tendbyte = (u64)offset + (u64)len;",
            "\tif (!len || endbyte < len)",
            "\t\tendbyte = LLONG_MAX;",
            "\telse",
            "\t\tendbyte--;\t\t/* inclusive */",
            "",
            "\tswitch (advice) {",
            "\tcase POSIX_FADV_NORMAL:",
            "\t\tfile->f_ra.ra_pages = bdi->ra_pages;",
            "\t\tspin_lock(&file->f_lock);",
            "\t\tfile->f_mode &= ~(FMODE_RANDOM | FMODE_NOREUSE);",
            "\t\tspin_unlock(&file->f_lock);",
            "\t\tbreak;",
            "\tcase POSIX_FADV_RANDOM:",
            "\t\tspin_lock(&file->f_lock);",
            "\t\tfile->f_mode |= FMODE_RANDOM;",
            "\t\tspin_unlock(&file->f_lock);",
            "\t\tbreak;",
            "\tcase POSIX_FADV_SEQUENTIAL:",
            "\t\tfile->f_ra.ra_pages = bdi->ra_pages * 2;",
            "\t\tspin_lock(&file->f_lock);",
            "\t\tfile->f_mode &= ~FMODE_RANDOM;",
            "\t\tspin_unlock(&file->f_lock);",
            "\t\tbreak;",
            "\tcase POSIX_FADV_WILLNEED:",
            "\t\t/* First and last PARTIAL page! */",
            "\t\tstart_index = offset >> PAGE_SHIFT;",
            "\t\tend_index = endbyte >> PAGE_SHIFT;",
            "",
            "\t\t/* Careful about overflow on the \"+1\" */",
            "\t\tnrpages = end_index - start_index + 1;",
            "\t\tif (!nrpages)",
            "\t\t\tnrpages = ~0UL;",
            "",
            "\t\tforce_page_cache_readahead(mapping, file, start_index, nrpages);",
            "\t\tbreak;",
            "\tcase POSIX_FADV_NOREUSE:",
            "\t\tspin_lock(&file->f_lock);",
            "\t\tfile->f_mode |= FMODE_NOREUSE;",
            "\t\tspin_unlock(&file->f_lock);",
            "\t\tbreak;",
            "\tcase POSIX_FADV_DONTNEED:",
            "\t\t__filemap_fdatawrite_range(mapping, offset, endbyte,",
            "\t\t\t\t\t   WB_SYNC_NONE);",
            "",
            "\t\t/*",
            "\t\t * First and last FULL page! Partial pages are deliberately",
            "\t\t * preserved on the expectation that it is better to preserve",
            "\t\t * needed memory than to discard unneeded memory.",
            "\t\t */",
            "\t\tstart_index = (offset+(PAGE_SIZE-1)) >> PAGE_SHIFT;",
            "\t\tend_index = (endbyte >> PAGE_SHIFT);",
            "\t\t/*",
            "\t\t * The page at end_index will be inclusively discarded according",
            "\t\t * by invalidate_mapping_pages(), so subtracting 1 from",
            "\t\t * end_index means we will skip the last page.  But if endbyte",
            "\t\t * is page aligned or is at the end of file, we should not skip",
            "\t\t * that page - discarding the last page is safe enough.",
            "\t\t */",
            "\t\tif ((endbyte & ~PAGE_MASK) != ~PAGE_MASK &&",
            "\t\t\t\tendbyte != inode->i_size - 1) {",
            "\t\t\t/* First page is tricky as 0 - 1 = -1, but pgoff_t",
            "\t\t\t * is unsigned, so the end_index >= start_index",
            "\t\t\t * check below would be true and we'll discard the whole",
            "\t\t\t * file cache which is not what was asked.",
            "\t\t\t */",
            "\t\t\tif (end_index == 0)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\tend_index--;",
            "\t\t}",
            "",
            "\t\tif (end_index >= start_index) {",
            "\t\t\tunsigned long nr_failed = 0;",
            "",
            "\t\t\t/*",
            "\t\t\t * It's common to FADV_DONTNEED right after",
            "\t\t\t * the read or write that instantiates the",
            "\t\t\t * pages, in which case there will be some",
            "\t\t\t * sitting on the local LRU cache. Try to",
            "\t\t\t * avoid the expensive remote drain and the",
            "\t\t\t * second cache tree walk below by flushing",
            "\t\t\t * them out right away.",
            "\t\t\t */",
            "\t\t\tlru_add_drain();",
            "",
            "\t\t\tmapping_try_invalidate(mapping, start_index, end_index,",
            "\t\t\t\t\t&nr_failed);",
            "",
            "\t\t\t/*",
            "\t\t\t * The failures may be due to the folio being",
            "\t\t\t * in the LRU cache of a remote CPU. Drain all",
            "\t\t\t * caches and try again.",
            "\t\t\t */",
            "\t\t\tif (nr_failed) {",
            "\t\t\t\tlru_add_drain_all();",
            "\t\t\t\tinvalidate_mapping_pages(mapping, start_index,",
            "\t\t\t\t\t\tend_index);",
            "\t\t\t}",
            "\t\t}",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "generic_fadvise",
          "description": "该代码实现了`generic_fadvise`函数，用于处理文件读取建议（advice）对内存管理和I/O调度的影响。  \n函数根据传入的建议类型（如POSIX_FADV_DONTNEED、SEQUENTIAL等），调整文件读取模式或触发页面无效化操作，同时处理特殊设备（如DAX或noop BDI）的兼容性。  \n对于非特殊设备，依据建议类型修改文件读取策略或直接无效化指定范围的页缓存，但对DAX设备及noop BDI直接忽略建议以避免不必要的操作。",
          "similarity": 0.5327861309051514
        },
        {
          "chunk_id": 0,
          "file_path": "mm/fadvise.c",
          "start_line": 1,
          "end_line": 30,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * mm/fadvise.c",
            " *",
            " * Copyright (C) 2002, Linus Torvalds",
            " *",
            " * 11Jan2003\tAndrew Morton",
            " *\t\tInitial version.",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fadvise.h>",
            "#include <linux/writeback.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "",
            "#include <asm/unistd.h>",
            "",
            "#include \"internal.h\"",
            "",
            "/*",
            " * POSIX_FADV_WILLNEED could set PG_Referenced, and POSIX_FADV_NOREUSE could",
            " * deactivate the pages and clear PG_Referenced.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "该代码段属于`mm/fadvise.c`文件的头部，主要定义与POSIX文件预读 advisory 建议相关的内核机制，通过设置或清除页面状态标志（如PG_Referenced）影响缓存行为。代码片段未包含完整函数实现，而是声明了与文件访问模式控制相关的常量及依赖项。此模块核心功能是实现`fadvise`系统调用的内核态逻辑，用于指导页面缓存管理策略。",
          "similarity": 0.4831118583679199
        }
      ]
    },
    {
      "source_file": "mm/damon/sysfs.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:52:10\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `damon\\sysfs.c`\n\n---\n\n# damon/sysfs.c 技术文档\n\n## 1. 文件概述\n\n`damon/sysfs.c` 是 Linux 内核中 DAMON（Data Access MONitor）子系统的 sysfs 接口实现文件。该文件通过 sysfs 提供用户空间可配置的接口，用于动态管理 DAMON 监控目标（如进程 PID）及其对应的内存区域（regions）。用户可通过标准文件系统操作（读/写）来设置监控目标数量、每个目标的 PID 以及其监控的虚拟地址范围（起始和结束地址），从而实现对 DAMON 行为的灵活控制。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct damon_sysfs_region`：表示一个内存监控区域，包含起始地址（`start`）和结束地址（`end`）。\n- `struct damon_sysfs_regions`：表示一个目标进程的所有监控区域集合，包含区域数组和数量。\n- `struct damon_sysfs_target`：表示一个 DAMON 监控目标，包含进程 PID 和对应的 regions 对象。\n- `struct damon_sysfs_targets`：表示所有监控目标的集合，包含 targets 数组和数量。\n\n### 主要函数\n- **Region 层级**：\n  - `damon_sysfs_region_alloc()`：分配并初始化 region 对象。\n  - `start_show()` / `start_store()`：读取/写入 region 起始地址。\n  - `end_show()` / `end_store()`：读取/写入 region 结束地址。\n  - `damon_sysfs_region_release()`：释放 region 对象。\n\n- **Regions 层级**：\n  - `damon_sysfs_regions_alloc()`：分配 regions 对象。\n  - `damon_sysfs_regions_add_dirs()`：根据指定数量动态创建 region 子目录。\n  - `damon_sysfs_regions_rm_dirs()`：删除所有 region 子目录并释放资源。\n  - `nr_regions_show()` / `nr_regions_store()`：读取/设置 regions 数量。\n\n- **Target 层级**：\n  - `damon_sysfs_target_alloc()`：分配 target 对象。\n  - `damon_sysfs_target_add_dirs()`：为目标创建 regions 子目录。\n  - `damon_sysfs_target_rm_dirs()`：删除目标的 regions 子目录。\n  - `pid_target_show()` / `pid_target_store()`：读取/设置目标进程 PID。\n\n- **Targets 层级**：\n  - `damon_sysfs_targets_alloc()`：分配 targets 对象。\n  - `damon_sysfs_targets_add_dirs()`：根据指定数量动态创建 target 子目录。\n  - `damon_sysfs_targets_rm_dirs()`：删除所有 target 子目录并释放资源。\n\n## 3. 关键实现\n\n- **分层 sysfs 目录结构**：  \n  实现了四层嵌套的 sysfs 目录结构：  \n  `targets/` → `targets/<index>/` → `targets/<index>/regions/` → `targets/<index>/regions/<index>/`  \n  每层通过 `kobject` 和 `kobj_type` 管理生命周期和属性操作。\n\n- **动态目录管理**：  \n  通过写入 `nr_regions` 或上层 targets 的数量，动态创建或销毁对应数量的子目录。例如，向 `targets/nr_targets` 写入 `3` 会创建 `0/`、`1/`、`2/` 三个 target 目录。\n\n- **并发控制**：  \n  在修改 regions 数量时使用全局互斥锁 `damon_sysfs_lock`（定义在 `sysfs-common.h` 中），防止并发修改导致状态不一致。\n\n- **内存安全**：  \n  所有分配均使用 `kzalloc` 初始化，并在失败路径中进行完整的资源回滚（如 `damon_sysfs_regions_add_dirs` 失败时调用 `damon_sysfs_regions_rm_dirs` 清理已分配对象）。\n\n- **属性权限**：  \n  所有 sysfs 属性均设置为 `0600`（仅 root 可读写），确保安全性。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `sysfs-common.h`：提供全局锁 `damon_sysfs_lock` 和通用 sysfs 操作辅助函数。\n  - `damon.h`（间接）：使用 `struct damon_addr_range` 定义内存区域。\n\n- **内核核心依赖**：\n  - `<linux/kobject.h>`：提供 kobject 基础设施（通过 `sysfs-common.h` 间接包含）。\n  - `<linux/slab.h>`：提供内存分配函数 `kzalloc`、`kmalloc_array`。\n  - `<linux/pid.h>` 和 `<linux/sched.h>`：用于进程相关操作（尽管当前代码未直接使用，但为未来扩展预留）。\n\n## 5. 使用场景\n\n- **DAMON 配置**：  \n  用户空间工具（如 `damo`）通过写入 sysfs 文件配置 DAMON 监控目标。例如：\n  ```bash\n  echo 1 > /sys/kernel/mm/damon/targets/nr_targets\n  echo 1234 > /sys/kernel/mm/damon/targets/0/pid_target\n  echo 2 > /sys/kernel/mm/damon/targets/0/regions/nr_regions\n  echo 0x100000 > /sys/kernel/mm/damon/targets/0/regions/0/start\n  echo 0x200000 > /sys/kernel/mm/damon/targets/0/regions/0/end\n  ```\n\n- **动态调整监控范围**：  \n  在 DAMON 运行时，可动态增减监控目标或修改内存区域，无需重启内核模块。\n\n- **调试与监控**：  \n  通过读取 sysfs 文件验证当前 DAMON 配置状态，辅助调试内存访问模式分析任务。",
      "similarity": 0.5618228912353516,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 709,
          "end_line": 839,
          "content": [
            "static int damon_sysfs_context_add_dirs(struct damon_sysfs_context *context)",
            "{",
            "\tint err;",
            "",
            "\terr = damon_sysfs_context_set_attrs(context);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = damon_sysfs_context_set_targets(context);",
            "\tif (err)",
            "\t\tgoto put_attrs_out;",
            "",
            "\terr = damon_sysfs_context_set_schemes(context);",
            "\tif (err)",
            "\t\tgoto put_targets_attrs_out;",
            "\treturn 0;",
            "",
            "put_targets_attrs_out:",
            "\tkobject_put(&context->targets->kobj);",
            "\tcontext->targets = NULL;",
            "put_attrs_out:",
            "\tkobject_put(&context->attrs->kobj);",
            "\tcontext->attrs = NULL;",
            "\treturn err;",
            "}",
            "static void damon_sysfs_context_rm_dirs(struct damon_sysfs_context *context)",
            "{",
            "\tdamon_sysfs_attrs_rm_dirs(context->attrs);",
            "\tkobject_put(&context->attrs->kobj);",
            "\tdamon_sysfs_targets_rm_dirs(context->targets);",
            "\tkobject_put(&context->targets->kobj);",
            "\tdamon_sysfs_schemes_rm_dirs(context->schemes);",
            "\tkobject_put(&context->schemes->kobj);",
            "}",
            "static ssize_t avail_operations_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tenum damon_ops_id id;",
            "\tint len = 0;",
            "",
            "\tfor (id = 0; id < NR_DAMON_OPS; id++) {",
            "\t\tif (!damon_is_registered_ops(id))",
            "\t\t\tcontinue;",
            "\t\tlen += sysfs_emit_at(buf, len, \"%s\\n\",",
            "\t\t\t\tdamon_sysfs_ops_strs[id]);",
            "\t}",
            "\treturn len;",
            "}",
            "static ssize_t operations_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct damon_sysfs_context *context = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_context, kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%s\\n\", damon_sysfs_ops_strs[context->ops_id]);",
            "}",
            "static ssize_t operations_store(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_context *context = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_context, kobj);",
            "\tenum damon_ops_id id;",
            "",
            "\tfor (id = 0; id < NR_DAMON_OPS; id++) {",
            "\t\tif (sysfs_streq(buf, damon_sysfs_ops_strs[id])) {",
            "\t\t\tcontext->ops_id = id;",
            "\t\t\treturn count;",
            "\t\t}",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static void damon_sysfs_context_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_context, kobj));",
            "}",
            "static void damon_sysfs_contexts_rm_dirs(struct damon_sysfs_contexts *contexts)",
            "{",
            "\tstruct damon_sysfs_context **contexts_arr = contexts->contexts_arr;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < contexts->nr; i++) {",
            "\t\tdamon_sysfs_context_rm_dirs(contexts_arr[i]);",
            "\t\tkobject_put(&contexts_arr[i]->kobj);",
            "\t}",
            "\tcontexts->nr = 0;",
            "\tkfree(contexts_arr);",
            "\tcontexts->contexts_arr = NULL;",
            "}",
            "static int damon_sysfs_contexts_add_dirs(struct damon_sysfs_contexts *contexts,",
            "\t\tint nr_contexts)",
            "{",
            "\tstruct damon_sysfs_context **contexts_arr, *context;",
            "\tint err, i;",
            "",
            "\tdamon_sysfs_contexts_rm_dirs(contexts);",
            "\tif (!nr_contexts)",
            "\t\treturn 0;",
            "",
            "\tcontexts_arr = kmalloc_array(nr_contexts, sizeof(*contexts_arr),",
            "\t\t\tGFP_KERNEL | __GFP_NOWARN);",
            "\tif (!contexts_arr)",
            "\t\treturn -ENOMEM;",
            "\tcontexts->contexts_arr = contexts_arr;",
            "",
            "\tfor (i = 0; i < nr_contexts; i++) {",
            "\t\tcontext = damon_sysfs_context_alloc(DAMON_OPS_VADDR);",
            "\t\tif (!context) {",
            "\t\t\tdamon_sysfs_contexts_rm_dirs(contexts);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "",
            "\t\terr = kobject_init_and_add(&context->kobj,",
            "\t\t\t\t&damon_sysfs_context_ktype, &contexts->kobj,",
            "\t\t\t\t\"%d\", i);",
            "\t\tif (err)",
            "\t\t\tgoto out;",
            "",
            "\t\terr = damon_sysfs_context_add_dirs(context);",
            "\t\tif (err)",
            "\t\t\tgoto out;",
            "",
            "\t\tcontexts_arr[i] = context;",
            "\t\tcontexts->nr++;",
            "\t}",
            "\treturn 0;",
            "",
            "out:",
            "\tdamon_sysfs_contexts_rm_dirs(contexts);",
            "\tkobject_put(&context->kobj);",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_sysfs_context_add_dirs, damon_sysfs_context_rm_dirs, avail_operations_show, operations_show, operations_store, damon_sysfs_context_release, damon_sysfs_contexts_rm_dirs, damon_sysfs_contexts_add_dirs",
          "description": "实现DAMON sysfs上下文目录的添加和移除逻辑，包含属性、目标和方案的初始化及清理，通过kobject管理子目录并处理错误回滚。",
          "similarity": 0.5409599542617798
        },
        {
          "chunk_id": 6,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 882,
          "end_line": 982,
          "content": [
            "static ssize_t nr_contexts_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct damon_sysfs_contexts *contexts = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_contexts, kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%d\\n\", contexts->nr);",
            "}",
            "static ssize_t nr_contexts_store(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_contexts *contexts;",
            "\tint nr, err;",
            "",
            "\terr = kstrtoint(buf, 0, &nr);",
            "\tif (err)",
            "\t\treturn err;",
            "\t/* TODO: support multiple contexts per kdamond */",
            "\tif (nr < 0 || 1 < nr)",
            "\t\treturn -EINVAL;",
            "",
            "\tcontexts = container_of(kobj, struct damon_sysfs_contexts, kobj);",
            "\tif (!mutex_trylock(&damon_sysfs_lock))",
            "\t\treturn -EBUSY;",
            "\terr = damon_sysfs_contexts_add_dirs(contexts, nr);",
            "\tmutex_unlock(&damon_sysfs_lock);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn count;",
            "}",
            "static void damon_sysfs_contexts_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_contexts, kobj));",
            "}",
            "static int damon_sysfs_kdamond_add_dirs(struct damon_sysfs_kdamond *kdamond)",
            "{",
            "\tstruct damon_sysfs_contexts *contexts;",
            "\tint err;",
            "",
            "\tcontexts = damon_sysfs_contexts_alloc();",
            "\tif (!contexts)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = kobject_init_and_add(&contexts->kobj,",
            "\t\t\t&damon_sysfs_contexts_ktype, &kdamond->kobj,",
            "\t\t\t\"contexts\");",
            "\tif (err) {",
            "\t\tkobject_put(&contexts->kobj);",
            "\t\treturn err;",
            "\t}",
            "\tkdamond->contexts = contexts;",
            "",
            "\treturn err;",
            "}",
            "static void damon_sysfs_kdamond_rm_dirs(struct damon_sysfs_kdamond *kdamond)",
            "{",
            "\tdamon_sysfs_contexts_rm_dirs(kdamond->contexts);",
            "\tkobject_put(&kdamond->contexts->kobj);",
            "}",
            "static bool damon_sysfs_ctx_running(struct damon_ctx *ctx)",
            "{",
            "\tbool running;",
            "",
            "\tmutex_lock(&ctx->kdamond_lock);",
            "\trunning = ctx->kdamond != NULL;",
            "\tmutex_unlock(&ctx->kdamond_lock);",
            "\treturn running;",
            "}",
            "static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\tchar *buf)",
            "{",
            "\tstruct damon_sysfs_kdamond *kdamond = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_kdamond, kobj);",
            "\tstruct damon_ctx *ctx = kdamond->damon_ctx;",
            "\tbool running;",
            "",
            "\tif (!ctx)",
            "\t\trunning = false;",
            "\telse",
            "\t\trunning = damon_sysfs_ctx_running(ctx);",
            "",
            "\treturn sysfs_emit(buf, \"%s\\n\", running ?",
            "\t\t\tdamon_sysfs_cmd_strs[DAMON_SYSFS_CMD_ON] :",
            "\t\t\tdamon_sysfs_cmd_strs[DAMON_SYSFS_CMD_OFF]);",
            "}",
            "static int damon_sysfs_set_attrs(struct damon_ctx *ctx,",
            "\t\tstruct damon_sysfs_attrs *sys_attrs)",
            "{",
            "\tstruct damon_sysfs_intervals *sys_intervals = sys_attrs->intervals;",
            "\tstruct damon_sysfs_ul_range *sys_nr_regions =",
            "\t\tsys_attrs->nr_regions_range;",
            "\tstruct damon_attrs attrs = {",
            "\t\t.sample_interval = sys_intervals->sample_us,",
            "\t\t.aggr_interval = sys_intervals->aggr_us,",
            "\t\t.ops_update_interval = sys_intervals->update_us,",
            "\t\t.min_nr_regions = sys_nr_regions->min,",
            "\t\t.max_nr_regions = sys_nr_regions->max,",
            "\t};",
            "\treturn damon_set_attrs(ctx, &attrs);",
            "}"
          ],
          "function_name": "nr_contexts_show, nr_contexts_store, damon_sysfs_contexts_release, damon_sysfs_kdamond_add_dirs, damon_sysfs_kdamond_rm_dirs, damon_sysfs_ctx_running, state_show, damon_sysfs_set_attrs",
          "description": "提供sysfs接口读取/设置上下文数量，管理kdamond目录结构，状态展示及属性设置功能，支持动态更新监控参数。",
          "similarity": 0.5388405919075012
        },
        {
          "chunk_id": 12,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 1730,
          "end_line": 1785,
          "content": [
            "static void damon_sysfs_kdamonds_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_kdamonds, kobj));",
            "}",
            "static int damon_sysfs_ui_dir_add_dirs(struct damon_sysfs_ui_dir *ui_dir)",
            "{",
            "\tstruct damon_sysfs_kdamonds *kdamonds;",
            "\tint err;",
            "",
            "\tkdamonds = damon_sysfs_kdamonds_alloc();",
            "\tif (!kdamonds)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = kobject_init_and_add(&kdamonds->kobj,",
            "\t\t\t&damon_sysfs_kdamonds_ktype, &ui_dir->kobj,",
            "\t\t\t\"kdamonds\");",
            "\tif (err) {",
            "\t\tkobject_put(&kdamonds->kobj);",
            "\t\treturn err;",
            "\t}",
            "\tui_dir->kdamonds = kdamonds;",
            "\treturn err;",
            "}",
            "static void damon_sysfs_ui_dir_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_ui_dir, kobj));",
            "}",
            "static int __init damon_sysfs_init(void)",
            "{",
            "\tstruct kobject *damon_sysfs_root;",
            "\tstruct damon_sysfs_ui_dir *admin;",
            "\tint err;",
            "",
            "\tdamon_sysfs_root = kobject_create_and_add(\"damon\", mm_kobj);",
            "\tif (!damon_sysfs_root)",
            "\t\treturn -ENOMEM;",
            "",
            "\tadmin = damon_sysfs_ui_dir_alloc();",
            "\tif (!admin) {",
            "\t\tkobject_put(damon_sysfs_root);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\terr = kobject_init_and_add(&admin->kobj, &damon_sysfs_ui_dir_ktype,",
            "\t\t\tdamon_sysfs_root, \"admin\");",
            "\tif (err)",
            "\t\tgoto out;",
            "\terr = damon_sysfs_ui_dir_add_dirs(admin);",
            "\tif (err)",
            "\t\tgoto out;",
            "\treturn 0;",
            "",
            "out:",
            "\tkobject_put(&admin->kobj);",
            "\tkobject_put(damon_sysfs_root);",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_sysfs_kdamonds_release, damon_sysfs_ui_dir_add_dirs, damon_sysfs_ui_dir_release, damon_sysfs_init",
          "description": "构建DAMON sysfs层级结构，初始化根目录并注册管理接口。damon_sysfs_init创建\"damon\" sysfs节点，admin目录注册UI控制接口，实现监控实例集合的动态管理与资源释放。",
          "similarity": 0.5363805294036865
        },
        {
          "chunk_id": 2,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 187,
          "end_line": 290,
          "content": [
            "static void damon_sysfs_regions_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_regions, kobj));",
            "}",
            "static int damon_sysfs_target_add_dirs(struct damon_sysfs_target *target)",
            "{",
            "\tstruct damon_sysfs_regions *regions = damon_sysfs_regions_alloc();",
            "\tint err;",
            "",
            "\tif (!regions)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = kobject_init_and_add(&regions->kobj, &damon_sysfs_regions_ktype,",
            "\t\t\t&target->kobj, \"regions\");",
            "\tif (err)",
            "\t\tkobject_put(&regions->kobj);",
            "\telse",
            "\t\ttarget->regions = regions;",
            "\treturn err;",
            "}",
            "static void damon_sysfs_target_rm_dirs(struct damon_sysfs_target *target)",
            "{",
            "\tdamon_sysfs_regions_rm_dirs(target->regions);",
            "\tkobject_put(&target->regions->kobj);",
            "}",
            "static ssize_t pid_target_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct damon_sysfs_target *target = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_target, kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%d\\n\", target->pid);",
            "}",
            "static ssize_t pid_target_store(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_target *target = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_target, kobj);",
            "\tint err = kstrtoint(buf, 0, &target->pid);",
            "",
            "\tif (err)",
            "\t\treturn -EINVAL;",
            "\treturn count;",
            "}",
            "static void damon_sysfs_target_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_target, kobj));",
            "}",
            "static void damon_sysfs_targets_rm_dirs(struct damon_sysfs_targets *targets)",
            "{",
            "\tstruct damon_sysfs_target **targets_arr = targets->targets_arr;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < targets->nr; i++) {",
            "\t\tdamon_sysfs_target_rm_dirs(targets_arr[i]);",
            "\t\tkobject_put(&targets_arr[i]->kobj);",
            "\t}",
            "\ttargets->nr = 0;",
            "\tkfree(targets_arr);",
            "\ttargets->targets_arr = NULL;",
            "}",
            "static int damon_sysfs_targets_add_dirs(struct damon_sysfs_targets *targets,",
            "\t\tint nr_targets)",
            "{",
            "\tstruct damon_sysfs_target **targets_arr, *target;",
            "\tint err, i;",
            "",
            "\tdamon_sysfs_targets_rm_dirs(targets);",
            "\tif (!nr_targets)",
            "\t\treturn 0;",
            "",
            "\ttargets_arr = kmalloc_array(nr_targets, sizeof(*targets_arr),",
            "\t\t\tGFP_KERNEL | __GFP_NOWARN);",
            "\tif (!targets_arr)",
            "\t\treturn -ENOMEM;",
            "\ttargets->targets_arr = targets_arr;",
            "",
            "\tfor (i = 0; i < nr_targets; i++) {",
            "\t\ttarget = damon_sysfs_target_alloc();",
            "\t\tif (!target) {",
            "\t\t\tdamon_sysfs_targets_rm_dirs(targets);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "",
            "\t\terr = kobject_init_and_add(&target->kobj,",
            "\t\t\t\t&damon_sysfs_target_ktype, &targets->kobj,",
            "\t\t\t\t\"%d\", i);",
            "\t\tif (err)",
            "\t\t\tgoto out;",
            "",
            "\t\terr = damon_sysfs_target_add_dirs(target);",
            "\t\tif (err)",
            "\t\t\tgoto out;",
            "",
            "\t\ttargets_arr[i] = target;",
            "\t\ttargets->nr++;",
            "\t}",
            "\treturn 0;",
            "",
            "out:",
            "\tdamon_sysfs_targets_rm_dirs(targets);",
            "\tkobject_put(&target->kobj);",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_sysfs_regions_release, damon_sysfs_target_add_dirs, damon_sysfs_target_rm_dirs, pid_target_show, pid_target_store, damon_sysfs_target_release, damon_sysfs_targets_rm_dirs, damon_sysfs_targets_add_dirs",
          "description": "实现目标进程PID的sysfs读写，管理目标目录的增删，建立进程与监控区域的关联关系。",
          "similarity": 0.5284062623977661
        },
        {
          "chunk_id": 10,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 1462,
          "end_line": 1569,
          "content": [
            "static int damon_sysfs_turn_damon_off(struct damon_sysfs_kdamond *kdamond)",
            "{",
            "\tif (!kdamond->damon_ctx)",
            "\t\treturn -EINVAL;",
            "\treturn damon_stop(&kdamond->damon_ctx, 1);",
            "\t/*",
            "\t * To allow users show final monitoring results of already turned-off",
            "\t * DAMON, we free kdamond->damon_ctx in next",
            "\t * damon_sysfs_turn_damon_on(), or kdamonds_nr_store()",
            "\t */",
            "}",
            "static int damon_sysfs_handle_cmd(enum damon_sysfs_cmd cmd,",
            "\t\tstruct damon_sysfs_kdamond *kdamond)",
            "{",
            "\tbool need_wait = true;",
            "",
            "\t/* Handle commands that doesn't access DAMON context-internal data */",
            "\tswitch (cmd) {",
            "\tcase DAMON_SYSFS_CMD_ON:",
            "\t\treturn damon_sysfs_turn_damon_on(kdamond);",
            "\tcase DAMON_SYSFS_CMD_OFF:",
            "\t\treturn damon_sysfs_turn_damon_off(kdamond);",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\t/* Pass the command to DAMON callback for safe DAMON context access */",
            "\tif (damon_sysfs_cmd_request.kdamond)",
            "\t\treturn -EBUSY;",
            "\tif (!damon_sysfs_kdamond_running(kdamond))",
            "\t\treturn -EINVAL;",
            "\tdamon_sysfs_cmd_request.cmd = cmd;",
            "\tdamon_sysfs_cmd_request.kdamond = kdamond;",
            "",
            "\t/*",
            "\t * wait until damon_sysfs_cmd_request_callback() handles the request",
            "\t * from kdamond context",
            "\t */",
            "\tmutex_unlock(&damon_sysfs_lock);",
            "\twhile (need_wait) {",
            "\t\tschedule_timeout_idle(msecs_to_jiffies(100));",
            "\t\tif (!mutex_trylock(&damon_sysfs_lock))",
            "\t\t\tcontinue;",
            "\t\tif (!damon_sysfs_cmd_request.kdamond) {",
            "\t\t\t/* damon_sysfs_cmd_request_callback() handled */",
            "\t\t\tneed_wait = false;",
            "\t\t} else if (!damon_sysfs_kdamond_running(kdamond)) {",
            "\t\t\t/* kdamond has already finished */",
            "\t\t\tneed_wait = false;",
            "\t\t\tdamon_sysfs_cmd_request.kdamond = NULL;",
            "\t\t}",
            "\t\tmutex_unlock(&damon_sysfs_lock);",
            "\t}",
            "\tmutex_lock(&damon_sysfs_lock);",
            "\treturn 0;",
            "}",
            "static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\tconst char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_kdamond *kdamond = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_kdamond, kobj);",
            "\tenum damon_sysfs_cmd cmd;",
            "\tssize_t ret = -EINVAL;",
            "",
            "\tif (!mutex_trylock(&damon_sysfs_lock))",
            "\t\treturn -EBUSY;",
            "\tfor (cmd = 0; cmd < NR_DAMON_SYSFS_CMDS; cmd++) {",
            "\t\tif (sysfs_streq(buf, damon_sysfs_cmd_strs[cmd])) {",
            "\t\t\tret = damon_sysfs_handle_cmd(cmd, kdamond);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&damon_sysfs_lock);",
            "\tif (!ret)",
            "\t\tret = count;",
            "\treturn ret;",
            "}",
            "static ssize_t pid_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct damon_sysfs_kdamond *kdamond = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_kdamond, kobj);",
            "\tstruct damon_ctx *ctx;",
            "\tint pid = -1;",
            "",
            "\tif (!mutex_trylock(&damon_sysfs_lock))",
            "\t\treturn -EBUSY;",
            "\tctx = kdamond->damon_ctx;",
            "\tif (!ctx)",
            "\t\tgoto out;",
            "",
            "\tmutex_lock(&ctx->kdamond_lock);",
            "\tif (ctx->kdamond)",
            "\t\tpid = ctx->kdamond->pid;",
            "\tmutex_unlock(&ctx->kdamond_lock);",
            "out:",
            "\tmutex_unlock(&damon_sysfs_lock);",
            "\treturn sysfs_emit(buf, \"%d\\n\", pid);",
            "}",
            "static void damon_sysfs_kdamond_release(struct kobject *kobj)",
            "{",
            "\tstruct damon_sysfs_kdamond *kdamond = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_kdamond, kobj);",
            "",
            "\tif (kdamond->damon_ctx)",
            "\t\tdamon_destroy_ctx(kdamond->damon_ctx);",
            "\tkfree(kdamond);",
            "}"
          ],
          "function_name": "damon_sysfs_turn_damon_off, damon_sysfs_handle_cmd, state_store, pid_show, damon_sysfs_kdamond_release",
          "description": "实现DAMON系统控制接口，提供开关监控、命令处理及状态存储功能。damon_sysfs_turn_damon_off停止监控上下文并释放资源，handle_cmd分发控制命令至安全回调，state_store通过sysfs接口更新监控状态。",
          "similarity": 0.49410420656204224
        }
      ]
    },
    {
      "source_file": "kernel/bpf/inode.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:12:33\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\inode.c`\n\n---\n\n# `bpf/inode.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/inode.c` 实现了一个轻量级的虚拟文件系统（称为 **bpffs**），用于支持 eBPF 对象（包括 BPF 程序、映射和链接）的 **pinning（持久化）机制**。该文件系统允许用户空间通过标准文件系统操作（如 `mkdir`、`create`、`unlink` 等）将 BPF 对象绑定到文件系统路径，从而在进程退出后仍能保持对这些对象的引用，避免被内核自动释放。此机制是 `bpf(2)` 系统调用中 `BPF_OBJ_PIN` 和 `BPF_OBJ_GET` 功能的后端支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `enum bpf_type`：枚举类型，标识 BPF 对象类型（`BPF_TYPE_PROG`、`BPF_TYPE_MAP`、`BPF_TYPE_LINK`）。\n- `struct map_iter`：用于 BPF map 序列化遍历的迭代器结构，包含当前 key 和完成标志。\n- `const struct inode_operations`：分别为目录、程序、映射、链接定义的 inode 操作集合（`bpf_dir_iops`、`bpf_prog_iops` 等）。\n- `const struct file_operations`：\n  - `bpffs_map_fops`：支持对支持 `seq_show` 的 BPF map 进行 `cat` 读取。\n  - `bpffs_obj_fops`：通用只读文件操作，打开即返回 `-EIO`，防止误操作。\n\n### 主要函数\n\n- `bpf_any_get()` / `bpf_any_put()`：根据对象类型统一增加/减少引用计数。\n- `bpf_fd_probe_obj()`：通过文件描述符探测并获取对应的 BPF 对象及其类型。\n- `bpf_get_inode()`：为 bpffs 创建新的 inode（支持目录、普通文件、符号链接）。\n- `bpf_inode_type()`：根据 inode 的 `i_op` 字段反推其对应的 BPF 对象类型。\n- `bpf_dentry_finalize()`：完成 dentry 与 inode 的绑定并更新父目录时间戳。\n- `bpf_mkdir()`：实现 bpffs 中的目录创建。\n- `bpf_mkprog()` / `bpf_mkmap()` / `bpf_mklink()`：分别创建 BPF 程序、映射、链接对应的文件 inode。\n- `map_iter_alloc()` / `map_iter_free()`：管理 map 遍历迭代器的生命周期。\n- `map_seq_*` 系列函数：实现 BPF map 的 `seq_file` 遍历接口，用于 `cat` 输出。\n- `bpffs_map_open()` / `bpffs_map_release()`：map 文件的打开与释放，初始化 seq_file 上下文。\n- `bpf_lookup()`：自定义 lookup 逻辑，禁止文件名中包含 `.`（保留用于未来扩展）。\n\n## 3. 关键实现\n\n### BPF 对象引用管理\n通过 `bpf_any_get()` 和 `bpf_any_put()` 封装不同 BPF 对象（prog/map/link）的引用计数操作，确保在 inode 创建和销毁时正确持有/释放内核对象，防止内存泄漏或提前释放。\n\n### 对象类型识别\n利用 `inode->i_op` 指针的唯一性（分别指向 `bpf_prog_iops`、`bpf_map_iops` 等空结构体）作为类型标签，在运行时通过指针比较快速判断 inode 对应的 BPF 对象类型。\n\n### BPF Map 的可读性支持\n对于支持 `map_seq_show_elem` 操作的 BPF map（如 hash、array 等），通过 `seq_file` 机制实现 `cat /sys/fs/bpf/map_name` 输出内容。输出包含警告信息，强调格式不稳定，仅用于调试。\n\n### 安全与扩展性设计\n- 文件名中禁止出现 `.` 字符（如 `foo.bar`），为未来在 bpffs 中引入特殊文件（如元数据、控制接口）预留命名空间。\n- 普通 BPF 对象文件（prog/link 或不支持 seq_show 的 map）使用 `bpffs_obj_fops`，其 `open` 返回 `-EIO`，防止用户误读/误写导致未定义行为。\n\n### 虚拟文件系统集成\n基于 `simple_fs` 框架（如 `simple_dir_operations`、`simple_lookup`）构建，仅重写必要操作（如 `mkdir`、`lookup`、`create` 逻辑由上层调用 `bpf_mk*` 实现），保持代码简洁。\n\n## 4. 依赖关系\n\n- **BPF 子系统核心**：依赖 `<linux/bpf.h>`、`<linux/filter.h>` 提供的 `bpf_prog_*`、`bpf_map_*`、`bpf_link_*` 等核心 API。\n- **VFS 层**：依赖标准 VFS 接口（`<linux/fs.h>`、`<linux/namei.h>`、`<linux/dcache.h>`）实现 inode、dentry、file 操作。\n- **预加载机制**：包含 `\"preload/bpf_preload.h\"`，可能用于内核启动时预加载 BPF 对象。\n- **迭代器支持**：若 BPF link 为 iterator 类型，会使用 `bpf_iter_fops`（定义在其他文件中）。\n\n## 5. 使用场景\n\n- **BPF 对象持久化**：用户空间工具（如 `bpftool`）调用 `bpf(BPF_OBJ_PIN, ...)` 将 map/prog/link pin 到 `/sys/fs/bpf/` 下的路径，内核通过本文件创建对应 inode 并持有对象引用。\n- **跨进程共享 BPF 对象**：多个进程可通过 `bpf(BPF_OBJ_GET, ...)` 从同一 bpffs 路径获取已 pin 对象的 fd，实现共享。\n- **调试与可观测性**：支持 `seq_show` 的 map 可通过 `cat` 命令查看内容，辅助开发调试（注意：非稳定接口）。\n- **系统启动预加载**：结合 `bpf_preload` 机制，在内核初始化阶段将关键 BPF 程序/映射 pin 到 bpffs，供后续服务使用。",
      "similarity": 0.5599342584609985,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 680,
          "end_line": 783,
          "content": [
            "static void seq_print_delegate_opts(struct seq_file *m,",
            "\t\t\t\t    const char *opt_name,",
            "\t\t\t\t    const struct btf *btf,",
            "\t\t\t\t    const struct btf_type *enum_t,",
            "\t\t\t\t    const char *prefix,",
            "\t\t\t\t    u64 delegate_msk, u64 any_msk)",
            "{",
            "\tconst struct btf_enum *e;",
            "\tbool first = true;",
            "\tconst char *name;",
            "\tu64 msk;",
            "\tint i, n, pfx_len = strlen(prefix);",
            "",
            "\tdelegate_msk &= any_msk; /* clear unknown bits */",
            "",
            "\tif (delegate_msk == 0)",
            "\t\treturn;",
            "",
            "\tseq_printf(m, \",%s\", opt_name);",
            "\tif (delegate_msk == any_msk) {",
            "\t\tseq_printf(m, \"=any\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (btf && enum_t) {",
            "\t\tfor (i = 0, n = btf_vlen(enum_t); i < n; i++) {",
            "\t\t\te = &btf_enum(enum_t)[i];",
            "\t\t\tname = btf_name_by_offset(btf, e->name_off);",
            "\t\t\tif (!name || strncasecmp(name, prefix, pfx_len) != 0)",
            "\t\t\t\tcontinue;",
            "\t\t\tmsk = 1ULL << e->val;",
            "\t\t\tif (delegate_msk & msk) {",
            "\t\t\t\t/* emit lower-case name without prefix */",
            "\t\t\t\tseq_printf(m, \"%c\", first ? '=' : ':');",
            "\t\t\t\tname += pfx_len;",
            "\t\t\t\twhile (*name) {",
            "\t\t\t\t\tseq_printf(m, \"%c\", tolower(*name));",
            "\t\t\t\t\tname++;",
            "\t\t\t\t}",
            "",
            "\t\t\t\tdelegate_msk &= ~msk;",
            "\t\t\t\tfirst = false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif (delegate_msk)",
            "\t\tseq_printf(m, \"%c0x%llx\", first ? '=' : ':', delegate_msk);",
            "}",
            "static int bpf_show_options(struct seq_file *m, struct dentry *root)",
            "{",
            "\tstruct inode *inode = d_inode(root);",
            "\tumode_t mode = inode->i_mode & S_IALLUGO & ~S_ISVTX;",
            "\tstruct bpf_mount_opts *opts = root->d_sb->s_fs_info;",
            "\tu64 mask;",
            "",
            "\tif (!uid_eq(inode->i_uid, GLOBAL_ROOT_UID))",
            "\t\tseq_printf(m, \",uid=%u\",",
            "\t\t\t   from_kuid_munged(&init_user_ns, inode->i_uid));",
            "\tif (!gid_eq(inode->i_gid, GLOBAL_ROOT_GID))",
            "\t\tseq_printf(m, \",gid=%u\",",
            "\t\t\t   from_kgid_munged(&init_user_ns, inode->i_gid));",
            "\tif (mode != S_IRWXUGO)",
            "\t\tseq_printf(m, \",mode=%o\", mode);",
            "",
            "\tif (opts->delegate_cmds || opts->delegate_maps ||",
            "\t    opts->delegate_progs || opts->delegate_attachs) {",
            "\t\tstruct bpffs_btf_enums info;",
            "",
            "\t\t/* ignore errors, fallback to hex */",
            "\t\t(void)find_bpffs_btf_enums(&info);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_cmds\",",
            "\t\t\t\t\tinfo.btf, info.cmd_t, \"BPF_\",",
            "\t\t\t\t\topts->delegate_cmds, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_maps\",",
            "\t\t\t\t\tinfo.btf, info.map_t, \"BPF_MAP_TYPE_\",",
            "\t\t\t\t\topts->delegate_maps, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_progs\",",
            "\t\t\t\t\tinfo.btf, info.prog_t, \"BPF_PROG_TYPE_\",",
            "\t\t\t\t\topts->delegate_progs, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_attachs\",",
            "\t\t\t\t\tinfo.btf, info.attach_t, \"BPF_\",",
            "\t\t\t\t\topts->delegate_attachs, mask);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_free_inode(struct inode *inode)",
            "{",
            "\tenum bpf_type type;",
            "",
            "\tif (S_ISLNK(inode->i_mode))",
            "\t\tkfree(inode->i_link);",
            "\tif (!bpf_inode_type(inode, &type))",
            "\t\tbpf_any_put(inode->i_private, type);",
            "\tfree_inode_nonrcu(inode);",
            "}"
          ],
          "function_name": "seq_print_delegate_opts, bpf_show_options, bpf_free_inode",
          "description": "展示文件系统挂载参数，处理委托选项打印及inode释放时的资源回收操作",
          "similarity": 0.5673365592956543
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 53,
          "end_line": 155,
          "content": [
            "static void bpf_any_put(void *raw, enum bpf_type type)",
            "{",
            "\tswitch (type) {",
            "\tcase BPF_TYPE_PROG:",
            "\t\tbpf_prog_put(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_MAP:",
            "\t\tbpf_map_put_with_uref(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_LINK:",
            "\t\tbpf_link_put(raw);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "}",
            "static int bpf_inode_type(const struct inode *inode, enum bpf_type *type)",
            "{",
            "\t*type = BPF_TYPE_UNSPEC;",
            "\tif (inode->i_op == &bpf_prog_iops)",
            "\t\t*type = BPF_TYPE_PROG;",
            "\telse if (inode->i_op == &bpf_map_iops)",
            "\t\t*type = BPF_TYPE_MAP;",
            "\telse if (inode->i_op == &bpf_link_iops)",
            "\t\t*type = BPF_TYPE_LINK;",
            "\telse",
            "\t\treturn -EACCES;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,",
            "\t\t\t\tstruct inode *dir)",
            "{",
            "\td_instantiate(dentry, inode);",
            "\tdget(dentry);",
            "",
            "\tdir->i_mtime = inode_set_ctime_current(dir);",
            "}",
            "static int bpf_mkdir(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t     struct dentry *dentry, umode_t mode)",
            "{",
            "\tstruct inode *inode;",
            "",
            "\tinode = bpf_get_inode(dir->i_sb, dir, mode | S_IFDIR);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_dir_iops;",
            "\tinode->i_fop = &simple_dir_operations;",
            "",
            "\tinc_nlink(inode);",
            "\tinc_nlink(dir);",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static void map_iter_free(struct map_iter *iter)",
            "{",
            "\tif (iter) {",
            "\t\tkfree(iter->key);",
            "\t\tkfree(iter);",
            "\t}",
            "}",
            "static void map_seq_stop(struct seq_file *m, void *v)",
            "{",
            "}",
            "static int map_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct bpf_map *map = seq_file_to_map(m);",
            "\tvoid *key = map_iter(m)->key;",
            "",
            "\tif (unlikely(v == SEQ_START_TOKEN)) {",
            "\t\tseq_puts(m, \"# WARNING!! The output is for debug purpose only\\n\");",
            "\t\tseq_puts(m, \"# WARNING!! The output format will change\\n\");",
            "\t} else {",
            "\t\tmap->ops->map_seq_show_elem(map, key, m);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int bpffs_map_open(struct inode *inode, struct file *file)",
            "{",
            "\tstruct bpf_map *map = inode->i_private;",
            "\tstruct map_iter *iter;",
            "\tstruct seq_file *m;",
            "\tint err;",
            "",
            "\titer = map_iter_alloc(map);",
            "\tif (!iter)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = seq_open(file, &bpffs_map_seq_ops);",
            "\tif (err) {",
            "\t\tmap_iter_free(iter);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tm = file->private_data;",
            "\tm->private = iter;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_any_put, bpf_inode_type, bpf_dentry_finalize, bpf_mkdir, map_iter_free, map_seq_stop, map_seq_show, bpffs_map_open",
          "description": "实现BPF对象引用释放逻辑，inode类型识别，目录创建，迭代器管理及序列化展示功能",
          "similarity": 0.5262347459793091
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 948,
          "end_line": 1061,
          "content": [
            "static bool bpf_preload_mod_get(void)",
            "{",
            "\t/* If bpf_preload.ko wasn't loaded earlier then load it now.",
            "\t * When bpf_preload is built into vmlinux the module's __init",
            "\t * function will populate it.",
            "\t */",
            "\tif (!bpf_preload_ops) {",
            "\t\trequest_module(\"bpf_preload\");",
            "\t\tif (!bpf_preload_ops)",
            "\t\t\treturn false;",
            "\t}",
            "\t/* And grab the reference, so the module doesn't disappear while the",
            "\t * kernel is interacting with the kernel module and its UMD.",
            "\t */",
            "\tif (!try_module_get(bpf_preload_ops->owner)) {",
            "\t\tpr_err(\"bpf_preload module get failed.\\n\");",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void bpf_preload_mod_put(void)",
            "{",
            "\tif (bpf_preload_ops)",
            "\t\t/* now user can \"rmmod bpf_preload\" if necessary */",
            "\t\tmodule_put(bpf_preload_ops->owner);",
            "}",
            "static int populate_bpffs(struct dentry *parent)",
            "{",
            "\tstruct bpf_preload_info objs[BPF_PRELOAD_LINKS] = {};",
            "\tint err = 0, i;",
            "",
            "\t/* grab the mutex to make sure the kernel interactions with bpf_preload",
            "\t * are serialized",
            "\t */",
            "\tmutex_lock(&bpf_preload_lock);",
            "",
            "\t/* if bpf_preload.ko wasn't built into vmlinux then load it */",
            "\tif (!bpf_preload_mod_get())",
            "\t\tgoto out;",
            "",
            "\terr = bpf_preload_ops->preload(objs);",
            "\tif (err)",
            "\t\tgoto out_put;",
            "\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {",
            "\t\tbpf_link_inc(objs[i].link);",
            "\t\terr = bpf_iter_link_pin_kernel(parent,",
            "\t\t\t\t\t       objs[i].link_name, objs[i].link);",
            "\t\tif (err) {",
            "\t\t\tbpf_link_put(objs[i].link);",
            "\t\t\tgoto out_put;",
            "\t\t}",
            "\t}",
            "out_put:",
            "\tbpf_preload_mod_put();",
            "out:",
            "\tmutex_unlock(&bpf_preload_lock);",
            "\treturn err;",
            "}",
            "static int bpf_fill_super(struct super_block *sb, struct fs_context *fc)",
            "{",
            "\tstatic const struct tree_descr bpf_rfiles[] = { { \"\" } };",
            "\tstruct bpf_mount_opts *opts = sb->s_fs_info;",
            "\tstruct inode *inode;",
            "\tint ret;",
            "",
            "\t/* Mounting an instance of BPF FS requires privileges */",
            "\tif (fc->user_ns != &init_user_ns && !capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tret = simple_fill_super(sb, BPF_FS_MAGIC, bpf_rfiles);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tsb->s_op = &bpf_super_ops;",
            "",
            "\tinode = sb->s_root->d_inode;",
            "\tinode->i_uid = opts->uid;",
            "\tinode->i_gid = opts->gid;",
            "\tinode->i_op = &bpf_dir_iops;",
            "\tinode->i_mode &= ~S_IALLUGO;",
            "\tpopulate_bpffs(sb->s_root);",
            "\tinode->i_mode |= S_ISVTX | opts->mode;",
            "\treturn 0;",
            "}",
            "static int bpf_get_tree(struct fs_context *fc)",
            "{",
            "\treturn get_tree_nodev(fc, bpf_fill_super);",
            "}",
            "static void bpf_free_fc(struct fs_context *fc)",
            "{",
            "\tkfree(fc->s_fs_info);",
            "}",
            "static int bpf_init_fs_context(struct fs_context *fc)",
            "{",
            "\tstruct bpf_mount_opts *opts;",
            "",
            "\topts = kzalloc(sizeof(struct bpf_mount_opts), GFP_KERNEL);",
            "\tif (!opts)",
            "\t\treturn -ENOMEM;",
            "",
            "\topts->mode = S_IRWXUGO;",
            "\topts->uid = current_fsuid();",
            "\topts->gid = current_fsgid();",
            "",
            "\t/* start out with no BPF token delegation enabled */",
            "\topts->delegate_cmds = 0;",
            "\topts->delegate_maps = 0;",
            "\topts->delegate_progs = 0;",
            "\topts->delegate_attachs = 0;",
            "",
            "\tfc->s_fs_info = opts;",
            "\tfc->ops = &bpf_context_ops;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_preload_mod_get, bpf_preload_mod_put, populate_bpffs, bpf_fill_super, bpf_get_tree, bpf_free_fc, bpf_init_fs_context",
          "description": "管理BPF预加载模块引用计数，填充BPF文件系统超级块数据，初始化文件系统上下文并设置默认挂载选项",
          "similarity": 0.5125528573989868
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 479,
          "end_line": 593,
          "content": [
            "int bpf_obj_pin_user(u32 ufd, int path_fd, const char __user *pathname)",
            "{",
            "\tenum bpf_type type;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\traw = bpf_fd_probe_obj(ufd, &type);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tret = bpf_obj_do_pin(path_fd, pathname, raw, type);",
            "\tif (ret != 0)",
            "\t\tbpf_any_put(raw, type);",
            "",
            "\treturn ret;",
            "}",
            "int bpf_obj_get_user(int path_fd, const char __user *pathname, int flags)",
            "{",
            "\tenum bpf_type type = BPF_TYPE_UNSPEC;",
            "\tint f_flags;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\tf_flags = bpf_get_file_flag(flags);",
            "\tif (f_flags < 0)",
            "\t\treturn f_flags;",
            "",
            "\traw = bpf_obj_do_get(path_fd, pathname, &type, f_flags);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tif (type == BPF_TYPE_PROG)",
            "\t\tret = bpf_prog_new_fd(raw);",
            "\telse if (type == BPF_TYPE_MAP)",
            "\t\tret = bpf_map_new_fd(raw, f_flags);",
            "\telse if (type == BPF_TYPE_LINK)",
            "\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);",
            "\telse",
            "\t\treturn -ENOENT;",
            "",
            "\tif (ret < 0)",
            "\t\tbpf_any_put(raw, type);",
            "\treturn ret;",
            "}",
            "static int find_bpffs_btf_enums(struct bpffs_btf_enums *info)",
            "{",
            "\tconst struct btf *btf;",
            "\tconst struct btf_type *t;",
            "\tconst char *name;",
            "\tint i, n;",
            "",
            "\tmemset(info, 0, sizeof(*info));",
            "",
            "\tbtf = bpf_get_btf_vmlinux();",
            "\tif (IS_ERR(btf))",
            "\t\treturn PTR_ERR(btf);",
            "\tif (!btf)",
            "\t\treturn -ENOENT;",
            "",
            "\tinfo->btf = btf;",
            "",
            "\tfor (i = 1, n = btf_nr_types(btf); i < n; i++) {",
            "\t\tt = btf_type_by_id(btf, i);",
            "\t\tif (!btf_type_is_enum(t))",
            "\t\t\tcontinue;",
            "",
            "\t\tname = btf_name_by_offset(btf, t->name_off);",
            "\t\tif (!name)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (strcmp(name, \"bpf_cmd\") == 0)",
            "\t\t\tinfo->cmd_t = t;",
            "\t\telse if (strcmp(name, \"bpf_map_type\") == 0)",
            "\t\t\tinfo->map_t = t;",
            "\t\telse if (strcmp(name, \"bpf_prog_type\") == 0)",
            "\t\t\tinfo->prog_t = t;",
            "\t\telse if (strcmp(name, \"bpf_attach_type\") == 0)",
            "\t\t\tinfo->attach_t = t;",
            "\t\telse",
            "\t\t\tcontinue;",
            "",
            "\t\tif (info->cmd_t && info->map_t && info->prog_t && info->attach_t)",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\treturn -ESRCH;",
            "}",
            "static bool find_btf_enum_const(const struct btf *btf, const struct btf_type *enum_t,",
            "\t\t\t\tconst char *prefix, const char *str, int *value)",
            "{",
            "\tconst struct btf_enum *e;",
            "\tconst char *name;",
            "\tint i, n, pfx_len = strlen(prefix);",
            "",
            "\t*value = 0;",
            "",
            "\tif (!btf || !enum_t)",
            "\t\treturn false;",
            "",
            "\tfor (i = 0, n = btf_vlen(enum_t); i < n; i++) {",
            "\t\te = &btf_enum(enum_t)[i];",
            "",
            "\t\tname = btf_name_by_offset(btf, e->name_off);",
            "\t\tif (!name || strncasecmp(name, prefix, pfx_len) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* match symbolic name case insensitive and ignoring prefix */",
            "\t\tif (strcasecmp(name + pfx_len, str) == 0) {",
            "\t\t\t*value = e->val;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "bpf_obj_pin_user, bpf_obj_get_user, find_bpffs_btf_enums, find_btf_enum_const",
          "description": "实现用户空间对象pin操作，对象获取逻辑及BTF枚举常量解析功能",
          "similarity": 0.5063323974609375
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 818,
          "end_line": 943,
          "content": [
            "static int bpf_parse_param(struct fs_context *fc, struct fs_parameter *param)",
            "{",
            "\tstruct bpf_mount_opts *opts = fc->s_fs_info;",
            "\tstruct fs_parse_result result;",
            "\tkuid_t uid;",
            "\tkgid_t gid;",
            "\tint opt, err;",
            "",
            "\topt = fs_parse(fc, bpf_fs_parameters, param, &result);",
            "\tif (opt < 0) {",
            "\t\t/* We might like to report bad mount options here, but",
            "\t\t * traditionally we've ignored all mount options, so we'd",
            "\t\t * better continue to ignore non-existing options for bpf.",
            "\t\t */",
            "\t\tif (opt == -ENOPARAM) {",
            "\t\t\topt = vfs_parse_fs_param_source(fc, param);",
            "\t\t\tif (opt != -ENOPARAM)",
            "\t\t\t\treturn opt;",
            "",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\tif (opt < 0)",
            "\t\t\treturn opt;",
            "\t}",
            "",
            "\tswitch (opt) {",
            "\tcase OPT_UID:",
            "\t\tuid = make_kuid(current_user_ns(), result.uint_32);",
            "\t\tif (!uid_valid(uid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\t/*",
            "\t\t * The requested uid must be representable in the",
            "\t\t * filesystem's idmapping.",
            "\t\t */",
            "\t\tif (!kuid_has_mapping(fc->user_ns, uid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\topts->uid = uid;",
            "\t\tbreak;",
            "\tcase OPT_GID:",
            "\t\tgid = make_kgid(current_user_ns(), result.uint_32);",
            "\t\tif (!gid_valid(gid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\t/*",
            "\t\t * The requested gid must be representable in the",
            "\t\t * filesystem's idmapping.",
            "\t\t */",
            "\t\tif (!kgid_has_mapping(fc->user_ns, gid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\topts->gid = gid;",
            "\t\tbreak;",
            "\tcase OPT_MODE:",
            "\t\topts->mode = result.uint_32 & S_IALLUGO;",
            "\t\tbreak;",
            "\tcase OPT_DELEGATE_CMDS:",
            "\tcase OPT_DELEGATE_MAPS:",
            "\tcase OPT_DELEGATE_PROGS:",
            "\tcase OPT_DELEGATE_ATTACHS: {",
            "\t\tstruct bpffs_btf_enums info;",
            "\t\tconst struct btf_type *enum_t;",
            "\t\tconst char *enum_pfx;",
            "\t\tu64 *delegate_msk, msk = 0;",
            "\t\tchar *p, *str;",
            "\t\tint val;",
            "",
            "\t\t/* ignore errors, fallback to hex */",
            "\t\t(void)find_bpffs_btf_enums(&info);",
            "",
            "\t\tswitch (opt) {",
            "\t\tcase OPT_DELEGATE_CMDS:",
            "\t\t\tdelegate_msk = &opts->delegate_cmds;",
            "\t\t\tenum_t = info.cmd_t;",
            "\t\t\tenum_pfx = \"BPF_\";",
            "\t\t\tbreak;",
            "\t\tcase OPT_DELEGATE_MAPS:",
            "\t\t\tdelegate_msk = &opts->delegate_maps;",
            "\t\t\tenum_t = info.map_t;",
            "\t\t\tenum_pfx = \"BPF_MAP_TYPE_\";",
            "\t\t\tbreak;",
            "\t\tcase OPT_DELEGATE_PROGS:",
            "\t\t\tdelegate_msk = &opts->delegate_progs;",
            "\t\t\tenum_t = info.prog_t;",
            "\t\t\tenum_pfx = \"BPF_PROG_TYPE_\";",
            "\t\t\tbreak;",
            "\t\tcase OPT_DELEGATE_ATTACHS:",
            "\t\t\tdelegate_msk = &opts->delegate_attachs;",
            "\t\t\tenum_t = info.attach_t;",
            "\t\t\tenum_pfx = \"BPF_\";",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tstr = param->string;",
            "\t\twhile ((p = strsep(&str, \":\"))) {",
            "\t\t\tif (strcmp(p, \"any\") == 0) {",
            "\t\t\t\tmsk |= ~0ULL;",
            "\t\t\t} else if (find_btf_enum_const(info.btf, enum_t, enum_pfx, p, &val)) {",
            "\t\t\t\tmsk |= 1ULL << val;",
            "\t\t\t} else {",
            "\t\t\t\terr = kstrtou64(p, 0, &msk);",
            "\t\t\t\tif (err)",
            "\t\t\t\t\treturn err;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/* Setting delegation mount options requires privileges */",
            "\t\tif (msk && !capable(CAP_SYS_ADMIN))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t*delegate_msk |= msk;",
            "\t\tbreak;",
            "\t}",
            "\tdefault:",
            "\t\t/* ignore unknown mount options */",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn 0;",
            "bad_value:",
            "\treturn invalfc(fc, \"Bad value for '%s'\", param->key);",
            "}"
          ],
          "function_name": "bpf_parse_param",
          "description": "解析并验证BPF文件系统的挂载参数，处理UID/GID/模式及委托选项，检查值的有效性并设置到mount选项结构体中",
          "similarity": 0.5041860342025757
        }
      ]
    }
  ]
}