{
  "query": "调度函数schedule()实现细节",
  "timestamp": "2025-12-25 23:24:02",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/deadline.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:06:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\deadline.c`\n\n---\n\n# `sched/deadline.c` 技术文档\n\n## 1. 文件概述\n\n`sched/deadline.c` 是 Linux 内核调度器中 **SCHED_DEADLINE** 调度类的核心实现文件。该调度类基于 **最早截止时间优先（Earliest Deadline First, EDF）** 算法，并结合 **恒定带宽服务器（Constant Bandwidth Server, CBS）** 机制，为具有严格实时性要求的任务提供可预测的调度保障。\n\n其核心目标是：  \n- 对于周期性任务，若其实际运行时间不超过所申请的运行时间（runtime），则保证不会错过任何截止时间（deadline）；  \n- 对于非周期性任务、突发任务或试图超出其预留带宽的任务，系统会对其进行节流（throttling），防止其影响其他任务的实时性保障。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct sched_dl_entity`：表示一个 deadline 调度实体，包含任务的运行时间（runtime）、截止期限（deadline）、周期（period）、带宽（dl_bw）等关键参数。\n- `struct dl_rq`：每个 CPU 的 deadline 运行队列，维护该 CPU 上所有 deadline 任务的红黑树、当前带宽使用情况（`this_bw`、`running_bw`）等。\n- `struct dl_bw`：deadline 带宽管理结构，用于跟踪系统或调度域中已分配的总带宽（`total_bw`）。\n\n### 主要函数与辅助宏\n\n#### 调度实体与运行队列关联\n- `dl_task_of(dl_se)`：从 `sched_dl_entity` 获取对应的 `task_struct`（仅适用于普通任务，不适用于服务器实体）。\n- `rq_of_dl_rq(dl_rq)` / `rq_of_dl_se(dl_se)`：获取与 deadline 运行队列或调度实体关联的 `rq`（runqueue）。\n- `dl_rq_of_se(dl_se)`：获取调度实体所属的 `dl_rq`。\n- `on_dl_rq(dl_se)`：判断调度实体是否已在 deadline 运行队列中（通过红黑树节点是否为空判断）。\n\n#### 优先级继承（PI）支持（`CONFIG_RT_MUTEXES`）\n- `pi_of(dl_se)`：获取当前调度实体因优先级继承而提升后的“代理”实体。\n- `is_dl_boosted(dl_se)`：判断该 deadline 实体是否因优先级继承被提升。\n\n#### 带宽管理（SMP 与 UP 差异处理）\n- `dl_bw_of(cpu)`：获取指定 CPU 所属调度域（或本地）的 `dl_bw` 结构。\n- `dl_bw_cpus(cpu)`：返回该 CPU 所在调度域中活跃 CPU 的数量。\n- `dl_bw_capacity(cpu)`：计算调度域的总 CPU 容量（考虑异构 CPU 的 `arch_scale_cpu_capacity`）。\n- `__dl_add()` / `__dl_sub()`：向带宽池中添加或移除任务带宽，并更新 `extra_bw`（用于负载均衡）。\n- `__dl_overflow()`：检查新增带宽是否超出系统/调度域的可用带宽上限。\n\n#### 运行时带宽跟踪\n- `__add_running_bw()` / `__sub_running_bw()`：更新 `dl_rq->running_bw`（当前正在运行的 deadline 任务所消耗的带宽）。\n- `__add_rq_bw()` / `__sub_rq_bw()`：更新 `dl_rq->this_bw`（该运行队列上所有 deadline 任务的总预留带宽）。\n- `add_running_bw()` / `sub_running_bw()` / `add_rq_bw()` / `sub_rq_bw()`：带宽操作的封装，跳过“特殊”调度实体（如服务器）。\n\n#### 其他\n- `dl_server(dl_se)`：判断调度实体是否为 CBS 服务器（而非普通任务）。\n- `dl_bw_visited(cpu, gen)`：用于带宽遍历去重（SMP 场景）。\n\n### 系统控制接口（`CONFIG_SYSCTL`）\n- `sched_deadline_period_max_us`：deadline 任务周期上限（默认 ~4 秒）。\n- `sched_deadline_period_min_us`：deadline 任务周期下限（默认 100 微秒），防止定时器 DoS。\n\n## 3. 关键实现\n\n### EDF + CBS 调度模型\n- 每个 deadline 任务通过 `runtime`、`deadline`、`period` 三个参数定义其资源需求。\n- 调度器按 **绝对截止时间（absolute deadline）** 对任务排序，使用红黑树实现 O(log n) 的调度决策。\n- CBS 机制确保任务即使突发执行，也不会长期占用超过其 `runtime/period` 的 CPU 带宽，超限任务会被 throttled。\n\n### 带宽隔离与全局限制\n- 在 SMP 系统中，deadline 带宽按 **调度域（root domain）** 进行管理，防止跨 CPU 的带宽滥用。\n- 总带宽限制默认为 CPU 总容量的 95%（由 `sysctl_sched_util_clamp_min` 等机制间接控制，具体限制逻辑在带宽分配函数中体现）。\n- `dl_bw->total_bw` 跟踪已分配带宽，`__dl_overflow()` 用于在任务加入时检查是否超限。\n\n### 异构 CPU 支持\n- 通过 `arch_scale_cpu_capacity()` 获取每个 CPU 的相对性能权重。\n- `dl_bw_capacity()` 在异构系统中返回调度域内所有活跃 CPU 的容量总和，用于带宽比例计算（`cap_scale()`）。\n\n### 与 cpufreq 集成\n- 每次 `running_bw` 变化时调用 `cpufreq_update_util()`，通知 CPU 频率调节器当前 deadline 负载，确保满足实时性能需求。\n\n### 优先级继承（PI）\n- 当 deadline 任务因持有 mutex 而阻塞高优先级任务时，通过 `pi_se` 字段临时提升其调度参数，避免优先级反转。\n\n## 4. 依赖关系\n\n- **核心调度框架**：依赖 `kernel/sched/sched.h` 中定义的通用调度结构（如 `rq`、`task_struct`）和宏（如 `SCHED_CAPACITY_SCALE`）。\n- **CPU 拓扑与容量**：依赖 `arch_scale_cpu_capacity()`（由各架构实现）获取 CPU 性能信息。\n- **RCU 机制**：在 SMP 路径中大量使用 `rcu_read_lock_sched_held()` 进行锁依赖检查。\n- **cpufreq 子系统**：通过 `cpufreq_update_util()` 与 CPU 频率调节器交互。\n- **实时互斥锁**：`CONFIG_RT_MUTEXES` 启用时，支持 deadline 任务的优先级继承。\n- **Sysctl 接口**：`CONFIG_SYSCTL` 启用时，提供用户空间可调的 deadline 参数。\n\n## 5. 使用场景\n\n- **工业实时控制**：如机器人控制、数控机床等需要严格周期性和低延迟响应的场景。\n- **音视频处理**：专业音视频采集、编码、播放等对 jitter 敏感的应用。\n- **电信基础设施**：5G 基站、核心网网元中的高优先级信令处理。\n- **汽车电子**：ADAS、自动驾驶系统中的关键任务调度。\n- **科研与高性能计算**：需要确定性执行时间的实验或仿真任务。\n\n用户通过 `sched_setattr(2)` 系统调用设置任务的 `SCHED_DEADLINE` 策略及对应的 `runtime`、`deadline`、`period` 参数，内核则通过本文件实现的调度逻辑确保其满足实时性约束。",
      "similarity": 0.6148144006729126,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 48,
          "end_line": 151,
          "content": [
            "static int __init sched_dl_sysctl_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", sched_dl_sysctls);",
            "\treturn 0;",
            "}",
            "static bool dl_server(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn dl_se->dl_server;",
            "}",
            "static inline int on_dl_rq(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn !RB_EMPTY_NODE(&dl_se->rb_node);",
            "}",
            "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn pi_of(dl_se) != dl_se;",
            "}",
            "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn false;",
            "}",
            "static inline int dl_bw_cpus(int i)",
            "{",
            "\tstruct root_domain *rd = cpu_rq(i)->rd;",
            "\tint cpus;",
            "",
            "\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),",
            "\t\t\t \"sched RCU must be held\");",
            "",
            "\tif (cpumask_subset(rd->span, cpu_active_mask))",
            "\t\treturn cpumask_weight(rd->span);",
            "",
            "\tcpus = 0;",
            "",
            "\tfor_each_cpu_and(i, rd->span, cpu_active_mask)",
            "\t\tcpus++;",
            "",
            "\treturn cpus;",
            "}",
            "static inline unsigned long __dl_bw_capacity(const struct cpumask *mask)",
            "{",
            "\tunsigned long cap = 0;",
            "\tint i;",
            "",
            "\tfor_each_cpu_and(i, mask, cpu_active_mask)",
            "\t\tcap += arch_scale_cpu_capacity(i);",
            "",
            "\treturn cap;",
            "}",
            "static inline unsigned long dl_bw_capacity(int i)",
            "{",
            "\tif (!sched_asym_cpucap_active() &&",
            "\t    arch_scale_cpu_capacity(i) == SCHED_CAPACITY_SCALE) {",
            "\t\treturn dl_bw_cpus(i) << SCHED_CAPACITY_SHIFT;",
            "\t} else {",
            "\t\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),",
            "\t\t\t\t \"sched RCU must be held\");",
            "",
            "\t\treturn __dl_bw_capacity(cpu_rq(i)->rd->span);",
            "\t}",
            "}",
            "static inline bool dl_bw_visited(int cpu, u64 gen)",
            "{",
            "\tstruct root_domain *rd = cpu_rq(cpu)->rd;",
            "",
            "\tif (rd->visit_gen == gen)",
            "\t\treturn true;",
            "",
            "\trd->visit_gen = gen;",
            "\treturn false;",
            "}",
            "static inline",
            "void __dl_update(struct dl_bw *dl_b, s64 bw)",
            "{",
            "\tstruct root_domain *rd = container_of(dl_b, struct root_domain, dl_bw);",
            "\tint i;",
            "",
            "\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),",
            "\t\t\t \"sched RCU must be held\");",
            "\tfor_each_cpu_and(i, rd->span, cpu_active_mask) {",
            "\t\tstruct rq *rq = cpu_rq(i);",
            "",
            "\t\trq->dl.extra_bw += bw;",
            "\t}",
            "}",
            "static inline int dl_bw_cpus(int i)",
            "{",
            "\treturn 1;",
            "}",
            "static inline unsigned long dl_bw_capacity(int i)",
            "{",
            "\treturn SCHED_CAPACITY_SCALE;",
            "}",
            "static inline bool dl_bw_visited(int cpu, u64 gen)",
            "{",
            "\treturn false;",
            "}",
            "static inline",
            "void __dl_update(struct dl_bw *dl_b, s64 bw)",
            "{",
            "\tstruct dl_rq *dl = container_of(dl_b, struct dl_rq, dl_bw);",
            "",
            "\tdl->extra_bw += bw;",
            "}"
          ],
          "function_name": "sched_dl_sysctl_init, dl_server, on_dl_rq, is_dl_boosted, is_dl_boosted, dl_bw_cpus, __dl_bw_capacity, dl_bw_capacity, dl_bw_visited, __dl_update, dl_bw_cpus, dl_bw_capacity, dl_bw_visited, __dl_update",
          "description": "提供与截止时间调度相关的辅助函数，包括判断任务属性、计算带宽、管理资源容量及更新带宽分配的操作。",
          "similarity": 0.633477509021759
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 1870,
          "end_line": 1974,
          "content": [
            "static inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
            "static inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
            "static inline",
            "void inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)",
            "{",
            "\tu64 deadline = dl_se->deadline;",
            "",
            "\tdl_rq->dl_nr_running++;",
            "",
            "\tif (!dl_server(dl_se))",
            "\t\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);",
            "",
            "\tinc_dl_deadline(dl_rq, deadline);",
            "}",
            "static inline",
            "void dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)",
            "{",
            "\tWARN_ON(!dl_rq->dl_nr_running);",
            "\tdl_rq->dl_nr_running--;",
            "",
            "\tif (!dl_server(dl_se))",
            "\t\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);",
            "",
            "\tdec_dl_deadline(dl_rq, dl_se->deadline);",
            "}",
            "static inline bool __dl_less(struct rb_node *a, const struct rb_node *b)",
            "{",
            "\treturn dl_time_before(__node_2_dle(a)->deadline, __node_2_dle(b)->deadline);",
            "}",
            "static inline void",
            "update_stats_wait_start_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct sched_statistics *stats = __schedstats_from_dl_se(dl_se);",
            "\tif (stats)",
            "\t\t__update_stats_wait_start(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);",
            "}",
            "static inline void",
            "update_stats_wait_end_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct sched_statistics *stats = __schedstats_from_dl_se(dl_se);",
            "\tif (stats)",
            "\t\t__update_stats_wait_end(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);",
            "}",
            "static inline void",
            "update_stats_enqueue_sleeper_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct sched_statistics *stats = __schedstats_from_dl_se(dl_se);",
            "\tif (stats)",
            "\t\t__update_stats_enqueue_sleeper(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);",
            "}",
            "static inline void",
            "update_stats_enqueue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,",
            "\t\t\tint flags)",
            "{",
            "\tif (!schedstat_enabled())",
            "\t\treturn;",
            "",
            "\tif (flags & ENQUEUE_WAKEUP)",
            "\t\tupdate_stats_enqueue_sleeper_dl(dl_rq, dl_se);",
            "}",
            "static inline void",
            "update_stats_dequeue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,",
            "\t\t\tint flags)",
            "{",
            "\tstruct task_struct *p = dl_task_of(dl_se);",
            "",
            "\tif (!schedstat_enabled())",
            "\t\treturn;",
            "",
            "\tif ((flags & DEQUEUE_SLEEP)) {",
            "\t\tunsigned int state;",
            "",
            "\t\tstate = READ_ONCE(p->__state);",
            "\t\tif (state & TASK_INTERRUPTIBLE)",
            "\t\t\t__schedstat_set(p->stats.sleep_start,",
            "\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));",
            "",
            "\t\tif (state & TASK_UNINTERRUPTIBLE)",
            "\t\t\t__schedstat_set(p->stats.block_start,",
            "\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));",
            "\t}",
            "}",
            "static void __enqueue_dl_entity(struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);",
            "",
            "\tWARN_ON_ONCE(!RB_EMPTY_NODE(&dl_se->rb_node));",
            "",
            "\trb_add_cached(&dl_se->rb_node, &dl_rq->root, __dl_less);",
            "",
            "\tinc_dl_tasks(dl_se, dl_rq);",
            "}",
            "static void __dequeue_dl_entity(struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);",
            "",
            "\tif (RB_EMPTY_NODE(&dl_se->rb_node))",
            "\t\treturn;",
            "",
            "\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);",
            "",
            "\tRB_CLEAR_NODE(&dl_se->rb_node);",
            "",
            "\tdec_dl_tasks(dl_se, dl_rq);",
            "}"
          ],
          "function_name": "inc_dl_deadline, dec_dl_deadline, inc_dl_tasks, dec_dl_tasks, __dl_less, update_stats_wait_start_dl, update_stats_wait_end_dl, update_stats_enqueue_sleeper_dl, update_stats_enqueue_dl, update_stats_dequeue_dl, __enqueue_dl_entity, __dequeue_dl_entity",
          "description": "提供截止时间调度器的辅助函数，包含任务数量增减、截止时间管理、红黑树节点比较、统计信息更新及实体插入删除操作，部分函数存在空实现表明上下文不完整",
          "similarity": 0.6159223318099976
        },
        {
          "chunk_id": 20,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 3345,
          "end_line": 3455,
          "content": [
            "void __getparam_dl(struct task_struct *p, struct sched_attr *attr)",
            "{",
            "\tstruct sched_dl_entity *dl_se = &p->dl;",
            "",
            "\tattr->sched_priority = p->rt_priority;",
            "\tattr->sched_runtime = dl_se->dl_runtime;",
            "\tattr->sched_deadline = dl_se->dl_deadline;",
            "\tattr->sched_period = dl_se->dl_period;",
            "\tattr->sched_flags &= ~SCHED_DL_FLAGS;",
            "\tattr->sched_flags |= dl_se->flags;",
            "}",
            "bool __checkparam_dl(const struct sched_attr *attr)",
            "{",
            "\tu64 period, max, min;",
            "",
            "\t/* special dl tasks don't actually use any parameter */",
            "\tif (attr->sched_flags & SCHED_FLAG_SUGOV)",
            "\t\treturn true;",
            "",
            "\t/* deadline != 0 */",
            "\tif (attr->sched_deadline == 0)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Since we truncate DL_SCALE bits, make sure we're at least",
            "\t * that big.",
            "\t */",
            "\tif (attr->sched_runtime < (1ULL << DL_SCALE))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Since we use the MSB for wrap-around and sign issues, make",
            "\t * sure it's not set (mind that period can be equal to zero).",
            "\t */",
            "\tif (attr->sched_deadline & (1ULL << 63) ||",
            "\t    attr->sched_period & (1ULL << 63))",
            "\t\treturn false;",
            "",
            "\tperiod = attr->sched_period;",
            "\tif (!period)",
            "\t\tperiod = attr->sched_deadline;",
            "",
            "\t/* runtime <= deadline <= period (if period != 0) */",
            "\tif (period < attr->sched_deadline ||",
            "\t    attr->sched_deadline < attr->sched_runtime)",
            "\t\treturn false;",
            "",
            "\tmax = (u64)READ_ONCE(sysctl_sched_dl_period_max) * NSEC_PER_USEC;",
            "\tmin = (u64)READ_ONCE(sysctl_sched_dl_period_min) * NSEC_PER_USEC;",
            "",
            "\tif (period < min || period > max)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static void __dl_clear_params(struct sched_dl_entity *dl_se)",
            "{",
            "\tdl_se->dl_runtime\t\t= 0;",
            "\tdl_se->dl_deadline\t\t= 0;",
            "\tdl_se->dl_period\t\t= 0;",
            "\tdl_se->flags\t\t\t= 0;",
            "\tdl_se->dl_bw\t\t\t= 0;",
            "\tdl_se->dl_density\t\t= 0;",
            "",
            "\tdl_se->dl_throttled\t\t= 0;",
            "\tdl_se->dl_yielded\t\t= 0;",
            "\tdl_se->dl_non_contending\t= 0;",
            "\tdl_se->dl_overrun\t\t= 0;",
            "\tdl_se->dl_server\t\t= 0;",
            "",
            "#ifdef CONFIG_RT_MUTEXES",
            "\tdl_se->pi_se\t\t\t= dl_se;",
            "#endif",
            "}",
            "void init_dl_entity(struct sched_dl_entity *dl_se)",
            "{",
            "\tRB_CLEAR_NODE(&dl_se->rb_node);",
            "\tinit_dl_task_timer(dl_se);",
            "\tinit_dl_inactive_task_timer(dl_se);",
            "\t__dl_clear_params(dl_se);",
            "}",
            "bool dl_param_changed(struct task_struct *p, const struct sched_attr *attr)",
            "{",
            "\tstruct sched_dl_entity *dl_se = &p->dl;",
            "",
            "\tif (dl_se->dl_runtime != attr->sched_runtime ||",
            "\t    dl_se->dl_deadline != attr->sched_deadline ||",
            "\t    dl_se->dl_period != attr->sched_period ||",
            "\t    dl_se->flags != (attr->sched_flags & SCHED_DL_FLAGS))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "int dl_cpuset_cpumask_can_shrink(const struct cpumask *cur,",
            "\t\t\t\t const struct cpumask *trial)",
            "{",
            "\tunsigned long flags, cap;",
            "\tstruct dl_bw *cur_dl_b;",
            "\tint ret = 1;",
            "",
            "\trcu_read_lock_sched();",
            "\tcur_dl_b = dl_bw_of(cpumask_any(cur));",
            "\tcap = __dl_bw_capacity(trial);",
            "\traw_spin_lock_irqsave(&cur_dl_b->lock, flags);",
            "\tif (__dl_overflow(cur_dl_b, cap, 0, 0))",
            "\t\tret = 0;",
            "\traw_spin_unlock_irqrestore(&cur_dl_b->lock, flags);",
            "\trcu_read_unlock_sched();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__getparam_dl, __checkparam_dl, __dl_clear_params, init_dl_entity, dl_param_changed, dl_cpuset_cpumask_can_shrink",
          "description": "该代码段实现了实时调度类（DL）参数的获取、校验与清理功能。  \n`__getparam_dl` 将任务的DL参数复制至 `sched_attr` 结构，`__checkparam_dl` 校验参数合法性（如截止时间非零、运行时足够等），`__dl_clear_params` 初始化或重置DL实体参数，`init_dl_entity` 建立DL实体基础状态，`dl_param_changed` 比较参数变更情况，`dl_cpuset_cpumask_can_shrink` 检查CPU亲和性缩减可行性，涉及带宽容量计算。  \n代码涵盖DL调度参数处理逻辑及资源约束检查机制，未引入额外API。",
          "similarity": 0.6030763983726501
        },
        {
          "chunk_id": 21,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 3482,
          "end_line": 3530,
          "content": [
            "static int dl_bw_manage(enum dl_bw_request req, int cpu, u64 dl_bw)",
            "{",
            "\tunsigned long flags;",
            "\tstruct dl_bw *dl_b;",
            "\tbool overflow = 0;",
            "",
            "\trcu_read_lock_sched();",
            "\tdl_b = dl_bw_of(cpu);",
            "\traw_spin_lock_irqsave(&dl_b->lock, flags);",
            "",
            "\tif (req == dl_bw_req_free) {",
            "\t\t__dl_sub(dl_b, dl_bw, dl_bw_cpus(cpu));",
            "\t} else {",
            "\t\tunsigned long cap = dl_bw_capacity(cpu);",
            "",
            "\t\toverflow = __dl_overflow(dl_b, cap, 0, dl_bw);",
            "",
            "\t\tif (req == dl_bw_req_alloc && !overflow) {",
            "\t\t\t/*",
            "\t\t\t * We reserve space in the destination",
            "\t\t\t * root_domain, as we can't fail after this point.",
            "\t\t\t * We will free resources in the source root_domain",
            "\t\t\t * later on (see set_cpus_allowed_dl()).",
            "\t\t\t */",
            "\t\t\t__dl_add(dl_b, dl_bw, dl_bw_cpus(cpu));",
            "\t\t}",
            "\t}",
            "",
            "\traw_spin_unlock_irqrestore(&dl_b->lock, flags);",
            "\trcu_read_unlock_sched();",
            "",
            "\treturn overflow ? -EBUSY : 0;",
            "}",
            "int dl_bw_check_overflow(int cpu)",
            "{",
            "\treturn dl_bw_manage(dl_bw_req_check_overflow, cpu, 0);",
            "}",
            "int dl_bw_alloc(int cpu, u64 dl_bw)",
            "{",
            "\treturn dl_bw_manage(dl_bw_req_alloc, cpu, dl_bw);",
            "}",
            "void dl_bw_free(int cpu, u64 dl_bw)",
            "{",
            "\tdl_bw_manage(dl_bw_req_free, cpu, dl_bw);",
            "}",
            "void print_dl_stats(struct seq_file *m, int cpu)",
            "{",
            "\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);",
            "}"
          ],
          "function_name": "dl_bw_manage, dl_bw_check_overflow, dl_bw_alloc, dl_bw_free, print_dl_stats",
          "description": "该代码段实现了截止时间调度器（Deadline Scheduler）中带宽管理的核心逻辑，通过`dl_bw_manage`统一处理带宽分配、释放及溢出检测。其中`dl_bw_alloc/free`用于资源申请与回收，`dl_bw_check_overflow`检查带宽是否超限，`print_dl_stats`输出统计信息。因依赖未展示的辅助函数（如`__dl_add/sub`、`dl_bw_of`等），上下文存在缺失。",
          "similarity": 0.5921350717544556
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 1,
          "end_line": 47,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Deadline Scheduling Class (SCHED_DEADLINE)",
            " *",
            " * Earliest Deadline First (EDF) + Constant Bandwidth Server (CBS).",
            " *",
            " * Tasks that periodically executes their instances for less than their",
            " * runtime won't miss any of their deadlines.",
            " * Tasks that are not periodic or sporadic or that tries to execute more",
            " * than their reserved bandwidth will be slowed down (and may potentially",
            " * miss some of their deadlines), and won't affect any other task.",
            " *",
            " * Copyright (C) 2012 Dario Faggioli <raistlin@linux.it>,",
            " *                    Juri Lelli <juri.lelli@gmail.com>,",
            " *                    Michael Trimarchi <michael@amarulasolutions.com>,",
            " *                    Fabio Checconi <fchecconi@gmail.com>",
            " */",
            "",
            "#include <linux/cpuset.h>",
            "",
            "/*",
            " * Default limits for DL period; on the top end we guard against small util",
            " * tasks still getting ridiculously long effective runtimes, on the bottom end we",
            " * guard against timer DoS.",
            " */",
            "static unsigned int sysctl_sched_dl_period_max = 1 << 22; /* ~4 seconds */",
            "static unsigned int sysctl_sched_dl_period_min = 100;     /* 100 us */",
            "#ifdef CONFIG_SYSCTL",
            "static struct ctl_table sched_dl_sysctls[] = {",
            "\t{",
            "\t\t.procname       = \"sched_deadline_period_max_us\",",
            "\t\t.data           = &sysctl_sched_dl_period_max,",
            "\t\t.maxlen         = sizeof(unsigned int),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = proc_douintvec_minmax,",
            "\t\t.extra1         = (void *)&sysctl_sched_dl_period_min,",
            "\t},",
            "\t{",
            "\t\t.procname       = \"sched_deadline_period_min_us\",",
            "\t\t.data           = &sysctl_sched_dl_period_min,",
            "\t\t.maxlen         = sizeof(unsigned int),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = proc_douintvec_minmax,",
            "\t\t.extra2         = (void *)&sysctl_sched_dl_period_max,",
            "\t},",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义SCHED_DEADLINE调度类的默认周期限制参数及sysctl接口，用于配置截止时间任务的最大/最小周期值。",
          "similarity": 0.5884578227996826
        }
      ]
    },
    {
      "source_file": "kernel/sched/sched.h",
      "md_summary": "> 自动生成时间: 2025-10-25 16:16:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\sched.h`\n\n---\n\n# `sched/sched.h` 技术文档\n\n## 1. 文件概述\n\n`sched/sched.h` 是 Linux 内核调度器（Scheduler）的核心内部头文件，定义了调度子系统内部使用的类型、宏、辅助函数和全局变量。该文件不对外暴露给其他子系统直接使用，而是作为调度器各组件（如 CFS、RT、Deadline 调度类）之间的内部接口和共享基础设施。它整合了任务状态管理、负载计算、策略判断、CPU 能力建模、cgroup 权重转换等关键调度逻辑，并为调试、性能追踪和平台适配提供支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct asym_cap_data`：用于描述非对称 CPU 架构中不同 CPU 集合的计算能力（capacity），支持异构多核系统（如 big.LITTLE）的调度优化。\n- `struct rq`（前向声明）：运行队列（runqueue）结构体，每个 CPU 对应一个，是调度器管理可运行任务的核心数据结构。\n- `struct cpuidle_state`（前向声明）：CPU 空闲状态信息，用于与调度器协同进行能效管理。\n\n### 关键全局变量\n- `scheduler_running`：标志调度器是否已启动。\n- `calc_load_update` / `calc_load_tasks`：用于全局负载（load average）计算的时间戳和任务计数。\n- `sysctl_sched_rt_period` / `sysctl_sched_rt_runtime`：实时任务带宽控制参数。\n- `sched_rr_timeslice`：SCHED_RR 策略的时间片长度。\n- `asym_cap_list`：非对称 CPU 能力数据的全局链表。\n\n### 核心辅助函数与宏\n- **任务策略判断函数**：\n  - `idle_policy()` / `task_has_idle_policy()`\n  - `normal_policy()` / `fair_policy()`\n  - `rt_policy()` / `task_has_rt_policy()`\n  - `dl_policy()` / `task_has_dl_policy()`\n  - `valid_policy()`\n- **负载与权重转换**：\n  - `scale_load()` / `scale_load_down()`：在内部高精度负载值与用户可见权重间转换。\n  - `sched_weight_from_cgroup()` / `sched_weight_to_cgroup()`：cgroup 权重与调度器内部权重的映射。\n- **时间与精度处理**：\n  - `NS_TO_JIFFIES()`：纳秒转 jiffies。\n  - `update_avg()`：指数移动平均（EMA）更新。\n  - `shr_bound()`：安全右移，避免未定义行为。\n- **特殊调度标志**：\n  - `SCHED_FLAG_SUGOV`：用于 schedutil 频率调节器的特殊标志，使相关 kworker 临时获得高于 SCHED_DEADLINE 的优先级。\n  - `dl_entity_is_special()`：判断 Deadline 实体是否为 SUGOV 特殊任务。\n\n### 重要宏定义\n- `TASK_ON_RQ_QUEUED` / `TASK_ON_RQ_MIGRATING`：`task_struct::on_rq` 字段的状态值。\n- `NICE_0_LOAD`：nice 值为 0 的任务对应的内部负载基准值。\n- `DL_SCALE`：SCHED_DEADLINE 内部计算的精度因子。\n- `RUNTIME_INF`：表示无限运行时间的常量。\n- `SCHED_WARN_ON()`：调度器专用的条件警告宏（仅在 `CONFIG_SCHED_DEBUG` 时生效）。\n\n## 3. 关键实现\n\n### 高精度负载计算（64 位优化）\n在 64 位架构上，通过 `NICE_0_LOAD_SHIFT = 2 * SCHED_FIXEDPOINT_SHIFT` 提升内部负载计算的精度，改善低权重任务组（如 nice +19）和深层 cgroup 层级的负载均衡效果。`scale_load()` 和 `scale_load_down()` 实现了用户权重与内部高精度负载值之间的无损转换。\n\n### 非对称 CPU 能力建模\n`asym_cap_data` 结构体结合 `cpu_capacity_span()` 宏，将具有相同计算能力的 CPU 归为一组，并通过全局链表 `asym_cap_list` 管理。这为调度器在异构系统中进行负载均衡和任务迁移提供关键拓扑信息。\n\n### cgroup 权重标准化\n通过 `sched_weight_from_cgroup()` 和 `sched_weight_to_cgroup()`，将 cgroup 接口的权重范围（1–10000，默认 100）映射到调度器内部使用的权重值（基于 1024 基准），确保用户配置与调度行为的一致性。\n\n### SCHED_DEADLINE 与频率调节协同\n引入 `SCHED_FLAG_SUGOV` 标志，允许 `schedutil` 频率调节器的工作线程在需要时临时突破 SCHED_DEADLINE 的优先级限制，以解决某些平台无法原子切换 CPU 频率的问题。这是一种临时性 workaround，依赖于 `dl_entity_is_special()` 进行识别。\n\n### 安全位运算\n`shr_bound()` 宏确保右移操作不会因移位数过大而触发未定义行为（UB），通过 `min_t()` 将移位数限制在 `BITS_PER_TYPE(val) - 1` 以内。\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n- **调度子系统内部**：包含多个调度相关子模块头文件（如 `affinity.h`, `deadline.h`, `topology.h`, `cpupri.h` 等）。\n- **核心内核设施**：依赖 `atomic.h`, `rcupdate.h`, `cpumask_api.h`, `ktime_api.h`, `trace/events/sched.h` 等。\n- **平台与虚拟化**：条件包含 `asm/paravirt.h`（半虚拟化支持）和 `asm/barrier.h`（内存屏障）。\n- **工作队列**：包含 `../workqueue_internal.h`，用于与工作队列子系统交互。\n\n### 配置选项依赖\n- `CONFIG_64BIT`：启用高精度负载计算。\n- `CONFIG_SCHED_DEBUG`：启用 `SCHED_WARN_ON()` 调试检查。\n- `CONFIG_CPU_FREQ_GOV_SCHEDUTIL`：启用 `SCHED_FLAG_SUGOV` 相关逻辑。\n- `CONFIG_SCHED_CLASS_EXT`：扩展调度类支持（影响 `normal_policy()` 判断）。\n- `CONFIG_PARAVIRT`：半虚拟化支持。\n\n## 5. 使用场景\n\n- **调度器初始化与运行**：`scheduler_running` 和负载计算变量在调度器启动和周期性负载更新中使用。\n- **任务调度策略处理**：所有调度类（CFS、RT、Deadline、Idle）在入队、出队、选择下一个任务时，通过策略判断函数确定任务类型。\n- **负载均衡与迁移**：`asym_cap_data` 和 CPU 拓扑信息用于跨 CPU 的任务迁移决策，尤其在异构系统中。\n- **cgroup 资源控制**：在设置或读取 cgroup 的 CPU 权重时，通过权重转换函数确保调度器内部表示与用户接口一致。\n- **实时带宽管理**：`sysctl_sched_rt_*` 参数用于限制 SCHED_FIFO/SCHED_RR 任务的 CPU 使用率。\n- **能效调度协同**：`SCHED_FLAG_SUGOV` 机制使频率调节器能及时响应 Deadline 任务的性能需求。\n- **内核调试与追踪**：`SCHED_WARN_ON()` 用于捕获调度器内部异常状态；tracepoint 定义支持调度事件追踪。",
      "similarity": 0.5946854948997498,
      "chunks": []
    },
    {
      "source_file": "kernel/sched/rt.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:14:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\rt.c`\n\n---\n\n# `sched/rt.c` 技术文档\n\n## 1. 文件概述\n\n`sched/rt.c` 是 Linux 内核调度子系统中实现实时（Real-Time, RT）调度类的核心文件，主要支持 `SCHED_FIFO` 和 `SCHED_RR` 两种 POSIX 实时调度策略。该文件负责管理实时任务的运行队列、优先级调度、时间片分配、带宽限制（RT throttling）以及在多核系统（SMP）下的负载均衡机制。此外，它还提供了对实时任务组调度（RT Group Scheduling）的支持，允许通过 cgroups 对实时任务的 CPU 使用进行资源控制。\n\n## 2. 核心功能\n\n### 全局变量\n- `sched_rr_timeslice`：定义 `SCHED_RR` 策略的默认时间片长度（单位：调度 tick）。\n- `max_rt_runtime`：实时任务在单个周期内可使用的最大运行时间上限（通常为 4 小时以上）。\n- `sysctl_sched_rt_period`：实时带宽控制的周期，默认为 1,000,000 微秒（1 秒）。\n- `sysctl_sched_rt_runtime`：每个周期内允许实时任务运行的时间，默认为 950,000 微秒（0.95 秒）。\n\n### sysctl 接口（`CONFIG_SYSCTL` 启用时）\n- `/proc/sys/kernel/sched_rt_period_us`：设置 RT 带宽控制周期。\n- `/proc/sys/kernel/sched_rt_runtime_us`：设置 RT 带宽控制运行时间（可设为 -1 表示无限制）。\n- `/proc/sys/kernel/sched_rr_timeslice_ms`：设置 `SCHED_RR` 时间片（毫秒）。\n\n### 主要函数\n- `init_rt_rq(struct rt_rq *rt_rq)`：初始化实时运行队列（`rt_rq`），包括优先级位图、链表、SMP 相关字段及带宽控制状态。\n- `init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)`：初始化 RT 带宽控制结构，配置高精度定时器。\n- `sched_rt_period_timer(struct hrtimer *timer)`：高精度定时器回调函数，用于周期性重置 RT 运行时间配额。\n- `start_rt_bandwidth(struct rt_bandwidth *rt_b)`：启动 RT 带宽控制定时器。\n- `alloc_rt_sched_group / free_rt_sched_group / unregister_rt_sched_group`：管理实时任务组（task group）的资源分配与释放。\n- `init_tg_rt_entry`：初始化任务组在指定 CPU 上的 RT 调度实体和运行队列。\n- `rt_task_of / rq_of_rt_rq / rt_rq_of_se / rq_of_rt_se`：辅助函数，用于在调度实体、任务、运行队列和 CPU 队列之间相互转换。\n\n### SMP 支持函数（`CONFIG_SMP` 启用时）\n- `need_pull_rt_task`：判断是否需要从其他 CPU 拉取高优先级 RT 任务。\n- `rt_overloaded` / `rt_set_overload`：用于跟踪系统中是否存在过载的 RT 运行队列，支持 RT 任务迁移。\n\n## 3. 关键实现\n\n### 实时运行队列（`rt_rq`）管理\n- 使用 `rt_prio_array` 结构维护 0 到 `MAX_RT_PRIO-1`（通常为 99）共 100 个优先级的双向链表。\n- 通过位图（`bitmap`）快速查找最高优先级的可运行任务，`__set_bit(MAX_RT_PRIO, bitmap)` 作为位图搜索的终止标记。\n- `rt_queued` 标志表示是否有 RT 任务入队；`highest_prio.curr/next` 跟踪当前和下一个最高优先级（SMP 专用）。\n\n### RT 带宽控制（Throttling）\n- 通过 `rt_bandwidth` 结构限制 RT 任务在每个 `rt_period` 内最多使用 `rt_runtime` 的 CPU 时间。\n- 使用高精度定时器（`hrtimer`）实现周期性重置：每经过 `rt_period`，将 `rt_time` 清零并解除 throttling。\n- 若 `rt_runtime == RUNTIME_INF`（即 -1），则禁用带宽限制。\n- 定时器回调 `sched_rt_period_timer` 支持处理定时器 overrun（跳过多个周期），确保带宽控制的准确性。\n\n### RT 任务组调度（`CONFIG_RT_GROUP_SCHED`）\n- 每个 `task_group` 拥有 per-CPU 的 `rt_rq` 和 `sched_rt_entity`。\n- 根叶节点（普通任务）的 `rt_se` 直接链接到 CPU 的全局 `rt_rq`；非叶节点（cgroup）的 `rt_se` 链接到父组的 `rt_rq`，形成调度树。\n- `rt_entity_is_task()` 用于区分调度实体是任务还是任务组。\n\n### SMP 负载均衡\n- 当某 CPU 上运行的 RT 任务优先级降低（如被抢占或阻塞），若其当前最高优先级高于刚被替换的任务，则触发 `need_pull_rt_task`，尝试从其他 CPU 拉取更高优先级的 RT 任务。\n- `overloaded` 标志和 `pushable_tasks` 链表用于支持 RT 任务的主动推送（push）和拉取（pull）机制，确保高优先级任务尽快运行。\n\n## 4. 依赖关系\n\n- **调度核心**：依赖 `kernel/sched/core.c` 提供的通用调度框架、运行队列（`rq`）结构和调度类注册机制。\n- **高精度定时器**：使用 `kernel/time/hrtimer.c` 实现 RT 带宽控制的周期性重置。\n- **SMP 调度**：与 `kernel/sched/topology.c` 和 `kernel/sched/fair.c` 协同实现跨 CPU 的 RT 任务迁移。\n- **cgroups**：当启用 `CONFIG_RT_GROUP_SCHED` 时，与 `kernel/cgroup/` 子系统集成，支持基于 cgroup v1/v2 的 RT 带宽分配。\n- **sysctl**：通过 `kernel/sysctl.c` 暴露运行时可调参数。\n\n## 5. 使用场景\n\n- **实时应用调度**：为音视频处理、工业控制、机器人等需要确定性延迟的应用提供 `SCHED_FIFO`/`SCHED_RR` 调度支持。\n- **系统资源保护**：通过 `sched_rt_runtime_us` 限制 RT 任务的 CPU 占用率（默认 95%），防止其独占 CPU 导致系统僵死。\n- **多租户 RT 资源隔离**：在容器或虚拟化环境中，利用 RT 任务组调度为不同租户分配独立的 RT 带宽配额。\n- **SMP 实时性能优化**：在多核系统中，通过 RT 任务迁移机制减少高优先级任务的调度延迟，提升实时响应能力。",
      "similarity": 0.5852811336517334,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/rt.c",
          "start_line": 1,
          "end_line": 56,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Real-Time Scheduling Class (mapped to the SCHED_FIFO and SCHED_RR",
            " * policies)",
            " */",
            "",
            "int sched_rr_timeslice = RR_TIMESLICE;",
            "/* More than 4 hours if BW_SHIFT equals 20. */",
            "static const u64 max_rt_runtime = MAX_BW;",
            "",
            "/*",
            " * period over which we measure -rt task CPU usage in us.",
            " * default: 1s",
            " */",
            "int sysctl_sched_rt_period = 1000000;",
            "",
            "/*",
            " * part of the period that we allow rt tasks to run in us.",
            " * default: 0.95s",
            " */",
            "int sysctl_sched_rt_runtime = 950000;",
            "",
            "#ifdef CONFIG_SYSCTL",
            "static int sysctl_sched_rr_timeslice = (MSEC_PER_SEC * RR_TIMESLICE) / HZ;",
            "static int sched_rt_handler(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos);",
            "static int sched_rr_handler(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos);",
            "static struct ctl_table sched_rt_sysctls[] = {",
            "\t{",
            "\t\t.procname       = \"sched_rt_period_us\",",
            "\t\t.data           = &sysctl_sched_rt_period,",
            "\t\t.maxlen         = sizeof(int),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = sched_rt_handler,",
            "\t\t.extra1         = SYSCTL_ONE,",
            "\t\t.extra2         = SYSCTL_INT_MAX,",
            "\t},",
            "\t{",
            "\t\t.procname       = \"sched_rt_runtime_us\",",
            "\t\t.data           = &sysctl_sched_rt_runtime,",
            "\t\t.maxlen         = sizeof(int),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = sched_rt_handler,",
            "\t\t.extra1         = SYSCTL_NEG_ONE,",
            "\t\t.extra2         = (void *)&sysctl_sched_rt_period,",
            "\t},",
            "\t{",
            "\t\t.procname       = \"sched_rr_timeslice_ms\",",
            "\t\t.data           = &sysctl_sched_rr_timeslice,",
            "\t\t.maxlen         = sizeof(int),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = sched_rr_handler,",
            "\t},",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义实时调度类的配置参数及sysctl接口，设置默认的实时任务周期和运行时间，并注册相应的proc_handler以允许动态调整。",
          "similarity": 0.5973786115646362
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/rt.c",
          "start_line": 57,
          "end_line": 159,
          "content": [
            "static int __init sched_rt_sysctl_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", sched_rt_sysctls);",
            "\treturn 0;",
            "}",
            "void init_rt_rq(struct rt_rq *rt_rq)",
            "{",
            "\tstruct rt_prio_array *array;",
            "\tint i;",
            "",
            "\tarray = &rt_rq->active;",
            "\tfor (i = 0; i < MAX_RT_PRIO; i++) {",
            "\t\tINIT_LIST_HEAD(array->queue + i);",
            "\t\t__clear_bit(i, array->bitmap);",
            "\t}",
            "\t/* delimiter for bitsearch: */",
            "\t__set_bit(MAX_RT_PRIO, array->bitmap);",
            "",
            "#if defined CONFIG_SMP",
            "\trt_rq->highest_prio.curr = MAX_RT_PRIO-1;",
            "\trt_rq->highest_prio.next = MAX_RT_PRIO-1;",
            "\trt_rq->overloaded = 0;",
            "\tplist_head_init(&rt_rq->pushable_tasks);",
            "#endif /* CONFIG_SMP */",
            "\t/* We start is dequeued state, because no RT tasks are queued */",
            "\trt_rq->rt_queued = 0;",
            "",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\trt_rq->rt_time = 0;",
            "\trt_rq->rt_throttled = 0;",
            "\trt_rq->rt_runtime = 0;",
            "\traw_spin_lock_init(&rt_rq->rt_runtime_lock);",
            "#endif",
            "}",
            "static enum hrtimer_restart sched_rt_period_timer(struct hrtimer *timer)",
            "{",
            "\tstruct rt_bandwidth *rt_b =",
            "\t\tcontainer_of(timer, struct rt_bandwidth, rt_period_timer);",
            "\tint idle = 0;",
            "\tint overrun;",
            "",
            "\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\tfor (;;) {",
            "\t\toverrun = hrtimer_forward_now(timer, rt_b->rt_period);",
            "\t\tif (!overrun)",
            "\t\t\tbreak;",
            "",
            "\t\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "\t\tidle = do_sched_rt_period_timer(rt_b, overrun);",
            "\t\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\t}",
            "\tif (idle)",
            "\t\trt_b->rt_period_active = 0;",
            "\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "",
            "\treturn idle ? HRTIMER_NORESTART : HRTIMER_RESTART;",
            "}",
            "void init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)",
            "{",
            "\trt_b->rt_period = ns_to_ktime(period);",
            "\trt_b->rt_runtime = runtime;",
            "",
            "\traw_spin_lock_init(&rt_b->rt_runtime_lock);",
            "",
            "\thrtimer_init(&rt_b->rt_period_timer, CLOCK_MONOTONIC,",
            "\t\t     HRTIMER_MODE_REL_HARD);",
            "\trt_b->rt_period_timer.function = sched_rt_period_timer;",
            "}",
            "static inline void do_start_rt_bandwidth(struct rt_bandwidth *rt_b)",
            "{",
            "\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\tif (!rt_b->rt_period_active) {",
            "\t\trt_b->rt_period_active = 1;",
            "\t\t/*",
            "\t\t * SCHED_DEADLINE updates the bandwidth, as a run away",
            "\t\t * RT task with a DL task could hog a CPU. But DL does",
            "\t\t * not reset the period. If a deadline task was running",
            "\t\t * without an RT task running, it can cause RT tasks to",
            "\t\t * throttle when they start up. Kick the timer right away",
            "\t\t * to update the period.",
            "\t\t */",
            "\t\thrtimer_forward_now(&rt_b->rt_period_timer, ns_to_ktime(0));",
            "\t\thrtimer_start_expires(&rt_b->rt_period_timer,",
            "\t\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);",
            "\t}",
            "\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "}",
            "static void start_rt_bandwidth(struct rt_bandwidth *rt_b)",
            "{",
            "\tif (!rt_bandwidth_enabled() || rt_b->rt_runtime == RUNTIME_INF)",
            "\t\treturn;",
            "",
            "\tdo_start_rt_bandwidth(rt_b);",
            "}",
            "static void destroy_rt_bandwidth(struct rt_bandwidth *rt_b)",
            "{",
            "\thrtimer_cancel(&rt_b->rt_period_timer);",
            "}",
            "void unregister_rt_sched_group(struct task_group *tg)",
            "{",
            "\tif (tg->rt_se)",
            "\t\tdestroy_rt_bandwidth(&tg->rt_bandwidth);",
            "}"
          ],
          "function_name": "sched_rt_sysctl_init, init_rt_rq, sched_rt_period_timer, init_rt_bandwidth, do_start_rt_bandwidth, start_rt_bandwidth, destroy_rt_bandwidth, unregister_rt_sched_group",
          "description": "初始化实时调度相关数据结构，管理实时任务周期定时器，控制实时带宽分配与回收，实现基于时间片轮转的调度策略。",
          "similarity": 0.5771715641021729
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/sched/rt.c",
          "start_line": 776,
          "end_line": 913,
          "content": [
            "static void balance_runtime(struct rt_rq *rt_rq)",
            "{",
            "\tif (!sched_feat(RT_RUNTIME_SHARE))",
            "\t\treturn;",
            "",
            "\tif (rt_rq->rt_time > rt_rq->rt_runtime) {",
            "\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);",
            "\t\tdo_balance_runtime(rt_rq);",
            "\t\traw_spin_lock(&rt_rq->rt_runtime_lock);",
            "\t}",
            "}",
            "static inline void balance_runtime(struct rt_rq *rt_rq) {}",
            "static int do_sched_rt_period_timer(struct rt_bandwidth *rt_b, int overrun)",
            "{",
            "\tint i, idle = 1, throttled = 0;",
            "\tconst struct cpumask *span;",
            "",
            "\tspan = sched_rt_period_mask();",
            "",
            "\t/*",
            "\t * FIXME: isolated CPUs should really leave the root task group,",
            "\t * whether they are isolcpus or were isolated via cpusets, lest",
            "\t * the timer run on a CPU which does not service all runqueues,",
            "\t * potentially leaving other CPUs indefinitely throttled.  If",
            "\t * isolation is really required, the user will turn the throttle",
            "\t * off to kill the perturbations it causes anyway.  Meanwhile,",
            "\t * this maintains functionality for boot and/or troubleshooting.",
            "\t */",
            "\tif (rt_b == &root_task_group.rt_bandwidth)",
            "\t\tspan = cpu_online_mask;",
            "",
            "\tfor_each_cpu(i, span) {",
            "\t\tint enqueue = 0;",
            "\t\tstruct rt_rq *rt_rq = sched_rt_period_rt_rq(rt_b, i);",
            "\t\tstruct rq *rq = rq_of_rt_rq(rt_rq);",
            "\t\tstruct rq_flags rf;",
            "\t\tint skip;",
            "",
            "\t\t/*",
            "\t\t * When span == cpu_online_mask, taking each rq->lock",
            "\t\t * can be time-consuming. Try to avoid it when possible.",
            "\t\t */",
            "\t\traw_spin_lock(&rt_rq->rt_runtime_lock);",
            "\t\tif (!sched_feat(RT_RUNTIME_SHARE) && rt_rq->rt_runtime != RUNTIME_INF)",
            "\t\t\trt_rq->rt_runtime = rt_b->rt_runtime;",
            "\t\tskip = !rt_rq->rt_time && !rt_rq->rt_nr_running;",
            "\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);",
            "\t\tif (skip)",
            "\t\t\tcontinue;",
            "",
            "\t\trq_lock(rq, &rf);",
            "\t\tupdate_rq_clock(rq);",
            "",
            "\t\tif (rt_rq->rt_time) {",
            "\t\t\tu64 runtime;",
            "",
            "\t\t\traw_spin_lock(&rt_rq->rt_runtime_lock);",
            "\t\t\tif (rt_rq->rt_throttled)",
            "\t\t\t\tbalance_runtime(rt_rq);",
            "\t\t\truntime = rt_rq->rt_runtime;",
            "\t\t\trt_rq->rt_time -= min(rt_rq->rt_time, overrun*runtime);",
            "\t\t\tif (rt_rq->rt_throttled && rt_rq->rt_time < runtime) {",
            "\t\t\t\trt_rq->rt_throttled = 0;",
            "\t\t\t\tenqueue = 1;",
            "",
            "\t\t\t\t/*",
            "\t\t\t\t * When we're idle and a woken (rt) task is",
            "\t\t\t\t * throttled wakeup_preempt() will set",
            "\t\t\t\t * skip_update and the time between the wakeup",
            "\t\t\t\t * and this unthrottle will get accounted as",
            "\t\t\t\t * 'runtime'.",
            "\t\t\t\t */",
            "\t\t\t\tif (rt_rq->rt_nr_running && rq->curr == rq->idle)",
            "\t\t\t\t\trq_clock_cancel_skipupdate(rq);",
            "\t\t\t}",
            "\t\t\tif (rt_rq->rt_time || rt_rq->rt_nr_running)",
            "\t\t\t\tidle = 0;",
            "\t\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);",
            "\t\t} else if (rt_rq->rt_nr_running) {",
            "\t\t\tidle = 0;",
            "\t\t\tif (!rt_rq_throttled(rt_rq))",
            "\t\t\t\tenqueue = 1;",
            "\t\t}",
            "\t\tif (rt_rq->rt_throttled)",
            "\t\t\tthrottled = 1;",
            "",
            "\t\tif (enqueue)",
            "\t\t\tsched_rt_rq_enqueue(rt_rq);",
            "\t\trq_unlock(rq, &rf);",
            "\t}",
            "",
            "\tif (!throttled && (!rt_bandwidth_enabled() || rt_b->rt_runtime == RUNTIME_INF))",
            "\t\treturn 1;",
            "",
            "\treturn idle;",
            "}",
            "static int sched_rt_runtime_exceeded(struct rt_rq *rt_rq)",
            "{",
            "\tu64 runtime = sched_rt_runtime(rt_rq);",
            "",
            "\tif (rt_rq->rt_throttled)",
            "\t\treturn rt_rq_throttled(rt_rq);",
            "",
            "\tif (runtime >= sched_rt_period(rt_rq))",
            "\t\treturn 0;",
            "",
            "\tbalance_runtime(rt_rq);",
            "\truntime = sched_rt_runtime(rt_rq);",
            "\tif (runtime == RUNTIME_INF)",
            "\t\treturn 0;",
            "",
            "\tif (rt_rq->rt_time > runtime) {",
            "\t\tstruct rt_bandwidth *rt_b = sched_rt_bandwidth(rt_rq);",
            "",
            "\t\t/*",
            "\t\t * Don't actually throttle groups that have no runtime assigned",
            "\t\t * but accrue some time due to boosting.",
            "\t\t */",
            "\t\tif (likely(rt_b->rt_runtime)) {",
            "\t\t\trt_rq->rt_throttled = 1;",
            "\t\t\tprintk_deferred_once(\"sched: RT throttling activated\\n\");",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * In case we did anyway, make it go away,",
            "\t\t\t * replenishment is a joke, since it will replenish us",
            "\t\t\t * with exactly 0 ns.",
            "\t\t\t */",
            "\t\t\trt_rq->rt_time = 0;",
            "\t\t}",
            "",
            "\t\tif (rt_rq_throttled(rt_rq)) {",
            "\t\t\tsched_rt_rq_dequeue(rt_rq);",
            "\t\t\treturn 1;",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "balance_runtime, balance_runtime, do_sched_rt_period_timer, sched_rt_runtime_exceeded",
          "description": "`balance_runtime`在超时时触发重新平衡，`do_sched_rt_period_timer`周期性调整运行时并检查节流状态，`sched_rt_runtime_exceeded`判断是否超出运行时限制并标记节流",
          "similarity": 0.5634451508522034
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/sched/rt.c",
          "start_line": 1066,
          "end_line": 1170,
          "content": [
            "static void",
            "inc_rt_prio_smp(struct rt_rq *rt_rq, int prio, int prev_prio)",
            "{",
            "\tstruct rq *rq = rq_of_rt_rq(rt_rq);",
            "",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\t/*",
            "\t * Change rq's cpupri only if rt_rq is the top queue.",
            "\t */",
            "\tif (&rq->rt != rt_rq)",
            "\t\treturn;",
            "#endif",
            "\tif (rq->online && prio < prev_prio)",
            "\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, prio);",
            "}",
            "static void",
            "dec_rt_prio_smp(struct rt_rq *rt_rq, int prio, int prev_prio)",
            "{",
            "\tstruct rq *rq = rq_of_rt_rq(rt_rq);",
            "",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\t/*",
            "\t * Change rq's cpupri only if rt_rq is the top queue.",
            "\t */",
            "\tif (&rq->rt != rt_rq)",
            "\t\treturn;",
            "#endif",
            "\tif (rq->online && rt_rq->highest_prio.curr != prev_prio)",
            "\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, rt_rq->highest_prio.curr);",
            "}",
            "static inline",
            "void inc_rt_prio_smp(struct rt_rq *rt_rq, int prio, int prev_prio) {}",
            "static inline",
            "void dec_rt_prio_smp(struct rt_rq *rt_rq, int prio, int prev_prio) {}",
            "static void",
            "inc_rt_prio(struct rt_rq *rt_rq, int prio)",
            "{",
            "\tint prev_prio = rt_rq->highest_prio.curr;",
            "",
            "\tif (prio < prev_prio)",
            "\t\trt_rq->highest_prio.curr = prio;",
            "",
            "\tinc_rt_prio_smp(rt_rq, prio, prev_prio);",
            "}",
            "static void",
            "dec_rt_prio(struct rt_rq *rt_rq, int prio)",
            "{",
            "\tint prev_prio = rt_rq->highest_prio.curr;",
            "",
            "\tif (rt_rq->rt_nr_running) {",
            "",
            "\t\tWARN_ON(prio < prev_prio);",
            "",
            "\t\t/*",
            "\t\t * This may have been our highest task, and therefore",
            "\t\t * we may have some recomputation to do",
            "\t\t */",
            "\t\tif (prio == prev_prio) {",
            "\t\t\tstruct rt_prio_array *array = &rt_rq->active;",
            "",
            "\t\t\trt_rq->highest_prio.curr =",
            "\t\t\t\tsched_find_first_bit(array->bitmap);",
            "\t\t}",
            "",
            "\t} else {",
            "\t\trt_rq->highest_prio.curr = MAX_RT_PRIO-1;",
            "\t}",
            "",
            "\tdec_rt_prio_smp(rt_rq, prio, prev_prio);",
            "}",
            "static inline void inc_rt_prio(struct rt_rq *rt_rq, int prio) {}",
            "static inline void dec_rt_prio(struct rt_rq *rt_rq, int prio) {}",
            "static void",
            "inc_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)",
            "{",
            "\tif (rt_se_boosted(rt_se))",
            "\t\trt_rq->rt_nr_boosted++;",
            "",
            "\tif (rt_rq->tg)",
            "\t\tstart_rt_bandwidth(&rt_rq->tg->rt_bandwidth);",
            "}",
            "static void",
            "dec_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)",
            "{",
            "\tif (rt_se_boosted(rt_se))",
            "\t\trt_rq->rt_nr_boosted--;",
            "",
            "\tWARN_ON(!rt_rq->rt_nr_running && rt_rq->rt_nr_boosted);",
            "}",
            "static void",
            "inc_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)",
            "{",
            "}",
            "static inline",
            "void dec_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq) {}",
            "static inline",
            "unsigned int rt_se_nr_running(struct sched_rt_entity *rt_se)",
            "{",
            "\tstruct rt_rq *group_rq = group_rt_rq(rt_se);",
            "",
            "\tif (group_rq)",
            "\t\treturn group_rq->rt_nr_running;",
            "\telse",
            "\t\treturn 1;",
            "}"
          ],
          "function_name": "inc_rt_prio_smp, dec_rt_prio_smp, inc_rt_prio_smp, dec_rt_prio_smp, inc_rt_prio, dec_rt_prio, inc_rt_prio, dec_rt_prio, inc_rt_group, dec_rt_group, inc_rt_group, dec_rt_group, rt_se_nr_running",
          "description": "`inc_rt_prio/dec_rt_prio`维护实时队列最高优先级，`inc_rt_group/dec_rt_group`处理调度组的资源计数，`rt_se_nr_running`查询任务所属组的运行数量",
          "similarity": 0.554922342300415
        },
        {
          "chunk_id": 17,
          "file_path": "kernel/sched/rt.c",
          "start_line": 2533,
          "end_line": 2686,
          "content": [
            "static void watchdog(struct rq *rq, struct task_struct *p)",
            "{",
            "\tunsigned long soft, hard;",
            "",
            "\t/* max may change after cur was read, this will be fixed next tick */",
            "\tsoft = task_rlimit(p, RLIMIT_RTTIME);",
            "\thard = task_rlimit_max(p, RLIMIT_RTTIME);",
            "",
            "\tif (soft != RLIM_INFINITY) {",
            "\t\tunsigned long next;",
            "",
            "\t\tif (p->rt.watchdog_stamp != jiffies) {",
            "\t\t\tp->rt.timeout++;",
            "\t\t\tp->rt.watchdog_stamp = jiffies;",
            "\t\t}",
            "",
            "\t\tnext = DIV_ROUND_UP(min(soft, hard), USEC_PER_SEC/HZ);",
            "\t\tif (p->rt.timeout > next) {",
            "\t\t\tposix_cputimers_rt_watchdog(&p->posix_cputimers,",
            "\t\t\t\t\t\t    p->se.sum_exec_runtime);",
            "\t\t}",
            "\t}",
            "}",
            "static inline void watchdog(struct rq *rq, struct task_struct *p) { }",
            "static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued)",
            "{",
            "\tstruct sched_rt_entity *rt_se = &p->rt;",
            "",
            "\tupdate_curr_rt(rq);",
            "\tupdate_rt_rq_load_avg(rq_clock_pelt(rq), rq, 1);",
            "",
            "\twatchdog(rq, p);",
            "",
            "\t/*",
            "\t * RR tasks need a special form of timeslice management.",
            "\t * FIFO tasks have no timeslices.",
            "\t */",
            "\tif (p->policy != SCHED_RR)",
            "\t\treturn;",
            "",
            "\tif (--p->rt.time_slice)",
            "\t\treturn;",
            "",
            "\tp->rt.time_slice = sched_rr_timeslice;",
            "",
            "\t/*",
            "\t * Requeue to the end of queue if we (and all of our ancestors) are not",
            "\t * the only element on the queue",
            "\t */",
            "\tfor_each_sched_rt_entity(rt_se) {",
            "\t\tif (rt_se->run_list.prev != rt_se->run_list.next) {",
            "\t\t\trequeue_task_rt(rq, p, 0);",
            "\t\t\tresched_curr(rq);",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "}",
            "static unsigned int get_rr_interval_rt(struct rq *rq, struct task_struct *task)",
            "{",
            "\t/*",
            "\t * Time slice is 0 for SCHED_FIFO tasks",
            "\t */",
            "\tif (task->policy == SCHED_RR)",
            "\t\treturn sched_rr_timeslice;",
            "\telse",
            "\t\treturn 0;",
            "}",
            "static int task_is_throttled_rt(struct task_struct *p, int cpu)",
            "{",
            "\tstruct rt_rq *rt_rq;",
            "",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\trt_rq = task_group(p)->rt_rq[cpu];",
            "#else",
            "\trt_rq = &cpu_rq(cpu)->rt;",
            "#endif",
            "",
            "\treturn rt_rq_throttled(rt_rq);",
            "}",
            "static inline int tg_has_rt_tasks(struct task_group *tg)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct css_task_iter it;",
            "\tint ret = 0;",
            "",
            "\t/*",
            "\t * Autogroups do not have RT tasks; see autogroup_create().",
            "\t */",
            "\tif (task_group_is_autogroup(tg))",
            "\t\treturn 0;",
            "",
            "\tcss_task_iter_start(&tg->css, 0, &it);",
            "\twhile (!ret && (task = css_task_iter_next(&it)))",
            "\t\tret |= rt_task(task);",
            "\tcss_task_iter_end(&it);",
            "",
            "\treturn ret;",
            "}",
            "static int tg_rt_schedulable(struct task_group *tg, void *data)",
            "{",
            "\tstruct rt_schedulable_data *d = data;",
            "\tstruct task_group *child;",
            "\tunsigned long total, sum = 0;",
            "\tu64 period, runtime;",
            "",
            "\tperiod = ktime_to_ns(tg->rt_bandwidth.rt_period);",
            "\truntime = tg->rt_bandwidth.rt_runtime;",
            "",
            "\tif (tg == d->tg) {",
            "\t\tperiod = d->rt_period;",
            "\t\truntime = d->rt_runtime;",
            "\t}",
            "",
            "\t/*",
            "\t * Cannot have more runtime than the period.",
            "\t */",
            "\tif (runtime > period && runtime != RUNTIME_INF)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Ensure we don't starve existing RT tasks if runtime turns zero.",
            "\t */",
            "\tif (rt_bandwidth_enabled() && !runtime &&",
            "\t    tg->rt_bandwidth.rt_runtime && tg_has_rt_tasks(tg))",
            "\t\treturn -EBUSY;",
            "",
            "\ttotal = to_ratio(period, runtime);",
            "",
            "\t/*",
            "\t * Nobody can have more than the global setting allows.",
            "\t */",
            "\tif (total > to_ratio(global_rt_period(), global_rt_runtime()))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * The sum of our children's runtime should not exceed our own.",
            "\t */",
            "\tlist_for_each_entry_rcu(child, &tg->children, siblings) {",
            "\t\tperiod = ktime_to_ns(child->rt_bandwidth.rt_period);",
            "\t\truntime = child->rt_bandwidth.rt_runtime;",
            "",
            "\t\tif (child == d->tg) {",
            "\t\t\tperiod = d->rt_period;",
            "\t\t\truntime = d->rt_runtime;",
            "\t\t}",
            "",
            "\t\tsum += to_ratio(period, runtime);",
            "\t}",
            "",
            "\tif (sum > total)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "watchdog, watchdog, task_tick_rt, get_rr_interval_rt, task_is_throttled_rt, tg_has_rt_tasks, tg_rt_schedulable",
          "description": "实现实时任务的超时监控、时间片管理、任务组资源配额验证及实时任务运行时间统计功能，支持轮转调度下的时间片重置和任务重排。",
          "similarity": 0.5517100095748901
        }
      ]
    }
  ]
}