{
  "query": "系统调用表与中断处理函数映射",
  "timestamp": "2025-12-25 23:35:01",
  "retrieved_files": [
    {
      "source_file": "kernel/trace/trace_functions_graph.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:25:32\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_functions_graph.c`\n\n---\n\n# `trace/trace_functions_graph.c` 技术文档\n\n## 1. 文件概述\n\n`trace_functions_graph.c` 是 Linux 内核函数图追踪器（Function Graph Tracer）的核心实现文件。该追踪器用于记录函数调用的进入（entry）和返回（return）事件，并以树状结构（缩进形式）展示函数调用关系，支持深度控制、中断过滤、执行耗时统计、进程信息显示等功能。相比简单的函数追踪器（function tracer），函数图追踪器能提供更完整的调用上下文，适用于性能分析、延迟调试和代码路径可视化等场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct fgraph_cpu_data`**  \n  每 CPU 的函数图追踪状态数据，包含：\n  - `last_pid`：上次追踪的进程 PID\n  - `depth`：当前调用深度\n  - `depth_irq`：中断上下文中的调用深度\n  - `ignore`：是否忽略当前追踪\n  - `enter_funcs`：记录已进入但未返回的函数地址栈（最大深度为 `FTRACE_RETFUNC_DEPTH`）\n\n- **`struct fgraph_data`**  \n  全局函数图追踪数据结构，包含 per-CPU 数据指针、临时缓存的 entry/ret 条目及失败状态等。\n\n- **`tracer_flags` 与 `trace_opts`**  \n  定义函数图追踪器的可配置选项，如是否显示 CPU、进程名、执行耗时、中断标记、绝对时间、返回值（需 `CONFIG_FUNCTION_GRAPH_RETVAL`）等。\n\n### 主要函数\n\n- **`__trace_graph_entry()` / `__trace_graph_return()`**  \n  底层函数，负责将函数进入/返回事件写入 ring buffer。\n\n- **`trace_graph_entry()` / `trace_graph_return()`**  \n  高层回调函数，由 ftrace 框架在函数进入/返回时调用，执行过滤、上下文检查、中断判断等逻辑后调用底层写入函数。\n\n- **`trace_graph_thresh_return()`**  \n  支持阈值过滤的返回处理函数：仅当函数执行时间超过 `tracing_thresh` 时才记录返回事件。\n\n- **`ftrace_graph_ignore_irqs()`**  \n  判断是否应忽略中断上下文中的函数调用（由 `ftrace_graph_skip_irqs` 控制）。\n\n- **`trace_graph_function()`**  \n  用于直接追踪单个函数调用（无嵌套），常用于调试或特殊追踪场景。\n\n- **`allocate_fgraph_ops()`**  \n  为指定的 `trace_array` 分配并初始化 `fgraph_ops` 结构体（代码片段中未完整展示）。\n\n## 3. 关键实现\n\n### 调用图构建机制\n函数图追踪器通过 hook 函数的进入和返回点，记录每个函数的调用深度和执行时间。进入时记录 `calltime` 和深度，返回时记录 `rettime`，两者之差即为函数执行耗时。通过 per-CPU 的 `enter_funcs` 栈维护调用关系，确保嵌套调用的正确匹配。\n\n### 中断与过滤处理\n- 若 `ftrace_graph_skip_irqs` 为真且当前处于硬中断上下文，则跳过追踪。\n- 支持通过 `set_graph_notrace` 排除特定函数，使用 `TRACE_GRAPH_NOTRACE_BIT` 标记任务变量以临时禁用追踪，并在返回时恢复。\n- 支持基于执行时间阈值（`tracing_thresh`）的过滤：仅记录耗时超过阈值的函数。\n\n### 输出格式控制\n通过 `tracer_flags` 动态控制输出内容，包括：\n- 缩进（每层 2 空格）\n- 是否显示 CPU、进程名、执行耗时、绝对时间\n- 中断标记（如 `!` 表示中断发生）\n- 函数返回值（需配置支持）\n- 睡眠时间（调度出的时间）是否计入总耗时\n\n### 并发与中断安全\n使用 `local_irq_save/restore` 禁用本地中断，并通过 `atomic_inc_return(&data->disabled)` 实现 per-CPU 缓冲区的嵌套保护，确保在中断或 NMI 上下文中不会破坏 ring buffer 的一致性。\n\n## 4. 依赖关系\n\n- **`<linux/ftrace.h>`**：提供 ftrace 核心 API，如 `ftrace_graph_ent`、`ftrace_graph_ret`、`ftrace_ops` 等。\n- **`\"trace.h\"` / `\"trace_output.h\"`**：内核追踪子系统内部头文件，定义 `trace_array`、`ring_buffer` 操作及事件输出格式。\n- **`CONFIG_FUNCTION_GRAPH_TRACER`**：必须启用此配置选项。\n- **`CONFIG_FUNCTION_GRAPH_RETVAL`（可选）**：启用函数返回值追踪。\n- **`CONFIG_FUNCTION_PROFILER`（可选）**：启用嵌套函数时间统计。\n\n## 5. 使用场景\n\n- **性能分析**：通过函数调用图识别热点路径和长延迟函数。\n- **延迟调试**：结合 `tracing_thresh` 过滤，聚焦于执行时间异常的函数。\n- **中断行为分析**：通过 `funcgraph-irqs` 选项观察中断对正常执行流的影响。\n- **代码路径验证**：确认特定功能的调用栈是否符合预期。\n- **系统启动/关机追踪**：在早期启动阶段启用，分析初始化流程。\n\n该追踪器可通过 `/sys/kernel/debug/tracing/` 接口配置和读取，是 Linux 内核动态追踪基础设施的重要组成部分。",
      "similarity": 0.6218124032020569,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/trace/trace_functions_graph.c",
          "start_line": 808,
          "end_line": 926,
          "content": [
            "static enum print_line_t",
            "print_graph_entry_nested(struct trace_iterator *iter,",
            "\t\t\t struct ftrace_graph_ent_entry *entry,",
            "\t\t\t struct trace_seq *s, int cpu, u32 flags)",
            "{",
            "\tstruct ftrace_graph_ent *call = &entry->graph_ent;",
            "\tstruct fgraph_data *data = iter->private;",
            "\tstruct trace_array *tr = iter->tr;",
            "\tint i;",
            "",
            "\tif (data) {",
            "\t\tstruct fgraph_cpu_data *cpu_data;",
            "\t\tint cpu = iter->cpu;",
            "",
            "\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);",
            "\t\tcpu_data->depth = call->depth;",
            "",
            "\t\t/* Save this function pointer to see if the exit matches */",
            "\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&",
            "\t\t    !WARN_ON_ONCE(call->depth < 0))",
            "\t\t\tcpu_data->enter_funcs[call->depth] = call->func;",
            "\t}",
            "",
            "\t/* No time */",
            "\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);",
            "",
            "\t/* Function */",
            "\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)",
            "\t\ttrace_seq_putc(s, ' ');",
            "",
            "\ttrace_seq_printf(s, \"%ps() {\\n\", (void *)call->func);",
            "",
            "\tif (trace_seq_has_overflowed(s))",
            "\t\treturn TRACE_TYPE_PARTIAL_LINE;",
            "",
            "\t/*",
            "\t * we already consumed the current entry to check the next one",
            "\t * and see if this is a leaf.",
            "\t */",
            "\treturn TRACE_TYPE_NO_CONSUME;",
            "}",
            "static void",
            "print_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,",
            "\t\t     int type, unsigned long addr, u32 flags)",
            "{",
            "\tstruct fgraph_data *data = iter->private;",
            "\tstruct trace_entry *ent = iter->ent;",
            "\tstruct trace_array *tr = iter->tr;",
            "\tint cpu = iter->cpu;",
            "",
            "\t/* Pid */",
            "\tverif_pid(s, ent->pid, cpu, data);",
            "",
            "\tif (type)",
            "\t\t/* Interrupt */",
            "\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);",
            "",
            "\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))",
            "\t\treturn;",
            "",
            "\t/* Absolute time */",
            "\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)",
            "\t\tprint_graph_abs_time(iter->ts, s);",
            "",
            "\t/* Relative time */",
            "\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)",
            "\t\tprint_graph_rel_time(iter, s);",
            "",
            "\t/* Cpu */",
            "\tif (flags & TRACE_GRAPH_PRINT_CPU)",
            "\t\tprint_graph_cpu(s, cpu);",
            "",
            "\t/* Proc */",
            "\tif (flags & TRACE_GRAPH_PRINT_PROC) {",
            "\t\tprint_graph_proc(s, ent->pid);",
            "\t\ttrace_seq_puts(s, \" | \");",
            "\t}",
            "",
            "\t/* Latency format */",
            "\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)",
            "\t\tprint_graph_lat_fmt(s, ent);",
            "",
            "\treturn;",
            "}",
            "static int",
            "check_irq_entry(struct trace_iterator *iter, u32 flags,",
            "\t\tunsigned long addr, int depth)",
            "{",
            "\tint cpu = iter->cpu;",
            "\tint *depth_irq;",
            "\tstruct fgraph_data *data = iter->private;",
            "",
            "\t/*",
            "\t * If we are either displaying irqs, or we got called as",
            "\t * a graph event and private data does not exist,",
            "\t * then we bypass the irq check.",
            "\t */",
            "\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||",
            "\t    (!data))",
            "\t\treturn 0;",
            "",
            "\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);",
            "",
            "\t/*",
            "\t * We are inside the irq code",
            "\t */",
            "\tif (*depth_irq >= 0)",
            "\t\treturn 1;",
            "",
            "\tif ((addr < (unsigned long)__irqentry_text_start) ||",
            "\t    (addr >= (unsigned long)__irqentry_text_end))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * We are entering irq code.",
            "\t */",
            "\t*depth_irq = depth;",
            "\treturn 1;",
            "}"
          ],
          "function_name": "print_graph_entry_nested, print_graph_prologue, check_irq_entry",
          "description": "该代码段实现函数调用图追踪的核心逻辑，包含三个关键函数：  \n1. `print_graph_entry_nested` 处理函数进入事件，维护调用栈深度并记录函数指针，格式化输出函数名及缩进；  \n2. `print_graph_prologue` 输出跟踪事件的上下文信息（如 PID、中断状态、时间戳等），根据标志位控制内容显示；  \n3. `check_irq_entry` 判断当前执行是否进入中断处理代码，通过地址范围与深度变量辅助识别中断函数。",
          "similarity": 0.6389796733856201
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/trace/trace_functions_graph.c",
          "start_line": 952,
          "end_line": 1106,
          "content": [
            "static int",
            "check_irq_return(struct trace_iterator *iter, u32 flags, int depth)",
            "{",
            "\tint cpu = iter->cpu;",
            "\tint *depth_irq;",
            "\tstruct fgraph_data *data = iter->private;",
            "",
            "\t/*",
            "\t * If we are either displaying irqs, or we got called as",
            "\t * a graph event and private data does not exist,",
            "\t * then we bypass the irq check.",
            "\t */",
            "\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||",
            "\t    (!data))",
            "\t\treturn 0;",
            "",
            "\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);",
            "",
            "\t/*",
            "\t * We are not inside the irq code.",
            "\t */",
            "\tif (*depth_irq == -1)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * We are inside the irq code, and this is returning entry.",
            "\t * Let's not trace it and clear the entry depth, since",
            "\t * we are out of irq code.",
            "\t *",
            "\t * This condition ensures that we 'leave the irq code' once",
            "\t * we are out of the entry depth. Thus protecting us from",
            "\t * the RETURN entry loss.",
            "\t */",
            "\tif (*depth_irq >= depth) {",
            "\t\t*depth_irq = -1;",
            "\t\treturn 1;",
            "\t}",
            "",
            "\t/*",
            "\t * We are inside the irq code, and this is not the entry.",
            "\t */",
            "\treturn 1;",
            "}",
            "static enum print_line_t",
            "print_graph_entry(struct ftrace_graph_ent_entry *field, struct trace_seq *s,",
            "\t\t\tstruct trace_iterator *iter, u32 flags)",
            "{",
            "\tstruct fgraph_data *data = iter->private;",
            "\tstruct ftrace_graph_ent *call = &field->graph_ent;",
            "\tstruct ftrace_graph_ret_entry *leaf_ret;",
            "\tstatic enum print_line_t ret;",
            "\tint cpu = iter->cpu;",
            "",
            "\tif (check_irq_entry(iter, flags, call->func, call->depth))",
            "\t\treturn TRACE_TYPE_HANDLED;",
            "",
            "\tprint_graph_prologue(iter, s, TRACE_GRAPH_ENT, call->func, flags);",
            "",
            "\tleaf_ret = get_return_for_leaf(iter, field);",
            "\tif (leaf_ret)",
            "\t\tret = print_graph_entry_leaf(iter, field, leaf_ret, s, flags);",
            "\telse",
            "\t\tret = print_graph_entry_nested(iter, field, s, cpu, flags);",
            "",
            "\tif (data) {",
            "\t\t/*",
            "\t\t * If we failed to write our output, then we need to make",
            "\t\t * note of it. Because we already consumed our entry.",
            "\t\t */",
            "\t\tif (s->full) {",
            "\t\t\tdata->failed = 1;",
            "\t\t\tdata->cpu = cpu;",
            "\t\t} else",
            "\t\t\tdata->failed = 0;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static enum print_line_t",
            "print_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,",
            "\t\t   struct trace_entry *ent, struct trace_iterator *iter,",
            "\t\t   u32 flags)",
            "{",
            "\tunsigned long long duration = trace->rettime - trace->calltime;",
            "\tstruct fgraph_data *data = iter->private;",
            "\tstruct trace_array *tr = iter->tr;",
            "\tpid_t pid = ent->pid;",
            "\tint cpu = iter->cpu;",
            "\tint func_match = 1;",
            "\tint i;",
            "",
            "\tif (check_irq_return(iter, flags, trace->depth))",
            "\t\treturn TRACE_TYPE_HANDLED;",
            "",
            "\tif (data) {",
            "\t\tstruct fgraph_cpu_data *cpu_data;",
            "\t\tint cpu = iter->cpu;",
            "",
            "\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);",
            "",
            "\t\t/*",
            "\t\t * Comments display at + 1 to depth. This is the",
            "\t\t * return from a function, we now want the comments",
            "\t\t * to display at the same level of the bracket.",
            "\t\t */",
            "\t\tcpu_data->depth = trace->depth - 1;",
            "",
            "\t\tif (trace->depth < FTRACE_RETFUNC_DEPTH &&",
            "\t\t    !WARN_ON_ONCE(trace->depth < 0)) {",
            "\t\t\tif (cpu_data->enter_funcs[trace->depth] != trace->func)",
            "\t\t\t\tfunc_match = 0;",
            "\t\t\tcpu_data->enter_funcs[trace->depth] = 0;",
            "\t\t}",
            "\t}",
            "",
            "\tprint_graph_prologue(iter, s, 0, 0, flags);",
            "",
            "\t/* Overhead and duration */",
            "\tprint_graph_duration(tr, duration, s, flags);",
            "",
            "\t/* Closing brace */",
            "\tfor (i = 0; i < trace->depth * TRACE_GRAPH_INDENT; i++)",
            "\t\ttrace_seq_putc(s, ' ');",
            "",
            "\t/*",
            "\t * Always write out the function name and its return value if the",
            "\t * function-retval option is enabled.",
            "\t */",
            "\tif (flags & __TRACE_GRAPH_PRINT_RETVAL) {",
            "\t\tprint_graph_retval(s, trace->retval, false, (void *)trace->func,",
            "\t\t\t!!(flags & TRACE_GRAPH_PRINT_RETVAL_HEX));",
            "\t} else {",
            "\t\t/*",
            "\t\t * If the return function does not have a matching entry,",
            "\t\t * then the entry was lost. Instead of just printing",
            "\t\t * the '}' and letting the user guess what function this",
            "\t\t * belongs to, write out the function name. Always do",
            "\t\t * that if the funcgraph-tail option is enabled.",
            "\t\t */",
            "\t\tif (func_match && !(flags & TRACE_GRAPH_PRINT_TAIL))",
            "\t\t\ttrace_seq_puts(s, \"}\\n\");",
            "\t\telse",
            "\t\t\ttrace_seq_printf(s, \"} /* %ps */\\n\", (void *)trace->func);",
            "\t}",
            "",
            "\t/* Overrun */",
            "\tif (flags & TRACE_GRAPH_PRINT_OVERRUN)",
            "\t\ttrace_seq_printf(s, \" (Overruns: %u)\\n\",",
            "\t\t\t\t trace->overrun);",
            "",
            "\tprint_graph_irq(iter, trace->func, TRACE_GRAPH_RET,",
            "\t\t\tcpu, pid, flags);",
            "",
            "\treturn trace_handle_return(s);",
            "}"
          ],
          "function_name": "check_irq_return, print_graph_entry, print_graph_return",
          "description": "该代码段实现了ftrace图形化函数追踪中的中断保护逻辑及函数调用栈可视化功能。`check_irq_return`检测中断上下文并调整深度标记以避免返回事件丢失；`print_graph_entry`处理函数入口记录并触发嵌套调用跟踪；`print_graph_return`输出函数返回信息并修复潜在的调用链断裂问题。由于缺少`check_irq_entry`函数定义，上下文存在不完整性。",
          "similarity": 0.6368352174758911
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/trace/trace_functions_graph.c",
          "start_line": 1240,
          "end_line": 1375,
          "content": [
            "static enum print_line_t",
            "print_graph_function(struct trace_iterator *iter)",
            "{",
            "\treturn print_graph_function_flags(iter, tracer_flags.val);",
            "}",
            "static enum print_line_t",
            "print_graph_function_event(struct trace_iterator *iter, int flags,",
            "\t\t\t   struct trace_event *event)",
            "{",
            "\treturn print_graph_function(iter);",
            "}",
            "static void print_lat_header(struct seq_file *s, u32 flags)",
            "{",
            "\tstatic const char spaces[] = \"                \"\t/* 16 spaces */",
            "\t\t\"    \"\t\t\t\t\t/* 4 spaces */",
            "\t\t\"                 \";\t\t\t/* 17 spaces */",
            "\tint size = 0;",
            "",
            "\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)",
            "\t\tsize += 16;",
            "\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)",
            "\t\tsize += 16;",
            "\tif (flags & TRACE_GRAPH_PRINT_CPU)",
            "\t\tsize += 4;",
            "\tif (flags & TRACE_GRAPH_PRINT_PROC)",
            "\t\tsize += 17;",
            "",
            "\tseq_printf(s, \"#%.*s  _-----=> irqs-off        \\n\", size, spaces);",
            "\tseq_printf(s, \"#%.*s / _----=> need-resched    \\n\", size, spaces);",
            "\tseq_printf(s, \"#%.*s| / _---=> hardirq/softirq \\n\", size, spaces);",
            "\tseq_printf(s, \"#%.*s|| / _--=> preempt-depth   \\n\", size, spaces);",
            "\tseq_printf(s, \"#%.*s||| /                      \\n\", size, spaces);",
            "}",
            "static void __print_graph_headers_flags(struct trace_array *tr,",
            "\t\t\t\t\tstruct seq_file *s, u32 flags)",
            "{",
            "\tint lat = tr->trace_flags & TRACE_ITER_LATENCY_FMT;",
            "",
            "\tif (lat)",
            "\t\tprint_lat_header(s, flags);",
            "",
            "\t/* 1st line */",
            "\tseq_putc(s, '#');",
            "\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)",
            "\t\tseq_puts(s, \"     TIME       \");",
            "\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)",
            "\t\tseq_puts(s, \"   REL TIME     \");",
            "\tif (flags & TRACE_GRAPH_PRINT_CPU)",
            "\t\tseq_puts(s, \" CPU\");",
            "\tif (flags & TRACE_GRAPH_PRINT_PROC)",
            "\t\tseq_puts(s, \"  TASK/PID       \");",
            "\tif (lat)",
            "\t\tseq_puts(s, \"||||   \");",
            "\tif (flags & TRACE_GRAPH_PRINT_DURATION)",
            "\t\tseq_puts(s, \"  DURATION   \");",
            "\tseq_puts(s, \"               FUNCTION CALLS\\n\");",
            "",
            "\t/* 2nd line */",
            "\tseq_putc(s, '#');",
            "\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)",
            "\t\tseq_puts(s, \"      |         \");",
            "\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)",
            "\t\tseq_puts(s, \"      |         \");",
            "\tif (flags & TRACE_GRAPH_PRINT_CPU)",
            "\t\tseq_puts(s, \" |  \");",
            "\tif (flags & TRACE_GRAPH_PRINT_PROC)",
            "\t\tseq_puts(s, \"   |    |        \");",
            "\tif (lat)",
            "\t\tseq_puts(s, \"||||   \");",
            "\tif (flags & TRACE_GRAPH_PRINT_DURATION)",
            "\t\tseq_puts(s, \"   |   |      \");",
            "\tseq_puts(s, \"               |   |   |   |\\n\");",
            "}",
            "static void print_graph_headers(struct seq_file *s)",
            "{",
            "\tprint_graph_headers_flags(s, tracer_flags.val);",
            "}",
            "void print_graph_headers_flags(struct seq_file *s, u32 flags)",
            "{",
            "\tstruct trace_iterator *iter = s->private;",
            "\tstruct trace_array *tr = iter->tr;",
            "",
            "\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))",
            "\t\treturn;",
            "",
            "\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {",
            "\t\t/* print nothing if the buffers are empty */",
            "\t\tif (trace_empty(iter))",
            "\t\t\treturn;",
            "",
            "\t\tprint_trace_header(s, iter);",
            "\t}",
            "",
            "\t__print_graph_headers_flags(tr, s, flags);",
            "}",
            "void graph_trace_open(struct trace_iterator *iter)",
            "{",
            "\t/* pid and depth on the last trace processed */",
            "\tstruct fgraph_data *data;",
            "\tgfp_t gfpflags;",
            "\tint cpu;",
            "",
            "\titer->private = NULL;",
            "",
            "\t/* We can be called in atomic context via ftrace_dump() */",
            "\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;",
            "",
            "\tdata = kzalloc(sizeof(*data), gfpflags);",
            "\tif (!data)",
            "\t\tgoto out_err;",
            "",
            "\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);",
            "\tif (!data->cpu_data)",
            "\t\tgoto out_err_free;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);",
            "\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);",
            "\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);",
            "\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);",
            "",
            "\t\t*pid = -1;",
            "\t\t*depth = 0;",
            "\t\t*ignore = 0;",
            "\t\t*depth_irq = -1;",
            "\t}",
            "",
            "\titer->private = data;",
            "",
            "\treturn;",
            "",
            " out_err_free:",
            "\tkfree(data);",
            " out_err:",
            "\tpr_warn(\"function graph tracer: not enough memory\\n\");",
            "}"
          ],
          "function_name": "print_graph_function, print_graph_function_event, print_lat_header, __print_graph_headers_flags, print_graph_headers, print_graph_headers_flags, graph_trace_open",
          "description": "该代码段实现了函数调用图跟踪功能的核心逻辑。  \n`print_lat_header` 根据标志位生成延迟跟踪的注释表头，`__print_graph_headers_flags` 和 `print_graph_headers` 动态构建包含时间、CPU、进程等信息的跟踪表头。  \n`graph_trace_open` 初始化跟踪迭代器的私有数据结构，为每CPU分配深度计数器和PID缓存，支持函数调用图的上下文追踪。",
          "similarity": 0.6106153726577759
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_functions_graph.c",
          "start_line": 101,
          "end_line": 202,
          "content": [
            "int __trace_graph_entry(struct trace_array *tr,",
            "\t\t\t\tstruct ftrace_graph_ent *trace,",
            "\t\t\t\tunsigned int trace_ctx)",
            "{",
            "\tstruct trace_event_call *call = &event_funcgraph_entry;",
            "\tstruct ring_buffer_event *event;",
            "\tstruct trace_buffer *buffer = tr->array_buffer.buffer;",
            "\tstruct ftrace_graph_ent_entry *entry;",
            "",
            "\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,",
            "\t\t\t\t\t  sizeof(*entry), trace_ctx);",
            "\tif (!event)",
            "\t\treturn 0;",
            "\tentry\t= ring_buffer_event_data(event);",
            "\tentry->graph_ent\t\t\t= *trace;",
            "\tif (!call_filter_check_discard(call, entry, buffer, event))",
            "\t\ttrace_buffer_unlock_commit_nostack(buffer, event);",
            "",
            "\treturn 1;",
            "}",
            "static inline int ftrace_graph_ignore_irqs(void)",
            "{",
            "\tif (!ftrace_graph_skip_irqs || trace_recursion_test(TRACE_IRQ_BIT))",
            "\t\treturn 0;",
            "",
            "\treturn in_hardirq();",
            "}",
            "int trace_graph_entry(struct ftrace_graph_ent *trace,",
            "\t\t      struct fgraph_ops *gops,",
            "\t\t      struct ftrace_regs *fregs)",
            "{",
            "\tunsigned long *task_var = fgraph_get_task_var(gops);",
            "\tstruct trace_array *tr = gops->private;",
            "\tstruct trace_array_cpu *data;",
            "\tstruct fgraph_times *ftimes;",
            "\tunsigned int trace_ctx;",
            "\tlong disabled;",
            "\tint ret = 0;",
            "\tint cpu;",
            "",
            "\tif (*task_var & TRACE_GRAPH_NOTRACE)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * Do not trace a function if it's filtered by set_graph_notrace.",
            "\t * Make the index of ret stack negative to indicate that it should",
            "\t * ignore further functions.  But it needs its own ret stack entry",
            "\t * to recover the original index in order to continue tracing after",
            "\t * returning from the function.",
            "\t */",
            "\tif (ftrace_graph_notrace_addr(trace->func)) {",
            "\t\t*task_var |= TRACE_GRAPH_NOTRACE_BIT;",
            "\t\t/*",
            "\t\t * Need to return 1 to have the return called",
            "\t\t * that will clear the NOTRACE bit.",
            "\t\t */",
            "\t\treturn 1;",
            "\t}",
            "",
            "\tif (!ftrace_trace_task(tr))",
            "\t\treturn 0;",
            "",
            "\tif (ftrace_graph_ignore_func(gops, trace))",
            "\t\treturn 0;",
            "",
            "\tif (ftrace_graph_ignore_irqs())",
            "\t\treturn 0;",
            "",
            "\tif (fgraph_sleep_time) {",
            "\t\t/* Only need to record the calltime */",
            "\t\tftimes = fgraph_reserve_data(gops->idx, sizeof(ftimes->calltime));",
            "\t} else {",
            "\t\tftimes = fgraph_reserve_data(gops->idx, sizeof(*ftimes));",
            "\t\tif (ftimes)",
            "\t\t\tftimes->sleeptime = current->ftrace_sleeptime;",
            "\t}",
            "\tif (!ftimes)",
            "\t\treturn 0;",
            "",
            "\tftimes->calltime = trace_clock_local();",
            "",
            "\t/*",
            "\t * Stop here if tracing_threshold is set. We only write function return",
            "\t * events to the ring buffer.",
            "\t */",
            "\tif (tracing_thresh)",
            "\t\treturn 1;",
            "",
            "\tpreempt_disable_notrace();",
            "\tcpu = raw_smp_processor_id();",
            "\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "\tdisabled = atomic_read(&data->disabled);",
            "\tif (likely(!disabled)) {",
            "\t\ttrace_ctx = tracing_gen_ctx();",
            "\t\tret = __trace_graph_entry(tr, trace, trace_ctx);",
            "\t} else {",
            "\t\tret = 0;",
            "\t}",
            "\tpreempt_enable_notrace();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__trace_graph_entry, ftrace_graph_ignore_irqs, trace_graph_entry",
          "description": "实现函数入口追踪逻辑，包含检查中断忽略标记的辅助函数，及主函数trace_graph_entry用于过滤不需要跟踪的函数并记录入口事件。",
          "similarity": 0.607842743396759
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_functions_graph.c",
          "start_line": 211,
          "end_line": 328,
          "content": [
            "static void",
            "__trace_graph_function(struct trace_array *tr,",
            "\t\tunsigned long ip, unsigned int trace_ctx)",
            "{",
            "\tu64 time = trace_clock_local();",
            "\tstruct ftrace_graph_ent ent = {",
            "\t\t.func  = ip,",
            "\t\t.depth = 0,",
            "\t};",
            "\tstruct ftrace_graph_ret ret = {",
            "\t\t.func     = ip,",
            "\t\t.depth    = 0,",
            "\t\t.calltime = time,",
            "\t\t.rettime  = time,",
            "\t};",
            "",
            "\t__trace_graph_entry(tr, &ent, trace_ctx);",
            "\t__trace_graph_return(tr, &ret, trace_ctx);",
            "}",
            "void",
            "trace_graph_function(struct trace_array *tr,",
            "\t\tunsigned long ip, unsigned long parent_ip,",
            "\t\tunsigned int trace_ctx)",
            "{",
            "\t__trace_graph_function(tr, ip, trace_ctx);",
            "}",
            "void __trace_graph_return(struct trace_array *tr,",
            "\t\t\t\tstruct ftrace_graph_ret *trace,",
            "\t\t\t\tunsigned int trace_ctx)",
            "{",
            "\tstruct trace_event_call *call = &event_funcgraph_exit;",
            "\tstruct ring_buffer_event *event;",
            "\tstruct trace_buffer *buffer = tr->array_buffer.buffer;",
            "\tstruct ftrace_graph_ret_entry *entry;",
            "",
            "\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,",
            "\t\t\t\t\t  sizeof(*entry), trace_ctx);",
            "\tif (!event)",
            "\t\treturn;",
            "\tentry\t= ring_buffer_event_data(event);",
            "\tentry->ret\t\t\t\t= *trace;",
            "\tif (!call_filter_check_discard(call, entry, buffer, event))",
            "\t\ttrace_buffer_unlock_commit_nostack(buffer, event);",
            "}",
            "static void handle_nosleeptime(struct ftrace_graph_ret *trace,",
            "\t\t\t       struct fgraph_times *ftimes,",
            "\t\t\t       int size)",
            "{",
            "\tif (fgraph_sleep_time || size < sizeof(*ftimes))",
            "\t\treturn;",
            "",
            "\tftimes->calltime += current->ftrace_sleeptime - ftimes->sleeptime;",
            "}",
            "void trace_graph_return(struct ftrace_graph_ret *trace,",
            "\t\t\tstruct fgraph_ops *gops, struct ftrace_regs *fregs)",
            "{",
            "\tunsigned long *task_var = fgraph_get_task_var(gops);",
            "\tstruct trace_array *tr = gops->private;",
            "\tstruct trace_array_cpu *data;",
            "\tstruct fgraph_times *ftimes;",
            "\tunsigned int trace_ctx;",
            "\tlong disabled;",
            "\tint size;",
            "\tint cpu;",
            "",
            "\tftrace_graph_addr_finish(gops, trace);",
            "",
            "\tif (*task_var & TRACE_GRAPH_NOTRACE) {",
            "\t\t*task_var &= ~TRACE_GRAPH_NOTRACE;",
            "\t\treturn;",
            "\t}",
            "",
            "\tftimes = fgraph_retrieve_data(gops->idx, &size);",
            "\tif (!ftimes)",
            "\t\treturn;",
            "",
            "\thandle_nosleeptime(trace, ftimes, size);",
            "",
            "\ttrace->calltime = ftimes->calltime;",
            "",
            "\tpreempt_disable_notrace();",
            "\tcpu = raw_smp_processor_id();",
            "\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "\tdisabled = atomic_read(&data->disabled);",
            "\tif (likely(!disabled)) {",
            "\t\ttrace_ctx = tracing_gen_ctx();",
            "\t\t__trace_graph_return(tr, trace, trace_ctx);",
            "\t}",
            "\tpreempt_enable_notrace();",
            "}",
            "static void trace_graph_thresh_return(struct ftrace_graph_ret *trace,",
            "\t\t\t\t      struct fgraph_ops *gops,",
            "\t\t\t\t      struct ftrace_regs *fregs)",
            "{",
            "\tstruct fgraph_times *ftimes;",
            "\tint size;",
            "",
            "\tftrace_graph_addr_finish(gops, trace);",
            "",
            "\tif (trace_recursion_test(TRACE_GRAPH_NOTRACE_BIT)) {",
            "\t\ttrace_recursion_clear(TRACE_GRAPH_NOTRACE_BIT);",
            "\t\treturn;",
            "\t}",
            "",
            "\tftimes = fgraph_retrieve_data(gops->idx, &size);",
            "\tif (!ftimes)",
            "\t\treturn;",
            "",
            "\thandle_nosleeptime(trace, ftimes, size);",
            "",
            "\ttrace->calltime = ftimes->calltime;",
            "",
            "\tif (tracing_thresh &&",
            "\t    (trace->rettime - ftimes->calltime < tracing_thresh))",
            "\t\treturn;",
            "\telse",
            "\t\ttrace_graph_return(trace, gops, fregs);",
            "}"
          ],
          "function_name": "__trace_graph_function, trace_graph_function, __trace_graph_return, handle_nosleeptime, trace_graph_return, trace_graph_thresh_return",
          "description": "处理函数执行和返回的跟踪事件，包含计算时间和睡眠时间差异的逻辑，以及返回事件的提交流程。",
          "similarity": 0.5984317064285278
        }
      ]
    },
    {
      "source_file": "kernel/irq/timings.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:10:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\timings.c`\n\n---\n\n# irq/timings.c 技术文档\n\n## 1. 文件概述\n\n`irq/timings.c` 是 Linux 内核中用于中断时间预测的核心模块。该文件实现了基于历史中断时间戳的预测算法，旨在通过分析中断发生的周期性模式，预测下一次中断可能发生的时间。此功能主要用于低功耗场景（如 CPU 空闲状态管理），帮助调度器或电源管理子系统更精确地设置唤醒时间，从而在保证响应性的同时减少不必要的唤醒开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irq_timings`：每个 CPU 私有的中断时间记录结构，包含一个循环缓冲区，用于存储 `<中断号, 时间戳>` 元组。\n- `irqt_stats`：全局 IDR（整数到指针映射）结构，用于按中断号索引中断统计信息。\n- `irq_timing_enabled`：静态分支键（`static_key`），用于在运行时动态启用/禁用中断时间跟踪功能，避免性能开销。\n\n### 主要函数\n\n- `irq_timings_enable(void)`：启用中断时间跟踪功能，激活静态分支。\n- `irq_timings_disable(void)`：禁用中断时间跟踪功能，关闭静态分支。\n- （注：实际的预测算法逻辑虽未在代码片段中完整展示，但文档详细描述了其实现原理）\n\n## 3. 关键实现\n\n### 中断时间预测算法\n\n该模块采用三阶段算法预测中断周期：\n\n#### 1) 后缀数组（Suffix Array）模式识别\n- 将中断间隔（经 `ilog2` 映射后的索引值）序列视为字符串。\n- 构建长度为 2 到 5 的后缀（受限于实际设备周期经验）。\n- 在最近 `3 × max_period`（即 15）个索引中搜索后缀的重复出现。\n- 若某后缀连续出现 3 次，则认为发现有效周期模式，其长度即为预测周期。\n\n#### 2) 对数间隔桶（Log Interval Bucketing）\n- 使用 `ilog2(interval)` 将原始时间间隔映射到 0~63 的桶索引（因 `u64` 最大为 2^64）。\n- 该方法将大范围的时间值压缩到小数组中，例如值 1123 映射到索引 10（因 2^10 = 1024 ≤ 1123 < 2048 = 2^11）。\n\n#### 3) 指数移动平均（Exponential Moving Average, EMA）\n- 每个桶维护一个 EMA 值，用于平滑同一数量级间隔的波动。\n- EMA 公式使平均值对新数据具有可调的响应速度（通过 alpha 参数隐式控制）。\n- 预测时，根据识别出的周期模式中的桶索引，返回对应桶的 EMA 值作为预测间隔。\n\n### 工作流程\n1. 中断发生时，若 `irq_timing_enabled` 为真，则将 `<irq, timestamp>` 记录到 per-CPU 的循环缓冲区。\n2. 当需要预测某中断的下次发生时间时：\n   - 清空并处理循环缓冲区，将间隔数据分发到各中断的统计结构中。\n   - 对每个中断的间隔序列执行上述三阶段算法。\n   - 若找到重复模式，则用 EMA 值计算预测时间；否则返回未预测。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：实现 per-CPU 变量 `irq_timings`。\n  - `<linux/static_key.h>`：提供静态分支优化，避免未启用时的条件判断开销。\n  - `<linux/math64.h>` 和 `<linux/log2.h>`：用于 `ilog2` 等数学运算。\n  - `<trace/events/irq.h>`：可能用于跟踪事件（虽未在片段中调用）。\n  - `\"internals.h\"`：内核中断子系统内部头文件。\n- **子系统依赖**：\n  - 通用中断子系统（`<linux/irq.h>`, `<linux/interrupt.h>`）。\n  - 内存管理（`<linux/slab.h>`）用于动态分配统计结构。\n  - IDR 机制（`<linux/idr.h>`）用于中断号到统计结构的映射。\n\n## 5. 使用场景\n\n- **CPU 空闲状态管理（cpuidle）**：在进入深度 C-state 前，预测下一次中断时间以设置精确的唤醒定时器，避免过早或过晚唤醒。\n- **实时系统调度**：辅助调度器预判周期性中断（如 tickless 系统中的高精度定时器），优化任务调度时机。\n- **电源管理**：结合设备驱动的中断模式，动态调整设备或 CPU 的电源状态。\n- **性能分析**：通过跟踪中断时间模式，诊断中断风暴或异常周期行为。\n\n该功能默认关闭，仅在需要时通过 `irq_timings_enable()` 动态启用，确保对常规系统性能无影响。",
      "similarity": 0.6176616549491882,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/timings.c",
          "start_line": 435,
          "end_line": 563,
          "content": [
            "static __always_inline int irq_timings_interval_index(u64 interval)",
            "{",
            "\t/*",
            "\t * The PREDICTION_FACTOR increase the interval size for the",
            "\t * array of exponential average.",
            "\t */",
            "\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;",
            "",
            "\treturn likely(interval_us) ? ilog2(interval_us) : 0;",
            "}",
            "static __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,",
            "\t\t\t\t\t\tu64 interval)",
            "{",
            "\tint index;",
            "",
            "\t/*",
            "\t * Get the index in the ema table for this interrupt.",
            "\t */",
            "\tindex = irq_timings_interval_index(interval);",
            "",
            "\tif (index > PREDICTION_BUFFER_SIZE - 1) {",
            "\t\tirqs->count = 0;",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Store the index as an element of the pattern in another",
            "\t * circular array.",
            "\t */",
            "\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;",
            "",
            "\tirqs->ema_time[index] = irq_timings_ema_new(interval,",
            "\t\t\t\t\t\t    irqs->ema_time[index]);",
            "",
            "\tirqs->count++;",
            "}",
            "static inline void irq_timings_store(int irq, struct irqt_stat *irqs, u64 ts)",
            "{",
            "\tu64 old_ts = irqs->last_ts;",
            "\tu64 interval;",
            "",
            "\t/*",
            "\t * The timestamps are absolute time values, we need to compute",
            "\t * the timing interval between two interrupts.",
            "\t */",
            "\tirqs->last_ts = ts;",
            "",
            "\t/*",
            "\t * The interval type is u64 in order to deal with the same",
            "\t * type in our computation, that prevent mindfuck issues with",
            "\t * overflow, sign and division.",
            "\t */",
            "\tinterval = ts - old_ts;",
            "",
            "\t/*",
            "\t * The interrupt triggered more than one second apart, that",
            "\t * ends the sequence as predictable for our purpose. In this",
            "\t * case, assume we have the beginning of a sequence and the",
            "\t * timestamp is the first value. As it is impossible to",
            "\t * predict anything at this point, return.",
            "\t *",
            "\t * Note the first timestamp of the sequence will always fall",
            "\t * in this test because the old_ts is zero. That is what we",
            "\t * want as we need another timestamp to compute an interval.",
            "\t */",
            "\tif (interval >= NSEC_PER_SEC) {",
            "\t\tirqs->count = 0;",
            "\t\treturn;",
            "\t}",
            "",
            "\t__irq_timings_store(irq, irqs, interval);",
            "}",
            "u64 irq_timings_next_event(u64 now)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tstruct irqt_stat *irqs;",
            "\tstruct irqt_stat __percpu *s;",
            "\tu64 ts, next_evt = U64_MAX;",
            "\tint i, irq = 0;",
            "",
            "\t/*",
            "\t * This function must be called with the local irq disabled in",
            "\t * order to prevent the timings circular buffer to be updated",
            "\t * while we are reading it.",
            "\t */",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\tif (!irqts->count)",
            "\t\treturn next_evt;",
            "",
            "\t/*",
            "\t * Number of elements in the circular buffer: If it happens it",
            "\t * was flushed before, then the number of elements could be",
            "\t * smaller than IRQ_TIMINGS_SIZE, so the count is used,",
            "\t * otherwise the array size is used as we wrapped. The index",
            "\t * begins from zero when we did not wrap. That could be done",
            "\t * in a nicer way with the proper circular array structure",
            "\t * type but with the cost of extra computation in the",
            "\t * interrupt handler hot path. We choose efficiency.",
            "\t *",
            "\t * Inject measured irq/timestamp to the pattern prediction",
            "\t * model while decrementing the counter because we consume the",
            "\t * data from our circular buffer.",
            "\t */",
            "\tfor_each_irqts(i, irqts) {",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "\t\ts = idr_find(&irqt_stats, irq);",
            "\t\tif (s)",
            "\t\t\tirq_timings_store(irq, this_cpu_ptr(s), ts);",
            "\t}",
            "",
            "\t/*",
            "\t * Look in the list of interrupts' statistics, the earliest",
            "\t * next event.",
            "\t */",
            "\tidr_for_each_entry(&irqt_stats, s, i) {",
            "",
            "\t\tirqs = this_cpu_ptr(s);",
            "",
            "\t\tts = __irq_timings_next_event(irqs, i, now);",
            "\t\tif (ts <= now)",
            "\t\t\treturn now;",
            "",
            "\t\tif (ts < next_evt)",
            "\t\t\tnext_evt = ts;",
            "\t}",
            "",
            "\treturn next_evt;",
            "}"
          ],
          "function_name": "irq_timings_interval_index, __irq_timings_store, irq_timings_store, irq_timings_next_event",
          "description": "提供时间间隔转索引的映射函数，实现环形缓冲区数据存储及主事件预测函数",
          "similarity": 0.6485385298728943
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/timings.c",
          "start_line": 26,
          "end_line": 165,
          "content": [
            "void irq_timings_enable(void)",
            "{",
            "\tstatic_branch_enable(&irq_timing_enabled);",
            "}",
            "void irq_timings_disable(void)",
            "{",
            "\tstatic_branch_disable(&irq_timing_enabled);",
            "}",
            "static u64 irq_timings_ema_new(u64 value, u64 ema_old)",
            "{",
            "\ts64 diff;",
            "",
            "\tif (unlikely(!ema_old))",
            "\t\treturn value;",
            "",
            "\tdiff = (value - ema_old) * EMA_ALPHA_VAL;",
            "\t/*",
            "\t * We can use a s64 type variable to be added with the u64",
            "\t * ema_old variable as this one will never have its topmost",
            "\t * bit set, it will be always smaller than 2^63 nanosec",
            "\t * interrupt interval (292 years).",
            "\t */",
            "\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);",
            "}",
            "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)",
            "{",
            "\tint period;",
            "",
            "\t/*",
            "\t * Move the beginning pointer to the end minus the max period x 3.",
            "\t * We are at the point we can begin searching the pattern",
            "\t */",
            "\tbuffer = &buffer[len - (period_max * 3)];",
            "",
            "\t/* Adjust the length to the maximum allowed period x 3 */",
            "\tlen = period_max * 3;",
            "",
            "\t/*",
            "\t * The buffer contains the suite of intervals, in a ilog2",
            "\t * basis, we are looking for a repetition. We point the",
            "\t * beginning of the search three times the length of the",
            "\t * period beginning at the end of the buffer. We do that for",
            "\t * each suffix.",
            "\t */",
            "\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {",
            "",
            "\t\t/*",
            "\t\t * The first comparison always succeed because the",
            "\t\t * suffix is deduced from the first n-period bytes of",
            "\t\t * the buffer and we compare the initial suffix with",
            "\t\t * itself, so we can skip the first iteration.",
            "\t\t */",
            "\t\tint idx = period;",
            "\t\tsize_t size = period;",
            "",
            "\t\t/*",
            "\t\t * We look if the suite with period 'i' repeat",
            "\t\t * itself. If it is truncated at the end, as it",
            "\t\t * repeats we can use the period to find out the next",
            "\t\t * element with the modulo.",
            "\t\t */",
            "\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {",
            "",
            "\t\t\t/*",
            "\t\t\t * Move the index in a period basis",
            "\t\t\t */",
            "\t\t\tidx += size;",
            "",
            "\t\t\t/*",
            "\t\t\t * If this condition is reached, all previous",
            "\t\t\t * memcmp were successful, so the period is",
            "\t\t\t * found.",
            "\t\t\t */",
            "\t\t\tif (idx == len)",
            "\t\t\t\treturn buffer[len % period];",
            "",
            "\t\t\t/*",
            "\t\t\t * If the remaining elements to compare are",
            "\t\t\t * smaller than the period, readjust the size",
            "\t\t\t * of the comparison for the last iteration.",
            "\t\t\t */",
            "\t\t\tif (len - idx < period)",
            "\t\t\t\tsize = len - idx;",
            "\t\t}",
            "\t}",
            "",
            "\treturn -1;",
            "}",
            "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)",
            "{",
            "\tint index, i, period_max, count, start, min = INT_MAX;",
            "",
            "\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {",
            "\t\tirqs->count = irqs->last_ts = 0;",
            "\t\treturn U64_MAX;",
            "\t}",
            "",
            "\t/*",
            "\t * As we want to find three times the repetition, we need a",
            "\t * number of intervals greater or equal to three times the",
            "\t * maximum period, otherwise we truncate the max period.",
            "\t */",
            "\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;",
            "",
            "\t/*",
            "\t * If we don't have enough irq timings for this prediction,",
            "\t * just bail out.",
            "\t */",
            "\tif (period_max <= PREDICTION_PERIOD_MIN)",
            "\t\treturn U64_MAX;",
            "",
            "\t/*",
            "\t * 'count' will depends if the circular buffer wrapped or not",
            "\t */",
            "\tcount = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\tirqs->count : IRQ_TIMINGS_SIZE;",
            "",
            "\tstart = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);",
            "",
            "\t/*",
            "\t * Copy the content of the circular buffer into another buffer",
            "\t * in order to linearize the buffer instead of dealing with",
            "\t * wrapping indexes and shifted array which will be prone to",
            "\t * error and extremely difficult to debug.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "",
            "\t\tirqs->timings[i] = irqs->circ_timings[index];",
            "\t\tmin = min_t(int, irqs->timings[i], min);",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);",
            "\tif (index < 0)",
            "\t\treturn irqs->last_ts + irqs->ema_time[min];",
            "",
            "\treturn irqs->last_ts + irqs->ema_time[index];",
            "}"
          ],
          "function_name": "irq_timings_enable, irq_timings_disable, irq_timings_ema_new, irq_timings_next_event_index, __irq_timings_next_event",
          "description": "实现中断计时功能的启用/禁用控制，EMA计算算法及基于模式匹配的周期预测核心逻辑",
          "similarity": 0.634076714515686
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/timings.c",
          "start_line": 594,
          "end_line": 739,
          "content": [
            "void irq_timings_free(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s) {",
            "\t\tfree_percpu(s);",
            "\t\tidr_remove(&irqt_stats, irq);",
            "\t}",
            "}",
            "int irq_timings_alloc(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tint id;",
            "",
            "\t/*",
            "\t * Some platforms can have the same private interrupt per cpu,",
            "\t * so this function may be called several times with the",
            "\t * same interrupt number. Just bail out in case the per cpu",
            "\t * stat structure is already allocated.",
            "\t */",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s)",
            "\t\treturn 0;",
            "",
            "\ts = alloc_percpu(*s);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\tidr_preload(GFP_KERNEL);",
            "\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);",
            "\tidr_preload_end();",
            "",
            "\tif (id < 0) {",
            "\t\tfree_percpu(s);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_test_next_index(struct timings_intervals *ti)",
            "{",
            "\tint _buffer[IRQ_TIMINGS_SIZE];",
            "\tint buffer[IRQ_TIMINGS_SIZE];",
            "\tint index, start, i, count, period_max;",
            "",
            "\tcount = ti->count - 1;",
            "",
            "\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : count / 3;",
            "",
            "\t/*",
            "\t * Inject all values except the last one which will be used",
            "\t * to compare with the next index result.",
            "\t */",
            "\tpr_debug(\"index suite: \");",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;",
            "\t\tpr_cont(\"%d \", index);",
            "\t}",
            "",
            "\tstart = count < IRQ_TIMINGS_SIZE ? 0 :",
            "\t\tcount & IRQ_TIMINGS_MASK;",
            "",
            "\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "\t\tbuffer[i] = _buffer[index];",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(buffer, count, period_max);",
            "\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);",
            "",
            "\tif (index != i) {",
            "\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",",
            "\t\t       i, index);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_next_index_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "",
            "\t\tret = irq_timings_test_next_index(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqs(struct timings_intervals *ti)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tstruct irqt_stat *irqs;",
            "\tint i, index, ret, irq = 0xACE5;",
            "",
            "\tret = irq_timings_alloc(irq);",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate irq timings\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (!s) {",
            "\t\tret = -EIDRM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tirqs = this_cpu_ptr(s);",
            "",
            "\tfor (i = 0; i < ti->count; i++) {",
            "",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",",
            "\t\t\t i, ti->intervals[i], index);",
            "",
            "\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);",
            "\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {",
            "\t\t\tret = -EBADSLT;",
            "\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (irqs->count != ti->count) {",
            "\t\tret = -ERANGE;",
            "\t\tpr_err(\"Count differs\\n\");",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "out:",
            "\tirq_timings_free(irq);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_free, irq_timings_alloc, irq_timings_test_next_index, irq_timings_next_index_selftest, irq_timings_test_irqs",
          "description": "实现中断统计结构的动态分配/释放机制，包含预测算法的自检测试函数",
          "similarity": 0.6105610132217407
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/timings.c",
          "start_line": 927,
          "end_line": 956,
          "content": [
            "static int __init irq_timings_selftest(void)",
            "{",
            "\tint ret;",
            "",
            "\tpr_info(\"------------------- selftest start -----------------\\n\");",
            "",
            "\t/*",
            "\t * At this point, we don't except any subsystem to use the irq",
            "\t * timings but us, so it should not be enabled.",
            "\t */",
            "\tif (static_branch_unlikely(&irq_timing_enabled)) {",
            "\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = irq_timings_irqts_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_irqs_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_next_index_selftest();",
            "out:",
            "\tpr_info(\"---------- selftest end with %s -----------\\n\",",
            "\t\tret ? \"failure\" : \"success\");",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_selftest",
          "description": "该代码段实现了中断定时功能的自我检测逻辑，用于验证中断时间戳、中断序列及索引管理等子系统的正确性。作为初始化函数，它通过调用三个子测试函数依次检查相关功能模块的行为是否符合预期。由于代码中引用了未展示的测试函数（如irq_timings_irqts_selftest），需结合上下文才能完整理解其工作机制。",
          "similarity": 0.5831828713417053
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/timings.c",
          "start_line": 1,
          "end_line": 25,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2016, Linaro Ltd - Daniel Lezcano <daniel.lezcano@linaro.org>",
            "#define pr_fmt(fmt) \"irq_timings: \" fmt",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/static_key.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/idr.h>",
            "#include <linux/irq.h>",
            "#include <linux/math64.h>",
            "#include <linux/log2.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(irq_timing_enabled);",
            "",
            "DEFINE_PER_CPU(struct irq_timings, irq_timings);",
            "",
            "static DEFINE_IDR(irqt_stats);",
            ""
          ],
          "function_name": null,
          "description": "定义中断计时模块的静态键开关和PER-CPU结构体，声明IDR管理器用于动态分配中断统计实例",
          "similarity": 0.5777402520179749
        }
      ]
    },
    {
      "source_file": "kernel/entry/common.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:19:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\common.c`\n\n---\n\n# entry\\common.c 技术文档\n\n## 文件概述\n\n`entry\\common.c` 是 Linux 内核中处理系统调用入口/出口以及中断入口/出口路径的通用逻辑实现文件。该文件提供了一套架构无关的通用函数，用于在用户态与内核态之间切换时执行必要的上下文跟踪、审计、跟踪点、安全检查（如 seccomp）、信号处理、调度等工作。其目标是统一不同架构在系统调用和中断处理路径上的共性逻辑，减少重复代码。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `syscall_trace_enter()` | 系统调用进入时的通用处理函数，依次处理用户态分发、ptrace 跟踪、seccomp 安全检查、tracepoint 和审计 |\n| `syscall_enter_from_user_mode_prepare()` | 从用户模式进入系统调用前的准备，启用中断并进入内核上下文 |\n| `exit_to_user_mode_loop()` | 在返回用户空间前循环处理所有待办工作项（如调度、信号、uprobe、livepatch 等） |\n| `syscall_exit_work()` | 系统调用退出时的通用处理，包括审计、tracepoint、ptrace 退出报告等 |\n| `irqentry_enter()` / `irqentry_exit()` | 中断入口/出口的通用处理，管理 RCU、上下文跟踪、KMSAN、lockdep 等 |\n| `irqentry_enter_from_user_mode()` / `irqentry_exit_to_user_mode()` | 从中断上下文进入/退出用户模式的专用路径 |\n| `raw_irqentry_exit_cond_resched()` | 中断退出时的条件调度检查（仅在非抢占计数为 0 时） |\n\n### 关键数据结构\n\n- `irqentry_state_t`：记录中断入口状态，主要用于判断是否需要在退出时执行 RCU 相关操作。\n- `SYSCALL_WORK_*` 和 `_TIF_*` 标志位：用于标识待处理的工作类型（如 trace、seccomp、信号、调度等）。\n\n## 关键实现\n\n### 系统调用入口处理流程（`syscall_trace_enter`）\n\n1. **Syscall User Dispatch 优先处理**：若设置了 `SYSCALL_WORK_SYSCALL_USER_DISPATCH`，调用 `syscall_user_dispatch()`，若返回 true 则直接终止系统调用（返回 `-1`），因为此时 ABI 可能无效。\n2. **Ptrace 跟踪**：若设置了 `SYSCALL_WORK_SYSCALL_TRACE` 或 `SYSCALL_WORK_SYSCALL_EMU`，调用 `ptrace_report_syscall_entry()`。若 tracer 修改了行为或启用了 `SYSCALL_EMU`，则终止系统调用。\n3. **Seccomp 安全检查**：在 ptrace 之后执行，以捕获 tracer 可能引入的变更。调用 `__secure_computing()`，若返回 `-1` 则拒绝系统调用。\n4. **重新获取系统调用号**：上述步骤可能修改了系统调用号，需重新通过 `syscall_get_nr()` 获取。\n5. **Tracepoint 触发**：若启用 `SYSCALL_WORK_SYSCALL_TRACEPOINT`，触发 `trace_sys_enter`，并再次重新获取系统调用号（因 BPF 或 kprobe 可能修改）。\n6. **审计日志**：调用 `syscall_enter_audit()` 记录审计事件。\n7. **返回最终系统调用号或错误码**。\n\n### 返回用户空间前的工作循环（`exit_to_user_mode_loop`）\n\n- 使用 `while (ti_work & EXIT_TO_USER_MODE_WORK)` 循环处理所有待办工作，确保在返回用户态前完成：\n  - 调度（`_TIF_NEED_RESCHED`）\n  - Uprobe 通知（`_TIF_UPROBE`）\n  - Livepatch 状态更新（`_TIF_PATCH_PENDING`）\n  - 信号处理（`_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL`）\n  - 用户态恢复工作（`_TIF_NOTIFY_RESUME`）\n  - 架构特定工作（`arch_exit_to_user_mode_work`）\n- 每次循环启用中断（`local_irq_enable_exit_to_user`），处理完后再关闭中断并重新读取线程标志（`read_thread_flags()`），以应对处理过程中新产生的工作项。\n- 最后调用 `tick_nohz_user_enter_prepare()` 处理 NO_HZ 模式下的 tick 准备。\n\n### 中断入口/出口的 RCU 与上下文管理\n\n- **从中断进入用户态**：调用 `enter_from_user_mode()`，启用中断。\n- **从内核态中断入口**：\n  - 若当前是 idle 任务且非 `TINY_RCU`，无条件调用 `ct_irq_enter()` 以确保 RCU 状态一致（避免嵌套中断导致 grace period 错误结束）。\n  - 否则调用 `rcu_irq_enter_check_tick()`。\n- 所有路径均正确处理 `lockdep`、`KMSAN`（解除寄存器毒化）和 `trace_hardirqs_off` 的顺序，确保调试和安全工具正常工作。\n\n### 条件调度支持（Preemption）\n\n- `raw_irqentry_exit_cond_resched()` 在中断退出且 `preempt_count() == 0` 时检查是否需要调度。\n- 支持动态抢占（`CONFIG_PREEMPT_DYNAMIC`），通过 `static_call` 或 `static_key` 实现运行时切换，避免编译时硬编码。\n\n## 依赖关系\n\n### 头文件依赖\n- `<linux/context_tracking.h>`：上下文跟踪（用户/内核态切换）\n- `<linux/resume_user_mode.h>`：用户态恢复工作\n- `<linux/seccomp.h>`（隐式通过 `__secure_computing`）：系统调用过滤\n- `<linux/audit.h>`：审计子系统\n- `<linux/ptrace.h>`（隐式）：ptrace 跟踪\n- `<linux/livepatch.h>`：内核热补丁\n- `<linux/uprobes.h>`（隐式）：用户态探针\n- `<linux/rcupdate.h>`：RCU 机制\n- `<linux/kmsan.h>`：Kernel Memory Sanitizer 支持\n- `<trace/events/syscalls.h>`：系统调用跟踪点\n\n### 架构依赖\n- 依赖架构特定实现：\n  - `syscall_get_arguments()` / `syscall_get_nr()` / `syscall_get_return_value()`\n  - `user_mode()` / `regs_irqs_disabled()`\n  - `arch_do_signal_or_restart()`（弱符号，默认空实现）\n  - `arch_exit_to_user_mode_work()`\n\n### 子系统交互\n- **RCU**：管理中断和用户态切换时的宽限期\n- **Scheduler**：处理 `need_resched()` 和 `schedule()`\n- **Security**：seccomp、audit\n- **Tracing**：ftrace、kprobe、uprobe、BPF\n- **Livepatch**：动态补丁状态更新\n\n## 使用场景\n\n1. **系统调用入口路径**：  \n   当用户程序执行 `syscall` 指令（或其他系统调用机制）进入内核时，架构代码调用 `syscall_trace_enter()` 执行通用预处理。\n\n2. **系统调用出口路径**：  \n   系统调用返回前，若存在待处理工作（如审计、tracepoint），调用 `syscall_exit_work()`。\n\n3. **中断处理返回用户空间**：  \n   中断处理完成后，若返回用户态，调用 `irqentry_exit_to_user_mode()`，进而触发 `exit_to_user_mode_loop()` 处理所有 pending work。\n\n4. **中断嵌套与 idle 任务处理**：  \n   在 idle 任务中发生中断时，确保 RCU 正确进入 IRQ 上下文，防止 grace period 错误终止。\n\n5. **动态抢占支持**：  \n   在支持动态抢占的系统中，中断退出时根据运行时配置决定是否执行条件调度。\n\n6. **调试与安全工具集成**：  \n   为 KMSAN、Lockdep、ftrace、audit、seccomp 等子系统提供统一的入口/出口钩子，确保工具链在系统调用和中断路径上正常工作。",
      "similarity": 0.6128383278846741,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/entry/common.c",
          "start_line": 256,
          "end_line": 347,
          "content": [
            "void raw_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!preempt_count()) {",
            "\t\t/* Sanity check RCU and thread stack */",
            "\t\trcu_irq_exit_check_preempt();",
            "\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))",
            "\t\t\tWARN_ON_ONCE(!on_thread_stack());",
            "\t\tif (need_resched())",
            "\t\t\tpreempt_schedule_irq();",
            "\t}",
            "}",
            "void dynamic_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!static_branch_unlikely(&sk_dynamic_irqentry_exit_cond_resched))",
            "\t\treturn;",
            "\traw_irqentry_exit_cond_resched();",
            "}",
            "noinstr void irqentry_exit(struct pt_regs *regs, irqentry_state_t state)",
            "{",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\t/* Check whether this returns to user mode */",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_exit_to_user_mode(regs);",
            "\t} else if (!regs_irqs_disabled(regs)) {",
            "\t\t/*",
            "\t\t * If RCU was not watching on entry this needs to be done",
            "\t\t * carefully and needs the same ordering of lockdep/tracing",
            "\t\t * and RCU as the return to user mode path.",
            "\t\t */",
            "\t\tif (state.exit_rcu) {",
            "\t\t\tinstrumentation_begin();",
            "\t\t\t/* Tell the tracer that IRET will enable interrupts */",
            "\t\t\ttrace_hardirqs_on_prepare();",
            "\t\t\tlockdep_hardirqs_on_prepare();",
            "\t\t\tinstrumentation_end();",
            "\t\t\tct_irq_exit();",
            "\t\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tinstrumentation_begin();",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPTION))",
            "\t\t\tirqentry_exit_cond_resched();",
            "",
            "\t\t/* Covers both tracing and lockdep */",
            "\t\ttrace_hardirqs_on();",
            "\t\tinstrumentation_end();",
            "\t} else {",
            "\t\t/*",
            "\t\t * IRQ flags state is correct already. Just tell RCU if it",
            "\t\t * was not watching on entry.",
            "\t\t */",
            "\t\tif (state.exit_rcu)",
            "\t\t\tct_irq_exit();",
            "\t}",
            "}",
            "irqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t irq_state;",
            "",
            "\tirq_state.lockdep = lockdep_hardirqs_enabled();",
            "",
            "\t__nmi_enter();",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tlockdep_hardirq_enter();",
            "\tct_nmi_enter();",
            "",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\ttrace_hardirqs_off_finish();",
            "\tftrace_nmi_enter();",
            "\tinstrumentation_end();",
            "",
            "\treturn irq_state;",
            "}",
            "void noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state)",
            "{",
            "\tinstrumentation_begin();",
            "\tftrace_nmi_exit();",
            "\tif (irq_state.lockdep) {",
            "\t\ttrace_hardirqs_on_prepare();",
            "\t\tlockdep_hardirqs_on_prepare();",
            "\t}",
            "\tinstrumentation_end();",
            "",
            "\tct_nmi_exit();",
            "\tlockdep_hardirq_exit();",
            "\tif (irq_state.lockdep)",
            "\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t__nmi_exit();",
            "}"
          ],
          "function_name": "raw_irqentry_exit_cond_resched, dynamic_irqentry_exit_cond_resched, irqentry_exit, irqentry_nmi_enter, irqentry_nmi_exit",
          "description": "实现中断退出路径的条件调度检查和NMI上下文切换，维护中断标志状态一致性，处理RCU状态转换、锁依赖标记恢复及异常中断返回时的上下文还原",
          "similarity": 0.5980628728866577
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/common.c",
          "start_line": 141,
          "end_line": 250,
          "content": [
            "static inline bool report_single_step(unsigned long work)",
            "{",
            "\tif (work & SYSCALL_WORK_SYSCALL_EMU)",
            "\t\treturn false;",
            "",
            "\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;",
            "}",
            "void syscall_exit_work(struct pt_regs *regs, unsigned long work)",
            "{",
            "\tbool step;",
            "",
            "\t/*",
            "\t * If the syscall was rolled back due to syscall user dispatching,",
            "\t * then the tracers below are not invoked for the same reason as",
            "\t * the entry side was not invoked in syscall_trace_enter(): The ABI",
            "\t * of these syscalls is unknown.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {",
            "\t\t\tcurrent->syscall_dispatch.on_dispatch = false;",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\taudit_syscall_exit(regs);",
            "",
            "\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)",
            "\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));",
            "",
            "\tstep = report_single_step(work);",
            "\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)",
            "\t\tptrace_report_syscall_exit(regs, step);",
            "}",
            "noinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "}",
            "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)",
            "{",
            "\tinstrumentation_begin();",
            "\texit_to_user_mode_prepare(regs);",
            "\tinstrumentation_end();",
            "\texit_to_user_mode();",
            "}",
            "noinstr irqentry_state_t irqentry_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t ret = {",
            "\t\t.exit_rcu = false,",
            "\t};",
            "",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_enter_from_user_mode(regs);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If this entry hit the idle task invoke ct_irq_enter() whether",
            "\t * RCU is watching or not.",
            "\t *",
            "\t * Interrupts can nest when the first interrupt invokes softirq",
            "\t * processing on return which enables interrupts.",
            "\t *",
            "\t * Scheduler ticks in the idle task can mark quiescent state and",
            "\t * terminate a grace period, if and only if the timer interrupt is",
            "\t * not nested into another interrupt.",
            "\t *",
            "\t * Checking for rcu_is_watching() here would prevent the nesting",
            "\t * interrupt to invoke ct_irq_enter(). If that nested interrupt is",
            "\t * the tick then rcu_flavor_sched_clock_irq() would wrongfully",
            "\t * assume that it is the first interrupt and eventually claim",
            "\t * quiescent state and end grace periods prematurely.",
            "\t *",
            "\t * Unconditionally invoke ct_irq_enter() so RCU state stays",
            "\t * consistent.",
            "\t *",
            "\t * TINY_RCU does not support EQS, so let the compiler eliminate",
            "\t * this part when enabled.",
            "\t */",
            "\tif (!IS_ENABLED(CONFIG_TINY_RCU) && is_idle_task(current)) {",
            "\t\t/*",
            "\t\t * If RCU is not watching then the same careful",
            "\t\t * sequence vs. lockdep and tracing is required",
            "\t\t * as in irqentry_enter_from_user_mode().",
            "\t\t */",
            "\t\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\t\tct_irq_enter();",
            "\t\tinstrumentation_begin();",
            "\t\tkmsan_unpoison_entry_regs(regs);",
            "\t\ttrace_hardirqs_off_finish();",
            "\t\tinstrumentation_end();",
            "",
            "\t\tret.exit_rcu = true;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If RCU is watching then RCU only wants to check whether it needs",
            "\t * to restart the tick in NOHZ mode. rcu_irq_enter_check_tick()",
            "\t * already contains a warning when RCU is not watching, so no point",
            "\t * in having another one here.",
            "\t */",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\trcu_irq_enter_check_tick();",
            "\ttrace_hardirqs_off_finish();",
            "\tinstrumentation_end();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "report_single_step, syscall_exit_work, irqentry_enter_from_user_mode, irqentry_exit_to_user_mode, irqentry_enter",
          "description": "处理系统调用退出阶段工作，包括审计退出记录、单步调试报告和跟踪点事件，同时管理中断返回时的RCU状态转换和锁依赖检查",
          "similarity": 0.5911189317703247
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/common.c",
          "start_line": 18,
          "end_line": 124,
          "content": [
            "static inline void syscall_enter_audit(struct pt_regs *regs, long syscall)",
            "{",
            "\tif (unlikely(audit_context())) {",
            "\t\tunsigned long args[6];",
            "",
            "\t\tsyscall_get_arguments(current, regs, args);",
            "\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);",
            "\t}",
            "}",
            "long syscall_trace_enter(struct pt_regs *regs, long syscall,",
            "\t\t\t\tunsigned long work)",
            "{",
            "\tlong ret = 0;",
            "",
            "\t/*",
            "\t * Handle Syscall User Dispatch.  This must comes first, since",
            "\t * the ABI here can be something that doesn't make sense for",
            "\t * other syscall_work features.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (syscall_user_dispatch(regs))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Handle ptrace */",
            "\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {",
            "\t\tret = ptrace_report_syscall_entry(regs);",
            "\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Do seccomp after ptrace, to catch any tracer changes. */",
            "\tif (work & SYSCALL_WORK_SECCOMP) {",
            "\t\tret = __secure_computing(NULL);",
            "\t\tif (ret == -1L)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/* Either of the above might have changed the syscall number */",
            "\tsyscall = syscall_get_nr(current, regs);",
            "",
            "\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT)) {",
            "\t\ttrace_sys_enter(regs, syscall);",
            "\t\t/*",
            "\t\t * Probes or BPF hooks in the tracepoint may have changed the",
            "\t\t * system call number as well.",
            "\t\t */",
            "\t\tsyscall = syscall_get_nr(current, regs);",
            "\t}",
            "",
            "\tsyscall_enter_audit(regs, syscall);",
            "",
            "\treturn ret ? : syscall;",
            "}",
            "noinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "\tinstrumentation_begin();",
            "\tlocal_irq_enable();",
            "\tinstrumentation_end();",
            "}",
            "void __weak arch_do_signal_or_restart(struct pt_regs *regs) { }",
            "__always_inline unsigned long exit_to_user_mode_loop(struct pt_regs *regs,",
            "\t\t\t\t\t\t     unsigned long ti_work)",
            "{",
            "\t/*",
            "\t * Before returning to user space ensure that all pending work",
            "\t * items have been completed.",
            "\t */",
            "\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {",
            "",
            "\t\tlocal_irq_enable_exit_to_user(ti_work);",
            "",
            "\t\tif (ti_work & _TIF_NEED_RESCHED)",
            "\t\t\tschedule();",
            "",
            "\t\tif (ti_work & _TIF_UPROBE)",
            "\t\t\tuprobe_notify_resume(regs);",
            "",
            "\t\tif (ti_work & _TIF_PATCH_PENDING)",
            "\t\t\tklp_update_patch_state(current);",
            "",
            "\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))",
            "\t\t\tarch_do_signal_or_restart(regs);",
            "",
            "\t\tif (ti_work & _TIF_NOTIFY_RESUME)",
            "\t\t\tresume_user_mode_work(regs);",
            "",
            "\t\t/* Architecture specific TIF work */",
            "\t\tarch_exit_to_user_mode_work(regs, ti_work);",
            "",
            "\t\t/*",
            "\t\t * Disable interrupts and reevaluate the work flags as they",
            "\t\t * might have changed while interrupts and preemption was",
            "\t\t * enabled above.",
            "\t\t */",
            "\t\tlocal_irq_disable_exit_to_user();",
            "",
            "\t\t/* Check if any of the above work has queued a deferred wakeup */",
            "\t\ttick_nohz_user_enter_prepare();",
            "",
            "\t\tti_work = read_thread_flags();",
            "\t}",
            "",
            "\t/* Return the latest work state for arch_exit_to_user_mode() */",
            "\treturn ti_work;",
            "}"
          ],
          "function_name": "syscall_enter_audit, syscall_trace_enter, syscall_enter_from_user_mode_prepare, arch_do_signal_or_restart, exit_to_user_mode_loop",
          "description": "实现系统调用入口处理逻辑，依次处理审计追踪、指针观察、seccomp过滤及架构特定工作，通过位掩码控制不同安全机制的触发顺序并更新系统调用号",
          "similarity": 0.5818387269973755
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/common.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/context_tracking.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/highmem.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmsan.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/audit.h>",
            "#include <linux/tick.h>",
            "",
            "#include \"common.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/syscalls.h>",
            ""
          ],
          "function_name": null,
          "description": "声明系统调用通用功能所需头文件，包含审计、跟踪、KMSAN、LivePatch等模块的接口定义，为后续系统调用入口处理提供基础依赖",
          "similarity": 0.5542176365852356
        }
      ]
    }
  ]
}