{
  "query": "BPF程序权限控制令牌机制",
  "timestamp": "2025-12-26 01:32:14",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/token.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:36:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\token.c`\n\n---\n\n# `bpf/token.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/token.c` 实现了 BPF（Berkeley Packet Filter）令牌（token）机制，用于在受限环境中安全地委托 BPF 操作权限。该机制允许用户空间程序通过文件描述符形式的令牌，将特定的 BPF 命令、映射类型、程序类型和附加类型权限委托给其他进程，同时结合用户命名空间（user namespace）和 LSM（Linux Security Module）安全策略进行细粒度访问控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `bpf_ns_capable()`：检查用户命名空间是否具备指定能力，或具备 `CAP_SYS_ADMIN`（除 `CAP_SYS_ADMIN` 自身外）。\n- `bpf_token_capable()`：结合用户命名空间能力和 LSM 安全钩子，判断令牌是否具备指定能力。\n- `bpf_token_inc()` / `bpf_token_put()`：引用计数管理，支持延迟释放。\n- `bpf_token_free()`：释放令牌资源，包括用户命名空间引用和安全模块数据。\n- `bpf_token_create()`：创建 BPF 令牌文件描述符，基于挂载在 BPF 文件系统上的委托配置。\n- `bpf_token_get_from_fd()`：从文件描述符获取并增加引用计数的 `bpf_token` 结构。\n- `bpf_token_allow_cmd()` / `bpf_token_allow_map_type()` / `bpf_token_allow_prog_type()`：检查令牌是否允许执行特定 BPF 操作。\n\n### 关键数据结构\n\n- `struct bpf_token`：表示 BPF 令牌，包含：\n  - `refcnt`：引用计数（`atomic64_t`）\n  - `userns`：关联的用户命名空间\n  - `allowed_cmds` / `allowed_maps` / `allowed_progs` / `allowed_attachs`：位掩码，分别表示允许的 BPF 命令、映射类型、程序类型和附加类型\n  - `work`：用于延迟释放的工作队列项\n\n### 文件操作接口\n\n- `bpf_token_fops`：定义了 `release` 和 `show_fdinfo` 回调，用于文件关闭和 `/proc/pid/fdinfo/` 信息展示。\n\n## 3. 关键实现\n\n### 令牌创建流程 (`bpf_token_create`)\n\n1. **验证输入**：检查传入的 `bpffs_fd` 是否指向 BPF 文件系统的根目录。\n2. **权限校验**：\n   - 要求调用者与 BPF 文件系统实例处于同一用户命名空间。\n   - 必须具备 `CAP_BPF` 能力。\n   - 禁止在 `init_user_ns` 中创建令牌。\n3. **委托配置检查**：确保 BPF 文件系统挂载时已通过挂载选项设置了至少一项委托权限（`delegate_*` 字段非零）。\n4. **资源分配**：\n   - 创建匿名 inode 和文件。\n   - 分配 `bpf_token` 结构并初始化引用计数为 1。\n   - 复制挂载选项中的委托位掩码到令牌。\n5. **安全模块集成**：调用 `security_bpf_token_create()` 允许 LSM 进行额外策略检查。\n6. **返回文件描述符**：安装文件到进程 fd 表并返回。\n\n### 安全能力检查 (`bpf_token_capable`)\n\n- 默认允许 `CAP_SYS_ADMIN` 作为“超级能力”覆盖其他能力检查（但 `CAP_SYS_ADMIN` 本身仍需显式授权）。\n- 调用 `security_bpf_token_capable()` 允许 LSM 对令牌能力进行二次验证。\n\n### 引用计数与延迟释放\n\n- 使用 `atomic64_t refcnt` 管理生命周期。\n- 当引用计数归零时，通过 `schedule_work()` 将释放操作推迟到工作队列执行，避免在中断或原子上下文中调用可能睡眠的 `put_user_ns()` 和 `kfree()`。\n\n### `/proc/pid/fdinfo/` 支持\n\n- `bpf_token_show_fdinfo()` 将令牌的委托权限以十六进制或 \"any\" 形式输出，便于调试和审计。\n\n### 权限位掩码设计\n\n- 所有委托权限（命令、映射、程序、附加类型）均使用 64 位无符号整数位掩码表示。\n- 通过 `BUILD_BUG_ON()` 确保枚举类型数量不超过 64，防止位移溢出。\n- 若掩码全为 1，则显示为 \"any\"，表示无限制。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_super_ops`、`bpf_get_inode()` 等 BPF 文件系统接口。\n- **用户命名空间**：通过 `user_namespace` 和 `ns_capable()` 实现能力隔离。\n- **安全模块 (LSM)**：集成 `security_bpf_token_*` 钩子，支持 SELinux、AppArmor 等策略扩展。\n- **VFS 层**：使用 `inode`、`file`、`path`、`fdtable` 等通用文件系统抽象。\n- **内存管理**：使用 `kzalloc()`/`kfree()` 和 `vmalloc.h`（虽未直接使用，但为潜在扩展预留）。\n- **工作队列**：通过 `schedule_work()` 实现延迟释放。\n\n## 5. 使用场景\n\n- **容器化环境中的 BPF 权限委托**：在用户命名空间隔离的容器中，特权进程可创建 BPF 令牌并传递给非特权子进程，使其在受限范围内使用 BPF 功能（如 eBPF 程序加载、映射操作）。\n- **安全沙箱**：应用程序可通过令牌机制将特定 BPF 操作权限委托给插件或子模块，避免授予完整 `CAP_BPF` 或 `CAP_SYS_ADMIN`。\n- **审计与调试**：通过 `/proc/pid/fdinfo/` 查看进程持有的 BPF 令牌权限，辅助安全分析。\n- **LSM 策略集成**：安全模块可基于令牌内容实施更细粒度的访问控制，例如限制特定程序类型只能在特定挂载点使用。",
      "similarity": 0.704521119594574,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/token.c",
          "start_line": 12,
          "end_line": 195,
          "content": [
            "static bool bpf_ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable(ns, cap) || (cap != CAP_SYS_ADMIN && ns_capable(ns, CAP_SYS_ADMIN));",
            "}",
            "bool bpf_token_capable(const struct bpf_token *token, int cap)",
            "{",
            "\tstruct user_namespace *userns;",
            "",
            "\t/* BPF token allows ns_capable() level of capabilities */",
            "\tuserns = token ? token->userns : &init_user_ns;",
            "\tif (!bpf_ns_capable(userns, cap))",
            "\t\treturn false;",
            "\tif (token && security_bpf_token_capable(token, cap) < 0)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "void bpf_token_inc(struct bpf_token *token)",
            "{",
            "\tatomic64_inc(&token->refcnt);",
            "}",
            "static void bpf_token_free(struct bpf_token *token)",
            "{",
            "\tsecurity_bpf_token_free(token);",
            "\tput_user_ns(token->userns);",
            "\tkfree(token);",
            "}",
            "static void bpf_token_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_token *token = container_of(work, struct bpf_token, work);",
            "",
            "\tbpf_token_free(token);",
            "}",
            "void bpf_token_put(struct bpf_token *token)",
            "{",
            "\tif (!token)",
            "\t\treturn;",
            "",
            "\tif (!atomic64_dec_and_test(&token->refcnt))",
            "\t\treturn;",
            "",
            "\tINIT_WORK(&token->work, bpf_token_put_deferred);",
            "\tschedule_work(&token->work);",
            "}",
            "static int bpf_token_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "",
            "\tbpf_token_put(token);",
            "\treturn 0;",
            "}",
            "static void bpf_token_show_fdinfo(struct seq_file *m, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "\tu64 mask;",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_CMD >= 64);",
            "\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\tif ((token->allowed_cmds & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_cmds:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_cmds:\\t0x%llx\\n\", token->allowed_cmds);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_MAP_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\tif ((token->allowed_maps & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_maps:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_maps:\\t0x%llx\\n\", token->allowed_maps);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_PROG_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\tif ((token->allowed_progs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_progs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_progs:\\t0x%llx\\n\", token->allowed_progs);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_ATTACH_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\tif ((token->allowed_attachs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_attachs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_attachs:\\t0x%llx\\n\", token->allowed_attachs);",
            "}",
            "int bpf_token_create(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_mount_opts *mnt_opts;",
            "\tstruct bpf_token *token = NULL;",
            "\tstruct user_namespace *userns;",
            "\tstruct inode *inode;",
            "\tstruct file *file;",
            "\tCLASS(fd, f)(attr->token_create.bpffs_fd);",
            "\tstruct path path;",
            "\tstruct super_block *sb;",
            "\tumode_t mode;",
            "\tint err, fd;",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "",
            "\tpath = fd_file(f)->f_path;",
            "\tsb = path.dentry->d_sb;",
            "",
            "\tif (path.dentry != sb->s_root)",
            "\t\treturn -EINVAL;",
            "\tif (sb->s_op != &bpf_super_ops)",
            "\t\treturn -EINVAL;",
            "\terr = path_permission(&path, MAY_ACCESS);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tuserns = sb->s_user_ns;",
            "\t/*",
            "\t * Enforce that creators of BPF tokens are in the same user",
            "\t * namespace as the BPF FS instance. This makes reasoning about",
            "\t * permissions a lot easier and we can always relax this later.",
            "\t */",
            "\tif (current_user_ns() != userns)",
            "\t\treturn -EPERM;",
            "\tif (!ns_capable(userns, CAP_BPF))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Creating BPF token in init_user_ns doesn't make much sense. */",
            "\tif (current_user_ns() == &init_user_ns)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tmnt_opts = sb->s_fs_info;",
            "\tif (mnt_opts->delegate_cmds == 0 &&",
            "\t    mnt_opts->delegate_maps == 0 &&",
            "\t    mnt_opts->delegate_progs == 0 &&",
            "\t    mnt_opts->delegate_attachs == 0)",
            "\t\treturn -ENOENT; /* no BPF token delegation is set up */",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tinode = bpf_get_inode(sb, NULL, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_token_iops;",
            "\tinode->i_fop = &bpf_token_fops;",
            "\tclear_nlink(inode); /* make sure it is unlinked */",
            "",
            "\tfile = alloc_file_pseudo(inode, path.mnt, BPF_TOKEN_INODE_NAME, O_RDWR, &bpf_token_fops);",
            "\tif (IS_ERR(file)) {",
            "\t\tiput(inode);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\ttoken = kzalloc(sizeof(*token), GFP_USER);",
            "\tif (!token) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_file;",
            "\t}",
            "",
            "\tatomic64_set(&token->refcnt, 1);",
            "",
            "\t/* remember bpffs owning userns for future ns_capable() checks */",
            "\ttoken->userns = get_user_ns(userns);",
            "",
            "\ttoken->allowed_cmds = mnt_opts->delegate_cmds;",
            "\ttoken->allowed_maps = mnt_opts->delegate_maps;",
            "\ttoken->allowed_progs = mnt_opts->delegate_progs;",
            "\ttoken->allowed_attachs = mnt_opts->delegate_attachs;",
            "",
            "\terr = security_bpf_token_create(token, attr, &path);",
            "\tif (err)",
            "\t\tgoto out_token;",
            "",
            "\tfd = get_unused_fd_flags(O_CLOEXEC);",
            "\tif (fd < 0) {",
            "\t\terr = fd;",
            "\t\tgoto out_token;",
            "\t}",
            "",
            "\tfile->private_data = token;",
            "\tfd_install(fd, file);",
            "",
            "\treturn fd;",
            "",
            "out_token:",
            "\tbpf_token_free(token);",
            "out_file:",
            "\tfput(file);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_ns_capable, bpf_token_capable, bpf_token_inc, bpf_token_free, bpf_token_put_deferred, bpf_token_put, bpf_token_release, bpf_token_show_fdinfo, bpf_token_create",
          "description": "实现BPF令牌的权限检查、引用计数管理、延迟释放及创建逻辑，包括基于挂载选项的令牌初始化和安全策略校验。",
          "similarity": 0.7501437067985535
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/token.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            ""
          ],
          "function_name": null,
          "description": "包含BPF令牌功能所需的各种内核头文件，如用户命名空间、安全策略、文件操作及BPF相关定义。",
          "similarity": 0.716093897819519
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/token.c",
          "start_line": 230,
          "end_line": 254,
          "content": [
            "bool bpf_token_allow_cmd(const struct bpf_token *token, enum bpf_cmd cmd)",
            "{",
            "\tif (!token)",
            "\t\treturn false;",
            "\tif (!(token->allowed_cmds & (1ULL << cmd)))",
            "\t\treturn false;",
            "\treturn security_bpf_token_cmd(token, cmd) == 0;",
            "}",
            "bool bpf_token_allow_map_type(const struct bpf_token *token, enum bpf_map_type type)",
            "{",
            "\tif (!token || type >= __MAX_BPF_MAP_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn token->allowed_maps & (1ULL << type);",
            "}",
            "bool bpf_token_allow_prog_type(const struct bpf_token *token,",
            "\t\t\t       enum bpf_prog_type prog_type,",
            "\t\t\t       enum bpf_attach_type attach_type)",
            "{",
            "\tif (!token || prog_type >= __MAX_BPF_PROG_TYPE || attach_type >= __MAX_BPF_ATTACH_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn (token->allowed_progs & (1ULL << prog_type)) &&",
            "\t       (token->allowed_attachs & (1ULL << attach_type));",
            "}"
          ],
          "function_name": "bpf_token_allow_cmd, bpf_token_allow_map_type, bpf_token_allow_prog_type",
          "description": "提供对BPF命令、映射类型和程序类型的访问控制检查，通过位掩码匹配并结合安全模块验证权限。",
          "similarity": 0.6622881889343262
        }
      ]
    },
    {
      "source_file": "kernel/bpf/mprog.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:20:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\mprog.c`\n\n---\n\n# bpf/mprog.c 技术文档\n\n## 1. 文件概述\n\n`bpf/mprog.c` 是 Linux 内核中用于管理 **BPF 多程序（multi-program）挂载点** 的核心实现文件。该文件提供了一套机制，允许在同一个挂载点上按顺序组织多个 BPF 程序（或通过 BPF link 关联的程序），并支持在运行时对这些程序进行 **插入、替换、删除** 等原子操作。此机制主要用于支持 **BPF 程序链（program chains）**，例如在 tc（traffic control）、XDP 或 cgroup 等子系统中实现多个 BPF 程序的有序执行。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct bpf_tuple`：封装一个 BPF 程序及其关联的 link（可选），用于统一表示待操作的目标程序。\n- `struct bpf_mprog_entry`：表示一个多程序挂载点的当前状态，包含程序数组、引用计数、版本号等。\n- `struct bpf_mprog_fp` / `struct bpf_mprog_cp`：分别表示程序的“快路径”（fast path）和“控制路径”（control path）数据，用于 RCU 安全的读写分离。\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `bpf_mprog_link()` | 从 ID 或 FD 解析 BPF link，并验证程序类型 |\n| `bpf_mprog_prog()` | 从 ID 或 FD 解析 BPF program，并验证程序类型 |\n| `bpf_mprog_tuple_relative()` | 根据 flags（如 `BPF_F_ID`, `BPF_F_LINK`）统一解析用户传入的 `id_or_fd` 为 `bpf_tuple` |\n| `bpf_mprog_tuple_put()` | 释放 `bpf_tuple` 中持有的 program 或 link 引用 |\n| `bpf_mprog_replace()` | 在指定索引位置替换现有程序 |\n| `bpf_mprog_insert()` | 在指定位置（支持 `BPF_F_BEFORE` / `BPF_F_AFTER`）插入新程序 |\n| `bpf_mprog_delete()` | 删除指定位置的程序（支持首尾删除：`idx = -1` 或 `idx = total`） |\n| `bpf_mprog_pos_exact()` | 查找与给定 tuple 完全匹配的程序位置 |\n| `bpf_mprog_pos_before()` / `bpf_mprog_pos_after()` | 根据相对位置语义计算插入/删除目标索引 |\n| `bpf_mprog_attach()` | **核心入口函数**：根据用户 flags 执行 attach、replace 或 insert 操作 |\n| `bpf_mprog_fetch()` | （未完整实现）用于获取指定索引处的程序信息 |\n\n## 3. 关键实现\n\n### 3.1 程序与 Link 的统一抽象（`bpf_tuple`）\n通过 `bpf_tuple` 结构，将直接使用 BPF program FD/ID 与通过 BPF link 引用程序两种方式统一处理。`BPF_F_LINK` 标志决定是否从 link 解析，`BPF_F_ID` 决定输入是 ID 还是 FD。\n\n### 3.2 RCU 安全的多程序管理\n- 使用 `bpf_mprog_entry` 的 peer 机制实现 **写时复制（Copy-on-Write）**：\n  - 修改操作（insert/replace/delete）先复制当前 entry 到 peer\n  - 在 peer 上修改，最后原子切换指针\n  - 旧 entry 通过 RCU 回收，确保并发读安全\n- `bpf_mprog_read()` / `bpf_mprog_write()` 封装了对 `fp`（fast path）和 `cp`（control path）的访问\n\n### 3.3 相对位置语义支持\n- `BPF_F_BEFORE` / `BPF_F_AFTER` 允许用户指定相对于某个已有程序的位置\n- `bpf_mprog_pos_before()` / `bpf_mprog_pos_after()` 遍历当前程序列表，查找参考程序位置并返回目标索引\n- 特殊情况：当 `id_or_fd = 0` 且无 flags 时，表示在末尾插入（`idx = total`）\n\n### 3.4 原子性与一致性保障\n- `revision` 参数用于防止并发修改冲突（类似乐观锁）\n- `bpf_mprog_exists()` 检查避免重复添加同一程序\n- 所有修改操作最终通过 `*entry_new` 返回新 entry，由调用者负责发布\n\n### 3.5 边界处理\n- 插入到末尾：`idx == total`\n- 删除首元素：`idx = -1` → 转换为 `0`\n- 删除尾元素：`idx = total` → 转换为 `total - 1`\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/bpf.h>`：BPF 核心定义（`bpf_prog`, `bpf_link` 等）\n  - `<linux/bpf_mprog.h>`：多程序管理相关 API 和数据结构声明\n- **内核子系统依赖**：\n  - BPF 核心子系统（程序/链接生命周期管理）\n  - RCU 机制（用于无锁读取）\n  - 内存管理（`kmalloc`/`kfree` 用于 entry 复制）\n- **被调用方**：\n  - BPF 系统调用处理函数（如 `bpf(BPF_PROG_ATTACH, ...)` 的多程序扩展）\n  - 网络子系统（如 tc BPF 多程序支持）\n\n## 5. 使用场景\n\n1. **tc BPF 多程序链**：在同一个网络 qdisc 上挂载多个 BPF 程序，按顺序执行分类/过滤/修改操作\n2. **cgroup BPF 程序链**：在 cgroup 层级上组合多个安全或资源控制策略\n3. **动态策略更新**：运行时替换某个中间策略程序，而不中断整个链的执行\n4. **模块化 BPF 应用**：将复杂逻辑拆分为多个小程序，通过 attach 顺序组合\n5. **调试与热补丁**：临时插入诊断程序或替换有缺陷的程序版本\n\n该机制为 BPF 提供了类似“插件链”或“中间件栈”的能力，增强了 BPF 程序的组合性和动态管理能力。",
      "similarity": 0.6057111024856567,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 1,
          "end_line": 6,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2023 Isovalent */",
            "",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_mprog.h>",
            ""
          ],
          "function_name": null,
          "description": "声明GPL许可证并包含BPF相关头文件，为后续多程序模块实现提供基础",
          "similarity": 0.6363680362701416
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 7,
          "end_line": 116,
          "content": [
            "static int bpf_mprog_link(struct bpf_tuple *tuple,",
            "\t\t\t  u32 id_or_fd, u32 flags,",
            "\t\t\t  enum bpf_prog_type type)",
            "{",
            "\tstruct bpf_link *link = ERR_PTR(-EINVAL);",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tif (id)",
            "\t\tlink = bpf_link_by_id(id_or_fd);",
            "\telse if (id_or_fd)",
            "\t\tlink = bpf_link_get_from_fd(id_or_fd);",
            "\tif (IS_ERR(link))",
            "\t\treturn PTR_ERR(link);",
            "\tif (type && link->prog->type != type) {",
            "\t\tbpf_link_put(link);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttuple->link = link;",
            "\ttuple->prog = link->prog;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_prog(struct bpf_tuple *tuple,",
            "\t\t\t  u32 id_or_fd, u32 flags,",
            "\t\t\t  enum bpf_prog_type type)",
            "{",
            "\tstruct bpf_prog *prog = ERR_PTR(-EINVAL);",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tif (id)",
            "\t\tprog = bpf_prog_by_id(id_or_fd);",
            "\telse if (id_or_fd)",
            "\t\tprog = bpf_prog_get(id_or_fd);",
            "\tif (IS_ERR(prog))",
            "\t\treturn PTR_ERR(prog);",
            "\tif (type && prog->type != type) {",
            "\t\tbpf_prog_put(prog);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttuple->link = NULL;",
            "\ttuple->prog = prog;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_tuple_relative(struct bpf_tuple *tuple,",
            "\t\t\t\t    u32 id_or_fd, u32 flags,",
            "\t\t\t\t    enum bpf_prog_type type)",
            "{",
            "\tbool link = flags & BPF_F_LINK;",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tmemset(tuple, 0, sizeof(*tuple));",
            "\tif (link)",
            "\t\treturn bpf_mprog_link(tuple, id_or_fd, flags, type);",
            "\t/* If no relevant flag is set and no id_or_fd was passed, then",
            "\t * tuple link/prog is just NULLed. This is the case when before/",
            "\t * after selects first/last position without passing fd.",
            "\t */",
            "\tif (!id && !id_or_fd)",
            "\t\treturn 0;",
            "\treturn bpf_mprog_prog(tuple, id_or_fd, flags, type);",
            "}",
            "static void bpf_mprog_tuple_put(struct bpf_tuple *tuple)",
            "{",
            "\tif (tuple->link)",
            "\t\tbpf_link_put(tuple->link);",
            "\telse if (tuple->prog)",
            "\t\tbpf_prog_put(tuple->prog);",
            "}",
            "static int bpf_mprog_replace(struct bpf_mprog_entry *entry,",
            "\t\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t\t     struct bpf_tuple *ntuple, int idx)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_prog *oprog;",
            "",
            "\tbpf_mprog_read(entry, idx, &fp, &cp);",
            "\toprog = READ_ONCE(fp->prog);",
            "\tbpf_mprog_write(fp, cp, ntuple);",
            "\tif (!ntuple->link) {",
            "\t\tWARN_ON_ONCE(cp->link);",
            "\t\tbpf_prog_put(oprog);",
            "\t}",
            "\t*entry_new = entry;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_insert(struct bpf_mprog_entry *entry,",
            "\t\t\t    struct bpf_mprog_entry **entry_new,",
            "\t\t\t    struct bpf_tuple *ntuple, int idx, u32 flags)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_entry *peer;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "",
            "\tpeer = bpf_mprog_peer(entry);",
            "\tbpf_mprog_entry_copy(peer, entry);",
            "\tif (idx == total)",
            "\t\tgoto insert;",
            "\telse if (flags & BPF_F_BEFORE)",
            "\t\tidx += 1;",
            "\tbpf_mprog_entry_grow(peer, idx);",
            "insert:",
            "\tbpf_mprog_read(peer, idx, &fp, &cp);",
            "\tbpf_mprog_write(fp, cp, ntuple);",
            "\tbpf_mprog_inc(peer);",
            "\t*entry_new = peer;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_mprog_link, bpf_mprog_prog, bpf_mprog_tuple_relative, bpf_mprog_tuple_put, bpf_mprog_replace, bpf_mprog_insert",
          "description": "实现多程序链接与程序绑定逻辑，通过不同标志位选择性设置tuple中的link或prog字段，进行类型校验和引用计数管理",
          "similarity": 0.4859081506729126
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 297,
          "end_line": 450,
          "content": [
            "static int bpf_mprog_fetch(struct bpf_mprog_entry *entry,",
            "\t\t\t   struct bpf_tuple *tuple, int idx)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_prog *prog;",
            "\tstruct bpf_link *link;",
            "",
            "\tif (idx == -1)",
            "\t\tidx = 0;",
            "\telse if (idx == total)",
            "\t\tidx = total - 1;",
            "\tbpf_mprog_read(entry, idx, &fp, &cp);",
            "\tprog = READ_ONCE(fp->prog);",
            "\tlink = cp->link;",
            "\t/* The deletion request can either be without filled tuple in which",
            "\t * case it gets populated here based on idx, or with filled tuple",
            "\t * where the only thing we end up doing is the WARN_ON_ONCE() assert.",
            "\t * If we hit a BPF link at the given index, it must not be removed",
            "\t * from opts path.",
            "\t */",
            "\tif (link && !tuple->link)",
            "\t\treturn -EBUSY;",
            "\tWARN_ON_ONCE(tuple->prog && tuple->prog != prog);",
            "\tWARN_ON_ONCE(tuple->link && tuple->link != link);",
            "\ttuple->prog = prog;",
            "\ttuple->link = link;",
            "\treturn 0;",
            "}",
            "int bpf_mprog_detach(struct bpf_mprog_entry *entry,",
            "\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t     struct bpf_prog *prog, struct bpf_link *link,",
            "\t\t     u32 flags, u32 id_or_fd, u64 revision)",
            "{",
            "\tstruct bpf_tuple rtuple, dtuple = {",
            "\t\t.prog = prog,",
            "\t\t.link = link,",
            "\t};",
            "\tint ret, idx = -ERANGE, tidx;",
            "",
            "\tif (flags & BPF_F_REPLACE)",
            "\t\treturn -EINVAL;",
            "\tif (revision && revision != bpf_mprog_revision(entry))",
            "\t\treturn -ESTALE;",
            "\tif (!bpf_mprog_total(entry))",
            "\t\treturn -ENOENT;",
            "\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd, flags,",
            "\t\t\t\t       prog ? prog->type :",
            "\t\t\t\t       BPF_PROG_TYPE_UNSPEC);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (dtuple.prog) {",
            "\t\ttidx = bpf_mprog_pos_exact(entry, &dtuple);",
            "\t\tif (tidx < 0) {",
            "\t\t\tret = tidx;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_BEFORE) {",
            "\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < -1 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_AFTER) {",
            "\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < 0 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (idx < -1) {",
            "\t\tif (rtuple.prog || flags) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = bpf_mprog_total(entry);",
            "\t\tflags = BPF_F_AFTER;",
            "\t}",
            "\tif (idx >= bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tret = bpf_mprog_fetch(entry, &dtuple, idx);",
            "\tif (ret)",
            "\t\tgoto out;",
            "\tret = bpf_mprog_delete(entry, entry_new, &dtuple, idx);",
            "out:",
            "\tbpf_mprog_tuple_put(&rtuple);",
            "\treturn ret;",
            "}",
            "int bpf_mprog_query(const union bpf_attr *attr, union bpf_attr __user *uattr,",
            "\t\t    struct bpf_mprog_entry *entry)",
            "{",
            "\tu32 __user *uprog_flags, *ulink_flags;",
            "\tu32 __user *uprog_id, *ulink_id;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_prog *prog;",
            "\tconst u32 flags = 0;",
            "\tu32 id, count = 0;",
            "\tu64 revision = 1;",
            "\tint i, ret = 0;",
            "",
            "\tif (attr->query.query_flags || attr->query.attach_flags)",
            "\t\treturn -EINVAL;",
            "\tif (entry) {",
            "\t\trevision = bpf_mprog_revision(entry);",
            "\t\tcount = bpf_mprog_total(entry);",
            "\t}",
            "\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))",
            "\t\treturn -EFAULT;",
            "\tif (copy_to_user(&uattr->query.revision, &revision, sizeof(revision)))",
            "\t\treturn -EFAULT;",
            "\tif (copy_to_user(&uattr->query.count, &count, sizeof(count)))",
            "\t\treturn -EFAULT;",
            "\tuprog_id = u64_to_user_ptr(attr->query.prog_ids);",
            "\tuprog_flags = u64_to_user_ptr(attr->query.prog_attach_flags);",
            "\tulink_id = u64_to_user_ptr(attr->query.link_ids);",
            "\tulink_flags = u64_to_user_ptr(attr->query.link_attach_flags);",
            "\tif (attr->query.count == 0 || !uprog_id || !count)",
            "\t\treturn 0;",
            "\tif (attr->query.count < count) {",
            "\t\tcount = attr->query.count;",
            "\t\tret = -ENOSPC;",
            "\t}",
            "\tfor (i = 0; i < bpf_mprog_max(); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tprog = READ_ONCE(fp->prog);",
            "\t\tif (!prog)",
            "\t\t\tbreak;",
            "\t\tid = prog->aux->id;",
            "\t\tif (copy_to_user(uprog_id + i, &id, sizeof(id)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (uprog_flags &&",
            "\t\t    copy_to_user(uprog_flags + i, &flags, sizeof(flags)))",
            "\t\t\treturn -EFAULT;",
            "\t\tid = cp->link ? cp->link->id : 0;",
            "\t\tif (ulink_id &&",
            "\t\t    copy_to_user(ulink_id + i, &id, sizeof(id)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (ulink_flags &&",
            "\t\t    copy_to_user(ulink_flags + i, &flags, sizeof(flags)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (i + 1 == count)",
            "\t\t\tbreak;",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_mprog_fetch, bpf_mprog_detach, bpf_mprog_query",
          "description": "实现多程序条目查询接口，支持根据索引获取运行时状态、执行删除操作，并向用户空间导出程序ID和链接ID等元信息",
          "similarity": 0.43010616302490234
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 151,
          "end_line": 284,
          "content": [
            "static int bpf_mprog_delete(struct bpf_mprog_entry *entry,",
            "\t\t\t    struct bpf_mprog_entry **entry_new,",
            "\t\t\t    struct bpf_tuple *dtuple, int idx)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_entry *peer;",
            "",
            "\tpeer = bpf_mprog_peer(entry);",
            "\tbpf_mprog_entry_copy(peer, entry);",
            "\tif (idx == -1)",
            "\t\tidx = 0;",
            "\telse if (idx == total)",
            "\t\tidx = total - 1;",
            "\tbpf_mprog_entry_shrink(peer, idx);",
            "\tbpf_mprog_dec(peer);",
            "\tbpf_mprog_mark_for_release(peer, dtuple);",
            "\t*entry_new = peer;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_pos_exact(struct bpf_mprog_entry *entry,",
            "\t\t\t       struct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog))",
            "\t\t\treturn tuple->link == cp->link ? i : -EBUSY;",
            "\t}",
            "\treturn -ENOENT;",
            "}",
            "static int bpf_mprog_pos_before(struct bpf_mprog_entry *entry,",
            "\t\t\t\tstruct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog) &&",
            "\t\t    (!tuple->link || tuple->link == cp->link))",
            "\t\t\treturn i - 1;",
            "\t}",
            "\treturn tuple->prog ? -ENOENT : -1;",
            "}",
            "static int bpf_mprog_pos_after(struct bpf_mprog_entry *entry,",
            "\t\t\t       struct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog) &&",
            "\t\t    (!tuple->link || tuple->link == cp->link))",
            "\t\t\treturn i + 1;",
            "\t}",
            "\treturn tuple->prog ? -ENOENT : bpf_mprog_total(entry);",
            "}",
            "int bpf_mprog_attach(struct bpf_mprog_entry *entry,",
            "\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t     struct bpf_prog *prog_new, struct bpf_link *link,",
            "\t\t     struct bpf_prog *prog_old,",
            "\t\t     u32 flags, u32 id_or_fd, u64 revision)",
            "{",
            "\tstruct bpf_tuple rtuple, ntuple = {",
            "\t\t.prog = prog_new,",
            "\t\t.link = link,",
            "\t}, otuple = {",
            "\t\t.prog = prog_old,",
            "\t\t.link = link,",
            "\t};",
            "\tint ret, idx = -ERANGE, tidx;",
            "",
            "\tif (revision && revision != bpf_mprog_revision(entry))",
            "\t\treturn -ESTALE;",
            "\tif (bpf_mprog_exists(entry, prog_new))",
            "\t\treturn -EEXIST;",
            "\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd,",
            "\t\t\t\t       flags & ~BPF_F_REPLACE,",
            "\t\t\t\t       prog_new->type);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (flags & BPF_F_REPLACE) {",
            "\t\ttidx = bpf_mprog_pos_exact(entry, &otuple);",
            "\t\tif (tidx < 0) {",
            "\t\t\tret = tidx;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t} else if (bpf_mprog_total(entry) == bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tif (flags & BPF_F_BEFORE) {",
            "\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < -1 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_AFTER) {",
            "\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < 0 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (idx < -1) {",
            "\t\tif (rtuple.prog || flags) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = bpf_mprog_total(entry);",
            "\t\tflags = BPF_F_AFTER;",
            "\t}",
            "\tif (idx >= bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tif (flags & BPF_F_REPLACE)",
            "\t\tret = bpf_mprog_replace(entry, entry_new, &ntuple, idx);",
            "\telse",
            "\t\tret = bpf_mprog_insert(entry, entry_new, &ntuple, idx, flags);",
            "out:",
            "\tbpf_mprog_tuple_put(&rtuple);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_mprog_delete, bpf_mprog_pos_exact, bpf_mprog_pos_before, bpf_mprog_pos_after, bpf_mprog_attach",
          "description": "实现多程序条目删除、精确匹配位置查找、前后位置确定等功能，支持基于程序和链接的条件匹配与索引计算",
          "similarity": 0.42948442697525024
        }
      ]
    },
    {
      "source_file": "kernel/bpf/btf.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:03:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\btf.c`\n\n---\n\n# `bpf/btf.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/btf.c` 是 Linux 内核中实现 **BPF Type Format (BTF)** 核心功能的源文件。BTF 是一种用于描述 BPF 程序和映射（map）中数据类型的元数据格式，本质上是对 C 语言类型系统的紧凑二进制编码。该文件负责 BTF 数据的解析、验证、内存管理、引用计数、ID 分配以及与 BPF 子系统（如验证器、结构体操作、kfunc 调用等）的集成。BTF 使得 BPF 程序能够进行类型安全检查、CO-RE（Compile Once – Run Everywhere）重定位，并支持高级调试和内省功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct btf`**  \n  BTF 对象的核心结构体，包含：\n  - 原始 BTF 数据 (`data`, `nohdr_data`)\n  - 解析后的类型指针数组 (`types`)\n  - 已解析类型的 ID 和大小缓存 (`resolved_ids`, `resolved_sizes`)\n  - 字符串表指针 (`strings`)\n  - BTF 头部信息 (`hdr`)\n  - 类型数量、数据大小等元信息\n  - 引用计数 (`refcnt`) 和 RCU 回收机制 (`rcu`)\n  - kfunc 集合表 (`kfunc_set_tab`)\n  - 析构函数表 (`dtor_kfunc_tab`)\n  - 结构体操作描述符表 (`struct_ops` 相关字段，代码截断)\n\n- **`struct btf_kfunc_set_tab`**  \n  管理不同 BPF 钩子上下文（如 XDP、TC、Tracing 等）下允许调用的内核函数（kfunc）集合。\n\n- **`struct btf_id_dtor_kfunc_tab`**  \n  存储与特定类型关联的析构函数（destructor kfunc），用于资源自动清理。\n\n- **`enum btf_kfunc_hook`**  \n  定义 BPF 程序可挂载的不同执行上下文类型，用于 kfunc 权限控制。\n\n- **`DEFINE_IDR(btf_idr)` 和 `btf_idr_lock`**  \n  全局 IDR（Integer ID Allocator）用于为每个加载的 BTF 对象分配唯一 ID，并配合自旋锁保证并发安全。\n\n### 关键宏定义\n\n- **BTF 验证与布局宏**  \n  - `BTF_MAX_SIZE`: BTF 数据最大允许大小（16MB）\n  - `BTF_TYPE_ID_VALID`, `BTF_STR_OFFSET_VALID`: 类型 ID 和字符串偏移合法性检查\n  - `BITS_ROUNDUP_BYTES` 等：位宽与字节转换工具\n\n- **遍历宏**  \n  - `for_each_member_from`: 遍历结构体/联合体成员\n  - `for_each_vsi_from`: 遍历变量段信息（Variable Section Info）\n\n## 3. 关键实现\n\n### BTF 验证两阶段模型\n\n- **第一阶段（收集与初步验证）**  \n  遍历原始 BTF 类型段，将每个 `struct btf_type` 及其附属数据（如数组、函数参数等）按 4 字节对齐解析，并存入 `btf->types[]` 数组。此阶段验证：\n  - 类型结构完整性\n  - 字符串偏移是否在合法范围内\n  - 基本类型属性合法性\n\n- **第二阶段（类型解析与循环检测）**  \n  对需要解析的类型（如结构体、指针、数组等）执行深度优先搜索（DFS）：\n  - 递归解析类型引用链\n  - 检测类型定义中的循环依赖（如结构体 A 包含结构体 B，B 又包含 A）\n  - 特殊处理指针类型：允许 `struct A { struct A *next; }` 这类合法递归\n  - 缓存已解析类型的大小和最终类型 ID，避免重复计算\n\n### BTF 对象生命周期管理\n\n- 使用 `refcount_t` 实现引用计数\n- 通过 RCU 机制安全释放内存，确保在 BPF 程序或映射仍在使用 BTF 时不会被提前销毁\n- 全局 `btf_idr` 提供 BTF 对象的全局唯一标识，支持通过 `bpf_btf_get_fd_by_id()` 等系统调用访问\n\n### kfunc 与析构函数集成\n\n- `btf_kfunc_set_tab` 为不同 BPF 钩子上下文维护允许调用的内核函数白名单\n- `dtor_kfunc_tab` 支持为特定类型注册析构函数，在 BPF map 元素删除时自动调用，实现资源管理\n- 通过 `btf_kfunc_hook_filter` 支持对 kfunc 调用进行额外过滤（如 LSM 策略）\n\n### CO-RE 与重定位支持\n\n- BTF 为 `libbpf` 的 CO-RE 重定位提供类型信息基础\n- 内核通过解析 BTF 中的类型结构，理解 BPF 程序期望访问的内核数据结构布局，从而在运行时进行字段偏移调整\n\n## 4. 依赖关系\n\n- **BPF 子系统**  \n  - `bpf_verifier.c`: BPF 验证器依赖 BTF 进行类型检查和内存安全分析\n  - `bpf_map.c`: BPF 映射使用 BTF 描述 key/value 类型\n  - `bpf_struct_ops.c`: 基于 BTF 定义内核结构体操作接口\n  - `bpf_lsm.c`: LSM 钩子使用 BTF 类型信息进行策略匹配\n\n- **网络子系统**  \n  - XDP、TC、Socket、Netfilter 等网络 BPF 钩子通过 BTF 注册和验证 kfunc\n\n- **用户空间接口**  \n  - 通过 `bpf(BPF_BTF_LOAD)` 系统调用加载 BTF\n  - `/sys/kernel/btf/` sysfs 接口暴露内核 BTF（vmlinux BTF）\n\n- **工具链依赖**  \n  - 依赖 `../tools/lib/bpf/relo_core.h` 中的 CO-RE 重定位定义\n\n- **内核通用机制**  \n  - IDR（ID 分配）、RCU（内存回收）、SLAB（内存分配）、Sysfs（调试接口）\n\n## 5. 使用场景\n\n- **BPF 程序加载**  \n  用户空间通过 `bpf(BPF_PROG_LOAD)` 加载程序时，可附带 BTF 信息，供验证器进行类型检查。\n\n- **BPF Map 类型描述**  \n  创建 BPF map 时指定 `btf_key_type_id` 和 `btf_value_type_id`，使内核理解 map 中存储的数据结构。\n\n- **内核函数调用（kfunc）**  \n  BPF 程序通过 `bpf_call` 调用内核函数时，BTF 用于验证函数签名、参数类型及调用上下文合法性。\n\n- **结构体操作（struct_ops）**  \n  定义 BPF 可实现的内核回调接口（如 TCP congestion control），BTF 描述接口结构体布局。\n\n- **CO-RE 程序运行**  \n  在不同内核版本上运行预编译的 BPF 程序时，内核 BTF（`vmlinux BTF`）与程序 BTF 对比，自动重定位字段访问。\n\n- **调试与内省**  \n  通过 `bpftool btf dump` 等工具查看 BTF 内容，辅助 BPF 程序开发和问题诊断。\n\n- **安全策略实施**  \n  LSM 模块利用 BTF 类型信息对 BPF 程序行为进行细粒度访问控制。",
      "similarity": 0.5962177515029907,
      "chunks": [
        {
          "chunk_id": 33,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 6004,
          "end_line": 6136,
          "content": [
            "static int btf_validate_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,",
            "\t\t\t\t      const struct btf_type *t, int arg,",
            "\t\t\t\t      enum bpf_prog_type prog_type,",
            "\t\t\t\t      enum bpf_attach_type attach_type)",
            "{",
            "\tconst struct btf_type *ctx_type;",
            "\tconst char *tname, *ctx_tname;",
            "",
            "\tif (!btf_is_ptr(t)) {",
            "\t\tbpf_log(log, \"arg#%d type isn't a pointer\\n\", arg);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t/* KPROBE and PERF_EVENT programs allow bpf_user_pt_regs_t typedef */",
            "\tif (prog_type == BPF_PROG_TYPE_KPROBE || prog_type == BPF_PROG_TYPE_PERF_EVENT) {",
            "\t\twhile (btf_type_is_modifier(t) && !btf_type_is_typedef(t))",
            "\t\t\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t\tif (btf_type_is_typedef(t)) {",
            "\t\t\ttname = btf_name_by_offset(btf, t->name_off);",
            "\t\t\tif (tname && strcmp(tname, \"bpf_user_pt_regs_t\") == 0)",
            "\t\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\t/* all other program types don't use typedefs for context type */",
            "\twhile (btf_type_is_modifier(t))",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t/* `void *ctx __arg_ctx` is always valid */",
            "\tif (btf_type_is_void(t))",
            "\t\treturn 0;",
            "",
            "\ttname = btf_name_by_offset(btf, t->name_off);",
            "\tif (str_is_empty(tname)) {",
            "\t\tbpf_log(log, \"arg#%d type doesn't have a name\\n\", arg);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* special cases */",
            "\tswitch (prog_type) {",
            "\tcase BPF_PROG_TYPE_KPROBE:",
            "\t\tif (__btf_type_is_struct(t) && strcmp(tname, \"pt_regs\") == 0)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_PERF_EVENT:",
            "\t\tif (__builtin_types_compatible_p(bpf_user_pt_regs_t, struct pt_regs) &&",
            "\t\t    __btf_type_is_struct(t) && strcmp(tname, \"pt_regs\") == 0)",
            "\t\t\treturn 0;",
            "\t\tif (__builtin_types_compatible_p(bpf_user_pt_regs_t, struct user_pt_regs) &&",
            "\t\t    __btf_type_is_struct(t) && strcmp(tname, \"user_pt_regs\") == 0)",
            "\t\t\treturn 0;",
            "\t\tif (__builtin_types_compatible_p(bpf_user_pt_regs_t, struct user_regs_struct) &&",
            "\t\t    __btf_type_is_struct(t) && strcmp(tname, \"user_regs_struct\") == 0)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:",
            "\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:",
            "\t\t/* allow u64* as ctx */",
            "\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_TRACING:",
            "\t\tswitch (attach_type) {",
            "\t\tcase BPF_TRACE_RAW_TP:",
            "\t\t\t/* tp_btf program is TRACING, so need special case here */",
            "\t\t\tif (__btf_type_is_struct(t) &&",
            "\t\t\t    strcmp(tname, \"bpf_raw_tracepoint_args\") == 0)",
            "\t\t\t\treturn 0;",
            "\t\t\t/* allow u64* as ctx */",
            "\t\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\t\treturn 0;",
            "\t\t\tbreak;",
            "\t\tcase BPF_TRACE_ITER:",
            "\t\t\t/* allow struct bpf_iter__xxx types only */",
            "\t\t\tif (__btf_type_is_struct(t) &&",
            "\t\t\t    strncmp(tname, \"bpf_iter__\", sizeof(\"bpf_iter__\") - 1) == 0)",
            "\t\t\t\treturn 0;",
            "\t\t\tbreak;",
            "\t\tcase BPF_TRACE_FENTRY:",
            "\t\tcase BPF_TRACE_FEXIT:",
            "\t\tcase BPF_MODIFY_RETURN:",
            "\t\t\t/* allow u64* as ctx */",
            "\t\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\t\treturn 0;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_LSM:",
            "\tcase BPF_PROG_TYPE_STRUCT_OPS:",
            "\t\t/* allow u64* as ctx */",
            "\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_TRACEPOINT:",
            "\tcase BPF_PROG_TYPE_SYSCALL:",
            "\tcase BPF_PROG_TYPE_EXT:",
            "\t\treturn 0; /* anything goes */",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\tctx_type = find_canonical_prog_ctx_type(prog_type);",
            "\tif (!ctx_type) {",
            "\t\t/* should not happen */",
            "\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* resolve typedefs and check that underlying structs are matching as well */",
            "\twhile (btf_type_is_modifier(ctx_type))",
            "\t\tctx_type = btf_type_by_id(btf_vmlinux, ctx_type->type);",
            "",
            "\t/* if program type doesn't have distinctly named struct type for",
            "\t * context, then __arg_ctx argument can only be `void *`, which we",
            "\t * already checked above",
            "\t */",
            "\tif (!__btf_type_is_struct(ctx_type)) {",
            "\t\tbpf_log(log, \"arg#%d should be void pointer\\n\", arg);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_type->name_off);",
            "\tif (!__btf_type_is_struct(t) || strcmp(ctx_tname, tname) != 0) {",
            "\t\tbpf_log(log, \"arg#%d should be `struct %s *`\\n\", arg, ctx_tname);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "btf_validate_prog_ctx_type",
          "description": "验证BPF程序上下文类型有效性，针对不同程序类型处理特殊指针类型兼容性检查，确保类型与内核期望的上下文结构匹配。",
          "similarity": 0.5965343713760376
        },
        {
          "chunk_id": 40,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 7408,
          "end_line": 7707,
          "content": [
            "int btf_check_type_match(struct bpf_verifier_log *log, const struct bpf_prog *prog,",
            "\t\t\t struct btf *btf2, const struct btf_type *t2)",
            "{",
            "\tstruct btf *btf1 = prog->aux->btf;",
            "\tconst struct btf_type *t1;",
            "\tu32 btf_id = 0;",
            "",
            "\tif (!prog->aux->func_info) {",
            "\t\tbpf_log(log, \"Program extension requires BTF\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbtf_id = prog->aux->func_info[0].type_id;",
            "\tif (!btf_id)",
            "\t\treturn -EFAULT;",
            "",
            "\tt1 = btf_type_by_id(btf1, btf_id);",
            "\tif (!t1 || !btf_type_is_func(t1))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn btf_check_func_type_match(log, btf1, t1, btf2, t2);",
            "}",
            "static bool btf_is_dynptr_ptr(const struct btf *btf, const struct btf_type *t)",
            "{",
            "\tconst char *name;",
            "",
            "\tt = btf_type_by_id(btf, t->type); /* skip PTR */",
            "",
            "\twhile (btf_type_is_modifier(t))",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t/* allow either struct or struct forward declaration */",
            "\tif (btf_type_is_struct(t) ||",
            "\t    (btf_type_is_fwd(t) && btf_type_kflag(t) == 0)) {",
            "\t\tname = btf_str_by_offset(btf, t->name_off);",
            "\t\treturn name && strcmp(name, \"bpf_dynptr\") == 0;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static int btf_get_ptr_to_btf_id(struct bpf_verifier_log *log, int arg_idx,",
            "\t\t\t\t const struct btf *btf, const struct btf_type *t)",
            "{",
            "\tstruct bpf_cand_cache *cc;",
            "\tstruct bpf_core_ctx ctx = {",
            "\t\t.btf = btf,",
            "\t\t.log = log,",
            "\t};",
            "\tu32 kern_type_id, type_id;",
            "\tint err = 0;",
            "",
            "\t/* skip PTR and modifiers */",
            "\ttype_id = t->type;",
            "\tt = btf_type_by_id(btf, t->type);",
            "\twhile (btf_type_is_modifier(t)) {",
            "\t\ttype_id = t->type;",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "\t}",
            "",
            "\tmutex_lock(&cand_cache_mutex);",
            "\tcc = bpf_core_find_cands(&ctx, type_id);",
            "\tif (IS_ERR(cc)) {",
            "\t\terr = PTR_ERR(cc);",
            "\t\tbpf_log(log, \"arg#%d reference type('%s %s') candidate matching error: %d\\n\",",
            "\t\t\targ_idx, btf_type_str(t), __btf_name_by_offset(btf, t->name_off),",
            "\t\t\terr);",
            "\t\tgoto cand_cache_unlock;",
            "\t}",
            "\tif (cc->cnt != 1) {",
            "\t\tbpf_log(log, \"arg#%d reference type('%s %s') %s\\n\",",
            "\t\t\targ_idx, btf_type_str(t), __btf_name_by_offset(btf, t->name_off),",
            "\t\t\tcc->cnt == 0 ? \"has no matches\" : \"is ambiguous\");",
            "\t\terr = cc->cnt == 0 ? -ENOENT : -ESRCH;",
            "\t\tgoto cand_cache_unlock;",
            "\t}",
            "\tif (btf_is_module(cc->cands[0].btf)) {",
            "\t\tbpf_log(log, \"arg#%d reference type('%s %s') points to kernel module type (unsupported)\\n\",",
            "\t\t\targ_idx, btf_type_str(t), __btf_name_by_offset(btf, t->name_off));",
            "\t\terr = -EOPNOTSUPP;",
            "\t\tgoto cand_cache_unlock;",
            "\t}",
            "\tkern_type_id = cc->cands[0].id;",
            "",
            "cand_cache_unlock:",
            "\tmutex_unlock(&cand_cache_mutex);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn kern_type_id;",
            "}",
            "int btf_prepare_func_args(struct bpf_verifier_env *env, int subprog)",
            "{",
            "\tbool is_global = subprog_aux(env, subprog)->linkage == BTF_FUNC_GLOBAL;",
            "\tstruct bpf_subprog_info *sub = subprog_info(env, subprog);",
            "\tstruct bpf_verifier_log *log = &env->log;",
            "\tstruct bpf_prog *prog = env->prog;",
            "\tenum bpf_prog_type prog_type = prog->type;",
            "\tstruct btf *btf = prog->aux->btf;",
            "\tconst struct btf_param *args;",
            "\tconst struct btf_type *t, *ref_t, *fn_t;",
            "\tu32 i, nargs, btf_id;",
            "\tconst char *tname;",
            "",
            "\tif (sub->args_cached)",
            "\t\treturn 0;",
            "",
            "\tif (!prog->aux->func_info) {",
            "\t\tbpf_log(log, \"Verifier bug\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tbtf_id = prog->aux->func_info[subprog].type_id;",
            "\tif (!btf_id) {",
            "\t\tif (!is_global) /* not fatal for static funcs */",
            "\t\t\treturn -EINVAL;",
            "\t\tbpf_log(log, \"Global functions need valid BTF\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tfn_t = btf_type_by_id(btf, btf_id);",
            "\tif (!fn_t || !btf_type_is_func(fn_t)) {",
            "\t\t/* These checks were already done by the verifier while loading",
            "\t\t * struct bpf_func_info",
            "\t\t */",
            "\t\tbpf_log(log, \"BTF of func#%d doesn't point to KIND_FUNC\\n\",",
            "\t\t\tsubprog);",
            "\t\treturn -EFAULT;",
            "\t}",
            "\ttname = btf_name_by_offset(btf, fn_t->name_off);",
            "",
            "\tif (prog->aux->func_info_aux[subprog].unreliable) {",
            "\t\tbpf_log(log, \"Verifier bug in function %s()\\n\", tname);",
            "\t\treturn -EFAULT;",
            "\t}",
            "\tif (prog_type == BPF_PROG_TYPE_EXT)",
            "\t\tprog_type = prog->aux->dst_prog->type;",
            "",
            "\tt = btf_type_by_id(btf, fn_t->type);",
            "\tif (!t || !btf_type_is_func_proto(t)) {",
            "\t\tbpf_log(log, \"Invalid type of function %s()\\n\", tname);",
            "\t\treturn -EFAULT;",
            "\t}",
            "\targs = (const struct btf_param *)(t + 1);",
            "\tnargs = btf_type_vlen(t);",
            "\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {",
            "\t\tif (!is_global)",
            "\t\t\treturn -EINVAL;",
            "\t\tbpf_log(log, \"Global function %s() with %d > %d args. Buggy compiler.\\n\",",
            "\t\t\ttname, nargs, MAX_BPF_FUNC_REG_ARGS);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\t/* check that function returns int, exception cb also requires this */",
            "\tt = btf_type_by_id(btf, t->type);",
            "\twhile (btf_type_is_modifier(t))",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "\tif (!btf_type_is_int(t) && !btf_is_any_enum(t)) {",
            "\t\tif (!is_global)",
            "\t\t\treturn -EINVAL;",
            "\t\tbpf_log(log,",
            "\t\t\t\"Global function %s() doesn't return scalar. Only those are supported.\\n\",",
            "\t\t\ttname);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\t/* Convert BTF function arguments into verifier types.",
            "\t * Only PTR_TO_CTX and SCALAR are supported atm.",
            "\t */",
            "\tfor (i = 0; i < nargs; i++) {",
            "\t\tu32 tags = 0;",
            "\t\tint id = 0;",
            "",
            "\t\t/* 'arg:<tag>' decl_tag takes precedence over derivation of",
            "\t\t * register type from BTF type itself",
            "\t\t */",
            "\t\twhile ((id = btf_find_next_decl_tag(btf, fn_t, i, \"arg:\", id)) > 0) {",
            "\t\t\tconst struct btf_type *tag_t = btf_type_by_id(btf, id);",
            "\t\t\tconst char *tag = __btf_name_by_offset(btf, tag_t->name_off) + 4;",
            "",
            "\t\t\t/* disallow arg tags in static subprogs */",
            "\t\t\tif (!is_global) {",
            "\t\t\t\tbpf_log(log, \"arg#%d type tag is not supported in static functions\\n\", i);",
            "\t\t\t\treturn -EOPNOTSUPP;",
            "\t\t\t}",
            "",
            "\t\t\tif (strcmp(tag, \"ctx\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_CTX;",
            "\t\t\t} else if (strcmp(tag, \"trusted\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_TRUSTED;",
            "\t\t\t} else if (strcmp(tag, \"nonnull\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_NONNULL;",
            "\t\t\t} else if (strcmp(tag, \"nullable\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_NULLABLE;",
            "\t\t\t} else if (strcmp(tag, \"arena\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_ARENA;",
            "\t\t\t} else {",
            "\t\t\t\tbpf_log(log, \"arg#%d has unsupported set of tags\\n\", i);",
            "\t\t\t\treturn -EOPNOTSUPP;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (id != -ENOENT) {",
            "\t\t\tbpf_log(log, \"arg#%d type tag fetching failure: %d\\n\", i, id);",
            "\t\t\treturn id;",
            "\t\t}",
            "",
            "\t\tt = btf_type_by_id(btf, args[i].type);",
            "\t\twhile (btf_type_is_modifier(t))",
            "\t\t\tt = btf_type_by_id(btf, t->type);",
            "\t\tif (!btf_type_is_ptr(t))",
            "\t\t\tgoto skip_pointer;",
            "",
            "\t\tif ((tags & ARG_TAG_CTX) || btf_is_prog_ctx_type(log, btf, t, prog_type, i)) {",
            "\t\t\tif (tags & ~ARG_TAG_CTX) {",
            "\t\t\t\tbpf_log(log, \"arg#%d has invalid combination of tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t\tif ((tags & ARG_TAG_CTX) &&",
            "\t\t\t    btf_validate_prog_ctx_type(log, btf, t, i, prog_type,",
            "\t\t\t\t\t\t       prog->expected_attach_type))",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_CTX;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (btf_is_dynptr_ptr(btf, t)) {",
            "\t\t\tif (tags) {",
            "\t\t\t\tbpf_log(log, \"arg#%d has invalid combination of tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_DYNPTR | MEM_RDONLY;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (tags & ARG_TAG_TRUSTED) {",
            "\t\t\tint kern_type_id;",
            "",
            "\t\t\tif (tags & ARG_TAG_NONNULL) {",
            "\t\t\t\tbpf_log(log, \"arg#%d has invalid combination of tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "",
            "\t\t\tkern_type_id = btf_get_ptr_to_btf_id(log, i, btf, t);",
            "\t\t\tif (kern_type_id < 0)",
            "\t\t\t\treturn kern_type_id;",
            "",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_BTF_ID | PTR_TRUSTED;",
            "\t\t\tif (tags & ARG_TAG_NULLABLE)",
            "\t\t\t\tsub->args[i].arg_type |= PTR_MAYBE_NULL;",
            "\t\t\tsub->args[i].btf_id = kern_type_id;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (tags & ARG_TAG_ARENA) {",
            "\t\t\tif (tags & ~ARG_TAG_ARENA) {",
            "\t\t\t\tbpf_log(log, \"arg#%d arena cannot be combined with any other tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_ARENA;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (is_global) { /* generic user data pointer */",
            "\t\t\tu32 mem_size;",
            "",
            "\t\t\tif (tags & ARG_TAG_NULLABLE) {",
            "\t\t\t\tbpf_log(log, \"arg#%d has invalid combination of tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "",
            "\t\t\tt = btf_type_skip_modifiers(btf, t->type, NULL);",
            "\t\t\tref_t = btf_resolve_size(btf, t, &mem_size);",
            "\t\t\tif (IS_ERR(ref_t)) {",
            "\t\t\t\tbpf_log(log, \"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",",
            "\t\t\t\t\ti, btf_type_str(t), btf_name_by_offset(btf, t->name_off),",
            "\t\t\t\t\tPTR_ERR(ref_t));",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_MEM | PTR_MAYBE_NULL;",
            "\t\t\tif (tags & ARG_TAG_NONNULL)",
            "\t\t\t\tsub->args[i].arg_type &= ~PTR_MAYBE_NULL;",
            "\t\t\tsub->args[i].mem_size = mem_size;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "skip_pointer:",
            "\t\tif (tags) {",
            "\t\t\tbpf_log(log, \"arg#%d has pointer tag, but is not a pointer type\\n\", i);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\tif (btf_type_is_int(t) || btf_is_any_enum(t)) {",
            "\t\t\tsub->args[i].arg_type = ARG_ANYTHING;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (!is_global)",
            "\t\t\treturn -EINVAL;",
            "\t\tbpf_log(log, \"Arg#%d type %s in %s() is not supported yet.\\n\",",
            "\t\t\ti, btf_type_str(t), tname);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tsub->arg_cnt = nargs;",
            "\tsub->args_cached = true;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "btf_check_type_match, btf_is_dynptr_ptr, btf_get_ptr_to_btf_id, btf_prepare_func_args",
          "description": "该代码块实现了BPF程序验证过程中对函数参数类型的匹配检查，包括动态指针类型识别、指向BTF类型的解析及参数标签处理，核心功能是将BTF类型转换为verifier可识别的arg_type标识",
          "similarity": 0.5744470357894897
        },
        {
          "chunk_id": 24,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 4396,
          "end_line": 4514,
          "content": [
            "static s32 btf_enum64_check_meta(struct btf_verifier_env *env,",
            "\t\t\t\t const struct btf_type *t,",
            "\t\t\t\t u32 meta_left)",
            "{",
            "\tconst struct btf_enum64 *enums = btf_type_enum64(t);",
            "\tstruct btf *btf = env->btf;",
            "\tconst char *fmt_str;",
            "\tu16 i, nr_enums;",
            "\tu32 meta_needed;",
            "",
            "\tnr_enums = btf_type_vlen(t);",
            "\tmeta_needed = nr_enums * sizeof(*enums);",
            "",
            "\tif (meta_left < meta_needed) {",
            "\t\tbtf_verifier_log_basic(env, t,",
            "\t\t\t\t       \"meta_left:%u meta_needed:%u\",",
            "\t\t\t\t       meta_left, meta_needed);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (t->size > 8 || !is_power_of_2(t->size)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Unexpected size\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* enum type either no name or a valid one */",
            "\tif (t->name_off &&",
            "\t    !btf_name_valid_identifier(env->btf, t->name_off)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbtf_verifier_log_type(env, t, NULL);",
            "",
            "\tfor (i = 0; i < nr_enums; i++) {",
            "\t\tif (!btf_name_offset_valid(btf, enums[i].name_off)) {",
            "\t\t\tbtf_verifier_log(env, \"\\tInvalid name_offset:%u\",",
            "\t\t\t\t\t enums[i].name_off);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\t/* enum member must have a valid name */",
            "\t\tif (!enums[i].name_off ||",
            "\t\t    !btf_name_valid_identifier(btf, enums[i].name_off)) {",
            "\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (env->log.level == BPF_LOG_KERNEL)",
            "\t\t\tcontinue;",
            "",
            "\t\tfmt_str = btf_type_kflag(t) ? \"\\t%s val=%lld\\n\" : \"\\t%s val=%llu\\n\";",
            "\t\tbtf_verifier_log(env, fmt_str,",
            "\t\t\t\t __btf_name_by_offset(btf, enums[i].name_off),",
            "\t\t\t\t btf_enum64_value(enums + i));",
            "\t}",
            "",
            "\treturn meta_needed;",
            "}",
            "static void btf_enum64_show(const struct btf *btf, const struct btf_type *t,",
            "\t\t\t    u32 type_id, void *data, u8 bits_offset,",
            "\t\t\t    struct btf_show *show)",
            "{",
            "\tconst struct btf_enum64 *enums = btf_type_enum64(t);",
            "\tu32 i, nr_enums = btf_type_vlen(t);",
            "\tvoid *safe_data;",
            "\ts64 v;",
            "",
            "\tsafe_data = btf_show_start_type(show, t, type_id, data);",
            "\tif (!safe_data)",
            "\t\treturn;",
            "",
            "\tv = *(u64 *)safe_data;",
            "",
            "\tfor (i = 0; i < nr_enums; i++) {",
            "\t\tif (v != btf_enum64_value(enums + i))",
            "\t\t\tcontinue;",
            "",
            "\t\tbtf_show_type_value(show, \"%s\",",
            "\t\t\t\t    __btf_name_by_offset(btf,",
            "\t\t\t\t\t\t\t enums[i].name_off));",
            "",
            "\t\tbtf_show_end_type(show);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (btf_type_kflag(t))",
            "\t\tbtf_show_type_value(show, \"%lld\", v);",
            "\telse",
            "\t\tbtf_show_type_value(show, \"%llu\", v);",
            "\tbtf_show_end_type(show);",
            "}",
            "static s32 btf_func_proto_check_meta(struct btf_verifier_env *env,",
            "\t\t\t\t     const struct btf_type *t,",
            "\t\t\t\t     u32 meta_left)",
            "{",
            "\tu32 meta_needed = btf_type_vlen(t) * sizeof(struct btf_param);",
            "",
            "\tif (meta_left < meta_needed) {",
            "\t\tbtf_verifier_log_basic(env, t,",
            "\t\t\t\t       \"meta_left:%u meta_needed:%u\",",
            "\t\t\t\t       meta_left, meta_needed);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (t->name_off) {",
            "\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (btf_type_kflag(t)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbtf_verifier_log_type(env, t, NULL);",
            "",
            "\treturn meta_needed;",
            "}"
          ],
          "function_name": "btf_enum64_check_meta, btf_enum64_show, btf_func_proto_check_meta",
          "description": "该代码段实现了BTF（Binary Toolchain Format）中对枚举类型和函数原型的元数据校验与展示功能。  \n`btf_enum64_check_meta` 校验枚举类型元数据完整性，确保大小合法且名称有效；`btf_enum64_show` 将枚举值映射到对应的符号名以供调试展示；`btf_func_proto_check_meta` 验证函数原型参数元数据的有效性。  \n所有函数均通过日志记录异常并返回错误码，核心目标是保障BPF程序在加载时的类型安全性。",
          "similarity": 0.5611127018928528
        },
        {
          "chunk_id": 16,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 3080,
          "end_line": 3215,
          "content": [
            "static void btf_array_show(const struct btf *btf, const struct btf_type *t,",
            "\t\t\t   u32 type_id, void *data, u8 bits_offset,",
            "\t\t\t   struct btf_show *show)",
            "{",
            "\tconst struct btf_member *m = show->state.member;",
            "",
            "\t/*",
            "\t * First check if any members would be shown (are non-zero).",
            "\t * See comments above \"struct btf_show\" definition for more",
            "\t * details on how this works at a high-level.",
            "\t */",
            "\tif (show->state.depth > 0 && !(show->flags & BTF_SHOW_ZERO)) {",
            "\t\tif (!show->state.depth_check) {",
            "\t\t\tshow->state.depth_check = show->state.depth + 1;",
            "\t\t\tshow->state.depth_to_show = 0;",
            "\t\t}",
            "\t\t__btf_array_show(btf, t, type_id, data, bits_offset, show);",
            "\t\tshow->state.member = m;",
            "",
            "\t\tif (show->state.depth_check != show->state.depth + 1)",
            "\t\t\treturn;",
            "\t\tshow->state.depth_check = 0;",
            "",
            "\t\tif (show->state.depth_to_show <= show->state.depth)",
            "\t\t\treturn;",
            "\t\t/*",
            "\t\t * Reaching here indicates we have recursed and found",
            "\t\t * non-zero array member(s).",
            "\t\t */",
            "\t}",
            "\t__btf_array_show(btf, t, type_id, data, bits_offset, show);",
            "}",
            "static int btf_struct_check_member(struct btf_verifier_env *env,",
            "\t\t\t\t   const struct btf_type *struct_type,",
            "\t\t\t\t   const struct btf_member *member,",
            "\t\t\t\t   const struct btf_type *member_type)",
            "{",
            "\tu32 struct_bits_off = member->offset;",
            "\tu32 struct_size, bytes_offset;",
            "",
            "\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {",
            "\t\tbtf_verifier_log_member(env, struct_type, member,",
            "\t\t\t\t\t\"Member is not byte aligned\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tstruct_size = struct_type->size;",
            "\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);",
            "\tif (struct_size - bytes_offset < member_type->size) {",
            "\t\tbtf_verifier_log_member(env, struct_type, member,",
            "\t\t\t\t\t\"Member exceeds struct_size\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static s32 btf_struct_check_meta(struct btf_verifier_env *env,",
            "\t\t\t\t const struct btf_type *t,",
            "\t\t\t\t u32 meta_left)",
            "{",
            "\tbool is_union = BTF_INFO_KIND(t->info) == BTF_KIND_UNION;",
            "\tconst struct btf_member *member;",
            "\tu32 meta_needed, last_offset;",
            "\tstruct btf *btf = env->btf;",
            "\tu32 struct_size = t->size;",
            "\tu32 offset;",
            "\tu16 i;",
            "",
            "\tmeta_needed = btf_type_vlen(t) * sizeof(*member);",
            "\tif (meta_left < meta_needed) {",
            "\t\tbtf_verifier_log_basic(env, t,",
            "\t\t\t\t       \"meta_left:%u meta_needed:%u\",",
            "\t\t\t\t       meta_left, meta_needed);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* struct type either no name or a valid one */",
            "\tif (t->name_off &&",
            "\t    !btf_name_valid_identifier(env->btf, t->name_off)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbtf_verifier_log_type(env, t, NULL);",
            "",
            "\tlast_offset = 0;",
            "\tfor_each_member(i, t, member) {",
            "\t\tif (!btf_name_offset_valid(btf, member->name_off)) {",
            "\t\t\tbtf_verifier_log_member(env, t, member,",
            "\t\t\t\t\t\t\"Invalid member name_offset:%u\",",
            "\t\t\t\t\t\tmember->name_off);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\t/* struct member either no name or a valid one */",
            "\t\tif (member->name_off &&",
            "\t\t    !btf_name_valid_identifier(btf, member->name_off)) {",
            "\t\t\tbtf_verifier_log_member(env, t, member, \"Invalid name\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\t/* A member cannot be in type void */",
            "\t\tif (!member->type || !BTF_TYPE_ID_VALID(member->type)) {",
            "\t\t\tbtf_verifier_log_member(env, t, member,",
            "\t\t\t\t\t\t\"Invalid type_id\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\toffset = __btf_member_bit_offset(t, member);",
            "\t\tif (is_union && offset) {",
            "\t\t\tbtf_verifier_log_member(env, t, member,",
            "\t\t\t\t\t\t\"Invalid member bits_offset\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * \">\" instead of \">=\" because the last member could be",
            "\t\t * \"char a[0];\"",
            "\t\t */",
            "\t\tif (last_offset > offset) {",
            "\t\t\tbtf_verifier_log_member(env, t, member,",
            "\t\t\t\t\t\t\"Invalid member bits_offset\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (BITS_ROUNDUP_BYTES(offset) > struct_size) {",
            "\t\t\tbtf_verifier_log_member(env, t, member,",
            "\t\t\t\t\t\t\"Member bits_offset exceeds its struct size\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tbtf_verifier_log_member(env, t, member, NULL);",
            "\t\tlast_offset = offset;",
            "\t}",
            "",
            "\treturn meta_needed;",
            "}"
          ],
          "function_name": "btf_array_show, btf_struct_check_member, btf_struct_check_meta",
          "description": "该代码段实现BPF类型系统中结构体与数组类型的验证及展示逻辑。  \n`btf_array_show` 控制数组类型展示逻辑，通过深度检测决定是否递归展开子项；`btf_struct_check_member` 验证结构体成员对齐及边界合法性；`btf_struct_check_meta` 检查结构体元数据完整性并遍历成员校验。  \n代码存在上下文缺失，例如 `__btf_array_show` 实现未提供，且 `btf_array_show` 中的深度检测逻辑依赖外部定义的 `struct btf_show` 结构。",
          "similarity": 0.5599510669708252
        },
        {
          "chunk_id": 23,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 4253,
          "end_line": 4382,
          "content": [
            "static int btf_enum_check_kflag_member(struct btf_verifier_env *env,",
            "\t\t\t\t       const struct btf_type *struct_type,",
            "\t\t\t\t       const struct btf_member *member,",
            "\t\t\t\t       const struct btf_type *member_type)",
            "{",
            "\tu32 struct_bits_off, nr_bits, bytes_end, struct_size;",
            "\tu32 int_bitsize = sizeof(int) * BITS_PER_BYTE;",
            "",
            "\tstruct_bits_off = BTF_MEMBER_BIT_OFFSET(member->offset);",
            "\tnr_bits = BTF_MEMBER_BITFIELD_SIZE(member->offset);",
            "\tif (!nr_bits) {",
            "\t\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {",
            "\t\t\tbtf_verifier_log_member(env, struct_type, member,",
            "\t\t\t\t\t\t\"Member is not byte aligned\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tnr_bits = int_bitsize;",
            "\t} else if (nr_bits > int_bitsize) {",
            "\t\tbtf_verifier_log_member(env, struct_type, member,",
            "\t\t\t\t\t\"Invalid member bitfield_size\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tstruct_size = struct_type->size;",
            "\tbytes_end = BITS_ROUNDUP_BYTES(struct_bits_off + nr_bits);",
            "\tif (struct_size < bytes_end) {",
            "\t\tbtf_verifier_log_member(env, struct_type, member,",
            "\t\t\t\t\t\"Member exceeds struct_size\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static s32 btf_enum_check_meta(struct btf_verifier_env *env,",
            "\t\t\t       const struct btf_type *t,",
            "\t\t\t       u32 meta_left)",
            "{",
            "\tconst struct btf_enum *enums = btf_type_enum(t);",
            "\tstruct btf *btf = env->btf;",
            "\tconst char *fmt_str;",
            "\tu16 i, nr_enums;",
            "\tu32 meta_needed;",
            "",
            "\tnr_enums = btf_type_vlen(t);",
            "\tmeta_needed = nr_enums * sizeof(*enums);",
            "",
            "\tif (meta_left < meta_needed) {",
            "\t\tbtf_verifier_log_basic(env, t,",
            "\t\t\t\t       \"meta_left:%u meta_needed:%u\",",
            "\t\t\t\t       meta_left, meta_needed);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (t->size > 8 || !is_power_of_2(t->size)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Unexpected size\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* enum type either no name or a valid one */",
            "\tif (t->name_off &&",
            "\t    !btf_name_valid_identifier(env->btf, t->name_off)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbtf_verifier_log_type(env, t, NULL);",
            "",
            "\tfor (i = 0; i < nr_enums; i++) {",
            "\t\tif (!btf_name_offset_valid(btf, enums[i].name_off)) {",
            "\t\t\tbtf_verifier_log(env, \"\\tInvalid name_offset:%u\",",
            "\t\t\t\t\t enums[i].name_off);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\t/* enum member must have a valid name */",
            "\t\tif (!enums[i].name_off ||",
            "\t\t    !btf_name_valid_identifier(btf, enums[i].name_off)) {",
            "\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (env->log.level == BPF_LOG_KERNEL)",
            "\t\t\tcontinue;",
            "\t\tfmt_str = btf_type_kflag(t) ? \"\\t%s val=%d\\n\" : \"\\t%s val=%u\\n\";",
            "\t\tbtf_verifier_log(env, fmt_str,",
            "\t\t\t\t __btf_name_by_offset(btf, enums[i].name_off),",
            "\t\t\t\t enums[i].val);",
            "\t}",
            "",
            "\treturn meta_needed;",
            "}",
            "static void btf_enum_log(struct btf_verifier_env *env,",
            "\t\t\t const struct btf_type *t)",
            "{",
            "\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));",
            "}",
            "static void btf_enum_show(const struct btf *btf, const struct btf_type *t,",
            "\t\t\t  u32 type_id, void *data, u8 bits_offset,",
            "\t\t\t  struct btf_show *show)",
            "{",
            "\tconst struct btf_enum *enums = btf_type_enum(t);",
            "\tu32 i, nr_enums = btf_type_vlen(t);",
            "\tvoid *safe_data;",
            "\tint v;",
            "",
            "\tsafe_data = btf_show_start_type(show, t, type_id, data);",
            "\tif (!safe_data)",
            "\t\treturn;",
            "",
            "\tv = *(int *)safe_data;",
            "",
            "\tfor (i = 0; i < nr_enums; i++) {",
            "\t\tif (v != enums[i].val)",
            "\t\t\tcontinue;",
            "",
            "\t\tbtf_show_type_value(show, \"%s\",",
            "\t\t\t\t    __btf_name_by_offset(btf,",
            "\t\t\t\t\t\t\t enums[i].name_off));",
            "",
            "\t\tbtf_show_end_type(show);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (btf_type_kflag(t))",
            "\t\tbtf_show_type_value(show, \"%d\", v);",
            "\telse",
            "\t\tbtf_show_type_value(show, \"%u\", v);",
            "\tbtf_show_end_type(show);",
            "}"
          ],
          "function_name": "btf_enum_check_kflag_member, btf_enum_check_meta, btf_enum_log, btf_enum_show",
          "description": "该代码段实现了BPF（Berkeley Packet Filter）中对枚举类型（enum）的验证与展示逻辑。  \n`btf_enum_check_kflag_member` 检查枚举成员的位域对齐及大小合法性，确保其符合BPF运行时约束；`btf_enum_check_meta` 验证枚举元数据完整性，包括名称有效性及类型尺寸合规性；其余两个函数用于日志记录和格式化输出枚举值对应名称。  \n上下文完整，无编造API。",
          "similarity": 0.5561820268630981
        }
      ]
    }
  ]
}