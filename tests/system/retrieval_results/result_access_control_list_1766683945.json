{
  "query": "access control list",
  "timestamp": "2025-12-26 01:32:25",
  "retrieved_files": [
    {
      "source_file": "kernel/printk/nbcon.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:32:39\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `printk\\nbcon.c`\n\n---\n\n# printk/nbcon.c 技术文档\n\n## 文件概述\n\n`printk/nbcon.c` 实现了新一代的 printk 控制台（nbcon，即 \"new console\"）打印机制，该机制不依赖传统的 `console_lock` 互斥锁，而是采用基于原子操作的状态机模型来管理控制台访问。其核心目标是支持高优先级上下文（如中断、NMI、panic）安全、高效地抢占低优先级上下文对控制台的使用权，同时避免死锁和优先级反转问题。该机制特别适用于实时系统和 panic 场景下的可靠日志输出。\n\n## 核心功能\n\n### 主要数据结构\n- **`struct nbcon_state`**：封装控制台状态的原子变量，包含以下关键字段：\n  - `prio`：当前持有控制台的上下文优先级（0 表示未锁定）\n  - `cpu`：当前持有控制台的 CPU 编号\n  - `req_prio`：请求友好移交的更高优先级上下文的优先级\n  - `unsafe`：标志当前是否处于不安全状态（如正在操作共享资源）\n  - `unsafe_takeover`：标志是否发生过不安全的强制接管\n\n### 主要函数\n- **`nbcon_state_set()`**：初始化或重置控制台状态（仅限未注册或初始化阶段使用）\n- **`nbcon_state_read()`**：原子读取当前控制台状态\n- **`nbcon_state_try_cmpxchg()`**：原子比较并交换控制台状态\n- **`nbcon_seq_read()`**：读取控制台当前应打印的 printk 记录序列号\n- **`nbcon_seq_force()`**：强制设置控制台序列号（用于初始化或 panic 场景）\n- **`nbcon_seq_try_update()`**：尝试原子更新控制台序列号\n- **`nbcon_context_try_acquire_direct()`**：尝试直接获取控制台所有权（核心获取逻辑之一）\n\n## 关键实现\n\n### 控制台状态管理机制\n控制台状态通过 `nbcon_state` 原子变量管理，支持三种获取策略：\n1. **直接获取**：当控制台未被占用，或当前持有者优先级更低且处于安全状态时，直接抢占。\n2. **友好移交**：当持有者优先级更低但处于不安全状态时，请求者设置 `req_prio`，持有者在退出不安全状态后主动释放。\n3. **强制接管**：仅在 `panic()` 的最后尝试中使用，无视不安全状态强制接管（标记 `unsafe_takeover`）。\n\n### 安全状态标记\n- **`unsafe` 字段**：在操作共享资源或控制台设备时置位，操作完成后清除。确保高优先级上下文不会在设备不一致状态下接管。\n- **`unsafe_takeover` 字段**：记录强制接管事件，后续需重新初始化控制台状态。\n\n### 序列号管理\n- 使用 64 位序列号跟踪下一条待打印的 printk 记录。\n- 在 32 位系统上，仅存储低 32 位，高 32 位通过 ringbuffer 中的有效序列号推导。\n- `nbcon_seq_force()` 确保设置的序列号不低于 ringbuffer 中最早的有效记录。\n\n### 优先级与 CPU 绑定\n- 优先级数值越大表示优先级越高（`NBCON_PRIO_NONE = 0` 表示无持有者）。\n- `cpu` 字段防止同 CPU 上的忙等待，并处理复杂场景下优先级相同但 CPU 切换的情况。\n\n## 依赖关系\n\n- **内部依赖**：\n  - `printk_ringbuffer.h`：提供 printk 环形缓冲区操作接口（如 `prb_first_valid_seq()`）\n  - `internal.h`：包含 nbcon 内部定义的辅助宏和类型（如 `ACCESS_PRIVATE`、`__ulseq_to_u64seq`）\n- **内核核心模块**：\n  - `linux/atomic.h`：提供原子操作支持\n  - `linux/console.h`：定义 `struct console` 及相关常量\n  - `linux/irqflags.h`：用于中断上下文判断\n  - `linux/smp.h`：SMP 相关支持（如 `smp_processor_id()`）\n- **关键子系统**：\n  - **Printk 子系统**：作为 printk 输出后端，与 ringbuffer 紧密集成\n  - **调度器/中断子系统**：依赖上下文优先级模型（如 NMI > IRQ > 进程）\n\n## 使用场景\n\n1. **常规 printk 输出**：\n   - 高优先级中断/NMI 日志可安全抢占低优先级进程的控制台输出。\n   - 每条 printk 记录独立输出，被抢占时由新持有者重试整条记录。\n\n2. **Panic 处理**：\n   - 在 `panic()` 流程中，通过强制接管机制确保最后的日志能输出。\n   - 使用独立的 panic 记录缓冲区，避免因不安全状态导致数据损坏。\n\n3. **实时系统**：\n   - 避免传统 `console_lock` 导致的优先级反转问题。\n   - 保证高优先级任务/中断的日志能及时输出。\n\n4. **控制台驱动实现**：\n   - 控制台驱动需在关键操作（如设备寄存器访问）前后标记 `unsafe` 状态。\n   - 驱动需在每次输出字符后检查移交请求（`req_prio`），及时释放控制台。",
      "similarity": 0.505849301815033,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 128,
          "end_line": 242,
          "content": [
            "static inline void nbcon_state_set(struct console *con, struct nbcon_state *new)",
            "{",
            "\tatomic_set(&ACCESS_PRIVATE(con, nbcon_state), new->atom);",
            "}",
            "static inline void nbcon_state_read(struct console *con, struct nbcon_state *state)",
            "{",
            "\tstate->atom = atomic_read(&ACCESS_PRIVATE(con, nbcon_state));",
            "}",
            "static inline bool nbcon_state_try_cmpxchg(struct console *con, struct nbcon_state *cur,",
            "\t\t\t\t\t   struct nbcon_state *new)",
            "{",
            "\treturn atomic_try_cmpxchg(&ACCESS_PRIVATE(con, nbcon_state), &cur->atom, new->atom);",
            "}",
            "u64 nbcon_seq_read(struct console *con)",
            "{",
            "\tunsigned long nbcon_seq = atomic_long_read(&ACCESS_PRIVATE(con, nbcon_seq));",
            "",
            "\treturn __ulseq_to_u64seq(prb, nbcon_seq);",
            "}",
            "void nbcon_seq_force(struct console *con, u64 seq)",
            "{",
            "\t/*",
            "\t * If the specified record no longer exists, the oldest available record",
            "\t * is chosen. This is especially important on 32bit systems because only",
            "\t * the lower 32 bits of the sequence number are stored. The upper 32 bits",
            "\t * are derived from the sequence numbers available in the ringbuffer.",
            "\t */",
            "\tu64 valid_seq = max_t(u64, seq, prb_first_valid_seq(prb));",
            "",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_seq), __u64seq_to_ulseq(valid_seq));",
            "}",
            "static void nbcon_seq_try_update(struct nbcon_context *ctxt, u64 new_seq)",
            "{",
            "\tunsigned long nbcon_seq = __u64seq_to_ulseq(ctxt->seq);",
            "\tstruct console *con = ctxt->console;",
            "",
            "\tif (atomic_long_try_cmpxchg(&ACCESS_PRIVATE(con, nbcon_seq), &nbcon_seq,",
            "\t\t\t\t    __u64seq_to_ulseq(new_seq))) {",
            "\t\tctxt->seq = new_seq;",
            "\t} else {",
            "\t\tctxt->seq = nbcon_seq_read(con);",
            "\t}",
            "}",
            "static int nbcon_context_try_acquire_direct(struct nbcon_context *ctxt,",
            "\t\t\t\t\t    struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\tdo {",
            "\t\t/*",
            "\t\t * Panic does not imply that the console is owned. However, it",
            "\t\t * is critical that non-panic CPUs during panic are unable to",
            "\t\t * acquire ownership in order to satisfy the assumptions of",
            "\t\t * nbcon_waiter_matches(). In particular, the assumption that",
            "\t\t * lower priorities are ignored during panic.",
            "\t\t */",
            "\t\tif (other_cpu_in_panic())",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio)",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (cur->unsafe)",
            "\t\t\treturn -EBUSY;",
            "",
            "\t\t/*",
            "\t\t * The console should never be safe for a direct acquire",
            "\t\t * if an unsafe hostile takeover has ever happened.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(cur->unsafe_takeover);",
            "",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.prio\t= ctxt->prio;",
            "\t\tnew.req_prio\t= NBCON_PRIO_NONE;",
            "\t\tnew.unsafe\t= cur->unsafe_takeover;",
            "\t\tnew.cpu\t\t= cpu;",
            "",
            "\t} while (!nbcon_state_try_cmpxchg(con, cur, &new));",
            "",
            "\treturn 0;",
            "}",
            "static bool nbcon_waiter_matches(struct nbcon_state *cur, int expected_prio)",
            "{",
            "\t/*",
            "\t * The request context is well defined by the @req_prio because:",
            "\t *",
            "\t * - Only a context with a priority higher than the owner can become",
            "\t *   a waiter.",
            "\t * - Only a context with a priority higher than the waiter can",
            "\t *   directly take over the request.",
            "\t * - There are only three priorities.",
            "\t * - Only one CPU is allowed to request PANIC priority.",
            "\t * - Lower priorities are ignored during panic() until reboot.",
            "\t *",
            "\t * As a result, the following scenario is *not* possible:",
            "\t *",
            "\t * 1. This context is currently a waiter.",
            "\t * 2. Another context with a higher priority than this context",
            "\t *    directly takes ownership.",
            "\t * 3. The higher priority context releases the ownership.",
            "\t * 4. Another lower priority context takes the ownership.",
            "\t * 5. Another context with the same priority as this context",
            "\t *    creates a request and starts waiting.",
            "\t *",
            "\t * Event #1 implies this context is EMERGENCY.",
            "\t * Event #2 implies the new context is PANIC.",
            "\t * Event #3 occurs when panic() has flushed the console.",
            "\t * Events #4 and #5 are not possible due to the other_cpu_in_panic()",
            "\t * check in nbcon_context_try_acquire_direct().",
            "\t */",
            "",
            "\treturn (cur->req_prio == expected_prio);",
            "}"
          ],
          "function_name": "nbcon_state_set, nbcon_state_read, nbcon_state_try_cmpxchg, nbcon_seq_read, nbcon_seq_force, nbcon_seq_try_update, nbcon_context_try_acquire_direct, nbcon_waiter_matches",
          "description": "实现直接获取控制台的逻辑，包含优先级检查、安全状态验证和状态原子更新，通过cmpxchg保证并发安全性，处理跨CPU和panic场景下的所有权转移规则。",
          "similarity": 0.5502619743347168
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 524,
          "end_line": 629,
          "content": [
            "static int nbcon_context_try_acquire_hostile(struct nbcon_context *ctxt,",
            "\t\t\t\t\t     struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\tif (!ctxt->allow_unsafe_takeover)",
            "\t\treturn -EPERM;",
            "",
            "\t/* Ensure caller is allowed to perform unsafe hostile takeovers. */",
            "\tif (WARN_ON_ONCE(ctxt->prio != NBCON_PRIO_PANIC))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Check that try_acquire_direct() and try_acquire_handover() returned",
            "\t * -EBUSY in the right situation.",
            "\t */",
            "\tWARN_ON_ONCE(ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio);",
            "\tWARN_ON_ONCE(cur->unsafe != true);",
            "",
            "\tdo {",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.cpu\t\t\t= cpu;",
            "\t\tnew.prio\t\t= ctxt->prio;",
            "\t\tnew.unsafe\t\t|= cur->unsafe_takeover;",
            "\t\tnew.unsafe_takeover\t|= cur->unsafe;",
            "",
            "\t} while (!nbcon_state_try_cmpxchg(con, cur, &new));",
            "",
            "\treturn 0;",
            "}",
            "static bool nbcon_context_try_acquire(struct nbcon_context *ctxt)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "\tint err;",
            "",
            "\tnbcon_state_read(con, &cur);",
            "try_again:",
            "\terr = nbcon_context_try_acquire_direct(ctxt, &cur);",
            "\tif (err != -EBUSY)",
            "\t\tgoto out;",
            "",
            "\terr = nbcon_context_try_acquire_handover(ctxt, &cur);",
            "\tif (err == -EAGAIN)",
            "\t\tgoto try_again;",
            "\tif (err != -EBUSY)",
            "\t\tgoto out;",
            "",
            "\terr = nbcon_context_try_acquire_hostile(ctxt, &cur);",
            "out:",
            "\tif (err)",
            "\t\treturn false;",
            "",
            "\t/* Acquire succeeded. */",
            "",
            "\t/* Assign the appropriate buffer for this context. */",
            "\tif (atomic_read(&panic_cpu) == cpu)",
            "\t\tctxt->pbufs = &panic_nbcon_pbufs;",
            "\telse",
            "\t\tctxt->pbufs = con->pbufs;",
            "",
            "\t/* Set the record sequence for this context to print. */",
            "\tctxt->seq = nbcon_seq_read(ctxt->console);",
            "",
            "\treturn true;",
            "}",
            "static bool nbcon_owner_matches(struct nbcon_state *cur, int expected_cpu,",
            "\t\t\t\tint expected_prio)",
            "{",
            "\t/*",
            "\t * A similar function, nbcon_waiter_matches(), only deals with",
            "\t * EMERGENCY and PANIC priorities. However, this function must also",
            "\t * deal with the NORMAL priority, which requires additional checks",
            "\t * and constraints.",
            "\t *",
            "\t * For the case where preemption and interrupts are disabled, it is",
            "\t * enough to also verify that the owning CPU has not changed.",
            "\t *",
            "\t * For the case where preemption or interrupts are enabled, an",
            "\t * external synchronization method *must* be used. In particular,",
            "\t * the driver-specific locking mechanism used in device_lock()",
            "\t * (including disabling migration) should be used. It prevents",
            "\t * scenarios such as:",
            "\t *",
            "\t * 1. [Task A] owns a context with NBCON_PRIO_NORMAL on [CPU X] and",
            "\t *    is scheduled out.",
            "\t * 2. Another context takes over the lock with NBCON_PRIO_EMERGENCY",
            "\t *    and releases it.",
            "\t * 3. [Task B] acquires a context with NBCON_PRIO_NORMAL on [CPU X]",
            "\t *    and is scheduled out.",
            "\t * 4. [Task A] gets running on [CPU X] and sees that the console is",
            "\t *    still owned by a task on [CPU X] with NBON_PRIO_NORMAL. Thus",
            "\t *    [Task A] thinks it is the owner when it is not.",
            "\t */",
            "",
            "\tif (cur->prio != expected_prio)",
            "\t\treturn false;",
            "",
            "\tif (cur->cpu != expected_cpu)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "nbcon_context_try_acquire_hostile, nbcon_context_try_acquire, nbcon_owner_matches",
          "description": "处理强制接管（hostile takeover）逻辑，仅限panic优先级使用，标记控制台为永久不安全状态，提供统一的获取入口函数并关联缓冲区选择。",
          "similarity": 0.5448272824287415
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 651,
          "end_line": 757,
          "content": [
            "static void nbcon_context_release(struct nbcon_context *ctxt)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "\tstruct nbcon_state new;",
            "",
            "\tnbcon_state_read(con, &cur);",
            "",
            "\tdo {",
            "\t\tif (!nbcon_owner_matches(&cur, cpu, ctxt->prio))",
            "\t\t\tbreak;",
            "",
            "\t\tnew.atom = cur.atom;",
            "\t\tnew.prio = NBCON_PRIO_NONE;",
            "",
            "\t\t/*",
            "\t\t * If @unsafe_takeover is set, it is kept set so that",
            "\t\t * the state remains permanently unsafe.",
            "\t\t */",
            "\t\tnew.unsafe |= cur.unsafe_takeover;",
            "",
            "\t} while (!nbcon_state_try_cmpxchg(con, &cur, &new));",
            "",
            "\tctxt->pbufs = NULL;",
            "}",
            "static bool nbcon_context_can_proceed(struct nbcon_context *ctxt, struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "",
            "\t/* Make sure this context still owns the console. */",
            "\tif (!nbcon_owner_matches(cur, cpu, ctxt->prio))",
            "\t\treturn false;",
            "",
            "\t/* The console owner can proceed if there is no waiter. */",
            "\tif (cur->req_prio == NBCON_PRIO_NONE)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * A console owner within an unsafe region is always allowed to",
            "\t * proceed, even if there are waiters. It can perform a handover",
            "\t * when exiting the unsafe region. Otherwise the waiter will",
            "\t * need to perform an unsafe hostile takeover.",
            "\t */",
            "\tif (cur->unsafe)",
            "\t\treturn true;",
            "",
            "\t/* Waiters always have higher priorities than owners. */",
            "\tWARN_ON_ONCE(cur->req_prio <= cur->prio);",
            "",
            "\t/*",
            "\t * Having a safe point for take over and eventually a few",
            "\t * duplicated characters or a full line is way better than a",
            "\t * hostile takeover. Post processing can take care of the garbage.",
            "\t * Release and hand over.",
            "\t */",
            "\tnbcon_context_release(ctxt);",
            "",
            "\t/*",
            "\t * It is not clear whether the waiter really took over ownership. The",
            "\t * outermost callsite must make the final decision whether console",
            "\t * ownership is needed for it to proceed. If yes, it must reacquire",
            "\t * ownership (possibly hostile) before carefully proceeding.",
            "\t *",
            "\t * The calling context no longer owns the console so go back all the",
            "\t * way instead of trying to implement reacquire heuristics in tons of",
            "\t * places.",
            "\t */",
            "\treturn false;",
            "}",
            "bool nbcon_can_proceed(struct nbcon_write_context *wctxt)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(wctxt, ctxt);",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "",
            "\tnbcon_state_read(con, &cur);",
            "",
            "\treturn nbcon_context_can_proceed(ctxt, &cur);",
            "}",
            "static bool __nbcon_context_update_unsafe(struct nbcon_context *ctxt, bool unsafe)",
            "{",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "\tstruct nbcon_state new;",
            "",
            "\tnbcon_state_read(con, &cur);",
            "",
            "\tdo {",
            "\t\t/*",
            "\t\t * The unsafe bit must not be cleared if an",
            "\t\t * unsafe hostile takeover has occurred.",
            "\t\t */",
            "\t\tif (!unsafe && cur.unsafe_takeover)",
            "\t\t\tgoto out;",
            "",
            "\t\tif (!nbcon_context_can_proceed(ctxt, &cur))",
            "\t\t\treturn false;",
            "",
            "\t\tnew.atom = cur.atom;",
            "\t\tnew.unsafe = unsafe;",
            "\t} while (!nbcon_state_try_cmpxchg(con, &cur, &new));",
            "",
            "\tcur.atom = new.atom;",
            "out:",
            "\treturn nbcon_context_can_proceed(ctxt, &cur);",
            "}"
          ],
          "function_name": "nbcon_context_release, nbcon_context_can_proceed, nbcon_can_proceed, __nbcon_context_update_unsafe",
          "description": "实现控制台释放与状态检查逻辑，包含安全状态维护、所有权验证和异常处理，通过循环CAS更新状态并在不安全状态下阻止进一步操作。",
          "similarity": 0.5447972416877747
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 1619,
          "end_line": 1720,
          "content": [
            "void nbcon_atomic_flush_unsafe(void)",
            "{",
            "\t__nbcon_atomic_flush_pending(prb_next_reserve_seq(prb), true);",
            "}",
            "void nbcon_cpu_emergency_enter(void)",
            "{",
            "\tunsigned int *cpu_emergency_nesting;",
            "",
            "\tpreempt_disable();",
            "",
            "\tcpu_emergency_nesting = nbcon_get_cpu_emergency_nesting();",
            "\t(*cpu_emergency_nesting)++;",
            "}",
            "void nbcon_cpu_emergency_exit(void)",
            "{",
            "\tunsigned int *cpu_emergency_nesting;",
            "",
            "\tcpu_emergency_nesting = nbcon_get_cpu_emergency_nesting();",
            "",
            "\tif (!WARN_ON_ONCE(*cpu_emergency_nesting == 0))",
            "\t\t(*cpu_emergency_nesting)--;",
            "",
            "\tpreempt_enable();",
            "}",
            "bool nbcon_alloc(struct console *con)",
            "{",
            "\tstruct nbcon_state state = { };",
            "",
            "\t/* The write_thread() callback is mandatory. */",
            "\tif (WARN_ON(!con->write_thread))",
            "\t\treturn false;",
            "",
            "\trcuwait_init(&con->rcuwait);",
            "\tinit_irq_work(&con->irq_work, nbcon_irq_work);",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_prev_seq), -1UL);",
            "\tnbcon_state_set(con, &state);",
            "",
            "\t/*",
            "\t * Initialize @nbcon_seq to the highest possible sequence number so",
            "\t * that practically speaking it will have nothing to print until a",
            "\t * desired initial sequence number has been set via nbcon_seq_force().",
            "\t */",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_seq), ULSEQ_MAX(prb));",
            "",
            "\tif (con->flags & CON_BOOT) {",
            "\t\t/*",
            "\t\t * Boot console printing is synchronized with legacy console",
            "\t\t * printing, so boot consoles can share the same global printk",
            "\t\t * buffers.",
            "\t\t */",
            "\t\tcon->pbufs = &printk_shared_pbufs;",
            "\t} else {",
            "\t\tcon->pbufs = kmalloc(sizeof(*con->pbufs), GFP_KERNEL);",
            "\t\tif (!con->pbufs) {",
            "\t\t\tcon_printk(KERN_ERR, con, \"failed to allocate printing buffer\\n\");",
            "\t\t\treturn false;",
            "\t\t}",
            "",
            "\t\tif (printk_kthreads_running) {",
            "\t\t\tif (!nbcon_kthread_create(con)) {",
            "\t\t\t\tkfree(con->pbufs);",
            "\t\t\t\tcon->pbufs = NULL;",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "void nbcon_free(struct console *con)",
            "{",
            "\tstruct nbcon_state state = { };",
            "",
            "\tif (printk_kthreads_running)",
            "\t\tnbcon_kthread_stop(con);",
            "",
            "\tnbcon_state_set(con, &state);",
            "",
            "\t/* Boot consoles share global printk buffers. */",
            "\tif (!(con->flags & CON_BOOT))",
            "\t\tkfree(con->pbufs);",
            "",
            "\tcon->pbufs = NULL;",
            "}",
            "bool nbcon_device_try_acquire(struct console *con)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(con, nbcon_device_ctxt);",
            "",
            "\tcant_migrate();",
            "",
            "\tmemset(ctxt, 0, sizeof(*ctxt));",
            "\tctxt->console\t= con;",
            "\tctxt->prio\t= NBCON_PRIO_NORMAL;",
            "",
            "\tif (!nbcon_context_try_acquire(ctxt))",
            "\t\treturn false;",
            "",
            "\tif (!nbcon_context_enter_unsafe(ctxt))",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "nbcon_atomic_flush_unsafe, nbcon_cpu_emergency_enter, nbcon_cpu_emergency_exit, nbcon_alloc, nbcon_free, nbcon_device_try_acquire",
          "description": "包含CPU紧急模式的嵌套计数器增减接口，控制台资源分配释放逻辑(nbcon_alloc/free)，以及设备抢占尝试函数nbcon_device_try_acquire，用于协调控制台设备的并发访问。",
          "similarity": 0.5444076657295227
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 335,
          "end_line": 473,
          "content": [
            "static int nbcon_context_try_acquire_requested(struct nbcon_context *ctxt,",
            "\t\t\t\t\t       struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\t/* Note that the caller must still remove the request! */",
            "\tif (other_cpu_in_panic())",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Note that the waiter will also change if there was an unsafe",
            "\t * hostile takeover.",
            "\t */",
            "\tif (!nbcon_waiter_matches(cur, ctxt->prio))",
            "\t\treturn -EPERM;",
            "",
            "\t/* If still locked, caller should continue waiting. */",
            "\tif (cur->prio != NBCON_PRIO_NONE)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * The previous owner should have never released ownership",
            "\t * in an unsafe region.",
            "\t */",
            "\tWARN_ON_ONCE(cur->unsafe);",
            "",
            "\tnew.atom = cur->atom;",
            "\tnew.prio\t= ctxt->prio;",
            "\tnew.req_prio\t= NBCON_PRIO_NONE;",
            "\tnew.unsafe\t= cur->unsafe_takeover;",
            "\tnew.cpu\t\t= cpu;",
            "",
            "\tif (!nbcon_state_try_cmpxchg(con, cur, &new)) {",
            "\t\t/*",
            "\t\t * The acquire could fail only when it has been taken",
            "\t\t * over by a higher priority context.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(nbcon_waiter_matches(cur, ctxt->prio));",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* Handover success. This context now owns the console. */",
            "\treturn 0;",
            "}",
            "static int nbcon_context_try_acquire_handover(struct nbcon_context *ctxt,",
            "\t\t\t\t\t      struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "\tint timeout;",
            "\tint request_err = -EBUSY;",
            "",
            "\t/*",
            "\t * Check that the handover is called when the direct acquire failed",
            "\t * with -EBUSY.",
            "\t */",
            "\tWARN_ON_ONCE(ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio);",
            "\tWARN_ON_ONCE(!cur->unsafe);",
            "",
            "\t/* Handover is not possible on the same CPU. */",
            "\tif (cur->cpu == cpu)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * Console stays unsafe after an unsafe takeover until re-initialized.",
            "\t * Waiting is not going to help in this case.",
            "\t */",
            "\tif (cur->unsafe_takeover)",
            "\t\treturn -EBUSY;",
            "",
            "\t/* Is the caller willing to wait? */",
            "\tif (ctxt->spinwait_max_us == 0)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * Setup a request for the handover. The caller should try to acquire",
            "\t * the console directly when the current state has been modified.",
            "\t */",
            "\tnew.atom = cur->atom;",
            "\tnew.req_prio = ctxt->prio;",
            "\tif (!nbcon_state_try_cmpxchg(con, cur, &new))",
            "\t\treturn -EAGAIN;",
            "",
            "\tcur->atom = new.atom;",
            "",
            "\t/* Wait until there is no owner and then acquire the console. */",
            "\tfor (timeout = ctxt->spinwait_max_us; timeout >= 0; timeout--) {",
            "\t\t/* On successful acquire, this request is cleared. */",
            "\t\trequest_err = nbcon_context_try_acquire_requested(ctxt, cur);",
            "\t\tif (!request_err)",
            "\t\t\treturn 0;",
            "",
            "\t\t/*",
            "\t\t * If the acquire should be aborted, it must be ensured",
            "\t\t * that the request is removed before returning to caller.",
            "\t\t */",
            "\t\tif (request_err == -EPERM)",
            "\t\t\tbreak;",
            "",
            "\t\tudelay(1);",
            "",
            "\t\t/* Re-read the state because some time has passed. */",
            "\t\tnbcon_state_read(con, cur);",
            "\t}",
            "",
            "\t/* Timed out or aborted. Carefully remove handover request. */",
            "\tdo {",
            "\t\t/*",
            "\t\t * No need to remove request if there is a new waiter. This",
            "\t\t * can only happen if a higher priority context has taken over",
            "\t\t * the console or the handover request.",
            "\t\t */",
            "\t\tif (!nbcon_waiter_matches(cur, ctxt->prio))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t/* Unset request for handover. */",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.req_prio = NBCON_PRIO_NONE;",
            "\t\tif (nbcon_state_try_cmpxchg(con, cur, &new)) {",
            "\t\t\t/*",
            "\t\t\t * Request successfully unset. Report failure of",
            "\t\t\t * acquiring via handover.",
            "\t\t\t */",
            "\t\t\tcur->atom = new.atom;",
            "\t\t\treturn request_err;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Unable to remove request. Try to acquire in case",
            "\t\t * the owner has released the lock.",
            "\t\t */",
            "\t} while (nbcon_context_try_acquire_requested(ctxt, cur));",
            "",
            "\t/* Lucky timing. The acquire succeeded while removing the request. */",
            "\treturn 0;",
            "}"
          ],
          "function_name": "nbcon_context_try_acquire_requested, nbcon_context_try_acquire_handover",
          "description": "实现友好移交机制，通过设置请求优先级并轮询等待所有者释放，包含超时控制和状态同步，确保高优先级任务可中断低优先级控制台输出。",
          "similarity": 0.5247403383255005
        }
      ]
    },
    {
      "source_file": "kernel/auditsc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:53:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `auditsc.c`\n\n---\n\n# auditsc.c 技术文档\n\n## 1. 文件概述\n\n`auditsc.c` 是 Linux 内核审计子系统的核心组件之一，专门负责**系统调用级别的审计功能**。该文件实现了系统调用进入和退出时的审计数据收集、过滤规则匹配、辅助数据管理以及与 LSM（Linux Security Module）安全模块的集成。它为内核审计框架提供了系统调用上下文的完整记录能力，支持对文件操作、网络配置、进程执行等关键系统行为进行细粒度监控和日志记录。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`audit_aux_data`**: 审计辅助数据的通用基类，用于链式存储额外的审计信息\n- **`audit_aux_data_pids`**: 存储目标进程相关信息（PID、UID、会话ID、安全上下文等），最多支持16个目标进程\n- **`audit_aux_data_bprm_fcaps`**: 记录可执行文件能力（capabilities）变更信息，包括文件能力、旧进程能力和新进程能力\n- **`audit_tree_refs`**: 用于管理文件系统审计树（audit tree）引用的链表结构，每个节点包含31个`audit_chunk`指针\n- **`audit_nfcfgop_tab`**: 网络过滤配置操作的枚举到字符串映射表，支持 iptables 和 nftables 操作审计\n\n### 关键函数\n\n- **`audit_match_perm()`**: 根据系统调用类型和访问模式（读/写/属性/执行）匹配审计权限过滤规则\n- **`audit_match_filetype()`**: 匹配审计上下文中文件的类型（如普通文件、目录、设备文件等）\n- **`audit_set_auditable()`**: 将审计上下文标记为可审计状态，设置优先级和记录状态\n- **`put_tree_ref()` / `grow_tree_refs()` / `unroll_tree_refs()`**: 管理审计树引用的动态分配和释放\n\n### 全局变量\n\n- **`audit_n_rules`**: 当前系统中审计规则的总数\n- **`audit_signals`**: 控制是否收集信号发送相关的审计数据\n\n## 3. 关键实现\n\n### 系统调用分类与权限匹配\n\n`audit_match_perm()` 函数实现了复杂的系统调用分类逻辑：\n- **原生系统调用**（`AUDITSC_NATIVE`）：通过预定义的系统调用类（`AUDIT_CLASS_WRITE`、`AUDIT_CLASS_READ` 等）进行匹配\n- **兼容模式系统调用**（`AUDITSC_COMPAT`）：针对32位兼容层的特殊处理\n- **特殊系统调用处理**：\n  - `open`/`openat`：直接从参数中提取访问模式\n  - `openat2`：从 `struct open_how` 的 flags 字段解析访问模式\n  - `socketcall`：特殊处理 `SYS_BIND` 操作\n  - `execve`：匹配执行权限\n\n### 审计树引用管理\n\n采用**固定大小数组链表**的设计模式管理 `audit_chunk` 引用：\n- 每个 `audit_tree_refs` 节点包含31个指针槽位\n- 初始状态为 `(NULL, NULL, 0)`，首次分配后变为 `(p, p, 31)`\n- 通过 `tree_count` 跟踪当前节点的可用槽位数\n- 不支持收缩，仅在上下文释放时统一清理\n\n### 辅助数据扩展机制\n\n通过**继承式链表设计**支持多种辅助数据类型：\n- 所有辅助数据结构都以 `audit_aux_data` 作为第一个成员\n- 通过 `type` 字段区分不同类型的数据\n- 支持动态添加新的辅助数据类型而无需修改核心逻辑\n\n### 网络配置审计支持\n\n内置对现代网络过滤框架的完整支持：\n- **iptables**（`xt_*` 操作）\n- **nftables**（`nft_*` 操作，包括表、链、规则、集合、对象、流表等）\n- 提供操作码到可读字符串的映射，便于用户空间解析\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n\n- **审计核心**：`<linux/audit.h>`、`\"audit.h\"`\n- **系统调用**：`<asm/syscall.h>`、`<linux/syscalls.h>`\n- **安全模块**：`<linux/security.h>`、`<linux/capability.h>`\n- **文件系统**：`<linux/fs.h>`、`<linux/namei.h>`、`<linux/mount.h>`\n- **网络**：`<linux/socket.h>`、`<uapi/linux/netfilter/nf_tables.h>`\n- **进程管理**：`<linux/binfmts.h>`、`<linux/personality.h>`\n\n### 功能依赖\n\n- **审计框架**：依赖 `audit.c` 提供的核心审计功能\n- **LSM 框架**：与 SELinux、Smack 等安全模块集成，支持安全上下文审计\n- **系统调用拦截**：依赖架构特定的系统调用入口/出口钩子（如 `entry.S`）\n- **文件系统通知**：与 `fsnotify` 子系统协作实现文件访问审计\n\n## 5. 使用场景\n\n### 系统调用审计\n\n- **文件操作监控**：记录所有文件创建、删除、重命名、权限修改等操作\n- **进程执行跟踪**：审计 `execve` 系统调用，记录命令行参数和环境变量\n- **网络配置变更**：监控 iptables/nftables 规则的添加、删除、修改\n- **能力变更审计**：跟踪进程能力的获取、丢弃和继承过程\n\n### 安全合规\n\n- **LSPP 认证**：支持主体/客体安全上下文标签审计，满足高安全等级要求\n- **访问控制审计**：记录所有违反 MAC（强制访问控制）策略的访问尝试\n- **特权操作监控**：审计所有涉及 root 权限或特殊能力的系统调用\n\n### 故障诊断与取证\n\n- **系统行为分析**：通过审计日志重建系统调用序列，分析异常行为\n- **安全事件响应**：在安全事件发生后，通过审计记录追踪攻击路径\n- **合规性报告**：生成满足法规要求的系统活动审计报告",
      "similarity": 0.49472928047180176,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/auditsc.c",
          "start_line": 151,
          "end_line": 255,
          "content": [
            "static int audit_match_perm(struct audit_context *ctx, int mask)",
            "{",
            "\tunsigned n;",
            "",
            "\tif (unlikely(!ctx))",
            "\t\treturn 0;",
            "\tn = ctx->major;",
            "",
            "\tswitch (audit_classify_syscall(ctx->arch, n)) {",
            "\tcase AUDITSC_NATIVE:",
            "\t\tif ((mask & AUDIT_PERM_WRITE) &&",
            "\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))",
            "\t\t\treturn 1;",
            "\t\tif ((mask & AUDIT_PERM_READ) &&",
            "\t\t     audit_match_class(AUDIT_CLASS_READ, n))",
            "\t\t\treturn 1;",
            "\t\tif ((mask & AUDIT_PERM_ATTR) &&",
            "\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))",
            "\t\t\treturn 1;",
            "\t\treturn 0;",
            "\tcase AUDITSC_COMPAT: /* 32bit on biarch */",
            "\t\tif ((mask & AUDIT_PERM_WRITE) &&",
            "\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))",
            "\t\t\treturn 1;",
            "\t\tif ((mask & AUDIT_PERM_READ) &&",
            "\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))",
            "\t\t\treturn 1;",
            "\t\tif ((mask & AUDIT_PERM_ATTR) &&",
            "\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))",
            "\t\t\treturn 1;",
            "\t\treturn 0;",
            "\tcase AUDITSC_OPEN:",
            "\t\treturn mask & ACC_MODE(ctx->argv[1]);",
            "\tcase AUDITSC_OPENAT:",
            "\t\treturn mask & ACC_MODE(ctx->argv[2]);",
            "\tcase AUDITSC_SOCKETCALL:",
            "\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);",
            "\tcase AUDITSC_EXECVE:",
            "\t\treturn mask & AUDIT_PERM_EXEC;",
            "\tcase AUDITSC_OPENAT2:",
            "\t\treturn mask & ACC_MODE((u32)ctx->openat2.flags);",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static int audit_match_filetype(struct audit_context *ctx, int val)",
            "{",
            "\tstruct audit_names *n;",
            "\tumode_t mode = (umode_t)val;",
            "",
            "\tif (unlikely(!ctx))",
            "\t\treturn 0;",
            "",
            "\tlist_for_each_entry(n, &ctx->names_list, list) {",
            "\t\tif ((n->ino != AUDIT_INO_UNSET) &&",
            "\t\t    ((n->mode & S_IFMT) == mode))",
            "\t\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void audit_set_auditable(struct audit_context *ctx)",
            "{",
            "\tif (!ctx->prio) {",
            "\t\tctx->prio = 1;",
            "\t\tctx->current_state = AUDIT_STATE_RECORD;",
            "\t}",
            "}",
            "static int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)",
            "{",
            "\tstruct audit_tree_refs *p = ctx->trees;",
            "\tint left = ctx->tree_count;",
            "",
            "\tif (likely(left)) {",
            "\t\tp->c[--left] = chunk;",
            "\t\tctx->tree_count = left;",
            "\t\treturn 1;",
            "\t}",
            "\tif (!p)",
            "\t\treturn 0;",
            "\tp = p->next;",
            "\tif (p) {",
            "\t\tp->c[30] = chunk;",
            "\t\tctx->trees = p;",
            "\t\tctx->tree_count = 30;",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int grow_tree_refs(struct audit_context *ctx)",
            "{",
            "\tstruct audit_tree_refs *p = ctx->trees;",
            "",
            "\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);",
            "\tif (!ctx->trees) {",
            "\t\tctx->trees = p;",
            "\t\treturn 0;",
            "\t}",
            "\tif (p)",
            "\t\tp->next = ctx->trees;",
            "\telse",
            "\t\tctx->first_trees = ctx->trees;",
            "\tctx->tree_count = 31;",
            "\treturn 1;",
            "}"
          ],
          "function_name": "audit_match_perm, audit_match_filetype, audit_set_auditable, put_tree_ref, grow_tree_refs",
          "description": "实现权限匹配、文件类型检测、审计标记设置及树引用管理功能，其中audit_match_perm根据系统调用类型判断权限匹配，put_tree_ref/grow_tree_refs动态扩展审计树引用存储空间。",
          "similarity": 0.5346377491950989
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/auditsc.c",
          "start_line": 1492,
          "end_line": 1628,
          "content": [
            "static inline int audit_proctitle_rtrim(char *proctitle, int len)",
            "{",
            "\tchar *end = proctitle + len - 1;",
            "",
            "\twhile (end > proctitle && !isprint(*end))",
            "\t\tend--;",
            "",
            "\t/* catch the case where proctitle is only 1 non-print character */",
            "\tlen = end - proctitle + 1;",
            "\tlen -= isprint(proctitle[len-1]) == 0;",
            "\treturn len;",
            "}",
            "static void audit_log_name(struct audit_context *context, struct audit_names *n,",
            "\t\t    const struct path *path, int record_num, int *call_panic)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\taudit_log_format(ab, \"item=%d\", record_num);",
            "",
            "\tif (path)",
            "\t\taudit_log_d_path(ab, \" name=\", path);",
            "\telse if (n->name) {",
            "\t\tswitch (n->name_len) {",
            "\t\tcase AUDIT_NAME_FULL:",
            "\t\t\t/* log the full path */",
            "\t\t\taudit_log_format(ab, \" name=\");",
            "\t\t\taudit_log_untrustedstring(ab, n->name->name);",
            "\t\t\tbreak;",
            "\t\tcase 0:",
            "\t\t\t/* name was specified as a relative path and the",
            "\t\t\t * directory component is the cwd",
            "\t\t\t */",
            "\t\t\tif (context->pwd.dentry && context->pwd.mnt)",
            "\t\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);",
            "\t\t\telse",
            "\t\t\t\taudit_log_format(ab, \" name=(null)\");",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\t/* log the name's directory component */",
            "\t\t\taudit_log_format(ab, \" name=\");",
            "\t\t\taudit_log_n_untrustedstring(ab, n->name->name,",
            "\t\t\t\t\t\t    n->name_len);",
            "\t\t}",
            "\t} else",
            "\t\taudit_log_format(ab, \" name=(null)\");",
            "",
            "\tif (n->ino != AUDIT_INO_UNSET)",
            "\t\taudit_log_format(ab, \" inode=%lu dev=%02x:%02x mode=%#ho ouid=%u ogid=%u rdev=%02x:%02x\",",
            "\t\t\t\t n->ino,",
            "\t\t\t\t MAJOR(n->dev),",
            "\t\t\t\t MINOR(n->dev),",
            "\t\t\t\t n->mode,",
            "\t\t\t\t from_kuid(&init_user_ns, n->uid),",
            "\t\t\t\t from_kgid(&init_user_ns, n->gid),",
            "\t\t\t\t MAJOR(n->rdev),",
            "\t\t\t\t MINOR(n->rdev));",
            "\tif (n->osid != 0) {",
            "\t\tchar *ctx = NULL;",
            "\t\tu32 len;",
            "",
            "\t\tif (security_secid_to_secctx(",
            "\t\t\tn->osid, &ctx, &len)) {",
            "\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);",
            "\t\t\tif (call_panic)",
            "\t\t\t\t*call_panic = 2;",
            "\t\t} else {",
            "\t\t\taudit_log_format(ab, \" obj=%s\", ctx);",
            "\t\t\tsecurity_release_secctx(ctx, len);",
            "\t\t}",
            "\t}",
            "",
            "\t/* log the audit_names record type */",
            "\tswitch (n->type) {",
            "\tcase AUDIT_TYPE_NORMAL:",
            "\t\taudit_log_format(ab, \" nametype=NORMAL\");",
            "\t\tbreak;",
            "\tcase AUDIT_TYPE_PARENT:",
            "\t\taudit_log_format(ab, \" nametype=PARENT\");",
            "\t\tbreak;",
            "\tcase AUDIT_TYPE_CHILD_DELETE:",
            "\t\taudit_log_format(ab, \" nametype=DELETE\");",
            "\t\tbreak;",
            "\tcase AUDIT_TYPE_CHILD_CREATE:",
            "\t\taudit_log_format(ab, \" nametype=CREATE\");",
            "\t\tbreak;",
            "\tdefault:",
            "\t\taudit_log_format(ab, \" nametype=UNKNOWN\");",
            "\t\tbreak;",
            "\t}",
            "",
            "\taudit_log_fcaps(ab, n);",
            "\taudit_log_end(ab);",
            "}",
            "static void audit_log_proctitle(void)",
            "{",
            "\tint res;",
            "\tchar *buf;",
            "\tchar *msg = \"(null)\";",
            "\tint len = strlen(msg);",
            "\tstruct audit_context *context = audit_context();",
            "\tstruct audit_buffer *ab;",
            "",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);",
            "\tif (!ab)",
            "\t\treturn;\t/* audit_panic or being filtered */",
            "",
            "\taudit_log_format(ab, \"proctitle=\");",
            "",
            "\t/* Not  cached */",
            "\tif (!context->proctitle.value) {",
            "\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);",
            "\t\tif (!buf)",
            "\t\t\tgoto out;",
            "\t\t/* Historically called this from procfs naming */",
            "\t\tres = get_cmdline(current, buf, MAX_PROCTITLE_AUDIT_LEN);",
            "\t\tif (res == 0) {",
            "\t\t\tkfree(buf);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tres = audit_proctitle_rtrim(buf, res);",
            "\t\tif (res == 0) {",
            "\t\t\tkfree(buf);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tcontext->proctitle.value = buf;",
            "\t\tcontext->proctitle.len = res;",
            "\t}",
            "\tmsg = context->proctitle.value;",
            "\tlen = context->proctitle.len;",
            "out:",
            "\taudit_log_n_untrustedstring(ab, msg, len);",
            "\taudit_log_end(ab);",
            "}"
          ],
          "function_name": "audit_proctitle_rtrim, audit_log_name, audit_log_proctitle",
          "description": "处理进程标题修剪、名称记录及审计日志格式化，包含命令行参数获取、非打印字符过滤及路径解析功能",
          "similarity": 0.47894254326820374
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/auditsc.c",
          "start_line": 271,
          "end_line": 374,
          "content": [
            "static void unroll_tree_refs(struct audit_context *ctx,",
            "\t\t      struct audit_tree_refs *p, int count)",
            "{",
            "\tstruct audit_tree_refs *q;",
            "\tint n;",
            "",
            "\tif (!p) {",
            "\t\t/* we started with empty chain */",
            "\t\tp = ctx->first_trees;",
            "\t\tcount = 31;",
            "\t\t/* if the very first allocation has failed, nothing to do */",
            "\t\tif (!p)",
            "\t\t\treturn;",
            "\t}",
            "\tn = count;",
            "\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {",
            "\t\twhile (n--) {",
            "\t\t\taudit_put_chunk(q->c[n]);",
            "\t\t\tq->c[n] = NULL;",
            "\t\t}",
            "\t}",
            "\twhile (n-- > ctx->tree_count) {",
            "\t\taudit_put_chunk(q->c[n]);",
            "\t\tq->c[n] = NULL;",
            "\t}",
            "\tctx->trees = p;",
            "\tctx->tree_count = count;",
            "}",
            "static void free_tree_refs(struct audit_context *ctx)",
            "{",
            "\tstruct audit_tree_refs *p, *q;",
            "",
            "\tfor (p = ctx->first_trees; p; p = q) {",
            "\t\tq = p->next;",
            "\t\tkfree(p);",
            "\t}",
            "}",
            "static int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)",
            "{",
            "\tstruct audit_tree_refs *p;",
            "\tint n;",
            "",
            "\tif (!tree)",
            "\t\treturn 0;",
            "\t/* full ones */",
            "\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {",
            "\t\tfor (n = 0; n < 31; n++)",
            "\t\t\tif (audit_tree_match(p->c[n], tree))",
            "\t\t\t\treturn 1;",
            "\t}",
            "\t/* partial */",
            "\tif (p) {",
            "\t\tfor (n = ctx->tree_count; n < 31; n++)",
            "\t\t\tif (audit_tree_match(p->c[n], tree))",
            "\t\t\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int audit_compare_uid(kuid_t uid,",
            "\t\t\t     struct audit_names *name,",
            "\t\t\t     struct audit_field *f,",
            "\t\t\t     struct audit_context *ctx)",
            "{",
            "\tstruct audit_names *n;",
            "\tint rc;",
            "",
            "\tif (name) {",
            "\t\trc = audit_uid_comparator(uid, f->op, name->uid);",
            "\t\tif (rc)",
            "\t\t\treturn rc;",
            "\t}",
            "",
            "\tif (ctx) {",
            "\t\tlist_for_each_entry(n, &ctx->names_list, list) {",
            "\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);",
            "\t\t\tif (rc)",
            "\t\t\t\treturn rc;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "static int audit_compare_gid(kgid_t gid,",
            "\t\t\t     struct audit_names *name,",
            "\t\t\t     struct audit_field *f,",
            "\t\t\t     struct audit_context *ctx)",
            "{",
            "\tstruct audit_names *n;",
            "\tint rc;",
            "",
            "\tif (name) {",
            "\t\trc = audit_gid_comparator(gid, f->op, name->gid);",
            "\t\tif (rc)",
            "\t\t\treturn rc;",
            "\t}",
            "",
            "\tif (ctx) {",
            "\t\tlist_for_each_entry(n, &ctx->names_list, list) {",
            "\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);",
            "\t\t\tif (rc)",
            "\t\t\t\treturn rc;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "unroll_tree_refs, free_tree_refs, match_tree_refs, audit_compare_uid, audit_compare_gid",
          "description": "处理审计树引用的释放与匹配操作，unroll_tree_refs回收冗余引用，free_tree_refs彻底释放内存，match_tree_refs检查目标树节点匹配情况，同时实现UID/GID对比逻辑。",
          "similarity": 0.4727438688278198
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/auditsc.c",
          "start_line": 921,
          "end_line": 1043,
          "content": [
            "static inline void audit_free_module(struct audit_context *context)",
            "{",
            "\tif (context->type == AUDIT_KERN_MODULE) {",
            "\t\tkfree(context->module.name);",
            "\t\tcontext->module.name = NULL;",
            "\t}",
            "}",
            "static inline void audit_free_names(struct audit_context *context)",
            "{",
            "\tstruct audit_names *n, *next;",
            "",
            "\tlist_for_each_entry_safe(n, next, &context->names_list, list) {",
            "\t\tlist_del(&n->list);",
            "\t\tif (n->name)",
            "\t\t\tputname(n->name);",
            "\t\tif (n->should_free)",
            "\t\t\tkfree(n);",
            "\t}",
            "\tcontext->name_count = 0;",
            "\tpath_put(&context->pwd);",
            "\tcontext->pwd.dentry = NULL;",
            "\tcontext->pwd.mnt = NULL;",
            "}",
            "static inline void audit_free_aux(struct audit_context *context)",
            "{",
            "\tstruct audit_aux_data *aux;",
            "",
            "\twhile ((aux = context->aux)) {",
            "\t\tcontext->aux = aux->next;",
            "\t\tkfree(aux);",
            "\t}",
            "\tcontext->aux = NULL;",
            "\twhile ((aux = context->aux_pids)) {",
            "\t\tcontext->aux_pids = aux->next;",
            "\t\tkfree(aux);",
            "\t}",
            "\tcontext->aux_pids = NULL;",
            "}",
            "static void audit_reset_context(struct audit_context *ctx)",
            "{",
            "\tif (!ctx)",
            "\t\treturn;",
            "",
            "\t/* if ctx is non-null, reset the \"ctx->context\" regardless */",
            "\tctx->context = AUDIT_CTX_UNUSED;",
            "\tif (ctx->dummy)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * NOTE: It shouldn't matter in what order we release the fields, so",
            "\t *       release them in the order in which they appear in the struct;",
            "\t *       this gives us some hope of quickly making sure we are",
            "\t *       resetting the audit_context properly.",
            "\t *",
            "\t *       Other things worth mentioning:",
            "\t *       - we don't reset \"dummy\"",
            "\t *       - we don't reset \"state\", we do reset \"current_state\"",
            "\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD",
            "\t *       - much of this is likely overkill, but play it safe for now",
            "\t *       - we really need to work on improving the audit_context struct",
            "\t */",
            "",
            "\tctx->current_state = ctx->state;",
            "\tctx->serial = 0;",
            "\tctx->major = 0;",
            "\tctx->uring_op = 0;",
            "\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };",
            "\tmemset(ctx->argv, 0, sizeof(ctx->argv));",
            "\tctx->return_code = 0;",
            "\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);",
            "\tctx->return_valid = AUDITSC_INVALID;",
            "\taudit_free_names(ctx);",
            "\tif (ctx->state != AUDIT_STATE_RECORD) {",
            "\t\tkfree(ctx->filterkey);",
            "\t\tctx->filterkey = NULL;",
            "\t}",
            "\taudit_free_aux(ctx);",
            "\tkfree(ctx->sockaddr);",
            "\tctx->sockaddr = NULL;",
            "\tctx->sockaddr_len = 0;",
            "\tctx->ppid = 0;",
            "\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);",
            "\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);",
            "\tctx->personality = 0;",
            "\tctx->arch = 0;",
            "\tctx->target_pid = 0;",
            "\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);",
            "\tctx->target_sessionid = 0;",
            "\tctx->target_sid = 0;",
            "\tctx->target_comm[0] = '\\0';",
            "\tunroll_tree_refs(ctx, NULL, 0);",
            "\tWARN_ON(!list_empty(&ctx->killed_trees));",
            "\taudit_free_module(ctx);",
            "\tctx->fds[0] = -1;",
            "\tctx->type = 0; /* reset last for audit_free_*() */",
            "}",
            "int audit_alloc(struct task_struct *tsk)",
            "{",
            "\tstruct audit_context *context;",
            "\tenum audit_state     state;",
            "\tchar *key = NULL;",
            "",
            "\tif (likely(!audit_ever_enabled))",
            "\t\treturn 0;",
            "",
            "\tstate = audit_filter_task(tsk, &key);",
            "\tif (state == AUDIT_STATE_DISABLED) {",
            "\t\tclear_task_syscall_work(tsk, SYSCALL_AUDIT);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tcontext = audit_alloc_context(state);",
            "\tif (!context) {",
            "\t\tkfree(key);",
            "\t\taudit_log_lost(\"out of memory in audit_alloc\");",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tcontext->filterkey = key;",
            "",
            "\taudit_set_context(tsk, context);",
            "\tset_task_syscall_work(tsk, SYSCALL_AUDIT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "audit_free_module, audit_free_names, audit_free_aux, audit_reset_context, audit_alloc",
          "description": "实现审计上下文的内存释放与状态重置，包含模块名、路径名列表、辅助数据等资源的清理及上下文状态初始化",
          "similarity": 0.46510565280914307
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/auditsc.c",
          "start_line": 2011,
          "end_line": 2156,
          "content": [
            "void __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,",
            "\t\t\t   unsigned long a3, unsigned long a4)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "\tenum audit_state     state;",
            "",
            "\tif (!audit_enabled || !context)",
            "\t\treturn;",
            "",
            "\tWARN_ON(context->context != AUDIT_CTX_UNUSED);",
            "\tWARN_ON(context->name_count);",
            "\tif (context->context != AUDIT_CTX_UNUSED || context->name_count) {",
            "\t\taudit_panic(\"unrecoverable error in audit_syscall_entry()\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tstate = context->state;",
            "\tif (state == AUDIT_STATE_DISABLED)",
            "\t\treturn;",
            "",
            "\tcontext->dummy = !audit_n_rules;",
            "\tif (!context->dummy && state == AUDIT_STATE_BUILD) {",
            "\t\tcontext->prio = 0;",
            "\t\tif (auditd_test_task(current))",
            "\t\t\treturn;",
            "\t}",
            "",
            "\tcontext->arch\t    = syscall_get_arch(current);",
            "\tcontext->major      = major;",
            "\tcontext->argv[0]    = a1;",
            "\tcontext->argv[1]    = a2;",
            "\tcontext->argv[2]    = a3;",
            "\tcontext->argv[3]    = a4;",
            "\tcontext->context = AUDIT_CTX_SYSCALL;",
            "\tcontext->current_state  = state;",
            "\tktime_get_coarse_real_ts64(&context->ctime);",
            "}",
            "void __audit_syscall_exit(int success, long return_code)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tif (!context || context->dummy ||",
            "\t    context->context != AUDIT_CTX_SYSCALL)",
            "\t\tgoto out;",
            "",
            "\t/* this may generate CONFIG_CHANGE records */",
            "\tif (!list_empty(&context->killed_trees))",
            "\t\taudit_kill_trees(context);",
            "",
            "\taudit_return_fixup(context, success, return_code);",
            "\t/* run through both filters to ensure we set the filterkey properly */",
            "\taudit_filter_syscall(current, context);",
            "\taudit_filter_inodes(current, context);",
            "\tif (context->current_state != AUDIT_STATE_RECORD)",
            "\t\tgoto out;",
            "",
            "\taudit_log_exit();",
            "",
            "out:",
            "\taudit_reset_context(context);",
            "}",
            "static inline void handle_one(const struct inode *inode)",
            "{",
            "\tstruct audit_context *context;",
            "\tstruct audit_tree_refs *p;",
            "\tstruct audit_chunk *chunk;",
            "\tint count;",
            "",
            "\tif (likely(!inode->i_fsnotify_marks))",
            "\t\treturn;",
            "\tcontext = audit_context();",
            "\tp = context->trees;",
            "\tcount = context->tree_count;",
            "\trcu_read_lock();",
            "\tchunk = audit_tree_lookup(inode);",
            "\trcu_read_unlock();",
            "\tif (!chunk)",
            "\t\treturn;",
            "\tif (likely(put_tree_ref(context, chunk)))",
            "\t\treturn;",
            "\tif (unlikely(!grow_tree_refs(context))) {",
            "\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");",
            "\t\taudit_set_auditable(context);",
            "\t\taudit_put_chunk(chunk);",
            "\t\tunroll_tree_refs(context, p, count);",
            "\t\treturn;",
            "\t}",
            "\tput_tree_ref(context, chunk);",
            "}",
            "static void handle_path(const struct dentry *dentry)",
            "{",
            "\tstruct audit_context *context;",
            "\tstruct audit_tree_refs *p;",
            "\tconst struct dentry *d, *parent;",
            "\tstruct audit_chunk *drop;",
            "\tunsigned long seq;",
            "\tint count;",
            "",
            "\tcontext = audit_context();",
            "\tp = context->trees;",
            "\tcount = context->tree_count;",
            "retry:",
            "\tdrop = NULL;",
            "\td = dentry;",
            "\trcu_read_lock();",
            "\tseq = read_seqbegin(&rename_lock);",
            "\tfor (;;) {",
            "\t\tstruct inode *inode = d_backing_inode(d);",
            "",
            "\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {",
            "\t\t\tstruct audit_chunk *chunk;",
            "",
            "\t\t\tchunk = audit_tree_lookup(inode);",
            "\t\t\tif (chunk) {",
            "\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {",
            "\t\t\t\t\tdrop = chunk;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tparent = d->d_parent;",
            "\t\tif (parent == d)",
            "\t\t\tbreak;",
            "\t\td = parent;",
            "\t}",
            "\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */",
            "\t\trcu_read_unlock();",
            "\t\tif (!drop) {",
            "\t\t\t/* just a race with rename */",
            "\t\t\tunroll_tree_refs(context, p, count);",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\taudit_put_chunk(drop);",
            "\t\tif (grow_tree_refs(context)) {",
            "\t\t\t/* OK, got more space */",
            "\t\t\tunroll_tree_refs(context, p, count);",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\t/* too bad */",
            "\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");",
            "\t\tunroll_tree_refs(context, p, count);",
            "\t\taudit_set_auditable(context);",
            "\t\treturn;",
            "\t}",
            "\trcu_read_unlock();",
            "}"
          ],
          "function_name": "__audit_syscall_entry, __audit_syscall_exit, handle_one, handle_path",
          "description": "此代码块处理系统调用的审计入口/出口记录，包含路径追踪功能。通过遍历文件系统节点检测变化，维护审计上下文中的树引用计数，确保在文件操作时正确记录审计信息。",
          "similarity": 0.4628704786300659
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/misc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:48:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\misc.c`\n\n---\n\n# cgroup/misc.c 技术文档\n\n## 文件概述\n\n`cgroup/misc.c` 实现了一个通用的 **miscellaneous cgroup controller（杂项资源控制组控制器）**，用于对系统中非传统类型的资源（如 AMD SEV/SEV-ES ASID 等安全加密虚拟化资源）进行配额管理和使用量跟踪。该控制器采用 **Limits 资源分配模型**，允许为每个 cgroup 设置资源使用上限（max），并确保整个系统的总使用量不超过主机实际容量（capacity）。该模块支持资源的尝试性计费（try-charge）、取消计费（uncharge）、容量设置、使用量查询及事件通知等功能。\n\n## 核心功能\n\n### 主要数据结构\n\n- `struct misc_cg`：表示一个 misc cgroup 实例，包含每种资源类型的 `struct misc_res`。\n- `struct misc_res`（定义在 `<linux/misc_cgroup.h>`）：\n  - `usage`：当前资源使用量（`atomic64_t`）\n  - `max`：该 cgroup 的资源使用上限（`u64`）\n  - `watermark`：历史峰值使用量（`atomic64_t`）\n  - `events` / `events_local`：事件计数器（用于通知）\n- `misc_res_capacity[MISC_CG_RES_TYPES]`：全局数组，记录每种资源在整机上的实际容量。\n- `root_cg`：根 misc cgroup 实例。\n- `misc_res_name[]`：资源类型的字符串名称映射（与 `enum misc_res_type` 同步）。\n\n### 主要导出函数（API）\n\n- `misc_cg_set_capacity(enum misc_res_type type, u64 capacity)`  \n  设置指定资源类型的整机容量。容量为 0 表示该资源不可用。\n- `misc_cg_try_charge(enum misc_res_type type, struct misc_cg *cg, u64 amount)`  \n  尝试对指定 cgroup 计费指定资源量。若超过该 cgroup 的 `max` 限制或整机 `capacity`，则失败并回滚。\n- `misc_cg_uncharge(enum misc_res_type type, struct misc_cg *cg, u64 amount)`  \n  从指定 cgroup 取消指定资源量的计费。\n- `misc_cg_res_total_usage(enum misc_res_type type)`  \n  获取指定资源类型的全局总使用量（即根 cgroup 的 usage）。\n\n### 主要内部函数\n\n- `parent_misc()`：获取 misc cgroup 的父节点。\n- `valid_type()`：验证资源类型是否有效。\n- `misc_cg_cancel_charge()`：原子地减少资源使用量，并检查负值（使用 `WARN_ONCE`）。\n- `misc_cg_update_watermark()`：原子地更新资源使用峰值（watermark）。\n- `misc_cg_event()`：触发资源事件通知（本地及向上传播到祖先）。\n- `misc_cg_max_show/write`：实现 `misc.max` 接口文件的读写。\n- `misc_cg_current_show`：实现 `misc.current` 接口文件的读取。\n- `misc_cg_peak_show`：实现 `misc.peak` 接口文件的读取（代码未完整显示，但可推断）。\n\n## 关键实现\n\n### 资源计费与回滚机制\n- **计费流程**：从目标 cgroup 向上遍历至根 cgroup，依次原子增加各层级的 `usage`。\n- **限制检查**：每层检查 `new_usage <= res->max` 且 `new_usage <= misc_res_capacity[type]`。\n- **失败回滚**：若任一层检查失败，立即触发事件通知，并从目标 cgroup 到失败层（含）逐层原子减少已增加的 `usage`，保证状态一致性。\n\n### 原子操作与并发安全\n- 所有资源使用量（`usage`）、峰值（`watermark`）和事件计数均使用 `atomic64_t` 类型，确保多线程/多 CPU 环境下的安全访问。\n- 容量（`misc_res_capacity`）和上限（`max`）使用 `READ_ONCE`/`WRITE_ONCE` 进行访问，避免编译器优化导致的不一致。\n\n### 接口文件实现\n- **`misc.max`**：\n  - **读**：输出每种已启用资源（`capacity > 0`）的 `max` 值；若为 `U64_MAX` 则显示为 `\"max\"`。\n  - **写**：格式为 `\"<resource_name> <value>\"`，`value` 可为正整数或 `\"max\"`（表示无限制）。\n- **`misc.current`**：输出每种资源（只要 `capacity > 0` 或 `usage > 0`）的当前使用量。\n- **`misc.peak`**（推断）：输出每种资源的历史峰值使用量（`watermark`）。\n\n### 事件通知\n- 当计费失败时，调用 `misc_cg_event()`：\n  - 增加当前 cgroup 的本地事件计数器（`events_local`）并通知 `events_local_file`。\n  - 向上遍历所有祖先 cgroup，增加其全局事件计数器（`events`）并通知 `events_file`。\n\n## 依赖关系\n\n- **内核头文件**：\n  - `<linux/cgroup.h>`：cgroup 核心框架。\n  - `<linux/misc_cgroup.h>`：定义 `struct misc_cg`、`struct misc_res`、`enum misc_res_type` 等关键数据结构和类型。\n  - `<linux/atomic.h>`：提供原子操作。\n  - `<linux/slab.h>`：内存分配。\n- **配置选项**：\n  - `CONFIG_KVM_AMD_SEV`：决定是否启用 `\"sev\"` 和 `\"sev_es\"` 资源类型。\n- **其他模块**：\n  - **KVM 模块**：在启用 AMD SEV/SEV-ES 时，会调用本模块的 API（如 `misc_cg_try_charge`/`misc_cg_uncharge`）来管理 ASID 资源。\n  - **cgroup 核心**：通过 `css_misc()`、`cgroup_file_notify()` 等接口与 cgroup 子系统集成。\n\n## 使用场景\n\n1. **AMD SEV/SEV-ES 资源管理**：\n   - 在支持 AMD 安全加密虚拟化（SEV/SEV-ES）的系统中，ASID（Address Space Identifier）是一种有限的硬件资源。\n   - KVM 模块在创建/销毁 SEV 虚拟机时，通过 `misc_cg_try_charge`/`misc_cg_uncharge` 对当前进程所属的 misc cgroup 进行 ASID 资源计费。\n   - 管理员可通过 `misc.max` 文件为不同 cgroup 设置 ASID 使用上限，防止单个用户或服务耗尽全局 ASID 资源。\n\n2. **通用杂项资源控制框架**：\n   - 该控制器设计为可扩展，未来可支持其他类型的有限系统资源（如特定硬件加速器的上下文、特殊内存区域等）。\n   - 通过 `misc_cg_set_capacity` 在系统初始化时注册资源容量，通过标准 cgroup 接口进行配额分配和监控。\n\n3. **资源监控与告警**：\n   - 用户空间可通过读取 `misc.current` 和 `misc.peak` 监控资源使用情况。\n   - 当资源分配失败（如达到 `max` 限制）时，内核会更新事件计数器，用户空间可通过 `inotify` 或轮询 `misc.events` 文件获取通知，实现自动化告警或扩缩容。",
      "similarity": 0.4931464195251465,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 1,
          "end_line": 64,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Miscellaneous cgroup controller",
            " *",
            " * Copyright 2020 Google LLC",
            " * Author: Vipin Sharma <vipinsh@google.com>",
            " */",
            "",
            "#include <linux/limits.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/errno.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/misc_cgroup.h>",
            "",
            "#define MAX_STR \"max\"",
            "#define MAX_NUM U64_MAX",
            "",
            "/* Miscellaneous res name, keep it in sync with enum misc_res_type */",
            "static const char *const misc_res_name[] = {",
            "#ifdef CONFIG_KVM_AMD_SEV",
            "\t/* AMD SEV ASIDs resource */",
            "\t\"sev\",",
            "\t/* AMD SEV-ES ASIDs resource */",
            "\t\"sev_es\",",
            "#endif",
            "};",
            "",
            "/* Root misc cgroup */",
            "static struct misc_cg root_cg;",
            "",
            "/*",
            " * Miscellaneous resources capacity for the entire machine. 0 capacity means",
            " * resource is not initialized or not present in the host.",
            " *",
            " * root_cg.max and capacity are independent of each other. root_cg.max can be",
            " * more than the actual capacity. We are using Limits resource distribution",
            " * model of cgroup for miscellaneous controller.",
            " */",
            "static u64 misc_res_capacity[MISC_CG_RES_TYPES];",
            "",
            "/**",
            " * parent_misc() - Get the parent of the passed misc cgroup.",
            " * @cgroup: cgroup whose parent needs to be fetched.",
            " *",
            " * Context: Any context.",
            " * Return:",
            " * * struct misc_cg* - Parent of the @cgroup.",
            " * * %NULL - If @cgroup is null or the passed cgroup does not have a parent.",
            " */",
            "static struct misc_cg *parent_misc(struct misc_cg *cgroup)",
            "{",
            "\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;",
            "}",
            "",
            "/**",
            " * valid_type() - Check if @type is valid or not.",
            " * @type: misc res type.",
            " *",
            " * Context: Any context.",
            " * Return:",
            " * * true - If valid type.",
            " * * false - If not valid type.",
            " */"
          ],
          "function_name": null,
          "description": "定义misc控制器的资源名称数组和根cgroup结构，提供父节点查询函数，用于管理杂项资源的层级关系和容量配置",
          "similarity": 0.5003173351287842
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 266,
          "end_line": 368,
          "content": [
            "static ssize_t misc_cg_max_write(struct kernfs_open_file *of, char *buf,",
            "\t\t\t\t size_t nbytes, loff_t off)",
            "{",
            "\tstruct misc_cg *cg;",
            "\tu64 max;",
            "\tint ret = 0, i;",
            "\tenum misc_res_type type = MISC_CG_RES_TYPES;",
            "\tchar *token;",
            "",
            "\tbuf = strstrip(buf);",
            "\ttoken = strsep(&buf, \" \");",
            "",
            "\tif (!token || !buf)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tif (!strcmp(misc_res_name[i], token)) {",
            "\t\t\ttype = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (type == MISC_CG_RES_TYPES)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!strcmp(MAX_STR, buf)) {",
            "\t\tmax = MAX_NUM;",
            "\t} else {",
            "\t\tret = kstrtou64(buf, 0, &max);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tcg = css_misc(of_css(of));",
            "",
            "\tif (READ_ONCE(misc_res_capacity[type]))",
            "\t\tWRITE_ONCE(cg->res[type].max, max);",
            "\telse",
            "\t\tret = -EINVAL;",
            "",
            "\treturn ret ? ret : nbytes;",
            "}",
            "static int misc_cg_current_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tu64 usage;",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tusage = atomic64_read(&cg->res[i].usage);",
            "\t\tif (READ_ONCE(misc_res_capacity[i]) || usage)",
            "\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], usage);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int misc_cg_peak_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tu64 watermark;",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\twatermark = atomic64_read(&cg->res[i].watermark);",
            "\t\tif (READ_ONCE(misc_res_capacity[i]) || watermark)",
            "\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], watermark);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int misc_cg_capacity_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tu64 cap;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tcap = READ_ONCE(misc_res_capacity[i]);",
            "\t\tif (cap)",
            "\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], cap);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __misc_events_show(struct seq_file *sf, bool local)",
            "{",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "\tu64 events;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tif (local)",
            "\t\t\tevents = atomic64_read(&cg->res[i].events_local);",
            "\t\telse",
            "\t\t\tevents = atomic64_read(&cg->res[i].events);",
            "\t\tif (READ_ONCE(misc_res_capacity[i]) || events)",
            "\t\t\tseq_printf(sf, \"%s.max %llu\\n\", misc_res_name[i], events);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int misc_events_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn __misc_events_show(sf, false);",
            "}"
          ],
          "function_name": "misc_cg_max_write, misc_cg_current_show, misc_cg_peak_show, misc_cg_capacity_show, __misc_events_show, misc_events_show",
          "description": "提供资源最大值写入接口和当前使用量、峰值、容量展示接口，支持通过seq_file接口暴露资源统计信息到用户空间",
          "similarity": 0.495813250541687
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 65,
          "end_line": 175,
          "content": [
            "static inline bool valid_type(enum misc_res_type type)",
            "{",
            "\treturn type >= 0 && type < MISC_CG_RES_TYPES;",
            "}",
            "u64 misc_cg_res_total_usage(enum misc_res_type type)",
            "{",
            "\tif (valid_type(type))",
            "\t\treturn atomic64_read(&root_cg.res[type].usage);",
            "",
            "\treturn 0;",
            "}",
            "int misc_cg_set_capacity(enum misc_res_type type, u64 capacity)",
            "{",
            "\tif (!valid_type(type))",
            "\t\treturn -EINVAL;",
            "",
            "\tWRITE_ONCE(misc_res_capacity[type], capacity);",
            "\treturn 0;",
            "}",
            "static void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,",
            "\t\t\t\t  u64 amount)",
            "{",
            "\tWARN_ONCE(atomic64_add_negative(-amount, &cg->res[type].usage),",
            "\t\t  \"misc cgroup resource %s became less than 0\",",
            "\t\t  misc_res_name[type]);",
            "}",
            "static void misc_cg_update_watermark(struct misc_res *res, u64 new_usage)",
            "{",
            "\tu64 old;",
            "",
            "\twhile (true) {",
            "\t\told = atomic64_read(&res->watermark);",
            "\t\tif (new_usage <= old)",
            "\t\t\tbreak;",
            "\t\tif (atomic64_cmpxchg(&res->watermark, old, new_usage) == old)",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "static void misc_cg_event(enum misc_res_type type, struct misc_cg *cg)",
            "{",
            "\tatomic64_inc(&cg->res[type].events_local);",
            "\tcgroup_file_notify(&cg->events_local_file);",
            "",
            "\tfor (; parent_misc(cg); cg = parent_misc(cg)) {",
            "\t\tatomic64_inc(&cg->res[type].events);",
            "\t\tcgroup_file_notify(&cg->events_file);",
            "\t}",
            "}",
            "int misc_cg_try_charge(enum misc_res_type type, struct misc_cg *cg, u64 amount)",
            "{",
            "\tstruct misc_cg *i, *j;",
            "\tint ret;",
            "\tstruct misc_res *res;",
            "\tu64 new_usage;",
            "",
            "\tif (!(valid_type(type) && cg && READ_ONCE(misc_res_capacity[type])))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!amount)",
            "\t\treturn 0;",
            "",
            "\tfor (i = cg; i; i = parent_misc(i)) {",
            "\t\tres = &i->res[type];",
            "",
            "\t\tnew_usage = atomic64_add_return(amount, &res->usage);",
            "\t\tif (new_usage > READ_ONCE(res->max) ||",
            "\t\t    new_usage > READ_ONCE(misc_res_capacity[type])) {",
            "\t\t\tret = -EBUSY;",
            "\t\t\tgoto err_charge;",
            "\t\t}",
            "\t\tmisc_cg_update_watermark(res, new_usage);",
            "\t}",
            "\treturn 0;",
            "",
            "err_charge:",
            "\tmisc_cg_event(type, i);",
            "",
            "\tfor (j = cg; j != i; j = parent_misc(j))",
            "\t\tmisc_cg_cancel_charge(type, j, amount);",
            "\tmisc_cg_cancel_charge(type, i, amount);",
            "\treturn ret;",
            "}",
            "void misc_cg_uncharge(enum misc_res_type type, struct misc_cg *cg, u64 amount)",
            "{",
            "\tstruct misc_cg *i;",
            "",
            "\tif (!(amount && valid_type(type) && cg))",
            "\t\treturn;",
            "",
            "\tfor (i = cg; i; i = parent_misc(i))",
            "\t\tmisc_cg_cancel_charge(type, i, amount);",
            "}",
            "static int misc_cg_max_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "\tu64 max;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tif (READ_ONCE(misc_res_capacity[i])) {",
            "\t\t\tmax = READ_ONCE(cg->res[i].max);",
            "\t\t\tif (max == MAX_NUM)",
            "\t\t\t\tseq_printf(sf, \"%s max\\n\", misc_res_name[i]);",
            "\t\t\telse",
            "\t\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i],",
            "\t\t\t\t\t   max);",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "valid_type, misc_cg_res_total_usage, misc_cg_set_capacity, misc_cg_cancel_charge, misc_cg_update_watermark, misc_cg_event, misc_cg_try_charge, misc_cg_uncharge, misc_cg_max_show",
          "description": "实现资源类型有效性验证、总使用量查询、容量设置、资源充放电控制及水位更新逻辑，支持递归充电检查与事件通知机制",
          "similarity": 0.4907843768596649
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 401,
          "end_line": 408,
          "content": [
            "static int misc_events_local_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn __misc_events_show(sf, true);",
            "}",
            "static void misc_cg_free(struct cgroup_subsys_state *css)",
            "{",
            "\tkfree(css_misc(css));",
            "}"
          ],
          "function_name": "misc_events_local_show, misc_cg_free",
          "description": "实现本地事件统计展示接口和cgroup子系统状态释放函数，用于清理misc控制器相关内存资源",
          "similarity": 0.4711396098136902
        }
      ]
    }
  ]
}