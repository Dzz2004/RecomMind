{
  "query": "虚拟内存的地址空间 死锁的定义和条件",
  "timestamp": "2025-12-25 23:29:34",
  "retrieved_files": [
    {
      "source_file": "kernel/module/tree_lookup.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:09:32\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\tree_lookup.c`\n\n---\n\n# module/tree_lookup.c 技术文档\n\n## 1. 文件概述\n\n`module/tree_lookup.c` 实现了一个基于**锁存红黑树（latched RB-tree）** 的模块地址查找机制，用于高效地根据内存地址定位所属的内核模块。该机制专为高性能、低延迟的地址查询场景设计，特别适用于性能事件（perf events）和跟踪（tracing）子系统在任意上下文（包括 NMI）中频繁调用 `__module_address()` 的情况。通过使用 RCU-sched 语义，该实现支持无锁读取，同时保证写操作（模块加载/卸载）的安全性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `mod_tree_insert(struct module *mod)`  \n  将模块的所有内存区域（按类型）插入全局模块树 `mod_tree`。\n\n- `mod_tree_remove_init(struct module *mod)`  \n  仅移除模块的初始化内存区域（如 `.init.text`、`.init.data` 等）。\n\n- `mod_tree_remove(struct module *mod)`  \n  移除模块的所有内存区域。\n\n- `mod_find(unsigned long addr, struct mod_tree_root *tree)`  \n  在指定模块树中查找包含给定地址 `addr` 的模块，返回对应的 `struct module *`。\n\n- `__mod_tree_insert()` / `__mod_tree_remove()`  \n  内部辅助函数，封装对 `latch_tree_insert()` 和 `latch_tree_erase()` 的调用。\n\n### 关键数据结构\n\n- `struct latch_tree_ops mod_tree_ops`  \n  定义模块树的比较和排序逻辑，包含：\n  - `.less`：节点间大小比较函数\n  - `.comp`：键值与节点的范围比较函数\n\n- `struct mod_tree_node`（隐含在 `struct module_memory` 中）  \n  模块内存区域在红黑树中的节点表示，包含指向所属模块的指针。\n\n## 3. 关键实现\n\n### 锁存红黑树（Latched RB-tree）机制\n- 使用 `latch_tree` 数据结构，支持**双版本（double-buffered）** 更新，允许读者在不加锁的情况下通过 RCU-sched 安全遍历。\n- 写操作（插入/删除）由 `module_mutex` 串行化，确保树结构修改的原子性。\n- 读操作（`mod_find`）可在任意上下文（包括中断、NMI）中执行，无需获取锁。\n\n### 地址范围比较逻辑\n- 每个模块内存区域由基地址（`base`）和大小（`size`）定义。\n- `mod_tree_comp()` 函数实现**区间包含判断**：\n  - 若查询地址 `< base`，返回 `-1`（在左侧）\n  - 若查询地址 `>= base + size`，返回 `1`（在右侧）\n  - 否则返回 `0`（命中该区域）\n\n### 内存区域类型遍历\n- 使用宏 `for_each_mod_mem_type()` 和 `for_class_mod_mem_type()` 遍历模块的所有内存段类型（如代码段、数据段、初始化段等）。\n- 仅当内存区域大小非零时才插入/移除树节点，避免无效条目。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：提供 `struct module` 等核心模块定义\n  - `<linux/rbtree_latch.h>`：提供锁存红黑树实现\n  - `\"internal.h\"`：包含模块子系统内部数据结构（如 `mod_tree` 全局变量、`module_memory` 定义等）\n\n- **全局变量依赖**：\n  - `mod_tree`：全局 `struct mod_tree_root` 实例，定义在 `internal.h` 中\n  - `module_mutex`：序列化模块树修改操作的互斥锁\n\n- **条件编译**：  \n  该文件功能仅在 `CONFIG_PERF_EVENTS || CONFIG_TRACING` 启用时编译，因其主要服务于性能分析和跟踪场景。\n\n## 5. 使用场景\n\n- **性能分析（perf）**：  \n  在 perf 采样中断或 NMI 中，通过 `__module_address()` 快速确定程序计数器（PC）是否位于某个内核模块内，用于符号解析和调用栈展开。\n\n- **内核跟踪（ftrace/kprobes）**：  \n  跟踪点触发时需识别当前执行地址所属模块，以提供模块上下文信息。\n\n- **模块卸载安全检查**：  \n  在模块移除前，通过地址查询验证无活跃引用（如 kprobe、ftrace 等）。\n\n- **内核 Oops/panic 诊断**：  \n  在内核崩溃时，快速定位错误地址所属模块，辅助调试。\n\n该实现通过无锁读取和高效区间查询，显著提升了高频率地址查找场景下的系统性能和实时性。",
      "similarity": 0.5613287687301636,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/module/tree_lookup.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Modules tree lookup",
            " *",
            " * Copyright (C) 2015 Peter Zijlstra",
            " * Copyright (C) 2015 Rusty Russell",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/rbtree_latch.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * Use a latched RB-tree for __module_address(); this allows us to use",
            " * RCU-sched lookups of the address from any context.",
            " *",
            " * This is conditional on PERF_EVENTS || TRACING because those can really hit",
            " * __module_address() hard by doing a lot of stack unwinding; potentially from",
            " * NMI context.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "定义使用带闩锁的RB树结构，用于支持模块地址查询，允许RCU-sched上下文下的安全查找，该实现依赖PERF_EVENTS或TRACING特性以应对高频栈遍历场景",
          "similarity": 0.5294673442840576
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/tree_lookup.c",
          "start_line": 22,
          "end_line": 84,
          "content": [
            "static __always_inline unsigned long __mod_tree_val(struct latch_tree_node *n)",
            "{",
            "\tstruct module_memory *mod_mem = container_of(n, struct module_memory, mtn.node);",
            "",
            "\treturn (unsigned long)mod_mem->base;",
            "}",
            "static __always_inline unsigned long __mod_tree_size(struct latch_tree_node *n)",
            "{",
            "\tstruct module_memory *mod_mem = container_of(n, struct module_memory, mtn.node);",
            "",
            "\treturn (unsigned long)mod_mem->size;",
            "}",
            "static __always_inline bool",
            "mod_tree_less(struct latch_tree_node *a, struct latch_tree_node *b)",
            "{",
            "\treturn __mod_tree_val(a) < __mod_tree_val(b);",
            "}",
            "static __always_inline int",
            "mod_tree_comp(void *key, struct latch_tree_node *n)",
            "{",
            "\tunsigned long val = (unsigned long)key;",
            "\tunsigned long start, end;",
            "",
            "\tstart = __mod_tree_val(n);",
            "\tif (val < start)",
            "\t\treturn -1;",
            "",
            "\tend = start + __mod_tree_size(n);",
            "\tif (val >= end)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static noinline void __mod_tree_insert(struct mod_tree_node *node, struct mod_tree_root *tree)",
            "{",
            "\tlatch_tree_insert(&node->node, &tree->root, &mod_tree_ops);",
            "}",
            "static void __mod_tree_remove(struct mod_tree_node *node, struct mod_tree_root *tree)",
            "{",
            "\tlatch_tree_erase(&node->node, &tree->root, &mod_tree_ops);",
            "}",
            "void mod_tree_insert(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tmod->mem[type].mtn.mod = mod;",
            "\t\tif (mod->mem[type].size)",
            "\t\t\t__mod_tree_insert(&mod->mem[type].mtn, &mod_tree);",
            "\t}",
            "}",
            "void mod_tree_remove_init(struct module *mod)",
            "{",
            "\tfor_class_mod_mem_type(type, init) {",
            "\t\tif (mod->mem[type].size)",
            "\t\t\t__mod_tree_remove(&mod->mem[type].mtn, &mod_tree);",
            "\t}",
            "}",
            "void mod_tree_remove(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tif (mod->mem[type].size)",
            "\t\t\t__mod_tree_remove(&mod->mem[type].mtn, &mod_tree);",
            "\t}",
            "}"
          ],
          "function_name": "__mod_tree_val, __mod_tree_size, mod_tree_less, mod_tree_comp, __mod_tree_insert, __mod_tree_remove, mod_tree_insert, mod_tree_remove_init, mod_tree_remove",
          "description": "实现模块内存区域的树状管理逻辑，包含节点值/大小提取、比较函数及插入/删除操作，通过latch_tree接口维护模块地址映射表，支持模块加载时插入和卸载时移除内存节点",
          "similarity": 0.4641221761703491
        }
      ]
    },
    {
      "source_file": "kernel/watchdog.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:51:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watchdog.c`\n\n---\n\n# watchdog.c 技术文档\n\n## 1. 文件概述\n\n`watchdog.c` 是 Linux 内核中实现 **硬锁死（hard lockup）** 和 **软锁死（soft lockup）** 检测机制的核心文件。该机制用于监控系统中 CPU 是否因长时间禁用中断或陷入无限循环而无法响应，从而帮助诊断系统挂死问题。硬锁死指 CPU 完全停止响应中断（包括 NMI），软锁死指内核线程长时间占用 CPU 且未调度其他任务。本文件主要聚焦于硬锁死检测的通用框架和部分实现，软锁死检测逻辑主要在其他文件（如 `softlockup.c`）中实现，但两者共享部分配置和控制逻辑。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `watchdog_enabled`：位掩码，表示当前启用的 watchdog 类型（软/硬锁死检测）。\n- `watchdog_user_enabled`：用户空间是否启用 watchdog（默认 1）。\n- `watchdog_hardlockup_user_enabled`：用户空间是否启用硬锁死检测（默认值取决于架构）。\n- `watchdog_softlockup_user_enabled`：用户空间是否启用软锁死检测（默认 1）。\n- `watchdog_thresh`：锁死检测阈值（秒，默认 10 秒）。\n- `watchdog_cpumask`：参与 watchdog 检测的 CPU 掩码。\n- `hardlockup_panic`：硬锁死发生时是否触发内核 panic（默认由 `CONFIG_BOOTPARAM_HARDLOCKUP_PANIC` 决定）。\n- `sysctl_hardlockup_all_cpu_backtrace`（SMP）：硬锁死时是否打印所有 CPU 的 backtrace。\n- `hardlockup_count`（SYSFS）：记录硬锁死事件发生次数。\n\n### 主要函数\n- `hardlockup_detector_disable(void)`：在启动早期禁用硬锁死检测（例如虚拟机环境）。\n- `hardlockup_panic_setup(char *str)`：解析内核启动参数 `nmi_watchdog=`，配置硬锁死行为。\n- `arch_touch_nmi_watchdog(void)`：架构相关函数，用于在关键路径“触摸”硬 watchdog，防止误报（导出符号）。\n- `watchdog_hardlockup_touch_cpu(unsigned int cpu)`：标记指定 CPU 已被“触摸”。\n- `is_hardlockup(unsigned int cpu)`：检查指定 CPU 是否发生硬锁死（基于高精度定时器中断计数）。\n- `watchdog_hardlockup_kick(void)`：在高精度定时器中断中“踢”硬 watchdog（更新中断计数）。\n- `watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs)`：执行硬锁死检测逻辑，打印诊断信息并可能触发 panic。\n- `watchdog_hardlockup_enable/disable(unsigned int cpu)`：弱符号函数，由具体硬 watchdog 实现（如 perf-based）覆盖，用于启停 per-CPU 检测。\n- `watchdog_hardlockup_probe(void)`：弱符号函数，由具体实现提供，用于探测硬 watchdog 硬件/机制是否可用。\n\n### 核心数据结构（Per-CPU）\n- `hrtimer_interrupts`：高精度定时器中断计数器（原子变量）。\n- `hrtimer_interrupts_saved`：上次保存的中断计数值。\n- `watchdog_hardlockup_warned`：是否已为该 CPU 打印过硬锁死警告。\n- `watchdog_hardlockup_touched`：该 CPU 是否被“触摸”过（用于豁免检测）。\n\n## 3. 关键实现\n\n### 硬锁死检测机制（基于高精度定时器）\n当配置 `CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER` 时，硬锁死检测通过监控 **高精度定时器（hrtimer）中断** 的发生频率实现：\n1. **计数更新**：每次 hrtimer 中断发生时，调用 `watchdog_hardlockup_kick()` 原子递增 per-CPU 计数器 `hrtimer_interrupts`。\n2. **检测逻辑**：在 NMI（不可屏蔽中断）上下文（或其他检测点）调用 `watchdog_hardlockup_check()`：\n   - 若 CPU 被“触摸”（`watchdog_hardlockup_touched` 为真），则清除此标记并跳过检测。\n   - 否则调用 `is_hardlockup()`：比较当前 `hrtimer_interrupts` 与上次保存值 `hrtimer_interrupts_saved`。若相等，说明在检测周期内无 hrtimer 中断，判定为硬锁死。\n3. **告警与处理**：\n   - 首次检测到硬锁死时，打印紧急日志（CPU 信息、模块列表、中断跟踪、寄存器状态或栈回溯）。\n   - 若启用 `sysctl_hardlockup_all_cpu_backtrace`，触发其他 CPU 的 backtrace。\n   - 若 `hardlockup_panic` 为真，调用 `nmi_panic()` 触发内核 panic。\n   - 设置 `watchdog_hardlockup_warned` 避免重复告警。\n\n### 启动参数与配置\n- **`nmi_watchdog=` 参数**：通过 `__setup` 宏注册，支持以下值：\n  - `panic`/`nopanic`：设置 `hardlockup_panic`。\n  - `0`/`1`：启用/禁用硬锁死检测。\n  - `r...`：传递参数给 perf-based 检测器（`hardlockup_config_perf_event`）。\n- **早期禁用**：`hardlockup_detector_disable()` 可在解析命令行前禁用硬检测（如 KVM guest）。\n\n### 架构交互与豁免\n- **`arch_touch_nmi_watchdog()`**：允许架构代码或关键内核路径（如 printk）临时豁免硬 watchdog 检测，防止在已知安全的长操作中误报。使用 `raw_cpu_write` 确保在抢占/中断使能环境下安全。\n\n### 弱符号扩展点\n- `watchdog_hardlockup_enable/disable/probe` 声明为 `__weak`，允许不同架构或检测方法（如基于 perf event 的 NMI watchdog）提供具体实现，实现检测机制的可插拔。\n\n## 4. 依赖关系\n\n- **内核子系统**：\n  - `<linux/nmi.h>`：NMI 处理框架，硬锁死检测通常在 NMI 上下文触发。\n  - `<linux/hrtimer.h>`（隐含）：高精度定时器中断作为检测心跳源。\n  - `<linux/sched/*.h>`：调度器相关（`print_irqtrace_events`, `dump_stack`）。\n  - `<linux/sysctl.h>`：提供 `sysctl_hardlockup_all_cpu_backtrace` 控制接口。\n  - `<linux/sysfs.h>`：暴露 `hardlockup_count` 到 sysfs。\n  - `<asm/irq_regs.h>`：获取中断上下文寄存器状态（`show_regs`）。\n- **配置选项**：\n  - `CONFIG_HARDLOCKUP_DETECTOR`：启用硬锁死检测框架。\n  - `CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER`：使用 hrtimer 中断计数实现检测。\n  - `CONFIG_HARDLOCKUP_DETECTOR_SPARC64`：SPARC64 架构默认启用硬检测。\n  - `CONFIG_BOOTPARAM_HARDLOCKUP_PANIC`：设置默认 panic 行为。\n  - `CONFIG_SMP`：多核支持（`all_cpu_backtrace` 功能）。\n  - `CONFIG_SYSFS`：sysfs 接口支持。\n- **其他模块**：依赖具体架构的 NMI 实现（如 x86 的 perf-based NMI watchdog）提供检测触发点。\n\n## 5. 使用场景\n\n- **系统稳定性监控**：在生产服务器或嵌入式设备中持续监控 CPU 响应性，及时发现硬件故障、驱动 bug 或内核死锁导致的系统挂死。\n- **内核调试**：开发人员通过 watchdog 触发的 backtrace 和寄存器转储，定位导致系统无响应的代码路径。\n- **虚拟化环境**：在 hypervisor guest 中可选择性禁用硬 watchdog（因虚拟化开销可能导致误报），通过 `hardlockup_detector_disable()` 或启动参数控制。\n- **实时系统**：结合 CPU 隔离（`isolcpus`）和 watchdog 配置，确保关键 CPU 核心的响应性，同时避免在非关键核上产生干扰。\n- **panic 策略**：通过 `hardlockup_panic` 配置，使系统在硬锁死时自动重启，提高无人值守系统的可用性。",
      "similarity": 0.5573567748069763,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/watchdog.c",
          "start_line": 1,
          "end_line": 72,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Detect hard and soft lockups on a system",
            " *",
            " * started by Don Zickus, Copyright (C) 2010 Red Hat, Inc.",
            " *",
            " * Note: Most of this code is borrowed heavily from the original softlockup",
            " * detector, so thanks to Ingo for the initial implementation.",
            " * Some chunks also taken from the old x86-specific nmi watchdog code, thanks",
            " * to those contributors as well.",
            " */",
            "",
            "#define pr_fmt(fmt) \"watchdog: \" fmt",
            "",
            "#include <linux/cpu.h>",
            "#include <linux/init.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/irq.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/math64.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/tick.h>",
            "",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/isolation.h>",
            "",
            "#include <asm/irq_regs.h>",
            "",
            "static DEFINE_MUTEX(watchdog_mutex);",
            "",
            "#if defined(CONFIG_HARDLOCKUP_DETECTOR) || defined(CONFIG_HARDLOCKUP_DETECTOR_SPARC64)",
            "# define WATCHDOG_HARDLOCKUP_DEFAULT\t1",
            "#else",
            "# define WATCHDOG_HARDLOCKUP_DEFAULT\t0",
            "#endif",
            "",
            "#define NUM_SAMPLE_PERIODS\t5",
            "",
            "unsigned long __read_mostly watchdog_enabled;",
            "int __read_mostly watchdog_user_enabled = 1;",
            "static int __read_mostly watchdog_hardlockup_user_enabled = WATCHDOG_HARDLOCKUP_DEFAULT;",
            "static int __read_mostly watchdog_softlockup_user_enabled = 1;",
            "int __read_mostly watchdog_thresh = 10;",
            "static int __read_mostly watchdog_thresh_next;",
            "static int __read_mostly watchdog_hardlockup_available;",
            "",
            "struct cpumask watchdog_cpumask __read_mostly;",
            "unsigned long *watchdog_cpumask_bits = cpumask_bits(&watchdog_cpumask);",
            "",
            "#ifdef CONFIG_HARDLOCKUP_DETECTOR",
            "",
            "# ifdef CONFIG_SMP",
            "int __read_mostly sysctl_hardlockup_all_cpu_backtrace;",
            "# endif /* CONFIG_SMP */",
            "",
            "/*",
            " * Should we panic when a soft-lockup or hard-lockup occurs:",
            " */",
            "unsigned int __read_mostly hardlockup_panic =",
            "\t\t\tIS_ENABLED(CONFIG_BOOTPARAM_HARDLOCKUP_PANIC);",
            "",
            "#ifdef CONFIG_SYSFS",
            "",
            "static unsigned int hardlockup_count;",
            ""
          ],
          "function_name": null,
          "description": "定义硬锁和软锁检测模块的全局变量及配置选项，初始化硬锁检测相关数据结构和默认启用状态。",
          "similarity": 0.5213554501533508
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/watchdog.c",
          "start_line": 73,
          "end_line": 217,
          "content": [
            "static ssize_t hardlockup_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\t     char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%u\\n\", hardlockup_count);",
            "}",
            "static __init int kernel_hardlockup_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &hardlockup_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "void __init hardlockup_detector_disable(void)",
            "{",
            "\twatchdog_hardlockup_user_enabled = 0;",
            "}",
            "static int __init hardlockup_panic_setup(char *str)",
            "{",
            "next:",
            "\tif (!strncmp(str, \"panic\", 5))",
            "\t\thardlockup_panic = 1;",
            "\telse if (!strncmp(str, \"nopanic\", 7))",
            "\t\thardlockup_panic = 0;",
            "\telse if (!strncmp(str, \"0\", 1))",
            "\t\twatchdog_hardlockup_user_enabled = 0;",
            "\telse if (!strncmp(str, \"1\", 1))",
            "\t\twatchdog_hardlockup_user_enabled = 1;",
            "\telse if (!strncmp(str, \"r\", 1))",
            "\t\thardlockup_config_perf_event(str + 1);",
            "\twhile (*(str++)) {",
            "\t\tif (*str == ',') {",
            "\t\t\tstr++;",
            "\t\t\tgoto next;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}",
            "notrace void arch_touch_nmi_watchdog(void)",
            "{",
            "\t/*",
            "\t * Using __raw here because some code paths have",
            "\t * preemption enabled.  If preemption is enabled",
            "\t * then interrupts should be enabled too, in which",
            "\t * case we shouldn't have to worry about the watchdog",
            "\t * going off.",
            "\t */",
            "\traw_cpu_write(watchdog_hardlockup_touched, true);",
            "}",
            "void watchdog_hardlockup_touch_cpu(unsigned int cpu)",
            "{",
            "\tper_cpu(watchdog_hardlockup_touched, cpu) = true;",
            "}",
            "static bool is_hardlockup(unsigned int cpu)",
            "{",
            "\tint hrint = atomic_read(&per_cpu(hrtimer_interrupts, cpu));",
            "",
            "\tif (per_cpu(hrtimer_interrupts_saved, cpu) == hrint)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * NOTE: we don't need any fancy atomic_t or READ_ONCE/WRITE_ONCE",
            "\t * for hrtimer_interrupts_saved. hrtimer_interrupts_saved is",
            "\t * written/read by a single CPU.",
            "\t */",
            "\tper_cpu(hrtimer_interrupts_saved, cpu) = hrint;",
            "",
            "\treturn false;",
            "}",
            "static void watchdog_hardlockup_kick(void)",
            "{",
            "\tint new_interrupts;",
            "",
            "\tnew_interrupts = atomic_inc_return(this_cpu_ptr(&hrtimer_interrupts));",
            "\twatchdog_buddy_check_hardlockup(new_interrupts);",
            "}",
            "void watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs)",
            "{",
            "\tif (per_cpu(watchdog_hardlockup_touched, cpu)) {",
            "\t\tper_cpu(watchdog_hardlockup_touched, cpu) = false;",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Check for a hardlockup by making sure the CPU's timer",
            "\t * interrupt is incrementing. The timer interrupt should have",
            "\t * fired multiple times before we overflow'd. If it hasn't",
            "\t * then this is a good indication the cpu is stuck",
            "\t */",
            "\tif (is_hardlockup(cpu)) {",
            "\t\tunsigned int this_cpu = smp_processor_id();",
            "\t\tunsigned long flags;",
            "",
            "#ifdef CONFIG_SYSFS",
            "\t\t++hardlockup_count;",
            "#endif",
            "",
            "\t\t/* Only print hardlockups once. */",
            "\t\tif (per_cpu(watchdog_hardlockup_warned, cpu))",
            "\t\t\treturn;",
            "",
            "\t\t/*",
            "\t\t * Prevent multiple hard-lockup reports if one cpu is already",
            "\t\t * engaged in dumping all cpu back traces.",
            "\t\t */",
            "\t\tif (sysctl_hardlockup_all_cpu_backtrace) {",
            "\t\t\tif (test_and_set_bit_lock(0, &hard_lockup_nmi_warn))",
            "\t\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * NOTE: we call printk_cpu_sync_get_irqsave() after printing",
            "\t\t * the lockup message. While it would be nice to serialize",
            "\t\t * that printout, we really want to make sure that if some",
            "\t\t * other CPU somehow locked up while holding the lock associated",
            "\t\t * with printk_cpu_sync_get_irqsave() that we can still at least",
            "\t\t * get the message about the lockup out.",
            "\t\t */",
            "\t\tpr_emerg(\"CPU%u: Watchdog detected hard LOCKUP on cpu %u\\n\", this_cpu, cpu);",
            "\t\tprintk_cpu_sync_get_irqsave(flags);",
            "",
            "\t\tprint_modules();",
            "\t\tprint_irqtrace_events(current);",
            "\t\tif (cpu == this_cpu) {",
            "\t\t\tif (regs)",
            "\t\t\t\tshow_regs(regs);",
            "\t\t\telse",
            "\t\t\t\tdump_stack();",
            "\t\t\tprintk_cpu_sync_put_irqrestore(flags);",
            "\t\t} else {",
            "\t\t\tprintk_cpu_sync_put_irqrestore(flags);",
            "\t\t\ttrigger_single_cpu_backtrace(cpu);",
            "\t\t}",
            "",
            "\t\tif (sysctl_hardlockup_all_cpu_backtrace) {",
            "\t\t\ttrigger_allbutcpu_cpu_backtrace(cpu);",
            "\t\t\tif (!hardlockup_panic)",
            "\t\t\t\tclear_bit_unlock(0, &hard_lockup_nmi_warn);",
            "\t\t}",
            "",
            "\t\tif (hardlockup_panic)",
            "\t\t\tnmi_panic(regs, \"Hard LOCKUP\");",
            "",
            "\t\tper_cpu(watchdog_hardlockup_warned, cpu) = true;",
            "\t} else {",
            "\t\tper_cpu(watchdog_hardlockup_warned, cpu) = false;",
            "\t}",
            "}"
          ],
          "function_name": "hardlockup_count_show, kernel_hardlockup_sysfs_init, hardlockup_detector_disable, hardlockup_panic_setup, arch_touch_nmi_watchdog, watchdog_hardlockup_touch_cpu, is_hardlockup, watchdog_hardlockup_kick, watchdog_hardlockup_check",
          "description": "实现硬锁检测核心逻辑，包含硬锁判断、计数统计、NMI触发电路及异常上报功能，通过中断计数器检测CPU卡顿。",
          "similarity": 0.48158377408981323
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/watchdog.c",
          "start_line": 946,
          "end_line": 1059,
          "content": [
            "void lockup_detector_reconfigure(void)",
            "{",
            "\tmutex_lock(&watchdog_mutex);",
            "\t__lockup_detector_reconfigure(false);",
            "\tmutex_unlock(&watchdog_mutex);",
            "}",
            "static __init void lockup_detector_setup(void)",
            "{",
            "\t/*",
            "\t * If sysctl is off and watchdog got disabled on the command line,",
            "\t * nothing to do here.",
            "\t */",
            "\tlockup_detector_update_enable();",
            "",
            "\tif (!IS_ENABLED(CONFIG_SYSCTL) &&",
            "\t    !(watchdog_enabled && watchdog_thresh))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "\t__lockup_detector_reconfigure(false);",
            "\tsoftlockup_initialized = true;",
            "\tmutex_unlock(&watchdog_mutex);",
            "}",
            "static void __lockup_detector_reconfigure(bool thresh_changed)",
            "{",
            "\tcpus_read_lock();",
            "\twatchdog_hardlockup_stop();",
            "\tif (thresh_changed)",
            "\t\twatchdog_thresh = READ_ONCE(watchdog_thresh_next);",
            "\tlockup_detector_update_enable();",
            "\twatchdog_hardlockup_start();",
            "\tcpus_read_unlock();",
            "}",
            "void lockup_detector_reconfigure(void)",
            "{",
            "\t__lockup_detector_reconfigure(false);",
            "}",
            "static inline void lockup_detector_setup(void)",
            "{",
            "\t__lockup_detector_reconfigure(false);",
            "}",
            "void lockup_detector_soft_poweroff(void)",
            "{",
            "\twatchdog_enabled = 0;",
            "}",
            "static void proc_watchdog_update(bool thresh_changed)",
            "{",
            "\t/* Remove impossible cpus to keep sysctl output clean. */",
            "\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);",
            "\t__lockup_detector_reconfigure(thresh_changed);",
            "}",
            "static int proc_watchdog_common(int which, struct ctl_table *table, int write,",
            "\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint err, old, *param = table->data;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "",
            "\told = *param;",
            "\tif (!write) {",
            "\t\t/*",
            "\t\t * On read synchronize the userspace interface. This is a",
            "\t\t * racy snapshot.",
            "\t\t */",
            "\t\t*param = (watchdog_enabled & which) != 0;",
            "\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\t\t*param = old;",
            "\t} else {",
            "\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\t\tif (!err && old != READ_ONCE(*param))",
            "\t\t\tproc_watchdog_update(false);",
            "\t}",
            "\tmutex_unlock(&watchdog_mutex);",
            "\treturn err;",
            "}",
            "int proc_watchdog(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn proc_watchdog_common(WATCHDOG_HARDLOCKUP_ENABLED |",
            "\t\t\t\t    WATCHDOG_SOFTOCKUP_ENABLED,",
            "\t\t\t\t    table, write, buffer, lenp, ppos);",
            "}",
            "int proc_nmi_watchdog(struct ctl_table *table, int write,",
            "\t\t      void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tif (!watchdog_hardlockup_available && write)",
            "\t\treturn -ENOTSUPP;",
            "\treturn proc_watchdog_common(WATCHDOG_HARDLOCKUP_ENABLED,",
            "\t\t\t\t    table, write, buffer, lenp, ppos);",
            "}",
            "int proc_soft_watchdog(struct ctl_table *table, int write,",
            "\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn proc_watchdog_common(WATCHDOG_SOFTOCKUP_ENABLED,",
            "\t\t\t\t    table, write, buffer, lenp, ppos);",
            "}",
            "int proc_watchdog_thresh(struct ctl_table *table, int write,",
            "\t\t\t void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint err, old;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "",
            "\twatchdog_thresh_next = READ_ONCE(watchdog_thresh);",
            "",
            "\told = watchdog_thresh_next;",
            "\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "",
            "\tif (!err && write && old != READ_ONCE(watchdog_thresh_next))",
            "\t\tproc_watchdog_update(true);",
            "",
            "\tmutex_unlock(&watchdog_mutex);",
            "\treturn err;",
            "}"
          ],
          "function_name": "lockup_detector_reconfigure, lockup_detector_setup, __lockup_detector_reconfigure, lockup_detector_reconfigure, lockup_detector_setup, lockup_detector_soft_poweroff, proc_watchdog_update, proc_watchdog_common, proc_watchdog, proc_nmi_watchdog, proc_soft_watchdog, proc_watchdog_thresh",
          "description": "提供看门狗参数动态配置接口，包含阈值更新、CPU掩码同步、sysctl参数读写控制逻辑，支持硬/软锁步检测模式切换和阈值调节",
          "similarity": 0.46875131130218506
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/watchdog.c",
          "start_line": 833,
          "end_line": 936,
          "content": [
            "static void watchdog_enable(unsigned int cpu)",
            "{",
            "\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);",
            "\tstruct completion *done = this_cpu_ptr(&softlockup_completion);",
            "",
            "\tWARN_ON_ONCE(cpu != smp_processor_id());",
            "",
            "\tinit_completion(done);",
            "\tcomplete(done);",
            "",
            "\t/*",
            "\t * Start the timer first to prevent the hardlockup watchdog triggering",
            "\t * before the timer has a chance to fire.",
            "\t */",
            "\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);",
            "\thrtimer->function = watchdog_timer_fn;",
            "\thrtimer_start(hrtimer, ns_to_ktime(sample_period),",
            "\t\t      HRTIMER_MODE_REL_PINNED_HARD);",
            "",
            "\t/* Initialize timestamp */",
            "\tupdate_touch_ts();",
            "\t/* Enable the hardlockup detector */",
            "\tif (watchdog_enabled & WATCHDOG_HARDLOCKUP_ENABLED)",
            "\t\twatchdog_hardlockup_enable(cpu);",
            "}",
            "static void watchdog_disable(unsigned int cpu)",
            "{",
            "\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);",
            "",
            "\tWARN_ON_ONCE(cpu != smp_processor_id());",
            "",
            "\t/*",
            "\t * Disable the hardlockup detector first. That prevents that a large",
            "\t * delay between disabling the timer and disabling the hardlockup",
            "\t * detector causes a false positive.",
            "\t */",
            "\twatchdog_hardlockup_disable(cpu);",
            "\thrtimer_cancel(hrtimer);",
            "\twait_for_completion(this_cpu_ptr(&softlockup_completion));",
            "}",
            "static int softlockup_stop_fn(void *data)",
            "{",
            "\twatchdog_disable(smp_processor_id());",
            "\treturn 0;",
            "}",
            "static void softlockup_stop_all(void)",
            "{",
            "\tint cpu;",
            "",
            "\tif (!softlockup_initialized)",
            "\t\treturn;",
            "",
            "\tfor_each_cpu(cpu, &watchdog_allowed_mask)",
            "\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);",
            "",
            "\tcpumask_clear(&watchdog_allowed_mask);",
            "}",
            "static int softlockup_start_fn(void *data)",
            "{",
            "\twatchdog_enable(smp_processor_id());",
            "\treturn 0;",
            "}",
            "static void softlockup_start_all(void)",
            "{",
            "\tint cpu;",
            "",
            "\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);",
            "\tfor_each_cpu(cpu, &watchdog_allowed_mask)",
            "\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);",
            "}",
            "int lockup_detector_online_cpu(unsigned int cpu)",
            "{",
            "\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))",
            "\t\twatchdog_enable(cpu);",
            "\treturn 0;",
            "}",
            "int lockup_detector_offline_cpu(unsigned int cpu)",
            "{",
            "\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))",
            "\t\twatchdog_disable(cpu);",
            "\treturn 0;",
            "}",
            "static void __lockup_detector_reconfigure(bool thresh_changed)",
            "{",
            "\tcpus_read_lock();",
            "\twatchdog_hardlockup_stop();",
            "",
            "\tsoftlockup_stop_all();",
            "\t/*",
            "\t * To prevent watchdog_timer_fn from using the old interval and",
            "\t * the new watchdog_thresh at the same time, which could lead to",
            "\t * false softlockup reports, it is necessary to update the",
            "\t * watchdog_thresh after the softlockup is completed.",
            "\t */",
            "\tif (thresh_changed)",
            "\t\twatchdog_thresh = READ_ONCE(watchdog_thresh_next);",
            "\tset_sample_period();",
            "\tlockup_detector_update_enable();",
            "\tif (watchdog_enabled && watchdog_thresh)",
            "\t\tsoftlockup_start_all();",
            "",
            "\twatchdog_hardlockup_start();",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "watchdog_enable, watchdog_disable, softlockup_stop_fn, softlockup_stop_all, softlockup_start_fn, softlockup_start_all, lockup_detector_online_cpu, lockup_detector_offline_cpu, __lockup_detector_reconfigure",
          "description": "定义看门狗启用/禁用逻辑，通过per-CPU定时器实现软锁步检测，包含初始化完成符、启动/取消高精度定时器、关联硬锁步检测模块的操作",
          "similarity": 0.46755149960517883
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watchdog.c",
          "start_line": 257,
          "end_line": 357,
          "content": [
            "static inline void watchdog_hardlockup_kick(void) { }",
            "void __weak watchdog_hardlockup_enable(unsigned int cpu) { }",
            "void __weak watchdog_hardlockup_disable(unsigned int cpu) { }",
            "int __weak __init watchdog_hardlockup_probe(void)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "void __weak watchdog_hardlockup_stop(void) { }",
            "void __weak watchdog_hardlockup_start(void) { }",
            "static void lockup_detector_update_enable(void)",
            "{",
            "\twatchdog_enabled = 0;",
            "\tif (!watchdog_user_enabled)",
            "\t\treturn;",
            "\tif (watchdog_hardlockup_available && watchdog_hardlockup_user_enabled)",
            "\t\twatchdog_enabled |= WATCHDOG_HARDLOCKUP_ENABLED;",
            "\tif (watchdog_softlockup_user_enabled)",
            "\t\twatchdog_enabled |= WATCHDOG_SOFTOCKUP_ENABLED;",
            "}",
            "static ssize_t softlockup_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\t     char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%u\\n\", softlockup_count);",
            "}",
            "static __init int kernel_softlockup_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &softlockup_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "static int __init softlockup_panic_setup(char *str)",
            "{",
            "\tsoftlockup_panic = simple_strtoul(str, NULL, 0);",
            "\treturn 1;",
            "}",
            "static int __init nowatchdog_setup(char *str)",
            "{",
            "\twatchdog_user_enabled = 0;",
            "\treturn 1;",
            "}",
            "static int __init nosoftlockup_setup(char *str)",
            "{",
            "\twatchdog_softlockup_user_enabled = 0;",
            "\treturn 1;",
            "}",
            "static int __init watchdog_thresh_setup(char *str)",
            "{",
            "\tget_option(&str, &watchdog_thresh);",
            "\treturn 1;",
            "}",
            "static u16 get_16bit_precision(u64 data_ns)",
            "{",
            "\treturn data_ns >> 24LL; /* 2^24ns ~= 16.8ms */",
            "}",
            "static void update_cpustat(void)",
            "{",
            "\tint i;",
            "\tu8 util;",
            "\tu16 old_stat, new_stat;",
            "\tstruct kernel_cpustat kcpustat;",
            "\tu64 *cpustat = kcpustat.cpustat;",
            "\tu8 tail = __this_cpu_read(cpustat_tail);",
            "\tu16 sample_period_16 = get_16bit_precision(sample_period);",
            "",
            "\tkcpustat_cpu_fetch(&kcpustat, smp_processor_id());",
            "",
            "\tfor (i = 0; i < NUM_STATS_PER_GROUP; i++) {",
            "\t\told_stat = __this_cpu_read(cpustat_old[i]);",
            "\t\tnew_stat = get_16bit_precision(cpustat[tracked_stats[i]]);",
            "\t\tutil = DIV_ROUND_UP(100 * (new_stat - old_stat), sample_period_16);",
            "\t\t__this_cpu_write(cpustat_util[tail][i], util);",
            "\t\t__this_cpu_write(cpustat_old[i], new_stat);",
            "\t}",
            "",
            "\t__this_cpu_write(cpustat_tail, (tail + 1) % NUM_SAMPLE_PERIODS);",
            "}",
            "static void print_cpustat(void)",
            "{",
            "\tint i, group;",
            "\tu8 tail = __this_cpu_read(cpustat_tail);",
            "\tu64 sample_period_second = sample_period;",
            "",
            "\tdo_div(sample_period_second, NSEC_PER_SEC);",
            "",
            "\t/*",
            "\t * Outputting the \"watchdog\" prefix on every line is redundant and not",
            "\t * concise, and the original alarm information is sufficient for",
            "\t * positioning in logs, hence here printk() is used instead of pr_crit().",
            "\t */",
            "\tprintk(KERN_CRIT \"CPU#%d Utilization every %llus during lockup:\\n\",",
            "\t       smp_processor_id(), sample_period_second);",
            "",
            "\tfor (i = 0; i < NUM_SAMPLE_PERIODS; i++) {",
            "\t\tgroup = (tail + i) % NUM_SAMPLE_PERIODS;",
            "\t\tprintk(KERN_CRIT \"\\t#%d: %3u%% system,\\t%3u%% softirq,\\t\"",
            "\t\t\t\"%3u%% hardirq,\\t%3u%% idle\\n\", i + 1,",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_SYSTEM]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_SOFTIRQ]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_HARDIRQ]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_IDLE]));",
            "\t}",
            "}"
          ],
          "function_name": "watchdog_hardlockup_kick, watchdog_hardlockup_enable, watchdog_hardlockup_disable, watchdog_hardlockup_probe, watchdog_hardlockup_stop, watchdog_hardlockup_start, lockup_detector_update_enable, softlockup_count_show, kernel_softlockup_sysfs_init, softlockup_panic_setup, nowatchdog_setup, nosoftlockup_setup, watchdog_thresh_setup, get_16bit_precision, update_cpustat, print_cpustat",
          "description": "提供软锁检测支持，包含统计周期设置、CPU利用率采集、中断事件追踪等辅助功能，维护软锁检测相关状态机。",
          "similarity": 0.46167832612991333
        }
      ]
    },
    {
      "source_file": "kernel/locking/qspinlock_paravirt.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:46:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\qspinlock_paravirt.h`\n\n---\n\n# `locking/qspinlock_paravirt.h` 技术文档\n\n## 1. 文件概述\n\n`qspinlock_paravirt.h` 是 Linux 内核中用于实现 **半虚拟化（paravirtualized, PV）队列自旋锁（qspinlock）** 的头文件。其核心目标是在虚拟化环境中优化自旋锁行为：当虚拟 CPU（vCPU）无法立即获取锁时，不进行忙等待（busy-waiting），而是通过 **挂起（halt）** 当前 vCPU 并等待被唤醒，从而显著降低在锁竞争激烈或宿主机过载（overcommitted）场景下的 CPU 资源浪费和延迟。\n\n该文件依赖架构层提供的两个关键半虚拟化超调用（hypercall）：\n- `pv_wait(u8 *ptr, u8 val)`：当 `*ptr == val` 时挂起当前 vCPU。\n- `pv_kick(cpu)`：唤醒指定的已挂起 vCPU。\n\n此文件 **不能直接包含**，必须通过定义 `_GEN_PV_LOCK_SLOWPATH` 宏后由其他文件（如 `qspinlock.c`）条件包含，以替换原生的慢路径锁实现。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`enum vcpu_state`**  \n  表示 vCPU 在锁等待队列中的状态：\n  - `vcpu_running`：正在运行（默认状态）。\n  - `vcpu_halted`：已挂起，等待被唤醒（仅用于 `pv_wait_node`）。\n  - `vcpu_hashed`：已挂起且其节点信息已加入哈希表（用于快速查找）。\n\n- **`struct pv_node`**  \n  扩展的 MCS 锁节点，包含：\n  - `mcs`：标准 MCS 自旋锁节点。\n  - `cpu`：关联的 CPU ID。\n  - `state`：当前 vCPU 状态（`vcpu_state` 枚举值）。\n\n- **`struct pv_hash_entry`**  \n  哈希表条目，用于快速映射锁地址到对应的 `pv_node`：\n  - `lock`：指向 `qspinlock` 的指针。\n  - `node`：指向 `pv_node` 的指针。\n\n### 主要函数与宏\n\n- **`pv_hybrid_queued_unfair_trylock()`**  \n  实现混合模式的锁尝试获取逻辑，结合了公平队列锁与非公平锁的优点。\n\n- **`set_pending()` / `trylock_clear_pending()`**  \n  操作锁的 `pending` 位，用于协调队列头 vCPU 与新到来的竞争者。\n\n- **`__pv_init_lock_hash()`**  \n  初始化 PV 锁哈希表，分配足够大的内存空间以支持所有可能的 CPU。\n\n- **`pv_hash()` / `pv_unhash()`**  \n  在哈希表中插入/删除锁与节点的映射关系，用于快速唤醒等待者。\n\n- **`pv_wait_early()`**  \n  （代码不完整）用于判断是否应提前检查前驱节点状态并挂起当前 vCPU。\n\n### 关键宏定义\n\n- **`PV_PREV_CHECK_MASK`**  \n  控制检查前驱节点状态的频率（每 256 次循环检查一次），避免缓存行抖动。\n\n- **`_Q_SLOW_VAL`**  \n  表示锁处于慢路径状态的值（`locked=1, pending=1`）。\n\n- **`queued_spin_trylock`**  \n  重定义为 `pv_hybrid_queued_unfair_trylock`，启用混合锁机制。\n\n## 3. 关键实现\n\n### 混合 PV 队列/非公平锁机制\n\n该实现采用 **混合策略**：\n- 当锁的 MCS 等待队列为空或 `pending` 位未设置时，新竞争者尝试 **非公平方式抢锁**（直接 CAS `locked` 位），提升低竞争场景性能。\n- 一旦有 vCPU 进入等待队列并成为队列头，它会设置 `pending` 位，**禁止后续抢锁**，强制新竞争者进入公平队列，避免锁饥饿。\n- 队列头 vCPU 在自旋等待锁释放时保持 `pending=1`，确保公平性。\n\n### 自适应挂起（Adaptive Spinning）\n\n- 等待队列中的 vCPU 会周期性（由 `PV_PREV_CHECK_MASK` 控制）检查 **前驱节点是否正在运行**。\n- 若前驱 **未运行**（如已挂起），当前 vCPU 也立即挂起，避免无意义的忙等。\n- 此机制在虚拟化过载环境中显著减少 CPU 浪费，同时在非过载场景下通过一次抢锁尝试维持性能。\n\n### 锁-节点哈希表\n\n- 为支持 `pv_kick()` 快速定位等待某锁的 vCPU，内核维护一个全局哈希表 `pv_lock_hash`。\n- 哈希表大小为 `4 * num_possible_cpus()`，确保即使在最大嵌套深度（4 层）下也有足够条目。\n- 使用 **开放寻址法**，每缓存行存放多个条目（`PV_HE_PER_LINE`），减少缓存未命中。\n- 锁持有者在释放锁前必须调用 `pv_unhash()` 移除映射，保证哈希表一致性。\n\n### Pending 位操作优化\n\n- 根据 `_Q_PENDING_BITS` 是否为 8（即 `pending` 字段是否独立字节），提供两种实现：\n  - **独立字节**：直接写 `pending` 字段，使用 `cmpxchg_acquire` 尝试获取锁。\n  - **共享字段**：使用原子位操作（`atomic_or` / `atomic_cmpxchg_acquire`）修改 `val`。\n\n## 4. 依赖关系\n\n- **架构依赖**：必须由底层架构（如 x86 KVM/Xen）提供 `pv_wait()` 和 `pv_kick()` 超调用。\n- **头文件依赖**：\n  - `<linux/hash.h>`：提供 `hash_ptr()` 哈希函数。\n  - `<linux/memblock.h>`：用于早期内存分配（`alloc_large_system_hash`）。\n  - `<linux/debug_locks.h>`：锁调试支持。\n- **锁核心依赖**：基于 `qspinlock` 和 `mcs_spinlock` 实现，需与 `locking/qspinlock.c` 协同工作。\n- **编译依赖**：必须由定义了 `_GEN_PV_LOCK_SLOWPATH` 的源文件包含，不能独立编译。\n\n## 5. 使用场景\n\n- **虚拟化环境**：主要在 KVM、Xen 等半虚拟化 Hypervisor 上启用，优化多 vCPU 虚拟机中的锁竞争。\n- **高竞争锁场景**：当多个 vCPU 频繁争用同一自旋锁时，避免忙等待导致的宿主机 CPU 资源耗尽。\n- **过载宿主机**：在物理 CPU 资源不足时，挂起等待锁的 vCPU 可减少调度开销和上下文切换延迟。\n- **混合工作负载**：通过混合锁机制，在低竞争时保持高性能，高竞争时保证公平性，适用于通用服务器场景。",
      "similarity": 0.5463931560516357,
      "chunks": []
    }
  ]
}