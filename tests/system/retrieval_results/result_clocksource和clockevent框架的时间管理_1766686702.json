{
  "query": "clocksource和clockevent框架的时间管理",
  "timestamp": "2025-12-26 02:18:22",
  "retrieved_files": [
    {
      "source_file": "kernel/time/clocksource.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:37:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\clocksource.c`\n\n---\n\n# `time/clocksource.c` 技术文档\n\n## 1. 文件概述\n\n`time/clocksource.c` 是 Linux 内核中负责管理 **clocksource 驱动** 的核心实现文件。Clocksource 是内核时间子系统的基础组件，用于提供高精度、单调递增的硬件计数器抽象，支撑系统时间（`timekeeping`）、高分辨率定时器（`hrtimers`）和 tick 管理等功能。该文件实现了 clocksource 的注册、选择、校验（watchdog 机制）、参数计算（mult/shift）以及稳定性监控等关键逻辑。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`clocks_calc_mult_shift()`**  \n  计算 clocksource 转换所需的 `mult`（乘数）和 `shift`（移位）参数，用于将硬件计数周期安全、高效地转换为纳秒值，同时保证在指定时间范围内不发生 64 位溢出。\n\n- **`cycles_to_nsec_safe()`**  \n  安全地将 clocksource 的周期差值转换为纳秒，先尝试使用快速路径（`clocksource_cyc2ns`），若超出安全范围则回退到更保守的 `mul_u64_u32_shr` 方法。\n\n- **`clocksource_mark_unstable()`**  \n  由外部（如 x86 TSC 驱动）调用，标记某个 clocksource 为不稳定状态，触发 watchdog 机制进行重新评估和时钟源切换。\n\n- **`clocksource_watchdog_work()` 与 `clocksource_watchdog_kthread()`**  \n  实现 clocksource watchdog 的异步校验机制：通过高精度 watchdog 时钟源交叉验证其他 clocksource 的稳定性，发现异常时降低其评级并触发重新选择。\n\n- **`__clocksource_unstable()`**  \n  内部函数，执行 clocksource 被标记为不稳定后的处理逻辑，包括清除高精度标志、调用驱动回调、调度 watchdog 工作项等。\n\n### 关键数据结构与变量\n\n- **`curr_clocksource`**：当前系统选用的主 clocksource。\n- **`suspend_clocksource`**：用于系统挂起/恢复期间计算 suspend 时间的 clocksource。\n- **`clocksource_list`**：已注册的所有 clocksource 的链表。\n- **`watchdog_list`**：待 watchdog 校验的不稳定或可疑 clocksource 列表。\n- **`watchdog`**：用作校验基准的高稳定性 clocksource（通常为 TSC 或 HPET）。\n- **`override_name`**：用户通过内核参数指定的强制 clocksource 名称。\n- **`finished_booting`**：标志系统是否已完成启动，影响 watchdog 行为。\n\n## 3. 关键实现\n\n### Mult/Shift 参数计算算法\n`clocks_calc_mult_shift()` 采用两阶段策略：\n1. **确定最大允许移位（`sftacc`）**：基于 `maxsec` 和输入频率 `from`，计算在 `maxsec` 秒内周期计数不会导致 64 位溢出的最大移位值。\n2. **寻找最优 mult/shift 对**：从 `shift=32` 向下遍历，计算对应的 `mult = (to << shift) / from`（带四舍五入），选择满足 `mult >> sftacc == 0` 的最大 `shift`，以在精度和范围间取得平衡。\n\n### Watchdog 稳定性校验机制\n- **原理**：利用一个已知高稳定性的 watchdog clocksource（如 TSC），在短时间内连续读取目标 clocksource 和 watchdog 的值。\n- **延迟检测**：计算两次 watchdog 读取之间的延迟（`wd_delay`），若超过 `WATCHDOG_MAX_SKEW`（默认基于 NTP 的 500ppm，约 125μs），则认为本次读取受干扰（如 SMI、虚拟机抢占），重试最多 `verify_n_cpus` 次。\n- **异步处理**：校验失败后，通过 workqueue 调度内核线程（`kwatchdog`）执行降级和重新选择，避免在中断上下文或 workqueue 中直接调用可能引起死锁的 `stop_machine()`。\n\n### 安全周期转纳秒转换\n`cycles_to_nsec_safe()` 先使用快速宏 `clocksource_cyc2ns()`（基于预计算的 `mult/shift`），但仅当周期差值 `delta` 小于 `cs->max_cycles`（由 `clocksource_max_deferment()` 计算得出）时才安全；否则使用更通用的 `mul_u64_u32_shr` 避免溢出。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/clocksource.h>`：定义 `struct clocksource` 及相关 API。\n  - `<linux/timekeeping_internal.h>` 和 `\"tick-internal.h\"`：与时间保持（timekeeping）和 tick 管理模块紧密交互。\n  - `<linux/kthread.h>`、`<linux/workqueue.h>`：用于 watchdog 异步校验。\n- **模块交互**：\n  - **Timekeeping 子系统**：通过 `timekeeping_notify()` 通知 clocksource 变更。\n  - **Clockevent 子系统**：共享 `clocks_calc_mult_shift()` 工具函数。\n  - **架构特定代码**（如 x86）：调用 `clocksource_mark_unstable()` 报告硬件时钟问题（如 TSC 不同步）。\n  - **CPU 热插拔**：watchdog 工作项需避免与 CPU hotplug 锁冲突。\n\n## 5. 使用场景\n\n- **系统启动阶段**：注册所有可用硬件时钟源（如 TSC、HPET、ARM arch-timer），根据评级（rating）自动选择最优 clocksource。\n- **运行时稳定性监控**：watchdog 定期（每 0.5 秒）校验非 watchdog clocksource，检测因硬件故障、虚拟化开销或电源管理导致的时钟漂移或非单调性。\n- **用户强制切换**：通过 `clocksource=` 内核启动参数或 `/sys/devices/system/clocksource/clocksource0/current_clocksource` 接口指定 clocksource。\n- **系统挂起/恢复**：使用 `suspend_clocksource` 精确计算 suspend 期间流逝的时间。\n- **高精度定时器支持**：为 hrtimers 提供底层单调时间源，要求 clocksource 具备 `CLOCK_SOURCE_VALID_FOR_HRES` 标志。",
      "similarity": 0.6733247637748718,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/clocksource.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * This file contains the functions which manage clocksource drivers.",
            " *",
            " * Copyright (C) 2004, 2005 IBM, John Stultz (johnstul@us.ibm.com)",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/device.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prandom.h>",
            "#include <linux/cpu.h>",
            "",
            "#include \"tick-internal.h\"",
            "#include \"timekeeping_internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "声明clocksource驱动管理模块，包含头文件和基本架构定义，用于后续时间源驱动注册与管理。",
          "similarity": 0.6984991431236267
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/time/clocksource.c",
          "start_line": 871,
          "end_line": 987,
          "content": [
            "void clocksource_suspend(void)",
            "{",
            "\tstruct clocksource *cs;",
            "",
            "\tlist_for_each_entry_reverse(cs, &clocksource_list, list)",
            "\t\tif (cs->suspend)",
            "\t\t\tcs->suspend(cs);",
            "}",
            "void clocksource_resume(void)",
            "{",
            "\tstruct clocksource *cs;",
            "",
            "\tlist_for_each_entry(cs, &clocksource_list, list)",
            "\t\tif (cs->resume)",
            "\t\t\tcs->resume(cs);",
            "",
            "\tclocksource_resume_watchdog();",
            "}",
            "void clocksource_touch_watchdog(void)",
            "{",
            "\tclocksource_resume_watchdog();",
            "}",
            "static u32 clocksource_max_adjustment(struct clocksource *cs)",
            "{",
            "\tu64 ret;",
            "\t/*",
            "\t * We won't try to correct for more than 11% adjustments (110,000 ppm),",
            "\t */",
            "\tret = (u64)cs->mult * 11;",
            "\tdo_div(ret,100);",
            "\treturn (u32)ret;",
            "}",
            "u64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)",
            "{",
            "\tu64 max_nsecs, max_cycles;",
            "",
            "\t/*",
            "\t * Calculate the maximum number of cycles that we can pass to the",
            "\t * cyc2ns() function without overflowing a 64-bit result.",
            "\t */",
            "\tmax_cycles = ULLONG_MAX;",
            "\tdo_div(max_cycles, mult+maxadj);",
            "",
            "\t/*",
            "\t * The actual maximum number of cycles we can defer the clocksource is",
            "\t * determined by the minimum of max_cycles and mask.",
            "\t * Note: Here we subtract the maxadj to make sure we don't sleep for",
            "\t * too long if there's a large negative adjustment.",
            "\t */",
            "\tmax_cycles = min(max_cycles, mask);",
            "\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);",
            "",
            "\t/* return the max_cycles value as well if requested */",
            "\tif (max_cyc)",
            "\t\t*max_cyc = max_cycles;",
            "",
            "\t/* Return 50% of the actual maximum, so we can detect bad values */",
            "\tmax_nsecs >>= 1;",
            "",
            "\treturn max_nsecs;",
            "}",
            "static inline void clocksource_update_max_deferment(struct clocksource *cs)",
            "{",
            "\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,",
            "\t\t\t\t\t\tcs->maxadj, cs->mask,",
            "\t\t\t\t\t\t&cs->max_cycles);",
            "}",
            "static void __clocksource_select(bool skipcur)",
            "{",
            "\tbool oneshot = tick_oneshot_mode_active();",
            "\tstruct clocksource *best, *cs;",
            "",
            "\t/* Find the best suitable clocksource */",
            "\tbest = clocksource_find_best(oneshot, skipcur);",
            "\tif (!best)",
            "\t\treturn;",
            "",
            "\tif (!strlen(override_name))",
            "\t\tgoto found;",
            "",
            "\t/* Check for the override clocksource. */",
            "\tlist_for_each_entry(cs, &clocksource_list, list) {",
            "\t\tif (skipcur && cs == curr_clocksource)",
            "\t\t\tcontinue;",
            "\t\tif (strcmp(cs->name, override_name) != 0)",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * Check to make sure we don't switch to a non-highres",
            "\t\t * capable clocksource if the tick code is in oneshot",
            "\t\t * mode (highres or nohz)",
            "\t\t */",
            "\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {",
            "\t\t\t/* Override clocksource cannot be used. */",
            "\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {",
            "\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",",
            "\t\t\t\t\tcs->name);",
            "\t\t\t\toverride_name[0] = 0;",
            "\t\t\t} else {",
            "\t\t\t\t/*",
            "\t\t\t\t * The override cannot be currently verified.",
            "\t\t\t\t * Deferring to let the watchdog check.",
            "\t\t\t\t */",
            "\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",",
            "\t\t\t\t\tcs->name);",
            "\t\t\t}",
            "\t\t} else",
            "\t\t\t/* Override clocksource can be used. */",
            "\t\t\tbest = cs;",
            "\t\tbreak;",
            "\t}",
            "",
            "found:",
            "\tif (curr_clocksource != best && !timekeeping_notify(best)) {",
            "\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);",
            "\t\tcurr_clocksource = best;",
            "\t}",
            "}"
          ],
          "function_name": "clocksource_suspend, clocksource_resume, clocksource_touch_watchdog, clocksource_max_adjustment, clocks_calc_max_nsecs, clocksource_update_max_deferment, __clocksource_select",
          "description": "实现系统挂起/恢复时的时钟源管理，clocksource_suspend/clocksource_resume遍历调用各时钟源的suspend/resume回调；clocksource_touch_watchdog触发动态调整；clocksource_max_adjustment计算最大调整值；clocks_calc_max_nsecs/clocksource_update_max_deferment确定最大延迟时间；__clocksource_select选择最佳时钟源并考虑覆盖名称。",
          "similarity": 0.6758069396018982
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/time/clocksource.c",
          "start_line": 1060,
          "end_line": 1167,
          "content": [
            "static void clocksource_select(void)",
            "{",
            "\t__clocksource_select(false);",
            "}",
            "static void clocksource_select_fallback(void)",
            "{",
            "\t__clocksource_select(true);",
            "}",
            "static int __init clocksource_done_booting(void)",
            "{",
            "\tmutex_lock(&clocksource_mutex);",
            "\tcurr_clocksource = clocksource_default_clock();",
            "\tfinished_booting = 1;",
            "\t/*",
            "\t * Run the watchdog first to eliminate unstable clock sources",
            "\t */",
            "\t__clocksource_watchdog_kthread();",
            "\tclocksource_select();",
            "\tmutex_unlock(&clocksource_mutex);",
            "\treturn 0;",
            "}",
            "static void clocksource_enqueue(struct clocksource *cs)",
            "{",
            "\tstruct list_head *entry = &clocksource_list;",
            "\tstruct clocksource *tmp;",
            "",
            "\tlist_for_each_entry(tmp, &clocksource_list, list) {",
            "\t\t/* Keep track of the place, where to insert */",
            "\t\tif (tmp->rating < cs->rating)",
            "\t\t\tbreak;",
            "\t\tentry = &tmp->list;",
            "\t}",
            "\tlist_add(&cs->list, entry);",
            "}",
            "void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)",
            "{",
            "\tu64 sec;",
            "",
            "\t/*",
            "\t * Default clocksources are *special* and self-define their mult/shift.",
            "\t * But, you're not special, so you should specify a freq value.",
            "\t */",
            "\tif (freq) {",
            "\t\t/*",
            "\t\t * Calc the maximum number of seconds which we can run before",
            "\t\t * wrapping around. For clocksources which have a mask > 32-bit",
            "\t\t * we need to limit the max sleep time to have a good",
            "\t\t * conversion precision. 10 minutes is still a reasonable",
            "\t\t * amount. That results in a shift value of 24 for a",
            "\t\t * clocksource with mask >= 40-bit and f >= 4GHz. That maps to",
            "\t\t * ~ 0.06ppm granularity for NTP.",
            "\t\t */",
            "\t\tsec = cs->mask;",
            "\t\tdo_div(sec, freq);",
            "\t\tdo_div(sec, scale);",
            "\t\tif (!sec)",
            "\t\t\tsec = 1;",
            "\t\telse if (sec > 600 && cs->mask > UINT_MAX)",
            "\t\t\tsec = 600;",
            "",
            "\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,",
            "\t\t\t\t       NSEC_PER_SEC / scale, sec * scale);",
            "\t}",
            "",
            "\t/*",
            "\t * If the uncertainty margin is not specified, calculate it.",
            "\t * If both scale and freq are non-zero, calculate the clock",
            "\t * period, but bound below at 2*WATCHDOG_MAX_SKEW.  However,",
            "\t * if either of scale or freq is zero, be very conservative and",
            "\t * take the tens-of-milliseconds WATCHDOG_THRESHOLD value for the",
            "\t * uncertainty margin.  Allow stupidly small uncertainty margins",
            "\t * to be specified by the caller for testing purposes, but warn",
            "\t * to discourage production use of this capability.",
            "\t */",
            "\tif (scale && freq && !cs->uncertainty_margin) {",
            "\t\tcs->uncertainty_margin = NSEC_PER_SEC / (scale * freq);",
            "\t\tif (cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW)",
            "\t\t\tcs->uncertainty_margin = 2 * WATCHDOG_MAX_SKEW;",
            "\t} else if (!cs->uncertainty_margin) {",
            "\t\tcs->uncertainty_margin = WATCHDOG_THRESHOLD;",
            "\t}",
            "\tWARN_ON_ONCE(cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW);",
            "",
            "\t/*",
            "\t * Ensure clocksources that have large 'mult' values don't overflow",
            "\t * when adjusted.",
            "\t */",
            "\tcs->maxadj = clocksource_max_adjustment(cs);",
            "\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)",
            "\t\t|| (cs->mult - cs->maxadj > cs->mult))) {",
            "\t\tcs->mult >>= 1;",
            "\t\tcs->shift--;",
            "\t\tcs->maxadj = clocksource_max_adjustment(cs);",
            "\t}",
            "",
            "\t/*",
            "\t * Only warn for *special* clocksources that self-define",
            "\t * their mult/shift values and don't specify a freq.",
            "\t */",
            "\tWARN_ONCE(cs->mult + cs->maxadj < cs->mult,",
            "\t\t\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\",",
            "\t\tcs->name);",
            "",
            "\tclocksource_update_max_deferment(cs);",
            "",
            "\tpr_info(\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\",",
            "\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);",
            "}"
          ],
          "function_name": "clocksource_select, clocksource_select_fallback, clocksource_done_booting, clocksource_enqueue, __clocksource_update_freq_scale",
          "description": "负责时钟源选择和初始化，clocksource_select/clocksource_select_fallback选择主/备用时钟源；clocksource_done_booting完成启动阶段的时钟源初始化并触发看门狗；clocksource_enqueue按优先级排序时钟源；__clocksource_update_freq_scale根据频率计算多倍率(shift/mult)和最大空闲时间(max_idle_ns)。",
          "similarity": 0.6600937843322754
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/time/clocksource.c",
          "start_line": 1208,
          "end_line": 1315,
          "content": [
            "int __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tclocksource_arch_init(cs);",
            "",
            "\tif (WARN_ON_ONCE((unsigned int)cs->id >= CSID_MAX))",
            "\t\tcs->id = CSID_GENERIC;",
            "\tif (cs->vdso_clock_mode < 0 ||",
            "\t    cs->vdso_clock_mode >= VDSO_CLOCKMODE_MAX) {",
            "\t\tpr_warn(\"clocksource %s registered with invalid VDSO mode %d. Disabling VDSO support.\\n\",",
            "\t\t\tcs->name, cs->vdso_clock_mode);",
            "\t\tcs->vdso_clock_mode = VDSO_CLOCKMODE_NONE;",
            "\t}",
            "",
            "\t/* Initialize mult/shift and max_idle_ns */",
            "\t__clocksource_update_freq_scale(cs, scale, freq);",
            "",
            "\t/* Add clocksource to the clocksource list */",
            "\tmutex_lock(&clocksource_mutex);",
            "",
            "\tclocksource_watchdog_lock(&flags);",
            "\tclocksource_enqueue(cs);",
            "\tclocksource_enqueue_watchdog(cs);",
            "\tclocksource_watchdog_unlock(&flags);",
            "",
            "\tclocksource_select();",
            "\tclocksource_select_watchdog(false);",
            "\t__clocksource_suspend_select(cs);",
            "\tmutex_unlock(&clocksource_mutex);",
            "\treturn 0;",
            "}",
            "static void __clocksource_change_rating(struct clocksource *cs, int rating)",
            "{",
            "\tlist_del(&cs->list);",
            "\tcs->rating = rating;",
            "\tclocksource_enqueue(cs);",
            "}",
            "void clocksource_change_rating(struct clocksource *cs, int rating)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmutex_lock(&clocksource_mutex);",
            "\tclocksource_watchdog_lock(&flags);",
            "\t__clocksource_change_rating(cs, rating);",
            "\tclocksource_watchdog_unlock(&flags);",
            "",
            "\tclocksource_select();",
            "\tclocksource_select_watchdog(false);",
            "\tclocksource_suspend_select(false);",
            "\tmutex_unlock(&clocksource_mutex);",
            "}",
            "static int clocksource_unbind(struct clocksource *cs)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (clocksource_is_watchdog(cs)) {",
            "\t\t/* Select and try to install a replacement watchdog. */",
            "\t\tclocksource_select_watchdog(true);",
            "\t\tif (clocksource_is_watchdog(cs))",
            "\t\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tif (cs == curr_clocksource) {",
            "\t\t/* Select and try to install a replacement clock source */",
            "\t\tclocksource_select_fallback();",
            "\t\tif (curr_clocksource == cs)",
            "\t\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tif (clocksource_is_suspend(cs)) {",
            "\t\t/*",
            "\t\t * Select and try to install a replacement suspend clocksource.",
            "\t\t * If no replacement suspend clocksource, we will just let the",
            "\t\t * clocksource go and have no suspend clocksource.",
            "\t\t */",
            "\t\tclocksource_suspend_select(true);",
            "\t}",
            "",
            "\tclocksource_watchdog_lock(&flags);",
            "\tclocksource_dequeue_watchdog(cs);",
            "\tlist_del_init(&cs->list);",
            "\tclocksource_watchdog_unlock(&flags);",
            "",
            "\treturn 0;",
            "}",
            "int clocksource_unregister(struct clocksource *cs)",
            "{",
            "\tint ret = 0;",
            "",
            "\tmutex_lock(&clocksource_mutex);",
            "\tif (!list_empty(&cs->list))",
            "\t\tret = clocksource_unbind(cs);",
            "\tmutex_unlock(&clocksource_mutex);",
            "\treturn ret;",
            "}",
            "static ssize_t current_clocksource_show(struct device *dev,",
            "\t\t\t\t\tstruct device_attribute *attr,",
            "\t\t\t\t\tchar *buf)",
            "{",
            "\tssize_t count = 0;",
            "",
            "\tmutex_lock(&clocksource_mutex);",
            "\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", curr_clocksource->name);",
            "\tmutex_unlock(&clocksource_mutex);",
            "",
            "\treturn count;",
            "}"
          ],
          "function_name": "__clocksource_register_scale, __clocksource_change_rating, clocksource_change_rating, clocksource_unbind, clocksource_unregister, current_clocksource_show",
          "description": "实现时钟源注册/变更/注销逻辑，__clocksource_register_scale注册时钟源并初始化参数；__clocksource_change_rating修改时钟源优先级；clocksource_unbind/clocksource_unregister解除绑定并清理资源；current_clocksource_show暴露当前时钟源名称。",
          "similarity": 0.6536110043525696
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/time/clocksource.c",
          "start_line": 704,
          "end_line": 822,
          "content": [
            "static int clocksource_watchdog_kthread(void *data)",
            "{",
            "\tmutex_lock(&clocksource_mutex);",
            "\tif (__clocksource_watchdog_kthread())",
            "\t\tclocksource_select();",
            "\tmutex_unlock(&clocksource_mutex);",
            "\treturn 0;",
            "}",
            "static bool clocksource_is_watchdog(struct clocksource *cs)",
            "{",
            "\treturn cs == watchdog;",
            "}",
            "static void clocksource_enqueue_watchdog(struct clocksource *cs)",
            "{",
            "\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)",
            "\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;",
            "}",
            "static void clocksource_select_watchdog(bool fallback) { }",
            "static inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }",
            "static inline void clocksource_resume_watchdog(void) { }",
            "static inline int __clocksource_watchdog_kthread(void) { return 0; }",
            "static bool clocksource_is_watchdog(struct clocksource *cs) { return false; }",
            "void clocksource_mark_unstable(struct clocksource *cs) { }",
            "static inline void clocksource_watchdog_lock(unsigned long *flags) { }",
            "static inline void clocksource_watchdog_unlock(unsigned long *flags) { }",
            "static bool clocksource_is_suspend(struct clocksource *cs)",
            "{",
            "\treturn cs == suspend_clocksource;",
            "}",
            "static void __clocksource_suspend_select(struct clocksource *cs)",
            "{",
            "\t/*",
            "\t * Skip the clocksource which will be stopped in suspend state.",
            "\t */",
            "\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * The nonstop clocksource can be selected as the suspend clocksource to",
            "\t * calculate the suspend time, so it should not supply suspend/resume",
            "\t * interfaces to suspend the nonstop clocksource when system suspends.",
            "\t */",
            "\tif (cs->suspend || cs->resume) {",
            "\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",",
            "\t\t\tcs->name);",
            "\t}",
            "",
            "\t/* Pick the best rating. */",
            "\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)",
            "\t\tsuspend_clocksource = cs;",
            "}",
            "static void clocksource_suspend_select(bool fallback)",
            "{",
            "\tstruct clocksource *cs, *old_suspend;",
            "",
            "\told_suspend = suspend_clocksource;",
            "\tif (fallback)",
            "\t\tsuspend_clocksource = NULL;",
            "",
            "\tlist_for_each_entry(cs, &clocksource_list, list) {",
            "\t\t/* Skip current if we were requested for a fallback. */",
            "\t\tif (fallback && cs == old_suspend)",
            "\t\t\tcontinue;",
            "",
            "\t\t__clocksource_suspend_select(cs);",
            "\t}",
            "}",
            "void clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles)",
            "{",
            "\tif (!suspend_clocksource)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * If current clocksource is the suspend timer, we should use the",
            "\t * tkr_mono.cycle_last value as suspend_start to avoid same reading",
            "\t * from suspend timer.",
            "\t */",
            "\tif (clocksource_is_suspend(cs)) {",
            "\t\tsuspend_start = start_cycles;",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (suspend_clocksource->enable &&",
            "\t    suspend_clocksource->enable(suspend_clocksource)) {",
            "\t\tpr_warn_once(\"Failed to enable the non-suspend-able clocksource.\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tsuspend_start = suspend_clocksource->read(suspend_clocksource);",
            "}",
            "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)",
            "{",
            "\tu64 now, nsec = 0;",
            "",
            "\tif (!suspend_clocksource)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * If current clocksource is the suspend timer, we should use the",
            "\t * tkr_mono.cycle_last value from timekeeping as current cycle to",
            "\t * avoid same reading from suspend timer.",
            "\t */",
            "\tif (clocksource_is_suspend(cs))",
            "\t\tnow = cycle_now;",
            "\telse",
            "\t\tnow = suspend_clocksource->read(suspend_clocksource);",
            "",
            "\tif (now > suspend_start)",
            "\t\tnsec = cycles_to_nsec_safe(suspend_clocksource, suspend_start, now);",
            "",
            "\t/*",
            "\t * Disable the suspend timer to save power if current clocksource is",
            "\t * not the suspend timer.",
            "\t */",
            "\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)",
            "\t\tsuspend_clocksource->disable(suspend_clocksource);",
            "",
            "\treturn nsec;",
            "}"
          ],
          "function_name": "clocksource_watchdog_kthread, clocksource_is_watchdog, clocksource_enqueue_watchdog, clocksource_select_watchdog, clocksource_dequeue_watchdog, clocksource_resume_watchdog, __clocksource_watchdog_kthread, clocksource_is_watchdog, clocksource_mark_unstable, clocksource_watchdog_lock, clocksource_watchdog_unlock, clocksource_is_suspend, __clocksource_suspend_select, clocksource_suspend_select, clocksource_start_suspend_timing, clocksource_stop_suspend_timing",
          "description": "定义了与看门狗机制相关的函数，用于监控和切换时钟源。clocksource_watchdog_kthread启动看门狗线程以选择最佳时钟源；clocksource_is_watchdog判断时钟源是否为看门狗候选；clocksource_enqueue_watchdog标记连续运行的时钟源；__clocksource_suspend_select选择挂起状态下的时钟源；clocksource_start_suspend_timing/clocksource_stop_suspend_timing记录挂起/恢复时间差。",
          "similarity": 0.6316592693328857
        }
      ]
    },
    {
      "source_file": "kernel/time/clockevents.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:35:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\clockevents.c`\n\n---\n\n# `time/clockevents.c` 技术文档\n\n## 1. 文件概述\n\n`time/clockevents.c` 是 Linux 内核中用于管理**时钟事件设备**（Clock Event Devices）的核心实现文件。它提供了一套统一的接口，用于注册、配置、切换状态以及编程各种硬件定时器设备（如 APIC、ARM Generic Timer、HPET 等），以支持周期性或单次触发的定时功能。该模块是通用时钟事件框架（Generic Clockevents）的关键组成部分，为高精度定时器（hrtimers）、tick 管理和 CPU 闲置管理等子系统提供底层支持。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `clockevent_devices`：已注册并处于活跃状态的时钟事件设备链表。\n- `clockevents_released`：已释放但尚未销毁的设备链表。\n- `clockevents_lock`：原始自旋锁，保护上述链表的并发访问。\n- `clockevents_mutex`：互斥锁，用于保护设备解绑（unbind）等可能睡眠的操作。\n\n### 关键函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `clockevent_delta2ns()` | 将设备滴答数（latch）转换为纳秒值，考虑精度和溢出保护。 |\n| `clockevents_switch_state()` | 切换时钟事件设备的工作状态（如 SHUTDOWN、PERIODIC、ONESHOT 等）。 |\n| `clockevents_shutdown()` | 关闭设备并重置其下次触发时间为无穷大（`KTIME_MAX`）。 |\n| `clockevents_tick_resume()` | 在系统从挂起状态恢复后，重新启用设备的 tick 功能。 |\n| `clockevents_program_event()` | 编程设备在指定绝对时间触发下一次事件。 |\n| `clockevents_program_min_delta()` | 尝试以最小延迟（`min_delta_ns`）编程设备，失败时根据配置策略重试或调整最小延迟。 |\n| `clockevents_increase_min_delta()` | （仅当 `CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST` 启用时）在编程失败时动态增大最小延迟，避免持续失败。 |\n\n### 状态管理\n- 支持的状态包括：`CLOCK_EVT_STATE_DETACHED`、`SHUTDOWN`、`PERIODIC`、`ONESHOT`、`ONESHOT_STOPPED`。\n- 通过设备描述符中的回调函数（如 `set_state_shutdown`、`set_state_oneshot` 等）实现具体硬件操作。\n\n## 3. 关键实现\n\n### 时间单位转换 (`cev_delta2ns`)\n- 使用**定点数缩放算法**（`mult`/`shift`）将设备滴答数转换为纳秒。\n- 针对高频设备（`mult > (1 << shift)`）进行特殊处理：在计算**最小延迟**时仍加 `mult - 1` 以避免舍入误差，但在计算**最大延迟**时省略该操作，防止超出硬件上限。\n- 对转换结果进行溢出检查，并确保返回值不低于 1 微秒（1000 ns），避免无意义的极短延迟。\n\n### 状态切换机制\n- `clockevents_switch_state()` 要求在**中断关闭**上下文中调用。\n- 调用前检查当前状态是否已为目标状态，避免冗余操作。\n- 若设备处于 `ONESHOT` 状态但 `mult == 0`，会发出警告并设为 1，防止后续计算崩溃。\n\n### 最小延迟编程策略\n- **启用 `CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST` 时**：\n  - 若连续 3 次编程失败，则调用 `clockevents_increase_min_delta()`。\n  - 动态增大 `min_delta_ns`（初始至少 5000ns，每次增加 50%），上限为一个 jiffy（`NSEC_PER_SEC / HZ`）。\n  - 达到上限后放弃并返回 `-ETIME`。\n- **未启用时**：\n  - 简单重试最多 10 次，每次将延迟累加 `min_delta_ns`。\n  - 仍失败则返回 `-ETIME`。\n\n### 并发与同步\n- 设备注册/注销使用 `clockevents_lock`（raw spinlock）保护，适用于中断上下文。\n- 设备解绑等可能涉及内存分配或睡眠的操作使用 `clockevents_mutex`（mutex）保护。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/clockchips.h>`：定义 `clock_event_device` 结构体及状态枚举。\n  - `<linux/hrtimer.h>`：高精度定时器支持。\n  - `\"tick-internal.h\"`：内部 tick 管理函数（如 `tick_check_deadline` 相关逻辑）。\n- **功能依赖**：\n  - 依赖底层硬件驱动实现 `set_next_event`、状态切换回调等。\n  - 被 tick-broadcast、tick-sched、hrtimer 等子系统调用以编程定时事件。\n  - 与 `clocksource` 子系统协同工作（`clockevent` 负责“何时触发”，`clocksource` 负责“当前时间”）。\n\n## 5. 使用场景\n\n- **系统启动初始化**：平台或架构特定代码注册本地 APIC、ARM arch timer 等作为 clock event device。\n- **高精度定时器（hrtimer）到期处理**：hrtimer 子系统调用 `clockevents_program_event()` 设置下一次中断。\n- **动态 tick（NO_HZ）**：在 CPU 空闲时关闭周期性 tick，需要精确编程单次事件唤醒。\n- **CPU 热插拔**：CPU offline 时 shutdown 设备，online 时 resume 并重新编程。\n- **电源管理（suspend/resume）**：系统 suspend 前 shutdown 设备，resume 后通过 `clockevents_tick_resume()` 恢复。\n- **设备热插拔或替换**：旧设备 detach 并 shutdown，新设备注册并接管 tick 功能。",
      "similarity": 0.6610453724861145,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/time/clockevents.c",
          "start_line": 670,
          "end_line": 750,
          "content": [
            "static ssize_t current_device_show(struct device *dev,",
            "\t\t\t\t   struct device_attribute *attr,",
            "\t\t\t\t   char *buf)",
            "{",
            "\tstruct tick_device *td;",
            "\tssize_t count = 0;",
            "",
            "\traw_spin_lock_irq(&clockevents_lock);",
            "\ttd = tick_get_tick_dev(dev);",
            "\tif (td && td->evtdev)",
            "\t\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", td->evtdev->name);",
            "\traw_spin_unlock_irq(&clockevents_lock);",
            "\treturn count;",
            "}",
            "static ssize_t unbind_device_store(struct device *dev,",
            "\t\t\t\t   struct device_attribute *attr,",
            "\t\t\t\t   const char *buf, size_t count)",
            "{",
            "\tchar name[CS_NAME_LEN];",
            "\tssize_t ret = sysfs_get_uname(buf, name, count);",
            "\tstruct clock_event_device *ce = NULL, *iter;",
            "",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tret = -ENODEV;",
            "\tmutex_lock(&clockevents_mutex);",
            "\traw_spin_lock_irq(&clockevents_lock);",
            "\tlist_for_each_entry(iter, &clockevent_devices, list) {",
            "\t\tif (!strcmp(iter->name, name)) {",
            "\t\t\tret = __clockevents_try_unbind(iter, dev->id);",
            "\t\t\tce = iter;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\traw_spin_unlock_irq(&clockevents_lock);",
            "\t/*",
            "\t * We hold clockevents_mutex, so ce can't go away",
            "\t */",
            "\tif (ret == -EAGAIN)",
            "\t\tret = clockevents_unbind(ce, dev->id);",
            "\tmutex_unlock(&clockevents_mutex);",
            "\treturn ret ? ret : count;",
            "}",
            "static __init int tick_broadcast_init_sysfs(void)",
            "{",
            "\tint err = device_register(&tick_bc_dev);",
            "",
            "\tif (!err)",
            "\t\terr = device_create_file(&tick_bc_dev, &dev_attr_current_device);",
            "\treturn err;",
            "}",
            "static inline int tick_broadcast_init_sysfs(void) { return 0; }",
            "static int __init tick_init_sysfs(void)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tstruct device *dev = &per_cpu(tick_percpu_dev, cpu);",
            "\t\tint err;",
            "",
            "\t\tdev->id = cpu;",
            "\t\tdev->bus = &clockevents_subsys;",
            "\t\terr = device_register(dev);",
            "\t\tif (!err)",
            "\t\t\terr = device_create_file(dev, &dev_attr_current_device);",
            "\t\tif (!err)",
            "\t\t\terr = device_create_file(dev, &dev_attr_unbind_device);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t}",
            "\treturn tick_broadcast_init_sysfs();",
            "}",
            "static int __init clockevents_init_sysfs(void)",
            "{",
            "\tint err = subsys_system_register(&clockevents_subsys, NULL);",
            "",
            "\tif (!err)",
            "\t\terr = tick_init_sysfs();",
            "\treturn err;",
            "}"
          ],
          "function_name": "current_device_show, unbind_device_store, tick_broadcast_init_sysfs, tick_broadcast_init_sysfs, tick_init_sysfs, clockevents_init_sysfs",
          "description": "该代码段实现对系统时钟事件设备的SysFS接口管理，包含**当前设备信息读取**和**动态解绑操作**的功能。`current_device_show`用于读取当前选中时钟设备名称，`unbind_device_store`通过SysFS接口尝试解绑指定设备，其余函数负责初始化各CPU及广播模式的SysFS节点。注：代码上下文不完整，部分关键结构体（如`tick_bc_dev`、`clockevent_devices`）和全局状态未展示。",
          "similarity": 0.5466709733009338
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/clockevents.c",
          "start_line": 1,
          "end_line": 31,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * This file contains functions which manage clock event devices.",
            " *",
            " * Copyright(C) 2005-2006, Thomas Gleixner <tglx@linutronix.de>",
            " * Copyright(C) 2005-2007, Red Hat, Inc., Ingo Molnar",
            " * Copyright(C) 2006-2007, Timesys Corp., Thomas Gleixner",
            " */",
            "",
            "#include <linux/clockchips.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/device.h>",
            "",
            "#include \"tick-internal.h\"",
            "",
            "/* The registered clock event devices */",
            "static LIST_HEAD(clockevent_devices);",
            "static LIST_HEAD(clockevents_released);",
            "/* Protection for the above */",
            "static DEFINE_RAW_SPINLOCK(clockevents_lock);",
            "/* Protection for unbind operations */",
            "static DEFINE_MUTEX(clockevents_mutex);",
            "",
            "struct ce_unbind {",
            "\tstruct clock_event_device *ce;",
            "\tint res;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "声明和初始化用于管理时钟事件设备的全局数据结构，包括设备列表、锁及用于设备解绑的辅助结构体。",
          "similarity": 0.5426709055900574
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/time/clockevents.c",
          "start_line": 504,
          "end_line": 606,
          "content": [
            "void clockevents_config_and_register(struct clock_event_device *dev,",
            "\t\t\t\t     u32 freq, unsigned long min_delta,",
            "\t\t\t\t     unsigned long max_delta)",
            "{",
            "\tdev->min_delta_ticks = min_delta;",
            "\tdev->max_delta_ticks = max_delta;",
            "\tclockevents_config(dev, freq);",
            "\tclockevents_register_device(dev);",
            "}",
            "int __clockevents_update_freq(struct clock_event_device *dev, u32 freq)",
            "{",
            "\tclockevents_config(dev, freq);",
            "",
            "\tif (clockevent_state_oneshot(dev))",
            "\t\treturn clockevents_program_event(dev, dev->next_event, false);",
            "",
            "\tif (clockevent_state_periodic(dev))",
            "\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);",
            "",
            "\treturn 0;",
            "}",
            "int clockevents_update_freq(struct clock_event_device *dev, u32 freq)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tlocal_irq_save(flags);",
            "\tret = tick_broadcast_update_freq(dev, freq);",
            "\tif (ret == -ENODEV)",
            "\t\tret = __clockevents_update_freq(dev, freq);",
            "\tlocal_irq_restore(flags);",
            "\treturn ret;",
            "}",
            "void clockevents_handle_noop(struct clock_event_device *dev)",
            "{",
            "}",
            "void clockevents_exchange_device(struct clock_event_device *old,",
            "\t\t\t\t struct clock_event_device *new)",
            "{",
            "\t/*",
            "\t * Caller releases a clock event device. We queue it into the",
            "\t * released list and do a notify add later.",
            "\t */",
            "\tif (old) {",
            "\t\tmodule_put(old->owner);",
            "\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);",
            "\t\tlist_move(&old->list, &clockevents_released);",
            "\t}",
            "",
            "\tif (new) {",
            "\t\tBUG_ON(!clockevent_state_detached(new));",
            "\t\tclockevents_shutdown(new);",
            "\t}",
            "}",
            "void clockevents_suspend(void)",
            "{",
            "\tstruct clock_event_device *dev;",
            "",
            "\tlist_for_each_entry_reverse(dev, &clockevent_devices, list)",
            "\t\tif (dev->suspend && !clockevent_state_detached(dev))",
            "\t\t\tdev->suspend(dev);",
            "}",
            "void clockevents_resume(void)",
            "{",
            "\tstruct clock_event_device *dev;",
            "",
            "\tlist_for_each_entry(dev, &clockevent_devices, list)",
            "\t\tif (dev->resume && !clockevent_state_detached(dev))",
            "\t\t\tdev->resume(dev);",
            "}",
            "void tick_offline_cpu(unsigned int cpu)",
            "{",
            "\traw_spin_lock(&clockevents_lock);",
            "\ttick_broadcast_offline(cpu);",
            "\traw_spin_unlock(&clockevents_lock);",
            "}",
            "void tick_cleanup_dead_cpu(int cpu)",
            "{",
            "\tstruct clock_event_device *dev, *tmp;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&clockevents_lock, flags);",
            "",
            "\ttick_shutdown(cpu);",
            "\t/*",
            "\t * Unregister the clock event devices which were",
            "\t * released from the users in the notify chain.",
            "\t */",
            "\tlist_for_each_entry_safe(dev, tmp, &clockevents_released, list)",
            "\t\tlist_del(&dev->list);",
            "\t/*",
            "\t * Now check whether the CPU has left unused per cpu devices",
            "\t */",
            "\tlist_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {",
            "\t\tif (cpumask_test_cpu(cpu, dev->cpumask) &&",
            "\t\t    cpumask_weight(dev->cpumask) == 1 &&",
            "\t\t    !tick_is_broadcast_device(dev)) {",
            "\t\t\tBUG_ON(!clockevent_state_detached(dev));",
            "\t\t\tlist_del(&dev->list);",
            "\t\t}",
            "\t}",
            "\traw_spin_unlock_irqrestore(&clockevents_lock, flags);",
            "}"
          ],
          "function_name": "clockevents_config_and_register, __clockevents_update_freq, clockevents_update_freq, clockevents_handle_noop, clockevents_exchange_device, clockevents_suspend, clockevents_resume, tick_offline_cpu, tick_cleanup_dead_cpu",
          "description": "封装设备频率更新、挂起/恢复操作及设备交换接口，协调系统时钟源变更与CPU状态变化的交互逻辑。",
          "similarity": 0.5084049701690674
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/clockevents.c",
          "start_line": 32,
          "end_line": 147,
          "content": [
            "static u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,",
            "\t\t\tbool ismax)",
            "{",
            "\tu64 clc = (u64) latch << evt->shift;",
            "\tu64 rnd;",
            "",
            "\tif (WARN_ON(!evt->mult))",
            "\t\tevt->mult = 1;",
            "\trnd = (u64) evt->mult - 1;",
            "",
            "\t/*",
            "\t * Upper bound sanity check. If the backwards conversion is",
            "\t * not equal latch, we know that the above shift overflowed.",
            "\t */",
            "\tif ((clc >> evt->shift) != (u64)latch)",
            "\t\tclc = ~0ULL;",
            "",
            "\t/*",
            "\t * Scaled math oddities:",
            "\t *",
            "\t * For mult <= (1 << shift) we can safely add mult - 1 to",
            "\t * prevent integer rounding loss. So the backwards conversion",
            "\t * from nsec to device ticks will be correct.",
            "\t *",
            "\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we",
            "\t * need to be careful. Adding mult - 1 will result in a value",
            "\t * which when converted back to device ticks can be larger",
            "\t * than latch by up to (mult - 1) >> shift. For the min_delta",
            "\t * calculation we still want to apply this in order to stay",
            "\t * above the minimum device ticks limit. For the upper limit",
            "\t * we would end up with a latch value larger than the upper",
            "\t * limit of the device, so we omit the add to stay below the",
            "\t * device upper boundary.",
            "\t *",
            "\t * Also omit the add if it would overflow the u64 boundary.",
            "\t */",
            "\tif ((~0ULL - clc > rnd) &&",
            "\t    (!ismax || evt->mult <= (1ULL << evt->shift)))",
            "\t\tclc += rnd;",
            "",
            "\tdo_div(clc, evt->mult);",
            "",
            "\t/* Deltas less than 1usec are pointless noise */",
            "\treturn clc > 1000 ? clc : 1000;",
            "}",
            "u64 clockevent_delta2ns(unsigned long latch, struct clock_event_device *evt)",
            "{",
            "\treturn cev_delta2ns(latch, evt, false);",
            "}",
            "static int __clockevents_switch_state(struct clock_event_device *dev,",
            "\t\t\t\t      enum clock_event_state state)",
            "{",
            "\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)",
            "\t\treturn 0;",
            "",
            "\t/* Transition with new state-specific callbacks */",
            "\tswitch (state) {",
            "\tcase CLOCK_EVT_STATE_DETACHED:",
            "\t\t/* The clockevent device is getting replaced. Shut it down. */",
            "",
            "\tcase CLOCK_EVT_STATE_SHUTDOWN:",
            "\t\tif (dev->set_state_shutdown)",
            "\t\t\treturn dev->set_state_shutdown(dev);",
            "\t\treturn 0;",
            "",
            "\tcase CLOCK_EVT_STATE_PERIODIC:",
            "\t\t/* Core internal bug */",
            "\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))",
            "\t\t\treturn -ENOSYS;",
            "\t\tif (dev->set_state_periodic)",
            "\t\t\treturn dev->set_state_periodic(dev);",
            "\t\treturn 0;",
            "",
            "\tcase CLOCK_EVT_STATE_ONESHOT:",
            "\t\t/* Core internal bug */",
            "\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))",
            "\t\t\treturn -ENOSYS;",
            "\t\tif (dev->set_state_oneshot)",
            "\t\t\treturn dev->set_state_oneshot(dev);",
            "\t\treturn 0;",
            "",
            "\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:",
            "\t\t/* Core internal bug */",
            "\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),",
            "\t\t\t      \"Current state: %d\\n\",",
            "\t\t\t      clockevent_get_state(dev)))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (dev->set_state_oneshot_stopped)",
            "\t\t\treturn dev->set_state_oneshot_stopped(dev);",
            "\t\telse",
            "\t\t\treturn -ENOSYS;",
            "",
            "\tdefault:",
            "\t\treturn -ENOSYS;",
            "\t}",
            "}",
            "void clockevents_switch_state(struct clock_event_device *dev,",
            "\t\t\t      enum clock_event_state state)",
            "{",
            "\tif (clockevent_get_state(dev) != state) {",
            "\t\tif (__clockevents_switch_state(dev, state))",
            "\t\t\treturn;",
            "",
            "\t\tclockevent_set_state(dev, state);",
            "",
            "\t\t/*",
            "\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash",
            "\t\t * on it, so fix it up and emit a warning:",
            "\t\t */",
            "\t\tif (clockevent_state_oneshot(dev)) {",
            "\t\t\tif (WARN_ON(!dev->mult))",
            "\t\t\t\tdev->mult = 1;",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "cev_delta2ns, clockevent_delta2ns, __clockevents_switch_state, clockevents_switch_state",
          "description": "实现纳秒与设备计数的转换计算，以及状态切换逻辑，处理不同状态下的回调函数调用和状态验证。",
          "similarity": 0.5035582184791565
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/clockevents.c",
          "start_line": 171,
          "end_line": 293,
          "content": [
            "void clockevents_shutdown(struct clock_event_device *dev)",
            "{",
            "\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);",
            "\tdev->next_event = KTIME_MAX;",
            "}",
            "int clockevents_tick_resume(struct clock_event_device *dev)",
            "{",
            "\tint ret = 0;",
            "",
            "\tif (dev->tick_resume)",
            "\t\tret = dev->tick_resume(dev);",
            "",
            "\treturn ret;",
            "}",
            "static int clockevents_increase_min_delta(struct clock_event_device *dev)",
            "{",
            "\t/* Nothing to do if we already reached the limit */",
            "\tif (dev->min_delta_ns >= MIN_DELTA_LIMIT) {",
            "\t\tprintk_deferred(KERN_WARNING",
            "\t\t\t\t\"CE: Reprogramming failure. Giving up\\n\");",
            "\t\tdev->next_event = KTIME_MAX;",
            "\t\treturn -ETIME;",
            "\t}",
            "",
            "\tif (dev->min_delta_ns < 5000)",
            "\t\tdev->min_delta_ns = 5000;",
            "\telse",
            "\t\tdev->min_delta_ns += dev->min_delta_ns >> 1;",
            "",
            "\tif (dev->min_delta_ns > MIN_DELTA_LIMIT)",
            "\t\tdev->min_delta_ns = MIN_DELTA_LIMIT;",
            "",
            "\tprintk_deferred(KERN_WARNING",
            "\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\",",
            "\t\t\tdev->name ? dev->name : \"?\",",
            "\t\t\t(unsigned long long) dev->min_delta_ns);",
            "\treturn 0;",
            "}",
            "static int clockevents_program_min_delta(struct clock_event_device *dev)",
            "{",
            "\tunsigned long long clc;",
            "\tint64_t delta;",
            "\tint i;",
            "",
            "\tfor (i = 0;;) {",
            "\t\tdelta = dev->min_delta_ns;",
            "\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);",
            "",
            "\t\tif (clockevent_state_shutdown(dev))",
            "\t\t\treturn 0;",
            "",
            "\t\tdev->retries++;",
            "\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;",
            "\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)",
            "\t\t\treturn 0;",
            "",
            "\t\tif (++i > 2) {",
            "\t\t\t/*",
            "\t\t\t * We tried 3 times to program the device with the",
            "\t\t\t * given min_delta_ns. Try to increase the minimum",
            "\t\t\t * delta, if that fails as well get out of here.",
            "\t\t\t */",
            "\t\t\tif (clockevents_increase_min_delta(dev))",
            "\t\t\t\treturn -ETIME;",
            "\t\t\ti = 0;",
            "\t\t}",
            "\t}",
            "}",
            "static int clockevents_program_min_delta(struct clock_event_device *dev)",
            "{",
            "\tunsigned long long clc;",
            "\tint64_t delta = 0;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < 10; i++) {",
            "\t\tdelta += dev->min_delta_ns;",
            "\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);",
            "",
            "\t\tif (clockevent_state_shutdown(dev))",
            "\t\t\treturn 0;",
            "",
            "\t\tdev->retries++;",
            "\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;",
            "\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)",
            "\t\t\treturn 0;",
            "\t}",
            "\treturn -ETIME;",
            "}",
            "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,",
            "\t\t\t      bool force)",
            "{",
            "\tunsigned long long clc;",
            "\tint64_t delta;",
            "\tint rc;",
            "",
            "\tif (WARN_ON_ONCE(expires < 0))",
            "\t\treturn -ETIME;",
            "",
            "\tdev->next_event = expires;",
            "",
            "\tif (clockevent_state_shutdown(dev))",
            "\t\treturn 0;",
            "",
            "\t/* We must be in ONESHOT state here */",
            "\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",",
            "\t\t  clockevent_get_state(dev));",
            "",
            "\t/* Shortcut for clockevent devices that can deal with ktime. */",
            "\tif (dev->features & CLOCK_EVT_FEAT_KTIME)",
            "\t\treturn dev->set_next_ktime(expires, dev);",
            "",
            "\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));",
            "\tif (delta <= 0)",
            "\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;",
            "",
            "\tdelta = min(delta, (int64_t) dev->max_delta_ns);",
            "\tdelta = max(delta, (int64_t) dev->min_delta_ns);",
            "",
            "\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;",
            "\trc = dev->set_next_event((unsigned long) clc, dev);",
            "",
            "\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;",
            "}"
          ],
          "function_name": "clockevents_shutdown, clockevents_tick_resume, clockevents_increase_min_delta, clockevents_program_min_delta, clockevents_program_min_delta, clockevents_program_event",
          "description": "提供设备关闭、Tick恢复、最小延迟调整及事件编程功能，处理设备重编程失败时的退化策略和错误反馈。",
          "similarity": 0.46744102239608765
        }
      ]
    },
    {
      "source_file": "kernel/time/clocksource-wdtest.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:36:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\clocksource-wdtest.c`\n\n---\n\n# `time/clocksource-wdtest.c` 技术文档\n\n## 1. 文件概述\n\n`clocksource-wdtest.c` 是 Linux 内核中的一个单元测试模块，专门用于验证 **clocksource watchdog（时钟源看门狗）** 机制的正确性。该模块通过注册两个自定义的虚拟时钟源（一个模拟 jiffies，一个模拟高精度时钟如 TSC），并主动注入延迟或时间抖动等异常行为，来测试内核时钟源看门狗是否能正确检测不稳定时钟源并将其标记为 `CLOCK_SOURCE_UNSTABLE`。该测试有助于确保系统在使用不可靠硬件时钟时仍能维持时间子系统的稳定性。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`clocksource_wdtest_jiffies`**  \n  模拟低精度、基于 jiffies 的时钟源，`rating=1`（最低有效评级），用于验证看门狗对低精度时钟的处理逻辑，特别是 `uncertainty_margin` 的设置。\n\n- **`clocksource_wdtest_ktime`**  \n  模拟高精度、连续的时钟源（如 TSC），`rating=300`，支持高分辨率定时器（`CLOCK_SOURCE_VALID_FOR_HRES`）和 per-CPU 验证（`CLOCK_SOURCE_VERIFY_PERCPU`），用于测试看门狗对高精度时钟异常的检测能力。\n\n### 主要函数\n\n- **`wdtest_jiffies_read()`**  \n  返回当前 `jiffies` 值作为时钟读数，用于构造低精度时钟源。\n\n- **`wdtest_ktime_read()`**  \n  返回 `ktime_get_real_fast_ns()` 的值，但支持两种异常注入：\n  - **延迟注入**：通过 `wdtest_ktime_read_ndelays` 控制调用时插入微秒级延迟。\n  - **时间抖动注入**：通过 `wdtest_ktime_read_fuzz` 使返回值交替加减 100 毫秒，模拟严重时钟漂移。\n\n- **`wdtest_ktime_cs_mark_unstable()`**  \n  自定义的 `mark_unstable` 回调函数，在时钟源被看门狗判定为不稳定时打印日志。\n\n- **`wdtest_ktime_clocksource_reset()`**  \n  若时钟源已被标记为不稳定，则注销并重新注册 `clocksource_wdtest_ktime`，用于多次测试循环。\n\n- **`wdtest_func()`**  \n  核心测试线程函数，执行以下测试用例：\n  1. 验证 jiffies 类时钟源的 `uncertainty_margin` 是否正确设置为 `TICK_NSEC`。\n  2. 验证高精度时钟源是否被分配合理的 `uncertainty_margin`（≥1 微秒）。\n  3. 注入 0 到 `max_retries + 1` 次延迟错误，验证看门狗在允许重试次数内容忍错误，超出则标记为不稳定。\n  4. 注入时间值抖动（fuzz），验证看门狗能检测到非单调性或跨 CPU 不一致，并触发 per-CPU 验证。\n\n- **`clocksource_wdtest_init()` / `clocksource_wdtest_cleanup()`**  \n  模块初始化与清理函数，负责启动测试线程。\n\n### 模块参数\n\n- **`holdoff`**（默认：内置模块为 10 秒，否则为 0）  \n  控制测试开始前的等待时间，便于系统启动完成后再执行测试。\n\n## 3. 关键实现\n\n- **不确定性边界（`uncertainty_margin`）验证**  \n  - 对于 `wdtest-jiffies`，显式设置 `.uncertainty_margin = TICK_NSEC`，并通过 `WARN_ON_ONCE` 验证注册后该值未被修改。\n  - 对于 `wdtest-ktime`，依赖内核自动计算 `uncertainty_margin`，并通过断言确保其 ≥ 1 微秒（`NSEC_PER_USEC`）。\n\n- **错误注入机制**  \n  - **延迟注入**：在 `wdtest_ktime_read()` 中根据 `wdtest_ktime_read_ndelays` 计数插入 `udelay()`，模拟读取延迟。\n  - **时间抖动注入**：通过全局符号 `wdtest_ktime_read_fuzz` 控制返回值交替偏移 ±100ms，破坏时钟单调性和一致性。\n\n- **看门狗行为验证**  \n  - 利用 `clocksource_get_max_watchdog_retry()` 获取最大重试次数，构造边界测试（0 次、最大次数、超限）。\n  - 通过检查 `clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE` 验证看门狗决策是否符合预期。\n  - 调用 `clocksource_verify_percpu()` 主动触发 per-CPU 一致性检查，验证 `CLOCK_SOURCE_VERIFY_PERCPU` 标志的效果。\n\n- **时钟源生命周期管理**  \n  使用 `clocksource_register_khz()` / `clocksource_unregister()` 动态注册/注销时钟源，并在重置时短暂休眠（`HZ/10`）确保看门狗完成状态清理。\n\n## 4. 依赖关系\n\n- **内核子系统**：\n  - **Clocksource 子系统**：依赖 `<linux/clocksource.h>` 提供的注册、注销、看门狗接口。\n  - **Tick 管理**：依赖 `tick-internal.h` 和 `TICK_NSEC` 等定义。\n  - **高精度定时器（hrtimers）**：通过 `ktime_get_real_fast_ns()` 获取高精度时间。\n  - **内核线程（kthread）**：使用 `kthread_run()` 创建测试线程。\n  - **调度器与延迟**：使用 `schedule_timeout_uninterruptible()` 和 `udelay()` 控制测试节奏。\n\n- **配置依赖**：\n  - 由 `CONFIG_TEST_CLOCKSOURCE_WATCHDOG` 控制是否编译进内核（内置或模块）。\n  - 依赖 `CONFIG_GENERIC_CLOCKEVENTS` 和 `CONFIG_HIGH_RES_TIMERS` 等基础时间子系统配置。\n\n## 5. 使用场景\n\n- **内核开发与测试**：  \n  作为 clocksource watchdog 机制的回归测试用例，在开发新时钟源驱动或修改看门狗逻辑时验证其健壮性。\n\n- **硬件兼容性验证**：  \n  模拟不同时钟源异常行为（如读取延迟、时间跳变），验证内核能否正确隔离不稳定硬件时钟，防止系统时间紊乱。\n\n- **调试辅助**：  \n  通过 `holdoff` 参数延迟测试执行，便于在系统完全初始化后观察看门狗行为；通过日志输出（`pr_info`）提供详细的测试步骤和结果。\n\n- **Per-CPU 时钟一致性测试**：  \n  利用 `CLOCK_SOURCE_VERIFY_PERCPU` 标志和 `clocksource_verify_percpu()` 接口，验证多核系统中时钟源在各 CPU 上的一致性。",
      "similarity": 0.5879871845245361,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/clocksource-wdtest.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Unit test for the clocksource watchdog.",
            " *",
            " * Copyright (C) 2021 Facebook, Inc.",
            " *",
            " * Author: Paul E. McKenney <paulmck@kernel.org>",
            " */",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/device.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/prandom.h>",
            "#include <linux/cpu.h>",
            "",
            "#include \"tick-internal.h\"",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Paul E. McKenney <paulmck@kernel.org>\");",
            "",
            "static int holdoff = IS_BUILTIN(CONFIG_TEST_CLOCKSOURCE_WATCHDOG) ? 10 : 0;",
            "module_param(holdoff, int, 0444);",
            "MODULE_PARM_DESC(holdoff, \"Time to wait to start test (s).\");",
            "",
            "/* Watchdog kthread's task_struct pointer for debug purposes. */",
            "static struct task_struct *wdtest_task;",
            ""
          ],
          "function_name": null,
          "description": "定义clocksource watchdog测试模块的基本信息，包含模块许可、作者及参数holdoff，用于控制测试启动延迟。",
          "similarity": 0.66949862241745
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/clocksource-wdtest.c",
          "start_line": 34,
          "end_line": 135,
          "content": [
            "static u64 wdtest_jiffies_read(struct clocksource *cs)",
            "{",
            "\treturn (u64)jiffies;",
            "}",
            "static u64 wdtest_ktime_read(struct clocksource *cs)",
            "{",
            "\tint wkrn = READ_ONCE(wdtest_ktime_read_ndelays);",
            "\tstatic int sign = 1;",
            "\tu64 ret;",
            "",
            "\tif (wkrn) {",
            "\t\tudelay(cs->uncertainty_margin / 250);",
            "\t\tWRITE_ONCE(wdtest_ktime_read_ndelays, wkrn - 1);",
            "\t}",
            "\tret = ktime_get_real_fast_ns();",
            "\tif (READ_ONCE(wdtest_ktime_read_fuzz)) {",
            "\t\tsign = -sign;",
            "\t\tret = ret + sign * 100 * NSEC_PER_MSEC;",
            "\t}",
            "\treturn ret;",
            "}",
            "static void wdtest_ktime_cs_mark_unstable(struct clocksource *cs)",
            "{",
            "\tpr_info(\"--- Marking %s unstable due to clocksource watchdog.\\n\", cs->name);",
            "}",
            "static void wdtest_ktime_clocksource_reset(void)",
            "{",
            "\tif (clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE) {",
            "\t\tclocksource_unregister(&clocksource_wdtest_ktime);",
            "\t\tclocksource_wdtest_ktime.flags = KTIME_FLAGS;",
            "\t\tschedule_timeout_uninterruptible(HZ / 10);",
            "\t\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);",
            "\t}",
            "}",
            "static int wdtest_func(void *arg)",
            "{",
            "\tunsigned long j1, j2;",
            "\tint i, max_retries;",
            "\tchar *s;",
            "",
            "\tschedule_timeout_uninterruptible(holdoff * HZ);",
            "",
            "\t/*",
            "\t * Verify that jiffies-like clocksources get the manually",
            "\t * specified uncertainty margin.",
            "\t */",
            "\tpr_info(\"--- Verify jiffies-like uncertainty margin.\\n\");",
            "\t__clocksource_register(&clocksource_wdtest_jiffies);",
            "\tWARN_ON_ONCE(clocksource_wdtest_jiffies.uncertainty_margin != TICK_NSEC);",
            "",
            "\tj1 = clocksource_wdtest_jiffies.read(&clocksource_wdtest_jiffies);",
            "\tschedule_timeout_uninterruptible(HZ);",
            "\tj2 = clocksource_wdtest_jiffies.read(&clocksource_wdtest_jiffies);",
            "\tWARN_ON_ONCE(j1 == j2);",
            "",
            "\tclocksource_unregister(&clocksource_wdtest_jiffies);",
            "",
            "\t/*",
            "\t * Verify that tsc-like clocksources are assigned a reasonable",
            "\t * uncertainty margin.",
            "\t */",
            "\tpr_info(\"--- Verify tsc-like uncertainty margin.\\n\");",
            "\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);",
            "\tWARN_ON_ONCE(clocksource_wdtest_ktime.uncertainty_margin < NSEC_PER_USEC);",
            "",
            "\tj1 = clocksource_wdtest_ktime.read(&clocksource_wdtest_ktime);",
            "\tudelay(1);",
            "\tj2 = clocksource_wdtest_ktime.read(&clocksource_wdtest_ktime);",
            "\tpr_info(\"--- tsc-like times: %lu - %lu = %lu.\\n\", j2, j1, j2 - j1);",
            "\tWARN_ON_ONCE(time_before(j2, j1 + NSEC_PER_USEC));",
            "",
            "\t/* Verify tsc-like stability with various numbers of errors injected. */",
            "\tmax_retries = clocksource_get_max_watchdog_retry();",
            "\tfor (i = 0; i <= max_retries + 1; i++) {",
            "\t\tif (i <= 1 && i < max_retries)",
            "\t\t\ts = \"\";",
            "\t\telse if (i <= max_retries)",
            "\t\t\ts = \", expect message\";",
            "\t\telse",
            "\t\t\ts = \", expect clock skew\";",
            "\t\tpr_info(\"--- Watchdog with %dx error injection, %d retries%s.\\n\", i, max_retries, s);",
            "\t\tWRITE_ONCE(wdtest_ktime_read_ndelays, i);",
            "\t\tschedule_timeout_uninterruptible(2 * HZ);",
            "\t\tWARN_ON_ONCE(READ_ONCE(wdtest_ktime_read_ndelays));",
            "\t\tWARN_ON_ONCE((i <= max_retries) !=",
            "\t\t\t     !(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE));",
            "\t\twdtest_ktime_clocksource_reset();",
            "\t}",
            "",
            "\t/* Verify tsc-like stability with clock-value-fuzz error injection. */",
            "\tpr_info(\"--- Watchdog clock-value-fuzz error injection, expect clock skew and per-CPU mismatches.\\n\");",
            "\tWRITE_ONCE(wdtest_ktime_read_fuzz, true);",
            "\tschedule_timeout_uninterruptible(2 * HZ);",
            "\tWARN_ON_ONCE(!(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE));",
            "\tclocksource_verify_percpu(&clocksource_wdtest_ktime);",
            "\tWRITE_ONCE(wdtest_ktime_read_fuzz, false);",
            "",
            "\tclocksource_unregister(&clocksource_wdtest_ktime);",
            "",
            "\tpr_info(\"--- Done with test.\\n\");",
            "\treturn 0;",
            "}"
          ],
          "function_name": "wdtest_jiffies_read, wdtest_ktime_read, wdtest_ktime_cs_mark_unstable, wdtest_ktime_clocksource_reset, wdtest_func",
          "description": "实现clocksource watchdog测试核心逻辑，包含时间读取函数、稳定性标记、重置操作及测试线程函数，通过注入误差验证时钟源不确定性和看门狗机制行为。",
          "similarity": 0.6670953631401062
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/clocksource-wdtest.c",
          "start_line": 173,
          "end_line": 196,
          "content": [
            "static void wdtest_print_module_parms(void)",
            "{",
            "\tpr_alert(\"--- holdoff=%d\\n\", holdoff);",
            "}",
            "static void clocksource_wdtest_cleanup(void)",
            "{",
            "}",
            "static int __init clocksource_wdtest_init(void)",
            "{",
            "\tint ret = 0;",
            "",
            "\twdtest_print_module_parms();",
            "",
            "\t/* Create watchdog-test task. */",
            "\twdtest_task = kthread_run(wdtest_func, NULL, \"wdtest\");",
            "\tif (IS_ERR(wdtest_task)) {",
            "\t\tret = PTR_ERR(wdtest_task);",
            "\t\tpr_warn(\"%s: Failed to create wdtest kthread.\\n\", __func__);",
            "\t\twdtest_task = NULL;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "wdtest_print_module_parms, clocksource_wdtest_cleanup, clocksource_wdtest_init",
          "description": "提供模块参数打印接口并初始化测试线程，包含模块入口点clocksource_wdtest_init用于创建测试任务， cleanup函数为空。",
          "similarity": 0.5407649874687195
        }
      ]
    }
  ]
}