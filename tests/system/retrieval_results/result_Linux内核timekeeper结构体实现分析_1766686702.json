{
  "query": "Linux内核timekeeper结构体实现分析",
  "timestamp": "2025-12-26 02:18:22",
  "retrieved_files": [
    {
      "source_file": "kernel/time/timekeeping.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:55:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timekeeping.c`\n\n---\n\n# timekeeping.c 技术文档\n\n## 1. 文件概述\n\n`timekeeping.c` 是 Linux 内核中负责时间保持（timekeeping）的核心实现文件。它维护系统时间的连续性和准确性，提供高精度的时间读取接口，并处理与 NTP（网络时间协议）、时钟源（clocksource）、系统挂起/恢复等相关的时间同步逻辑。该文件实现了单调时钟（monotonic）、原始时钟（raw）、实时时钟（wall-clock）等多种时间视图，并确保在中断上下文、NMI（不可屏蔽中断）等特殊场景下也能安全读取时间。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct timekeeper`**  \n  核心时间保持结构体，包含当前时间、时钟偏移、TAI 偏移、启动时间偏移等关键字段。\n\n- **`struct tk_read_base`**  \n  用于快速时间读取的基础结构，包含时钟源指针、乘数（mult）、移位（shift）、掩码（mask）和上次周期值（cycle_last）等。\n\n- **`struct tk_fast`**  \n  专为 NMI 和中断上下文设计的快速时间读取结构，使用双缓冲（latch-based seqcount）机制实现无锁安全读取。\n\n- **`tk_core`**  \n  全局核心时间保持对象，包含一个 `seqcount_raw_spinlock_t` 序列锁和 `timekeeper` 实例，对齐到 64 字节缓存行以优化性能。\n\n- **`shadow_timekeeper`**  \n  时间保持器的影子副本，用于在更新过程中暂存新值，避免直接修改主结构导致不一致。\n\n- **`dummy_clock`**  \n  早期启动阶段使用的虚拟时钟源，基于 `local_clock()`，在真实时钟源注册前提供基本时间服务。\n\n### 主要函数与宏\n\n- **`tk_normalize_xtime()`**  \n  将纳秒部分规范化，确保 `xtime_nsec` 不超过每秒纳秒数的表示范围。\n\n- **`tk_xtime()` / `tk_set_xtime()` / `tk_xtime_add()`**  \n  用于获取、设置和累加系统实时时钟（wall time）。\n\n- **`tk_set_wall_to_mono()`**  \n  设置 wall-to-monotonic 偏移，并同步更新 `offs_real` 和 `offs_tai`。\n\n- **`tk_update_sleep_time()`**  \n  在系统从挂起状态恢复时，更新启动时间偏移（`offs_boot`）。\n\n- **`tk_clock_read()`**  \n  安全读取当前时钟源的周期值，防止在时钟源切换过程中发生崩溃。\n\n- **`timekeeping_check_update()`（仅调试模式）**  \n  检查时钟周期偏移是否超出安全范围，防止溢出或下溢。\n\n- **`update_fast_timekeeper()`（未完整显示但被引用）**  \n  更新 `tk_fast_mono` 和 `tk_fast_raw`，用于 NMI 安全的时间读取。\n\n### 全局变量\n\n- `timekeeper_lock`：保护 `tk_core` 的原始自旋锁。\n- `timekeeping_suspended`：标志系统时间保持是否处于挂起状态。\n- `cycles_at_suspend`：系统挂起时记录的时钟周期值。\n- `tk_fast_mono` / `tk_fast_raw`：分别用于单调时间和原始时间的快速读取路径。\n\n## 3. 关键实现\n\n### 时间读取的无锁安全机制\n\n为支持在 NMI、中断等不可睡眠上下文中安全读取时间，内核引入了 `tk_fast` 结构。它使用 `seqcount_latch_t`（一种双缓冲序列计数器），通过切换两个 `tk_read_base` 实例（索引由序列计数器最低位决定）来实现更新与读取的分离。读取时只需读取当前有效的副本，无需加锁。\n\n### 时间规范化与溢出处理\n\n`tk_normalize_xtime()` 确保纳秒字段不会超过 `NSEC_PER_SEC << shift`，避免在时间计算中出现逻辑错误。同时，`CONFIG_DEBUG_TIMEKEEPING` 启用时会检查周期偏移是否超过时钟源的 `max_cycles`，防止因时钟源回绕或频率异常导致时间跳变。\n\n### 早期启动支持\n\n在系统早期启动阶段，真实时钟源尚未注册，此时使用 `dummy_clock` 作为占位时钟源。其 `read` 函数返回 `local_clock()`（通常基于 TSC 或 jiffies），并设置 `mult=1, shift=0`，因为 `local_clock()` 直接返回纳秒值，无需转换。\n\n### 挂起/恢复处理\n\n当系统挂起时，`timekeeping_suspend()` 会记录当前时钟周期值到 `cycles_at_suspend`，并将 `dummy_clock` 的 `read` 函数改为返回该固定值，防止挂起期间时间继续推进。恢复时再切换回真实时钟源并补偿睡眠时间。\n\n### 序列锁保护\n\n主时间保持结构 `tk_core` 使用 `seqcount_raw_spinlock_t` 保护。写操作需持有 `timekeeper_lock`，读操作通过 `read_seqcount_begin()` / `read_seqcount_retry()` 实现无锁但一致的读取，适用于大多数用户空间时间查询路径（如 VDSO）。\n\n## 4. 依赖关系\n\n- **`<linux/clocksource.h>`**：依赖时钟源抽象，用于获取高精度硬件计时器。\n- **`<linux/tick.h>` / `tick-internal.h`**：与 tick 管理子系统交互，处理周期性时间更新。\n- **`ntp_internal.h`**：集成 NTP 频率调整和闰秒处理逻辑。\n- **`timekeeping_internal.h`**：包含内部辅助函数和结构定义。\n- **`<linux/vdso.h>` / `pvclock_gtod.h`**：为 VDSO 和虚拟化环境（如 Xen、KVM）提供高效时间读取支持。\n- **`<linux/sched/clock.h>`**：使用 `local_clock()` 作为早期启动和虚拟时钟源。\n- **`<linux/stop_machine.h>`**：在某些关键更新路径中可能使用 stop-machine 机制确保全局一致性。\n\n## 5. 使用场景\n\n- **系统调用时间查询**：如 `clock_gettime(CLOCK_REALTIME)`、`CLOCK_MONOTONIC` 等通过此模块获取高精度时间。\n- **VDSO 加速**：用户空间通过 VDSO 直接读取 `tk_fast` 结构，避免陷入内核。\n- **NMI 和中断处理**：在不可睡眠上下文中安全获取时间戳（如 perf、ftrace、oops 打印）。\n- **系统挂起/恢复**：在 suspend/resume 流程中冻结和恢复时间推进。\n- **NTP 时间同步**：接收用户空间 `adjtimex` 调用，调整时钟频率和偏移。\n- **内核日志时间戳**：`printk` 等日志系统依赖此模块提供单调或实时时钟。\n- **调度器和负载计算**：`update_wall_time()` 被 tick 中断定期调用，驱动时间推进，影响调度、负载均衡等子系统。",
      "similarity": 0.6832960247993469,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 1,
          "end_line": 78,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  Kernel timekeeping code and accessor functions. Based on code from",
            " *  timer.c, moved in commit 8524070b7982.",
            " */",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/tick.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/compiler.h>",
            "#include <linux/audit.h>",
            "#include <linux/random.h>",
            "",
            "#include \"tick-internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"timekeeping_internal.h\"",
            "",
            "#define TK_CLEAR_NTP\t\t(1 << 0)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "",
            "enum timekeeping_adv_mode {",
            "\t/* Update timekeeper when a tick has passed */",
            "\tTK_ADV_TICK,",
            "",
            "\t/* Update timekeeper on a direct frequency change */",
            "\tTK_ADV_FREQ",
            "};",
            "",
            "DEFINE_RAW_SPINLOCK(timekeeper_lock);",
            "",
            "/*",
            " * The most important data for readout fits into a single 64 byte",
            " * cache line.",
            " */",
            "static struct {",
            "\tseqcount_raw_spinlock_t\tseq;",
            "\tstruct timekeeper\ttimekeeper;",
            "} tk_core ____cacheline_aligned = {",
            "\t.seq = SEQCNT_RAW_SPINLOCK_ZERO(tk_core.seq, &timekeeper_lock),",
            "};",
            "",
            "static struct timekeeper shadow_timekeeper;",
            "",
            "/* flag for if timekeeping is suspended */",
            "int __read_mostly timekeeping_suspended;",
            "",
            "/**",
            " * struct tk_fast - NMI safe timekeeper",
            " * @seq:\tSequence counter for protecting updates. The lowest bit",
            " *\t\tis the index for the tk_read_base array",
            " * @base:\ttk_read_base array. Access is indexed by the lowest bit of",
            " *\t\t@seq.",
            " *",
            " * See @update_fast_timekeeper() below.",
            " */",
            "struct tk_fast {",
            "\tseqcount_latch_t\tseq;",
            "\tstruct tk_read_base\tbase[2];",
            "};",
            "",
            "/* Suspend-time cycles value for halted fast timekeeper. */",
            "static u64 cycles_at_suspend;",
            ""
          ],
          "function_name": null,
          "description": "定义时间保持器核心结构体和锁，声明TK标志位枚举及全局时间保持器实例，提供NMI安全时间记录结构体tk_fast的定义，用于保护时间数据更新的序列计数器和基础读取结构体",
          "similarity": 0.5822224617004395
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 2290,
          "end_line": 2394,
          "content": [
            "void do_timer(unsigned long ticks)",
            "{",
            "\tjiffies_64 += ticks;",
            "\tcalc_global_load();",
            "}",
            "ktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,",
            "\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned int seq;",
            "\tktime_t base;",
            "\tu64 nsecs;",
            "",
            "\tdo {",
            "\t\tseq = read_seqcount_begin(&tk_core.seq);",
            "",
            "\t\tbase = tk->tkr_mono.base;",
            "\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);",
            "\t\tbase = ktime_add_ns(base, nsecs);",
            "",
            "\t\tif (*cwsseq != tk->clock_was_set_seq) {",
            "\t\t\t*cwsseq = tk->clock_was_set_seq;",
            "\t\t\t*offs_real = tk->offs_real;",
            "\t\t\t*offs_boot = tk->offs_boot;",
            "\t\t\t*offs_tai = tk->offs_tai;",
            "\t\t}",
            "",
            "\t\t/* Handle leapsecond insertion adjustments */",
            "\t\tif (unlikely(base >= tk->next_leap_ktime))",
            "\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));",
            "",
            "\t} while (read_seqcount_retry(&tk_core.seq, seq));",
            "",
            "\treturn base;",
            "}",
            "static int timekeeping_validate_timex(const struct __kernel_timex *txc)",
            "{",
            "\tif (txc->modes & ADJ_ADJTIME) {",
            "\t\t/* singleshot must not be used with any other mode bits */",
            "\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))",
            "\t\t\treturn -EINVAL;",
            "\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&",
            "\t\t    !capable(CAP_SYS_TIME))",
            "\t\t\treturn -EPERM;",
            "\t} else {",
            "\t\t/* In order to modify anything, you gotta be super-user! */",
            "\t\tif (txc->modes && !capable(CAP_SYS_TIME))",
            "\t\t\treturn -EPERM;",
            "\t\t/*",
            "\t\t * if the quartz is off by more than 10% then",
            "\t\t * something is VERY wrong!",
            "\t\t */",
            "\t\tif (txc->modes & ADJ_TICK &&",
            "\t\t    (txc->tick <  900000/USER_HZ ||",
            "\t\t     txc->tick > 1100000/USER_HZ))",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (txc->modes & ADJ_SETOFFSET) {",
            "\t\t/* In order to inject time, you gotta be super-user! */",
            "\t\tif (!capable(CAP_SYS_TIME))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t/*",
            "\t\t * Validate if a timespec/timeval used to inject a time",
            "\t\t * offset is valid.  Offsets can be positive or negative, so",
            "\t\t * we don't check tv_sec. The value of the timeval/timespec",
            "\t\t * is the sum of its fields,but *NOTE*:",
            "\t\t * The field tv_usec/tv_nsec must always be non-negative and",
            "\t\t * we can't have more nanoseconds/microseconds than a second.",
            "\t\t */",
            "\t\tif (txc->time.tv_usec < 0)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (txc->modes & ADJ_NANO) {",
            "\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)",
            "\t\t\t\treturn -EINVAL;",
            "\t\t} else {",
            "\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)",
            "\t\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Check for potential multiplication overflows that can",
            "\t * only happen on 64-bit systems:",
            "\t */",
            "\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {",
            "\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)",
            "\t\t\treturn -EINVAL;",
            "\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "unsigned long random_get_entropy_fallback(void)",
            "{",
            "\tstruct tk_read_base *tkr = &tk_core.timekeeper.tkr_mono;",
            "\tstruct clocksource *clock = READ_ONCE(tkr->clock);",
            "",
            "\tif (unlikely(timekeeping_suspended || !clock))",
            "\t\treturn 0;",
            "\treturn clock->read(clock);",
            "}"
          ],
          "function_name": "do_timer, ktime_get_update_offsets_now, timekeeping_validate_timex, random_get_entropy_fallback",
          "description": "处理定时器中断更新jiffies，获取并验证时间校准参数有效性，提供熵收集回退函数读取钟源读数",
          "similarity": 0.559027373790741
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 374,
          "end_line": 474,
          "content": [
            "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)",
            "{",
            "\tu64 nsec;",
            "",
            "\tnsec = delta * tkr->mult + tkr->xtime_nsec;",
            "\tnsec >>= tkr->shift;",
            "",
            "\treturn nsec;",
            "}",
            "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)",
            "{",
            "\tu64 delta;",
            "",
            "\tdelta = timekeeping_get_delta(tkr);",
            "\treturn timekeeping_delta_to_ns(tkr, delta);",
            "}",
            "static inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)",
            "{",
            "\tu64 delta;",
            "",
            "\t/* calculate the delta since the last update_wall_time */",
            "\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);",
            "\treturn timekeeping_delta_to_ns(tkr, delta);",
            "}",
            "static void update_fast_timekeeper(const struct tk_read_base *tkr,",
            "\t\t\t\t   struct tk_fast *tkf)",
            "{",
            "\tstruct tk_read_base *base = tkf->base;",
            "",
            "\t/* Force readers off to base[1] */",
            "\traw_write_seqcount_latch(&tkf->seq);",
            "",
            "\t/* Update base[0] */",
            "\tmemcpy(base, tkr, sizeof(*base));",
            "",
            "\t/* Force readers back to base[0] */",
            "\traw_write_seqcount_latch(&tkf->seq);",
            "",
            "\t/* Update base[1] */",
            "\tmemcpy(base + 1, base, sizeof(*base));",
            "}",
            "static __always_inline u64 fast_tk_get_delta_ns(struct tk_read_base *tkr)",
            "{",
            "\tu64 delta, cycles = tk_clock_read(tkr);",
            "",
            "\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);",
            "\treturn timekeeping_delta_to_ns(tkr, delta);",
            "}",
            "static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)",
            "{",
            "\tstruct tk_read_base *tkr;",
            "\tunsigned int seq;",
            "\tu64 now;",
            "",
            "\tdo {",
            "\t\tseq = raw_read_seqcount_latch(&tkf->seq);",
            "\t\ttkr = tkf->base + (seq & 0x01);",
            "\t\tnow = ktime_to_ns(tkr->base);",
            "\t\tnow += fast_tk_get_delta_ns(tkr);",
            "\t} while (raw_read_seqcount_latch_retry(&tkf->seq, seq));",
            "",
            "\treturn now;",
            "}",
            "u64 notrace ktime_get_mono_fast_ns(void)",
            "{",
            "\treturn __ktime_get_fast_ns(&tk_fast_mono);",
            "}",
            "u64 notrace ktime_get_raw_fast_ns(void)",
            "{",
            "\treturn __ktime_get_fast_ns(&tk_fast_raw);",
            "}",
            "u64 notrace ktime_get_boot_fast_ns(void)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "",
            "\treturn (ktime_get_mono_fast_ns() + ktime_to_ns(data_race(tk->offs_boot)));",
            "}",
            "u64 notrace ktime_get_tai_fast_ns(void)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "",
            "\treturn (ktime_get_mono_fast_ns() + ktime_to_ns(data_race(tk->offs_tai)));",
            "}",
            "static __always_inline u64 __ktime_get_real_fast(struct tk_fast *tkf, u64 *mono)",
            "{",
            "\tstruct tk_read_base *tkr;",
            "\tu64 basem, baser, delta;",
            "\tunsigned int seq;",
            "",
            "\tdo {",
            "\t\tseq = raw_read_seqcount_latch(&tkf->seq);",
            "\t\ttkr = tkf->base + (seq & 0x01);",
            "\t\tbasem = ktime_to_ns(tkr->base);",
            "\t\tbaser = ktime_to_ns(tkr->base_real);",
            "\t\tdelta = fast_tk_get_delta_ns(tkr);",
            "\t} while (raw_read_seqcount_latch_retry(&tkf->seq, seq));",
            "",
            "\tif (mono)",
            "\t\t*mono = basem + delta;",
            "\treturn baser + delta;",
            "}"
          ],
          "function_name": "timekeeping_delta_to_ns, timekeeping_get_ns, timekeeping_cycles_to_ns, update_fast_timekeeper, fast_tk_get_delta_ns, __ktime_get_fast_ns, ktime_get_mono_fast_ns, ktime_get_raw_fast_ns, ktime_get_boot_fast_ns, ktime_get_tai_fast_ns, __ktime_get_real_fast",
          "description": "将时间间隔转换为纳秒值，提供NMI安全时间获取接口，通过序列计数器保护多线程访问，利用双缓冲技术实现快速时间读取并保证数据一致性",
          "similarity": 0.5545514225959778
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 2423,
          "end_line": 2497,
          "content": [
            "int do_adjtimex(struct __kernel_timex *txc)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tstruct audit_ntp_data ad;",
            "\tbool clock_set = false;",
            "\tstruct timespec64 ts;",
            "\tunsigned long flags;",
            "\ts32 orig_tai, tai;",
            "\tint ret;",
            "",
            "\t/* Validate the data before disabling interrupts */",
            "\tret = timekeeping_validate_timex(txc);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tadd_device_randomness(txc, sizeof(*txc));",
            "",
            "\tif (txc->modes & ADJ_SETOFFSET) {",
            "\t\tstruct timespec64 delta;",
            "\t\tdelta.tv_sec  = txc->time.tv_sec;",
            "\t\tdelta.tv_nsec = txc->time.tv_usec;",
            "\t\tif (!(txc->modes & ADJ_NANO))",
            "\t\t\tdelta.tv_nsec *= 1000;",
            "\t\tret = timekeeping_inject_offset(&delta);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "",
            "\t\taudit_tk_injoffset(delta);",
            "\t}",
            "",
            "\taudit_ntp_init(&ad);",
            "",
            "\tktime_get_real_ts64(&ts);",
            "\tadd_device_randomness(&ts, sizeof(ts));",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\torig_tai = tai = tk->tai_offset;",
            "\tret = __do_adjtimex(txc, &ts, &tai, &ad);",
            "",
            "\tif (tai != orig_tai) {",
            "\t\t__timekeeping_set_tai_offset(tk, tai);",
            "\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);",
            "\t\tclock_set = true;",
            "\t}",
            "\ttk_update_leap_state(tk);",
            "",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\taudit_ntp_log(&ad);",
            "",
            "\t/* Update the multiplier immediately if frequency was set directly */",
            "\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))",
            "\t\tclock_set |= timekeeping_advance(TK_ADV_FREQ);",
            "",
            "\tif (clock_set)",
            "\t\tclock_was_set(CLOCK_SET_WALL);",
            "",
            "\tntp_notify_cmos_timer();",
            "",
            "\treturn ret;",
            "}",
            "void hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\t__hardpps(phase_ts, raw_ts);",
            "",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "}"
          ],
          "function_name": "do_adjtimex, hardpps",
          "description": "该代码段实现时间调整与硬件脉冲信号处理功能。do_adjtimex函数负责解析并应用用户空间通过TIMEX接口提交的时间校准请求（如偏移量设置、频率调整），通过锁定时间保持器并更新TAI偏移量实现系统时间同步，同时记录审计日志。hardpps函数作为硬件PPS信号处理入口，通过加锁机制将相位时间戳传递给底层时间校准逻辑以修正系统时钟。",
          "similarity": 0.5366531610488892
        },
        {
          "chunk_id": 13,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 2151,
          "end_line": 2263,
          "content": [
            "static bool timekeeping_advance(enum timekeeping_adv_mode mode)",
            "{",
            "\tstruct timekeeper *real_tk = &tk_core.timekeeper;",
            "\tstruct timekeeper *tk = &shadow_timekeeper;",
            "\tu64 offset;",
            "\tint shift = 0, maxshift;",
            "\tunsigned int clock_set = 0;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "",
            "\t/* Make sure we're fully resumed: */",
            "\tif (unlikely(timekeeping_suspended))",
            "\t\tgoto out;",
            "",
            "\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),",
            "\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);",
            "",
            "\t/* Check if there's really nothing to do */",
            "\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)",
            "\t\tgoto out;",
            "",
            "\t/* Do some additional sanity checking */",
            "\ttimekeeping_check_update(tk, offset);",
            "",
            "\t/*",
            "\t * With NO_HZ we may have to accumulate many cycle_intervals",
            "\t * (think \"ticks\") worth of time at once. To do this efficiently,",
            "\t * we calculate the largest doubling multiple of cycle_intervals",
            "\t * that is smaller than the offset.  We then accumulate that",
            "\t * chunk in one go, and then try to consume the next smaller",
            "\t * doubled multiple.",
            "\t */",
            "\tshift = ilog2(offset) - ilog2(tk->cycle_interval);",
            "\tshift = max(0, shift);",
            "\t/* Bound shift to one less than what overflows tick_length */",
            "\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;",
            "\tshift = min(shift, maxshift);",
            "\twhile (offset >= tk->cycle_interval) {",
            "\t\toffset = logarithmic_accumulation(tk, offset, shift,",
            "\t\t\t\t\t\t\t&clock_set);",
            "\t\tif (offset < tk->cycle_interval<<shift)",
            "\t\t\tshift--;",
            "\t}",
            "",
            "\t/* Adjust the multiplier to correct NTP error */",
            "\ttimekeeping_adjust(tk, offset);",
            "",
            "\t/*",
            "\t * Finally, make sure that after the rounding",
            "\t * xtime_nsec isn't larger than NSEC_PER_SEC",
            "\t */",
            "\tclock_set |= accumulate_nsecs_to_secs(tk);",
            "",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "\t/*",
            "\t * Update the real timekeeper.",
            "\t *",
            "\t * We could avoid this memcpy by switching pointers, but that",
            "\t * requires changes to all other timekeeper usage sites as",
            "\t * well, i.e. move the timekeeper pointer getter into the",
            "\t * spinlocked/seqcount protected sections. And we trade this",
            "\t * memcpy under the tk_core.seq against one before we start",
            "\t * updating.",
            "\t */",
            "\ttimekeeping_update(tk, clock_set);",
            "\tmemcpy(real_tk, tk, sizeof(*tk));",
            "\t/* The memcpy must come last. Do not put anything here! */",
            "\twrite_seqcount_end(&tk_core.seq);",
            "out:",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\treturn !!clock_set;",
            "}",
            "void update_wall_time(void)",
            "{",
            "\tif (timekeeping_advance(TK_ADV_TICK))",
            "\t\tclock_was_set_delayed();",
            "}",
            "void getboottime64(struct timespec64 *ts)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tktime_t t = ktime_sub(tk->offs_real, tk->offs_boot);",
            "",
            "\t*ts = ktime_to_timespec64(t);",
            "}",
            "void ktime_get_coarse_real_ts64(struct timespec64 *ts)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned int seq;",
            "",
            "\tdo {",
            "\t\tseq = read_seqcount_begin(&tk_core.seq);",
            "",
            "\t\t*ts = tk_xtime(tk);",
            "\t} while (read_seqcount_retry(&tk_core.seq, seq));",
            "}",
            "void ktime_get_coarse_ts64(struct timespec64 *ts)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tstruct timespec64 now, mono;",
            "\tunsigned int seq;",
            "",
            "\tdo {",
            "\t\tseq = read_seqcount_begin(&tk_core.seq);",
            "",
            "\t\tnow = tk_xtime(tk);",
            "\t\tmono = tk->wall_to_monotonic;",
            "\t} while (read_seqcount_retry(&tk_core.seq, seq));",
            "",
            "\tset_normalized_timespec64(ts, now.tv_sec + mono.tv_sec,",
            "\t\t\t\tnow.tv_nsec + mono.tv_nsec);",
            "}"
          ],
          "function_name": "timekeeping_advance, update_wall_time, getboottime64, ktime_get_coarse_real_ts64, ktime_get_coarse_ts64",
          "description": "推进时间保持器状态，更新墙时间并触发时钟变更通知，提供获取启动时间和粗粒度实时时间戳的接口",
          "similarity": 0.5305521488189697
        }
      ]
    },
    {
      "source_file": "kernel/time/timekeeping_internal.h",
      "md_summary": "> 自动生成时间: 2025-10-25 16:56:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timekeeping_internal.h`\n\n---\n\n# timekeeping_internal.h 技术文档\n\n## 1. 文件概述\n\n`timekeeping_internal.h` 是 Linux 内核时间子系统中的一个内部头文件，主要用于定义时间保持（timekeeping）模块的内部接口、辅助函数和共享数据结构。该文件为时间保持核心逻辑提供底层支持，包括时钟源（clocksource）差值计算、调试功能以及跨模块同步机制，仅供内核时间子系统内部使用，不对外暴露给其他子系统。\n\n## 2. 核心功能\n\n### 函数\n\n- **`tk_debug_account_sleep_time(const struct timespec64 *t)`**  \n  在启用 `CONFIG_DEBUG_FS` 配置时，用于记录系统休眠期间的时间消耗，便于调试时间保持行为；否则定义为空宏。\n\n- **`clocksource_delta(u64 now, u64 last, u64 mask)`**  \n  计算两个时钟源读数之间的差值，并根据掩码（mask）进行环绕处理。在启用 `CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE` 时，会额外检查是否发生时间回退，防止无效的负向时间差。\n\n### 数据结构\n\n- **`timekeeper_lock`**  \n  类型为 `raw_spinlock_t` 的原始自旋锁，用于序列化对非 timekeeper 模块的 VDSO（虚拟动态共享对象）时间数据的更新操作，确保多核环境下时间数据的一致性。\n\n## 3. 关键实现\n\n### 时钟源差值计算（`clocksource_delta`）\n\n该函数用于安全地计算时钟源两次读数之间的增量。由于硬件时钟源通常为固定位宽的计数器（如 32 位或 64 位），在溢出时会自动回绕。`mask` 参数用于限定有效位宽（例如，32 位计数器对应 `mask = 0xFFFFFFFF`）。\n\n- **基础实现**：直接计算 `(now - last) & mask`，利用无符号整数的模运算特性处理回绕。\n- **带验证的实现**（启用 `CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE`）：\n  - 通过检查结果的最高有效位（MSB）是否被置位（即 `ret & ~(mask >> 1)` 是否非零）来判断是否发生了异常的“时间倒流”。\n  - 若检测到可能的时间回退（例如因 last 值异常或时钟源不稳定），则返回 0，避免将负时间差传递给上层时间保持逻辑，从而增强系统鲁棒性。\n\n### 调试支持\n\n通过条件编译控制 `tk_debug_account_sleep_time` 函数的存在，仅在启用调试文件系统（`CONFIG_DEBUG_FS`）时提供休眠时间统计功能，用于分析系统挂起/恢复过程中的时间行为。\n\n### 同步机制\n\n`timekeeper_lock` 是一个 `raw_spinlock_t` 类型的锁，用于保护 VDSO 中非 timekeeper 模块写入的时间数据（如 `wall_to_monotonic` 等）。使用原始自旋锁（而非普通自旋锁）是为了避免在中断上下文或不可睡眠上下文中发生调度，确保低延迟和确定性。\n\n## 4. 依赖关系\n\n- **`<linux/clocksource.h>`**：提供时钟源（clocksource）相关的定义和接口，`clocksource_delta` 函数直接操作时钟源原始计数值。\n- **`<linux/spinlock.h>`**：提供 `raw_spinlock_t` 类型及锁操作原语，用于定义和操作 `timekeeper_lock`。\n- **`<linux/time.h>`**：提供 `timespec64` 等时间表示结构体，用于调试函数的参数类型。\n- **配置选项依赖**：\n  - `CONFIG_DEBUG_FS`：控制调试函数的编译。\n  - `CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE`：控制是否启用时钟源差值的安全验证逻辑。\n\n## 5. 使用场景\n\n- **时间保持核心更新**：在 `timekeeping.c` 中调用 `clocksource_delta` 计算自上次更新以来的时钟源增量，用于推进系统时间。\n- **VDSO 时间数据同步**：当非 timekeeper 模块（如 NTP 调整、挂起/恢复路径）需要更新 VDSO 中的时间偏移量时，使用 `timekeeper_lock` 进行序列化，防止与用户态读取操作发生竞争。\n- **系统休眠/唤醒调试**：在系统进入 suspend 或从 resume 恢复时，通过 `tk_debug_account_sleep_time` 记录休眠持续时间，辅助分析时间漂移或丢失问题。\n- **时钟源稳定性保障**：在启用验证选项的系统中，`clocksource_delta` 可防止因硬件故障或驱动错误导致的时钟回退，提升时间子系统的可靠性。",
      "similarity": 0.634354293346405,
      "chunks": []
    },
    {
      "source_file": "kernel/time/time.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:52:34\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\time.c`\n\n---\n\n# time/time.c 技术文档\n\n## 1. 文件概述\n\n`time/time.c` 是 Linux 内核中负责实现与时间相关的系统调用的核心文件。该文件提供了用户空间程序访问和设置系统时间的接口，包括 `time`、`stime`、`gettimeofday`、`settimeofday` 和 `adjtimex` 等传统 POSIX 时间系统调用。文件同时支持 32 位和 64 位时间表示，并处理不同架构和兼容性需求，确保内核时间子系统与用户空间的正确交互。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`sys_tz`** (`struct timezone`)：全局变量，存储系统默认时区信息，供 `gettimeofday` 系统调用返回。\n\n### 主要函数\n- **`SYSCALL_DEFINE1(time, ...)`**：返回自 Unix 纪元（1970-01-01 00:00:00 UTC）以来的秒数。\n- **`SYSCALL_DEFINE1(stime, ...)`**：设置系统时间（仅秒级精度）。\n- **`SYSCALL_DEFINE2(gettimeofday, ...)`**：获取高精度系统时间（微秒级）和时区信息。\n- **`SYSCALL_DEFINE2(settimeofday, ...)`**：设置系统时间（微秒级精度）和/或时区。\n- **`do_sys_settimeofday64(...)`**：`settimeofday` 的核心实现函数，处理时间/时区验证、安全检查和时钟调整。\n- **`SYSCALL_DEFINE1(adjtimex, ...)`**：用于 NTP（网络时间协议）时间同步，调整系统时钟频率和偏移。\n- **兼容性系统调用**：\n  - `time32` / `stime32`：32 位时间值的兼容接口（用于 `CONFIG_COMPAT_32BIT_TIME`）。\n  - `COMPAT_SYSCALL_DEFINE2(gettimeofday, ...)` / `COMPAT_SYSCALL_DEFINE2(settimeofday, ...)`：32 位用户空间兼容接口。\n- **辅助函数**：\n  - `get_old_timex32(...)`：将 32 位 `old_timex32` 结构转换为内核 `__kernel_timex`。\n  - `put_old_timex32(...)`：将内核 `__kernel_timex` 结构转换回 32 位 `old_timex32`（代码截断）。\n\n## 3. 关键实现\n\n### 时间获取与设置\n- 使用 `ktime_get_real_seconds()` 和 `ktime_get_real_ts64()` 从内核时间子系统获取高精度实时时间。\n- 时间设置通过 `do_settimeofday64()` 接口完成，该函数负责更新内核时间状态并通知相关子系统。\n\n### 时区处理\n- 全局变量 `sys_tz` 存储系统时区，通过 `settimeofday` 更新。\n- 首次设置时区时（`firsttime == 1`），若未同时设置时间，则调用 `timekeeping_warp_clock()` 将 CMOS 时钟从本地时间转换为 UTC 时间，避免时间跳变对应用程序造成影响。\n\n### 安全与验证\n- 所有修改系统时间的操作均调用 `security_settime64()` 进行 LSM（Linux Security Module）安全检查。\n- 输入参数严格验证：\n  - 时间值必须通过 `timespec64_valid_settod()` 检查有效性。\n  - 时区偏移限制在 ±15 小时范围内（`tz_minuteswest ∈ [-900, 900]`）。\n  - 微秒值必须在 `[0, USEC_PER_SEC)` 范围内。\n\n### 兼容性支持\n- 通过条件编译宏（如 `__ARCH_WANT_SYS_TIME`、`CONFIG_COMPAT_32BIT_TIME`、`CONFIG_COMPAT`）支持不同架构和位宽需求。\n- 32 位时间接口（`time32`/`stime32`）用于处理 `time_t` 为 32 位的旧应用程序。\n- 兼容层系统调用处理 32 位用户空间结构体与 64 位内核结构体之间的转换。\n\n### NTP 支持\n- `adjtimex` 系统调用提供对内核 PLL（锁相环）的精细控制，用于 NTP 时间同步。\n- 支持 NTPv4 规范，允许更大的时间常数（`time_constant > 6`）。\n\n## 4. 依赖关系\n\n- **内核时间子系统**：\n  - `<linux/timekeeper_internal.h>`、`\"timekeeping.h\"`：提供 `ktime_get_real_ts64()`、`do_settimeofday64()`、`timekeeping_warp_clock()` 等核心时间操作。\n- **安全框架**：\n  - `<linux/security.h>`：提供 `security_settime64()` 安全钩子。\n- **系统调用框架**：\n  - `<linux/syscalls.h>`：定义 `SYSCALL_DEFINE` 宏。\n  - `<linux/compat.h>`：提供 32/64 位兼容系统调用支持。\n- **架构相关**：\n  - `<asm/unistd.h>`：包含系统调用号定义。\n  - `__ARCH_WANT_SYS_TIME` 等宏由具体架构定义，决定是否编译传统时间系统调用。\n- **其他**：\n  - `<linux/uaccess.h>`：提供用户空间内存访问函数（`get_user`、`put_user`、`copy_to/from_user`）。\n  - `<generated/timeconst.h>`：包含编译时生成的时间常量。\n\n## 5. 使用场景\n\n- **用户空间时间获取**：应用程序通过 `gettimeofday()` 获取高精度当前时间，用于日志记录、性能分析、定时器等。\n- **系统时间设置**：管理员或 NTP 守护进程（如 `ntpd`、`chronyd`）通过 `settimeofday()` 或 `adjtimex()` 同步系统时间。\n- **时区配置**：系统初始化脚本（如 `/etc/rc`）通过 `settimeofday()` 设置时区，确保 CMOS 时钟以 UTC 运行。\n- **遗留应用支持**：32 位时间接口支持在 64 位系统上运行的旧版应用程序（Y2038 问题兼容）。\n- **NTP 精确时间同步**：`adjtimex()` 系统调用被 NTP 守护进程用于微调系统时钟频率和相位，实现高精度时间同步。",
      "similarity": 0.6334714889526367,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/time/time.c",
          "start_line": 984,
          "end_line": 1026,
          "content": [
            "int get_itimerspec64(struct itimerspec64 *it,",
            "\t\t\tconst struct __kernel_itimerspec __user *uit)",
            "{",
            "\tint ret;",
            "",
            "\tret = get_timespec64(&it->it_interval, &uit->it_interval);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = get_timespec64(&it->it_value, &uit->it_value);",
            "",
            "\treturn ret;",
            "}",
            "int put_itimerspec64(const struct itimerspec64 *it,",
            "\t\t\tstruct __kernel_itimerspec __user *uit)",
            "{",
            "\tint ret;",
            "",
            "\tret = put_timespec64(&it->it_interval, &uit->it_interval);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = put_timespec64(&it->it_value, &uit->it_value);",
            "",
            "\treturn ret;",
            "}",
            "int get_old_itimerspec32(struct itimerspec64 *its,",
            "\t\t\tconst struct old_itimerspec32 __user *uits)",
            "{",
            "",
            "\tif (__get_old_timespec32(&its->it_interval, &uits->it_interval) ||",
            "\t    __get_old_timespec32(&its->it_value, &uits->it_value))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "int put_old_itimerspec32(const struct itimerspec64 *its,",
            "\t\t\tstruct old_itimerspec32 __user *uits)",
            "{",
            "\tif (__put_old_timespec32(&its->it_interval, &uits->it_interval) ||",
            "\t    __put_old_timespec32(&its->it_value, &uits->it_value))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_itimerspec64, put_itimerspec64, get_old_itimerspec32, put_old_itimerspec32",
          "description": "该代码块实现了对时间间隔结构体（itimerspec）在用户空间与内核空间之间的转换，包含64位和32位兼容处理。  \n`get/put_itimerspec64` 用于64位时间规范的双向转换，通过 `get/put_timespec64` 处理内部时间戳字段；`get_old/put_old_itimerspec32` 专为兼容旧版32位接口设计，通过辅助函数进行安全拷贝并检查错误。  \n由于代码未包含 `get_timespec64`、`put_timespec64` 及 `__get_old_timespec32` 等关键辅助函数的定义，上下文信息不完整。",
          "similarity": 0.5943644046783447
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/time/time.c",
          "start_line": 796,
          "end_line": 899,
          "content": [
            "u64 nsecs_to_jiffies64(u64 n)",
            "{",
            "#if (NSEC_PER_SEC % HZ) == 0",
            "\t/* Common case, HZ = 100, 128, 200, 250, 256, 500, 512, 1000 etc. */",
            "\treturn div_u64(n, NSEC_PER_SEC / HZ);",
            "#elif (HZ % 512) == 0",
            "\t/* overflow after 292 years if HZ = 1024 */",
            "\treturn div_u64(n * HZ / 512, NSEC_PER_SEC / 512);",
            "#else",
            "\t/*",
            "\t * Generic case - optimized for cases where HZ is a multiple of 3.",
            "\t * overflow after 64.99 years, exact for HZ = 60, 72, 90, 120 etc.",
            "\t */",
            "\treturn div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);",
            "#endif",
            "}",
            "unsigned long nsecs_to_jiffies(u64 n)",
            "{",
            "\treturn (unsigned long)nsecs_to_jiffies64(n);",
            "}",
            "struct timespec64 timespec64_add_safe(const struct timespec64 lhs,",
            "\t\t\t\tconst struct timespec64 rhs)",
            "{",
            "\tstruct timespec64 res;",
            "",
            "\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,",
            "\t\t\tlhs.tv_nsec + rhs.tv_nsec);",
            "",
            "\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {",
            "\t\tres.tv_sec = TIME64_MAX;",
            "\t\tres.tv_nsec = 0;",
            "\t}",
            "",
            "\treturn res;",
            "}",
            "int get_timespec64(struct timespec64 *ts,",
            "\t\t   const struct __kernel_timespec __user *uts)",
            "{",
            "\tstruct __kernel_timespec kts;",
            "\tint ret;",
            "",
            "\tret = copy_from_user(&kts, uts, sizeof(kts));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tts->tv_sec = kts.tv_sec;",
            "",
            "\t/* Zero out the padding in compat mode */",
            "\tif (in_compat_syscall())",
            "\t\tkts.tv_nsec &= 0xFFFFFFFFUL;",
            "",
            "\t/* In 32-bit mode, this drops the padding */",
            "\tts->tv_nsec = kts.tv_nsec;",
            "",
            "\treturn 0;",
            "}",
            "int put_timespec64(const struct timespec64 *ts,",
            "\t\t   struct __kernel_timespec __user *uts)",
            "{",
            "\tstruct __kernel_timespec kts = {",
            "\t\t.tv_sec = ts->tv_sec,",
            "\t\t.tv_nsec = ts->tv_nsec",
            "\t};",
            "",
            "\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;",
            "}",
            "static int __get_old_timespec32(struct timespec64 *ts64,",
            "\t\t\t\t   const struct old_timespec32 __user *cts)",
            "{",
            "\tstruct old_timespec32 ts;",
            "\tint ret;",
            "",
            "\tret = copy_from_user(&ts, cts, sizeof(ts));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tts64->tv_sec = ts.tv_sec;",
            "\tts64->tv_nsec = ts.tv_nsec;",
            "",
            "\treturn 0;",
            "}",
            "static int __put_old_timespec32(const struct timespec64 *ts64,",
            "\t\t\t\t   struct old_timespec32 __user *cts)",
            "{",
            "\tstruct old_timespec32 ts = {",
            "\t\t.tv_sec = ts64->tv_sec,",
            "\t\t.tv_nsec = ts64->tv_nsec",
            "\t};",
            "\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;",
            "}",
            "int get_old_timespec32(struct timespec64 *ts, const void __user *uts)",
            "{",
            "\tif (COMPAT_USE_64BIT_TIME)",
            "\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;",
            "\telse",
            "\t\treturn __get_old_timespec32(ts, uts);",
            "}",
            "int put_old_timespec32(const struct timespec64 *ts, void __user *uts)",
            "{",
            "\tif (COMPAT_USE_64BIT_TIME)",
            "\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;",
            "\telse",
            "\t\treturn __put_old_timespec32(ts, uts);",
            "}"
          ],
          "function_name": "nsecs_to_jiffies64, nsecs_to_jiffies, timespec64_add_safe, get_timespec64, put_timespec64, __get_old_timespec32, __put_old_timespec32, get_old_timespec32, put_old_timespec32",
          "description": "实现纳秒到jiffies转换nsecs_to_jiffies64，时间相加函数timespec64_add_safe，以及timespec64与用户态old_timespec32结构体的数据复制函数get/put_old_timespec32。",
          "similarity": 0.5478655099868774
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/time.c",
          "start_line": 400,
          "end_line": 501,
          "content": [
            "unsigned int jiffies_to_usecs(const unsigned long j)",
            "{",
            "\t/*",
            "\t * Hz usually doesn't go much further MSEC_PER_SEC.",
            "\t * jiffies_to_usecs() and usecs_to_jiffies() depend on that.",
            "\t */",
            "\tBUILD_BUG_ON(HZ > USEC_PER_SEC);",
            "",
            "#if !(USEC_PER_SEC % HZ)",
            "\treturn (USEC_PER_SEC / HZ) * j;",
            "#else",
            "# if BITS_PER_LONG == 32",
            "\treturn (HZ_TO_USEC_MUL32 * j) >> HZ_TO_USEC_SHR32;",
            "# else",
            "\treturn (j * HZ_TO_USEC_NUM) / HZ_TO_USEC_DEN;",
            "# endif",
            "#endif",
            "}",
            "time64_t mktime64(const unsigned int year0, const unsigned int mon0,",
            "\t\tconst unsigned int day, const unsigned int hour,",
            "\t\tconst unsigned int min, const unsigned int sec)",
            "{",
            "\tunsigned int mon = mon0, year = year0;",
            "",
            "\t/* 1..12 -> 11,12,1..10 */",
            "\tif (0 >= (int) (mon -= 2)) {",
            "\t\tmon += 12;\t/* Puts Feb last since it has leap day */",
            "\t\tyear -= 1;",
            "\t}",
            "",
            "\treturn ((((time64_t)",
            "\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +",
            "\t\t  year*365 - 719499",
            "\t    )*24 + hour /* now have hours - midnight tomorrow handled here */",
            "\t  )*60 + min /* now have minutes */",
            "\t)*60 + sec; /* finally seconds */",
            "}",
            "struct __kernel_old_timeval ns_to_kernel_old_timeval(s64 nsec)",
            "{",
            "\tstruct timespec64 ts = ns_to_timespec64(nsec);",
            "\tstruct __kernel_old_timeval tv;",
            "",
            "\ttv.tv_sec = ts.tv_sec;",
            "\ttv.tv_usec = (suseconds_t)ts.tv_nsec / 1000;",
            "",
            "\treturn tv;",
            "}",
            "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)",
            "{",
            "\twhile (nsec >= NSEC_PER_SEC) {",
            "\t\t/*",
            "\t\t * The following asm() prevents the compiler from",
            "\t\t * optimising this loop into a modulo operation. See",
            "\t\t * also __iter_div_u64_rem() in include/linux/time.h",
            "\t\t */",
            "\t\tasm(\"\" : \"+rm\"(nsec));",
            "\t\tnsec -= NSEC_PER_SEC;",
            "\t\t++sec;",
            "\t}",
            "\twhile (nsec < 0) {",
            "\t\tasm(\"\" : \"+rm\"(nsec));",
            "\t\tnsec += NSEC_PER_SEC;",
            "\t\t--sec;",
            "\t}",
            "\tts->tv_sec = sec;",
            "\tts->tv_nsec = nsec;",
            "}",
            "struct timespec64 ns_to_timespec64(s64 nsec)",
            "{",
            "\tstruct timespec64 ts = { 0, 0 };",
            "\ts32 rem;",
            "",
            "\tif (likely(nsec > 0)) {",
            "\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);",
            "\t\tts.tv_nsec = rem;",
            "\t} else if (nsec < 0) {",
            "\t\t/*",
            "\t\t * With negative times, tv_sec points to the earlier",
            "\t\t * second, and tv_nsec counts the nanoseconds since",
            "\t\t * then, so tv_nsec is always a positive number.",
            "\t\t */",
            "\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;",
            "\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;",
            "\t}",
            "",
            "\treturn ts;",
            "}",
            "unsigned long __msecs_to_jiffies(const unsigned int m)",
            "{",
            "\t/*",
            "\t * Negative value, means infinite timeout:",
            "\t */",
            "\tif ((int)m < 0)",
            "\t\treturn MAX_JIFFY_OFFSET;",
            "\treturn _msecs_to_jiffies(m);",
            "}",
            "unsigned long __usecs_to_jiffies(const unsigned int u)",
            "{",
            "\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))",
            "\t\treturn MAX_JIFFY_OFFSET;",
            "\treturn _usecs_to_jiffies(u);",
            "}"
          ],
          "function_name": "jiffies_to_usecs, mktime64, ns_to_kernel_old_timeval, set_normalized_timespec64, ns_to_timespec64, __msecs_to_jiffies, __usecs_to_jiffies",
          "description": "包含时间单位转换函数jiffies_to_usecs/msecs_to_jiffies等，实现mktime64日期转时间戳，ns_to_*系列纳秒到时间结构体转换，以及set_normalized_timespec64时间归一化处理。",
          "similarity": 0.532077968120575
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/time.c",
          "start_line": 616,
          "end_line": 720,
          "content": [
            "unsigned long",
            "timespec64_to_jiffies(const struct timespec64 *value)",
            "{",
            "\tu64 sec = value->tv_sec;",
            "\tlong nsec = value->tv_nsec + TICK_NSEC - 1;",
            "",
            "\tif (sec >= MAX_SEC_IN_JIFFIES){",
            "\t\tsec = MAX_SEC_IN_JIFFIES;",
            "\t\tnsec = 0;",
            "\t}",
            "\treturn ((sec * SEC_CONVERSION) +",
            "\t\t(((u64)nsec * NSEC_CONVERSION) >>",
            "\t\t (NSEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;",
            "",
            "}",
            "void",
            "jiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)",
            "{",
            "\t/*",
            "\t * Convert jiffies to nanoseconds and separate with",
            "\t * one divide.",
            "\t */",
            "\tu32 rem;",
            "\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,",
            "\t\t\t\t    NSEC_PER_SEC, &rem);",
            "\tvalue->tv_nsec = rem;",
            "}",
            "clock_t jiffies_to_clock_t(unsigned long x)",
            "{",
            "#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0",
            "# if HZ < USER_HZ",
            "\treturn x * (USER_HZ / HZ);",
            "# else",
            "\treturn x / (HZ / USER_HZ);",
            "# endif",
            "#else",
            "\treturn div_u64((u64)x * TICK_NSEC, NSEC_PER_SEC / USER_HZ);",
            "#endif",
            "}",
            "unsigned long clock_t_to_jiffies(unsigned long x)",
            "{",
            "#if (HZ % USER_HZ)==0",
            "\tif (x >= ~0UL / (HZ / USER_HZ))",
            "\t\treturn ~0UL;",
            "\treturn x * (HZ / USER_HZ);",
            "#else",
            "\t/* Don't worry about loss of precision here .. */",
            "\tif (x >= ~0UL / HZ * USER_HZ)",
            "\t\treturn ~0UL;",
            "",
            "\t/* .. but do try to contain it here */",
            "\treturn div_u64((u64)x * HZ, USER_HZ);",
            "#endif",
            "}",
            "u64 jiffies_64_to_clock_t(u64 x)",
            "{",
            "#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0",
            "# if HZ < USER_HZ",
            "\tx = div_u64(x * USER_HZ, HZ);",
            "# elif HZ > USER_HZ",
            "\tx = div_u64(x, HZ / USER_HZ);",
            "# else",
            "\t/* Nothing to do */",
            "# endif",
            "#else",
            "\t/*",
            "\t * There are better ways that don't overflow early,",
            "\t * but even this doesn't overflow in hundreds of years",
            "\t * in 64 bits, so..",
            "\t */",
            "\tx = div_u64(x * TICK_NSEC, (NSEC_PER_SEC / USER_HZ));",
            "#endif",
            "\treturn x;",
            "}",
            "u64 nsec_to_clock_t(u64 x)",
            "{",
            "#if (NSEC_PER_SEC % USER_HZ) == 0",
            "\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);",
            "#elif (USER_HZ % 512) == 0",
            "\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);",
            "#else",
            "\t/*",
            "         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,",
            "         * overflow after 64.99 years.",
            "         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...",
            "         */",
            "\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);",
            "#endif",
            "}",
            "u64 jiffies64_to_nsecs(u64 j)",
            "{",
            "#if !(NSEC_PER_SEC % HZ)",
            "\treturn (NSEC_PER_SEC / HZ) * j;",
            "# else",
            "\treturn div_u64(j * HZ_TO_NSEC_NUM, HZ_TO_NSEC_DEN);",
            "#endif",
            "}",
            "u64 jiffies64_to_msecs(const u64 j)",
            "{",
            "#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)",
            "\treturn (MSEC_PER_SEC / HZ) * j;",
            "#else",
            "\treturn div_u64(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);",
            "#endif",
            "}"
          ],
          "function_name": "timespec64_to_jiffies, jiffies_to_timespec64, jiffies_to_clock_t, clock_t_to_jiffies, jiffies_64_to_clock_t, nsec_to_clock_t, jiffies64_to_nsecs, jiffies64_to_msecs",
          "description": "提供多种时间表示形式转换函数，包括timespec64与jiffies互转，clock_t与jiffies转换，以及nsec到clock_t等不同时间域间的转换实现。",
          "similarity": 0.5259178280830383
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/time.c",
          "start_line": 169,
          "end_line": 273,
          "content": [
            "int do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)",
            "{",
            "\tstatic int firsttime = 1;",
            "\tint error = 0;",
            "",
            "\tif (tv && !timespec64_valid_settod(tv))",
            "\t\treturn -EINVAL;",
            "",
            "\terror = security_settime64(tv, tz);",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\tif (tz) {",
            "\t\t/* Verify we're within the +-15 hrs range */",
            "\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tsys_tz = *tz;",
            "\t\tupdate_vsyscall_tz();",
            "\t\tif (firsttime) {",
            "\t\t\tfirsttime = 0;",
            "\t\t\tif (!tv)",
            "\t\t\t\ttimekeeping_warp_clock();",
            "\t\t}",
            "\t}",
            "\tif (tv)",
            "\t\treturn do_settimeofday64(tv);",
            "\treturn 0;",
            "}",
            "int get_old_timex32(struct __kernel_timex *txc, const struct old_timex32 __user *utp)",
            "{",
            "\tstruct old_timex32 tx32;",
            "",
            "\tmemset(txc, 0, sizeof(struct __kernel_timex));",
            "\tif (copy_from_user(&tx32, utp, sizeof(struct old_timex32)))",
            "\t\treturn -EFAULT;",
            "",
            "\ttxc->modes = tx32.modes;",
            "\ttxc->offset = tx32.offset;",
            "\ttxc->freq = tx32.freq;",
            "\ttxc->maxerror = tx32.maxerror;",
            "\ttxc->esterror = tx32.esterror;",
            "\ttxc->status = tx32.status;",
            "\ttxc->constant = tx32.constant;",
            "\ttxc->precision = tx32.precision;",
            "\ttxc->tolerance = tx32.tolerance;",
            "\ttxc->time.tv_sec = tx32.time.tv_sec;",
            "\ttxc->time.tv_usec = tx32.time.tv_usec;",
            "\ttxc->tick = tx32.tick;",
            "\ttxc->ppsfreq = tx32.ppsfreq;",
            "\ttxc->jitter = tx32.jitter;",
            "\ttxc->shift = tx32.shift;",
            "\ttxc->stabil = tx32.stabil;",
            "\ttxc->jitcnt = tx32.jitcnt;",
            "\ttxc->calcnt = tx32.calcnt;",
            "\ttxc->errcnt = tx32.errcnt;",
            "\ttxc->stbcnt = tx32.stbcnt;",
            "",
            "\treturn 0;",
            "}",
            "int put_old_timex32(struct old_timex32 __user *utp, const struct __kernel_timex *txc)",
            "{",
            "\tstruct old_timex32 tx32;",
            "",
            "\tmemset(&tx32, 0, sizeof(struct old_timex32));",
            "\ttx32.modes = txc->modes;",
            "\ttx32.offset = txc->offset;",
            "\ttx32.freq = txc->freq;",
            "\ttx32.maxerror = txc->maxerror;",
            "\ttx32.esterror = txc->esterror;",
            "\ttx32.status = txc->status;",
            "\ttx32.constant = txc->constant;",
            "\ttx32.precision = txc->precision;",
            "\ttx32.tolerance = txc->tolerance;",
            "\ttx32.time.tv_sec = txc->time.tv_sec;",
            "\ttx32.time.tv_usec = txc->time.tv_usec;",
            "\ttx32.tick = txc->tick;",
            "\ttx32.ppsfreq = txc->ppsfreq;",
            "\ttx32.jitter = txc->jitter;",
            "\ttx32.shift = txc->shift;",
            "\ttx32.stabil = txc->stabil;",
            "\ttx32.jitcnt = txc->jitcnt;",
            "\ttx32.calcnt = txc->calcnt;",
            "\ttx32.errcnt = txc->errcnt;",
            "\ttx32.stbcnt = txc->stbcnt;",
            "\ttx32.tai = txc->tai;",
            "\tif (copy_to_user(utp, &tx32, sizeof(struct old_timex32)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "unsigned int jiffies_to_msecs(const unsigned long j)",
            "{",
            "#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)",
            "\treturn (MSEC_PER_SEC / HZ) * j;",
            "#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)",
            "\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);",
            "#else",
            "# if BITS_PER_LONG == 32",
            "\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>",
            "\t       HZ_TO_MSEC_SHR32;",
            "# else",
            "\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);",
            "# endif",
            "#endif",
            "}"
          ],
          "function_name": "do_sys_settimeofday64, get_old_timex32, put_old_timex32, jiffies_to_msecs",
          "description": "实现do_sys_settimeofday64用于设置系统时间，提供old_timex结构体转换函数get_old_timex32/put_old_timex32，以及jiffies到毫秒的转换函数jiffies_to_msecs。",
          "similarity": 0.5157126188278198
        }
      ]
    }
  ]
}