{
  "query": "审计日志与性能监控的关联分析",
  "timestamp": "2025-12-26 01:39:23",
  "retrieved_files": [
    {
      "source_file": "kernel/audit_tree.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:51:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit_tree.c`\n\n---\n\n# audit_tree.c 技术文档\n\n## 1. 文件概述\n\n`audit_tree.c` 是 Linux 内核审计子系统中用于实现**目录树监控**（audit tree watching）的核心模块。该文件提供了对整个目录树（而不仅仅是单个 inode）进行审计监控的能力，通过将审计规则与目录路径关联，并在文件系统事件（如创建、删除、重命名等）发生时高效匹配规则。其核心机制基于 `fsnotify` 框架，在 inode 级别挂载通知标记（mark），并通过引用计数、RCU（Read-Copy-Update）和哈希表等技术保证高并发下的安全性和性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct audit_tree`**  \n  表示一个被监控的目录树。包含路径名、引用计数、关联的规则列表、关联的 chunk 列表等。\n  \n- **`struct audit_chunk`**  \n  表示与一个或多个 inode 关联的监控单元。每个 chunk 通过 `fsnotify_mark` 附加到 inode 上，并维护多个 `audit_tree` 的所有者关系（`owners[]` 数组）。\n\n- **`struct audit_tree_mark`**  \n  封装 `fsnotify_mark`，作为 chunk 与 inode 之间的桥梁，属于 `fsnotify` 框架的扩展标记类型。\n\n- **`struct audit_node`**  \n  嵌入在 `audit_chunk` 中，表示 chunk 与某个 `audit_tree` 的关联关系，包含 owner 指针和索引。\n\n### 主要函数\n\n- **`alloc_tree(const char *s)`**  \n  分配并初始化一个新的 `audit_tree` 实例。\n\n- **`get_tree()` / `put_tree()`**  \n  对 `audit_tree` 进行引用计数管理，`put_tree` 在引用归零时使用 RCU 安全释放。\n\n- **`audit_tree_lookup(const struct inode *inode)`**  \n  在 RCU 读临界区内，根据 inode 查找对应的 `audit_chunk`，并增加其引用计数。\n\n- **`audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)`**  \n  检查给定 chunk 是否属于指定的 audit tree。\n\n- **`alloc_chunk(int count)`**  \n  分配包含指定数量 `audit_node` 的 chunk。\n\n- **`insert_hash(struct audit_chunk *chunk)`**  \n  将 chunk 插入全局哈希表，用于快速查找。\n\n- **`audit_mark_put_chunk()` / `audit_put_chunk()`**  \n  安全释放 chunk 的引用，结合 RCU 机制确保并发安全。\n\n- **`replace_mark_chunk()` / `replace_chunk()`**  \n  在标记或 chunk 更新时进行原子替换（代码片段中 `replace_chunk` 未完整）。\n\n## 3. 关键实现\n\n### 哈希与查找机制\n- 使用 `inode->i_fsnotify_marks` 的地址作为哈希键（`inode_to_key`），确保每个 inode 对应唯一键。\n- 全局哈希表 `chunk_hash_heads[HASH_SIZE]`（大小为 128）配合 `hash_lock` 自旋锁保护写操作。\n- 查找操作（`audit_tree_lookup`）在 RCU 读锁下进行，通过 `READ_ONCE()` 和 `smp_wmb()` 保证内存可见性。\n\n### 引用计数与生命周期管理\n- `audit_tree` 使用 `refcount_t` 管理引用，来源包括：关联的审计规则、chunk 中的 owner 引用。\n- `audit_chunk` 使用 `atomic_long_t refs`，其中一份引用由 `fsnotify_mark` 持有。\n- 所有释放操作均通过 RCU（`call_rcu` / `kfree_rcu`）延迟执行，确保并发读取安全。\n\n### 与 fsnotify 集成\n- 每个被监控的 inode 通过 `audit_tree_mark`（继承 `fsnotify_mark`）关联一个 `audit_chunk`。\n- 当 inode 被删除或 untag 时，`fsnotify` 框架回调 `audit_tree_destroy_watch` 释放 mark。\n- `mark->mask = FS_IN_IGNORED` 表示仅用于内部结构关联，不主动监听事件（实际事件由审计规则触发匹配）。\n\n### 循环链表组织\n- `tree->chunks`：链接所有包含该 tree 的 chunk 中的 `audit_node.list`。\n- `chunk->trees`：链接所有以该 chunk 为根的 tree 的 `same_root` 链表。\n- `tree->rules`：链接所有引用该 tree 的审计规则。\n- 这些链表分别由 `hash_lock` 或 `audit_filter_mutex` 保护。\n\n### 索引位标记\n- `audit_node.index` 的最高位（MSB）用于标记“可能需要回滚”的临时状态，辅助复杂操作（如树重构）的清理逻辑。\n\n## 4. 依赖关系\n\n- **`<linux/fsnotify_backend.h>`**：依赖 fsnotify 框架实现 inode 级别事件通知和标记管理。\n- **`<linux/namei.h>` / `<linux/mount.h>`**：用于路径解析和挂载点处理（虽未在片段中直接调用，但 audit 树需处理跨挂载点语义）。\n- **`audit.h`**：与审计核心模块交互，提供 `audit_tree_path()` 等接口供规则匹配使用。\n- **`<linux/rcupdate.h>`**：使用 RCU 机制保证并发安全。\n- **`<linux/slab.h>`**：使用 `kmem_cache` 高效分配 `audit_tree_mark` 对象。\n\n## 5. 使用场景\n\n- **审计规则匹配**：当用户通过 `auditctl` 添加 `-w /path/to/dir -p wa -k key` 类型规则时，内核将 `/path/to/dir` 注册为 `audit_tree`。\n- **路径遍历监控**：在 `audit_inode()` 和 `audit_inode_child()` 中，内核收集路径上所有 inode 对应的 `audit_chunk`，用于后续与 `AUDIT_TREE` 类型规则匹配。\n- **动态目录结构变更**：当目录树内发生文件创建、删除、重命名或 inode 删除时，通过 fsnotify 机制触发 chunk 更新或 prune（修剪）操作，由专用内核线程 `prune_thread` 处理延迟清理。\n- **资源回收**：当审计规则被删除或监控目录被移除时，相关 `audit_tree` 和 `audit_chunk` 通过引用计数和 RCU 安全释放，避免内存泄漏。",
      "similarity": 0.6080656051635742,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/audit_tree.c",
          "start_line": 458,
          "end_line": 560,
          "content": [
            "static int tag_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk, *old;",
            "\tstruct audit_node *p;",
            "\tint n;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\tmark = fsnotify_find_inode_mark(inode, audit_tree_group);",
            "\tif (!mark)",
            "\t\treturn create_chunk(inode, tree);",
            "",
            "\t/*",
            "\t * Found mark is guaranteed to be attached and mark_mutex protects mark",
            "\t * from getting detached and thus it makes sure there is chunk attached",
            "\t * to the mark.",
            "\t */",
            "\t/* are we already there? */",
            "\tspin_lock(&hash_lock);",
            "\told = mark_chunk(mark);",
            "\tfor (n = 0; n < old->count; n++) {",
            "\t\tif (old->owners[n].owner == tree) {",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\t\tfsnotify_put_mark(mark);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "",
            "\tchunk = alloc_chunk(old->count + 1);",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\tp = &chunk->owners[chunk->count - 1];",
            "\tp->index = (chunk->count - 1) | (1U<<31);",
            "\tp->owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&p->list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(chunk, old);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\tfsnotify_put_mark(mark); /* pair to fsnotify_find_mark */",
            "\taudit_mark_put_chunk(old);",
            "",
            "\treturn 0;",
            "}",
            "static void audit_tree_log_remove_rule(struct audit_context *context,",
            "\t\t\t\t       struct audit_krule *rule)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CONFIG_CHANGE);",
            "\tif (unlikely(!ab))",
            "\t\treturn;",
            "\taudit_log_format(ab, \"op=remove_rule dir=\");",
            "\taudit_log_untrustedstring(ab, rule->tree->pathname);",
            "\taudit_log_key(ab, rule->filterkey);",
            "\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);",
            "\taudit_log_end(ab);",
            "}",
            "static void kill_rules(struct audit_context *context, struct audit_tree *tree)",
            "{",
            "\tstruct audit_krule *rule, *next;",
            "\tstruct audit_entry *entry;",
            "",
            "\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {",
            "\t\tentry = container_of(rule, struct audit_entry, rule);",
            "",
            "\t\tlist_del_init(&rule->rlist);",
            "\t\tif (rule->tree) {",
            "\t\t\t/* not a half-baked one */",
            "\t\t\taudit_tree_log_remove_rule(context, rule);",
            "\t\t\tif (entry->rule.exe)",
            "\t\t\t\taudit_remove_mark(entry->rule.exe);",
            "\t\t\trule->tree = NULL;",
            "\t\t\tlist_del_rcu(&entry->list);",
            "\t\t\tlist_del(&entry->rule.list);",
            "\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "tag_chunk, audit_tree_log_remove_rule, kill_rules",
          "description": "负责规则绑定和解绑操作，包含标记chunk的关联建立与断开。通过日志记录规则变更，触发清理流程，确保审计规则与文件系统事件的动态同步。",
          "similarity": 0.6526577472686768
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/audit_tree.c",
          "start_line": 569,
          "end_line": 709,
          "content": [
            "static void prune_tree_chunks(struct audit_tree *victim, bool tagged)",
            "{",
            "\tspin_lock(&hash_lock);",
            "\twhile (!list_empty(&victim->chunks)) {",
            "\t\tstruct audit_node *p;",
            "\t\tstruct audit_chunk *chunk;",
            "\t\tstruct fsnotify_mark *mark;",
            "",
            "\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);",
            "\t\t/* have we run out of marked? */",
            "\t\tif (tagged && !(p->index & (1U<<31)))",
            "\t\t\tbreak;",
            "\t\tchunk = find_chunk(p);",
            "\t\tmark = chunk->mark;",
            "\t\tremove_chunk_node(chunk, p);",
            "\t\t/* Racing with audit_tree_freeing_mark()? */",
            "\t\tif (!mark)",
            "\t\t\tcontinue;",
            "\t\tfsnotify_get_mark(mark);",
            "\t\tspin_unlock(&hash_lock);",
            "",
            "\t\tuntag_chunk(chunk, mark);",
            "\t\tfsnotify_put_mark(mark);",
            "",
            "\t\tspin_lock(&hash_lock);",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "}",
            "static void prune_one(struct audit_tree *victim)",
            "{",
            "\tprune_tree_chunks(victim, false);",
            "\tput_tree(victim);",
            "}",
            "static void trim_marked(struct audit_tree *tree)",
            "{",
            "\tstruct list_head *p, *q;",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\treturn;",
            "\t}",
            "\t/* reorder */",
            "\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {",
            "\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);",
            "\t\tq = p->next;",
            "\t\tif (node->index & (1U<<31)) {",
            "\t\t\tlist_del_init(p);",
            "\t\t\tlist_add(p, &tree->chunks);",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "",
            "\tprune_tree_chunks(tree, true);",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (!tree->root && !tree->goner) {",
            "\t\ttree->goner = 1;",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t\tkill_rules(audit_context(), tree);",
            "\t\tlist_del_init(&tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\tprune_one(tree);",
            "\t} else {",
            "\t\tspin_unlock(&hash_lock);",
            "\t}",
            "}",
            "int audit_remove_tree_rule(struct audit_krule *rule)",
            "{",
            "\tstruct audit_tree *tree;",
            "\ttree = rule->tree;",
            "\tif (tree) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&rule->rlist);",
            "\t\tif (list_empty(&tree->rules) && !tree->goner) {",
            "\t\t\ttree->root = NULL;",
            "\t\t\tlist_del_init(&tree->same_root);",
            "\t\t\ttree->goner = 1;",
            "\t\t\tlist_move(&tree->list, &prune_list);",
            "\t\t\trule->tree = NULL;",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t\taudit_schedule_prune();",
            "\t\t\treturn 1;",
            "\t\t}",
            "\t\trule->tree = NULL;",
            "\t\tspin_unlock(&hash_lock);",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "void audit_trim_trees(void)",
            "{",
            "\tstruct list_head cursor;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_add(&cursor, &tree_list);",
            "\twhile (cursor.next != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "\t\tstruct path path;",
            "\t\tstruct audit_node *node;",
            "\t\tstruct path *paths;",
            "\t\tstruct path array[16];",
            "\t\tint err;",
            "",
            "\t\ttree = container_of(cursor.next, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&cursor, &tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\terr = kern_path(tree->pathname, 0, &path);",
            "\t\tif (err)",
            "\t\t\tgoto skip_it;",
            "",
            "\t\tpaths = collect_paths(&path, array, 16);",
            "\t\tpath_put(&path);",
            "\t\tif (IS_ERR(paths))",
            "\t\t\tgoto skip_it;",
            "",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_for_each_entry(node, &tree->chunks, list) {",
            "\t\t\tstruct audit_chunk *chunk = find_chunk(node);",
            "\t\t\t/* this could be NULL if the watch is dying else where... */",
            "\t\t\tnode->index |= 1U<<31;",
            "\t\t\tfor (struct path *p = paths; p->dentry; p++) {",
            "\t\t\t\tstruct inode *inode = p->dentry->d_inode;",
            "\t\t\t\tif (inode_to_key(inode) == chunk->key) {",
            "\t\t\t\t\tnode->index &= ~(1U<<31);",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock(&hash_lock);",
            "\t\ttrim_marked(tree);",
            "\t\tdrop_collected_paths(paths, array);",
            "skip_it:",
            "\t\tput_tree(tree);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "\tlist_del(&cursor);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "}"
          ],
          "function_name": "prune_tree_chunks, prune_one, trim_marked, audit_remove_tree_rule, audit_trim_trees",
          "description": "实现审计树的周期性清理机制，扫描并移除冗余chunk，通过标记位判断是否保留。结合路径收集和哈希表遍历，确保审计数据及时回收，防止内存泄露和性能下降。",
          "similarity": 0.6442438364028931
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/audit_tree.c",
          "start_line": 325,
          "end_line": 451,
          "content": [
            "static void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)",
            "{",
            "\tstruct audit_tree *owner = p->owner;",
            "",
            "\tif (owner->root == chunk) {",
            "\t\tlist_del_init(&owner->same_root);",
            "\t\towner->root = NULL;",
            "\t}",
            "\tlist_del_init(&p->list);",
            "\tp->owner = NULL;",
            "\tput_tree(owner);",
            "}",
            "static int chunk_count_trees(struct audit_chunk *chunk)",
            "{",
            "\tint i;",
            "\tint ret = 0;",
            "",
            "\tfor (i = 0; i < chunk->count; i++)",
            "\t\tif (chunk->owners[i].owner)",
            "\t\t\tret++;",
            "\treturn ret;",
            "}",
            "static void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)",
            "{",
            "\tstruct audit_chunk *new;",
            "\tint size;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\t/*",
            "\t * mark_mutex stabilizes chunk attached to the mark so we can check",
            "\t * whether it didn't change while we've dropped hash_lock.",
            "\t */",
            "\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||",
            "\t    mark_chunk(mark) != chunk)",
            "\t\tgoto out_mutex;",
            "",
            "\tsize = chunk_count_trees(chunk);",
            "\tif (!size) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&chunk->trees);",
            "\t\tlist_del_rcu(&chunk->hash);",
            "\t\treplace_mark_chunk(mark, NULL);",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\taudit_mark_put_chunk(chunk);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\treturn;",
            "\t}",
            "",
            "\tnew = alloc_chunk(size);",
            "\tif (!new)",
            "\t\tgoto out_mutex;",
            "",
            "\tspin_lock(&hash_lock);",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(new, chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\taudit_mark_put_chunk(chunk);",
            "\treturn;",
            "",
            "out_mutex:",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "}",
            "static int create_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk = alloc_chunk(1);",
            "",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tmark = alloc_mark();",
            "\tif (!mark) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\treplace_mark_chunk(mark, chunk);",
            "\tchunk->owners[0].index = (1U << 31);",
            "\tchunk->owners[0].owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&chunk->owners[0].list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\tchunk->key = inode_to_key(inode);",
            "\t/*",
            "\t * Inserting into the hash table has to go last as once we do that RCU",
            "\t * readers can see the chunk.",
            "\t */",
            "\tinsert_hash(chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\t/*",
            "\t * Drop our initial reference. When mark we point to is getting freed,",
            "\t * we get notification through ->freeing_mark callback and cleanup",
            "\t * chunk pointing to this mark.",
            "\t */",
            "\tfsnotify_put_mark(mark);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "remove_chunk_node, chunk_count_trees, untag_chunk, create_chunk",
          "description": "实现文件节点标记的增删改查逻辑，包含chunk创建、旧chunk清理及哈希表更新。通过锁保护确保操作原子性，处理标记失效场景并释放无效资源，维持审计系统状态有效性。",
          "similarity": 0.6025954484939575
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/audit_tree.c",
          "start_line": 1,
          "end_line": 110,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include \"audit.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/refcount.h>",
            "#include <linux/slab.h>",
            "",
            "struct audit_tree;",
            "struct audit_chunk;",
            "",
            "struct audit_tree {",
            "\trefcount_t count;",
            "\tint goner;",
            "\tstruct audit_chunk *root;",
            "\tstruct list_head chunks;",
            "\tstruct list_head rules;",
            "\tstruct list_head list;",
            "\tstruct list_head same_root;",
            "\tstruct rcu_head head;",
            "\tchar pathname[];",
            "};",
            "",
            "struct audit_chunk {",
            "\tstruct list_head hash;",
            "\tunsigned long key;",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct list_head trees;\t\t/* with root here */",
            "\tint count;",
            "\tatomic_long_t refs;",
            "\tstruct rcu_head head;",
            "\tstruct audit_node {",
            "\t\tstruct list_head list;",
            "\t\tstruct audit_tree *owner;",
            "\t\tunsigned index;\t\t/* index; upper bit indicates 'will prune' */",
            "\t} owners[];",
            "};",
            "",
            "struct audit_tree_mark {",
            "\tstruct fsnotify_mark mark;",
            "\tstruct audit_chunk *chunk;",
            "};",
            "",
            "static LIST_HEAD(tree_list);",
            "static LIST_HEAD(prune_list);",
            "static struct task_struct *prune_thread;",
            "",
            "/*",
            " * One struct chunk is attached to each inode of interest through",
            " * audit_tree_mark (fsnotify mark). We replace struct chunk on tagging /",
            " * untagging, the mark is stable as long as there is chunk attached. The",
            " * association between mark and chunk is protected by hash_lock and",
            " * audit_tree_group->mark_mutex. Thus as long as we hold",
            " * audit_tree_group->mark_mutex and check that the mark is alive by",
            " * FSNOTIFY_MARK_FLAG_ATTACHED flag check, we are sure the mark points to",
            " * the current chunk.",
            " *",
            " * Rules have pointer to struct audit_tree.",
            " * Rules have struct list_head rlist forming a list of rules over",
            " * the same tree.",
            " * References to struct chunk are collected at audit_inode{,_child}()",
            " * time and used in AUDIT_TREE rule matching.",
            " * These references are dropped at the same time we are calling",
            " * audit_free_names(), etc.",
            " *",
            " * Cyclic lists galore:",
            " * tree.chunks anchors chunk.owners[].list\t\t\thash_lock",
            " * tree.rules anchors rule.rlist\t\t\t\taudit_filter_mutex",
            " * chunk.trees anchors tree.same_root\t\t\t\thash_lock",
            " * chunk.hash is a hash with middle bits of watch.inode as",
            " * a hash function.\t\t\t\t\t\tRCU, hash_lock",
            " *",
            " * tree is refcounted; one reference for \"some rules on rules_list refer to",
            " * it\", one for each chunk with pointer to it.",
            " *",
            " * chunk is refcounted by embedded .refs. Mark associated with the chunk holds",
            " * one chunk reference. This reference is dropped either when a mark is going",
            " * to be freed (corresponding inode goes away) or when chunk attached to the",
            " * mark gets replaced. This reference must be dropped using",
            " * audit_mark_put_chunk() to make sure the reference is dropped only after RCU",
            " * grace period as it protects RCU readers of the hash table.",
            " *",
            " * node.index allows to get from node.list to containing chunk.",
            " * MSB of that sucker is stolen to mark taggings that we might have to",
            " * revert - several operations have very unpleasant cleanup logics and",
            " * that makes a difference.  Some.",
            " */",
            "",
            "static struct fsnotify_group *audit_tree_group __ro_after_init;",
            "static struct kmem_cache *audit_tree_mark_cachep __ro_after_init;",
            "",
            "static struct audit_tree *alloc_tree(const char *s)",
            "{",
            "\tstruct audit_tree *tree;",
            "",
            "\ttree = kmalloc(struct_size(tree, pathname, strlen(s) + 1), GFP_KERNEL);",
            "\tif (tree) {",
            "\t\trefcount_set(&tree->count, 1);",
            "\t\ttree->goner = 0;",
            "\t\tINIT_LIST_HEAD(&tree->chunks);",
            "\t\tINIT_LIST_HEAD(&tree->rules);",
            "\t\tINIT_LIST_HEAD(&tree->list);",
            "\t\tINIT_LIST_HEAD(&tree->same_root);",
            "\t\ttree->root = NULL;",
            "\t\tstrcpy(tree->pathname, s);",
            "\t}",
            "\treturn tree;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了审计树和chunk的数据结构，用于跟踪文件系统事件。audit_tree包含规则列表和路径名，audit_chunk管理与文件节点的关联。全局变量和辅助函数用于初始化、引用计数及哈希表操作，支持审计规则匹配和事件追踪。",
          "similarity": 0.5922267436981201
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/audit_tree.c",
          "start_line": 874,
          "end_line": 993,
          "content": [
            "int audit_tag_tree(char *old, char *new)",
            "{",
            "\tstruct list_head cursor, barrier;",
            "\tint failed = 0;",
            "\tstruct path path1, path2;",
            "\tstruct path array[16];",
            "\tstruct path *paths;",
            "\tint err;",
            "",
            "\terr = kern_path(new, 0, &path2);",
            "\tif (err)",
            "\t\treturn err;",
            "\tpaths = collect_paths(&path2, array, 16);",
            "\tpath_put(&path2);",
            "\tif (IS_ERR(paths))",
            "\t\treturn PTR_ERR(paths);",
            "",
            "\terr = kern_path(old, 0, &path1);",
            "\tif (err) {",
            "\t\tdrop_collected_paths(paths, array);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_add(&barrier, &tree_list);",
            "\tlist_add(&cursor, &barrier);",
            "",
            "\twhile (cursor.next != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "\t\tint good_one = 0;",
            "",
            "\t\ttree = container_of(cursor.next, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&cursor, &tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\terr = kern_path(tree->pathname, 0, &path2);",
            "\t\tif (!err) {",
            "\t\t\tgood_one = path_is_under(&path1, &path2);",
            "\t\t\tpath_put(&path2);",
            "\t\t}",
            "",
            "\t\tif (!good_one) {",
            "\t\t\tput_tree(tree);",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfailed = tag_mounts(paths, tree);",
            "\t\tif (failed) {",
            "\t\t\tput_tree(tree);",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t\tspin_lock(&hash_lock);",
            "\t\tif (!tree->goner) {",
            "\t\t\tlist_move(&tree->list, &tree_list);",
            "\t\t}",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tput_tree(tree);",
            "\t}",
            "",
            "\twhile (barrier.prev != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "",
            "\t\ttree = container_of(barrier.prev, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&tree->list, &barrier);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\tif (!failed) {",
            "\t\t\tstruct audit_node *node;",
            "\t\t\tspin_lock(&hash_lock);",
            "\t\t\tlist_for_each_entry(node, &tree->chunks, list)",
            "\t\t\t\tnode->index &= ~(1U<<31);",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t} else {",
            "\t\t\ttrim_marked(tree);",
            "\t\t}",
            "",
            "\t\tput_tree(tree);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "\tlist_del(&barrier);",
            "\tlist_del(&cursor);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\tpath_put(&path1);",
            "\tdrop_collected_paths(paths, array);",
            "\treturn failed;",
            "}",
            "static void audit_schedule_prune(void)",
            "{",
            "\twake_up_process(prune_thread);",
            "}",
            "void audit_kill_trees(struct audit_context *context)",
            "{",
            "\tstruct list_head *list = &context->killed_trees;",
            "",
            "\taudit_ctl_lock();",
            "\tmutex_lock(&audit_filter_mutex);",
            "",
            "\twhile (!list_empty(list)) {",
            "\t\tstruct audit_tree *victim;",
            "",
            "\t\tvictim = list_entry(list->next, struct audit_tree, list);",
            "\t\tkill_rules(context, victim);",
            "\t\tlist_del_init(&victim->list);",
            "",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\tprune_one(victim);",
            "",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\taudit_ctl_unlock();",
            "}"
          ],
          "function_name": "audit_tag_tree, audit_schedule_prune, audit_kill_trees",
          "description": "提供审计树状态同步与清理机制，audit_tag_tree用于路径变更时同步树结构，audit_schedule_prune唤醒修剪线程，audit_kill_trees处理上下文中被终止的审计树，通过互斥锁保护并发访问并执行规则清理。",
          "similarity": 0.5869085788726807
        }
      ]
    },
    {
      "source_file": "kernel/audit_watch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:52:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit_watch.c`\n\n---\n\n# audit_watch.c 技术文档\n\n## 1. 文件概述\n\n`audit_watch.c` 是 Linux 内核审计子系统（Audit Subsystem）中用于实现文件路径监控的核心模块。该文件通过与 `fsnotify` 机制集成，实现对指定路径的动态 inode 监控。当被监控的文件或目录发生创建、删除、移动或卸载等事件时，审计系统能够自动更新规则中关联的 inode 信息，确保审计规则持续有效。该机制解决了传统基于路径的监控在文件系统结构变化时失效的问题。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct audit_watch`**  \n  表示一个审计监控项，包含：\n  - `count`：引用计数\n  - `dev` / `ino`：关联的设备号和 inode 号（初始为未设置状态）\n  - `path`：原始监控路径字符串\n  - `parent`：指向所属父目录的 `audit_parent` 结构\n  - `wlist`：挂载到父目录监控列表的链表节点\n  - `rules`：关联的审计规则链表头\n\n- **`struct audit_parent`**  \n  表示被监控路径的父目录，包含：\n  - `watches`：该父目录下所有 `audit_watch` 的链表头\n  - `mark`：嵌入的 `fsnotify_mark`，用于注册到 VFS 通知系统\n\n### 主要函数\n\n- **`audit_to_watch()`**  \n  将用户空间传入的路径字符串转换为内核 `audit_watch` 对象，并绑定到审计规则\n\n- **`audit_init_watch()` / `audit_init_parent()`**  \n  初始化 `audit_watch` 和 `audit_parent` 结构\n\n- **`audit_dupe_watch()`**  \n  复制监控项（用于 inode 变更时的规则更新）\n\n- **`audit_update_watch()`**  \n  核心回调函数，处理文件系统事件（如重命名、删除）并更新所有关联规则的 inode 信息\n\n- **`audit_watch_compare()`**  \n  比较监控项与给定 inode/dev 是否匹配\n\n- **`audit_get_watch()` / `audit_put_watch()`**  \n  引用计数管理接口\n\n- **`audit_remove_watch()`**  \n  从父目录监控列表中移除监控项\n\n## 3. 关键实现\n\n### 引用计数机制\n- **`audit_watch`**：使用 `refcount_t` 管理生命周期，每个关联的审计规则持有引用\n- **`audit_parent`**：通过 `fsnotify_mark` 的引用计数管理，每个子监控项持有父目录引用\n\n### fsnotify 集成\n- 创建专用 `fsnotify_group` (`audit_watch_group`)\n- 监控事件类型：`FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF | FS_MOVE_SELF | FS_UNMOUNT`\n- 通过 `fsnotify_add_inode_mark()` 在父目录 inode 上注册监控标记\n\n### 动态 inode 更新流程\n1. 文件系统事件触发 `audit_update_watch()` 回调\n2. 根据事件中的 dentry 名称匹配对应 `audit_watch`\n3. 创建新 `audit_watch` 副本并更新 inode/dev 信息\n4. 遍历原监控项关联的所有规则：\n   - 从旧 inode 哈希表移除规则\n   - 创建规则副本并绑定到新监控项\n   - 插入新 inode 对应的哈希表\n5. 记录配置变更日志（`AUDIT_CONFIG_CHANGE`）\n\n### 路径解析策略\n- 仅支持绝对路径（以 `/` 开头）\n- 不支持目录路径（路径末尾不能为 `/`）\n- 仅允许用于 `AUDIT_FILTER_EXIT` 和 `AUDIT_FILTER_URING_EXIT` 规则类型\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `fsnotify` 子系统（`<linux/fsnotify_backend.h>`）：提供文件系统事件通知\n  - 审计核心模块（`audit.h`）：规则管理、日志记录、哈希表操作\n  - VFS 层（`<linux/fs.h>`, `<linux/namei.h>`）：inode/dentry 操作\n\n- **关键交互**：\n  - 通过 `audit_filter_mutex` 与审计规则管理模块同步\n  - 调用 `audit_filter_inodes()` 确保事件发生时的审计记录完整性\n  - 使用 `audit_inode_hash` 哈希表管理基于 inode 的规则索引\n\n## 5. 使用场景\n\n1. **审计规则动态维护**  \n   当用户通过 `auditctl -w /path/to/file` 添加路径监控时，内核将路径解析为 inode 并注册 fsnotify 监控。后续文件移动/重命名时自动更新规则绑定的 inode。\n\n2. **文件系统事件响应**  \n   处理以下场景：\n   - 文件被移动到监控目录（触发 `FS_CREATE`）\n   - 监控文件被重命名（触发 `FS_MOVE`）\n   - 监控目录被卸载（触发 `FS_UNMOUNT`）\n   - 监控文件被删除（触发 `FS_DELETE`）\n\n3. **审计日志完整性保障**  \n   在 inode 变更过程中，通过 `audit_filter_inodes()` 确保变更期间的系统调用仍能被正确审计，避免监控间隙。\n\n4. **资源生命周期管理**  \n   通过引用计数确保：\n   - 规则存在时监控项不被释放\n   - 父目录无监控项时自动清理 fsnotify 标记\n   - 路径字符串内存的安全回收",
      "similarity": 0.6033862233161926,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/audit_watch.c",
          "start_line": 58,
          "end_line": 218,
          "content": [
            "static void audit_free_parent(struct audit_parent *parent)",
            "{",
            "\tWARN_ON(!list_empty(&parent->watches));",
            "\tkfree(parent);",
            "}",
            "static void audit_watch_free_mark(struct fsnotify_mark *entry)",
            "{",
            "\tstruct audit_parent *parent;",
            "",
            "\tparent = container_of(entry, struct audit_parent, mark);",
            "\taudit_free_parent(parent);",
            "}",
            "static void audit_get_parent(struct audit_parent *parent)",
            "{",
            "\tif (likely(parent))",
            "\t\tfsnotify_get_mark(&parent->mark);",
            "}",
            "static void audit_put_parent(struct audit_parent *parent)",
            "{",
            "\tif (likely(parent))",
            "\t\tfsnotify_put_mark(&parent->mark);",
            "}",
            "void audit_get_watch(struct audit_watch *watch)",
            "{",
            "\trefcount_inc(&watch->count);",
            "}",
            "void audit_put_watch(struct audit_watch *watch)",
            "{",
            "\tif (refcount_dec_and_test(&watch->count)) {",
            "\t\tWARN_ON(watch->parent);",
            "\t\tWARN_ON(!list_empty(&watch->rules));",
            "\t\tkfree(watch->path);",
            "\t\tkfree(watch);",
            "\t}",
            "}",
            "static void audit_remove_watch(struct audit_watch *watch)",
            "{",
            "\tlist_del(&watch->wlist);",
            "\taudit_put_parent(watch->parent);",
            "\twatch->parent = NULL;",
            "\taudit_put_watch(watch); /* match initial get */",
            "}",
            "int audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)",
            "{",
            "\treturn (watch->ino != AUDIT_INO_UNSET) &&",
            "\t\t(watch->ino == ino) &&",
            "\t\t(watch->dev == dev);",
            "}",
            "int audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)",
            "{",
            "\tstruct audit_watch *watch;",
            "",
            "\tif (!audit_watch_group)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tif (path[0] != '/' || path[len-1] == '/' ||",
            "\t    (krule->listnr != AUDIT_FILTER_EXIT &&",
            "\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||",
            "\t    op != Audit_equal ||",
            "\t    krule->inode_f || krule->watch || krule->tree)",
            "\t\treturn -EINVAL;",
            "",
            "\twatch = audit_init_watch(path);",
            "\tif (IS_ERR(watch))",
            "\t\treturn PTR_ERR(watch);",
            "",
            "\tkrule->watch = watch;",
            "",
            "\treturn 0;",
            "}",
            "static void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "\tab = audit_log_start(audit_context(), GFP_NOFS, AUDIT_CONFIG_CHANGE);",
            "\tif (!ab)",
            "\t\treturn;",
            "\taudit_log_session_info(ab);",
            "\taudit_log_format(ab, \"op=%s path=\", op);",
            "\taudit_log_untrustedstring(ab, w->path);",
            "\taudit_log_key(ab, r->filterkey);",
            "\taudit_log_format(ab, \" list=%d res=1\", r->listnr);",
            "\taudit_log_end(ab);",
            "}",
            "static void audit_update_watch(struct audit_parent *parent,",
            "\t\t\t       const struct qstr *dname, dev_t dev,",
            "\t\t\t       unsigned long ino, unsigned invalidating)",
            "{",
            "\tstruct audit_watch *owatch, *nwatch, *nextw;",
            "\tstruct audit_krule *r, *nextr;",
            "\tstruct audit_entry *oentry, *nentry;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\t/* Run all of the watches on this parent looking for the one that",
            "\t * matches the given dname */",
            "\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {",
            "\t\tif (audit_compare_dname_path(dname, owatch->path,",
            "\t\t\t\t\t     AUDIT_NAME_FULL))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* If the update involves invalidating rules, do the inode-based",
            "\t\t * filtering now, so we don't omit records. */",
            "\t\tif (invalidating && !audit_dummy_context())",
            "\t\t\taudit_filter_inodes(current, audit_context());",
            "",
            "\t\t/* updating ino will likely change which audit_hash_list we",
            "\t\t * are on so we need a new watch for the new list */",
            "\t\tnwatch = audit_dupe_watch(owatch);",
            "\t\tif (IS_ERR(nwatch)) {",
            "\t\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\t\taudit_panic(\"error updating watch, skipping\");",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tnwatch->dev = dev;",
            "\t\tnwatch->ino = ino;",
            "",
            "\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {",
            "",
            "\t\t\toentry = container_of(r, struct audit_entry, rule);",
            "\t\t\tlist_del(&oentry->rule.rlist);",
            "\t\t\tlist_del_rcu(&oentry->list);",
            "",
            "\t\t\tnentry = audit_dupe_rule(&oentry->rule);",
            "\t\t\tif (IS_ERR(nentry)) {",
            "\t\t\t\tlist_del(&oentry->rule.list);",
            "\t\t\t\taudit_panic(\"error updating watch, removing\");",
            "\t\t\t} else {",
            "\t\t\t\tint h = audit_hash_ino((u32)ino);",
            "",
            "\t\t\t\t/*",
            "\t\t\t\t * nentry->rule.watch == oentry->rule.watch so",
            "\t\t\t\t * we must drop that reference and set it to our",
            "\t\t\t\t * new watch.",
            "\t\t\t\t */",
            "\t\t\t\taudit_put_watch(nentry->rule.watch);",
            "\t\t\t\taudit_get_watch(nwatch);",
            "\t\t\t\tnentry->rule.watch = nwatch;",
            "\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);",
            "\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);",
            "\t\t\t\tlist_replace(&oentry->rule.list,",
            "\t\t\t\t\t     &nentry->rule.list);",
            "\t\t\t}",
            "\t\t\tif (oentry->rule.exe)",
            "\t\t\t\taudit_remove_mark(oentry->rule.exe);",
            "",
            "\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "",
            "\t\taudit_remove_watch(owatch);",
            "\t\tgoto add_watch_to_parent; /* event applies to a single watch */",
            "\t}",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\treturn;",
            "",
            "add_watch_to_parent:",
            "\tlist_add(&nwatch->wlist, &parent->watches);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\treturn;",
            "}"
          ],
          "function_name": "audit_free_parent, audit_watch_free_mark, audit_get_parent, audit_put_parent, audit_get_watch, audit_put_watch, audit_remove_watch, audit_watch_compare, audit_to_watch, audit_watch_log_rule_change, audit_update_watch",
          "description": "实现了审计监视器的引用计数管理、资源释放逻辑及动态更新机制。包含对监视器与规则的绑定解除、路径匹配判断、以及基于文件系统事件的监视器状态同步等功能。",
          "similarity": 0.6582739353179932
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/audit_watch.c",
          "start_line": 447,
          "end_line": 533,
          "content": [
            "void audit_remove_watch_rule(struct audit_krule *krule)",
            "{",
            "\tstruct audit_watch *watch = krule->watch;",
            "\tstruct audit_parent *parent = watch->parent;",
            "",
            "\tlist_del(&krule->rlist);",
            "",
            "\tif (list_empty(&watch->rules)) {",
            "\t\t/*",
            "\t\t * audit_remove_watch() drops our reference to 'parent' which",
            "\t\t * can get freed. Grab our own reference to be safe.",
            "\t\t */",
            "\t\taudit_get_parent(parent);",
            "\t\taudit_remove_watch(watch);",
            "\t\tif (list_empty(&parent->watches))",
            "\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);",
            "\t\taudit_put_parent(parent);",
            "\t}",
            "}",
            "static int audit_watch_handle_event(struct fsnotify_mark *inode_mark, u32 mask,",
            "\t\t\t\t    struct inode *inode, struct inode *dir,",
            "\t\t\t\t    const struct qstr *dname, u32 cookie)",
            "{",
            "\tstruct audit_parent *parent;",
            "",
            "\tparent = container_of(inode_mark, struct audit_parent, mark);",
            "",
            "\tif (WARN_ON_ONCE(inode_mark->group != audit_watch_group))",
            "\t\treturn 0;",
            "",
            "\tif (mask & (FS_CREATE|FS_MOVED_TO) && inode)",
            "\t\taudit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);",
            "\telse if (mask & (FS_DELETE|FS_MOVED_FROM))",
            "\t\taudit_update_watch(parent, dname, AUDIT_DEV_UNSET, AUDIT_INO_UNSET, 1);",
            "\telse if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))",
            "\t\taudit_remove_parent_watches(parent);",
            "",
            "\treturn 0;",
            "}",
            "static int __init audit_watch_init(void)",
            "{",
            "\taudit_watch_group = fsnotify_alloc_group(&audit_watch_fsnotify_ops, 0);",
            "\tif (IS_ERR(audit_watch_group)) {",
            "\t\taudit_watch_group = NULL;",
            "\t\taudit_panic(\"cannot create audit fsnotify group\");",
            "\t}",
            "\treturn 0;",
            "}",
            "int audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)",
            "{",
            "\tstruct audit_fsnotify_mark *audit_mark;",
            "\tchar *pathname;",
            "",
            "\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);",
            "\tif (!pathname)",
            "\t\treturn -ENOMEM;",
            "",
            "\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));",
            "\tif (IS_ERR(audit_mark)) {",
            "\t\tkfree(pathname);",
            "\t\treturn PTR_ERR(audit_mark);",
            "\t}",
            "\tnew->exe = audit_mark;",
            "",
            "\treturn 0;",
            "}",
            "int audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)",
            "{",
            "\tstruct file *exe_file;",
            "\tunsigned long ino;",
            "\tdev_t dev;",
            "",
            "\t/* only do exe filtering if we are recording @current events/records */",
            "\tif (tsk != current)",
            "\t\treturn 0;",
            "",
            "\tif (!current->mm)",
            "\t\treturn 0;",
            "\texe_file = get_mm_exe_file(current->mm);",
            "\tif (!exe_file)",
            "\t\treturn 0;",
            "\tino = file_inode(exe_file)->i_ino;",
            "\tdev = file_inode(exe_file)->i_sb->s_dev;",
            "\tfput(exe_file);",
            "",
            "\treturn audit_mark_compare(mark, ino, dev);",
            "}"
          ],
          "function_name": "audit_remove_watch_rule, audit_watch_handle_event, audit_watch_init, audit_dupe_exe, audit_exe_compare",
          "description": "实现了文件系统事件监听初始化、事件回调处理及执行文件路径比对功能。包含监视器事件处理入口、审计模块初始化代码，以及用于进程执行文件审计匹配的专用比较函数。",
          "similarity": 0.6195129156112671
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/audit_watch.c",
          "start_line": 322,
          "end_line": 437,
          "content": [
            "static void audit_remove_parent_watches(struct audit_parent *parent)",
            "{",
            "\tstruct audit_watch *w, *nextw;",
            "\tstruct audit_krule *r, *nextr;",
            "\tstruct audit_entry *e;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {",
            "\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {",
            "\t\t\te = container_of(r, struct audit_entry, rule);",
            "\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");",
            "\t\t\tif (e->rule.exe)",
            "\t\t\t\taudit_remove_mark(e->rule.exe);",
            "\t\t\tlist_del(&r->rlist);",
            "\t\t\tlist_del(&r->list);",
            "\t\t\tlist_del_rcu(&e->list);",
            "\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "\t\taudit_remove_watch(w);",
            "\t}",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);",
            "}",
            "static int audit_get_nd(struct audit_watch *watch, struct path *parent)",
            "{",
            "\tstruct dentry *d = kern_path_locked(watch->path, parent);",
            "\tif (IS_ERR(d))",
            "\t\treturn PTR_ERR(d);",
            "\tif (d_is_positive(d)) {",
            "\t\t/* update watch filter fields */",
            "\t\twatch->dev = d->d_sb->s_dev;",
            "\t\twatch->ino = d_backing_inode(d)->i_ino;",
            "\t}",
            "\tinode_unlock(d_backing_inode(parent->dentry));",
            "\tdput(d);",
            "\treturn 0;",
            "}",
            "static void audit_add_to_parent(struct audit_krule *krule,",
            "\t\t\t\tstruct audit_parent *parent)",
            "{",
            "\tstruct audit_watch *w, *watch = krule->watch;",
            "\tint watch_found = 0;",
            "",
            "\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));",
            "",
            "\tlist_for_each_entry(w, &parent->watches, wlist) {",
            "\t\tif (strcmp(watch->path, w->path))",
            "\t\t\tcontinue;",
            "",
            "\t\twatch_found = 1;",
            "",
            "\t\t/* put krule's ref to temporary watch */",
            "\t\taudit_put_watch(watch);",
            "",
            "\t\taudit_get_watch(w);",
            "\t\tkrule->watch = watch = w;",
            "",
            "\t\taudit_put_parent(parent);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tif (!watch_found) {",
            "\t\twatch->parent = parent;",
            "",
            "\t\taudit_get_watch(watch);",
            "\t\tlist_add(&watch->wlist, &parent->watches);",
            "\t}",
            "\tlist_add(&krule->rlist, &watch->rules);",
            "}",
            "int audit_add_watch(struct audit_krule *krule, struct list_head **list)",
            "{",
            "\tstruct audit_watch *watch = krule->watch;",
            "\tstruct audit_parent *parent;",
            "\tstruct path parent_path;",
            "\tint h, ret = 0;",
            "",
            "\t/*",
            "\t * When we will be calling audit_add_to_parent, krule->watch might have",
            "\t * been updated and watch might have been freed.",
            "\t * So we need to keep a reference of watch.",
            "\t */",
            "\taudit_get_watch(watch);",
            "",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t/* Avoid calling path_lookup under audit_filter_mutex. */",
            "\tret = audit_get_nd(watch, &parent_path);",
            "",
            "\t/* caller expects mutex locked */",
            "\tmutex_lock(&audit_filter_mutex);",
            "",
            "\tif (ret) {",
            "\t\taudit_put_watch(watch);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/* either find an old parent or attach a new one */",
            "\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));",
            "\tif (!parent) {",
            "\t\tparent = audit_init_parent(&parent_path);",
            "\t\tif (IS_ERR(parent)) {",
            "\t\t\tret = PTR_ERR(parent);",
            "\t\t\tgoto error;",
            "\t\t}",
            "\t}",
            "",
            "\taudit_add_to_parent(krule, parent);",
            "",
            "\th = audit_hash_ino((u32)watch->ino);",
            "\t*list = &audit_inode_hash[h];",
            "error:",
            "\tpath_put(&parent_path);",
            "\taudit_put_watch(watch);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "audit_remove_parent_watches, audit_get_nd, audit_add_to_parent, audit_add_watch",
          "description": "提供了将审计规则附加到文件系统路径的实现，包含路径解析、现有监视器查找替换逻辑，以及根据文件系统变更事件更新审计规则的机制。",
          "similarity": 0.601433515548706
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/audit_watch.c",
          "start_line": 1,
          "end_line": 57,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* audit_watch.c -- watching inodes",
            " *",
            " * Copyright 2003-2009 Red Hat, Inc.",
            " * Copyright 2005 Hewlett-Packard Development Company, L.P.",
            " * Copyright 2005 IBM Corporation",
            " */",
            "",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/audit.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/namei.h>",
            "#include <linux/netlink.h>",
            "#include <linux/refcount.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include \"audit.h\"",
            "",
            "/*",
            " * Reference counting:",
            " *",
            " * audit_parent: lifetime is from audit_init_parent() to receipt of an FS_IGNORED",
            " * \tevent.  Each audit_watch holds a reference to its associated parent.",
            " *",
            " * audit_watch: if added to lists, lifetime is from audit_init_watch() to",
            " * \taudit_remove_watch().  Additionally, an audit_watch may exist",
            " * \ttemporarily to assist in searching existing filter data.  Each",
            " * \taudit_krule holds a reference to its associated watch.",
            " */",
            "",
            "struct audit_watch {",
            "\trefcount_t\t\tcount;\t/* reference count */",
            "\tdev_t\t\t\tdev;\t/* associated superblock device */",
            "\tchar\t\t\t*path;\t/* insertion path */",
            "\tunsigned long\t\tino;\t/* associated inode number */",
            "\tstruct audit_parent\t*parent; /* associated parent */",
            "\tstruct list_head\twlist;\t/* entry in parent->watches list */",
            "\tstruct list_head\trules;\t/* anchor for krule->rlist */",
            "};",
            "",
            "struct audit_parent {",
            "\tstruct list_head\twatches; /* anchor for audit_watch->wlist */",
            "\tstruct fsnotify_mark mark; /* fsnotify mark on the inode */",
            "};",
            "",
            "/* fsnotify handle. */",
            "static struct fsnotify_group *audit_watch_group;",
            "",
            "/* fsnotify events we care about. */",
            "#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\",
            "\t\t\tFS_MOVE_SELF | FS_UNMOUNT)",
            ""
          ],
          "function_name": null,
          "description": "定义了audit_watch和audit_parent结构体，用于跟踪被审计的文件系统对象及其关联的监视器。声明了全局的fsnotify组用于文件系统事件通知，并定义了用于匹配文件系统事件的位掩码AUDIT_FS_WATCH。",
          "similarity": 0.5612983107566833
        }
      ]
    },
    {
      "source_file": "kernel/auditsc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:53:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `auditsc.c`\n\n---\n\n# auditsc.c 技术文档\n\n## 1. 文件概述\n\n`auditsc.c` 是 Linux 内核审计子系统的核心组件之一，专门负责**系统调用级别的审计功能**。该文件实现了系统调用进入和退出时的审计数据收集、过滤规则匹配、辅助数据管理以及与 LSM（Linux Security Module）安全模块的集成。它为内核审计框架提供了系统调用上下文的完整记录能力，支持对文件操作、网络配置、进程执行等关键系统行为进行细粒度监控和日志记录。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`audit_aux_data`**: 审计辅助数据的通用基类，用于链式存储额外的审计信息\n- **`audit_aux_data_pids`**: 存储目标进程相关信息（PID、UID、会话ID、安全上下文等），最多支持16个目标进程\n- **`audit_aux_data_bprm_fcaps`**: 记录可执行文件能力（capabilities）变更信息，包括文件能力、旧进程能力和新进程能力\n- **`audit_tree_refs`**: 用于管理文件系统审计树（audit tree）引用的链表结构，每个节点包含31个`audit_chunk`指针\n- **`audit_nfcfgop_tab`**: 网络过滤配置操作的枚举到字符串映射表，支持 iptables 和 nftables 操作审计\n\n### 关键函数\n\n- **`audit_match_perm()`**: 根据系统调用类型和访问模式（读/写/属性/执行）匹配审计权限过滤规则\n- **`audit_match_filetype()`**: 匹配审计上下文中文件的类型（如普通文件、目录、设备文件等）\n- **`audit_set_auditable()`**: 将审计上下文标记为可审计状态，设置优先级和记录状态\n- **`put_tree_ref()` / `grow_tree_refs()` / `unroll_tree_refs()`**: 管理审计树引用的动态分配和释放\n\n### 全局变量\n\n- **`audit_n_rules`**: 当前系统中审计规则的总数\n- **`audit_signals`**: 控制是否收集信号发送相关的审计数据\n\n## 3. 关键实现\n\n### 系统调用分类与权限匹配\n\n`audit_match_perm()` 函数实现了复杂的系统调用分类逻辑：\n- **原生系统调用**（`AUDITSC_NATIVE`）：通过预定义的系统调用类（`AUDIT_CLASS_WRITE`、`AUDIT_CLASS_READ` 等）进行匹配\n- **兼容模式系统调用**（`AUDITSC_COMPAT`）：针对32位兼容层的特殊处理\n- **特殊系统调用处理**：\n  - `open`/`openat`：直接从参数中提取访问模式\n  - `openat2`：从 `struct open_how` 的 flags 字段解析访问模式\n  - `socketcall`：特殊处理 `SYS_BIND` 操作\n  - `execve`：匹配执行权限\n\n### 审计树引用管理\n\n采用**固定大小数组链表**的设计模式管理 `audit_chunk` 引用：\n- 每个 `audit_tree_refs` 节点包含31个指针槽位\n- 初始状态为 `(NULL, NULL, 0)`，首次分配后变为 `(p, p, 31)`\n- 通过 `tree_count` 跟踪当前节点的可用槽位数\n- 不支持收缩，仅在上下文释放时统一清理\n\n### 辅助数据扩展机制\n\n通过**继承式链表设计**支持多种辅助数据类型：\n- 所有辅助数据结构都以 `audit_aux_data` 作为第一个成员\n- 通过 `type` 字段区分不同类型的数据\n- 支持动态添加新的辅助数据类型而无需修改核心逻辑\n\n### 网络配置审计支持\n\n内置对现代网络过滤框架的完整支持：\n- **iptables**（`xt_*` 操作）\n- **nftables**（`nft_*` 操作，包括表、链、规则、集合、对象、流表等）\n- 提供操作码到可读字符串的映射，便于用户空间解析\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n\n- **审计核心**：`<linux/audit.h>`、`\"audit.h\"`\n- **系统调用**：`<asm/syscall.h>`、`<linux/syscalls.h>`\n- **安全模块**：`<linux/security.h>`、`<linux/capability.h>`\n- **文件系统**：`<linux/fs.h>`、`<linux/namei.h>`、`<linux/mount.h>`\n- **网络**：`<linux/socket.h>`、`<uapi/linux/netfilter/nf_tables.h>`\n- **进程管理**：`<linux/binfmts.h>`、`<linux/personality.h>`\n\n### 功能依赖\n\n- **审计框架**：依赖 `audit.c` 提供的核心审计功能\n- **LSM 框架**：与 SELinux、Smack 等安全模块集成，支持安全上下文审计\n- **系统调用拦截**：依赖架构特定的系统调用入口/出口钩子（如 `entry.S`）\n- **文件系统通知**：与 `fsnotify` 子系统协作实现文件访问审计\n\n## 5. 使用场景\n\n### 系统调用审计\n\n- **文件操作监控**：记录所有文件创建、删除、重命名、权限修改等操作\n- **进程执行跟踪**：审计 `execve` 系统调用，记录命令行参数和环境变量\n- **网络配置变更**：监控 iptables/nftables 规则的添加、删除、修改\n- **能力变更审计**：跟踪进程能力的获取、丢弃和继承过程\n\n### 安全合规\n\n- **LSPP 认证**：支持主体/客体安全上下文标签审计，满足高安全等级要求\n- **访问控制审计**：记录所有违反 MAC（强制访问控制）策略的访问尝试\n- **特权操作监控**：审计所有涉及 root 权限或特殊能力的系统调用\n\n### 故障诊断与取证\n\n- **系统行为分析**：通过审计日志重建系统调用序列，分析异常行为\n- **安全事件响应**：在安全事件发生后，通过审计记录追踪攻击路径\n- **合规性报告**：生成满足法规要求的系统活动审计报告",
      "similarity": 0.6033312082290649,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/auditsc.c",
          "start_line": 1083,
          "end_line": 1295,
          "content": [
            "static inline void audit_free_context(struct audit_context *context)",
            "{",
            "\t/* resetting is extra work, but it is likely just noise */",
            "\taudit_reset_context(context);",
            "\taudit_proctitle_free(context);",
            "\tfree_tree_refs(context);",
            "\tkfree(context->filterkey);",
            "\tkfree(context);",
            "}",
            "static int audit_log_pid_context(struct audit_context *context, pid_t pid,",
            "\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,",
            "\t\t\t\t u32 sid, char *comm)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tchar *ctx = NULL;",
            "\tu32 len;",
            "\tint rc = 0;",
            "",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);",
            "\tif (!ab)",
            "\t\treturn rc;",
            "",
            "\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,",
            "\t\t\t from_kuid(&init_user_ns, auid),",
            "\t\t\t from_kuid(&init_user_ns, uid), sessionid);",
            "\tif (sid) {",
            "\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {",
            "\t\t\taudit_log_format(ab, \" obj=(none)\");",
            "\t\t\trc = 1;",
            "\t\t} else {",
            "\t\t\taudit_log_format(ab, \" obj=%s\", ctx);",
            "\t\t\tsecurity_release_secctx(ctx, len);",
            "\t\t}",
            "\t}",
            "\taudit_log_format(ab, \" ocomm=\");",
            "\taudit_log_untrustedstring(ab, comm);",
            "\taudit_log_end(ab);",
            "",
            "\treturn rc;",
            "}",
            "static void audit_log_execve_info(struct audit_context *context,",
            "\t\t\t\t  struct audit_buffer **ab)",
            "{",
            "\tlong len_max;",
            "\tlong len_rem;",
            "\tlong len_full;",
            "\tlong len_buf;",
            "\tlong len_abuf = 0;",
            "\tlong len_tmp;",
            "\tbool require_data;",
            "\tbool encode;",
            "\tunsigned int iter;",
            "\tunsigned int arg;",
            "\tchar *buf_head;",
            "\tchar *buf;",
            "\tconst char __user *p = (const char __user *)current->mm->arg_start;",
            "",
            "\t/* NOTE: this buffer needs to be large enough to hold all the non-arg",
            "\t *       data we put in the audit record for this argument (see the",
            "\t *       code below) ... at this point in time 96 is plenty */",
            "\tchar abuf[96];",
            "",
            "\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the",
            "\t *       current value of 7500 is not as important as the fact that it",
            "\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle",
            "\t *       room if we go over a little bit in the logging below */",
            "\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);",
            "\tlen_max = MAX_EXECVE_AUDIT_LEN;",
            "",
            "\t/* scratch buffer to hold the userspace args */",
            "\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);",
            "\tif (!buf_head) {",
            "\t\taudit_panic(\"out of memory for argv string\");",
            "\t\treturn;",
            "\t}",
            "\tbuf = buf_head;",
            "",
            "\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);",
            "",
            "\tlen_rem = len_max;",
            "\tlen_buf = 0;",
            "\tlen_full = 0;",
            "\trequire_data = true;",
            "\tencode = false;",
            "\titer = 0;",
            "\targ = 0;",
            "\tdo {",
            "\t\t/* NOTE: we don't ever want to trust this value for anything",
            "\t\t *       serious, but the audit record format insists we",
            "\t\t *       provide an argument length for really long arguments,",
            "\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but",
            "\t\t *       to use strncpy_from_user() to obtain this value for",
            "\t\t *       recording in the log, although we don't use it",
            "\t\t *       anywhere here to avoid a double-fetch problem */",
            "\t\tif (len_full == 0)",
            "\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;",
            "",
            "\t\t/* read more data from userspace */",
            "\t\tif (require_data) {",
            "\t\t\t/* can we make more room in the buffer? */",
            "\t\t\tif (buf != buf_head) {",
            "\t\t\t\tmemmove(buf_head, buf, len_buf);",
            "\t\t\t\tbuf = buf_head;",
            "\t\t\t}",
            "",
            "\t\t\t/* fetch as much as we can of the argument */",
            "\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,",
            "\t\t\t\t\t\t    len_max - len_buf);",
            "\t\t\tif (len_tmp == -EFAULT) {",
            "\t\t\t\t/* unable to copy from userspace */",
            "\t\t\t\tsend_sig(SIGKILL, current, 0);",
            "\t\t\t\tgoto out;",
            "\t\t\t} else if (len_tmp == (len_max - len_buf)) {",
            "\t\t\t\t/* buffer is not large enough */",
            "\t\t\t\trequire_data = true;",
            "\t\t\t\t/* NOTE: if we are going to span multiple",
            "\t\t\t\t *       buffers force the encoding so we stand",
            "\t\t\t\t *       a chance at a sane len_full value and",
            "\t\t\t\t *       consistent record encoding */",
            "\t\t\t\tencode = true;",
            "\t\t\t\tlen_full = len_full * 2;",
            "\t\t\t\tp += len_tmp;",
            "\t\t\t} else {",
            "\t\t\t\trequire_data = false;",
            "\t\t\t\tif (!encode)",
            "\t\t\t\t\tencode = audit_string_contains_control(",
            "\t\t\t\t\t\t\t\tbuf, len_tmp);",
            "\t\t\t\t/* try to use a trusted value for len_full */",
            "\t\t\t\tif (len_full < len_max)",
            "\t\t\t\t\tlen_full = (encode ?",
            "\t\t\t\t\t\t    len_tmp * 2 : len_tmp);",
            "\t\t\t\tp += len_tmp + 1;",
            "\t\t\t}",
            "\t\t\tlen_buf += len_tmp;",
            "\t\t\tbuf_head[len_buf] = '\\0';",
            "",
            "\t\t\t/* length of the buffer in the audit record? */",
            "\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);",
            "\t\t}",
            "",
            "\t\t/* write as much as we can to the audit log */",
            "\t\tif (len_buf >= 0) {",
            "\t\t\t/* NOTE: some magic numbers here - basically if we",
            "\t\t\t *       can't fit a reasonable amount of data into the",
            "\t\t\t *       existing audit buffer, flush it and start with",
            "\t\t\t *       a new buffer */",
            "\t\t\tif ((sizeof(abuf) + 8) > len_rem) {",
            "\t\t\t\tlen_rem = len_max;",
            "\t\t\t\taudit_log_end(*ab);",
            "\t\t\t\t*ab = audit_log_start(context,",
            "\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);",
            "\t\t\t\tif (!*ab)",
            "\t\t\t\t\tgoto out;",
            "\t\t\t}",
            "",
            "\t\t\t/* create the non-arg portion of the arg record */",
            "\t\t\tlen_tmp = 0;",
            "\t\t\tif (require_data || (iter > 0) ||",
            "\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {",
            "\t\t\t\tif (iter == 0) {",
            "\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],",
            "\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,",
            "\t\t\t\t\t\t\t\" a%d_len=%lu\",",
            "\t\t\t\t\t\t\targ, len_full);",
            "\t\t\t\t}",
            "\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],",
            "\t\t\t\t\t\t    sizeof(abuf) - len_tmp,",
            "\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);",
            "\t\t\t} else",
            "\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],",
            "\t\t\t\t\t\t    sizeof(abuf) - len_tmp,",
            "\t\t\t\t\t\t    \" a%d=\", arg);",
            "\t\t\tWARN_ON(len_tmp >= sizeof(abuf));",
            "\t\t\tabuf[sizeof(abuf) - 1] = '\\0';",
            "",
            "\t\t\t/* log the arg in the audit record */",
            "\t\t\taudit_log_format(*ab, \"%s\", abuf);",
            "\t\t\tlen_rem -= len_tmp;",
            "\t\t\tlen_tmp = len_buf;",
            "\t\t\tif (encode) {",
            "\t\t\t\tif (len_abuf > len_rem)",
            "\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */",
            "\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);",
            "\t\t\t\tlen_rem -= len_tmp * 2;",
            "\t\t\t\tlen_abuf -= len_tmp * 2;",
            "\t\t\t} else {",
            "\t\t\t\tif (len_abuf > len_rem)",
            "\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */",
            "\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);",
            "\t\t\t\tlen_rem -= len_tmp + 2;",
            "\t\t\t\t/* don't subtract the \"2\" because we still need",
            "\t\t\t\t * to add quotes to the remaining string */",
            "\t\t\t\tlen_abuf -= len_tmp;",
            "\t\t\t}",
            "\t\t\tlen_buf -= len_tmp;",
            "\t\t\tbuf += len_tmp;",
            "\t\t}",
            "",
            "\t\t/* ready to move to the next argument? */",
            "\t\tif ((len_buf == 0) && !require_data) {",
            "\t\t\targ++;",
            "\t\t\titer = 0;",
            "\t\t\tlen_full = 0;",
            "\t\t\trequire_data = true;",
            "\t\t\tencode = false;",
            "\t\t}",
            "\t} while (arg < context->execve.argc);",
            "",
            "\t/* NOTE: the caller handles the final audit_log_end() call */",
            "",
            "out:",
            "\tkfree(buf_head);",
            "}"
          ],
          "function_name": "audit_free_context, audit_log_pid_context, audit_log_execve_info",
          "description": "负责审计上下文释放、进程PID上下文日志记录及execve参数审计日志生成，包含用户态字符串复制与缓冲区管理逻辑",
          "similarity": 0.657756507396698
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/auditsc.c",
          "start_line": 1299,
          "end_line": 1487,
          "content": [
            "static void audit_log_cap(struct audit_buffer *ab, char *prefix,",
            "\t\t\t  kernel_cap_t *cap)",
            "{",
            "\tif (cap_isclear(*cap)) {",
            "\t\taudit_log_format(ab, \" %s=0\", prefix);",
            "\t\treturn;",
            "\t}",
            "\taudit_log_format(ab, \" %s=%016llx\", prefix, cap->val);",
            "}",
            "static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)",
            "{",
            "\tif (name->fcap_ver == -1) {",
            "\t\taudit_log_format(ab, \" cap_fe=? cap_fver=? cap_fp=? cap_fi=?\");",
            "\t\treturn;",
            "\t}",
            "\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);",
            "\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);",
            "\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x cap_frootid=%d\",",
            "\t\t\t name->fcap.fE, name->fcap_ver,",
            "\t\t\t from_kuid(&init_user_ns, name->fcap.rootid));",
            "}",
            "static void audit_log_time(struct audit_context *context, struct audit_buffer **ab)",
            "{",
            "\tconst struct audit_ntp_data *ntp = &context->time.ntp_data;",
            "\tconst struct timespec64 *tk = &context->time.tk_injoffset;",
            "\tstatic const char * const ntp_name[] = {",
            "\t\t\"offset\",",
            "\t\t\"freq\",",
            "\t\t\"status\",",
            "\t\t\"tai\",",
            "\t\t\"tick\",",
            "\t\t\"adjust\",",
            "\t};",
            "\tint type;",
            "",
            "\tif (context->type == AUDIT_TIME_ADJNTPVAL) {",
            "\t\tfor (type = 0; type < AUDIT_NTP_NVALS; type++) {",
            "\t\t\tif (ntp->vals[type].newval != ntp->vals[type].oldval) {",
            "\t\t\t\tif (!*ab) {",
            "\t\t\t\t\t*ab = audit_log_start(context,",
            "\t\t\t\t\t\t\tGFP_KERNEL,",
            "\t\t\t\t\t\t\tAUDIT_TIME_ADJNTPVAL);",
            "\t\t\t\t\tif (!*ab)",
            "\t\t\t\t\t\treturn;",
            "\t\t\t\t}",
            "\t\t\t\taudit_log_format(*ab, \"op=%s old=%lli new=%lli\",",
            "\t\t\t\t\t\t ntp_name[type],",
            "\t\t\t\t\t\t ntp->vals[type].oldval,",
            "\t\t\t\t\t\t ntp->vals[type].newval);",
            "\t\t\t\taudit_log_end(*ab);",
            "\t\t\t\t*ab = NULL;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif (tk->tv_sec != 0 || tk->tv_nsec != 0) {",
            "\t\tif (!*ab) {",
            "\t\t\t*ab = audit_log_start(context, GFP_KERNEL,",
            "\t\t\t\t\t      AUDIT_TIME_INJOFFSET);",
            "\t\t\tif (!*ab)",
            "\t\t\t\treturn;",
            "\t\t}",
            "\t\taudit_log_format(*ab, \"sec=%lli nsec=%li\",",
            "\t\t\t\t (long long)tk->tv_sec, tk->tv_nsec);",
            "\t\taudit_log_end(*ab);",
            "\t\t*ab = NULL;",
            "\t}",
            "}",
            "static void show_special(struct audit_context *context, int *call_panic)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tint i;",
            "",
            "\tab = audit_log_start(context, GFP_KERNEL, context->type);",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tswitch (context->type) {",
            "\tcase AUDIT_SOCKETCALL: {",
            "\t\tint nargs = context->socketcall.nargs;",
            "",
            "\t\taudit_log_format(ab, \"nargs=%d\", nargs);",
            "\t\tfor (i = 0; i < nargs; i++)",
            "\t\t\taudit_log_format(ab, \" a%d=%lx\", i,",
            "\t\t\t\tcontext->socketcall.args[i]);",
            "\t\tbreak; }",
            "\tcase AUDIT_IPC: {",
            "\t\tu32 osid = context->ipc.osid;",
            "",
            "\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",",
            "\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),",
            "\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),",
            "\t\t\t\t context->ipc.mode);",
            "\t\tif (osid) {",
            "\t\t\tchar *ctx = NULL;",
            "\t\t\tu32 len;",
            "",
            "\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {",
            "\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);",
            "\t\t\t\t*call_panic = 1;",
            "\t\t\t} else {",
            "\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);",
            "\t\t\t\tsecurity_release_secctx(ctx, len);",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (context->ipc.has_perm) {",
            "\t\t\taudit_log_end(ab);",
            "\t\t\tab = audit_log_start(context, GFP_KERNEL,",
            "\t\t\t\t\t     AUDIT_IPC_SET_PERM);",
            "\t\t\tif (unlikely(!ab))",
            "\t\t\t\treturn;",
            "\t\t\taudit_log_format(ab,",
            "\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",",
            "\t\t\t\tcontext->ipc.qbytes,",
            "\t\t\t\tcontext->ipc.perm_uid,",
            "\t\t\t\tcontext->ipc.perm_gid,",
            "\t\t\t\tcontext->ipc.perm_mode);",
            "\t\t}",
            "\t\tbreak; }",
            "\tcase AUDIT_MQ_OPEN:",
            "\t\taudit_log_format(ab,",
            "\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"",
            "\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",",
            "\t\t\tcontext->mq_open.oflag, context->mq_open.mode,",
            "\t\t\tcontext->mq_open.attr.mq_flags,",
            "\t\t\tcontext->mq_open.attr.mq_maxmsg,",
            "\t\t\tcontext->mq_open.attr.mq_msgsize,",
            "\t\t\tcontext->mq_open.attr.mq_curmsgs);",
            "\t\tbreak;",
            "\tcase AUDIT_MQ_SENDRECV:",
            "\t\taudit_log_format(ab,",
            "\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"",
            "\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",",
            "\t\t\tcontext->mq_sendrecv.mqdes,",
            "\t\t\tcontext->mq_sendrecv.msg_len,",
            "\t\t\tcontext->mq_sendrecv.msg_prio,",
            "\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,",
            "\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);",
            "\t\tbreak;",
            "\tcase AUDIT_MQ_NOTIFY:",
            "\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",",
            "\t\t\t\tcontext->mq_notify.mqdes,",
            "\t\t\t\tcontext->mq_notify.sigev_signo);",
            "\t\tbreak;",
            "\tcase AUDIT_MQ_GETSETATTR: {",
            "\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;",
            "",
            "\t\taudit_log_format(ab,",
            "\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"",
            "\t\t\t\"mq_curmsgs=%ld \",",
            "\t\t\tcontext->mq_getsetattr.mqdes,",
            "\t\t\tattr->mq_flags, attr->mq_maxmsg,",
            "\t\t\tattr->mq_msgsize, attr->mq_curmsgs);",
            "\t\tbreak; }",
            "\tcase AUDIT_CAPSET:",
            "\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);",
            "\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);",
            "\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);",
            "\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);",
            "\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);",
            "\t\tbreak;",
            "\tcase AUDIT_MMAP:",
            "\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,",
            "\t\t\t\t context->mmap.flags);",
            "\t\tbreak;",
            "\tcase AUDIT_OPENAT2:",
            "\t\taudit_log_format(ab, \"oflag=0%llo mode=0%llo resolve=0x%llx\",",
            "\t\t\t\t context->openat2.flags,",
            "\t\t\t\t context->openat2.mode,",
            "\t\t\t\t context->openat2.resolve);",
            "\t\tbreak;",
            "\tcase AUDIT_EXECVE:",
            "\t\taudit_log_execve_info(context, &ab);",
            "\t\tbreak;",
            "\tcase AUDIT_KERN_MODULE:",
            "\t\taudit_log_format(ab, \"name=\");",
            "\t\tif (context->module.name) {",
            "\t\t\taudit_log_untrustedstring(ab, context->module.name);",
            "\t\t} else",
            "\t\t\taudit_log_format(ab, \"(null)\");",
            "",
            "\t\tbreak;",
            "\tcase AUDIT_TIME_ADJNTPVAL:",
            "\tcase AUDIT_TIME_INJOFFSET:",
            "\t\t/* this call deviates from the rest, eating the buffer */",
            "\t\taudit_log_time(context, &ab);",
            "\t\tbreak;",
            "\t}",
            "\taudit_log_end(ab);",
            "}"
          ],
          "function_name": "audit_log_cap, audit_log_fcaps, audit_log_time, show_special",
          "description": "实现能力标识、文件能力、时间调整等特殊审计事件的格式化记录，根据上下文类型触发不同日志格式化规则",
          "similarity": 0.6418113708496094
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/auditsc.c",
          "start_line": 1644,
          "end_line": 1818,
          "content": [
            "static void audit_log_uring(struct audit_context *ctx)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tconst struct cred *cred;",
            "",
            "\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);",
            "\tif (!ab)",
            "\t\treturn;",
            "\tcred = current_cred();",
            "\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);",
            "\tif (ctx->return_valid != AUDITSC_INVALID)",
            "\t\taudit_log_format(ab, \" success=%s exit=%ld\",",
            "\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?",
            "\t\t\t\t  \"yes\" : \"no\"),",
            "\t\t\t\t ctx->return_code);",
            "\taudit_log_format(ab,",
            "\t\t\t \" items=%d\"",
            "\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"",
            "\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",",
            "\t\t\t ctx->name_count,",
            "\t\t\t task_ppid_nr(current), task_tgid_nr(current),",
            "\t\t\t from_kuid(&init_user_ns, cred->uid),",
            "\t\t\t from_kgid(&init_user_ns, cred->gid),",
            "\t\t\t from_kuid(&init_user_ns, cred->euid),",
            "\t\t\t from_kuid(&init_user_ns, cred->suid),",
            "\t\t\t from_kuid(&init_user_ns, cred->fsuid),",
            "\t\t\t from_kgid(&init_user_ns, cred->egid),",
            "\t\t\t from_kgid(&init_user_ns, cred->sgid),",
            "\t\t\t from_kgid(&init_user_ns, cred->fsgid));",
            "\taudit_log_task_context(ab);",
            "\taudit_log_key(ab, ctx->filterkey);",
            "\taudit_log_end(ab);",
            "}",
            "static void audit_log_exit(void)",
            "{",
            "\tint i, call_panic = 0;",
            "\tstruct audit_context *context = audit_context();",
            "\tstruct audit_buffer *ab;",
            "\tstruct audit_aux_data *aux;",
            "\tstruct audit_names *n;",
            "",
            "\tcontext->personality = current->personality;",
            "",
            "\tswitch (context->context) {",
            "\tcase AUDIT_CTX_SYSCALL:",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);",
            "\t\tif (!ab)",
            "\t\t\treturn;",
            "\t\taudit_log_format(ab, \"arch=%x syscall=%d\",",
            "\t\t\t\t context->arch, context->major);",
            "\t\tif (context->personality != PER_LINUX)",
            "\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);",
            "\t\tif (context->return_valid != AUDITSC_INVALID)",
            "\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",",
            "\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?",
            "\t\t\t\t\t  \"yes\" : \"no\"),",
            "\t\t\t\t\t context->return_code);",
            "\t\taudit_log_format(ab,",
            "\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",",
            "\t\t\t\t context->argv[0],",
            "\t\t\t\t context->argv[1],",
            "\t\t\t\t context->argv[2],",
            "\t\t\t\t context->argv[3],",
            "\t\t\t\t context->name_count);",
            "\t\taudit_log_task_info(ab);",
            "\t\taudit_log_key(ab, context->filterkey);",
            "\t\taudit_log_end(ab);",
            "\t\tbreak;",
            "\tcase AUDIT_CTX_URING:",
            "\t\taudit_log_uring(context);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t\tbreak;",
            "\t}",
            "",
            "\tfor (aux = context->aux; aux; aux = aux->next) {",
            "",
            "\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);",
            "\t\tif (!ab)",
            "\t\t\tcontinue; /* audit_panic has been called */",
            "",
            "\t\tswitch (aux->type) {",
            "",
            "\t\tcase AUDIT_BPRM_FCAPS: {",
            "\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;",
            "",
            "\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);",
            "\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);",
            "\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);",
            "\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);",
            "\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);",
            "\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);",
            "\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);",
            "\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);",
            "\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);",
            "\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);",
            "\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);",
            "\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);",
            "\t\t\taudit_log_format(ab, \" frootid=%d\",",
            "\t\t\t\t\t from_kuid(&init_user_ns,",
            "\t\t\t\t\t\t   axs->fcap.rootid));",
            "\t\t\tbreak; }",
            "",
            "\t\t}",
            "\t\taudit_log_end(ab);",
            "\t}",
            "",
            "\tif (context->type)",
            "\t\tshow_special(context, &call_panic);",
            "",
            "\tif (context->fds[0] >= 0) {",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);",
            "\t\tif (ab) {",
            "\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",",
            "\t\t\t\t\tcontext->fds[0], context->fds[1]);",
            "\t\t\taudit_log_end(ab);",
            "\t\t}",
            "\t}",
            "",
            "\tif (context->sockaddr_len) {",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);",
            "\t\tif (ab) {",
            "\t\t\taudit_log_format(ab, \"saddr=\");",
            "\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,",
            "\t\t\t\t\tcontext->sockaddr_len);",
            "\t\t\taudit_log_end(ab);",
            "\t\t}",
            "\t}",
            "",
            "\tfor (aux = context->aux_pids; aux; aux = aux->next) {",
            "\t\tstruct audit_aux_data_pids *axs = (void *)aux;",
            "",
            "\t\tfor (i = 0; i < axs->pid_count; i++)",
            "\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],",
            "\t\t\t\t\t\t  axs->target_auid[i],",
            "\t\t\t\t\t\t  axs->target_uid[i],",
            "\t\t\t\t\t\t  axs->target_sessionid[i],",
            "\t\t\t\t\t\t  axs->target_sid[i],",
            "\t\t\t\t\t\t  axs->target_comm[i]))",
            "\t\t\t\tcall_panic = 1;",
            "\t}",
            "",
            "\tif (context->target_pid &&",
            "\t    audit_log_pid_context(context, context->target_pid,",
            "\t\t\t\t  context->target_auid, context->target_uid,",
            "\t\t\t\t  context->target_sessionid,",
            "\t\t\t\t  context->target_sid, context->target_comm))",
            "\t\t\tcall_panic = 1;",
            "",
            "\tif (context->pwd.dentry && context->pwd.mnt) {",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);",
            "\t\tif (ab) {",
            "\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);",
            "\t\t\taudit_log_end(ab);",
            "\t\t}",
            "\t}",
            "",
            "\ti = 0;",
            "\tlist_for_each_entry(n, &context->names_list, list) {",
            "\t\tif (n->hidden)",
            "\t\t\tcontinue;",
            "\t\taudit_log_name(context, n, NULL, i++, &call_panic);",
            "\t}",
            "",
            "\tif (context->context == AUDIT_CTX_SYSCALL)",
            "\t\taudit_log_proctitle();",
            "",
            "\t/* Send end of event record to help user space know we are finished */",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);",
            "\tif (ab)",
            "\t\taudit_log_end(ab);",
            "\tif (call_panic)",
            "\t\taudit_panic(\"error in audit_log_exit()\");",
            "}"
          ],
          "function_name": "audit_log_uring, audit_log_exit",
          "description": "实现uring操作审计日志记录及进程退出事件审计，包含系统调用参数、文件描述符、特殊辅助数据等多维度审计信息收集",
          "similarity": 0.6368927955627441
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/auditsc.c",
          "start_line": 2011,
          "end_line": 2156,
          "content": [
            "void __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,",
            "\t\t\t   unsigned long a3, unsigned long a4)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "\tenum audit_state     state;",
            "",
            "\tif (!audit_enabled || !context)",
            "\t\treturn;",
            "",
            "\tWARN_ON(context->context != AUDIT_CTX_UNUSED);",
            "\tWARN_ON(context->name_count);",
            "\tif (context->context != AUDIT_CTX_UNUSED || context->name_count) {",
            "\t\taudit_panic(\"unrecoverable error in audit_syscall_entry()\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tstate = context->state;",
            "\tif (state == AUDIT_STATE_DISABLED)",
            "\t\treturn;",
            "",
            "\tcontext->dummy = !audit_n_rules;",
            "\tif (!context->dummy && state == AUDIT_STATE_BUILD) {",
            "\t\tcontext->prio = 0;",
            "\t\tif (auditd_test_task(current))",
            "\t\t\treturn;",
            "\t}",
            "",
            "\tcontext->arch\t    = syscall_get_arch(current);",
            "\tcontext->major      = major;",
            "\tcontext->argv[0]    = a1;",
            "\tcontext->argv[1]    = a2;",
            "\tcontext->argv[2]    = a3;",
            "\tcontext->argv[3]    = a4;",
            "\tcontext->context = AUDIT_CTX_SYSCALL;",
            "\tcontext->current_state  = state;",
            "\tktime_get_coarse_real_ts64(&context->ctime);",
            "}",
            "void __audit_syscall_exit(int success, long return_code)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tif (!context || context->dummy ||",
            "\t    context->context != AUDIT_CTX_SYSCALL)",
            "\t\tgoto out;",
            "",
            "\t/* this may generate CONFIG_CHANGE records */",
            "\tif (!list_empty(&context->killed_trees))",
            "\t\taudit_kill_trees(context);",
            "",
            "\taudit_return_fixup(context, success, return_code);",
            "\t/* run through both filters to ensure we set the filterkey properly */",
            "\taudit_filter_syscall(current, context);",
            "\taudit_filter_inodes(current, context);",
            "\tif (context->current_state != AUDIT_STATE_RECORD)",
            "\t\tgoto out;",
            "",
            "\taudit_log_exit();",
            "",
            "out:",
            "\taudit_reset_context(context);",
            "}",
            "static inline void handle_one(const struct inode *inode)",
            "{",
            "\tstruct audit_context *context;",
            "\tstruct audit_tree_refs *p;",
            "\tstruct audit_chunk *chunk;",
            "\tint count;",
            "",
            "\tif (likely(!inode->i_fsnotify_marks))",
            "\t\treturn;",
            "\tcontext = audit_context();",
            "\tp = context->trees;",
            "\tcount = context->tree_count;",
            "\trcu_read_lock();",
            "\tchunk = audit_tree_lookup(inode);",
            "\trcu_read_unlock();",
            "\tif (!chunk)",
            "\t\treturn;",
            "\tif (likely(put_tree_ref(context, chunk)))",
            "\t\treturn;",
            "\tif (unlikely(!grow_tree_refs(context))) {",
            "\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");",
            "\t\taudit_set_auditable(context);",
            "\t\taudit_put_chunk(chunk);",
            "\t\tunroll_tree_refs(context, p, count);",
            "\t\treturn;",
            "\t}",
            "\tput_tree_ref(context, chunk);",
            "}",
            "static void handle_path(const struct dentry *dentry)",
            "{",
            "\tstruct audit_context *context;",
            "\tstruct audit_tree_refs *p;",
            "\tconst struct dentry *d, *parent;",
            "\tstruct audit_chunk *drop;",
            "\tunsigned long seq;",
            "\tint count;",
            "",
            "\tcontext = audit_context();",
            "\tp = context->trees;",
            "\tcount = context->tree_count;",
            "retry:",
            "\tdrop = NULL;",
            "\td = dentry;",
            "\trcu_read_lock();",
            "\tseq = read_seqbegin(&rename_lock);",
            "\tfor (;;) {",
            "\t\tstruct inode *inode = d_backing_inode(d);",
            "",
            "\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {",
            "\t\t\tstruct audit_chunk *chunk;",
            "",
            "\t\t\tchunk = audit_tree_lookup(inode);",
            "\t\t\tif (chunk) {",
            "\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {",
            "\t\t\t\t\tdrop = chunk;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tparent = d->d_parent;",
            "\t\tif (parent == d)",
            "\t\t\tbreak;",
            "\t\td = parent;",
            "\t}",
            "\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */",
            "\t\trcu_read_unlock();",
            "\t\tif (!drop) {",
            "\t\t\t/* just a race with rename */",
            "\t\t\tunroll_tree_refs(context, p, count);",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\taudit_put_chunk(drop);",
            "\t\tif (grow_tree_refs(context)) {",
            "\t\t\t/* OK, got more space */",
            "\t\t\tunroll_tree_refs(context, p, count);",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\t/* too bad */",
            "\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");",
            "\t\tunroll_tree_refs(context, p, count);",
            "\t\taudit_set_auditable(context);",
            "\t\treturn;",
            "\t}",
            "\trcu_read_unlock();",
            "}"
          ],
          "function_name": "__audit_syscall_entry, __audit_syscall_exit, handle_one, handle_path",
          "description": "此代码块处理系统调用的审计入口/出口记录，包含路径追踪功能。通过遍历文件系统节点检测变化，维护审计上下文中的树引用计数，确保在文件操作时正确记录审计信息。",
          "similarity": 0.6176713109016418
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/auditsc.c",
          "start_line": 2692,
          "end_line": 2803,
          "content": [
            "void __audit_fd_pair(int fd1, int fd2)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tcontext->fds[0] = fd1;",
            "\tcontext->fds[1] = fd2;",
            "}",
            "int __audit_sockaddr(int len, void *a)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tif (!context->sockaddr) {",
            "\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);",
            "",
            "\t\tif (!p)",
            "\t\t\treturn -ENOMEM;",
            "\t\tcontext->sockaddr = p;",
            "\t}",
            "",
            "\tcontext->sockaddr_len = len;",
            "\tmemcpy(context->sockaddr, a, len);",
            "\treturn 0;",
            "}",
            "void __audit_ptrace(struct task_struct *t)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tcontext->target_pid = task_tgid_nr(t);",
            "\tcontext->target_auid = audit_get_loginuid(t);",
            "\tcontext->target_uid = task_uid(t);",
            "\tcontext->target_sessionid = audit_get_sessionid(t);",
            "\tsecurity_task_getsecid_obj(t, &context->target_sid);",
            "\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);",
            "}",
            "int audit_signal_info_syscall(struct task_struct *t)",
            "{",
            "\tstruct audit_aux_data_pids *axp;",
            "\tstruct audit_context *ctx = audit_context();",
            "\tkuid_t t_uid = task_uid(t);",
            "",
            "\tif (!audit_signals || audit_dummy_context())",
            "\t\treturn 0;",
            "",
            "\t/* optimize the common case by putting first signal recipient directly",
            "\t * in audit_context */",
            "\tif (!ctx->target_pid) {",
            "\t\tctx->target_pid = task_tgid_nr(t);",
            "\t\tctx->target_auid = audit_get_loginuid(t);",
            "\t\tctx->target_uid = t_uid;",
            "\t\tctx->target_sessionid = audit_get_sessionid(t);",
            "\t\tsecurity_task_getsecid_obj(t, &ctx->target_sid);",
            "\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\taxp = (void *)ctx->aux_pids;",
            "\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {",
            "\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);",
            "\t\tif (!axp)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\taxp->d.type = AUDIT_OBJ_PID;",
            "\t\taxp->d.next = ctx->aux_pids;",
            "\t\tctx->aux_pids = (void *)axp;",
            "\t}",
            "\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);",
            "",
            "\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);",
            "\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);",
            "\taxp->target_uid[axp->pid_count] = t_uid;",
            "\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);",
            "\tsecurity_task_getsecid_obj(t, &axp->target_sid[axp->pid_count]);",
            "\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);",
            "\taxp->pid_count++;",
            "",
            "\treturn 0;",
            "}",
            "int __audit_log_bprm_fcaps(struct linux_binprm *bprm,",
            "\t\t\t   const struct cred *new, const struct cred *old)",
            "{",
            "\tstruct audit_aux_data_bprm_fcaps *ax;",
            "\tstruct audit_context *context = audit_context();",
            "\tstruct cpu_vfs_cap_data vcaps;",
            "",
            "\tax = kmalloc(sizeof(*ax), GFP_KERNEL);",
            "\tif (!ax)",
            "\t\treturn -ENOMEM;",
            "",
            "\tax->d.type = AUDIT_BPRM_FCAPS;",
            "\tax->d.next = context->aux;",
            "\tcontext->aux = (void *)ax;",
            "",
            "\tget_vfs_caps_from_disk(&nop_mnt_idmap,",
            "\t\t\t       bprm->file->f_path.dentry, &vcaps);",
            "",
            "\tax->fcap.permitted = vcaps.permitted;",
            "\tax->fcap.inheritable = vcaps.inheritable;",
            "\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);",
            "\tax->fcap.rootid = vcaps.rootid;",
            "\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;",
            "",
            "\tax->old_pcap.permitted   = old->cap_permitted;",
            "\tax->old_pcap.inheritable = old->cap_inheritable;",
            "\tax->old_pcap.effective   = old->cap_effective;",
            "\tax->old_pcap.ambient     = old->cap_ambient;",
            "",
            "\tax->new_pcap.permitted   = new->cap_permitted;",
            "\tax->new_pcap.inheritable = new->cap_inheritable;",
            "\tax->new_pcap.effective   = new->cap_effective;",
            "\tax->new_pcap.ambient     = new->cap_ambient;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__audit_fd_pair, __audit_sockaddr, __audit_ptrace, audit_signal_info_syscall, __audit_log_bprm_fcaps",
          "description": "该代码块定义了多个辅助函数，用于在审计上下文中记录文件描述符配对、套接字地址、ptrace目标信息、信号传递及二进制参数能力变化等安全相关事件，通过修改audit_context结构体成员存储关键数据，供后续审计日志生成使用。",
          "similarity": 0.6118061542510986
        }
      ]
    }
  ]
}