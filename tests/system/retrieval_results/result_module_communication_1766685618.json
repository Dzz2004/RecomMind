{
  "query": "module communication",
  "timestamp": "2025-12-26 02:00:18",
  "retrieved_files": [
    {
      "source_file": "kernel/module/main.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:04:44\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\main.c`\n\n---\n\n# `module/main.c` 技术文档\n\n## 1. 文件概述\n\n`module/main.c` 是 Linux 内核模块子系统的核心实现文件，负责模块的加载、卸载、符号解析、内存管理、状态跟踪以及模块间依赖关系的维护。该文件实现了内核模块机制的基础框架，包括模块列表管理、模块内存布局控制、符号查找、模块通知机制、模块引用计数等关键功能，是内核动态加载模块能力的核心支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mod_tree_root mod_tree`**：用于加速地址到模块映射的全局模块地址范围树，包含 `addr_min`/`addr_max`（及可选的 `data_addr_min`/`data_addr_max`）。\n- **`LIST_HEAD(modules)`**：全局模块链表，存储所有已加载模块。\n- **`DEFINE_MUTEX(module_mutex)`**：保护模块列表、模块使用关系及地址边界的关键互斥锁。\n- **`struct symsearch`**：用于描述符号搜索范围，包含符号起止位置、CRC 校验数组及许可证类型。\n- **`struct find_symbol_arg`**：符号查找的参数结构体，用于传递查找目标及接收结果（所有者、符号指针、CRC、许可证等）。\n\n### 主要函数与接口\n\n- **模块注册/注销通知**：\n  - `register_module_notifier()` / `unregister_module_notifier()`：注册/注销模块生命周期事件通知回调。\n- **模块引用管理**：\n  - `strong_try_module_get()`：强引用获取，拒绝处于 `COMING` 状态的模块。\n  - `__module_put_and_kthread_exit()`：专用于内核线程在退出前释放模块引用。\n- **模块内存边界管理**：\n  - `__mod_update_bounds()` / `mod_update_bounds()`：更新全局模块地址范围，用于加速 `__module_address()`。\n- **ELF 节区辅助函数**：\n  - `find_sec()` / `find_any_sec()`：根据名称查找 ELF 节区索引。\n  - `section_addr()` / `section_objs()`：获取节区地址及对象数量。\n- **符号查找**：\n  - `find_symbol()`：在内核及已加载模块中查找导出符号。\n  - `find_exported_symbol_in_section()`：在指定符号段中二分查找符号。\n- **模块状态与安全**：\n  - `add_taint_module()`：为模块添加污点标记（taint flag）。\n- **全局控制**：\n  - `modules_disabled`：通过 `nomodule` 内核参数控制是否禁用模块加载。\n\n### 全局变量与工作队列\n\n- **`init_free_wq`**：用于异步释放模块初始化段（`.init`）内存的工作队列。\n- **`init_free_list`**：待释放初始化内存的无锁链表。\n- **`module_wq`**：等待模块初始化完成的等待队列。\n\n## 3. 关键实现\n\n### 模块地址范围加速\n\n通过 `mod_tree` 全局结构维护所有模块（或核心数据）的最小/最大虚拟地址。`__module_address()` 可先检查目标地址是否落在 `[addr_min, addr_max]` 范围内，若不在则直接返回 `NULL`，避免遍历整个模块链表，显著提升性能。\n\n### 符号查找机制\n\n- 使用 `bsearch()` 在已排序的导出符号表中进行二分查找，时间复杂度为 O(log n)。\n- 支持符号命名空间（namespace）和 GPL 许可证检查：非 GPL 模块无法使用 `GPL_ONLY` 符号。\n- 通过 `symsearch` 数组统一管理内核及各模块的符号段，实现统一查找接口。\n\n### 模块内存管理\n\n- 模块内存按 `mod_mem_type`（如代码、只读数据、可写数据、初始化段等）分类管理。\n- 初始化段（`.init`）在模块初始化成功后通过工作队列异步释放，节省内存。\n- 支持 `CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC` 架构选项，将模块数据段单独纳入地址范围管理。\n\n### 模块状态与引用安全\n\n- `strong_try_module_get()` 确保不会对处于 `MODULE_STATE_COMING`（正在初始化）或 `MODULE_STATE_UNFORMED`（未形成）状态的模块增加引用，防止竞态。\n- `__module_put_and_kthread_exit()` 为内核线程提供安全退出路径，在释放模块引用后终止线程。\n\n### 模块通知机制\n\n基于 `blocking_notifier_chain` 实现模块生命周期事件（如加载、卸载、初始化完成等）的通知，允许其他子系统（如 livepatch、ftrace）监听并响应模块状态变化。\n\n### 构建标识与版本校验\n\n- 通过 `INCLUDE_VERMAGIC` 宏包含模块魔数（vermagic）信息，用于加载时内核版本兼容性检查。\n- 支持 `CONFIG_MODVERSIONS`，在符号查找时返回 CRC 校验值，确保符号 ABI 兼容性。\n\n## 4. 依赖关系\n\n- **架构相关**：\n  - 依赖 `asm/cacheflush.h`、`asm/mmu_context.h`、`asm/sections.h` 等架构头文件，处理指令缓存刷新、内存映射等。\n  - 使用 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 优化符号字符串存储。\n- **内核子系统**：\n  - **内存管理**：`vmalloc`、`slab` 用于模块内存分配。\n  - **安全机制**：`capability`、`audit`、`module_signature` 用于模块加载权限和签名验证。\n  - **调试与追踪**：`kallsyms`、`trace_events`、`ftrace`、`dynamic_debug`、`debugfs` 提供模块调试支持。\n  - **并发控制**：`RCU`、`mutex`、`percpu` 用于同步。\n  - **文件系统**：`fs.h`、`kernel_read_file.h` 用于从文件加载模块。\n- **内部依赖**：\n  - 依赖同目录下的 `internal.h`，包含模块子系统内部数据结构和函数声明。\n  - 使用 `uapi/linux/module.h` 定义用户空间接口常量。\n\n## 5. 使用场景\n\n- **动态加载内核模块**：通过 `init_module()` 或 `finit_module()` 系统调用加载 `.ko` 文件时，该文件中的函数负责解析 ELF、重定位、符号解析、执行初始化函数。\n- **模块卸载**：通过 `delete_module()` 系统调用卸载模块时，管理模块引用计数、执行清理函数、释放内存。\n- **内核符号解析**：当模块或内核其他部分调用 `symbol_get()` 或通过 `EXPORT_SYMBOL` 机制访问符号时，`find_symbol()` 被调用。\n- **运行时模块查询**：`/proc/modules`、`/sys/module/` 等接口依赖此文件维护的模块列表和状态信息。\n- **内核热补丁（Livepatch）**：依赖模块通知机制和符号查找功能实现函数替换。\n- **内核调试与性能分析**：ftrace、kprobes 等工具依赖模块地址范围和符号信息进行函数跟踪。",
      "similarity": 0.5415233373641968,
      "chunks": [
        {
          "chunk_id": 15,
          "file_path": "kernel/module/main.c",
          "start_line": 2794,
          "end_line": 3072,
          "content": [
            "static int prepare_coming_module(struct module *mod)",
            "{",
            "\tint err;",
            "",
            "\tftrace_module_enable(mod);",
            "\terr = klp_module_coming(mod);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = blocking_notifier_call_chain_robust(&module_notify_list,",
            "\t\t\tMODULE_STATE_COMING, MODULE_STATE_GOING, mod);",
            "\terr = notifier_to_errno(err);",
            "\tif (err)",
            "\t\tklp_module_going(mod);",
            "",
            "\treturn err;",
            "}",
            "static int unknown_module_param_cb(char *param, char *val, const char *modname,",
            "\t\t\t\t   void *arg)",
            "{",
            "\tstruct module *mod = arg;",
            "\tint ret;",
            "",
            "\tif (strcmp(param, \"async_probe\") == 0) {",
            "\t\tif (kstrtobool(val, &mod->async_probe_requested))",
            "\t\t\tmod->async_probe_requested = true;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* Check for magic 'dyndbg' arg */",
            "\tret = ddebug_dyndbg_module_param_cb(param, val, modname);",
            "\tif (ret != 0)",
            "\t\tpr_warn(\"%s: unknown parameter '%s' ignored\\n\", modname, param);",
            "\treturn 0;",
            "}",
            "static int early_mod_check(struct load_info *info, int flags)",
            "{",
            "\tint err;",
            "",
            "\t/*",
            "\t * Now that we know we have the correct module name, check",
            "\t * if it's blacklisted.",
            "\t */",
            "\tif (blacklisted(info->name)) {",
            "\t\tpr_err(\"Module %s is blacklisted\\n\", info->name);",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\terr = rewrite_section_headers(info, flags);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Check module struct version now, before we try to use module. */",
            "\tif (!check_modstruct_version(info, info->mod))",
            "\t\treturn -ENOEXEC;",
            "",
            "\terr = check_modinfo(info->mod, info, flags);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\terr = module_patient_check_exists(info->mod->name, FAIL_DUP_MOD_BECOMING);",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\treturn err;",
            "}",
            "static int load_module(struct load_info *info, const char __user *uargs,",
            "\t\t       int flags)",
            "{",
            "\tstruct module *mod;",
            "\tbool module_allocated = false;",
            "\tlong err = 0;",
            "\tchar *after_dashes;",
            "",
            "\t/*",
            "\t * Do the signature check (if any) first. All that",
            "\t * the signature check needs is info->len, it does",
            "\t * not need any of the section info. That can be",
            "\t * set up later. This will minimize the chances",
            "\t * of a corrupt module causing problems before",
            "\t * we even get to the signature check.",
            "\t *",
            "\t * The check will also adjust info->len by stripping",
            "\t * off the sig length at the end of the module, making",
            "\t * checks against info->len more correct.",
            "\t */",
            "\terr = module_sig_check(info, flags);",
            "\tif (err)",
            "\t\tgoto free_copy;",
            "",
            "\t/*",
            "\t * Do basic sanity checks against the ELF header and",
            "\t * sections. Cache useful sections and set the",
            "\t * info->mod to the userspace passed struct module.",
            "\t */",
            "\terr = elf_validity_cache_copy(info, flags);",
            "\tif (err)",
            "\t\tgoto free_copy;",
            "",
            "\terr = early_mod_check(info, flags);",
            "\tif (err)",
            "\t\tgoto free_copy;",
            "",
            "\t/* Figure out module layout, and allocate all the memory. */",
            "\tmod = layout_and_allocate(info, flags);",
            "\tif (IS_ERR(mod)) {",
            "\t\terr = PTR_ERR(mod);",
            "\t\tgoto free_copy;",
            "\t}",
            "",
            "\tmodule_allocated = true;",
            "",
            "\taudit_log_kern_module(info->name);",
            "",
            "\t/* Reserve our place in the list. */",
            "\terr = add_unformed_module(mod);",
            "\tif (err)",
            "\t\tgoto free_module;",
            "",
            "\t/*",
            "\t * We are tainting your kernel if your module gets into",
            "\t * the modules linked list somehow.",
            "\t */",
            "\tmodule_augment_kernel_taints(mod, info);",
            "",
            "\t/* To avoid stressing percpu allocator, do this once we're unique. */",
            "\terr = percpu_modalloc(mod, info);",
            "\tif (err)",
            "\t\tgoto unlink_mod;",
            "",
            "\t/* Now module is in final location, initialize linked lists, etc. */",
            "\terr = module_unload_init(mod);",
            "\tif (err)",
            "\t\tgoto unlink_mod;",
            "",
            "\tinit_param_lock(mod);",
            "",
            "\t/*",
            "\t * Now we've got everything in the final locations, we can",
            "\t * find optional sections.",
            "\t */",
            "\terr = find_module_sections(mod, info);",
            "\tif (err)",
            "\t\tgoto free_unload;",
            "",
            "\terr = check_export_symbol_versions(mod);",
            "\tif (err)",
            "\t\tgoto free_unload;",
            "",
            "\t/* Set up MODINFO_ATTR fields */",
            "\tsetup_modinfo(mod, info);",
            "",
            "\t/* Fix up syms, so that st_value is a pointer to location. */",
            "\terr = simplify_symbols(mod, info);",
            "\tif (err < 0)",
            "\t\tgoto free_modinfo;",
            "",
            "\terr = apply_relocations(mod, info);",
            "\tif (err < 0)",
            "\t\tgoto free_modinfo;",
            "",
            "\terr = post_relocation(mod, info);",
            "\tif (err < 0)",
            "\t\tgoto free_modinfo;",
            "",
            "\tflush_module_icache(mod);",
            "",
            "\t/* Now copy in args */",
            "\tmod->args = strndup_user(uargs, ~0UL >> 1);",
            "\tif (IS_ERR(mod->args)) {",
            "\t\terr = PTR_ERR(mod->args);",
            "\t\tgoto free_arch_cleanup;",
            "\t}",
            "",
            "\tinit_build_id(mod, info);",
            "",
            "\t/* Ftrace init must be called in the MODULE_STATE_UNFORMED state */",
            "\tftrace_module_init(mod);",
            "",
            "\t/* Finally it's fully formed, ready to start executing. */",
            "\terr = complete_formation(mod, info);",
            "\tif (err)",
            "\t\tgoto ddebug_cleanup;",
            "",
            "\terr = prepare_coming_module(mod);",
            "\tif (err)",
            "\t\tgoto bug_cleanup;",
            "",
            "\tmod->async_probe_requested = async_probe;",
            "",
            "\t/* Module is ready to execute: parsing args may do that. */",
            "\tafter_dashes = parse_args(mod->name, mod->args, mod->kp, mod->num_kp,",
            "\t\t\t\t  -32768, 32767, mod,",
            "\t\t\t\t  unknown_module_param_cb);",
            "\tif (IS_ERR(after_dashes)) {",
            "\t\terr = PTR_ERR(after_dashes);",
            "\t\tgoto coming_cleanup;",
            "\t} else if (after_dashes) {",
            "\t\tpr_warn(\"%s: parameters '%s' after `--' ignored\\n\",",
            "\t\t       mod->name, after_dashes);",
            "\t}",
            "",
            "\t/* Link in to sysfs. */",
            "\terr = mod_sysfs_setup(mod, info, mod->kp, mod->num_kp);",
            "\tif (err < 0)",
            "\t\tgoto coming_cleanup;",
            "",
            "\tif (is_livepatch_module(mod)) {",
            "\t\terr = copy_module_elf(mod, info);",
            "\t\tif (err < 0)",
            "\t\t\tgoto sysfs_cleanup;",
            "\t}",
            "",
            "\t/* Get rid of temporary copy. */",
            "\tfree_copy(info, flags);",
            "",
            "\tcodetag_load_module(mod);",
            "",
            "\t/* Done! */",
            "\ttrace_module_load(mod);",
            "",
            "\treturn do_init_module(mod);",
            "",
            " sysfs_cleanup:",
            "\tmod_sysfs_teardown(mod);",
            " coming_cleanup:",
            "\tmod->state = MODULE_STATE_GOING;",
            "\tdestroy_params(mod->kp, mod->num_kp);",
            "\tblocking_notifier_call_chain(&module_notify_list,",
            "\t\t\t\t     MODULE_STATE_GOING, mod);",
            "\tklp_module_going(mod);",
            " bug_cleanup:",
            "\tmod->state = MODULE_STATE_GOING;",
            "\t/* module_bug_cleanup needs module_mutex protection */",
            "\tmutex_lock(&module_mutex);",
            "\tmodule_bug_cleanup(mod);",
            "\tmutex_unlock(&module_mutex);",
            "",
            " ddebug_cleanup:",
            "\tftrace_release_mod(mod);",
            "\tsynchronize_rcu();",
            "\tkfree(mod->args);",
            " free_arch_cleanup:",
            "\tmodule_arch_cleanup(mod);",
            " free_modinfo:",
            "\tfree_modinfo(mod);",
            " free_unload:",
            "\tmodule_unload_free(mod);",
            " unlink_mod:",
            "\tmutex_lock(&module_mutex);",
            "\t/* Unlink carefully: kallsyms could be walking list. */",
            "\tlist_del_rcu(&mod->list);",
            "\tmod_tree_remove(mod);",
            "\twake_up_all(&module_wq);",
            "\t/* Wait for RCU-sched synchronizing before releasing mod->list. */",
            "\tsynchronize_rcu();",
            "\tmutex_unlock(&module_mutex);",
            " free_module:",
            "\tmod_stat_bump_invalid(info, flags);",
            "\t/* Free lock-classes; relies on the preceding sync_rcu() */",
            "\tfor_class_mod_mem_type(type, core_data) {",
            "\t\tlockdep_free_key_range(mod->mem[type].base,",
            "\t\t\t\t       mod->mem[type].size);",
            "\t}",
            "",
            "\tmodule_deallocate(mod, info);",
            " free_copy:",
            "\t/*",
            "\t * The info->len is always set. We distinguish between",
            "\t * failures once the proper module was allocated and",
            "\t * before that.",
            "\t */",
            "\tif (!module_allocated) {",
            "\t\taudit_log_kern_module(info->name ? info->name : \"?\");",
            "\t\tmod_stat_bump_becoming(info, flags);",
            "\t}",
            "\tfree_copy(info, flags);",
            "\treturn err;",
            "}"
          ],
          "function_name": "prepare_coming_module, unknown_module_param_cb, early_mod_check, load_module",
          "description": "prepare_coming_module 函数处理模块加载前的通知链调用，执行符号重定位和Ftrace初始化，最终调用do_init_module启动模块",
          "similarity": 0.5487764477729797
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/module/main.c",
          "start_line": 2039,
          "end_line": 2252,
          "content": [
            "static void module_augment_kernel_taints(struct module *mod, struct load_info *info)",
            "{",
            "\tint prev_taint = test_taint(TAINT_PROPRIETARY_MODULE);",
            "",
            "\tif (!get_modinfo(info, \"intree\")) {",
            "\t\tif (!test_taint(TAINT_OOT_MODULE))",
            "\t\t\tpr_warn(\"%s: loading out-of-tree module taints kernel.\\n\",",
            "\t\t\t\tmod->name);",
            "\t\tadd_taint_module(mod, TAINT_OOT_MODULE, LOCKDEP_STILL_OK);",
            "\t}",
            "",
            "\tcheck_modinfo_retpoline(mod, info);",
            "",
            "\tif (get_modinfo(info, \"staging\")) {",
            "\t\tadd_taint_module(mod, TAINT_CRAP, LOCKDEP_STILL_OK);",
            "\t\tpr_warn(\"%s: module is from the staging directory, the quality \"",
            "\t\t\t\"is unknown, you have been warned.\\n\", mod->name);",
            "\t}",
            "",
            "\tif (is_livepatch_module(mod)) {",
            "\t\tadd_taint_module(mod, TAINT_LIVEPATCH, LOCKDEP_STILL_OK);",
            "\t\tpr_notice_once(\"%s: tainting kernel with TAINT_LIVEPATCH\\n\",",
            "\t\t\t\tmod->name);",
            "\t}",
            "",
            "\tmodule_license_taint_check(mod, get_modinfo(info, \"license\"));",
            "",
            "\tif (get_modinfo(info, \"test\")) {",
            "\t\tif (!test_taint(TAINT_TEST))",
            "\t\t\tpr_warn(\"%s: loading test module taints kernel.\\n\",",
            "\t\t\t\tmod->name);",
            "\t\tadd_taint_module(mod, TAINT_TEST, LOCKDEP_STILL_OK);",
            "\t}",
            "#ifdef CONFIG_MODULE_SIG",
            "\tmod->sig_ok = info->sig_ok;",
            "\tif (!mod->sig_ok) {",
            "\t\tpr_notice_once(\"%s: module verification failed: signature \"",
            "\t\t\t       \"and/or required key missing - tainting \"",
            "\t\t\t       \"kernel\\n\", mod->name);",
            "\t\tadd_taint_module(mod, TAINT_UNSIGNED_MODULE, LOCKDEP_STILL_OK);",
            "\t}",
            "#endif",
            "",
            "\t/*",
            "\t * ndiswrapper is under GPL by itself, but loads proprietary modules.",
            "\t * Don't use add_taint_module(), as it would prevent ndiswrapper from",
            "\t * using GPL-only symbols it needs.",
            "\t */",
            "\tif (strcmp(mod->name, \"ndiswrapper\") == 0)",
            "\t\tadd_taint(TAINT_PROPRIETARY_MODULE, LOCKDEP_NOW_UNRELIABLE);",
            "",
            "\t/* driverloader was caught wrongly pretending to be under GPL */",
            "\tif (strcmp(mod->name, \"driverloader\") == 0)",
            "\t\tadd_taint_module(mod, TAINT_PROPRIETARY_MODULE,",
            "\t\t\t\t LOCKDEP_NOW_UNRELIABLE);",
            "",
            "\t/* lve claims to be GPL but upstream won't provide source */",
            "\tif (strcmp(mod->name, \"lve\") == 0)",
            "\t\tadd_taint_module(mod, TAINT_PROPRIETARY_MODULE,",
            "\t\t\t\t LOCKDEP_NOW_UNRELIABLE);",
            "",
            "\tif (!prev_taint && test_taint(TAINT_PROPRIETARY_MODULE))",
            "\t\tpr_warn(\"%s: module license taints kernel.\\n\", mod->name);",
            "",
            "}",
            "static int check_modinfo(struct module *mod, struct load_info *info, int flags)",
            "{",
            "\tconst char *modmagic = get_modinfo(info, \"vermagic\");",
            "\tint err;",
            "",
            "\tif (flags & MODULE_INIT_IGNORE_VERMAGIC)",
            "\t\tmodmagic = NULL;",
            "",
            "\t/* This is allowed: modprobe --force will invalidate it. */",
            "\tif (!modmagic) {",
            "\t\terr = try_to_force_load(mod, \"bad vermagic\");",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t} else if (!same_magic(modmagic, vermagic, info->index.vers)) {",
            "\t\tpr_err(\"%s: version magic '%s' should be '%s'\\n\",",
            "\t\t       info->name, modmagic, vermagic);",
            "\t\treturn -ENOEXEC;",
            "\t}",
            "",
            "\terr = check_modinfo_livepatch(mod, info);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn 0;",
            "}",
            "static int find_module_sections(struct module *mod, struct load_info *info)",
            "{",
            "\tmod->kp = section_objs(info, \"__param\",",
            "\t\t\t       sizeof(*mod->kp), &mod->num_kp);",
            "\tmod->syms = section_objs(info, \"__ksymtab\",",
            "\t\t\t\t sizeof(*mod->syms), &mod->num_syms);",
            "\tmod->crcs = section_addr(info, \"__kcrctab\");",
            "\tmod->gpl_syms = section_objs(info, \"__ksymtab_gpl\",",
            "\t\t\t\t     sizeof(*mod->gpl_syms),",
            "\t\t\t\t     &mod->num_gpl_syms);",
            "\tmod->gpl_crcs = section_addr(info, \"__kcrctab_gpl\");",
            "",
            "#ifdef CONFIG_CONSTRUCTORS",
            "\tmod->ctors = section_objs(info, \".ctors\",",
            "\t\t\t\t  sizeof(*mod->ctors), &mod->num_ctors);",
            "\tif (!mod->ctors)",
            "\t\tmod->ctors = section_objs(info, \".init_array\",",
            "\t\t\t\tsizeof(*mod->ctors), &mod->num_ctors);",
            "\telse if (find_sec(info, \".init_array\")) {",
            "\t\t/*",
            "\t\t * This shouldn't happen with same compiler and binutils",
            "\t\t * building all parts of the module.",
            "\t\t */",
            "\t\tpr_warn(\"%s: has both .ctors and .init_array.\\n\",",
            "\t\t       mod->name);",
            "\t\treturn -EINVAL;",
            "\t}",
            "#endif",
            "",
            "\tmod->noinstr_text_start = section_objs(info, \".noinstr.text\", 1,",
            "\t\t\t\t\t\t&mod->noinstr_text_size);",
            "",
            "#ifdef CONFIG_TRACEPOINTS",
            "\tmod->tracepoints_ptrs = section_objs(info, \"__tracepoints_ptrs\",",
            "\t\t\t\t\t     sizeof(*mod->tracepoints_ptrs),",
            "\t\t\t\t\t     &mod->num_tracepoints);",
            "#endif",
            "#ifdef CONFIG_TREE_SRCU",
            "\tmod->srcu_struct_ptrs = section_objs(info, \"___srcu_struct_ptrs\",",
            "\t\t\t\t\t     sizeof(*mod->srcu_struct_ptrs),",
            "\t\t\t\t\t     &mod->num_srcu_structs);",
            "#endif",
            "#ifdef CONFIG_BPF_EVENTS",
            "\tmod->bpf_raw_events = section_objs(info, \"__bpf_raw_tp_map\",",
            "\t\t\t\t\t   sizeof(*mod->bpf_raw_events),",
            "\t\t\t\t\t   &mod->num_bpf_raw_events);",
            "#endif",
            "#ifdef CONFIG_DEBUG_INFO_BTF_MODULES",
            "\tmod->btf_data = any_section_objs(info, \".BTF\", 1, &mod->btf_data_size);",
            "\tmod->btf_base_data = any_section_objs(info, \".BTF.base\", 1,",
            "\t\t\t\t\t      &mod->btf_base_data_size);",
            "#endif",
            "#ifdef CONFIG_JUMP_LABEL",
            "\tmod->jump_entries = section_objs(info, \"__jump_table\",",
            "\t\t\t\t\tsizeof(*mod->jump_entries),",
            "\t\t\t\t\t&mod->num_jump_entries);",
            "#endif",
            "#ifdef CONFIG_EVENT_TRACING",
            "\tmod->trace_events = section_objs(info, \"_ftrace_events\",",
            "\t\t\t\t\t sizeof(*mod->trace_events),",
            "\t\t\t\t\t &mod->num_trace_events);",
            "\tmod->trace_evals = section_objs(info, \"_ftrace_eval_map\",",
            "\t\t\t\t\tsizeof(*mod->trace_evals),",
            "\t\t\t\t\t&mod->num_trace_evals);",
            "#endif",
            "#ifdef CONFIG_TRACING",
            "\tmod->trace_bprintk_fmt_start = section_objs(info, \"__trace_printk_fmt\",",
            "\t\t\t\t\t sizeof(*mod->trace_bprintk_fmt_start),",
            "\t\t\t\t\t &mod->num_trace_bprintk_fmt);",
            "#endif",
            "#ifdef CONFIG_FTRACE_MCOUNT_RECORD",
            "\t/* sechdrs[0].sh_size is always zero */",
            "\tmod->ftrace_callsites = section_objs(info, FTRACE_CALLSITE_SECTION,",
            "\t\t\t\t\t     sizeof(*mod->ftrace_callsites),",
            "\t\t\t\t\t     &mod->num_ftrace_callsites);",
            "#endif",
            "#ifdef CONFIG_FUNCTION_ERROR_INJECTION",
            "\tmod->ei_funcs = section_objs(info, \"_error_injection_whitelist\",",
            "\t\t\t\t\t    sizeof(*mod->ei_funcs),",
            "\t\t\t\t\t    &mod->num_ei_funcs);",
            "#endif",
            "#ifdef CONFIG_KPROBES",
            "\tmod->kprobes_text_start = section_objs(info, \".kprobes.text\", 1,",
            "\t\t\t\t\t\t&mod->kprobes_text_size);",
            "\tmod->kprobe_blacklist = section_objs(info, \"_kprobe_blacklist\",",
            "\t\t\t\t\t\tsizeof(unsigned long),",
            "\t\t\t\t\t\t&mod->num_kprobe_blacklist);",
            "#endif",
            "#ifdef CONFIG_PRINTK_INDEX",
            "\tmod->printk_index_start = section_objs(info, \".printk_index\",",
            "\t\t\t\t\t       sizeof(*mod->printk_index_start),",
            "\t\t\t\t\t       &mod->printk_index_size);",
            "#endif",
            "#ifdef CONFIG_HAVE_STATIC_CALL_INLINE",
            "\tmod->static_call_sites = section_objs(info, \".static_call_sites\",",
            "\t\t\t\t\t      sizeof(*mod->static_call_sites),",
            "\t\t\t\t\t      &mod->num_static_call_sites);",
            "#endif",
            "#if IS_ENABLED(CONFIG_KUNIT)",
            "\tmod->kunit_suites = section_objs(info, \".kunit_test_suites\",",
            "\t\t\t\t\t      sizeof(*mod->kunit_suites),",
            "\t\t\t\t\t      &mod->num_kunit_suites);",
            "\tmod->kunit_init_suites = section_objs(info, \".kunit_init_test_suites\",",
            "\t\t\t\t\t      sizeof(*mod->kunit_init_suites),",
            "\t\t\t\t\t      &mod->num_kunit_init_suites);",
            "#endif",
            "",
            "\tmod->extable = section_objs(info, \"__ex_table\",",
            "\t\t\t\t    sizeof(*mod->extable), &mod->num_exentries);",
            "",
            "\tif (section_addr(info, \"__obsparm\"))",
            "\t\tpr_warn(\"%s: Ignoring obsolete parameters\\n\", mod->name);",
            "",
            "#ifdef CONFIG_DYNAMIC_DEBUG_CORE",
            "\tmod->dyndbg_info.descs = section_objs(info, \"__dyndbg\",",
            "\t\t\t\t\t      sizeof(*mod->dyndbg_info.descs),",
            "\t\t\t\t\t      &mod->dyndbg_info.num_descs);",
            "\tmod->dyndbg_info.classes = section_objs(info, \"__dyndbg_classes\",",
            "\t\t\t\t\t\tsizeof(*mod->dyndbg_info.classes),",
            "\t\t\t\t\t\t&mod->dyndbg_info.num_classes);",
            "#endif",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "module_augment_kernel_taints, check_modinfo, find_module_sections",
          "description": "根据模块元信息增强内核污点标记，验证版本魔法字符串，解析模块各节区信息并填充至module结构体，处理特殊节区如ctors、tracepoints等",
          "similarity": 0.5318461656570435
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/main.c",
          "start_line": 96,
          "end_line": 202,
          "content": [
            "static void __mod_update_bounds(enum mod_mem_type type __maybe_unused, void *base,",
            "\t\t\t\tunsigned int size, struct mod_tree_root *tree)",
            "{",
            "\tunsigned long min = (unsigned long)base;",
            "\tunsigned long max = min + size;",
            "",
            "#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC",
            "\tif (mod_mem_type_is_core_data(type)) {",
            "\t\tif (min < tree->data_addr_min)",
            "\t\t\ttree->data_addr_min = min;",
            "\t\tif (max > tree->data_addr_max)",
            "\t\t\ttree->data_addr_max = max;",
            "\t\treturn;",
            "\t}",
            "#endif",
            "\tif (min < tree->addr_min)",
            "\t\ttree->addr_min = min;",
            "\tif (max > tree->addr_max)",
            "\t\ttree->addr_max = max;",
            "}",
            "static void mod_update_bounds(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size)",
            "\t\t\t__mod_update_bounds(type, mod_mem->base, mod_mem->size, &mod_tree);",
            "\t}",
            "}",
            "int register_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&module_notify_list, nb);",
            "}",
            "int unregister_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);",
            "}",
            "static inline int strong_try_module_get(struct module *mod)",
            "{",
            "\tBUG_ON(mod && mod->state == MODULE_STATE_UNFORMED);",
            "\tif (mod && mod->state == MODULE_STATE_COMING)",
            "\t\treturn -EBUSY;",
            "\tif (try_module_get(mod))",
            "\t\treturn 0;",
            "\telse",
            "\t\treturn -ENOENT;",
            "}",
            "static inline void add_taint_module(struct module *mod, unsigned flag,",
            "\t\t\t\t    enum lockdep_ok lockdep_ok)",
            "{",
            "\tadd_taint(flag, lockdep_ok);",
            "\tset_bit(flag, &mod->taints);",
            "}",
            "void __noreturn __module_put_and_kthread_exit(struct module *mod, long code)",
            "{",
            "\tmodule_put(mod);",
            "\tkthread_exit(code);",
            "}",
            "static unsigned int find_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\t/* Alloc bit cleared means \"ignore it.\" */",
            "\t\tif ((shdr->sh_flags & SHF_ALLOC)",
            "\t\t    && strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "static unsigned int find_any_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tif (strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "int cmp_name(const void *name, const void *sym)",
            "{",
            "\treturn strcmp(name, kernel_symbol_name(sym));",
            "}",
            "static bool find_exported_symbol_in_section(const struct symsearch *syms,",
            "\t\t\t\t\t    struct module *owner,",
            "\t\t\t\t\t    struct find_symbol_arg *fsa)",
            "{",
            "\tstruct kernel_symbol *sym;",
            "",
            "\tif (!fsa->gplok && syms->license == GPL_ONLY)",
            "\t\treturn false;",
            "",
            "\tsym = bsearch(fsa->name, syms->start, syms->stop - syms->start,",
            "\t\t\tsizeof(struct kernel_symbol), cmp_name);",
            "\tif (!sym)",
            "\t\treturn false;",
            "",
            "\tfsa->owner = owner;",
            "\tfsa->crc = symversion(syms->crcs, sym - syms->start);",
            "\tfsa->sym = sym;",
            "\tfsa->license = syms->license;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "__mod_update_bounds, mod_update_bounds, register_module_notifier, unregister_module_notifier, strong_try_module_get, add_taint_module, __module_put_and_kthread_exit, find_sec, find_any_sec, cmp_name, find_exported_symbol_in_section",
          "description": "实现模块内存边界更新逻辑、模块状态变更通知注册与注销接口，以及强引用获取检查函数，用于维护模块内存范围并控制模块生命周期事件。",
          "similarity": 0.528052806854248
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/module/main.c",
          "start_line": 1071,
          "end_line": 1218,
          "content": [
            "static int verify_namespace_is_imported(const struct load_info *info,",
            "\t\t\t\t\tconst struct kernel_symbol *sym,",
            "\t\t\t\t\tstruct module *mod)",
            "{",
            "\tconst char *namespace;",
            "\tchar *imported_namespace;",
            "",
            "\tnamespace = kernel_symbol_namespace(sym);",
            "\tif (namespace && namespace[0]) {",
            "\t\tfor_each_modinfo_entry(imported_namespace, info, \"import_ns\") {",
            "\t\t\tif (strcmp(namespace, imported_namespace) == 0)",
            "\t\t\t\treturn 0;",
            "\t\t}",
            "#ifdef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\tpr_warn(",
            "#else",
            "\t\tpr_err(",
            "#endif",
            "\t\t\t\"%s: module uses symbol (%s) from namespace %s, but does not import it.\\n\",",
            "\t\t\tmod->name, kernel_symbol_name(sym), namespace);",
            "#ifndef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\treturn -EINVAL;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool inherit_taint(struct module *mod, struct module *owner, const char *name)",
            "{",
            "\tif (!owner || !test_bit(TAINT_PROPRIETARY_MODULE, &owner->taints))",
            "\t\treturn true;",
            "",
            "\tif (mod->using_gplonly_symbols) {",
            "\t\tpr_err(\"%s: module using GPL-only symbols uses symbols %s from proprietary module %s.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (!test_bit(TAINT_PROPRIETARY_MODULE, &mod->taints)) {",
            "\t\tpr_warn(\"%s: module uses symbols %s from proprietary module %s, inheriting taint.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\tset_bit(TAINT_PROPRIETARY_MODULE, &mod->taints);",
            "\t}",
            "\treturn true;",
            "}",
            "void __weak module_memfree(void *module_region)",
            "{",
            "\t/*",
            "\t * This memory may be RO, and freeing RO memory in an interrupt is not",
            "\t * supported by vmalloc.",
            "\t */",
            "\tWARN_ON(in_interrupt());",
            "\tvfree(module_region);",
            "}",
            "void __weak module_arch_cleanup(struct module *mod)",
            "{",
            "}",
            "void __weak module_arch_freeing_init(struct module *mod)",
            "{",
            "}",
            "static bool mod_mem_use_vmalloc(enum mod_mem_type type)",
            "{",
            "\treturn IS_ENABLED(CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC) &&",
            "\t\tmod_mem_type_is_core_data(type);",
            "}",
            "static void module_memory_free(void *ptr, enum mod_mem_type type,",
            "\t\t\t       bool unload_codetags)",
            "{",
            "\tif (!unload_codetags && mod_mem_type_is_core_data(type))",
            "\t\treturn;",
            "",
            "\tif (mod_mem_use_vmalloc(type))",
            "\t\tvfree(ptr);",
            "\telse",
            "\t\tmodule_memfree(ptr);",
            "}",
            "static void free_mod_mem(struct module *mod, bool unload_codetags)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (type == MOD_DATA)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Free lock-classes; relies on the preceding sync_rcu(). */",
            "\t\tlockdep_free_key_range(mod_mem->base, mod_mem->size);",
            "\t\tif (mod_mem->size)",
            "\t\t\tmodule_memory_free(mod_mem->base, type,",
            "\t\t\t\t\t   unload_codetags);",
            "\t}",
            "",
            "\t/* MOD_DATA hosts mod, so free it at last */",
            "\tlockdep_free_key_range(mod->mem[MOD_DATA].base, mod->mem[MOD_DATA].size);",
            "\tmodule_memory_free(mod->mem[MOD_DATA].base, MOD_DATA, unload_codetags);",
            "}",
            "static void free_module(struct module *mod)",
            "{",
            "\tbool unload_codetags;",
            "",
            "\ttrace_module_free(mod);",
            "",
            "\tunload_codetags = codetag_unload_module(mod);",
            "\tif (!unload_codetags)",
            "\t\tpr_warn(\"%s: memory allocation(s) from the module still alive, cannot unload cleanly\\n\",",
            "\t\t\tmod->name);",
            "",
            "\tmod_sysfs_teardown(mod);",
            "",
            "\t/*",
            "\t * We leave it in list to prevent duplicate loads, but make sure",
            "\t * that noone uses it while it's being deconstructed.",
            "\t */",
            "\tmutex_lock(&module_mutex);",
            "\tmod->state = MODULE_STATE_UNFORMED;",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* Arch-specific cleanup. */",
            "\tmodule_arch_cleanup(mod);",
            "",
            "\t/* Module unload stuff */",
            "\tmodule_unload_free(mod);",
            "",
            "\t/* Free any allocated parameters. */",
            "\tdestroy_params(mod->kp, mod->num_kp);",
            "",
            "\tif (is_livepatch_module(mod))",
            "\t\tfree_module_elf(mod);",
            "",
            "\t/* Now we can delete it from the lists */",
            "\tmutex_lock(&module_mutex);",
            "\t/* Unlink carefully: kallsyms could be walking list. */",
            "\tlist_del_rcu(&mod->list);",
            "\tmod_tree_remove(mod);",
            "\t/* Remove this module from bug list, this uses list_del_rcu */",
            "\tmodule_bug_cleanup(mod);",
            "\t/* Wait for RCU-sched synchronizing before releasing mod->list and buglist. */",
            "\tsynchronize_rcu();",
            "\tif (try_add_tainted_module(mod))",
            "\t\tpr_err(\"%s: adding tainted module to the unloaded tainted modules list failed.\\n\",",
            "\t\t       mod->name);",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* This may be empty, but that's OK */",
            "\tmodule_arch_freeing_init(mod);",
            "\tkfree(mod->args);",
            "\tpercpu_modfree(mod);",
            "",
            "\tfree_mod_mem(mod, unload_codetags);",
            "}"
          ],
          "function_name": "verify_namespace_is_imported, inherit_taint, module_memfree, module_arch_cleanup, module_arch_freeing_init, mod_mem_use_vmalloc, module_memory_free, free_mod_mem, free_module",
          "description": "实现模块符号命名空间验证(verify_namespace_is_imported)、污点继承逻辑(herit_taint)、内存释放(module_memory_free/free_mod_mem)及架构特定清理(module_arch_cleanup/module_arch_freeing_init)，包含弱符号声明供架构扩展。",
          "similarity": 0.5200815200805664
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/module/main.c",
          "start_line": 460,
          "end_line": 567,
          "content": [
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn __is_module_percpu_address(addr, NULL);",
            "}",
            "static int percpu_modalloc(struct module *mod, struct load_info *info)",
            "{",
            "\t/* UP modules shouldn't have this section: ENOMEM isn't quite right */",
            "\tif (info->sechdrs[info->index.pcpu].sh_size != 0)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static inline void percpu_modfree(struct module *mod)",
            "{",
            "}",
            "static unsigned int find_pcpusec(struct load_info *info)",
            "{",
            "\treturn 0;",
            "}",
            "static inline void percpu_modcopy(struct module *mod,",
            "\t\t\t\t  const void *from, unsigned long size)",
            "{",
            "\t/* pcpusec should be 0, and size of that section should be 0. */",
            "\tBUG_ON(size != 0);",
            "}",
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn false;",
            "}",
            "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)",
            "{",
            "\treturn false;",
            "}",
            "static int module_unload_init(struct module *mod)",
            "{",
            "\t/*",
            "\t * Initialize reference counter to MODULE_REF_BASE.",
            "\t * refcnt == 0 means module is going.",
            "\t */",
            "\tatomic_set(&mod->refcnt, MODULE_REF_BASE);",
            "",
            "\tINIT_LIST_HEAD(&mod->source_list);",
            "\tINIT_LIST_HEAD(&mod->target_list);",
            "",
            "\t/* Hold reference count during initialization. */",
            "\tatomic_inc(&mod->refcnt);",
            "",
            "\treturn 0;",
            "}",
            "static int already_uses(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tlist_for_each_entry(use, &b->source_list, source_list) {",
            "\t\tif (use->source == a)",
            "\t\t\treturn 1;",
            "\t}",
            "\tpr_debug(\"%s does not use %s!\\n\", a->name, b->name);",
            "\treturn 0;",
            "}",
            "static int add_module_usage(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tpr_debug(\"Allocating new usage for %s.\\n\", a->name);",
            "\tuse = kmalloc(sizeof(*use), GFP_ATOMIC);",
            "\tif (!use)",
            "\t\treturn -ENOMEM;",
            "",
            "\tuse->source = a;",
            "\tuse->target = b;",
            "\tlist_add(&use->source_list, &b->source_list);",
            "\tlist_add(&use->target_list, &a->target_list);",
            "\treturn 0;",
            "}",
            "static int ref_module(struct module *a, struct module *b)",
            "{",
            "\tint err;",
            "",
            "\tif (b == NULL || already_uses(a, b))",
            "\t\treturn 0;",
            "",
            "\t/* If module isn't available, we fail. */",
            "\terr = strong_try_module_get(b);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = add_module_usage(a, b);",
            "\tif (err) {",
            "\t\tmodule_put(b);",
            "\t\treturn err;",
            "\t}",
            "\treturn 0;",
            "}",
            "static void module_unload_free(struct module *mod)",
            "{",
            "\tstruct module_use *use, *tmp;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\tlist_for_each_entry_safe(use, tmp, &mod->target_list, target_list) {",
            "\t\tstruct module *i = use->target;",
            "\t\tpr_debug(\"%s unusing %s\\n\", mod->name, i->name);",
            "\t\tmodule_put(i);",
            "\t\tlist_del(&use->source_list);",
            "\t\tlist_del(&use->target_list);",
            "\t\tkfree(use);",
            "\t}",
            "\tmutex_unlock(&module_mutex);",
            "}"
          ],
          "function_name": "is_module_percpu_address, percpu_modalloc, percpu_modfree, find_pcpusec, percpu_modcopy, is_module_percpu_address, __is_module_percpu_address, module_unload_init, already_uses, add_module_usage, ref_module, module_unload_free",
          "description": "包含模块卸载初始化逻辑，管理模块间依赖关系（通过module_use结构），实现模块引用计数调整及依赖链清理，在模块卸载时安全解除其他模块对其的依赖。",
          "similarity": 0.5165912508964539
        }
      ]
    },
    {
      "source_file": "kernel/module/version.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:10:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\version.c`\n\n---\n\n# module/version.c 技术文档\n\n## 1. 文件概述\n\n`module/version.c` 是 Linux 内核模块子系统中负责模块版本校验的核心实现文件。该文件提供了模块加载过程中符号版本（symbol versioning）的检查机制，用于确保加载的模块与其依赖的内核或其他模块在接口层面保持兼容性。通过 CRC 校验码比对，防止因内核结构体或函数接口变更导致的模块不兼容问题，从而提升系统稳定性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`check_version()`**  \n  检查模块中某个符号的版本 CRC 是否与当前内核中导出的符号 CRC 一致。\n\n- **`check_modstruct_version()`**  \n  专门用于校验 `module_layout` 符号的版本一致性，该符号代表模块布局结构的 ABI。\n\n- **`same_magic()`**  \n  比较两个模块魔数（magic string）是否相同，支持忽略内核版本前缀（当模块包含 CRC 时）。\n\n- **`module_layout()`**  \n  一个空实现的占位函数，其符号被导出，用于生成模块布局的版本签名。\n\n### 关键数据结构\n\n- **`struct modversion_info`**  \n  存储符号名称及其对应的 CRC 校验值，用于版本比对。\n\n- **`struct load_info`**  \n  模块加载过程中的元数据结构，包含 ELF 节头、版本节索引等信息。\n\n## 3. 关键实现\n\n### 符号版本校验机制\n\n- `check_version()` 函数从模块的 `.modver` 节（由 `versindex` 指定）中读取 `modversion_info` 数组。\n- 遍历该数组，查找与目标符号名 `symname` 匹配的条目。\n- 若找到且 CRC 值匹配，则返回 1（校验通过）；否则打印警告并返回 0（校验失败）。\n- 若模块未提供 CRC（`crc == NULL`），视为已污染（tainted），直接放行。\n- 若模块无版本节（`versindex == 0`），则调用 `try_to_force_load()` 允许强制加载（如 `modprobe --force`）。\n\n### `module_layout` 特殊处理\n\n- `check_modstruct_version()` 通过 `find_symbol()` 查找内核中名为 `\"module_layout\"` 的符号。\n- 该符号代表模块内存布局的 ABI，其变化意味着模块结构不兼容。\n- 使用 `preempt_disable()` 避免调度（因内核符号不可卸载，无需锁，仅用于满足 lockdep 检查）。\n\n### 魔数比较逻辑\n\n- `same_magic()` 在模块包含 CRC 时，跳过魔数字符串开头的内核版本部分（通过 `strcspn(..., \" \")` 定位空格后内容），仅比较后续 ABI 标识部分。\n- 此设计允许不同内核版本但相同 ABI 的模块兼容加载。\n\n### `module_layout()` 的作用\n\n- 该函数本身无实现，但其符号被 `EXPORT_SYMBOL` 导出。\n- 链接时，`genksyms` 工具会根据其参数类型（`struct module`, `modversion_info` 等）生成唯一的 CRC。\n- 该 CRC 反映了关键内核数据结构的布局，任何结构变更都会导致 CRC 变化，从而触发版本不匹配。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：提供模块核心 API 和数据结构。\n  - `<linux/string.h>`：使用 `strcmp`、`strcspn` 等字符串函数。\n  - `<linux/printk.h>`：使用 `pr_debug`、`pr_warn` 等日志接口。\n  - `\"internal.h\"`：包含模块子系统内部实现细节（如 `find_symbol`、`try_to_force_load` 等）。\n\n- **功能依赖**：\n  - 依赖内核符号表（`find_symbol`）查询 `module_layout`。\n  - 依赖模块加载流程中解析的 ELF 节信息（`load_info::sechdrs`）。\n  - 与 `scripts/genksyms/` 工具链协同工作，生成符号 CRC。\n\n## 5. 使用场景\n\n- **模块正常加载**：  \n  内核在解析模块依赖时，对每个外部符号调用 `check_version()`，确保 CRC 一致。\n\n- **强制加载模块（`modprobe --force`）**：  \n  当模块无版本信息（`versindex == 0`）时，调用 `try_to_force_load()` 允许加载，但系统会被标记为 tainted。\n\n- **内核升级后模块兼容性检查**：  \n  若内核关键结构（如 `struct module`）发生变化，`module_layout` 的 CRC 将不同，阻止旧模块加载。\n\n- **开发调试**：  \n  开发者可通过 `pr_debug` 输出查看 CRC 不匹配详情，辅助定位 ABI 不兼容问题。\n\n- **模块签名与安全加载**：  \n  版本校验是模块安全加载的前提，防止因结构错位导致内存破坏。",
      "similarity": 0.518608570098877,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/version.c",
          "start_line": 13,
          "end_line": 92,
          "content": [
            "int check_version(const struct load_info *info,",
            "\t\t  const char *symname,",
            "\t\t\t struct module *mod,",
            "\t\t\t const s32 *crc)",
            "{",
            "\tElf_Shdr *sechdrs = info->sechdrs;",
            "\tunsigned int versindex = info->index.vers;",
            "\tunsigned int i, num_versions;",
            "\tstruct modversion_info *versions;",
            "",
            "\t/* Exporting module didn't supply crcs?  OK, we're already tainted. */",
            "\tif (!crc)",
            "\t\treturn 1;",
            "",
            "\t/* No versions at all?  modprobe --force does this. */",
            "\tif (versindex == 0)",
            "\t\treturn try_to_force_load(mod, symname) == 0;",
            "",
            "\tversions = (void *)sechdrs[versindex].sh_addr;",
            "\tnum_versions = sechdrs[versindex].sh_size",
            "\t\t/ sizeof(struct modversion_info);",
            "",
            "\tfor (i = 0; i < num_versions; i++) {",
            "\t\tu32 crcval;",
            "",
            "\t\tif (strcmp(versions[i].name, symname) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tcrcval = *crc;",
            "\t\tif (versions[i].crc == crcval)",
            "\t\t\treturn 1;",
            "\t\tpr_debug(\"Found checksum %X vs module %lX\\n\",",
            "\t\t\t crcval, versions[i].crc);",
            "\t\tgoto bad_version;",
            "\t}",
            "",
            "\t/* Broken toolchain. Warn once, then let it go.. */",
            "\tpr_warn_once(\"%s: no symbol version for %s\\n\", info->name, symname);",
            "\treturn 1;",
            "",
            "bad_version:",
            "\tpr_warn(\"%s: disagrees about version of symbol %s\\n\", info->name, symname);",
            "\treturn 0;",
            "}",
            "int check_modstruct_version(const struct load_info *info,",
            "\t\t\t    struct module *mod)",
            "{",
            "\tstruct find_symbol_arg fsa = {",
            "\t\t.name\t= \"module_layout\",",
            "\t\t.gplok\t= true,",
            "\t};",
            "",
            "\t/*",
            "\t * Since this should be found in kernel (which can't be removed), no",
            "\t * locking is necessary -- use preempt_disable() to placate lockdep.",
            "\t */",
            "\tpreempt_disable();",
            "\tif (!find_symbol(&fsa)) {",
            "\t\tpreempt_enable();",
            "\t\tBUG();",
            "\t}",
            "\tpreempt_enable();",
            "\treturn check_version(info, \"module_layout\", mod, fsa.crc);",
            "}",
            "int same_magic(const char *amagic, const char *bmagic,",
            "\t       bool has_crcs)",
            "{",
            "\tif (has_crcs) {",
            "\t\tamagic += strcspn(amagic, \" \");",
            "\t\tbmagic += strcspn(bmagic, \" \");",
            "\t}",
            "\treturn strcmp(amagic, bmagic) == 0;",
            "}",
            "void module_layout(struct module *mod,",
            "\t\t   struct modversion_info *ver,",
            "\t\t   struct kernel_param *kp,",
            "\t\t   struct kernel_symbol *ks,",
            "\t\t   struct tracepoint * const *tp)",
            "{",
            "}"
          ],
          "function_name": "check_version, check_modstruct_version, same_magic, module_layout",
          "description": "实现模块符号版本校验逻辑，check_version验证符号CRC一致性，check_modstruct_version检查模块布局版本，same_magic对比魔术字符串，module_layout作为预留接口当前为空实现。",
          "similarity": 0.5408594012260437
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/version.c",
          "start_line": 1,
          "end_line": 12,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module version support",
            " *",
            " * Copyright (C) 2008 Rusty Russell",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/printk.h>",
            "#include \"internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "定义模块版本支持的实现文件，包含许可证声明及核心头文件导入，提供模块版本校验所需的基础结构和内部接口定义。",
          "similarity": 0.49882176518440247
        }
      ]
    },
    {
      "source_file": "kernel/module/kmod.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:03:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\kmod.c`\n\n---\n\n# `module/kmod.c` 技术文档\n\n## 1. 文件概述\n\n`kmod.c` 是 Linux 内核中负责**内核模块自动加载机制**的核心实现文件。它提供了从内核空间调用用户态 `modprobe` 工具以动态加载缺失模块的能力。该机制允许内核在运行时按需加载驱动或功能模块（例如当设备被探测到但对应驱动未加载时），从而提升系统灵活性和资源利用率。\n\n该文件实现了 `__request_module()` 接口，作为内核其他子系统请求模块加载的统一入口，并通过 `call_usermodehelper` 机制安全地调用用户空间的 `/sbin/modprobe`（或由 `modprobe_path` 指定的路径）。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__request_module(bool wait, const char *fmt, ...)`**  \n  内核模块加载的主入口函数。支持格式化模块名，可选择同步（`wait=true`）或异步（`wait=false`）执行。返回值为 0 表示成功启动加载过程，负值为错误码，正值为 `modprobe` 的退出码。\n\n- **`call_modprobe(char *orig_module_name, int wait)`**  \n  封装对用户态 `modprobe` 的调用。构造命令行参数（`modprobe -q -- <module_name>`）和环境变量，通过 `call_usermodehelper_setup()` 和 `call_usermodehelper_exec()` 执行。\n\n- **`free_modprobe_argv(struct subprocess_info *info)`**  \n  释放 `call_modprobe` 中分配的参数内存，作为 `call_usermodehelper_setup()` 的清理回调。\n\n### 关键数据结构与变量\n\n- **`modprobe_path[KMOD_PATH_LEN]`**  \n  全局可配置的 `modprobe` 可执行文件路径，默认为 `CONFIG_MODPROBE_PATH`（通常为 `\"/sbin/modprobe\"`），可通过 `/proc/sys/kernel/modprobe` 修改。\n\n- **`kmod_concurrent_max`**  \n  信号量，限制同时进行的模块加载请求数量，上限为 `MAX_KMOD_CONCURRENT`（50），防止资源耗尽或递归依赖导致的死锁。\n\n- **`MAX_KMOD_ALL_BUSY_TIMEOUT`**  \n  超时阈值（5 秒），当所有并发槽位被占用超过此时间，判定为可能的模块依赖循环，拒绝新请求。\n\n## 3. 关键实现\n\n### 并发控制与死锁预防\n\n- 使用 `down_timeout(&kmod_concurrent_max, ...)` 限制并发加载线程数，避免系统资源（如内存、进程数）被大量 `modprobe` 进程耗尽。\n- 若所有 50 个并发槽位在 5 秒内未释放，内核判定为**模块依赖循环**（如 A 依赖 B，B 又依赖 A），主动拒绝请求并打印警告，防止无限递归。\n- 通过 `WARN_ON_ONCE(wait && current_is_async())` 禁止在异步上下文（如 workqueue、async 任务）中执行**同步**模块加载，避免与 `async_synchronize_full()` 产生死锁。\n\n### 安全与资源管理\n\n- 调用 `security_kernel_module_request()` 执行 LSM（Linux Security Module）安全检查，允许安全模块（如 SELinux、AppArmor）控制模块加载权限。\n- 使用 `UMH_KILLABLE` 标志使 `modprobe` 进程可被信号中断，提升系统响应性。\n- 通过 `kmod_dup_request_exists_wait()` 检测重复的模块加载请求，避免对同一模块发起多次 `modprobe` 调用，提升效率。\n\n### 用户态交互\n\n- 构造标准环境变量（`HOME=/`, `PATH=/sbin:/usr/sbin:/bin:/usr/bin`）确保 `modprobe` 在受限但可用的环境中执行。\n- 使用 `call_usermodehelper` 子系统创建内核线程执行用户态程序，该机制处理了凭证（cred）、文件描述符、挂载命名空间等上下文隔离。\n\n### 跟踪与调试\n\n- 集成 `trace_module_request` 跟踪点，可通过 ftrace 或 perf 监控模块加载请求。\n- 调用 `kmod_dup_request_announce()` 记录重复请求或失败事件，便于诊断。\n\n## 4. 依赖关系\n\n- **内核子系统依赖**：\n  - `call_usermodehelper`（`<linux/unistd.h>`, `<linux/binfmts.h>`）：用于执行用户态 helper 程序。\n  - LSM 框架（`<linux/security.h>`）：执行模块加载安全策略。\n  - 内存管理（`<linux/slab.h>`）：动态分配参数字符串。\n  - 同步原语（`<linux/semaphore.h>` via `DEFINE_SEMAPHORE`）：并发控制。\n  - 调试与跟踪（`<trace/events/module.h>`）：性能分析支持。\n- **配置依赖**：\n  - `CONFIG_MODULES`：模块支持必须启用。\n  - `CONFIG_MODPROBE_PATH`：定义默认 `modprobe` 路径。\n- **内部依赖**：\n  - `internal.h`：包含模块子系统内部声明（如 `kmod_dup_request_exists_wait`）。\n\n## 5. 使用场景\n\n- **设备驱动自动加载**：当内核探测到新硬件（如 USB 设备）但无对应驱动时，通过 `__request_module(\"usb:vXXXXpXXXX...\")` 触发驱动加载。\n- **文件系统按需挂载**：挂载未知文件系统类型时（如 `mount -t foo`），内核调用 `__request_module(\"fs-foo\")` 加载文件系统模块。\n- **网络协议模块加载**：使用未加载的网络协议（如 `AF_PHONET`）时自动加载对应模块。\n- **内核特性动态扩展**：如加密算法、压缩模块等在首次使用时按需加载。\n- **内核模块依赖解析**：当模块 A 依赖模块 B，而 B 未加载时，`insmod`/`modprobe` 内部会通过此机制加载 B。\n\n> **注意**：成功返回仅表示 `modprobe` 已启动，不保证模块最终加载成功。调用者必须验证所需功能是否可用。",
      "similarity": 0.5133913159370422,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/kmod.c",
          "start_line": 66,
          "end_line": 161,
          "content": [
            "static void free_modprobe_argv(struct subprocess_info *info)",
            "{",
            "\tkfree(info->argv[3]); /* check call_modprobe() */",
            "\tkfree(info->argv);",
            "}",
            "static int call_modprobe(char *orig_module_name, int wait)",
            "{",
            "\tstruct subprocess_info *info;",
            "\tstatic char *envp[] = {",
            "\t\t\"HOME=/\",",
            "\t\t\"TERM=linux\",",
            "\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",",
            "\t\tNULL",
            "\t};",
            "\tchar *module_name;",
            "\tint ret;",
            "",
            "\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);",
            "\tif (!argv)",
            "\t\tgoto out;",
            "",
            "\tmodule_name = kstrdup(orig_module_name, GFP_KERNEL);",
            "\tif (!module_name)",
            "\t\tgoto free_argv;",
            "",
            "\targv[0] = modprobe_path;",
            "\targv[1] = \"-q\";",
            "\targv[2] = \"--\";",
            "\targv[3] = module_name;\t/* check free_modprobe_argv() */",
            "\targv[4] = NULL;",
            "",
            "\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,",
            "\t\t\t\t\t NULL, free_modprobe_argv, NULL);",
            "\tif (!info)",
            "\t\tgoto free_module_name;",
            "",
            "\tret = call_usermodehelper_exec(info, wait | UMH_KILLABLE);",
            "\tkmod_dup_request_announce(orig_module_name, ret);",
            "\treturn ret;",
            "",
            "free_module_name:",
            "\tkfree(module_name);",
            "free_argv:",
            "\tkfree(argv);",
            "out:",
            "\tkmod_dup_request_announce(orig_module_name, -ENOMEM);",
            "\treturn -ENOMEM;",
            "}",
            "int __request_module(bool wait, const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "\tchar module_name[MODULE_NAME_LEN];",
            "\tint ret, dup_ret;",
            "",
            "\t/*",
            "\t * We don't allow synchronous module loading from async.  Module",
            "\t * init may invoke async_synchronize_full() which will end up",
            "\t * waiting for this task which already is waiting for the module",
            "\t * loading to complete, leading to a deadlock.",
            "\t */",
            "\tWARN_ON_ONCE(wait && current_is_async());",
            "",
            "\tif (!modprobe_path[0])",
            "\t\treturn -ENOENT;",
            "",
            "\tva_start(args, fmt);",
            "\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);",
            "\tva_end(args);",
            "\tif (ret >= MODULE_NAME_LEN)",
            "\t\treturn -ENAMETOOLONG;",
            "",
            "\tret = security_kernel_module_request(module_name);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = down_timeout(&kmod_concurrent_max, MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);",
            "\tif (ret) {",
            "\t\tpr_warn_ratelimited(\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\",",
            "\t\t\t\t    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ttrace_module_request(module_name, wait, _RET_IP_);",
            "",
            "\tif (kmod_dup_request_exists_wait(module_name, wait, &dup_ret)) {",
            "\t\tret = dup_ret;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);",
            "",
            "out:",
            "\tup(&kmod_concurrent_max);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "free_modprobe_argv, call_modprobe, __request_module",
          "description": "实现模块请求处理逻辑，通过调用modprobe执行模块加载，包含参数构造、子进程管理及并发控制机制",
          "similarity": 0.557679295539856
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/kmod.c",
          "start_line": 1,
          "end_line": 65,
          "content": [
            "/*",
            " * kmod - the kernel module loader",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/cred.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/resource.h>",
            "#include <linux/notifier.h>",
            "#include <linux/suspend.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/async.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include <trace/events/module.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * Assuming:",
            " *",
            " * threads = div64_u64((u64) totalram_pages * (u64) PAGE_SIZE,",
            " *\t\t       (u64) THREAD_SIZE * 8UL);",
            " *",
            " * If you need less than 50 threads would mean we're dealing with systems",
            " * smaller than 3200 pages. This assumes you are capable of having ~13M memory,",
            " * and this would only be an upper limit, after which the OOM killer would take",
            " * effect. Systems like these are very unlikely if modules are enabled.",
            " */",
            "#define MAX_KMOD_CONCURRENT 50",
            "static DEFINE_SEMAPHORE(kmod_concurrent_max, MAX_KMOD_CONCURRENT);",
            "",
            "/*",
            " * This is a restriction on having *all* MAX_KMOD_CONCURRENT threads",
            " * running at the same time without returning. When this happens we",
            " * believe you've somehow ended up with a recursive module dependency",
            " * creating a loop.",
            " *",
            " * We have no option but to fail.",
            " *",
            " * Userspace should proactively try to detect and prevent these.",
            " */",
            "#define MAX_KMOD_ALL_BUSY_TIMEOUT 5",
            "",
            "/*",
            "\tmodprobe_path is set via /proc/sys.",
            "*/",
            "char modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;",
            ""
          ],
          "function_name": null,
          "description": "定义模块加载并发控制相关常量与全局变量，包含模块加载所需头文件并初始化modprobe路径",
          "similarity": 0.4955998957157135
        }
      ]
    }
  ]
}