{
  "query": "现在又问了 加密文件系统",
  "timestamp": "2025-12-26 01:33:48",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/crypto.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:08:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\crypto.c`\n\n---\n\n# `bpf/crypto.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/crypto.c` 是 Linux 内核中为 BPF（Berkeley Packet Filter）程序提供加密功能支持的核心实现文件。该文件定义了 BPF 加密上下文（`bpf_crypto_ctx`）的创建、引用管理、加解密操作等接口，并通过可扩展的类型注册机制（`bpf_crypto_type`）支持多种加密算法后端。所有接口均以 `__bpf_kfunc` 标记，供 sleepable BPF 程序在内核态安全调用。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_crypto_params`**  \n  BPF 程序传入的加密初始化参数结构体，包含：\n  - `type`：加密操作类型（如 \"skcipher\"）\n  - `algo`：具体算法名称（如 \"aes-gcm\"）\n  - `key` / `key_len`：密钥及其长度\n  - `authsize`：认证标签长度（用于 AEAD 算法）\n\n- **`struct bpf_crypto_ctx`**  \n  引用计数的 BPF 加密上下文，封装了底层 crypto API 的变换对象（`tfm`），包含：\n  - `type`：指向注册的加密类型操作集\n  - `tfm`：由 `alloc_tfm()` 创建的 crypto 变换实例\n  - `siv_len`：IV（初始向量）与状态存储总大小\n  - `usage`：引用计数器，支持多 BPF 程序共享\n  - `rcu`：用于 RCU 安全释放资源\n\n- **`struct bpf_crypto_type_list`**  \n  全局加密类型注册链表节点，用于管理所有已注册的 `bpf_crypto_type`。\n\n### 主要函数\n\n- **`bpf_crypto_register_type()` / `bpf_crypto_unregister_type()`**  \n  向全局链表注册/注销一种 BPF 加密类型（如对称加密、AEAD 等），支持模块动态加载。\n\n- **`bpf_crypto_ctx_create()`**  \n  根据 `bpf_crypto_params` 创建并初始化加密上下文，执行密钥设置、认证大小配置等操作。\n\n- **`bpf_crypto_ctx_acquire()` / `bpf_crypto_ctx_release()`**  \n  实现引用计数管理，支持 BPF 程序安全地共享和释放上下文。\n\n- **`bpf_crypto_decrypt()` / `bpf_crypto_encrypt()`（隐含于 `bpf_crypto_crypt()`）**  \n  执行实际的加解密操作，通过 `bpf_dynptr_kern` 安全访问源/目标缓冲区及 IV/状态数据。\n\n## 3. 关键实现\n\n- **类型注册机制**  \n  使用读写信号量 `bpf_crypto_types_sem` 保护全局类型链表 `bpf_crypto_types`，确保并发安全。注册时检查名称唯一性，卸载时自动清理。\n\n- **模块引用管理**  \n  在 `bpf_crypto_get_type()` 中调用 `try_module_get()` 获取模块引用，在上下文释放时通过 `module_put()` 释放，防止模块卸载时使用悬空指针。\n\n- **内存与资源安全释放**  \n  上下文释放采用 RCU 机制：当引用计数归零时，通过 `call_rcu()` 异步调用 `crypto_free_cb()`，确保在所有 CPU 完成读取后再释放 `tfm` 和结构体内存。\n\n- **参数校验严格性**  \n  `bpf_crypto_ctx_create()` 对输入参数进行多层校验：\n  - 检查 `reserved` 字段是否为零（预留扩展）\n  - 验证 `params__sz` 是否匹配结构体大小\n  - 确保 `authsize` 与算法能力匹配（有/无 `setauthsize` 回调）\n  - 密钥长度合法性检查\n\n- **动态指针（dynptr）集成**  \n  加解密操作通过 `bpf_dynptr_kern` 接口访问数据，确保源/目标缓冲区权限正确（目标必须可写），并验证 IV 长度与上下文 `siv_len` 一致。\n\n## 4. 依赖关系\n\n- **BPF 子系统**  \n  依赖 `bpf_mem_alloc.h`（BPF 内存分配）、`filter.h`（BPF 程序基础）、`btf_ids.h`（BTF 类型信息）及 `__bpf_kfunc` 基础设施。\n\n- **Crypto API**  \n  通过 `crypto/skcipher.h` 等头文件调用内核加密框架，具体算法由 `bpf_crypto_type` 的回调函数（如 `alloc_tfm`, `encrypt`）桥接。\n\n- **内核通用机制**  \n  使用 `refcount_t`（引用计数）、`RCU`（安全释放）、`GFP_KERNEL`（睡眠分配）等标准内核原语。\n\n- **网络子系统**（间接）  \n  可能与 `skbuff.h` 交互（如处理网络包加密），但当前代码未直接操作 `sk_buff`。\n\n## 5. 使用场景\n\n- **BPF 程序内加密操作**  \n  Sleepable BPF 程序（如 LSM、syscall hook）可调用 `bpf_crypto_ctx_create()` 初始化 AES-GCM 等上下文，对用户数据进行加解密。\n\n- **安全协议实现**  \n  在 BPF 中实现 TLS/DTLS 记录层、IPsec ESP 等协议的加解密逻辑，利用内核 crypto API 的硬件加速能力。\n\n- **密钥管理集成**  \n  与 BPF map 结合，将加密上下文作为 `kptr` 存储，实现密钥轮换、会话管理等高级功能。\n\n- **模块化扩展**  \n  第三方模块可通过 `bpf_crypto_register_type()` 注册自定义加密类型（如国密算法），扩展 BPF 加密能力。",
      "similarity": 0.5996922850608826,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/crypto.c",
          "start_line": 60,
          "end_line": 167,
          "content": [
            "int bpf_crypto_register_type(const struct bpf_crypto_type *type)",
            "{",
            "\tstruct bpf_crypto_type_list *node;",
            "\tint err = -EEXIST;",
            "",
            "\tdown_write(&bpf_crypto_types_sem);",
            "\tlist_for_each_entry(node, &bpf_crypto_types, list) {",
            "\t\tif (!strcmp(node->type->name, type->name))",
            "\t\t\tgoto unlock;",
            "\t}",
            "",
            "\tnode = kmalloc(sizeof(*node), GFP_KERNEL);",
            "\terr = -ENOMEM;",
            "\tif (!node)",
            "\t\tgoto unlock;",
            "",
            "\tnode->type = type;",
            "\tlist_add(&node->list, &bpf_crypto_types);",
            "\terr = 0;",
            "",
            "unlock:",
            "\tup_write(&bpf_crypto_types_sem);",
            "",
            "\treturn err;",
            "}",
            "int bpf_crypto_unregister_type(const struct bpf_crypto_type *type)",
            "{",
            "\tstruct bpf_crypto_type_list *node;",
            "\tint err = -ENOENT;",
            "",
            "\tdown_write(&bpf_crypto_types_sem);",
            "\tlist_for_each_entry(node, &bpf_crypto_types, list) {",
            "\t\tif (strcmp(node->type->name, type->name))",
            "\t\t\tcontinue;",
            "",
            "\t\tlist_del(&node->list);",
            "\t\tkfree(node);",
            "\t\terr = 0;",
            "\t\tbreak;",
            "\t}",
            "\tup_write(&bpf_crypto_types_sem);",
            "",
            "\treturn err;",
            "}",
            "static void crypto_free_cb(struct rcu_head *head)",
            "{",
            "\tstruct bpf_crypto_ctx *ctx;",
            "",
            "\tctx = container_of(head, struct bpf_crypto_ctx, rcu);",
            "\tctx->type->free_tfm(ctx->tfm);",
            "\tmodule_put(ctx->type->owner);",
            "\tkfree(ctx);",
            "}",
            "__bpf_kfunc void bpf_crypto_ctx_release(struct bpf_crypto_ctx *ctx)",
            "{",
            "\tif (refcount_dec_and_test(&ctx->usage))",
            "\t\tcall_rcu(&ctx->rcu, crypto_free_cb);",
            "}",
            "static int bpf_crypto_crypt(const struct bpf_crypto_ctx *ctx,",
            "\t\t\t    const struct bpf_dynptr_kern *src,",
            "\t\t\t    const struct bpf_dynptr_kern *dst,",
            "\t\t\t    const struct bpf_dynptr_kern *siv,",
            "\t\t\t    bool decrypt)",
            "{",
            "\tu32 src_len, dst_len, siv_len;",
            "\tconst u8 *psrc;",
            "\tu8 *pdst, *piv;",
            "\tint err;",
            "",
            "\tif (__bpf_dynptr_is_rdonly(dst))",
            "\t\treturn -EINVAL;",
            "",
            "\tsiv_len = siv ? __bpf_dynptr_size(siv) : 0;",
            "\tsrc_len = __bpf_dynptr_size(src);",
            "\tdst_len = __bpf_dynptr_size(dst);",
            "\tif (!src_len || !dst_len || src_len > dst_len)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (siv_len != ctx->siv_len)",
            "\t\treturn -EINVAL;",
            "",
            "\tpsrc = __bpf_dynptr_data(src, src_len);",
            "\tif (!psrc)",
            "\t\treturn -EINVAL;",
            "\tpdst = __bpf_dynptr_data_rw(dst, dst_len);",
            "\tif (!pdst)",
            "\t\treturn -EINVAL;",
            "",
            "\tpiv = siv_len ? __bpf_dynptr_data_rw(siv, siv_len) : NULL;",
            "\tif (siv_len && !piv)",
            "\t\treturn -EINVAL;",
            "",
            "\terr = decrypt ? ctx->type->decrypt(ctx->tfm, psrc, pdst, src_len, piv)",
            "\t\t      : ctx->type->encrypt(ctx->tfm, psrc, pdst, src_len, piv);",
            "",
            "\treturn err;",
            "}",
            "__bpf_kfunc int bpf_crypto_decrypt(struct bpf_crypto_ctx *ctx,",
            "\t\t\t\t   const struct bpf_dynptr *src,",
            "\t\t\t\t   const struct bpf_dynptr *dst,",
            "\t\t\t\t   const struct bpf_dynptr *siv__nullable)",
            "{",
            "\tconst struct bpf_dynptr_kern *src_kern = (struct bpf_dynptr_kern *)src;",
            "\tconst struct bpf_dynptr_kern *dst_kern = (struct bpf_dynptr_kern *)dst;",
            "\tconst struct bpf_dynptr_kern *siv_kern = (struct bpf_dynptr_kern *)siv__nullable;",
            "",
            "\treturn bpf_crypto_crypt(ctx, src_kern, dst_kern, siv_kern, true);",
            "}"
          ],
          "function_name": "bpf_crypto_register_type, bpf_crypto_unregister_type, crypto_free_cb, bpf_crypto_ctx_release, bpf_crypto_crypt, bpf_crypto_decrypt",
          "description": "实现了BPF加密类型的注册/注销、上下文释放及加密解密操作，包含类型注册检查、上下文引用计数管理、动态指针数据操作和加密算法调用逻辑。",
          "similarity": 0.6070442795753479
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/crypto.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2024 Meta, Inc */",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_crypto.h>",
            "#include <linux/bpf_mem_alloc.h>",
            "#include <linux/btf.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/skbuff.h>",
            "#include <crypto/skcipher.h>",
            "",
            "struct bpf_crypto_type_list {",
            "\tconst struct bpf_crypto_type *type;",
            "\tstruct list_head list;",
            "};",
            "",
            "/* BPF crypto initialization parameters struct */",
            "/**",
            " * struct bpf_crypto_params - BPF crypto initialization parameters structure",
            " * @type:\tThe string of crypto operation type.",
            " * @reserved:\tReserved member, will be reused for more options in future",
            " *\t\tValues:",
            " *\t\t  0",
            " * @algo:\tThe string of algorithm to initialize.",
            " * @key:\tThe cipher key used to init crypto algorithm.",
            " * @key_len:\tThe length of cipher key.",
            " * @authsize:\tThe length of authentication tag used by algorithm.",
            " */",
            "struct bpf_crypto_params {",
            "\tchar type[14];",
            "\tu8 reserved[2];",
            "\tchar algo[128];",
            "\tu8 key[256];",
            "\tu32 key_len;",
            "\tu32 authsize;",
            "};",
            "",
            "static LIST_HEAD(bpf_crypto_types);",
            "static DECLARE_RWSEM(bpf_crypto_types_sem);",
            "",
            "/**",
            " * struct bpf_crypto_ctx - refcounted BPF crypto context structure",
            " * @type:\tThe pointer to bpf crypto type",
            " * @tfm:\tThe pointer to instance of crypto API struct.",
            " * @siv_len:    Size of IV and state storage for cipher",
            " * @rcu:\tThe RCU head used to free the crypto context with RCU safety.",
            " * @usage:\tObject reference counter. When the refcount goes to 0, the",
            " *\t\tmemory is released back to the BPF allocator, which provides",
            " *\t\tRCU safety.",
            " */",
            "struct bpf_crypto_ctx {",
            "\tconst struct bpf_crypto_type *type;",
            "\tvoid *tfm;",
            "\tu32 siv_len;",
            "\tstruct rcu_head rcu;",
            "\trefcount_t usage;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了BPF加密相关结构体和全局变量，包括加密参数结构体bpf_crypto_params、加密上下文结构体bpf_crypto_ctx，以及用于管理加密类型的链表和读写信号量。",
          "similarity": 0.6068929433822632
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/crypto.c",
          "start_line": 334,
          "end_line": 388,
          "content": [
            "__bpf_kfunc int bpf_crypto_encrypt(struct bpf_crypto_ctx *ctx,",
            "\t\t\t\t   const struct bpf_dynptr *src,",
            "\t\t\t\t   const struct bpf_dynptr *dst,",
            "\t\t\t\t   const struct bpf_dynptr *siv__nullable)",
            "{",
            "\tconst struct bpf_dynptr_kern *src_kern = (struct bpf_dynptr_kern *)src;",
            "\tconst struct bpf_dynptr_kern *dst_kern = (struct bpf_dynptr_kern *)dst;",
            "\tconst struct bpf_dynptr_kern *siv_kern = (struct bpf_dynptr_kern *)siv__nullable;",
            "",
            "\treturn bpf_crypto_crypt(ctx, src_kern, dst_kern, siv_kern, false);",
            "}",
            "BTF_KFUNCS_START(crypt_init_kfunc_btf_ids)",
            "BTF_ID_FLAGS(func, bpf_crypto_ctx_create, KF_ACQUIRE | KF_RET_NULL | KF_SLEEPABLE)",
            "BTF_ID_FLAGS(func, bpf_crypto_ctx_release, KF_RELEASE)",
            "BTF_ID_FLAGS(func, bpf_crypto_ctx_acquire, KF_ACQUIRE | KF_RCU | KF_RET_NULL)",
            "BTF_KFUNCS_END(crypt_init_kfunc_btf_ids)",
            "",
            "static const struct btf_kfunc_id_set crypt_init_kfunc_set = {",
            "\t.owner = THIS_MODULE,",
            "\t.set   = &crypt_init_kfunc_btf_ids,",
            "};",
            "",
            "BTF_KFUNCS_START(crypt_kfunc_btf_ids)",
            "BTF_ID_FLAGS(func, bpf_crypto_decrypt, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_crypto_encrypt, KF_RCU)",
            "BTF_KFUNCS_END(crypt_kfunc_btf_ids)",
            "",
            "static const struct btf_kfunc_id_set crypt_kfunc_set = {",
            "\t.owner = THIS_MODULE,",
            "\t.set   = &crypt_kfunc_btf_ids,",
            "};",
            "",
            "BTF_ID_LIST(bpf_crypto_dtor_ids)",
            "BTF_ID(struct, bpf_crypto_ctx)",
            "BTF_ID(func, bpf_crypto_ctx_release)",
            "",
            "static int __init crypto_kfunc_init(void)",
            "{",
            "\tint ret;",
            "\tconst struct btf_id_dtor_kfunc bpf_crypto_dtors[] = {",
            "\t\t{",
            "\t\t\t.btf_id\t      = bpf_crypto_dtor_ids[0],",
            "\t\t\t.kfunc_btf_id = bpf_crypto_dtor_ids[1]",
            "\t\t},",
            "\t};",
            "",
            "\tret = register_btf_kfunc_id_set(BPF_PROG_TYPE_SCHED_CLS, &crypt_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_SCHED_ACT, &crypt_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_XDP, &crypt_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_SYSCALL,",
            "\t\t\t\t\t       &crypt_init_kfunc_set);",
            "\treturn  ret ?: register_btf_id_dtor_kfuncs(bpf_crypto_dtors,",
            "\t\t\t\t\t\t   ARRAY_SIZE(bpf_crypto_dtors),",
            "\t\t\t\t\t\t   THIS_MODULE);",
            "}"
          ],
          "function_name": "bpf_crypto_encrypt, BTF_ID_FLAGS",
          "description": "定义了BPF加密函数的BTF标识符及其属性，注册了加密操作的KFUNC集合，并初始化BTF析构函数关联，用于程序类型匹配和元数据解析。",
          "similarity": 0.5876668691635132
        }
      ]
    },
    {
      "source_file": "kernel/bpf/local_storage.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:15:04\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\local_storage.c`\n\n---\n\n# `bpf/local_storage.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/local_storage.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统的一部分，专门用于实现 **cgroup 本地存储（cgroup local storage）** 功能。该文件在 `CONFIG_CGROUP_BPF` 配置启用时编译，提供了一种机制，允许 BPF 程序为每个 cgroup 实例关联私有的、可持久化的存储空间（即“本地存储”）。这种存储可用于在 BPF 程序中跨调用保存状态，例如统计信息、配置参数等。\n\n该文件实现了两种 BPF map 类型：\n- `BPF_MAP_TYPE_CGROUP_STORAGE`\n- `BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE`\n\n分别用于单值存储和 per-CPU 存储，均基于 cgroup 的 inode ID（及可选的 attach type）作为键进行索引。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_cgroup_storage_map`**  \n  表示 cgroup 存储类型的 BPF map。包含：\n  - `struct bpf_map map`：继承自通用 BPF map 结构\n  - `spinlock_t lock`：保护红黑树和链表的自旋锁\n  - `struct rb_root root`：以键为索引的红黑树，用于快速查找\n  - `struct list_head list`：用于遍历所有存储项的链表\n\n- **`struct bpf_cgroup_storage_key`**  \n  键结构体，包含：\n  - `__u64 cgroup_inode_id`：cgroup 的 inode ID（唯一标识）\n  - `__u32 attach_type`：BPF 程序附加类型（如 `BPF_CGROUP_INET_INGRESS`）\n\n- **`struct bpf_cgroup_storage`**  \n  存储条目，包含：\n  - `struct rb_node node`：红黑树节点\n  - `struct list_head list_map`：链表节点\n  - `union { struct bpf_storage_buffer *buf; void __percpu *percpu_buf; }`：指向实际数据的指针（单值或 per-CPU）\n\n### 主要函数\n\n- **`cgroup_storage_lookup()`**  \n  在红黑树中根据 key 查找对应的 `bpf_cgroup_storage` 条目，支持加锁/不加锁模式。\n\n- **`cgroup_storage_insert()`**  \n  将新的存储条目插入红黑树，若键已存在则返回 `-EEXIST`。\n\n- **`cgroup_storage_lookup_elem()`**  \n  BPF map 的 `lookup` 操作回调，返回存储数据的起始地址。\n\n- **`cgroup_storage_update_elem()`**  \n  BPF map 的 `update` 操作回调，支持原子更新（带 `BPF_F_LOCK`）或替换整个缓冲区。\n\n- **`bpf_percpu_cgroup_storage_copy()`**  \n  用于 `PERCPU_CGROUP_STORAGE` 类型的 lookup，聚合所有 CPU 的数据。\n\n- **`bpf_percpu_cgroup_storage_update()`**  \n  用于 `PERCPU_CGROUP_STORAGE` 类型的 update，将用户提供的数据分发到各 CPU。\n\n- **`cgroup_storage_get_next_key()`**  \n  实现 BPF map 的 `get_next_key` 操作，用于遍历所有存储条目。\n\n- **`cgroup_storage_map_alloc()`**  \n  分配并初始化 cgroup storage 类型的 BPF map。\n\n- **`cgroup_storage_map_free()`**  \n  释放 map 及其所有存储条目（代码未完整显示，但功能明确）。\n\n## 3. 关键实现\n\n### 键值设计与比较逻辑\n\n- 支持两种键格式：\n  1. 仅 `__u64 cgroup_inode_id`（用于非隔离 attach type）\n  2. `struct bpf_cgroup_storage_key`（包含 inode ID + attach type，用于隔离场景）\n- `attach_type_isolated()` 判断是否使用完整键结构。\n- `bpf_cgroup_storage_key_cmp()` 实现红黑树的比较逻辑，先比较 inode ID，再比较 attach type（如适用）。\n\n### 并发控制\n\n- 使用 `spinlock_t lock` 保护红黑树和链表的修改操作（如插入、遍历）。\n- 查找操作可选择是否加锁（`locked` 参数），以支持 RCU 读路径（如 per-CPU update 中使用 `rcu_read_lock()`）。\n- 单值存储更新时使用 `xchg()` + `kfree_rcu()` 实现无锁读取和安全释放。\n\n### 内存管理\n\n- 单值存储使用 `bpf_map_kmalloc_node()` 分配 `bpf_storage_buffer`，包含数据和可能的 BTF 记录。\n- per-CPU 存储使用 `__percpu` 指针，通过 `per_cpu_ptr()` 访问各 CPU 数据。\n- 所有分配考虑 NUMA 节点（通过 `numa_node` 字段）。\n\n### 安全与限制\n\n- `value_size` 限制：\n  - 普通类型：最大 `BPF_LOCAL_STORAGE_MAX_VALUE_SIZE`\n  - per-CPU 类型：额外受限于 `PCPU_MIN_UNIT_SIZE`\n- 键大小必须为 `sizeof(__u64)` 或 `sizeof(bpf_cgroup_storage_key)`\n- `max_entries` 必须为 0（动态扩展）\n- `map_flags` 仅允许 `BPF_F_NUMA_NODE` 和访问权限标志\n\n### per-CPU 数据对齐\n\n- per-CPU 数据按 8 字节对齐（`round_up(value_size, 8)`），确保跨 CPU 访问安全，并防止内核数据泄露（因 per-CPU 区域初始化为零）。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf.h`、`bpf_map.h`、`filter.h` 等核心 BPF 头文件。\n- **cgroup 子系统**：依赖 `cgroup-internal.h` 获取 cgroup 内部结构（如 inode ID）。\n- **内存管理**：使用 `slab.h`、`mm.h` 进行内存分配。\n- **RCU 机制**：用于安全释放旧缓冲区（`kfree_rcu`）。\n- **BTF（BPF Type Format）**：支持带锁字段的类型验证（`btf_record_has_field`）。\n- **红黑树**：使用 `rbtree.h` 实现高效查找。\n- **Per-CPU 基础设施**：使用 `percpu.h` 相关宏（隐式包含）。\n\n## 5. 使用场景\n\n- **BPF 程序状态持久化**：  \n  BPF 程序（如 cgroup hook 程序）可为每个 cgroup 维护独立的计数器、配置或状态机。\n\n- **网络策略与限速**：  \n  在 `BPF_CGROUP_INET_*` 程序中，为每个 cgroup 存储流量统计或令牌桶状态。\n\n- **资源监控**：  \n  用户空间通过 BPF map 接口读取各 cgroup 的累计指标（如 I/O 次数、进程数）。\n\n- **安全策略**：  \n  存储 cgroup 特定的安全上下文或访问控制列表。\n\n- **调试与追踪**：  \n  在 BPF tracepoint 或 kprobe 程序中，按 cgroup 聚合事件数据。\n\n> **注意**：该机制仅在 cgroup BPF 支持启用（`CONFIG_CGROUP_BPF=y`）时可用，且必须通过 BPF 系统调用创建对应类型的 map，并由 BPF 程序或用户空间程序操作。",
      "similarity": 0.599658727645874,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 211,
          "end_line": 363,
          "content": [
            "int bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *key,",
            "\t\t\t\t     void *value, u64 map_flags)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);",
            "\tstruct bpf_cgroup_storage *storage;",
            "\tint cpu, off = 0;",
            "\tu32 size;",
            "",
            "\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)",
            "\t\treturn -EINVAL;",
            "",
            "\trcu_read_lock();",
            "\tstorage = cgroup_storage_lookup(map, key, false);",
            "\tif (!storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ENOENT;",
            "\t}",
            "",
            "\t/* the user space will provide round_up(value_size, 8) bytes that",
            "\t * will be copied into per-cpu area. bpf programs can only access",
            "\t * value_size of it. During lookup the same extra bytes will be",
            "\t * returned or zeros which were zero-filled by percpu_alloc,",
            "\t * so no kernel data leaks possible",
            "\t */",
            "\tsize = round_up(_map->value_size, 8);",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),",
            "\t\t\t\tvalue + off, size);",
            "\t\toff += size;",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn 0;",
            "}",
            "static int cgroup_storage_get_next_key(struct bpf_map *_map, void *key,",
            "\t\t\t\t       void *_next_key)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);",
            "\tstruct bpf_cgroup_storage *storage;",
            "",
            "\tspin_lock_bh(&map->lock);",
            "",
            "\tif (list_empty(&map->list))",
            "\t\tgoto enoent;",
            "",
            "\tif (key) {",
            "\t\tstorage = cgroup_storage_lookup(map, key, true);",
            "\t\tif (!storage)",
            "\t\t\tgoto enoent;",
            "",
            "\t\tstorage = list_next_entry(storage, list_map);",
            "\t\tif (!storage)",
            "\t\t\tgoto enoent;",
            "\t} else {",
            "\t\tstorage = list_first_entry(&map->list,",
            "\t\t\t\t\t struct bpf_cgroup_storage, list_map);",
            "\t}",
            "",
            "\tspin_unlock_bh(&map->lock);",
            "",
            "\tif (attach_type_isolated(&map->map)) {",
            "\t\tstruct bpf_cgroup_storage_key *next = _next_key;",
            "\t\t*next = storage->key;",
            "\t} else {",
            "\t\t__u64 *next = _next_key;",
            "\t\t*next = storage->key.cgroup_inode_id;",
            "\t}",
            "\treturn 0;",
            "",
            "enoent:",
            "\tspin_unlock_bh(&map->lock);",
            "\treturn -ENOENT;",
            "}",
            "static void cgroup_storage_map_free(struct bpf_map *_map)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);",
            "\tstruct list_head *storages = &map->list;",
            "\tstruct bpf_cgroup_storage *storage, *stmp;",
            "",
            "\tcgroup_lock();",
            "",
            "\tlist_for_each_entry_safe(storage, stmp, storages, list_map) {",
            "\t\tbpf_cgroup_storage_unlink(storage);",
            "\t\tbpf_cgroup_storage_free(storage);",
            "\t}",
            "",
            "\tcgroup_unlock();",
            "",
            "\tWARN_ON(!RB_EMPTY_ROOT(&map->root));",
            "\tWARN_ON(!list_empty(&map->list));",
            "",
            "\tbpf_map_area_free(map);",
            "}",
            "static long cgroup_storage_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int cgroup_storage_check_btf(const struct bpf_map *map,",
            "\t\t\t\t    const struct btf *btf,",
            "\t\t\t\t    const struct btf_type *key_type,",
            "\t\t\t\t    const struct btf_type *value_type)",
            "{",
            "\tif (attach_type_isolated(map)) {",
            "\t\tstruct btf_member *m;",
            "\t\tu32 offset, size;",
            "",
            "\t\t/* Key is expected to be of struct bpf_cgroup_storage_key type,",
            "\t\t * which is:",
            "\t\t * struct bpf_cgroup_storage_key {",
            "\t\t *\t__u64\tcgroup_inode_id;",
            "\t\t *\t__u32\tattach_type;",
            "\t\t * };",
            "\t\t */",
            "",
            "\t\t/*",
            "\t\t * Key_type must be a structure with two fields.",
            "\t\t */",
            "\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ||",
            "\t\t    BTF_INFO_VLEN(key_type->info) != 2)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * The first field must be a 64 bit integer at 0 offset.",
            "\t\t */",
            "\t\tm = (struct btf_member *)(key_type + 1);",
            "\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, cgroup_inode_id);",
            "\t\tif (!btf_member_is_reg_int(btf, key_type, m, 0, size))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * The second field must be a 32 bit integer at 64 bit offset.",
            "\t\t */",
            "\t\tm++;",
            "\t\toffset = offsetof(struct bpf_cgroup_storage_key, attach_type);",
            "\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, attach_type);",
            "\t\tif (!btf_member_is_reg_int(btf, key_type, m, offset, size))",
            "\t\t\treturn -EINVAL;",
            "\t} else {",
            "\t\tu32 int_data;",
            "",
            "\t\t/*",
            "\t\t * Key is expected to be u64, which stores the cgroup_inode_id",
            "\t\t */",
            "",
            "\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tint_data = *(u32 *)(key_type + 1);",
            "\t\tif (BTF_INT_BITS(int_data) != 64 || BTF_INT_OFFSET(int_data))",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_percpu_cgroup_storage_update, cgroup_storage_get_next_key, cgroup_storage_map_free, cgroup_storage_delete_elem, cgroup_storage_check_btf",
          "description": "提供了存储遍历、资源释放和BTF类型校验功能，其中delete_elem未实际实现直接返回错误码，check_btf验证键值类型合法性。",
          "similarity": 0.5526728630065918
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 595,
          "end_line": 612,
          "content": [
            "void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map;",
            "\tstruct rb_root *root;",
            "",
            "\tif (!storage)",
            "\t\treturn;",
            "",
            "\tmap = storage->map;",
            "",
            "\tspin_lock_bh(&map->lock);",
            "\troot = &map->root;",
            "\trb_erase(&storage->node, root);",
            "",
            "\tlist_del(&storage->list_map);",
            "\tlist_del(&storage->list_cg);",
            "\tspin_unlock_bh(&map->lock);",
            "}"
          ],
          "function_name": "bpf_cgroup_storage_unlink",
          "description": "负责从红黑树和链表中移除存储项，通过自旋锁保护并发访问，同步维护存储结构与cgroup关联列表。",
          "similarity": 0.5455870628356934
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 414,
          "end_line": 530,
          "content": [
            "static void cgroup_storage_seq_show_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t\t struct seq_file *m)",
            "{",
            "\tenum bpf_cgroup_storage_type stype;",
            "\tstruct bpf_cgroup_storage *storage;",
            "\tint cpu;",
            "",
            "\trcu_read_lock();",
            "\tstorage = cgroup_storage_lookup(map_to_storage(map), key, false);",
            "\tif (!storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn;",
            "\t}",
            "",
            "\tbtf_type_seq_show(map->btf, map->btf_key_type_id, key, m);",
            "\tstype = cgroup_storage_type(map);",
            "\tif (stype == BPF_CGROUP_STORAGE_SHARED) {",
            "\t\tseq_puts(m, \": \");",
            "\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,",
            "\t\t\t\t  &READ_ONCE(storage->buf)->data[0], m);",
            "\t\tseq_puts(m, \"\\n\");",
            "\t} else {",
            "\t\tseq_puts(m, \": {\\n\");",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tseq_printf(m, \"\\tcpu%d: \", cpu);",
            "\t\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,",
            "\t\t\t\t\t  per_cpu_ptr(storage->percpu_buf, cpu),",
            "\t\t\t\t\t  m);",
            "\t\t\tseq_puts(m, \"\\n\");",
            "\t\t}",
            "\t\tseq_puts(m, \"}\\n\");",
            "\t}",
            "\trcu_read_unlock();",
            "}",
            "static u64 cgroup_storage_map_usage(const struct bpf_map *map)",
            "{",
            "\t/* Currently the dynamically allocated elements are not counted. */",
            "\treturn sizeof(struct bpf_cgroup_storage_map);",
            "}",
            "int bpf_cgroup_storage_assign(struct bpf_prog_aux *aux, struct bpf_map *_map)",
            "{",
            "\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);",
            "",
            "\tif (aux->cgroup_storage[stype] &&",
            "\t    aux->cgroup_storage[stype] != _map)",
            "\t\treturn -EBUSY;",
            "",
            "\taux->cgroup_storage[stype] = _map;",
            "\treturn 0;",
            "}",
            "static size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)",
            "{",
            "\tsize_t size;",
            "",
            "\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {",
            "\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;",
            "\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,",
            "\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;",
            "\t} else {",
            "\t\tsize = map->value_size;",
            "\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),",
            "\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;",
            "\t}",
            "",
            "\treturn size;",
            "}",
            "static void free_shared_cgroup_storage_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct bpf_cgroup_storage *storage =",
            "\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);",
            "",
            "\tkfree(storage->buf);",
            "\tkfree(storage);",
            "}",
            "static void free_percpu_cgroup_storage_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct bpf_cgroup_storage *storage =",
            "\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);",
            "",
            "\tfree_percpu(storage->percpu_buf);",
            "\tkfree(storage);",
            "}",
            "void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)",
            "{",
            "\tenum bpf_cgroup_storage_type stype;",
            "\tstruct bpf_map *map;",
            "",
            "\tif (!storage)",
            "\t\treturn;",
            "",
            "\tmap = &storage->map->map;",
            "\tstype = cgroup_storage_type(map);",
            "\tif (stype == BPF_CGROUP_STORAGE_SHARED)",
            "\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);",
            "\telse",
            "\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);",
            "}",
            "void bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,",
            "\t\t\t     struct cgroup *cgroup,",
            "\t\t\t     enum bpf_attach_type type)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map;",
            "",
            "\tif (!storage)",
            "\t\treturn;",
            "",
            "\tstorage->key.attach_type = type;",
            "\tstorage->key.cgroup_inode_id = cgroup_id(cgroup);",
            "",
            "\tmap = storage->map;",
            "",
            "\tspin_lock_bh(&map->lock);",
            "\tWARN_ON(cgroup_storage_insert(map, storage));",
            "\tlist_add(&storage->list_map, &map->list);",
            "\tlist_add(&storage->list_cg, &cgroup->bpf.storages);",
            "\tspin_unlock_bh(&map->lock);",
            "}"
          ],
          "function_name": "cgroup_storage_seq_show_elem, cgroup_storage_map_usage, bpf_cgroup_storage_assign, bpf_cgroup_storage_calculate_size, free_shared_cgroup_storage_rcu, free_percpu_cgroup_storage_rcu, bpf_cgroup_storage_free, bpf_cgroup_storage_link",
          "description": "包含存储元素序列化显示、内存占用统计、存储分配绑定及RCU安全的内存回收机制，区分共享与per-CPU存储的释放路径。",
          "similarity": 0.5431869626045227
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf.h>",
            "#include <linux/bug.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#ifdef CONFIG_CGROUP_BPF",
            "",
            "#include \"../cgroup/cgroup-internal.h\"",
            "",
            "#define LOCAL_STORAGE_CREATE_FLAG_MASK\t\t\t\t\t\\",
            "\t(BPF_F_NUMA_NODE | BPF_F_ACCESS_MASK)",
            "",
            "struct bpf_cgroup_storage_map {",
            "\tstruct bpf_map map;",
            "",
            "\tspinlock_t lock;",
            "\tstruct rb_root root;",
            "\tstruct list_head list;",
            "};",
            "",
            "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)",
            "{",
            "\treturn container_of(map, struct bpf_cgroup_storage_map, map);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了BPF cgroup存储管理的基础结构，包含红黑树根节点、锁和链表，通过map_to_storage函数将通用map转换为专用存储结构。",
          "similarity": 0.5391499996185303
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 34,
          "end_line": 157,
          "content": [
            "static bool attach_type_isolated(const struct bpf_map *map)",
            "{",
            "\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);",
            "}",
            "static int bpf_cgroup_storage_key_cmp(const struct bpf_cgroup_storage_map *map,",
            "\t\t\t\t      const void *_key1, const void *_key2)",
            "{",
            "\tif (attach_type_isolated(&map->map)) {",
            "\t\tconst struct bpf_cgroup_storage_key *key1 = _key1;",
            "\t\tconst struct bpf_cgroup_storage_key *key2 = _key2;",
            "",
            "\t\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)",
            "\t\t\treturn -1;",
            "\t\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)",
            "\t\t\treturn 1;",
            "\t\telse if (key1->attach_type < key2->attach_type)",
            "\t\t\treturn -1;",
            "\t\telse if (key1->attach_type > key2->attach_type)",
            "\t\t\treturn 1;",
            "\t} else {",
            "\t\tconst __u64 *cgroup_inode_id1 = _key1;",
            "\t\tconst __u64 *cgroup_inode_id2 = _key2;",
            "",
            "\t\tif (*cgroup_inode_id1 < *cgroup_inode_id2)",
            "\t\t\treturn -1;",
            "\t\telse if (*cgroup_inode_id1 > *cgroup_inode_id2)",
            "\t\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,",
            "\t\t\t\t struct bpf_cgroup_storage *storage)",
            "{",
            "\tstruct rb_root *root = &map->root;",
            "\tstruct rb_node **new = &(root->rb_node), *parent = NULL;",
            "",
            "\twhile (*new) {",
            "\t\tstruct bpf_cgroup_storage *this;",
            "",
            "\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);",
            "",
            "\t\tparent = *new;",
            "\t\tswitch (bpf_cgroup_storage_key_cmp(map, &storage->key, &this->key)) {",
            "\t\tcase -1:",
            "\t\t\tnew = &((*new)->rb_left);",
            "\t\t\tbreak;",
            "\t\tcase 1:",
            "\t\t\tnew = &((*new)->rb_right);",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\treturn -EEXIST;",
            "\t\t}",
            "\t}",
            "",
            "\trb_link_node(&storage->node, parent, new);",
            "\trb_insert_color(&storage->node, root);",
            "",
            "\treturn 0;",
            "}",
            "static long cgroup_storage_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t       void *value, u64 flags)",
            "{",
            "\tstruct bpf_cgroup_storage *storage;",
            "\tstruct bpf_storage_buffer *new;",
            "",
            "\tif (unlikely(flags & ~(BPF_F_LOCK | BPF_EXIST)))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely((flags & BPF_F_LOCK) &&",
            "\t\t     !btf_record_has_field(map->record, BPF_SPIN_LOCK)))",
            "\t\treturn -EINVAL;",
            "",
            "\tstorage = cgroup_storage_lookup((struct bpf_cgroup_storage_map *)map,",
            "\t\t\t\t\tkey, false);",
            "\tif (!storage)",
            "\t\treturn -ENOENT;",
            "",
            "\tif (flags & BPF_F_LOCK) {",
            "\t\tcopy_map_value_locked(map, storage->buf->data, value, false);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tnew = bpf_map_kmalloc_node(map, struct_size(new, data, map->value_size),",
            "\t\t\t\t   __GFP_ZERO | GFP_NOWAIT | __GFP_NOWARN,",
            "\t\t\t\t   map->numa_node);",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tmemcpy(&new->data[0], value, map->value_size);",
            "\tcheck_and_init_map_value(map, new->data);",
            "",
            "\tnew = xchg(&storage->buf, new);",
            "\tkfree_rcu(new, rcu);",
            "",
            "\treturn 0;",
            "}",
            "int bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *key,",
            "\t\t\t\t   void *value)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);",
            "\tstruct bpf_cgroup_storage *storage;",
            "\tint cpu, off = 0;",
            "\tu32 size;",
            "",
            "\trcu_read_lock();",
            "\tstorage = cgroup_storage_lookup(map, key, false);",
            "\tif (!storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ENOENT;",
            "\t}",
            "",
            "\t/* per_cpu areas are zero-filled and bpf programs can only",
            "\t * access 'value_size' of them, so copying rounded areas",
            "\t * will not leak any kernel data",
            "\t */",
            "\tsize = round_up(_map->value_size, 8);",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tbpf_long_memcpy(value + off,",
            "\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);",
            "\t\toff += size;",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn 0;",
            "}"
          ],
          "function_name": "attach_type_isolated, bpf_cgroup_storage_key_cmp, cgroup_storage_insert, cgroup_storage_update_elem, bpf_percpu_cgroup_storage_copy",
          "description": "实现了键值比较逻辑、红黑树插入操作、多CPU数据复制及存储更新功能，支持基于cgroup inode ID和attach类型的键区分。",
          "similarity": 0.5239297151565552
        }
      ]
    },
    {
      "source_file": "mm/memfd.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:40:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memfd.c`\n\n---\n\n# memfd.c 技术文档\n\n## 1. 文件概述\n\n`memfd.c` 实现了 Linux 内核中的 `memfd_create()` 系统调用及其配套的文件密封（file sealing）机制。该文件最初是 `shmem.c` 的一部分，后被拆分出来以同时支持 tmpfs 和 hugetlbfs 文件系统。其核心功能包括：\n\n- 创建匿名内存文件（memfd），无需关联磁盘或文件系统路径\n- 提供文件密封（sealing）能力，允许对共享内存区域施加不可逆的操作限制\n- 支持普通页和大页（hugetlb）两种内存分配模式\n- 通过引用计数检测和等待机制确保密封操作的安全性\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|---------|\n| `memfd_alloc_folio()` | 为 memfd 文件分配 folio（页），支持普通页和大页模式 |\n| `memfd_wait_for_pins()` | 等待所有被外部引用（如 GUP、DMA）的 folio 释放，用于 SEAL_WRITE 密封前的安全检查 |\n| `memfd_tag_pins()` | 扫描地址空间，标记具有额外引用计数的 folio |\n| `memfd_add_seals()` | 向文件添加密封标志，实现不可逆的访问控制 |\n| `memfd_get_seals()` | 获取文件当前的密封标志 |\n| `memfd_fcntl()` | 处理 F_ADD_SEALS 和 F_GET_SEALS fcntl 命令 |\n\n### 关键数据结构和常量\n\n- **密封标志**：\n  - `F_SEAL_SEAL`：禁止进一步添加密封\n  - `F_SEAL_WRITE`：禁止写入\n  - `F_SEAL_GROW/SHRINK`：禁止文件增长/缩小\n  - `F_SEAL_EXEC`：禁止修改执行权限位\n  - `F_SEAL_FUTURE_WRITE`：禁止未来写入（与 EXEC 相关）\n\n- **memfd 标志**：\n  - `MFD_CLOEXEC`：close-on-exec\n  - `MFD_ALLOW_SEALING`：允许密封\n  - `MFD_HUGETLB`：使用大页\n  - `MFD_NOEXEC_SEAL` / `MFD_EXEC`：控制执行权限\n\n- **内部标记**：\n  - `MEMFD_TAG_PINNED`：复用 `PAGECACHE_TAG_TOWRITE` 标记被外部引用的 folio\n\n## 3. 关键实现\n\n### 文件密封机制\n\n密封是一种**单向、不可逆**的访问控制机制：\n- 密封只能添加，不能移除\n- 一旦设置 `F_SEAL_SEAL`，不能再添加任何密封\n- 密封作用于整个 inode，影响所有文件描述符\n\n### 引用计数检测算法\n\n为安全实现 `SEAL_WRITE`，内核需确保无外部引用：\n1. **标记阶段** (`memfd_tag_pins`)：\n   - 遍历 radix tree 中的所有 folio\n   - 对 `folio_ref_count() - folio_mapcount() != folio_nr_pages()` 的 folio 标记为 PINNED\n   - 表示存在非映射引用（如 GUP、DMA）\n\n2. **等待阶段** (`memfd_wait_for_pins`)：\n   - 最多进行 5 次扫描（LAST_SCAN = 4）\n   - 指数退避等待（(HZ << scan) / 200）\n   - 最后一次扫描清理标记并返回 `-EBUSY`（如有残留引用）\n\n### 大页支持\n\n通过条件编译支持 hugetlbfs：\n- 检测 `is_file_hugepages()` 判断是否大页模式\n- 使用 `htlb_alloc_mask()` 并清除 `__GFP_HIGHMEM | __GFP_MOVABLE`\n- 调用 hugetlb 专用分配和缓存接口\n\n### 执行权限密封\n\n`F_SEAL_EXEC` 具有特殊语义：\n- 若文件已有执行权限（`i_mode & 0111`），自动添加 `WRITE|GROW|SHRINK|FUTURE_WRITE` 密封\n- 实现 W^X（Write XOR Execute）安全策略\n\n## 4. 依赖关系\n\n### 内核模块依赖\n\n- **内存管理**：\n  - `<linux/mm.h>`：folio 操作、GFP 标志\n  - `<linux/pagemap.h>`：address_space、radix tree 操作\n  - `<linux/shmem_fs.h>`：tmpfs inode 结构（`SHMEM_I`）\n  \n- **文件系统**：\n  - `<linux/hugetlb.h>`：大页支持（`HUGETLBFS_I`）\n  - `<linux/fs.h>` / `<linux/vfs.h>`：VFS 层接口\n  \n- **同步机制**：\n  - `<linux/sched/signal.h>`：可杀等待（`schedule_timeout_killable`）\n  - XArray 锁（`xas_lock_irq`）保证并发安全\n\n### 复用设计\n\n- **标记复用**：使用 `PAGECACHE_TAG_TOWRITE` 作为 `MEMFD_TAG_PINNED`，因 tmpfs/hugetlbfs 不使用此标记\n- **代码共享**：同时服务 tmpfs 和 hugetlbfs，通过 `memfd_file_seals_ptr()` 抽象 inode 访问\n\n## 5. 使用场景\n\n### 用户态应用场景\n\n1. **安全共享内存**：\n   - 多进程通过 `memfd_create()` 创建共享内存\n   - 生产者添加 `SEAL_WRITE` 后传递 fd 给消费者，确保数据不可篡改\n\n2. **动态代码加载**：\n   - JIT 编译器创建可执行 memfd\n   - 写入代码后密封 `SEAL_WRITE`，防止后续修改（配合 `SEAL_EXEC`）\n\n3. **容器/沙箱**：\n   - 限制不受信任进程对共享内存的操作能力\n   - 通过密封防止恶意进程破坏共享状态\n\n### 内核内部使用\n\n1. **GUP（Get User Pages）集成**：\n   - `memfd_alloc_folio()` 被 `gup.c` 调用，处理 memfd 的缺页\n   - 确保 DMA/GUP 场景下密封的安全性\n\n2. **大页优化**：\n   - 通过 `MFD_HUGETLB` 标志创建大页 memfd\n   - 适用于需要大块连续内存的高性能场景（如 DPDK）\n\n3. **安全增强**：\n   - `sysctl_memfd_noexec` 控制默认执行权限\n   - 防止 memfd 被滥用于代码注入攻击",
      "similarity": 0.599263072013855,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/memfd.c",
          "start_line": 275,
          "end_line": 320,
          "content": [
            "static int memfd_get_seals(struct file *file)",
            "{",
            "\tunsigned int *seals = memfd_file_seals_ptr(file);",
            "",
            "\treturn seals ? *seals : -EINVAL;",
            "}",
            "long memfd_fcntl(struct file *file, unsigned int cmd, unsigned int arg)",
            "{",
            "\tlong error;",
            "",
            "\tswitch (cmd) {",
            "\tcase F_ADD_SEALS:",
            "\t\terror = memfd_add_seals(file, arg);",
            "\t\tbreak;",
            "\tcase F_GET_SEALS:",
            "\t\terror = memfd_get_seals(file);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\terror = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int check_sysctl_memfd_noexec(unsigned int *flags)",
            "{",
            "#ifdef CONFIG_SYSCTL",
            "\tstruct pid_namespace *ns = task_active_pid_ns(current);",
            "\tint sysctl = pidns_memfd_noexec_scope(ns);",
            "",
            "\tif (!(*flags & (MFD_EXEC | MFD_NOEXEC_SEAL))) {",
            "\t\tif (sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_SEAL)",
            "\t\t\t*flags |= MFD_NOEXEC_SEAL;",
            "\t\telse",
            "\t\t\t*flags |= MFD_EXEC;",
            "\t}",
            "",
            "\tif (!(*flags & MFD_NOEXEC_SEAL) && sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_ENFORCED) {",
            "\t\tpr_err_ratelimited(",
            "\t\t\t\"%s[%d]: memfd_create() requires MFD_NOEXEC_SEAL with vm.memfd_noexec=%d\\n\",",
            "\t\t\tcurrent->comm, task_pid_nr(current), sysctl);",
            "\t\treturn -EACCES;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "memfd_get_seals, memfd_fcntl, check_sysctl_memfd_noexec",
          "description": "提供密封信息查询接口(memfd_get_seals)和fcntl命令处理(memfd_fcntl)，check_sysctl_memfd_noexec根据内核配置动态调整内存文件执行权限标志，强制应用noexec安全策略。",
          "similarity": 0.6032847166061401
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memfd.c",
          "start_line": 32,
          "end_line": 194,
          "content": [
            "static bool memfd_folio_has_extra_refs(struct folio *folio)",
            "{",
            "\treturn folio_ref_count(folio) - folio_mapcount(folio) !=",
            "\t       folio_nr_pages(folio);",
            "}",
            "static void memfd_tag_pins(struct xa_state *xas)",
            "{",
            "\tstruct folio *folio;",
            "\tint latency = 0;",
            "",
            "\tlru_add_drain();",
            "",
            "\txas_lock_irq(xas);",
            "\txas_for_each(xas, folio, ULONG_MAX) {",
            "\t\tif (!xa_is_value(folio) && memfd_folio_has_extra_refs(folio))",
            "\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);",
            "",
            "\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\tcontinue;",
            "\t\tlatency = 0;",
            "",
            "\t\txas_pause(xas);",
            "\t\txas_unlock_irq(xas);",
            "\t\tcond_resched();",
            "\t\txas_lock_irq(xas);",
            "\t}",
            "\txas_unlock_irq(xas);",
            "}",
            "static int memfd_wait_for_pins(struct address_space *mapping)",
            "{",
            "\tXA_STATE(xas, &mapping->i_pages, 0);",
            "\tstruct folio *folio;",
            "\tint error, scan;",
            "",
            "\tmemfd_tag_pins(&xas);",
            "",
            "\terror = 0;",
            "\tfor (scan = 0; scan <= LAST_SCAN; scan++) {",
            "\t\tint latency = 0;",
            "",
            "\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))",
            "\t\t\tbreak;",
            "",
            "\t\tif (!scan)",
            "\t\t\tlru_add_drain_all();",
            "\t\telse if (schedule_timeout_killable((HZ << scan) / 200))",
            "\t\t\tscan = LAST_SCAN;",
            "",
            "\t\txas_set(&xas, 0);",
            "\t\txas_lock_irq(&xas);",
            "\t\txas_for_each_marked(&xas, folio, ULONG_MAX, MEMFD_TAG_PINNED) {",
            "\t\t\tbool clear = true;",
            "",
            "\t\t\tif (!xa_is_value(folio) &&",
            "\t\t\t    memfd_folio_has_extra_refs(folio)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * On the last scan, we clean up all those tags",
            "\t\t\t\t * we inserted; but make a note that we still",
            "\t\t\t\t * found folios pinned.",
            "\t\t\t\t */",
            "\t\t\t\tif (scan == LAST_SCAN)",
            "\t\t\t\t\terror = -EBUSY;",
            "\t\t\t\telse",
            "\t\t\t\t\tclear = false;",
            "\t\t\t}",
            "\t\t\tif (clear)",
            "\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);",
            "",
            "\t\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\t\tcontinue;",
            "\t\t\tlatency = 0;",
            "",
            "\t\t\txas_pause(&xas);",
            "\t\t\txas_unlock_irq(&xas);",
            "\t\t\tcond_resched();",
            "\t\t\txas_lock_irq(&xas);",
            "\t\t}",
            "\t\txas_unlock_irq(&xas);",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int memfd_add_seals(struct file *file, unsigned int seals)",
            "{",
            "\tstruct inode *inode = file_inode(file);",
            "\tunsigned int *file_seals;",
            "\tint error;",
            "",
            "\t/*",
            "\t * SEALING",
            "\t * Sealing allows multiple parties to share a tmpfs or hugetlbfs file",
            "\t * but restrict access to a specific subset of file operations. Seals",
            "\t * can only be added, but never removed. This way, mutually untrusted",
            "\t * parties can share common memory regions with a well-defined policy.",
            "\t * A malicious peer can thus never perform unwanted operations on a",
            "\t * shared object.",
            "\t *",
            "\t * Seals are only supported on special tmpfs or hugetlbfs files and",
            "\t * always affect the whole underlying inode. Once a seal is set, it",
            "\t * may prevent some kinds of access to the file. Currently, the",
            "\t * following seals are defined:",
            "\t *   SEAL_SEAL: Prevent further seals from being set on this file",
            "\t *   SEAL_SHRINK: Prevent the file from shrinking",
            "\t *   SEAL_GROW: Prevent the file from growing",
            "\t *   SEAL_WRITE: Prevent write access to the file",
            "\t *   SEAL_EXEC: Prevent modification of the exec bits in the file mode",
            "\t *",
            "\t * As we don't require any trust relationship between two parties, we",
            "\t * must prevent seals from being removed. Therefore, sealing a file",
            "\t * only adds a given set of seals to the file, it never touches",
            "\t * existing seals. Furthermore, the \"setting seals\"-operation can be",
            "\t * sealed itself, which basically prevents any further seal from being",
            "\t * added.",
            "\t *",
            "\t * Semantics of sealing are only defined on volatile files. Only",
            "\t * anonymous tmpfs and hugetlbfs files support sealing. More",
            "\t * importantly, seals are never written to disk. Therefore, there's",
            "\t * no plan to support it on other file types.",
            "\t */",
            "",
            "\tif (!(file->f_mode & FMODE_WRITE))",
            "\t\treturn -EPERM;",
            "\tif (seals & ~(unsigned int)F_ALL_SEALS)",
            "\t\treturn -EINVAL;",
            "",
            "\tinode_lock(inode);",
            "",
            "\tfile_seals = memfd_file_seals_ptr(file);",
            "\tif (!file_seals) {",
            "\t\terror = -EINVAL;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif (*file_seals & F_SEAL_SEAL) {",
            "\t\terror = -EPERM;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {",
            "\t\terror = mapping_deny_writable(file->f_mapping);",
            "\t\tif (error)",
            "\t\t\tgoto unlock;",
            "",
            "\t\terror = memfd_wait_for_pins(file->f_mapping);",
            "\t\tif (error) {",
            "\t\t\tmapping_allow_writable(file->f_mapping);",
            "\t\t\tgoto unlock;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * SEAL_EXEC implys SEAL_WRITE, making W^X from the start.",
            "\t */",
            "\tif (seals & F_SEAL_EXEC && inode->i_mode & 0111)",
            "\t\tseals |= F_SEAL_SHRINK|F_SEAL_GROW|F_SEAL_WRITE|F_SEAL_FUTURE_WRITE;",
            "",
            "\t*file_seals |= seals;",
            "\terror = 0;",
            "",
            "unlock:",
            "\tinode_unlock(inode);",
            "\treturn error;",
            "}"
          ],
          "function_name": "memfd_folio_has_extra_refs, memfd_tag_pins, memfd_wait_for_pins, memfd_add_seals",
          "description": "实现内存文件的页引用追踪与密封逻辑，memfd_tag_pins遍历页表标记额外引用页，memfd_wait_for_pins等待所有引用释放后清除标记，memfd_add_seals处理文件密封标志验证及权限限制设置。",
          "similarity": 0.592139482498169
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memfd.c",
          "start_line": 1,
          "end_line": 31,
          "content": [
            "/*",
            " * memfd_create system call and file sealing support",
            " *",
            " * Code was originally included in shmem.c, and broken out to facilitate",
            " * use by hugetlbfs as well as tmpfs.",
            " *",
            " * This file is released under the GPL.",
            " */",
            "",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/memfd.h>",
            "#include <linux/pid_namespace.h>",
            "#include <uapi/linux/memfd.h>",
            "",
            "/*",
            " * We need a tag: a new tag would expand every xa_node by 8 bytes,",
            " * so reuse a tag which we firmly believe is never set or cleared on tmpfs",
            " * or hugetlbfs because they are memory only filesystems.",
            " */",
            "#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE",
            "#define LAST_SCAN               4       /* about 150ms max */",
            ""
          ],
          "function_name": null,
          "description": "定义MEMFD_TAG_PINNED宏用于标识内存文件的特殊页缓存标记，通过复用tmpfs和hugetlbfs中未使用的PAGECACHE_TAG_TOWRITE标签，为后续内存文件的页管理提供标记支持。",
          "similarity": 0.46752113103866577
        }
      ]
    }
  ]
}