{
  "query": "性能计数器",
  "timestamp": "2025-12-26 01:37:20",
  "retrieved_files": [
    {
      "source_file": "kernel/time/timecounter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:54:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timecounter.c`\n\n---\n\n# `time/timecounter.c` 技术文档\n\n## 1. 文件概述\n\n`time/timecounter.c` 实现了 Linux 内核中的 **timecounter** 机制，用于将底层硬件周期计数器（cycle counter）的原始计数值转换为高精度的纳秒时间戳。该机制基于 `cyclecounter` 抽象，能够处理计数器溢出，并支持将任意周期时间戳转换为对应的纳秒时间，广泛应用于网络时间戳、PTP（精确时间协议）等需要高精度时间同步的场景。\n\n## 2. 核心功能\n\n### 数据结构\n- `struct timecounter`：时间计数器抽象，包含指向底层 `cyclecounter` 的指针、上次读取的周期值、当前纳秒时间戳、掩码和分数部分等字段。\n\n### 主要函数\n- `timecounter_init()`：初始化 `timecounter` 实例。\n- `timecounter_read()`：获取当前纳秒时间戳，并更新内部状态。\n- `timecounter_read_delta()`（静态）：计算自上次调用以来经过的纳秒数。\n- `timecounter_cyc2time()`：将给定的周期计数值转换为对应的纳秒时间戳（支持向前或向后转换）。\n- `cc_cyc2ns_backwards()`（静态）：辅助函数，用于反向（历史时间）的周期到纳秒转换。\n\n## 3. 关键实现\n\n### 初始化 (`timecounter_init`)\n- 将用户提供的 `cyclecounter` 指针保存到 `tc->cc`。\n- 读取当前硬件周期值作为 `cycle_last`。\n- 设置初始纳秒时间戳 `nsec` 为 `start_tstamp`。\n- 计算掩码 `mask = (1ULL << cc->shift) - 1`，用于后续溢出处理。\n- 初始化分数部分 `frac = 0`，用于高精度纳秒转换。\n\n### 时间读取 (`timecounter_read`)\n- 调用 `timecounter_read_delta()` 获取自上次读取以来的纳秒增量。\n- 将增量累加到 `tc->nsec`，并返回更新后的时间戳。\n- **注意**：首次调用返回值未定义，仅用于初始化内部状态。\n\n### 增量计算 (`timecounter_read_delta`)\n- 读取当前周期值 `cycle_now`。\n- 计算与上次值的差值 `cycle_delta`，并通过 `& cc->mask` 处理单次溢出。\n- 使用 `cyclecounter_cyc2ns()` 将周期差值转换为纳秒偏移量（含分数精度补偿）。\n- 更新 `cycle_last` 为当前值。\n\n### 周期转时间 (`timecounter_cyc2time`)\n- 计算目标周期 `cycle_tstamp` 与 `cycle_last` 的差值 `delta`。\n- **智能方向判断**：若 `delta > mask / 2`，说明 `cycle_tstamp` 实际是历史时间（因计数器回绕），则反向计算。\n  - 使用 `cc_cyc2ns_backwards()` 从当前纳秒时间减去对应的历史偏移。\n- 否则视为未来时间，使用标准 `cyclecounter_cyc2ns()` 正向累加。\n- 该设计确保即使在计数器溢出边界附近，也能正确解析时间戳。\n\n### 反向转换 (`cc_cyc2ns_backwards`)\n- 与 `cyclecounter_cyc2ns()` 类似，但先减去分数部分再右移，适用于历史时间计算。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/timecounter.h>`：定义 `struct timecounter` 和相关函数原型。\n  - `<linux/export.h>`：提供 `EXPORT_SYMBOL_GPL` 宏，用于导出符号供其他模块使用。\n- **功能依赖**：\n  - 依赖 `cyclecounter` 子系统（定义在 `include/linux/cyclecounter.h`），特别是 `cyclecounter_cyc2ns()` 函数。\n  - 依赖底层硬件驱动提供符合 `cyclecounter` 接口的周期计数器（如 `read()` 函数和 `mask`/`mult`/`shift` 参数）。\n\n## 5. 使用场景\n\n- **网络时间戳**：在网络驱动中，硬件捕获数据包到达/发送时的周期计数值，通过 `timecounter_cyc2time()` 转换为精确的纳秒时间戳，用于 PTP（IEEE 1588）等协议。\n- **高精度定时**：在需要比 `jiffies` 或 `ktime` 更高分辨率的场景中，结合硬件计数器使用。\n- **跨溢出时间计算**：当底层计数器位宽有限（如 32 位）且频率较高时，频繁溢出，`timecounter` 能透明处理单次溢出，保证时间连续性。\n- **时间同步子系统**：作为 PTP 硬件时钟（PHC）实现的基础组件，将硬件寄存器值映射到系统时间域。",
      "similarity": 0.503697395324707,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/timecounter.c",
          "start_line": 8,
          "end_line": 77,
          "content": [
            "void timecounter_init(struct timecounter *tc,",
            "\t\t      const struct cyclecounter *cc,",
            "\t\t      u64 start_tstamp)",
            "{",
            "\ttc->cc = cc;",
            "\ttc->cycle_last = cc->read(cc);",
            "\ttc->nsec = start_tstamp;",
            "\ttc->mask = (1ULL << cc->shift) - 1;",
            "\ttc->frac = 0;",
            "}",
            "static u64 timecounter_read_delta(struct timecounter *tc)",
            "{",
            "\tu64 cycle_now, cycle_delta;",
            "\tu64 ns_offset;",
            "",
            "\t/* read cycle counter: */",
            "\tcycle_now = tc->cc->read(tc->cc);",
            "",
            "\t/* calculate the delta since the last timecounter_read_delta(): */",
            "\tcycle_delta = (cycle_now - tc->cycle_last) & tc->cc->mask;",
            "",
            "\t/* convert to nanoseconds: */",
            "\tns_offset = cyclecounter_cyc2ns(tc->cc, cycle_delta,",
            "\t\t\t\t\ttc->mask, &tc->frac);",
            "",
            "\t/* update time stamp of timecounter_read_delta() call: */",
            "\ttc->cycle_last = cycle_now;",
            "",
            "\treturn ns_offset;",
            "}",
            "u64 timecounter_read(struct timecounter *tc)",
            "{",
            "\tu64 nsec;",
            "",
            "\t/* increment time by nanoseconds since last call */",
            "\tnsec = timecounter_read_delta(tc);",
            "\tnsec += tc->nsec;",
            "\ttc->nsec = nsec;",
            "",
            "\treturn nsec;",
            "}",
            "static u64 cc_cyc2ns_backwards(const struct cyclecounter *cc,",
            "\t\t\t       u64 cycles, u64 mask, u64 frac)",
            "{",
            "\tu64 ns = (u64) cycles;",
            "",
            "\tns = ((ns * cc->mult) - frac) >> cc->shift;",
            "",
            "\treturn ns;",
            "}",
            "u64 timecounter_cyc2time(const struct timecounter *tc,",
            "\t\t\t u64 cycle_tstamp)",
            "{",
            "\tu64 delta = (cycle_tstamp - tc->cycle_last) & tc->cc->mask;",
            "\tu64 nsec = tc->nsec, frac = tc->frac;",
            "",
            "\t/*",
            "\t * Instead of always treating cycle_tstamp as more recent",
            "\t * than tc->cycle_last, detect when it is too far in the",
            "\t * future and treat it as old time stamp instead.",
            "\t */",
            "\tif (delta > tc->cc->mask / 2) {",
            "\t\tdelta = (tc->cycle_last - cycle_tstamp) & tc->cc->mask;",
            "\t\tnsec -= cc_cyc2ns_backwards(tc->cc, delta, tc->mask, frac);",
            "\t} else {",
            "\t\tnsec += cyclecounter_cyc2ns(tc->cc, delta, tc->mask, &frac);",
            "\t}",
            "",
            "\treturn nsec;",
            "}"
          ],
          "function_name": "timecounter_init, timecounter_read_delta, timecounter_read, cc_cyc2ns_backwards, timecounter_cyc2time",
          "description": "实现时间计数器初始化与时间读取逻辑，包含周期计数转纳秒计算、时间差获取及时间戳更新功能",
          "similarity": 0.5802924036979675
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/timecounter.c",
          "start_line": 1,
          "end_line": 7,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Based on clocksource code. See commit 74d23cc704d1",
            " */",
            "#include <linux/export.h>",
            "#include <linux/timecounter.h>",
            ""
          ],
          "function_name": null,
          "description": "声明时间计数器模块的许可证及包含必要头文件，为后续时间计数器实现提供基础",
          "similarity": 0.5584568381309509
        }
      ]
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.497067928314209,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.5448362827301025
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5051948428153992
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.46906375885009766
        }
      ]
    },
    {
      "source_file": "kernel/time/jiffies.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:39:58\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\jiffies.c`\n\n---\n\n# time/jiffies.c 技术文档\n\n## 1. 文件概述\n\n`time/jiffies.c` 实现了一个基于 `jiffies` 的低精度时钟源（clocksource），作为 Linux 内核中最基础、兼容性最强的时钟源。该时钟源适用于所有系统，但精度受限于系统定时器中断频率（HZ），且在无滴答（tickless）系统中不推荐使用。文件还提供了 64 位 jiffies 值的原子读取机制（在 32 位系统上），并支持注册一个经过校准的“refined-jiffies”时钟源以提升精度。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `clocksource_jiffies`：基础 jiffies 时钟源实例，评分为 1（最低有效评分）\n- `jiffies_lock`：用于保护 jiffies 更新的原始自旋锁，SMP 下缓存行对齐\n- `jiffies_seq`：与 `jiffies_lock` 关联的序列计数器（seqcount），用于无锁读取 64 位 jiffies\n- `refined_jiffies`：经校准后的 jiffies 时钟源，评分为 2\n\n### 主要函数\n- `jiffies_read()`：时钟源读取回调函数，返回当前 `jiffies` 值\n- `get_jiffies_64()`（仅 32 位系统）：安全地读取 64 位 `jiffies_64` 值，使用 seqcount 机制避免撕裂读\n- `init_jiffies_clocksource()`：初始化并注册基础 jiffies 时钟源\n- `clocksource_default_clock()`：弱符号函数，提供默认时钟源（回退到 jiffies）\n- `register_refined_jiffies()`：注册一个基于实际定时器频率校准的 refined-jiffies 时钟源\n\n## 3. 关键实现\n\n### Jiffies 时钟源参数\n- **mult/shift**：使用 `TICK_NSEC << JIFFIES_SHIFT` 作为 mult，配合 `JIFFIES_SHIFT` 实现纳秒转换。`TICK_NSEC` 是每个 jiffy 对应的纳秒数（`NSEC_PER_SEC / HZ`）。\n- **mask**：设为 32 位掩码（`CLOCKSOURCE_MASK(32)`），因为 jiffies 本质是 32 位计数器（即使在 64 位系统上，低 32 位也足够表示周期性溢出）。\n- **uncertainty_margin**：设为 32 毫秒，反映其低精度特性。\n- **max_cycles**：限制为 10，防止在高 HZ 系统上因 mult/shift 计算溢出。\n\n### 64 位 Jiffies 安全读取（32 位系统）\n在 `BITS_PER_LONG < 64` 的系统上，`jiffies_64` 是 64 位变量，但无法原子读取。通过 `jiffies_seq` 序列锁实现无锁读取：\n1. 读取序列号\n2. 读取 `jiffies_64`\n3. 检查序列号是否变化（写操作会递增序列号）\n4. 若变化则重试，确保读取一致性\n\n### Refined Jiffies 校准算法\n`register_refined_jiffies()` 根据实际定时器硬件频率（`cycles_per_second`）动态计算更精确的 `mult` 值：\n1. 计算每 tick 的硬件周期数：`cycles_per_tick = (cycles_per_second + HZ/2) / HZ`（四舍五入）\n2. 通过定点运算（<<8 提高精度）计算实际 HZ：`shift_hz = (cycles_per_second << 8) / cycles_per_tick`\n3. 计算每 tick 的纳秒数：`nsec_per_tick = (NSEC_PER_SEC << 8) / shift_hz`\n4. 更新 `refined_jiffies.mult = nsec_per_tick << JIFFIES_SHIFT`\n\n此机制允许在无法提供高精度时钟源的平台上，利用已知的定时器硬件频率提升 jiffies 时钟源的精度。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/clocksource.h>`：时钟源核心接口\n  - `<linux/jiffies.h>`：jiffies 宏定义和全局变量声明\n  - `\"timekeeping.h\"` 和 `\"tick-internal.h\"`：内核时间子系统内部接口\n- **符号依赖**：\n  - `jiffies` / `jiffies_64`：由 `kernel/time/timer.c` 定义\n  - `__clocksource_register()`：时钟源注册接口\n  - `TICK_NSEC` / `JIFFIES_SHIFT`：jiffies 转换常量\n- **导出符号**：\n  - `jiffies`（所有架构）\n  - `get_jiffies_64()`（仅 32 位架构）\n\n## 5. 使用场景\n\n- **系统启动早期**：作为默认时钟源，在高精度时钟源（如 TSC、HPET）初始化前提供基础时间服务。\n- **无高精度时钟硬件平台**：在缺乏可靠硬件计时器的嵌入式或老旧系统中作为后备时钟源。\n- **调试与兼容性**：用于验证时间子系统基础功能，或在高精度时钟源失效时降级使用。\n- **Refined Jiffies 场景**：当平台可提供精确的定时器频率（如某些 ARM SoC）但无独立 clocksource 时，通过 `register_refined_jiffies()` 提升时间精度。\n- **32 位系统**：通过 `get_jiffies_64()` 为需要 64 位时间戳的子系统（如文件系统、网络协议栈）提供安全的长时间计数。",
      "similarity": 0.4966108202934265,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/jiffies.c",
          "start_line": 16,
          "end_line": 65,
          "content": [
            "static u64 jiffies_read(struct clocksource *cs)",
            "{",
            "\treturn (u64) jiffies;",
            "}",
            "u64 get_jiffies_64(void)",
            "{",
            "\tunsigned int seq;",
            "\tu64 ret;",
            "",
            "\tdo {",
            "\t\tseq = read_seqcount_begin(&jiffies_seq);",
            "\t\tret = jiffies_64;",
            "\t} while (read_seqcount_retry(&jiffies_seq, seq));",
            "\treturn ret;",
            "}",
            "static int __init init_jiffies_clocksource(void)",
            "{",
            "\treturn __clocksource_register(&clocksource_jiffies);",
            "}",
            "struct clocksource * __init __weak clocksource_default_clock(void)",
            "{",
            "\treturn &clocksource_jiffies;",
            "}",
            "int register_refined_jiffies(long cycles_per_second)",
            "{",
            "\tu64 nsec_per_tick, shift_hz;",
            "\tlong cycles_per_tick;",
            "",
            "",
            "",
            "\trefined_jiffies = clocksource_jiffies;",
            "\trefined_jiffies.name = \"refined-jiffies\";",
            "\trefined_jiffies.rating++;",
            "",
            "\t/* Calc cycles per tick */",
            "\tcycles_per_tick = (cycles_per_second + HZ/2)/HZ;",
            "\t/* shift_hz stores hz<<8 for extra accuracy */",
            "\tshift_hz = (u64)cycles_per_second << 8;",
            "\tshift_hz += cycles_per_tick/2;",
            "\tdo_div(shift_hz, cycles_per_tick);",
            "\t/* Calculate nsec_per_tick using shift_hz */",
            "\tnsec_per_tick = (u64)NSEC_PER_SEC << 8;",
            "\tnsec_per_tick += (u32)shift_hz/2;",
            "\tdo_div(nsec_per_tick, (u32)shift_hz);",
            "",
            "\trefined_jiffies.mult = ((u32)nsec_per_tick) << JIFFIES_SHIFT;",
            "",
            "\t__clocksource_register(&refined_jiffies);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "jiffies_read, get_jiffies_64, init_jiffies_clocksource, clocksource_default_clock, register_refined_jiffies",
          "description": "定义jiffies时间源读取函数及注册逻辑，调整计时精度参数",
          "similarity": 0.5163627862930298
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/jiffies.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * This file contains the jiffies based clocksource.",
            " *",
            " * Copyright (C) 2004, 2005 IBM, John Stultz (johnstul@us.ibm.com)",
            " */",
            "#include <linux/clocksource.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "",
            "#include \"timekeeping.h\"",
            "#include \"tick-internal.h\"",
            "",
            ""
          ],
          "function_name": null,
          "description": "包含头文件并声明后续函数和结构体定义",
          "similarity": 0.37818992137908936
        }
      ]
    }
  ]
}