{
  "query": "file system logging",
  "timestamp": "2025-12-26 00:25:03",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/log.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:15:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\log.c`\n\n---\n\n# bpf/log.c 技术文档\n\n## 1. 文件概述\n\n`bpf/log.c` 是 Linux 内核 BPF（Berkeley Packet Filter）子系统中负责日志记录的核心实现文件。该文件为 BPF 验证器（verifier）提供灵活、高效的日志输出机制，支持将验证过程中的诊断信息输出到用户空间缓冲区或内核日志（`pr_err`）。日志系统支持两种模式：**固定模式**（`BPF_LOG_FIXED`）和**循环缓冲模式**（默认），并能处理大容量日志的截断、回绕和最终整理，确保用户获得连续、有效的验证日志。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`bpf_verifier_log_attr_valid()`**  \n  验证 `bpf_verifier_log` 结构体的属性是否合法，包括用户缓冲区指针与大小的一致性、日志级别有效性等。\n\n- **`bpf_vlog_init()`**  \n  初始化 `bpf_verifier_log` 结构体，设置日志级别、用户缓冲区指针和大小，并进行合法性校验。\n\n- **`bpf_verifier_vlog()`**  \n  核心日志写入函数，接收格式化字符串和可变参数列表，根据日志模式（固定/循环）将内容写入内核临时缓冲区并复制到用户空间，或直接输出到内核日志。\n\n- **`bpf_vlog_reset()`**  \n  重置日志写入位置（用于回溯验证路径时清理无效日志），并更新用户缓冲区对应位置为 `\\0`。\n\n- **`bpf_vlog_finalize()`**  \n  在验证结束时整理日志内容：若使用循环缓冲且发生回绕，则通过三次反转算法将日志内容原地旋转为从缓冲区开头开始的连续字符串。\n\n- **`bpf_vlog_reverse_kbuf()` / `bpf_vlog_reverse_ubuf()`**  \n  辅助函数，分别用于反转内核临时缓冲区和用户空间日志缓冲区的指定区段，支撑 `bpf_vlog_finalize()` 中的原地旋转算法。\n\n### 关键数据结构\n\n- **`struct bpf_verifier_log`**（定义在 `bpf_verifier.h` 中）  \n  包含日志级别（`level`）、用户缓冲区指针（`ubuf`）、缓冲区总大小（`len_total`）、当前写入结束位置（`end_pos`）、循环缓冲起始位置（`start_pos`）、最大日志长度（`len_max`）以及内核临时缓冲区（`kbuf`）等字段。\n\n## 3. 关键实现\n\n### 日志模式\n\n- **固定模式（`BPF_LOG_FIXED`）**：日志从缓冲区开头顺序写入，超出部分被丢弃。适用于需要完整前缀日志的场景。\n- **循环缓冲模式（默认）**：当日志超出缓冲区大小时，覆盖最早写入的内容，始终保持最新的日志。适用于关注最新错误信息的场景。\n\n### 日志写入流程\n\n1. 使用 `vscnprintf` 将格式化日志写入内核临时缓冲区 `kbuf`（大小为 `BPF_VERIFIER_TMP_LOG_SIZE`）。\n2. 若日志级别为 `BPF_LOG_KERNEL`，直接通过 `pr_err` 输出到内核日志。\n3. 否则，根据日志模式：\n   - **固定模式**：计算可写入用户缓冲区的字节数，调用 `copy_to_user`。\n   - **循环模式**：计算写入位置（可能回绕），分一或两个片段调用 `copy_to_user`。\n\n### 日志最终整理（`bpf_vlog_finalize`）\n\n当使用循环缓冲且日志发生回绕（`start_pos != 0`）时，需将日志整理为从缓冲区开头开始的连续字符串。采用**三次反转原地旋转算法**：\n1. 反转整个缓冲区；\n2. 反转前 `sublen` 字节（原尾部）；\n3. 反转后 `len_total - sublen` 字节（原头部）。  \n该算法避免了大内存分配，仅使用固定大小的内核临时缓冲区 `kbuf` 分块处理用户空间内存。\n\n### 安全与健壮性\n\n- 所有 `copy_to_user`/`copy_from_user` 操作均检查返回值，失败时置空 `ubuf` 指针以禁用后续写入。\n- 对日志长度进行溢出检查（`len_total > UINT_MAX >> 2`）。\n- 使用 `WARN_ON_ONCE` 检测非法重置位置。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<uapi/linux/btf.h>`：BTF（BPF Type Format）相关定义。\n  - `<linux/bpf.h>`：BPF 核心数据结构和常量（如 `BPF_LOG_MASK`、`BPF_LOG_KERNEL`、`BPF_LOG_FIXED`）。\n  - `<linux/bpf_verifier.h>`：`struct bpf_verifier_log` 定义及辅助宏（如 `bpf_verifier_log_needed`）。\n  - `<linux/math64.h>`：提供 `div_u64_rem` 等 64 位除法函数。\n- **内核子系统**：\n  - **BPF 验证器**：作为验证器的输出后端，由 `bpf_verifier.c` 调用。\n  - **用户空间交互**：通过 `copy_to_user`/`copy_from_user` 与用户态 BPF 加载程序（如 `libbpf`）通信。\n\n## 5. 使用场景\n\n- **BPF 程序加载验证**：当用户通过 `bpf(BPF_PROG_LOAD, ...)` 系统调用加载 BPF 程序时，内核验证器在检查程序安全性过程中调用本文件的日志函数，将详细错误或警告信息写入用户提供的日志缓冲区。\n- **调试与诊断**：开发者通过设置 `log_level` 和提供足够大的 `log_buf`，获取验证失败的具体原因（如无效指针访问、未初始化寄存器等）。\n- **内核日志输出**：当 `log_level` 设为 `BPF_LOG_KERNEL` 时，日志直接输出到内核日志（`dmesg`），用于内核开发者调试 BPF 验证器本身。\n- **资源受限环境**：循环缓冲模式允许在有限缓冲区大小下捕获最新的验证日志，适用于嵌入式或内存受限系统。",
      "similarity": 0.6090936064720154,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/log.c",
          "start_line": 15,
          "end_line": 143,
          "content": [
            "static bool bpf_verifier_log_attr_valid(const struct bpf_verifier_log *log)",
            "{",
            "\t/* ubuf and len_total should both be specified (or not) together */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn false;",
            "\t/* log buf without log_level is meaningless */",
            "\tif (log->ubuf && log->level == 0)",
            "\t\treturn false;",
            "\tif (log->level & ~BPF_LOG_MASK)",
            "\t\treturn false;",
            "\tif (log->len_total > UINT_MAX >> 2)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "int bpf_vlog_init(struct bpf_verifier_log *log, u32 log_level,",
            "\t\t  char __user *log_buf, u32 log_size)",
            "{",
            "\tlog->level = log_level;",
            "\tlog->ubuf = log_buf;",
            "\tlog->len_total = log_size;",
            "",
            "\t/* log attributes have to be sane */",
            "\tif (!bpf_verifier_log_attr_valid(log))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_vlog_update_len_max(struct bpf_verifier_log *log, u32 add_len)",
            "{",
            "\t/* add_len includes terminal \\0, so no need for +1. */",
            "\tu64 len = log->end_pos + add_len;",
            "",
            "\t/* log->len_max could be larger than our current len due to",
            "\t * bpf_vlog_reset() calls, so we maintain the max of any length at any",
            "\t * previous point",
            "\t */",
            "\tif (len > UINT_MAX)",
            "\t\tlog->len_max = UINT_MAX;",
            "\telse if (len > log->len_max)",
            "\t\tlog->len_max = len;",
            "}",
            "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,",
            "\t\t       va_list args)",
            "{",
            "\tu64 cur_pos;",
            "\tu32 new_n, n;",
            "",
            "\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);",
            "",
            "\tif (log->level == BPF_LOG_KERNEL) {",
            "\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';",
            "",
            "\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tn += 1; /* include terminating zero */",
            "\tbpf_vlog_update_len_max(log, n);",
            "",
            "\tif (log->level & BPF_LOG_FIXED) {",
            "\t\t/* check if we have at least something to put into user buf */",
            "\t\tnew_n = 0;",
            "\t\tif (log->end_pos < log->len_total) {",
            "\t\t\tnew_n = min_t(u32, log->len_total - log->end_pos, n);",
            "\t\t\tlog->kbuf[new_n - 1] = '\\0';",
            "\t\t}",
            "",
            "\t\tcur_pos = log->end_pos;",
            "\t\tlog->end_pos += n - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (log->ubuf && new_n &&",
            "\t\t    copy_to_user(log->ubuf + cur_pos, log->kbuf, new_n))",
            "\t\t\tgoto fail;",
            "\t} else {",
            "\t\tu64 new_end, new_start;",
            "\t\tu32 buf_start, buf_end, new_n;",
            "",
            "\t\tnew_end = log->end_pos + n;",
            "\t\tif (new_end - log->start_pos >= log->len_total)",
            "\t\t\tnew_start = new_end - log->len_total;",
            "\t\telse",
            "\t\t\tnew_start = log->start_pos;",
            "",
            "\t\tlog->start_pos = new_start;",
            "\t\tlog->end_pos = new_end - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (!log->ubuf)",
            "\t\t\treturn;",
            "",
            "\t\tnew_n = min(n, log->len_total);",
            "\t\tcur_pos = new_end - new_n;",
            "\t\tdiv_u64_rem(cur_pos, log->len_total, &buf_start);",
            "\t\tdiv_u64_rem(new_end, log->len_total, &buf_end);",
            "\t\t/* new_end and buf_end are exclusive indices, so if buf_end is",
            "\t\t * exactly zero, then it actually points right to the end of",
            "\t\t * ubuf and there is no wrap around",
            "\t\t */",
            "\t\tif (buf_end == 0)",
            "\t\t\tbuf_end = log->len_total;",
            "",
            "\t\t/* if buf_start > buf_end, we wrapped around;",
            "\t\t * if buf_start == buf_end, then we fill ubuf completely; we",
            "\t\t * can't have buf_start == buf_end to mean that there is",
            "\t\t * nothing to write, because we always write at least",
            "\t\t * something, even if terminal '\\0'",
            "\t\t */",
            "\t\tif (buf_start < buf_end) {",
            "\t\t\t/* message fits within contiguous chunk of ubuf */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t buf_end - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t} else {",
            "\t\t\t/* message wraps around the end of ubuf, copy in two chunks */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t log->len_total - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t\tif (copy_to_user(log->ubuf,",
            "\t\t\t\t\t log->kbuf + n - buf_end,",
            "\t\t\t\t\t buf_end))",
            "\t\t\t\tgoto fail;",
            "\t\t}",
            "\t}",
            "",
            "\treturn;",
            "fail:",
            "\tlog->ubuf = NULL;",
            "}"
          ],
          "function_name": "bpf_verifier_log_attr_valid, bpf_vlog_init, bpf_vlog_update_len_max, bpf_verifier_vlog",
          "description": "实现日志属性校验、初始化、长度更新及日志写入逻辑，负责管理日志缓冲区的有效性和数据写入操作。",
          "similarity": 0.5655841827392578
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/log.c",
          "start_line": 303,
          "end_line": 462,
          "content": [
            "__printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,",
            "\t\t\t\t\t   const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(&env->log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(2, 3) void bpf_log(struct bpf_verifier_log *log,",
            "\t\t\t    const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(3, 4) void verbose_linfo(struct bpf_verifier_env *env,",
            "\t\t\t\t  u32 insn_off,",
            "\t\t\t\t  const char *prefix_fmt, ...)",
            "{",
            "\tconst struct bpf_line_info *linfo;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tlinfo = find_linfo(env, insn_off);",
            "\tif (!linfo || linfo == env->prev_linfo)",
            "\t\treturn;",
            "",
            "\tif (prefix_fmt) {",
            "\t\tva_list args;",
            "",
            "\t\tva_start(args, prefix_fmt);",
            "\t\tbpf_verifier_vlog(&env->log, prefix_fmt, args);",
            "\t\tva_end(args);",
            "\t}",
            "",
            "\tverbose(env, \"%s\\n\",",
            "\t\tltrim(btf_name_by_offset(env->prog->aux->btf,",
            "\t\t\t\t\t linfo->line_off)));",
            "",
            "\tenv->prev_linfo = linfo;",
            "}",
            "static void print_liveness(struct bpf_verifier_env *env,",
            "\t\t\t   enum bpf_reg_liveness live)",
            "{",
            "\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))",
            "\t    verbose(env, \"_\");",
            "\tif (live & REG_LIVE_READ)",
            "\t\tverbose(env, \"r\");",
            "\tif (live & REG_LIVE_WRITTEN)",
            "\t\tverbose(env, \"w\");",
            "\tif (live & REG_LIVE_DONE)",
            "\t\tverbose(env, \"D\");",
            "}",
            "static bool is_unum_decimal(u64 num)",
            "{",
            "\treturn num <= UNUM_MAX_DECIMAL;",
            "}",
            "static bool is_snum_decimal(s64 num)",
            "{",
            "\treturn num >= SNUM_MIN_DECIMAL && num <= SNUM_MAX_DECIMAL;",
            "}",
            "static void verbose_unum(struct bpf_verifier_env *env, u64 num)",
            "{",
            "\tif (is_unum_decimal(num))",
            "\t\tverbose(env, \"%llu\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "static void verbose_snum(struct bpf_verifier_env *env, s64 num)",
            "{",
            "\tif (is_snum_decimal(num))",
            "\t\tverbose(env, \"%lld\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "int tnum_strn(char *str, size_t size, struct tnum a)",
            "{",
            "\t/* print as a constant, if tnum is fully known */",
            "\tif (a.mask == 0) {",
            "\t\tif (is_unum_decimal(a.value))",
            "\t\t\treturn snprintf(str, size, \"%llu\", a.value);",
            "\t\telse",
            "\t\t\treturn snprintf(str, size, \"%#llx\", a.value);",
            "\t}",
            "\treturn snprintf(str, size, \"(%#llx; %#llx)\", a.value, a.mask);",
            "}",
            "static void print_scalar_ranges(struct bpf_verifier_env *env,",
            "\t\t\t\tconst struct bpf_reg_state *reg,",
            "\t\t\t\tconst char **sep)",
            "{",
            "\t/* For signed ranges, we want to unify 64-bit and 32-bit values in the",
            "\t * output as much as possible, but there is a bit of a complication.",
            "\t * If we choose to print values as decimals, this is natural to do,",
            "\t * because negative 64-bit and 32-bit values >= -S32_MIN have the same",
            "\t * representation due to sign extension. But if we choose to print",
            "\t * them in hex format (see is_snum_decimal()), then sign extension is",
            "\t * misleading.",
            "\t * E.g., smin=-2 and smin32=-2 are exactly the same in decimal, but in",
            "\t * hex they will be smin=0xfffffffffffffffe and smin32=0xfffffffe, two",
            "\t * very different numbers.",
            "\t * So we avoid sign extension if we choose to print values in hex.",
            "\t */",
            "\tstruct {",
            "\t\tconst char *name;",
            "\t\tu64 val;",
            "\t\tbool omit;",
            "\t} minmaxs[] = {",
            "\t\t{\"smin\",   reg->smin_value,         reg->smin_value == S64_MIN},",
            "\t\t{\"smax\",   reg->smax_value,         reg->smax_value == S64_MAX},",
            "\t\t{\"umin\",   reg->umin_value,         reg->umin_value == 0},",
            "\t\t{\"umax\",   reg->umax_value,         reg->umax_value == U64_MAX},",
            "\t\t{\"smin32\",",
            "\t\t is_snum_decimal((s64)reg->s32_min_value)",
            "\t\t\t ? (s64)reg->s32_min_value",
            "\t\t\t : (u32)reg->s32_min_value, reg->s32_min_value == S32_MIN},",
            "\t\t{\"smax32\",",
            "\t\t is_snum_decimal((s64)reg->s32_max_value)",
            "\t\t\t ? (s64)reg->s32_max_value",
            "\t\t\t : (u32)reg->s32_max_value, reg->s32_max_value == S32_MAX},",
            "\t\t{\"umin32\", reg->u32_min_value,      reg->u32_min_value == 0},",
            "\t\t{\"umax32\", reg->u32_max_value,      reg->u32_max_value == U32_MAX},",
            "\t}, *m1, *m2, *mend = &minmaxs[ARRAY_SIZE(minmaxs)];",
            "\tbool neg1, neg2;",
            "",
            "\tfor (m1 = &minmaxs[0]; m1 < mend; m1++) {",
            "\t\tif (m1->omit)",
            "\t\t\tcontinue;",
            "",
            "\t\tneg1 = m1->name[0] == 's' && (s64)m1->val < 0;",
            "",
            "\t\tverbose(env, \"%s%s=\", *sep, m1->name);",
            "\t\t*sep = \",\";",
            "",
            "\t\tfor (m2 = m1 + 2; m2 < mend; m2 += 2) {",
            "\t\t\tif (m2->omit || m2->val != m1->val)",
            "\t\t\t\tcontinue;",
            "\t\t\t/* don't mix negatives with positives */",
            "\t\t\tneg2 = m2->name[0] == 's' && (s64)m2->val < 0;",
            "\t\t\tif (neg2 != neg1)",
            "\t\t\t\tcontinue;",
            "\t\t\tm2->omit = true;",
            "\t\t\tverbose(env, \"%s=\", m2->name);",
            "\t\t}",
            "",
            "\t\tif (m1->name[0] == 's')",
            "\t\t\tverbose_snum(env, m1->val);",
            "\t\telse",
            "\t\t\tverbose_unum(env, m1->val);",
            "\t}",
            "}"
          ],
          "function_name": "bpf_verifier_log_write, bpf_log, verbose_linfo, print_liveness, is_unum_decimal, is_snum_decimal, verbose_unum, verbose_snum, tnum_strn, print_scalar_ranges",
          "description": "包含日志格式化辅助函数，支持指令信息打印、寄存器存活状态显示及数值范围解析等多样化日志输出需求。",
          "similarity": 0.5439445972442627
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/log.c",
          "start_line": 148,
          "end_line": 294,
          "content": [
            "void bpf_vlog_reset(struct bpf_verifier_log *log, u64 new_pos)",
            "{",
            "\tchar zero = 0;",
            "\tu32 pos;",
            "",
            "\tif (WARN_ON_ONCE(new_pos > log->end_pos))",
            "\t\treturn;",
            "",
            "\tif (!bpf_verifier_log_needed(log) || log->level == BPF_LOG_KERNEL)",
            "\t\treturn;",
            "",
            "\t/* if position to which we reset is beyond current log window,",
            "\t * then we didn't preserve any useful content and should adjust",
            "\t * start_pos to end up with an empty log (start_pos == end_pos)",
            "\t */",
            "\tlog->end_pos = new_pos;",
            "\tif (log->end_pos < log->start_pos)",
            "\t\tlog->start_pos = log->end_pos;",
            "",
            "\tif (!log->ubuf)",
            "\t\treturn;",
            "",
            "\tif (log->level & BPF_LOG_FIXED)",
            "\t\tpos = log->end_pos + 1;",
            "\telse",
            "\t\tdiv_u64_rem(new_pos, log->len_total, &pos);",
            "",
            "\tif (pos < log->len_total && put_user(zero, log->ubuf + pos))",
            "\t\tlog->ubuf = NULL;",
            "}",
            "static void bpf_vlog_reverse_kbuf(char *buf, int len)",
            "{",
            "\tint i, j;",
            "",
            "\tfor (i = 0, j = len - 1; i < j; i++, j--)",
            "\t\tswap(buf[i], buf[j]);",
            "}",
            "static int bpf_vlog_reverse_ubuf(struct bpf_verifier_log *log, int start, int end)",
            "{",
            "\t/* we split log->kbuf into two equal parts for both ends of array */",
            "\tint n = sizeof(log->kbuf) / 2, nn;",
            "\tchar *lbuf = log->kbuf, *rbuf = log->kbuf + n;",
            "",
            "\t/* Read ubuf's section [start, end) two chunks at a time, from left",
            "\t * and right side; within each chunk, swap all the bytes; after that",
            "\t * reverse the order of lbuf and rbuf and write result back to ubuf.",
            "\t * This way we'll end up with swapped contents of specified",
            "\t * [start, end) ubuf segment.",
            "\t */",
            "\twhile (end - start > 1) {",
            "\t\tnn = min(n, (end - start ) / 2);",
            "",
            "\t\tif (copy_from_user(lbuf, log->ubuf + start, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_from_user(rbuf, log->ubuf + end - nn, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbpf_vlog_reverse_kbuf(lbuf, nn);",
            "\t\tbpf_vlog_reverse_kbuf(rbuf, nn);",
            "",
            "\t\t/* we write lbuf to the right end of ubuf, while rbuf to the",
            "\t\t * left one to end up with properly reversed overall ubuf",
            "\t\t */",
            "\t\tif (copy_to_user(log->ubuf + start, rbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_to_user(log->ubuf + end - nn, lbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tstart += nn;",
            "\t\tend -= nn;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int bpf_vlog_finalize(struct bpf_verifier_log *log, u32 *log_size_actual)",
            "{",
            "\tu32 sublen;",
            "\tint err;",
            "",
            "\t*log_size_actual = 0;",
            "\tif (!log || log->level == 0 || log->level == BPF_LOG_KERNEL)",
            "\t\treturn 0;",
            "",
            "\tif (!log->ubuf)",
            "\t\tgoto skip_log_rotate;",
            "\t/* If we never truncated log, there is nothing to move around. */",
            "\tif (log->start_pos == 0)",
            "\t\tgoto skip_log_rotate;",
            "",
            "\t/* Otherwise we need to rotate log contents to make it start from the",
            "\t * buffer beginning and be a continuous zero-terminated string. Note",
            "\t * that if log->start_pos != 0 then we definitely filled up entire log",
            "\t * buffer with no gaps, and we just need to shift buffer contents to",
            "\t * the left by (log->start_pos % log->len_total) bytes.",
            "\t *",
            "\t * Unfortunately, user buffer could be huge and we don't want to",
            "\t * allocate temporary kernel memory of the same size just to shift",
            "\t * contents in a straightforward fashion. Instead, we'll be clever and",
            "\t * do in-place array rotation. This is a leetcode-style problem, which",
            "\t * could be solved by three rotations.",
            "\t *",
            "\t * Let's say we have log buffer that has to be shifted left by 7 bytes",
            "\t * (spaces and vertical bar is just for demonstrative purposes):",
            "\t *   E F G H I J K | A B C D",
            "\t *",
            "\t * First, we reverse entire array:",
            "\t *   D C B A | K J I H G F E",
            "\t *",
            "\t * Then we rotate first 4 bytes (DCBA) and separately last 7 bytes",
            "\t * (KJIHGFE), resulting in a properly rotated array:",
            "\t *   A B C D | E F G H I J K",
            "\t *",
            "\t * We'll utilize log->kbuf to read user memory chunk by chunk, swap",
            "\t * bytes, and write them back. Doing it byte-by-byte would be",
            "\t * unnecessarily inefficient. Altogether we are going to read and",
            "\t * write each byte twice, for total 4 memory copies between kernel and",
            "\t * user space.",
            "\t */",
            "",
            "\t/* length of the chopped off part that will be the beginning;",
            "\t * len(ABCD) in the example above",
            "\t */",
            "\tdiv_u64_rem(log->start_pos, log->len_total, &sublen);",
            "\tsublen = log->len_total - sublen;",
            "",
            "\terr = bpf_vlog_reverse_ubuf(log, 0, log->len_total);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, 0, sublen);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, sublen, log->len_total);",
            "\tif (err)",
            "\t\tlog->ubuf = NULL;",
            "",
            "skip_log_rotate:",
            "\t*log_size_actual = log->len_max;",
            "",
            "\t/* properly initialized log has either both ubuf!=NULL and len_total>0",
            "\t * or ubuf==NULL and len_total==0, so if this condition doesn't hold,",
            "\t * we got a fault somewhere along the way, so report it back",
            "\t */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn -EFAULT;",
            "",
            "\t/* did truncation actually happen? */",
            "\tif (log->ubuf && log->len_max > log->len_total)",
            "\t\treturn -ENOSPC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_vlog_reset, bpf_vlog_reverse_kbuf, bpf_vlog_reverse_ubuf, bpf_vlog_finalize",
          "description": "提供日志重置、缓冲区反转及最终化功能，通过旋转日志缓冲区实现连续日志存储并保证数据完整性。",
          "similarity": 0.5411735773086548
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/log.c",
          "start_line": 814,
          "end_line": 830,
          "content": [
            "static inline u32 vlog_alignment(u32 pos)",
            "{",
            "\treturn round_up(max(pos + BPF_LOG_MIN_ALIGNMENT / 2, BPF_LOG_ALIGNMENT),",
            "\t\t\tBPF_LOG_MIN_ALIGNMENT) - pos - 1;",
            "}",
            "void print_insn_state(struct bpf_verifier_env *env, const struct bpf_verifier_state *vstate,",
            "\t\t      u32 frameno)",
            "{",
            "\tif (env->prev_log_pos && env->prev_log_pos == env->log.end_pos) {",
            "\t\t/* remove new line character */",
            "\t\tbpf_vlog_reset(&env->log, env->prev_log_pos - 1);",
            "\t\tverbose(env, \"%*c;\", vlog_alignment(env->prev_insn_print_pos), ' ');",
            "\t} else {",
            "\t\tverbose(env, \"%d:\", env->insn_idx);",
            "\t}",
            "\tprint_verifier_state(env, vstate, frameno, false);",
            "}"
          ],
          "function_name": "vlog_alignment, print_insn_state",
          "description": "该代码片段实现BPF验证日志的格式化输出控制。vlog_alignment函数计算日志记录时所需的对齐空格数量，通过取当前位置到下一个对齐边界的距离实现。print_insn_state函数负责在验证过程中按需输出指令状态信息，通过判断日志位置状态决定是否重置日志并添加对齐符号，但存在依赖未展示的宏定义和print_verifier_state函数，上下文不完整。",
          "similarity": 0.5112699270248413
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/log.c",
          "start_line": 622,
          "end_line": 810,
          "content": [
            "static bool type_is_map_ptr(enum bpf_reg_type t) {",
            "\tswitch (base_type(t)) {",
            "\tcase CONST_PTR_TO_MAP:",
            "\tcase PTR_TO_MAP_KEY:",
            "\tcase PTR_TO_MAP_VALUE:",
            "\t\treturn true;",
            "\tdefault:",
            "\t\treturn false;",
            "\t}",
            "}",
            "static void print_reg_state(struct bpf_verifier_env *env,",
            "\t\t\t    const struct bpf_func_state *state,",
            "\t\t\t    const struct bpf_reg_state *reg)",
            "{",
            "\tenum bpf_reg_type t;",
            "\tconst char *sep = \"\";",
            "",
            "\tt = reg->type;",
            "\tif (t == SCALAR_VALUE && reg->precise)",
            "\t\tverbose(env, \"P\");",
            "\tif (t == SCALAR_VALUE && tnum_is_const(reg->var_off)) {",
            "\t\tverbose_snum(env, reg->var_off.value);",
            "\t\treturn;",
            "\t}",
            "/*",
            " * _a stands for append, was shortened to avoid multiline statements below.",
            " * This macro is used to output a comma separated list of attributes.",
            " */",
            "#define verbose_a(fmt, ...) ({ verbose(env, \"%s\" fmt, sep, ##__VA_ARGS__); sep = \",\"; })",
            "",
            "\tverbose(env, \"%s\", reg_type_str(env, t));",
            "\tif (t == PTR_TO_ARENA)",
            "\t\treturn;",
            "\tif (t == PTR_TO_STACK) {",
            "\t\tif (state->frameno != reg->frameno)",
            "\t\t\tverbose(env, \"[%d]\", reg->frameno);",
            "\t\tif (tnum_is_const(reg->var_off)) {",
            "\t\t\tverbose_snum(env, reg->var_off.value + reg->off);",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "\tif (base_type(t) == PTR_TO_BTF_ID)",
            "\t\tverbose(env, \"%s\", btf_type_name(reg->btf, reg->btf_id));",
            "\tverbose(env, \"(\");",
            "\tif (reg->id)",
            "\t\tverbose_a(\"id=%d\", reg->id & ~BPF_ADD_CONST);",
            "\tif (reg->id & BPF_ADD_CONST)",
            "\t\tverbose(env, \"%+d\", reg->off);",
            "\tif (reg->ref_obj_id)",
            "\t\tverbose_a(\"ref_obj_id=%d\", reg->ref_obj_id);",
            "\tif (type_is_non_owning_ref(reg->type))",
            "\t\tverbose_a(\"%s\", \"non_own_ref\");",
            "\tif (type_is_map_ptr(t)) {",
            "\t\tif (reg->map_ptr->name[0])",
            "\t\t\tverbose_a(\"map=%s\", reg->map_ptr->name);",
            "\t\tverbose_a(\"ks=%d,vs=%d\",",
            "\t\t\t  reg->map_ptr->key_size,",
            "\t\t\t  reg->map_ptr->value_size);",
            "\t}",
            "\tif (t != SCALAR_VALUE && reg->off) {",
            "\t\tverbose_a(\"off=\");",
            "\t\tverbose_snum(env, reg->off);",
            "\t}",
            "\tif (type_is_pkt_pointer(t)) {",
            "\t\tverbose_a(\"r=\");",
            "\t\tverbose_unum(env, reg->range);",
            "\t}",
            "\tif (base_type(t) == PTR_TO_MEM) {",
            "\t\tverbose_a(\"sz=\");",
            "\t\tverbose_unum(env, reg->mem_size);",
            "\t}",
            "\tif (tnum_is_const(reg->var_off)) {",
            "\t\t/* a pointer register with fixed offset */",
            "\t\tif (reg->var_off.value) {",
            "\t\t\tverbose_a(\"imm=\");",
            "\t\t\tverbose_snum(env, reg->var_off.value);",
            "\t\t}",
            "\t} else {",
            "\t\tprint_scalar_ranges(env, reg, &sep);",
            "\t\tif (!tnum_is_unknown(reg->var_off)) {",
            "\t\t\tchar tn_buf[48];",
            "",
            "\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
            "\t\t\tverbose_a(\"var_off=%s\", tn_buf);",
            "\t\t}",
            "\t}",
            "\tverbose(env, \")\");",
            "",
            "#undef verbose_a",
            "}",
            "void print_verifier_state(struct bpf_verifier_env *env, const struct bpf_verifier_state *vstate,",
            "\t\t\t  u32 frameno, bool print_all)",
            "{",
            "\tconst struct bpf_func_state *state = vstate->frame[frameno];",
            "\tconst struct bpf_reg_state *reg;",
            "\tint i;",
            "",
            "\tif (state->frameno)",
            "\t\tverbose(env, \" frame%d:\", state->frameno);",
            "\tfor (i = 0; i < MAX_BPF_REG; i++) {",
            "\t\treg = &state->regs[i];",
            "\t\tif (reg->type == NOT_INIT)",
            "\t\t\tcontinue;",
            "\t\tif (!print_all && !reg_scratched(env, i))",
            "\t\t\tcontinue;",
            "\t\tverbose(env, \" R%d\", i);",
            "\t\tprint_liveness(env, reg->live);",
            "\t\tverbose(env, \"=\");",
            "\t\tprint_reg_state(env, state, reg);",
            "\t}",
            "\tfor (i = 0; i < state->allocated_stack / BPF_REG_SIZE; i++) {",
            "\t\tchar types_buf[BPF_REG_SIZE + 1];",
            "\t\tbool valid = false;",
            "\t\tu8 slot_type;",
            "\t\tint j;",
            "",
            "\t\tif (!print_all && !stack_slot_scratched(env, i))",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (j = 0; j < BPF_REG_SIZE; j++) {",
            "\t\t\tslot_type = state->stack[i].slot_type[j];",
            "\t\t\tif (slot_type != STACK_INVALID)",
            "\t\t\t\tvalid = true;",
            "\t\t\ttypes_buf[j] = slot_type_char[slot_type];",
            "\t\t}",
            "\t\ttypes_buf[BPF_REG_SIZE] = 0;",
            "\t\tif (!valid)",
            "\t\t\tcontinue;",
            "",
            "\t\treg = &state->stack[i].spilled_ptr;",
            "\t\tswitch (state->stack[i].slot_type[BPF_REG_SIZE - 1]) {",
            "\t\tcase STACK_SPILL:",
            "\t\t\t/* print MISC/ZERO/INVALID slots above subreg spill */",
            "\t\t\tfor (j = 0; j < BPF_REG_SIZE; j++)",
            "\t\t\t\tif (state->stack[i].slot_type[j] == STACK_SPILL)",
            "\t\t\t\t\tbreak;",
            "\t\t\ttypes_buf[j] = '\\0';",
            "",
            "\t\t\tverbose(env, \" fp%d\", (-i - 1) * BPF_REG_SIZE);",
            "\t\t\tprint_liveness(env, reg->live);",
            "\t\t\tverbose(env, \"=%s\", types_buf);",
            "\t\t\tprint_reg_state(env, state, reg);",
            "\t\t\tbreak;",
            "\t\tcase STACK_DYNPTR:",
            "\t\t\t/* skip to main dynptr slot */",
            "\t\t\ti += BPF_DYNPTR_NR_SLOTS - 1;",
            "\t\t\treg = &state->stack[i].spilled_ptr;",
            "",
            "\t\t\tverbose(env, \" fp%d\", (-i - 1) * BPF_REG_SIZE);",
            "\t\t\tprint_liveness(env, reg->live);",
            "\t\t\tverbose(env, \"=dynptr_%s\", dynptr_type_str(reg->dynptr.type));",
            "\t\t\tif (reg->ref_obj_id)",
            "\t\t\t\tverbose(env, \"(ref_id=%d)\", reg->ref_obj_id);",
            "\t\t\tbreak;",
            "\t\tcase STACK_ITER:",
            "\t\t\t/* only main slot has ref_obj_id set; skip others */",
            "\t\t\tif (!reg->ref_obj_id)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tverbose(env, \" fp%d\", (-i - 1) * BPF_REG_SIZE);",
            "\t\t\tprint_liveness(env, reg->live);",
            "\t\t\tverbose(env, \"=iter_%s(ref_id=%d,state=%s,depth=%u)\",",
            "\t\t\t\titer_type_str(reg->iter.btf, reg->iter.btf_id),",
            "\t\t\t\treg->ref_obj_id, iter_state_str(reg->iter.state),",
            "\t\t\t\treg->iter.depth);",
            "\t\t\tbreak;",
            "\t\tcase STACK_MISC:",
            "\t\tcase STACK_ZERO:",
            "\t\tdefault:",
            "\t\t\tverbose(env, \" fp%d\", (-i - 1) * BPF_REG_SIZE);",
            "\t\t\tprint_liveness(env, reg->live);",
            "\t\t\tverbose(env, \"=%s\", types_buf);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tif (vstate->acquired_refs && vstate->refs[0].id) {",
            "\t\tverbose(env, \" refs=%d\", vstate->refs[0].id);",
            "\t\tfor (i = 1; i < vstate->acquired_refs; i++)",
            "\t\t\tif (vstate->refs[i].id)",
            "\t\t\t\tverbose(env, \",%d\", vstate->refs[i].id);",
            "\t}",
            "\tif (state->in_callback_fn)",
            "\t\tverbose(env, \" cb\");",
            "\tif (state->in_async_callback_fn)",
            "\t\tverbose(env, \" async_cb\");",
            "\tverbose(env, \"\\n\");",
            "\tif (!print_all)",
            "\t\tmark_verifier_state_clean(env);",
            "}"
          ],
          "function_name": "type_is_map_ptr, print_reg_state, print_verifier_state",
          "description": "实现类型判断与状态打印功能，用于展示寄存器状态细节和验证器整体状态信息，辅助进行BPF程序调试分析。",
          "similarity": 0.49059703946113586
        }
      ]
    },
    {
      "source_file": "kernel/latencytop.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:31:05\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `latencytop.c`\n\n---\n\n# latencytop.c 技术文档\n\n## 1. 文件概述\n\n`latencytop.c` 实现了 Linux 内核中的延迟追踪基础设施，用于支持用户空间工具 `latencytop`。该机制并非追踪传统意义上的中断延迟（如 CPU 被其他任务占用），而是追踪应用程序因内核代表其睡眠（如等待 I/O、锁、资源等）而产生的延迟。延迟信息通过 `/proc/latency_stats`（系统级）和 `/proc/<pid>/latency`（进程级）导出，帮助开发者识别导致应用响应延迟的内核路径。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct latency_record`：存储延迟记录，包含：\n  - `count`：该延迟原因发生的次数\n  - `time`：累计延迟时间（微秒）\n  - `max`：单次最大延迟时间（微秒）\n  - `backtrace[LT_BACKTRACEDEPTH]`：字符串化的调用栈（函数地址）\n- `latency_record[MAXLR]`：全局系统级延迟记录数组（`MAXLR = 128`）\n- `latencytop_enabled`：全局开关，控制是否启用延迟追踪\n\n### 主要函数\n- `__account_scheduler_latency()`：核心入口函数，由调度器调用，记录一次延迟事件\n- `account_global_scheduler_latency()`：将延迟记录合并到全局统计中\n- `clear_tsk_latency_tracing()`：清除指定任务的延迟记录\n- `clear_global_latency_tracing()`：清除全局延迟记录\n- `lstats_show()`：生成 `/proc/latency_stats` 的输出内容\n- `lstats_write()`：清空全局延迟记录（通过写 `/proc/latency_stats` 触发）\n- `init_lstats_procfs()`：初始化 `/proc/latency_stats` 和 sysctl 接口\n\n### Sysctl 接口\n- `/proc/sys/kernel/latencytop`：控制 `latencytop_enabled` 开关，启用时自动开启调度统计（`force_schedstat_enabled()`）\n\n## 3. 关键实现\n\n### 延迟记录机制\n- **调用栈捕获**：使用 `stack_trace_save_tsk()` 获取当前任务在调度点的调用栈（深度为 `LT_BACKTRACEDEPTH`）。\n- **去重合并**：通过比较调用栈内容，将相同原因的延迟事件合并为一条记录，更新 `count`、`time` 和 `max`。\n- **存储限制**：\n  - 全局记录最多 `MAXLR`（128）条，满后不再记录新原因。\n  - 每个任务最多记录 `LT_SAVECOUNT` 条（代码中硬编码为 32，注释称未来会优化为循环覆盖）。\n\n### 过滤策略\n- **跳过长可中断睡眠**：若睡眠可中断（`inter == 1`）且超过 5 毫秒（5000 微秒），视为用户主动等待（如 `select()`），不记录。\n- **忽略无效延迟**：负值或零延迟（可能由时间回退引起）被直接丢弃。\n- **跳过内核线程**：仅追踪用户进程（`tsk->mm != NULL`）。\n\n### 并发控制\n- 使用 `raw_spinlock_t latency_lock` 保护全局和进程级延迟记录的读写，确保多 CPU 环境下的数据一致性。\n\n### 输出格式\n`/proc/latency_stats` 每行格式为：\n```\n<count> <accumulated_time> <max_time> <func1> <func2> ... <funcN>\n```\n其中：\n- `count`：延迟原因发生次数\n- `accumulated_time`：累计延迟时间（微秒）\n- `max_time`：单次最大延迟时间（微秒）\n- 后续字段为调用栈函数符号（通过 `%ps` 格式化解析）\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/latencytop.h>`：定义 `struct latency_record` 和 `LT_BACKTRACEDEPTH`、`LT_SAVECOUNT` 等常量。\n  - `<linux/stacktrace.h>`：提供 `stack_trace_save_tsk()` 用于捕获调用栈。\n  - `<linux/sched/stat.h>`：提供 `force_schedstat_enabled()`，确保调度统计开启。\n  - `<linux/proc_fs.h>`、`<linux/sysctl.h>`：实现 `/proc` 和 sysctl 接口。\n- **内核配置依赖**：\n  - `CONFIG_LATENCYTOP`：启用该功能。\n  - `CONFIG_SCHEDSTATS`：延迟追踪依赖调度统计信息。\n- **用户空间工具**：需配合 `latencytop` 工具解析 `/proc` 输出并可视化延迟原因。\n\n## 5. 使用场景\n\n- **性能调优**：开发者使用 `latencytop` 工具实时监控系统或特定进程的延迟热点，定位内核中导致应用卡顿的代码路径（如锁竞争、I/O 等待）。\n- **系统诊断**：在实时性要求高的场景（如音视频处理、工业控制）中，分析不可接受的延迟来源。\n- **内核开发**：验证新代码是否引入了意外的延迟，或评估调度器/子系统优化效果。\n- **动态启用**：通过写 `/proc/sys/kernel/latencytop` 动态开启/关闭追踪，避免常驻开销。用户工具定期读取并清空 `/proc/latency_stats` 以持续收集新数据。",
      "similarity": 0.5743923783302307,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/latencytop.c",
          "start_line": 242,
          "end_line": 287,
          "content": [
            "static int lstats_show(struct seq_file *m, void *v)",
            "{",
            "\tint i;",
            "",
            "\tseq_puts(m, \"Latency Top version : v0.1\\n\");",
            "",
            "\tfor (i = 0; i < MAXLR; i++) {",
            "\t\tstruct latency_record *lr = &latency_record[i];",
            "",
            "\t\tif (lr->backtrace[0]) {",
            "\t\t\tint q;",
            "\t\t\tseq_printf(m, \"%i %lu %lu\",",
            "\t\t\t\t   lr->count, lr->time, lr->max);",
            "\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {",
            "\t\t\t\tunsigned long bt = lr->backtrace[q];",
            "",
            "\t\t\t\tif (!bt)",
            "\t\t\t\t\tbreak;",
            "",
            "\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);",
            "\t\t\t}",
            "\t\t\tseq_puts(m, \"\\n\");",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "static ssize_t",
            "lstats_write(struct file *file, const char __user *buf, size_t count,",
            "\t     loff_t *offs)",
            "{",
            "\tclear_global_latency_tracing();",
            "",
            "\treturn count;",
            "}",
            "static int lstats_open(struct inode *inode, struct file *filp)",
            "{",
            "\treturn single_open(filp, lstats_show, NULL);",
            "}",
            "static int __init init_lstats_procfs(void)",
            "{",
            "\tproc_create(\"latency_stats\", 0644, NULL, &lstats_proc_ops);",
            "#ifdef CONFIG_SYSCTL",
            "\tregister_sysctl_init(\"kernel\", latencytop_sysctl);",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "lstats_show, lstats_write, lstats_open, init_lstats_procfs",
          "description": "提供延迟统计信息的导出接口，包含延迟数据序列化展示函数lstats_show、清除全局记录的写入接口lstats_write及proc文件系统初始化函数init_lstats_procfs，通过/proc文件系统暴露延迟统计信息。",
          "similarity": 0.5408698320388794
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/latencytop.c",
          "start_line": 1,
          "end_line": 67,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * latencytop.c: Latency display infrastructure",
            " *",
            " * (C) Copyright 2008 Intel Corporation",
            " * Author: Arjan van de Ven <arjan@linux.intel.com>",
            " */",
            "",
            "/*",
            " * CONFIG_LATENCYTOP enables a kernel latency tracking infrastructure that is",
            " * used by the \"latencytop\" userspace tool. The latency that is tracked is not",
            " * the 'traditional' interrupt latency (which is primarily caused by something",
            " * else consuming CPU), but instead, it is the latency an application encounters",
            " * because the kernel sleeps on its behalf for various reasons.",
            " *",
            " * This code tracks 2 levels of statistics:",
            " * 1) System level latency",
            " * 2) Per process latency",
            " *",
            " * The latency is stored in fixed sized data structures in an accumulated form;",
            " * if the \"same\" latency cause is hit twice, this will be tracked as one entry",
            " * in the data structure. Both the count, total accumulated latency and maximum",
            " * latency are tracked in this data structure. When the fixed size structure is",
            " * full, no new causes are tracked until the buffer is flushed by writing to",
            " * the /proc file; the userspace tool does this on a regular basis.",
            " *",
            " * A latency cause is identified by a stringified backtrace at the point that",
            " * the scheduler gets invoked. The userland tool will use this string to",
            " * identify the cause of the latency in human readable form.",
            " *",
            " * The information is exported via /proc/latency_stats and /proc/<pid>/latency.",
            " * These files look like this:",
            " *",
            " * Latency Top version : v0.1",
            " * 70 59433 4897 i915_irq_wait drm_ioctl vfs_ioctl do_vfs_ioctl sys_ioctl",
            " * |    |    |    |",
            " * |    |    |    +----> the stringified backtrace",
            " * |    |    +---------> The maximum latency for this entry in microseconds",
            " * |    +--------------> The accumulated latency for this entry (microseconds)",
            " * +-------------------> The number of times this entry is hit",
            " *",
            " * (note: the average latency is the accumulated latency divided by the number",
            " * of times)",
            " */",
            "",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/notifier.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/list.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sysctl.h>",
            "",
            "static DEFINE_RAW_SPINLOCK(latency_lock);",
            "",
            "#define MAXLR 128",
            "static struct latency_record latency_record[MAXLR];",
            "",
            "int latencytop_enabled;",
            "",
            "#ifdef CONFIG_SYSCTL"
          ],
          "function_name": null,
          "description": "定义延迟跟踪的全局数据结构和锁，包括固定大小的延迟记录数组latency_record，用于存储进程和系统级别的延迟统计信息，通过SPDX许可证注释表明GPL许可。",
          "similarity": 0.5354743003845215
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/latencytop.c",
          "start_line": 68,
          "end_line": 209,
          "content": [
            "static int sysctl_latencytop(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos)",
            "{",
            "\tint err;",
            "",
            "\terr = proc_dointvec(table, write, buffer, lenp, ppos);",
            "\tif (latencytop_enabled)",
            "\t\tforce_schedstat_enabled();",
            "",
            "\treturn err;",
            "}",
            "void clear_tsk_latency_tracing(struct task_struct *p)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&latency_lock, flags);",
            "\tmemset(&p->latency_record, 0, sizeof(p->latency_record));",
            "\tp->latency_record_count = 0;",
            "\traw_spin_unlock_irqrestore(&latency_lock, flags);",
            "}",
            "static void clear_global_latency_tracing(void)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&latency_lock, flags);",
            "\tmemset(&latency_record, 0, sizeof(latency_record));",
            "\traw_spin_unlock_irqrestore(&latency_lock, flags);",
            "}",
            "static void __sched",
            "account_global_scheduler_latency(struct task_struct *tsk,",
            "\t\t\t\t struct latency_record *lat)",
            "{",
            "\tint firstnonnull = MAXLR;",
            "\tint i;",
            "",
            "\t/* skip kernel threads for now */",
            "\tif (!tsk->mm)",
            "\t\treturn;",
            "",
            "\tfor (i = 0; i < MAXLR; i++) {",
            "\t\tint q, same = 1;",
            "",
            "\t\t/* Nothing stored: */",
            "\t\tif (!latency_record[i].backtrace[0]) {",
            "\t\t\tif (firstnonnull > i)",
            "\t\t\t\tfirstnonnull = i;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {",
            "\t\t\tunsigned long record = lat->backtrace[q];",
            "",
            "\t\t\tif (latency_record[i].backtrace[q] != record) {",
            "\t\t\t\tsame = 0;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\t/* 0 entry marks end of backtrace: */",
            "\t\t\tif (!record)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (same) {",
            "\t\t\tlatency_record[i].count++;",
            "\t\t\tlatency_record[i].time += lat->time;",
            "\t\t\tif (lat->time > latency_record[i].max)",
            "\t\t\t\tlatency_record[i].max = lat->time;",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\ti = firstnonnull;",
            "\tif (i >= MAXLR)",
            "\t\treturn;",
            "",
            "\t/* Allocted a new one: */",
            "\tmemcpy(&latency_record[i], lat, sizeof(struct latency_record));",
            "}",
            "void __sched",
            "__account_scheduler_latency(struct task_struct *tsk, int usecs, int inter)",
            "{",
            "\tunsigned long flags;",
            "\tint i, q;",
            "\tstruct latency_record lat;",
            "",
            "\t/* Long interruptible waits are generally user requested... */",
            "\tif (inter && usecs > 5000)",
            "\t\treturn;",
            "",
            "\t/* Negative sleeps are time going backwards */",
            "\t/* Zero-time sleeps are non-interesting */",
            "\tif (usecs <= 0)",
            "\t\treturn;",
            "",
            "\tmemset(&lat, 0, sizeof(lat));",
            "\tlat.count = 1;",
            "\tlat.time = usecs;",
            "\tlat.max = usecs;",
            "",
            "\tstack_trace_save_tsk(tsk, lat.backtrace, LT_BACKTRACEDEPTH, 0);",
            "",
            "\traw_spin_lock_irqsave(&latency_lock, flags);",
            "",
            "\taccount_global_scheduler_latency(tsk, &lat);",
            "",
            "\tfor (i = 0; i < tsk->latency_record_count; i++) {",
            "\t\tstruct latency_record *mylat;",
            "\t\tint same = 1;",
            "",
            "\t\tmylat = &tsk->latency_record[i];",
            "\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {",
            "\t\t\tunsigned long record = lat.backtrace[q];",
            "",
            "\t\t\tif (mylat->backtrace[q] != record) {",
            "\t\t\t\tsame = 0;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\t/* 0 entry is end of backtrace */",
            "\t\t\tif (!record)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (same) {",
            "\t\t\tmylat->count++;",
            "\t\t\tmylat->time += lat.time;",
            "\t\t\tif (lat.time > mylat->max)",
            "\t\t\t\tmylat->max = lat.time;",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * short term hack; if we're > 32 we stop; future we recycle:",
            "\t */",
            "\tif (tsk->latency_record_count >= LT_SAVECOUNT)",
            "\t\tgoto out_unlock;",
            "",
            "\t/* Allocated a new one: */",
            "\ti = tsk->latency_record_count++;",
            "\tmemcpy(&tsk->latency_record[i], &lat, sizeof(struct latency_record));",
            "",
            "out_unlock:",
            "\traw_spin_unlock_irqrestore(&latency_lock, flags);",
            "}"
          ],
          "function_name": "sysctl_latencytop, clear_tsk_latency_tracing, clear_global_latency_tracing, account_global_scheduler_latency, __account_scheduler_latency",
          "description": "实现延迟跟踪的控制接口与数据维护逻辑，包含启用配置参数处理、任务级延迟记录清除、全局延迟记录清除及调度器延迟统计收集函数，通过堆栈跟踪比对实现延迟原因去重与聚合。",
          "similarity": 0.499648779630661
        }
      ]
    },
    {
      "source_file": "kernel/watchdog.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:51:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watchdog.c`\n\n---\n\n# watchdog.c 技术文档\n\n## 1. 文件概述\n\n`watchdog.c` 是 Linux 内核中实现 **硬锁死（hard lockup）** 和 **软锁死（soft lockup）** 检测机制的核心文件。该机制用于监控系统中 CPU 是否因长时间禁用中断或陷入无限循环而无法响应，从而帮助诊断系统挂死问题。硬锁死指 CPU 完全停止响应中断（包括 NMI），软锁死指内核线程长时间占用 CPU 且未调度其他任务。本文件主要聚焦于硬锁死检测的通用框架和部分实现，软锁死检测逻辑主要在其他文件（如 `softlockup.c`）中实现，但两者共享部分配置和控制逻辑。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `watchdog_enabled`：位掩码，表示当前启用的 watchdog 类型（软/硬锁死检测）。\n- `watchdog_user_enabled`：用户空间是否启用 watchdog（默认 1）。\n- `watchdog_hardlockup_user_enabled`：用户空间是否启用硬锁死检测（默认值取决于架构）。\n- `watchdog_softlockup_user_enabled`：用户空间是否启用软锁死检测（默认 1）。\n- `watchdog_thresh`：锁死检测阈值（秒，默认 10 秒）。\n- `watchdog_cpumask`：参与 watchdog 检测的 CPU 掩码。\n- `hardlockup_panic`：硬锁死发生时是否触发内核 panic（默认由 `CONFIG_BOOTPARAM_HARDLOCKUP_PANIC` 决定）。\n- `sysctl_hardlockup_all_cpu_backtrace`（SMP）：硬锁死时是否打印所有 CPU 的 backtrace。\n- `hardlockup_count`（SYSFS）：记录硬锁死事件发生次数。\n\n### 主要函数\n- `hardlockup_detector_disable(void)`：在启动早期禁用硬锁死检测（例如虚拟机环境）。\n- `hardlockup_panic_setup(char *str)`：解析内核启动参数 `nmi_watchdog=`，配置硬锁死行为。\n- `arch_touch_nmi_watchdog(void)`：架构相关函数，用于在关键路径“触摸”硬 watchdog，防止误报（导出符号）。\n- `watchdog_hardlockup_touch_cpu(unsigned int cpu)`：标记指定 CPU 已被“触摸”。\n- `is_hardlockup(unsigned int cpu)`：检查指定 CPU 是否发生硬锁死（基于高精度定时器中断计数）。\n- `watchdog_hardlockup_kick(void)`：在高精度定时器中断中“踢”硬 watchdog（更新中断计数）。\n- `watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs)`：执行硬锁死检测逻辑，打印诊断信息并可能触发 panic。\n- `watchdog_hardlockup_enable/disable(unsigned int cpu)`：弱符号函数，由具体硬 watchdog 实现（如 perf-based）覆盖，用于启停 per-CPU 检测。\n- `watchdog_hardlockup_probe(void)`：弱符号函数，由具体实现提供，用于探测硬 watchdog 硬件/机制是否可用。\n\n### 核心数据结构（Per-CPU）\n- `hrtimer_interrupts`：高精度定时器中断计数器（原子变量）。\n- `hrtimer_interrupts_saved`：上次保存的中断计数值。\n- `watchdog_hardlockup_warned`：是否已为该 CPU 打印过硬锁死警告。\n- `watchdog_hardlockup_touched`：该 CPU 是否被“触摸”过（用于豁免检测）。\n\n## 3. 关键实现\n\n### 硬锁死检测机制（基于高精度定时器）\n当配置 `CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER` 时，硬锁死检测通过监控 **高精度定时器（hrtimer）中断** 的发生频率实现：\n1. **计数更新**：每次 hrtimer 中断发生时，调用 `watchdog_hardlockup_kick()` 原子递增 per-CPU 计数器 `hrtimer_interrupts`。\n2. **检测逻辑**：在 NMI（不可屏蔽中断）上下文（或其他检测点）调用 `watchdog_hardlockup_check()`：\n   - 若 CPU 被“触摸”（`watchdog_hardlockup_touched` 为真），则清除此标记并跳过检测。\n   - 否则调用 `is_hardlockup()`：比较当前 `hrtimer_interrupts` 与上次保存值 `hrtimer_interrupts_saved`。若相等，说明在检测周期内无 hrtimer 中断，判定为硬锁死。\n3. **告警与处理**：\n   - 首次检测到硬锁死时，打印紧急日志（CPU 信息、模块列表、中断跟踪、寄存器状态或栈回溯）。\n   - 若启用 `sysctl_hardlockup_all_cpu_backtrace`，触发其他 CPU 的 backtrace。\n   - 若 `hardlockup_panic` 为真，调用 `nmi_panic()` 触发内核 panic。\n   - 设置 `watchdog_hardlockup_warned` 避免重复告警。\n\n### 启动参数与配置\n- **`nmi_watchdog=` 参数**：通过 `__setup` 宏注册，支持以下值：\n  - `panic`/`nopanic`：设置 `hardlockup_panic`。\n  - `0`/`1`：启用/禁用硬锁死检测。\n  - `r...`：传递参数给 perf-based 检测器（`hardlockup_config_perf_event`）。\n- **早期禁用**：`hardlockup_detector_disable()` 可在解析命令行前禁用硬检测（如 KVM guest）。\n\n### 架构交互与豁免\n- **`arch_touch_nmi_watchdog()`**：允许架构代码或关键内核路径（如 printk）临时豁免硬 watchdog 检测，防止在已知安全的长操作中误报。使用 `raw_cpu_write` 确保在抢占/中断使能环境下安全。\n\n### 弱符号扩展点\n- `watchdog_hardlockup_enable/disable/probe` 声明为 `__weak`，允许不同架构或检测方法（如基于 perf event 的 NMI watchdog）提供具体实现，实现检测机制的可插拔。\n\n## 4. 依赖关系\n\n- **内核子系统**：\n  - `<linux/nmi.h>`：NMI 处理框架，硬锁死检测通常在 NMI 上下文触发。\n  - `<linux/hrtimer.h>`（隐含）：高精度定时器中断作为检测心跳源。\n  - `<linux/sched/*.h>`：调度器相关（`print_irqtrace_events`, `dump_stack`）。\n  - `<linux/sysctl.h>`：提供 `sysctl_hardlockup_all_cpu_backtrace` 控制接口。\n  - `<linux/sysfs.h>`：暴露 `hardlockup_count` 到 sysfs。\n  - `<asm/irq_regs.h>`：获取中断上下文寄存器状态（`show_regs`）。\n- **配置选项**：\n  - `CONFIG_HARDLOCKUP_DETECTOR`：启用硬锁死检测框架。\n  - `CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER`：使用 hrtimer 中断计数实现检测。\n  - `CONFIG_HARDLOCKUP_DETECTOR_SPARC64`：SPARC64 架构默认启用硬检测。\n  - `CONFIG_BOOTPARAM_HARDLOCKUP_PANIC`：设置默认 panic 行为。\n  - `CONFIG_SMP`：多核支持（`all_cpu_backtrace` 功能）。\n  - `CONFIG_SYSFS`：sysfs 接口支持。\n- **其他模块**：依赖具体架构的 NMI 实现（如 x86 的 perf-based NMI watchdog）提供检测触发点。\n\n## 5. 使用场景\n\n- **系统稳定性监控**：在生产服务器或嵌入式设备中持续监控 CPU 响应性，及时发现硬件故障、驱动 bug 或内核死锁导致的系统挂死。\n- **内核调试**：开发人员通过 watchdog 触发的 backtrace 和寄存器转储，定位导致系统无响应的代码路径。\n- **虚拟化环境**：在 hypervisor guest 中可选择性禁用硬 watchdog（因虚拟化开销可能导致误报），通过 `hardlockup_detector_disable()` 或启动参数控制。\n- **实时系统**：结合 CPU 隔离（`isolcpus`）和 watchdog 配置，确保关键 CPU 核心的响应性，同时避免在非关键核上产生干扰。\n- **panic 策略**：通过 `hardlockup_panic` 配置，使系统在硬锁死时自动重启，提高无人值守系统的可用性。",
      "similarity": 0.5735354423522949,
      "chunks": [
        {
          "chunk_id": 7,
          "file_path": "kernel/watchdog.c",
          "start_line": 1114,
          "end_line": 1190,
          "content": [
            "int proc_watchdog_cpumask(struct ctl_table *table, int write,",
            "\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint err;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "",
            "\terr = proc_do_large_bitmap(table, write, buffer, lenp, ppos);",
            "\tif (!err && write)",
            "\t\tproc_watchdog_update(false);",
            "",
            "\tmutex_unlock(&watchdog_mutex);",
            "\treturn err;",
            "}",
            "static void __init watchdog_sysctl_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", watchdog_sysctls);",
            "",
            "\tif (watchdog_hardlockup_available)",
            "\t\twatchdog_hardlockup_sysctl[0].mode = 0644;",
            "\tregister_sysctl_init(\"kernel\", watchdog_hardlockup_sysctl);",
            "}",
            "static void __init lockup_detector_delay_init(struct work_struct *work)",
            "{",
            "\tint ret;",
            "",
            "\tret = watchdog_hardlockup_probe();",
            "\tif (ret) {",
            "\t\tif (ret == -ENODEV)",
            "\t\t\tpr_info(\"NMI not fully supported\\n\");",
            "\t\telse",
            "\t\t\tpr_info(\"Delayed init of the lockup detector failed: %d\\n\", ret);",
            "\t\tpr_info(\"Hard watchdog permanently disabled\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tallow_lockup_detector_init_retry = false;",
            "",
            "\twatchdog_hardlockup_available = true;",
            "\tlockup_detector_setup();",
            "}",
            "void __init lockup_detector_retry_init(void)",
            "{",
            "\t/* Must be called before late init calls */",
            "\tif (!allow_lockup_detector_init_retry)",
            "\t\treturn;",
            "",
            "\tschedule_work(&detector_work);",
            "}",
            "static int __init lockup_detector_check(void)",
            "{",
            "\t/* Prevent any later retry. */",
            "\tallow_lockup_detector_init_retry = false;",
            "",
            "\t/* Make sure no work is pending. */",
            "\tflush_work(&detector_work);",
            "",
            "\twatchdog_sysctl_init();",
            "",
            "\treturn 0;",
            "",
            "}",
            "void __init lockup_detector_init(void)",
            "{",
            "\tif (tick_nohz_full_enabled())",
            "\t\tpr_info(\"Disabling watchdog on nohz_full cores by default\\n\");",
            "",
            "\tcpumask_copy(&watchdog_cpumask,",
            "\t\t     housekeeping_cpumask(HK_TYPE_TIMER));",
            "",
            "\tif (!watchdog_hardlockup_probe())",
            "\t\twatchdog_hardlockup_available = true;",
            "\telse",
            "\t\tallow_lockup_detector_init_retry = true;",
            "",
            "\tlockup_detector_setup();",
            "}"
          ],
          "function_name": "proc_watchdog_cpumask, watchdog_sysctl_init, lockup_detector_delay_init, lockup_detector_retry_init, lockup_detector_check, lockup_detector_init",
          "description": "实现看门狗子系统的初始化流程，包含sysctl参数注册、延迟初始化工作队列、CPU掩码配置及探测器状态同步机制",
          "similarity": 0.5274595022201538
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/watchdog.c",
          "start_line": 73,
          "end_line": 217,
          "content": [
            "static ssize_t hardlockup_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\t     char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%u\\n\", hardlockup_count);",
            "}",
            "static __init int kernel_hardlockup_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &hardlockup_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "void __init hardlockup_detector_disable(void)",
            "{",
            "\twatchdog_hardlockup_user_enabled = 0;",
            "}",
            "static int __init hardlockup_panic_setup(char *str)",
            "{",
            "next:",
            "\tif (!strncmp(str, \"panic\", 5))",
            "\t\thardlockup_panic = 1;",
            "\telse if (!strncmp(str, \"nopanic\", 7))",
            "\t\thardlockup_panic = 0;",
            "\telse if (!strncmp(str, \"0\", 1))",
            "\t\twatchdog_hardlockup_user_enabled = 0;",
            "\telse if (!strncmp(str, \"1\", 1))",
            "\t\twatchdog_hardlockup_user_enabled = 1;",
            "\telse if (!strncmp(str, \"r\", 1))",
            "\t\thardlockup_config_perf_event(str + 1);",
            "\twhile (*(str++)) {",
            "\t\tif (*str == ',') {",
            "\t\t\tstr++;",
            "\t\t\tgoto next;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}",
            "notrace void arch_touch_nmi_watchdog(void)",
            "{",
            "\t/*",
            "\t * Using __raw here because some code paths have",
            "\t * preemption enabled.  If preemption is enabled",
            "\t * then interrupts should be enabled too, in which",
            "\t * case we shouldn't have to worry about the watchdog",
            "\t * going off.",
            "\t */",
            "\traw_cpu_write(watchdog_hardlockup_touched, true);",
            "}",
            "void watchdog_hardlockup_touch_cpu(unsigned int cpu)",
            "{",
            "\tper_cpu(watchdog_hardlockup_touched, cpu) = true;",
            "}",
            "static bool is_hardlockup(unsigned int cpu)",
            "{",
            "\tint hrint = atomic_read(&per_cpu(hrtimer_interrupts, cpu));",
            "",
            "\tif (per_cpu(hrtimer_interrupts_saved, cpu) == hrint)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * NOTE: we don't need any fancy atomic_t or READ_ONCE/WRITE_ONCE",
            "\t * for hrtimer_interrupts_saved. hrtimer_interrupts_saved is",
            "\t * written/read by a single CPU.",
            "\t */",
            "\tper_cpu(hrtimer_interrupts_saved, cpu) = hrint;",
            "",
            "\treturn false;",
            "}",
            "static void watchdog_hardlockup_kick(void)",
            "{",
            "\tint new_interrupts;",
            "",
            "\tnew_interrupts = atomic_inc_return(this_cpu_ptr(&hrtimer_interrupts));",
            "\twatchdog_buddy_check_hardlockup(new_interrupts);",
            "}",
            "void watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs)",
            "{",
            "\tif (per_cpu(watchdog_hardlockup_touched, cpu)) {",
            "\t\tper_cpu(watchdog_hardlockup_touched, cpu) = false;",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Check for a hardlockup by making sure the CPU's timer",
            "\t * interrupt is incrementing. The timer interrupt should have",
            "\t * fired multiple times before we overflow'd. If it hasn't",
            "\t * then this is a good indication the cpu is stuck",
            "\t */",
            "\tif (is_hardlockup(cpu)) {",
            "\t\tunsigned int this_cpu = smp_processor_id();",
            "\t\tunsigned long flags;",
            "",
            "#ifdef CONFIG_SYSFS",
            "\t\t++hardlockup_count;",
            "#endif",
            "",
            "\t\t/* Only print hardlockups once. */",
            "\t\tif (per_cpu(watchdog_hardlockup_warned, cpu))",
            "\t\t\treturn;",
            "",
            "\t\t/*",
            "\t\t * Prevent multiple hard-lockup reports if one cpu is already",
            "\t\t * engaged in dumping all cpu back traces.",
            "\t\t */",
            "\t\tif (sysctl_hardlockup_all_cpu_backtrace) {",
            "\t\t\tif (test_and_set_bit_lock(0, &hard_lockup_nmi_warn))",
            "\t\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * NOTE: we call printk_cpu_sync_get_irqsave() after printing",
            "\t\t * the lockup message. While it would be nice to serialize",
            "\t\t * that printout, we really want to make sure that if some",
            "\t\t * other CPU somehow locked up while holding the lock associated",
            "\t\t * with printk_cpu_sync_get_irqsave() that we can still at least",
            "\t\t * get the message about the lockup out.",
            "\t\t */",
            "\t\tpr_emerg(\"CPU%u: Watchdog detected hard LOCKUP on cpu %u\\n\", this_cpu, cpu);",
            "\t\tprintk_cpu_sync_get_irqsave(flags);",
            "",
            "\t\tprint_modules();",
            "\t\tprint_irqtrace_events(current);",
            "\t\tif (cpu == this_cpu) {",
            "\t\t\tif (regs)",
            "\t\t\t\tshow_regs(regs);",
            "\t\t\telse",
            "\t\t\t\tdump_stack();",
            "\t\t\tprintk_cpu_sync_put_irqrestore(flags);",
            "\t\t} else {",
            "\t\t\tprintk_cpu_sync_put_irqrestore(flags);",
            "\t\t\ttrigger_single_cpu_backtrace(cpu);",
            "\t\t}",
            "",
            "\t\tif (sysctl_hardlockup_all_cpu_backtrace) {",
            "\t\t\ttrigger_allbutcpu_cpu_backtrace(cpu);",
            "\t\t\tif (!hardlockup_panic)",
            "\t\t\t\tclear_bit_unlock(0, &hard_lockup_nmi_warn);",
            "\t\t}",
            "",
            "\t\tif (hardlockup_panic)",
            "\t\t\tnmi_panic(regs, \"Hard LOCKUP\");",
            "",
            "\t\tper_cpu(watchdog_hardlockup_warned, cpu) = true;",
            "\t} else {",
            "\t\tper_cpu(watchdog_hardlockup_warned, cpu) = false;",
            "\t}",
            "}"
          ],
          "function_name": "hardlockup_count_show, kernel_hardlockup_sysfs_init, hardlockup_detector_disable, hardlockup_panic_setup, arch_touch_nmi_watchdog, watchdog_hardlockup_touch_cpu, is_hardlockup, watchdog_hardlockup_kick, watchdog_hardlockup_check",
          "description": "实现硬锁检测核心逻辑，包含硬锁判断、计数统计、NMI触发电路及异常上报功能，通过中断计数器检测CPU卡顿。",
          "similarity": 0.5159614086151123
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watchdog.c",
          "start_line": 257,
          "end_line": 357,
          "content": [
            "static inline void watchdog_hardlockup_kick(void) { }",
            "void __weak watchdog_hardlockup_enable(unsigned int cpu) { }",
            "void __weak watchdog_hardlockup_disable(unsigned int cpu) { }",
            "int __weak __init watchdog_hardlockup_probe(void)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "void __weak watchdog_hardlockup_stop(void) { }",
            "void __weak watchdog_hardlockup_start(void) { }",
            "static void lockup_detector_update_enable(void)",
            "{",
            "\twatchdog_enabled = 0;",
            "\tif (!watchdog_user_enabled)",
            "\t\treturn;",
            "\tif (watchdog_hardlockup_available && watchdog_hardlockup_user_enabled)",
            "\t\twatchdog_enabled |= WATCHDOG_HARDLOCKUP_ENABLED;",
            "\tif (watchdog_softlockup_user_enabled)",
            "\t\twatchdog_enabled |= WATCHDOG_SOFTOCKUP_ENABLED;",
            "}",
            "static ssize_t softlockup_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\t     char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%u\\n\", softlockup_count);",
            "}",
            "static __init int kernel_softlockup_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &softlockup_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "static int __init softlockup_panic_setup(char *str)",
            "{",
            "\tsoftlockup_panic = simple_strtoul(str, NULL, 0);",
            "\treturn 1;",
            "}",
            "static int __init nowatchdog_setup(char *str)",
            "{",
            "\twatchdog_user_enabled = 0;",
            "\treturn 1;",
            "}",
            "static int __init nosoftlockup_setup(char *str)",
            "{",
            "\twatchdog_softlockup_user_enabled = 0;",
            "\treturn 1;",
            "}",
            "static int __init watchdog_thresh_setup(char *str)",
            "{",
            "\tget_option(&str, &watchdog_thresh);",
            "\treturn 1;",
            "}",
            "static u16 get_16bit_precision(u64 data_ns)",
            "{",
            "\treturn data_ns >> 24LL; /* 2^24ns ~= 16.8ms */",
            "}",
            "static void update_cpustat(void)",
            "{",
            "\tint i;",
            "\tu8 util;",
            "\tu16 old_stat, new_stat;",
            "\tstruct kernel_cpustat kcpustat;",
            "\tu64 *cpustat = kcpustat.cpustat;",
            "\tu8 tail = __this_cpu_read(cpustat_tail);",
            "\tu16 sample_period_16 = get_16bit_precision(sample_period);",
            "",
            "\tkcpustat_cpu_fetch(&kcpustat, smp_processor_id());",
            "",
            "\tfor (i = 0; i < NUM_STATS_PER_GROUP; i++) {",
            "\t\told_stat = __this_cpu_read(cpustat_old[i]);",
            "\t\tnew_stat = get_16bit_precision(cpustat[tracked_stats[i]]);",
            "\t\tutil = DIV_ROUND_UP(100 * (new_stat - old_stat), sample_period_16);",
            "\t\t__this_cpu_write(cpustat_util[tail][i], util);",
            "\t\t__this_cpu_write(cpustat_old[i], new_stat);",
            "\t}",
            "",
            "\t__this_cpu_write(cpustat_tail, (tail + 1) % NUM_SAMPLE_PERIODS);",
            "}",
            "static void print_cpustat(void)",
            "{",
            "\tint i, group;",
            "\tu8 tail = __this_cpu_read(cpustat_tail);",
            "\tu64 sample_period_second = sample_period;",
            "",
            "\tdo_div(sample_period_second, NSEC_PER_SEC);",
            "",
            "\t/*",
            "\t * Outputting the \"watchdog\" prefix on every line is redundant and not",
            "\t * concise, and the original alarm information is sufficient for",
            "\t * positioning in logs, hence here printk() is used instead of pr_crit().",
            "\t */",
            "\tprintk(KERN_CRIT \"CPU#%d Utilization every %llus during lockup:\\n\",",
            "\t       smp_processor_id(), sample_period_second);",
            "",
            "\tfor (i = 0; i < NUM_SAMPLE_PERIODS; i++) {",
            "\t\tgroup = (tail + i) % NUM_SAMPLE_PERIODS;",
            "\t\tprintk(KERN_CRIT \"\\t#%d: %3u%% system,\\t%3u%% softirq,\\t\"",
            "\t\t\t\"%3u%% hardirq,\\t%3u%% idle\\n\", i + 1,",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_SYSTEM]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_SOFTIRQ]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_HARDIRQ]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_IDLE]));",
            "\t}",
            "}"
          ],
          "function_name": "watchdog_hardlockup_kick, watchdog_hardlockup_enable, watchdog_hardlockup_disable, watchdog_hardlockup_probe, watchdog_hardlockup_stop, watchdog_hardlockup_start, lockup_detector_update_enable, softlockup_count_show, kernel_softlockup_sysfs_init, softlockup_panic_setup, nowatchdog_setup, nosoftlockup_setup, watchdog_thresh_setup, get_16bit_precision, update_cpustat, print_cpustat",
          "description": "提供软锁检测支持，包含统计周期设置、CPU利用率采集、中断事件追踪等辅助功能，维护软锁检测相关状态机。",
          "similarity": 0.510827898979187
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/watchdog.c",
          "start_line": 946,
          "end_line": 1059,
          "content": [
            "void lockup_detector_reconfigure(void)",
            "{",
            "\tmutex_lock(&watchdog_mutex);",
            "\t__lockup_detector_reconfigure(false);",
            "\tmutex_unlock(&watchdog_mutex);",
            "}",
            "static __init void lockup_detector_setup(void)",
            "{",
            "\t/*",
            "\t * If sysctl is off and watchdog got disabled on the command line,",
            "\t * nothing to do here.",
            "\t */",
            "\tlockup_detector_update_enable();",
            "",
            "\tif (!IS_ENABLED(CONFIG_SYSCTL) &&",
            "\t    !(watchdog_enabled && watchdog_thresh))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "\t__lockup_detector_reconfigure(false);",
            "\tsoftlockup_initialized = true;",
            "\tmutex_unlock(&watchdog_mutex);",
            "}",
            "static void __lockup_detector_reconfigure(bool thresh_changed)",
            "{",
            "\tcpus_read_lock();",
            "\twatchdog_hardlockup_stop();",
            "\tif (thresh_changed)",
            "\t\twatchdog_thresh = READ_ONCE(watchdog_thresh_next);",
            "\tlockup_detector_update_enable();",
            "\twatchdog_hardlockup_start();",
            "\tcpus_read_unlock();",
            "}",
            "void lockup_detector_reconfigure(void)",
            "{",
            "\t__lockup_detector_reconfigure(false);",
            "}",
            "static inline void lockup_detector_setup(void)",
            "{",
            "\t__lockup_detector_reconfigure(false);",
            "}",
            "void lockup_detector_soft_poweroff(void)",
            "{",
            "\twatchdog_enabled = 0;",
            "}",
            "static void proc_watchdog_update(bool thresh_changed)",
            "{",
            "\t/* Remove impossible cpus to keep sysctl output clean. */",
            "\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);",
            "\t__lockup_detector_reconfigure(thresh_changed);",
            "}",
            "static int proc_watchdog_common(int which, struct ctl_table *table, int write,",
            "\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint err, old, *param = table->data;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "",
            "\told = *param;",
            "\tif (!write) {",
            "\t\t/*",
            "\t\t * On read synchronize the userspace interface. This is a",
            "\t\t * racy snapshot.",
            "\t\t */",
            "\t\t*param = (watchdog_enabled & which) != 0;",
            "\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\t\t*param = old;",
            "\t} else {",
            "\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\t\tif (!err && old != READ_ONCE(*param))",
            "\t\t\tproc_watchdog_update(false);",
            "\t}",
            "\tmutex_unlock(&watchdog_mutex);",
            "\treturn err;",
            "}",
            "int proc_watchdog(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn proc_watchdog_common(WATCHDOG_HARDLOCKUP_ENABLED |",
            "\t\t\t\t    WATCHDOG_SOFTOCKUP_ENABLED,",
            "\t\t\t\t    table, write, buffer, lenp, ppos);",
            "}",
            "int proc_nmi_watchdog(struct ctl_table *table, int write,",
            "\t\t      void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tif (!watchdog_hardlockup_available && write)",
            "\t\treturn -ENOTSUPP;",
            "\treturn proc_watchdog_common(WATCHDOG_HARDLOCKUP_ENABLED,",
            "\t\t\t\t    table, write, buffer, lenp, ppos);",
            "}",
            "int proc_soft_watchdog(struct ctl_table *table, int write,",
            "\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn proc_watchdog_common(WATCHDOG_SOFTOCKUP_ENABLED,",
            "\t\t\t\t    table, write, buffer, lenp, ppos);",
            "}",
            "int proc_watchdog_thresh(struct ctl_table *table, int write,",
            "\t\t\t void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint err, old;",
            "",
            "\tmutex_lock(&watchdog_mutex);",
            "",
            "\twatchdog_thresh_next = READ_ONCE(watchdog_thresh);",
            "",
            "\told = watchdog_thresh_next;",
            "\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "",
            "\tif (!err && write && old != READ_ONCE(watchdog_thresh_next))",
            "\t\tproc_watchdog_update(true);",
            "",
            "\tmutex_unlock(&watchdog_mutex);",
            "\treturn err;",
            "}"
          ],
          "function_name": "lockup_detector_reconfigure, lockup_detector_setup, __lockup_detector_reconfigure, lockup_detector_reconfigure, lockup_detector_setup, lockup_detector_soft_poweroff, proc_watchdog_update, proc_watchdog_common, proc_watchdog, proc_nmi_watchdog, proc_soft_watchdog, proc_watchdog_thresh",
          "description": "提供看门狗参数动态配置接口，包含阈值更新、CPU掩码同步、sysctl参数读写控制逻辑，支持硬/软锁步检测模式切换和阈值调节",
          "similarity": 0.5088366270065308
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/watchdog.c",
          "start_line": 494,
          "end_line": 595,
          "content": [
            "static void tabulate_irq_count(struct irq_counts *irq_counts, int irq, u32 counts, int rank)",
            "{",
            "\tint i;",
            "\tstruct irq_counts new_count = {irq, counts};",
            "",
            "\tfor (i = 0; i < rank; i++) {",
            "\t\tif (counts > irq_counts[i].counts)",
            "\t\t\tswap(new_count, irq_counts[i]);",
            "\t}",
            "}",
            "static bool need_counting_irqs(void)",
            "{",
            "\tu8 util;",
            "\tint tail = __this_cpu_read(cpustat_tail);",
            "",
            "\ttail = (tail + NUM_HARDIRQ_REPORT - 1) % NUM_HARDIRQ_REPORT;",
            "\tutil = __this_cpu_read(cpustat_util[tail][STATS_HARDIRQ]);",
            "\treturn util > HARDIRQ_PERCENT_THRESH;",
            "}",
            "static void start_counting_irqs(void)",
            "{",
            "\tif (!__this_cpu_read(snapshot_taken)) {",
            "\t\tkstat_snapshot_irqs();",
            "\t\t__this_cpu_write(snapshot_taken, true);",
            "\t}",
            "}",
            "static void stop_counting_irqs(void)",
            "{",
            "\t__this_cpu_write(snapshot_taken, false);",
            "}",
            "static void print_irq_counts(void)",
            "{",
            "\tunsigned int i, count;",
            "\tstruct irq_counts irq_counts_sorted[NUM_HARDIRQ_REPORT] = {",
            "\t\t{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}",
            "\t};",
            "",
            "\tif (__this_cpu_read(snapshot_taken)) {",
            "\t\tfor_each_active_irq(i) {",
            "\t\t\tcount = kstat_get_irq_since_snapshot(i);",
            "\t\t\ttabulate_irq_count(irq_counts_sorted, i, count, NUM_HARDIRQ_REPORT);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Outputting the \"watchdog\" prefix on every line is redundant and not",
            "\t\t * concise, and the original alarm information is sufficient for",
            "\t\t * positioning in logs, hence here printk() is used instead of pr_crit().",
            "\t\t */",
            "\t\tprintk(KERN_CRIT \"CPU#%d Detect HardIRQ Time exceeds %d%%. Most frequent HardIRQs:\\n\",",
            "\t\t       smp_processor_id(), HARDIRQ_PERCENT_THRESH);",
            "",
            "\t\tfor (i = 0; i < NUM_HARDIRQ_REPORT; i++) {",
            "\t\t\tif (irq_counts_sorted[i].irq == -1)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\tprintk(KERN_CRIT \"\\t#%u: %-10u\\tirq#%d\\n\",",
            "\t\t\t       i + 1, irq_counts_sorted[i].counts,",
            "\t\t\t       irq_counts_sorted[i].irq);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If the hardirq time is less than HARDIRQ_PERCENT_THRESH% in the last",
            "\t\t * sample_period, then we suspect the interrupt storm might be subsiding.",
            "\t\t */",
            "\t\tif (!need_counting_irqs())",
            "\t\t\tstop_counting_irqs();",
            "\t}",
            "}",
            "static void report_cpu_status(void)",
            "{",
            "\tprint_cpustat();",
            "\tprint_irq_counts();",
            "}",
            "static inline void update_cpustat(void) { }",
            "static inline void report_cpu_status(void) { }",
            "static inline bool need_counting_irqs(void) { return false; }",
            "static inline void start_counting_irqs(void) { }",
            "static inline void stop_counting_irqs(void) { }",
            "static int get_softlockup_thresh(void)",
            "{",
            "\treturn watchdog_thresh * 2;",
            "}",
            "static unsigned long get_timestamp(void)",
            "{",
            "\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */",
            "}",
            "static void set_sample_period(void)",
            "{",
            "\t/*",
            "\t * convert watchdog_thresh from seconds to ns",
            "\t * the divide by 5 is to give hrtimer several chances (two",
            "\t * or three with the current relation between the soft",
            "\t * and hard thresholds) to increment before the",
            "\t * hardlockup detector generates a warning",
            "\t */",
            "\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / NUM_SAMPLE_PERIODS);",
            "\twatchdog_update_hrtimer_threshold(sample_period);",
            "}",
            "static void update_report_ts(void)",
            "{",
            "\t__this_cpu_write(watchdog_report_ts, get_timestamp());",
            "}"
          ],
          "function_name": "tabulate_irq_count, need_counting_irqs, start_counting_irqs, stop_counting_irqs, print_irq_counts, report_cpu_status, update_cpustat, report_cpu_status, need_counting_irqs, start_counting_irqs, stop_counting_irqs, get_softlockup_thresh, get_timestamp, set_sample_period, update_report_ts",
          "description": "实现中断统计分析模块，通过记录中断次数分布识别潜在中断风暴，为软锁检测提供上下文信息。",
          "similarity": 0.5013073682785034
        }
      ]
    }
  ]
}