{
  "query": "银行家算法资源分配安全检查实现",
  "timestamp": "2025-12-26 01:08:32",
  "retrieved_files": [
    {
      "source_file": "mm/shuffle.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:21:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `shuffle.c`\n\n---\n\n# shuffle.c 技术文档\n\n## 1. 文件概述\n\n`shuffle.c` 实现了 Linux 内核内存管理子系统中的**页面分配随机化（Page Allocation Shuffling）**功能。该机制通过在内存初始化阶段对空闲页面链表进行 Fisher-Yates 洗牌操作，降低物理页帧分配的可预测性，从而增强系统安全性，抵御基于内存布局预测的攻击（如堆喷射、地址泄露等）。该功能默认关闭，可通过内核启动参数 `shuffle=1` 启用。\n\n## 2. 核心功能\n\n### 数据结构与全局变量\n- `page_alloc_shuffle_key`：静态分支键（static key），用于运行时启用/禁用洗牌逻辑，减少未启用时的性能开销。\n- `shuffle_param`：模块参数布尔值，控制是否启用洗牌功能。\n- `shuffle_param_ops`：自定义模块参数操作集，用于处理 `shuffle` 参数的设置和读取。\n\n### 主要函数\n- `shuffle_param_set()`：解析并设置 `shuffle` 内核参数，若启用则激活 `page_alloc_shuffle_key`。\n- `shuffle_valid_page()`：验证指定 PFN 的页面是否满足洗牌条件（属于 buddy 系统、同 zone、空闲、相同 order 和 migratetype）。\n- `__shuffle_zone()`：对指定内存区域（zone）执行 Fisher-Yates 洗牌算法，随机交换同阶空闲页面。\n- `__shuffle_free_memory()`：遍历节点（pgdat）中所有 zone，依次调用 `shuffle_zone()` 进行洗牌。\n- `shuffle_pick_tail()`：提供轻量级随机位生成器，用于在分配时决定从链表头部还是尾部取页（增强运行时随机性）。\n\n## 3. 关键实现\n\n### 洗牌算法（Fisher-Yates）\n- **粒度**：以 `SHUFFLE_ORDER`（通常为 0，即单页）为单位进行洗牌。\n- **范围**：遍历 zone 内所有按 order 对齐的 PFN，对每个有效页面 `page_i` 随机选择另一个有效页面 `page_j` 进行交换。\n- **有效性校验**：通过 `shuffle_valid_page()` 确保交换双方均为 buddy 系统管理的空闲页，且具有相同的迁移类型（migratetype）。\n- **重试机制**：最多尝试 `SHUFFLE_RETRY`（10 次）寻找有效的随机目标页，避免因内存空洞导致失败。\n- **锁优化**：每处理 100 个页面后释放 zone 自旋锁并调度，防止长时间持锁影响系统响应。\n\n### 随机性来源\n- 使用 `get_random_long()` 获取高质量伪随机数作为洗牌索引。\n- `shuffle_pick_tail()` 使用无锁的 64 位随机状态生成器，每次返回最低位并右移，用于运行时分配策略的微调。\n\n### 安全性权衡\n- 明确承认不消除模运算偏差（modulo bias）或 PRNG 偏差，目标是“提高攻击门槛”而非完美随机。\n- 仅在内存初始化阶段（`__meminit`）执行一次洗牌，不影响运行时分配性能。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`、`<linux/mmzone.h>`：内存管理核心数据结构（`struct zone`, `struct page`）。\n  - `<linux/random.h>`：提供 `get_random_long()` 和 `get_random_u64()`。\n  - `\"internal.h\"`、`\"shuffle.h\"`：内核 MM 子系统内部接口及洗牌功能声明。\n- **功能依赖**：\n  - Buddy 分配器：依赖 `PageBuddy()`、`buddy_order()` 等接口判断页面状态。\n  - 页面迁移类型（Migratetype）：确保洗牌不破坏不同迁移类型页面的隔离。\n  - 静态分支（Static Keys）：通过 `static_branch_enable()` 动态启用洗牌路径。\n\n## 5. 使用场景\n\n- **安全加固**：在需要防范物理地址预测攻击的场景（如虚拟化宿主机、安全敏感设备）中启用，增加攻击者利用内存布局漏洞的难度。\n- **内核初始化**：在 `free_area_init_core()` 等内存子系统初始化流程中调用 `__shuffle_free_memory()`，对初始空闲内存进行一次性洗牌。\n- **运行时分配辅助**：`shuffle_pick_tail()` 被页面分配器调用，决定从空闲链表头/尾取页，进一步增加分配时序的不可预测性。\n- **调试支持**：通过 `pr_debug()` 输出洗牌失败或迁移类型不匹配的日志，便于问题诊断（需开启 `DEBUG_SHUFFLE`）。",
      "similarity": 0.5548757910728455,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/shuffle.c",
          "start_line": 16,
          "end_line": 121,
          "content": [
            "static __meminit int shuffle_param_set(const char *val,",
            "\t\tconst struct kernel_param *kp)",
            "{",
            "\tif (param_set_bool(val, kp))",
            "\t\treturn -EINVAL;",
            "\tif (*(bool *)kp->arg)",
            "\t\tstatic_branch_enable(&page_alloc_shuffle_key);",
            "\treturn 0;",
            "}",
            "void __meminit __shuffle_zone(struct zone *z)",
            "{",
            "\tunsigned long i, flags;",
            "\tunsigned long start_pfn = z->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(z);",
            "\tconst int order = SHUFFLE_ORDER;",
            "\tconst int order_pages = 1 << order;",
            "",
            "\tspin_lock_irqsave(&z->lock, flags);",
            "\tstart_pfn = ALIGN(start_pfn, order_pages);",
            "\tfor (i = start_pfn; i < end_pfn; i += order_pages) {",
            "\t\tunsigned long j;",
            "\t\tint migratetype, retry;",
            "\t\tstruct page *page_i, *page_j;",
            "",
            "\t\t/*",
            "\t\t * We expect page_i, in the sub-range of a zone being added",
            "\t\t * (@start_pfn to @end_pfn), to more likely be valid compared to",
            "\t\t * page_j randomly selected in the span @zone_start_pfn to",
            "\t\t * @spanned_pages.",
            "\t\t */",
            "\t\tpage_i = shuffle_valid_page(z, i, order);",
            "\t\tif (!page_i)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (retry = 0; retry < SHUFFLE_RETRY; retry++) {",
            "\t\t\t/*",
            "\t\t\t * Pick a random order aligned page in the zone span as",
            "\t\t\t * a swap target. If the selected pfn is a hole, retry",
            "\t\t\t * up to SHUFFLE_RETRY attempts find a random valid pfn",
            "\t\t\t * in the zone.",
            "\t\t\t */",
            "\t\t\tj = z->zone_start_pfn +",
            "\t\t\t\tALIGN_DOWN(get_random_long() % z->spanned_pages,",
            "\t\t\t\t\t\torder_pages);",
            "\t\t\tpage_j = shuffle_valid_page(z, j, order);",
            "\t\t\tif (page_j && page_j != page_i)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (retry >= SHUFFLE_RETRY) {",
            "\t\t\tpr_debug(\"%s: failed to swap %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Each migratetype corresponds to its own list, make sure the",
            "\t\t * types match otherwise we're moving pages to lists where they",
            "\t\t * do not belong.",
            "\t\t */",
            "\t\tmigratetype = get_pageblock_migratetype(page_i);",
            "\t\tif (get_pageblock_migratetype(page_j) != migratetype) {",
            "\t\t\tpr_debug(\"%s: migratetype mismatch %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tlist_swap(&page_i->lru, &page_j->lru);",
            "",
            "\t\tpr_debug(\"%s: swap: %#lx -> %#lx\\n\", __func__, i, j);",
            "",
            "\t\t/* take it easy on the zone lock */",
            "\t\tif ((i % (100 * order_pages)) == 0) {",
            "\t\t\tspin_unlock_irqrestore(&z->lock, flags);",
            "\t\t\tcond_resched();",
            "\t\t\tspin_lock_irqsave(&z->lock, flags);",
            "\t\t}",
            "\t}",
            "\tspin_unlock_irqrestore(&z->lock, flags);",
            "}",
            "void __meminit __shuffle_free_memory(pg_data_t *pgdat)",
            "{",
            "\tstruct zone *z;",
            "",
            "\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)",
            "\t\tshuffle_zone(z);",
            "}",
            "bool shuffle_pick_tail(void)",
            "{",
            "\tstatic u64 rand;",
            "\tstatic u8 rand_bits;",
            "\tbool ret;",
            "",
            "\t/*",
            "\t * The lack of locking is deliberate. If 2 threads race to",
            "\t * update the rand state it just adds to the entropy.",
            "\t */",
            "\tif (rand_bits == 0) {",
            "\t\trand_bits = 64;",
            "\t\trand = get_random_u64();",
            "\t}",
            "",
            "\tret = rand & 1;",
            "",
            "\trand_bits--;",
            "\trand >>= 1;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "shuffle_param_set, __shuffle_zone, __shuffle_free_memory, shuffle_pick_tail",
          "description": "shuffle_param_set设置参数并启用/禁用静态键；__shuffle_zone在内存区随机交换页面以打乱物理顺序；__shuffle_free_memory初始化时调用__shuffle_zone；shuffle_pick_tail生成随机布尔值用于选择尾部页",
          "similarity": 0.4612264037132263
        },
        {
          "chunk_id": 0,
          "file_path": "mm/shuffle.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright(c) 2018 Intel Corporation. All rights reserved.",
            "",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/random.h>",
            "#include <linux/moduleparam.h>",
            "#include \"internal.h\"",
            "#include \"shuffle.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(page_alloc_shuffle_key);",
            "",
            "static bool shuffle_param;",
            ""
          ],
          "function_name": null,
          "description": "定义静态键用于控制页面分配随机化功能，并声明参数变量shuffle_param，用于启用或禁用相关机制",
          "similarity": 0.3673788905143738
        }
      ]
    },
    {
      "source_file": "mm/kmemleak.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:27:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kmemleak.c`\n\n---\n\n# kmemleak.c 技术文档\n\n## 1. 文件概述\n\n`kmemleak.c` 是 Linux 内核中用于检测内核内存泄漏（kernel memory leak）的调试工具实现文件。它通过跟踪内核动态分配的内存块，并周期性扫描内核地址空间，查找是否有指向这些内存块的有效指针。若某内存块在分配后经过一定时间仍未被任何指针引用，则被判定为潜在的内存泄漏。该机制类似于用户空间的垃圾回收中的“可达性分析”，但仅用于诊断目的，不会自动释放内存。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct kmemleak_object`**  \n  表示一个被跟踪的内存分配对象，包含以下关键字段：\n  - `pointer` / `size`：分配的内存地址和大小\n  - `flags`：对象状态标志（如 `OBJECT_ALLOCATED`, `OBJECT_PHYS` 等）\n  - `count` / `min_count`：当前找到的引用指针数量及判定为泄漏所需的最小引用数\n  - `use_count`：引用计数，用于 RCU 安全释放\n  - `del_state`：删除状态，控制对象从全局列表中移除的时机\n  - `area_list`：指定需扫描的子区域（可选）\n  - `trace_handle`：分配时的栈回溯信息（通过 stackdepot 存储）\n  - `jiffies` / `pid` / `comm`：分配时间、进程 ID 和命令名，用于报告上下文\n\n- **全局数据结构**\n  - `object_list`：所有已分配对象的链表\n  - `gray_list`：待扫描的“灰色”对象列表（在当前扫描周期中需检查其内容）\n  - `object_tree_root` / `object_phys_tree_root` / `object_percpu_tree_root`：基于红黑树的索引结构，用于根据指针地址快速查找对应的 `kmemleak_object`\n  - `mem_pool`：预分配的对象池，避免在内存压力下因分配元数据失败而影响检测\n\n### 主要函数（虽未完整列出，但可推断）\n\n- **对象生命周期管理**：\n  - `create_object()`：创建并注册新分配的内存块\n  - `delete_object()` / `__remove_object()`：注销已释放的内存块\n  - `get_object()` / `put_object()`：引用计数管理，配合 RCU 释放\n\n- **内存扫描与分析**：\n  - 扫描线程（`scan_mutex` 保护）遍历 `gray_list`，解析每个对象内存内容，查找可能指向其他对象的指针\n  - 更新目标对象的 `count`，若引用不足且超时则标记为泄漏\n\n- **接口与调试支持**：\n  - 通过 `debugfs` 提供 `/sys/kernel/debug/kmemleak` 接口，支持手动触发扫描、清除报告、调整参数等\n  - 支持 `kmemleak_alloc()` / `kmemleak_free()` 等钩子函数，由 SLAB、vmalloc、percpu 等分配器调用\n\n## 3. 关键实现\n\n### 锁定机制\n\n采用多级锁策略以平衡并发性能与数据一致性：\n\n- **`kmemleak_lock`（raw_spinlock_t）**  \n  全局自旋锁，保护 `object_list` 和三棵红黑树的结构修改（插入/删除节点），以及 `del_state` 的变更。\n\n- **`kmemleak_object.lock`（raw_spinlock_t）**  \n  每对象自旋锁，保护对象内部元数据（如 `count`）的并发访问，并在扫描对象内存时持有，防止该内存被释放。\n\n- **`scan_mutex`（mutex）**  \n  互斥锁，确保同一时间仅有一个线程执行内存扫描。扫描期间操作 `gray_list`，并对其中每个对象调用 `get_object()` 增加引用计数，防止其被释放。\n\n**锁顺序约定**：  \n`scan_mutex` → `object->lock` → `kmemleak_lock` → `other_object->lock`（使用 `SINGLE_DEPTH_NESTING` 避免死锁）。禁止在未持有 `scan_mutex` 时嵌套 `kmemleak_lock` 与 `object->lock`。\n\n### 对象生命周期与 RCU\n\n- 所有 `kmemleak_object` 实例通过引用计数（`use_count`）管理生命周期。\n- 当 `use_count` 降为 0 时，通过 RCU 回调异步释放对象，确保读取路径（如 `rcu_read_lock()` 保护下的查找）不会访问已释放内存。\n- 删除对象时先标记 `DELSTATE_REMOVED`，延迟从 `object_list` 移除，直到无活跃引用。\n\n### 扫描算法\n\n- **灰色对象（Gray List）**：初始时所有新分配对象加入灰色列表。扫描时将其内存内容按指针大小解析，若发现值落在某已知对象地址范围内，则增加目标对象的 `count`。\n- **泄漏判定**：对象需满足：\n  1. `count < min_count`（默认 `min_count=1`）\n  2. 分配时间超过 `MSECS_MIN_AGE`（5000ms）\n  3. 未被标记为 `OBJECT_REPORTED`\n- **扫描优化**：\n  - 支持通过 `kmemleak_scan_area` 指定仅扫描对象内的特定区域\n  - 若无法分配 `scan_area`，则回退到全对象扫描（`OBJECT_FULL_SCAN`）\n\n### 内存池设计\n\n- 使用静态数组 `mem_pool` 预分配固定数量的 `kmemleak_object`（数量由 `CONFIG_DEBUG_KMEMLEAK_MEM_POOL_SIZE` 配置）\n- 避免在内存紧张或中断上下文中因动态分配元数据失败而导致跟踪丢失\n\n## 4. 依赖关系\n\n- **内存分配器**：依赖 SLAB、SLUB、SLOB、vmalloc、percpu 等子系统在分配/释放内存时调用 `kmemleak_alloc*()` / `kmemleak_free*()` 钩子。\n- **调试基础设施**：\n  - `debugfs`：提供用户交互接口\n  - `stackdepot`：高效存储分配点的栈回溯\n  - `RCU`：安全释放对象元数据\n- **其他调试工具**：与 KASAN、KFENCE 互斥（通常不同时启用），因功能重叠且开销大。\n- **架构相关代码**：通过 `<asm/sections.h>` 获取内核符号范围，用于排除静态数据区的误报。\n\n## 5. 使用场景\n\n- **内核开发与调试**：开发者在启用 `CONFIG_DEBUG_KMEMLEAK` 后，可通过 `debugfs` 接口检测驱动或子系统中的内存泄漏。\n- **持续集成测试**：在自动化测试中定期触发 kmemleak 扫描，捕获回归引入的泄漏。\n- **生产环境诊断（谨慎）**：在可控环境下临时启用以定位疑难内存问题，因其带来显著性能开销（内存与 CPU）。\n- **与内存热插拔协同**：通过 `memory_hotplug` 通知机制，处理物理内存区域变化对扫描范围的影响。",
      "similarity": 0.5438724160194397,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "mm/kmemleak.c",
          "start_line": 1814,
          "end_line": 1928,
          "content": [
            "static int kmemleak_scan_thread(void *arg)",
            "{",
            "\tstatic int first_run = IS_ENABLED(CONFIG_DEBUG_KMEMLEAK_AUTO_SCAN);",
            "",
            "\tpr_info(\"Automatic memory scanning thread started\\n\");",
            "\tset_user_nice(current, 10);",
            "",
            "\t/*",
            "\t * Wait before the first scan to allow the system to fully initialize.",
            "\t */",
            "\tif (first_run) {",
            "\t\tsigned long timeout = msecs_to_jiffies(SECS_FIRST_SCAN * 1000);",
            "\t\tfirst_run = 0;",
            "\t\twhile (timeout && !kthread_should_stop())",
            "\t\t\ttimeout = schedule_timeout_interruptible(timeout);",
            "\t}",
            "",
            "\twhile (!kthread_should_stop()) {",
            "\t\tsigned long timeout = READ_ONCE(jiffies_scan_wait);",
            "",
            "\t\tmutex_lock(&scan_mutex);",
            "\t\tkmemleak_scan();",
            "\t\tmutex_unlock(&scan_mutex);",
            "",
            "\t\t/* wait before the next scan */",
            "\t\twhile (timeout && !kthread_should_stop())",
            "\t\t\ttimeout = schedule_timeout_interruptible(timeout);",
            "\t}",
            "",
            "\tpr_info(\"Automatic memory scanning thread ended\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static void start_scan_thread(void)",
            "{",
            "\tif (scan_thread)",
            "\t\treturn;",
            "\tscan_thread = kthread_run(kmemleak_scan_thread, NULL, \"kmemleak\");",
            "\tif (IS_ERR(scan_thread)) {",
            "\t\tpr_warn(\"Failed to create the scan thread\\n\");",
            "\t\tscan_thread = NULL;",
            "\t}",
            "}",
            "static void stop_scan_thread(void)",
            "{",
            "\tif (scan_thread) {",
            "\t\tkthread_stop(scan_thread);",
            "\t\tscan_thread = NULL;",
            "\t}",
            "}",
            "static void kmemleak_seq_stop(struct seq_file *seq, void *v)",
            "{",
            "\tif (!IS_ERR(v)) {",
            "\t\t/*",
            "\t\t * kmemleak_seq_start may return ERR_PTR if the scan_mutex",
            "\t\t * waiting was interrupted, so only release it if !IS_ERR.",
            "\t\t */",
            "\t\trcu_read_unlock();",
            "\t\tmutex_unlock(&scan_mutex);",
            "\t\tif (v)",
            "\t\t\tput_object(v);",
            "\t}",
            "}",
            "static int kmemleak_seq_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct kmemleak_object *object = v;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&object->lock, flags);",
            "\tif ((object->flags & OBJECT_REPORTED) && unreferenced_object(object))",
            "\t\tprint_unreferenced(seq, object);",
            "\traw_spin_unlock_irqrestore(&object->lock, flags);",
            "\treturn 0;",
            "}",
            "static int kmemleak_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn seq_open(file, &kmemleak_seq_ops);",
            "}",
            "static int dump_str_object_info(const char *str)",
            "{",
            "\tunsigned long flags;",
            "\tstruct kmemleak_object *object;",
            "\tunsigned long addr;",
            "",
            "\tif (kstrtoul(str, 0, &addr))",
            "\t\treturn -EINVAL;",
            "\tobject = find_and_get_object(addr, 0);",
            "\tif (!object) {",
            "\t\tpr_info(\"Unknown object at 0x%08lx\\n\", addr);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\traw_spin_lock_irqsave(&object->lock, flags);",
            "\tdump_object_info(object);",
            "\traw_spin_unlock_irqrestore(&object->lock, flags);",
            "",
            "\tput_object(object);",
            "\treturn 0;",
            "}",
            "static void kmemleak_clear(void)",
            "{",
            "\tstruct kmemleak_object *object;",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(object, &object_list, object_list) {",
            "\t\traw_spin_lock_irq(&object->lock);",
            "\t\tif ((object->flags & OBJECT_REPORTED) &&",
            "\t\t    unreferenced_object(object))",
            "\t\t\t__paint_it(object, KMEMLEAK_GREY);",
            "\t\traw_spin_unlock_irq(&object->lock);",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\tkmemleak_found_leaks = false;",
            "}"
          ],
          "function_name": "kmemleak_scan_thread, start_scan_thread, stop_scan_thread, kmemleak_seq_stop, kmemleak_seq_show, kmemleak_open, dump_str_object_info, kmemleak_clear",
          "description": "提供内存泄漏检测的线程化扫描机制，包含自动扫描线程管理、序列化接口实现以及清除已报告泄漏状态的功能。",
          "similarity": 0.5929161310195923
        },
        {
          "chunk_id": 6,
          "file_path": "mm/kmemleak.c",
          "start_line": 1274,
          "end_line": 1401,
          "content": [
            "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, gfp_t gfp)",
            "{",
            "\tpr_debug(\"%s(0x%px, %zu)\\n\", __func__, &phys, size);",
            "",
            "\tif (kmemleak_enabled)",
            "\t\t/*",
            "\t\t * Create object with OBJECT_PHYS flag and",
            "\t\t * assume min_count 0.",
            "\t\t */",
            "\t\tcreate_object_phys((unsigned long)phys, size, 0, gfp);",
            "}",
            "void __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)",
            "{",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, &phys);",
            "",
            "\tif (kmemleak_enabled)",
            "\t\tdelete_object_part((unsigned long)phys, size, OBJECT_PHYS);",
            "}",
            "void __ref kmemleak_ignore_phys(phys_addr_t phys)",
            "{",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, &phys);",
            "",
            "\tif (kmemleak_enabled)",
            "\t\tmake_black_object((unsigned long)phys, OBJECT_PHYS);",
            "}",
            "static bool update_checksum(struct kmemleak_object *object)",
            "{",
            "\tu32 old_csum = object->checksum;",
            "",
            "\tif (WARN_ON_ONCE(object->flags & OBJECT_PHYS))",
            "\t\treturn false;",
            "",
            "\tkasan_disable_current();",
            "\tkcsan_disable_current();",
            "\tif (object->flags & OBJECT_PERCPU) {",
            "\t\tunsigned int cpu;",
            "",
            "\t\tobject->checksum = 0;",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tvoid *ptr = per_cpu_ptr((void __percpu *)object->pointer, cpu);",
            "",
            "\t\t\tobject->checksum ^= crc32(0, kasan_reset_tag((void *)ptr), object->size);",
            "\t\t}",
            "\t} else {",
            "\t\tobject->checksum = crc32(0, kasan_reset_tag((void *)object->pointer), object->size);",
            "\t}",
            "\tkasan_enable_current();",
            "\tkcsan_enable_current();",
            "",
            "\treturn object->checksum != old_csum;",
            "}",
            "static void update_refs(struct kmemleak_object *object)",
            "{",
            "\tif (!color_white(object)) {",
            "\t\t/* non-orphan, ignored or new */",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Increase the object's reference count (number of pointers to the",
            "\t * memory block). If this count reaches the required minimum, the",
            "\t * object's color will become gray and it will be added to the",
            "\t * gray_list.",
            "\t */",
            "\tobject->count++;",
            "\tif (color_gray(object)) {",
            "\t\t/* put_object() called when removing from gray_list */",
            "\t\tWARN_ON(!get_object(object));",
            "\t\tlist_add_tail(&object->gray_list, &gray_list);",
            "\t}",
            "}",
            "static void pointer_update_refs(struct kmemleak_object *scanned,",
            "\t\t\t unsigned long pointer, unsigned int objflags)",
            "{",
            "\tstruct kmemleak_object *object;",
            "\tunsigned long untagged_ptr;",
            "\tunsigned long excess_ref;",
            "",
            "\tuntagged_ptr = (unsigned long)kasan_reset_tag((void *)pointer);",
            "\tif (objflags & OBJECT_PERCPU) {",
            "\t\tif (untagged_ptr < min_percpu_addr || untagged_ptr >= max_percpu_addr)",
            "\t\t\treturn;",
            "\t} else {",
            "\t\tif (untagged_ptr < min_addr || untagged_ptr >= max_addr)",
            "\t\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * No need for get_object() here since we hold kmemleak_lock.",
            "\t * object->use_count cannot be dropped to 0 while the object",
            "\t * is still present in object_tree_root and object_list",
            "\t * (with updates protected by kmemleak_lock).",
            "\t */",
            "\tobject = __lookup_object(pointer, 1, objflags);",
            "\tif (!object)",
            "\t\treturn;",
            "\tif (object == scanned)",
            "\t\t/* self referenced, ignore */",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Avoid the lockdep recursive warning on object->lock being",
            "\t * previously acquired in scan_object(). These locks are",
            "\t * enclosed by scan_mutex.",
            "\t */",
            "\traw_spin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);",
            "\t/* only pass surplus references (object already gray) */",
            "\tif (color_gray(object)) {",
            "\t\texcess_ref = object->excess_ref;",
            "\t\t/* no need for update_refs() if object already gray */",
            "\t} else {",
            "\t\texcess_ref = 0;",
            "\t\tupdate_refs(object);",
            "\t}",
            "\traw_spin_unlock(&object->lock);",
            "",
            "\tif (excess_ref) {",
            "\t\tobject = lookup_object(excess_ref, 0);",
            "\t\tif (!object)",
            "\t\t\treturn;",
            "\t\tif (object == scanned)",
            "\t\t\t/* circular reference, ignore */",
            "\t\t\treturn;",
            "\t\traw_spin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);",
            "\t\tupdate_refs(object);",
            "\t\traw_spin_unlock(&object->lock);",
            "\t}",
            "}"
          ],
          "function_name": "kmemleak_alloc_phys, kmemleak_free_part_phys, kmemleak_ignore_phys, update_checksum, update_refs, pointer_update_refs",
          "description": "处理物理内存区域的分配/释放跟踪，提供校验和更新和引用计数管理机制，用于识别内存块变更和引用关系。",
          "similarity": 0.5428093075752258
        },
        {
          "chunk_id": 7,
          "file_path": "mm/kmemleak.c",
          "start_line": 1433,
          "end_line": 1543,
          "content": [
            "static int scan_should_stop(void)",
            "{",
            "\tif (!kmemleak_enabled)",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * This function may be called from either process or kthread context,",
            "\t * hence the need to check for both stop conditions.",
            "\t */",
            "\tif (current->mm)",
            "\t\treturn signal_pending(current);",
            "\telse",
            "\t\treturn kthread_should_stop();",
            "",
            "\treturn 0;",
            "}",
            "static void scan_block(void *_start, void *_end,",
            "\t\t       struct kmemleak_object *scanned)",
            "{",
            "\tunsigned long *ptr;",
            "\tunsigned long *start = PTR_ALIGN(_start, BYTES_PER_POINTER);",
            "\tunsigned long *end = _end - (BYTES_PER_POINTER - 1);",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&kmemleak_lock, flags);",
            "\tfor (ptr = start; ptr < end; ptr++) {",
            "\t\tunsigned long pointer;",
            "",
            "\t\tif (scan_should_stop())",
            "\t\t\tbreak;",
            "",
            "\t\tkasan_disable_current();",
            "\t\tpointer = *(unsigned long *)kasan_reset_tag((void *)ptr);",
            "\t\tkasan_enable_current();",
            "",
            "\t\tpointer_update_refs(scanned, pointer, 0);",
            "\t\tpointer_update_refs(scanned, pointer, OBJECT_PERCPU);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&kmemleak_lock, flags);",
            "}",
            "static void scan_large_block(void *start, void *end)",
            "{",
            "\tvoid *next;",
            "",
            "\twhile (start < end) {",
            "\t\tnext = min(start + MAX_SCAN_SIZE, end);",
            "\t\tscan_block(start, next, NULL);",
            "\t\tstart = next;",
            "\t\tcond_resched();",
            "\t}",
            "}",
            "static void scan_object(struct kmemleak_object *object)",
            "{",
            "\tstruct kmemleak_scan_area *area;",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * Once the object->lock is acquired, the corresponding memory block",
            "\t * cannot be freed (the same lock is acquired in delete_object).",
            "\t */",
            "\traw_spin_lock_irqsave(&object->lock, flags);",
            "\tif (object->flags & OBJECT_NO_SCAN)",
            "\t\tgoto out;",
            "\tif (!(object->flags & OBJECT_ALLOCATED))",
            "\t\t/* already freed object */",
            "\t\tgoto out;",
            "",
            "\tif (object->flags & OBJECT_PERCPU) {",
            "\t\tunsigned int cpu;",
            "",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tvoid *start = per_cpu_ptr((void __percpu *)object->pointer, cpu);",
            "\t\t\tvoid *end = start + object->size;",
            "",
            "\t\t\tscan_block(start, end, object);",
            "",
            "\t\t\traw_spin_unlock_irqrestore(&object->lock, flags);",
            "\t\t\tcond_resched();",
            "\t\t\traw_spin_lock_irqsave(&object->lock, flags);",
            "\t\t\tif (!(object->flags & OBJECT_ALLOCATED))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t} else if (hlist_empty(&object->area_list) ||",
            "\t    object->flags & OBJECT_FULL_SCAN) {",
            "\t\tvoid *start = object->flags & OBJECT_PHYS ?",
            "\t\t\t\t__va((phys_addr_t)object->pointer) :",
            "\t\t\t\t(void *)object->pointer;",
            "\t\tvoid *end = start + object->size;",
            "\t\tvoid *next;",
            "",
            "\t\tdo {",
            "\t\t\tnext = min(start + MAX_SCAN_SIZE, end);",
            "\t\t\tscan_block(start, next, object);",
            "",
            "\t\t\tstart = next;",
            "\t\t\tif (start >= end)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\traw_spin_unlock_irqrestore(&object->lock, flags);",
            "\t\t\tcond_resched();",
            "\t\t\traw_spin_lock_irqsave(&object->lock, flags);",
            "\t\t} while (object->flags & OBJECT_ALLOCATED);",
            "\t} else {",
            "\t\thlist_for_each_entry(area, &object->area_list, node)",
            "\t\t\tscan_block((void *)area->start,",
            "\t\t\t\t   (void *)(area->start + area->size),",
            "\t\t\t\t   object);",
            "\t}",
            "out:",
            "\traw_spin_unlock_irqrestore(&object->lock, flags);",
            "}"
          ],
          "function_name": "scan_should_stop, scan_block, scan_large_block, scan_object",
          "description": "实现内存块扫描逻辑，通过遍历指定范围内的指针并更新相关对象的引用状态，支持多区域和大块内存的分段扫描。",
          "similarity": 0.5415979623794556
        },
        {
          "chunk_id": 1,
          "file_path": "mm/kmemleak.c",
          "start_line": 283,
          "end_line": 388,
          "content": [
            "static void warn_or_seq_hex_dump(struct seq_file *seq, int prefix_type,",
            "\t\t\t\t int rowsize, int groupsize, const void *buf,",
            "\t\t\t\t size_t len, bool ascii)",
            "{",
            "\tif (seq)",
            "\t\tseq_hex_dump(seq, HEX_PREFIX, prefix_type, rowsize, groupsize,",
            "\t\t\t     buf, len, ascii);",
            "\telse",
            "\t\tprint_hex_dump(KERN_WARNING, pr_fmt(HEX_PREFIX), prefix_type,",
            "\t\t\t       rowsize, groupsize, buf, len, ascii);",
            "}",
            "static void hex_dump_object(struct seq_file *seq,",
            "\t\t\t    struct kmemleak_object *object)",
            "{",
            "\tconst u8 *ptr = (const u8 *)object->pointer;",
            "\tsize_t len;",
            "",
            "\tif (WARN_ON_ONCE(object->flags & OBJECT_PHYS))",
            "\t\treturn;",
            "",
            "\tif (object->flags & OBJECT_PERCPU)",
            "\t\tptr = (const u8 *)this_cpu_ptr((void __percpu *)object->pointer);",
            "",
            "\t/* limit the number of lines to HEX_MAX_LINES */",
            "\tlen = min_t(size_t, object->size, HEX_MAX_LINES * HEX_ROW_SIZE);",
            "",
            "\tif (object->flags & OBJECT_PERCPU)",
            "\t\twarn_or_seq_printf(seq, \"  hex dump (first %zu bytes on cpu %d):\\n\",",
            "\t\t\t\t   len, raw_smp_processor_id());",
            "\telse",
            "\t\twarn_or_seq_printf(seq, \"  hex dump (first %zu bytes):\\n\", len);",
            "\tkasan_disable_current();",
            "\twarn_or_seq_hex_dump(seq, DUMP_PREFIX_NONE, HEX_ROW_SIZE,",
            "\t\t\t     HEX_GROUP_SIZE, kasan_reset_tag((void *)ptr), len, HEX_ASCII);",
            "\tkasan_enable_current();",
            "}",
            "static bool color_white(const struct kmemleak_object *object)",
            "{",
            "\treturn object->count != KMEMLEAK_BLACK &&",
            "\t\tobject->count < object->min_count;",
            "}",
            "static bool color_gray(const struct kmemleak_object *object)",
            "{",
            "\treturn object->min_count != KMEMLEAK_BLACK &&",
            "\t\tobject->count >= object->min_count;",
            "}",
            "static bool unreferenced_object(struct kmemleak_object *object)",
            "{",
            "\treturn (color_white(object) && object->flags & OBJECT_ALLOCATED) &&",
            "\t\ttime_before_eq(object->jiffies + jiffies_min_age,",
            "\t\t\t       jiffies_last_scan);",
            "}",
            "static void print_unreferenced(struct seq_file *seq,",
            "\t\t\t       struct kmemleak_object *object)",
            "{",
            "\tint i;",
            "\tunsigned long *entries;",
            "\tunsigned int nr_entries;",
            "\tunsigned int msecs_age = jiffies_to_msecs(jiffies - object->jiffies);",
            "",
            "\tnr_entries = stack_depot_fetch(object->trace_handle, &entries);",
            "\twarn_or_seq_printf(seq, \"unreferenced object 0x%08lx (size %zu):\\n\",",
            "\t\t\t  object->pointer, object->size);",
            "\twarn_or_seq_printf(seq, \"  comm \\\"%s\\\", pid %d, jiffies %lu (age %d.%03ds)\\n\",",
            "\t\t\t   object->comm, object->pid, object->jiffies,",
            "\t\t\t   msecs_age / 1000, msecs_age % 1000);",
            "\thex_dump_object(seq, object);",
            "\twarn_or_seq_printf(seq, \"  backtrace:\\n\");",
            "",
            "\tfor (i = 0; i < nr_entries; i++) {",
            "\t\tvoid *ptr = (void *)entries[i];",
            "\t\twarn_or_seq_printf(seq, \"    %pS\\n\", ptr);",
            "\t}",
            "}",
            "static void dump_object_info(struct kmemleak_object *object)",
            "{",
            "\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",",
            "\t\t\tobject->pointer, object->size);",
            "\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",",
            "\t\t\tobject->comm, object->pid, object->jiffies);",
            "\tpr_notice(\"  min_count = %d\\n\", object->min_count);",
            "\tpr_notice(\"  count = %d\\n\", object->count);",
            "\tpr_notice(\"  flags = 0x%x\\n\", object->flags);",
            "\tpr_notice(\"  checksum = %u\\n\", object->checksum);",
            "\tpr_notice(\"  backtrace:\\n\");",
            "\tif (object->trace_handle)",
            "\t\tstack_depot_print(object->trace_handle);",
            "}",
            "static int get_object(struct kmemleak_object *object)",
            "{",
            "\treturn atomic_inc_not_zero(&object->use_count);",
            "}",
            "static void mem_pool_free(struct kmemleak_object *object)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (object < mem_pool || object >= mem_pool + ARRAY_SIZE(mem_pool)) {",
            "\t\tkmem_cache_free(object_cache, object);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* add the object to the memory pool free list */",
            "\traw_spin_lock_irqsave(&kmemleak_lock, flags);",
            "\tlist_add(&object->object_list, &mem_pool_free_list);",
            "\traw_spin_unlock_irqrestore(&kmemleak_lock, flags);",
            "}"
          ],
          "function_name": "warn_or_seq_hex_dump, hex_dump_object, color_white, color_gray, unreferenced_object, print_unreferenced, dump_object_info, get_object, mem_pool_free",
          "description": "实现内存泄漏对象的调试打印功能，包含十六进制转储、颜色判定逻辑和未引用对象信息展示，用于生成内存泄漏诊断报告。",
          "similarity": 0.5350169539451599
        },
        {
          "chunk_id": 5,
          "file_path": "mm/kmemleak.c",
          "start_line": 1055,
          "end_line": 1160,
          "content": [
            "void __ref kmemleak_alloc(const void *ptr, size_t size, int min_count,",
            "\t\t\t  gfp_t gfp)",
            "{",
            "\tpr_debug(\"%s(0x%px, %zu, %d)\\n\", __func__, ptr, size, min_count);",
            "",
            "\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))",
            "\t\tcreate_object((unsigned long)ptr, size, min_count, gfp);",
            "}",
            "void __ref kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,",
            "\t\t\t\t gfp_t gfp)",
            "{",
            "\tpr_debug(\"%s(0x%px, %zu)\\n\", __func__, ptr, size);",
            "",
            "\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))",
            "\t\tcreate_object_percpu((unsigned long)ptr, size, 1, gfp);",
            "}",
            "void __ref kmemleak_vmalloc(const struct vm_struct *area, size_t size, gfp_t gfp)",
            "{",
            "\tpr_debug(\"%s(0x%px, %zu)\\n\", __func__, area, size);",
            "",
            "\t/*",
            "\t * A min_count = 2 is needed because vm_struct contains a reference to",
            "\t * the virtual address of the vmalloc'ed block.",
            "\t */",
            "\tif (kmemleak_enabled) {",
            "\t\tcreate_object((unsigned long)area->addr, size, 2, gfp);",
            "\t\tobject_set_excess_ref((unsigned long)area,",
            "\t\t\t\t      (unsigned long)area->addr);",
            "\t}",
            "}",
            "void __ref kmemleak_free(const void *ptr)",
            "{",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, ptr);",
            "",
            "\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))",
            "\t\tdelete_object_full((unsigned long)ptr, 0);",
            "}",
            "void __ref kmemleak_free_part(const void *ptr, size_t size)",
            "{",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, ptr);",
            "",
            "\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))",
            "\t\tdelete_object_part((unsigned long)ptr, size, 0);",
            "}",
            "void __ref kmemleak_free_percpu(const void __percpu *ptr)",
            "{",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, ptr);",
            "",
            "\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))",
            "\t\tdelete_object_full((unsigned long)ptr, OBJECT_PERCPU);",
            "}",
            "void __ref kmemleak_update_trace(const void *ptr)",
            "{",
            "\tstruct kmemleak_object *object;",
            "\tdepot_stack_handle_t trace_handle;",
            "\tunsigned long flags;",
            "",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, ptr);",
            "",
            "\tif (!kmemleak_enabled || IS_ERR_OR_NULL(ptr))",
            "\t\treturn;",
            "",
            "\tobject = find_and_get_object((unsigned long)ptr, 1);",
            "\tif (!object) {",
            "#ifdef DEBUG",
            "\t\tkmemleak_warn(\"Updating stack trace for unknown object at %p\\n\",",
            "\t\t\t      ptr);",
            "#endif",
            "\t\treturn;",
            "\t}",
            "",
            "\ttrace_handle = set_track_prepare();",
            "\traw_spin_lock_irqsave(&object->lock, flags);",
            "\tobject->trace_handle = trace_handle;",
            "\traw_spin_unlock_irqrestore(&object->lock, flags);",
            "",
            "\tput_object(object);",
            "}",
            "void __ref kmemleak_not_leak(const void *ptr)",
            "{",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, ptr);",
            "",
            "\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))",
            "\t\tmake_gray_object((unsigned long)ptr);",
            "}",
            "void __ref kmemleak_ignore(const void *ptr)",
            "{",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, ptr);",
            "",
            "\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))",
            "\t\tmake_black_object((unsigned long)ptr, 0);",
            "}",
            "void __ref kmemleak_scan_area(const void *ptr, size_t size, gfp_t gfp)",
            "{",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, ptr);",
            "",
            "\tif (kmemleak_enabled && ptr && size && !IS_ERR(ptr))",
            "\t\tadd_scan_area((unsigned long)ptr, size, gfp);",
            "}",
            "void __ref kmemleak_no_scan(const void *ptr)",
            "{",
            "\tpr_debug(\"%s(0x%px)\\n\", __func__, ptr);",
            "",
            "\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))",
            "\t\tobject_no_scan((unsigned long)ptr);",
            "}"
          ],
          "function_name": "kmemleak_alloc, kmemleak_alloc_percpu, kmemleak_vmalloc, kmemleak_free, kmemleak_free_part, kmemleak_free_percpu, kmemleak_update_trace, kmemleak_not_leak, kmemleak_ignore, kmemleak_scan_area, kmemleak_no_scan",
          "description": "定义了kmemleak模块的核心操作函数，包括内存分配/释放跟踪、标记非泄漏对象、更新堆栈追踪及扫描区域注册，用于检测内存泄漏。",
          "similarity": 0.5299390554428101
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bloom_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:56:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bloom_filter.c`\n\n---\n\n# `bpf/bloom_filter.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了 Linux 内核中 eBPF（extended Berkeley Packet Filter）子系统所支持的 **布隆过滤器（Bloom Filter）映射类型**。布隆过滤器是一种空间高效的概率型数据结构，用于快速判断某个元素是否**可能存在于集合中**（允许假阳性，但不允许假阴性）。该映射类型专为只写入、只查询、不可删除的场景设计，适用于高性能、低内存开销的成员存在性检测。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_bloom_filter`**  \n  布隆过滤器的具体实现结构体，包含：\n  - `struct bpf_map map`：继承自通用 eBPF 映射结构。\n  - `u32 bitset_mask`：位图掩码，用于快速取模（因位图大小为 2 的幂）。\n  - `u32 hash_seed`：哈希种子，用于初始化哈希函数（可选随机化）。\n  - `u32 nr_hash_funcs`：使用的哈希函数数量（1–15，由 `map_extra` 指定）。\n  - `unsigned long bitset[]`：柔性数组，存储位图数据。\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `hash()` | 根据输入值、哈希种子和索引计算哈希值，并通过 `bitset_mask` 取模得到位图索引。支持 4 字节对齐和非对齐数据。 |\n| `bloom_map_peek_elem()` | 查询元素是否存在：对每个哈希函数计算位图位置，若任一位为 0 则返回 `-ENOENT`（不存在）；否则返回 0（可能存在）。 |\n| `bloom_map_push_elem()` | 插入元素：对每个哈希函数计算位图位置并置位。仅支持 `BPF_ANY` 标志。 |\n| `bloom_map_alloc()` | 分配并初始化布隆过滤器映射。根据 `max_entries` 和 `map_extra`（哈希函数数）计算最优位图大小，并向上取整为 2 的幂。 |\n| `bloom_map_free()` | 释放布隆过滤器占用的内存。 |\n| `bloom_map_alloc_check()` | 在创建映射前校验参数合法性（如 `value_size` 不超过 `KMALLOC_MAX_SIZE`）。 |\n| `bloom_map_check_btf()` | BTF（BPF Type Format）校验：要求 key 类型为 `void`（无 key）。 |\n| `bloom_map_mem_usage()` | 返回该映射实际占用的内存大小（含位图）。 |\n\n### 不支持的操作（返回 `-EOPNOTSUPP` 或 `-EINVAL`）\n\n- `bloom_map_pop_elem()`：不支持弹出元素。\n- `bloom_map_delete_elem()`：不支持删除元素。\n- `bloom_map_get_next_key()`：不支持遍历。\n- `bloom_map_lookup_elem()` / `bloom_map_update_elem()`：eBPF 程序应使用 `map_peek_elem` 和 `map_push_elem` 替代。\n\n### 映射操作表\n\n- `bloom_filter_map_ops`：定义了该映射类型支持的所有操作回调函数，注册到 eBPF 子系统。\n\n## 3. 关键实现\n\n### 布隆过滤器参数计算\n\n- **哈希函数数量**：由用户通过 `attr->map_extra & 0xF` 指定（1–15），若为 0 则默认使用 5 个。\n- **位图大小计算**：\n  - 理论最优位数：`n * k / ln(2)`，其中 `n = max_entries`，`k = nr_hash_funcs`。\n  - 代码使用 `7/5 ≈ 1/ln(2)` 近似计算：`nr_bits = (max_entries * k * 7) / 5`。\n  - 为提升哈希效率，将 `nr_bits` **向上取整为 2 的幂**，从而可用 `& (size - 1)` 替代取模运算。\n  - 若计算溢出（> 2^31），则使用最大位图（`U32_MAX` 位，约 512 MB）。\n\n### 哈希函数\n\n- 使用内核提供的 `jhash()` 和 `jhash2()`（Jenkins 哈希）。\n- 每个哈希函数通过 `hash_seed + index` 区分，确保独立性。\n- 支持任意长度的 `value`（由 `value_size` 指定），自动选择对齐/非对齐版本。\n\n### 内存分配\n\n- 使用 `bpf_map_area_alloc()` 分配连续内存，包含结构体头和位图。\n- 位图大小按 `unsigned long` 对齐，确保位操作效率。\n\n### 安全与校验\n\n- 严格校验创建参数：`key_size` 必须为 0，`value_size` 和 `max_entries` 必须 > 0。\n- 仅允许特定 `map_flags`（`BPF_F_NUMA_NODE`、`BPF_F_ZERO_SEED`、`BPF_F_ACCESS_MASK`）。\n- BTF 校验强制 key 类型为 `void`，符合“无 key”设计。\n\n## 4. 依赖关系\n\n- **内核头文件**：\n  - `<linux/bitmap.h>`：提供 `test_bit()`、`set_bit()` 等位操作。\n  - `<linux/bpf.h>`：eBPF 核心定义（`bpf_map`、操作码等）。\n  - `<linux/btf.h>`：BTF 类型系统支持。\n  - `<linux/jhash.h>`：Jenkins 哈希函数实现。\n  - `<linux/random.h>`：`get_random_u32()` 用于生成哈希种子。\n- **eBPF 子系统**：通过 `bpf_map_ops` 机制集成到 eBPF 映射框架中。\n- **内存管理**：依赖 `bpf_map_area_alloc/free` 进行 NUMA 感知内存分配。\n\n## 5. 使用场景\n\n- **网络数据包过滤**：快速判断 IP 地址、端口等是否在可疑集合中。\n- **安全监控**：检测进程、文件路径是否属于已知恶意样本（允许少量误报）。\n- **性能分析**：记录已观测到的事件 ID，避免重复处理。\n- **资源去重**：在无法存储完整集合的场景下，高效判断元素是否已存在。\n\n> **注意**：由于布隆过滤器**不支持删除操作**，且存在**假阳性**，适用于“写一次、查多次”且可容忍少量误报的场景。eBPF 程序需通过 `bpf_map_peek_elem()` 查询，通过 `bpf_map_push_elem()` 插入。",
      "similarity": 0.5292413830757141,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 23,
          "end_line": 117,
          "content": [
            "static u32 hash(struct bpf_bloom_filter *bloom, void *value,",
            "\t\tu32 value_size, u32 index)",
            "{",
            "\tu32 h;",
            "",
            "\tif (likely(value_size % 4 == 0))",
            "\t\th = jhash2(value, value_size / 4, bloom->hash_seed + index);",
            "\telse",
            "\t\th = jhash(value, value_size, bloom->hash_seed + index);",
            "",
            "\treturn h & bloom->bitset_mask;",
            "}",
            "static long bloom_map_peek_elem(struct bpf_map *map, void *value)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tif (!test_bit(h, bloom->bitset))",
            "\t\t\treturn -ENOENT;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_push_elem(struct bpf_map *map, void *value, u64 flags)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tif (flags != BPF_ANY)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tset_bit(h, bloom->bitset);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_pop_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static long bloom_map_delete_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_get_next_key(struct bpf_map *map, void *key, void *next_key)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_alloc_check(union bpf_attr *attr)",
            "{",
            "\tif (attr->value_size > KMALLOC_MAX_SIZE)",
            "\t\t/* if value_size is bigger, the user space won't be able to",
            "\t\t * access the elements.",
            "\t\t */",
            "\t\treturn -E2BIG;",
            "",
            "\treturn 0;",
            "}",
            "static void bloom_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "",
            "\tbpf_map_area_free(bloom);",
            "}",
            "static long bloom_map_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t  void *value, u64 flags)",
            "{",
            "\t/* The eBPF program should use map_push_elem instead */",
            "\treturn -EINVAL;",
            "}",
            "static int bloom_map_check_btf(const struct bpf_map *map,",
            "\t\t\t       const struct btf *btf,",
            "\t\t\t       const struct btf_type *key_type,",
            "\t\t\t       const struct btf_type *value_type)",
            "{",
            "\t/* Bloom filter maps are keyless */",
            "\treturn btf_type_is_void(key_type) ? 0 : -EINVAL;",
            "}",
            "static u64 bloom_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom;",
            "\tu64 bitset_bytes;",
            "",
            "\tbloom = container_of(map, struct bpf_bloom_filter, map);",
            "\tbitset_bytes = BITS_TO_BYTES((u64)bloom->bitset_mask + 1);",
            "\tbitset_bytes = roundup(bitset_bytes, sizeof(unsigned long));",
            "\treturn sizeof(*bloom) + bitset_bytes;",
            "}"
          ],
          "function_name": "hash, bloom_map_peek_elem, bloom_map_push_elem, bloom_map_pop_elem, bloom_map_delete_elem, bloom_map_get_next_key, bloom_map_alloc_check, bloom_map_free, bloom_map_update_elem, bloom_map_check_btf, bloom_map_mem_usage",
          "description": "实现Bloom过滤器核心操作，包括哈希计算、元素存在性检测、插入操作、内存校验、资源释放及内存占用统计，部分接口暂不支持并返回相应错误码",
          "similarity": 0.5064307451248169
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2021 Facebook */",
            "",
            "#include <linux/bitmap.h>",
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/err.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#define BLOOM_CREATE_FLAG_MASK \\",
            "\t(BPF_F_NUMA_NODE | BPF_F_ZERO_SEED | BPF_F_ACCESS_MASK)",
            "",
            "struct bpf_bloom_filter {",
            "\tstruct bpf_map map;",
            "\tu32 bitset_mask;",
            "\tu32 hash_seed;",
            "\tu32 nr_hash_funcs;",
            "\tunsigned long bitset[];",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义Bloom过滤器内核结构体，包含位图掩码、哈希种子、哈希函数数及动态扩展的位集合数组，用于eBPF程序中的布隆过滤器实现",
          "similarity": 0.40809136629104614
        }
      ]
    }
  ]
}