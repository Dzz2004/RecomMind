{
  "query": "内核能力检查函数实现",
  "timestamp": "2025-12-26 01:32:14",
  "retrieved_files": [
    {
      "source_file": "kernel/fail_function.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:29:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fail_function.c`\n\n---\n\n# fail_function.c 技术文档\n\n## 1. 文件概述\n\n`fail_function.c` 实现了基于函数的错误注入（Function-based Error Injection, FEI）机制，允许内核开发者在指定的可注入函数调用点动态注入预定义的错误返回值。该机制通过 kprobe 技术拦截目标函数的执行，并在满足故障注入条件时覆盖其返回值，用于测试内核错误处理路径的健壮性。所有功能通过 debugfs 接口暴露给用户空间，便于运行时控制。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct fei_attr`**  \n  表示一个错误注入点的元数据，包含：\n  - `list`：用于链入全局 `fei_attr_list` 链表\n  - `kp`：关联的 kprobe 实例，用于拦截函数执行\n  - `retval`：预设的错误返回值\n\n- **全局变量**\n  - `fei_lock`：保护 `fei_attr_list` 的互斥锁\n  - `fei_attr_list`：所有已注册错误注入点的链表\n  - `fei_fault_attr`：故障注入属性，控制注入概率/条件\n  - `fei_debugfs_dir`：debugfs 根目录句柄\n\n### 主要函数\n\n- **错误值调整**\n  - `adjust_error_retval()`：根据函数的可注入错误类型（如 `EI_ETYPE_ERRNO`、`EI_ETYPE_NULL` 等）校验并标准化返回值\n\n- **注入点管理**\n  - `fei_attr_new()` / `fei_attr_free()`：创建/销毁 `fei_attr` 实例\n  - `fei_attr_lookup()`：通过符号名查找注入点\n  - `fei_attr_is_valid()`：验证 `fei_attr` 是否仍在全局链表中\n  - `fei_attr_remove()` / `fei_attr_remove_all()`：移除单个或所有注入点\n\n- **Kprobe 处理**\n  - `fei_kprobe_handler()`：kprobe 前置处理函数，决定是否注入错误并覆盖返回值\n  - `fei_post_handler()`：空后置处理函数，防止 kprobe 优化\n\n- **Debugfs 接口**\n  - `fei_retval_get()` / `fei_retval_set()`：读写指定注入点的返回值\n  - `fei_write()`：主控制接口，支持添加/删除注入点\n  - `fei_seq_*()`：实现 `/sys/kernel/debug/fail_function/inject` 的列表读取\n\n- **初始化**\n  - `fei_debugfs_init()`：创建 debugfs 目录和文件\n\n## 3. 关键实现\n\n### 错误注入机制\n1. **函数拦截**：通过 kprobe 在目标函数入口处设置断点，触发 `fei_kprobe_handler`\n2. **条件判断**：调用 `should_fail(&fei_fault_attr, 1)` 检查是否满足注入条件（基于 `fail_function` 的故障属性配置）\n3. **返回值覆盖**：\n   - 调用 `regs_set_return_value(regs, attr->retval)` 设置返回值\n   - 调用 `override_function_with_return(regs)` 跳过原函数执行，直接返回\n\n### 安全性保障\n- **防优化**：`fei_post_handler` 作为空函数存在，阻止 kprobe 的跳转优化（因优化不支持执行路径覆盖）\n- **并发保护**：所有链表操作受 `fei_lock` 互斥锁保护\n- **有效性验证**：在 debugfs 回调中通过 `fei_attr_is_valid()` 检查对象是否已被释放\n\n### Debugfs 接口设计\n- **主控制文件** (`inject`)：\n  - **写入函数名**：添加新注入点（需在 `error_injection/list` 中注册）\n  - **写入 `!函数名`**：移除指定注入点\n  - **写入空内容**：清空所有注入点\n- **返回值文件** (`retval`)：每个注入点目录下独立的 `retval` 文件，支持动态修改返回值\n- **符号链接** (`injectable`)：指向 `error_injection/list`，显示所有可注入函数\n\n### 返回值类型处理\n`adjust_error_retval()` 根据函数声明的错误类型自动校验返回值：\n- `EI_ETYPE_NULL`：强制返回 `0`\n- `EI_ETYPE_ERRNO`：非错误值转换为 `-EINVAL`\n- `EI_ETYPE_ERRNO_NULL`：非零且非错误值转换为 `-EINVAL`\n- `EI_ETYPE_TRUE`：强制返回 `1`\n\n## 4. 依赖关系\n\n- **`<linux/error-injection.h>`**  \n  提供 `get_injectable_error_type()` 和 `within_error_injection_list()`，用于验证函数是否支持错误注入\n- **`<linux/fault-inject.h>`**  \n  提供 `DECLARE_FAULT_ATTR` 和 `should_fail()`，实现概率性故障注入控制\n- **`<linux/kprobes.h>`**  \n  核心拦截机制，通过 kprobe 动态修改函数执行流\n- **`<linux/kallsyms.h>`**  \n  通过 `kallsyms_lookup_name()` 解析函数符号地址\n- **`<linux/debugfs.h>`**  \n  提供用户空间控制接口\n- **`<linux/uaccess.h>`**  \n  处理用户空间数据拷贝（`memdup_user_nul`）\n\n## 5. 使用场景\n\n1. **内核错误路径测试**  \n   开发者可通过注入特定错误（如 `-ENOMEM`、`-EINVAL`）验证内核模块对异常返回值的处理逻辑\n\n2. **故障恢复验证**  \n   模拟硬件/驱动故障（如 I/O 失败），测试系统恢复机制（如重试、降级、崩溃防护）\n\n3. **安全边界测试**  \n   验证内核在非法返回值（如非错误码的正数）下的行为是否符合预期\n\n4. **动态调试**  \n   运行时无需重新编译内核，通过 debugfs 快速启用/禁用特定函数的错误注入\n\n**典型操作流程**：\n```bash\n# 查看可注入函数列表\ncat /sys/kernel/debug/error_injection/list\n\n# 为目标函数添加注入点\necho \"some_function\" > /sys/kernel/debug/fail_function/inject\n\n# 设置返回值为 -ENOMEM\necho -12 > /sys/kernel/debug/fail_function/some_function/retval\n\n# 触发故障（需先配置故障属性）\necho 100 > /sys/kernel/debug/fail_function/probability  # 100% 概率\n\n# 移除注入点\necho \"!some_function\" > /sys/kernel/debug/fail_function/inject\n```",
      "similarity": 0.6196787357330322,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/fail_function.c",
          "start_line": 17,
          "end_line": 117,
          "content": [
            "static void fei_post_handler(struct kprobe *kp, struct pt_regs *regs,",
            "\t\t\t     unsigned long flags)",
            "{",
            "\t/*",
            "\t * A dummy post handler is required to prohibit optimizing, because",
            "\t * jump optimization does not support execution path overriding.",
            "\t */",
            "}",
            "static unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)",
            "{",
            "\tswitch (get_injectable_error_type(addr)) {",
            "\tcase EI_ETYPE_NULL:",
            "\t\treturn 0;",
            "\tcase EI_ETYPE_ERRNO:",
            "\t\tif (retv < (unsigned long)-MAX_ERRNO)",
            "\t\t\treturn (unsigned long)-EINVAL;",
            "\t\tbreak;",
            "\tcase EI_ETYPE_ERRNO_NULL:",
            "\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)",
            "\t\t\treturn (unsigned long)-EINVAL;",
            "\t\tbreak;",
            "\tcase EI_ETYPE_TRUE:",
            "\t\treturn 1;",
            "\t}",
            "",
            "\treturn retv;",
            "}",
            "static void fei_attr_free(struct fei_attr *attr)",
            "{",
            "\tif (attr) {",
            "\t\tkfree(attr->kp.symbol_name);",
            "\t\tkfree(attr);",
            "\t}",
            "}",
            "static bool fei_attr_is_valid(struct fei_attr *_attr)",
            "{",
            "\tstruct fei_attr *attr;",
            "",
            "\tlist_for_each_entry(attr, &fei_attr_list, list) {",
            "\t\tif (attr == _attr)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static int fei_retval_set(void *data, u64 val)",
            "{",
            "\tstruct fei_attr *attr = data;",
            "\tunsigned long retv = (unsigned long)val;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&fei_lock);",
            "\t/*",
            "\t * Since this operation can be done after retval file is removed,",
            "\t * It is safer to check the attr is still valid before accessing",
            "\t * its member.",
            "\t */",
            "\tif (!fei_attr_is_valid(attr)) {",
            "\t\terr = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (attr->kp.addr) {",
            "\t\tif (adjust_error_retval((unsigned long)attr->kp.addr,",
            "\t\t\t\t\tval) != retv)",
            "\t\t\terr = -EINVAL;",
            "\t}",
            "\tif (!err)",
            "\t\tattr->retval = val;",
            "out:",
            "\tmutex_unlock(&fei_lock);",
            "",
            "\treturn err;",
            "}",
            "static int fei_retval_get(void *data, u64 *val)",
            "{",
            "\tstruct fei_attr *attr = data;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&fei_lock);",
            "\t/* Here we also validate @attr to ensure it still exists. */",
            "\tif (!fei_attr_is_valid(attr))",
            "\t\terr = -ENOENT;",
            "\telse",
            "\t\t*val = attr->retval;",
            "\tmutex_unlock(&fei_lock);",
            "",
            "\treturn err;",
            "}",
            "static void fei_debugfs_add_attr(struct fei_attr *attr)",
            "{",
            "\tstruct dentry *dir;",
            "",
            "\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);",
            "",
            "\tdebugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops);",
            "}",
            "static void fei_debugfs_remove_attr(struct fei_attr *attr)",
            "{",
            "\tdebugfs_lookup_and_remove(attr->kp.symbol_name, fei_debugfs_dir);",
            "}"
          ],
          "function_name": "fei_post_handler, adjust_error_retval, fei_attr_free, fei_attr_is_valid, fei_retval_set, fei_retval_get, fei_debugfs_add_attr, fei_debugfs_remove_attr",
          "description": "实现错误注入的核心逻辑，包括返回值调整、属性管理、debugfs接口创建及验证机制",
          "similarity": 0.5420315265655518
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/fail_function.c",
          "start_line": 169,
          "end_line": 280,
          "content": [
            "static int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs)",
            "{",
            "\tstruct fei_attr *attr = container_of(kp, struct fei_attr, kp);",
            "",
            "\tif (should_fail(&fei_fault_attr, 1)) {",
            "\t\tregs_set_return_value(regs, attr->retval);",
            "\t\toverride_function_with_return(regs);",
            "\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void fei_seq_stop(struct seq_file *m, void *v)",
            "{",
            "\tmutex_unlock(&fei_lock);",
            "}",
            "static int fei_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct fei_attr *attr = list_entry(v, struct fei_attr, list);",
            "",
            "\tseq_printf(m, \"%ps\\n\", attr->kp.addr);",
            "\treturn 0;",
            "}",
            "static int fei_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn seq_open(file, &fei_seq_ops);",
            "}",
            "static void fei_attr_remove(struct fei_attr *attr)",
            "{",
            "\tfei_debugfs_remove_attr(attr);",
            "\tunregister_kprobe(&attr->kp);",
            "\tlist_del(&attr->list);",
            "\tfei_attr_free(attr);",
            "}",
            "static void fei_attr_remove_all(void)",
            "{",
            "\tstruct fei_attr *attr, *n;",
            "",
            "\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {",
            "\t\tfei_attr_remove(attr);",
            "\t}",
            "}",
            "static ssize_t fei_write(struct file *file, const char __user *buffer,",
            "\t\t\t size_t count, loff_t *ppos)",
            "{",
            "\tstruct fei_attr *attr;",
            "\tunsigned long addr;",
            "\tchar *buf, *sym;",
            "\tint ret;",
            "",
            "\t/* cut off if it is too long */",
            "\tif (count > KSYM_NAME_LEN)",
            "\t\tcount = KSYM_NAME_LEN;",
            "",
            "\tbuf = memdup_user_nul(buffer, count);",
            "\tif (IS_ERR(buf))",
            "\t\treturn PTR_ERR(buf);",
            "",
            "\tsym = strstrip(buf);",
            "",
            "\tmutex_lock(&fei_lock);",
            "",
            "\t/* Writing just spaces will remove all injection points */",
            "\tif (sym[0] == '\\0') {",
            "\t\tfei_attr_remove_all();",
            "\t\tret = count;",
            "\t\tgoto out;",
            "\t}",
            "\t/* Writing !function will remove one injection point */",
            "\tif (sym[0] == '!') {",
            "\t\tattr = fei_attr_lookup(sym + 1);",
            "\t\tif (!attr) {",
            "\t\t\tret = -ENOENT;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tfei_attr_remove(attr);",
            "\t\tret = count;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\taddr = kallsyms_lookup_name(sym);",
            "\tif (!addr) {",
            "\t\tret = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "\tif (!within_error_injection_list(addr)) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tif (fei_attr_lookup(sym)) {",
            "\t\tret = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "\tattr = fei_attr_new(sym, addr);",
            "\tif (!attr) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = register_kprobe(&attr->kp);",
            "\tif (ret) {",
            "\t\tfei_attr_free(attr);",
            "\t\tgoto out;",
            "\t}",
            "\tfei_debugfs_add_attr(attr);",
            "\tlist_add_tail(&attr->list, &fei_attr_list);",
            "\tret = count;",
            "out:",
            "\tmutex_unlock(&fei_lock);",
            "\tkfree(buf);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "fei_kprobe_handler, fei_seq_stop, fei_seq_show, fei_open, fei_attr_remove, fei_attr_remove_all, fei_write",
          "description": "实现kprobe处理函数和序列化展示接口，支持动态添加/移除错误注入点并通过文件操作控制",
          "similarity": 0.5254331827163696
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/fail_function.c",
          "start_line": 1,
          "end_line": 16,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * fail_function.c: Function-based error injection",
            " */",
            "#include <linux/error-injection.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "",
            "static int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);",
            ""
          ],
          "function_name": null,
          "description": "定义错误注入模块所需头文件并声明kprobe处理函数，为后续错误注入功能提供基础支持",
          "similarity": 0.5178961157798767
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/fail_function.c",
          "start_line": 315,
          "end_line": 332,
          "content": [
            "static int __init fei_debugfs_init(void)",
            "{",
            "\tstruct dentry *dir;",
            "",
            "\tdir = fault_create_debugfs_attr(\"fail_function\", NULL,",
            "\t\t\t\t\t&fei_fault_attr);",
            "\tif (IS_ERR(dir))",
            "\t\treturn PTR_ERR(dir);",
            "",
            "\t/* injectable attribute is just a symlink of error_inject/list */",
            "\tdebugfs_create_symlink(\"injectable\", dir, \"../error_injection/list\");",
            "",
            "\tdebugfs_create_file(\"inject\", 0600, dir, NULL, &fei_ops);",
            "",
            "\tfei_debugfs_dir = dir;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "fei_debugfs_init",
          "description": "初始化debugfs调试接口，创建错误注入配置文件和符号链接以供用户空间访问",
          "similarity": 0.4687238037586212
        }
      ]
    },
    {
      "source_file": "kernel/kcsan/selftest.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:22:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kcsan\\selftest.c`\n\n---\n\n# kcsan/selftest.c 技术文档\n\n## 1. 文件概述\n\n`kcsan/selftest.c` 是 Linux 内核中 KCSAN（Kernel Concurrency Sanitizer）模块的启动时自检代码文件。该文件在内核启动阶段执行一系列轻量级的单元测试，用于验证 KCSAN 核心机制的正确性，包括：\n\n- 监视点（watchpoint）编码/解码逻辑的完整性\n- 内存访问冲突检测中的访问匹配算法\n- 内存屏障（memory barrier）的正确插桩（instrumentation）\n\n这些自检有助于在早期发现 KCSAN 自身实现中的缺陷，避免因工具本身的错误导致误报或漏报。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `test_encode_decode(void)` | 验证 `encode_watchpoint()` 和 `decode_watchpoint()` 的正确性，确保编码后的监视点信息可完整还原 |\n| `test_matching_access(void)` | 测试 `matching_access()` 函数对重叠内存访问的判断逻辑是否符合预期 |\n| `test_barrier(void)` | 检查各类内存屏障和原子操作是否被 KCSAN 正确插桩，确保在弱内存模型下不会产生误报 |\n\n### 关键宏与辅助结构\n\n- `ITERS_PER_TEST`：定义每个测试的迭代次数（2000 次），用于随机化测试覆盖\n- `__KCSAN_CHECK_BARRIER` / `KCSAN_CHECK_READ_BARRIER` 等宏：用于检测特定屏障操作是否清除了当前作用域访问（`reorder_access`），从而验证插桩有效性\n- `test_spinlock`：用于测试自旋锁相关屏障的静态定义自旋锁\n\n## 3. 关键实现\n\n### 3.1 监视点编码/解码测试 (`test_encode_decode`)\n\n- 随机生成合法的内存地址（避开低地址区域）和访问大小（1 到 `MAX_ENCODABLE_SIZE`）\n- 随机选择读/写类型\n- 调用 `encode_watchpoint()` 编码，再通过 `decode_watchpoint()` 解码\n- 验证解码结果与原始输入一致，包括：\n  - 地址（经 `WATCHPOINT_ADDR_MASK` 掩码处理）\n  - 访问大小\n  - 读写标志\n- 同时验证特殊监视点（`INVALID_WATCHPOINT` 和 `CONSUMED_WATCHPOINT`）不会被错误解码\n\n### 3.2 访问匹配逻辑测试 (`test_matching_access`)\n\n- 使用预设的地址/大小组合验证 `matching_access()` 的边界行为：\n  - 相同地址相同大小 → 匹配\n  - 部分重叠（如 [10,11) 与 [11,12)）→ 不匹配\n  - 完全包含或相邻重叠 → 匹配\n- 特别测试大小为 0 的访问：虽然逻辑上可能匹配，但 KCSAN 在实际检查中会跳过 size=0 的访问，因此此处仅验证函数行为一致性\n\n### 3.3 内存屏障插桩测试 (`test_barrier`)\n\n- 仅在启用 `CONFIG_KCSAN_WEAK_MEMORY` 且为 SMP 系统时执行\n- 利用 `current->kcsan_ctx.reorder_access` 结构模拟一个“作用域访问”\n- 对每类屏障/原子操作：\n  1. 设置 `reorder_access` 为有效状态（size=1）\n  2. 执行屏障操作\n  3. 检查 `reorder_access->size` 是否被置 0\n- 若未被清零，说明该操作未被 KCSAN 正确插桩，可能导致弱内存序下的误报\n\n> **注意**：该测试依赖 KCSAN 在屏障处插入的运行时检查逻辑，若插桩缺失，则 `reorder_access` 不会被清除。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/kcsan-checks.h>`：提供 KCSAN 核心 API（如 `encode_watchpoint`、`matching_access`）\n- `\"encoding.h\"`：包含监视点编码相关的内部定义（如 `WATCHPOINT_ADDR_MASK`、特殊监视点常量）\n- 其他标准内核头文件：提供原子操作、自旋锁、内存屏障、随机数等基础功能\n\n### 内核配置依赖\n- `CONFIG_KCSAN`：必须启用 KCSAN\n- `CONFIG_KCSAN_WEAK_MEMORY`：控制是否执行内存屏障测试\n- `CONFIG_SMP`：多处理器支持，影响屏障测试的执行条件\n\n### 运行时依赖\n- `current->kcsan_ctx`：依赖任务结构中的 KCSAN 上下文\n- 内核随机数生成器：用于随机化测试输入\n\n## 5. 使用场景\n\n- **内核启动阶段**：作为 `init` 段代码，在 KCSAN 初始化完成后立即执行\n- **开发与调试**：帮助 KCSAN 开发者验证核心逻辑变更的正确性\n- **CI/测试环境**：作为内核自检的一部分，确保 KCSAN 工具链的可靠性\n- **弱内存模型平台验证**：在 ARM、PowerPC 等弱一致性架构上，确保内存屏障插桩完整，避免并发误报\n\n> 该自检为“短时启动自检”（short boot-time selftests），设计为快速执行，不影响正常启动流程。更全面的测试由 `kcsan_test.ko` 模块提供。",
      "similarity": 0.6137621998786926,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/kcsan/selftest.c",
          "start_line": 238,
          "end_line": 260,
          "content": [
            "static int __init kcsan_selftest(void)",
            "{",
            "\tint passed = 0;",
            "\tint total = 0;",
            "",
            "#define RUN_TEST(do_test)                                                      \\",
            "\tdo {                                                                   \\",
            "\t\t++total;                                                       \\",
            "\t\tif (do_test())                                                 \\",
            "\t\t\t++passed;                                              \\",
            "\t\telse                                                           \\",
            "\t\t\tpr_err(\"selftest: \" #do_test \" failed\");               \\",
            "\t} while (0)",
            "",
            "\tRUN_TEST(test_encode_decode);",
            "\tRUN_TEST(test_matching_access);",
            "\tRUN_TEST(test_barrier);",
            "",
            "\tpr_info(\"selftest: %d/%d tests passed\\n\", passed, total);",
            "\tif (passed != total)",
            "\t\tpanic(\"selftests failed\");",
            "\treturn 0;",
            "}"
          ],
          "function_name": "kcsan_selftest",
          "description": "作为KCSAN自测入口点，依次执行三个测试用例并统计结果，最终通过率不达100%时触发内核 panic。",
          "similarity": 0.5837671756744385
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kcsan/selftest.c",
          "start_line": 29,
          "end_line": 227,
          "content": [
            "static bool __init test_encode_decode(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < ITERS_PER_TEST; ++i) {",
            "\t\tsize_t size = get_random_u32_inclusive(1, MAX_ENCODABLE_SIZE);",
            "\t\tbool is_write = !!get_random_u32_below(2);",
            "\t\tunsigned long verif_masked_addr;",
            "\t\tlong encoded_watchpoint;",
            "\t\tbool verif_is_write;",
            "\t\tunsigned long addr;",
            "\t\tsize_t verif_size;",
            "",
            "\t\tget_random_bytes(&addr, sizeof(addr));",
            "\t\tif (addr < PAGE_SIZE)",
            "\t\t\taddr = PAGE_SIZE;",
            "",
            "\t\tif (WARN_ON(!check_encodable(addr, size)))",
            "\t\t\treturn false;",
            "",
            "\t\tencoded_watchpoint = encode_watchpoint(addr, size, is_write);",
            "",
            "\t\t/* Check special watchpoints */",
            "\t\tif (WARN_ON(decode_watchpoint(INVALID_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)))",
            "\t\t\treturn false;",
            "\t\tif (WARN_ON(decode_watchpoint(CONSUMED_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)))",
            "\t\t\treturn false;",
            "",
            "\t\t/* Check decoding watchpoint returns same data */",
            "\t\tif (WARN_ON(!decode_watchpoint(encoded_watchpoint, &verif_masked_addr, &verif_size, &verif_is_write)))",
            "\t\t\treturn false;",
            "\t\tif (WARN_ON(verif_masked_addr != (addr & WATCHPOINT_ADDR_MASK)))",
            "\t\t\tgoto fail;",
            "\t\tif (WARN_ON(verif_size != size))",
            "\t\t\tgoto fail;",
            "\t\tif (WARN_ON(is_write != verif_is_write))",
            "\t\t\tgoto fail;",
            "",
            "\t\tcontinue;",
            "fail:",
            "\t\tpr_err(\"%s fail: %s %zu bytes @ %lx -> encoded: %lx -> %s %zu bytes @ %lx\\n\",",
            "\t\t       __func__, is_write ? \"write\" : \"read\", size, addr, encoded_watchpoint,",
            "\t\t       verif_is_write ? \"write\" : \"read\", verif_size, verif_masked_addr);",
            "\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static bool __init test_matching_access(void)",
            "{",
            "\tif (WARN_ON(!matching_access(10, 1, 10, 1)))",
            "\t\treturn false;",
            "\tif (WARN_ON(!matching_access(10, 2, 11, 1)))",
            "\t\treturn false;",
            "\tif (WARN_ON(!matching_access(10, 1, 9, 2)))",
            "\t\treturn false;",
            "\tif (WARN_ON(matching_access(10, 1, 11, 1)))",
            "\t\treturn false;",
            "\tif (WARN_ON(matching_access(9, 1, 10, 1)))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * An access of size 0 could match another access, as demonstrated here.",
            "\t * Rather than add more comparisons to 'matching_access()', which would",
            "\t * end up in the fast-path for *all* checks, check_access() simply",
            "\t * returns for all accesses of size 0.",
            "\t */",
            "\tif (WARN_ON(!matching_access(8, 8, 12, 0)))",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static bool __init test_barrier(void)",
            "{",
            "#ifdef CONFIG_KCSAN_WEAK_MEMORY",
            "\tstruct kcsan_scoped_access *reorder_access = &current->kcsan_ctx.reorder_access;",
            "#else",
            "\tstruct kcsan_scoped_access *reorder_access = NULL;",
            "#endif",
            "\tbool ret = true;",
            "\tarch_spinlock_t arch_spinlock = __ARCH_SPIN_LOCK_UNLOCKED;",
            "\tatomic_t dummy;",
            "\tlong test_var;",
            "",
            "\tif (!reorder_access || !IS_ENABLED(CONFIG_SMP))",
            "\t\treturn true;",
            "",
            "#define __KCSAN_CHECK_BARRIER(access_type, barrier, name)\t\t\t\t\t\\",
            "\tdo {\t\t\t\t\t\t\t\t\t\t\t\\",
            "\t\treorder_access->type = (access_type) | KCSAN_ACCESS_SCOPED;\t\t\t\\",
            "\t\treorder_access->size = 1;\t\t\t\t\t\t\t\\",
            "\t\tbarrier;\t\t\t\t\t\t\t\t\t\\",
            "\t\tif (reorder_access->size != 0) {\t\t\t\t\t\t\\",
            "\t\t\tpr_err(\"improperly instrumented type=(\" #access_type \"): \" name \"\\n\");\t\\",
            "\t\t\tret = false;\t\t\t\t\t\t\t\t\\",
            "\t\t}\t\t\t\t\t\t\t\t\t\t\\",
            "\t} while (0)",
            "#define KCSAN_CHECK_READ_BARRIER(b)  __KCSAN_CHECK_BARRIER(0, b, #b)",
            "#define KCSAN_CHECK_WRITE_BARRIER(b) __KCSAN_CHECK_BARRIER(KCSAN_ACCESS_WRITE, b, #b)",
            "#define KCSAN_CHECK_RW_BARRIER(b)    __KCSAN_CHECK_BARRIER(KCSAN_ACCESS_WRITE | KCSAN_ACCESS_COMPOUND, b, #b)",
            "",
            "\tkcsan_nestable_atomic_begin(); /* No watchpoints in called functions. */",
            "",
            "\tKCSAN_CHECK_READ_BARRIER(mb());",
            "\tKCSAN_CHECK_READ_BARRIER(rmb());",
            "\tKCSAN_CHECK_READ_BARRIER(smp_mb());",
            "\tKCSAN_CHECK_READ_BARRIER(smp_rmb());",
            "\tKCSAN_CHECK_READ_BARRIER(dma_rmb());",
            "\tKCSAN_CHECK_READ_BARRIER(smp_mb__before_atomic());",
            "\tKCSAN_CHECK_READ_BARRIER(smp_mb__after_atomic());",
            "\tKCSAN_CHECK_READ_BARRIER(smp_mb__after_spinlock());",
            "\tKCSAN_CHECK_READ_BARRIER(smp_store_mb(test_var, 0));",
            "\tKCSAN_CHECK_READ_BARRIER(smp_store_release(&test_var, 0));",
            "\tKCSAN_CHECK_READ_BARRIER(xchg(&test_var, 0));",
            "\tKCSAN_CHECK_READ_BARRIER(xchg_release(&test_var, 0));",
            "\tKCSAN_CHECK_READ_BARRIER(cmpxchg(&test_var, 0,  0));",
            "\tKCSAN_CHECK_READ_BARRIER(cmpxchg_release(&test_var, 0,  0));",
            "\tKCSAN_CHECK_READ_BARRIER(atomic_set_release(&dummy, 0));",
            "\tKCSAN_CHECK_READ_BARRIER(atomic_add_return(1, &dummy));",
            "\tKCSAN_CHECK_READ_BARRIER(atomic_add_return_release(1, &dummy));",
            "\tKCSAN_CHECK_READ_BARRIER(atomic_fetch_add(1, &dummy));",
            "\tKCSAN_CHECK_READ_BARRIER(atomic_fetch_add_release(1, &dummy));",
            "\tKCSAN_CHECK_READ_BARRIER(test_and_set_bit(0, &test_var));",
            "\tKCSAN_CHECK_READ_BARRIER(test_and_clear_bit(0, &test_var));",
            "\tKCSAN_CHECK_READ_BARRIER(test_and_change_bit(0, &test_var));",
            "\tKCSAN_CHECK_READ_BARRIER(clear_bit_unlock(0, &test_var));",
            "\tKCSAN_CHECK_READ_BARRIER(__clear_bit_unlock(0, &test_var));",
            "\tarch_spin_lock(&arch_spinlock);",
            "\tKCSAN_CHECK_READ_BARRIER(arch_spin_unlock(&arch_spinlock));",
            "\tspin_lock(&test_spinlock);",
            "\tKCSAN_CHECK_READ_BARRIER(spin_unlock(&test_spinlock));",
            "",
            "\tKCSAN_CHECK_WRITE_BARRIER(mb());",
            "\tKCSAN_CHECK_WRITE_BARRIER(wmb());",
            "\tKCSAN_CHECK_WRITE_BARRIER(smp_mb());",
            "\tKCSAN_CHECK_WRITE_BARRIER(smp_wmb());",
            "\tKCSAN_CHECK_WRITE_BARRIER(dma_wmb());",
            "\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__before_atomic());",
            "\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__after_atomic());",
            "\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__after_spinlock());",
            "\tKCSAN_CHECK_WRITE_BARRIER(smp_store_mb(test_var, 0));",
            "\tKCSAN_CHECK_WRITE_BARRIER(smp_store_release(&test_var, 0));",
            "\tKCSAN_CHECK_WRITE_BARRIER(xchg(&test_var, 0));",
            "\tKCSAN_CHECK_WRITE_BARRIER(xchg_release(&test_var, 0));",
            "\tKCSAN_CHECK_WRITE_BARRIER(cmpxchg(&test_var, 0,  0));",
            "\tKCSAN_CHECK_WRITE_BARRIER(cmpxchg_release(&test_var, 0,  0));",
            "\tKCSAN_CHECK_WRITE_BARRIER(atomic_set_release(&dummy, 0));",
            "\tKCSAN_CHECK_WRITE_BARRIER(atomic_add_return(1, &dummy));",
            "\tKCSAN_CHECK_WRITE_BARRIER(atomic_add_return_release(1, &dummy));",
            "\tKCSAN_CHECK_WRITE_BARRIER(atomic_fetch_add(1, &dummy));",
            "\tKCSAN_CHECK_WRITE_BARRIER(atomic_fetch_add_release(1, &dummy));",
            "\tKCSAN_CHECK_WRITE_BARRIER(test_and_set_bit(0, &test_var));",
            "\tKCSAN_CHECK_WRITE_BARRIER(test_and_clear_bit(0, &test_var));",
            "\tKCSAN_CHECK_WRITE_BARRIER(test_and_change_bit(0, &test_var));",
            "\tKCSAN_CHECK_WRITE_BARRIER(clear_bit_unlock(0, &test_var));",
            "\tKCSAN_CHECK_WRITE_BARRIER(__clear_bit_unlock(0, &test_var));",
            "\tarch_spin_lock(&arch_spinlock);",
            "\tKCSAN_CHECK_WRITE_BARRIER(arch_spin_unlock(&arch_spinlock));",
            "\tspin_lock(&test_spinlock);",
            "\tKCSAN_CHECK_WRITE_BARRIER(spin_unlock(&test_spinlock));",
            "",
            "\tKCSAN_CHECK_RW_BARRIER(mb());",
            "\tKCSAN_CHECK_RW_BARRIER(wmb());",
            "\tKCSAN_CHECK_RW_BARRIER(rmb());",
            "\tKCSAN_CHECK_RW_BARRIER(smp_mb());",
            "\tKCSAN_CHECK_RW_BARRIER(smp_wmb());",
            "\tKCSAN_CHECK_RW_BARRIER(smp_rmb());",
            "\tKCSAN_CHECK_RW_BARRIER(dma_wmb());",
            "\tKCSAN_CHECK_RW_BARRIER(dma_rmb());",
            "\tKCSAN_CHECK_RW_BARRIER(smp_mb__before_atomic());",
            "\tKCSAN_CHECK_RW_BARRIER(smp_mb__after_atomic());",
            "\tKCSAN_CHECK_RW_BARRIER(smp_mb__after_spinlock());",
            "\tKCSAN_CHECK_RW_BARRIER(smp_store_mb(test_var, 0));",
            "\tKCSAN_CHECK_RW_BARRIER(smp_store_release(&test_var, 0));",
            "\tKCSAN_CHECK_RW_BARRIER(xchg(&test_var, 0));",
            "\tKCSAN_CHECK_RW_BARRIER(xchg_release(&test_var, 0));",
            "\tKCSAN_CHECK_RW_BARRIER(cmpxchg(&test_var, 0,  0));",
            "\tKCSAN_CHECK_RW_BARRIER(cmpxchg_release(&test_var, 0,  0));",
            "\tKCSAN_CHECK_RW_BARRIER(atomic_set_release(&dummy, 0));",
            "\tKCSAN_CHECK_RW_BARRIER(atomic_add_return(1, &dummy));",
            "\tKCSAN_CHECK_RW_BARRIER(atomic_add_return_release(1, &dummy));",
            "\tKCSAN_CHECK_RW_BARRIER(atomic_fetch_add(1, &dummy));",
            "\tKCSAN_CHECK_RW_BARRIER(atomic_fetch_add_release(1, &dummy));",
            "\tKCSAN_CHECK_RW_BARRIER(test_and_set_bit(0, &test_var));",
            "\tKCSAN_CHECK_RW_BARRIER(test_and_clear_bit(0, &test_var));",
            "\tKCSAN_CHECK_RW_BARRIER(test_and_change_bit(0, &test_var));",
            "\tKCSAN_CHECK_RW_BARRIER(clear_bit_unlock(0, &test_var));",
            "\tKCSAN_CHECK_RW_BARRIER(__clear_bit_unlock(0, &test_var));",
            "\tarch_spin_lock(&arch_spinlock);",
            "\tKCSAN_CHECK_RW_BARRIER(arch_spin_unlock(&arch_spinlock));",
            "\tspin_lock(&test_spinlock);",
            "\tKCSAN_CHECK_RW_BARRIER(spin_unlock(&test_spinlock));",
            "\tKCSAN_CHECK_RW_BARRIER(xor_unlock_is_negative_byte(1, &test_var));",
            "\tKCSAN_CHECK_READ_BARRIER(xor_unlock_is_negative_byte(1, &test_var));",
            "\tKCSAN_CHECK_WRITE_BARRIER(xor_unlock_is_negative_byte(1, &test_var));",
            "\tkcsan_nestable_atomic_end();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "test_encode_decode, test_matching_access, test_barrier",
          "description": "实现三个核心测试函数，test_encode_decode验证地址编码解码一致性，test_matching_access检测访问类型匹配规则，test_barrier检查内存屏障对KCSAN仪器化的影响。",
          "similarity": 0.5814882516860962
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/kcsan/selftest.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * KCSAN short boot-time selftests.",
            " *",
            " * Copyright (C) 2019, Google LLC.",
            " */",
            "",
            "#define pr_fmt(fmt) \"kcsan: \" fmt",
            "",
            "#include <linux/atomic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/printk.h>",
            "#include <linux/random.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "",
            "#include \"encoding.h\"",
            "",
            "#define ITERS_PER_TEST 2000",
            "",
            "/*",
            " * Test watchpoint encode and decode: check that encoding some access's info,",
            " * and then subsequent decode preserves the access's info.",
            " */"
          ],
          "function_name": null,
          "description": "定义KCSAN自测框架基础结构，包含头文件、宏定义及测试迭代次数常量，用于验证watchpoint编码解码逻辑的正确性。",
          "similarity": 0.4773213565349579
        }
      ]
    },
    {
      "source_file": "kernel/kallsyms_selftest.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:14:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kallsyms_selftest.c`\n\n---\n\n# kallsyms_selftest.c 技术文档\n\n## 文件概述\n\n`kallsyms_selftest.c` 是 Linux 内核中用于对 `kallsyms`（内核符号表）子系统进行功能验证和性能测试的自检模块。该文件通过一系列测试用例，验证 `kallsyms_lookup_name()`、`kallsyms_on_each_symbol()` 和 `kallsyms_on_each_match_symbol()` 等核心接口的正确性，并评估其性能表现。同时，该模块还计算内核符号表的压缩率，用于评估符号表存储效率。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct test_stat`**  \n  用于记录测试过程中的统计信息，包括最小/最大耗时、调用次数、地址记录、累计时间等。\n\n- **`struct test_item`**  \n  定义测试项，包含符号名称和预期地址，用于验证符号解析的准确性。\n\n- **`test_items[]`**  \n  预定义的测试符号数组，涵盖静态函数、全局函数、弱符号以及（在 `CONFIG_KALLSYMS_ALL` 启用时）全局和静态变量。\n\n### 主要函数\n\n- **`test_kallsyms_basic_function()`**  \n  核心功能测试函数，验证三种符号查找接口对预定义符号的解析是否准确。\n\n- **`test_kallsyms_compression_ratio()`**  \n  计算并输出内核符号表的压缩率，包括原始符号名总长度与压缩后实际占用内存的对比。\n\n- **`test_perf_kallsyms_lookup_name()`**  \n  性能测试：遍历所有符号，测量 `kallsyms_lookup_name()` 的单次调用耗时（最小值、最大值、平均值）。\n\n- **`test_perf_kallsyms_on_each_symbol()`**  \n  性能测试：使用一个不可能匹配的“桩”符号名，遍历整个符号表，测量 `kallsyms_on_each_symbol()` 的总耗时。\n\n- **`test_perf_kallsyms_on_each_match_symbol()`**  \n  性能测试：使用桩符号名调用 `kallsyms_on_each_match_symbol()`，测量其遍历耗时。\n\n- **`lookup_name()` / `find_symbol()` / `match_symbol()`**  \n  回调函数，分别用于上述性能测试和功能验证中，收集统计信息。\n\n- **`match_cleanup_name()`**  \n  辅助函数，用于处理 Clang LTO（Link Time Optimization）编译时生成的带 `.llvm.` 后缀的符号名，确保测试兼容性。\n\n## 关键实现\n\n1. **测试符号设计**  \n   模块内部定义了多种类型的符号（静态函数、全局函数、弱函数、BSS/DATA 段变量），覆盖 `kallsyms` 支持的不同符号类别。变量测试仅在 `CONFIG_KALLSYMS_ALL` 配置启用时进行。\n\n2. **桩符号（Stub Symbol）生成**  \n   为避免在性能测试中因匹配成功而提前退出，模块构造一个由数字 `'4'` 组成的符号名（符号名不能以数字开头，确保无匹配）。其长度设为所有符号名的平均长度，使测试更贴近真实场景。\n\n3. **压缩率计算逻辑**  \n   - 通过 `kallsyms_on_each_symbol()` 累加所有符号名长度得到原始大小（`total_len`）。\n   - 手动解析 `kallsyms_names[]` 数组的压缩格式（支持 7/15 位长度编码），计算压缩后数据区大小（`off - num`，排除长度字段）。\n   - 加上 `kallsyms_token_table[]` 和 `kallsyms_token_index[]` 的内存开销，得到总压缩大小（`total_size`）。\n   - 最终计算压缩率：`ratio = (total_size * 10000) / total_len`，以百分比形式输出（保留两位小数）。\n\n4. **LTO 符号兼容性处理**  \n   在启用 Clang LTO 时，编译器会为符号添加 `.llvm.<hash>` 后缀。`match_cleanup_name()` 函数通过检查前缀是否匹配原始符号名，确保测试能正确识别这类符号。\n\n5. **性能测量方法**  \n   使用 `ktime_get_ns()` 获取纳秒级高精度时间戳，在每次符号查找前后采样，计算单次或整体操作耗时。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/kallsyms.h>`：提供 `kallsyms_lookup_name()`、`kallsyms_on_each_symbol()` 等公共接口。\n  - `\"kallsyms_internal.h\"`：访问 `kallsyms` 内部数据结构（如 `kallsyms_names`、`kallsyms_token_table`、`kallsyms_num_syms`），用于压缩率计算。\n  - `\"kallsyms_selftest.h\"`：可能包含测试相关的辅助定义（本文件未展示其内容）。\n  - 其他通用内核头文件（`init.h`, `module.h`, `random.h`, `sched/clock.h`, `kthread.h`, `vmalloc.h`）。\n\n- **配置依赖**：\n  - `CONFIG_KALLSYMS`：必须启用，否则 `kallsyms` 功能不可用。\n  - `CONFIG_KALLSYMS_ALL`：控制是否测试变量符号。\n  - `CONFIG_LTO_CLANG`：影响符号名后缀处理逻辑。\n\n- **函数依赖**：\n  - 依赖 `vmalloc_noprof` 和 `vfree` 作为已知内核函数符号进行测试。\n  - 使用 `is_ksym_addr()` 判断地址是否属于内核符号范围（代码片段末尾未完整展示）。\n\n## 使用场景\n\n- **内核开发与调试**：在开发或修改 `kallsyms` 相关代码后，加载此模块可快速验证符号解析功能是否正常。\n- **性能基准测试**：评估不同内核版本或配置下 `kallsyms` 接口的性能变化，特别是在符号表规模较大时的查找效率。\n- **压缩算法验证**：监控符号表压缩率，帮助优化内核镜像大小（尤其在嵌入式或资源受限环境中）。\n- **CI/CD 自动化测试**：可集成到内核持续集成流程中，作为 `kallsyms` 子系统的回归测试用例。\n- **LTO 编译兼容性验证**：确保在使用 Clang LTO 编译内核时，`kallsyms` 仍能正确处理修饰后的符号名。",
      "similarity": 0.6132721304893494,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/kallsyms_selftest.c",
          "start_line": 430,
          "end_line": 466,
          "content": [
            "static int test_entry(void *p)",
            "{",
            "\tint ret;",
            "",
            "\tdo {",
            "\t\tschedule_timeout(5 * HZ);",
            "\t} while (system_state != SYSTEM_RUNNING);",
            "",
            "\tpr_info(\"start\\n\");",
            "\tret = test_kallsyms_basic_function();",
            "\tif (ret) {",
            "\t\tpr_info(\"abort\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ttest_kallsyms_compression_ratio();",
            "\ttest_perf_kallsyms_lookup_name();",
            "\ttest_perf_kallsyms_on_each_symbol();",
            "\ttest_perf_kallsyms_on_each_match_symbol();",
            "\tpr_info(\"finish\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static int __init kallsyms_test_init(void)",
            "{",
            "\tstruct task_struct *t;",
            "",
            "\tt = kthread_create(test_entry, NULL, \"kallsyms_test\");",
            "\tif (IS_ERR(t)) {",
            "\t\tpr_info(\"Create kallsyms selftest task failed\\n\");",
            "\t\treturn PTR_ERR(t);",
            "\t}",
            "\tkthread_bind(t, 0);",
            "\twake_up_process(t);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "test_entry, kallsyms_test_init",
          "description": "作为模块初始化入口，创建内核线程异步执行完整的kallsyms自测流程，包含所有测试项的调用和结果输出。",
          "similarity": 0.6096914410591125
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kallsyms_selftest.c",
          "start_line": 61,
          "end_line": 166,
          "content": [
            "static int kallsyms_test_func_static(void)",
            "{",
            "\tkallsyms_test_var_bss_static++;",
            "\tkallsyms_test_var_data_static++;",
            "",
            "\treturn 0;",
            "}",
            "int kallsyms_test_func(void)",
            "{",
            "\treturn kallsyms_test_func_static();",
            "}",
            "__weak int kallsyms_test_func_weak(void)",
            "{",
            "\tkallsyms_test_var_bss++;",
            "\tkallsyms_test_var_data++;",
            "\treturn 0;",
            "}",
            "static int stat_symbol_len(void *data, const char *name, unsigned long addr)",
            "{",
            "\t*(u32 *)data += strlen(name);",
            "",
            "\treturn 0;",
            "}",
            "static void test_kallsyms_compression_ratio(void)",
            "{",
            "\tu32 pos, off, len, num;",
            "\tu32 ratio, total_size, total_len = 0;",
            "",
            "\tkallsyms_on_each_symbol(stat_symbol_len, &total_len);",
            "",
            "\t/*",
            "\t * A symbol name cannot start with a number. This stub name helps us",
            "\t * traverse the entire symbol table without finding a match. It's used",
            "\t * for subsequent performance tests, and its length is the average",
            "\t * length of all symbol names.",
            "\t */",
            "\tmemset(stub_name, '4', sizeof(stub_name));",
            "\tpos = total_len / kallsyms_num_syms;",
            "\tstub_name[pos] = 0;",
            "",
            "\tpos = 0;",
            "\tnum = 0;",
            "\toff = 0;",
            "\twhile (pos < kallsyms_num_syms) {",
            "\t\tlen = kallsyms_names[off];",
            "\t\tnum++;",
            "\t\toff++;",
            "\t\tpos++;",
            "\t\tif ((len & 0x80) != 0) {",
            "\t\t\tlen = (len & 0x7f) | (kallsyms_names[off] << 7);",
            "\t\t\tnum++;",
            "\t\t\toff++;",
            "\t\t}",
            "\t\toff += len;",
            "\t}",
            "",
            "\t/*",
            "\t * 1. The length fields is not counted",
            "\t * 2. The memory occupied by array kallsyms_token_table[] and",
            "\t *    kallsyms_token_index[] needs to be counted.",
            "\t */",
            "\ttotal_size = off - num;",
            "\tpos = kallsyms_token_index[0xff];",
            "\ttotal_size += pos + strlen(&kallsyms_token_table[pos]) + 1;",
            "\ttotal_size += 0x100 * sizeof(u16);",
            "",
            "\tpr_info(\" ---------------------------------------------------------\\n\");",
            "\tpr_info(\"| nr_symbols | compressed size | original size | ratio(%%) |\\n\");",
            "\tpr_info(\"|---------------------------------------------------------|\\n\");",
            "\tratio = (u32)div_u64(10000ULL * total_size, total_len);",
            "\tpr_info(\"| %10d |    %10d   |   %10d  |  %2d.%-2d   |\\n\",",
            "\t\tkallsyms_num_syms, total_size, total_len, ratio / 100, ratio % 100);",
            "\tpr_info(\" ---------------------------------------------------------\\n\");",
            "}",
            "static int lookup_name(void *data, const char *name, unsigned long addr)",
            "{",
            "\tu64 t0, t1, t;",
            "\tstruct test_stat *stat = (struct test_stat *)data;",
            "",
            "\tt0 = ktime_get_ns();",
            "\t(void)kallsyms_lookup_name(name);",
            "\tt1 = ktime_get_ns();",
            "",
            "\tt = t1 - t0;",
            "\tif (t < stat->min)",
            "\t\tstat->min = t;",
            "",
            "\tif (t > stat->max)",
            "\t\tstat->max = t;",
            "",
            "\tstat->real_cnt++;",
            "\tstat->sum += t;",
            "",
            "\treturn 0;",
            "}",
            "static void test_perf_kallsyms_lookup_name(void)",
            "{",
            "\tstruct test_stat stat;",
            "",
            "\tmemset(&stat, 0, sizeof(stat));",
            "\tstat.min = INT_MAX;",
            "\tkallsyms_on_each_symbol(lookup_name, &stat);",
            "\tpr_info(\"kallsyms_lookup_name() looked up %d symbols\\n\", stat.real_cnt);",
            "\tpr_info(\"The time spent on each symbol is (ns): min=%d, max=%d, avg=%lld\\n\",",
            "\t\tstat.min, stat.max, div_u64(stat.sum, stat.real_cnt));",
            "}"
          ],
          "function_name": "kallsyms_test_func_static, kallsyms_test_func, kallsyms_test_func_weak, stat_symbol_len, test_kallsyms_compression_ratio, lookup_name, test_perf_kallsyms_lookup_name",
          "description": "实现kallsyms符号表相关测试逻辑，包含符号长度统计、压缩率计算、kallsyms_lookup_name性能测试及遍历符号表的回调函数实现。",
          "similarity": 0.5891976356506348
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/kallsyms_selftest.c",
          "start_line": 190,
          "end_line": 423,
          "content": [
            "static bool match_cleanup_name(const char *s, const char *name)",
            "{",
            "\tchar *p;",
            "\tint len;",
            "",
            "\tif (!IS_ENABLED(CONFIG_LTO_CLANG))",
            "\t\treturn false;",
            "",
            "\tp = strstr(s, \".llvm.\");",
            "\tif (!p)",
            "\t\treturn false;",
            "",
            "\tlen = strlen(name);",
            "\tif (p - s != len)",
            "\t\treturn false;",
            "",
            "\treturn !strncmp(s, name, len);",
            "}",
            "static int find_symbol(void *data, const char *name, unsigned long addr)",
            "{",
            "\tstruct test_stat *stat = (struct test_stat *)data;",
            "",
            "\tif (strcmp(name, stat->name) == 0 ||",
            "\t    (!stat->perf && match_cleanup_name(name, stat->name))) {",
            "\t\tstat->real_cnt++;",
            "\t\tstat->addr = addr;",
            "",
            "\t\tif (stat->save_cnt < MAX_NUM_OF_RECORDS) {",
            "\t\t\tstat->addrs[stat->save_cnt] = addr;",
            "\t\t\tstat->save_cnt++;",
            "\t\t}",
            "",
            "\t\tif (stat->real_cnt == stat->max)",
            "\t\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void test_perf_kallsyms_on_each_symbol(void)",
            "{",
            "\tu64 t0, t1;",
            "\tstruct test_stat stat;",
            "",
            "\tmemset(&stat, 0, sizeof(stat));",
            "\tstat.max = INT_MAX;",
            "\tstat.name = stub_name;",
            "\tstat.perf = 1;",
            "\tt0 = ktime_get_ns();",
            "\tkallsyms_on_each_symbol(find_symbol, &stat);",
            "\tt1 = ktime_get_ns();",
            "\tpr_info(\"kallsyms_on_each_symbol() traverse all: %lld ns\\n\", t1 - t0);",
            "}",
            "static int match_symbol(void *data, unsigned long addr)",
            "{",
            "\tstruct test_stat *stat = (struct test_stat *)data;",
            "",
            "\tstat->real_cnt++;",
            "\tstat->addr = addr;",
            "",
            "\tif (stat->save_cnt < MAX_NUM_OF_RECORDS) {",
            "\t\tstat->addrs[stat->save_cnt] = addr;",
            "\t\tstat->save_cnt++;",
            "\t}",
            "",
            "\tif (stat->real_cnt == stat->max)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static void test_perf_kallsyms_on_each_match_symbol(void)",
            "{",
            "\tu64 t0, t1;",
            "\tstruct test_stat stat;",
            "",
            "\tmemset(&stat, 0, sizeof(stat));",
            "\tstat.max = INT_MAX;",
            "\tstat.name = stub_name;",
            "\tt0 = ktime_get_ns();",
            "\tkallsyms_on_each_match_symbol(match_symbol, stat.name, &stat);",
            "\tt1 = ktime_get_ns();",
            "\tpr_info(\"kallsyms_on_each_match_symbol() traverse all: %lld ns\\n\", t1 - t0);",
            "}",
            "static int test_kallsyms_basic_function(void)",
            "{",
            "\tint i, j, ret;",
            "\tint next = 0, nr_failed = 0;",
            "\tchar *prefix;",
            "\tunsigned short rand;",
            "\tunsigned long addr, lookup_addr;",
            "\tchar namebuf[KSYM_NAME_LEN];",
            "\tstruct test_stat *stat, *stat2;",
            "",
            "\tstat = kmalloc(sizeof(*stat) * 2, GFP_KERNEL);",
            "\tif (!stat)",
            "\t\treturn -ENOMEM;",
            "\tstat2 = stat + 1;",
            "",
            "\tprefix = \"kallsyms_lookup_name() for\";",
            "\tfor (i = 0; i < ARRAY_SIZE(test_items); i++) {",
            "\t\taddr = kallsyms_lookup_name(test_items[i].name);",
            "\t\tif (addr != test_items[i].addr) {",
            "\t\t\tnr_failed++;",
            "\t\t\tpr_info(\"%s %s failed: addr=%lx, expect %lx\\n\",",
            "\t\t\t\tprefix, test_items[i].name, addr, test_items[i].addr);",
            "\t\t}",
            "\t}",
            "",
            "\tprefix = \"kallsyms_on_each_symbol() for\";",
            "\tfor (i = 0; i < ARRAY_SIZE(test_items); i++) {",
            "\t\tmemset(stat, 0, sizeof(*stat));",
            "\t\tstat->max = INT_MAX;",
            "\t\tstat->name = test_items[i].name;",
            "\t\tkallsyms_on_each_symbol(find_symbol, stat);",
            "\t\tif (stat->addr != test_items[i].addr || stat->real_cnt != 1) {",
            "\t\t\tnr_failed++;",
            "\t\t\tpr_info(\"%s %s failed: count=%d, addr=%lx, expect %lx\\n\",",
            "\t\t\t\tprefix, test_items[i].name,",
            "\t\t\t\tstat->real_cnt, stat->addr, test_items[i].addr);",
            "\t\t}",
            "\t}",
            "",
            "\tprefix = \"kallsyms_on_each_match_symbol() for\";",
            "\tfor (i = 0; i < ARRAY_SIZE(test_items); i++) {",
            "\t\tmemset(stat, 0, sizeof(*stat));",
            "\t\tstat->max = INT_MAX;",
            "\t\tstat->name = test_items[i].name;",
            "\t\tkallsyms_on_each_match_symbol(match_symbol, test_items[i].name, stat);",
            "\t\tif (stat->addr != test_items[i].addr || stat->real_cnt != 1) {",
            "\t\t\tnr_failed++;",
            "\t\t\tpr_info(\"%s %s failed: count=%d, addr=%lx, expect %lx\\n\",",
            "\t\t\t\tprefix, test_items[i].name,",
            "\t\t\t\tstat->real_cnt, stat->addr, test_items[i].addr);",
            "\t\t}",
            "\t}",
            "",
            "\tif (nr_failed) {",
            "\t\tkfree(stat);",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "\tfor (i = 0; i < kallsyms_num_syms; i++) {",
            "\t\taddr = kallsyms_sym_address(i);",
            "\t\tif (!is_ksym_addr(addr))",
            "\t\t\tcontinue;",
            "",
            "\t\tret = lookup_symbol_name(addr, namebuf);",
            "\t\tif (unlikely(ret)) {",
            "\t\t\tnamebuf[0] = 0;",
            "\t\t\tpr_info(\"%d: lookup_symbol_name(%lx) failed\\n\", i, addr);",
            "\t\t\tgoto failed;",
            "\t\t}",
            "",
            "\t\tlookup_addr = kallsyms_lookup_name(namebuf);",
            "",
            "\t\tmemset(stat, 0, sizeof(*stat));",
            "\t\tstat->max = INT_MAX;",
            "\t\tkallsyms_on_each_match_symbol(match_symbol, namebuf, stat);",
            "",
            "\t\t/*",
            "\t\t * kallsyms_on_each_symbol() is too slow, randomly select some",
            "\t\t * symbols for test.",
            "\t\t */",
            "\t\tif (i >= next) {",
            "\t\t\tmemset(stat2, 0, sizeof(*stat2));",
            "\t\t\tstat2->max = INT_MAX;",
            "\t\t\tstat2->name = namebuf;",
            "\t\t\tkallsyms_on_each_symbol(find_symbol, stat2);",
            "",
            "\t\t\t/*",
            "\t\t\t * kallsyms_on_each_symbol() and kallsyms_on_each_match_symbol()",
            "\t\t\t * need to get the same traversal result.",
            "\t\t\t */",
            "\t\t\tif (stat->addr != stat2->addr ||",
            "\t\t\t    stat->real_cnt != stat2->real_cnt ||",
            "\t\t\t    memcmp(stat->addrs, stat2->addrs,",
            "\t\t\t\t   stat->save_cnt * sizeof(stat->addrs[0]))) {",
            "\t\t\t\tpr_info(\"%s: mismatch between kallsyms_on_each_symbol() and kallsyms_on_each_match_symbol()\\n\",",
            "\t\t\t\t\tnamebuf);",
            "\t\t\t\tgoto failed;",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * The average of random increments is 128, that is, one of",
            "\t\t\t * them is tested every 128 symbols.",
            "\t\t\t */",
            "\t\t\tget_random_bytes(&rand, sizeof(rand));",
            "\t\t\tnext = i + (rand & 0xff) + 1;",
            "\t\t}",
            "",
            "\t\t/* Need to be found at least once */",
            "\t\tif (!stat->real_cnt) {",
            "\t\t\tpr_info(\"%s: Never found\\n\", namebuf);",
            "\t\t\tgoto failed;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * kallsyms_lookup_name() returns the address of the first",
            "\t\t * symbol found and cannot be NULL.",
            "\t\t */",
            "\t\tif (!lookup_addr) {",
            "\t\t\tpr_info(\"%s: NULL lookup_addr?!\\n\", namebuf);",
            "\t\t\tgoto failed;",
            "\t\t}",
            "\t\tif (lookup_addr != stat->addrs[0]) {",
            "\t\t\tpr_info(\"%s: lookup_addr != stat->addrs[0]\\n\", namebuf);",
            "\t\t\tgoto failed;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If the addresses of all matching symbols are recorded, the",
            "\t\t * target address needs to be exist.",
            "\t\t */",
            "\t\tif (stat->real_cnt <= MAX_NUM_OF_RECORDS) {",
            "\t\t\tfor (j = 0; j < stat->save_cnt; j++) {",
            "\t\t\t\tif (stat->addrs[j] == addr)",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\tif (j == stat->save_cnt) {",
            "\t\t\t\tpr_info(\"%s: j == save_cnt?!\\n\", namebuf);",
            "\t\t\t\tgoto failed;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tkfree(stat);",
            "",
            "\treturn 0;",
            "",
            "failed:",
            "\tpr_info(\"Test for %dth symbol failed: (%s) addr=%lx\", i, namebuf, addr);",
            "\tkfree(stat);",
            "\treturn -ESRCH;",
            "}"
          ],
          "function_name": "match_cleanup_name, find_symbol, test_perf_kallsyms_on_each_symbol, match_symbol, test_perf_kallsyms_on_each_match_symbol, test_kallsyms_basic_function",
          "description": "实现符号匹配校验逻辑和基础功能测试，包含符号地址查找验证、遍历符号表的匹配函数测试，以及跨不同遍历API的结果一致性检测。",
          "similarity": 0.550668478012085
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/kallsyms_selftest.c",
          "start_line": 1,
          "end_line": 60,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Test the function and performance of kallsyms",
            " *",
            " * Copyright (C) Huawei Technologies Co., Ltd., 2022",
            " *",
            " * Authors: Zhen Lei <thunder.leizhen@huawei.com> Huawei",
            " */",
            "",
            "#define pr_fmt(fmt) \"kallsyms_selftest: \" fmt",
            "",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/random.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kthread.h>",
            "#include <linux/vmalloc.h>",
            "",
            "#include \"kallsyms_internal.h\"",
            "#include \"kallsyms_selftest.h\"",
            "",
            "",
            "#define MAX_NUM_OF_RECORDS\t\t64",
            "",
            "struct test_stat {",
            "\tint min;",
            "\tint max;",
            "\tint save_cnt;",
            "\tint real_cnt;",
            "\tint perf;",
            "\tu64 sum;",
            "\tchar *name;",
            "\tunsigned long addr;",
            "\tunsigned long addrs[MAX_NUM_OF_RECORDS];",
            "};",
            "",
            "struct test_item {",
            "\tchar *name;",
            "\tunsigned long addr;",
            "};",
            "",
            "#define ITEM_FUNC(s)\t\t\t\t\\",
            "\t{\t\t\t\t\t\\",
            "\t\t.name = #s,\t\t\t\\",
            "\t\t.addr = (unsigned long)s,\t\\",
            "\t}",
            "",
            "#define ITEM_DATA(s)\t\t\t\t\\",
            "\t{\t\t\t\t\t\\",
            "\t\t.name = #s,\t\t\t\\",
            "\t\t.addr = (unsigned long)&s,\t\\",
            "\t}",
            "",
            "",
            "static int kallsyms_test_var_bss_static;",
            "static int kallsyms_test_var_data_static = 1;",
            "int kallsyms_test_var_bss;",
            "int kallsyms_test_var_data = 1;",
            ""
          ],
          "function_name": null,
          "description": "定义了用于kallsyms自测的测试变量和结构体，包括静态变量、数据段变量及测试项结构体，通过宏ITEM_FUNC和ITEM_DATA注册测试符号及其地址。",
          "similarity": 0.48057234287261963
        }
      ]
    }
  ]
}