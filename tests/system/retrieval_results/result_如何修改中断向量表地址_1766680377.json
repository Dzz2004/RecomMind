{
  "query": "如何修改中断向量表地址",
  "timestamp": "2025-12-26 00:32:57",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/settings.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:08:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\settings.h`\n\n---\n\n# `irq/settings.h` 技术文档\n\n## 1. 文件概述\n\n`irq/settings.h` 是 Linux 内核中断子系统中的一个内部头文件，用于封装对 `irq_desc` 结构体中中断状态（原 `status` 字段，现为 `status_use_accessors`）的访问逻辑。该文件通过定义一组带下划线前缀的枚举常量（如 `_IRQ_PER_CPU`）映射原始中断标志（如 `IRQ_PER_CPU`），并提供一系列内联函数以安全、统一的方式读取和修改中断描述符的配置属性。同时，文件通过将原始标志宏（如 `IRQ_PER_CPU`）重定义为无效值（`GOT_YOU_MORON`），强制开发者使用封装后的访问器函数，避免直接操作底层状态位，从而提升代码的可维护性和安全性。\n\n## 2. 核心功能\n\n### 枚举常量\n- `_IRQ_DEFAULT_INIT_FLAGS`：中断描述符的默认初始化标志。\n- `_IRQ_PER_CPU`：表示该中断仅绑定到特定 CPU。\n- `_IRQ_LEVEL`：表示该中断为电平触发。\n- `_IRQ_NOPROBE`：禁止对该中断进行探测。\n- `_IRQ_NOREQUEST`：禁止通过 `request_irq()` 请求该中断。\n- `_IRQ_NOTHREAD`：禁止为该中断创建线程化处理程序。\n- `_IRQ_NOAUTOEN`：中断不会在注册后自动启用。\n- `_IRQ_MOVE_PCNTXT`：允许在进程上下文中迁移该中断。\n- `_IRQ_NO_BALANCING`：禁用中断负载均衡。\n- `_IRQ_NESTED_THREAD`：表示该中断是嵌套线程化中断。\n- `_IRQ_PER_CPU_DEVID`：表示该中断为 per-CPU 类型，且使用设备 ID。\n- `_IRQ_IS_POLLED`：表示该中断由轮询机制处理。\n- `_IRQ_DISABLE_UNLAZY`：禁用 lazy disable 优化。\n- `_IRQ_HIDDEN`：该中断对用户空间隐藏。\n- `_IRQ_NO_DEBUG`：禁用对该中断的调试跟踪。\n- `_IRQF_MODIFY_MASK`：定义哪些标志位允许被修改。\n\n### 内联函数\n- **通用操作**：\n  - `irq_settings_clr_and_set()`：原子地清除和设置指定的中断标志位。\n- **Per-CPU 相关**：\n  - `irq_settings_is_per_cpu()` / `irq_settings_set_per_cpu()`\n  - `irq_settings_is_per_cpu_devid()`\n- **负载均衡**：\n  - `irq_settings_set_no_balancing()` / `irq_settings_has_no_balance_set()`\n- **触发类型**：\n  - `irq_settings_get_trigger_mask()` / `irq_settings_set_trigger_mask()`\n  - `irq_settings_is_level()` / `irq_settings_set_level()` / `irq_settings_clr_level()`\n- **请求与探测控制**：\n  - `irq_settings_can_request()` / `irq_settings_set_norequest()` / `irq_settings_clr_norequest()`\n  - `irq_settings_can_probe()` / `irq_settings_set_noprobe()` / `irq_settings_clr_noprobe()`\n- **线程化处理**：\n  - `irq_settings_can_thread()` / `irq_settings_set_nothread()` / `irq_settings_clr_nothread()`\n  - `irq_settings_is_nested_thread()`\n- **其他属性**：\n  - `irq_settings_can_move_pcntxt()`\n  - `irq_settings_can_autoenable()`\n  - `irq_settings_is_polled()`\n  - `irq_settings_disable_unlazy()` / `irq_settings_clr_disable_unlazy()`\n  - `irq_settings_is_hidden()`\n  - `irq_settings_no_debug()` / `irq_settings_set_no_debug()`\n\n## 3. 关键实现\n\n- **标志位封装**：所有原始中断标志（如 `IRQ_PER_CPU`）被重定义为无效标识符（`GOT_YOU_MORON`），强制开发者使用带下划线前缀的枚举值（如 `_IRQ_PER_CPU`）配合封装函数进行操作，防止直接访问 `irq_desc->status_use_accessors`。\n- **安全位操作**：`irq_settings_clr_and_set()` 函数在修改标志位时，会与 `_IRQF_MODIFY_MASK` 进行掩码操作，确保只有允许修改的位被更新，防止意外覆盖关键状态。\n- **触发类型管理**：通过 `IRQ_TYPE_SENSE_MASK` 掩码单独管理中断触发类型（如边沿/电平），与其他标志位解耦。\n- **布尔语义封装**：对于“禁止”类标志（如 `_IRQ_NOREQUEST`），封装函数（如 `irq_settings_can_request()`）返回其逻辑否定值，使接口语义更直观（“能否请求”而非“是否禁止请求”）。\n\n## 4. 依赖关系\n\n- **依赖头文件**：隐式依赖 `linux/irq.h` 或 `linux/interrupt.h`，其中定义了原始中断标志（如 `IRQ_PER_CPU`、`IRQ_TYPE_SENSE_MASK`）和 `struct irq_desc`。\n- **被依赖模块**：\n  - 中断核心子系统（`kernel/irq/` 下的 `.c` 文件）：如 `irqdesc.c`、`manage.c` 等，在初始化、配置和管理中断描述符时调用本文件提供的访问器函数。\n  - 中断控制器驱动（如 GIC、APIC 驱动）：在设置特定中断属性时使用这些封装接口。\n  - 线程化中断和中断亲和性管理模块：依赖 per-CPU、线程化、负载均衡等相关接口。\n\n## 5. 使用场景\n\n- **中断描述符初始化**：在 `alloc_desc()` 或 `irq_setup_virq()` 等函数中，使用 `irq_settings_set_*` 系列函数设置中断的初始属性（如 per-CPU、触发类型等）。\n- **中断注册与配置**：在 `request_irq()`、`devm_request_irq()` 或驱动的中断设置路径中，通过 `irq_settings_can_request()` 等函数检查中断是否可被请求，并通过 `irq_settings_set_norequest()` 等函数动态调整属性。\n- **中断迁移与负载均衡**：在 `irq_set_affinity()` 或中断均衡逻辑中，使用 `irq_settings_has_no_balance_set()` 判断是否跳过均衡处理。\n- **调试与监控**：调试子系统通过 `irq_settings_no_debug()` 判断是否应跳过特定中断的跟踪。\n- **电源管理与轮询**：在中断休眠或轮询模式下，通过 `irq_settings_is_polled()` 和 `irq_settings_disable_unlazy()` 控制中断行为。",
      "similarity": 0.5658032298088074,
      "chunks": []
    },
    {
      "source_file": "kernel/irq/matrix.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:03:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\matrix.c`\n\n---\n\n# `irq/matrix.c` 技术文档\n\n## 1. 文件概述\n\n`irq/matrix.c` 实现了一个通用的中断位图（IRQ matrix）管理机制，用于在多 CPU 系统中高效地分配和管理中断向量（或中断位）。该机制支持两类中断分配：\n\n- **普通分配（allocated）**：由设备驱动等动态申请的中断。\n- **托管分配（managed）**：由内核子系统（如 MSI/MSI-X）预先保留、按需激活的中断。\n\n该文件通过 per-CPU 的位图结构，结合全局状态跟踪，实现了跨 CPU 的中断资源分配、预留、释放和在线/离线管理，特别适用于中断向量数量有限（如 x86 的 256 个向量）的架构。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct cpumap`**：每个 CPU 的本地中断位图状态\n  - `available`：当前 CPU 可用的中断数量\n  - `allocated`：已分配的普通中断数量\n  - `managed` / `managed_allocated`：预留和已激活的托管中断数量\n  - `alloc_map[]`：记录已分配的普通中断位\n  - `managed_map[]`：记录预留的托管中断位\n  - `initialized` / `online`：CPU 初始化和在线状态\n\n- **`struct irq_matrix`**：全局中断矩阵控制结构\n  - `matrix_bits`：总位图大小（≤ `IRQ_MATRIX_BITS`）\n  - `alloc_start` / `alloc_end`：可分配范围\n  - `global_available`：全局可用中断总数\n  - `system_map[]`：系统保留位（如 APIC 自身使用的向量）\n  - `maps`：指向 per-CPU `cpumap` 的指针\n  - `scratch_map[]`：临时位图，用于分配时的合并计算\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `irq_alloc_matrix()` | 分配并初始化一个 `irq_matrix` 结构 |\n| `irq_matrix_online()` / `irq_matrix_offline()` | 将本地 CPU 的中断矩阵置为在线/离线状态 |\n| `irq_matrix_assign_system()` | 在矩阵中保留系统级中断位（如 APIC 向量） |\n| `irq_matrix_reserve_managed()` | 在指定 CPU 掩码上为托管中断预留位 |\n| `irq_matrix_remove_managed()` | 移除托管中断的预留位 |\n| `irq_matrix_alloc_managed()` | 从预留的托管中断中分配一个实际使用的中断 |\n| `matrix_alloc_area()` | 内部辅助函数：在合并位图中查找连续空闲区域 |\n| `matrix_find_best_cpu()` / `matrix_find_best_cpu_managed()` | 选择最优 CPU（基于可用数或托管分配数最少） |\n\n## 3. 关键实现\n\n### 位图合并分配策略\n- 在分配中断时，`matrix_alloc_area()` 会临时合并三个位图：\n  1. 当前 CPU 的 `managed_map`（托管预留）\n  2. 全局 `system_map`（系统保留）\n  3. 当前 CPU 的 `alloc_map`（已分配）\n- 使用 `bitmap_find_next_zero_area()` 在合并后的位图中查找连续空闲区域，确保不会重复分配。\n\n### 托管中断（Managed IRQ）机制\n- **两阶段分配**：\n  1. **预留（reserve）**：调用 `irq_matrix_reserve_managed()` 在多个 CPU 上各预留一个位（不一定对齐）。\n  2. **激活（alloc）**：调用 `irq_matrix_alloc_managed()` 从预留位中选择一个未使用的位进行实际分配。\n- **动态 CPU 选择**：`matrix_find_best_cpu_managed()` 优先选择 `managed_allocated` 最少的 CPU，实现负载均衡。\n\n### 系统中断保留\n- `irq_matrix_assign_system()` 用于保留如 x86 的 `IRQ0_VECTOR`（时钟中断）等关键系统向量。\n- 通过 `BUG_ON()` 强制保证：系统中断只能在单 CPU 初始化阶段分配，防止运行时冲突。\n\n### 在线/离线管理\n- CPU 上线时，将其 `available` 计数加入 `global_available`。\n- CPU 离线时，从全局计数中减去，但保留其位图数据（支持重新上线）。\n\n### 跟踪与调试\n- 集成 `trace/events/irq_matrix.h`，提供分配、预留、系统保留等关键操作的 tracepoint，便于调试中断分配问题。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/bitmap.h>`：位图操作（`bitmap_set`, `bitmap_find_next_zero_area` 等）\n  - `<linux/percpu.h>`：Per-CPU 变量支持\n  - `<linux/cpu.h>`：CPU 在线/离线状态\n  - `<linux/irq.h>`：中断子系统基础定义\n  - `<trace/events/irq_matrix.h>`：自定义 tracepoint\n\n- **内核子系统**：\n  - **中断子系统**：作为底层分配器，被 `irqdomain`、MSI/MSI-X 驱动等使用。\n  - **x86 APIC 驱动**：典型使用者，用于管理 256 个中断向量的分配（如 `kernel/irq/vector.c`）。\n\n## 5. 使用场景\n\n- **x86 中断向量管理**：在 `CONFIG_X86_IO_APIC` 或 `CONFIG_X86_LOCAL_APIC` 下，用于分配 IRQ 向量（0-255），区分系统向量、普通设备中断和 MSI 中断。\n- **MSI/MSI-X 中断分配**：PCIe 设备的 MSI 中断通过托管机制预留和分配，确保每个设备在多个 CPU 上有可用向量。\n- **CPU 热插拔**：支持 CPU 动态上线/下线时的中断资源重新平衡。\n- **中断负载均衡**：通过 `matrix_find_best_cpu*` 函数，在多 CPU 间均匀分配中断，避免单 CPU 向量耗尽。",
      "similarity": 0.5618911981582642,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 418,
          "end_line": 483,
          "content": [
            "void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,",
            "\t\t     unsigned int bit, bool managed)",
            "{",
            "\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))",
            "\t\treturn;",
            "",
            "\tif (WARN_ON_ONCE(!test_and_clear_bit(bit, cm->alloc_map)))",
            "\t\treturn;",
            "",
            "\tcm->allocated--;",
            "\tif(managed)",
            "\t\tcm->managed_allocated--;",
            "",
            "\tif (cm->online)",
            "\t\tm->total_allocated--;",
            "",
            "\tif (!managed) {",
            "\t\tcm->available++;",
            "\t\tif (cm->online)",
            "\t\t\tm->global_available++;",
            "\t}",
            "\ttrace_irq_matrix_free(bit, cpu, m, cm);",
            "}",
            "unsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tif (!cpudown)",
            "\t\treturn m->global_available;",
            "\treturn m->global_available - cm->available;",
            "}",
            "unsigned int irq_matrix_reserved(struct irq_matrix *m)",
            "{",
            "\treturn m->global_reserved;",
            "}",
            "unsigned int irq_matrix_allocated(struct irq_matrix *m)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\treturn cm->allocated - cm->managed_allocated;",
            "}",
            "void irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind)",
            "{",
            "\tunsigned int nsys = bitmap_weight(m->system_map, m->matrix_bits);",
            "\tint cpu;",
            "",
            "\tseq_printf(sf, \"Online bitmaps:   %6u\\n\", m->online_maps);",
            "\tseq_printf(sf, \"Global available: %6u\\n\", m->global_available);",
            "\tseq_printf(sf, \"Global reserved:  %6u\\n\", m->global_reserved);",
            "\tseq_printf(sf, \"Total allocated:  %6u\\n\", m->total_allocated);",
            "\tseq_printf(sf, \"System: %u: %*pbl\\n\", nsys, m->matrix_bits,",
            "\t\t   m->system_map);",
            "\tseq_printf(sf, \"%*s| CPU | avl | man | mac | act | vectors\\n\", ind, \" \");",
            "\tcpus_read_lock();",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\t\tseq_printf(sf, \"%*s %4d  %4u  %4u  %4u %4u  %*pbl\\n\", ind, \" \",",
            "\t\t\t   cpu, cm->available, cm->managed,",
            "\t\t\t   cm->managed_allocated, cm->allocated,",
            "\t\t\t   m->matrix_bits, cm->alloc_map);",
            "\t}",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "irq_matrix_free, irq_matrix_available, irq_matrix_reserved, irq_matrix_allocated, irq_matrix_debug_show",
          "description": "提供中断资源的释放接口，实现全局和CPU级的资源使用统计查询，包含调试信息展示功能，通过位图操作维护系统中断位的使用状态",
          "similarity": 0.5459905862808228
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 251,
          "end_line": 365,
          "content": [
            "void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)",
            "{",
            "\tunsigned int cpu;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "\t\tunsigned int bit, end = m->alloc_end;",
            "",
            "\t\tif (WARN_ON_ONCE(!cm->managed))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Get managed bit which are not allocated */",
            "\t\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);",
            "",
            "\t\tbit = find_first_bit(m->scratch_map, end);",
            "\t\tif (WARN_ON_ONCE(bit >= end))",
            "\t\t\tcontinue;",
            "",
            "\t\tclear_bit(bit, cm->managed_map);",
            "",
            "\t\tcm->managed--;",
            "\t\tif (cm->online) {",
            "\t\t\tcm->available++;",
            "\t\t\tm->global_available++;",
            "\t\t}",
            "\t\ttrace_irq_matrix_remove_managed(bit, cpu, m, cm);",
            "\t}",
            "}",
            "int irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,",
            "\t\t\t     unsigned int *mapped_cpu)",
            "{",
            "\tunsigned int bit, cpu, end;",
            "\tstruct cpumap *cm;",
            "",
            "\tif (cpumask_empty(msk))",
            "\t\treturn -EINVAL;",
            "",
            "\tcpu = matrix_find_best_cpu_managed(m, msk);",
            "\tif (cpu == UINT_MAX)",
            "\t\treturn -ENOSPC;",
            "",
            "\tcm = per_cpu_ptr(m->maps, cpu);",
            "\tend = m->alloc_end;",
            "\t/* Get managed bit which are not allocated */",
            "\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);",
            "\tbit = find_first_bit(m->scratch_map, end);",
            "\tif (bit >= end)",
            "\t\treturn -ENOSPC;",
            "\tset_bit(bit, cm->alloc_map);",
            "\tcm->allocated++;",
            "\tcm->managed_allocated++;",
            "\tm->total_allocated++;",
            "\t*mapped_cpu = cpu;",
            "\ttrace_irq_matrix_alloc_managed(bit, cpu, m, cm);",
            "\treturn bit;",
            "}",
            "void irq_matrix_assign(struct irq_matrix *m, unsigned int bit)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))",
            "\t\treturn;",
            "\tif (WARN_ON_ONCE(test_and_set_bit(bit, cm->alloc_map)))",
            "\t\treturn;",
            "\tcm->allocated++;",
            "\tm->total_allocated++;",
            "\tcm->available--;",
            "\tm->global_available--;",
            "\ttrace_irq_matrix_assign(bit, smp_processor_id(), m, cm);",
            "}",
            "void irq_matrix_reserve(struct irq_matrix *m)",
            "{",
            "\tif (m->global_reserved == m->global_available)",
            "\t\tpr_warn(\"Interrupt reservation exceeds available resources\\n\");",
            "",
            "\tm->global_reserved++;",
            "\ttrace_irq_matrix_reserve(m);",
            "}",
            "void irq_matrix_remove_reserved(struct irq_matrix *m)",
            "{",
            "\tm->global_reserved--;",
            "\ttrace_irq_matrix_remove_reserved(m);",
            "}",
            "int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,",
            "\t\t     bool reserved, unsigned int *mapped_cpu)",
            "{",
            "\tunsigned int cpu, bit;",
            "\tstruct cpumap *cm;",
            "",
            "\t/*",
            "\t * Not required in theory, but matrix_find_best_cpu() uses",
            "\t * for_each_cpu() which ignores the cpumask on UP .",
            "\t */",
            "\tif (cpumask_empty(msk))",
            "\t\treturn -EINVAL;",
            "",
            "\tcpu = matrix_find_best_cpu(m, msk);",
            "\tif (cpu == UINT_MAX)",
            "\t\treturn -ENOSPC;",
            "",
            "\tcm = per_cpu_ptr(m->maps, cpu);",
            "\tbit = matrix_alloc_area(m, cm, 1, false);",
            "\tif (bit >= m->alloc_end)",
            "\t\treturn -ENOSPC;",
            "\tcm->allocated++;",
            "\tcm->available--;",
            "\tm->total_allocated++;",
            "\tm->global_available--;",
            "\tif (reserved)",
            "\t\tm->global_reserved--;",
            "\t*mapped_cpu = cpu;",
            "\ttrace_irq_matrix_alloc(bit, cpu, m, cm);",
            "\treturn bit;",
            "",
            "}"
          ],
          "function_name": "irq_matrix_remove_managed, irq_matrix_alloc_managed, irq_matrix_assign, irq_matrix_reserve, irq_matrix_remove_reserved, irq_matrix_alloc",
          "description": "实现中断位的分配/回收机制，包含保留中断位的管理、跨CPU的中断分配逻辑，以及根据预留状态进行资源分配的控制流程",
          "similarity": 0.4945136308670044
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 78,
          "end_line": 205,
          "content": [
            "void irq_matrix_online(struct irq_matrix *m)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tBUG_ON(cm->online);",
            "",
            "\tif (!cm->initialized) {",
            "\t\tcm->available = m->alloc_size;",
            "\t\tcm->available -= cm->managed + m->systembits_inalloc;",
            "\t\tcm->initialized = true;",
            "\t}",
            "\tm->global_available += cm->available;",
            "\tcm->online = true;",
            "\tm->online_maps++;",
            "\ttrace_irq_matrix_online(m);",
            "}",
            "void irq_matrix_offline(struct irq_matrix *m)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\t/* Update the global available size */",
            "\tm->global_available -= cm->available;",
            "\tcm->online = false;",
            "\tm->online_maps--;",
            "\ttrace_irq_matrix_offline(m);",
            "}",
            "static unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,",
            "\t\t\t\t      unsigned int num, bool managed)",
            "{",
            "\tunsigned int area, start = m->alloc_start;",
            "\tunsigned int end = m->alloc_end;",
            "",
            "\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);",
            "\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);",
            "\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);",
            "\tif (area >= end)",
            "\t\treturn area;",
            "\tif (managed)",
            "\t\tbitmap_set(cm->managed_map, area, num);",
            "\telse",
            "\t\tbitmap_set(cm->alloc_map, area, num);",
            "\treturn area;",
            "}",
            "static unsigned int matrix_find_best_cpu(struct irq_matrix *m,",
            "\t\t\t\t\tconst struct cpumask *msk)",
            "{",
            "\tunsigned int cpu, best_cpu, maxavl = 0;",
            "\tstruct cpumap *cm;",
            "",
            "\tbest_cpu = UINT_MAX;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tcm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\t\tif (!cm->online || cm->available <= maxavl)",
            "\t\t\tcontinue;",
            "",
            "\t\tbest_cpu = cpu;",
            "\t\tmaxavl = cm->available;",
            "\t}",
            "\treturn best_cpu;",
            "}",
            "static unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,",
            "\t\t\t\t\t\tconst struct cpumask *msk)",
            "{",
            "\tunsigned int cpu, best_cpu, allocated = UINT_MAX;",
            "\tstruct cpumap *cm;",
            "",
            "\tbest_cpu = UINT_MAX;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tcm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\t\tif (!cm->online || cm->managed_allocated > allocated)",
            "\t\t\tcontinue;",
            "",
            "\t\tbest_cpu = cpu;",
            "\t\tallocated = cm->managed_allocated;",
            "\t}",
            "\treturn best_cpu;",
            "}",
            "void irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit,",
            "\t\t\t      bool replace)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tBUG_ON(bit > m->matrix_bits);",
            "\tBUG_ON(m->online_maps > 1 || (m->online_maps && !replace));",
            "",
            "\tset_bit(bit, m->system_map);",
            "\tif (replace) {",
            "\t\tBUG_ON(!test_and_clear_bit(bit, cm->alloc_map));",
            "\t\tcm->allocated--;",
            "\t\tm->total_allocated--;",
            "\t}",
            "\tif (bit >= m->alloc_start && bit < m->alloc_end)",
            "\t\tm->systembits_inalloc++;",
            "",
            "\ttrace_irq_matrix_assign_system(bit, m);",
            "}",
            "int irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk)",
            "{",
            "\tunsigned int cpu, failed_cpu;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "\t\tunsigned int bit;",
            "",
            "\t\tbit = matrix_alloc_area(m, cm, 1, true);",
            "\t\tif (bit >= m->alloc_end)",
            "\t\t\tgoto cleanup;",
            "\t\tcm->managed++;",
            "\t\tif (cm->online) {",
            "\t\t\tcm->available--;",
            "\t\t\tm->global_available--;",
            "\t\t}",
            "\t\ttrace_irq_matrix_reserve_managed(bit, cpu, m, cm);",
            "\t}",
            "\treturn 0;",
            "cleanup:",
            "\tfailed_cpu = cpu;",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tif (cpu == failed_cpu)",
            "\t\t\tbreak;",
            "\t\tirq_matrix_remove_managed(m, cpumask_of(cpu));",
            "\t}",
            "\treturn -ENOSPC;",
            "}"
          ],
          "function_name": "irq_matrix_online, irq_matrix_offline, matrix_alloc_area, matrix_find_best_cpu, matrix_find_best_cpu_managed, irq_matrix_assign_system, irq_matrix_reserve_managed",
          "description": "实现CPU矩阵的上线/下线操作，通过bitmap操作实现中断位的分配策略，包含寻找最佳CPU的逻辑，支持系统位管理和保留区域的分配与追踪",
          "similarity": 0.49042707681655884
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 1,
          "end_line": 77,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2017 Thomas Gleixner <tglx@linutronix.de>",
            "",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpu.h>",
            "#include <linux/irq.h>",
            "",
            "#define IRQ_MATRIX_SIZE\t(BITS_TO_LONGS(IRQ_MATRIX_BITS))",
            "",
            "struct cpumap {",
            "\tunsigned int\t\tavailable;",
            "\tunsigned int\t\tallocated;",
            "\tunsigned int\t\tmanaged;",
            "\tunsigned int\t\tmanaged_allocated;",
            "\tbool\t\t\tinitialized;",
            "\tbool\t\t\tonline;",
            "\tunsigned long\t\talloc_map[IRQ_MATRIX_SIZE];",
            "\tunsigned long\t\tmanaged_map[IRQ_MATRIX_SIZE];",
            "};",
            "",
            "struct irq_matrix {",
            "\tunsigned int\t\tmatrix_bits;",
            "\tunsigned int\t\talloc_start;",
            "\tunsigned int\t\talloc_end;",
            "\tunsigned int\t\talloc_size;",
            "\tunsigned int\t\tglobal_available;",
            "\tunsigned int\t\tglobal_reserved;",
            "\tunsigned int\t\tsystembits_inalloc;",
            "\tunsigned int\t\ttotal_allocated;",
            "\tunsigned int\t\tonline_maps;",
            "\tstruct cpumap __percpu\t*maps;",
            "\tunsigned long\t\tscratch_map[IRQ_MATRIX_SIZE];",
            "\tunsigned long\t\tsystem_map[IRQ_MATRIX_SIZE];",
            "};",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/irq_matrix.h>",
            "",
            "/**",
            " * irq_alloc_matrix - Allocate a irq_matrix structure and initialize it",
            " * @matrix_bits:\tNumber of matrix bits must be <= IRQ_MATRIX_BITS",
            " * @alloc_start:\tFrom which bit the allocation search starts",
            " * @alloc_end:\t\tAt which bit the allocation search ends, i.e first",
            " *\t\t\tinvalid bit",
            " */",
            "__init struct irq_matrix *irq_alloc_matrix(unsigned int matrix_bits,",
            "\t\t\t\t\t   unsigned int alloc_start,",
            "\t\t\t\t\t   unsigned int alloc_end)",
            "{",
            "\tstruct irq_matrix *m;",
            "",
            "\tif (matrix_bits > IRQ_MATRIX_BITS)",
            "\t\treturn NULL;",
            "",
            "\tm = kzalloc(sizeof(*m), GFP_KERNEL);",
            "\tif (!m)",
            "\t\treturn NULL;",
            "",
            "\tm->matrix_bits = matrix_bits;",
            "\tm->alloc_start = alloc_start;",
            "\tm->alloc_end = alloc_end;",
            "\tm->alloc_size = alloc_end - alloc_start;",
            "\tm->maps = alloc_percpu(*m->maps);",
            "\tif (!m->maps) {",
            "\t\tkfree(m);",
            "\t\treturn NULL;",
            "\t}",
            "\treturn m;",
            "}",
            "",
            "/**",
            " * irq_matrix_online - Bring the local CPU matrix online",
            " * @m:\t\tMatrix pointer",
            " */"
          ],
          "function_name": null,
          "description": "定义irq_matrix结构体和相关辅助数据结构，提供irq_alloc_matrix函数用于初始化并分配irq_matrix实例，设置矩阵大小、起始结束位置等参数，并分配per-CPU的cpumap数组",
          "similarity": 0.4600091278553009
        }
      ]
    },
    {
      "source_file": "kernel/irq/resend.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:07:32\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\resend.c`\n\n---\n\n# `irq/resend.c` 技术文档\n\n## 1. 文件概述\n\n`irq/resend.c` 实现了 Linux 内核中断子系统中的 **中断重发（IRQ resend）机制**。该机制用于在中断未能被及时处理或需要重新触发时，尝试通过硬件重触发（retrigger）或软件任务（tasklet）方式重新投递中断。此功能主要用于支持那些无法通过硬件自动重发中断的中断控制器，以及用于调试和错误注入场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `check_irq_resend(struct irq_desc *desc, bool inject)` | 检查是否需要重发中断，并尝试通过硬件重触发或软件重发机制重新投递中断。 |\n| `irq_sw_resend(struct irq_desc *desc)` | 在不支持硬件重触发时，将中断描述符加入软件重发队列，并调度 tasklet 处理。 |\n| `resend_irqs(struct tasklet_struct *unused)` | tasklet 回调函数，遍历软件重发队列并调用对应中断的 `handle_irq` 处理函数。 |\n| `clear_irq_resend(struct irq_desc *desc)` | 从软件重发队列中移除指定中断描述符。 |\n| `irq_resend_init(struct irq_desc *desc)` | 初始化中断描述符的重发链表节点。 |\n| `irq_inject_interrupt(unsigned int irq)`（仅当 `CONFIG_GENERIC_IRQ_INJECTION` 启用） | 用于调试目的，主动注入指定中断。 |\n\n### 主要数据结构\n\n- `irq_resend_list`：全局哈希链表头，用于维护待软件重发的中断描述符。\n- `irq_resend_lock`：保护 `irq_resend_list` 的原始自旋锁（raw spinlock）。\n- `resend_tasklet`：用于异步执行软件重发逻辑的 tasklet。\n- `desc->resend_node`：`struct irq_desc` 中用于链入 `irq_resend_list` 的节点。\n\n## 3. 关键实现\n\n### 中断重发条件判断\n\n- **仅边沿触发中断支持重发**：`check_irq_resend()` 会跳过电平触发中断（`irq_settings_is_level()`），因为这类中断在电平有效期间会由硬件自动保持。\n- **避免重复重发**：若中断已处于 `IRQS_REPLAY` 状态，则返回 `-EBUSY`，防止重复处理。\n- **注入模式支持**：当 `inject == true`（如 `irq_inject_interrupt` 调用）时，即使 `IRQS_PENDING` 未置位也会尝试重发。\n\n### 硬件 vs 软件重发\n\n- **优先尝试硬件重触发**：调用 `try_retrigger()`，先检查中断芯片是否提供 `irq_retrigger` 回调；若无，则尝试层级中断域的 `irq_chip_retrigger_hierarchy`。\n- **回退到软件重发**：若硬件重触发不可用且 `CONFIG_HARDIRQS_SW_RESEND` 已启用，则调用 `irq_sw_resend()` 将中断加入软件队列。\n\n### 软件重发机制\n\n- 使用 **tasklet** 在软中断上下文中执行重发，避免在硬中断或原子上下文中直接调用 `handle_irq`。\n- 通过 `hlist` 管理待重发的 `irq_desc`，并用 `raw_spinlock` 保证并发安全。\n- 支持嵌套线程中断（nested threaded IRQ）：若目标中断是嵌套线程类型，则重发其父中断。\n\n### 安全性检查\n\n- `handle_enforce_irqctx()` 确保中断可在非中断上下文中安全注入。\n- 对嵌套线程中断，验证 `parent_irq` 有效性，防止空指针解引用。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：提供中断核心 API 和数据结构。\n  - `\"internals.h\"`：内核中断子系统内部头文件，包含 `irq_desc` 等私有定义。\n- **配置依赖**：\n  - `CONFIG_HARDIRQS_SW_RESEND`：启用软件重发机制。\n  - `CONFIG_IRQ_DOMAIN_HIERARCHY`：支持层级中断域的重触发。\n  - `CONFIG_GENERIC_IRQ_INJECTION`：启用 `irq_inject_interrupt()` 调试接口。\n- **与其他模块交互**：\n  - 依赖中断控制器驱动实现的 `irq_retrigger` 回调。\n  - 与通用中断处理框架（如 `handle_irq`）紧密集成。\n\n## 5. 使用场景\n\n1. **中断丢失恢复**：在某些硬件平台或虚拟化环境中，中断可能因竞争条件或延迟而丢失，重发机制可提高可靠性。\n2. **调试与测试**：通过 `irq_inject_interrupt()` 主动注入中断，用于测试中断处理路径、驱动健壮性或错误恢复逻辑。\n3. **不支持硬件重触发的平台**：如部分 ARM SoC 或旧式 x86 芯片组，依赖软件 tasklet 机制模拟中断重发。\n4. **电源管理（suspend/resume）**：在系统恢复过程中，可能需要重放挂起期间未处理的边沿中断。\n5. **嵌套中断处理**：在 threaded IRQ 架构中，确保子中断能通过父中断正确重发。",
      "similarity": 0.5413851737976074,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/resend.c",
          "start_line": 173,
          "end_line": 200,
          "content": [
            "int irq_inject_interrupt(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tunsigned long flags;",
            "\tint err;",
            "",
            "\t/* Try the state injection hardware interface first */",
            "\tif (!irq_set_irqchip_state(irq, IRQCHIP_STATE_PENDING, true))",
            "\t\treturn 0;",
            "",
            "\t/* That failed, try via the resend mechanism */",
            "\tdesc = irq_get_desc_buslock(irq, &flags, 0);",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Only try to inject when the interrupt is:",
            "\t *  - not NMI type",
            "\t *  - activated",
            "\t */",
            "\tif ((desc->istate & IRQS_NMI) || !irqd_is_activated(&desc->irq_data))",
            "\t\terr = -EINVAL;",
            "\telse",
            "\t\terr = check_irq_resend(desc, true);",
            "",
            "\tirq_put_desc_busunlock(desc, flags);",
            "\treturn err;",
            "}"
          ],
          "function_name": "irq_inject_interrupt",
          "description": "提供中断注入接口，通过硬件设置或软件重发机制将中断请求注入系统，需先获取中断描述符并验证中断属性",
          "similarity": 0.5561341047286987
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/resend.c",
          "start_line": 1,
          "end_line": 30,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar",
            " * Copyright (C) 2005-2006, Thomas Gleixner",
            " *",
            " * This file contains the IRQ-resend code",
            " *",
            " * If the interrupt is waiting to be processed, we try to re-run it.",
            " * We can't directly run it from here since the caller might be in an",
            " * interrupt-protected region. Not all irq controller chips can",
            " * retrigger interrupts at the hardware level, so in those cases",
            " * we allow the resending of IRQs via a tasklet.",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/interrupt.h>",
            "",
            "#include \"internals.h\"",
            "",
            "#ifdef CONFIG_HARDIRQS_SW_RESEND",
            "",
            "/* hlist_head to handle software resend of interrupts: */",
            "static HLIST_HEAD(irq_resend_list);",
            "static DEFINE_RAW_SPINLOCK(irq_resend_lock);",
            "",
            "/*",
            " * Run software resends of IRQ's",
            " */"
          ],
          "function_name": null,
          "description": "定义软件中断重发机制所需的全局数据结构和锁，用于管理待重发中断列表及同步访问",
          "similarity": 0.5310056209564209
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/resend.c",
          "start_line": 31,
          "end_line": 137,
          "content": [
            "static void resend_irqs(struct tasklet_struct *unused)",
            "{",
            "\tstruct irq_desc *desc;",
            "",
            "\traw_spin_lock_irq(&irq_resend_lock);",
            "\twhile (!hlist_empty(&irq_resend_list)) {",
            "\t\tdesc = hlist_entry(irq_resend_list.first, struct irq_desc,",
            "\t\t\t\t   resend_node);",
            "\t\thlist_del_init(&desc->resend_node);",
            "\t\traw_spin_unlock(&irq_resend_lock);",
            "\t\tdesc->handle_irq(desc);",
            "\t\traw_spin_lock(&irq_resend_lock);",
            "\t}",
            "\traw_spin_unlock_irq(&irq_resend_lock);",
            "}",
            "static int irq_sw_resend(struct irq_desc *desc)",
            "{",
            "\t/*",
            "\t * Validate whether this interrupt can be safely injected from",
            "\t * non interrupt context",
            "\t */",
            "\tif (handle_enforce_irqctx(&desc->irq_data))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * If the interrupt is running in the thread context of the parent",
            "\t * irq we need to be careful, because we cannot trigger it",
            "\t * directly.",
            "\t */",
            "\tif (irq_settings_is_nested_thread(desc)) {",
            "\t\t/*",
            "\t\t * If the parent_irq is valid, we retrigger the parent,",
            "\t\t * otherwise we do nothing.",
            "\t\t */",
            "\t\tif (!desc->parent_irq)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tdesc = irq_to_desc(desc->parent_irq);",
            "\t\tif (!desc)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* Add to resend_list and activate the softirq: */",
            "\traw_spin_lock(&irq_resend_lock);",
            "\tif (hlist_unhashed(&desc->resend_node))",
            "\t\thlist_add_head(&desc->resend_node, &irq_resend_list);",
            "\traw_spin_unlock(&irq_resend_lock);",
            "\ttasklet_schedule(&resend_tasklet);",
            "\treturn 0;",
            "}",
            "void clear_irq_resend(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&irq_resend_lock);",
            "\thlist_del_init(&desc->resend_node);",
            "\traw_spin_unlock(&irq_resend_lock);",
            "}",
            "void irq_resend_init(struct irq_desc *desc)",
            "{",
            "\tINIT_HLIST_NODE(&desc->resend_node);",
            "}",
            "void clear_irq_resend(struct irq_desc *desc) {}",
            "void irq_resend_init(struct irq_desc *desc) {}",
            "static int irq_sw_resend(struct irq_desc *desc)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int try_retrigger(struct irq_desc *desc)",
            "{",
            "\tif (desc->irq_data.chip->irq_retrigger)",
            "\t\treturn desc->irq_data.chip->irq_retrigger(&desc->irq_data);",
            "",
            "#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY",
            "\treturn irq_chip_retrigger_hierarchy(&desc->irq_data);",
            "#else",
            "\treturn 0;",
            "#endif",
            "}",
            "int check_irq_resend(struct irq_desc *desc, bool inject)",
            "{",
            "\tint err = 0;",
            "",
            "\t/*",
            "\t * We do not resend level type interrupts. Level type interrupts",
            "\t * are resent by hardware when they are still active. Clear the",
            "\t * pending bit so suspend/resume does not get confused.",
            "\t */",
            "\tif (irq_settings_is_level(desc)) {",
            "\t\tdesc->istate &= ~IRQS_PENDING;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (desc->istate & IRQS_REPLAY)",
            "\t\treturn -EBUSY;",
            "",
            "\tif (!(desc->istate & IRQS_PENDING) && !inject)",
            "\t\treturn 0;",
            "",
            "\tdesc->istate &= ~IRQS_PENDING;",
            "",
            "\tif (!try_retrigger(desc))",
            "\t\terr = irq_sw_resend(desc);",
            "",
            "\t/* If the retrigger was successful, mark it with the REPLAY bit */",
            "\tif (!err)",
            "\t\tdesc->istate |= IRQS_REPLAY;",
            "\treturn err;",
            "}"
          ],
          "function_name": "resend_irqs, irq_sw_resend, clear_irq_resend, irq_resend_init, clear_irq_resend, irq_resend_init, irq_sw_resend, try_retrigger, check_irq_resend",
          "description": "实现中断重发核心逻辑，包含中断添加至重发队列、任务调度、状态清理等功能，部分函数存在重复定义提示代码不完整",
          "similarity": 0.5163059234619141
        }
      ]
    }
  ]
}