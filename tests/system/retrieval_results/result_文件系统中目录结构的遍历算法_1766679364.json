{
  "query": "文件系统中目录结构的遍历算法",
  "timestamp": "2025-12-26 00:16:04",
  "retrieved_files": [
    {
      "source_file": "mm/pagewalk.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:08:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pagewalk.c`\n\n---\n\n# pagewalk.c 技术文档\n\n## 1. 文件概述\n\n`pagewalk.c` 是 Linux 内核中实现通用页表遍历（page table walk）机制的核心文件。它提供了一套可配置的回调接口，允许内核子系统以统一的方式遍历进程地址空间中的各级页表项（PGD → P4D → PUD → PMD → PTE），并支持对普通页、透明大页（THP）、hugetlbfs 大页以及架构特定的 hugepd（huge page directory）结构进行处理。该机制广泛用于内存管理、调试、性能分析和安全审计等场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `real_depth(int depth)`  \n  计算页表项在物理层级结构中的真实深度，考虑了某些架构下页表层级被“折叠”（folded）的情况（如 x86_64 中 P4D/PUD/PMD 可能被编译时优化掉）。\n\n- `walk_pte_range(pmd_t *pmd, ...)`  \n  遍历指定 PMD 所覆盖地址范围内的所有 PTE 项，调用 `ops->pte_entry` 回调。\n\n- `walk_pmd_range(pud_t *pud, ...)`  \n  遍历 PUD 范围内的 PMD 项，支持透明大页（THP）处理：若遇到 THP 且需要深入，则调用 `split_huge_pmd()` 拆分后再遍历 PTE。\n\n- `walk_pud_range(p4d_t *p4d, ...)`  \n  遍历 P4D 范围内的 PUD 项，类似地支持 PUD 级别的透明大页拆分。\n\n- `walk_p4d_range(pgd_t *pgd, ...)`  \n  遍历 PGD 范围内的 P4D 项。\n\n- `walk_pgd_range(unsigned long addr, ...)`  \n  顶层遍历函数，从 PGD 开始向下递归遍历整个指定虚拟地址区间。\n\n- `walk_hugetlb_range(unsigned long addr, ...)`  \n  （仅当 `CONFIG_HUGETLB_PAGE` 启用时）专门处理 hugetlbfs 映射的大页，调用 `ops->hugetlb_entry` 回调。\n\n- `walk_hugepd_range(hugepd_t *phpd, ...)`  \n  （仅当 `CONFIG_ARCH_HAS_HUGEPD` 启用时）处理架构特定的 hugepd 结构，用于非标准大页布局。\n\n### 关键数据结构\n\n- `struct mm_walk`  \n  封装遍历上下文，包含目标地址空间（`mm`）、VMA（`vma`）、操作回调集合（`ops`）、当前动作控制（`action`）等。\n\n- `struct mm_walk_ops`  \n  定义遍历过程中各级页表项的回调函数指针，包括：\n  - `pgd_entry`, `p4d_entry`, `pud_entry`, `pmd_entry`\n  - `pte_entry`, `hugetlb_entry`\n  - `pte_hole`（处理未映射或无效区域）\n\n- 动作控制枚举（隐式使用）：\n  - `ACTION_SUBTREE`：默认行为，继续向下遍历\n  - `ACTION_CONTINUE`：跳过当前子树\n  - `ACTION_AGAIN`：重新处理当前项（用于动态修改页表后重试）\n\n## 3. 关键实现\n\n### 层级折叠处理\n`real_depth()` 函数通过检查 `PTRS_PER_P?D == 1` 来判断某一级页表是否在编译时被折叠（即逻辑存在但物理上与上一级合并），从而将逻辑深度映射到实际硬件层级，确保 `pte_hole` 回调传入正确的深度参数。\n\n### 页表锁与映射管理\n- 在有 VMA 上下文时（`!walk->no_vma`），使用 `pte_offset_map_lock()` 获取 PTE 页表锁并映射 PTE；\n- 在无 VMA 场景（如内核页表遍历）时，根据地址范围选择 `pte_offset_kernel()` 或 `pte_offset_map()`，避免对用户空间页表执行不必要的验证。\n\n### 透明大页（THP）支持\n在 `walk_pmd_range()` 和 `walk_pud_range()` 中：\n- 若 `walk->vma` 存在且遇到 THP（`pmd_leaf()` 为真），则调用 `split_huge_pmd()` 将其拆分为普通 PTE 页表；\n- 拆分后重新检查 PMD 状态，确保遍历的是细化后的 PTE。\n\n### HugePD 支持\n当检测到页表项是 `hugepd` 类型（通过 `is_hugepd()` 判断），调用 `walk_hugepd_range()`，该函数按大页大小步进地址，并通过 `hugepte_offset()` 获取对应 PTE，适用于 PowerPC 等架构的非标准大页布局。\n\n### Hugetlbfs 专用路径\n`walk_hugetlb_range()` 使用 `hugetlb_walk()` 查找大页 PTE，并在 VMA 读锁保护下遍历，确保 hugetlbfs 映射的一致性。\n\n### 动作控制机制\n通过 `walk->action` 字段实现遍历流程的动态控制：\n- 回调函数可设置 `ACTION_CONTINUE` 跳过子树；\n- 设置 `ACTION_AGAIN` 可触发当前节点重处理（如页表被修改后）；\n- 默认为 `ACTION_SUBTREE`，继续向下遍历。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pagewalk.h>`：定义 `struct mm_walk`、`struct mm_walk_ops` 及相关常量\n  - `<linux/highmem.h>`：提供 `pte_offset_map()` / `pte_unmap()` 等高内存映射接口\n  - `<linux/sched.h>`：访问 `task_struct` 和 `mm_struct`\n  - `<linux/hugetlb.h>`：hugetlbfs 相关操作（如 `hugetlb_walk()`, `hstate_vma()`）\n\n- **架构依赖**：\n  - 依赖各架构定义的页表操作宏（如 `pmd_offset()`, `pmd_none()`, `pmd_leaf()` 等）\n  - `CONFIG_ARCH_HAS_HUGEPD` 控制 hugepd 支持\n  - `PTRS_PER_P?D` 宏用于判断页表折叠\n\n- **内存管理子系统**：\n  - 与 THP 子系统交互（`split_huge_pmd()`, `split_huge_pud()`）\n  - 与 hugetlbfs 子系统交互（`hugetlb_vma_lock_read()` 等）\n\n## 5. 使用场景\n\n- **内存统计与审计**：如 `/proc/pid/smaps` 生成、内存占用分析工具\n- **页表转储与调试**：内核调试功能（如 `CONFIG_EFI_PGT_DUMP`）遍历 EFI 页表\n- **内存迁移与回收**：在内存规整（compaction）或 NUMA 迁移时扫描页表\n- **安全监控**：检测异常内存映射（如可执行堆栈）\n- **性能分析**：perf 工具通过页表遍历关联虚拟地址与物理页\n- **KSM（Kernel Samepage Merging）**：扫描可合并页面\n- **用户态页表检查**：通过 `walk_page_range()` 系列 API 供内核模块遍历指定 VMA 的页表结构",
      "similarity": 0.6151576638221741,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/pagewalk.c",
          "start_line": 12,
          "end_line": 168,
          "content": [
            "static int real_depth(int depth)",
            "{",
            "\tif (depth == 3 && PTRS_PER_PMD == 1)",
            "\t\tdepth = 2;",
            "\tif (depth == 2 && PTRS_PER_PUD == 1)",
            "\t\tdepth = 1;",
            "\tif (depth == 1 && PTRS_PER_P4D == 1)",
            "\t\tdepth = 0;",
            "\treturn depth;",
            "}",
            "static int walk_pte_range_inner(pte_t *pte, unsigned long addr,",
            "\t\t\t\tunsigned long end, struct mm_walk *walk)",
            "{",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint err = 0;",
            "",
            "\tfor (;;) {",
            "\t\terr = ops->pte_entry(pte, addr, addr + PAGE_SIZE, walk);",
            "\t\tif (err)",
            "\t\t       break;",
            "\t\tif (addr >= end - PAGE_SIZE)",
            "\t\t\tbreak;",
            "\t\taddr += PAGE_SIZE;",
            "\t\tpte++;",
            "\t}",
            "\treturn err;",
            "}",
            "static int walk_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,",
            "\t\t\t  struct mm_walk *walk)",
            "{",
            "\tpte_t *pte;",
            "\tint err = 0;",
            "\tspinlock_t *ptl;",
            "",
            "\tif (walk->no_vma) {",
            "\t\t/*",
            "\t\t * pte_offset_map() might apply user-specific validation.",
            "\t\t * Indeed, on x86_64 the pmd entries set up by init_espfix_ap()",
            "\t\t * fit its pmd_bad() check (_PAGE_NX set and _PAGE_RW clear),",
            "\t\t * and CONFIG_EFI_PGT_DUMP efi_mm goes so far as to walk them.",
            "\t\t */",
            "\t\tif (walk->mm == &init_mm || addr >= TASK_SIZE)",
            "\t\t\tpte = pte_offset_kernel(pmd, addr);",
            "\t\telse",
            "\t\t\tpte = pte_offset_map(pmd, addr);",
            "\t\tif (pte) {",
            "\t\t\terr = walk_pte_range_inner(pte, addr, end, walk);",
            "\t\t\tif (walk->mm != &init_mm && addr < TASK_SIZE)",
            "\t\t\t\tpte_unmap(pte);",
            "\t\t}",
            "\t} else {",
            "\t\tpte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);",
            "\t\tif (pte) {",
            "\t\t\terr = walk_pte_range_inner(pte, addr, end, walk);",
            "\t\t\tpte_unmap_unlock(pte, ptl);",
            "\t\t}",
            "\t}",
            "\tif (!pte)",
            "\t\twalk->action = ACTION_AGAIN;",
            "\treturn err;",
            "}",
            "static int walk_hugepd_range(hugepd_t *phpd, unsigned long addr,",
            "\t\t\t     unsigned long end, struct mm_walk *walk, int pdshift)",
            "{",
            "\tint err = 0;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint shift = hugepd_shift(*phpd);",
            "\tint page_size = 1 << shift;",
            "",
            "\tif (!ops->pte_entry)",
            "\t\treturn 0;",
            "",
            "\tif (addr & (page_size - 1))",
            "\t\treturn 0;",
            "",
            "\tfor (;;) {",
            "\t\tpte_t *pte;",
            "",
            "\t\tspin_lock(&walk->mm->page_table_lock);",
            "\t\tpte = hugepte_offset(*phpd, addr, pdshift);",
            "\t\terr = ops->pte_entry(pte, addr, addr + page_size, walk);",
            "\t\tspin_unlock(&walk->mm->page_table_lock);",
            "",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t\tif (addr >= end - page_size)",
            "\t\t\tbreak;",
            "\t\taddr += page_size;",
            "\t}",
            "\treturn err;",
            "}",
            "static int walk_hugepd_range(hugepd_t *phpd, unsigned long addr,",
            "\t\t\t     unsigned long end, struct mm_walk *walk, int pdshift)",
            "{",
            "\treturn 0;",
            "}",
            "static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,",
            "\t\t\t  struct mm_walk *walk)",
            "{",
            "\tpmd_t *pmd;",
            "\tunsigned long next;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint err = 0;",
            "\tint depth = real_depth(3);",
            "",
            "\tpmd = pmd_offset(pud, addr);",
            "\tdo {",
            "again:",
            "\t\tnext = pmd_addr_end(addr, end);",
            "\t\tif (pmd_none(*pmd)) {",
            "\t\t\tif (ops->pte_hole)",
            "\t\t\t\terr = ops->pte_hole(addr, next, depth, walk);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\twalk->action = ACTION_SUBTREE;",
            "",
            "\t\t/*",
            "\t\t * This implies that each ->pmd_entry() handler",
            "\t\t * needs to know about pmd_trans_huge() pmds",
            "\t\t */",
            "\t\tif (ops->pmd_entry)",
            "\t\t\terr = ops->pmd_entry(pmd, addr, next, walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "",
            "\t\tif (walk->action == ACTION_AGAIN)",
            "\t\t\tgoto again;",
            "",
            "\t\t/*",
            "\t\t * Check this here so we only break down trans_huge",
            "\t\t * pages when we _need_ to",
            "\t\t */",
            "\t\tif ((!walk->vma && (pmd_leaf(*pmd) || !pmd_present(*pmd))) ||",
            "\t\t    walk->action == ACTION_CONTINUE ||",
            "\t\t    !(ops->pte_entry))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (walk->vma)",
            "\t\t\tsplit_huge_pmd(walk->vma, pmd, addr);",
            "",
            "\t\tif (is_hugepd(__hugepd(pmd_val(*pmd))))",
            "\t\t\terr = walk_hugepd_range((hugepd_t *)pmd, addr, next, walk, PMD_SHIFT);",
            "\t\telse",
            "\t\t\terr = walk_pte_range(pmd, addr, next, walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "",
            "\t\tif (walk->action == ACTION_AGAIN)",
            "\t\t\tgoto again;",
            "",
            "\t} while (pmd++, addr = next, addr != end);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "real_depth, walk_pte_range_inner, walk_pte_range, walk_hugepd_range, walk_hugepd_range, walk_pmd_range",
          "description": "实现页表遍历核心逻辑，包含real_depth函数用于修正页表层级，walk_pte_range遍历页目录项，walk_pmd_range处理大页面拆分，walk_hugepd_range处理HugePD页面，walk_pud_range/walk_p4d_range/walk_pgd_range递归处理更高层级页表结构。",
          "similarity": 0.5937159061431885
        },
        {
          "chunk_id": 4,
          "file_path": "mm/pagewalk.c",
          "start_line": 470,
          "end_line": 589,
          "content": [
            "int walk_page_range(struct mm_struct *mm, unsigned long start,",
            "\t\tunsigned long end, const struct mm_walk_ops *ops,",
            "\t\tvoid *private)",
            "{",
            "\tint err = 0;",
            "\tunsigned long next;",
            "\tstruct vm_area_struct *vma;",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.mm\t\t= mm,",
            "\t\t.private\t= private,",
            "\t};",
            "",
            "\tif (start >= end)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!walk.mm)",
            "\t\treturn -EINVAL;",
            "",
            "\tprocess_mm_walk_lock(walk.mm, ops->walk_lock);",
            "",
            "\tvma = find_vma(walk.mm, start);",
            "\tdo {",
            "\t\tif (!vma) { /* after the last vma */",
            "\t\t\twalk.vma = NULL;",
            "\t\t\tnext = end;",
            "\t\t\tif (ops->pte_hole)",
            "\t\t\t\terr = ops->pte_hole(start, next, -1, &walk);",
            "\t\t} else if (start < vma->vm_start) { /* outside vma */",
            "\t\t\twalk.vma = NULL;",
            "\t\t\tnext = min(end, vma->vm_start);",
            "\t\t\tif (ops->pte_hole)",
            "\t\t\t\terr = ops->pte_hole(start, next, -1, &walk);",
            "\t\t} else { /* inside vma */",
            "\t\t\tprocess_vma_walk_lock(vma, ops->walk_lock);",
            "\t\t\twalk.vma = vma;",
            "\t\t\tnext = min(end, vma->vm_end);",
            "\t\t\tvma = find_vma(mm, vma->vm_end);",
            "",
            "\t\t\terr = walk_page_test(start, next, &walk);",
            "\t\t\tif (err > 0) {",
            "\t\t\t\t/*",
            "\t\t\t\t * positive return values are purely for",
            "\t\t\t\t * controlling the pagewalk, so should never",
            "\t\t\t\t * be passed to the callers.",
            "\t\t\t\t */",
            "\t\t\t\terr = 0;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif (err < 0)",
            "\t\t\t\tbreak;",
            "\t\t\terr = __walk_page_range(start, next, &walk);",
            "\t\t}",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t} while (start = next, start < end);",
            "\treturn err;",
            "}",
            "int walk_page_range_novma(struct mm_struct *mm, unsigned long start,",
            "\t\t\t  unsigned long end, const struct mm_walk_ops *ops,",
            "\t\t\t  pgd_t *pgd,",
            "\t\t\t  void *private)",
            "{",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.mm\t\t= mm,",
            "\t\t.pgd\t\t= pgd,",
            "\t\t.private\t= private,",
            "\t\t.no_vma\t\t= true",
            "\t};",
            "",
            "\tif (start >= end || !walk.mm)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * 1) For walking the user virtual address space:",
            "\t *",
            "\t * The mmap lock protects the page walker from changes to the page",
            "\t * tables during the walk.  However a read lock is insufficient to",
            "\t * protect those areas which don't have a VMA as munmap() detaches",
            "\t * the VMAs before downgrading to a read lock and actually tearing",
            "\t * down PTEs/page tables. In which case, the mmap write lock should",
            "\t * be hold.",
            "\t *",
            "\t * 2) For walking the kernel virtual address space:",
            "\t *",
            "\t * The kernel intermediate page tables usually do not be freed, so",
            "\t * the mmap map read lock is sufficient. But there are some exceptions.",
            "\t * E.g. memory hot-remove. In which case, the mmap lock is insufficient",
            "\t * to prevent the intermediate kernel pages tables belonging to the",
            "\t * specified address range from being freed. The caller should take",
            "\t * other actions to prevent this race.",
            "\t */",
            "\tif (mm == &init_mm)",
            "\t\tmmap_assert_locked(walk.mm);",
            "\telse",
            "\t\tmmap_assert_write_locked(walk.mm);",
            "",
            "\treturn walk_pgd_range(start, end, &walk);",
            "}",
            "int walk_page_range_vma(struct vm_area_struct *vma, unsigned long start,",
            "\t\t\tunsigned long end, const struct mm_walk_ops *ops,",
            "\t\t\tvoid *private)",
            "{",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.mm\t\t= vma->vm_mm,",
            "\t\t.vma\t\t= vma,",
            "\t\t.private\t= private,",
            "\t};",
            "",
            "\tif (start >= end || !walk.mm)",
            "\t\treturn -EINVAL;",
            "\tif (start < vma->vm_start || end > vma->vm_end)",
            "\t\treturn -EINVAL;",
            "",
            "\tprocess_mm_walk_lock(walk.mm, ops->walk_lock);",
            "\tprocess_vma_walk_lock(vma, ops->walk_lock);",
            "\treturn __walk_page_range(start, end, &walk);",
            "}"
          ],
          "function_name": "walk_page_range, walk_page_range_novma, walk_page_range_vma",
          "description": "实现三种页表遍历接口，walk_page_range处理任意MM域的页表遍历，walk_page_range_novma处理无需VMA的内核地址空间遍历，walk_page_range_vma处理特定VMA区域的遍历，均通过调用底层遍历函数完成实际工作。",
          "similarity": 0.5779048800468445
        },
        {
          "chunk_id": 5,
          "file_path": "mm/pagewalk.c",
          "start_line": 613,
          "end_line": 675,
          "content": [
            "int walk_page_vma(struct vm_area_struct *vma, const struct mm_walk_ops *ops,",
            "\t\tvoid *private)",
            "{",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.mm\t\t= vma->vm_mm,",
            "\t\t.vma\t\t= vma,",
            "\t\t.private\t= private,",
            "\t};",
            "",
            "\tif (!walk.mm)",
            "\t\treturn -EINVAL;",
            "",
            "\tprocess_mm_walk_lock(walk.mm, ops->walk_lock);",
            "\tprocess_vma_walk_lock(vma, ops->walk_lock);",
            "\treturn __walk_page_range(vma->vm_start, vma->vm_end, &walk);",
            "}",
            "int walk_page_mapping(struct address_space *mapping, pgoff_t first_index,",
            "\t\t      pgoff_t nr, const struct mm_walk_ops *ops,",
            "\t\t      void *private)",
            "{",
            "\tstruct mm_walk walk = {",
            "\t\t.ops\t\t= ops,",
            "\t\t.private\t= private,",
            "\t};",
            "\tstruct vm_area_struct *vma;",
            "\tpgoff_t vba, vea, cba, cea;",
            "\tunsigned long start_addr, end_addr;",
            "\tint err = 0;",
            "",
            "\tlockdep_assert_held(&mapping->i_mmap_rwsem);",
            "\tvma_interval_tree_foreach(vma, &mapping->i_mmap, first_index,",
            "\t\t\t\t  first_index + nr - 1) {",
            "\t\t/* Clip to the vma */",
            "\t\tvba = vma->vm_pgoff;",
            "\t\tvea = vba + vma_pages(vma);",
            "\t\tcba = first_index;",
            "\t\tcba = max(cba, vba);",
            "\t\tcea = first_index + nr;",
            "\t\tcea = min(cea, vea);",
            "",
            "\t\tstart_addr = ((cba - vba) << PAGE_SHIFT) + vma->vm_start;",
            "\t\tend_addr = ((cea - vba) << PAGE_SHIFT) + vma->vm_start;",
            "\t\tif (start_addr >= end_addr)",
            "\t\t\tcontinue;",
            "",
            "\t\twalk.vma = vma;",
            "\t\twalk.mm = vma->vm_mm;",
            "",
            "\t\terr = walk_page_test(vma->vm_start, vma->vm_end, &walk);",
            "\t\tif (err > 0) {",
            "\t\t\terr = 0;",
            "\t\t\tbreak;",
            "\t\t} else if (err < 0)",
            "\t\t\tbreak;",
            "",
            "\t\terr = __walk_page_range(start_addr, end_addr, &walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "walk_page_vma, walk_page_mapping",
          "description": "该代码段实现了两种页面遍历接口：  \n1. `walk_page_vma`用于遍历指定VMA范围的页面，通过`__walk_page_range`执行实际操作，需持有VMA锁以保证并发安全；  \n2. `walk_page_mapping`遍历文件映射区域对应的所有VMA区间，按索引范围裁剪后调用`__walk_page_range`处理具体页表项，依赖VMA区间树遍历机制；  \n代码上下文不完整，部分锁操作和底层遍历函数（如`__walk_page_range`）未展示。",
          "similarity": 0.5557358860969543
        },
        {
          "chunk_id": 2,
          "file_path": "mm/pagewalk.c",
          "start_line": 177,
          "end_line": 297,
          "content": [
            "static int walk_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end,",
            "\t\t\t  struct mm_walk *walk)",
            "{",
            "\tpud_t *pud;",
            "\tunsigned long next;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint err = 0;",
            "\tint depth = real_depth(2);",
            "",
            "\tpud = pud_offset(p4d, addr);",
            "\tdo {",
            " again:",
            "\t\tnext = pud_addr_end(addr, end);",
            "\t\tif (pud_none(*pud)) {",
            "\t\t\tif (ops->pte_hole)",
            "\t\t\t\terr = ops->pte_hole(addr, next, depth, walk);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\twalk->action = ACTION_SUBTREE;",
            "",
            "\t\tif (ops->pud_entry)",
            "\t\t\terr = ops->pud_entry(pud, addr, next, walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "",
            "\t\tif (walk->action == ACTION_AGAIN)",
            "\t\t\tgoto again;",
            "",
            "\t\tif ((!walk->vma && (pud_leaf(*pud) || !pud_present(*pud))) ||",
            "\t\t    walk->action == ACTION_CONTINUE ||",
            "\t\t    !(ops->pmd_entry || ops->pte_entry))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (walk->vma)",
            "\t\t\tsplit_huge_pud(walk->vma, pud, addr);",
            "\t\tif (pud_none(*pud))",
            "\t\t\tgoto again;",
            "",
            "\t\tif (is_hugepd(__hugepd(pud_val(*pud))))",
            "\t\t\terr = walk_hugepd_range((hugepd_t *)pud, addr, next, walk, PUD_SHIFT);",
            "\t\telse",
            "\t\t\terr = walk_pmd_range(pud, addr, next, walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t} while (pud++, addr = next, addr != end);",
            "",
            "\treturn err;",
            "}",
            "static int walk_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end,",
            "\t\t\t  struct mm_walk *walk)",
            "{",
            "\tp4d_t *p4d;",
            "\tunsigned long next;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint err = 0;",
            "\tint depth = real_depth(1);",
            "",
            "\tp4d = p4d_offset(pgd, addr);",
            "\tdo {",
            "\t\tnext = p4d_addr_end(addr, end);",
            "\t\tif (p4d_none_or_clear_bad(p4d)) {",
            "\t\t\tif (ops->pte_hole)",
            "\t\t\t\terr = ops->pte_hole(addr, next, depth, walk);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (ops->p4d_entry) {",
            "\t\t\terr = ops->p4d_entry(p4d, addr, next, walk);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (is_hugepd(__hugepd(p4d_val(*p4d))))",
            "\t\t\terr = walk_hugepd_range((hugepd_t *)p4d, addr, next, walk, P4D_SHIFT);",
            "\t\telse if (ops->pud_entry || ops->pmd_entry || ops->pte_entry)",
            "\t\t\terr = walk_pud_range(p4d, addr, next, walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t} while (p4d++, addr = next, addr != end);",
            "",
            "\treturn err;",
            "}",
            "static int walk_pgd_range(unsigned long addr, unsigned long end,",
            "\t\t\t  struct mm_walk *walk)",
            "{",
            "\tpgd_t *pgd;",
            "\tunsigned long next;",
            "\tconst struct mm_walk_ops *ops = walk->ops;",
            "\tint err = 0;",
            "",
            "\tif (walk->pgd)",
            "\t\tpgd = walk->pgd + pgd_index(addr);",
            "\telse",
            "\t\tpgd = pgd_offset(walk->mm, addr);",
            "\tdo {",
            "\t\tnext = pgd_addr_end(addr, end);",
            "\t\tif (pgd_none_or_clear_bad(pgd)) {",
            "\t\t\tif (ops->pte_hole)",
            "\t\t\t\terr = ops->pte_hole(addr, next, 0, walk);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (ops->pgd_entry) {",
            "\t\t\terr = ops->pgd_entry(pgd, addr, next, walk);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (is_hugepd(__hugepd(pgd_val(*pgd))))",
            "\t\t\terr = walk_hugepd_range((hugepd_t *)pgd, addr, next, walk, PGDIR_SHIFT);",
            "\t\telse if (ops->p4d_entry || ops->pud_entry || ops->pmd_entry || ops->pte_entry)",
            "\t\t\terr = walk_p4d_range(pgd, addr, next, walk);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t} while (pgd++, addr = next, addr != end);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "walk_pud_range, walk_p4d_range, walk_pgd_range",
          "description": "实现PUD/P4D/PGD层级的页表遍历，walk_pud_range处理PUD项，walk_p4d_range处理P4D项，walk_pgd_range处理PGD项，均通过判断是否为巨型页面并递归调用相应遍历函数。",
          "similarity": 0.5280902981758118
        },
        {
          "chunk_id": 0,
          "file_path": "mm/pagewalk.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/pagewalk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched.h>",
            "#include <linux/hugetlb.h>",
            "",
            "/*",
            " * We want to know the real level where a entry is located ignoring any",
            " * folding of levels which may be happening. For example if p4d is folded then",
            " * a missing entry found at level 1 (p4d) is actually at level 0 (pgd).",
            " */"
          ],
          "function_name": null,
          "description": "定义了real_depth函数，用于调整页表层级以忽略折叠情况，通过比较PTRS_PER_*宏值来动态修正深度。其余部分为页表遍历相关头文件声明及注释说明。",
          "similarity": 0.5089889764785767
        }
      ]
    },
    {
      "source_file": "mm/ptdump.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:14:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ptdump.c`\n\n---\n\n# ptdump.c 技术文档\n\n## 1. 文件概述\n\n`ptdump.c` 是 Linux 内核中用于遍历和转储页表（Page Table）内容的核心实现文件。它通过 `walk_page_range_novma()` 接口对指定虚拟地址范围内的页表结构进行深度遍历，并调用用户提供的回调函数记录每一级页表项的状态。该文件特别针对启用了 KASAN（Kernel Address Sanitizer）的配置进行了性能优化，避免在大量未映射区域上进行冗余的页表遍历，显著提升调试信息（如 `kernel_page_tables` debugfs 文件）生成效率。\n\n## 2. 核心功能\n\n### 主要函数\n- `ptdump_walk_pgd(struct ptdump_state *st, struct mm_struct *mm, pgd_t *pgd)`  \n  入口函数，遍历指定内存管理结构 `mm` 中由 `st->range` 定义的多个虚拟地址区间，并使用 `ptdump_ops` 对页表进行遍历。\n  \n- `ptdump_pgd_entry()`, `ptdump_p4d_entry()`, `ptdump_pud_entry()`, `ptdump_pmd_entry()`, `ptdump_pte_entry()`  \n  各级页表项的回调处理函数，在遍历过程中被 `mm_walk` 框架调用，用于提取页表项值、计算有效权限（若启用），并调用 `note_page()` 记录叶节点或中间节点信息。\n\n- `ptdump_hole()`  \n  处理页表“空洞”（即未映射区域）的回调函数，将空洞视为无效页表项（值为0）传递给 `note_page()`。\n\n- `note_kasan_page_table()`（条件编译）  \n  KASAN 专用优化函数，当检测到页表指向 KASAN 的早期影子页（shadow page）时，直接生成对应的 PTE 条目，跳过下层页表遍历。\n\n### 主要数据结构\n- `struct ptdump_state`（定义于 `<linux/ptdump.h>`）  \n  用户提供的状态结构体，包含以下关键成员：\n  - `const struct ptdump_range *range`：待遍历的虚拟地址范围数组。\n  - `void (*note_page)(...)`：每遇到一个页表项（或空洞）时调用的回调函数。\n  - `void (*effective_prot)(...)`（可选）：用于逐级累积并计算有效页表权限的回调。\n\n- `ptdump_ops`（`static const struct mm_walk_ops`）  \n  定义了页表遍历过程中各级回调函数的集合，供 `walk_page_range_novma()` 使用。\n\n## 3. 关键实现\n\n### KASAN 优化机制\n当内核配置启用 `CONFIG_KASAN_GENERIC` 或 `CONFIG_KASAN_SW_TAGS` 时，大量未使用的虚拟地址空间会映射到共享的 KASAN 影子页（如 `kasan_early_shadow_pte`）。传统遍历方式需逐级深入这些页表，效率极低。本文件通过在各级页表入口（PGD/P4D/PUD/PMD）检查当前页表项是否指向对应的 KASAN 影子页结构：\n```c\nif (pmd_page(val) == virt_to_page(lm_alias(kasan_early_shadow_pte)))\n    return note_kasan_page_table(walk, addr);\n```\n若匹配，则直接调用 `note_kasan_page_table()`，模拟一个完整的 PTE 层级条目（使用 `kasan_early_shadow_pte[0]` 的值），并设置 `walk->action = ACTION_CONTINUE` 跳过后续遍历。此优化可将页表转储时间从分钟级降至秒级。\n\n### 页表遍历与回调\n- 使用 `READ_ONCE()` 安全读取页表项，避免编译器优化导致的竞态。\n- 对于支持大页（huge page）的架构，通过 `*_leaf()` 宏判断当前页表项是否为叶节点（即不再指向下一级页表），若是则直接记录。\n- `effective_prot` 回调允许用户逐级（depth 0~4）收集页表项原始值，用于计算最终的有效访问权限（如 NX、RW 等位的组合效果）。\n- 遍历结束后调用 `st->note_page(st, 0, -1, 0)` 作为结束标记，便于用户清理状态。\n\n### 地址范围处理\n支持多个不连续的虚拟地址范围（`ptdump_range` 数组），通过循环依次遍历每个区间。遍历期间持有 `mmap_write_lock` 以确保页表结构一致性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pagewalk.h>`：提供 `mm_walk` 框架及 `walk_page_range_novma()` 等遍历接口。\n  - `<linux/ptdump.h>`：定义 `struct ptdump_state` 和 `struct ptdump_range` 等用户接口结构。\n  - `<linux/kasan.h>`：提供 KASAN 相关的影子页符号（如 `kasan_early_shadow_pte`）。\n\n- **配置依赖**：\n  - `CONFIG_KASAN_GENERIC` / `CONFIG_KASAN_SW_TAGS`：启用 KASAN 优化路径。\n  - `CONFIG_PGTABLE_LEVELS`：决定编译哪些页表层级的 KASAN 检查逻辑（如 5 级页表需检查 PGD 层）。\n\n- **架构依赖**：\n  - 依赖架构特定的页表操作宏（如 `pgd_leaf()`, `pmd_val()` 等），这些由各架构的 `pgtable.h` 提供。\n  - `lm_alias()` 用于处理直接映射区域的别名转换（主要在 x86_64 等支持 5-level 页表的架构中使用）。\n\n## 5. 使用场景\n\n- **内核调试**：  \n  作为 `debugfs` 中 `kernel_page_tables` 文件的底层实现，用于展示内核完整页表布局，辅助分析内存映射问题。\n\n- **安全审计**：  \n  检测违反 W^X（Write XOR Execute）策略的内存区域，即同时具有可写和可执行权限的页。\n\n- **KASAN 开发与诊断**：  \n  在启用 KASAN 的系统中高效生成页表快照，帮助开发者理解影子内存布局及未初始化内存的映射情况。\n\n- **内存管理子系统测试**：  \n  用于验证页表操作（如大页拆分、内存映射）的正确性，通过对比转储前后的页表状态。",
      "similarity": 0.59909987449646,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/ptdump.c",
          "start_line": 15,
          "end_line": 124,
          "content": [
            "static inline int note_kasan_page_table(struct mm_walk *walk,",
            "\t\t\t\t\tunsigned long addr)",
            "{",
            "\tstruct ptdump_state *st = walk->private;",
            "",
            "\tst->note_page(st, addr, 4, pte_val(kasan_early_shadow_pte[0]));",
            "",
            "\twalk->action = ACTION_CONTINUE;",
            "",
            "\treturn 0;",
            "}",
            "static int ptdump_pgd_entry(pgd_t *pgd, unsigned long addr,",
            "\t\t\t    unsigned long next, struct mm_walk *walk)",
            "{",
            "\tstruct ptdump_state *st = walk->private;",
            "\tpgd_t val = READ_ONCE(*pgd);",
            "",
            "#if CONFIG_PGTABLE_LEVELS > 4 && \\",
            "\t\t(defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS))",
            "\tif (pgd_page(val) == virt_to_page(lm_alias(kasan_early_shadow_p4d)))",
            "\t\treturn note_kasan_page_table(walk, addr);",
            "#endif",
            "",
            "\tif (st->effective_prot)",
            "\t\tst->effective_prot(st, 0, pgd_val(val));",
            "",
            "\tif (pgd_leaf(val)) {",
            "\t\tst->note_page(st, addr, 0, pgd_val(val));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int ptdump_p4d_entry(p4d_t *p4d, unsigned long addr,",
            "\t\t\t    unsigned long next, struct mm_walk *walk)",
            "{",
            "\tstruct ptdump_state *st = walk->private;",
            "\tp4d_t val = READ_ONCE(*p4d);",
            "",
            "#if CONFIG_PGTABLE_LEVELS > 3 && \\",
            "\t\t(defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS))",
            "\tif (p4d_page(val) == virt_to_page(lm_alias(kasan_early_shadow_pud)))",
            "\t\treturn note_kasan_page_table(walk, addr);",
            "#endif",
            "",
            "\tif (st->effective_prot)",
            "\t\tst->effective_prot(st, 1, p4d_val(val));",
            "",
            "\tif (p4d_leaf(val)) {",
            "\t\tst->note_page(st, addr, 1, p4d_val(val));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int ptdump_pud_entry(pud_t *pud, unsigned long addr,",
            "\t\t\t    unsigned long next, struct mm_walk *walk)",
            "{",
            "\tstruct ptdump_state *st = walk->private;",
            "\tpud_t val = READ_ONCE(*pud);",
            "",
            "#if CONFIG_PGTABLE_LEVELS > 2 && \\",
            "\t\t(defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS))",
            "\tif (pud_page(val) == virt_to_page(lm_alias(kasan_early_shadow_pmd)))",
            "\t\treturn note_kasan_page_table(walk, addr);",
            "#endif",
            "",
            "\tif (st->effective_prot)",
            "\t\tst->effective_prot(st, 2, pud_val(val));",
            "",
            "\tif (pud_leaf(val)) {",
            "\t\tst->note_page(st, addr, 2, pud_val(val));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int ptdump_pmd_entry(pmd_t *pmd, unsigned long addr,",
            "\t\t\t    unsigned long next, struct mm_walk *walk)",
            "{",
            "\tstruct ptdump_state *st = walk->private;",
            "\tpmd_t val = READ_ONCE(*pmd);",
            "",
            "#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)",
            "\tif (pmd_page(val) == virt_to_page(lm_alias(kasan_early_shadow_pte)))",
            "\t\treturn note_kasan_page_table(walk, addr);",
            "#endif",
            "",
            "\tif (st->effective_prot)",
            "\t\tst->effective_prot(st, 3, pmd_val(val));",
            "\tif (pmd_leaf(val)) {",
            "\t\tst->note_page(st, addr, 3, pmd_val(val));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int ptdump_pte_entry(pte_t *pte, unsigned long addr,",
            "\t\t\t    unsigned long next, struct mm_walk *walk)",
            "{",
            "\tstruct ptdump_state *st = walk->private;",
            "\tpte_t val = ptep_get_lockless(pte);",
            "",
            "\tif (st->effective_prot)",
            "\t\tst->effective_prot(st, 4, pte_val(val));",
            "",
            "\tst->note_page(st, addr, 4, pte_val(val));",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "note_kasan_page_table, ptdump_pgd_entry, ptdump_p4d_entry, ptdump_pud_entry, ptdump_pmd_entry, ptdump_pte_entry",
          "description": "实现了针对不同页表层级（PGD/P4D/PUD/PMD/PTA）的遍历处理逻辑，通过检查页表项是否指向KASAN早期影子页表，若匹配则直接调用note_kasan_page_table快速记录，否则继续递归遍历页表",
          "similarity": 0.5453165769577026
        },
        {
          "chunk_id": 2,
          "file_path": "mm/ptdump.c",
          "start_line": 132,
          "end_line": 155,
          "content": [
            "static int ptdump_hole(unsigned long addr, unsigned long next,",
            "\t\t       int depth, struct mm_walk *walk)",
            "{",
            "\tstruct ptdump_state *st = walk->private;",
            "",
            "\tst->note_page(st, addr, depth, 0);",
            "",
            "\treturn 0;",
            "}",
            "void ptdump_walk_pgd(struct ptdump_state *st, struct mm_struct *mm, pgd_t *pgd)",
            "{",
            "\tconst struct ptdump_range *range = st->range;",
            "",
            "\tmmap_write_lock(mm);",
            "\twhile (range->start != range->end) {",
            "\t\twalk_page_range_novma(mm, range->start, range->end,",
            "\t\t\t\t      &ptdump_ops, pgd, st);",
            "\t\trange++;",
            "\t}",
            "\tmmap_write_unlock(mm);",
            "",
            "\t/* Flush out the last page */",
            "\tst->note_page(st, 0, -1, 0);",
            "}"
          ],
          "function_name": "ptdump_hole, ptdump_walk_pgd",
          "description": "ptdump_hole函数用于记录页表空洞区域信息，ptdump_walk_pgd函数作为入口点启动全页表遍历流程，通过walk_page_range_novma处理指定地址范围，并在遍历完成后强制记录末尾页面状态",
          "similarity": 0.5162631273269653
        },
        {
          "chunk_id": 0,
          "file_path": "mm/ptdump.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/pagewalk.h>",
            "#include <linux/ptdump.h>",
            "#include <linux/kasan.h>",
            "",
            "#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)",
            "/*",
            " * This is an optimization for KASAN=y case. Since all kasan page tables",
            " * eventually point to the kasan_early_shadow_page we could call note_page()",
            " * right away without walking through lower level page tables. This saves",
            " * us dozens of seconds (minutes for 5-level config) while checking for",
            " * W+X mapping or reading kernel_page_tables debugfs file.",
            " */"
          ],
          "function_name": null,
          "description": "此代码块定义了针对KASAN内存保护机制的优化策略，在CONFIG_KASAN_GENERIC或CONFIG_KASAN_SW_TAGS配置下，通过直接访问kasan_early_shadow_page跳过多级页表遍历，提升调试工具读取页表信息的性能",
          "similarity": 0.4629993140697479
        }
      ]
    },
    {
      "source_file": "kernel/module/tree_lookup.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:09:32\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\tree_lookup.c`\n\n---\n\n# module/tree_lookup.c 技术文档\n\n## 1. 文件概述\n\n`module/tree_lookup.c` 实现了一个基于**锁存红黑树（latched RB-tree）** 的模块地址查找机制，用于高效地根据内存地址定位所属的内核模块。该机制专为高性能、低延迟的地址查询场景设计，特别适用于性能事件（perf events）和跟踪（tracing）子系统在任意上下文（包括 NMI）中频繁调用 `__module_address()` 的情况。通过使用 RCU-sched 语义，该实现支持无锁读取，同时保证写操作（模块加载/卸载）的安全性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `mod_tree_insert(struct module *mod)`  \n  将模块的所有内存区域（按类型）插入全局模块树 `mod_tree`。\n\n- `mod_tree_remove_init(struct module *mod)`  \n  仅移除模块的初始化内存区域（如 `.init.text`、`.init.data` 等）。\n\n- `mod_tree_remove(struct module *mod)`  \n  移除模块的所有内存区域。\n\n- `mod_find(unsigned long addr, struct mod_tree_root *tree)`  \n  在指定模块树中查找包含给定地址 `addr` 的模块，返回对应的 `struct module *`。\n\n- `__mod_tree_insert()` / `__mod_tree_remove()`  \n  内部辅助函数，封装对 `latch_tree_insert()` 和 `latch_tree_erase()` 的调用。\n\n### 关键数据结构\n\n- `struct latch_tree_ops mod_tree_ops`  \n  定义模块树的比较和排序逻辑，包含：\n  - `.less`：节点间大小比较函数\n  - `.comp`：键值与节点的范围比较函数\n\n- `struct mod_tree_node`（隐含在 `struct module_memory` 中）  \n  模块内存区域在红黑树中的节点表示，包含指向所属模块的指针。\n\n## 3. 关键实现\n\n### 锁存红黑树（Latched RB-tree）机制\n- 使用 `latch_tree` 数据结构，支持**双版本（double-buffered）** 更新，允许读者在不加锁的情况下通过 RCU-sched 安全遍历。\n- 写操作（插入/删除）由 `module_mutex` 串行化，确保树结构修改的原子性。\n- 读操作（`mod_find`）可在任意上下文（包括中断、NMI）中执行，无需获取锁。\n\n### 地址范围比较逻辑\n- 每个模块内存区域由基地址（`base`）和大小（`size`）定义。\n- `mod_tree_comp()` 函数实现**区间包含判断**：\n  - 若查询地址 `< base`，返回 `-1`（在左侧）\n  - 若查询地址 `>= base + size`，返回 `1`（在右侧）\n  - 否则返回 `0`（命中该区域）\n\n### 内存区域类型遍历\n- 使用宏 `for_each_mod_mem_type()` 和 `for_class_mod_mem_type()` 遍历模块的所有内存段类型（如代码段、数据段、初始化段等）。\n- 仅当内存区域大小非零时才插入/移除树节点，避免无效条目。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：提供 `struct module` 等核心模块定义\n  - `<linux/rbtree_latch.h>`：提供锁存红黑树实现\n  - `\"internal.h\"`：包含模块子系统内部数据结构（如 `mod_tree` 全局变量、`module_memory` 定义等）\n\n- **全局变量依赖**：\n  - `mod_tree`：全局 `struct mod_tree_root` 实例，定义在 `internal.h` 中\n  - `module_mutex`：序列化模块树修改操作的互斥锁\n\n- **条件编译**：  \n  该文件功能仅在 `CONFIG_PERF_EVENTS || CONFIG_TRACING` 启用时编译，因其主要服务于性能分析和跟踪场景。\n\n## 5. 使用场景\n\n- **性能分析（perf）**：  \n  在 perf 采样中断或 NMI 中，通过 `__module_address()` 快速确定程序计数器（PC）是否位于某个内核模块内，用于符号解析和调用栈展开。\n\n- **内核跟踪（ftrace/kprobes）**：  \n  跟踪点触发时需识别当前执行地址所属模块，以提供模块上下文信息。\n\n- **模块卸载安全检查**：  \n  在模块移除前，通过地址查询验证无活跃引用（如 kprobe、ftrace 等）。\n\n- **内核 Oops/panic 诊断**：  \n  在内核崩溃时，快速定位错误地址所属模块，辅助调试。\n\n该实现通过无锁读取和高效区间查询，显著提升了高频率地址查找场景下的系统性能和实时性。",
      "similarity": 0.5899266600608826,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/module/tree_lookup.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Modules tree lookup",
            " *",
            " * Copyright (C) 2015 Peter Zijlstra",
            " * Copyright (C) 2015 Rusty Russell",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/rbtree_latch.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * Use a latched RB-tree for __module_address(); this allows us to use",
            " * RCU-sched lookups of the address from any context.",
            " *",
            " * This is conditional on PERF_EVENTS || TRACING because those can really hit",
            " * __module_address() hard by doing a lot of stack unwinding; potentially from",
            " * NMI context.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "定义使用带闩锁的RB树结构，用于支持模块地址查询，允许RCU-sched上下文下的安全查找，该实现依赖PERF_EVENTS或TRACING特性以应对高频栈遍历场景",
          "similarity": 0.5578557252883911
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/tree_lookup.c",
          "start_line": 22,
          "end_line": 84,
          "content": [
            "static __always_inline unsigned long __mod_tree_val(struct latch_tree_node *n)",
            "{",
            "\tstruct module_memory *mod_mem = container_of(n, struct module_memory, mtn.node);",
            "",
            "\treturn (unsigned long)mod_mem->base;",
            "}",
            "static __always_inline unsigned long __mod_tree_size(struct latch_tree_node *n)",
            "{",
            "\tstruct module_memory *mod_mem = container_of(n, struct module_memory, mtn.node);",
            "",
            "\treturn (unsigned long)mod_mem->size;",
            "}",
            "static __always_inline bool",
            "mod_tree_less(struct latch_tree_node *a, struct latch_tree_node *b)",
            "{",
            "\treturn __mod_tree_val(a) < __mod_tree_val(b);",
            "}",
            "static __always_inline int",
            "mod_tree_comp(void *key, struct latch_tree_node *n)",
            "{",
            "\tunsigned long val = (unsigned long)key;",
            "\tunsigned long start, end;",
            "",
            "\tstart = __mod_tree_val(n);",
            "\tif (val < start)",
            "\t\treturn -1;",
            "",
            "\tend = start + __mod_tree_size(n);",
            "\tif (val >= end)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static noinline void __mod_tree_insert(struct mod_tree_node *node, struct mod_tree_root *tree)",
            "{",
            "\tlatch_tree_insert(&node->node, &tree->root, &mod_tree_ops);",
            "}",
            "static void __mod_tree_remove(struct mod_tree_node *node, struct mod_tree_root *tree)",
            "{",
            "\tlatch_tree_erase(&node->node, &tree->root, &mod_tree_ops);",
            "}",
            "void mod_tree_insert(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tmod->mem[type].mtn.mod = mod;",
            "\t\tif (mod->mem[type].size)",
            "\t\t\t__mod_tree_insert(&mod->mem[type].mtn, &mod_tree);",
            "\t}",
            "}",
            "void mod_tree_remove_init(struct module *mod)",
            "{",
            "\tfor_class_mod_mem_type(type, init) {",
            "\t\tif (mod->mem[type].size)",
            "\t\t\t__mod_tree_remove(&mod->mem[type].mtn, &mod_tree);",
            "\t}",
            "}",
            "void mod_tree_remove(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tif (mod->mem[type].size)",
            "\t\t\t__mod_tree_remove(&mod->mem[type].mtn, &mod_tree);",
            "\t}",
            "}"
          ],
          "function_name": "__mod_tree_val, __mod_tree_size, mod_tree_less, mod_tree_comp, __mod_tree_insert, __mod_tree_remove, mod_tree_insert, mod_tree_remove_init, mod_tree_remove",
          "description": "实现模块内存区域的树状管理逻辑，包含节点值/大小提取、比较函数及插入/删除操作，通过latch_tree接口维护模块地址映射表，支持模块加载时插入和卸载时移除内存节点",
          "similarity": 0.5185220837593079
        }
      ]
    }
  ]
}