{
  "query": "hrtimer在系统时间更新中的作用",
  "timestamp": "2025-12-26 02:18:22",
  "retrieved_files": [
    {
      "source_file": "kernel/time/hrtimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:38:33\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\hrtimer.c`\n\n---\n\n# `time/hrtimer.c` 技术文档\n\n## 1. 文件概述\n\n`time/hrtimer.c` 是 Linux 内核中高分辨率定时器（High-Resolution Timer, hrtimer）的核心实现文件。该模块提供了比传统低分辨率定时器（基于 timer wheel）更高精度和更准确的定时能力，适用于需要纳秒级精度的场景，如 POSIX 定时器、高精度睡眠、实时调度等。hrtimer 的精度依赖于底层硬件时钟事件设备（clockevent）的能力，并支持动态切换高/低分辨率模式。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct hrtimer_cpu_base`**  \n  每个 CPU 私有的 hrtimer 基础结构，包含多个时钟基准（clock_base）和全局锁，用于管理该 CPU 上所有 hrtimer 实例。\n\n- **`struct hrtimer_clock_base`**  \n  表示一个特定时钟源（如 `CLOCK_MONOTONIC`、`CLOCK_REALTIME` 等）的定时器基准，包含红黑树（rbtree）用于高效管理到期事件。\n\n- **`hrtimer_bases`（per-CPU 变量）**  \n  定义了每个 CPU 的 hrtimer 基础结构，初始化了 8 个 clock_base（4 个硬中断上下文 + 4 个软中断上下文），分别对应不同的 POSIX 时钟 ID。\n\n- **`migration_cpu_base`**  \n  SMP 系统中用于定时器迁移的临时占位结构，确保在跨 CPU 迁移过程中定时器状态的一致性。\n\n### 主要函数/宏\n\n- **`lock_hrtimer_base()`**  \n  安全获取定时器所属 clock_base 的自旋锁，处理 SMP 环境下定时器可能正在迁移的情况。\n\n- **`switch_hrtimer_base()`**  \n  将定时器迁移到目标 CPU 的对应 clock_base，用于负载均衡或 NO_HZ（动态滴答）优化。\n\n- **`get_target_base()`**  \n  根据当前 CPU 状态、NO_HZ 配置和 `pinned` 标志，选择最优的目标 CPU 作为定时器归属。\n\n- **`hrtimer_suitable_target()`**  \n  判断目标 CPU 是否适合作为定时器的新归属，考虑其下一次事件时间和 CPU 在线状态。\n\n- **`hrtimer_clock_to_base_table[]`**  \n  将 POSIX 时钟 ID（如 `CLOCK_MONOTONIC`）映射到内核内部的 `hrtimer_base_type` 枚举值。\n\n- **`HRTIMER_ACTIVE_HARD / SOFT / ALL`**  \n  位掩码宏，用于区分硬中断上下文和软中断上下文的活跃定时器集合。\n\n## 3. 关键实现\n\n### 高分辨率定时器基础架构\n\n- 每个 CPU 拥有独立的 `hrtimer_cpu_base`，包含多个 `clock_base`，每个对应一个 POSIX 时钟源。\n- 定时器按到期时间组织在红黑树中，确保 O(log n) 的插入/删除/查找性能。\n- 支持硬中断（hardirq）和软中断（softirq）两种上下文的定时器，通过 `_SOFT` 后缀的 base 区分。\n\n### 定时器迁移机制（SMP）\n\n- 在 SMP 系统中，为支持 NO_HZ 和负载均衡，hrtimer 可动态迁移到其他 CPU。\n- 使用 `migration_base` 作为迁移过程中的临时占位符，避免在迁移过程中出现空悬指针。\n- `lock_hrtimer_base()` 采用乐观重试机制：先读取 `timer->base`，加锁后再次验证，若不一致则重试。\n\n### 目标 CPU 选择策略\n\n- 若当前 CPU 离线，则选择 `housekeeping_cpumask` 中任意在线 CPU。\n- 若启用 `timers_migration_enabled` 且未设置 `pinned`，则使用 `get_nohz_timer_target()` 选择节能目标 CPU。\n- 通过 `hrtimer_suitable_target()` 避免将即将到期的定时器迁移到远端 CPU，防止因 IPI 延迟错过截止时间。\n\n### 锁与并发控制\n\n- 每个 `hrtimer_cpu_base` 使用 raw spinlock 保护其所有 `clock_base`。\n- 定时器操作（如 enqueue/dequeue）必须在持有对应 base 锁的情况下进行。\n- 迁移过程中通过原子读写 `timer->base` 和锁验证保证内存一致性。\n\n## 4. 依赖关系\n\n- **硬件抽象层**：依赖 `clocksource` 和 `clockevent` 子系统提供高精度时间源和事件触发能力。\n- **调度子系统**：与 `sched/` 目录下的实时调度（`rt.c`）、截止时间调度（`deadline.c`）和 NO_HZ（`nohz.c`）紧密集成。\n- **中断子系统**：通过 `tick-internal.h` 与 tick 管理模块交互，控制周期性滴答的启停。\n- **调试与追踪**：集成 `debugobjects` 用于对象生命周期检查，`trace/events/timer.h` 提供 ftrace 事件。\n- **系统调用**：为 `sys_nanosleep`、`timer_create` 等 POSIX 接口提供底层支持。\n- **CPU 热插拔**：通过 `CONFIG_HOTPLUG_CPU` 支持 CPU 在线/离线时的定时器迁移。\n\n## 5. 使用场景\n\n- **高精度睡眠**：`nanosleep()`、`clock_nanosleep()` 等系统调用依赖 hrtimer 实现纳秒级睡眠。\n- **POSIX 定时器**：用户空间通过 `timer_create()` 创建的定时器由 hrtimer 驱动。\n- **内核定时任务**：如 RCU 宽限期检测、网络协议栈超时、块设备 I/O 超时等需要高精度定时的子系统。\n- **实时系统**：配合 `SCHED_FIFO`/`SCHED_RR` 或 `SCHED_DEADLINE` 调度策略，提供确定性定时行为。\n- **动态滴答（NO_HZ）**：在空闲 CPU 上停止周期性 tick，仅靠 hrtimer 触发下一次事件，降低功耗。\n- **定时器迁移**：在多核系统中将定时器集中到少数 CPU，使其他 CPU 进入深度睡眠状态，提升能效。",
      "similarity": 0.6533807516098022,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/time/hrtimer.c",
          "start_line": 624,
          "end_line": 737,
          "content": [
            "static ktime_t hrtimer_update_next_event(struct hrtimer_cpu_base *cpu_base)",
            "{",
            "\tktime_t expires_next, soft = KTIME_MAX;",
            "",
            "\t/*",
            "\t * If the soft interrupt has already been activated, ignore the",
            "\t * soft bases. They will be handled in the already raised soft",
            "\t * interrupt.",
            "\t */",
            "\tif (!cpu_base->softirq_activated) {",
            "\t\tsoft = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);",
            "\t\t/*",
            "\t\t * Update the soft expiry time. clock_settime() might have",
            "\t\t * affected it.",
            "\t\t */",
            "\t\tcpu_base->softirq_expires_next = soft;",
            "\t}",
            "",
            "\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_HARD);",
            "\t/*",
            "\t * If a softirq timer is expiring first, update cpu_base->next_timer",
            "\t * and program the hardware with the soft expiry time.",
            "\t */",
            "\tif (expires_next > soft) {",
            "\t\tcpu_base->next_timer = cpu_base->softirq_next_timer;",
            "\t\texpires_next = soft;",
            "\t}",
            "",
            "\treturn expires_next;",
            "}",
            "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)",
            "{",
            "\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;",
            "\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;",
            "\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;",
            "",
            "\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,",
            "\t\t\t\t\t    offs_real, offs_boot, offs_tai);",
            "",
            "\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;",
            "\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;",
            "\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;",
            "",
            "\treturn now;",
            "}",
            "static inline int hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)",
            "{",
            "\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?",
            "\t\tcpu_base->hres_active : 0;",
            "}",
            "static void __hrtimer_reprogram(struct hrtimer_cpu_base *cpu_base,",
            "\t\t\t\tstruct hrtimer *next_timer,",
            "\t\t\t\tktime_t expires_next)",
            "{",
            "\tcpu_base->expires_next = expires_next;",
            "",
            "\t/*",
            "\t * If hres is not active, hardware does not have to be",
            "\t * reprogrammed yet.",
            "\t *",
            "\t * If a hang was detected in the last timer interrupt then we",
            "\t * leave the hang delay active in the hardware. We want the",
            "\t * system to make progress. That also prevents the following",
            "\t * scenario:",
            "\t * T1 expires 50ms from now",
            "\t * T2 expires 5s from now",
            "\t *",
            "\t * T1 is removed, so this code is called and would reprogram",
            "\t * the hardware to 5s from now. Any hrtimer_start after that",
            "\t * will not reprogram the hardware due to hang_detected being",
            "\t * set. So we'd effectively block all timers until the T2 event",
            "\t * fires.",
            "\t */",
            "\tif (!hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)",
            "\t\treturn;",
            "",
            "\ttick_program_event(expires_next, 1);",
            "}",
            "static void",
            "hrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)",
            "{",
            "\tktime_t expires_next;",
            "",
            "\texpires_next = hrtimer_update_next_event(cpu_base);",
            "",
            "\tif (skip_equal && expires_next == cpu_base->expires_next)",
            "\t\treturn;",
            "",
            "\t__hrtimer_reprogram(cpu_base, cpu_base->next_timer, expires_next);",
            "}",
            "static int __init setup_hrtimer_hres(char *str)",
            "{",
            "\treturn (kstrtobool(str, &hrtimer_hres_enabled) == 0);",
            "}",
            "static inline int hrtimer_is_hres_enabled(void)",
            "{",
            "\treturn hrtimer_hres_enabled;",
            "}",
            "static void hrtimer_switch_to_hres(void)",
            "{",
            "\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);",
            "",
            "\tif (tick_init_highres()) {",
            "\t\tpr_warn(\"Could not switch to high resolution mode on CPU %u\\n\",",
            "\t\t\tbase->cpu);",
            "\t\treturn;",
            "\t}",
            "\tbase->hres_active = 1;",
            "\thrtimer_resolution = HIGH_RES_NSEC;",
            "",
            "\ttick_setup_sched_timer();",
            "\t/* \"Retrigger\" the interrupt to get things going */",
            "\tretrigger_next_event(NULL);",
            "}"
          ],
          "function_name": "hrtimer_update_next_event, hrtimer_update_base, hrtimer_hres_active, __hrtimer_reprogram, hrtimer_force_reprogram, setup_hrtimer_hres, hrtimer_is_hres_enabled, hrtimer_switch_to_hres",
          "description": "实现高精度模式下的事件更新逻辑(hrtimer_update_next_event)，维护时钟偏移更新(hrtimer_update_base)，控制硬件定时器重编程(__hrtimer_reprogram)，并提供高精度模式开关(setup_hrtimer_hres/hrtimer_switch_to_hres)。",
          "similarity": 0.6738545298576355
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/time/hrtimer.c",
          "start_line": 777,
          "end_line": 928,
          "content": [
            "static inline int hrtimer_is_hres_enabled(void) { return 0; }",
            "static inline void hrtimer_switch_to_hres(void) { }",
            "static void retrigger_next_event(void *arg)",
            "{",
            "\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);",
            "",
            "\t/*",
            "\t * When high resolution mode or nohz is active, then the offsets of",
            "\t * CLOCK_REALTIME/TAI/BOOTTIME have to be updated. Otherwise the",
            "\t * next tick will take care of that.",
            "\t *",
            "\t * If high resolution mode is active then the next expiring timer",
            "\t * must be reevaluated and the clock event device reprogrammed if",
            "\t * necessary.",
            "\t *",
            "\t * In the NOHZ case the update of the offset and the reevaluation",
            "\t * of the next expiring timer is enough. The return from the SMP",
            "\t * function call will take care of the reprogramming in case the",
            "\t * CPU was in a NOHZ idle sleep.",
            "\t *",
            "\t * In periodic low resolution mode, the next softirq expiration",
            "\t * must also be updated.",
            "\t */",
            "\traw_spin_lock(&base->lock);",
            "\thrtimer_update_base(base);",
            "\tif (hrtimer_hres_active(base))",
            "\t\thrtimer_force_reprogram(base, 0);",
            "\telse",
            "\t\thrtimer_update_next_event(base);",
            "\traw_spin_unlock(&base->lock);",
            "}",
            "static void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)",
            "{",
            "\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);",
            "\tstruct hrtimer_clock_base *base = timer->base;",
            "\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);",
            "",
            "\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);",
            "",
            "\t/*",
            "\t * CLOCK_REALTIME timer might be requested with an absolute",
            "\t * expiry time which is less than base->offset. Set it to 0.",
            "\t */",
            "\tif (expires < 0)",
            "\t\texpires = 0;",
            "",
            "\tif (timer->is_soft) {",
            "\t\t/*",
            "\t\t * soft hrtimer could be started on a remote CPU. In this",
            "\t\t * case softirq_expires_next needs to be updated on the",
            "\t\t * remote CPU. The soft hrtimer will not expire before the",
            "\t\t * first hard hrtimer on the remote CPU -",
            "\t\t * hrtimer_check_target() prevents this case.",
            "\t\t */",
            "\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;",
            "",
            "\t\tif (timer_cpu_base->softirq_activated)",
            "\t\t\treturn;",
            "",
            "\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))",
            "\t\t\treturn;",
            "",
            "\t\ttimer_cpu_base->softirq_next_timer = timer;",
            "\t\ttimer_cpu_base->softirq_expires_next = expires;",
            "",
            "\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||",
            "\t\t    !reprogram)",
            "\t\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * If the timer is not on the current cpu, we cannot reprogram",
            "\t * the other cpus clock event device.",
            "\t */",
            "\tif (base->cpu_base != cpu_base)",
            "\t\treturn;",
            "",
            "\tif (expires >= cpu_base->expires_next)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * If the hrtimer interrupt is running, then it will reevaluate the",
            "\t * clock bases and reprogram the clock event device.",
            "\t */",
            "\tif (cpu_base->in_hrtirq)",
            "\t\treturn;",
            "",
            "\tcpu_base->next_timer = timer;",
            "",
            "\t__hrtimer_reprogram(cpu_base, timer, expires);",
            "}",
            "static bool update_needs_ipi(struct hrtimer_cpu_base *cpu_base,",
            "\t\t\t     unsigned int active)",
            "{",
            "\tstruct hrtimer_clock_base *base;",
            "\tunsigned int seq;",
            "\tktime_t expires;",
            "",
            "\t/*",
            "\t * Update the base offsets unconditionally so the following",
            "\t * checks whether the SMP function call is required works.",
            "\t *",
            "\t * The update is safe even when the remote CPU is in the hrtimer",
            "\t * interrupt or the hrtimer soft interrupt and expiring affected",
            "\t * bases. Either it will see the update before handling a base or",
            "\t * it will see it when it finishes the processing and reevaluates",
            "\t * the next expiring timer.",
            "\t */",
            "\tseq = cpu_base->clock_was_set_seq;",
            "\thrtimer_update_base(cpu_base);",
            "",
            "\t/*",
            "\t * If the sequence did not change over the update then the",
            "\t * remote CPU already handled it.",
            "\t */",
            "\tif (seq == cpu_base->clock_was_set_seq)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * If the remote CPU is currently handling an hrtimer interrupt, it",
            "\t * will reevaluate the first expiring timer of all clock bases",
            "\t * before reprogramming. Nothing to do here.",
            "\t */",
            "\tif (cpu_base->in_hrtirq)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Walk the affected clock bases and check whether the first expiring",
            "\t * timer in a clock base is moving ahead of the first expiring timer of",
            "\t * @cpu_base. If so, the IPI must be invoked because per CPU clock",
            "\t * event devices cannot be remotely reprogrammed.",
            "\t */",
            "\tactive &= cpu_base->active_bases;",
            "",
            "\tfor_each_active_base(base, cpu_base, active) {",
            "\t\tstruct timerqueue_node *next;",
            "",
            "\t\tnext = timerqueue_getnext(&base->active);",
            "\t\texpires = ktime_sub(next->expires, base->offset);",
            "\t\tif (expires < cpu_base->expires_next)",
            "\t\t\treturn true;",
            "",
            "\t\t/* Extra check for softirq clock bases */",
            "\t\tif (base->clockid < HRTIMER_BASE_MONOTONIC_SOFT)",
            "\t\t\tcontinue;",
            "\t\tif (cpu_base->softirq_activated)",
            "\t\t\tcontinue;",
            "\t\tif (expires < cpu_base->softirq_expires_next)",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}"
          ],
          "function_name": "hrtimer_is_hres_enabled, hrtimer_switch_to_hres, retrigger_next_event, hrtimer_reprogram, update_needs_ipi",
          "description": "实现高精度模式状态查询(hrtimer_is_hres_enabled)，通过retrigger_next_event触发事件重评估，hrtimer_reprogram执行定时器重编程，update_needs_ipi判断是否需要跨CPU中断同步。",
          "similarity": 0.6646291017532349
        },
        {
          "chunk_id": 13,
          "file_path": "kernel/time/hrtimer.c",
          "start_line": 2081,
          "end_line": 2185,
          "content": [
            "static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)",
            "{",
            "\tstruct restart_block *restart;",
            "",
            "\tdo {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE);",
            "\t\thrtimer_sleeper_start_expires(t, mode);",
            "",
            "\t\tif (likely(t->task))",
            "\t\t\tschedule();",
            "",
            "\t\thrtimer_cancel(&t->timer);",
            "\t\tmode = HRTIMER_MODE_ABS;",
            "",
            "\t} while (t->task && !signal_pending(current));",
            "",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tif (!t->task)",
            "\t\treturn 0;",
            "",
            "\trestart = &current->restart_block;",
            "\tif (restart->nanosleep.type != TT_NONE) {",
            "\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);",
            "\t\tstruct timespec64 rmt;",
            "",
            "\t\tif (rem <= 0)",
            "\t\t\treturn 0;",
            "\t\trmt = ktime_to_timespec64(rem);",
            "",
            "\t\treturn nanosleep_copyout(restart, &rmt);",
            "\t}",
            "\treturn -ERESTART_RESTARTBLOCK;",
            "}",
            "static long __sched hrtimer_nanosleep_restart(struct restart_block *restart)",
            "{",
            "\tstruct hrtimer_sleeper t;",
            "\tint ret;",
            "",
            "\thrtimer_init_sleeper_on_stack(&t, restart->nanosleep.clockid,",
            "\t\t\t\t      HRTIMER_MODE_ABS);",
            "\thrtimer_set_expires_tv64(&t.timer, restart->nanosleep.expires);",
            "\tret = do_nanosleep(&t, HRTIMER_MODE_ABS);",
            "\tdestroy_hrtimer_on_stack(&t.timer);",
            "\treturn ret;",
            "}",
            "long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,",
            "\t\t       const clockid_t clockid)",
            "{",
            "\tstruct restart_block *restart;",
            "\tstruct hrtimer_sleeper t;",
            "\tint ret = 0;",
            "",
            "\thrtimer_init_sleeper_on_stack(&t, clockid, mode);",
            "\thrtimer_set_expires_range_ns(&t.timer, rqtp, current->timer_slack_ns);",
            "\tret = do_nanosleep(&t, mode);",
            "\tif (ret != -ERESTART_RESTARTBLOCK)",
            "\t\tgoto out;",
            "",
            "\t/* Absolute timers do not update the rmtp value and restart: */",
            "\tif (mode == HRTIMER_MODE_ABS) {",
            "\t\tret = -ERESTARTNOHAND;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\trestart = &current->restart_block;",
            "\trestart->nanosleep.clockid = t.timer.base->clockid;",
            "\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);",
            "\tset_restart_fn(restart, hrtimer_nanosleep_restart);",
            "out:",
            "\tdestroy_hrtimer_on_stack(&t.timer);",
            "\treturn ret;",
            "}",
            "int hrtimers_prepare_cpu(unsigned int cpu)",
            "{",
            "\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);",
            "\tint i;",
            "",
            "\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {",
            "\t\tstruct hrtimer_clock_base *clock_b = &cpu_base->clock_base[i];",
            "",
            "\t\tclock_b->cpu_base = cpu_base;",
            "\t\tseqcount_raw_spinlock_init(&clock_b->seq, &cpu_base->lock);",
            "\t\ttimerqueue_init_head(&clock_b->active);",
            "\t}",
            "",
            "\tcpu_base->cpu = cpu;",
            "\thrtimer_cpu_base_init_expiry_lock(cpu_base);",
            "\treturn 0;",
            "}",
            "int hrtimers_cpu_starting(unsigned int cpu)",
            "{",
            "\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);",
            "",
            "\t/* Clear out any left over state from a CPU down operation */",
            "\tcpu_base->active_bases = 0;",
            "\tcpu_base->hres_active = 0;",
            "\tcpu_base->hang_detected = 0;",
            "\tcpu_base->next_timer = NULL;",
            "\tcpu_base->softirq_next_timer = NULL;",
            "\tcpu_base->expires_next = KTIME_MAX;",
            "\tcpu_base->softirq_expires_next = KTIME_MAX;",
            "\tcpu_base->online = 1;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "do_nanosleep, hrtimer_nanosleep_restart, hrtimer_nanosleep, hrtimers_prepare_cpu, hrtimers_cpu_starting",
          "description": "实现纳秒级休眠的核心逻辑，通过hrtimer_sleeper结构体跟踪睡眠状态，处理任务调度和中断重启，包含CPU初始化及启动时的定时器基础设施设置。",
          "similarity": 0.6524187326431274
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/time/hrtimer.c",
          "start_line": 1940,
          "end_line": 2055,
          "content": [
            "void hrtimer_run_queues(void)",
            "{",
            "\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);",
            "\tunsigned long flags;",
            "\tktime_t now;",
            "",
            "\tif (hrtimer_hres_active(cpu_base))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This _is_ ugly: We have to check periodically, whether we",
            "\t * can switch to highres and / or nohz mode. The clocksource",
            "\t * switch happens with xtime_lock held. Notification from",
            "\t * there only sets the check bit in the tick_oneshot code,",
            "\t * otherwise we might deadlock vs. xtime_lock.",
            "\t */",
            "\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {",
            "\t\thrtimer_switch_to_hres();",
            "\t\treturn;",
            "\t}",
            "",
            "\traw_spin_lock_irqsave(&cpu_base->lock, flags);",
            "\tnow = hrtimer_update_base(cpu_base);",
            "",
            "\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {",
            "\t\tcpu_base->softirq_expires_next = KTIME_MAX;",
            "\t\tcpu_base->softirq_activated = 1;",
            "\t\traise_timer_softirq(HRTIMER_SOFTIRQ);",
            "\t}",
            "",
            "\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);",
            "\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);",
            "}",
            "static enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer)",
            "{",
            "\tstruct hrtimer_sleeper *t =",
            "\t\tcontainer_of(timer, struct hrtimer_sleeper, timer);",
            "\tstruct task_struct *task = t->task;",
            "",
            "\tt->task = NULL;",
            "\tif (task)",
            "\t\twake_up_process(task);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}",
            "void hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,",
            "\t\t\t\t   enum hrtimer_mode mode)",
            "{",
            "\t/*",
            "\t * Make the enqueue delivery mode check work on RT. If the sleeper",
            "\t * was initialized for hard interrupt delivery, force the mode bit.",
            "\t * This is a special case for hrtimer_sleepers because",
            "\t * hrtimer_init_sleeper() determines the delivery mode on RT so the",
            "\t * fiddling with this decision is avoided at the call sites.",
            "\t */",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && sl->timer.is_hard)",
            "\t\tmode |= HRTIMER_MODE_HARD;",
            "",
            "\thrtimer_start_expires(&sl->timer, mode);",
            "}",
            "static void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,",
            "\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)",
            "{",
            "\t/*",
            "\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly",
            "\t * marked for hard interrupt expiry mode are moved into soft",
            "\t * interrupt context either for latency reasons or because the",
            "\t * hrtimer callback takes regular spinlocks or invokes other",
            "\t * functions which are not suitable for hard interrupt context on",
            "\t * PREEMPT_RT.",
            "\t *",
            "\t * The hrtimer_sleeper callback is RT compatible in hard interrupt",
            "\t * context, but there is a latency concern: Untrusted userspace can",
            "\t * spawn many threads which arm timers for the same expiry time on",
            "\t * the same CPU. That causes a latency spike due to the wakeup of",
            "\t * a gazillion threads.",
            "\t *",
            "\t * OTOH, privileged real-time user space applications rely on the",
            "\t * low latency of hard interrupt wakeups. If the current task is in",
            "\t * a real-time scheduling class, mark the mode for hard interrupt",
            "\t * expiry.",
            "\t */",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\tif (rt_or_dl_task_policy(current) && !(mode & HRTIMER_MODE_SOFT))",
            "\t\t\tmode |= HRTIMER_MODE_HARD;",
            "\t}",
            "",
            "\t__hrtimer_init(&sl->timer, clock_id, mode);",
            "\tsl->timer.function = hrtimer_wakeup;",
            "\tsl->task = current;",
            "}",
            "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,",
            "\t\t\t  enum hrtimer_mode mode)",
            "{",
            "\tdebug_init(&sl->timer, clock_id, mode);",
            "\t__hrtimer_init_sleeper(sl, clock_id, mode);",
            "",
            "}",
            "int nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)",
            "{",
            "\tswitch(restart->nanosleep.type) {",
            "#ifdef CONFIG_COMPAT_32BIT_TIME",
            "\tcase TT_COMPAT:",
            "\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))",
            "\t\t\treturn -EFAULT;",
            "\t\tbreak;",
            "#endif",
            "\tcase TT_NATIVE:",
            "\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))",
            "\t\t\treturn -EFAULT;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "\treturn -ERESTART_RESTARTBLOCK;",
            "}"
          ],
          "function_name": "hrtimer_run_queues, hrtimer_wakeup, hrtimer_sleeper_start_expires, __hrtimer_init_sleeper, hrtimer_init_sleeper, nanosleep_copyout",
          "description": "管理睡眠定时器的初始化与唤醒，通过hrtimer_sleeper结构体实现睡眠超时检测，支持硬中断上下文唤醒，并提供纳秒级休眠的参数复制功能。",
          "similarity": 0.6462470293045044
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/time/hrtimer.c",
          "start_line": 968,
          "end_line": 1070,
          "content": [
            "void clock_was_set(unsigned int bases)",
            "{",
            "\tstruct hrtimer_cpu_base *cpu_base = raw_cpu_ptr(&hrtimer_bases);",
            "\tcpumask_var_t mask;",
            "\tint cpu;",
            "",
            "\tif (!hrtimer_hres_active(cpu_base) && !tick_nohz_active)",
            "\t\tgoto out_timerfd;",
            "",
            "\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL)) {",
            "\t\ton_each_cpu(retrigger_next_event, NULL, 1);",
            "\t\tgoto out_timerfd;",
            "\t}",
            "",
            "\t/* Avoid interrupting CPUs if possible */",
            "\tcpus_read_lock();",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tunsigned long flags;",
            "",
            "\t\tcpu_base = &per_cpu(hrtimer_bases, cpu);",
            "\t\traw_spin_lock_irqsave(&cpu_base->lock, flags);",
            "",
            "\t\tif (update_needs_ipi(cpu_base, bases))",
            "\t\t\tcpumask_set_cpu(cpu, mask);",
            "",
            "\t\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);",
            "\t}",
            "",
            "\tpreempt_disable();",
            "\tsmp_call_function_many(mask, retrigger_next_event, NULL, 1);",
            "\tpreempt_enable();",
            "\tcpus_read_unlock();",
            "\tfree_cpumask_var(mask);",
            "",
            "out_timerfd:",
            "\ttimerfd_clock_was_set();",
            "}",
            "static void clock_was_set_work(struct work_struct *work)",
            "{",
            "\tclock_was_set(CLOCK_SET_WALL);",
            "}",
            "void clock_was_set_delayed(void)",
            "{",
            "\tschedule_work(&hrtimer_work);",
            "}",
            "void hrtimers_resume_local(void)",
            "{",
            "\tlockdep_assert_irqs_disabled();",
            "\t/* Retrigger on the local CPU */",
            "\tretrigger_next_event(NULL);",
            "}",
            "static inline",
            "void unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)",
            "\t__releases(&timer->base->cpu_base->lock)",
            "{",
            "\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);",
            "}",
            "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)",
            "{",
            "\tu64 orun = 1;",
            "\tktime_t delta;",
            "",
            "\tdelta = ktime_sub(now, hrtimer_get_expires(timer));",
            "",
            "\tif (delta < 0)",
            "\t\treturn 0;",
            "",
            "\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))",
            "\t\treturn 0;",
            "",
            "\tif (interval < hrtimer_resolution)",
            "\t\tinterval = hrtimer_resolution;",
            "",
            "\tif (unlikely(delta >= interval)) {",
            "\t\ts64 incr = ktime_to_ns(interval);",
            "",
            "\t\torun = ktime_divns(delta, incr);",
            "\t\thrtimer_add_expires_ns(timer, incr * orun);",
            "\t\tif (hrtimer_get_expires_tv64(timer) > now)",
            "\t\t\treturn orun;",
            "\t\t/*",
            "\t\t * This (and the ktime_add() below) is the",
            "\t\t * correction for exact:",
            "\t\t */",
            "\t\torun++;",
            "\t}",
            "\thrtimer_add_expires(timer, interval);",
            "",
            "\treturn orun;",
            "}",
            "static bool enqueue_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base,",
            "\t\t\t    enum hrtimer_mode mode)",
            "{",
            "\tdebug_activate(timer, mode);",
            "\tWARN_ON_ONCE(!base->cpu_base->online);",
            "",
            "\tbase->cpu_base->active_bases |= 1 << base->index;",
            "",
            "\t/* Pairs with the lockless read in hrtimer_is_queued() */",
            "\tWRITE_ONCE(timer->state, HRTIMER_STATE_ENQUEUED);",
            "",
            "\treturn timerqueue_add(&base->active, &timer->node);",
            "}"
          ],
          "function_name": "clock_was_set, clock_was_set_work, clock_was_set_delayed, hrtimers_resume_local, unlock_hrtimer_base, hrtimer_forward, enqueue_hrtimer",
          "description": "处理系统时钟更改时触发的高精度定时器重新编程，遍历所有CPU更新活动定时器并调度事件，通过smp_call_function_many通知远程CPU重新触发下一事件，同时调用timerfd_clock_was_set更新时间相关接口",
          "similarity": 0.6187866926193237
        }
      ]
    },
    {
      "source_file": "kernel/time/tick-broadcast-hrtimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:47:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\tick-broadcast-hrtimer.c`\n\n---\n\n# `time/tick-broadcast-hrtimer.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了基于高分辨率定时器（hrtimer）的广播时钟事件设备（tick broadcast device）模拟机制。在某些系统（如无本地 APIC 或本地时钟事件设备不支持唤醒 CPU 的平台）中，当 CPU 进入深度空闲状态时，无法接收本地定时器中断，此时需要一个全局的“广播”定时器来代替本地时钟事件设备，在需要时唤醒所有等待广播事件的 CPU。本文件通过一个全局的 hrtimer 实例，模拟出一个虚拟的广播时钟事件设备，用于在单 CPU 或多 CPU 系统中提供统一的广播定时服务。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`bctimer`**：全局静态的 `hrtimer` 实例，作为广播定时器的核心实现。\n- **`ce_broadcast_hrtimer`**：`clock_event_device` 类型的结构体，代表一个虚拟的广播时钟事件设备，注册到内核时钟事件子系统中。\n\n### 主要函数\n\n- **`bc_shutdown()`**：实现广播设备的关闭操作，调用 `hrtimer_try_to_cancel()` 尝试取消定时器，避免死锁。\n- **`bc_set_next()`**：设置下一次广播事件的到期时间，调用 `hrtimer_start()` 启动高分辨率定时器，并更新设备绑定的 CPU（`bound_on` 字段）。\n- **`bc_handler()`**：hrtimer 到期时的回调函数，触发广播设备的事件处理函数（`event_handler`），进而调用通用的广播处理逻辑（如 `tick_handle_oneshot_broadcast()`）。\n- **`tick_setup_hrtimer_broadcast()`**：初始化广播 hrtimer 并注册虚拟时钟事件设备到内核。\n\n## 3. 关键实现\n\n- **避免死锁的设计**：  \n  在 `bc_shutdown()` 和 `bc_set_next()` 中，均避免直接调用 `hrtimer_cancel()`，因为该函数可能等待回调执行完毕，而回调函数（`bc_handler`）内部会尝试获取 `tick_broadcast_lock`，若调用者已持有该锁，则会导致死锁。因此使用非阻塞的 `hrtimer_try_to_cancel()`。\n\n- **CPU 绑定机制**：  \n  `bc_set_next()` 在启动 hrtimer 时使用 `HRTIMER_MODE_ABS_PINNED_HARD` 模式，确保定时器在当前 CPU 上执行（若回调未运行）。随后通过读取 `bctimer.base->cpu_base->cpu` 设置 `ce_broadcast_hrtimer.bound_on`，告知 tick 广播子系统该广播定时器当前绑定在哪个 CPU 上，防止该 CPU 进入无法被唤醒的深度空闲状态。\n\n- **线程安全性**：  \n  所有对 `bctimer` 的操作（如 `hrtimer_start` 和 `hrtimer_try_to_cancel`）均在持有 `tick_broadcast_lock` 的上下文中执行，保证了对广播设备状态修改的原子性。同时，由于该锁的存在，`bound_on` 的读取无需额外加锁。\n\n- **事件分发**：  \n  hrtimer 到期后，`bc_handler()` 调用 `ce_broadcast_hrtimer.event_handler()`，该回调由 tick 广播子系统在注册设备时设置（通常指向 `tick_handle_oneshot_broadcast`），负责唤醒所有等待广播事件的 CPU 并处理 pending 的 tick。\n\n## 4. 依赖关系\n\n- **`<linux/hrtimer.h>`**：依赖高分辨率定时器子系统，用于实现精确的单次广播事件。\n- **`<linux/clockchips.h>`**：依赖时钟事件设备框架，用于注册虚拟的广播设备。\n- **`\"tick-internal.h\"`**：依赖内核 tick 管理内部接口，特别是广播 tick 相关的锁和处理函数。\n- **`tick-broadcast.c`**：与通用 tick 广播逻辑紧密耦合，本设备作为其后备实现之一，由 `tick_broadcast_setup_hrtimer()` 调用 `tick_setup_hrtimer_broadcast()` 进行初始化。\n\n## 5. 使用场景\n\n- **无本地时钟事件设备的系统**：在某些嵌入式或虚拟化环境中，CPU 可能缺乏支持唤醒的本地定时器，此时必须依赖广播机制维持系统 tick。\n- **深度 C-state 电源管理**：当 CPU 进入 C3 或更深的空闲状态时，本地 APIC 定时器可能被关闭，需由广播设备代替其功能。\n- **单 CPU 系统的简化实现**：在单核系统中，可直接使用此 hrtimer 广播设备作为 tick 源，无需复杂的多 CPU 同步逻辑。\n- **作为通用广播后备方案**：当系统未配置硬件广播设备（如 HPET 或 IO-APIC）时，内核可回退到此基于 hrtimer 的软件实现。",
      "similarity": 0.6398849487304688,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/tick-broadcast-hrtimer.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Emulate a local clock event device via a pseudo clock device.",
            " */",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/clockchips.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "",
            "#include \"tick-internal.h\"",
            "",
            "static struct hrtimer bctimer;",
            ""
          ],
          "function_name": null,
          "description": "定义用于广播式高精度定时器的全局hrtimer结构体实例，作为伪时钟设备实现基础",
          "similarity": 0.6254692077636719
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/tick-broadcast-hrtimer.c",
          "start_line": 20,
          "end_line": 81,
          "content": [
            "static int bc_shutdown(struct clock_event_device *evt)",
            "{",
            "\t/*",
            "\t * Note, we cannot cancel the timer here as we might",
            "\t * run into the following live lock scenario:",
            "\t *",
            "\t * cpu 0\t\tcpu1",
            "\t * lock(broadcast_lock);",
            "\t *\t\t\thrtimer_interrupt()",
            "\t *\t\t\tbc_handler()",
            "\t *\t\t\t   tick_handle_oneshot_broadcast();",
            "\t *\t\t\t    lock(broadcast_lock);",
            "\t * hrtimer_cancel()",
            "\t *  wait_for_callback()",
            "\t */",
            "\thrtimer_try_to_cancel(&bctimer);",
            "\treturn 0;",
            "}",
            "static int bc_set_next(ktime_t expires, struct clock_event_device *bc)",
            "{",
            "\t/*",
            "\t * This is called either from enter/exit idle code or from the",
            "\t * broadcast handler. In all cases tick_broadcast_lock is held.",
            "\t *",
            "\t * hrtimer_cancel() cannot be called here neither from the",
            "\t * broadcast handler nor from the enter/exit idle code. The idle",
            "\t * code can run into the problem described in bc_shutdown() and the",
            "\t * broadcast handler cannot wait for itself to complete for obvious",
            "\t * reasons.",
            "\t *",
            "\t * Each caller tries to arm the hrtimer on its own CPU, but if the",
            "\t * hrtimer callback function is currently running, then",
            "\t * hrtimer_start() cannot move it and the timer stays on the CPU on",
            "\t * which it is assigned at the moment.",
            "\t */",
            "\thrtimer_start(&bctimer, expires, HRTIMER_MODE_ABS_PINNED_HARD);",
            "\t/*",
            "\t * The core tick broadcast mode expects bc->bound_on to be set",
            "\t * correctly to prevent a CPU which has the broadcast hrtimer",
            "\t * armed from going deep idle.",
            "\t *",
            "\t * As tick_broadcast_lock is held, nothing can change the cpu",
            "\t * base which was just established in hrtimer_start() above. So",
            "\t * the below access is safe even without holding the hrtimer",
            "\t * base lock.",
            "\t */",
            "\tbc->bound_on = bctimer.base->cpu_base->cpu;",
            "",
            "\treturn 0;",
            "}",
            "static enum hrtimer_restart bc_handler(struct hrtimer *t)",
            "{",
            "\tce_broadcast_hrtimer.event_handler(&ce_broadcast_hrtimer);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}",
            "void tick_setup_hrtimer_broadcast(void)",
            "{",
            "\thrtimer_init(&bctimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);",
            "\tbctimer.function = bc_handler;",
            "\tclockevents_register_device(&ce_broadcast_hrtimer);",
            "}"
          ],
          "function_name": "bc_shutdown, bc_set_next, bc_handler, tick_setup_hrtimer_broadcast",
          "description": "实现广播定时器控制逻辑，包含关闭定时器防止死锁、设置下次超时时间、处理中断回调及初始化广播定时器设备的函数集合",
          "similarity": 0.47035542130470276
        }
      ]
    },
    {
      "source_file": "kernel/time/itimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:39:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\itimer.c`\n\n---\n\n# `time/itimer.c` 技术文档\n\n## 1. 文件概述\n\n`time/itimer.c` 是 Linux 内核中实现 POSIX 间隔定时器（interval timers，简称 itimers）的核心文件。该文件提供了对三种经典 Unix 间隔定时器的支持：\n\n- **ITIMER_REAL**：基于真实时间（墙上时钟）的定时器，到期时发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL**：基于进程用户态 CPU 时间的定时器，到期时发送 `SIGVTALRM` 信号\n- **ITIMER_PROF**：基于进程总 CPU 时间（用户态+内核态）的定时器，到期时发送 `SIGPROF` 信号\n\n该文件实现了 `getitimer()`、`setitimer()` 系统调用以及 `alarm()` 系统调用（在架构支持的情况下），为用户空间程序提供间隔定时器功能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`itimer_get_remtime()`**：获取高精度实时定时器的剩余时间\n- **`get_cpu_itimer()`**：获取 CPU 时间相关的定时器（虚拟/性能）状态\n- **`do_getitimer()`**：内部实现获取指定类型定时器状态的逻辑\n- **`put_itimerval()`**：将内核内部的 `itimerspec64` 格式转换为用户空间的 `old_itimerval` 格式\n- **`getitimer()` 系统调用**：用户空间获取定时器状态的入口\n- **`it_real_fn()`**：ITIMER_REAL 定时器到期时的回调函数\n- **`set_cpu_itimer()`**：设置 CPU 时间相关的定时器\n- **`do_setitimer()`**：内部实现设置指定类型定时器的逻辑\n- **`clear_itimer()`**：在 SELinux 环境下清除所有定时器（安全相关）\n- **`alarm_setitimer()`**：实现 `alarm()` 系统调用的内部函数\n- **`alarm()` 系统调用**：设置单次实时定时器的简化接口\n\n### 数据结构\n\n- **`struct cpu_itimer`**：存储 CPU 时间定时器的状态（在 `signal_struct` 中）\n- **`struct hrtimer`**：高精度定时器，用于实现 ITIMER_REAL\n- **`struct itimerspec64`**：64 位时间规格结构，内核内部使用\n- **`struct __kernel_old_itimerval`**：用户空间兼容的定时器值结构\n\n## 3. 关键实现\n\n### 定时器类型实现差异\n\n- **ITIMER_REAL**：使用高精度定时器（`hrtimer`）实现，基于真实时间，通过 `hrtimer_start()` 启动，到期时调用 `it_real_fn()` 发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL/ITIMER_PROF**：基于 CPU 时间采样实现，通过 `thread_group_sample_cputime()` 获取当前进程组的 CPU 时间，与设定的过期时间比较来判断是否到期\n\n### 时间精度处理\n\n- 使用纳秒级精度的 `ktime_t` 和 `timespec64` 进行内部计算\n- 用户空间接口使用微秒精度（`tv_usec`），通过 `NSEC_PER_USEC` 进行单位转换\n- 对于即将到期的定时器，返回 `TICK_NSEC`（1 微秒）作为剩余时间，避免返回 0 导致用户误判\n\n### 并发安全\n\n- 使用 `siglock` 自旋锁保护信号结构体中的定时器状态\n- ITIMER_REAL 的设置操作需要处理定时器可能正在执行的竞态条件，通过 `hrtimer_try_to_cancel()` 和重试机制确保安全\n- CPU 定时器操作在 `siglock` 保护下进行，确保线程组内的一致性\n\n### 兼容性支持\n\n- 提供 32 位兼容接口（`COMPAT_SYSCALL_DEFINE2`）\n- 支持 `alarm()` 系统调用（在 `__ARCH_WANT_SYS_ALARM` 定义时）\n- 处理 32 位系统上的时间值溢出问题（限制为 `INT_MAX`）\n\n## 4. 依赖关系\n\n### 头文件依赖\n\n- **`<linux/hrtimer.h>`**：高精度定时器框架，用于 ITIMER_REAL 实现\n- **`<linux/sched/cputime.h>`**：CPU 时间采样功能，用于虚拟和性能定时器\n- **`<linux/posix-timers.h>`**：POSIX 定时器相关定义\n- **`<linux/sched/signal.h>`**：信号处理和 `signal_struct` 结构定义\n- **`<linux/time.h>`**：时间转换和操作函数\n- **`<trace/events/timer.h>`**：定时器事件跟踪支持\n\n### 内核子系统依赖\n\n- **调度子系统**：通过 `current` 获取当前任务，使用 `thread_group_sample_cputime()` 采样 CPU 时间\n- **信号子系统**：通过 `kill_pid_info()` 发送信号，使用 `siglock` 进行同步\n- **高精度定时器子系统**：ITIMER_REAL 的底层实现依赖 hrtimer 框架\n- **安全子系统**：SELinux 相关的 `clear_itimer()` 函数\n\n## 5. 使用场景\n\n### 用户空间编程\n\n- **定时任务**：应用程序使用 `setitimer()` 设置周期性或一次性定时器\n- **超时控制**：网络编程中设置 I/O 操作超时\n- **性能监控**：使用 ITIMER_PROF 监控程序 CPU 使用情况\n- **简单定时**：使用 `alarm()` 系统调用设置简单的秒级定时器\n\n### 内核内部使用\n\n- **进程管理**：在进程退出或权限变更时清除定时器（SELinux 场景）\n- **信号处理**：定时器到期时向进程发送相应信号\n- **时间跟踪**：通过 tracepoint 记录定时器状态变化和到期事件\n- **兼容层**：为不同架构和位数提供统一的定时器接口\n\n### 系统调用路径\n\n- **`getitimer()`** → `do_getitimer()` → 对应定时器类型的具体获取函数\n- **`setitimer()`** → `do_setitimer()` → 对应定时器类型的具体设置函数  \n- **`alarm()`** → `alarm_setitimer()` → `do_setitimer(ITIMER_REAL, ...)`\n\n该文件是 Linux 内核 POSIX 定时器功能的重要组成部分，为用户空间提供了经典的 Unix 间隔定时器接口。",
      "similarity": 0.6371281147003174,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/time/itimer.c",
          "start_line": 168,
          "end_line": 275,
          "content": [
            "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   const struct itimerspec64 *const value,",
            "\t\t\t   struct itimerspec64 *const ovalue)",
            "{",
            "\tu64 oval, nval, ointerval, ninterval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tnval = timespec64_to_ns(&value->it_value);",
            "\tninterval = timespec64_to_ns(&value->it_interval);",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\toval = it->expires;",
            "\tointerval = it->incr;",
            "\tif (oval || nval) {",
            "\t\tif (nval > 0)",
            "\t\t\tnval += TICK_NSEC;",
            "\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);",
            "\t}",
            "\tit->expires = nval;",
            "\tit->incr = ninterval;",
            "\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?",
            "\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tif (ovalue) {",
            "\t\tovalue->it_value = ns_to_timespec64(oval);",
            "\t\tovalue->it_interval = ns_to_timespec64(ointerval);",
            "\t}",
            "}",
            "static int do_setitimer(int which, struct itimerspec64 *value,",
            "\t\t\tstruct itimerspec64 *ovalue)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct hrtimer *timer;",
            "\tktime_t expires;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "again:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\ttimer = &tsk->signal->real_timer;",
            "\t\tif (ovalue) {",
            "\t\t\tovalue->it_value = itimer_get_remtime(timer);",
            "\t\t\tovalue->it_interval",
            "\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\t}",
            "\t\t/* We are sharing ->siglock with it_real_fn() */",
            "\t\tif (hrtimer_try_to_cancel(timer) < 0) {",
            "\t\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\t\thrtimer_cancel_wait_running(timer);",
            "\t\t\tgoto again;",
            "\t\t}",
            "\t\texpires = timespec64_to_ktime(value->it_value);",
            "\t\tif (expires != 0) {",
            "\t\t\ttsk->signal->it_real_incr =",
            "\t\t\t\ttimespec64_to_ktime(value->it_interval);",
            "\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);",
            "\t\t} else",
            "\t\t\ttsk->signal->it_real_incr = 0;",
            "",
            "\t\ttrace_itimer_state(ITIMER_REAL, value, 0);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "void clear_itimer(void)",
            "{",
            "\tstruct itimerspec64 v = {};",
            "\tint i;",
            "",
            "\tfor (i = 0; i < 3; i++)",
            "\t\tdo_setitimer(i, &v, NULL);",
            "}",
            "static unsigned int alarm_setitimer(unsigned int seconds)",
            "{",
            "\tstruct itimerspec64 it_new, it_old;",
            "",
            "#if BITS_PER_LONG < 64",
            "\tif (seconds > INT_MAX)",
            "\t\tseconds = INT_MAX;",
            "#endif",
            "\tit_new.it_value.tv_sec = seconds;",
            "\tit_new.it_value.tv_nsec = 0;",
            "\tit_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;",
            "",
            "\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);",
            "",
            "\t/*",
            "\t * We can't return 0 if we have an alarm pending ...  And we'd",
            "\t * better return too much than too little anyway",
            "\t */",
            "\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||",
            "\t      it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))",
            "\t\tit_old.it_value.tv_sec++;",
            "",
            "\treturn it_old.it_value.tv_sec;",
            "}"
          ],
          "function_name": "set_cpu_itimer, do_setitimer, clear_itimer, alarm_setitimer",
          "description": "包含set_cpu_itimer设置CPU定时器参数、do_setitimer根据时钟类型配置定时器、clear_itimer清除所有定时器、alarm_setitimer设置一次性闹钟，其中do_setitimer处理实时时钟的启动和取消操作",
          "similarity": 0.6057105660438538
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/itimer.c",
          "start_line": 29,
          "end_line": 129,
          "content": [
            "static struct timespec64 itimer_get_remtime(struct hrtimer *timer)",
            "{",
            "\tktime_t rem = __hrtimer_get_remaining(timer, true);",
            "",
            "\t/*",
            "\t * Racy but safe: if the itimer expires after the above",
            "\t * hrtimer_get_remtime() call but before this condition",
            "\t * then we return 0 - which is correct.",
            "\t */",
            "\tif (hrtimer_active(timer)) {",
            "\t\tif (rem <= 0)",
            "\t\t\trem = NSEC_PER_USEC;",
            "\t} else",
            "\t\trem = 0;",
            "",
            "\treturn ktime_to_timespec64(rem);",
            "}",
            "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   struct itimerspec64 *const value)",
            "{",
            "\tu64 val, interval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\tval = it->expires;",
            "\tinterval = it->incr;",
            "\tif (val) {",
            "\t\tu64 t, samples[CPUCLOCK_MAX];",
            "",
            "\t\tthread_group_sample_cputime(tsk, samples);",
            "\t\tt = samples[clock_id];",
            "",
            "\t\tif (val < t)",
            "\t\t\t/* about to fire */",
            "\t\t\tval = TICK_NSEC;",
            "\t\telse",
            "\t\t\tval -= t;",
            "\t}",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tvalue->it_value = ns_to_timespec64(val);",
            "\tvalue->it_interval = ns_to_timespec64(interval);",
            "}",
            "static int do_getitimer(int which, struct itimerspec64 *value)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);",
            "\t\tvalue->it_interval =",
            "\t\t\tktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn(-EINVAL);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int put_itimerval(struct __kernel_old_itimerval __user *o,",
            "\t\t\t const struct itimerspec64 *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tv.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v, sizeof(struct __kernel_old_itimerval)) ? -EFAULT : 0;",
            "}",
            "static int put_old_itimerval32(struct old_itimerval32 __user *o,",
            "\t\t\t       const struct itimerspec64 *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tv32.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv32.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv32.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv32.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v32, sizeof(struct old_itimerval32)) ? -EFAULT : 0;",
            "}",
            "enum hrtimer_restart it_real_fn(struct hrtimer *timer)",
            "{",
            "\tstruct signal_struct *sig =",
            "\t\tcontainer_of(timer, struct signal_struct, real_timer);",
            "\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];",
            "",
            "\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);",
            "\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}"
          ],
          "function_name": "itimer_get_remtime, get_cpu_itimer, do_getitimer, put_itimerval, put_old_itimerval32, it_real_fn",
          "description": "实现了itimer_get_remtime获取剩余时间、get_cpu_itimer读取CPU定时器信息、do_getitimer根据时钟类型获取定时器状态、put_itimerval/put_old_itimerval32转换并复制时间值到用户空间，以及it_real_fn作为实时时钟的超时处理函数",
          "similarity": 0.5935667753219604
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/itimer.c",
          "start_line": 313,
          "end_line": 348,
          "content": [
            "static int get_itimerval(struct itimerspec64 *o, const struct __kernel_old_itimerval __user *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tif (copy_from_user(&v, i, sizeof(struct __kernel_old_itimerval)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value. */",
            "\tif (!timeval_valid(&v.it_value) ||",
            "\t    !timeval_valid(&v.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}",
            "static int get_old_itimerval32(struct itimerspec64 *o, const struct old_itimerval32 __user *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tif (copy_from_user(&v32, i, sizeof(struct old_itimerval32)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value.  */",
            "\tif (!timeval_valid(&v32.it_value) ||",
            "\t    !timeval_valid(&v32.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v32.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v32.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v32.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v32.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_itimerval, get_old_itimerval32",
          "description": "实现get_itimerval/get_old_itimerval32将用户态时间值转换为内核时间结构体，执行有效性校验，确保输入时间值在合法范围内",
          "similarity": 0.5389938354492188
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/itimer.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992 Darren Senn",
            " */",
            "",
            "/* These are all the functions necessary to implement itimers */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/time.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/hrtimer.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/compat.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "/**",
            " * itimer_get_remtime - get remaining time for the timer",
            " *",
            " * @timer: the timer to read",
            " *",
            " * Returns the delta between the expiry time and now, which can be",
            " * less than zero or 1usec for an pending expired timer",
            " */"
          ],
          "function_name": null,
          "description": "该代码块定义了itimer_get_remtime函数的原型，用于获取高精度定时器的剩余时间，通过计算当前时间与定时器到期时间的差值得到剩余时间，但未提供完整实现，上下文不完整",
          "similarity": 0.5366377830505371
        }
      ]
    }
  ]
}