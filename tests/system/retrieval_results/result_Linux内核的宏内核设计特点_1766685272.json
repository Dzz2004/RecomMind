{
  "query": "Linux内核的宏内核设计特点",
  "timestamp": "2025-12-26 01:54:32",
  "retrieved_files": [
    {
      "source_file": "mm/memblock.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memblock.c`\n\n---\n\n# memblock.c 技术文档\n\n## 1. 文件概述\n\n`memblock.c` 实现了 Linux 内核早期启动阶段的内存管理机制——**memblock**。该机制用于在常规内存分配器（如 buddy allocator）尚未初始化之前，对物理内存进行粗粒度的区域管理。它将系统内存抽象为若干连续的内存区域（regions），支持“可用内存”（memory）、“保留内存”（reserved）和“物理内存”（physmem，部分架构支持）三种类型，为内核早期初始化提供内存添加、查询和分配能力。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct memblock_region`：表示一个连续的物理内存区域，包含基地址（base）、大小（size）、NUMA 节点 ID 和属性标志。\n- `struct memblock_type`：管理一类内存区域的集合，包含区域数组、当前数量（cnt）、最大容量（max）和名称。\n- `struct memblock`：全局 memblock 管理结构，包含 `memory` 和 `reserved` 两种类型的 `memblock_type`，以及分配方向（bottom_up）和当前分配上限（current_limit）。\n- `physmem`（条件编译）：描述不受 `mem=` 参数限制的实际物理内存布局。\n\n### 主要函数与变量\n- `memblock_add()` / `memblock_add_node()`：向 memblock 添加可用内存区域。\n- `memblock_reserve()`：标记内存区域为保留（不可用于动态分配）。\n- `memblock_phys_alloc*()` / `memblock_alloc*()`：分配物理或虚拟地址的内存。\n- `memblock_overlaps_region()`：判断指定区域是否与某类 memblock 区域重叠。\n- `__memblock_find_range_bottom_up()`：从低地址向高地址查找满足条件的空闲内存范围。\n- 全局变量 `memblock`：静态初始化的主 memblock 结构体。\n- `max_low_pfn`, `min_low_pfn`, `max_pfn`, `max_possible_pfn`：记录 PFN（页帧号）边界信息。\n\n### 配置宏\n- `INIT_MEMBLOCK_REGIONS`：初始内存/保留区域数组大小（默认 128）。\n- `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 类型支持。\n- `CONFIG_MEMBLOCK_KHO_SCRATCH`：支持仅从特定标记（KHO_SCRATCH）区域分配内存。\n- `CONFIG_ARCH_KEEP_MEMBLOCK`：决定是否在初始化完成后保留 memblock 数据结构。\n\n## 3. 关键实现\n\n### 初始化与存储\n- `memblock` 结构体在编译时静态初始化，其 `memory` 和 `reserved` 的区域数组分别使用 `memblock_memory_init_regions` 和 `memblock_reserved_init_regions`，初始容量由 `INIT_MEMBLOCK_*_REGIONS` 定义。\n- 每个 `memblock_type` 的 `cnt` 初始设为 1，但实际第一个条目为空的占位符，有效区域从索引 1 开始（后续代码处理）。\n- 支持通过 `memblock_allow_resize()` 动态扩容区域数组，但需谨慎避免与 initrd 等关键区域冲突。\n\n### 内存区域管理\n- 使用 `for_each_memblock_type` 宏遍历指定类型的区域。\n- `memblock_addrs_overlap()` 通过比较区间端点判断两个物理内存区域是否重叠。\n- `memblock_overlaps_region()` 封装了对某类所有区域的重叠检测。\n\n### 分配策略\n- 默认采用 **top-down**（从高地址向低地址）分配策略，可通过 `memblock_set_bottom_up(true)` 切换为 **bottom-up**。\n- 分配时受 `current_limit` 限制（默认 `MEMBLOCK_ALLOC_ANYWHERE` 表示无限制）。\n- 支持基于 NUMA 节点、对齐要求、内存属性（如 `MEMBLOCK_MIRROR`、`MEMBLOCK_KHO_SCRATCH`）的精细控制。\n- `choose_memblock_flags()` 根据 `kho_scratch_only` 和镜像内存存在性动态选择分配标志。\n\n### 安全与调试\n- `memblock_cap_size()` 防止地址计算溢出（确保 `base + size <= PHYS_ADDR_MAX`）。\n- 条件编译的 `memblock_dbg()` 宏用于调试输出（需开启 `memblock_debug`）。\n- 使用 `__initdata_memblock` 属性标记仅在初始化阶段使用的数据，便于后续释放。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memblock.h>`：定义 memblock API 和数据结构。\n  - `<linux/kernel.h>`, `<linux/init.h>`：提供基础内核功能和初始化宏。\n  - `<linux/pfn.h>`：PFN 相关操作。\n  - `<asm/sections.h>`：访问内核链接段信息。\n  - 架构相关头文件（如 `internal.h`）。\n- **配置依赖**：\n  - `CONFIG_NUMA`：影响 `contig_page_data` 的定义。\n  - `CONFIG_KEXEC_HANDOVER`：引入 kexec 相关头文件。\n  - `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 支持。\n- **后续移交**：在 `mem_init()` 中，memblock 管理的内存会被释放给 buddy allocator，完成内存管理权移交。\n\n## 5. 使用场景\n\n- **内核早期初始化**：在 `start_kernel()` 初期，架构代码（如 `setup_arch()`）调用 `memblock_add()` 注册可用物理内存，调用 `memblock_reserve()` 保留内核镜像、设备树、initrd 等关键区域。\n- **早期内存分配**：在 slab/buddy 分配器就绪前，使用 `memblock_alloc()` 分配大块连续内存（如页表、中断向量表、ACPI 表解析缓冲区）。\n- **内存布局查询**：通过 `for_each_memblock()` 等宏遍历内存区域，用于构建 e820 表、EFI 内存映射或 NUMA 拓扑。\n- **特殊分配需求**：支持从镜像内存（`MEMBLOCK_MIRROR`）或 KHO scratch 区域分配，满足安全启动或崩溃转储等场景。\n- **调试与分析**：通过 debugfs 接口（未在片段中体现）导出 memblock 布局，辅助内存问题诊断。",
      "similarity": 0.6069428324699402,
      "chunks": [
        {
          "chunk_id": 12,
          "file_path": "mm/memblock.c",
          "start_line": 2233,
          "end_line": 2340,
          "content": [
            "static void __init __free_pages_memory(unsigned long start, unsigned long end)",
            "{",
            "\tint order;",
            "",
            "\twhile (start < end) {",
            "\t\t/*",
            "\t\t * Free the pages in the largest chunks alignment allows.",
            "\t\t *",
            "\t\t * __ffs() behaviour is undefined for 0. start == 0 is",
            "\t\t * MAX_PAGE_ORDER-aligned, set order to MAX_PAGE_ORDER for",
            "\t\t * the case.",
            "\t\t */",
            "\t\tif (start)",
            "\t\t\torder = min_t(int, MAX_PAGE_ORDER, __ffs(start));",
            "\t\telse",
            "\t\t\torder = MAX_PAGE_ORDER;",
            "",
            "\t\twhile (start + (1UL << order) > end)",
            "\t\t\torder--;",
            "",
            "\t\tmemblock_free_pages(pfn_to_page(start), start, order);",
            "",
            "\t\tstart += (1UL << order);",
            "\t}",
            "}",
            "static unsigned long __init __free_memory_core(phys_addr_t start,",
            "\t\t\t\t phys_addr_t end)",
            "{",
            "\tunsigned long start_pfn = PFN_UP(start);",
            "\tunsigned long end_pfn = min_t(unsigned long,",
            "\t\t\t\t      PFN_DOWN(end), max_low_pfn);",
            "",
            "\tif (start_pfn >= end_pfn)",
            "\t\treturn 0;",
            "",
            "\t__free_pages_memory(start_pfn, end_pfn);",
            "",
            "\treturn end_pfn - start_pfn;",
            "}",
            "static void __init memmap_init_reserved_pages(void)",
            "{",
            "\tstruct memblock_region *region;",
            "\tphys_addr_t start, end;",
            "\tint nid;",
            "\tunsigned long max_reserved;",
            "",
            "\t/*",
            "\t * set nid on all reserved pages and also treat struct",
            "\t * pages for the NOMAP regions as PageReserved",
            "\t */",
            "repeat:",
            "\tmax_reserved = memblock.reserved.max;",
            "\tfor_each_mem_region(region) {",
            "\t\tnid = memblock_get_region_node(region);",
            "\t\tstart = region->base;",
            "\t\tend = start + region->size;",
            "",
            "\t\tif (memblock_is_nomap(region))",
            "\t\t\treserve_bootmem_region(start, end, nid);",
            "",
            "\t\tmemblock_set_node(start, region->size, &memblock.reserved, nid);",
            "\t}",
            "\t/*",
            "\t * 'max' is changed means memblock.reserved has been doubled its",
            "\t * array, which may result a new reserved region before current",
            "\t * 'start'. Now we should repeat the procedure to set its node id.",
            "\t */",
            "\tif (max_reserved != memblock.reserved.max)",
            "\t\tgoto repeat;",
            "",
            "\t/*",
            "\t * initialize struct pages for reserved regions that don't have",
            "\t * the MEMBLOCK_RSRV_NOINIT flag set",
            "\t */",
            "\tfor_each_reserved_mem_region(region) {",
            "\t\tif (!memblock_is_reserved_noinit(region)) {",
            "\t\t\tnid = memblock_get_region_node(region);",
            "\t\t\tstart = region->base;",
            "\t\t\tend = start + region->size;",
            "",
            "\t\t\tif (!numa_valid_node(nid))",
            "\t\t\t\tnid = early_pfn_to_nid(PFN_DOWN(start));",
            "",
            "\t\t\treserve_bootmem_region(start, end, nid);",
            "\t\t}",
            "\t}",
            "}",
            "static unsigned long __init free_low_memory_core_early(void)",
            "{",
            "\tunsigned long count = 0;",
            "\tphys_addr_t start, end;",
            "\tu64 i;",
            "",
            "\tmemblock_clear_hotplug(0, -1);",
            "",
            "\tmemmap_init_reserved_pages();",
            "",
            "\t/*",
            "\t * We need to use NUMA_NO_NODE instead of NODE_DATA(0)->node_id",
            "\t *  because in some case like Node0 doesn't have RAM installed",
            "\t *  low ram will be on Node1",
            "\t */",
            "\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,",
            "\t\t\t\tNULL)",
            "\t\tcount += __free_memory_core(start, end);",
            "",
            "\treturn count;",
            "}"
          ],
          "function_name": "__free_pages_memory, __free_memory_core, memmap_init_reserved_pages, free_low_memory_core_early",
          "description": "核心实现内存页面释放逻辑，初始化保留区域页结构并处理低内存核心区域的提前释放操作",
          "similarity": 0.543127179145813
        },
        {
          "chunk_id": 10,
          "file_path": "mm/memblock.c",
          "start_line": 1954,
          "end_line": 2057,
          "content": [
            "void __init memblock_mem_limit_remove_map(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\tmemblock_cap_memory_range(0, max_addr);",
            "}",
            "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)",
            "{",
            "\tunsigned int left = 0, right = type->cnt;",
            "",
            "\tdo {",
            "\t\tunsigned int mid = (right + left) / 2;",
            "",
            "\t\tif (addr < type->regions[mid].base)",
            "\t\t\tright = mid;",
            "\t\telse if (addr >= (type->regions[mid].base +",
            "\t\t\t\t  type->regions[mid].size))",
            "\t\t\tleft = mid + 1;",
            "\t\telse",
            "\t\t\treturn mid;",
            "\t} while (left < right);",
            "\treturn -1;",
            "}",
            "bool __init_memblock memblock_is_reserved(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.reserved, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_memory(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.memory, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_map_memory(phys_addr_t addr)",
            "{",
            "\tint i = memblock_search(&memblock.memory, addr);",
            "",
            "\tif (i == -1)",
            "\t\treturn false;",
            "\treturn !memblock_is_nomap(&memblock.memory.regions[i]);",
            "}",
            "int __init_memblock memblock_search_pfn_nid(unsigned long pfn,",
            "\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)",
            "{",
            "\tstruct memblock_type *type = &memblock.memory;",
            "\tint mid = memblock_search(type, PFN_PHYS(pfn));",
            "",
            "\tif (mid == -1)",
            "\t\treturn -1;",
            "",
            "\t*start_pfn = PFN_DOWN(type->regions[mid].base);",
            "\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);",
            "",
            "\treturn memblock_get_region_node(&type->regions[mid]);",
            "}",
            "bool __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint idx = memblock_search(&memblock.memory, base);",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "",
            "\tif (idx == -1)",
            "\t\treturn false;",
            "\treturn (memblock.memory.regions[idx].base +",
            "\t\t memblock.memory.regions[idx].size) >= end;",
            "}",
            "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_overlaps_region(&memblock.reserved, base, size);",
            "}",
            "void __init_memblock memblock_trim_memory(phys_addr_t align)",
            "{",
            "\tphys_addr_t start, end, orig_start, orig_end;",
            "\tstruct memblock_region *r;",
            "",
            "\tfor_each_mem_region(r) {",
            "\t\torig_start = r->base;",
            "\t\torig_end = r->base + r->size;",
            "\t\tstart = round_up(orig_start, align);",
            "\t\tend = round_down(orig_end, align);",
            "",
            "\t\tif (start == orig_start && end == orig_end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start < end) {",
            "\t\t\tr->base = start;",
            "\t\t\tr->size = end - start;",
            "\t\t} else {",
            "\t\t\tmemblock_remove_region(&memblock.memory,",
            "\t\t\t\t\t       r - memblock.memory.regions);",
            "\t\t\tr--;",
            "\t\t}",
            "\t}",
            "}",
            "void __init_memblock memblock_set_current_limit(phys_addr_t limit)",
            "{",
            "\tmemblock.current_limit = limit;",
            "}"
          ],
          "function_name": "memblock_mem_limit_remove_map, memblock_search, memblock_is_reserved, memblock_is_memory, memblock_is_map_memory, memblock_search_pfn_nid, memblock_is_region_memory, memblock_is_region_reserved, memblock_trim_memory, memblock_set_current_limit",
          "description": "实现内存块限制移除、搜索和区域判断逻辑，用于管理内存和保留区域的地址范围查询及修剪操作",
          "similarity": 0.5387403964996338
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memblock.c",
          "start_line": 192,
          "end_line": 297,
          "content": [
            "static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)",
            "{",
            "\treturn *size = min(*size, PHYS_ADDR_MAX - base);",
            "}",
            "unsigned long __init_memblock",
            "memblock_addrs_overlap(phys_addr_t base1, phys_addr_t size1, phys_addr_t base2,",
            "\t\t       phys_addr_t size2)",
            "{",
            "\treturn ((base1 < (base2 + size2)) && (base2 < (base1 + size1)));",
            "}",
            "bool __init_memblock memblock_overlaps_region(struct memblock_type *type,",
            "\t\t\t\t\tphys_addr_t base, phys_addr_t size)",
            "{",
            "\tunsigned long i;",
            "",
            "\tmemblock_cap_size(base, &size);",
            "",
            "\tfor (i = 0; i < type->cnt; i++)",
            "\t\tif (memblock_addrs_overlap(base, size, type->regions[i].base,",
            "\t\t\t\t\t   type->regions[i].size))",
            "\t\t\tbreak;",
            "\treturn i < type->cnt;",
            "}",
            "static phys_addr_t __init_memblock",
            "__memblock_find_range_bottom_up(phys_addr_t start, phys_addr_t end,",
            "\t\t\t\tphys_addr_t size, phys_addr_t align, int nid,",
            "\t\t\t\tenum memblock_flags flags)",
            "{",
            "\tphys_addr_t this_start, this_end, cand;",
            "\tu64 i;",
            "",
            "\tfor_each_free_mem_range(i, nid, flags, &this_start, &this_end, NULL) {",
            "\t\tthis_start = clamp(this_start, start, end);",
            "\t\tthis_end = clamp(this_end, start, end);",
            "",
            "\t\tcand = round_up(this_start, align);",
            "\t\tif (cand < this_end && this_end - cand >= size)",
            "\t\t\treturn cand;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static phys_addr_t __init_memblock",
            "__memblock_find_range_top_down(phys_addr_t start, phys_addr_t end,",
            "\t\t\t       phys_addr_t size, phys_addr_t align, int nid,",
            "\t\t\t       enum memblock_flags flags)",
            "{",
            "\tphys_addr_t this_start, this_end, cand;",
            "\tu64 i;",
            "",
            "\tfor_each_free_mem_range_reverse(i, nid, flags, &this_start, &this_end,",
            "\t\t\t\t\tNULL) {",
            "\t\tthis_start = clamp(this_start, start, end);",
            "\t\tthis_end = clamp(this_end, start, end);",
            "",
            "\t\tif (this_end < size)",
            "\t\t\tcontinue;",
            "",
            "\t\tcand = round_down(this_end - size, align);",
            "\t\tif (cand >= this_start)",
            "\t\t\treturn cand;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,",
            "\t\t\t\t\tphys_addr_t align, phys_addr_t start,",
            "\t\t\t\t\tphys_addr_t end, int nid,",
            "\t\t\t\t\tenum memblock_flags flags)",
            "{",
            "\t/* pump up @end */",
            "\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE ||",
            "\t    end == MEMBLOCK_ALLOC_NOLEAKTRACE)",
            "\t\tend = memblock.current_limit;",
            "",
            "\t/* avoid allocating the first page */",
            "\tstart = max_t(phys_addr_t, start, PAGE_SIZE);",
            "\tend = max(start, end);",
            "",
            "\tif (memblock_bottom_up())",
            "\t\treturn __memblock_find_range_bottom_up(start, end, size, align,",
            "\t\t\t\t\t\t       nid, flags);",
            "\telse",
            "\t\treturn __memblock_find_range_top_down(start, end, size, align,",
            "\t\t\t\t\t\t      nid, flags);",
            "}",
            "static phys_addr_t __init_memblock memblock_find_in_range(phys_addr_t start,",
            "\t\t\t\t\tphys_addr_t end, phys_addr_t size,",
            "\t\t\t\t\tphys_addr_t align)",
            "{",
            "\tphys_addr_t ret;",
            "\tenum memblock_flags flags = choose_memblock_flags();",
            "",
            "again:",
            "\tret = memblock_find_in_range_node(size, align, start, end,",
            "\t\t\t\t\t    NUMA_NO_NODE, flags);",
            "",
            "\tif (!ret && (flags & MEMBLOCK_MIRROR)) {",
            "\t\tpr_warn_ratelimited(\"Could not allocate %pap bytes of mirrored memory\\n\",",
            "\t\t\t&size);",
            "\t\tflags &= ~MEMBLOCK_MIRROR;",
            "\t\tgoto again;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "memblock_cap_size, memblock_addrs_overlap, memblock_overlaps_region, __memblock_find_range_bottom_up, __memblock_find_range_top_down, memblock_find_in_range_node, memblock_find_in_range",
          "description": "实现内存区域地址重叠检测与分配策略选择逻辑，包含范围查找算法（底向顶/顶向底）及镜像内存分配失败回退机制。",
          "similarity": 0.5293705463409424
        },
        {
          "chunk_id": 11,
          "file_path": "mm/memblock.c",
          "start_line": 2094,
          "end_line": 2203,
          "content": [
            "static void __init_memblock memblock_dump(struct memblock_type *type)",
            "{",
            "\tphys_addr_t base, end, size;",
            "\tenum memblock_flags flags;",
            "\tint idx;",
            "\tstruct memblock_region *rgn;",
            "",
            "\tpr_info(\" %s.cnt  = 0x%lx\\n\", type->name, type->cnt);",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tchar nid_buf[32] = \"\";",
            "",
            "\t\tbase = rgn->base;",
            "\t\tsize = rgn->size;",
            "\t\tend = base + size - 1;",
            "\t\tflags = rgn->flags;",
            "#ifdef CONFIG_NUMA",
            "\t\tif (numa_valid_node(memblock_get_region_node(rgn)))",
            "\t\t\tsnprintf(nid_buf, sizeof(nid_buf), \" on node %d\",",
            "\t\t\t\t memblock_get_region_node(rgn));",
            "#endif",
            "\t\tpr_info(\" %s[%#x]\\t[%pa-%pa], %pa bytes%s flags: %#x\\n\",",
            "\t\t\ttype->name, idx, &base, &end, &size, nid_buf, flags);",
            "\t}",
            "}",
            "void __init memblock_allow_resize(void)",
            "{",
            "\tmemblock_can_resize = 1;",
            "}",
            "static int __init early_memblock(char *p)",
            "{",
            "\tif (p && strstr(p, \"debug\"))",
            "\t\tmemblock_debug = 1;",
            "\treturn 0;",
            "}",
            "static void __init free_memmap(unsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tstruct page *start_pg, *end_pg;",
            "\tphys_addr_t pg, pgend;",
            "",
            "\t/*",
            "\t * Convert start_pfn/end_pfn to a struct page pointer.",
            "\t */",
            "\tstart_pg = pfn_to_page(start_pfn - 1) + 1;",
            "\tend_pg = pfn_to_page(end_pfn - 1) + 1;",
            "",
            "\t/*",
            "\t * Convert to physical addresses, and round start upwards and end",
            "\t * downwards.",
            "\t */",
            "\tpg = PAGE_ALIGN(__pa(start_pg));",
            "\tpgend = __pa(end_pg) & PAGE_MASK;",
            "",
            "\t/*",
            "\t * If there are free pages between these, free the section of the",
            "\t * memmap array.",
            "\t */",
            "\tif (pg < pgend)",
            "\t\tmemblock_phys_free(pg, pgend - pg);",
            "}",
            "static void __init free_unused_memmap(void)",
            "{",
            "\tunsigned long start, end, prev_end = 0;",
            "\tint i;",
            "",
            "\tif (!IS_ENABLED(CONFIG_HAVE_ARCH_PFN_VALID) ||",
            "\t    IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This relies on each bank being in address order.",
            "\t * The banks are sorted previously in bootmem_init().",
            "\t */",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, NULL) {",
            "#ifdef CONFIG_SPARSEMEM",
            "\t\t/*",
            "\t\t * Take care not to free memmap entries that don't exist",
            "\t\t * due to SPARSEMEM sections which aren't present.",
            "\t\t */",
            "\t\tstart = min(start, ALIGN(prev_end, PAGES_PER_SECTION));",
            "#endif",
            "\t\t/*",
            "\t\t * Align down here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tstart = pageblock_start_pfn(start);",
            "",
            "\t\t/*",
            "\t\t * If we had a previous bank, and there is a space",
            "\t\t * between the current bank and the previous, free it.",
            "\t\t */",
            "\t\tif (prev_end && prev_end < start)",
            "\t\t\tfree_memmap(prev_end, start);",
            "",
            "\t\t/*",
            "\t\t * Align up here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tprev_end = pageblock_align(end);",
            "\t}",
            "",
            "#ifdef CONFIG_SPARSEMEM",
            "\tif (!IS_ALIGNED(prev_end, PAGES_PER_SECTION)) {",
            "\t\tprev_end = pageblock_align(end);",
            "\t\tfree_memmap(prev_end, ALIGN(prev_end, PAGES_PER_SECTION));",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "memblock_dump, memblock_allow_resize, early_memblock, free_memmap, free_unused_memmap",
          "description": "提供内存块状态调试、调整支持、早期内存处理及未使用memmap释放功能，用于优化内存映射管理",
          "similarity": 0.5188350677490234
        },
        {
          "chunk_id": 9,
          "file_path": "mm/memblock.c",
          "start_line": 1607,
          "end_line": 1734,
          "content": [
            "phys_addr_t __init memblock_phys_alloc_range(phys_addr_t size,",
            "\t\t\t\t\t     phys_addr_t align,",
            "\t\t\t\t\t     phys_addr_t start,",
            "\t\t\t\t\t     phys_addr_t end)",
            "{",
            "\tmemblock_dbg(\"%s: %llu bytes align=0x%llx from=%pa max_addr=%pa %pS\\n\",",
            "\t\t     __func__, (u64)size, (u64)align, &start, &end,",
            "\t\t     (void *)_RET_IP_);",
            "\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,",
            "\t\t\t\t\tfalse);",
            "}",
            "phys_addr_t __init memblock_phys_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)",
            "{",
            "\treturn memblock_alloc_range_nid(size, align, 0,",
            "\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid, false);",
            "}",
            "void __init memblock_free_late(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t cursor, end;",
            "",
            "\tend = base + size - 1;",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\",",
            "\t\t     __func__, &base, &end, (void *)_RET_IP_);",
            "\tkmemleak_free_part_phys(base, size);",
            "\tcursor = PFN_UP(base);",
            "\tend = PFN_DOWN(base + size);",
            "",
            "\tfor (; cursor < end; cursor++) {",
            "\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);",
            "\t\ttotalram_pages_inc();",
            "\t}",
            "}",
            "phys_addr_t __init_memblock memblock_reserved_kern_size(phys_addr_t limit, int nid)",
            "{",
            "\tstruct memblock_region *r;",
            "\tphys_addr_t total = 0;",
            "",
            "\tfor_each_reserved_mem_region(r) {",
            "\t\tphys_addr_t size = r->size;",
            "",
            "\t\tif (r->base > limit)",
            "\t\t\tbreak;",
            "",
            "\t\tif (r->base + r->size > limit)",
            "\t\t\tsize = limit - r->base;",
            "",
            "\t\tif (nid == memblock_get_region_node(r) || !numa_valid_node(nid))",
            "\t\t\tif (r->flags & MEMBLOCK_RSRV_KERN)",
            "\t\t\t\ttotal += size;",
            "\t}",
            "",
            "\treturn total;",
            "}",
            "unsigned long __init memblock_estimated_nr_free_pages(void)",
            "{",
            "\treturn PHYS_PFN(memblock_phys_mem_size() - memblock_reserved_size());",
            "}",
            "static phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr = PHYS_ADDR_MAX;",
            "\tstruct memblock_region *r;",
            "",
            "\t/*",
            "\t * translate the memory @limit size into the max address within one of",
            "\t * the memory memblock regions, if the @limit exceeds the total size",
            "\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX",
            "\t */",
            "\tfor_each_mem_region(r) {",
            "\t\tif (limit <= r->size) {",
            "\t\t\tmax_addr = r->base + limit;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tlimit -= r->size;",
            "\t}",
            "",
            "\treturn max_addr;",
            "}",
            "void __init memblock_enforce_memory_limit(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\t/* truncate both memory and reserved regions */",
            "\tmemblock_remove_range(&memblock.memory, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "\tmemblock_remove_range(&memblock.reserved, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "}",
            "void __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint start_rgn, end_rgn;",
            "\tint i, ret;",
            "",
            "\tif (!size)",
            "\t\treturn;",
            "",
            "\tif (!memblock_memory->total_size) {",
            "\t\tpr_warn(\"%s: No memory registered yet\\n\", __func__);",
            "\t\treturn;",
            "\t}",
            "",
            "\tret = memblock_isolate_range(&memblock.memory, base, size,",
            "\t\t\t\t\t\t&start_rgn, &end_rgn);",
            "\tif (ret)",
            "\t\treturn;",
            "",
            "\t/* remove all the MAP regions */",
            "\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\tfor (i = start_rgn - 1; i >= 0; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\t/* truncate the reserved regions */",
            "\tmemblock_remove_range(&memblock.reserved, 0, base);",
            "\tmemblock_remove_range(&memblock.reserved,",
            "\t\t\tbase + size, PHYS_ADDR_MAX);",
            "}"
          ],
          "function_name": "memblock_phys_alloc_range, memblock_phys_alloc_try_nid, memblock_free_late, memblock_reserved_kern_size, memblock_estimated_nr_free_pages, __find_max_addr, memblock_enforce_memory_limit, memblock_cap_memory_range",
          "description": "实现物理内存分配/释放控制，包含内存上限强制限制、空闲页面估算、内存区域截断等管理功能，支持对保留内存的容量统计",
          "similarity": 0.5162268877029419
        }
      ]
    },
    {
      "source_file": "kernel/locking/lockdep_internals.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:38:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\lockdep_internals.h`\n\n---\n\n# `locking/lockdep_internals.h` 技术文档\n\n## 1. 文件概述\n\n`lockdep_internals.h` 是 Linux 内核锁依赖（Lock Dependency，简称 lockdep）子系统的内部头文件，定义了 lockdep 运行时验证器所依赖的核心数据结构、枚举、宏和全局变量。该文件不对外暴露 API，仅供 lockdep 子系统内部使用，用于跟踪锁的使用状态、依赖关系、调用链以及统计信息，以检测潜在的死锁、锁顺序违规和中断上下文不一致等问题。\n\n## 2. 核心功能\n\n### 枚举与宏定义\n- `enum lock_usage_bit`：定义锁类（lock class）在不同上下文中的使用状态位（如 IRQ、softirq、hardirq 等）。\n- `LOCK_USAGE_*_MASK`：用于解析锁使用状态位的掩码（读/写方向、上下文类型）。\n- `LOCKF_*` 系列宏与常量：将使用状态位转换为位掩码，便于位运算操作，如 `LOCKF_ENABLED_IRQ`、`LOCKF_USED_IN_IRQ_READ` 等。\n- `LOCKF_IRQ` 与 `LOCKF_IRQ_READ`：组合宏，用于快速判断锁是否在中断上下文中被启用或使用。\n\n### 配置相关宏（内存优化）\n- `CONFIG_LOCKDEP_SMALL`：针对内存受限架构（如 SPARC）启用的小内存配置，限制 lockdep 数据结构的最大规模。\n- `MAX_LOCKDEP_ENTRIES`、`MAX_LOCKDEP_CHAINS_BITS`、`MAX_STACK_TRACE_ENTRIES`、`STACK_TRACE_HASH_SIZE`：定义 lockdep 跟踪能力的上限。\n\n### 锁链（Lock Chain）上下文标志\n- `LOCK_CHAIN_SOFTIRQ_CONTEXT` / `LOCK_CHAIN_HARDIRQ_CONTEXT`：标识锁链所处的中断上下文类型。\n\n### 全局变量声明\n- `lock_classes[]`：所有锁类的静态数组。\n- `lock_chains[]`：所有锁依赖链的静态数组。\n- 各类计数器：如 `nr_lock_classes`、`max_lockdep_depth`、`nr_stack_trace_entries` 等，用于跟踪 lockdep 运行状态。\n- 中断/软中断/进程上下文链数量统计：`nr_hardirq_chains`、`nr_softirq_chains`、`nr_process_chains`。\n- 内存使用统计：`nr_lost_chain_hlocks`、`nr_large_chain_blocks` 等。\n\n### 函数声明\n- `get_usage_chars()`：将锁类的使用状态转换为可读字符串。\n- `__get_key_name()`：获取锁子类键的名称。\n- `lock_chain_get_class()`：从锁链中获取第 i 个锁类。\n- `lockdep_next_lockchain()` / `lock_chain_count()`：遍历和统计锁链。\n- `lockdep_count_forward_deps()` / `lockdep_count_backward_deps()`（仅在 `CONFIG_PROVE_LOCKING` 下有效）：计算锁类的前向/后向依赖数量。\n- `lockdep_stack_trace_count()` / `lockdep_stack_hash_count()`（仅在 `CONFIG_TRACE_IRQFLAGS` 下有效）：返回栈跟踪相关统计。\n\n### 调试统计结构（`CONFIG_DEBUG_LOCKDEP`）\n- `struct lockdep_stats`：每 CPU 的 lockdep 调试统计信息，包括：\n  - 链查找命中/未命中次数\n  - 中断开关事件计数（含冗余事件）\n  - 各类检查次数（循环、前向/后向使用查找等）\n  - 每个锁类的操作计数（`lock_class_ops`）\n- 提供原子操作宏：`debug_atomic_inc/dec/read` 和 `debug_class_ops_inc/read`，用于安全更新和读取统计值。\n\n## 3. 关键实现\n\n### 锁使用状态编码\n- 使用 `lockdep_states.h` 中定义的状态（如 IRQ、SOFTIRQ、HARDIRQ 等）通过宏展开生成两组状态位：\n  - `USED_IN_*`：表示锁在该上下文中被实际使用（加锁）。\n  - `ENABLED_*`：表示锁在该上下文中被启用（即允许在该上下文中获取）。\n- 每个状态同时存在普通（写）和 `_READ`（读）版本，支持读写锁语义。\n- 状态位总数由 `LOCK_USAGE_STATES` 表示，并通过 `static_assert` 确保与 `LOCK_TRACE_STATES` 一致。\n\n### 位掩码构建\n- 利用 C 预处理器的 `#include` 技巧，在枚举和常量定义中重复包含 `lockdep_states.h`，动态生成所有状态对应的位掩码常量（如 `LOCKF_ENABLED_IRQ` 是所有 `LOCKF_ENABLED_*` 的按位或）。\n- 这种设计避免了手动维护大量状态组合，提高了可扩展性和一致性。\n\n### 内存布局优化\n- 通过 `CONFIG_LOCKDEP_SMALL` 宏，为资源受限平台（如 SPARC）提供较小的静态数组尺寸，确保内核镜像不超过 32MB 限制。\n- 默认配置则通过 Kconfig 选项（如 `CONFIG_LOCKDEP_BITS`）动态设定数据结构大小，以平衡内存占用与跟踪能力。\n\n### 调试统计的每 CPU 设计\n- 在 `CONFIG_DEBUG_LOCKDEP` 启用时，统计信息存储在 per-CPU 变量中，避免在 fast path 中因全局锁或缓存行竞争导致性能下降。\n- 提供封装宏确保在中断关闭上下文中更新统计（通过 `WARN_ON_ONCE(!irqs_disabled())` 强制约束）。\n\n## 4. 依赖关系\n\n- **依赖头文件**：\n  - `\"lockdep_states.h\"`：定义 lockdep 支持的上下文状态列表。\n  - `<asm/local.h>`：提供 per-CPU 变量操作原语（仅在 `CONFIG_DEBUG_LOCKDEP` 下）。\n- **被依赖模块**：\n  - `kernel/lockdep.c`：lockdep 主逻辑实现，大量使用本文件定义的数据结构和宏。\n  - `kernel/lockdep_proc.c`：通过本文件声明的全局变量和函数生成 `/proc/lockdep*` 调试信息。\n- **配置依赖**：\n  - `CONFIG_LOCKDEP`：启用 lockdep 子系统。\n  - `CONFIG_PROVE_LOCKING`：启用锁正确性证明（依赖前向/后向依赖计数）。\n  - `CONFIG_TRACE_IRQFLAGS`：启用中断状态跟踪（影响栈跟踪统计）。\n  - `CONFIG_DEBUG_LOCKDEP`：启用详细调试统计。\n\n## 5. 使用场景\n\n- **死锁检测**：通过 `lock_classes` 和 `lock_chains` 构建锁依赖图，运行时检测循环依赖。\n- **锁顺序验证**：记录锁获取顺序，防止违反既定顺序导致的潜在死锁。\n- **中断上下文一致性检查**：利用 `LOCKF_ENABLED_*` 和 `LOCKF_USED_IN_*` 位，确保锁不会在不允许的中断上下文中被获取（如在 hardirq 中获取仅在进程上下文启用的锁）。\n- **性能分析与调试**：通过 `lockdep_stats` 统计 lockdep 自身开销（如链查找效率、冗余检查次数），辅助优化。\n- **内核调试接口**：为 `/proc/lockdep`、`/proc/lockdep_chains` 等提供底层数据支持，供开发者分析锁行为。\n- **内存受限系统适配**：在 SPARC 等平台上，通过 `CONFIG_LOCKDEP_SMALL` 保证 lockdep 功能可用而不突破内存限制。",
      "similarity": 0.591047465801239,
      "chunks": []
    },
    {
      "source_file": "mm/internal.h",
      "md_summary": "> 自动生成时间: 2025-12-07 16:09:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `internal.h`\n\n---\n\n# `internal.h` 技术文档\n\n## 1. 文件概述\n\n`internal.h` 是 Linux 内核内存管理子系统（`mm/`）的内部头文件，定义了仅供内存管理模块内部使用的宏、辅助函数、数据结构和常量。该文件不对外暴露接口，主要用于协调页分配、映射、回收、大页（hugetlb/folio）处理、VMA 操作等核心内存管理逻辑，并提供调试与一致性保障机制。\n\n## 2. 核心功能\n\n### 宏定义\n- **GFP 掩码相关**：\n  - `GFP_RECLAIM_MASK`：仅影响水位检查和回收行为的 GFP 标志集合。\n  - `GFP_BOOT_MASK`：早期启动阶段允许使用的 GFP 标志。\n  - `GFP_CONSTRAINT_MASK`：控制 cpuset 和节点放置约束的标志。\n  - `GFP_SLAB_BUG_MASK`：用于检测错误地将 slab 不支持的标志（如 `__GFP_HIGHMEM`）传递给 slab 分配器。\n- **调试与警告**：\n  - `WARN_ON_ONCE_GFP(cond, gfp)`：带 `__GFP_NOWARN` 控制的单次警告宏。\n- **映射状态标志**：\n  - `SHOW_MEM_FILTER_NODES`：用于 `__show_mem()` 和 `show_free_areas()` 的节点过滤标志。\n- **folio 映射计数**：\n  - `ENTIRELY_MAPPED` 与 `FOLIO_PAGES_MAPPED`：用于区分 folio 是否被整体映射或部分页面被映射。\n\n### 内联函数\n- `folio_nr_pages_mapped()`：获取 folio 中被单独映射的页面数量（排除整体映射计数）。\n- `folio_swap()`：根据 folio 和一个 swap entry 计算其所属 folio 的起始 swap entry。\n- `folio_raw_mapping()`：安全提取 folio 的原始 mapping 指针（清除标志位）。\n- `mmap_file()`：安全调用文件的 `mmap` 钩子，失败时安装 dummy VMA 操作以防止后续误用。\n- `vma_close()`：安全关闭 VMA，调用 close 钩子后替换为 dummy 操作集。\n- `folio_pte_batch()`（仅在 `CONFIG_MMU` 下）：检测连续 PTE 是否构成一个“PTE 批处理”（即连续映射同一 folio 的多个页面）。\n- `__pte_batch_clear_ignored()`：根据标志清除 PTE 中可忽略的位（如 dirty、soft-dirty），用于 PTE 批处理比较。\n\n### 函数声明\n- `page_writeback_init()`：初始化页回写子系统。\n\n### 类型定义\n- `fpb_t`：`folio_pte_batch()` 使用的标志类型（强类型位掩码）。\n- `FPB_IGNORE_DIRTY` / `FPB_IGNORE_SOFT_DIRTY`：控制 PTE 批处理比较时忽略哪些状态位。\n\n## 3. 关键实现\n\n### Folio 映射计数设计\n- 使用 `atomic_t _nr_pages_mapped` 字段的低 23 位（`FOLIO_PAGES_MAPPED = 0x7FFFFF`）记录被单独映射的页面数。\n- 最高位（`ENTIRELY_MAPPED = 0x800000`）保留用于标记整个 folio 被一次性映射（如通过 PMD/PUD 映射大页），避免与逐页映射计数冲突。\n- 即使 hugetlb 当前未使用该字段，此设计也为未来扩展预留空间。\n\n### 安全 VMA 钩子调用机制\n- `mmap_file()` 和 `vma_close()` 在操作失败或完成关闭后，立即将 `vma->vm_ops` 替换为 `&vma_dummy_vm_ops`（空操作集）。\n- 此设计防止 VMA 处于不一致状态时被意外调用其他钩子，提升内核健壮性。\n\n### PTE 批处理检测（`folio_pte_batch`）\n- 目标：高效识别连续 PTE 是否映射同一 folio 的连续物理页。\n- 实现要点：\n  - 使用 `pte_batch_hint()` 获取硬件或架构建议的批处理步长（如 THP 场景下为 512）。\n  - 通过 `__pte_batch_clear_ignored()` 标准化 PTE（清除可忽略位），再用 `pte_same()` 比较。\n  - 动态推进 `expected_pte` 的 PFN，确保连续性。\n  - 支持通过指针参数返回非首项 PTE 的 writable/young/dirty 状态。\n  - 严格限制扫描范围不超过单个页表（由 `max_nr` 保证）。\n\n### GFP 标志分组策略\n- 将 GFP 标志按用途分类（回收行为、启动约束、放置约束、slab 兼容性），便于在不同内存分配路径中精确控制行为，避免标志误用。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/fs.h>`：文件和 VMA 相关操作。\n  - `<linux/mm.h>`、`<linux/pagemap.h>`、`<linux/rmap.h>`、`<linux/swap.h>`、`<linux/swapops.h>`：核心内存管理、页缓存、反向映射、交换子系统。\n  - `<linux/khugepaged.h>`：透明大页后台合并支持。\n  - `<linux/tracepoint-defs.h>`：跟踪点定义。\n- **内核配置依赖**：\n  - `CONFIG_MMU`：决定是否编译 `folio_pte_batch` 等 MMU 相关功能。\n- **模块依赖**：\n  - 被 `mm/` 子目录下的多个源文件包含（如 `memory.c`, `mmap.c`, `swap.c`, `huge_memory.c` 等），作为内部实现细节共享。\n\n## 5. 使用场景\n\n- **内存分配路径**：在 `alloc_pages()` 等底层分配函数中，使用 `GFP_RECLAIM_MASK` 等掩码控制回收行为。\n- **VMA 生命周期管理**：在 `do_mmap()` 和 `remove_vma()` 中调用 `mmap_file()` 和 `vma_close()` 安全处理文件映射。\n- **大页（Folio/HugeTLB/THP）处理**：\n  - 使用 `folio_nr_pages_mapped()` 跟踪部分映射状态。\n  - `folio_pte_batch()` 用于优化大页的 PTE 遍历（如缺页处理、页迁移、内存规整）。\n- **页回收与回写**：`page_writeback_init()` 在系统初始化时设置回写参数。\n- **调试与诊断**：`WARN_ON_ONCE_GFP` 用于条件性报告内存分配异常；`SHOW_MEM_FILTER_NODES` 控制内存状态输出。\n- **交换子系统**：`folio_swap()` 辅助在 folio 粒度上管理 swap entry。",
      "similarity": 0.5833626389503479,
      "chunks": []
    }
  ]
}