{
  "query": "抢占式调度与非抢占式调度区别",
  "timestamp": "2025-12-25 23:24:01",
  "retrieved_files": [
    {
      "source_file": "kernel/printk/nbcon.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:32:39\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `printk\\nbcon.c`\n\n---\n\n# printk/nbcon.c 技术文档\n\n## 文件概述\n\n`printk/nbcon.c` 实现了新一代的 printk 控制台（nbcon，即 \"new console\"）打印机制，该机制不依赖传统的 `console_lock` 互斥锁，而是采用基于原子操作的状态机模型来管理控制台访问。其核心目标是支持高优先级上下文（如中断、NMI、panic）安全、高效地抢占低优先级上下文对控制台的使用权，同时避免死锁和优先级反转问题。该机制特别适用于实时系统和 panic 场景下的可靠日志输出。\n\n## 核心功能\n\n### 主要数据结构\n- **`struct nbcon_state`**：封装控制台状态的原子变量，包含以下关键字段：\n  - `prio`：当前持有控制台的上下文优先级（0 表示未锁定）\n  - `cpu`：当前持有控制台的 CPU 编号\n  - `req_prio`：请求友好移交的更高优先级上下文的优先级\n  - `unsafe`：标志当前是否处于不安全状态（如正在操作共享资源）\n  - `unsafe_takeover`：标志是否发生过不安全的强制接管\n\n### 主要函数\n- **`nbcon_state_set()`**：初始化或重置控制台状态（仅限未注册或初始化阶段使用）\n- **`nbcon_state_read()`**：原子读取当前控制台状态\n- **`nbcon_state_try_cmpxchg()`**：原子比较并交换控制台状态\n- **`nbcon_seq_read()`**：读取控制台当前应打印的 printk 记录序列号\n- **`nbcon_seq_force()`**：强制设置控制台序列号（用于初始化或 panic 场景）\n- **`nbcon_seq_try_update()`**：尝试原子更新控制台序列号\n- **`nbcon_context_try_acquire_direct()`**：尝试直接获取控制台所有权（核心获取逻辑之一）\n\n## 关键实现\n\n### 控制台状态管理机制\n控制台状态通过 `nbcon_state` 原子变量管理，支持三种获取策略：\n1. **直接获取**：当控制台未被占用，或当前持有者优先级更低且处于安全状态时，直接抢占。\n2. **友好移交**：当持有者优先级更低但处于不安全状态时，请求者设置 `req_prio`，持有者在退出不安全状态后主动释放。\n3. **强制接管**：仅在 `panic()` 的最后尝试中使用，无视不安全状态强制接管（标记 `unsafe_takeover`）。\n\n### 安全状态标记\n- **`unsafe` 字段**：在操作共享资源或控制台设备时置位，操作完成后清除。确保高优先级上下文不会在设备不一致状态下接管。\n- **`unsafe_takeover` 字段**：记录强制接管事件，后续需重新初始化控制台状态。\n\n### 序列号管理\n- 使用 64 位序列号跟踪下一条待打印的 printk 记录。\n- 在 32 位系统上，仅存储低 32 位，高 32 位通过 ringbuffer 中的有效序列号推导。\n- `nbcon_seq_force()` 确保设置的序列号不低于 ringbuffer 中最早的有效记录。\n\n### 优先级与 CPU 绑定\n- 优先级数值越大表示优先级越高（`NBCON_PRIO_NONE = 0` 表示无持有者）。\n- `cpu` 字段防止同 CPU 上的忙等待，并处理复杂场景下优先级相同但 CPU 切换的情况。\n\n## 依赖关系\n\n- **内部依赖**：\n  - `printk_ringbuffer.h`：提供 printk 环形缓冲区操作接口（如 `prb_first_valid_seq()`）\n  - `internal.h`：包含 nbcon 内部定义的辅助宏和类型（如 `ACCESS_PRIVATE`、`__ulseq_to_u64seq`）\n- **内核核心模块**：\n  - `linux/atomic.h`：提供原子操作支持\n  - `linux/console.h`：定义 `struct console` 及相关常量\n  - `linux/irqflags.h`：用于中断上下文判断\n  - `linux/smp.h`：SMP 相关支持（如 `smp_processor_id()`）\n- **关键子系统**：\n  - **Printk 子系统**：作为 printk 输出后端，与 ringbuffer 紧密集成\n  - **调度器/中断子系统**：依赖上下文优先级模型（如 NMI > IRQ > 进程）\n\n## 使用场景\n\n1. **常规 printk 输出**：\n   - 高优先级中断/NMI 日志可安全抢占低优先级进程的控制台输出。\n   - 每条 printk 记录独立输出，被抢占时由新持有者重试整条记录。\n\n2. **Panic 处理**：\n   - 在 `panic()` 流程中，通过强制接管机制确保最后的日志能输出。\n   - 使用独立的 panic 记录缓冲区，避免因不安全状态导致数据损坏。\n\n3. **实时系统**：\n   - 避免传统 `console_lock` 导致的优先级反转问题。\n   - 保证高优先级任务/中断的日志能及时输出。\n\n4. **控制台驱动实现**：\n   - 控制台驱动需在关键操作（如设备寄存器访问）前后标记 `unsafe` 状态。\n   - 驱动需在每次输出字符后检查移交请求（`req_prio`），及时释放控制台。",
      "similarity": 0.49559807777404785,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 1,
          "end_line": 127,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "// Copyright (C) 2022 Linutronix GmbH, John Ogness",
            "// Copyright (C) 2022 Intel, Thomas Gleixner",
            "",
            "#include <linux/atomic.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/delay.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kthread.h>",
            "#include <linux/minmax.h>",
            "#include <linux/percpu.h>",
            "#include <linux/preempt.h>",
            "#include <linux/slab.h>",
            "#include <linux/smp.h>",
            "#include <linux/stddef.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include \"internal.h\"",
            "#include \"printk_ringbuffer.h\"",
            "/*",
            " * Printk console printing implementation for consoles which does not depend",
            " * on the legacy style console_lock mechanism.",
            " *",
            " * The state of the console is maintained in the \"nbcon_state\" atomic",
            " * variable.",
            " *",
            " * The console is locked when:",
            " *",
            " *   - The 'prio' field contains the priority of the context that owns the",
            " *     console. Only higher priority contexts are allowed to take over the",
            " *     lock. A value of 0 (NBCON_PRIO_NONE) means the console is not locked.",
            " *",
            " *   - The 'cpu' field denotes on which CPU the console is locked. It is used",
            " *     to prevent busy waiting on the same CPU. Also it informs the lock owner",
            " *     that it has lost the lock in a more complex scenario when the lock was",
            " *     taken over by a higher priority context, released, and taken on another",
            " *     CPU with the same priority as the interrupted owner.",
            " *",
            " * The acquire mechanism uses a few more fields:",
            " *",
            " *   - The 'req_prio' field is used by the handover approach to make the",
            " *     current owner aware that there is a context with a higher priority",
            " *     waiting for the friendly handover.",
            " *",
            " *   - The 'unsafe' field allows to take over the console in a safe way in the",
            " *     middle of emitting a message. The field is set only when accessing some",
            " *     shared resources or when the console device is manipulated. It can be",
            " *     cleared, for example, after emitting one character when the console",
            " *     device is in a consistent state.",
            " *",
            " *   - The 'unsafe_takeover' field is set when a hostile takeover took the",
            " *     console in an unsafe state. The console will stay in the unsafe state",
            " *     until re-initialized.",
            " *",
            " * The acquire mechanism uses three approaches:",
            " *",
            " *   1) Direct acquire when the console is not owned or is owned by a lower",
            " *      priority context and is in a safe state.",
            " *",
            " *   2) Friendly handover mechanism uses a request/grant handshake. It is used",
            " *      when the current owner has lower priority and the console is in an",
            " *      unsafe state.",
            " *",
            " *      The requesting context:",
            " *",
            " *        a) Sets its priority into the 'req_prio' field.",
            " *",
            " *        b) Waits (with a timeout) for the owning context to unlock the",
            " *           console.",
            " *",
            " *        c) Takes the lock and clears the 'req_prio' field.",
            " *",
            " *      The owning context:",
            " *",
            " *        a) Observes the 'req_prio' field set on exit from the unsafe",
            " *           console state.",
            " *",
            " *        b) Gives up console ownership by clearing the 'prio' field.",
            " *",
            " *   3) Unsafe hostile takeover allows to take over the lock even when the",
            " *      console is an unsafe state. It is used only in panic() by the final",
            " *      attempt to flush consoles in a try and hope mode.",
            " *",
            " *      Note that separate record buffers are used in panic(). As a result,",
            " *      the messages can be read and formatted without any risk even after",
            " *      using the hostile takeover in unsafe state.",
            " *",
            " * The release function simply clears the 'prio' field.",
            " *",
            " * All operations on @console::nbcon_state are atomic cmpxchg based to",
            " * handle concurrency.",
            " *",
            " * The acquire/release functions implement only minimal policies:",
            " *",
            " *   - Preference for higher priority contexts.",
            " *   - Protection of the panic CPU.",
            " *",
            " * All other policy decisions must be made at the call sites:",
            " *",
            " *   - What is marked as an unsafe section.",
            " *   - Whether to spin-wait if there is already an owner and the console is",
            " *     in an unsafe state.",
            " *   - Whether to attempt an unsafe hostile takeover.",
            " *",
            " * The design allows to implement the well known:",
            " *",
            " *     acquire()",
            " *     output_one_printk_record()",
            " *     release()",
            " *",
            " * The output of one printk record might be interrupted with a higher priority",
            " * context. The new owner is supposed to reprint the entire interrupted record",
            " * from scratch.",
            " */",
            "",
            "/**",
            " * nbcon_state_set - Helper function to set the console state",
            " * @con:\tConsole to update",
            " * @new:\tThe new state to write",
            " *",
            " * Only to be used when the console is not yet or no longer visible in the",
            " * system. Otherwise use nbcon_state_try_cmpxchg().",
            " */"
          ],
          "function_name": null,
          "description": "定义了非阻塞控制台（nbcon）的状态管理和序列号操作函数，提供设置、读取和原子比较交换操作，用于维护控制台锁状态及记录序列号，支持多优先级抢占式控制台访问策略。",
          "similarity": 0.5416755080223083
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 1619,
          "end_line": 1720,
          "content": [
            "void nbcon_atomic_flush_unsafe(void)",
            "{",
            "\t__nbcon_atomic_flush_pending(prb_next_reserve_seq(prb), true);",
            "}",
            "void nbcon_cpu_emergency_enter(void)",
            "{",
            "\tunsigned int *cpu_emergency_nesting;",
            "",
            "\tpreempt_disable();",
            "",
            "\tcpu_emergency_nesting = nbcon_get_cpu_emergency_nesting();",
            "\t(*cpu_emergency_nesting)++;",
            "}",
            "void nbcon_cpu_emergency_exit(void)",
            "{",
            "\tunsigned int *cpu_emergency_nesting;",
            "",
            "\tcpu_emergency_nesting = nbcon_get_cpu_emergency_nesting();",
            "",
            "\tif (!WARN_ON_ONCE(*cpu_emergency_nesting == 0))",
            "\t\t(*cpu_emergency_nesting)--;",
            "",
            "\tpreempt_enable();",
            "}",
            "bool nbcon_alloc(struct console *con)",
            "{",
            "\tstruct nbcon_state state = { };",
            "",
            "\t/* The write_thread() callback is mandatory. */",
            "\tif (WARN_ON(!con->write_thread))",
            "\t\treturn false;",
            "",
            "\trcuwait_init(&con->rcuwait);",
            "\tinit_irq_work(&con->irq_work, nbcon_irq_work);",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_prev_seq), -1UL);",
            "\tnbcon_state_set(con, &state);",
            "",
            "\t/*",
            "\t * Initialize @nbcon_seq to the highest possible sequence number so",
            "\t * that practically speaking it will have nothing to print until a",
            "\t * desired initial sequence number has been set via nbcon_seq_force().",
            "\t */",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_seq), ULSEQ_MAX(prb));",
            "",
            "\tif (con->flags & CON_BOOT) {",
            "\t\t/*",
            "\t\t * Boot console printing is synchronized with legacy console",
            "\t\t * printing, so boot consoles can share the same global printk",
            "\t\t * buffers.",
            "\t\t */",
            "\t\tcon->pbufs = &printk_shared_pbufs;",
            "\t} else {",
            "\t\tcon->pbufs = kmalloc(sizeof(*con->pbufs), GFP_KERNEL);",
            "\t\tif (!con->pbufs) {",
            "\t\t\tcon_printk(KERN_ERR, con, \"failed to allocate printing buffer\\n\");",
            "\t\t\treturn false;",
            "\t\t}",
            "",
            "\t\tif (printk_kthreads_running) {",
            "\t\t\tif (!nbcon_kthread_create(con)) {",
            "\t\t\t\tkfree(con->pbufs);",
            "\t\t\t\tcon->pbufs = NULL;",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "void nbcon_free(struct console *con)",
            "{",
            "\tstruct nbcon_state state = { };",
            "",
            "\tif (printk_kthreads_running)",
            "\t\tnbcon_kthread_stop(con);",
            "",
            "\tnbcon_state_set(con, &state);",
            "",
            "\t/* Boot consoles share global printk buffers. */",
            "\tif (!(con->flags & CON_BOOT))",
            "\t\tkfree(con->pbufs);",
            "",
            "\tcon->pbufs = NULL;",
            "}",
            "bool nbcon_device_try_acquire(struct console *con)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(con, nbcon_device_ctxt);",
            "",
            "\tcant_migrate();",
            "",
            "\tmemset(ctxt, 0, sizeof(*ctxt));",
            "\tctxt->console\t= con;",
            "\tctxt->prio\t= NBCON_PRIO_NORMAL;",
            "",
            "\tif (!nbcon_context_try_acquire(ctxt))",
            "\t\treturn false;",
            "",
            "\tif (!nbcon_context_enter_unsafe(ctxt))",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "nbcon_atomic_flush_unsafe, nbcon_cpu_emergency_enter, nbcon_cpu_emergency_exit, nbcon_alloc, nbcon_free, nbcon_device_try_acquire",
          "description": "包含CPU紧急模式的嵌套计数器增减接口，控制台资源分配释放逻辑(nbcon_alloc/free)，以及设备抢占尝试函数nbcon_device_try_acquire，用于协调控制台设备的并发访问。",
          "similarity": 0.5055211186408997
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 524,
          "end_line": 629,
          "content": [
            "static int nbcon_context_try_acquire_hostile(struct nbcon_context *ctxt,",
            "\t\t\t\t\t     struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\tif (!ctxt->allow_unsafe_takeover)",
            "\t\treturn -EPERM;",
            "",
            "\t/* Ensure caller is allowed to perform unsafe hostile takeovers. */",
            "\tif (WARN_ON_ONCE(ctxt->prio != NBCON_PRIO_PANIC))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Check that try_acquire_direct() and try_acquire_handover() returned",
            "\t * -EBUSY in the right situation.",
            "\t */",
            "\tWARN_ON_ONCE(ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio);",
            "\tWARN_ON_ONCE(cur->unsafe != true);",
            "",
            "\tdo {",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.cpu\t\t\t= cpu;",
            "\t\tnew.prio\t\t= ctxt->prio;",
            "\t\tnew.unsafe\t\t|= cur->unsafe_takeover;",
            "\t\tnew.unsafe_takeover\t|= cur->unsafe;",
            "",
            "\t} while (!nbcon_state_try_cmpxchg(con, cur, &new));",
            "",
            "\treturn 0;",
            "}",
            "static bool nbcon_context_try_acquire(struct nbcon_context *ctxt)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "\tint err;",
            "",
            "\tnbcon_state_read(con, &cur);",
            "try_again:",
            "\terr = nbcon_context_try_acquire_direct(ctxt, &cur);",
            "\tif (err != -EBUSY)",
            "\t\tgoto out;",
            "",
            "\terr = nbcon_context_try_acquire_handover(ctxt, &cur);",
            "\tif (err == -EAGAIN)",
            "\t\tgoto try_again;",
            "\tif (err != -EBUSY)",
            "\t\tgoto out;",
            "",
            "\terr = nbcon_context_try_acquire_hostile(ctxt, &cur);",
            "out:",
            "\tif (err)",
            "\t\treturn false;",
            "",
            "\t/* Acquire succeeded. */",
            "",
            "\t/* Assign the appropriate buffer for this context. */",
            "\tif (atomic_read(&panic_cpu) == cpu)",
            "\t\tctxt->pbufs = &panic_nbcon_pbufs;",
            "\telse",
            "\t\tctxt->pbufs = con->pbufs;",
            "",
            "\t/* Set the record sequence for this context to print. */",
            "\tctxt->seq = nbcon_seq_read(ctxt->console);",
            "",
            "\treturn true;",
            "}",
            "static bool nbcon_owner_matches(struct nbcon_state *cur, int expected_cpu,",
            "\t\t\t\tint expected_prio)",
            "{",
            "\t/*",
            "\t * A similar function, nbcon_waiter_matches(), only deals with",
            "\t * EMERGENCY and PANIC priorities. However, this function must also",
            "\t * deal with the NORMAL priority, which requires additional checks",
            "\t * and constraints.",
            "\t *",
            "\t * For the case where preemption and interrupts are disabled, it is",
            "\t * enough to also verify that the owning CPU has not changed.",
            "\t *",
            "\t * For the case where preemption or interrupts are enabled, an",
            "\t * external synchronization method *must* be used. In particular,",
            "\t * the driver-specific locking mechanism used in device_lock()",
            "\t * (including disabling migration) should be used. It prevents",
            "\t * scenarios such as:",
            "\t *",
            "\t * 1. [Task A] owns a context with NBCON_PRIO_NORMAL on [CPU X] and",
            "\t *    is scheduled out.",
            "\t * 2. Another context takes over the lock with NBCON_PRIO_EMERGENCY",
            "\t *    and releases it.",
            "\t * 3. [Task B] acquires a context with NBCON_PRIO_NORMAL on [CPU X]",
            "\t *    and is scheduled out.",
            "\t * 4. [Task A] gets running on [CPU X] and sees that the console is",
            "\t *    still owned by a task on [CPU X] with NBON_PRIO_NORMAL. Thus",
            "\t *    [Task A] thinks it is the owner when it is not.",
            "\t */",
            "",
            "\tif (cur->prio != expected_prio)",
            "\t\treturn false;",
            "",
            "\tif (cur->cpu != expected_cpu)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "nbcon_context_try_acquire_hostile, nbcon_context_try_acquire, nbcon_owner_matches",
          "description": "处理强制接管（hostile takeover）逻辑，仅限panic优先级使用，标记控制台为永久不安全状态，提供统一的获取入口函数并关联缓冲区选择。",
          "similarity": 0.4919516444206238
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 335,
          "end_line": 473,
          "content": [
            "static int nbcon_context_try_acquire_requested(struct nbcon_context *ctxt,",
            "\t\t\t\t\t       struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\t/* Note that the caller must still remove the request! */",
            "\tif (other_cpu_in_panic())",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Note that the waiter will also change if there was an unsafe",
            "\t * hostile takeover.",
            "\t */",
            "\tif (!nbcon_waiter_matches(cur, ctxt->prio))",
            "\t\treturn -EPERM;",
            "",
            "\t/* If still locked, caller should continue waiting. */",
            "\tif (cur->prio != NBCON_PRIO_NONE)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * The previous owner should have never released ownership",
            "\t * in an unsafe region.",
            "\t */",
            "\tWARN_ON_ONCE(cur->unsafe);",
            "",
            "\tnew.atom = cur->atom;",
            "\tnew.prio\t= ctxt->prio;",
            "\tnew.req_prio\t= NBCON_PRIO_NONE;",
            "\tnew.unsafe\t= cur->unsafe_takeover;",
            "\tnew.cpu\t\t= cpu;",
            "",
            "\tif (!nbcon_state_try_cmpxchg(con, cur, &new)) {",
            "\t\t/*",
            "\t\t * The acquire could fail only when it has been taken",
            "\t\t * over by a higher priority context.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(nbcon_waiter_matches(cur, ctxt->prio));",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* Handover success. This context now owns the console. */",
            "\treturn 0;",
            "}",
            "static int nbcon_context_try_acquire_handover(struct nbcon_context *ctxt,",
            "\t\t\t\t\t      struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "\tint timeout;",
            "\tint request_err = -EBUSY;",
            "",
            "\t/*",
            "\t * Check that the handover is called when the direct acquire failed",
            "\t * with -EBUSY.",
            "\t */",
            "\tWARN_ON_ONCE(ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio);",
            "\tWARN_ON_ONCE(!cur->unsafe);",
            "",
            "\t/* Handover is not possible on the same CPU. */",
            "\tif (cur->cpu == cpu)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * Console stays unsafe after an unsafe takeover until re-initialized.",
            "\t * Waiting is not going to help in this case.",
            "\t */",
            "\tif (cur->unsafe_takeover)",
            "\t\treturn -EBUSY;",
            "",
            "\t/* Is the caller willing to wait? */",
            "\tif (ctxt->spinwait_max_us == 0)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * Setup a request for the handover. The caller should try to acquire",
            "\t * the console directly when the current state has been modified.",
            "\t */",
            "\tnew.atom = cur->atom;",
            "\tnew.req_prio = ctxt->prio;",
            "\tif (!nbcon_state_try_cmpxchg(con, cur, &new))",
            "\t\treturn -EAGAIN;",
            "",
            "\tcur->atom = new.atom;",
            "",
            "\t/* Wait until there is no owner and then acquire the console. */",
            "\tfor (timeout = ctxt->spinwait_max_us; timeout >= 0; timeout--) {",
            "\t\t/* On successful acquire, this request is cleared. */",
            "\t\trequest_err = nbcon_context_try_acquire_requested(ctxt, cur);",
            "\t\tif (!request_err)",
            "\t\t\treturn 0;",
            "",
            "\t\t/*",
            "\t\t * If the acquire should be aborted, it must be ensured",
            "\t\t * that the request is removed before returning to caller.",
            "\t\t */",
            "\t\tif (request_err == -EPERM)",
            "\t\t\tbreak;",
            "",
            "\t\tudelay(1);",
            "",
            "\t\t/* Re-read the state because some time has passed. */",
            "\t\tnbcon_state_read(con, cur);",
            "\t}",
            "",
            "\t/* Timed out or aborted. Carefully remove handover request. */",
            "\tdo {",
            "\t\t/*",
            "\t\t * No need to remove request if there is a new waiter. This",
            "\t\t * can only happen if a higher priority context has taken over",
            "\t\t * the console or the handover request.",
            "\t\t */",
            "\t\tif (!nbcon_waiter_matches(cur, ctxt->prio))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t/* Unset request for handover. */",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.req_prio = NBCON_PRIO_NONE;",
            "\t\tif (nbcon_state_try_cmpxchg(con, cur, &new)) {",
            "\t\t\t/*",
            "\t\t\t * Request successfully unset. Report failure of",
            "\t\t\t * acquiring via handover.",
            "\t\t\t */",
            "\t\t\tcur->atom = new.atom;",
            "\t\t\treturn request_err;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Unable to remove request. Try to acquire in case",
            "\t\t * the owner has released the lock.",
            "\t\t */",
            "\t} while (nbcon_context_try_acquire_requested(ctxt, cur));",
            "",
            "\t/* Lucky timing. The acquire succeeded while removing the request. */",
            "\treturn 0;",
            "}"
          ],
          "function_name": "nbcon_context_try_acquire_requested, nbcon_context_try_acquire_handover",
          "description": "实现友好移交机制，通过设置请求优先级并轮询等待所有者释放，包含超时控制和状态同步，确保高优先级任务可中断低优先级控制台输出。",
          "similarity": 0.44108983874320984
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 834,
          "end_line": 1003,
          "content": [
            "static void nbcon_write_context_set_buf(struct nbcon_write_context *wctxt,",
            "\t\t\t\t\tchar *buf, unsigned int len)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(wctxt, ctxt);",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "",
            "\twctxt->outbuf = buf;",
            "\twctxt->len = len;",
            "\tnbcon_state_read(con, &cur);",
            "\twctxt->unsafe_takeover = cur.unsafe_takeover;",
            "}",
            "bool nbcon_enter_unsafe(struct nbcon_write_context *wctxt)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(wctxt, ctxt);",
            "\tbool is_owner;",
            "",
            "\tis_owner = nbcon_context_enter_unsafe(ctxt);",
            "\tif (!is_owner)",
            "\t\tnbcon_write_context_set_buf(wctxt, NULL, 0);",
            "\treturn is_owner;",
            "}",
            "bool nbcon_exit_unsafe(struct nbcon_write_context *wctxt)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(wctxt, ctxt);",
            "\tbool ret;",
            "",
            "\tret = nbcon_context_exit_unsafe(ctxt);",
            "\tif (!ret)",
            "\t\tnbcon_write_context_set_buf(wctxt, NULL, 0);",
            "\treturn ret;",
            "}",
            "void nbcon_reacquire_nobuf(struct nbcon_write_context *wctxt)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(wctxt, ctxt);",
            "",
            "\twhile (!nbcon_context_try_acquire(ctxt))",
            "\t\tcpu_relax();",
            "",
            "\tnbcon_write_context_set_buf(wctxt, NULL, 0);",
            "}",
            "static bool nbcon_emit_next_record(struct nbcon_write_context *wctxt, bool use_atomic)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(wctxt, ctxt);",
            "\tstruct console *con = ctxt->console;",
            "\tbool is_extended = console_srcu_read_flags(con) & CON_EXTENDED;",
            "\tstruct printk_message pmsg = {",
            "\t\t.pbufs = ctxt->pbufs,",
            "\t};",
            "\tunsigned long con_dropped;",
            "\tstruct nbcon_state cur;",
            "\tunsigned long dropped;",
            "\tunsigned long ulseq;",
            "",
            "\t/*",
            "\t * This function should never be called for consoles that have not",
            "\t * implemented the necessary callback for writing: i.e. legacy",
            "\t * consoles and, when atomic, nbcon consoles with no write_atomic().",
            "\t * Handle it as if ownership was lost and try to continue.",
            "\t *",
            "\t * Note that for nbcon consoles the write_thread() callback is",
            "\t * mandatory and was already checked in nbcon_alloc().",
            "\t */",
            "\tif (WARN_ON_ONCE((use_atomic && !con->write_atomic) ||",
            "\t\t\t !(console_srcu_read_flags(con) & CON_NBCON))) {",
            "\t\tnbcon_context_release(ctxt);",
            "\t\treturn false;",
            "\t}",
            "",
            "\t/*",
            "\t * The printk buffers are filled within an unsafe section. This",
            "\t * prevents NBCON_PRIO_NORMAL and NBCON_PRIO_EMERGENCY from",
            "\t * clobbering each other.",
            "\t */",
            "",
            "\tif (!nbcon_context_enter_unsafe(ctxt))",
            "\t\treturn false;",
            "",
            "\tctxt->backlog = printk_get_next_message(&pmsg, ctxt->seq, is_extended, true);",
            "\tif (!ctxt->backlog)",
            "\t\treturn nbcon_context_exit_unsafe(ctxt);",
            "",
            "\t/*",
            "\t * @con->dropped is not protected in case of an unsafe hostile",
            "\t * takeover. In that situation the update can be racy so",
            "\t * annotate it accordingly.",
            "\t */",
            "\tcon_dropped = data_race(READ_ONCE(con->dropped));",
            "",
            "\tdropped = con_dropped + pmsg.dropped;",
            "\tif (dropped && !is_extended)",
            "\t\tconsole_prepend_dropped(&pmsg, dropped);",
            "",
            "\t/*",
            "\t * If the previous owner was assigned the same record, this context",
            "\t * has taken over ownership and is replaying the record. Prepend a",
            "\t * message to let the user know the record is replayed.",
            "\t */",
            "\tulseq = atomic_long_read(&ACCESS_PRIVATE(con, nbcon_prev_seq));",
            "\tif (__ulseq_to_u64seq(prb, ulseq) == pmsg.seq) {",
            "\t\tconsole_prepend_replay(&pmsg);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Ensure this context is still the owner before trying to",
            "\t\t * update @nbcon_prev_seq. Otherwise the value in @ulseq may",
            "\t\t * not be from the previous owner and instead be some later",
            "\t\t * value from the context that took over ownership.",
            "\t\t */",
            "\t\tnbcon_state_read(con, &cur);",
            "\t\tif (!nbcon_context_can_proceed(ctxt, &cur))",
            "\t\t\treturn false;",
            "",
            "\t\tatomic_long_try_cmpxchg(&ACCESS_PRIVATE(con, nbcon_prev_seq), &ulseq,",
            "\t\t\t\t\t__u64seq_to_ulseq(pmsg.seq));",
            "\t}",
            "",
            "\tif (!nbcon_context_exit_unsafe(ctxt))",
            "\t\treturn false;",
            "",
            "\t/* For skipped records just update seq/dropped in @con. */",
            "\tif (pmsg.outbuf_len == 0)",
            "\t\tgoto update_con;",
            "",
            "\t/* Initialize the write context for driver callbacks. */",
            "\tnbcon_write_context_set_buf(wctxt, &pmsg.pbufs->outbuf[0], pmsg.outbuf_len);",
            "",
            "\tif (use_atomic)",
            "\t\tcon->write_atomic(con, wctxt);",
            "\telse",
            "\t\tcon->write_thread(con, wctxt);",
            "",
            "\tif (!wctxt->outbuf) {",
            "\t\t/*",
            "\t\t * Ownership was lost and reacquired by the driver. Handle it",
            "\t\t * as if ownership was lost.",
            "\t\t */",
            "\t\tnbcon_context_release(ctxt);",
            "\t\treturn false;",
            "\t}",
            "",
            "\t/*",
            "\t * Ownership may have been lost but _not_ reacquired by the driver.",
            "\t * This case is detected and handled when entering unsafe to update",
            "\t * dropped/seq values.",
            "\t */",
            "",
            "\t/*",
            "\t * Since any dropped message was successfully output, reset the",
            "\t * dropped count for the console.",
            "\t */",
            "\tdropped = 0;",
            "update_con:",
            "\t/*",
            "\t * The dropped count and the sequence number are updated within an",
            "\t * unsafe section. This limits update races to the panic context and",
            "\t * allows the panic context to win.",
            "\t */",
            "",
            "\tif (!nbcon_context_enter_unsafe(ctxt))",
            "\t\treturn false;",
            "",
            "\tif (dropped != con_dropped) {",
            "\t\t/* Counterpart to the READ_ONCE() above. */",
            "\t\tWRITE_ONCE(con->dropped, dropped);",
            "\t}",
            "",
            "\tnbcon_seq_try_update(ctxt, pmsg.seq + 1);",
            "",
            "\treturn nbcon_context_exit_unsafe(ctxt);",
            "}"
          ],
          "function_name": "nbcon_write_context_set_buf, nbcon_enter_unsafe, nbcon_exit_unsafe, nbcon_reacquire_nobuf, nbcon_emit_next_record",
          "description": "定义了nbcon_write_context的缓冲区设置及unsafe状态的进入/退出逻辑，用于协调多线程环境下控制台消息的写入竞争，通过nbcon_emit_next_record函数处理消息序列号更新和重放逻辑。",
          "similarity": 0.41253602504730225
        }
      ]
    },
    {
      "source_file": "kernel/locking/osq_lock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:43:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\osq_lock.c`\n\n---\n\n# `locking/osq_lock.c` 技术文档\n\n## 1. 文件概述\n\n`osq_lock.c` 实现了一种专为**乐观自旋（Optimistic Spinning）**设计的轻量级排队自旋锁机制，称为 **OSQ（Optimistic Spin Queue）锁**。该机制主要用于支持如互斥锁（mutex）、读写信号量（rwsem）等**可睡眠锁**在争用时进行乐观自旋，以避免不必要的上下文切换和调度开销。OSQ 锁基于 MCS（Mellor-Crummey and Scott）锁的思想，但针对 Linux 内核的调度和抢占模型进行了优化，利用每个 CPU 的静态 per-CPU 节点结构，确保在禁用抢占的自旋上下文中安全使用。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct optimistic_spin_node`：每个 CPU 对应一个静态节点，包含：\n  - `cpu`：编码后的 CPU 编号（实际值 = CPU ID + 1）\n  - `locked`：布尔标志，表示是否已获得锁\n  - `next`：指向队列中下一个节点的指针\n  - `prev`：指向前一个节点的指针\n- `struct optimistic_spin_queue`：OSQ 锁结构体，仅包含一个原子变量 `tail`，用于指向队列尾部（编码后的 CPU 编号），`OSQ_UNLOCKED_VAL`（值为 0）表示无锁。\n\n### 主要函数\n- `bool osq_lock(struct optimistic_spin_queue *lock)`  \n  尝试获取 OSQ 锁。若成功获得锁或决定放弃自旋（如需要调度或前驱被抢占），返回 `true`；若成功排队但未获得锁且需继续等待，则返回 `false`（实际逻辑中，失败路径最终也返回 `false` 表示未获得锁）。\n  \n- `void osq_unlock(struct optimistic_spin_queue *lock)`  \n  释放 OSQ 锁，唤醒队列中的下一个等待者（若存在）。\n\n- `static inline struct optimistic_spin_node *osq_wait_next(...)`  \n  辅助函数，用于在解锁或取消排队时安全地获取下一个节点，并处理队列尾部的原子更新。\n\n- `encode_cpu()` / `decode_cpu()` / `node_cpu()`  \n  用于在 CPU 编号与 per-CPU 节点指针之间进行编码/解码转换，其中 CPU 编号 0 被编码为 1，以 0 表示“无 CPU”（即锁空闲）。\n\n## 3. 关键实现\n\n### Per-CPU 静态节点设计\n- 每个 CPU 拥有一个静态的 `osq_node`（通过 `DEFINE_PER_CPU_SHARED_ALIGNED` 定义），避免动态分配开销。\n- 由于 OSQ 仅在**禁用抢占**的上下文中使用（如 mutex 的乐观自旋阶段），且**不可在中断上下文调用**，因此 per-CPU 节点的生命周期安全。\n\n### 锁获取流程 (`osq_lock`)\n1. **初始化本地节点**：设置 `locked=0`、`next=NULL`，并确保 `cpu` 字段为当前 CPU 编码值。\n2. **原子交换尾指针**：通过 `atomic_xchg(&lock->tail, curr)` 尝试入队。若原值为 `OSQ_UNLOCKED_VAL`，直接获得锁。\n3. **链接到前驱**：若已有前驱（`prev`），通过 `smp_wmb()` 确保内存顺序后，设置 `prev->next = node`。\n4. **自旋等待**：使用 `smp_cond_load_relaxed()` 等待 `node->locked` 变为 1，或满足退出条件（`need_resched()` 或前驱 CPU 被抢占 `vcpu_is_preempted()`）。\n5. **取消排队（Unqueue）**：若需退出自旋：\n   - **Step A**：尝试将 `prev->next` 置为 `NULL`，断开链接。\n   - **Step B**：调用 `osq_wait_next()` 确定下一个节点，并可能将锁尾指针回退。\n   - **Step C**：若存在 `next`，将其与 `prev` 直接链接，完成队列修复。\n\n### 锁释放流程 (`osq_unlock`)\n1. **快速路径**：若当前 CPU 是唯一持有者（`tail == curr`），直接将 `tail` 设为 `OSQ_UNLOCKED_VAL`。\n2. **慢速路径**：\n   - 若本地节点的 `next` 非空，直接设置 `next->locked = 1` 唤醒后继。\n   - 否则调用 `osq_wait_next()` 获取下一个节点（处理并发取消排队的情况），再唤醒。\n\n### 内存屏障与原子操作\n- 使用 `atomic_xchg`、`atomic_cmpxchg_acquire/release` 确保对 `lock->tail` 的操作具有适当的内存序。\n- `smp_wmb()` 保证在设置 `prev->next` 前，本地节点的初始化对其他 CPU 可见。\n- `WRITE_ONCE`/`READ_ONCE` 防止编译器优化破坏并发访问语义。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：提供 per-CPU 变量支持（`this_cpu_ptr`, `per_cpu_ptr`）。\n  - `<linux/sched.h>`：提供调度相关函数（`need_resched()`）和虚拟 CPU 抢占检测（`vcpu_is_preempted()`）。\n  - `<linux/osq_lock.h>`：定义 `struct optimistic_spin_queue`、`struct optimistic_spin_node` 及 `OSQ_UNLOCKED_VAL`。\n- **架构依赖**：依赖底层架构的原子操作（`atomic_*`）、内存屏障（`smp_wmb`, `smp_load_acquire`）和 CPU ID 获取（`smp_processor_id()`）。\n- **调度器集成**：与内核调度器紧密协作，通过 `need_resched()` 和 `vcpu_is_preempted()` 决定是否继续自旋。\n\n## 5. 使用场景\n\nOSQ 锁主要用于**可睡眠锁的乐观自旋优化**，典型场景包括：\n- **Mutex（互斥锁）**：在 `mutex_spin_on_owner()` 中，若锁持有者正在运行，当前 CPU 会尝试 OSQ 自旋而非立即睡眠。\n- **Rwsem（读写信号量）**：在写者争用时，若满足条件，会使用 OSQ 进行乐观自旋。\n- **其他睡眠锁**：任何希望在锁争用时避免立即进入睡眠、以降低延迟的同步原语。\n\n其核心价值在于：当锁持有者很可能在**另一个 CPU 上运行且未被抢占**时，通过短暂自旋可避免昂贵的上下文切换，提升性能；同时通过 `vcpu_is_preempted()` 检测虚拟化环境中的抢占，避免在持有者已让出 CPU 时无效自旋。",
      "similarity": 0.4778311848640442,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/osq_lock.c",
          "start_line": 213,
          "end_line": 238,
          "content": [
            "void osq_unlock(struct optimistic_spin_queue *lock)",
            "{",
            "\tstruct optimistic_spin_node *node, *next;",
            "\tint curr = encode_cpu(smp_processor_id());",
            "",
            "\t/*",
            "\t * Fast path for the uncontended case.",
            "\t */",
            "\tif (likely(atomic_cmpxchg_release(&lock->tail, curr,",
            "\t\t\t\t\t  OSQ_UNLOCKED_VAL) == curr))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Second most likely case.",
            "\t */",
            "\tnode = this_cpu_ptr(&osq_node);",
            "\tnext = xchg(&node->next, NULL);",
            "\tif (next) {",
            "\t\tWRITE_ONCE(next->locked, 1);",
            "\t\treturn;",
            "\t}",
            "",
            "\tnext = osq_wait_next(lock, node, NULL);",
            "\tif (next)",
            "\t\tWRITE_ONCE(next->locked, 1);",
            "}"
          ],
          "function_name": "osq_unlock",
          "description": "实现osq_unlock函数，处理锁的释放。通过原子比较交换操作快速处理无竞争情况，否则查找并唤醒下一个等待节点，确保锁状态的正确性与线程安全。",
          "similarity": 0.4056483805179596
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/osq_lock.c",
          "start_line": 20,
          "end_line": 149,
          "content": [
            "static inline int encode_cpu(int cpu_nr)",
            "{",
            "\treturn cpu_nr + 1;",
            "}",
            "static inline int node_cpu(struct optimistic_spin_node *node)",
            "{",
            "\treturn node->cpu - 1;",
            "}",
            "bool osq_lock(struct optimistic_spin_queue *lock)",
            "{",
            "\tstruct optimistic_spin_node *node = this_cpu_ptr(&osq_node);",
            "\tstruct optimistic_spin_node *prev, *next;",
            "\tint curr = encode_cpu(smp_processor_id());",
            "\tint old;",
            "",
            "\tnode->locked = 0;",
            "\tnode->next = NULL;",
            "\t/*",
            "\t * After this cpu member is initialized for the first time, it",
            "\t * would no longer change in fact. That could avoid cache misses",
            "\t * when spin and access the cpu member by other CPUs.",
            "\t */",
            "\tif (node->cpu != curr)",
            "\t\tnode->cpu = curr;",
            "",
            "\t/*",
            "\t * We need both ACQUIRE (pairs with corresponding RELEASE in",
            "\t * unlock() uncontended, or fastpath) and RELEASE (to publish",
            "\t * the node fields we just initialised) semantics when updating",
            "\t * the lock tail.",
            "\t */",
            "\told = atomic_xchg(&lock->tail, curr);",
            "\tif (old == OSQ_UNLOCKED_VAL)",
            "\t\treturn true;",
            "",
            "\tprev = decode_cpu(old);",
            "\tnode->prev = prev;",
            "",
            "\t/*",
            "\t * osq_lock()\t\t\tunqueue",
            "\t *",
            "\t * node->prev = prev\t\tosq_wait_next()",
            "\t * WMB\t\t\t\tMB",
            "\t * prev->next = node\t\tnext->prev = prev // unqueue-C",
            "\t *",
            "\t * Here 'node->prev' and 'next->prev' are the same variable and we need",
            "\t * to ensure these stores happen in-order to avoid corrupting the list.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tWRITE_ONCE(prev->next, node);",
            "",
            "\t/*",
            "\t * Normally @prev is untouchable after the above store; because at that",
            "\t * moment unlock can proceed and wipe the node element from stack.",
            "\t *",
            "\t * However, since our nodes are static per-cpu storage, we're",
            "\t * guaranteed their existence -- this allows us to apply",
            "\t * cmpxchg in an attempt to undo our queueing.",
            "\t */",
            "",
            "\t/*",
            "\t * Wait to acquire the lock or cancellation. Note that need_resched()",
            "\t * will come with an IPI, which will wake smp_cond_load_relaxed() if it",
            "\t * is implemented with a monitor-wait. vcpu_is_preempted() relies on",
            "\t * polling, be careful.",
            "\t */",
            "\tif (smp_cond_load_relaxed(&node->locked, VAL || need_resched() ||",
            "\t\t\t\t  vcpu_is_preempted(node_cpu(node->prev))))",
            "\t\treturn true;",
            "",
            "\t/* unqueue */",
            "\t/*",
            "\t * Step - A  -- stabilize @prev",
            "\t *",
            "\t * Undo our @prev->next assignment; this will make @prev's",
            "\t * unlock()/unqueue() wait for a next pointer since @lock points to us",
            "\t * (or later).",
            "\t */",
            "",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * cpu_relax() below implies a compiler barrier which would",
            "\t\t * prevent this comparison being optimized away.",
            "\t\t */",
            "\t\tif (data_race(prev->next) == node &&",
            "\t\t    cmpxchg(&prev->next, node, NULL) == node)",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * We can only fail the cmpxchg() racing against an unlock(),",
            "\t\t * in which case we should observe @node->locked becoming",
            "\t\t * true.",
            "\t\t */",
            "\t\tif (smp_load_acquire(&node->locked))",
            "\t\t\treturn true;",
            "",
            "\t\tcpu_relax();",
            "",
            "\t\t/*",
            "\t\t * Or we race against a concurrent unqueue()'s step-B, in which",
            "\t\t * case its step-C will write us a new @node->prev pointer.",
            "\t\t */",
            "\t\tprev = READ_ONCE(node->prev);",
            "\t}",
            "",
            "\t/*",
            "\t * Step - B -- stabilize @next",
            "\t *",
            "\t * Similar to unlock(), wait for @node->next or move @lock from @node",
            "\t * back to @prev.",
            "\t */",
            "",
            "\tnext = osq_wait_next(lock, node, prev);",
            "\tif (!next)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Step - C -- unlink",
            "\t *",
            "\t * @prev is stable because its still waiting for a new @prev->next",
            "\t * pointer, @next is stable because our @node->next pointer is NULL and",
            "\t * it will wait in Step-A.",
            "\t */",
            "",
            "\tWRITE_ONCE(next->prev, prev);",
            "\tWRITE_ONCE(prev->next, next);",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "encode_cpu, node_cpu, osq_lock",
          "description": "实现osq_lock函数，负责获取乐观自旋锁。通过原子操作将当前节点插入队列，利用内存屏障保证顺序一致性，并通过循环等待条件满足或被唤醒，最终完成锁的获取过程。",
          "similarity": 0.3793208599090576
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/osq_lock.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/percpu.h>",
            "#include <linux/sched.h>",
            "#include <linux/osq_lock.h>",
            "",
            "/*",
            " * An MCS like lock especially tailored for optimistic spinning for sleeping",
            " * lock implementations (mutex, rwsem, etc).",
            " *",
            " * Using a single mcs node per CPU is safe because sleeping locks should not be",
            " * called from interrupt context and we have preemption disabled while",
            " * spinning.",
            " */",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct optimistic_spin_node, osq_node);",
            "",
            "/*",
            " * We use the value 0 to represent \"no CPU\", thus the encoded value",
            " * will be the CPU number incremented by 1.",
            " */"
          ],
          "function_name": null,
          "description": "定义全局的per-CPU乐观自旋节点osq_node，用于支持多CPU环境下乐观自旋锁的实现。通过encode_cpu和node_cpu函数处理CPU编号转换，为后续锁操作提供基础设施。",
          "similarity": 0.3665141463279724
        }
      ]
    },
    {
      "source_file": "kernel/rcu/tree_plugin.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:48:59\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\tree_plugin.h`\n\n---\n\n# `rcu/tree_plugin.h` 技术文档\n\n## 1. 文件概述\n\n`rcu/tree_plugin.h` 是 Linux 内核中 **树形 RCU（Read-Copy Update）机制** 的内部头文件，用于实现基于分层树结构的 RCU 互斥机制。该文件定义了适用于 **经典 RCU** 或 **可抢占 RCU（PREEMPT_RCU）** 的内部非公开接口和辅助函数，主要服务于 `kernel/rcu/tree.c` 等核心 RCU 实现模块。其核心目标是在大规模 CPU 系统中高效管理宽限期（Grace Period）的检测与回调处理，同时支持 NOCB（No-CBs，即回调卸载）等高级特性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`rcu_rdp_is_offloaded(struct rcu_data *rdp)`**  \n  安全地判断指定 CPU 的 `rcu_data` 是否启用了 NOCB（回调卸载）模式。该函数包含严格的锁依赖检查（通过 `RCU_LOCKDEP_WARN`），确保在读取 `offloaded` 状态时不会因并发修改导致数据不一致。\n\n- **`rcu_bootup_announce_oddness(void)`**  \n  在内核启动阶段检测并打印所有非默认或调试相关的 RCU 配置参数，用于诊断和性能调优。涵盖内容包括：扇出（fanout）设置、回调水位线、FQS（Force Quiescent State）延迟、软中断处理方式、调试选项等。\n\n- **`rcu_bootup_announce(void)`**（仅 `CONFIG_PREEMPT_RCU`）  \n  启动时声明当前使用的是“可抢占的分层 RCU 实现”，并调用 `rcu_bootup_announce_oddness()` 输出配置异常信息。\n\n- **`rcu_preempt_ctxt_queue(struct rcu_node *rnp, struct rcu_data *rdp)`**（仅 `CONFIG_PREEMPT_RCU`）  \n  将当前被抢占且处于 RCU 读侧临界区的任务插入到 `rcu_node` 的阻塞任务链表（`blkd_tasks`）中的合适位置。其插入策略基于当前是否存在普通或加速宽限期（GP/EXP GP），以及当前 CPU 是否被这些宽限期阻塞，以最小化对已有宽限期的不必要阻塞。\n\n### 关键宏定义（仅 `CONFIG_PREEMPT_RCU`）\n\n- **`RCU_GP_TASKS` / `RCU_EXP_TASKS` / `RCU_GP_BLKD` / `RCU_EXP_BLKD`**  \n  用于构建决策表，表示 `rcu_node` 中普通/加速宽限期的等待状态及当前 CPU 的阻塞状态，指导 `rcu_preempt_ctxt_queue()` 的任务插入逻辑。\n\n## 3. 关键实现\n\n### 安全读取 NOCB 状态\n`rcu_rdp_is_offloaded()` 通过 `RCU_LOCKDEP_WARN` 强制要求调用者必须持有以下任一同步原语：\n- `rcu_state.barrier_mutex`\n- CPU 热插拔锁（读/写）\n- 对应 `rdp` 的 NOCB 锁\n- 在本地 CPU 且不可抢占（非 `CONFIG_PREEMPT_COUNT` 或不可抢占上下文）\n- 当前为 NOCB 内核线程  \n这确保了在读取 `rdp->cblist` 的 `offloaded` 标志时，其值不会被并发修改。\n\n### 可抢占 RCU 的任务阻塞队列策略\n在 `CONFIG_PREEMPT_RCU` 下，当任务在 RCU 读侧临界区内被抢占时，需将其加入 `rcu_node->blkd_tasks` 链表。`rcu_preempt_ctxt_queue()` 使用 **状态决策表**（基于 `blkd_state` 的 4 位组合）决定插入位置：\n- **插入链表头部**：当任务不会阻塞任何**已存在的**宽限期（尤其是加速宽限期）时，避免延长已有宽限期。\n- **插入链表尾部**（代码未完整显示，但逻辑隐含）：当任务会阻塞已有宽限期时，需排在末尾以确保正确性。  \n该策略优先保护**加速宽限期**的低延迟特性，即使可能轻微延长普通宽限期。\n\n### 启动配置诊断\n`rcu_bootup_announce_oddness()` 系统性地检查数十个编译时和运行时 RCU 参数，对任何非默认值或启用的调试功能输出 `pr_info` 日志。这为系统管理员和开发者提供了 RCU 行为的透明视图，便于性能分析和问题排查。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `../locking/rtmutex_common.h`：提供 `lockdep_is_cpus_held()` 等锁依赖检查宏。\n  - `rcu_segcblist_is_offloaded()`：来自 RCU 回调段管理模块，用于查询 NOCB 状态。\n  - `rcu_lockdep_is_held_nocb()`、`rcu_current_is_nocb_kthread()`：NOCB 相关的锁依赖和上下文检查函数。\n  - `rcupdate_announce_bootup_oddness()`：来自 `kernel/rcu/update.c`，用于打印通用 RCU 启动信息。\n\n- **配置依赖**：\n  - `CONFIG_PREEMPT_RCU`：启用可抢占 RCU 的特定逻辑（如任务阻塞队列）。\n  - `CONFIG_RCU_TRACE`、`CONFIG_PROVE_RCU`、`CONFIG_RCU_BOOST` 等：控制启动诊断信息的输出。\n  - `CONFIG_HOTPLUG_CPU`：影响 CPU 热插拔锁的检查逻辑。\n\n- **数据结构依赖**：\n  - `struct rcu_data`、`struct rcu_node`：RCU 核心数据结构，定义在 `kernel/rcu/tree.h`。\n  - `rcu_state`：全局 RCU 状态结构体。\n\n## 5. 使用场景\n\n- **内核启动阶段**：  \n  `rcu_bootup_announce()` 和 `rcu_bootup_announce_oddness()` 在 RCU 初始化时被调用，输出配置诊断信息，帮助确认 RCU 子系统按预期配置。\n\n- **NOCB（回调卸载）模式运行时**：  \n  当系统启用 `CONFIG_RCU_NOCB_CPU` 时，`rcu_rdp_is_offloaded()` 被频繁调用（如在回调处理、宽限期推进路径中），以安全判断当前 CPU 的回调是否由专用内核线程处理。\n\n- **可抢占内核中的任务调度**：  \n  在 `CONFIG_PREEMPT_RCU` 系统中，当任务在 RCU 读侧临界区内被抢占时，调度器路径会调用 `rcu_preempt_ctxt_queue()`，将任务加入阻塞链表，确保宽限期能正确等待该任务退出临界区。\n\n- **调试与性能分析**：  \n  启动时的“oddness”日志为 RCU 调优提供依据；`RCU_LOCKDEP_WARN` 等检查帮助开发者发现 RCU 状态访问的同步错误。",
      "similarity": 0.4768858551979065,
      "chunks": []
    }
  ]
}