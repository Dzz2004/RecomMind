{
  "query": "分段与分页的地址映射机制",
  "timestamp": "2025-12-26 00:11:12",
  "retrieved_files": [
    {
      "source_file": "kernel/dma/remap.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:16:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma\\remap.c`\n\n---\n\n# `dma/remap.c` 技术文档\n\n## 1. 文件概述\n\n`dma/remap.c` 是 Linux 内核中用于 DMA（Direct Memory Access）一致性内存管理的辅助实现文件。该文件提供了一组通用函数，用于将物理页面（`struct page`）重新映射到内核虚拟地址空间中，并标记为 DMA 一致性映射区域（`VM_DMA_COHERENT`）。这些函数主要用于支持架构无关的 DMA 映射操作，特别是在需要将非连续物理页或连续物理内存块映射为连续虚拟地址的场景中。\n\n## 2. 核心功能\n\n### 主要函数：\n\n- **`dma_common_find_pages(void *cpu_addr)`**  \n  根据给定的内核虚拟地址 `cpu_addr`，查找其对应的 `struct page` 数组。该地址必须是由 `dma_common_*_remap` 系列函数创建的、标记为 `VM_DMA_COHERENT` 的 vmalloc 区域。\n\n- **`dma_common_pages_remap(struct page **pages, size_t size, pgprot_t prot, const void *caller)`**  \n  将一组非连续的物理页面（由 `pages` 数组指定）重新映射为一个连续的内核虚拟地址区域，并标记为 `VM_DMA_COHERENT`。该函数不可在原子上下文（如中断处理程序）中调用。\n\n- **`dma_common_contiguous_remap(struct page *page, size_t size, pgprot_t prot, const void *caller)`**  \n  将一段物理上连续的内存区域（起始于 `page`，长度为 `size`）重新映射为连续的内核虚拟地址，并标记为 `VM_DMA_COHERENT`。内部会临时分配一个 `struct page *` 数组来描述每一页。\n\n- **`dma_common_free_remap(void *cpu_addr, size_t size)`**  \n  释放由上述 `remap` 函数创建的虚拟映射区域。会验证该区域是否为有效的 `VM_DMA_COHERENT` 类型，若无效则触发警告。\n\n### 数据结构：\n- 无显式定义新数据结构，但依赖于内核已有的：\n  - `struct page`\n  - `struct vm_struct`\n  - `pgprot_t`\n\n## 3. 关键实现\n\n- **VM 区域标识**：所有通过 `dma_common_*_remap` 创建的映射区域均使用 `VM_DMA_COHERENT` 标志，以便后续可通过 `find_vm_area()` 识别其为 DMA 一致性映射区域。\n  \n- **页面数组管理**：\n  - `dma_common_pages_remap` 直接使用传入的 `pages` 数组，并在成功 `vmap` 后将其保存到 `vm_struct->pages` 字段中，供 `dma_common_find_pages` 查询。\n  - `dma_common_contiguous_remap` 针对连续物理内存，动态构建 `pages` 数组（使用 `kvmalloc_array`），调用 `vmap` 后立即释放该临时数组，但 `vmap` 内部会复制页面指针。\n\n- **内存分配与映射**：\n  - 使用 `vmap()` 将物理页面映射到 vmalloc 区域，确保返回的虚拟地址在内核空间连续。\n  - 使用 `kvmalloc_array`/`kvfree` 进行临时内存分配，兼顾大内存分配的可靠性（可回退到 vmalloc）。\n\n- **错误处理与调试**：\n  - `dma_common_free_remap` 中包含 `WARN(1, ...)`，用于检测非法释放操作，提升调试能力。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/dma-map-ops.h>`：提供 DMA 映射操作相关的类型和接口。\n  - `<linux/slab.h>`：提供 `kvmalloc_array`/`kvfree` 等内存分配接口。\n  - `<linux/vmalloc.h>`：提供 `vmap`、`vunmap`、`find_vm_area` 等 vmalloc 区域管理函数。\n\n- **内核子系统依赖**：\n  - **VMALLOC 子系统**：依赖 `vmap`/`vunmap` 实现虚拟地址映射。\n  - **内存管理子系统（MM）**：依赖 `struct page` 和页面操作函数（如 `nth_page`）。\n  - **DMA 子系统**：作为 `dma_map_ops` 的底层支持，被架构特定的 DMA 实现（如 ARM、ARM64）调用。\n\n## 5. 使用场景\n\n- **DMA 一致性内存分配**：当设备驱动需要分配大块 DMA 一致性内存，且底层无法直接提供连续虚拟地址时，可通过此模块将物理页重新映射为连续虚拟地址。\n  \n- **IOMMU 或非一致性缓存架构支持**：在缓存不一致的系统（如某些 ARM 平台）上，为保证 CPU 与设备对内存视图一致，需使用特殊页表属性（`pgprot_t`）进行映射，本模块提供通用封装。\n\n- **通用 DMA 映射框架后端**：作为 `dma_map_ops` 中 `alloc`/`free` 等操作的辅助实现，被 `dma-direct.c`、`arm_dma_alloc.c` 等架构相关代码调用。\n\n- **调试与验证**：通过 `VM_DMA_COHERENT` 标志和 `WARN` 机制，帮助检测非法的 DMA 内存释放操作，提升系统稳定性。",
      "similarity": 0.6219407320022583,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/dma/remap.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (c) 2014 The Linux Foundation",
            " */",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "",
            "struct page **dma_common_find_pages(void *cpu_addr)",
            "{",
            "\tstruct vm_struct *area = find_vm_area(cpu_addr);",
            "",
            "\tif (!area || area->flags != VM_DMA_COHERENT)",
            "\t\treturn NULL;",
            "\treturn area->pages;",
            "}",
            "",
            "/*",
            " * Remaps an array of PAGE_SIZE pages into another vm_area.",
            " * Cannot be used in non-sleeping contexts",
            " */",
            "void *dma_common_pages_remap(struct page **pages, size_t size,",
            "\t\t\t pgprot_t prot, const void *caller)",
            "{",
            "\tvoid *vaddr;",
            "",
            "\tvaddr = vmap(pages, PAGE_ALIGN(size) >> PAGE_SHIFT,",
            "\t\t     VM_DMA_COHERENT, prot);",
            "\tif (vaddr)",
            "\t\tfind_vm_area(vaddr)->pages = pages;",
            "\treturn vaddr;",
            "}",
            "",
            "/*",
            " * Remaps an allocated contiguous region into another vm_area.",
            " * Cannot be used in non-sleeping contexts",
            " */",
            "void *dma_common_contiguous_remap(struct page *page, size_t size,",
            "\t\t\tpgprot_t prot, const void *caller)",
            "{",
            "\tint count = PAGE_ALIGN(size) >> PAGE_SHIFT;",
            "\tstruct page **pages;",
            "\tvoid *vaddr;",
            "\tint i;",
            "",
            "\tpages = kvmalloc_array(count, sizeof(struct page *), GFP_KERNEL);",
            "\tif (!pages)",
            "\t\treturn NULL;",
            "\tfor (i = 0; i < count; i++)",
            "\t\tpages[i] = nth_page(page, i);",
            "\tvaddr = vmap(pages, count, VM_DMA_COHERENT, prot);",
            "\tkvfree(pages);",
            "",
            "\treturn vaddr;",
            "}",
            "",
            "/*",
            " * Unmaps a range previously mapped by dma_common_*_remap",
            " */"
          ],
          "function_name": null,
          "description": "定义dma_common_find_pages函数，通过查找VM_DMA_COHERENT标记的vm_area结构体，返回对应页面数组指针",
          "similarity": 0.5501736402511597
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/dma/remap.c",
          "start_line": 60,
          "end_line": 70,
          "content": [
            "void dma_common_free_remap(void *cpu_addr, size_t size)",
            "{",
            "\tstruct vm_struct *area = find_vm_area(cpu_addr);",
            "",
            "\tif (!area || area->flags != VM_DMA_COHERENT) {",
            "\t\tWARN(1, \"trying to free invalid coherent area: %p\\n\", cpu_addr);",
            "\t\treturn;",
            "\t}",
            "",
            "\tvunmap(cpu_addr);",
            "}"
          ],
          "function_name": "dma_common_free_remap",
          "description": "实现dma_common_free_remap函数，验证虚拟地址所属的vm_area结构体标志后，调用vunmap释放对应DMA一致性区域的映射",
          "similarity": 0.5364396572113037
        }
      ]
    },
    {
      "source_file": "mm/sparse-vmemmap.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:24:15\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sparse-vmemmap.c`\n\n---\n\n# sparse-vmemmap.c 技术文档\n\n## 1. 文件概述\n\n`sparse-vmemmap.c` 是 Linux 内核中用于实现 **虚拟内存映射（Virtual Memory Map, vmemmap）** 的核心文件之一。该机制为稀疏内存模型（sparse memory model）提供支持，使得 `pfn_to_page()`、`page_to_pfn()`、`virt_to_page()` 和 `page_address()` 等页管理原语可以通过简单的地址偏移计算实现，而无需访问内存中的间接结构。\n\n在支持 1:1 物理地址映射的架构上，vmemmap 利用已有的页表和 TLB 映射，仅需额外分配少量页面来构建一个连续的虚拟地址空间，用于存放所有物理页对应的 `struct page` 结构体。此文件主要负责在系统初始化阶段动态填充 vmemmap 所需的页表项，并支持使用替代内存分配器（如 ZONE_DEVICE 提供的 altmap）进行底层内存分配。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `vmemmap_alloc_block()` | 分配用于 vmemmap 或其页表的内存块，优先使用 slab 分配器，早期启动阶段回退到 memblock |\n| `vmemmap_alloc_block_buf()` | 封装分配接口，支持通过 `vmem_altmap` 指定替代内存源 |\n| `altmap_alloc_block_buf()` | 使用 `vmem_altmap` 提供的预留内存区域分配 vmemmap 缓冲区 |\n| `vmemmap_populate_address()` | 为指定虚拟地址填充完整的四级（或五级）页表路径（PGD → P4D → PUD → PMD → PTE） |\n| `vmemmap_populate_range()` | 批量填充一段虚拟地址范围的页表 |\n| `vmemmap_populate_basepages()` | 公开接口，用于以基本页（4KB）粒度填充 vmemmap 区域 |\n| `vmemmap_pte_populate()` / `vmemmap_pmd_populate()` / ... | 各级页表项的按需填充函数 |\n| `vmemmap_verify()` | 验证分配的 `struct page` 是否位于预期 NUMA 节点，避免跨节点性能问题 |\n\n### 关键数据结构\n\n- **`struct vmem_altmap`**  \n  由外部（如 device-dax 或 pmem 驱动）提供，描述一块预留的物理内存区域，可用于替代常规内存分配 vmemmap 所需的 `struct page` 存储空间。包含字段：\n  - `base_pfn`：起始物理页帧号\n  - `reserve`：保留页数（通常用于元数据）\n  - `alloc`：已分配页数\n  - `align`：对齐填充页数\n  - `free`：总可用页数\n\n## 3. 关键实现\n\n### 内存分配策略\n- **运行时分配**：当 slab 分配器可用时（`slab_is_available()` 返回 true），使用 `alloc_pages_node()` 分配高阶页面。\n- **早期启动分配**：在 slab 不可用时，调用 `memblock_alloc_try_nid_raw()` 从 bootmem 分配器获取内存。\n- **替代内存支持**：通过 `vmem_altmap` 参数，允许将 `struct page` 存储在设备内存（如持久内存）中，减少对系统 DRAM 的占用。\n\n### 页表填充机制\n- 采用 **按需填充（on-demand population）** 策略，仅在访问 vmemmap 虚拟地址时构建对应页表。\n- 支持完整的 x86_64 / ARM64 等架构的多级页表（PGD → P4D → PUD → PMD → PTE）。\n- 每级页表项若为空（`*_none()`），则分配一个 4KB 页面作为下一级页表，并通过 `*_populate()` 填充。\n- 叶子 PTE 指向实际存储 `struct page` 的物理页面，权限设为 `PAGE_KERNEL`。\n\n### 对齐与验证\n- `altmap_alloc_block_buf()` 中实现 **动态对齐**：根据请求大小计算所需对齐边界（2 的幂），确保分配地址满足页表项对齐要求。\n- `vmemmap_verify()` 在调试/警告模式下检查分配的 `struct page` 所在 NUMA 节点是否与目标节点“本地”，避免远程访问开销。\n\n### 架构钩子函数\n- 提供弱符号（`__weak`）钩子如 `kernel_pte_init()`、`pmd_init()` 等，允许特定架构在分配页表页面后执行初始化操作（如设置特殊属性位）。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：\n  - `<linux/mm.h>`、`<linux/mmzone.h>`：页帧、内存域、NUMA 节点管理\n  - `<linux/memblock.h>`：早期内存分配\n  - `<linux/vmalloc.h>`：虚拟内存管理（间接）\n- **页表操作**：\n  - `<asm/pgalloc.h>`：架构相关的页表分配/释放\n  - 依赖 `pgd_offset_k()`、`pud_populate()` 等架构宏/函数\n- **稀疏内存模型**：\n  - 与 `sparse.c` 协同工作，`sparse_buffer_alloc()` 用于复用预分配的缓冲区\n- **设备内存支持**：\n  - `<linux/memremap.h>`：`vmem_altmap` 定义，用于 ZONE_DEVICE 场景\n\n## 5. 使用场景\n\n1. **稀疏内存模型初始化**  \n   在 `sparse_init()` 过程中，为每个内存 section 调用 `vmemmap_populate_basepages()` 填充对应的 `struct page` 数组。\n\n2. **热插拔内存（Memory Hotplug）**  \n   新增内存区域时，动态填充其 vmemmap 映射，使新页可被内核页管理器识别。\n\n3. **持久内存（Persistent Memory）/ DAX 设备**  \n   通过 `vmem_altmap` 将 `struct page` 存储在设备自身内存中，避免消耗系统 RAM，典型用于 `fsdax` 或 `device-dax`。\n\n4. **大页优化（未完成功能）**  \n   文件末尾存在 `vmemmap_populate_hugepages()` 声明，表明未来可能支持使用透明大页（如 2MB PMD）映射 vmemmap，减少 TLB 压力（当前实现可能不完整或依赖架构支持）。\n\n5. **NUMA 感知分配**  \n   所有分配均指定目标 NUMA 节点（`node` 参数），确保 `struct page` 尽可能靠近其所描述的物理内存，优化访问延迟。",
      "similarity": 0.6153538227081299,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/sparse-vmemmap.c",
          "start_line": 91,
          "end_line": 203,
          "content": [
            "static unsigned long __meminit vmem_altmap_next_pfn(struct vmem_altmap *altmap)",
            "{",
            "\treturn altmap->base_pfn + altmap->reserve + altmap->alloc",
            "\t\t+ altmap->align;",
            "}",
            "static unsigned long __meminit vmem_altmap_nr_free(struct vmem_altmap *altmap)",
            "{",
            "\tunsigned long allocated = altmap->alloc + altmap->align;",
            "",
            "\tif (altmap->free > allocated)",
            "\t\treturn altmap->free - allocated;",
            "\treturn 0;",
            "}",
            "void __meminit vmemmap_verify(pte_t *pte, int node,",
            "\t\t\t\tunsigned long start, unsigned long end)",
            "{",
            "\tunsigned long pfn = pte_pfn(ptep_get(pte));",
            "\tint actual_node = early_pfn_to_nid(pfn);",
            "",
            "\tif (node_distance(actual_node, node) > LOCAL_DISTANCE)",
            "\t\tpr_warn_once(\"[%lx-%lx] potential offnode page_structs\\n\",",
            "\t\t\tstart, end - 1);",
            "}",
            "void __weak __meminit kernel_pte_init(void *addr)",
            "{",
            "}",
            "void __weak __meminit pmd_init(void *addr)",
            "{",
            "}",
            "void __weak __meminit pud_init(void *addr)",
            "{",
            "}",
            "static int __meminit vmemmap_populate_range(unsigned long start,",
            "\t\t\t\t\t    unsigned long end, int node,",
            "\t\t\t\t\t    struct vmem_altmap *altmap,",
            "\t\t\t\t\t    struct page *reuse)",
            "{",
            "\tunsigned long addr = start;",
            "\tpte_t *pte;",
            "",
            "\tfor (; addr < end; addr += PAGE_SIZE) {",
            "\t\tpte = vmemmap_populate_address(addr, node, altmap, reuse);",
            "\t\tif (!pte)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int __meminit vmemmap_populate_basepages(unsigned long start, unsigned long end,",
            "\t\t\t\t\t int node, struct vmem_altmap *altmap)",
            "{",
            "\treturn vmemmap_populate_range(start, end, node, altmap, NULL);",
            "}",
            "void __weak __meminit vmemmap_set_pmd(pmd_t *pmd, void *p, int node,",
            "\t\t\t\t      unsigned long addr, unsigned long next)",
            "{",
            "}",
            "int __weak __meminit vmemmap_check_pmd(pmd_t *pmd, int node,",
            "\t\t\t\t       unsigned long addr, unsigned long next)",
            "{",
            "\treturn 0;",
            "}",
            "int __meminit vmemmap_populate_hugepages(unsigned long start, unsigned long end,",
            "\t\t\t\t\t int node, struct vmem_altmap *altmap)",
            "{",
            "\tunsigned long addr;",
            "\tunsigned long next;",
            "\tpgd_t *pgd;",
            "\tp4d_t *p4d;",
            "\tpud_t *pud;",
            "\tpmd_t *pmd;",
            "",
            "\tfor (addr = start; addr < end; addr = next) {",
            "\t\tnext = pmd_addr_end(addr, end);",
            "",
            "\t\tpgd = vmemmap_pgd_populate(addr, node);",
            "\t\tif (!pgd)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\tp4d = vmemmap_p4d_populate(pgd, addr, node);",
            "\t\tif (!p4d)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\tpud = vmemmap_pud_populate(p4d, addr, node);",
            "\t\tif (!pud)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\tpmd = pmd_offset(pud, addr);",
            "\t\tif (pmd_none(READ_ONCE(*pmd))) {",
            "\t\t\tvoid *p;",
            "",
            "\t\t\tp = vmemmap_alloc_block_buf(PMD_SIZE, node, altmap);",
            "\t\t\tif (p) {",
            "\t\t\t\tvmemmap_set_pmd(pmd, p, node, addr, next);",
            "\t\t\t\tcontinue;",
            "\t\t\t} else if (altmap) {",
            "\t\t\t\t/*",
            "\t\t\t\t * No fallback: In any case we care about, the",
            "\t\t\t\t * altmap should be reasonably sized and aligned",
            "\t\t\t\t * such that vmemmap_alloc_block_buf() will always",
            "\t\t\t\t * succeed. For consistency with the PTE case,",
            "\t\t\t\t * return an error here as failure could indicate",
            "\t\t\t\t * a configuration issue with the size of the altmap.",
            "\t\t\t\t */",
            "\t\t\t\treturn -ENOMEM;",
            "\t\t\t}",
            "\t\t} else if (vmemmap_check_pmd(pmd, node, addr, next))",
            "\t\t\tcontinue;",
            "\t\tif (vmemmap_populate_basepages(addr, next, node, altmap))",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "vmem_altmap_next_pfn, vmem_altmap_nr_free, vmemmap_verify, kernel_pte_init, pmd_init, pud_init, vmemmap_populate_range, vmemmap_populate_basepages, vmemmap_set_pmd, vmemmap_check_pmd, vmemmap_populate_hugepages",
          "description": "实现了虚拟内存映射验证、页表初始化及大页填充逻辑，包含检查页表项节点一致性、弱函数声明以及递归填充连续地址范围的辅助函数",
          "similarity": 0.589389443397522
        },
        {
          "chunk_id": 2,
          "file_path": "mm/sparse-vmemmap.c",
          "start_line": 377,
          "end_line": 435,
          "content": [
            "static bool __meminit reuse_compound_section(unsigned long start_pfn,",
            "\t\t\t\t\t     struct dev_pagemap *pgmap)",
            "{",
            "\tunsigned long nr_pages = pgmap_vmemmap_nr(pgmap);",
            "\tunsigned long offset = start_pfn -",
            "\t\tPHYS_PFN(pgmap->ranges[pgmap->nr_range].start);",
            "",
            "\treturn !IS_ALIGNED(offset, nr_pages) && nr_pages > PAGES_PER_SUBSECTION;",
            "}",
            "static int __meminit vmemmap_populate_compound_pages(unsigned long start_pfn,",
            "\t\t\t\t\t\t     unsigned long start,",
            "\t\t\t\t\t\t     unsigned long end, int node,",
            "\t\t\t\t\t\t     struct dev_pagemap *pgmap)",
            "{",
            "\tunsigned long size, addr;",
            "\tpte_t *pte;",
            "\tint rc;",
            "",
            "\tif (reuse_compound_section(start_pfn, pgmap)) {",
            "\t\tpte = compound_section_tail_page(start);",
            "\t\tif (!pte)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/*",
            "\t\t * Reuse the page that was populated in the prior iteration",
            "\t\t * with just tail struct pages.",
            "\t\t */",
            "\t\treturn vmemmap_populate_range(start, end, node, NULL,",
            "\t\t\t\t\t      pte_page(ptep_get(pte)));",
            "\t}",
            "",
            "\tsize = min(end - start, pgmap_vmemmap_nr(pgmap) * sizeof(struct page));",
            "\tfor (addr = start; addr < end; addr += size) {",
            "\t\tunsigned long next, last = addr + size;",
            "",
            "\t\t/* Populate the head page vmemmap page */",
            "\t\tpte = vmemmap_populate_address(addr, node, NULL, NULL);",
            "\t\tif (!pte)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/* Populate the tail pages vmemmap page */",
            "\t\tnext = addr + PAGE_SIZE;",
            "\t\tpte = vmemmap_populate_address(next, node, NULL, NULL);",
            "\t\tif (!pte)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/*",
            "\t\t * Reuse the previous page for the rest of tail pages",
            "\t\t * See layout diagram in Documentation/mm/vmemmap_dedup.rst",
            "\t\t */",
            "\t\tnext += PAGE_SIZE;",
            "\t\trc = vmemmap_populate_range(next, last, node, NULL,",
            "\t\t\t\t\t    pte_page(ptep_get(pte)));",
            "\t\tif (rc)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "reuse_compound_section, vmemmap_populate_compound_pages",
          "description": "提供复合页面内存复用机制，通过判断偏移对齐情况决定是否复用上一次迭代产生的尾部页面，从而优化vmentry结构体的内存分配效率",
          "similarity": 0.5452051162719727
        },
        {
          "chunk_id": 0,
          "file_path": "mm/sparse-vmemmap.c",
          "start_line": 1,
          "end_line": 90,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Virtual Memory Map support",
            " *",
            " * (C) 2007 sgi. Christoph Lameter.",
            " *",
            " * Virtual memory maps allow VM primitives pfn_to_page, page_to_pfn,",
            " * virt_to_page, page_address() to be implemented as a base offset",
            " * calculation without memory access.",
            " *",
            " * However, virtual mappings need a page table and TLBs. Many Linux",
            " * architectures already map their physical space using 1-1 mappings",
            " * via TLBs. For those arches the virtual memory map is essentially",
            " * for free if we use the same page size as the 1-1 mappings. In that",
            " * case the overhead consists of a few additional pages that are",
            " * allocated to create a view of memory for vmemmap.",
            " *",
            " * The architecture is expected to provide a vmemmap_populate() function",
            " * to instantiate the mapping.",
            " */",
            "#include <linux/mm.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/memblock.h>",
            "#include <linux/memremap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched.h>",
            "",
            "#include <asm/dma.h>",
            "#include <asm/pgalloc.h>",
            "",
            "/*",
            " * Allocate a block of memory to be used to back the virtual memory map",
            " * or to back the page tables that are used to create the mapping.",
            " * Uses the main allocators if they are available, else bootmem.",
            " */",
            "",
            "static void * __ref __earlyonly_bootmem_alloc(int node,",
            "\t\t\t\tunsigned long size,",
            "\t\t\t\tunsigned long align,",
            "\t\t\t\tunsigned long goal)",
            "{",
            "\treturn memblock_alloc_try_nid_raw(size, align, goal,",
            "\t\t\t\t\t       MEMBLOCK_ALLOC_ACCESSIBLE, node);",
            "}",
            "",
            "void * __meminit vmemmap_alloc_block(unsigned long size, int node)",
            "{",
            "\t/* If the main allocator is up use that, fallback to bootmem. */",
            "\tif (slab_is_available()) {",
            "\t\tgfp_t gfp_mask = GFP_KERNEL|__GFP_RETRY_MAYFAIL|__GFP_NOWARN;",
            "\t\tint order = get_order(size);",
            "\t\tstatic bool warned;",
            "\t\tstruct page *page;",
            "",
            "\t\tpage = alloc_pages_node(node, gfp_mask, order);",
            "\t\tif (page)",
            "\t\t\treturn page_address(page);",
            "",
            "\t\tif (!warned) {",
            "\t\t\twarn_alloc(gfp_mask & ~__GFP_NOWARN, NULL,",
            "\t\t\t\t   \"vmemmap alloc failure: order:%u\", order);",
            "\t\t\twarned = true;",
            "\t\t}",
            "\t\treturn NULL;",
            "\t} else",
            "\t\treturn __earlyonly_bootmem_alloc(node, size, size,",
            "\t\t\t\t__pa(MAX_DMA_ADDRESS));",
            "}",
            "",
            "static void * __meminit altmap_alloc_block_buf(unsigned long size,",
            "\t\t\t\t\t       struct vmem_altmap *altmap);",
            "",
            "/* need to make sure size is all the same during early stage */",
            "void * __meminit vmemmap_alloc_block_buf(unsigned long size, int node,",
            "\t\t\t\t\t struct vmem_altmap *altmap)",
            "{",
            "\tvoid *ptr;",
            "",
            "\tif (altmap)",
            "\t\treturn altmap_alloc_block_buf(size, altmap);",
            "",
            "\tptr = sparse_buffer_alloc(size);",
            "\tif (!ptr)",
            "\t\tptr = vmemmap_alloc_block(size, node);",
            "\treturn ptr;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了用于分配虚拟内存映射所需内存块的函数，包括对slab分配器和bootmem分配器的选择逻辑，用于在系统初始化期间为vmentry结构体分配物理存储",
          "similarity": 0.5440182685852051
        }
      ]
    },
    {
      "source_file": "mm/ioremap.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:11:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ioremap.c`\n\n---\n\n# ioremap.c 技术文档\n\n## 1. 文件概述\n\n`ioremap.c` 是 Linux 内核中用于将物理 I/O 内存区域重新映射到内核虚拟地址空间的核心实现文件。该机制使得内核能够安全、高效地访问设备寄存器或高地址 PCI I/O 空间（这些区域通常未被直接映射到内核的低地址段，如 PC 架构中的 640KB–1MB 区域之外）。通过 `ioremap` 系列函数，驱动程序可以获取可直接读写的内核虚拟地址，从而操作硬件设备。\n\n## 2. 核心功能\n\n### 主要函数：\n\n- **`generic_ioremap_prot(phys_addr_t phys_addr, size_t size, pgprot_t prot)`**  \n  通用 I/O 内存重映射函数，根据指定的物理地址、大小和页保护属性创建内核虚拟映射。\n\n- **`ioremap_prot(phys_addr_t phys_addr, size_t size, unsigned long prot)`**  \n  对外导出的接口函数，封装 `generic_ioremap_prot`，接受原始的 `prot` 值并转换为 `pgprot_t` 类型。\n\n- **`generic_iounmap(volatile void __iomem *addr)`**  \n  通用 I/O 映射解除函数，释放由 `ioremap` 创建的虚拟地址映射。\n\n- **`iounmap(volatile void __iomem *addr)`**  \n  对外导出的接口函数，调用 `generic_iounmap` 完成实际的解映射操作。\n\n### 关键数据结构：\n\n- **`struct vm_struct`**：用于描述内核虚拟内存区域（vmalloc 区域）的结构体，记录映射的虚拟地址、物理地址、大小及标志等信息。\n- **`pgprot_t`**：页表项保护属性类型，用于控制映射页面的访问权限（如不可缓存、设备内存等）。\n\n## 3. 关键实现\n\n### 地址对齐与边界检查\n- 函数首先校验输入参数：拒绝零长度或地址溢出（wrap-around）的情况。\n- 将物理地址和映射大小按页对齐：提取原始地址在页内的偏移量 `offset`，将 `phys_addr` 下调至页边界，并将 `size` 扩展为包含偏移后的页对齐值。\n\n### 虚拟地址分配\n- 使用 `__get_vm_area_caller()` 在 `IOREMAP_START` 到 `IOREMAP_END` 的专用内核虚拟地址区间中分配一个 `vm_struct` 描述符。\n- 若分配失败，返回 `NULL`。\n\n### 页表建立\n- 调用 `ioremap_page_range()` 建立从分配的虚拟地址 `vaddr` 到对齐后物理地址 `phys_addr` 的页表映射，使用传入的保护属性 `prot`。\n- 若页表建立失败，则通过 `free_vm_area()` 释放已分配的虚拟区域并返回 `NULL`。\n\n### 返回用户可见地址\n- 最终返回的地址为 `vaddr + offset`，即保留原始物理地址的页内偏移，使调用者能精确访问目标 I/O 地址。\n\n### 解映射流程\n- `generic_iounmap()` 首先将传入地址对齐到页边界。\n- 通过 `is_ioremap_addr()` 验证该地址是否属于 ioremap 区域。\n- 若是，则调用 `vunmap()` 释放整个虚拟映射区域。\n\n### 条件编译支持\n- 使用 `#ifndef ioremap_prot` 和 `#ifndef iounmap` 确保在架构未提供自定义实现时，使用本文件提供的通用版本。\n- 通过 `EXPORT_SYMBOL` 导出符号，供内核模块使用。\n\n## 4. 依赖关系\n\n- **`<linux/vmalloc.h>`**：提供 `__get_vm_area_caller()`、`free_vm_area()`、`vunmap()` 等 vmalloc 子系统接口。\n- **`<linux/mm.h>`**：提供内存管理基础定义，如 `PAGE_MASK`、`PAGE_ALIGN`。\n- **`<linux/io.h>`**：定义 `__iomem` 注解及 I/O 访问相关宏。\n- **`<linux/ioremap.h>`**：声明 `ioremap` 相关接口和辅助函数（如 `is_ioremap_addr`）。\n- **`<linux/export.h>`**：提供 `EXPORT_SYMBOL` 宏，用于导出符号给模块使用。\n- 依赖内核 slab 分配器（通过 `slab_is_available()` 检查），确保在早期启动阶段不会因内存子系统未就绪而崩溃。\n\n## 5. 使用场景\n\n- **设备驱动开发**：驱动程序在初始化时调用 `ioremap()` 将设备寄存器的物理地址映射为内核可访问的虚拟地址，后续通过 `readl()`/`writel()` 等 I/O 访问函数操作硬件。\n- **PCI/平台设备资源访问**：当设备 BAR（Base Address Register）指向高物理地址（超出直接映射区）时，必须通过 ioremap 机制访问。\n- **ACPI/固件交互**：访问 ACPI 表或 UEFI 运行时服务所使用的物理内存区域。\n- **体系结构抽象层**：作为通用实现，被未提供特定优化版本的架构（如某些嵌入式平台）所采用。\n- **内核调试与诊断工具**：如 `/dev/mem` 的实现可能间接依赖此机制访问任意物理内存（需配置支持）。",
      "similarity": 0.5991911292076111,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/ioremap.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Re-map IO memory to kernel address space so that we can access it.",
            " * This is needed for high PCI addresses that aren't mapped in the",
            " * 640k-1MB IO memory area on PC's",
            " *",
            " * (C) Copyright 1995 1996 Linus Torvalds",
            " */",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/export.h>",
            "#include <linux/ioremap.h>",
            "",
            "void __iomem *generic_ioremap_prot(phys_addr_t phys_addr, size_t size,",
            "\t\t\t\t   pgprot_t prot)",
            "{",
            "\tunsigned long offset, vaddr;",
            "\tphys_addr_t last_addr;",
            "\tstruct vm_struct *area;",
            "",
            "\t/* An early platform driver might end up here */",
            "\tif (WARN_ON_ONCE(!slab_is_available()))",
            "\t\treturn NULL;",
            "",
            "\t/* Disallow wrap-around or zero size */",
            "\tlast_addr = phys_addr + size - 1;",
            "\tif (!size || last_addr < phys_addr)",
            "\t\treturn NULL;",
            "",
            "\t/* Page-align mappings */",
            "\toffset = phys_addr & (~PAGE_MASK);",
            "\tphys_addr -= offset;",
            "\tsize = PAGE_ALIGN(size + offset);",
            "",
            "\tarea = __get_vm_area_caller(size, VM_IOREMAP, IOREMAP_START,",
            "\t\t\t\t    IOREMAP_END, __builtin_return_address(0));",
            "\tif (!area)",
            "\t\treturn NULL;",
            "\tvaddr = (unsigned long)area->addr;",
            "\tarea->phys_addr = phys_addr;",
            "",
            "\tif (ioremap_page_range(vaddr, vaddr + size, phys_addr, prot)) {",
            "\t\tfree_vm_area(area);",
            "\t\treturn NULL;",
            "\t}",
            "",
            "\treturn (void __iomem *)(vaddr + offset);",
            "}",
            "",
            "#ifndef ioremap_prot",
            "void __iomem *ioremap_prot(phys_addr_t phys_addr, size_t size,",
            "\t\t\t   unsigned long prot)",
            "{",
            "\treturn generic_ioremap_prot(phys_addr, size, __pgprot(prot));",
            "}",
            "EXPORT_SYMBOL(ioremap_prot);",
            "#endif",
            ""
          ],
          "function_name": null,
          "description": "generic_ioremap_prot 函数实现通用I/O内存映射，接收物理地址、大小和保护属性参数，通过页面对齐计算偏移量，使用__get_vm_area分配虚拟内存区域，并调用ioremap_page_range建立映射，最终返回指向映射后虚拟地址的指针",
          "similarity": 0.5997652411460876
        },
        {
          "chunk_id": 1,
          "file_path": "mm/ioremap.c",
          "start_line": 60,
          "end_line": 70,
          "content": [
            "void generic_iounmap(volatile void __iomem *addr)",
            "{",
            "\tvoid *vaddr = (void *)((unsigned long)addr & PAGE_MASK);",
            "",
            "\tif (is_ioremap_addr(vaddr))",
            "\t\tvunmap(vaddr);",
            "}",
            "void iounmap(volatile void __iomem *addr)",
            "{",
            "\tgeneric_iounmap(addr);",
            "}"
          ],
          "function_name": "generic_iounmap, iounmap",
          "description": "generic_iounmap 函数用于解除I/O内存映射，通过判断地址是否属于ioremap区域，若是则调用vunmap释放对应的虚拟内存区域，iounmap函数作为包装接口调用generic_iounmap执行卸载操作",
          "similarity": 0.48614680767059326
        }
      ]
    }
  ]
}