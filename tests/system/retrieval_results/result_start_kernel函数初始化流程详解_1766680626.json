{
  "query": "start_kernel函数初始化流程详解",
  "timestamp": "2025-12-26 00:37:06",
  "retrieved_files": [
    {
      "source_file": "mm/kmsan/init.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:29:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kmsan\\init.c`\n\n---\n\n# `kmsan/init.c` 技术文档\n\n## 1. 文件概述\n\n`kmsan/init.c` 是 Linux 内核中 **KernelMemorySanitizer (KMSAN)** 调试工具的初始化模块。该文件负责在内核启动早期阶段为已存在的内存区域（如内核代码段、数据段、节点描述符 NODE_DATA 等）分配并初始化影子（shadow）和来源（origin）元数据页，并管理 memblock 分配器向伙伴系统移交页面时的元数据预分配策略。其目标是确保 KMSAN 能够追踪所有内核内存的初始化状态，从而检测未初始化内存的使用。\n\n## 2. 核心功能\n\n### 主要函数\n- `kmsan_record_future_shadow_range(void *start, void *end)`  \n  记录一个将在稍后（slab 初始化后）为其分配元数据的内存范围，并尝试与已有范围合并以减少碎片。\n  \n- `kmsan_init_shadow(void)`  \n  在内核初始化早期调用，收集需要初始化元数据的内存区域（包括保留内存、`.data` 段、NODE_DATA 等），并为这些区域分配影子和来源元数据。\n\n- `kmsan_memblock_free_pages(struct page *page, unsigned int order)`  \n  在 memblock 将大块连续物理页释放给伙伴系统时，拦截这些页面，按“三取一”策略：每三块同阶页面中，两块用作元数据（shadow + origin），一块作为被监控的数据页。\n\n- `kmsan_memblock_discard(void)`  \n  在 memblock 生命周期结束前，处理 `held_back[]` 中剩余的未配对元数据页，通过递归拆分和重新组合，尽可能为剩余数据页分配元数据，并将无法使用的页面归还系统。\n\n- `kmsan_init_runtime(void)`  \n  完成 KMSAN 的运行时初始化：为 init_task 创建任务上下文、清理残留元数据、启用 KMSAN 全局开关，并打印警告信息。\n\n### 主要数据结构\n- `struct start_end_pair`  \n  表示一个待分配元数据的虚拟地址范围（对齐到页边界）。\n\n- `struct metadata_page_pair`  \n  存储一对用于元数据的物理页：`shadow`（影子页，记录字节是否初始化）和 `origin`（来源页，记录未初始化值的来源信息）。\n\n- `struct smallstack`  \n  一个轻量级栈结构，用于在 `kmsan_memblock_discard()` 中暂存不同阶的页面块，支持按需拆分和重组。\n\n## 3. 关键实现\n\n### 内存范围合并机制\n`kmsan_record_future_shadow_range()` 在记录新范围前会遍历已有范围列表，若发现重叠或相邻，则合并为一个更大的连续范围。由于内核早期注册的范围数量有限（<20），采用线性扫描即可高效完成合并，避免元数据分配碎片化。\n\n### “三取一”元数据预分配策略\n在 `kmsan_memblock_free_pages()` 中，KMSAN 利用 memblock 向伙伴系统移交页面的时机，实施一种**贪婪但高效的元数据预留机制**：\n- 对于每个页面阶 `order`，维护一个 `held_back[order]` 缓存。\n- 前两次收到同阶页面块时，分别暂存为 shadow 和 origin。\n- 第三次收到时，将前两块作为元数据分配给第三块，并清空缓存供后续复用。\n- 此策略确保约 2/3 的释放内存被用作元数据，1/3 作为有效数据页，满足 KMSAN 对元数据空间的高需求。\n\n### 残留元数据回收（`kmsan_memblock_discard`）\n当 memblock 生命周期结束时，`held_back[]` 中可能残留未配对的 shadow 或 origin 页面。`kmsan_memblock_discard()` 采用**自顶向下递归拆分**策略：\n1. 从最大阶（`MAX_PAGE_ORDER`）开始，将所有残留页面压入 `collect` 栈。\n2. 若栈中元素 ≥3，则弹出三个页面，按“shadow + origin → data”方式完成一次元数据绑定，并将 data 页归还伙伴系统。\n3. 若栈中元素 <3，则将每个页面**拆分为两个低一阶的页面**，压入新栈，继续处理。\n4. 重复上述过程直至最小阶（0 阶），最大化利用残留内存。\n\n### 初始化流程整合\n- `kmsan_init_shadow()` 在 slab 初始化前运行，依赖 `memblock` 和 `phys_to_virt`，为静态内核内存分配元数据。\n- `kmsan_init_runtime()` 在伙伴系统完全就绪后调用，完成任务上下文初始化、残留清理，并最终启用 KMSAN。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `kmsan.h`：KMSAN 核心接口和宏定义（如 `KMSAN_WARN_ON`）。\n  - `<asm/sections.h>`：获取内核符号地址（如 `_sdata`, `_edata`）。\n  - `<linux/mm.h>`, `<linux/memblock.h>`：内存管理基础 API（`phys_to_virt`, `memblock` 遍历等）。\n  - `\"../internal.h\"`：KMSAN 内部实现细节（如 `kmsan_setup_meta`, `kmsan_init_alloc_meta_for_range`）。\n\n- **功能依赖**：\n  - 依赖 **memblock 分配器** 在早期内存管理中的行为。\n  - 依赖 **伙伴系统（buddy allocator）** 接管页面后的正常运作。\n  - 依赖 **percpu、NUMA NODE_DATA** 等子系统的初始化顺序（需在其注册内存范围后再调用 `kmsan_init_shadow`）。\n\n## 5. 使用场景\n\n- **内核启动早期**：在 `start_kernel()` 流程中，于 `mm_init()` 之前调用 `kmsan_init_shadow()`，为内核静态数据分配元数据。\n- **memblock 释放页面时**：每当 `memblock_free_pages()` 被调用（通常在 `free_all_bootmem()` 中），KMSAN 拦截页面释放流程，执行元数据预留。\n- **内核初始化尾声**：在 `rest_init()` 之前调用 `kmsan_init_runtime()`，完成 KMSAN 的最终激活。\n- **调试场景**：仅在启用 `CONFIG_KMSAN` 编译选项的内核中生效，用于检测内核中因未初始化内存导致的安全漏洞或逻辑错误，**严禁在生产环境使用**。",
      "similarity": 0.6289292573928833,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/kmsan/init.c",
          "start_line": 201,
          "end_line": 234,
          "content": [
            "static void kmsan_memblock_discard(void)",
            "{",
            "\t/*",
            "\t * For each order=N:",
            "\t *  - push held_back[N].shadow and .origin to @collect;",
            "\t *  - while there are >= 3 elements in @collect, do garbage collection:",
            "\t *    - pop 3 ranges from @collect;",
            "\t *    - use two of them as shadow and origin for the third one;",
            "\t *    - repeat;",
            "\t *  - split each remaining element from @collect into 2 ranges of",
            "\t *    order=N-1,",
            "\t *  - repeat.",
            "\t */",
            "\tcollect.order = MAX_PAGE_ORDER;",
            "\tfor (int i = MAX_PAGE_ORDER; i >= 0; i--) {",
            "\t\tif (held_back[i].shadow)",
            "\t\t\tsmallstack_push(&collect, held_back[i].shadow);",
            "\t\tif (held_back[i].origin)",
            "\t\t\tsmallstack_push(&collect, held_back[i].origin);",
            "\t\theld_back[i].shadow = NULL;",
            "\t\theld_back[i].origin = NULL;",
            "\t\tdo_collection();",
            "\t\tcollect_split();",
            "\t}",
            "}",
            "void __init kmsan_init_runtime(void)",
            "{",
            "\t/* Assuming current is init_task */",
            "\tkmsan_internal_task_create(current);",
            "\tkmsan_memblock_discard();",
            "\tpr_info(\"Starting KernelMemorySanitizer\\n\");",
            "\tpr_info(\"ATTENTION: KMSAN is a debugging tool! Do not use it on production machines!\\n\");",
            "\tkmsan_enabled = true;",
            "}"
          ],
          "function_name": "kmsan_memblock_discard, kmsan_init_runtime",
          "description": "执行内存块清理操作，通过小栈收集并处理不同阶序的页面资源，完成KMSAN运行时环境初始化与启用",
          "similarity": 0.5849202871322632
        },
        {
          "chunk_id": 0,
          "file_path": "mm/kmsan/init.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * KMSAN initialization routines.",
            " *",
            " * Copyright (C) 2017-2021 Google LLC",
            " * Author: Alexander Potapenko <glider@google.com>",
            " *",
            " */",
            "",
            "#include \"kmsan.h\"",
            "",
            "#include <asm/sections.h>",
            "#include <linux/mm.h>",
            "#include <linux/memblock.h>",
            "",
            "#include \"../internal.h\"",
            "",
            "#define NUM_FUTURE_RANGES 128",
            "struct start_end_pair {",
            "\tu64 start, end;",
            "};",
            "",
            "static struct start_end_pair start_end_pairs[NUM_FUTURE_RANGES] __initdata;",
            "static int future_index __initdata;",
            "",
            "/*",
            " * Record a range of memory for which the metadata pages will be created once",
            " * the page allocator becomes available.",
            " */"
          ],
          "function_name": null,
          "description": "定义用于记录未来内存范围的辅助结构和初始化函数，用于在页面分配器就绪后创建元数据页",
          "similarity": 0.5236632227897644
        },
        {
          "chunk_id": 1,
          "file_path": "mm/kmsan/init.c",
          "start_line": 30,
          "end_line": 141,
          "content": [
            "static void __init kmsan_record_future_shadow_range(void *start, void *end)",
            "{",
            "\tu64 nstart = (u64)start, nend = (u64)end, cstart, cend;",
            "\tbool merged = false;",
            "",
            "\tKMSAN_WARN_ON(future_index == NUM_FUTURE_RANGES);",
            "\tKMSAN_WARN_ON((nstart >= nend) || !nstart || !nend);",
            "\tnstart = ALIGN_DOWN(nstart, PAGE_SIZE);",
            "\tnend = ALIGN(nend, PAGE_SIZE);",
            "",
            "\t/*",
            "\t * Scan the existing ranges to see if any of them overlaps with",
            "\t * [start, end). In that case, merge the two ranges instead of",
            "\t * creating a new one.",
            "\t * The number of ranges is less than 20, so there is no need to organize",
            "\t * them into a more intelligent data structure.",
            "\t */",
            "\tfor (int i = 0; i < future_index; i++) {",
            "\t\tcstart = start_end_pairs[i].start;",
            "\t\tcend = start_end_pairs[i].end;",
            "\t\tif ((cstart < nstart && cend < nstart) ||",
            "\t\t    (cstart > nend && cend > nend))",
            "\t\t\t/* ranges are disjoint - do not merge */",
            "\t\t\tcontinue;",
            "\t\tstart_end_pairs[i].start = min(nstart, cstart);",
            "\t\tstart_end_pairs[i].end = max(nend, cend);",
            "\t\tmerged = true;",
            "\t\tbreak;",
            "\t}",
            "\tif (merged)",
            "\t\treturn;",
            "\tstart_end_pairs[future_index].start = nstart;",
            "\tstart_end_pairs[future_index].end = nend;",
            "\tfuture_index++;",
            "}",
            "void __init kmsan_init_shadow(void)",
            "{",
            "\tconst size_t nd_size = roundup(sizeof(pg_data_t), PAGE_SIZE);",
            "\tphys_addr_t p_start, p_end;",
            "\tu64 loop;",
            "\tint nid;",
            "",
            "\tfor_each_reserved_mem_range(loop, &p_start, &p_end)",
            "\t\tkmsan_record_future_shadow_range(phys_to_virt(p_start),",
            "\t\t\t\t\t\t phys_to_virt(p_end));",
            "\t/* Allocate shadow for .data */",
            "\tkmsan_record_future_shadow_range(_sdata, _edata);",
            "",
            "\tfor_each_online_node(nid)",
            "\t\tkmsan_record_future_shadow_range(",
            "\t\t\tNODE_DATA(nid), (char *)NODE_DATA(nid) + nd_size);",
            "",
            "\tfor (int i = 0; i < future_index; i++)",
            "\t\tkmsan_init_alloc_meta_for_range(",
            "\t\t\t(void *)start_end_pairs[i].start,",
            "\t\t\t(void *)start_end_pairs[i].end);",
            "}",
            "bool kmsan_memblock_free_pages(struct page *page, unsigned int order)",
            "{",
            "\tstruct page *shadow, *origin;",
            "",
            "\tif (!held_back[order].shadow) {",
            "\t\theld_back[order].shadow = page;",
            "\t\treturn false;",
            "\t}",
            "\tif (!held_back[order].origin) {",
            "\t\theld_back[order].origin = page;",
            "\t\treturn false;",
            "\t}",
            "\tshadow = held_back[order].shadow;",
            "\torigin = held_back[order].origin;",
            "\tkmsan_setup_meta(page, shadow, origin, order);",
            "",
            "\theld_back[order].shadow = NULL;",
            "\theld_back[order].origin = NULL;",
            "\treturn true;",
            "}",
            "static void smallstack_push(struct smallstack *stack, struct page *pages)",
            "{",
            "\tKMSAN_WARN_ON(stack->index == MAX_BLOCKS);",
            "\tstack->items[stack->index] = pages;",
            "\tstack->index++;",
            "}",
            "static void do_collection(void)",
            "{",
            "\tstruct page *page, *shadow, *origin;",
            "",
            "\twhile (collect.index >= 3) {",
            "\t\tpage = smallstack_pop(&collect);",
            "\t\tshadow = smallstack_pop(&collect);",
            "\t\torigin = smallstack_pop(&collect);",
            "\t\tkmsan_setup_meta(page, shadow, origin, collect.order);",
            "\t\t__free_pages_core(page, collect.order, MEMINIT_EARLY);",
            "\t}",
            "}",
            "static void collect_split(void)",
            "{",
            "\tstruct smallstack tmp = {",
            "\t\t.order = collect.order - 1,",
            "\t\t.index = 0,",
            "\t};",
            "\tstruct page *page;",
            "",
            "\tif (!collect.order)",
            "\t\treturn;",
            "\twhile (collect.index) {",
            "\t\tpage = smallstack_pop(&collect);",
            "\t\tsmallstack_push(&tmp, &page[0]);",
            "\t\tsmallstack_push(&tmp, &page[1 << tmp.order]);",
            "\t}",
            "\t__memcpy(&collect, &tmp, sizeof(tmp));",
            "}"
          ],
          "function_name": "kmsan_record_future_shadow_range, kmsan_init_shadow, kmsan_memblock_free_pages, smallstack_push, do_collection, collect_split",
          "description": "实现未来内存范围的合并逻辑、影子内存初始化及页面回收机制，包含范围扫描、元数据分配与碎片收集处理",
          "similarity": 0.4979667663574219
        }
      ]
    },
    {
      "source_file": "mm/mm_init.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:50:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mm_init.c`\n\n---\n\n# mm_init.c 技术文档\n\n## 1. 文件概述\n\n`mm_init.c` 是 Linux 内核内存管理子系统（Memory Management, MM）中的一个初始化和调试辅助文件。其主要作用包括：\n\n- 提供内存初始化过程的验证与调试功能（在 `CONFIG_DEBUG_MEMORY_INIT` 启用时）\n- 初始化内存相关的全局参数和 sysfs 接口\n- 解析内核启动命令行参数（如 `kernelcore` 和 `movablecore`），用于控制不可移动与可移动内存区域的分配策略\n- 在 SMP 系统中动态计算 `vm_committed_as` 的批处理阈值，以优化内存提交统计的性能\n\n该文件不直接参与页分配或虚拟内存管理的核心逻辑，而是为内存子系统的正确性验证、配置和可观测性提供支持。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `mminit_verify_zonelist()` | 验证并打印每个 NUMA 节点的 zonelist 结构，用于调试内存区域组织 |\n| `mminit_verify_pageflags_layout()` | 验证 `struct page` 中用于存储节点、区域、节区等元数据的位域布局是否无重叠且对齐正确 |\n| `set_mminit_loglevel()` | 解析 `mminit_loglevel` 内核参数，设置内存初始化调试日志级别 |\n| `mm_compute_batch()` | 根据系统内存总量和 CPU 数量，计算 `vm_committed_as` per-CPU 计数器的批处理阈值 |\n| `mm_compute_batch_notifier()` | 内存热插拔事件回调，重新计算 `vm_committed_as` 批处理值 |\n| `mm_sysfs_init()` | 创建 `/sys/kernel/mm` sysfs 目录，用于暴露内存子系统信息 |\n| `cmdline_parse_core()` | 辅助函数，解析带百分比或字节单位的内存大小参数 |\n| `cmdline_parse_kernelcore()` / `cmdline_parse_movablecore()` | 解析 `kernelcore=` 和 `movablecore=` 内核启动参数 |\n\n### 主要全局变量\n\n| 变量名 | 类型/说明 |\n|--------|---------|\n| `mminit_loglevel` | 调试日志级别（仅当 `CONFIG_DEBUG_MEMORY_INIT` 启用） |\n| `mm_kobj` | 指向 `/sys/kernel/mm` 的 kobject 指针 |\n| `vm_committed_as_batch` | `vm_committed_as` per-CPU 计数器的批处理阈值（SMP） |\n| `required_kernelcore` / `required_kernelcore_percent` | 用户指定的不可移动内存需求（页数或百分比） |\n| `required_movablecore` / `required_movablecore_percent` | 用户指定的可移动内存需求（页数或百分比） |\n| `mirrored_kernelcore` | 是否启用镜像式 kernelcore 布局 |\n| `arch_zone_lowest_possible_pfn[]` / `arch_zone_highest_possible_pfn[]` | 架构定义的各内存区域（ZONE）的 PFN 范围 |\n| `zone_movable_pfn[]` | 各 NUMA 节点上 ZONE_MOVABLE 的起始 PFN |\n| `deferred_struct_pages` | 标记是否延迟初始化 struct page 实例 |\n\n## 3. 关键实现\n\n### 3.1 内存初始化调试（`CONFIG_DEBUG_MEMORY_INIT`）\n\n- **Zonelist 验证**：`mminit_verify_zonelist()` 遍历所有在线 NUMA 节点，打印其“通用”（general）和“本节点优先”（thisnode）两种 zonelist 的组成，帮助开发者确认内存区域的 fallback 顺序是否符合预期。\n- **Page Flags 布局验证**：`mminit_verify_pageflags_layout()` 检查 `struct page` 中用于编码物理位置（section/node/zone）的位域是否：\n  - 总宽度不超过 `BITS_PER_LONG`\n  - 各字段偏移（`_PGSHIFT`）与宽度一致\n  - 位掩码无重叠（通过 `or_mask == add_mask` 验证）\n\n### 3.2 内存区域划分策略\n\n- 通过 `kernelcore=` 和 `movablecore=` 参数，用户可显式指定系统中用于**不可移动分配**（如内核数据结构）和**可移动分配**（如用户页、可迁移 slab）的内存大小。\n- 支持 `kernelcore=mirror` 模式，在支持内存镜像的平台上启用特殊布局。\n- 参数值可为绝对字节数（如 `512M`）或总内存百分比（如 `40%`）。\n\n### 3.3 `vm_committed_as` 批处理优化（SMP）\n\n- `vm_committed_as` 是一个 per-CPU 计数器，跟踪已提交虚拟内存总量。\n- 为减少原子操作开销，当本地计数器变化超过 `vm_committed_as_batch` 时才同步到全局值。\n- `mm_compute_batch()` 根据 overcommit 策略动态调整 batch 大小：\n  - `OVERCOMMIT_NEVER`：batch = 总内存 / CPU数 / 256（约 0.4%）\n  - 其他策略：batch = 总内存 / CPU数 / 4（25%）\n- 注册内存热插拔通知器，确保内存容量变化后重新计算 batch 值。\n\n### 3.4 Sysfs 接口初始化\n\n- `mm_sysfs_init()` 在内核早期创建 `/sys/kernel/mm` 目录，作为内存子系统其他模块（如 compaction、numa、transparent_hugepage 等）注册 sysfs 属性的基础。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memory.h>`、`<linux/memblock.h>`：内存块和热插拔管理\n  - `<linux/page-isolation.h>`、`<linux/cma.h>`：连续内存分配和页面隔离\n  - `\"internal.h\"`、`\"slab.h\"`：MM 子系统内部接口\n  - `<asm/setup.h>`：架构相关内存布局信息\n- **配置依赖**：\n  - `CONFIG_DEBUG_MEMORY_INIT`：启用调试验证功能\n  - `CONFIG_SMP`：启用 `vm_committed_as_batch` 优化\n  - `CONFIG_SYSFS`：支持 mm sysfs 目录创建\n- **被依赖模块**：\n  - 内存初始化流程（`mm_init()` in `init/main.c`）\n  - 页面分配器（`page_alloc.c`）使用 `zone_movable_pfn` 等变量\n  - 内存热插拔子系统调用 batch 重计算回调\n\n## 5. 使用场景\n\n- **内核开发与调试**：开发者启用 `CONFIG_DEBUG_MEMORY_INIT` 并设置 `mminit_loglevel`，可在启动时验证内存拓扑结构和 page 结构体布局的正确性。\n- **系统部署调优**：管理员通过 `kernelcore=` 或 `movablecore=` 参数，强制划分不可移动/可移动内存区域，以优化透明大页（THP）或避免内存碎片。\n- **高可靠性系统**：使用 `kernelcore=mirror` 在支持的硬件上启用内存镜像，提升容错能力。\n- **大规模 SMP 系统**：自动调整 `vm_committed_as_batch` 减少锁竞争，提升多进程内存密集型应用的性能。\n- **运行时监控**：`/sys/kernel/mm` 为用户空间工具（如 `numastat`、`cma` 调试接口）提供统一入口点。",
      "similarity": 0.6093420386314392,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/mm_init.c",
          "start_line": 151,
          "end_line": 259,
          "content": [
            "static __init int set_mminit_loglevel(char *str)",
            "{",
            "\tget_option(&str, &mminit_loglevel);",
            "\treturn 0;",
            "}",
            "void mm_compute_batch(int overcommit_policy)",
            "{",
            "\tu64 memsized_batch;",
            "\ts32 nr = num_present_cpus();",
            "\ts32 batch = max_t(s32, nr*2, 32);",
            "\tunsigned long ram_pages = totalram_pages();",
            "",
            "\t/*",
            "\t * For policy OVERCOMMIT_NEVER, set batch size to 0.4% of",
            "\t * (total memory/#cpus), and lift it to 25% for other policies",
            "\t * to easy the possible lock contention for percpu_counter",
            "\t * vm_committed_as, while the max limit is INT_MAX",
            "\t */",
            "\tif (overcommit_policy == OVERCOMMIT_NEVER)",
            "\t\tmemsized_batch = min_t(u64, ram_pages/nr/256, INT_MAX);",
            "\telse",
            "\t\tmemsized_batch = min_t(u64, ram_pages/nr/4, INT_MAX);",
            "",
            "\tvm_committed_as_batch = max_t(s32, memsized_batch, batch);",
            "}",
            "static int __meminit mm_compute_batch_notifier(struct notifier_block *self,",
            "\t\t\t\t\tunsigned long action, void *arg)",
            "{",
            "\tswitch (action) {",
            "\tcase MEM_ONLINE:",
            "\tcase MEM_OFFLINE:",
            "\t\tmm_compute_batch(sysctl_overcommit_memory);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "\treturn NOTIFY_OK;",
            "}",
            "static int __init mm_compute_batch_init(void)",
            "{",
            "\tmm_compute_batch(sysctl_overcommit_memory);",
            "\thotplug_memory_notifier(mm_compute_batch_notifier, MM_COMPUTE_BATCH_PRI);",
            "\treturn 0;",
            "}",
            "static int __init mm_sysfs_init(void)",
            "{",
            "\tmm_kobj = kobject_create_and_add(\"mm\", kernel_kobj);",
            "\tif (!mm_kobj)",
            "\t\treturn -ENOMEM;",
            "",
            "\treturn 0;",
            "}",
            "static int __init cmdline_parse_core(char *p, unsigned long *core,",
            "\t\t\t\t     unsigned long *percent)",
            "{",
            "\tunsigned long long coremem;",
            "\tchar *endptr;",
            "",
            "\tif (!p)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Value may be a percentage of total memory, otherwise bytes */",
            "\tcoremem = simple_strtoull(p, &endptr, 0);",
            "\tif (*endptr == '%') {",
            "\t\t/* Paranoid check for percent values greater than 100 */",
            "\t\tWARN_ON(coremem > 100);",
            "",
            "\t\t*percent = coremem;",
            "\t} else {",
            "\t\tcoremem = memparse(p, &p);",
            "\t\t/* Paranoid check that UL is enough for the coremem value */",
            "\t\tWARN_ON((coremem >> PAGE_SHIFT) > ULONG_MAX);",
            "",
            "\t\t*core = coremem >> PAGE_SHIFT;",
            "\t\t*percent = 0UL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int __init cmdline_parse_kernelcore(char *p)",
            "{",
            "\t/* parse kernelcore=mirror */",
            "\tif (parse_option_str(p, \"mirror\")) {",
            "\t\tmirrored_kernelcore = true;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn cmdline_parse_core(p, &required_kernelcore,",
            "\t\t\t\t  &required_kernelcore_percent);",
            "}",
            "static int __init cmdline_parse_movablecore(char *p)",
            "{",
            "\treturn cmdline_parse_core(p, &required_movablecore,",
            "\t\t\t\t  &required_movablecore_percent);",
            "}",
            "static unsigned long __init early_calculate_totalpages(void)",
            "{",
            "\tunsigned long totalpages = 0;",
            "\tunsigned long start_pfn, end_pfn;",
            "\tint i, nid;",
            "",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {",
            "\t\tunsigned long pages = end_pfn - start_pfn;",
            "",
            "\t\ttotalpages += pages;",
            "\t\tif (pages)",
            "\t\t\tnode_set_state(nid, N_MEMORY);",
            "\t}",
            "\treturn totalpages;",
            "}"
          ],
          "function_name": "set_mminit_loglevel, mm_compute_batch, mm_compute_batch_notifier, mm_compute_batch_init, mm_sysfs_init, cmdline_parse_core, cmdline_parse_kernelcore, cmdline_parse_movablecore, early_calculate_totalpages",
          "description": "初始化内存批次计算逻辑，注册内存变化通知回调，解析命令行参数以确定内核核心和可移动内存需求",
          "similarity": 0.6066824793815613
        },
        {
          "chunk_id": 17,
          "file_path": "mm/mm_init.c",
          "start_line": 2711,
          "end_line": 2806,
          "content": [
            "static void __init mem_init_print_info(void)",
            "{",
            "\tunsigned long physpages, codesize, datasize, rosize, bss_size;",
            "\tunsigned long init_code_size, init_data_size;",
            "",
            "\tphyspages = get_num_physpages();",
            "\tcodesize = _etext - _stext;",
            "\tdatasize = _edata - _sdata;",
            "\trosize = __end_rodata - __start_rodata;",
            "\tbss_size = __bss_stop - __bss_start;",
            "\tinit_data_size = __init_end - __init_begin;",
            "\tinit_code_size = _einittext - _sinittext;",
            "",
            "\t/*",
            "\t * Detect special cases and adjust section sizes accordingly:",
            "\t * 1) .init.* may be embedded into .data sections",
            "\t * 2) .init.text.* may be out of [__init_begin, __init_end],",
            "\t *    please refer to arch/tile/kernel/vmlinux.lds.S.",
            "\t * 3) .rodata.* may be embedded into .text or .data sections.",
            "\t */",
            "#define adj_init_size(start, end, size, pos, adj) \\",
            "\tdo { \\",
            "\t\tif (&start[0] <= &pos[0] && &pos[0] < &end[0] && size > adj) \\",
            "\t\t\tsize -= adj; \\",
            "\t} while (0)",
            "",
            "\tadj_init_size(__init_begin, __init_end, init_data_size,",
            "\t\t     _sinittext, init_code_size);",
            "\tadj_init_size(_stext, _etext, codesize, _sinittext, init_code_size);",
            "\tadj_init_size(_sdata, _edata, datasize, __init_begin, init_data_size);",
            "\tadj_init_size(_stext, _etext, codesize, __start_rodata, rosize);",
            "\tadj_init_size(_sdata, _edata, datasize, __start_rodata, rosize);",
            "",
            "#undef\tadj_init_size",
            "",
            "\tpr_info(\"Memory: %luK/%luK available (%luK kernel code, %luK rwdata, %luK rodata, %luK init, %luK bss, %luK reserved, %luK cma-reserved\"",
            "#ifdef\tCONFIG_HIGHMEM",
            "\t\t\", %luK highmem\"",
            "#endif",
            "\t\t\")\\n\",",
            "\t\tK(nr_free_pages()), K(physpages),",
            "\t\tcodesize / SZ_1K, datasize / SZ_1K, rosize / SZ_1K,",
            "\t\t(init_data_size + init_code_size) / SZ_1K, bss_size / SZ_1K,",
            "\t\tK(physpages - totalram_pages() - totalcma_pages),",
            "\t\tK(totalcma_pages)",
            "#ifdef\tCONFIG_HIGHMEM",
            "\t\t, K(totalhigh_pages())",
            "#endif",
            "\t\t);",
            "}",
            "void __init mm_core_init(void)",
            "{",
            "\t/* Initializations relying on SMP setup */",
            "\tbuild_all_zonelists(NULL);",
            "\tpage_alloc_init_cpuhp();",
            "",
            "\t/*",
            "\t * page_ext requires contiguous pages,",
            "\t * bigger than MAX_PAGE_ORDER unless SPARSEMEM.",
            "\t */",
            "\tpage_ext_init_flatmem();",
            "\tmem_debugging_and_hardening_init();",
            "\tkfence_alloc_pool_and_metadata();",
            "\treport_meminit();",
            "\tkmsan_init_shadow();",
            "\tstack_depot_early_init();",
            "",
            "\t/*",
            "\t * KHO memory setup must happen while memblock is still active, but",
            "\t * as close as possible to buddy initialization",
            "\t */",
            "\tkho_memory_init();",
            "",
            "\tmem_init();",
            "\tmem_init_print_info();",
            "\tkmem_cache_init();",
            "\t/*",
            "\t * page_owner must be initialized after buddy is ready, and also after",
            "\t * slab is ready so that stack_depot_init() works properly",
            "\t */",
            "\tpage_ext_init_flatmem_late();",
            "\tkmemleak_init();",
            "\tptlock_cache_init();",
            "\tpgtable_cache_init();",
            "\tdebug_objects_mem_init();",
            "\tvmalloc_init();",
            "\t/* If no deferred init page_ext now, as vmap is fully initialized */",
            "\tif (!deferred_struct_pages)",
            "\t\tpage_ext_init();",
            "\t/* Should be run before the first non-init thread is created */",
            "\tinit_espfix_bsp();",
            "\t/* Should be run after espfix64 is set up. */",
            "\tpti_init();",
            "\tkmsan_init_runtime();",
            "\tmm_cache_init();",
            "}"
          ],
          "function_name": "mem_init_print_info, mm_core_init",
          "description": "mem_init_print_info计算并打印内存统计信息，包括可用页面数、各段代码数据大小及保留区域。mm_core_init初始化内存核心组件，构建zonelists，初始化slab/kmem_cache，启用调试对象跟踪，设置虚拟内存管理，最后根据是否延迟结构页初始化page_ext模块。",
          "similarity": 0.5858094692230225
        },
        {
          "chunk_id": 6,
          "file_path": "mm/mm_init.c",
          "start_line": 912,
          "end_line": 1017,
          "content": [
            "static void __init memmap_init_zone_range(struct zone *zone,",
            "\t\t\t\t\t  unsigned long start_pfn,",
            "\t\t\t\t\t  unsigned long end_pfn,",
            "\t\t\t\t\t  unsigned long *hole_pfn)",
            "{",
            "\tunsigned long zone_start_pfn = zone->zone_start_pfn;",
            "\tunsigned long zone_end_pfn = zone_start_pfn + zone->spanned_pages;",
            "\tint nid = zone_to_nid(zone), zone_id = zone_idx(zone);",
            "",
            "\tstart_pfn = clamp(start_pfn, zone_start_pfn, zone_end_pfn);",
            "\tend_pfn = clamp(end_pfn, zone_start_pfn, zone_end_pfn);",
            "",
            "\tif (start_pfn >= end_pfn)",
            "\t\treturn;",
            "",
            "\tmemmap_init_range(end_pfn - start_pfn, nid, zone_id, start_pfn,",
            "\t\t\t  zone_end_pfn, MEMINIT_EARLY, NULL, MIGRATE_MOVABLE);",
            "",
            "\tif (*hole_pfn < start_pfn)",
            "\t\tinit_unavailable_range(*hole_pfn, start_pfn, zone_id, nid);",
            "",
            "\t*hole_pfn = end_pfn;",
            "}",
            "static void __init memmap_init(void)",
            "{",
            "\tunsigned long start_pfn, end_pfn;",
            "\tunsigned long hole_pfn = 0;",
            "\tint i, j, zone_id = 0, nid;",
            "",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {",
            "\t\tstruct pglist_data *node = NODE_DATA(nid);",
            "",
            "\t\tfor (j = 0; j < MAX_NR_ZONES; j++) {",
            "\t\t\tstruct zone *zone = node->node_zones + j;",
            "",
            "\t\t\tif (!populated_zone(zone))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tmemmap_init_zone_range(zone, start_pfn, end_pfn,",
            "\t\t\t\t\t       &hole_pfn);",
            "\t\t\tzone_id = j;",
            "\t\t}",
            "\t}",
            "",
            "#ifdef CONFIG_SPARSEMEM",
            "\t/*",
            "\t * Initialize the memory map for hole in the range [memory_end,",
            "\t * section_end].",
            "\t * Append the pages in this hole to the highest zone in the last",
            "\t * node.",
            "\t * The call to init_unavailable_range() is outside the ifdef to",
            "\t * silence the compiler warining about zone_id set but not used;",
            "\t * for FLATMEM it is a nop anyway",
            "\t */",
            "\tend_pfn = round_up(end_pfn, PAGES_PER_SECTION);",
            "\tif (hole_pfn < end_pfn)",
            "#endif",
            "\t\tinit_unavailable_range(hole_pfn, end_pfn, zone_id, nid);",
            "}",
            "static void __ref __init_zone_device_page(struct page *page, unsigned long pfn,",
            "\t\t\t\t\t  unsigned long zone_idx, int nid,",
            "\t\t\t\t\t  struct dev_pagemap *pgmap)",
            "{",
            "",
            "\t__init_single_page(page, pfn, zone_idx, nid);",
            "",
            "\t/*",
            "\t * Mark page reserved as it will need to wait for onlining",
            "\t * phase for it to be fully associated with a zone.",
            "\t *",
            "\t * We can use the non-atomic __set_bit operation for setting",
            "\t * the flag as we are still initializing the pages.",
            "\t */",
            "\t__SetPageReserved(page);",
            "",
            "\t/*",
            "\t * ZONE_DEVICE pages union ->lru with a ->pgmap back pointer",
            "\t * and zone_device_data.  It is a bug if a ZONE_DEVICE page is",
            "\t * ever freed or placed on a driver-private list.",
            "\t */",
            "\tpage->pgmap = pgmap;",
            "\tpage->zone_device_data = NULL;",
            "",
            "\t/*",
            "\t * Mark the block movable so that blocks are reserved for",
            "\t * movable at startup. This will force kernel allocations",
            "\t * to reserve their blocks rather than leaking throughout",
            "\t * the address space during boot when many long-lived",
            "\t * kernel allocations are made.",
            "\t *",
            "\t * Please note that MEMINIT_HOTPLUG path doesn't clear memmap",
            "\t * because this is done early in section_activate()",
            "\t */",
            "\tif (pageblock_aligned(pfn)) {",
            "\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\t/*",
            "\t * ZONE_DEVICE pages are released directly to the driver page allocator",
            "\t * which will set the page count to 1 when allocating the page.",
            "\t */",
            "\tif (pgmap->type == MEMORY_DEVICE_PRIVATE ||",
            "\t    pgmap->type == MEMORY_DEVICE_COHERENT)",
            "\t\tset_page_count(page, 0);",
            "}"
          ],
          "function_name": "memmap_init_zone_range, memmap_init, __init_zone_device_page",
          "description": "遍历各节点和区，调用memmap_init_range初始化内存映射，处理稀疏内存中洞的不可用范围，并调整ZONE_MOVABLE范围以适应架构需求。",
          "similarity": 0.5757331252098083
        },
        {
          "chunk_id": 4,
          "file_path": "mm/mm_init.c",
          "start_line": 566,
          "end_line": 671,
          "content": [
            "void __meminit __init_single_page(struct page *page, unsigned long pfn,",
            "\t\t\t\tunsigned long zone, int nid)",
            "{",
            "\tmm_zero_struct_page(page);",
            "\tset_page_links(page, zone, nid, pfn);",
            "\tinit_page_count(page);",
            "\tpage_mapcount_reset(page);",
            "\tpage_cpupid_reset_last(page);",
            "\tpage_kasan_tag_reset(page);",
            "",
            "\tINIT_LIST_HEAD(&page->lru);",
            "#ifdef WANT_PAGE_VIRTUAL",
            "\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */",
            "\tif (!is_highmem_idx(zone))",
            "\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));",
            "#endif",
            "}",
            "static int __meminit __early_pfn_to_nid(unsigned long pfn,",
            "\t\t\t\t\tstruct mminit_pfnnid_cache *state)",
            "{",
            "\tunsigned long start_pfn, end_pfn;",
            "\tint nid;",
            "",
            "\tif (state->last_start <= pfn && pfn < state->last_end)",
            "\t\treturn state->last_nid;",
            "",
            "\tnid = memblock_search_pfn_nid(pfn, &start_pfn, &end_pfn);",
            "\tif (nid != NUMA_NO_NODE) {",
            "\t\tstate->last_start = start_pfn;",
            "\t\tstate->last_end = end_pfn;",
            "\t\tstate->last_nid = nid;",
            "\t}",
            "",
            "\treturn nid;",
            "}",
            "int __meminit early_pfn_to_nid(unsigned long pfn)",
            "{",
            "\tstatic DEFINE_SPINLOCK(early_pfn_lock);",
            "\tint nid;",
            "",
            "\tspin_lock(&early_pfn_lock);",
            "\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);",
            "\tif (nid < 0)",
            "\t\tnid = first_online_node;",
            "\tspin_unlock(&early_pfn_lock);",
            "",
            "\treturn nid;",
            "}",
            "static int __init set_hashdist(char *str)",
            "{",
            "\tif (!str)",
            "\t\treturn 0;",
            "\thashdist = simple_strtoul(str, &str, 0);",
            "\treturn 1;",
            "}",
            "static inline void fixup_hashdist(void)",
            "{",
            "\tif (num_node_state(N_MEMORY) == 1)",
            "\t\thashdist = 0;",
            "}",
            "static inline void fixup_hashdist(void) {}",
            "static inline void pgdat_set_deferred_range(pg_data_t *pgdat)",
            "{",
            "\tpgdat->first_deferred_pfn = ULONG_MAX;",
            "}",
            "static inline bool __meminit early_page_initialised(unsigned long pfn, int nid)",
            "{",
            "\tif (node_online(nid) && pfn >= NODE_DATA(nid)->first_deferred_pfn)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static bool __meminit",
            "defer_init(int nid, unsigned long pfn, unsigned long end_pfn)",
            "{",
            "\tstatic unsigned long prev_end_pfn, nr_initialised;",
            "",
            "\tif (early_page_ext_enabled())",
            "\t\treturn false;",
            "\t/*",
            "\t * prev_end_pfn static that contains the end of previous zone",
            "\t * No need to protect because called very early in boot before smp_init.",
            "\t */",
            "\tif (prev_end_pfn != end_pfn) {",
            "\t\tprev_end_pfn = end_pfn;",
            "\t\tnr_initialised = 0;",
            "\t}",
            "",
            "\t/* Always populate low zones for address-constrained allocations */",
            "\tif (end_pfn < pgdat_end_pfn(NODE_DATA(nid)))",
            "\t\treturn false;",
            "",
            "\tif (NODE_DATA(nid)->first_deferred_pfn != ULONG_MAX)",
            "\t\treturn true;",
            "\t/*",
            "\t * We start only with one section of pages, more pages are added as",
            "\t * needed until the rest of deferred pages are initialized.",
            "\t */",
            "\tnr_initialised++;",
            "\tif ((nr_initialised > PAGES_PER_SECTION) &&",
            "\t    (pfn & (PAGES_PER_SECTION - 1)) == 0) {",
            "\t\tNODE_DATA(nid)->first_deferred_pfn = pfn;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}"
          ],
          "function_name": "__init_single_page, __early_pfn_to_nid, early_pfn_to_nid, set_hashdist, fixup_hashdist, fixup_hashdist, pgdat_set_deferred_range, early_page_initialised, defer_init",
          "description": "初始化单页数据结构，实现PFN到节点ID映射，控制延迟初始化页面范围以优化早期启动性能",
          "similarity": 0.5686830282211304
        },
        {
          "chunk_id": 10,
          "file_path": "mm/mm_init.c",
          "start_line": 1443,
          "end_line": 1578,
          "content": [
            "static void __ref setup_usemap(struct zone *zone)",
            "{",
            "\tunsigned long usemapsize = usemap_size(zone->zone_start_pfn,",
            "\t\t\t\t\t       zone->spanned_pages);",
            "\tzone->pageblock_flags = NULL;",
            "\tif (usemapsize) {",
            "\t\tzone->pageblock_flags =",
            "\t\t\tmemblock_alloc_node(usemapsize, SMP_CACHE_BYTES,",
            "\t\t\t\t\t    zone_to_nid(zone));",
            "\t\tif (!zone->pageblock_flags)",
            "\t\t\tpanic(\"Failed to allocate %ld bytes for zone %s pageblock flags on node %d\\n\",",
            "\t\t\t      usemapsize, zone->name, zone_to_nid(zone));",
            "\t}",
            "}",
            "static inline void setup_usemap(struct zone *zone) {}",
            "void __init set_pageblock_order(void)",
            "{",
            "\tunsigned int order = MAX_PAGE_ORDER;",
            "",
            "\t/* Check that pageblock_nr_pages has not already been setup */",
            "\tif (pageblock_order)",
            "\t\treturn;",
            "",
            "\t/* Don't let pageblocks exceed the maximum allocation granularity. */",
            "\tif (HPAGE_SHIFT > PAGE_SHIFT && HUGETLB_PAGE_ORDER < order)",
            "\t\torder = HUGETLB_PAGE_ORDER;",
            "",
            "\t/*",
            "\t * Assume the largest contiguous order of interest is a huge page.",
            "\t * This value may be variable depending on boot parameters on powerpc.",
            "\t */",
            "\tpageblock_order = order;",
            "}",
            "void __init set_pageblock_order(void)",
            "{",
            "}",
            "void __ref free_area_init_core_hotplug(struct pglist_data *pgdat)",
            "{",
            "\tint nid = pgdat->node_id;",
            "\tenum zone_type z;",
            "\tint cpu;",
            "",
            "\tpgdat_init_internals(pgdat);",
            "",
            "\tif (pgdat->per_cpu_nodestats == &boot_nodestats)",
            "\t\tpgdat->per_cpu_nodestats = alloc_percpu(struct per_cpu_nodestat);",
            "",
            "\t/*",
            "\t * Reset the nr_zones, order and highest_zoneidx before reuse.",
            "\t * Note that kswapd will init kswapd_highest_zoneidx properly",
            "\t * when it starts in the near future.",
            "\t */",
            "\tpgdat->nr_zones = 0;",
            "\tpgdat->kswapd_order = 0;",
            "\tpgdat->kswapd_highest_zoneidx = 0;",
            "\tpgdat->node_start_pfn = 0;",
            "\tpgdat->node_present_pages = 0;",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct per_cpu_nodestat *p;",
            "",
            "\t\tp = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu);",
            "\t\tmemset(p, 0, sizeof(*p));",
            "\t}",
            "",
            "\t/*",
            "\t * When memory is hot-added, all the memory is in offline state. So",
            "\t * clear all zones' present_pages and managed_pages because they will",
            "\t * be updated in online_pages() and offline_pages().",
            "\t */",
            "\tfor (z = 0; z < MAX_NR_ZONES; z++) {",
            "\t\tstruct zone *zone = pgdat->node_zones + z;",
            "",
            "\t\tzone->present_pages = 0;",
            "\t\tzone_init_internals(zone, z, nid, 0);",
            "\t}",
            "}",
            "static void __init free_area_init_core(struct pglist_data *pgdat)",
            "{",
            "\tenum zone_type j;",
            "\tint nid = pgdat->node_id;",
            "",
            "\tpgdat_init_internals(pgdat);",
            "\tpgdat->per_cpu_nodestats = &boot_nodestats;",
            "",
            "\tfor (j = 0; j < MAX_NR_ZONES; j++) {",
            "\t\tstruct zone *zone = pgdat->node_zones + j;",
            "\t\tunsigned long size, freesize, memmap_pages;",
            "",
            "\t\tsize = zone->spanned_pages;",
            "\t\tfreesize = zone->present_pages;",
            "",
            "\t\t/*",
            "\t\t * Adjust freesize so that it accounts for how much memory",
            "\t\t * is used by this zone for memmap. This affects the watermark",
            "\t\t * and per-cpu initialisations",
            "\t\t */",
            "\t\tmemmap_pages = calc_memmap_size(size, freesize);",
            "\t\tif (!is_highmem_idx(j)) {",
            "\t\t\tif (freesize >= memmap_pages) {",
            "\t\t\t\tfreesize -= memmap_pages;",
            "\t\t\t\tif (memmap_pages)",
            "\t\t\t\t\tpr_debug(\"  %s zone: %lu pages used for memmap\\n\",",
            "\t\t\t\t\t\t zone_names[j], memmap_pages);",
            "\t\t\t} else",
            "\t\t\t\tpr_warn(\"  %s zone: %lu memmap pages exceeds freesize %lu\\n\",",
            "\t\t\t\t\tzone_names[j], memmap_pages, freesize);",
            "\t\t}",
            "",
            "\t\t/* Account for reserved pages */",
            "\t\tif (j == 0 && freesize > dma_reserve) {",
            "\t\t\tfreesize -= dma_reserve;",
            "\t\t\tpr_debug(\"  %s zone: %lu pages reserved\\n\", zone_names[0], dma_reserve);",
            "\t\t}",
            "",
            "\t\tif (!is_highmem_idx(j))",
            "\t\t\tnr_kernel_pages += freesize;",
            "\t\t/* Charge for highmem memmap if there are enough kernel pages */",
            "\t\telse if (nr_kernel_pages > memmap_pages * 2)",
            "\t\t\tnr_kernel_pages -= memmap_pages;",
            "\t\tnr_all_pages += freesize;",
            "",
            "\t\t/*",
            "\t\t * Set an approximate value for lowmem here, it will be adjusted",
            "\t\t * when the bootmem allocator frees pages into the buddy system.",
            "\t\t * And all highmem pages will be managed by the buddy system.",
            "\t\t */",
            "\t\tzone_init_internals(zone, j, nid, freesize);",
            "",
            "\t\tif (!size)",
            "\t\t\tcontinue;",
            "",
            "\t\tsetup_usemap(zone);",
            "\t\tinit_currently_empty_zone(zone, zone->zone_start_pfn, size);",
            "\t}",
            "}"
          ],
          "function_name": "setup_usemap, setup_usemap, set_pageblock_order, set_pageblock_order, free_area_init_core_hotplug, free_area_init_core",
          "description": "该代码段主要负责内存子系统初始化，涉及三个关键部分：  \n1. `setup_usemap`用于为页面块分配使用位图存储空间，以跟踪页面使用状态；  \n2. `set_pageblock_order`设定页面块大小（基于HugeTLB页限制），但存在重复定义导致上下文不完整；  \n3. `free_area_init_core_hotplug`与`free_area_init_core`协同初始化zone结构体，处理热插拔内存时的页面统计与MemMap占用修正。",
          "similarity": 0.5681347846984863
        }
      ]
    },
    {
      "source_file": "mm/kmsan/kmsan.h",
      "md_summary": "> 自动生成时间: 2025-12-07 16:31:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kmsan\\kmsan.h`\n\n---\n\n# `kmsan/kmsan.h` 技术文档\n\n## 文件概述\n\n`kmsan.h` 是 Linux 内核内存安全检测工具 **Kernel Memory Sanitizer (KMSAN)** 的核心头文件，定义了 KMSAN 运行时所需的数据结构、宏、全局变量和函数接口。KMSAN 用于检测内核中未初始化内存的使用（use-of-uninitialized-value）问题，通过维护每字节数据的**影子（shadow）** 和**起源（origin）** 元数据，在运行时追踪内存初始化状态并报告错误。\n\n该头文件为编译器插桩（instrumentation）生成的代码提供运行时支持，并确保 KMSAN 自身执行过程的安全性和一致性。\n\n## 核心功能\n\n### 宏定义\n- `KMSAN_ALLOCA_MAGIC_ORIGIN` / `KMSAN_CHAIN_MAGIC_ORIGIN`：特殊起源 ID，用于标识栈分配或起源链操作。\n- `KMSAN_POISON_*`：内存毒化（poisoning）模式标志（不检查、检查、释放后毒化）。\n- `KMSAN_ORIGIN_SIZE`：起源元数据大小（4 字节）。\n- `KMSAN_MAX_ORIGIN_DEPTH`：起源链最大深度（7 层）。\n- `KMSAN_STACK_DEPTH`：堆栈跟踪深度（64 帧）。\n- `KMSAN_META_SHADOW` / `KMSAN_META_ORIGIN`：元数据类型标识符。\n- `KMSAN_WARN_ON(cond)`：带状态禁用和可选 panic 的断言宏。\n\n### 全局变量\n- `kmsan_enabled`：KMSAN 是否启用（bool）。\n- `panic_on_kmsan`：检测到错误时是否触发内核 panic（int）。\n\n### 数据结构\n- `struct shadow_origin_ptr`：包含指向影子和起源元数据的指针对。\n- `struct kmsan_ctx`（声明于其他文件）：每个任务/每 CPU 的 KMSAN 上下文，含 `kmsan_in_runtime` 标志。\n\n### 主要函数\n- **元数据访问**：\n  - `kmsan_get_shadow_origin_ptr()`：获取指定地址范围的影子/起源指针。\n  - `kmsan_get_metadata()`：根据类型（影子/起源）返回元数据地址。\n- **初始化与设置**：\n  - `kmsan_init_alloc_meta_for_range()`：为指定虚拟地址范围预分配元数据。\n  - `kmsan_setup_meta()`：为物理页关联影子页和起源页。\n- **错误报告**：\n  - `kmsan_report()`：报告未初始化内存使用错误。\n  - `kmsan_print_origin()`：打印起源堆栈信息。\n- **运行时控制**：\n  - `kmsan_enter_runtime()` / `kmsan_leave_runtime()`：标记进入/离开 KMSAN 运行时。\n  - `kmsan_in_runtime()`：判断当前是否处于 KMSAN 运行时上下文。\n- **堆栈处理**：\n  - `kmsan_save_stack()` / `kmsan_save_stack_with_flags()`：保存当前调用栈并返回句柄。\n  - 起源链辅助函数（`kmsan_extra_bits`, `kmsan_uaf_from_eb`, `kmsan_depth_from_eb`）。\n- **内部操作（非递归安全）**：\n  - `kmsan_internal_memmove_metadata()`：复制元数据。\n  - `kmsan_internal_poison_memory()` / `kmsan_internal_unpoison_memory()`：毒化/解毒内存。\n  - `kmsan_internal_set_shadow_origin()`：直接设置影子和起源值。\n  - `kmsan_internal_chain_origin()`：构建起源链。\n  - `kmsan_internal_task_create()`：初始化新任务的 KMSAN 上下文。\n  - `kmsan_internal_check_memory()`：主动检查内存初始化状态。\n- **地址空间判断**：\n  - `kmsan_internal_is_module_addr()` / `kmsan_internal_is_vmalloc_addr()`：安全判断地址是否属于模块或 vmalloc 区域。\n\n## 关键实现\n\n### 运行时递归防护\nKMSAN 使用 `kmsan_in_runtime()` 检查防止运行时函数被自身插桩代码递归调用：\n- 检查硬中断嵌套层数（>1）或 NMI 上下文时直接返回 `true`。\n- 否则查询 per-task/per-CPU 上下文中的 `kmsan_in_runtime` 计数器。\n- `kmsan_enter_runtime()`/`kmsan_leave_runtime()` 通过原子增减该计数器管理入口区域。\n\n### 起源（Origin）压缩存储\n利用 `stackdepot` 的额外位（extra bits）存储起源链信息：\n- 最低位表示是否为 Use-After-Free（UAF）。\n- 高位存储起源链深度（最大 7，故需 3 位，共使用 4 位）。\n- 通过 `kmsan_extra_bits()` 打包，`kmsan_uaf_from_eb()` 和 `kmsan_depth_from_eb()` 解包。\n\n### 错误报告机制\n`kmsan_report()` 支持细粒度报告：\n- 对同一内存访问中不同起源的未初始化字节分段报告（通过 `off_first`/`off_last`）。\n- 支持多种错误场景（如 `REASON_COPY_TO_USER` 表示向用户态泄露未初始化数据）。\n\n### 元数据布局\n- 影子（shadow）：每字节对应 1 字节，标记是否初始化。\n- 起源（origin）：每 4 字节数据对应 4 字节起源 ID（`KMSAN_ORIGIN_SIZE=4`）。\n- 元数据独立映射，通过 `kmsan_get_metadata()` 动态计算地址。\n\n### 安全断言\n`KMSAN_WARN_ON()` 在条件成立时：\n1. 禁用 KMSAN（`kmsan_enabled = false`）。\n2. 若 `panic_on_kmsan` 启用，则调用 `BUG()`（避免在 uaccess 上下文中调用 `panic()`）。\n\n## 依赖关系\n\n- **架构相关**：依赖 `<asm/pgtable_64_types.h>` 获取 `MODULES_VADDR`、`VMALLOC_START` 等地址边界（仅限 64 位）。\n- **内核子系统**：\n  - 内存管理（`<linux/mm.h>`）：页分配、vmalloc 处理。\n  - 调度器（`<linux/sched.h>`）：任务结构体中的 `kmsan_ctx`。\n  - 中断/NMI（`<linux/irqflags.h>`, `<linux/nmi.h>`）：运行时上下文判断。\n  - 堆栈跟踪（`<linux/stacktrace.h>`, `<linux/stackdepot.h>`）：起源信息存储。\n- **编译器支持**：需 Clang 编译器插桩生成对 `kmsan_get_shadow_origin_ptr()` 等函数的调用。\n\n## 使用场景\n\n1. **编译器插桩**：Clang 在访问内存前插入对 `kmsan_get_shadow_origin_ptr()` 的调用，检查影子状态。\n2. **内存分配/释放**：\n   - `kmalloc`/`kfree`、`vmalloc`/`vfree` 等路径调用 `kmsan_internal_poison_memory()` 标记未初始化或释放状态。\n   - 页面分配器通过 `kmsan_setup_meta()` 关联元数据页。\n3. **错误检测**：\n   - 当插桩代码发现未初始化内存被使用时，调用 `kmsan_report()` 输出详细错误。\n   - 显式检查点（如系统调用出口）调用 `kmsan_internal_check_memory()` 防止泄露。\n4. **任务创建**：`copy_process()` 调用 `kmsan_internal_task_create()` 初始化子进程 KMSAN 上下文。\n5. **元数据操作**：`memcpy`/`memmove` 等函数的 KMSAN 版本调用 `kmsan_internal_memmove_metadata()` 同步元数据。",
      "similarity": 0.6084663271903992,
      "chunks": []
    }
  ]
}