{
  "query": "operating system types",
  "timestamp": "2025-12-25 23:57:26",
  "retrieved_files": [
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.5371911525726318,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.5646084547042847
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.4988653063774109
        }
      ]
    },
    {
      "source_file": "kernel/rcu/tree.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:46:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\tree.c`\n\n---\n\n# `rcu/tree.c` 技术文档\n\n## 1. 文件概述\n\n`rcu/tree.c` 是 Linux 内核中 **Read-Copy Update (RCU)** 机制的树形（tree-based）实现核心文件。RCU 是一种高性能的同步原语，用于在读多写少的场景下实现无锁读取与安全更新。该文件实现了基于分层树结构的 RCU 状态管理、宽限期（Grace Period）检测、回调处理、CPU 离线/上线处理以及与调度器、中断、kthread 等子系统的集成。树形结构的设计使得 RCU 能够高效扩展到大规模多核系统（数百甚至上千 CPU）。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct rcu_data`**（每 CPU）  \n  存储每个 CPU 的 RCU 状态，包括待处理的回调链表、宽限期序列号、QS（Quiescent State）状态等。\n  \n- **`struct rcu_state`**（全局）  \n  全局 RCU 状态机，包含宽限期状态（`gp_state`）、序列号（`gp_seq`）、树形节点层级结构（`level[]`）、互斥锁（如 `barrier_mutex`、`exp_mutex`）等。\n\n- **`struct rcu_node`**（层级节点）  \n  构成 RCU 树的内部节点，用于聚合子节点（CPU 或下层 `rcu_node`）的宽限期完成状态，实现分层检测，减少全局同步开销。\n\n- **全局变量**：\n  - `rcu_scheduler_active`：指示调度器是否已激活，影响 RCU 初始化和优化策略。\n  - `rcu_scheduler_fully_active`：指示 RCU 是否已完全初始化（包括 kthread 启动）。\n  - `rcu_num_lvls` / `num_rcu_lvl[]` / `rcu_num_nodes`：描述 RCU 树的层级结构和节点数量。\n  - 多个模块参数（如 `use_softirq`, `rcu_fanout_leaf`, `kthread_prio` 等）用于运行时调优和调试。\n\n### 主要函数（声明/定义）\n\n- **宽限期管理**：\n  - `rcu_report_qs_rnp()`：向上报告某 `rcu_node` 的 QS 状态。\n  - `invoke_rcu_core()`：触发 RCU 核心处理（如宽限期推进或回调执行）。\n\n- **回调处理**：\n  - `rcu_report_exp_rdp()`：报告扩展（expedited）宽限期完成。\n  - `check_cb_ovld_locked()`：检查回调过载情况。\n\n- **CPU 热插拔支持**：\n  - `rcu_boost_kthread_setaffinity()`：调整 RCU boost kthread 的 CPU 亲和性。\n  - `sync_sched_exp_online_cleanup()`：清理 CPU 上线时的扩展同步状态。\n  - `rcu_cleanup_dead_rnp()` / `rcu_init_new_rnp()`：处理 CPU 离线/上线时的 `rcu_node` 结构。\n\n- **辅助函数**：\n  - `rcu_rdp_is_offloaded()`：判断 RCU 回调是否被卸载到专用 kthread（NO_HZ_FULL/NO_CB 场景）。\n  - `rcu_rdp_cpu_online()`：检查对应 CPU 是否在线。\n  - `rcu_init_invoked()`：判断 RCU 初始化是否已启动。\n\n- **导出接口**：\n  - `rcu_get_gp_kthreads_prio()`：供 `rcutorture` 等测试模块获取 RCU kthread 优先级。\n\n## 3. 关键实现\n\n### 树形宽限期检测机制\nRCU 使用分层树结构（`rcu_node` 树）来高效检测宽限期完成：\n- 叶子层对应 CPU，上层节点聚合子节点状态。\n- 每个 `rcu_node` 维护一个位图（`qsmask`），记录哪些子节点尚未报告 QS。\n- 当所有子节点都报告 QS 后，该节点向上层报告，最终根节点完成整个宽限期。\n- 此设计将 O(N) 的全局同步开销降低为 O(log N)，适用于大规模系统。\n\n### 宽限期状态机\n- 全局状态 `rcu_state.gp_state` 控制宽限期生命周期（IDLE → WAITING → DONE 等）。\n- 使用 64 位序列号 `gp_seq` 标识宽限期，通过位移（`RCU_SEQ_CTR_SHIFT`）区分状态。\n- 初始序列号设为 `(0UL - 300UL) << RCU_SEQ_CTR_SHIFT`，确保启动时处于有效状态。\n\n### 调度器集成与启动阶段优化\n- `rcu_scheduler_active` 分三阶段：\n  1. `RCU_SCHEDULER_INACTIVE`：单任务阶段，`synchronize_rcu()` 退化为内存屏障。\n  2. `RCU_SCHEDULER_INIT`：调度器启动但 RCU 未完全初始化。\n  3. `RCU_SCHEDULER_RUNNING`：RCU 完全激活。\n- `rcu_scheduler_fully_active` 确保 RCU 回调和 kthread 在调度器支持多任务后才启用。\n\n### 回调处理策略\n- 支持两种回调执行模式：\n  - **软中断（`RCU_SOFTIRQ`）**：默认模式，通过 `rcu_softirq` 处理。\n  - **专用 kthread（`rcuc`/`rcub`）**：在 `PREEMPT_RT` 或配置 `NO_CB` 时使用，避免软中断延迟。\n- 通过 `use_softirq` 模块参数控制模式选择。\n\n### 调试与调优支持\n- 多个延迟参数（`gp_preinit_delay` 等）用于注入延迟以暴露竞态条件。\n- `rcu_unlock_delay` 在 `CONFIG_RCU_STRICT_GRACE_PERIOD` 下强制延迟 `rcu_read_unlock()`。\n- `dump_tree` 参数可在启动时打印 RCU 树结构用于验证。\n- `rcu_fanout_leaf` 和 `rcu_fanout_exact` 控制树的扇出（fanout）结构。\n\n### 内存与资源管理\n- `rcu_min_cached_objs` 控制每 CPU 缓存的最小对象数（以页为单位）。\n- `rcu_delay_page_cache_fill_msec` 在内存压力下延迟填充 RCU 缓存，避免与页回收冲突。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - 基础内核设施：`<linux/smp.h>`, `<linux/sched.h>`, `<linux/interrupt.h>`, `<linux/percpu.h>` 等。\n  - 时间子系统：`<linux/tick.h>`, `<linux/jiffies.h>`。\n  - 内存管理：`<linux/mm.h>`, `<linux/slab.h>`, `<linux/vmalloc.h>`。\n  - 调试与追踪：`<linux/lockdep.h>`, `<linux/ftrace.h>`, `<linux/kasan.h>`。\n  - RCU 内部头文件：`\"tree.h\"`, `\"rcu.h\"`。\n\n- **模块依赖**：\n  - 与调度器深度集成（`rcu_scheduler_active` 状态依赖 `sched/`）。\n  - 依赖中断子系统处理 QS 检测（如 tick 中断）。\n  - 与 CPU 热插拔机制协同（`cpuhp` 框架）。\n  - 在 `PREEMPT_RT` 下依赖实时调度特性。\n  - 与内存回收（shrinker）交互以管理缓存。\n\n## 5. 使用场景\n\n- **内核同步原语**：为 `synchronize_rcu()`, `call_rcu()` 等 API 提供底层实现。\n- **大规模多核系统**：通过树形结构支持数百至数千 CPU 的高效宽限期检测。\n- **实时系统**：通过 `rcuc` kthread 和优先级控制（`kthread_prio`）满足实时性要求。\n- **CPU 热插拔**：动态调整 RCU 树结构以适应 CPU 在线/离线。\n- **内存压力场景**：与页回收协同，避免 RCU 缓存加剧内存紧张。\n- **内核调试与测试**：\n  - `rcutorture` 模块利用此文件接口进行压力测试。\n  - 通过延迟参数和 `dump_tree` 辅助调试竞态和结构问题。\n- **低延迟场景**：在 `NO_HZ_FULL` 或 `NO_CB` 配置下，将 RCU 回调卸载到专用 CPU，减少主 CPU 干扰。",
      "similarity": 0.5293257832527161,
      "chunks": [
        {
          "chunk_id": 11,
          "file_path": "kernel/rcu/tree.c",
          "start_line": 2012,
          "end_line": 2249,
          "content": [
            "static void",
            "rcu_report_qs_rdp(struct rcu_data *rdp)",
            "{",
            "\tunsigned long flags;",
            "\tunsigned long mask;",
            "\tbool needacc = false;",
            "\tstruct rcu_node *rnp;",
            "",
            "\tWARN_ON_ONCE(rdp->cpu != smp_processor_id());",
            "\trnp = rdp->mynode;",
            "\traw_spin_lock_irqsave_rcu_node(rnp, flags);",
            "\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||",
            "\t    rdp->gpwrap) {",
            "",
            "\t\t/*",
            "\t\t * The grace period in which this quiescent state was",
            "\t\t * recorded has ended, so don't report it upwards.",
            "\t\t * We will instead need a new quiescent state that lies",
            "\t\t * within the current grace period.",
            "\t\t */",
            "\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */",
            "\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);",
            "\t\treturn;",
            "\t}",
            "\tmask = rdp->grpmask;",
            "\trdp->core_needs_qs = false;",
            "\tif ((rnp->qsmask & mask) == 0) {",
            "\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);",
            "\t} else {",
            "\t\t/*",
            "\t\t * This GP can't end until cpu checks in, so all of our",
            "\t\t * callbacks can be processed during the next GP.",
            "\t\t *",
            "\t\t * NOCB kthreads have their own way to deal with that...",
            "\t\t */",
            "\t\tif (!rcu_rdp_is_offloaded(rdp)) {",
            "\t\t\t/*",
            "\t\t\t * The current GP has not yet ended, so it",
            "\t\t\t * should not be possible for rcu_accelerate_cbs()",
            "\t\t\t * to return true.  So complain, but don't awaken.",
            "\t\t\t */",
            "\t\t\tWARN_ON_ONCE(rcu_accelerate_cbs(rnp, rdp));",
            "\t\t} else if (!rcu_segcblist_completely_offloaded(&rdp->cblist)) {",
            "\t\t\t/*",
            "\t\t\t * ...but NOCB kthreads may miss or delay callbacks acceleration",
            "\t\t\t * if in the middle of a (de-)offloading process.",
            "\t\t\t */",
            "\t\t\tneedacc = true;",
            "\t\t}",
            "",
            "\t\trcu_disable_urgency_upon_qs(rdp);",
            "\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);",
            "\t\t/* ^^^ Released rnp->lock */",
            "",
            "\t\tif (needacc) {",
            "\t\t\trcu_nocb_lock_irqsave(rdp, flags);",
            "\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);",
            "\t\t\trcu_nocb_unlock_irqrestore(rdp, flags);",
            "\t\t}",
            "\t}",
            "}",
            "static void",
            "rcu_check_quiescent_state(struct rcu_data *rdp)",
            "{",
            "\t/* Check for grace-period ends and beginnings. */",
            "\tnote_gp_changes(rdp);",
            "",
            "\t/*",
            "\t * Does this CPU still need to do its part for current grace period?",
            "\t * If no, return and let the other CPUs do their part as well.",
            "\t */",
            "\tif (!rdp->core_needs_qs)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Was there a quiescent state since the beginning of the grace",
            "\t * period? If no, then exit and wait for the next call.",
            "\t */",
            "\tif (rdp->cpu_no_qs.b.norm)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the",
            "\t * judge of that).",
            "\t */",
            "\trcu_report_qs_rdp(rdp);",
            "}",
            "static bool rcu_do_batch_check_time(long count, long tlimit,",
            "\t\t\t\t    bool jlimit_check, unsigned long jlimit)",
            "{",
            "\t// Invoke local_clock() only once per 32 consecutive callbacks.",
            "\treturn unlikely(tlimit) &&",
            "\t       (!likely(count & 31) ||",
            "\t\t(IS_ENABLED(CONFIG_RCU_DOUBLE_CHECK_CB_TIME) &&",
            "\t\t jlimit_check && time_after(jiffies, jlimit))) &&",
            "\t       local_clock() >= tlimit;",
            "}",
            "static void rcu_do_batch(struct rcu_data *rdp)",
            "{",
            "\tlong bl;",
            "\tlong count = 0;",
            "\tint div;",
            "\tbool __maybe_unused empty;",
            "\tunsigned long flags;",
            "\tunsigned long jlimit;",
            "\tbool jlimit_check = false;",
            "\tlong pending;",
            "\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);",
            "\tstruct rcu_head *rhp;",
            "\tlong tlimit = 0;",
            "",
            "\t/* If no callbacks are ready, just return. */",
            "\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {",
            "\t\ttrace_rcu_batch_start(rcu_state.name,",
            "\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);",
            "\t\ttrace_rcu_batch_end(rcu_state.name, 0,",
            "\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),",
            "\t\t\t\t    need_resched(), is_idle_task(current),",
            "\t\t\t\t    rcu_is_callbacks_kthread(rdp));",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Extract the list of ready callbacks, disabling IRQs to prevent",
            "\t * races with call_rcu() from interrupt handlers.  Leave the",
            "\t * callback counts, as rcu_barrier() needs to be conservative.",
            "\t */",
            "\trcu_nocb_lock_irqsave(rdp, flags);",
            "\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));",
            "\tpending = rcu_segcblist_get_seglen(&rdp->cblist, RCU_DONE_TAIL);",
            "\tdiv = READ_ONCE(rcu_divisor);",
            "\tdiv = div < 0 ? 7 : div > sizeof(long) * 8 - 2 ? sizeof(long) * 8 - 2 : div;",
            "\tbl = max(rdp->blimit, pending >> div);",
            "\tif ((in_serving_softirq() || rdp->rcu_cpu_kthread_status == RCU_KTHREAD_RUNNING) &&",
            "\t    (IS_ENABLED(CONFIG_RCU_DOUBLE_CHECK_CB_TIME) || unlikely(bl > 100))) {",
            "\t\tconst long npj = NSEC_PER_SEC / HZ;",
            "\t\tlong rrn = READ_ONCE(rcu_resched_ns);",
            "",
            "\t\trrn = rrn < NSEC_PER_MSEC ? NSEC_PER_MSEC : rrn > NSEC_PER_SEC ? NSEC_PER_SEC : rrn;",
            "\t\ttlimit = local_clock() + rrn;",
            "\t\tjlimit = jiffies + (rrn + npj + 1) / npj;",
            "\t\tjlimit_check = true;",
            "\t}",
            "\ttrace_rcu_batch_start(rcu_state.name,",
            "\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);",
            "\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);",
            "\tif (rcu_rdp_is_offloaded(rdp))",
            "\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);",
            "",
            "\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbDequeued\"));",
            "\trcu_nocb_unlock_irqrestore(rdp, flags);",
            "",
            "\t/* Invoke callbacks. */",
            "\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);",
            "\trhp = rcu_cblist_dequeue(&rcl);",
            "",
            "\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {",
            "\t\trcu_callback_t f;",
            "",
            "\t\tcount++;",
            "\t\tdebug_rcu_head_unqueue(rhp);",
            "",
            "\t\trcu_lock_acquire(&rcu_callback_map);",
            "\t\ttrace_rcu_invoke_callback(rcu_state.name, rhp);",
            "",
            "\t\tf = rhp->func;",
            "\t\tdebug_rcu_head_callback(rhp);",
            "\t\tWRITE_ONCE(rhp->func, (rcu_callback_t)0L);",
            "\t\tf(rhp);",
            "",
            "\t\trcu_lock_release(&rcu_callback_map);",
            "",
            "\t\t/*",
            "\t\t * Stop only if limit reached and CPU has something to do.",
            "\t\t */",
            "\t\tif (in_serving_softirq()) {",
            "\t\t\tif (count >= bl && (need_resched() || !is_idle_task(current)))",
            "\t\t\t\tbreak;",
            "\t\t\t/*",
            "\t\t\t * Make sure we don't spend too much time here and deprive other",
            "\t\t\t * softirq vectors of CPU cycles.",
            "\t\t\t */",
            "\t\t\tif (rcu_do_batch_check_time(count, tlimit, jlimit_check, jlimit))",
            "\t\t\t\tbreak;",
            "\t\t} else {",
            "\t\t\t// In rcuc/rcuoc context, so no worries about",
            "\t\t\t// depriving other softirq vectors of CPU cycles.",
            "\t\t\tlocal_bh_enable();",
            "\t\t\tlockdep_assert_irqs_enabled();",
            "\t\t\tcond_resched_tasks_rcu_qs();",
            "\t\t\tlockdep_assert_irqs_enabled();",
            "\t\t\tlocal_bh_disable();",
            "\t\t\t// But rcuc kthreads can delay quiescent-state",
            "\t\t\t// reporting, so check time limits for them.",
            "\t\t\tif (rdp->rcu_cpu_kthread_status == RCU_KTHREAD_RUNNING &&",
            "\t\t\t    rcu_do_batch_check_time(count, tlimit, jlimit_check, jlimit)) {",
            "\t\t\t\trdp->rcu_cpu_has_work = 1;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\trcu_nocb_lock_irqsave(rdp, flags);",
            "\trdp->n_cbs_invoked += count;",
            "\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),",
            "\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread(rdp));",
            "",
            "\t/* Update counts and requeue any remaining callbacks. */",
            "\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);",
            "\trcu_segcblist_add_len(&rdp->cblist, -count);",
            "",
            "\t/* Reinstate batch limit if we have worked down the excess. */",
            "\tcount = rcu_segcblist_n_cbs(&rdp->cblist);",
            "\tif (rdp->blimit >= DEFAULT_MAX_RCU_BLIMIT && count <= qlowmark)",
            "\t\trdp->blimit = blimit;",
            "",
            "\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */",
            "\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {",
            "\t\trdp->qlen_last_fqs_check = 0;",
            "\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);",
            "\t} else if (count < rdp->qlen_last_fqs_check - qhimark)",
            "\t\trdp->qlen_last_fqs_check = count;",
            "",
            "\t/*",
            "\t * The following usually indicates a double call_rcu().  To track",
            "\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.",
            "\t */",
            "\tempty = rcu_segcblist_empty(&rdp->cblist);",
            "\tWARN_ON_ONCE(count == 0 && !empty);",
            "\tWARN_ON_ONCE(!IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&",
            "\t\t     count != 0 && empty);",
            "\tWARN_ON_ONCE(count == 0 && rcu_segcblist_n_segment_cbs(&rdp->cblist) != 0);",
            "\tWARN_ON_ONCE(!empty && rcu_segcblist_n_segment_cbs(&rdp->cblist) == 0);",
            "",
            "\trcu_nocb_unlock_irqrestore(rdp, flags);",
            "",
            "\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);",
            "}"
          ],
          "function_name": "rcu_report_qs_rdp, rcu_check_quiescent_state, rcu_do_batch_check_time, rcu_do_batch",
          "description": "提供CPU级quiescent状态检测与回调处理机制，包含quiescent状态上报、回调批量处理及性能监控功能，支持动态调整批处理参数",
          "similarity": 0.49006009101867676
        },
        {
          "chunk_id": 27,
          "file_path": "kernel/rcu/tree.c",
          "start_line": 4895,
          "end_line": 5082,
          "content": [
            "static void __init rcu_init_one(void)",
            "{",
            "\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;",
            "\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;",
            "\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];",
            "\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];",
            "",
            "\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */",
            "\tint cpustride = 1;",
            "\tint i;",
            "\tint j;",
            "\tstruct rcu_node *rnp;",
            "",
            "\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */",
            "",
            "\t/* Silence gcc 4.8 false positive about array index out of range. */",
            "\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)",
            "\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");",
            "",
            "\t/* Initialize the level-tracking arrays. */",
            "",
            "\tfor (i = 1; i < rcu_num_lvls; i++)",
            "\t\trcu_state.level[i] =",
            "\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];",
            "\trcu_init_levelspread(levelspread, num_rcu_lvl);",
            "",
            "\t/* Initialize the elements themselves, starting from the leaves. */",
            "",
            "\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {",
            "\t\tcpustride *= levelspread[i];",
            "\t\trnp = rcu_state.level[i];",
            "\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {",
            "\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));",
            "\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),",
            "\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);",
            "\t\t\traw_spin_lock_init(&rnp->fqslock);",
            "\t\t\tlockdep_set_class_and_name(&rnp->fqslock,",
            "\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);",
            "\t\t\trnp->gp_seq = rcu_state.gp_seq;",
            "\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;",
            "\t\t\trnp->completedqs = rcu_state.gp_seq;",
            "\t\t\trnp->qsmask = 0;",
            "\t\t\trnp->qsmaskinit = 0;",
            "\t\t\trnp->grplo = j * cpustride;",
            "\t\t\trnp->grphi = (j + 1) * cpustride - 1;",
            "\t\t\tif (rnp->grphi >= nr_cpu_ids)",
            "\t\t\t\trnp->grphi = nr_cpu_ids - 1;",
            "\t\t\tif (i == 0) {",
            "\t\t\t\trnp->grpnum = 0;",
            "\t\t\t\trnp->grpmask = 0;",
            "\t\t\t\trnp->parent = NULL;",
            "\t\t\t} else {",
            "\t\t\t\trnp->grpnum = j % levelspread[i - 1];",
            "\t\t\t\trnp->grpmask = BIT(rnp->grpnum);",
            "\t\t\t\trnp->parent = rcu_state.level[i - 1] +",
            "\t\t\t\t\t      j / levelspread[i - 1];",
            "\t\t\t}",
            "\t\t\trnp->level = i;",
            "\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);",
            "\t\t\trcu_init_one_nocb(rnp);",
            "\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);",
            "\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);",
            "\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);",
            "\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);",
            "\t\t\tspin_lock_init(&rnp->exp_lock);",
            "\t\t\tmutex_init(&rnp->boost_kthread_mutex);",
            "\t\t\traw_spin_lock_init(&rnp->exp_poll_lock);",
            "\t\t\trnp->exp_seq_poll_rq = RCU_GET_STATE_COMPLETED;",
            "\t\t\tINIT_WORK(&rnp->exp_poll_wq, sync_rcu_do_polled_gp);",
            "\t\t}",
            "\t}",
            "",
            "\tinit_swait_queue_head(&rcu_state.gp_wq);",
            "\tinit_swait_queue_head(&rcu_state.expedited_wq);",
            "\trnp = rcu_first_leaf_node();",
            "\tfor_each_possible_cpu(i) {",
            "\t\twhile (i > rnp->grphi)",
            "\t\t\trnp++;",
            "\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;",
            "\t\trcu_boot_init_percpu_data(i);",
            "\t}",
            "}",
            "static void __init sanitize_kthread_prio(void)",
            "{",
            "\tint kthread_prio_in = kthread_prio;",
            "",
            "\tif (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 2",
            "\t    && IS_BUILTIN(CONFIG_RCU_TORTURE_TEST))",
            "\t\tkthread_prio = 2;",
            "\telse if (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 1)",
            "\t\tkthread_prio = 1;",
            "\telse if (kthread_prio < 0)",
            "\t\tkthread_prio = 0;",
            "\telse if (kthread_prio > 99)",
            "\t\tkthread_prio = 99;",
            "",
            "\tif (kthread_prio != kthread_prio_in)",
            "\t\tpr_alert(\"%s: Limited prio to %d from %d\\n\",",
            "\t\t\t __func__, kthread_prio, kthread_prio_in);",
            "}",
            "void rcu_init_geometry(void)",
            "{",
            "\tulong d;",
            "\tint i;",
            "\tstatic unsigned long old_nr_cpu_ids;",
            "\tint rcu_capacity[RCU_NUM_LVLS];",
            "\tstatic bool initialized;",
            "",
            "\tif (initialized) {",
            "\t\t/*",
            "\t\t * Warn if setup_nr_cpu_ids() had not yet been invoked,",
            "\t\t * unless nr_cpus_ids == NR_CPUS, in which case who cares?",
            "\t\t */",
            "\t\tWARN_ON_ONCE(old_nr_cpu_ids != nr_cpu_ids);",
            "\t\treturn;",
            "\t}",
            "",
            "\told_nr_cpu_ids = nr_cpu_ids;",
            "\tinitialized = true;",
            "",
            "\t/*",
            "\t * Initialize any unspecified boot parameters.",
            "\t * The default values of jiffies_till_first_fqs and",
            "\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS",
            "\t * value, which is a function of HZ, then adding one for each",
            "\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.",
            "\t */",
            "\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;",
            "\tif (jiffies_till_first_fqs == ULONG_MAX)",
            "\t\tjiffies_till_first_fqs = d;",
            "\tif (jiffies_till_next_fqs == ULONG_MAX)",
            "\t\tjiffies_till_next_fqs = d;",
            "\tadjust_jiffies_till_sched_qs();",
            "",
            "\t/* If the compile-time values are accurate, just leave. */",
            "\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&",
            "\t    nr_cpu_ids == NR_CPUS)",
            "\t\treturn;",
            "\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",",
            "\t\trcu_fanout_leaf, nr_cpu_ids);",
            "",
            "\t/*",
            "\t * The boot-time rcu_fanout_leaf parameter must be at least two",
            "\t * and cannot exceed the number of bits in the rcu_node masks.",
            "\t * Complain and fall back to the compile-time values if this",
            "\t * limit is exceeded.",
            "\t */",
            "\tif (rcu_fanout_leaf < 2 ||",
            "\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {",
            "\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Compute number of nodes that can be handled an rcu_node tree",
            "\t * with the given number of levels.",
            "\t */",
            "\trcu_capacity[0] = rcu_fanout_leaf;",
            "\tfor (i = 1; i < RCU_NUM_LVLS; i++)",
            "\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;",
            "",
            "\t/*",
            "\t * The tree must be able to accommodate the configured number of CPUs.",
            "\t * If this limit is exceeded, fall back to the compile-time values.",
            "\t */",
            "\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {",
            "\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Calculate the number of levels in the tree. */",
            "\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {",
            "\t}",
            "\trcu_num_lvls = i + 1;",
            "",
            "\t/* Calculate the number of rcu_nodes at each level of the tree. */",
            "\tfor (i = 0; i < rcu_num_lvls; i++) {",
            "\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];",
            "\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);",
            "\t}",
            "",
            "\t/* Calculate the total number of rcu_node structures. */",
            "\trcu_num_nodes = 0;",
            "\tfor (i = 0; i < rcu_num_lvls; i++)",
            "\t\trcu_num_nodes += num_rcu_lvl[i];",
            "}"
          ],
          "function_name": "rcu_init_one, sanitize_kthread_prio, rcu_init_geometry",
          "description": "构建多级RCU节点树结构，初始化各层级的锁类和节点属性，动态调整RCU树的几何形态以适配当前CPU数量和层级分布需求。",
          "similarity": 0.47447460889816284
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/rcu/tree.c",
          "start_line": 2523,
          "end_line": 2628,
          "content": [
            "static void rcu_cpu_kthread_park(unsigned int cpu)",
            "{",
            "\tper_cpu(rcu_data.rcu_cpu_kthread_status, cpu) = RCU_KTHREAD_OFFCPU;",
            "}",
            "static int rcu_cpu_kthread_should_run(unsigned int cpu)",
            "{",
            "\treturn __this_cpu_read(rcu_data.rcu_cpu_has_work);",
            "}",
            "static void rcu_cpu_kthread(unsigned int cpu)",
            "{",
            "\tunsigned int *statusp = this_cpu_ptr(&rcu_data.rcu_cpu_kthread_status);",
            "\tchar work, *workp = this_cpu_ptr(&rcu_data.rcu_cpu_has_work);",
            "\tunsigned long *j = this_cpu_ptr(&rcu_data.rcuc_activity);",
            "\tint spincnt;",
            "",
            "\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_run\"));",
            "\tfor (spincnt = 0; spincnt < 10; spincnt++) {",
            "\t\tWRITE_ONCE(*j, jiffies);",
            "\t\tlocal_bh_disable();",
            "\t\t*statusp = RCU_KTHREAD_RUNNING;",
            "\t\tlocal_irq_disable();",
            "\t\twork = *workp;",
            "\t\tWRITE_ONCE(*workp, 0);",
            "\t\tlocal_irq_enable();",
            "\t\tif (work)",
            "\t\t\trcu_core();",
            "\t\tlocal_bh_enable();",
            "\t\tif (!READ_ONCE(*workp)) {",
            "\t\t\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_wait\"));",
            "\t\t\t*statusp = RCU_KTHREAD_WAITING;",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "\t*statusp = RCU_KTHREAD_YIELDING;",
            "\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_yield\"));",
            "\tschedule_timeout_idle(2);",
            "\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_yield\"));",
            "\t*statusp = RCU_KTHREAD_WAITING;",
            "\tWRITE_ONCE(*j, jiffies);",
            "}",
            "static int __init rcu_spawn_core_kthreads(void)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tper_cpu(rcu_data.rcu_cpu_has_work, cpu) = 0;",
            "\tif (use_softirq)",
            "\t\treturn 0;",
            "\tWARN_ONCE(smpboot_register_percpu_thread(&rcu_cpu_thread_spec),",
            "\t\t  \"%s: Could not start rcuc kthread, OOM is now expected behavior\\n\", __func__);",
            "\treturn 0;",
            "}",
            "static void rcutree_enqueue(struct rcu_data *rdp, struct rcu_head *head, rcu_callback_t func)",
            "{",
            "\trcu_segcblist_enqueue(&rdp->cblist, head);",
            "\tif (__is_kvfree_rcu_offset((unsigned long)func))",
            "\t\ttrace_rcu_kvfree_callback(rcu_state.name, head,",
            "\t\t\t\t\t (unsigned long)func,",
            "\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));",
            "\telse",
            "\t\ttrace_rcu_callback(rcu_state.name, head,",
            "\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));",
            "\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCBQueued\"));",
            "}",
            "static void call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,",
            "\t\t\t  rcu_callback_t func, unsigned long flags)",
            "{",
            "\trcutree_enqueue(rdp, head, func);",
            "\t/*",
            "\t * If called from an extended quiescent state, invoke the RCU",
            "\t * core in order to force a re-evaluation of RCU's idleness.",
            "\t */",
            "\tif (!rcu_is_watching())",
            "\t\tinvoke_rcu_core();",
            "",
            "\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */",
            "\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Force the grace period if too many callbacks or too long waiting.",
            "\t * Enforce hysteresis, and don't invoke rcu_force_quiescent_state()",
            "\t * if some other CPU has recently done so.  Also, don't bother",
            "\t * invoking rcu_force_quiescent_state() if the newly enqueued callback",
            "\t * is the only one waiting for a grace period to complete.",
            "\t */",
            "\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >",
            "\t\t     rdp->qlen_last_fqs_check + qhimark)) {",
            "",
            "\t\t/* Are we ignoring a completed grace period? */",
            "\t\tnote_gp_changes(rdp);",
            "",
            "\t\t/* Start a new grace period if one not already started. */",
            "\t\tif (!rcu_gp_in_progress()) {",
            "\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);",
            "\t\t} else {",
            "\t\t\t/* Give the grace period a kick. */",
            "\t\t\trdp->blimit = DEFAULT_MAX_RCU_BLIMIT;",
            "\t\t\tif (READ_ONCE(rcu_state.n_force_qs) == rdp->n_force_qs_snap &&",
            "\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)",
            "\t\t\t\trcu_force_quiescent_state();",
            "\t\t\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);",
            "\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "rcu_cpu_kthread_park, rcu_cpu_kthread_should_run, rcu_cpu_kthread, rcu_spawn_core_kthreads, rcutree_enqueue, call_rcu_core",
          "description": "实现RCU k线程管理与回调分发基础设施，包含线程启动、回调入队及触发条件判断逻辑，提供跨CPU的异步处理能力",
          "similarity": 0.47286078333854675
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/rcu/tree.c",
          "start_line": 1840,
          "end_line": 1973,
          "content": [
            "static int __noreturn rcu_gp_kthread(void *unused)",
            "{",
            "\trcu_bind_gp_kthread();",
            "\tfor (;;) {",
            "",
            "\t\t/* Handle grace-period start. */",
            "\t\tfor (;;) {",
            "\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,",
            "\t\t\t\t\t       TPS(\"reqwait\"));",
            "\t\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_WAIT_GPS);",
            "\t\t\tswait_event_idle_exclusive(rcu_state.gp_wq,",
            "\t\t\t\t\t READ_ONCE(rcu_state.gp_flags) &",
            "\t\t\t\t\t RCU_GP_FLAG_INIT);",
            "\t\t\trcu_gp_torture_wait();",
            "\t\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_DONE_GPS);",
            "\t\t\t/* Locking provides needed memory barrier. */",
            "\t\t\tif (rcu_gp_init())",
            "\t\t\t\tbreak;",
            "\t\t\tcond_resched_tasks_rcu_qs();",
            "\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);",
            "\t\t\tWARN_ON(signal_pending(current));",
            "\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,",
            "\t\t\t\t\t       TPS(\"reqwaitsig\"));",
            "\t\t}",
            "",
            "\t\t/* Handle quiescent-state forcing. */",
            "\t\trcu_gp_fqs_loop();",
            "",
            "\t\t/* Handle grace-period end. */",
            "\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_CLEANUP);",
            "\t\trcu_gp_cleanup();",
            "\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_CLEANED);",
            "\t}",
            "}",
            "static void rcu_report_qs_rsp(unsigned long flags)",
            "\t__releases(rcu_get_root()->lock)",
            "{",
            "\traw_lockdep_assert_held_rcu_node(rcu_get_root());",
            "\tWARN_ON_ONCE(!rcu_gp_in_progress());",
            "\tWRITE_ONCE(rcu_state.gp_flags,",
            "\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);",
            "\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);",
            "\trcu_gp_kthread_wake();",
            "}",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,",
            "\t\t\t      unsigned long gps, unsigned long flags)",
            "\t__releases(rnp->lock)",
            "{",
            "\tunsigned long oldmask = 0;",
            "\tstruct rcu_node *rnp_c;",
            "",
            "\traw_lockdep_assert_held_rcu_node(rnp);",
            "",
            "\t/* Walk up the rcu_node hierarchy. */",
            "\tfor (;;) {",
            "\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {",
            "",
            "\t\t\t/*",
            "\t\t\t * Our bit has already been cleared, or the",
            "\t\t\t * relevant grace period is already over, so done.",
            "\t\t\t */",
            "\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */",
            "\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&",
            "\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));",
            "\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);",
            "\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,",
            "\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,",
            "\t\t\t\t\t\t rnp->grplo, rnp->grphi,",
            "\t\t\t\t\t\t !!rnp->gp_tasks);",
            "\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {",
            "",
            "\t\t\t/* Other bits still set at this level, so done. */",
            "\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\trnp->completedqs = rnp->gp_seq;",
            "\t\tmask = rnp->grpmask;",
            "\t\tif (rnp->parent == NULL) {",
            "",
            "\t\t\t/* No more levels.  Exit loop holding root lock. */",
            "",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);",
            "\t\trnp_c = rnp;",
            "\t\trnp = rnp->parent;",
            "\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);",
            "\t\toldmask = READ_ONCE(rnp_c->qsmask);",
            "\t}",
            "",
            "\t/*",
            "\t * Get here if we are the last CPU to pass through a quiescent",
            "\t * state for this grace period.  Invoke rcu_report_qs_rsp()",
            "\t * to clean up and start the next grace period if one is needed.",
            "\t */",
            "\trcu_report_qs_rsp(flags); /* releases rnp->lock. */",
            "}",
            "static void __maybe_unused",
            "rcu_report_unblock_qs_rnp(struct rcu_node *rnp, unsigned long flags)",
            "\t__releases(rnp->lock)",
            "{",
            "\tunsigned long gps;",
            "\tunsigned long mask;",
            "\tstruct rcu_node *rnp_p;",
            "",
            "\traw_lockdep_assert_held_rcu_node(rnp);",
            "\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_PREEMPT_RCU)) ||",
            "\t    WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)) ||",
            "\t    rnp->qsmask != 0) {",
            "\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);",
            "\t\treturn;  /* Still need more quiescent states! */",
            "\t}",
            "",
            "\trnp->completedqs = rnp->gp_seq;",
            "\trnp_p = rnp->parent;",
            "\tif (rnp_p == NULL) {",
            "\t\t/*",
            "\t\t * Only one rcu_node structure in the tree, so don't",
            "\t\t * try to report up to its nonexistent parent!",
            "\t\t */",
            "\t\trcu_report_qs_rsp(flags);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Report up the rest of the hierarchy, tracking current ->gp_seq. */",
            "\tgps = rnp->gp_seq;",
            "\tmask = rnp->grpmask;",
            "\traw_spin_unlock_rcu_node(rnp);\t/* irqs remain disabled. */",
            "\traw_spin_lock_rcu_node(rnp_p);\t/* irqs already disabled. */",
            "\trcu_report_qs_rnp(mask, rnp_p, gps, flags);",
            "}"
          ],
          "function_name": "rcu_gp_kthread, rcu_report_qs_rsp, rcu_report_qs_rnp, rcu_report_unblock_qs_rnp",
          "description": "实现RCU grace period的主线程循环，处理grace period启动、强制quiescent状态报告及结束逻辑，通过锁和状态标志协调各子系统同步",
          "similarity": 0.4700930714607239
        },
        {
          "chunk_id": 24,
          "file_path": "kernel/rcu/tree.c",
          "start_line": 4444,
          "end_line": 4559,
          "content": [
            "static void __init",
            "rcu_boot_init_percpu_data(int cpu)",
            "{",
            "\tstruct context_tracking *ct = this_cpu_ptr(&context_tracking);",
            "\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);",
            "",
            "\t/* Set up local state, ensuring consistent view of global state. */",
            "\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);",
            "\tINIT_WORK(&rdp->strict_work, strict_work_handler);",
            "\tWARN_ON_ONCE(ct->dynticks_nesting != 1);",
            "\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(cpu)));",
            "\trdp->barrier_seq_snap = rcu_state.barrier_sequence;",
            "\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;",
            "\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;",
            "\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;",
            "\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;",
            "\trdp->last_sched_clock = jiffies;",
            "\trdp->cpu = cpu;",
            "\trcu_boot_init_nocb_percpu_data(rdp);",
            "}",
            "int rcutree_prepare_cpu(unsigned int cpu)",
            "{",
            "\tunsigned long flags;",
            "\tstruct context_tracking *ct = per_cpu_ptr(&context_tracking, cpu);",
            "\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);",
            "\tstruct rcu_node *rnp = rcu_get_root();",
            "",
            "\t/* Set up local state, ensuring consistent view of global state. */",
            "\traw_spin_lock_irqsave_rcu_node(rnp, flags);",
            "\trdp->qlen_last_fqs_check = 0;",
            "\trdp->n_force_qs_snap = READ_ONCE(rcu_state.n_force_qs);",
            "\trdp->blimit = blimit;",
            "\tct->dynticks_nesting = 1;\t/* CPU not up, no tearing. */",
            "\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */",
            "",
            "\t/*",
            "\t * Only non-NOCB CPUs that didn't have early-boot callbacks need to be",
            "\t * (re-)initialized.",
            "\t */",
            "\tif (!rcu_segcblist_is_enabled(&rdp->cblist))",
            "\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */",
            "",
            "\t/*",
            "\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed",
            "\t * propagation up the rcu_node tree will happen at the beginning",
            "\t * of the next grace period.",
            "\t */",
            "\trnp = rdp->mynode;",
            "\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */",
            "\trdp->gp_seq = READ_ONCE(rnp->gp_seq);",
            "\trdp->gp_seq_needed = rdp->gp_seq;",
            "\trdp->cpu_no_qs.b.norm = true;",
            "\trdp->core_needs_qs = false;",
            "\trdp->rcu_iw_pending = false;",
            "\trdp->rcu_iw = IRQ_WORK_INIT_HARD(rcu_iw_handler);",
            "\trdp->rcu_iw_gp_seq = rdp->gp_seq - 1;",
            "\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));",
            "\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);",
            "",
            "\trcu_preempt_deferred_qs_init(rdp);",
            "\trcu_spawn_one_boost_kthread(rnp);",
            "\trcu_spawn_cpu_nocb_kthread(cpu);",
            "\tWRITE_ONCE(rcu_state.n_online_cpus, rcu_state.n_online_cpus + 1);",
            "",
            "\treturn 0;",
            "}",
            "static void rcutree_affinity_setting(unsigned int cpu, int outgoing)",
            "{",
            "\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);",
            "",
            "\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);",
            "}",
            "bool rcu_cpu_beenfullyonline(int cpu)",
            "{",
            "\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);",
            "",
            "\treturn smp_load_acquire(&rdp->beenonline);",
            "}",
            "int rcutree_online_cpu(unsigned int cpu)",
            "{",
            "\tunsigned long flags;",
            "\tstruct rcu_data *rdp;",
            "\tstruct rcu_node *rnp;",
            "",
            "\trdp = per_cpu_ptr(&rcu_data, cpu);",
            "\trnp = rdp->mynode;",
            "\traw_spin_lock_irqsave_rcu_node(rnp, flags);",
            "\trnp->ffmask |= rdp->grpmask;",
            "\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);",
            "\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)",
            "\t\treturn 0; /* Too early in boot for scheduler work. */",
            "\tsync_sched_exp_online_cleanup(cpu);",
            "\trcutree_affinity_setting(cpu, -1);",
            "",
            "\t// Stop-machine done, so allow nohz_full to disable tick.",
            "\ttick_dep_clear(TICK_DEP_BIT_RCU);",
            "\treturn 0;",
            "}",
            "int rcutree_offline_cpu(unsigned int cpu)",
            "{",
            "\tunsigned long flags;",
            "\tstruct rcu_data *rdp;",
            "\tstruct rcu_node *rnp;",
            "",
            "\trdp = per_cpu_ptr(&rcu_data, cpu);",
            "\trnp = rdp->mynode;",
            "\traw_spin_lock_irqsave_rcu_node(rnp, flags);",
            "\trnp->ffmask &= ~rdp->grpmask;",
            "\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);",
            "",
            "\trcutree_affinity_setting(cpu, cpu);",
            "",
            "\t// nohz_full CPUs need the tick for stop-machine to work quickly",
            "\ttick_dep_set(TICK_DEP_BIT_RCU);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "rcu_boot_init_percpu_data, rcutree_prepare_cpu, rcutree_affinity_setting, rcu_cpu_beenfullyonline, rcutree_online_cpu, rcutree_offline_cpu",
          "description": "初始化每个CPU的RCU私有数据结构，处理CPU上线/下线时的RCU状态同步，配置中断亲和性，更新全局在线CPU计数器",
          "similarity": 0.4683588147163391
        }
      ]
    },
    {
      "source_file": "kernel/sysctl.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:32:56\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sysctl.c`\n\n---\n\n# sysctl.c 技术文档\n\n## 文件概述\n\n`sysctl.c` 是 Linux 内核中实现系统控制（sysctl）机制的核心文件，提供了通过 `/proc/sys` 接口动态读写内核运行时参数的能力。该文件实现了通用的 sysctl 框架，支持字符串、整数、长整型等多种数据类型的读写操作，并提供了严格的写入模式控制，确保系统参数的安全性和一致性。\n\n## 核心功能\n\n### 主要数据结构\n- `enum sysctl_writes_mode`: 定义 sysctl 写入模式的三种策略\n  - `SYSCTL_WRITES_LEGACY`: 传统模式，忽略文件位置\n  - `SYSCTL_WRITES_WARN`: 警告模式，非零位置写入时发出警告\n  - `SYSCTL_WRITES_STRICT`: 严格模式，强制要求位置为0且完整写入\n\n### 主要全局变量\n- `sysctl_vals[]`: 预定义的常用整数值常量数组（0, 1, 2, 3, 4, 100, 200, 1000, 3000, INT_MAX, 65535, -1）\n- `sysctl_long_vals[]`: 预定义的常用长整型值常量数组（0, 1, LONG_MAX）\n- `sysctl_writes_strict`: 当前 sysctl 写入模式，默认为严格模式\n- `sysctl_legacy_va_layout`: 控制虚拟地址布局的兼容性标志\n\n### 主要函数\n- `proc_dostring()`: 处理字符串类型 sysctl 参数的读写操作\n- `_proc_do_string()`: 字符串读写的底层实现函数\n- `proc_first_pos_non_zero_ignore()`: 检查文件位置是否为非零并根据模式处理\n- `warn_sysctl_write()`: 发出 sysctl 写入警告信息\n- `proc_skip_spaces()`: 跳过缓冲区中的空白字符\n- `proc_skip_char()`: 跳过缓冲区中的指定字符\n- `strtoul_lenient()`: 宽松的无符号长整型字符串解析函数（代码片段中未完整显示）\n\n## 关键实现\n\n### 写入模式控制\nsysctl 实现了三种写入模式来控制如何处理文件位置和多次写入：\n- **严格模式**（默认）: 要求写入必须从位置0开始，且一次写入必须包含完整值\n- **警告模式**: 允许非零位置写入但会发出警告\n- **传统模式**: 完全忽略文件位置，每次写入都覆盖整个值\n\n### 字符串处理机制\n`_proc_do_string()` 函数实现了智能的字符串读写逻辑：\n- **读取时**: 自动在字符串末尾添加换行符 `\\n`，支持分段读取\n- **写入时**: \n  - 严格模式下支持从指定位置继续写入（用于长字符串）\n  - 其他模式下总是从字符串开头覆盖写入\n  - 自动处理空字符和换行符作为字符串终止符\n\n### 安全性保障\n- 通过 `proc_first_pos_non_zero_ignore()` 函数确保数值类型参数的写入安全性\n- 使用 `maxlen` 参数防止缓冲区溢出\n- 自动截断超长字符串并确保 NULL 终止\n\n### 预定义常量优化\n通过导出 `sysctl_vals[]` 和 `sysctl_long_vals[]` 数组，避免在各个 sysctl 表项中重复定义常用数值，减少内存占用并提高一致性。\n\n## 依赖关系\n\n### 头文件依赖\n- **核心内核头文件**: `linux/module.h`, `linux/kernel.h`, `linux/init.h`\n- **内存管理**: `linux/mm.h`, `linux/slab.h`, `linux/swap.h`\n- **文件系统**: `linux/proc_fs.h`, `linux/fs.h`\n- **安全机制**: `linux/security.h`, `linux/capability.h`\n- **系统调用**: `linux/syscalls.h`, `linux/uaccess.h`\n- **架构相关**: `asm/processor.h` 及各架构特定头文件（X86、SPARC 等）\n\n### 配置依赖\n- `CONFIG_SYSCTL`: 主开关，控制 sysctl 功能是否启用\n- `CONFIG_PROC_SYSCTL`: 控制 `/proc/sys` 接口支持\n- `CONFIG_PERF_EVENTS`: 影响性能事件相关的 sysctl 参数\n- `CONFIG_RT_MUTEXES`: 实时互斥锁相关的 sysctl 支持\n- 架构特定配置: `HAVE_ARCH_PICK_MMAP_LAYOUT`, `CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT`\n\n### 模块交互\n- 与 proc 文件系统深度集成，提供 `/proc/sys` 虚拟文件接口\n- 为网络子系统、内存管理、调度器等内核子系统提供参数配置接口\n- 与安全模块（如 SELinux）协作进行权限检查\n\n## 使用场景\n\n### 内核参数动态配置\n- 系统管理员通过 `/proc/sys` 接口实时调整内核参数\n- 应用程序通过 sysctl 系统调用查询或修改内核行为\n- 启动脚本在系统初始化时设置关键内核参数\n\n### 子系统集成\n- **网络子系统**: 配置 TCP/IP 参数、网络缓冲区大小等\n- **内存管理**: 调整脏页回写策略、内存回收阈值等\n- **进程调度**: 设置调度策略参数、进程优先级范围等\n- **安全机制**: 配置 capability、用户命名空间等安全相关参数\n- **虚拟内存**: 控制 mmap 布局、huge page 行为等\n\n### 调试和监控\n- 开发者通过 sysctl 接口启用/禁用调试功能\n- 监控工具读取 sysctl 参数了解系统当前配置状态\n- 性能调优时动态调整内核参数以获得最佳性能\n\n### 兼容性支持\n- 通过 `sysctl_legacy_va_layout` 等参数维持向后兼容性\n- 支持传统应用程序对 sysctl 接口的使用模式\n- 提供平滑的迁移路径从传统模式到严格模式",
      "similarity": 0.5266538262367249,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/sysctl.c",
          "start_line": 610,
          "end_line": 712,
          "content": [
            "static int do_proc_douintvec_r(unsigned int *tbl_data, void *buffer,",
            "\t\t\t       size_t *lenp, loff_t *ppos,",
            "\t\t\t       int (*conv)(unsigned long *lvalp,",
            "\t\t\t\t\t   unsigned int *valp,",
            "\t\t\t\t\t   int write, void *data),",
            "\t\t\t       void *data)",
            "{",
            "\tunsigned long lval;",
            "\tint err = 0;",
            "\tsize_t left;",
            "",
            "\tleft = *lenp;",
            "",
            "\tif (conv(&lval, tbl_data, 0, data)) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tproc_put_long(&buffer, &left, lval, false);",
            "\tif (!left)",
            "\t\tgoto out;",
            "",
            "\tproc_put_char(&buffer, &left, '\\n');",
            "",
            "out:",
            "\t*lenp -= left;",
            "\t*ppos += *lenp;",
            "",
            "\treturn err;",
            "}",
            "static int __do_proc_douintvec(void *tbl_data, struct ctl_table *table,",
            "\t\t\t       int write, void *buffer,",
            "\t\t\t       size_t *lenp, loff_t *ppos,",
            "\t\t\t       int (*conv)(unsigned long *lvalp,",
            "\t\t\t\t\t   unsigned int *valp,",
            "\t\t\t\t\t   int write, void *data),",
            "\t\t\t       void *data)",
            "{",
            "\tunsigned int *i, vleft;",
            "",
            "\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {",
            "\t\t*lenp = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ti = (unsigned int *) tbl_data;",
            "\tvleft = table->maxlen / sizeof(*i);",
            "",
            "\t/*",
            "\t * Arrays are not supported, keep this simple. *Do not* add",
            "\t * support for them.",
            "\t */",
            "\tif (vleft != 1) {",
            "\t\t*lenp = 0;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (!conv)",
            "\t\tconv = do_proc_douintvec_conv;",
            "",
            "\tif (write)",
            "\t\treturn do_proc_douintvec_w(i, table, buffer, lenp, ppos,",
            "\t\t\t\t\t   conv, data);",
            "\treturn do_proc_douintvec_r(i, buffer, lenp, ppos, conv, data);",
            "}",
            "int do_proc_douintvec(struct ctl_table *table, int write,",
            "\t\t      void *buffer, size_t *lenp, loff_t *ppos,",
            "\t\t      int (*conv)(unsigned long *lvalp,",
            "\t\t\t\t  unsigned int *valp,",
            "\t\t\t\t  int write, void *data),",
            "\t\t      void *data)",
            "{",
            "\treturn __do_proc_douintvec(table->data, table, write,",
            "\t\t\t\t   buffer, lenp, ppos, conv, data);",
            "}",
            "int proc_dobool(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct ctl_table tmp;",
            "\tbool *data = table->data;",
            "\tint res, val;",
            "",
            "\t/* Do not support arrays yet. */",
            "\tif (table->maxlen != sizeof(bool))",
            "\t\treturn -EINVAL;",
            "",
            "\ttmp = *table;",
            "\ttmp.maxlen = sizeof(val);",
            "\ttmp.data = &val;",
            "",
            "\tval = READ_ONCE(*data);",
            "\tres = proc_dointvec(&tmp, write, buffer, lenp, ppos);",
            "\tif (res)",
            "\t\treturn res;",
            "\tif (write)",
            "\t\tWRITE_ONCE(*data, val);",
            "\treturn 0;",
            "}",
            "int proc_dointvec(struct ctl_table *table, int write, void *buffer,",
            "\t\t  size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn do_proc_dointvec(table, write, buffer, lenp, ppos, NULL, NULL);",
            "}"
          ],
          "function_name": "do_proc_douintvec_r, __do_proc_douintvec, do_proc_douintvec, proc_dobool, proc_dointvec",
          "description": "扩展整数向量处理功能，包含只读向量处理和布尔类型专用处理函数，用于支持不同数据类型的sysctl参数访问，确保类型安全性和操作一致性。",
          "similarity": 0.48936891555786133
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sysctl.c",
          "start_line": 453,
          "end_line": 603,
          "content": [
            "static int do_proc_douintvec_conv(unsigned long *lvalp,",
            "\t\t\t\t  unsigned int *valp,",
            "\t\t\t\t  int write, void *data)",
            "{",
            "\tif (write) {",
            "\t\tif (*lvalp > UINT_MAX)",
            "\t\t\treturn -EINVAL;",
            "\t\tWRITE_ONCE(*valp, *lvalp);",
            "\t} else {",
            "\t\tunsigned int val = READ_ONCE(*valp);",
            "\t\t*lvalp = (unsigned long)val;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,",
            "\t\t  int write, void *buffer,",
            "\t\t  size_t *lenp, loff_t *ppos,",
            "\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,",
            "\t\t\t      int write, void *data),",
            "\t\t  void *data)",
            "{",
            "\tint *i, vleft, first = 1, err = 0;",
            "\tsize_t left;",
            "\tchar *p;",
            "",
            "\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {",
            "\t\t*lenp = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ti = (int *) tbl_data;",
            "\tvleft = table->maxlen / sizeof(*i);",
            "\tleft = *lenp;",
            "",
            "\tif (!conv)",
            "\t\tconv = do_proc_dointvec_conv;",
            "",
            "\tif (write) {",
            "\t\tif (proc_first_pos_non_zero_ignore(ppos, table))",
            "\t\t\tgoto out;",
            "",
            "\t\tif (left > PAGE_SIZE - 1)",
            "\t\t\tleft = PAGE_SIZE - 1;",
            "\t\tp = buffer;",
            "\t}",
            "",
            "\tfor (; left && vleft--; i++, first=0) {",
            "\t\tunsigned long lval;",
            "\t\tbool neg;",
            "",
            "\t\tif (write) {",
            "\t\t\tproc_skip_spaces(&p, &left);",
            "",
            "\t\t\tif (!left)",
            "\t\t\t\tbreak;",
            "\t\t\terr = proc_get_long(&p, &left, &lval, &neg,",
            "\t\t\t\t\t     proc_wspace_sep,",
            "\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t\tif (conv(&neg, &lval, i, 1, data)) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tif (conv(&neg, &lval, i, 0, data)) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif (!first)",
            "\t\t\t\tproc_put_char(&buffer, &left, '\\t');",
            "\t\t\tproc_put_long(&buffer, &left, lval, neg);",
            "\t\t}",
            "\t}",
            "",
            "\tif (!write && !first && left && !err)",
            "\t\tproc_put_char(&buffer, &left, '\\n');",
            "\tif (write && !err && left)",
            "\t\tproc_skip_spaces(&p, &left);",
            "\tif (write && first)",
            "\t\treturn err ? : -EINVAL;",
            "\t*lenp -= left;",
            "out:",
            "\t*ppos += *lenp;",
            "\treturn err;",
            "}",
            "static int do_proc_dointvec(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos,",
            "\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,",
            "\t\t\t      int write, void *data),",
            "\t\t  void *data)",
            "{",
            "\treturn __do_proc_dointvec(table->data, table, write,",
            "\t\t\tbuffer, lenp, ppos, conv, data);",
            "}",
            "static int do_proc_douintvec_w(unsigned int *tbl_data,",
            "\t\t\t       struct ctl_table *table,",
            "\t\t\t       void *buffer,",
            "\t\t\t       size_t *lenp, loff_t *ppos,",
            "\t\t\t       int (*conv)(unsigned long *lvalp,",
            "\t\t\t\t\t   unsigned int *valp,",
            "\t\t\t\t\t   int write, void *data),",
            "\t\t\t       void *data)",
            "{",
            "\tunsigned long lval;",
            "\tint err = 0;",
            "\tsize_t left;",
            "\tbool neg;",
            "\tchar *p = buffer;",
            "",
            "\tleft = *lenp;",
            "",
            "\tif (proc_first_pos_non_zero_ignore(ppos, table))",
            "\t\tgoto bail_early;",
            "",
            "\tif (left > PAGE_SIZE - 1)",
            "\t\tleft = PAGE_SIZE - 1;",
            "",
            "\tproc_skip_spaces(&p, &left);",
            "\tif (!left) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\terr = proc_get_long(&p, &left, &lval, &neg,",
            "\t\t\t     proc_wspace_sep,",
            "\t\t\t     sizeof(proc_wspace_sep), NULL);",
            "\tif (err || neg) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\tif (conv(&lval, tbl_data, 1, data)) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\tif (!err && left)",
            "\t\tproc_skip_spaces(&p, &left);",
            "",
            "out_free:",
            "\tif (err)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "",
            "\t/* This is in keeping with old __do_proc_dointvec() */",
            "bail_early:",
            "\t*ppos += *lenp;",
            "\treturn err;",
            "}"
          ],
          "function_name": "do_proc_douintvec_conv, __do_proc_dointvec, do_proc_dointvec, do_proc_douintvec_w",
          "description": "实现多元素整数向量的读写处理逻辑，包含严格写入模式验证、数值解析与转换流程，用于处理proc文件系统中数组形式的sysctl参数操作。",
          "similarity": 0.4814348816871643
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sysctl.c",
          "start_line": 1,
          "end_line": 144,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * sysctl.c: General linux system control interface",
            " *",
            " * Begun 24 March 1995, Stephen Tweedie",
            " * Added /proc support, Dec 1995",
            " * Added bdflush entry and intvec min/max checking, 2/23/96, Tom Dyas.",
            " * Added hooks for /proc/sys/net (minor, minor patch), 96/4/1, Mike Shaver.",
            " * Added kernel/java-{interpreter,appletviewer}, 96/5/10, Mike Shaver.",
            " * Dynamic registration fixes, Stephen Tweedie.",
            " * Added kswapd-interval, ctrl-alt-del, printk stuff, 1/8/97, Chris Horn.",
            " * Made sysctl support optional via CONFIG_SYSCTL, 1/10/97, Chris",
            " *  Horn.",
            " * Added proc_doulongvec_ms_jiffies_minmax, 09/08/99, Carlos H. Bauer.",
            " * Added proc_doulongvec_minmax, 09/08/99, Carlos H. Bauer.",
            " * Changed linked lists to use list.h instead of lists.h, 02/24/00, Bill",
            " *  Wendling.",
            " * The list_for_each() macro wasn't appropriate for the sysctl loop.",
            " *  Removed it and replaced it with older style, 03/23/00, Bill Wendling",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/signal.h>",
            "#include <linux/panic.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/filter.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kobject.h>",
            "#include <linux/net.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/highuid.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/initrd.h>",
            "#include <linux/key.h>",
            "#include <linux/times.h>",
            "#include <linux/limits.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/acpi.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/oom.h>",
            "#include <linux/kmod.h>",
            "#include <linux/capability.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/mount.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/pid.h>",
            "",
            "#include \"../lib/kstrtox.h\"",
            "",
            "#include <linux/uaccess.h>",
            "#include <asm/processor.h>",
            "",
            "#ifdef CONFIG_X86",
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/io.h>",
            "#endif",
            "#ifdef CONFIG_SPARC",
            "#include <asm/setup.h>",
            "#endif",
            "#ifdef CONFIG_RT_MUTEXES",
            "#include <linux/rtmutex.h>",
            "#endif",
            "",
            "/* shared constants to be used in various sysctls */",
            "const int sysctl_vals[] = { 0, 1, 2, 3, 4, 100, 200, 1000, 3000, INT_MAX, 65535, -1 };",
            "EXPORT_SYMBOL(sysctl_vals);",
            "",
            "const unsigned long sysctl_long_vals[] = { 0, 1, LONG_MAX };",
            "EXPORT_SYMBOL_GPL(sysctl_long_vals);",
            "",
            "#if defined(CONFIG_SYSCTL)",
            "",
            "/* Constants used for minimum and maximum */",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "static const int six_hundred_forty_kb = 640 * 1024;",
            "#endif",
            "",
            "",
            "static const int ngroups_max = NGROUPS_MAX;",
            "static const int cap_last_cap = CAP_LAST_CAP;",
            "",
            "#ifdef CONFIG_PROC_SYSCTL",
            "",
            "/**",
            " * enum sysctl_writes_mode - supported sysctl write modes",
            " *",
            " * @SYSCTL_WRITES_LEGACY: each write syscall must fully contain the sysctl value",
            " *\tto be written, and multiple writes on the same sysctl file descriptor",
            " *\twill rewrite the sysctl value, regardless of file position. No warning",
            " *\tis issued when the initial position is not 0.",
            " * @SYSCTL_WRITES_WARN: same as above but warn when the initial file position is",
            " *\tnot 0.",
            " * @SYSCTL_WRITES_STRICT: writes to numeric sysctl entries must always be at",
            " *\tfile position 0 and the value must be fully contained in the buffer",
            " *\tsent to the write syscall. If dealing with strings respect the file",
            " *\tposition, but restrict this to the max length of the buffer, anything",
            " *\tpassed the max length will be ignored. Multiple writes will append",
            " *\tto the buffer.",
            " *",
            " * These write modes control how current file position affects the behavior of",
            " * updating sysctl values through the proc interface on each write.",
            " */",
            "enum sysctl_writes_mode {",
            "\tSYSCTL_WRITES_LEGACY\t\t= -1,",
            "\tSYSCTL_WRITES_WARN\t\t= 0,",
            "\tSYSCTL_WRITES_STRICT\t\t= 1,",
            "};",
            "",
            "static enum sysctl_writes_mode sysctl_writes_strict = SYSCTL_WRITES_STRICT;",
            "#endif /* CONFIG_PROC_SYSCTL */",
            "",
            "#if defined(HAVE_ARCH_PICK_MMAP_LAYOUT) || \\",
            "    defined(CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT)",
            "int sysctl_legacy_va_layout;",
            "#endif",
            "",
            "#endif /* CONFIG_SYSCTL */",
            "",
            "/*",
            " * /proc/sys support",
            " */",
            "",
            "#ifdef CONFIG_PROC_SYSCTL",
            ""
          ],
          "function_name": null,
          "description": "声明sysctl通用系统控制接口的实现，包含头文件和公共常量定义，用于支持/proc/sys虚拟文件系统中的参数控制，核心功能为构建sysctl框架基础结构。",
          "similarity": 0.47036415338516235
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sysctl.c",
          "start_line": 145,
          "end_line": 246,
          "content": [
            "static int _proc_do_string(char *data, int maxlen, int write,",
            "\t\tchar *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tsize_t len;",
            "\tchar c, *p;",
            "",
            "\tif (!data || !maxlen || !*lenp) {",
            "\t\t*lenp = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (write) {",
            "\t\tif (sysctl_writes_strict == SYSCTL_WRITES_STRICT) {",
            "\t\t\t/* Only continue writes not past the end of buffer. */",
            "\t\t\tlen = strlen(data);",
            "\t\t\tif (len > maxlen - 1)",
            "\t\t\t\tlen = maxlen - 1;",
            "",
            "\t\t\tif (*ppos > len)",
            "\t\t\t\treturn 0;",
            "\t\t\tlen = *ppos;",
            "\t\t} else {",
            "\t\t\t/* Start writing from beginning of buffer. */",
            "\t\t\tlen = 0;",
            "\t\t}",
            "",
            "\t\t*ppos += *lenp;",
            "\t\tp = buffer;",
            "\t\twhile ((p - buffer) < *lenp && len < maxlen - 1) {",
            "\t\t\tc = *(p++);",
            "\t\t\tif (c == 0 || c == '\\n')",
            "\t\t\t\tbreak;",
            "\t\t\tdata[len++] = c;",
            "\t\t}",
            "\t\tdata[len] = 0;",
            "\t} else {",
            "\t\tlen = strlen(data);",
            "\t\tif (len > maxlen)",
            "\t\t\tlen = maxlen;",
            "",
            "\t\tif (*ppos > len) {",
            "\t\t\t*lenp = 0;",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\tdata += *ppos;",
            "\t\tlen  -= *ppos;",
            "",
            "\t\tif (len > *lenp)",
            "\t\t\tlen = *lenp;",
            "\t\tif (len)",
            "\t\t\tmemcpy(buffer, data, len);",
            "\t\tif (len < *lenp) {",
            "\t\t\tbuffer[len] = '\\n';",
            "\t\t\tlen++;",
            "\t\t}",
            "\t\t*lenp = len;",
            "\t\t*ppos += len;",
            "\t}",
            "\treturn 0;",
            "}",
            "static void warn_sysctl_write(struct ctl_table *table)",
            "{",
            "\tpr_warn_once(\"%s wrote to %s when file position was not 0!\\n\"",
            "\t\t\"This will not be supported in the future. To silence this\\n\"",
            "\t\t\"warning, set kernel.sysctl_writes_strict = -1\\n\",",
            "\t\tcurrent->comm, table->procname);",
            "}",
            "static bool proc_first_pos_non_zero_ignore(loff_t *ppos,",
            "\t\t\t\t\t   struct ctl_table *table)",
            "{",
            "\tif (!*ppos)",
            "\t\treturn false;",
            "",
            "\tswitch (sysctl_writes_strict) {",
            "\tcase SYSCTL_WRITES_STRICT:",
            "\t\treturn true;",
            "\tcase SYSCTL_WRITES_WARN:",
            "\t\twarn_sysctl_write(table);",
            "\t\treturn false;",
            "\tdefault:",
            "\t\treturn false;",
            "\t}",
            "}",
            "int proc_dostring(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tif (write)",
            "\t\tproc_first_pos_non_zero_ignore(ppos, table);",
            "",
            "\treturn _proc_do_string(table->data, table->maxlen, write, buffer, lenp,",
            "\t\t\tppos);",
            "}",
            "static void proc_skip_spaces(char **buf, size_t *size)",
            "{",
            "\twhile (*size) {",
            "\t\tif (!isspace(**buf))",
            "\t\t\tbreak;",
            "\t\t(*size)--;",
            "\t\t(*buf)++;",
            "\t}",
            "}"
          ],
          "function_name": "_proc_do_string, warn_sysctl_write, proc_first_pos_non_zero_ignore, proc_dostring, proc_skip_spaces",
          "description": "实现sysctl字符串处理辅助函数，包含字符跳过、写入模式校验及字符串转换逻辑，用于处理proc文件系统中带文件偏移的sysctl参数写入行为。",
          "similarity": 0.453224778175354
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/sysctl.c",
          "start_line": 1564,
          "end_line": 1667,
          "content": [
            "int proc_dostring(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_dobool(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_dointvec(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_douintvec(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_dointvec_minmax(struct ctl_table *table, int write,",
            "\t\t    void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_douintvec_minmax(struct ctl_table *table, int write,",
            "\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_dou8vec_minmax(struct ctl_table *table, int write,",
            "\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_dointvec_jiffies(struct ctl_table *table, int write,",
            "\t\t    void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_dointvec_jiffies_minmax(struct ctl_table *table, int write,",
            "\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_dointvec_ms_jiffies_minmax(struct ctl_table *table, int write,",
            "\t\t\t\t    void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,",
            "\t\t    void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,",
            "\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_doulongvec_minmax(struct ctl_table *table, int write,",
            "\t\t    void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,",
            "\t\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_do_large_bitmap(struct ctl_table *table, int write,",
            "\t\t\t void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "int proc_do_static_key(struct ctl_table *table, int write,",
            "\t\t       void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct static_key *key = (struct static_key *)table->data;",
            "\tstatic DEFINE_MUTEX(static_key_mutex);",
            "\tint val, ret;",
            "\tstruct ctl_table tmp = {",
            "\t\t.data   = &val,",
            "\t\t.maxlen = sizeof(val),",
            "\t\t.mode   = table->mode,",
            "\t\t.extra1 = SYSCTL_ZERO,",
            "\t\t.extra2 = SYSCTL_ONE,",
            "\t};",
            "",
            "\tif (write && !capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tmutex_lock(&static_key_mutex);",
            "\tval = static_key_enabled(key);",
            "\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);",
            "\tif (write && !ret) {",
            "\t\tif (val)",
            "\t\t\tstatic_key_enable(key);",
            "\t\telse",
            "\t\t\tstatic_key_disable(key);",
            "\t}",
            "\tmutex_unlock(&static_key_mutex);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "proc_dostring, proc_dobool, proc_dointvec, proc_douintvec, proc_dointvec_minmax, proc_douintvec_minmax, proc_dou8vec_minmax, proc_dointvec_jiffies, proc_dointvec_jiffies_minmax, proc_dointvec_ms_jiffies_minmax, proc_dointvec_userhz_jiffies, proc_dointvec_ms_jiffies, proc_doulongvec_minmax, proc_doulongvec_ms_jiffies_minmax, proc_do_large_bitmap, proc_do_static_key",
          "description": "这些函数是处理/proc/sys虚拟文件系统中sysctl参数读写的回调函数，大部分函数返回-ENOSYS表示未实现，仅proc_do_static_key实现了对静态键状态的读写操作，其余函数可能在不同内核版本或配置中被具体实现。",
          "similarity": 0.44560372829437256
        }
      ]
    }
  ]
}