{
  "query": "段表如何实现地址转换",
  "timestamp": "2025-12-26 00:12:50",
  "retrieved_files": [
    {
      "source_file": "mm/slab.h",
      "md_summary": "> 自动生成时间: 2025-12-07 17:22:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `slab.h`\n\n---\n\n# `slab.h` 技术文档\n\n## 1. 文件概述\n\n`slab.h` 是 Linux 内核内存管理子系统中 SLAB/SLUB 分配器的核心内部头文件，定义了 slab 分配器所使用的底层数据结构（如 `struct slab` 和 `struct kmem_cache`）、关键宏和辅助函数。该文件主要用于在页（`struct page`）与 slab 表示之间进行安全转换，并提供对 slab 元数据的原子访问机制，以支持高性能、可扩展的对象缓存分配。\n\n此头文件专供内核内存管理内部使用，不对外暴露给模块开发者，是实现 SLUB（默认）或 SLAB 分配器的关键基础设施。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`freelist_aba_t`**  \n  联合体，将空闲对象指针（`freelist`）与计数器（`counter`）打包为一个原子单元，用于避免 ABA 问题（Compare-and-Swap 中因值重复导致的逻辑错误）。\n\n- **`struct slab`**  \n  slab 的内部表示，复用 `struct page` 的内存布局。包含：\n  - 所属的 `kmem_cache`\n  - 空闲对象链表（`freelist`）\n  - 对象使用计数（`inuse`）、总对象数（`objects`）\n  - 冻结状态（`frozen`，用于调试）\n  - RCU 回收头（`rcu_head`）\n  - 引用计数（`__page_refcount`）\n  - 可选的 per-object 扩展数据（`obj_exts`）\n\n- **`struct kmem_cache_order_objects`**  \n  封装 slab 阶数（order）与对象数量的复合值，支持原子读写。\n\n- **`struct kmem_cache`**  \n  slab 缓存描述符，包含：\n  - 每 CPU 缓存（`cpu_slab`）\n  - 对象大小（`size`, `object_size`）\n  - 构造函数（`ctor`）\n  - 对齐要求（`align`）\n  - 分配标志（`allocflags`）\n  - NUMA 相关参数（如 `remote_node_defrag_ratio`）\n  - 安全特性（如 `random` 用于 freelist 加固）\n\n### 主要宏与辅助函数\n\n- **类型安全转换宏**：\n  - `folio_slab()` / `slab_folio()`：在 `folio` 与 `slab` 之间安全转换\n  - `page_slab()` / `slab_page()`：兼容旧代码，在 `page` 与 `slab` 之间转换\n\n- **slab 属性访问函数**：\n  - `slab_address()`：获取 slab 起始虚拟地址\n  - `slab_nid()` / `slab_pgdat()`：获取所属 NUMA 节点和内存域\n  - `slab_order()` / `slab_size()`：获取分配阶数和总字节数\n\n- **pfmemalloc 标志操作**：\n  - `slab_test_pfmemalloc()` / `slab_set_pfmemalloc()` 等：标记 slab 是否来自紧急内存预留区（用于网络交换等场景）\n\n- **每 CPU partial slab 支持（`CONFIG_SLUB_CPU_PARTIAL`）**：\n  - `slub_percpu_partial()` 等宏：管理每 CPU 的 partial slab 链表\n\n## 3. 关键实现\n\n### 内存布局复用与静态断言\n\n- `struct slab` 并非独立分配，而是直接复用 `struct page` 的内存空间。通过 `static_assert` 确保关键字段偏移一致（如 `flags` ↔ `__page_flags`），保证类型转换安全。\n- 整个 `struct slab` 大小不超过 `struct page`，确保无越界访问。\n\n### ABA 问题防护\n\n- 在支持 `cmpxchg128`（64 位）或 `cmpxchg64`（32 位）的架构上，启用 `freelist_aba_t` 结构，将 `freelist` 指针与递增计数器打包为单个原子单元。\n- 使用 `try_cmpxchg_freelist` 进行原子更新，防止因指针值循环重用导致的 ABA 错误。\n- 若系统不支持对齐的 `struct page`（`!CONFIG_HAVE_ALIGNED_STRUCT_PAGE`），则禁用此优化。\n\n### 类型安全转换\n\n- 使用 C11 `_Generic` 实现类型安全的 `folio`/`slab`/`page` 转换，避免强制类型转换带来的风险，并为未来重构（如完全迁移到 folio）预留接口。\n\n### pfmemalloc 标志复用\n\n- 利用 `folio` 的 `PG_active` 位存储 `pfmemalloc` 标志，指示该 slab 是否从紧急内存池分配，用于网络子系统在内存压力下仍能分配 skb 等关键结构。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/page.h>` / `<linux/folio.h>`：通过 `folio_*` 系列函数操作底层内存\n  - `<linux/reciprocal_div.h>`：用于快速除法（计算对象索引）\n  - `<linux/rcupdate.h>`：通过 `rcu_head` 支持 RCU 安全的 slab 回收\n\n- **可选依赖（由 Kconfig 控制）**：\n  - `CONFIG_SLUB_CPU_PARTIAL`：每 CPU partial slab 优化\n  - `CONFIG_SLAB_OBJ_EXT`：per-object 扩展元数据\n  - `CONFIG_SLAB_FREELIST_HARDENED`：freelist 指针随机化加固\n  - `CONFIG_NUMA`：NUMA 感知分配与碎片整理\n  - `CONFIG_KASAN` / `CONFIG_KFENCE`：内存错误检测集成\n\n- **与内存控制器集成**：\n  - 通过 `memcg_data` 字段（复用 `obj_exts`）支持 memcg 内存统计\n\n## 5. 使用场景\n\n- **SLUB 分配器内部**：作为 `slub.c` 的核心数据结构定义，用于管理 slab 生命周期、对象分配/释放。\n- **内存回收路径**：在 direct reclaim 或 kswapd 中，通过 `slab_folio` 获取 folio 信息以决策回收策略。\n- **调试与监控**：sysfs (`kobj`)、KASAN/KFENCE 集成依赖此结构获取 slab 元数据。\n- **网络子系统**：通过 `pfmemalloc` 标志识别紧急内存分配，确保高优先级数据包处理不被阻塞。\n- **NUMA 优化**：在远程节点分配时使用 `remote_node_defrag_ratio` 参数控制跨节点分配行为。\n- **安全加固**：`SLAB_FREELIST_HARDENED` 利用 `random` 字段混淆 freelist 指针，防止堆利用攻击。",
      "similarity": 0.5118458867073059,
      "chunks": []
    },
    {
      "source_file": "kernel/extable.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:28:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `extable.c`\n\n---\n\n# extable.c 技术文档\n\n## 文件概述\n\n`extable.c` 是 Linux 内核中用于管理**异常表（exception table）**的核心实现文件。异常表记录了内核中可能触发页错误（如访问用户空间地址失败）的指令地址及其对应的异常处理程序地址。该文件提供了对内核内置异常表、模块异常表和 BPF 异常表的统一搜索接口，并负责在内核初始化阶段对内置异常表进行排序，以支持高效的二分查找。此外，该文件还包含用于判断地址是否位于内核可执行文本段（text section）的辅助函数，以及在支持函数描述符（function descriptors）的架构上对函数指针进行解引用的逻辑。\n\n## 核心功能\n\n### 主要数据结构\n- `struct exception_table_entry`：异常表项，包含故障指令地址和对应的修复处理程序地址（定义在 `<linux/extable.h>` 中）。\n- `text_mutex`：互斥锁，用于保护对内核文本段的动态修改（如热补丁、ftrace、kprobes 等）。\n\n### 主要函数\n- `sort_main_extable(void)`：在内核初始化阶段对内置异常表 `__ex_table` 进行排序。\n- `search_kernel_exception_table(unsigned long addr)`：在内核内置异常表中搜索指定地址对应的异常处理项。\n- `search_exception_tables(unsigned long addr)`：统一接口，在内核、模块和 BPF 的异常表中搜索指定地址。\n- `core_kernel_text(unsigned long addr)`：判断地址是否属于内核核心文本段（包括 init 段，在初始化内存释放前）。\n- `kernel_text_address(unsigned long addr)`：判断地址是否属于任何内核可执行文本（包括模块、kprobes、BPF、ftrace 等）。\n- `__kernel_text_address(unsigned long addr)`：扩展版的 `kernel_text_address`，特别包含 init 段符号以支持栈回溯。\n- `dereference_function_descriptor(void *ptr)`（仅 `CONFIG_HAVE_FUNCTION_DESCRIPTORS`）：解引用函数描述符，获取真实函数地址。\n- `dereference_kernel_function_descriptor(void *ptr)`（仅 `CONFIG_HAVE_FUNCTION_DESCRIPTORS`）：仅对内核 OPD 段中的函数描述符进行解引用。\n- `func_ptr_is_kernel_text(void *ptr)`：判断函数指针（可能为描述符）是否指向内核文本。\n\n## 关键实现\n\n### 异常表管理\n- 内核链接脚本将所有 `.ex_table` 段合并为 `__start___ex_table` 到 `__stop___ex_table` 的连续区域。\n- 构建工具（如 `sortextable`）可能已在编译时对异常表排序；若未排序，则 `main_extable_sort_needed` 为 1，内核在 `sort_main_extable()` 中调用 `sort_extable()` 进行运行时排序。\n- `search_extable()`（定义在别处）依赖表已排序，使用二分查找实现 O(log n) 查询效率。\n\n### 文本段地址判断\n- `kernel_text_address()` 是核心判断函数，依次检查：\n  1. 内核核心文本（`core_kernel_text()`）\n  2. 模块文本（`is_module_text_address()`）\n  3. ftrace 跳板（`is_ftrace_trampoline()`）\n  4. kprobes 指令槽（`is_kprobe_*_slot()`）\n  5. BPF 文本（`is_bpf_text_address()`）\n- 由于部分检查（如模块地址）依赖 RCU 机制，在 RCU 不活跃上下文（如 NMI、idle 退出）中，函数会临时通过 `ct_nmi_enter/exit()` 通知 RCU 子系统。\n\n### 函数描述符支持\n- 在 PowerPC64、IA-64、PARISC 等架构上，函数指针实际指向描述符（OPD），其中包含真实入口地址。\n- `dereference_function_descriptor()` 使用 `get_kernel_nofault()` 安全读取描述符中的地址，避免因无效指针导致崩溃。\n- `func_ptr_is_kernel_text()` 先解引用描述符，再判断真实地址是否在内核文本中。\n\n### 并发控制\n- `text_mutex` 保护所有对内核 `.text` 段的运行时修改操作（如 ftrace、kprobes、alternatives），防止并发写入导致不一致。\n- 该锁**不导出给内核模块**，强调内核文本修改的高风险性。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/extable.h>`：异常表数据结构和操作函数声明\n  - `<linux/module.h>`：模块异常表搜索（`search_module_extables`）\n  - `<linux/filter.h>`：BPF 异常表搜索（`search_bpf_extables`）\n  - `<linux/kprobes.h>`：kprobes 指令槽判断\n  - `<linux/ftrace.h>`：ftrace 跳板判断\n  - `<asm/sections.h>`：内核段边界符号（`__start___ex_table` 等）\n  - `<linux/uaccess.h>`：`get_kernel_nofault()` 安全内存访问\n- **架构依赖**：\n  - `CONFIG_HAVE_FUNCTION_DESCRIPTORS`：启用函数描述符解引用逻辑\n  - 架构特定的 `is_*_text_address()` 实现（如 x86 的 `is_module_text_address`）\n- **内核子系统**：\n  - 内存管理（页错误处理）\n  - 模块加载（模块异常表注册）\n  - BPF JIT（BPF 异常表）\n  - 动态追踪（ftrace、kprobes）\n\n## 使用场景\n\n1. **页错误处理**：当内核执行 `copy_from_user()` 等函数访问无效用户地址时，CPU 触发页错误，`do_page_fault()` 调用 `search_exception_tables()` 查找修复地址，跳转执行错误处理逻辑（如返回 `-EFAULT`）。\n2. **内核调试与追踪**：\n   - 栈回溯（stack unwinding）时通过 `__kernel_text_address()` 过滤有效内核符号\n   - 锁依赖检测（lockdep）等子系统依赖准确的文本段地址判断\n3. **动态代码修改**：\n   - ftrace、kprobes、livepatch 等机制在修改内核代码前需获取 `text_mutex`\n   - SMP alternatives（x86）使用同一互斥锁保证多核一致性\n4. **架构兼容性**：\n   - 在使用函数描述符的架构上，`kallsyms`、`perf` 等工具通过 `dereference_kernel_function_descriptor()` 获取真实函数地址\n   - 函数指针比较或验证时调用 `func_ptr_is_kernel_text()` 确保安全性",
      "similarity": 0.510603666305542,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/extable.c",
          "start_line": 36,
          "end_line": 117,
          "content": [
            "void __init sort_main_extable(void)",
            "{",
            "\tif (main_extable_sort_needed &&",
            "\t    &__stop___ex_table > &__start___ex_table) {",
            "\t\tpr_notice(\"Sorting __ex_table...\\n\");",
            "\t\tsort_extable(__start___ex_table, __stop___ex_table);",
            "\t}",
            "}",
            "int notrace core_kernel_text(unsigned long addr)",
            "{",
            "\tif (is_kernel_text(addr))",
            "\t\treturn 1;",
            "",
            "\tif (system_state < SYSTEM_FREEING_INITMEM &&",
            "\t    is_kernel_inittext(addr))",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "int __kernel_text_address(unsigned long addr)",
            "{",
            "\tif (kernel_text_address(addr))",
            "\t\treturn 1;",
            "\t/*",
            "\t * There might be init symbols in saved stacktraces.",
            "\t * Give those symbols a chance to be printed in",
            "\t * backtraces (such as lockdep traces).",
            "\t *",
            "\t * Since we are after the module-symbols check, there's",
            "\t * no danger of address overlap:",
            "\t */",
            "\tif (is_kernel_inittext(addr))",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "int kernel_text_address(unsigned long addr)",
            "{",
            "\tbool no_rcu;",
            "\tint ret = 1;",
            "",
            "\tif (core_kernel_text(addr))",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * If a stack dump happens while RCU is not watching, then",
            "\t * RCU needs to be notified that it requires to start",
            "\t * watching again. This can happen either by tracing that",
            "\t * triggers a stack trace, or a WARN() that happens during",
            "\t * coming back from idle, or cpu on or offlining.",
            "\t *",
            "\t * is_module_text_address() as well as the kprobe slots,",
            "\t * is_bpf_text_address() and is_bpf_image_address require",
            "\t * RCU to be watching.",
            "\t */",
            "\tno_rcu = !rcu_is_watching();",
            "",
            "\t/* Treat this like an NMI as it can happen anywhere */",
            "\tif (no_rcu)",
            "\t\tct_nmi_enter();",
            "",
            "\tif (is_module_text_address(addr))",
            "\t\tgoto out;",
            "\tif (is_ftrace_trampoline(addr))",
            "\t\tgoto out;",
            "\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))",
            "\t\tgoto out;",
            "\tif (is_bpf_text_address(addr))",
            "\t\tgoto out;",
            "\tret = 0;",
            "out:",
            "\tif (no_rcu)",
            "\t\tct_nmi_exit();",
            "",
            "\treturn ret;",
            "}",
            "int func_ptr_is_kernel_text(void *ptr)",
            "{",
            "\tunsigned long addr;",
            "\taddr = (unsigned long) dereference_function_descriptor(ptr);",
            "\tif (core_kernel_text(addr))",
            "\t\treturn 1;",
            "\treturn is_module_text_address(addr);",
            "}"
          ],
          "function_name": "sort_main_extable, core_kernel_text, __kernel_text_address, kernel_text_address, func_ptr_is_kernel_text",
          "description": "实现异常表排序函数sort_main_extable及地址有效性检测函数，其中core_kernel_text判断地址是否为核心或初始化文本，kernel_text_address综合判断地址是否属于内核文本、模块文本或BPF文本并处理RCU状态，func_ptr_is_kernel_text检查函数指针指向的地址是否为内核文本",
          "similarity": 0.5248726606369019
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/extable.c",
          "start_line": 1,
          "end_line": 35,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* Rewritten by Rusty Russell, on the backs of many others...",
            "   Copyright (C) 2001 Rusty Russell, 2002 Rusty Russell IBM.",
            "",
            "*/",
            "#include <linux/elf.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/extable.h>",
            "#include <linux/module.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/filter.h>",
            "",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "",
            "/*",
            " * mutex protecting text section modification (dynamic code patching).",
            " * some users need to sleep (allocating memory...) while they hold this lock.",
            " *",
            " * Note: Also protects SMP-alternatives modification on x86.",
            " *",
            " * NOT exported to modules - patching kernel text is a really delicate matter.",
            " */",
            "DEFINE_MUTEX(text_mutex);",
            "",
            "extern struct exception_table_entry __start___ex_table[];",
            "extern struct exception_table_entry __stop___ex_table[];",
            "",
            "/* Cleared by build time tools if the table is already sorted. */",
            "u32 __initdata __visible main_extable_sort_needed = 1;",
            "",
            "/* Sort the kernel's built-in exception table */"
          ],
          "function_name": null,
          "description": "定义保护动态代码修补的互斥锁text_mutex，声明异常表的起始/终止地址符号__start___ex_table/__stop___ex_table，并设置主异常表排序标志位main_extable_sort_needed，用于后续排序操作",
          "similarity": 0.41907939314842224
        }
      ]
    },
    {
      "source_file": "kernel/bpf/stackmap.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:30:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\stackmap.c`\n\n---\n\n# `bpf/stackmap.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/stackmap.c` 实现了 BPF（Berkeley Packet Filter）子系统中的 **栈映射（stack map）** 功能，用于高效地存储和查询用户态或内核态的调用栈（call stack）信息。该映射支持两种模式：\n- **原始 IP 地址模式**：直接存储程序计数器（PC）地址。\n- **Build ID + 偏移量模式**：将 IP 地址转换为对应二进制文件的 Build ID 和相对于该文件的偏移量，便于符号化解析且不受 ASLR 影响。\n\n该文件为 BPF 程序提供 `bpf_get_stackid()` 辅助函数的后端实现，是性能分析、追踪和调试工具（如 perf、bpftrace）的关键组件。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct stack_map_bucket`**  \n  哈希桶中的条目，包含：\n  - `fnode`：用于 per-CPU 自由链表管理\n  - `hash`：调用栈内容的哈希值\n  - `nr`：栈帧数量\n  - `data[]`：变长数组，存储栈数据（`u64` IP 或 `struct bpf_stack_build_id`）\n\n- **`struct bpf_stack_map`**  \n  BPF 栈映射的私有结构，继承自 `struct bpf_map`，包含：\n  - `elems`：预分配的桶内存池\n  - `freelist`：per-CPU 自由链表，用于高效分配/回收桶\n  - `n_buckets`：哈希表桶数量（2 的幂）\n  - `buckets[]`：哈希桶指针数组\n\n- **`struct bpf_stack_build_id`**（外部定义）  \n  Build ID 模式下的栈帧表示，包含：\n  - `status`：状态（`BPF_STACK_BUILD_ID_IP` 或 `BPF_STACK_BUILD_ID_VALID`）\n  - `ip`：原始 IP（仅当 status 为 IP 时有效）\n  - `offset`：相对于映射起始地址的偏移\n  - `build_id[]`：Build ID 字节数组\n\n### 主要函数\n\n- **`stack_map_alloc()`**  \n  BPF 栈映射的分配器，验证属性、预分配内存、初始化自由链表和调用链缓冲区。\n\n- **`__bpf_get_stackid()`**  \n  核心逻辑：根据传入的调用栈生成唯一 ID，执行哈希查找、比较和插入。\n\n- **`stack_map_get_build_id_offset()`**  \n  将原始 IP 地址转换为 Build ID + 偏移量格式，需持有 mmap 读锁。\n\n- **`get_callchain_entry_for_task()`**  \n  从指定任务结构中提取内核态调用栈（仅在 `CONFIG_STACKTRACE` 启用时有效）。\n\n- **`bpf_get_stackid()`**（BPF_CALL_3 宏定义）  \n  BPF 程序调用的入口点，根据寄存器上下文获取当前调用栈并返回其 ID。\n\n## 3. 关键实现\n\n### 哈希表设计\n- 使用 **开放寻址 + 覆盖替换** 策略：每个桶 ID 对应唯一哈希桶，冲突时直接替换旧条目。\n- 哈希函数为 `jhash2()`，对栈 IP 数组进行哈希。\n- 桶数量为 `max_entries` 的 2 次幂，通过位掩码 `hash & (n_buckets - 1)` 快速定位。\n\n### 内存管理\n- **预分配内存池**：在映射创建时一次性分配所有桶内存（`smap->elems`）。\n- **Per-CPU 自由链表**：使用 `pcpu_freelist` 实现无锁、高效的桶分配/回收，避免运行时内存分配开销。\n\n### Build ID 转换\n- 通过 `find_vma()` 查找 IP 所属的 VMA（虚拟内存区域）。\n- 调用 `build_id_parse()` 从 VMA 的 ELF 头中提取 Build ID。\n- 计算偏移量：`offset = (vma->vm_pgoff << PAGE_SHIFT) + ip - vma->vm_start`。\n- **锁机制**：使用 `mmap_read_trylock()` 获取 mmap 读锁，失败时回退到原始 IP 模式。\n- **中断上下文安全**：通过 `mmap_unlock_irq_work` 机制确保在中断上下文中安全释放 mmap 锁。\n\n### 快速比较优化\n- 若设置 `BPF_F_FAST_STACK_CMP` 标志，仅比较哈希值，不进行内容 memcmp，适用于对哈希冲突不敏感的场景。\n\n### 栈深度限制\n- 最大栈深度由 `sysctl_perf_event_max_stack` 控制，映射的 `value_size` 必须是单个栈帧大小的整数倍且不超过该限制。\n\n## 4. 依赖关系\n\n- **BPF 核心**：`<linux/bpf.h>`、`bpf_map` 基础设施\n- **内存管理**：`<linux/percpu.h>`（per-CPU 自由链表）、`bpf_map_area_alloc/free`\n- **栈追踪**：`<linux/stacktrace.h>`、`<linux/perf_event.h>`（调用链缓冲区）\n- **Build ID 支持**：`<linux/buildid.h>`、VMA 操作（`find_vma`、`range_in_vma`）\n- **内存映射锁**：`mmap_unlock_work.h`（安全释放 mmap 锁）\n- **哈希函数**：`<linux/jhash.h>`\n- **配置选项**：`CONFIG_STACKTRACE`（内核栈追踪支持）\n\n## 5. 使用场景\n\n- **性能分析**：BPF 程序通过 `bpf_get_stackid()` 获取当前调用栈 ID，后续通过 `bpf_map_lookup_elem()` 读取完整栈内容，用于火焰图生成。\n- **系统追踪**：结合 kprobe/uprobe，记录特定函数调用时的完整调用上下文。\n- **安全监控**：检测异常调用路径（如敏感系统调用的调用者）。\n- **调试工具**：为 `perf`、`bpftrace`、`bcc` 等工具提供高效的栈存储后端。\n- **Build ID 模式**：在 ASLR（地址空间布局随机化）环境下，通过 Build ID + 偏移实现稳定的符号化解析，适用于长期运行的监控场景。",
      "similarity": 0.5096918344497681,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/stackmap.c",
          "start_line": 319,
          "end_line": 426,
          "content": [
            "static __u64 count_kernel_ip(struct perf_callchain_entry *trace)",
            "{",
            "\t__u64 nr_kernel = 0;",
            "",
            "\twhile (nr_kernel < trace->nr) {",
            "\t\tif (trace->ip[nr_kernel] == PERF_CONTEXT_USER)",
            "\t\t\tbreak;",
            "\t\tnr_kernel++;",
            "\t}",
            "\treturn nr_kernel;",
            "}",
            "static long __bpf_get_stack(struct pt_regs *regs, struct task_struct *task,",
            "\t\t\t    struct perf_callchain_entry *trace_in,",
            "\t\t\t    void *buf, u32 size, u64 flags)",
            "{",
            "\tu32 trace_nr, copy_len, elem_size, num_elem, max_depth;",
            "\tbool user_build_id = flags & BPF_F_USER_BUILD_ID;",
            "\tbool crosstask = task && task != current;",
            "\tu32 skip = flags & BPF_F_SKIP_FIELD_MASK;",
            "\tbool user = flags & BPF_F_USER_STACK;",
            "\tstruct perf_callchain_entry *trace;",
            "\tbool kernel = !user;",
            "\tint err = -EINVAL;",
            "\tu64 *ips;",
            "",
            "\tif (unlikely(flags & ~(BPF_F_SKIP_FIELD_MASK | BPF_F_USER_STACK |",
            "\t\t\t       BPF_F_USER_BUILD_ID)))",
            "\t\tgoto clear;",
            "\tif (kernel && user_build_id)",
            "\t\tgoto clear;",
            "",
            "\telem_size = (user && user_build_id) ? sizeof(struct bpf_stack_build_id)",
            "\t\t\t\t\t    : sizeof(u64);",
            "\tif (unlikely(size % elem_size))",
            "\t\tgoto clear;",
            "",
            "\t/* cannot get valid user stack for task without user_mode regs */",
            "\tif (task && user && !user_mode(regs))",
            "\t\tgoto err_fault;",
            "",
            "\t/* get_perf_callchain does not support crosstask user stack walking",
            "\t * but returns an empty stack instead of NULL.",
            "\t */",
            "\tif (crosstask && user) {",
            "\t\terr = -EOPNOTSUPP;",
            "\t\tgoto clear;",
            "\t}",
            "",
            "\tnum_elem = size / elem_size;",
            "\tmax_depth = num_elem + skip;",
            "\tif (sysctl_perf_event_max_stack < max_depth)",
            "\t\tmax_depth = sysctl_perf_event_max_stack;",
            "",
            "\tif (trace_in)",
            "\t\ttrace = trace_in;",
            "\telse if (kernel && task)",
            "\t\ttrace = get_callchain_entry_for_task(task, max_depth);",
            "\telse",
            "\t\ttrace = get_perf_callchain(regs, 0, kernel, user, max_depth,",
            "\t\t\t\t\t   crosstask, false);",
            "\tif (unlikely(!trace))",
            "\t\tgoto err_fault;",
            "",
            "\tif (trace->nr < skip)",
            "\t\tgoto err_fault;",
            "",
            "\ttrace_nr = trace->nr - skip;",
            "\ttrace_nr = (trace_nr <= num_elem) ? trace_nr : num_elem;",
            "\tcopy_len = trace_nr * elem_size;",
            "",
            "\tips = trace->ip + skip;",
            "\tif (user && user_build_id)",
            "\t\tstack_map_get_build_id_offset(buf, ips, trace_nr, user);",
            "\telse",
            "\t\tmemcpy(buf, ips, copy_len);",
            "",
            "\tif (size > copy_len)",
            "\t\tmemset(buf + copy_len, 0, size - copy_len);",
            "\treturn copy_len;",
            "",
            "err_fault:",
            "\terr = -EFAULT;",
            "clear:",
            "\tmemset(buf, 0, size);",
            "\treturn err;",
            "}",
            "int bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)",
            "{",
            "\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);",
            "\tstruct stack_map_bucket *bucket, *old_bucket;",
            "\tu32 id = *(u32 *)key, trace_len;",
            "",
            "\tif (unlikely(id >= smap->n_buckets))",
            "\t\treturn -ENOENT;",
            "",
            "\tbucket = xchg(&smap->buckets[id], NULL);",
            "\tif (!bucket)",
            "\t\treturn -ENOENT;",
            "",
            "\ttrace_len = bucket->nr * stack_map_data_size(map);",
            "\tmemcpy(value, bucket->data, trace_len);",
            "\tmemset(value + trace_len, 0, map->value_size - trace_len);",
            "",
            "\told_bucket = xchg(&smap->buckets[id], bucket);",
            "\tif (old_bucket)",
            "\t\tpcpu_freelist_push(&smap->freelist, &old_bucket->fnode);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "count_kernel_ip, __bpf_get_stack, bpf_stackmap_copy",
          "description": "提供堆栈数据复制接口，包含内核IP计数、用户/内核模式堆栈采集、构建ID偏移量解析，以及堆栈映射数据复制功能",
          "similarity": 0.49316978454589844
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/stackmap.c",
          "start_line": 34,
          "end_line": 182,
          "content": [
            "static inline bool stack_map_use_build_id(struct bpf_map *map)",
            "{",
            "\treturn (map->map_flags & BPF_F_STACK_BUILD_ID);",
            "}",
            "static inline int stack_map_data_size(struct bpf_map *map)",
            "{",
            "\treturn stack_map_use_build_id(map) ?",
            "\t\tsizeof(struct bpf_stack_build_id) : sizeof(u64);",
            "}",
            "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)",
            "{",
            "\tu64 elem_size = sizeof(struct stack_map_bucket) +",
            "\t\t\t(u64)smap->map.value_size;",
            "\tint err;",
            "",
            "\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,",
            "\t\t\t\t\t smap->map.numa_node);",
            "\tif (!smap->elems)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = pcpu_freelist_init(&smap->freelist);",
            "\tif (err)",
            "\t\tgoto free_elems;",
            "",
            "\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,",
            "\t\t\t       smap->map.max_entries);",
            "\treturn 0;",
            "",
            "free_elems:",
            "\tbpf_map_area_free(smap->elems);",
            "\treturn err;",
            "}",
            "static void stack_map_get_build_id_offset(struct bpf_stack_build_id *id_offs,",
            "\t\t\t\t\t  u64 *ips, u32 trace_nr, bool user)",
            "{",
            "\tint i;",
            "\tstruct mmap_unlock_irq_work *work = NULL;",
            "\tbool irq_work_busy = bpf_mmap_unlock_get_irq_work(&work);",
            "\tstruct vm_area_struct *vma, *prev_vma = NULL;",
            "\tconst char *prev_build_id;",
            "",
            "\t/* If the irq_work is in use, fall back to report ips. Same",
            "\t * fallback is used for kernel stack (!user) on a stackmap with",
            "\t * build_id.",
            "\t */",
            "\tif (!user || !current || !current->mm || irq_work_busy ||",
            "\t    !mmap_read_trylock(current->mm)) {",
            "\t\t/* cannot access current->mm, fall back to ips */",
            "\t\tfor (i = 0; i < trace_nr; i++) {",
            "\t\t\tid_offs[i].status = BPF_STACK_BUILD_ID_IP;",
            "\t\t\tid_offs[i].ip = ips[i];",
            "\t\t\tmemset(id_offs[i].build_id, 0, BUILD_ID_SIZE_MAX);",
            "\t\t}",
            "\t\treturn;",
            "\t}",
            "",
            "\tfor (i = 0; i < trace_nr; i++) {",
            "\t\tif (range_in_vma(prev_vma, ips[i], ips[i])) {",
            "\t\t\tvma = prev_vma;",
            "\t\t\tmemcpy(id_offs[i].build_id, prev_build_id,",
            "\t\t\t       BUILD_ID_SIZE_MAX);",
            "\t\t\tgoto build_id_valid;",
            "\t\t}",
            "\t\tvma = find_vma(current->mm, ips[i]);",
            "\t\tif (!vma || build_id_parse(vma, id_offs[i].build_id, NULL)) {",
            "\t\t\t/* per entry fall back to ips */",
            "\t\t\tid_offs[i].status = BPF_STACK_BUILD_ID_IP;",
            "\t\t\tid_offs[i].ip = ips[i];",
            "\t\t\tmemset(id_offs[i].build_id, 0, BUILD_ID_SIZE_MAX);",
            "\t\t\tcontinue;",
            "\t\t}",
            "build_id_valid:",
            "\t\tid_offs[i].offset = (vma->vm_pgoff << PAGE_SHIFT) + ips[i]",
            "\t\t\t- vma->vm_start;",
            "\t\tid_offs[i].status = BPF_STACK_BUILD_ID_VALID;",
            "\t\tprev_vma = vma;",
            "\t\tprev_build_id = id_offs[i].build_id;",
            "\t}",
            "\tbpf_mmap_unlock_mm(work, current->mm);",
            "}",
            "static long __bpf_get_stackid(struct bpf_map *map,",
            "\t\t\t      struct perf_callchain_entry *trace, u64 flags)",
            "{",
            "\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);",
            "\tstruct stack_map_bucket *bucket, *new_bucket, *old_bucket;",
            "\tu32 skip = flags & BPF_F_SKIP_FIELD_MASK;",
            "\tu32 hash, id, trace_nr, trace_len;",
            "\tbool user = flags & BPF_F_USER_STACK;",
            "\tu64 *ips;",
            "\tbool hash_matches;",
            "",
            "\tif (trace->nr <= skip)",
            "\t\t/* skipping more than usable stack trace */",
            "\t\treturn -EFAULT;",
            "",
            "\ttrace_nr = trace->nr - skip;",
            "\ttrace_len = trace_nr * sizeof(u64);",
            "\tips = trace->ip + skip;",
            "\thash = jhash2((u32 *)ips, trace_len / sizeof(u32), 0);",
            "\tid = hash & (smap->n_buckets - 1);",
            "\tbucket = READ_ONCE(smap->buckets[id]);",
            "",
            "\thash_matches = bucket && bucket->hash == hash;",
            "\t/* fast cmp */",
            "\tif (hash_matches && flags & BPF_F_FAST_STACK_CMP)",
            "\t\treturn id;",
            "",
            "\tif (stack_map_use_build_id(map)) {",
            "\t\t/* for build_id+offset, pop a bucket before slow cmp */",
            "\t\tnew_bucket = (struct stack_map_bucket *)",
            "\t\t\tpcpu_freelist_pop(&smap->freelist);",
            "\t\tif (unlikely(!new_bucket))",
            "\t\t\treturn -ENOMEM;",
            "\t\tnew_bucket->nr = trace_nr;",
            "\t\tstack_map_get_build_id_offset(",
            "\t\t\t(struct bpf_stack_build_id *)new_bucket->data,",
            "\t\t\tips, trace_nr, user);",
            "\t\ttrace_len = trace_nr * sizeof(struct bpf_stack_build_id);",
            "\t\tif (hash_matches && bucket->nr == trace_nr &&",
            "\t\t    memcmp(bucket->data, new_bucket->data, trace_len) == 0) {",
            "\t\t\tpcpu_freelist_push(&smap->freelist, &new_bucket->fnode);",
            "\t\t\treturn id;",
            "\t\t}",
            "\t\tif (bucket && !(flags & BPF_F_REUSE_STACKID)) {",
            "\t\t\tpcpu_freelist_push(&smap->freelist, &new_bucket->fnode);",
            "\t\t\treturn -EEXIST;",
            "\t\t}",
            "\t} else {",
            "\t\tif (hash_matches && bucket->nr == trace_nr &&",
            "\t\t    memcmp(bucket->data, ips, trace_len) == 0)",
            "\t\t\treturn id;",
            "\t\tif (bucket && !(flags & BPF_F_REUSE_STACKID))",
            "\t\t\treturn -EEXIST;",
            "",
            "\t\tnew_bucket = (struct stack_map_bucket *)",
            "\t\t\tpcpu_freelist_pop(&smap->freelist);",
            "\t\tif (unlikely(!new_bucket))",
            "\t\t\treturn -ENOMEM;",
            "\t\tmemcpy(new_bucket->data, ips, trace_len);",
            "\t}",
            "",
            "\tnew_bucket->hash = hash;",
            "\tnew_bucket->nr = trace_nr;",
            "",
            "\told_bucket = xchg(&smap->buckets[id], new_bucket);",
            "\tif (old_bucket)",
            "\t\tpcpu_freelist_push(&smap->freelist, &old_bucket->fnode);",
            "\treturn id;",
            "}"
          ],
          "function_name": "stack_map_use_build_id, stack_map_data_size, prealloc_elems_and_freelist, stack_map_get_build_id_offset, __bpf_get_stackid",
          "description": "实现堆栈ID获取逻辑，包含构建ID解析、桶数据比较、哈希表查找等功能，支持通过构建ID或直接IP地址方式存储堆栈跟踪信息",
          "similarity": 0.48824989795684814
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/stackmap.c",
          "start_line": 601,
          "end_line": 671,
          "content": [
            "static int stack_map_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\t  void *next_key)",
            "{",
            "\tstruct bpf_stack_map *smap = container_of(map,",
            "\t\t\t\t\t\t  struct bpf_stack_map, map);",
            "\tu32 id;",
            "",
            "\tWARN_ON_ONCE(!rcu_read_lock_held());",
            "",
            "\tif (!key) {",
            "\t\tid = 0;",
            "\t} else {",
            "\t\tid = *(u32 *)key;",
            "\t\tif (id >= smap->n_buckets || !smap->buckets[id])",
            "\t\t\tid = 0;",
            "\t\telse",
            "\t\t\tid++;",
            "\t}",
            "",
            "\twhile (id < smap->n_buckets && !smap->buckets[id])",
            "\t\tid++;",
            "",
            "\tif (id >= smap->n_buckets)",
            "\t\treturn -ENOENT;",
            "",
            "\t*(u32 *)next_key = id;",
            "\treturn 0;",
            "}",
            "static long stack_map_update_elem(struct bpf_map *map, void *key, void *value,",
            "\t\t\t\t  u64 map_flags)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static long stack_map_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);",
            "\tstruct stack_map_bucket *old_bucket;",
            "\tu32 id = *(u32 *)key;",
            "",
            "\tif (unlikely(id >= smap->n_buckets))",
            "\t\treturn -E2BIG;",
            "",
            "\told_bucket = xchg(&smap->buckets[id], NULL);",
            "\tif (old_bucket) {",
            "\t\tpcpu_freelist_push(&smap->freelist, &old_bucket->fnode);",
            "\t\treturn 0;",
            "\t} else {",
            "\t\treturn -ENOENT;",
            "\t}",
            "}",
            "static void stack_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);",
            "",
            "\tbpf_map_area_free(smap->elems);",
            "\tpcpu_freelist_destroy(&smap->freelist);",
            "\tbpf_map_area_free(smap);",
            "\tput_callchain_buffers();",
            "}",
            "static u64 stack_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);",
            "\tu64 value_size = map->value_size;",
            "\tu64 n_buckets = smap->n_buckets;",
            "\tu64 enties = map->max_entries;",
            "\tu64 usage = sizeof(*smap);",
            "",
            "\tusage += n_buckets * sizeof(struct stack_map_bucket *);",
            "\tusage += enties * (sizeof(struct stack_map_bucket) + value_size);",
            "\treturn usage;",
            "}"
          ],
          "function_name": "stack_map_get_next_key, stack_map_update_elem, stack_map_delete_elem, stack_map_free, stack_map_mem_usage",
          "description": "实现堆栈映射的键值遍历、元素更新/删除、内存释放和内存使用统计功能，维护堆栈桶的生命周期管理",
          "similarity": 0.47491759061813354
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/stackmap.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2016 Facebook",
            " */",
            "#include <linux/bpf.h>",
            "#include <linux/jhash.h>",
            "#include <linux/filter.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/buildid.h>",
            "#include \"percpu_freelist.h\"",
            "#include \"mmap_unlock_work.h\"",
            "",
            "#define STACK_CREATE_FLAG_MASK\t\t\t\t\t\\",
            "\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY |\t\\",
            "\t BPF_F_STACK_BUILD_ID)",
            "",
            "struct stack_map_bucket {",
            "\tstruct pcpu_freelist_node fnode;",
            "\tu32 hash;",
            "\tu32 nr;",
            "\tu64 data[];",
            "};",
            "",
            "struct bpf_stack_map {",
            "\tstruct bpf_map map;",
            "\tvoid *elems;",
            "\tstruct pcpu_freelist freelist;",
            "\tu32 n_buckets;",
            "\tstruct stack_map_bucket *buckets[];",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义堆栈映射相关结构体，包含用于存储堆栈跟踪数据的stack_map_bucket和堆栈映射主结构bpf_stack_map，包含PCPU自由列表和桶数组",
          "similarity": 0.42611023783683777
        }
      ]
    }
  ]
}