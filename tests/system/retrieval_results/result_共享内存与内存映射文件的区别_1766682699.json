{
  "query": "共享内存与内存映射文件的区别",
  "timestamp": "2025-12-26 01:11:39",
  "retrieved_files": [
    {
      "source_file": "kernel/iomem.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:45:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `iomem.c`\n\n---\n\n# iomem.c 技术文档\n\n## 1. 文件概述\n\n`iomem.c` 实现了通用的内存重映射（`memremap`）接口，用于将物理地址空间（特别是 I/O 内存资源）映射为可直接访问的内核虚拟地址。与传统的 `ioremap` 不同，`memremap` 专为**无 I/O 副作用**的内存区域设计（如持久内存 PMEM、设备内存等），并支持多种缓存策略（如写回 WB、写通 WT、写合并 WC）。该文件还提供了资源管理版本（`devm_memremap`），可自动在设备卸载时释放映射。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`memremap()`**  \n  核心映射函数，根据指定的缓存策略（`MEMREMAP_WB`/`WT`/`WC`）将物理地址映射为内核虚拟地址。若映射区域为系统 RAM 且请求 `MEMREMAP_WB`，则直接返回线性映射地址。\n\n- **`memunmap()`**  \n  释放由 `memremap()` 创建的映射。若地址来自 `ioremap` 系列函数，则调用 `iounmap()`；若为直接映射地址则无需操作。\n\n- **`devm_memremap()`**  \n  设备资源管理版本的 `memremap()`，将映射资源与设备生命周期绑定，设备卸载时自动释放。\n\n- **`devm_memunmap()`**  \n  显式释放由 `devm_memremap()` 分配的资源（通常无需手动调用）。\n\n### 辅助函数\n\n- **`try_ram_remap()`**  \n  尝试对系统 RAM 区域使用内核直接映射（`__va()`），避免创建新页表。\n\n- **`arch_memremap_wb()`**（弱符号）  \n  架构特定的写回（WB）映射实现，默认回退到 `ioremap_cache()` 或 `ioremap()`。\n\n- **`arch_memremap_can_ram_remap()`**（弱符号）  \n  架构特定的 RAM 重映射能力检查，默认返回 `true`。\n\n### 标志位（Flags）\n\n- `MEMREMAP_WB`：写回缓存（默认系统 RAM 策略）\n- `MEMREMAP_WT`：写通缓存（禁止用于系统 RAM）\n- `MEMREMAP_WC`：写合并（禁止用于系统 RAM）\n- `MEMREMAP_ENC`/`DEC`：加密/解密映射（代码中未直接处理，由底层 `ioremap` 实现）\n\n## 3. 关键实现\n\n### 内存区域类型检测\n- 使用 `region_intersects()` 检查物理地址范围是否与 `IORESOURCE_SYSTEM_RAM` 重叠，返回：\n  - `REGION_INTERSECTS`：完全或部分在系统 RAM 内\n  - `REGION_MIXED`：跨越 RAM 与非 RAM 区域（视为错误）\n  - `REGION_DISJOINT`：完全在非 RAM 区域\n\n### RAM 直接映射优化\n- 当请求 `MEMREMAP_WB` 且区域为系统 RAM 时：\n  1. 调用 `try_ram_remap()` 检查是否满足直接映射条件：\n     - 物理页帧有效（`pfn_valid()`）\n     - 非高端内存（`!PageHighMem()`）\n     - 架构允许 RAM 重映射（`arch_memremap_can_ram_remap()`）\n  2. 若满足，直接返回 `__va(offset)`（内核线性映射地址），避免页表开销。\n\n### 非 RAM 区域映射\n- 对于非 RAM 区域或非 WB 请求：\n  - `MEMREMAP_WT` → `ioremap_wt()`\n  - `MEMREMAP_WC` → `ioremap_wc()`\n  - `MEMREMAP_WB` → `arch_memremap_wb()`（最终调用 `ioremap_cache()` 或 `ioremap()`）\n\n### 安全限制\n- 禁止对系统 RAM 使用 `WT`/`WC` 映射（会触发 `WARN_ONCE` 并返回 `NULL`）\n- 禁止映射混合 RAM/非 RAM 区域（视为编程错误）\n\n### 资源管理\n- `devm_memremap()` 使用设备资源管理框架（`devres`）：\n  - 分配资源描述符（`devres_alloc_node`）\n  - 注册释放回调（`devm_memremap_release`）\n  - 设备卸载时自动调用 `memunmap()`\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/io.h>`：提供 `ioremap_*()` 系列函数\n  - `<linux/mm.h>`：提供 `pfn_valid()`、`PageHighMem()` 等内存管理接口\n  - `<linux/ioremap.h>`：定义 `ioremap` 相关类型和函数\n  - `<linux/device.h>`：提供设备资源管理（`devres`）接口\n\n- **架构依赖**：\n  - 依赖架构实现的 `ioremap_cache()`、`ioremap_wt()`、`ioremap_wc()`\n  - 可选覆盖 `arch_memremap_wb()` 和 `arch_memremap_can_ram_remap()`\n\n- **内核子系统**：\n  - 内存管理子系统（MM）：页表管理、直接映射\n  - 设备驱动模型：设备资源生命周期管理\n\n## 5. 使用场景\n\n- **持久内存（PMEM）驱动**：  \n  将持久内存设备的物理地址映射为可直接读写的内核虚拟地址（通常使用 `MEMREMAP_WB`）。\n\n- **设备内存（Device Memory）访问**：  \n  访问无 I/O 副作用的设备内存区域（如 GPU 显存、FPGA 内存），根据性能需求选择缓存策略。\n\n- **EFI 运行时服务内存**：  \n  映射 EFI 固件提供的内存区域（需确保无副作用）。\n\n- **设备驱动资源管理**：  \n  使用 `devm_memremap()` 简化驱动代码，避免手动释放映射（尤其适用于 probe/remove 场景）。\n\n- **内核子系统通用映射**：  \n  为需要高性能内存访问的子系统（如 DAX、HMM）提供统一映射接口。",
      "similarity": 0.6243742108345032,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/iomem.c",
          "start_line": 20,
          "end_line": 42,
          "content": [
            "static bool arch_memremap_can_ram_remap(resource_size_t offset, size_t size,",
            "\t\t\t\t\tunsigned long flags)",
            "{",
            "\treturn true;",
            "}",
            "void memunmap(void *addr)",
            "{",
            "\tif (is_ioremap_addr(addr))",
            "\t\tiounmap((void __iomem *) addr);",
            "}",
            "static void devm_memremap_release(struct device *dev, void *res)",
            "{",
            "\tmemunmap(*(void **)res);",
            "}",
            "static int devm_memremap_match(struct device *dev, void *res, void *match_data)",
            "{",
            "\treturn *(void **)res == match_data;",
            "}",
            "void devm_memunmap(struct device *dev, void *addr)",
            "{",
            "\tWARN_ON(devres_release(dev, devm_memremap_release,",
            "\t\t\t\tdevm_memremap_match, addr));",
            "}"
          ],
          "function_name": "arch_memremap_can_ram_remap, memunmap, devm_memremap_release, devm_memremap_match, devm_memunmap",
          "description": "实现内存映射释放相关函数，包含判断能否进行RAM重映射的钩子函数、解除ioremap地址映射的memunmap函数，以及设备资源管理中的动态内存映射释放匹配逻辑",
          "similarity": 0.591553807258606
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/iomem.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "/* SPDX-License-Identifier: GPL-2.0 */",
            "#include <linux/device.h>",
            "#include <linux/types.h>",
            "#include <linux/io.h>",
            "#include <linux/mm.h>",
            "#include <linux/ioremap.h>",
            "",
            "#ifndef arch_memremap_wb",
            "static void *arch_memremap_wb(resource_size_t offset, unsigned long size)",
            "{",
            "#ifdef ioremap_cache",
            "\treturn (__force void *)ioremap_cache(offset, size);",
            "#else",
            "\treturn (__force void *)ioremap(offset, size);",
            "#endif",
            "}",
            "#endif",
            "",
            "#ifndef arch_memremap_can_ram_remap"
          ],
          "function_name": null,
          "description": "定义arch_memremap_wb函数，根据ioremap_cache是否存在选择使用ioremap_cache或ioremap实现，用于创建带写回缓存策略的内存映射区域，上下文不完整",
          "similarity": 0.5159003734588623
        }
      ]
    },
    {
      "source_file": "mm/memremap.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:45:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memremap.c`\n\n---\n\n# memremap.c 技术文档\n\n## 1. 文件概述\n\n`memremap.c` 是 Linux 内核中用于管理设备持久内存（Persistent Memory）映射的核心实现文件。它提供了将物理设备内存（如 NVDIMM、CXL 等）映射到内核虚拟地址空间并将其纳入内存管理子系统（特别是 ZONE_DEVICE）的机制。该文件主要实现了 `memremap_pages()` 和 `memunmap_pages()` 接口，用于注册和注销设备页映射（`dev_pagemap`），支持多种设备内存类型（如 FS_DAX、PRIVATE、COHERENT 等），并确保与内存热插拔、KASAN、NUMA 等子系统的正确集成。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct dev_pagemap`**：描述设备内存区域的元数据结构，包含内存范围、类型、引用计数、完成量等。\n- **`pgmap_array`**：全局 XArray 结构，用于按 PFN 范围快速查找对应的 `dev_pagemap` 实例。\n\n### 主要函数\n- **`memremap_compat_align()`**：返回设备内存映射的最小兼容对齐粒度（默认为 `SUBSECTION_SIZE`），确保在不同映射模式间切换时满足架构约束。\n- **`pgmap_pfn_valid()`**：判断给定 PFN 是否属于指定 `dev_pagemap` 的有效范围。\n- **`memunmap_pages()`**：释放通过 `memremap_pages()` 映射的设备内存区域，包括从内存管理子系统移除、清理 KASAN 影子内存、更新 XArray 等。\n- **`pagemap_range()`**：内部辅助函数，负责将单个内存范围添加到内核内存管理中（调用 `arch_add_memory()` 或 `add_pages()`）。\n- **`devm_memremap_pages_release()`**：资源管理释放回调，用于自动清理通过 `devm_` 接口分配的映射。\n- **`dev_pagemap_percpu_release()`**：percpu 引用计数释放回调，用于同步等待所有用户完成后再执行实际卸载。\n\n### 静态键（Static Keys）\n- **`devmap_managed_key`**：仅在 `CONFIG_FS_DAX` 启用时定义，用于优化 FS_DAX 设备内存路径的运行时分支预测。\n\n## 3. 关键实现\n\n### 设备内存映射流程 (`pagemap_range`)\n1. **冲突检测**：通过 `get_dev_pagemap()` 检查目标 PFN 范围是否已存在映射，避免重叠。\n2. **RAM 区域检查**：使用 `region_intersects()` 确保映射区域不与系统 RAM 重叠。\n3. **XArray 注册**：将 `dev_pagemap` 指针存入全局 `pgmap_array`，以 PFN 为键。\n4. **PFN 跟踪**：调用 `track_pfn_remap()` 建立页表映射。\n5. **内存热插拔**：\n   - 对于 `MEMORY_DEVICE_PRIVATE` 类型，调用 `add_pages()` 仅初始化 `struct page`，不建立线性映射。\n   - 对于其他类型（如 FS_DAX），调用 `kasan_add_zero_shadow()` 添加 KASAN 影子内存，再调用 `arch_add_memory()` 建立完整线性映射。\n6. **ZONE_DEVICE 集成**：调用 `move_pfn_range_to_zone()` 将 PFN 范围移动到 `ZONE_DEVICE`。\n7. **延迟初始化**：调用 `memmap_init_zone_device()` 初始化 `struct page` 的设备特定字段。\n8. **引用计数**：对非 PRIVATE/COHERENT 类型，增加 percpu 引用计数。\n\n### 设备内存卸载流程 (`memunmap_pages`)\n1. **引用计数终止**：调用 `percpu_ref_kill()` 标记引用不可再增加。\n2. **引用释放**：对非 PRIVATE/COHERENT 类型，批量减少 percpu 引用。\n3. **同步等待**：通过 `wait_for_completion()` 等待所有现有引用释放完毕。\n4. **逐范围卸载**：对每个范围调用 `pageunmap_range()`：\n   - 从对应 zone 移除 PFN 范围。\n   - 调用 `__remove_pages()`（PRIVATE）或 `arch_remove_memory()` + `kasan_remove_zero_shadow()`（其他类型）。\n   - 调用 `untrack_pfn()` 清理页表跟踪。\n   - 从 `pgmap_array` 中删除映射。\n5. **清理引用**：调用 `percpu_ref_exit()` 销毁 percpu 引用。\n6. **静态键更新**：若为 FS_DAX 类型，减少 `devmap_managed_key` 计数。\n\n### PFN 范围处理\n- **起始 PFN**：`pfn_first()` 考虑 `vmem_altmap` 的偏移（用于预留 struct page 存储空间）。\n- **结束 PFN**：`pfn_end()` 基于物理范围计算。\n- **有效长度**：`pfn_len()` 计算实际可使用的页数，并考虑 `vmemmap_shift`（用于大页优化）。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `memory_hotplug.h`、`mmzone.h`、`swap.h` 等，与 `ZONE_DEVICE`、内存热插拔机制紧密集成。\n- **体系结构相关代码**：调用 `arch_add_memory()`、`arch_remove_memory()`，依赖各架构的具体实现。\n- **KASAN**：通过 `kasan_add/remove_zero_shadow()` 管理影子内存。\n- **DAX 子系统**：当 `CONFIG_FS_DAX` 启用时，与 DAX 设备管理交互，使用 `devmap_managed_key` 优化路径。\n- **XArray**：使用 XArray 数据结构高效管理 PFN 到 `dev_pagemap` 的映射。\n- **Per-CPU 引用计数**：使用 `percpu_ref` 机制安全地管理设备内存的生命周期。\n- **内部头文件**：包含 `\"internal.h\"`，访问内核内存管理内部接口。\n\n## 5. 使用场景\n\n- **持久内存 (PMEM) 设备驱动**：如 `libnvdimm` 子系统中的 `nd_pmem` 驱动，使用 `memremap_pages()` 将 NVDIMM 映射为可直接访问的内存。\n- **CXL 内存设备**：CXL.mem 设备通过此接口将设备附加内存纳入内核管理。\n- **DAX 文件系统**：当挂载支持 DAX 的文件系统（如 ext4、xfs）到 PMEM 设备时，底层使用此机制建立直接映射。\n- **GPU/CXL 设备私有内存**：`MEMORY_DEVICE_PRIVATE` 类型用于管理 CPU 不可直接访问但可通过特殊指令（如迁移 API）操作的设备内存。\n- **异构内存管理**：作为统一内存架构（UMA/NUMA 扩展）的一部分，将设备内存作为特殊内存节点纳入调度和分配策略。",
      "similarity": 0.6205989122390747,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/memremap.c",
          "start_line": 34,
          "end_line": 137,
          "content": [
            "unsigned long memremap_compat_align(void)",
            "{",
            "\treturn SUBSECTION_SIZE;",
            "}",
            "static void devmap_managed_enable_put(struct dev_pagemap *pgmap)",
            "{",
            "\tif (pgmap->type == MEMORY_DEVICE_FS_DAX)",
            "\t\tstatic_branch_dec(&devmap_managed_key);",
            "}",
            "static void devmap_managed_enable_get(struct dev_pagemap *pgmap)",
            "{",
            "\tif (pgmap->type == MEMORY_DEVICE_FS_DAX)",
            "\t\tstatic_branch_inc(&devmap_managed_key);",
            "}",
            "static void devmap_managed_enable_get(struct dev_pagemap *pgmap)",
            "{",
            "}",
            "static void devmap_managed_enable_put(struct dev_pagemap *pgmap)",
            "{",
            "}",
            "static void pgmap_array_delete(struct range *range)",
            "{",
            "\txa_store_range(&pgmap_array, PHYS_PFN(range->start), PHYS_PFN(range->end),",
            "\t\t\tNULL, GFP_KERNEL);",
            "\tsynchronize_rcu();",
            "}",
            "static unsigned long pfn_first(struct dev_pagemap *pgmap, int range_id)",
            "{",
            "\tstruct range *range = &pgmap->ranges[range_id];",
            "\tunsigned long pfn = PHYS_PFN(range->start);",
            "",
            "\tif (range_id)",
            "\t\treturn pfn;",
            "\treturn pfn + vmem_altmap_offset(pgmap_altmap(pgmap));",
            "}",
            "bool pgmap_pfn_valid(struct dev_pagemap *pgmap, unsigned long pfn)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < pgmap->nr_range; i++) {",
            "\t\tstruct range *range = &pgmap->ranges[i];",
            "",
            "\t\tif (pfn >= PHYS_PFN(range->start) &&",
            "\t\t    pfn <= PHYS_PFN(range->end))",
            "\t\t\treturn pfn >= pfn_first(pgmap, i);",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static unsigned long pfn_end(struct dev_pagemap *pgmap, int range_id)",
            "{",
            "\tconst struct range *range = &pgmap->ranges[range_id];",
            "",
            "\treturn (range->start + range_len(range)) >> PAGE_SHIFT;",
            "}",
            "static unsigned long pfn_len(struct dev_pagemap *pgmap, unsigned long range_id)",
            "{",
            "\treturn (pfn_end(pgmap, range_id) -",
            "\t\tpfn_first(pgmap, range_id)) >> pgmap->vmemmap_shift;",
            "}",
            "static void pageunmap_range(struct dev_pagemap *pgmap, int range_id)",
            "{",
            "\tstruct range *range = &pgmap->ranges[range_id];",
            "\tstruct page *first_page;",
            "",
            "\t/* make sure to access a memmap that was actually initialized */",
            "\tfirst_page = pfn_to_page(pfn_first(pgmap, range_id));",
            "",
            "\t/* pages are dead and unused, undo the arch mapping */",
            "\tmem_hotplug_begin();",
            "\tremove_pfn_range_from_zone(page_zone(first_page), PHYS_PFN(range->start),",
            "\t\t\t\t   PHYS_PFN(range_len(range)));",
            "\tif (pgmap->type == MEMORY_DEVICE_PRIVATE) {",
            "\t\t__remove_pages(PHYS_PFN(range->start),",
            "\t\t\t       PHYS_PFN(range_len(range)), NULL);",
            "\t} else {",
            "\t\tarch_remove_memory(range->start, range_len(range),",
            "\t\t\t\tpgmap_altmap(pgmap));",
            "\t\tkasan_remove_zero_shadow(__va(range->start), range_len(range));",
            "\t}",
            "\tmem_hotplug_done();",
            "",
            "\tuntrack_pfn(NULL, PHYS_PFN(range->start), range_len(range), true);",
            "\tpgmap_array_delete(range);",
            "}",
            "void memunmap_pages(struct dev_pagemap *pgmap)",
            "{",
            "\tint i;",
            "",
            "\tpercpu_ref_kill(&pgmap->ref);",
            "\tif (pgmap->type != MEMORY_DEVICE_PRIVATE &&",
            "\t    pgmap->type != MEMORY_DEVICE_COHERENT)",
            "\t\tfor (i = 0; i < pgmap->nr_range; i++)",
            "\t\t\tpercpu_ref_put_many(&pgmap->ref, pfn_len(pgmap, i));",
            "",
            "\twait_for_completion(&pgmap->done);",
            "",
            "\tfor (i = 0; i < pgmap->nr_range; i++)",
            "\t\tpageunmap_range(pgmap, i);",
            "\tpercpu_ref_exit(&pgmap->ref);",
            "",
            "\tWARN_ONCE(pgmap->altmap.alloc, \"failed to free all reserved pages\\n\");",
            "\tdevmap_managed_enable_put(pgmap);",
            "}"
          ],
          "function_name": "memremap_compat_align, devmap_managed_enable_put, devmap_managed_enable_get, devmap_managed_enable_get, devmap_managed_enable_put, pgmap_array_delete, pfn_first, pgmap_pfn_valid, pfn_end, pfn_len, pageunmap_range, memunmap_pages",
          "description": "实现设备内存映射管理函数，包含兼容对齐返回、引用计数增减、PFN范围操作及内存解映射逻辑，通过xa操作维护pgmap_array并处理内存热插拔相关状态",
          "similarity": 0.5950524806976318
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memremap.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright(c) 2015 Intel Corporation. All rights reserved. */",
            "#include <linux/device.h>",
            "#include <linux/io.h>",
            "#include <linux/kasan.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/swapops.h>",
            "#include <linux/types.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/xarray.h>",
            "#include \"internal.h\"",
            "",
            "static DEFINE_XARRAY(pgmap_array);",
            "",
            "/*",
            " * The memremap() and memremap_pages() interfaces are alternately used",
            " * to map persistent memory namespaces. These interfaces place different",
            " * constraints on the alignment and size of the mapping (namespace).",
            " * memremap() can map individual PAGE_SIZE pages. memremap_pages() can",
            " * only map subsections (2MB), and at least one architecture (PowerPC)",
            " * the minimum mapping granularity of memremap_pages() is 16MB.",
            " *",
            " * The role of memremap_compat_align() is to communicate the minimum",
            " * arch supported alignment of a namespace such that it can freely",
            " * switch modes without violating the arch constraint. Namely, do not",
            " * allow a namespace to be PAGE_SIZE aligned since that namespace may be",
            " * reconfigured into a mode that requires SUBSECTION_SIZE alignment.",
            " */",
            "#ifndef CONFIG_ARCH_HAS_MEMREMAP_COMPAT_ALIGN"
          ],
          "function_name": null,
          "description": "定义pgmap_array XArray用于存储设备内存映射范围，注释说明memremap接口的兼容性对齐约束及架构限制，因条件编译未完全展开导致上下文不完整",
          "similarity": 0.593005895614624
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memremap.c",
          "start_line": 419,
          "end_line": 499,
          "content": [
            "void devm_memunmap_pages(struct device *dev, struct dev_pagemap *pgmap)",
            "{",
            "\tdevm_release_action(dev, devm_memremap_pages_release, pgmap);",
            "}",
            "unsigned long vmem_altmap_offset(struct vmem_altmap *altmap)",
            "{",
            "\t/* number of pfns from base where pfn_to_page() is valid */",
            "\tif (altmap)",
            "\t\treturn altmap->reserve + altmap->free;",
            "\treturn 0;",
            "}",
            "void vmem_altmap_free(struct vmem_altmap *altmap, unsigned long nr_pfns)",
            "{",
            "\taltmap->alloc -= nr_pfns;",
            "}",
            "void free_zone_device_folio(struct folio *folio)",
            "{",
            "\tif (WARN_ON_ONCE(!folio->page.pgmap->ops ||",
            "\t\t\t!folio->page.pgmap->ops->page_free))",
            "\t\treturn;",
            "",
            "\tmem_cgroup_uncharge(folio);",
            "",
            "\t/*",
            "\t * Note: we don't expect anonymous compound pages yet. Once supported",
            "\t * and we could PTE-map them similar to THP, we'd have to clear",
            "\t * PG_anon_exclusive on all tail pages.",
            "\t */",
            "\tif (folio_test_anon(folio)) {",
            "\t\tVM_BUG_ON_FOLIO(folio_test_large(folio), folio);",
            "\t\t__ClearPageAnonExclusive(folio_page(folio, 0));",
            "\t}",
            "",
            "\t/*",
            "\t * When a device managed page is freed, the folio->mapping field",
            "\t * may still contain a (stale) mapping value. For example, the",
            "\t * lower bits of folio->mapping may still identify the folio as an",
            "\t * anonymous folio. Ultimately, this entire field is just stale",
            "\t * and wrong, and it will cause errors if not cleared.",
            "\t *",
            "\t * For other types of ZONE_DEVICE pages, migration is either",
            "\t * handled differently or not done at all, so there is no need",
            "\t * to clear folio->mapping.",
            "\t */",
            "\tfolio->mapping = NULL;",
            "\tfolio->page.pgmap->ops->page_free(folio_page(folio, 0));",
            "",
            "\tif (folio->page.pgmap->type != MEMORY_DEVICE_PRIVATE &&",
            "\t    folio->page.pgmap->type != MEMORY_DEVICE_COHERENT)",
            "\t\t/*",
            "\t\t * Reset the refcount to 1 to prepare for handing out the page",
            "\t\t * again.",
            "\t\t */",
            "\t\tfolio_set_count(folio, 1);",
            "\telse",
            "\t\tput_dev_pagemap(folio->page.pgmap);",
            "}",
            "void zone_device_page_init(struct page *page)",
            "{",
            "\t/*",
            "\t * Drivers shouldn't be allocating pages after calling",
            "\t * memunmap_pages().",
            "\t */",
            "\tWARN_ON_ONCE(!percpu_ref_tryget_live(&page->pgmap->ref));",
            "\tset_page_count(page, 1);",
            "\tlock_page(page);",
            "}",
            "bool __put_devmap_managed_folio_refs(struct folio *folio, int refs)",
            "{",
            "\tif (folio->page.pgmap->type != MEMORY_DEVICE_FS_DAX)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * fsdax page refcounts are 1-based, rather than 0-based: if",
            "\t * refcount is 1, then the page is free and the refcount is",
            "\t * stable because nobody holds a reference on the page.",
            "\t */",
            "\tif (folio_ref_sub_return(folio, refs) == 1)",
            "\t\twake_up_var(&folio->_refcount);",
            "\treturn true;",
            "}"
          ],
          "function_name": "devm_memunmap_pages, vmem_altmap_offset, vmem_altmap_free, free_zone_device_folio, zone_device_page_init, __put_devmap_managed_folio_refs",
          "description": "实现设备内存释放链路，包含虚拟映射偏移计算、ZONEdevice页帧回收、映射信息清理及引用计数管理，针对不同类型设备内存执行差异化释放策略",
          "similarity": 0.5909605622291565
        },
        {
          "chunk_id": 2,
          "file_path": "mm/memremap.c",
          "start_line": 157,
          "end_line": 281,
          "content": [
            "static void devm_memremap_pages_release(void *data)",
            "{",
            "\tmemunmap_pages(data);",
            "}",
            "static void dev_pagemap_percpu_release(struct percpu_ref *ref)",
            "{",
            "\tstruct dev_pagemap *pgmap = container_of(ref, struct dev_pagemap, ref);",
            "",
            "\tcomplete(&pgmap->done);",
            "}",
            "static int pagemap_range(struct dev_pagemap *pgmap, struct mhp_params *params,",
            "\t\tint range_id, int nid)",
            "{",
            "\tconst bool is_private = pgmap->type == MEMORY_DEVICE_PRIVATE;",
            "\tstruct range *range = &pgmap->ranges[range_id];",
            "\tstruct dev_pagemap *conflict_pgmap;",
            "\tint error, is_ram;",
            "",
            "\tif (WARN_ONCE(pgmap_altmap(pgmap) && range_id > 0,",
            "\t\t\t\t\"altmap not supported for multiple ranges\\n\"))",
            "\t\treturn -EINVAL;",
            "",
            "\tconflict_pgmap = get_dev_pagemap(PHYS_PFN(range->start), NULL);",
            "\tif (conflict_pgmap) {",
            "\t\tWARN(1, \"Conflicting mapping in same section\\n\");",
            "\t\tput_dev_pagemap(conflict_pgmap);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tconflict_pgmap = get_dev_pagemap(PHYS_PFN(range->end), NULL);",
            "\tif (conflict_pgmap) {",
            "\t\tWARN(1, \"Conflicting mapping in same section\\n\");",
            "\t\tput_dev_pagemap(conflict_pgmap);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tis_ram = region_intersects(range->start, range_len(range),",
            "\t\tIORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);",
            "",
            "\tif (is_ram != REGION_DISJOINT) {",
            "\t\tWARN_ONCE(1, \"attempted on %s region %#llx-%#llx\\n\",",
            "\t\t\t\tis_ram == REGION_MIXED ? \"mixed\" : \"ram\",",
            "\t\t\t\trange->start, range->end);",
            "\t\treturn -ENXIO;",
            "\t}",
            "",
            "\terror = xa_err(xa_store_range(&pgmap_array, PHYS_PFN(range->start),",
            "\t\t\t\tPHYS_PFN(range->end), pgmap, GFP_KERNEL));",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\tif (nid < 0)",
            "\t\tnid = numa_mem_id();",
            "",
            "\terror = track_pfn_remap(NULL, &params->pgprot, PHYS_PFN(range->start), 0,",
            "\t\t\trange_len(range));",
            "\tif (error)",
            "\t\tgoto err_pfn_remap;",
            "",
            "\tif (!mhp_range_allowed(range->start, range_len(range), !is_private)) {",
            "\t\terror = -EINVAL;",
            "\t\tgoto err_kasan;",
            "\t}",
            "",
            "\tmem_hotplug_begin();",
            "",
            "\t/*",
            "\t * For device private memory we call add_pages() as we only need to",
            "\t * allocate and initialize struct page for the device memory. More-",
            "\t * over the device memory is un-accessible thus we do not want to",
            "\t * create a linear mapping for the memory like arch_add_memory()",
            "\t * would do.",
            "\t *",
            "\t * For all other device memory types, which are accessible by",
            "\t * the CPU, we do want the linear mapping and thus use",
            "\t * arch_add_memory().",
            "\t */",
            "\tif (is_private) {",
            "\t\terror = add_pages(nid, PHYS_PFN(range->start),",
            "\t\t\t\tPHYS_PFN(range_len(range)), params);",
            "\t} else {",
            "\t\terror = kasan_add_zero_shadow(__va(range->start), range_len(range));",
            "\t\tif (error) {",
            "\t\t\tmem_hotplug_done();",
            "\t\t\tgoto err_kasan;",
            "\t\t}",
            "",
            "\t\terror = arch_add_memory(nid, range->start, range_len(range),",
            "\t\t\t\t\tparams);",
            "\t}",
            "",
            "\tif (!error) {",
            "\t\tstruct zone *zone;",
            "",
            "\t\tzone = &NODE_DATA(nid)->node_zones[ZONE_DEVICE];",
            "\t\tmove_pfn_range_to_zone(zone, PHYS_PFN(range->start),",
            "\t\t\t\tPHYS_PFN(range_len(range)), params->altmap,",
            "\t\t\t\tMIGRATE_MOVABLE);",
            "\t}",
            "",
            "\tmem_hotplug_done();",
            "\tif (error)",
            "\t\tgoto err_add_memory;",
            "",
            "\t/*",
            "\t * Initialization of the pages has been deferred until now in order",
            "\t * to allow us to do the work while not holding the hotplug lock.",
            "\t */",
            "\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],",
            "\t\t\t\tPHYS_PFN(range->start),",
            "\t\t\t\tPHYS_PFN(range_len(range)), pgmap);",
            "\tif (pgmap->type != MEMORY_DEVICE_PRIVATE &&",
            "\t    pgmap->type != MEMORY_DEVICE_COHERENT)",
            "\t\tpercpu_ref_get_many(&pgmap->ref, pfn_len(pgmap, range_id));",
            "\treturn 0;",
            "",
            "err_add_memory:",
            "\tif (!is_private)",
            "\t\tkasan_remove_zero_shadow(__va(range->start), range_len(range));",
            "err_kasan:",
            "\tuntrack_pfn(NULL, PHYS_PFN(range->start), range_len(range), true);",
            "err_pfn_remap:",
            "\tpgmap_array_delete(range);",
            "\treturn error;",
            "}"
          ],
          "function_name": "devm_memremap_pages_release, dev_pagemap_percpu_release, pagemap_range",
          "description": "提供设备内存注册流程，检查地址冲突与内存类型有效性，通过track_pfn_remap追踪PFN范围，依据内存类型调用add_pages或arch_add_memory完成设备内存注册",
          "similarity": 0.522078275680542
        }
      ]
    },
    {
      "source_file": "kernel/dma/ops_helpers.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:14:54\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma\\ops_helpers.c`\n\n---\n\n# `dma/ops_helpers.c` 技术文档\n\n## 1. 文件概述\n\n`dma/ops_helpers.c` 是 Linux 内核中为 DMA（Direct Memory Access）操作提供通用辅助功能的实现文件。该文件封装了多个通用的 DMA 操作辅助函数，用于简化不同架构或设备驱动中 DMA 映射、内存分配、用户空间映射及 scatter-gather 表构建等常见任务。这些函数假设所分配的内存位于内核直接映射区域（normal pages in the direct kernel mapping），并依赖底层 `dma_map_ops` 操作集完成实际的硬件相关操作。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `dma_common_vaddr_to_page(void *cpu_addr)`  \n  将内核虚拟地址转换为对应的 `struct page *`，支持 `vmalloc` 区域和直接映射区域。\n\n- `dma_common_get_sgtable(struct device *dev, struct sg_table *sgt, void *cpu_addr, dma_addr_t dma_addr, size_t size, unsigned long attrs)`  \n  为已分配的 DMA 缓冲区创建单页 scatter-gather 表（`sg_table`）。\n\n- `dma_common_mmap(struct device *dev, struct vm_area_struct *vma, void *cpu_addr, dma_addr_t dma_addr, size_t size, unsigned long attrs)`  \n  为 DMA 一致性内存创建用户空间 mmap 映射。\n\n- `dma_common_alloc_pages(struct device *dev, size_t size, dma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)`  \n  分配物理连续（或通过 CMA）的页面，并通过 DMA 映射操作获取设备可访问的总线地址。\n\n- `dma_common_free_pages(struct device *dev, size_t size, struct page *page, dma_addr_t dma_handle, enum dma_data_direction dir)`  \n  释放由 `dma_common_alloc_pages` 分配的页面，并取消 DMA 映射。\n\n### 数据结构\n\n- 无定义新的数据结构，主要使用内核通用结构：\n  - `struct page`\n  - `struct sg_table`\n  - `struct vm_area_struct`\n  - `struct device`\n\n## 3. 关键实现\n\n### 地址到页面转换\n`dma_common_vaddr_to_page` 函数首先判断传入的 CPU 虚拟地址是否属于 `vmalloc` 区域。若是，则调用 `vmalloc_to_page`；否则使用 `virt_to_page`。这确保了对内核不同内存区域的兼容性。\n\n### Scatter-Gather 表构建\n`dma_common_get_sgtable` 假设 DMA 缓冲区由单个物理页面（或连续页面）组成，因此只分配一个 scatterlist 条目，并通过 `sg_set_page` 设置页面、长度（按页对齐）和偏移（0）。\n\n### 用户空间 mmap 支持\n`dma_common_mmap` 函数：\n- 仅在 `CONFIG_MMU` 配置下有效；\n- 首先尝试通过 `dma_mmap_from_dev_coherent` 处理设备特定的一致性内存映射；\n- 若失败，则使用通用路径：将内核页面的 PFN（页帧号）加上 `vma->vm_pgoff`，通过 `remap_pfn_range` 映射到用户空间；\n- 映射前进行边界检查，防止越界访问；\n- 使用 `dma_pgprot` 根据设备属性调整页保护标志。\n\n### 页面分配与释放\n- `dma_common_alloc_pages` 优先尝试通过 CMA（Contiguous Memory Allocator）分配连续物理内存（`dma_alloc_contiguous`），失败后回退到 `alloc_pages_node`；\n- 分配成功后，调用设备的 `map_page` 操作获取 DMA 地址，并跳过 CPU 缓存同步（`DMA_ATTR_SKIP_CPU_SYNC`）；\n- 分配的内存会被清零；\n- 释放时先调用 `unmap_page`（若存在），再通过 `dma_free_contiguous` 释放物理页面。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/dma-map-ops.h>`：提供 `dma_map_ops`、`get_dma_ops`、`dma_alloc_contiguous` 等核心 DMA 操作接口。\n- **内核子系统依赖**：\n  - **内存管理子系统**：依赖 `vmalloc`、`page`、`pfn`、`remap_pfn_range` 等 MMU 相关机制；\n  - **CMA（Contiguous Memory Allocator）**：用于分配大块连续物理内存；\n  - **设备模型**：通过 `struct device` 获取 NUMA 节点（`dev_to_node`）和 DMA 操作集；\n  - **DMA 映射框架**：依赖各架构或平台实现的 `dma_map_ops`（如 `map_page`/`unmap_page`）。\n\n## 5. 使用场景\n\n- **设备驱动开发**：当驱动需要实现自定义的 `dma_map_ops` 时，可复用本文件中的通用函数，避免重复实现 scatterlist 构建、mmap 或页面分配逻辑。\n- **一致性 DMA 内存管理**：适用于需要分配一致性（coherent）DMA 内存并映射到用户空间的场景（如音视频、网络设备驱动）。\n- **简化 DMA 编程模型**：为不支持复杂 IOMMU 或 scatter-gather 的简单设备提供轻量级 DMA 操作封装。\n- **跨架构兼容性**：通过抽象底层差异，使驱动代码在不同架构（如 ARM、x86）上保持一致行为。",
      "similarity": 0.6180806159973145,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/dma/ops_helpers.c",
          "start_line": 18,
          "end_line": 65,
          "content": [
            "int dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,",
            "\t\t void *cpu_addr, dma_addr_t dma_addr, size_t size,",
            "\t\t unsigned long attrs)",
            "{",
            "\tstruct page *page = dma_common_vaddr_to_page(cpu_addr);",
            "\tint ret;",
            "",
            "\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);",
            "\tif (!ret)",
            "\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);",
            "\treturn ret;",
            "}",
            "int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,",
            "\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,",
            "\t\tunsigned long attrs)",
            "{",
            "#ifdef CONFIG_MMU",
            "\tunsigned long user_count = vma_pages(vma);",
            "\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;",
            "\tunsigned long off = vma->vm_pgoff;",
            "\tstruct page *page = dma_common_vaddr_to_page(cpu_addr);",
            "\tint ret = -ENXIO;",
            "",
            "\tvma->vm_page_prot = dma_pgprot(dev, vma->vm_page_prot, attrs);",
            "",
            "\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))",
            "\t\treturn ret;",
            "",
            "\tif (off >= count || user_count > count - off)",
            "\t\treturn -ENXIO;",
            "",
            "\treturn remap_pfn_range(vma, vma->vm_start,",
            "\t\t\tpage_to_pfn(page) + vma->vm_pgoff,",
            "\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);",
            "#else",
            "\treturn -ENXIO;",
            "#endif /* CONFIG_MMU */",
            "}",
            "void dma_common_free_pages(struct device *dev, size_t size, struct page *page,",
            "\t\tdma_addr_t dma_handle, enum dma_data_direction dir)",
            "{",
            "\tconst struct dma_map_ops *ops = get_dma_ops(dev);",
            "",
            "\tif (ops->unmap_page)",
            "\t\tops->unmap_page(dev, dma_handle, size, dir,",
            "\t\t\t\tDMA_ATTR_SKIP_CPU_SYNC);",
            "\tdma_free_contiguous(dev, page, size);",
            "}"
          ],
          "function_name": "dma_common_get_sgtable, dma_common_mmap, dma_common_free_pages",
          "description": "该代码块实现了三个DMA操作辅助函数，dma_common_get_sgtable构建单页SG表用于DMA传输，dma_common_mmap处理设备内存映射并支持MMU配置，dma_common_free_pages负责解除页面映射并释放连续内存资源",
          "similarity": 0.5154680013656616
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/dma/ops_helpers.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Helpers for DMA ops implementations.  These generally rely on the fact that",
            " * the allocated memory contains normal pages in the direct kernel mapping.",
            " */",
            "#include <linux/dma-map-ops.h>",
            "",
            "static struct page *dma_common_vaddr_to_page(void *cpu_addr)",
            "{",
            "\tif (is_vmalloc_addr(cpu_addr))",
            "\t\treturn vmalloc_to_page(cpu_addr);",
            "\treturn virt_to_page(cpu_addr);",
            "}",
            "",
            "/*",
            " * Create scatter-list for the already allocated DMA buffer.",
            " */"
          ],
          "function_name": null,
          "description": "该代码块定义了dma_common_vaddr_to_page函数，用于将CPU虚拟地址转换为对应的物理页面结构，通过判断地址是否属于vmalloc区域选择不同的转换方式。后续未展示的代码可能包含与DMA操作相关的辅助函数声明，当前上下文不完整",
          "similarity": 0.4100435674190521
        }
      ]
    }
  ]
}