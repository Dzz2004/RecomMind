{
  "query": "security mechanisms",
  "timestamp": "2025-12-25 23:32:25",
  "retrieved_files": [
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5384699106216431,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5378950834274292
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.4734095335006714
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.46983134746551514
        }
      ]
    },
    {
      "source_file": "kernel/module/signing.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:06:05\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\signing.c`\n\n---\n\n# module/signing.c 技术文档\n\n## 1. 文件概述\n\n`module/signing.c` 是 Linux 内核中用于验证内核模块数字签名的核心实现文件。该文件提供了模块加载过程中对 PKCS#7 格式签名的解析、验证和策略控制功能，确保只有经过合法签名的模块才能被加载到内核中，从而增强系统的安全性和完整性。该机制是内核模块签名（Module Signature）子系统的关键组成部分，支持强制签名（`CONFIG_MODULE_SIG_FORCE`）和运行时策略控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`is_module_sig_enforced(void)`**  \n  返回当前是否强制要求模块必须具有有效签名。该函数导出为符号，供其他内核子系统使用。\n\n- **`set_module_sig_enforced(void)`**  \n  在运行时将模块签名强制策略设置为启用状态（`true`），通常由安全机制（如 Lockdown）调用。\n\n- **`mod_verify_sig(const void *mod, struct load_info *info)`**  \n  执行模块签名的实际验证逻辑：解析模块末尾的 `module_signature` 结构，提取签名数据，并调用通用 PKCS#7 验证接口进行验证。\n\n- **`module_sig_check(struct load_info *info, int flags)`**  \n  模块加载流程中的主入口函数，负责检测模块是否包含签名标记（`~Module signature appended~\\n`），决定是否调用 `mod_verify_sig`，并根据验证结果和系统策略决定是否允许加载。\n\n### 关键数据结构与变量\n\n- **`sig_enforce`**  \n  全局布尔变量，表示是否强制执行模块签名验证。初始值由 `CONFIG_MODULE_SIG_FORCE` 决定，可通过内核命令行参数 `module.sig_enforce=1` 或运行时调用 `set_module_sig_enforced()` 修改。\n\n- **`module_signature`**  \n  定义在 `<linux/module_signature.h>` 中的结构体，位于模块二进制末尾，包含签名元数据（如签名长度、哈希算法、密钥标识等）。\n\n- **`MODULE_SIG_STRING`**  \n  签名结束标记字符串 `\"~Module signature appended~\\n\"`，用于识别模块是否包含签名。\n\n## 3. 关键实现\n\n### 签名验证流程\n\n1. **签名检测**：  \n   `module_sig_check` 检查模块末尾是否存在 `MODULE_SIG_STRING` 标记。若存在，则认为模块包含签名。\n\n2. **签名解析**：  \n   `mod_verify_sig` 从模块末尾读取 `struct module_signature`，调用 `mod_check_sig()` 验证其格式合法性。\n\n3. **数据截断**：  \n   从模块总长度中扣除签名数据和签名结构体的长度，得到实际代码/数据部分的长度（`info->len` 更新为此值）。\n\n4. **PKCS#7 验证**：  \n   调用 `verify_pkcs7_signature()`，使用内核的 `VERIFY_USE_SECONDARY_KEYRING`（通常为 `.module_signing` 密钥环）验证模块主体的完整性与签名有效性。\n\n### 安全策略处理\n\n- **强制模式（`sig_enforce == true`）**：  \n  任何未签名、密钥不可用或加密算法不支持的模块均被拒绝加载，返回 `-EKEYREJECTED`。\n\n- **非强制模式**：  \n  允许加载未签名模块，但会检查系统是否处于 Lockdown 模式（通过 `security_locked_down(LOCKDOWN_MODULE_SIGNATURE)`）。若处于 Lockdown，则仍拒绝加载。\n\n- **模块篡改防护**：  \n  若加载标志包含 `MODULE_INIT_IGNORE_MODVERSIONS` 或 `MODULE_INIT_IGNORE_VERMAGIC`（即忽略版本魔数或模块版本），则视为“被篡改”的模块，即使有签名也不予验证，防止绕过签名保护。\n\n### 错误分类\n\n- **非致命错误**（仅在非强制模式下可忽略）：\n  - `-ENODATA`：模块未签名\n  - `-ENOPKG`：使用了内核不支持的加密算法\n  - `-ENOKEY`：签名所用公钥不在信任密钥环中\n\n- **致命错误**（无论是否强制均拒绝）：\n  - 内存分配失败、签名格式错误、哈希不匹配等\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/verification.h>`：提供 `verify_pkcs7_signature()` 接口\n  - `<crypto/public_key.h>`：PKCS#7 验证所需的密码学支持\n  - `<linux/module_signature.h>`：定义 `module_signature` 结构\n  - `\"internal.h\"`：模块子系统内部头文件\n\n- **内核配置依赖**：\n  - `CONFIG_MODULE_SIG`：启用模块签名功能\n  - `CONFIG_MODULE_SIG_FORCE`：决定 `sig_enforce` 的默认值\n  - `CONFIG_SECURITY_LOCKDOWN_LSM`：提供 `security_locked_down()` 支持\n\n- **密钥管理依赖**：  \n  依赖内核密钥环服务（Key Retention Service），特别是 `.module_signing` 二级密钥环存储用于验证模块的公钥。\n\n## 5. 使用场景\n\n- **模块加载流程**：  \n  在 `load_module()` 函数中，内核调用 `module_sig_check()` 对待加载模块进行签名验证，是模块安全加载的关键环节。\n\n- **安全启动（Secure Boot）环境**：  \n  当系统启用 UEFI Secure Boot 时，通常会强制启用模块签名（`sig_enforce = true`），确保所有内核模块均来自可信源。\n\n- **内核 Lockdown 模式**：  \n  在 Lockdown 的 `integrity` 或 `confidentiality` 级别下，即使未设置 `CONFIG_MODULE_SIG_FORCE`，也会通过 `security_locked_down()` 阻止未签名模块加载。\n\n- **动态策略调整**：  \n  安全模块（如 Lockdown LSM）可在运行时调用 `set_module_sig_enforced()` 动态提升安全策略，禁止后续未签名模块加载。",
      "similarity": 0.5352270603179932,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/signing.c",
          "start_line": 29,
          "end_line": 118,
          "content": [
            "bool is_module_sig_enforced(void)",
            "{",
            "\treturn sig_enforce;",
            "}",
            "void set_module_sig_enforced(void)",
            "{",
            "\tsig_enforce = true;",
            "}",
            "int mod_verify_sig(const void *mod, struct load_info *info)",
            "{",
            "\tstruct module_signature ms;",
            "\tsize_t sig_len, modlen = info->len;",
            "\tint ret;",
            "",
            "\tpr_devel(\"==>%s(,%zu)\\n\", __func__, modlen);",
            "",
            "\tif (modlen <= sizeof(ms))",
            "\t\treturn -EBADMSG;",
            "",
            "\tmemcpy(&ms, mod + (modlen - sizeof(ms)), sizeof(ms));",
            "",
            "\tret = mod_check_sig(&ms, modlen, \"module\");",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tsig_len = be32_to_cpu(ms.sig_len);",
            "\tmodlen -= sig_len + sizeof(ms);",
            "\tinfo->len = modlen;",
            "",
            "\treturn verify_pkcs7_signature(mod, modlen, mod + modlen, sig_len,",
            "\t\t\t\t      VERIFY_USE_SECONDARY_KEYRING,",
            "\t\t\t\t      VERIFYING_MODULE_SIGNATURE,",
            "\t\t\t\t      NULL, NULL);",
            "}",
            "int module_sig_check(struct load_info *info, int flags)",
            "{",
            "\tint err = -ENODATA;",
            "\tconst unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;",
            "\tconst char *reason;",
            "\tconst void *mod = info->hdr;",
            "\tbool mangled_module = flags & (MODULE_INIT_IGNORE_MODVERSIONS |",
            "\t\t\t\t       MODULE_INIT_IGNORE_VERMAGIC);",
            "\t/*",
            "\t * Do not allow mangled modules as a module with version information",
            "\t * removed is no longer the module that was signed.",
            "\t */",
            "\tif (!mangled_module &&",
            "\t    info->len > markerlen &&",
            "\t    memcmp(mod + info->len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {",
            "\t\t/* We truncate the module to discard the signature */",
            "\t\tinfo->len -= markerlen;",
            "\t\terr = mod_verify_sig(mod, info);",
            "\t\tif (!err) {",
            "\t\t\tinfo->sig_ok = true;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * We don't permit modules to be loaded into the trusted kernels",
            "\t * without a valid signature on them, but if we're not enforcing,",
            "\t * certain errors are non-fatal.",
            "\t */",
            "\tswitch (err) {",
            "\tcase -ENODATA:",
            "\t\treason = \"unsigned module\";",
            "\t\tbreak;",
            "\tcase -ENOPKG:",
            "\t\treason = \"module with unsupported crypto\";",
            "\t\tbreak;",
            "\tcase -ENOKEY:",
            "\t\treason = \"module with unavailable key\";",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\t/*",
            "\t\t * All other errors are fatal, including lack of memory,",
            "\t\t * unparseable signatures, and signature check failures --",
            "\t\t * even if signatures aren't required.",
            "\t\t */",
            "\t\treturn err;",
            "\t}",
            "",
            "\tif (is_module_sig_enforced()) {",
            "\t\tpr_notice(\"Loading of %s is rejected\\n\", reason);",
            "\t\treturn -EKEYREJECTED;",
            "\t}",
            "",
            "\treturn security_locked_down(LOCKDOWN_MODULE_SIGNATURE);",
            "}"
          ],
          "function_name": "is_module_sig_enforced, set_module_sig_enforced, mod_verify_sig, module_sig_check",
          "description": "实现模块签名验证核心逻辑，包含签名状态查询接口、签名验证执行函数以及综合检查入口，通过标记比对与证书验证完成模块签名有效性校验",
          "similarity": 0.4785442352294922
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/signing.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* Module signature checker",
            " *",
            " * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/string.h>",
            "#include <linux/verification.h>",
            "#include <linux/security.h>",
            "#include <crypto/public_key.h>",
            "#include <uapi/linux/module.h>",
            "#include \"internal.h\"",
            "",
            "#undef MODULE_PARAM_PREFIX",
            "#define MODULE_PARAM_PREFIX \"module.\"",
            "",
            "static bool sig_enforce = IS_ENABLED(CONFIG_MODULE_SIG_FORCE);",
            "module_param(sig_enforce, bool_enable_only, 0644);",
            "",
            "/*",
            " * Export sig_enforce kernel cmdline parameter to allow other subsystems rely",
            " * on that instead of directly to CONFIG_MODULE_SIG_FORCE config.",
            " */"
          ],
          "function_name": null,
          "description": "定义sig_enforce全局变量用于控制模块签名强制检查标志位，并注册模块参数供外部配置",
          "similarity": 0.4241240918636322
        }
      ]
    },
    {
      "source_file": "kernel/locking/lockdep_proc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:39:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\lockdep_proc.c`\n\n---\n\n# `locking/lockdep_proc.c` 技术文档\n\n## 1. 文件概述\n\n`lockdep_proc.c` 是 Linux 内核 Lockdep（Lock Dependency）子系统的一部分，负责通过 `/proc` 文件系统暴露锁依赖信息，用于运行时锁正确性验证。该文件实现了两个主要的 `/proc` 接口：\n\n- `/proc/lockdep`：列出所有已注册的锁类（lock classes）及其依赖关系。\n- `/proc/lockdep_stats`：提供锁依赖检测器的统计信息，包括使用情况、依赖数量及调试计数器。\n\n该模块仅在启用 `CONFIG_LOCKDEP`（特别是 `CONFIG_PROVE_LOCKING` 和 `CONFIG_DEBUG_LOCKDEP`）时编译，主要用于内核开发和死锁/竞态条件的调试。\n\n---\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `l_start` / `l_next` / `l_stop` / `l_show` | 实现 `/proc/lockdep` 的 `seq_file` 迭代器，遍历并打印所有锁类信息 |\n| `print_name` | 格式化输出锁类名称，包含版本号和子类信息 |\n| `lc_start` / `lc_next` / `lc_stop` / `lc_show` | （仅当 `CONFIG_PROVE_LOCKING` 启用）实现 `/proc/lockdep_chains` 的迭代器，打印锁链（lock chains）信息 |\n| `lockdep_stats_show` | 输出锁依赖系统的统计信息，如各类锁的使用计数 |\n| `lockdep_stats_debug_show` | （仅当 `CONFIG_DEBUG_LOCKDEP` 启用）输出调试计数器，如中断开关事件、冗余检查等 |\n\n### 数据结构\n\n- **`struct lock_class`**：表示一个锁类，包含锁的使用掩码、依赖关系、名称等。\n- **`struct lock_chain`**：表示一个锁获取序列（锁链），用于记录锁的获取顺序。\n- **`lock_classes`**：全局锁类数组，每个锁实例映射到一个锁类。\n- **`lock_classes_in_use`**：位图，标记哪些锁类索引当前有效。\n- **`max_lock_class_idx`**：当前已分配的最大锁类索引。\n\n### seq_operations 实例\n\n- `lockdep_ops`：用于 `/proc/lockdep`\n- `lockdep_chains_ops`：用于 `/proc/lockdep_chains`（条件编译）\n\n---\n\n## 3. 关键实现\n\n### 安全遍历锁类\n\n由于遍历 `lock_classes` 时不能持有 `lockdep_lock`（避免死锁或性能问题），代码通过以下方式安全迭代：\n\n```c\n#define iterate_lock_classes(idx, class) \\\n\tfor (idx = 0, class = lock_classes; idx <= max_lock_class_idx; idx++, class++)\n```\n\n并结合 `lock_classes_in_use` 位图判断某个索引是否有效，避免访问已释放或未初始化的锁类。\n\n### 锁类信息输出格式\n\n每个锁类在 `/proc/lockdep` 中输出格式如下：\n\n```\n<key_ptr> OPS:<ops_count> FD:<forward_deps> BD:<backward_deps> <usage_flags>: <name>[#version][/subclass]\n -> [<dep_key>] <dep_name>\n ...\n```\n\n- `OPS`：仅在 `CONFIG_DEBUG_LOCKDEP` 下显示，表示该锁类的操作计数。\n- `FD/BD`：前向/后向依赖数量（`CONFIG_PROVE_LOCKING`）。\n- `usage_flags`：如 `..S...` 表示在 softirq 中使用等（由 `get_usage_chars` 生成）。\n- 依赖关系仅显示距离为 1 的直接后继锁。\n\n### 锁链（Lock Chains）遍历\n\n锁链通过 `lock_chains` 数组存储，使用 `lockdep_next_lockchain()` 安全跳过空洞。每个锁链记录：\n\n- `irq_context`：中断上下文类型（hardirq/softirq/组合）\n- 按获取顺序排列的锁类列表\n\n### 统计信息分类\n\n`lockdep_stats_show` 对锁类按使用场景分类统计，例如：\n\n- `nr_irq_safe`：在 IRQ 中安全使用的锁数量（`LOCKF_USED_IN_IRQ`）\n- `nr_irq_unsafe`：在 IRQ 中被禁用的锁（`LOCKF_ENABLED_IRQ`）\n- 同时区分读锁（`_READ` 后缀）和普通锁\n\n并验证 `nr_unused` 与调试计数器 `nr_unused_locks` 一致性（`DEBUG_LOCKS_WARN_ON`）。\n\n---\n\n## 4. 依赖关系\n\n### 头文件依赖\n\n- `lockdep_internals.h`：包含 Lockdep 内部数据结构（`lock_classes`, `lock_chains` 等）\n- `linux/proc_fs.h` 和 `linux/seq_file.h`：实现 `/proc` 接口\n- `linux/debug_locks.h`：调试锁相关宏和计数器\n- `linux/kallsyms.h`：用于符号解析（`__get_key_name`）\n- `asm/div64.h`：64 位除法支持（用于统计计算）\n\n### 配置依赖\n\n- **`CONFIG_LOCKDEP`**：基础锁依赖检测\n- **`CONFIG_PROVE_LOCKING`**：启用锁顺序验证，提供依赖图和锁链\n- **`CONFIG_DEBUG_LOCKDEP`**：启用详细调试计数器和操作追踪\n\n### 与其他模块交互\n\n- 与 `kernel/locking/lockdep.c` 紧密耦合，共享全局锁类和锁链数据结构。\n- 通过 `debug_atomic_read()` 访问原子调试计数器（定义在 `lockdep.c` 中）。\n- 使用 `lockdep_count_forward_deps()` 等辅助函数（定义在 `lockdep.c`）。\n\n---\n\n## 5. 使用场景\n\n### 内核调试与死锁分析\n\n- 开发者通过 `cat /proc/lockdep` 查看所有锁类及其依赖关系，识别潜在的锁顺序冲突。\n- 通过 `/proc/lockdep_stats` 评估锁使用模式，例如是否在中断上下文中不当使用锁。\n- 在触发 Lockdep 警告（如“possible circular locking dependency”）后，结合 `/proc/lockdep` 分析依赖路径。\n\n### 性能与资源监控\n\n- 统计锁类数量、依赖数量，帮助评估 Lockdep 内存开销。\n- 调试计数器（如 `chain_lookup_hits/misses`）可用于优化 Lockdep 内部哈希表性能。\n\n### 自动化测试\n\n- 内核测试框架（如 KUnit、LKFT）可解析 `/proc/lockdep_stats` 验证锁行为是否符合预期。\n- 在回归测试中监控 `nr_unused` 或 `redundant_checks` 变化，检测锁使用异常。\n\n> **注意**：这些 `/proc` 接口仅在启用 Lockdep 的调试内核中存在，生产环境通常关闭以避免性能开销。",
      "similarity": 0.5254517793655396,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/lockdep_proc.c",
          "start_line": 231,
          "end_line": 392,
          "content": [
            "static int lockdep_stats_show(struct seq_file *m, void *v)",
            "{",
            "\tunsigned long nr_unused = 0, nr_uncategorized = 0,",
            "\t\t      nr_irq_safe = 0, nr_irq_unsafe = 0,",
            "\t\t      nr_softirq_safe = 0, nr_softirq_unsafe = 0,",
            "\t\t      nr_hardirq_safe = 0, nr_hardirq_unsafe = 0,",
            "\t\t      nr_irq_read_safe = 0, nr_irq_read_unsafe = 0,",
            "\t\t      nr_softirq_read_safe = 0, nr_softirq_read_unsafe = 0,",
            "\t\t      nr_hardirq_read_safe = 0, nr_hardirq_read_unsafe = 0,",
            "\t\t      sum_forward_deps = 0;",
            "",
            "#ifdef CONFIG_PROVE_LOCKING",
            "\tstruct lock_class *class;",
            "\tunsigned long idx;",
            "",
            "\titerate_lock_classes(idx, class) {",
            "\t\tif (!test_bit(idx, lock_classes_in_use))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (class->usage_mask == 0)",
            "\t\t\tnr_unused++;",
            "\t\tif (class->usage_mask == LOCKF_USED)",
            "\t\t\tnr_uncategorized++;",
            "\t\tif (class->usage_mask & LOCKF_USED_IN_IRQ)",
            "\t\t\tnr_irq_safe++;",
            "\t\tif (class->usage_mask & LOCKF_ENABLED_IRQ)",
            "\t\t\tnr_irq_unsafe++;",
            "\t\tif (class->usage_mask & LOCKF_USED_IN_SOFTIRQ)",
            "\t\t\tnr_softirq_safe++;",
            "\t\tif (class->usage_mask & LOCKF_ENABLED_SOFTIRQ)",
            "\t\t\tnr_softirq_unsafe++;",
            "\t\tif (class->usage_mask & LOCKF_USED_IN_HARDIRQ)",
            "\t\t\tnr_hardirq_safe++;",
            "\t\tif (class->usage_mask & LOCKF_ENABLED_HARDIRQ)",
            "\t\t\tnr_hardirq_unsafe++;",
            "\t\tif (class->usage_mask & LOCKF_USED_IN_IRQ_READ)",
            "\t\t\tnr_irq_read_safe++;",
            "\t\tif (class->usage_mask & LOCKF_ENABLED_IRQ_READ)",
            "\t\t\tnr_irq_read_unsafe++;",
            "\t\tif (class->usage_mask & LOCKF_USED_IN_SOFTIRQ_READ)",
            "\t\t\tnr_softirq_read_safe++;",
            "\t\tif (class->usage_mask & LOCKF_ENABLED_SOFTIRQ_READ)",
            "\t\t\tnr_softirq_read_unsafe++;",
            "\t\tif (class->usage_mask & LOCKF_USED_IN_HARDIRQ_READ)",
            "\t\t\tnr_hardirq_read_safe++;",
            "\t\tif (class->usage_mask & LOCKF_ENABLED_HARDIRQ_READ)",
            "\t\t\tnr_hardirq_read_unsafe++;",
            "",
            "\t\tsum_forward_deps += lockdep_count_forward_deps(class);",
            "\t}",
            "",
            "#ifdef CONFIG_DEBUG_LOCKDEP",
            "\tDEBUG_LOCKS_WARN_ON(debug_atomic_read(nr_unused_locks) != nr_unused);",
            "#endif",
            "",
            "#endif",
            "\tseq_printf(m, \" lock-classes:                  %11lu [max: %lu]\\n\",",
            "\t\t\tnr_lock_classes, MAX_LOCKDEP_KEYS);",
            "\tseq_printf(m, \" direct dependencies:           %11lu [max: %lu]\\n\",",
            "\t\t\tnr_list_entries, MAX_LOCKDEP_ENTRIES);",
            "\tseq_printf(m, \" indirect dependencies:         %11lu\\n\",",
            "\t\t\tsum_forward_deps);",
            "",
            "\t/*",
            "\t * Total number of dependencies:",
            "\t *",
            "\t * All irq-safe locks may nest inside irq-unsafe locks,",
            "\t * plus all the other known dependencies:",
            "\t */",
            "\tseq_printf(m, \" all direct dependencies:       %11lu\\n\",",
            "\t\t\tnr_irq_unsafe * nr_irq_safe +",
            "\t\t\tnr_hardirq_unsafe * nr_hardirq_safe +",
            "\t\t\tnr_list_entries);",
            "",
            "#ifdef CONFIG_PROVE_LOCKING",
            "\tseq_printf(m, \" dependency chains:             %11lu [max: %lu]\\n\",",
            "\t\t\tlock_chain_count(), MAX_LOCKDEP_CHAINS);",
            "\tseq_printf(m, \" dependency chain hlocks used:  %11lu [max: %lu]\\n\",",
            "\t\t\tMAX_LOCKDEP_CHAIN_HLOCKS -",
            "\t\t\t(nr_free_chain_hlocks + nr_lost_chain_hlocks),",
            "\t\t\tMAX_LOCKDEP_CHAIN_HLOCKS);",
            "\tseq_printf(m, \" dependency chain hlocks lost:  %11u\\n\",",
            "\t\t\tnr_lost_chain_hlocks);",
            "#endif",
            "",
            "#ifdef CONFIG_TRACE_IRQFLAGS",
            "\tseq_printf(m, \" in-hardirq chains:             %11u\\n\",",
            "\t\t\tnr_hardirq_chains);",
            "\tseq_printf(m, \" in-softirq chains:             %11u\\n\",",
            "\t\t\tnr_softirq_chains);",
            "#endif",
            "\tseq_printf(m, \" in-process chains:             %11u\\n\",",
            "\t\t\tnr_process_chains);",
            "\tseq_printf(m, \" stack-trace entries:           %11lu [max: %lu]\\n\",",
            "\t\t\tnr_stack_trace_entries, MAX_STACK_TRACE_ENTRIES);",
            "#if defined(CONFIG_TRACE_IRQFLAGS) && defined(CONFIG_PROVE_LOCKING)",
            "\tseq_printf(m, \" number of stack traces:        %11llu\\n\",",
            "\t\t   lockdep_stack_trace_count());",
            "\tseq_printf(m, \" number of stack hash chains:   %11llu\\n\",",
            "\t\t   lockdep_stack_hash_count());",
            "#endif",
            "\tseq_printf(m, \" combined max dependencies:     %11u\\n\",",
            "\t\t\t(nr_hardirq_chains + 1) *",
            "\t\t\t(nr_softirq_chains + 1) *",
            "\t\t\t(nr_process_chains + 1)",
            "\t);",
            "\tseq_printf(m, \" hardirq-safe locks:            %11lu\\n\",",
            "\t\t\tnr_hardirq_safe);",
            "\tseq_printf(m, \" hardirq-unsafe locks:          %11lu\\n\",",
            "\t\t\tnr_hardirq_unsafe);",
            "\tseq_printf(m, \" softirq-safe locks:            %11lu\\n\",",
            "\t\t\tnr_softirq_safe);",
            "\tseq_printf(m, \" softirq-unsafe locks:          %11lu\\n\",",
            "\t\t\tnr_softirq_unsafe);",
            "\tseq_printf(m, \" irq-safe locks:                %11lu\\n\",",
            "\t\t\tnr_irq_safe);",
            "\tseq_printf(m, \" irq-unsafe locks:              %11lu\\n\",",
            "\t\t\tnr_irq_unsafe);",
            "",
            "\tseq_printf(m, \" hardirq-read-safe locks:       %11lu\\n\",",
            "\t\t\tnr_hardirq_read_safe);",
            "\tseq_printf(m, \" hardirq-read-unsafe locks:     %11lu\\n\",",
            "\t\t\tnr_hardirq_read_unsafe);",
            "\tseq_printf(m, \" softirq-read-safe locks:       %11lu\\n\",",
            "\t\t\tnr_softirq_read_safe);",
            "\tseq_printf(m, \" softirq-read-unsafe locks:     %11lu\\n\",",
            "\t\t\tnr_softirq_read_unsafe);",
            "\tseq_printf(m, \" irq-read-safe locks:           %11lu\\n\",",
            "\t\t\tnr_irq_read_safe);",
            "\tseq_printf(m, \" irq-read-unsafe locks:         %11lu\\n\",",
            "\t\t\tnr_irq_read_unsafe);",
            "",
            "\tseq_printf(m, \" uncategorized locks:           %11lu\\n\",",
            "\t\t\tnr_uncategorized);",
            "\tseq_printf(m, \" unused locks:                  %11lu\\n\",",
            "\t\t\tnr_unused);",
            "\tseq_printf(m, \" max locking depth:             %11u\\n\",",
            "\t\t\tmax_lockdep_depth);",
            "#ifdef CONFIG_PROVE_LOCKING",
            "\tseq_printf(m, \" max bfs queue depth:           %11u\\n\",",
            "\t\t\tmax_bfs_queue_depth);",
            "#endif",
            "\tseq_printf(m, \" max lock class index:          %11lu\\n\",",
            "\t\t\tmax_lock_class_idx);",
            "\tlockdep_stats_debug_show(m);",
            "\tseq_printf(m, \" debug_locks:                   %11u\\n\",",
            "\t\t\tdebug_locks);",
            "",
            "\t/*",
            "\t * Zapped classes and lockdep data buffers reuse statistics.",
            "\t */",
            "\tseq_puts(m, \"\\n\");",
            "\tseq_printf(m, \" zapped classes:                %11lu\\n\",",
            "\t\t\tnr_zapped_classes);",
            "#ifdef CONFIG_PROVE_LOCKING",
            "\tseq_printf(m, \" zapped lock chains:            %11lu\\n\",",
            "\t\t\tnr_zapped_lock_chains);",
            "\tseq_printf(m, \" large chain blocks:            %11u\\n\",",
            "\t\t\tnr_large_chain_blocks);",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "lockdep_stats_show",
          "description": "实现锁使用统计信息收集与展示，统计各类中断上下文下的锁使用情况及依赖项数量",
          "similarity": 0.5473699569702148
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/locking/lockdep_proc.c",
          "start_line": 570,
          "end_line": 671,
          "content": [
            "static void seq_header(struct seq_file *m)",
            "{",
            "\tseq_puts(m, \"lock_stat version 0.4\\n\");",
            "",
            "\tif (unlikely(!debug_locks))",
            "\t\tseq_printf(m, \"*WARNING* lock debugging disabled!! - possibly due to a lockdep warning\\n\");",
            "",
            "\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));",
            "\tseq_printf(m, \"%40s %14s %14s %14s %14s %14s %14s %14s %14s %14s %14s \"",
            "\t\t\t\"%14s %14s\\n\",",
            "\t\t\t\"class name\",",
            "\t\t\t\"con-bounces\",",
            "\t\t\t\"contentions\",",
            "\t\t\t\"waittime-min\",",
            "\t\t\t\"waittime-max\",",
            "\t\t\t\"waittime-total\",",
            "\t\t\t\"waittime-avg\",",
            "\t\t\t\"acq-bounces\",",
            "\t\t\t\"acquisitions\",",
            "\t\t\t\"holdtime-min\",",
            "\t\t\t\"holdtime-max\",",
            "\t\t\t\"holdtime-total\",",
            "\t\t\t\"holdtime-avg\");",
            "\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));",
            "\tseq_printf(m, \"\\n\");",
            "}",
            "static void ls_stop(struct seq_file *m, void *v)",
            "{",
            "}",
            "static int ls_show(struct seq_file *m, void *v)",
            "{",
            "\tif (v == SEQ_START_TOKEN)",
            "\t\tseq_header(m);",
            "\telse",
            "\t\tseq_stats(m, v);",
            "",
            "\treturn 0;",
            "}",
            "static int lock_stat_open(struct inode *inode, struct file *file)",
            "{",
            "\tint res;",
            "\tstruct lock_class *class;",
            "\tstruct lock_stat_seq *data = vmalloc(sizeof(struct lock_stat_seq));",
            "",
            "\tif (!data)",
            "\t\treturn -ENOMEM;",
            "",
            "\tres = seq_open(file, &lockstat_ops);",
            "\tif (!res) {",
            "\t\tstruct lock_stat_data *iter = data->stats;",
            "\t\tstruct seq_file *m = file->private_data;",
            "\t\tunsigned long idx;",
            "",
            "\t\titerate_lock_classes(idx, class) {",
            "\t\t\tif (!test_bit(idx, lock_classes_in_use))",
            "\t\t\t\tcontinue;",
            "\t\t\titer->class = class;",
            "\t\t\titer->stats = lock_stats(class);",
            "\t\t\titer++;",
            "\t\t}",
            "",
            "\t\tdata->iter_end = iter;",
            "",
            "\t\tsort(data->stats, data->iter_end - data->stats,",
            "\t\t\t\tsizeof(struct lock_stat_data),",
            "\t\t\t\tlock_stat_cmp, NULL);",
            "",
            "\t\tm->private = data;",
            "\t} else",
            "\t\tvfree(data);",
            "",
            "\treturn res;",
            "}",
            "static ssize_t lock_stat_write(struct file *file, const char __user *buf,",
            "\t\t\t       size_t count, loff_t *ppos)",
            "{",
            "\tstruct lock_class *class;",
            "\tunsigned long idx;",
            "\tchar c;",
            "",
            "\tif (count) {",
            "\t\tif (get_user(c, buf))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (c != '0')",
            "\t\t\treturn count;",
            "",
            "\t\titerate_lock_classes(idx, class) {",
            "\t\t\tif (!test_bit(idx, lock_classes_in_use))",
            "\t\t\t\tcontinue;",
            "\t\t\tclear_lock_stats(class);",
            "\t\t}",
            "\t}",
            "\treturn count;",
            "}",
            "static int lock_stat_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "",
            "\tvfree(seq->private);",
            "\treturn seq_release(inode, file);",
            "}"
          ],
          "function_name": "seq_header, ls_stop, ls_show, lock_stat_open, lock_stat_write, lock_stat_release",
          "description": "实现锁统计接口的文件操作管理，包含数据初始化、排序、清零操作及统计信息展示逻辑",
          "similarity": 0.4930282235145569
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/locking/lockdep_proc.c",
          "start_line": 409,
          "end_line": 563,
          "content": [
            "static int lock_stat_cmp(const void *l, const void *r)",
            "{",
            "\tconst struct lock_stat_data *dl = l, *dr = r;",
            "\tunsigned long nl, nr;",
            "",
            "\tnl = dl->stats.read_waittime.nr + dl->stats.write_waittime.nr;",
            "\tnr = dr->stats.read_waittime.nr + dr->stats.write_waittime.nr;",
            "",
            "\treturn nr - nl;",
            "}",
            "static void seq_line(struct seq_file *m, char c, int offset, int length)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < offset; i++)",
            "\t\tseq_puts(m, \" \");",
            "\tfor (i = 0; i < length; i++)",
            "\t\tseq_printf(m, \"%c\", c);",
            "\tseq_puts(m, \"\\n\");",
            "}",
            "static void snprint_time(char *buf, size_t bufsiz, s64 nr)",
            "{",
            "\ts64 div;",
            "\ts32 rem;",
            "",
            "\tnr += 5; /* for display rounding */",
            "\tdiv = div_s64_rem(nr, 1000, &rem);",
            "\tsnprintf(buf, bufsiz, \"%lld.%02d\", (long long)div, (int)rem/10);",
            "}",
            "static void seq_time(struct seq_file *m, s64 time)",
            "{",
            "\tchar num[15];",
            "",
            "\tsnprint_time(num, sizeof(num), time);",
            "\tseq_printf(m, \" %14s\", num);",
            "}",
            "static void seq_lock_time(struct seq_file *m, struct lock_time *lt)",
            "{",
            "\tseq_printf(m, \"%14lu\", lt->nr);",
            "\tseq_time(m, lt->min);",
            "\tseq_time(m, lt->max);",
            "\tseq_time(m, lt->total);",
            "\tseq_time(m, lt->nr ? div64_u64(lt->total, lt->nr) : 0);",
            "}",
            "static void seq_stats(struct seq_file *m, struct lock_stat_data *data)",
            "{",
            "\tconst struct lockdep_subclass_key *ckey;",
            "\tstruct lock_class_stats *stats;",
            "\tstruct lock_class *class;",
            "\tconst char *cname;",
            "\tint i, namelen;",
            "\tchar name[39];",
            "",
            "\tclass = data->class;",
            "\tstats = &data->stats;",
            "",
            "\tnamelen = 38;",
            "\tif (class->name_version > 1)",
            "\t\tnamelen -= 2; /* XXX truncates versions > 9 */",
            "\tif (class->subclass)",
            "\t\tnamelen -= 2;",
            "",
            "\trcu_read_lock_sched();",
            "\tcname = rcu_dereference_sched(class->name);",
            "\tckey  = rcu_dereference_sched(class->key);",
            "",
            "\tif (!cname && !ckey) {",
            "\t\trcu_read_unlock_sched();",
            "\t\treturn;",
            "",
            "\t} else if (!cname) {",
            "\t\tchar str[KSYM_NAME_LEN];",
            "\t\tconst char *key_name;",
            "",
            "\t\tkey_name = __get_key_name(ckey, str);",
            "\t\tsnprintf(name, namelen, \"%s\", key_name);",
            "\t} else {",
            "\t\tsnprintf(name, namelen, \"%s\", cname);",
            "\t}",
            "\trcu_read_unlock_sched();",
            "",
            "\tnamelen = strlen(name);",
            "\tif (class->name_version > 1) {",
            "\t\tsnprintf(name+namelen, 3, \"#%d\", class->name_version);",
            "\t\tnamelen += 2;",
            "\t}",
            "\tif (class->subclass) {",
            "\t\tsnprintf(name+namelen, 3, \"/%d\", class->subclass);",
            "\t\tnamelen += 2;",
            "\t}",
            "",
            "\tif (stats->write_holdtime.nr) {",
            "\t\tif (stats->read_holdtime.nr)",
            "\t\t\tseq_printf(m, \"%38s-W:\", name);",
            "\t\telse",
            "\t\t\tseq_printf(m, \"%40s:\", name);",
            "",
            "\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_write]);",
            "\t\tseq_lock_time(m, &stats->write_waittime);",
            "\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_write]);",
            "\t\tseq_lock_time(m, &stats->write_holdtime);",
            "\t\tseq_puts(m, \"\\n\");",
            "\t}",
            "",
            "\tif (stats->read_holdtime.nr) {",
            "\t\tseq_printf(m, \"%38s-R:\", name);",
            "\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_read]);",
            "\t\tseq_lock_time(m, &stats->read_waittime);",
            "\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_read]);",
            "\t\tseq_lock_time(m, &stats->read_holdtime);",
            "\t\tseq_puts(m, \"\\n\");",
            "\t}",
            "",
            "\tif (stats->read_waittime.nr + stats->write_waittime.nr == 0)",
            "\t\treturn;",
            "",
            "\tif (stats->read_holdtime.nr)",
            "\t\tnamelen += 2;",
            "",
            "\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {",
            "\t\tchar ip[32];",
            "",
            "\t\tif (class->contention_point[i] == 0)",
            "\t\t\tbreak;",
            "",
            "\t\tif (!i)",
            "\t\t\tseq_line(m, '-', 40-namelen, namelen);",
            "",
            "\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",",
            "\t\t\t\t(void *)class->contention_point[i]);",
            "\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",",
            "\t\t\t   name, stats->contention_point[i],",
            "\t\t\t   ip, (void *)class->contention_point[i]);",
            "\t}",
            "\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {",
            "\t\tchar ip[32];",
            "",
            "\t\tif (class->contending_point[i] == 0)",
            "\t\t\tbreak;",
            "",
            "\t\tif (!i)",
            "\t\t\tseq_line(m, '-', 40-namelen, namelen);",
            "",
            "\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",",
            "\t\t\t\t(void *)class->contending_point[i]);",
            "\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",",
            "\t\t\t   name, stats->contending_point[i],",
            "\t\t\t   ip, (void *)class->contending_point[i]);",
            "\t}",
            "\tif (i) {",
            "\t\tseq_puts(m, \"\\n\");",
            "\t\tseq_line(m, '.', 0, 40 + 1 + 12 * (14 + 1));",
            "\t\tseq_puts(m, \"\\n\");",
            "\t}",
            "}"
          ],
          "function_name": "lock_stat_cmp, seq_line, snprint_time, seq_time, seq_lock_time, seq_stats",
          "description": "实现锁性能统计信息的格式化输出，包含等待时间、持有时间、争用点及调用栈信息展示",
          "similarity": 0.48412275314331055
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/lockdep_proc.c",
          "start_line": 56,
          "end_line": 191,
          "content": [
            "static void l_stop(struct seq_file *m, void *v)",
            "{",
            "}",
            "static void print_name(struct seq_file *m, struct lock_class *class)",
            "{",
            "\tchar str[KSYM_NAME_LEN];",
            "\tconst char *name = class->name;",
            "",
            "\tif (!name) {",
            "\t\tname = __get_key_name(class->key, str);",
            "\t\tseq_printf(m, \"%s\", name);",
            "\t} else{",
            "\t\tseq_printf(m, \"%s\", name);",
            "\t\tif (class->name_version > 1)",
            "\t\t\tseq_printf(m, \"#%d\", class->name_version);",
            "\t\tif (class->subclass)",
            "\t\t\tseq_printf(m, \"/%d\", class->subclass);",
            "\t}",
            "}",
            "static int l_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct lock_class *class = v;",
            "\tstruct lock_list *entry;",
            "\tchar usage[LOCK_USAGE_CHARS];",
            "\tint idx = class - lock_classes;",
            "",
            "\tif (v == lock_classes)",
            "\t\tseq_printf(m, \"all lock classes:\\n\");",
            "",
            "\tif (!test_bit(idx, lock_classes_in_use))",
            "\t\treturn 0;",
            "",
            "\tseq_printf(m, \"%p\", class->key);",
            "#ifdef CONFIG_DEBUG_LOCKDEP",
            "\tseq_printf(m, \" OPS:%8ld\", debug_class_ops_read(class));",
            "#endif",
            "\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {",
            "\t\tseq_printf(m, \" FD:%5ld\", lockdep_count_forward_deps(class));",
            "\t\tseq_printf(m, \" BD:%5ld\", lockdep_count_backward_deps(class));",
            "",
            "\t\tget_usage_chars(class, usage);",
            "\t\tseq_printf(m, \" %s\", usage);",
            "\t}",
            "",
            "\tseq_printf(m, \": \");",
            "\tprint_name(m, class);",
            "\tseq_puts(m, \"\\n\");",
            "",
            "\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {",
            "\t\tlist_for_each_entry(entry, &class->locks_after, entry) {",
            "\t\t\tif (entry->distance == 1) {",
            "\t\t\t\tseq_printf(m, \" -> [%p] \", entry->class->key);",
            "\t\t\t\tprint_name(m, entry->class);",
            "\t\t\t\tseq_puts(m, \"\\n\");",
            "\t\t\t}",
            "\t\t}",
            "\t\tseq_puts(m, \"\\n\");",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void lc_stop(struct seq_file *m, void *v)",
            "{",
            "}",
            "static int lc_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct lock_chain *chain = v;",
            "\tstruct lock_class *class;",
            "\tint i;",
            "\tstatic const char * const irq_strs[] = {",
            "\t\t[0]\t\t\t     = \"0\",",
            "\t\t[LOCK_CHAIN_HARDIRQ_CONTEXT] = \"hardirq\",",
            "\t\t[LOCK_CHAIN_SOFTIRQ_CONTEXT] = \"softirq\",",
            "\t\t[LOCK_CHAIN_SOFTIRQ_CONTEXT|",
            "\t\t LOCK_CHAIN_HARDIRQ_CONTEXT] = \"hardirq|softirq\",",
            "\t};",
            "",
            "\tif (v == SEQ_START_TOKEN) {",
            "\t\tif (!nr_free_chain_hlocks)",
            "\t\t\tseq_printf(m, \"(buggered) \");",
            "\t\tseq_printf(m, \"all lock chains:\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tseq_printf(m, \"irq_context: %s\\n\", irq_strs[chain->irq_context]);",
            "",
            "\tfor (i = 0; i < chain->depth; i++) {",
            "\t\tclass = lock_chain_get_class(chain, i);",
            "\t\tif (!class->key)",
            "\t\t\tcontinue;",
            "",
            "\t\tseq_printf(m, \"[%p] \", class->key);",
            "\t\tprint_name(m, class);",
            "\t\tseq_puts(m, \"\\n\");",
            "\t}",
            "\tseq_puts(m, \"\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static void lockdep_stats_debug_show(struct seq_file *m)",
            "{",
            "#ifdef CONFIG_DEBUG_LOCKDEP",
            "\tunsigned long long hi1 = debug_atomic_read(hardirqs_on_events),",
            "\t\t\t   hi2 = debug_atomic_read(hardirqs_off_events),",
            "\t\t\t   hr1 = debug_atomic_read(redundant_hardirqs_on),",
            "\t\t\t   hr2 = debug_atomic_read(redundant_hardirqs_off),",
            "\t\t\t   si1 = debug_atomic_read(softirqs_on_events),",
            "\t\t\t   si2 = debug_atomic_read(softirqs_off_events),",
            "\t\t\t   sr1 = debug_atomic_read(redundant_softirqs_on),",
            "\t\t\t   sr2 = debug_atomic_read(redundant_softirqs_off);",
            "",
            "\tseq_printf(m, \" chain lookup misses:           %11llu\\n\",",
            "\t\tdebug_atomic_read(chain_lookup_misses));",
            "\tseq_printf(m, \" chain lookup hits:             %11llu\\n\",",
            "\t\tdebug_atomic_read(chain_lookup_hits));",
            "\tseq_printf(m, \" cyclic checks:                 %11llu\\n\",",
            "\t\tdebug_atomic_read(nr_cyclic_checks));",
            "\tseq_printf(m, \" redundant checks:              %11llu\\n\",",
            "\t\tdebug_atomic_read(nr_redundant_checks));",
            "\tseq_printf(m, \" redundant links:               %11llu\\n\",",
            "\t\tdebug_atomic_read(nr_redundant));",
            "\tseq_printf(m, \" find-mask forwards checks:     %11llu\\n\",",
            "\t\tdebug_atomic_read(nr_find_usage_forwards_checks));",
            "\tseq_printf(m, \" find-mask backwards checks:    %11llu\\n\",",
            "\t\tdebug_atomic_read(nr_find_usage_backwards_checks));",
            "",
            "\tseq_printf(m, \" hardirq on events:             %11llu\\n\", hi1);",
            "\tseq_printf(m, \" hardirq off events:            %11llu\\n\", hi2);",
            "\tseq_printf(m, \" redundant hardirq ons:         %11llu\\n\", hr1);",
            "\tseq_printf(m, \" redundant hardirq offs:        %11llu\\n\", hr2);",
            "\tseq_printf(m, \" softirq on events:             %11llu\\n\", si1);",
            "\tseq_printf(m, \" softirq off events:            %11llu\\n\", si2);",
            "\tseq_printf(m, \" redundant softirq ons:         %11llu\\n\", sr1);",
            "\tseq_printf(m, \" redundant softirq offs:        %11llu\\n\", sr2);",
            "#endif",
            "}"
          ],
          "function_name": "l_stop, print_name, l_show, lc_stop, lc_show, lockdep_stats_debug_show",
          "description": "实现/proc/lockdep接口的数据展示逻辑，包括锁类信息、锁链信息及调试统计信息的格式化输出",
          "similarity": 0.47815394401550293
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/lockdep_proc.c",
          "start_line": 1,
          "end_line": 55,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * kernel/lockdep_proc.c",
            " *",
            " * Runtime locking correctness validator",
            " *",
            " * Started by Ingo Molnar:",
            " *",
            " *  Copyright (C) 2006,2007 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>",
            " *  Copyright (C) 2007 Red Hat, Inc., Peter Zijlstra",
            " *",
            " * Code for /proc/lockdep and /proc/lockdep_stats:",
            " *",
            " */",
            "#include <linux/export.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sort.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/div64.h>",
            "",
            "#include \"lockdep_internals.h\"",
            "",
            "/*",
            " * Since iteration of lock_classes is done without holding the lockdep lock,",
            " * it is not safe to iterate all_lock_classes list directly as the iteration",
            " * may branch off to free_lock_classes or the zapped list. Iteration is done",
            " * directly on the lock_classes array by checking the lock_classes_in_use",
            " * bitmap and max_lock_class_idx.",
            " */",
            "#define iterate_lock_classes(idx, class)\t\t\t\t\\",
            "\tfor (idx = 0, class = lock_classes; idx <= max_lock_class_idx;\t\\",
            "\t     idx++, class++)",
            "",
            "static void *l_next(struct seq_file *m, void *v, loff_t *pos)",
            "{",
            "\tstruct lock_class *class = v;",
            "",
            "\t++class;",
            "\t*pos = class - lock_classes;",
            "\treturn (*pos > max_lock_class_idx) ? NULL : class;",
            "}",
            "",
            "static void *l_start(struct seq_file *m, loff_t *pos)",
            "{",
            "\tunsigned long idx = *pos;",
            "",
            "\tif (idx > max_lock_class_idx)",
            "\t\treturn NULL;",
            "\treturn lock_classes + idx;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用于遍历锁类的迭代器宏及序列化接口函数，提供/proc/lockdep和/proc/lockdep_stats的遍历基础",
          "similarity": 0.4590874910354614
        }
      ]
    }
  ]
}