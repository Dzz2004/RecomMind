{
  "query": "Linux内核文件访问控制机制实现",
  "timestamp": "2025-12-26 00:19:14",
  "retrieved_files": [
    {
      "source_file": "kernel/pid_sysctl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_sysctl.h`\n\n---\n\n# `pid_sysctl.h` 技术文档\n\n## 1. 文件概述\n\n`pid_sysctl.h` 是 Linux 内核中用于定义与 PID 命名空间（`pid_namespace`）相关的系统控制（sysctl）接口的头文件。其核心功能是提供对 `memfd_noexec` 系统策略的运行时配置支持，该策略用于控制通过 `memfd_create()` 创建的内存文件是否允许执行代码。该配置具有层级继承语义：子 PID 命名空间的策略不能比其父命名空间更宽松，以确保安全策略的向下兼容性和强制性。\n\n## 2. 核心功能\n\n### 函数\n\n- **`pid_mfd_noexec_dointvec_minmax`**  \n  自定义的 sysctl 处理函数，用于读写 `memfd_noexec` 策略值。在写入时执行权限检查和策略继承约束验证。\n\n- **`register_pid_ns_sysctl_table_vm`**  \n  内联函数，用于向内核 sysctl 子系统注册 `vm.memfd_noexec` 控制项（仅在 `CONFIG_SYSCTL` 和 `CONFIG_MEMFD_CREATE` 同时启用时有效）。\n\n### 数据结构\n\n- **`pid_ns_ctl_table_vm`**  \n  `ctl_table` 类型的静态数组，定义了 `vm.memfd_noexec` sysctl 条目，包括其名称、数据指针、访问权限、处理函数及取值范围（0 到 2）。\n\n## 3. 关键实现\n\n- **权限控制**：  \n  在写入 `memfd_noexec` 值时，调用 `ns_capable(ns->user_ns, CAP_SYS_ADMIN)` 检查当前任务是否在对应用户命名空间中拥有 `CAP_SYS_ADMIN` 能力，防止非特权用户修改安全策略。\n\n- **策略继承约束**：  \n  通过 `pidns_memfd_noexec_scope(ns->parent)` 获取父 PID 命名空间的策略值 `parent_scope`，并确保当前命名空间的策略值 `scope` 不小于父策略（即不能更宽松）。实际写入前使用 `max(READ_ONCE(ns->memfd_noexec_scope), parent_scope)` 保证该约束。\n\n- **原子读写**：  \n  使用 `READ_ONCE()` 和 `WRITE_ONCE()` 对 `ns->memfd_noexec_scope` 进行访问，确保在并发环境下内存访问的可见性和顺序性。\n\n- **sysctl 注册**：  \n  通过 `register_sysctl(\"vm\", pid_ns_ctl_table_vm)` 将控制项注册到 `/proc/sys/vm/memfd_noexec` 路径下，供用户空间通过标准 sysctl 接口访问。\n\n- **条件编译**：  \n  整个功能仅在 `CONFIG_SYSCTL`（启用 sysctl 支持）和 `CONFIG_MEMFD_CREATE`（启用 memfd_create 系统调用）同时配置时编译，否则 `register_pid_ns_sysctl_table_vm` 为空内联函数，避免代码膨胀。\n\n## 4. 依赖关系\n\n- **`<linux/pid_namespace.h>`**：  \n  提供 `struct pid_namespace` 定义及辅助函数如 `task_active_pid_ns()` 和 `pidns_memfd_noexec_scope()`。\n\n- **`CONFIG_SYSCTL`**：  \n  内核配置选项，启用 sysctl 框架支持，提供 `register_sysctl`、`proc_dointvec_minmax` 等接口。\n\n- **`CONFIG_MEMFD_CREATE`**：  \n  内核配置选项，启用 `memfd_create()` 系统调用及相关功能（如 `memfd_noexec_scope` 字段）。\n\n- **能力子系统（Capabilities）**：  \n  依赖 `ns_capable()` 进行命名空间感知的权限检查。\n\n## 5. 使用场景\n\n- **安全策略配置**：  \n  系统管理员或容器运行时可通过写入 `/proc/sys/vm/memfd_noexec` 设置当前 PID 命名空间中 `memfd` 文件的执行限制级别（0=允许执行，1=禁止执行但可覆盖，2=严格禁止执行），用于防御基于内存文件的代码注入攻击。\n\n- **容器隔离**：  \n  在容器化环境中，不同容器运行在独立的 PID 命名空间中。父命名空间（如宿主机）可设置较严格的 `memfd_noexec` 策略，子容器无法降低该策略级别，从而实现自上而下的安全策略强制。\n\n- **运行时动态调整**：  \n  允许在系统运行期间动态调整 `memfd` 执行策略，无需重启或重新加载内核模块，提升系统灵活性与安全性。",
      "similarity": 0.669451117515564,
      "chunks": []
    },
    {
      "source_file": "kernel/locking/spinlock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:53:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\spinlock.c`\n\n---\n\n# `locking/spinlock.c` 技术文档\n\n## 1. 文件概述\n\n`locking/spinlock.c` 是 Linux 内核中实现自旋锁（spinlock）和读写锁（rwlock）通用逻辑的核心源文件。该文件主要为对称多处理器（SMP）系统以及启用了锁调试（如 `DEBUG_SPINLOCK` 或 `DEBUG_LOCK_ALLOC`）的配置提供锁操作的通用实现。在单处理器（UP）且未启用调试的配置下，相关操作通常以内联函数形式直接展开，不依赖此文件。\n\n该文件通过宏生成机制构建了多种锁操作函数，包括普通加锁、中断屏蔽加锁、软中断屏蔽加锁等变体，并支持可抢占内核（`CONFIG_PREEMPT`）下的友好调度行为。此外，文件还处理了与内存映射 I/O 写屏障（`CONFIG_MMIOWB`）相关的每 CPU 状态管理。\n\n## 2. 核心功能\n\n### 数据结构\n- `struct mmiowb_state`（条件定义）：用于跟踪每 CPU 的内存映射 I/O 写屏障状态，仅在 `CONFIG_MMIOWB` 启用且架构未提供自有实现时定义。\n  - 全局符号：`DEFINE_PER_CPU(struct mmiowb_state, __mmiowb_state)`，并通过 `EXPORT_PER_CPU_SYMBOL` 导出。\n\n### 主要函数（通过宏生成或显式定义）\n- **自旋锁（spinlock）操作**：\n  - `_raw_spin_lock` / `__raw_spin_lock`\n  - `_raw_spin_lock_irq` / `__raw_spin_lock_irq`\n  - `_raw_spin_lock_irqsave` / `__raw_spin_lock_irqsave`\n  - `_raw_spin_lock_bh` / `__raw_spin_lock_bh`\n  - `_raw_spin_trylock` / `__raw_spin_trylock`\n  - 对应的解锁函数（如 `_raw_spin_unlock` 等）\n\n- **读写锁（rwlock）操作**（非 `PREEMPT_RT` 配置下）：\n  - `_raw_read_lock` / `__raw_read_lock` 等读操作\n  - `_raw_write_lock` / `__raw_write_lock` 等写操作\n  - `_raw_write_lock_nested`：支持锁类嵌套的写锁获取\n\n- **架构相关松弛函数（默认回退）**：\n  - `arch_read_relax`, `arch_write_relax`, `arch_spin_relax`：默认定义为 `cpu_relax()`，允许架构提供特定优化。\n\n## 3. 关键实现\n\n### 锁操作的通用构建机制\n- 使用 `BUILD_LOCK_OPS(op, locktype)` 宏统一生成加锁函数族（`_lock`, `_lock_irqsave`, `_lock_irq`, `_lock_bh`）。\n- 每个加锁函数采用 **“尝试-失败-松弛-重试”** 循环：\n  1. 禁用抢占（`preempt_disable()`）\n  2. 尝试原子获取锁（调用 `do_raw_##op##_trylock`）\n  3. 若成功则退出；否则恢复抢占（`preempt_enable()`）\n  4. 调用架构特定的 `arch_##op##_relax()`（默认为 `cpu_relax()`）以降低 CPU 占用\n- 在 `_irqsave` 和 `_bh` 变体中，正确处理中断和软中断的屏蔽与恢复。\n\n### 可抢占性与调试兼容性\n- 当启用 `CONFIG_DEBUG_LOCK_ALLOC` 或未定义 `CONFIG_GENERIC_LOCKBREAK` 时，**不使用**上述通用构建逻辑，而是依赖头文件（`spinlock_api_smp.h` / `rwlock_api_smp.h`）中的内联实现，以满足锁依赖验证器（lockdep）对中断状态的假设。\n- 在通用构建路径中，循环内显式启用/禁用抢占，使得长时间自旋时当前 CPU 可被抢占，提升系统响应性。\n\n### 函数导出与内联控制\n- 所有 `_raw_*` 函数均通过条件编译（如 `#ifndef CONFIG_INLINE_SPIN_LOCK`）决定是否以内联或 `noinline` 形式定义。\n- 非内联版本使用 `EXPORT_SYMBOL` 导出，供模块或其他编译单元调用。\n- 解锁函数同样受 `CONFIG_UNINLINE_SPIN_UNLOCK` 等配置项控制。\n\n### 嵌套写锁支持\n- `_raw_write_lock_nested` 函数在非调试模式下退化为普通写锁；在调试模式下保留子类参数以支持锁类验证。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/spinlock.h>`：核心锁类型和 API 声明\n  - `<linux/preempt.h>`：抢占控制原语（`preempt_disable/enable`）\n  - `<linux/interrupt.h>`：中断控制（`local_irq_save/restore`, `local_bh_disable`）\n  - `<linux/debug_locks.h>`：调试锁相关宏\n  - `<linux/export.h>`：符号导出宏\n  - `<linux/linkage.h>`：链接属性定义\n\n- **架构依赖**：\n  - 依赖架构层提供底层原子操作（如 `do_raw_spin_trylock` 的实际实现通常在 `arch/*/include/asm/spinlock.h` 中）\n  - 架构可覆盖 `arch_*_relax` 宏以优化自旋行为\n  - 某些架构的性能分析工具（如 `profile_pc`）依赖此文件中函数的栈帧结构稳定性\n\n- **配置依赖**：\n  - `CONFIG_SMP`：SMP 支持是此文件生效的前提\n  - `CONFIG_PREEMPT` / `CONFIG_PREEMPT_RT`：影响锁实现路径选择\n  - `CONFIG_DEBUG_LOCK_ALLOC`：决定是否使用通用构建逻辑\n  - `CONFIG_MMIOWB`：控制每 CPU `mmiowb_state` 的定义\n\n## 5. 使用场景\n\n- **内核同步原语实现**：作为自旋锁和读写锁的通用后端，被内核各子系统（如内存管理、文件系统、设备驱动、网络栈等）广泛用于保护临界区。\n- **中断上下文同步**：通过 `_irq` / `_irqsave` 变体，在中断处理程序与进程上下文之间提供同步。\n- **软中断同步**：通过 `_bh` 变体，防止软中断与进程上下文同时访问共享数据。\n- **实时内核适配**：在 `PREEMPT_RT` 补丁集下，读写锁实现被替换，但自旋锁仍由此文件提供（部分路径被绕过）。\n- **锁调试与验证**：配合 `lockdep` 子系统，在开发和调试阶段检测死锁、锁顺序违规等问题。\n- **性能关键路径**：通过可配置的内联/非内联策略，在代码大小与性能之间取得平衡。",
      "similarity": 0.6517549753189087,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/spinlock.c",
          "start_line": 136,
          "end_line": 239,
          "content": [
            "noinline int __lockfunc _raw_spin_trylock(raw_spinlock_t *lock)",
            "{",
            "\treturn __raw_spin_trylock(lock);",
            "}",
            "noinline int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)",
            "{",
            "\treturn __raw_spin_trylock_bh(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_lock(lock);",
            "}",
            "noinline unsigned long __lockfunc _raw_spin_lock_irqsave(raw_spinlock_t *lock)",
            "{",
            "\treturn __raw_spin_lock_irqsave(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_lock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_lock_bh(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_unlock(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_unlock(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)",
            "{",
            "\t__raw_spin_unlock_irqrestore(lock, flags);",
            "}",
            "noinline void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_unlock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_unlock_bh(lock);",
            "}",
            "noinline int __lockfunc _raw_read_trylock(rwlock_t *lock)",
            "{",
            "\treturn __raw_read_trylock(lock);",
            "}",
            "noinline void __lockfunc _raw_read_lock(rwlock_t *lock)",
            "{",
            "\t__raw_read_lock(lock);",
            "}",
            "noinline unsigned long __lockfunc _raw_read_lock_irqsave(rwlock_t *lock)",
            "{",
            "\treturn __raw_read_lock_irqsave(lock);",
            "}",
            "noinline void __lockfunc _raw_read_lock_irq(rwlock_t *lock)",
            "{",
            "\t__raw_read_lock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_read_lock_bh(rwlock_t *lock)",
            "{",
            "\t__raw_read_lock_bh(lock);",
            "}",
            "noinline void __lockfunc _raw_read_unlock(rwlock_t *lock)",
            "{",
            "\t__raw_read_unlock(lock);",
            "}",
            "noinline void __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)",
            "{",
            "\t__raw_read_unlock_irqrestore(lock, flags);",
            "}",
            "noinline void __lockfunc _raw_read_unlock_irq(rwlock_t *lock)",
            "{",
            "\t__raw_read_unlock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_read_unlock_bh(rwlock_t *lock)",
            "{",
            "\t__raw_read_unlock_bh(lock);",
            "}",
            "noinline int __lockfunc _raw_write_trylock(rwlock_t *lock)",
            "{",
            "\treturn __raw_write_trylock(lock);",
            "}",
            "noinline void __lockfunc _raw_write_lock(rwlock_t *lock)",
            "{",
            "\t__raw_write_lock(lock);",
            "}",
            "void __lockfunc _raw_write_lock_nested(rwlock_t *lock, int subclass)",
            "{",
            "\t__raw_write_lock_nested(lock, subclass);",
            "}",
            "noinline unsigned long __lockfunc _raw_write_lock_irqsave(rwlock_t *lock)",
            "{",
            "\treturn __raw_write_lock_irqsave(lock);",
            "}",
            "noinline void __lockfunc _raw_write_lock_irq(rwlock_t *lock)",
            "{",
            "\t__raw_write_lock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_write_lock_bh(rwlock_t *lock)",
            "{",
            "\t__raw_write_lock_bh(lock);",
            "}",
            "noinline void __lockfunc _raw_write_unlock(rwlock_t *lock)",
            "{",
            "\t__raw_write_unlock(lock);",
            "}"
          ],
          "function_name": "_raw_spin_trylock, _raw_spin_trylock_bh, _raw_spin_lock, _raw_spin_lock_irqsave, _raw_spin_lock_irq, _raw_spin_lock_bh, _raw_spin_unlock, _raw_spin_unlock_irqrestore, _raw_spin_unlock_irq, _raw_spin_unlock_bh, _raw_read_trylock, _raw_read_lock, _raw_read_lock_irqsave, _raw_read_lock_irq, _raw_read_lock_bh, _raw_read_unlock, _raw_read_unlock_irqrestore, _raw_read_unlock_irq, _raw_read_unlock_bh, _raw_write_trylock, _raw_write_lock, _raw_write_lock_nested, _raw_write_lock_irqsave, _raw_write_lock_irq, _raw_write_lock_bh, _raw_write_unlock",
          "description": "实现底层自旋锁和读写锁的具体操作函数，包括尝试加锁、加锁、解锁及其中断/软中断变种，所有函数均调用相应的__raw_*系列内核函数执行实际锁状态变更。",
          "similarity": 0.5444381237030029
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/spinlock.c",
          "start_line": 1,
          "end_line": 135,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (2004) Linus Torvalds",
            " *",
            " * Author: Zwane Mwaikambo <zwane@fsmlabs.com>",
            " *",
            " * Copyright (2004, 2005) Ingo Molnar",
            " *",
            " * This file contains the spinlock/rwlock implementations for the",
            " * SMP and the DEBUG_SPINLOCK cases. (UP-nondebug inlines them)",
            " *",
            " * Note that some architectures have special knowledge about the",
            " * stack frames of these functions in their profile_pc. If you",
            " * change anything significant here that could change the stack",
            " * frame contact the architecture maintainers.",
            " */",
            "",
            "#include <linux/linkage.h>",
            "#include <linux/preempt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/export.h>",
            "",
            "#ifdef CONFIG_MMIOWB",
            "#ifndef arch_mmiowb_state",
            "DEFINE_PER_CPU(struct mmiowb_state, __mmiowb_state);",
            "EXPORT_PER_CPU_SYMBOL(__mmiowb_state);",
            "#endif",
            "#endif",
            "",
            "/*",
            " * If lockdep is enabled then we use the non-preemption spin-ops",
            " * even on CONFIG_PREEMPT, because lockdep assumes that interrupts are",
            " * not re-enabled during lock-acquire (which the preempt-spin-ops do):",
            " */",
            "#if !defined(CONFIG_GENERIC_LOCKBREAK) || defined(CONFIG_DEBUG_LOCK_ALLOC)",
            "/*",
            " * The __lock_function inlines are taken from",
            " * spinlock : include/linux/spinlock_api_smp.h",
            " * rwlock   : include/linux/rwlock_api_smp.h",
            " */",
            "#else",
            "",
            "/*",
            " * Some architectures can relax in favour of the CPU owning the lock.",
            " */",
            "#ifndef arch_read_relax",
            "# define arch_read_relax(l)\tcpu_relax()",
            "#endif",
            "#ifndef arch_write_relax",
            "# define arch_write_relax(l)\tcpu_relax()",
            "#endif",
            "#ifndef arch_spin_relax",
            "# define arch_spin_relax(l)\tcpu_relax()",
            "#endif",
            "",
            "/*",
            " * We build the __lock_function inlines here. They are too large for",
            " * inlining all over the place, but here is only one user per function",
            " * which embeds them into the calling _lock_function below.",
            " *",
            " * This could be a long-held lock. We both prepare to spin for a long",
            " * time (making _this_ CPU preemptible if possible), and we also signal",
            " * towards that other CPU that it should break the lock ASAP.",
            " */",
            "#define BUILD_LOCK_OPS(op, locktype)\t\t\t\t\t\\",
            "void __lockfunc __raw_##op##_lock(locktype##_t *lock)\t\t\t\\",
            "{\t\t\t\t\t\t\t\t\t\\",
            "\tfor (;;) {\t\t\t\t\t\t\t\\",
            "\t\tpreempt_disable();\t\t\t\t\t\\",
            "\t\tif (likely(do_raw_##op##_trylock(lock)))\t\t\\",
            "\t\t\tbreak;\t\t\t\t\t\t\\",
            "\t\tpreempt_enable();\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\t\tarch_##op##_relax(&lock->raw_lock);\t\t\t\\",
            "\t}\t\t\t\t\t\t\t\t\\",
            "}\t\t\t\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "unsigned long __lockfunc __raw_##op##_lock_irqsave(locktype##_t *lock)\t\\",
            "{\t\t\t\t\t\t\t\t\t\\",
            "\tunsigned long flags;\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\tfor (;;) {\t\t\t\t\t\t\t\\",
            "\t\tpreempt_disable();\t\t\t\t\t\\",
            "\t\tlocal_irq_save(flags);\t\t\t\t\t\\",
            "\t\tif (likely(do_raw_##op##_trylock(lock)))\t\t\\",
            "\t\t\tbreak;\t\t\t\t\t\t\\",
            "\t\tlocal_irq_restore(flags);\t\t\t\t\\",
            "\t\tpreempt_enable();\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\t\tarch_##op##_relax(&lock->raw_lock);\t\t\t\\",
            "\t}\t\t\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\treturn flags;\t\t\t\t\t\t\t\\",
            "}\t\t\t\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "void __lockfunc __raw_##op##_lock_irq(locktype##_t *lock)\t\t\\",
            "{\t\t\t\t\t\t\t\t\t\\",
            "\t_raw_##op##_lock_irqsave(lock);\t\t\t\t\t\\",
            "}\t\t\t\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "void __lockfunc __raw_##op##_lock_bh(locktype##_t *lock)\t\t\\",
            "{\t\t\t\t\t\t\t\t\t\\",
            "\tunsigned long flags;\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\t/*\t\t\t\t\t\t\t*/\t\\",
            "\t/* Careful: we must exclude softirqs too, hence the\t*/\t\\",
            "\t/* irq-disabling. We use the generic preemption-aware\t*/\t\\",
            "\t/* function:\t\t\t\t\t\t*/\t\\",
            "\t/**/\t\t\t\t\t\t\t\t\\",
            "\tflags = _raw_##op##_lock_irqsave(lock);\t\t\t\t\\",
            "\tlocal_bh_disable();\t\t\t\t\t\t\\",
            "\tlocal_irq_restore(flags);\t\t\t\t\t\\",
            "}\t\t\t\t\t\t\t\t\t\\",
            "",
            "/*",
            " * Build preemption-friendly versions of the following",
            " * lock-spinning functions:",
            " *",
            " *         __[spin|read|write]_lock()",
            " *         __[spin|read|write]_lock_irq()",
            " *         __[spin|read|write]_lock_irqsave()",
            " *         __[spin|read|write]_lock_bh()",
            " */",
            "BUILD_LOCK_OPS(spin, raw_spinlock);",
            "",
            "#ifndef CONFIG_PREEMPT_RT",
            "BUILD_LOCK_OPS(read, rwlock);",
            "BUILD_LOCK_OPS(write, rwlock);",
            "#endif",
            "",
            "#endif",
            "",
            "#ifndef CONFIG_INLINE_SPIN_TRYLOCK"
          ],
          "function_name": null,
          "description": "定义并生成针对SMP和DEBUG_SPINLOCK的自旋锁及读写锁操作函数，通过宏展开创建多种锁操作接口，支持中断和软中断处理，包含架构特定的放松函数（如cpu_relax）和MMIOWB状态定义。",
          "similarity": 0.5302727818489075
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/spinlock.c",
          "start_line": 348,
          "end_line": 395,
          "content": [
            "noinline void __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)",
            "{",
            "\t__raw_write_unlock_irqrestore(lock, flags);",
            "}",
            "noinline void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)",
            "{",
            "\t__raw_write_unlock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)",
            "{",
            "\t__raw_write_unlock_bh(lock);",
            "}",
            "void __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)",
            "{",
            "\tpreempt_disable();",
            "\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);",
            "\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);",
            "}",
            "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,",
            "\t\t\t\t\t\t   int subclass)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\tpreempt_disable();",
            "\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);",
            "\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);",
            "\treturn flags;",
            "}",
            "void __lockfunc _raw_spin_lock_nest_lock(raw_spinlock_t *lock,",
            "\t\t\t\t     struct lockdep_map *nest_lock)",
            "{",
            "\tpreempt_disable();",
            "\tspin_acquire_nest(&lock->dep_map, 0, 0, nest_lock, _RET_IP_);",
            "\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);",
            "}",
            "notrace int in_lock_functions(unsigned long addr)",
            "{",
            "\t/* Linker adds these: start and end of __lockfunc functions */",
            "\textern char __lock_text_start[], __lock_text_end[];",
            "",
            "\treturn addr >= (unsigned long)__lock_text_start",
            "\t&& addr < (unsigned long)__lock_text_end;",
            "}",
            "void notrace lockdep_assert_in_softirq_func(void)",
            "{",
            "\tlockdep_assert_in_softirq();",
            "}"
          ],
          "function_name": "_raw_write_unlock_irqrestore, _raw_write_unlock_irq, _raw_write_unlock_bh, _raw_spin_lock_nested, _raw_spin_lock_irqsave_nested, _raw_spin_lock_nest_lock, in_lock_functions, lockdep_assert_in_softirq_func",
          "description": "提供嵌套锁操作和锁跟踪辅助函数，包含带子类别的锁获取、锁范围检测函数in_lock_functions，以及确保在软中断上下文的安全性检查函数lockdep_assert_in_softirq_func。",
          "similarity": 0.498962938785553
        }
      ]
    },
    {
      "source_file": "kernel/capability.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:39:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `capability.c`\n\n---\n\n# capability.c 技术文档\n\n## 1. 文件概述\n\n`capability.c` 是 Linux 内核中实现 POSIX 能力（Capabilities）机制的核心文件，位于 `kernel/` 目录下。该文件主要负责提供用户空间与内核之间进行能力获取（`capget`）和设置（`capset`）的系统调用接口，并维护能力模型的版本兼容性、安全策略检查以及与 LSM（Linux Security Module）框架的集成。能力机制允许将传统超级用户权限细分为多个独立的特权单元，从而实现最小权限原则。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `file_caps_enabled`：控制是否启用文件能力（File Capabilities）功能的全局开关，默认启用。可通过内核启动参数 `no_file_caps` 禁用。\n\n### 主要函数\n- **`cap_validate_magic()`**：验证用户传入的能力结构体版本号，支持 v1、v2、v3 版本，并对旧版本发出警告。\n- **`cap_get_target_pid()`**：安全地获取指定进程（通过 PID）的有效（Effective）、可继承（Inheritable）和允许（Permitted）能力集。\n- **`sys_capget()`**：`capget(2)` 系统调用的实现，用于查询指定进程的能力集。\n- **`sys_capset()`**：`capset(2)` 系统调用的实现，用于设置当前进程的能力集（仅限自身）。\n- **`mk_kernel_cap()`**：将用户空间传入的高低 32 位能力值组合成内核内部的 `kernel_cap_t` 类型。\n- **`has_ns_capability()`**（截断）：检查指定任务在给定用户命名空间中是否拥有某项能力（函数体在提供的代码中被截断）。\n\n### 辅助函数\n- `warn_legacy_capability_use()`：对使用 v1（32 位）能力接口的应用程序发出一次性警告。\n- `warn_deprecated_v2()`：对使用已弃用的 v2 能力接口的应用程序发出一次性警告。\n\n## 3. 关键实现\n\n### 能力版本兼容性处理\n- 支持三种能力结构版本：\n  - **v1 (`_LINUX_CAPABILITY_VERSION_1`)**：仅支持 32 位能力（旧版），调用时触发 `warn_legacy_capability_use()`。\n  - **v2 (`_LINUX_CAPABILITY_VERSION_2`)**：支持 64 位能力但存在安全风险，调用时触发 `warn_deprecated_v2()`。\n  - **v3 (`_LINUX_CAPABILITY_VERSION_3`)**：当前推荐版本，功能等同于 v2 但通过头文件变更避免误用。\n- 对于无效版本，内核会尝试将当前支持的版本号写回用户空间并返回 `-EINVAL`。\n\n### 能力数据传输格式\n- 用户空间使用两个 `__user_cap_data_struct` 结构体（`kdata[2]`）来表示 64 位能力值：\n  - `kdata[0]` 存储低 32 位\n  - `kdata[1]` 存储高 32 位\n- 在 `capget` 中，内核能力值被拆分为高低 32 位写入用户缓冲区；在 `capset` 中则反向组合。\n- **向后兼容策略**：当用户空间请求的版本只支持 32 位（`tocopy = 1`）时，内核会静默丢弃高 32 位能力，避免旧版 `libcap` 应用崩溃。\n\n### 安全限制\n- **`capset` 限制**：仅允许进程修改自身能力（`pid` 必须为 0 或当前进程 PID），修改其他进程能力的功能已被移除。\n- **能力设置规则**（由 LSM 实现，如 `security_capset`）：\n  - 新的 **可继承集（I）** 和 **允许集（P）** 只能是旧允许集的子集。\n  - 新的 **有效集（E）** 必须是新允许集的子集。\n- 使用 `prepare_creds()` / `commit_creds()` 机制安全地更新进程凭证（credentials），并在失败时通过 `abort_creds()` 回滚。\n\n### 并发与锁机制\n- 获取**其他进程**能力时，使用 `rcu_read_lock()` 保护对进程链表的访问（通过 `find_task_by_vpid()`）。\n- 获取**当前进程**能力时无需加锁，因为能力修改是原子的（通过凭证替换）。\n\n### 审计与日志\n- `capset` 成功时调用 `audit_log_capset()` 记录能力变更事件，用于安全审计。\n- 对旧版能力接口的使用通过 `pr_info_once()` 发出一次性内核日志警告。\n\n## 4. 依赖关系\n\n- **LSM 框架**：通过 `security_capget()` 和 `security_capset()` 钩子与安全模块（如 SELinux、AppArmor）交互，实际的能力检查和设置策略由 LSM 实现。\n- **凭证子系统**：依赖 `cred` 结构体管理进程权限，使用 `prepare_creds()`、`commit_creds()` 等函数安全更新。\n- **命名空间**：支持用户命名空间（`user_namespace.h`），能力检查与命名空间隔离相关（体现在 `has_ns_capability` 等函数中）。\n- **审计子系统**：通过 `audit.h` 提供能力变更的审计日志。\n- **系统调用接口**：通过 `SYSCALL_DEFINE2` 定义 `capget` 和 `capset` 系统调用。\n- **用户空间访问**：使用 `uaccess.h` 中的 `copy_to_user()` 和 `copy_from_user()` 安全传输数据。\n\n## 5. 使用场景\n\n- **容器与沙箱**：容器运行时（如 Docker、runc）通过 `capset` 限制容器内进程的能力集，实现权限隔离。\n- **特权程序降权**：需要临时提升权限的程序（如 `ping` 使用 `CAP_NET_RAW`）可在执行关键操作后通过 `capset` 丢弃多余能力。\n- **安全策略实施**：系统管理员或安全模块通过限制进程能力，遵循最小权限原则，减少攻击面。\n- **调试与监控**：安全工具（如 `getpcaps`）通过 `capget` 查询进程当前能力状态，用于诊断或合规检查。\n- **文件能力加载**：虽然本文件不直接处理文件能力，但 `file_caps_enabled` 开关控制是否启用基于文件扩展属性（xattr）的能力加载机制（由 `fs/` 子系统实现）。",
      "similarity": 0.6499567627906799,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/capability.c",
          "start_line": 25,
          "end_line": 125,
          "content": [
            "static int __init file_caps_disable(char *str)",
            "{",
            "\tfile_caps_enabled = 0;",
            "\treturn 1;",
            "}",
            "static void warn_legacy_capability_use(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static void warn_deprecated_v2(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)",
            "{",
            "\t__u32 version;",
            "",
            "\tif (get_user(version, &header->version))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (version) {",
            "\tcase _LINUX_CAPABILITY_VERSION_1:",
            "\t\twarn_legacy_capability_use();",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;",
            "\t\tbreak;",
            "\tcase _LINUX_CAPABILITY_VERSION_2:",
            "\t\twarn_deprecated_v2();",
            "\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */",
            "\tcase _LINUX_CAPABILITY_VERSION_3:",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))",
            "\t\t\treturn -EFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,",
            "\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)",
            "{",
            "\tint ret;",
            "",
            "\tif (pid && (pid != task_pid_vnr(current))) {",
            "\t\tconst struct task_struct *target;",
            "",
            "\t\trcu_read_lock();",
            "",
            "\t\ttarget = find_task_by_vpid(pid);",
            "\t\tif (!target)",
            "\t\t\tret = -ESRCH;",
            "\t\telse",
            "\t\t\tret = security_capget(target, pEp, pIp, pPp);",
            "",
            "\t\trcu_read_unlock();",
            "\t} else",
            "\t\tret = security_capget(current, pEp, pIp, pPp);",
            "",
            "\treturn ret;",
            "}",
            "static kernel_cap_t mk_kernel_cap(u32 low, u32 high)",
            "{",
            "\treturn (kernel_cap_t) { (low | ((u64)high << 32)) & CAP_VALID_MASK };",
            "}",
            "bool has_ns_capability(struct task_struct *t,",
            "\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability(t, &init_user_ns, cap);",
            "}",
            "bool has_ns_capability_noaudit(struct task_struct *t,",
            "\t\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability_noaudit(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);",
            "}"
          ],
          "function_name": "file_caps_disable, warn_legacy_capability_use, warn_deprecated_v2, cap_validate_magic, cap_get_target_pid, mk_kernel_cap, has_ns_capability, has_capability, has_ns_capability_noaudit, has_capability_noaudit",
          "description": "提供能力相关辅助函数，包括禁用文件能力标志、版本验证警告、目标进程能力获取及能力结构构建，实现命名空间能力检查和权限验证逻辑",
          "similarity": 0.5733795166015625
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/capability.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/capability.c",
            " *",
            " * Copyright (C) 1997  Andrew Main <zefram@fysh.org>",
            " *",
            " * Integrated into 2.1.97+,  Andrew G. Morgan <morgan@kernel.org>",
            " * 30 May 2002:\tCleanup, Robert M. Love <rml@tech9.net>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/uaccess.h>",
            "",
            "int file_caps_enabled = 1;",
            ""
          ],
          "function_name": null,
          "description": "声明模块许可证并包含必要的头文件，定义控制文件能力启用状态的全局变量file_caps_enabled",
          "similarity": 0.5712803602218628
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/capability.c",
          "start_line": 351,
          "end_line": 424,
          "content": [
            "static bool ns_capable_common(struct user_namespace *ns,",
            "\t\t\t      int cap,",
            "\t\t\t      unsigned int opts)",
            "{",
            "\tint capable;",
            "",
            "\tif (unlikely(!cap_valid(cap))) {",
            "\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);",
            "\t\tBUG();",
            "\t}",
            "",
            "\tcapable = security_capable(current_cred(), ns, cap, opts);",
            "\tif (capable == 0) {",
            "\t\tcurrent->flags |= PF_SUPERPRIV;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "bool ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);",
            "}",
            "bool ns_capable_noaudit(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);",
            "}",
            "bool ns_capable_setid(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);",
            "}",
            "bool capable(int cap)",
            "{",
            "\treturn ns_capable(&init_user_ns, cap);",
            "}",
            "bool file_ns_capable(const struct file *file, struct user_namespace *ns,",
            "\t\t     int cap)",
            "{",
            "",
            "\tif (WARN_ON_ONCE(!cap_valid(cap)))",
            "\t\treturn false;",
            "",
            "\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,",
            "\t\t\t\t struct mnt_idmap *idmap,",
            "\t\t\t\t const struct inode *inode)",
            "{",
            "\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&",
            "\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));",
            "}",
            "bool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,",
            "\t\t\t      const struct inode *inode, int cap)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "",
            "\treturn ns_capable(ns, cap) &&",
            "\t       privileged_wrt_inode_uidgid(ns, idmap, inode);",
            "}",
            "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)",
            "{",
            "\tint ret = 0;  /* An absent tracer adds no restrictions */",
            "\tconst struct cred *cred;",
            "",
            "\trcu_read_lock();",
            "\tcred = rcu_dereference(tsk->ptracer_cred);",
            "\tif (cred)",
            "\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,",
            "\t\t\t\t       CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "\treturn (ret == 0);",
            "}"
          ],
          "function_name": "ns_capable_common, ns_capable, ns_capable_noaudit, ns_capable_setid, capable, file_ns_capable, privileged_wrt_inode_uidgid, capable_wrt_inode_uidgid, ptracer_capable",
          "description": "实现核心能力检查函数，包含通用命名空间能力检测、当前命名空间能力检查、文件能力验证、基于inode UID/GID的特权判断及跟踪者能力检查等功能",
          "similarity": 0.5678902864456177
        }
      ]
    }
  ]
}