{
  "query": "FIFO communication",
  "timestamp": "2025-12-26 01:15:59",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/ringbuf.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:29:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\ringbuf.c`\n\n---\n\n# `bpf/ringbuf.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/ringbuf.c` 实现了 BPF（Berkeley Packet Filter）子系统中的**环形缓冲区（Ring Buffer）**机制，用于在内核与用户空间之间高效、安全地传递数据。该机制支持两种生产者模式：**内核生产者**（如 BPF 程序）和**用户空间生产者**，并提供内存映射（`mmap`）、等待队列通知、并发控制等核心功能，是 BPF 数据输出（如 perf event 替代方案）的关键基础设施。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_ringbuf`**  \n  环形缓冲区的核心结构体，包含：\n  - `waitq`：等待队列，用于通知用户空间有新数据\n  - `work`：IRQ 工作项，用于异步唤醒等待队列\n  - `mask`：环形缓冲区大小掩码（`data_sz - 1`），用于快速取模\n  - `pages` / `nr_pages`：物理页数组，支持双映射\n  - `spinlock`：用于内核生产者的自旋锁（SMP 对齐）\n  - `busy`：原子变量，用于用户空间生产者的互斥访问（避免持有自旋锁过久）\n  - `consumer_pos` / `producer_pos` / `pending_pos`：消费者、生产者和待提交位置（各自独占一页，支持不同 mmap 权限）\n  - `data[]`：实际数据存储区域（页对齐）\n\n- **`struct bpf_ringbuf_map`**  \n  封装标准 `bpf_map`，关联一个 `bpf_ringbuf` 实例。\n\n- **`struct bpf_ringbuf_hdr`**  \n  8 字节记录头，包含：\n  - `len`：记录有效载荷长度\n  - `pg_off`：记录在页内的偏移（用于跨页处理）\n\n### 主要函数\n\n- **`bpf_ringbuf_area_alloc()`**  \n  分配并初始化环形缓冲区的虚拟内存区域，采用**双映射数据页**技术简化环绕处理。\n\n- **`bpf_ringbuf_alloc()`**  \n  初始化 `bpf_ringbuf` 结构体，设置锁、等待队列、IRQ 工作项及初始位置。\n\n- **`bpf_ringbuf_free()`**  \n  释放环形缓冲区占用的虚拟内存和物理页。\n\n- **`ringbuf_map_alloc()`**  \n  BPF map 分配器回调，验证参数并创建 `bpf_ringbuf_map`。\n\n- **`ringbuf_map_free()`**  \n  BPF map 释放器回调，清理资源。\n\n- **`ringbuf_map_*_elem()` / `ringbuf_map_get_next_key()`**  \n  禁用标准 map 操作（返回 `-ENOTSUPP`），因为 ringbuf 不支持键值操作。\n\n- **`bpf_ringbuf_notify()`**  \n  IRQ 工作回调，唤醒所有等待数据的用户进程。\n\n## 3. 关键实现\n\n### 双映射数据页（Double-Mapped Data Pages）\n\n为简化环形缓冲区**环绕（wrap-around）**时的数据读取逻辑，数据页被**连续映射两次**：\n```\n[meta pages][data pages][data pages (same as first copy)]\n```\n当读取跨越缓冲区末尾时，可直接线性读取第二份映射，无需特殊处理。此设计同时适用于内核和用户空间 `mmap`。\n\n### 权限隔离与安全\n\n- **`consumer_pos` 和 `producer_pos` 各占独立页**，允许通过 `mmap` 设置不同权限：\n  - **内核生产者模式**：`producer_pos` 和数据页对用户空间为**只读**，防止篡改。\n  - **用户空间生产者模式**：仅 `consumer_pos` 对用户空间为**只读**，内核需严格验证用户提交的记录。\n\n### 并发控制策略\n\n- **内核生产者**：使用 `raw_spinlock_t` 保证多生产者安全。\n- **用户空间生产者**：使用 `atomic_t busy` 原子变量，避免在 BPF 程序回调期间长期持有 IRQ 自旋锁（可能导致死锁或延迟）。若 `busy` 被占用，`__bpf_user_ringbuf_peek()` 返回 `-EBUSY`。\n\n### 内存布局与对齐\n\n- 非 `mmap` 部分（`waitq` 到 `pending_pos`）大小由 `RINGBUF_PGOFF` 定义。\n- `consumer_pos`、`producer_pos` 和 `data` 均按 `PAGE_SIZE` 对齐，确保可独立映射。\n- 总元数据页数：`RINGBUF_NR_META_PAGES = RINGBUF_PGOFF + 2`（含 consumer/producer 页）。\n\n### 大小限制\n\n- 最大记录大小：`RINGBUF_MAX_RECORD_SZ = UINT_MAX / 4`（约 1GB）。\n- 最大缓冲区大小受 `bpf_ringbuf_hdr.pg_off`（32 位页偏移）限制，理论最大约 **64GB**。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_map` 基础设施（`bpf_map_area_alloc/free`、`bpf_map_init_from_attr`）。\n- **内存管理**：使用 `alloc_pages_node`、`vmap`/`vunmap`、`__free_page` 管理物理页和虚拟映射。\n- **同步机制**：依赖 `wait_queue`、`irq_work`、`raw_spinlock` 和 `atomic_t`。\n- **BTF（BPF Type Format）**：包含 BTF 相关头文件，可能用于未来类型验证（当前未直接使用）。\n- **用户 API**：与 `uapi/linux/bpf.h` 中的 `BPF_F_NUMA_NODE` 等标志交互。\n\n## 5. 使用场景\n\n- **BPF 程序输出数据**：替代 `bpf_perf_event_output()`，提供更低开销、更高吞吐的内核到用户空间数据通道。\n- **用户空间主动提交数据**：允许用户程序通过 ringbuf 向内核提交样本（需内核验证）。\n- **实时监控与追踪**：用于 eBPF 监控工具（如 `bpftrace`、`libbpf` 应用）高效收集内核事件。\n- **NUMA 感知分配**：支持通过 `BPF_F_NUMA_NODE` 标志在指定 NUMA 节点分配内存，优化性能。",
      "similarity": 0.44113051891326904,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/ringbuf.c",
          "start_line": 1,
          "end_line": 149,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/err.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/kmemleak.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#define RINGBUF_CREATE_FLAG_MASK (BPF_F_NUMA_NODE)",
            "",
            "/* non-mmap()'able part of bpf_ringbuf (everything up to consumer page) */",
            "#define RINGBUF_PGOFF \\",
            "\t(offsetof(struct bpf_ringbuf, consumer_pos) >> PAGE_SHIFT)",
            "/* consumer page and producer page */",
            "#define RINGBUF_POS_PAGES 2",
            "#define RINGBUF_NR_META_PAGES (RINGBUF_PGOFF + RINGBUF_POS_PAGES)",
            "",
            "#define RINGBUF_MAX_RECORD_SZ (UINT_MAX/4)",
            "",
            "struct bpf_ringbuf {",
            "\twait_queue_head_t waitq;",
            "\tstruct irq_work work;",
            "\tu64 mask;",
            "\tstruct page **pages;",
            "\tint nr_pages;",
            "\traw_spinlock_t spinlock ____cacheline_aligned_in_smp;",
            "\t/* For user-space producer ring buffers, an atomic_t busy bit is used",
            "\t * to synchronize access to the ring buffers in the kernel, rather than",
            "\t * the spinlock that is used for kernel-producer ring buffers. This is",
            "\t * done because the ring buffer must hold a lock across a BPF program's",
            "\t * callback:",
            "\t *",
            "\t *    __bpf_user_ringbuf_peek() // lock acquired",
            "\t * -> program callback_fn()",
            "\t * -> __bpf_user_ringbuf_sample_release() // lock released",
            "\t *",
            "\t * It is unsafe and incorrect to hold an IRQ spinlock across what could",
            "\t * be a long execution window, so we instead simply disallow concurrent",
            "\t * access to the ring buffer by kernel consumers, and return -EBUSY from",
            "\t * __bpf_user_ringbuf_peek() if the busy bit is held by another task.",
            "\t */",
            "\tatomic_t busy ____cacheline_aligned_in_smp;",
            "\t/* Consumer and producer counters are put into separate pages to",
            "\t * allow each position to be mapped with different permissions.",
            "\t * This prevents a user-space application from modifying the",
            "\t * position and ruining in-kernel tracking. The permissions of the",
            "\t * pages depend on who is producing samples: user-space or the",
            "\t * kernel. Note that the pending counter is placed in the same",
            "\t * page as the producer, so that it shares the same cache line.",
            "\t *",
            "\t * Kernel-producer",
            "\t * ---------------",
            "\t * The producer position and data pages are mapped as r/o in",
            "\t * userspace. For this approach, bits in the header of samples are",
            "\t * used to signal to user-space, and to other producers, whether a",
            "\t * sample is currently being written.",
            "\t *",
            "\t * User-space producer",
            "\t * -------------------",
            "\t * Only the page containing the consumer position is mapped r/o in",
            "\t * user-space. User-space producers also use bits of the header to",
            "\t * communicate to the kernel, but the kernel must carefully check and",
            "\t * validate each sample to ensure that they're correctly formatted, and",
            "\t * fully contained within the ring buffer.",
            "\t */",
            "\tunsigned long consumer_pos __aligned(PAGE_SIZE);",
            "\tunsigned long producer_pos __aligned(PAGE_SIZE);",
            "\tunsigned long pending_pos;",
            "\tchar data[] __aligned(PAGE_SIZE);",
            "};",
            "",
            "struct bpf_ringbuf_map {",
            "\tstruct bpf_map map;",
            "\tstruct bpf_ringbuf *rb;",
            "};",
            "",
            "/* 8-byte ring buffer record header structure */",
            "struct bpf_ringbuf_hdr {",
            "\tu32 len;",
            "\tu32 pg_off;",
            "};",
            "",
            "static struct bpf_ringbuf *bpf_ringbuf_area_alloc(size_t data_sz, int numa_node)",
            "{",
            "\tconst gfp_t flags = GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL |",
            "\t\t\t    __GFP_NOWARN | __GFP_ZERO;",
            "\tint nr_meta_pages = RINGBUF_NR_META_PAGES;",
            "\tint nr_data_pages = data_sz >> PAGE_SHIFT;",
            "\tint nr_pages = nr_meta_pages + nr_data_pages;",
            "\tstruct page **pages, *page;",
            "\tstruct bpf_ringbuf *rb;",
            "\tsize_t array_size;",
            "\tint i;",
            "",
            "\t/* Each data page is mapped twice to allow \"virtual\"",
            "\t * continuous read of samples wrapping around the end of ring",
            "\t * buffer area:",
            "\t * ------------------------------------------------------",
            "\t * | meta pages |  real data pages  |  same data pages  |",
            "\t * ------------------------------------------------------",
            "\t * |            | 1 2 3 4 5 6 7 8 9 | 1 2 3 4 5 6 7 8 9 |",
            "\t * ------------------------------------------------------",
            "\t * |            | TA             DA | TA             DA |",
            "\t * ------------------------------------------------------",
            "\t *                               ^^^^^^^",
            "\t *                                  |",
            "\t * Here, no need to worry about special handling of wrapped-around",
            "\t * data due to double-mapped data pages. This works both in kernel and",
            "\t * when mmap()'ed in user-space, simplifying both kernel and",
            "\t * user-space implementations significantly.",
            "\t */",
            "\tarray_size = (nr_meta_pages + 2 * nr_data_pages) * sizeof(*pages);",
            "\tpages = bpf_map_area_alloc(array_size, numa_node);",
            "\tif (!pages)",
            "\t\treturn NULL;",
            "",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tpage = alloc_pages_node(numa_node, flags, 0);",
            "\t\tif (!page) {",
            "\t\t\tnr_pages = i;",
            "\t\t\tgoto err_free_pages;",
            "\t\t}",
            "\t\tpages[i] = page;",
            "\t\tif (i >= nr_meta_pages)",
            "\t\t\tpages[nr_data_pages + i] = page;",
            "\t}",
            "",
            "\trb = vmap(pages, nr_meta_pages + 2 * nr_data_pages,",
            "\t\t  VM_MAP | VM_USERMAP, PAGE_KERNEL);",
            "\tif (rb) {",
            "\t\tkmemleak_not_leak(pages);",
            "\t\trb->pages = pages;",
            "\t\trb->nr_pages = nr_pages;",
            "\t\treturn rb;",
            "\t}",
            "",
            "err_free_pages:",
            "\tfor (i = 0; i < nr_pages; i++)",
            "\t\t__free_page(pages[i]);",
            "\tbpf_map_area_free(pages);",
            "\treturn NULL;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了bpf_ringbuf结构体及其相关宏，用于管理BPF环形缓冲区的元数据和数据区域。通过页面数组实现环形缓冲区的虚拟连续读取，支持用户态和内核态生产者的差异化权限控制，其中包含消费者/生产者位置指针、忙位原子变量及锁保护的元数据。",
          "similarity": 0.4293738901615143
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/ringbuf.c",
          "start_line": 150,
          "end_line": 258,
          "content": [
            "static void bpf_ringbuf_notify(struct irq_work *work)",
            "{",
            "\tstruct bpf_ringbuf *rb = container_of(work, struct bpf_ringbuf, work);",
            "",
            "\twake_up_all(&rb->waitq);",
            "}",
            "static void bpf_ringbuf_free(struct bpf_ringbuf *rb)",
            "{",
            "\t/* copy pages pointer and nr_pages to local variable, as we are going",
            "\t * to unmap rb itself with vunmap() below",
            "\t */",
            "\tstruct page **pages = rb->pages;",
            "\tint i, nr_pages = rb->nr_pages;",
            "",
            "\tvunmap(rb);",
            "\tfor (i = 0; i < nr_pages; i++)",
            "\t\t__free_page(pages[i]);",
            "\tbpf_map_area_free(pages);",
            "}",
            "static void ringbuf_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "\tbpf_ringbuf_free(rb_map->rb);",
            "\tbpf_map_area_free(rb_map);",
            "}",
            "static long ringbuf_map_update_elem(struct bpf_map *map, void *key, void *value,",
            "\t\t\t\t    u64 flags)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static long ringbuf_map_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static int ringbuf_map_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\t    void *next_key)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static int ringbuf_map_mmap_kern(struct bpf_map *map, struct vm_area_struct *vma)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "",
            "\tif (vma->vm_flags & VM_WRITE) {",
            "\t\t/* allow writable mapping for the consumer_pos only */",
            "\t\tif (vma->vm_pgoff != 0 || vma->vm_end - vma->vm_start != PAGE_SIZE)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "\t/* remap_vmalloc_range() checks size and offset constraints */",
            "\treturn remap_vmalloc_range(vma, rb_map->rb,",
            "\t\t\t\t   vma->vm_pgoff + RINGBUF_PGOFF);",
            "}",
            "static int ringbuf_map_mmap_user(struct bpf_map *map, struct vm_area_struct *vma)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "",
            "\tif (vma->vm_flags & VM_WRITE) {",
            "\t\tif (vma->vm_pgoff == 0)",
            "\t\t\t/* Disallow writable mappings to the consumer pointer,",
            "\t\t\t * and allow writable mappings to both the producer",
            "\t\t\t * position, and the ring buffer data itself.",
            "\t\t\t */",
            "\t\t\treturn -EPERM;",
            "\t}",
            "\t/* remap_vmalloc_range() checks size and offset constraints */",
            "\treturn remap_vmalloc_range(vma, rb_map->rb, vma->vm_pgoff + RINGBUF_PGOFF);",
            "}",
            "static unsigned long ringbuf_avail_data_sz(struct bpf_ringbuf *rb)",
            "{",
            "\tunsigned long cons_pos, prod_pos;",
            "",
            "\tcons_pos = smp_load_acquire(&rb->consumer_pos);",
            "\tprod_pos = smp_load_acquire(&rb->producer_pos);",
            "\treturn prod_pos - cons_pos;",
            "}",
            "static u32 ringbuf_total_data_sz(const struct bpf_ringbuf *rb)",
            "{",
            "\treturn rb->mask + 1;",
            "}",
            "static __poll_t ringbuf_map_poll_kern(struct bpf_map *map, struct file *filp,",
            "\t\t\t\t      struct poll_table_struct *pts)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "\tpoll_wait(filp, &rb_map->rb->waitq, pts);",
            "",
            "\tif (ringbuf_avail_data_sz(rb_map->rb))",
            "\t\treturn EPOLLIN | EPOLLRDNORM;",
            "\treturn 0;",
            "}",
            "static __poll_t ringbuf_map_poll_user(struct bpf_map *map, struct file *filp,",
            "\t\t\t\t      struct poll_table_struct *pts)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "\tpoll_wait(filp, &rb_map->rb->waitq, pts);",
            "",
            "\tif (ringbuf_avail_data_sz(rb_map->rb) < ringbuf_total_data_sz(rb_map->rb))",
            "\t\treturn EPOLLOUT | EPOLLWRNORM;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_ringbuf_notify, bpf_ringbuf_free, ringbuf_map_free, ringbuf_map_update_elem, ringbuf_map_delete_elem, ringbuf_map_get_next_key, ringbuf_map_mmap_kern, ringbuf_map_mmap_user, ringbuf_avail_data_sz, ringbuf_total_data_sz, ringbuf_map_poll_kern, ringbuf_map_poll_user",
          "description": "实现了环形缓冲区的事件通知、资源释放、内存映射控制及I/O监控功能。包含针对用户态和内核态的差异化mmap处理逻辑，通过spinlock和atomic_t实现并发控制，提供poll接口检测缓冲区可用数据状态。",
          "similarity": 0.376830130815506
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/ringbuf.c",
          "start_line": 335,
          "end_line": 447,
          "content": [
            "static u64 ringbuf_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct bpf_ringbuf *rb;",
            "\tint nr_data_pages;",
            "\tint nr_meta_pages;",
            "\tu64 usage = sizeof(struct bpf_ringbuf_map);",
            "",
            "\trb = container_of(map, struct bpf_ringbuf_map, map)->rb;",
            "\tusage += (u64)rb->nr_pages << PAGE_SHIFT;",
            "\tnr_meta_pages = RINGBUF_NR_META_PAGES;",
            "\tnr_data_pages = map->max_entries >> PAGE_SHIFT;",
            "\tusage += (nr_meta_pages + 2 * nr_data_pages) * sizeof(struct page *);",
            "\treturn usage;",
            "}",
            "static size_t bpf_ringbuf_rec_pg_off(struct bpf_ringbuf *rb,",
            "\t\t\t\t     struct bpf_ringbuf_hdr *hdr)",
            "{",
            "\treturn ((void *)hdr - (void *)rb) >> PAGE_SHIFT;",
            "}",
            "static void bpf_ringbuf_commit(void *sample, u64 flags, bool discard)",
            "{",
            "\tunsigned long rec_pos, cons_pos;",
            "\tstruct bpf_ringbuf_hdr *hdr;",
            "\tstruct bpf_ringbuf *rb;",
            "\tu32 new_len;",
            "",
            "\thdr = sample - BPF_RINGBUF_HDR_SZ;",
            "\trb = bpf_ringbuf_restore_from_rec(hdr);",
            "\tnew_len = hdr->len ^ BPF_RINGBUF_BUSY_BIT;",
            "\tif (discard)",
            "\t\tnew_len |= BPF_RINGBUF_DISCARD_BIT;",
            "",
            "\t/* update record header with correct final size prefix */",
            "\txchg(&hdr->len, new_len);",
            "",
            "\t/* if consumer caught up and is waiting for our record, notify about",
            "\t * new data availability",
            "\t */",
            "\trec_pos = (void *)hdr - (void *)rb->data;",
            "\tcons_pos = smp_load_acquire(&rb->consumer_pos) & rb->mask;",
            "",
            "\tif (flags & BPF_RB_FORCE_WAKEUP)",
            "\t\tirq_work_queue(&rb->work);",
            "\telse if (cons_pos == rec_pos && !(flags & BPF_RB_NO_WAKEUP))",
            "\t\tirq_work_queue(&rb->work);",
            "}",
            "static int __bpf_user_ringbuf_peek(struct bpf_ringbuf *rb, void **sample, u32 *size)",
            "{",
            "\tint err;",
            "\tu32 hdr_len, sample_len, total_len, flags, *hdr;",
            "\tu64 cons_pos, prod_pos;",
            "",
            "\t/* Synchronizes with smp_store_release() in user-space producer. */",
            "\tprod_pos = smp_load_acquire(&rb->producer_pos);",
            "\tif (prod_pos % 8)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Synchronizes with smp_store_release() in __bpf_user_ringbuf_sample_release() */",
            "\tcons_pos = smp_load_acquire(&rb->consumer_pos);",
            "\tif (cons_pos >= prod_pos)",
            "\t\treturn -ENODATA;",
            "",
            "\thdr = (u32 *)((uintptr_t)rb->data + (uintptr_t)(cons_pos & rb->mask));",
            "\t/* Synchronizes with smp_store_release() in user-space producer. */",
            "\thdr_len = smp_load_acquire(hdr);",
            "\tflags = hdr_len & (BPF_RINGBUF_BUSY_BIT | BPF_RINGBUF_DISCARD_BIT);",
            "\tsample_len = hdr_len & ~flags;",
            "\ttotal_len = round_up(sample_len + BPF_RINGBUF_HDR_SZ, 8);",
            "",
            "\t/* The sample must fit within the region advertised by the producer position. */",
            "\tif (total_len > prod_pos - cons_pos)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* The sample must fit within the data region of the ring buffer. */",
            "\tif (total_len > ringbuf_total_data_sz(rb))",
            "\t\treturn -E2BIG;",
            "",
            "\t/* The sample must fit into a struct bpf_dynptr. */",
            "\terr = bpf_dynptr_check_size(sample_len);",
            "\tif (err)",
            "\t\treturn -E2BIG;",
            "",
            "\tif (flags & BPF_RINGBUF_DISCARD_BIT) {",
            "\t\t/* If the discard bit is set, the sample should be skipped.",
            "\t\t *",
            "\t\t * Update the consumer pos, and return -EAGAIN so the caller",
            "\t\t * knows to skip this sample and try to read the next one.",
            "\t\t */",
            "\t\tsmp_store_release(&rb->consumer_pos, cons_pos + total_len);",
            "\t\treturn -EAGAIN;",
            "\t}",
            "",
            "\tif (flags & BPF_RINGBUF_BUSY_BIT)",
            "\t\treturn -ENODATA;",
            "",
            "\t*sample = (void *)((uintptr_t)rb->data +",
            "\t\t\t   (uintptr_t)((cons_pos + BPF_RINGBUF_HDR_SZ) & rb->mask));",
            "\t*size = sample_len;",
            "\treturn 0;",
            "}",
            "static void __bpf_user_ringbuf_sample_release(struct bpf_ringbuf *rb, size_t size, u64 flags)",
            "{",
            "\tu64 consumer_pos;",
            "\tu32 rounded_size = round_up(size + BPF_RINGBUF_HDR_SZ, 8);",
            "",
            "\t/* Using smp_load_acquire() is unnecessary here, as the busy-bit",
            "\t * prevents another task from writing to consumer_pos after it was read",
            "\t * by this task with smp_load_acquire() in __bpf_user_ringbuf_peek().",
            "\t */",
            "\tconsumer_pos = rb->consumer_pos;",
            "\t /* Synchronizes with smp_load_acquire() in user-space producer. */",
            "\tsmp_store_release(&rb->consumer_pos, consumer_pos + rounded_size);",
            "}"
          ],
          "function_name": "ringbuf_map_mem_usage, bpf_ringbuf_rec_pg_off, bpf_ringbuf_commit, __bpf_user_ringbuf_peek, __bpf_user_ringbuf_sample_release",
          "description": "提供了环形缓冲区的内存占用统计、记录位置转换、样本提交及消费操作。包含用户态生产者与消费者的同步机制，通过忙位防止竞态条件，确保样本数据完整性校验和消费进度更新的有序性。",
          "similarity": 0.36228957772254944
        }
      ]
    },
    {
      "source_file": "kernel/bpf/inode.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:12:33\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\inode.c`\n\n---\n\n# `bpf/inode.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/inode.c` 实现了一个轻量级的虚拟文件系统（称为 **bpffs**），用于支持 eBPF 对象（包括 BPF 程序、映射和链接）的 **pinning（持久化）机制**。该文件系统允许用户空间通过标准文件系统操作（如 `mkdir`、`create`、`unlink` 等）将 BPF 对象绑定到文件系统路径，从而在进程退出后仍能保持对这些对象的引用，避免被内核自动释放。此机制是 `bpf(2)` 系统调用中 `BPF_OBJ_PIN` 和 `BPF_OBJ_GET` 功能的后端支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `enum bpf_type`：枚举类型，标识 BPF 对象类型（`BPF_TYPE_PROG`、`BPF_TYPE_MAP`、`BPF_TYPE_LINK`）。\n- `struct map_iter`：用于 BPF map 序列化遍历的迭代器结构，包含当前 key 和完成标志。\n- `const struct inode_operations`：分别为目录、程序、映射、链接定义的 inode 操作集合（`bpf_dir_iops`、`bpf_prog_iops` 等）。\n- `const struct file_operations`：\n  - `bpffs_map_fops`：支持对支持 `seq_show` 的 BPF map 进行 `cat` 读取。\n  - `bpffs_obj_fops`：通用只读文件操作，打开即返回 `-EIO`，防止误操作。\n\n### 主要函数\n\n- `bpf_any_get()` / `bpf_any_put()`：根据对象类型统一增加/减少引用计数。\n- `bpf_fd_probe_obj()`：通过文件描述符探测并获取对应的 BPF 对象及其类型。\n- `bpf_get_inode()`：为 bpffs 创建新的 inode（支持目录、普通文件、符号链接）。\n- `bpf_inode_type()`：根据 inode 的 `i_op` 字段反推其对应的 BPF 对象类型。\n- `bpf_dentry_finalize()`：完成 dentry 与 inode 的绑定并更新父目录时间戳。\n- `bpf_mkdir()`：实现 bpffs 中的目录创建。\n- `bpf_mkprog()` / `bpf_mkmap()` / `bpf_mklink()`：分别创建 BPF 程序、映射、链接对应的文件 inode。\n- `map_iter_alloc()` / `map_iter_free()`：管理 map 遍历迭代器的生命周期。\n- `map_seq_*` 系列函数：实现 BPF map 的 `seq_file` 遍历接口，用于 `cat` 输出。\n- `bpffs_map_open()` / `bpffs_map_release()`：map 文件的打开与释放，初始化 seq_file 上下文。\n- `bpf_lookup()`：自定义 lookup 逻辑，禁止文件名中包含 `.`（保留用于未来扩展）。\n\n## 3. 关键实现\n\n### BPF 对象引用管理\n通过 `bpf_any_get()` 和 `bpf_any_put()` 封装不同 BPF 对象（prog/map/link）的引用计数操作，确保在 inode 创建和销毁时正确持有/释放内核对象，防止内存泄漏或提前释放。\n\n### 对象类型识别\n利用 `inode->i_op` 指针的唯一性（分别指向 `bpf_prog_iops`、`bpf_map_iops` 等空结构体）作为类型标签，在运行时通过指针比较快速判断 inode 对应的 BPF 对象类型。\n\n### BPF Map 的可读性支持\n对于支持 `map_seq_show_elem` 操作的 BPF map（如 hash、array 等），通过 `seq_file` 机制实现 `cat /sys/fs/bpf/map_name` 输出内容。输出包含警告信息，强调格式不稳定，仅用于调试。\n\n### 安全与扩展性设计\n- 文件名中禁止出现 `.` 字符（如 `foo.bar`），为未来在 bpffs 中引入特殊文件（如元数据、控制接口）预留命名空间。\n- 普通 BPF 对象文件（prog/link 或不支持 seq_show 的 map）使用 `bpffs_obj_fops`，其 `open` 返回 `-EIO`，防止用户误读/误写导致未定义行为。\n\n### 虚拟文件系统集成\n基于 `simple_fs` 框架（如 `simple_dir_operations`、`simple_lookup`）构建，仅重写必要操作（如 `mkdir`、`lookup`、`create` 逻辑由上层调用 `bpf_mk*` 实现），保持代码简洁。\n\n## 4. 依赖关系\n\n- **BPF 子系统核心**：依赖 `<linux/bpf.h>`、`<linux/filter.h>` 提供的 `bpf_prog_*`、`bpf_map_*`、`bpf_link_*` 等核心 API。\n- **VFS 层**：依赖标准 VFS 接口（`<linux/fs.h>`、`<linux/namei.h>`、`<linux/dcache.h>`）实现 inode、dentry、file 操作。\n- **预加载机制**：包含 `\"preload/bpf_preload.h\"`，可能用于内核启动时预加载 BPF 对象。\n- **迭代器支持**：若 BPF link 为 iterator 类型，会使用 `bpf_iter_fops`（定义在其他文件中）。\n\n## 5. 使用场景\n\n- **BPF 对象持久化**：用户空间工具（如 `bpftool`）调用 `bpf(BPF_OBJ_PIN, ...)` 将 map/prog/link pin 到 `/sys/fs/bpf/` 下的路径，内核通过本文件创建对应 inode 并持有对象引用。\n- **跨进程共享 BPF 对象**：多个进程可通过 `bpf(BPF_OBJ_GET, ...)` 从同一 bpffs 路径获取已 pin 对象的 fd，实现共享。\n- **调试与可观测性**：支持 `seq_show` 的 map 可通过 `cat` 命令查看内容，辅助开发调试（注意：非稳定接口）。\n- **系统启动预加载**：结合 `bpf_preload` 机制，在内核初始化阶段将关键 BPF 程序/映射 pin 到 bpffs，供后续服务使用。",
      "similarity": 0.4340924024581909,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 53,
          "end_line": 155,
          "content": [
            "static void bpf_any_put(void *raw, enum bpf_type type)",
            "{",
            "\tswitch (type) {",
            "\tcase BPF_TYPE_PROG:",
            "\t\tbpf_prog_put(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_MAP:",
            "\t\tbpf_map_put_with_uref(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_LINK:",
            "\t\tbpf_link_put(raw);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "}",
            "static int bpf_inode_type(const struct inode *inode, enum bpf_type *type)",
            "{",
            "\t*type = BPF_TYPE_UNSPEC;",
            "\tif (inode->i_op == &bpf_prog_iops)",
            "\t\t*type = BPF_TYPE_PROG;",
            "\telse if (inode->i_op == &bpf_map_iops)",
            "\t\t*type = BPF_TYPE_MAP;",
            "\telse if (inode->i_op == &bpf_link_iops)",
            "\t\t*type = BPF_TYPE_LINK;",
            "\telse",
            "\t\treturn -EACCES;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,",
            "\t\t\t\tstruct inode *dir)",
            "{",
            "\td_instantiate(dentry, inode);",
            "\tdget(dentry);",
            "",
            "\tdir->i_mtime = inode_set_ctime_current(dir);",
            "}",
            "static int bpf_mkdir(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t     struct dentry *dentry, umode_t mode)",
            "{",
            "\tstruct inode *inode;",
            "",
            "\tinode = bpf_get_inode(dir->i_sb, dir, mode | S_IFDIR);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_dir_iops;",
            "\tinode->i_fop = &simple_dir_operations;",
            "",
            "\tinc_nlink(inode);",
            "\tinc_nlink(dir);",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static void map_iter_free(struct map_iter *iter)",
            "{",
            "\tif (iter) {",
            "\t\tkfree(iter->key);",
            "\t\tkfree(iter);",
            "\t}",
            "}",
            "static void map_seq_stop(struct seq_file *m, void *v)",
            "{",
            "}",
            "static int map_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct bpf_map *map = seq_file_to_map(m);",
            "\tvoid *key = map_iter(m)->key;",
            "",
            "\tif (unlikely(v == SEQ_START_TOKEN)) {",
            "\t\tseq_puts(m, \"# WARNING!! The output is for debug purpose only\\n\");",
            "\t\tseq_puts(m, \"# WARNING!! The output format will change\\n\");",
            "\t} else {",
            "\t\tmap->ops->map_seq_show_elem(map, key, m);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int bpffs_map_open(struct inode *inode, struct file *file)",
            "{",
            "\tstruct bpf_map *map = inode->i_private;",
            "\tstruct map_iter *iter;",
            "\tstruct seq_file *m;",
            "\tint err;",
            "",
            "\titer = map_iter_alloc(map);",
            "\tif (!iter)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = seq_open(file, &bpffs_map_seq_ops);",
            "\tif (err) {",
            "\t\tmap_iter_free(iter);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tm = file->private_data;",
            "\tm->private = iter;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_any_put, bpf_inode_type, bpf_dentry_finalize, bpf_mkdir, map_iter_free, map_seq_stop, map_seq_show, bpffs_map_open",
          "description": "实现BPF对象引用释放逻辑，inode类型识别，目录创建，迭代器管理及序列化展示功能",
          "similarity": 0.41948363184928894
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 680,
          "end_line": 783,
          "content": [
            "static void seq_print_delegate_opts(struct seq_file *m,",
            "\t\t\t\t    const char *opt_name,",
            "\t\t\t\t    const struct btf *btf,",
            "\t\t\t\t    const struct btf_type *enum_t,",
            "\t\t\t\t    const char *prefix,",
            "\t\t\t\t    u64 delegate_msk, u64 any_msk)",
            "{",
            "\tconst struct btf_enum *e;",
            "\tbool first = true;",
            "\tconst char *name;",
            "\tu64 msk;",
            "\tint i, n, pfx_len = strlen(prefix);",
            "",
            "\tdelegate_msk &= any_msk; /* clear unknown bits */",
            "",
            "\tif (delegate_msk == 0)",
            "\t\treturn;",
            "",
            "\tseq_printf(m, \",%s\", opt_name);",
            "\tif (delegate_msk == any_msk) {",
            "\t\tseq_printf(m, \"=any\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (btf && enum_t) {",
            "\t\tfor (i = 0, n = btf_vlen(enum_t); i < n; i++) {",
            "\t\t\te = &btf_enum(enum_t)[i];",
            "\t\t\tname = btf_name_by_offset(btf, e->name_off);",
            "\t\t\tif (!name || strncasecmp(name, prefix, pfx_len) != 0)",
            "\t\t\t\tcontinue;",
            "\t\t\tmsk = 1ULL << e->val;",
            "\t\t\tif (delegate_msk & msk) {",
            "\t\t\t\t/* emit lower-case name without prefix */",
            "\t\t\t\tseq_printf(m, \"%c\", first ? '=' : ':');",
            "\t\t\t\tname += pfx_len;",
            "\t\t\t\twhile (*name) {",
            "\t\t\t\t\tseq_printf(m, \"%c\", tolower(*name));",
            "\t\t\t\t\tname++;",
            "\t\t\t\t}",
            "",
            "\t\t\t\tdelegate_msk &= ~msk;",
            "\t\t\t\tfirst = false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif (delegate_msk)",
            "\t\tseq_printf(m, \"%c0x%llx\", first ? '=' : ':', delegate_msk);",
            "}",
            "static int bpf_show_options(struct seq_file *m, struct dentry *root)",
            "{",
            "\tstruct inode *inode = d_inode(root);",
            "\tumode_t mode = inode->i_mode & S_IALLUGO & ~S_ISVTX;",
            "\tstruct bpf_mount_opts *opts = root->d_sb->s_fs_info;",
            "\tu64 mask;",
            "",
            "\tif (!uid_eq(inode->i_uid, GLOBAL_ROOT_UID))",
            "\t\tseq_printf(m, \",uid=%u\",",
            "\t\t\t   from_kuid_munged(&init_user_ns, inode->i_uid));",
            "\tif (!gid_eq(inode->i_gid, GLOBAL_ROOT_GID))",
            "\t\tseq_printf(m, \",gid=%u\",",
            "\t\t\t   from_kgid_munged(&init_user_ns, inode->i_gid));",
            "\tif (mode != S_IRWXUGO)",
            "\t\tseq_printf(m, \",mode=%o\", mode);",
            "",
            "\tif (opts->delegate_cmds || opts->delegate_maps ||",
            "\t    opts->delegate_progs || opts->delegate_attachs) {",
            "\t\tstruct bpffs_btf_enums info;",
            "",
            "\t\t/* ignore errors, fallback to hex */",
            "\t\t(void)find_bpffs_btf_enums(&info);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_cmds\",",
            "\t\t\t\t\tinfo.btf, info.cmd_t, \"BPF_\",",
            "\t\t\t\t\topts->delegate_cmds, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_maps\",",
            "\t\t\t\t\tinfo.btf, info.map_t, \"BPF_MAP_TYPE_\",",
            "\t\t\t\t\topts->delegate_maps, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_progs\",",
            "\t\t\t\t\tinfo.btf, info.prog_t, \"BPF_PROG_TYPE_\",",
            "\t\t\t\t\topts->delegate_progs, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_attachs\",",
            "\t\t\t\t\tinfo.btf, info.attach_t, \"BPF_\",",
            "\t\t\t\t\topts->delegate_attachs, mask);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_free_inode(struct inode *inode)",
            "{",
            "\tenum bpf_type type;",
            "",
            "\tif (S_ISLNK(inode->i_mode))",
            "\t\tkfree(inode->i_link);",
            "\tif (!bpf_inode_type(inode, &type))",
            "\t\tbpf_any_put(inode->i_private, type);",
            "\tfree_inode_nonrcu(inode);",
            "}"
          ],
          "function_name": "seq_print_delegate_opts, bpf_show_options, bpf_free_inode",
          "description": "展示文件系统挂载参数，处理委托选项打印及inode释放时的资源回收操作",
          "similarity": 0.3968053460121155
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 296,
          "end_line": 425,
          "content": [
            "static int bpffs_map_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seq_file *m = file->private_data;",
            "",
            "\tmap_iter_free(map_iter(m));",
            "",
            "\treturn seq_release(inode, file);",
            "}",
            "static int bpffs_obj_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn -EIO;",
            "}",
            "static int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,",
            "\t\t\t const struct inode_operations *iops,",
            "\t\t\t const struct file_operations *fops)",
            "{",
            "\tstruct inode *dir = dentry->d_parent->d_inode;",
            "\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = iops;",
            "\tinode->i_fop = fops;",
            "\tinode->i_private = raw;",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static int bpf_mkprog(struct dentry *dentry, umode_t mode, void *arg)",
            "{",
            "\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_prog_iops,",
            "\t\t\t     &bpffs_obj_fops);",
            "}",
            "static int bpf_mkmap(struct dentry *dentry, umode_t mode, void *arg)",
            "{",
            "\tstruct bpf_map *map = arg;",
            "",
            "\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_map_iops,",
            "\t\t\t     bpf_map_support_seq_show(map) ?",
            "\t\t\t     &bpffs_map_fops : &bpffs_obj_fops);",
            "}",
            "static int bpf_mklink(struct dentry *dentry, umode_t mode, void *arg)",
            "{",
            "\tstruct bpf_link *link = arg;",
            "",
            "\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_link_iops,",
            "\t\t\t     bpf_link_is_iter(link) ?",
            "\t\t\t     &bpf_iter_fops : &bpffs_obj_fops);",
            "}",
            "static int bpf_symlink(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t       struct dentry *dentry, const char *target)",
            "{",
            "\tchar *link = kstrdup(target, GFP_USER | __GFP_NOWARN);",
            "\tstruct inode *inode;",
            "",
            "\tif (!link)",
            "\t\treturn -ENOMEM;",
            "",
            "\tinode = bpf_get_inode(dir->i_sb, dir, S_IRWXUGO | S_IFLNK);",
            "\tif (IS_ERR(inode)) {",
            "\t\tkfree(link);",
            "\t\treturn PTR_ERR(inode);",
            "\t}",
            "",
            "\tinode->i_op = &simple_symlink_inode_operations;",
            "\tinode->i_link = link;",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static int bpf_iter_link_pin_kernel(struct dentry *parent,",
            "\t\t\t\t    const char *name, struct bpf_link *link)",
            "{",
            "\tumode_t mode = S_IFREG | S_IRUSR;",
            "\tstruct dentry *dentry;",
            "\tint ret;",
            "",
            "\tinode_lock(parent->d_inode);",
            "\tdentry = lookup_one_len(name, parent, strlen(name));",
            "\tif (IS_ERR(dentry)) {",
            "\t\tinode_unlock(parent->d_inode);",
            "\t\treturn PTR_ERR(dentry);",
            "\t}",
            "\tret = bpf_mkobj_ops(dentry, mode, link, &bpf_link_iops,",
            "\t\t\t    &bpf_iter_fops);",
            "\tdput(dentry);",
            "\tinode_unlock(parent->d_inode);",
            "\treturn ret;",
            "}",
            "static int bpf_obj_do_pin(int path_fd, const char __user *pathname, void *raw,",
            "\t\t\t  enum bpf_type type)",
            "{",
            "\tstruct dentry *dentry;",
            "\tstruct inode *dir;",
            "\tstruct path path;",
            "\tumode_t mode;",
            "\tint ret;",
            "",
            "\tdentry = user_path_create(path_fd, pathname, &path, 0);",
            "\tif (IS_ERR(dentry))",
            "\t\treturn PTR_ERR(dentry);",
            "",
            "\tdir = d_inode(path.dentry);",
            "\tif (dir->i_op != &bpf_dir_iops) {",
            "\t\tret = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tret = security_path_mknod(&path, dentry, mode, 0);",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tswitch (type) {",
            "\tcase BPF_TYPE_PROG:",
            "\t\tret = vfs_mkobj(dentry, mode, bpf_mkprog, raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_MAP:",
            "\t\tret = vfs_mkobj(dentry, mode, bpf_mkmap, raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_LINK:",
            "\t\tret = vfs_mkobj(dentry, mode, bpf_mklink, raw);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tret = -EPERM;",
            "\t}",
            "out:",
            "\tdone_path_create(&path, dentry);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpffs_map_release, bpffs_obj_open, bpf_mkobj_ops, bpf_mkprog, bpf_mkmap, bpf_mklink, bpf_symlink, bpf_iter_link_pin_kernel, bpf_obj_do_pin",
          "description": "提供对象创建接口，符号链接处理，链接对象挂载及对象pin操作实现",
          "similarity": 0.39030611515045166
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 479,
          "end_line": 593,
          "content": [
            "int bpf_obj_pin_user(u32 ufd, int path_fd, const char __user *pathname)",
            "{",
            "\tenum bpf_type type;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\traw = bpf_fd_probe_obj(ufd, &type);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tret = bpf_obj_do_pin(path_fd, pathname, raw, type);",
            "\tif (ret != 0)",
            "\t\tbpf_any_put(raw, type);",
            "",
            "\treturn ret;",
            "}",
            "int bpf_obj_get_user(int path_fd, const char __user *pathname, int flags)",
            "{",
            "\tenum bpf_type type = BPF_TYPE_UNSPEC;",
            "\tint f_flags;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\tf_flags = bpf_get_file_flag(flags);",
            "\tif (f_flags < 0)",
            "\t\treturn f_flags;",
            "",
            "\traw = bpf_obj_do_get(path_fd, pathname, &type, f_flags);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tif (type == BPF_TYPE_PROG)",
            "\t\tret = bpf_prog_new_fd(raw);",
            "\telse if (type == BPF_TYPE_MAP)",
            "\t\tret = bpf_map_new_fd(raw, f_flags);",
            "\telse if (type == BPF_TYPE_LINK)",
            "\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);",
            "\telse",
            "\t\treturn -ENOENT;",
            "",
            "\tif (ret < 0)",
            "\t\tbpf_any_put(raw, type);",
            "\treturn ret;",
            "}",
            "static int find_bpffs_btf_enums(struct bpffs_btf_enums *info)",
            "{",
            "\tconst struct btf *btf;",
            "\tconst struct btf_type *t;",
            "\tconst char *name;",
            "\tint i, n;",
            "",
            "\tmemset(info, 0, sizeof(*info));",
            "",
            "\tbtf = bpf_get_btf_vmlinux();",
            "\tif (IS_ERR(btf))",
            "\t\treturn PTR_ERR(btf);",
            "\tif (!btf)",
            "\t\treturn -ENOENT;",
            "",
            "\tinfo->btf = btf;",
            "",
            "\tfor (i = 1, n = btf_nr_types(btf); i < n; i++) {",
            "\t\tt = btf_type_by_id(btf, i);",
            "\t\tif (!btf_type_is_enum(t))",
            "\t\t\tcontinue;",
            "",
            "\t\tname = btf_name_by_offset(btf, t->name_off);",
            "\t\tif (!name)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (strcmp(name, \"bpf_cmd\") == 0)",
            "\t\t\tinfo->cmd_t = t;",
            "\t\telse if (strcmp(name, \"bpf_map_type\") == 0)",
            "\t\t\tinfo->map_t = t;",
            "\t\telse if (strcmp(name, \"bpf_prog_type\") == 0)",
            "\t\t\tinfo->prog_t = t;",
            "\t\telse if (strcmp(name, \"bpf_attach_type\") == 0)",
            "\t\t\tinfo->attach_t = t;",
            "\t\telse",
            "\t\t\tcontinue;",
            "",
            "\t\tif (info->cmd_t && info->map_t && info->prog_t && info->attach_t)",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\treturn -ESRCH;",
            "}",
            "static bool find_btf_enum_const(const struct btf *btf, const struct btf_type *enum_t,",
            "\t\t\t\tconst char *prefix, const char *str, int *value)",
            "{",
            "\tconst struct btf_enum *e;",
            "\tconst char *name;",
            "\tint i, n, pfx_len = strlen(prefix);",
            "",
            "\t*value = 0;",
            "",
            "\tif (!btf || !enum_t)",
            "\t\treturn false;",
            "",
            "\tfor (i = 0, n = btf_vlen(enum_t); i < n; i++) {",
            "\t\te = &btf_enum(enum_t)[i];",
            "",
            "\t\tname = btf_name_by_offset(btf, e->name_off);",
            "\t\tif (!name || strncasecmp(name, prefix, pfx_len) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* match symbolic name case insensitive and ignoring prefix */",
            "\t\tif (strcasecmp(name + pfx_len, str) == 0) {",
            "\t\t\t*value = e->val;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "bpf_obj_pin_user, bpf_obj_get_user, find_bpffs_btf_enums, find_btf_enum_const",
          "description": "实现用户空间对象pin操作，对象获取逻辑及BTF枚举常量解析功能",
          "similarity": 0.3792884945869446
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 818,
          "end_line": 943,
          "content": [
            "static int bpf_parse_param(struct fs_context *fc, struct fs_parameter *param)",
            "{",
            "\tstruct bpf_mount_opts *opts = fc->s_fs_info;",
            "\tstruct fs_parse_result result;",
            "\tkuid_t uid;",
            "\tkgid_t gid;",
            "\tint opt, err;",
            "",
            "\topt = fs_parse(fc, bpf_fs_parameters, param, &result);",
            "\tif (opt < 0) {",
            "\t\t/* We might like to report bad mount options here, but",
            "\t\t * traditionally we've ignored all mount options, so we'd",
            "\t\t * better continue to ignore non-existing options for bpf.",
            "\t\t */",
            "\t\tif (opt == -ENOPARAM) {",
            "\t\t\topt = vfs_parse_fs_param_source(fc, param);",
            "\t\t\tif (opt != -ENOPARAM)",
            "\t\t\t\treturn opt;",
            "",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\tif (opt < 0)",
            "\t\t\treturn opt;",
            "\t}",
            "",
            "\tswitch (opt) {",
            "\tcase OPT_UID:",
            "\t\tuid = make_kuid(current_user_ns(), result.uint_32);",
            "\t\tif (!uid_valid(uid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\t/*",
            "\t\t * The requested uid must be representable in the",
            "\t\t * filesystem's idmapping.",
            "\t\t */",
            "\t\tif (!kuid_has_mapping(fc->user_ns, uid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\topts->uid = uid;",
            "\t\tbreak;",
            "\tcase OPT_GID:",
            "\t\tgid = make_kgid(current_user_ns(), result.uint_32);",
            "\t\tif (!gid_valid(gid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\t/*",
            "\t\t * The requested gid must be representable in the",
            "\t\t * filesystem's idmapping.",
            "\t\t */",
            "\t\tif (!kgid_has_mapping(fc->user_ns, gid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\topts->gid = gid;",
            "\t\tbreak;",
            "\tcase OPT_MODE:",
            "\t\topts->mode = result.uint_32 & S_IALLUGO;",
            "\t\tbreak;",
            "\tcase OPT_DELEGATE_CMDS:",
            "\tcase OPT_DELEGATE_MAPS:",
            "\tcase OPT_DELEGATE_PROGS:",
            "\tcase OPT_DELEGATE_ATTACHS: {",
            "\t\tstruct bpffs_btf_enums info;",
            "\t\tconst struct btf_type *enum_t;",
            "\t\tconst char *enum_pfx;",
            "\t\tu64 *delegate_msk, msk = 0;",
            "\t\tchar *p, *str;",
            "\t\tint val;",
            "",
            "\t\t/* ignore errors, fallback to hex */",
            "\t\t(void)find_bpffs_btf_enums(&info);",
            "",
            "\t\tswitch (opt) {",
            "\t\tcase OPT_DELEGATE_CMDS:",
            "\t\t\tdelegate_msk = &opts->delegate_cmds;",
            "\t\t\tenum_t = info.cmd_t;",
            "\t\t\tenum_pfx = \"BPF_\";",
            "\t\t\tbreak;",
            "\t\tcase OPT_DELEGATE_MAPS:",
            "\t\t\tdelegate_msk = &opts->delegate_maps;",
            "\t\t\tenum_t = info.map_t;",
            "\t\t\tenum_pfx = \"BPF_MAP_TYPE_\";",
            "\t\t\tbreak;",
            "\t\tcase OPT_DELEGATE_PROGS:",
            "\t\t\tdelegate_msk = &opts->delegate_progs;",
            "\t\t\tenum_t = info.prog_t;",
            "\t\t\tenum_pfx = \"BPF_PROG_TYPE_\";",
            "\t\t\tbreak;",
            "\t\tcase OPT_DELEGATE_ATTACHS:",
            "\t\t\tdelegate_msk = &opts->delegate_attachs;",
            "\t\t\tenum_t = info.attach_t;",
            "\t\t\tenum_pfx = \"BPF_\";",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tstr = param->string;",
            "\t\twhile ((p = strsep(&str, \":\"))) {",
            "\t\t\tif (strcmp(p, \"any\") == 0) {",
            "\t\t\t\tmsk |= ~0ULL;",
            "\t\t\t} else if (find_btf_enum_const(info.btf, enum_t, enum_pfx, p, &val)) {",
            "\t\t\t\tmsk |= 1ULL << val;",
            "\t\t\t} else {",
            "\t\t\t\terr = kstrtou64(p, 0, &msk);",
            "\t\t\t\tif (err)",
            "\t\t\t\t\treturn err;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/* Setting delegation mount options requires privileges */",
            "\t\tif (msk && !capable(CAP_SYS_ADMIN))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t*delegate_msk |= msk;",
            "\t\tbreak;",
            "\t}",
            "\tdefault:",
            "\t\t/* ignore unknown mount options */",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn 0;",
            "bad_value:",
            "\treturn invalfc(fc, \"Bad value for '%s'\", param->key);",
            "}"
          ],
          "function_name": "bpf_parse_param",
          "description": "解析并验证BPF文件系统的挂载参数，处理UID/GID/模式及委托选项，检查值的有效性并设置到mount选项结构体中",
          "similarity": 0.3692444860935211
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_inode_storage.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:57:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_inode_storage.c`\n\n---\n\n# `bpf/bpf_inode_storage.c` 技术文档\n\n## 1. 文件概述\n\n`bpf_inode_storage.c` 实现了 BPF（Berkeley Packet Filter）程序对 **inode 级别本地存储（local storage）** 的支持。该机制允许 BPF 程序将任意用户定义的数据与内核中的 `struct inode` 实例关联，从而在不修改 VFS 层或文件系统代码的前提下，为 inode 附加自定义元数据。此功能主要用于 LSM（Linux Security Module）钩子、审计、追踪等场景。\n\n该文件基于通用的 `bpf_local_storage` 框架，为 inode 对象定制了存储管理逻辑，并提供了 BPF 辅助函数（helpers）和 map 操作接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `DEFINE_BPF_STORAGE_CACHE(inode_cache)`：为 inode 存储分配的专用内存缓存。\n- `inode_storage_map_ops`：`bpf_map_ops` 操作集，定义了 inode 存储 map 的行为。\n- `bpf_inode_storage_btf_ids`：BTF（BPF Type Format）类型 ID 列表，用于类型安全检查。\n\n### 关键函数\n- **存储访问与管理**\n  - `inode_storage_ptr()`：获取 inode 对应的 BPF 存储指针。\n  - `inode_storage_lookup()`：在指定 inode 和 map 中查找存储数据。\n  - `bpf_inode_storage_free()`：在 inode 销毁时释放其关联的 BPF 存储。\n  - `inode_storage_delete()`：从 inode 中删除指定 map 的存储项。\n\n- **BPF Map 操作接口**\n  - `bpf_fd_inode_storage_lookup_elem()`：通过文件描述符（fd）查找 inode 存储数据。\n  - `bpf_fd_inode_storage_update_elem()`：通过 fd 更新 inode 存储。\n  - `bpf_fd_inode_storage_delete_elem()`：通过 fd 删除 inode 存储。\n\n- **BPF 辅助函数（Helpers）**\n  - `bpf_inode_storage_get()`：BPF 程序调用的辅助函数，用于获取或创建 inode 存储。\n  - `bpf_inode_storage_delete()`：BPF 程序调用的辅助函数，用于删除 inode 存储。\n\n- **Map 生命周期管理**\n  - `inode_storage_map_alloc()`：分配 inode 存储类型的 BPF map。\n  - `inode_storage_map_free()`：释放该类型 map。\n\n## 3. 关键实现\n\n### 存储绑定机制\n- 每个 `struct inode` 通过 `bpf_inode()` 宏访问其内嵌的 `struct bpf_storage_blob`（通常位于 inode 的安全字段或扩展字段中）。\n- `bpf_storage_blob` 包含一个 RCU 保护的 `struct bpf_local_storage *storage` 指针，指向实际的存储容器。\n- 所有存储操作均通过 `bpf_local_storage` 通用框架完成，确保线程安全和内存管理一致性。\n\n### RCU 与锁策略\n- 查找操作使用 `rcu_read_lock()` 保护，避免持有写锁。\n- 更新/删除操作在必要时使用自旋锁（由 `bpf_local_storage_update` 内部处理）。\n- `bpf_inode_storage_get` 要求调用者已持有 RCU 锁（通过 `bpf_rcu_lock_held()` 验证），确保 inode 不会在操作期间被释放。\n\n### 内存分配策略\n- 存储项分配使用 `GFP_ATOMIC`（在 fd-based 接口）或由 verifier 传入的 `gfp_flags`（在 helper 中），以适应不同上下文（如中断、软中断）。\n- 使用专用 SLAB 缓存 `inode_cache` 优化内存分配性能。\n\n### BPF Map 与 Helper 集成\n- 提供两种访问路径：\n  1. **BPF 程序直接调用 helper**（如 `bpf_inode_storage_get`），传入 `struct inode *`。\n  2. **用户空间通过 fd 操作 map**（如 `bpf_map_lookup_elem`），内核自动解析 fd 到 inode。\n- `map_get_next_key` 返回 `-ENOTSUPP`，表明该 map 不支持迭代。\n\n### 类型安全\n- 通过 BTF 类型 ID (`bpf_inode_storage_btf_ids`) 确保 BPF 程序传入的 `inode` 指针类型正确。\n- `arg2_type = ARG_PTR_TO_BTF_ID_OR_NULL` 允许传入空指针（安全处理）。\n\n## 4. 依赖关系\n\n- **核心依赖**\n  - `<linux/bpf_local_storage.h>`：提供通用本地存储框架。\n  - `<linux/bpf.h>`：BPF 核心基础设施。\n  - `<linux/rculist.h>` / `<linux/spinlock.h>`：并发控制原语。\n  - `<linux/fdtable.h>`：fd 解析支持。\n\n- **关联子系统**\n  - **VFS（Virtual File System）**：依赖 `struct inode` 结构及生命周期管理。\n  - **BPF 子系统**：集成到 BPF map 和 helper 机制中。\n  - **LSM（Linux Security Modules）**：常用于在 LSM 钩子中附加安全上下文。\n  - **BTF（BPF Type Format）**：用于运行时类型验证。\n\n- **内存管理**\n  - 依赖 SLAB 分配器创建专用缓存 `inode_cache`。\n  - 与 RCU 机制深度集成，确保存储项安全回收。\n\n## 5. 使用场景\n\n1. **LSM 安全策略扩展**\n   - 在 LSM 钩子（如 `file_open`、`inode_permission`）中，BPF 程序可为 inode 附加自定义安全标签或策略数据。\n\n2. **文件系统审计与监控**\n   - 追踪特定 inode 的访问模式，记录额外审计信息（如首次访问时间、访问者 UID）。\n\n3. **资源配额与限制**\n   - 为 inode 关联配额计数器，实现细粒度资源控制（如单个文件的 I/O 限速）。\n\n4. **调试与性能分析**\n   - 在 BPF 程序中为热点 inode 附加调试信息，辅助性能调优。\n\n5. **用户空间工具集成**\n   - 通过 fd 操作 map，用户空间程序可查询/修改 inode 的 BPF 存储（如 `bpftool` 调试）。\n\n> **注意**：由于 inode 可能被频繁创建/销毁，BPF 程序必须确保在安全上下文中调用 helper（如持有 inode 引用或处于 RCU 临界区），避免访问已释放内存。",
      "similarity": 0.42658525705337524,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 57,
          "end_line": 121,
          "content": [
            "void bpf_inode_storage_free(struct inode *inode)",
            "{",
            "\tstruct bpf_local_storage *local_storage;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "",
            "\tlocal_storage = rcu_dereference(bsb->storage);",
            "\tif (!local_storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn;",
            "\t}",
            "",
            "\tbpf_local_storage_destroy(local_storage);",
            "\trcu_read_unlock();",
            "}",
            "static long bpf_fd_inode_storage_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t\t     void *value, u64 map_flags)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\tif (!inode_storage_ptr(file_inode(fd_file(f))))",
            "\t\treturn -EBADF;",
            "",
            "\tsdata = bpf_local_storage_update(file_inode(fd_file(f)),",
            "\t\t\t\t\t (struct bpf_local_storage_map *)map,",
            "\t\t\t\t\t value, map_flags, false, GFP_ATOMIC);",
            "\treturn PTR_ERR_OR_ZERO(sdata);",
            "}",
            "static int inode_storage_delete(struct inode *inode, struct bpf_map *map)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "",
            "\tsdata = inode_storage_lookup(inode, map, false);",
            "\tif (!sdata)",
            "\t\treturn -ENOENT;",
            "",
            "\tbpf_selem_unlink(SELEM(sdata), false);",
            "",
            "\treturn 0;",
            "}",
            "static long bpf_fd_inode_storage_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\treturn inode_storage_delete(file_inode(fd_file(f)), map);",
            "}",
            "static int notsupp_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\tvoid *next_key)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static void inode_storage_map_free(struct bpf_map *map)",
            "{",
            "\tbpf_local_storage_map_free(map, &inode_cache, NULL);",
            "}"
          ],
          "function_name": "bpf_inode_storage_free, bpf_fd_inode_storage_update_elem, inode_storage_delete, bpf_fd_inode_storage_delete_elem, notsupp_get_next_key, inode_storage_map_free",
          "description": "实现inode相关BPF存储资源的释放、更新、删除操作。包含释放存储空间、通过文件描述符更新存储项、删除存储条目等功能，同时注册了不支持的get_next_key操作并实现map销毁时的缓存回收逻辑。",
          "similarity": 0.3981117606163025
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 1,
          "end_line": 56,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (c) 2019 Facebook",
            " * Copyright 2020 Google LLC.",
            " */",
            "",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/rcupdate_trace.h>",
            "",
            "DEFINE_BPF_STORAGE_CACHE(inode_cache);",
            "",
            "static struct bpf_local_storage __rcu **",
            "inode_storage_ptr(void *owner)",
            "{",
            "\tstruct inode *inode = owner;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "\treturn &bsb->storage;",
            "}",
            "",
            "static struct bpf_local_storage_data *inode_storage_lookup(struct inode *inode,",
            "\t\t\t\t\t\t\t   struct bpf_map *map,",
            "\t\t\t\t\t\t\t   bool cacheit_lockit)",
            "{",
            "\tstruct bpf_local_storage *inode_storage;",
            "\tstruct bpf_local_storage_map *smap;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "",
            "\tinode_storage =",
            "\t\trcu_dereference_check(bsb->storage, bpf_rcu_lock_held());",
            "\tif (!inode_storage)",
            "\t\treturn NULL;",
            "",
            "\tsmap = (struct bpf_local_storage_map *)map;",
            "\treturn bpf_local_storage_lookup(inode_storage, smap, cacheit_lockit);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义inode级别的BPF本地存储缓存inode_cache，并提供用于获取inode存储指针及查询特定map中存储数据的辅助函数。其中inode_storage_lookup通过RCU读锁安全地检索存储实例并调用底层BPF本地存储查找逻辑。",
          "similarity": 0.3853991627693176
        }
      ]
    }
  ]
}