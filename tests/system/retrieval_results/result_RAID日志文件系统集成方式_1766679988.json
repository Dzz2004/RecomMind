{
  "query": "RAID日志文件系统集成方式",
  "timestamp": "2025-12-26 00:26:28",
  "retrieved_files": [
    {
      "source_file": "kernel/pid.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:16:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid.c`\n\n---\n\n# `pid.c` 技术文档\n\n## 1. 文件概述\n\n`pid.c` 是 Linux 内核中实现进程标识符（PID）管理和分配机制的核心文件。它提供了可扩展、时间有界的 PID 分配器，支持 PID 哈希表（pidhash）以及 PID 命名空间（pid namespace）功能。该文件负责 PID 的分配、释放、引用计数管理，并确保在多处理器（SMP）环境下的线程安全性。其设计目标是在高并发场景下高效、无锁地分配和回收 PID，同时支持容器化环境中的 PID 隔离。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct pid`**  \n  表示一个 PID 实例，包含：\n  - 引用计数（`count`）\n  - 多种任务类型链表（`tasks[PIDTYPE_MAX]`），用于关联不同类型的进程（如线程组、会话等）\n  - PID 层级（`level`），用于命名空间嵌套\n  - `numbers[]` 数组：每个命名空间层级对应的 `struct upid`（包含实际 PID 编号 `nr` 和所属命名空间 `ns`）\n  - `rcu` 字段：用于 RCU 安全释放\n  - `wait_pidfd`：用于 pidfd 机制的等待队列\n  - `inodes`：关联的 pidfs inode 列表\n\n- **`struct pid_namespace`**  \n  PID 命名空间结构，包含：\n  - IDR（整数 ID 映射）结构 `idr`，用于高效 PID 分配\n  - `pid_allocated`：当前已分配 PID 数量（含特殊状态如 `PIDNS_ADDING`）\n  - `child_reaper`：命名空间中的 init 进程（子进程回收者）\n  - `level`：命名空间嵌套层级\n  - `pid_cachep`：用于分配 `struct pid` 的 slab 缓存\n\n- **全局变量**\n  - `init_struct_pid`：初始 PID 结构（PID 0，用于 idle 进程）\n  - `init_pid_ns`：初始 PID 命名空间\n  - `pid_max` / `pid_max_min` / `pid_max_max`：PID 分配上限控制\n  - `pidfs_ino`：pidfs 文件系统的 inode 编号起始值\n  - `pidmap_lock`：保护 IDR 和 `pid_allocated` 的自旋锁（SMP 对齐）\n\n### 主要函数\n\n- **`alloc_pid(struct pid_namespace *ns, pid_t *set_tid, size_t set_tid_size)`**  \n  在指定 PID 命名空间中分配一个新的 PID。支持通过 `set_tid` 数组在嵌套命名空间中预设 PID（用于容器恢复等场景）。\n\n- **`free_pid(struct pid *pid)`**  \n  释放 PID 资源，从所有嵌套命名空间的 IDR 中移除，并减少 `pid_allocated` 计数。若命名空间中仅剩 reaper 进程，则唤醒它。\n\n- **`put_pid(struct pid *pid)`**  \n  减少 PID 引用计数，若引用归零则释放内存并减少命名空间引用。\n\n- **`delayed_put_pid(struct rcu_head *rhp)`**  \n  RCU 回调函数，用于安全释放 PID 结构。\n\n## 3. 关键实现\n\n### PID 分配机制\n- 使用 **IDR（Integer ID Allocator）** 替代传统的位图（bitmap），实现 O(1) 分配与释放。\n- 默认采用**循环分配策略**（`idr_alloc_cyclic`），从 `RESERVED_PIDS`（通常为 300）开始，避免低编号 PID 被耗尽。\n- 支持**预设 PID 分配**：通过 `set_tid` 参数在创建进程时指定特定 PID（需具备 `CAP_CHECKPOINT_RESTORE` 权限），用于容器快照恢复。\n\n### 命名空间支持\n- 每个 PID 在嵌套的命名空间中拥有不同的编号（`upid->nr`），通过 `pid->numbers[]` 数组维护层级关系。\n- `pid->level` 表示该 PID 所属的最深命名空间层级。\n- 分配时从最深层命名空间向上遍历至根命名空间，逐层分配 PID。\n\n### 并发与同步\n- **`pidmap_lock`**：保护 IDR 操作和 `pid_allocated` 计数器，使用 `spin_lock_irqsave` 禁用本地中断，防止与 `tasklist_lock` 的死锁。\n- **RCU 释放**：`free_pid` 通过 `call_rcu` 延迟释放 PID 结构，避免在持有锁时执行内存释放。\n- **引用计数**：`struct pid` 使用 `refcount_t` 管理生命周期，确保多任务共享 PID 时的安全释放。\n\n### 特殊状态处理\n- **`PIDNS_ADDING`**：标记命名空间正在添加新进程，防止在 fork 失败时错误减少计数。\n- **Reaper 唤醒**：当命名空间中 PID 数量降至 1 或 2 时，唤醒 `child_reaper`（通常为 init 进程），用于处理命名空间退出（`zap_pid_ns_processes`）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pid_namespace.h>`：PID 命名空间定义\n  - `<linux/idr.h>`：IDR 分配器实现\n  - `<linux/rculist.h>`：RCU 安全链表操作\n  - `<linux/sched/task.h>`、`<linux/sched/signal.h>`：任务调度与信号处理\n  - `<linux/pidfs.h>`、`<uapi/linux/pidfd.h>`：pidfd 和 pidfs 支持\n  - `<linux/refcount.h>`：引用计数机制\n\n- **内核模块交互**：\n  - **进程管理子系统**：与 `fork`/`clone` 系统调用集成，分配 PID 并关联到 `task_struct`\n  - **命名空间子系统**：与 `pidns_operations` 协同实现 PID 隔离\n  - **VFS 子系统**：通过 `pidfs_ino` 为 `/proc/[pid]` 提供 inode 编号\n  - **内存管理**：使用 slab 分配器（`kmem_cache_alloc`）管理 `struct pid` 内存\n\n## 5. 使用场景\n\n- **进程创建**：在 `copy_process` 中调用 `alloc_pid` 为新进程分配唯一 PID。\n- **容器运行时**：通过 `clone(CLONE_NEWPID)` 创建 PID 命名空间，实现容器内 PID 隔离。\n- **检查点/恢复（CRIU）**：使用 `set_tid` 参数在恢复进程时精确还原原始 PID。\n- **pidfd 机制**：`pid->wait_pidfd` 支持通过文件描述符等待进程退出（`pidfd_send_signal` 等系统调用）。\n- **命名空间清理**：当容器退出时，`free_pid` 触发 reaper 唤醒，确保孤儿进程被正确回收。",
      "similarity": 0.5473794937133789,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/pid.c",
          "start_line": 109,
          "end_line": 221,
          "content": [
            "void put_pid(struct pid *pid)",
            "{",
            "\tstruct pid_namespace *ns;",
            "",
            "\tif (!pid)",
            "\t\treturn;",
            "",
            "\tns = pid->numbers[pid->level].ns;",
            "\tif (refcount_dec_and_test(&pid->count)) {",
            "\t\tkmem_cache_free(ns->pid_cachep, pid);",
            "\t\tput_pid_ns(ns);",
            "\t}",
            "}",
            "static void delayed_put_pid(struct rcu_head *rhp)",
            "{",
            "\tstruct pid *pid = container_of(rhp, struct pid, rcu);",
            "\tput_pid(pid);",
            "}",
            "void free_pid(struct pid *pid)",
            "{",
            "\t/* We can be called with write_lock_irq(&tasklist_lock) held */",
            "\tint i;",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&pidmap_lock, flags);",
            "\tfor (i = 0; i <= pid->level; i++) {",
            "\t\tstruct upid *upid = pid->numbers + i;",
            "\t\tstruct pid_namespace *ns = upid->ns;",
            "\t\tswitch (--ns->pid_allocated) {",
            "\t\tcase 2:",
            "\t\tcase 1:",
            "\t\t\t/* When all that is left in the pid namespace",
            "\t\t\t * is the reaper wake up the reaper.  The reaper",
            "\t\t\t * may be sleeping in zap_pid_ns_processes().",
            "\t\t\t */",
            "\t\t\twake_up_process(ns->child_reaper);",
            "\t\t\tbreak;",
            "\t\tcase PIDNS_ADDING:",
            "\t\t\t/* Handle a fork failure of the first process */",
            "\t\t\tWARN_ON(ns->child_reaper);",
            "\t\t\tns->pid_allocated = 0;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tidr_remove(&ns->idr, upid->nr);",
            "\t}",
            "\tpidfs_remove_pid(pid);",
            "\tspin_unlock_irqrestore(&pidmap_lock, flags);",
            "",
            "\tcall_rcu(&pid->rcu, delayed_put_pid);",
            "}",
            "void disable_pid_allocation(struct pid_namespace *ns)",
            "{",
            "\tspin_lock_irq(&pidmap_lock);",
            "\tns->pid_allocated &= ~PIDNS_ADDING;",
            "\tspin_unlock_irq(&pidmap_lock);",
            "}",
            "void attach_pid(struct task_struct *task, enum pid_type type)",
            "{",
            "\tstruct pid *pid = *task_pid_ptr(task, type);",
            "\thlist_add_head_rcu(&task->pid_links[type], &pid->tasks[type]);",
            "}",
            "static void __change_pid(struct task_struct *task, enum pid_type type,",
            "\t\t\tstruct pid *new)",
            "{",
            "\tstruct pid **pid_ptr = task_pid_ptr(task, type);",
            "\tstruct pid *pid;",
            "\tint tmp;",
            "",
            "\tpid = *pid_ptr;",
            "",
            "\thlist_del_rcu(&task->pid_links[type]);",
            "\t*pid_ptr = new;",
            "",
            "\tif (type == PIDTYPE_PID) {",
            "\t\tWARN_ON_ONCE(pid_has_task(pid, PIDTYPE_PID));",
            "\t\twake_up_all(&pid->wait_pidfd);",
            "\t}",
            "",
            "\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )",
            "\t\tif (pid_has_task(pid, tmp))",
            "\t\t\treturn;",
            "",
            "\tfree_pid(pid);",
            "}",
            "void detach_pid(struct task_struct *task, enum pid_type type)",
            "{",
            "\t__change_pid(task, type, NULL);",
            "}",
            "void change_pid(struct task_struct *task, enum pid_type type,",
            "\t\tstruct pid *pid)",
            "{",
            "\t__change_pid(task, type, pid);",
            "\tattach_pid(task, type);",
            "}",
            "void exchange_tids(struct task_struct *left, struct task_struct *right)",
            "{",
            "\tstruct pid *pid1 = left->thread_pid;",
            "\tstruct pid *pid2 = right->thread_pid;",
            "\tstruct hlist_head *head1 = &pid1->tasks[PIDTYPE_PID];",
            "\tstruct hlist_head *head2 = &pid2->tasks[PIDTYPE_PID];",
            "",
            "\t/* Swap the single entry tid lists */",
            "\thlists_swap_heads_rcu(head1, head2);",
            "",
            "\t/* Swap the per task_struct pid */",
            "\trcu_assign_pointer(left->thread_pid, pid2);",
            "\trcu_assign_pointer(right->thread_pid, pid1);",
            "",
            "\t/* Swap the cached value */",
            "\tWRITE_ONCE(left->pid, pid_nr(pid2));",
            "\tWRITE_ONCE(right->pid, pid_nr(pid1));",
            "}"
          ],
          "function_name": "put_pid, delayed_put_pid, free_pid, disable_pid_allocation, attach_pid, __change_pid, detach_pid, change_pid, exchange_tids",
          "description": "实现PID引用计数管理、释放逻辑及任务PID绑定操作，通过锁保护PID分配状态变更，利用RCU机制延迟释放内存，并处理进程ID类型切换和线程ID交换。",
          "similarity": 0.5428014397621155
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/pid.c",
          "start_line": 402,
          "end_line": 488,
          "content": [
            "void transfer_pid(struct task_struct *old, struct task_struct *new,",
            "\t\t\t   enum pid_type type)",
            "{",
            "\tWARN_ON_ONCE(type == PIDTYPE_PID);",
            "\thlist_replace_rcu(&old->pid_links[type], &new->pid_links[type]);",
            "}",
            "pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)",
            "{",
            "\tstruct upid *upid;",
            "\tpid_t nr = 0;",
            "",
            "\tif (pid && ns->level <= pid->level) {",
            "\t\tupid = &pid->numbers[ns->level];",
            "\t\tif (upid->ns == ns)",
            "\t\t\tnr = upid->nr;",
            "\t}",
            "\treturn nr;",
            "}",
            "pid_t pid_vnr(struct pid *pid)",
            "{",
            "\treturn pid_nr_ns(pid, task_active_pid_ns(current));",
            "}",
            "pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,",
            "\t\t\tstruct pid_namespace *ns)",
            "{",
            "\tpid_t nr = 0;",
            "",
            "\trcu_read_lock();",
            "\tif (!ns)",
            "\t\tns = task_active_pid_ns(current);",
            "\tnr = pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);",
            "\trcu_read_unlock();",
            "",
            "\treturn nr;",
            "}",
            "static int pidfd_create(struct pid *pid, unsigned int flags)",
            "{",
            "\tint pidfd;",
            "\tstruct file *pidfd_file;",
            "",
            "\tpidfd = pidfd_prepare(pid, flags, &pidfd_file);",
            "\tif (pidfd < 0)",
            "\t\treturn pidfd;",
            "",
            "\tfd_install(pidfd, pidfd_file);",
            "\treturn pidfd;",
            "}",
            "void __init pid_idr_init(void)",
            "{",
            "\t/* Verify no one has done anything silly: */",
            "\tBUILD_BUG_ON(PID_MAX_LIMIT >= PIDNS_ADDING);",
            "",
            "\t/* bump default and minimum pid_max based on number of cpus */",
            "\tpid_max = min(pid_max_max, max_t(int, pid_max,",
            "\t\t\t\tPIDS_PER_CPU_DEFAULT * num_possible_cpus()));",
            "\tpid_max_min = max_t(int, pid_max_min,",
            "\t\t\t\tPIDS_PER_CPU_MIN * num_possible_cpus());",
            "\tpr_info(\"pid_max: default: %u minimum: %u\\n\", pid_max, pid_max_min);",
            "",
            "\tidr_init(&init_pid_ns.idr);",
            "",
            "\tinit_pid_ns.pid_cachep = kmem_cache_create(\"pid\",",
            "\t\t\tstruct_size_t(struct pid, numbers, 1),",
            "\t\t\t__alignof__(struct pid),",
            "\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT,",
            "\t\t\tNULL);",
            "}",
            "static int pidfd_getfd(struct pid *pid, int fd)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct file *file;",
            "\tint ret;",
            "",
            "\ttask = get_pid_task(pid, PIDTYPE_PID);",
            "\tif (!task)",
            "\t\treturn -ESRCH;",
            "",
            "\tfile = __pidfd_fget(task, fd);",
            "\tput_task_struct(task);",
            "\tif (IS_ERR(file))",
            "\t\treturn PTR_ERR(file);",
            "",
            "\tret = receive_fd(file, O_CLOEXEC);",
            "\tfput(file);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "transfer_pid, pid_nr_ns, pid_vnr, __task_pid_nr_ns, pidfd_create, pid_idr_init, pidfd_getfd",
          "description": "提供跨命名空间PID查询接口及文件描述符创建功能，初始化ID分配器并配置PID命名空间层级关系，支持基于IDR的高效PID索引管理。",
          "similarity": 0.49565547704696655
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/pid.c",
          "start_line": 1,
          "end_line": 108,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Generic pidhash and scalable, time-bounded PID allocator",
            " *",
            " * (C) 2002-2003 Nadia Yvette Chambers, IBM",
            " * (C) 2004 Nadia Yvette Chambers, Oracle",
            " * (C) 2002-2004 Ingo Molnar, Red Hat",
            " *",
            " * pid-structures are backing objects for tasks sharing a given ID to chain",
            " * against. There is very little to them aside from hashing them and",
            " * parking tasks using given ID's on a list.",
            " *",
            " * The hash is always changed with the tasklist_lock write-acquired,",
            " * and the hash is only accessed with the tasklist_lock at least",
            " * read-acquired, so there's no additional SMP locking needed here.",
            " *",
            " * We have a list of bitmap pages, which bitmaps represent the PID space.",
            " * Allocating and freeing PIDs is completely lockless. The worst-case",
            " * allocation scenario when all but one out of 1 million PIDs possible are",
            " * allocated already: the scanning of 32 list entries and at most PAGE_SIZE",
            " * bytes. The typical fastpath is a single successful setbit. Freeing is O(1).",
            " *",
            " * Pid namespaces:",
            " *    (C) 2007 Pavel Emelyanov <xemul@openvz.org>, OpenVZ, SWsoft Inc.",
            " *    (C) 2007 Sukadev Bhattiprolu <sukadev@us.ibm.com>, IBM",
            " *     Many thanks to Oleg Nesterov for comments and help",
            " *",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/rculist.h>",
            "#include <linux/memblock.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/refcount.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/idr.h>",
            "#include <linux/pidfs.h>",
            "#include <linux/seqlock.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/pidfd.h>",
            "",
            "struct pid init_struct_pid = {",
            "\t.count\t\t= REFCOUNT_INIT(1),",
            "\t.tasks\t\t= {",
            "\t\t{ .first = NULL },",
            "\t\t{ .first = NULL },",
            "\t\t{ .first = NULL },",
            "\t},",
            "\t.level\t\t= 0,",
            "\t.numbers\t= { {",
            "\t\t.nr\t\t= 0,",
            "\t\t.ns\t\t= &init_pid_ns,",
            "\t}, }",
            "};",
            "",
            "int pid_max = PID_MAX_DEFAULT;",
            "",
            "int pid_max_min = RESERVED_PIDS + 1;",
            "int pid_max_max = PID_MAX_LIMIT;",
            "",
            "/*",
            " * PID-map pages start out as NULL, they get allocated upon",
            " * first use and are never deallocated. This way a low pid_max",
            " * value does not cause lots of bitmaps to be allocated, but",
            " * the scheme scales to up to 4 million PIDs, runtime.",
            " */",
            "struct pid_namespace init_pid_ns = {",
            "\t.ns.count = REFCOUNT_INIT(2),",
            "\t.idr = IDR_INIT(init_pid_ns.idr),",
            "\t.pid_allocated = PIDNS_ADDING,",
            "\t.level = 0,",
            "\t.child_reaper = &init_task,",
            "\t.user_ns = &init_user_ns,",
            "\t.ns.inum = PROC_PID_INIT_INO,",
            "#ifdef CONFIG_PID_NS",
            "\t.ns.ops = &pidns_operations,",
            "#endif",
            "#if defined(CONFIG_SYSCTL) && defined(CONFIG_MEMFD_CREATE)",
            "\t.memfd_noexec_scope = MEMFD_NOEXEC_SCOPE_EXEC,",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_pid_ns);",
            "",
            "/*",
            " * Note: disable interrupts while the pidmap_lock is held as an",
            " * interrupt might come in and do read_lock(&tasklist_lock).",
            " *",
            " * If we don't disable interrupts there is a nasty deadlock between",
            " * detach_pid()->free_pid() and another cpu that does",
            " * spin_lock(&pidmap_lock) followed by an interrupt routine that does",
            " * read_lock(&tasklist_lock);",
            " *",
            " * After we clean up the tasklist_lock and know there are no",
            " * irq handlers that take it we can leave the interrupts enabled.",
            " * For now it is easier to be safe than to prove it can't happen.",
            " */",
            "",
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);",
            "seqcount_spinlock_t pidmap_lock_seq = SEQCNT_SPINLOCK_ZERO(pidmap_lock_seq, &pidmap_lock);",
            ""
          ],
          "function_name": null,
          "description": "定义了PID命名空间和PID结构体的初始状态，包括全局PID最大值限制、PID映射锁及序列化机制，用于支持多层级PID分配和命名空间隔离。",
          "similarity": 0.46265989542007446
        }
      ]
    },
    {
      "source_file": "kernel/trace/rv/rv.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:10:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\rv\\rv.c`\n\n---\n\n# `trace/rv/rv.c` 技术文档\n\n## 1. 文件概述\n\n`rv.c` 是 Linux 内核中运行时验证（Runtime Verification, RV）子系统的主接口实现文件。该文件提供了注册、启用、禁用运行时监控器（monitor）的统一接口，并实现了用户空间与内核 RV 子系统交互的 tracefs 文件系统接口。RV 通过将内核实际执行轨迹与形式化规范进行比对，实现对关键行为的实时监控与异常响应，适用于安全关键系统。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct rv_monitor`**  \n  定义运行时监控器的回调接口，包括 `enable()` 和 `disable()` 等函数指针，用于挂载/卸载内核追踪点。\n\n- **`struct rv_monitor_def`**  \n  监控器定义结构体，封装 `rv_monitor` 实例及其元数据（如名称、描述、启用状态等）。\n\n- **`struct rv_interface`**  \n  表示 RV 子系统的根接口结构，包含 tracefs 目录项（如 `monitors_dir`）。\n\n- **`task_monitor_slots[]` 与 `task_monitor_count`**  \n  管理 per-task 监控器槽位的位图与计数器，限制同时启用的 per-task 监控器数量（上限为 `RV_PER_TASK_MONITORS`）。\n\n### 主要函数\n\n- **`rv_register_monitor()` / `rv_unregister_monitor()`**  \n  用于向 RV 子系统注册或注销一个监控器。\n\n- **`rv_get_task_monitor_slot()` / `rv_put_task_monitor_slot()`**  \n  分配和释放 per-task 监控器槽位，确保不超过系统限制。\n\n- **`__rv_disable_monitor()` / `rv_disable_monitor()`**  \n  禁用已启用的监控器，可选择是否同步等待所有追踪点执行完成（通过 `tracepoint_synchronize_unregister()`）。\n\n- **`monitor_enable_read_data()`**  \n  实现 tracefs 中每个监控器目录下 `enable` 文件的读取操作，返回当前启用状态（\"0\\n\" 或 \"1\\n\"）。\n\n- **`get_monitors_root()`**  \n  返回 tracefs 中 `monitors/` 目录的 dentry，供其他模块创建子目录使用。\n\n## 3. 关键实现\n\n- **互斥锁保护**  \n  全局互斥锁 `rv_interface_lock` 保护所有监控器注册、启用/禁用及槽位分配操作，确保并发安全。\n\n- **槽位管理机制**  \n  使用位图 `task_monitor_slots[]` 和计数器 `task_monitor_count` 跟踪 per-task 监控器资源使用情况，防止超额分配。\n\n- **同步禁用机制**  \n  在禁用监控器时调用 `tracepoint_synchronize_unregister()`，确保所有 CPU 上的追踪点回调执行完毕后再释放资源，避免竞态导致的数据不一致。\n\n- **tracefs 接口布局**  \n  模仿内核 tracing 子系统的 `events/` 目录结构，在 tracefs 下创建：\n  - `available_monitors`：列出所有已注册监控器\n  - `enabled_monitors`：控制监控器启用/禁用（支持前缀 `!` 禁用和清空禁用全部）\n  - `monitoring_on`：全局开关，暂停所有监控逻辑但不卸载追踪点\n  - `monitors/<name>/`：每个监控器的专属目录，包含 `desc`（描述）和 `enable`（状态控制）文件\n\n- **Lockdep 断言**  \n  关键函数（如槽位分配/释放、监控器禁用）使用 `lockdep_assert_held(&rv_interface_lock)` 确保调用者已持有锁，增强代码健壮性。\n\n## 4. 依赖关系\n\n- **内核追踪子系统**  \n  依赖 tracepoint 机制实现事件注入，使用 `tracepoint_synchronize_unregister()` 进行同步。\n  \n- **tracefs 文件系统**  \n  通过 tracefs 暴露用户接口，依赖 `<linux/fs.h>` 和 dentry 操作。\n\n- **内存管理**  \n  使用 `kmalloc()`/`kfree()`（通过 `rv.h` 中的封装）管理监控器定义结构体内存。\n\n- **模块系统**  \n  作为可加载模块实现（`MODULE_LICENSE(\"GPL\")`），支持动态加载/卸载。\n\n- **RV 子系统头文件**  \n  包含本地头文件 `\"rv.h\"`，定义监控器结构、常量（如 `RV_PER_TASK_MONITORS`）和辅助函数。\n\n- **DA_MON_EVENTS 支持**  \n  若配置 `CONFIG_DA_MON_EVENTS`，则生成 RV 专用追踪点（`<trace/events/rv.h>`）。\n\n## 5. 使用场景\n\n- **形式化验证集成**  \n  作为学术研究（如论文 *Efficient formal verification for the Linux kernel*）的工程实现，将自动机模型与内核实例绑定。\n\n- **实时行为监控**  \n  在安全关键系统（如工业控制、自动驾驶）中监控内核行为是否违反预定义规范（如“禁止在中断上下文中睡眠”）。\n\n- **调试与诊断**  \n  开发者通过启用特定监控器（如 `wip`、`wwnr`）捕获复杂并发 bug 或时序违规。\n\n- **动态策略执行**  \n  用户空间可通过写入 `enabled_monitors` 动态切换监控策略，无需重启系统。\n\n- **资源受限环境**  \n  per-task 监控器槽位限制机制确保 RV 子系统在资源受限设备上可控运行。",
      "similarity": 0.5352789759635925,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 742,
          "end_line": 798,
          "content": [
            "int rv_unregister_monitor(struct rv_monitor *monitor)",
            "{",
            "\tstruct rv_monitor_def *ptr, *next;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry_safe(ptr, next, &rv_monitors_list, list) {",
            "\t\tif (strcmp(monitor->name, ptr->monitor->name) == 0) {",
            "\t\t\trv_disable_monitor(ptr);",
            "\t\t\tlist_del(&ptr->list);",
            "\t\t\tdestroy_monitor_dir(ptr);",
            "\t\t}",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn 0;",
            "}",
            "int __init rv_init_interface(void)",
            "{",
            "\tstruct dentry *tmp;",
            "\tint retval;",
            "",
            "\trv_root.root_dir = rv_create_dir(\"rv\", NULL);",
            "\tif (!rv_root.root_dir)",
            "\t\tgoto out_err;",
            "",
            "\trv_root.monitors_dir = rv_create_dir(\"monitors\", rv_root.root_dir);",
            "\tif (!rv_root.monitors_dir)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"available_monitors\", RV_MODE_READ, rv_root.root_dir, NULL,",
            "\t\t\t     &available_monitors_ops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"enabled_monitors\", RV_MODE_WRITE, rv_root.root_dir, NULL,",
            "\t\t\t     &enabled_monitors_ops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"monitoring_on\", RV_MODE_WRITE, rv_root.root_dir, NULL,",
            "\t\t\t     &monitoring_on_fops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "\tretval = init_rv_reactors(rv_root.root_dir);",
            "\tif (retval)",
            "\t\tgoto out_err;",
            "",
            "\tturn_monitoring_on();",
            "",
            "\treturn 0;",
            "",
            "out_err:",
            "\trv_remove(rv_root.root_dir);",
            "\tprintk(KERN_ERR \"RV: Error while creating the RV interface\\n\");",
            "\treturn 1;",
            "}"
          ],
          "function_name": "rv_unregister_monitor, rv_init_interface",
          "description": "实现监控器注册注销流程，完成RV接口初始化，建立监控管理核心结构并注册基础控制接口，处理初始化失败时的资源清理。",
          "similarity": 0.48807162046432495
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 170,
          "end_line": 278,
          "content": [
            "int rv_get_task_monitor_slot(void)",
            "{",
            "\tint i;",
            "",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (task_monitor_count == RV_PER_TASK_MONITORS)",
            "\t\treturn -EBUSY;",
            "",
            "\ttask_monitor_count++;",
            "",
            "\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++) {",
            "\t\tif (task_monitor_slots[i] == false) {",
            "\t\t\ttask_monitor_slots[i] = true;",
            "\t\t\treturn i;",
            "\t\t}",
            "\t}",
            "",
            "\tWARN_ONCE(1, \"RV task_monitor_count and slots are out of sync\\n\");",
            "",
            "\treturn -EINVAL;",
            "}",
            "void rv_put_task_monitor_slot(int slot)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (slot < 0 || slot >= RV_PER_TASK_MONITORS) {",
            "\t\tWARN_ONCE(1, \"RV releasing an invalid slot!: %d\\n\", slot);",
            "\t\treturn;",
            "\t}",
            "",
            "\tWARN_ONCE(!task_monitor_slots[slot], \"RV releasing unused task_monitor_slots: %d\\n\",",
            "\t\t  slot);",
            "",
            "\ttask_monitor_count--;",
            "\ttask_monitor_slots[slot] = false;",
            "}",
            "static ssize_t monitor_enable_read_data(struct file *filp, char __user *user_buf, size_t count,",
            "\t\t\t\t\tloff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tconst char *buff;",
            "",
            "\tbuff = mdef->monitor->enabled ? \"1\\n\" : \"0\\n\";",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff)+1);",
            "}",
            "static int __rv_disable_monitor(struct rv_monitor_def *mdef, bool sync)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (mdef->monitor->enabled) {",
            "\t\tmdef->monitor->enabled = 0;",
            "\t\tmdef->monitor->disable();",
            "",
            "\t\t/*",
            "\t\t * Wait for the execution of all events to finish.",
            "\t\t * Otherwise, the data used by the monitor could",
            "\t\t * be inconsistent. i.e., if the monitor is re-enabled.",
            "\t\t */",
            "\t\tif (sync)",
            "\t\t\ttracepoint_synchronize_unregister();",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "int rv_disable_monitor(struct rv_monitor_def *mdef)",
            "{",
            "\t__rv_disable_monitor(mdef, true);",
            "\treturn 0;",
            "}",
            "int rv_enable_monitor(struct rv_monitor_def *mdef)",
            "{",
            "\tint retval;",
            "",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (mdef->monitor->enabled)",
            "\t\treturn 0;",
            "",
            "\tretval = mdef->monitor->enable();",
            "",
            "\tif (!retval)",
            "\t\tmdef->monitor->enabled = 1;",
            "",
            "\treturn retval;",
            "}",
            "static ssize_t monitor_enable_write_data(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t\t size_t count, loff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tint retval;",
            "\tbool val;",
            "",
            "\tretval = kstrtobool_from_user(user_buf, count, &val);",
            "\tif (retval)",
            "\t\treturn retval;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tif (val)",
            "\t\tretval = rv_enable_monitor(mdef);",
            "\telse",
            "\t\tretval = rv_disable_monitor(mdef);",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "",
            "\treturn retval ? : count;",
            "}"
          ],
          "function_name": "rv_get_task_monitor_slot, rv_put_task_monitor_slot, monitor_enable_read_data, __rv_disable_monitor, rv_disable_monitor, rv_enable_monitor, monitor_enable_write_data",
          "description": "管理任务级监控槽位分配与回收，实现监控启停控制逻辑，通过互斥锁保护监控状态变更并同步跟踪事件处理。",
          "similarity": 0.48780298233032227
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 317,
          "end_line": 459,
          "content": [
            "static ssize_t monitor_desc_read_data(struct file *filp, char __user *user_buf, size_t count,",
            "\t\t\t\t      loff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tchar buff[256];",
            "",
            "\tmemset(buff, 0, sizeof(buff));",
            "",
            "\tsnprintf(buff, sizeof(buff), \"%s\\n\", mdef->monitor->description);",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);",
            "}",
            "static int create_monitor_dir(struct rv_monitor_def *mdef)",
            "{",
            "\tstruct dentry *root = get_monitors_root();",
            "\tconst char *name = mdef->monitor->name;",
            "\tstruct dentry *tmp;",
            "\tint retval;",
            "",
            "\tmdef->root_d = rv_create_dir(name, root);",
            "\tif (!mdef->root_d)",
            "\t\treturn -ENOMEM;",
            "",
            "\ttmp = rv_create_file(\"enable\", RV_MODE_WRITE, mdef->root_d, mdef, &interface_enable_fops);",
            "\tif (!tmp) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_remove_root;",
            "\t}",
            "",
            "\ttmp = rv_create_file(\"desc\", RV_MODE_READ, mdef->root_d, mdef, &interface_desc_fops);",
            "\tif (!tmp) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_remove_root;",
            "\t}",
            "",
            "\tretval = reactor_populate_monitor(mdef);",
            "\tif (retval)",
            "\t\tgoto out_remove_root;",
            "",
            "\treturn 0;",
            "",
            "out_remove_root:",
            "\trv_remove(mdef->root_d);",
            "\treturn retval;",
            "}",
            "static int monitors_show(struct seq_file *m, void *p)",
            "{",
            "\tstruct rv_monitor_def *mon_def = p;",
            "",
            "\tseq_printf(m, \"%s\\n\", mon_def->monitor->name);",
            "\treturn 0;",
            "}",
            "static void monitors_stop(struct seq_file *m, void *p)",
            "{",
            "\tmutex_unlock(&rv_interface_lock);",
            "}",
            "static int available_monitors_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn seq_open(file, &available_monitors_seq_ops);",
            "};",
            "static void disable_all_monitors(void)",
            "{",
            "\tstruct rv_monitor_def *mdef;",
            "\tint enabled = 0;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list)",
            "\t\tenabled += __rv_disable_monitor(mdef, false);",
            "",
            "\tif (enabled) {",
            "\t\t/*",
            "\t\t * Wait for the execution of all events to finish.",
            "\t\t * Otherwise, the data used by the monitor could",
            "\t\t * be inconsistent. i.e., if the monitor is re-enabled.",
            "\t\t */",
            "\t\ttracepoint_synchronize_unregister();",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "}",
            "static int enabled_monitors_open(struct inode *inode, struct file *file)",
            "{",
            "\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC))",
            "\t\tdisable_all_monitors();",
            "",
            "\treturn seq_open(file, &enabled_monitors_seq_ops);",
            "};",
            "static ssize_t enabled_monitors_write(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t      size_t count, loff_t *ppos)",
            "{",
            "\tchar buff[MAX_RV_MONITOR_NAME_SIZE + 2];",
            "\tstruct rv_monitor_def *mdef;",
            "\tint retval = -EINVAL;",
            "\tbool enable = true;",
            "\tchar *ptr;",
            "\tint len;",
            "",
            "\tif (count < 1 || count > MAX_RV_MONITOR_NAME_SIZE + 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tmemset(buff, 0, sizeof(buff));",
            "",
            "\tretval = simple_write_to_buffer(buff, sizeof(buff) - 1, ppos, user_buf, count);",
            "\tif (retval < 0)",
            "\t\treturn -EFAULT;",
            "",
            "\tptr = strim(buff);",
            "",
            "\tif (ptr[0] == '!') {",
            "\t\tenable = false;",
            "\t\tptr++;",
            "\t}",
            "",
            "\tlen = strlen(ptr);",
            "\tif (!len)",
            "\t\treturn count;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tretval = -EINVAL;",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list) {",
            "\t\tif (strcmp(ptr, mdef->monitor->name) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Monitor found!",
            "\t\t */",
            "\t\tif (enable)",
            "\t\t\tretval = rv_enable_monitor(mdef);",
            "\t\telse",
            "\t\t\tretval = rv_disable_monitor(mdef);",
            "",
            "\t\tif (!retval)",
            "\t\t\tretval = count;",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "monitor_desc_read_data, create_monitor_dir, monitors_show, monitors_stop, available_monitors_open, disable_all_monitors, enabled_monitors_open, enabled_monitors_write",
          "description": "创建监控专用目录结构，实现监控描述信息读取和可用监控列表展示，支持动态监控使能状态管理和全局禁用操作。",
          "similarity": 0.4851530194282532
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 1,
          "end_line": 169,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2019-2022 Red Hat, Inc. Daniel Bristot de Oliveira <bristot@kernel.org>",
            " *",
            " * This is the online Runtime Verification (RV) interface.",
            " *",
            " * RV is a lightweight (yet rigorous) method that complements classical",
            " * exhaustive verification techniques (such as model checking and",
            " * theorem proving) with a more practical approach to complex systems.",
            " *",
            " * RV works by analyzing the trace of the system's actual execution,",
            " * comparing it against a formal specification of the system behavior.",
            " * RV can give precise information on the runtime behavior of the",
            " * monitored system while enabling the reaction for unexpected",
            " * events, avoiding, for example, the propagation of a failure on",
            " * safety-critical systems.",
            " *",
            " * The development of this interface roots in the development of the",
            " * paper:",
            " *",
            " * De Oliveira, Daniel Bristot; Cucinotta, Tommaso; De Oliveira, Romulo",
            " * Silva. Efficient formal verification for the Linux kernel. In:",
            " * International Conference on Software Engineering and Formal Methods.",
            " * Springer, Cham, 2019. p. 315-332.",
            " *",
            " * And:",
            " *",
            " * De Oliveira, Daniel Bristot, et al. Automata-based formal analysis",
            " * and verification of the real-time Linux kernel. PhD Thesis, 2020.",
            " *",
            " * == Runtime monitor interface ==",
            " *",
            " * A monitor is the central part of the runtime verification of a system.",
            " *",
            " * The monitor stands in between the formal specification of the desired",
            " * (or undesired) behavior, and the trace of the actual system.",
            " *",
            " * In Linux terms, the runtime verification monitors are encapsulated",
            " * inside the \"RV monitor\" abstraction. A RV monitor includes a reference",
            " * model of the system, a set of instances of the monitor (per-cpu monitor,",
            " * per-task monitor, and so on), and the helper functions that glue the",
            " * monitor to the system via trace. Generally, a monitor includes some form",
            " * of trace output as a reaction for event parsing and exceptions,",
            " * as depicted bellow:",
            " *",
            " * Linux  +----- RV Monitor ----------------------------------+ Formal",
            " *  Realm |                                                   |  Realm",
            " *  +-------------------+     +----------------+     +-----------------+",
            " *  |   Linux kernel    |     |     Monitor    |     |     Reference   |",
            " *  |     Tracing       |  -> |   Instance(s)  | <-  |       Model     |",
            " *  | (instrumentation) |     | (verification) |     | (specification) |",
            " *  +-------------------+     +----------------+     +-----------------+",
            " *         |                          |                       |",
            " *         |                          V                       |",
            " *         |                     +----------+                 |",
            " *         |                     | Reaction |                 |",
            " *         |                     +--+--+--+-+                 |",
            " *         |                        |  |  |                   |",
            " *         |                        |  |  +-> trace output ?  |",
            " *         +------------------------|--|----------------------+",
            " *                                  |  +----> panic ?",
            " *                                  +-------> <user-specified>",
            " *",
            " * This file implements the interface for loading RV monitors, and",
            " * to control the verification session.",
            " *",
            " * == Registering monitors ==",
            " *",
            " * The struct rv_monitor defines a set of callback functions to control",
            " * a verification session. For instance, when a given monitor is enabled,",
            " * the \"enable\" callback function is called to hook the instrumentation",
            " * functions to the kernel trace events. The \"disable\" function is called",
            " * when disabling the verification session.",
            " *",
            " * A RV monitor is registered via:",
            " *   int rv_register_monitor(struct rv_monitor *monitor);",
            " * And unregistered via:",
            " *   int rv_unregister_monitor(struct rv_monitor *monitor);",
            " *",
            " * == User interface ==",
            " *",
            " * The user interface resembles kernel tracing interface. It presents",
            " * these files:",
            " *",
            " *  \"available_monitors\"",
            " *    - List the available monitors, one per line.",
            " *",
            " *    For example:",
            " *      # cat available_monitors",
            " *      wip",
            " *      wwnr",
            " *",
            " *  \"enabled_monitors\"",
            " *    - Lists the enabled monitors, one per line;",
            " *    - Writing to it enables a given monitor;",
            " *    - Writing a monitor name with a '!' prefix disables it;",
            " *    - Truncating the file disables all enabled monitors.",
            " *",
            " *    For example:",
            " *      # cat enabled_monitors",
            " *      # echo wip > enabled_monitors",
            " *      # echo wwnr >> enabled_monitors",
            " *      # cat enabled_monitors",
            " *      wip",
            " *      wwnr",
            " *      # echo '!wip' >> enabled_monitors",
            " *      # cat enabled_monitors",
            " *      wwnr",
            " *      # echo > enabled_monitors",
            " *      # cat enabled_monitors",
            " *      #",
            " *",
            " *    Note that more than one monitor can be enabled concurrently.",
            " *",
            " *  \"monitoring_on\"",
            " *    - It is an on/off general switcher for monitoring. Note",
            " *    that it does not disable enabled monitors or detach events,",
            " *    but stops the per-entity monitors from monitoring the events",
            " *    received from the instrumentation. It resembles the \"tracing_on\"",
            " *    switcher.",
            " *",
            " *  \"monitors/\"",
            " *    Each monitor will have its own directory inside \"monitors/\". There",
            " *    the monitor specific files will be presented.",
            " *    The \"monitors/\" directory resembles the \"events\" directory on",
            " *    tracefs.",
            " *",
            " *    For example:",
            " *      # cd monitors/wip/",
            " *      # ls",
            " *      desc  enable",
            " *      # cat desc",
            " *      auto-generated wakeup in preemptive monitor.",
            " *      # cat enable",
            " *      0",
            " *",
            " *  For further information, see:",
            " *   Documentation/trace/rv/runtime-verification.rst",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "",
            "#ifdef CONFIG_DA_MON_EVENTS",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/rv.h>",
            "#endif",
            "",
            "#include \"rv.h\"",
            "",
            "DEFINE_MUTEX(rv_interface_lock);",
            "",
            "static struct rv_interface rv_root;",
            "",
            "struct dentry *get_monitors_root(void)",
            "{",
            "\treturn rv_root.monitors_dir;",
            "}",
            "",
            "/*",
            " * Interface for the monitor register.",
            " */",
            "static LIST_HEAD(rv_monitors_list);",
            "",
            "static int task_monitor_count;",
            "static bool task_monitor_slots[RV_PER_TASK_MONITORS];",
            ""
          ],
          "function_name": null,
          "description": "定义RV监控接口的基础结构，包括互斥锁、全局监控根节点及监控列表，为后续监控注册和管理提供基础设施。",
          "similarity": 0.4621371328830719
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 586,
          "end_line": 710,
          "content": [
            "bool rv_monitoring_on(void)",
            "{",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_rmb();",
            "\treturn READ_ONCE(monitoring_on);",
            "}",
            "static ssize_t monitoring_on_read_data(struct file *filp, char __user *user_buf,",
            "\t\t\t\t       size_t count, loff_t *ppos)",
            "{",
            "\tconst char *buff;",
            "",
            "\tbuff = rv_monitoring_on() ? \"1\\n\" : \"0\\n\";",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);",
            "}",
            "static void turn_monitoring_off(void)",
            "{",
            "\tWRITE_ONCE(monitoring_on, false);",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_wmb();",
            "}",
            "static void reset_all_monitors(void)",
            "{",
            "\tstruct rv_monitor_def *mdef;",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list) {",
            "\t\tif (mdef->monitor->enabled)",
            "\t\t\tmdef->monitor->reset();",
            "\t}",
            "}",
            "static void turn_monitoring_on(void)",
            "{",
            "\tWRITE_ONCE(monitoring_on, true);",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_wmb();",
            "}",
            "static void turn_monitoring_on_with_reset(void)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (rv_monitoring_on())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Monitors might be out of sync with the system if events were not",
            "\t * processed because of !rv_monitoring_on().",
            "\t *",
            "\t * Reset all monitors, forcing a re-sync.",
            "\t */",
            "\treset_all_monitors();",
            "\tturn_monitoring_on();",
            "}",
            "static ssize_t monitoring_on_write_data(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t\tsize_t count, loff_t *ppos)",
            "{",
            "\tint retval;",
            "\tbool val;",
            "",
            "\tretval = kstrtobool_from_user(user_buf, count, &val);",
            "\tif (retval)",
            "\t\treturn retval;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tif (val)",
            "\t\tturn_monitoring_on_with_reset();",
            "\telse",
            "\t\tturn_monitoring_off();",
            "",
            "\t/*",
            "\t * Wait for the execution of all events to finish",
            "\t * before returning to user-space.",
            "\t */",
            "\ttracepoint_synchronize_unregister();",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "",
            "\treturn count;",
            "}",
            "static void destroy_monitor_dir(struct rv_monitor_def *mdef)",
            "{",
            "\treactor_cleanup_monitor(mdef);",
            "\trv_remove(mdef->root_d);",
            "}",
            "int rv_register_monitor(struct rv_monitor *monitor)",
            "{",
            "\tstruct rv_monitor_def *r;",
            "\tint retval = 0;",
            "",
            "\tif (strlen(monitor->name) >= MAX_RV_MONITOR_NAME_SIZE) {",
            "\t\tpr_info(\"Monitor %s has a name longer than %d\\n\", monitor->name,",
            "\t\t\tMAX_RV_MONITOR_NAME_SIZE);",
            "\t\treturn -1;",
            "\t}",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry(r, &rv_monitors_list, list) {",
            "\t\tif (strcmp(monitor->name, r->monitor->name) == 0) {",
            "\t\t\tpr_info(\"Monitor %s is already registered\\n\", monitor->name);",
            "\t\t\tretval = -1;",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "\t}",
            "",
            "\tr = kzalloc(sizeof(struct rv_monitor_def), GFP_KERNEL);",
            "\tif (!r) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tr->monitor = monitor;",
            "",
            "\tretval = create_monitor_dir(r);",
            "\tif (retval) {",
            "\t\tkfree(r);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tlist_add_tail(&r->list, &rv_monitors_list);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "rv_monitoring_on, monitoring_on_read_data, turn_monitoring_off, reset_all_monitors, turn_monitoring_on, turn_monitoring_on_with_reset, monitoring_on_write_data, destroy_monitor_dir, rv_register_monitor",
          "description": "控制整体监控开关状态，提供监控开关切换接口，包含监控状态同步和异常恢复机制，确保监控器与系统状态一致性。",
          "similarity": 0.44583940505981445
        }
      ]
    },
    {
      "source_file": "kernel/trace/pid_list.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:04:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\pid_list.c`\n\n---\n\n# `trace/pid_list.c` 技术文档\n\n## 1. 文件概述\n\n`trace/pid_list.c` 实现了一个高效、可扩展的 PID（进程标识符）集合管理机制，用于 Linux 内核跟踪子系统（ftrace）中对特定进程的过滤控制。该文件通过三级位图结构（upper1 → upper2 → lower）将 PID 空间分层组织，支持快速的 PID 设置、清除、查询及遍历操作，同时兼顾内存使用效率和并发安全性。该实现特别适用于需要动态跟踪大量进程但又不能占用过多连续内存的场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trace_pid_list_is_set()`：检查指定 PID 是否在列表中（用于调度时快速判断是否应跟踪该任务）。\n- `trace_pid_list_set()`：将指定 PID 加入跟踪列表。\n- `trace_pid_list_clear()`：从跟踪列表中移除指定 PID，并在对应位图块为空时自动释放内存。\n- `trace_pid_list_next()`：从给定 PID 开始查找下一个存在于列表中的 PID（用于遍历所有被跟踪的 PID）。\n\n### 辅助内联函数\n\n- `get_lower_chunk()` / `put_lower_chunk()`：从空闲链表中分配或归还底层位图块（`lower_chunk`）。\n- `get_upper_chunk()` / `put_upper_chunk()`：从空闲链表中分配或归还上层索引块（`upper_chunk`）。\n- `upper_empty()`：判断一个 `upper_chunk` 是否完全为空（所有 `lower_chunk` 均为 NULL）。\n- `pid_split()` / `pid_join()`：将 PID 拆分为三级索引（upper1, upper2, lower）或将三级索引合并为 PID。\n\n### 关键数据结构（定义于 `pid_list.h`）\n\n- `struct trace_pid_list`：PID 列表的主结构体，包含：\n  - 两级指针数组：`upper[UPPER_MAX]` 指向 `upper_chunk`。\n  - 空闲块链表：`lower_list` 和 `upper_list` 用于缓存未使用的块。\n  - 计数器：`free_lower_chunks` 和 `free_upper_chunks`。\n  - 自旋锁：`lock` 保证并发安全。\n  - 中断工作队列：`refill_irqwork` 用于异步补充空闲块。\n- `union upper_chunk`：包含一个指针数组 `data[UPPER_MAX]`，每个元素指向一个 `lower_chunk`。\n- `union lower_chunk`：包含一个位图数组 `data[LOWER_SIZE]`，用于存储 `LOWER_MAX` 个 PID 的存在状态。\n\n## 3. 关键实现\n\n### 三级分层位图结构\n- **设计目的**：避免为整个 PID 空间（最大 `PID_MAX_LIMIT`，通常为 4194304）分配连续大内存。\n- **层级划分**：\n  - **Upper1**：最高位，索引 `trace_pid_list->upper[]` 数组（大小 `UPPER_MAX`）。\n  - **Upper2**：中间位，索引 `upper_chunk->data[]` 数组（大小 `UPPER_MAX`）。\n  - **Lower**：最低位，索引 `lower_chunk->data` 位图中的具体位（范围 `0` 到 `LOWER_MAX-1`）。\n- **内存效率**：仅当某 PID 范围被使用时才动态分配对应的 `upper_chunk` 和 `lower_chunk`。\n\n### 并发与内存管理\n- **自旋锁保护**：所有操作均在 `pid_list->lock` 保护下进行，使用 `raw_spin_lock_irqsave()` 禁用本地中断以确保在硬中断上下文（如调度器）中的安全性。\n- **空闲块缓存**：通过 `lower_list` 和 `upper_list` 链表缓存已释放的块，避免频繁的内存分配/释放。\n- **异步补充机制**：当空闲块数量低于阈值 `CHUNK_REALLOC` 时，通过 `irq_work_queue()` 触发中断上下文工作（`refill_irqwork`）来补充空闲块，避免在持有调度器锁时执行耗时的内存分配。\n\n### 动态释放\n- 在 `trace_pid_list_clear()` 中，清除位后检查 `lower_chunk` 是否全零：\n  - 若是，则将其归还到 `lower_list` 并置空 `upper_chunk->data[upper2]`。\n  - 进一步检查 `upper_chunk` 是否完全为空（所有 `data[]` 为 NULL），若是则归还到 `upper_list` 并置空 `pid_list->upper[upper1]`。\n\n### PID 遍历算法\n- `trace_pid_list_next()` 从给定 PID 的拆分索引开始，按 `upper1 → upper2 → lower` 顺序遍历：\n  - 外层循环遍历 `upper1`（从起始值到 `UPPER_MASK`）。\n  - 内层循环遍历 `upper2`（从起始值或 0 到 `UPPER_MASK`）。\n  - 在有效的 `lower_chunk` 中使用 `find_next_bit()` 查找下一个置位的 PID。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/spinlock.h>`：提供自旋锁原语。\n  - `<linux/irq_work.h>`：提供中断上下文工作队列机制。\n  - `<linux/slab.h>`：提供内存分配接口（由 `pid_list.h` 或其他文件间接使用）。\n  - `\"trace.h\"`：包含跟踪子系统通用定义及 `pid_list.h`。\n- **数据结构依赖**：依赖 `pid_list.h` 中定义的 `struct trace_pid_list`、`union upper_chunk`、`union lower_chunk` 及相关常量（如 `UPPER_MASK`、`LOWER_MASK`、`CHUNK_REALLOC` 等）。\n- **内核子系统**：作为 ftrace 跟踪过滤机制的核心组件，被调度器（`kernel/sched/`）和 tracefs 接口（`kernel/trace/`）调用。\n\n## 5. 使用场景\n\n- **动态进程跟踪**：用户通过 tracefs 接口（如 `set_ftrace_pid`）指定要跟踪的进程 PID，内核调用 `trace_pid_list_set()` 将其加入列表。\n- **调度器过滤**：在任务切换时（`__schedule()`），调度器调用 `trace_pid_list_is_set()` 快速判断当前任务是否应被跟踪，决定是否触发跟踪事件。\n- **进程生命周期管理**：\n  - **Fork**：若父进程在跟踪列表中且配置了跟踪子进程，则新进程 PID 通过 `trace_pid_list_set()` 加入列表。\n  - **Exit**：任务退出时，若其 PID 在列表中，则通过 `trace_pid_list_clear()` 移除。\n- **PID 列表遍历**：调试工具或内核接口需要枚举所有被跟踪的 PID 时，调用 `trace_pid_list_next()` 进行迭代。\n- **内存压力处理**：在高并发设置/清除 PID 时，通过异步 `irq_work` 补充空闲块，避免在关键路径（如调度器）中阻塞。",
      "similarity": 0.528957724571228,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 457,
          "end_line": 495,
          "content": [
            "void trace_pid_list_free(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *upper;",
            "\tunion lower_chunk *lower;",
            "\tint i, j;",
            "",
            "\tif (!pid_list)",
            "\t\treturn;",
            "",
            "\tirq_work_sync(&pid_list->refill_irqwork);",
            "",
            "\twhile (pid_list->lower_list) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->lower_list;",
            "\t\tpid_list->lower_list = pid_list->lower_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\twhile (pid_list->upper_list) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->upper_list;",
            "\t\tpid_list->upper_list = pid_list->upper_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\tfor (i = 0; i < UPPER1_SIZE; i++) {",
            "\t\tupper = pid_list->upper[i];",
            "\t\tif (upper) {",
            "\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {",
            "\t\t\t\tlower = upper->data[j];",
            "\t\t\t\tkfree(lower);",
            "\t\t\t}",
            "\t\t\tkfree(upper);",
            "\t\t}",
            "\t}",
            "\tkfree(pid_list);",
            "}"
          ],
          "function_name": "trace_pid_list_free",
          "description": "释放trace_pid_list及其关联的所有内存资源，递归回收上层块和下层块链表，彻底清理PID跟踪结构体占用的内存量。",
          "similarity": 0.5285965204238892
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 60,
          "end_line": 180,
          "content": [
            "static inline void put_lower_chunk(struct trace_pid_list *pid_list,",
            "\t\t\t\t   union lower_chunk *chunk)",
            "{",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tchunk->next = pid_list->lower_list;",
            "\tpid_list->lower_list = chunk;",
            "\tpid_list->free_lower_chunks++;",
            "}",
            "static inline void put_upper_chunk(struct trace_pid_list *pid_list,",
            "\t\t\t\t   union upper_chunk *chunk)",
            "{",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tchunk->next = pid_list->upper_list;",
            "\tpid_list->upper_list = chunk;",
            "\tpid_list->free_upper_chunks++;",
            "}",
            "static inline bool upper_empty(union upper_chunk *chunk)",
            "{",
            "\t/*",
            "\t * If chunk->data has no lower chunks, it will be the same",
            "\t * as a zeroed bitmask. Use find_first_bit() to test it",
            "\t * and if it doesn't find any bits set, then the array",
            "\t * is empty.",
            "\t */",
            "\tint bit = find_first_bit((unsigned long *)chunk->data,",
            "\t\t\t\t sizeof(chunk->data) * 8);",
            "\treturn bit >= sizeof(chunk->data) * 8;",
            "}",
            "static inline int pid_split(unsigned int pid, unsigned int *upper1,",
            "\t\t\t     unsigned int *upper2, unsigned int *lower)",
            "{",
            "\t/* MAX_PID should cover all pids */",
            "\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);",
            "",
            "\t/* In case a bad pid is passed in, then fail */",
            "\tif (unlikely(pid >= MAX_PID))",
            "\t\treturn -1;",
            "",
            "\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;",
            "\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;",
            "\t*lower = pid & LOWER_MASK;",
            "",
            "\treturn 0;",
            "}",
            "static inline unsigned int pid_join(unsigned int upper1,",
            "\t\t\t\t    unsigned int upper2, unsigned int lower)",
            "{",
            "\treturn ((upper1 & UPPER_MASK) << UPPER1_SHIFT) |",
            "\t\t((upper2 & UPPER_MASK) << UPPER2_SHIFT) |",
            "\t\t(lower & LOWER_MASK);",
            "}",
            "bool trace_pid_list_is_set(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "\tbool ret = false;",
            "",
            "\tif (!pid_list)",
            "\t\treturn false;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn false;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (upper_chunk) {",
            "\t\tlower_chunk = upper_chunk->data[upper2];",
            "\t\tif (lower_chunk)",
            "\t\t\tret = test_bit(lower, lower_chunk->data);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "int trace_pid_list_set(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "\tint ret;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (!upper_chunk) {",
            "\t\tupper_chunk = get_upper_chunk(pid_list);",
            "\t\tif (!upper_chunk) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tpid_list->upper[upper1] = upper_chunk;",
            "\t}",
            "\tlower_chunk = upper_chunk->data[upper2];",
            "\tif (!lower_chunk) {",
            "\t\tlower_chunk = get_lower_chunk(pid_list);",
            "\t\tif (!lower_chunk) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tupper_chunk->data[upper2] = lower_chunk;",
            "\t}",
            "\tset_bit(lower, lower_chunk->data);",
            "\tret = 0;",
            " out:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "put_lower_chunk, put_upper_chunk, upper_empty, pid_split, pid_join, trace_pid_list_is_set, trace_pid_list_set",
          "description": "提供PID存储结构的辅助操作，包括块回收、位掩码操作、PID地址转换及集合状态查询与更新，实现基于多级位图的高效PID追踪。",
          "similarity": 0.5164718627929688
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 221,
          "end_line": 377,
          "content": [
            "int trace_pid_list_clear(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (!upper_chunk)",
            "\t\tgoto out;",
            "",
            "\tlower_chunk = upper_chunk->data[upper2];",
            "\tif (!lower_chunk)",
            "\t\tgoto out;",
            "",
            "\tclear_bit(lower, lower_chunk->data);",
            "",
            "\t/* if there's no more bits set, add it to the free list */",
            "\tif (find_first_bit(lower_chunk->data, LOWER_MAX) >= LOWER_MAX) {",
            "\t\tput_lower_chunk(pid_list, lower_chunk);",
            "\t\tupper_chunk->data[upper2] = NULL;",
            "\t\tif (upper_empty(upper_chunk)) {",
            "\t\t\tput_upper_chunk(pid_list, upper_chunk);",
            "\t\t\tpid_list->upper[upper1] = NULL;",
            "\t\t}",
            "\t}",
            " out:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_next(struct trace_pid_list *pid_list, unsigned int pid,",
            "\t\t\tunsigned int *next)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tfor (; upper1 <= UPPER_MASK; upper1++, upper2 = 0) {",
            "\t\tupper_chunk = pid_list->upper[upper1];",
            "",
            "\t\tif (!upper_chunk)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (; upper2 <= UPPER_MASK; upper2++, lower = 0) {",
            "\t\t\tlower_chunk = upper_chunk->data[upper2];",
            "\t\t\tif (!lower_chunk)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tlower = find_next_bit(lower_chunk->data, LOWER_MAX,",
            "\t\t\t\t\t    lower);",
            "\t\t\tif (lower < LOWER_MAX)",
            "\t\t\t\tgoto found;",
            "\t\t}",
            "\t}",
            "",
            " found:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\tif (upper1 > UPPER_MASK)",
            "\t\treturn -1;",
            "",
            "\t*next = pid_join(upper1, upper2, lower);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_first(struct trace_pid_list *pid_list, unsigned int *pid)",
            "{",
            "\treturn trace_pid_list_next(pid_list, 0, pid);",
            "}",
            "static void pid_list_refill_irq(struct irq_work *iwork)",
            "{",
            "\tstruct trace_pid_list *pid_list = container_of(iwork, struct trace_pid_list,",
            "\t\t\t\t\t\t       refill_irqwork);",
            "\tunion upper_chunk *upper = NULL;",
            "\tunion lower_chunk *lower = NULL;",
            "\tunion upper_chunk **upper_next = &upper;",
            "\tunion lower_chunk **lower_next = &lower;",
            "\tint upper_count;",
            "\tint lower_count;",
            "\tint ucnt = 0;",
            "\tint lcnt = 0;",
            "",
            " again:",
            "\traw_spin_lock(&pid_list->lock);",
            "\tupper_count = CHUNK_ALLOC - pid_list->free_upper_chunks;",
            "\tlower_count = CHUNK_ALLOC - pid_list->free_lower_chunks;",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\tif (upper_count <= 0 && lower_count <= 0)",
            "\t\treturn;",
            "",
            "\twhile (upper_count-- > 0) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*upper_next = chunk;",
            "\t\tupper_next = &chunk->next;",
            "\t\tucnt++;",
            "\t}",
            "",
            "\twhile (lower_count-- > 0) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*lower_next = chunk;",
            "\t\tlower_next = &chunk->next;",
            "\t\tlcnt++;",
            "\t}",
            "",
            "\traw_spin_lock(&pid_list->lock);",
            "\tif (upper) {",
            "\t\t*upper_next = pid_list->upper_list;",
            "\t\tpid_list->upper_list = upper;",
            "\t\tpid_list->free_upper_chunks += ucnt;",
            "\t}",
            "\tif (lower) {",
            "\t\t*lower_next = pid_list->lower_list;",
            "\t\tpid_list->lower_list = lower;",
            "\t\tpid_list->free_lower_chunks += lcnt;",
            "\t}",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\t/*",
            "\t * On success of allocating all the chunks, both counters",
            "\t * will be less than zero. If they are not, then an allocation",
            "\t * failed, and we should not try again.",
            "\t */",
            "\tif (upper_count >= 0 || lower_count >= 0)",
            "\t\treturn;",
            "\t/*",
            "\t * When the locks were released, free chunks could have",
            "\t * been used and allocation needs to be done again. Might as",
            "\t * well allocate it now.",
            "\t */",
            "\tgoto again;",
            "}"
          ],
          "function_name": "trace_pid_list_clear, trace_pid_list_next, trace_pid_list_first, pid_list_refill_irq",
          "description": "实现PID集合的遍历与清理功能，包含按序查找下一个PID、首次PID查询及异步内存补充分配逻辑，支持动态扩展存储结构以避免内存耗尽。",
          "similarity": 0.5129391551017761
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2021 VMware Inc, Steven Rostedt <rostedt@goodmis.org>",
            " */",
            "#include <linux/spinlock.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include \"trace.h\"",
            "",
            "/* See pid_list.h for details */",
            "",
            "static inline union lower_chunk *get_lower_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion lower_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->lower_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->lower_list;",
            "\tpid_list->lower_list = chunk->next;",
            "\tpid_list->free_lower_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_lower_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_lower_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            "",
            "static inline union upper_chunk *get_upper_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->upper_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->upper_list;",
            "\tpid_list->upper_list = chunk->next;",
            "\tpid_list->free_upper_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_upper_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_upper_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现从trace_pid_list结构中获取下层和上层块的函数，通过原子操作减少空闲块计数并可能触发异步补充分配，用于动态管理PID跟踪的内存块。",
          "similarity": 0.5005959868431091
        }
      ]
    }
  ]
}