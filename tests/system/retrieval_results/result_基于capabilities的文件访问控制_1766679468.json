{
  "query": "基于capabilities的文件访问控制",
  "timestamp": "2025-12-26 00:17:48",
  "retrieved_files": [
    {
      "source_file": "kernel/capability.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:39:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `capability.c`\n\n---\n\n# capability.c 技术文档\n\n## 1. 文件概述\n\n`capability.c` 是 Linux 内核中实现 POSIX 能力（Capabilities）机制的核心文件，位于 `kernel/` 目录下。该文件主要负责提供用户空间与内核之间进行能力获取（`capget`）和设置（`capset`）的系统调用接口，并维护能力模型的版本兼容性、安全策略检查以及与 LSM（Linux Security Module）框架的集成。能力机制允许将传统超级用户权限细分为多个独立的特权单元，从而实现最小权限原则。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `file_caps_enabled`：控制是否启用文件能力（File Capabilities）功能的全局开关，默认启用。可通过内核启动参数 `no_file_caps` 禁用。\n\n### 主要函数\n- **`cap_validate_magic()`**：验证用户传入的能力结构体版本号，支持 v1、v2、v3 版本，并对旧版本发出警告。\n- **`cap_get_target_pid()`**：安全地获取指定进程（通过 PID）的有效（Effective）、可继承（Inheritable）和允许（Permitted）能力集。\n- **`sys_capget()`**：`capget(2)` 系统调用的实现，用于查询指定进程的能力集。\n- **`sys_capset()`**：`capset(2)` 系统调用的实现，用于设置当前进程的能力集（仅限自身）。\n- **`mk_kernel_cap()`**：将用户空间传入的高低 32 位能力值组合成内核内部的 `kernel_cap_t` 类型。\n- **`has_ns_capability()`**（截断）：检查指定任务在给定用户命名空间中是否拥有某项能力（函数体在提供的代码中被截断）。\n\n### 辅助函数\n- `warn_legacy_capability_use()`：对使用 v1（32 位）能力接口的应用程序发出一次性警告。\n- `warn_deprecated_v2()`：对使用已弃用的 v2 能力接口的应用程序发出一次性警告。\n\n## 3. 关键实现\n\n### 能力版本兼容性处理\n- 支持三种能力结构版本：\n  - **v1 (`_LINUX_CAPABILITY_VERSION_1`)**：仅支持 32 位能力（旧版），调用时触发 `warn_legacy_capability_use()`。\n  - **v2 (`_LINUX_CAPABILITY_VERSION_2`)**：支持 64 位能力但存在安全风险，调用时触发 `warn_deprecated_v2()`。\n  - **v3 (`_LINUX_CAPABILITY_VERSION_3`)**：当前推荐版本，功能等同于 v2 但通过头文件变更避免误用。\n- 对于无效版本，内核会尝试将当前支持的版本号写回用户空间并返回 `-EINVAL`。\n\n### 能力数据传输格式\n- 用户空间使用两个 `__user_cap_data_struct` 结构体（`kdata[2]`）来表示 64 位能力值：\n  - `kdata[0]` 存储低 32 位\n  - `kdata[1]` 存储高 32 位\n- 在 `capget` 中，内核能力值被拆分为高低 32 位写入用户缓冲区；在 `capset` 中则反向组合。\n- **向后兼容策略**：当用户空间请求的版本只支持 32 位（`tocopy = 1`）时，内核会静默丢弃高 32 位能力，避免旧版 `libcap` 应用崩溃。\n\n### 安全限制\n- **`capset` 限制**：仅允许进程修改自身能力（`pid` 必须为 0 或当前进程 PID），修改其他进程能力的功能已被移除。\n- **能力设置规则**（由 LSM 实现，如 `security_capset`）：\n  - 新的 **可继承集（I）** 和 **允许集（P）** 只能是旧允许集的子集。\n  - 新的 **有效集（E）** 必须是新允许集的子集。\n- 使用 `prepare_creds()` / `commit_creds()` 机制安全地更新进程凭证（credentials），并在失败时通过 `abort_creds()` 回滚。\n\n### 并发与锁机制\n- 获取**其他进程**能力时，使用 `rcu_read_lock()` 保护对进程链表的访问（通过 `find_task_by_vpid()`）。\n- 获取**当前进程**能力时无需加锁，因为能力修改是原子的（通过凭证替换）。\n\n### 审计与日志\n- `capset` 成功时调用 `audit_log_capset()` 记录能力变更事件，用于安全审计。\n- 对旧版能力接口的使用通过 `pr_info_once()` 发出一次性内核日志警告。\n\n## 4. 依赖关系\n\n- **LSM 框架**：通过 `security_capget()` 和 `security_capset()` 钩子与安全模块（如 SELinux、AppArmor）交互，实际的能力检查和设置策略由 LSM 实现。\n- **凭证子系统**：依赖 `cred` 结构体管理进程权限，使用 `prepare_creds()`、`commit_creds()` 等函数安全更新。\n- **命名空间**：支持用户命名空间（`user_namespace.h`），能力检查与命名空间隔离相关（体现在 `has_ns_capability` 等函数中）。\n- **审计子系统**：通过 `audit.h` 提供能力变更的审计日志。\n- **系统调用接口**：通过 `SYSCALL_DEFINE2` 定义 `capget` 和 `capset` 系统调用。\n- **用户空间访问**：使用 `uaccess.h` 中的 `copy_to_user()` 和 `copy_from_user()` 安全传输数据。\n\n## 5. 使用场景\n\n- **容器与沙箱**：容器运行时（如 Docker、runc）通过 `capset` 限制容器内进程的能力集，实现权限隔离。\n- **特权程序降权**：需要临时提升权限的程序（如 `ping` 使用 `CAP_NET_RAW`）可在执行关键操作后通过 `capset` 丢弃多余能力。\n- **安全策略实施**：系统管理员或安全模块通过限制进程能力，遵循最小权限原则，减少攻击面。\n- **调试与监控**：安全工具（如 `getpcaps`）通过 `capget` 查询进程当前能力状态，用于诊断或合规检查。\n- **文件能力加载**：虽然本文件不直接处理文件能力，但 `file_caps_enabled` 开关控制是否启用基于文件扩展属性（xattr）的能力加载机制（由 `fs/` 子系统实现）。",
      "similarity": 0.7041589617729187,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/capability.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/capability.c",
            " *",
            " * Copyright (C) 1997  Andrew Main <zefram@fysh.org>",
            " *",
            " * Integrated into 2.1.97+,  Andrew G. Morgan <morgan@kernel.org>",
            " * 30 May 2002:\tCleanup, Robert M. Love <rml@tech9.net>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/uaccess.h>",
            "",
            "int file_caps_enabled = 1;",
            ""
          ],
          "function_name": null,
          "description": "声明模块许可证并包含必要的头文件，定义控制文件能力启用状态的全局变量file_caps_enabled",
          "similarity": 0.6565974950790405
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/capability.c",
          "start_line": 25,
          "end_line": 125,
          "content": [
            "static int __init file_caps_disable(char *str)",
            "{",
            "\tfile_caps_enabled = 0;",
            "\treturn 1;",
            "}",
            "static void warn_legacy_capability_use(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static void warn_deprecated_v2(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)",
            "{",
            "\t__u32 version;",
            "",
            "\tif (get_user(version, &header->version))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (version) {",
            "\tcase _LINUX_CAPABILITY_VERSION_1:",
            "\t\twarn_legacy_capability_use();",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;",
            "\t\tbreak;",
            "\tcase _LINUX_CAPABILITY_VERSION_2:",
            "\t\twarn_deprecated_v2();",
            "\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */",
            "\tcase _LINUX_CAPABILITY_VERSION_3:",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))",
            "\t\t\treturn -EFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,",
            "\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)",
            "{",
            "\tint ret;",
            "",
            "\tif (pid && (pid != task_pid_vnr(current))) {",
            "\t\tconst struct task_struct *target;",
            "",
            "\t\trcu_read_lock();",
            "",
            "\t\ttarget = find_task_by_vpid(pid);",
            "\t\tif (!target)",
            "\t\t\tret = -ESRCH;",
            "\t\telse",
            "\t\t\tret = security_capget(target, pEp, pIp, pPp);",
            "",
            "\t\trcu_read_unlock();",
            "\t} else",
            "\t\tret = security_capget(current, pEp, pIp, pPp);",
            "",
            "\treturn ret;",
            "}",
            "static kernel_cap_t mk_kernel_cap(u32 low, u32 high)",
            "{",
            "\treturn (kernel_cap_t) { (low | ((u64)high << 32)) & CAP_VALID_MASK };",
            "}",
            "bool has_ns_capability(struct task_struct *t,",
            "\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability(t, &init_user_ns, cap);",
            "}",
            "bool has_ns_capability_noaudit(struct task_struct *t,",
            "\t\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability_noaudit(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);",
            "}"
          ],
          "function_name": "file_caps_disable, warn_legacy_capability_use, warn_deprecated_v2, cap_validate_magic, cap_get_target_pid, mk_kernel_cap, has_ns_capability, has_capability, has_ns_capability_noaudit, has_capability_noaudit",
          "description": "提供能力相关辅助函数，包括禁用文件能力标志、版本验证警告、目标进程能力获取及能力结构构建，实现命名空间能力检查和权限验证逻辑",
          "similarity": 0.650719404220581
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/capability.c",
          "start_line": 351,
          "end_line": 424,
          "content": [
            "static bool ns_capable_common(struct user_namespace *ns,",
            "\t\t\t      int cap,",
            "\t\t\t      unsigned int opts)",
            "{",
            "\tint capable;",
            "",
            "\tif (unlikely(!cap_valid(cap))) {",
            "\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);",
            "\t\tBUG();",
            "\t}",
            "",
            "\tcapable = security_capable(current_cred(), ns, cap, opts);",
            "\tif (capable == 0) {",
            "\t\tcurrent->flags |= PF_SUPERPRIV;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "bool ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);",
            "}",
            "bool ns_capable_noaudit(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);",
            "}",
            "bool ns_capable_setid(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);",
            "}",
            "bool capable(int cap)",
            "{",
            "\treturn ns_capable(&init_user_ns, cap);",
            "}",
            "bool file_ns_capable(const struct file *file, struct user_namespace *ns,",
            "\t\t     int cap)",
            "{",
            "",
            "\tif (WARN_ON_ONCE(!cap_valid(cap)))",
            "\t\treturn false;",
            "",
            "\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,",
            "\t\t\t\t struct mnt_idmap *idmap,",
            "\t\t\t\t const struct inode *inode)",
            "{",
            "\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&",
            "\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));",
            "}",
            "bool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,",
            "\t\t\t      const struct inode *inode, int cap)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "",
            "\treturn ns_capable(ns, cap) &&",
            "\t       privileged_wrt_inode_uidgid(ns, idmap, inode);",
            "}",
            "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)",
            "{",
            "\tint ret = 0;  /* An absent tracer adds no restrictions */",
            "\tconst struct cred *cred;",
            "",
            "\trcu_read_lock();",
            "\tcred = rcu_dereference(tsk->ptracer_cred);",
            "\tif (cred)",
            "\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,",
            "\t\t\t\t       CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "\treturn (ret == 0);",
            "}"
          ],
          "function_name": "ns_capable_common, ns_capable, ns_capable_noaudit, ns_capable_setid, capable, file_ns_capable, privileged_wrt_inode_uidgid, capable_wrt_inode_uidgid, ptracer_capable",
          "description": "实现核心能力检查函数，包含通用命名空间能力检测、当前命名空间能力检查、文件能力验证、基于inode UID/GID的特权判断及跟踪者能力检查等功能",
          "similarity": 0.6041803359985352
        }
      ]
    },
    {
      "source_file": "kernel/bpf/token.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:36:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\token.c`\n\n---\n\n# `bpf/token.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/token.c` 实现了 BPF（Berkeley Packet Filter）令牌（token）机制，用于在受限环境中安全地委托 BPF 操作权限。该机制允许用户空间程序通过文件描述符形式的令牌，将特定的 BPF 命令、映射类型、程序类型和附加类型权限委托给其他进程，同时结合用户命名空间（user namespace）和 LSM（Linux Security Module）安全策略进行细粒度访问控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `bpf_ns_capable()`：检查用户命名空间是否具备指定能力，或具备 `CAP_SYS_ADMIN`（除 `CAP_SYS_ADMIN` 自身外）。\n- `bpf_token_capable()`：结合用户命名空间能力和 LSM 安全钩子，判断令牌是否具备指定能力。\n- `bpf_token_inc()` / `bpf_token_put()`：引用计数管理，支持延迟释放。\n- `bpf_token_free()`：释放令牌资源，包括用户命名空间引用和安全模块数据。\n- `bpf_token_create()`：创建 BPF 令牌文件描述符，基于挂载在 BPF 文件系统上的委托配置。\n- `bpf_token_get_from_fd()`：从文件描述符获取并增加引用计数的 `bpf_token` 结构。\n- `bpf_token_allow_cmd()` / `bpf_token_allow_map_type()` / `bpf_token_allow_prog_type()`：检查令牌是否允许执行特定 BPF 操作。\n\n### 关键数据结构\n\n- `struct bpf_token`：表示 BPF 令牌，包含：\n  - `refcnt`：引用计数（`atomic64_t`）\n  - `userns`：关联的用户命名空间\n  - `allowed_cmds` / `allowed_maps` / `allowed_progs` / `allowed_attachs`：位掩码，分别表示允许的 BPF 命令、映射类型、程序类型和附加类型\n  - `work`：用于延迟释放的工作队列项\n\n### 文件操作接口\n\n- `bpf_token_fops`：定义了 `release` 和 `show_fdinfo` 回调，用于文件关闭和 `/proc/pid/fdinfo/` 信息展示。\n\n## 3. 关键实现\n\n### 令牌创建流程 (`bpf_token_create`)\n\n1. **验证输入**：检查传入的 `bpffs_fd` 是否指向 BPF 文件系统的根目录。\n2. **权限校验**：\n   - 要求调用者与 BPF 文件系统实例处于同一用户命名空间。\n   - 必须具备 `CAP_BPF` 能力。\n   - 禁止在 `init_user_ns` 中创建令牌。\n3. **委托配置检查**：确保 BPF 文件系统挂载时已通过挂载选项设置了至少一项委托权限（`delegate_*` 字段非零）。\n4. **资源分配**：\n   - 创建匿名 inode 和文件。\n   - 分配 `bpf_token` 结构并初始化引用计数为 1。\n   - 复制挂载选项中的委托位掩码到令牌。\n5. **安全模块集成**：调用 `security_bpf_token_create()` 允许 LSM 进行额外策略检查。\n6. **返回文件描述符**：安装文件到进程 fd 表并返回。\n\n### 安全能力检查 (`bpf_token_capable`)\n\n- 默认允许 `CAP_SYS_ADMIN` 作为“超级能力”覆盖其他能力检查（但 `CAP_SYS_ADMIN` 本身仍需显式授权）。\n- 调用 `security_bpf_token_capable()` 允许 LSM 对令牌能力进行二次验证。\n\n### 引用计数与延迟释放\n\n- 使用 `atomic64_t refcnt` 管理生命周期。\n- 当引用计数归零时，通过 `schedule_work()` 将释放操作推迟到工作队列执行，避免在中断或原子上下文中调用可能睡眠的 `put_user_ns()` 和 `kfree()`。\n\n### `/proc/pid/fdinfo/` 支持\n\n- `bpf_token_show_fdinfo()` 将令牌的委托权限以十六进制或 \"any\" 形式输出，便于调试和审计。\n\n### 权限位掩码设计\n\n- 所有委托权限（命令、映射、程序、附加类型）均使用 64 位无符号整数位掩码表示。\n- 通过 `BUILD_BUG_ON()` 确保枚举类型数量不超过 64，防止位移溢出。\n- 若掩码全为 1，则显示为 \"any\"，表示无限制。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_super_ops`、`bpf_get_inode()` 等 BPF 文件系统接口。\n- **用户命名空间**：通过 `user_namespace` 和 `ns_capable()` 实现能力隔离。\n- **安全模块 (LSM)**：集成 `security_bpf_token_*` 钩子，支持 SELinux、AppArmor 等策略扩展。\n- **VFS 层**：使用 `inode`、`file`、`path`、`fdtable` 等通用文件系统抽象。\n- **内存管理**：使用 `kzalloc()`/`kfree()` 和 `vmalloc.h`（虽未直接使用，但为潜在扩展预留）。\n- **工作队列**：通过 `schedule_work()` 实现延迟释放。\n\n## 5. 使用场景\n\n- **容器化环境中的 BPF 权限委托**：在用户命名空间隔离的容器中，特权进程可创建 BPF 令牌并传递给非特权子进程，使其在受限范围内使用 BPF 功能（如 eBPF 程序加载、映射操作）。\n- **安全沙箱**：应用程序可通过令牌机制将特定 BPF 操作权限委托给插件或子模块，避免授予完整 `CAP_BPF` 或 `CAP_SYS_ADMIN`。\n- **审计与调试**：通过 `/proc/pid/fdinfo/` 查看进程持有的 BPF 令牌权限，辅助安全分析。\n- **LSM 策略集成**：安全模块可基于令牌内容实施更细粒度的访问控制，例如限制特定程序类型只能在特定挂载点使用。",
      "similarity": 0.5952212810516357,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/token.c",
          "start_line": 230,
          "end_line": 254,
          "content": [
            "bool bpf_token_allow_cmd(const struct bpf_token *token, enum bpf_cmd cmd)",
            "{",
            "\tif (!token)",
            "\t\treturn false;",
            "\tif (!(token->allowed_cmds & (1ULL << cmd)))",
            "\t\treturn false;",
            "\treturn security_bpf_token_cmd(token, cmd) == 0;",
            "}",
            "bool bpf_token_allow_map_type(const struct bpf_token *token, enum bpf_map_type type)",
            "{",
            "\tif (!token || type >= __MAX_BPF_MAP_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn token->allowed_maps & (1ULL << type);",
            "}",
            "bool bpf_token_allow_prog_type(const struct bpf_token *token,",
            "\t\t\t       enum bpf_prog_type prog_type,",
            "\t\t\t       enum bpf_attach_type attach_type)",
            "{",
            "\tif (!token || prog_type >= __MAX_BPF_PROG_TYPE || attach_type >= __MAX_BPF_ATTACH_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn (token->allowed_progs & (1ULL << prog_type)) &&",
            "\t       (token->allowed_attachs & (1ULL << attach_type));",
            "}"
          ],
          "function_name": "bpf_token_allow_cmd, bpf_token_allow_map_type, bpf_token_allow_prog_type",
          "description": "提供对BPF命令、映射类型和程序类型的访问控制检查，通过位掩码匹配并结合安全模块验证权限。",
          "similarity": 0.5818879008293152
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/token.c",
          "start_line": 12,
          "end_line": 195,
          "content": [
            "static bool bpf_ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable(ns, cap) || (cap != CAP_SYS_ADMIN && ns_capable(ns, CAP_SYS_ADMIN));",
            "}",
            "bool bpf_token_capable(const struct bpf_token *token, int cap)",
            "{",
            "\tstruct user_namespace *userns;",
            "",
            "\t/* BPF token allows ns_capable() level of capabilities */",
            "\tuserns = token ? token->userns : &init_user_ns;",
            "\tif (!bpf_ns_capable(userns, cap))",
            "\t\treturn false;",
            "\tif (token && security_bpf_token_capable(token, cap) < 0)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "void bpf_token_inc(struct bpf_token *token)",
            "{",
            "\tatomic64_inc(&token->refcnt);",
            "}",
            "static void bpf_token_free(struct bpf_token *token)",
            "{",
            "\tsecurity_bpf_token_free(token);",
            "\tput_user_ns(token->userns);",
            "\tkfree(token);",
            "}",
            "static void bpf_token_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_token *token = container_of(work, struct bpf_token, work);",
            "",
            "\tbpf_token_free(token);",
            "}",
            "void bpf_token_put(struct bpf_token *token)",
            "{",
            "\tif (!token)",
            "\t\treturn;",
            "",
            "\tif (!atomic64_dec_and_test(&token->refcnt))",
            "\t\treturn;",
            "",
            "\tINIT_WORK(&token->work, bpf_token_put_deferred);",
            "\tschedule_work(&token->work);",
            "}",
            "static int bpf_token_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "",
            "\tbpf_token_put(token);",
            "\treturn 0;",
            "}",
            "static void bpf_token_show_fdinfo(struct seq_file *m, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "\tu64 mask;",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_CMD >= 64);",
            "\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\tif ((token->allowed_cmds & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_cmds:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_cmds:\\t0x%llx\\n\", token->allowed_cmds);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_MAP_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\tif ((token->allowed_maps & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_maps:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_maps:\\t0x%llx\\n\", token->allowed_maps);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_PROG_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\tif ((token->allowed_progs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_progs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_progs:\\t0x%llx\\n\", token->allowed_progs);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_ATTACH_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\tif ((token->allowed_attachs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_attachs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_attachs:\\t0x%llx\\n\", token->allowed_attachs);",
            "}",
            "int bpf_token_create(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_mount_opts *mnt_opts;",
            "\tstruct bpf_token *token = NULL;",
            "\tstruct user_namespace *userns;",
            "\tstruct inode *inode;",
            "\tstruct file *file;",
            "\tCLASS(fd, f)(attr->token_create.bpffs_fd);",
            "\tstruct path path;",
            "\tstruct super_block *sb;",
            "\tumode_t mode;",
            "\tint err, fd;",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "",
            "\tpath = fd_file(f)->f_path;",
            "\tsb = path.dentry->d_sb;",
            "",
            "\tif (path.dentry != sb->s_root)",
            "\t\treturn -EINVAL;",
            "\tif (sb->s_op != &bpf_super_ops)",
            "\t\treturn -EINVAL;",
            "\terr = path_permission(&path, MAY_ACCESS);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tuserns = sb->s_user_ns;",
            "\t/*",
            "\t * Enforce that creators of BPF tokens are in the same user",
            "\t * namespace as the BPF FS instance. This makes reasoning about",
            "\t * permissions a lot easier and we can always relax this later.",
            "\t */",
            "\tif (current_user_ns() != userns)",
            "\t\treturn -EPERM;",
            "\tif (!ns_capable(userns, CAP_BPF))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Creating BPF token in init_user_ns doesn't make much sense. */",
            "\tif (current_user_ns() == &init_user_ns)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tmnt_opts = sb->s_fs_info;",
            "\tif (mnt_opts->delegate_cmds == 0 &&",
            "\t    mnt_opts->delegate_maps == 0 &&",
            "\t    mnt_opts->delegate_progs == 0 &&",
            "\t    mnt_opts->delegate_attachs == 0)",
            "\t\treturn -ENOENT; /* no BPF token delegation is set up */",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tinode = bpf_get_inode(sb, NULL, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_token_iops;",
            "\tinode->i_fop = &bpf_token_fops;",
            "\tclear_nlink(inode); /* make sure it is unlinked */",
            "",
            "\tfile = alloc_file_pseudo(inode, path.mnt, BPF_TOKEN_INODE_NAME, O_RDWR, &bpf_token_fops);",
            "\tif (IS_ERR(file)) {",
            "\t\tiput(inode);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\ttoken = kzalloc(sizeof(*token), GFP_USER);",
            "\tif (!token) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_file;",
            "\t}",
            "",
            "\tatomic64_set(&token->refcnt, 1);",
            "",
            "\t/* remember bpffs owning userns for future ns_capable() checks */",
            "\ttoken->userns = get_user_ns(userns);",
            "",
            "\ttoken->allowed_cmds = mnt_opts->delegate_cmds;",
            "\ttoken->allowed_maps = mnt_opts->delegate_maps;",
            "\ttoken->allowed_progs = mnt_opts->delegate_progs;",
            "\ttoken->allowed_attachs = mnt_opts->delegate_attachs;",
            "",
            "\terr = security_bpf_token_create(token, attr, &path);",
            "\tif (err)",
            "\t\tgoto out_token;",
            "",
            "\tfd = get_unused_fd_flags(O_CLOEXEC);",
            "\tif (fd < 0) {",
            "\t\terr = fd;",
            "\t\tgoto out_token;",
            "\t}",
            "",
            "\tfile->private_data = token;",
            "\tfd_install(fd, file);",
            "",
            "\treturn fd;",
            "",
            "out_token:",
            "\tbpf_token_free(token);",
            "out_file:",
            "\tfput(file);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_ns_capable, bpf_token_capable, bpf_token_inc, bpf_token_free, bpf_token_put_deferred, bpf_token_put, bpf_token_release, bpf_token_show_fdinfo, bpf_token_create",
          "description": "实现BPF令牌的权限检查、引用计数管理、延迟释放及创建逻辑，包括基于挂载选项的令牌初始化和安全策略校验。",
          "similarity": 0.565630316734314
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/token.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            ""
          ],
          "function_name": null,
          "description": "包含BPF令牌功能所需的各种内核头文件，如用户命名空间、安全策略、文件操作及BPF相关定义。",
          "similarity": 0.5177135467529297
        }
      ]
    },
    {
      "source_file": "mm/shmem_quota.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:18:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `shmem_quota.c`\n\n---\n\n# shmem_quota.c 技术文档\n\n## 1. 文件概述\n\n`shmem_quota.c` 实现了针对内存文件系统（如 tmpfs）的配额（quota）管理机制。由于 tmpfs 等内存文件系统没有持久化存储，传统的基于磁盘配额文件的方式无法使用。该文件提供了一种**纯内存配额格式**（in-memory quota format），通过红黑树（rbtree）在内存中维护用户/组的配额限制信息，并与 Linux 内核通用配额子系统集成，从而支持对 tmpfs 的空间和 inode 使用量进行配额控制。\n\n关键设计原则是：**不能释放未使用的 dquot 结构**，因为一旦释放，配额限制信息将永久丢失（无持久化后端可重新加载）。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct quota_id`**  \n  表示一个配额主体（用户或组）的配额限制信息，作为红黑树节点存储：\n  - `node`: 红黑树节点\n  - `id`: 用户/组 ID（qid_t）\n  - `bhardlimit/bsoftlimit`: 块（空间）硬/软限制\n  - `ihardlimit/isoftlimit`: inode 硬/软限制\n\n### 主要函数\n\n- **`shmem_check_quota_file()`**  \n  检查配额文件是否存在（内存配额无实际文件，始终返回成功）\n\n- **`shmem_read_file_info()`**  \n  初始化配额信息结构，分配红黑树根节点并设置默认配额参数（grace time、最大限制等）\n\n- **`shmem_write_file_info()`**  \n  写入配额文件信息（无操作，因无持久化存储）\n\n- **`shmem_free_file_info()`**  \n  释放红黑树中所有 `quota_id` 条目及根节点，清理内存\n\n- **`shmem_get_next_id()`**  \n  在红黑树中查找大于等于指定 ID 的下一个配额主体 ID（用于配额遍历）\n\n- **`shmem_acquire_dquot()`**  \n  获取或创建指定 ID 的 dquot：\n  - 若红黑树中存在对应 ID，加载其配额限制到 dquot\n  - 若不存在，创建新 `quota_id` 节点，从超级块的默认配额限制初始化，并插入红黑树\n\n- **`shmem_is_empty_dquot()`**  \n  判断 dquot 是否为空（即未使用且配额限制等于默认值），用于决定是否可安全移除\n\n- **`shmem_release_dquot()`**  \n  释放 dquot 时，若其为“假”（fake）或内容为空，则从红黑树中删除对应条目（代码截断，但逻辑完整）\n\n## 3. 关键实现\n\n### 内存配额存储结构\n- 每个配额类型（USRQUOTA/GRPQUOTA）在 `mem_dqinfo->dqi_priv` 中保存一个独立的红黑树（`struct rb_root`）\n- 红黑树按键值 `qid_t id` 排序，支持高效查找、插入和顺序遍历\n\n### 配额限制初始化\n- 新创建的 `quota_id` 条目从 `shmem_sb_info->qlimits` 获取默认硬限制值\n- 软限制初始为 0（表示未设置），硬限制来自挂载选项或默认值\n- 若所有限制均为 0，则标记 dquot 为 `DQ_FAKE_B`（表示无实际配额限制）\n\n### 并发控制\n- 使用 `dqopt->dqio_sem` 读写信号量保护红黑树的并发访问：\n  - 读操作（如 `shmem_get_next_id`）使用 `down_read`\n  - 写操作（如 `shmem_acquire_dquot`、`shmem_release_dquot`）使用 `down_write`\n- 每个 dquot 使用 `dq_lock` 互斥锁保护其状态变更\n\n### 配额生命周期管理\n- **获取**（acquire）：确保 dquot 在内存中存在，必要时创建并初始化\n- **释放**（release）：仅当 dquot 为空（未使用且限制为默认值）时才从红黑树删除，避免信息丢失\n- **活跃性检查**：通过 `dquot_is_busy()` 防止在仍有引用时释放 dquot\n\n## 4. 依赖关系\n\n- **内核配额子系统**：依赖 `<linux/quota.h>` 和 `<linux/quotaops.h>` 提供的通用配额框架（dquot 结构、操作接口等）\n- **tmpfs 文件系统**：通过 `shmem_fs.h` 访问 `shmem_sb_info` 结构获取默认配额限制\n- **内存管理**：使用 `kzalloc/kfree` 分配/释放 `quota_id` 结构\n- **红黑树**：使用 `<linux/rbtree.h>` 实现高效的 ID 查找和排序\n- **配置选项**：仅在 `CONFIG_TMPFS_QUOTA` 启用时编译\n\n## 5. 使用场景\n\n- **tmpfs 配额支持**：当 tmpfs 挂载时启用配额（如 `mount -o usrquota,grpquota tmpfs /tmp`），该模块负责管理用户/组的空间和 inode 使用限制\n- **内存文件系统配额**：可扩展用于其他无持久化存储的内存文件系统\n- **运行时配额查询/修改**：通过 `quotactl` 系统调用查询或更新配额限制时，底层操作由本文件实现\n- **资源隔离**：在容器或沙箱环境中，限制单个用户/组在 tmpfs 中可使用的内存资源",
      "similarity": 0.5688250064849854,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/shmem_quota.c",
          "start_line": 1,
          "end_line": 56,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * In memory quota format relies on quota infrastructure to store dquot",
            " * information for us. While conventional quota formats for file systems",
            " * with persistent storage can load quota information into dquot from the",
            " * storage on-demand and hence quota dquot shrinker can free any dquot",
            " * that is not currently being used, it must be avoided here. Otherwise we",
            " * can lose valuable information, user provided limits, because there is",
            " * no persistent storage to load the information from afterwards.",
            " *",
            " * One information that in-memory quota format needs to keep track of is",
            " * a sorted list of ids for each quota type. This is done by utilizing",
            " * an rb tree which root is stored in mem_dqinfo->dqi_priv for each quota",
            " * type.",
            " *",
            " * This format can be used to support quota on file system without persistent",
            " * storage such as tmpfs.",
            " *",
            " * Author:\tLukas Czerner <lczerner@redhat.com>",
            " *\t\tCarlos Maiolino <cmaiolino@redhat.com>",
            " *",
            " * Copyright (C) 2023 Red Hat, Inc.",
            " */",
            "#include <linux/errno.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/shmem_fs.h>",
            "",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "",
            "#ifdef CONFIG_TMPFS_QUOTA",
            "",
            "/*",
            " * The following constants define the amount of time given a user",
            " * before the soft limits are treated as hard limits (usually resulting",
            " * in an allocation failure). The timer is started when the user crosses",
            " * their soft limit, it is reset when they go below their soft limit.",
            " */",
            "#define SHMEM_MAX_IQ_TIME 604800\t/* (7*24*60*60) 1 week */",
            "#define SHMEM_MAX_DQ_TIME 604800\t/* (7*24*60*60) 1 week */",
            "",
            "struct quota_id {",
            "\tstruct rb_node\tnode;",
            "\tqid_t\t\tid;",
            "\tqsize_t\t\tbhardlimit;",
            "\tqsize_t\t\tbsoftlimit;",
            "\tqsize_t\t\tihardlimit;",
            "\tqsize_t\t\tisoftlimit;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义用于管理内存配额信息的结构体quota_id，包含RB树节点、用户ID及硬软限制值，用于支持tmpfs等无持久存储文件系统的配额管理。",
          "similarity": 0.5329675674438477
        },
        {
          "chunk_id": 1,
          "file_path": "mm/shmem_quota.c",
          "start_line": 57,
          "end_line": 221,
          "content": [
            "static int shmem_check_quota_file(struct super_block *sb, int type)",
            "{",
            "\t/* There is no real quota file, nothing to do */",
            "\treturn 1;",
            "}",
            "static int shmem_read_file_info(struct super_block *sb, int type)",
            "{",
            "\tstruct quota_info *dqopt = sb_dqopt(sb);",
            "\tstruct mem_dqinfo *info = &dqopt->info[type];",
            "",
            "\tinfo->dqi_priv = kzalloc(sizeof(struct rb_root), GFP_NOFS);",
            "\tif (!info->dqi_priv)",
            "\t\treturn -ENOMEM;",
            "",
            "\tinfo->dqi_max_spc_limit = SHMEM_QUOTA_MAX_SPC_LIMIT;",
            "\tinfo->dqi_max_ino_limit = SHMEM_QUOTA_MAX_INO_LIMIT;",
            "",
            "\tinfo->dqi_bgrace = SHMEM_MAX_DQ_TIME;",
            "\tinfo->dqi_igrace = SHMEM_MAX_IQ_TIME;",
            "\tinfo->dqi_flags = 0;",
            "",
            "\treturn 0;",
            "}",
            "static int shmem_write_file_info(struct super_block *sb, int type)",
            "{",
            "\t/* There is no real quota file, nothing to do */",
            "\treturn 0;",
            "}",
            "static int shmem_free_file_info(struct super_block *sb, int type)",
            "{",
            "\tstruct mem_dqinfo *info = &sb_dqopt(sb)->info[type];",
            "\tstruct rb_root *root = info->dqi_priv;",
            "\tstruct quota_id *entry;",
            "\tstruct rb_node *node;",
            "",
            "\tinfo->dqi_priv = NULL;",
            "\tnode = rb_first(root);",
            "\twhile (node) {",
            "\t\tentry = rb_entry(node, struct quota_id, node);",
            "\t\tnode = rb_next(&entry->node);",
            "",
            "\t\trb_erase(&entry->node, root);",
            "\t\tkfree(entry);",
            "\t}",
            "",
            "\tkfree(root);",
            "\treturn 0;",
            "}",
            "static int shmem_get_next_id(struct super_block *sb, struct kqid *qid)",
            "{",
            "\tstruct mem_dqinfo *info = sb_dqinfo(sb, qid->type);",
            "\tstruct rb_node *node;",
            "\tqid_t id = from_kqid(&init_user_ns, *qid);",
            "\tstruct quota_info *dqopt = sb_dqopt(sb);",
            "\tstruct quota_id *entry = NULL;",
            "\tint ret = 0;",
            "",
            "\tif (!sb_has_quota_active(sb, qid->type))",
            "\t\treturn -ESRCH;",
            "",
            "\tdown_read(&dqopt->dqio_sem);",
            "\tnode = ((struct rb_root *)info->dqi_priv)->rb_node;",
            "\twhile (node) {",
            "\t\tentry = rb_entry(node, struct quota_id, node);",
            "",
            "\t\tif (id < entry->id)",
            "\t\t\tnode = node->rb_left;",
            "\t\telse if (id > entry->id)",
            "\t\t\tnode = node->rb_right;",
            "\t\telse",
            "\t\t\tgoto got_next_id;",
            "\t}",
            "",
            "\tif (!entry) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (id > entry->id) {",
            "\t\tnode = rb_next(&entry->node);",
            "\t\tif (!node) {",
            "\t\t\tret = -ENOENT;",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "\t\tentry = rb_entry(node, struct quota_id, node);",
            "\t}",
            "",
            "got_next_id:",
            "\t*qid = make_kqid(&init_user_ns, qid->type, entry->id);",
            "out_unlock:",
            "\tup_read(&dqopt->dqio_sem);",
            "\treturn ret;",
            "}",
            "static int shmem_acquire_dquot(struct dquot *dquot)",
            "{",
            "\tstruct mem_dqinfo *info = sb_dqinfo(dquot->dq_sb, dquot->dq_id.type);",
            "\tstruct rb_node **n;",
            "\tstruct shmem_sb_info *sbinfo = dquot->dq_sb->s_fs_info;",
            "\tstruct rb_node *parent = NULL, *new_node = NULL;",
            "\tstruct quota_id *new_entry, *entry;",
            "\tqid_t id = from_kqid(&init_user_ns, dquot->dq_id);",
            "\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);",
            "\tint ret = 0;",
            "",
            "\tmutex_lock(&dquot->dq_lock);",
            "",
            "\tdown_write(&dqopt->dqio_sem);",
            "\tn = &((struct rb_root *)info->dqi_priv)->rb_node;",
            "",
            "\twhile (*n) {",
            "\t\tparent = *n;",
            "\t\tentry = rb_entry(parent, struct quota_id, node);",
            "",
            "\t\tif (id < entry->id)",
            "\t\t\tn = &(*n)->rb_left;",
            "\t\telse if (id > entry->id)",
            "\t\t\tn = &(*n)->rb_right;",
            "\t\telse",
            "\t\t\tgoto found;",
            "\t}",
            "",
            "\t/* We don't have entry for this id yet, create it */",
            "\tnew_entry = kzalloc(sizeof(struct quota_id), GFP_NOFS);",
            "\tif (!new_entry) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tnew_entry->id = id;",
            "\tif (dquot->dq_id.type == USRQUOTA) {",
            "\t\tnew_entry->bhardlimit = sbinfo->qlimits.usrquota_bhardlimit;",
            "\t\tnew_entry->ihardlimit = sbinfo->qlimits.usrquota_ihardlimit;",
            "\t} else if (dquot->dq_id.type == GRPQUOTA) {",
            "\t\tnew_entry->bhardlimit = sbinfo->qlimits.grpquota_bhardlimit;",
            "\t\tnew_entry->ihardlimit = sbinfo->qlimits.grpquota_ihardlimit;",
            "\t}",
            "",
            "\tnew_node = &new_entry->node;",
            "\trb_link_node(new_node, parent, n);",
            "\trb_insert_color(new_node, (struct rb_root *)info->dqi_priv);",
            "\tentry = new_entry;",
            "",
            "found:",
            "\t/* Load the stored limits from the tree */",
            "\tspin_lock(&dquot->dq_dqb_lock);",
            "\tdquot->dq_dqb.dqb_bhardlimit = entry->bhardlimit;",
            "\tdquot->dq_dqb.dqb_bsoftlimit = entry->bsoftlimit;",
            "\tdquot->dq_dqb.dqb_ihardlimit = entry->ihardlimit;",
            "\tdquot->dq_dqb.dqb_isoftlimit = entry->isoftlimit;",
            "",
            "\tif (!dquot->dq_dqb.dqb_bhardlimit &&",
            "\t    !dquot->dq_dqb.dqb_bsoftlimit &&",
            "\t    !dquot->dq_dqb.dqb_ihardlimit &&",
            "\t    !dquot->dq_dqb.dqb_isoftlimit)",
            "\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);",
            "\tspin_unlock(&dquot->dq_dqb_lock);",
            "",
            "\t/* Make sure flags update is visible after dquot has been filled */",
            "\tsmp_mb__before_atomic();",
            "\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);",
            "out_unlock:",
            "\tup_write(&dqopt->dqio_sem);",
            "\tmutex_unlock(&dquot->dq_lock);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "shmem_check_quota_file, shmem_read_file_info, shmem_write_file_info, shmem_free_file_info, shmem_get_next_id, shmem_acquire_dquot",
          "description": "实现内存配额核心操作，包括初始化配额信息、管理RB树节点、获取下一个ID、分配配额项及加载存储限制，通过RB树维护用户ID有序集合。",
          "similarity": 0.5190434455871582
        },
        {
          "chunk_id": 2,
          "file_path": "mm/shmem_quota.c",
          "start_line": 239,
          "end_line": 323,
          "content": [
            "static bool shmem_is_empty_dquot(struct dquot *dquot)",
            "{",
            "\tstruct shmem_sb_info *sbinfo = dquot->dq_sb->s_fs_info;",
            "\tqsize_t bhardlimit;",
            "\tqsize_t ihardlimit;",
            "",
            "\tif (dquot->dq_id.type == USRQUOTA) {",
            "\t\tbhardlimit = sbinfo->qlimits.usrquota_bhardlimit;",
            "\t\tihardlimit = sbinfo->qlimits.usrquota_ihardlimit;",
            "\t} else if (dquot->dq_id.type == GRPQUOTA) {",
            "\t\tbhardlimit = sbinfo->qlimits.grpquota_bhardlimit;",
            "\t\tihardlimit = sbinfo->qlimits.grpquota_ihardlimit;",
            "\t}",
            "",
            "\tif (test_bit(DQ_FAKE_B, &dquot->dq_flags) ||",
            "\t\t(dquot->dq_dqb.dqb_curspace == 0 &&",
            "\t\t dquot->dq_dqb.dqb_curinodes == 0 &&",
            "\t\t dquot->dq_dqb.dqb_bhardlimit == bhardlimit &&",
            "\t\t dquot->dq_dqb.dqb_ihardlimit == ihardlimit))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static int shmem_release_dquot(struct dquot *dquot)",
            "{",
            "\tstruct mem_dqinfo *info = sb_dqinfo(dquot->dq_sb, dquot->dq_id.type);",
            "\tstruct rb_node *node;",
            "\tqid_t id = from_kqid(&init_user_ns, dquot->dq_id);",
            "\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);",
            "\tstruct quota_id *entry = NULL;",
            "",
            "\tmutex_lock(&dquot->dq_lock);",
            "\t/* Check whether we are not racing with some other dqget() */",
            "\tif (dquot_is_busy(dquot))",
            "\t\tgoto out_dqlock;",
            "",
            "\tdown_write(&dqopt->dqio_sem);",
            "\tnode = ((struct rb_root *)info->dqi_priv)->rb_node;",
            "\twhile (node) {",
            "\t\tentry = rb_entry(node, struct quota_id, node);",
            "",
            "\t\tif (id < entry->id)",
            "\t\t\tnode = node->rb_left;",
            "\t\telse if (id > entry->id)",
            "\t\t\tnode = node->rb_right;",
            "\t\telse",
            "\t\t\tgoto found;",
            "\t}",
            "",
            "\t/* We should always find the entry in the rb tree */",
            "\tWARN_ONCE(1, \"quota id %u from dquot %p, not in rb tree!\\n\", id, dquot);",
            "\tup_write(&dqopt->dqio_sem);",
            "\tmutex_unlock(&dquot->dq_lock);",
            "\treturn -ENOENT;",
            "",
            "found:",
            "\tif (shmem_is_empty_dquot(dquot)) {",
            "\t\t/* Remove entry from the tree */",
            "\t\trb_erase(&entry->node, info->dqi_priv);",
            "\t\tkfree(entry);",
            "\t} else {",
            "\t\t/* Store the limits in the tree */",
            "\t\tspin_lock(&dquot->dq_dqb_lock);",
            "\t\tentry->bhardlimit = dquot->dq_dqb.dqb_bhardlimit;",
            "\t\tentry->bsoftlimit = dquot->dq_dqb.dqb_bsoftlimit;",
            "\t\tentry->ihardlimit = dquot->dq_dqb.dqb_ihardlimit;",
            "\t\tentry->isoftlimit = dquot->dq_dqb.dqb_isoftlimit;",
            "\t\tspin_unlock(&dquot->dq_dqb_lock);",
            "\t}",
            "",
            "\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);",
            "\tup_write(&dqopt->dqio_sem);",
            "",
            "out_dqlock:",
            "\tmutex_unlock(&dquot->dq_lock);",
            "\treturn 0;",
            "}",
            "static int shmem_mark_dquot_dirty(struct dquot *dquot)",
            "{",
            "\treturn 0;",
            "}",
            "static int shmem_dquot_write_info(struct super_block *sb, int type)",
            "{",
            "\treturn 0;",
            "}"
          ],
          "function_name": "shmem_is_empty_dquot, shmem_release_dquot, shmem_mark_dquot_dirty, shmem_dquot_write_info",
          "description": "提供配额项状态检测与释放逻辑，检查配额是否为空以决定是否从RB树中移除节点，在释放时同步更新树中存储的限制值并标记配额状态变化。",
          "similarity": 0.5073189735412598
        }
      ]
    }
  ]
}