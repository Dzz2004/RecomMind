{
  "query": "容器技术中的虚拟文件系统实现",
  "timestamp": "2025-12-26 01:50:28",
  "retrieved_files": [
    {
      "source_file": "mm/shmem.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:17:29\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `shmem.c`\n\n---\n\n# shmem.c 技术文档\n\n## 1. 文件概述\n\n`shmem.c` 实现了 Linux 内核中的 **共享内存虚拟文件系统（tmpfs）**，它基于 `ramfs` 扩展而来，支持使用交换空间（swap）并遵守资源限制，从而成为一个完全可用的内存文件系统。该文件系统用于实现 POSIX 共享内存、匿名映射（如 `/dev/zero`）、`memfd_create()` 创建的内存文件以及 tmpfs 挂载点（如 `/tmp` 或 `/dev/shm`）。其核心特点是：数据存储在内存中，可被换出到 swap，支持稀疏文件，并受内存和 inode 配额限制。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct shmem_falloc`：用于 `fallocate` 操作与缺页处理之间的通信，记录预分配范围、已分配页数等。\n- `struct shmem_options`：解析挂载选项（如 size、nr_inodes、huge、uid/gid 等）时使用的临时结构。\n- `struct shmem_sb_info`：超级块私有信息，包含块/ inode 配额、内存策略、配额计数器等。\n- `struct shmem_inode_info`：inode 私有信息，扩展标准 inode 以支持共享内存特性。\n\n### 关键函数\n- `shmem_acct_size()` / `shmem_unacct_size()`：对固定大小 VM 对象进行内存预占（如共享内存映射）。\n- `shmem_acct_blocks()` / `shmem_unacct_blocks()`：对 tmpfs 稀疏文件按实际分配页进行内存核算。\n- `shmem_inode_acct_blocks()` / `shmem_inode_unacct_blocks()`：结合文件系统配额（`max_blocks`）和磁盘配额（`dquot`）进行块分配/释放。\n- `shmem_swapin_folio()`：从 swap 中换入指定页。\n- `vma_is_anon_shmem()`：判断 VMA 是否为匿名共享内存映射。\n- `SHMEM_SB()`：宏，快速获取超级块的 `shmem_sb_info`。\n\n### 全局操作结构体\n- `shmem_ops`：超级块操作（如 `statfs`、`put_super`）。\n- `shmem_aops`：地址空间操作（如 `readpage`、`writepage`、`set_page_dirty`）。\n- `shmem_file_operations`：文件操作（如 `read`、`write`、`mmap`）。\n- `shmem_inode_operations`：普通文件 inode 操作。\n- `shmem_dir_inode_operations`：目录 inode 操作。\n- `shmem_special_inode_operations`：特殊文件（设备、socket）inode 操作。\n- `shmem_vm_ops` / `shmem_anon_vm_ops`：VMA 操作结构体，分别用于 tmpfs 文件映射和匿名共享内存映射。\n\n## 3. 关键实现\n\n### 内存核算机制\n- **预占模式（Pre-accounting）**：用于 `shmem_file_setup()` 创建的固定大小对象（如 POSIX 共享内存），在创建时即核算全部内存（通过 `shmem_acct_size`），避免运行时 OOM。\n- **增量核算（Incremental accounting）**：用于 tmpfs 文件，仅在实际分配页面时核算（通过 `shmem_acct_blocks`），支持大稀疏文件。失败返回 `-ENOSPC` 而非 `-ENOMEM`，使用户态收到 `SIGBUS` 而非触发 OOM killer。\n\n### 配额管理\n- 使用 `percpu_counter` 高效跟踪已用块数（`used_blocks`），并与挂载时指定的 `max_blocks` 限制比较。\n- 集成内核通用配额子系统（`dquot_alloc_block_nodirty` / `dquot_free_block_nodirty`），支持用户/组配额。\n\n### 大页（Huge Page）支持\n- 通过 `huge` 挂载选项和 `madvise(MADV_HUGEPAGE)` 控制透明大页（THP）行为。\n- 维护多个位图（`huge_shmem_orders_*`）记录不同场景下允许的大页阶数。\n\n### fallocate 与缺页协同\n- `shmem_falloc` 结构通过 `inode->i_private` 在 `fallocate` 和 `shmem_fault`/`shmem_writepage` 之间传递状态。\n- 使用等待队列（`waitq`）确保在 punch hole 操作期间，访问空洞的缺页请求会等待操作完成。\n\n### 匿名 vs 命名共享内存\n- **匿名共享内存**：由 `shmem_zero_setup()` 创建（如 `/dev/zero` 映射），使用 `shmem_anon_vm_ops`。\n- **命名共享内存**：通过 tmpfs 文件系统接口创建（如 `shm_open()`），使用 `shmem_vm_ops`。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `mm/` 中的页分配、swap、rmap、mempolicy、hugetlb 等机制。\n- **VFS 层**：实现标准文件系统接口（`super_operations`, `inode_operations` 等）。\n- **安全模块**：调用 LSM 钩子（`security_vm_enough_memory_mm`）进行内存安全检查。\n- **配额子系统**：通过 `dquot_*` 函数集成磁盘配额功能。\n- **swap 子系统**：通过 `swap.h` 和 `swapops.h` 实现页面换入换出。\n- **其他**：依赖 `ramfs` 基础结构、`xattr`、`posix_acl`、`splice`、`falloc` 等通用内核组件。\n\n## 5. 使用场景\n\n- **POSIX 共享内存**：`shm_open()` / `shm_unlink()` 创建的共享内存对象。\n- **System V 共享内存**：`shmget()` / `shmat()` 使用的底层存储。\n- **匿名映射**：`mmap()` 映射 `/dev/zero` 或 `MAP_ANONYMOUS | MAP_SHARED` 创建的共享内存区域。\n- **tmpfs 文件系统**：挂载 tmpfs（如 `/dev/shm`）后创建的文件和目录。\n- **memfd 文件**：通过 `memfd_create()` 系统调用创建的匿名内存文件，支持密封（sealing）和共享。\n- **内核内部用途**：作为某些需要临时可换出内存缓冲区的子系统的后端存储。",
      "similarity": 0.5710126757621765,
      "chunks": [
        {
          "chunk_id": 19,
          "file_path": "mm/shmem.c",
          "start_line": 3562,
          "end_line": 3733,
          "content": [
            "static loff_t shmem_file_llseek(struct file *file, loff_t offset, int whence)",
            "{",
            "\tstruct address_space *mapping = file->f_mapping;",
            "\tstruct inode *inode = mapping->host;",
            "",
            "\tif (whence != SEEK_DATA && whence != SEEK_HOLE)",
            "\t\treturn generic_file_llseek_size(file, offset, whence,",
            "\t\t\t\t\tMAX_LFS_FILESIZE, i_size_read(inode));",
            "\tif (offset < 0)",
            "\t\treturn -ENXIO;",
            "",
            "\tinode_lock(inode);",
            "\t/* We're holding i_rwsem so we can access i_size directly */",
            "\toffset = mapping_seek_hole_data(mapping, offset, inode->i_size, whence);",
            "\tif (offset >= 0)",
            "\t\toffset = vfs_setpos(file, offset, MAX_LFS_FILESIZE);",
            "\tinode_unlock(inode);",
            "\treturn offset;",
            "}",
            "static long shmem_fallocate(struct file *file, int mode, loff_t offset,",
            "\t\t\t\t\t\t\t loff_t len)",
            "{",
            "\tstruct inode *inode = file_inode(file);",
            "\tstruct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);",
            "\tstruct shmem_inode_info *info = SHMEM_I(inode);",
            "\tstruct shmem_falloc shmem_falloc;",
            "\tpgoff_t start, index, end, undo_fallocend;",
            "\tint error;",
            "",
            "\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tinode_lock(inode);",
            "",
            "\tif (mode & FALLOC_FL_PUNCH_HOLE) {",
            "\t\tstruct address_space *mapping = file->f_mapping;",
            "\t\tloff_t unmap_start = round_up(offset, PAGE_SIZE);",
            "\t\tloff_t unmap_end = round_down(offset + len, PAGE_SIZE) - 1;",
            "\t\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(shmem_falloc_waitq);",
            "",
            "\t\t/* protected by i_rwsem */",
            "\t\tif (info->seals & (F_SEAL_WRITE | F_SEAL_FUTURE_WRITE)) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tshmem_falloc.waitq = &shmem_falloc_waitq;",
            "\t\tshmem_falloc.start = (u64)unmap_start >> PAGE_SHIFT;",
            "\t\tshmem_falloc.next = (unmap_end + 1) >> PAGE_SHIFT;",
            "\t\tspin_lock(&inode->i_lock);",
            "\t\tinode->i_private = &shmem_falloc;",
            "\t\tspin_unlock(&inode->i_lock);",
            "",
            "\t\tif ((u64)unmap_end > (u64)unmap_start)",
            "\t\t\tunmap_mapping_range(mapping, unmap_start,",
            "\t\t\t\t\t    1 + unmap_end - unmap_start, 0);",
            "\t\tshmem_truncate_range(inode, offset, offset + len - 1);",
            "\t\t/* No need to unmap again: hole-punching leaves COWed pages */",
            "",
            "\t\tspin_lock(&inode->i_lock);",
            "\t\tinode->i_private = NULL;",
            "\t\twake_up_all(&shmem_falloc_waitq);",
            "\t\tWARN_ON_ONCE(!list_empty(&shmem_falloc_waitq.head));",
            "\t\tspin_unlock(&inode->i_lock);",
            "\t\terror = 0;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* We need to check rlimit even when FALLOC_FL_KEEP_SIZE */",
            "\terror = inode_newsize_ok(inode, offset + len);",
            "\tif (error)",
            "\t\tgoto out;",
            "",
            "\tif ((info->seals & F_SEAL_GROW) && offset + len > inode->i_size) {",
            "\t\terror = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tstart = offset >> PAGE_SHIFT;",
            "\tend = (offset + len + PAGE_SIZE - 1) >> PAGE_SHIFT;",
            "\t/* Try to avoid a swapstorm if len is impossible to satisfy */",
            "\tif (sbinfo->max_blocks && end - start > sbinfo->max_blocks) {",
            "\t\terror = -ENOSPC;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tshmem_falloc.waitq = NULL;",
            "\tshmem_falloc.start = start;",
            "\tshmem_falloc.next  = start;",
            "\tshmem_falloc.nr_falloced = 0;",
            "\tshmem_falloc.nr_unswapped = 0;",
            "\tspin_lock(&inode->i_lock);",
            "\tinode->i_private = &shmem_falloc;",
            "\tspin_unlock(&inode->i_lock);",
            "",
            "\t/*",
            "\t * info->fallocend is only relevant when huge pages might be",
            "\t * involved: to prevent split_huge_page() freeing fallocated",
            "\t * pages when FALLOC_FL_KEEP_SIZE committed beyond i_size.",
            "\t */",
            "\tundo_fallocend = info->fallocend;",
            "\tif (info->fallocend < end)",
            "\t\tinfo->fallocend = end;",
            "",
            "\tfor (index = start; index < end; ) {",
            "\t\tstruct folio *folio;",
            "",
            "\t\t/*",
            "\t\t * Good, the fallocate(2) manpage permits EINTR: we may have",
            "\t\t * been interrupted because we are using up too much memory.",
            "\t\t */",
            "\t\tif (signal_pending(current))",
            "\t\t\terror = -EINTR;",
            "\t\telse if (shmem_falloc.nr_unswapped > shmem_falloc.nr_falloced)",
            "\t\t\terror = -ENOMEM;",
            "\t\telse",
            "\t\t\terror = shmem_get_folio(inode, index, offset + len,",
            "\t\t\t\t\t\t&folio, SGP_FALLOC);",
            "\t\tif (error) {",
            "\t\t\tinfo->fallocend = undo_fallocend;",
            "\t\t\t/* Remove the !uptodate folios we added */",
            "\t\t\tif (index > start) {",
            "\t\t\t\tshmem_undo_range(inode,",
            "\t\t\t\t    (loff_t)start << PAGE_SHIFT,",
            "\t\t\t\t    ((loff_t)index << PAGE_SHIFT) - 1, true);",
            "\t\t\t}",
            "\t\t\tgoto undone;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Here is a more important optimization than it appears:",
            "\t\t * a second SGP_FALLOC on the same large folio will clear it,",
            "\t\t * making it uptodate and un-undoable if we fail later.",
            "\t\t */",
            "\t\tindex = folio_next_index(folio);",
            "\t\t/* Beware 32-bit wraparound */",
            "\t\tif (!index)",
            "\t\t\tindex--;",
            "",
            "\t\t/*",
            "\t\t * Inform shmem_writepage() how far we have reached.",
            "\t\t * No need for lock or barrier: we have the page lock.",
            "\t\t */",
            "\t\tif (!folio_test_uptodate(folio))",
            "\t\t\tshmem_falloc.nr_falloced += index - shmem_falloc.next;",
            "\t\tshmem_falloc.next = index;",
            "",
            "\t\t/*",
            "\t\t * If !uptodate, leave it that way so that freeable folios",
            "\t\t * can be recognized if we need to rollback on error later.",
            "\t\t * But mark it dirty so that memory pressure will swap rather",
            "\t\t * than free the folios we are allocating (and SGP_CACHE folios",
            "\t\t * might still be clean: we now need to mark those dirty too).",
            "\t\t */",
            "\t\tfolio_mark_dirty(folio);",
            "\t\tfolio_unlock(folio);",
            "\t\tfolio_put(folio);",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\tif (!(mode & FALLOC_FL_KEEP_SIZE) && offset + len > inode->i_size)",
            "\t\ti_size_write(inode, offset + len);",
            "undone:",
            "\tspin_lock(&inode->i_lock);",
            "\tinode->i_private = NULL;",
            "\tspin_unlock(&inode->i_lock);",
            "out:",
            "\tif (!error)",
            "\t\tfile_modified(file);",
            "\tinode_unlock(inode);",
            "\treturn error;",
            "}"
          ],
          "function_name": "shmem_file_llseek, shmem_fallocate",
          "description": "提供文件定位与扩展控制，包含shmem_file_llseek实现文件寻址，shmem_fallocate执行文件扩展操作，支持孔洞打孔并维护分配范围，包含分配撤销机制防止资源泄漏",
          "similarity": 0.5245610475540161
        },
        {
          "chunk_id": 18,
          "file_path": "mm/shmem.c",
          "start_line": 3383,
          "end_line": 3549,
          "content": [
            "static ssize_t shmem_file_write_iter(struct kiocb *iocb, struct iov_iter *from)",
            "{",
            "\tstruct file *file = iocb->ki_filp;",
            "\tstruct inode *inode = file->f_mapping->host;",
            "\tssize_t ret;",
            "",
            "\tinode_lock(inode);",
            "\tret = generic_write_checks(iocb, from);",
            "\tif (ret <= 0)",
            "\t\tgoto unlock;",
            "\tret = file_remove_privs(file);",
            "\tif (ret)",
            "\t\tgoto unlock;",
            "\tret = file_update_time(file);",
            "\tif (ret)",
            "\t\tgoto unlock;",
            "\tret = generic_perform_write(iocb, from);",
            "unlock:",
            "\tinode_unlock(inode);",
            "\treturn ret;",
            "}",
            "static bool zero_pipe_buf_get(struct pipe_inode_info *pipe,",
            "\t\t\t      struct pipe_buffer *buf)",
            "{",
            "\treturn true;",
            "}",
            "static void zero_pipe_buf_release(struct pipe_inode_info *pipe,",
            "\t\t\t\t  struct pipe_buffer *buf)",
            "{",
            "}",
            "static bool zero_pipe_buf_try_steal(struct pipe_inode_info *pipe,",
            "\t\t\t\t    struct pipe_buffer *buf)",
            "{",
            "\treturn false;",
            "}",
            "static size_t splice_zeropage_into_pipe(struct pipe_inode_info *pipe,",
            "\t\t\t\t\tloff_t fpos, size_t size)",
            "{",
            "\tsize_t offset = fpos & ~PAGE_MASK;",
            "",
            "\tsize = min_t(size_t, size, PAGE_SIZE - offset);",
            "",
            "\tif (!pipe_is_full(pipe)) {",
            "\t\tstruct pipe_buffer *buf = pipe_head_buf(pipe);",
            "",
            "\t\t*buf = (struct pipe_buffer) {",
            "\t\t\t.ops\t= &zero_pipe_buf_ops,",
            "\t\t\t.page\t= ZERO_PAGE(0),",
            "\t\t\t.offset\t= offset,",
            "\t\t\t.len\t= size,",
            "\t\t};",
            "\t\tpipe->head++;",
            "\t}",
            "",
            "\treturn size;",
            "}",
            "static ssize_t shmem_file_splice_read(struct file *in, loff_t *ppos,",
            "\t\t\t\t      struct pipe_inode_info *pipe,",
            "\t\t\t\t      size_t len, unsigned int flags)",
            "{",
            "\tstruct inode *inode = file_inode(in);",
            "\tstruct address_space *mapping = inode->i_mapping;",
            "\tstruct folio *folio = NULL;",
            "\tsize_t total_spliced = 0, used, npages, n, part;",
            "\tloff_t isize;",
            "\tint error = 0;",
            "",
            "\t/* Work out how much data we can actually add into the pipe */",
            "\tused = pipe_buf_usage(pipe);",
            "\tnpages = max_t(ssize_t, pipe->max_usage - used, 0);",
            "\tlen = min_t(size_t, len, npages * PAGE_SIZE);",
            "",
            "\tdo {",
            "\t\tbool fallback_page_splice = false;",
            "\t\tstruct page *page = NULL;",
            "\t\tpgoff_t index;",
            "\t\tsize_t size;",
            "",
            "\t\tif (*ppos >= i_size_read(inode))",
            "\t\t\tbreak;",
            "",
            "\t\tindex = *ppos >> PAGE_SHIFT;",
            "\t\terror = shmem_get_folio(inode, index, 0, &folio, SGP_READ);",
            "\t\tif (error) {",
            "\t\t\tif (error == -EINVAL)",
            "\t\t\t\terror = 0;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (folio) {",
            "\t\t\tfolio_unlock(folio);",
            "",
            "\t\t\tpage = folio_file_page(folio, index);",
            "\t\t\tif (PageHWPoison(page)) {",
            "\t\t\t\terror = -EIO;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\tif (folio_test_large(folio) &&",
            "\t\t\t    folio_test_has_hwpoisoned(folio))",
            "\t\t\t\tfallback_page_splice = true;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * i_size must be checked after we know the pages are Uptodate.",
            "\t\t *",
            "\t\t * Checking i_size after the check allows us to calculate",
            "\t\t * the correct value for \"nr\", which means the zero-filled",
            "\t\t * part of the page is not copied back to userspace (unless",
            "\t\t * another truncate extends the file - this is desired though).",
            "\t\t */",
            "\t\tisize = i_size_read(inode);",
            "\t\tif (unlikely(*ppos >= isize))",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * Fallback to PAGE_SIZE splice if the large folio has hwpoisoned",
            "\t\t * pages.",
            "\t\t */",
            "\t\tsize = len;",
            "\t\tif (unlikely(fallback_page_splice)) {",
            "\t\t\tsize_t offset = *ppos & ~PAGE_MASK;",
            "",
            "\t\t\tsize = umin(size, PAGE_SIZE - offset);",
            "\t\t}",
            "\t\tpart = min_t(loff_t, isize - *ppos, size);",
            "",
            "\t\tif (folio) {",
            "\t\t\t/*",
            "\t\t\t * If users can be writing to this page using arbitrary",
            "\t\t\t * virtual addresses, take care about potential aliasing",
            "\t\t\t * before reading the page on the kernel side.",
            "\t\t\t */",
            "\t\t\tif (mapping_writably_mapped(mapping)) {",
            "\t\t\t\tif (likely(!fallback_page_splice))",
            "\t\t\t\t\tflush_dcache_folio(folio);",
            "\t\t\t\telse",
            "\t\t\t\t\tflush_dcache_page(page);",
            "\t\t\t}",
            "\t\t\tfolio_mark_accessed(folio);",
            "\t\t\t/*",
            "\t\t\t * Ok, we have the page, and it's up-to-date, so we can",
            "\t\t\t * now splice it into the pipe.",
            "\t\t\t */",
            "\t\t\tn = splice_folio_into_pipe(pipe, folio, *ppos, part);",
            "\t\t\tfolio_put(folio);",
            "\t\t\tfolio = NULL;",
            "\t\t} else {",
            "\t\t\tn = splice_zeropage_into_pipe(pipe, *ppos, part);",
            "\t\t}",
            "",
            "\t\tif (!n)",
            "\t\t\tbreak;",
            "\t\tlen -= n;",
            "\t\ttotal_spliced += n;",
            "\t\t*ppos += n;",
            "\t\tin->f_ra.prev_pos = *ppos;",
            "\t\tif (pipe_is_full(pipe))",
            "\t\t\tbreak;",
            "",
            "\t\tcond_resched();",
            "\t} while (len);",
            "",
            "\tif (folio)",
            "\t\tfolio_put(folio);",
            "",
            "\tfile_accessed(in);",
            "\treturn total_spliced ? total_spliced : error;",
            "}"
          ],
          "function_name": "shmem_file_write_iter, zero_pipe_buf_get, zero_pipe_buf_release, zero_pipe_buf_try_steal, splice_zeropage_into_pipe, shmem_file_splice_read",
          "description": "实现管道数据分片读取与零页处理，包含shmem_file_splice_read将文件数据分片读取到管道，通过splice_zeropage_into_pipe使用零页填充管道缓冲区，处理特殊缓冲区释放与重用",
          "similarity": 0.519668459892273
        },
        {
          "chunk_id": 20,
          "file_path": "mm/shmem.c",
          "start_line": 3736,
          "end_line": 3872,
          "content": [
            "static int shmem_statfs(struct dentry *dentry, struct kstatfs *buf)",
            "{",
            "\tstruct shmem_sb_info *sbinfo = SHMEM_SB(dentry->d_sb);",
            "",
            "\tbuf->f_type = TMPFS_MAGIC;",
            "\tbuf->f_bsize = PAGE_SIZE;",
            "\tbuf->f_namelen = NAME_MAX;",
            "\tif (sbinfo->max_blocks) {",
            "\t\tbuf->f_blocks = sbinfo->max_blocks;",
            "\t\tbuf->f_bavail =",
            "\t\tbuf->f_bfree  = sbinfo->max_blocks -",
            "\t\t\t\tpercpu_counter_sum(&sbinfo->used_blocks);",
            "\t}",
            "\tif (sbinfo->max_inodes) {",
            "\t\tbuf->f_files = sbinfo->max_inodes;",
            "\t\tbuf->f_ffree = sbinfo->free_ispace / BOGO_INODE_SIZE;",
            "\t}",
            "\t/* else leave those fields 0 like simple_statfs */",
            "",
            "\tbuf->f_fsid = uuid_to_fsid(dentry->d_sb->s_uuid.b);",
            "",
            "\treturn 0;",
            "}",
            "static int",
            "shmem_mknod(struct mnt_idmap *idmap, struct inode *dir,",
            "\t    struct dentry *dentry, umode_t mode, dev_t dev)",
            "{",
            "\tstruct inode *inode;",
            "\tint error;",
            "",
            "\tinode = shmem_get_inode(idmap, dir->i_sb, dir, mode, dev, VM_NORESERVE);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\terror = simple_acl_create(dir, inode);",
            "\tif (error)",
            "\t\tgoto out_iput;",
            "\terror = security_inode_init_security(inode, dir, &dentry->d_name,",
            "\t\t\t\t\t     shmem_initxattrs, NULL);",
            "\tif (error && error != -EOPNOTSUPP)",
            "\t\tgoto out_iput;",
            "",
            "\terror = simple_offset_add(shmem_get_offset_ctx(dir), dentry);",
            "\tif (error)",
            "\t\tgoto out_iput;",
            "",
            "\tdir->i_size += BOGO_DIRENT_SIZE;",
            "\tdir->i_mtime = inode_set_ctime_current(dir);",
            "\tinode_inc_iversion(dir);",
            "\td_instantiate(dentry, inode);",
            "\tdget(dentry); /* Extra count - pin the dentry in core */",
            "\treturn error;",
            "",
            "out_iput:",
            "\tiput(inode);",
            "\treturn error;",
            "}",
            "static int",
            "shmem_tmpfile(struct mnt_idmap *idmap, struct inode *dir,",
            "\t      struct file *file, umode_t mode)",
            "{",
            "\tstruct inode *inode;",
            "\tint error;",
            "",
            "\tinode = shmem_get_inode(idmap, dir->i_sb, dir, mode, 0, VM_NORESERVE);",
            "\tif (IS_ERR(inode)) {",
            "\t\terror = PTR_ERR(inode);",
            "\t\tgoto err_out;",
            "\t}",
            "\terror = security_inode_init_security(inode, dir, NULL,",
            "\t\t\t\t\t     shmem_initxattrs, NULL);",
            "\tif (error && error != -EOPNOTSUPP)",
            "\t\tgoto out_iput;",
            "\terror = simple_acl_create(dir, inode);",
            "\tif (error)",
            "\t\tgoto out_iput;",
            "\td_tmpfile(file, inode);",
            "",
            "err_out:",
            "\treturn finish_open_simple(file, error);",
            "out_iput:",
            "\tiput(inode);",
            "\treturn error;",
            "}",
            "static int shmem_mkdir(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t       struct dentry *dentry, umode_t mode)",
            "{",
            "\tint error;",
            "",
            "\terror = shmem_mknod(idmap, dir, dentry, mode | S_IFDIR, 0);",
            "\tif (error)",
            "\t\treturn error;",
            "\tinc_nlink(dir);",
            "\treturn 0;",
            "}",
            "static int shmem_create(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t\tstruct dentry *dentry, umode_t mode, bool excl)",
            "{",
            "\treturn shmem_mknod(idmap, dir, dentry, mode | S_IFREG, 0);",
            "}",
            "static int shmem_link(struct dentry *old_dentry, struct inode *dir,",
            "\t\t      struct dentry *dentry)",
            "{",
            "\tstruct inode *inode = d_inode(old_dentry);",
            "\tint ret = 0;",
            "",
            "\t/*",
            "\t * No ordinary (disk based) filesystem counts links as inodes;",
            "\t * but each new link needs a new dentry, pinning lowmem, and",
            "\t * tmpfs dentries cannot be pruned until they are unlinked.",
            "\t * But if an O_TMPFILE file is linked into the tmpfs, the",
            "\t * first link must skip that, to get the accounting right.",
            "\t */",
            "\tif (inode->i_nlink) {",
            "\t\tret = shmem_reserve_inode(inode->i_sb, NULL);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tret = simple_offset_add(shmem_get_offset_ctx(dir), dentry);",
            "\tif (ret) {",
            "\t\tif (inode->i_nlink)",
            "\t\t\tshmem_free_inode(inode->i_sb, 0);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tdir->i_size += BOGO_DIRENT_SIZE;",
            "\tdir->i_mtime = inode_set_ctime_to_ts(dir,",
            "\t\t\t\t\t     inode_set_ctime_current(inode));",
            "\tinode_inc_iversion(dir);",
            "\tinc_nlink(inode);",
            "\tihold(inode);\t/* New dentry reference */",
            "\tdget(dentry);\t/* Extra pinning count for the created dentry */",
            "\td_instantiate(dentry, inode);",
            "out:",
            "\treturn ret;",
            "}"
          ],
          "function_name": "shmem_statfs, shmem_mknod, shmem_tmpfile, shmem_mkdir, shmem_create, shmem_link",
          "description": "实现tmpfs文件系统中文件创建相关操作，包括statfs获取文件系统统计信息，mknod/mkdir/create/link用于创建普通文件、目录及硬链接，通过shmem_get_inode分配内存并设置文件属性，维护目录项与索引节点关联",
          "similarity": 0.5192912817001343
        },
        {
          "chunk_id": 16,
          "file_path": "mm/shmem.c",
          "start_line": 2837,
          "end_line": 3022,
          "content": [
            "static int shmem_set_policy(struct vm_area_struct *vma, struct mempolicy *mpol)",
            "{",
            "\tstruct inode *inode = file_inode(vma->vm_file);",
            "\treturn mpol_set_shared_policy(&SHMEM_I(inode)->policy, vma, mpol);",
            "}",
            "int shmem_lock(struct file *file, int lock, struct ucounts *ucounts)",
            "{",
            "\tstruct inode *inode = file_inode(file);",
            "\tstruct shmem_inode_info *info = SHMEM_I(inode);",
            "\tint retval = -ENOMEM;",
            "",
            "\t/*",
            "\t * What serializes the accesses to info->flags?",
            "\t * ipc_lock_object() when called from shmctl_do_lock(),",
            "\t * no serialization needed when called from shm_destroy().",
            "\t */",
            "\tif (lock && !(info->flags & VM_LOCKED)) {",
            "\t\tif (!user_shm_lock(inode->i_size, ucounts))",
            "\t\t\tgoto out_nomem;",
            "\t\tinfo->flags |= VM_LOCKED;",
            "\t\tmapping_set_unevictable(file->f_mapping);",
            "\t}",
            "\tif (!lock && (info->flags & VM_LOCKED) && ucounts) {",
            "\t\tuser_shm_unlock(inode->i_size, ucounts);",
            "\t\tinfo->flags &= ~VM_LOCKED;",
            "\t\tmapping_clear_unevictable(file->f_mapping);",
            "\t}",
            "\tretval = 0;",
            "",
            "out_nomem:",
            "\treturn retval;",
            "}",
            "static int shmem_mmap(struct file *file, struct vm_area_struct *vma)",
            "{",
            "\tstruct inode *inode = file_inode(file);",
            "\tstruct shmem_inode_info *info = SHMEM_I(inode);",
            "\tint ret;",
            "",
            "\tret = seal_check_write(info->seals, vma);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tfile_accessed(file);",
            "\t/* This is anonymous shared memory if it is unlinked at the time of mmap */",
            "\tif (inode->i_nlink)",
            "\t\tvma->vm_ops = &shmem_vm_ops;",
            "\telse",
            "\t\tvma->vm_ops = &shmem_anon_vm_ops;",
            "\treturn 0;",
            "}",
            "static int shmem_file_open(struct inode *inode, struct file *file)",
            "{",
            "\tfile->f_mode |= FMODE_CAN_ODIRECT;",
            "\treturn generic_file_open(inode, file);",
            "}",
            "static void shmem_set_inode_flags(struct inode *inode, unsigned int fsflags)",
            "{",
            "\tunsigned int i_flags = 0;",
            "",
            "\tif (fsflags & FS_NOATIME_FL)",
            "\t\ti_flags |= S_NOATIME;",
            "\tif (fsflags & FS_APPEND_FL)",
            "\t\ti_flags |= S_APPEND;",
            "\tif (fsflags & FS_IMMUTABLE_FL)",
            "\t\ti_flags |= S_IMMUTABLE;",
            "\t/*",
            "\t * But FS_NODUMP_FL does not require any action in i_flags.",
            "\t */",
            "\tinode_set_flags(inode, i_flags, S_NOATIME | S_APPEND | S_IMMUTABLE);",
            "}",
            "static void shmem_set_inode_flags(struct inode *inode, unsigned int fsflags)",
            "{",
            "}",
            "int shmem_mfill_atomic_pte(pmd_t *dst_pmd,",
            "\t\t\t   struct vm_area_struct *dst_vma,",
            "\t\t\t   unsigned long dst_addr,",
            "\t\t\t   unsigned long src_addr,",
            "\t\t\t   uffd_flags_t flags,",
            "\t\t\t   struct folio **foliop)",
            "{",
            "\tstruct inode *inode = file_inode(dst_vma->vm_file);",
            "\tstruct shmem_inode_info *info = SHMEM_I(inode);",
            "\tstruct address_space *mapping = inode->i_mapping;",
            "\tgfp_t gfp = mapping_gfp_mask(mapping);",
            "\tpgoff_t pgoff = linear_page_index(dst_vma, dst_addr);",
            "\tvoid *page_kaddr;",
            "\tstruct folio *folio;",
            "\tint ret;",
            "\tpgoff_t max_off;",
            "",
            "\tif (shmem_inode_acct_blocks(inode, 1)) {",
            "\t\t/*",
            "\t\t * We may have got a page, returned -ENOENT triggering a retry,",
            "\t\t * and now we find ourselves with -ENOMEM. Release the page, to",
            "\t\t * avoid a BUG_ON in our caller.",
            "\t\t */",
            "\t\tif (unlikely(*foliop)) {",
            "\t\t\tfolio_put(*foliop);",
            "\t\t\t*foliop = NULL;",
            "\t\t}",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tif (!*foliop) {",
            "\t\tret = -ENOMEM;",
            "\t\tfolio = shmem_alloc_folio(gfp, 0, info, pgoff);",
            "\t\tif (!folio)",
            "\t\t\tgoto out_unacct_blocks;",
            "",
            "\t\tif (uffd_flags_mode_is(flags, MFILL_ATOMIC_COPY)) {",
            "\t\t\tpage_kaddr = kmap_local_folio(folio, 0);",
            "\t\t\t/*",
            "\t\t\t * The read mmap_lock is held here.  Despite the",
            "\t\t\t * mmap_lock being read recursive a deadlock is still",
            "\t\t\t * possible if a writer has taken a lock.  For example:",
            "\t\t\t *",
            "\t\t\t * process A thread 1 takes read lock on own mmap_lock",
            "\t\t\t * process A thread 2 calls mmap, blocks taking write lock",
            "\t\t\t * process B thread 1 takes page fault, read lock on own mmap lock",
            "\t\t\t * process B thread 2 calls mmap, blocks taking write lock",
            "\t\t\t * process A thread 1 blocks taking read lock on process B",
            "\t\t\t * process B thread 1 blocks taking read lock on process A",
            "\t\t\t *",
            "\t\t\t * Disable page faults to prevent potential deadlock",
            "\t\t\t * and retry the copy outside the mmap_lock.",
            "\t\t\t */",
            "\t\t\tpagefault_disable();",
            "\t\t\tret = copy_from_user(page_kaddr,",
            "\t\t\t\t\t     (const void __user *)src_addr,",
            "\t\t\t\t\t     PAGE_SIZE);",
            "\t\t\tpagefault_enable();",
            "\t\t\tkunmap_local(page_kaddr);",
            "",
            "\t\t\t/* fallback to copy_from_user outside mmap_lock */",
            "\t\t\tif (unlikely(ret)) {",
            "\t\t\t\t*foliop = folio;",
            "\t\t\t\tret = -ENOENT;",
            "\t\t\t\t/* don't free the page */",
            "\t\t\t\tgoto out_unacct_blocks;",
            "\t\t\t}",
            "",
            "\t\t\tflush_dcache_folio(folio);",
            "\t\t} else {\t\t/* ZEROPAGE */",
            "\t\t\tclear_user_highpage(&folio->page, dst_addr);",
            "\t\t}",
            "\t} else {",
            "\t\tfolio = *foliop;",
            "\t\tVM_BUG_ON_FOLIO(folio_test_large(folio), folio);",
            "\t\t*foliop = NULL;",
            "\t}",
            "",
            "\tVM_BUG_ON(folio_test_locked(folio));",
            "\tVM_BUG_ON(folio_test_swapbacked(folio));",
            "\t__folio_set_locked(folio);",
            "\t__folio_set_swapbacked(folio);",
            "\t__folio_mark_uptodate(folio);",
            "",
            "\tret = -EFAULT;",
            "\tmax_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);",
            "\tif (unlikely(pgoff >= max_off))",
            "\t\tgoto out_release;",
            "",
            "\tret = mem_cgroup_charge(folio, dst_vma->vm_mm, gfp);",
            "\tif (ret)",
            "\t\tgoto out_release;",
            "\tret = shmem_add_to_page_cache(folio, mapping, pgoff, NULL, gfp);",
            "\tif (ret)",
            "\t\tgoto out_release;",
            "",
            "\tret = mfill_atomic_install_pte(dst_pmd, dst_vma, dst_addr,",
            "\t\t\t\t       &folio->page, true, flags);",
            "\tif (ret)",
            "\t\tgoto out_delete_from_cache;",
            "",
            "\tshmem_recalc_inode(inode, 1, 0);",
            "\tfolio_unlock(folio);",
            "\treturn 0;",
            "out_delete_from_cache:",
            "\tfilemap_remove_folio(folio);",
            "out_release:",
            "\tfolio_unlock(folio);",
            "\tfolio_put(folio);",
            "out_unacct_blocks:",
            "\tshmem_inode_unacct_blocks(inode, 1);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "shmem_set_policy, shmem_lock, shmem_mmap, shmem_file_open, shmem_set_inode_flags, shmem_set_inode_flags, shmem_mfill_atomic_pte",
          "description": "提供共享内存策略设置、锁操作、mmap映射配置、文件打开及原子页填充功能，包含shmem_set_policy设置内存策略，shmem_lock管理内存锁定，shmem_mmap配置虚拟内存区域，shmem_mfill_atomic_pte执行原子页填充",
          "similarity": 0.5191735029220581
        },
        {
          "chunk_id": 15,
          "file_path": "mm/shmem.c",
          "start_line": 2617,
          "end_line": 2808,
          "content": [
            "int shmem_get_folio(struct inode *inode, pgoff_t index, loff_t write_end,",
            "\t\t    struct folio **foliop, enum sgp_type sgp)",
            "{",
            "\treturn shmem_get_folio_gfp(inode, index, write_end, foliop, sgp,",
            "\t\t\tmapping_gfp_mask(inode->i_mapping), NULL, NULL);",
            "}",
            "static int synchronous_wake_function(wait_queue_entry_t *wait,",
            "\t\t\tunsigned int mode, int sync, void *key)",
            "{",
            "\tint ret = default_wake_function(wait, mode, sync, key);",
            "\tlist_del_init(&wait->entry);",
            "\treturn ret;",
            "}",
            "static vm_fault_t shmem_falloc_wait(struct vm_fault *vmf, struct inode *inode)",
            "{",
            "\tstruct shmem_falloc *shmem_falloc;",
            "\tstruct file *fpin = NULL;",
            "\tvm_fault_t ret = 0;",
            "",
            "\tspin_lock(&inode->i_lock);",
            "\tshmem_falloc = inode->i_private;",
            "\tif (shmem_falloc &&",
            "\t    shmem_falloc->waitq &&",
            "\t    vmf->pgoff >= shmem_falloc->start &&",
            "\t    vmf->pgoff < shmem_falloc->next) {",
            "\t\twait_queue_head_t *shmem_falloc_waitq;",
            "\t\tDEFINE_WAIT_FUNC(shmem_fault_wait, synchronous_wake_function);",
            "",
            "\t\tret = VM_FAULT_NOPAGE;",
            "\t\tfpin = maybe_unlock_mmap_for_io(vmf, NULL);",
            "\t\tshmem_falloc_waitq = shmem_falloc->waitq;",
            "\t\tprepare_to_wait(shmem_falloc_waitq, &shmem_fault_wait,",
            "\t\t\t\tTASK_UNINTERRUPTIBLE);",
            "\t\tspin_unlock(&inode->i_lock);",
            "\t\tschedule();",
            "",
            "\t\t/*",
            "\t\t * shmem_falloc_waitq points into the shmem_fallocate()",
            "\t\t * stack of the hole-punching task: shmem_falloc_waitq",
            "\t\t * is usually invalid by the time we reach here, but",
            "\t\t * finish_wait() does not dereference it in that case;",
            "\t\t * though i_lock needed lest racing with wake_up_all().",
            "\t\t */",
            "\t\tspin_lock(&inode->i_lock);",
            "\t\tfinish_wait(shmem_falloc_waitq, &shmem_fault_wait);",
            "\t}",
            "\tspin_unlock(&inode->i_lock);",
            "\tif (fpin) {",
            "\t\tfput(fpin);",
            "\t\tret = VM_FAULT_RETRY;",
            "\t}",
            "\treturn ret;",
            "}",
            "static vm_fault_t shmem_fault(struct vm_fault *vmf)",
            "{",
            "\tstruct inode *inode = file_inode(vmf->vma->vm_file);",
            "\tgfp_t gfp = mapping_gfp_mask(inode->i_mapping);",
            "\tstruct folio *folio = NULL;",
            "\tvm_fault_t ret = 0;",
            "\tint err;",
            "",
            "\t/*",
            "\t * Trinity finds that probing a hole which tmpfs is punching can",
            "\t * prevent the hole-punch from ever completing: noted in i_private.",
            "\t */",
            "\tif (unlikely(inode->i_private)) {",
            "\t\tret = shmem_falloc_wait(vmf, inode);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tWARN_ON_ONCE(vmf->page != NULL);",
            "\terr = shmem_get_folio_gfp(inode, vmf->pgoff, 0, &folio, SGP_CACHE,",
            "\t\t\t\t  gfp, vmf, &ret);",
            "\tif (err)",
            "\t\treturn vmf_error(err);",
            "\tif (folio) {",
            "\t\tvmf->page = folio_file_page(folio, vmf->pgoff);",
            "\t\tret |= VM_FAULT_LOCKED;",
            "\t}",
            "\treturn ret;",
            "}",
            "unsigned long shmem_get_unmapped_area(struct file *file,",
            "\t\t\t\t      unsigned long uaddr, unsigned long len,",
            "\t\t\t\t      unsigned long pgoff, unsigned long flags)",
            "{",
            "\tunsigned long (*get_area)(struct file *,",
            "\t\tunsigned long, unsigned long, unsigned long, unsigned long);",
            "\tunsigned long addr;",
            "\tunsigned long offset;",
            "\tunsigned long inflated_len;",
            "\tunsigned long inflated_addr;",
            "\tunsigned long inflated_offset;",
            "\tunsigned long hpage_size;",
            "",
            "\tif (len > TASK_SIZE)",
            "\t\treturn -ENOMEM;",
            "",
            "\tget_area = current->mm->get_unmapped_area;",
            "\taddr = get_area(file, uaddr, len, pgoff, flags);",
            "",
            "\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))",
            "\t\treturn addr;",
            "\tif (IS_ERR_VALUE(addr))",
            "\t\treturn addr;",
            "\tif (addr & ~PAGE_MASK)",
            "\t\treturn addr;",
            "\tif (addr > TASK_SIZE - len)",
            "\t\treturn addr;",
            "",
            "\tif (shmem_huge == SHMEM_HUGE_DENY)",
            "\t\treturn addr;",
            "\tif (flags & MAP_FIXED)",
            "\t\treturn addr;",
            "\t/*",
            "\t * Our priority is to support MAP_SHARED mapped hugely;",
            "\t * and support MAP_PRIVATE mapped hugely too, until it is COWed.",
            "\t * But if caller specified an address hint and we allocated area there",
            "\t * successfully, respect that as before.",
            "\t */",
            "\tif (uaddr == addr)",
            "\t\treturn addr;",
            "",
            "\thpage_size = HPAGE_PMD_SIZE;",
            "\tif (shmem_huge != SHMEM_HUGE_FORCE) {",
            "\t\tstruct super_block *sb;",
            "\t\tunsigned long __maybe_unused hpage_orders;",
            "\t\tint order = 0;",
            "",
            "\t\tif (file) {",
            "\t\t\tVM_BUG_ON(file->f_op != &shmem_file_operations);",
            "\t\t\tsb = file_inode(file)->i_sb;",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * Called directly from mm/mmap.c, or drivers/char/mem.c",
            "\t\t\t * for \"/dev/zero\", to create a shared anonymous object.",
            "\t\t\t */",
            "\t\t\tif (IS_ERR(shm_mnt))",
            "\t\t\t\treturn addr;",
            "\t\t\tsb = shm_mnt->mnt_sb;",
            "",
            "\t\t\t/*",
            "\t\t\t * Find the highest mTHP order used for anonymous shmem to",
            "\t\t\t * provide a suitable alignment address.",
            "\t\t\t */",
            "#ifdef CONFIG_TRANSPARENT_HUGEPAGE",
            "\t\t\thpage_orders = READ_ONCE(huge_shmem_orders_always);",
            "\t\t\thpage_orders |= READ_ONCE(huge_shmem_orders_within_size);",
            "\t\t\thpage_orders |= READ_ONCE(huge_shmem_orders_madvise);",
            "\t\t\tif (SHMEM_SB(sb)->huge != SHMEM_HUGE_NEVER)",
            "\t\t\t\thpage_orders |= READ_ONCE(huge_shmem_orders_inherit);",
            "",
            "\t\t\tif (hpage_orders > 0) {",
            "\t\t\t\torder = highest_order(hpage_orders);",
            "\t\t\t\thpage_size = PAGE_SIZE << order;",
            "\t\t\t}",
            "#endif",
            "\t\t}",
            "\t\tif (SHMEM_SB(sb)->huge == SHMEM_HUGE_NEVER && !order)",
            "\t\t\treturn addr;",
            "\t}",
            "",
            "\tif (len < hpage_size)",
            "\t\treturn addr;",
            "",
            "\toffset = (pgoff << PAGE_SHIFT) & (hpage_size - 1);",
            "\tif (offset && offset + len < 2 * hpage_size)",
            "\t\treturn addr;",
            "\tif ((addr & (hpage_size - 1)) == offset)",
            "\t\treturn addr;",
            "",
            "\tinflated_len = len + hpage_size - PAGE_SIZE;",
            "\tif (inflated_len > TASK_SIZE)",
            "\t\treturn addr;",
            "\tif (inflated_len < len)",
            "\t\treturn addr;",
            "",
            "\tinflated_addr = get_area(NULL, uaddr, inflated_len, 0, flags);",
            "\tif (IS_ERR_VALUE(inflated_addr))",
            "\t\treturn addr;",
            "\tif (inflated_addr & ~PAGE_MASK)",
            "\t\treturn addr;",
            "",
            "\tinflated_offset = inflated_addr & (hpage_size - 1);",
            "\tinflated_addr += offset - inflated_offset;",
            "\tif (inflated_offset > offset)",
            "\t\tinflated_addr += hpage_size;",
            "",
            "\tif (inflated_addr > TASK_SIZE - len)",
            "\t\treturn addr;",
            "\treturn inflated_addr;",
            "}"
          ],
          "function_name": "shmem_get_folio, synchronous_wake_function, shmem_falloc_wait, shmem_fault, shmem_get_unmapped_area",
          "description": "实现共享内存页面分配与地址映射，包含shmem_get_folio获取页面，synchronous_wake_function同步唤醒等待队列，shmem_falloc_wait处理文件分配等待逻辑，shmem_fault处理页面故障，shmem_get_unmapped_area查找未映射区域并支持透明大页",
          "similarity": 0.5173348188400269
        }
      ]
    },
    {
      "source_file": "kernel/time/namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:40:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\namespace.c`\n\n---\n\n# time/namespace.c 技术文档\n\n## 1. 文件概述\n\n`time/namespace.c` 实现了 Linux 内核中的 **时间命名空间（time namespace）** 功能，允许不同进程组拥有独立的时间视图。该机制主要用于容器化环境中，使容器内的进程能够看到与宿主机或其他容器不同的系统时间（特别是 `CLOCK_MONOTONIC` 和 `CLOCK_BOOTTIME` 等单调时钟）。时间命名空间通过偏移量（offset）机制实现，不影响真实硬件时钟，仅在用户空间通过 VDSO（虚拟动态共享对象）提供转换后的时间值。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `do_timens_ktime_to_host()` | 将时间命名空间中的时间值转换回宿主机时间（减去偏移量），用于内核内部时间比较 |\n| `clone_time_ns()` | 克隆一个时间命名空间，分配资源并初始化 VVAR 页面 |\n| `copy_time_ns()` | 根据 `CLONE_NEWTIME` 标志决定是克隆还是复用现有时间命名空间 |\n| `timens_setup_vdso_data()` | 在 VDSO 数据页中设置时间偏移量，供用户空间读取 |\n| `find_timens_vvar_page()` | 为进程查找其所属时间命名空间的 VVAR 页面 |\n| `timens_set_vvar_page()` | 初始化时间命名空间的 VVAR 页面（仅首次进入时执行） |\n| `free_time_ns()` | 释放时间命名空间占用的资源 |\n| `timens_commit()` | 在任务切换到新时间命名空间时提交配置（设置 VVAR 和 VDSO） |\n| `timens_install()` | 安装新的时间命名空间到当前进程（需权限检查） |\n| `timens_on_fork()` | 子进程 fork 时继承父进程的 `time_ns_for_children` |\n\n### 关键数据结构\n\n- `struct time_namespace`：时间命名空间的核心结构，包含：\n  - `vvar_page`：用于 VDSO 的特殊内存页\n  - `offsets`：`monotonic` 和 `boottime` 时钟的偏移量\n  - `frozen_offsets`：标志位，表示偏移量是否已固化（防止重复初始化）\n  - `user_ns`：所属的用户命名空间\n  - `ucounts`：资源计数器，限制时间命名空间创建数量\n\n- `struct timens_offsets`：存储 `CLOCK_MONOTONIC` 和 `CLOCK_BOOTTIME` 的偏移量（`timespec64` 格式）\n\n- `struct timens_offset`：VDSO 中使用的偏移量结构（`sec` + `nsec`）\n\n## 3. 关键实现\n\n### 时间偏移转换机制\n- `do_timens_ktime_to_host()` 负责将命名空间内的时间值（如定时器到期时间）转换为宿主机视角的时间。\n- 对于 `CLOCK_MONOTONIC` 和 `CLOCK_BOOTTIME`，减去对应的偏移量。\n- 若转换后时间小于 0，则视为已过期，返回 0。\n- 转换结果被限制在 `[0, KTIME_MAX]` 范围内。\n\n### VDSO 集成\n- 时间命名空间通过 **VVAR 页面** 向用户空间暴露偏移量。\n- 正常进程的 VDSO 布局：`VVAR → PVCLOCK → HVCLOCK`\n- 时间命名空间进程的 VDSO 布局：`TIMENS → PVCLOCK → HVCLOCK → VVAR`\n- `timens_setup_vdso_data()` 在 VVAR 页面中设置 `clock_mode = VDSO_CLOCKMODE_TIMENS` 并填充各时钟的偏移量。\n- 用户空间 VDSO 代码根据 `clock_mode` 决定是否应用偏移。\n\n### 偏移量初始化保护\n- 使用全局 `offset_lock` 互斥锁确保 `vvar_page` 仅被初始化一次。\n- `frozen_offsets` 标志位避免重复初始化，提高性能（快路径无锁）。\n\n### 资源管理与权限控制\n- 通过 `ucounts` 限制每个用户命名空间可创建的时间命名空间数量（防 DoS）。\n- `timens_install()` 要求调用者在**目标命名空间**和**当前命名空间**均具备 `CAP_SYS_ADMIN` 权限。\n- 仅允许单线程进程（`current_is_single_threaded()`）切换时间命名空间，避免多线程一致性问题。\n\n### 进程继承模型\n- 每个进程拥有两个时间命名空间指针：\n  - `time_ns`：当前生效的时间命名空间\n  - `time_ns_for_children`：子进程将继承的时间命名空间\n- `timens_on_fork()` 确保子进程正确继承父进程的 `time_ns_for_children`\n\n## 4. 依赖关系\n\n| 依赖模块 | 用途 |\n|---------|------|\n| `<linux/user_namespace.h>` | 用户命名空间支持，用于权限隔离和资源计数 |\n| `<linux/proc_ns.h>` | 命名空间 proc 接口（如 `/proc/PID/ns/time`） |\n| `<vdso/datapage.h>` | VDSO 数据页结构定义 |\n| `<linux/clocksource.h>` | 时钟源相关常量（如 `CS_BASES`） |\n| `<linux/sched/*.h>` | 进程调度和 nsproxy 管理 |\n| `<linux/cred.h>` | 凭据和权限检查（`ns_capable()`） |\n| `<linux/mm.h>` | 内存管理（`alloc_page()`、`vm_area_struct`） |\n\n## 5. 使用场景\n\n1. **容器时间隔离**  \n   容器运行时（如 LXC、systemd-nspawn）可通过 `unshare(CLONE_NEWTIME)` 创建独立时间视图，使容器内 `CLOCK_MONOTONIC` 从 0 开始计时，便于测试或迁移。\n\n2. **系统时间回滚测试**  \n   开发者可在时间命名空间中设置负偏移量，模拟系统时间回退场景，验证应用程序的健壮性。\n\n3. **沙箱环境**  \n   安全沙箱可限制进程看到的时间范围，防止基于时间的侧信道攻击。\n\n4. **VDSO 优化路径**  \n   用户空间通过 VDSO 直接读取偏移后的时间，无需系统调用，性能开销极低。\n\n5. **命名空间组合**  \n   时间命名空间通常与 PID、mount、user 等命名空间联合使用，构建完整的隔离环境。",
      "similarity": 0.5682226419448853,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/time/namespace.c",
          "start_line": 298,
          "end_line": 448,
          "content": [
            "void timens_commit(struct task_struct *tsk, struct time_namespace *ns)",
            "{",
            "\ttimens_set_vvar_page(tsk, ns);",
            "\tvdso_join_timens(tsk, ns);",
            "}",
            "static int timens_install(struct nsset *nsset, struct ns_common *new)",
            "{",
            "\tstruct nsproxy *nsproxy = nsset->nsproxy;",
            "\tstruct time_namespace *ns = to_time_ns(new);",
            "",
            "\tif (!current_is_single_threaded())",
            "\t\treturn -EUSERS;",
            "",
            "\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||",
            "\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tget_time_ns(ns);",
            "\tput_time_ns(nsproxy->time_ns);",
            "\tnsproxy->time_ns = ns;",
            "",
            "\tget_time_ns(ns);",
            "\tput_time_ns(nsproxy->time_ns_for_children);",
            "\tnsproxy->time_ns_for_children = ns;",
            "\treturn 0;",
            "}",
            "void timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk)",
            "{",
            "\tstruct ns_common *nsc = &nsproxy->time_ns_for_children->ns;",
            "\tstruct time_namespace *ns = to_time_ns(nsc);",
            "",
            "\t/* create_new_namespaces() already incremented the ref counter */",
            "\tif (nsproxy->time_ns == nsproxy->time_ns_for_children)",
            "\t\treturn;",
            "",
            "\tget_time_ns(ns);",
            "\tput_time_ns(nsproxy->time_ns);",
            "\tnsproxy->time_ns = ns;",
            "",
            "\ttimens_commit(tsk, ns);",
            "}",
            "static void show_offset(struct seq_file *m, int clockid, struct timespec64 *ts)",
            "{",
            "\tchar *clock;",
            "",
            "\tswitch (clockid) {",
            "\tcase CLOCK_BOOTTIME:",
            "\t\tclock = \"boottime\";",
            "\t\tbreak;",
            "\tcase CLOCK_MONOTONIC:",
            "\t\tclock = \"monotonic\";",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tclock = \"unknown\";",
            "\t\tbreak;",
            "\t}",
            "\tseq_printf(m, \"%-10s %10lld %9ld\\n\", clock, ts->tv_sec, ts->tv_nsec);",
            "}",
            "void proc_timens_show_offsets(struct task_struct *p, struct seq_file *m)",
            "{",
            "\tstruct ns_common *ns;",
            "\tstruct time_namespace *time_ns;",
            "",
            "\tns = timens_for_children_get(p);",
            "\tif (!ns)",
            "\t\treturn;",
            "\ttime_ns = to_time_ns(ns);",
            "",
            "\tshow_offset(m, CLOCK_MONOTONIC, &time_ns->offsets.monotonic);",
            "\tshow_offset(m, CLOCK_BOOTTIME, &time_ns->offsets.boottime);",
            "\tput_time_ns(time_ns);",
            "}",
            "int proc_timens_set_offset(struct file *file, struct task_struct *p,",
            "\t\t\t   struct proc_timens_offset *offsets, int noffsets)",
            "{",
            "\tstruct ns_common *ns;",
            "\tstruct time_namespace *time_ns;",
            "\tstruct timespec64 tp;",
            "\tint i, err;",
            "",
            "\tns = timens_for_children_get(p);",
            "\tif (!ns)",
            "\t\treturn -ESRCH;",
            "\ttime_ns = to_time_ns(ns);",
            "",
            "\tif (!file_ns_capable(file, time_ns->user_ns, CAP_SYS_TIME)) {",
            "\t\tput_time_ns(time_ns);",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\tfor (i = 0; i < noffsets; i++) {",
            "\t\tstruct proc_timens_offset *off = &offsets[i];",
            "",
            "\t\tswitch (off->clockid) {",
            "\t\tcase CLOCK_MONOTONIC:",
            "\t\t\tktime_get_ts64(&tp);",
            "\t\t\tbreak;",
            "\t\tcase CLOCK_BOOTTIME:",
            "\t\t\tktime_get_boottime_ts64(&tp);",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\terr = -ERANGE;",
            "",
            "\t\tif (off->val.tv_sec > KTIME_SEC_MAX ||",
            "\t\t    off->val.tv_sec < -KTIME_SEC_MAX)",
            "\t\t\tgoto out;",
            "",
            "\t\ttp = timespec64_add(tp, off->val);",
            "\t\t/*",
            "\t\t * KTIME_SEC_MAX is divided by 2 to be sure that KTIME_MAX is",
            "\t\t * still unreachable.",
            "\t\t */",
            "\t\tif (tp.tv_sec < 0 || tp.tv_sec > KTIME_SEC_MAX / 2)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tmutex_lock(&offset_lock);",
            "\tif (time_ns->frozen_offsets) {",
            "\t\terr = -EACCES;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\terr = 0;",
            "\t/* Don't report errors after this line */",
            "\tfor (i = 0; i < noffsets; i++) {",
            "\t\tstruct proc_timens_offset *off = &offsets[i];",
            "\t\tstruct timespec64 *offset = NULL;",
            "",
            "\t\tswitch (off->clockid) {",
            "\t\tcase CLOCK_MONOTONIC:",
            "\t\t\toffset = &time_ns->offsets.monotonic;",
            "\t\t\tbreak;",
            "\t\tcase CLOCK_BOOTTIME:",
            "\t\t\toffset = &time_ns->offsets.boottime;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t*offset = off->val;",
            "\t}",
            "",
            "out_unlock:",
            "\tmutex_unlock(&offset_lock);",
            "out:",
            "\tput_time_ns(time_ns);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "timens_commit, timens_install, timens_on_fork, show_offset, proc_timens_show_offsets, proc_timens_set_offset",
          "description": "实现时间命名空间的安装传播机制，包含命名空间继承处理、偏移量展示接口、时钟偏移量设置接口及其权限校验逻辑。",
          "similarity": 0.4836350679397583
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/namespace.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Author: Andrei Vagin <avagin@openvz.org>",
            " * Author: Dmitry Safonov <dima@arista.com>",
            " */",
            "",
            "#include <linux/time_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/export.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "",
            "#include <vdso/datapage.h>",
            ""
          ],
          "function_name": null,
          "description": "包含时间命名空间所需头文件，声明时间、用户命名空间及内核通用结构体，为后续时间命名空间实现提供类型和函数声明支持。",
          "similarity": 0.460713267326355
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/namespace.c",
          "start_line": 23,
          "end_line": 124,
          "content": [
            "ktime_t do_timens_ktime_to_host(clockid_t clockid, ktime_t tim,",
            "\t\t\t\tstruct timens_offsets *ns_offsets)",
            "{",
            "\tktime_t offset;",
            "",
            "\tswitch (clockid) {",
            "\tcase CLOCK_MONOTONIC:",
            "\t\toffset = timespec64_to_ktime(ns_offsets->monotonic);",
            "\t\tbreak;",
            "\tcase CLOCK_BOOTTIME:",
            "\tcase CLOCK_BOOTTIME_ALARM:",
            "\t\toffset = timespec64_to_ktime(ns_offsets->boottime);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn tim;",
            "\t}",
            "",
            "\t/*",
            "\t * Check that @tim value is in [offset, KTIME_MAX + offset]",
            "\t * and subtract offset.",
            "\t */",
            "\tif (tim < offset) {",
            "\t\t/*",
            "\t\t * User can specify @tim *absolute* value - if it's lesser than",
            "\t\t * the time namespace's offset - it's already expired.",
            "\t\t */",
            "\t\ttim = 0;",
            "\t} else {",
            "\t\ttim = ktime_sub(tim, offset);",
            "\t\tif (unlikely(tim > KTIME_MAX))",
            "\t\t\ttim = KTIME_MAX;",
            "\t}",
            "",
            "\treturn tim;",
            "}",
            "static void dec_time_namespaces(struct ucounts *ucounts)",
            "{",
            "\tdec_ucount(ucounts, UCOUNT_TIME_NAMESPACES);",
            "}",
            "static struct timens_offset offset_from_ts(struct timespec64 off)",
            "{",
            "\tstruct timens_offset ret;",
            "",
            "\tret.sec = off.tv_sec;",
            "\tret.nsec = off.tv_nsec;",
            "",
            "\treturn ret;",
            "}",
            "static void timens_setup_vdso_data(struct vdso_data *vdata,",
            "\t\t\t\t   struct time_namespace *ns)",
            "{",
            "\tstruct timens_offset *offset = vdata->offset;",
            "\tstruct timens_offset monotonic = offset_from_ts(ns->offsets.monotonic);",
            "\tstruct timens_offset boottime = offset_from_ts(ns->offsets.boottime);",
            "",
            "\tvdata->seq\t\t\t= 1;",
            "\tvdata->clock_mode\t\t= VDSO_CLOCKMODE_TIMENS;",
            "\toffset[CLOCK_MONOTONIC]\t\t= monotonic;",
            "\toffset[CLOCK_MONOTONIC_RAW]\t= monotonic;",
            "\toffset[CLOCK_MONOTONIC_COARSE]\t= monotonic;",
            "\toffset[CLOCK_BOOTTIME]\t\t= boottime;",
            "\toffset[CLOCK_BOOTTIME_ALARM]\t= boottime;",
            "}",
            "static void timens_set_vvar_page(struct task_struct *task,",
            "\t\t\t\tstruct time_namespace *ns)",
            "{",
            "\tstruct vdso_data *vdata;",
            "\tunsigned int i;",
            "",
            "\tif (ns == &init_time_ns)",
            "\t\treturn;",
            "",
            "\t/* Fast-path, taken by every task in namespace except the first. */",
            "\tif (likely(ns->frozen_offsets))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&offset_lock);",
            "\t/* Nothing to-do: vvar_page has been already initialized. */",
            "\tif (ns->frozen_offsets)",
            "\t\tgoto out;",
            "",
            "\tns->frozen_offsets = true;",
            "\tvdata = arch_get_vdso_data(page_address(ns->vvar_page));",
            "",
            "\tfor (i = 0; i < CS_BASES; i++)",
            "\t\ttimens_setup_vdso_data(&vdata[i], ns);",
            "",
            "out:",
            "\tmutex_unlock(&offset_lock);",
            "}",
            "void free_time_ns(struct time_namespace *ns)",
            "{",
            "\tdec_time_namespaces(ns->ucounts);",
            "\tput_user_ns(ns->user_ns);",
            "\tns_free_inum(&ns->ns);",
            "\t__free_page(ns->vvar_page);",
            "\tkfree(ns);",
            "}",
            "static void timens_put(struct ns_common *ns)",
            "{",
            "\tput_time_ns(to_time_ns(ns));",
            "}"
          ],
          "function_name": "do_timens_ktime_to_host, dec_time_namespaces, offset_from_ts, timens_setup_vdso_data, timens_set_vvar_page, free_time_ns, timens_put",
          "description": "实现时间命名空间偏移转换逻辑，包括时间转换、引用计数更新、VDSO数据初始化、页内存释放及命名空间引用计数管理等功能模块。",
          "similarity": 0.4522974193096161
        }
      ]
    },
    {
      "source_file": "mm/process_vm_access.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:13:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `process_vm_access.c`\n\n---\n\n# `process_vm_access.c` 技术文档\n\n## 1. 文件概述\n\n`process_vm_access.c` 是 Linux 内核中实现跨进程虚拟内存读写功能的核心文件，提供了系统调用 `process_vm_readv` 和 `process_vm_writev` 的底层支持。该机制允许一个进程在无需目标进程协作的情况下，安全地从另一个进程中读取或向其写入数据，常用于调试器、容器运行时、性能分析工具等需要跨进程内存访问的场景。其实现基于内核的页表管理和用户页锁定（`pin_user_pages_remote`）机制，在保证安全性的同时避免了传统 `ptrace` 方式的上下文切换开销。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`process_vm_rw_pages`**  \n  执行实际的页面级内存拷贝操作，根据 `vm_write` 标志决定是将本地数据写入目标页（`copy_page_from_iter`）还是从目标页读取到本地（`copy_page_to_iter`）。\n\n- **`process_vm_rw_single_vec`**  \n  处理单个内存区域（由起始地址和长度定义）的读写操作。负责计算所需页数、通过 `pin_user_pages_remote` 锁定目标进程的物理页，并调用 `process_vm_rw_pages` 执行拷贝。\n\n- **`process_vm_rw_core`**  \n  核心调度函数，遍历远程进程的 iovec 数组（`rvec`），对每个内存段调用 `process_vm_rw_single_vec`。管理页指针数组的分配（栈上或动态）、目标进程查找（`find_get_task_by_vpid`）及内存描述符访问（`mm_access`）。\n\n- **`process_vm_rw`**  \n  系统调用入口的封装层，负责验证并导入用户态传入的本地（`lvec`）和远程（`rvec`）iovec 数组，初始化 `iov_iter` 迭代器，并调用 `process_vm_rw_core`。\n\n- **`SYSCALL_DEFINE6(process_vm_readv, ...)`**  \n  `process_vm_readv` 系统调用的定义（代码片段截断，但完整实现会在此处调用 `process_vm_rw` 并设置 `vm_write=0`）。\n\n- **`SYSCALL_DEFINE6(process_vm_writev, ...)`**  \n  （隐含存在）`process_vm_writev` 系统调用的定义，调用 `process_vm_rw` 并设置 `vm_write=1`。\n\n### 关键数据结构与常量\n\n- **`PVM_MAX_PP_ARRAY_COUNT`** (`16`)  \n  栈上预分配的 `struct page*` 数组的最大元素数量，用于存储待操作页的指针，避免小规模操作时的动态分配。\n\n- **`PVM_MAX_KMALLOC_PAGES`** (`PAGE_SIZE * 2`)  \n  动态分配 `struct page*` 数组时的最大内存限制（以字节计），确保 `kmalloc` 调用的可靠性。\n\n- **`iov_iter`**  \n  内核通用的 I/O 迭代器，用于高效遍历本地缓冲区（`lvec`）。\n\n## 3. 关键实现\n\n- **分页处理与批量锁定**：  \n  函数 `process_vm_rw_single_vec` 将大块内存访问拆分为多个页面批次处理。每批次最多处理 `PVM_MAX_KMALLOC_PAGES / sizeof(struct page*)` 个页，通过 `pin_user_pages_remote` 在目标进程的 `mm_struct` 上下文中锁定物理页，确保在拷贝期间页不会被换出或释放。\n\n- **内存安全与权限检查**：  \n  使用 `mm_access(task, PTRACE_MODE_ATTACH_REALCREDS)` 检查调用者是否有权访问目标进程的内存，该模式要求调用者具有 `CAP_SYS_PTRACE` 能力或满足 ptrace 附加条件。若返回 `-EACCES`，则转换为更合适的 `-EPERM` 错误码。\n\n- **资源管理与错误处理**：  \n  - 页指针数组优先使用栈空间（`pp_stack`），超出 `PVM_MAX_PP_ARRAY_COUNT` 时才动态分配。\n  - 拷贝过程中若发生部分成功（`total_len > 0`），即使后续出错也返回已成功传输的字节数。\n  - 使用 `unpin_user_pages_dirty_lock` 释放锁定的页，若为写操作（`vm_write=1`）则标记页为脏（`dirty`），确保修改能回写。\n\n- **I/O 向量化支持**：  \n  通过 `import_iovec` 和 `iovec_from_user` 处理用户态传入的分散/聚集 I/O 向量（iovec），支持非连续内存区域的高效批量传输。\n\n## 4. 依赖关系\n\n- **内存管理子系统 (`<linux/mm.h>`, `<linux/highmem.h>`)**：  \n  依赖 `pin_user_pages_remote`、`unpin_user_pages_dirty_lock`、`copy_page_to/from_iter` 等核心内存操作函数。\n  \n- **进程管理 (`<linux/sched.h>`, `<linux/sched/mm.h>`)**：  \n  使用 `find_get_task_by_vpid` 查找目标进程，`mm_access` 获取并验证其内存描述符。\n\n- **I/O 子系统 (`<linux/uio.h>`)**：  \n  基于 `iov_iter` 框架实现高效的 I/O 向量处理。\n\n- **系统调用接口 (`<linux/syscalls.h>`)**：  \n  通过 `SYSCALL_DEFINE6` 定义用户态可调用的系统调用入口。\n\n- **兼容层 (`<linux/compat.h>`)**：  \n  支持 32 位用户程序在 64 位内核上的调用（`in_compat_syscall()`）。\n\n- **安全框架 (`<linux/ptrace.h>`)**：  \n  复用 ptrace 的权限检查模型（`PTRACE_MODE_ATTACH_REALCREDS`）确保内存访问安全。\n\n## 5. 使用场景\n\n- **调试与监控工具**：  \n  如 `gdb`、`strace` 等工具通过 `process_vm_readv` 直接读取被调试进程的内存状态，避免频繁的 `ptrace` 陷入内核。\n\n- **容器与沙箱技术**：  \n  容器运行时（如 Docker、Kata Containers）利用此接口在不侵入容器内部的情况下，从宿主机读取或注入容器进程的内存数据。\n\n- **高性能进程间通信 (IPC)**：  \n  在特定场景下替代传统的管道、共享内存等 IPC 机制，实现零拷贝或低开销的跨进程数据交换。\n\n- **内核自检与故障注入**：  \n  内核测试框架可通过此接口模拟内存错误或验证进程内存布局。\n\n- **安全审计工具**：  \n  如 `auditd` 或自定义 LSM 模块，用于监控敏感进程的内存活动。",
      "similarity": 0.5635443925857544,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/process_vm_access.c",
          "start_line": 253,
          "end_line": 289,
          "content": [
            "static ssize_t process_vm_rw(pid_t pid,",
            "\t\t\t     const struct iovec __user *lvec,",
            "\t\t\t     unsigned long liovcnt,",
            "\t\t\t     const struct iovec __user *rvec,",
            "\t\t\t     unsigned long riovcnt,",
            "\t\t\t     unsigned long flags, int vm_write)",
            "{",
            "\tstruct iovec iovstack_l[UIO_FASTIOV];",
            "\tstruct iovec iovstack_r[UIO_FASTIOV];",
            "\tstruct iovec *iov_l = iovstack_l;",
            "\tstruct iovec *iov_r;",
            "\tstruct iov_iter iter;",
            "\tssize_t rc;",
            "\tint dir = vm_write ? ITER_SOURCE : ITER_DEST;",
            "",
            "\tif (flags != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Check iovecs */",
            "\trc = import_iovec(dir, lvec, liovcnt, UIO_FASTIOV, &iov_l, &iter);",
            "\tif (rc < 0)",
            "\t\treturn rc;",
            "\tif (!iov_iter_count(&iter))",
            "\t\tgoto free_iov_l;",
            "\tiov_r = iovec_from_user(rvec, riovcnt, UIO_FASTIOV, iovstack_r,",
            "\t\t\t\tin_compat_syscall());",
            "\tif (IS_ERR(iov_r)) {",
            "\t\trc = PTR_ERR(iov_r);",
            "\t\tgoto free_iov_l;",
            "\t}",
            "\trc = process_vm_rw_core(pid, &iter, iov_r, riovcnt, flags, vm_write);",
            "\tif (iov_r != iovstack_r)",
            "\t\tkfree(iov_r);",
            "free_iov_l:",
            "\tkfree(iov_l);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "process_vm_rw",
          "description": "实现process_vm_rw函数，整合用户态iovec数据到内核迭代器，通过import_iovec解析输入向量，调用核心处理流程完成跨进程内存读写操作",
          "similarity": 0.5263333320617676
        },
        {
          "chunk_id": 1,
          "file_path": "mm/process_vm_access.c",
          "start_line": 27,
          "end_line": 203,
          "content": [
            "static int process_vm_rw_pages(struct page **pages,",
            "\t\t\t       unsigned offset,",
            "\t\t\t       size_t len,",
            "\t\t\t       struct iov_iter *iter,",
            "\t\t\t       int vm_write)",
            "{",
            "\t/* Do the copy for each page */",
            "\twhile (len && iov_iter_count(iter)) {",
            "\t\tstruct page *page = *pages++;",
            "\t\tsize_t copy = PAGE_SIZE - offset;",
            "\t\tsize_t copied;",
            "",
            "\t\tif (copy > len)",
            "\t\t\tcopy = len;",
            "",
            "\t\tif (vm_write)",
            "\t\t\tcopied = copy_page_from_iter(page, offset, copy, iter);",
            "\t\telse",
            "\t\t\tcopied = copy_page_to_iter(page, offset, copy, iter);",
            "",
            "\t\tlen -= copied;",
            "\t\tif (copied < copy && iov_iter_count(iter))",
            "\t\t\treturn -EFAULT;",
            "\t\toffset = 0;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int process_vm_rw_single_vec(unsigned long addr,",
            "\t\t\t\t    unsigned long len,",
            "\t\t\t\t    struct iov_iter *iter,",
            "\t\t\t\t    struct page **process_pages,",
            "\t\t\t\t    struct mm_struct *mm,",
            "\t\t\t\t    struct task_struct *task,",
            "\t\t\t\t    int vm_write)",
            "{",
            "\tunsigned long pa = addr & PAGE_MASK;",
            "\tunsigned long start_offset = addr - pa;",
            "\tunsigned long nr_pages;",
            "\tssize_t rc = 0;",
            "\tunsigned long max_pages_per_loop = PVM_MAX_KMALLOC_PAGES",
            "\t\t/ sizeof(struct pages *);",
            "\tunsigned int flags = 0;",
            "",
            "\t/* Work out address and page range required */",
            "\tif (len == 0)",
            "\t\treturn 0;",
            "\tnr_pages = (addr + len - 1) / PAGE_SIZE - addr / PAGE_SIZE + 1;",
            "",
            "\tif (vm_write)",
            "\t\tflags |= FOLL_WRITE;",
            "",
            "\twhile (!rc && nr_pages && iov_iter_count(iter)) {",
            "\t\tint pinned_pages = min(nr_pages, max_pages_per_loop);",
            "\t\tint locked = 1;",
            "\t\tsize_t bytes;",
            "",
            "\t\t/*",
            "\t\t * Get the pages we're interested in.  We must",
            "\t\t * access remotely because task/mm might not",
            "\t\t * current/current->mm",
            "\t\t */",
            "\t\tmmap_read_lock(mm);",
            "\t\tpinned_pages = pin_user_pages_remote(mm, pa, pinned_pages,",
            "\t\t\t\t\t\t     flags, process_pages,",
            "\t\t\t\t\t\t     &locked);",
            "\t\tif (locked)",
            "\t\t\tmmap_read_unlock(mm);",
            "\t\tif (pinned_pages <= 0)",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbytes = pinned_pages * PAGE_SIZE - start_offset;",
            "\t\tif (bytes > len)",
            "\t\t\tbytes = len;",
            "",
            "\t\trc = process_vm_rw_pages(process_pages,",
            "\t\t\t\t\t start_offset, bytes, iter,",
            "\t\t\t\t\t vm_write);",
            "\t\tlen -= bytes;",
            "\t\tstart_offset = 0;",
            "\t\tnr_pages -= pinned_pages;",
            "\t\tpa += pinned_pages * PAGE_SIZE;",
            "",
            "\t\t/* If vm_write is set, the pages need to be made dirty: */",
            "\t\tunpin_user_pages_dirty_lock(process_pages, pinned_pages,",
            "\t\t\t\t\t    vm_write);",
            "\t}",
            "",
            "\treturn rc;",
            "}",
            "static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,",
            "\t\t\t\t  const struct iovec *rvec,",
            "\t\t\t\t  unsigned long riovcnt,",
            "\t\t\t\t  unsigned long flags, int vm_write)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];",
            "\tstruct page **process_pages = pp_stack;",
            "\tstruct mm_struct *mm;",
            "\tunsigned long i;",
            "\tssize_t rc = 0;",
            "\tunsigned long nr_pages = 0;",
            "\tunsigned long nr_pages_iov;",
            "\tssize_t iov_len;",
            "\tsize_t total_len = iov_iter_count(iter);",
            "",
            "\t/*",
            "\t * Work out how many pages of struct pages we're going to need",
            "\t * when eventually calling get_user_pages",
            "\t */",
            "\tfor (i = 0; i < riovcnt; i++) {",
            "\t\tiov_len = rvec[i].iov_len;",
            "\t\tif (iov_len > 0) {",
            "\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base",
            "\t\t\t\t\t+ iov_len)",
            "\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base",
            "\t\t\t\t/ PAGE_SIZE + 1;",
            "\t\t\tnr_pages = max(nr_pages, nr_pages_iov);",
            "\t\t}",
            "\t}",
            "",
            "\tif (nr_pages == 0)",
            "\t\treturn 0;",
            "",
            "\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {",
            "\t\t/* For reliability don't try to kmalloc more than",
            "\t\t   2 pages worth */",
            "\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,",
            "\t\t\t\t\t      sizeof(struct pages *)*nr_pages),",
            "\t\t\t\t\tGFP_KERNEL);",
            "",
            "\t\tif (!process_pages)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\t/* Get process information */",
            "\ttask = find_get_task_by_vpid(pid);",
            "\tif (!task) {",
            "\t\trc = -ESRCH;",
            "\t\tgoto free_proc_pages;",
            "\t}",
            "",
            "\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);",
            "\tif (!mm || IS_ERR(mm)) {",
            "\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;",
            "\t\t/*",
            "\t\t * Explicitly map EACCES to EPERM as EPERM is a more",
            "\t\t * appropriate error code for process_vw_readv/writev",
            "\t\t */",
            "\t\tif (rc == -EACCES)",
            "\t\t\trc = -EPERM;",
            "\t\tgoto put_task_struct;",
            "\t}",
            "",
            "\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)",
            "\t\trc = process_vm_rw_single_vec(",
            "\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,",
            "\t\t\titer, process_pages, mm, task, vm_write);",
            "",
            "\t/* copied = space before - space after */",
            "\ttotal_len -= iov_iter_count(iter);",
            "",
            "\t/* If we have managed to copy any data at all then",
            "\t   we return the number of bytes copied. Otherwise",
            "\t   we return the error code */",
            "\tif (total_len)",
            "\t\trc = total_len;",
            "",
            "\tmmput(mm);",
            "",
            "put_task_struct:",
            "\tput_task_struct(task);",
            "",
            "free_proc_pages:",
            "\tif (process_pages != pp_stack)",
            "\t\tkfree(process_pages);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "process_vm_rw_pages, process_vm_rw_single_vec, process_vm_rw_core",
          "description": "实现process_vm_rw_pages通过循环处理页面数据拷贝，process_vm_rw_single_vec获取远程页面并调用核心处理逻辑，process_vm_rw_core协调多进程地址范围映射与页面锁定操作",
          "similarity": 0.5129913091659546
        },
        {
          "chunk_id": 0,
          "file_path": "mm/process_vm_access.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * linux/mm/process_vm_access.c",
            " *",
            " * Copyright (C) 2010-2011 Christopher Yeoh <cyeoh@au1.ibm.com>, IBM Corp.",
            " */",
            "",
            "#include <linux/compat.h>",
            "#include <linux/mm.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "",
            "/**",
            " * process_vm_rw_pages - read/write pages from task specified",
            " * @pages: array of pointers to pages we want to copy",
            " * @offset: offset in page to start copying from/to",
            " * @len: number of bytes to copy",
            " * @iter: where to copy to/from locally",
            " * @vm_write: 0 means copy from, 1 means copy to",
            " * Returns 0 on success, error code otherwise",
            " */"
          ],
          "function_name": null,
          "description": "声明process_vm_rw_pages函数，用于从指定任务的页面进行读写操作，接受页面指针数组、偏移量、长度、迭代器及写标志，返回操作结果状态码",
          "similarity": 0.4407569169998169
        }
      ]
    }
  ]
}