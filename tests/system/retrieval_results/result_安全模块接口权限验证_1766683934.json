{
  "query": "安全模块接口权限验证",
  "timestamp": "2025-12-26 01:32:14",
  "retrieved_files": [
    {
      "source_file": "kernel/module/signing.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:06:05\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\signing.c`\n\n---\n\n# module/signing.c 技术文档\n\n## 1. 文件概述\n\n`module/signing.c` 是 Linux 内核中用于验证内核模块数字签名的核心实现文件。该文件提供了模块加载过程中对 PKCS#7 格式签名的解析、验证和策略控制功能，确保只有经过合法签名的模块才能被加载到内核中，从而增强系统的安全性和完整性。该机制是内核模块签名（Module Signature）子系统的关键组成部分，支持强制签名（`CONFIG_MODULE_SIG_FORCE`）和运行时策略控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`is_module_sig_enforced(void)`**  \n  返回当前是否强制要求模块必须具有有效签名。该函数导出为符号，供其他内核子系统使用。\n\n- **`set_module_sig_enforced(void)`**  \n  在运行时将模块签名强制策略设置为启用状态（`true`），通常由安全机制（如 Lockdown）调用。\n\n- **`mod_verify_sig(const void *mod, struct load_info *info)`**  \n  执行模块签名的实际验证逻辑：解析模块末尾的 `module_signature` 结构，提取签名数据，并调用通用 PKCS#7 验证接口进行验证。\n\n- **`module_sig_check(struct load_info *info, int flags)`**  \n  模块加载流程中的主入口函数，负责检测模块是否包含签名标记（`~Module signature appended~\\n`），决定是否调用 `mod_verify_sig`，并根据验证结果和系统策略决定是否允许加载。\n\n### 关键数据结构与变量\n\n- **`sig_enforce`**  \n  全局布尔变量，表示是否强制执行模块签名验证。初始值由 `CONFIG_MODULE_SIG_FORCE` 决定，可通过内核命令行参数 `module.sig_enforce=1` 或运行时调用 `set_module_sig_enforced()` 修改。\n\n- **`module_signature`**  \n  定义在 `<linux/module_signature.h>` 中的结构体，位于模块二进制末尾，包含签名元数据（如签名长度、哈希算法、密钥标识等）。\n\n- **`MODULE_SIG_STRING`**  \n  签名结束标记字符串 `\"~Module signature appended~\\n\"`，用于识别模块是否包含签名。\n\n## 3. 关键实现\n\n### 签名验证流程\n\n1. **签名检测**：  \n   `module_sig_check` 检查模块末尾是否存在 `MODULE_SIG_STRING` 标记。若存在，则认为模块包含签名。\n\n2. **签名解析**：  \n   `mod_verify_sig` 从模块末尾读取 `struct module_signature`，调用 `mod_check_sig()` 验证其格式合法性。\n\n3. **数据截断**：  \n   从模块总长度中扣除签名数据和签名结构体的长度，得到实际代码/数据部分的长度（`info->len` 更新为此值）。\n\n4. **PKCS#7 验证**：  \n   调用 `verify_pkcs7_signature()`，使用内核的 `VERIFY_USE_SECONDARY_KEYRING`（通常为 `.module_signing` 密钥环）验证模块主体的完整性与签名有效性。\n\n### 安全策略处理\n\n- **强制模式（`sig_enforce == true`）**：  \n  任何未签名、密钥不可用或加密算法不支持的模块均被拒绝加载，返回 `-EKEYREJECTED`。\n\n- **非强制模式**：  \n  允许加载未签名模块，但会检查系统是否处于 Lockdown 模式（通过 `security_locked_down(LOCKDOWN_MODULE_SIGNATURE)`）。若处于 Lockdown，则仍拒绝加载。\n\n- **模块篡改防护**：  \n  若加载标志包含 `MODULE_INIT_IGNORE_MODVERSIONS` 或 `MODULE_INIT_IGNORE_VERMAGIC`（即忽略版本魔数或模块版本），则视为“被篡改”的模块，即使有签名也不予验证，防止绕过签名保护。\n\n### 错误分类\n\n- **非致命错误**（仅在非强制模式下可忽略）：\n  - `-ENODATA`：模块未签名\n  - `-ENOPKG`：使用了内核不支持的加密算法\n  - `-ENOKEY`：签名所用公钥不在信任密钥环中\n\n- **致命错误**（无论是否强制均拒绝）：\n  - 内存分配失败、签名格式错误、哈希不匹配等\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/verification.h>`：提供 `verify_pkcs7_signature()` 接口\n  - `<crypto/public_key.h>`：PKCS#7 验证所需的密码学支持\n  - `<linux/module_signature.h>`：定义 `module_signature` 结构\n  - `\"internal.h\"`：模块子系统内部头文件\n\n- **内核配置依赖**：\n  - `CONFIG_MODULE_SIG`：启用模块签名功能\n  - `CONFIG_MODULE_SIG_FORCE`：决定 `sig_enforce` 的默认值\n  - `CONFIG_SECURITY_LOCKDOWN_LSM`：提供 `security_locked_down()` 支持\n\n- **密钥管理依赖**：  \n  依赖内核密钥环服务（Key Retention Service），特别是 `.module_signing` 二级密钥环存储用于验证模块的公钥。\n\n## 5. 使用场景\n\n- **模块加载流程**：  \n  在 `load_module()` 函数中，内核调用 `module_sig_check()` 对待加载模块进行签名验证，是模块安全加载的关键环节。\n\n- **安全启动（Secure Boot）环境**：  \n  当系统启用 UEFI Secure Boot 时，通常会强制启用模块签名（`sig_enforce = true`），确保所有内核模块均来自可信源。\n\n- **内核 Lockdown 模式**：  \n  在 Lockdown 的 `integrity` 或 `confidentiality` 级别下，即使未设置 `CONFIG_MODULE_SIG_FORCE`，也会通过 `security_locked_down()` 阻止未签名模块加载。\n\n- **动态策略调整**：  \n  安全模块（如 Lockdown LSM）可在运行时调用 `set_module_sig_enforced()` 动态提升安全策略，禁止后续未签名模块加载。",
      "similarity": 0.6378082036972046,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/signing.c",
          "start_line": 29,
          "end_line": 118,
          "content": [
            "bool is_module_sig_enforced(void)",
            "{",
            "\treturn sig_enforce;",
            "}",
            "void set_module_sig_enforced(void)",
            "{",
            "\tsig_enforce = true;",
            "}",
            "int mod_verify_sig(const void *mod, struct load_info *info)",
            "{",
            "\tstruct module_signature ms;",
            "\tsize_t sig_len, modlen = info->len;",
            "\tint ret;",
            "",
            "\tpr_devel(\"==>%s(,%zu)\\n\", __func__, modlen);",
            "",
            "\tif (modlen <= sizeof(ms))",
            "\t\treturn -EBADMSG;",
            "",
            "\tmemcpy(&ms, mod + (modlen - sizeof(ms)), sizeof(ms));",
            "",
            "\tret = mod_check_sig(&ms, modlen, \"module\");",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tsig_len = be32_to_cpu(ms.sig_len);",
            "\tmodlen -= sig_len + sizeof(ms);",
            "\tinfo->len = modlen;",
            "",
            "\treturn verify_pkcs7_signature(mod, modlen, mod + modlen, sig_len,",
            "\t\t\t\t      VERIFY_USE_SECONDARY_KEYRING,",
            "\t\t\t\t      VERIFYING_MODULE_SIGNATURE,",
            "\t\t\t\t      NULL, NULL);",
            "}",
            "int module_sig_check(struct load_info *info, int flags)",
            "{",
            "\tint err = -ENODATA;",
            "\tconst unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;",
            "\tconst char *reason;",
            "\tconst void *mod = info->hdr;",
            "\tbool mangled_module = flags & (MODULE_INIT_IGNORE_MODVERSIONS |",
            "\t\t\t\t       MODULE_INIT_IGNORE_VERMAGIC);",
            "\t/*",
            "\t * Do not allow mangled modules as a module with version information",
            "\t * removed is no longer the module that was signed.",
            "\t */",
            "\tif (!mangled_module &&",
            "\t    info->len > markerlen &&",
            "\t    memcmp(mod + info->len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {",
            "\t\t/* We truncate the module to discard the signature */",
            "\t\tinfo->len -= markerlen;",
            "\t\terr = mod_verify_sig(mod, info);",
            "\t\tif (!err) {",
            "\t\t\tinfo->sig_ok = true;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * We don't permit modules to be loaded into the trusted kernels",
            "\t * without a valid signature on them, but if we're not enforcing,",
            "\t * certain errors are non-fatal.",
            "\t */",
            "\tswitch (err) {",
            "\tcase -ENODATA:",
            "\t\treason = \"unsigned module\";",
            "\t\tbreak;",
            "\tcase -ENOPKG:",
            "\t\treason = \"module with unsupported crypto\";",
            "\t\tbreak;",
            "\tcase -ENOKEY:",
            "\t\treason = \"module with unavailable key\";",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\t/*",
            "\t\t * All other errors are fatal, including lack of memory,",
            "\t\t * unparseable signatures, and signature check failures --",
            "\t\t * even if signatures aren't required.",
            "\t\t */",
            "\t\treturn err;",
            "\t}",
            "",
            "\tif (is_module_sig_enforced()) {",
            "\t\tpr_notice(\"Loading of %s is rejected\\n\", reason);",
            "\t\treturn -EKEYREJECTED;",
            "\t}",
            "",
            "\treturn security_locked_down(LOCKDOWN_MODULE_SIGNATURE);",
            "}"
          ],
          "function_name": "is_module_sig_enforced, set_module_sig_enforced, mod_verify_sig, module_sig_check",
          "description": "实现模块签名验证核心逻辑，包含签名状态查询接口、签名验证执行函数以及综合检查入口，通过标记比对与证书验证完成模块签名有效性校验",
          "similarity": 0.6402788162231445
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/signing.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* Module signature checker",
            " *",
            " * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/string.h>",
            "#include <linux/verification.h>",
            "#include <linux/security.h>",
            "#include <crypto/public_key.h>",
            "#include <uapi/linux/module.h>",
            "#include \"internal.h\"",
            "",
            "#undef MODULE_PARAM_PREFIX",
            "#define MODULE_PARAM_PREFIX \"module.\"",
            "",
            "static bool sig_enforce = IS_ENABLED(CONFIG_MODULE_SIG_FORCE);",
            "module_param(sig_enforce, bool_enable_only, 0644);",
            "",
            "/*",
            " * Export sig_enforce kernel cmdline parameter to allow other subsystems rely",
            " * on that instead of directly to CONFIG_MODULE_SIG_FORCE config.",
            " */"
          ],
          "function_name": null,
          "description": "定义sig_enforce全局变量用于控制模块签名强制检查标志位，并注册模块参数供外部配置",
          "similarity": 0.5137535929679871
        }
      ]
    },
    {
      "source_file": "kernel/module_signature.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:10:38\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module_signature.c`\n\n---\n\n# module_signature.c 技术文档\n\n## 1. 文件概述\n\n`module_signature.c` 是 Linux 内核中用于验证内核模块数字签名有效性的核心组件。该文件实现了对附加在模块末尾的 PKCS#7 格式签名的初步格式校验逻辑，确保加载的模块签名结构合法且符合内核预期的安全要求。此功能是内核模块签名验证机制的第一道防线，用于防止加载格式错误或使用非预期签名算法的模块。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`mod_check_sig`**  \n  函数原型：  \n  ```c\n  int mod_check_sig(const struct module_signature *ms, size_t file_len, const char *name)\n  ```  \n  功能：验证模块签名结构的合法性，包括签名长度、签名类型及保留字段是否符合预期。\n\n### 关键数据结构\n\n- **`struct module_signature`**  \n  定义在 `<linux/module_signature.h>` 中，描述附加在模块文件末尾的签名元数据结构，包含签名长度、标识类型、算法、哈希方式、签名人长度、密钥 ID 长度及填充字段等。\n\n## 3. 关键实现\n\n- **签名长度校验**：  \n  使用 `be32_to_cpu(ms->sig_len)` 将大端序存储的签名长度转换为主机字节序，并验证其不超过模块文件总长度减去签名结构本身的大小，防止缓冲区越界。\n\n- **签名类型强制约束**：  \n  仅接受 `PKEY_ID_PKCS7` 类型的签名，这是内核模块签名的标准格式。若使用其他签名类型（如 X.509 直接签名），则拒绝加载并返回 `-ENOPKG`。\n\n- **保留字段清零检查**：  \n  对于 PKCS#7 签名，`algo`、`hash`、`signer_len`、`key_id_len` 及三个填充字节 `__pad` 必须为零。这是因为 PKCS#7 本身已包含完整的算法和身份信息，无需在签名头中重复指定。任何非零值均视为格式错误，返回 `-EBADMSG`。\n\n- **错误报告机制**：  \n  使用 `pr_err()` 输出带上下文名称（如模块文件名）的详细错误信息，便于调试和审计。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/errno.h>`：提供标准错误码（如 `-EBADMSG`, `-ENOPKG`）\n  - `<linux/printk.h>`：提供内核日志输出接口 `pr_err()`\n  - `<linux/module_signature.h>`：定义 `struct module_signature` 结构体\n  - `<asm/byteorder.h>`：提供字节序转换函数 `be32_to_cpu()`\n\n- **内核子系统依赖**：\n  - **模块加载子系统（module loader）**：在模块加载流程中调用此函数进行签名预检\n  - **密钥管理子系统（KEYS）**：后续的 PKCS#7 签名验证由 KEYS 子系统完成，本文件仅做格式检查\n\n## 5. 使用场景\n\n- **内核模块加载时的安全校验**：  \n  当用户通过 `insmod`、`modprobe` 等命令加载内核模块时，内核模块加载器会读取模块文件末尾的签名数据，并调用 `mod_check_sig()` 进行初步格式验证。只有通过此检查的模块才会进入后续的 PKCS#7 签名验证阶段。\n\n- **启用模块签名强制策略时的关键环节**：  \n  在配置了 `CONFIG_MODULE_SIG_FORCE=y` 的系统中，所有模块必须带有有效签名。`mod_check_sig()` 作为签名验证链的第一步，确保签名结构本身合法，防止恶意构造的签名数据绕过安全检查。\n\n- **内核自保护机制的一部分**：  \n  该文件与内核完整性子系统（如 IMA）协同工作，共同保障运行时内核代码的完整性与可信性。",
      "similarity": 0.6278212070465088,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module_signature.c",
          "start_line": 21,
          "end_line": 46,
          "content": [
            "int mod_check_sig(const struct module_signature *ms, size_t file_len,",
            "\t\t  const char *name)",
            "{",
            "\tif (be32_to_cpu(ms->sig_len) >= file_len - sizeof(*ms))",
            "\t\treturn -EBADMSG;",
            "",
            "\tif (ms->id_type != PKEY_ID_PKCS7) {",
            "\t\tpr_err(\"%s: not signed with expected PKCS#7 message\\n\",",
            "\t\t       name);",
            "\t\treturn -ENOPKG;",
            "\t}",
            "",
            "\tif (ms->algo != 0 ||",
            "\t    ms->hash != 0 ||",
            "\t    ms->signer_len != 0 ||",
            "\t    ms->key_id_len != 0 ||",
            "\t    ms->__pad[0] != 0 ||",
            "\t    ms->__pad[1] != 0 ||",
            "\t    ms->__pad[2] != 0) {",
            "\t\tpr_err(\"%s: PKCS#7 signature info has unexpected non-zero params\\n\",",
            "\t\t       name);",
            "\t\treturn -EBADMSG;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "mod_check_sig",
          "description": "实现模块签名验证函数mod_check_sig，检查签名长度是否超出有效范围，验证PKCS#7标识符类型，并确保签名结构中的非关键字段均为零值以保证签名数据完整性",
          "similarity": 0.6137670874595642
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module_signature.c",
          "start_line": 1,
          "end_line": 20,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Module signature checker",
            " *",
            " * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " */",
            "",
            "#include <linux/errno.h>",
            "#include <linux/printk.h>",
            "#include <linux/module_signature.h>",
            "#include <asm/byteorder.h>",
            "",
            "/**",
            " * mod_check_sig - check that the given signature is sane",
            " *",
            " * @ms:\t\tSignature to check.",
            " * @file_len:\tSize of the file to which @ms is appended.",
            " * @name:\tWhat is being checked. Used for error messages.",
            " */"
          ],
          "function_name": null,
          "description": "定义模块签名检查函数mod_check_sig的原型，用于验证模块签名结构有效性，包含签名长度检查、算法标识符类型校验及字段初始化状态检测，但尚未包含完整实现逻辑",
          "similarity": 0.5558815002441406
        }
      ]
    },
    {
      "source_file": "kernel/module/version.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:10:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\version.c`\n\n---\n\n# module/version.c 技术文档\n\n## 1. 文件概述\n\n`module/version.c` 是 Linux 内核模块子系统中负责模块版本校验的核心实现文件。该文件提供了模块加载过程中符号版本（symbol versioning）的检查机制，用于确保加载的模块与其依赖的内核或其他模块在接口层面保持兼容性。通过 CRC 校验码比对，防止因内核结构体或函数接口变更导致的模块不兼容问题，从而提升系统稳定性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`check_version()`**  \n  检查模块中某个符号的版本 CRC 是否与当前内核中导出的符号 CRC 一致。\n\n- **`check_modstruct_version()`**  \n  专门用于校验 `module_layout` 符号的版本一致性，该符号代表模块布局结构的 ABI。\n\n- **`same_magic()`**  \n  比较两个模块魔数（magic string）是否相同，支持忽略内核版本前缀（当模块包含 CRC 时）。\n\n- **`module_layout()`**  \n  一个空实现的占位函数，其符号被导出，用于生成模块布局的版本签名。\n\n### 关键数据结构\n\n- **`struct modversion_info`**  \n  存储符号名称及其对应的 CRC 校验值，用于版本比对。\n\n- **`struct load_info`**  \n  模块加载过程中的元数据结构，包含 ELF 节头、版本节索引等信息。\n\n## 3. 关键实现\n\n### 符号版本校验机制\n\n- `check_version()` 函数从模块的 `.modver` 节（由 `versindex` 指定）中读取 `modversion_info` 数组。\n- 遍历该数组，查找与目标符号名 `symname` 匹配的条目。\n- 若找到且 CRC 值匹配，则返回 1（校验通过）；否则打印警告并返回 0（校验失败）。\n- 若模块未提供 CRC（`crc == NULL`），视为已污染（tainted），直接放行。\n- 若模块无版本节（`versindex == 0`），则调用 `try_to_force_load()` 允许强制加载（如 `modprobe --force`）。\n\n### `module_layout` 特殊处理\n\n- `check_modstruct_version()` 通过 `find_symbol()` 查找内核中名为 `\"module_layout\"` 的符号。\n- 该符号代表模块内存布局的 ABI，其变化意味着模块结构不兼容。\n- 使用 `preempt_disable()` 避免调度（因内核符号不可卸载，无需锁，仅用于满足 lockdep 检查）。\n\n### 魔数比较逻辑\n\n- `same_magic()` 在模块包含 CRC 时，跳过魔数字符串开头的内核版本部分（通过 `strcspn(..., \" \")` 定位空格后内容），仅比较后续 ABI 标识部分。\n- 此设计允许不同内核版本但相同 ABI 的模块兼容加载。\n\n### `module_layout()` 的作用\n\n- 该函数本身无实现，但其符号被 `EXPORT_SYMBOL` 导出。\n- 链接时，`genksyms` 工具会根据其参数类型（`struct module`, `modversion_info` 等）生成唯一的 CRC。\n- 该 CRC 反映了关键内核数据结构的布局，任何结构变更都会导致 CRC 变化，从而触发版本不匹配。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：提供模块核心 API 和数据结构。\n  - `<linux/string.h>`：使用 `strcmp`、`strcspn` 等字符串函数。\n  - `<linux/printk.h>`：使用 `pr_debug`、`pr_warn` 等日志接口。\n  - `\"internal.h\"`：包含模块子系统内部实现细节（如 `find_symbol`、`try_to_force_load` 等）。\n\n- **功能依赖**：\n  - 依赖内核符号表（`find_symbol`）查询 `module_layout`。\n  - 依赖模块加载流程中解析的 ELF 节信息（`load_info::sechdrs`）。\n  - 与 `scripts/genksyms/` 工具链协同工作，生成符号 CRC。\n\n## 5. 使用场景\n\n- **模块正常加载**：  \n  内核在解析模块依赖时，对每个外部符号调用 `check_version()`，确保 CRC 一致。\n\n- **强制加载模块（`modprobe --force`）**：  \n  当模块无版本信息（`versindex == 0`）时，调用 `try_to_force_load()` 允许加载，但系统会被标记为 tainted。\n\n- **内核升级后模块兼容性检查**：  \n  若内核关键结构（如 `struct module`）发生变化，`module_layout` 的 CRC 将不同，阻止旧模块加载。\n\n- **开发调试**：  \n  开发者可通过 `pr_debug` 输出查看 CRC 不匹配详情，辅助定位 ABI 不兼容问题。\n\n- **模块签名与安全加载**：  \n  版本校验是模块安全加载的前提，防止因结构错位导致内存破坏。",
      "similarity": 0.6028280258178711,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/module/version.c",
          "start_line": 1,
          "end_line": 12,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module version support",
            " *",
            " * Copyright (C) 2008 Rusty Russell",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/printk.h>",
            "#include \"internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "定义模块版本支持的实现文件，包含许可证声明及核心头文件导入，提供模块版本校验所需的基础结构和内部接口定义。",
          "similarity": 0.6355370283126831
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/version.c",
          "start_line": 13,
          "end_line": 92,
          "content": [
            "int check_version(const struct load_info *info,",
            "\t\t  const char *symname,",
            "\t\t\t struct module *mod,",
            "\t\t\t const s32 *crc)",
            "{",
            "\tElf_Shdr *sechdrs = info->sechdrs;",
            "\tunsigned int versindex = info->index.vers;",
            "\tunsigned int i, num_versions;",
            "\tstruct modversion_info *versions;",
            "",
            "\t/* Exporting module didn't supply crcs?  OK, we're already tainted. */",
            "\tif (!crc)",
            "\t\treturn 1;",
            "",
            "\t/* No versions at all?  modprobe --force does this. */",
            "\tif (versindex == 0)",
            "\t\treturn try_to_force_load(mod, symname) == 0;",
            "",
            "\tversions = (void *)sechdrs[versindex].sh_addr;",
            "\tnum_versions = sechdrs[versindex].sh_size",
            "\t\t/ sizeof(struct modversion_info);",
            "",
            "\tfor (i = 0; i < num_versions; i++) {",
            "\t\tu32 crcval;",
            "",
            "\t\tif (strcmp(versions[i].name, symname) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tcrcval = *crc;",
            "\t\tif (versions[i].crc == crcval)",
            "\t\t\treturn 1;",
            "\t\tpr_debug(\"Found checksum %X vs module %lX\\n\",",
            "\t\t\t crcval, versions[i].crc);",
            "\t\tgoto bad_version;",
            "\t}",
            "",
            "\t/* Broken toolchain. Warn once, then let it go.. */",
            "\tpr_warn_once(\"%s: no symbol version for %s\\n\", info->name, symname);",
            "\treturn 1;",
            "",
            "bad_version:",
            "\tpr_warn(\"%s: disagrees about version of symbol %s\\n\", info->name, symname);",
            "\treturn 0;",
            "}",
            "int check_modstruct_version(const struct load_info *info,",
            "\t\t\t    struct module *mod)",
            "{",
            "\tstruct find_symbol_arg fsa = {",
            "\t\t.name\t= \"module_layout\",",
            "\t\t.gplok\t= true,",
            "\t};",
            "",
            "\t/*",
            "\t * Since this should be found in kernel (which can't be removed), no",
            "\t * locking is necessary -- use preempt_disable() to placate lockdep.",
            "\t */",
            "\tpreempt_disable();",
            "\tif (!find_symbol(&fsa)) {",
            "\t\tpreempt_enable();",
            "\t\tBUG();",
            "\t}",
            "\tpreempt_enable();",
            "\treturn check_version(info, \"module_layout\", mod, fsa.crc);",
            "}",
            "int same_magic(const char *amagic, const char *bmagic,",
            "\t       bool has_crcs)",
            "{",
            "\tif (has_crcs) {",
            "\t\tamagic += strcspn(amagic, \" \");",
            "\t\tbmagic += strcspn(bmagic, \" \");",
            "\t}",
            "\treturn strcmp(amagic, bmagic) == 0;",
            "}",
            "void module_layout(struct module *mod,",
            "\t\t   struct modversion_info *ver,",
            "\t\t   struct kernel_param *kp,",
            "\t\t   struct kernel_symbol *ks,",
            "\t\t   struct tracepoint * const *tp)",
            "{",
            "}"
          ],
          "function_name": "check_version, check_modstruct_version, same_magic, module_layout",
          "description": "实现模块符号版本校验逻辑，check_version验证符号CRC一致性，check_modstruct_version检查模块布局版本，same_magic对比魔术字符串，module_layout作为预留接口当前为空实现。",
          "similarity": 0.5770838260650635
        }
      ]
    }
  ]
}