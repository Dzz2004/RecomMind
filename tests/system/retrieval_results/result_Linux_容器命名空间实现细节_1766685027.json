{
  "query": "Linux 容器命名空间实现细节",
  "timestamp": "2025-12-26 01:50:27",
  "retrieved_files": [
    {
      "source_file": "kernel/nsproxy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:12:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `nsproxy.c`\n\n---\n\n# nsproxy.c 技术文档\n\n## 1. 文件概述\n\n`nsproxy.c` 是 Linux 内核中实现命名空间（namespaces）代理机制的核心文件。该文件负责管理进程的命名空间代理结构 `nsproxy`，提供创建、复制、切换和释放命名空间集合的功能。命名空间是 Linux 容器技术（如 Docker、LXC）的基础，用于隔离进程视图，包括挂载点、UTS（主机名）、IPC、PID、网络、cgroup 和时间等资源。`nsproxy` 作为指向各类命名空间实例的容器，使得一个进程可以拥有独立的命名空间视图。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct nsproxy`**  \n  命名空间代理结构体，包含指向各类命名空间的指针：\n  - `uts_ns`：UTS 命名空间（主机名、域名）\n  - `ipc_ns`：IPC 命名空间（System V IPC 和 POSIX 消息队列）\n  - `mnt_ns`：挂载命名空间（文件系统挂载点视图）\n  - `pid_ns_for_children`：子进程将加入的 PID 命名空间\n  - `net_ns`：网络命名空间（网络设备、协议栈等）\n  - `cgroup_ns`：cgroup 命名空间（cgroup 层级视图）\n  - `time_ns` / `time_ns_for_children`：时间命名空间（用于虚拟化时间）\n\n- **`init_nsproxy`**  \n  全局初始化的命名空间代理实例，作为系统初始命名空间的引用。\n\n### 主要函数\n\n- **`create_nsproxy()`**  \n  从 slab 缓存分配一个新的 `nsproxy` 结构并初始化引用计数。\n\n- **`create_new_namespaces()`**  \n  根据指定标志位（如 `CLONE_NEWNS` 等）为任务创建全新的命名空间集合。\n\n- **`copy_namespaces()`**  \n  在 `clone()` 系统调用中被调用，根据 `clone_flags` 决定是否复制命名空间。\n\n- **`free_nsproxy()`**  \n  释放 `nsproxy` 及其引用的所有命名空间资源。\n\n- **`unshare_nsproxy_namespaces()`**  \n  在 `unshare()` 系统调用中使用，允许进程脱离当前命名空间并创建新的命名空间。\n\n- **`switch_task_namespaces()`**  \n  安全地切换任务的 `nsproxy`，并释放旧的引用。\n\n- **`exit_task_namespaces()`**  \n  进程退出时清理命名空间引用。\n\n- **`exec_task_namespaces()`**  \n  在 `execve()` 期间处理时间命名空间的特殊语义（子进程继承 `time_ns_for_children`）。\n\n- **`check_setns_flags()`**  \n  验证 `setns()` 系统调用传入的命名空间标志是否合法且内核已启用对应支持。\n\n## 3. 关键实现\n\n### 命名空间复制逻辑\n\n`create_new_namespaces()` 函数按顺序复制各类命名空间。若某一步失败（如内存不足或权限不足），则回滚已分配的资源，确保无内存泄漏。每个命名空间的复制由对应模块提供 `copy_xxx_ns()` 函数实现（如 `copy_mnt_ns()`、`copy_net_ns()` 等）。\n\n### 引用计数管理\n\n所有命名空间结构均使用引用计数（`refcount_t` 或类似机制）。`nsproxy` 本身也通过 `refcount_t count` 管理生命周期。`get_nsproxy()` 增加引用，`put_nsproxy()`（内联调用 `free_nsproxy()`）减少引用并在归零时释放。\n\n### 时间命名空间特殊处理\n\n时间命名空间具有两个字段：\n- `time_ns`：当前任务使用的时间命名空间。\n- `time_ns_for_children`：新创建子进程将继承的时间命名空间。\n\n在 `execve()` 时，若两者不同，需创建新的 `nsproxy` 并调用 `timens_on_fork()` 更新时间命名空间状态。\n\n### 权限与安全检查\n\n- 除 `CLONE_VM` 优化路径外，创建新命名空间需 `CAP_SYS_ADMIN` 能力。\n- 禁止同时指定 `CLONE_NEWIPC` 和 `CLONE_SYSVSEM`，因语义冲突。\n- `check_setns_flags()` 确保仅启用的命名空间类型可被操作。\n\n### 优化路径\n\n若 `clone_flags` 未请求任何新命名空间，且满足 `CLONE_VM` 或时间命名空间一致，则直接复用父进程的 `nsproxy`（仅增加引用计数），避免不必要的复制开销。\n\n## 4. 依赖关系\n\n- **内存管理**：依赖 `slab.h` 的 `kmem_cache` 机制分配 `nsproxy`。\n- **各命名空间子系统**：\n  - 挂载命名空间：`mnt_namespace.h`\n  - UTS：`utsname.h`\n  - IPC：`ipc_namespace.h`\n  - PID：`pid_namespace.h`\n  - 网络：`net_namespace.h`\n  - cgroup：`cgroup.h`\n  - 时间：`time_namespace.h`\n- **进程管理**：依赖 `task_struct`、`cred`、`fs_struct` 等结构。\n- **能力机制**：通过 `ns_capable()` 检查 `CAP_SYS_ADMIN`。\n- **proc 文件系统**：支持 `/proc/[pid]/ns/` 下的命名空间符号链接（通过 `proc_ns.h`）。\n\n## 5. 使用场景\n\n- **`clone()` 系统调用**：当指定 `CLONE_NEW*` 标志时，`copy_namespaces()` 被调用以创建子进程的命名空间视图。\n- **`unshare()` 系统调用**：进程调用 `unshare(CLONE_NEWNS | ...)` 时，`unshare_nsproxy_namespaces()` 创建新命名空间并切换。\n- **`setns()` 系统调用**：通过 `check_setns_flags()` 验证传入的命名空间类型合法性。\n- **`execve()` 系统调用**：处理时间命名空间的继承语义，确保子进程使用正确的 `time_ns_for_children`。\n- **进程退出**：`exit_task_namespaces()` 在进程终止时释放命名空间资源。\n- **容器运行时**：Docker、Podman、LXC 等依赖此机制实现资源隔离。",
      "similarity": 0.6491991281509399,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/nsproxy.c",
          "start_line": 151,
          "end_line": 265,
          "content": [
            "int copy_namespaces(unsigned long flags, struct task_struct *tsk)",
            "{",
            "\tstruct nsproxy *old_ns = tsk->nsproxy;",
            "\tstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);",
            "\tstruct nsproxy *new_ns;",
            "",
            "\tif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t      CLONE_NEWPID | CLONE_NEWNET |",
            "\t\t\t      CLONE_NEWCGROUP | CLONE_NEWTIME)))) {",
            "\t\tif ((flags & CLONE_VM) ||",
            "\t\t    likely(old_ns->time_ns_for_children == old_ns->time_ns)) {",
            "\t\t\tget_nsproxy(old_ns);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t} else if (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * CLONE_NEWIPC must detach from the undolist: after switching",
            "\t * to a new ipc namespace, the semaphore arrays from the old",
            "\t * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM",
            "\t * means share undolist with parent, so we must forbid using",
            "\t * it along with CLONE_NEWIPC.",
            "\t */",
            "\tif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==",
            "\t\t(CLONE_NEWIPC | CLONE_SYSVSEM))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);",
            "\tif (IS_ERR(new_ns))",
            "\t\treturn  PTR_ERR(new_ns);",
            "",
            "\tif ((flags & CLONE_VM) == 0)",
            "\t\ttimens_on_fork(new_ns, tsk);",
            "",
            "\ttsk->nsproxy = new_ns;",
            "\treturn 0;",
            "}",
            "void free_nsproxy(struct nsproxy *ns)",
            "{",
            "\tif (ns->mnt_ns)",
            "\t\tput_mnt_ns(ns->mnt_ns);",
            "\tif (ns->uts_ns)",
            "\t\tput_uts_ns(ns->uts_ns);",
            "\tif (ns->ipc_ns)",
            "\t\tput_ipc_ns(ns->ipc_ns);",
            "\tif (ns->pid_ns_for_children)",
            "\t\tput_pid_ns(ns->pid_ns_for_children);",
            "\tif (ns->time_ns)",
            "\t\tput_time_ns(ns->time_ns);",
            "\tif (ns->time_ns_for_children)",
            "\t\tput_time_ns(ns->time_ns_for_children);",
            "\tput_cgroup_ns(ns->cgroup_ns);",
            "\tput_net(ns->net_ns);",
            "\tkmem_cache_free(nsproxy_cachep, ns);",
            "}",
            "int unshare_nsproxy_namespaces(unsigned long unshare_flags,",
            "\tstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)",
            "{",
            "\tstruct user_namespace *user_ns;",
            "\tint err = 0;",
            "",
            "\tif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP |",
            "\t\t\t       CLONE_NEWTIME)))",
            "\t\treturn 0;",
            "",
            "\tuser_ns = new_cred ? new_cred->user_ns : current_user_ns();",
            "\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,",
            "\t\t\t\t\t new_fs ? new_fs : current->fs);",
            "\tif (IS_ERR(*new_nsp)) {",
            "\t\terr = PTR_ERR(*new_nsp);",
            "\t\tgoto out;",
            "\t}",
            "",
            "out:",
            "\treturn err;",
            "}",
            "void switch_task_namespaces(struct task_struct *p, struct nsproxy *new)",
            "{",
            "\tstruct nsproxy *ns;",
            "",
            "\tmight_sleep();",
            "",
            "\ttask_lock(p);",
            "\tns = p->nsproxy;",
            "\tp->nsproxy = new;",
            "\ttask_unlock(p);",
            "",
            "\tif (ns)",
            "\t\tput_nsproxy(ns);",
            "}",
            "void exit_task_namespaces(struct task_struct *p)",
            "{",
            "\tswitch_task_namespaces(p, NULL);",
            "}",
            "int exec_task_namespaces(void)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct nsproxy *new;",
            "",
            "\tif (tsk->nsproxy->time_ns_for_children == tsk->nsproxy->time_ns)",
            "\t\treturn 0;",
            "",
            "\tnew = create_new_namespaces(0, tsk, current_user_ns(), tsk->fs);",
            "\tif (IS_ERR(new))",
            "\t\treturn PTR_ERR(new);",
            "",
            "\ttimens_on_fork(new, tsk);",
            "\tswitch_task_namespaces(tsk, new);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_namespaces, free_nsproxy, unshare_nsproxy_namespaces, switch_task_namespaces, exit_task_namespaces, exec_task_namespaces",
          "description": "实现了命名空间相关操作，包括复制（copy_namespaces）、释放（free_nsproxy）、分离（unshare_nsproxy_namespaces）、切换（switch_task_namespaces）和验证（validate_nsset）等功能，支持多命名空间的动态管理",
          "similarity": 0.6335999965667725
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/nsproxy.c",
          "start_line": 276,
          "end_line": 490,
          "content": [
            "static int check_setns_flags(unsigned long flags)",
            "{",
            "\tif (!flags || (flags & ~(CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t\t CLONE_NEWNET | CLONE_NEWTIME | CLONE_NEWUSER |",
            "\t\t\t\t CLONE_NEWPID | CLONE_NEWCGROUP)))",
            "\t\treturn -EINVAL;",
            "",
            "#ifndef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_UTS_NS",
            "\tif (flags & CLONE_NEWUTS)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_CGROUPS",
            "\tif (flags & CLONE_NEWCGROUP)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_NET_NS",
            "\tif (flags & CLONE_NEWNET)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME)",
            "\t\treturn -EINVAL;",
            "#endif",
            "",
            "\treturn 0;",
            "}",
            "static void put_nsset(struct nsset *nsset)",
            "{",
            "\tunsigned flags = nsset->flags;",
            "",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tput_cred(nsset_cred(nsset));",
            "\t/*",
            "\t * We only created a temporary copy if we attached to more than just",
            "\t * the mount namespace.",
            "\t */",
            "\tif (nsset->fs && (flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS))",
            "\t\tfree_fs_struct(nsset->fs);",
            "\tif (nsset->nsproxy)",
            "\t\tfree_nsproxy(nsset->nsproxy);",
            "}",
            "static int prepare_nsset(unsigned flags, struct nsset *nsset)",
            "{",
            "\tstruct task_struct *me = current;",
            "",
            "\tnsset->nsproxy = create_new_namespaces(0, me, current_user_ns(), me->fs);",
            "\tif (IS_ERR(nsset->nsproxy))",
            "\t\treturn PTR_ERR(nsset->nsproxy);",
            "",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tnsset->cred = prepare_creds();",
            "\telse",
            "\t\tnsset->cred = current_cred();",
            "\tif (!nsset->cred)",
            "\t\tgoto out;",
            "",
            "\t/* Only create a temporary copy of fs_struct if we really need to. */",
            "\tif (flags == CLONE_NEWNS) {",
            "\t\tnsset->fs = me->fs;",
            "\t} else if (flags & CLONE_NEWNS) {",
            "\t\tnsset->fs = copy_fs_struct(me->fs);",
            "\t\tif (!nsset->fs)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tnsset->flags = flags;",
            "\treturn 0;",
            "",
            "out:",
            "\tput_nsset(nsset);",
            "\treturn -ENOMEM;",
            "}",
            "static inline int validate_ns(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\treturn ns->ops->install(nsset, ns);",
            "}",
            "static int validate_nsset(struct nsset *nsset, struct pid *pid)",
            "{",
            "\tint ret = 0;",
            "\tunsigned flags = nsset->flags;",
            "\tstruct user_namespace *user_ns = NULL;",
            "\tstruct pid_namespace *pid_ns = NULL;",
            "\tstruct nsproxy *nsp;",
            "\tstruct task_struct *tsk;",
            "",
            "\t/* Take a \"snapshot\" of the target task's namespaces. */",
            "\trcu_read_lock();",
            "\ttsk = pid_task(pid, PIDTYPE_PID);",
            "\tif (!tsk) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "\tif (!ptrace_may_access(tsk, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\ttask_lock(tsk);",
            "\tnsp = tsk->nsproxy;",
            "\tif (nsp)",
            "\t\tget_nsproxy(nsp);",
            "\ttask_unlock(tsk);",
            "\tif (!nsp) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "#ifdef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID) {",
            "\t\tpid_ns = task_active_pid_ns(tsk);",
            "\t\tif (unlikely(!pid_ns)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tret = -ESRCH;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tget_pid_ns(pid_ns);",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tuser_ns = get_user_ns(__task_cred(tsk)->user_ns);",
            "#endif",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Install requested namespaces. The caller will have",
            "\t * verified earlier that the requested namespaces are",
            "\t * supported on this kernel. We don't report errors here",
            "\t * if a namespace is requested that isn't supported.",
            "\t */",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER) {",
            "\t\tret = validate_ns(nsset, &user_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "\tif (flags & CLONE_NEWNS) {",
            "\t\tret = validate_ns(nsset, from_mnt_ns(nsp->mnt_ns));",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "#ifdef CONFIG_UTS_NS",
            "\tif (flags & CLONE_NEWUTS) {",
            "\t\tret = validate_ns(nsset, &nsp->uts_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC) {",
            "\t\tret = validate_ns(nsset, &nsp->ipc_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID) {",
            "\t\tret = validate_ns(nsset, &pid_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_CGROUPS",
            "\tif (flags & CLONE_NEWCGROUP) {",
            "\t\tret = validate_ns(nsset, &nsp->cgroup_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_NET_NS",
            "\tif (flags & CLONE_NEWNET) {",
            "\t\tret = validate_ns(nsset, &nsp->net_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME) {",
            "\t\tret = validate_ns(nsset, &nsp->time_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "out:",
            "\tif (pid_ns)",
            "\t\tput_pid_ns(pid_ns);",
            "\tif (nsp)",
            "\t\tput_nsproxy(nsp);",
            "\tput_user_ns(user_ns);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "check_setns_flags, put_nsset, prepare_nsset, validate_ns, validate_nsset",
          "description": "提供命名空间集合的校验与准备逻辑，check_setns_flags验证标志位有效性，prepare_nsset构建临时命名空间集，validate_nsset检查目标命名空间权限和可用性，确保安全操作",
          "similarity": 0.5781140327453613
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/nsproxy.c",
          "start_line": 1,
          "end_line": 150,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  Copyright (C) 2006 IBM Corporation",
            " *",
            " *  Author: Serge Hallyn <serue@us.ibm.com>",
            " *",
            " *  Jun 2006 - namespaces support",
            " *             OpenVZ, SWsoft Inc.",
            " *             Pavel Emelianov <xemul@openvz.org>",
            " */",
            "",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/init_task.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pid_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/perf_event.h>",
            "",
            "static struct kmem_cache *nsproxy_cachep;",
            "",
            "struct nsproxy init_nsproxy = {",
            "\t.count\t\t\t= REFCOUNT_INIT(1),",
            "\t.uts_ns\t\t\t= &init_uts_ns,",
            "#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)",
            "\t.ipc_ns\t\t\t= &init_ipc_ns,",
            "#endif",
            "\t.mnt_ns\t\t\t= NULL,",
            "\t.pid_ns_for_children\t= &init_pid_ns,",
            "#ifdef CONFIG_NET",
            "\t.net_ns\t\t\t= &init_net,",
            "#endif",
            "#ifdef CONFIG_CGROUPS",
            "\t.cgroup_ns\t\t= &init_cgroup_ns,",
            "#endif",
            "#ifdef CONFIG_TIME_NS",
            "\t.time_ns\t\t= &init_time_ns,",
            "\t.time_ns_for_children\t= &init_time_ns,",
            "#endif",
            "};",
            "",
            "static inline struct nsproxy *create_nsproxy(void)",
            "{",
            "\tstruct nsproxy *nsproxy;",
            "",
            "\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);",
            "\tif (nsproxy)",
            "\t\trefcount_set(&nsproxy->count, 1);",
            "\treturn nsproxy;",
            "}",
            "",
            "/*",
            " * Create new nsproxy and all of its the associated namespaces.",
            " * Return the newly created nsproxy.  Do not attach this to the task,",
            " * leave it to the caller to do proper locking and attach it to task.",
            " */",
            "static struct nsproxy *create_new_namespaces(unsigned long flags,",
            "\tstruct task_struct *tsk, struct user_namespace *user_ns,",
            "\tstruct fs_struct *new_fs)",
            "{",
            "\tstruct nsproxy *new_nsp;",
            "\tint err;",
            "",
            "\tnew_nsp = create_nsproxy();",
            "\tif (!new_nsp)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "",
            "\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);",
            "\tif (IS_ERR(new_nsp->mnt_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->mnt_ns);",
            "\t\tgoto out_ns;",
            "\t}",
            "",
            "\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);",
            "\tif (IS_ERR(new_nsp->uts_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->uts_ns);",
            "\t\tgoto out_uts;",
            "\t}",
            "",
            "\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);",
            "\tif (IS_ERR(new_nsp->ipc_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->ipc_ns);",
            "\t\tgoto out_ipc;",
            "\t}",
            "",
            "\tnew_nsp->pid_ns_for_children =",
            "\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);",
            "\tif (IS_ERR(new_nsp->pid_ns_for_children)) {",
            "\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);",
            "\t\tgoto out_pid;",
            "\t}",
            "",
            "\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,",
            "\t\t\t\t\t    tsk->nsproxy->cgroup_ns);",
            "\tif (IS_ERR(new_nsp->cgroup_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->cgroup_ns);",
            "\t\tgoto out_cgroup;",
            "\t}",
            "",
            "\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);",
            "\tif (IS_ERR(new_nsp->net_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->net_ns);",
            "\t\tgoto out_net;",
            "\t}",
            "",
            "\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,",
            "\t\t\t\t\ttsk->nsproxy->time_ns_for_children);",
            "\tif (IS_ERR(new_nsp->time_ns_for_children)) {",
            "\t\terr = PTR_ERR(new_nsp->time_ns_for_children);",
            "\t\tgoto out_time;",
            "\t}",
            "\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);",
            "",
            "\treturn new_nsp;",
            "",
            "out_time:",
            "\tput_net(new_nsp->net_ns);",
            "out_net:",
            "\tput_cgroup_ns(new_nsp->cgroup_ns);",
            "out_cgroup:",
            "\tif (new_nsp->pid_ns_for_children)",
            "\t\tput_pid_ns(new_nsp->pid_ns_for_children);",
            "out_pid:",
            "\tif (new_nsp->ipc_ns)",
            "\t\tput_ipc_ns(new_nsp->ipc_ns);",
            "out_ipc:",
            "\tif (new_nsp->uts_ns)",
            "\t\tput_uts_ns(new_nsp->uts_ns);",
            "out_uts:",
            "\tif (new_nsp->mnt_ns)",
            "\t\tput_mnt_ns(new_nsp->mnt_ns);",
            "out_ns:",
            "\tkmem_cache_free(nsproxy_cachep, new_nsp);",
            "\treturn ERR_PTR(err);",
            "}",
            "",
            "/*",
            " * called from clone.  This now handles copy for nsproxy and all",
            " * namespaces therein.",
            " */"
          ],
          "function_name": null,
          "description": "定义了nsproxy结构体的初始值和创建逻辑，包括各命名空间（如mnt、uts、ipc等）的初始化及通过create_new_namespaces函数创建新命名空间的流程，用于进程克隆时复制命名空间环境",
          "similarity": 0.5681438446044922
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/nsproxy.c",
          "start_line": 512,
          "end_line": 549,
          "content": [
            "static void commit_nsset(struct nsset *nsset)",
            "{",
            "\tunsigned flags = nsset->flags;",
            "\tstruct task_struct *me = current;",
            "",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER) {",
            "\t\t/* transfer ownership */",
            "\t\tcommit_creds(nsset_cred(nsset));",
            "\t\tnsset->cred = NULL;",
            "\t}",
            "#endif",
            "",
            "\t/* We only need to commit if we have used a temporary fs_struct. */",
            "\tif ((flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS)) {",
            "\t\tset_fs_root(me->fs, &nsset->fs->root);",
            "\t\tset_fs_pwd(me->fs, &nsset->fs->pwd);",
            "\t}",
            "",
            "#ifdef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC)",
            "\t\texit_sem(me);",
            "#endif",
            "",
            "#ifdef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME)",
            "\t\ttimens_commit(me, nsset->nsproxy->time_ns);",
            "#endif",
            "",
            "\t/* transfer ownership */",
            "\tswitch_task_namespaces(me, nsset->nsproxy);",
            "\tnsset->nsproxy = NULL;",
            "}",
            "int __init nsproxy_cache_init(void)",
            "{",
            "\tnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC|SLAB_ACCOUNT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "commit_nsset, nsproxy_cache_init",
          "description": "完成命名空间变更提交（commit_nsset）和缓存初始化（nsproxy_cache_init），将临时命名空间绑定到当前任务并持久化，同时建立nsproxy结构体的Slab缓存以优化内存分配",
          "similarity": 0.567343533039093
        }
      ]
    },
    {
      "source_file": "kernel/pid_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:16:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_namespace.c`\n\n---\n\n# `pid_namespace.c` 技术文档\n\n## 1. 文件概述\n\n`pid_namespace.c` 是 Linux 内核中实现 **PID 命名空间（PID Namespace）** 的核心源文件。PID 命名空间是 Linux 容器技术（如 Docker、LXC）的关键基础组件之一，用于为不同进程组提供隔离的进程 ID 视图。每个 PID 命名空间拥有独立的 PID 分配空间，使得不同命名空间中的进程可以拥有相同的 PID 而互不干扰。\n\n该文件负责 PID 命名空间的创建、销毁、引用计数管理、资源回收以及命名空间内进程的批量终止（如容器退出时清理所有子进程）等核心功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct pid_namespace`：表示一个 PID 命名空间，包含：\n  - `level`：命名空间层级（init_pid_ns 为 0，子命名空间依次递增）\n  - `parent`：指向父命名空间的指针\n  - `user_ns`：关联的用户命名空间\n  - `idr`：用于分配和管理 PID 的 IDR（整数到指针映射）结构\n  - `pid_cachep`：用于分配 `struct pid` 对象的 slab 缓存\n  - `pid_allocated`：当前命名空间中已分配的 PID 数量\n  - `ucounts`：用于限制用户命名空间下 PID 命名空间数量的计数器\n\n### 主要函数\n- `create_pid_cachep(unsigned int level)`  \n  为指定层级的 PID 命名空间创建专用的 `struct pid` slab 缓存。\n  \n- `create_pid_namespace(struct user_namespace *user_ns, struct pid_namespace *parent_pid_ns)`  \n  创建一个新的 PID 命名空间，设置层级、父命名空间、用户命名空间等属性，并初始化 IDR 和引用计数。\n\n- `copy_pid_ns(unsigned long flags, struct user_namespace *user_ns, struct pid_namespace *old_ns)`  \n  在 `clone()` 或 `unshare()` 系统调用中被调用，根据 `CLONE_NEWPID` 标志决定是否创建新的 PID 命名空间。\n\n- `put_pid_ns(struct pid_namespace *ns)`  \n  递减 PID 命名空间的引用计数，若引用计数归零则递归销毁该命名空间及其子命名空间。\n\n- `zap_pid_ns_processes(struct pid_namespace *pid_ns)`  \n  在 PID 命名空间的 init 进程退出时调用，向命名空间内所有剩余进程发送 `SIGKILL`，并等待其全部退出，确保命名空间干净回收。\n\n- `delayed_free_pidns(struct rcu_head *p)`  \n  通过 RCU 机制延迟释放 PID 命名空间结构体，确保所有并发读取完成后再释放内存。\n\n## 3. 关键实现\n\n### PID 命名空间层级与缓存管理\n- PID 命名空间支持嵌套，最大深度由 `MAX_PID_NS_LEVEL` 限制（通常为 32）。\n- 每个层级使用独立的 slab 缓存（`pid_cache[level - 1]`）来分配 `struct pid`，因为 `struct pid` 中的 `numbers[]` 数组大小依赖于命名空间层级（`level + 1`）。\n- 缓存创建通过 `create_pid_cachep()` 实现，使用互斥锁 `pid_caches_mutex` 避免并发创建冲突。\n\n### 引用计数与生命周期管理\n- 使用 `refcount_t` 管理命名空间引用计数。\n- `put_pid_ns()` 采用**尾递归方式**向上遍历父命名空间链，逐级释放无引用的命名空间。\n- 实际内存释放通过 RCU 回调 `delayed_free_pidns()` 延迟执行，保证并发安全。\n\n### 命名空间退出清理机制（`zap_pid_ns_processes`）\n- **禁用新 PID 分配**：调用 `disable_pid_allocation()` 阻止新进程加入。\n- **忽略 SIGCHLD**：使 init 进程自动回收僵尸子进程，避免阻塞。\n- **批量 SIGKILL**：遍历 IDR 中所有 PID，向对应进程发送 `SIGKILL`。\n- **等待所有进程退出**：通过 `kernel_wait4()` 回收直接子进程，并通过检查 `pid_allocated == init_pids` 确保所有进程（包括跨命名空间 fork 的僵尸进程）均已退出。\n- **RCU 安全调度**：在等待循环中调用 `exit_tasks_rcu_stop/start()` 避免与 `synchronize_rcu_tasks()` 死锁。\n\n### 资源限制\n- 通过 `inc_pid_namespaces()` / `dec_pid_namespaces()` 调用 `ucounts` 机制，限制每个用户命名空间可创建的 PID 命名空间数量，防止资源耗尽。\n\n## 4. 依赖关系\n\n- **`<linux/pid.h>` / `<linux/pid_namespace.h>`**：定义 `struct pid` 和 `struct pid_namespace`。\n- **`<linux/user_namespace.h>`**：依赖用户命名空间进行权限和资源限制。\n- **`<linux/idr.h>`**：使用 IDR 数据结构管理 PID 分配。\n- **`<linux/slab.h>`**：使用 kmem_cache 管理内存分配。\n- **`<linux/sched/*.h>`**：访问任务结构、信号处理、RCU 任务同步等。\n- **`<linux/proc_ns.h>`**：支持 `/proc/[pid]/ns/pid` 接口。\n- **`\"pid_sysctl.h\"`**：提供 sysctl 配置（如 `memfd_noexec_scope`）。\n- **`<linux/acct.h>`**：在命名空间销毁时清理进程会计信息。\n\n## 5. 使用场景\n\n- **容器启动**：当执行 `unshare(CLONE_NEWPID)` 或 `clone(CLONE_NEWPID)` 时，内核调用 `copy_pid_ns()` 创建新的 PID 命名空间，使容器内进程拥有独立的 PID 视图（容器内 PID 1 对应宿主机某个高 PID）。\n- **容器退出**：当容器的 init 进程（PID 1）退出时，内核自动调用 `zap_pid_ns_processes()` 终止命名空间内所有剩余进程，防止孤儿进程泄漏。\n- **命名空间嵌套**：支持多层容器或 sandbox 场景，如 systemd-nspawn 嵌套运行容器。\n- **资源隔离与限制**：结合用户命名空间，限制非特权用户创建过多 PID 命名空间，提升系统安全性。\n- **进程迁移与检查点**：配合 CRIU（Checkpoint/Restore in Userspace）等工具，通过 sysctl 接口控制命名空间行为（如 memfd 执行权限）。",
      "similarity": 0.64459228515625,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 281,
          "end_line": 379,
          "content": [
            "static int pid_ns_ctl_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);",
            "\tstruct ctl_table tmp = *table;",
            "\tint ret, next;",
            "",
            "\tif (write && !checkpoint_restore_ns_capable(pid_ns->user_ns))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Writing directly to ns' last_pid field is OK, since this field",
            "\t * is volatile in a living namespace anyway and a code writing to",
            "\t * it should synchronize its usage with external means.",
            "\t */",
            "",
            "\tnext = idr_get_cursor(&pid_ns->idr) - 1;",
            "",
            "\ttmp.data = &next;",
            "\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);",
            "\tif (!ret && write)",
            "\t\tidr_set_cursor(&pid_ns->idr, next + 1);",
            "",
            "\treturn ret;",
            "}",
            "int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)",
            "{",
            "\tif (pid_ns == &init_pid_ns)",
            "\t\treturn 0;",
            "",
            "\tswitch (cmd) {",
            "\tcase LINUX_REBOOT_CMD_RESTART2:",
            "\tcase LINUX_REBOOT_CMD_RESTART:",
            "\t\tpid_ns->reboot = SIGHUP;",
            "\t\tbreak;",
            "",
            "\tcase LINUX_REBOOT_CMD_POWER_OFF:",
            "\tcase LINUX_REBOOT_CMD_HALT:",
            "\t\tpid_ns->reboot = SIGINT;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tsend_sig(SIGKILL, pid_ns->child_reaper, 1);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tdo_exit(0);",
            "",
            "\t/* Not reached */",
            "\treturn 0;",
            "}",
            "static void pidns_put(struct ns_common *ns)",
            "{",
            "\tput_pid_ns(to_pid_ns(ns));",
            "}",
            "static int pidns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct nsproxy *nsproxy = nsset->nsproxy;",
            "\tstruct pid_namespace *active = task_active_pid_ns(current);",
            "\tstruct pid_namespace *ancestor, *new = to_pid_ns(ns);",
            "",
            "\tif (!ns_capable(new->user_ns, CAP_SYS_ADMIN) ||",
            "\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Only allow entering the current active pid namespace",
            "\t * or a child of the current active pid namespace.",
            "\t *",
            "\t * This is required for fork to return a usable pid value and",
            "\t * this maintains the property that processes and their",
            "\t * children can not escape their current pid namespace.",
            "\t */",
            "\tif (new->level < active->level)",
            "\t\treturn -EINVAL;",
            "",
            "\tancestor = new;",
            "\twhile (ancestor->level > active->level)",
            "\t\tancestor = ancestor->parent;",
            "\tif (ancestor != active)",
            "\t\treturn -EINVAL;",
            "",
            "\tput_pid_ns(nsproxy->pid_ns_for_children);",
            "\tnsproxy->pid_ns_for_children = get_pid_ns(new);",
            "\treturn 0;",
            "}",
            "static __init int pid_namespaces_init(void)",
            "{",
            "\tpid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC | SLAB_ACCOUNT);",
            "",
            "#ifdef CONFIG_CHECKPOINT_RESTORE",
            "\tregister_sysctl_init(\"kernel\", pid_ns_ctl_table);",
            "#endif",
            "",
            "\tregister_pid_ns_sysctl_table_vm();",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pid_ns_ctl_handler, reboot_pid_ns, pidns_put, pidns_install, pid_namespaces_init",
          "description": "包含pid命名空间控制接口处理函数pid_ns_ctl_handler，reboot_pid_ns设置命名空间重启信号，pidns_install验证命名空间层级权限并进行安装操作，pid_namespaces_init完成核心数据结构初始化和sysctl注册",
          "similarity": 0.5947387218475342
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 1,
          "end_line": 67,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Pid namespaces",
            " *",
            " * Authors:",
            " *    (C) 2007 Pavel Emelyanov <xemul@openvz.org>, OpenVZ, SWsoft Inc.",
            " *    (C) 2007 Sukadev Bhattiprolu <sukadev@us.ibm.com>, IBM",
            " *     Many thanks to Oleg Nesterov for comments and help",
            " *",
            " */",
            "",
            "#include <linux/pid.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cred.h>",
            "#include <linux/err.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/reboot.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/idr.h>",
            "#include <uapi/linux/wait.h>",
            "#include \"pid_sysctl.h\"",
            "",
            "static DEFINE_MUTEX(pid_caches_mutex);",
            "static struct kmem_cache *pid_ns_cachep;",
            "/* Write once array, filled from the beginning. */",
            "static struct kmem_cache *pid_cache[MAX_PID_NS_LEVEL];",
            "",
            "/*",
            " * creates the kmem cache to allocate pids from.",
            " * @level: pid namespace level",
            " */",
            "",
            "static struct kmem_cache *create_pid_cachep(unsigned int level)",
            "{",
            "\t/* Level 0 is init_pid_ns.pid_cachep */",
            "\tstruct kmem_cache **pkc = &pid_cache[level - 1];",
            "\tstruct kmem_cache *kc;",
            "\tchar name[4 + 10 + 1];",
            "\tunsigned int len;",
            "",
            "\tkc = READ_ONCE(*pkc);",
            "\tif (kc)",
            "\t\treturn kc;",
            "",
            "\tsnprintf(name, sizeof(name), \"pid_%u\", level + 1);",
            "\tlen = struct_size_t(struct pid, numbers, level + 1);",
            "\tmutex_lock(&pid_caches_mutex);",
            "\t/* Name collision forces to do allocation under mutex. */",
            "\tif (!*pkc)",
            "\t\t*pkc = kmem_cache_create(name, len, 0,",
            "\t\t\t\t\t SLAB_HWCACHE_ALIGN | SLAB_ACCOUNT, NULL);",
            "\tmutex_unlock(&pid_caches_mutex);",
            "\t/* current can fail, but someone else can succeed. */",
            "\treturn READ_ONCE(*pkc);",
            "}",
            "",
            "static struct ucounts *inc_pid_namespaces(struct user_namespace *ns)",
            "{",
            "\treturn inc_ucount(ns, current_euid(), UCOUNT_PID_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用于管理pid命名空间的kmem缓存创建函数create_pid_cachep，根据层级参数为不同pid命名空间级别创建专用内存池；inc_pid_namespaces函数用于增加用户命名空间的使用计数",
          "similarity": 0.5754290819168091
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 68,
          "end_line": 208,
          "content": [
            "static void dec_pid_namespaces(struct ucounts *ucounts)",
            "{",
            "\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);",
            "}",
            "static void delayed_free_pidns(struct rcu_head *p)",
            "{",
            "\tstruct pid_namespace *ns = container_of(p, struct pid_namespace, rcu);",
            "",
            "\tdec_pid_namespaces(ns->ucounts);",
            "\tput_user_ns(ns->user_ns);",
            "",
            "\tkmem_cache_free(pid_ns_cachep, ns);",
            "}",
            "static void destroy_pid_namespace(struct pid_namespace *ns)",
            "{",
            "\tns_free_inum(&ns->ns);",
            "",
            "\tidr_destroy(&ns->idr);",
            "\tcall_rcu(&ns->rcu, delayed_free_pidns);",
            "}",
            "void put_pid_ns(struct pid_namespace *ns)",
            "{",
            "\tstruct pid_namespace *parent;",
            "",
            "\twhile (ns != &init_pid_ns) {",
            "\t\tparent = ns->parent;",
            "\t\tif (!refcount_dec_and_test(&ns->ns.count))",
            "\t\t\tbreak;",
            "\t\tdestroy_pid_namespace(ns);",
            "\t\tns = parent;",
            "\t}",
            "}",
            "void zap_pid_ns_processes(struct pid_namespace *pid_ns)",
            "{",
            "\tint nr;",
            "\tint rc;",
            "\tstruct task_struct *task, *me = current;",
            "\tint init_pids = thread_group_leader(me) ? 1 : 2;",
            "\tstruct pid *pid;",
            "",
            "\t/* Don't allow any more processes into the pid namespace */",
            "\tdisable_pid_allocation(pid_ns);",
            "",
            "\t/*",
            "\t * Ignore SIGCHLD causing any terminated children to autoreap.",
            "\t * This speeds up the namespace shutdown, plus see the comment",
            "\t * below.",
            "\t */",
            "\tspin_lock_irq(&me->sighand->siglock);",
            "\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;",
            "\tspin_unlock_irq(&me->sighand->siglock);",
            "",
            "\t/*",
            "\t * The last thread in the cgroup-init thread group is terminating.",
            "\t * Find remaining pid_ts in the namespace, signal and wait for them",
            "\t * to exit.",
            "\t *",
            "\t * Note:  This signals each threads in the namespace - even those that",
            "\t * \t  belong to the same thread group, To avoid this, we would have",
            "\t * \t  to walk the entire tasklist looking a processes in this",
            "\t * \t  namespace, but that could be unnecessarily expensive if the",
            "\t * \t  pid namespace has just a few processes. Or we need to",
            "\t * \t  maintain a tasklist for each pid namespace.",
            "\t *",
            "\t */",
            "\trcu_read_lock();",
            "\tread_lock(&tasklist_lock);",
            "\tnr = 2;",
            "\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {",
            "\t\ttask = pid_task(pid, PIDTYPE_PID);",
            "\t\tif (task && !__fatal_signal_pending(task))",
            "\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.",
            "\t * kernel_wait4() will also block until our children traced from the",
            "\t * parent namespace are detached and become EXIT_DEAD.",
            "\t */",
            "\tdo {",
            "\t\tclear_thread_flag(TIF_SIGPENDING);",
            "\t\tclear_thread_flag(TIF_NOTIFY_SIGNAL);",
            "\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);",
            "\t} while (rc != -ECHILD);",
            "",
            "\t/*",
            "\t * kernel_wait4() misses EXIT_DEAD children, and EXIT_ZOMBIE",
            "\t * process whose parents processes are outside of the pid",
            "\t * namespace.  Such processes are created with setns()+fork().",
            "\t *",
            "\t * If those EXIT_ZOMBIE processes are not reaped by their",
            "\t * parents before their parents exit, they will be reparented",
            "\t * to pid_ns->child_reaper.  Thus pidns->child_reaper needs to",
            "\t * stay valid until they all go away.",
            "\t *",
            "\t * The code relies on the pid_ns->child_reaper ignoring",
            "\t * SIGCHILD to cause those EXIT_ZOMBIE processes to be",
            "\t * autoreaped if reparented.",
            "\t *",
            "\t * Semantically it is also desirable to wait for EXIT_ZOMBIE",
            "\t * processes before allowing the child_reaper to be reaped, as",
            "\t * that gives the invariant that when the init process of a",
            "\t * pid namespace is reaped all of the processes in the pid",
            "\t * namespace are gone.",
            "\t *",
            "\t * Once all of the other tasks are gone from the pid_namespace",
            "\t * free_pid() will awaken this task.",
            "\t */",
            "\tfor (;;) {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tif (pid_ns->pid_allocated == init_pids)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * Release tasks_rcu_exit_srcu to avoid following deadlock:",
            "\t\t *",
            "\t\t * 1) TASK A unshare(CLONE_NEWPID)",
            "\t\t * 2) TASK A fork() twice -> TASK B (child reaper for new ns)",
            "\t\t *    and TASK C",
            "\t\t * 3) TASK B exits, kills TASK C, waits for TASK A to reap it",
            "\t\t * 4) TASK A calls synchronize_rcu_tasks()",
            "\t\t *                   -> synchronize_srcu(tasks_rcu_exit_srcu)",
            "\t\t * 5) *DEADLOCK*",
            "\t\t *",
            "\t\t * It is considered safe to release tasks_rcu_exit_srcu here",
            "\t\t * because we assume the current task can not be concurrently",
            "\t\t * reaped at this point.",
            "\t\t */",
            "\t\texit_tasks_rcu_stop();",
            "\t\tschedule();",
            "\t\texit_tasks_rcu_start();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tif (pid_ns->reboot)",
            "\t\tcurrent->signal->group_exit_code = pid_ns->reboot;",
            "",
            "\tacct_exit_ns(pid_ns);",
            "\treturn;",
            "}"
          ],
          "function_name": "dec_pid_namespaces, delayed_free_pidns, destroy_pid_namespace, put_pid_ns, zap_pid_ns_processes",
          "description": "包含销毁pid命名空间相关函数，其中destroy_pid_namespace通过RCU机制延迟释放资源，zap_pid_ns_processes强制终止命名空间内所有进程并回收资源，put_pid_ns管理命名空间引用计数",
          "similarity": 0.5676052570343018
        }
      ]
    },
    {
      "source_file": "kernel/user_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:46:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user_namespace.c`\n\n---\n\n# user_namespace.c 技术文档\n\n## 1. 文件概述\n\n`user_namespace.c` 是 Linux 内核中实现用户命名空间（User Namespace）核心功能的源文件。用户命名空间是 Linux 命名空间机制的一部分，用于隔离用户和组 ID（UID/GID），使得不同命名空间中的相同 UID 可以映射到宿主系统中的不同实际 UID/GID。该文件负责用户命名空间的创建、销毁、引用计数管理、ID 映射查找以及与凭证（credentials）的集成，是容器化技术（如 Docker、LXC）实现非特权容器和用户隔离的关键组件。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`create_user_ns(struct cred *new)`**  \n  创建一个新的用户命名空间，设置其父命名空间、层级、所有者、资源限制，并初始化凭证中的命名空间指针。\n\n- **`unshare_userns(unsigned long unshare_flags, struct cred **new_cred)`**  \n  为当前进程创建新的用户命名空间（通过 `unshare(CLONE_NEWUSER)` 系统调用触发），并返回新的凭证结构。\n\n- **`free_user_ns(struct work_struct *work)`**  \n  异步释放用户命名空间及其关联资源（如 ID 映射、sysctl 表、密钥环等），通过工作队列延迟执行以避免死锁。\n\n- **`__put_user_ns(struct user_namespace *ns)`**  \n  减少用户命名空间引用计数，若引用计数归零则调度 `free_user_ns` 工作项进行释放。\n\n- **`map_id_range_down_base()` / `map_id_range_down_max()`**  \n  在 UID/GID 映射表中查找指定 ID 范围对应的映射条目，分别处理小规模（≤4 条）和大规模（>4 条）映射。\n\n- **`cmp_map_id()`**  \n  用于二分查找的比较函数，支持正向（内核 ID → 用户 ID）和反向（用户 ID → 内核 ID）映射查询。\n\n- **`set_cred_user_ns()`**  \n  初始化新凭证中的用户命名空间相关字段，包括能力集（capabilities）、安全位（securebits）和密钥认证上下文。\n\n- **`enforced_nproc_rlimit()`**  \n  根据当前用户是否为全局 root 以及是否处于初始用户命名空间，决定是否对 `RLIMIT_NPROC` 施加限制。\n\n### 主要数据结构\n\n- **`struct user_namespace`**  \n  用户命名空间的核心结构体，包含父命名空间指针、层级、所有者 UID/GID、ID 映射表（uid_map、gid_map、projid_map）、资源使用计数器（ucounts）、引用计数、标志位、密钥环列表等。\n\n- **`struct idmap_key`**  \n  用于 ID 映射查找的辅助结构，封装待查找的 ID、范围长度及映射方向（向上/向下）。\n\n- **`struct uid_gid_extent`**  \n  表示单个 UID/GID 映射区间的结构，包含起始内核 ID、起始用户 ID 和映射长度。\n\n## 3. 关键实现\n\n### 用户命名空间创建流程\n1. **层级限制检查**：防止命名空间嵌套过深（最大 32 层）。\n2. **资源计数**：通过 `inc_user_namespaces()` 增加父命名空间中创建者的用户命名空间使用计数。\n3. **安全策略验证**：\n   - 禁止在 chroot 环境中创建新用户命名空间。\n   - 确保创建者的 UID/GID 在父命名空间中有有效映射。\n4. **安全模块回调**：调用 LSM（如 SELinux、AppArmor）的 `security_create_user_ns()` 钩子进行权限检查。\n5. **初始化新命名空间**：\n   - 分配内存并设置层级、所有者、父指针。\n   - 初始化资源限制（如进程数、消息队列大小等）。\n   - 继承父命名空间的标志（如 `USERNS_SETGROUPS_ALLOWED`）。\n   - 设置凭证中的用户命名空间指针并重置能力集。\n\n### ID 映射查找算法\n- **小规模映射（≤4 条）**：使用线性遍历（`map_id_range_down_base`）。\n- **大规模映射（>4 条）**：使用二分查找（`map_id_range_down_max` + `bsearch`），映射表按 `first` 字段排序。\n- **双向映射支持**：通过 `idmap_key.map_up` 标志区分内核 ID → 用户 ID（map down）和用户 ID → 内核 ID（map up）。\n\n### 异步释放机制\n- 使用 `INIT_WORK()` 将释放操作注册为工作队列任务。\n- 在 `free_user_ns()` 中循环释放命名空间链（处理引用计数级联归零的情况）。\n- 释放动态分配的映射表内存、sysctl 表、密钥环资源，并减少资源使用计数。\n\n### 能力与安全上下文初始化\n- 新命名空间的初始凭证拥有 `CAP_FULL_SET`，但这些能力仅在新命名空间内有效。\n- 清除请求密钥认证（`request_key_auth`）上下文，防止跨命名空间密钥泄露。\n- 重置安全位（`securebits`）为默认值。\n\n## 4. 依赖关系\n\n- **命名空间基础设施**：依赖 `<linux/nsproxy.h>` 和 `ns_common` 结构，与 `proc_ns.c` 协作提供 `/proc/<pid>/ns/user` 接口。\n- **凭证管理**：与 `<linux/cred.h>` 紧密集成，通过 `prepare_creds()`/`put_cred()` 管理凭证生命周期。\n- **资源计数**：使用 `<linux/user_namespace.h>` 中的 `ucounts` 机制跟踪用户命名空间、进程数等资源使用。\n- **安全模块**：通过 LSM 接口（`security_create_user_ns()`）与安全子系统交互。\n- **密钥管理**：依赖 `<keys/user-type.h>` 实现命名空间隔离的用户密钥环。\n- **内存管理**：使用 SLAB 分配器（`kmem_cache`）高效分配 `user_namespace` 结构。\n- **ID 映射**：与 `uidgid.c` 协同实现 UID/GID 映射的设置与查询。\n\n## 5. 使用场景\n\n- **容器运行时**：Docker、Podman、LXC 等通过 `unshare(CLONE_NEWUSER)` 创建非特权容器，实现用户隔离。\n- **用户态命名空间管理**：`unshare(1)` 命令或 `clone(2)` 系统调用创建独立用户上下文。\n- **特权降级**：进程在创建用户命名空间后映射自身为新命名空间的 root，获得有限特权。\n- **安全沙箱**：浏览器、应用沙箱利用用户命名空间限制潜在攻击面。\n- **ID 映射服务**：`newuidmap`/`newgidmap` 工具通过写入 `/proc/<pid>/uid_map` 配置映射，内核通过本文件中的查找函数解析映射关系。\n- **资源隔离**：结合 `ucounts` 机制限制单个用户可创建的用户命名空间数量，防止资源耗尽攻击。",
      "similarity": 0.6236592531204224,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user_namespace.c",
          "start_line": 41,
          "end_line": 180,
          "content": [
            "static void dec_user_namespaces(struct ucounts *ucounts)",
            "{",
            "\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);",
            "}",
            "static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)",
            "{",
            "\t/* Start with the same capabilities as init but useless for doing",
            "\t * anything as the capabilities are bound to the new user namespace.",
            "\t */",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_securebits(cred, SECUREBITS_DEFAULT);",
            "\tiee_set_cred_cap_inheritable(cred, CAP_EMPTY_SET);",
            "\tiee_set_cred_cap_permitted(cred, CAP_FULL_SET);",
            "\tiee_set_cred_cap_effective(cred, CAP_FULL_SET);",
            "\tiee_set_cred_cap_ambient(cred, CAP_EMPTY_SET);",
            "\tiee_set_cred_cap_bset(cred, CAP_FULL_SET);",
            "#ifdef CONFIG_KEYS",
            "\tkey_put(cred->request_key_auth);",
            "\tiee_set_cred_request_key_auth(cred, NULL);",
            "#endif",
            "\tiee_set_cred_user_ns(cred, user_ns);",
            "\t#else",
            "\tcred->securebits = SECUREBITS_DEFAULT;",
            "\tcred->cap_inheritable = CAP_EMPTY_SET;",
            "\tcred->cap_permitted = CAP_FULL_SET;",
            "\tcred->cap_effective = CAP_FULL_SET;",
            "\tcred->cap_ambient = CAP_EMPTY_SET;",
            "\tcred->cap_bset = CAP_FULL_SET;",
            "#ifdef CONFIG_KEYS",
            "\tkey_put(cred->request_key_auth);",
            "\tcred->request_key_auth = NULL;",
            "#endif",
            "\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */",
            "\tcred->user_ns = user_ns;",
            "\t#endif",
            "}",
            "static unsigned long enforced_nproc_rlimit(void)",
            "{",
            "\tunsigned long limit = RLIM_INFINITY;",
            "",
            "\t/* Is RLIMIT_NPROC currently enforced? */",
            "\tif (!uid_eq(current_uid(), GLOBAL_ROOT_UID) ||",
            "\t    (current_user_ns() != &init_user_ns))",
            "\t\tlimit = rlimit(RLIMIT_NPROC);",
            "",
            "\treturn limit;",
            "}",
            "int create_user_ns(struct cred *new)",
            "{",
            "\tstruct user_namespace *ns, *parent_ns = new->user_ns;",
            "\tkuid_t owner = new->euid;",
            "\tkgid_t group = new->egid;",
            "\tstruct ucounts *ucounts;",
            "\tint ret, i;",
            "",
            "\tret = -ENOSPC;",
            "\tif (parent_ns->level > 32)",
            "\t\tgoto fail;",
            "",
            "\tucounts = inc_user_namespaces(parent_ns, owner);",
            "\tif (!ucounts)",
            "\t\tgoto fail;",
            "",
            "\t/*",
            "\t * Verify that we can not violate the policy of which files",
            "\t * may be accessed that is specified by the root directory,",
            "\t * by verifying that the root directory is at the root of the",
            "\t * mount namespace which allows all files to be accessed.",
            "\t */",
            "\tret = -EPERM;",
            "\tif (current_chrooted())",
            "\t\tgoto fail_dec;",
            "",
            "\t/* The creator needs a mapping in the parent user namespace",
            "\t * or else we won't be able to reasonably tell userspace who",
            "\t * created a user_namespace.",
            "\t */",
            "\tret = -EPERM;",
            "\tif (!kuid_has_mapping(parent_ns, owner) ||",
            "\t    !kgid_has_mapping(parent_ns, group))",
            "\t\tgoto fail_dec;",
            "",
            "\tret = security_create_user_ns(new);",
            "\tif (ret < 0)",
            "\t\tgoto fail_dec;",
            "",
            "\tret = -ENOMEM;",
            "\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);",
            "\tif (!ns)",
            "\t\tgoto fail_dec;",
            "",
            "\tns->parent_could_setfcap = cap_raised(new->cap_effective, CAP_SETFCAP);",
            "\tret = ns_alloc_inum(&ns->ns);",
            "\tif (ret)",
            "\t\tgoto fail_free;",
            "\tns->ns.ops = &userns_operations;",
            "",
            "\trefcount_set(&ns->ns.count, 1);",
            "\t/* Leave the new->user_ns reference with the new user namespace. */",
            "\tns->parent = parent_ns;",
            "\tns->level = parent_ns->level + 1;",
            "\tns->owner = owner;",
            "\tns->group = group;",
            "\tINIT_WORK(&ns->work, free_user_ns);",
            "\tfor (i = 0; i < UCOUNT_COUNTS; i++) {",
            "\t\tns->ucount_max[i] = INT_MAX;",
            "\t}",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_NPROC, enforced_nproc_rlimit());",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_MSGQUEUE, rlimit(RLIMIT_MSGQUEUE));",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_SIGPENDING, rlimit(RLIMIT_SIGPENDING));",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_MEMLOCK, rlimit(RLIMIT_MEMLOCK));",
            "\tns->ucounts = ucounts;",
            "",
            "\t/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */",
            "\tmutex_lock(&userns_state_mutex);",
            "\tns->flags = parent_ns->flags;",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "#ifdef CONFIG_KEYS",
            "\tINIT_LIST_HEAD(&ns->keyring_name_list);",
            "\tinit_rwsem(&ns->keyring_sem);",
            "#endif",
            "\tret = -ENOMEM;",
            "\tif (!setup_userns_sysctls(ns))",
            "\t\tgoto fail_keyring;",
            "",
            "\tset_cred_user_ns(new, ns);",
            "\treturn 0;",
            "fail_keyring:",
            "#ifdef CONFIG_PERSISTENT_KEYRINGS",
            "\tkey_put(ns->persistent_keyring_register);",
            "#endif",
            "\tns_free_inum(&ns->ns);",
            "fail_free:",
            "\tkmem_cache_free(user_ns_cachep, ns);",
            "fail_dec:",
            "\tdec_user_namespaces(ucounts);",
            "fail:",
            "\treturn ret;",
            "}"
          ],
          "function_name": "dec_user_namespaces, set_cred_user_ns, enforced_nproc_rlimit, create_user_ns",
          "description": "实现用户命名空间创建逻辑，包含权限验证、资源分配、安全策略应用及命名空间引用计数管理。",
          "similarity": 0.6216557025909424
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1297,
          "end_line": 1365,
          "content": [
            "bool userns_may_setgroups(const struct user_namespace *ns)",
            "{",
            "\tbool allowed;",
            "",
            "\tmutex_lock(&userns_state_mutex);",
            "\t/* It is not safe to use setgroups until a gid mapping in",
            "\t * the user namespace has been established.",
            "\t */",
            "\tallowed = ns->gid_map.nr_extents != 0;",
            "\t/* Is setgroups allowed? */",
            "\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "\treturn allowed;",
            "}",
            "bool in_userns(const struct user_namespace *ancestor,",
            "\t       const struct user_namespace *child)",
            "{",
            "\tconst struct user_namespace *ns;",
            "\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)",
            "\t\t;",
            "\treturn (ns == ancestor);",
            "}",
            "bool current_in_userns(const struct user_namespace *target_ns)",
            "{",
            "\treturn in_userns(target_ns, current_user_ns());",
            "}",
            "static void userns_put(struct ns_common *ns)",
            "{",
            "\tput_user_ns(to_user_ns(ns));",
            "}",
            "static int userns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct user_namespace *user_ns = to_user_ns(ns);",
            "\tstruct cred *cred;",
            "",
            "\t/* Don't allow gaining capabilities by reentering",
            "\t * the same user namespace.",
            "\t */",
            "\tif (user_ns == current_user_ns())",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Tasks that share a thread group must share a user namespace */",
            "\tif (!thread_group_empty(current))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (current->fs->users != 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tcred = nsset_cred(nsset);",
            "\tif (!cred)",
            "\t\treturn -EINVAL;",
            "",
            "\tput_user_ns(cred->user_ns);",
            "\tset_cred_user_ns(cred, get_user_ns(user_ns));",
            "",
            "\tif (set_cred_ucounts(cred) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static __init int user_namespaces_init(void)",
            "{",
            "\tuser_ns_cachep = KMEM_CACHE(user_namespace, SLAB_PANIC | SLAB_ACCOUNT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "userns_may_setgroups, in_userns, current_in_userns, userns_put, userns_install, user_namespaces_init",
          "description": "实现用户命名空间相关辅助功能，userns_may_setgroups检查setgroups可用性，in_userns判断命名空间层级关系，userns_install负责用户命名空间的安装与引用计数管理，user_namespaces_init初始化用户命名空间对象缓存",
          "similarity": 0.6172235012054443
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1,
          "end_line": 40,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/export.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/highuid.h>",
            "#include <linux/cred.h>",
            "#include <linux/securebits.h>",
            "#include <linux/security.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ctype.h>",
            "#include <linux/projid.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/sort.h>",
            "#ifdef CONFIG_CREDP",
            "#include <asm/iee-cred.h>",
            "#endif",
            "",
            "static struct kmem_cache *user_ns_cachep __ro_after_init;",
            "static DEFINE_MUTEX(userns_state_mutex);",
            "",
            "static bool new_idmap_permitted(const struct file *file,",
            "\t\t\t\tstruct user_namespace *ns, int cap_setid,",
            "\t\t\t\tstruct uid_gid_map *map);",
            "static void free_user_ns(struct work_struct *work);",
            "",
            "static struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)",
            "{",
            "\treturn inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用户命名空间相关全局变量和缓存，声明辅助函数及用户命名空间操作的通用接口。",
          "similarity": 0.6143980622291565
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/user_namespace.c",
          "start_line": 722,
          "end_line": 822,
          "content": [
            "static void m_stop(struct seq_file *seq, void *v)",
            "{",
            "\treturn;",
            "}",
            "static bool mappings_overlap(struct uid_gid_map *new_map,",
            "\t\t\t     struct uid_gid_extent *extent)",
            "{",
            "\tu32 upper_first, lower_first, upper_last, lower_last;",
            "\tunsigned idx;",
            "",
            "\tupper_first = extent->first;",
            "\tlower_first = extent->lower_first;",
            "\tupper_last = upper_first + extent->count - 1;",
            "\tlower_last = lower_first + extent->count - 1;",
            "",
            "\tfor (idx = 0; idx < new_map->nr_extents; idx++) {",
            "\t\tu32 prev_upper_first, prev_lower_first;",
            "\t\tu32 prev_upper_last, prev_lower_last;",
            "\t\tstruct uid_gid_extent *prev;",
            "",
            "\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\t\tprev = &new_map->extent[idx];",
            "\t\telse",
            "\t\t\tprev = &new_map->forward[idx];",
            "",
            "\t\tprev_upper_first = prev->first;",
            "\t\tprev_lower_first = prev->lower_first;",
            "\t\tprev_upper_last = prev_upper_first + prev->count - 1;",
            "\t\tprev_lower_last = prev_lower_first + prev->count - 1;",
            "",
            "\t\t/* Does the upper range intersect a previous extent? */",
            "\t\tif ((prev_upper_first <= upper_last) &&",
            "\t\t    (prev_upper_last >= upper_first))",
            "\t\t\treturn true;",
            "",
            "\t\t/* Does the lower range intersect a previous extent? */",
            "\t\tif ((prev_lower_first <= lower_last) &&",
            "\t\t    (prev_lower_last >= lower_first))",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static int insert_extent(struct uid_gid_map *map, struct uid_gid_extent *extent)",
            "{",
            "\tstruct uid_gid_extent *dest;",
            "",
            "\tif (map->nr_extents == UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\tstruct uid_gid_extent *forward;",
            "",
            "\t\t/* Allocate memory for 340 mappings. */",
            "\t\tforward = kmalloc_array(UID_GID_MAP_MAX_EXTENTS,",
            "\t\t\t\t\tsizeof(struct uid_gid_extent),",
            "\t\t\t\t\tGFP_KERNEL);",
            "\t\tif (!forward)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/* Copy over memory. Only set up memory for the forward pointer.",
            "\t\t * Defer the memory setup for the reverse pointer.",
            "\t\t */",
            "\t\tmemcpy(forward, map->extent,",
            "\t\t       map->nr_extents * sizeof(map->extent[0]));",
            "",
            "\t\tmap->forward = forward;",
            "\t\tmap->reverse = NULL;",
            "\t}",
            "",
            "\tif (map->nr_extents < UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\tdest = &map->extent[map->nr_extents];",
            "\telse",
            "\t\tdest = &map->forward[map->nr_extents];",
            "",
            "\t*dest = *extent;",
            "\tmap->nr_extents++;",
            "\treturn 0;",
            "}",
            "static int cmp_extents_forward(const void *a, const void *b)",
            "{",
            "\tconst struct uid_gid_extent *e1 = a;",
            "\tconst struct uid_gid_extent *e2 = b;",
            "",
            "\tif (e1->first < e2->first)",
            "\t\treturn -1;",
            "",
            "\tif (e1->first > e2->first)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int cmp_extents_reverse(const void *a, const void *b)",
            "{",
            "\tconst struct uid_gid_extent *e1 = a;",
            "\tconst struct uid_gid_extent *e2 = b;",
            "",
            "\tif (e1->lower_first < e2->lower_first)",
            "\t\treturn -1;",
            "",
            "\tif (e1->lower_first > e2->lower_first)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "m_stop, mappings_overlap, insert_extent, cmp_extents_forward, cmp_extents_reverse",
          "description": "实现用户命名空间映射区间管理函数，包含范围冲突检测、有序性排序及动态扩展逻辑。",
          "similarity": 0.5682801008224487
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/user_namespace.c",
          "start_line": 193,
          "end_line": 310,
          "content": [
            "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)",
            "{",
            "\tstruct cred *cred;",
            "\tint err = -ENOMEM;",
            "",
            "\tif (!(unshare_flags & CLONE_NEWUSER))",
            "\t\treturn 0;",
            "",
            "\tcred = prepare_creds();",
            "\tif (cred) {",
            "\t\terr = create_user_ns(cred);",
            "\t\tif (err)",
            "\t\t\tput_cred(cred);",
            "\t\telse",
            "\t\t\t*new_cred = cred;",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "static void free_user_ns(struct work_struct *work)",
            "{",
            "\tstruct user_namespace *parent, *ns =",
            "\t\tcontainer_of(work, struct user_namespace, work);",
            "",
            "\tdo {",
            "\t\tstruct ucounts *ucounts = ns->ucounts;",
            "\t\tparent = ns->parent;",
            "\t\tif (ns->gid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\t\tkfree(ns->gid_map.forward);",
            "\t\t\tkfree(ns->gid_map.reverse);",
            "\t\t}",
            "\t\tif (ns->uid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\t\tkfree(ns->uid_map.forward);",
            "\t\t\tkfree(ns->uid_map.reverse);",
            "\t\t}",
            "\t\tif (ns->projid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\t\tkfree(ns->projid_map.forward);",
            "\t\t\tkfree(ns->projid_map.reverse);",
            "\t\t}",
            "\t\tretire_userns_sysctls(ns);",
            "\t\tkey_free_user_ns(ns);",
            "\t\tns_free_inum(&ns->ns);",
            "\t\tkmem_cache_free(user_ns_cachep, ns);",
            "\t\tdec_user_namespaces(ucounts);",
            "\t\tns = parent;",
            "\t} while (refcount_dec_and_test(&parent->ns.count));",
            "}",
            "void __put_user_ns(struct user_namespace *ns)",
            "{",
            "\tschedule_work(&ns->work);",
            "}",
            "static int cmp_map_id(const void *k, const void *e)",
            "{",
            "\tu32 first, last, id2;",
            "\tconst struct idmap_key *key = k;",
            "\tconst struct uid_gid_extent *el = e;",
            "",
            "\tid2 = key->id + key->count - 1;",
            "",
            "\t/* handle map_id_{down,up}() */",
            "\tif (key->map_up)",
            "\t\tfirst = el->lower_first;",
            "\telse",
            "\t\tfirst = el->first;",
            "",
            "\tlast = first + el->count - 1;",
            "",
            "\tif (key->id >= first && key->id <= last &&",
            "\t    (id2 >= first && id2 <= last))",
            "\t\treturn 0;",
            "",
            "\tif (key->id < first || id2 < first)",
            "\t\treturn -1;",
            "",
            "\treturn 1;",
            "}",
            "static u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)",
            "{",
            "\tstruct uid_gid_extent *extent;",
            "\tunsigned extents = map->nr_extents;",
            "\tsmp_rmb();",
            "",
            "\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\textent = map_id_range_down_base(extents, map, id, count);",
            "\telse",
            "\t\textent = map_id_range_down_max(extents, map, id, count);",
            "",
            "\t/* Map the id or note failure */",
            "\tif (extent)",
            "\t\tid = (id - extent->first) + extent->lower_first;",
            "\telse",
            "\t\tid = (u32) -1;",
            "",
            "\treturn id;",
            "}",
            "static u32 map_id_down(struct uid_gid_map *map, u32 id)",
            "{",
            "\treturn map_id_range_down(map, id, 1);",
            "}",
            "static u32 map_id_up(struct uid_gid_map *map, u32 id)",
            "{",
            "\tstruct uid_gid_extent *extent;",
            "\tunsigned extents = map->nr_extents;",
            "\tsmp_rmb();",
            "",
            "\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\textent = map_id_up_base(extents, map, id);",
            "\telse",
            "\t\textent = map_id_up_max(extents, map, id);",
            "",
            "\t/* Map the id or note failure */",
            "\tif (extent)",
            "\t\tid = (id - extent->lower_first) + extent->first;",
            "\telse",
            "\t\tid = (u32) -1;",
            "",
            "\treturn id;",
            "}"
          ],
          "function_name": "unshare_userns, free_user_ns, __put_user_ns, cmp_map_id, map_id_range_down, map_id_down, map_id_up",
          "description": "提供用户命名空间解隔离接口与析构逻辑，包含映射表清理、引用计数递减及延迟释放机制。",
          "similarity": 0.5594087839126587
        }
      ]
    }
  ]
}