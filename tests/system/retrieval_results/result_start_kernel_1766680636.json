{
  "query": "start_kernel",
  "timestamp": "2025-12-26 00:37:16",
  "retrieved_files": [
    {
      "source_file": "kernel/reboot.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:51:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `reboot.c`\n\n---\n\n# reboot.c 技术文档\n\n## 1. 文件概述\n\n`reboot.c` 是 Linux 内核中负责系统重启、关机和紧急重启逻辑的核心实现文件。它提供了统一的接口用于注册重启通知器、处理重启准备流程、执行系统重启，并支持多种重启模式（如硬重启、软重启、kexec 等）。该文件协调设备关闭、用户空间辅助进程禁用、CPU 迁移等关键步骤，确保系统在重启前处于安全状态，并为架构无关代码提供标准化的重启抽象。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `C_A_D`：控制是否允许通过 Ctrl+Alt+Del 组合键触发重启（默认启用）。\n- `cad_pid`：指向处理 Ctrl+Alt+Del 信号的进程 PID（导出供其他模块使用）。\n- `reboot_mode`：当前系统重启模式（如 `REBOOT_HARD`、`REBOOT_SOFT` 等），ARM 架构默认为硬重启。\n- `panic_reboot_mode`：内核 panic 时使用的重启模式。\n- `reboot_default`：标识 `reboot=` 内核参数是否被显式设置，用于控制 DMI 重启 quirks 的启用。\n- `reboot_cpu` / `reboot_type` / `reboot_force`：控制重启目标 CPU、重启方式（如 ACPI、EFI 等）及是否强制重启。\n- `pm_power_off`：弱符号函数指针，作为遗留关机接口的临时占位符。\n\n### 主要函数\n- `emergency_restart()`：在紧急情况下（如死锁、严重错误）立即重启系统，可在中断上下文调用。\n- `kernel_restart_prepare()`：执行重启前的标准准备流程（通知链、设备关闭等）。\n- `kernel_restart()`：执行完整的系统重启流程，包括迁移至指定 CPU、关闭 syscore、调用底层 `machine_restart()`。\n- `register_reboot_notifier()` / `unregister_reboot_notifier()`：注册/注销重启通知器（阻塞型）。\n- `devm_register_reboot_notifier()`：基于设备资源管理的重启通知器注册。\n- `register_restart_handler()` / `unregister_restart_handler()`：注册/注销重启处理器（原子型，高优先级）。\n- `do_kernel_restart()`：调用已注册的重启处理器链，尝试执行架构无关的重启。\n- `migrate_to_reboot_cpu()`：将当前任务迁移到指定的重启 CPU（默认为 CPU 0 或首个在线 CPU）。\n- `do_kernel_restart_prepare()`：调用重启准备通知链，用于预处理。\n\n### 通知链\n- `reboot_notifier_list`（阻塞）：用于常规重启前的通知。\n- `restart_handler_list`（原子）：用于实际执行重启操作的高优先级处理器。\n- `restart_prep_handler_list`（阻塞）：用于重启前的额外准备步骤。\n\n## 3. 关键实现\n\n### 重启流程控制\n- **标准重启** (`kernel_restart`)：依次执行通知链 → 设备关闭 → 用户空间 helper 禁用 → 迁移到指定 CPU → syscore 关闭 → 调用架构相关 `machine_restart()`。\n- **紧急重启** (`emergency_restart`)：跳过大部分清理步骤，直接调用 `machine_emergency_restart()`，适用于系统已不稳定的情况。\n- **重启处理器机制**：通过 `register_restart_handler()` 注册的处理器（如 watchdog 驱动）可在 `machine_restart()` 中被调用（若其实现调用了 `do_kernel_restart()`），实现架构无关的重启能力。\n\n### CPU 迁移策略\n- `migrate_to_reboot_cpu()` 确保重启操作在指定 CPU（`reboot_cpu`）上执行，若该 CPU 离线则回退到首个在线 CPU。\n- 设置 `PF_NO_SETAFFINITY` 标志防止其他任务修改当前任务的 CPU 亲和性，保证迁移的可靠性。\n\n### 重启模式与参数\n- `reboot_mode` 允许内核或用户空间指定重启类型（硬/软/kexec），影响底层硬件操作方式。\n- `reboot_default` 变量用于判断是否通过内核命令行显式设置了 `reboot=` 参数，从而决定是否跳过 DMI 重启 quirks 扫描，便于覆盖错误的固件行为。\n\n### 资源管理\n- `devm_register_reboot_notifier()` 使用设备资源管理（devres）自动注销通知器，避免资源泄漏。\n\n## 4. 依赖关系\n\n- **架构相关代码**：依赖 `machine_restart()` 和 `machine_emergency_restart()` 的架构特定实现（位于 `arch/*/kernel/reboot.c` 等）。\n- **设备模型**：调用 `device_shutdown()` 关闭设备，依赖驱动模型。\n- **电源管理**：与 `suspend.h` 和遗留的 `pm_power_off` 接口交互。\n- **kexec**：支持通过 `kexec` 实现快速重启，依赖 `kexec.h`。\n- **内核通知机制**：使用 `notifier.h` 提供的阻塞和原子通知链。\n- **用户空间交互**：通过 `syscalls.h` 暴露系统调用接口（如 `reboot()` 系统调用）。\n- **日志系统**：使用 `kmsg_dump()` 在重启前转储内核日志。\n\n## 5. 使用场景\n\n- **系统调用处理**：`sys_reboot()` 系统调用最终调用 `kernel_restart()` 或 `kernel_halt()` 等函数。\n- **内核 Panic**：当配置了 panic 后自动重启时，调用 `emergency_restart()` 或 `kernel_restart()`。\n- **硬件驱动**：Watchdog 或电源管理芯片驱动通过 `register_restart_handler()` 注册硬件级重启能力。\n- **用户空间工具**：`reboot`、`shutdown` 等命令通过系统调用触发内核重启流程。\n- **kexec 快速启动**：配合 kexec 实现无需固件介入的内核切换。\n- **调试与恢复**：在系统卡死时通过 Magic SysRq 或硬件看门狗触发紧急重启。",
      "similarity": 0.5791140198707581,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/reboot.c",
          "start_line": 609,
          "end_line": 728,
          "content": [
            "void unregister_platform_power_off(void (*power_off)(void))",
            "{",
            "\tif (platform_power_off_handler &&",
            "\t    platform_power_off_handler->cb_data == power_off) {",
            "\t\tunregister_sys_off_handler(platform_power_off_handler);",
            "\t\tplatform_power_off_handler = NULL;",
            "\t}",
            "}",
            "static int legacy_pm_power_off(struct sys_off_data *data)",
            "{",
            "\tif (pm_power_off)",
            "\t\tpm_power_off();",
            "",
            "\treturn NOTIFY_DONE;",
            "}",
            "static void do_kernel_power_off_prepare(void)",
            "{",
            "\tblocking_notifier_call_chain(&power_off_prep_handler_list, 0, NULL);",
            "}",
            "void do_kernel_power_off(void)",
            "{",
            "\tstruct sys_off_handler *sys_off = NULL;",
            "",
            "\t/*",
            "\t * Register sys-off handlers for legacy PM callback. This allows",
            "\t * legacy PM callbacks temporary co-exist with the new sys-off API.",
            "\t *",
            "\t * TODO: Remove legacy handlers once all legacy PM users will be",
            "\t *       switched to the sys-off based APIs.",
            "\t */",
            "\tif (pm_power_off)",
            "\t\tsys_off = register_sys_off_handler(SYS_OFF_MODE_POWER_OFF,",
            "\t\t\t\t\t\t   SYS_OFF_PRIO_DEFAULT,",
            "\t\t\t\t\t\t   legacy_pm_power_off, NULL);",
            "",
            "\tatomic_notifier_call_chain(&power_off_handler_list, 0, NULL);",
            "",
            "\tunregister_sys_off_handler(sys_off);",
            "}",
            "bool kernel_can_power_off(void)",
            "{",
            "\treturn !atomic_notifier_call_chain_is_empty(&power_off_handler_list) ||",
            "\t\tpm_power_off;",
            "}",
            "void kernel_power_off(void)",
            "{",
            "\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);",
            "\tdo_kernel_power_off_prepare();",
            "\tmigrate_to_reboot_cpu();",
            "\tsyscore_shutdown();",
            "\tpr_emerg(\"Power down\\n\");",
            "\tkmsg_dump(KMSG_DUMP_SHUTDOWN);",
            "\tmachine_power_off();",
            "}",
            "static void deferred_cad(struct work_struct *dummy)",
            "{",
            "\tkernel_restart(NULL);",
            "}",
            "void ctrl_alt_del(void)",
            "{",
            "\tstatic DECLARE_WORK(cad_work, deferred_cad);",
            "",
            "\tif (C_A_D)",
            "\t\tschedule_work(&cad_work);",
            "\telse",
            "\t\tkill_cad_pid(SIGINT, 1);",
            "}",
            "static int run_cmd(const char *cmd)",
            "{",
            "\tchar **argv;",
            "\tstatic char *envp[] = {",
            "\t\t\"HOME=/\",",
            "\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",",
            "\t\tNULL",
            "\t};",
            "\tint ret;",
            "\targv = argv_split(GFP_KERNEL, cmd, NULL);",
            "\tif (argv) {",
            "\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);",
            "\t\targv_free(argv);",
            "\t} else {",
            "\t\tret = -ENOMEM;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __orderly_reboot(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = run_cmd(reboot_cmd);",
            "",
            "\tif (ret) {",
            "\t\tpr_warn(\"Failed to start orderly reboot: forcing the issue\\n\");",
            "\t\temergency_sync();",
            "\t\tkernel_restart(NULL);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __orderly_poweroff(bool force)",
            "{",
            "\tint ret;",
            "",
            "\tret = run_cmd(poweroff_cmd);",
            "",
            "\tif (ret && force) {",
            "\t\tpr_warn(\"Failed to start orderly shutdown: forcing the issue\\n\");",
            "",
            "\t\t/*",
            "\t\t * I guess this should try to kick off some daemon to sync and",
            "\t\t * poweroff asap.  Or not even bother syncing if we're doing an",
            "\t\t * emergency shutdown?",
            "\t\t */",
            "\t\temergency_sync();",
            "\t\tkernel_power_off();",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "unregister_platform_power_off, legacy_pm_power_off, do_kernel_power_off_prepare, do_kernel_power_off, kernel_can_power_off, kernel_power_off, deferred_cad, ctrl_alt_del, run_cmd, __orderly_reboot, __orderly_poweroff",
          "description": "处理传统PM电源关闭接口兼容性，实现kernel_power_off强制关机逻辑，包含Ctrl+Alt+Del热键处理（deferred_cad）、命令行执行（run_cmd）以及有序重启/关机的兜底方案（__orderly_reboot/__orderly_poweroff）。",
          "similarity": 0.5762214660644531
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/reboot.c",
          "start_line": 1219,
          "end_line": 1267,
          "content": [
            "static ssize_t cpu_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%d\\n\", reboot_cpu);",
            "}",
            "static ssize_t cpu_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t  const char *buf, size_t count)",
            "{",
            "\tunsigned int cpunum;",
            "\tint rc;",
            "",
            "\tif (!capable(CAP_SYS_BOOT))",
            "\t\treturn -EPERM;",
            "",
            "\trc = kstrtouint(buf, 0, &cpunum);",
            "",
            "\tif (rc)",
            "\t\treturn rc;",
            "",
            "\tif (cpunum >= num_possible_cpus())",
            "\t\treturn -ERANGE;",
            "",
            "\treboot_default = 0;",
            "\treboot_cpu = cpunum;",
            "",
            "\treturn count;",
            "}",
            "static void __init kernel_reboot_sysctls_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kern_reboot_table);",
            "}",
            "static int __init reboot_ksysfs_init(void)",
            "{",
            "\tstruct kobject *reboot_kobj;",
            "\tint ret;",
            "",
            "\treboot_kobj = kobject_create_and_add(\"reboot\", kernel_kobj);",
            "\tif (!reboot_kobj)",
            "\t\treturn -ENOMEM;",
            "",
            "\tret = sysfs_create_group(reboot_kobj, &reboot_attr_group);",
            "\tif (ret) {",
            "\t\tkobject_put(reboot_kobj);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tkernel_reboot_sysctls_init();",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "cpu_show, cpu_store, kernel_reboot_sysctls_init, reboot_ksysfs_init",
          "description": "实现了CPU重启控制(sysfs/cpu)及sysctl初始化逻辑，包含cpu参数读写接口与sysfs目录创建函数，用于指定特定CPU触发系统重启操作。",
          "similarity": 0.5413686633110046
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/reboot.c",
          "start_line": 74,
          "end_line": 181,
          "content": [
            "void emergency_restart(void)",
            "{",
            "\tkmsg_dump(KMSG_DUMP_EMERG);",
            "\tsystem_state = SYSTEM_RESTART;",
            "\tmachine_emergency_restart();",
            "}",
            "void kernel_restart_prepare(char *cmd)",
            "{",
            "\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);",
            "\tsystem_state = SYSTEM_RESTART;",
            "\tusermodehelper_disable();",
            "\tdevice_shutdown();",
            "}",
            "int register_reboot_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&reboot_notifier_list, nb);",
            "}",
            "int unregister_reboot_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);",
            "}",
            "static void devm_unregister_reboot_notifier(struct device *dev, void *res)",
            "{",
            "\tWARN_ON(unregister_reboot_notifier(*(struct notifier_block **)res));",
            "}",
            "int devm_register_reboot_notifier(struct device *dev, struct notifier_block *nb)",
            "{",
            "\tstruct notifier_block **rcnb;",
            "\tint ret;",
            "",
            "\trcnb = devres_alloc(devm_unregister_reboot_notifier,",
            "\t\t\t    sizeof(*rcnb), GFP_KERNEL);",
            "\tif (!rcnb)",
            "\t\treturn -ENOMEM;",
            "",
            "\tret = register_reboot_notifier(nb);",
            "\tif (!ret) {",
            "\t\t*rcnb = nb;",
            "\t\tdevres_add(dev, rcnb);",
            "\t} else {",
            "\t\tdevres_free(rcnb);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "int register_restart_handler(struct notifier_block *nb)",
            "{",
            "\treturn atomic_notifier_chain_register(&restart_handler_list, nb);",
            "}",
            "int unregister_restart_handler(struct notifier_block *nb)",
            "{",
            "\treturn atomic_notifier_chain_unregister(&restart_handler_list, nb);",
            "}",
            "void do_kernel_restart(char *cmd)",
            "{",
            "\tatomic_notifier_call_chain(&restart_handler_list, reboot_mode, cmd);",
            "}",
            "void migrate_to_reboot_cpu(void)",
            "{",
            "\t/* The boot cpu is always logical cpu 0 */",
            "\tint cpu = reboot_cpu;",
            "",
            "\tcpu_hotplug_disable();",
            "",
            "\t/* Make certain the cpu I'm about to reboot on is online */",
            "\tif (!cpu_online(cpu))",
            "\t\tcpu = cpumask_first(cpu_online_mask);",
            "",
            "\t/* Prevent races with other tasks migrating this task */",
            "\tcurrent->flags |= PF_NO_SETAFFINITY;",
            "",
            "\t/* Make certain I only run on the appropriate processor */",
            "\tset_cpus_allowed_ptr(current, cpumask_of(cpu));",
            "}",
            "static void do_kernel_restart_prepare(void)",
            "{",
            "\tblocking_notifier_call_chain(&restart_prep_handler_list, 0, NULL);",
            "}",
            "void kernel_restart(char *cmd)",
            "{",
            "\tkernel_restart_prepare(cmd);",
            "\tdo_kernel_restart_prepare();",
            "\tmigrate_to_reboot_cpu();",
            "\tsyscore_shutdown();",
            "\tif (!cmd)",
            "\t\tpr_emerg(\"Restarting system\\n\");",
            "\telse",
            "\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);",
            "\tkmsg_dump(KMSG_DUMP_SHUTDOWN);",
            "\tmachine_restart(cmd);",
            "}",
            "static void kernel_shutdown_prepare(enum system_states state)",
            "{",
            "\tblocking_notifier_call_chain(&reboot_notifier_list,",
            "\t\t(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, NULL);",
            "\tsystem_state = state;",
            "\tusermodehelper_disable();",
            "\tdevice_shutdown();",
            "}",
            "void kernel_halt(void)",
            "{",
            "\tkernel_shutdown_prepare(SYSTEM_HALT);",
            "\tmigrate_to_reboot_cpu();",
            "\tsyscore_shutdown();",
            "\tpr_emerg(\"System halted\\n\");",
            "\tkmsg_dump(KMSG_DUMP_SHUTDOWN);",
            "\tmachine_halt();",
            "}"
          ],
          "function_name": "emergency_restart, kernel_restart_prepare, register_reboot_notifier, unregister_reboot_notifier, devm_unregister_reboot_notifier, devm_register_reboot_notifier, register_restart_handler, unregister_restart_handler, do_kernel_restart, migrate_to_reboot_cpu, do_kernel_restart_prepare, kernel_restart, kernel_shutdown_prepare, kernel_halt",
          "description": "实现了系统重启、关机和休眠的准备逻辑，包含注册/注销重启通知链、迁移CPU到指定核心、执行设备关闭操作等功能。通过notifier_call_chain触发各阶段的回调处理。",
          "similarity": 0.5280896425247192
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/reboot.c",
          "start_line": 871,
          "end_line": 1010,
          "content": [
            "static void poweroff_work_func(struct work_struct *work)",
            "{",
            "\t__orderly_poweroff(poweroff_force);",
            "}",
            "void orderly_poweroff(bool force)",
            "{",
            "\tif (force) /* do not override the pending \"true\" */",
            "\t\tpoweroff_force = true;",
            "\tschedule_work(&poweroff_work);",
            "}",
            "static void reboot_work_func(struct work_struct *work)",
            "{",
            "\t__orderly_reboot();",
            "}",
            "void orderly_reboot(void)",
            "{",
            "\tschedule_work(&reboot_work);",
            "}",
            "static void hw_failure_emergency_poweroff_func(struct work_struct *work)",
            "{",
            "\t/*",
            "\t * We have reached here after the emergency shutdown waiting period has",
            "\t * expired. This means orderly_poweroff has not been able to shut off",
            "\t * the system for some reason.",
            "\t *",
            "\t * Try to shut down the system immediately using kernel_power_off",
            "\t * if populated",
            "\t */",
            "\tpr_emerg(\"Hardware protection timed-out. Trying forced poweroff\\n\");",
            "\tkernel_power_off();",
            "",
            "\t/*",
            "\t * Worst of the worst case trigger emergency restart",
            "\t */",
            "\tpr_emerg(\"Hardware protection shutdown failed. Trying emergency restart\\n\");",
            "\temergency_restart();",
            "}",
            "static void hw_failure_emergency_poweroff(int poweroff_delay_ms)",
            "{",
            "\tif (poweroff_delay_ms <= 0)",
            "\t\treturn;",
            "\tschedule_delayed_work(&hw_failure_emergency_poweroff_work,",
            "\t\t\t      msecs_to_jiffies(poweroff_delay_ms));",
            "}",
            "void hw_protection_shutdown(const char *reason, int ms_until_forced)",
            "{",
            "\tstatic atomic_t allow_proceed = ATOMIC_INIT(1);",
            "",
            "\tpr_emerg(\"HARDWARE PROTECTION shutdown (%s)\\n\", reason);",
            "",
            "\t/* Shutdown should be initiated only once. */",
            "\tif (!atomic_dec_and_test(&allow_proceed))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Queue a backup emergency shutdown in the event of",
            "\t * orderly_poweroff failure",
            "\t */",
            "\thw_failure_emergency_poweroff(ms_until_forced);",
            "\torderly_poweroff(true);",
            "}",
            "static int __init reboot_setup(char *str)",
            "{",
            "\tfor (;;) {",
            "\t\tenum reboot_mode *mode;",
            "",
            "\t\t/*",
            "\t\t * Having anything passed on the command line via",
            "\t\t * reboot= will cause us to disable DMI checking",
            "\t\t * below.",
            "\t\t */",
            "\t\treboot_default = 0;",
            "",
            "\t\tif (!strncmp(str, \"panic_\", 6)) {",
            "\t\t\tmode = &panic_reboot_mode;",
            "\t\t\tstr += 6;",
            "\t\t} else {",
            "\t\t\tmode = &reboot_mode;",
            "\t\t}",
            "",
            "\t\tswitch (*str) {",
            "\t\tcase 'w':",
            "\t\t\t*mode = REBOOT_WARM;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'c':",
            "\t\t\t*mode = REBOOT_COLD;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'h':",
            "\t\t\t*mode = REBOOT_HARD;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 's':",
            "\t\t\t/*",
            "\t\t\t * reboot_cpu is s[mp]#### with #### being the processor",
            "\t\t\t * to be used for rebooting. Skip 's' or 'smp' prefix.",
            "\t\t\t */",
            "\t\t\tstr += str[1] == 'm' && str[2] == 'p' ? 3 : 1;",
            "",
            "\t\t\tif (isdigit(str[0])) {",
            "\t\t\t\tint cpu = simple_strtoul(str, NULL, 0);",
            "",
            "\t\t\t\tif (cpu >= num_possible_cpus()) {",
            "\t\t\t\t\tpr_err(\"Ignoring the CPU number in reboot= option. \"",
            "\t\t\t\t\t\"CPU %d exceeds possible cpu number %d\\n\",",
            "\t\t\t\t\tcpu, num_possible_cpus());",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\treboot_cpu = cpu;",
            "\t\t\t} else",
            "\t\t\t\t*mode = REBOOT_SOFT;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'g':",
            "\t\t\t*mode = REBOOT_GPIO;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'b':",
            "\t\tcase 'a':",
            "\t\tcase 'k':",
            "\t\tcase 't':",
            "\t\tcase 'e':",
            "\t\tcase 'p':",
            "\t\t\treboot_type = *str;",
            "\t\t\tbreak;",
            "",
            "\t\tcase 'f':",
            "\t\t\treboot_force = 1;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tstr = strchr(str, ',');",
            "\t\tif (str)",
            "\t\t\tstr++;",
            "\t\telse",
            "\t\t\tbreak;",
            "\t}",
            "\treturn 1;",
            "}"
          ],
          "function_name": "poweroff_work_func, orderly_poweroff, reboot_work_func, orderly_reboot, hw_failure_emergency_poweroff_func, hw_failure_emergency_poweroff, hw_protection_shutdown, reboot_setup",
          "description": "通过工作队列实现延迟关机/重启操作（poweroff_work_func/reboot_work_func），处理硬件保护超时后的应急关机（hw_failure_emergency_poweroff_func），并通过reboot_setup解析内核命令行参数配置重启模式。",
          "similarity": 0.5214468240737915
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/reboot.c",
          "start_line": 1,
          "end_line": 73,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/reboot.c",
            " *",
            " *  Copyright (C) 2013  Linus Torvalds",
            " */",
            "",
            "#define pr_fmt(fmt)\t\"reboot: \" fmt",
            "",
            "#include <linux/atomic.h>",
            "#include <linux/ctype.h>",
            "#include <linux/export.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/uaccess.h>",
            "",
            "/*",
            " * this indicates whether you can reboot with ctrl-alt-del: the default is yes",
            " */",
            "",
            "static int C_A_D = 1;",
            "struct pid *cad_pid;",
            "EXPORT_SYMBOL(cad_pid);",
            "",
            "#if defined(CONFIG_ARM)",
            "#define DEFAULT_REBOOT_MODE\t\t= REBOOT_HARD",
            "#else",
            "#define DEFAULT_REBOOT_MODE",
            "#endif",
            "enum reboot_mode reboot_mode DEFAULT_REBOOT_MODE;",
            "EXPORT_SYMBOL_GPL(reboot_mode);",
            "enum reboot_mode panic_reboot_mode = REBOOT_UNDEFINED;",
            "",
            "/*",
            " * This variable is used privately to keep track of whether or not",
            " * reboot_type is still set to its default value (i.e., reboot= hasn't",
            " * been set on the command line).  This is needed so that we can",
            " * suppress DMI scanning for reboot quirks.  Without it, it's",
            " * impossible to override a faulty reboot quirk without recompiling.",
            " */",
            "int reboot_default = 1;",
            "int reboot_cpu;",
            "enum reboot_type reboot_type = BOOT_ACPI;",
            "int reboot_force;",
            "",
            "struct sys_off_handler {",
            "\tstruct notifier_block nb;",
            "\tint (*sys_off_cb)(struct sys_off_data *data);",
            "\tvoid *cb_data;",
            "\tenum sys_off_mode mode;",
            "\tbool blocking;",
            "\tvoid *list;",
            "};",
            "",
            "/*",
            " * Temporary stub that prevents linkage failure while we're in process",
            " * of removing all uses of legacy pm_power_off() around the kernel.",
            " */",
            "void __weak (*pm_power_off)(void);",
            "",
            "/**",
            " *\temergency_restart - reboot the system",
            " *",
            " *\tWithout shutting down any hardware or taking any locks",
            " *\treboot the system.  This is called when we know we are in",
            " *\ttrouble so this is our best effort to reboot.  This is",
            " *\tsafe to call in interrupt context.",
            " */"
          ],
          "function_name": null,
          "description": "定义了与系统重启相关的全局变量和枚举类型，包括重启模式（reboot_mode）、默认重启类型（reboot_type）以及用于跟踪重启处理器的变量（reboot_cpu）。声明了sys_off_handler结构体，用于管理系统关机回调函数。",
          "similarity": 0.4881476163864136
        }
      ]
    },
    {
      "source_file": "mm/mm_init.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:50:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mm_init.c`\n\n---\n\n# mm_init.c 技术文档\n\n## 1. 文件概述\n\n`mm_init.c` 是 Linux 内核内存管理子系统（Memory Management, MM）中的一个初始化和调试辅助文件。其主要作用包括：\n\n- 提供内存初始化过程的验证与调试功能（在 `CONFIG_DEBUG_MEMORY_INIT` 启用时）\n- 初始化内存相关的全局参数和 sysfs 接口\n- 解析内核启动命令行参数（如 `kernelcore` 和 `movablecore`），用于控制不可移动与可移动内存区域的分配策略\n- 在 SMP 系统中动态计算 `vm_committed_as` 的批处理阈值，以优化内存提交统计的性能\n\n该文件不直接参与页分配或虚拟内存管理的核心逻辑，而是为内存子系统的正确性验证、配置和可观测性提供支持。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `mminit_verify_zonelist()` | 验证并打印每个 NUMA 节点的 zonelist 结构，用于调试内存区域组织 |\n| `mminit_verify_pageflags_layout()` | 验证 `struct page` 中用于存储节点、区域、节区等元数据的位域布局是否无重叠且对齐正确 |\n| `set_mminit_loglevel()` | 解析 `mminit_loglevel` 内核参数，设置内存初始化调试日志级别 |\n| `mm_compute_batch()` | 根据系统内存总量和 CPU 数量，计算 `vm_committed_as` per-CPU 计数器的批处理阈值 |\n| `mm_compute_batch_notifier()` | 内存热插拔事件回调，重新计算 `vm_committed_as` 批处理值 |\n| `mm_sysfs_init()` | 创建 `/sys/kernel/mm` sysfs 目录，用于暴露内存子系统信息 |\n| `cmdline_parse_core()` | 辅助函数，解析带百分比或字节单位的内存大小参数 |\n| `cmdline_parse_kernelcore()` / `cmdline_parse_movablecore()` | 解析 `kernelcore=` 和 `movablecore=` 内核启动参数 |\n\n### 主要全局变量\n\n| 变量名 | 类型/说明 |\n|--------|---------|\n| `mminit_loglevel` | 调试日志级别（仅当 `CONFIG_DEBUG_MEMORY_INIT` 启用） |\n| `mm_kobj` | 指向 `/sys/kernel/mm` 的 kobject 指针 |\n| `vm_committed_as_batch` | `vm_committed_as` per-CPU 计数器的批处理阈值（SMP） |\n| `required_kernelcore` / `required_kernelcore_percent` | 用户指定的不可移动内存需求（页数或百分比） |\n| `required_movablecore` / `required_movablecore_percent` | 用户指定的可移动内存需求（页数或百分比） |\n| `mirrored_kernelcore` | 是否启用镜像式 kernelcore 布局 |\n| `arch_zone_lowest_possible_pfn[]` / `arch_zone_highest_possible_pfn[]` | 架构定义的各内存区域（ZONE）的 PFN 范围 |\n| `zone_movable_pfn[]` | 各 NUMA 节点上 ZONE_MOVABLE 的起始 PFN |\n| `deferred_struct_pages` | 标记是否延迟初始化 struct page 实例 |\n\n## 3. 关键实现\n\n### 3.1 内存初始化调试（`CONFIG_DEBUG_MEMORY_INIT`）\n\n- **Zonelist 验证**：`mminit_verify_zonelist()` 遍历所有在线 NUMA 节点，打印其“通用”（general）和“本节点优先”（thisnode）两种 zonelist 的组成，帮助开发者确认内存区域的 fallback 顺序是否符合预期。\n- **Page Flags 布局验证**：`mminit_verify_pageflags_layout()` 检查 `struct page` 中用于编码物理位置（section/node/zone）的位域是否：\n  - 总宽度不超过 `BITS_PER_LONG`\n  - 各字段偏移（`_PGSHIFT`）与宽度一致\n  - 位掩码无重叠（通过 `or_mask == add_mask` 验证）\n\n### 3.2 内存区域划分策略\n\n- 通过 `kernelcore=` 和 `movablecore=` 参数，用户可显式指定系统中用于**不可移动分配**（如内核数据结构）和**可移动分配**（如用户页、可迁移 slab）的内存大小。\n- 支持 `kernelcore=mirror` 模式，在支持内存镜像的平台上启用特殊布局。\n- 参数值可为绝对字节数（如 `512M`）或总内存百分比（如 `40%`）。\n\n### 3.3 `vm_committed_as` 批处理优化（SMP）\n\n- `vm_committed_as` 是一个 per-CPU 计数器，跟踪已提交虚拟内存总量。\n- 为减少原子操作开销，当本地计数器变化超过 `vm_committed_as_batch` 时才同步到全局值。\n- `mm_compute_batch()` 根据 overcommit 策略动态调整 batch 大小：\n  - `OVERCOMMIT_NEVER`：batch = 总内存 / CPU数 / 256（约 0.4%）\n  - 其他策略：batch = 总内存 / CPU数 / 4（25%）\n- 注册内存热插拔通知器，确保内存容量变化后重新计算 batch 值。\n\n### 3.4 Sysfs 接口初始化\n\n- `mm_sysfs_init()` 在内核早期创建 `/sys/kernel/mm` 目录，作为内存子系统其他模块（如 compaction、numa、transparent_hugepage 等）注册 sysfs 属性的基础。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memory.h>`、`<linux/memblock.h>`：内存块和热插拔管理\n  - `<linux/page-isolation.h>`、`<linux/cma.h>`：连续内存分配和页面隔离\n  - `\"internal.h\"`、`\"slab.h\"`：MM 子系统内部接口\n  - `<asm/setup.h>`：架构相关内存布局信息\n- **配置依赖**：\n  - `CONFIG_DEBUG_MEMORY_INIT`：启用调试验证功能\n  - `CONFIG_SMP`：启用 `vm_committed_as_batch` 优化\n  - `CONFIG_SYSFS`：支持 mm sysfs 目录创建\n- **被依赖模块**：\n  - 内存初始化流程（`mm_init()` in `init/main.c`）\n  - 页面分配器（`page_alloc.c`）使用 `zone_movable_pfn` 等变量\n  - 内存热插拔子系统调用 batch 重计算回调\n\n## 5. 使用场景\n\n- **内核开发与调试**：开发者启用 `CONFIG_DEBUG_MEMORY_INIT` 并设置 `mminit_loglevel`，可在启动时验证内存拓扑结构和 page 结构体布局的正确性。\n- **系统部署调优**：管理员通过 `kernelcore=` 或 `movablecore=` 参数，强制划分不可移动/可移动内存区域，以优化透明大页（THP）或避免内存碎片。\n- **高可靠性系统**：使用 `kernelcore=mirror` 在支持的硬件上启用内存镜像，提升容错能力。\n- **大规模 SMP 系统**：自动调整 `vm_committed_as_batch` 减少锁竞争，提升多进程内存密集型应用的性能。\n- **运行时监控**：`/sys/kernel/mm` 为用户空间工具（如 `numastat`、`cma` 调试接口）提供统一入口点。",
      "similarity": 0.5564312934875488,
      "chunks": [
        {
          "chunk_id": 17,
          "file_path": "mm/mm_init.c",
          "start_line": 2711,
          "end_line": 2806,
          "content": [
            "static void __init mem_init_print_info(void)",
            "{",
            "\tunsigned long physpages, codesize, datasize, rosize, bss_size;",
            "\tunsigned long init_code_size, init_data_size;",
            "",
            "\tphyspages = get_num_physpages();",
            "\tcodesize = _etext - _stext;",
            "\tdatasize = _edata - _sdata;",
            "\trosize = __end_rodata - __start_rodata;",
            "\tbss_size = __bss_stop - __bss_start;",
            "\tinit_data_size = __init_end - __init_begin;",
            "\tinit_code_size = _einittext - _sinittext;",
            "",
            "\t/*",
            "\t * Detect special cases and adjust section sizes accordingly:",
            "\t * 1) .init.* may be embedded into .data sections",
            "\t * 2) .init.text.* may be out of [__init_begin, __init_end],",
            "\t *    please refer to arch/tile/kernel/vmlinux.lds.S.",
            "\t * 3) .rodata.* may be embedded into .text or .data sections.",
            "\t */",
            "#define adj_init_size(start, end, size, pos, adj) \\",
            "\tdo { \\",
            "\t\tif (&start[0] <= &pos[0] && &pos[0] < &end[0] && size > adj) \\",
            "\t\t\tsize -= adj; \\",
            "\t} while (0)",
            "",
            "\tadj_init_size(__init_begin, __init_end, init_data_size,",
            "\t\t     _sinittext, init_code_size);",
            "\tadj_init_size(_stext, _etext, codesize, _sinittext, init_code_size);",
            "\tadj_init_size(_sdata, _edata, datasize, __init_begin, init_data_size);",
            "\tadj_init_size(_stext, _etext, codesize, __start_rodata, rosize);",
            "\tadj_init_size(_sdata, _edata, datasize, __start_rodata, rosize);",
            "",
            "#undef\tadj_init_size",
            "",
            "\tpr_info(\"Memory: %luK/%luK available (%luK kernel code, %luK rwdata, %luK rodata, %luK init, %luK bss, %luK reserved, %luK cma-reserved\"",
            "#ifdef\tCONFIG_HIGHMEM",
            "\t\t\", %luK highmem\"",
            "#endif",
            "\t\t\")\\n\",",
            "\t\tK(nr_free_pages()), K(physpages),",
            "\t\tcodesize / SZ_1K, datasize / SZ_1K, rosize / SZ_1K,",
            "\t\t(init_data_size + init_code_size) / SZ_1K, bss_size / SZ_1K,",
            "\t\tK(physpages - totalram_pages() - totalcma_pages),",
            "\t\tK(totalcma_pages)",
            "#ifdef\tCONFIG_HIGHMEM",
            "\t\t, K(totalhigh_pages())",
            "#endif",
            "\t\t);",
            "}",
            "void __init mm_core_init(void)",
            "{",
            "\t/* Initializations relying on SMP setup */",
            "\tbuild_all_zonelists(NULL);",
            "\tpage_alloc_init_cpuhp();",
            "",
            "\t/*",
            "\t * page_ext requires contiguous pages,",
            "\t * bigger than MAX_PAGE_ORDER unless SPARSEMEM.",
            "\t */",
            "\tpage_ext_init_flatmem();",
            "\tmem_debugging_and_hardening_init();",
            "\tkfence_alloc_pool_and_metadata();",
            "\treport_meminit();",
            "\tkmsan_init_shadow();",
            "\tstack_depot_early_init();",
            "",
            "\t/*",
            "\t * KHO memory setup must happen while memblock is still active, but",
            "\t * as close as possible to buddy initialization",
            "\t */",
            "\tkho_memory_init();",
            "",
            "\tmem_init();",
            "\tmem_init_print_info();",
            "\tkmem_cache_init();",
            "\t/*",
            "\t * page_owner must be initialized after buddy is ready, and also after",
            "\t * slab is ready so that stack_depot_init() works properly",
            "\t */",
            "\tpage_ext_init_flatmem_late();",
            "\tkmemleak_init();",
            "\tptlock_cache_init();",
            "\tpgtable_cache_init();",
            "\tdebug_objects_mem_init();",
            "\tvmalloc_init();",
            "\t/* If no deferred init page_ext now, as vmap is fully initialized */",
            "\tif (!deferred_struct_pages)",
            "\t\tpage_ext_init();",
            "\t/* Should be run before the first non-init thread is created */",
            "\tinit_espfix_bsp();",
            "\t/* Should be run after espfix64 is set up. */",
            "\tpti_init();",
            "\tkmsan_init_runtime();",
            "\tmm_cache_init();",
            "}"
          ],
          "function_name": "mem_init_print_info, mm_core_init",
          "description": "mem_init_print_info计算并打印内存统计信息，包括可用页面数、各段代码数据大小及保留区域。mm_core_init初始化内存核心组件，构建zonelists，初始化slab/kmem_cache，启用调试对象跟踪，设置虚拟内存管理，最后根据是否延迟结构页初始化page_ext模块。",
          "similarity": 0.5602084398269653
        },
        {
          "chunk_id": 6,
          "file_path": "mm/mm_init.c",
          "start_line": 912,
          "end_line": 1017,
          "content": [
            "static void __init memmap_init_zone_range(struct zone *zone,",
            "\t\t\t\t\t  unsigned long start_pfn,",
            "\t\t\t\t\t  unsigned long end_pfn,",
            "\t\t\t\t\t  unsigned long *hole_pfn)",
            "{",
            "\tunsigned long zone_start_pfn = zone->zone_start_pfn;",
            "\tunsigned long zone_end_pfn = zone_start_pfn + zone->spanned_pages;",
            "\tint nid = zone_to_nid(zone), zone_id = zone_idx(zone);",
            "",
            "\tstart_pfn = clamp(start_pfn, zone_start_pfn, zone_end_pfn);",
            "\tend_pfn = clamp(end_pfn, zone_start_pfn, zone_end_pfn);",
            "",
            "\tif (start_pfn >= end_pfn)",
            "\t\treturn;",
            "",
            "\tmemmap_init_range(end_pfn - start_pfn, nid, zone_id, start_pfn,",
            "\t\t\t  zone_end_pfn, MEMINIT_EARLY, NULL, MIGRATE_MOVABLE);",
            "",
            "\tif (*hole_pfn < start_pfn)",
            "\t\tinit_unavailable_range(*hole_pfn, start_pfn, zone_id, nid);",
            "",
            "\t*hole_pfn = end_pfn;",
            "}",
            "static void __init memmap_init(void)",
            "{",
            "\tunsigned long start_pfn, end_pfn;",
            "\tunsigned long hole_pfn = 0;",
            "\tint i, j, zone_id = 0, nid;",
            "",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {",
            "\t\tstruct pglist_data *node = NODE_DATA(nid);",
            "",
            "\t\tfor (j = 0; j < MAX_NR_ZONES; j++) {",
            "\t\t\tstruct zone *zone = node->node_zones + j;",
            "",
            "\t\t\tif (!populated_zone(zone))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tmemmap_init_zone_range(zone, start_pfn, end_pfn,",
            "\t\t\t\t\t       &hole_pfn);",
            "\t\t\tzone_id = j;",
            "\t\t}",
            "\t}",
            "",
            "#ifdef CONFIG_SPARSEMEM",
            "\t/*",
            "\t * Initialize the memory map for hole in the range [memory_end,",
            "\t * section_end].",
            "\t * Append the pages in this hole to the highest zone in the last",
            "\t * node.",
            "\t * The call to init_unavailable_range() is outside the ifdef to",
            "\t * silence the compiler warining about zone_id set but not used;",
            "\t * for FLATMEM it is a nop anyway",
            "\t */",
            "\tend_pfn = round_up(end_pfn, PAGES_PER_SECTION);",
            "\tif (hole_pfn < end_pfn)",
            "#endif",
            "\t\tinit_unavailable_range(hole_pfn, end_pfn, zone_id, nid);",
            "}",
            "static void __ref __init_zone_device_page(struct page *page, unsigned long pfn,",
            "\t\t\t\t\t  unsigned long zone_idx, int nid,",
            "\t\t\t\t\t  struct dev_pagemap *pgmap)",
            "{",
            "",
            "\t__init_single_page(page, pfn, zone_idx, nid);",
            "",
            "\t/*",
            "\t * Mark page reserved as it will need to wait for onlining",
            "\t * phase for it to be fully associated with a zone.",
            "\t *",
            "\t * We can use the non-atomic __set_bit operation for setting",
            "\t * the flag as we are still initializing the pages.",
            "\t */",
            "\t__SetPageReserved(page);",
            "",
            "\t/*",
            "\t * ZONE_DEVICE pages union ->lru with a ->pgmap back pointer",
            "\t * and zone_device_data.  It is a bug if a ZONE_DEVICE page is",
            "\t * ever freed or placed on a driver-private list.",
            "\t */",
            "\tpage->pgmap = pgmap;",
            "\tpage->zone_device_data = NULL;",
            "",
            "\t/*",
            "\t * Mark the block movable so that blocks are reserved for",
            "\t * movable at startup. This will force kernel allocations",
            "\t * to reserve their blocks rather than leaking throughout",
            "\t * the address space during boot when many long-lived",
            "\t * kernel allocations are made.",
            "\t *",
            "\t * Please note that MEMINIT_HOTPLUG path doesn't clear memmap",
            "\t * because this is done early in section_activate()",
            "\t */",
            "\tif (pageblock_aligned(pfn)) {",
            "\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\t/*",
            "\t * ZONE_DEVICE pages are released directly to the driver page allocator",
            "\t * which will set the page count to 1 when allocating the page.",
            "\t */",
            "\tif (pgmap->type == MEMORY_DEVICE_PRIVATE ||",
            "\t    pgmap->type == MEMORY_DEVICE_COHERENT)",
            "\t\tset_page_count(page, 0);",
            "}"
          ],
          "function_name": "memmap_init_zone_range, memmap_init, __init_zone_device_page",
          "description": "遍历各节点和区，调用memmap_init_range初始化内存映射，处理稀疏内存中洞的不可用范围，并调整ZONE_MOVABLE范围以适应架构需求。",
          "similarity": 0.5570640563964844
        },
        {
          "chunk_id": 16,
          "file_path": "mm/mm_init.c",
          "start_line": 2425,
          "end_line": 2546,
          "content": [
            "static unsigned long __init arch_reserved_kernel_pages(void)",
            "{",
            "\treturn 0;",
            "}",
            "void __init set_dma_reserve(unsigned long new_dma_reserve)",
            "{",
            "\tdma_reserve = new_dma_reserve;",
            "}",
            "void __init memblock_free_pages(struct page *page, unsigned long pfn,",
            "\t\t\t\t\t\t\tunsigned int order)",
            "{",
            "\tif (IS_ENABLED(CONFIG_DEFERRED_STRUCT_PAGE_INIT)) {",
            "\t\tint nid = early_pfn_to_nid(pfn);",
            "",
            "\t\tif (!early_page_initialised(pfn, nid))",
            "\t\t\treturn;",
            "\t}",
            "",
            "\tif (!kmsan_memblock_free_pages(page, order)) {",
            "\t\t/* KMSAN will take care of these pages. */",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* pages were reserved and not allocated */",
            "\tclear_page_tag_ref(page);",
            "\t__free_pages_core(page, order, MEMINIT_EARLY);",
            "}",
            "static int __init early_init_on_alloc(char *buf)",
            "{",
            "",
            "\treturn kstrtobool(buf, &_init_on_alloc_enabled_early);",
            "}",
            "static int __init early_init_on_free(char *buf)",
            "{",
            "\treturn kstrtobool(buf, &_init_on_free_enabled_early);",
            "}",
            "static void __init mem_debugging_and_hardening_init(void)",
            "{",
            "\tbool page_poisoning_requested = false;",
            "\tbool want_check_pages = false;",
            "",
            "#ifdef CONFIG_PAGE_POISONING",
            "\t/*",
            "\t * Page poisoning is debug page alloc for some arches. If",
            "\t * either of those options are enabled, enable poisoning.",
            "\t */",
            "\tif (page_poisoning_enabled() ||",
            "\t     (!IS_ENABLED(CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC) &&",
            "\t      debug_pagealloc_enabled())) {",
            "\t\tstatic_branch_enable(&_page_poisoning_enabled);",
            "\t\tpage_poisoning_requested = true;",
            "\t\twant_check_pages = true;",
            "\t}",
            "#endif",
            "",
            "\tif ((_init_on_alloc_enabled_early || _init_on_free_enabled_early) &&",
            "\t    page_poisoning_requested) {",
            "\t\tpr_info(\"mem auto-init: CONFIG_PAGE_POISONING is on, \"",
            "\t\t\t\"will take precedence over init_on_alloc and init_on_free\\n\");",
            "\t\t_init_on_alloc_enabled_early = false;",
            "\t\t_init_on_free_enabled_early = false;",
            "\t}",
            "",
            "\tif (_init_on_alloc_enabled_early) {",
            "\t\twant_check_pages = true;",
            "\t\tstatic_branch_enable(&init_on_alloc);",
            "\t} else {",
            "\t\tstatic_branch_disable(&init_on_alloc);",
            "\t}",
            "",
            "\tif (_init_on_free_enabled_early) {",
            "\t\twant_check_pages = true;",
            "\t\tstatic_branch_enable(&init_on_free);",
            "\t} else {",
            "\t\tstatic_branch_disable(&init_on_free);",
            "\t}",
            "",
            "\tif (IS_ENABLED(CONFIG_KMSAN) &&",
            "\t    (_init_on_alloc_enabled_early || _init_on_free_enabled_early))",
            "\t\tpr_info(\"mem auto-init: please make sure init_on_alloc and init_on_free are disabled when running KMSAN\\n\");",
            "",
            "#ifdef CONFIG_DEBUG_PAGEALLOC",
            "\tif (debug_pagealloc_enabled()) {",
            "\t\twant_check_pages = true;",
            "\t\tstatic_branch_enable(&_debug_pagealloc_enabled);",
            "",
            "\t\tif (debug_guardpage_minorder())",
            "\t\t\tstatic_branch_enable(&_debug_guardpage_enabled);",
            "\t}",
            "#endif",
            "",
            "\t/*",
            "\t * Any page debugging or hardening option also enables sanity checking",
            "\t * of struct pages being allocated or freed. With CONFIG_DEBUG_VM it's",
            "\t * enabled already.",
            "\t */",
            "\tif (!IS_ENABLED(CONFIG_DEBUG_VM) && want_check_pages)",
            "\t\tstatic_branch_enable(&check_pages_enabled);",
            "}",
            "static void __init report_meminit(void)",
            "{",
            "\tconst char *stack;",
            "",
            "\tif (IS_ENABLED(CONFIG_INIT_STACK_ALL_PATTERN))",
            "\t\tstack = \"all(pattern)\";",
            "\telse if (IS_ENABLED(CONFIG_INIT_STACK_ALL_ZERO))",
            "\t\tstack = \"all(zero)\";",
            "\telse if (IS_ENABLED(CONFIG_GCC_PLUGIN_STRUCTLEAK_BYREF_ALL))",
            "\t\tstack = \"byref_all(zero)\";",
            "\telse if (IS_ENABLED(CONFIG_GCC_PLUGIN_STRUCTLEAK_BYREF))",
            "\t\tstack = \"byref(zero)\";",
            "\telse if (IS_ENABLED(CONFIG_GCC_PLUGIN_STRUCTLEAK_USER))",
            "\t\tstack = \"__user(zero)\";",
            "\telse",
            "\t\tstack = \"off\";",
            "",
            "\tpr_info(\"mem auto-init: stack:%s, heap alloc:%s, heap free:%s\\n\",",
            "\t\tstack, want_init_on_alloc(GFP_KERNEL) ? \"on\" : \"off\",",
            "\t\twant_init_on_free() ? \"on\" : \"off\");",
            "\tif (want_init_on_free())",
            "\t\tpr_info(\"mem auto-init: clearing system memory may take some time...\\n\");",
            "}"
          ],
          "function_name": "arch_reserved_kernel_pages, set_dma_reserve, memblock_free_pages, early_init_on_alloc, early_init_on_free, mem_debugging_and_hardening_init, report_meminit",
          "description": "arch_reserved_kernel_pages返回0表示无内核保留物理页。set_dma_reserve设置DMA保留页面数量。memblock_free_pages释放早期分配的内存块，清除保留标记并调用底层释放函数。early_init_on_alloc/early_init_on_free控制早期内存初始化开关。mem_debugging_and_hardening_init启用页面毒化、堆检查等安全机制，优先级高于早期初始化选项。report_meminit打印内存自动初始化配置信息。",
          "similarity": 0.5402158498764038
        },
        {
          "chunk_id": 2,
          "file_path": "mm/mm_init.c",
          "start_line": 151,
          "end_line": 259,
          "content": [
            "static __init int set_mminit_loglevel(char *str)",
            "{",
            "\tget_option(&str, &mminit_loglevel);",
            "\treturn 0;",
            "}",
            "void mm_compute_batch(int overcommit_policy)",
            "{",
            "\tu64 memsized_batch;",
            "\ts32 nr = num_present_cpus();",
            "\ts32 batch = max_t(s32, nr*2, 32);",
            "\tunsigned long ram_pages = totalram_pages();",
            "",
            "\t/*",
            "\t * For policy OVERCOMMIT_NEVER, set batch size to 0.4% of",
            "\t * (total memory/#cpus), and lift it to 25% for other policies",
            "\t * to easy the possible lock contention for percpu_counter",
            "\t * vm_committed_as, while the max limit is INT_MAX",
            "\t */",
            "\tif (overcommit_policy == OVERCOMMIT_NEVER)",
            "\t\tmemsized_batch = min_t(u64, ram_pages/nr/256, INT_MAX);",
            "\telse",
            "\t\tmemsized_batch = min_t(u64, ram_pages/nr/4, INT_MAX);",
            "",
            "\tvm_committed_as_batch = max_t(s32, memsized_batch, batch);",
            "}",
            "static int __meminit mm_compute_batch_notifier(struct notifier_block *self,",
            "\t\t\t\t\tunsigned long action, void *arg)",
            "{",
            "\tswitch (action) {",
            "\tcase MEM_ONLINE:",
            "\tcase MEM_OFFLINE:",
            "\t\tmm_compute_batch(sysctl_overcommit_memory);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "\treturn NOTIFY_OK;",
            "}",
            "static int __init mm_compute_batch_init(void)",
            "{",
            "\tmm_compute_batch(sysctl_overcommit_memory);",
            "\thotplug_memory_notifier(mm_compute_batch_notifier, MM_COMPUTE_BATCH_PRI);",
            "\treturn 0;",
            "}",
            "static int __init mm_sysfs_init(void)",
            "{",
            "\tmm_kobj = kobject_create_and_add(\"mm\", kernel_kobj);",
            "\tif (!mm_kobj)",
            "\t\treturn -ENOMEM;",
            "",
            "\treturn 0;",
            "}",
            "static int __init cmdline_parse_core(char *p, unsigned long *core,",
            "\t\t\t\t     unsigned long *percent)",
            "{",
            "\tunsigned long long coremem;",
            "\tchar *endptr;",
            "",
            "\tif (!p)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Value may be a percentage of total memory, otherwise bytes */",
            "\tcoremem = simple_strtoull(p, &endptr, 0);",
            "\tif (*endptr == '%') {",
            "\t\t/* Paranoid check for percent values greater than 100 */",
            "\t\tWARN_ON(coremem > 100);",
            "",
            "\t\t*percent = coremem;",
            "\t} else {",
            "\t\tcoremem = memparse(p, &p);",
            "\t\t/* Paranoid check that UL is enough for the coremem value */",
            "\t\tWARN_ON((coremem >> PAGE_SHIFT) > ULONG_MAX);",
            "",
            "\t\t*core = coremem >> PAGE_SHIFT;",
            "\t\t*percent = 0UL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int __init cmdline_parse_kernelcore(char *p)",
            "{",
            "\t/* parse kernelcore=mirror */",
            "\tif (parse_option_str(p, \"mirror\")) {",
            "\t\tmirrored_kernelcore = true;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn cmdline_parse_core(p, &required_kernelcore,",
            "\t\t\t\t  &required_kernelcore_percent);",
            "}",
            "static int __init cmdline_parse_movablecore(char *p)",
            "{",
            "\treturn cmdline_parse_core(p, &required_movablecore,",
            "\t\t\t\t  &required_movablecore_percent);",
            "}",
            "static unsigned long __init early_calculate_totalpages(void)",
            "{",
            "\tunsigned long totalpages = 0;",
            "\tunsigned long start_pfn, end_pfn;",
            "\tint i, nid;",
            "",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {",
            "\t\tunsigned long pages = end_pfn - start_pfn;",
            "",
            "\t\ttotalpages += pages;",
            "\t\tif (pages)",
            "\t\t\tnode_set_state(nid, N_MEMORY);",
            "\t}",
            "\treturn totalpages;",
            "}"
          ],
          "function_name": "set_mminit_loglevel, mm_compute_batch, mm_compute_batch_notifier, mm_compute_batch_init, mm_sysfs_init, cmdline_parse_core, cmdline_parse_kernelcore, cmdline_parse_movablecore, early_calculate_totalpages",
          "description": "初始化内存批次计算逻辑，注册内存变化通知回调，解析命令行参数以确定内核核心和可移动内存需求",
          "similarity": 0.5285018086433411
        },
        {
          "chunk_id": 4,
          "file_path": "mm/mm_init.c",
          "start_line": 566,
          "end_line": 671,
          "content": [
            "void __meminit __init_single_page(struct page *page, unsigned long pfn,",
            "\t\t\t\tunsigned long zone, int nid)",
            "{",
            "\tmm_zero_struct_page(page);",
            "\tset_page_links(page, zone, nid, pfn);",
            "\tinit_page_count(page);",
            "\tpage_mapcount_reset(page);",
            "\tpage_cpupid_reset_last(page);",
            "\tpage_kasan_tag_reset(page);",
            "",
            "\tINIT_LIST_HEAD(&page->lru);",
            "#ifdef WANT_PAGE_VIRTUAL",
            "\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */",
            "\tif (!is_highmem_idx(zone))",
            "\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));",
            "#endif",
            "}",
            "static int __meminit __early_pfn_to_nid(unsigned long pfn,",
            "\t\t\t\t\tstruct mminit_pfnnid_cache *state)",
            "{",
            "\tunsigned long start_pfn, end_pfn;",
            "\tint nid;",
            "",
            "\tif (state->last_start <= pfn && pfn < state->last_end)",
            "\t\treturn state->last_nid;",
            "",
            "\tnid = memblock_search_pfn_nid(pfn, &start_pfn, &end_pfn);",
            "\tif (nid != NUMA_NO_NODE) {",
            "\t\tstate->last_start = start_pfn;",
            "\t\tstate->last_end = end_pfn;",
            "\t\tstate->last_nid = nid;",
            "\t}",
            "",
            "\treturn nid;",
            "}",
            "int __meminit early_pfn_to_nid(unsigned long pfn)",
            "{",
            "\tstatic DEFINE_SPINLOCK(early_pfn_lock);",
            "\tint nid;",
            "",
            "\tspin_lock(&early_pfn_lock);",
            "\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);",
            "\tif (nid < 0)",
            "\t\tnid = first_online_node;",
            "\tspin_unlock(&early_pfn_lock);",
            "",
            "\treturn nid;",
            "}",
            "static int __init set_hashdist(char *str)",
            "{",
            "\tif (!str)",
            "\t\treturn 0;",
            "\thashdist = simple_strtoul(str, &str, 0);",
            "\treturn 1;",
            "}",
            "static inline void fixup_hashdist(void)",
            "{",
            "\tif (num_node_state(N_MEMORY) == 1)",
            "\t\thashdist = 0;",
            "}",
            "static inline void fixup_hashdist(void) {}",
            "static inline void pgdat_set_deferred_range(pg_data_t *pgdat)",
            "{",
            "\tpgdat->first_deferred_pfn = ULONG_MAX;",
            "}",
            "static inline bool __meminit early_page_initialised(unsigned long pfn, int nid)",
            "{",
            "\tif (node_online(nid) && pfn >= NODE_DATA(nid)->first_deferred_pfn)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static bool __meminit",
            "defer_init(int nid, unsigned long pfn, unsigned long end_pfn)",
            "{",
            "\tstatic unsigned long prev_end_pfn, nr_initialised;",
            "",
            "\tif (early_page_ext_enabled())",
            "\t\treturn false;",
            "\t/*",
            "\t * prev_end_pfn static that contains the end of previous zone",
            "\t * No need to protect because called very early in boot before smp_init.",
            "\t */",
            "\tif (prev_end_pfn != end_pfn) {",
            "\t\tprev_end_pfn = end_pfn;",
            "\t\tnr_initialised = 0;",
            "\t}",
            "",
            "\t/* Always populate low zones for address-constrained allocations */",
            "\tif (end_pfn < pgdat_end_pfn(NODE_DATA(nid)))",
            "\t\treturn false;",
            "",
            "\tif (NODE_DATA(nid)->first_deferred_pfn != ULONG_MAX)",
            "\t\treturn true;",
            "\t/*",
            "\t * We start only with one section of pages, more pages are added as",
            "\t * needed until the rest of deferred pages are initialized.",
            "\t */",
            "\tnr_initialised++;",
            "\tif ((nr_initialised > PAGES_PER_SECTION) &&",
            "\t    (pfn & (PAGES_PER_SECTION - 1)) == 0) {",
            "\t\tNODE_DATA(nid)->first_deferred_pfn = pfn;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}"
          ],
          "function_name": "__init_single_page, __early_pfn_to_nid, early_pfn_to_nid, set_hashdist, fixup_hashdist, fixup_hashdist, pgdat_set_deferred_range, early_page_initialised, defer_init",
          "description": "初始化单页数据结构，实现PFN到节点ID映射，控制延迟初始化页面范围以优化早期启动性能",
          "similarity": 0.5257990956306458
        }
      ]
    },
    {
      "source_file": "mm/kmsan/init.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:29:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kmsan\\init.c`\n\n---\n\n# `kmsan/init.c` 技术文档\n\n## 1. 文件概述\n\n`kmsan/init.c` 是 Linux 内核中 **KernelMemorySanitizer (KMSAN)** 调试工具的初始化模块。该文件负责在内核启动早期阶段为已存在的内存区域（如内核代码段、数据段、节点描述符 NODE_DATA 等）分配并初始化影子（shadow）和来源（origin）元数据页，并管理 memblock 分配器向伙伴系统移交页面时的元数据预分配策略。其目标是确保 KMSAN 能够追踪所有内核内存的初始化状态，从而检测未初始化内存的使用。\n\n## 2. 核心功能\n\n### 主要函数\n- `kmsan_record_future_shadow_range(void *start, void *end)`  \n  记录一个将在稍后（slab 初始化后）为其分配元数据的内存范围，并尝试与已有范围合并以减少碎片。\n  \n- `kmsan_init_shadow(void)`  \n  在内核初始化早期调用，收集需要初始化元数据的内存区域（包括保留内存、`.data` 段、NODE_DATA 等），并为这些区域分配影子和来源元数据。\n\n- `kmsan_memblock_free_pages(struct page *page, unsigned int order)`  \n  在 memblock 将大块连续物理页释放给伙伴系统时，拦截这些页面，按“三取一”策略：每三块同阶页面中，两块用作元数据（shadow + origin），一块作为被监控的数据页。\n\n- `kmsan_memblock_discard(void)`  \n  在 memblock 生命周期结束前，处理 `held_back[]` 中剩余的未配对元数据页，通过递归拆分和重新组合，尽可能为剩余数据页分配元数据，并将无法使用的页面归还系统。\n\n- `kmsan_init_runtime(void)`  \n  完成 KMSAN 的运行时初始化：为 init_task 创建任务上下文、清理残留元数据、启用 KMSAN 全局开关，并打印警告信息。\n\n### 主要数据结构\n- `struct start_end_pair`  \n  表示一个待分配元数据的虚拟地址范围（对齐到页边界）。\n\n- `struct metadata_page_pair`  \n  存储一对用于元数据的物理页：`shadow`（影子页，记录字节是否初始化）和 `origin`（来源页，记录未初始化值的来源信息）。\n\n- `struct smallstack`  \n  一个轻量级栈结构，用于在 `kmsan_memblock_discard()` 中暂存不同阶的页面块，支持按需拆分和重组。\n\n## 3. 关键实现\n\n### 内存范围合并机制\n`kmsan_record_future_shadow_range()` 在记录新范围前会遍历已有范围列表，若发现重叠或相邻，则合并为一个更大的连续范围。由于内核早期注册的范围数量有限（<20），采用线性扫描即可高效完成合并，避免元数据分配碎片化。\n\n### “三取一”元数据预分配策略\n在 `kmsan_memblock_free_pages()` 中，KMSAN 利用 memblock 向伙伴系统移交页面的时机，实施一种**贪婪但高效的元数据预留机制**：\n- 对于每个页面阶 `order`，维护一个 `held_back[order]` 缓存。\n- 前两次收到同阶页面块时，分别暂存为 shadow 和 origin。\n- 第三次收到时，将前两块作为元数据分配给第三块，并清空缓存供后续复用。\n- 此策略确保约 2/3 的释放内存被用作元数据，1/3 作为有效数据页，满足 KMSAN 对元数据空间的高需求。\n\n### 残留元数据回收（`kmsan_memblock_discard`）\n当 memblock 生命周期结束时，`held_back[]` 中可能残留未配对的 shadow 或 origin 页面。`kmsan_memblock_discard()` 采用**自顶向下递归拆分**策略：\n1. 从最大阶（`MAX_PAGE_ORDER`）开始，将所有残留页面压入 `collect` 栈。\n2. 若栈中元素 ≥3，则弹出三个页面，按“shadow + origin → data”方式完成一次元数据绑定，并将 data 页归还伙伴系统。\n3. 若栈中元素 <3，则将每个页面**拆分为两个低一阶的页面**，压入新栈，继续处理。\n4. 重复上述过程直至最小阶（0 阶），最大化利用残留内存。\n\n### 初始化流程整合\n- `kmsan_init_shadow()` 在 slab 初始化前运行，依赖 `memblock` 和 `phys_to_virt`，为静态内核内存分配元数据。\n- `kmsan_init_runtime()` 在伙伴系统完全就绪后调用，完成任务上下文初始化、残留清理，并最终启用 KMSAN。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `kmsan.h`：KMSAN 核心接口和宏定义（如 `KMSAN_WARN_ON`）。\n  - `<asm/sections.h>`：获取内核符号地址（如 `_sdata`, `_edata`）。\n  - `<linux/mm.h>`, `<linux/memblock.h>`：内存管理基础 API（`phys_to_virt`, `memblock` 遍历等）。\n  - `\"../internal.h\"`：KMSAN 内部实现细节（如 `kmsan_setup_meta`, `kmsan_init_alloc_meta_for_range`）。\n\n- **功能依赖**：\n  - 依赖 **memblock 分配器** 在早期内存管理中的行为。\n  - 依赖 **伙伴系统（buddy allocator）** 接管页面后的正常运作。\n  - 依赖 **percpu、NUMA NODE_DATA** 等子系统的初始化顺序（需在其注册内存范围后再调用 `kmsan_init_shadow`）。\n\n## 5. 使用场景\n\n- **内核启动早期**：在 `start_kernel()` 流程中，于 `mm_init()` 之前调用 `kmsan_init_shadow()`，为内核静态数据分配元数据。\n- **memblock 释放页面时**：每当 `memblock_free_pages()` 被调用（通常在 `free_all_bootmem()` 中），KMSAN 拦截页面释放流程，执行元数据预留。\n- **内核初始化尾声**：在 `rest_init()` 之前调用 `kmsan_init_runtime()`，完成 KMSAN 的最终激活。\n- **调试场景**：仅在启用 `CONFIG_KMSAN` 编译选项的内核中生效，用于检测内核中因未初始化内存导致的安全漏洞或逻辑错误，**严禁在生产环境使用**。",
      "similarity": 0.5534512400627136,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/kmsan/init.c",
          "start_line": 201,
          "end_line": 234,
          "content": [
            "static void kmsan_memblock_discard(void)",
            "{",
            "\t/*",
            "\t * For each order=N:",
            "\t *  - push held_back[N].shadow and .origin to @collect;",
            "\t *  - while there are >= 3 elements in @collect, do garbage collection:",
            "\t *    - pop 3 ranges from @collect;",
            "\t *    - use two of them as shadow and origin for the third one;",
            "\t *    - repeat;",
            "\t *  - split each remaining element from @collect into 2 ranges of",
            "\t *    order=N-1,",
            "\t *  - repeat.",
            "\t */",
            "\tcollect.order = MAX_PAGE_ORDER;",
            "\tfor (int i = MAX_PAGE_ORDER; i >= 0; i--) {",
            "\t\tif (held_back[i].shadow)",
            "\t\t\tsmallstack_push(&collect, held_back[i].shadow);",
            "\t\tif (held_back[i].origin)",
            "\t\t\tsmallstack_push(&collect, held_back[i].origin);",
            "\t\theld_back[i].shadow = NULL;",
            "\t\theld_back[i].origin = NULL;",
            "\t\tdo_collection();",
            "\t\tcollect_split();",
            "\t}",
            "}",
            "void __init kmsan_init_runtime(void)",
            "{",
            "\t/* Assuming current is init_task */",
            "\tkmsan_internal_task_create(current);",
            "\tkmsan_memblock_discard();",
            "\tpr_info(\"Starting KernelMemorySanitizer\\n\");",
            "\tpr_info(\"ATTENTION: KMSAN is a debugging tool! Do not use it on production machines!\\n\");",
            "\tkmsan_enabled = true;",
            "}"
          ],
          "function_name": "kmsan_memblock_discard, kmsan_init_runtime",
          "description": "执行内存块清理操作，通过小栈收集并处理不同阶序的页面资源，完成KMSAN运行时环境初始化与启用",
          "similarity": 0.5515851974487305
        },
        {
          "chunk_id": 1,
          "file_path": "mm/kmsan/init.c",
          "start_line": 30,
          "end_line": 141,
          "content": [
            "static void __init kmsan_record_future_shadow_range(void *start, void *end)",
            "{",
            "\tu64 nstart = (u64)start, nend = (u64)end, cstart, cend;",
            "\tbool merged = false;",
            "",
            "\tKMSAN_WARN_ON(future_index == NUM_FUTURE_RANGES);",
            "\tKMSAN_WARN_ON((nstart >= nend) || !nstart || !nend);",
            "\tnstart = ALIGN_DOWN(nstart, PAGE_SIZE);",
            "\tnend = ALIGN(nend, PAGE_SIZE);",
            "",
            "\t/*",
            "\t * Scan the existing ranges to see if any of them overlaps with",
            "\t * [start, end). In that case, merge the two ranges instead of",
            "\t * creating a new one.",
            "\t * The number of ranges is less than 20, so there is no need to organize",
            "\t * them into a more intelligent data structure.",
            "\t */",
            "\tfor (int i = 0; i < future_index; i++) {",
            "\t\tcstart = start_end_pairs[i].start;",
            "\t\tcend = start_end_pairs[i].end;",
            "\t\tif ((cstart < nstart && cend < nstart) ||",
            "\t\t    (cstart > nend && cend > nend))",
            "\t\t\t/* ranges are disjoint - do not merge */",
            "\t\t\tcontinue;",
            "\t\tstart_end_pairs[i].start = min(nstart, cstart);",
            "\t\tstart_end_pairs[i].end = max(nend, cend);",
            "\t\tmerged = true;",
            "\t\tbreak;",
            "\t}",
            "\tif (merged)",
            "\t\treturn;",
            "\tstart_end_pairs[future_index].start = nstart;",
            "\tstart_end_pairs[future_index].end = nend;",
            "\tfuture_index++;",
            "}",
            "void __init kmsan_init_shadow(void)",
            "{",
            "\tconst size_t nd_size = roundup(sizeof(pg_data_t), PAGE_SIZE);",
            "\tphys_addr_t p_start, p_end;",
            "\tu64 loop;",
            "\tint nid;",
            "",
            "\tfor_each_reserved_mem_range(loop, &p_start, &p_end)",
            "\t\tkmsan_record_future_shadow_range(phys_to_virt(p_start),",
            "\t\t\t\t\t\t phys_to_virt(p_end));",
            "\t/* Allocate shadow for .data */",
            "\tkmsan_record_future_shadow_range(_sdata, _edata);",
            "",
            "\tfor_each_online_node(nid)",
            "\t\tkmsan_record_future_shadow_range(",
            "\t\t\tNODE_DATA(nid), (char *)NODE_DATA(nid) + nd_size);",
            "",
            "\tfor (int i = 0; i < future_index; i++)",
            "\t\tkmsan_init_alloc_meta_for_range(",
            "\t\t\t(void *)start_end_pairs[i].start,",
            "\t\t\t(void *)start_end_pairs[i].end);",
            "}",
            "bool kmsan_memblock_free_pages(struct page *page, unsigned int order)",
            "{",
            "\tstruct page *shadow, *origin;",
            "",
            "\tif (!held_back[order].shadow) {",
            "\t\theld_back[order].shadow = page;",
            "\t\treturn false;",
            "\t}",
            "\tif (!held_back[order].origin) {",
            "\t\theld_back[order].origin = page;",
            "\t\treturn false;",
            "\t}",
            "\tshadow = held_back[order].shadow;",
            "\torigin = held_back[order].origin;",
            "\tkmsan_setup_meta(page, shadow, origin, order);",
            "",
            "\theld_back[order].shadow = NULL;",
            "\theld_back[order].origin = NULL;",
            "\treturn true;",
            "}",
            "static void smallstack_push(struct smallstack *stack, struct page *pages)",
            "{",
            "\tKMSAN_WARN_ON(stack->index == MAX_BLOCKS);",
            "\tstack->items[stack->index] = pages;",
            "\tstack->index++;",
            "}",
            "static void do_collection(void)",
            "{",
            "\tstruct page *page, *shadow, *origin;",
            "",
            "\twhile (collect.index >= 3) {",
            "\t\tpage = smallstack_pop(&collect);",
            "\t\tshadow = smallstack_pop(&collect);",
            "\t\torigin = smallstack_pop(&collect);",
            "\t\tkmsan_setup_meta(page, shadow, origin, collect.order);",
            "\t\t__free_pages_core(page, collect.order, MEMINIT_EARLY);",
            "\t}",
            "}",
            "static void collect_split(void)",
            "{",
            "\tstruct smallstack tmp = {",
            "\t\t.order = collect.order - 1,",
            "\t\t.index = 0,",
            "\t};",
            "\tstruct page *page;",
            "",
            "\tif (!collect.order)",
            "\t\treturn;",
            "\twhile (collect.index) {",
            "\t\tpage = smallstack_pop(&collect);",
            "\t\tsmallstack_push(&tmp, &page[0]);",
            "\t\tsmallstack_push(&tmp, &page[1 << tmp.order]);",
            "\t}",
            "\t__memcpy(&collect, &tmp, sizeof(tmp));",
            "}"
          ],
          "function_name": "kmsan_record_future_shadow_range, kmsan_init_shadow, kmsan_memblock_free_pages, smallstack_push, do_collection, collect_split",
          "description": "实现未来内存范围的合并逻辑、影子内存初始化及页面回收机制，包含范围扫描、元数据分配与碎片收集处理",
          "similarity": 0.4960290193557739
        },
        {
          "chunk_id": 0,
          "file_path": "mm/kmsan/init.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * KMSAN initialization routines.",
            " *",
            " * Copyright (C) 2017-2021 Google LLC",
            " * Author: Alexander Potapenko <glider@google.com>",
            " *",
            " */",
            "",
            "#include \"kmsan.h\"",
            "",
            "#include <asm/sections.h>",
            "#include <linux/mm.h>",
            "#include <linux/memblock.h>",
            "",
            "#include \"../internal.h\"",
            "",
            "#define NUM_FUTURE_RANGES 128",
            "struct start_end_pair {",
            "\tu64 start, end;",
            "};",
            "",
            "static struct start_end_pair start_end_pairs[NUM_FUTURE_RANGES] __initdata;",
            "static int future_index __initdata;",
            "",
            "/*",
            " * Record a range of memory for which the metadata pages will be created once",
            " * the page allocator becomes available.",
            " */"
          ],
          "function_name": null,
          "description": "定义用于记录未来内存范围的辅助结构和初始化函数，用于在页面分配器就绪后创建元数据页",
          "similarity": 0.4440256953239441
        }
      ]
    }
  ]
}