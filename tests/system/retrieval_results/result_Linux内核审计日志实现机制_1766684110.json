{
  "query": "Linux内核审计日志实现机制",
  "timestamp": "2025-12-26 01:35:10",
  "retrieved_files": [
    {
      "source_file": "kernel/auditfilter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:52:34\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `auditfilter.c`\n\n---\n\n# auditfilter.c 技术文档\n\n## 文件概述\n\n`auditfilter.c` 是 Linux 内核审计子系统（Audit Subsystem）的核心组件之一，负责实现审计事件的过滤机制。该文件提供了审计规则的解析、存储、匹配和释放功能，支持基于系统调用、文件路径、用户身份、LSM（Linux Security Module）标签等多种条件的细粒度事件过滤。通过维护多个过滤规则链表，内核能够在事件发生时快速判断是否需要记录或忽略该事件。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`audit_filter_list[AUDIT_NR_FILTERS]`**：全局数组，包含 8 个链表头，分别对应不同类型的审计过滤器（如 `AUDIT_FILTER_EXIT`、`AUDIT_FILTER_USER` 等）。\n- **`audit_rules_list[AUDIT_NR_FILTERS]`**：与 `audit_filter_list` 并行的规则链表，用于规则管理。\n- **`audit_entry`**：审计规则的内核表示，包含 `audit_krule` 结构，用于存储规则字段、操作、动作等信息。\n- **`audit_field`**：表示单个过滤字段，支持整数、字符串、LSM 安全上下文等多种类型。\n- **`classes[AUDIT_SYSCALL_CLASSES]`**：系统调用分类映射表，用于将系统调用分组（如信号类、网络类等）。\n\n### 主要函数\n\n- **`audit_free_rule()` / `audit_free_rule_rcu()`**：释放审计规则及其关联资源（如 watch、LSM 规则、字符串等），支持 RCU 安全释放。\n- **`audit_init_entry()`**：分配并初始化一个新的审计规则条目。\n- **`audit_unpack_string()`**：从用户空间缓冲区解包字符串字段，用于规则解析。\n- **`audit_to_inode()`**：处理基于 inode 的审计规则字段。\n- **`audit_register_class()` / `audit_match_class()`**：注册和匹配系统调用分类。\n- **`audit_to_entry_common()`**：将用户空间传入的 `audit_rule_data` 转换为内核内部的 `audit_entry` 表示。\n- **`audit_match_signal()`**（仅在 `CONFIG_AUDITSYSCALL` 下）：判断规则是否匹配信号类系统调用。\n\n## 关键实现\n\n### 锁与并发控制\n\n- 使用 **`audit_filter_mutex`** 互斥锁保护对过滤规则链表的写操作和阻塞读操作。\n- 规则遍历和匹配过程使用 **RCU（Read-Copy-Update）** 机制，确保高并发下的读性能。\n- 修改规则时必须**复制整个结构体**并替换链表中的旧条目，而非原地修改，以保证 RCU 读取的安全性。\n\n### 规则解析与转换\n\n- `audit_to_entry_common()` 是规则解析的核心函数，负责：\n  - 验证规则合法性（动作、字段数量、过滤器类型等）\n  - 初始化内核规则结构\n  - 处理系统调用分类位图（将分类位展开为具体系统调用掩码）\n- 支持多种比较操作符（等于、不等于、位掩码、位测试、大小比较等），通过 `audit_ops[]` 数组映射。\n\n### LSM 集成\n\n- 支持 SELinux 等 LSM 框架的安全上下文字段（如 `AUDIT_SUBJ_USER`、`AUDIT_OBJ_ROLE` 等）。\n- 使用 `security_audit_rule_free()` 释放 LSM 规则，确保与安全模块的解耦。\n\n### 系统调用分类\n\n- 通过 `audit_register_class()` 动态注册系统调用分组（如信号、文件、网络等）。\n- 在规则匹配时，自动将分类位扩展为对应的系统调用位掩码，简化用户空间规则配置。\n\n## 依赖关系\n\n- **`<linux/audit.h>`**：定义审计子系统的公共接口、常量和数据结构。\n- **`<linux/security.h>`**：提供 LSM 审计规则的注册与释放接口。\n- **`<linux/rcupdate.h>`**（隐式）：通过 RCU 机制实现无锁读取。\n- **`audit.h`（本地头文件）**：包含审计子系统内部定义。\n- **`CONFIG_AUDITSYSCALL`**：条件编译依赖，启用系统调用审计相关功能。\n- **Netlink 子系统**：通过 netlink 接收用户空间下发的审计规则。\n\n## 使用场景\n\n1. **审计规则加载**：当用户空间工具（如 `auditctl`）通过 netlink 发送审计规则时，内核调用本文件中的解析函数将规则转换为内核格式并插入对应过滤链表。\n2. **事件过滤**：在系统调用入口/出口、文件访问、进程创建等关键路径上，审计钩子函数调用本模块的匹配逻辑，判断当前事件是否应被记录。\n3. **规则更新与删除**：管理员动态修改审计策略时，内核通过 `audit_filter_mutex` 保护规则链表的修改操作，并利用 RCU 机制安全替换旧规则。\n4. **LSM 审计集成**：当 SELinux 或其他 LSM 启用审计时，安全上下文相关的过滤规则通过本模块进行匹配。\n5. **系统调用分组监控**：用户可基于系统调用类别（如“所有信号相关调用”）设置规则，无需逐个指定系统调用号。",
      "similarity": 0.6488021612167358,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/auditfilter.c",
          "start_line": 624,
          "end_line": 737,
          "content": [
            "static inline size_t audit_pack_string(void **bufp, const char *str)",
            "{",
            "\tsize_t len = strlen(str);",
            "",
            "\tmemcpy(*bufp, str, len);",
            "\t*bufp += len;",
            "",
            "\treturn len;",
            "}",
            "static int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)",
            "{",
            "\tint i;",
            "",
            "\tif (a->flags != b->flags ||",
            "\t    a->pflags != b->pflags ||",
            "\t    a->listnr != b->listnr ||",
            "\t    a->action != b->action ||",
            "\t    a->field_count != b->field_count)",
            "\t\treturn 1;",
            "",
            "\tfor (i = 0; i < a->field_count; i++) {",
            "\t\tif (a->fields[i].type != b->fields[i].type ||",
            "\t\t    a->fields[i].op != b->fields[i].op)",
            "\t\t\treturn 1;",
            "",
            "\t\tswitch (a->fields[i].type) {",
            "\t\tcase AUDIT_SUBJ_USER:",
            "\t\tcase AUDIT_SUBJ_ROLE:",
            "\t\tcase AUDIT_SUBJ_TYPE:",
            "\t\tcase AUDIT_SUBJ_SEN:",
            "\t\tcase AUDIT_SUBJ_CLR:",
            "\t\tcase AUDIT_OBJ_USER:",
            "\t\tcase AUDIT_OBJ_ROLE:",
            "\t\tcase AUDIT_OBJ_TYPE:",
            "\t\tcase AUDIT_OBJ_LEV_LOW:",
            "\t\tcase AUDIT_OBJ_LEV_HIGH:",
            "\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_WATCH:",
            "\t\t\tif (strcmp(audit_watch_path(a->watch),",
            "\t\t\t\t   audit_watch_path(b->watch)))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_DIR:",
            "\t\t\tif (strcmp(audit_tree_path(a->tree),",
            "\t\t\t\t   audit_tree_path(b->tree)))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_FILTERKEY:",
            "\t\t\t/* both filterkeys exist based on above type compare */",
            "\t\t\tif (strcmp(a->filterkey, b->filterkey))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_EXE:",
            "\t\t\t/* both paths exist based on above type compare */",
            "\t\t\tif (strcmp(audit_mark_path(a->exe),",
            "\t\t\t\t   audit_mark_path(b->exe)))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_UID:",
            "\t\tcase AUDIT_EUID:",
            "\t\tcase AUDIT_SUID:",
            "\t\tcase AUDIT_FSUID:",
            "\t\tcase AUDIT_LOGINUID:",
            "\t\tcase AUDIT_OBJ_UID:",
            "\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_GID:",
            "\t\tcase AUDIT_EGID:",
            "\t\tcase AUDIT_SGID:",
            "\t\tcase AUDIT_FSGID:",
            "\t\tcase AUDIT_OBJ_GID:",
            "\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tif (a->fields[i].val != b->fields[i].val)",
            "\t\t\t\treturn 1;",
            "\t\t}",
            "\t}",
            "",
            "\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)",
            "\t\tif (a->mask[i] != b->mask[i])",
            "\t\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static inline int audit_dupe_lsm_field(struct audit_field *df,",
            "\t\t\t\t\t   struct audit_field *sf)",
            "{",
            "\tint ret = 0;",
            "\tchar *lsm_str;",
            "",
            "\t/* our own copy of lsm_str */",
            "\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);",
            "\tif (unlikely(!lsm_str))",
            "\t\treturn -ENOMEM;",
            "\tdf->lsm_str = lsm_str;",
            "",
            "\t/* our own (refreshed) copy of lsm_rule */",
            "\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,",
            "\t\t\t\t       (void **)&df->lsm_rule, GFP_KERNEL);",
            "\t/* Keep currently invalid fields around in case they",
            "\t * become valid after a policy reload. */",
            "\tif (ret == -EINVAL) {",
            "\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",",
            "\t\t\tdf->lsm_str);",
            "\t\tret = 0;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "audit_pack_string, audit_compare_rule, audit_dupe_lsm_field",
          "description": "实现字符串序列化、规则全量对比和LSM规则复制功能，支持审计规则的精确匹配和安全模块规则初始化。",
          "similarity": 0.604823112487793
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/auditfilter.c",
          "start_line": 1206,
          "end_line": 1313,
          "content": [
            "int audit_comparator(u32 left, u32 op, u32 right)",
            "{",
            "\tswitch (op) {",
            "\tcase Audit_equal:",
            "\t\treturn (left == right);",
            "\tcase Audit_not_equal:",
            "\t\treturn (left != right);",
            "\tcase Audit_lt:",
            "\t\treturn (left < right);",
            "\tcase Audit_le:",
            "\t\treturn (left <= right);",
            "\tcase Audit_gt:",
            "\t\treturn (left > right);",
            "\tcase Audit_ge:",
            "\t\treturn (left >= right);",
            "\tcase Audit_bitmask:",
            "\t\treturn (left & right);",
            "\tcase Audit_bittest:",
            "\t\treturn ((left & right) == right);",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)",
            "{",
            "\tswitch (op) {",
            "\tcase Audit_equal:",
            "\t\treturn uid_eq(left, right);",
            "\tcase Audit_not_equal:",
            "\t\treturn !uid_eq(left, right);",
            "\tcase Audit_lt:",
            "\t\treturn uid_lt(left, right);",
            "\tcase Audit_le:",
            "\t\treturn uid_lte(left, right);",
            "\tcase Audit_gt:",
            "\t\treturn uid_gt(left, right);",
            "\tcase Audit_ge:",
            "\t\treturn uid_gte(left, right);",
            "\tcase Audit_bitmask:",
            "\tcase Audit_bittest:",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)",
            "{",
            "\tswitch (op) {",
            "\tcase Audit_equal:",
            "\t\treturn gid_eq(left, right);",
            "\tcase Audit_not_equal:",
            "\t\treturn !gid_eq(left, right);",
            "\tcase Audit_lt:",
            "\t\treturn gid_lt(left, right);",
            "\tcase Audit_le:",
            "\t\treturn gid_lte(left, right);",
            "\tcase Audit_gt:",
            "\t\treturn gid_gt(left, right);",
            "\tcase Audit_ge:",
            "\t\treturn gid_gte(left, right);",
            "\tcase Audit_bitmask:",
            "\tcase Audit_bittest:",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "int parent_len(const char *path)",
            "{",
            "\tint plen;",
            "\tconst char *p;",
            "",
            "\tplen = strlen(path);",
            "",
            "\tif (plen == 0)",
            "\t\treturn plen;",
            "",
            "\t/* disregard trailing slashes */",
            "\tp = path + plen - 1;",
            "\twhile ((*p == '/') && (p > path))",
            "\t\tp--;",
            "",
            "\t/* walk backward until we find the next slash or hit beginning */",
            "\twhile ((*p != '/') && (p > path))",
            "\t\tp--;",
            "",
            "\t/* did we find a slash? Then increment to include it in path */",
            "\tif (*p == '/')",
            "\t\tp++;",
            "",
            "\treturn p - path;",
            "}",
            "int audit_compare_dname_path(const struct qstr *dname, const char *path, int parentlen)",
            "{",
            "\tint dlen, pathlen;",
            "\tconst char *p;",
            "",
            "\tdlen = dname->len;",
            "\tpathlen = strlen(path);",
            "\tif (pathlen < dlen)",
            "\t\treturn 1;",
            "",
            "\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;",
            "\tif (pathlen - parentlen != dlen)",
            "\t\treturn 1;",
            "",
            "\tp = path + parentlen;",
            "",
            "\treturn strncmp(p, dname->name, dlen);",
            "}"
          ],
          "function_name": "audit_comparator, audit_uid_comparator, audit_gid_comparator, parent_len, audit_compare_dname_path",
          "description": "提供通用比较逻辑及路径名匹配支持，用于审计规则字段的值比较与父目录长度计算",
          "similarity": 0.6014137268066406
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/auditfilter.c",
          "start_line": 1331,
          "end_line": 1431,
          "content": [
            "int audit_filter(int msgtype, unsigned int listtype)",
            "{",
            "\tstruct audit_entry *e;",
            "\tint ret = 1; /* Audit by default */",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {",
            "\t\tint i, result = 0;",
            "",
            "\t\tfor (i = 0; i < e->rule.field_count; i++) {",
            "\t\t\tstruct audit_field *f = &e->rule.fields[i];",
            "\t\t\tpid_t pid;",
            "\t\t\tu32 sid;",
            "",
            "\t\t\tswitch (f->type) {",
            "\t\t\tcase AUDIT_PID:",
            "\t\t\t\tpid = task_pid_nr(current);",
            "\t\t\t\tresult = audit_comparator(pid, f->op, f->val);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_UID:",
            "\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_GID:",
            "\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_LOGINUID:",
            "\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),",
            "\t\t\t\t\t\t\t      f->op, f->uid);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_LOGINUID_SET:",
            "\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),",
            "\t\t\t\t\t\t\t  f->op, f->val);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_MSGTYPE:",
            "\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_SUBJ_USER:",
            "\t\t\tcase AUDIT_SUBJ_ROLE:",
            "\t\t\tcase AUDIT_SUBJ_TYPE:",
            "\t\t\tcase AUDIT_SUBJ_SEN:",
            "\t\t\tcase AUDIT_SUBJ_CLR:",
            "\t\t\t\tif (f->lsm_rule) {",
            "\t\t\t\t\tsecurity_current_getsecid_subj(&sid);",
            "\t\t\t\t\tresult = security_audit_rule_match(sid,",
            "\t\t\t\t\t\t   f->type, f->op, f->lsm_rule);",
            "\t\t\t\t}",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_EXE:",
            "\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);",
            "\t\t\t\tif (f->op == Audit_not_equal)",
            "\t\t\t\t\tresult = !result;",
            "\t\t\t\tbreak;",
            "\t\t\tdefault:",
            "\t\t\t\tgoto unlock_and_return;",
            "\t\t\t}",
            "\t\t\tif (result < 0) /* error */",
            "\t\t\t\tgoto unlock_and_return;",
            "\t\t\tif (!result)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (result > 0) {",
            "\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)",
            "\t\t\t\tret = 0;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "unlock_and_return:",
            "\trcu_read_unlock();",
            "\treturn ret;",
            "}",
            "static int update_lsm_rule(struct audit_krule *r)",
            "{",
            "\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);",
            "\tstruct audit_entry *nentry;",
            "\tint err = 0;",
            "",
            "\tif (!security_audit_rule_known(r))",
            "\t\treturn 0;",
            "",
            "\tnentry = audit_dupe_rule(r);",
            "\tif (entry->rule.exe)",
            "\t\taudit_remove_mark(entry->rule.exe);",
            "\tif (IS_ERR(nentry)) {",
            "\t\t/* save the first error encountered for the",
            "\t\t * return value */",
            "\t\terr = PTR_ERR(nentry);",
            "\t\taudit_panic(\"error updating LSM filters\");",
            "\t\tif (r->watch)",
            "\t\t\tlist_del(&r->rlist);",
            "\t\tlist_del_rcu(&entry->list);",
            "\t\tlist_del(&r->list);",
            "\t} else {",
            "\t\tif (r->watch || r->tree)",
            "\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);",
            "\t\tlist_replace_rcu(&entry->list, &nentry->list);",
            "\t\tlist_replace(&r->list, &nentry->rule.list);",
            "\t}",
            "\tcall_rcu(&entry->rcu, audit_free_rule_rcu);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "audit_filter, update_lsm_rule",
          "description": "执行审计过滤决策逻辑，基于当前进程属性与规则字段进行匹配判断，并维护LSM安全模块的规则状态",
          "similarity": 0.5992417335510254
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/auditfilter.c",
          "start_line": 1080,
          "end_line": 1188,
          "content": [
            "static void audit_list_rules(int seq, struct sk_buff_head *q)",
            "{",
            "\tstruct sk_buff *skb;",
            "\tstruct audit_krule *r;",
            "\tint i;",
            "",
            "\t/* This is a blocking read, so use audit_filter_mutex instead of rcu",
            "\t * iterator to sync with list writers. */",
            "\tfor (i = 0; i < AUDIT_NR_FILTERS; i++) {",
            "\t\tlist_for_each_entry(r, &audit_rules_list[i], list) {",
            "\t\t\tstruct audit_rule_data *data;",
            "",
            "\t\t\tdata = audit_krule_to_data(r);",
            "\t\t\tif (unlikely(!data))",
            "\t\t\t\tbreak;",
            "\t\t\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 0, 1,",
            "\t\t\t\t\t       data,",
            "\t\t\t\t\t       struct_size(data, buf, data->buflen));",
            "\t\t\tif (skb)",
            "\t\t\t\tskb_queue_tail(q, skb);",
            "\t\t\tkfree(data);",
            "\t\t}",
            "\t}",
            "\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 1, 1, NULL, 0);",
            "\tif (skb)",
            "\t\tskb_queue_tail(q, skb);",
            "}",
            "static void audit_log_rule_change(char *action, struct audit_krule *rule, int res)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);",
            "\tif (!ab)",
            "\t\treturn;",
            "\taudit_log_session_info(ab);",
            "\taudit_log_task_context(ab);",
            "\taudit_log_format(ab, \" op=%s\", action);",
            "\taudit_log_key(ab, rule->filterkey);",
            "\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);",
            "\taudit_log_end(ab);",
            "}",
            "int audit_rule_change(int type, int seq, void *data, size_t datasz)",
            "{",
            "\tint err = 0;",
            "\tstruct audit_entry *entry;",
            "",
            "\tswitch (type) {",
            "\tcase AUDIT_ADD_RULE:",
            "\t\tentry = audit_data_to_entry(data, datasz);",
            "\t\tif (IS_ERR(entry))",
            "\t\t\treturn PTR_ERR(entry);",
            "\t\terr = audit_add_rule(entry);",
            "\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);",
            "\t\tbreak;",
            "\tcase AUDIT_DEL_RULE:",
            "\t\tentry = audit_data_to_entry(data, datasz);",
            "\t\tif (IS_ERR(entry))",
            "\t\t\treturn PTR_ERR(entry);",
            "\t\terr = audit_del_rule(entry);",
            "\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ON(1);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (err || type == AUDIT_DEL_RULE) {",
            "\t\tif (entry->rule.exe)",
            "\t\t\taudit_remove_mark(entry->rule.exe);",
            "\t\taudit_free_rule(entry);",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "int audit_list_rules_send(struct sk_buff *request_skb, int seq)",
            "{",
            "\tstruct task_struct *tsk;",
            "\tstruct audit_netlink_list *dest;",
            "",
            "\t/* We can't just spew out the rules here because we might fill",
            "\t * the available socket buffer space and deadlock waiting for",
            "\t * auditctl to read from it... which isn't ever going to",
            "\t * happen if we're actually running in the context of auditctl",
            "\t * trying to _send_ the stuff */",
            "",
            "\tdest = kmalloc(sizeof(*dest), GFP_KERNEL);",
            "\tif (!dest)",
            "\t\treturn -ENOMEM;",
            "\tdest->net = get_net(sock_net(NETLINK_CB(request_skb).sk));",
            "\tdest->portid = NETLINK_CB(request_skb).portid;",
            "\tskb_queue_head_init(&dest->q);",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\taudit_list_rules(seq, &dest->q);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\ttsk = kthread_run(audit_send_list_thread, dest, \"audit_send_list\");",
            "\tif (IS_ERR(tsk)) {",
            "\t\tskb_queue_purge(&dest->q);",
            "\t\tput_net(dest->net);",
            "\t\tkfree(dest);",
            "\t\treturn PTR_ERR(tsk);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "audit_list_rules, audit_log_rule_change, audit_rule_change, audit_list_rules_send",
          "description": "实现审计规则列表的生成与发送功能，通过遍历audit_rules_list构建skb队列并异步发送至Netlink套接字，防止阻塞导致死锁",
          "similarity": 0.5945486426353455
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/auditfilter.c",
          "start_line": 940,
          "end_line": 1075,
          "content": [
            "static inline int audit_add_rule(struct audit_entry *entry)",
            "{",
            "\tstruct audit_entry *e;",
            "\tstruct audit_watch *watch = entry->rule.watch;",
            "\tstruct audit_tree *tree = entry->rule.tree;",
            "\tstruct list_head *list;",
            "\tint err = 0;",
            "#ifdef CONFIG_AUDITSYSCALL",
            "\tint dont_count = 0;",
            "",
            "\t/* If any of these, don't count towards total */",
            "\tswitch (entry->rule.listnr) {",
            "\tcase AUDIT_FILTER_USER:",
            "\tcase AUDIT_FILTER_EXCLUDE:",
            "\tcase AUDIT_FILTER_FS:",
            "\t\tdont_count = 1;",
            "\t}",
            "#endif",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\te = audit_find_rule(entry, &list);",
            "\tif (e) {",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\terr = -EEXIST;",
            "\t\t/* normally audit_add_tree_rule() will free it on failure */",
            "\t\tif (tree)",
            "\t\t\taudit_put_tree(tree);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tif (watch) {",
            "\t\t/* audit_filter_mutex is dropped and re-taken during this call */",
            "\t\terr = audit_add_watch(&entry->rule, &list);",
            "\t\tif (err) {",
            "\t\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\t\t/*",
            "\t\t\t * normally audit_add_tree_rule() will free it",
            "\t\t\t * on failure",
            "\t\t\t */",
            "\t\t\tif (tree)",
            "\t\t\t\taudit_put_tree(tree);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "\tif (tree) {",
            "\t\terr = audit_add_tree_rule(&entry->rule);",
            "\t\tif (err) {",
            "\t\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "",
            "\tentry->rule.prio = ~0ULL;",
            "\tif (entry->rule.listnr == AUDIT_FILTER_EXIT ||",
            "\t    entry->rule.listnr == AUDIT_FILTER_URING_EXIT) {",
            "\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)",
            "\t\t\tentry->rule.prio = ++prio_high;",
            "\t\telse",
            "\t\t\tentry->rule.prio = --prio_low;",
            "\t}",
            "",
            "\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {",
            "\t\tlist_add(&entry->rule.list,",
            "\t\t\t &audit_rules_list[entry->rule.listnr]);",
            "\t\tlist_add_rcu(&entry->list, list);",
            "\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;",
            "\t} else {",
            "\t\tlist_add_tail(&entry->rule.list,",
            "\t\t\t      &audit_rules_list[entry->rule.listnr]);",
            "\t\tlist_add_tail_rcu(&entry->list, list);",
            "\t}",
            "#ifdef CONFIG_AUDITSYSCALL",
            "\tif (!dont_count)",
            "\t\taudit_n_rules++;",
            "",
            "\tif (!audit_match_signal(entry))",
            "\t\taudit_signals++;",
            "#endif",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\treturn err;",
            "}",
            "int audit_del_rule(struct audit_entry *entry)",
            "{",
            "\tstruct audit_entry  *e;",
            "\tstruct audit_tree *tree = entry->rule.tree;",
            "\tstruct list_head *list;",
            "\tint ret = 0;",
            "#ifdef CONFIG_AUDITSYSCALL",
            "\tint dont_count = 0;",
            "",
            "\t/* If any of these, don't count towards total */",
            "\tswitch (entry->rule.listnr) {",
            "\tcase AUDIT_FILTER_USER:",
            "\tcase AUDIT_FILTER_EXCLUDE:",
            "\tcase AUDIT_FILTER_FS:",
            "\t\tdont_count = 1;",
            "\t}",
            "#endif",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\te = audit_find_rule(entry, &list);",
            "\tif (!e) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (e->rule.watch)",
            "\t\taudit_remove_watch_rule(&e->rule);",
            "",
            "\tif (e->rule.tree)",
            "\t\taudit_remove_tree_rule(&e->rule);",
            "",
            "\tif (e->rule.exe)",
            "\t\taudit_remove_mark_rule(&e->rule);",
            "",
            "#ifdef CONFIG_AUDITSYSCALL",
            "\tif (!dont_count)",
            "\t\taudit_n_rules--;",
            "",
            "\tif (!audit_match_signal(entry))",
            "\t\taudit_signals--;",
            "#endif",
            "",
            "\tlist_del_rcu(&e->list);",
            "\tlist_del(&e->rule.list);",
            "\tcall_rcu(&e->rcu, audit_free_rule_rcu);",
            "",
            "out:",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\tif (tree)",
            "\t\taudit_put_tree(tree);\t/* that's the temporary one */",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "audit_add_rule, audit_del_rule",
          "description": "提供审计规则增删操作，包含链表插入/删除、优先级分配、计数更新及资源引用计数管理，采用互斥锁和RCU机制保障线程安全。",
          "similarity": 0.572762131690979
        }
      ]
    },
    {
      "source_file": "kernel/acct.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:48:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `acct.c`\n\n---\n\n# Linux 内核进程记账模块（acct.c）技术文档\n\n## 1. 文件概述\n\n`acct.c` 实现了 BSD 风格的 Linux 进程记账（Process Accounting）功能。当任意进程退出时，内核会向通过 `acct()` 系统调用指定的文件中写入一条类型为 `struct acct` 的记账记录。该模块仅负责生成原始记账数据，具体的数据分析和处理由用户空间程序完成。此功能可用于系统资源使用审计、用户行为追踪和性能分析等场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bsd_acct_struct`**：进程记账核心控制结构\n  - `pin`：文件系统 pin 机制，防止记账文件被意外卸载\n  - `count`：引用计数，用于安全释放资源\n  - `active`：记账功能是否处于激活状态\n  - `check_space`：是否启用磁盘空间检查\n  - `needcheck`：下次磁盘空间检查的时间点\n  - `file`：记账文件的 file 结构指针\n  - `ns`：关联的 PID 命名空间\n  - `work`：用于异步关闭记账文件的工作队列\n  - `ac`：实际的记账数据结构（`acct_t` 类型）\n\n### 主要函数\n\n- **`acct_on()`**：启用进程记账功能，打开指定文件并初始化记账结构\n- **`check_free_space()`**：检查磁盘剩余空间，根据阈值暂停或恢复记账\n- **`acct_pin_kill()`**：安全关闭记账功能，处理资源清理\n- **`close_work()`**：工作队列回调函数，异步执行记账文件关闭操作\n- **`acct_get()`**：获取当前命名空间的记账结构，带引用计数管理\n- **`acct_put()`**：减少记账结构引用计数，必要时释放内存\n- **`fill_ac()`** 和 **`acct_write_process()`**：填充和写入进程记账记录（声明但未在提供的代码片段中实现）\n\n### 系统参数\n\n- **`acct_parm[3]`**：记账系统控制参数数组\n  - `acct_parm[0]`（RESUME）：磁盘剩余空间百分比阈值，超过此值恢复记账\n  - `acct_parm[1]`（SUSPEND）：磁盘剩余空间百分比阈值，低于此值暂停记账  \n  - `acct_parm[2]`（ACCT_TIMEOUT）：磁盘空间检查间隔时间（秒）\n\n## 3. 关键实现\n\n### 磁盘空间监控机制\n\n记账系统实现了智能的磁盘空间管理：\n- 当可用磁盘空间低于 `SUSPEND` 百分比时，自动暂停记账以避免填满磁盘\n- 当可用磁盘空间恢复到 `RESUME` 百分比以上时，自动恢复记账\n- 通过 `needcheck` 字段控制检查频率，避免频繁的磁盘 I/O 操作\n\n### 资源安全管理和并发控制\n\n- **引用计数机制**：使用 `atomic_long_t count` 确保记账结构在多线程环境下的安全访问和释放\n- **RCU 读取优化**：通过 RCU 机制实现高效的记账结构读取，减少锁竞争\n- **互斥锁保护**：`mutex lock` 保护关键操作，防止竞态条件\n- **文件系统 pin 机制**：防止记账文件所在的文件系统被意外卸载\n\n### 异步关闭机制\n\n- 使用工作队列（`work_struct`）异步处理记账文件关闭操作\n- 通过 `completion` 机制确保关闭操作完成后再释放资源\n- 在关闭前调用文件操作的 `flush` 方法确保数据写入磁盘\n\n### 安全性和验证\n\n- 验证目标文件必须是普通文件（`S_ISREG`）\n- 排除内核内部文件系统（`SB_NOUSER | SB_KERNMOUNT`）\n- 排除特殊文件系统如 procfs 和 sysfs（`SB_I_USERNS_VISIBLE`）\n- 验证文件必须具有写权限（`FMODE_CAN_WRITE`）\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n\n- **内存管理**：`<linux/mm.h>`, `<linux/slab.h>`\n- **文件系统**：`<linux/vfs.h>`, `<linux/file.h>`, `<linux/mount.h>`, `<linux/fs_pin.h>`\n- **进程管理**：`<linux/sched/cputime.h>`, `<linux/pid_namespace.h>`\n- **系统调用**：`<linux/syscalls.h>`, `<linux/uaccess.h>`\n- **安全机制**：`<linux/capability.h>`, `<linux/security.h>`\n- **设备支持**：`<linux/tty.h>`\n- **时间管理**：`<linux/jiffies.h>`, `<linux/times.h>`\n\n### 内核子系统交互\n\n- **VFS 层**：通过标准 VFS 接口进行文件操作和文件系统状态查询\n- **内存管理子系统**：使用 slab 分配器分配记账结构内存\n- **工作队列子系统**：利用内核工作队列处理异步关闭操作\n- **RCU 机制**：使用 RCU 进行无锁读取操作\n- **sysctl 接口**：提供运行时可调参数（当 `CONFIG_SYSCTL` 启用时）\n\n## 5. 使用场景\n\n### 系统管理员监控\n\n- 通过 `acct()` 系统调用启用进程记账，收集系统中所有进程的执行信息\n- 分析用户资源使用情况，识别异常进程行为\n- 监控系统负载和进程执行模式\n\n### 安全审计\n\n- 记录所有进程的执行历史，包括命令名、执行时间、资源消耗等\n- 用于事后安全事件分析和取证\n- 检测未授权的程序执行\n\n### 性能分析\n\n- 收集进程 CPU 时间、内存使用、I/O 操作等性能指标\n- 分析系统资源瓶颈和优化机会\n- 监控长时间运行的进程资源消耗趋势\n\n### 容器环境支持\n\n- 通过 PID 命名空间隔离，支持容器级别的进程记账\n- 每个命名空间可以独立配置记账文件和参数\n- 为容器监控和计费提供基础数据支持",
      "similarity": 0.6388119459152222,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/acct.c",
          "start_line": 544,
          "end_line": 644,
          "content": [
            "static void acct_write_process(struct bsd_acct_struct *acct)",
            "{",
            "\tstruct file *file = acct->file;",
            "\tconst struct cred *cred;",
            "\tacct_t *ac = &acct->ac;",
            "",
            "\t/* Perform file operations on behalf of whoever enabled accounting */",
            "\tcred = override_creds(file->f_cred);",
            "",
            "\t/*",
            "\t * First check to see if there is enough free_space to continue",
            "\t * the process accounting system. Then get freeze protection. If",
            "\t * the fs is frozen, just skip the write as we could deadlock",
            "\t * the system otherwise.",
            "\t */",
            "\tif (check_free_space(acct) && file_start_write_trylock(file)) {",
            "\t\t/* it's been opened O_APPEND, so position is irrelevant */",
            "\t\tloff_t pos = 0;",
            "\t\t__kernel_write(file, ac, sizeof(acct_t), &pos);",
            "\t\tfile_end_write(file);",
            "\t}",
            "",
            "\trevert_creds(cred);",
            "}",
            "static void do_acct_process(struct bsd_acct_struct *acct)",
            "{",
            "\tunsigned long flim;",
            "",
            "\t/* Accounting records are not subject to resource limits. */",
            "\tflim = rlimit(RLIMIT_FSIZE);",
            "\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;",
            "\tfill_ac(acct);",
            "\tacct_write_process(acct);",
            "\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;",
            "}",
            "void acct_collect(long exitcode, int group_dead)",
            "{",
            "\tstruct pacct_struct *pacct = &current->signal->pacct;",
            "\tu64 utime, stime;",
            "\tunsigned long vsize = 0;",
            "",
            "\tif (group_dead && current->mm) {",
            "\t\tstruct mm_struct *mm = current->mm;",
            "\t\tVMA_ITERATOR(vmi, mm, 0);",
            "\t\tstruct vm_area_struct *vma;",
            "",
            "\t\tmmap_read_lock(mm);",
            "\t\tfor_each_vma(vmi, vma)",
            "\t\t\tvsize += vma->vm_end - vma->vm_start;",
            "\t\tmmap_read_unlock(mm);",
            "\t}",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tif (group_dead)",
            "\t\tpacct->ac_mem = vsize / 1024;",
            "\tif (thread_group_leader(current)) {",
            "\t\tpacct->ac_exitcode = exitcode;",
            "\t\tif (current->flags & PF_FORKNOEXEC)",
            "\t\t\tpacct->ac_flag |= AFORK;",
            "\t}",
            "\tif (current->flags & PF_SUPERPRIV)",
            "\t\tpacct->ac_flag |= ASU;",
            "\tif (current->flags & PF_DUMPCORE)",
            "\t\tpacct->ac_flag |= ACORE;",
            "\tif (current->flags & PF_SIGNALED)",
            "\t\tpacct->ac_flag |= AXSIG;",
            "",
            "\ttask_cputime(current, &utime, &stime);",
            "\tpacct->ac_utime += utime;",
            "\tpacct->ac_stime += stime;",
            "\tpacct->ac_minflt += current->min_flt;",
            "\tpacct->ac_majflt += current->maj_flt;",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "}",
            "static void slow_acct_process(struct pid_namespace *ns)",
            "{",
            "\tfor ( ; ns; ns = ns->parent) {",
            "\t\tstruct bsd_acct_struct *acct = acct_get(ns);",
            "\t\tif (acct) {",
            "\t\t\tdo_acct_process(acct);",
            "\t\t\tmutex_unlock(&acct->lock);",
            "\t\t\tacct_put(acct);",
            "\t\t}",
            "\t}",
            "}",
            "void acct_process(void)",
            "{",
            "\tstruct pid_namespace *ns;",
            "",
            "\t/*",
            "\t * This loop is safe lockless, since current is still",
            "\t * alive and holds its namespace, which in turn holds",
            "\t * its parent.",
            "\t */",
            "\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {",
            "\t\tif (ns->bacct)",
            "\t\t\tbreak;",
            "\t}",
            "\tif (unlikely(ns))",
            "\t\tslow_acct_process(ns);",
            "}"
          ],
          "function_name": "acct_write_process, do_acct_process, acct_collect, slow_acct_process, acct_process",
          "description": "实现会计记录的实际写入流程、进程状态收集逻辑及跨命名空间的递归计账处理，包含资源限制绕过、线程组统计信息聚合和锁安全的遍历机制。",
          "similarity": 0.5720210075378418
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/acct.c",
          "start_line": 338,
          "end_line": 498,
          "content": [
            "void acct_exit_ns(struct pid_namespace *ns)",
            "{",
            "\trcu_read_lock();",
            "\tpin_kill(ns->bacct);",
            "}",
            "static comp_t encode_comp_t(u64 value)",
            "{",
            "\tint exp, rnd;",
            "",
            "\texp = rnd = 0;",
            "\twhile (value > MAXFRACT) {",
            "\t\trnd = value & (1 << (EXPSIZE - 1));\t/* Round up? */",
            "\t\tvalue >>= EXPSIZE;\t/* Base 8 exponent == 3 bit shift. */",
            "\t\texp++;",
            "\t}",
            "",
            "\t/*",
            "\t * If we need to round up, do it (and handle overflow correctly).",
            "\t */",
            "\tif (rnd && (++value > MAXFRACT)) {",
            "\t\tvalue >>= EXPSIZE;",
            "\t\texp++;",
            "\t}",
            "",
            "\tif (exp > (((comp_t) ~0U) >> MANTSIZE))",
            "\t\treturn (comp_t) ~0U;",
            "\t/*",
            "\t * Clean it up and polish it off.",
            "\t */",
            "\texp <<= MANTSIZE;\t\t/* Shift the exponent into place */",
            "\texp += value;\t\t\t/* and add on the mantissa. */",
            "\treturn exp;",
            "}",
            "static comp2_t encode_comp2_t(u64 value)",
            "{",
            "\tint exp, rnd;",
            "",
            "\texp = (value > (MAXFRACT2>>1));",
            "\trnd = 0;",
            "\twhile (value > MAXFRACT2) {",
            "\t\trnd = value & 1;",
            "\t\tvalue >>= 1;",
            "\t\texp++;",
            "\t}",
            "",
            "\t/*",
            "\t * If we need to round up, do it (and handle overflow correctly).",
            "\t */",
            "\tif (rnd && (++value > MAXFRACT2)) {",
            "\t\tvalue >>= 1;",
            "\t\texp++;",
            "\t}",
            "",
            "\tif (exp > MAXEXP2) {",
            "\t\t/* Overflow. Return largest representable number instead. */",
            "\t\treturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;",
            "\t} else {",
            "\t\treturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));",
            "\t}",
            "}",
            "static u32 encode_float(u64 value)",
            "{",
            "\tunsigned exp = 190;",
            "\tunsigned u;",
            "",
            "\tif (value == 0)",
            "\t\treturn 0;",
            "\twhile ((s64)value > 0) {",
            "\t\tvalue <<= 1;",
            "\t\texp--;",
            "\t}",
            "\tu = (u32)(value >> 40) & 0x7fffffu;",
            "\treturn u | (exp << 23);",
            "}",
            "static void fill_ac(struct bsd_acct_struct *acct)",
            "{",
            "\tstruct pacct_struct *pacct = &current->signal->pacct;",
            "\tstruct file *file = acct->file;",
            "\tacct_t *ac = &acct->ac;",
            "\tu64 elapsed, run_time;",
            "\ttime64_t btime;",
            "\tstruct tty_struct *tty;",
            "",
            "\tlockdep_assert_held(&acct->lock);",
            "",
            "\tif (time_is_after_jiffies(acct->needcheck)) {",
            "\t\tacct->check_space = false;",
            "",
            "\t\t/* Don't fill in @ac if nothing will be written. */",
            "\t\tif (!acct->active)",
            "\t\t\treturn;",
            "\t} else {",
            "\t\tacct->check_space = true;",
            "\t}",
            "",
            "\t/*",
            "\t * Fill the accounting struct with the needed info as recorded",
            "\t * by the different kernel functions.",
            "\t */",
            "\tmemset(ac, 0, sizeof(acct_t));",
            "",
            "\tac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;",
            "\tstrscpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));",
            "",
            "\t/* calculate run_time in nsec*/",
            "\trun_time = ktime_get_ns();",
            "\trun_time -= current->group_leader->start_time;",
            "\t/* convert nsec -> AHZ */",
            "\telapsed = nsec_to_AHZ(run_time);",
            "#if ACCT_VERSION == 3",
            "\tac->ac_etime = encode_float(elapsed);",
            "#else",
            "\tac->ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?",
            "\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);",
            "#endif",
            "#if ACCT_VERSION == 1 || ACCT_VERSION == 2",
            "\t{",
            "\t\t/* new enlarged etime field */",
            "\t\tcomp2_t etime = encode_comp2_t(elapsed);",
            "",
            "\t\tac->ac_etime_hi = etime >> 16;",
            "\t\tac->ac_etime_lo = (u16) etime;",
            "\t}",
            "#endif",
            "\tdo_div(elapsed, AHZ);",
            "\tbtime = ktime_get_real_seconds() - elapsed;",
            "\tac->ac_btime = clamp_t(time64_t, btime, 0, U32_MAX);",
            "#if ACCT_VERSION == 2",
            "\tac->ac_ahz = AHZ;",
            "#endif",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\ttty = current->signal->tty;\t/* Safe as we hold the siglock */",
            "\tac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;",
            "\tac->ac_utime = encode_comp_t(nsec_to_AHZ(pacct->ac_utime));",
            "\tac->ac_stime = encode_comp_t(nsec_to_AHZ(pacct->ac_stime));",
            "\tac->ac_flag = pacct->ac_flag;",
            "\tac->ac_mem = encode_comp_t(pacct->ac_mem);",
            "\tac->ac_minflt = encode_comp_t(pacct->ac_minflt);",
            "\tac->ac_majflt = encode_comp_t(pacct->ac_majflt);",
            "\tac->ac_exitcode = pacct->ac_exitcode;",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\t/* we really need to bite the bullet and change layout */",
            "\tac->ac_uid = from_kuid_munged(file->f_cred->user_ns, current_uid());",
            "\tac->ac_gid = from_kgid_munged(file->f_cred->user_ns, current_gid());",
            "#if ACCT_VERSION == 1 || ACCT_VERSION == 2",
            "\t/* backward-compatible 16 bit fields */",
            "\tac->ac_uid16 = ac->ac_uid;",
            "\tac->ac_gid16 = ac->ac_gid;",
            "#elif ACCT_VERSION == 3",
            "\t{",
            "\t\tstruct pid_namespace *ns = acct->ns;",
            "",
            "\t\tac->ac_pid = task_tgid_nr_ns(current, ns);",
            "\t\trcu_read_lock();",
            "\t\tac->ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent), ns);",
            "\t\trcu_read_unlock();",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "acct_exit_ns, encode_comp_t, encode_comp2_t, encode_float, fill_ac",
          "description": "提供时间编码辅助函数和会计记录填充逻辑，实现不同版本会计结构的数据转换与字段填充，包含UID/GID映射和进程标识符获取等关键操作。",
          "similarity": 0.5317434072494507
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/acct.c",
          "start_line": 1,
          "end_line": 88,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  linux/kernel/acct.c",
            " *",
            " *  BSD Process Accounting for Linux",
            " *",
            " *  Author: Marco van Wieringen <mvw@planets.elm.net>",
            " *",
            " *  Some code based on ideas and code from:",
            " *  Thomas K. Dyas <tdyas@eden.rutgers.edu>",
            " *",
            " *  This file implements BSD-style process accounting. Whenever any",
            " *  process exits, an accounting record of type \"struct acct\" is",
            " *  written to the file specified with the acct() system call. It is",
            " *  up to user-level programs to do useful things with the accounting",
            " *  log. The kernel just provides the raw accounting information.",
            " *",
            " * (C) Copyright 1995 - 1997 Marco van Wieringen - ELM Consultancy B.V.",
            " *",
            " *  Plugged two leaks. 1) It didn't return acct_file into the free_filps if",
            " *  the file happened to be read-only. 2) If the accounting was suspended",
            " *  due to the lack of space it happily allowed to reopen it and completely",
            " *  lost the old acct_file. 3/10/98, Al Viro.",
            " *",
            " *  Now we silently close acct_file on attempt to reopen. Cleaned sys_acct().",
            " *  XTerms and EMACS are manifestations of pure evil. 21/10/98, AV.",
            " *",
            " *  Fixed a nasty interaction with sys_umount(). If the accounting",
            " *  was suspeneded we failed to stop it on umount(). Messy.",
            " *  Another one: remount to readonly didn't stop accounting.",
            " *\tQuestion: what should we do if we have CAP_SYS_ADMIN but not",
            " *  CAP_SYS_PACCT? Current code does the following: umount returns -EBUSY",
            " *  unless we are messing with the root. In that case we are getting a",
            " *  real mess with do_remount_sb(). 9/11/98, AV.",
            " *",
            " *  Fixed a bunch of races (and pair of leaks). Probably not the best way,",
            " *  but this one obviously doesn't introduce deadlocks. Later. BTW, found",
            " *  one race (and leak) in BSD implementation.",
            " *  OK, that's better. ANOTHER race and leak in BSD variant. There always",
            " *  is one more bug... 10/11/98, AV.",
            " *",
            " *\tOh, fsck... Oopsable SMP race in do_process_acct() - we must hold",
            " * ->mmap_lock to walk the vma list of current->mm. Nasty, since it leaks",
            " * a struct file opened for write. Fixed. 2/6/2000, AV.",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/capability.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/security.h>",
            "#include <linux/vfs.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/times.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/cputime.h>",
            "",
            "#include <asm/div64.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/fs_pin.h>",
            "",
            "/*",
            " * These constants control the amount of freespace that suspend and",
            " * resume the process accounting system, and the time delay between",
            " * each check.",
            " * Turned into sysctl-controllable parameters. AV, 12/11/98",
            " */",
            "",
            "static int acct_parm[3] = {4, 2, 30};",
            "#define RESUME\t\t(acct_parm[0])\t/* >foo% free space - resume */",
            "#define SUSPEND\t\t(acct_parm[1])\t/* <foo% free space - suspend */",
            "#define ACCT_TIMEOUT\t(acct_parm[2])\t/* foo second timeout between checks */",
            "",
            "#ifdef CONFIG_SYSCTL",
            "static struct ctl_table kern_acct_table[] = {",
            "\t{",
            "\t\t.procname       = \"acct\",",
            "\t\t.data           = &acct_parm,",
            "\t\t.maxlen         = 3*sizeof(int),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = proc_dointvec,",
            "\t},",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义BSD进程计账系统的常量和sysctl控制表，用于动态调整磁盘空间阈值和检查间隔，注册到内核sysctl接口以支持运行时配置。",
          "similarity": 0.5303263664245605
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/acct.c",
          "start_line": 89,
          "end_line": 236,
          "content": [
            "static __init int kernel_acct_sysctls_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kern_acct_table);",
            "\treturn 0;",
            "}",
            "static bool check_free_space(struct bsd_acct_struct *acct)",
            "{",
            "\tstruct kstatfs sbuf;",
            "",
            "\tif (!acct->check_space)",
            "\t\treturn acct->active;",
            "",
            "\t/* May block */",
            "\tif (vfs_statfs(&acct->file->f_path, &sbuf))",
            "\t\treturn acct->active;",
            "",
            "\tif (acct->active) {",
            "\t\tu64 suspend = sbuf.f_blocks * SUSPEND;",
            "\t\tdo_div(suspend, 100);",
            "\t\tif (sbuf.f_bavail <= suspend) {",
            "\t\t\tacct->active = false;",
            "\t\t\tpr_info(\"Process accounting paused\\n\");",
            "\t\t}",
            "\t} else {",
            "\t\tu64 resume = sbuf.f_blocks * RESUME;",
            "\t\tdo_div(resume, 100);",
            "\t\tif (sbuf.f_bavail >= resume) {",
            "\t\t\tacct->active = true;",
            "\t\t\tpr_info(\"Process accounting resumed\\n\");",
            "\t\t}",
            "\t}",
            "",
            "\tacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;",
            "\treturn acct->active;",
            "}",
            "static void acct_put(struct bsd_acct_struct *p)",
            "{",
            "\tif (atomic_long_dec_and_test(&p->count))",
            "\t\tkfree_rcu(p, rcu);",
            "}",
            "static void acct_pin_kill(struct fs_pin *pin)",
            "{",
            "\tstruct bsd_acct_struct *acct = to_acct(pin);",
            "\tmutex_lock(&acct->lock);",
            "\t/*",
            "\t * Fill the accounting struct with the exiting task's info",
            "\t * before punting to the workqueue.",
            "\t */",
            "\tfill_ac(acct);",
            "\tschedule_work(&acct->work);",
            "\twait_for_completion(&acct->done);",
            "\tcmpxchg(&acct->ns->bacct, pin, NULL);",
            "\tmutex_unlock(&acct->lock);",
            "\tpin_remove(pin);",
            "\tacct_put(acct);",
            "}",
            "static void close_work(struct work_struct *work)",
            "{",
            "\tstruct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);",
            "\tstruct file *file = acct->file;",
            "",
            "\t/* We were fired by acct_pin_kill() which holds acct->lock. */",
            "\tacct_write_process(acct);",
            "\tif (file->f_op->flush)",
            "\t\tfile->f_op->flush(file, NULL);",
            "\t__fput_sync(file);",
            "\tcomplete(&acct->done);",
            "}",
            "static int acct_on(struct filename *pathname)",
            "{",
            "\tstruct file *file;",
            "\tstruct vfsmount *mnt, *internal;",
            "\tstruct pid_namespace *ns = task_active_pid_ns(current);",
            "\tstruct bsd_acct_struct *acct;",
            "\tstruct fs_pin *old;",
            "\tint err;",
            "",
            "\tacct = kzalloc(sizeof(struct bsd_acct_struct), GFP_KERNEL);",
            "\tif (!acct)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* Difference from BSD - they don't do O_APPEND */",
            "\tfile = file_open_name(pathname, O_WRONLY|O_APPEND|O_LARGEFILE, 0);",
            "\tif (IS_ERR(file)) {",
            "\t\tkfree(acct);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\tif (!S_ISREG(file_inode(file)->i_mode)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EACCES;",
            "\t}",
            "",
            "\t/* Exclude kernel kernel internal filesystems. */",
            "\tif (file_inode(file)->i_sb->s_flags & (SB_NOUSER | SB_KERNMOUNT)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* Exclude procfs and sysfs. */",
            "\tif (file_inode(file)->i_sb->s_iflags & SB_I_USERNS_VISIBLE) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (!(file->f_mode & FMODE_CAN_WRITE)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EIO;",
            "\t}",
            "\tinternal = mnt_clone_internal(&file->f_path);",
            "\tif (IS_ERR(internal)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn PTR_ERR(internal);",
            "\t}",
            "\terr = mnt_get_write_access(internal);",
            "\tif (err) {",
            "\t\tmntput(internal);",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn err;",
            "\t}",
            "\tmnt = file->f_path.mnt;",
            "\tfile->f_path.mnt = internal;",
            "",
            "\tatomic_long_set(&acct->count, 1);",
            "\tinit_fs_pin(&acct->pin, acct_pin_kill);",
            "\tacct->file = file;",
            "\tacct->needcheck = jiffies;",
            "\tacct->ns = ns;",
            "\tmutex_init(&acct->lock);",
            "\tINIT_WORK(&acct->work, close_work);",
            "\tinit_completion(&acct->done);",
            "\tmutex_lock_nested(&acct->lock, 1);\t/* nobody has seen it yet */",
            "\tpin_insert(&acct->pin, mnt);",
            "",
            "\trcu_read_lock();",
            "\told = xchg(&ns->bacct, &acct->pin);",
            "\tmutex_unlock(&acct->lock);",
            "\tpin_kill(old);",
            "\tmnt_put_write_access(mnt);",
            "\tmntput(mnt);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "kernel_acct_sysctls_init, check_free_space, acct_put, acct_pin_kill, close_work, acct_on",
          "description": "实现计账文件的空间检查逻辑、资源释放机制、文件句柄管理及计账开启流程，包含磁盘空间监控、文件操作封装和命名空间绑定等功能。",
          "similarity": 0.5025812983512878
        }
      ]
    },
    {
      "source_file": "kernel/audit_tree.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:51:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit_tree.c`\n\n---\n\n# audit_tree.c 技术文档\n\n## 1. 文件概述\n\n`audit_tree.c` 是 Linux 内核审计子系统中用于实现**目录树监控**（audit tree watching）的核心模块。该文件提供了对整个目录树（而不仅仅是单个 inode）进行审计监控的能力，通过将审计规则与目录路径关联，并在文件系统事件（如创建、删除、重命名等）发生时高效匹配规则。其核心机制基于 `fsnotify` 框架，在 inode 级别挂载通知标记（mark），并通过引用计数、RCU（Read-Copy-Update）和哈希表等技术保证高并发下的安全性和性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct audit_tree`**  \n  表示一个被监控的目录树。包含路径名、引用计数、关联的规则列表、关联的 chunk 列表等。\n  \n- **`struct audit_chunk`**  \n  表示与一个或多个 inode 关联的监控单元。每个 chunk 通过 `fsnotify_mark` 附加到 inode 上，并维护多个 `audit_tree` 的所有者关系（`owners[]` 数组）。\n\n- **`struct audit_tree_mark`**  \n  封装 `fsnotify_mark`，作为 chunk 与 inode 之间的桥梁，属于 `fsnotify` 框架的扩展标记类型。\n\n- **`struct audit_node`**  \n  嵌入在 `audit_chunk` 中，表示 chunk 与某个 `audit_tree` 的关联关系，包含 owner 指针和索引。\n\n### 主要函数\n\n- **`alloc_tree(const char *s)`**  \n  分配并初始化一个新的 `audit_tree` 实例。\n\n- **`get_tree()` / `put_tree()`**  \n  对 `audit_tree` 进行引用计数管理，`put_tree` 在引用归零时使用 RCU 安全释放。\n\n- **`audit_tree_lookup(const struct inode *inode)`**  \n  在 RCU 读临界区内，根据 inode 查找对应的 `audit_chunk`，并增加其引用计数。\n\n- **`audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)`**  \n  检查给定 chunk 是否属于指定的 audit tree。\n\n- **`alloc_chunk(int count)`**  \n  分配包含指定数量 `audit_node` 的 chunk。\n\n- **`insert_hash(struct audit_chunk *chunk)`**  \n  将 chunk 插入全局哈希表，用于快速查找。\n\n- **`audit_mark_put_chunk()` / `audit_put_chunk()`**  \n  安全释放 chunk 的引用，结合 RCU 机制确保并发安全。\n\n- **`replace_mark_chunk()` / `replace_chunk()`**  \n  在标记或 chunk 更新时进行原子替换（代码片段中 `replace_chunk` 未完整）。\n\n## 3. 关键实现\n\n### 哈希与查找机制\n- 使用 `inode->i_fsnotify_marks` 的地址作为哈希键（`inode_to_key`），确保每个 inode 对应唯一键。\n- 全局哈希表 `chunk_hash_heads[HASH_SIZE]`（大小为 128）配合 `hash_lock` 自旋锁保护写操作。\n- 查找操作（`audit_tree_lookup`）在 RCU 读锁下进行，通过 `READ_ONCE()` 和 `smp_wmb()` 保证内存可见性。\n\n### 引用计数与生命周期管理\n- `audit_tree` 使用 `refcount_t` 管理引用，来源包括：关联的审计规则、chunk 中的 owner 引用。\n- `audit_chunk` 使用 `atomic_long_t refs`，其中一份引用由 `fsnotify_mark` 持有。\n- 所有释放操作均通过 RCU（`call_rcu` / `kfree_rcu`）延迟执行，确保并发读取安全。\n\n### 与 fsnotify 集成\n- 每个被监控的 inode 通过 `audit_tree_mark`（继承 `fsnotify_mark`）关联一个 `audit_chunk`。\n- 当 inode 被删除或 untag 时，`fsnotify` 框架回调 `audit_tree_destroy_watch` 释放 mark。\n- `mark->mask = FS_IN_IGNORED` 表示仅用于内部结构关联，不主动监听事件（实际事件由审计规则触发匹配）。\n\n### 循环链表组织\n- `tree->chunks`：链接所有包含该 tree 的 chunk 中的 `audit_node.list`。\n- `chunk->trees`：链接所有以该 chunk 为根的 tree 的 `same_root` 链表。\n- `tree->rules`：链接所有引用该 tree 的审计规则。\n- 这些链表分别由 `hash_lock` 或 `audit_filter_mutex` 保护。\n\n### 索引位标记\n- `audit_node.index` 的最高位（MSB）用于标记“可能需要回滚”的临时状态，辅助复杂操作（如树重构）的清理逻辑。\n\n## 4. 依赖关系\n\n- **`<linux/fsnotify_backend.h>`**：依赖 fsnotify 框架实现 inode 级别事件通知和标记管理。\n- **`<linux/namei.h>` / `<linux/mount.h>`**：用于路径解析和挂载点处理（虽未在片段中直接调用，但 audit 树需处理跨挂载点语义）。\n- **`audit.h`**：与审计核心模块交互，提供 `audit_tree_path()` 等接口供规则匹配使用。\n- **`<linux/rcupdate.h>`**：使用 RCU 机制保证并发安全。\n- **`<linux/slab.h>`**：使用 `kmem_cache` 高效分配 `audit_tree_mark` 对象。\n\n## 5. 使用场景\n\n- **审计规则匹配**：当用户通过 `auditctl` 添加 `-w /path/to/dir -p wa -k key` 类型规则时，内核将 `/path/to/dir` 注册为 `audit_tree`。\n- **路径遍历监控**：在 `audit_inode()` 和 `audit_inode_child()` 中，内核收集路径上所有 inode 对应的 `audit_chunk`，用于后续与 `AUDIT_TREE` 类型规则匹配。\n- **动态目录结构变更**：当目录树内发生文件创建、删除、重命名或 inode 删除时，通过 fsnotify 机制触发 chunk 更新或 prune（修剪）操作，由专用内核线程 `prune_thread` 处理延迟清理。\n- **资源回收**：当审计规则被删除或监控目录被移除时，相关 `audit_tree` 和 `audit_chunk` 通过引用计数和 RCU 安全释放，避免内存泄漏。",
      "similarity": 0.6367953419685364,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/audit_tree.c",
          "start_line": 569,
          "end_line": 709,
          "content": [
            "static void prune_tree_chunks(struct audit_tree *victim, bool tagged)",
            "{",
            "\tspin_lock(&hash_lock);",
            "\twhile (!list_empty(&victim->chunks)) {",
            "\t\tstruct audit_node *p;",
            "\t\tstruct audit_chunk *chunk;",
            "\t\tstruct fsnotify_mark *mark;",
            "",
            "\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);",
            "\t\t/* have we run out of marked? */",
            "\t\tif (tagged && !(p->index & (1U<<31)))",
            "\t\t\tbreak;",
            "\t\tchunk = find_chunk(p);",
            "\t\tmark = chunk->mark;",
            "\t\tremove_chunk_node(chunk, p);",
            "\t\t/* Racing with audit_tree_freeing_mark()? */",
            "\t\tif (!mark)",
            "\t\t\tcontinue;",
            "\t\tfsnotify_get_mark(mark);",
            "\t\tspin_unlock(&hash_lock);",
            "",
            "\t\tuntag_chunk(chunk, mark);",
            "\t\tfsnotify_put_mark(mark);",
            "",
            "\t\tspin_lock(&hash_lock);",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "}",
            "static void prune_one(struct audit_tree *victim)",
            "{",
            "\tprune_tree_chunks(victim, false);",
            "\tput_tree(victim);",
            "}",
            "static void trim_marked(struct audit_tree *tree)",
            "{",
            "\tstruct list_head *p, *q;",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\treturn;",
            "\t}",
            "\t/* reorder */",
            "\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {",
            "\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);",
            "\t\tq = p->next;",
            "\t\tif (node->index & (1U<<31)) {",
            "\t\t\tlist_del_init(p);",
            "\t\t\tlist_add(p, &tree->chunks);",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "",
            "\tprune_tree_chunks(tree, true);",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (!tree->root && !tree->goner) {",
            "\t\ttree->goner = 1;",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t\tkill_rules(audit_context(), tree);",
            "\t\tlist_del_init(&tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\tprune_one(tree);",
            "\t} else {",
            "\t\tspin_unlock(&hash_lock);",
            "\t}",
            "}",
            "int audit_remove_tree_rule(struct audit_krule *rule)",
            "{",
            "\tstruct audit_tree *tree;",
            "\ttree = rule->tree;",
            "\tif (tree) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&rule->rlist);",
            "\t\tif (list_empty(&tree->rules) && !tree->goner) {",
            "\t\t\ttree->root = NULL;",
            "\t\t\tlist_del_init(&tree->same_root);",
            "\t\t\ttree->goner = 1;",
            "\t\t\tlist_move(&tree->list, &prune_list);",
            "\t\t\trule->tree = NULL;",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t\taudit_schedule_prune();",
            "\t\t\treturn 1;",
            "\t\t}",
            "\t\trule->tree = NULL;",
            "\t\tspin_unlock(&hash_lock);",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "void audit_trim_trees(void)",
            "{",
            "\tstruct list_head cursor;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_add(&cursor, &tree_list);",
            "\twhile (cursor.next != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "\t\tstruct path path;",
            "\t\tstruct audit_node *node;",
            "\t\tstruct path *paths;",
            "\t\tstruct path array[16];",
            "\t\tint err;",
            "",
            "\t\ttree = container_of(cursor.next, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&cursor, &tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\terr = kern_path(tree->pathname, 0, &path);",
            "\t\tif (err)",
            "\t\t\tgoto skip_it;",
            "",
            "\t\tpaths = collect_paths(&path, array, 16);",
            "\t\tpath_put(&path);",
            "\t\tif (IS_ERR(paths))",
            "\t\t\tgoto skip_it;",
            "",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_for_each_entry(node, &tree->chunks, list) {",
            "\t\t\tstruct audit_chunk *chunk = find_chunk(node);",
            "\t\t\t/* this could be NULL if the watch is dying else where... */",
            "\t\t\tnode->index |= 1U<<31;",
            "\t\t\tfor (struct path *p = paths; p->dentry; p++) {",
            "\t\t\t\tstruct inode *inode = p->dentry->d_inode;",
            "\t\t\t\tif (inode_to_key(inode) == chunk->key) {",
            "\t\t\t\t\tnode->index &= ~(1U<<31);",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock(&hash_lock);",
            "\t\ttrim_marked(tree);",
            "\t\tdrop_collected_paths(paths, array);",
            "skip_it:",
            "\t\tput_tree(tree);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "\tlist_del(&cursor);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "}"
          ],
          "function_name": "prune_tree_chunks, prune_one, trim_marked, audit_remove_tree_rule, audit_trim_trees",
          "description": "实现审计树的周期性清理机制，扫描并移除冗余chunk，通过标记位判断是否保留。结合路径收集和哈希表遍历，确保审计数据及时回收，防止内存泄露和性能下降。",
          "similarity": 0.62575364112854
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/audit_tree.c",
          "start_line": 325,
          "end_line": 451,
          "content": [
            "static void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)",
            "{",
            "\tstruct audit_tree *owner = p->owner;",
            "",
            "\tif (owner->root == chunk) {",
            "\t\tlist_del_init(&owner->same_root);",
            "\t\towner->root = NULL;",
            "\t}",
            "\tlist_del_init(&p->list);",
            "\tp->owner = NULL;",
            "\tput_tree(owner);",
            "}",
            "static int chunk_count_trees(struct audit_chunk *chunk)",
            "{",
            "\tint i;",
            "\tint ret = 0;",
            "",
            "\tfor (i = 0; i < chunk->count; i++)",
            "\t\tif (chunk->owners[i].owner)",
            "\t\t\tret++;",
            "\treturn ret;",
            "}",
            "static void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)",
            "{",
            "\tstruct audit_chunk *new;",
            "\tint size;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\t/*",
            "\t * mark_mutex stabilizes chunk attached to the mark so we can check",
            "\t * whether it didn't change while we've dropped hash_lock.",
            "\t */",
            "\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||",
            "\t    mark_chunk(mark) != chunk)",
            "\t\tgoto out_mutex;",
            "",
            "\tsize = chunk_count_trees(chunk);",
            "\tif (!size) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&chunk->trees);",
            "\t\tlist_del_rcu(&chunk->hash);",
            "\t\treplace_mark_chunk(mark, NULL);",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\taudit_mark_put_chunk(chunk);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\treturn;",
            "\t}",
            "",
            "\tnew = alloc_chunk(size);",
            "\tif (!new)",
            "\t\tgoto out_mutex;",
            "",
            "\tspin_lock(&hash_lock);",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(new, chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\taudit_mark_put_chunk(chunk);",
            "\treturn;",
            "",
            "out_mutex:",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "}",
            "static int create_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk = alloc_chunk(1);",
            "",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tmark = alloc_mark();",
            "\tif (!mark) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\treplace_mark_chunk(mark, chunk);",
            "\tchunk->owners[0].index = (1U << 31);",
            "\tchunk->owners[0].owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&chunk->owners[0].list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\tchunk->key = inode_to_key(inode);",
            "\t/*",
            "\t * Inserting into the hash table has to go last as once we do that RCU",
            "\t * readers can see the chunk.",
            "\t */",
            "\tinsert_hash(chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\t/*",
            "\t * Drop our initial reference. When mark we point to is getting freed,",
            "\t * we get notification through ->freeing_mark callback and cleanup",
            "\t * chunk pointing to this mark.",
            "\t */",
            "\tfsnotify_put_mark(mark);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "remove_chunk_node, chunk_count_trees, untag_chunk, create_chunk",
          "description": "实现文件节点标记的增删改查逻辑，包含chunk创建、旧chunk清理及哈希表更新。通过锁保护确保操作原子性，处理标记失效场景并释放无效资源，维持审计系统状态有效性。",
          "similarity": 0.5991398096084595
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/audit_tree.c",
          "start_line": 458,
          "end_line": 560,
          "content": [
            "static int tag_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk, *old;",
            "\tstruct audit_node *p;",
            "\tint n;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\tmark = fsnotify_find_inode_mark(inode, audit_tree_group);",
            "\tif (!mark)",
            "\t\treturn create_chunk(inode, tree);",
            "",
            "\t/*",
            "\t * Found mark is guaranteed to be attached and mark_mutex protects mark",
            "\t * from getting detached and thus it makes sure there is chunk attached",
            "\t * to the mark.",
            "\t */",
            "\t/* are we already there? */",
            "\tspin_lock(&hash_lock);",
            "\told = mark_chunk(mark);",
            "\tfor (n = 0; n < old->count; n++) {",
            "\t\tif (old->owners[n].owner == tree) {",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\t\tfsnotify_put_mark(mark);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "",
            "\tchunk = alloc_chunk(old->count + 1);",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\tp = &chunk->owners[chunk->count - 1];",
            "\tp->index = (chunk->count - 1) | (1U<<31);",
            "\tp->owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&p->list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(chunk, old);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\tfsnotify_put_mark(mark); /* pair to fsnotify_find_mark */",
            "\taudit_mark_put_chunk(old);",
            "",
            "\treturn 0;",
            "}",
            "static void audit_tree_log_remove_rule(struct audit_context *context,",
            "\t\t\t\t       struct audit_krule *rule)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CONFIG_CHANGE);",
            "\tif (unlikely(!ab))",
            "\t\treturn;",
            "\taudit_log_format(ab, \"op=remove_rule dir=\");",
            "\taudit_log_untrustedstring(ab, rule->tree->pathname);",
            "\taudit_log_key(ab, rule->filterkey);",
            "\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);",
            "\taudit_log_end(ab);",
            "}",
            "static void kill_rules(struct audit_context *context, struct audit_tree *tree)",
            "{",
            "\tstruct audit_krule *rule, *next;",
            "\tstruct audit_entry *entry;",
            "",
            "\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {",
            "\t\tentry = container_of(rule, struct audit_entry, rule);",
            "",
            "\t\tlist_del_init(&rule->rlist);",
            "\t\tif (rule->tree) {",
            "\t\t\t/* not a half-baked one */",
            "\t\t\taudit_tree_log_remove_rule(context, rule);",
            "\t\t\tif (entry->rule.exe)",
            "\t\t\t\taudit_remove_mark(entry->rule.exe);",
            "\t\t\trule->tree = NULL;",
            "\t\t\tlist_del_rcu(&entry->list);",
            "\t\t\tlist_del(&entry->rule.list);",
            "\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "tag_chunk, audit_tree_log_remove_rule, kill_rules",
          "description": "负责规则绑定和解绑操作，包含标记chunk的关联建立与断开。通过日志记录规则变更，触发清理流程，确保审计规则与文件系统事件的动态同步。",
          "similarity": 0.5792531371116638
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/audit_tree.c",
          "start_line": 723,
          "end_line": 862,
          "content": [
            "int audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)",
            "{",
            "",
            "\tif (pathname[0] != '/' ||",
            "\t    (rule->listnr != AUDIT_FILTER_EXIT &&",
            "\t     rule->listnr != AUDIT_FILTER_URING_EXIT) ||",
            "\t    op != Audit_equal ||",
            "\t    rule->inode_f || rule->watch || rule->tree)",
            "\t\treturn -EINVAL;",
            "\trule->tree = alloc_tree(pathname);",
            "\tif (!rule->tree)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "void audit_put_tree(struct audit_tree *tree)",
            "{",
            "\tput_tree(tree);",
            "}",
            "static int tag_mounts(struct path *paths, struct audit_tree *tree)",
            "{",
            "\tfor (struct path *p = paths; p->dentry; p++) {",
            "\t\tint err = tag_chunk(p->dentry->d_inode, tree);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int prune_tree_thread(void *unused)",
            "{",
            "\tfor (;;) {",
            "\t\tif (list_empty(&prune_list)) {",
            "\t\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\t\tschedule();",
            "\t\t}",
            "",
            "\t\taudit_ctl_lock();",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "",
            "\t\twhile (!list_empty(&prune_list)) {",
            "\t\t\tstruct audit_tree *victim;",
            "",
            "\t\t\tvictim = list_entry(prune_list.next,",
            "\t\t\t\t\tstruct audit_tree, list);",
            "\t\t\tlist_del_init(&victim->list);",
            "",
            "\t\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\t\tprune_one(victim);",
            "",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t}",
            "",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\taudit_ctl_unlock();",
            "\t}",
            "\treturn 0;",
            "}",
            "static int audit_launch_prune(void)",
            "{",
            "\tif (prune_thread)",
            "\t\treturn 0;",
            "\tprune_thread = kthread_run(prune_tree_thread, NULL,",
            "\t\t\t\t\"audit_prune_tree\");",
            "\tif (IS_ERR(prune_thread)) {",
            "\t\tpr_err(\"cannot start thread audit_prune_tree\");",
            "\t\tprune_thread = NULL;",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\treturn 0;",
            "}",
            "int audit_add_tree_rule(struct audit_krule *rule)",
            "{",
            "\tstruct audit_tree *seed = rule->tree, *tree;",
            "\tstruct path path;",
            "\tstruct path array[16];",
            "\tstruct path *paths;",
            "\tint err;",
            "",
            "\trule->tree = NULL;",
            "\tlist_for_each_entry(tree, &tree_list, list) {",
            "\t\tif (!strcmp(seed->pathname, tree->pathname)) {",
            "\t\t\tput_tree(seed);",
            "\t\t\trule->tree = tree;",
            "\t\t\tlist_add(&rule->rlist, &tree->rules);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\ttree = seed;",
            "\tlist_add(&tree->list, &tree_list);",
            "\tlist_add(&rule->rlist, &tree->rules);",
            "\t/* do not set rule->tree yet */",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\tif (unlikely(!prune_thread)) {",
            "\t\terr = audit_launch_prune();",
            "\t\tif (err)",
            "\t\t\tgoto Err;",
            "\t}",
            "",
            "\terr = kern_path(tree->pathname, 0, &path);",
            "\tif (err)",
            "\t\tgoto Err;",
            "\tpaths = collect_paths(&path, array, 16);",
            "\tpath_put(&path);",
            "\tif (IS_ERR(paths)) {",
            "\t\terr = PTR_ERR(paths);",
            "\t\tgoto Err;",
            "\t}",
            "",
            "\tget_tree(tree);",
            "\terr = tag_mounts(paths, tree);",
            "\tdrop_collected_paths(paths, array);",
            "",
            "\tif (!err) {",
            "\t\tstruct audit_node *node;",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_for_each_entry(node, &tree->chunks, list)",
            "\t\t\tnode->index &= ~(1U<<31);",
            "\t\tspin_unlock(&hash_lock);",
            "\t} else {",
            "\t\ttrim_marked(tree);",
            "\t\tgoto Err;",
            "\t}",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tif (list_empty(&rule->rlist)) {",
            "\t\tput_tree(tree);",
            "\t\treturn -ENOENT;",
            "\t}",
            "\trule->tree = tree;",
            "\tput_tree(tree);",
            "",
            "\treturn 0;",
            "Err:",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_del_init(&tree->list);",
            "\tlist_del_init(&tree->rules);",
            "\tput_tree(tree);",
            "\treturn err;",
            "}"
          ],
          "function_name": "audit_make_tree, audit_put_tree, tag_mounts, prune_tree_thread, audit_launch_prune, audit_add_tree_rule",
          "description": "实现审计树的创建与销毁逻辑，包括路径有效性校验、树结构分配、挂载点标记、修剪线程启动及规则绑定。通过alloc_tree分配新树结构，put_tree释放资源，tag_mounts遍历路径标记挂载点，prune_tree_thread作为后台线程定期清理过期树节点。",
          "similarity": 0.5699805021286011
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/audit_tree.c",
          "start_line": 111,
          "end_line": 218,
          "content": [
            "static inline void get_tree(struct audit_tree *tree)",
            "{",
            "\trefcount_inc(&tree->count);",
            "}",
            "static inline void put_tree(struct audit_tree *tree)",
            "{",
            "\tif (refcount_dec_and_test(&tree->count))",
            "\t\tkfree_rcu(tree, head);",
            "}",
            "static void free_chunk(struct audit_chunk *chunk)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < chunk->count; i++) {",
            "\t\tif (chunk->owners[i].owner)",
            "\t\t\tput_tree(chunk->owners[i].owner);",
            "\t}",
            "\tkfree(chunk);",
            "}",
            "void audit_put_chunk(struct audit_chunk *chunk)",
            "{",
            "\tif (atomic_long_dec_and_test(&chunk->refs))",
            "\t\tfree_chunk(chunk);",
            "}",
            "static void __put_chunk(struct rcu_head *rcu)",
            "{",
            "\tstruct audit_chunk *chunk = container_of(rcu, struct audit_chunk, head);",
            "\taudit_put_chunk(chunk);",
            "}",
            "static void audit_mark_put_chunk(struct audit_chunk *chunk)",
            "{",
            "\tcall_rcu(&chunk->head, __put_chunk);",
            "}",
            "static void audit_tree_destroy_watch(struct fsnotify_mark *mark)",
            "{",
            "\tkmem_cache_free(audit_tree_mark_cachep, audit_mark(mark));",
            "}",
            "static unsigned long inode_to_key(const struct inode *inode)",
            "{",
            "\t/* Use address pointed to by connector->obj as the key */",
            "\treturn (unsigned long)&inode->i_fsnotify_marks;",
            "}",
            "static void insert_hash(struct audit_chunk *chunk)",
            "{",
            "\tstruct list_head *list;",
            "",
            "\t/*",
            "\t * Make sure chunk is fully initialized before making it visible in the",
            "\t * hash. Pairs with a data dependency barrier in READ_ONCE() in",
            "\t * audit_tree_lookup().",
            "\t */",
            "\tsmp_wmb();",
            "\tWARN_ON_ONCE(!chunk->key);",
            "\tlist = chunk_hash(chunk->key);",
            "\tlist_add_rcu(&chunk->hash, list);",
            "}",
            "bool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)",
            "{",
            "\tint n;",
            "\tfor (n = 0; n < chunk->count; n++)",
            "\t\tif (chunk->owners[n].owner == tree)",
            "\t\t\treturn true;",
            "\treturn false;",
            "}",
            "static void replace_mark_chunk(struct fsnotify_mark *mark,",
            "\t\t\t       struct audit_chunk *chunk)",
            "{",
            "\tstruct audit_chunk *old;",
            "",
            "\tassert_spin_locked(&hash_lock);",
            "\told = mark_chunk(mark);",
            "\taudit_mark(mark)->chunk = chunk;",
            "\tif (chunk)",
            "\t\tchunk->mark = mark;",
            "\tif (old)",
            "\t\told->mark = NULL;",
            "}",
            "static void replace_chunk(struct audit_chunk *new, struct audit_chunk *old)",
            "{",
            "\tstruct audit_tree *owner;",
            "\tint i, j;",
            "",
            "\tnew->key = old->key;",
            "\tlist_splice_init(&old->trees, &new->trees);",
            "\tlist_for_each_entry(owner, &new->trees, same_root)",
            "\t\towner->root = new;",
            "\tfor (i = j = 0; j < old->count; i++, j++) {",
            "\t\tif (!old->owners[j].owner) {",
            "\t\t\ti--;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\towner = old->owners[j].owner;",
            "\t\tnew->owners[i].owner = owner;",
            "\t\tnew->owners[i].index = old->owners[j].index - j + i;",
            "\t\tif (!owner) /* result of earlier fallback */",
            "\t\t\tcontinue;",
            "\t\tget_tree(owner);",
            "\t\tlist_replace_init(&old->owners[j].list, &new->owners[i].list);",
            "\t}",
            "\treplace_mark_chunk(old->mark, new);",
            "\t/*",
            "\t * Make sure chunk is fully initialized before making it visible in the",
            "\t * hash. Pairs with a data dependency barrier in READ_ONCE() in",
            "\t * audit_tree_lookup().",
            "\t */",
            "\tsmp_wmb();",
            "\tlist_replace_rcu(&old->hash, &new->hash);",
            "}"
          ],
          "function_name": "get_tree, put_tree, free_chunk, audit_put_chunk, __put_chunk, audit_mark_put_chunk, audit_tree_destroy_watch, inode_to_key, insert_hash, audit_tree_match, replace_mark_chunk, replace_chunk",
          "description": "提供对audit_tree和audit_chunk的引用计数管理，包含分配/释放chunk逻辑，处理标记替换及哈希表插入。通过RCU机制确保并发安全性，维护规则匹配所需的数据结构一致性。",
          "similarity": 0.5579456686973572
        }
      ]
    }
  ]
}