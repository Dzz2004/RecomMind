{
  "query": "访问控制列表",
  "timestamp": "2025-12-26 01:30:49",
  "retrieved_files": [
    {
      "source_file": "mm/memcontrol-v1.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memcontrol-v1.c`\n\n---\n\n# memcontrol-v1.c 技术文档\n\n## 1. 文件概述\n\n`memcontrol-v1.c` 是 Linux 内核内存控制组（Memory Cgroup）v1 接口的核心实现文件之一，主要负责基于软限制（soft limit）的内存回收机制、OOM 事件通知以及与 cgroup v1 兼容的资源统计和管理功能。该文件维护了一个独立于 cgroup 层级结构的红黑树（RB-Tree），用于高效地追踪和选择超出软限制最多的内存控制组进行内存回收。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mem_cgroup_tree_per_node`**  \n  每个 NUMA 节点对应的红黑树结构，用于存储超出软限制的 `mem_cgroup_per_node` 实例。\n  - `rb_root`: 红黑树根节点\n  - `rb_rightmost`: 指向使用量超出软限制最多的节点（树中最右侧节点）\n  - `lock`: 保护该树的自旋锁\n\n- **`struct mem_cgroup_tree`**  \n  全局软限制树结构，包含每个 NUMA 节点对应的 `mem_cgroup_tree_per_node`。\n\n- **`struct mem_cgroup_eventfd_list`**  \n  用于 OOM 事件通知的 eventfd 列表项。\n\n- **`struct mem_cgroup_event`**  \n  表示用户空间注册的内存事件（如 OOM、阈值触发等），支持通过 eventfd 通知用户空间。\n\n- **枚举常量 `RES_*`**  \n  定义了 cgroup v1 接口中可读写的资源属性类型（如使用量、限制、最大使用量、失败计数、软限制等）。\n\n### 主要函数\n\n- **`__mem_cgroup_insert_exceeded()` / `__mem_cgroup_remove_exceeded()`**  \n  在指定节点的软限制红黑树中插入或移除一个 `mem_cgroup_per_node` 节点。\n\n- **`memcg1_update_tree()`**  \n  根据当前内存使用量与软限制的差值，更新指定 memcg 及其所有祖先在软限制树中的位置。\n\n- **`memcg1_remove_from_trees()`**  \n  在 memcg 销毁时，将其从所有 NUMA 节点的软限制树中移除。\n\n- **`mem_cgroup_largest_soft_limit_node()`**  \n  从指定节点的软限制树中找出超出软限制最多的 memcg 节点，用于优先回收。\n\n- **`mem_cgroup_soft_reclaim()`**  \n  对指定 memcg 层级结构执行软限制驱动的内存回收。\n\n- **`memcg1_soft_limit_reclaim()`**（未完整显示）  \n  全局软限制回收入口函数，由内存短缺路径调用，尝试从超出软限制的 memcg 中回收内存。\n\n## 3. 关键实现\n\n### 软限制红黑树机制\n\n- 所有超出软限制（`memory.usage > soft_limit`）的 `mem_cgroup_per_node` 实例被组织到 per-NUMA-node 的红黑树中。\n- 树按 `usage_in_excess = usage - soft_limit` 升序排列，最右侧节点即为超出最多的 memcg。\n- 当 memcg 的内存使用量变化或软限制被修改时，调用 `memcg1_update_tree()` 更新其在树中的位置（先删除再重新插入）。\n- 回收时优先选择 `rb_rightmost` 节点，确保优先回收“最违规”的 memcg。\n\n### 层级遍历与祖先更新\n\n- 在启用 cgroup 层级模式时，子 memcg 的内存使用会影响父 memcg 的统计。\n- 因此，当子 memcg 的使用量变化时，需向上遍历所有祖先，更新它们在软限制树中的状态。\n\n### 防止无限循环的回收控制\n\n- `MEM_CGROUP_MAX_RECLAIM_LOOPS`（100）和 `MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS`（2）用于限制回收循环次数。\n- 若一轮遍历未回收足够内存（`total < excess >> 2`），最多再尝试一次。\n\n### 与 LRU_GEN 的集成\n\n- 若启用了多代 LRU（`lru_gen_enabled()`），则绕过红黑树机制，直接调用 `lru_gen_soft_reclaim()` 进行软限制回收。\n\n### 事件通知机制\n\n- 支持通过 `eventfd` 向用户空间发送 OOM 或其他内存事件通知。\n- 使用 `poll_table` 和 `wait_queue` 实现 eventfd 的自动注销（当 fd 关闭时）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memcontrol.h>`：内存控制组核心接口\n  - `<linux/swap.h>`, `\"swap.h\"`：交换子系统支持\n  - `<linux/eventfd.h>`, `<linux/poll.h>`：事件通知机制\n  - `\"internal.h\"`：内核内存管理内部接口\n\n- **功能依赖**：\n  - 依赖 `page_counter` 子系统进行内存使用量统计\n  - 依赖 `mem_cgroup_iter()` 实现层级遍历\n  - 依赖 `mem_cgroup_shrink_node()` 执行实际页面回收\n  - 可选依赖 `lru_gen` 多代 LRU 回收器\n\n- **配置依赖**：\n  - `CONFIG_MEMCG`：必须启用内存 cgroup\n  - `CONFIG_LOCKDEP`：仅在调试时定义锁依赖映射\n\n## 5. 使用场景\n\n- **内存压力下的软限制回收**：当系统内存紧张时，`kswapd` 或直接回收路径会调用 `memcg1_soft_limit_reclaim()`，优先从超出软限制的 memcg 中回收内存，以维持服务质量（QoS）。\n- **cgroup v1 接口兼容**：为 `/sys/fs/cgroup/memory/` 下的 `memory.soft_limit_in_bytes` 等文件提供后端支持。\n- **OOM 事件通知**：当 memcg 触发 OOM 时，通过预先注册的 eventfd 向用户空间守护进程（如容器运行时）发送通知。\n- **动态资源调整**：当用户通过写入 `memory.soft_limit_in_bytes` 修改软限制时，触发 `memcg1_update_tree()` 更新红黑树结构。\n- **memcg 销毁清理**：在 cgroup 被删除时，确保其从所有软限制树中正确移除，防止悬挂指针。",
      "similarity": 0.5454526543617249,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 1400,
          "end_line": 1528,
          "content": [
            "static int mem_cgroup_force_empty(struct mem_cgroup *memcg)",
            "{",
            "\tint nr_retries = MAX_RECLAIM_RETRIES;",
            "",
            "\t/* we call try-to-free pages for make this cgroup empty */",
            "\tlru_add_drain_all();",
            "",
            "\tdrain_all_stock(memcg);",
            "",
            "\t/* try to free all pages in this cgroup */",
            "\twhile (nr_retries && page_counter_read(&memcg->memory)) {",
            "\t\tif (signal_pending(current))",
            "\t\t\treturn -EINTR;",
            "",
            "\t\tif (!try_to_free_mem_cgroup_pages(memcg, 1, GFP_KERNEL,",
            "\t\t\t\t\t\t  MEMCG_RECLAIM_MAY_SWAP))",
            "\t\t\tnr_retries--;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static ssize_t mem_cgroup_force_empty_write(struct kernfs_open_file *of,",
            "\t\t\t\t\t    char *buf, size_t nbytes,",
            "\t\t\t\t\t    loff_t off)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));",
            "",
            "\tif (mem_cgroup_is_root(memcg))",
            "\t\treturn -EINVAL;",
            "\treturn mem_cgroup_force_empty(memcg) ?: nbytes;",
            "}",
            "static u64 mem_cgroup_hierarchy_read(struct cgroup_subsys_state *css,",
            "\t\t\t\t     struct cftype *cft)",
            "{",
            "\treturn 1;",
            "}",
            "static int mem_cgroup_hierarchy_write(struct cgroup_subsys_state *css,",
            "\t\t\t\t      struct cftype *cft, u64 val)",
            "{",
            "\tif (val == 1)",
            "\t\treturn 0;",
            "",
            "\tpr_warn_once(\"Non-hierarchical mode is deprecated. \"",
            "\t\t     \"Please report your usecase to linux-mm@kvack.org if you \"",
            "\t\t     \"depend on this functionality.\\n\");",
            "",
            "\treturn -EINVAL;",
            "}",
            "static u64 mem_cgroup_read_u64(struct cgroup_subsys_state *css,",
            "\t\t\t       struct cftype *cft)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);",
            "\tstruct page_counter *counter;",
            "",
            "\tswitch (MEMFILE_TYPE(cft->private)) {",
            "\tcase _MEM:",
            "\t\tcounter = &memcg->memory;",
            "\t\tbreak;",
            "\tcase _MEMSWAP:",
            "\t\tcounter = &memcg->memsw;",
            "\t\tbreak;",
            "\tcase _KMEM:",
            "\t\tcounter = &memcg->kmem;",
            "\t\tbreak;",
            "\tcase _TCP:",
            "\t\tcounter = &memcg->tcpmem;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\tswitch (MEMFILE_ATTR(cft->private)) {",
            "\tcase RES_USAGE:",
            "\t\tif (counter == &memcg->memory)",
            "\t\t\treturn (u64)mem_cgroup_usage(memcg, false) * PAGE_SIZE;",
            "\t\tif (counter == &memcg->memsw)",
            "\t\t\treturn (u64)mem_cgroup_usage(memcg, true) * PAGE_SIZE;",
            "\t\treturn (u64)page_counter_read(counter) * PAGE_SIZE;",
            "\tcase RES_LIMIT:",
            "\t\treturn (u64)counter->max * PAGE_SIZE;",
            "\tcase RES_MAX_USAGE:",
            "\t\treturn (u64)counter->watermark * PAGE_SIZE;",
            "\tcase RES_FAILCNT:",
            "\t\treturn counter->failcnt;",
            "\tcase RES_SOFT_LIMIT:",
            "\t\treturn (u64)READ_ONCE(memcg->soft_limit) * PAGE_SIZE;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "static int mem_cgroup_dummy_seq_show(__always_unused struct seq_file *m,",
            "\t\t\t\t     __always_unused void *v)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int memcg_update_tcp_max(struct mem_cgroup *memcg, unsigned long max)",
            "{",
            "\tint ret;",
            "",
            "\tmutex_lock(&memcg_max_mutex);",
            "",
            "\tret = page_counter_set_max(&memcg->tcpmem, max);",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tif (!memcg->tcpmem_active) {",
            "\t\t/*",
            "\t\t * The active flag needs to be written after the static_key",
            "\t\t * update. This is what guarantees that the socket activation",
            "\t\t * function is the last one to run. See mem_cgroup_sk_alloc()",
            "\t\t * for details, and note that we don't mark any socket as",
            "\t\t * belonging to this memcg until that flag is up.",
            "\t\t *",
            "\t\t * We need to do this, because static_keys will span multiple",
            "\t\t * sites, but we can't control their order. If we mark a socket",
            "\t\t * as accounted, but the accounting functions are not patched in",
            "\t\t * yet, we'll lose accounting.",
            "\t\t *",
            "\t\t * We never race with the readers in mem_cgroup_sk_alloc(),",
            "\t\t * because when this value change, the code to process it is not",
            "\t\t * patched in yet.",
            "\t\t */",
            "\t\tstatic_branch_inc(&memcg_sockets_enabled_key);",
            "\t\tmemcg->tcpmem_active = true;",
            "\t}",
            "out:",
            "\tmutex_unlock(&memcg_max_mutex);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "mem_cgroup_force_empty, mem_cgroup_force_empty_write, mem_cgroup_hierarchy_read, mem_cgroup_hierarchy_write, mem_cgroup_read_u64, mem_cgroup_dummy_seq_show, memcg_update_tcp_max",
          "description": "提供内存控制组的强制清空、层级参数读写及统计信息查询功能。包含内存使用量读取接口、虚拟内存软限制更新及TCP内存上限调整逻辑，支持不同资源类型的计数器访问。",
          "similarity": 0.617473840713501
        },
        {
          "chunk_id": 10,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 1544,
          "end_line": 1646,
          "content": [
            "static ssize_t mem_cgroup_write(struct kernfs_open_file *of,",
            "\t\t\t\tchar *buf, size_t nbytes, loff_t off)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));",
            "\tunsigned long nr_pages;",
            "\tint ret;",
            "",
            "\tbuf = strstrip(buf);",
            "\tret = page_counter_memparse(buf, \"-1\", &nr_pages);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {",
            "\tcase RES_LIMIT:",
            "\t\tif (mem_cgroup_is_root(memcg)) { /* Can't set limit on root */",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {",
            "\t\tcase _MEM:",
            "\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, false);",
            "\t\t\tbreak;",
            "\t\tcase _MEMSWAP:",
            "\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, true);",
            "\t\t\tbreak;",
            "\t\tcase _KMEM:",
            "\t\t\tpr_warn_once(\"kmem.limit_in_bytes is deprecated and will be removed. \"",
            "\t\t\t\t     \"Writing any value to this file has no effect. \"",
            "\t\t\t\t     \"Please report your usecase to linux-mm@kvack.org if you \"",
            "\t\t\t\t     \"depend on this functionality.\\n\");",
            "\t\t\tret = 0;",
            "\t\t\tbreak;",
            "\t\tcase _TCP:",
            "\t\t\tret = memcg_update_tcp_max(memcg, nr_pages);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase RES_SOFT_LIMIT:",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\t\tret = -EOPNOTSUPP;",
            "\t\t} else {",
            "\t\t\tWRITE_ONCE(memcg->soft_limit, nr_pages);",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t\tbreak;",
            "\t}",
            "\treturn ret ?: nbytes;",
            "}",
            "static ssize_t mem_cgroup_reset(struct kernfs_open_file *of, char *buf,",
            "\t\t\t\tsize_t nbytes, loff_t off)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));",
            "\tstruct page_counter *counter;",
            "",
            "\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {",
            "\tcase _MEM:",
            "\t\tcounter = &memcg->memory;",
            "\t\tbreak;",
            "\tcase _MEMSWAP:",
            "\t\tcounter = &memcg->memsw;",
            "\t\tbreak;",
            "\tcase _KMEM:",
            "\t\tcounter = &memcg->kmem;",
            "\t\tbreak;",
            "\tcase _TCP:",
            "\t\tcounter = &memcg->tcpmem;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {",
            "\tcase RES_MAX_USAGE:",
            "\t\tpage_counter_reset_watermark(counter);",
            "\t\tbreak;",
            "\tcase RES_FAILCNT:",
            "\t\tcounter->failcnt = 0;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\treturn nbytes;",
            "}",
            "static unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,",
            "\t\t\t\tint nid, unsigned int lru_mask, bool tree)",
            "{",
            "\tstruct lruvec *lruvec = mem_cgroup_lruvec(memcg, NODE_DATA(nid));",
            "\tunsigned long nr = 0;",
            "\tenum lru_list lru;",
            "",
            "\tVM_BUG_ON((unsigned)nid >= nr_node_ids);",
            "",
            "\tfor_each_lru(lru) {",
            "\t\tif (!(BIT(lru) & lru_mask))",
            "\t\t\tcontinue;",
            "\t\tif (tree)",
            "\t\t\tnr += lruvec_page_state(lruvec, NR_LRU_BASE + lru);",
            "\t\telse",
            "\t\t\tnr += lruvec_page_state_local(lruvec, NR_LRU_BASE + lru);",
            "\t}",
            "\treturn nr;",
            "}"
          ],
          "function_name": "mem_cgroup_write, mem_cgroup_reset, mem_cgroup_node_nr_lru_pages",
          "description": "实现内存控制组的写操作接口，根据不同的属性类型设置内存限制（如RES_LIMIT、RES_SOFT_LIMIT），对根控制组禁止设置限制并处理相应错误码。",
          "similarity": 0.6051229238510132
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 109,
          "end_line": 216,
          "content": [
            "static void __mem_cgroup_insert_exceeded(struct mem_cgroup_per_node *mz,",
            "\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz,",
            "\t\t\t\t\t unsigned long new_usage_in_excess)",
            "{",
            "\tstruct rb_node **p = &mctz->rb_root.rb_node;",
            "\tstruct rb_node *parent = NULL;",
            "\tstruct mem_cgroup_per_node *mz_node;",
            "\tbool rightmost = true;",
            "",
            "\tif (mz->on_tree)",
            "\t\treturn;",
            "",
            "\tmz->usage_in_excess = new_usage_in_excess;",
            "\tif (!mz->usage_in_excess)",
            "\t\treturn;",
            "\twhile (*p) {",
            "\t\tparent = *p;",
            "\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_node,",
            "\t\t\t\t\ttree_node);",
            "\t\tif (mz->usage_in_excess < mz_node->usage_in_excess) {",
            "\t\t\tp = &(*p)->rb_left;",
            "\t\t\trightmost = false;",
            "\t\t} else {",
            "\t\t\tp = &(*p)->rb_right;",
            "\t\t}",
            "\t}",
            "",
            "\tif (rightmost)",
            "\t\tmctz->rb_rightmost = &mz->tree_node;",
            "",
            "\trb_link_node(&mz->tree_node, parent, p);",
            "\trb_insert_color(&mz->tree_node, &mctz->rb_root);",
            "\tmz->on_tree = true;",
            "}",
            "static void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,",
            "\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)",
            "{",
            "\tif (!mz->on_tree)",
            "\t\treturn;",
            "",
            "\tif (&mz->tree_node == mctz->rb_rightmost)",
            "\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);",
            "",
            "\trb_erase(&mz->tree_node, &mctz->rb_root);",
            "\tmz->on_tree = false;",
            "}",
            "static void mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,",
            "\t\t\t\t       struct mem_cgroup_tree_per_node *mctz)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&mctz->lock, flags);",
            "\t__mem_cgroup_remove_exceeded(mz, mctz);",
            "\tspin_unlock_irqrestore(&mctz->lock, flags);",
            "}",
            "static unsigned long soft_limit_excess(struct mem_cgroup *memcg)",
            "{",
            "\tunsigned long nr_pages = page_counter_read(&memcg->memory);",
            "\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);",
            "\tunsigned long excess = 0;",
            "",
            "\tif (nr_pages > soft_limit)",
            "\t\texcess = nr_pages - soft_limit;",
            "",
            "\treturn excess;",
            "}",
            "static void memcg1_update_tree(struct mem_cgroup *memcg, int nid)",
            "{",
            "\tunsigned long excess;",
            "\tstruct mem_cgroup_per_node *mz;",
            "\tstruct mem_cgroup_tree_per_node *mctz;",
            "",
            "\tif (lru_gen_enabled()) {",
            "\t\tif (soft_limit_excess(memcg))",
            "\t\t\tlru_gen_soft_reclaim(memcg, nid);",
            "\t\treturn;",
            "\t}",
            "",
            "\tmctz = soft_limit_tree.rb_tree_per_node[nid];",
            "\tif (!mctz)",
            "\t\treturn;",
            "\t/*",
            "\t * Necessary to update all ancestors when hierarchy is used.",
            "\t * because their event counter is not touched.",
            "\t */",
            "\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {",
            "\t\tmz = memcg->nodeinfo[nid];",
            "\t\texcess = soft_limit_excess(memcg);",
            "\t\t/*",
            "\t\t * We have to update the tree if mz is on RB-tree or",
            "\t\t * mem is over its softlimit.",
            "\t\t */",
            "\t\tif (excess || mz->on_tree) {",
            "\t\t\tunsigned long flags;",
            "",
            "\t\t\tspin_lock_irqsave(&mctz->lock, flags);",
            "\t\t\t/* if on-tree, remove it */",
            "\t\t\tif (mz->on_tree)",
            "\t\t\t\t__mem_cgroup_remove_exceeded(mz, mctz);",
            "\t\t\t/*",
            "\t\t\t * Insert again. mz->usage_in_excess will be updated.",
            "\t\t\t * If excess is 0, no tree ops.",
            "\t\t\t */",
            "\t\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);",
            "\t\t\tspin_unlock_irqrestore(&mctz->lock, flags);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "__mem_cgroup_insert_exceeded, __mem_cgroup_remove_exceeded, mem_cgroup_remove_exceeded, soft_limit_excess, memcg1_update_tree",
          "description": "实现RB树操作函数，用于将超出软限制的内存控制组节点插入或删除到RB树中，同时维护树的右极值指针，并通过遍历层级更新树结构以反映当前软限制状态。",
          "similarity": 0.5708149671554565
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 404,
          "end_line": 520,
          "content": [
            "static u64 mem_cgroup_move_charge_read(struct cgroup_subsys_state *css,",
            "\t\t\t\tstruct cftype *cft)",
            "{",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,",
            "\t\t\t\t struct cftype *cft, u64 val)",
            "{",
            "\tpr_warn_once(\"Cgroup memory moving (move_charge_at_immigrate) is deprecated. \"",
            "\t\t     \"Please report your usecase to linux-mm@kvack.org if you \"",
            "\t\t     \"depend on this functionality.\\n\");",
            "",
            "\tif (val != 0)",
            "\t\treturn -EINVAL;",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,",
            "\t\t\t\t struct cftype *cft, u64 val)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "static void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)",
            "{",
            "\tstruct mem_cgroup_threshold_ary *t;",
            "\tunsigned long usage;",
            "\tint i;",
            "",
            "\trcu_read_lock();",
            "\tif (!swap)",
            "\t\tt = rcu_dereference(memcg->thresholds.primary);",
            "\telse",
            "\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);",
            "",
            "\tif (!t)",
            "\t\tgoto unlock;",
            "",
            "\tusage = mem_cgroup_usage(memcg, swap);",
            "",
            "\t/*",
            "\t * current_threshold points to threshold just below or equal to usage.",
            "\t * If it's not true, a threshold was crossed after last",
            "\t * call of __mem_cgroup_threshold().",
            "\t */",
            "\ti = t->current_threshold;",
            "",
            "\t/*",
            "\t * Iterate backward over array of thresholds starting from",
            "\t * current_threshold and check if a threshold is crossed.",
            "\t * If none of thresholds below usage is crossed, we read",
            "\t * only one element of the array here.",
            "\t */",
            "\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)",
            "\t\teventfd_signal(t->entries[i].eventfd);",
            "",
            "\t/* i = current_threshold + 1 */",
            "\ti++;",
            "",
            "\t/*",
            "\t * Iterate forward over array of thresholds starting from",
            "\t * current_threshold+1 and check if a threshold is crossed.",
            "\t * If none of thresholds above usage is crossed, we read",
            "\t * only one element of the array here.",
            "\t */",
            "\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)",
            "\t\teventfd_signal(t->entries[i].eventfd);",
            "",
            "\t/* Update current_threshold */",
            "\tt->current_threshold = i - 1;",
            "unlock:",
            "\trcu_read_unlock();",
            "}",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg)",
            "{",
            "\twhile (memcg) {",
            "\t\t__mem_cgroup_threshold(memcg, false);",
            "\t\tif (do_memsw_account())",
            "\t\t\t__mem_cgroup_threshold(memcg, true);",
            "",
            "\t\tmemcg = parent_mem_cgroup(memcg);",
            "\t}",
            "}",
            "static void memcg1_charge_statistics(struct mem_cgroup *memcg, int nr_pages)",
            "{",
            "\t/* pagein of a big page is an event. So, ignore page size */",
            "\tif (nr_pages > 0)",
            "\t\t__count_memcg_events(memcg, PGPGIN, 1);",
            "\telse {",
            "\t\t__count_memcg_events(memcg, PGPGOUT, 1);",
            "\t\tnr_pages = -nr_pages; /* for event */",
            "\t}",
            "",
            "\t__this_cpu_add(memcg->events_percpu->nr_page_events, nr_pages);",
            "}",
            "static bool memcg1_event_ratelimit(struct mem_cgroup *memcg,",
            "\t\t\t\tenum mem_cgroup_events_target target)",
            "{",
            "\tunsigned long val, next;",
            "",
            "\tval = __this_cpu_read(memcg->events_percpu->nr_page_events);",
            "\tnext = __this_cpu_read(memcg->events_percpu->targets[target]);",
            "\t/* from time_after() in jiffies.h */",
            "\tif ((long)(next - val) < 0) {",
            "\t\tswitch (target) {",
            "\t\tcase MEM_CGROUP_TARGET_THRESH:",
            "\t\t\tnext = val + THRESHOLDS_EVENTS_TARGET;",
            "\t\t\tbreak;",
            "\t\tcase MEM_CGROUP_TARGET_SOFTLIMIT:",
            "\t\t\tnext = val + SOFTLIMIT_EVENTS_TARGET;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t__this_cpu_write(memcg->events_percpu->targets[target], next);",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}"
          ],
          "function_name": "mem_cgroup_move_charge_read, mem_cgroup_move_charge_write, mem_cgroup_move_charge_write, __mem_cgroup_threshold, mem_cgroup_threshold, memcg1_charge_statistics, memcg1_event_ratelimit",
          "description": "实现内存使用阈值监测与事件触发机制，包含阈值比较排序、事件信号发送及页面事件统计功能，通过事件限速机制控制通知频率，支持软限制和交换空间双重阈值监控。",
          "similarity": 0.5671486258506775
        },
        {
          "chunk_id": 2,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 222,
          "end_line": 364,
          "content": [
            "void memcg1_remove_from_trees(struct mem_cgroup *memcg)",
            "{",
            "\tstruct mem_cgroup_tree_per_node *mctz;",
            "\tstruct mem_cgroup_per_node *mz;",
            "\tint nid;",
            "",
            "\tfor_each_node(nid) {",
            "\t\tmz = memcg->nodeinfo[nid];",
            "\t\tmctz = soft_limit_tree.rb_tree_per_node[nid];",
            "\t\tif (mctz)",
            "\t\t\tmem_cgroup_remove_exceeded(mz, mctz);",
            "\t}",
            "}",
            "static int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,",
            "\t\t\t\t   pg_data_t *pgdat,",
            "\t\t\t\t   gfp_t gfp_mask,",
            "\t\t\t\t   unsigned long *total_scanned)",
            "{",
            "\tstruct mem_cgroup *victim = NULL;",
            "\tint total = 0;",
            "\tint loop = 0;",
            "\tunsigned long excess;",
            "\tunsigned long nr_scanned;",
            "\tstruct mem_cgroup_reclaim_cookie reclaim = {",
            "\t\t.pgdat = pgdat,",
            "\t};",
            "",
            "\texcess = soft_limit_excess(root_memcg);",
            "",
            "\twhile (1) {",
            "\t\tvictim = mem_cgroup_iter(root_memcg, victim, &reclaim);",
            "\t\tif (!victim) {",
            "\t\t\tloop++;",
            "\t\t\tif (loop >= 2) {",
            "\t\t\t\t/*",
            "\t\t\t\t * If we have not been able to reclaim",
            "\t\t\t\t * anything, it might because there are",
            "\t\t\t\t * no reclaimable pages under this hierarchy",
            "\t\t\t\t */",
            "\t\t\t\tif (!total)",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t/*",
            "\t\t\t\t * We want to do more targeted reclaim.",
            "\t\t\t\t * excess >> 2 is not to excessive so as to",
            "\t\t\t\t * reclaim too much, nor too less that we keep",
            "\t\t\t\t * coming back to reclaim from this cgroup",
            "\t\t\t\t */",
            "\t\t\t\tif (total >= (excess >> 2) ||",
            "\t\t\t\t\t(loop > MEM_CGROUP_MAX_RECLAIM_LOOPS))",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\ttotal += mem_cgroup_shrink_node(victim, gfp_mask, false,",
            "\t\t\t\t\tpgdat, &nr_scanned);",
            "\t\t*total_scanned += nr_scanned;",
            "\t\tif (!soft_limit_excess(root_memcg))",
            "\t\t\tbreak;",
            "\t}",
            "\tmem_cgroup_iter_break(root_memcg, victim);",
            "\treturn total;",
            "}",
            "unsigned long memcg1_soft_limit_reclaim(pg_data_t *pgdat, int order,",
            "\t\t\t\t\t    gfp_t gfp_mask,",
            "\t\t\t\t\t    unsigned long *total_scanned)",
            "{",
            "\tunsigned long nr_reclaimed = 0;",
            "\tstruct mem_cgroup_per_node *mz, *next_mz = NULL;",
            "\tunsigned long reclaimed;",
            "\tint loop = 0;",
            "\tstruct mem_cgroup_tree_per_node *mctz;",
            "\tunsigned long excess;",
            "",
            "\tif (lru_gen_enabled())",
            "\t\treturn 0;",
            "",
            "\tif (order > 0)",
            "\t\treturn 0;",
            "",
            "\tmctz = soft_limit_tree.rb_tree_per_node[pgdat->node_id];",
            "",
            "\t/*",
            "\t * Do not even bother to check the largest node if the root",
            "\t * is empty. Do it lockless to prevent lock bouncing. Races",
            "\t * are acceptable as soft limit is best effort anyway.",
            "\t */",
            "\tif (!mctz || RB_EMPTY_ROOT(&mctz->rb_root))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * This loop can run a while, specially if mem_cgroup's continuously",
            "\t * keep exceeding their soft limit and putting the system under",
            "\t * pressure",
            "\t */",
            "\tdo {",
            "\t\tif (next_mz)",
            "\t\t\tmz = next_mz;",
            "\t\telse",
            "\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);",
            "\t\tif (!mz)",
            "\t\t\tbreak;",
            "",
            "\t\treclaimed = mem_cgroup_soft_reclaim(mz->memcg, pgdat,",
            "\t\t\t\t\t\t    gfp_mask, total_scanned);",
            "\t\tnr_reclaimed += reclaimed;",
            "\t\tspin_lock_irq(&mctz->lock);",
            "",
            "\t\t/*",
            "\t\t * If we failed to reclaim anything from this memory cgroup",
            "\t\t * it is time to move on to the next cgroup",
            "\t\t */",
            "\t\tnext_mz = NULL;",
            "\t\tif (!reclaimed)",
            "\t\t\tnext_mz = __mem_cgroup_largest_soft_limit_node(mctz);",
            "",
            "\t\texcess = soft_limit_excess(mz->memcg);",
            "\t\t/*",
            "\t\t * One school of thought says that we should not add",
            "\t\t * back the node to the tree if reclaim returns 0.",
            "\t\t * But our reclaim could return 0, simply because due",
            "\t\t * to priority we are exposing a smaller subset of",
            "\t\t * memory to reclaim from. Consider this as a longer",
            "\t\t * term TODO.",
            "\t\t */",
            "\t\t/* If excess == 0, no tree ops */",
            "\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);",
            "\t\tspin_unlock_irq(&mctz->lock);",
            "\t\tcss_put(&mz->memcg->css);",
            "\t\tloop++;",
            "\t\t/*",
            "\t\t * Could not reclaim anything and there are no more",
            "\t\t * mem cgroups to try or we seem to be looping without",
            "\t\t * reclaiming anything.",
            "\t\t */",
            "\t\tif (!nr_reclaimed &&",
            "\t\t\t(next_mz == NULL ||",
            "\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))",
            "\t\t\tbreak;",
            "\t} while (!nr_reclaimed);",
            "\tif (next_mz)",
            "\t\tcss_put(&next_mz->memcg->css);",
            "\treturn nr_reclaimed;",
            "}"
          ],
          "function_name": "memcg1_remove_from_trees, mem_cgroup_soft_reclaim, memcg1_soft_limit_reclaim",
          "description": "提供内存回收逻辑，当内存控制组超过软限制时，通过迭代寻找目标cgroup执行内存回收操作，并通过循环控制防止无限回收，最终返回回收的页面数量。",
          "similarity": 0.5408110618591309
        }
      ]
    },
    {
      "source_file": "mm/damon/lru_sort.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:47:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `damon\\lru_sort.c`\n\n---\n\n# `damon/lru_sort.c` 技术文档\n\n## 1. 文件概述\n\n`damon/lru_sort.c` 是 Linux 内核中基于 DAMON（Data Access MONitor）框架实现的一个内核模块，用于根据内存访问模式动态调整页面在 LRU（Least Recently Used）列表中的优先级。该模块通过监控内存区域的访问频率和空闲时间，将“热”页面标记为高优先级（防止被回收），将“冷”页面标记为低优先级（优先回收），从而优化内存回收效率。模块行为受水位线（watermarks）机制控制，仅在系统空闲内存低于特定阈值时激活。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`enabled`**: 控制模块是否启用的布尔标志。\n- **`commit_inputs`**: 触发运行时参数重载的布尔标志。\n- **`hot_thres_access_freq`**: 热内存区域的访问频率阈值（单位：千分比，默认 500，即 50%）。\n- **`cold_min_age`**: 冷内存区域的最小未访问时间（单位：微秒，默认 120,000,000，即 120 秒）。\n- **`damon_lru_sort_quota`**: 操作配额限制，控制 DAMON 操作消耗的 CPU 时间（默认每秒最多 10 毫秒）。\n- **`damon_lru_sort_wmarks`**: 水位线配置，基于空闲内存率决定模块是否激活（高/中/低阈值分别为 20%/15%/5%）。\n- **`damon_lru_sort_mon_attrs`**: DAMON 监控属性，包括采样间隔、聚合间隔等。\n- **`monitor_region_start/monitor_region_end`**: 监控的物理内存区域范围（默认为最大 System RAM 区域）。\n- **`kdamond_pid`**: DAMON 工作线程的 PID（启用时有效，否则为 -1）。\n- **`damon_lru_sort_hot_stat` / `damon_lru_sort_cold_stat`**: 热/冷页面操作的统计信息。\n- **`damon_lru_sort_stub_pattern`**: 基础访问模式模板，用于构建热/冷识别规则。\n\n### 主要函数\n- **`damon_lru_sort_new_scheme()`**: 创建通用的 DAMOS（DAMON Operation Scheme）方案。\n- **`damon_lru_sort_new_hot_scheme()`**: 创建用于识别并提升热页面优先级的方案（`DAMOS_LRU_PRIO`）。\n- **`damon_lru_sort_new_cold_scheme()`**: 创建用于识别并降低冷页面优先级的方案（`DAMOS_LRU_DEPRIO`）。\n- **`damon_lru_sort_copy_quota_status()`**: 复制配额使用状态，用于方案更新时保留历史配额信息。\n- **`damon_lru_sort_apply_parameters()`**: 应用当前模块参数到 DAMON 上下文，包括监控属性、操作方案和监控区域。\n- **`damon_lru_sort_turn()`**: 启用或禁用 DAMON LRU 排序功能。\n- **`damon_lru_sort_enabled_store()`**: 处理 `enabled` 参数的写入（代码片段截断，但功能为切换模块状态）。\n\n## 3. 关键实现\n\n- **热/冷页面识别**：\n  - **热页面**：在聚合间隔内访问次数 ≥ `hot_thres_access_freq`（转换为 DAMON 访问计数阈值）。\n  - **冷页面**：未被访问的时间 ≥ `cold_min_age`（转换为以聚合间隔为单位的年龄阈值）。\n  \n- **LRU 优先级调整**：\n  - 热页面通过 `DAMOS_LRU_PRIO` 动作标记为已访问，提升其在 LRU 列表中的位置。\n  - 冷页面通过 `DAMOS_LRU_DEPRIO` 动作标记为未访问，降低其优先级以便优先回收。\n\n- **资源控制**：\n  - 使用 `damos_quota` 限制操作开销（默认每秒最多 10ms CPU 时间），热/冷方案各分配一半配额。\n  - 配额状态在方案更新时保留，避免因参数重载导致配额重置。\n\n- **条件激活**：\n  - 通过 `damos_watermarks` 实现基于空闲内存率的自动启停：\n    - 空闲内存率 ≤ 低水位（5%）时激活；\n    - ≥ 高水位（20%）时停用；\n    - 在中/低水位间保持当前状态。\n\n- **参数动态更新**：\n  - 除 `enabled` 外的参数修改后，需设置 `commit_inputs=Y` 触发重载。\n  - 重载失败（如参数无效）将导致模块自动禁用。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `linux/damon.h`：DAMON 框架核心 API。\n  - `modules-common.h`：DAMON 模块通用宏和辅助函数（如 `DEFINE_DAMON_MODULES_*` 宏）。\n- **内核子系统**：\n  - 内存管理子系统（LRU 列表操作）。\n  - 进程调度（DAMON 工作线程 `kdamond`）。\n- **配置接口**：\n  - 通过 `module_param` 提供 `/sys/module/damon_lru_sort/parameters/` 下的运行时配置。\n\n## 5. 使用场景\n\n- **内存压力下的页面回收优化**：在系统内存紧张时，自动将长期未使用的冷页面置于 LRU 列表前端，加速其回收；同时保护频繁访问的热页面不被误回收。\n- **透明大页（THP）友好**：通过基于访问模式的 LRU 调整，减少对 THP 的干扰。\n- **低开销内存监控**：利用 DAMON 的自适应区域拆分/合并机制，在有限 CPU 开销（默认 ≤10ms/s）下实现高效监控。\n- **容器/虚拟化环境**：适用于多租户场景，动态优化各 workload 的内存使用效率。\n- **嵌入式/实时系统**：通过严格配额控制，确保内存优化操作不影响关键任务实时性。",
      "similarity": 0.5450892448425293,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/damon/lru_sort.c",
          "start_line": 188,
          "end_line": 289,
          "content": [
            "static void damon_lru_sort_copy_quota_status(struct damos_quota *dst,",
            "\t\tstruct damos_quota *src)",
            "{",
            "\tdst->total_charged_sz = src->total_charged_sz;",
            "\tdst->total_charged_ns = src->total_charged_ns;",
            "\tdst->charged_sz = src->charged_sz;",
            "\tdst->charged_from = src->charged_from;",
            "\tdst->charge_target_from = src->charge_target_from;",
            "\tdst->charge_addr_from = src->charge_addr_from;",
            "}",
            "static int damon_lru_sort_apply_parameters(void)",
            "{",
            "\tstruct damos *scheme, *hot_scheme, *cold_scheme;",
            "\tstruct damos *old_hot_scheme = NULL, *old_cold_scheme = NULL;",
            "\tunsigned int hot_thres, cold_thres;",
            "\tint err = 0;",
            "",
            "\terr = damon_set_attrs(ctx, &damon_lru_sort_mon_attrs);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tdamon_for_each_scheme(scheme, ctx) {",
            "\t\tif (!old_hot_scheme) {",
            "\t\t\told_hot_scheme = scheme;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\told_cold_scheme = scheme;",
            "\t}",
            "",
            "\thot_thres = damon_max_nr_accesses(&damon_lru_sort_mon_attrs) *",
            "\t\thot_thres_access_freq / 1000;",
            "\thot_scheme = damon_lru_sort_new_hot_scheme(hot_thres);",
            "\tif (!hot_scheme)",
            "\t\treturn -ENOMEM;",
            "\tif (old_hot_scheme)",
            "\t\tdamon_lru_sort_copy_quota_status(&hot_scheme->quota,",
            "\t\t\t\t&old_hot_scheme->quota);",
            "",
            "\tcold_thres = cold_min_age / damon_lru_sort_mon_attrs.aggr_interval;",
            "\tcold_scheme = damon_lru_sort_new_cold_scheme(cold_thres);",
            "\tif (!cold_scheme) {",
            "\t\tdamon_destroy_scheme(hot_scheme);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tif (old_cold_scheme)",
            "\t\tdamon_lru_sort_copy_quota_status(&cold_scheme->quota,",
            "\t\t\t\t&old_cold_scheme->quota);",
            "",
            "\tdamon_set_schemes(ctx, &hot_scheme, 1);",
            "\tdamon_add_scheme(ctx, cold_scheme);",
            "",
            "\treturn damon_set_region_biggest_system_ram_default(target,",
            "\t\t\t\t\t&monitor_region_start,",
            "\t\t\t\t\t&monitor_region_end);",
            "}",
            "static int damon_lru_sort_turn(bool on)",
            "{",
            "\tint err;",
            "",
            "\tif (!on) {",
            "\t\terr = damon_stop(&ctx, 1);",
            "\t\tif (!err)",
            "\t\t\tkdamond_pid = -1;",
            "\t\treturn err;",
            "\t}",
            "",
            "\terr = damon_lru_sort_apply_parameters();",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = damon_start(&ctx, 1, true);",
            "\tif (err)",
            "\t\treturn err;",
            "\tkdamond_pid = ctx->kdamond->pid;",
            "\treturn 0;",
            "}",
            "static int damon_lru_sort_enabled_store(const char *val,",
            "\t\tconst struct kernel_param *kp)",
            "{",
            "\tbool is_enabled = enabled;",
            "\tbool enable;",
            "\tint err;",
            "",
            "\terr = kstrtobool(val, &enable);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (is_enabled == enable)",
            "\t\treturn 0;",
            "",
            "\t/* Called before init function.  The function will handle this. */",
            "\tif (!ctx)",
            "\t\tgoto set_param_out;",
            "",
            "\terr = damon_lru_sort_turn(enable);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "set_param_out:",
            "\tenabled = enable;",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_lru_sort_copy_quota_status, damon_lru_sort_apply_parameters, damon_lru_sort_turn, damon_lru_sort_enabled_store",
          "description": "实现动态参数应用、方案创建与切换逻辑，通过复制配额状态、构建热点/冷点筛选策略，并通过回调机制控制LRU列表优先级调整。",
          "similarity": 0.5155534744262695
        },
        {
          "chunk_id": 0,
          "file_path": "mm/damon/lru_sort.c",
          "start_line": 1,
          "end_line": 187,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * DAMON-based LRU-lists Sorting",
            " *",
            " * Author: SeongJae Park <sj@kernel.org>",
            " */",
            "",
            "#define pr_fmt(fmt) \"damon-lru-sort: \" fmt",
            "",
            "#include <linux/damon.h>",
            "#include <linux/kstrtox.h>",
            "#include <linux/module.h>",
            "",
            "#include \"modules-common.h\"",
            "",
            "#ifdef MODULE_PARAM_PREFIX",
            "#undef MODULE_PARAM_PREFIX",
            "#endif",
            "#define MODULE_PARAM_PREFIX \"damon_lru_sort.\"",
            "",
            "/*",
            " * Enable or disable DAMON_LRU_SORT.",
            " *",
            " * You can enable DAMON_LRU_SORT by setting the value of this parameter as",
            " * ``Y``.  Setting it as ``N`` disables DAMON_LRU_SORT.  Note that",
            " * DAMON_LRU_SORT could do no real monitoring and LRU-lists sorting due to the",
            " * watermarks-based activation condition.  Refer to below descriptions for the",
            " * watermarks parameter for this.",
            " */",
            "static bool enabled __read_mostly;",
            "",
            "/*",
            " * Make DAMON_LRU_SORT reads the input parameters again, except ``enabled``.",
            " *",
            " * Input parameters that updated while DAMON_LRU_SORT is running are not",
            " * applied by default.  Once this parameter is set as ``Y``, DAMON_LRU_SORT",
            " * reads values of parametrs except ``enabled`` again.  Once the re-reading is",
            " * done, this parameter is set as ``N``.  If invalid parameters are found while",
            " * the re-reading, DAMON_LRU_SORT will be disabled.",
            " */",
            "static bool commit_inputs __read_mostly;",
            "module_param(commit_inputs, bool, 0600);",
            "",
            "/*",
            " * Access frequency threshold for hot memory regions identification in permil.",
            " *",
            " * If a memory region is accessed in frequency of this or higher,",
            " * DAMON_LRU_SORT identifies the region as hot, and mark it as accessed on the",
            " * LRU list, so that it could not be reclaimed under memory pressure.  50% by",
            " * default.",
            " */",
            "static unsigned long hot_thres_access_freq = 500;",
            "module_param(hot_thres_access_freq, ulong, 0600);",
            "",
            "/*",
            " * Time threshold for cold memory regions identification in microseconds.",
            " *",
            " * If a memory region is not accessed for this or longer time, DAMON_LRU_SORT",
            " * identifies the region as cold, and mark it as unaccessed on the LRU list, so",
            " * that it could be reclaimed first under memory pressure.  120 seconds by",
            " * default.",
            " */",
            "static unsigned long cold_min_age __read_mostly = 120000000;",
            "module_param(cold_min_age, ulong, 0600);",
            "",
            "static struct damos_quota damon_lru_sort_quota = {",
            "\t/* Use up to 10 ms per 1 sec, by default */",
            "\t.ms = 10,",
            "\t.sz = 0,",
            "\t.reset_interval = 1000,",
            "\t/* Within the quota, mark hotter regions accessed first. */",
            "\t.weight_sz = 0,",
            "\t.weight_nr_accesses = 1,",
            "\t.weight_age = 0,",
            "};",
            "DEFINE_DAMON_MODULES_DAMOS_TIME_QUOTA(damon_lru_sort_quota);",
            "",
            "static struct damos_watermarks damon_lru_sort_wmarks = {",
            "\t.metric = DAMOS_WMARK_FREE_MEM_RATE,",
            "\t.interval = 5000000,\t/* 5 seconds */",
            "\t.high = 200,\t\t/* 20 percent */",
            "\t.mid = 150,\t\t/* 15 percent */",
            "\t.low = 50,\t\t/* 5 percent */",
            "};",
            "DEFINE_DAMON_MODULES_WMARKS_PARAMS(damon_lru_sort_wmarks);",
            "",
            "static struct damon_attrs damon_lru_sort_mon_attrs = {",
            "\t.sample_interval = 5000,\t/* 5 ms */",
            "\t.aggr_interval = 100000,\t/* 100 ms */",
            "\t.ops_update_interval = 0,",
            "\t.min_nr_regions = 10,",
            "\t.max_nr_regions = 1000,",
            "};",
            "DEFINE_DAMON_MODULES_MON_ATTRS_PARAMS(damon_lru_sort_mon_attrs);",
            "",
            "/*",
            " * Start of the target memory region in physical address.",
            " *",
            " * The start physical address of memory region that DAMON_LRU_SORT will do work",
            " * against.  By default, biggest System RAM is used as the region.",
            " */",
            "static unsigned long monitor_region_start __read_mostly;",
            "module_param(monitor_region_start, ulong, 0600);",
            "",
            "/*",
            " * End of the target memory region in physical address.",
            " *",
            " * The end physical address of memory region that DAMON_LRU_SORT will do work",
            " * against.  By default, biggest System RAM is used as the region.",
            " */",
            "static unsigned long monitor_region_end __read_mostly;",
            "module_param(monitor_region_end, ulong, 0600);",
            "",
            "/*",
            " * PID of the DAMON thread",
            " *",
            " * If DAMON_LRU_SORT is enabled, this becomes the PID of the worker thread.",
            " * Else, -1.",
            " */",
            "static int kdamond_pid __read_mostly = -1;",
            "module_param(kdamond_pid, int, 0400);",
            "",
            "static struct damos_stat damon_lru_sort_hot_stat;",
            "DEFINE_DAMON_MODULES_DAMOS_STATS_PARAMS(damon_lru_sort_hot_stat,",
            "\t\tlru_sort_tried_hot_regions, lru_sorted_hot_regions,",
            "\t\thot_quota_exceeds);",
            "",
            "static struct damos_stat damon_lru_sort_cold_stat;",
            "DEFINE_DAMON_MODULES_DAMOS_STATS_PARAMS(damon_lru_sort_cold_stat,",
            "\t\tlru_sort_tried_cold_regions, lru_sorted_cold_regions,",
            "\t\tcold_quota_exceeds);",
            "",
            "static struct damos_access_pattern damon_lru_sort_stub_pattern = {",
            "\t/* Find regions having PAGE_SIZE or larger size */",
            "\t.min_sz_region = PAGE_SIZE,",
            "\t.max_sz_region = ULONG_MAX,",
            "\t/* no matter its access frequency */",
            "\t.min_nr_accesses = 0,",
            "\t.max_nr_accesses = UINT_MAX,",
            "\t/* no matter its age */",
            "\t.min_age_region = 0,",
            "\t.max_age_region = UINT_MAX,",
            "};",
            "",
            "static struct damon_ctx *ctx;",
            "static struct damon_target *target;",
            "",
            "static struct damos *damon_lru_sort_new_scheme(",
            "\t\tstruct damos_access_pattern *pattern, enum damos_action action)",
            "{",
            "\tstruct damos_quota quota = damon_lru_sort_quota;",
            "",
            "\t/* Use half of total quota for hot/cold pages sorting */",
            "\tquota.ms = quota.ms / 2;",
            "",
            "\treturn damon_new_scheme(",
            "\t\t\t/* find the pattern, and */",
            "\t\t\tpattern,",
            "\t\t\t/* (de)prioritize on LRU-lists */",
            "\t\t\taction,",
            "\t\t\t/* for each aggregation interval */",
            "\t\t\t0,",
            "\t\t\t/* under the quota. */",
            "\t\t\t&quota,",
            "\t\t\t/* (De)activate this according to the watermarks. */",
            "\t\t\t&damon_lru_sort_wmarks);",
            "}",
            "",
            "/* Create a DAMON-based operation scheme for hot memory regions */",
            "static struct damos *damon_lru_sort_new_hot_scheme(unsigned int hot_thres)",
            "{",
            "\tstruct damos_access_pattern pattern = damon_lru_sort_stub_pattern;",
            "",
            "\tpattern.min_nr_accesses = hot_thres;",
            "\treturn damon_lru_sort_new_scheme(&pattern, DAMOS_LRU_PRIO);",
            "}",
            "",
            "/* Create a DAMON-based operation scheme for cold memory regions */",
            "static struct damos *damon_lru_sort_new_cold_scheme(unsigned int cold_thres)",
            "{",
            "\tstruct damos_access_pattern pattern = damon_lru_sort_stub_pattern;",
            "",
            "\tpattern.max_nr_accesses = 0;",
            "\tpattern.min_age_region = cold_thres;",
            "\treturn damon_lru_sort_new_scheme(&pattern, DAMOS_LRU_DEPRIO);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义DAMON_LRU_SORT模块的配置参数和数据结构，包括启用状态、访问频率阈值、冷区域时间阈值、配额策略及水位标记参数，初始化监控上下文和目标内存区域。",
          "similarity": 0.4764588177204132
        },
        {
          "chunk_id": 2,
          "file_path": "mm/damon/lru_sort.c",
          "start_line": 303,
          "end_line": 347,
          "content": [
            "static int damon_lru_sort_handle_commit_inputs(void)",
            "{",
            "\tint err;",
            "",
            "\tif (!commit_inputs)",
            "\t\treturn 0;",
            "",
            "\terr = damon_lru_sort_apply_parameters();",
            "\tcommit_inputs = false;",
            "\treturn err;",
            "}",
            "static int damon_lru_sort_after_aggregation(struct damon_ctx *c)",
            "{",
            "\tstruct damos *s;",
            "",
            "\t/* update the stats parameter */",
            "\tdamon_for_each_scheme(s, c) {",
            "\t\tif (s->action == DAMOS_LRU_PRIO)",
            "\t\t\tdamon_lru_sort_hot_stat = s->stat;",
            "\t\telse if (s->action == DAMOS_LRU_DEPRIO)",
            "\t\t\tdamon_lru_sort_cold_stat = s->stat;",
            "\t}",
            "",
            "\treturn damon_lru_sort_handle_commit_inputs();",
            "}",
            "static int damon_lru_sort_after_wmarks_check(struct damon_ctx *c)",
            "{",
            "\treturn damon_lru_sort_handle_commit_inputs();",
            "}",
            "static int __init damon_lru_sort_init(void)",
            "{",
            "\tint err = damon_modules_new_paddr_ctx_target(&ctx, &target);",
            "",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tctx->callback.after_wmarks_check = damon_lru_sort_after_wmarks_check;",
            "\tctx->callback.after_aggregation = damon_lru_sort_after_aggregation;",
            "",
            "\t/* 'enabled' has set before this function, probably via command line */",
            "\tif (enabled)",
            "\t\terr = damon_lru_sort_turn(true);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_lru_sort_handle_commit_inputs, damon_lru_sort_after_aggregation, damon_lru_sort_after_wmarks_check, damon_lru_sort_init",
          "description": "注册聚合后回调处理参数提交、水位检查后的参数同步，初始化模块时根据启用标志启动监控线程并绑定回调函数链表。",
          "similarity": 0.456153929233551
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/pids.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:50:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\pids.c`\n\n---\n\n# cgroup/pids.c 技术文档\n\n## 1. 文件概述\n\n`cgroup/pids.c` 实现了 Linux 内核中 cgroup 的 **PID 控制器（pids controller）**，用于限制指定 cgroup 及其子层级中可创建的最大进程（任务）数量。该控制器通过监控 `fork()` 系统调用，在进程数量即将超过设定阈值时拒绝创建新进程（返回 `-EAGAIN`），从而防止 PID 资源耗尽。该控制器支持层级继承语义，即子 cgroup 的有效限制为其自身与所有祖先中**最严格**的限制。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct pids_cgroup`**  \n  表示一个 cgroup 的 PID 控制状态，包含：\n  - `counter`：当前 cgroup 中的进程数量（64 位原子计数器）\n  - `limit`：允许的最大进程数（64 位原子值，`PIDS_MAX` 表示无限制）\n  - `watermark`：历史最高进程数（用于监控）\n  - `events` / `events_local`：事件计数器（如 `PIDCG_MAX`、`PIDCG_FORKFAIL`）\n  - `events_file` / `events_local_file`：用于通知用户空间事件发生的 cgroup 文件句柄\n\n- **`enum pidcg_event`**  \n  定义两类事件：\n  - `PIDCG_MAX`：因本 cgroup 或祖先限制被触发而导致 fork 失败\n  - `PIDCG_FORKFAIL`：在本 cgroup 中 fork 失败（用于本地事件通知）\n\n### 主要函数\n\n- **资源分配与释放**\n  - `pids_css_alloc()`：为新 cgroup 分配 `pids_cgroup` 结构，初始限制设为 `PIDS_MAX`（无限制）\n  - `pids_css_free()`：释放 `pids_cgroup` 结构\n\n- **计数操作**\n  - `pids_charge()`：**无条件**增加指定 cgroup 及其所有祖先的进程计数（用于回滚）\n  - `pids_uncharge()`：减少指定 cgroup 及其所有祖先的进程计数\n  - `pids_cancel()`：内部辅助函数，执行实际的原子减操作，并检查负值（视为 bug）\n  - `pids_try_charge()`：**有条件**增加计数，若任一祖先层级超过限制则回滚并返回 `-EAGAIN`\n\n- **cgroup 钩子函数**\n  - `pids_can_attach()`：在任务迁移到新 cgroup 时，更新源/目标 cgroup 的计数\n  - `pids_cancel_attach()`：回滚 `pids_can_attach()` 的操作\n  - `pids_can_fork()`：在 `fork()` 前检查是否允许创建新进程（未在提供的代码片段中完整显示）\n  - `pids_cancel_fork()`：回滚 fork 失败时的计数（未在提供的代码片段中完整显示）\n\n- **事件通知**\n  - `pids_event()`：当 fork 因 PID 限制失败时，记录事件并通知用户空间（通过 `cgroup_file_notify`）\n\n- **辅助函数**\n  - `css_pids()`：从 `cgroup_subsys_state` 转换为 `pids_cgroup`\n  - `parent_pids()`：获取父 cgroup 的 `pids_cgroup`\n  - `pids_update_watermark()`：更新历史最高进程数（非原子，容忍竞态）\n\n## 3. 关键实现\n\n### 层级限制语义\nPID 限制遵循 cgroup 的层级继承规则：一个进程的实际限制由其所在 cgroup 路径上**所有祖先中最小的 `limit` 值**决定。`pids_try_charge()` 在从当前 cgroup 向根方向遍历时，一旦发现任一祖先的 `counter + num > limit`，即判定为违反策略。\n\n### 原子计数与回滚机制\n- 所有计数操作均使用 `atomic64_t` 保证并发安全。\n- `pids_try_charge()` 采用“先增加后检查+回滚”策略：先原子增加所有祖先计数，再逐级检查是否超限。若超限，则从当前节点回滚到起始节点的所有增量。\n- `pids_charge()` 用于必须成功的场景（如 attach 回滚），**不检查限制**，允许临时超限。\n\n### 事件通知机制\n- 当 fork 因限制失败时，调用 `pids_event()`：\n  - 在 fork 发生的 cgroup 中记录 `PIDCG_FORKFAIL` 事件（仅首次触发时打印内核日志）\n  - 若启用了本地事件（通过 `cgroup v2` 的 `pids.local_events` 选项），则仅通知本地事件文件\n  - 否则，在**触发限制的祖先 cgroup** 中记录 `PIDCG_MAX` 事件，并向上传播通知\n\n### 无限制表示\n使用 `PIDS_MAX = PID_MAX_LIMIT + 1` 表示“无限制”，因为实际 PID 数量不可能超过 `PID_MAX_LIMIT`，因此该值可安全用于比较（`new > limit` 永远为假）。\n\n## 4. 依赖关系\n\n- **`<linux/cgroup.h>`**：cgroup 核心框架，提供 `cgroup_subsys_state`、`cgroup_taskset` 等基础结构和钩子函数接口\n- **`<linux/atomic.h>`**：提供 64 位原子操作（`atomic64_t`）\n- **`<linux/sched/task.h>`**：提供 `task_css()` 等任务与 cgroup 关联的接口\n- **`<linux/slab.h>`**：内存分配（`kzalloc`/`kfree`）\n- **`pids_cgrp_id`**：全局子系统 ID，用于从 `css_set` 或 `task_struct` 中获取 PID 控制器状态\n- **`cgroup_threadgroup_change_begin()`**：确保在 `fork` 过程中 cgroup 关联稳定（`pids_can_fork` 依赖此锁）\n\n## 5. 使用场景\n\n1. **容器资源隔离**  \n   在容器运行时（如 Docker、Podman）中限制单个容器或 Pod 可创建的最大进程数，防止 fork bomb 耗尽系统 PID 资源。\n\n2. **多租户系统防护**  \n   在共享主机环境中，为不同用户或服务分配独立的 cgroup，并设置 PID 限制，避免某一用户进程泛滥影响其他用户。\n\n3. **系统稳定性保障**  \n   通过全局或关键服务 cgroup 设置 PID 上限，确保即使某个子系统异常，也不会导致整个系统因 PID 耗尽而无法创建新进程。\n\n4. **监控与告警**  \n   通过读取 `pids.current`、`pids.max` 和 `pids.events` 文件，监控进程使用情况并在接近或达到限制时触发告警。",
      "similarity": 0.5409272909164429,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 355,
          "end_line": 394,
          "content": [
            "static s64 pids_current_read(struct cgroup_subsys_state *css,",
            "\t\t\t     struct cftype *cft)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "",
            "\treturn atomic64_read(&pids->counter);",
            "}",
            "static s64 pids_peak_read(struct cgroup_subsys_state *css,",
            "\t\t\t  struct cftype *cft)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "",
            "\treturn READ_ONCE(pids->watermark);",
            "}",
            "static int __pids_events_show(struct seq_file *sf, bool local)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(seq_css(sf));",
            "\tenum pidcg_event pe = PIDCG_MAX;",
            "\tatomic64_t *events;",
            "",
            "\tif (!cgroup_subsys_on_dfl(pids_cgrp_subsys) ||",
            "\t    cgrp_dfl_root.flags & CGRP_ROOT_PIDS_LOCAL_EVENTS) {",
            "\t\tpe = PIDCG_FORKFAIL;",
            "\t\tlocal = true;",
            "\t}",
            "\tevents = local ? pids->events_local : pids->events;",
            "",
            "\tseq_printf(sf, \"max %lld\\n\", (s64)atomic64_read(&events[pe]));",
            "\treturn 0;",
            "}",
            "static int pids_events_show(struct seq_file *sf, void *v)",
            "{",
            "\t__pids_events_show(sf, false);",
            "\treturn 0;",
            "}",
            "static int pids_events_local_show(struct seq_file *sf, void *v)",
            "{",
            "\t__pids_events_show(sf, true);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pids_current_read, pids_peak_read, __pids_events_show, pids_events_show, pids_events_local_show",
          "description": "暴露pids控制器的监控接口，包括当前任务数读取、历史峰值查询及事件统计展示。通过seq_file接口向用户空间导出运行时统计数据。",
          "similarity": 0.571458637714386
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 91,
          "end_line": 202,
          "content": [
            "static void pids_css_free(struct cgroup_subsys_state *css)",
            "{",
            "\tkfree(css_pids(css));",
            "}",
            "static void pids_update_watermark(struct pids_cgroup *p, int64_t nr_pids)",
            "{",
            "\t/*",
            "\t * This is racy, but we don't need perfectly accurate tallying of",
            "\t * the watermark, and this lets us avoid extra atomic overhead.",
            "\t */",
            "\tif (nr_pids > READ_ONCE(p->watermark))",
            "\t\tWRITE_ONCE(p->watermark, nr_pids);",
            "}",
            "static void pids_cancel(struct pids_cgroup *pids, int num)",
            "{",
            "\t/*",
            "\t * A negative count (or overflow for that matter) is invalid,",
            "\t * and indicates a bug in the `pids` controller proper.",
            "\t */",
            "\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));",
            "}",
            "static void pids_uncharge(struct pids_cgroup *pids, int num)",
            "{",
            "\tstruct pids_cgroup *p;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p))",
            "\t\tpids_cancel(p, num);",
            "}",
            "static void pids_charge(struct pids_cgroup *pids, int num)",
            "{",
            "\tstruct pids_cgroup *p;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {",
            "\t\tint64_t new = atomic64_add_return(num, &p->counter);",
            "",
            "\t\tpids_update_watermark(p, new);",
            "\t}",
            "}",
            "static int pids_try_charge(struct pids_cgroup *pids, int num, struct pids_cgroup **fail)",
            "{",
            "\tstruct pids_cgroup *p, *q;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {",
            "\t\tint64_t new = atomic64_add_return(num, &p->counter);",
            "\t\tint64_t limit = atomic64_read(&p->limit);",
            "",
            "\t\t/*",
            "\t\t * Since new is capped to the maximum number of pid_t, if",
            "\t\t * p->limit is %PIDS_MAX then we know that this test will never",
            "\t\t * fail.",
            "\t\t */",
            "\t\tif (new > limit) {",
            "\t\t\t*fail = p;",
            "\t\t\tgoto revert;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Not technically accurate if we go over limit somewhere up",
            "\t\t * the hierarchy, but that's tolerable for the watermark.",
            "\t\t */",
            "\t\tpids_update_watermark(p, new);",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "revert:",
            "\tfor (q = pids; q != p; q = parent_pids(q))",
            "\t\tpids_cancel(q, num);",
            "\tpids_cancel(p, num);",
            "",
            "\treturn -EAGAIN;",
            "}",
            "static int pids_can_attach(struct cgroup_taskset *tset)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct cgroup_subsys_state *dst_css;",
            "",
            "\tcgroup_taskset_for_each(task, dst_css, tset) {",
            "\t\tstruct pids_cgroup *pids = css_pids(dst_css);",
            "\t\tstruct cgroup_subsys_state *old_css;",
            "\t\tstruct pids_cgroup *old_pids;",
            "",
            "\t\t/*",
            "\t\t * No need to pin @old_css between here and cancel_attach()",
            "\t\t * because cgroup core protects it from being freed before",
            "\t\t * the migration completes or fails.",
            "\t\t */",
            "\t\told_css = task_css(task, pids_cgrp_id);",
            "\t\told_pids = css_pids(old_css);",
            "",
            "\t\tpids_charge(pids, 1);",
            "\t\tpids_uncharge(old_pids, 1);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void pids_cancel_attach(struct cgroup_taskset *tset)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct cgroup_subsys_state *dst_css;",
            "",
            "\tcgroup_taskset_for_each(task, dst_css, tset) {",
            "\t\tstruct pids_cgroup *pids = css_pids(dst_css);",
            "\t\tstruct cgroup_subsys_state *old_css;",
            "\t\tstruct pids_cgroup *old_pids;",
            "",
            "\t\told_css = task_css(task, pids_cgrp_id);",
            "\t\told_pids = css_pids(old_css);",
            "",
            "\t\tpids_charge(old_pids, 1);",
            "\t\tpids_uncharge(pids, 1);",
            "\t}",
            "}"
          ],
          "function_name": "pids_css_free, pids_update_watermark, pids_cancel, pids_uncharge, pids_charge, pids_try_charge, pids_can_attach, pids_cancel_attach",
          "description": "实现了pids控制器的资源充放电逻辑，包含分配/释放CSS结构、更新水位线、充放电操作及附件检查等功能。通过遍历祖先cgroup进行全局资源追踪，确保层级间限制一致性。",
          "similarity": 0.5606219172477722
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 243,
          "end_line": 344,
          "content": [
            "static void pids_event(struct pids_cgroup *pids_forking,",
            "\t\t       struct pids_cgroup *pids_over_limit)",
            "{",
            "\tstruct pids_cgroup *p = pids_forking;",
            "",
            "\t/* Only log the first time limit is hit. */",
            "\tif (atomic64_inc_return(&p->events_local[PIDCG_FORKFAIL]) == 1) {",
            "\t\tpr_info(\"cgroup: fork rejected by pids controller in \");",
            "\t\tpr_cont_cgroup_path(p->css.cgroup);",
            "\t\tpr_cont(\"\\n\");",
            "\t}",
            "\tif (!cgroup_subsys_on_dfl(pids_cgrp_subsys) ||",
            "\t    cgrp_dfl_root.flags & CGRP_ROOT_PIDS_LOCAL_EVENTS) {",
            "\t\tcgroup_file_notify(&p->events_local_file);",
            "\t\treturn;",
            "\t}",
            "",
            "\tatomic64_inc(&pids_over_limit->events_local[PIDCG_MAX]);",
            "\tcgroup_file_notify(&pids_over_limit->events_local_file);",
            "",
            "\tfor (p = pids_over_limit; parent_pids(p); p = parent_pids(p)) {",
            "\t\tatomic64_inc(&p->events[PIDCG_MAX]);",
            "\t\tcgroup_file_notify(&p->events_file);",
            "\t}",
            "}",
            "static int pids_can_fork(struct task_struct *task, struct css_set *cset)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct pids_cgroup *pids, *pids_over_limit;",
            "\tint err;",
            "",
            "\tif (cset)",
            "\t\tcss = cset->subsys[pids_cgrp_id];",
            "\telse",
            "\t\tcss = task_css_check(current, pids_cgrp_id, true);",
            "\tpids = css_pids(css);",
            "\terr = pids_try_charge(pids, 1, &pids_over_limit);",
            "\tif (err)",
            "\t\tpids_event(pids, pids_over_limit);",
            "",
            "\treturn err;",
            "}",
            "static void pids_cancel_fork(struct task_struct *task, struct css_set *cset)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct pids_cgroup *pids;",
            "",
            "\tif (cset)",
            "\t\tcss = cset->subsys[pids_cgrp_id];",
            "\telse",
            "\t\tcss = task_css_check(current, pids_cgrp_id, true);",
            "\tpids = css_pids(css);",
            "\tpids_uncharge(pids, 1);",
            "}",
            "static void pids_release(struct task_struct *task)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));",
            "",
            "\tpids_uncharge(pids, 1);",
            "}",
            "static ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,",
            "\t\t\t      size_t nbytes, loff_t off)",
            "{",
            "\tstruct cgroup_subsys_state *css = of_css(of);",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "\tint64_t limit;",
            "\tint err;",
            "",
            "\tbuf = strstrip(buf);",
            "\tif (!strcmp(buf, PIDS_MAX_STR)) {",
            "\t\tlimit = PIDS_MAX;",
            "\t\tgoto set_limit;",
            "\t}",
            "",
            "\terr = kstrtoll(buf, 0, &limit);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (limit < 0 || limit >= PIDS_MAX)",
            "\t\treturn -EINVAL;",
            "",
            "set_limit:",
            "\t/*",
            "\t * Limit updates don't need to be mutex'd, since it isn't",
            "\t * critical that any racing fork()s follow the new limit.",
            "\t */",
            "\tatomic64_set(&pids->limit, limit);",
            "\treturn nbytes;",
            "}",
            "static int pids_max_show(struct seq_file *sf, void *v)",
            "{",
            "\tstruct cgroup_subsys_state *css = seq_css(sf);",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "\tint64_t limit = atomic64_read(&pids->limit);",
            "",
            "\tif (limit >= PIDS_MAX)",
            "\t\tseq_printf(sf, \"%s\\n\", PIDS_MAX_STR);",
            "\telse",
            "\t\tseq_printf(sf, \"%lld\\n\", limit);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pids_event, pids_can_fork, pids_cancel_fork, pids_release, pids_max_write, pids_max_show",
          "description": "处理进程创建时的配额检查与事件记录，包含can_fork检查、取消fork操作、任务释放及最大进程数配置接口。当达到硬限制时触发事件通知并拒绝fork请求。",
          "similarity": 0.5577729940414429
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 1,
          "end_line": 90,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Process number limiting controller for cgroups.",
            " *",
            " * Used to allow a cgroup hierarchy to stop any new processes from fork()ing",
            " * after a certain limit is reached.",
            " *",
            " * Since it is trivial to hit the task limit without hitting any kmemcg limits",
            " * in place, PIDs are a fundamental resource. As such, PID exhaustion must be",
            " * preventable in the scope of a cgroup hierarchy by allowing resource limiting",
            " * of the number of tasks in a cgroup.",
            " *",
            " * In order to use the `pids` controller, set the maximum number of tasks in",
            " * pids.max (this is not available in the root cgroup for obvious reasons). The",
            " * number of processes currently in the cgroup is given by pids.current.",
            " * Organisational operations are not blocked by cgroup policies, so it is",
            " * possible to have pids.current > pids.max. However, it is not possible to",
            " * violate a cgroup policy through fork(). fork() will return -EAGAIN if forking",
            " * would cause a cgroup policy to be violated.",
            " *",
            " * To set a cgroup to have no limit, set pids.max to \"max\". This is the default",
            " * for all new cgroups (N.B. that PID limits are hierarchical, so the most",
            " * stringent limit in the hierarchy is followed).",
            " *",
            " * pids.current tracks all child cgroup hierarchies, so parent/pids.current is",
            " * a superset of parent/child/pids.current.",
            " *",
            " * Copyright (C) 2015 Aleksa Sarai <cyphar@cyphar.com>",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/threads.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "",
            "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)",
            "#define PIDS_MAX_STR \"max\"",
            "",
            "enum pidcg_event {",
            "\t/* Fork failed in subtree because this pids_cgroup limit was hit. */",
            "\tPIDCG_MAX,",
            "\t/* Fork failed in this pids_cgroup because ancestor limit was hit. */",
            "\tPIDCG_FORKFAIL,",
            "\tNR_PIDCG_EVENTS,",
            "};",
            "",
            "struct pids_cgroup {",
            "\tstruct cgroup_subsys_state\tcss;",
            "",
            "\t/*",
            "\t * Use 64-bit types so that we can safely represent \"max\" as",
            "\t * %PIDS_MAX = (%PID_MAX_LIMIT + 1).",
            "\t */",
            "\tatomic64_t\t\t\tcounter;",
            "\tatomic64_t\t\t\tlimit;",
            "\tint64_t\t\t\t\twatermark;",
            "",
            "\t/* Handles for pids.events[.local] */",
            "\tstruct cgroup_file\t\tevents_file;",
            "\tstruct cgroup_file\t\tevents_local_file;",
            "",
            "\tatomic64_t\t\t\tevents[NR_PIDCG_EVENTS];",
            "\tatomic64_t\t\t\tevents_local[NR_PIDCG_EVENTS];",
            "};",
            "",
            "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)",
            "{",
            "\treturn container_of(css, struct pids_cgroup, css);",
            "}",
            "",
            "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)",
            "{",
            "\treturn css_pids(pids->css.parent);",
            "}",
            "",
            "static struct cgroup_subsys_state *",
            "pids_css_alloc(struct cgroup_subsys_state *parent)",
            "{",
            "\tstruct pids_cgroup *pids;",
            "",
            "\tpids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);",
            "\tif (!pids)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "",
            "\tatomic64_set(&pids->limit, PIDS_MAX);",
            "\treturn &pids->css;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了cgroup的pids控制器核心结构体pids_cgroup，包含原子计数器、限制值和事件统计字段，用于跟踪任务数量以防止进程爆炸。通过CSS子系统状态关联到cgroup层级，支持基于层级的资源限制。",
          "similarity": 0.4985870122909546
        }
      ]
    }
  ]
}