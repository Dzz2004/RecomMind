{
  "query": "引导程序初始化内存映射的过程",
  "timestamp": "2025-12-26 00:36:01",
  "retrieved_files": [
    {
      "source_file": "mm/early_ioremap.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:58:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `early_ioremap.c`\n\n---\n\n# early_ioremap.c 技术文档\n\n## 1. 文件概述\n\n`early_ioremap.c` 提供了在内核启动早期阶段（在标准 `ioremap()` 机制尚未可用时）进行临时 I/O 或内存映射的通用支持。该文件主要用于无 MMU 架构或需要在分页初始化完成前访问物理地址空间的体系结构。其实现基于固定映射（fixmap）机制，通过预分配的虚拟地址窗口动态映射物理内存区域。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `early_ioremap_setup(void)`  \n  初始化早期 ioremap 所需的虚拟地址槽位。\n\n- `__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)`  \n  内部实现函数，执行实际的早期映射操作。\n\n- `early_ioremap(resource_size_t phys_addr, unsigned long size)`  \n  映射 I/O 设备内存，使用 `FIXMAP_PAGE_IO` 页属性。\n\n- `early_memremap(resource_size_t phys_addr, unsigned long size)`  \n  映射普通内存，使用 `FIXMAP_PAGE_NORMAL` 页属性，并可由架构调整保护属性。\n\n- `early_memremap_ro(resource_size_t phys_addr, unsigned long size)`  \n  （条件编译）只读方式映射内存，使用 `FIXMAP_PAGE_RO` 属性。\n\n- `early_memremap_prot(resource_size_t phys_addr, unsigned long size, unsigned long prot_val)`  \n  （条件编译）使用自定义页表属性映射内存。\n\n- `early_iounmap(void __iomem *addr, unsigned long size)`  \n  解除早期 I/O 映射。\n\n- `early_memunmap(void *addr, unsigned long size)`  \n  解除早期内存映射，是对 `early_iounmap` 的封装。\n\n- `copy_from_early_mem(void *dest, phys_addr_t src, unsigned long size)`  \n  安全地从早期物理内存复制数据，自动处理跨映射块边界的情况。\n\n- `early_ioremap_reset(void)`  \n  标记分页初始化已完成，后续映射将使用晚期 fixmap 接口。\n\n- `check_early_ioremap_leak(void)`  \n  启动后期检查是否存在未释放的早期映射（用于调试）。\n\n### 主要数据结构与变量\n\n- `prev_map[FIX_BTMAPS_SLOTS]`：记录每个槽位当前映射的虚拟地址。\n- `prev_size[FIX_BTMAPS_SLOTS]`：记录每个槽位映射的大小。\n- `slot_virt[FIX_BTMAPS_SLOTS]`：每个槽位对应的固定虚拟地址基址。\n- `after_paging_init`：标志位，指示是否已完成分页初始化。\n- `early_ioremap_debug`：调试开关，启用详细日志输出。\n\n## 3. 关键实现\n\n### 固定映射槽位管理\n- 使用 `FIX_BTMAPS_SLOTS` 个独立的 fixmap 槽位（每个槽包含 `NR_FIX_BTMAPS` 个页面），支持并发的早期映射。\n- 每个槽位的虚拟地址通过 `__fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i)` 预计算。\n- 映射时线性搜索首个空闲槽位；解映射时通过虚拟地址反查槽位。\n\n### 分页初始化前后区分\n- 在 `paging_init()` 调用前，使用 `__early_set_fixmap()` 建立映射。\n- 调用 `early_ioremap_reset()` 后（即 `after_paging_init = 1`），改用 `__late_set_fixmap()` 和 `__late_clear_fixmap()`。\n- 若架构未定义晚期接口，则调用 `BUG()`，确保正确性。\n\n### 页对齐与大小限制\n- 输入物理地址和大小会被自动对齐到页边界。\n- 单次映射最大为 `NR_FIX_BTMAPS << PAGE_SHIFT`（即 `MAX_MAP_CHUNK`）。\n- 超出单槽容量的请求会被拒绝（`WARN_ON(nrpages > NR_FIX_BTMAPS)`）。\n\n### 内存属性定制\n- `early_memremap_pgprot_adjust()` 是弱符号函数，允许架构层根据物理地址调整页属性（如设置缓存策略）。\n- 支持只读 (`FIXMAP_PAGE_RO`) 和自定义属性 (`early_memremap_prot`) 的映射。\n\n### 泄漏检测\n- 通过 `late_initcall(check_early_ioremap_leak)` 在启动后期检查是否有未释放的映射。\n- 若存在泄漏且启用了 `early_ioremap_debug`，会提示用户上报 dmesg 日志。\n\n### 无 MMU 支持\n- 在 `!CONFIG_MMU` 配置下，所有 `early_*remap` 函数直接返回物理地址（无映射开销），`unmap` 操作为空。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<asm/fixmap.h>`：提供固定映射相关定义（如 `FIX_BTMAP_BEGIN`、`__fix_to_virt`）。\n  - `<asm/early_ioremap.h>`：必须由架构提供 `__early_set_fixmap` 等底层接口。\n  - `\"internal.h\"`：可能包含内核内部辅助宏或函数。\n\n- **架构依赖**：\n  - 必须实现 `__early_set_fixmap()` 和 `FIXMAP_PAGE_CLEAR`。\n  - 可选实现 `__late_set_fixmap()` / `__late_clear_fixmap()` 以支持分页初始化后的映射。\n  - 可重载 `early_memremap_pgprot_adjust()` 调整内存属性。\n\n- **内核子系统**：\n  - 依赖 `mm` 子系统的页表管理机制。\n  - 使用 `init` 段属性（`__init`）确保代码/数据在初始化后释放。\n  - 通过 `early_param()` 注册启动参数 `early_ioremap_debug`。\n\n## 5. 使用场景\n\n- **内核启动早期**：在 `paging_init()` 之前访问设备寄存器或 ACPI/SMBIOS 等固件表。\n- **ACPI/UEFI 初始化**：解析和访问位于高物理地址的固件数据结构。\n- **内存探测**：在建立完整内存映射前读取内存控制器寄存器。\n- **安全启动验证**：在初始化完整 I/O 子系统前验证硬件状态。\n- **架构移植**：为新架构提供标准化的早期映射接口，避免重复实现。\n\n> 注意：所有早期映射必须在内核进入 `SYSTEM_RUNNING` 状态前解除，否则会触发警告。生产系统应避免长期持有早期映射。",
      "similarity": 0.6297534704208374,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/early_ioremap.c",
          "start_line": 25,
          "end_line": 138,
          "content": [
            "static int __init early_ioremap_debug_setup(char *str)",
            "{",
            "\tearly_ioremap_debug = 1;",
            "",
            "\treturn 0;",
            "}",
            "pgprot_t __init __weak early_memremap_pgprot_adjust(resource_size_t phys_addr,",
            "\t\t\t\t\t\t    unsigned long size,",
            "\t\t\t\t\t\t    pgprot_t prot)",
            "{",
            "\treturn prot;",
            "}",
            "void __init early_ioremap_reset(void)",
            "{",
            "\tafter_paging_init = 1;",
            "}",
            "static inline void __init __late_set_fixmap(enum fixed_addresses idx,",
            "\t\t\t\t\t    phys_addr_t phys, pgprot_t prot)",
            "{",
            "\tBUG();",
            "}",
            "static inline void __init __late_clear_fixmap(enum fixed_addresses idx)",
            "{",
            "\tBUG();",
            "}",
            "void __init early_ioremap_setup(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {",
            "\t\tWARN_ON_ONCE(prev_map[i]);",
            "\t\tslot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);",
            "\t}",
            "}",
            "static int __init check_early_ioremap_leak(void)",
            "{",
            "\tint count = 0;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++)",
            "\t\tif (prev_map[i])",
            "\t\t\tcount++;",
            "",
            "\tif (WARN(count, KERN_WARNING",
            "\t\t \"Debug warning: early ioremap leak of %d areas detected.\\n\"",
            "\t\t \"please boot with early_ioremap_debug and report the dmesg.\\n\",",
            "\t\t count))",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "void __init early_iounmap(void __iomem *addr, unsigned long size)",
            "{",
            "\tunsigned long virt_addr;",
            "\tunsigned long offset;",
            "\tunsigned int nrpages;",
            "\tenum fixed_addresses idx;",
            "\tint i, slot;",
            "",
            "\tslot = -1;",
            "\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {",
            "\t\tif (prev_map[i] == addr) {",
            "\t\t\tslot = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (WARN(slot < 0, \"%s(%p, %08lx) not found slot\\n\",",
            "\t\t  __func__, addr, size))",
            "\t\treturn;",
            "",
            "\tif (WARN(prev_size[slot] != size,",
            "\t\t \"%s(%p, %08lx) [%d] size not consistent %08lx\\n\",",
            "\t\t  __func__, addr, size, slot, prev_size[slot]))",
            "\t\treturn;",
            "",
            "\tWARN(early_ioremap_debug, \"%s(%p, %08lx) [%d]\\n\",",
            "\t      __func__, addr, size, slot);",
            "",
            "\tvirt_addr = (unsigned long)addr;",
            "\tif (WARN_ON(virt_addr < fix_to_virt(FIX_BTMAP_BEGIN)))",
            "\t\treturn;",
            "",
            "\toffset = offset_in_page(virt_addr);",
            "\tnrpages = PAGE_ALIGN(offset + size) >> PAGE_SHIFT;",
            "",
            "\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;",
            "\twhile (nrpages > 0) {",
            "\t\tif (after_paging_init)",
            "\t\t\t__late_clear_fixmap(idx);",
            "\t\telse",
            "\t\t\t__early_set_fixmap(idx, 0, FIXMAP_PAGE_CLEAR);",
            "\t\t--idx;",
            "\t\t--nrpages;",
            "\t}",
            "\tprev_map[slot] = NULL;",
            "}",
            "void __init copy_from_early_mem(void *dest, phys_addr_t src, unsigned long size)",
            "{",
            "\tunsigned long slop, clen;",
            "\tchar *p;",
            "",
            "\twhile (size) {",
            "\t\tslop = offset_in_page(src);",
            "\t\tclen = size;",
            "\t\tif (clen > MAX_MAP_CHUNK - slop)",
            "\t\t\tclen = MAX_MAP_CHUNK - slop;",
            "\t\tp = early_memremap(src & PAGE_MASK, clen + slop);",
            "\t\tmemcpy(dest, p + slop, clen);",
            "\t\tearly_memunmap(p, clen + slop);",
            "\t\tdest += clen;",
            "\t\tsrc += clen;",
            "\t\tsize -= clen;",
            "\t}",
            "}"
          ],
          "function_name": "early_ioremap_debug_setup, early_memremap_pgprot_adjust, early_ioremap_reset, __late_set_fixmap, __late_clear_fixmap, early_ioremap_setup, check_early_ioremap_leak, early_iounmap, copy_from_early_mem",
          "description": "实现早期内存映射的调试控制、固定映射管理、内存泄漏检测及释放逻辑，包含ioremap区域解除映射、数据拷贝等关键操作函数",
          "similarity": 0.6401308178901672
        },
        {
          "chunk_id": 0,
          "file_path": "mm/early_ioremap.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Provide common bits of early_ioremap() support for architectures needing",
            " * temporary mappings during boot before ioremap() is available.",
            " *",
            " * This is mostly a direct copy of the x86 early_ioremap implementation.",
            " *",
            " * (C) Copyright 1995 1996, 2014 Linus Torvalds",
            " *",
            " */",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <asm/fixmap.h>",
            "#include <asm/early_ioremap.h>",
            "#include \"internal.h\"",
            "",
            "#ifdef CONFIG_MMU",
            "static int early_ioremap_debug __initdata;",
            ""
          ],
          "function_name": null,
          "description": "提供架构通用的早期ioremap支持框架，定义DEBUG调试标志及基础头文件，为需要启动阶段临时映射的架构准备MMU相关基础设施",
          "similarity": 0.5584659576416016
        },
        {
          "chunk_id": 2,
          "file_path": "mm/early_ioremap.c",
          "start_line": 287,
          "end_line": 293,
          "content": [
            "void __init early_iounmap(void __iomem *addr, unsigned long size)",
            "{",
            "}",
            "void __init early_memunmap(void *addr, unsigned long size)",
            "{",
            "\tearly_iounmap((__force void __iomem *)addr, size);",
            "}"
          ],
          "function_name": "early_iounmap, early_memunmap",
          "description": "定义early_iounmap空函数与early_memunmap封装函数，用于统一释放由early_ioremap分配的资源，但当前上下文不完整",
          "similarity": 0.5275001525878906
        }
      ]
    },
    {
      "source_file": "kernel/iomem.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:45:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `iomem.c`\n\n---\n\n# iomem.c 技术文档\n\n## 1. 文件概述\n\n`iomem.c` 实现了通用的内存重映射（`memremap`）接口，用于将物理地址空间（特别是 I/O 内存资源）映射为可直接访问的内核虚拟地址。与传统的 `ioremap` 不同，`memremap` 专为**无 I/O 副作用**的内存区域设计（如持久内存 PMEM、设备内存等），并支持多种缓存策略（如写回 WB、写通 WT、写合并 WC）。该文件还提供了资源管理版本（`devm_memremap`），可自动在设备卸载时释放映射。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`memremap()`**  \n  核心映射函数，根据指定的缓存策略（`MEMREMAP_WB`/`WT`/`WC`）将物理地址映射为内核虚拟地址。若映射区域为系统 RAM 且请求 `MEMREMAP_WB`，则直接返回线性映射地址。\n\n- **`memunmap()`**  \n  释放由 `memremap()` 创建的映射。若地址来自 `ioremap` 系列函数，则调用 `iounmap()`；若为直接映射地址则无需操作。\n\n- **`devm_memremap()`**  \n  设备资源管理版本的 `memremap()`，将映射资源与设备生命周期绑定，设备卸载时自动释放。\n\n- **`devm_memunmap()`**  \n  显式释放由 `devm_memremap()` 分配的资源（通常无需手动调用）。\n\n### 辅助函数\n\n- **`try_ram_remap()`**  \n  尝试对系统 RAM 区域使用内核直接映射（`__va()`），避免创建新页表。\n\n- **`arch_memremap_wb()`**（弱符号）  \n  架构特定的写回（WB）映射实现，默认回退到 `ioremap_cache()` 或 `ioremap()`。\n\n- **`arch_memremap_can_ram_remap()`**（弱符号）  \n  架构特定的 RAM 重映射能力检查，默认返回 `true`。\n\n### 标志位（Flags）\n\n- `MEMREMAP_WB`：写回缓存（默认系统 RAM 策略）\n- `MEMREMAP_WT`：写通缓存（禁止用于系统 RAM）\n- `MEMREMAP_WC`：写合并（禁止用于系统 RAM）\n- `MEMREMAP_ENC`/`DEC`：加密/解密映射（代码中未直接处理，由底层 `ioremap` 实现）\n\n## 3. 关键实现\n\n### 内存区域类型检测\n- 使用 `region_intersects()` 检查物理地址范围是否与 `IORESOURCE_SYSTEM_RAM` 重叠，返回：\n  - `REGION_INTERSECTS`：完全或部分在系统 RAM 内\n  - `REGION_MIXED`：跨越 RAM 与非 RAM 区域（视为错误）\n  - `REGION_DISJOINT`：完全在非 RAM 区域\n\n### RAM 直接映射优化\n- 当请求 `MEMREMAP_WB` 且区域为系统 RAM 时：\n  1. 调用 `try_ram_remap()` 检查是否满足直接映射条件：\n     - 物理页帧有效（`pfn_valid()`）\n     - 非高端内存（`!PageHighMem()`）\n     - 架构允许 RAM 重映射（`arch_memremap_can_ram_remap()`）\n  2. 若满足，直接返回 `__va(offset)`（内核线性映射地址），避免页表开销。\n\n### 非 RAM 区域映射\n- 对于非 RAM 区域或非 WB 请求：\n  - `MEMREMAP_WT` → `ioremap_wt()`\n  - `MEMREMAP_WC` → `ioremap_wc()`\n  - `MEMREMAP_WB` → `arch_memremap_wb()`（最终调用 `ioremap_cache()` 或 `ioremap()`）\n\n### 安全限制\n- 禁止对系统 RAM 使用 `WT`/`WC` 映射（会触发 `WARN_ONCE` 并返回 `NULL`）\n- 禁止映射混合 RAM/非 RAM 区域（视为编程错误）\n\n### 资源管理\n- `devm_memremap()` 使用设备资源管理框架（`devres`）：\n  - 分配资源描述符（`devres_alloc_node`）\n  - 注册释放回调（`devm_memremap_release`）\n  - 设备卸载时自动调用 `memunmap()`\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/io.h>`：提供 `ioremap_*()` 系列函数\n  - `<linux/mm.h>`：提供 `pfn_valid()`、`PageHighMem()` 等内存管理接口\n  - `<linux/ioremap.h>`：定义 `ioremap` 相关类型和函数\n  - `<linux/device.h>`：提供设备资源管理（`devres`）接口\n\n- **架构依赖**：\n  - 依赖架构实现的 `ioremap_cache()`、`ioremap_wt()`、`ioremap_wc()`\n  - 可选覆盖 `arch_memremap_wb()` 和 `arch_memremap_can_ram_remap()`\n\n- **内核子系统**：\n  - 内存管理子系统（MM）：页表管理、直接映射\n  - 设备驱动模型：设备资源生命周期管理\n\n## 5. 使用场景\n\n- **持久内存（PMEM）驱动**：  \n  将持久内存设备的物理地址映射为可直接读写的内核虚拟地址（通常使用 `MEMREMAP_WB`）。\n\n- **设备内存（Device Memory）访问**：  \n  访问无 I/O 副作用的设备内存区域（如 GPU 显存、FPGA 内存），根据性能需求选择缓存策略。\n\n- **EFI 运行时服务内存**：  \n  映射 EFI 固件提供的内存区域（需确保无副作用）。\n\n- **设备驱动资源管理**：  \n  使用 `devm_memremap()` 简化驱动代码，避免手动释放映射（尤其适用于 probe/remove 场景）。\n\n- **内核子系统通用映射**：  \n  为需要高性能内存访问的子系统（如 DAX、HMM）提供统一映射接口。",
      "similarity": 0.6214466691017151,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/iomem.c",
          "start_line": 20,
          "end_line": 42,
          "content": [
            "static bool arch_memremap_can_ram_remap(resource_size_t offset, size_t size,",
            "\t\t\t\t\tunsigned long flags)",
            "{",
            "\treturn true;",
            "}",
            "void memunmap(void *addr)",
            "{",
            "\tif (is_ioremap_addr(addr))",
            "\t\tiounmap((void __iomem *) addr);",
            "}",
            "static void devm_memremap_release(struct device *dev, void *res)",
            "{",
            "\tmemunmap(*(void **)res);",
            "}",
            "static int devm_memremap_match(struct device *dev, void *res, void *match_data)",
            "{",
            "\treturn *(void **)res == match_data;",
            "}",
            "void devm_memunmap(struct device *dev, void *addr)",
            "{",
            "\tWARN_ON(devres_release(dev, devm_memremap_release,",
            "\t\t\t\tdevm_memremap_match, addr));",
            "}"
          ],
          "function_name": "arch_memremap_can_ram_remap, memunmap, devm_memremap_release, devm_memremap_match, devm_memunmap",
          "description": "实现内存映射释放相关函数，包含判断能否进行RAM重映射的钩子函数、解除ioremap地址映射的memunmap函数，以及设备资源管理中的动态内存映射释放匹配逻辑",
          "similarity": 0.5937511324882507
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/iomem.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "/* SPDX-License-Identifier: GPL-2.0 */",
            "#include <linux/device.h>",
            "#include <linux/types.h>",
            "#include <linux/io.h>",
            "#include <linux/mm.h>",
            "#include <linux/ioremap.h>",
            "",
            "#ifndef arch_memremap_wb",
            "static void *arch_memremap_wb(resource_size_t offset, unsigned long size)",
            "{",
            "#ifdef ioremap_cache",
            "\treturn (__force void *)ioremap_cache(offset, size);",
            "#else",
            "\treturn (__force void *)ioremap(offset, size);",
            "#endif",
            "}",
            "#endif",
            "",
            "#ifndef arch_memremap_can_ram_remap"
          ],
          "function_name": null,
          "description": "定义arch_memremap_wb函数，根据ioremap_cache是否存在选择使用ioremap_cache或ioremap实现，用于创建带写回缓存策略的内存映射区域，上下文不完整",
          "similarity": 0.5639153718948364
        }
      ]
    },
    {
      "source_file": "mm/kmsan/init.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:29:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kmsan\\init.c`\n\n---\n\n# `kmsan/init.c` 技术文档\n\n## 1. 文件概述\n\n`kmsan/init.c` 是 Linux 内核中 **KernelMemorySanitizer (KMSAN)** 调试工具的初始化模块。该文件负责在内核启动早期阶段为已存在的内存区域（如内核代码段、数据段、节点描述符 NODE_DATA 等）分配并初始化影子（shadow）和来源（origin）元数据页，并管理 memblock 分配器向伙伴系统移交页面时的元数据预分配策略。其目标是确保 KMSAN 能够追踪所有内核内存的初始化状态，从而检测未初始化内存的使用。\n\n## 2. 核心功能\n\n### 主要函数\n- `kmsan_record_future_shadow_range(void *start, void *end)`  \n  记录一个将在稍后（slab 初始化后）为其分配元数据的内存范围，并尝试与已有范围合并以减少碎片。\n  \n- `kmsan_init_shadow(void)`  \n  在内核初始化早期调用，收集需要初始化元数据的内存区域（包括保留内存、`.data` 段、NODE_DATA 等），并为这些区域分配影子和来源元数据。\n\n- `kmsan_memblock_free_pages(struct page *page, unsigned int order)`  \n  在 memblock 将大块连续物理页释放给伙伴系统时，拦截这些页面，按“三取一”策略：每三块同阶页面中，两块用作元数据（shadow + origin），一块作为被监控的数据页。\n\n- `kmsan_memblock_discard(void)`  \n  在 memblock 生命周期结束前，处理 `held_back[]` 中剩余的未配对元数据页，通过递归拆分和重新组合，尽可能为剩余数据页分配元数据，并将无法使用的页面归还系统。\n\n- `kmsan_init_runtime(void)`  \n  完成 KMSAN 的运行时初始化：为 init_task 创建任务上下文、清理残留元数据、启用 KMSAN 全局开关，并打印警告信息。\n\n### 主要数据结构\n- `struct start_end_pair`  \n  表示一个待分配元数据的虚拟地址范围（对齐到页边界）。\n\n- `struct metadata_page_pair`  \n  存储一对用于元数据的物理页：`shadow`（影子页，记录字节是否初始化）和 `origin`（来源页，记录未初始化值的来源信息）。\n\n- `struct smallstack`  \n  一个轻量级栈结构，用于在 `kmsan_memblock_discard()` 中暂存不同阶的页面块，支持按需拆分和重组。\n\n## 3. 关键实现\n\n### 内存范围合并机制\n`kmsan_record_future_shadow_range()` 在记录新范围前会遍历已有范围列表，若发现重叠或相邻，则合并为一个更大的连续范围。由于内核早期注册的范围数量有限（<20），采用线性扫描即可高效完成合并，避免元数据分配碎片化。\n\n### “三取一”元数据预分配策略\n在 `kmsan_memblock_free_pages()` 中，KMSAN 利用 memblock 向伙伴系统移交页面的时机，实施一种**贪婪但高效的元数据预留机制**：\n- 对于每个页面阶 `order`，维护一个 `held_back[order]` 缓存。\n- 前两次收到同阶页面块时，分别暂存为 shadow 和 origin。\n- 第三次收到时，将前两块作为元数据分配给第三块，并清空缓存供后续复用。\n- 此策略确保约 2/3 的释放内存被用作元数据，1/3 作为有效数据页，满足 KMSAN 对元数据空间的高需求。\n\n### 残留元数据回收（`kmsan_memblock_discard`）\n当 memblock 生命周期结束时，`held_back[]` 中可能残留未配对的 shadow 或 origin 页面。`kmsan_memblock_discard()` 采用**自顶向下递归拆分**策略：\n1. 从最大阶（`MAX_PAGE_ORDER`）开始，将所有残留页面压入 `collect` 栈。\n2. 若栈中元素 ≥3，则弹出三个页面，按“shadow + origin → data”方式完成一次元数据绑定，并将 data 页归还伙伴系统。\n3. 若栈中元素 <3，则将每个页面**拆分为两个低一阶的页面**，压入新栈，继续处理。\n4. 重复上述过程直至最小阶（0 阶），最大化利用残留内存。\n\n### 初始化流程整合\n- `kmsan_init_shadow()` 在 slab 初始化前运行，依赖 `memblock` 和 `phys_to_virt`，为静态内核内存分配元数据。\n- `kmsan_init_runtime()` 在伙伴系统完全就绪后调用，完成任务上下文初始化、残留清理，并最终启用 KMSAN。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `kmsan.h`：KMSAN 核心接口和宏定义（如 `KMSAN_WARN_ON`）。\n  - `<asm/sections.h>`：获取内核符号地址（如 `_sdata`, `_edata`）。\n  - `<linux/mm.h>`, `<linux/memblock.h>`：内存管理基础 API（`phys_to_virt`, `memblock` 遍历等）。\n  - `\"../internal.h\"`：KMSAN 内部实现细节（如 `kmsan_setup_meta`, `kmsan_init_alloc_meta_for_range`）。\n\n- **功能依赖**：\n  - 依赖 **memblock 分配器** 在早期内存管理中的行为。\n  - 依赖 **伙伴系统（buddy allocator）** 接管页面后的正常运作。\n  - 依赖 **percpu、NUMA NODE_DATA** 等子系统的初始化顺序（需在其注册内存范围后再调用 `kmsan_init_shadow`）。\n\n## 5. 使用场景\n\n- **内核启动早期**：在 `start_kernel()` 流程中，于 `mm_init()` 之前调用 `kmsan_init_shadow()`，为内核静态数据分配元数据。\n- **memblock 释放页面时**：每当 `memblock_free_pages()` 被调用（通常在 `free_all_bootmem()` 中），KMSAN 拦截页面释放流程，执行元数据预留。\n- **内核初始化尾声**：在 `rest_init()` 之前调用 `kmsan_init_runtime()`，完成 KMSAN 的最终激活。\n- **调试场景**：仅在启用 `CONFIG_KMSAN` 编译选项的内核中生效，用于检测内核中因未初始化内存导致的安全漏洞或逻辑错误，**严禁在生产环境使用**。",
      "similarity": 0.6119273900985718,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/kmsan/init.c",
          "start_line": 201,
          "end_line": 234,
          "content": [
            "static void kmsan_memblock_discard(void)",
            "{",
            "\t/*",
            "\t * For each order=N:",
            "\t *  - push held_back[N].shadow and .origin to @collect;",
            "\t *  - while there are >= 3 elements in @collect, do garbage collection:",
            "\t *    - pop 3 ranges from @collect;",
            "\t *    - use two of them as shadow and origin for the third one;",
            "\t *    - repeat;",
            "\t *  - split each remaining element from @collect into 2 ranges of",
            "\t *    order=N-1,",
            "\t *  - repeat.",
            "\t */",
            "\tcollect.order = MAX_PAGE_ORDER;",
            "\tfor (int i = MAX_PAGE_ORDER; i >= 0; i--) {",
            "\t\tif (held_back[i].shadow)",
            "\t\t\tsmallstack_push(&collect, held_back[i].shadow);",
            "\t\tif (held_back[i].origin)",
            "\t\t\tsmallstack_push(&collect, held_back[i].origin);",
            "\t\theld_back[i].shadow = NULL;",
            "\t\theld_back[i].origin = NULL;",
            "\t\tdo_collection();",
            "\t\tcollect_split();",
            "\t}",
            "}",
            "void __init kmsan_init_runtime(void)",
            "{",
            "\t/* Assuming current is init_task */",
            "\tkmsan_internal_task_create(current);",
            "\tkmsan_memblock_discard();",
            "\tpr_info(\"Starting KernelMemorySanitizer\\n\");",
            "\tpr_info(\"ATTENTION: KMSAN is a debugging tool! Do not use it on production machines!\\n\");",
            "\tkmsan_enabled = true;",
            "}"
          ],
          "function_name": "kmsan_memblock_discard, kmsan_init_runtime",
          "description": "执行内存块清理操作，通过小栈收集并处理不同阶序的页面资源，完成KMSAN运行时环境初始化与启用",
          "similarity": 0.610999345779419
        },
        {
          "chunk_id": 0,
          "file_path": "mm/kmsan/init.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * KMSAN initialization routines.",
            " *",
            " * Copyright (C) 2017-2021 Google LLC",
            " * Author: Alexander Potapenko <glider@google.com>",
            " *",
            " */",
            "",
            "#include \"kmsan.h\"",
            "",
            "#include <asm/sections.h>",
            "#include <linux/mm.h>",
            "#include <linux/memblock.h>",
            "",
            "#include \"../internal.h\"",
            "",
            "#define NUM_FUTURE_RANGES 128",
            "struct start_end_pair {",
            "\tu64 start, end;",
            "};",
            "",
            "static struct start_end_pair start_end_pairs[NUM_FUTURE_RANGES] __initdata;",
            "static int future_index __initdata;",
            "",
            "/*",
            " * Record a range of memory for which the metadata pages will be created once",
            " * the page allocator becomes available.",
            " */"
          ],
          "function_name": null,
          "description": "定义用于记录未来内存范围的辅助结构和初始化函数，用于在页面分配器就绪后创建元数据页",
          "similarity": 0.6015708446502686
        },
        {
          "chunk_id": 1,
          "file_path": "mm/kmsan/init.c",
          "start_line": 30,
          "end_line": 141,
          "content": [
            "static void __init kmsan_record_future_shadow_range(void *start, void *end)",
            "{",
            "\tu64 nstart = (u64)start, nend = (u64)end, cstart, cend;",
            "\tbool merged = false;",
            "",
            "\tKMSAN_WARN_ON(future_index == NUM_FUTURE_RANGES);",
            "\tKMSAN_WARN_ON((nstart >= nend) || !nstart || !nend);",
            "\tnstart = ALIGN_DOWN(nstart, PAGE_SIZE);",
            "\tnend = ALIGN(nend, PAGE_SIZE);",
            "",
            "\t/*",
            "\t * Scan the existing ranges to see if any of them overlaps with",
            "\t * [start, end). In that case, merge the two ranges instead of",
            "\t * creating a new one.",
            "\t * The number of ranges is less than 20, so there is no need to organize",
            "\t * them into a more intelligent data structure.",
            "\t */",
            "\tfor (int i = 0; i < future_index; i++) {",
            "\t\tcstart = start_end_pairs[i].start;",
            "\t\tcend = start_end_pairs[i].end;",
            "\t\tif ((cstart < nstart && cend < nstart) ||",
            "\t\t    (cstart > nend && cend > nend))",
            "\t\t\t/* ranges are disjoint - do not merge */",
            "\t\t\tcontinue;",
            "\t\tstart_end_pairs[i].start = min(nstart, cstart);",
            "\t\tstart_end_pairs[i].end = max(nend, cend);",
            "\t\tmerged = true;",
            "\t\tbreak;",
            "\t}",
            "\tif (merged)",
            "\t\treturn;",
            "\tstart_end_pairs[future_index].start = nstart;",
            "\tstart_end_pairs[future_index].end = nend;",
            "\tfuture_index++;",
            "}",
            "void __init kmsan_init_shadow(void)",
            "{",
            "\tconst size_t nd_size = roundup(sizeof(pg_data_t), PAGE_SIZE);",
            "\tphys_addr_t p_start, p_end;",
            "\tu64 loop;",
            "\tint nid;",
            "",
            "\tfor_each_reserved_mem_range(loop, &p_start, &p_end)",
            "\t\tkmsan_record_future_shadow_range(phys_to_virt(p_start),",
            "\t\t\t\t\t\t phys_to_virt(p_end));",
            "\t/* Allocate shadow for .data */",
            "\tkmsan_record_future_shadow_range(_sdata, _edata);",
            "",
            "\tfor_each_online_node(nid)",
            "\t\tkmsan_record_future_shadow_range(",
            "\t\t\tNODE_DATA(nid), (char *)NODE_DATA(nid) + nd_size);",
            "",
            "\tfor (int i = 0; i < future_index; i++)",
            "\t\tkmsan_init_alloc_meta_for_range(",
            "\t\t\t(void *)start_end_pairs[i].start,",
            "\t\t\t(void *)start_end_pairs[i].end);",
            "}",
            "bool kmsan_memblock_free_pages(struct page *page, unsigned int order)",
            "{",
            "\tstruct page *shadow, *origin;",
            "",
            "\tif (!held_back[order].shadow) {",
            "\t\theld_back[order].shadow = page;",
            "\t\treturn false;",
            "\t}",
            "\tif (!held_back[order].origin) {",
            "\t\theld_back[order].origin = page;",
            "\t\treturn false;",
            "\t}",
            "\tshadow = held_back[order].shadow;",
            "\torigin = held_back[order].origin;",
            "\tkmsan_setup_meta(page, shadow, origin, order);",
            "",
            "\theld_back[order].shadow = NULL;",
            "\theld_back[order].origin = NULL;",
            "\treturn true;",
            "}",
            "static void smallstack_push(struct smallstack *stack, struct page *pages)",
            "{",
            "\tKMSAN_WARN_ON(stack->index == MAX_BLOCKS);",
            "\tstack->items[stack->index] = pages;",
            "\tstack->index++;",
            "}",
            "static void do_collection(void)",
            "{",
            "\tstruct page *page, *shadow, *origin;",
            "",
            "\twhile (collect.index >= 3) {",
            "\t\tpage = smallstack_pop(&collect);",
            "\t\tshadow = smallstack_pop(&collect);",
            "\t\torigin = smallstack_pop(&collect);",
            "\t\tkmsan_setup_meta(page, shadow, origin, collect.order);",
            "\t\t__free_pages_core(page, collect.order, MEMINIT_EARLY);",
            "\t}",
            "}",
            "static void collect_split(void)",
            "{",
            "\tstruct smallstack tmp = {",
            "\t\t.order = collect.order - 1,",
            "\t\t.index = 0,",
            "\t};",
            "\tstruct page *page;",
            "",
            "\tif (!collect.order)",
            "\t\treturn;",
            "\twhile (collect.index) {",
            "\t\tpage = smallstack_pop(&collect);",
            "\t\tsmallstack_push(&tmp, &page[0]);",
            "\t\tsmallstack_push(&tmp, &page[1 << tmp.order]);",
            "\t}",
            "\t__memcpy(&collect, &tmp, sizeof(tmp));",
            "}"
          ],
          "function_name": "kmsan_record_future_shadow_range, kmsan_init_shadow, kmsan_memblock_free_pages, smallstack_push, do_collection, collect_split",
          "description": "实现未来内存范围的合并逻辑、影子内存初始化及页面回收机制，包含范围扫描、元数据分配与碎片收集处理",
          "similarity": 0.5584853887557983
        }
      ]
    }
  ]
}