{
  "query": "设备驱动",
  "timestamp": "2025-12-26 00:28:53",
  "retrieved_files": [
    {
      "source_file": "kernel/hardware_message.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:43:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `hardware_message.c`\n\n---\n\n# hardware_message.c 技术文档\n\n## 文件概述\n\n`hardware_message.c` 是麒麟操作系统（Kylin Linux Advanced Desktop/Server，简称 KLAS/KLAD）内核中用于向用户发出硬件或驱动程序支持状态警告的专用模块。该文件定义了一系列函数，用于在内核启动或驱动加载过程中，根据硬件或驱动的生命周期状态（如“已弃用”、“不再维护”、“已禁用”或“技术预览”）向系统日志输出高优先级的 `pr_crit()` 警告信息。这些函数仅在启用了 `CONFIG_KYLIN_DIFFERENCES` 内核配置选项时生效，体现了麒麟操作系统对特定硬件兼容性与支持策略的管理机制。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `mark_hardware_unmaintained()` | 标记特定硬件设备为“不再维护”，输出包含设备描述的严重警告 |\n| `mark_driver_unmaintained()` | 标记驱动程序为“不再维护”，适用于无法关联具体硬件的通用驱动 |\n| `mark_hardware_deprecated()` | 标记特定硬件为“已弃用”，提示将在未来版本停止维护 |\n| `mark_driver_deprecated()` | 标记驱动为“已弃用”，适用于抽象或高层驱动 |\n| `mark_hardware_disabled()` | 标记硬件支持已被完全禁用，设备无法在当前版本使用 |\n| `mark_tech_preview()` | 标记驱动或子系统为“技术预览”状态（函数声明未完整实现） |\n\n### 数据结构与常量\n\n- `DEV_DESC_LEN`：定义设备描述字符串的最大长度（256 字节）\n- 使用 `va_list` 和可变参数处理设备描述格式化\n\n### 导出符号\n\n所有上述函数均通过 `EXPORT_SYMBOL()` 导出，可供其他内核模块调用。\n\n## 关键实现\n\n### 条件编译控制\n\n所有函数的实现均被 `#ifdef CONFIG_KYLIN_DIFFERENCES` 包裹，确保仅在麒麟定制内核中启用该功能，避免对上游 Linux 内核造成影响。\n\n### 驱动/模块名称解析逻辑\n\n函数优先使用传入的 `driver_name` 参数；若为空且启用了 `CONFIG_MODULES`，则回退到从 `struct module *mod` 中提取模块名；若两者均不可用，则使用默认字符串 `\"Kernel\"`。\n\n### 可变参数处理\n\n对于硬件相关的函数（`_hardware_*`），使用 `va_start`/`vsnprintf`/`va_end` 机制格式化设备描述信息，支持动态构造设备标识（如 PCI ID、设备型号等）。\n\n### 日志级别\n\n统一使用 `pr_crit()` 输出 **Critical** 级别日志，确保警告信息在系统日志中高亮显示，引起管理员注意。\n\n### 生命周期状态语义\n\n- **Deprecated（已弃用）**：当前仍可用，但计划在未来主版本中转为“不再维护”或“禁用”\n- **Unmaintained（不再维护）**：仅修复安全或严重问题，常规更新已停止\n- **Disabled（已禁用）**：当前版本已完全移除支持\n- **Tech Preview（技术预览）**：新功能，测试有限，不保证稳定性与支持（函数未完整实现）\n\n## 依赖关系\n\n### 头文件依赖\n\n- `<linux/kernel.h>`：提供 `pr_crit()`、`vsnprintf()`、`va_list` 等内核日志与字符串处理接口\n- `<linux/module.h>`：提供 `struct module` 定义及模块相关信息\n\n### 内核配置依赖\n\n- **必需**：`CONFIG_KYLIN_DIFFERENCES` — 启用麒麟特有差异功能\n- **可选**：`CONFIG_MODULES` — 支持从模块指针获取名称（若未启用模块，则跳过该路径）\n\n### 符号导出\n\n所有函数通过 `EXPORT_SYMBOL()` 导出，供其他驱动模块在初始化时调用，以声明自身支持状态。\n\n## 使用场景\n\n1. **驱动弃用通知**  \n   当某硬件厂商停止维护某款网卡，麒麟内核团队决定在下一主版本移除支持。当前版本中，该驱动在 `probe()` 时调用 `mark_hardware_deprecated()`，提示用户规划迁移。\n\n2. **通用驱动生命周期管理**  \n   某旧版 RAID 管理驱动因上游废弃，麒麟将其标记为“不再维护”，调用 `mark_driver_unmaintained()`，适用于所有使用该驱动的系统。\n\n3. **已禁用硬件检测**  \n   用户尝试加载已被内核配置禁用的旧显卡驱动，驱动框架调用 `mark_hardware_disabled()` 明确告知设备不可用。\n\n4. **新技术预览**  \n   引入实验性文件系统或新硬件支持时，通过 `mark_tech_preview()` 声明其非生产就绪状态（注：当前代码中该函数未实现完整逻辑）。\n\n5. **发布合规性**  \n   所有调用必须记录于 KLAS/KLAD 发行说明，并获得管理层审批，确保用户对硬件支持变更有明确预期。",
      "similarity": 0.5844175815582275,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/hardware_message.c",
          "start_line": 44,
          "end_line": 145,
          "content": [
            "void mark_hardware_unmaintained(const char *driver_name, struct module *mod,",
            "\t\t\t\tchar *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Unmaintained hardware is detected: %s:%s\\n\",",
            "\t\tname ?: \"Kernel\",",
            "\t\tdevice_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_driver_unmaintained(const char *driver_name, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tpr_crit(\"Warning: Unmaintained driver is detected: %s\\n\",",
            "\t\tname ?: \"Kernel\");",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_hardware_deprecated(const char *driver_name, struct module *mod,",
            "\t\t\t      char *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Deprecated Hardware is detected: %s:%s will not be \"",
            "\t\t\"maintained in a future major release and may be disabled.\\n\",",
            "\t\tname ?: \"Kernel\", device_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_driver_deprecated(const char *driver_name, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tpr_crit(\"Warning: Deprecated Driver is detected: %s will not be \"",
            "\t\t\"maintained in a future major release and may be disabled.\\n\",",
            "\t\tname ?: \"Kernel\");",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_hardware_disabled(const char *driver_name, struct module *mod,",
            "\t\t\t    char *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Disabled Hardware is detected: %s:%s is no longer \"",
            "\t\t\"enabled in this release.\\n\",",
            "\t\tname ?: \"Kernel\", device_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}"
          ],
          "function_name": "mark_hardware_unmaintained, mark_driver_unmaintained, mark_hardware_deprecated, mark_driver_deprecated, mark_hardware_disabled",
          "description": "实现了标记硬件/驱动状态的五个函数，通过变参处理构建设备描述信息并输出内核警告日志，核心功能是根据配置条件触发不同级别硬件/驱动支持状态的警告提示",
          "similarity": 0.6183566451072693
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/hardware_message.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Author: Jackie Liu <liuyun01@kylinos.cn>",
            " * Copyright (C) 2024, KylinSoft Corporation.",
            " *",
            " * The following functions are used by 'Kylin Linux Advanced Desktop/Server",
            " * Operation System' to indicate to users that hardware and drivers are",
            " * unsupported, or have limited support in KLAS/KLAD major and minor releases.",
            " * These functions output loud warning messages to the end user and should",
            " * be USED WITH CAUTION.",
            " *",
            " * Any use of these functions _MUST_ be documented in the KLAS/KLAD Release",
            " * Notes, and have approval of management.",
            " *",
            " * Generally, the process of disabling a driver or device in KLAS/KLAD requires",
            " * the driver or device to be marked as 'deprecated' in all existing releases,",
            " * and then either 'unmaintained' or 'disabled' in a future release.",
            " *",
            " * In general, deprecated and unmaintained drivers continue to receive security",
            " * related fixes until they are disabled.",
            " */",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "",
            "#define DEV_DESC_LEN 256",
            "",
            "/**",
            " * mark_hardware_unmaintained() - Mark hardware as unmaintained.",
            " * @driver_name: driver name",
            " * @mod: module pointer",
            " * @fmt: format for device description",
            " * @...: args for device description",
            " *",
            " * Called to notify users that the device will no longer be tested on a routine",
            " * basis and driver code associated with this device is no longer being updated.",
            " * KYLIN may fix security-related and critical issues. Support for this device",
            " * will be disabled in a future major release and users deploying this device",
            " * should plan to replace the device in production systems.",
            " *",
            " * This function should be used when the driver's usage can be tied to a",
            " * specific hardware device. For example, a network device driver loading on a",
            " * specific device that is no longer maintained by the manufacturer.",
            " */"
          ],
          "function_name": null,
          "description": "此代码块定义了用于标记硬件和驱动状态的函数原型，描述了各函数的用途及使用规范，核心功能是通知用户硬件/驱动的支持状态变化，但未提供函数实现，上下文不完整",
          "similarity": 0.6142951846122742
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/hardware_message.c",
          "start_line": 230,
          "end_line": 283,
          "content": [
            "void mark_tech_preview(const char *msg, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *str = NULL;",
            "",
            "\tif (msg)",
            "\t\tstr = msg;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tstr = mod->name;",
            "#endif",
            "",
            "\tpr_warn(\"TECH PREVIEW: %s may not be fully supported.\\n\"",
            "\t\t\"Please review provided documentation for limitations.\\n\",",
            "\t\tstr ?: \"kernel\");",
            "\tadd_taint(TAINT_AUX, LOCKDEP_STILL_OK);",
            "#ifdef CONFIG_MODULES",
            "\tif (mod)",
            "\t\tmod->taints |= (1U << TAINT_AUX);",
            "#endif",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_partner_supported(const char *msg, const char *partner,",
            "\t\t\t    struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *str = NULL;",
            "",
            "\tif (msg)",
            "\t\tstr = msg;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tstr = mod->name;",
            "#endif",
            "",
            "\tpr_warn(\"Warning: %s is a partner (%s) supported and not supported \"",
            "\t\t\"directly by KylinSoft Corporation.\\n\",",
            "\t\tstr ?: \"Kernel\", partner ?: \"Unknown\");",
            "\tadd_taint(TAINT_PARTNER_SUPPORTED, LOCKDEP_STILL_OK);",
            "#ifdef CONFIG_MODULES",
            "\tif (mod)",
            "\t\tmod->taints |= (1U << TAINT_PARTNER_SUPPORTED);",
            "#endif",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_partner_supported_module(const char *partner, struct module *mod)",
            "{",
            "#if defined(CONFIG_KYLIN_DIFFERENCES) && defined(CONFIG_MODULES)",
            "\tif (!mod)",
            "\t\treturn;",
            "",
            "\tmark_partner_supported(NULL, partner, mod);",
            "#endif",
            "}"
          ],
          "function_name": "mark_tech_preview, mark_partner_supported, mark_partner_supported_module",
          "description": "实现了与合作伙伴支持相关联的标记函数，通过添加特定污点标识和模块状态修改，核心功能是标注技术预览特性或第三方合作组件的非官方支持状态",
          "similarity": 0.4878057539463043
        }
      ]
    },
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.5839911103248596,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.610576868057251
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.4756406545639038
        }
      ]
    },
    {
      "source_file": "kernel/irq/devres.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:52:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\devres.c`\n\n---\n\n# `irq/devres.c` 技术文档\n\n## 1. 文件概述\n\n`irq/devres.c` 是 Linux 内核中用于实现**设备资源管理（Device Resource Management, devres）感知的中断（IRQ）申请与释放机制**的核心文件。该文件封装了标准 IRQ 操作（如 `request_irq`、`free_irq` 等）为“可自动释放”的资源管理版本，确保在设备驱动卸载或设备移除时，已申请的中断资源能被自动、安全地释放，避免资源泄漏。\n\n该机制基于内核的 `devres`（Device Resource）框架，将 IRQ 资源与 `struct device` 生命周期绑定，极大简化了驱动开发中的资源管理逻辑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct irq_devres`**  \n  用于跟踪通过 `devm_*` 接口申请的中断资源，包含：\n  - `irq`：中断号\n  - `dev_id`：传递给中断处理函数的设备标识（用于共享中断的区分）\n\n- **`struct irq_desc_devres`**  \n  用于跟踪通过 `__devm_irq_alloc_descs` 分配的中断描述符范围，包含：\n  - `from`：分配的起始中断号\n  - `cnt`：分配的中断数量\n\n- **`struct irq_generic_chip_devres`**  \n  用于跟踪通过 `devm_irq_setup_generic_chip` 设置的通用中断芯片资源，包含：\n  - `gc`：指向 `irq_chip_generic` 结构的指针\n  - `msk`、`clr`、`set`：用于在释放时还原中断状态的参数\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `devm_request_threaded_irq` | 为设备申请带线程化处理的中断，自动管理生命周期 |\n| `devm_request_any_context_irq` | 为设备申请可在任意上下文（硬中断或线程）处理的中断 |\n| `devm_free_irq` | 手动释放由 `devm_*` 接口申请的中断（通常不需要调用） |\n| `__devm_irq_alloc_descs` | 为设备分配并管理一组中断描述符（IRQ descriptors） |\n| `devm_irq_alloc_generic_chip` | 为设备分配并初始化一个通用中断芯片结构（`irq_chip_generic`） |\n| `devm_irq_setup_generic_chip` | 为设备设置通用中断芯片的中断范围，并注册资源释放回调 |\n\n## 3. 关键实现\n\n### 资源自动释放机制\n- 所有 `devm_*` 接口在成功申请资源后，会通过 `devres_alloc()` 分配一个资源描述结构（如 `irq_devres`），并注册对应的释放函数（如 `devm_irq_release`）。\n- 该资源结构通过 `devres_add()` 绑定到 `struct device`。\n- 当设备被移除（`device_del`）或驱动卸载时，内核自动调用所有注册的 `devres` 释放函数，确保 `free_irq()` 或 `irq_free_descs()` 被正确调用。\n\n### 中断匹配逻辑\n- `devm_free_irq()` 使用 `devm_irq_match` 函数通过 `irq` 和 `dev_id` 精确匹配要释放的资源，确保不会误删其他中断。\n\n### 通用中断芯片支持\n- `devm_irq_alloc_generic_chip` 使用 `devm_kzalloc` 分配内存，确保芯片结构随设备生命周期自动释放。\n- `devm_irq_setup_generic_chip` 在设置芯片后注册 `devm_irq_remove_generic_chip` 回调，在设备移除时自动调用 `irq_remove_generic_chip` 清理中断配置。\n\n### 错误处理\n- 所有分配操作（如 `devres_alloc`）失败时返回 `-ENOMEM`。\n- 底层 IRQ 申请失败时，会释放已分配的 `devres` 结构，避免内存泄漏。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/device.h>`：提供 `devres` 框架接口（`devres_alloc`, `devres_add`, `devres_destroy` 等）\n  - `<linux/interrupt.h>`：提供标准 IRQ 接口（`request_threaded_irq`, `free_irq` 等）\n  - `<linux/irq.h>`：提供中断描述符管理接口（`__irq_alloc_descs`, `irq_free_descs`）\n  - `\"internals.h\"`：包含 IRQ 子系统内部实现细节\n\n- **内核配置依赖**：\n  - `CONFIG_GENERIC_IRQ_CHIP`：启用通用中断芯片支持（影响 `devm_irq_alloc_generic_chip` 和 `devm_irq_setup_generic_chip` 的编译）\n\n- **模块导出**：\n  - `devm_request_threaded_irq`、`devm_request_any_context_irq`、`devm_free_irq` 通过 `EXPORT_SYMBOL` 导出，供其他模块使用。\n  - 中断描述符和通用芯片相关函数通过 `EXPORT_SYMBOL_GPL` 导出，仅限 GPL 兼容模块使用。\n\n## 5. 使用场景\n\n- **驱动开发**：设备驱动在 `probe` 函数中使用 `devm_request_threaded_irq()` 申请中断，无需在 `remove` 函数中显式调用 `free_irq()`，简化代码并避免遗漏。\n- **虚拟中断分配**：平台驱动或中断控制器驱动使用 `__devm_irq_alloc_descs()` 为虚拟设备分配中断号范围，确保在设备移除时自动释放描述符。\n- **通用中断控制器**：使用 `devm_irq_alloc_generic_chip()` 和 `devm_irq_setup_generic_chip()` 管理基于 `irq_chip_generic` 的中断控制器，适用于 GPIO、I2C、SPI 等子系统中的中断复用场景。\n- **资源安全释放**：在驱动异常退出或设备热插拔场景下，内核自动释放 IRQ 资源，防止中断悬挂或资源冲突。",
      "similarity": 0.5611245632171631,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/devres.c",
          "start_line": 18,
          "end_line": 122,
          "content": [
            "static void devm_irq_release(struct device *dev, void *res)",
            "{",
            "\tstruct irq_devres *this = res;",
            "",
            "\tfree_irq(this->irq, this->dev_id);",
            "}",
            "static int devm_irq_match(struct device *dev, void *res, void *data)",
            "{",
            "\tstruct irq_devres *this = res, *match = data;",
            "",
            "\treturn this->irq == match->irq && this->dev_id == match->dev_id;",
            "}",
            "int devm_request_threaded_irq(struct device *dev, unsigned int irq,",
            "\t\t\t      irq_handler_t handler, irq_handler_t thread_fn,",
            "\t\t\t      unsigned long irqflags, const char *devname,",
            "\t\t\t      void *dev_id)",
            "{",
            "\tstruct irq_devres *dr;",
            "\tint rc;",
            "",
            "\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),",
            "\t\t\t  GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!devname)",
            "\t\tdevname = dev_name(dev);",
            "",
            "\trc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,",
            "\t\t\t\t  dev_id);",
            "\tif (rc) {",
            "\t\tdevres_free(dr);",
            "\t\treturn rc;",
            "\t}",
            "",
            "\tdr->irq = irq;",
            "\tdr->dev_id = dev_id;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn 0;",
            "}",
            "int devm_request_any_context_irq(struct device *dev, unsigned int irq,",
            "\t\t\t      irq_handler_t handler, unsigned long irqflags,",
            "\t\t\t      const char *devname, void *dev_id)",
            "{",
            "\tstruct irq_devres *dr;",
            "\tint rc;",
            "",
            "\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),",
            "\t\t\t  GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!devname)",
            "\t\tdevname = dev_name(dev);",
            "",
            "\trc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);",
            "\tif (rc < 0) {",
            "\t\tdevres_free(dr);",
            "\t\treturn rc;",
            "\t}",
            "",
            "\tdr->irq = irq;",
            "\tdr->dev_id = dev_id;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn rc;",
            "}",
            "void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)",
            "{",
            "\tstruct irq_devres match_data = { irq, dev_id };",
            "",
            "\tWARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,",
            "\t\t\t       &match_data));",
            "\tfree_irq(irq, dev_id);",
            "}",
            "static void devm_irq_desc_release(struct device *dev, void *res)",
            "{",
            "\tstruct irq_desc_devres *this = res;",
            "",
            "\tirq_free_descs(this->from, this->cnt);",
            "}",
            "int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,",
            "\t\t\t   unsigned int cnt, int node, struct module *owner,",
            "\t\t\t   const struct irq_affinity_desc *affinity)",
            "{",
            "\tstruct irq_desc_devres *dr;",
            "\tint base;",
            "",
            "\tdr = devres_alloc(devm_irq_desc_release, sizeof(*dr), GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tbase = __irq_alloc_descs(irq, from, cnt, node, owner, affinity);",
            "\tif (base < 0) {",
            "\t\tdevres_free(dr);",
            "\t\treturn base;",
            "\t}",
            "",
            "\tdr->from = base;",
            "\tdr->cnt = cnt;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn base;",
            "}"
          ],
          "function_name": "devm_irq_release, devm_irq_match, devm_request_threaded_irq, devm_request_any_context_irq, devm_free_irq, devm_irq_desc_release, __devm_irq_alloc_descs",
          "description": "实现设备资源管理的中断申请与释放逻辑，包含中断线程处理注册、任意上下文中断申请、中断释放及中断描述符分配等功能，通过devres框架实现资源自动管理。",
          "similarity": 0.5475374460220337
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/devres.c",
          "start_line": 240,
          "end_line": 266,
          "content": [
            "static void devm_irq_remove_generic_chip(struct device *dev, void *res)",
            "{",
            "\tstruct irq_generic_chip_devres *this = res;",
            "",
            "\tirq_remove_generic_chip(this->gc, this->msk, this->clr, this->set);",
            "}",
            "int devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,",
            "\t\t\t\tu32 msk, enum irq_gc_flags flags,",
            "\t\t\t\tunsigned int clr, unsigned int set)",
            "{",
            "\tstruct irq_generic_chip_devres *dr;",
            "",
            "\tdr = devres_alloc(devm_irq_remove_generic_chip,",
            "\t\t\t  sizeof(*dr), GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tirq_setup_generic_chip(gc, msk, flags, clr, set);",
            "",
            "\tdr->gc = gc;",
            "\tdr->msk = msk;",
            "\tdr->clr = clr;",
            "\tdr->set = set;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "devm_irq_remove_generic_chip, devm_irq_setup_generic_chip",
          "description": "提供通用中断芯片的配置与清理接口，用于在设备初始化时设置中断控制器参数并在设备移除时安全地移除通用中断芯片配置。",
          "similarity": 0.52852463722229
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/devres.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "/*",
            " * Device resource management aware IRQ request/free implementation.",
            " */",
            "struct irq_devres {",
            "\tunsigned int irq;",
            "\tvoid *dev_id;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义irq_devres结构体，用于存储中断号和设备ID，作为设备资源管理中断请求的辅助数据结构。",
          "similarity": 0.5068200826644897
        }
      ]
    }
  ]
}