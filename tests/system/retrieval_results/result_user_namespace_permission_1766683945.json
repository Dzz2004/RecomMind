{
  "query": "user namespace permission",
  "timestamp": "2025-12-26 01:32:25",
  "retrieved_files": [
    {
      "source_file": "kernel/user_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:46:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user_namespace.c`\n\n---\n\n# user_namespace.c 技术文档\n\n## 1. 文件概述\n\n`user_namespace.c` 是 Linux 内核中实现用户命名空间（User Namespace）核心功能的源文件。用户命名空间是 Linux 命名空间机制的一部分，用于隔离用户和组 ID（UID/GID），使得不同命名空间中的相同 UID 可以映射到宿主系统中的不同实际 UID/GID。该文件负责用户命名空间的创建、销毁、引用计数管理、ID 映射查找以及与凭证（credentials）的集成，是容器化技术（如 Docker、LXC）实现非特权容器和用户隔离的关键组件。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`create_user_ns(struct cred *new)`**  \n  创建一个新的用户命名空间，设置其父命名空间、层级、所有者、资源限制，并初始化凭证中的命名空间指针。\n\n- **`unshare_userns(unsigned long unshare_flags, struct cred **new_cred)`**  \n  为当前进程创建新的用户命名空间（通过 `unshare(CLONE_NEWUSER)` 系统调用触发），并返回新的凭证结构。\n\n- **`free_user_ns(struct work_struct *work)`**  \n  异步释放用户命名空间及其关联资源（如 ID 映射、sysctl 表、密钥环等），通过工作队列延迟执行以避免死锁。\n\n- **`__put_user_ns(struct user_namespace *ns)`**  \n  减少用户命名空间引用计数，若引用计数归零则调度 `free_user_ns` 工作项进行释放。\n\n- **`map_id_range_down_base()` / `map_id_range_down_max()`**  \n  在 UID/GID 映射表中查找指定 ID 范围对应的映射条目，分别处理小规模（≤4 条）和大规模（>4 条）映射。\n\n- **`cmp_map_id()`**  \n  用于二分查找的比较函数，支持正向（内核 ID → 用户 ID）和反向（用户 ID → 内核 ID）映射查询。\n\n- **`set_cred_user_ns()`**  \n  初始化新凭证中的用户命名空间相关字段，包括能力集（capabilities）、安全位（securebits）和密钥认证上下文。\n\n- **`enforced_nproc_rlimit()`**  \n  根据当前用户是否为全局 root 以及是否处于初始用户命名空间，决定是否对 `RLIMIT_NPROC` 施加限制。\n\n### 主要数据结构\n\n- **`struct user_namespace`**  \n  用户命名空间的核心结构体，包含父命名空间指针、层级、所有者 UID/GID、ID 映射表（uid_map、gid_map、projid_map）、资源使用计数器（ucounts）、引用计数、标志位、密钥环列表等。\n\n- **`struct idmap_key`**  \n  用于 ID 映射查找的辅助结构，封装待查找的 ID、范围长度及映射方向（向上/向下）。\n\n- **`struct uid_gid_extent`**  \n  表示单个 UID/GID 映射区间的结构，包含起始内核 ID、起始用户 ID 和映射长度。\n\n## 3. 关键实现\n\n### 用户命名空间创建流程\n1. **层级限制检查**：防止命名空间嵌套过深（最大 32 层）。\n2. **资源计数**：通过 `inc_user_namespaces()` 增加父命名空间中创建者的用户命名空间使用计数。\n3. **安全策略验证**：\n   - 禁止在 chroot 环境中创建新用户命名空间。\n   - 确保创建者的 UID/GID 在父命名空间中有有效映射。\n4. **安全模块回调**：调用 LSM（如 SELinux、AppArmor）的 `security_create_user_ns()` 钩子进行权限检查。\n5. **初始化新命名空间**：\n   - 分配内存并设置层级、所有者、父指针。\n   - 初始化资源限制（如进程数、消息队列大小等）。\n   - 继承父命名空间的标志（如 `USERNS_SETGROUPS_ALLOWED`）。\n   - 设置凭证中的用户命名空间指针并重置能力集。\n\n### ID 映射查找算法\n- **小规模映射（≤4 条）**：使用线性遍历（`map_id_range_down_base`）。\n- **大规模映射（>4 条）**：使用二分查找（`map_id_range_down_max` + `bsearch`），映射表按 `first` 字段排序。\n- **双向映射支持**：通过 `idmap_key.map_up` 标志区分内核 ID → 用户 ID（map down）和用户 ID → 内核 ID（map up）。\n\n### 异步释放机制\n- 使用 `INIT_WORK()` 将释放操作注册为工作队列任务。\n- 在 `free_user_ns()` 中循环释放命名空间链（处理引用计数级联归零的情况）。\n- 释放动态分配的映射表内存、sysctl 表、密钥环资源，并减少资源使用计数。\n\n### 能力与安全上下文初始化\n- 新命名空间的初始凭证拥有 `CAP_FULL_SET`，但这些能力仅在新命名空间内有效。\n- 清除请求密钥认证（`request_key_auth`）上下文，防止跨命名空间密钥泄露。\n- 重置安全位（`securebits`）为默认值。\n\n## 4. 依赖关系\n\n- **命名空间基础设施**：依赖 `<linux/nsproxy.h>` 和 `ns_common` 结构，与 `proc_ns.c` 协作提供 `/proc/<pid>/ns/user` 接口。\n- **凭证管理**：与 `<linux/cred.h>` 紧密集成，通过 `prepare_creds()`/`put_cred()` 管理凭证生命周期。\n- **资源计数**：使用 `<linux/user_namespace.h>` 中的 `ucounts` 机制跟踪用户命名空间、进程数等资源使用。\n- **安全模块**：通过 LSM 接口（`security_create_user_ns()`）与安全子系统交互。\n- **密钥管理**：依赖 `<keys/user-type.h>` 实现命名空间隔离的用户密钥环。\n- **内存管理**：使用 SLAB 分配器（`kmem_cache`）高效分配 `user_namespace` 结构。\n- **ID 映射**：与 `uidgid.c` 协同实现 UID/GID 映射的设置与查询。\n\n## 5. 使用场景\n\n- **容器运行时**：Docker、Podman、LXC 等通过 `unshare(CLONE_NEWUSER)` 创建非特权容器，实现用户隔离。\n- **用户态命名空间管理**：`unshare(1)` 命令或 `clone(2)` 系统调用创建独立用户上下文。\n- **特权降级**：进程在创建用户命名空间后映射自身为新命名空间的 root，获得有限特权。\n- **安全沙箱**：浏览器、应用沙箱利用用户命名空间限制潜在攻击面。\n- **ID 映射服务**：`newuidmap`/`newgidmap` 工具通过写入 `/proc/<pid>/uid_map` 配置映射，内核通过本文件中的查找函数解析映射关系。\n- **资源隔离**：结合 `ucounts` 机制限制单个用户可创建的用户命名空间数量，防止资源耗尽攻击。",
      "similarity": 0.6360577940940857,
      "chunks": [
        {
          "chunk_id": 7,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1297,
          "end_line": 1365,
          "content": [
            "bool userns_may_setgroups(const struct user_namespace *ns)",
            "{",
            "\tbool allowed;",
            "",
            "\tmutex_lock(&userns_state_mutex);",
            "\t/* It is not safe to use setgroups until a gid mapping in",
            "\t * the user namespace has been established.",
            "\t */",
            "\tallowed = ns->gid_map.nr_extents != 0;",
            "\t/* Is setgroups allowed? */",
            "\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "\treturn allowed;",
            "}",
            "bool in_userns(const struct user_namespace *ancestor,",
            "\t       const struct user_namespace *child)",
            "{",
            "\tconst struct user_namespace *ns;",
            "\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)",
            "\t\t;",
            "\treturn (ns == ancestor);",
            "}",
            "bool current_in_userns(const struct user_namespace *target_ns)",
            "{",
            "\treturn in_userns(target_ns, current_user_ns());",
            "}",
            "static void userns_put(struct ns_common *ns)",
            "{",
            "\tput_user_ns(to_user_ns(ns));",
            "}",
            "static int userns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct user_namespace *user_ns = to_user_ns(ns);",
            "\tstruct cred *cred;",
            "",
            "\t/* Don't allow gaining capabilities by reentering",
            "\t * the same user namespace.",
            "\t */",
            "\tif (user_ns == current_user_ns())",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Tasks that share a thread group must share a user namespace */",
            "\tif (!thread_group_empty(current))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (current->fs->users != 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tcred = nsset_cred(nsset);",
            "\tif (!cred)",
            "\t\treturn -EINVAL;",
            "",
            "\tput_user_ns(cred->user_ns);",
            "\tset_cred_user_ns(cred, get_user_ns(user_ns));",
            "",
            "\tif (set_cred_ucounts(cred) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static __init int user_namespaces_init(void)",
            "{",
            "\tuser_ns_cachep = KMEM_CACHE(user_namespace, SLAB_PANIC | SLAB_ACCOUNT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "userns_may_setgroups, in_userns, current_in_userns, userns_put, userns_install, user_namespaces_init",
          "description": "实现用户命名空间相关辅助功能，userns_may_setgroups检查setgroups可用性，in_userns判断命名空间层级关系，userns_install负责用户命名空间的安装与引用计数管理，user_namespaces_init初始化用户命名空间对象缓存",
          "similarity": 0.631224513053894
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/user_namespace.c",
          "start_line": 41,
          "end_line": 180,
          "content": [
            "static void dec_user_namespaces(struct ucounts *ucounts)",
            "{",
            "\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);",
            "}",
            "static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)",
            "{",
            "\t/* Start with the same capabilities as init but useless for doing",
            "\t * anything as the capabilities are bound to the new user namespace.",
            "\t */",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_securebits(cred, SECUREBITS_DEFAULT);",
            "\tiee_set_cred_cap_inheritable(cred, CAP_EMPTY_SET);",
            "\tiee_set_cred_cap_permitted(cred, CAP_FULL_SET);",
            "\tiee_set_cred_cap_effective(cred, CAP_FULL_SET);",
            "\tiee_set_cred_cap_ambient(cred, CAP_EMPTY_SET);",
            "\tiee_set_cred_cap_bset(cred, CAP_FULL_SET);",
            "#ifdef CONFIG_KEYS",
            "\tkey_put(cred->request_key_auth);",
            "\tiee_set_cred_request_key_auth(cred, NULL);",
            "#endif",
            "\tiee_set_cred_user_ns(cred, user_ns);",
            "\t#else",
            "\tcred->securebits = SECUREBITS_DEFAULT;",
            "\tcred->cap_inheritable = CAP_EMPTY_SET;",
            "\tcred->cap_permitted = CAP_FULL_SET;",
            "\tcred->cap_effective = CAP_FULL_SET;",
            "\tcred->cap_ambient = CAP_EMPTY_SET;",
            "\tcred->cap_bset = CAP_FULL_SET;",
            "#ifdef CONFIG_KEYS",
            "\tkey_put(cred->request_key_auth);",
            "\tcred->request_key_auth = NULL;",
            "#endif",
            "\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */",
            "\tcred->user_ns = user_ns;",
            "\t#endif",
            "}",
            "static unsigned long enforced_nproc_rlimit(void)",
            "{",
            "\tunsigned long limit = RLIM_INFINITY;",
            "",
            "\t/* Is RLIMIT_NPROC currently enforced? */",
            "\tif (!uid_eq(current_uid(), GLOBAL_ROOT_UID) ||",
            "\t    (current_user_ns() != &init_user_ns))",
            "\t\tlimit = rlimit(RLIMIT_NPROC);",
            "",
            "\treturn limit;",
            "}",
            "int create_user_ns(struct cred *new)",
            "{",
            "\tstruct user_namespace *ns, *parent_ns = new->user_ns;",
            "\tkuid_t owner = new->euid;",
            "\tkgid_t group = new->egid;",
            "\tstruct ucounts *ucounts;",
            "\tint ret, i;",
            "",
            "\tret = -ENOSPC;",
            "\tif (parent_ns->level > 32)",
            "\t\tgoto fail;",
            "",
            "\tucounts = inc_user_namespaces(parent_ns, owner);",
            "\tif (!ucounts)",
            "\t\tgoto fail;",
            "",
            "\t/*",
            "\t * Verify that we can not violate the policy of which files",
            "\t * may be accessed that is specified by the root directory,",
            "\t * by verifying that the root directory is at the root of the",
            "\t * mount namespace which allows all files to be accessed.",
            "\t */",
            "\tret = -EPERM;",
            "\tif (current_chrooted())",
            "\t\tgoto fail_dec;",
            "",
            "\t/* The creator needs a mapping in the parent user namespace",
            "\t * or else we won't be able to reasonably tell userspace who",
            "\t * created a user_namespace.",
            "\t */",
            "\tret = -EPERM;",
            "\tif (!kuid_has_mapping(parent_ns, owner) ||",
            "\t    !kgid_has_mapping(parent_ns, group))",
            "\t\tgoto fail_dec;",
            "",
            "\tret = security_create_user_ns(new);",
            "\tif (ret < 0)",
            "\t\tgoto fail_dec;",
            "",
            "\tret = -ENOMEM;",
            "\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);",
            "\tif (!ns)",
            "\t\tgoto fail_dec;",
            "",
            "\tns->parent_could_setfcap = cap_raised(new->cap_effective, CAP_SETFCAP);",
            "\tret = ns_alloc_inum(&ns->ns);",
            "\tif (ret)",
            "\t\tgoto fail_free;",
            "\tns->ns.ops = &userns_operations;",
            "",
            "\trefcount_set(&ns->ns.count, 1);",
            "\t/* Leave the new->user_ns reference with the new user namespace. */",
            "\tns->parent = parent_ns;",
            "\tns->level = parent_ns->level + 1;",
            "\tns->owner = owner;",
            "\tns->group = group;",
            "\tINIT_WORK(&ns->work, free_user_ns);",
            "\tfor (i = 0; i < UCOUNT_COUNTS; i++) {",
            "\t\tns->ucount_max[i] = INT_MAX;",
            "\t}",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_NPROC, enforced_nproc_rlimit());",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_MSGQUEUE, rlimit(RLIMIT_MSGQUEUE));",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_SIGPENDING, rlimit(RLIMIT_SIGPENDING));",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_MEMLOCK, rlimit(RLIMIT_MEMLOCK));",
            "\tns->ucounts = ucounts;",
            "",
            "\t/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */",
            "\tmutex_lock(&userns_state_mutex);",
            "\tns->flags = parent_ns->flags;",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "#ifdef CONFIG_KEYS",
            "\tINIT_LIST_HEAD(&ns->keyring_name_list);",
            "\tinit_rwsem(&ns->keyring_sem);",
            "#endif",
            "\tret = -ENOMEM;",
            "\tif (!setup_userns_sysctls(ns))",
            "\t\tgoto fail_keyring;",
            "",
            "\tset_cred_user_ns(new, ns);",
            "\treturn 0;",
            "fail_keyring:",
            "#ifdef CONFIG_PERSISTENT_KEYRINGS",
            "\tkey_put(ns->persistent_keyring_register);",
            "#endif",
            "\tns_free_inum(&ns->ns);",
            "fail_free:",
            "\tkmem_cache_free(user_ns_cachep, ns);",
            "fail_dec:",
            "\tdec_user_namespaces(ucounts);",
            "fail:",
            "\treturn ret;",
            "}"
          ],
          "function_name": "dec_user_namespaces, set_cred_user_ns, enforced_nproc_rlimit, create_user_ns",
          "description": "实现用户命名空间创建逻辑，包含权限验证、资源分配、安全策略应用及命名空间引用计数管理。",
          "similarity": 0.6029629707336426
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1,
          "end_line": 40,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/export.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/highuid.h>",
            "#include <linux/cred.h>",
            "#include <linux/securebits.h>",
            "#include <linux/security.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ctype.h>",
            "#include <linux/projid.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/sort.h>",
            "#ifdef CONFIG_CREDP",
            "#include <asm/iee-cred.h>",
            "#endif",
            "",
            "static struct kmem_cache *user_ns_cachep __ro_after_init;",
            "static DEFINE_MUTEX(userns_state_mutex);",
            "",
            "static bool new_idmap_permitted(const struct file *file,",
            "\t\t\t\tstruct user_namespace *ns, int cap_setid,",
            "\t\t\t\tstruct uid_gid_map *map);",
            "static void free_user_ns(struct work_struct *work);",
            "",
            "static struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)",
            "{",
            "\treturn inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用户命名空间相关全局变量和缓存，声明辅助函数及用户命名空间操作的通用接口。",
          "similarity": 0.5580556988716125
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1125,
          "end_line": 1290,
          "content": [
            "ssize_t proc_uid_map_write(struct file *file, const char __user *buf,",
            "\t\t\t   size_t size, loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct user_namespace *seq_ns = seq_user_ns(seq);",
            "",
            "\tif (!ns->parent)",
            "\t\treturn -EPERM;",
            "",
            "\tif ((seq_ns != ns) && (seq_ns != ns->parent))",
            "\t\treturn -EPERM;",
            "",
            "\treturn map_write(file, buf, size, ppos, CAP_SETUID,",
            "\t\t\t &ns->uid_map, &ns->parent->uid_map);",
            "}",
            "ssize_t proc_gid_map_write(struct file *file, const char __user *buf,",
            "\t\t\t   size_t size, loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct user_namespace *seq_ns = seq_user_ns(seq);",
            "",
            "\tif (!ns->parent)",
            "\t\treturn -EPERM;",
            "",
            "\tif ((seq_ns != ns) && (seq_ns != ns->parent))",
            "\t\treturn -EPERM;",
            "",
            "\treturn map_write(file, buf, size, ppos, CAP_SETGID,",
            "\t\t\t &ns->gid_map, &ns->parent->gid_map);",
            "}",
            "ssize_t proc_projid_map_write(struct file *file, const char __user *buf,",
            "\t\t\t      size_t size, loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct user_namespace *seq_ns = seq_user_ns(seq);",
            "",
            "\tif (!ns->parent)",
            "\t\treturn -EPERM;",
            "",
            "\tif ((seq_ns != ns) && (seq_ns != ns->parent))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Anyone can set any valid project id no capability needed */",
            "\treturn map_write(file, buf, size, ppos, -1,",
            "\t\t\t &ns->projid_map, &ns->parent->projid_map);",
            "}",
            "static bool new_idmap_permitted(const struct file *file,",
            "\t\t\t\tstruct user_namespace *ns, int cap_setid,",
            "\t\t\t\tstruct uid_gid_map *new_map)",
            "{",
            "\tconst struct cred *cred = file->f_cred;",
            "",
            "\tif (cap_setid == CAP_SETUID && !verify_root_map(file, ns, new_map))",
            "\t\treturn false;",
            "",
            "\t/* Don't allow mappings that would allow anything that wouldn't",
            "\t * be allowed without the establishment of unprivileged mappings.",
            "\t */",
            "\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1) &&",
            "\t    uid_eq(ns->owner, cred->euid)) {",
            "\t\tu32 id = new_map->extent[0].lower_first;",
            "\t\tif (cap_setid == CAP_SETUID) {",
            "\t\t\tkuid_t uid = make_kuid(ns->parent, id);",
            "\t\t\tif (uid_eq(uid, cred->euid))",
            "\t\t\t\treturn true;",
            "\t\t} else if (cap_setid == CAP_SETGID) {",
            "\t\t\tkgid_t gid = make_kgid(ns->parent, id);",
            "\t\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED) &&",
            "\t\t\t    gid_eq(gid, cred->egid))",
            "\t\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Allow anyone to set a mapping that doesn't require privilege */",
            "\tif (!cap_valid(cap_setid))",
            "\t\treturn true;",
            "",
            "\t/* Allow the specified ids if we have the appropriate capability",
            "\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.",
            "\t * And the opener of the id file also has the appropriate capability.",
            "\t */",
            "\tif (ns_capable(ns->parent, cap_setid) &&",
            "\t    file_ns_capable(file, ns->parent, cap_setid))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "int proc_setgroups_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct user_namespace *ns = seq->private;",
            "\tunsigned long userns_flags = READ_ONCE(ns->flags);",
            "",
            "\tseq_printf(seq, \"%s\\n\",",
            "\t\t   (userns_flags & USERNS_SETGROUPS_ALLOWED) ?",
            "\t\t   \"allow\" : \"deny\");",
            "\treturn 0;",
            "}",
            "ssize_t proc_setgroups_write(struct file *file, const char __user *buf,",
            "\t\t\t     size_t count, loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *ns = seq->private;",
            "\tchar kbuf[8], *pos;",
            "\tbool setgroups_allowed;",
            "\tssize_t ret;",
            "",
            "\t/* Only allow a very narrow range of strings to be written */",
            "\tret = -EINVAL;",
            "\tif ((*ppos != 0) || (count >= sizeof(kbuf)))",
            "\t\tgoto out;",
            "",
            "\t/* What was written? */",
            "\tret = -EFAULT;",
            "\tif (copy_from_user(kbuf, buf, count))",
            "\t\tgoto out;",
            "\tkbuf[count] = '\\0';",
            "\tpos = kbuf;",
            "",
            "\t/* What is being requested? */",
            "\tret = -EINVAL;",
            "\tif (strncmp(pos, \"allow\", 5) == 0) {",
            "\t\tpos += 5;",
            "\t\tsetgroups_allowed = true;",
            "\t}",
            "\telse if (strncmp(pos, \"deny\", 4) == 0) {",
            "\t\tpos += 4;",
            "\t\tsetgroups_allowed = false;",
            "\t}",
            "\telse",
            "\t\tgoto out;",
            "",
            "\t/* Verify there is not trailing junk on the line */",
            "\tpos = skip_spaces(pos);",
            "\tif (*pos != '\\0')",
            "\t\tgoto out;",
            "",
            "\tret = -EPERM;",
            "\tmutex_lock(&userns_state_mutex);",
            "\tif (setgroups_allowed) {",
            "\t\t/* Enabling setgroups after setgroups has been disabled",
            "\t\t * is not allowed.",
            "\t\t */",
            "\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED))",
            "\t\t\tgoto out_unlock;",
            "\t} else {",
            "\t\t/* Permanently disabling setgroups after setgroups has",
            "\t\t * been enabled by writing the gid_map is not allowed.",
            "\t\t */",
            "\t\tif (ns->gid_map.nr_extents != 0)",
            "\t\t\tgoto out_unlock;",
            "\t\tns->flags &= ~USERNS_SETGROUPS_ALLOWED;",
            "\t}",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "\t/* Report a successful write */",
            "\t*ppos = count;",
            "\tret = count;",
            "out:",
            "\treturn ret;",
            "out_unlock:",
            "\tmutex_unlock(&userns_state_mutex);",
            "\tgoto out;",
            "}"
          ],
          "function_name": "proc_uid_map_write, proc_gid_map_write, proc_projid_map_write, new_idmap_permitted, proc_setgroups_show, proc_setgroups_write",
          "description": "提供用户/组/项目ID映射文件的操作接口，proc_*_map_write系列函数通过map_write设置对应ID映射，new_idmap_permitted验证新映射权限，proc_setgroups控制组切换权限，支持允许/禁止setgroups操作",
          "similarity": 0.5572350025177002
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/user_namespace.c",
          "start_line": 193,
          "end_line": 310,
          "content": [
            "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)",
            "{",
            "\tstruct cred *cred;",
            "\tint err = -ENOMEM;",
            "",
            "\tif (!(unshare_flags & CLONE_NEWUSER))",
            "\t\treturn 0;",
            "",
            "\tcred = prepare_creds();",
            "\tif (cred) {",
            "\t\terr = create_user_ns(cred);",
            "\t\tif (err)",
            "\t\t\tput_cred(cred);",
            "\t\telse",
            "\t\t\t*new_cred = cred;",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "static void free_user_ns(struct work_struct *work)",
            "{",
            "\tstruct user_namespace *parent, *ns =",
            "\t\tcontainer_of(work, struct user_namespace, work);",
            "",
            "\tdo {",
            "\t\tstruct ucounts *ucounts = ns->ucounts;",
            "\t\tparent = ns->parent;",
            "\t\tif (ns->gid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\t\tkfree(ns->gid_map.forward);",
            "\t\t\tkfree(ns->gid_map.reverse);",
            "\t\t}",
            "\t\tif (ns->uid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\t\tkfree(ns->uid_map.forward);",
            "\t\t\tkfree(ns->uid_map.reverse);",
            "\t\t}",
            "\t\tif (ns->projid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\t\tkfree(ns->projid_map.forward);",
            "\t\t\tkfree(ns->projid_map.reverse);",
            "\t\t}",
            "\t\tretire_userns_sysctls(ns);",
            "\t\tkey_free_user_ns(ns);",
            "\t\tns_free_inum(&ns->ns);",
            "\t\tkmem_cache_free(user_ns_cachep, ns);",
            "\t\tdec_user_namespaces(ucounts);",
            "\t\tns = parent;",
            "\t} while (refcount_dec_and_test(&parent->ns.count));",
            "}",
            "void __put_user_ns(struct user_namespace *ns)",
            "{",
            "\tschedule_work(&ns->work);",
            "}",
            "static int cmp_map_id(const void *k, const void *e)",
            "{",
            "\tu32 first, last, id2;",
            "\tconst struct idmap_key *key = k;",
            "\tconst struct uid_gid_extent *el = e;",
            "",
            "\tid2 = key->id + key->count - 1;",
            "",
            "\t/* handle map_id_{down,up}() */",
            "\tif (key->map_up)",
            "\t\tfirst = el->lower_first;",
            "\telse",
            "\t\tfirst = el->first;",
            "",
            "\tlast = first + el->count - 1;",
            "",
            "\tif (key->id >= first && key->id <= last &&",
            "\t    (id2 >= first && id2 <= last))",
            "\t\treturn 0;",
            "",
            "\tif (key->id < first || id2 < first)",
            "\t\treturn -1;",
            "",
            "\treturn 1;",
            "}",
            "static u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)",
            "{",
            "\tstruct uid_gid_extent *extent;",
            "\tunsigned extents = map->nr_extents;",
            "\tsmp_rmb();",
            "",
            "\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\textent = map_id_range_down_base(extents, map, id, count);",
            "\telse",
            "\t\textent = map_id_range_down_max(extents, map, id, count);",
            "",
            "\t/* Map the id or note failure */",
            "\tif (extent)",
            "\t\tid = (id - extent->first) + extent->lower_first;",
            "\telse",
            "\t\tid = (u32) -1;",
            "",
            "\treturn id;",
            "}",
            "static u32 map_id_down(struct uid_gid_map *map, u32 id)",
            "{",
            "\treturn map_id_range_down(map, id, 1);",
            "}",
            "static u32 map_id_up(struct uid_gid_map *map, u32 id)",
            "{",
            "\tstruct uid_gid_extent *extent;",
            "\tunsigned extents = map->nr_extents;",
            "\tsmp_rmb();",
            "",
            "\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\textent = map_id_up_base(extents, map, id);",
            "\telse",
            "\t\textent = map_id_up_max(extents, map, id);",
            "",
            "\t/* Map the id or note failure */",
            "\tif (extent)",
            "\t\tid = (id - extent->lower_first) + extent->first;",
            "\telse",
            "\t\tid = (u32) -1;",
            "",
            "\treturn id;",
            "}"
          ],
          "function_name": "unshare_userns, free_user_ns, __put_user_ns, cmp_map_id, map_id_range_down, map_id_down, map_id_up",
          "description": "提供用户命名空间解隔离接口与析构逻辑，包含映射表清理、引用计数递减及延迟释放机制。",
          "similarity": 0.5532295107841492
        }
      ]
    },
    {
      "source_file": "kernel/user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:58\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user.c`\n\n---\n\n# user.c 技术文档\n\n## 1. 文件概述\n\n`user.c` 实现了 Linux 内核中的 **用户缓存（user cache）** 机制，用于跟踪每个用户（以 UID 标识）所占用的系统资源（如进程数、打开文件数等），从而支持基于用户的资源限制（per-user limits）。该文件维护了一个全局的哈希表，用于快速查找和管理 `user_struct` 结构体实例，并提供了用户结构的分配、引用计数管理和释放接口。此外，文件还定义了初始用户命名空间 `init_user_ns` 和根用户结构 `root_user`，为系统启动和用户命名空间功能提供基础支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`init_user_ns`**：全局初始用户命名空间（`struct user_namespace`），作为所有用户命名空间的根，包含完整的 UID/GID/ProjID 映射（0~2³²-1），引用计数初始化为 3。\n- **`root_user`**：代表 UID 为 0 的根用户的 `struct user_struct` 实例，引用计数初始化为 1（供 init 进程使用）。\n- **`uidhash_table`**：大小为 `2^UIDHASH_BITS`（通常为 128）的哈希表，用于存储 `user_struct` 实例，实现 O(1) 平均查找复杂度。\n- **`uid_cachep`**：SLAB 缓存，用于高效分配和释放 `struct user_struct` 对象。\n\n### 主要函数\n\n- **`alloc_uid(kuid_t uid)`**：根据 UID 查找或创建对应的 `user_struct`。若不存在则分配新结构体，初始化资源计数器（如 epoll watches），并插入哈希表；若已存在则增加引用计数。处理并发创建的竞争条件。\n- **`find_user(kuid_t uid)`**：在哈希表中查找指定 UID 的 `user_struct`，若找到则增加引用计数并返回，否则返回 NULL。\n- **`free_uid(struct user_struct *up)`**：减少 `user_struct` 的引用计数，若计数归零则调用 `free_user` 释放资源。\n- **`free_user(struct user_struct *up, unsigned long flags)`**：内部函数，从哈希表中移除用户结构，释放 epoll 计数器，并通过 SLAB 缓存回收内存。\n- **`uid_cache_init(void)`**：初始化函数（通过 `subsys_initcall` 注册），创建 SLAB 缓存、初始化哈希表、为 `root_user` 分配 epoll 计数器，并将 `root_user` 插入哈希表。\n\n### 辅助函数\n\n- **`uid_hash_insert/remove/find`**：哈希表操作的内部封装，必须在持有 `uidhash_lock` 自旋锁时调用。\n- **`user_epoll_alloc/free`**：条件编译函数，用于初始化/销毁 `user_struct` 中的 epoll watches per-CPU 计数器（仅当 `CONFIG_EPOLL` 启用时有效）。\n\n## 3. 关键实现\n\n### 哈希表设计与并发控制\n\n- **哈希函数**：使用 `__uidhashfn(uid) = ((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK`，将 32 位 UID 映射到 `UIDHASH_SZ`（默认 128）个桶中，减少冲突。\n- **锁机制**：使用 `DEFINE_SPINLOCK(uidhash_lock)` 保护哈希表操作。该锁需 **软中断安全（softirq-safe）**，因为 `free_uid()` 可能在 RCU 回调（软中断上下文）中被调用。\n- **中断处理**：所有哈希表操作均使用 `spin_lock_irqsave/restore` 或 `spin_lock_irq/unlock`，确保在中断上下文和进程上下文间的正确同步。\n\n### 引用计数与资源管理\n\n- **引用计数**：`user_struct.__count` 使用 `refcount_t` 类型，确保原子操作。`alloc_uid` 返回时已持有引用，调用者必须通过 `free_uid` 释放。\n- **延迟释放**：`free_uid` 使用 `refcount_dec_and_lock_irqsave` 原子地减少计数并在归零时获取锁，避免竞态条件。\n- **资源初始化**：新创建的 `user_struct` 会初始化速率限制器（`ratelimit`）和 epoll watches 计数器（若启用）。\n\n### 初始化与竞态处理\n\n- **`root_user` 预置**：在 `uid_cache_init` 中预先将 `root_user` 插入哈希表，确保 init 进程可直接使用。\n- **双重检查**：`alloc_uid` 在分配新结构后再次检查哈希表，防止多线程同时创建同一 UID 的 `user_struct`，确保唯一性。\n\n### 用户命名空间支持\n\n- **`init_user_ns`**：作为初始用户命名空间，其 UID/GID 映射覆盖全范围（0 到 2³²-1），标志位 `USERNS_INIT_FLAGS` 启用特定行为（如允许 setgroups）。\n- **密钥环支持**：若启用 `CONFIG_KEYS`，`init_user_ns` 包含密钥环名称列表和读写信号量。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/sched/user.h>`：定义 `struct user_struct`。\n  - `<linux/user_namespace.h>`：定义 `struct user_namespace` 和相关操作。\n  - `<linux/key.h>`：提供密钥环支持（条件编译）。\n  - `<linux/percpu_counter.h>`（隐含）：用于 epoll watches 计数（通过 `CONFIG_EPOLL`）。\n- **内核配置依赖**：\n  - `CONFIG_EPOLL`：控制 epoll watches 计数器的编译。\n  - `CONFIG_USER_NS`：控制用户命名空间操作函数的绑定。\n  - `CONFIG_KEYS`：控制密钥环相关字段的初始化。\n- **子系统依赖**：\n  - **进程调度子系统**：`user_struct` 被嵌入到进程凭证（`cred`）中，用于资源统计。\n  - **用户命名空间子系统**：`init_user_ns` 是用户命名空间层次结构的根。\n  - **内存管理子系统**：依赖 SLAB 分配器管理 `user_struct` 对象。\n\n## 5. 使用场景\n\n- **进程凭证管理**：当进程通过 `setuid()`、`setreuid()` 等系统调用切换用户身份时，内核调用 `alloc_uid` 获取目标 UID 的 `user_struct`，并更新进程凭证中的用户引用。\n- **资源限制实施**：内核在创建进程、打开文件、分配内存等操作时，通过 `current_uid()` 获取当前用户的 `user_struct`，检查并更新资源使用计数（如 `processes`、`files` 字段），确保不超过 `ulimit` 限制。\n- **用户命名空间创建**：新用户命名空间的创建依赖 `init_user_ns` 作为父命名空间，并继承其映射逻辑。\n- **系统初始化**：在内核启动早期（`subsys_initcall` 阶段），初始化用户缓存和根用户结构，为 init 进程（PID 1）提供用户上下文。\n- **资源回收**：当进程退出或切换用户时，通过 `free_uid` 释放不再需要的 `user_struct` 引用，最终在引用计数归零时回收内存和相关资源（如 epoll 计数器）。",
      "similarity": 0.56397944688797,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user.c",
          "start_line": 108,
          "end_line": 167,
          "content": [
            "static void uid_hash_insert(struct user_struct *up, struct hlist_head *hashent)",
            "{",
            "\thlist_add_head(&up->uidhash_node, hashent);",
            "}",
            "static void uid_hash_remove(struct user_struct *up)",
            "{",
            "\thlist_del_init(&up->uidhash_node);",
            "}",
            "static int user_epoll_alloc(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\treturn percpu_counter_init(&up->epoll_watches, 0, GFP_KERNEL);",
            "#else",
            "\treturn 0;",
            "#endif",
            "}",
            "static void user_epoll_free(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\tpercpu_counter_destroy(&up->epoll_watches);",
            "#endif",
            "}",
            "static void free_user(struct user_struct *up, unsigned long flags)",
            "\t__releases(&uidhash_lock)",
            "{",
            "\tuid_hash_remove(up);",
            "\tspin_unlock_irqrestore(&uidhash_lock, flags);",
            "\tuser_epoll_free(up);",
            "\tkmem_cache_free(uid_cachep, up);",
            "}",
            "void free_uid(struct user_struct *up)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!up)",
            "\t\treturn;",
            "",
            "\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))",
            "\t\tfree_user(up, flags);",
            "}",
            "static int __init uid_cache_init(void)",
            "{",
            "\tint n;",
            "",
            "\tuid_cachep = kmem_cache_create(\"uid_cache\", sizeof(struct user_struct),",
            "\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);",
            "",
            "\tfor(n = 0; n < UIDHASH_SZ; ++n)",
            "\t\tINIT_HLIST_HEAD(uidhash_table + n);",
            "",
            "\tif (user_epoll_alloc(&root_user))",
            "\t\tpanic(\"root_user epoll percpu counter alloc failed\");",
            "",
            "\t/* Insert the root user immediately (init already runs as root) */",
            "\tspin_lock_irq(&uidhash_lock);",
            "\tuid_hash_insert(&root_user, uidhashentry(GLOBAL_ROOT_UID));",
            "\tspin_unlock_irq(&uidhash_lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "uid_hash_insert, uid_hash_remove, user_epoll_alloc, user_epoll_free, free_user, free_uid, uid_cache_init",
          "description": "实现用户结构体在UID哈希表中的增删操作，管理epoll计数器资源分配释放，提供free_user/free_uid接口完成用户结构销毁流程，初始化uid_cache缓存及哈希表基础结构并注册根用户",
          "similarity": 0.5181635618209839
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user.c",
          "start_line": 1,
          "end_line": 107,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * The \"user cache\".",
            " *",
            " * (C) Copyright 1991-2000 Linus Torvalds",
            " *",
            " * We have a per-user structure to keep track of how many",
            " * processes, files etc the user has claimed, in order to be",
            " * able to have per-user limits for system resources. ",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "",
            "/*",
            " * userns count is 1 for root user, 1 for init_uts_ns,",
            " * and 1 for... ?",
            " */",
            "struct user_namespace init_user_ns = {",
            "\t.uid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.gid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.projid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.ns.count = REFCOUNT_INIT(3),",
            "\t.owner = GLOBAL_ROOT_UID,",
            "\t.group = GLOBAL_ROOT_GID,",
            "\t.ns.inum = PROC_USER_INIT_INO,",
            "#ifdef CONFIG_USER_NS",
            "\t.ns.ops = &userns_operations,",
            "#endif",
            "\t.flags = USERNS_INIT_FLAGS,",
            "#ifdef CONFIG_KEYS",
            "\t.keyring_name_list = LIST_HEAD_INIT(init_user_ns.keyring_name_list),",
            "\t.keyring_sem = __RWSEM_INITIALIZER(init_user_ns.keyring_sem),",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_user_ns);",
            "",
            "/*",
            " * UID task count cache, to get fast user lookup in \"alloc_uid\"",
            " * when changing user ID's (ie setuid() and friends).",
            " */",
            "",
            "#define UIDHASH_BITS\t(CONFIG_BASE_SMALL ? 3 : 7)",
            "#define UIDHASH_SZ\t(1 << UIDHASH_BITS)",
            "#define UIDHASH_MASK\t\t(UIDHASH_SZ - 1)",
            "#define __uidhashfn(uid)\t(((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK)",
            "#define uidhashentry(uid)\t(uidhash_table + __uidhashfn((__kuid_val(uid))))",
            "",
            "static struct kmem_cache *uid_cachep;",
            "static struct hlist_head uidhash_table[UIDHASH_SZ];",
            "",
            "/*",
            " * The uidhash_lock is mostly taken from process context, but it is",
            " * occasionally also taken from softirq/tasklet context, when",
            " * task-structs get RCU-freed. Hence all locking must be softirq-safe.",
            " * But free_uid() is also called with local interrupts disabled, and running",
            " * local_bh_enable() with local interrupts disabled is an error - we'll run",
            " * softirq callbacks, and they can unconditionally enable interrupts, and",
            " * the caller of free_uid() didn't expect that..",
            " */",
            "static DEFINE_SPINLOCK(uidhash_lock);",
            "",
            "/* root_user.__count is 1, for init task cred */",
            "struct user_struct root_user = {",
            "\t.__count\t= REFCOUNT_INIT(1),",
            "\t.uid\t\t= GLOBAL_ROOT_UID,",
            "\t.ratelimit\t= RATELIMIT_STATE_INIT(root_user.ratelimit, 0, 0),",
            "};",
            "",
            "/*",
            " * These routines must be called with the uidhash spinlock held!",
            " */"
          ],
          "function_name": null,
          "description": "定义初始用户命名空间init_user_ns，配置UID/GID/PROJID映射关系并初始化引用计数，建立全局根用户user_struct结构，通过uidhash_table构建基于哈希的UID快速查找表，设置UID哈希锁及缓存参数",
          "similarity": 0.5175184011459351
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:49:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\namespace.c`\n\n---\n\n# cgroup/namespace.c 技术文档\n\n## 1. 文件概述\n\n`cgroup/namespace.c` 实现了 cgroup 命名空间（cgroup namespace）的核心功能。该文件为 Linux 内核提供了对 cgroup 命名空间的支持，使得不同进程可以拥有隔离的 cgroup 视图，从而增强容器化环境中的资源隔离能力。cgroup 命名空间允许进程看到一个以当前进程所属 cgroup 为根的虚拟 cgroup 文件系统视图，而不是全局的 cgroup 层次结构。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `alloc_cgroup_ns()`：分配并初始化一个新的 cgroup 命名空间结构体。\n- `free_cgroup_ns()`：释放 cgroup 命名空间及其关联资源。\n- `copy_cgroup_ns()`：在进程 fork 或 clone 时复制 cgroup 命名空间，支持 `CLONE_NEWCGROUP` 标志创建新命名空间。\n- `cgroupns_install()`：将指定的 cgroup 命名空间安装到当前进程的 `nsproxy` 中。\n- `cgroupns_get()` / `cgroupns_put()`：用于引用计数管理，获取和释放 cgroup 命名空间。\n- `cgroupns_owner()`：返回该 cgroup 命名空间所属的用户命名空间。\n\n### 关键数据结构\n\n- `struct cgroup_namespace`：表示一个 cgroup 命名空间，包含：\n  - `ns`：通用命名空间结构（`struct ns_common`）\n  - `root_cset`：指向该命名空间根 css_set（控制组集合）\n  - `user_ns`：关联的用户命名空间\n  - `ucounts`：用于资源计数（限制命名空间数量）\n\n- `cgroupns_operations`：`proc_ns_operations` 类型的全局常量，定义了 cgroup 命名空间在 `/proc/[pid]/ns/cgroup` 中的操作接口。\n\n## 3. 关键实现\n\n### 命名空间创建与资源限制\n- 使用 `inc_cgroup_namespaces()` 和 `dec_cgroup_namespaces()` 通过 `ucounts` 机制限制每个用户命名空间可创建的 cgroup 命名空间数量，防止资源耗尽。\n- 仅允许具有 `CAP_SYS_ADMIN` 能力的进程创建新的 cgroup 命名空间，确保安全性。\n\n### 命名空间复制逻辑\n- 在 `copy_cgroup_ns()` 中：\n  - 若未设置 `CLONE_NEWCGROUP`，则直接复用父进程的 cgroup 命名空间（引用计数加一）。\n  - 若设置 `CLONE_NEWCGROUP`，则创建新命名空间，并将当前任务的 `css_set` 作为新命名空间的根（`root_cset`）。\n  - 使用 `spin_lock_irq(&css_set_lock)` 安全地获取当前任务的 `css_set`，避免在持有 `cgroup_mutex` 的上下文中操作。\n\n### 命名空间安装与切换\n- `cgroupns_install()` 在 `setns()` 系统调用中被调用，用于将目标命名空间切换到当前进程。\n- 实现双重权限检查：要求调用者在其自身用户命名空间和目标 cgroup 命名空间的用户命名空间中均具备 `CAP_SYS_ADMIN`。\n\n### 生命周期管理\n- 通过 `refcount_set()` 和 `get_cgroup_ns()` / `put_cgroup_ns()` 实现引用计数。\n- `free_cgroup_ns()` 负责释放所有关联资源：`css_set`、用户命名空间、ucounts 计数及 inum（用于 `/proc` 中的命名空间标识）。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `cgroup-internal.h`：提供 cgroup 内部数据结构和辅助函数（如 `css_set`、`get_css_set()` 等）。\n- **内核模块依赖**：\n  - `<linux/nsproxy.h>`：提供 `nsproxy` 结构，用于管理进程的命名空间集合。\n  - `<linux/proc_ns.h>`：定义 `proc_ns_operations` 接口，用于 `/proc/[pid]/ns/` 下的命名空间文件操作。\n  - `<linux/sched/task.h>`：提供 `current` 和任务锁相关操作。\n  - `<linux/slab.h>`：内存分配接口（`kzalloc`/`kfree`）。\n  - `<linux/ucount.h>`（通过 `cgroup-internal.h` 间接包含）：用户资源计数机制。\n\n## 5. 使用场景\n\n- **容器运行时**：Docker、Podman、containerd 等容器引擎在创建容器时使用 `CLONE_NEWCGROUP` 创建新的 cgroup 命名空间，使容器内进程看到以容器 cgroup 为根的视图，提升隔离性和安全性。\n- **系统调用支持**：\n  - `clone()` / `unshare()`：通过 `CLONE_NEWCGROUP` 标志创建新 cgroup 命名空间。\n  - `setns()`：将进程加入现有 cgroup 命名空间。\n- **/proc 文件系统**：通过 `/proc/[pid]/ns/cgroup` 提供命名空间文件，支持命名空间的查看和操作（如 `nsenter` 工具）。\n- **资源隔离**：结合用户命名空间，实现多租户环境下对 cgroup 命名空间创建数量的限制，防止 DoS 攻击。",
      "similarity": 0.5632351040840149,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/namespace.c",
          "start_line": 1,
          "end_line": 16,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include \"cgroup-internal.h\"",
            "",
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "",
            "",
            "/* cgroup namespaces */",
            "",
            "static struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)",
            "{",
            "\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "该代码片段定义了一个静态函数`inc_cgroup_namespaces`，用于在用户命名空间中增加cgroup命名空间的引用计数。函数通过`current_euid()`获取当前有效UID，并调用`inc_ucount`更新对应类型的计数器（类型标识为`UCOUNT_CGROUP_NAMESPACES`）。由于缺乏上下文信息（如`UCOUNT_CGROUP_NAMESPACES`的定义及`inc_ucount`的具体实现），无法进一步确认其完整行为。",
          "similarity": 0.5560299158096313
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/namespace.c",
          "start_line": 17,
          "end_line": 51,
          "content": [
            "static void dec_cgroup_namespaces(struct ucounts *ucounts)",
            "{",
            "\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);",
            "}",
            "void free_cgroup_ns(struct cgroup_namespace *ns)",
            "{",
            "\tput_css_set(ns->root_cset);",
            "\tdec_cgroup_namespaces(ns->ucounts);",
            "\tput_user_ns(ns->user_ns);",
            "\tns_free_inum(&ns->ns);",
            "\tkfree(ns);",
            "}",
            "static int cgroupns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct nsproxy *nsproxy = nsset->nsproxy;",
            "\tstruct cgroup_namespace *cgroup_ns = to_cg_ns(ns);",
            "",
            "\tif (!ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN) ||",
            "\t    !ns_capable(cgroup_ns->user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Don't need to do anything if we are attaching to our own cgroupns. */",
            "\tif (cgroup_ns == nsproxy->cgroup_ns)",
            "\t\treturn 0;",
            "",
            "\tget_cgroup_ns(cgroup_ns);",
            "\tput_cgroup_ns(nsproxy->cgroup_ns);",
            "\tnsproxy->cgroup_ns = cgroup_ns;",
            "",
            "\treturn 0;",
            "}",
            "static void cgroupns_put(struct ns_common *ns)",
            "{",
            "\tput_cgroup_ns(to_cg_ns(ns));",
            "}"
          ],
          "function_name": "dec_cgroup_namespaces, free_cgroup_ns, cgroupns_install, cgroupns_put",
          "description": "该代码段实现cgroup命名空间的引用计数管理和生命周期控制。  \n`free_cgroup_ns`负责安全释放cgroup命名空间资源，通过递减引用计数、释放关联的css_set和user_ns等资源完成销毁；`cgroupns_install`用于安装新的cgroup命名空间到进程nsproxy，需具备SYS_ADMIN权限；其余函数辅助引用计数操作。  \n上下文不完整：代码中调用的`put_css_set`、`get_cgroup_ns`等函数未在当前片段中定义。",
          "similarity": 0.4999767243862152
        }
      ]
    }
  ]
}