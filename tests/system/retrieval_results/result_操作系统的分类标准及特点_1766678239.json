{
  "query": "操作系统的分类标准及特点",
  "timestamp": "2025-12-25 23:57:19",
  "retrieved_files": [
    {
      "source_file": "kernel/sysctl.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:32:56\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sysctl.c`\n\n---\n\n# sysctl.c 技术文档\n\n## 文件概述\n\n`sysctl.c` 是 Linux 内核中实现系统控制（sysctl）机制的核心文件，提供了通过 `/proc/sys` 接口动态读写内核运行时参数的能力。该文件实现了通用的 sysctl 框架，支持字符串、整数、长整型等多种数据类型的读写操作，并提供了严格的写入模式控制，确保系统参数的安全性和一致性。\n\n## 核心功能\n\n### 主要数据结构\n- `enum sysctl_writes_mode`: 定义 sysctl 写入模式的三种策略\n  - `SYSCTL_WRITES_LEGACY`: 传统模式，忽略文件位置\n  - `SYSCTL_WRITES_WARN`: 警告模式，非零位置写入时发出警告\n  - `SYSCTL_WRITES_STRICT`: 严格模式，强制要求位置为0且完整写入\n\n### 主要全局变量\n- `sysctl_vals[]`: 预定义的常用整数值常量数组（0, 1, 2, 3, 4, 100, 200, 1000, 3000, INT_MAX, 65535, -1）\n- `sysctl_long_vals[]`: 预定义的常用长整型值常量数组（0, 1, LONG_MAX）\n- `sysctl_writes_strict`: 当前 sysctl 写入模式，默认为严格模式\n- `sysctl_legacy_va_layout`: 控制虚拟地址布局的兼容性标志\n\n### 主要函数\n- `proc_dostring()`: 处理字符串类型 sysctl 参数的读写操作\n- `_proc_do_string()`: 字符串读写的底层实现函数\n- `proc_first_pos_non_zero_ignore()`: 检查文件位置是否为非零并根据模式处理\n- `warn_sysctl_write()`: 发出 sysctl 写入警告信息\n- `proc_skip_spaces()`: 跳过缓冲区中的空白字符\n- `proc_skip_char()`: 跳过缓冲区中的指定字符\n- `strtoul_lenient()`: 宽松的无符号长整型字符串解析函数（代码片段中未完整显示）\n\n## 关键实现\n\n### 写入模式控制\nsysctl 实现了三种写入模式来控制如何处理文件位置和多次写入：\n- **严格模式**（默认）: 要求写入必须从位置0开始，且一次写入必须包含完整值\n- **警告模式**: 允许非零位置写入但会发出警告\n- **传统模式**: 完全忽略文件位置，每次写入都覆盖整个值\n\n### 字符串处理机制\n`_proc_do_string()` 函数实现了智能的字符串读写逻辑：\n- **读取时**: 自动在字符串末尾添加换行符 `\\n`，支持分段读取\n- **写入时**: \n  - 严格模式下支持从指定位置继续写入（用于长字符串）\n  - 其他模式下总是从字符串开头覆盖写入\n  - 自动处理空字符和换行符作为字符串终止符\n\n### 安全性保障\n- 通过 `proc_first_pos_non_zero_ignore()` 函数确保数值类型参数的写入安全性\n- 使用 `maxlen` 参数防止缓冲区溢出\n- 自动截断超长字符串并确保 NULL 终止\n\n### 预定义常量优化\n通过导出 `sysctl_vals[]` 和 `sysctl_long_vals[]` 数组，避免在各个 sysctl 表项中重复定义常用数值，减少内存占用并提高一致性。\n\n## 依赖关系\n\n### 头文件依赖\n- **核心内核头文件**: `linux/module.h`, `linux/kernel.h`, `linux/init.h`\n- **内存管理**: `linux/mm.h`, `linux/slab.h`, `linux/swap.h`\n- **文件系统**: `linux/proc_fs.h`, `linux/fs.h`\n- **安全机制**: `linux/security.h`, `linux/capability.h`\n- **系统调用**: `linux/syscalls.h`, `linux/uaccess.h`\n- **架构相关**: `asm/processor.h` 及各架构特定头文件（X86、SPARC 等）\n\n### 配置依赖\n- `CONFIG_SYSCTL`: 主开关，控制 sysctl 功能是否启用\n- `CONFIG_PROC_SYSCTL`: 控制 `/proc/sys` 接口支持\n- `CONFIG_PERF_EVENTS`: 影响性能事件相关的 sysctl 参数\n- `CONFIG_RT_MUTEXES`: 实时互斥锁相关的 sysctl 支持\n- 架构特定配置: `HAVE_ARCH_PICK_MMAP_LAYOUT`, `CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT`\n\n### 模块交互\n- 与 proc 文件系统深度集成，提供 `/proc/sys` 虚拟文件接口\n- 为网络子系统、内存管理、调度器等内核子系统提供参数配置接口\n- 与安全模块（如 SELinux）协作进行权限检查\n\n## 使用场景\n\n### 内核参数动态配置\n- 系统管理员通过 `/proc/sys` 接口实时调整内核参数\n- 应用程序通过 sysctl 系统调用查询或修改内核行为\n- 启动脚本在系统初始化时设置关键内核参数\n\n### 子系统集成\n- **网络子系统**: 配置 TCP/IP 参数、网络缓冲区大小等\n- **内存管理**: 调整脏页回写策略、内存回收阈值等\n- **进程调度**: 设置调度策略参数、进程优先级范围等\n- **安全机制**: 配置 capability、用户命名空间等安全相关参数\n- **虚拟内存**: 控制 mmap 布局、huge page 行为等\n\n### 调试和监控\n- 开发者通过 sysctl 接口启用/禁用调试功能\n- 监控工具读取 sysctl 参数了解系统当前配置状态\n- 性能调优时动态调整内核参数以获得最佳性能\n\n### 兼容性支持\n- 通过 `sysctl_legacy_va_layout` 等参数维持向后兼容性\n- 支持传统应用程序对 sysctl 接口的使用模式\n- 提供平滑的迁移路径从传统模式到严格模式",
      "similarity": 0.5739696621894836,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/sysctl.c",
          "start_line": 453,
          "end_line": 603,
          "content": [
            "static int do_proc_douintvec_conv(unsigned long *lvalp,",
            "\t\t\t\t  unsigned int *valp,",
            "\t\t\t\t  int write, void *data)",
            "{",
            "\tif (write) {",
            "\t\tif (*lvalp > UINT_MAX)",
            "\t\t\treturn -EINVAL;",
            "\t\tWRITE_ONCE(*valp, *lvalp);",
            "\t} else {",
            "\t\tunsigned int val = READ_ONCE(*valp);",
            "\t\t*lvalp = (unsigned long)val;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,",
            "\t\t  int write, void *buffer,",
            "\t\t  size_t *lenp, loff_t *ppos,",
            "\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,",
            "\t\t\t      int write, void *data),",
            "\t\t  void *data)",
            "{",
            "\tint *i, vleft, first = 1, err = 0;",
            "\tsize_t left;",
            "\tchar *p;",
            "",
            "\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {",
            "\t\t*lenp = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ti = (int *) tbl_data;",
            "\tvleft = table->maxlen / sizeof(*i);",
            "\tleft = *lenp;",
            "",
            "\tif (!conv)",
            "\t\tconv = do_proc_dointvec_conv;",
            "",
            "\tif (write) {",
            "\t\tif (proc_first_pos_non_zero_ignore(ppos, table))",
            "\t\t\tgoto out;",
            "",
            "\t\tif (left > PAGE_SIZE - 1)",
            "\t\t\tleft = PAGE_SIZE - 1;",
            "\t\tp = buffer;",
            "\t}",
            "",
            "\tfor (; left && vleft--; i++, first=0) {",
            "\t\tunsigned long lval;",
            "\t\tbool neg;",
            "",
            "\t\tif (write) {",
            "\t\t\tproc_skip_spaces(&p, &left);",
            "",
            "\t\t\tif (!left)",
            "\t\t\t\tbreak;",
            "\t\t\terr = proc_get_long(&p, &left, &lval, &neg,",
            "\t\t\t\t\t     proc_wspace_sep,",
            "\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t\tif (conv(&neg, &lval, i, 1, data)) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tif (conv(&neg, &lval, i, 0, data)) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif (!first)",
            "\t\t\t\tproc_put_char(&buffer, &left, '\\t');",
            "\t\t\tproc_put_long(&buffer, &left, lval, neg);",
            "\t\t}",
            "\t}",
            "",
            "\tif (!write && !first && left && !err)",
            "\t\tproc_put_char(&buffer, &left, '\\n');",
            "\tif (write && !err && left)",
            "\t\tproc_skip_spaces(&p, &left);",
            "\tif (write && first)",
            "\t\treturn err ? : -EINVAL;",
            "\t*lenp -= left;",
            "out:",
            "\t*ppos += *lenp;",
            "\treturn err;",
            "}",
            "static int do_proc_dointvec(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos,",
            "\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,",
            "\t\t\t      int write, void *data),",
            "\t\t  void *data)",
            "{",
            "\treturn __do_proc_dointvec(table->data, table, write,",
            "\t\t\tbuffer, lenp, ppos, conv, data);",
            "}",
            "static int do_proc_douintvec_w(unsigned int *tbl_data,",
            "\t\t\t       struct ctl_table *table,",
            "\t\t\t       void *buffer,",
            "\t\t\t       size_t *lenp, loff_t *ppos,",
            "\t\t\t       int (*conv)(unsigned long *lvalp,",
            "\t\t\t\t\t   unsigned int *valp,",
            "\t\t\t\t\t   int write, void *data),",
            "\t\t\t       void *data)",
            "{",
            "\tunsigned long lval;",
            "\tint err = 0;",
            "\tsize_t left;",
            "\tbool neg;",
            "\tchar *p = buffer;",
            "",
            "\tleft = *lenp;",
            "",
            "\tif (proc_first_pos_non_zero_ignore(ppos, table))",
            "\t\tgoto bail_early;",
            "",
            "\tif (left > PAGE_SIZE - 1)",
            "\t\tleft = PAGE_SIZE - 1;",
            "",
            "\tproc_skip_spaces(&p, &left);",
            "\tif (!left) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\terr = proc_get_long(&p, &left, &lval, &neg,",
            "\t\t\t     proc_wspace_sep,",
            "\t\t\t     sizeof(proc_wspace_sep), NULL);",
            "\tif (err || neg) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\tif (conv(&lval, tbl_data, 1, data)) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\tif (!err && left)",
            "\t\tproc_skip_spaces(&p, &left);",
            "",
            "out_free:",
            "\tif (err)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "",
            "\t/* This is in keeping with old __do_proc_dointvec() */",
            "bail_early:",
            "\t*ppos += *lenp;",
            "\treturn err;",
            "}"
          ],
          "function_name": "do_proc_douintvec_conv, __do_proc_dointvec, do_proc_dointvec, do_proc_douintvec_w",
          "description": "实现多元素整数向量的读写处理逻辑，包含严格写入模式验证、数值解析与转换流程，用于处理proc文件系统中数组形式的sysctl参数操作。",
          "similarity": 0.5192407965660095
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/sysctl.c",
          "start_line": 610,
          "end_line": 712,
          "content": [
            "static int do_proc_douintvec_r(unsigned int *tbl_data, void *buffer,",
            "\t\t\t       size_t *lenp, loff_t *ppos,",
            "\t\t\t       int (*conv)(unsigned long *lvalp,",
            "\t\t\t\t\t   unsigned int *valp,",
            "\t\t\t\t\t   int write, void *data),",
            "\t\t\t       void *data)",
            "{",
            "\tunsigned long lval;",
            "\tint err = 0;",
            "\tsize_t left;",
            "",
            "\tleft = *lenp;",
            "",
            "\tif (conv(&lval, tbl_data, 0, data)) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tproc_put_long(&buffer, &left, lval, false);",
            "\tif (!left)",
            "\t\tgoto out;",
            "",
            "\tproc_put_char(&buffer, &left, '\\n');",
            "",
            "out:",
            "\t*lenp -= left;",
            "\t*ppos += *lenp;",
            "",
            "\treturn err;",
            "}",
            "static int __do_proc_douintvec(void *tbl_data, struct ctl_table *table,",
            "\t\t\t       int write, void *buffer,",
            "\t\t\t       size_t *lenp, loff_t *ppos,",
            "\t\t\t       int (*conv)(unsigned long *lvalp,",
            "\t\t\t\t\t   unsigned int *valp,",
            "\t\t\t\t\t   int write, void *data),",
            "\t\t\t       void *data)",
            "{",
            "\tunsigned int *i, vleft;",
            "",
            "\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {",
            "\t\t*lenp = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ti = (unsigned int *) tbl_data;",
            "\tvleft = table->maxlen / sizeof(*i);",
            "",
            "\t/*",
            "\t * Arrays are not supported, keep this simple. *Do not* add",
            "\t * support for them.",
            "\t */",
            "\tif (vleft != 1) {",
            "\t\t*lenp = 0;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (!conv)",
            "\t\tconv = do_proc_douintvec_conv;",
            "",
            "\tif (write)",
            "\t\treturn do_proc_douintvec_w(i, table, buffer, lenp, ppos,",
            "\t\t\t\t\t   conv, data);",
            "\treturn do_proc_douintvec_r(i, buffer, lenp, ppos, conv, data);",
            "}",
            "int do_proc_douintvec(struct ctl_table *table, int write,",
            "\t\t      void *buffer, size_t *lenp, loff_t *ppos,",
            "\t\t      int (*conv)(unsigned long *lvalp,",
            "\t\t\t\t  unsigned int *valp,",
            "\t\t\t\t  int write, void *data),",
            "\t\t      void *data)",
            "{",
            "\treturn __do_proc_douintvec(table->data, table, write,",
            "\t\t\t\t   buffer, lenp, ppos, conv, data);",
            "}",
            "int proc_dobool(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct ctl_table tmp;",
            "\tbool *data = table->data;",
            "\tint res, val;",
            "",
            "\t/* Do not support arrays yet. */",
            "\tif (table->maxlen != sizeof(bool))",
            "\t\treturn -EINVAL;",
            "",
            "\ttmp = *table;",
            "\ttmp.maxlen = sizeof(val);",
            "\ttmp.data = &val;",
            "",
            "\tval = READ_ONCE(*data);",
            "\tres = proc_dointvec(&tmp, write, buffer, lenp, ppos);",
            "\tif (res)",
            "\t\treturn res;",
            "\tif (write)",
            "\t\tWRITE_ONCE(*data, val);",
            "\treturn 0;",
            "}",
            "int proc_dointvec(struct ctl_table *table, int write, void *buffer,",
            "\t\t  size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn do_proc_dointvec(table, write, buffer, lenp, ppos, NULL, NULL);",
            "}"
          ],
          "function_name": "do_proc_douintvec_r, __do_proc_douintvec, do_proc_douintvec, proc_dobool, proc_dointvec",
          "description": "扩展整数向量处理功能，包含只读向量处理和布尔类型专用处理函数，用于支持不同数据类型的sysctl参数访问，确保类型安全性和操作一致性。",
          "similarity": 0.5167659521102905
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sysctl.c",
          "start_line": 1,
          "end_line": 144,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * sysctl.c: General linux system control interface",
            " *",
            " * Begun 24 March 1995, Stephen Tweedie",
            " * Added /proc support, Dec 1995",
            " * Added bdflush entry and intvec min/max checking, 2/23/96, Tom Dyas.",
            " * Added hooks for /proc/sys/net (minor, minor patch), 96/4/1, Mike Shaver.",
            " * Added kernel/java-{interpreter,appletviewer}, 96/5/10, Mike Shaver.",
            " * Dynamic registration fixes, Stephen Tweedie.",
            " * Added kswapd-interval, ctrl-alt-del, printk stuff, 1/8/97, Chris Horn.",
            " * Made sysctl support optional via CONFIG_SYSCTL, 1/10/97, Chris",
            " *  Horn.",
            " * Added proc_doulongvec_ms_jiffies_minmax, 09/08/99, Carlos H. Bauer.",
            " * Added proc_doulongvec_minmax, 09/08/99, Carlos H. Bauer.",
            " * Changed linked lists to use list.h instead of lists.h, 02/24/00, Bill",
            " *  Wendling.",
            " * The list_for_each() macro wasn't appropriate for the sysctl loop.",
            " *  Removed it and replaced it with older style, 03/23/00, Bill Wendling",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/signal.h>",
            "#include <linux/panic.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/filter.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kobject.h>",
            "#include <linux/net.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/highuid.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/initrd.h>",
            "#include <linux/key.h>",
            "#include <linux/times.h>",
            "#include <linux/limits.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/acpi.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/oom.h>",
            "#include <linux/kmod.h>",
            "#include <linux/capability.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/mount.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/pid.h>",
            "",
            "#include \"../lib/kstrtox.h\"",
            "",
            "#include <linux/uaccess.h>",
            "#include <asm/processor.h>",
            "",
            "#ifdef CONFIG_X86",
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/io.h>",
            "#endif",
            "#ifdef CONFIG_SPARC",
            "#include <asm/setup.h>",
            "#endif",
            "#ifdef CONFIG_RT_MUTEXES",
            "#include <linux/rtmutex.h>",
            "#endif",
            "",
            "/* shared constants to be used in various sysctls */",
            "const int sysctl_vals[] = { 0, 1, 2, 3, 4, 100, 200, 1000, 3000, INT_MAX, 65535, -1 };",
            "EXPORT_SYMBOL(sysctl_vals);",
            "",
            "const unsigned long sysctl_long_vals[] = { 0, 1, LONG_MAX };",
            "EXPORT_SYMBOL_GPL(sysctl_long_vals);",
            "",
            "#if defined(CONFIG_SYSCTL)",
            "",
            "/* Constants used for minimum and maximum */",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "static const int six_hundred_forty_kb = 640 * 1024;",
            "#endif",
            "",
            "",
            "static const int ngroups_max = NGROUPS_MAX;",
            "static const int cap_last_cap = CAP_LAST_CAP;",
            "",
            "#ifdef CONFIG_PROC_SYSCTL",
            "",
            "/**",
            " * enum sysctl_writes_mode - supported sysctl write modes",
            " *",
            " * @SYSCTL_WRITES_LEGACY: each write syscall must fully contain the sysctl value",
            " *\tto be written, and multiple writes on the same sysctl file descriptor",
            " *\twill rewrite the sysctl value, regardless of file position. No warning",
            " *\tis issued when the initial position is not 0.",
            " * @SYSCTL_WRITES_WARN: same as above but warn when the initial file position is",
            " *\tnot 0.",
            " * @SYSCTL_WRITES_STRICT: writes to numeric sysctl entries must always be at",
            " *\tfile position 0 and the value must be fully contained in the buffer",
            " *\tsent to the write syscall. If dealing with strings respect the file",
            " *\tposition, but restrict this to the max length of the buffer, anything",
            " *\tpassed the max length will be ignored. Multiple writes will append",
            " *\tto the buffer.",
            " *",
            " * These write modes control how current file position affects the behavior of",
            " * updating sysctl values through the proc interface on each write.",
            " */",
            "enum sysctl_writes_mode {",
            "\tSYSCTL_WRITES_LEGACY\t\t= -1,",
            "\tSYSCTL_WRITES_WARN\t\t= 0,",
            "\tSYSCTL_WRITES_STRICT\t\t= 1,",
            "};",
            "",
            "static enum sysctl_writes_mode sysctl_writes_strict = SYSCTL_WRITES_STRICT;",
            "#endif /* CONFIG_PROC_SYSCTL */",
            "",
            "#if defined(HAVE_ARCH_PICK_MMAP_LAYOUT) || \\",
            "    defined(CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT)",
            "int sysctl_legacy_va_layout;",
            "#endif",
            "",
            "#endif /* CONFIG_SYSCTL */",
            "",
            "/*",
            " * /proc/sys support",
            " */",
            "",
            "#ifdef CONFIG_PROC_SYSCTL",
            ""
          ],
          "function_name": null,
          "description": "声明sysctl通用系统控制接口的实现，包含头文件和公共常量定义，用于支持/proc/sys虚拟文件系统中的参数控制，核心功能为构建sysctl框架基础结构。",
          "similarity": 0.5069886445999146
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/sysctl.c",
          "start_line": 1089,
          "end_line": 1203,
          "content": [
            "static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table,",
            "\t\tint write, void *buffer, size_t *lenp, loff_t *ppos,",
            "\t\tunsigned long convmul, unsigned long convdiv)",
            "{",
            "\tunsigned long *i, *min, *max;",
            "\tint vleft, first = 1, err = 0;",
            "\tsize_t left;",
            "\tchar *p;",
            "",
            "\tif (!data || !table->maxlen || !*lenp || (*ppos && !write)) {",
            "\t\t*lenp = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ti = data;",
            "\tmin = table->extra1;",
            "\tmax = table->extra2;",
            "\tvleft = table->maxlen / sizeof(unsigned long);",
            "\tleft = *lenp;",
            "",
            "\tif (write) {",
            "\t\tif (proc_first_pos_non_zero_ignore(ppos, table))",
            "\t\t\tgoto out;",
            "",
            "\t\tif (left > PAGE_SIZE - 1)",
            "\t\t\tleft = PAGE_SIZE - 1;",
            "\t\tp = buffer;",
            "\t}",
            "",
            "\tfor (; left && vleft--; i++, first = 0) {",
            "\t\tunsigned long val;",
            "",
            "\t\tif (write) {",
            "\t\t\tbool neg;",
            "",
            "\t\t\tproc_skip_spaces(&p, &left);",
            "\t\t\tif (!left)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\terr = proc_get_long(&p, &left, &val, &neg,",
            "\t\t\t\t\t     proc_wspace_sep,",
            "\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);",
            "\t\t\tif (err || neg) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\tval = convmul * val / convdiv;",
            "\t\t\tif ((min && val < *min) || (max && val > *max)) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tWRITE_ONCE(*i, val);",
            "\t\t} else {",
            "\t\t\tval = convdiv * READ_ONCE(*i) / convmul;",
            "\t\t\tif (!first)",
            "\t\t\t\tproc_put_char(&buffer, &left, '\\t');",
            "\t\t\tproc_put_long(&buffer, &left, val, false);",
            "\t\t}",
            "\t}",
            "",
            "\tif (!write && !first && left && !err)",
            "\t\tproc_put_char(&buffer, &left, '\\n');",
            "\tif (write && !err)",
            "\t\tproc_skip_spaces(&p, &left);",
            "\tif (write && first)",
            "\t\treturn err ? : -EINVAL;",
            "\t*lenp -= left;",
            "out:",
            "\t*ppos += *lenp;",
            "\treturn err;",
            "}",
            "static int do_proc_doulongvec_minmax(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos, unsigned long convmul,",
            "\t\tunsigned long convdiv)",
            "{",
            "\treturn __do_proc_doulongvec_minmax(table->data, table, write,",
            "\t\t\tbuffer, lenp, ppos, convmul, convdiv);",
            "}",
            "int proc_doulongvec_minmax(struct ctl_table *table, int write,",
            "\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "    return do_proc_doulongvec_minmax(table, write, buffer, lenp, ppos, 1l, 1l);",
            "}",
            "int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,",
            "\t\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "    return do_proc_doulongvec_minmax(table, write, buffer,",
            "\t\t\t\t     lenp, ppos, HZ, 1000l);",
            "}",
            "static int do_proc_dointvec_jiffies_conv(bool *negp, unsigned long *lvalp,",
            "\t\t\t\t\t int *valp,",
            "\t\t\t\t\t int write, void *data)",
            "{",
            "\tif (write) {",
            "\t\tif (*lvalp > INT_MAX / HZ)",
            "\t\t\treturn 1;",
            "\t\tif (*negp)",
            "\t\t\tWRITE_ONCE(*valp, -*lvalp * HZ);",
            "\t\telse",
            "\t\t\tWRITE_ONCE(*valp, *lvalp * HZ);",
            "\t} else {",
            "\t\tint val = READ_ONCE(*valp);",
            "\t\tunsigned long lval;",
            "\t\tif (val < 0) {",
            "\t\t\t*negp = true;",
            "\t\t\tlval = -(unsigned long)val;",
            "\t\t} else {",
            "\t\t\t*negp = false;",
            "\t\t\tlval = (unsigned long)val;",
            "\t\t}",
            "\t\t*lvalp = lval / HZ;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__do_proc_doulongvec_minmax, do_proc_doulongvec_minmax, proc_doulongvec_minmax, proc_doulongvec_ms_jiffies_minmax, do_proc_dointvec_jiffies_conv",
          "description": "该代码实现了一组用于处理 `/proc/sys` 系统控制表项的通用函数，核心功能是管理 `unsigned long` 类型向量的读写操作，并支持值范围校验及单位转换。  \n`__do_proc_doulongvec_minmax` 是核心函数，通过 `min`/`max` 指针限制数值范围，并利用 `convmul`/`convdiv` 进行单位转换；`proc_doulongvec_minmax` 和 `proc_doulongvec_ms_jiffies_minmax` 分别封装了默认转换逻辑（1:1 和 ms:jiffies）。  \n`do_proc_dointvec_jiffies_conv` 处理带符号整数与 jiffies 的双向转换，但因上下文缺失，无法确认其完整依赖关系。",
          "similarity": 0.49141114950180054
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/sysctl.c",
          "start_line": 2305,
          "end_line": 2311,
          "content": [
            "int __init sysctl_init_bases(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kern_table);",
            "\tregister_sysctl_init(\"vm\", vm_table);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "sysctl_init_bases",
          "description": "该函数在内核启动时注册\"kern_table\"和\"vm_table\"控制表到sysctl层次结构，建立/proc/sys/kernel和/proc/sys/vm目录的基础配置项，为后续动态调整内核参数提供基础设施。",
          "similarity": 0.4896976053714752
        }
      ]
    },
    {
      "source_file": "mm/mempolicy.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:44:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mempolicy.c`\n\n---\n\n# mempolicy.c 技术文档\n\n## 1. 文件概述\n\n`mempolicy.c` 实现了 Linux 内核中的 NUMA（Non-Uniform Memory Access）内存策略机制，允许用户通过系统调用为进程或虚拟内存区域（VMA）指定内存分配偏好。该机制支持多种内存分配策略，包括本地优先、绑定节点、轮询交错和基于权重的交错分配等，以优化多节点 NUMA 系统上的内存访问性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct mempolicy`：表示内存策略的核心结构，包含策略模式（如 MPOL_INTERLEAVE、MPOL_BIND、MPOL_PREFERRED 等）、节点掩码（nodemask）和引用计数。\n- `struct weighted_interleave_state`：用于实现加权交错分配策略，包含每个节点的权重表（iw_table）和自动模式标志。\n- `default_policy`：全局默认内存策略，初始为 MPOL_LOCAL（本地节点优先）。\n- `preferred_node_policy[MAX_NUMNODES]`：为每个节点预定义的首选策略数组。\n\n### 主要函数与接口\n- `get_il_weight(int node)`：获取指定节点在加权交错策略中的权重。\n- `reduce_interleave_weights(unsigned int *bw, u8 *new_iw)`：将带宽值转换为归一化的交错权重。\n- `mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)`：根据节点性能坐标（读/写带宽）动态更新加权交错策略。\n- 多个辅助函数用于策略创建、复制、合并、验证及与 VMA 和进程上下文的集成。\n\n### 全局变量\n- `policy_cache` / `sn_cache`：用于高效分配 mempolicy 和相关子结构的 slab 缓存。\n- `policy_zone`：标识受策略控制的最高内存区域类型（zone_type），低区域（如 GFP_DMA）不应用策略。\n- `wi_state`：RCU 保护的加权交错状态指针。\n- `node_bw_table`：存储各节点带宽信息，用于动态权重计算。\n- `weightiness`：权重归一化常量（值为 32），平衡权重精度与分配公平性。\n\n## 3. 关键实现\n\n### 策略优先级与作用域\n- **VMA 策略优先于进程策略**：页错误处理时，若 VMA 有策略则使用 VMA 策略，否则回退到当前进程的策略。\n- **中断上下文忽略策略**：所有中断相关的内存分配始终尝试在本地 CPU 节点分配。\n- **策略不跨 swap 保留**：进程策略在页面换出/换入时不被保留。\n\n### 加权交错分配（Weighted Interleave）\n- 基于各 NUMA 节点的读/写带宽动态计算分配权重。\n- 使用 `weightiness=32` 对带宽进行缩放，并通过 GCD（最大公约数）约简权重以减少分配周期长度。\n- 权重状态通过 RCU 机制安全更新，读路径无锁，写路径由 `wi_state_lock` 互斥锁保护。\n\n### 策略类型详解\n- **interleave**：按偏移量（VMA）或进程计数器（进程）在节点集上轮询分配。\n- **weighted interleave**：按节点权重比例分配（如权重 [2,1] 表示节点0:节点1 = 2:1）。\n- **bind**：严格限制在指定节点集分配，无回退（当前实现按节点顺序分配，非最优）。\n- **preferred / preferred many**：优先在指定单个/多个节点分配，失败后回退到默认策略。\n- **default / local**：优先本地节点分配，VMA 中则继承进程策略。\n\n### 内存区域限制\n- 仅对 **最高 zone 层级**（如 NORMAL 或 MOVABLE）应用策略，GFP_DMA、HIGHMEM 等低层级分配忽略策略。\n\n### 特殊共享内存处理\n- **shmem/tmpfs**：策略在所有映射进程间共享，即使无活跃映射也持久保存。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `<linux/mm.h>`、`<linux/vm_area_struct.h>`、`<linux/page-flags.h>` 等进行页分配、VMA 操作和页表遍历。\n- **NUMA 感知调度**：与 `<linux/sched/numa_balancing.h>` 协同，支持自动 NUMA 迁移。\n- **CPUSET 子系统**：通过 `<linux/cpuset.h>` 集成节点可用性约束。\n- **Slab 分配器**：使用 kmem_cache 管理 mempolicy 对象生命周期。\n- **RCU 机制**：用于加权交错状态的无锁读取。\n- **系统调用接口**：通过 `sys_mbind()`、`sys_set_mempolicy()` 等提供用户空间配置入口。\n- **安全模块**：调用 LSM hooks（`security_task_movememory()`）进行权限检查。\n\n## 5. 使用场景\n\n- **高性能计算（HPC）应用**：通过 `mbind()` 将关键数据结构绑定到特定 NUMA 节点，减少远程内存访问延迟。\n- **数据库系统**：使用交错策略均衡多节点内存带宽，提升吞吐量。\n- **虚拟化环境**：VMM 可为不同虚拟机设置独立内存策略，隔离资源并优化性能。\n- **自动 NUMA 优化**：内核 NUMA balancing 机制结合默认策略，自动迁移热点页面至访问 CPU 所在节点。\n- **实时系统**：通过 `MPOL_BIND` 严格限制内存位置，确保确定性访问延迟。\n- **大页（HugeTLB）分配**：策略同样适用于透明大页和显式 HugeTLB 页面分配。",
      "similarity": 0.5650296211242676,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "mm/mempolicy.c",
          "start_line": 484,
          "end_line": 639,
          "content": [
            "static void mpol_rebind_preferred(struct mempolicy *pol,",
            "\t\t\t\t\t\tconst nodemask_t *nodes)",
            "{",
            "\tpol->w.cpuset_mems_allowed = *nodes;",
            "}",
            "static void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)",
            "{",
            "\tif (!pol || pol->mode == MPOL_LOCAL)",
            "\t\treturn;",
            "\tif (!mpol_store_user_nodemask(pol) &&",
            "\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))",
            "\t\treturn;",
            "",
            "\tmpol_ops[pol->mode].rebind(pol, newmask);",
            "}",
            "void mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new)",
            "{",
            "\tmpol_rebind_policy(tsk->mempolicy, new);",
            "}",
            "void mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)",
            "{",
            "\tstruct vm_area_struct *vma;",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\tmmap_write_lock(mm);",
            "\tfor_each_vma(vmi, vma) {",
            "\t\tvma_start_write(vma);",
            "\t\tmpol_rebind_policy(vma->vm_policy, new);",
            "\t}",
            "\tmmap_write_unlock(mm);",
            "}",
            "static bool strictly_unmovable(unsigned long flags)",
            "{",
            "\t/*",
            "\t * STRICT without MOVE flags lets do_mbind() fail immediately with -EIO",
            "\t * if any misplaced page is found.",
            "\t */",
            "\treturn (flags & (MPOL_MF_STRICT | MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) ==",
            "\t\t\t MPOL_MF_STRICT;",
            "}",
            "static inline bool queue_folio_required(struct folio *folio,",
            "\t\t\t\t\tstruct queue_pages *qp)",
            "{",
            "\tint nid = folio_nid(folio);",
            "\tunsigned long flags = qp->flags;",
            "",
            "\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);",
            "}",
            "static void queue_folios_pmd(pmd_t *pmd, struct mm_walk *walk)",
            "{",
            "\tstruct folio *folio;",
            "\tstruct queue_pages *qp = walk->private;",
            "",
            "\tif (unlikely(is_pmd_migration_entry(*pmd))) {",
            "\t\tqp->nr_failed++;",
            "\t\treturn;",
            "\t}",
            "\tfolio = pmd_folio(*pmd);",
            "\tif (is_huge_zero_folio(folio)) {",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t\treturn;",
            "\t}",
            "\tif (!queue_folio_required(folio, qp))",
            "\t\treturn;",
            "\tif (!(qp->flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) ||",
            "\t    !vma_migratable(walk->vma) ||",
            "\t    !migrate_folio_add(folio, qp->pagelist, qp->flags))",
            "\t\tqp->nr_failed++;",
            "}",
            "static int queue_folios_pte_range(pmd_t *pmd, unsigned long addr,",
            "\t\t\tunsigned long end, struct mm_walk *walk)",
            "{",
            "\tconst fpb_t fpb_flags = FPB_IGNORE_DIRTY | FPB_IGNORE_SOFT_DIRTY;",
            "\tstruct vm_area_struct *vma = walk->vma;",
            "\tstruct folio *folio;",
            "\tstruct queue_pages *qp = walk->private;",
            "\tunsigned long flags = qp->flags;",
            "\tpte_t *pte, *mapped_pte;",
            "\tpte_t ptent;",
            "\tspinlock_t *ptl;",
            "\tint max_nr, nr;",
            "",
            "\tptl = pmd_trans_huge_lock(pmd, vma);",
            "\tif (ptl) {",
            "\t\tqueue_folios_pmd(pmd, walk);",
            "\t\tspin_unlock(ptl);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmapped_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);",
            "\tif (!pte) {",
            "\t\twalk->action = ACTION_AGAIN;",
            "\t\treturn 0;",
            "\t}",
            "\tfor (; addr != end; pte += nr, addr += nr * PAGE_SIZE) {",
            "\t\tmax_nr = (end - addr) >> PAGE_SHIFT;",
            "\t\tnr = 1;",
            "\t\tptent = ptep_get(pte);",
            "\t\tif (pte_none(ptent))",
            "\t\t\tcontinue;",
            "\t\tif (!pte_present(ptent)) {",
            "\t\t\tif (is_migration_entry(pte_to_swp_entry(ptent)))",
            "\t\t\t\tqp->nr_failed++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tfolio = vm_normal_folio(vma, addr, ptent);",
            "\t\tif (!folio || folio_is_zone_device(folio))",
            "\t\t\tcontinue;",
            "\t\tif (folio_test_large(folio) && max_nr != 1)",
            "\t\t\tnr = folio_pte_batch(folio, addr, pte, ptent,",
            "\t\t\t\t\t     max_nr, fpb_flags,",
            "\t\t\t\t\t     NULL, NULL, NULL);",
            "\t\t/*",
            "\t\t * vm_normal_folio() filters out zero pages, but there might",
            "\t\t * still be reserved folios to skip, perhaps in a VDSO.",
            "\t\t */",
            "\t\tif (folio_test_reserved(folio))",
            "\t\t\tcontinue;",
            "\t\tif (!queue_folio_required(folio, qp))",
            "\t\t\tcontinue;",
            "\t\tif (folio_test_large(folio)) {",
            "\t\t\t/*",
            "\t\t\t * A large folio can only be isolated from LRU once,",
            "\t\t\t * but may be mapped by many PTEs (and Copy-On-Write may",
            "\t\t\t * intersperse PTEs of other, order 0, folios).  This is",
            "\t\t\t * a common case, so don't mistake it for failure (but",
            "\t\t\t * there can be other cases of multi-mapped pages which",
            "\t\t\t * this quick check does not help to filter out - and a",
            "\t\t\t * search of the pagelist might grow to be prohibitive).",
            "\t\t\t *",
            "\t\t\t * migrate_pages(&pagelist) returns nr_failed folios, so",
            "\t\t\t * check \"large\" now so that queue_pages_range() returns",
            "\t\t\t * a comparable nr_failed folios.  This does imply that",
            "\t\t\t * if folio could not be isolated for some racy reason",
            "\t\t\t * at its first PTE, later PTEs will not give it another",
            "\t\t\t * chance of isolation; but keeps the accounting simple.",
            "\t\t\t */",
            "\t\t\tif (folio == qp->large)",
            "\t\t\t\tcontinue;",
            "\t\t\tqp->large = folio;",
            "\t\t}",
            "\t\tif (!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) ||",
            "\t\t    !vma_migratable(vma) ||",
            "\t\t    !migrate_folio_add(folio, qp->pagelist, flags)) {",
            "\t\t\tqp->nr_failed += nr;",
            "\t\t\tif (strictly_unmovable(flags))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tpte_unmap_unlock(mapped_pte, ptl);",
            "\tcond_resched();",
            "out:",
            "\tif (qp->nr_failed && strictly_unmovable(flags))",
            "\t\treturn -EIO;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "mpol_rebind_preferred, mpol_rebind_policy, mpol_rebind_task, mpol_rebind_mm, strictly_unmovable, queue_folio_required, queue_folios_pmd, queue_folios_pte_range",
          "description": "处理页表项遍历与迁移操作，包含页帧队列检测、迁移标志验证及大页迁移逻辑，确保内存分配符合NUMA策略要求。",
          "similarity": 0.5331342220306396
        },
        {
          "chunk_id": 10,
          "file_path": "mm/mempolicy.c",
          "start_line": 1735,
          "end_line": 1838,
          "content": [
            "static long kernel_set_mempolicy(int mode, const unsigned long __user *nmask,",
            "\t\t\t\t unsigned long maxnode)",
            "{",
            "\tunsigned short mode_flags;",
            "\tnodemask_t nodes;",
            "\tint lmode = mode;",
            "\tint err;",
            "",
            "\terr = sanitize_mpol_flags(&lmode, &mode_flags);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = get_nodes(&nodes, nmask, maxnode);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn do_set_mempolicy(lmode, mode_flags, &nodes);",
            "}",
            "static int kernel_migrate_pages(pid_t pid, unsigned long maxnode,",
            "\t\t\t\tconst unsigned long __user *old_nodes,",
            "\t\t\t\tconst unsigned long __user *new_nodes)",
            "{",
            "\tstruct mm_struct *mm = NULL;",
            "\tstruct task_struct *task;",
            "\tnodemask_t task_nodes;",
            "\tint err;",
            "\tnodemask_t *old;",
            "\tnodemask_t *new;",
            "\tNODEMASK_SCRATCH(scratch);",
            "",
            "\tif (!scratch)",
            "\t\treturn -ENOMEM;",
            "",
            "\told = &scratch->mask1;",
            "\tnew = &scratch->mask2;",
            "",
            "\terr = get_nodes(old, old_nodes, maxnode);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\terr = get_nodes(new, new_nodes, maxnode);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\t/* Find the mm_struct */",
            "\trcu_read_lock();",
            "\ttask = pid ? find_task_by_vpid(pid) : current;",
            "\tif (!task) {",
            "\t\trcu_read_unlock();",
            "\t\terr = -ESRCH;",
            "\t\tgoto out;",
            "\t}",
            "\tget_task_struct(task);",
            "",
            "\terr = -EINVAL;",
            "",
            "\t/*",
            "\t * Check if this process has the right to modify the specified process.",
            "\t * Use the regular \"ptrace_may_access()\" checks.",
            "\t */",
            "\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\trcu_read_unlock();",
            "\t\terr = -EPERM;",
            "\t\tgoto out_put;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\ttask_nodes = cpuset_mems_allowed(task);",
            "\t/* Is the user allowed to access the target nodes? */",
            "\tif (!nodes_subset(*new, task_nodes) && !capable(CAP_SYS_NICE)) {",
            "\t\terr = -EPERM;",
            "\t\tgoto out_put;",
            "\t}",
            "",
            "\ttask_nodes = cpuset_mems_allowed(current);",
            "\tnodes_and(*new, *new, task_nodes);",
            "\tif (nodes_empty(*new))",
            "\t\tgoto out_put;",
            "",
            "\terr = security_task_movememory(task);",
            "\tif (err)",
            "\t\tgoto out_put;",
            "",
            "\tmm = get_task_mm(task);",
            "\tput_task_struct(task);",
            "",
            "\tif (!mm) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terr = do_migrate_pages(mm, old, new,",
            "\t\tcapable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);",
            "",
            "\tmmput(mm);",
            "out:",
            "\tNODEMASK_SCRATCH_FREE(scratch);",
            "",
            "\treturn err;",
            "",
            "out_put:",
            "\tput_task_struct(task);",
            "\tgoto out;",
            "}"
          ],
          "function_name": "kernel_set_mempolicy, kernel_migrate_pages",
          "description": "kernel_set_mempolicy 设置进程的内存放置策略，通过sanitize_mpol_flags验证模式标志并调用do_set_mempolicy应用策略；kernel_migrate_pages 实现页面迁移，检查目标进程权限，限制迁移节点范围，并调用do_migrate_pages进行实际迁移操作。",
          "similarity": 0.5217626094818115
        },
        {
          "chunk_id": 11,
          "file_path": "mm/mempolicy.c",
          "start_line": 1855,
          "end_line": 1971,
          "content": [
            "static int kernel_get_mempolicy(int __user *policy,",
            "\t\t\t\tunsigned long __user *nmask,",
            "\t\t\t\tunsigned long maxnode,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long flags)",
            "{",
            "\tint err;",
            "\tint pval;",
            "\tnodemask_t nodes;",
            "",
            "\tif (nmask != NULL && maxnode < nr_node_ids)",
            "\t\treturn -EINVAL;",
            "",
            "\taddr = untagged_addr(addr);",
            "",
            "\terr = do_get_mempolicy(&pval, &nodes, addr, flags);",
            "",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (policy && put_user(pval, policy))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (nmask)",
            "\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);",
            "",
            "\treturn err;",
            "}",
            "bool vma_migratable(struct vm_area_struct *vma)",
            "{",
            "\tif (vma->vm_flags & (VM_IO | VM_PFNMAP))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * DAX device mappings require predictable access latency, so avoid",
            "\t * incurring periodic faults.",
            "\t */",
            "\tif (vma_is_dax(vma))",
            "\t\treturn false;",
            "",
            "\tif (is_vm_hugetlb_page(vma) &&",
            "\t\t!hugepage_migration_supported(hstate_vma(vma)))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Migration allocates pages in the highest zone. If we cannot",
            "\t * do so then migration (at least from node to node) is not",
            "\t * possible.",
            "\t */",
            "\tif (vma->vm_file &&",
            "\t\tgfp_zone(mapping_gfp_mask(vma->vm_file->f_mapping))",
            "\t\t\t< policy_zone)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "bool vma_policy_mof(struct vm_area_struct *vma)",
            "{",
            "\tstruct mempolicy *pol;",
            "",
            "\tif (vma->vm_ops && vma->vm_ops->get_policy) {",
            "\t\tbool ret = false;",
            "\t\tpgoff_t ilx;\t\t/* ignored here */",
            "",
            "\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start, &ilx);",
            "\t\tif (pol && (pol->flags & MPOL_F_MOF))",
            "\t\t\tret = true;",
            "\t\tmpol_cond_put(pol);",
            "",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tpol = vma->vm_policy;",
            "\tif (!pol)",
            "\t\tpol = get_task_policy(current);",
            "",
            "\treturn pol->flags & MPOL_F_MOF;",
            "}",
            "bool apply_policy_zone(struct mempolicy *policy, enum zone_type zone)",
            "{",
            "\tenum zone_type dynamic_policy_zone = policy_zone;",
            "",
            "\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);",
            "",
            "\t/*",
            "\t * if policy->nodes has movable memory only,",
            "\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.",
            "\t *",
            "\t * policy->nodes is intersect with node_states[N_MEMORY].",
            "\t * so if the following test fails, it implies",
            "\t * policy->nodes has movable memory only.",
            "\t */",
            "\tif (!nodes_intersects(policy->nodes, node_states[N_HIGH_MEMORY]))",
            "\t\tdynamic_policy_zone = ZONE_MOVABLE;",
            "",
            "\treturn zone >= dynamic_policy_zone;",
            "}",
            "static unsigned int weighted_interleave_nodes(struct mempolicy *policy)",
            "{",
            "\tunsigned int node;",
            "\tunsigned int cpuset_mems_cookie;",
            "",
            "retry:",
            "\t/* to prevent miscount use tsk->mems_allowed_seq to detect rebind */",
            "\tcpuset_mems_cookie = read_mems_allowed_begin();",
            "\tnode = current->il_prev;",
            "\tif (!current->il_weight || !node_isset(node, policy->nodes)) {",
            "\t\tnode = next_node_in(node, policy->nodes);",
            "\t\tif (read_mems_allowed_retry(cpuset_mems_cookie))",
            "\t\t\tgoto retry;",
            "\t\tif (node == MAX_NUMNODES)",
            "\t\t\treturn node;",
            "\t\tcurrent->il_prev = node;",
            "\t\tcurrent->il_weight = get_il_weight(node);",
            "\t}",
            "\tcurrent->il_weight--;",
            "\treturn node;",
            "}"
          ],
          "function_name": "kernel_get_mempolicy, vma_migratable, vma_policy_mof, apply_policy_zone, weighted_interleave_nodes",
          "description": "kernel_get_mempolicy 获取当前内存策略参数并复制到用户空间；vma_migratable 判断虚拟内存区域是否支持迁移；vma_policy_mof 检查VMA是否启用了MOF（Migration On Fault）策略；apply_policy_zone 确定当前zone是否满足策略要求；weighted_interleave_nodes 计算加权交错分配的目标节点。",
          "similarity": 0.5009486079216003
        },
        {
          "chunk_id": 12,
          "file_path": "mm/mempolicy.c",
          "start_line": 2024,
          "end_line": 2135,
          "content": [
            "static unsigned int interleave_nodes(struct mempolicy *policy)",
            "{",
            "\tunsigned int nid;",
            "\tunsigned int cpuset_mems_cookie;",
            "",
            "\t/* to prevent miscount, use tsk->mems_allowed_seq to detect rebind */",
            "\tdo {",
            "\t\tcpuset_mems_cookie = read_mems_allowed_begin();",
            "\t\tnid = next_node_in(current->il_prev, policy->nodes);",
            "\t} while (read_mems_allowed_retry(cpuset_mems_cookie));",
            "",
            "\tif (nid < MAX_NUMNODES)",
            "\t\tcurrent->il_prev = nid;",
            "\treturn nid;",
            "}",
            "unsigned int mempolicy_slab_node(void)",
            "{",
            "\tstruct mempolicy *policy;",
            "\tint node = numa_mem_id();",
            "",
            "\tif (!in_task())",
            "\t\treturn node;",
            "",
            "\tpolicy = current->mempolicy;",
            "\tif (!policy)",
            "\t\treturn node;",
            "",
            "\tswitch (policy->mode) {",
            "\tcase MPOL_PREFERRED:",
            "\t\treturn first_node(policy->nodes);",
            "",
            "\tcase MPOL_INTERLEAVE:",
            "\t\treturn interleave_nodes(policy);",
            "",
            "\tcase MPOL_WEIGHTED_INTERLEAVE:",
            "\t\treturn weighted_interleave_nodes(policy);",
            "",
            "\tcase MPOL_BIND:",
            "\tcase MPOL_PREFERRED_MANY:",
            "\t{",
            "\t\tstruct zoneref *z;",
            "",
            "\t\t/*",
            "\t\t * Follow bind policy behavior and start allocation at the",
            "\t\t * first node.",
            "\t\t */",
            "\t\tstruct zonelist *zonelist;",
            "\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);",
            "\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];",
            "\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,",
            "\t\t\t\t\t\t\t&policy->nodes);",
            "\t\treturn z->zone ? zone_to_nid(z->zone) : node;",
            "\t}",
            "\tcase MPOL_LOCAL:",
            "\t\treturn node;",
            "",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "static unsigned int read_once_policy_nodemask(struct mempolicy *pol,",
            "\t\t\t\t\t      nodemask_t *mask)",
            "{",
            "\t/*",
            "\t * barrier stabilizes the nodemask locally so that it can be iterated",
            "\t * over safely without concern for changes. Allocators validate node",
            "\t * selection does not violate mems_allowed, so this is safe.",
            "\t */",
            "\tbarrier();",
            "\tmemcpy(mask, &pol->nodes, sizeof(nodemask_t));",
            "\tbarrier();",
            "\treturn nodes_weight(*mask);",
            "}",
            "static unsigned int weighted_interleave_nid(struct mempolicy *pol, pgoff_t ilx)",
            "{",
            "\tstruct weighted_interleave_state *state;",
            "\tnodemask_t nodemask;",
            "\tunsigned int target, nr_nodes;",
            "\tu8 *table = NULL;",
            "\tunsigned int weight_total = 0;",
            "\tu8 weight;",
            "\tint nid = 0;",
            "",
            "\tnr_nodes = read_once_policy_nodemask(pol, &nodemask);",
            "\tif (!nr_nodes)",
            "\t\treturn numa_node_id();",
            "",
            "\trcu_read_lock();",
            "",
            "\tstate = rcu_dereference(wi_state);",
            "\t/* Uninitialized wi_state means we should assume all weights are 1 */",
            "\tif (state)",
            "\t\ttable = state->iw_table;",
            "",
            "\t/* calculate the total weight */",
            "\tfor_each_node_mask(nid, nodemask)",
            "\t\tweight_total += table ? table[nid] : 1;",
            "",
            "\t/* Calculate the node offset based on totals */",
            "\ttarget = ilx % weight_total;",
            "\tnid = first_node(nodemask);",
            "\twhile (target) {",
            "\t\t/* detect system default usage */",
            "\t\tweight = table ? table[nid] : 1;",
            "\t\tif (target < weight)",
            "\t\t\tbreak;",
            "\t\ttarget -= weight;",
            "\t\tnid = next_node_in(nid, nodemask);",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn nid;",
            "}"
          ],
          "function_name": "interleave_nodes, mempolicy_slab_node, read_once_policy_nodemask, weighted_interleave_nid",
          "description": "interleave_nodes 计算交错分配的下一个节点；mempolicy_slab_node 根据内存策略返回Slab分配的节点；read_once_policy_nodemask 安全读取策略节点掩码；weighted_interleave_nid 基于权重计算加权交错分配的目标节点。",
          "similarity": 0.4943215250968933
        },
        {
          "chunk_id": 0,
          "file_path": "mm/mempolicy.c",
          "start_line": 1,
          "end_line": 167,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Simple NUMA memory policy for the Linux kernel.",
            " *",
            " * Copyright 2003,2004 Andi Kleen, SuSE Labs.",
            " * (C) Copyright 2005 Christoph Lameter, Silicon Graphics, Inc.",
            " *",
            " * NUMA policy allows the user to give hints in which node(s) memory should",
            " * be allocated.",
            " *",
            " * Support four policies per VMA and per process:",
            " *",
            " * The VMA policy has priority over the process policy for a page fault.",
            " *",
            " * interleave     Allocate memory interleaved over a set of nodes,",
            " *                with normal fallback if it fails.",
            " *                For VMA based allocations this interleaves based on the",
            " *                offset into the backing object or offset into the mapping",
            " *                for anonymous memory. For process policy an process counter",
            " *                is used.",
            " *",
            " * weighted interleave",
            " *                Allocate memory interleaved over a set of nodes based on",
            " *                a set of weights (per-node), with normal fallback if it",
            " *                fails.  Otherwise operates the same as interleave.",
            " *                Example: nodeset(0,1) & weights (2,1) - 2 pages allocated",
            " *                on node 0 for every 1 page allocated on node 1.",
            " *",
            " * bind           Only allocate memory on a specific set of nodes,",
            " *                no fallback.",
            " *                FIXME: memory is allocated starting with the first node",
            " *                to the last. It would be better if bind would truly restrict",
            " *                the allocation to memory nodes instead",
            " *",
            " * preferred      Try a specific node first before normal fallback.",
            " *                As a special case NUMA_NO_NODE here means do the allocation",
            " *                on the local CPU. This is normally identical to default,",
            " *                but useful to set in a VMA when you have a non default",
            " *                process policy.",
            " *",
            " * preferred many Try a set of nodes first before normal fallback. This is",
            " *                similar to preferred without the special case.",
            " *",
            " * default        Allocate on the local node first, or when on a VMA",
            " *                use the process policy. This is what Linux always did",
            " *\t\t  in a NUMA aware kernel and still does by, ahem, default.",
            " *",
            " * The process policy is applied for most non interrupt memory allocations",
            " * in that process' context. Interrupts ignore the policies and always",
            " * try to allocate on the local CPU. The VMA policy is only applied for memory",
            " * allocations for a VMA in the VM.",
            " *",
            " * Currently there are a few corner cases in swapping where the policy",
            " * is not applied, but the majority should be handled. When process policy",
            " * is used it is not remembered over swap outs/swap ins.",
            " *",
            " * Only the highest zone in the zone hierarchy gets policied. Allocations",
            " * requesting a lower zone just use default policy. This implies that",
            " * on systems with highmem kernel lowmem allocation don't get policied.",
            " * Same with GFP_DMA allocations.",
            " *",
            " * For shmem/tmpfs shared memory the policy is shared between",
            " * all users and remembered even when nobody has memory mapped.",
            " */",
            "",
            "/* Notebook:",
            "   fix mmap readahead to honour policy and enable policy for any page cache",
            "   object",
            "   statistics for bigpages",
            "   global policy for page cache? currently it uses process policy. Requires",
            "   first item above.",
            "   handle mremap for shared memory (currently ignored for the policy)",
            "   grows down?",
            "   make bind policy root only? It can trigger oom much faster and the",
            "   kernel is not always grateful with that.",
            "*/",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagewalk.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/compat.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/swap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/printk.h>",
            "#include <linux/swapops.h>",
            "#include <linux/gcd.h>",
            "",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>",
            "",
            "#include \"internal.h\"",
            "",
            "/* Internal flags */",
            "#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */",
            "#define MPOL_MF_INVERT       (MPOL_MF_INTERNAL << 1)\t/* Invert check for nodemask */",
            "#define MPOL_MF_WRLOCK       (MPOL_MF_INTERNAL << 2)\t/* Write-lock walked vmas */",
            "",
            "static struct kmem_cache *policy_cache;",
            "static struct kmem_cache *sn_cache;",
            "",
            "/* Highest zone. An specific allocation for a zone below that is not",
            "   policied. */",
            "enum zone_type policy_zone = 0;",
            "",
            "/*",
            " * run-time system-wide default policy => local allocation",
            " */",
            "static struct mempolicy default_policy = {",
            "\t.refcnt = ATOMIC_INIT(1), /* never free it */",
            "\t.mode = MPOL_LOCAL,",
            "};",
            "",
            "static struct mempolicy preferred_node_policy[MAX_NUMNODES];",
            "",
            "/*",
            " * weightiness balances the tradeoff between small weights (cycles through nodes",
            " * faster, more fair/even distribution) and large weights (smaller errors",
            " * between actual bandwidth ratios and weight ratios). 32 is a number that has",
            " * been found to perform at a reasonable compromise between the two goals.",
            " */",
            "static const int weightiness = 32;",
            "",
            "/*",
            " * A null weighted_interleave_state is interpreted as having .mode=\"auto\",",
            " * and .iw_table is interpreted as an array of 1s with length nr_node_ids.",
            " */",
            "struct weighted_interleave_state {",
            "\tbool mode_auto;",
            "\tu8 iw_table[];",
            "};",
            "static struct weighted_interleave_state __rcu *wi_state;",
            "static unsigned int *node_bw_table;",
            "",
            "/*",
            " * wi_state_lock protects both wi_state and node_bw_table.",
            " * node_bw_table is only used by writers to update wi_state.",
            " */",
            "static DEFINE_MUTEX(wi_state_lock);",
            ""
          ],
          "function_name": null,
          "description": "定义NUMA内存策略相关结构体和全局变量，包括默认策略default_policy、节点带宽表node_bw_table及加权交错策略状态wi_state，用于管理多节点内存分配策略。",
          "similarity": 0.4916864335536957
        }
      ]
    },
    {
      "source_file": "kernel/params.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:15:19\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `params.c`\n\n---\n\n# params.c 技术文档\n\n## 1. 文件概述\n\n`params.c` 是 Linux 内核中用于解析内核命令行参数（kernel command line）和模块参数（module parameters）的核心辅助文件。它提供了一套通用的参数解析框架，支持从字符串形式的参数值转换为内核内部数据类型，并允许注册自定义参数处理函数。该文件实现了参数的设置、获取、内存管理、安全检查以及未知参数的回调处理机制，是内核启动参数和模块参数系统的基础组件。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `parameq(const char *a, const char *b)` / `parameqn(...)`：比较两个参数名是否相等，将 `-` 视为 `_`（兼容命令行习惯）。\n- `parse_one(...)`：解析单个参数（如 `foo=bar`），在参数表中查找匹配项并调用其 `set` 操作。\n- `parse_args(...)`：解析完整的参数字符串（如 `\"foo=bar,baz=1\"`），按逗号或空格分隔，逐个调用 `parse_one`。\n- `param_set_*` / `param_get_*` 系列函数：为标准数据类型（byte、int、ulong 等）提供参数设置和获取操作。\n- `param_set_charp` / `param_get_charp` / `param_free_charp`：处理字符串类型参数，支持动态内存分配与释放。\n- `param_set_bool` / `param_get_bool`：处理布尔类型参数，支持 `y/n/Y/N/0/1` 等输入格式。\n- `param_check_unsafe(...)`：检查参数是否为“危险”或“硬件相关”，并在安全锁定（lockdown）模式下限制访问。\n\n### 主要数据结构\n\n- `struct kernel_param`：描述一个内核参数，包含名称、操作函数集（`ops`）、参数地址（`arg`）、所属模块（`mod`）和安全标志（`flags`）。\n- `struct kernel_param_ops`：定义参数的操作接口，包括 `set`（设置）、`get`（获取）和可选的 `free`（释放）函数。\n- `struct kmalloced_param`：用于跟踪通过 `kmalloc` 分配的字符串参数内存，便于统一释放。\n\n### 宏定义\n\n- `STANDARD_PARAM_DEF(name, type, format, strtolfn)`：用于快速定义标准类型参数的 `set`/`get` 函数和 `ops` 结构体。\n\n## 3. 关键实现\n\n### 参数名等价处理\n函数 `dash2underscore()` 将连字符 `-` 转换为下划线 `_`，使得命令行中 `foo-bar=1` 可以匹配内核中名为 `foo_bar` 的参数，提升用户友好性。\n\n### 内存管理机制\n对于字符串参数（`charp` 类型），使用 `kmalloced_param` 链表跟踪所有动态分配的内存。在早期启动阶段（slab 分配器不可用时），直接使用命令行字符串指针；后期则分配新内存并复制内容。`maybe_kfree_parameter()` 在参数重设或模块卸载时安全释放内存。\n\n### 并发与锁机制\n在 `CONFIG_SYSFS` 启用时，使用互斥锁（`param_lock` 或模块私有 `param_lock`）保护参数设置操作，防止并发修改。`check_kparam_locked()` 在调试模式下验证锁状态。\n\n### 安全限制\n通过 `param_check_unsafe()` 检查参数标志：\n- 若参数标记为 `KERNEL_PARAM_FL_HWPARAM` 且系统处于 `LOCKDOWN_MODULE_PARAMETERS` 锁定状态，则拒绝设置（返回 `-EPERM`）。\n- 若参数标记为 `KERNEL_PARAM_FL_UNSAFE`，则设置时打印警告并污染内核（`add_taint(TAINT_USER)`）。\n\n### 参数解析流程\n`parse_args()` 使用 `next_arg()` 拆分参数字符串，对每个 `param=val` 调用 `parse_one()`。若未找到匹配参数且提供了 `unknown` 回调，则交由回调处理；否则报错。支持以 `--` 终止解析。\n\n### 标准类型支持\n通过 `STANDARD_PARAM_DEF` 宏自动生成多种整数类型（byte/short/int/long/ulong/ullong/hexint）的参数操作函数，统一使用 `kstrto*` 系列函数进行字符串到数值的转换。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/kernel.h>`：基础内核 API\n  - `<linux/kstrtox.h>`：字符串转数值函数（`kstrtoull` 等）\n  - `<linux/module.h>` / `<linux/moduleparam.h>`：模块参数相关定义\n  - `<linux/security.h>`：安全锁定（lockdown）检查\n  - `<linux/slab.h>`：内存分配（`kmalloc`/`kfree`）\n  - `<linux/ctype.h>`：字符处理（`skip_spaces` 等）\n\n- **配置依赖**：\n  - `CONFIG_SYSFS`：启用参数锁机制\n  - `CONFIG_MODULES`：区分内置参数与模块参数的锁\n\n- **导出符号**：\n  - 所有 `param_set_*`、`param_get_*`、`param_ops_*` 均通过 `EXPORT_SYMBOL` 导出，供模块使用。\n  - `param_set_uint_minmax` 通过 `EXPORT_SYMBOL_GPL` 导出，用于带范围检查的无符号整数参数。\n\n## 5. 使用场景\n\n- **内核启动参数解析**：在 `start_kernel()` 阶段，通过 `parse_args()` 解析 `boot_command_line`，设置内核全局变量（如 `initcall_debug`、`loglevel` 等）。\n- **内核模块参数处理**：模块加载时（`init_module` 系统调用），解析用户传入的参数字符串，调用对应参数的 `set` 函数初始化模块变量。\n- **sysfs 参数接口**：当 `CONFIG_SYSFS` 启用时，模块参数会暴露在 `/sys/module/<modname>/parameters/` 下，读写操作分别调用 `get` 和 `set` 函数。\n- **动态参数调整**：运行时可通过 `sysfs` 或 `modprobe` 修改模块参数值，触发 `param_set_*` 函数执行。\n- **安全敏感系统**：在启用了内核锁定（lockdown）的系统中，阻止用户空间修改关键硬件参数，增强系统安全性。",
      "similarity": 0.557731568813324,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/params.c",
          "start_line": 265,
          "end_line": 406,
          "content": [
            "int param_set_charp(const char *val, const struct kernel_param *kp)",
            "{",
            "\tif (strlen(val) > 1024) {",
            "\t\tpr_err(\"%s: string parameter too long\\n\", kp->name);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "",
            "\tmaybe_kfree_parameter(*(char **)kp->arg);",
            "",
            "\t/* This is a hack.  We can't kmalloc in early boot, and we",
            "\t * don't need to; this mangled commandline is preserved. */",
            "\tif (slab_is_available()) {",
            "\t\t*(char **)kp->arg = kmalloc_parameter(strlen(val)+1);",
            "\t\tif (!*(char **)kp->arg)",
            "\t\t\treturn -ENOMEM;",
            "\t\tstrcpy(*(char **)kp->arg, val);",
            "\t} else",
            "\t\t*(const char **)kp->arg = val;",
            "",
            "\treturn 0;",
            "}",
            "int param_get_charp(char *buffer, const struct kernel_param *kp)",
            "{",
            "\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", *((char **)kp->arg));",
            "}",
            "void param_free_charp(void *arg)",
            "{",
            "\tmaybe_kfree_parameter(*((char **)arg));",
            "}",
            "int param_set_bool(const char *val, const struct kernel_param *kp)",
            "{",
            "\t/* No equals means \"set\"... */",
            "\tif (!val) val = \"1\";",
            "",
            "\t/* One of =[yYnN01] */",
            "\treturn kstrtobool(val, kp->arg);",
            "}",
            "int param_get_bool(char *buffer, const struct kernel_param *kp)",
            "{",
            "\t/* Y and N chosen as being relatively non-coder friendly */",
            "\treturn sprintf(buffer, \"%c\\n\", *(bool *)kp->arg ? 'Y' : 'N');",
            "}",
            "int param_set_bool_enable_only(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint err;",
            "\tbool new_value;",
            "\tbool orig_value = *(bool *)kp->arg;",
            "\tstruct kernel_param dummy_kp = *kp;",
            "",
            "\tdummy_kp.arg = &new_value;",
            "",
            "\terr = param_set_bool(val, &dummy_kp);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Don't let them unset it once it's set! */",
            "\tif (!new_value && orig_value)",
            "\t\treturn -EROFS;",
            "",
            "\tif (new_value)",
            "\t\terr = param_set_bool(val, kp);",
            "",
            "\treturn err;",
            "}",
            "int param_set_invbool(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint ret;",
            "\tbool boolval;",
            "\tstruct kernel_param dummy;",
            "",
            "\tdummy.arg = &boolval;",
            "\tret = param_set_bool(val, &dummy);",
            "\tif (ret == 0)",
            "\t\t*(bool *)kp->arg = !boolval;",
            "\treturn ret;",
            "}",
            "int param_get_invbool(char *buffer, const struct kernel_param *kp)",
            "{",
            "\treturn sprintf(buffer, \"%c\\n\", (*(bool *)kp->arg) ? 'N' : 'Y');",
            "}",
            "int param_set_bint(const char *val, const struct kernel_param *kp)",
            "{",
            "\t/* Match bool exactly, by re-using it. */",
            "\tstruct kernel_param boolkp = *kp;",
            "\tbool v;",
            "\tint ret;",
            "",
            "\tboolkp.arg = &v;",
            "",
            "\tret = param_set_bool(val, &boolkp);",
            "\tif (ret == 0)",
            "\t\t*(int *)kp->arg = v;",
            "\treturn ret;",
            "}",
            "static int param_array(struct module *mod,",
            "\t\t       const char *name,",
            "\t\t       const char *val,",
            "\t\t       unsigned int min, unsigned int max,",
            "\t\t       void *elem, int elemsize,",
            "\t\t       int (*set)(const char *, const struct kernel_param *kp),",
            "\t\t       s16 level,",
            "\t\t       unsigned int *num)",
            "{",
            "\tint ret;",
            "\tstruct kernel_param kp;",
            "\tchar save;",
            "",
            "\t/* Get the name right for errors. */",
            "\tkp.name = name;",
            "\tkp.arg = elem;",
            "\tkp.level = level;",
            "",
            "\t*num = 0;",
            "\t/* We expect a comma-separated list of values. */",
            "\tdo {",
            "\t\tint len;",
            "",
            "\t\tif (*num == max) {",
            "\t\t\tpr_err(\"%s: can only take %i arguments\\n\", name, max);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\tlen = strcspn(val, \",\");",
            "",
            "\t\t/* nul-terminate and parse */",
            "\t\tsave = val[len];",
            "\t\t((char *)val)[len] = '\\0';",
            "\t\tcheck_kparam_locked(mod);",
            "\t\tret = set(val, &kp);",
            "",
            "\t\tif (ret != 0)",
            "\t\t\treturn ret;",
            "\t\tkp.arg += elemsize;",
            "\t\tval += len+1;",
            "\t\t(*num)++;",
            "\t} while (save == ',');",
            "",
            "\tif (*num < min) {",
            "\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "param_set_charp, param_get_charp, param_free_charp, param_set_bool, param_get_bool, param_set_bool_enable_only, param_set_invbool, param_get_invbool, param_set_bint, param_array",
          "description": "提供特定参数类型的处理实现，包括字符串参数分配、布尔值转换、数组参数处理等，包含内存管理、格式化输出等辅助功能。",
          "similarity": 0.5650151968002319
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/params.c",
          "start_line": 29,
          "end_line": 143,
          "content": [
            "static inline void check_kparam_locked(struct module *mod)",
            "{",
            "\tBUG_ON(!mutex_is_locked(KPARAM_MUTEX(mod)));",
            "}",
            "static inline void check_kparam_locked(struct module *mod)",
            "{",
            "}",
            "static void maybe_kfree_parameter(void *param)",
            "{",
            "\tstruct kmalloced_param *p;",
            "",
            "\tspin_lock(&kmalloced_params_lock);",
            "\tlist_for_each_entry(p, &kmalloced_params, list) {",
            "\t\tif (p->val == param) {",
            "\t\t\tlist_del(&p->list);",
            "\t\t\tkfree(p);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&kmalloced_params_lock);",
            "}",
            "static char dash2underscore(char c)",
            "{",
            "\tif (c == '-')",
            "\t\treturn '_';",
            "\treturn c;",
            "}",
            "bool parameqn(const char *a, const char *b, size_t n)",
            "{",
            "\tsize_t i;",
            "",
            "\tfor (i = 0; i < n; i++) {",
            "\t\tif (dash2underscore(a[i]) != dash2underscore(b[i]))",
            "\t\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "bool parameq(const char *a, const char *b)",
            "{",
            "\treturn parameqn(a, b, strlen(a)+1);",
            "}",
            "static bool param_check_unsafe(const struct kernel_param *kp)",
            "{",
            "\tif (kp->flags & KERNEL_PARAM_FL_HWPARAM &&",
            "\t    security_locked_down(LOCKDOWN_MODULE_PARAMETERS))",
            "\t\treturn false;",
            "",
            "\tif (kp->flags & KERNEL_PARAM_FL_UNSAFE) {",
            "\t\tpr_notice(\"Setting dangerous option %s - tainting kernel\\n\",",
            "\t\t\t  kp->name);",
            "\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static int parse_one(char *param,",
            "\t\t     char *val,",
            "\t\t     const char *doing,",
            "\t\t     const struct kernel_param *params,",
            "\t\t     unsigned num_params,",
            "\t\t     s16 min_level,",
            "\t\t     s16 max_level,",
            "\t\t     void *arg,",
            "\t\t     int (*handle_unknown)(char *param, char *val,",
            "\t\t\t\t     const char *doing, void *arg))",
            "{",
            "\tunsigned int i;",
            "\tint err;",
            "",
            "\t/* Find parameter */",
            "\tfor (i = 0; i < num_params; i++) {",
            "\t\tif (parameq(param, params[i].name)) {",
            "\t\t\tif (params[i].level < min_level",
            "\t\t\t    || params[i].level > max_level)",
            "\t\t\t\treturn 0;",
            "\t\t\t/* No one handled NULL, so do it here. */",
            "\t\t\tif (!val &&",
            "\t\t\t    !(params[i].ops->flags & KERNEL_PARAM_OPS_FL_NOARG))",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\tpr_debug(\"handling %s with %p\\n\", param,",
            "\t\t\t\tparams[i].ops->set);",
            "\t\t\tkernel_param_lock(params[i].mod);",
            "\t\t\tif (param_check_unsafe(&params[i]))",
            "\t\t\t\terr = params[i].ops->set(val, &params[i]);",
            "\t\t\telse",
            "\t\t\t\terr = -EPERM;",
            "\t\t\tkernel_param_unlock(params[i].mod);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "",
            "\tif (handle_unknown) {",
            "\t\tpr_debug(\"doing %s: %s='%s'\\n\", doing, param, val);",
            "\t\treturn handle_unknown(param, val, doing, arg);",
            "\t}",
            "",
            "\tpr_debug(\"Unknown argument '%s'\\n\", param);",
            "\treturn -ENOENT;",
            "}",
            "int param_set_uint_minmax(const char *val, const struct kernel_param *kp,",
            "\t\tunsigned int min, unsigned int max)",
            "{",
            "\tunsigned int num;",
            "\tint ret;",
            "",
            "\tif (!val)",
            "\t\treturn -EINVAL;",
            "\tret = kstrtouint(val, 0, &num);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (num < min || num > max)",
            "\t\treturn -EINVAL;",
            "\t*((unsigned int *)kp->arg) = num;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "check_kparam_locked, check_kparam_locked, maybe_kfree_parameter, dash2underscore, parameqn, parameq, param_check_unsafe, parse_one, param_set_uint_minmax",
          "description": "实现参数解析核心逻辑，包含参数匹配、权限检查、类型转换及异常处理，支持布尔、整数、字符串等基本类型参数的统一处理框架。",
          "similarity": 0.5394055843353271
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/params.c",
          "start_line": 463,
          "end_line": 621,
          "content": [
            "static int param_array_set(const char *val, const struct kernel_param *kp)",
            "{",
            "\tconst struct kparam_array *arr = kp->arr;",
            "\tunsigned int temp_num;",
            "",
            "\treturn param_array(kp->mod, kp->name, val, 1, arr->max, arr->elem,",
            "\t\t\t   arr->elemsize, arr->ops->set, kp->level,",
            "\t\t\t   arr->num ?: &temp_num);",
            "}",
            "static int param_array_get(char *buffer, const struct kernel_param *kp)",
            "{",
            "\tint i, off, ret;",
            "\tconst struct kparam_array *arr = kp->arr;",
            "\tstruct kernel_param p = *kp;",
            "",
            "\tfor (i = off = 0; i < (arr->num ? *arr->num : arr->max); i++) {",
            "\t\t/* Replace \\n with comma */",
            "\t\tif (i)",
            "\t\t\tbuffer[off - 1] = ',';",
            "\t\tp.arg = arr->elem + arr->elemsize * i;",
            "\t\tcheck_kparam_locked(p.mod);",
            "\t\tret = arr->ops->get(buffer + off, &p);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t\toff += ret;",
            "\t}",
            "\tbuffer[off] = '\\0';",
            "\treturn off;",
            "}",
            "static void param_array_free(void *arg)",
            "{",
            "\tunsigned int i;",
            "\tconst struct kparam_array *arr = arg;",
            "",
            "\tif (arr->ops->free)",
            "\t\tfor (i = 0; i < (arr->num ? *arr->num : arr->max); i++)",
            "\t\t\tarr->ops->free(arr->elem + arr->elemsize * i);",
            "}",
            "int param_set_copystring(const char *val, const struct kernel_param *kp)",
            "{",
            "\tconst struct kparam_string *kps = kp->str;",
            "",
            "\tif (strlen(val)+1 > kps->maxlen) {",
            "\t\tpr_err(\"%s: string doesn't fit in %u chars.\\n\",",
            "\t\t       kp->name, kps->maxlen-1);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "\tstrcpy(kps->string, val);",
            "\treturn 0;",
            "}",
            "int param_get_string(char *buffer, const struct kernel_param *kp)",
            "{",
            "\tconst struct kparam_string *kps = kp->str;",
            "\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", kps->string);",
            "}",
            "static ssize_t param_attr_show(struct module_attribute *mattr,",
            "\t\t\t       struct module_kobject *mk, char *buf)",
            "{",
            "\tint count;",
            "\tstruct param_attribute *attribute = to_param_attr(mattr);",
            "",
            "\tif (!attribute->param->ops->get)",
            "\t\treturn -EPERM;",
            "",
            "\tkernel_param_lock(mk->mod);",
            "\tcount = attribute->param->ops->get(buf, attribute->param);",
            "\tkernel_param_unlock(mk->mod);",
            "\treturn count;",
            "}",
            "static ssize_t param_attr_store(struct module_attribute *mattr,",
            "\t\t\t\tstruct module_kobject *mk,",
            "\t\t\t\tconst char *buf, size_t len)",
            "{",
            " \tint err;",
            "\tstruct param_attribute *attribute = to_param_attr(mattr);",
            "",
            "\tif (!attribute->param->ops->set)",
            "\t\treturn -EPERM;",
            "",
            "\tkernel_param_lock(mk->mod);",
            "\tif (param_check_unsafe(attribute->param))",
            "\t\terr = attribute->param->ops->set(buf, attribute->param);",
            "\telse",
            "\t\terr = -EPERM;",
            "\tkernel_param_unlock(mk->mod);",
            "\tif (!err)",
            "\t\treturn len;",
            "\treturn err;",
            "}",
            "void kernel_param_lock(struct module *mod)",
            "{",
            "\tmutex_lock(KPARAM_MUTEX(mod));",
            "}",
            "void kernel_param_unlock(struct module *mod)",
            "{",
            "\tmutex_unlock(KPARAM_MUTEX(mod));",
            "}",
            "static __modinit int add_sysfs_param(struct module_kobject *mk,",
            "\t\t\t\t     const struct kernel_param *kp,",
            "\t\t\t\t     const char *name)",
            "{",
            "\tstruct module_param_attrs *new_mp;",
            "\tstruct attribute **new_attrs;",
            "\tunsigned int i;",
            "",
            "\t/* We don't bother calling this with invisible parameters. */",
            "\tBUG_ON(!kp->perm);",
            "",
            "\tif (!mk->mp) {",
            "\t\t/* First allocation. */",
            "\t\tmk->mp = kzalloc(sizeof(*mk->mp), GFP_KERNEL);",
            "\t\tif (!mk->mp)",
            "\t\t\treturn -ENOMEM;",
            "\t\tmk->mp->grp.name = \"parameters\";",
            "\t\t/* NULL-terminated attribute array. */",
            "\t\tmk->mp->grp.attrs = kzalloc(sizeof(mk->mp->grp.attrs[0]),",
            "\t\t\t\t\t    GFP_KERNEL);",
            "\t\t/* Caller will cleanup via free_module_param_attrs */",
            "\t\tif (!mk->mp->grp.attrs)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\t/* Enlarge allocations. */",
            "\tnew_mp = krealloc(mk->mp,",
            "\t\t\t  sizeof(*mk->mp) +",
            "\t\t\t  sizeof(mk->mp->attrs[0]) * (mk->mp->num + 1),",
            "\t\t\t  GFP_KERNEL);",
            "\tif (!new_mp)",
            "\t\treturn -ENOMEM;",
            "\tmk->mp = new_mp;",
            "",
            "\t/* Extra pointer for NULL terminator */",
            "\tnew_attrs = krealloc(mk->mp->grp.attrs,",
            "\t\t\t     sizeof(mk->mp->grp.attrs[0]) * (mk->mp->num + 2),",
            "\t\t\t     GFP_KERNEL);",
            "\tif (!new_attrs)",
            "\t\treturn -ENOMEM;",
            "\tmk->mp->grp.attrs = new_attrs;",
            "",
            "\t/* Tack new one on the end. */",
            "\tmemset(&mk->mp->attrs[mk->mp->num], 0, sizeof(mk->mp->attrs[0]));",
            "\tsysfs_attr_init(&mk->mp->attrs[mk->mp->num].mattr.attr);",
            "\tmk->mp->attrs[mk->mp->num].param = kp;",
            "\tmk->mp->attrs[mk->mp->num].mattr.show = param_attr_show;",
            "\t/* Do not allow runtime DAC changes to make param writable. */",
            "\tif ((kp->perm & (S_IWUSR | S_IWGRP | S_IWOTH)) != 0)",
            "\t\tmk->mp->attrs[mk->mp->num].mattr.store = param_attr_store;",
            "\telse",
            "\t\tmk->mp->attrs[mk->mp->num].mattr.store = NULL;",
            "\tmk->mp->attrs[mk->mp->num].mattr.attr.name = (char *)name;",
            "\tmk->mp->attrs[mk->mp->num].mattr.attr.mode = kp->perm;",
            "\tmk->mp->num++;",
            "",
            "\t/* Fix up all the pointers, since krealloc can move us */",
            "\tfor (i = 0; i < mk->mp->num; i++)",
            "\t\tmk->mp->grp.attrs[i] = &mk->mp->attrs[i].mattr.attr;",
            "\tmk->mp->grp.attrs[mk->mp->num] = NULL;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "param_array_set, param_array_get, param_array_free, param_set_copystring, param_get_string, param_attr_show, param_attr_store, kernel_param_lock, kernel_param_unlock, add_sysfs_param",
          "description": "实现sysfs接口参数暴露机制，包含参数属性展示/存储方法、数组参数处理、字符串拷贝等操作，支持模块参数的动态配置与监控。",
          "similarity": 0.5038952231407166
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/params.c",
          "start_line": 868,
          "end_line": 955,
          "content": [
            "static void __init version_sysfs_builtin(void)",
            "{",
            "\tconst struct module_version_attribute *vattr;",
            "\tstruct module_kobject *mk;",
            "\tint err;",
            "",
            "\tfor (vattr = __start___modver; vattr < __stop___modver; vattr++) {",
            "\t\tmk = lookup_or_create_module_kobject(vattr->module_name);",
            "\t\tif (mk) {",
            "\t\t\terr = sysfs_create_file(&mk->kobj, &vattr->mattr.attr);",
            "\t\t\tWARN_ON_ONCE(err);",
            "\t\t\tkobject_uevent(&mk->kobj, KOBJ_ADD);",
            "\t\t\tkobject_put(&mk->kobj);",
            "\t\t}",
            "\t}",
            "}",
            "static ssize_t module_attr_show(struct kobject *kobj,",
            "\t\t\t\tstruct attribute *attr,",
            "\t\t\t\tchar *buf)",
            "{",
            "\tstruct module_attribute *attribute;",
            "\tstruct module_kobject *mk;",
            "\tint ret;",
            "",
            "\tattribute = to_module_attr(attr);",
            "\tmk = to_module_kobject(kobj);",
            "",
            "\tif (!attribute->show)",
            "\t\treturn -EIO;",
            "",
            "\tret = attribute->show(attribute, mk, buf);",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t module_attr_store(struct kobject *kobj,",
            "\t\t\t\tstruct attribute *attr,",
            "\t\t\t\tconst char *buf, size_t len)",
            "{",
            "\tstruct module_attribute *attribute;",
            "\tstruct module_kobject *mk;",
            "\tint ret;",
            "",
            "\tattribute = to_module_attr(attr);",
            "\tmk = to_module_kobject(kobj);",
            "",
            "\tif (!attribute->store)",
            "\t\treturn -EIO;",
            "",
            "\tret = attribute->store(attribute, mk, buf, len);",
            "",
            "\treturn ret;",
            "}",
            "static int uevent_filter(const struct kobject *kobj)",
            "{",
            "\tconst struct kobj_type *ktype = get_ktype(kobj);",
            "",
            "\tif (ktype == &module_ktype)",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "static void module_kobj_release(struct kobject *kobj)",
            "{",
            "\tstruct module_kobject *mk = to_module_kobject(kobj);",
            "",
            "\tif (mk->kobj_completion)",
            "\t\tcomplete(mk->kobj_completion);",
            "}",
            "static int __init param_sysfs_init(void)",
            "{",
            "\tmodule_kset = kset_create_and_add(\"module\", &module_uevent_ops, NULL);",
            "\tif (!module_kset) {",
            "\t\tprintk(KERN_WARNING \"%s (%d): error creating kset\\n\",",
            "\t\t\t__FILE__, __LINE__);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init param_sysfs_builtin_init(void)",
            "{",
            "\tif (!module_kset)",
            "\t\treturn -ENOMEM;",
            "",
            "\tversion_sysfs_builtin();",
            "\tparam_sysfs_builtin();",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "version_sysfs_builtin, module_attr_show, module_attr_store, uevent_filter, module_kobj_release, param_sysfs_init, param_sysfs_builtin_init",
          "description": "该代码段主要实现模块参数的SysFS接口初始化与管理，包含以下功能：  \n1. `version_sysfs_builtin` 初始化模块版本属性到SysFS，创建对应文件并触发设备添加事件；  \n2. `module_attr_show/store` 定义模块属性的通用读写接口，通过回调函数实现具体逻辑；  \n3. `param_sysfs_init` 创建模块KSet并注册UEVENT过滤规则，`param_sysfs_builtin_init` 统一调用版本相关初始化函数。",
          "similarity": 0.48128455877304077
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/params.c",
          "start_line": 690,
          "end_line": 795,
          "content": [
            "static void free_module_param_attrs(struct module_kobject *mk)",
            "{",
            "\tif (mk->mp)",
            "\t\tkfree(mk->mp->grp.attrs);",
            "\tkfree(mk->mp);",
            "\tmk->mp = NULL;",
            "}",
            "int module_param_sysfs_setup(struct module *mod,",
            "\t\t\t     const struct kernel_param *kparam,",
            "\t\t\t     unsigned int num_params)",
            "{",
            "\tint i, err;",
            "\tbool params = false;",
            "",
            "\tfor (i = 0; i < num_params; i++) {",
            "\t\tif (kparam[i].perm == 0)",
            "\t\t\tcontinue;",
            "\t\terr = add_sysfs_param(&mod->mkobj, &kparam[i], kparam[i].name);",
            "\t\tif (err) {",
            "\t\t\tfree_module_param_attrs(&mod->mkobj);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t\tparams = true;",
            "\t}",
            "",
            "\tif (!params)",
            "\t\treturn 0;",
            "",
            "\t/* Create the param group. */",
            "\terr = sysfs_create_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);",
            "\tif (err)",
            "\t\tfree_module_param_attrs(&mod->mkobj);",
            "\treturn err;",
            "}",
            "void module_param_sysfs_remove(struct module *mod)",
            "{",
            "\tif (mod->mkobj.mp) {",
            "\t\tsysfs_remove_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);",
            "\t\t/* We are positive that no one is using any param",
            "\t\t * attrs at this point.  Deallocate immediately. */",
            "\t\tfree_module_param_attrs(&mod->mkobj);",
            "\t}",
            "}",
            "void destroy_params(const struct kernel_param *params, unsigned num)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < num; i++)",
            "\t\tif (params[i].ops->free)",
            "\t\t\tparams[i].ops->free(params[i].arg);",
            "}",
            "static void __init kernel_add_sysfs_param(const char *name,",
            "\t\t\t\t\t  const struct kernel_param *kparam,",
            "\t\t\t\t\t  unsigned int name_skip)",
            "{",
            "\tstruct module_kobject *mk;",
            "\tint err;",
            "",
            "\tmk = lookup_or_create_module_kobject(name);",
            "\tif (!mk)",
            "\t\treturn;",
            "",
            "\t/* We need to remove old parameters before adding more. */",
            "\tif (mk->mp)",
            "\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);",
            "",
            "\t/* These should not fail at boot. */",
            "\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);",
            "\tBUG_ON(err);",
            "\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);",
            "\tBUG_ON(err);",
            "\tkobject_uevent(&mk->kobj, KOBJ_ADD);",
            "\tkobject_put(&mk->kobj);",
            "}",
            "static void __init param_sysfs_builtin(void)",
            "{",
            "\tconst struct kernel_param *kp;",
            "\tunsigned int name_len;",
            "\tchar modname[MODULE_NAME_LEN];",
            "",
            "\tfor (kp = __start___param; kp < __stop___param; kp++) {",
            "\t\tchar *dot;",
            "",
            "\t\tif (kp->perm == 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tdot = strchr(kp->name, '.');",
            "\t\tif (!dot) {",
            "\t\t\t/* This happens for core_param() */",
            "\t\t\tstrcpy(modname, \"kernel\");",
            "\t\t\tname_len = 0;",
            "\t\t} else {",
            "\t\t\tname_len = dot - kp->name + 1;",
            "\t\t\tstrscpy(modname, kp->name, name_len);",
            "\t\t}",
            "\t\tkernel_add_sysfs_param(modname, kp, name_len);",
            "\t}",
            "}",
            "ssize_t __modver_version_show(struct module_attribute *mattr,",
            "\t\t\t      struct module_kobject *mk, char *buf)",
            "{",
            "\tstruct module_version_attribute *vattr =",
            "\t\tcontainer_of(mattr, struct module_version_attribute, mattr);",
            "",
            "\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", vattr->version);",
            "}"
          ],
          "function_name": "free_module_param_attrs, module_param_sysfs_setup, module_param_sysfs_remove, destroy_params, kernel_add_sysfs_param, param_sysfs_builtin, __modver_version_show",
          "description": "管理模块参数的sysfs节点生命周期，包含参数组创建/移除、参数释放、内核内置参数注册等基础设施，负责模块参数的系统级集成。",
          "similarity": 0.46944141387939453
        }
      ]
    }
  ]
}