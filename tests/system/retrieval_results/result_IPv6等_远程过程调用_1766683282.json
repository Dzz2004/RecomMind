{
  "query": "IPv6等 远程过程调用",
  "timestamp": "2025-12-26 01:21:22",
  "retrieved_files": [
    {
      "source_file": "kernel/static_call_inline.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:29:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `static_call_inline.c`\n\n---\n\n# static_call_inline.c 技术文档\n\n## 1. 文件概述\n\n`static_call_inline.c` 是 Linux 内核中实现 **静态调用（Static Call）** 机制的核心文件之一。静态调用是一种运行时可动态更新的函数调用优化技术，它在编译时将函数调用点内联为对跳板（trampoline）的直接跳转，而在运行时可通过 `__static_call_update()` 动态修改所有调用点，使其跳转到新的目标函数，从而避免传统函数指针调用的间接开销。该机制常用于性能敏感路径（如调度、RCU、tracepoint 等），同时支持模块热插拔和初始化阶段的特殊处理。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `static_call_force_reinit(void)`  \n  强制重新初始化静态调用机制，用于调试或特殊场景，必须在 `early_initcall()` 之前调用。\n\n- `__static_call_update(struct static_call_key *key, void *tramp, void *func)`  \n  核心更新函数：将指定 `key` 对应的所有静态调用点更新为调用 `func`，并更新跳板 `tramp`。支持内核和模块中的调用点。\n\n- `__static_call_init(struct module *mod, struct static_call_site *start, struct static_call_site *stop)`  \n  初始化静态调用站点，对站点按 `key` 排序，并建立 `key` 到站点的映射关系，同时执行首次 `arch_static_call_transform`。\n\n- `__static_call_text_reserved(...)`  \n  检查指定代码区间是否与活跃的静态调用站点冲突，用于内存热插拔或代码修改前的安全校验。\n\n### 主要数据结构\n\n- `struct static_call_site`  \n  描述一个静态调用点的位置（`addr`）和关联的 `key`（带标志位）。\n\n- `struct static_call_key`  \n  静态调用的“键”，用于将多个调用点分组。包含当前函数指针 `func` 和类型/模块信息。\n\n- `struct static_call_mod`  \n  用于模块场景下，将模块与该模块中属于某 `key` 的调用点列表关联。\n\n- 全局符号：\n  - `__start_static_call_sites[]` / `__stop_static_call_sites[]`：内核镜像中所有静态调用点的链接器生成数组。\n  - `__start_static_call_tramp_key[]` / `__stop_static_call_tramp_key[]`：跳板与 key 的映射。\n\n### 辅助函数与宏\n\n- `static_call_addr(site)`：计算调用点的实际地址（处理重定位）。\n- `static_call_key(site)`：从站点中提取 `static_call_key*`（忽略标志位）。\n- `static_call_is_init(site)` / `static_call_is_tail(site)`：检查站点是否位于 `__init` 段或是否为尾调用。\n- `static_call_sort_entries()`：对站点按 `key` 排序，便于批量处理。\n- `static_call_key_has_mods()` / `static_call_key_sites()`：判断 key 是否关联模块或直接站点。\n\n## 3. 关键实现\n\n### 地址重定位处理\n由于静态调用站点在编译时使用相对地址存储，`static_call_addr()` 和 `__static_call_key()` 通过 `(long)field + (long)&field` 的方式计算出运行时绝对地址，这是处理位置无关代码（PIC）和内核重定位的关键技巧。\n\n### 站点组织与模块支持\n- **内核（vmlinux）场景**：为节省内存和避免早期内存分配，将首个站点指针直接编码到 `key->type` 的低有效位中（通过 `| 1` 标记）。\n- **模块场景**：使用 `static_call_mod` 链表管理不同模块中属于同一 `key` 的站点，支持模块加载/卸载时的动态注册。\n\n### 初始化与更新流程\n1. **初始化**（`__static_call_init`）：\n   - 对站点按 `key` 排序。\n   - 标记位于 `__init` 段的站点（后续更新可跳过）。\n   - 建立 `key` 到站点的映射。\n   - 调用架构相关 `arch_static_call_transform` 执行首次转换（通常设为跳板）。\n\n2. **更新**（`__static_call_update`）：\n   - 更新 `key->func`。\n   - 更新跳板 `tramp` 指向新函数。\n   - 遍历所有关联站点（包括模块），调用 `arch_static_call_transform` 修改调用点指令（如 x86 的 `jmp` 目标）。\n   - 跳过 `__init` 段中已初始化的站点（因不会被执行）。\n\n### 安全与并发控制\n- 使用 `cpus_read_lock()` 防止 CPU 热插拔期间的并发问题。\n- 使用 `static_call_mutex` 保护 `key` 和站点数据结构的修改。\n- 通过 `kernel_text_address()` 验证调用点是否在可执行内核文本段，避免修改无效地址。\n\n## 4. 依赖关系\n\n- **架构依赖**：依赖 `asm/sections.h` 和 `arch_static_call_transform()`（由各架构实现，如 x86、ARM64）。\n- **内核子系统**：\n  - `linux/module.h`：模块加载/卸载时的静态调用站点管理。\n  - `linux/cpu.h` / `linux/smp.h`：CPU 热插拔和并发控制。\n  - `linux/sort.h`：站点排序。\n  - `linux/slab.h`：模块场景下的动态内存分配。\n- **链接器脚本**：依赖链接器生成的 `__start/stop_static_call_sites` 等符号，这些在 `vmlinux.lds` 中定义。\n\n## 5. 使用场景\n\n- **内核核心优化**：在调度器、RCU、中断处理等高频路径中替代函数指针，减少间接调用开销。\n- **动态追踪（ftrace）**：作为 tracepoint 或 kprobe 的底层机制，实现零开销探针。\n- **模块热插拔**：模块加载时注册其静态调用站点，卸载时自动清理，确保调用点始终有效。\n- **初始化优化**：`__init` 段的调用点在初始化完成后可被安全忽略，减少运行时开销。\n- **安全代码修改**：在 livepatch 或内核热补丁中，安全地替换函数实现而不影响运行中的调用。",
      "similarity": 0.5674325823783875,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 23,
          "end_line": 176,
          "content": [
            "void static_call_force_reinit(void)",
            "{",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\treturn;",
            "",
            "\tstatic_call_initialized++;",
            "}",
            "static void static_call_lock(void)",
            "{",
            "\tmutex_lock(&static_call_mutex);",
            "}",
            "static void static_call_unlock(void)",
            "{",
            "\tmutex_unlock(&static_call_mutex);",
            "}",
            "static inline unsigned long __static_call_key(const struct static_call_site *site)",
            "{",
            "\treturn (long)site->key + (long)&site->key;",
            "}",
            "static inline bool static_call_is_init(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;",
            "}",
            "static inline bool static_call_is_tail(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;",
            "}",
            "static inline void static_call_set_init(struct static_call_site *site)",
            "{",
            "\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -",
            "\t\t    (long)&site->key;",
            "}",
            "static int static_call_site_cmp(const void *_a, const void *_b)",
            "{",
            "\tconst struct static_call_site *a = _a;",
            "\tconst struct static_call_site *b = _b;",
            "\tconst struct static_call_key *key_a = static_call_key(a);",
            "\tconst struct static_call_key *key_b = static_call_key(b);",
            "",
            "\tif (key_a < key_b)",
            "\t\treturn -1;",
            "",
            "\tif (key_a > key_b)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static void static_call_site_swap(void *_a, void *_b, int size)",
            "{",
            "\tlong delta = (unsigned long)_a - (unsigned long)_b;",
            "\tstruct static_call_site *a = _a;",
            "\tstruct static_call_site *b = _b;",
            "\tstruct static_call_site tmp = *a;",
            "",
            "\ta->addr = b->addr  - delta;",
            "\ta->key  = b->key   - delta;",
            "",
            "\tb->addr = tmp.addr + delta;",
            "\tb->key  = tmp.key  + delta;",
            "}",
            "static inline void static_call_sort_entries(struct static_call_site *start,",
            "\t\t\t\t\t    struct static_call_site *stop)",
            "{",
            "\tsort(start, stop - start, sizeof(struct static_call_site),",
            "\t     static_call_site_cmp, static_call_site_swap);",
            "}",
            "static inline bool static_call_key_has_mods(struct static_call_key *key)",
            "{",
            "\treturn !(key->type & 1);",
            "}",
            "void __static_call_update(struct static_call_key *key, void *tramp, void *func)",
            "{",
            "\tstruct static_call_site *site, *stop;",
            "\tstruct static_call_mod *site_mod, first;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tif (key->func == func)",
            "\t\tgoto done;",
            "",
            "\tkey->func = func;",
            "",
            "\tarch_static_call_transform(NULL, tramp, func, false);",
            "",
            "\t/*",
            "\t * If uninitialized, we'll not update the callsites, but they still",
            "\t * point to the trampoline and we just patched that.",
            "\t */",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\tgoto done;",
            "",
            "\tfirst = (struct static_call_mod){",
            "\t\t.next = static_call_key_next(key),",
            "\t\t.mod = NULL,",
            "\t\t.sites = static_call_key_sites(key),",
            "\t};",
            "",
            "\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {",
            "\t\tbool init = system_state < SYSTEM_RUNNING;",
            "\t\tstruct module *mod = site_mod->mod;",
            "",
            "\t\tif (!site_mod->sites) {",
            "\t\t\t/*",
            "\t\t\t * This can happen if the static call key is defined in",
            "\t\t\t * a module which doesn't use it.",
            "\t\t\t *",
            "\t\t\t * It also happens in the has_mods case, where the",
            "\t\t\t * 'first' entry has no sites associated with it.",
            "\t\t\t */",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tstop = __stop_static_call_sites;",
            "",
            "\t\tif (mod) {",
            "#ifdef CONFIG_MODULES",
            "\t\t\tstop = mod->static_call_sites +",
            "\t\t\t       mod->num_static_call_sites;",
            "\t\t\tinit = mod->state == MODULE_STATE_COMING;",
            "#endif",
            "\t\t}",
            "",
            "\t\tfor (site = site_mod->sites;",
            "\t\t     site < stop && static_call_key(site) == key; site++) {",
            "\t\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\t\tif (!init && static_call_is_init(site))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * This skips patching built-in __exit, which",
            "\t\t\t\t * is part of init_section_contains() but is",
            "\t\t\t\t * not part of kernel_text_address().",
            "\t\t\t\t *",
            "\t\t\t\t * Skipping built-in __exit is fine since it",
            "\t\t\t\t * will never be executed.",
            "\t\t\t\t */",
            "\t\t\t\tWARN_ONCE(!static_call_is_init(site),",
            "\t\t\t\t\t  \"can't patch static call site at %pS\",",
            "\t\t\t\t\t  site_addr);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tarch_static_call_transform(site_addr, NULL, func,",
            "\t\t\t\t\t\t   static_call_is_tail(site));",
            "\t\t}",
            "\t}",
            "",
            "done:",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "static_call_force_reinit, static_call_lock, static_call_unlock, __static_call_key, static_call_is_init, static_call_is_tail, static_call_set_init, static_call_site_cmp, static_call_site_swap, static_call_sort_entries, static_call_key_has_mods, __static_call_update",
          "description": "实现静态调用的互斥锁控制、键值计算、站点排序及更新逻辑，包含地址冲突检测和模块间调用关系维护功能。",
          "similarity": 0.5792120099067688
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 220,
          "end_line": 340,
          "content": [
            "static int __static_call_init(struct module *mod,",
            "\t\t\t      struct static_call_site *start,",
            "\t\t\t      struct static_call_site *stop)",
            "{",
            "\tstruct static_call_site *site;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod;",
            "",
            "\tif (start == stop)",
            "\t\treturn 0;",
            "",
            "\tstatic_call_sort_entries(start, stop);",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||",
            "\t\t    (!mod && init_section_contains(site_addr, 1)))",
            "\t\t\tstatic_call_set_init(site);",
            "",
            "\t\tkey = static_call_key(site);",
            "\t\tif (key != prev_key) {",
            "\t\t\tprev_key = key;",
            "",
            "\t\t\t/*",
            "\t\t\t * For vmlinux (!mod) avoid the allocation by storing",
            "\t\t\t * the sites pointer in the key itself. Also see",
            "\t\t\t * __static_call_update()'s @first.",
            "\t\t\t *",
            "\t\t\t * This allows architectures (eg. x86) to call",
            "\t\t\t * static_call_init() before memory allocation works.",
            "\t\t\t */",
            "\t\t\tif (!mod) {",
            "\t\t\t\tkey->sites = site;",
            "\t\t\t\tkey->type |= 1;",
            "\t\t\t\tgoto do_transform;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\tif (!site_mod)",
            "\t\t\t\treturn -ENOMEM;",
            "",
            "\t\t\t/*",
            "\t\t\t * When the key has a direct sites pointer, extract",
            "\t\t\t * that into an explicit struct static_call_mod, so we",
            "\t\t\t * can have a list of modules.",
            "\t\t\t */",
            "\t\t\tif (static_call_key_sites(key)) {",
            "\t\t\t\tsite_mod->mod = NULL;",
            "\t\t\t\tsite_mod->next = NULL;",
            "\t\t\t\tsite_mod->sites = static_call_key_sites(key);",
            "",
            "\t\t\t\tkey->mods = site_mod;",
            "",
            "\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\t\tif (!site_mod)",
            "\t\t\t\t\treturn -ENOMEM;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod->mod = mod;",
            "\t\t\tsite_mod->sites = site;",
            "\t\t\tsite_mod->next = static_call_key_next(key);",
            "\t\t\tkey->mods = site_mod;",
            "\t\t}",
            "",
            "do_transform:",
            "\t\tarch_static_call_transform(site_addr, NULL, key->func,",
            "\t\t\t\tstatic_call_is_tail(site));",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int addr_conflict(struct static_call_site *site, void *start, void *end)",
            "{",
            "\tunsigned long addr = (unsigned long)static_call_addr(site);",
            "",
            "\tif (addr <= (unsigned long)end &&",
            "\t    addr + CALL_INSN_SIZE > (unsigned long)start)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_text_reserved(struct static_call_site *iter_start,",
            "\t\t\t\t       struct static_call_site *iter_stop,",
            "\t\t\t\t       void *start, void *end, bool init)",
            "{",
            "\tstruct static_call_site *iter = iter_start;",
            "",
            "\twhile (iter < iter_stop) {",
            "\t\tif (init || !static_call_is_init(iter)) {",
            "\t\t\tif (addr_conflict(iter, start, end))",
            "\t\t\t\treturn 1;",
            "\t\t}",
            "\t\titer++;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\tstruct module *mod;",
            "\tint ret;",
            "",
            "\tpreempt_disable();",
            "\tmod = __module_text_address((unsigned long)start);",
            "\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);",
            "\tif (!try_module_get(mod))",
            "\t\tmod = NULL;",
            "\tpreempt_enable();",
            "",
            "\tif (!mod)",
            "\t\treturn 0;",
            "",
            "\tret = __static_call_text_reserved(mod->static_call_sites,",
            "\t\t\tmod->static_call_sites + mod->num_static_call_sites,",
            "\t\t\tstart, end, mod->state == MODULE_STATE_COMING);",
            "",
            "\tmodule_put(mod);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__static_call_init, addr_conflict, __static_call_text_reserved, __static_call_mod_text_reserved",
          "description": "执行静态调用初始化流程，分配模块关联结构体并进行地址转换，实现文本区域预留检查以避免内存覆盖。",
          "similarity": 0.5658028721809387
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/init.h>",
            "#include <linux/static_call.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/cpu.h>",
            "#include <linux/processor.h>",
            "#include <asm/sections.h>",
            "",
            "extern struct static_call_site __start_static_call_sites[],",
            "\t\t\t       __stop_static_call_sites[];",
            "extern struct static_call_tramp_key __start_static_call_tramp_key[],",
            "\t\t\t\t    __stop_static_call_tramp_key[];",
            "",
            "int static_call_initialized;",
            "",
            "/*",
            " * Must be called before early_initcall() to be effective.",
            " */"
          ],
          "function_name": null,
          "description": "声明静态调用相关的全局变量和外部符号，定义静态调用初始化标志位，为后续静态调用站点管理和地址转换提供基础结构。",
          "similarity": 0.5602535009384155
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 453,
          "end_line": 552,
          "content": [
            "static int static_call_module_notify(struct notifier_block *nb,",
            "\t\t\t\t     unsigned long val, void *data)",
            "{",
            "\tstruct module *mod = data;",
            "\tint ret = 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tswitch (val) {",
            "\tcase MODULE_STATE_COMING:",
            "\t\tret = static_call_add_module(mod);",
            "\t\tif (ret) {",
            "\t\t\tpr_warn(\"Failed to allocate memory for static calls\\n\");",
            "\t\t\tstatic_call_del_module(mod);",
            "\t\t}",
            "\t\tbreak;",
            "\tcase MODULE_STATE_GOING:",
            "\t\tstatic_call_del_module(mod);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\treturn notifier_from_errno(ret);",
            "}",
            "int klp_static_call_register(struct module *mod)",
            "{",
            "\tint ret;",
            "",
            "\tret = static_call_module_notify(&static_call_module_nb, MODULE_STATE_COMING, mod);",
            "\treturn notifier_to_errno(ret);",
            "}",
            "static inline int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\treturn 0;",
            "}",
            "int static_call_text_reserved(void *start, void *end)",
            "{",
            "\tbool init = system_state < SYSTEM_RUNNING;",
            "\tint ret = __static_call_text_reserved(__start_static_call_sites,",
            "\t\t\t__stop_static_call_sites, start, end, init);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn __static_call_mod_text_reserved(start, end);",
            "}",
            "int __init static_call_init(void)",
            "{",
            "\tint ret;",
            "",
            "\t/* See static_call_force_reinit(). */",
            "\tif (static_call_initialized == 1)",
            "\t\treturn 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "\tret = __static_call_init(NULL, __start_static_call_sites,",
            "\t\t\t\t __stop_static_call_sites);",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate memory for static_call!\\n\");",
            "\t\tBUG();",
            "\t}",
            "",
            "#ifdef CONFIG_MODULES",
            "\tif (!static_call_initialized)",
            "\t\tregister_module_notifier(&static_call_module_nb);",
            "#endif",
            "",
            "\tstatic_call_initialized = 1;",
            "\treturn 0;",
            "}",
            "static int func_a(int x)",
            "{",
            "\treturn x+1;",
            "}",
            "static int func_b(int x)",
            "{",
            "\treturn x+2;",
            "}",
            "static int __init test_static_call_init(void)",
            "{",
            "      int i;",
            "",
            "      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {",
            "\t      struct static_call_data *scd = &static_call_data[i];",
            "",
            "              if (scd->func)",
            "                      static_call_update(sc_selftest, scd->func);",
            "",
            "              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);",
            "      }",
            "",
            "      return 0;",
            "}"
          ],
          "function_name": "static_call_module_notify, klp_static_call_register, __static_call_mod_text_reserved, static_call_text_reserved, static_call_init, func_a, func_b, test_static_call_init",
          "description": "实现模块状态变更通知机制，完成静态调用系统的初始化注册，包含测试函数用于验证静态调用逻辑的正确性。",
          "similarity": 0.5590009093284607
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 347,
          "end_line": 449,
          "content": [
            "static unsigned long tramp_key_lookup(unsigned long addr)",
            "{",
            "\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *tramp_key;",
            "",
            "\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {",
            "\t\tunsigned long tramp;",
            "",
            "\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;",
            "\t\tif (tramp == addr)",
            "\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int static_call_add_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = start + mod->num_static_call_sites;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn 0;",
            "#endif",
            "",
            "\tfor (site = start; site != stop; site++) {",
            "\t\tunsigned long s_key = __static_call_key(site);",
            "\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;",
            "\t\tunsigned long key;",
            "",
            "\t\t/*",
            "\t\t * Is the key is exported, 'addr' points to the key, which",
            "\t\t * means modules are allowed to call static_call_update() on",
            "\t\t * it.",
            "\t\t *",
            "\t\t * Otherwise, the key isn't exported, and 'addr' points to the",
            "\t\t * trampoline so we need to lookup the key.",
            "\t\t *",
            "\t\t * We go through this dance to prevent crazy modules from",
            "\t\t * abusing sensitive static calls.",
            "\t\t */",
            "\t\tif (!kernel_text_address(addr))",
            "\t\t\tcontinue;",
            "",
            "\t\tkey = tramp_key_lookup(addr);",
            "\t\tif (!key) {",
            "\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",",
            "\t\t\t\tstatic_call_addr(site));",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;",
            "\t\tsite->key = key - (long)&site->key;",
            "\t}",
            "",
            "\treturn __static_call_init(mod, start, stop);",
            "}",
            "static void static_call_del_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = mod->static_call_sites +",
            "\t\t\t\t\tmod->num_static_call_sites;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod, **prev;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn;",
            "#endif",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tkey = static_call_key(site);",
            "",
            "\t\t/*",
            "\t\t * If the key was not updated due to a memory allocation",
            "\t\t * failure in __static_call_init() then treating key::sites",
            "\t\t * as key::mods in the code below would cause random memory",
            "\t\t * access and #GP. In that case all subsequent sites have",
            "\t\t * not been touched either, so stop iterating.",
            "\t\t */",
            "\t\tif (!static_call_key_has_mods(key))",
            "\t\t\tbreak;",
            "",
            "\t\tif (key == prev_key)",
            "\t\t\tcontinue;",
            "",
            "\t\tprev_key = key;",
            "",
            "\t\tfor (prev = &key->mods, site_mod = key->mods;",
            "\t\t     site_mod && site_mod->mod != mod;",
            "\t\t     prev = &site_mod->next, site_mod = site_mod->next)",
            "\t\t\t;",
            "",
            "\t\tif (!site_mod)",
            "\t\t\tcontinue;",
            "",
            "\t\t*prev = site_mod->next;",
            "\t\tkfree(site_mod);",
            "\t}",
            "}"
          ],
          "function_name": "tramp_key_lookup, static_call_add_module, static_call_del_module",
          "description": "处理模块动态加载/卸载时的静态调用更新，通过键查找机制确保跨模块调用正确性，并维护静态调用站点的模块绑定关系。",
          "similarity": 0.5273634195327759
        }
      ]
    },
    {
      "source_file": "kernel/irq/ipi-mux.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:57:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\ipi-mux.c`\n\n---\n\n# `irq/ipi-mux.c` 技术文档\n\n## 1. 文件概述\n\n`ipi-mux.c` 实现了一个虚拟 IPI（Inter-Processor Interrupt，处理器间中断）多路复用机制，允许多个逻辑 IPI 共享一个底层硬件 IPI。该机制通过软件方式在每个 CPU 上维护一个位图，记录哪些虚拟 IPI 处于挂起（pending）或使能（enabled）状态，并在需要时触发底层硬件 IPI。此设计适用于硬件 IPI 资源受限但需要支持多个逻辑 IPI 的系统架构（如某些 RISC-V 或定制 SoC 平台）。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct ipi_mux_cpu`**  \n  每个 CPU 的私有状态结构，包含两个原子变量：\n  - `enable`：表示当前 CPU 上哪些虚拟 IPI 已被使能（unmasked）。\n  - `bits`：表示当前 CPU 上哪些虚拟 IPI 处于挂起状态（pending）。\n\n- **全局变量**\n  - `ipi_mux_pcpu`：指向 per-CPU 的 `ipi_mux_cpu` 实例。\n  - `ipi_mux_domain`：指向虚拟 IPI 的 IRQ domain。\n  - `ipi_mux_send`：回调函数，用于向指定 CPU 发送底层硬件 IPI。\n\n### 主要函数\n\n- **`ipi_mux_mask()` / `ipi_mux_unmask()`**  \n  实现虚拟 IPI 的屏蔽与解除屏蔽逻辑，通过操作 `enable` 字段控制中断使能状态。\n\n- **`ipi_mux_send_mask()`**  \n  实现 `ipi_send_mask` 接口，用于向指定 CPU 集合发送特定虚拟 IPI。通过设置 `bits` 字段标记挂起状态，并在必要时触发底层 IPI。\n\n- **`ipi_mux_process()`**  \n  在底层 IPI 中断处理上下文中调用，读取并清除当前 CPU 的挂起虚拟 IPI 位图，并调用对应的中断处理程序。\n\n- **`ipi_mux_create()`**  \n  初始化整个虚拟 IPI 多路复用系统，包括分配 per-CPU 数据、创建 IRQ domain、分配虚拟 IRQ 号，并注册回调函数。\n\n### IRQ 芯片与 Domain 操作\n\n- **`ipi_mux_chip`**：定义了虚拟 IPI 的 `irq_chip` 操作集。\n- **`ipi_mux_domain_ops`**：定义了 IRQ domain 的分配与释放操作。\n\n## 3. 关键实现\n\n### 虚拟 IPI 状态管理\n\n每个 CPU 维护两个位图：\n- `enable`：记录哪些虚拟 IPI 当前被允许触发（即未被 mask）。\n- `bits`：记录哪些虚拟 IPI 已被请求但尚未处理（pending）。\n\n当调用 `ipi_send_mask()` 时，对应位被置入 `bits`；若该位同时在 `enable` 中置位，则立即触发底层 IPI。\n\n### 内存顺序与同步\n\n- 使用 `atomic_fetch_or_release()` 和 `smp_mb__after_atomic()` 确保：\n  - 对 `bits` 的写入在读取 `enable` 之前完成，避免与 `ipi_mux_unmask()` 竞争。\n  - 虚拟 IPI 标志的设置在触发底层 IPI 前对目标 CPU 可见。\n- 在 `ipi_mux_process()` 中使用 `atomic_fetch_andnot()` 原子地清除已使能且挂起的位，确保中断处理的精确性。\n\n### 中断处理流程\n\n1. 软件调用 `ipi_send_mask()` 发送虚拟 IPI。\n2. 目标 CPU 的 `bits` 对应位置位；若已使能，则调用 `ipi_mux_send()` 触发硬件 IPI。\n3. 硬件 IPI 到达后，调用 `ipi_mux_process()`。\n4. `ipi_mux_process()` 读取 `enable` 与 `bits`，计算需处理的虚拟 IPI 集合，并调用 `generic_handle_domain_irq()` 分发至对应处理函数。\n\n### IRQ Domain 管理\n\n- 使用线性 IRQ domain，虚拟 IPI 的 `hwirq` 编号从 0 开始连续分配。\n- 设置 `IRQ_DOMAIN_FLAG_IPI_SINGLE` 和 `DOMAIN_BUS_IPI` 标志，表明该 domain 专用于 IPI。\n- 每个虚拟 IPI 被配置为 per-CPU 中断（`irq_set_percpu_devid`），使用 `handle_percpu_devid_irq` 处理器。\n\n## 4. 依赖关系\n\n- **`<linux/irq.h>` / `<linux/irqdomain.h>`**：IRQ 子系统核心接口，用于注册 IRQ domain 和管理中断。\n- **`<linux/irqchip/chained_irq.h>`**：提供链式中断处理支持（虽未直接使用，但属于 IPI 架构上下文）。\n- **`<linux/percpu.h>`**：用于分配和访问 per-CPU 数据结构。\n- **`<linux/smp.h>` / `<linux/cpu.h>`**：SMP 相关功能，如 CPU 掩码遍历和处理器 ID 获取。\n- **`<linux/jump_label.h>`**：可能用于优化（当前未显式使用，但包含在头文件中）。\n- **底层平台代码**：必须提供 `mux_send` 回调函数，用于实际触发硬件 IPI。\n\n## 5. 使用场景\n\n- **硬件 IPI 资源受限的 SoC**：当物理 IPI 通道数量少于所需逻辑中断类型时（如仅 1 个硬件 IPI 但需支持 timer、reschedule、call-function 等多种 IPI），使用此机制进行软件复用。\n- **RISC-V 或定制架构平台**：如 Asahi Linux（Apple Silicon）或 Ventana Micro 的 RISC-V 实现，这些平台可能缺乏丰富的硬件 IPI 支持。\n- **内核 SMP 初始化阶段**：在 `ipi_mux_create()` 成功后，其他子系统（如调度器、RCU）可通过分配的虚拟 IPI 实现跨 CPU 通信。\n- **替代传统 IPI 向量机制**：在不支持多向量 IPI 的架构上，提供类似 x86 的多类型 IPI 功能。",
      "similarity": 0.5598108768463135,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/ipi-mux.c",
          "start_line": 29,
          "end_line": 176,
          "content": [
            "static void ipi_mux_mask(struct irq_data *d)",
            "{",
            "\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);",
            "",
            "\tatomic_andnot(BIT(irqd_to_hwirq(d)), &icpu->enable);",
            "}",
            "static void ipi_mux_unmask(struct irq_data *d)",
            "{",
            "\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);",
            "\tu32 ibit = BIT(irqd_to_hwirq(d));",
            "",
            "\tatomic_or(ibit, &icpu->enable);",
            "",
            "\t/*",
            "\t * The atomic_or() above must complete before the atomic_read()",
            "\t * below to avoid racing ipi_mux_send_mask().",
            "\t */",
            "\tsmp_mb__after_atomic();",
            "",
            "\t/* If a pending IPI was unmasked, raise a parent IPI immediately. */",
            "\tif (atomic_read(&icpu->bits) & ibit)",
            "\t\tipi_mux_send(smp_processor_id());",
            "}",
            "static void ipi_mux_send_mask(struct irq_data *d, const struct cpumask *mask)",
            "{",
            "\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);",
            "\tu32 ibit = BIT(irqd_to_hwirq(d));",
            "\tunsigned long pending;",
            "\tint cpu;",
            "",
            "\tfor_each_cpu(cpu, mask) {",
            "\t\ticpu = per_cpu_ptr(ipi_mux_pcpu, cpu);",
            "",
            "\t\t/*",
            "\t\t * This sequence is the mirror of the one in ipi_mux_unmask();",
            "\t\t * see the comment there. Additionally, release semantics",
            "\t\t * ensure that the vIPI flag set is ordered after any shared",
            "\t\t * memory accesses that precede it. This therefore also pairs",
            "\t\t * with the atomic_fetch_andnot in ipi_mux_process().",
            "\t\t */",
            "\t\tpending = atomic_fetch_or_release(ibit, &icpu->bits);",
            "",
            "\t\t/*",
            "\t\t * The atomic_fetch_or_release() above must complete",
            "\t\t * before the atomic_read() below to avoid racing with",
            "\t\t * ipi_mux_unmask().",
            "\t\t */",
            "\t\tsmp_mb__after_atomic();",
            "",
            "\t\t/*",
            "\t\t * The flag writes must complete before the physical IPI is",
            "\t\t * issued to another CPU. This is implied by the control",
            "\t\t * dependency on the result of atomic_read() below, which is",
            "\t\t * itself already ordered after the vIPI flag write.",
            "\t\t */",
            "\t\tif (!(pending & ibit) && (atomic_read(&icpu->enable) & ibit))",
            "\t\t\tipi_mux_send(cpu);",
            "\t}",
            "}",
            "static int ipi_mux_domain_alloc(struct irq_domain *d, unsigned int virq,",
            "\t\t\t\tunsigned int nr_irqs, void *arg)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < nr_irqs; i++) {",
            "\t\tirq_set_percpu_devid(virq + i);",
            "\t\tirq_domain_set_info(d, virq + i, i, &ipi_mux_chip, NULL,",
            "\t\t\t\t    handle_percpu_devid_irq, NULL, NULL);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void ipi_mux_process(void)",
            "{",
            "\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);",
            "\tirq_hw_number_t hwirq;",
            "\tunsigned long ipis;",
            "\tunsigned int en;",
            "",
            "\t/*",
            "\t * Reading enable mask does not need to be ordered as long as",
            "\t * this function is called from interrupt handler because only",
            "\t * the CPU itself can change it's own enable mask.",
            "\t */",
            "\ten = atomic_read(&icpu->enable);",
            "",
            "\t/*",
            "\t * Clear the IPIs we are about to handle. This pairs with the",
            "\t * atomic_fetch_or_release() in ipi_mux_send_mask().",
            "\t */",
            "\tipis = atomic_fetch_andnot(en, &icpu->bits) & en;",
            "",
            "\tfor_each_set_bit(hwirq, &ipis, BITS_PER_TYPE(int))",
            "\t\tgeneric_handle_domain_irq(ipi_mux_domain, hwirq);",
            "}",
            "int ipi_mux_create(unsigned int nr_ipi, void (*mux_send)(unsigned int cpu))",
            "{",
            "\tstruct fwnode_handle *fwnode;",
            "\tstruct irq_domain *domain;",
            "\tint rc;",
            "",
            "\tif (ipi_mux_domain)",
            "\t\treturn -EEXIST;",
            "",
            "\tif (BITS_PER_TYPE(int) < nr_ipi || !mux_send)",
            "\t\treturn -EINVAL;",
            "",
            "\tipi_mux_pcpu = alloc_percpu(typeof(*ipi_mux_pcpu));",
            "\tif (!ipi_mux_pcpu)",
            "\t\treturn -ENOMEM;",
            "",
            "\tfwnode = irq_domain_alloc_named_fwnode(\"IPI-Mux\");",
            "\tif (!fwnode) {",
            "\t\tpr_err(\"unable to create IPI Mux fwnode\\n\");",
            "\t\trc = -ENOMEM;",
            "\t\tgoto fail_free_cpu;",
            "\t}",
            "",
            "\tdomain = irq_domain_create_linear(fwnode, nr_ipi,",
            "\t\t\t\t\t  &ipi_mux_domain_ops, NULL);",
            "\tif (!domain) {",
            "\t\tpr_err(\"unable to add IPI Mux domain\\n\");",
            "\t\trc = -ENOMEM;",
            "\t\tgoto fail_free_fwnode;",
            "\t}",
            "",
            "\tdomain->flags |= IRQ_DOMAIN_FLAG_IPI_SINGLE;",
            "\tirq_domain_update_bus_token(domain, DOMAIN_BUS_IPI);",
            "",
            "\trc = irq_domain_alloc_irqs(domain, nr_ipi, NUMA_NO_NODE, NULL);",
            "\tif (rc <= 0) {",
            "\t\tpr_err(\"unable to alloc IRQs from IPI Mux domain\\n\");",
            "\t\tgoto fail_free_domain;",
            "\t}",
            "",
            "\tipi_mux_domain = domain;",
            "\tipi_mux_send = mux_send;",
            "",
            "\treturn rc;",
            "",
            "fail_free_domain:",
            "\tirq_domain_remove(domain);",
            "fail_free_fwnode:",
            "\tirq_domain_free_fwnode(fwnode);",
            "fail_free_cpu:",
            "\tfree_percpu(ipi_mux_pcpu);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "ipi_mux_mask, ipi_mux_unmask, ipi_mux_send_mask, ipi_mux_domain_alloc, ipi_mux_process, ipi_mux_create",
          "description": "实现了IPI多路复用器的核心逻辑，包括中断屏蔽/解除屏蔽操作、批量发送IPI标记、中断域分配、中断处理流程及初始化创建函数，通过原子操作和内存屏障保证跨CPU状态同步与顺序性。",
          "similarity": 0.5598106384277344
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/ipi-mux.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Multiplex several virtual IPIs over a single HW IPI.",
            " *",
            " * Copyright The Asahi Linux Contributors",
            " * Copyright (c) 2022 Ventana Micro Systems Inc.",
            " */",
            "",
            "#define pr_fmt(fmt) \"ipi-mux: \" fmt",
            "#include <linux/cpu.h>",
            "#include <linux/init.h>",
            "#include <linux/irq.h>",
            "#include <linux/irqchip.h>",
            "#include <linux/irqchip/chained_irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/percpu.h>",
            "#include <linux/smp.h>",
            "",
            "struct ipi_mux_cpu {",
            "\tatomic_t\t\t\tenable;",
            "\tatomic_t\t\t\tbits;",
            "};",
            "",
            "static struct ipi_mux_cpu __percpu *ipi_mux_pcpu;",
            "static struct irq_domain *ipi_mux_domain;",
            "static void (*ipi_mux_send)(unsigned int cpu);",
            ""
          ],
          "function_name": null,
          "description": "定义了用于多路复用虚拟IPI的CPU状态结构体ipi_mux_cpu，包含启用位掩码和位计数器。声明了全局的per-CPU指针数组ipi_mux_pcpu，中断域ipi_mux_domain，及发送回调函数指针ipi_mux_send。",
          "similarity": 0.5234491229057312
        }
      ]
    },
    {
      "source_file": "mm/process_vm_access.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:13:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `process_vm_access.c`\n\n---\n\n# `process_vm_access.c` 技术文档\n\n## 1. 文件概述\n\n`process_vm_access.c` 是 Linux 内核中实现跨进程虚拟内存读写功能的核心文件，提供了系统调用 `process_vm_readv` 和 `process_vm_writev` 的底层支持。该机制允许一个进程在无需目标进程协作的情况下，安全地从另一个进程中读取或向其写入数据，常用于调试器、容器运行时、性能分析工具等需要跨进程内存访问的场景。其实现基于内核的页表管理和用户页锁定（`pin_user_pages_remote`）机制，在保证安全性的同时避免了传统 `ptrace` 方式的上下文切换开销。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`process_vm_rw_pages`**  \n  执行实际的页面级内存拷贝操作，根据 `vm_write` 标志决定是将本地数据写入目标页（`copy_page_from_iter`）还是从目标页读取到本地（`copy_page_to_iter`）。\n\n- **`process_vm_rw_single_vec`**  \n  处理单个内存区域（由起始地址和长度定义）的读写操作。负责计算所需页数、通过 `pin_user_pages_remote` 锁定目标进程的物理页，并调用 `process_vm_rw_pages` 执行拷贝。\n\n- **`process_vm_rw_core`**  \n  核心调度函数，遍历远程进程的 iovec 数组（`rvec`），对每个内存段调用 `process_vm_rw_single_vec`。管理页指针数组的分配（栈上或动态）、目标进程查找（`find_get_task_by_vpid`）及内存描述符访问（`mm_access`）。\n\n- **`process_vm_rw`**  \n  系统调用入口的封装层，负责验证并导入用户态传入的本地（`lvec`）和远程（`rvec`）iovec 数组，初始化 `iov_iter` 迭代器，并调用 `process_vm_rw_core`。\n\n- **`SYSCALL_DEFINE6(process_vm_readv, ...)`**  \n  `process_vm_readv` 系统调用的定义（代码片段截断，但完整实现会在此处调用 `process_vm_rw` 并设置 `vm_write=0`）。\n\n- **`SYSCALL_DEFINE6(process_vm_writev, ...)`**  \n  （隐含存在）`process_vm_writev` 系统调用的定义，调用 `process_vm_rw` 并设置 `vm_write=1`。\n\n### 关键数据结构与常量\n\n- **`PVM_MAX_PP_ARRAY_COUNT`** (`16`)  \n  栈上预分配的 `struct page*` 数组的最大元素数量，用于存储待操作页的指针，避免小规模操作时的动态分配。\n\n- **`PVM_MAX_KMALLOC_PAGES`** (`PAGE_SIZE * 2`)  \n  动态分配 `struct page*` 数组时的最大内存限制（以字节计），确保 `kmalloc` 调用的可靠性。\n\n- **`iov_iter`**  \n  内核通用的 I/O 迭代器，用于高效遍历本地缓冲区（`lvec`）。\n\n## 3. 关键实现\n\n- **分页处理与批量锁定**：  \n  函数 `process_vm_rw_single_vec` 将大块内存访问拆分为多个页面批次处理。每批次最多处理 `PVM_MAX_KMALLOC_PAGES / sizeof(struct page*)` 个页，通过 `pin_user_pages_remote` 在目标进程的 `mm_struct` 上下文中锁定物理页，确保在拷贝期间页不会被换出或释放。\n\n- **内存安全与权限检查**：  \n  使用 `mm_access(task, PTRACE_MODE_ATTACH_REALCREDS)` 检查调用者是否有权访问目标进程的内存，该模式要求调用者具有 `CAP_SYS_PTRACE` 能力或满足 ptrace 附加条件。若返回 `-EACCES`，则转换为更合适的 `-EPERM` 错误码。\n\n- **资源管理与错误处理**：  \n  - 页指针数组优先使用栈空间（`pp_stack`），超出 `PVM_MAX_PP_ARRAY_COUNT` 时才动态分配。\n  - 拷贝过程中若发生部分成功（`total_len > 0`），即使后续出错也返回已成功传输的字节数。\n  - 使用 `unpin_user_pages_dirty_lock` 释放锁定的页，若为写操作（`vm_write=1`）则标记页为脏（`dirty`），确保修改能回写。\n\n- **I/O 向量化支持**：  \n  通过 `import_iovec` 和 `iovec_from_user` 处理用户态传入的分散/聚集 I/O 向量（iovec），支持非连续内存区域的高效批量传输。\n\n## 4. 依赖关系\n\n- **内存管理子系统 (`<linux/mm.h>`, `<linux/highmem.h>`)**：  \n  依赖 `pin_user_pages_remote`、`unpin_user_pages_dirty_lock`、`copy_page_to/from_iter` 等核心内存操作函数。\n  \n- **进程管理 (`<linux/sched.h>`, `<linux/sched/mm.h>`)**：  \n  使用 `find_get_task_by_vpid` 查找目标进程，`mm_access` 获取并验证其内存描述符。\n\n- **I/O 子系统 (`<linux/uio.h>`)**：  \n  基于 `iov_iter` 框架实现高效的 I/O 向量处理。\n\n- **系统调用接口 (`<linux/syscalls.h>`)**：  \n  通过 `SYSCALL_DEFINE6` 定义用户态可调用的系统调用入口。\n\n- **兼容层 (`<linux/compat.h>`)**：  \n  支持 32 位用户程序在 64 位内核上的调用（`in_compat_syscall()`）。\n\n- **安全框架 (`<linux/ptrace.h>`)**：  \n  复用 ptrace 的权限检查模型（`PTRACE_MODE_ATTACH_REALCREDS`）确保内存访问安全。\n\n## 5. 使用场景\n\n- **调试与监控工具**：  \n  如 `gdb`、`strace` 等工具通过 `process_vm_readv` 直接读取被调试进程的内存状态，避免频繁的 `ptrace` 陷入内核。\n\n- **容器与沙箱技术**：  \n  容器运行时（如 Docker、Kata Containers）利用此接口在不侵入容器内部的情况下，从宿主机读取或注入容器进程的内存数据。\n\n- **高性能进程间通信 (IPC)**：  \n  在特定场景下替代传统的管道、共享内存等 IPC 机制，实现零拷贝或低开销的跨进程数据交换。\n\n- **内核自检与故障注入**：  \n  内核测试框架可通过此接口模拟内存错误或验证进程内存布局。\n\n- **安全审计工具**：  \n  如 `auditd` 或自定义 LSM 模块，用于监控敏感进程的内存活动。",
      "similarity": 0.5594156980514526,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/process_vm_access.c",
          "start_line": 27,
          "end_line": 203,
          "content": [
            "static int process_vm_rw_pages(struct page **pages,",
            "\t\t\t       unsigned offset,",
            "\t\t\t       size_t len,",
            "\t\t\t       struct iov_iter *iter,",
            "\t\t\t       int vm_write)",
            "{",
            "\t/* Do the copy for each page */",
            "\twhile (len && iov_iter_count(iter)) {",
            "\t\tstruct page *page = *pages++;",
            "\t\tsize_t copy = PAGE_SIZE - offset;",
            "\t\tsize_t copied;",
            "",
            "\t\tif (copy > len)",
            "\t\t\tcopy = len;",
            "",
            "\t\tif (vm_write)",
            "\t\t\tcopied = copy_page_from_iter(page, offset, copy, iter);",
            "\t\telse",
            "\t\t\tcopied = copy_page_to_iter(page, offset, copy, iter);",
            "",
            "\t\tlen -= copied;",
            "\t\tif (copied < copy && iov_iter_count(iter))",
            "\t\t\treturn -EFAULT;",
            "\t\toffset = 0;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int process_vm_rw_single_vec(unsigned long addr,",
            "\t\t\t\t    unsigned long len,",
            "\t\t\t\t    struct iov_iter *iter,",
            "\t\t\t\t    struct page **process_pages,",
            "\t\t\t\t    struct mm_struct *mm,",
            "\t\t\t\t    struct task_struct *task,",
            "\t\t\t\t    int vm_write)",
            "{",
            "\tunsigned long pa = addr & PAGE_MASK;",
            "\tunsigned long start_offset = addr - pa;",
            "\tunsigned long nr_pages;",
            "\tssize_t rc = 0;",
            "\tunsigned long max_pages_per_loop = PVM_MAX_KMALLOC_PAGES",
            "\t\t/ sizeof(struct pages *);",
            "\tunsigned int flags = 0;",
            "",
            "\t/* Work out address and page range required */",
            "\tif (len == 0)",
            "\t\treturn 0;",
            "\tnr_pages = (addr + len - 1) / PAGE_SIZE - addr / PAGE_SIZE + 1;",
            "",
            "\tif (vm_write)",
            "\t\tflags |= FOLL_WRITE;",
            "",
            "\twhile (!rc && nr_pages && iov_iter_count(iter)) {",
            "\t\tint pinned_pages = min(nr_pages, max_pages_per_loop);",
            "\t\tint locked = 1;",
            "\t\tsize_t bytes;",
            "",
            "\t\t/*",
            "\t\t * Get the pages we're interested in.  We must",
            "\t\t * access remotely because task/mm might not",
            "\t\t * current/current->mm",
            "\t\t */",
            "\t\tmmap_read_lock(mm);",
            "\t\tpinned_pages = pin_user_pages_remote(mm, pa, pinned_pages,",
            "\t\t\t\t\t\t     flags, process_pages,",
            "\t\t\t\t\t\t     &locked);",
            "\t\tif (locked)",
            "\t\t\tmmap_read_unlock(mm);",
            "\t\tif (pinned_pages <= 0)",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbytes = pinned_pages * PAGE_SIZE - start_offset;",
            "\t\tif (bytes > len)",
            "\t\t\tbytes = len;",
            "",
            "\t\trc = process_vm_rw_pages(process_pages,",
            "\t\t\t\t\t start_offset, bytes, iter,",
            "\t\t\t\t\t vm_write);",
            "\t\tlen -= bytes;",
            "\t\tstart_offset = 0;",
            "\t\tnr_pages -= pinned_pages;",
            "\t\tpa += pinned_pages * PAGE_SIZE;",
            "",
            "\t\t/* If vm_write is set, the pages need to be made dirty: */",
            "\t\tunpin_user_pages_dirty_lock(process_pages, pinned_pages,",
            "\t\t\t\t\t    vm_write);",
            "\t}",
            "",
            "\treturn rc;",
            "}",
            "static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,",
            "\t\t\t\t  const struct iovec *rvec,",
            "\t\t\t\t  unsigned long riovcnt,",
            "\t\t\t\t  unsigned long flags, int vm_write)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];",
            "\tstruct page **process_pages = pp_stack;",
            "\tstruct mm_struct *mm;",
            "\tunsigned long i;",
            "\tssize_t rc = 0;",
            "\tunsigned long nr_pages = 0;",
            "\tunsigned long nr_pages_iov;",
            "\tssize_t iov_len;",
            "\tsize_t total_len = iov_iter_count(iter);",
            "",
            "\t/*",
            "\t * Work out how many pages of struct pages we're going to need",
            "\t * when eventually calling get_user_pages",
            "\t */",
            "\tfor (i = 0; i < riovcnt; i++) {",
            "\t\tiov_len = rvec[i].iov_len;",
            "\t\tif (iov_len > 0) {",
            "\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base",
            "\t\t\t\t\t+ iov_len)",
            "\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base",
            "\t\t\t\t/ PAGE_SIZE + 1;",
            "\t\t\tnr_pages = max(nr_pages, nr_pages_iov);",
            "\t\t}",
            "\t}",
            "",
            "\tif (nr_pages == 0)",
            "\t\treturn 0;",
            "",
            "\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {",
            "\t\t/* For reliability don't try to kmalloc more than",
            "\t\t   2 pages worth */",
            "\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,",
            "\t\t\t\t\t      sizeof(struct pages *)*nr_pages),",
            "\t\t\t\t\tGFP_KERNEL);",
            "",
            "\t\tif (!process_pages)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\t/* Get process information */",
            "\ttask = find_get_task_by_vpid(pid);",
            "\tif (!task) {",
            "\t\trc = -ESRCH;",
            "\t\tgoto free_proc_pages;",
            "\t}",
            "",
            "\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);",
            "\tif (!mm || IS_ERR(mm)) {",
            "\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;",
            "\t\t/*",
            "\t\t * Explicitly map EACCES to EPERM as EPERM is a more",
            "\t\t * appropriate error code for process_vw_readv/writev",
            "\t\t */",
            "\t\tif (rc == -EACCES)",
            "\t\t\trc = -EPERM;",
            "\t\tgoto put_task_struct;",
            "\t}",
            "",
            "\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)",
            "\t\trc = process_vm_rw_single_vec(",
            "\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,",
            "\t\t\titer, process_pages, mm, task, vm_write);",
            "",
            "\t/* copied = space before - space after */",
            "\ttotal_len -= iov_iter_count(iter);",
            "",
            "\t/* If we have managed to copy any data at all then",
            "\t   we return the number of bytes copied. Otherwise",
            "\t   we return the error code */",
            "\tif (total_len)",
            "\t\trc = total_len;",
            "",
            "\tmmput(mm);",
            "",
            "put_task_struct:",
            "\tput_task_struct(task);",
            "",
            "free_proc_pages:",
            "\tif (process_pages != pp_stack)",
            "\t\tkfree(process_pages);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "process_vm_rw_pages, process_vm_rw_single_vec, process_vm_rw_core",
          "description": "实现process_vm_rw_pages通过循环处理页面数据拷贝，process_vm_rw_single_vec获取远程页面并调用核心处理逻辑，process_vm_rw_core协调多进程地址范围映射与页面锁定操作",
          "similarity": 0.6084696054458618
        },
        {
          "chunk_id": 2,
          "file_path": "mm/process_vm_access.c",
          "start_line": 253,
          "end_line": 289,
          "content": [
            "static ssize_t process_vm_rw(pid_t pid,",
            "\t\t\t     const struct iovec __user *lvec,",
            "\t\t\t     unsigned long liovcnt,",
            "\t\t\t     const struct iovec __user *rvec,",
            "\t\t\t     unsigned long riovcnt,",
            "\t\t\t     unsigned long flags, int vm_write)",
            "{",
            "\tstruct iovec iovstack_l[UIO_FASTIOV];",
            "\tstruct iovec iovstack_r[UIO_FASTIOV];",
            "\tstruct iovec *iov_l = iovstack_l;",
            "\tstruct iovec *iov_r;",
            "\tstruct iov_iter iter;",
            "\tssize_t rc;",
            "\tint dir = vm_write ? ITER_SOURCE : ITER_DEST;",
            "",
            "\tif (flags != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Check iovecs */",
            "\trc = import_iovec(dir, lvec, liovcnt, UIO_FASTIOV, &iov_l, &iter);",
            "\tif (rc < 0)",
            "\t\treturn rc;",
            "\tif (!iov_iter_count(&iter))",
            "\t\tgoto free_iov_l;",
            "\tiov_r = iovec_from_user(rvec, riovcnt, UIO_FASTIOV, iovstack_r,",
            "\t\t\t\tin_compat_syscall());",
            "\tif (IS_ERR(iov_r)) {",
            "\t\trc = PTR_ERR(iov_r);",
            "\t\tgoto free_iov_l;",
            "\t}",
            "\trc = process_vm_rw_core(pid, &iter, iov_r, riovcnt, flags, vm_write);",
            "\tif (iov_r != iovstack_r)",
            "\t\tkfree(iov_r);",
            "free_iov_l:",
            "\tkfree(iov_l);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "process_vm_rw",
          "description": "实现process_vm_rw函数，整合用户态iovec数据到内核迭代器，通过import_iovec解析输入向量，调用核心处理流程完成跨进程内存读写操作",
          "similarity": 0.5684492588043213
        },
        {
          "chunk_id": 0,
          "file_path": "mm/process_vm_access.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * linux/mm/process_vm_access.c",
            " *",
            " * Copyright (C) 2010-2011 Christopher Yeoh <cyeoh@au1.ibm.com>, IBM Corp.",
            " */",
            "",
            "#include <linux/compat.h>",
            "#include <linux/mm.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "",
            "/**",
            " * process_vm_rw_pages - read/write pages from task specified",
            " * @pages: array of pointers to pages we want to copy",
            " * @offset: offset in page to start copying from/to",
            " * @len: number of bytes to copy",
            " * @iter: where to copy to/from locally",
            " * @vm_write: 0 means copy from, 1 means copy to",
            " * Returns 0 on success, error code otherwise",
            " */"
          ],
          "function_name": null,
          "description": "声明process_vm_rw_pages函数，用于从指定任务的页面进行读写操作，接受页面指针数组、偏移量、长度、迭代器及写标志，返回操作结果状态码",
          "similarity": 0.49743202328681946
        }
      ]
    }
  ]
}