{
  "query": "死锁检测中内存映射文件的使用场景",
  "timestamp": "2025-12-26 01:10:06",
  "retrieved_files": [
    {
      "source_file": "kernel/watchdog.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:51:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watchdog.c`\n\n---\n\n# watchdog.c 技术文档\n\n## 1. 文件概述\n\n`watchdog.c` 是 Linux 内核中实现 **硬锁死（hard lockup）** 和 **软锁死（soft lockup）** 检测机制的核心文件。该机制用于监控系统中 CPU 是否因长时间禁用中断或陷入无限循环而无法响应，从而帮助诊断系统挂死问题。硬锁死指 CPU 完全停止响应中断（包括 NMI），软锁死指内核线程长时间占用 CPU 且未调度其他任务。本文件主要聚焦于硬锁死检测的通用框架和部分实现，软锁死检测逻辑主要在其他文件（如 `softlockup.c`）中实现，但两者共享部分配置和控制逻辑。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `watchdog_enabled`：位掩码，表示当前启用的 watchdog 类型（软/硬锁死检测）。\n- `watchdog_user_enabled`：用户空间是否启用 watchdog（默认 1）。\n- `watchdog_hardlockup_user_enabled`：用户空间是否启用硬锁死检测（默认值取决于架构）。\n- `watchdog_softlockup_user_enabled`：用户空间是否启用软锁死检测（默认 1）。\n- `watchdog_thresh`：锁死检测阈值（秒，默认 10 秒）。\n- `watchdog_cpumask`：参与 watchdog 检测的 CPU 掩码。\n- `hardlockup_panic`：硬锁死发生时是否触发内核 panic（默认由 `CONFIG_BOOTPARAM_HARDLOCKUP_PANIC` 决定）。\n- `sysctl_hardlockup_all_cpu_backtrace`（SMP）：硬锁死时是否打印所有 CPU 的 backtrace。\n- `hardlockup_count`（SYSFS）：记录硬锁死事件发生次数。\n\n### 主要函数\n- `hardlockup_detector_disable(void)`：在启动早期禁用硬锁死检测（例如虚拟机环境）。\n- `hardlockup_panic_setup(char *str)`：解析内核启动参数 `nmi_watchdog=`，配置硬锁死行为。\n- `arch_touch_nmi_watchdog(void)`：架构相关函数，用于在关键路径“触摸”硬 watchdog，防止误报（导出符号）。\n- `watchdog_hardlockup_touch_cpu(unsigned int cpu)`：标记指定 CPU 已被“触摸”。\n- `is_hardlockup(unsigned int cpu)`：检查指定 CPU 是否发生硬锁死（基于高精度定时器中断计数）。\n- `watchdog_hardlockup_kick(void)`：在高精度定时器中断中“踢”硬 watchdog（更新中断计数）。\n- `watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs)`：执行硬锁死检测逻辑，打印诊断信息并可能触发 panic。\n- `watchdog_hardlockup_enable/disable(unsigned int cpu)`：弱符号函数，由具体硬 watchdog 实现（如 perf-based）覆盖，用于启停 per-CPU 检测。\n- `watchdog_hardlockup_probe(void)`：弱符号函数，由具体实现提供，用于探测硬 watchdog 硬件/机制是否可用。\n\n### 核心数据结构（Per-CPU）\n- `hrtimer_interrupts`：高精度定时器中断计数器（原子变量）。\n- `hrtimer_interrupts_saved`：上次保存的中断计数值。\n- `watchdog_hardlockup_warned`：是否已为该 CPU 打印过硬锁死警告。\n- `watchdog_hardlockup_touched`：该 CPU 是否被“触摸”过（用于豁免检测）。\n\n## 3. 关键实现\n\n### 硬锁死检测机制（基于高精度定时器）\n当配置 `CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER` 时，硬锁死检测通过监控 **高精度定时器（hrtimer）中断** 的发生频率实现：\n1. **计数更新**：每次 hrtimer 中断发生时，调用 `watchdog_hardlockup_kick()` 原子递增 per-CPU 计数器 `hrtimer_interrupts`。\n2. **检测逻辑**：在 NMI（不可屏蔽中断）上下文（或其他检测点）调用 `watchdog_hardlockup_check()`：\n   - 若 CPU 被“触摸”（`watchdog_hardlockup_touched` 为真），则清除此标记并跳过检测。\n   - 否则调用 `is_hardlockup()`：比较当前 `hrtimer_interrupts` 与上次保存值 `hrtimer_interrupts_saved`。若相等，说明在检测周期内无 hrtimer 中断，判定为硬锁死。\n3. **告警与处理**：\n   - 首次检测到硬锁死时，打印紧急日志（CPU 信息、模块列表、中断跟踪、寄存器状态或栈回溯）。\n   - 若启用 `sysctl_hardlockup_all_cpu_backtrace`，触发其他 CPU 的 backtrace。\n   - 若 `hardlockup_panic` 为真，调用 `nmi_panic()` 触发内核 panic。\n   - 设置 `watchdog_hardlockup_warned` 避免重复告警。\n\n### 启动参数与配置\n- **`nmi_watchdog=` 参数**：通过 `__setup` 宏注册，支持以下值：\n  - `panic`/`nopanic`：设置 `hardlockup_panic`。\n  - `0`/`1`：启用/禁用硬锁死检测。\n  - `r...`：传递参数给 perf-based 检测器（`hardlockup_config_perf_event`）。\n- **早期禁用**：`hardlockup_detector_disable()` 可在解析命令行前禁用硬检测（如 KVM guest）。\n\n### 架构交互与豁免\n- **`arch_touch_nmi_watchdog()`**：允许架构代码或关键内核路径（如 printk）临时豁免硬 watchdog 检测，防止在已知安全的长操作中误报。使用 `raw_cpu_write` 确保在抢占/中断使能环境下安全。\n\n### 弱符号扩展点\n- `watchdog_hardlockup_enable/disable/probe` 声明为 `__weak`，允许不同架构或检测方法（如基于 perf event 的 NMI watchdog）提供具体实现，实现检测机制的可插拔。\n\n## 4. 依赖关系\n\n- **内核子系统**：\n  - `<linux/nmi.h>`：NMI 处理框架，硬锁死检测通常在 NMI 上下文触发。\n  - `<linux/hrtimer.h>`（隐含）：高精度定时器中断作为检测心跳源。\n  - `<linux/sched/*.h>`：调度器相关（`print_irqtrace_events`, `dump_stack`）。\n  - `<linux/sysctl.h>`：提供 `sysctl_hardlockup_all_cpu_backtrace` 控制接口。\n  - `<linux/sysfs.h>`：暴露 `hardlockup_count` 到 sysfs。\n  - `<asm/irq_regs.h>`：获取中断上下文寄存器状态（`show_regs`）。\n- **配置选项**：\n  - `CONFIG_HARDLOCKUP_DETECTOR`：启用硬锁死检测框架。\n  - `CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER`：使用 hrtimer 中断计数实现检测。\n  - `CONFIG_HARDLOCKUP_DETECTOR_SPARC64`：SPARC64 架构默认启用硬检测。\n  - `CONFIG_BOOTPARAM_HARDLOCKUP_PANIC`：设置默认 panic 行为。\n  - `CONFIG_SMP`：多核支持（`all_cpu_backtrace` 功能）。\n  - `CONFIG_SYSFS`：sysfs 接口支持。\n- **其他模块**：依赖具体架构的 NMI 实现（如 x86 的 perf-based NMI watchdog）提供检测触发点。\n\n## 5. 使用场景\n\n- **系统稳定性监控**：在生产服务器或嵌入式设备中持续监控 CPU 响应性，及时发现硬件故障、驱动 bug 或内核死锁导致的系统挂死。\n- **内核调试**：开发人员通过 watchdog 触发的 backtrace 和寄存器转储，定位导致系统无响应的代码路径。\n- **虚拟化环境**：在 hypervisor guest 中可选择性禁用硬 watchdog（因虚拟化开销可能导致误报），通过 `hardlockup_detector_disable()` 或启动参数控制。\n- **实时系统**：结合 CPU 隔离（`isolcpus`）和 watchdog 配置，确保关键 CPU 核心的响应性，同时避免在非关键核上产生干扰。\n- **panic 策略**：通过 `hardlockup_panic` 配置，使系统在硬锁死时自动重启，提高无人值守系统的可用性。",
      "similarity": 0.6204476952552795,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/watchdog.c",
          "start_line": 73,
          "end_line": 217,
          "content": [
            "static ssize_t hardlockup_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\t     char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%u\\n\", hardlockup_count);",
            "}",
            "static __init int kernel_hardlockup_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &hardlockup_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "void __init hardlockup_detector_disable(void)",
            "{",
            "\twatchdog_hardlockup_user_enabled = 0;",
            "}",
            "static int __init hardlockup_panic_setup(char *str)",
            "{",
            "next:",
            "\tif (!strncmp(str, \"panic\", 5))",
            "\t\thardlockup_panic = 1;",
            "\telse if (!strncmp(str, \"nopanic\", 7))",
            "\t\thardlockup_panic = 0;",
            "\telse if (!strncmp(str, \"0\", 1))",
            "\t\twatchdog_hardlockup_user_enabled = 0;",
            "\telse if (!strncmp(str, \"1\", 1))",
            "\t\twatchdog_hardlockup_user_enabled = 1;",
            "\telse if (!strncmp(str, \"r\", 1))",
            "\t\thardlockup_config_perf_event(str + 1);",
            "\twhile (*(str++)) {",
            "\t\tif (*str == ',') {",
            "\t\t\tstr++;",
            "\t\t\tgoto next;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}",
            "notrace void arch_touch_nmi_watchdog(void)",
            "{",
            "\t/*",
            "\t * Using __raw here because some code paths have",
            "\t * preemption enabled.  If preemption is enabled",
            "\t * then interrupts should be enabled too, in which",
            "\t * case we shouldn't have to worry about the watchdog",
            "\t * going off.",
            "\t */",
            "\traw_cpu_write(watchdog_hardlockup_touched, true);",
            "}",
            "void watchdog_hardlockup_touch_cpu(unsigned int cpu)",
            "{",
            "\tper_cpu(watchdog_hardlockup_touched, cpu) = true;",
            "}",
            "static bool is_hardlockup(unsigned int cpu)",
            "{",
            "\tint hrint = atomic_read(&per_cpu(hrtimer_interrupts, cpu));",
            "",
            "\tif (per_cpu(hrtimer_interrupts_saved, cpu) == hrint)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * NOTE: we don't need any fancy atomic_t or READ_ONCE/WRITE_ONCE",
            "\t * for hrtimer_interrupts_saved. hrtimer_interrupts_saved is",
            "\t * written/read by a single CPU.",
            "\t */",
            "\tper_cpu(hrtimer_interrupts_saved, cpu) = hrint;",
            "",
            "\treturn false;",
            "}",
            "static void watchdog_hardlockup_kick(void)",
            "{",
            "\tint new_interrupts;",
            "",
            "\tnew_interrupts = atomic_inc_return(this_cpu_ptr(&hrtimer_interrupts));",
            "\twatchdog_buddy_check_hardlockup(new_interrupts);",
            "}",
            "void watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs)",
            "{",
            "\tif (per_cpu(watchdog_hardlockup_touched, cpu)) {",
            "\t\tper_cpu(watchdog_hardlockup_touched, cpu) = false;",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Check for a hardlockup by making sure the CPU's timer",
            "\t * interrupt is incrementing. The timer interrupt should have",
            "\t * fired multiple times before we overflow'd. If it hasn't",
            "\t * then this is a good indication the cpu is stuck",
            "\t */",
            "\tif (is_hardlockup(cpu)) {",
            "\t\tunsigned int this_cpu = smp_processor_id();",
            "\t\tunsigned long flags;",
            "",
            "#ifdef CONFIG_SYSFS",
            "\t\t++hardlockup_count;",
            "#endif",
            "",
            "\t\t/* Only print hardlockups once. */",
            "\t\tif (per_cpu(watchdog_hardlockup_warned, cpu))",
            "\t\t\treturn;",
            "",
            "\t\t/*",
            "\t\t * Prevent multiple hard-lockup reports if one cpu is already",
            "\t\t * engaged in dumping all cpu back traces.",
            "\t\t */",
            "\t\tif (sysctl_hardlockup_all_cpu_backtrace) {",
            "\t\t\tif (test_and_set_bit_lock(0, &hard_lockup_nmi_warn))",
            "\t\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * NOTE: we call printk_cpu_sync_get_irqsave() after printing",
            "\t\t * the lockup message. While it would be nice to serialize",
            "\t\t * that printout, we really want to make sure that if some",
            "\t\t * other CPU somehow locked up while holding the lock associated",
            "\t\t * with printk_cpu_sync_get_irqsave() that we can still at least",
            "\t\t * get the message about the lockup out.",
            "\t\t */",
            "\t\tpr_emerg(\"CPU%u: Watchdog detected hard LOCKUP on cpu %u\\n\", this_cpu, cpu);",
            "\t\tprintk_cpu_sync_get_irqsave(flags);",
            "",
            "\t\tprint_modules();",
            "\t\tprint_irqtrace_events(current);",
            "\t\tif (cpu == this_cpu) {",
            "\t\t\tif (regs)",
            "\t\t\t\tshow_regs(regs);",
            "\t\t\telse",
            "\t\t\t\tdump_stack();",
            "\t\t\tprintk_cpu_sync_put_irqrestore(flags);",
            "\t\t} else {",
            "\t\t\tprintk_cpu_sync_put_irqrestore(flags);",
            "\t\t\ttrigger_single_cpu_backtrace(cpu);",
            "\t\t}",
            "",
            "\t\tif (sysctl_hardlockup_all_cpu_backtrace) {",
            "\t\t\ttrigger_allbutcpu_cpu_backtrace(cpu);",
            "\t\t\tif (!hardlockup_panic)",
            "\t\t\t\tclear_bit_unlock(0, &hard_lockup_nmi_warn);",
            "\t\t}",
            "",
            "\t\tif (hardlockup_panic)",
            "\t\t\tnmi_panic(regs, \"Hard LOCKUP\");",
            "",
            "\t\tper_cpu(watchdog_hardlockup_warned, cpu) = true;",
            "\t} else {",
            "\t\tper_cpu(watchdog_hardlockup_warned, cpu) = false;",
            "\t}",
            "}"
          ],
          "function_name": "hardlockup_count_show, kernel_hardlockup_sysfs_init, hardlockup_detector_disable, hardlockup_panic_setup, arch_touch_nmi_watchdog, watchdog_hardlockup_touch_cpu, is_hardlockup, watchdog_hardlockup_kick, watchdog_hardlockup_check",
          "description": "实现硬锁检测核心逻辑，包含硬锁判断、计数统计、NMI触发电路及异常上报功能，通过中断计数器检测CPU卡顿。",
          "similarity": 0.6058289408683777
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watchdog.c",
          "start_line": 257,
          "end_line": 357,
          "content": [
            "static inline void watchdog_hardlockup_kick(void) { }",
            "void __weak watchdog_hardlockup_enable(unsigned int cpu) { }",
            "void __weak watchdog_hardlockup_disable(unsigned int cpu) { }",
            "int __weak __init watchdog_hardlockup_probe(void)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "void __weak watchdog_hardlockup_stop(void) { }",
            "void __weak watchdog_hardlockup_start(void) { }",
            "static void lockup_detector_update_enable(void)",
            "{",
            "\twatchdog_enabled = 0;",
            "\tif (!watchdog_user_enabled)",
            "\t\treturn;",
            "\tif (watchdog_hardlockup_available && watchdog_hardlockup_user_enabled)",
            "\t\twatchdog_enabled |= WATCHDOG_HARDLOCKUP_ENABLED;",
            "\tif (watchdog_softlockup_user_enabled)",
            "\t\twatchdog_enabled |= WATCHDOG_SOFTOCKUP_ENABLED;",
            "}",
            "static ssize_t softlockup_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t\t     char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%u\\n\", softlockup_count);",
            "}",
            "static __init int kernel_softlockup_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &softlockup_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "static int __init softlockup_panic_setup(char *str)",
            "{",
            "\tsoftlockup_panic = simple_strtoul(str, NULL, 0);",
            "\treturn 1;",
            "}",
            "static int __init nowatchdog_setup(char *str)",
            "{",
            "\twatchdog_user_enabled = 0;",
            "\treturn 1;",
            "}",
            "static int __init nosoftlockup_setup(char *str)",
            "{",
            "\twatchdog_softlockup_user_enabled = 0;",
            "\treturn 1;",
            "}",
            "static int __init watchdog_thresh_setup(char *str)",
            "{",
            "\tget_option(&str, &watchdog_thresh);",
            "\treturn 1;",
            "}",
            "static u16 get_16bit_precision(u64 data_ns)",
            "{",
            "\treturn data_ns >> 24LL; /* 2^24ns ~= 16.8ms */",
            "}",
            "static void update_cpustat(void)",
            "{",
            "\tint i;",
            "\tu8 util;",
            "\tu16 old_stat, new_stat;",
            "\tstruct kernel_cpustat kcpustat;",
            "\tu64 *cpustat = kcpustat.cpustat;",
            "\tu8 tail = __this_cpu_read(cpustat_tail);",
            "\tu16 sample_period_16 = get_16bit_precision(sample_period);",
            "",
            "\tkcpustat_cpu_fetch(&kcpustat, smp_processor_id());",
            "",
            "\tfor (i = 0; i < NUM_STATS_PER_GROUP; i++) {",
            "\t\told_stat = __this_cpu_read(cpustat_old[i]);",
            "\t\tnew_stat = get_16bit_precision(cpustat[tracked_stats[i]]);",
            "\t\tutil = DIV_ROUND_UP(100 * (new_stat - old_stat), sample_period_16);",
            "\t\t__this_cpu_write(cpustat_util[tail][i], util);",
            "\t\t__this_cpu_write(cpustat_old[i], new_stat);",
            "\t}",
            "",
            "\t__this_cpu_write(cpustat_tail, (tail + 1) % NUM_SAMPLE_PERIODS);",
            "}",
            "static void print_cpustat(void)",
            "{",
            "\tint i, group;",
            "\tu8 tail = __this_cpu_read(cpustat_tail);",
            "\tu64 sample_period_second = sample_period;",
            "",
            "\tdo_div(sample_period_second, NSEC_PER_SEC);",
            "",
            "\t/*",
            "\t * Outputting the \"watchdog\" prefix on every line is redundant and not",
            "\t * concise, and the original alarm information is sufficient for",
            "\t * positioning in logs, hence here printk() is used instead of pr_crit().",
            "\t */",
            "\tprintk(KERN_CRIT \"CPU#%d Utilization every %llus during lockup:\\n\",",
            "\t       smp_processor_id(), sample_period_second);",
            "",
            "\tfor (i = 0; i < NUM_SAMPLE_PERIODS; i++) {",
            "\t\tgroup = (tail + i) % NUM_SAMPLE_PERIODS;",
            "\t\tprintk(KERN_CRIT \"\\t#%d: %3u%% system,\\t%3u%% softirq,\\t\"",
            "\t\t\t\"%3u%% hardirq,\\t%3u%% idle\\n\", i + 1,",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_SYSTEM]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_SOFTIRQ]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_HARDIRQ]),",
            "\t\t\t__this_cpu_read(cpustat_util[group][STATS_IDLE]));",
            "\t}",
            "}"
          ],
          "function_name": "watchdog_hardlockup_kick, watchdog_hardlockup_enable, watchdog_hardlockup_disable, watchdog_hardlockup_probe, watchdog_hardlockup_stop, watchdog_hardlockup_start, lockup_detector_update_enable, softlockup_count_show, kernel_softlockup_sysfs_init, softlockup_panic_setup, nowatchdog_setup, nosoftlockup_setup, watchdog_thresh_setup, get_16bit_precision, update_cpustat, print_cpustat",
          "description": "提供软锁检测支持，包含统计周期设置、CPU利用率采集、中断事件追踪等辅助功能，维护软锁检测相关状态机。",
          "similarity": 0.5658522844314575
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/watchdog.c",
          "start_line": 626,
          "end_line": 802,
          "content": [
            "static void update_touch_ts(void)",
            "{",
            "\t__this_cpu_write(watchdog_touch_ts, get_timestamp());",
            "\tupdate_report_ts();",
            "}",
            "notrace void touch_softlockup_watchdog_sched(void)",
            "{",
            "\t/*",
            "\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog",
            "\t * report period gets restarted here, so use the raw_ operation.",
            "\t */",
            "\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);",
            "}",
            "notrace void touch_softlockup_watchdog(void)",
            "{",
            "\ttouch_softlockup_watchdog_sched();",
            "\twq_watchdog_touch(raw_smp_processor_id());",
            "}",
            "void touch_all_softlockup_watchdogs(void)",
            "{",
            "\tint cpu;",
            "",
            "\t/*",
            "\t * watchdog_mutex cannpt be taken here, as this might be called",
            "\t * from (soft)interrupt context, so the access to",
            "\t * watchdog_allowed_cpumask might race with a concurrent update.",
            "\t *",
            "\t * The watchdog time stamp can race against a concurrent real",
            "\t * update as well, the only side effect might be a cycle delay for",
            "\t * the softlockup check.",
            "\t */",
            "\tfor_each_cpu(cpu, &watchdog_allowed_mask) {",
            "\t\tper_cpu(watchdog_report_ts, cpu) = SOFTLOCKUP_DELAY_REPORT;",
            "\t\twq_watchdog_touch(cpu);",
            "\t}",
            "}",
            "void touch_softlockup_watchdog_sync(void)",
            "{",
            "\t__this_cpu_write(softlockup_touch_sync, true);",
            "\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);",
            "}",
            "static int is_softlockup(unsigned long touch_ts,",
            "\t\t\t unsigned long period_ts,",
            "\t\t\t unsigned long now)",
            "{",
            "\tif ((watchdog_enabled & WATCHDOG_SOFTOCKUP_ENABLED) && watchdog_thresh) {",
            "\t\t/*",
            "\t\t * If period_ts has not been updated during a sample_period, then",
            "\t\t * in the subsequent few sample_periods, period_ts might also not",
            "\t\t * be updated, which could indicate a potential softlockup. In",
            "\t\t * this case, if we suspect the cause of the potential softlockup",
            "\t\t * might be interrupt storm, then we need to count the interrupts",
            "\t\t * to find which interrupt is storming.",
            "\t\t */",
            "\t\tif (time_after_eq(now, period_ts + get_softlockup_thresh() / NUM_SAMPLE_PERIODS) &&",
            "\t\t    need_counting_irqs())",
            "\t\t\tstart_counting_irqs();",
            "",
            "\t\t/* Warn about unreasonable delays. */",
            "\t\tif (time_after(now, period_ts + get_softlockup_thresh()))",
            "\t\t\treturn now - touch_ts;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int softlockup_fn(void *data)",
            "{",
            "\tupdate_touch_ts();",
            "\tstop_counting_irqs();",
            "\tcomplete(this_cpu_ptr(&softlockup_completion));",
            "",
            "\treturn 0;",
            "}",
            "static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)",
            "{",
            "\tunsigned long touch_ts, period_ts, now;",
            "\tstruct pt_regs *regs = get_irq_regs();",
            "\tint duration;",
            "\tint softlockup_all_cpu_backtrace = sysctl_softlockup_all_cpu_backtrace;",
            "\tunsigned long flags;",
            "",
            "\tif (!watchdog_enabled)",
            "\t\treturn HRTIMER_NORESTART;",
            "",
            "\twatchdog_hardlockup_kick();",
            "",
            "\t/* kick the softlockup detector */",
            "\tif (completion_done(this_cpu_ptr(&softlockup_completion))) {",
            "\t\treinit_completion(this_cpu_ptr(&softlockup_completion));",
            "\t\tstop_one_cpu_nowait(smp_processor_id(),",
            "\t\t\t\tsoftlockup_fn, NULL,",
            "\t\t\t\tthis_cpu_ptr(&softlockup_stop_work));",
            "\t}",
            "",
            "\t/* .. and repeat */",
            "\thrtimer_forward_now(hrtimer, ns_to_ktime(sample_period));",
            "",
            "\t/*",
            "\t * Read the current timestamp first. It might become invalid anytime",
            "\t * when a virtual machine is stopped by the host or when the watchog",
            "\t * is touched from NMI.",
            "\t */",
            "\tnow = get_timestamp();",
            "\t/*",
            "\t * If a virtual machine is stopped by the host it can look to",
            "\t * the watchdog like a soft lockup. This function touches the watchdog.",
            "\t */",
            "\tkvm_check_and_clear_guest_paused();",
            "\t/*",
            "\t * The stored timestamp is comparable with @now only when not touched.",
            "\t * It might get touched anytime from NMI. Make sure that is_softlockup()",
            "\t * uses the same (valid) value.",
            "\t */",
            "\tperiod_ts = READ_ONCE(*this_cpu_ptr(&watchdog_report_ts));",
            "",
            "\tupdate_cpustat();",
            "",
            "\t/* Reset the interval when touched by known problematic code. */",
            "\tif (period_ts == SOFTLOCKUP_DELAY_REPORT) {",
            "\t\tif (unlikely(__this_cpu_read(softlockup_touch_sync))) {",
            "\t\t\t/*",
            "\t\t\t * If the time stamp was touched atomically",
            "\t\t\t * make sure the scheduler tick is up to date.",
            "\t\t\t */",
            "\t\t\t__this_cpu_write(softlockup_touch_sync, false);",
            "\t\t\tsched_clock_tick();",
            "\t\t}",
            "",
            "\t\tupdate_report_ts();",
            "\t\treturn HRTIMER_RESTART;",
            "\t}",
            "",
            "\t/* Check for a softlockup. */",
            "\ttouch_ts = __this_cpu_read(watchdog_touch_ts);",
            "\tduration = is_softlockup(touch_ts, period_ts, now);",
            "\tif (unlikely(duration)) {",
            "#ifdef CONFIG_SYSFS",
            "\t\t++softlockup_count;",
            "#endif",
            "",
            "\t\t/*",
            "\t\t * Prevent multiple soft-lockup reports if one cpu is already",
            "\t\t * engaged in dumping all cpu back traces.",
            "\t\t */",
            "\t\tif (softlockup_all_cpu_backtrace) {",
            "\t\t\tif (test_and_set_bit_lock(0, &soft_lockup_nmi_warn))",
            "\t\t\t\treturn HRTIMER_RESTART;",
            "\t\t}",
            "",
            "\t\t/* Start period for the next softlockup warning. */",
            "\t\tupdate_report_ts();",
            "",
            "\t\tprintk_cpu_sync_get_irqsave(flags);",
            "\t\tpr_emerg(\"BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\\n\",",
            "\t\t\tsmp_processor_id(), duration,",
            "\t\t\tcurrent->comm, task_pid_nr(current));",
            "\t\treport_cpu_status();",
            "\t\tprint_modules();",
            "\t\tprint_irqtrace_events(current);",
            "\t\tif (regs)",
            "\t\t\tshow_regs(regs);",
            "\t\telse",
            "\t\t\tdump_stack();",
            "\t\tprintk_cpu_sync_put_irqrestore(flags);",
            "",
            "\t\tif (softlockup_all_cpu_backtrace) {",
            "\t\t\ttrigger_allbutcpu_cpu_backtrace(smp_processor_id());",
            "\t\t\tif (!softlockup_panic)",
            "\t\t\t\tclear_bit_unlock(0, &soft_lockup_nmi_warn);",
            "\t\t}",
            "",
            "\t\tadd_taint(TAINT_SOFTLOCKUP, LOCKDEP_STILL_OK);",
            "\t\tif (softlockup_panic)",
            "\t\t\tpanic(\"softlockup: hung tasks\");",
            "\t}",
            "",
            "\treturn HRTIMER_RESTART;",
            "}"
          ],
          "function_name": "update_touch_ts, touch_softlockup_watchdog_sched, touch_softlockup_watchdog, touch_all_softlockup_watchdogs, touch_softlockup_watchdog_sync, is_softlockup, softlockup_fn, watchdog_timer_fn",
          "description": "处理软锁检测时序逻辑，包含超时判定算法、任务栈回溯触发机制及异常处理流程，协调硬件定时器与软件检测模块。",
          "similarity": 0.549204409122467
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/watchdog.c",
          "start_line": 1,
          "end_line": 72,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Detect hard and soft lockups on a system",
            " *",
            " * started by Don Zickus, Copyright (C) 2010 Red Hat, Inc.",
            " *",
            " * Note: Most of this code is borrowed heavily from the original softlockup",
            " * detector, so thanks to Ingo for the initial implementation.",
            " * Some chunks also taken from the old x86-specific nmi watchdog code, thanks",
            " * to those contributors as well.",
            " */",
            "",
            "#define pr_fmt(fmt) \"watchdog: \" fmt",
            "",
            "#include <linux/cpu.h>",
            "#include <linux/init.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/irq.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/math64.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/tick.h>",
            "",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/isolation.h>",
            "",
            "#include <asm/irq_regs.h>",
            "",
            "static DEFINE_MUTEX(watchdog_mutex);",
            "",
            "#if defined(CONFIG_HARDLOCKUP_DETECTOR) || defined(CONFIG_HARDLOCKUP_DETECTOR_SPARC64)",
            "# define WATCHDOG_HARDLOCKUP_DEFAULT\t1",
            "#else",
            "# define WATCHDOG_HARDLOCKUP_DEFAULT\t0",
            "#endif",
            "",
            "#define NUM_SAMPLE_PERIODS\t5",
            "",
            "unsigned long __read_mostly watchdog_enabled;",
            "int __read_mostly watchdog_user_enabled = 1;",
            "static int __read_mostly watchdog_hardlockup_user_enabled = WATCHDOG_HARDLOCKUP_DEFAULT;",
            "static int __read_mostly watchdog_softlockup_user_enabled = 1;",
            "int __read_mostly watchdog_thresh = 10;",
            "static int __read_mostly watchdog_thresh_next;",
            "static int __read_mostly watchdog_hardlockup_available;",
            "",
            "struct cpumask watchdog_cpumask __read_mostly;",
            "unsigned long *watchdog_cpumask_bits = cpumask_bits(&watchdog_cpumask);",
            "",
            "#ifdef CONFIG_HARDLOCKUP_DETECTOR",
            "",
            "# ifdef CONFIG_SMP",
            "int __read_mostly sysctl_hardlockup_all_cpu_backtrace;",
            "# endif /* CONFIG_SMP */",
            "",
            "/*",
            " * Should we panic when a soft-lockup or hard-lockup occurs:",
            " */",
            "unsigned int __read_mostly hardlockup_panic =",
            "\t\t\tIS_ENABLED(CONFIG_BOOTPARAM_HARDLOCKUP_PANIC);",
            "",
            "#ifdef CONFIG_SYSFS",
            "",
            "static unsigned int hardlockup_count;",
            ""
          ],
          "function_name": null,
          "description": "定义硬锁和软锁检测模块的全局变量及配置选项，初始化硬锁检测相关数据结构和默认启用状态。",
          "similarity": 0.5483648777008057
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/watchdog.c",
          "start_line": 494,
          "end_line": 595,
          "content": [
            "static void tabulate_irq_count(struct irq_counts *irq_counts, int irq, u32 counts, int rank)",
            "{",
            "\tint i;",
            "\tstruct irq_counts new_count = {irq, counts};",
            "",
            "\tfor (i = 0; i < rank; i++) {",
            "\t\tif (counts > irq_counts[i].counts)",
            "\t\t\tswap(new_count, irq_counts[i]);",
            "\t}",
            "}",
            "static bool need_counting_irqs(void)",
            "{",
            "\tu8 util;",
            "\tint tail = __this_cpu_read(cpustat_tail);",
            "",
            "\ttail = (tail + NUM_HARDIRQ_REPORT - 1) % NUM_HARDIRQ_REPORT;",
            "\tutil = __this_cpu_read(cpustat_util[tail][STATS_HARDIRQ]);",
            "\treturn util > HARDIRQ_PERCENT_THRESH;",
            "}",
            "static void start_counting_irqs(void)",
            "{",
            "\tif (!__this_cpu_read(snapshot_taken)) {",
            "\t\tkstat_snapshot_irqs();",
            "\t\t__this_cpu_write(snapshot_taken, true);",
            "\t}",
            "}",
            "static void stop_counting_irqs(void)",
            "{",
            "\t__this_cpu_write(snapshot_taken, false);",
            "}",
            "static void print_irq_counts(void)",
            "{",
            "\tunsigned int i, count;",
            "\tstruct irq_counts irq_counts_sorted[NUM_HARDIRQ_REPORT] = {",
            "\t\t{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}",
            "\t};",
            "",
            "\tif (__this_cpu_read(snapshot_taken)) {",
            "\t\tfor_each_active_irq(i) {",
            "\t\t\tcount = kstat_get_irq_since_snapshot(i);",
            "\t\t\ttabulate_irq_count(irq_counts_sorted, i, count, NUM_HARDIRQ_REPORT);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Outputting the \"watchdog\" prefix on every line is redundant and not",
            "\t\t * concise, and the original alarm information is sufficient for",
            "\t\t * positioning in logs, hence here printk() is used instead of pr_crit().",
            "\t\t */",
            "\t\tprintk(KERN_CRIT \"CPU#%d Detect HardIRQ Time exceeds %d%%. Most frequent HardIRQs:\\n\",",
            "\t\t       smp_processor_id(), HARDIRQ_PERCENT_THRESH);",
            "",
            "\t\tfor (i = 0; i < NUM_HARDIRQ_REPORT; i++) {",
            "\t\t\tif (irq_counts_sorted[i].irq == -1)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\tprintk(KERN_CRIT \"\\t#%u: %-10u\\tirq#%d\\n\",",
            "\t\t\t       i + 1, irq_counts_sorted[i].counts,",
            "\t\t\t       irq_counts_sorted[i].irq);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If the hardirq time is less than HARDIRQ_PERCENT_THRESH% in the last",
            "\t\t * sample_period, then we suspect the interrupt storm might be subsiding.",
            "\t\t */",
            "\t\tif (!need_counting_irqs())",
            "\t\t\tstop_counting_irqs();",
            "\t}",
            "}",
            "static void report_cpu_status(void)",
            "{",
            "\tprint_cpustat();",
            "\tprint_irq_counts();",
            "}",
            "static inline void update_cpustat(void) { }",
            "static inline void report_cpu_status(void) { }",
            "static inline bool need_counting_irqs(void) { return false; }",
            "static inline void start_counting_irqs(void) { }",
            "static inline void stop_counting_irqs(void) { }",
            "static int get_softlockup_thresh(void)",
            "{",
            "\treturn watchdog_thresh * 2;",
            "}",
            "static unsigned long get_timestamp(void)",
            "{",
            "\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */",
            "}",
            "static void set_sample_period(void)",
            "{",
            "\t/*",
            "\t * convert watchdog_thresh from seconds to ns",
            "\t * the divide by 5 is to give hrtimer several chances (two",
            "\t * or three with the current relation between the soft",
            "\t * and hard thresholds) to increment before the",
            "\t * hardlockup detector generates a warning",
            "\t */",
            "\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / NUM_SAMPLE_PERIODS);",
            "\twatchdog_update_hrtimer_threshold(sample_period);",
            "}",
            "static void update_report_ts(void)",
            "{",
            "\t__this_cpu_write(watchdog_report_ts, get_timestamp());",
            "}"
          ],
          "function_name": "tabulate_irq_count, need_counting_irqs, start_counting_irqs, stop_counting_irqs, print_irq_counts, report_cpu_status, update_cpustat, report_cpu_status, need_counting_irqs, start_counting_irqs, stop_counting_irqs, get_softlockup_thresh, get_timestamp, set_sample_period, update_report_ts",
          "description": "实现中断统计分析模块，通过记录中断次数分布识别潜在中断风暴，为软锁检测提供上下文信息。",
          "similarity": 0.5426404476165771
        }
      ]
    },
    {
      "source_file": "kernel/locking/test-ww_mutex.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:55:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\test-ww_mutex.c`\n\n---\n\n# `locking/test-ww_mutex.c` 技术文档\n\n## 1. 文件概述\n\n`test-ww_mutex.c` 是 Linux 内核中用于测试 **Wound/Wait 互斥锁（ww_mutex）** 机制的模块化单元测试文件。该文件通过模拟多种并发场景（如自锁、ABBA 死锁、循环死锁等），验证 ww_mutex 的正确性、互斥性以及死锁检测与恢复机制是否按预期工作。该测试模块主要用于内核开发和调试阶段，确保 ww_mutex 的实现符合设计规范。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct test_mutex`  \n  用于测试基本互斥行为的结构体，包含工作项、ww_mutex、完成量（completion）和测试标志。\n\n- `struct test_abba`  \n  用于模拟 ABBA 死锁场景的结构体，包含两个 ww_mutex、完成量、解析标志、trylock 标志及结果。\n\n- `struct test_cycle`  \n  用于测试多线程循环依赖死锁场景的结构体，支持 N 个线程形成环形依赖。\n\n- `ww_class`  \n  全局定义的 `ww_class`，用于标识 ww_mutex 所属的锁类，是 ww_mutex 正常工作的必要条件。\n\n### 主要函数\n\n- `test_mutex_work()`  \n  工作队列回调函数，执行 ww_mutex 的加锁/尝试加锁操作。\n\n- `__test_mutex()` / `test_mutex()`  \n  测试基本互斥语义，覆盖多种标志组合（自旋、trylock、带上下文等）。\n\n- `test_aa()`  \n  测试同一上下文对同一 ww_mutex 的重复加锁行为，验证 `-EALREADY` 返回值。\n\n- `test_abba_work()` / `test_abba()`  \n  测试经典的 ABBA 死锁场景，支持是否启用死锁解析（resolve）。\n\n- `test_cycle_work()` / `__test_cycle()`  \n  测试 N 线程环形依赖死锁，并验证 ww_mutex 的死锁自动解析能力。\n\n## 3. 关键实现\n\n### Wound/Wait 机制测试\n\n- 所有测试均基于 `ww_acquire_ctx` 上下文进行加锁，确保符合 ww_mutex 的使用规范。\n- 通过 `ww_mutex_lock()` 和 `ww_mutex_trylock()` 的组合，验证不同加锁路径的行为一致性。\n\n### 死锁检测与解析\n\n- 在 `test_abba()` 和 `__test_cycle()` 中，当检测到 `-EDEADLK` 时，主动调用 `ww_mutex_unlock()` 释放已持有锁，再通过 `ww_mutex_lock_slow()` 重新按顺序获取锁，模拟死锁恢复流程。\n- `test_abba()` 支持两种模式：  \n  - **不解析**：期望两个线程均返回 `-EDEADLK`；  \n  - **解析**：期望死锁被成功解除，返回 0。\n\n### 防止测试干扰\n\n- 使用 `CONFIG_DEBUG_WW_MUTEX_SLOWPATH` 宏控制是否禁用死锁注入（`deadlock_inject_countdown = ~0U`），确保测试结果可复现。\n- 所有工作项均使用 `INIT_WORK_ONSTACK` 初始化，并在测试结束时调用 `destroy_work_on_stack()`，避免内存泄漏。\n\n### 超时与同步机制\n\n- 使用 `completion` 机制协调主线程与工作线程的执行顺序。\n- 设置 `TIMEOUT = HZ / 16` 作为最大等待时间，防止测试挂起。\n- 在 `TEST_MTX_SPIN` 模式下，主动轮询完成状态并调用 `cond_resched()`，避免软死锁。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ww_mutex.h>`：提供 ww_mutex 核心 API。\n  - `<linux/completion.h>`、`<linux/workqueue.h>`：用于线程同步与调度。\n  - `<linux/kthread.h>`、`<linux/slab.h>`：支持动态内存分配与内核线程。\n  - `<linux/prandom.h>`：虽未直接使用，但为潜在扩展预留。\n\n- **内核配置依赖**：\n  - 依赖 `CONFIG_WW_MUTEX` 编译选项。\n  - 调试模式下依赖 `CONFIG_DEBUG_WW_MUTEX_SLOWPATH`。\n\n- **运行时依赖**：\n  - 使用全局工作队列 `wq`（在文件外初始化），用于并发执行测试任务。\n\n## 5. 使用场景\n\n- **内核开发与回归测试**：在修改 ww_mutex 实现后，运行此模块验证功能正确性。\n- **死锁行为验证**：用于确认 ww_mutex 能正确检测并处理 ABBA、循环依赖等复杂死锁。\n- **API 兼容性测试**：确保 `ww_mutex_lock`、`ww_mutex_trylock`、`ww_mutex_lock_slow` 等接口行为符合预期。\n- **调试辅助**：当系统出现 ww_mutex 相关死锁时，可参考此测试逻辑复现问题。",
      "similarity": 0.6092982292175293,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/test-ww_mutex.c",
          "start_line": 186,
          "end_line": 302,
          "content": [
            "static void test_abba_work(struct work_struct *work)",
            "{",
            "\tstruct test_abba *abba = container_of(work, typeof(*abba), work);",
            "\tstruct ww_acquire_ctx ctx;",
            "\tint err;",
            "",
            "\tww_acquire_init_noinject(&ctx, &ww_class);",
            "\tif (!abba->trylock)",
            "\t\tww_mutex_lock(&abba->b_mutex, &ctx);",
            "\telse",
            "\t\tWARN_ON(!ww_mutex_trylock(&abba->b_mutex, &ctx));",
            "",
            "\tWARN_ON(READ_ONCE(abba->b_mutex.ctx) != &ctx);",
            "",
            "\tcomplete(&abba->b_ready);",
            "\twait_for_completion(&abba->a_ready);",
            "",
            "\terr = ww_mutex_lock(&abba->a_mutex, &ctx);",
            "\tif (abba->resolve && err == -EDEADLK) {",
            "\t\tww_mutex_unlock(&abba->b_mutex);",
            "\t\tww_mutex_lock_slow(&abba->a_mutex, &ctx);",
            "\t\terr = ww_mutex_lock(&abba->b_mutex, &ctx);",
            "\t}",
            "",
            "\tif (!err)",
            "\t\tww_mutex_unlock(&abba->a_mutex);",
            "\tww_mutex_unlock(&abba->b_mutex);",
            "\tww_acquire_fini(&ctx);",
            "",
            "\tabba->result = err;",
            "}",
            "static int test_abba(bool trylock, bool resolve)",
            "{",
            "\tstruct test_abba abba;",
            "\tstruct ww_acquire_ctx ctx;",
            "\tint err, ret;",
            "",
            "\tww_mutex_init(&abba.a_mutex, &ww_class);",
            "\tww_mutex_init(&abba.b_mutex, &ww_class);",
            "\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);",
            "\tinit_completion(&abba.a_ready);",
            "\tinit_completion(&abba.b_ready);",
            "\tabba.trylock = trylock;",
            "\tabba.resolve = resolve;",
            "",
            "\tschedule_work(&abba.work);",
            "",
            "\tww_acquire_init_noinject(&ctx, &ww_class);",
            "\tif (!trylock)",
            "\t\tww_mutex_lock(&abba.a_mutex, &ctx);",
            "\telse",
            "\t\tWARN_ON(!ww_mutex_trylock(&abba.a_mutex, &ctx));",
            "",
            "\tWARN_ON(READ_ONCE(abba.a_mutex.ctx) != &ctx);",
            "",
            "\tcomplete(&abba.a_ready);",
            "\twait_for_completion(&abba.b_ready);",
            "",
            "\terr = ww_mutex_lock(&abba.b_mutex, &ctx);",
            "\tif (resolve && err == -EDEADLK) {",
            "\t\tww_mutex_unlock(&abba.a_mutex);",
            "\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);",
            "\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);",
            "\t}",
            "",
            "\tif (!err)",
            "\t\tww_mutex_unlock(&abba.b_mutex);",
            "\tww_mutex_unlock(&abba.a_mutex);",
            "\tww_acquire_fini(&ctx);",
            "",
            "\tflush_work(&abba.work);",
            "\tdestroy_work_on_stack(&abba.work);",
            "",
            "\tret = 0;",
            "\tif (resolve) {",
            "\t\tif (err || abba.result) {",
            "\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",",
            "\t\t\t       __func__, err, abba.result);",
            "\t\t\tret = -EINVAL;",
            "\t\t}",
            "\t} else {",
            "\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {",
            "\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",",
            "\t\t\t       __func__, err, abba.result);",
            "\t\t\tret = -EINVAL;",
            "\t\t}",
            "\t}",
            "\treturn ret;",
            "}",
            "static void test_cycle_work(struct work_struct *work)",
            "{",
            "\tstruct test_cycle *cycle = container_of(work, typeof(*cycle), work);",
            "\tstruct ww_acquire_ctx ctx;",
            "\tint err, erra = 0;",
            "",
            "\tww_acquire_init_noinject(&ctx, &ww_class);",
            "\tww_mutex_lock(&cycle->a_mutex, &ctx);",
            "",
            "\tcomplete(cycle->a_signal);",
            "\twait_for_completion(&cycle->b_signal);",
            "",
            "\terr = ww_mutex_lock(cycle->b_mutex, &ctx);",
            "\tif (err == -EDEADLK) {",
            "\t\terr = 0;",
            "\t\tww_mutex_unlock(&cycle->a_mutex);",
            "\t\tww_mutex_lock_slow(cycle->b_mutex, &ctx);",
            "\t\terra = ww_mutex_lock(&cycle->a_mutex, &ctx);",
            "\t}",
            "",
            "\tif (!err)",
            "\t\tww_mutex_unlock(cycle->b_mutex);",
            "\tif (!erra)",
            "\t\tww_mutex_unlock(&cycle->a_mutex);",
            "\tww_acquire_fini(&ctx);",
            "",
            "\tcycle->result = err ?: erra;",
            "}"
          ],
          "function_name": "test_abba_work, test_abba, test_cycle_work",
          "description": "测试ABBA死锁场景及环形依赖问题，通过交替顺序加锁模拟死锁条件，验证系统能否检测并解除死锁状态",
          "similarity": 0.6396048665046692
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/test-ww_mutex.c",
          "start_line": 40,
          "end_line": 171,
          "content": [
            "static void test_mutex_work(struct work_struct *work)",
            "{",
            "\tstruct test_mutex *mtx = container_of(work, typeof(*mtx), work);",
            "",
            "\tcomplete(&mtx->ready);",
            "\twait_for_completion(&mtx->go);",
            "",
            "\tif (mtx->flags & TEST_MTX_TRY) {",
            "\t\twhile (!ww_mutex_trylock(&mtx->mutex, NULL))",
            "\t\t\tcond_resched();",
            "\t} else {",
            "\t\tww_mutex_lock(&mtx->mutex, NULL);",
            "\t}",
            "\tcomplete(&mtx->done);",
            "\tww_mutex_unlock(&mtx->mutex);",
            "}",
            "static int __test_mutex(unsigned int flags)",
            "{",
            "#define TIMEOUT (HZ / 16)",
            "\tstruct test_mutex mtx;",
            "\tstruct ww_acquire_ctx ctx;",
            "\tint ret;",
            "",
            "\tww_mutex_init(&mtx.mutex, &ww_class);",
            "\tww_acquire_init(&ctx, &ww_class);",
            "",
            "\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);",
            "\tinit_completion(&mtx.ready);",
            "\tinit_completion(&mtx.go);",
            "\tinit_completion(&mtx.done);",
            "\tmtx.flags = flags;",
            "",
            "\tschedule_work(&mtx.work);",
            "",
            "\twait_for_completion(&mtx.ready);",
            "\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);",
            "\tcomplete(&mtx.go);",
            "\tif (flags & TEST_MTX_SPIN) {",
            "\t\tunsigned long timeout = jiffies + TIMEOUT;",
            "",
            "\t\tret = 0;",
            "\t\tdo {",
            "\t\t\tif (completion_done(&mtx.done)) {",
            "\t\t\t\tret = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tcond_resched();",
            "\t\t} while (time_before(jiffies, timeout));",
            "\t} else {",
            "\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);",
            "\t}",
            "\tww_mutex_unlock(&mtx.mutex);",
            "\tww_acquire_fini(&ctx);",
            "",
            "\tif (ret) {",
            "\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",",
            "\t\t       __func__, flags);",
            "\t\tret = -EINVAL;",
            "\t}",
            "",
            "\tflush_work(&mtx.work);",
            "\tdestroy_work_on_stack(&mtx.work);",
            "\treturn ret;",
            "#undef TIMEOUT",
            "}",
            "static int test_mutex(void)",
            "{",
            "\tint ret;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < __TEST_MTX_LAST; i++) {",
            "\t\tret = __test_mutex(i);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int test_aa(bool trylock)",
            "{",
            "\tstruct ww_mutex mutex;",
            "\tstruct ww_acquire_ctx ctx;",
            "\tint ret;",
            "\tconst char *from = trylock ? \"trylock\" : \"lock\";",
            "",
            "\tww_mutex_init(&mutex, &ww_class);",
            "\tww_acquire_init(&ctx, &ww_class);",
            "",
            "\tif (!trylock) {",
            "\t\tret = ww_mutex_lock(&mutex, &ctx);",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"%s: initial lock failed!\\n\", __func__);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t} else {",
            "\t\tret = !ww_mutex_trylock(&mutex, &ctx);",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"%s: initial trylock failed!\\n\", __func__);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (ww_mutex_trylock(&mutex, NULL))  {",
            "\t\tpr_err(\"%s: trylocked itself without context from %s!\\n\", __func__, from);",
            "\t\tww_mutex_unlock(&mutex);",
            "\t\tret = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (ww_mutex_trylock(&mutex, &ctx))  {",
            "\t\tpr_err(\"%s: trylocked itself with context from %s!\\n\", __func__, from);",
            "\t\tww_mutex_unlock(&mutex);",
            "\t\tret = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = ww_mutex_lock(&mutex, &ctx);",
            "\tif (ret != -EALREADY) {",
            "\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d from %s\\n\",",
            "\t\t       __func__, ret, from);",
            "\t\tif (!ret)",
            "\t\t\tww_mutex_unlock(&mutex);",
            "\t\tret = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tww_mutex_unlock(&mutex);",
            "\tret = 0;",
            "out:",
            "\tww_acquire_fini(&ctx);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "test_mutex_work, __test_mutex, test_mutex, test_aa",
          "description": "实现ww_mutex的多种测试场景，包括尝试加锁、死锁检测、递归锁冲突验证，通过工作队列模拟并发操作并校验互斥行为",
          "similarity": 0.6347489356994629
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/locking/test-ww_mutex.c",
          "start_line": 315,
          "end_line": 444,
          "content": [
            "static int __test_cycle(unsigned int nthreads)",
            "{",
            "\tstruct test_cycle *cycles;",
            "\tunsigned int n, last = nthreads - 1;",
            "\tint ret;",
            "",
            "\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);",
            "\tif (!cycles)",
            "\t\treturn -ENOMEM;",
            "",
            "\tfor (n = 0; n < nthreads; n++) {",
            "\t\tstruct test_cycle *cycle = &cycles[n];",
            "",
            "\t\tww_mutex_init(&cycle->a_mutex, &ww_class);",
            "\t\tif (n == last)",
            "\t\t\tcycle->b_mutex = &cycles[0].a_mutex;",
            "\t\telse",
            "\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;",
            "",
            "\t\tif (n == 0)",
            "\t\t\tcycle->a_signal = &cycles[last].b_signal;",
            "\t\telse",
            "\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;",
            "\t\tinit_completion(&cycle->b_signal);",
            "",
            "\t\tINIT_WORK(&cycle->work, test_cycle_work);",
            "\t\tcycle->result = 0;",
            "\t}",
            "",
            "\tfor (n = 0; n < nthreads; n++)",
            "\t\tqueue_work(wq, &cycles[n].work);",
            "",
            "\tflush_workqueue(wq);",
            "",
            "\tret = 0;",
            "\tfor (n = 0; n < nthreads; n++) {",
            "\t\tstruct test_cycle *cycle = &cycles[n];",
            "",
            "\t\tif (!cycle->result)",
            "\t\t\tcontinue;",
            "",
            "\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",",
            "\t\t       n, nthreads, cycle->result);",
            "\t\tret = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tfor (n = 0; n < nthreads; n++)",
            "\t\tww_mutex_destroy(&cycles[n].a_mutex);",
            "\tkfree(cycles);",
            "\treturn ret;",
            "}",
            "static int test_cycle(unsigned int ncpus)",
            "{",
            "\tunsigned int n;",
            "\tint ret;",
            "",
            "\tfor (n = 2; n <= ncpus + 1; n++) {",
            "\t\tret = __test_cycle(n);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline u32 prandom_u32_below(u32 ceil)",
            "{",
            "\tu32 ret;",
            "",
            "\tspin_lock(&rng_lock);",
            "\tret = prandom_u32_state(&rng) % ceil;",
            "\tspin_unlock(&rng_lock);",
            "\treturn ret;",
            "}",
            "static void dummy_load(struct stress *stress)",
            "{",
            "\tusleep_range(1000, 2000);",
            "}",
            "static void stress_inorder_work(struct work_struct *work)",
            "{",
            "\tstruct stress *stress = container_of(work, typeof(*stress), work);",
            "\tconst int nlocks = stress->nlocks;",
            "\tstruct ww_mutex *locks = stress->locks;",
            "\tstruct ww_acquire_ctx ctx;",
            "\tint *order;",
            "",
            "\torder = get_random_order(nlocks);",
            "\tif (!order)",
            "\t\treturn;",
            "",
            "\tdo {",
            "\t\tint contended = -1;",
            "\t\tint n, err;",
            "",
            "\t\tww_acquire_init(&ctx, &ww_class);",
            "retry:",
            "\t\terr = 0;",
            "\t\tfor (n = 0; n < nlocks; n++) {",
            "\t\t\tif (n == contended)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\terr = ww_mutex_lock(&locks[order[n]], &ctx);",
            "\t\t\tif (err < 0)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (!err)",
            "\t\t\tdummy_load(stress);",
            "",
            "\t\tif (contended > n)",
            "\t\t\tww_mutex_unlock(&locks[order[contended]]);",
            "\t\tcontended = n;",
            "\t\twhile (n--)",
            "\t\t\tww_mutex_unlock(&locks[order[n]]);",
            "",
            "\t\tif (err == -EDEADLK) {",
            "\t\t\tww_mutex_lock_slow(&locks[order[contended]], &ctx);",
            "\t\t\tgoto retry;",
            "\t\t}",
            "",
            "\t\tif (err) {",
            "\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",",
            "\t\t\t\t    __func__, err);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tww_acquire_fini(&ctx);",
            "\t} while (!time_after(jiffies, stress->timeout));",
            "",
            "\tkfree(order);",
            "}"
          ],
          "function_name": "__test_cycle, test_cycle, prandom_u32_below, dummy_load, stress_inorder_work",
          "description": "执行多线程环形死锁测试，动态分配资源并模拟复杂锁竞争场景，包含随机数生成和负载控制机制",
          "similarity": 0.6212573051452637
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/locking/test-ww_mutex.c",
          "start_line": 489,
          "end_line": 629,
          "content": [
            "static void stress_reorder_work(struct work_struct *work)",
            "{",
            "\tstruct stress *stress = container_of(work, typeof(*stress), work);",
            "\tLIST_HEAD(locks);",
            "\tstruct ww_acquire_ctx ctx;",
            "\tstruct reorder_lock *ll, *ln;",
            "\tint *order;",
            "\tint n, err;",
            "",
            "\torder = get_random_order(stress->nlocks);",
            "\tif (!order)",
            "\t\treturn;",
            "",
            "\tfor (n = 0; n < stress->nlocks; n++) {",
            "\t\tll = kmalloc(sizeof(*ll), GFP_KERNEL);",
            "\t\tif (!ll)",
            "\t\t\tgoto out;",
            "",
            "\t\tll->lock = &stress->locks[order[n]];",
            "\t\tlist_add(&ll->link, &locks);",
            "\t}",
            "\tkfree(order);",
            "\torder = NULL;",
            "",
            "\tdo {",
            "\t\tww_acquire_init(&ctx, &ww_class);",
            "",
            "\t\tlist_for_each_entry(ll, &locks, link) {",
            "\t\t\terr = ww_mutex_lock(ll->lock, &ctx);",
            "\t\t\tif (!err)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tln = ll;",
            "\t\t\tlist_for_each_entry_continue_reverse(ln, &locks, link)",
            "\t\t\t\tww_mutex_unlock(ln->lock);",
            "",
            "\t\t\tif (err != -EDEADLK) {",
            "\t\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",",
            "\t\t\t\t\t    __func__, err);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\tww_mutex_lock_slow(ll->lock, &ctx);",
            "\t\t\tlist_move(&ll->link, &locks); /* restarts iteration */",
            "\t\t}",
            "",
            "\t\tdummy_load(stress);",
            "\t\tlist_for_each_entry(ll, &locks, link)",
            "\t\t\tww_mutex_unlock(ll->lock);",
            "",
            "\t\tww_acquire_fini(&ctx);",
            "\t} while (!time_after(jiffies, stress->timeout));",
            "",
            "out:",
            "\tlist_for_each_entry_safe(ll, ln, &locks, link)",
            "\t\tkfree(ll);",
            "\tkfree(order);",
            "}",
            "static void stress_one_work(struct work_struct *work)",
            "{",
            "\tstruct stress *stress = container_of(work, typeof(*stress), work);",
            "\tconst int nlocks = stress->nlocks;",
            "\tstruct ww_mutex *lock = stress->locks + get_random_u32_below(nlocks);",
            "\tint err;",
            "",
            "\tdo {",
            "\t\terr = ww_mutex_lock(lock, NULL);",
            "\t\tif (!err) {",
            "\t\t\tdummy_load(stress);",
            "\t\t\tww_mutex_unlock(lock);",
            "\t\t} else {",
            "\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",",
            "\t\t\t\t    __func__, err);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t} while (!time_after(jiffies, stress->timeout));",
            "}",
            "static int stress(int nlocks, int nthreads, unsigned int flags)",
            "{",
            "\tstruct ww_mutex *locks;",
            "\tstruct stress *stress_array;",
            "\tint n, count;",
            "",
            "\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);",
            "\tif (!locks)",
            "\t\treturn -ENOMEM;",
            "",
            "\tstress_array = kmalloc_array(nthreads, sizeof(*stress_array),",
            "\t\t\t\t     GFP_KERNEL);",
            "\tif (!stress_array) {",
            "\t\tkfree(locks);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tfor (n = 0; n < nlocks; n++)",
            "\t\tww_mutex_init(&locks[n], &ww_class);",
            "",
            "\tcount = 0;",
            "\tfor (n = 0; nthreads; n++) {",
            "\t\tstruct stress *stress;",
            "\t\tvoid (*fn)(struct work_struct *work);",
            "",
            "\t\tfn = NULL;",
            "\t\tswitch (n & 3) {",
            "\t\tcase 0:",
            "\t\t\tif (flags & STRESS_INORDER)",
            "\t\t\t\tfn = stress_inorder_work;",
            "\t\t\tbreak;",
            "\t\tcase 1:",
            "\t\t\tif (flags & STRESS_REORDER)",
            "\t\t\t\tfn = stress_reorder_work;",
            "\t\t\tbreak;",
            "\t\tcase 2:",
            "\t\t\tif (flags & STRESS_ONE)",
            "\t\t\t\tfn = stress_one_work;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (!fn)",
            "\t\t\tcontinue;",
            "",
            "\t\tstress = &stress_array[count++];",
            "",
            "\t\tINIT_WORK(&stress->work, fn);",
            "\t\tstress->locks = locks;",
            "\t\tstress->nlocks = nlocks;",
            "\t\tstress->timeout = jiffies + 2*HZ;",
            "",
            "\t\tqueue_work(wq, &stress->work);",
            "\t\tnthreads--;",
            "\t}",
            "",
            "\tflush_workqueue(wq);",
            "",
            "\tfor (n = 0; n < nlocks; n++)",
            "\t\tww_mutex_destroy(&locks[n]);",
            "\tkfree(stress_array);",
            "\tkfree(locks);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "stress_reorder_work, stress_one_work, stress",
          "description": "实施大规模并发压力测试，支持按序加锁、重排序加锁和单锁测试模式，验证系统在高强度并发下的稳定性与死锁预防能力",
          "similarity": 0.5676169395446777
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/locking/test-ww_mutex.c",
          "start_line": 638,
          "end_line": 691,
          "content": [
            "static int __init test_ww_mutex_init(void)",
            "{",
            "\tint ncpus = num_online_cpus();",
            "\tint ret, i;",
            "",
            "\tprintk(KERN_INFO \"Beginning ww mutex selftests\\n\");",
            "",
            "\tprandom_seed_state(&rng, get_random_u64());",
            "",
            "\twq = alloc_workqueue(\"test-ww_mutex\", WQ_UNBOUND, 0);",
            "\tif (!wq)",
            "\t\treturn -ENOMEM;",
            "",
            "\tret = test_mutex();",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = test_aa(false);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = test_aa(true);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tfor (i = 0; i < 4; i++) {",
            "\t\tret = test_abba(i & 1, i & 2);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tret = test_cycle(ncpus);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = stress(16, 2*ncpus, STRESS_INORDER);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = stress(16, 2*ncpus, STRESS_REORDER);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = stress(2047, hweight32(STRESS_ALL)*ncpus, STRESS_ALL);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tprintk(KERN_INFO \"All ww mutex selftests passed\\n\");",
            "\treturn 0;",
            "}",
            "static void __exit test_ww_mutex_exit(void)",
            "{",
            "\tdestroy_workqueue(wq);",
            "}"
          ],
          "function_name": "test_ww_mutex_init, test_ww_mutex_exit",
          "description": "该代码段为ww_mutex子系统的自检模块，通过初始化函数注册并启动多线程测试任务，依次执行mutex、AA锁、ABBA死锁检测及压力测试等场景验证。其中`test_ww_mutex_init`负责创建工作队列并调用系列测试函数，`test_ww_mutex_exit`用于释放资源，但具体测试函数实现未在当前片段中展示，存在上下文缺失。",
          "similarity": 0.5003267526626587
        }
      ]
    },
    {
      "source_file": "kernel/iomem.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:45:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `iomem.c`\n\n---\n\n# iomem.c 技术文档\n\n## 1. 文件概述\n\n`iomem.c` 实现了通用的内存重映射（`memremap`）接口，用于将物理地址空间（特别是 I/O 内存资源）映射为可直接访问的内核虚拟地址。与传统的 `ioremap` 不同，`memremap` 专为**无 I/O 副作用**的内存区域设计（如持久内存 PMEM、设备内存等），并支持多种缓存策略（如写回 WB、写通 WT、写合并 WC）。该文件还提供了资源管理版本（`devm_memremap`），可自动在设备卸载时释放映射。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`memremap()`**  \n  核心映射函数，根据指定的缓存策略（`MEMREMAP_WB`/`WT`/`WC`）将物理地址映射为内核虚拟地址。若映射区域为系统 RAM 且请求 `MEMREMAP_WB`，则直接返回线性映射地址。\n\n- **`memunmap()`**  \n  释放由 `memremap()` 创建的映射。若地址来自 `ioremap` 系列函数，则调用 `iounmap()`；若为直接映射地址则无需操作。\n\n- **`devm_memremap()`**  \n  设备资源管理版本的 `memremap()`，将映射资源与设备生命周期绑定，设备卸载时自动释放。\n\n- **`devm_memunmap()`**  \n  显式释放由 `devm_memremap()` 分配的资源（通常无需手动调用）。\n\n### 辅助函数\n\n- **`try_ram_remap()`**  \n  尝试对系统 RAM 区域使用内核直接映射（`__va()`），避免创建新页表。\n\n- **`arch_memremap_wb()`**（弱符号）  \n  架构特定的写回（WB）映射实现，默认回退到 `ioremap_cache()` 或 `ioremap()`。\n\n- **`arch_memremap_can_ram_remap()`**（弱符号）  \n  架构特定的 RAM 重映射能力检查，默认返回 `true`。\n\n### 标志位（Flags）\n\n- `MEMREMAP_WB`：写回缓存（默认系统 RAM 策略）\n- `MEMREMAP_WT`：写通缓存（禁止用于系统 RAM）\n- `MEMREMAP_WC`：写合并（禁止用于系统 RAM）\n- `MEMREMAP_ENC`/`DEC`：加密/解密映射（代码中未直接处理，由底层 `ioremap` 实现）\n\n## 3. 关键实现\n\n### 内存区域类型检测\n- 使用 `region_intersects()` 检查物理地址范围是否与 `IORESOURCE_SYSTEM_RAM` 重叠，返回：\n  - `REGION_INTERSECTS`：完全或部分在系统 RAM 内\n  - `REGION_MIXED`：跨越 RAM 与非 RAM 区域（视为错误）\n  - `REGION_DISJOINT`：完全在非 RAM 区域\n\n### RAM 直接映射优化\n- 当请求 `MEMREMAP_WB` 且区域为系统 RAM 时：\n  1. 调用 `try_ram_remap()` 检查是否满足直接映射条件：\n     - 物理页帧有效（`pfn_valid()`）\n     - 非高端内存（`!PageHighMem()`）\n     - 架构允许 RAM 重映射（`arch_memremap_can_ram_remap()`）\n  2. 若满足，直接返回 `__va(offset)`（内核线性映射地址），避免页表开销。\n\n### 非 RAM 区域映射\n- 对于非 RAM 区域或非 WB 请求：\n  - `MEMREMAP_WT` → `ioremap_wt()`\n  - `MEMREMAP_WC` → `ioremap_wc()`\n  - `MEMREMAP_WB` → `arch_memremap_wb()`（最终调用 `ioremap_cache()` 或 `ioremap()`）\n\n### 安全限制\n- 禁止对系统 RAM 使用 `WT`/`WC` 映射（会触发 `WARN_ONCE` 并返回 `NULL`）\n- 禁止映射混合 RAM/非 RAM 区域（视为编程错误）\n\n### 资源管理\n- `devm_memremap()` 使用设备资源管理框架（`devres`）：\n  - 分配资源描述符（`devres_alloc_node`）\n  - 注册释放回调（`devm_memremap_release`）\n  - 设备卸载时自动调用 `memunmap()`\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/io.h>`：提供 `ioremap_*()` 系列函数\n  - `<linux/mm.h>`：提供 `pfn_valid()`、`PageHighMem()` 等内存管理接口\n  - `<linux/ioremap.h>`：定义 `ioremap` 相关类型和函数\n  - `<linux/device.h>`：提供设备资源管理（`devres`）接口\n\n- **架构依赖**：\n  - 依赖架构实现的 `ioremap_cache()`、`ioremap_wt()`、`ioremap_wc()`\n  - 可选覆盖 `arch_memremap_wb()` 和 `arch_memremap_can_ram_remap()`\n\n- **内核子系统**：\n  - 内存管理子系统（MM）：页表管理、直接映射\n  - 设备驱动模型：设备资源生命周期管理\n\n## 5. 使用场景\n\n- **持久内存（PMEM）驱动**：  \n  将持久内存设备的物理地址映射为可直接读写的内核虚拟地址（通常使用 `MEMREMAP_WB`）。\n\n- **设备内存（Device Memory）访问**：  \n  访问无 I/O 副作用的设备内存区域（如 GPU 显存、FPGA 内存），根据性能需求选择缓存策略。\n\n- **EFI 运行时服务内存**：  \n  映射 EFI 固件提供的内存区域（需确保无副作用）。\n\n- **设备驱动资源管理**：  \n  使用 `devm_memremap()` 简化驱动代码，避免手动释放映射（尤其适用于 probe/remove 场景）。\n\n- **内核子系统通用映射**：  \n  为需要高性能内存访问的子系统（如 DAX、HMM）提供统一映射接口。",
      "similarity": 0.5948742032051086,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/iomem.c",
          "start_line": 20,
          "end_line": 42,
          "content": [
            "static bool arch_memremap_can_ram_remap(resource_size_t offset, size_t size,",
            "\t\t\t\t\tunsigned long flags)",
            "{",
            "\treturn true;",
            "}",
            "void memunmap(void *addr)",
            "{",
            "\tif (is_ioremap_addr(addr))",
            "\t\tiounmap((void __iomem *) addr);",
            "}",
            "static void devm_memremap_release(struct device *dev, void *res)",
            "{",
            "\tmemunmap(*(void **)res);",
            "}",
            "static int devm_memremap_match(struct device *dev, void *res, void *match_data)",
            "{",
            "\treturn *(void **)res == match_data;",
            "}",
            "void devm_memunmap(struct device *dev, void *addr)",
            "{",
            "\tWARN_ON(devres_release(dev, devm_memremap_release,",
            "\t\t\t\tdevm_memremap_match, addr));",
            "}"
          ],
          "function_name": "arch_memremap_can_ram_remap, memunmap, devm_memremap_release, devm_memremap_match, devm_memunmap",
          "description": "实现内存映射释放相关函数，包含判断能否进行RAM重映射的钩子函数、解除ioremap地址映射的memunmap函数，以及设备资源管理中的动态内存映射释放匹配逻辑",
          "similarity": 0.5973476767539978
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/iomem.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "/* SPDX-License-Identifier: GPL-2.0 */",
            "#include <linux/device.h>",
            "#include <linux/types.h>",
            "#include <linux/io.h>",
            "#include <linux/mm.h>",
            "#include <linux/ioremap.h>",
            "",
            "#ifndef arch_memremap_wb",
            "static void *arch_memremap_wb(resource_size_t offset, unsigned long size)",
            "{",
            "#ifdef ioremap_cache",
            "\treturn (__force void *)ioremap_cache(offset, size);",
            "#else",
            "\treturn (__force void *)ioremap(offset, size);",
            "#endif",
            "}",
            "#endif",
            "",
            "#ifndef arch_memremap_can_ram_remap"
          ],
          "function_name": null,
          "description": "定义arch_memremap_wb函数，根据ioremap_cache是否存在选择使用ioremap_cache或ioremap实现，用于创建带写回缓存策略的内存映射区域，上下文不完整",
          "similarity": 0.5096645355224609
        }
      ]
    }
  ]
}