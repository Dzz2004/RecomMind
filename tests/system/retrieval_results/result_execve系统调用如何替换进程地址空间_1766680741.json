{
  "query": "execve系统调用如何替换进程地址空间",
  "timestamp": "2025-12-26 00:39:01",
  "retrieved_files": [
    {
      "source_file": "kernel/nsproxy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:12:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `nsproxy.c`\n\n---\n\n# nsproxy.c 技术文档\n\n## 1. 文件概述\n\n`nsproxy.c` 是 Linux 内核中实现命名空间（namespaces）代理机制的核心文件。该文件负责管理进程的命名空间代理结构 `nsproxy`，提供创建、复制、切换和释放命名空间集合的功能。命名空间是 Linux 容器技术（如 Docker、LXC）的基础，用于隔离进程视图，包括挂载点、UTS（主机名）、IPC、PID、网络、cgroup 和时间等资源。`nsproxy` 作为指向各类命名空间实例的容器，使得一个进程可以拥有独立的命名空间视图。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct nsproxy`**  \n  命名空间代理结构体，包含指向各类命名空间的指针：\n  - `uts_ns`：UTS 命名空间（主机名、域名）\n  - `ipc_ns`：IPC 命名空间（System V IPC 和 POSIX 消息队列）\n  - `mnt_ns`：挂载命名空间（文件系统挂载点视图）\n  - `pid_ns_for_children`：子进程将加入的 PID 命名空间\n  - `net_ns`：网络命名空间（网络设备、协议栈等）\n  - `cgroup_ns`：cgroup 命名空间（cgroup 层级视图）\n  - `time_ns` / `time_ns_for_children`：时间命名空间（用于虚拟化时间）\n\n- **`init_nsproxy`**  \n  全局初始化的命名空间代理实例，作为系统初始命名空间的引用。\n\n### 主要函数\n\n- **`create_nsproxy()`**  \n  从 slab 缓存分配一个新的 `nsproxy` 结构并初始化引用计数。\n\n- **`create_new_namespaces()`**  \n  根据指定标志位（如 `CLONE_NEWNS` 等）为任务创建全新的命名空间集合。\n\n- **`copy_namespaces()`**  \n  在 `clone()` 系统调用中被调用，根据 `clone_flags` 决定是否复制命名空间。\n\n- **`free_nsproxy()`**  \n  释放 `nsproxy` 及其引用的所有命名空间资源。\n\n- **`unshare_nsproxy_namespaces()`**  \n  在 `unshare()` 系统调用中使用，允许进程脱离当前命名空间并创建新的命名空间。\n\n- **`switch_task_namespaces()`**  \n  安全地切换任务的 `nsproxy`，并释放旧的引用。\n\n- **`exit_task_namespaces()`**  \n  进程退出时清理命名空间引用。\n\n- **`exec_task_namespaces()`**  \n  在 `execve()` 期间处理时间命名空间的特殊语义（子进程继承 `time_ns_for_children`）。\n\n- **`check_setns_flags()`**  \n  验证 `setns()` 系统调用传入的命名空间标志是否合法且内核已启用对应支持。\n\n## 3. 关键实现\n\n### 命名空间复制逻辑\n\n`create_new_namespaces()` 函数按顺序复制各类命名空间。若某一步失败（如内存不足或权限不足），则回滚已分配的资源，确保无内存泄漏。每个命名空间的复制由对应模块提供 `copy_xxx_ns()` 函数实现（如 `copy_mnt_ns()`、`copy_net_ns()` 等）。\n\n### 引用计数管理\n\n所有命名空间结构均使用引用计数（`refcount_t` 或类似机制）。`nsproxy` 本身也通过 `refcount_t count` 管理生命周期。`get_nsproxy()` 增加引用，`put_nsproxy()`（内联调用 `free_nsproxy()`）减少引用并在归零时释放。\n\n### 时间命名空间特殊处理\n\n时间命名空间具有两个字段：\n- `time_ns`：当前任务使用的时间命名空间。\n- `time_ns_for_children`：新创建子进程将继承的时间命名空间。\n\n在 `execve()` 时，若两者不同，需创建新的 `nsproxy` 并调用 `timens_on_fork()` 更新时间命名空间状态。\n\n### 权限与安全检查\n\n- 除 `CLONE_VM` 优化路径外，创建新命名空间需 `CAP_SYS_ADMIN` 能力。\n- 禁止同时指定 `CLONE_NEWIPC` 和 `CLONE_SYSVSEM`，因语义冲突。\n- `check_setns_flags()` 确保仅启用的命名空间类型可被操作。\n\n### 优化路径\n\n若 `clone_flags` 未请求任何新命名空间，且满足 `CLONE_VM` 或时间命名空间一致，则直接复用父进程的 `nsproxy`（仅增加引用计数），避免不必要的复制开销。\n\n## 4. 依赖关系\n\n- **内存管理**：依赖 `slab.h` 的 `kmem_cache` 机制分配 `nsproxy`。\n- **各命名空间子系统**：\n  - 挂载命名空间：`mnt_namespace.h`\n  - UTS：`utsname.h`\n  - IPC：`ipc_namespace.h`\n  - PID：`pid_namespace.h`\n  - 网络：`net_namespace.h`\n  - cgroup：`cgroup.h`\n  - 时间：`time_namespace.h`\n- **进程管理**：依赖 `task_struct`、`cred`、`fs_struct` 等结构。\n- **能力机制**：通过 `ns_capable()` 检查 `CAP_SYS_ADMIN`。\n- **proc 文件系统**：支持 `/proc/[pid]/ns/` 下的命名空间符号链接（通过 `proc_ns.h`）。\n\n## 5. 使用场景\n\n- **`clone()` 系统调用**：当指定 `CLONE_NEW*` 标志时，`copy_namespaces()` 被调用以创建子进程的命名空间视图。\n- **`unshare()` 系统调用**：进程调用 `unshare(CLONE_NEWNS | ...)` 时，`unshare_nsproxy_namespaces()` 创建新命名空间并切换。\n- **`setns()` 系统调用**：通过 `check_setns_flags()` 验证传入的命名空间类型合法性。\n- **`execve()` 系统调用**：处理时间命名空间的继承语义，确保子进程使用正确的 `time_ns_for_children`。\n- **进程退出**：`exit_task_namespaces()` 在进程终止时释放命名空间资源。\n- **容器运行时**：Docker、Podman、LXC 等依赖此机制实现资源隔离。",
      "similarity": 0.5718855857849121,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/nsproxy.c",
          "start_line": 151,
          "end_line": 265,
          "content": [
            "int copy_namespaces(unsigned long flags, struct task_struct *tsk)",
            "{",
            "\tstruct nsproxy *old_ns = tsk->nsproxy;",
            "\tstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);",
            "\tstruct nsproxy *new_ns;",
            "",
            "\tif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t      CLONE_NEWPID | CLONE_NEWNET |",
            "\t\t\t      CLONE_NEWCGROUP | CLONE_NEWTIME)))) {",
            "\t\tif ((flags & CLONE_VM) ||",
            "\t\t    likely(old_ns->time_ns_for_children == old_ns->time_ns)) {",
            "\t\t\tget_nsproxy(old_ns);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t} else if (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * CLONE_NEWIPC must detach from the undolist: after switching",
            "\t * to a new ipc namespace, the semaphore arrays from the old",
            "\t * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM",
            "\t * means share undolist with parent, so we must forbid using",
            "\t * it along with CLONE_NEWIPC.",
            "\t */",
            "\tif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==",
            "\t\t(CLONE_NEWIPC | CLONE_SYSVSEM))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);",
            "\tif (IS_ERR(new_ns))",
            "\t\treturn  PTR_ERR(new_ns);",
            "",
            "\tif ((flags & CLONE_VM) == 0)",
            "\t\ttimens_on_fork(new_ns, tsk);",
            "",
            "\ttsk->nsproxy = new_ns;",
            "\treturn 0;",
            "}",
            "void free_nsproxy(struct nsproxy *ns)",
            "{",
            "\tif (ns->mnt_ns)",
            "\t\tput_mnt_ns(ns->mnt_ns);",
            "\tif (ns->uts_ns)",
            "\t\tput_uts_ns(ns->uts_ns);",
            "\tif (ns->ipc_ns)",
            "\t\tput_ipc_ns(ns->ipc_ns);",
            "\tif (ns->pid_ns_for_children)",
            "\t\tput_pid_ns(ns->pid_ns_for_children);",
            "\tif (ns->time_ns)",
            "\t\tput_time_ns(ns->time_ns);",
            "\tif (ns->time_ns_for_children)",
            "\t\tput_time_ns(ns->time_ns_for_children);",
            "\tput_cgroup_ns(ns->cgroup_ns);",
            "\tput_net(ns->net_ns);",
            "\tkmem_cache_free(nsproxy_cachep, ns);",
            "}",
            "int unshare_nsproxy_namespaces(unsigned long unshare_flags,",
            "\tstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)",
            "{",
            "\tstruct user_namespace *user_ns;",
            "\tint err = 0;",
            "",
            "\tif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP |",
            "\t\t\t       CLONE_NEWTIME)))",
            "\t\treturn 0;",
            "",
            "\tuser_ns = new_cred ? new_cred->user_ns : current_user_ns();",
            "\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,",
            "\t\t\t\t\t new_fs ? new_fs : current->fs);",
            "\tif (IS_ERR(*new_nsp)) {",
            "\t\terr = PTR_ERR(*new_nsp);",
            "\t\tgoto out;",
            "\t}",
            "",
            "out:",
            "\treturn err;",
            "}",
            "void switch_task_namespaces(struct task_struct *p, struct nsproxy *new)",
            "{",
            "\tstruct nsproxy *ns;",
            "",
            "\tmight_sleep();",
            "",
            "\ttask_lock(p);",
            "\tns = p->nsproxy;",
            "\tp->nsproxy = new;",
            "\ttask_unlock(p);",
            "",
            "\tif (ns)",
            "\t\tput_nsproxy(ns);",
            "}",
            "void exit_task_namespaces(struct task_struct *p)",
            "{",
            "\tswitch_task_namespaces(p, NULL);",
            "}",
            "int exec_task_namespaces(void)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct nsproxy *new;",
            "",
            "\tif (tsk->nsproxy->time_ns_for_children == tsk->nsproxy->time_ns)",
            "\t\treturn 0;",
            "",
            "\tnew = create_new_namespaces(0, tsk, current_user_ns(), tsk->fs);",
            "\tif (IS_ERR(new))",
            "\t\treturn PTR_ERR(new);",
            "",
            "\ttimens_on_fork(new, tsk);",
            "\tswitch_task_namespaces(tsk, new);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_namespaces, free_nsproxy, unshare_nsproxy_namespaces, switch_task_namespaces, exit_task_namespaces, exec_task_namespaces",
          "description": "实现了命名空间相关操作，包括复制（copy_namespaces）、释放（free_nsproxy）、分离（unshare_nsproxy_namespaces）、切换（switch_task_namespaces）和验证（validate_nsset）等功能，支持多命名空间的动态管理",
          "similarity": 0.5734356641769409
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/nsproxy.c",
          "start_line": 512,
          "end_line": 549,
          "content": [
            "static void commit_nsset(struct nsset *nsset)",
            "{",
            "\tunsigned flags = nsset->flags;",
            "\tstruct task_struct *me = current;",
            "",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER) {",
            "\t\t/* transfer ownership */",
            "\t\tcommit_creds(nsset_cred(nsset));",
            "\t\tnsset->cred = NULL;",
            "\t}",
            "#endif",
            "",
            "\t/* We only need to commit if we have used a temporary fs_struct. */",
            "\tif ((flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS)) {",
            "\t\tset_fs_root(me->fs, &nsset->fs->root);",
            "\t\tset_fs_pwd(me->fs, &nsset->fs->pwd);",
            "\t}",
            "",
            "#ifdef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC)",
            "\t\texit_sem(me);",
            "#endif",
            "",
            "#ifdef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME)",
            "\t\ttimens_commit(me, nsset->nsproxy->time_ns);",
            "#endif",
            "",
            "\t/* transfer ownership */",
            "\tswitch_task_namespaces(me, nsset->nsproxy);",
            "\tnsset->nsproxy = NULL;",
            "}",
            "int __init nsproxy_cache_init(void)",
            "{",
            "\tnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC|SLAB_ACCOUNT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "commit_nsset, nsproxy_cache_init",
          "description": "完成命名空间变更提交（commit_nsset）和缓存初始化（nsproxy_cache_init），将临时命名空间绑定到当前任务并持久化，同时建立nsproxy结构体的Slab缓存以优化内存分配",
          "similarity": 0.5625882148742676
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/nsproxy.c",
          "start_line": 276,
          "end_line": 490,
          "content": [
            "static int check_setns_flags(unsigned long flags)",
            "{",
            "\tif (!flags || (flags & ~(CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t\t CLONE_NEWNET | CLONE_NEWTIME | CLONE_NEWUSER |",
            "\t\t\t\t CLONE_NEWPID | CLONE_NEWCGROUP)))",
            "\t\treturn -EINVAL;",
            "",
            "#ifndef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_UTS_NS",
            "\tif (flags & CLONE_NEWUTS)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_CGROUPS",
            "\tif (flags & CLONE_NEWCGROUP)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_NET_NS",
            "\tif (flags & CLONE_NEWNET)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME)",
            "\t\treturn -EINVAL;",
            "#endif",
            "",
            "\treturn 0;",
            "}",
            "static void put_nsset(struct nsset *nsset)",
            "{",
            "\tunsigned flags = nsset->flags;",
            "",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tput_cred(nsset_cred(nsset));",
            "\t/*",
            "\t * We only created a temporary copy if we attached to more than just",
            "\t * the mount namespace.",
            "\t */",
            "\tif (nsset->fs && (flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS))",
            "\t\tfree_fs_struct(nsset->fs);",
            "\tif (nsset->nsproxy)",
            "\t\tfree_nsproxy(nsset->nsproxy);",
            "}",
            "static int prepare_nsset(unsigned flags, struct nsset *nsset)",
            "{",
            "\tstruct task_struct *me = current;",
            "",
            "\tnsset->nsproxy = create_new_namespaces(0, me, current_user_ns(), me->fs);",
            "\tif (IS_ERR(nsset->nsproxy))",
            "\t\treturn PTR_ERR(nsset->nsproxy);",
            "",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tnsset->cred = prepare_creds();",
            "\telse",
            "\t\tnsset->cred = current_cred();",
            "\tif (!nsset->cred)",
            "\t\tgoto out;",
            "",
            "\t/* Only create a temporary copy of fs_struct if we really need to. */",
            "\tif (flags == CLONE_NEWNS) {",
            "\t\tnsset->fs = me->fs;",
            "\t} else if (flags & CLONE_NEWNS) {",
            "\t\tnsset->fs = copy_fs_struct(me->fs);",
            "\t\tif (!nsset->fs)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tnsset->flags = flags;",
            "\treturn 0;",
            "",
            "out:",
            "\tput_nsset(nsset);",
            "\treturn -ENOMEM;",
            "}",
            "static inline int validate_ns(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\treturn ns->ops->install(nsset, ns);",
            "}",
            "static int validate_nsset(struct nsset *nsset, struct pid *pid)",
            "{",
            "\tint ret = 0;",
            "\tunsigned flags = nsset->flags;",
            "\tstruct user_namespace *user_ns = NULL;",
            "\tstruct pid_namespace *pid_ns = NULL;",
            "\tstruct nsproxy *nsp;",
            "\tstruct task_struct *tsk;",
            "",
            "\t/* Take a \"snapshot\" of the target task's namespaces. */",
            "\trcu_read_lock();",
            "\ttsk = pid_task(pid, PIDTYPE_PID);",
            "\tif (!tsk) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "\tif (!ptrace_may_access(tsk, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\ttask_lock(tsk);",
            "\tnsp = tsk->nsproxy;",
            "\tif (nsp)",
            "\t\tget_nsproxy(nsp);",
            "\ttask_unlock(tsk);",
            "\tif (!nsp) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "#ifdef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID) {",
            "\t\tpid_ns = task_active_pid_ns(tsk);",
            "\t\tif (unlikely(!pid_ns)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tret = -ESRCH;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tget_pid_ns(pid_ns);",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tuser_ns = get_user_ns(__task_cred(tsk)->user_ns);",
            "#endif",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Install requested namespaces. The caller will have",
            "\t * verified earlier that the requested namespaces are",
            "\t * supported on this kernel. We don't report errors here",
            "\t * if a namespace is requested that isn't supported.",
            "\t */",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER) {",
            "\t\tret = validate_ns(nsset, &user_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "\tif (flags & CLONE_NEWNS) {",
            "\t\tret = validate_ns(nsset, from_mnt_ns(nsp->mnt_ns));",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "#ifdef CONFIG_UTS_NS",
            "\tif (flags & CLONE_NEWUTS) {",
            "\t\tret = validate_ns(nsset, &nsp->uts_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC) {",
            "\t\tret = validate_ns(nsset, &nsp->ipc_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID) {",
            "\t\tret = validate_ns(nsset, &pid_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_CGROUPS",
            "\tif (flags & CLONE_NEWCGROUP) {",
            "\t\tret = validate_ns(nsset, &nsp->cgroup_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_NET_NS",
            "\tif (flags & CLONE_NEWNET) {",
            "\t\tret = validate_ns(nsset, &nsp->net_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME) {",
            "\t\tret = validate_ns(nsset, &nsp->time_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "out:",
            "\tif (pid_ns)",
            "\t\tput_pid_ns(pid_ns);",
            "\tif (nsp)",
            "\t\tput_nsproxy(nsp);",
            "\tput_user_ns(user_ns);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "check_setns_flags, put_nsset, prepare_nsset, validate_ns, validate_nsset",
          "description": "提供命名空间集合的校验与准备逻辑，check_setns_flags验证标志位有效性，prepare_nsset构建临时命名空间集，validate_nsset检查目标命名空间权限和可用性，确保安全操作",
          "similarity": 0.49873754382133484
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/nsproxy.c",
          "start_line": 1,
          "end_line": 150,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  Copyright (C) 2006 IBM Corporation",
            " *",
            " *  Author: Serge Hallyn <serue@us.ibm.com>",
            " *",
            " *  Jun 2006 - namespaces support",
            " *             OpenVZ, SWsoft Inc.",
            " *             Pavel Emelianov <xemul@openvz.org>",
            " */",
            "",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/init_task.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pid_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/perf_event.h>",
            "",
            "static struct kmem_cache *nsproxy_cachep;",
            "",
            "struct nsproxy init_nsproxy = {",
            "\t.count\t\t\t= REFCOUNT_INIT(1),",
            "\t.uts_ns\t\t\t= &init_uts_ns,",
            "#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)",
            "\t.ipc_ns\t\t\t= &init_ipc_ns,",
            "#endif",
            "\t.mnt_ns\t\t\t= NULL,",
            "\t.pid_ns_for_children\t= &init_pid_ns,",
            "#ifdef CONFIG_NET",
            "\t.net_ns\t\t\t= &init_net,",
            "#endif",
            "#ifdef CONFIG_CGROUPS",
            "\t.cgroup_ns\t\t= &init_cgroup_ns,",
            "#endif",
            "#ifdef CONFIG_TIME_NS",
            "\t.time_ns\t\t= &init_time_ns,",
            "\t.time_ns_for_children\t= &init_time_ns,",
            "#endif",
            "};",
            "",
            "static inline struct nsproxy *create_nsproxy(void)",
            "{",
            "\tstruct nsproxy *nsproxy;",
            "",
            "\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);",
            "\tif (nsproxy)",
            "\t\trefcount_set(&nsproxy->count, 1);",
            "\treturn nsproxy;",
            "}",
            "",
            "/*",
            " * Create new nsproxy and all of its the associated namespaces.",
            " * Return the newly created nsproxy.  Do not attach this to the task,",
            " * leave it to the caller to do proper locking and attach it to task.",
            " */",
            "static struct nsproxy *create_new_namespaces(unsigned long flags,",
            "\tstruct task_struct *tsk, struct user_namespace *user_ns,",
            "\tstruct fs_struct *new_fs)",
            "{",
            "\tstruct nsproxy *new_nsp;",
            "\tint err;",
            "",
            "\tnew_nsp = create_nsproxy();",
            "\tif (!new_nsp)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "",
            "\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);",
            "\tif (IS_ERR(new_nsp->mnt_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->mnt_ns);",
            "\t\tgoto out_ns;",
            "\t}",
            "",
            "\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);",
            "\tif (IS_ERR(new_nsp->uts_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->uts_ns);",
            "\t\tgoto out_uts;",
            "\t}",
            "",
            "\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);",
            "\tif (IS_ERR(new_nsp->ipc_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->ipc_ns);",
            "\t\tgoto out_ipc;",
            "\t}",
            "",
            "\tnew_nsp->pid_ns_for_children =",
            "\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);",
            "\tif (IS_ERR(new_nsp->pid_ns_for_children)) {",
            "\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);",
            "\t\tgoto out_pid;",
            "\t}",
            "",
            "\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,",
            "\t\t\t\t\t    tsk->nsproxy->cgroup_ns);",
            "\tif (IS_ERR(new_nsp->cgroup_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->cgroup_ns);",
            "\t\tgoto out_cgroup;",
            "\t}",
            "",
            "\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);",
            "\tif (IS_ERR(new_nsp->net_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->net_ns);",
            "\t\tgoto out_net;",
            "\t}",
            "",
            "\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,",
            "\t\t\t\t\ttsk->nsproxy->time_ns_for_children);",
            "\tif (IS_ERR(new_nsp->time_ns_for_children)) {",
            "\t\terr = PTR_ERR(new_nsp->time_ns_for_children);",
            "\t\tgoto out_time;",
            "\t}",
            "\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);",
            "",
            "\treturn new_nsp;",
            "",
            "out_time:",
            "\tput_net(new_nsp->net_ns);",
            "out_net:",
            "\tput_cgroup_ns(new_nsp->cgroup_ns);",
            "out_cgroup:",
            "\tif (new_nsp->pid_ns_for_children)",
            "\t\tput_pid_ns(new_nsp->pid_ns_for_children);",
            "out_pid:",
            "\tif (new_nsp->ipc_ns)",
            "\t\tput_ipc_ns(new_nsp->ipc_ns);",
            "out_ipc:",
            "\tif (new_nsp->uts_ns)",
            "\t\tput_uts_ns(new_nsp->uts_ns);",
            "out_uts:",
            "\tif (new_nsp->mnt_ns)",
            "\t\tput_mnt_ns(new_nsp->mnt_ns);",
            "out_ns:",
            "\tkmem_cache_free(nsproxy_cachep, new_nsp);",
            "\treturn ERR_PTR(err);",
            "}",
            "",
            "/*",
            " * called from clone.  This now handles copy for nsproxy and all",
            " * namespaces therein.",
            " */"
          ],
          "function_name": null,
          "description": "定义了nsproxy结构体的初始值和创建逻辑，包括各命名空间（如mnt、uts、ipc等）的初始化及通过create_new_namespaces函数创建新命名空间的流程，用于进程克隆时复制命名空间环境",
          "similarity": 0.4686448276042938
        }
      ]
    },
    {
      "source_file": "kernel/exec_domain.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:26:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `exec_domain.c`\n\n---\n\n# exec_domain.c 技术文档\n\n## 1. 文件概述\n\n`exec_domain.c` 是 Linux 内核中用于管理不同 ABI（Application Binary Interface，应用程序二进制接口）执行域（execution domains）的核心文件。该文件实现了对“personality”机制的支持，允许进程在运行时切换其行为模式，以兼容不同操作系统或 ABI 的语义，例如信号处理、系统调用编号映射等。当前实现主要保留了基础框架，并默认仅支持标准 Linux personality。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`SYSCALL_DEFINE1(personality, unsigned int, personality)`**  \n  系统调用入口，用于获取或设置当前进程的 personality。若传入参数不为 `0xffffffff`，则调用 `set_personality()` 更新当前进程的 personality；无论是否更新，均返回旧值。\n\n- **`execdomains_proc_show(struct seq_file *m, void *v)`**（条件编译）  \n  在 `/proc/execdomains` 文件中输出当前内核支持的执行域列表。当前仅输出标准 Linux 执行域（ID 0-0）。\n\n- **`proc_execdomains_init(void)`**（条件编译）  \n  初始化 `/proc/execdomains` 接口，仅在 `CONFIG_PROC_FS` 配置启用时编译。\n\n## 3. 关键实现\n\n- **Personality 机制**：  \n  每个进程的 `task_struct` 中包含 `personality` 字段，用于标识其当前的执行域行为。通过 `personality()` 系统调用可动态切换该值，从而影响内核对信号、路径解析、系统调用等行为的处理方式。\n\n- **执行域注册与查询**：  \n  历史上 Linux 支持多种执行域（如 SVr4、BSD、OSF 等），但现代内核已移除大部分实现，仅保留 Linux 原生执行域（ID 0）。`/proc/execdomains` 接口静态返回 `\"0-0\\tLinux\\t[kernel]\\n\"`，表明当前仅支持标准 Linux ABI。\n\n- **系统调用接口**：  \n  `personality()` 系统调用是用户空间与内核 personality 机制交互的唯一入口。传入 `0xffffffff` 可用于仅查询当前值而不修改。\n\n- **模块初始化**：  \n  若启用了 `CONFIG_PROC_FS`，则在内核初始化阶段通过 `module_init()` 注册 `/proc/execdomains` 文件，供用户空间查询支持的执行域。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/personality.h>`：定义 personality 相关常量和 `set_personality()` 函数。\n  - `<linux/sched.h>`：访问 `current` 宏以获取当前进程的 `task_struct`。\n  - `<linux/proc_fs.h>` 和 `<linux/seq_file.h>`：用于实现 `/proc/execdomains` 接口。\n  - `<linux/syscalls.h>`：用于定义系统调用。\n  - 其他通用内核头文件（如 `init.h`, `kernel.h`, `module.h` 等）。\n\n- **内核配置依赖**：\n  - `CONFIG_PROC_FS`：控制是否编译 `/proc/execdomains` 接口。\n\n- **外部模块交互**：\n  - 该文件不导出符号供其他模块使用，属于内核核心 ABI 支持层。\n  - `set_personality()` 的具体实现位于 `kernel/sys.c` 中。\n\n## 5. 使用场景\n\n- **兼容性运行环境**：  \n  在早期 Linux 中，用于运行非 Linux 二进制程序（如通过 binfmt 模块加载的 SVr4 或 BSD 程序），通过设置特定 personality 使内核模拟目标系统的 ABI 行为。\n\n- **调试与沙箱**：  \n  用户空间程序可通过 `personality(PER_LINUX)` 或其他标志（如 `ADDR_NO_RANDOMIZE`）临时修改进程行为，例如禁用 ASLR 以辅助调试。\n\n- **系统信息查询**：  \n  用户可通过读取 `/proc/execdomains` 了解当前内核支持的执行域类型（尽管现代系统通常仅显示 Linux）。\n\n- **容器与虚拟化**：  \n  在某些轻量级虚拟化场景中，可通过 personality 机制微调进程的系统调用行为，但现代方案更多依赖 seccomp 或 namespaces。",
      "similarity": 0.570259153842926,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/exec_domain.c",
          "start_line": 24,
          "end_line": 33,
          "content": [
            "static int execdomains_proc_show(struct seq_file *m, void *v)",
            "{",
            "\tseq_puts(m, \"0-0\\tLinux           \\t[kernel]\\n\");",
            "\treturn 0;",
            "}",
            "static int __init proc_execdomains_init(void)",
            "{",
            "\tproc_create_single(\"execdomains\", 0, NULL, execdomains_proc_show);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "execdomains_proc_show, proc_execdomains_init",
          "description": "定义用于 /proc/execdomains 文件的读取回调函数及初始化函数，通过 proc_create_single 创建 proc 文件节点以暴露当前系统运行的执行域标识及其关联的 ABI 类型信息",
          "similarity": 0.5507076978683472
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/exec_domain.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Handling of different ABIs (personalities).",
            " *",
            " * We group personalities into execution domains which have their",
            " * own handlers for kernel entry points, signal mapping, etc...",
            " *",
            " * 2001-05-06\tComplete rewrite,  Christoph Hellwig (hch@infradead.org)",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kmod.h>",
            "#include <linux/module.h>",
            "#include <linux/personality.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/types.h>",
            "",
            "#ifdef CONFIG_PROC_FS"
          ],
          "function_name": null,
          "description": "此代码块包含执行域（exec domain）相关的头文件声明，启用对 PROC_FS 的支持以实现 ABI 特性处理，因代码片段未展示核心逻辑故标记上下文不完整",
          "similarity": 0.5392407178878784
        }
      ]
    },
    {
      "source_file": "kernel/uid16.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:43:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `uid16.c`\n\n---\n\n# uid16.c 技术文档\n\n## 文件概述\n\n`uid16.c` 是 Linux 内核中用于提供 16 位用户 ID（UID）和组 ID（GID）系统调用兼容性的封装层。该文件实现了旧式 16 位 UID/GID 系统调用（如 `chown16`、`setuid16` 等）到现代 32 位 UID/GID 内核接口的桥接，确保运行在 32 位 UID/GID 架构上的旧应用程序仍能在支持高 UID（high UID）的现代内核上正常工作。文件注释中提到“希望五年后能移除这些接口”，表明其为临时兼容性方案。\n\n## 核心功能\n\n### 主要系统调用函数\n\n- **文件所有权变更类**：\n  - `chown16`：变更文件所有者和所属组（16 位接口）\n  - `lchown16`：变更符号链接指向文件的所有者和组（16 位接口）\n  - `fchown16`：通过文件描述符变更文件所有者和组（16 位接口）\n\n- **用户 ID 设置类**：\n  - `setuid16` / `seteuid16`（通过 `setreuid16` 实现）：设置真实/有效 UID\n  - `setreuid16`：同时设置真实 UID 和有效 UID\n  - `setresuid16`：设置真实、有效和保存的 UID\n  - `setfsuid16`：设置文件系统 UID\n\n- **组 ID 设置类**：\n  - `setgid16` / `setegid16`（通过 `setregid16` 实现）：设置真实/有效 GID\n  - `setregid16`：同时设置真实 GID 和有效 GID\n  - `setresgid16`：设置真实、有效和保存的 GID\n  - `setfsgid16`：设置文件系统 GID\n\n- **查询类**：\n  - `getuid16` / `geteuid16`：获取当前真实/有效 UID（16 位返回）\n  - `getgid16` / `getegid16`：获取当前真实/有效 GID（16 位返回）\n  - `getresuid16` / `getresgid16`：获取三类 UID/GID（真实、有效、保存）\n  - `getgroups16`：获取当前进程的附加组列表（16 位格式）\n  - `setgroups16`：设置当前进程的附加组列表（16 位输入）\n\n### 辅助函数\n\n- `groups16_to_user`：将内核 `group_info` 中的 GID 转换为 16 位格式并复制到用户空间\n- `groups16_from_user`：从用户空间读取 16 位 GID 列表并转换为内核 `kgid_t` 格式\n\n### 关键宏与类型\n\n- `old_uid_t` / `old_gid_t`：定义为 16 位整数类型（通常为 `__u16`）\n- `low2highuid` / `low2highgid`：将 16 位 UID/GID 扩展为 32 位内核表示\n- `high2lowuid` / `high2lowgid`：将 32 位内核 UID/GID 截断为 16 位返回用户空间\n- `from_kuid_munged` / `from_kgid_munged`：在用户命名空间上下文中将内核 UID/GID 转换为用户可见值，并处理无效 ID\n\n## 关键实现\n\n### UID/GID 转换机制\n\n- 所有 16 位系统调用首先使用 `low2highuid()` 或 `low2highgid()` 将传入的 16 位值转换为内核使用的 32 位 `kuid_t`/`kgid_t` 类型。\n- 查询类调用（如 `getuid16`）则通过 `from_kuid_munged()` 将内核 UID 映射到当前用户命名空间的用户可见值，再用 `high2lowuid()` 截断为 16 位返回。\n- `from_kuid_munged()` 在 UID 超出 16 位范围（>65535）时会返回 `(uid_t) -1`，确保旧程序不会收到无法处理的大值。\n\n### 用户命名空间支持\n\n- 所有转换均通过 `current_user_ns()` 获取当前进程的用户命名空间，确保在容器或用户命名空间隔离环境中正确映射 UID/GID。\n- 例如：`from_kuid_munged(cred->user_ns, cred->uid)` 将内核 UID 转换为该命名空间下的用户视角 UID。\n\n### 组列表处理\n\n- `getgroups16` 和 `setgroups16` 通过辅助函数 `groups16_to_user`/`groups16_from_user` 实现 16 位与内核 `kgid_t` 数组的双向转换。\n- `setgroups16` 在设置前调用 `groups_sort()` 对组列表排序，符合内核对 `group_info` 的要求。\n\n### 错误处理与边界检查\n\n- `setgroups16` 检查 `gidsetsize` 是否超过 `NGROUPS_MAX`，防止内存溢出。\n- `getgroups16` 在 `gidsetsize` 小于实际组数时返回 `-EINVAL`，符合 POSIX 语义。\n- 所有用户空间访问均通过 `put_user`/`get_user` 进行，失败时返回 `-EFAULT`。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/cred.h>`：访问 `struct cred` 和 `current_cred()`\n  - `<linux/highuid.h>`：提供 `low2highuid`/`high2lowuid` 等转换宏\n  - `<linux/uaccess.h>`：提供 `put_user`/`get_user` 用户空间访问接口\n  - `<linux/syscalls.h>`：使用 `SYSCALL_DEFINE` 宏定义系统调用\n  - `<linux/security.h>`：间接依赖安全模块钩子（如 `may_setgroups`）\n\n- **内核子系统依赖**：\n  - **用户命名空间**（`user_namespace`）：所有 UID/GID 转换基于当前命名空间\n  - **凭证管理**（`cred`）：读取/修改进程的 UID/GID 属性\n  - **组管理**（`group_info`）：处理附加组列表的分配、排序和设置\n  - **系统调用框架**：通过 `ksys_*` 和 `__sys_*` 内核内部接口复用主逻辑\n\n## 使用场景\n\n- **旧版二进制兼容**：运行在早期 Linux 发行版（仅支持 16 位 UID/GID）上的应用程序在现代内核上执行时，自动通过这些 16 位系统调用接口与内核交互。\n- **嵌入式或资源受限系统**：某些遗留嵌入式系统可能仍使用 16 位 UID/GID 接口以节省空间或保持 ABI 兼容。\n- **用户命名空间容器环境**：在容器中运行的旧程序可通过这些接口正确映射容器内 UID/GID 到宿主机内核表示。\n- **系统调用拦截与审计**：安全模块可通过这些封装层监控或控制对 UID/GID 的变更操作。\n\n> 注：随着 16 位 UID/GID 的淘汰，这些接口在现代系统中已极少使用，主要用于维持向后兼容性。",
      "similarity": 0.5568236112594604,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/uid16.c",
          "start_line": 114,
          "end_line": 151,
          "content": [
            "static int groups16_to_user(old_gid_t __user *grouplist,",
            "    struct group_info *group_info)",
            "{",
            "\tstruct user_namespace *user_ns = current_user_ns();",
            "\tint i;",
            "\told_gid_t group;",
            "\tkgid_t kgid;",
            "",
            "\tfor (i = 0; i < group_info->ngroups; i++) {",
            "\t\tkgid = group_info->gid[i];",
            "\t\tgroup = high2lowgid(from_kgid_munged(user_ns, kgid));",
            "\t\tif (put_user(group, grouplist+i))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int groups16_from_user(struct group_info *group_info,",
            "    old_gid_t __user *grouplist)",
            "{",
            "\tstruct user_namespace *user_ns = current_user_ns();",
            "\tint i;",
            "\told_gid_t group;",
            "\tkgid_t kgid;",
            "",
            "\tfor (i = 0; i < group_info->ngroups; i++) {",
            "\t\tif (get_user(group, grouplist+i))",
            "\t\t\treturn  -EFAULT;",
            "",
            "\t\tkgid = make_kgid(user_ns, low2highgid(group));",
            "\t\tif (!gid_valid(kgid))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tgroup_info->gid[i] = kgid;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "groups16_to_user, groups16_from_user",
          "description": "该代码块包含两个辅助函数，groups16_to_user将用户组列表中的旧16位GID转换为kgid类型并写入用户空间缓冲区，groups16_from_user则从用户空间读取旧GID转换为kgid并填充至group_info结构，确保用户组操作在旧GID与内核GID之间的双向转换。",
          "similarity": 0.50096595287323
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/uid16.c",
          "start_line": 1,
          "end_line": 113,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *\tWrapper functions for 16bit uid back compatibility. All nicely tied",
            " *\ttogether in the faint hope we can take the out in five years time.",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/notifier.h>",
            "#include <linux/reboot.h>",
            "#include <linux/prctl.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/highuid.h>",
            "#include <linux/security.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#include \"uid16.h\"",
            "",
            "SYSCALL_DEFINE3(chown16, const char __user *, filename, old_uid_t, user, old_gid_t, group)",
            "{",
            "\treturn ksys_chown(filename, low2highuid(user), low2highgid(group));",
            "}",
            "",
            "SYSCALL_DEFINE3(lchown16, const char __user *, filename, old_uid_t, user, old_gid_t, group)",
            "{",
            "\treturn ksys_lchown(filename, low2highuid(user), low2highgid(group));",
            "}",
            "",
            "SYSCALL_DEFINE3(fchown16, unsigned int, fd, old_uid_t, user, old_gid_t, group)",
            "{",
            "\treturn ksys_fchown(fd, low2highuid(user), low2highgid(group));",
            "}",
            "",
            "SYSCALL_DEFINE2(setregid16, old_gid_t, rgid, old_gid_t, egid)",
            "{",
            "\treturn __sys_setregid(low2highgid(rgid), low2highgid(egid));",
            "}",
            "",
            "SYSCALL_DEFINE1(setgid16, old_gid_t, gid)",
            "{",
            "\treturn __sys_setgid(low2highgid(gid));",
            "}",
            "",
            "SYSCALL_DEFINE2(setreuid16, old_uid_t, ruid, old_uid_t, euid)",
            "{",
            "\treturn __sys_setreuid(low2highuid(ruid), low2highuid(euid));",
            "}",
            "",
            "SYSCALL_DEFINE1(setuid16, old_uid_t, uid)",
            "{",
            "\treturn __sys_setuid(low2highuid(uid));",
            "}",
            "",
            "SYSCALL_DEFINE3(setresuid16, old_uid_t, ruid, old_uid_t, euid, old_uid_t, suid)",
            "{",
            "\treturn __sys_setresuid(low2highuid(ruid), low2highuid(euid),",
            "\t\t\t\t low2highuid(suid));",
            "}",
            "",
            "SYSCALL_DEFINE3(getresuid16, old_uid_t __user *, ruidp, old_uid_t __user *, euidp, old_uid_t __user *, suidp)",
            "{",
            "\tconst struct cred *cred = current_cred();",
            "\tint retval;",
            "\told_uid_t ruid, euid, suid;",
            "",
            "\truid = high2lowuid(from_kuid_munged(cred->user_ns, cred->uid));",
            "\teuid = high2lowuid(from_kuid_munged(cred->user_ns, cred->euid));",
            "\tsuid = high2lowuid(from_kuid_munged(cred->user_ns, cred->suid));",
            "",
            "\tif (!(retval   = put_user(ruid, ruidp)) &&",
            "\t    !(retval   = put_user(euid, euidp)))",
            "\t\tretval = put_user(suid, suidp);",
            "",
            "\treturn retval;",
            "}",
            "",
            "SYSCALL_DEFINE3(setresgid16, old_gid_t, rgid, old_gid_t, egid, old_gid_t, sgid)",
            "{",
            "\treturn __sys_setresgid(low2highgid(rgid), low2highgid(egid),",
            "\t\t\t\t low2highgid(sgid));",
            "}",
            "",
            "SYSCALL_DEFINE3(getresgid16, old_gid_t __user *, rgidp, old_gid_t __user *, egidp, old_gid_t __user *, sgidp)",
            "{",
            "\tconst struct cred *cred = current_cred();",
            "\tint retval;",
            "\told_gid_t rgid, egid, sgid;",
            "",
            "\trgid = high2lowgid(from_kgid_munged(cred->user_ns, cred->gid));",
            "\tegid = high2lowgid(from_kgid_munged(cred->user_ns, cred->egid));",
            "\tsgid = high2lowgid(from_kgid_munged(cred->user_ns, cred->sgid));",
            "",
            "\tif (!(retval   = put_user(rgid, rgidp)) &&",
            "\t    !(retval   = put_user(egid, egidp)))",
            "\t\tretval = put_user(sgid, sgidp);",
            "",
            "\treturn retval;",
            "}",
            "",
            "SYSCALL_DEFINE1(setfsuid16, old_uid_t, uid)",
            "{",
            "\treturn __sys_setfsuid(low2highuid(uid));",
            "}",
            "",
            "SYSCALL_DEFINE1(setfsgid16, old_gid_t, gid)",
            "{",
            "\treturn __sys_setfsgid(low2highgid(gid));",
            "}",
            ""
          ],
          "function_name": null,
          "description": "此代码块实现了16位UID的兼容性包装函数，将old_uid_t类型的参数转换为高位UID（通过low2highuid）后调用相应的内核函数（如ksys_chown、__sys_setuid等），并提供从高位UID还原为低位UID的逻辑（通过high2lowuid），以维护对旧应用程序的兼容性。",
          "similarity": 0.47454702854156494
        }
      ]
    }
  ]
}