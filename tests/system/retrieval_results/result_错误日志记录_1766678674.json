{
  "query": "错误日志记录",
  "timestamp": "2025-12-26 00:04:34",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/log.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:15:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\log.c`\n\n---\n\n# bpf/log.c 技术文档\n\n## 1. 文件概述\n\n`bpf/log.c` 是 Linux 内核 BPF（Berkeley Packet Filter）子系统中负责日志记录的核心实现文件。该文件为 BPF 验证器（verifier）提供灵活、高效的日志输出机制，支持将验证过程中的诊断信息输出到用户空间缓冲区或内核日志（`pr_err`）。日志系统支持两种模式：**固定模式**（`BPF_LOG_FIXED`）和**循环缓冲模式**（默认），并能处理大容量日志的截断、回绕和最终整理，确保用户获得连续、有效的验证日志。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`bpf_verifier_log_attr_valid()`**  \n  验证 `bpf_verifier_log` 结构体的属性是否合法，包括用户缓冲区指针与大小的一致性、日志级别有效性等。\n\n- **`bpf_vlog_init()`**  \n  初始化 `bpf_verifier_log` 结构体，设置日志级别、用户缓冲区指针和大小，并进行合法性校验。\n\n- **`bpf_verifier_vlog()`**  \n  核心日志写入函数，接收格式化字符串和可变参数列表，根据日志模式（固定/循环）将内容写入内核临时缓冲区并复制到用户空间，或直接输出到内核日志。\n\n- **`bpf_vlog_reset()`**  \n  重置日志写入位置（用于回溯验证路径时清理无效日志），并更新用户缓冲区对应位置为 `\\0`。\n\n- **`bpf_vlog_finalize()`**  \n  在验证结束时整理日志内容：若使用循环缓冲且发生回绕，则通过三次反转算法将日志内容原地旋转为从缓冲区开头开始的连续字符串。\n\n- **`bpf_vlog_reverse_kbuf()` / `bpf_vlog_reverse_ubuf()`**  \n  辅助函数，分别用于反转内核临时缓冲区和用户空间日志缓冲区的指定区段，支撑 `bpf_vlog_finalize()` 中的原地旋转算法。\n\n### 关键数据结构\n\n- **`struct bpf_verifier_log`**（定义在 `bpf_verifier.h` 中）  \n  包含日志级别（`level`）、用户缓冲区指针（`ubuf`）、缓冲区总大小（`len_total`）、当前写入结束位置（`end_pos`）、循环缓冲起始位置（`start_pos`）、最大日志长度（`len_max`）以及内核临时缓冲区（`kbuf`）等字段。\n\n## 3. 关键实现\n\n### 日志模式\n\n- **固定模式（`BPF_LOG_FIXED`）**：日志从缓冲区开头顺序写入，超出部分被丢弃。适用于需要完整前缀日志的场景。\n- **循环缓冲模式（默认）**：当日志超出缓冲区大小时，覆盖最早写入的内容，始终保持最新的日志。适用于关注最新错误信息的场景。\n\n### 日志写入流程\n\n1. 使用 `vscnprintf` 将格式化日志写入内核临时缓冲区 `kbuf`（大小为 `BPF_VERIFIER_TMP_LOG_SIZE`）。\n2. 若日志级别为 `BPF_LOG_KERNEL`，直接通过 `pr_err` 输出到内核日志。\n3. 否则，根据日志模式：\n   - **固定模式**：计算可写入用户缓冲区的字节数，调用 `copy_to_user`。\n   - **循环模式**：计算写入位置（可能回绕），分一或两个片段调用 `copy_to_user`。\n\n### 日志最终整理（`bpf_vlog_finalize`）\n\n当使用循环缓冲且日志发生回绕（`start_pos != 0`）时，需将日志整理为从缓冲区开头开始的连续字符串。采用**三次反转原地旋转算法**：\n1. 反转整个缓冲区；\n2. 反转前 `sublen` 字节（原尾部）；\n3. 反转后 `len_total - sublen` 字节（原头部）。  \n该算法避免了大内存分配，仅使用固定大小的内核临时缓冲区 `kbuf` 分块处理用户空间内存。\n\n### 安全与健壮性\n\n- 所有 `copy_to_user`/`copy_from_user` 操作均检查返回值，失败时置空 `ubuf` 指针以禁用后续写入。\n- 对日志长度进行溢出检查（`len_total > UINT_MAX >> 2`）。\n- 使用 `WARN_ON_ONCE` 检测非法重置位置。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<uapi/linux/btf.h>`：BTF（BPF Type Format）相关定义。\n  - `<linux/bpf.h>`：BPF 核心数据结构和常量（如 `BPF_LOG_MASK`、`BPF_LOG_KERNEL`、`BPF_LOG_FIXED`）。\n  - `<linux/bpf_verifier.h>`：`struct bpf_verifier_log` 定义及辅助宏（如 `bpf_verifier_log_needed`）。\n  - `<linux/math64.h>`：提供 `div_u64_rem` 等 64 位除法函数。\n- **内核子系统**：\n  - **BPF 验证器**：作为验证器的输出后端，由 `bpf_verifier.c` 调用。\n  - **用户空间交互**：通过 `copy_to_user`/`copy_from_user` 与用户态 BPF 加载程序（如 `libbpf`）通信。\n\n## 5. 使用场景\n\n- **BPF 程序加载验证**：当用户通过 `bpf(BPF_PROG_LOAD, ...)` 系统调用加载 BPF 程序时，内核验证器在检查程序安全性过程中调用本文件的日志函数，将详细错误或警告信息写入用户提供的日志缓冲区。\n- **调试与诊断**：开发者通过设置 `log_level` 和提供足够大的 `log_buf`，获取验证失败的具体原因（如无效指针访问、未初始化寄存器等）。\n- **内核日志输出**：当 `log_level` 设为 `BPF_LOG_KERNEL` 时，日志直接输出到内核日志（`dmesg`），用于内核开发者调试 BPF 验证器本身。\n- **资源受限环境**：循环缓冲模式允许在有限缓冲区大小下捕获最新的验证日志，适用于嵌入式或内存受限系统。",
      "similarity": 0.595210611820221,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/log.c",
          "start_line": 15,
          "end_line": 143,
          "content": [
            "static bool bpf_verifier_log_attr_valid(const struct bpf_verifier_log *log)",
            "{",
            "\t/* ubuf and len_total should both be specified (or not) together */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn false;",
            "\t/* log buf without log_level is meaningless */",
            "\tif (log->ubuf && log->level == 0)",
            "\t\treturn false;",
            "\tif (log->level & ~BPF_LOG_MASK)",
            "\t\treturn false;",
            "\tif (log->len_total > UINT_MAX >> 2)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "int bpf_vlog_init(struct bpf_verifier_log *log, u32 log_level,",
            "\t\t  char __user *log_buf, u32 log_size)",
            "{",
            "\tlog->level = log_level;",
            "\tlog->ubuf = log_buf;",
            "\tlog->len_total = log_size;",
            "",
            "\t/* log attributes have to be sane */",
            "\tif (!bpf_verifier_log_attr_valid(log))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_vlog_update_len_max(struct bpf_verifier_log *log, u32 add_len)",
            "{",
            "\t/* add_len includes terminal \\0, so no need for +1. */",
            "\tu64 len = log->end_pos + add_len;",
            "",
            "\t/* log->len_max could be larger than our current len due to",
            "\t * bpf_vlog_reset() calls, so we maintain the max of any length at any",
            "\t * previous point",
            "\t */",
            "\tif (len > UINT_MAX)",
            "\t\tlog->len_max = UINT_MAX;",
            "\telse if (len > log->len_max)",
            "\t\tlog->len_max = len;",
            "}",
            "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,",
            "\t\t       va_list args)",
            "{",
            "\tu64 cur_pos;",
            "\tu32 new_n, n;",
            "",
            "\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);",
            "",
            "\tif (log->level == BPF_LOG_KERNEL) {",
            "\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';",
            "",
            "\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tn += 1; /* include terminating zero */",
            "\tbpf_vlog_update_len_max(log, n);",
            "",
            "\tif (log->level & BPF_LOG_FIXED) {",
            "\t\t/* check if we have at least something to put into user buf */",
            "\t\tnew_n = 0;",
            "\t\tif (log->end_pos < log->len_total) {",
            "\t\t\tnew_n = min_t(u32, log->len_total - log->end_pos, n);",
            "\t\t\tlog->kbuf[new_n - 1] = '\\0';",
            "\t\t}",
            "",
            "\t\tcur_pos = log->end_pos;",
            "\t\tlog->end_pos += n - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (log->ubuf && new_n &&",
            "\t\t    copy_to_user(log->ubuf + cur_pos, log->kbuf, new_n))",
            "\t\t\tgoto fail;",
            "\t} else {",
            "\t\tu64 new_end, new_start;",
            "\t\tu32 buf_start, buf_end, new_n;",
            "",
            "\t\tnew_end = log->end_pos + n;",
            "\t\tif (new_end - log->start_pos >= log->len_total)",
            "\t\t\tnew_start = new_end - log->len_total;",
            "\t\telse",
            "\t\t\tnew_start = log->start_pos;",
            "",
            "\t\tlog->start_pos = new_start;",
            "\t\tlog->end_pos = new_end - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (!log->ubuf)",
            "\t\t\treturn;",
            "",
            "\t\tnew_n = min(n, log->len_total);",
            "\t\tcur_pos = new_end - new_n;",
            "\t\tdiv_u64_rem(cur_pos, log->len_total, &buf_start);",
            "\t\tdiv_u64_rem(new_end, log->len_total, &buf_end);",
            "\t\t/* new_end and buf_end are exclusive indices, so if buf_end is",
            "\t\t * exactly zero, then it actually points right to the end of",
            "\t\t * ubuf and there is no wrap around",
            "\t\t */",
            "\t\tif (buf_end == 0)",
            "\t\t\tbuf_end = log->len_total;",
            "",
            "\t\t/* if buf_start > buf_end, we wrapped around;",
            "\t\t * if buf_start == buf_end, then we fill ubuf completely; we",
            "\t\t * can't have buf_start == buf_end to mean that there is",
            "\t\t * nothing to write, because we always write at least",
            "\t\t * something, even if terminal '\\0'",
            "\t\t */",
            "\t\tif (buf_start < buf_end) {",
            "\t\t\t/* message fits within contiguous chunk of ubuf */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t buf_end - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t} else {",
            "\t\t\t/* message wraps around the end of ubuf, copy in two chunks */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t log->len_total - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t\tif (copy_to_user(log->ubuf,",
            "\t\t\t\t\t log->kbuf + n - buf_end,",
            "\t\t\t\t\t buf_end))",
            "\t\t\t\tgoto fail;",
            "\t\t}",
            "\t}",
            "",
            "\treturn;",
            "fail:",
            "\tlog->ubuf = NULL;",
            "}"
          ],
          "function_name": "bpf_verifier_log_attr_valid, bpf_vlog_init, bpf_vlog_update_len_max, bpf_verifier_vlog",
          "description": "实现日志属性校验、初始化、长度更新及日志写入逻辑，负责管理日志缓冲区的有效性和数据写入操作。",
          "similarity": 0.6165568828582764
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/log.c",
          "start_line": 303,
          "end_line": 462,
          "content": [
            "__printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,",
            "\t\t\t\t\t   const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(&env->log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(2, 3) void bpf_log(struct bpf_verifier_log *log,",
            "\t\t\t    const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(3, 4) void verbose_linfo(struct bpf_verifier_env *env,",
            "\t\t\t\t  u32 insn_off,",
            "\t\t\t\t  const char *prefix_fmt, ...)",
            "{",
            "\tconst struct bpf_line_info *linfo;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tlinfo = find_linfo(env, insn_off);",
            "\tif (!linfo || linfo == env->prev_linfo)",
            "\t\treturn;",
            "",
            "\tif (prefix_fmt) {",
            "\t\tva_list args;",
            "",
            "\t\tva_start(args, prefix_fmt);",
            "\t\tbpf_verifier_vlog(&env->log, prefix_fmt, args);",
            "\t\tva_end(args);",
            "\t}",
            "",
            "\tverbose(env, \"%s\\n\",",
            "\t\tltrim(btf_name_by_offset(env->prog->aux->btf,",
            "\t\t\t\t\t linfo->line_off)));",
            "",
            "\tenv->prev_linfo = linfo;",
            "}",
            "static void print_liveness(struct bpf_verifier_env *env,",
            "\t\t\t   enum bpf_reg_liveness live)",
            "{",
            "\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))",
            "\t    verbose(env, \"_\");",
            "\tif (live & REG_LIVE_READ)",
            "\t\tverbose(env, \"r\");",
            "\tif (live & REG_LIVE_WRITTEN)",
            "\t\tverbose(env, \"w\");",
            "\tif (live & REG_LIVE_DONE)",
            "\t\tverbose(env, \"D\");",
            "}",
            "static bool is_unum_decimal(u64 num)",
            "{",
            "\treturn num <= UNUM_MAX_DECIMAL;",
            "}",
            "static bool is_snum_decimal(s64 num)",
            "{",
            "\treturn num >= SNUM_MIN_DECIMAL && num <= SNUM_MAX_DECIMAL;",
            "}",
            "static void verbose_unum(struct bpf_verifier_env *env, u64 num)",
            "{",
            "\tif (is_unum_decimal(num))",
            "\t\tverbose(env, \"%llu\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "static void verbose_snum(struct bpf_verifier_env *env, s64 num)",
            "{",
            "\tif (is_snum_decimal(num))",
            "\t\tverbose(env, \"%lld\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "int tnum_strn(char *str, size_t size, struct tnum a)",
            "{",
            "\t/* print as a constant, if tnum is fully known */",
            "\tif (a.mask == 0) {",
            "\t\tif (is_unum_decimal(a.value))",
            "\t\t\treturn snprintf(str, size, \"%llu\", a.value);",
            "\t\telse",
            "\t\t\treturn snprintf(str, size, \"%#llx\", a.value);",
            "\t}",
            "\treturn snprintf(str, size, \"(%#llx; %#llx)\", a.value, a.mask);",
            "}",
            "static void print_scalar_ranges(struct bpf_verifier_env *env,",
            "\t\t\t\tconst struct bpf_reg_state *reg,",
            "\t\t\t\tconst char **sep)",
            "{",
            "\t/* For signed ranges, we want to unify 64-bit and 32-bit values in the",
            "\t * output as much as possible, but there is a bit of a complication.",
            "\t * If we choose to print values as decimals, this is natural to do,",
            "\t * because negative 64-bit and 32-bit values >= -S32_MIN have the same",
            "\t * representation due to sign extension. But if we choose to print",
            "\t * them in hex format (see is_snum_decimal()), then sign extension is",
            "\t * misleading.",
            "\t * E.g., smin=-2 and smin32=-2 are exactly the same in decimal, but in",
            "\t * hex they will be smin=0xfffffffffffffffe and smin32=0xfffffffe, two",
            "\t * very different numbers.",
            "\t * So we avoid sign extension if we choose to print values in hex.",
            "\t */",
            "\tstruct {",
            "\t\tconst char *name;",
            "\t\tu64 val;",
            "\t\tbool omit;",
            "\t} minmaxs[] = {",
            "\t\t{\"smin\",   reg->smin_value,         reg->smin_value == S64_MIN},",
            "\t\t{\"smax\",   reg->smax_value,         reg->smax_value == S64_MAX},",
            "\t\t{\"umin\",   reg->umin_value,         reg->umin_value == 0},",
            "\t\t{\"umax\",   reg->umax_value,         reg->umax_value == U64_MAX},",
            "\t\t{\"smin32\",",
            "\t\t is_snum_decimal((s64)reg->s32_min_value)",
            "\t\t\t ? (s64)reg->s32_min_value",
            "\t\t\t : (u32)reg->s32_min_value, reg->s32_min_value == S32_MIN},",
            "\t\t{\"smax32\",",
            "\t\t is_snum_decimal((s64)reg->s32_max_value)",
            "\t\t\t ? (s64)reg->s32_max_value",
            "\t\t\t : (u32)reg->s32_max_value, reg->s32_max_value == S32_MAX},",
            "\t\t{\"umin32\", reg->u32_min_value,      reg->u32_min_value == 0},",
            "\t\t{\"umax32\", reg->u32_max_value,      reg->u32_max_value == U32_MAX},",
            "\t}, *m1, *m2, *mend = &minmaxs[ARRAY_SIZE(minmaxs)];",
            "\tbool neg1, neg2;",
            "",
            "\tfor (m1 = &minmaxs[0]; m1 < mend; m1++) {",
            "\t\tif (m1->omit)",
            "\t\t\tcontinue;",
            "",
            "\t\tneg1 = m1->name[0] == 's' && (s64)m1->val < 0;",
            "",
            "\t\tverbose(env, \"%s%s=\", *sep, m1->name);",
            "\t\t*sep = \",\";",
            "",
            "\t\tfor (m2 = m1 + 2; m2 < mend; m2 += 2) {",
            "\t\t\tif (m2->omit || m2->val != m1->val)",
            "\t\t\t\tcontinue;",
            "\t\t\t/* don't mix negatives with positives */",
            "\t\t\tneg2 = m2->name[0] == 's' && (s64)m2->val < 0;",
            "\t\t\tif (neg2 != neg1)",
            "\t\t\t\tcontinue;",
            "\t\t\tm2->omit = true;",
            "\t\t\tverbose(env, \"%s=\", m2->name);",
            "\t\t}",
            "",
            "\t\tif (m1->name[0] == 's')",
            "\t\t\tverbose_snum(env, m1->val);",
            "\t\telse",
            "\t\t\tverbose_unum(env, m1->val);",
            "\t}",
            "}"
          ],
          "function_name": "bpf_verifier_log_write, bpf_log, verbose_linfo, print_liveness, is_unum_decimal, is_snum_decimal, verbose_unum, verbose_snum, tnum_strn, print_scalar_ranges",
          "description": "包含日志格式化辅助函数，支持指令信息打印、寄存器存活状态显示及数值范围解析等多样化日志输出需求。",
          "similarity": 0.6039256453514099
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/log.c",
          "start_line": 148,
          "end_line": 294,
          "content": [
            "void bpf_vlog_reset(struct bpf_verifier_log *log, u64 new_pos)",
            "{",
            "\tchar zero = 0;",
            "\tu32 pos;",
            "",
            "\tif (WARN_ON_ONCE(new_pos > log->end_pos))",
            "\t\treturn;",
            "",
            "\tif (!bpf_verifier_log_needed(log) || log->level == BPF_LOG_KERNEL)",
            "\t\treturn;",
            "",
            "\t/* if position to which we reset is beyond current log window,",
            "\t * then we didn't preserve any useful content and should adjust",
            "\t * start_pos to end up with an empty log (start_pos == end_pos)",
            "\t */",
            "\tlog->end_pos = new_pos;",
            "\tif (log->end_pos < log->start_pos)",
            "\t\tlog->start_pos = log->end_pos;",
            "",
            "\tif (!log->ubuf)",
            "\t\treturn;",
            "",
            "\tif (log->level & BPF_LOG_FIXED)",
            "\t\tpos = log->end_pos + 1;",
            "\telse",
            "\t\tdiv_u64_rem(new_pos, log->len_total, &pos);",
            "",
            "\tif (pos < log->len_total && put_user(zero, log->ubuf + pos))",
            "\t\tlog->ubuf = NULL;",
            "}",
            "static void bpf_vlog_reverse_kbuf(char *buf, int len)",
            "{",
            "\tint i, j;",
            "",
            "\tfor (i = 0, j = len - 1; i < j; i++, j--)",
            "\t\tswap(buf[i], buf[j]);",
            "}",
            "static int bpf_vlog_reverse_ubuf(struct bpf_verifier_log *log, int start, int end)",
            "{",
            "\t/* we split log->kbuf into two equal parts for both ends of array */",
            "\tint n = sizeof(log->kbuf) / 2, nn;",
            "\tchar *lbuf = log->kbuf, *rbuf = log->kbuf + n;",
            "",
            "\t/* Read ubuf's section [start, end) two chunks at a time, from left",
            "\t * and right side; within each chunk, swap all the bytes; after that",
            "\t * reverse the order of lbuf and rbuf and write result back to ubuf.",
            "\t * This way we'll end up with swapped contents of specified",
            "\t * [start, end) ubuf segment.",
            "\t */",
            "\twhile (end - start > 1) {",
            "\t\tnn = min(n, (end - start ) / 2);",
            "",
            "\t\tif (copy_from_user(lbuf, log->ubuf + start, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_from_user(rbuf, log->ubuf + end - nn, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbpf_vlog_reverse_kbuf(lbuf, nn);",
            "\t\tbpf_vlog_reverse_kbuf(rbuf, nn);",
            "",
            "\t\t/* we write lbuf to the right end of ubuf, while rbuf to the",
            "\t\t * left one to end up with properly reversed overall ubuf",
            "\t\t */",
            "\t\tif (copy_to_user(log->ubuf + start, rbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_to_user(log->ubuf + end - nn, lbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tstart += nn;",
            "\t\tend -= nn;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int bpf_vlog_finalize(struct bpf_verifier_log *log, u32 *log_size_actual)",
            "{",
            "\tu32 sublen;",
            "\tint err;",
            "",
            "\t*log_size_actual = 0;",
            "\tif (!log || log->level == 0 || log->level == BPF_LOG_KERNEL)",
            "\t\treturn 0;",
            "",
            "\tif (!log->ubuf)",
            "\t\tgoto skip_log_rotate;",
            "\t/* If we never truncated log, there is nothing to move around. */",
            "\tif (log->start_pos == 0)",
            "\t\tgoto skip_log_rotate;",
            "",
            "\t/* Otherwise we need to rotate log contents to make it start from the",
            "\t * buffer beginning and be a continuous zero-terminated string. Note",
            "\t * that if log->start_pos != 0 then we definitely filled up entire log",
            "\t * buffer with no gaps, and we just need to shift buffer contents to",
            "\t * the left by (log->start_pos % log->len_total) bytes.",
            "\t *",
            "\t * Unfortunately, user buffer could be huge and we don't want to",
            "\t * allocate temporary kernel memory of the same size just to shift",
            "\t * contents in a straightforward fashion. Instead, we'll be clever and",
            "\t * do in-place array rotation. This is a leetcode-style problem, which",
            "\t * could be solved by three rotations.",
            "\t *",
            "\t * Let's say we have log buffer that has to be shifted left by 7 bytes",
            "\t * (spaces and vertical bar is just for demonstrative purposes):",
            "\t *   E F G H I J K | A B C D",
            "\t *",
            "\t * First, we reverse entire array:",
            "\t *   D C B A | K J I H G F E",
            "\t *",
            "\t * Then we rotate first 4 bytes (DCBA) and separately last 7 bytes",
            "\t * (KJIHGFE), resulting in a properly rotated array:",
            "\t *   A B C D | E F G H I J K",
            "\t *",
            "\t * We'll utilize log->kbuf to read user memory chunk by chunk, swap",
            "\t * bytes, and write them back. Doing it byte-by-byte would be",
            "\t * unnecessarily inefficient. Altogether we are going to read and",
            "\t * write each byte twice, for total 4 memory copies between kernel and",
            "\t * user space.",
            "\t */",
            "",
            "\t/* length of the chopped off part that will be the beginning;",
            "\t * len(ABCD) in the example above",
            "\t */",
            "\tdiv_u64_rem(log->start_pos, log->len_total, &sublen);",
            "\tsublen = log->len_total - sublen;",
            "",
            "\terr = bpf_vlog_reverse_ubuf(log, 0, log->len_total);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, 0, sublen);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, sublen, log->len_total);",
            "\tif (err)",
            "\t\tlog->ubuf = NULL;",
            "",
            "skip_log_rotate:",
            "\t*log_size_actual = log->len_max;",
            "",
            "\t/* properly initialized log has either both ubuf!=NULL and len_total>0",
            "\t * or ubuf==NULL and len_total==0, so if this condition doesn't hold,",
            "\t * we got a fault somewhere along the way, so report it back",
            "\t */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn -EFAULT;",
            "",
            "\t/* did truncation actually happen? */",
            "\tif (log->ubuf && log->len_max > log->len_total)",
            "\t\treturn -ENOSPC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_vlog_reset, bpf_vlog_reverse_kbuf, bpf_vlog_reverse_ubuf, bpf_vlog_finalize",
          "description": "提供日志重置、缓冲区反转及最终化功能，通过旋转日志缓冲区实现连续日志存储并保证数据完整性。",
          "similarity": 0.5687318444252014
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/log.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com",
            " * Copyright (c) 2016 Facebook",
            " * Copyright (c) 2018 Covalent IO, Inc. http://covalent.io",
            " */",
            "#include <uapi/linux/btf.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/math64.h>",
            "",
            "#define verbose(env, fmt, args...) bpf_verifier_log_write(env, fmt, ##args)",
            ""
          ],
          "function_name": null,
          "description": "定义了BPF验证器日志相关的头文件和宏，其中`verbose`宏用于向内核日志写入验证器相关信息。",
          "similarity": 0.5497122406959534
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/log.c",
          "start_line": 814,
          "end_line": 830,
          "content": [
            "static inline u32 vlog_alignment(u32 pos)",
            "{",
            "\treturn round_up(max(pos + BPF_LOG_MIN_ALIGNMENT / 2, BPF_LOG_ALIGNMENT),",
            "\t\t\tBPF_LOG_MIN_ALIGNMENT) - pos - 1;",
            "}",
            "void print_insn_state(struct bpf_verifier_env *env, const struct bpf_verifier_state *vstate,",
            "\t\t      u32 frameno)",
            "{",
            "\tif (env->prev_log_pos && env->prev_log_pos == env->log.end_pos) {",
            "\t\t/* remove new line character */",
            "\t\tbpf_vlog_reset(&env->log, env->prev_log_pos - 1);",
            "\t\tverbose(env, \"%*c;\", vlog_alignment(env->prev_insn_print_pos), ' ');",
            "\t} else {",
            "\t\tverbose(env, \"%d:\", env->insn_idx);",
            "\t}",
            "\tprint_verifier_state(env, vstate, frameno, false);",
            "}"
          ],
          "function_name": "vlog_alignment, print_insn_state",
          "description": "该代码片段实现BPF验证日志的格式化输出控制。vlog_alignment函数计算日志记录时所需的对齐空格数量，通过取当前位置到下一个对齐边界的距离实现。print_insn_state函数负责在验证过程中按需输出指令状态信息，通过判断日志位置状态决定是否重置日志并添加对齐符号，但存在依赖未展示的宏定义和print_verifier_state函数，上下文不完整。",
          "similarity": 0.5494953989982605
        }
      ]
    },
    {
      "source_file": "kernel/module/stats.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:06:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\stats.c`\n\n---\n\n# `module/stats.c` 技术文档\n\n## 1. 文件概述\n\n`module/stats.c` 是 Linux 内核模块子系统中用于收集和跟踪模块加载失败相关调试统计信息的实现文件。当启用 `CONFIG_MODULE_STATS` 配置选项时，该文件提供对模块加载过程中因各种原因失败所导致的虚拟内存浪费情况的监控能力。其主要目标是帮助开发者和系统维护人员识别和优化模块加载过程中的资源浪费问题，特别是在系统启动阶段因重复加载或竞争条件导致的无效内存分配。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`dup_failed_modules`**  \n  全局静态链表（`LIST_HEAD`），用于记录因模块名称重复（已加载或正在处理）而加载失败的模块实例。该链表帮助追踪因用户空间竞争或内核并发加载导致的无效加载尝试。\n\n### 调试统计计数器（通过 debugfs 暴露）\n\n- **`total_mod_size`**：系统处理过的所有模块占用的总字节数。\n- **`total_text_size`**：所有模块的 `.text` 和 `.init.text` ELF 节区大小总和。\n- **`invalid_kread_bytes`**：因 `kernel_read_file_from_fd()` 阶段失败而浪费的 `vmalloc()` 分配字节数。\n- **`invalid_decompress_bytes`**：模块解压过程中因失败而浪费的 `vmap()` 分配字节数。\n- **`invalid_becoming_bytes`**：在 `early_mod_check()` 之后、`layout_and_allocate()` 之前失败所浪费的内存总量（含解压和读取阶段）。\n- **`invalid_mod_bytes`**：在 `layout_and_allocate()` 之后（即模块已分配最终内存布局）因失败而释放的内存总量。\n\n> 注：文档片段在 `invalid_mod_bytes` 处截断，但根据上下文可推断其用于统计最晚阶段（模块结构体已分配）的失败内存开销。\n\n## 3. 关键实现\n\n### 模块加载失败的三阶段内存模型\n\n模块加载过程中的内存分配分为三个关键阶段，每个阶段失败对应不同的统计计数器：\n\n1. **阶段 a**：`kernel_read_file_from_fd()` 使用 `vmalloc()` 读取模块文件。\n2. **阶段 b**（可选）：若模块为压缩格式，解压后通过 `vmap()` 映射解压内容，原始读取缓冲区随即释放。\n3. **阶段 c**：`layout_and_allocate()` 为模块分配最终运行时内存布局（可能使用 `vzalloc()` 或架构特定的 `vmalloc` 变体）。\n\n失败统计遵循“最晚失败点”原则：仅在导致失败的最晚阶段对应的计数器中累加**该次加载尝试中所有已分配并最终释放的内存总量**。\n\n### 重复模块加载失败分类\n\n针对因模块名重复导致的失败，细分为两类：\n\n- **`FAIL_DUP_MOD_BECOMING`**：在 `early_mod_check()` 末尾检测到重复（尚未调用 `layout_and_allocate()`）。\n  - 有解压：浪费 2 次分配（`kread` + `vmap`）\n  - 无解压：浪费 1 次分配（`kread`）\n- **`FAIL_DUP_MOD_LOAD`**：在 `add_unformed_module()` 阶段检测到重复（已执行 `layout_and_allocate()`）。\n  - 有解压：浪费 3 次分配\n  - 无解压：浪费 2 次分配\n\n### 原子计数与性能考量\n\n所有统计计数器均使用**原子操作**更新，以避免锁竞争、死锁及性能开销，确保在高并发模块加载场景下的低延迟。\n\n### debugfs 集成\n\n统计信息通过 **debugfs** 文件系统暴露，便于用户空间工具（如 `cat /sys/kernel/debug/...`）实时监控模块加载效率和内存浪费情况。\n\n## 4. 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/module.h>`：模块核心接口\n  - `<linux/debugfs.h>`：调试文件系统支持\n  - `<linux/vmalloc.h>` 相关（通过 `slab.h`, `math.h` 等间接依赖）：虚拟内存分配\n  - `<linux/rculist.h>`：RCU 安全链表操作\n- **内部依赖**：\n  - `\"internal.h\"`：模块子系统内部头文件，包含未公开的模块管理结构和函数\n- **配置依赖**：\n  - 仅在 `CONFIG_MODULE_STATS=y` 时编译生效\n\n## 5. 使用场景\n\n- **系统启动优化**：分析启动过程中因用户空间并发调用 `modprobe` 或 `request_module()` 导致的重复模块加载，减少不必要的 `vmalloc` 压力。\n- **内存压力诊断**：在虚拟地址空间受限的架构（如 x86 默认 128 MiB vmalloc 空间）上，定位模块加载失败是否加剧内存碎片或耗尽问题。\n- **内核/用户空间协同改进**：通过 `dup_failed_modules` 链表识别用户空间加载逻辑缺陷（如未检查 `/sys/module` 即重复加载），推动工具链优化。\n- **安全与验证调试**：监控因签名验证（`module_sig_check`）、ELF 格式错误或黑名单策略导致的早期失败，评估安全机制开销。",
      "similarity": 0.5742358565330505,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/stats.c",
          "start_line": 220,
          "end_line": 385,
          "content": [
            "void mod_stat_bump_invalid(struct load_info *info, int flags)",
            "{",
            "\tatomic_long_add(info->len * 2, &invalid_mod_bytes);",
            "\tatomic_inc(&failed_load_modules);",
            "#if defined(CONFIG_MODULE_DECOMPRESS)",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tatomic_long_add(info->compressed_len, &invalid_mod_bytes);",
            "#endif",
            "}",
            "void mod_stat_bump_becoming(struct load_info *info, int flags)",
            "{",
            "\tatomic_inc(&failed_becoming);",
            "\tatomic_long_add(info->len, &invalid_becoming_bytes);",
            "#if defined(CONFIG_MODULE_DECOMPRESS)",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tatomic_long_add(info->compressed_len, &invalid_becoming_bytes);",
            "#endif",
            "}",
            "int try_add_failed_module(const char *name, enum fail_dup_mod_reason reason)",
            "{",
            "\tstruct mod_fail_load *mod_fail;",
            "",
            "\tlist_for_each_entry_rcu(mod_fail, &dup_failed_modules, list,",
            "\t\t\t\tlockdep_is_held(&module_mutex)) {",
            "\t\tif (!strcmp(mod_fail->name, name)) {",
            "\t\t\tatomic_long_inc(&mod_fail->count);",
            "\t\t\t__set_bit(reason, &mod_fail->dup_fail_mask);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tmod_fail = kzalloc(sizeof(*mod_fail), GFP_KERNEL);",
            "\tif (!mod_fail)",
            "\t\treturn -ENOMEM;",
            "\tmemcpy(mod_fail->name, name, strlen(name));",
            "\t__set_bit(reason, &mod_fail->dup_fail_mask);",
            "\tatomic_long_inc(&mod_fail->count);",
            "\tlist_add_rcu(&mod_fail->list, &dup_failed_modules);",
            "out:",
            "\treturn 0;",
            "}",
            "static ssize_t read_file_mod_stats(struct file *file, char __user *user_buf,",
            "\t\t\t\t   size_t count, loff_t *ppos)",
            "{",
            "\tstruct mod_fail_load *mod_fail;",
            "\tunsigned int len, size, count_failed = 0;",
            "\tchar *buf;",
            "\tint ret;",
            "\tu32 live_mod_count, fkreads, fdecompress, fbecoming, floads;",
            "\tunsigned long total_size, text_size, ikread_bytes, ibecoming_bytes,",
            "\t\tidecompress_bytes, imod_bytes, total_virtual_lost;",
            "",
            "\tlive_mod_count = atomic_read(&modcount);",
            "\tfkreads = atomic_read(&failed_kreads);",
            "\tfdecompress = atomic_read(&failed_decompress);",
            "\tfbecoming = atomic_read(&failed_becoming);",
            "\tfloads = atomic_read(&failed_load_modules);",
            "",
            "\ttotal_size = atomic_long_read(&total_mod_size);",
            "\ttext_size = atomic_long_read(&total_text_size);",
            "\tikread_bytes = atomic_long_read(&invalid_kread_bytes);",
            "\tidecompress_bytes = atomic_long_read(&invalid_decompress_bytes);",
            "\tibecoming_bytes = atomic_long_read(&invalid_becoming_bytes);",
            "\timod_bytes = atomic_long_read(&invalid_mod_bytes);",
            "",
            "\ttotal_virtual_lost = ikread_bytes + idecompress_bytes + ibecoming_bytes + imod_bytes;",
            "",
            "\tsize = MAX_PREAMBLE + min((unsigned int)(floads + fbecoming),",
            "\t\t\t\t  (unsigned int)MAX_FAILED_MOD_PRINT) * MAX_BYTES_PER_MOD;",
            "\tbuf = kzalloc(size, GFP_KERNEL);",
            "\tif (buf == NULL)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* The beginning of our debug preamble */",
            "\tlen = scnprintf(buf, size, \"%25s\\t%u\\n\", \"Mods ever loaded\", live_mod_count);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on kread\", fkreads);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on decompress\",",
            "\t\t\t fdecompress);",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on becoming\", fbecoming);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on load\", floads);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Total module size\", total_size);",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Total mod text size\", text_size);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed kread bytes\", ikread_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed decompress bytes\",",
            "\t\t\t idecompress_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed becoming bytes\", ibecoming_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed kmod bytes\", imod_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Virtual mem wasted bytes\", total_virtual_lost);",
            "",
            "\tif (live_mod_count && total_size) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Average mod size\",",
            "\t\t\t\t DIV_ROUND_UP(total_size, live_mod_count));",
            "\t}",
            "",
            "\tif (live_mod_count && text_size) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Average mod text size\",",
            "\t\t\t\t DIV_ROUND_UP(text_size, live_mod_count));",
            "\t}",
            "",
            "\t/*",
            "\t * We use WARN_ON_ONCE() for the counters to ensure we always have parity",
            "\t * for keeping tabs on a type of failure with one type of byte counter.",
            "\t * The counters for imod_bytes does not increase for fkreads failures",
            "\t * for example, and so on.",
            "\t */",
            "",
            "\tWARN_ON_ONCE(ikread_bytes && !fkreads);",
            "\tif (fkreads && ikread_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Avg fail kread bytes\",",
            "\t\t\t\t DIV_ROUND_UP(ikread_bytes, fkreads));",
            "\t}",
            "",
            "\tWARN_ON_ONCE(ibecoming_bytes && !fbecoming);",
            "\tif (fbecoming && ibecoming_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Avg fail becoming bytes\",",
            "\t\t\t\t DIV_ROUND_UP(ibecoming_bytes, fbecoming));",
            "\t}",
            "",
            "\tWARN_ON_ONCE(idecompress_bytes && !fdecompress);",
            "\tif (fdecompress && idecompress_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Avg fail decomp bytes\",",
            "\t\t\t\t DIV_ROUND_UP(idecompress_bytes, fdecompress));",
            "\t}",
            "",
            "\tWARN_ON_ONCE(imod_bytes && !floads);",
            "\tif (floads && imod_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Average fail load bytes\",",
            "\t\t\t\t DIV_ROUND_UP(imod_bytes, floads));",
            "\t}",
            "",
            "\t/* End of our debug preamble header. */",
            "",
            "\t/* Catch when we've gone beyond our expected preamble */",
            "\tWARN_ON_ONCE(len >= MAX_PREAMBLE);",
            "",
            "\tif (list_empty(&dup_failed_modules))",
            "\t\tgoto out;",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"Duplicate failed modules:\\n\");",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%15s\\t%25s\\n\",",
            "\t\t\t \"Module-name\", \"How-many-times\", \"Reason\");",
            "\tmutex_lock(&module_mutex);",
            "",
            "",
            "\tlist_for_each_entry_rcu(mod_fail, &dup_failed_modules, list) {",
            "\t\tif (WARN_ON_ONCE(++count_failed >= MAX_FAILED_MOD_PRINT))",
            "\t\t\tgoto out_unlock;",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%15lu\\t%25s\\n\", mod_fail->name,",
            "\t\t\t\t atomic_long_read(&mod_fail->count), mod_fail_to_str(mod_fail));",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&module_mutex);",
            "out:",
            "\tret = simple_read_from_buffer(user_buf, count, ppos, buf, len);",
            "\tkfree(buf);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "mod_stat_bump_invalid, mod_stat_bump_becoming, try_add_failed_module, read_file_mod_stats",
          "description": "实现模块加载失败统计的更新逻辑与导出接口，包含失败计数器递增、失败模块记录及调试信息格式化输出功能",
          "similarity": 0.6187795400619507
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/stats.c",
          "start_line": 411,
          "end_line": 429,
          "content": [
            "static int __init module_stats_init(void)",
            "{",
            "\tmod_debug_add_ulong(total_mod_size);",
            "\tmod_debug_add_ulong(total_text_size);",
            "\tmod_debug_add_ulong(invalid_kread_bytes);",
            "\tmod_debug_add_ulong(invalid_decompress_bytes);",
            "\tmod_debug_add_ulong(invalid_becoming_bytes);",
            "\tmod_debug_add_ulong(invalid_mod_bytes);",
            "",
            "\tmod_debug_add_atomic(modcount);",
            "\tmod_debug_add_atomic(failed_kreads);",
            "\tmod_debug_add_atomic(failed_decompress);",
            "\tmod_debug_add_atomic(failed_becoming);",
            "\tmod_debug_add_atomic(failed_load_modules);",
            "",
            "\tdebugfs_create_file(\"stats\", 0400, mod_debugfs_root, mod_debugfs_root, &fops_mod_stats);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "module_stats_init",
          "description": "初始化模块统计信息到debugfs系统，注册统计文件节点以支持通过/proc/self/debugfs接口访问模块加载统计数据",
          "similarity": 0.5476411581039429
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/stats.c",
          "start_line": 1,
          "end_line": 219,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Debugging module statistics.",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <uapi/linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/math.h>",
            "",
            "#include \"internal.h\"",
            "",
            "/**",
            " * DOC: module debugging statistics overview",
            " *",
            " * Enabling CONFIG_MODULE_STATS enables module debugging statistics which",
            " * are useful to monitor and root cause memory pressure issues with module",
            " * loading. These statistics are useful to allow us to improve production",
            " * workloads.",
            " *",
            " * The current module debugging statistics supported help keep track of module",
            " * loading failures to enable improvements either for kernel module auto-loading",
            " * usage (request_module()) or interactions with userspace. Statistics are",
            " * provided to track all possible failures in the finit_module() path and memory",
            " * wasted in this process space.  Each of the failure counters are associated",
            " * to a type of module loading failure which is known to incur a certain amount",
            " * of memory allocation loss. In the worst case loading a module will fail after",
            " * a 3 step memory allocation process:",
            " *",
            " *   a) memory allocated with kernel_read_file_from_fd()",
            " *   b) module decompression processes the file read from",
            " *      kernel_read_file_from_fd(), and vmap() is used to map",
            " *      the decompressed module to a new local buffer which represents",
            " *      a copy of the decompressed module passed from userspace. The buffer",
            " *      from kernel_read_file_from_fd() is freed right away.",
            " *   c) layout_and_allocate() allocates space for the final resting",
            " *      place where we would keep the module if it were to be processed",
            " *      successfully.",
            " *",
            " * If a failure occurs after these three different allocations only one",
            " * counter will be incremented with the summation of the allocated bytes freed",
            " * incurred during this failure. Likewise, if module loading failed only after",
            " * step b) a separate counter is used and incremented for the bytes freed and",
            " * not used during both of those allocations.",
            " *",
            " * Virtual memory space can be limited, for example on x86 virtual memory size",
            " * defaults to 128 MiB. We should strive to limit and avoid wasting virtual",
            " * memory allocations when possible. These module debugging statistics help",
            " * to evaluate how much memory is being wasted on bootup due to module loading",
            " * failures.",
            " *",
            " * All counters are designed to be incremental. Atomic counters are used so to",
            " * remain simple and avoid delays and deadlocks.",
            " */",
            "",
            "/**",
            " * DOC: dup_failed_modules - tracks duplicate failed modules",
            " *",
            " * Linked list of modules which failed to be loaded because an already existing",
            " * module with the same name was already being processed or already loaded.",
            " * The finit_module() system call incurs heavy virtual memory allocations. In",
            " * the worst case an finit_module() system call can end up allocating virtual",
            " * memory 3 times:",
            " *",
            " *   1) kernel_read_file_from_fd() call uses vmalloc()",
            " *   2) optional module decompression uses vmap()",
            " *   3) layout_and allocate() can use vzalloc() or an arch specific variation of",
            " *      vmalloc to deal with ELF sections requiring special permissions",
            " *",
            " * In practice on a typical boot today most finit_module() calls fail due to",
            " * the module with the same name already being loaded or about to be processed.",
            " * All virtual memory allocated to these failed modules will be freed with",
            " * no functional use.",
            " *",
            " * To help with this the dup_failed_modules allows us to track modules which",
            " * failed to load due to the fact that a module was already loaded or being",
            " * processed.  There are only two points at which we can fail such calls,",
            " * we list them below along with the number of virtual memory allocation",
            " * calls:",
            " *",
            " *   a) FAIL_DUP_MOD_BECOMING: at the end of early_mod_check() before",
            " *\tlayout_and_allocate().",
            " *\t- with module decompression: 2 virtual memory allocation calls",
            " *\t- without module decompression: 1 virtual memory allocation calls",
            " *   b) FAIL_DUP_MOD_LOAD: after layout_and_allocate() on add_unformed_module()",
            " *   \t- with module decompression 3 virtual memory allocation calls",
            " *   \t- without module decompression 2 virtual memory allocation calls",
            " *",
            " * We should strive to get this list to be as small as possible. If this list",
            " * is not empty it is a reflection of possible work or optimizations possible",
            " * either in-kernel or in userspace.",
            " */",
            "static LIST_HEAD(dup_failed_modules);",
            "",
            "/**",
            " * DOC: module statistics debugfs counters",
            " *",
            " * The total amount of wasted virtual memory allocation space during module",
            " * loading can be computed by adding the total from the summation:",
            " *",
            " *   * @invalid_kread_bytes +",
            " *     @invalid_decompress_bytes +",
            " *     @invalid_becoming_bytes +",
            " *     @invalid_mod_bytes",
            " *",
            " * The following debugfs counters are available to inspect module loading",
            " * failures:",
            " *",
            " *   * total_mod_size: total bytes ever used by all modules we've dealt with on",
            " *     this system",
            " *   * total_text_size: total bytes of the .text and .init.text ELF section",
            " *     sizes we've dealt with on this system",
            " *   * invalid_kread_bytes: bytes allocated and then freed on failures which",
            " *     happen due to the initial kernel_read_file_from_fd(). kernel_read_file_from_fd()",
            " *     uses vmalloc(). These should typically not happen unless your system is",
            " *     under memory pressure.",
            " *   * invalid_decompress_bytes: number of bytes allocated and freed due to",
            " *     memory allocations in the module decompression path that use vmap().",
            " *     These typically should not happen unless your system is under memory",
            " *     pressure.",
            " *   * invalid_becoming_bytes: total number of bytes allocated and freed used",
            " *     used to read the kernel module userspace wants us to read before we",
            " *     promote it to be processed to be added to our @modules linked list. These",
            " *     failures can happen if we had a check in between a successful kernel_read_file_from_fd()",
            " *     call and right before we allocate the our private memory for the module",
            " *     which would be kept if the module is successfully loaded. The most common",
            " *     reason for this failure is when userspace is racing to load a module",
            " *     which it does not yet see loaded. The first module to succeed in",
            " *     add_unformed_module() will add a module to our &modules list and",
            " *     subsequent loads of modules with the same name will error out at the",
            " *     end of early_mod_check(). The check for module_patient_check_exists()",
            " *     at the end of early_mod_check() prevents duplicate allocations",
            " *     on layout_and_allocate() for modules already being processed. These",
            " *     duplicate failed modules are non-fatal, however they typically are",
            " *     indicative of userspace not seeing a module in userspace loaded yet and",
            " *     unnecessarily trying to load a module before the kernel even has a chance",
            " *     to begin to process prior requests. Although duplicate failures can be",
            " *     non-fatal, we should try to reduce vmalloc() pressure proactively, so",
            " *     ideally after boot this will be close to as 0 as possible.  If module",
            " *     decompression was used we also add to this counter the cost of the",
            " *     initial kernel_read_file_from_fd() of the compressed module. If module",
            " *     decompression was not used the value represents the total allocated and",
            " *     freed bytes in kernel_read_file_from_fd() calls for these type of",
            " *     failures. These failures can occur because:",
            " *",
            " *    * module_sig_check() - module signature checks",
            " *    * elf_validity_cache_copy() - some ELF validation issue",
            " *    * early_mod_check():",
            " *",
            " *      * blacklisting",
            " *      * failed to rewrite section headers",
            " *      * version magic",
            " *      * live patch requirements didn't check out",
            " *      * the module was detected as being already present",
            " *",
            " *   * invalid_mod_bytes: these are the total number of bytes allocated and",
            " *     freed due to failures after we did all the sanity checks of the module",
            " *     which userspace passed to us and after our first check that the module",
            " *     is unique.  A module can still fail to load if we detect the module is",
            " *     loaded after we allocate space for it with layout_and_allocate(), we do",
            " *     this check right before processing the module as live and run its",
            " *     initialization routines. Note that you have a failure of this type it",
            " *     also means the respective kernel_read_file_from_fd() memory space was",
            " *     also freed and not used, and so we increment this counter with twice",
            " *     the size of the module. Additionally if you used module decompression",
            " *     the size of the compressed module is also added to this counter.",
            " *",
            " *  * modcount: how many modules we've loaded in our kernel life time",
            " *  * failed_kreads: how many modules failed due to failed kernel_read_file_from_fd()",
            " *  * failed_decompress: how many failed module decompression attempts we've had.",
            " *    These really should not happen unless your compression / decompression",
            " *    might be broken.",
            " *  * failed_becoming: how many modules failed after we kernel_read_file_from_fd()",
            " *    it and before we allocate memory for it with layout_and_allocate(). This",
            " *    counter is never incremented if you manage to validate the module and",
            " *    call layout_and_allocate() for it.",
            " *  * failed_load_modules: how many modules failed once we've allocated our",
            " *    private space for our module using layout_and_allocate(). These failures",
            " *    should hopefully mostly be dealt with already. Races in theory could",
            " *    still exist here, but it would just mean the kernel had started processing",
            " *    two threads concurrently up to early_mod_check() and one thread won.",
            " *    These failures are good signs the kernel or userspace is doing something",
            " *    seriously stupid or that could be improved. We should strive to fix these,",
            " *    but it is perhaps not easy to fix them. A recent example are the modules",
            " *    requests incurred for frequency modules, a separate module request was",
            " *    being issued for each CPU on a system.",
            " */",
            "",
            "atomic_long_t total_mod_size;",
            "atomic_long_t total_text_size;",
            "atomic_long_t invalid_kread_bytes;",
            "atomic_long_t invalid_decompress_bytes;",
            "static atomic_long_t invalid_becoming_bytes;",
            "static atomic_long_t invalid_mod_bytes;",
            "atomic_t modcount;",
            "atomic_t failed_kreads;",
            "atomic_t failed_decompress;",
            "static atomic_t failed_becoming;",
            "static atomic_t failed_load_modules;",
            "",
            "static const char *mod_fail_to_str(struct mod_fail_load *mod_fail)",
            "{",
            "\tif (test_bit(FAIL_DUP_MOD_BECOMING, &mod_fail->dup_fail_mask) &&",
            "\t    test_bit(FAIL_DUP_MOD_LOAD, &mod_fail->dup_fail_mask))",
            "\t\treturn \"Becoming & Load\";",
            "\tif (test_bit(FAIL_DUP_MOD_BECOMING, &mod_fail->dup_fail_mask))",
            "\t\treturn \"Becoming\";",
            "\tif (test_bit(FAIL_DUP_MOD_LOAD, &mod_fail->dup_fail_mask))",
            "\t\treturn \"Load\";",
            "\treturn \"Bug-on-stats\";",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义模块调试统计相关的原子计数器和链表结构，用于追踪模块加载失败导致的虚拟内存浪费情况，包括不同阶段的内存分配失败统计及重复模块列表管理",
          "similarity": 0.4647367596626282
        }
      ]
    },
    {
      "source_file": "kernel/trace/error_report-traces.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:00:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\error_report-traces.c`\n\n---\n\n# trace/error_report-traces.c 技术文档\n\n## 1. 文件概述\n\n该文件是 Linux 内核中用于定义和导出错误报告（error reporting）相关跟踪点（tracepoints）的核心实现。它通过内核的跟踪基础设施，为内核中发生的错误事件提供标准化的追踪接口，便于调试、监控和诊断系统错误。文件主要作用是实例化 `error_report.h` 中声明的跟踪点，并将关键跟踪点符号导出供其他内核模块使用。\n\n## 2. 核心功能\n\n- **跟踪点实例化**：通过定义 `CREATE_TRACE_POINTS` 宏并包含 `<trace/events/error_report.h>`，在编译时生成实际的跟踪点代码。\n- **符号导出**：使用 `EXPORT_TRACEPOINT_SYMBOL_GPL()` 宏将 `error_report_end` 跟踪点符号导出，允许 GPL 兼容的内核模块在运行时引用该跟踪点。\n\n## 3. 关键实现\n\n- **`CREATE_TRACE_POINTS` 宏**：该宏是内核跟踪点机制的关键。当在包含 trace event 头文件前定义此宏时，会触发头文件中对跟踪点结构体、函数和静态变量的实际定义，而非仅声明。这确保了跟踪点在链接时有唯一的实现。\n- **`EXPORT_TRACEPOINT_SYMBOL_GPL`**：此宏将指定的跟踪点符号（此处为 `error_report_end`）导出到内核符号表，并限制仅 GPL 许可的模块可使用。这是为了维护内核的许可证合规性，同时支持模块化错误追踪功能。\n\n## 4. 依赖关系\n\n- **依赖头文件**：`<trace/events/error_report.h>` —— 该头文件定义了错误报告跟踪点的声明、参数格式及事件结构。\n- **依赖内核子系统**：依赖内核的 **ftrace** 跟踪框架，该框架提供底层的动态跟踪点注册、启用/禁用及回调机制。\n- **被依赖模块**：任何需要监听或触发错误报告事件的内核模块（如 RAS（Reliability, Availability, Serviceability）子系统、EDAC（Error Detection and Correction）驱动等）可能依赖此文件导出的符号。\n\n## 5. 使用场景\n\n- **内核错误诊断**：当内核检测到硬件错误（如内存 ECC 错误、PCIe AER 错误）或软件异常时，可通过调用 `trace_error_report_end()` 等跟踪点记录错误上下文。\n- **动态追踪与监控**：系统管理员或开发者可通过 ftrace、perf 或 trace-cmd 等工具启用 `error_report` 相关事件，实时捕获错误发生的时间、位置及附加信息。\n- **RAS 子系统集成**：作为内核 RAS 功能的一部分，该跟踪点为统一的错误上报机制提供标准化接口，便于上层工具（如 rasdaemon）收集和分析系统可靠性数据。",
      "similarity": 0.5702834725379944,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/error_report-traces.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Error reporting trace points.",
            " *",
            " * Copyright (C) 2021, Google LLC.",
            " */",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/error_report.h>",
            "",
            "EXPORT_TRACEPOINT_SYMBOL_GPL(error_report_end);"
          ],
          "function_name": null,
          "description": "该代码片段定义了用于记录系统错误事件的跟踪点（tracepoints），通过包含`error_report.h`头文件实现对`error_report_end`跟踪点的导出。作为跟踪点定义的一部分，它为内核提供了一种在发生错误时生成可追踪日志的机制。由于代码片段未展示完整的跟踪点定义逻辑，需结合相关头文件以获取完整上下文。",
          "similarity": 0.6418296098709106
        }
      ]
    }
  ]
}