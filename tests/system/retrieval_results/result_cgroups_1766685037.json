{
  "query": "cgroups",
  "timestamp": "2025-12-26 01:50:37",
  "retrieved_files": [
    {
      "source_file": "kernel/cgroup/cgroup.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:42:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\cgroup.c`\n\n---\n\n# cgroup/cgroup.c 技术文档\n\n## 1. 文件概述\n\n`cgroup/cgroup.c` 是 Linux 内核中控制组（Control Group, cgroup）子系统的核心实现文件。它提供了通用的进程分组机制，用于对进程进行资源限制、优先级分配、资源统计和进程控制。该文件实现了 cgroup v2 统一层次结构（unified hierarchy）的基础框架，包括 cgroup 的创建、销毁、层级管理、子系统（subsystem/controller）注册与回调、文件系统接口、命名空间支持以及与 RCU、工作队列等内核机制的集成。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n\n- **`cgroup_mutex`**：cgroup 系统的主互斥锁，任何对 cgroup 层级结构或配置的修改都必须持有此锁。\n- **`css_set_lock`**：自旋锁，保护任务的 `task->cgroups` 指针、`css_set` 对象链表以及每个 `css_set` 关联的任务链。\n- **`cgroup_subsys[]`**：指向所有已注册 cgroup 子系统的指针数组，通过 `cgroup_subsys.h` 自动生成。\n- **`cgroup_subsys_name[]`**：各子系统的名称字符串数组。\n- **`cgroup_subsys_enabled_key[]` / `cgroup_subsys_on_dfl_key[]`**：静态键（static_key）数组，用于高效判断子系统是否启用或是否在默认层级（v2）上启用。\n- **`cgrp_dfl_root`**：默认 cgroup 层级（v2）的根节点。\n- **`cgroup_roots`**：所有已挂载 cgroup 层级根节点的链表。\n- **`init_cgroup_ns`**：初始 cgroup 命名空间，供 init 进程使用。\n- **`cgroup_destroy_wq`**：专用工作队列，用于异步销毁 cgroup，避免阻塞系统工作队列。\n\n### 关键静态变量\n\n- **`cgrp_dfl_visible`**：标志默认层级是否已挂载（首次挂载后可见）。\n- **`cgrp_dfl_inhibit_ss_mask` / `cgrp_dfl_implicit_ss_mask` / `cgrp_dfl_threaded_ss_mask`**：位掩码，分别表示在默认层级中被禁止、隐式启用和可线程化的子系统。\n- **`have_fork_callback` 等**：位掩码，记录哪些子系统实现了特定生命周期回调（如 fork、exit、release、can_fork）。\n- **`css_serial_nr_next`**：全局递增序列号，用于保证 cgroup 创建顺序和兄弟节点排序。\n\n### 核心函数（声明/定义）\n\n- **`cgroup_apply_control()`**：应用对 cgroup 的控制策略变更。\n- **`cgroup_finalize_control()`**：完成控制策略变更的最终处理。\n- **`cgroup_destroy_locked()`**：在持有 `cgroup_mutex` 的情况下销毁 cgroup。\n- **`css_create()`**：为指定 cgroup 和子系统创建 `cgroup_subsys_state`（css）。\n- **`css_release()`**：css 引用计数归零时的释放回调。\n- **`kill_css()`**：终止并清理一个 css。\n- **`css_task_iter_skip()`**：在遍历任务时跳过特定任务。\n- **`cgroup_addrm_files()`**：向 cgroup 目录动态添加或移除控制文件。\n\n## 3. 关键实现\n\n### 锁机制设计\n- **`cgroup_mutex`** 作为主锁，保护所有结构性变更（如创建/销毁 cgroup、挂载/卸载层级）。\n- **`css_set_lock`** 保护任务与 css_set 的关联关系，允许在不持有主锁的情况下快速读取任务的 cgroup 成员关系。\n- **`cgroup_idr_lock`** 保护 ID 分配器（`cgroup_idr` 和 `css_idr`），允许在不持有 `cgroup_mutex` 的情况下释放 ID。\n- **`cgroup_file_kn_lock`** 同步通知机制与文件节点（kn）的创建/销毁，尤其在 css 隐藏/显示时。\n- **`cgroup_threadgroup_rwsem`**（percpu rwsem）用于线程组操作的同步。\n\n### 子系统管理\n- 通过宏 `SUBSYS()` 和头文件 `linux/cgroup_subsys.h` 自动生成子系统数组、名称数组和静态键数组，实现编译期配置。\n- 使用 `static_key` 优化运行时检查（如 `cgroup_subsys_enabled()`），避免分支预测开销。\n- 位掩码（如 `have_fork_callback`）用于快速判断哪些子系统需要调用特定回调，避免遍历所有子系统。\n\n### 默认层级（v2）支持\n- `cgrp_dfl_root` 代表统一的 cgroup v2 层级，初始隐藏，首次挂载后变为可见。\n- 通过 `cgrp_dfl_inhibit_ss_mask` 等掩码控制哪些子系统可在 v2 中使用、是否自动启用或支持线程化模式。\n\n### 资源销毁与异步处理\n- 使用专用工作队列 `cgroup_destroy_wq` 处理 cgroup 销毁，防止大量并发销毁操作阻塞 `system_wq` 导致死锁。\n- css 的生命周期通过 `percpu_ref` 管理，`css_release()` 在引用归零时触发异步清理。\n\n### 调试与追踪\n- `trace_cgroup_path` 和 `trace_cgroup_path_lock` 用于追踪事件中记录 cgroup 路径。\n- `cgroup_debug` 全局开关控制调试输出。\n- 定义了 `CREATE_TRACE_POINTS` 以生成 cgroup 相关的 tracepoint。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `cgroup-internal.h`：cgroup 内部实现头文件。\n  - 多个内核子系统头文件：`sched.h`（调度）、`cred.h`（凭证）、`nsproxy.h`（命名空间）、`bpf-cgroup.h`（BPF 集成）、`psi.h`（压力指标）等。\n- **子系统依赖**：\n  - 所有 cgroup 子系统（如 `cpuset`、`memory`、`cpu` 等）通过 `cgroup_subsys.h` 注册到此框架。\n  - 依赖 `sysfs` 的设计思想（源自 Patrick Mochel）。\n- **内核机制依赖**：\n  - RCU（读-拷贝-更新）用于无锁读取。\n  - IDR（整数 ID 管理器）用于分配 cgroup 和 css 的唯一 ID。\n  - 工作队列（workqueue）用于异步销毁。\n  - 静态键（static_key）用于运行时优化。\n  - percpu 变量用于性能敏感数据（如 `cgrp_dfl_root_rstat_cpu`）。\n\n## 5. 使用场景\n\n- **容器运行时**（如 Docker、containerd）：通过挂载 cgroup v2 文件系统并写入进程 PID 到 `cgroup.procs`，实现对容器内进程的资源隔离与限制。\n- **系统资源管理器**（如 systemd）：使用 cgroup 层级组织服务进程，实施 CPU、内存、IO 等资源配额。\n- **内核子系统集成**：各资源控制器（如内存、CPU 调度器、blkio）通过注册 cgroup 子系统，将其资源管理策略与 cgroup 框架绑定。\n- **性能监控与调试**：通过 cgroup 提供的接口（如 `memory.stat`、`cpu.stat`）获取进程组的资源使用统计。\n- **安全隔离**：结合用户命名空间（user namespace）和 cgroup，实现多租户环境下的资源隔离。\n- **BPF 程序挂载**：通过 `bpf-cgroup` 接口，将 BPF 程序附加到 cgroup 上，实现网络、安全等策略的分组应用。",
      "similarity": 0.5969605445861816,
      "chunks": [
        {
          "chunk_id": 23,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 7006,
          "end_line": 7111,
          "content": [
            "int cgroup_parse_float(const char *input, unsigned dec_shift, s64 *v)",
            "{",
            "\ts64 whole, frac = 0;",
            "\tint fstart = 0, fend = 0, flen;",
            "",
            "\tif (!sscanf(input, \"%lld.%n%lld%n\", &whole, &fstart, &frac, &fend))",
            "\t\treturn -EINVAL;",
            "\tif (frac < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tflen = fend > fstart ? fend - fstart : 0;",
            "\tif (flen < dec_shift)",
            "\t\tfrac *= power_of_ten(dec_shift - flen);",
            "\telse",
            "\t\tfrac = DIV_ROUND_CLOSEST_ULL(frac, power_of_ten(flen - dec_shift));",
            "",
            "\t*v = whole * power_of_ten(dec_shift) + frac;",
            "\treturn 0;",
            "}",
            "void cgroup_sk_alloc(struct sock_cgroup_data *skcd)",
            "{",
            "\tstruct cgroup *cgroup;",
            "",
            "\trcu_read_lock();",
            "\t/* Don't associate the sock with unrelated interrupted task's cgroup. */",
            "\tif (in_interrupt()) {",
            "\t\tcgroup = &cgrp_dfl_root.cgrp;",
            "\t\tcgroup_get(cgroup);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\twhile (true) {",
            "\t\tstruct css_set *cset;",
            "",
            "\t\tcset = task_css_set(current);",
            "\t\tif (likely(cgroup_tryget(cset->dfl_cgrp))) {",
            "\t\t\tcgroup = cset->dfl_cgrp;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tcpu_relax();",
            "\t}",
            "out:",
            "\tskcd->cgroup = cgroup;",
            "\tcgroup_bpf_get(cgroup);",
            "\trcu_read_unlock();",
            "}",
            "void cgroup_sk_clone(struct sock_cgroup_data *skcd)",
            "{",
            "\tstruct cgroup *cgrp = sock_cgroup_ptr(skcd);",
            "",
            "\t/*",
            "\t * We might be cloning a socket which is left in an empty",
            "\t * cgroup and the cgroup might have already been rmdir'd.",
            "\t * Don't use cgroup_get_live().",
            "\t */",
            "\tcgroup_get(cgrp);",
            "\tcgroup_bpf_get(cgrp);",
            "}",
            "void cgroup_sk_free(struct sock_cgroup_data *skcd)",
            "{",
            "\tstruct cgroup *cgrp = sock_cgroup_ptr(skcd);",
            "",
            "\tcgroup_bpf_put(cgrp);",
            "\tcgroup_put(cgrp);",
            "}",
            "static ssize_t show_delegatable_files(struct cftype *files, char *buf,",
            "\t\t\t\t      ssize_t size, const char *prefix)",
            "{",
            "\tstruct cftype *cft;",
            "\tssize_t ret = 0;",
            "",
            "\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {",
            "\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (prefix)",
            "\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);",
            "",
            "\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);",
            "",
            "\t\tif (WARN_ON(ret >= size))",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t delegate_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t      char *buf)",
            "{",
            "\tstruct cgroup_subsys *ss;",
            "\tint ssid;",
            "\tssize_t ret = 0;",
            "",
            "\tret = show_delegatable_files(cgroup_base_files, buf + ret,",
            "\t\t\t\t     PAGE_SIZE - ret, NULL);",
            "\tif (cgroup_psi_enabled())",
            "\t\tret += show_delegatable_files(cgroup_psi_files, buf + ret,",
            "\t\t\t\t\t      PAGE_SIZE - ret, NULL);",
            "",
            "\tfor_each_subsys(ss, ssid)",
            "\t\tret += show_delegatable_files(ss->dfl_cftypes, buf + ret,",
            "\t\t\t\t\t      PAGE_SIZE - ret,",
            "\t\t\t\t\t      cgroup_subsys_name[ssid]);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "cgroup_parse_float, cgroup_sk_alloc, cgroup_sk_clone, cgroup_sk_free, show_delegatable_files, delegate_show",
          "description": "cgroup_parse_float将字符串解析为带小数位的整数，cgroup_sk_*系列函数管理socket与cgroup的关联，show_delegatable_files遍历可委派的cftype文件",
          "similarity": 0.6154428124427795
        },
        {
          "chunk_id": 24,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 7128,
          "end_line": 7142,
          "content": [
            "static ssize_t features_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t     char *buf)",
            "{",
            "\treturn snprintf(buf, PAGE_SIZE,",
            "\t\t\t\"nsdelegate\\n\"",
            "\t\t\t\"favordynmods\\n\"",
            "\t\t\t\"memory_localevents\\n\"",
            "\t\t\t\"memory_recursiveprot\\n\"",
            "\t\t\t\"memory_hugetlb_accounting\\n\"",
            "\t\t\t\"pids_localevents\\n\");",
            "}",
            "static int __init cgroup_sysfs_init(void)",
            "{",
            "\treturn sysfs_create_group(kernel_kobj, &cgroup_sysfs_attr_group);",
            "}"
          ],
          "function_name": "features_show, cgroup_sysfs_init",
          "description": "features_show输出当前支持的cgroup特性选项，cgroup_sysfs_init注册cgroup系统属性组到内核sysfs接口",
          "similarity": 0.5938897728919983
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 291,
          "end_line": 392,
          "content": [
            "bool cgroup_ssid_enabled(int ssid)",
            "{",
            "\tif (!CGROUP_HAS_SUBSYS_CONFIG)",
            "\t\treturn false;",
            "",
            "\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);",
            "}",
            "bool cgroup_on_dfl(const struct cgroup *cgrp)",
            "{",
            "\treturn cgrp->root == &cgrp_dfl_root;",
            "}",
            "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,",
            "\t\t\t    gfp_t gfp_mask)",
            "{",
            "\tint ret;",
            "",
            "\tidr_preload(gfp_mask);",
            "\tspin_lock_bh(&cgroup_idr_lock);",
            "\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);",
            "\tspin_unlock_bh(&cgroup_idr_lock);",
            "\tidr_preload_end();",
            "\treturn ret;",
            "}",
            "static void cgroup_idr_remove(struct idr *idr, int id)",
            "{",
            "\tspin_lock_bh(&cgroup_idr_lock);",
            "\tidr_remove(idr, id);",
            "\tspin_unlock_bh(&cgroup_idr_lock);",
            "}",
            "static bool cgroup_has_tasks(struct cgroup *cgrp)",
            "{",
            "\treturn cgrp->nr_populated_csets;",
            "}",
            "static bool cgroup_is_threaded(struct cgroup *cgrp)",
            "{",
            "\treturn cgrp->dom_cgrp != cgrp;",
            "}",
            "static bool cgroup_is_mixable(struct cgroup *cgrp)",
            "{",
            "\t/*",
            "\t * Root isn't under domain level resource control exempting it from",
            "\t * the no-internal-process constraint, so it can serve as a thread",
            "\t * root and a parent of resource domains at the same time.",
            "\t */",
            "\treturn !cgroup_parent(cgrp);",
            "}",
            "static bool cgroup_can_be_thread_root(struct cgroup *cgrp)",
            "{",
            "\t/* mixables don't care */",
            "\tif (cgroup_is_mixable(cgrp))",
            "\t\treturn true;",
            "",
            "\t/* domain roots can't be nested under threaded */",
            "\tif (cgroup_is_threaded(cgrp))",
            "\t\treturn false;",
            "",
            "\t/* can only have either domain or threaded children */",
            "\tif (cgrp->nr_populated_domain_children)",
            "\t\treturn false;",
            "",
            "\t/* and no domain controllers can be enabled */",
            "\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static bool cgroup_is_thread_root(struct cgroup *cgrp)",
            "{",
            "\t/* thread root should be a domain */",
            "\tif (cgroup_is_threaded(cgrp))",
            "\t\treturn false;",
            "",
            "\t/* a domain w/ threaded children is a thread root */",
            "\tif (cgrp->nr_threaded_children)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * A domain which has tasks and explicit threaded controllers",
            "\t * enabled is a thread root.",
            "\t */",
            "\tif (cgroup_has_tasks(cgrp) &&",
            "\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static bool cgroup_is_valid_domain(struct cgroup *cgrp)",
            "{",
            "\t/* the cgroup itself can be a thread root */",
            "\tif (cgroup_is_threaded(cgrp))",
            "\t\treturn false;",
            "",
            "\t/* but the ancestors can't be unless mixable */",
            "\twhile ((cgrp = cgroup_parent(cgrp))) {",
            "\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))",
            "\t\t\treturn false;",
            "\t\tif (cgroup_is_threaded(cgrp))",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "cgroup_ssid_enabled, cgroup_on_dfl, cgroup_idr_alloc, cgroup_idr_remove, cgroup_has_tasks, cgroup_is_threaded, cgroup_is_mixable, cgroup_can_be_thread_root, cgroup_is_thread_root, cgroup_is_valid_domain",
          "description": "提供了多个辅助函数用于cgroup管理，包括检查子系统是否启用（cgroup_ssid_enabled）、判断是否处于默认层级（cgroup_on_dfl）、ID分配/移除（cgroup_idr_*）、任务存在检测（cgroup_has_tasks）及线程化属性判断（cgroup_is_threaded等）。",
          "similarity": 0.5918571949005127
        },
        {
          "chunk_id": 22,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 6748,
          "end_line": 6848,
          "content": [
            "void cgroup_exit(struct task_struct *tsk)",
            "{",
            "\tstruct cgroup_subsys *ss;",
            "\tstruct css_set *cset;",
            "\tint i;",
            "",
            "\tspin_lock_irq(&css_set_lock);",
            "",
            "\tWARN_ON_ONCE(list_empty(&tsk->cg_list));",
            "\tcset = task_css_set(tsk);",
            "\tcss_set_move_task(tsk, cset, NULL, false);",
            "\tcset->nr_tasks--;",
            "\t/* matches the signal->live check in css_task_iter_advance() */",
            "\tif (thread_group_leader(tsk) && atomic_read(&tsk->signal->live))",
            "\t\tlist_add_tail(&tsk->cg_list, &cset->dying_tasks);",
            "",
            "\tif (dl_task(tsk))",
            "\t\tdec_dl_tasks_cs(tsk);",
            "",
            "\tWARN_ON_ONCE(cgroup_task_frozen(tsk));",
            "\tif (unlikely(!(tsk->flags & PF_KTHREAD) &&",
            "\t\t     test_bit(CGRP_FREEZE, &task_dfl_cgroup(tsk)->flags)))",
            "\t\tcgroup_update_frozen(task_dfl_cgroup(tsk));",
            "",
            "\tspin_unlock_irq(&css_set_lock);",
            "",
            "\t/* see cgroup_post_fork() for details */",
            "\tdo_each_subsys_mask(ss, i, have_exit_callback) {",
            "\t\tss->exit(tsk);",
            "\t} while_each_subsys_mask();",
            "}",
            "void cgroup_release(struct task_struct *task)",
            "{",
            "\tstruct cgroup_subsys *ss;",
            "\tint ssid;",
            "",
            "\tdo_each_subsys_mask(ss, ssid, have_release_callback) {",
            "\t\tss->release(task);",
            "\t} while_each_subsys_mask();",
            "",
            "\tif (!list_empty(&task->cg_list)) {",
            "\t\tspin_lock_irq(&css_set_lock);",
            "\t\tcss_set_skip_task_iters(task_css_set(task), task);",
            "\t\tlist_del_init(&task->cg_list);",
            "\t\tspin_unlock_irq(&css_set_lock);",
            "\t}",
            "}",
            "void cgroup_free(struct task_struct *task)",
            "{",
            "\tstruct css_set *cset = task_css_set(task);",
            "\tput_css_set(cset);",
            "}",
            "static int __init cgroup_disable(char *str)",
            "{",
            "\tstruct cgroup_subsys *ss;",
            "\tchar *token;",
            "\tint i;",
            "",
            "\twhile ((token = strsep(&str, \",\")) != NULL) {",
            "\t\tif (!*token)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor_each_subsys(ss, i) {",
            "\t\t\tif (strcmp(token, ss->name) &&",
            "\t\t\t    strcmp(token, ss->legacy_name))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tstatic_branch_disable(cgroup_subsys_enabled_key[i]);",
            "\t\t\tpr_info(\"Disabling %s control group subsystem\\n\",",
            "\t\t\t\tss->name);",
            "\t\t}",
            "",
            "\t\tfor (i = 0; i < OPT_FEATURE_COUNT; i++) {",
            "\t\t\tif (strcmp(token, cgroup_opt_feature_names[i]))",
            "\t\t\t\tcontinue;",
            "\t\t\tcgroup_feature_disable_mask |= 1 << i;",
            "\t\t\tpr_info(\"Disabling %s control group feature\\n\",",
            "\t\t\t\tcgroup_opt_feature_names[i]);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}",
            "void __init __weak enable_debug_cgroup(void) { }",
            "static int __init enable_cgroup_debug(char *str)",
            "{",
            "\tcgroup_debug = true;",
            "\tenable_debug_cgroup();",
            "\treturn 1;",
            "}",
            "static int __init cgroup_favordynmods_setup(char *str)",
            "{",
            "\treturn (kstrtobool(str, &have_favordynmods) == 0);",
            "}",
            "static u64 power_of_ten(int power)",
            "{",
            "\tu64 v = 1;",
            "\twhile (power--)",
            "\t\tv *= 10;",
            "\treturn v;",
            "}"
          ],
          "function_name": "cgroup_exit, cgroup_release, cgroup_free, cgroup_disable, enable_debug_cgroup, enable_cgroup_debug, cgroup_favordynmods_setup, power_of_ten",
          "description": "cgroup_exit减少任务计数并触发子系统exit回调，cgroup_release移除任务链表节点，cgroup_free释放CSS集引用，cgroup_disable禁用指定子系统，enable_cgroup_debug启用调试功能",
          "similarity": 0.5884870290756226
        },
        {
          "chunk_id": 20,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 6395,
          "end_line": 6515,
          "content": [
            "void cgroup_fork(struct task_struct *child)",
            "{",
            "\tRCU_INIT_POINTER(child->cgroups, &init_css_set);",
            "\tINIT_LIST_HEAD(&child->cg_list);",
            "}",
            "static int cgroup_css_set_fork(struct kernel_clone_args *kargs)",
            "\t__acquires(&cgroup_mutex) __acquires(&cgroup_threadgroup_rwsem)",
            "{",
            "\tint ret;",
            "\tstruct cgroup *dst_cgrp = NULL;",
            "\tstruct css_set *cset;",
            "\tstruct super_block *sb;",
            "",
            "\tif (kargs->flags & CLONE_INTO_CGROUP)",
            "\t\tcgroup_lock();",
            "",
            "\tcgroup_threadgroup_change_begin(current);",
            "",
            "\tspin_lock_irq(&css_set_lock);",
            "\tcset = task_css_set(current);",
            "\tget_css_set(cset);",
            "\tif (kargs->cgrp)",
            "\t\tkargs->kill_seq = kargs->cgrp->kill_seq;",
            "\telse",
            "\t\tkargs->kill_seq = cset->dfl_cgrp->kill_seq;",
            "\tspin_unlock_irq(&css_set_lock);",
            "",
            "\tif (!(kargs->flags & CLONE_INTO_CGROUP)) {",
            "\t\tkargs->cset = cset;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tCLASS(fd_raw, f)(kargs->cgroup);",
            "\tif (fd_empty(f)) {",
            "\t\tret = -EBADF;",
            "\t\tgoto err;",
            "\t}",
            "\tsb = fd_file(f)->f_path.dentry->d_sb;",
            "",
            "\tdst_cgrp = cgroup_get_from_file(fd_file(f));",
            "\tif (IS_ERR(dst_cgrp)) {",
            "\t\tret = PTR_ERR(dst_cgrp);",
            "\t\tdst_cgrp = NULL;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tif (cgroup_is_dead(dst_cgrp)) {",
            "\t\tret = -ENODEV;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\t/*",
            "\t * Verify that we the target cgroup is writable for us. This is",
            "\t * usually done by the vfs layer but since we're not going through",
            "\t * the vfs layer here we need to do it \"manually\".",
            "\t */",
            "\tret = cgroup_may_write(dst_cgrp, sb);",
            "\tif (ret)",
            "\t\tgoto err;",
            "",
            "\t/*",
            "\t * Spawning a task directly into a cgroup works by passing a file",
            "\t * descriptor to the target cgroup directory. This can even be an O_PATH",
            "\t * file descriptor. But it can never be a cgroup.procs file descriptor.",
            "\t * This was done on purpose so spawning into a cgroup could be",
            "\t * conceptualized as an atomic",
            "\t *",
            "\t *   fd = openat(dfd_cgroup, \"cgroup.procs\", ...);",
            "\t *   write(fd, <child-pid>, ...);",
            "\t *",
            "\t * sequence, i.e. it's a shorthand for the caller opening and writing",
            "\t * cgroup.procs of the cgroup indicated by @dfd_cgroup. This allows us",
            "\t * to always use the caller's credentials.",
            "\t */",
            "\tret = cgroup_attach_permissions(cset->dfl_cgrp, dst_cgrp, sb,",
            "\t\t\t\t\t!(kargs->flags & CLONE_THREAD),",
            "\t\t\t\t\tcurrent->nsproxy->cgroup_ns);",
            "\tif (ret)",
            "\t\tgoto err;",
            "",
            "\tkargs->cset = find_css_set(cset, dst_cgrp);",
            "\tif (!kargs->cset) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tput_css_set(cset);",
            "\tkargs->cgrp = dst_cgrp;",
            "\treturn ret;",
            "",
            "err:",
            "\tcgroup_threadgroup_change_end(current);",
            "\tcgroup_unlock();",
            "\tif (dst_cgrp)",
            "\t\tcgroup_put(dst_cgrp);",
            "\tput_css_set(cset);",
            "\tif (kargs->cset)",
            "\t\tput_css_set(kargs->cset);",
            "\treturn ret;",
            "}",
            "static void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)",
            "\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)",
            "{",
            "\tstruct cgroup *cgrp = kargs->cgrp;",
            "\tstruct css_set *cset = kargs->cset;",
            "",
            "\tcgroup_threadgroup_change_end(current);",
            "",
            "\tif (cset) {",
            "\t\tput_css_set(cset);",
            "\t\tkargs->cset = NULL;",
            "\t}",
            "",
            "\tif (kargs->flags & CLONE_INTO_CGROUP) {",
            "\t\tcgroup_unlock();",
            "\t\tif (cgrp) {",
            "\t\t\tcgroup_put(cgrp);",
            "\t\t\tkargs->cgrp = NULL;",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "cgroup_fork, cgroup_css_set_fork, cgroup_css_set_put_fork",
          "description": "初始化子进程的cgroup和CSS集合，通过cgroup_fork设置默认CSS集，cgroup_css_set_fork处理CLONE_INTO_CGROUP标志下的目标cgroup验证及CSS集切换，cgroup_css_set_put_fork释放相关引用",
          "similarity": 0.5807887315750122
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:49:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\namespace.c`\n\n---\n\n# cgroup/namespace.c 技术文档\n\n## 1. 文件概述\n\n`cgroup/namespace.c` 实现了 cgroup 命名空间（cgroup namespace）的核心功能。该文件为 Linux 内核提供了对 cgroup 命名空间的支持，使得不同进程可以拥有隔离的 cgroup 视图，从而增强容器化环境中的资源隔离能力。cgroup 命名空间允许进程看到一个以当前进程所属 cgroup 为根的虚拟 cgroup 文件系统视图，而不是全局的 cgroup 层次结构。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `alloc_cgroup_ns()`：分配并初始化一个新的 cgroup 命名空间结构体。\n- `free_cgroup_ns()`：释放 cgroup 命名空间及其关联资源。\n- `copy_cgroup_ns()`：在进程 fork 或 clone 时复制 cgroup 命名空间，支持 `CLONE_NEWCGROUP` 标志创建新命名空间。\n- `cgroupns_install()`：将指定的 cgroup 命名空间安装到当前进程的 `nsproxy` 中。\n- `cgroupns_get()` / `cgroupns_put()`：用于引用计数管理，获取和释放 cgroup 命名空间。\n- `cgroupns_owner()`：返回该 cgroup 命名空间所属的用户命名空间。\n\n### 关键数据结构\n\n- `struct cgroup_namespace`：表示一个 cgroup 命名空间，包含：\n  - `ns`：通用命名空间结构（`struct ns_common`）\n  - `root_cset`：指向该命名空间根 css_set（控制组集合）\n  - `user_ns`：关联的用户命名空间\n  - `ucounts`：用于资源计数（限制命名空间数量）\n\n- `cgroupns_operations`：`proc_ns_operations` 类型的全局常量，定义了 cgroup 命名空间在 `/proc/[pid]/ns/cgroup` 中的操作接口。\n\n## 3. 关键实现\n\n### 命名空间创建与资源限制\n- 使用 `inc_cgroup_namespaces()` 和 `dec_cgroup_namespaces()` 通过 `ucounts` 机制限制每个用户命名空间可创建的 cgroup 命名空间数量，防止资源耗尽。\n- 仅允许具有 `CAP_SYS_ADMIN` 能力的进程创建新的 cgroup 命名空间，确保安全性。\n\n### 命名空间复制逻辑\n- 在 `copy_cgroup_ns()` 中：\n  - 若未设置 `CLONE_NEWCGROUP`，则直接复用父进程的 cgroup 命名空间（引用计数加一）。\n  - 若设置 `CLONE_NEWCGROUP`，则创建新命名空间，并将当前任务的 `css_set` 作为新命名空间的根（`root_cset`）。\n  - 使用 `spin_lock_irq(&css_set_lock)` 安全地获取当前任务的 `css_set`，避免在持有 `cgroup_mutex` 的上下文中操作。\n\n### 命名空间安装与切换\n- `cgroupns_install()` 在 `setns()` 系统调用中被调用，用于将目标命名空间切换到当前进程。\n- 实现双重权限检查：要求调用者在其自身用户命名空间和目标 cgroup 命名空间的用户命名空间中均具备 `CAP_SYS_ADMIN`。\n\n### 生命周期管理\n- 通过 `refcount_set()` 和 `get_cgroup_ns()` / `put_cgroup_ns()` 实现引用计数。\n- `free_cgroup_ns()` 负责释放所有关联资源：`css_set`、用户命名空间、ucounts 计数及 inum（用于 `/proc` 中的命名空间标识）。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `cgroup-internal.h`：提供 cgroup 内部数据结构和辅助函数（如 `css_set`、`get_css_set()` 等）。\n- **内核模块依赖**：\n  - `<linux/nsproxy.h>`：提供 `nsproxy` 结构，用于管理进程的命名空间集合。\n  - `<linux/proc_ns.h>`：定义 `proc_ns_operations` 接口，用于 `/proc/[pid]/ns/` 下的命名空间文件操作。\n  - `<linux/sched/task.h>`：提供 `current` 和任务锁相关操作。\n  - `<linux/slab.h>`：内存分配接口（`kzalloc`/`kfree`）。\n  - `<linux/ucount.h>`（通过 `cgroup-internal.h` 间接包含）：用户资源计数机制。\n\n## 5. 使用场景\n\n- **容器运行时**：Docker、Podman、containerd 等容器引擎在创建容器时使用 `CLONE_NEWCGROUP` 创建新的 cgroup 命名空间，使容器内进程看到以容器 cgroup 为根的视图，提升隔离性和安全性。\n- **系统调用支持**：\n  - `clone()` / `unshare()`：通过 `CLONE_NEWCGROUP` 标志创建新 cgroup 命名空间。\n  - `setns()`：将进程加入现有 cgroup 命名空间。\n- **/proc 文件系统**：通过 `/proc/[pid]/ns/cgroup` 提供命名空间文件，支持命名空间的查看和操作（如 `nsenter` 工具）。\n- **资源隔离**：结合用户命名空间，实现多租户环境下对 cgroup 命名空间创建数量的限制，防止 DoS 攻击。",
      "similarity": 0.5860731601715088,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/namespace.c",
          "start_line": 17,
          "end_line": 51,
          "content": [
            "static void dec_cgroup_namespaces(struct ucounts *ucounts)",
            "{",
            "\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);",
            "}",
            "void free_cgroup_ns(struct cgroup_namespace *ns)",
            "{",
            "\tput_css_set(ns->root_cset);",
            "\tdec_cgroup_namespaces(ns->ucounts);",
            "\tput_user_ns(ns->user_ns);",
            "\tns_free_inum(&ns->ns);",
            "\tkfree(ns);",
            "}",
            "static int cgroupns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct nsproxy *nsproxy = nsset->nsproxy;",
            "\tstruct cgroup_namespace *cgroup_ns = to_cg_ns(ns);",
            "",
            "\tif (!ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN) ||",
            "\t    !ns_capable(cgroup_ns->user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Don't need to do anything if we are attaching to our own cgroupns. */",
            "\tif (cgroup_ns == nsproxy->cgroup_ns)",
            "\t\treturn 0;",
            "",
            "\tget_cgroup_ns(cgroup_ns);",
            "\tput_cgroup_ns(nsproxy->cgroup_ns);",
            "\tnsproxy->cgroup_ns = cgroup_ns;",
            "",
            "\treturn 0;",
            "}",
            "static void cgroupns_put(struct ns_common *ns)",
            "{",
            "\tput_cgroup_ns(to_cg_ns(ns));",
            "}"
          ],
          "function_name": "dec_cgroup_namespaces, free_cgroup_ns, cgroupns_install, cgroupns_put",
          "description": "该代码段实现cgroup命名空间的引用计数管理和生命周期控制。  \n`free_cgroup_ns`负责安全释放cgroup命名空间资源，通过递减引用计数、释放关联的css_set和user_ns等资源完成销毁；`cgroupns_install`用于安装新的cgroup命名空间到进程nsproxy，需具备SYS_ADMIN权限；其余函数辅助引用计数操作。  \n上下文不完整：代码中调用的`put_css_set`、`get_cgroup_ns`等函数未在当前片段中定义。",
          "similarity": 0.5649504661560059
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/namespace.c",
          "start_line": 1,
          "end_line": 16,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include \"cgroup-internal.h\"",
            "",
            "#include <linux/sched/task.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "",
            "",
            "/* cgroup namespaces */",
            "",
            "static struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)",
            "{",
            "\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "该代码片段定义了一个静态函数`inc_cgroup_namespaces`，用于在用户命名空间中增加cgroup命名空间的引用计数。函数通过`current_euid()`获取当前有效UID，并调用`inc_ucount`更新对应类型的计数器（类型标识为`UCOUNT_CGROUP_NAMESPACES`）。由于缺乏上下文信息（如`UCOUNT_CGROUP_NAMESPACES`的定义及`inc_ucount`的具体实现），无法进一步确认其完整行为。",
          "similarity": 0.5307716727256775
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/dmem.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:45:21\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\dmem.c`\n\n---\n\n# cgroup/dmem.c 技术文档\n\n## 文件概述\n\n`cgroup/dmem.c` 实现了一个名为 **dmem（device memory）** 的 cgroup 子系统，用于对设备内存（如 GPU、NPU 或其他专用硬件内存）的使用进行资源控制和配额管理。该子系统通过 `page_counter` 机制跟踪每个 cgroup 在特定设备内存区域（region）上的用量，并支持设置 `min`、`low` 和 `max` 三种资源限制级别，以实现分级内存保护和回收策略。文件还提供了内存回收时的“是否可驱逐”判断逻辑，用于指导设备驱动在内存压力下选择合适的 cgroup 进行释放。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct dmem_cgroup_region`**  \n  表示一个设备内存区域（如某块 GPU 显存），包含：\n  - `ref`：引用计数，配合 RCU 管理生命周期\n  - `region_node`：全局区域链表节点（`dmem_cgroup_regions`）\n  - `pools`：关联到该区域的所有 cgroup 内存池列表\n  - `size`：区域总大小（字节）\n  - `name`：区域名称\n  - `unregistered`：标记区域是否已注销，防止新池加入\n\n- **`struct dmemcg_state`**  \n  cgroup 子系统状态（CSS），每个 cgroup 实例对应一个，包含：\n  - `css`：标准 cgroup_subsys_state 基类\n  - `pools`：该 cgroup 下所有设备内存池的链表\n\n- **`struct dmem_cgroup_pool_state`**  \n  表示某个 cgroup 在特定设备内存区域上的使用状态，包含：\n  - `region`：指向所属的 `dmem_cgroup_region`\n  - `cs`：指向所属的 `dmemcg_state`\n  - `css_node`：挂载到 cgroup 的 `pools` 链表（RCU 保护）\n  - `region_node`：挂载到 region 的 `pools` 链表（自旋锁保护）\n  - `cnt`：`page_counter` 实例，记录当前用量及限制\n  - `inited`：初始化标志\n\n### 主要函数\n\n- **资源限制操作函数**  \n  - `set_resource_min/low/max()`：设置 min/low/max 限制\n  - `get_resource_current/min/low/max()`：获取当前用量或限制值\n  - `reset_all_resource_limits()`：重置所有限制为默认值\n\n- **cgroup 生命周期回调**  \n  - `dmemcs_alloc()`：分配 cgroup 状态\n  - `dmemcs_offline()`：cgroup 下线时重置所有池的限制\n  - `dmemcs_free()`：释放 cgroup 状态及关联的池\n\n- **内存回收辅助函数**  \n  - `dmem_cgroup_state_evict_valuable()`：判断某内存池是否可被驱逐（核心回收逻辑）\n  - `dmem_cgroup_calculate_protection()`：计算子树中各池的有效保护值（emin/elow）\n\n- **辅助函数**  \n  - `find_cg_pool_locked()`：在指定 cgroup 中查找特定 region 的池（需持锁）\n  - `pool_parent()`：获取池的父池（基于 page_counter 层级）\n\n## 关键实现\n\n### 并发控制策略\n\n- **全局自旋锁 `dmemcg_lock`**：保护以下操作：\n  - 全局区域列表 `dmem_cgroup_regions` 的增删\n  - cgroup 的 `pools` 链表与 region 的 `pools` 链表的修改\n- **RCU 机制**：用于无锁读取 cgroup 的 `pools` 链表（如 `dmemcs_offline()` 和 `find_cg_pool_locked()`）\n- **`page_counter`**：本身是无锁的原子计数器，用于高效跟踪内存用量\n\n### 内存保护与回收逻辑\n\n- **三级保护机制**：\n  - `min`：硬性保证，用量 ≤ min 时不可驱逐\n  - `low`：软性保护，用量 > low 时可驱逐；用量 ≤ low 时需特殊处理（如设置 `ret_hit_low`）\n  - `max`：硬性上限，用量不可超过\n- **`dmem_cgroup_state_evict_valuable()` 工作流程**：\n  1. 若 `limit_pool == test_pool`，直接允许驱逐（自身超限）\n  2. 若 `limit_pool` 无父 cgroup（即根 cgroup），允许驱逐\n  3. 检查 `test_pool` 是否在 `limit_pool` 的子树中（通过 `pool_parent` 遍历）\n  4. 调用 `dmem_cgroup_calculate_protection()` 计算子树中各池的有效保护值\n  5. 比较 `test_pool` 的当前用量与 `emin`/`elow`：\n     - 用量 ≤ `emin` → 不可驱逐\n     - 用量 > `elow` → 可驱逐\n     - 用量 ≤ `elow` 且 `ignore_low=false` → 不可驱逐，但设置 `ret_hit_low=true` 建议重试\n\n### 层级关系维护\n\n- **池的父子关系**：通过 `page_counter` 的 `parent` 字段隐式建立，`pool_parent()` 用于向上遍历\n- **保护值传播**：`dmem_cgroup_calculate_protection()` 遍历 `limit_pool` 的整个子树，调用 `page_counter_calculate_protection()` 更新各子池的 `emin`/`elow`\n\n## 依赖关系\n\n- **核心依赖**：\n  - `<linux/cgroup.h>`：cgroup 子系统框架\n  - `<linux/page_counter.h>`：内存用量计数与保护机制\n  - `<linux/rcupdate.h>`（隐式）：RCU 读写锁\n  - `<linux/spinlock.h>`：自旋锁实现\n- **头文件依赖**：\n  - `<linux/cgroup_dmem.h>`：dmem cgroup 的公共接口定义（如 `dmem_cgrp_id`）\n- **与其他子系统关系**：\n  - 类似 `rdma` 和 `misc` cgroup 控制器的设计模式\n  - 为设备驱动（如 GPU/NPU 驱动）提供内存配额管理接口\n\n## 使用场景\n\n- **设备内存资源隔离**：在多租户或容器化环境中，限制不同 cgroup 对专用设备内存（如 GPU 显存）的使用量。\n- **分级内存回收**：当设备内存不足时，驱动调用 `dmem_cgroup_state_evict_valuable()` 判断哪些 cgroup 的内存可安全释放，优先驱逐超出 `low` 限制的 cgroup，保护 `min` 限制内的关键任务。\n- **动态配额调整**：管理员可通过 cgroup 接口（如 `memory.dmem.*` 文件）动态调整各 cgroup 的 `min`/`low`/`max` 限制，实现灵活的资源调度。\n- **根 cgroup 默认行为**：未显式设置限制的 cgroup 继承根 cgroup 的默认策略（`max=PAGE_COUNTER_MAX`，无硬限制）。",
      "similarity": 0.5775836110115051,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 106,
          "end_line": 209,
          "content": [
            "static void free_cg_pool(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\tlist_del(&pool->region_node);",
            "\tkfree(pool);",
            "}",
            "static void",
            "set_resource_min(struct dmem_cgroup_pool_state *pool, u64 val)",
            "{",
            "\tpage_counter_set_min(&pool->cnt, val);",
            "}",
            "static void",
            "set_resource_low(struct dmem_cgroup_pool_state *pool, u64 val)",
            "{",
            "\tpage_counter_set_low(&pool->cnt, val);",
            "}",
            "static void",
            "set_resource_max(struct dmem_cgroup_pool_state *pool, u64 val)",
            "{",
            "\tpage_counter_set_max(&pool->cnt, val);",
            "}",
            "static u64 get_resource_low(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\treturn pool ? READ_ONCE(pool->cnt.low) : 0;",
            "}",
            "static u64 get_resource_min(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\treturn pool ? READ_ONCE(pool->cnt.min) : 0;",
            "}",
            "static u64 get_resource_max(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\treturn pool ? READ_ONCE(pool->cnt.max) : PAGE_COUNTER_MAX;",
            "}",
            "static u64 get_resource_current(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\treturn pool ? page_counter_read(&pool->cnt) : 0;",
            "}",
            "static void reset_all_resource_limits(struct dmem_cgroup_pool_state *rpool)",
            "{",
            "\tset_resource_min(rpool, 0);",
            "\tset_resource_low(rpool, 0);",
            "\tset_resource_max(rpool, PAGE_COUNTER_MAX);",
            "}",
            "static void dmemcs_offline(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct dmemcg_state *dmemcs = css_to_dmemcs(css);",
            "\tstruct dmem_cgroup_pool_state *pool;",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(pool, &dmemcs->pools, css_node)",
            "\t\treset_all_resource_limits(pool);",
            "\trcu_read_unlock();",
            "}",
            "static void dmemcs_free(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct dmemcg_state *dmemcs = css_to_dmemcs(css);",
            "\tstruct dmem_cgroup_pool_state *pool, *next;",
            "",
            "\tspin_lock(&dmemcg_lock);",
            "\tlist_for_each_entry_safe(pool, next, &dmemcs->pools, css_node) {",
            "\t\t/*",
            "\t\t *The pool is dead and all references are 0,",
            "\t\t * no need for RCU protection with list_del_rcu or freeing.",
            "\t\t */",
            "\t\tlist_del(&pool->css_node);",
            "\t\tfree_cg_pool(pool);",
            "\t}",
            "\tspin_unlock(&dmemcg_lock);",
            "",
            "\tkfree(dmemcs);",
            "}",
            "static void",
            "dmem_cgroup_calculate_protection(struct dmem_cgroup_pool_state *limit_pool,",
            "\t\t\t\t struct dmem_cgroup_pool_state *test_pool)",
            "{",
            "\tstruct page_counter *climit;",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct dmemcg_state *dmemcg_iter;",
            "\tstruct dmem_cgroup_pool_state *pool, *found_pool;",
            "",
            "\tclimit = &limit_pool->cnt;",
            "",
            "\trcu_read_lock();",
            "",
            "\tcss_for_each_descendant_pre(css, &limit_pool->cs->css) {",
            "\t\tdmemcg_iter = container_of(css, struct dmemcg_state, css);",
            "\t\tfound_pool = NULL;",
            "",
            "\t\tlist_for_each_entry_rcu(pool, &dmemcg_iter->pools, css_node) {",
            "\t\t\tif (pool->region == limit_pool->region) {",
            "\t\t\t\tfound_pool = pool;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (!found_pool)",
            "\t\t\tcontinue;",
            "",
            "\t\tpage_counter_calculate_protection(",
            "\t\t\tclimit, &found_pool->cnt, true);",
            "",
            "\t\tif (found_pool == test_pool)",
            "\t\t\tbreak;",
            "\t}",
            "\trcu_read_unlock();",
            "}"
          ],
          "function_name": "free_cg_pool, set_resource_min, set_resource_low, set_resource_max, get_resource_low, get_resource_min, get_resource_max, get_resource_current, reset_all_resource_limits, dmemcs_offline, dmemcs_free, dmem_cgroup_calculate_protection",
          "description": "实现内存池释放逻辑（free_cg_pool）及资源限制设置/获取接口（set_resource_* / get_resource_*）；通过RCU和自旋锁保护池生命周期管理；处理cgroup卸载时的资源重置（dmemcs_offline）和彻底销毁（dmemcs_free）；计算层级保护策略（dmem_cgroup_calculate_protection）",
          "similarity": 0.5501812696456909
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 1,
          "end_line": 105,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright 2023-2024 Intel Corporation (Maarten Lankhorst <dev@lankhorst.se>)",
            " * Copyright 2024 Red Hat (Maxime Ripard <mripard@kernel.org>)",
            " * Partially based on the rdma and misc controllers, which bear the following copyrights:",
            " *",
            " * Copyright 2020 Google LLC",
            " * Copyright (C) 2016 Parav Pandit <pandit.parav@gmail.com>",
            " */",
            "",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroup_dmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "",
            "struct dmem_cgroup_region {",
            "\t/**",
            "\t * @ref: References keeping the region alive.",
            "\t * Keeps the region reference alive after a succesful RCU lookup.",
            "\t */",
            "\tstruct kref ref;",
            "",
            "\t/** @rcu: RCU head for freeing */",
            "\tstruct rcu_head rcu;",
            "",
            "\t/**",
            "\t * @region_node: Linked into &dmem_cgroup_regions list.",
            "\t * Protected by RCU and global spinlock.",
            "\t */",
            "\tstruct list_head region_node;",
            "",
            "\t/**",
            "\t * @pools: List of pools linked to this region.",
            "\t * Protected by global spinlock only",
            "\t */",
            "\tstruct list_head pools;",
            "",
            "\t/** @size: Size of region, in bytes */",
            "\tu64 size;",
            "",
            "\t/** @name: Name describing the node, set by dmem_cgroup_register_region */",
            "\tchar *name;",
            "",
            "\t/**",
            "\t * @unregistered: Whether the region is unregistered by its caller.",
            "\t * No new pools should be added to the region afterwards.",
            "\t */",
            "\tbool unregistered;",
            "};",
            "",
            "struct dmemcg_state {",
            "\tstruct cgroup_subsys_state css;",
            "",
            "\tstruct list_head pools;",
            "};",
            "",
            "struct dmem_cgroup_pool_state {",
            "\tstruct dmem_cgroup_region *region;",
            "\tstruct dmemcg_state *cs;",
            "",
            "\t/* css node, RCU protected against region teardown */",
            "\tstruct list_head\tcss_node;",
            "",
            "\t/* dev node, no RCU protection required */",
            "\tstruct list_head\tregion_node;",
            "",
            "\tstruct rcu_head rcu;",
            "",
            "\tstruct page_counter cnt;",
            "",
            "\tbool inited;",
            "};",
            "",
            "/*",
            " * 3 operations require locking protection:",
            " * - Registering and unregistering region to/from list, requires global lock.",
            " * - Adding a dmem_cgroup_pool_state to a CSS, removing when CSS is freed.",
            " * - Adding a dmem_cgroup_pool_state to a region list.",
            " *",
            " * Since for the most common operations RCU provides enough protection, I",
            " * do not think more granular locking makes sense. Most protection is offered",
            " * by RCU and the lockless operating page_counter.",
            " */",
            "static DEFINE_SPINLOCK(dmemcg_lock);",
            "static LIST_HEAD(dmem_cgroup_regions);",
            "",
            "static inline struct dmemcg_state *",
            "css_to_dmemcs(struct cgroup_subsys_state *css)",
            "{",
            "\treturn container_of(css, struct dmemcg_state, css);",
            "}",
            "",
            "static inline struct dmemcg_state *get_current_dmemcs(void)",
            "{",
            "\treturn css_to_dmemcs(task_get_css(current, dmem_cgrp_id));",
            "}",
            "",
            "static struct dmemcg_state *parent_dmemcs(struct dmemcg_state *cg)",
            "{",
            "\treturn cg->css.parent ? css_to_dmemcs(cg->css.parent) : NULL;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义dmem_cgroup_region结构体，用于管理内存区域及其关联的池列表、大小、名称和注册状态；定义dmemcg_state结构体，作为cgroup子系统状态扩展；定义dmem_cgroup_pool_state结构体，保存池状态、计数器及链接节点；声明全局锁和链表头以协调多线程访问；提供css到dmemcg_state的转换函数",
          "similarity": 0.5219391584396362
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 572,
          "end_line": 704,
          "content": [
            "void dmem_cgroup_uncharge(struct dmem_cgroup_pool_state *pool, u64 size)",
            "{",
            "\tif (!pool)",
            "\t\treturn;",
            "",
            "\tpage_counter_uncharge(&pool->cnt, size);",
            "\tcss_put(&pool->cs->css);",
            "}",
            "int dmem_cgroup_try_charge(struct dmem_cgroup_region *region, u64 size,",
            "\t\t\t  struct dmem_cgroup_pool_state **ret_pool,",
            "\t\t\t  struct dmem_cgroup_pool_state **ret_limit_pool)",
            "{",
            "\tstruct dmemcg_state *cg;",
            "\tstruct dmem_cgroup_pool_state *pool;",
            "\tstruct page_counter *fail;",
            "\tint ret;",
            "",
            "\t*ret_pool = NULL;",
            "\tif (ret_limit_pool)",
            "\t\t*ret_limit_pool = NULL;",
            "",
            "\t/*",
            "\t * hold on to css, as cgroup can be removed but resource",
            "\t * accounting happens on css.",
            "\t */",
            "\tcg = get_current_dmemcs();",
            "",
            "\tpool = get_cg_pool_unlocked(cg, region);",
            "\tif (IS_ERR(pool)) {",
            "\t\tret = PTR_ERR(pool);",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tif (!page_counter_try_charge(&pool->cnt, size, &fail)) {",
            "\t\tif (ret_limit_pool) {",
            "\t\t\t*ret_limit_pool = container_of(fail, struct dmem_cgroup_pool_state, cnt);",
            "\t\t\tcss_get(&(*ret_limit_pool)->cs->css);",
            "\t\t}",
            "\t\tret = -EAGAIN;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\t/* On success, reference from get_current_dmemcs is transferred to *ret_pool */",
            "\t*ret_pool = pool;",
            "\treturn 0;",
            "",
            "err:",
            "\tcss_put(&cg->css);",
            "\treturn ret;",
            "}",
            "static int dmem_cgroup_region_capacity_show(struct seq_file *sf, void *v)",
            "{",
            "\tstruct dmem_cgroup_region *region;",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(region, &dmem_cgroup_regions, region_node) {",
            "\t\tseq_puts(sf, region->name);",
            "\t\tseq_printf(sf, \" %llu\\n\", region->size);",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn 0;",
            "}",
            "static int dmemcg_parse_limit(char *options, struct dmem_cgroup_region *region,",
            "\t\t\t      u64 *new_limit)",
            "{",
            "\tchar *end;",
            "",
            "\tif (!strcmp(options, \"max\")) {",
            "\t\t*new_limit = PAGE_COUNTER_MAX;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t*new_limit = memparse(options, &end);",
            "\tif (*end != '\\0')",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static ssize_t dmemcg_limit_write(struct kernfs_open_file *of,",
            "\t\t\t\t char *buf, size_t nbytes, loff_t off,",
            "\t\t\t\t void (*apply)(struct dmem_cgroup_pool_state *, u64))",
            "{",
            "\tstruct dmemcg_state *dmemcs = css_to_dmemcs(of_css(of));",
            "\tint err = 0;",
            "",
            "\twhile (buf && !err) {",
            "\t\tstruct dmem_cgroup_pool_state *pool = NULL;",
            "\t\tchar *options, *region_name;",
            "\t\tstruct dmem_cgroup_region *region;",
            "\t\tu64 new_limit;",
            "",
            "\t\toptions = buf;",
            "\t\tbuf = strchr(buf, '\\n');",
            "\t\tif (buf)",
            "\t\t\t*buf++ = '\\0';",
            "",
            "\t\toptions = strstrip(options);",
            "",
            "\t\t/* eat empty lines */",
            "\t\tif (!options[0])",
            "\t\t\tcontinue;",
            "",
            "\t\tregion_name = strsep(&options, \" \\t\");",
            "\t\tif (!region_name[0])",
            "\t\t\tcontinue;",
            "",
            "\t\trcu_read_lock();",
            "\t\tregion = dmemcg_get_region_by_name(region_name);",
            "\t\trcu_read_unlock();",
            "",
            "\t\tif (!region)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\terr = dmemcg_parse_limit(options, region, &new_limit);",
            "\t\tif (err < 0)",
            "\t\t\tgoto out_put;",
            "",
            "\t\tpool = get_cg_pool_unlocked(dmemcs, region);",
            "\t\tif (IS_ERR(pool)) {",
            "\t\t\terr = PTR_ERR(pool);",
            "\t\t\tgoto out_put;",
            "\t\t}",
            "",
            "\t\t/* And commit */",
            "\t\tapply(pool, new_limit);",
            "",
            "out_put:",
            "\t\tkref_put(&region->ref, dmemcg_free_region);",
            "\t}",
            "",
            "",
            "\treturn err ?: nbytes;",
            "}"
          ],
          "function_name": "dmem_cgroup_uncharge, dmem_cgroup_try_charge, dmem_cgroup_region_capacity_show, dmemcg_parse_limit, dmemcg_limit_write",
          "description": "实现内存扣费操作（dmem_cgroup_uncharge）及带检查的扣费尝试（dmem_cgroup_try_charge）；提供区域容量展示接口（dmem_cgroup_region_capacity_show）；解析限制参数（dmemcg_parse_limit）并应用到指定区域池（dmemcg_limit_write）",
          "similarity": 0.48830848932266235
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 267,
          "end_line": 367,
          "content": [
            "bool dmem_cgroup_state_evict_valuable(struct dmem_cgroup_pool_state *limit_pool,",
            "\t\t\t\t      struct dmem_cgroup_pool_state *test_pool,",
            "\t\t\t\t      bool ignore_low, bool *ret_hit_low)",
            "{",
            "\tstruct dmem_cgroup_pool_state *pool = test_pool;",
            "\tstruct page_counter *climit, *ctest;",
            "\tu64 used, min, low;",
            "",
            "\t/* Can always evict from current pool, despite limits */",
            "\tif (limit_pool == test_pool)",
            "\t\treturn true;",
            "",
            "\tif (limit_pool) {",
            "\t\tif (!parent_dmemcs(limit_pool->cs))",
            "\t\t\treturn true;",
            "",
            "\t\tfor (pool = test_pool; pool && limit_pool != pool; pool = pool_parent(pool))",
            "\t\t\t{}",
            "",
            "\t\tif (!pool)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\t/*",
            "\t\t * If there is no cgroup limiting memory usage, use the root",
            "\t\t * cgroup instead for limit calculations.",
            "\t\t */",
            "\t\tfor (limit_pool = test_pool; pool_parent(limit_pool); limit_pool = pool_parent(limit_pool))",
            "\t\t\t{}",
            "\t}",
            "",
            "\tclimit = &limit_pool->cnt;",
            "\tctest = &test_pool->cnt;",
            "",
            "\tdmem_cgroup_calculate_protection(limit_pool, test_pool);",
            "",
            "\tused = page_counter_read(ctest);",
            "\tmin = READ_ONCE(ctest->emin);",
            "",
            "\tif (used <= min)",
            "\t\treturn false;",
            "",
            "\tif (!ignore_low) {",
            "\t\tlow = READ_ONCE(ctest->elow);",
            "\t\tif (used > low)",
            "\t\t\treturn true;",
            "",
            "\t\t*ret_hit_low = true;",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void dmemcg_free_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct dmem_cgroup_region *region = container_of(rcu, typeof(*region), rcu);",
            "\tstruct dmem_cgroup_pool_state *pool, *next;",
            "",
            "\tlist_for_each_entry_safe(pool, next, &region->pools, region_node)",
            "\t\tfree_cg_pool(pool);",
            "\tkfree(region->name);",
            "\tkfree(region);",
            "}",
            "static void dmemcg_free_region(struct kref *ref)",
            "{",
            "\tstruct dmem_cgroup_region *cgregion = container_of(ref, typeof(*cgregion), ref);",
            "",
            "\tcall_rcu(&cgregion->rcu, dmemcg_free_rcu);",
            "}",
            "void dmem_cgroup_unregister_region(struct dmem_cgroup_region *region)",
            "{",
            "\tstruct list_head *entry;",
            "",
            "\tif (!region)",
            "\t\treturn;",
            "",
            "\tspin_lock(&dmemcg_lock);",
            "",
            "\t/* Remove from global region list */",
            "\tlist_del_rcu(&region->region_node);",
            "",
            "\tlist_for_each_rcu(entry, &region->pools) {",
            "\t\tstruct dmem_cgroup_pool_state *pool =",
            "\t\t\tcontainer_of(entry, typeof(*pool), region_node);",
            "",
            "\t\tlist_del_rcu(&pool->css_node);",
            "\t}",
            "",
            "\t/*",
            "\t * Ensure any RCU based lookups fail. Additionally,",
            "\t * no new pools should be added to the dead region",
            "\t * by get_cg_pool_unlocked.",
            "\t */",
            "\tregion->unregistered = true;",
            "\tspin_unlock(&dmemcg_lock);",
            "",
            "\tkref_put(&region->ref, dmemcg_free_region);",
            "}",
            "void dmem_cgroup_pool_state_put(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\tif (pool)",
            "\t\tcss_put(&pool->cs->css);",
            "}"
          ],
          "function_name": "dmem_cgroup_state_evict_valuable, dmemcg_free_rcu, dmemcg_free_region, dmem_cgroup_unregister_region, dmem_cgroup_pool_state_put",
          "description": "实现内存可驱逐性判定（dmem_cgroup_state_evict_valuable）；通过RCU异步释放内存区域相关资源（dmemcg_free_rcu/dmemcg_free_region）；提供区域注销接口（dmem_cgroup_unregister_region）标记区域无效并触发动态清理；实现池状态引用计数管理（dmem_cgroup_pool_state_put）",
          "similarity": 0.47042548656463623
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 731,
          "end_line": 784,
          "content": [
            "static int dmemcg_limit_show(struct seq_file *sf, void *v,",
            "\t\t\t    u64 (*fn)(struct dmem_cgroup_pool_state *))",
            "{",
            "\tstruct dmemcg_state *dmemcs = css_to_dmemcs(seq_css(sf));",
            "\tstruct dmem_cgroup_region *region;",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(region, &dmem_cgroup_regions, region_node) {",
            "\t\tstruct dmem_cgroup_pool_state *pool = find_cg_pool_locked(dmemcs, region);",
            "\t\tu64 val;",
            "",
            "\t\tseq_puts(sf, region->name);",
            "",
            "\t\tval = fn(pool);",
            "\t\tif (val < PAGE_COUNTER_MAX)",
            "\t\t\tseq_printf(sf, \" %lld\\n\", val);",
            "\t\telse",
            "\t\t\tseq_puts(sf, \" max\\n\");",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn 0;",
            "}",
            "static int dmem_cgroup_region_current_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn dmemcg_limit_show(sf, v, get_resource_current);",
            "}",
            "static int dmem_cgroup_region_min_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn dmemcg_limit_show(sf, v, get_resource_min);",
            "}",
            "static ssize_t dmem_cgroup_region_min_write(struct kernfs_open_file *of,",
            "\t\t\t\t      char *buf, size_t nbytes, loff_t off)",
            "{",
            "\treturn dmemcg_limit_write(of, buf, nbytes, off, set_resource_min);",
            "}",
            "static int dmem_cgroup_region_low_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn dmemcg_limit_show(sf, v, get_resource_low);",
            "}",
            "static ssize_t dmem_cgroup_region_low_write(struct kernfs_open_file *of,",
            "\t\t\t\t      char *buf, size_t nbytes, loff_t off)",
            "{",
            "\treturn dmemcg_limit_write(of, buf, nbytes, off, set_resource_low);",
            "}",
            "static int dmem_cgroup_region_max_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn dmemcg_limit_show(sf, v, get_resource_max);",
            "}",
            "static ssize_t dmem_cgroup_region_max_write(struct kernfs_open_file *of,",
            "\t\t\t\t      char *buf, size_t nbytes, loff_t off)",
            "{",
            "\treturn dmemcg_limit_write(of, buf, nbytes, off, set_resource_max);",
            "}"
          ],
          "function_name": "dmemcg_limit_show, dmem_cgroup_region_current_show, dmem_cgroup_region_min_show, dmem_cgroup_region_min_write, dmem_cgroup_region_low_show, dmem_cgroup_region_low_write, dmem_cgroup_region_max_show, dmem_cgroup_region_max_write",
          "description": "实现内存限制属性展示接口（dmemcg_limit_show系列）用于序列化输出；通过统一接口暴露当前值（get_resource_current）、最小值（get_resource_min）、低水位（get_resource_low）和最大值（get_resource_max）；提供限制参数写入接口（dmem_cgroup_region_min_write等）支持动态调整",
          "similarity": 0.42620617151260376
        }
      ]
    }
  ]
}