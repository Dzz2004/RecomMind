{
  "query": "gettimeofday",
  "timestamp": "2025-12-26 02:18:33",
  "retrieved_files": [
    {
      "source_file": "kernel/time/timeconv.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:53:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timeconv.c`\n\n---\n\n# time/timeconv.c 技术文档\n\n## 1. 文件概述\n\n`time/timeconv.c` 是 Linux 内核中用于将日历时间（自 Unix 纪元 1970-01-01 00:00:00 UTC 起的秒数）转换为本地“分解时间”（broken-down time）表示的核心实现文件。该文件提供了一个高效、精确且支持 64 位时间戳（`time64_t`）的转换函数，适用于跨越 2038 年的时间处理需求。其算法基于 Cassio Neri 与 Schneider 提出的欧几里得仿射函数方法，具有良好的数学严谨性和性能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`time64_to_tm(time64_t totalsecs, int offset, struct tm *result)`**  \n  将 64 位日历时间（UTC 秒数）结合时区偏移量转换为本地分解时间结构体 `struct tm`。\n\n### 数据结构\n\n- **`struct tm`**（定义于 `<linux/time.h>`）  \n  表示分解时间的标准结构体，包含年、月、日、时、分、秒、星期、年内日等字段。\n\n### 宏定义\n\n- `SECS_PER_HOUR`：每小时秒数（3600）\n- `SECS_PER_DAY`：每天秒数（86400）\n\n## 3. 关键实现\n\n### 时间归一化\n函数首先将输入的总秒数 `totalsecs` 与偏移量 `offset` 相加，并通过循环调整，确保秒数部分 `rem` 落在 `[0, SECS_PER_DAY)` 范围内，同时相应调整天数 `days`。这一步处理了跨日边界的情况（如负偏移导致前一天）。\n\n### 时分秒计算\n基于归一化后的 `rem`，直接通过整除和取模运算得出 `tm_hour`、`tm_min` 和 `tm_sec`。\n\n### 星期计算\n利用已知事实“1970 年 1 月 1 日是星期四”，通过 `(4 + days) % 7` 计算星期几（`tm_wday`），并确保结果为非负。\n\n### 日期计算（核心算法）\n采用 **“计算日历”**（computational calendar）方法，该日历将每年起点设为 **3 月 1 日**（即 3 月为第 0 月，次年 2 月为第 13 月），从而消除闰年对年内日计算的影响：\n\n1. **天数偏移**：将 `days` 加上常量 `2305843009213814918ULL`，使日历对齐到便于计算的周期起点。\n2. **世纪与年内日分解**：\n   - 使用 `div64_u64_rem` 将总天数按 400 年周期（146097 天）分解为世纪数 `century` 和世纪内天数 `day_of_century`。\n   - 进一步将 `day_of_century` 分解为年份偏移 `year_of_century` 和年内日 `day_of_year`。\n3. **月份与日计算**：\n   - 利用线性近似 `2141 * day_of_year + 132377` 的高 16 位作为月份索引，低 16 位除以 2141 得到日。\n4. **日历转换**：\n   - 判断是否为 1 月或 2 月（即 `day_of_year >= 306`），据此调整年、月、日及年内日 `tm_yday`。\n   - 通过减去大常量 `6313183731940000ULL` 将计算年份映射回实际 Gregorian 年份。\n5. **结果适配**：\n   - `tm_year` 设为实际年份减 1900（符合 POSIX 规范）。\n   - `tm_mon` 为 0 起始（0=1月），`tm_mday` 为 1 起始。\n\n该算法避免了传统循环或查表方式，完全基于整数算术，高效且无分支预测惩罚。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/time.h>`：提供 `time64_t`、`struct tm` 等时间相关定义\n  - `<linux/module.h>`：提供 `EXPORT_SYMBOL` 宏\n  - `<linux/kernel.h>`：提供 `div_s64_rem`、`div64_u64_rem`、`upper_32_bits`、`lower_32_bits` 等内核数学辅助函数\n- **导出符号**：\n  - `time64_to_tm` 通过 `EXPORT_SYMBOL` 导出，可供其他内核模块使用\n\n## 5. 使用场景\n\n- **系统调用实现**：如 `localtime()`、`gmtime()` 等用户空间时间转换函数的内核支持\n- **文件系统时间戳处理**：在需要将 inode 时间戳转换为可读日期时使用\n- **日志与调试**：内核日志中打印人类可读的时间信息\n- **网络协议栈**：处理 HTTP、NTP 等协议中的日期字段\n- **定时器与调度**：在需要将绝对时间转换为日历时间进行调度决策时\n- **Y2038 安全**：作为 64 位时间基础设施的一部分，确保内核在 2038 年后仍能正确处理时间",
      "similarity": 0.4749598503112793,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/timeconv.c",
          "start_line": 47,
          "end_line": 140,
          "content": [
            "void time64_to_tm(time64_t totalsecs, int offset, struct tm *result)",
            "{",
            "\tu32 u32tmp, day_of_century, year_of_century, day_of_year, month, day;",
            "\tu64 u64tmp, udays, century, year;",
            "\tbool is_Jan_or_Feb, is_leap_year;",
            "\tlong days, rem;",
            "\tint remainder;",
            "",
            "\tdays = div_s64_rem(totalsecs, SECS_PER_DAY, &remainder);",
            "\trem = remainder;",
            "\trem += offset;",
            "\twhile (rem < 0) {",
            "\t\trem += SECS_PER_DAY;",
            "\t\t--days;",
            "\t}",
            "\twhile (rem >= SECS_PER_DAY) {",
            "\t\trem -= SECS_PER_DAY;",
            "\t\t++days;",
            "\t}",
            "",
            "\tresult->tm_hour = rem / SECS_PER_HOUR;",
            "\trem %= SECS_PER_HOUR;",
            "\tresult->tm_min = rem / 60;",
            "\tresult->tm_sec = rem % 60;",
            "",
            "\t/* January 1, 1970 was a Thursday. */",
            "\tresult->tm_wday = (4 + days) % 7;",
            "\tif (result->tm_wday < 0)",
            "\t\tresult->tm_wday += 7;",
            "",
            "\t/*",
            "\t * The following algorithm is, basically, Proposition 6.3 of Neri",
            "\t * and Schneider [1]. In a few words: it works on the computational",
            "\t * (fictitious) calendar where the year starts in March, month = 2",
            "\t * (*), and finishes in February, month = 13. This calendar is",
            "\t * mathematically convenient because the day of the year does not",
            "\t * depend on whether the year is leap or not. For instance:",
            "\t *",
            "\t * March 1st\t\t0-th day of the year;",
            "\t * ...",
            "\t * April 1st\t\t31-st day of the year;",
            "\t * ...",
            "\t * January 1st\t\t306-th day of the year; (Important!)",
            "\t * ...",
            "\t * February 28th\t364-th day of the year;",
            "\t * February 29th\t365-th day of the year (if it exists).",
            "\t *",
            "\t * After having worked out the date in the computational calendar",
            "\t * (using just arithmetics) it's easy to convert it to the",
            "\t * corresponding date in the Gregorian calendar.",
            "\t *",
            "\t * [1] \"Euclidean Affine Functions and Applications to Calendar",
            "\t * Algorithms\". https://arxiv.org/abs/2102.06959",
            "\t *",
            "\t * (*) The numbering of months follows tm more closely and thus,",
            "\t * is slightly different from [1].",
            "\t */",
            "",
            "\tudays\t= ((u64) days) + 2305843009213814918ULL;",
            "",
            "\tu64tmp\t\t= 4 * udays + 3;",
            "\tcentury\t\t= div64_u64_rem(u64tmp, 146097, &u64tmp);",
            "\tday_of_century\t= (u32) (u64tmp / 4);",
            "",
            "\tu32tmp\t\t= 4 * day_of_century + 3;",
            "\tu64tmp\t\t= 2939745ULL * u32tmp;",
            "\tyear_of_century\t= upper_32_bits(u64tmp);",
            "\tday_of_year\t= lower_32_bits(u64tmp) / 2939745 / 4;",
            "",
            "\tyear\t\t= 100 * century + year_of_century;",
            "\tis_leap_year\t= year_of_century ? !(year_of_century % 4) : !(century % 4);",
            "",
            "\tu32tmp\t\t= 2141 * day_of_year + 132377;",
            "\tmonth\t\t= u32tmp >> 16;",
            "\tday\t\t= ((u16) u32tmp) / 2141;",
            "",
            "\t/*",
            "\t * Recall that January 1st is the 306-th day of the year in the",
            "\t * computational (not Gregorian) calendar.",
            "\t */",
            "\tis_Jan_or_Feb\t= day_of_year >= 306;",
            "",
            "\t/* Convert to the Gregorian calendar and adjust to Unix time. */",
            "\tyear\t\t= year + is_Jan_or_Feb - 6313183731940000ULL;",
            "\tmonth\t\t= is_Jan_or_Feb ? month - 12 : month;",
            "\tday\t\t= day + 1;",
            "\tday_of_year\t+= is_Jan_or_Feb ? -306 : 31 + 28 + is_leap_year;",
            "",
            "\t/* Convert to tm's format. */",
            "\tresult->tm_year = (long) (year - 1900);",
            "\tresult->tm_mon  = (int) month;",
            "\tresult->tm_mday = (int) day;",
            "\tresult->tm_yday = (int) day_of_year;",
            "}"
          ],
          "function_name": "time64_to_tm",
          "description": "该函数实现将64位时间戳转换为tm结构体，通过计算天数、处理闰年规则、应用纪元起始日星期信息，并采用基于数学推导的格里高利历算法进行月日转换，最终填充tm结构体成员",
          "similarity": 0.4757586419582367
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/timeconv.c",
          "start_line": 1,
          "end_line": 46,
          "content": [
            "// SPDX-License-Identifier: LGPL-2.0+",
            "/*",
            " * Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.",
            " * This file is part of the GNU C Library.",
            " * Contributed by Paul Eggert (eggert@twinsun.com).",
            " *",
            " * The GNU C Library is free software; you can redistribute it and/or",
            " * modify it under the terms of the GNU Library General Public License as",
            " * published by the Free Software Foundation; either version 2 of the",
            " * License, or (at your option) any later version.",
            " *",
            " * The GNU C Library is distributed in the hope that it will be useful,",
            " * but WITHOUT ANY WARRANTY; without even the implied warranty of",
            " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            " * Library General Public License for more details.",
            " *",
            " * You should have received a copy of the GNU Library General Public",
            " * License along with the GNU C Library; see the file COPYING.LIB.  If not,",
            " * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,",
            " * Boston, MA 02111-1307, USA.",
            " */",
            "",
            "/*",
            " * Converts the calendar time to broken-down time representation",
            " *",
            " * 2009-7-14:",
            " *   Moved from glibc-2.6 to kernel by Zhaolei<zhaolei@cn.fujitsu.com>",
            " * 2021-06-02:",
            " *   Reimplemented by Cassio Neri <cassio.neri@gmail.com>",
            " */",
            "",
            "#include <linux/time.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "",
            "#define SECS_PER_HOUR\t(60 * 60)",
            "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
            "",
            "/**",
            " * time64_to_tm - converts the calendar time to local broken-down time",
            " *",
            " * @totalsecs:\tthe number of seconds elapsed since 00:00:00 on January 1, 1970,",
            " *\t\tCoordinated Universal Time (UTC).",
            " * @offset:\toffset seconds adding to totalsecs.",
            " * @result:\tpointer to struct tm variable to receive broken-down time",
            " */"
          ],
          "function_name": null,
          "description": "此代码块定义了time64_to_tm函数的原型，用于将Unix时间戳（以秒为单位）转换为本地分解时间结构体tm，接受总秒数、时区偏移量和结果缓冲区参数，但未包含函数实现细节",
          "similarity": 0.4701077342033386
        }
      ]
    },
    {
      "source_file": "kernel/time/itimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:39:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\itimer.c`\n\n---\n\n# `time/itimer.c` 技术文档\n\n## 1. 文件概述\n\n`time/itimer.c` 是 Linux 内核中实现 POSIX 间隔定时器（interval timers，简称 itimers）的核心文件。该文件提供了对三种经典 Unix 间隔定时器的支持：\n\n- **ITIMER_REAL**：基于真实时间（墙上时钟）的定时器，到期时发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL**：基于进程用户态 CPU 时间的定时器，到期时发送 `SIGVTALRM` 信号\n- **ITIMER_PROF**：基于进程总 CPU 时间（用户态+内核态）的定时器，到期时发送 `SIGPROF` 信号\n\n该文件实现了 `getitimer()`、`setitimer()` 系统调用以及 `alarm()` 系统调用（在架构支持的情况下），为用户空间程序提供间隔定时器功能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`itimer_get_remtime()`**：获取高精度实时定时器的剩余时间\n- **`get_cpu_itimer()`**：获取 CPU 时间相关的定时器（虚拟/性能）状态\n- **`do_getitimer()`**：内部实现获取指定类型定时器状态的逻辑\n- **`put_itimerval()`**：将内核内部的 `itimerspec64` 格式转换为用户空间的 `old_itimerval` 格式\n- **`getitimer()` 系统调用**：用户空间获取定时器状态的入口\n- **`it_real_fn()`**：ITIMER_REAL 定时器到期时的回调函数\n- **`set_cpu_itimer()`**：设置 CPU 时间相关的定时器\n- **`do_setitimer()`**：内部实现设置指定类型定时器的逻辑\n- **`clear_itimer()`**：在 SELinux 环境下清除所有定时器（安全相关）\n- **`alarm_setitimer()`**：实现 `alarm()` 系统调用的内部函数\n- **`alarm()` 系统调用**：设置单次实时定时器的简化接口\n\n### 数据结构\n\n- **`struct cpu_itimer`**：存储 CPU 时间定时器的状态（在 `signal_struct` 中）\n- **`struct hrtimer`**：高精度定时器，用于实现 ITIMER_REAL\n- **`struct itimerspec64`**：64 位时间规格结构，内核内部使用\n- **`struct __kernel_old_itimerval`**：用户空间兼容的定时器值结构\n\n## 3. 关键实现\n\n### 定时器类型实现差异\n\n- **ITIMER_REAL**：使用高精度定时器（`hrtimer`）实现，基于真实时间，通过 `hrtimer_start()` 启动，到期时调用 `it_real_fn()` 发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL/ITIMER_PROF**：基于 CPU 时间采样实现，通过 `thread_group_sample_cputime()` 获取当前进程组的 CPU 时间，与设定的过期时间比较来判断是否到期\n\n### 时间精度处理\n\n- 使用纳秒级精度的 `ktime_t` 和 `timespec64` 进行内部计算\n- 用户空间接口使用微秒精度（`tv_usec`），通过 `NSEC_PER_USEC` 进行单位转换\n- 对于即将到期的定时器，返回 `TICK_NSEC`（1 微秒）作为剩余时间，避免返回 0 导致用户误判\n\n### 并发安全\n\n- 使用 `siglock` 自旋锁保护信号结构体中的定时器状态\n- ITIMER_REAL 的设置操作需要处理定时器可能正在执行的竞态条件，通过 `hrtimer_try_to_cancel()` 和重试机制确保安全\n- CPU 定时器操作在 `siglock` 保护下进行，确保线程组内的一致性\n\n### 兼容性支持\n\n- 提供 32 位兼容接口（`COMPAT_SYSCALL_DEFINE2`）\n- 支持 `alarm()` 系统调用（在 `__ARCH_WANT_SYS_ALARM` 定义时）\n- 处理 32 位系统上的时间值溢出问题（限制为 `INT_MAX`）\n\n## 4. 依赖关系\n\n### 头文件依赖\n\n- **`<linux/hrtimer.h>`**：高精度定时器框架，用于 ITIMER_REAL 实现\n- **`<linux/sched/cputime.h>`**：CPU 时间采样功能，用于虚拟和性能定时器\n- **`<linux/posix-timers.h>`**：POSIX 定时器相关定义\n- **`<linux/sched/signal.h>`**：信号处理和 `signal_struct` 结构定义\n- **`<linux/time.h>`**：时间转换和操作函数\n- **`<trace/events/timer.h>`**：定时器事件跟踪支持\n\n### 内核子系统依赖\n\n- **调度子系统**：通过 `current` 获取当前任务，使用 `thread_group_sample_cputime()` 采样 CPU 时间\n- **信号子系统**：通过 `kill_pid_info()` 发送信号，使用 `siglock` 进行同步\n- **高精度定时器子系统**：ITIMER_REAL 的底层实现依赖 hrtimer 框架\n- **安全子系统**：SELinux 相关的 `clear_itimer()` 函数\n\n## 5. 使用场景\n\n### 用户空间编程\n\n- **定时任务**：应用程序使用 `setitimer()` 设置周期性或一次性定时器\n- **超时控制**：网络编程中设置 I/O 操作超时\n- **性能监控**：使用 ITIMER_PROF 监控程序 CPU 使用情况\n- **简单定时**：使用 `alarm()` 系统调用设置简单的秒级定时器\n\n### 内核内部使用\n\n- **进程管理**：在进程退出或权限变更时清除定时器（SELinux 场景）\n- **信号处理**：定时器到期时向进程发送相应信号\n- **时间跟踪**：通过 tracepoint 记录定时器状态变化和到期事件\n- **兼容层**：为不同架构和位数提供统一的定时器接口\n\n### 系统调用路径\n\n- **`getitimer()`** → `do_getitimer()` → 对应定时器类型的具体获取函数\n- **`setitimer()`** → `do_setitimer()` → 对应定时器类型的具体设置函数  \n- **`alarm()`** → `alarm_setitimer()` → `do_setitimer(ITIMER_REAL, ...)`\n\n该文件是 Linux 内核 POSIX 定时器功能的重要组成部分，为用户空间提供了经典的 Unix 间隔定时器接口。",
      "similarity": 0.46466064453125,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/itimer.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992 Darren Senn",
            " */",
            "",
            "/* These are all the functions necessary to implement itimers */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/time.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/hrtimer.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/compat.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "/**",
            " * itimer_get_remtime - get remaining time for the timer",
            " *",
            " * @timer: the timer to read",
            " *",
            " * Returns the delta between the expiry time and now, which can be",
            " * less than zero or 1usec for an pending expired timer",
            " */"
          ],
          "function_name": null,
          "description": "该代码块定义了itimer_get_remtime函数的原型，用于获取高精度定时器的剩余时间，通过计算当前时间与定时器到期时间的差值得到剩余时间，但未提供完整实现，上下文不完整",
          "similarity": 0.5503346920013428
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/itimer.c",
          "start_line": 29,
          "end_line": 129,
          "content": [
            "static struct timespec64 itimer_get_remtime(struct hrtimer *timer)",
            "{",
            "\tktime_t rem = __hrtimer_get_remaining(timer, true);",
            "",
            "\t/*",
            "\t * Racy but safe: if the itimer expires after the above",
            "\t * hrtimer_get_remtime() call but before this condition",
            "\t * then we return 0 - which is correct.",
            "\t */",
            "\tif (hrtimer_active(timer)) {",
            "\t\tif (rem <= 0)",
            "\t\t\trem = NSEC_PER_USEC;",
            "\t} else",
            "\t\trem = 0;",
            "",
            "\treturn ktime_to_timespec64(rem);",
            "}",
            "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   struct itimerspec64 *const value)",
            "{",
            "\tu64 val, interval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\tval = it->expires;",
            "\tinterval = it->incr;",
            "\tif (val) {",
            "\t\tu64 t, samples[CPUCLOCK_MAX];",
            "",
            "\t\tthread_group_sample_cputime(tsk, samples);",
            "\t\tt = samples[clock_id];",
            "",
            "\t\tif (val < t)",
            "\t\t\t/* about to fire */",
            "\t\t\tval = TICK_NSEC;",
            "\t\telse",
            "\t\t\tval -= t;",
            "\t}",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tvalue->it_value = ns_to_timespec64(val);",
            "\tvalue->it_interval = ns_to_timespec64(interval);",
            "}",
            "static int do_getitimer(int which, struct itimerspec64 *value)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);",
            "\t\tvalue->it_interval =",
            "\t\t\tktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn(-EINVAL);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int put_itimerval(struct __kernel_old_itimerval __user *o,",
            "\t\t\t const struct itimerspec64 *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tv.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v, sizeof(struct __kernel_old_itimerval)) ? -EFAULT : 0;",
            "}",
            "static int put_old_itimerval32(struct old_itimerval32 __user *o,",
            "\t\t\t       const struct itimerspec64 *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tv32.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv32.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv32.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv32.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v32, sizeof(struct old_itimerval32)) ? -EFAULT : 0;",
            "}",
            "enum hrtimer_restart it_real_fn(struct hrtimer *timer)",
            "{",
            "\tstruct signal_struct *sig =",
            "\t\tcontainer_of(timer, struct signal_struct, real_timer);",
            "\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];",
            "",
            "\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);",
            "\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}"
          ],
          "function_name": "itimer_get_remtime, get_cpu_itimer, do_getitimer, put_itimerval, put_old_itimerval32, it_real_fn",
          "description": "实现了itimer_get_remtime获取剩余时间、get_cpu_itimer读取CPU定时器信息、do_getitimer根据时钟类型获取定时器状态、put_itimerval/put_old_itimerval32转换并复制时间值到用户空间，以及it_real_fn作为实时时钟的超时处理函数",
          "similarity": 0.5447057485580444
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/itimer.c",
          "start_line": 313,
          "end_line": 348,
          "content": [
            "static int get_itimerval(struct itimerspec64 *o, const struct __kernel_old_itimerval __user *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tif (copy_from_user(&v, i, sizeof(struct __kernel_old_itimerval)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value. */",
            "\tif (!timeval_valid(&v.it_value) ||",
            "\t    !timeval_valid(&v.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}",
            "static int get_old_itimerval32(struct itimerspec64 *o, const struct old_itimerval32 __user *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tif (copy_from_user(&v32, i, sizeof(struct old_itimerval32)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value.  */",
            "\tif (!timeval_valid(&v32.it_value) ||",
            "\t    !timeval_valid(&v32.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v32.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v32.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v32.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v32.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_itimerval, get_old_itimerval32",
          "description": "实现get_itimerval/get_old_itimerval32将用户态时间值转换为内核时间结构体，执行有效性校验，确保输入时间值在合法范围内",
          "similarity": 0.5270363688468933
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/itimer.c",
          "start_line": 168,
          "end_line": 275,
          "content": [
            "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   const struct itimerspec64 *const value,",
            "\t\t\t   struct itimerspec64 *const ovalue)",
            "{",
            "\tu64 oval, nval, ointerval, ninterval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tnval = timespec64_to_ns(&value->it_value);",
            "\tninterval = timespec64_to_ns(&value->it_interval);",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\toval = it->expires;",
            "\tointerval = it->incr;",
            "\tif (oval || nval) {",
            "\t\tif (nval > 0)",
            "\t\t\tnval += TICK_NSEC;",
            "\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);",
            "\t}",
            "\tit->expires = nval;",
            "\tit->incr = ninterval;",
            "\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?",
            "\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tif (ovalue) {",
            "\t\tovalue->it_value = ns_to_timespec64(oval);",
            "\t\tovalue->it_interval = ns_to_timespec64(ointerval);",
            "\t}",
            "}",
            "static int do_setitimer(int which, struct itimerspec64 *value,",
            "\t\t\tstruct itimerspec64 *ovalue)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct hrtimer *timer;",
            "\tktime_t expires;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "again:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\ttimer = &tsk->signal->real_timer;",
            "\t\tif (ovalue) {",
            "\t\t\tovalue->it_value = itimer_get_remtime(timer);",
            "\t\t\tovalue->it_interval",
            "\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\t}",
            "\t\t/* We are sharing ->siglock with it_real_fn() */",
            "\t\tif (hrtimer_try_to_cancel(timer) < 0) {",
            "\t\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\t\thrtimer_cancel_wait_running(timer);",
            "\t\t\tgoto again;",
            "\t\t}",
            "\t\texpires = timespec64_to_ktime(value->it_value);",
            "\t\tif (expires != 0) {",
            "\t\t\ttsk->signal->it_real_incr =",
            "\t\t\t\ttimespec64_to_ktime(value->it_interval);",
            "\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);",
            "\t\t} else",
            "\t\t\ttsk->signal->it_real_incr = 0;",
            "",
            "\t\ttrace_itimer_state(ITIMER_REAL, value, 0);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "void clear_itimer(void)",
            "{",
            "\tstruct itimerspec64 v = {};",
            "\tint i;",
            "",
            "\tfor (i = 0; i < 3; i++)",
            "\t\tdo_setitimer(i, &v, NULL);",
            "}",
            "static unsigned int alarm_setitimer(unsigned int seconds)",
            "{",
            "\tstruct itimerspec64 it_new, it_old;",
            "",
            "#if BITS_PER_LONG < 64",
            "\tif (seconds > INT_MAX)",
            "\t\tseconds = INT_MAX;",
            "#endif",
            "\tit_new.it_value.tv_sec = seconds;",
            "\tit_new.it_value.tv_nsec = 0;",
            "\tit_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;",
            "",
            "\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);",
            "",
            "\t/*",
            "\t * We can't return 0 if we have an alarm pending ...  And we'd",
            "\t * better return too much than too little anyway",
            "\t */",
            "\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||",
            "\t      it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))",
            "\t\tit_old.it_value.tv_sec++;",
            "",
            "\treturn it_old.it_value.tv_sec;",
            "}"
          ],
          "function_name": "set_cpu_itimer, do_setitimer, clear_itimer, alarm_setitimer",
          "description": "包含set_cpu_itimer设置CPU定时器参数、do_setitimer根据时钟类型配置定时器、clear_itimer清除所有定时器、alarm_setitimer设置一次性闹钟，其中do_setitimer处理实时时钟的启动和取消操作",
          "similarity": 0.4862552881240845
        }
      ]
    },
    {
      "source_file": "kernel/time/time.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:52:34\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\time.c`\n\n---\n\n# time/time.c 技术文档\n\n## 1. 文件概述\n\n`time/time.c` 是 Linux 内核中负责实现与时间相关的系统调用的核心文件。该文件提供了用户空间程序访问和设置系统时间的接口，包括 `time`、`stime`、`gettimeofday`、`settimeofday` 和 `adjtimex` 等传统 POSIX 时间系统调用。文件同时支持 32 位和 64 位时间表示，并处理不同架构和兼容性需求，确保内核时间子系统与用户空间的正确交互。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`sys_tz`** (`struct timezone`)：全局变量，存储系统默认时区信息，供 `gettimeofday` 系统调用返回。\n\n### 主要函数\n- **`SYSCALL_DEFINE1(time, ...)`**：返回自 Unix 纪元（1970-01-01 00:00:00 UTC）以来的秒数。\n- **`SYSCALL_DEFINE1(stime, ...)`**：设置系统时间（仅秒级精度）。\n- **`SYSCALL_DEFINE2(gettimeofday, ...)`**：获取高精度系统时间（微秒级）和时区信息。\n- **`SYSCALL_DEFINE2(settimeofday, ...)`**：设置系统时间（微秒级精度）和/或时区。\n- **`do_sys_settimeofday64(...)`**：`settimeofday` 的核心实现函数，处理时间/时区验证、安全检查和时钟调整。\n- **`SYSCALL_DEFINE1(adjtimex, ...)`**：用于 NTP（网络时间协议）时间同步，调整系统时钟频率和偏移。\n- **兼容性系统调用**：\n  - `time32` / `stime32`：32 位时间值的兼容接口（用于 `CONFIG_COMPAT_32BIT_TIME`）。\n  - `COMPAT_SYSCALL_DEFINE2(gettimeofday, ...)` / `COMPAT_SYSCALL_DEFINE2(settimeofday, ...)`：32 位用户空间兼容接口。\n- **辅助函数**：\n  - `get_old_timex32(...)`：将 32 位 `old_timex32` 结构转换为内核 `__kernel_timex`。\n  - `put_old_timex32(...)`：将内核 `__kernel_timex` 结构转换回 32 位 `old_timex32`（代码截断）。\n\n## 3. 关键实现\n\n### 时间获取与设置\n- 使用 `ktime_get_real_seconds()` 和 `ktime_get_real_ts64()` 从内核时间子系统获取高精度实时时间。\n- 时间设置通过 `do_settimeofday64()` 接口完成，该函数负责更新内核时间状态并通知相关子系统。\n\n### 时区处理\n- 全局变量 `sys_tz` 存储系统时区，通过 `settimeofday` 更新。\n- 首次设置时区时（`firsttime == 1`），若未同时设置时间，则调用 `timekeeping_warp_clock()` 将 CMOS 时钟从本地时间转换为 UTC 时间，避免时间跳变对应用程序造成影响。\n\n### 安全与验证\n- 所有修改系统时间的操作均调用 `security_settime64()` 进行 LSM（Linux Security Module）安全检查。\n- 输入参数严格验证：\n  - 时间值必须通过 `timespec64_valid_settod()` 检查有效性。\n  - 时区偏移限制在 ±15 小时范围内（`tz_minuteswest ∈ [-900, 900]`）。\n  - 微秒值必须在 `[0, USEC_PER_SEC)` 范围内。\n\n### 兼容性支持\n- 通过条件编译宏（如 `__ARCH_WANT_SYS_TIME`、`CONFIG_COMPAT_32BIT_TIME`、`CONFIG_COMPAT`）支持不同架构和位宽需求。\n- 32 位时间接口（`time32`/`stime32`）用于处理 `time_t` 为 32 位的旧应用程序。\n- 兼容层系统调用处理 32 位用户空间结构体与 64 位内核结构体之间的转换。\n\n### NTP 支持\n- `adjtimex` 系统调用提供对内核 PLL（锁相环）的精细控制，用于 NTP 时间同步。\n- 支持 NTPv4 规范，允许更大的时间常数（`time_constant > 6`）。\n\n## 4. 依赖关系\n\n- **内核时间子系统**：\n  - `<linux/timekeeper_internal.h>`、`\"timekeeping.h\"`：提供 `ktime_get_real_ts64()`、`do_settimeofday64()`、`timekeeping_warp_clock()` 等核心时间操作。\n- **安全框架**：\n  - `<linux/security.h>`：提供 `security_settime64()` 安全钩子。\n- **系统调用框架**：\n  - `<linux/syscalls.h>`：定义 `SYSCALL_DEFINE` 宏。\n  - `<linux/compat.h>`：提供 32/64 位兼容系统调用支持。\n- **架构相关**：\n  - `<asm/unistd.h>`：包含系统调用号定义。\n  - `__ARCH_WANT_SYS_TIME` 等宏由具体架构定义，决定是否编译传统时间系统调用。\n- **其他**：\n  - `<linux/uaccess.h>`：提供用户空间内存访问函数（`get_user`、`put_user`、`copy_to/from_user`）。\n  - `<generated/timeconst.h>`：包含编译时生成的时间常量。\n\n## 5. 使用场景\n\n- **用户空间时间获取**：应用程序通过 `gettimeofday()` 获取高精度当前时间，用于日志记录、性能分析、定时器等。\n- **系统时间设置**：管理员或 NTP 守护进程（如 `ntpd`、`chronyd`）通过 `settimeofday()` 或 `adjtimex()` 同步系统时间。\n- **时区配置**：系统初始化脚本（如 `/etc/rc`）通过 `settimeofday()` 设置时区，确保 CMOS 时钟以 UTC 运行。\n- **遗留应用支持**：32 位时间接口支持在 64 位系统上运行的旧版应用程序（Y2038 问题兼容）。\n- **NTP 精确时间同步**：`adjtimex()` 系统调用被 NTP 守护进程用于微调系统时钟频率和相位，实现高精度时间同步。",
      "similarity": 0.46453791856765747,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/time.c",
          "start_line": 169,
          "end_line": 273,
          "content": [
            "int do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)",
            "{",
            "\tstatic int firsttime = 1;",
            "\tint error = 0;",
            "",
            "\tif (tv && !timespec64_valid_settod(tv))",
            "\t\treturn -EINVAL;",
            "",
            "\terror = security_settime64(tv, tz);",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\tif (tz) {",
            "\t\t/* Verify we're within the +-15 hrs range */",
            "\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tsys_tz = *tz;",
            "\t\tupdate_vsyscall_tz();",
            "\t\tif (firsttime) {",
            "\t\t\tfirsttime = 0;",
            "\t\t\tif (!tv)",
            "\t\t\t\ttimekeeping_warp_clock();",
            "\t\t}",
            "\t}",
            "\tif (tv)",
            "\t\treturn do_settimeofday64(tv);",
            "\treturn 0;",
            "}",
            "int get_old_timex32(struct __kernel_timex *txc, const struct old_timex32 __user *utp)",
            "{",
            "\tstruct old_timex32 tx32;",
            "",
            "\tmemset(txc, 0, sizeof(struct __kernel_timex));",
            "\tif (copy_from_user(&tx32, utp, sizeof(struct old_timex32)))",
            "\t\treturn -EFAULT;",
            "",
            "\ttxc->modes = tx32.modes;",
            "\ttxc->offset = tx32.offset;",
            "\ttxc->freq = tx32.freq;",
            "\ttxc->maxerror = tx32.maxerror;",
            "\ttxc->esterror = tx32.esterror;",
            "\ttxc->status = tx32.status;",
            "\ttxc->constant = tx32.constant;",
            "\ttxc->precision = tx32.precision;",
            "\ttxc->tolerance = tx32.tolerance;",
            "\ttxc->time.tv_sec = tx32.time.tv_sec;",
            "\ttxc->time.tv_usec = tx32.time.tv_usec;",
            "\ttxc->tick = tx32.tick;",
            "\ttxc->ppsfreq = tx32.ppsfreq;",
            "\ttxc->jitter = tx32.jitter;",
            "\ttxc->shift = tx32.shift;",
            "\ttxc->stabil = tx32.stabil;",
            "\ttxc->jitcnt = tx32.jitcnt;",
            "\ttxc->calcnt = tx32.calcnt;",
            "\ttxc->errcnt = tx32.errcnt;",
            "\ttxc->stbcnt = tx32.stbcnt;",
            "",
            "\treturn 0;",
            "}",
            "int put_old_timex32(struct old_timex32 __user *utp, const struct __kernel_timex *txc)",
            "{",
            "\tstruct old_timex32 tx32;",
            "",
            "\tmemset(&tx32, 0, sizeof(struct old_timex32));",
            "\ttx32.modes = txc->modes;",
            "\ttx32.offset = txc->offset;",
            "\ttx32.freq = txc->freq;",
            "\ttx32.maxerror = txc->maxerror;",
            "\ttx32.esterror = txc->esterror;",
            "\ttx32.status = txc->status;",
            "\ttx32.constant = txc->constant;",
            "\ttx32.precision = txc->precision;",
            "\ttx32.tolerance = txc->tolerance;",
            "\ttx32.time.tv_sec = txc->time.tv_sec;",
            "\ttx32.time.tv_usec = txc->time.tv_usec;",
            "\ttx32.tick = txc->tick;",
            "\ttx32.ppsfreq = txc->ppsfreq;",
            "\ttx32.jitter = txc->jitter;",
            "\ttx32.shift = txc->shift;",
            "\ttx32.stabil = txc->stabil;",
            "\ttx32.jitcnt = txc->jitcnt;",
            "\ttx32.calcnt = txc->calcnt;",
            "\ttx32.errcnt = txc->errcnt;",
            "\ttx32.stbcnt = txc->stbcnt;",
            "\ttx32.tai = txc->tai;",
            "\tif (copy_to_user(utp, &tx32, sizeof(struct old_timex32)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "unsigned int jiffies_to_msecs(const unsigned long j)",
            "{",
            "#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)",
            "\treturn (MSEC_PER_SEC / HZ) * j;",
            "#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)",
            "\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);",
            "#else",
            "# if BITS_PER_LONG == 32",
            "\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>",
            "\t       HZ_TO_MSEC_SHR32;",
            "# else",
            "\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);",
            "# endif",
            "#endif",
            "}"
          ],
          "function_name": "do_sys_settimeofday64, get_old_timex32, put_old_timex32, jiffies_to_msecs",
          "description": "实现do_sys_settimeofday64用于设置系统时间，提供old_timex结构体转换函数get_old_timex32/put_old_timex32，以及jiffies到毫秒的转换函数jiffies_to_msecs。",
          "similarity": 0.5804663300514221
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/time.c",
          "start_line": 1,
          "end_line": 168,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " *",
            " *  This file contains the interface functions for the various time related",
            " *  system calls: time, stime, gettimeofday, settimeofday, adjtime",
            " *",
            " * Modification history:",
            " *",
            " * 1993-09-02    Philip Gladstone",
            " *      Created file with time related functions from sched/core.c and adjtimex()",
            " * 1993-10-08    Torsten Duwe",
            " *      adjtime interface update and CMOS clock write code",
            " * 1995-08-13    Torsten Duwe",
            " *      kernel PLL updated to 1994-12-13 specs (rfc-1589)",
            " * 1999-01-16    Ulrich Windl",
            " *\tIntroduced error checking for many cases in adjtimex().",
            " *\tUpdated NTP code according to technical memorandum Jan '96",
            " *\t\"A Kernel Model for Precision Timekeeping\" by Dave Mills",
            " *\tAllow time_constant larger than MAXTC(6) for NTP v4 (MAXTC == 10)",
            " *\t(Even though the technical memorandum forbids it)",
            " * 2004-07-14\t Christoph Lameter",
            " *\tAdded getnstimeofday to allow the posix timer functions to return",
            " *\twith nanosecond accuracy",
            " */",
            "",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/timex.h>",
            "#include <linux/capability.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/errno.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/math64.h>",
            "#include <linux/ptrace.h>",
            "",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <asm/unistd.h>",
            "",
            "#include <generated/timeconst.h>",
            "#include \"timekeeping.h\"",
            "",
            "/*",
            " * The timezone where the local system is located.  Used as a default by some",
            " * programs who obtain this value by using gettimeofday.",
            " */",
            "struct timezone sys_tz;",
            "",
            "EXPORT_SYMBOL(sys_tz);",
            "",
            "#ifdef __ARCH_WANT_SYS_TIME",
            "",
            "/*",
            " * sys_time() can be implemented in user-level using",
            " * sys_gettimeofday().  Is this for backwards compatibility?  If so,",
            " * why not move it into the appropriate arch directory (for those",
            " * architectures that need it).",
            " */",
            "SYSCALL_DEFINE1(time, __kernel_old_time_t __user *, tloc)",
            "{",
            "\t__kernel_old_time_t i = (__kernel_old_time_t)ktime_get_real_seconds();",
            "",
            "\tif (tloc) {",
            "\t\tif (put_user(i,tloc))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\tforce_successful_syscall_return();",
            "\treturn i;",
            "}",
            "",
            "/*",
            " * sys_stime() can be implemented in user-level using",
            " * sys_settimeofday().  Is this for backwards compatibility?  If so,",
            " * why not move it into the appropriate arch directory (for those",
            " * architectures that need it).",
            " */",
            "",
            "SYSCALL_DEFINE1(stime, __kernel_old_time_t __user *, tptr)",
            "{",
            "\tstruct timespec64 tv;",
            "\tint err;",
            "",
            "\tif (get_user(tv.tv_sec, tptr))",
            "\t\treturn -EFAULT;",
            "",
            "\ttv.tv_nsec = 0;",
            "",
            "\terr = security_settime64(&tv, NULL);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tdo_settimeofday64(&tv);",
            "\treturn 0;",
            "}",
            "",
            "#endif /* __ARCH_WANT_SYS_TIME */",
            "",
            "#ifdef CONFIG_COMPAT_32BIT_TIME",
            "#ifdef __ARCH_WANT_SYS_TIME32",
            "",
            "/* old_time32_t is a 32 bit \"long\" and needs to get converted. */",
            "SYSCALL_DEFINE1(time32, old_time32_t __user *, tloc)",
            "{",
            "\told_time32_t i;",
            "",
            "\ti = (old_time32_t)ktime_get_real_seconds();",
            "",
            "\tif (tloc) {",
            "\t\tif (put_user(i,tloc))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\tforce_successful_syscall_return();",
            "\treturn i;",
            "}",
            "",
            "SYSCALL_DEFINE1(stime32, old_time32_t __user *, tptr)",
            "{",
            "\tstruct timespec64 tv;",
            "\tint err;",
            "",
            "\tif (get_user(tv.tv_sec, tptr))",
            "\t\treturn -EFAULT;",
            "",
            "\ttv.tv_nsec = 0;",
            "",
            "\terr = security_settime64(&tv, NULL);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tdo_settimeofday64(&tv);",
            "\treturn 0;",
            "}",
            "",
            "#endif /* __ARCH_WANT_SYS_TIME32 */",
            "#endif",
            "",
            "SYSCALL_DEFINE2(gettimeofday, struct __kernel_old_timeval __user *, tv,",
            "\t\tstruct timezone __user *, tz)",
            "{",
            "\tif (likely(tv != NULL)) {",
            "\t\tstruct timespec64 ts;",
            "",
            "\t\tktime_get_real_ts64(&ts);",
            "\t\tif (put_user(ts.tv_sec, &tv->tv_sec) ||",
            "\t\t    put_user(ts.tv_nsec / 1000, &tv->tv_usec))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\tif (unlikely(tz != NULL)) {",
            "\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\treturn 0;",
            "}",
            "",
            "/*",
            " * In case for some reason the CMOS clock has not already been running",
            " * in UTC, but in some local time: The first time we set the timezone,",
            " * we will warp the clock so that it is ticking UTC time instead of",
            " * local time. Presumably, if someone is setting the timezone then we",
            " * are running in an environment where the programs understand about",
            " * timezones. This should be done at boot time in the /etc/rc script,",
            " * as soon as possible, so that the clock can be set right. Otherwise,",
            " * various programs will get confused when the clock gets warped.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "定义了时间相关系统调用接口，包括time、stime、gettimeofday等函数，用于获取和设置系统时间及时区信息，包含安全检查和用户空间数据拷贝操作。",
          "similarity": 0.5685999393463135
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/time.c",
          "start_line": 616,
          "end_line": 720,
          "content": [
            "unsigned long",
            "timespec64_to_jiffies(const struct timespec64 *value)",
            "{",
            "\tu64 sec = value->tv_sec;",
            "\tlong nsec = value->tv_nsec + TICK_NSEC - 1;",
            "",
            "\tif (sec >= MAX_SEC_IN_JIFFIES){",
            "\t\tsec = MAX_SEC_IN_JIFFIES;",
            "\t\tnsec = 0;",
            "\t}",
            "\treturn ((sec * SEC_CONVERSION) +",
            "\t\t(((u64)nsec * NSEC_CONVERSION) >>",
            "\t\t (NSEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;",
            "",
            "}",
            "void",
            "jiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)",
            "{",
            "\t/*",
            "\t * Convert jiffies to nanoseconds and separate with",
            "\t * one divide.",
            "\t */",
            "\tu32 rem;",
            "\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,",
            "\t\t\t\t    NSEC_PER_SEC, &rem);",
            "\tvalue->tv_nsec = rem;",
            "}",
            "clock_t jiffies_to_clock_t(unsigned long x)",
            "{",
            "#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0",
            "# if HZ < USER_HZ",
            "\treturn x * (USER_HZ / HZ);",
            "# else",
            "\treturn x / (HZ / USER_HZ);",
            "# endif",
            "#else",
            "\treturn div_u64((u64)x * TICK_NSEC, NSEC_PER_SEC / USER_HZ);",
            "#endif",
            "}",
            "unsigned long clock_t_to_jiffies(unsigned long x)",
            "{",
            "#if (HZ % USER_HZ)==0",
            "\tif (x >= ~0UL / (HZ / USER_HZ))",
            "\t\treturn ~0UL;",
            "\treturn x * (HZ / USER_HZ);",
            "#else",
            "\t/* Don't worry about loss of precision here .. */",
            "\tif (x >= ~0UL / HZ * USER_HZ)",
            "\t\treturn ~0UL;",
            "",
            "\t/* .. but do try to contain it here */",
            "\treturn div_u64((u64)x * HZ, USER_HZ);",
            "#endif",
            "}",
            "u64 jiffies_64_to_clock_t(u64 x)",
            "{",
            "#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0",
            "# if HZ < USER_HZ",
            "\tx = div_u64(x * USER_HZ, HZ);",
            "# elif HZ > USER_HZ",
            "\tx = div_u64(x, HZ / USER_HZ);",
            "# else",
            "\t/* Nothing to do */",
            "# endif",
            "#else",
            "\t/*",
            "\t * There are better ways that don't overflow early,",
            "\t * but even this doesn't overflow in hundreds of years",
            "\t * in 64 bits, so..",
            "\t */",
            "\tx = div_u64(x * TICK_NSEC, (NSEC_PER_SEC / USER_HZ));",
            "#endif",
            "\treturn x;",
            "}",
            "u64 nsec_to_clock_t(u64 x)",
            "{",
            "#if (NSEC_PER_SEC % USER_HZ) == 0",
            "\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);",
            "#elif (USER_HZ % 512) == 0",
            "\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);",
            "#else",
            "\t/*",
            "         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,",
            "         * overflow after 64.99 years.",
            "         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...",
            "         */",
            "\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);",
            "#endif",
            "}",
            "u64 jiffies64_to_nsecs(u64 j)",
            "{",
            "#if !(NSEC_PER_SEC % HZ)",
            "\treturn (NSEC_PER_SEC / HZ) * j;",
            "# else",
            "\treturn div_u64(j * HZ_TO_NSEC_NUM, HZ_TO_NSEC_DEN);",
            "#endif",
            "}",
            "u64 jiffies64_to_msecs(const u64 j)",
            "{",
            "#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)",
            "\treturn (MSEC_PER_SEC / HZ) * j;",
            "#else",
            "\treturn div_u64(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);",
            "#endif",
            "}"
          ],
          "function_name": "timespec64_to_jiffies, jiffies_to_timespec64, jiffies_to_clock_t, clock_t_to_jiffies, jiffies_64_to_clock_t, nsec_to_clock_t, jiffies64_to_nsecs, jiffies64_to_msecs",
          "description": "提供多种时间表示形式转换函数，包括timespec64与jiffies互转，clock_t与jiffies转换，以及nsec到clock_t等不同时间域间的转换实现。",
          "similarity": 0.5397475957870483
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/time.c",
          "start_line": 400,
          "end_line": 501,
          "content": [
            "unsigned int jiffies_to_usecs(const unsigned long j)",
            "{",
            "\t/*",
            "\t * Hz usually doesn't go much further MSEC_PER_SEC.",
            "\t * jiffies_to_usecs() and usecs_to_jiffies() depend on that.",
            "\t */",
            "\tBUILD_BUG_ON(HZ > USEC_PER_SEC);",
            "",
            "#if !(USEC_PER_SEC % HZ)",
            "\treturn (USEC_PER_SEC / HZ) * j;",
            "#else",
            "# if BITS_PER_LONG == 32",
            "\treturn (HZ_TO_USEC_MUL32 * j) >> HZ_TO_USEC_SHR32;",
            "# else",
            "\treturn (j * HZ_TO_USEC_NUM) / HZ_TO_USEC_DEN;",
            "# endif",
            "#endif",
            "}",
            "time64_t mktime64(const unsigned int year0, const unsigned int mon0,",
            "\t\tconst unsigned int day, const unsigned int hour,",
            "\t\tconst unsigned int min, const unsigned int sec)",
            "{",
            "\tunsigned int mon = mon0, year = year0;",
            "",
            "\t/* 1..12 -> 11,12,1..10 */",
            "\tif (0 >= (int) (mon -= 2)) {",
            "\t\tmon += 12;\t/* Puts Feb last since it has leap day */",
            "\t\tyear -= 1;",
            "\t}",
            "",
            "\treturn ((((time64_t)",
            "\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +",
            "\t\t  year*365 - 719499",
            "\t    )*24 + hour /* now have hours - midnight tomorrow handled here */",
            "\t  )*60 + min /* now have minutes */",
            "\t)*60 + sec; /* finally seconds */",
            "}",
            "struct __kernel_old_timeval ns_to_kernel_old_timeval(s64 nsec)",
            "{",
            "\tstruct timespec64 ts = ns_to_timespec64(nsec);",
            "\tstruct __kernel_old_timeval tv;",
            "",
            "\ttv.tv_sec = ts.tv_sec;",
            "\ttv.tv_usec = (suseconds_t)ts.tv_nsec / 1000;",
            "",
            "\treturn tv;",
            "}",
            "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)",
            "{",
            "\twhile (nsec >= NSEC_PER_SEC) {",
            "\t\t/*",
            "\t\t * The following asm() prevents the compiler from",
            "\t\t * optimising this loop into a modulo operation. See",
            "\t\t * also __iter_div_u64_rem() in include/linux/time.h",
            "\t\t */",
            "\t\tasm(\"\" : \"+rm\"(nsec));",
            "\t\tnsec -= NSEC_PER_SEC;",
            "\t\t++sec;",
            "\t}",
            "\twhile (nsec < 0) {",
            "\t\tasm(\"\" : \"+rm\"(nsec));",
            "\t\tnsec += NSEC_PER_SEC;",
            "\t\t--sec;",
            "\t}",
            "\tts->tv_sec = sec;",
            "\tts->tv_nsec = nsec;",
            "}",
            "struct timespec64 ns_to_timespec64(s64 nsec)",
            "{",
            "\tstruct timespec64 ts = { 0, 0 };",
            "\ts32 rem;",
            "",
            "\tif (likely(nsec > 0)) {",
            "\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);",
            "\t\tts.tv_nsec = rem;",
            "\t} else if (nsec < 0) {",
            "\t\t/*",
            "\t\t * With negative times, tv_sec points to the earlier",
            "\t\t * second, and tv_nsec counts the nanoseconds since",
            "\t\t * then, so tv_nsec is always a positive number.",
            "\t\t */",
            "\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;",
            "\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;",
            "\t}",
            "",
            "\treturn ts;",
            "}",
            "unsigned long __msecs_to_jiffies(const unsigned int m)",
            "{",
            "\t/*",
            "\t * Negative value, means infinite timeout:",
            "\t */",
            "\tif ((int)m < 0)",
            "\t\treturn MAX_JIFFY_OFFSET;",
            "\treturn _msecs_to_jiffies(m);",
            "}",
            "unsigned long __usecs_to_jiffies(const unsigned int u)",
            "{",
            "\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))",
            "\t\treturn MAX_JIFFY_OFFSET;",
            "\treturn _usecs_to_jiffies(u);",
            "}"
          ],
          "function_name": "jiffies_to_usecs, mktime64, ns_to_kernel_old_timeval, set_normalized_timespec64, ns_to_timespec64, __msecs_to_jiffies, __usecs_to_jiffies",
          "description": "包含时间单位转换函数jiffies_to_usecs/msecs_to_jiffies等，实现mktime64日期转时间戳，ns_to_*系列纳秒到时间结构体转换，以及set_normalized_timespec64时间归一化处理。",
          "similarity": 0.5336017608642578
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/time/time.c",
          "start_line": 796,
          "end_line": 899,
          "content": [
            "u64 nsecs_to_jiffies64(u64 n)",
            "{",
            "#if (NSEC_PER_SEC % HZ) == 0",
            "\t/* Common case, HZ = 100, 128, 200, 250, 256, 500, 512, 1000 etc. */",
            "\treturn div_u64(n, NSEC_PER_SEC / HZ);",
            "#elif (HZ % 512) == 0",
            "\t/* overflow after 292 years if HZ = 1024 */",
            "\treturn div_u64(n * HZ / 512, NSEC_PER_SEC / 512);",
            "#else",
            "\t/*",
            "\t * Generic case - optimized for cases where HZ is a multiple of 3.",
            "\t * overflow after 64.99 years, exact for HZ = 60, 72, 90, 120 etc.",
            "\t */",
            "\treturn div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);",
            "#endif",
            "}",
            "unsigned long nsecs_to_jiffies(u64 n)",
            "{",
            "\treturn (unsigned long)nsecs_to_jiffies64(n);",
            "}",
            "struct timespec64 timespec64_add_safe(const struct timespec64 lhs,",
            "\t\t\t\tconst struct timespec64 rhs)",
            "{",
            "\tstruct timespec64 res;",
            "",
            "\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,",
            "\t\t\tlhs.tv_nsec + rhs.tv_nsec);",
            "",
            "\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {",
            "\t\tres.tv_sec = TIME64_MAX;",
            "\t\tres.tv_nsec = 0;",
            "\t}",
            "",
            "\treturn res;",
            "}",
            "int get_timespec64(struct timespec64 *ts,",
            "\t\t   const struct __kernel_timespec __user *uts)",
            "{",
            "\tstruct __kernel_timespec kts;",
            "\tint ret;",
            "",
            "\tret = copy_from_user(&kts, uts, sizeof(kts));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tts->tv_sec = kts.tv_sec;",
            "",
            "\t/* Zero out the padding in compat mode */",
            "\tif (in_compat_syscall())",
            "\t\tkts.tv_nsec &= 0xFFFFFFFFUL;",
            "",
            "\t/* In 32-bit mode, this drops the padding */",
            "\tts->tv_nsec = kts.tv_nsec;",
            "",
            "\treturn 0;",
            "}",
            "int put_timespec64(const struct timespec64 *ts,",
            "\t\t   struct __kernel_timespec __user *uts)",
            "{",
            "\tstruct __kernel_timespec kts = {",
            "\t\t.tv_sec = ts->tv_sec,",
            "\t\t.tv_nsec = ts->tv_nsec",
            "\t};",
            "",
            "\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;",
            "}",
            "static int __get_old_timespec32(struct timespec64 *ts64,",
            "\t\t\t\t   const struct old_timespec32 __user *cts)",
            "{",
            "\tstruct old_timespec32 ts;",
            "\tint ret;",
            "",
            "\tret = copy_from_user(&ts, cts, sizeof(ts));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tts64->tv_sec = ts.tv_sec;",
            "\tts64->tv_nsec = ts.tv_nsec;",
            "",
            "\treturn 0;",
            "}",
            "static int __put_old_timespec32(const struct timespec64 *ts64,",
            "\t\t\t\t   struct old_timespec32 __user *cts)",
            "{",
            "\tstruct old_timespec32 ts = {",
            "\t\t.tv_sec = ts64->tv_sec,",
            "\t\t.tv_nsec = ts64->tv_nsec",
            "\t};",
            "\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;",
            "}",
            "int get_old_timespec32(struct timespec64 *ts, const void __user *uts)",
            "{",
            "\tif (COMPAT_USE_64BIT_TIME)",
            "\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;",
            "\telse",
            "\t\treturn __get_old_timespec32(ts, uts);",
            "}",
            "int put_old_timespec32(const struct timespec64 *ts, void __user *uts)",
            "{",
            "\tif (COMPAT_USE_64BIT_TIME)",
            "\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;",
            "\telse",
            "\t\treturn __put_old_timespec32(ts, uts);",
            "}"
          ],
          "function_name": "nsecs_to_jiffies64, nsecs_to_jiffies, timespec64_add_safe, get_timespec64, put_timespec64, __get_old_timespec32, __put_old_timespec32, get_old_timespec32, put_old_timespec32",
          "description": "实现纳秒到jiffies转换nsecs_to_jiffies64，时间相加函数timespec64_add_safe，以及timespec64与用户态old_timespec32结构体的数据复制函数get/put_old_timespec32。",
          "similarity": 0.490647554397583
        }
      ]
    }
  ]
}