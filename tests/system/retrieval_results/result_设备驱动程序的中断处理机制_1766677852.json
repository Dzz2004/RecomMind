{
  "query": "设备驱动程序的中断处理机制",
  "timestamp": "2025-12-25 23:50:52",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/autoprobe.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:47:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\autoprobe.c`\n\n---\n\n# `irq/autoprobe.c` 技术文档\n\n## 1. 文件概述\n\n`irq/autoprobe.c` 实现了 Linux 内核中的中断自动探测（IRQ autodetection）机制。该机制用于在设备驱动程序无法预先知道其所使用的中断号时，动态探测硬件实际触发的中断线。文件提供了一组 API，允许驱动程序在安全、受控的环境下扫描并识别有效的中断请求（IRQ）线路。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`probe_irq_on(void)`**  \n  启动中断自动探测过程。激活所有可探测的未分配中断线，等待潜在中断触发，并返回一个位掩码，表示可能有效的低编号（<32）中断线。\n\n- **`probe_irq_mask(unsigned long val)`**  \n  扫描所有中断线，返回在指定掩码 `val` 范围内被触发的有效中断位图，并清理探测状态。\n\n- **`probe_irq_off(unsigned long val)`**  \n  结束中断探测，检查哪些中断线在探测期间被触发。若唯一中断被触发，返回其中断号；若多个中断被触发，返回负值表示冲突；若无中断触发，返回 0。\n\n### 关键数据结构与状态标志\n\n- **`IRQS_AUTODETECT`**：标记该中断正处于自动探测状态。\n- **`IRQS_WAITING`**：表示该中断尚未被触发；若在探测期间被触发，此标志会被清除。\n- **`probing_active`**：全局互斥锁（`mutex`），确保同一时间只有一个探测过程在进行。\n\n## 3. 关键实现\n\n### 探测流程\n\n1. **准备阶段（`probe_irq_on`）**：\n   - 调用 `async_synchronize_full()` 确保异步任务完成，避免干扰。\n   - 获取 `probing_active` 互斥锁，防止并发探测。\n   - 遍历所有中断描述符（`irq_desc`），对未分配（`!desc->action`）且允许探测（`irq_settings_can_probe`）的中断：\n     - 若芯片支持，调用 `irq_set_type(..., IRQ_TYPE_PROBE)` 通知硬件进入探测模式。\n     - 调用 `irq_activate_and_startup()` 激活并启用中断（不重发）。\n   - 等待 20ms，让“陈旧”中断（longstanding irq）有机会触发并自屏蔽。\n\n2. **正式探测阶段**：\n   - 再次遍历中断描述符，为可探测中断设置 `IRQS_AUTODETECT | IRQS_WAITING`。\n   - 重新激活中断（处理可能因陈旧中断而被屏蔽的情况）。\n   - 等待 100ms，让真实硬件中断触发。\n\n3. **结果收集与清理**：\n   - 在 `probe_irq_off` 或 `probe_irq_mask` 中：\n     - 检查哪些中断仍带有 `IRQS_AUTODETECT` 且 **未** 设置 `IRQS_WAITING`（即已被触发）。\n     - 清除 `IRQS_AUTODETECT` 标志，并调用 `irq_shutdown_and_deactivate()` 关闭中断。\n     - 根据触发中断的数量返回结果：唯一中断返回正号，多个返回负号，无触发返回 0。\n\n### 并发控制\n\n- 使用 `probing_active` 互斥锁保证探测过程的原子性。\n- 所有对 `irq_desc` 的访问均在 `raw_spin_lock_irq()` 保护下进行，确保中断上下文安全。\n\n### 硬件交互\n\n- 支持通过 `irq_chip->irq_set_type()` 向中断控制器发送 `IRQ_TYPE_PROBE` 类型，使某些硬件（如 ISA 控制器）进入探测兼容模式。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`：IRQ 核心定义。\n  - `<linux/interrupt.h>`：中断处理相关 API。\n  - `<linux/delay.h>`：提供 `msleep()`。\n  - `<linux/async.h>`：用于同步异步任务。\n  - `\"internals.h\"`：包含 IRQ 子系统内部函数（如 `irq_activate_and_startup`、`irq_shutdown_and_deactivate`）。\n\n- **内核子系统依赖**：\n  - **IRQ 子系统核心**：依赖 `irq_desc` 管理、中断激活/关闭逻辑。\n  - **中断控制器驱动**：依赖 `irq_chip` 回调（特别是 `irq_set_type`）。\n\n## 5. 使用场景\n\n- **传统 ISA/PnP 设备驱动**：在即插即用（PnP）或资源未知的旧硬件驱动中，用于动态确定设备使用的 IRQ 号。\n- **调试与诊断工具**：内核调试时用于验证硬件中断线路是否正常工作。\n- **模块化驱动初始化**：在 `module_init` 阶段，当设备资源未通过 ACPI/FDT 等机制明确指定时，作为后备探测手段。\n\n> **注意**：现代设备通常通过设备树（Device Tree）、ACPI 或 PCI 配置空间明确指定中断号，因此该机制主要用于遗留硬件支持。文档中也指出，在模块中使用时存在并发风险，应避免重叠调用。",
      "similarity": 0.6893124580383301,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/autoprobe.c",
          "start_line": 30,
          "end_line": 149,
          "content": [
            "unsigned long probe_irq_on(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tunsigned long mask = 0;",
            "\tint i;",
            "",
            "\t/*",
            "\t * quiesce the kernel, or at least the asynchronous portion",
            "\t */",
            "\tasync_synchronize_full();",
            "\tmutex_lock(&probing_active);",
            "\t/*",
            "\t * something may have generated an irq long ago and we want to",
            "\t * flush such a longstanding irq before considering it as spurious.",
            "\t */",
            "\tfor_each_irq_desc_reverse(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "\t\tif (!desc->action && irq_settings_can_probe(desc)) {",
            "\t\t\t/*",
            "\t\t\t * Some chips need to know about probing in",
            "\t\t\t * progress:",
            "\t\t\t */",
            "\t\t\tif (desc->irq_data.chip->irq_set_type)",
            "\t\t\t\tdesc->irq_data.chip->irq_set_type(&desc->irq_data,",
            "\t\t\t\t\t\t\t IRQ_TYPE_PROBE);",
            "\t\t\tirq_activate_and_startup(desc, IRQ_NORESEND);",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "",
            "\t/* Wait for longstanding interrupts to trigger. */",
            "\tmsleep(20);",
            "",
            "\t/*",
            "\t * enable any unassigned irqs",
            "\t * (we must startup again here because if a longstanding irq",
            "\t * happened in the previous stage, it may have masked itself)",
            "\t */",
            "\tfor_each_irq_desc_reverse(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "\t\tif (!desc->action && irq_settings_can_probe(desc)) {",
            "\t\t\tdesc->istate |= IRQS_AUTODETECT | IRQS_WAITING;",
            "\t\t\tif (irq_activate_and_startup(desc, IRQ_NORESEND))",
            "\t\t\t\tdesc->istate |= IRQS_PENDING;",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "",
            "\t/*",
            "\t * Wait for spurious interrupts to trigger",
            "\t */",
            "\tmsleep(100);",
            "",
            "\t/*",
            "\t * Now filter out any obviously spurious interrupts",
            "\t */",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "",
            "\t\tif (desc->istate & IRQS_AUTODETECT) {",
            "\t\t\t/* It triggered already - consider it spurious. */",
            "\t\t\tif (!(desc->istate & IRQS_WAITING)) {",
            "\t\t\t\tdesc->istate &= ~IRQS_AUTODETECT;",
            "\t\t\t\tirq_shutdown_and_deactivate(desc);",
            "\t\t\t} else",
            "\t\t\t\tif (i < 32)",
            "\t\t\t\t\tmask |= 1 << i;",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "",
            "\treturn mask;",
            "}",
            "unsigned int probe_irq_mask(unsigned long val)",
            "{",
            "\tunsigned int mask = 0;",
            "\tstruct irq_desc *desc;",
            "\tint i;",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "\t\tif (desc->istate & IRQS_AUTODETECT) {",
            "\t\t\tif (i < 16 && !(desc->istate & IRQS_WAITING))",
            "\t\t\t\tmask |= 1 << i;",
            "",
            "\t\t\tdesc->istate &= ~IRQS_AUTODETECT;",
            "\t\t\tirq_shutdown_and_deactivate(desc);",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "\tmutex_unlock(&probing_active);",
            "",
            "\treturn mask & val;",
            "}",
            "int probe_irq_off(unsigned long val)",
            "{",
            "\tint i, irq_found = 0, nr_of_irqs = 0;",
            "\tstruct irq_desc *desc;",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "",
            "\t\tif (desc->istate & IRQS_AUTODETECT) {",
            "\t\t\tif (!(desc->istate & IRQS_WAITING)) {",
            "\t\t\t\tif (!nr_of_irqs)",
            "\t\t\t\t\tirq_found = i;",
            "\t\t\t\tnr_of_irqs++;",
            "\t\t\t}",
            "\t\t\tdesc->istate &= ~IRQS_AUTODETECT;",
            "\t\t\tirq_shutdown_and_deactivate(desc);",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "\tmutex_unlock(&probing_active);",
            "",
            "\tif (nr_of_irqs > 1)",
            "\t\tirq_found = -irq_found;",
            "",
            "\treturn irq_found;",
            "}"
          ],
          "function_name": "probe_irq_on, probe_irq_mask, probe_irq_off",
          "description": "实现中断自动检测三阶段流程，probe_irq_on启用未分配中断并收集触发掩码，probe_irq_mask筛选有效中断位，probe_irq_off解析最终中断号，通过遍历中断描述符完成状态修改与激活控制。",
          "similarity": 0.6297205090522766
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/autoprobe.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2004 Linus Torvalds, Ingo Molnar",
            " *",
            " * This file contains the interrupt probing code and driver APIs.",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "",
            "#include \"internals.h\"",
            "",
            "/*",
            " * Autodetection depends on the fact that any interrupt that",
            " * comes in on to an unassigned handler will get stuck with",
            " * \"IRQS_WAITING\" cleared and the interrupt disabled.",
            " */",
            "static DEFINE_MUTEX(probing_active);",
            "",
            "/**",
            " *\tprobe_irq_on\t- begin an interrupt autodetect",
            " *",
            " *\tCommence probing for an interrupt. The interrupts are scanned",
            " *\tand a mask of potential interrupt lines is returned.",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "定义用于中断自动检测的互斥锁probing_active，并声明probe_irq_on、probe_irq_mask和probe_irq_off函数，为后续中断探针流程提供基础框架。",
          "similarity": 0.5262863039970398
        }
      ]
    },
    {
      "source_file": "kernel/irq/spurious.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:09:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\spurious.c`\n\n---\n\n# `irq/spurious.c` 技术文档\n\n## 1. 文件概述\n\n`irq/spurious.c` 是 Linux 内核中断子系统中的一个关键组件，负责处理**伪中断**（spurious interrupts）和**错误路由中断**（misrouted interrupts）。当硬件中断未被任何中断处理程序正确处理（返回 `IRQ_NONE`）时，内核会怀疑该中断是伪中断或被错误路由到当前 IRQ 线。该文件实现了检测、诊断和恢复机制，包括：\n\n- 统计未处理中断次数并判断是否为“卡住”的 IRQ\n- 在启用 `irqfixup` 选项时尝试在其他 IRQ 线上查找真正的中断源（中断错位恢复）\n- 定期轮询被禁用的伪中断线以尝试恢复共享中断设备\n- 提供诊断信息（如调用栈和注册的处理函数列表）\n\n该机制对于提高系统在硬件或固件存在缺陷时的鲁棒性至关重要。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `irqfixup`：模块参数，控制伪中断修复行为（0=禁用，1=仅对未处理中断尝试修复，2=对标记为 `IRQF_IRQPOLL` 的中断也尝试修复）\n- `poll_spurious_irq_timer`：定时器，用于定期轮询被标记为 `IRQS_SPURIOUS_DISABLED` 的中断线\n- `irq_poll_cpu`：记录当前正在执行轮询任务的 CPU ID\n- `irq_poll_active`：原子变量，防止多个 CPU 同时执行轮询\n\n### 主要函数\n- `irq_wait_for_poll(struct irq_desc *desc)`  \n  等待轮询操作完成，避免与轮询线程竞争。在 SMP 系统中自旋等待 `IRQS_POLL_INPROGRESS` 标志清除。\n  \n- `try_one_irq(struct irq_desc *desc, bool force)`  \n  尝试在指定中断描述符上执行中断处理。跳过 PER_CPU、嵌套线程和显式标记为轮询的中断。若中断被禁用，则仅在 `force=true` 时处理。支持共享中断的 `IRQS_PENDING` 重试机制。\n\n- `misrouted_irq(int irq)`  \n  遍历所有 IRQ（除 0 和当前 IRQ），调用 `try_one_irq()` 尝试在其他线上找到真正的中断源。用于中断错位恢复。\n\n- `poll_spurious_irqs(struct timer_list *unused)`  \n  定时器回调函数，轮询所有被标记为 `IRQS_SPURIOUS_DISABLED` 的中断线，强制尝试处理（`force=true`）。\n\n- `__report_bad_irq()` / `report_bad_irq()`  \n  打印伪中断诊断信息，包括中断号、错误返回值、调用栈及所有注册的处理函数。\n\n- `try_misrouted_irq()`  \n  根据 `irqfixup` 级别判断是否应尝试中断错位恢复。\n\n- `note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)`  \n  中断处理结果分析入口。统计未处理中断，触发伪中断检测、诊断和恢复逻辑。\n\n## 3. 关键实现\n\n### 伪中断检测机制\n- 当 `note_interrupt()` 收到 `IRQ_NONE` 时，会递增中断描述符的未处理计数。\n- 若在 100,000 次中断中有 99,900 次未处理，则判定该 IRQ “卡住”，打印诊断信息并建议使用 `irqpoll` 启动参数。\n- 诊断信息包含所有注册的处理函数地址及符号名，便于调试。\n\n### 中断错位恢复（Misrouted IRQ Recovery）\n- 通过 `irqfixup` 内核参数启用（启动时传入 `irqfixup=1` 或 `2`）。\n- 当当前 IRQ 未被处理时，遍历其他所有 IRQ 线，尝试调用其处理函数（`try_one_irq()`）。\n- 仅适用于共享中断（`IRQF_SHARED`）且非 PER_CPU/嵌套线程类型。\n- 使用 `IRQS_POLL_INPROGRESS` 标志防止与正常中断处理冲突。\n\n### 轮询恢复机制\n- 被判定为伪中断的 IRQ 会被标记 `IRQS_SPURIOUS_DISABLED` 并禁用。\n- 启用 `irqfixup` 时，启动定时器 `poll_spurious_irq_timer`（间隔 100ms）。\n- 定时器回调 `poll_spurious_irqs()` 遍历所有 `IRQS_SPURIOUS_DISABLED` 的 IRQ，强制尝试处理（即使已禁用）。\n- 通过 `local_irq_disable/enable()` 保证轮询期间本地中断关闭，避免嵌套。\n\n### SMP 安全性\n- 使用 `irq_poll_active` 原子变量确保同一时间仅一个 CPU 执行轮询。\n- `irq_wait_for_poll()` 在 SMP 下自旋等待轮询完成，防止死锁。\n- 所有关键操作均在 `desc->lock` 保护下进行。\n\n### 线程化中断处理支持\n- 若主处理函数返回 `IRQ_WAKE_THREAD`，则延迟伪中断判断至下一次硬件中断，以等待线程处理结果。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：中断核心数据结构和 API\n  - `<linux/timer.h>`：定时器支持（用于轮询）\n  - `\"internals.h\"`：中断子系统内部接口\n\n- **内核配置依赖**：\n  - `CONFIG_SMP`：影响 `irq_wait_for_poll()` 的实现\n  - `irqfixup` 模块参数：控制恢复行为\n\n- **与其他模块交互**：\n  - 被通用中断处理流程（如 `handle_irq_event()`）调用\n  - 与中断描述符管理（`irq_desc`）紧密集成\n  - 依赖内核打印和栈回溯机制（`dump_stack()`）\n\n## 5. 使用场景\n\n1. **硬件/固件缺陷处理**：  \n   当 BIOS 或硬件错误地将设备中断路由到错误的 IRQ 线时，通过 `irqfixup` 机制尝试在其他线上找到真正的处理函数。\n\n2. **共享中断线故障恢复**：  \n   在多个设备共享同一 IRQ 线时，若其中一个设备故障产生持续中断但无处理函数响应，内核可禁用该线并定期轮询，避免系统被中断风暴拖垮。\n\n3. **系统调试与诊断**：  \n   当出现“nobody cared”中断错误时，自动打印详细的处理函数列表和调用栈，帮助开发者定位问题设备或驱动。\n\n4. **高可用性系统**：  \n   在无法立即修复硬件问题的生产环境中，通过 `irqpoll` 启动参数启用轮询机制，维持系统基本运行。\n\n5. **传统 PC 兼容性**：  \n   特别处理 IRQ 0（系统定时器），因其在传统 PC 架构中的特殊地位，即使在 `irqfixup=2` 模式下也始终尝试恢复。",
      "similarity": 0.688555121421814,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 272,
          "end_line": 432,
          "content": [
            "void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)",
            "{",
            "\tunsigned int irq;",
            "",
            "\tif (desc->istate & IRQS_POLL_INPROGRESS ||",
            "\t    irq_settings_is_polled(desc))",
            "\t\treturn;",
            "",
            "\tif (bad_action_ret(action_ret)) {",
            "\t\treport_bad_irq(desc, action_ret);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * We cannot call note_interrupt from the threaded handler",
            "\t * because we need to look at the compound of all handlers",
            "\t * (primary and threaded). Aside of that in the threaded",
            "\t * shared case we have no serialization against an incoming",
            "\t * hardware interrupt while we are dealing with a threaded",
            "\t * result.",
            "\t *",
            "\t * So in case a thread is woken, we just note the fact and",
            "\t * defer the analysis to the next hardware interrupt.",
            "\t *",
            "\t * The threaded handlers store whether they successfully",
            "\t * handled an interrupt and we check whether that number",
            "\t * changed versus the last invocation.",
            "\t *",
            "\t * We could handle all interrupts with the delayed by one",
            "\t * mechanism, but for the non forced threaded case we'd just",
            "\t * add pointless overhead to the straight hardirq interrupts",
            "\t * for the sake of a few lines less code.",
            "\t */",
            "\tif (action_ret & IRQ_WAKE_THREAD) {",
            "\t\t/*",
            "\t\t * There is a thread woken. Check whether one of the",
            "\t\t * shared primary handlers returned IRQ_HANDLED. If",
            "\t\t * not we defer the spurious detection to the next",
            "\t\t * interrupt.",
            "\t\t */",
            "\t\tif (action_ret == IRQ_WAKE_THREAD) {",
            "\t\t\tint handled;",
            "\t\t\t/*",
            "\t\t\t * We use bit 31 of thread_handled_last to",
            "\t\t\t * denote the deferred spurious detection",
            "\t\t\t * active. No locking necessary as",
            "\t\t\t * thread_handled_last is only accessed here",
            "\t\t\t * and we have the guarantee that hard",
            "\t\t\t * interrupts are not reentrant.",
            "\t\t\t */",
            "\t\t\tif (!(desc->threads_handled_last & SPURIOUS_DEFERRED)) {",
            "\t\t\t\tdesc->threads_handled_last |= SPURIOUS_DEFERRED;",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\t/*",
            "\t\t\t * Check whether one of the threaded handlers",
            "\t\t\t * returned IRQ_HANDLED since the last",
            "\t\t\t * interrupt happened.",
            "\t\t\t *",
            "\t\t\t * For simplicity we just set bit 31, as it is",
            "\t\t\t * set in threads_handled_last as well. So we",
            "\t\t\t * avoid extra masking. And we really do not",
            "\t\t\t * care about the high bits of the handled",
            "\t\t\t * count. We just care about the count being",
            "\t\t\t * different than the one we saw before.",
            "\t\t\t */",
            "\t\t\thandled = atomic_read(&desc->threads_handled);",
            "\t\t\thandled |= SPURIOUS_DEFERRED;",
            "\t\t\tif (handled != desc->threads_handled_last) {",
            "\t\t\t\taction_ret = IRQ_HANDLED;",
            "\t\t\t\t/*",
            "\t\t\t\t * Note: We keep the SPURIOUS_DEFERRED",
            "\t\t\t\t * bit set. We are handling the",
            "\t\t\t\t * previous invocation right now.",
            "\t\t\t\t * Keep it for the current one, so the",
            "\t\t\t\t * next hardware interrupt will",
            "\t\t\t\t * account for it.",
            "\t\t\t\t */",
            "\t\t\t\tdesc->threads_handled_last = handled;",
            "\t\t\t} else {",
            "\t\t\t\t/*",
            "\t\t\t\t * None of the threaded handlers felt",
            "\t\t\t\t * responsible for the last interrupt",
            "\t\t\t\t *",
            "\t\t\t\t * We keep the SPURIOUS_DEFERRED bit",
            "\t\t\t\t * set in threads_handled_last as we",
            "\t\t\t\t * need to account for the current",
            "\t\t\t\t * interrupt as well.",
            "\t\t\t\t */",
            "\t\t\t\taction_ret = IRQ_NONE;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * One of the primary handlers returned",
            "\t\t\t * IRQ_HANDLED. So we don't care about the",
            "\t\t\t * threaded handlers on the same line. Clear",
            "\t\t\t * the deferred detection bit.",
            "\t\t\t *",
            "\t\t\t * In theory we could/should check whether the",
            "\t\t\t * deferred bit is set and take the result of",
            "\t\t\t * the previous run into account here as",
            "\t\t\t * well. But it's really not worth the",
            "\t\t\t * trouble. If every other interrupt is",
            "\t\t\t * handled we never trigger the spurious",
            "\t\t\t * detector. And if this is just the one out",
            "\t\t\t * of 100k unhandled ones which is handled",
            "\t\t\t * then we merily delay the spurious detection",
            "\t\t\t * by one hard interrupt. Not a real problem.",
            "\t\t\t */",
            "\t\t\tdesc->threads_handled_last &= ~SPURIOUS_DEFERRED;",
            "\t\t}",
            "\t}",
            "",
            "\tif (unlikely(action_ret == IRQ_NONE)) {",
            "\t\t/*",
            "\t\t * If we are seeing only the odd spurious IRQ caused by",
            "\t\t * bus asynchronicity then don't eventually trigger an error,",
            "\t\t * otherwise the counter becomes a doomsday timer for otherwise",
            "\t\t * working systems",
            "\t\t */",
            "\t\tif (time_after(jiffies, desc->last_unhandled + HZ/10))",
            "\t\t\tdesc->irqs_unhandled = 1;",
            "\t\telse",
            "\t\t\tdesc->irqs_unhandled++;",
            "\t\tdesc->last_unhandled = jiffies;",
            "\t}",
            "",
            "\tirq = irq_desc_get_irq(desc);",
            "\tif (unlikely(try_misrouted_irq(irq, desc, action_ret))) {",
            "\t\tint ok = misrouted_irq(irq);",
            "\t\tif (action_ret == IRQ_NONE)",
            "\t\t\tdesc->irqs_unhandled -= ok;",
            "\t}",
            "",
            "\tif (likely(!desc->irqs_unhandled))",
            "\t\treturn;",
            "",
            "\t/* Now getting into unhandled irq detection */",
            "\tdesc->irq_count++;",
            "\tif (likely(desc->irq_count < 100000))",
            "\t\treturn;",
            "",
            "\tdesc->irq_count = 0;",
            "\tif (unlikely(desc->irqs_unhandled > 99900)) {",
            "\t\t/*",
            "\t\t * The interrupt is stuck",
            "\t\t */",
            "\t\t__report_bad_irq(desc, action_ret);",
            "\t\t/*",
            "\t\t * Now kill the IRQ",
            "\t\t */",
            "\t\tprintk(KERN_EMERG \"Disabling IRQ #%d\\n\", irq);",
            "\t\tdesc->istate |= IRQS_SPURIOUS_DISABLED;",
            "\t\tdesc->depth++;",
            "\t\tirq_disable(desc);",
            "",
            "\t\tmod_timer(&poll_spurious_irq_timer,",
            "\t\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);",
            "\t}",
            "\tdesc->irqs_unhandled = 0;",
            "}"
          ],
          "function_name": "note_interrupt",
          "description": "note_interrupt记录中断事件，检测未处理中断并触发报告，处理线程唤醒场景下的特殊逻辑。",
          "similarity": 0.6267300844192505
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 1,
          "end_line": 35,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2004 Linus Torvalds, Ingo Molnar",
            " *",
            " * This file contains spurious interrupt handling.",
            " */",
            "",
            "#include <linux/jiffies.h>",
            "#include <linux/irq.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/timer.h>",
            "",
            "#include \"internals.h\"",
            "",
            "static int irqfixup __read_mostly;",
            "",
            "#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)",
            "static void poll_spurious_irqs(struct timer_list *unused);",
            "static DEFINE_TIMER(poll_spurious_irq_timer, poll_spurious_irqs);",
            "static int irq_poll_cpu;",
            "static atomic_t irq_poll_active;",
            "",
            "/*",
            " * We wait here for a poller to finish.",
            " *",
            " * If the poll runs on this CPU, then we yell loudly and return",
            " * false. That will leave the interrupt line disabled in the worst",
            " * case, but it should never happen.",
            " *",
            " * We wait until the poller is done and then recheck disabled and",
            " * action (about to be disabled). Only if it's still active, we return",
            " * true and let the handler run.",
            " */"
          ],
          "function_name": null,
          "description": "定义了处理虚假中断的相关变量和定时器，用于周期性地扫描和处理可能存在的虚假中断。",
          "similarity": 0.5959514379501343
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 144,
          "end_line": 256,
          "content": [
            "static void poll_spurious_irqs(struct timer_list *unused)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint i;",
            "",
            "\tif (atomic_inc_return(&irq_poll_active) != 1)",
            "\t\tgoto out;",
            "\tirq_poll_cpu = smp_processor_id();",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\tunsigned int state;",
            "",
            "\t\tif (!i)",
            "\t\t\t continue;",
            "",
            "\t\t/* Racy but it doesn't matter */",
            "\t\tstate = desc->istate;",
            "\t\tbarrier();",
            "\t\tif (!(state & IRQS_SPURIOUS_DISABLED))",
            "\t\t\tcontinue;",
            "",
            "\t\tlocal_irq_disable();",
            "\t\ttry_one_irq(desc, true);",
            "\t\tlocal_irq_enable();",
            "\t}",
            "out:",
            "\tatomic_dec(&irq_poll_active);",
            "\tmod_timer(&poll_spurious_irq_timer,",
            "\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);",
            "}",
            "static inline int bad_action_ret(irqreturn_t action_ret)",
            "{",
            "\tunsigned int r = action_ret;",
            "",
            "\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))",
            "\t\treturn 0;",
            "\treturn 1;",
            "}",
            "static void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)",
            "{",
            "\tunsigned int irq = irq_desc_get_irq(desc);",
            "\tstruct irqaction *action;",
            "\tunsigned long flags;",
            "",
            "\tif (bad_action_ret(action_ret)) {",
            "\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",",
            "\t\t\t\tirq, action_ret);",
            "\t} else {",
            "\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"",
            "\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);",
            "\t}",
            "\tdump_stack();",
            "\tprintk(KERN_ERR \"handlers:\\n\");",
            "",
            "\t/*",
            "\t * We need to take desc->lock here. note_interrupt() is called",
            "\t * w/o desc->lock held, but IRQ_PROGRESS set. We might race",
            "\t * with something else removing an action. It's ok to take",
            "\t * desc->lock here. See synchronize_irq().",
            "\t */",
            "\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\tfor_each_action_of_desc(desc, action) {",
            "\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);",
            "\t\tif (action->thread_fn)",
            "\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",",
            "\t\t\t\t\taction->thread_fn, action->thread_fn);",
            "\t\tprintk(KERN_CONT \"\\n\");",
            "\t}",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "}",
            "static void report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)",
            "{",
            "\tstatic int count = 100;",
            "",
            "\tif (count > 0) {",
            "\t\tcount--;",
            "\t\t__report_bad_irq(desc, action_ret);",
            "\t}",
            "}",
            "static inline int",
            "try_misrouted_irq(unsigned int irq, struct irq_desc *desc,",
            "\t\t  irqreturn_t action_ret)",
            "{",
            "\tstruct irqaction *action;",
            "",
            "\tif (!irqfixup)",
            "\t\treturn 0;",
            "",
            "\t/* We didn't actually handle the IRQ - see if it was misrouted? */",
            "\tif (action_ret == IRQ_NONE)",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * But for 'irqfixup == 2' we also do it for handled interrupts if",
            "\t * they are marked as IRQF_IRQPOLL (or for irq zero, which is the",
            "\t * traditional PC timer interrupt.. Legacy)",
            "\t */",
            "\tif (irqfixup < 2)",
            "\t\treturn 0;",
            "",
            "\tif (!irq)",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * Since we don't get the descriptor lock, \"action\" can",
            "\t * change under us.  We don't really care, but we don't",
            "\t * want to follow a NULL pointer. So tell the compiler to",
            "\t * just load it once by using a barrier.",
            "\t */",
            "\taction = desc->action;",
            "\tbarrier();",
            "\treturn action && (action->flags & IRQF_IRQPOLL);",
            "}"
          ],
          "function_name": "poll_spurious_irqs, bad_action_ret, __report_bad_irq, report_bad_irq, try_misrouted_irq",
          "description": "poll_spurious_irqs定时扫描中断描述符并处理疑似虚假中断，包含错误报告辅助函数和误路由检测逻辑。",
          "similarity": 0.5604449510574341
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 36,
          "end_line": 136,
          "content": [
            "bool irq_wait_for_poll(struct irq_desc *desc)",
            "\t__must_hold(&desc->lock)",
            "{",
            "\tif (WARN_ONCE(irq_poll_cpu == smp_processor_id(),",
            "\t\t      \"irq poll in progress on cpu %d for irq %d\\n\",",
            "\t\t      smp_processor_id(), desc->irq_data.irq))",
            "\t\treturn false;",
            "",
            "#ifdef CONFIG_SMP",
            "\tdo {",
            "\t\traw_spin_unlock(&desc->lock);",
            "\t\twhile (irqd_irq_inprogress(&desc->irq_data))",
            "\t\t\tcpu_relax();",
            "\t\traw_spin_lock(&desc->lock);",
            "\t} while (irqd_irq_inprogress(&desc->irq_data));",
            "\t/* Might have been disabled in meantime */",
            "\treturn !irqd_irq_disabled(&desc->irq_data) && desc->action;",
            "#else",
            "\treturn false;",
            "#endif",
            "}",
            "static int try_one_irq(struct irq_desc *desc, bool force)",
            "{",
            "\tirqreturn_t ret = IRQ_NONE;",
            "\tstruct irqaction *action;",
            "",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\t/*",
            "\t * PER_CPU, nested thread interrupts and interrupts explicitly",
            "\t * marked polled are excluded from polling.",
            "\t */",
            "\tif (irq_settings_is_per_cpu(desc) ||",
            "\t    irq_settings_is_nested_thread(desc) ||",
            "\t    irq_settings_is_polled(desc))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Do not poll disabled interrupts unless the spurious",
            "\t * disabled poller asks explicitly.",
            "\t */",
            "\tif (irqd_irq_disabled(&desc->irq_data) && !force)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * All handlers must agree on IRQF_SHARED, so we test just the",
            "\t * first.",
            "\t */",
            "\taction = desc->action;",
            "\tif (!action || !(action->flags & IRQF_SHARED) ||",
            "\t    (action->flags & __IRQF_TIMER))",
            "\t\tgoto out;",
            "",
            "\t/* Already running on another processor */",
            "\tif (irqd_irq_inprogress(&desc->irq_data)) {",
            "\t\t/*",
            "\t\t * Already running: If it is shared get the other",
            "\t\t * CPU to go looking for our mystery interrupt too",
            "\t\t */",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Mark it poll in progress */",
            "\tdesc->istate |= IRQS_POLL_INPROGRESS;",
            "\tdo {",
            "\t\tif (handle_irq_event(desc) == IRQ_HANDLED)",
            "\t\t\tret = IRQ_HANDLED;",
            "\t\t/* Make sure that there is still a valid action */",
            "\t\taction = desc->action;",
            "\t} while ((desc->istate & IRQS_PENDING) && action);",
            "\tdesc->istate &= ~IRQS_POLL_INPROGRESS;",
            "out:",
            "\traw_spin_unlock(&desc->lock);",
            "\treturn ret == IRQ_HANDLED;",
            "}",
            "static int misrouted_irq(int irq)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint i, ok = 0;",
            "",
            "\tif (atomic_inc_return(&irq_poll_active) != 1)",
            "\t\tgoto out;",
            "",
            "\tirq_poll_cpu = smp_processor_id();",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\tif (!i)",
            "\t\t\t continue;",
            "",
            "\t\tif (i == irq)\t/* Already tried */",
            "\t\t\tcontinue;",
            "",
            "\t\tif (try_one_irq(desc, false))",
            "\t\t\tok = 1;",
            "\t}",
            "out:",
            "\tatomic_dec(&irq_poll_active);",
            "\t/* So the caller can adjust the irq error counts */",
            "\treturn ok;",
            "}"
          ],
          "function_name": "irq_wait_for_poll, try_one_irq, misrouted_irq",
          "description": "实现了irq_wait_for_poll用于等待轮询完成，try_one_irq尝试处理单个中断，misrouted_irq尝试修复误路由中断。",
          "similarity": 0.5523670315742493
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 436,
          "end_line": 467,
          "content": [
            "int noirqdebug_setup(char *str)",
            "{",
            "\tnoirqdebug = 1;",
            "\tprintk(KERN_INFO \"IRQ lockup detection disabled\\n\");",
            "",
            "\treturn 1;",
            "}",
            "static int __init irqfixup_setup(char *str)",
            "{",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\tpr_warn(\"irqfixup boot option not supported with PREEMPT_RT\\n\");",
            "\t\treturn 1;",
            "\t}",
            "\tirqfixup = 1;",
            "\tprintk(KERN_WARNING \"Misrouted IRQ fixup support enabled.\\n\");",
            "\tprintk(KERN_WARNING \"This may impact system performance.\\n\");",
            "",
            "\treturn 1;",
            "}",
            "static int __init irqpoll_setup(char *str)",
            "{",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\tpr_warn(\"irqpoll boot option not supported with PREEMPT_RT\\n\");",
            "\t\treturn 1;",
            "\t}",
            "\tirqfixup = 2;",
            "\tprintk(KERN_WARNING \"Misrouted IRQ fixup and polling support \"",
            "\t\t\t\t\"enabled\\n\");",
            "\tprintk(KERN_WARNING \"This may significantly impact system \"",
            "\t\t\t\t\"performance\\n\");",
            "\treturn 1;",
            "}"
          ],
          "function_name": "noirqdebug_setup, irqfixup_setup, irqpoll_setup",
          "description": "提供启动参数配置接口，用于启用或禁用irqfixup和irqpoll功能，并输出相应警告信息。",
          "similarity": 0.5463958978652954
        }
      ]
    },
    {
      "source_file": "kernel/irq/irq_sim.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:58:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\irq_sim.c`\n\n---\n\n# `irq/irq_sim.c` 技术文档\n\n## 1. 文件概述\n\n`irq/irq_sim.c` 实现了一个**中断模拟器（IRQ Simulator）**，用于在 Linux 内核中创建虚拟的中断域（`irq_domain`），以模拟硬件中断行为。该模块主要用于**测试、调试和驱动开发**场景，允许开发者在没有真实硬件中断源的情况下触发和处理中断。它通过 `irq_work` 机制异步处理“模拟中断”，并提供标准的 `irq_chip` 接口，使上层驱动代码可以像使用真实中断一样使用这些虚拟中断。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct irq_sim_work_ctx`**  \n  中断模拟器的工作上下文，包含：\n  - `struct irq_work work`：用于异步处理待处理中断的 irq_work 实例\n  - `int irq_base`：保留字段（当前未使用）\n  - `unsigned int irq_count`：模拟中断的数量\n  - `unsigned long *pending`：位图，标记哪些中断处于 pending 状态\n  - `struct irq_domain *domain`：关联的中断域\n\n- **`struct irq_sim_irq_ctx`**  \n  每个虚拟中断的上下文，包含：\n  - `int irqnum`：保留字段（当前未使用）\n  - `bool enabled`：中断是否已启用（unmask）\n  - `struct irq_sim_work_ctx *work_ctx`：指向工作上下文的指针\n\n- **`struct irq_chip irq_sim_irqchip`**  \n  虚拟中断控制器的实现，提供标准的中断芯片操作接口。\n\n- **`struct irq_domain_ops irq_sim_domain_ops`**  \n  中断域映射操作集，用于虚拟中断号与硬件中断号的映射管理。\n\n### 主要函数\n\n- **`irq_domain_create_sim()`**  \n  创建一个新的中断模拟器域，分配指定数量的虚拟中断。\n\n- **`irq_domain_remove_sim()`**  \n  销毁中断模拟器域，释放相关资源。\n\n- **`devm_irq_domain_create_sim()`**  \n  基于设备资源管理（devres）的中断模拟器创建函数，自动在设备卸载时清理资源。\n\n- **`irq_sim_handle_irq()`**  \n  `irq_work` 的回调函数，遍历 pending 位图并触发对应的虚拟中断。\n\n- **`irq_sim_irqmask()` / `irq_sim_irqunmask()`**  \n  实现中断的屏蔽与解除屏蔽，仅设置 `enabled` 标志。\n\n- **`irq_sim_set_type()`**  \n  设置中断触发类型，仅支持 `IRQ_TYPE_EDGE_RISING` 和 `IRQ_TYPE_EDGE_FALLING`。\n\n- **`irq_sim_get_irqchip_state()` / `irq_sim_set_irqchip_state()`**  \n  查询和设置中断芯片状态（目前仅支持 `IRQCHIP_STATE_PENDING`）。\n\n## 3. 关键实现\n\n### 中断模拟机制\n- 使用 **位图（`pending`）** 记录哪些虚拟中断处于 pending 状态。\n- 当调用 `irq_sim_set_irqchip_state(..., IRQCHIP_STATE_PENDING, true)` 时：\n  - 若中断已启用（`enabled == true`），则在位图中标记对应位。\n  - 同时调用 `irq_work_queue()` 触发异步处理。\n- `irq_work` 回调 `irq_sim_handle_irq()` 遍历位图，对每个 pending 中断：\n  - 清除位图中的对应位。\n  - 通过 `irq_find_mapping()` 获取虚拟中断号。\n  - 调用 `handle_simple_irq()` 触发中断处理流程。\n\n### 中断域管理\n- 使用 **线性映射（`irq_domain_create_linear`）** 创建中断域。\n- 每个虚拟中断在 `map` 时分配独立的 `irq_sim_irq_ctx`，并绑定 `irq_sim_irqchip`。\n- 中断默认设置为 `IRQ_NOREQUEST | IRQ_NOAUTOEN`，防止自动使能和用户空间请求。\n\n### 资源管理\n- `devm_irq_domain_create_sim()` 利用内核的 **设备资源管理（devres）** 机制，在设备移除时自动调用 `irq_domain_remove_sim()`。\n- `irq_domain_remove_sim()` 会同步等待所有 pending 的 `irq_work` 完成（`irq_work_sync()`），确保安全释放内存。\n\n### 中断状态控制\n- 仅当中断处于 **enabled 状态** 时，才允许设置或查询 pending 状态。\n- 不支持电平触发中断，仅支持边沿触发（`IRQ_TYPE_EDGE_BOTH`）。\n\n## 4. 依赖关系\n\n- **`<linux/irq.h>`**：提供中断核心 API（如 `irq_set_chip`、`handle_simple_irq`）。\n- **`<linux/irq_sim.h>`**：定义中断模拟器的公共接口（如 `irq_domain_create_sim` 声明）。\n- **`<linux/irq_work.h>`**：提供 `irq_work` 机制，用于异步中断处理。\n- **`<linux/interrupt.h>`**：提供中断描述符和状态操作函数。\n- **`<linux/slab.h>`**：提供动态内存分配（`kmalloc`/`kzalloc`/`kfree`）。\n- **依赖 `GENERIC_IRQ_CHIP` 和 `IRQ_DOMAIN` 子系统**：作为中断子系统的扩展模块。\n\n## 5. 使用场景\n\n- **驱动开发与测试**：在无硬件环境下验证中断处理逻辑。\n- **虚拟化与仿真**：为虚拟设备提供中断模拟支持。\n- **内核子系统测试**：用于测试中断子系统、电源管理、实时性等模块。\n- **平台无关的中断逻辑验证**：避免依赖特定硬件平台进行中断行为测试。\n- **教学与调试**：帮助理解 Linux 中断处理机制的工作流程。",
      "similarity": 0.678887128829956,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/irq_sim.c",
          "start_line": 203,
          "end_line": 218,
          "content": [
            "void irq_domain_remove_sim(struct irq_domain *domain)",
            "{",
            "\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;",
            "",
            "\tirq_work_sync(&work_ctx->work);",
            "\tbitmap_free(work_ctx->pending);",
            "\tkfree(work_ctx);",
            "",
            "\tirq_domain_remove(domain);",
            "}",
            "static void devm_irq_domain_remove_sim(void *data)",
            "{",
            "\tstruct irq_domain *domain = data;",
            "",
            "\tirq_domain_remove_sim(domain);",
            "}"
          ],
          "function_name": "irq_domain_remove_sim, devm_irq_domain_remove_sim",
          "description": "提供中断域清理接口，同步工作队列确保Pending中断处理完成，释放位图内存并安全移除中断域，包含设备管理器版本的延迟卸载实现",
          "similarity": 0.7014422416687012
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/irq_sim.c",
          "start_line": 27,
          "end_line": 131,
          "content": [
            "static void irq_sim_irqmask(struct irq_data *data)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "",
            "\tirq_ctx->enabled = false;",
            "}",
            "static void irq_sim_irqunmask(struct irq_data *data)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "",
            "\tirq_ctx->enabled = true;",
            "}",
            "static int irq_sim_set_type(struct irq_data *data, unsigned int type)",
            "{",
            "\t/* We only support rising and falling edge trigger types. */",
            "\tif (type & ~IRQ_TYPE_EDGE_BOTH)",
            "\t\treturn -EINVAL;",
            "",
            "\tirqd_set_trigger_type(data, type);",
            "",
            "\treturn 0;",
            "}",
            "static int irq_sim_get_irqchip_state(struct irq_data *data,",
            "\t\t\t\t     enum irqchip_irq_state which, bool *state)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "\tirq_hw_number_t hwirq = irqd_to_hwirq(data);",
            "",
            "\tswitch (which) {",
            "\tcase IRQCHIP_STATE_PENDING:",
            "\t\tif (irq_ctx->enabled)",
            "\t\t\t*state = test_bit(hwirq, irq_ctx->work_ctx->pending);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int irq_sim_set_irqchip_state(struct irq_data *data,",
            "\t\t\t\t     enum irqchip_irq_state which, bool state)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "\tirq_hw_number_t hwirq = irqd_to_hwirq(data);",
            "",
            "\tswitch (which) {",
            "\tcase IRQCHIP_STATE_PENDING:",
            "\t\tif (irq_ctx->enabled) {",
            "\t\t\tassign_bit(hwirq, irq_ctx->work_ctx->pending, state);",
            "\t\t\tif (state)",
            "\t\t\t\tirq_work_queue(&irq_ctx->work_ctx->work);",
            "\t\t}",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void irq_sim_handle_irq(struct irq_work *work)",
            "{",
            "\tstruct irq_sim_work_ctx *work_ctx;",
            "\tunsigned int offset = 0;",
            "\tint irqnum;",
            "",
            "\twork_ctx = container_of(work, struct irq_sim_work_ctx, work);",
            "",
            "\twhile (!bitmap_empty(work_ctx->pending, work_ctx->irq_count)) {",
            "\t\toffset = find_next_bit(work_ctx->pending,",
            "\t\t\t\t       work_ctx->irq_count, offset);",
            "\t\tclear_bit(offset, work_ctx->pending);",
            "\t\tirqnum = irq_find_mapping(work_ctx->domain, offset);",
            "\t\thandle_simple_irq(irq_to_desc(irqnum));",
            "\t}",
            "}",
            "static int irq_sim_domain_map(struct irq_domain *domain,",
            "\t\t\t      unsigned int virq, irq_hw_number_t hw)",
            "{",
            "\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;",
            "\tstruct irq_sim_irq_ctx *irq_ctx;",
            "",
            "\tirq_ctx = kzalloc(sizeof(*irq_ctx), GFP_KERNEL);",
            "\tif (!irq_ctx)",
            "\t\treturn -ENOMEM;",
            "",
            "\tirq_set_chip(virq, &irq_sim_irqchip);",
            "\tirq_set_chip_data(virq, irq_ctx);",
            "\tirq_set_handler(virq, handle_simple_irq);",
            "\tirq_modify_status(virq, IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);",
            "\tirq_ctx->work_ctx = work_ctx;",
            "",
            "\treturn 0;",
            "}",
            "static void irq_sim_domain_unmap(struct irq_domain *domain, unsigned int virq)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx;",
            "\tstruct irq_data *irqd;",
            "",
            "\tirqd = irq_domain_get_irq_data(domain, virq);",
            "\tirq_ctx = irq_data_get_irq_chip_data(irqd);",
            "",
            "\tirq_set_handler(virq, NULL);",
            "\tirq_domain_reset_irq_data(irqd);",
            "\tkfree(irq_ctx);",
            "}"
          ],
          "function_name": "irq_sim_irqmask, irq_sim_irqunmask, irq_sim_set_type, irq_sim_get_irqchip_state, irq_sim_set_irqchip_state, irq_sim_handle_irq, irq_sim_domain_map, irq_sim_domain_unmap",
          "description": "实现模拟中断芯片的操作函数，包括中断使能/禁止控制、触发类型设置、芯片状态读取/修改、中断处理回调及中断域映射/解除映射逻辑，通过位图管理待处理中断并调度至简单中断处理流程",
          "similarity": 0.6664339303970337
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/irq_sim.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Copyright (C) 2017-2018 Bartosz Golaszewski <brgl@bgdev.pl>",
            " * Copyright (C) 2020 Bartosz Golaszewski <bgolaszewski@baylibre.com>",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/irq_sim.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "",
            "struct irq_sim_work_ctx {",
            "\tstruct irq_work\t\twork;",
            "\tint\t\t\tirq_base;",
            "\tunsigned int\t\tirq_count;",
            "\tunsigned long\t\t*pending;",
            "\tstruct irq_domain\t*domain;",
            "};",
            "",
            "struct irq_sim_irq_ctx {",
            "\tint\t\t\tirqnum;",
            "\tbool\t\t\tenabled;",
            "\tstruct irq_sim_work_ctx\t*work_ctx;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了irq_sim_work_ctx和irq_sim_irq_ctx结构体，前者用于维护中断工作队列上下文（含位图pending、中断域指针等），后者保存单个中断的配置信息（中断号、启用状态及工作上下文指针）",
          "similarity": 0.5677024126052856
        }
      ]
    }
  ]
}