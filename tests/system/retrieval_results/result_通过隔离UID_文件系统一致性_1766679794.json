{
  "query": "通过隔离UID 文件系统一致性",
  "timestamp": "2025-12-26 00:23:14",
  "retrieved_files": [
    {
      "source_file": "kernel/uid16.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:43:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `uid16.c`\n\n---\n\n# uid16.c 技术文档\n\n## 文件概述\n\n`uid16.c` 是 Linux 内核中用于提供 16 位用户 ID（UID）和组 ID（GID）系统调用兼容性的封装层。该文件实现了旧式 16 位 UID/GID 系统调用（如 `chown16`、`setuid16` 等）到现代 32 位 UID/GID 内核接口的桥接，确保运行在 32 位 UID/GID 架构上的旧应用程序仍能在支持高 UID（high UID）的现代内核上正常工作。文件注释中提到“希望五年后能移除这些接口”，表明其为临时兼容性方案。\n\n## 核心功能\n\n### 主要系统调用函数\n\n- **文件所有权变更类**：\n  - `chown16`：变更文件所有者和所属组（16 位接口）\n  - `lchown16`：变更符号链接指向文件的所有者和组（16 位接口）\n  - `fchown16`：通过文件描述符变更文件所有者和组（16 位接口）\n\n- **用户 ID 设置类**：\n  - `setuid16` / `seteuid16`（通过 `setreuid16` 实现）：设置真实/有效 UID\n  - `setreuid16`：同时设置真实 UID 和有效 UID\n  - `setresuid16`：设置真实、有效和保存的 UID\n  - `setfsuid16`：设置文件系统 UID\n\n- **组 ID 设置类**：\n  - `setgid16` / `setegid16`（通过 `setregid16` 实现）：设置真实/有效 GID\n  - `setregid16`：同时设置真实 GID 和有效 GID\n  - `setresgid16`：设置真实、有效和保存的 GID\n  - `setfsgid16`：设置文件系统 GID\n\n- **查询类**：\n  - `getuid16` / `geteuid16`：获取当前真实/有效 UID（16 位返回）\n  - `getgid16` / `getegid16`：获取当前真实/有效 GID（16 位返回）\n  - `getresuid16` / `getresgid16`：获取三类 UID/GID（真实、有效、保存）\n  - `getgroups16`：获取当前进程的附加组列表（16 位格式）\n  - `setgroups16`：设置当前进程的附加组列表（16 位输入）\n\n### 辅助函数\n\n- `groups16_to_user`：将内核 `group_info` 中的 GID 转换为 16 位格式并复制到用户空间\n- `groups16_from_user`：从用户空间读取 16 位 GID 列表并转换为内核 `kgid_t` 格式\n\n### 关键宏与类型\n\n- `old_uid_t` / `old_gid_t`：定义为 16 位整数类型（通常为 `__u16`）\n- `low2highuid` / `low2highgid`：将 16 位 UID/GID 扩展为 32 位内核表示\n- `high2lowuid` / `high2lowgid`：将 32 位内核 UID/GID 截断为 16 位返回用户空间\n- `from_kuid_munged` / `from_kgid_munged`：在用户命名空间上下文中将内核 UID/GID 转换为用户可见值，并处理无效 ID\n\n## 关键实现\n\n### UID/GID 转换机制\n\n- 所有 16 位系统调用首先使用 `low2highuid()` 或 `low2highgid()` 将传入的 16 位值转换为内核使用的 32 位 `kuid_t`/`kgid_t` 类型。\n- 查询类调用（如 `getuid16`）则通过 `from_kuid_munged()` 将内核 UID 映射到当前用户命名空间的用户可见值，再用 `high2lowuid()` 截断为 16 位返回。\n- `from_kuid_munged()` 在 UID 超出 16 位范围（>65535）时会返回 `(uid_t) -1`，确保旧程序不会收到无法处理的大值。\n\n### 用户命名空间支持\n\n- 所有转换均通过 `current_user_ns()` 获取当前进程的用户命名空间，确保在容器或用户命名空间隔离环境中正确映射 UID/GID。\n- 例如：`from_kuid_munged(cred->user_ns, cred->uid)` 将内核 UID 转换为该命名空间下的用户视角 UID。\n\n### 组列表处理\n\n- `getgroups16` 和 `setgroups16` 通过辅助函数 `groups16_to_user`/`groups16_from_user` 实现 16 位与内核 `kgid_t` 数组的双向转换。\n- `setgroups16` 在设置前调用 `groups_sort()` 对组列表排序，符合内核对 `group_info` 的要求。\n\n### 错误处理与边界检查\n\n- `setgroups16` 检查 `gidsetsize` 是否超过 `NGROUPS_MAX`，防止内存溢出。\n- `getgroups16` 在 `gidsetsize` 小于实际组数时返回 `-EINVAL`，符合 POSIX 语义。\n- 所有用户空间访问均通过 `put_user`/`get_user` 进行，失败时返回 `-EFAULT`。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/cred.h>`：访问 `struct cred` 和 `current_cred()`\n  - `<linux/highuid.h>`：提供 `low2highuid`/`high2lowuid` 等转换宏\n  - `<linux/uaccess.h>`：提供 `put_user`/`get_user` 用户空间访问接口\n  - `<linux/syscalls.h>`：使用 `SYSCALL_DEFINE` 宏定义系统调用\n  - `<linux/security.h>`：间接依赖安全模块钩子（如 `may_setgroups`）\n\n- **内核子系统依赖**：\n  - **用户命名空间**（`user_namespace`）：所有 UID/GID 转换基于当前命名空间\n  - **凭证管理**（`cred`）：读取/修改进程的 UID/GID 属性\n  - **组管理**（`group_info`）：处理附加组列表的分配、排序和设置\n  - **系统调用框架**：通过 `ksys_*` 和 `__sys_*` 内核内部接口复用主逻辑\n\n## 使用场景\n\n- **旧版二进制兼容**：运行在早期 Linux 发行版（仅支持 16 位 UID/GID）上的应用程序在现代内核上执行时，自动通过这些 16 位系统调用接口与内核交互。\n- **嵌入式或资源受限系统**：某些遗留嵌入式系统可能仍使用 16 位 UID/GID 接口以节省空间或保持 ABI 兼容。\n- **用户命名空间容器环境**：在容器中运行的旧程序可通过这些接口正确映射容器内 UID/GID 到宿主机内核表示。\n- **系统调用拦截与审计**：安全模块可通过这些封装层监控或控制对 UID/GID 的变更操作。\n\n> 注：随着 16 位 UID/GID 的淘汰，这些接口在现代系统中已极少使用，主要用于维持向后兼容性。",
      "similarity": 0.6137733459472656,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/uid16.c",
          "start_line": 1,
          "end_line": 113,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *\tWrapper functions for 16bit uid back compatibility. All nicely tied",
            " *\ttogether in the faint hope we can take the out in five years time.",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/notifier.h>",
            "#include <linux/reboot.h>",
            "#include <linux/prctl.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/highuid.h>",
            "#include <linux/security.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#include \"uid16.h\"",
            "",
            "SYSCALL_DEFINE3(chown16, const char __user *, filename, old_uid_t, user, old_gid_t, group)",
            "{",
            "\treturn ksys_chown(filename, low2highuid(user), low2highgid(group));",
            "}",
            "",
            "SYSCALL_DEFINE3(lchown16, const char __user *, filename, old_uid_t, user, old_gid_t, group)",
            "{",
            "\treturn ksys_lchown(filename, low2highuid(user), low2highgid(group));",
            "}",
            "",
            "SYSCALL_DEFINE3(fchown16, unsigned int, fd, old_uid_t, user, old_gid_t, group)",
            "{",
            "\treturn ksys_fchown(fd, low2highuid(user), low2highgid(group));",
            "}",
            "",
            "SYSCALL_DEFINE2(setregid16, old_gid_t, rgid, old_gid_t, egid)",
            "{",
            "\treturn __sys_setregid(low2highgid(rgid), low2highgid(egid));",
            "}",
            "",
            "SYSCALL_DEFINE1(setgid16, old_gid_t, gid)",
            "{",
            "\treturn __sys_setgid(low2highgid(gid));",
            "}",
            "",
            "SYSCALL_DEFINE2(setreuid16, old_uid_t, ruid, old_uid_t, euid)",
            "{",
            "\treturn __sys_setreuid(low2highuid(ruid), low2highuid(euid));",
            "}",
            "",
            "SYSCALL_DEFINE1(setuid16, old_uid_t, uid)",
            "{",
            "\treturn __sys_setuid(low2highuid(uid));",
            "}",
            "",
            "SYSCALL_DEFINE3(setresuid16, old_uid_t, ruid, old_uid_t, euid, old_uid_t, suid)",
            "{",
            "\treturn __sys_setresuid(low2highuid(ruid), low2highuid(euid),",
            "\t\t\t\t low2highuid(suid));",
            "}",
            "",
            "SYSCALL_DEFINE3(getresuid16, old_uid_t __user *, ruidp, old_uid_t __user *, euidp, old_uid_t __user *, suidp)",
            "{",
            "\tconst struct cred *cred = current_cred();",
            "\tint retval;",
            "\told_uid_t ruid, euid, suid;",
            "",
            "\truid = high2lowuid(from_kuid_munged(cred->user_ns, cred->uid));",
            "\teuid = high2lowuid(from_kuid_munged(cred->user_ns, cred->euid));",
            "\tsuid = high2lowuid(from_kuid_munged(cred->user_ns, cred->suid));",
            "",
            "\tif (!(retval   = put_user(ruid, ruidp)) &&",
            "\t    !(retval   = put_user(euid, euidp)))",
            "\t\tretval = put_user(suid, suidp);",
            "",
            "\treturn retval;",
            "}",
            "",
            "SYSCALL_DEFINE3(setresgid16, old_gid_t, rgid, old_gid_t, egid, old_gid_t, sgid)",
            "{",
            "\treturn __sys_setresgid(low2highgid(rgid), low2highgid(egid),",
            "\t\t\t\t low2highgid(sgid));",
            "}",
            "",
            "SYSCALL_DEFINE3(getresgid16, old_gid_t __user *, rgidp, old_gid_t __user *, egidp, old_gid_t __user *, sgidp)",
            "{",
            "\tconst struct cred *cred = current_cred();",
            "\tint retval;",
            "\told_gid_t rgid, egid, sgid;",
            "",
            "\trgid = high2lowgid(from_kgid_munged(cred->user_ns, cred->gid));",
            "\tegid = high2lowgid(from_kgid_munged(cred->user_ns, cred->egid));",
            "\tsgid = high2lowgid(from_kgid_munged(cred->user_ns, cred->sgid));",
            "",
            "\tif (!(retval   = put_user(rgid, rgidp)) &&",
            "\t    !(retval   = put_user(egid, egidp)))",
            "\t\tretval = put_user(sgid, sgidp);",
            "",
            "\treturn retval;",
            "}",
            "",
            "SYSCALL_DEFINE1(setfsuid16, old_uid_t, uid)",
            "{",
            "\treturn __sys_setfsuid(low2highuid(uid));",
            "}",
            "",
            "SYSCALL_DEFINE1(setfsgid16, old_gid_t, gid)",
            "{",
            "\treturn __sys_setfsgid(low2highgid(gid));",
            "}",
            ""
          ],
          "function_name": null,
          "description": "此代码块实现了16位UID的兼容性包装函数，将old_uid_t类型的参数转换为高位UID（通过low2highuid）后调用相应的内核函数（如ksys_chown、__sys_setuid等），并提供从高位UID还原为低位UID的逻辑（通过high2lowuid），以维护对旧应用程序的兼容性。",
          "similarity": 0.5818099975585938
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/uid16.c",
          "start_line": 114,
          "end_line": 151,
          "content": [
            "static int groups16_to_user(old_gid_t __user *grouplist,",
            "    struct group_info *group_info)",
            "{",
            "\tstruct user_namespace *user_ns = current_user_ns();",
            "\tint i;",
            "\told_gid_t group;",
            "\tkgid_t kgid;",
            "",
            "\tfor (i = 0; i < group_info->ngroups; i++) {",
            "\t\tkgid = group_info->gid[i];",
            "\t\tgroup = high2lowgid(from_kgid_munged(user_ns, kgid));",
            "\t\tif (put_user(group, grouplist+i))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int groups16_from_user(struct group_info *group_info,",
            "    old_gid_t __user *grouplist)",
            "{",
            "\tstruct user_namespace *user_ns = current_user_ns();",
            "\tint i;",
            "\told_gid_t group;",
            "\tkgid_t kgid;",
            "",
            "\tfor (i = 0; i < group_info->ngroups; i++) {",
            "\t\tif (get_user(group, grouplist+i))",
            "\t\t\treturn  -EFAULT;",
            "",
            "\t\tkgid = make_kgid(user_ns, low2highgid(group));",
            "\t\tif (!gid_valid(kgid))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tgroup_info->gid[i] = kgid;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "groups16_to_user, groups16_from_user",
          "description": "该代码块包含两个辅助函数，groups16_to_user将用户组列表中的旧16位GID转换为kgid类型并写入用户空间缓冲区，groups16_from_user则从用户空间读取旧GID转换为kgid并填充至group_info结构，确保用户组操作在旧GID与内核GID之间的双向转换。",
          "similarity": 0.5133193135261536
        }
      ]
    },
    {
      "source_file": "kernel/user_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:46:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user_namespace.c`\n\n---\n\n# user_namespace.c 技术文档\n\n## 1. 文件概述\n\n`user_namespace.c` 是 Linux 内核中实现用户命名空间（User Namespace）核心功能的源文件。用户命名空间是 Linux 命名空间机制的一部分，用于隔离用户和组 ID（UID/GID），使得不同命名空间中的相同 UID 可以映射到宿主系统中的不同实际 UID/GID。该文件负责用户命名空间的创建、销毁、引用计数管理、ID 映射查找以及与凭证（credentials）的集成，是容器化技术（如 Docker、LXC）实现非特权容器和用户隔离的关键组件。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`create_user_ns(struct cred *new)`**  \n  创建一个新的用户命名空间，设置其父命名空间、层级、所有者、资源限制，并初始化凭证中的命名空间指针。\n\n- **`unshare_userns(unsigned long unshare_flags, struct cred **new_cred)`**  \n  为当前进程创建新的用户命名空间（通过 `unshare(CLONE_NEWUSER)` 系统调用触发），并返回新的凭证结构。\n\n- **`free_user_ns(struct work_struct *work)`**  \n  异步释放用户命名空间及其关联资源（如 ID 映射、sysctl 表、密钥环等），通过工作队列延迟执行以避免死锁。\n\n- **`__put_user_ns(struct user_namespace *ns)`**  \n  减少用户命名空间引用计数，若引用计数归零则调度 `free_user_ns` 工作项进行释放。\n\n- **`map_id_range_down_base()` / `map_id_range_down_max()`**  \n  在 UID/GID 映射表中查找指定 ID 范围对应的映射条目，分别处理小规模（≤4 条）和大规模（>4 条）映射。\n\n- **`cmp_map_id()`**  \n  用于二分查找的比较函数，支持正向（内核 ID → 用户 ID）和反向（用户 ID → 内核 ID）映射查询。\n\n- **`set_cred_user_ns()`**  \n  初始化新凭证中的用户命名空间相关字段，包括能力集（capabilities）、安全位（securebits）和密钥认证上下文。\n\n- **`enforced_nproc_rlimit()`**  \n  根据当前用户是否为全局 root 以及是否处于初始用户命名空间，决定是否对 `RLIMIT_NPROC` 施加限制。\n\n### 主要数据结构\n\n- **`struct user_namespace`**  \n  用户命名空间的核心结构体，包含父命名空间指针、层级、所有者 UID/GID、ID 映射表（uid_map、gid_map、projid_map）、资源使用计数器（ucounts）、引用计数、标志位、密钥环列表等。\n\n- **`struct idmap_key`**  \n  用于 ID 映射查找的辅助结构，封装待查找的 ID、范围长度及映射方向（向上/向下）。\n\n- **`struct uid_gid_extent`**  \n  表示单个 UID/GID 映射区间的结构，包含起始内核 ID、起始用户 ID 和映射长度。\n\n## 3. 关键实现\n\n### 用户命名空间创建流程\n1. **层级限制检查**：防止命名空间嵌套过深（最大 32 层）。\n2. **资源计数**：通过 `inc_user_namespaces()` 增加父命名空间中创建者的用户命名空间使用计数。\n3. **安全策略验证**：\n   - 禁止在 chroot 环境中创建新用户命名空间。\n   - 确保创建者的 UID/GID 在父命名空间中有有效映射。\n4. **安全模块回调**：调用 LSM（如 SELinux、AppArmor）的 `security_create_user_ns()` 钩子进行权限检查。\n5. **初始化新命名空间**：\n   - 分配内存并设置层级、所有者、父指针。\n   - 初始化资源限制（如进程数、消息队列大小等）。\n   - 继承父命名空间的标志（如 `USERNS_SETGROUPS_ALLOWED`）。\n   - 设置凭证中的用户命名空间指针并重置能力集。\n\n### ID 映射查找算法\n- **小规模映射（≤4 条）**：使用线性遍历（`map_id_range_down_base`）。\n- **大规模映射（>4 条）**：使用二分查找（`map_id_range_down_max` + `bsearch`），映射表按 `first` 字段排序。\n- **双向映射支持**：通过 `idmap_key.map_up` 标志区分内核 ID → 用户 ID（map down）和用户 ID → 内核 ID（map up）。\n\n### 异步释放机制\n- 使用 `INIT_WORK()` 将释放操作注册为工作队列任务。\n- 在 `free_user_ns()` 中循环释放命名空间链（处理引用计数级联归零的情况）。\n- 释放动态分配的映射表内存、sysctl 表、密钥环资源，并减少资源使用计数。\n\n### 能力与安全上下文初始化\n- 新命名空间的初始凭证拥有 `CAP_FULL_SET`，但这些能力仅在新命名空间内有效。\n- 清除请求密钥认证（`request_key_auth`）上下文，防止跨命名空间密钥泄露。\n- 重置安全位（`securebits`）为默认值。\n\n## 4. 依赖关系\n\n- **命名空间基础设施**：依赖 `<linux/nsproxy.h>` 和 `ns_common` 结构，与 `proc_ns.c` 协作提供 `/proc/<pid>/ns/user` 接口。\n- **凭证管理**：与 `<linux/cred.h>` 紧密集成，通过 `prepare_creds()`/`put_cred()` 管理凭证生命周期。\n- **资源计数**：使用 `<linux/user_namespace.h>` 中的 `ucounts` 机制跟踪用户命名空间、进程数等资源使用。\n- **安全模块**：通过 LSM 接口（`security_create_user_ns()`）与安全子系统交互。\n- **密钥管理**：依赖 `<keys/user-type.h>` 实现命名空间隔离的用户密钥环。\n- **内存管理**：使用 SLAB 分配器（`kmem_cache`）高效分配 `user_namespace` 结构。\n- **ID 映射**：与 `uidgid.c` 协同实现 UID/GID 映射的设置与查询。\n\n## 5. 使用场景\n\n- **容器运行时**：Docker、Podman、LXC 等通过 `unshare(CLONE_NEWUSER)` 创建非特权容器，实现用户隔离。\n- **用户态命名空间管理**：`unshare(1)` 命令或 `clone(2)` 系统调用创建独立用户上下文。\n- **特权降级**：进程在创建用户命名空间后映射自身为新命名空间的 root，获得有限特权。\n- **安全沙箱**：浏览器、应用沙箱利用用户命名空间限制潜在攻击面。\n- **ID 映射服务**：`newuidmap`/`newgidmap` 工具通过写入 `/proc/<pid>/uid_map` 配置映射，内核通过本文件中的查找函数解析映射关系。\n- **资源隔离**：结合 `ucounts` 机制限制单个用户可创建的用户命名空间数量，防止资源耗尽攻击。",
      "similarity": 0.5947417616844177,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/user_namespace.c",
          "start_line": 425,
          "end_line": 541,
          "content": [
            "kuid_t make_kuid(struct user_namespace *ns, uid_t uid)",
            "{",
            "\t/* Map the uid to a global kernel uid */",
            "\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));",
            "}",
            "uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)",
            "{",
            "\t/* Map the uid from a global kernel uid */",
            "\treturn map_id_up(&targ->uid_map, __kuid_val(kuid));",
            "}",
            "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)",
            "{",
            "\tuid_t uid;",
            "\tuid = from_kuid(targ, kuid);",
            "",
            "\tif (uid == (uid_t) -1)",
            "\t\tuid = overflowuid;",
            "\treturn uid;",
            "}",
            "kgid_t make_kgid(struct user_namespace *ns, gid_t gid)",
            "{",
            "\t/* Map the gid to a global kernel gid */",
            "\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));",
            "}",
            "gid_t from_kgid(struct user_namespace *targ, kgid_t kgid)",
            "{",
            "\t/* Map the gid from a global kernel gid */",
            "\treturn map_id_up(&targ->gid_map, __kgid_val(kgid));",
            "}",
            "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)",
            "{",
            "\tgid_t gid;",
            "\tgid = from_kgid(targ, kgid);",
            "",
            "\tif (gid == (gid_t) -1)",
            "\t\tgid = overflowgid;",
            "\treturn gid;",
            "}",
            "kprojid_t make_kprojid(struct user_namespace *ns, projid_t projid)",
            "{",
            "\t/* Map the uid to a global kernel uid */",
            "\treturn KPROJIDT_INIT(map_id_down(&ns->projid_map, projid));",
            "}",
            "projid_t from_kprojid(struct user_namespace *targ, kprojid_t kprojid)",
            "{",
            "\t/* Map the uid from a global kernel uid */",
            "\treturn map_id_up(&targ->projid_map, __kprojid_val(kprojid));",
            "}",
            "projid_t from_kprojid_munged(struct user_namespace *targ, kprojid_t kprojid)",
            "{",
            "\tprojid_t projid;",
            "\tprojid = from_kprojid(targ, kprojid);",
            "",
            "\tif (projid == (projid_t) -1)",
            "\t\tprojid = OVERFLOW_PROJID;",
            "\treturn projid;",
            "}",
            "static int uid_m_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct uid_gid_extent *extent = v;",
            "\tstruct user_namespace *lower_ns;",
            "\tuid_t lower;",
            "",
            "\tlower_ns = seq_user_ns(seq);",
            "\tif ((lower_ns == ns) && lower_ns->parent)",
            "\t\tlower_ns = lower_ns->parent;",
            "",
            "\tlower = from_kuid(lower_ns, KUIDT_INIT(extent->lower_first));",
            "",
            "\tseq_printf(seq, \"%10u %10u %10u\\n\",",
            "\t\textent->first,",
            "\t\tlower,",
            "\t\textent->count);",
            "",
            "\treturn 0;",
            "}",
            "static int gid_m_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct uid_gid_extent *extent = v;",
            "\tstruct user_namespace *lower_ns;",
            "\tgid_t lower;",
            "",
            "\tlower_ns = seq_user_ns(seq);",
            "\tif ((lower_ns == ns) && lower_ns->parent)",
            "\t\tlower_ns = lower_ns->parent;",
            "",
            "\tlower = from_kgid(lower_ns, KGIDT_INIT(extent->lower_first));",
            "",
            "\tseq_printf(seq, \"%10u %10u %10u\\n\",",
            "\t\textent->first,",
            "\t\tlower,",
            "\t\textent->count);",
            "",
            "\treturn 0;",
            "}",
            "static int projid_m_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct uid_gid_extent *extent = v;",
            "\tstruct user_namespace *lower_ns;",
            "\tprojid_t lower;",
            "",
            "\tlower_ns = seq_user_ns(seq);",
            "\tif ((lower_ns == ns) && lower_ns->parent)",
            "\t\tlower_ns = lower_ns->parent;",
            "",
            "\tlower = from_kprojid(lower_ns, KPROJIDT_INIT(extent->lower_first));",
            "",
            "\tseq_printf(seq, \"%10u %10u %10u\\n\",",
            "\t\textent->first,",
            "\t\tlower,",
            "\t\textent->count);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "make_kuid, from_kuid, from_kuid_munged, make_kgid, from_kgid, from_kgid_munged, make_kprojid, from_kprojid, from_kprojid_munged, uid_m_show, gid_m_show, projid_m_show",
          "description": "实现用户/组/项目ID跨命名空间转换接口，通过双向映射关系进行身份标识转换与溢出值处理。",
          "similarity": 0.5618470907211304
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/user_namespace.c",
          "start_line": 193,
          "end_line": 310,
          "content": [
            "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)",
            "{",
            "\tstruct cred *cred;",
            "\tint err = -ENOMEM;",
            "",
            "\tif (!(unshare_flags & CLONE_NEWUSER))",
            "\t\treturn 0;",
            "",
            "\tcred = prepare_creds();",
            "\tif (cred) {",
            "\t\terr = create_user_ns(cred);",
            "\t\tif (err)",
            "\t\t\tput_cred(cred);",
            "\t\telse",
            "\t\t\t*new_cred = cred;",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "static void free_user_ns(struct work_struct *work)",
            "{",
            "\tstruct user_namespace *parent, *ns =",
            "\t\tcontainer_of(work, struct user_namespace, work);",
            "",
            "\tdo {",
            "\t\tstruct ucounts *ucounts = ns->ucounts;",
            "\t\tparent = ns->parent;",
            "\t\tif (ns->gid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\t\tkfree(ns->gid_map.forward);",
            "\t\t\tkfree(ns->gid_map.reverse);",
            "\t\t}",
            "\t\tif (ns->uid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\t\tkfree(ns->uid_map.forward);",
            "\t\t\tkfree(ns->uid_map.reverse);",
            "\t\t}",
            "\t\tif (ns->projid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\t\tkfree(ns->projid_map.forward);",
            "\t\t\tkfree(ns->projid_map.reverse);",
            "\t\t}",
            "\t\tretire_userns_sysctls(ns);",
            "\t\tkey_free_user_ns(ns);",
            "\t\tns_free_inum(&ns->ns);",
            "\t\tkmem_cache_free(user_ns_cachep, ns);",
            "\t\tdec_user_namespaces(ucounts);",
            "\t\tns = parent;",
            "\t} while (refcount_dec_and_test(&parent->ns.count));",
            "}",
            "void __put_user_ns(struct user_namespace *ns)",
            "{",
            "\tschedule_work(&ns->work);",
            "}",
            "static int cmp_map_id(const void *k, const void *e)",
            "{",
            "\tu32 first, last, id2;",
            "\tconst struct idmap_key *key = k;",
            "\tconst struct uid_gid_extent *el = e;",
            "",
            "\tid2 = key->id + key->count - 1;",
            "",
            "\t/* handle map_id_{down,up}() */",
            "\tif (key->map_up)",
            "\t\tfirst = el->lower_first;",
            "\telse",
            "\t\tfirst = el->first;",
            "",
            "\tlast = first + el->count - 1;",
            "",
            "\tif (key->id >= first && key->id <= last &&",
            "\t    (id2 >= first && id2 <= last))",
            "\t\treturn 0;",
            "",
            "\tif (key->id < first || id2 < first)",
            "\t\treturn -1;",
            "",
            "\treturn 1;",
            "}",
            "static u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)",
            "{",
            "\tstruct uid_gid_extent *extent;",
            "\tunsigned extents = map->nr_extents;",
            "\tsmp_rmb();",
            "",
            "\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\textent = map_id_range_down_base(extents, map, id, count);",
            "\telse",
            "\t\textent = map_id_range_down_max(extents, map, id, count);",
            "",
            "\t/* Map the id or note failure */",
            "\tif (extent)",
            "\t\tid = (id - extent->first) + extent->lower_first;",
            "\telse",
            "\t\tid = (u32) -1;",
            "",
            "\treturn id;",
            "}",
            "static u32 map_id_down(struct uid_gid_map *map, u32 id)",
            "{",
            "\treturn map_id_range_down(map, id, 1);",
            "}",
            "static u32 map_id_up(struct uid_gid_map *map, u32 id)",
            "{",
            "\tstruct uid_gid_extent *extent;",
            "\tunsigned extents = map->nr_extents;",
            "\tsmp_rmb();",
            "",
            "\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\textent = map_id_up_base(extents, map, id);",
            "\telse",
            "\t\textent = map_id_up_max(extents, map, id);",
            "",
            "\t/* Map the id or note failure */",
            "\tif (extent)",
            "\t\tid = (id - extent->lower_first) + extent->first;",
            "\telse",
            "\t\tid = (u32) -1;",
            "",
            "\treturn id;",
            "}"
          ],
          "function_name": "unshare_userns, free_user_ns, __put_user_ns, cmp_map_id, map_id_range_down, map_id_down, map_id_up",
          "description": "提供用户命名空间解隔离接口与析构逻辑，包含映射表清理、引用计数递减及延迟释放机制。",
          "similarity": 0.5617243051528931
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/user_namespace.c",
          "start_line": 860,
          "end_line": 1109,
          "content": [
            "static int sort_idmaps(struct uid_gid_map *map)",
            "{",
            "\tif (map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\treturn 0;",
            "",
            "\t/* Sort forward array. */",
            "\tsort(map->forward, map->nr_extents, sizeof(struct uid_gid_extent),",
            "\t     cmp_extents_forward, NULL);",
            "",
            "\t/* Only copy the memory from forward we actually need. */",
            "\tmap->reverse = kmemdup(map->forward,",
            "\t\t\t       map->nr_extents * sizeof(struct uid_gid_extent),",
            "\t\t\t       GFP_KERNEL);",
            "\tif (!map->reverse)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* Sort reverse array. */",
            "\tsort(map->reverse, map->nr_extents, sizeof(struct uid_gid_extent),",
            "\t     cmp_extents_reverse, NULL);",
            "",
            "\treturn 0;",
            "}",
            "static bool verify_root_map(const struct file *file,",
            "\t\t\t    struct user_namespace *map_ns,",
            "\t\t\t    struct uid_gid_map *new_map)",
            "{",
            "\tint idx;",
            "\tconst struct user_namespace *file_ns = file->f_cred->user_ns;",
            "\tstruct uid_gid_extent *extent0 = NULL;",
            "",
            "\tfor (idx = 0; idx < new_map->nr_extents; idx++) {",
            "\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\t\textent0 = &new_map->extent[idx];",
            "\t\telse",
            "\t\t\textent0 = &new_map->forward[idx];",
            "\t\tif (extent0->lower_first == 0)",
            "\t\t\tbreak;",
            "",
            "\t\textent0 = NULL;",
            "\t}",
            "",
            "\tif (!extent0)",
            "\t\treturn true;",
            "",
            "\tif (map_ns == file_ns) {",
            "\t\t/* The process unshared its ns and is writing to its own",
            "\t\t * /proc/self/uid_map.  User already has full capabilites in",
            "\t\t * the new namespace.  Verify that the parent had CAP_SETFCAP",
            "\t\t * when it unshared.",
            "\t\t * */",
            "\t\tif (!file_ns->parent_could_setfcap)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\t/* Process p1 is writing to uid_map of p2, who is in a child",
            "\t\t * user namespace to p1's.  Verify that the opener of the map",
            "\t\t * file has CAP_SETFCAP against the parent of the new map",
            "\t\t * namespace */",
            "\t\tif (!file_ns_capable(file, map_ns->parent, CAP_SETFCAP))",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static ssize_t map_write(struct file *file, const char __user *buf,",
            "\t\t\t size_t count, loff_t *ppos,",
            "\t\t\t int cap_setid,",
            "\t\t\t struct uid_gid_map *map,",
            "\t\t\t struct uid_gid_map *parent_map)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *map_ns = seq->private;",
            "\tstruct uid_gid_map new_map;",
            "\tunsigned idx;",
            "\tstruct uid_gid_extent extent;",
            "\tchar *kbuf = NULL, *pos, *next_line;",
            "\tssize_t ret;",
            "",
            "\t/* Only allow < page size writes at the beginning of the file */",
            "\tif ((*ppos != 0) || (count >= PAGE_SIZE))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Slurp in the user data */",
            "\tkbuf = memdup_user_nul(buf, count);",
            "\tif (IS_ERR(kbuf))",
            "\t\treturn PTR_ERR(kbuf);",
            "",
            "\t/*",
            "\t * The userns_state_mutex serializes all writes to any given map.",
            "\t *",
            "\t * Any map is only ever written once.",
            "\t *",
            "\t * An id map fits within 1 cache line on most architectures.",
            "\t *",
            "\t * On read nothing needs to be done unless you are on an",
            "\t * architecture with a crazy cache coherency model like alpha.",
            "\t *",
            "\t * There is a one time data dependency between reading the",
            "\t * count of the extents and the values of the extents.  The",
            "\t * desired behavior is to see the values of the extents that",
            "\t * were written before the count of the extents.",
            "\t *",
            "\t * To achieve this smp_wmb() is used on guarantee the write",
            "\t * order and smp_rmb() is guaranteed that we don't have crazy",
            "\t * architectures returning stale data.",
            "\t */",
            "\tmutex_lock(&userns_state_mutex);",
            "",
            "\tmemset(&new_map, 0, sizeof(struct uid_gid_map));",
            "",
            "\tret = -EPERM;",
            "\t/* Only allow one successful write to the map */",
            "\tif (map->nr_extents != 0)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Adjusting namespace settings requires capabilities on the target.",
            "\t */",
            "\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))",
            "\t\tgoto out;",
            "",
            "\t/* Parse the user data */",
            "\tret = -EINVAL;",
            "\tpos = kbuf;",
            "\tfor (; pos; pos = next_line) {",
            "",
            "\t\t/* Find the end of line and ensure I don't look past it */",
            "\t\tnext_line = strchr(pos, '\\n');",
            "\t\tif (next_line) {",
            "\t\t\t*next_line = '\\0';",
            "\t\t\tnext_line++;",
            "\t\t\tif (*next_line == '\\0')",
            "\t\t\t\tnext_line = NULL;",
            "\t\t}",
            "",
            "\t\tpos = skip_spaces(pos);",
            "\t\textent.first = simple_strtoul(pos, &pos, 10);",
            "\t\tif (!isspace(*pos))",
            "\t\t\tgoto out;",
            "",
            "\t\tpos = skip_spaces(pos);",
            "\t\textent.lower_first = simple_strtoul(pos, &pos, 10);",
            "\t\tif (!isspace(*pos))",
            "\t\t\tgoto out;",
            "",
            "\t\tpos = skip_spaces(pos);",
            "\t\textent.count = simple_strtoul(pos, &pos, 10);",
            "\t\tif (*pos && !isspace(*pos))",
            "\t\t\tgoto out;",
            "",
            "\t\t/* Verify there is not trailing junk on the line */",
            "\t\tpos = skip_spaces(pos);",
            "\t\tif (*pos != '\\0')",
            "\t\t\tgoto out;",
            "",
            "\t\t/* Verify we have been given valid starting values */",
            "\t\tif ((extent.first == (u32) -1) ||",
            "\t\t    (extent.lower_first == (u32) -1))",
            "\t\t\tgoto out;",
            "",
            "\t\t/* Verify count is not zero and does not cause the",
            "\t\t * extent to wrap",
            "\t\t */",
            "\t\tif ((extent.first + extent.count) <= extent.first)",
            "\t\t\tgoto out;",
            "\t\tif ((extent.lower_first + extent.count) <=",
            "\t\t     extent.lower_first)",
            "\t\t\tgoto out;",
            "",
            "\t\t/* Do the ranges in extent overlap any previous extents? */",
            "\t\tif (mappings_overlap(&new_map, &extent))",
            "\t\t\tgoto out;",
            "",
            "\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&",
            "\t\t    (next_line != NULL))",
            "\t\t\tgoto out;",
            "",
            "\t\tret = insert_extent(&new_map, &extent);",
            "\t\tif (ret < 0)",
            "\t\t\tgoto out;",
            "\t\tret = -EINVAL;",
            "\t}",
            "\t/* Be very certain the new map actually exists */",
            "\tif (new_map.nr_extents == 0)",
            "\t\tgoto out;",
            "",
            "\tret = -EPERM;",
            "\t/* Validate the user is allowed to use user id's mapped to. */",
            "\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))",
            "\t\tgoto out;",
            "",
            "\tret = -EPERM;",
            "\t/* Map the lower ids from the parent user namespace to the",
            "\t * kernel global id space.",
            "\t */",
            "\tfor (idx = 0; idx < new_map.nr_extents; idx++) {",
            "\t\tstruct uid_gid_extent *e;",
            "\t\tu32 lower_first;",
            "",
            "\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\t\te = &new_map.extent[idx];",
            "\t\telse",
            "\t\t\te = &new_map.forward[idx];",
            "",
            "\t\tlower_first = map_id_range_down(parent_map,",
            "\t\t\t\t\t\te->lower_first,",
            "\t\t\t\t\t\te->count);",
            "",
            "\t\t/* Fail if we can not map the specified extent to",
            "\t\t * the kernel global id space.",
            "\t\t */",
            "\t\tif (lower_first == (u32) -1)",
            "\t\t\tgoto out;",
            "",
            "\t\te->lower_first = lower_first;",
            "\t}",
            "",
            "\t/*",
            "\t * If we want to use binary search for lookup, this clones the extent",
            "\t * array and sorts both copies.",
            "\t */",
            "\tret = sort_idmaps(&new_map);",
            "\tif (ret < 0)",
            "\t\tgoto out;",
            "",
            "\t/* Install the map */",
            "\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\tmemcpy(map->extent, new_map.extent,",
            "\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));",
            "\t} else {",
            "\t\tmap->forward = new_map.forward;",
            "\t\tmap->reverse = new_map.reverse;",
            "\t}",
            "\tsmp_wmb();",
            "\tmap->nr_extents = new_map.nr_extents;",
            "",
            "\t*ppos = count;",
            "\tret = count;",
            "out:",
            "\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\tkfree(new_map.forward);",
            "\t\tkfree(new_map.reverse);",
            "\t\tmap->forward = NULL;",
            "\t\tmap->reverse = NULL;",
            "\t\tmap->nr_extents = 0;",
            "\t}",
            "",
            "\tmutex_unlock(&userns_state_mutex);",
            "\tkfree(kbuf);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "sort_idmaps, verify_root_map, map_write",
          "description": "实现用户命名空间中ID映射的排序与验证逻辑，通过sort_idmaps对映射区间排序并复制内存，verify_root_map检查根映射的权限合法性，map_write处理用户态ID映射写入，包含数据解析、有效性校验及映射安装，需具备SETUID/SETGID能力",
          "similarity": 0.5329766273498535
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/user_namespace.c",
          "start_line": 722,
          "end_line": 822,
          "content": [
            "static void m_stop(struct seq_file *seq, void *v)",
            "{",
            "\treturn;",
            "}",
            "static bool mappings_overlap(struct uid_gid_map *new_map,",
            "\t\t\t     struct uid_gid_extent *extent)",
            "{",
            "\tu32 upper_first, lower_first, upper_last, lower_last;",
            "\tunsigned idx;",
            "",
            "\tupper_first = extent->first;",
            "\tlower_first = extent->lower_first;",
            "\tupper_last = upper_first + extent->count - 1;",
            "\tlower_last = lower_first + extent->count - 1;",
            "",
            "\tfor (idx = 0; idx < new_map->nr_extents; idx++) {",
            "\t\tu32 prev_upper_first, prev_lower_first;",
            "\t\tu32 prev_upper_last, prev_lower_last;",
            "\t\tstruct uid_gid_extent *prev;",
            "",
            "\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\t\tprev = &new_map->extent[idx];",
            "\t\telse",
            "\t\t\tprev = &new_map->forward[idx];",
            "",
            "\t\tprev_upper_first = prev->first;",
            "\t\tprev_lower_first = prev->lower_first;",
            "\t\tprev_upper_last = prev_upper_first + prev->count - 1;",
            "\t\tprev_lower_last = prev_lower_first + prev->count - 1;",
            "",
            "\t\t/* Does the upper range intersect a previous extent? */",
            "\t\tif ((prev_upper_first <= upper_last) &&",
            "\t\t    (prev_upper_last >= upper_first))",
            "\t\t\treturn true;",
            "",
            "\t\t/* Does the lower range intersect a previous extent? */",
            "\t\tif ((prev_lower_first <= lower_last) &&",
            "\t\t    (prev_lower_last >= lower_first))",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static int insert_extent(struct uid_gid_map *map, struct uid_gid_extent *extent)",
            "{",
            "\tstruct uid_gid_extent *dest;",
            "",
            "\tif (map->nr_extents == UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\tstruct uid_gid_extent *forward;",
            "",
            "\t\t/* Allocate memory for 340 mappings. */",
            "\t\tforward = kmalloc_array(UID_GID_MAP_MAX_EXTENTS,",
            "\t\t\t\t\tsizeof(struct uid_gid_extent),",
            "\t\t\t\t\tGFP_KERNEL);",
            "\t\tif (!forward)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/* Copy over memory. Only set up memory for the forward pointer.",
            "\t\t * Defer the memory setup for the reverse pointer.",
            "\t\t */",
            "\t\tmemcpy(forward, map->extent,",
            "\t\t       map->nr_extents * sizeof(map->extent[0]));",
            "",
            "\t\tmap->forward = forward;",
            "\t\tmap->reverse = NULL;",
            "\t}",
            "",
            "\tif (map->nr_extents < UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\tdest = &map->extent[map->nr_extents];",
            "\telse",
            "\t\tdest = &map->forward[map->nr_extents];",
            "",
            "\t*dest = *extent;",
            "\tmap->nr_extents++;",
            "\treturn 0;",
            "}",
            "static int cmp_extents_forward(const void *a, const void *b)",
            "{",
            "\tconst struct uid_gid_extent *e1 = a;",
            "\tconst struct uid_gid_extent *e2 = b;",
            "",
            "\tif (e1->first < e2->first)",
            "\t\treturn -1;",
            "",
            "\tif (e1->first > e2->first)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int cmp_extents_reverse(const void *a, const void *b)",
            "{",
            "\tconst struct uid_gid_extent *e1 = a;",
            "\tconst struct uid_gid_extent *e2 = b;",
            "",
            "\tif (e1->lower_first < e2->lower_first)",
            "\t\treturn -1;",
            "",
            "\tif (e1->lower_first > e2->lower_first)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "m_stop, mappings_overlap, insert_extent, cmp_extents_forward, cmp_extents_reverse",
          "description": "实现用户命名空间映射区间管理函数，包含范围冲突检测、有序性排序及动态扩展逻辑。",
          "similarity": 0.5192023515701294
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1125,
          "end_line": 1290,
          "content": [
            "ssize_t proc_uid_map_write(struct file *file, const char __user *buf,",
            "\t\t\t   size_t size, loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct user_namespace *seq_ns = seq_user_ns(seq);",
            "",
            "\tif (!ns->parent)",
            "\t\treturn -EPERM;",
            "",
            "\tif ((seq_ns != ns) && (seq_ns != ns->parent))",
            "\t\treturn -EPERM;",
            "",
            "\treturn map_write(file, buf, size, ppos, CAP_SETUID,",
            "\t\t\t &ns->uid_map, &ns->parent->uid_map);",
            "}",
            "ssize_t proc_gid_map_write(struct file *file, const char __user *buf,",
            "\t\t\t   size_t size, loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct user_namespace *seq_ns = seq_user_ns(seq);",
            "",
            "\tif (!ns->parent)",
            "\t\treturn -EPERM;",
            "",
            "\tif ((seq_ns != ns) && (seq_ns != ns->parent))",
            "\t\treturn -EPERM;",
            "",
            "\treturn map_write(file, buf, size, ppos, CAP_SETGID,",
            "\t\t\t &ns->gid_map, &ns->parent->gid_map);",
            "}",
            "ssize_t proc_projid_map_write(struct file *file, const char __user *buf,",
            "\t\t\t      size_t size, loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct user_namespace *seq_ns = seq_user_ns(seq);",
            "",
            "\tif (!ns->parent)",
            "\t\treturn -EPERM;",
            "",
            "\tif ((seq_ns != ns) && (seq_ns != ns->parent))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Anyone can set any valid project id no capability needed */",
            "\treturn map_write(file, buf, size, ppos, -1,",
            "\t\t\t &ns->projid_map, &ns->parent->projid_map);",
            "}",
            "static bool new_idmap_permitted(const struct file *file,",
            "\t\t\t\tstruct user_namespace *ns, int cap_setid,",
            "\t\t\t\tstruct uid_gid_map *new_map)",
            "{",
            "\tconst struct cred *cred = file->f_cred;",
            "",
            "\tif (cap_setid == CAP_SETUID && !verify_root_map(file, ns, new_map))",
            "\t\treturn false;",
            "",
            "\t/* Don't allow mappings that would allow anything that wouldn't",
            "\t * be allowed without the establishment of unprivileged mappings.",
            "\t */",
            "\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1) &&",
            "\t    uid_eq(ns->owner, cred->euid)) {",
            "\t\tu32 id = new_map->extent[0].lower_first;",
            "\t\tif (cap_setid == CAP_SETUID) {",
            "\t\t\tkuid_t uid = make_kuid(ns->parent, id);",
            "\t\t\tif (uid_eq(uid, cred->euid))",
            "\t\t\t\treturn true;",
            "\t\t} else if (cap_setid == CAP_SETGID) {",
            "\t\t\tkgid_t gid = make_kgid(ns->parent, id);",
            "\t\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED) &&",
            "\t\t\t    gid_eq(gid, cred->egid))",
            "\t\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Allow anyone to set a mapping that doesn't require privilege */",
            "\tif (!cap_valid(cap_setid))",
            "\t\treturn true;",
            "",
            "\t/* Allow the specified ids if we have the appropriate capability",
            "\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.",
            "\t * And the opener of the id file also has the appropriate capability.",
            "\t */",
            "\tif (ns_capable(ns->parent, cap_setid) &&",
            "\t    file_ns_capable(file, ns->parent, cap_setid))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "int proc_setgroups_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct user_namespace *ns = seq->private;",
            "\tunsigned long userns_flags = READ_ONCE(ns->flags);",
            "",
            "\tseq_printf(seq, \"%s\\n\",",
            "\t\t   (userns_flags & USERNS_SETGROUPS_ALLOWED) ?",
            "\t\t   \"allow\" : \"deny\");",
            "\treturn 0;",
            "}",
            "ssize_t proc_setgroups_write(struct file *file, const char __user *buf,",
            "\t\t\t     size_t count, loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *ns = seq->private;",
            "\tchar kbuf[8], *pos;",
            "\tbool setgroups_allowed;",
            "\tssize_t ret;",
            "",
            "\t/* Only allow a very narrow range of strings to be written */",
            "\tret = -EINVAL;",
            "\tif ((*ppos != 0) || (count >= sizeof(kbuf)))",
            "\t\tgoto out;",
            "",
            "\t/* What was written? */",
            "\tret = -EFAULT;",
            "\tif (copy_from_user(kbuf, buf, count))",
            "\t\tgoto out;",
            "\tkbuf[count] = '\\0';",
            "\tpos = kbuf;",
            "",
            "\t/* What is being requested? */",
            "\tret = -EINVAL;",
            "\tif (strncmp(pos, \"allow\", 5) == 0) {",
            "\t\tpos += 5;",
            "\t\tsetgroups_allowed = true;",
            "\t}",
            "\telse if (strncmp(pos, \"deny\", 4) == 0) {",
            "\t\tpos += 4;",
            "\t\tsetgroups_allowed = false;",
            "\t}",
            "\telse",
            "\t\tgoto out;",
            "",
            "\t/* Verify there is not trailing junk on the line */",
            "\tpos = skip_spaces(pos);",
            "\tif (*pos != '\\0')",
            "\t\tgoto out;",
            "",
            "\tret = -EPERM;",
            "\tmutex_lock(&userns_state_mutex);",
            "\tif (setgroups_allowed) {",
            "\t\t/* Enabling setgroups after setgroups has been disabled",
            "\t\t * is not allowed.",
            "\t\t */",
            "\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED))",
            "\t\t\tgoto out_unlock;",
            "\t} else {",
            "\t\t/* Permanently disabling setgroups after setgroups has",
            "\t\t * been enabled by writing the gid_map is not allowed.",
            "\t\t */",
            "\t\tif (ns->gid_map.nr_extents != 0)",
            "\t\t\tgoto out_unlock;",
            "\t\tns->flags &= ~USERNS_SETGROUPS_ALLOWED;",
            "\t}",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "\t/* Report a successful write */",
            "\t*ppos = count;",
            "\tret = count;",
            "out:",
            "\treturn ret;",
            "out_unlock:",
            "\tmutex_unlock(&userns_state_mutex);",
            "\tgoto out;",
            "}"
          ],
          "function_name": "proc_uid_map_write, proc_gid_map_write, proc_projid_map_write, new_idmap_permitted, proc_setgroups_show, proc_setgroups_write",
          "description": "提供用户/组/项目ID映射文件的操作接口，proc_*_map_write系列函数通过map_write设置对应ID映射，new_idmap_permitted验证新映射权限，proc_setgroups控制组切换权限，支持允许/禁止setgroups操作",
          "similarity": 0.48652997612953186
        }
      ]
    },
    {
      "source_file": "kernel/pid.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:16:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid.c`\n\n---\n\n# `pid.c` 技术文档\n\n## 1. 文件概述\n\n`pid.c` 是 Linux 内核中实现进程标识符（PID）管理和分配机制的核心文件。它提供了可扩展、时间有界的 PID 分配器，支持 PID 哈希表（pidhash）以及 PID 命名空间（pid namespace）功能。该文件负责 PID 的分配、释放、引用计数管理，并确保在多处理器（SMP）环境下的线程安全性。其设计目标是在高并发场景下高效、无锁地分配和回收 PID，同时支持容器化环境中的 PID 隔离。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct pid`**  \n  表示一个 PID 实例，包含：\n  - 引用计数（`count`）\n  - 多种任务类型链表（`tasks[PIDTYPE_MAX]`），用于关联不同类型的进程（如线程组、会话等）\n  - PID 层级（`level`），用于命名空间嵌套\n  - `numbers[]` 数组：每个命名空间层级对应的 `struct upid`（包含实际 PID 编号 `nr` 和所属命名空间 `ns`）\n  - `rcu` 字段：用于 RCU 安全释放\n  - `wait_pidfd`：用于 pidfd 机制的等待队列\n  - `inodes`：关联的 pidfs inode 列表\n\n- **`struct pid_namespace`**  \n  PID 命名空间结构，包含：\n  - IDR（整数 ID 映射）结构 `idr`，用于高效 PID 分配\n  - `pid_allocated`：当前已分配 PID 数量（含特殊状态如 `PIDNS_ADDING`）\n  - `child_reaper`：命名空间中的 init 进程（子进程回收者）\n  - `level`：命名空间嵌套层级\n  - `pid_cachep`：用于分配 `struct pid` 的 slab 缓存\n\n- **全局变量**\n  - `init_struct_pid`：初始 PID 结构（PID 0，用于 idle 进程）\n  - `init_pid_ns`：初始 PID 命名空间\n  - `pid_max` / `pid_max_min` / `pid_max_max`：PID 分配上限控制\n  - `pidfs_ino`：pidfs 文件系统的 inode 编号起始值\n  - `pidmap_lock`：保护 IDR 和 `pid_allocated` 的自旋锁（SMP 对齐）\n\n### 主要函数\n\n- **`alloc_pid(struct pid_namespace *ns, pid_t *set_tid, size_t set_tid_size)`**  \n  在指定 PID 命名空间中分配一个新的 PID。支持通过 `set_tid` 数组在嵌套命名空间中预设 PID（用于容器恢复等场景）。\n\n- **`free_pid(struct pid *pid)`**  \n  释放 PID 资源，从所有嵌套命名空间的 IDR 中移除，并减少 `pid_allocated` 计数。若命名空间中仅剩 reaper 进程，则唤醒它。\n\n- **`put_pid(struct pid *pid)`**  \n  减少 PID 引用计数，若引用归零则释放内存并减少命名空间引用。\n\n- **`delayed_put_pid(struct rcu_head *rhp)`**  \n  RCU 回调函数，用于安全释放 PID 结构。\n\n## 3. 关键实现\n\n### PID 分配机制\n- 使用 **IDR（Integer ID Allocator）** 替代传统的位图（bitmap），实现 O(1) 分配与释放。\n- 默认采用**循环分配策略**（`idr_alloc_cyclic`），从 `RESERVED_PIDS`（通常为 300）开始，避免低编号 PID 被耗尽。\n- 支持**预设 PID 分配**：通过 `set_tid` 参数在创建进程时指定特定 PID（需具备 `CAP_CHECKPOINT_RESTORE` 权限），用于容器快照恢复。\n\n### 命名空间支持\n- 每个 PID 在嵌套的命名空间中拥有不同的编号（`upid->nr`），通过 `pid->numbers[]` 数组维护层级关系。\n- `pid->level` 表示该 PID 所属的最深命名空间层级。\n- 分配时从最深层命名空间向上遍历至根命名空间，逐层分配 PID。\n\n### 并发与同步\n- **`pidmap_lock`**：保护 IDR 操作和 `pid_allocated` 计数器，使用 `spin_lock_irqsave` 禁用本地中断，防止与 `tasklist_lock` 的死锁。\n- **RCU 释放**：`free_pid` 通过 `call_rcu` 延迟释放 PID 结构，避免在持有锁时执行内存释放。\n- **引用计数**：`struct pid` 使用 `refcount_t` 管理生命周期，确保多任务共享 PID 时的安全释放。\n\n### 特殊状态处理\n- **`PIDNS_ADDING`**：标记命名空间正在添加新进程，防止在 fork 失败时错误减少计数。\n- **Reaper 唤醒**：当命名空间中 PID 数量降至 1 或 2 时，唤醒 `child_reaper`（通常为 init 进程），用于处理命名空间退出（`zap_pid_ns_processes`）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pid_namespace.h>`：PID 命名空间定义\n  - `<linux/idr.h>`：IDR 分配器实现\n  - `<linux/rculist.h>`：RCU 安全链表操作\n  - `<linux/sched/task.h>`、`<linux/sched/signal.h>`：任务调度与信号处理\n  - `<linux/pidfs.h>`、`<uapi/linux/pidfd.h>`：pidfd 和 pidfs 支持\n  - `<linux/refcount.h>`：引用计数机制\n\n- **内核模块交互**：\n  - **进程管理子系统**：与 `fork`/`clone` 系统调用集成，分配 PID 并关联到 `task_struct`\n  - **命名空间子系统**：与 `pidns_operations` 协同实现 PID 隔离\n  - **VFS 子系统**：通过 `pidfs_ino` 为 `/proc/[pid]` 提供 inode 编号\n  - **内存管理**：使用 slab 分配器（`kmem_cache_alloc`）管理 `struct pid` 内存\n\n## 5. 使用场景\n\n- **进程创建**：在 `copy_process` 中调用 `alloc_pid` 为新进程分配唯一 PID。\n- **容器运行时**：通过 `clone(CLONE_NEWPID)` 创建 PID 命名空间，实现容器内 PID 隔离。\n- **检查点/恢复（CRIU）**：使用 `set_tid` 参数在恢复进程时精确还原原始 PID。\n- **pidfd 机制**：`pid->wait_pidfd` 支持通过文件描述符等待进程退出（`pidfd_send_signal` 等系统调用）。\n- **命名空间清理**：当容器退出时，`free_pid` 触发 reaper 唤醒，确保孤儿进程被正确回收。",
      "similarity": 0.5789046287536621,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/pid.c",
          "start_line": 402,
          "end_line": 488,
          "content": [
            "void transfer_pid(struct task_struct *old, struct task_struct *new,",
            "\t\t\t   enum pid_type type)",
            "{",
            "\tWARN_ON_ONCE(type == PIDTYPE_PID);",
            "\thlist_replace_rcu(&old->pid_links[type], &new->pid_links[type]);",
            "}",
            "pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)",
            "{",
            "\tstruct upid *upid;",
            "\tpid_t nr = 0;",
            "",
            "\tif (pid && ns->level <= pid->level) {",
            "\t\tupid = &pid->numbers[ns->level];",
            "\t\tif (upid->ns == ns)",
            "\t\t\tnr = upid->nr;",
            "\t}",
            "\treturn nr;",
            "}",
            "pid_t pid_vnr(struct pid *pid)",
            "{",
            "\treturn pid_nr_ns(pid, task_active_pid_ns(current));",
            "}",
            "pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,",
            "\t\t\tstruct pid_namespace *ns)",
            "{",
            "\tpid_t nr = 0;",
            "",
            "\trcu_read_lock();",
            "\tif (!ns)",
            "\t\tns = task_active_pid_ns(current);",
            "\tnr = pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);",
            "\trcu_read_unlock();",
            "",
            "\treturn nr;",
            "}",
            "static int pidfd_create(struct pid *pid, unsigned int flags)",
            "{",
            "\tint pidfd;",
            "\tstruct file *pidfd_file;",
            "",
            "\tpidfd = pidfd_prepare(pid, flags, &pidfd_file);",
            "\tif (pidfd < 0)",
            "\t\treturn pidfd;",
            "",
            "\tfd_install(pidfd, pidfd_file);",
            "\treturn pidfd;",
            "}",
            "void __init pid_idr_init(void)",
            "{",
            "\t/* Verify no one has done anything silly: */",
            "\tBUILD_BUG_ON(PID_MAX_LIMIT >= PIDNS_ADDING);",
            "",
            "\t/* bump default and minimum pid_max based on number of cpus */",
            "\tpid_max = min(pid_max_max, max_t(int, pid_max,",
            "\t\t\t\tPIDS_PER_CPU_DEFAULT * num_possible_cpus()));",
            "\tpid_max_min = max_t(int, pid_max_min,",
            "\t\t\t\tPIDS_PER_CPU_MIN * num_possible_cpus());",
            "\tpr_info(\"pid_max: default: %u minimum: %u\\n\", pid_max, pid_max_min);",
            "",
            "\tidr_init(&init_pid_ns.idr);",
            "",
            "\tinit_pid_ns.pid_cachep = kmem_cache_create(\"pid\",",
            "\t\t\tstruct_size_t(struct pid, numbers, 1),",
            "\t\t\t__alignof__(struct pid),",
            "\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT,",
            "\t\t\tNULL);",
            "}",
            "static int pidfd_getfd(struct pid *pid, int fd)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct file *file;",
            "\tint ret;",
            "",
            "\ttask = get_pid_task(pid, PIDTYPE_PID);",
            "\tif (!task)",
            "\t\treturn -ESRCH;",
            "",
            "\tfile = __pidfd_fget(task, fd);",
            "\tput_task_struct(task);",
            "\tif (IS_ERR(file))",
            "\t\treturn PTR_ERR(file);",
            "",
            "\tret = receive_fd(file, O_CLOEXEC);",
            "\tfput(file);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "transfer_pid, pid_nr_ns, pid_vnr, __task_pid_nr_ns, pidfd_create, pid_idr_init, pidfd_getfd",
          "description": "提供跨命名空间PID查询接口及文件描述符创建功能，初始化ID分配器并配置PID命名空间层级关系，支持基于IDR的高效PID索引管理。",
          "similarity": 0.5521186590194702
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/pid.c",
          "start_line": 109,
          "end_line": 221,
          "content": [
            "void put_pid(struct pid *pid)",
            "{",
            "\tstruct pid_namespace *ns;",
            "",
            "\tif (!pid)",
            "\t\treturn;",
            "",
            "\tns = pid->numbers[pid->level].ns;",
            "\tif (refcount_dec_and_test(&pid->count)) {",
            "\t\tkmem_cache_free(ns->pid_cachep, pid);",
            "\t\tput_pid_ns(ns);",
            "\t}",
            "}",
            "static void delayed_put_pid(struct rcu_head *rhp)",
            "{",
            "\tstruct pid *pid = container_of(rhp, struct pid, rcu);",
            "\tput_pid(pid);",
            "}",
            "void free_pid(struct pid *pid)",
            "{",
            "\t/* We can be called with write_lock_irq(&tasklist_lock) held */",
            "\tint i;",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&pidmap_lock, flags);",
            "\tfor (i = 0; i <= pid->level; i++) {",
            "\t\tstruct upid *upid = pid->numbers + i;",
            "\t\tstruct pid_namespace *ns = upid->ns;",
            "\t\tswitch (--ns->pid_allocated) {",
            "\t\tcase 2:",
            "\t\tcase 1:",
            "\t\t\t/* When all that is left in the pid namespace",
            "\t\t\t * is the reaper wake up the reaper.  The reaper",
            "\t\t\t * may be sleeping in zap_pid_ns_processes().",
            "\t\t\t */",
            "\t\t\twake_up_process(ns->child_reaper);",
            "\t\t\tbreak;",
            "\t\tcase PIDNS_ADDING:",
            "\t\t\t/* Handle a fork failure of the first process */",
            "\t\t\tWARN_ON(ns->child_reaper);",
            "\t\t\tns->pid_allocated = 0;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tidr_remove(&ns->idr, upid->nr);",
            "\t}",
            "\tpidfs_remove_pid(pid);",
            "\tspin_unlock_irqrestore(&pidmap_lock, flags);",
            "",
            "\tcall_rcu(&pid->rcu, delayed_put_pid);",
            "}",
            "void disable_pid_allocation(struct pid_namespace *ns)",
            "{",
            "\tspin_lock_irq(&pidmap_lock);",
            "\tns->pid_allocated &= ~PIDNS_ADDING;",
            "\tspin_unlock_irq(&pidmap_lock);",
            "}",
            "void attach_pid(struct task_struct *task, enum pid_type type)",
            "{",
            "\tstruct pid *pid = *task_pid_ptr(task, type);",
            "\thlist_add_head_rcu(&task->pid_links[type], &pid->tasks[type]);",
            "}",
            "static void __change_pid(struct task_struct *task, enum pid_type type,",
            "\t\t\tstruct pid *new)",
            "{",
            "\tstruct pid **pid_ptr = task_pid_ptr(task, type);",
            "\tstruct pid *pid;",
            "\tint tmp;",
            "",
            "\tpid = *pid_ptr;",
            "",
            "\thlist_del_rcu(&task->pid_links[type]);",
            "\t*pid_ptr = new;",
            "",
            "\tif (type == PIDTYPE_PID) {",
            "\t\tWARN_ON_ONCE(pid_has_task(pid, PIDTYPE_PID));",
            "\t\twake_up_all(&pid->wait_pidfd);",
            "\t}",
            "",
            "\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )",
            "\t\tif (pid_has_task(pid, tmp))",
            "\t\t\treturn;",
            "",
            "\tfree_pid(pid);",
            "}",
            "void detach_pid(struct task_struct *task, enum pid_type type)",
            "{",
            "\t__change_pid(task, type, NULL);",
            "}",
            "void change_pid(struct task_struct *task, enum pid_type type,",
            "\t\tstruct pid *pid)",
            "{",
            "\t__change_pid(task, type, pid);",
            "\tattach_pid(task, type);",
            "}",
            "void exchange_tids(struct task_struct *left, struct task_struct *right)",
            "{",
            "\tstruct pid *pid1 = left->thread_pid;",
            "\tstruct pid *pid2 = right->thread_pid;",
            "\tstruct hlist_head *head1 = &pid1->tasks[PIDTYPE_PID];",
            "\tstruct hlist_head *head2 = &pid2->tasks[PIDTYPE_PID];",
            "",
            "\t/* Swap the single entry tid lists */",
            "\thlists_swap_heads_rcu(head1, head2);",
            "",
            "\t/* Swap the per task_struct pid */",
            "\trcu_assign_pointer(left->thread_pid, pid2);",
            "\trcu_assign_pointer(right->thread_pid, pid1);",
            "",
            "\t/* Swap the cached value */",
            "\tWRITE_ONCE(left->pid, pid_nr(pid2));",
            "\tWRITE_ONCE(right->pid, pid_nr(pid1));",
            "}"
          ],
          "function_name": "put_pid, delayed_put_pid, free_pid, disable_pid_allocation, attach_pid, __change_pid, detach_pid, change_pid, exchange_tids",
          "description": "实现PID引用计数管理、释放逻辑及任务PID绑定操作，通过锁保护PID分配状态变更，利用RCU机制延迟释放内存，并处理进程ID类型切换和线程ID交换。",
          "similarity": 0.5475950241088867
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/pid.c",
          "start_line": 1,
          "end_line": 108,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Generic pidhash and scalable, time-bounded PID allocator",
            " *",
            " * (C) 2002-2003 Nadia Yvette Chambers, IBM",
            " * (C) 2004 Nadia Yvette Chambers, Oracle",
            " * (C) 2002-2004 Ingo Molnar, Red Hat",
            " *",
            " * pid-structures are backing objects for tasks sharing a given ID to chain",
            " * against. There is very little to them aside from hashing them and",
            " * parking tasks using given ID's on a list.",
            " *",
            " * The hash is always changed with the tasklist_lock write-acquired,",
            " * and the hash is only accessed with the tasklist_lock at least",
            " * read-acquired, so there's no additional SMP locking needed here.",
            " *",
            " * We have a list of bitmap pages, which bitmaps represent the PID space.",
            " * Allocating and freeing PIDs is completely lockless. The worst-case",
            " * allocation scenario when all but one out of 1 million PIDs possible are",
            " * allocated already: the scanning of 32 list entries and at most PAGE_SIZE",
            " * bytes. The typical fastpath is a single successful setbit. Freeing is O(1).",
            " *",
            " * Pid namespaces:",
            " *    (C) 2007 Pavel Emelyanov <xemul@openvz.org>, OpenVZ, SWsoft Inc.",
            " *    (C) 2007 Sukadev Bhattiprolu <sukadev@us.ibm.com>, IBM",
            " *     Many thanks to Oleg Nesterov for comments and help",
            " *",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/rculist.h>",
            "#include <linux/memblock.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/refcount.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/idr.h>",
            "#include <linux/pidfs.h>",
            "#include <linux/seqlock.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/pidfd.h>",
            "",
            "struct pid init_struct_pid = {",
            "\t.count\t\t= REFCOUNT_INIT(1),",
            "\t.tasks\t\t= {",
            "\t\t{ .first = NULL },",
            "\t\t{ .first = NULL },",
            "\t\t{ .first = NULL },",
            "\t},",
            "\t.level\t\t= 0,",
            "\t.numbers\t= { {",
            "\t\t.nr\t\t= 0,",
            "\t\t.ns\t\t= &init_pid_ns,",
            "\t}, }",
            "};",
            "",
            "int pid_max = PID_MAX_DEFAULT;",
            "",
            "int pid_max_min = RESERVED_PIDS + 1;",
            "int pid_max_max = PID_MAX_LIMIT;",
            "",
            "/*",
            " * PID-map pages start out as NULL, they get allocated upon",
            " * first use and are never deallocated. This way a low pid_max",
            " * value does not cause lots of bitmaps to be allocated, but",
            " * the scheme scales to up to 4 million PIDs, runtime.",
            " */",
            "struct pid_namespace init_pid_ns = {",
            "\t.ns.count = REFCOUNT_INIT(2),",
            "\t.idr = IDR_INIT(init_pid_ns.idr),",
            "\t.pid_allocated = PIDNS_ADDING,",
            "\t.level = 0,",
            "\t.child_reaper = &init_task,",
            "\t.user_ns = &init_user_ns,",
            "\t.ns.inum = PROC_PID_INIT_INO,",
            "#ifdef CONFIG_PID_NS",
            "\t.ns.ops = &pidns_operations,",
            "#endif",
            "#if defined(CONFIG_SYSCTL) && defined(CONFIG_MEMFD_CREATE)",
            "\t.memfd_noexec_scope = MEMFD_NOEXEC_SCOPE_EXEC,",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_pid_ns);",
            "",
            "/*",
            " * Note: disable interrupts while the pidmap_lock is held as an",
            " * interrupt might come in and do read_lock(&tasklist_lock).",
            " *",
            " * If we don't disable interrupts there is a nasty deadlock between",
            " * detach_pid()->free_pid() and another cpu that does",
            " * spin_lock(&pidmap_lock) followed by an interrupt routine that does",
            " * read_lock(&tasklist_lock);",
            " *",
            " * After we clean up the tasklist_lock and know there are no",
            " * irq handlers that take it we can leave the interrupts enabled.",
            " * For now it is easier to be safe than to prove it can't happen.",
            " */",
            "",
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);",
            "seqcount_spinlock_t pidmap_lock_seq = SEQCNT_SPINLOCK_ZERO(pidmap_lock_seq, &pidmap_lock);",
            ""
          ],
          "function_name": null,
          "description": "定义了PID命名空间和PID结构体的初始状态，包括全局PID最大值限制、PID映射锁及序列化机制，用于支持多层级PID分配和命名空间隔离。",
          "similarity": 0.5375726222991943
        }
      ]
    }
  ]
}