{
  "query": "profiling tools",
  "timestamp": "2025-12-26 01:39:32",
  "retrieved_files": [
    {
      "source_file": "kernel/profile.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:36:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `profile.c`\n\n---\n\n# profile.c 技术文档\n\n## 文件概述\n\n`profile.c` 是 Linux 内核中实现简单性能剖析（profiling）功能的核心文件。它管理一个直接映射的剖析命中计数缓冲区，支持可配置的分辨率、限制剖析所用的 CPU 集合，并可通过内核启动参数在基于 CPU 时间的剖析和基于 `schedule()` 调用的剖析之间切换。该文件主要用于内核级性能分析，帮助开发者了解内核代码的执行热点。\n\n## 核心功能\n\n### 主要全局变量\n- `prof_buffer`：指向剖析命中计数缓冲区的原子计数器数组\n- `prof_len`：剖析缓冲区长度（以槽位计）\n- `prof_shift`：地址映射的位移量，决定剖析粒度\n- `prof_on`：剖析模式标志（`CPU_PROFILING`、`SCHED_PROFILING` 或 `KVM_PROFILING`）\n\n### 主要函数\n- `profile_setup(char *str)`：解析内核命令行参数 `profile=`，初始化剖析模式和粒度\n- `profile_init(void)`：分配并初始化全局剖析缓冲区\n- `do_profile_hits(int type, void *__pc, unsigned int nr_hits)`：记录剖析命中，使用 per-CPU 哈希表缓冲以减少全局原子操作\n- `profile_flip_buffers(void)`：在 SMP 系统中翻转 per-CPU 缓冲区并将数据合并到全局缓冲区\n- `profile_discard_flip_buffers(void)`：丢弃当前 per-CPU 缓冲区内容\n- `profile_prepare_cpu(unsigned int cpu)` / `profile_dead_cpu(unsigned int cpu)`：CPU 热插拔时的 per-CPU 资源管理\n\n### 数据结构\n- `struct profile_hit`：per-CPU 哈希表条目，包含程序计数器（`pc`）和命中次数（`hits`）\n- per-CPU 变量 `cpu_profile_hits[2]`：每个 CPU 维护两个哈希表用于缓冲\n- per-CPU 变量 `cpu_profile_flip`：指示当前使用的哈希表索引（0 或 1）\n\n## 关键实现\n\n### 剖析缓冲区映射\n- 仅对内核文本段（`_stext` 到 `_etext`）进行剖析\n- 程序计数器通过右移 `prof_shift` 位映射到缓冲区索引：`index = (pc - _stext) >> prof_shift`\n- `prof_shift` 越大，剖析粒度越粗，缓冲区越小\n\n### SMP 优化：Per-CPU 哈希缓冲\n- 为避免频繁的全局原子操作导致的缓存行竞争和中断活锁问题，每个 CPU 维护两个开放寻址哈希表\n- 哈希表大小为一页（`NR_PROFILE_HIT = PAGE_SIZE / sizeof(struct profile_hit)`）\n- 使用双缓冲机制：当需要读取剖析数据时，通过 IPI 通知所有 CPU 翻转缓冲区，然后将旧缓冲区内容原子地累加到全局 `prof_buffer`\n\n### 哈希算法\n- 主哈希：`primary = (pc & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT`\n- 次哈希（用于探测）：`secondary = (~(pc << 1) & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT`\n- 每个哈希桶包含 `PROFILE_GRPSZ = 8` 个连续条目（`PROFILE_GRPSHIFT = 3`）\n- 哈希表满时，直接将当前命中和所有缓冲命中写入全局缓冲区并清空\n\n### 内存分配策略\n- `profile_init()` 尝试三种内存分配方式（按优先级）：\n  1. `kzalloc()`：连续内核内存\n  2. `alloc_pages_exact()`：精确页分配\n  3. `vzalloc()`：虚拟连续内存（适用于大缓冲区）\n\n## 依赖关系\n\n### 头文件依赖\n- `<linux/profile.h>`：剖析功能的公共接口定义\n- `<asm/sections.h>`：获取 `_stext` 和 `_etext` 符号\n- `<asm/irq_regs.h>` / `<asm/ptrace.h>`：获取当前执行上下文的程序计数器\n- `<linux/sched/stat.h>`：调度器统计相关功能\n- 其他通用内核头文件（内存管理、CPU 掩码、互斥锁等）\n\n### 配置依赖\n- `CONFIG_PROFILING`：必须启用才能编译此文件\n- `CONFIG_SMP && CONFIG_PROC_FS`：启用 per-CPU 哈希缓冲优化（否则使用简单全局原子操作）\n- 架构相关代码需提供 `_stext`/`_etext` 符号和 `profile_tick()` 等钩子\n\n### 外部接口\n- `EXPORT_SYMBOL_GPL(prof_on)`：供其他模块检查剖析是否启用\n- 通过 `__setup(\"profile=\", profile_setup)` 注册内核参数处理函数\n- 依赖架构代码在适当位置（如时钟中断、调度点）调用 `profile_hit()` 或类似函数\n\n## 使用场景\n\n### 内核性能剖析\n- **CPU 剖析**：通过 `profile=shift` 启用，记录时钟中断时的程序计数器，用于分析 CPU 时间分布\n- **调度器剖析**：通过 `profile=schedule` 启用，在每次调用 `schedule()` 时记录上下文切换位置\n- **KVM 剖析**：通过 `profile=kvm` 启用，用于虚拟化场景的性能分析\n\n### 开发与调试\n- 内核开发者使用 `/proc/profile`（需 `CONFIG_PROC_FS`）读取剖析数据\n- 用于识别内核热点函数、优化关键路径\n- 在实时系统中分析中断延迟和调度行为\n\n### 运行时控制\n- 剖析模式在启动时通过内核命令行参数确定，运行时不可更改\n- 支持在多核系统上高效运行，避免传统剖析方法在高负载下的性能退化\n- 适用于长时间运行的性能监控，哈希缓冲机制显著降低剖析开销",
      "similarity": 0.5616834163665771,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/profile.c",
          "start_line": 326,
          "end_line": 397,
          "content": [
            "static ssize_t",
            "read_profile(struct file *file, char __user *buf, size_t count, loff_t *ppos)",
            "{",
            "\tunsigned long p = *ppos;",
            "\tssize_t read;",
            "\tchar *pnt;",
            "\tunsigned long sample_step = 1UL << prof_shift;",
            "",
            "\tprofile_flip_buffers();",
            "\tif (p >= (prof_len+1)*sizeof(unsigned int))",
            "\t\treturn 0;",
            "\tif (count > (prof_len+1)*sizeof(unsigned int) - p)",
            "\t\tcount = (prof_len+1)*sizeof(unsigned int) - p;",
            "\tread = 0;",
            "",
            "\twhile (p < sizeof(unsigned int) && count > 0) {",
            "\t\tif (put_user(*((char *)(&sample_step)+p), buf))",
            "\t\t\treturn -EFAULT;",
            "\t\tbuf++; p++; count--; read++;",
            "\t}",
            "\tpnt = (char *)prof_buffer + p - sizeof(atomic_t);",
            "\tif (copy_to_user(buf, (void *)pnt, count))",
            "\t\treturn -EFAULT;",
            "\tread += count;",
            "\t*ppos += read;",
            "\treturn read;",
            "}",
            "int __weak setup_profiling_timer(unsigned mult)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static ssize_t write_profile(struct file *file, const char __user *buf,",
            "\t\t\t     size_t count, loff_t *ppos)",
            "{",
            "#ifdef CONFIG_SMP",
            "\tif (count == sizeof(int)) {",
            "\t\tunsigned int multiplier;",
            "",
            "\t\tif (copy_from_user(&multiplier, buf, sizeof(int)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (setup_profiling_timer(multiplier))",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "#endif",
            "\tprofile_discard_flip_buffers();",
            "\tmemset(prof_buffer, 0, prof_len * sizeof(atomic_t));",
            "\treturn count;",
            "}",
            "int __ref create_proc_profile(void)",
            "{",
            "\tstruct proc_dir_entry *entry;",
            "\tint err = 0;",
            "",
            "\tif (!prof_on)",
            "\t\treturn 0;",
            "#ifdef CONFIG_SMP",
            "\terr = cpuhp_setup_state(CPUHP_PROFILE_PREPARE, \"PROFILE_PREPARE\",",
            "\t\t\t\tprofile_prepare_cpu, profile_dead_cpu);",
            "\tif (err)",
            "\t\treturn err;",
            "#endif",
            "\tentry = proc_create(\"profile\", S_IWUSR | S_IRUGO,",
            "\t\t\t    NULL, &profile_proc_ops);",
            "\tif (entry)",
            "\t\tproc_set_size(entry, (1 + prof_len) * sizeof(atomic_t));",
            "#ifdef CONFIG_SMP",
            "\telse",
            "\t\tcpuhp_remove_state(CPUHP_PROFILE_PREPARE);",
            "#endif",
            "\treturn err;",
            "}"
          ],
          "function_name": "read_profile, setup_profiling_timer, write_profile, create_proc_profile",
          "description": "暴露性能数据读写接口，包含/proc/profile文件节点创建与维护，支持用户态读取统计结果、重置计数器及动态调整采样率参数的控制操作。",
          "similarity": 0.5766698718070984
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/profile.c",
          "start_line": 56,
          "end_line": 160,
          "content": [
            "int profile_setup(char *str)",
            "{",
            "\tstatic const char schedstr[] = \"schedule\";",
            "\tstatic const char kvmstr[] = \"kvm\";",
            "\tconst char *select = NULL;",
            "\tint par;",
            "",
            "\tif (!strncmp(str, schedstr, strlen(schedstr))) {",
            "\t\tprof_on = SCHED_PROFILING;",
            "\t\tselect = schedstr;",
            "\t} else if (!strncmp(str, kvmstr, strlen(kvmstr))) {",
            "\t\tprof_on = KVM_PROFILING;",
            "\t\tselect = kvmstr;",
            "\t} else if (get_option(&str, &par)) {",
            "\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);",
            "\t\tprof_on = CPU_PROFILING;",
            "\t\tpr_info(\"kernel profiling enabled (shift: %u)\\n\",",
            "\t\t\tprof_shift);",
            "\t}",
            "",
            "\tif (select) {",
            "\t\tif (str[strlen(select)] == ',')",
            "\t\t\tstr += strlen(select) + 1;",
            "\t\tif (get_option(&str, &par))",
            "\t\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);",
            "\t\tpr_info(\"kernel %s profiling enabled (shift: %u)\\n\",",
            "\t\t\tselect, prof_shift);",
            "\t}",
            "",
            "\treturn 1;",
            "}",
            "int __ref profile_init(void)",
            "{",
            "\tint buffer_bytes;",
            "\tif (!prof_on)",
            "\t\treturn 0;",
            "",
            "\t/* only text is profiled */",
            "\tprof_len = (_etext - _stext) >> prof_shift;",
            "",
            "\tif (!prof_len) {",
            "\t\tpr_warn(\"profiling shift: %u too large\\n\", prof_shift);",
            "\t\tprof_on = 0;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbuffer_bytes = prof_len*sizeof(atomic_t);",
            "",
            "\tprof_buffer = kzalloc(buffer_bytes, GFP_KERNEL|__GFP_NOWARN);",
            "\tif (prof_buffer)",
            "\t\treturn 0;",
            "",
            "\tprof_buffer = alloc_pages_exact(buffer_bytes,",
            "\t\t\t\t\tGFP_KERNEL|__GFP_ZERO|__GFP_NOWARN);",
            "\tif (prof_buffer)",
            "\t\treturn 0;",
            "",
            "\tprof_buffer = vzalloc(buffer_bytes);",
            "\tif (prof_buffer)",
            "\t\treturn 0;",
            "",
            "\treturn -ENOMEM;",
            "}",
            "static void __profile_flip_buffers(void *unused)",
            "{",
            "\tint cpu = smp_processor_id();",
            "",
            "\tper_cpu(cpu_profile_flip, cpu) = !per_cpu(cpu_profile_flip, cpu);",
            "}",
            "static void profile_flip_buffers(void)",
            "{",
            "\tint i, j, cpu;",
            "",
            "\tmutex_lock(&profile_flip_mutex);",
            "\tj = per_cpu(cpu_profile_flip, get_cpu());",
            "\tput_cpu();",
            "\ton_each_cpu(__profile_flip_buffers, NULL, 1);",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];",
            "\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {",
            "\t\t\tif (!hits[i].hits) {",
            "\t\t\t\tif (hits[i].pc)",
            "\t\t\t\t\thits[i].pc = 0;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);",
            "\t\t\thits[i].hits = hits[i].pc = 0;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&profile_flip_mutex);",
            "}",
            "static void profile_discard_flip_buffers(void)",
            "{",
            "\tint i, cpu;",
            "",
            "\tmutex_lock(&profile_flip_mutex);",
            "\ti = per_cpu(cpu_profile_flip, get_cpu());",
            "\tput_cpu();",
            "\ton_each_cpu(__profile_flip_buffers, NULL, 1);",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];",
            "\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));",
            "\t}",
            "\tmutex_unlock(&profile_flip_mutex);",
            "}"
          ],
          "function_name": "profile_setup, profile_init, __profile_flip_buffers, profile_flip_buffers, profile_discard_flip_buffers",
          "description": "实现性能分析参数解析、缓冲区初始化及双缓冲切换逻辑，通过原子操作和互斥锁协调多CPU间的缓冲区翻转与数据聚合过程。",
          "similarity": 0.4640032649040222
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/profile.c",
          "start_line": 200,
          "end_line": 302,
          "content": [
            "static void do_profile_hits(int type, void *__pc, unsigned int nr_hits)",
            "{",
            "\tunsigned long primary, secondary, flags, pc = (unsigned long)__pc;",
            "\tint i, j, cpu;",
            "\tstruct profile_hit *hits;",
            "",
            "\tpc = min((pc - (unsigned long)_stext) >> prof_shift, prof_len - 1);",
            "\ti = primary = (pc & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;",
            "\tsecondary = (~(pc << 1) & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;",
            "\tcpu = get_cpu();",
            "\thits = per_cpu(cpu_profile_hits, cpu)[per_cpu(cpu_profile_flip, cpu)];",
            "\tif (!hits) {",
            "\t\tput_cpu();",
            "\t\treturn;",
            "\t}",
            "\t/*",
            "\t * We buffer the global profiler buffer into a per-CPU",
            "\t * queue and thus reduce the number of global (and possibly",
            "\t * NUMA-alien) accesses. The write-queue is self-coalescing:",
            "\t */",
            "\tlocal_irq_save(flags);",
            "\tdo {",
            "\t\tfor (j = 0; j < PROFILE_GRPSZ; ++j) {",
            "\t\t\tif (hits[i + j].pc == pc) {",
            "\t\t\t\thits[i + j].hits += nr_hits;",
            "\t\t\t\tgoto out;",
            "\t\t\t} else if (!hits[i + j].hits) {",
            "\t\t\t\thits[i + j].pc = pc;",
            "\t\t\t\thits[i + j].hits = nr_hits;",
            "\t\t\t\tgoto out;",
            "\t\t\t}",
            "\t\t}",
            "\t\ti = (i + secondary) & (NR_PROFILE_HIT - 1);",
            "\t} while (i != primary);",
            "",
            "\t/*",
            "\t * Add the current hit(s) and flush the write-queue out",
            "\t * to the global buffer:",
            "\t */",
            "\tatomic_add(nr_hits, &prof_buffer[pc]);",
            "\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {",
            "\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);",
            "\t\thits[i].pc = hits[i].hits = 0;",
            "\t}",
            "out:",
            "\tlocal_irq_restore(flags);",
            "\tput_cpu();",
            "}",
            "static int profile_dead_cpu(unsigned int cpu)",
            "{",
            "\tstruct page *page;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < 2; i++) {",
            "\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {",
            "\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);",
            "\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;",
            "\t\t\t__free_page(page);",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "static int profile_prepare_cpu(unsigned int cpu)",
            "{",
            "\tint i, node = cpu_to_mem(cpu);",
            "\tstruct page *page;",
            "",
            "\tper_cpu(cpu_profile_flip, cpu) = 0;",
            "",
            "\tfor (i = 0; i < 2; i++) {",
            "\t\tif (per_cpu(cpu_profile_hits, cpu)[i])",
            "\t\t\tcontinue;",
            "",
            "\t\tpage = __alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);",
            "\t\tif (!page) {",
            "\t\t\tprofile_dead_cpu(cpu);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "\t\tper_cpu(cpu_profile_hits, cpu)[i] = page_address(page);",
            "",
            "\t}",
            "\treturn 0;",
            "}",
            "static void do_profile_hits(int type, void *__pc, unsigned int nr_hits)",
            "{",
            "\tunsigned long pc;",
            "\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;",
            "\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);",
            "}",
            "void profile_hits(int type, void *__pc, unsigned int nr_hits)",
            "{",
            "\tif (prof_on != type || !prof_buffer)",
            "\t\treturn;",
            "\tdo_profile_hits(type, __pc, nr_hits);",
            "}",
            "void profile_tick(int type)",
            "{",
            "\tstruct pt_regs *regs = get_irq_regs();",
            "",
            "\t/* This is the old kernel-only legacy profiling */",
            "\tif (!user_mode(regs))",
            "\t\tprofile_hit(type, (void *)profile_pc(regs));",
            "}"
          ],
          "function_name": "do_profile_hits, profile_dead_cpu, profile_prepare_cpu, do_profile_hits, profile_hits, profile_tick",
          "description": "提供性能事件记录核心逻辑，采用开放寻址哈希表缓冲热点指令地址计数，在CPU准备/死亡回调中管理缓存资源，最终通过原子操作更新全局统计缓冲区。",
          "similarity": 0.43146657943725586
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/profile.c",
          "start_line": 1,
          "end_line": 55,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/profile.c",
            " *  Simple profiling. Manages a direct-mapped profile hit count buffer,",
            " *  with configurable resolution, support for restricting the cpus on",
            " *  which profiling is done, and switching between cpu time and",
            " *  schedule() calls via kernel command line parameters passed at boot.",
            " *",
            " *  Scheduler profiling support, Arjan van de Ven and Ingo Molnar,",
            " *\tRed Hat, July 2004",
            " *  Consolidation of architecture support code for profiling,",
            " *\tNadia Yvette Chambers, Oracle, July 2004",
            " *  Amortized hit count accounting via per-cpu open-addressed hashtables",
            " *\tto resolve timer interrupt livelocks, Nadia Yvette Chambers,",
            " *\tOracle, 2004",
            " */",
            "",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/memblock.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/stat.h>",
            "",
            "#include <asm/sections.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/ptrace.h>",
            "",
            "struct profile_hit {",
            "\tu32 pc, hits;",
            "};",
            "#define PROFILE_GRPSHIFT\t3",
            "#define PROFILE_GRPSZ\t\t(1 << PROFILE_GRPSHIFT)",
            "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))",
            "#define NR_PROFILE_GRP\t\t(NR_PROFILE_HIT/PROFILE_GRPSZ)",
            "",
            "static atomic_t *prof_buffer;",
            "static unsigned long prof_len;",
            "static unsigned short int prof_shift;",
            "",
            "int prof_on __read_mostly;",
            "EXPORT_SYMBOL_GPL(prof_on);",
            "",
            "#if defined(CONFIG_SMP) && defined(CONFIG_PROC_FS)",
            "static DEFINE_PER_CPU(struct profile_hit *[2], cpu_profile_hits);",
            "static DEFINE_PER_CPU(int, cpu_profile_flip);",
            "static DEFINE_MUTEX(profile_flip_mutex);",
            "#endif /* CONFIG_SMP */",
            ""
          ],
          "function_name": null,
          "description": "定义内核性能分析模块的基础结构，包含全局缓冲区指针、长度、位移参数及启用标志，支持SMP环境下基于CPU的哈希表缓存和切换机制。",
          "similarity": 0.42823898792266846
        }
      ]
    },
    {
      "source_file": "kernel/trace/fprobe.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:02:19\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\fprobe.c`\n\n---\n\n# `trace/fprobe.c` 技术文档\n\n## 1. 文件概述\n\n`fprobe.c` 实现了 Linux 内核中 **fprobe**（Function Probe）机制，它是对 **ftrace** 框架的轻量级封装，用于在函数入口（entry）和/或出口（exit）处动态插入探针回调。  \nfprobe 支持两种注册方式：基于符号名（支持通配符过滤）或直接基于函数地址。若配置了退出处理函数（`exit_handler`），则通过 `rethook` 机制自动在函数返回时触发回调。  \n该模块特别适用于需要低开销、高灵活性的函数级动态追踪场景，并可与 kprobes 共享回调上下文。\n\n---\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct fprobe`**  \n  用户定义的探针控制结构，包含：\n  - `entry_handler`：函数入口回调\n  - `exit_handler`：函数出口回调（可选）\n  - `rethook`：用于管理函数返回钩子的结构\n  - `ops`：关联的 `ftrace_ops`，用于注册到 ftrace 框架\n  - `nmissed`：因资源不足或递归等原因错过的探针调用计数\n  - `nr_maxactive`：用户指定的最大并发返回钩子数量\n  - `entry_data_size`：用户可在入口回调中分配的私有数据大小\n\n- **`struct fprobe_rethook_node`**  \n  为每个被探测函数调用实例分配的节点，用于在入口和出口之间传递上下文：\n  - `node`：嵌入的 `rethook_node`\n  - `entry_ip` / `entry_parent_ip`：记录入口时的指令指针和调用者地址\n  - `data[]`：变长数组，用于存储用户自定义的入口数据\n\n### 主要函数\n\n- **`register_fprobe()`**  \n  通过符号通配符模式注册 fprobe，支持正向过滤（`filter`）和反向排除（`notfilter`）。\n\n- **`register_fprobe_ips()`**  \n  通过一组已知的 ftrace 位置地址（通常是符号地址 + 架构偏移）直接注册 fprobe。\n\n- **`register_fprobe_syms()`**（代码截断，但可推断）  \n  通过符号名数组注册 fprobe，内部调用 `get_ftrace_locations()` 将符号转换为地址。\n\n- **`fprobe_handler()` / `fprobe_kprobe_handler()`**  \n  ftrace 入口回调函数。前者用于普通 fprobe，后者用于与 kprobes 共享上下文的场景，包含额外的 kprobe 递归检测。\n\n- **`fprobe_exit_handler()`**  \n  由 `rethook` 框架在函数返回时调用，执行用户定义的 `exit_handler`。\n\n- **`fprobe_init()` / `fprobe_init_rethook()`**  \n  初始化 fprobe 结构及其返回钩子资源池。\n\n- **`get_ftrace_locations()`**  \n  将符号名数组转换为对应的内核地址数组，供 `register_fprobe_ips()` 使用。\n\n---\n\n## 3. 关键实现\n\n### 递归防护机制\n- 所有入口和出口处理函数均使用 `ftrace_test_recursion_trylock()` / `unlock()` 防止在追踪路径中发生递归调用，避免死锁或栈溢出。\n- 在与 kprobes 共享模式下，额外检查 `kprobe_running()`，若已有 kprobe 处理中则跳过本次 fprobe 调用，确保上下文一致性。\n\n### 返回钩子（rethook）管理\n- 若用户提供了 `exit_handler`，则在初始化时预分配 `rethook_node` 池：\n  - 默认大小为 `num * num_possible_cpus() * 2`（`num` 为探测点数量）\n  - 用户可通过 `nr_maxactive` 覆盖默认值\n- 入口处理中，若 `entry_handler` 返回非零值，则立即回收 `rethook_node`（表示不追踪返回）；否则将其挂载到当前函数调用栈，等待返回时触发。\n\n### 符号解析与地址转换\n- `get_ftrace_locations()` 对符号名数组排序后调用 `ftrace_lookup_symbols()`，这是 ftrace 提供的标准符号解析接口。\n- 要求符号必须对应有效的 ftrace 可追踪位置（通常是函数开头的 `mcount`/`fentry` 桩）。\n\n### 错误处理与资源清理\n- 任何初始化失败（如内存分配、ftrace 注册失败）都会调用 `fprobe_fail_cleanup()` 释放已分配资源，包括 `rethook` 池和 ftrace 过滤器。\n\n---\n\n## 4. 依赖关系\n\n- **ftrace 核心框架**（`<linux/ftrace.h>`, `\"trace.h\"`）  \n  依赖 ftrace 的函数追踪、过滤、递归检测等基础设施。\n\n- **kprobes 子系统**（`<linux/kprobes.h>`）  \n  在共享模式下依赖 kprobes 的运行状态检测（`kprobe_running()`）和忙状态标记（`kprobe_busy_begin/end()`）。\n\n- **rethook 机制**（`<linux/rethook.h>`）  \n  用于实现函数返回钩子，是 exit_handler 的底层支撑。\n\n- **kallsyms**（`<linux/kallsyms.h>`）  \n  用于符号名到地址的解析（通过 `ftrace_lookup_symbols` 间接使用）。\n\n- **内存管理**（`<linux/slab.h>`）  \n  动态分配 `fprobe_rethook_node` 和地址数组。\n\n- **排序算法**（`<linux/sort.h>`）  \n  对符号名数组排序以满足 `ftrace_lookup_symbols` 的输入要求。\n\n---\n\n## 5. 使用场景\n\n- **动态函数追踪**：无需修改内核代码，即可在任意可追踪函数的入口/出口插入自定义逻辑（如性能分析、参数记录、行为监控）。\n- **低开销探针**：相比 kprobes，fprobe 基于 ftrace，开销更小，适用于高频函数。\n- **与 kprobes 协同工作**：通过 `fprobe_shared_with_kprobes()` 标志，允许 fprobe 与 kprobes 共享同一回调上下文，避免冲突。\n- **符号级批量探测**：支持通配符（如 `\"vfs_*\"`）一次性探测多个相关函数。\n- **精确地址探测**：适用于已知具体地址的场景（如 JIT 代码、模块符号解析后地址）。\n- **函数调用链分析**：结合 entry/exit handler，可构建完整的函数调用图和执行时间统计。",
      "similarity": 0.5168225765228271,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/fprobe.c",
          "start_line": 444,
          "end_line": 566,
          "content": [
            "static int fprobe_module_callback(struct notifier_block *nb,",
            "\t\t\t\t  unsigned long val, void *data)",
            "{",
            "\tstruct fprobe_addr_list alist = {.size = FPROBE_IPS_BATCH_INIT};",
            "\tstruct module *mod = data;",
            "\tint i;",
            "",
            "\tif (val != MODULE_STATE_GOING)",
            "\t\treturn NOTIFY_DONE;",
            "",
            "\talist.addrs = kcalloc(alist.size, sizeof(*alist.addrs), GFP_KERNEL);",
            "\t/* If failed to alloc memory, we can not remove ips from hash. */",
            "\tif (!alist.addrs)",
            "\t\treturn NOTIFY_DONE;",
            "",
            "\tmutex_lock(&fprobe_mutex);",
            "\tfor (i = 0; i < FPROBE_IP_TABLE_SIZE; i++)",
            "\t\tfprobe_remove_node_in_module(mod, &fprobe_ip_table[i], &alist);",
            "",
            "\tif (alist.index < alist.size && alist.index > 0)",
            "\t\tftrace_set_filter_ips(&fprobe_graph_ops.ops,",
            "\t\t\t\t      alist.addrs, alist.index, 1, 0);",
            "\tmutex_unlock(&fprobe_mutex);",
            "",
            "\tkfree(alist.addrs);",
            "",
            "\treturn NOTIFY_DONE;",
            "}",
            "static int __init init_fprobe_module(void)",
            "{",
            "\treturn register_module_notifier(&fprobe_module_nb);",
            "}",
            "static int symbols_cmp(const void *a, const void *b)",
            "{",
            "\tconst char **str_a = (const char **) a;",
            "\tconst char **str_b = (const char **) b;",
            "",
            "\treturn strcmp(*str_a, *str_b);",
            "}",
            "static int filter_match_callback(void *data, const char *name, unsigned long addr)",
            "{",
            "\tstruct filter_match_data *match = data;",
            "",
            "\tif (!glob_match(match->filter, name) ||",
            "\t    (match->notfilter && glob_match(match->notfilter, name)))",
            "\t\treturn 0;",
            "",
            "\tif (!ftrace_location(addr))",
            "\t\treturn 0;",
            "",
            "\tif (match->addrs) {",
            "\t\tstruct module *mod = __module_text_address(addr);",
            "",
            "\t\tif (mod && !try_module_get(mod))",
            "\t\t\treturn 0;",
            "",
            "\t\tmatch->mods[match->index] = mod;",
            "\t\tmatch->addrs[match->index] = addr;",
            "\t}",
            "\tmatch->index++;",
            "\treturn match->index == match->size;",
            "}",
            "static int get_ips_from_filter(const char *filter, const char *notfilter,",
            "\t\t\t       unsigned long *addrs, struct module **mods,",
            "\t\t\t       size_t size)",
            "{",
            "\tstruct filter_match_data match = { .filter = filter, .notfilter = notfilter,",
            "\t\t.index = 0, .size = size, .addrs = addrs, .mods = mods};",
            "\tint ret;",
            "",
            "\tif (addrs && !mods)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = kallsyms_on_each_symbol(filter_match_callback, &match);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\tif (IS_ENABLED(CONFIG_MODULES)) {",
            "\t\tret = module_kallsyms_on_each_symbol(NULL, filter_match_callback, &match);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\treturn match.index ?: -ENOENT;",
            "}",
            "static void fprobe_fail_cleanup(struct fprobe *fp)",
            "{",
            "\tkfree(fp->hlist_array);",
            "\tfp->hlist_array = NULL;",
            "}",
            "static int fprobe_init(struct fprobe *fp, unsigned long *addrs, int num)",
            "{",
            "\tstruct fprobe_hlist *hlist_array;",
            "\tunsigned long addr;",
            "\tint size, i;",
            "",
            "\tif (!fp || !addrs || num <= 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tsize = ALIGN(fp->entry_data_size, sizeof(long));",
            "\tif (size > MAX_FPROBE_DATA_SIZE)",
            "\t\treturn -E2BIG;",
            "\tfp->entry_data_size = size;",
            "",
            "\thlist_array = kzalloc(struct_size(hlist_array, array, num), GFP_KERNEL);",
            "\tif (!hlist_array)",
            "\t\treturn -ENOMEM;",
            "",
            "\tfp->nmissed = 0;",
            "",
            "\thlist_array->size = num;",
            "\tfp->hlist_array = hlist_array;",
            "\thlist_array->fp = fp;",
            "\tfor (i = 0; i < num; i++) {",
            "\t\thlist_array->array[i].fp = fp;",
            "\t\taddr = ftrace_location(addrs[i]);",
            "\t\tif (!addr) {",
            "\t\t\tfprobe_fail_cleanup(fp);",
            "\t\t\treturn -ENOENT;",
            "\t\t}",
            "\t\thlist_array->array[i].addr = addr;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "fprobe_module_callback, init_fprobe_module, symbols_cmp, filter_match_callback, get_ips_from_filter, fprobe_fail_cleanup, fprobe_init",
          "description": "提供模块通知回调、符号匹配过滤及探针初始化功能，包含地址解析、内存分配及失败清理机制，支持根据过滤规则动态获取目标地址。",
          "similarity": 0.5188966393470764
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/fprobe.c",
          "start_line": 68,
          "end_line": 169,
          "content": [
            "static void insert_fprobe_node(struct fprobe_hlist_node *node)",
            "{",
            "\tunsigned long ip = node->addr;",
            "\tstruct fprobe_hlist_node *next;",
            "\tstruct hlist_head *head;",
            "",
            "\tlockdep_assert_held(&fprobe_mutex);",
            "",
            "\tnext = find_first_fprobe_node(ip);",
            "\tif (next) {",
            "\t\thlist_add_before_rcu(&node->hlist, &next->hlist);",
            "\t\treturn;",
            "\t}",
            "\thead = &fprobe_ip_table[hash_ptr((void *)ip, FPROBE_IP_HASH_BITS)];",
            "\thlist_add_head_rcu(&node->hlist, head);",
            "}",
            "static bool delete_fprobe_node(struct fprobe_hlist_node *node)",
            "{",
            "\tlockdep_assert_held(&fprobe_mutex);",
            "",
            "\t/* Avoid double deleting */",
            "\tif (READ_ONCE(node->fp) != NULL) {",
            "\t\tWRITE_ONCE(node->fp, NULL);",
            "\t\thlist_del_rcu(&node->hlist);",
            "\t}",
            "\treturn !!find_first_fprobe_node(node->addr);",
            "}",
            "static bool is_fprobe_still_exist(struct fprobe *fp)",
            "{",
            "\tstruct hlist_head *head;",
            "\tstruct fprobe_hlist *fph;",
            "",
            "\thead = &fprobe_table[hash_ptr(fp, FPROBE_HASH_BITS)];",
            "\thlist_for_each_entry_rcu(fph, head, hlist,",
            "\t\t\t\t lockdep_is_held(&fprobe_mutex)) {",
            "\t\tif (fph->fp == fp)",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static int add_fprobe_hash(struct fprobe *fp)",
            "{",
            "\tstruct fprobe_hlist *fph = fp->hlist_array;",
            "\tstruct hlist_head *head;",
            "",
            "\tlockdep_assert_held(&fprobe_mutex);",
            "",
            "\tif (WARN_ON_ONCE(!fph))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (is_fprobe_still_exist(fp))",
            "\t\treturn -EEXIST;",
            "",
            "\thead = &fprobe_table[hash_ptr(fp, FPROBE_HASH_BITS)];",
            "\thlist_add_head_rcu(&fp->hlist_array->hlist, head);",
            "\treturn 0;",
            "}",
            "static int del_fprobe_hash(struct fprobe *fp)",
            "{",
            "\tstruct fprobe_hlist *fph = fp->hlist_array;",
            "",
            "\tlockdep_assert_held(&fprobe_mutex);",
            "",
            "\tif (WARN_ON_ONCE(!fph))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!is_fprobe_still_exist(fp))",
            "\t\treturn -ENOENT;",
            "",
            "\tfph->fp = NULL;",
            "\thlist_del_rcu(&fph->hlist);",
            "\treturn 0;",
            "}",
            "static inline bool write_fprobe_header(unsigned long *stack,",
            "\t\t\t\t\tstruct fprobe *fp, unsigned int size_words)",
            "{",
            "\tstruct __fprobe_header *fph = (struct __fprobe_header *)stack;",
            "",
            "\tif (WARN_ON_ONCE(size_words > MAX_FPROBE_DATA_SIZE_WORD))",
            "\t\treturn false;",
            "",
            "\tfph->fp = fp;",
            "\tfph->size_words = size_words;",
            "\treturn true;",
            "}",
            "static inline void read_fprobe_header(unsigned long *stack,",
            "\t\t\t\t\tstruct fprobe **fp, unsigned int *size_words)",
            "{",
            "\tstruct __fprobe_header *fph = (struct __fprobe_header *)stack;",
            "",
            "\t*fp = fph->fp;",
            "\t*size_words = fph->size_words;",
            "}",
            "static inline int __fprobe_handler(unsigned long ip, unsigned long parent_ip,",
            "\t\t\t\t   struct fprobe *fp, struct ftrace_regs *fregs,",
            "\t\t\t\t   void *data)",
            "{",
            "\tif (!fp->entry_handler)",
            "\t\treturn 0;",
            "",
            "\treturn fp->entry_handler(fp, ip, parent_ip, fregs, data);",
            "}"
          ],
          "function_name": "insert_fprobe_node, delete_fprobe_node, is_fprobe_still_exist, add_fprobe_hash, del_fprobe_hash, write_fprobe_header, read_fprobe_header, __fprobe_handler",
          "description": "实现fprobe节点的增删查操作，包含哈希表操作、探针状态检查及头部信息读写，支持共享kprobes的回调处理逻辑。",
          "similarity": 0.5001914501190186
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/fprobe.c",
          "start_line": 633,
          "end_line": 752,
          "content": [
            "int register_fprobe(struct fprobe *fp, const char *filter, const char *notfilter)",
            "{",
            "\tunsigned long *addrs __free(kfree) = NULL;",
            "\tstruct module **mods __free(kfree) = NULL;",
            "\tint ret, num;",
            "",
            "\tif (!fp || !filter)",
            "\t\treturn -EINVAL;",
            "",
            "\tnum = get_ips_from_filter(filter, notfilter, NULL, NULL, FPROBE_IPS_MAX);",
            "\tif (num < 0)",
            "\t\treturn num;",
            "",
            "\taddrs = kcalloc(num, sizeof(*addrs), GFP_KERNEL);",
            "\tif (!addrs)",
            "\t\treturn -ENOMEM;",
            "",
            "\tmods = kcalloc(num, sizeof(*mods), GFP_KERNEL);",
            "\tif (!mods)",
            "\t\treturn -ENOMEM;",
            "",
            "\tret = get_ips_from_filter(filter, notfilter, addrs, mods, num);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tret = register_fprobe_ips(fp, addrs, ret);",
            "",
            "\tfor (int i = 0; i < num; i++) {",
            "\t\tif (mods[i])",
            "\t\t\tmodule_put(mods[i]);",
            "\t}",
            "\treturn ret;",
            "}",
            "int register_fprobe_ips(struct fprobe *fp, unsigned long *addrs, int num)",
            "{",
            "\tstruct fprobe_hlist *hlist_array;",
            "\tint ret, i;",
            "",
            "\tret = fprobe_init(fp, addrs, num);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tmutex_lock(&fprobe_mutex);",
            "",
            "\thlist_array = fp->hlist_array;",
            "\tret = fprobe_graph_add_ips(addrs, num);",
            "\tif (!ret) {",
            "\t\tadd_fprobe_hash(fp);",
            "\t\tfor (i = 0; i < hlist_array->size; i++)",
            "\t\t\tinsert_fprobe_node(&hlist_array->array[i]);",
            "\t}",
            "\tmutex_unlock(&fprobe_mutex);",
            "",
            "\tif (ret)",
            "\t\tfprobe_fail_cleanup(fp);",
            "",
            "\treturn ret;",
            "}",
            "int register_fprobe_syms(struct fprobe *fp, const char **syms, int num)",
            "{",
            "\tunsigned long *addrs;",
            "\tint ret;",
            "",
            "\tif (!fp || !syms || num <= 0)",
            "\t\treturn -EINVAL;",
            "",
            "\taddrs = get_ftrace_locations(syms, num);",
            "\tif (IS_ERR(addrs))",
            "\t\treturn PTR_ERR(addrs);",
            "",
            "\tret = register_fprobe_ips(fp, addrs, num);",
            "",
            "\tkfree(addrs);",
            "",
            "\treturn ret;",
            "}",
            "bool fprobe_is_registered(struct fprobe *fp)",
            "{",
            "\tif (!fp || !fp->hlist_array)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "int unregister_fprobe(struct fprobe *fp)",
            "{",
            "\tstruct fprobe_hlist *hlist_array;",
            "\tunsigned long *addrs = NULL;",
            "\tint ret = 0, i, count;",
            "",
            "\tmutex_lock(&fprobe_mutex);",
            "\tif (!fp || !is_fprobe_still_exist(fp)) {",
            "\t\tret = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\thlist_array = fp->hlist_array;",
            "\taddrs = kcalloc(hlist_array->size, sizeof(unsigned long), GFP_KERNEL);",
            "\tif (!addrs) {",
            "\t\tret = -ENOMEM;\t/* TODO: Fallback to one-by-one loop */",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Remove non-synonim ips from table and hash */",
            "\tcount = 0;",
            "\tfor (i = 0; i < hlist_array->size; i++) {",
            "\t\tif (!delete_fprobe_node(&hlist_array->array[i]))",
            "\t\t\taddrs[count++] = hlist_array->array[i].addr;",
            "\t}",
            "\tdel_fprobe_hash(fp);",
            "",
            "\tfprobe_graph_remove_ips(addrs, count);",
            "",
            "\tkfree_rcu(hlist_array, rcu);",
            "\tfp->hlist_array = NULL;",
            "",
            "out:",
            "\tmutex_unlock(&fprobe_mutex);",
            "",
            "\tkfree(addrs);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "register_fprobe, register_fprobe_ips, register_fprobe_syms, fprobe_is_registered, unregister_fprobe",
          "description": "该代码块实现了基于函数入口点的动态跟踪探针（fprobe）注册与管理，核心功能包括：  \n1. `register_fprobe`系列函数通过过滤器/符号名解析目标函数地址，调用`register_fprobe_ips`完成探针注册，涉及地址解析、哈希表维护及互斥锁保护；  \n2. `unregister_fprobe`负责安全移除探针，需注意上下文不完整（如`get_ips_from_filter`、`fprobe_init`等关键子函数未提供）；  \n3. 所有操作均通过`fprobe_hlist`结构组织探针节点，并利用RCU机制保障并发安全性。",
          "similarity": 0.48654019832611084
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/fprobe.c",
          "start_line": 310,
          "end_line": 418,
          "content": [
            "static void fprobe_return(struct ftrace_graph_ret *trace,",
            "\t\t\t  struct fgraph_ops *gops,",
            "\t\t\t  struct ftrace_regs *fregs)",
            "{",
            "\tunsigned long *fgraph_data = NULL;",
            "\tunsigned long ret_ip;",
            "\tstruct fprobe *fp;",
            "\tint size, curr;",
            "\tint size_words;",
            "",
            "\tfgraph_data = (unsigned long *)fgraph_retrieve_data(gops->idx, &size);",
            "\tif (WARN_ON_ONCE(!fgraph_data))",
            "\t\treturn;",
            "\tsize_words = SIZE_IN_LONG(size);",
            "\tret_ip = ftrace_regs_get_instruction_pointer(fregs);",
            "",
            "\tpreempt_disable_notrace();",
            "",
            "\tcurr = 0;",
            "\twhile (size_words > curr) {",
            "\t\tread_fprobe_header(&fgraph_data[curr], &fp, &size);",
            "\t\tif (!fp)",
            "\t\t\tbreak;",
            "\t\tcurr += FPROBE_HEADER_SIZE_IN_LONG;",
            "\t\tif (is_fprobe_still_exist(fp) && !fprobe_disabled(fp)) {",
            "\t\t\tif (WARN_ON_ONCE(curr + size > size_words))",
            "\t\t\t\tbreak;",
            "\t\t\tfp->exit_handler(fp, trace->func, ret_ip, fregs,",
            "\t\t\t\t\t size ? fgraph_data + curr : NULL);",
            "\t\t}",
            "\t\tcurr += size;",
            "\t}",
            "\tpreempt_enable_notrace();",
            "}",
            "static int fprobe_graph_add_ips(unsigned long *addrs, int num)",
            "{",
            "\tint ret;",
            "",
            "\tlockdep_assert_held(&fprobe_mutex);",
            "",
            "\tret = ftrace_set_filter_ips(&fprobe_graph_ops.ops, addrs, num, 0, 0);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (!fprobe_graph_active) {",
            "\t\tret = register_ftrace_graph(&fprobe_graph_ops);",
            "\t\tif (WARN_ON_ONCE(ret)) {",
            "\t\t\tftrace_free_filter(&fprobe_graph_ops.ops);",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t}",
            "\tfprobe_graph_active++;",
            "\treturn 0;",
            "}",
            "static void fprobe_graph_remove_ips(unsigned long *addrs, int num)",
            "{",
            "\tlockdep_assert_held(&fprobe_mutex);",
            "",
            "\tfprobe_graph_active--;",
            "\t/* Q: should we unregister it ? */",
            "\tif (!fprobe_graph_active)",
            "\t\tunregister_ftrace_graph(&fprobe_graph_ops);",
            "",
            "\tif (num)",
            "\t\tftrace_set_filter_ips(&fprobe_graph_ops.ops, addrs, num, 1, 0);",
            "}",
            "static int fprobe_addr_list_add(struct fprobe_addr_list *alist, unsigned long addr)",
            "{",
            "\tunsigned long *addrs;",
            "",
            "\tif (alist->index >= alist->size)",
            "\t\treturn -ENOMEM;",
            "",
            "\talist->addrs[alist->index++] = addr;",
            "\tif (alist->index < alist->size)",
            "\t\treturn 0;",
            "",
            "\t/* Expand the address list */",
            "\taddrs = kcalloc(alist->size * 2, sizeof(*addrs), GFP_KERNEL);",
            "\tif (!addrs)",
            "\t\treturn -ENOMEM;",
            "",
            "\tmemcpy(addrs, alist->addrs, alist->size * sizeof(*addrs));",
            "\talist->size *= 2;",
            "\tkfree(alist->addrs);",
            "\talist->addrs = addrs;",
            "",
            "\treturn 0;",
            "}",
            "static void fprobe_remove_node_in_module(struct module *mod, struct hlist_head *head,",
            "\t\t\t\t\tstruct fprobe_addr_list *alist)",
            "{",
            "\tstruct fprobe_hlist_node *node;",
            "\tint ret = 0;",
            "",
            "\thlist_for_each_entry_rcu(node, head, hlist,",
            "\t\t\t\t lockdep_is_held(&fprobe_mutex)) {",
            "\t\tif (!within_module(node->addr, mod))",
            "\t\t\tcontinue;",
            "\t\tif (delete_fprobe_node(node))",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * If failed to update alist, just continue to update hlist.",
            "\t\t * Therefore, at list user handler will not hit anymore.",
            "\t\t */",
            "\t\tif (!ret)",
            "\t\t\tret = fprobe_addr_list_add(alist, node->addr);",
            "\t}",
            "}"
          ],
          "function_name": "fprobe_return, fprobe_graph_add_ips, fprobe_graph_remove_ips, fprobe_addr_list_add, fprobe_remove_node_in_module",
          "description": "实现探针返回处理、地址列表动态管理及模块卸载时的清理逻辑，通过ftrace图形化跟踪接口控制探针激活状态。",
          "similarity": 0.47378697991371155
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/fprobe.c",
          "start_line": 198,
          "end_line": 306,
          "content": [
            "static inline int __fprobe_kprobe_handler(unsigned long ip, unsigned long parent_ip,",
            "\t\t\t\t\t  struct fprobe *fp, struct ftrace_regs *fregs,",
            "\t\t\t\t\t  void *data)",
            "{",
            "\tint ret;",
            "\t/*",
            "\t * This user handler is shared with other kprobes and is not expected to be",
            "\t * called recursively. So if any other kprobe handler is running, this will",
            "\t * exit as kprobe does. See the section 'Share the callbacks with kprobes'",
            "\t * in Documentation/trace/fprobe.rst for more information.",
            "\t */",
            "\tif (unlikely(kprobe_running())) {",
            "\t\tfp->nmissed++;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tkprobe_busy_begin();",
            "\tret = __fprobe_handler(ip, parent_ip, fp, fregs, data);",
            "\tkprobe_busy_end();",
            "\treturn ret;",
            "}",
            "static int fprobe_entry(struct ftrace_graph_ent *trace, struct fgraph_ops *gops,",
            "\t\t\tstruct ftrace_regs *fregs)",
            "{",
            "\tstruct fprobe_hlist_node *node, *first;",
            "\tunsigned long *fgraph_data = NULL;",
            "\tunsigned long func = trace->func;",
            "\tunsigned long ret_ip;",
            "\tint reserved_words;",
            "\tstruct fprobe *fp;",
            "\tint used, ret;",
            "",
            "\tif (WARN_ON_ONCE(!fregs))",
            "\t\treturn 0;",
            "",
            "\tfirst = node = find_first_fprobe_node(func);",
            "\tif (unlikely(!first))",
            "\t\treturn 0;",
            "",
            "\treserved_words = 0;",
            "\thlist_for_each_entry_from_rcu(node, hlist) {",
            "\t\tif (node->addr != func)",
            "\t\t\tbreak;",
            "\t\tfp = READ_ONCE(node->fp);",
            "\t\tif (!fp || !fp->exit_handler)",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * Since fprobe can be enabled until the next loop, we ignore the",
            "\t\t * fprobe's disabled flag in this loop.",
            "\t\t */",
            "\t\treserved_words +=",
            "\t\t\tFPROBE_HEADER_SIZE_IN_LONG + SIZE_IN_LONG(fp->entry_data_size);",
            "\t}",
            "\tnode = first;",
            "\tif (reserved_words) {",
            "\t\tfgraph_data = fgraph_reserve_data(gops->idx, reserved_words * sizeof(long));",
            "\t\tif (unlikely(!fgraph_data)) {",
            "\t\t\thlist_for_each_entry_from_rcu(node, hlist) {",
            "\t\t\t\tif (node->addr != func)",
            "\t\t\t\t\tbreak;",
            "\t\t\t\tfp = READ_ONCE(node->fp);",
            "\t\t\t\tif (fp && !fprobe_disabled(fp))",
            "\t\t\t\t\tfp->nmissed++;",
            "\t\t\t}",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * TODO: recursion detection has been done in the fgraph. Thus we need",
            "\t * to add a callback to increment missed counter.",
            "\t */",
            "\tret_ip = ftrace_regs_get_return_address(fregs);",
            "\tused = 0;",
            "\thlist_for_each_entry_from_rcu(node, hlist) {",
            "\t\tint data_size;",
            "\t\tvoid *data;",
            "",
            "\t\tif (node->addr != func)",
            "\t\t\tbreak;",
            "\t\tfp = READ_ONCE(node->fp);",
            "\t\tif (!fp || fprobe_disabled(fp))",
            "\t\t\tcontinue;",
            "",
            "\t\tdata_size = fp->entry_data_size;",
            "\t\tif (data_size && fp->exit_handler)",
            "\t\t\tdata = fgraph_data + used + FPROBE_HEADER_SIZE_IN_LONG;",
            "\t\telse",
            "\t\t\tdata = NULL;",
            "",
            "\t\tif (fprobe_shared_with_kprobes(fp))",
            "\t\t\tret = __fprobe_kprobe_handler(func, ret_ip, fp, fregs, data);",
            "\t\telse",
            "\t\t\tret = __fprobe_handler(func, ret_ip, fp, fregs, data);",
            "",
            "\t\t/* If entry_handler returns !0, nmissed is not counted but skips exit_handler. */",
            "\t\tif (!ret && fp->exit_handler) {",
            "\t\t\tint size_words = SIZE_IN_LONG(data_size);",
            "",
            "\t\t\tif (write_fprobe_header(&fgraph_data[used], fp, size_words))",
            "\t\t\t\tused += FPROBE_HEADER_SIZE_IN_LONG + size_words;",
            "\t\t}",
            "\t}",
            "\tif (used < reserved_words)",
            "\t\tmemset(fgraph_data + used, 0, reserved_words - used);",
            "",
            "\t/* If any exit_handler is set, data must be used. */",
            "\treturn used != 0;",
            "}"
          ],
          "function_name": "__fprobe_kprobe_handler, fprobe_entry",
          "description": "处理函数入口探针的执行流程，包括数据预留、头部写入及回调分发，通过fgraph机制管理探针数据并处理递归检测。",
          "similarity": 0.4573237895965576
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_events_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:18:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_events_filter.c`\n\n---\n\n# trace_events_filter.c 技术文档\n\n## 1. 文件概述\n\n`trace_events_filter.c` 是 Linux 内核中用于实现通用事件过滤（event filtering）功能的核心文件。它为 ftrace 事件跟踪系统提供了一套灵活的表达式解析和执行机制，允许用户通过逻辑表达式（支持 `&&`、`||`、`!` 等操作符）对跟踪事件进行动态过滤。该模块支持对事件字段进行数值比较、字符串匹配、位运算以及 CPU 掩码过滤等多种操作，广泛应用于性能分析、调试和系统监控场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct filter_pred`**  \n  表示一个过滤谓词（predicate），包含：\n  - 字段指针（`field`）\n  - 比较值（`val`, `val2`）\n  - 操作符（`op`，如 `==`, `<`, `&` 等）\n  - 谓词执行函数类型（`fn_num`）\n  - 正则表达式（`regex`）或 CPU 掩码（`mask`）\n  - 取反标志（`not`）\n\n- **`struct prog_entry`**  \n  表示过滤程序中的一个指令条目，用于构建基于跳转的执行逻辑：\n  - `pred`：关联的谓词\n  - `when_to_branch`：分支条件（0 或 1）\n  - `target`：跳转目标索引\n\n- **`struct filter_parse_error`**  \n  用于记录表达式解析过程中的错误类型和位置。\n\n- **`enum filter_op_ids` 和 `enum filter_pred_fn`**  \n  定义支持的操作符（如 `OP_EQ`, `OP_GT`）和谓词执行函数类型（如 `FILTER_PRED_FN_U64`, `FILTER_PRED_FN_STRING`）。\n\n- **错误码枚举（`FILT_ERR_*`）**  \n  定义了 20 余种解析和语义错误，如 `FIELD_NOT_FOUND`、`INVALID_OP`、`MISSING_QUOTE` 等。\n\n### 关键函数/逻辑\n\n- **`is_not()`**  \n  判断 `!` 是否表示逻辑取反（排除 `!=` 和 `!~` 的情况）。\n\n- **`update_preds()`**  \n  在构建过滤程序时动态更新跳转目标，用于处理 `&&` 和 `||` 的优先级和短路求值。\n\n- **`free_predicate()`**  \n  释放谓词结构及其关联资源（正则、CPU 掩码等）。\n\n- **表达式解析器框架**  \n  支持回调函数 `parse_pred_fn`，允许不同事件类型自定义谓词解析逻辑。\n\n## 3. 关键实现\n\n### 表达式解析与程序生成\n\n该文件实现了一个两阶段的逻辑表达式处理机制：\n\n1. **词法与语法解析**：将用户输入的字符串（如 `\"pid > 100 && comm == 'bash'\"`）解析为操作符、字段名和值的序列。\n2. **程序生成**：将逻辑表达式转换为线性“程序”（`prog_entry` 数组），通过条件跳转模拟 `&&`（短路与）和 `||`（短路或）的语义。\n\n例如，表达式 `a && !b || c` 被编译为类似以下的跳转逻辑：\n```text\neval a; if false goto L2\neval b; if true  goto L2\nreturn true\nL2: eval c; if false goto FAIL\nreturn true\nFAIL: return false\n```\n\n### 操作符优先级处理\n\n通过宏 `OPS` 定义操作符顺序，特别要求 `<=` 在 `<` 之前、`>=` 在 `>` 之前，以确保词法分析时长操作符优先匹配。\n\n### 取反逻辑（`!`）处理\n\n使用栈和 `invert` 标志跟踪当前作用域内的取反层数。每遇到一个 `!` 就翻转 `invert`，括号会将当前 `invert` 值压栈，确保作用域隔离。\n\n### 多类型谓词支持\n\n通过 `filter_pred_fn` 枚举区分不同数据类型的比较函数（如 8/16/32/64 位有无符号整数、字符串、CPU 掩码、函数指针等），实现类型安全的字段比较。\n\n### 错误报告机制\n\n提供详细的错误码和位置信息（`filter_parse_error`），便于用户调试无效过滤表达式。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `trace.h` / `trace_output.h`：ftrace 核心接口和事件定义\n  - `linux/slab.h`：内存分配（`kmalloc`/`kfree`）\n  - `linux/ctype.h`：字符处理\n  - `linux/perf_event.h`：与 perf 事件子系统集成\n  - `linux/uaccess.h`：用户空间数据访问\n\n- **模块依赖**：\n  - 依赖 ftrace 事件注册机制（`ftrace_event_field`）\n  - 与 `trace_events.c` 协同工作，提供过滤能力\n  - 被 perf 和 ftrace 用户接口（如 `/sys/kernel/debug/tracing/events/.../filter`）调用\n\n## 5. 使用场景\n\n- **动态事件过滤**：用户通过写入 `/sys/kernel/debug/tracing/events/<subsys>/<event>/filter` 设置过滤条件，仅记录满足条件的事件。\n- **全局过滤**：通过 `set_event_filter` 设置跨多个事件的统一过滤规则。\n- **性能分析**：在高负载系统中减少无关事件的记录开销，提升跟踪效率。\n- **调试特定行为**：例如 `filter='pid == 1234'` 仅跟踪指定进程的事件，或 `filter='latency > 1000'` 捕获高延迟操作。\n- **安全与审计**：结合字段值过滤实现细粒度的系统行为监控。",
      "similarity": 0.5152703523635864,
      "chunks": [
        {
          "chunk_id": 11,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2543,
          "end_line": 2647,
          "content": [
            "static int ftrace_function_set_filter_pred(struct filter_pred *pred,",
            "\t\t\t\t\t   struct function_filter_data *data)",
            "{",
            "\tint ret;",
            "",
            "\t/* Checking the node is valid for function trace. */",
            "\tret = ftrace_function_check_pred(pred);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn __ftrace_function_set_filter(pred->op == OP_EQ,",
            "\t\t\t\t\t    pred->regex->pattern,",
            "\t\t\t\t\t    pred->regex->len,",
            "\t\t\t\t\t    data);",
            "}",
            "static bool is_or(struct prog_entry *prog, int i)",
            "{",
            "\tint target;",
            "",
            "\t/*",
            "\t * Only \"||\" is allowed for function events, thus,",
            "\t * all true branches should jump to true, and any",
            "\t * false branch should jump to false.",
            "\t */",
            "\ttarget = prog[i].target + 1;",
            "\t/* True and false have NULL preds (all prog entries should jump to one */",
            "\tif (prog[target].pred)",
            "\t\treturn false;",
            "",
            "\t/* prog[target].target is 1 for TRUE, 0 for FALSE */",
            "\treturn prog[i].when_to_branch == prog[target].target;",
            "}",
            "static int ftrace_function_set_filter(struct perf_event *event,",
            "\t\t\t\t      struct event_filter *filter)",
            "{",
            "\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,",
            "\t\t\t\t\t\tlockdep_is_held(&event_mutex));",
            "\tstruct function_filter_data data = {",
            "\t\t.first_filter  = 1,",
            "\t\t.first_notrace = 1,",
            "\t\t.ops           = &event->ftrace_ops,",
            "\t};",
            "\tint i;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "",
            "\t\tif (!is_or(prog, i))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int ftrace_function_set_filter(struct perf_event *event,",
            "\t\t\t\t      struct event_filter *filter)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "int ftrace_profile_set_filter(struct perf_event *event, int event_id,",
            "\t\t\t      char *filter_str)",
            "{",
            "\tint err;",
            "\tstruct event_filter *filter = NULL;",
            "\tstruct trace_event_call *call;",
            "",
            "\tmutex_lock(&event_mutex);",
            "",
            "\tcall = event->tp_event;",
            "",
            "\terr = -EINVAL;",
            "\tif (!call)",
            "\t\tgoto out_unlock;",
            "",
            "\terr = -EEXIST;",
            "\tif (event->filter)",
            "\t\tgoto out_unlock;",
            "",
            "\terr = create_filter(NULL, call, filter_str, false, &filter);",
            "\tif (err)",
            "\t\tgoto free_filter;",
            "",
            "\tif (ftrace_event_is_function(call))",
            "\t\terr = ftrace_function_set_filter(event, filter);",
            "\telse",
            "\t\tevent->filter = filter;",
            "",
            "free_filter:",
            "\tif (err || ftrace_event_is_function(call))",
            "\t\t__free_filter(filter);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn err;",
            "}",
            "static int test_pred_visited_fn(struct filter_pred *pred, void *event)",
            "{",
            "\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\ttest_pred_visited = 1;",
            "\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);",
            "\treturn 1;",
            "}"
          ],
          "function_name": "ftrace_function_set_filter_pred, is_or, ftrace_function_set_filter, ftrace_function_set_filter, ftrace_profile_set_filter, test_pred_visited_fn",
          "description": "ftrace_function_set_filter_pred 将谓词转换为正则表达式并调用底层设置函数；is_or 检查程序流图中节点是否为OR逻辑分支；ftrace_function_set_filter 遍历过滤器谓词链表，校验逻辑结构后应用到函数跟踪；ftrace_profile_set_filter 创建事件过滤器并根据事件类型选择设置方式；test_pred_visited_fn 标记谓词访问状态用于测试",
          "similarity": 0.5183413028717041
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 862,
          "end_line": 968,
          "content": [
            "static int filter_pred_pchar(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_string(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_pchar_user(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_ustring(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_strloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 str_item = *(u32 *)(event + pred->offset);",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(event + str_loc);",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_strrelloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 *item = (u32 *)(event + pred->offset);",
            "\tu32 str_item = *item;",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(&item[1]) + str_loc;",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu, cmp;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\tcmp = pred->val;",
            "",
            "\tswitch (pred->op) {",
            "\tcase OP_EQ:",
            "\t\treturn cpu == cmp;",
            "\tcase OP_NE:",
            "\t\treturn cpu != cmp;",
            "\tcase OP_LT:",
            "\t\treturn cpu < cmp;",
            "\tcase OP_LE:",
            "\t\treturn cpu <= cmp;",
            "\tcase OP_GT:",
            "\t\treturn cpu > cmp;",
            "\tcase OP_GE:",
            "\t\treturn cpu >= cmp;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static int filter_pred_cpu_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu = raw_smp_processor_id();",
            "",
            "\treturn do_filter_scalar_cpumask(pred->op, cpu, pred->mask);",
            "}",
            "static int filter_pred_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tconst struct cpumask *cmp = pred->mask;",
            "",
            "\treturn do_filter_cpumask(pred->op, mask, cmp);",
            "}",
            "static int filter_pred_cpumask_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tunsigned int cpu = pred->val;",
            "",
            "\treturn do_filter_cpumask_scalar(pred->op, mask, cpu);",
            "}",
            "static int filter_pred_comm(struct filter_pred *pred, void *event)",
            "{",
            "\tint cmp;",
            "",
            "\tcmp = pred->regex->match(current->comm, pred->regex,",
            "\t\t\t\tTASK_COMM_LEN);",
            "\treturn cmp ^ pred->not;",
            "}"
          ],
          "function_name": "filter_pred_pchar, filter_pred_pchar_user, filter_pred_strloc, filter_pred_strrelloc, filter_pred_cpu, filter_pred_cpu_cpumask, filter_pred_cpumask, filter_pred_cpumask_cpu, filter_pred_comm",
          "description": "提供针对字符串、位置、进程名等特殊数据类型的过滤实现，处理指针解引用和内存地址匹配。",
          "similarity": 0.517646312713623
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2741,
          "end_line": 2822,
          "content": [
            "static void update_pred_fn(struct event_filter *filter, char *fields)",
            "{",
            "\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,",
            "\t\t\t\t\t\tlockdep_is_held(&event_mutex));",
            "\tint i;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "\t\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\t\tWARN_ON_ONCE(pred->fn_num == FILTER_PRED_FN_NOP);",
            "",
            "\t\tif (!field) {",
            "\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!strchr(fields, *field->name))",
            "\t\t\tcontinue;",
            "",
            "\t\tpred->fn_num = FILTER_PRED_TEST_VISITED;",
            "\t}",
            "}",
            "static __init int ftrace_test_event_filter(void)",
            "{",
            "\tint i;",
            "",
            "\tprintk(KERN_INFO \"Testing ftrace filter: \");",
            "",
            "\tfor (i = 0; i < DATA_CNT; i++) {",
            "\t\tstruct event_filter *filter = NULL;",
            "\t\tstruct test_filter_data_t *d = &test_filter_data[i];",
            "\t\tint err;",
            "",
            "\t\terr = create_filter(NULL, &event_ftrace_test_filter,",
            "\t\t\t\t    d->filter, false, &filter);",
            "\t\tif (err) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed to get filter for '%s', err %d\\n\",",
            "\t\t\t       d->filter, err);",
            "\t\t\t__free_filter(filter);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Needed to dereference filter->prog */",
            "\t\tmutex_lock(&event_mutex);",
            "\t\t/*",
            "\t\t * The preemption disabling is not really needed for self",
            "\t\t * tests, but the rcu dereference will complain without it.",
            "\t\t */",
            "\t\tpreempt_disable();",
            "\t\tif (*d->not_visited)",
            "\t\t\tupdate_pred_fn(filter, d->not_visited);",
            "",
            "\t\ttest_pred_visited = 0;",
            "\t\terr = filter_match_preds(filter, &d->rec);",
            "\t\tpreempt_enable();",
            "",
            "\t\tmutex_unlock(&event_mutex);",
            "",
            "\t\t__free_filter(filter);",
            "",
            "\t\tif (test_pred_visited) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",",
            "\t\t\t       d->filter);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (err != d->match) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed to match filter '%s', expected %d\\n\",",
            "\t\t\t       d->filter, d->match);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (i == DATA_CNT)",
            "\t\tprintk(KERN_CONT \"OK\\n\");",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "update_pred_fn, ftrace_test_event_filter",
          "description": "update_pred_fn 更新谓词节点的函数号标记已访问字段；ftrace_test_event_filter 自动测试过滤器匹配逻辑，通过创建过滤器、遍历谓词节点并验证匹配结果判断测试是否通过",
          "similarity": 0.5108420848846436
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2400,
          "end_line": 2508,
          "content": [
            "int apply_subsystem_event_filter(struct trace_subsystem_dir *dir,",
            "\t\t\t\t char *filter_string)",
            "{",
            "\tstruct event_subsystem *system = dir->subsystem;",
            "\tstruct trace_array *tr = dir->tr;",
            "\tstruct event_filter *filter = NULL;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&event_mutex);",
            "",
            "\t/* Make sure the system still has events */",
            "\tif (!dir->nr_events) {",
            "\t\terr = -ENODEV;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (!strcmp(strstrip(filter_string), \"0\")) {",
            "\t\tfilter_free_subsystem_preds(dir, tr);",
            "\t\tremove_filter_string(system->filter);",
            "\t\tfilter = system->filter;",
            "\t\tsystem->filter = NULL;",
            "\t\t/* Ensure all filters are no longer used */",
            "\t\ttracepoint_synchronize_unregister();",
            "\t\tfilter_free_subsystem_filters(dir, tr);",
            "\t\t__free_filter(filter);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\terr = create_system_filter(dir, filter_string, &filter);",
            "\tif (filter) {",
            "\t\t/*",
            "\t\t * No event actually uses the system filter",
            "\t\t * we can free it without synchronize_rcu().",
            "\t\t */",
            "\t\t__free_filter(system->filter);",
            "\t\tsystem->filter = filter;",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn err;",
            "}",
            "void ftrace_profile_free_filter(struct perf_event *event)",
            "{",
            "\tstruct event_filter *filter = event->filter;",
            "",
            "\tevent->filter = NULL;",
            "\t__free_filter(filter);",
            "}",
            "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,",
            "\t\t\t\t      int reset, char *re, int len)",
            "{",
            "\tint ret;",
            "",
            "\tif (filter)",
            "\t\tret = ftrace_set_filter(ops, re, len, reset);",
            "\telse",
            "\t\tret = ftrace_set_notrace(ops, re, len, reset);",
            "",
            "\treturn ret;",
            "}",
            "static int __ftrace_function_set_filter(int filter, char *buf, int len,",
            "\t\t\t\t\tstruct function_filter_data *data)",
            "{",
            "\tint i, re_cnt, ret = -EINVAL;",
            "\tint *reset;",
            "\tchar **re;",
            "",
            "\treset = filter ? &data->first_filter : &data->first_notrace;",
            "",
            "\t/*",
            "\t * The 'ip' field could have multiple filters set, separated",
            "\t * either by space or comma. We first cut the filter and apply",
            "\t * all pieces separately.",
            "\t */",
            "\tre = ftrace_function_filter_re(buf, len, &re_cnt);",
            "\tif (!re)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < re_cnt; i++) {",
            "\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,",
            "\t\t\t\t\t\t re[i], strlen(re[i]));",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "",
            "\t\tif (*reset)",
            "\t\t\t*reset = 0;",
            "\t}",
            "",
            "\targv_free(re);",
            "\treturn ret;",
            "}",
            "static int ftrace_function_check_pred(struct filter_pred *pred)",
            "{",
            "\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\t/*",
            "\t * Check the predicate for function trace, verify:",
            "\t *  - only '==' and '!=' is used",
            "\t *  - the 'ip' field is used",
            "\t */",
            "\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (strcmp(field->name, \"ip\"))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "apply_subsystem_event_filter, ftrace_profile_free_filter, ftrace_function_set_regexp, __ftrace_function_set_filter, ftrace_function_check_pred",
          "description": "apply_subsystem_event_filter 根据过滤字符串设置子系统级事件过滤器，处理过滤器创建、释放及错误返回；ftrace_profile_free_filter 释放perf_event的过滤器指针；__ftrace_function_set_filter 将过滤字符串分割后依次应用正则表达式到函数跟踪操作；ftrace_function_check_pred 验证谓词操作类型和字段是否符合函数跟踪要求",
          "similarity": 0.5082913041114807
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 134,
          "end_line": 236,
          "content": [
            "static bool is_not(const char *str)",
            "{",
            "\tswitch (str[1]) {",
            "\tcase '=':",
            "\tcase '~':",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void update_preds(struct prog_entry *prog, int N, int invert)",
            "{",
            "\tint t, s;",
            "",
            "\tt = prog[N].target;",
            "\ts = prog[t].target;",
            "\tprog[t].when_to_branch = invert;",
            "\tprog[t].target = N;",
            "\tprog[N].target = s;",
            "}",
            "static void parse_error(struct filter_parse_error *pe, int err, int pos)",
            "{",
            "\tpe->lasterr = err;",
            "\tpe->lasterr_pos = pos;",
            "}",
            "static void free_predicate(struct filter_pred *pred)",
            "{",
            "\tif (pred) {",
            "\t\tkfree(pred->regex);",
            "\t\tkfree(pred->mask);",
            "\t\tkfree(pred);",
            "\t}",
            "}",
            "static inline int",
            "do_filter_cpumask(int op, const struct cpumask *mask, const struct cpumask *cmp)",
            "{",
            "\tswitch (op) {",
            "\tcase OP_EQ:",
            "\t\treturn cpumask_equal(mask, cmp);",
            "\tcase OP_NE:",
            "\t\treturn !cpumask_equal(mask, cmp);",
            "\tcase OP_BAND:",
            "\t\treturn cpumask_intersects(mask, cmp);",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static inline int",
            "do_filter_scalar_cpumask(int op, unsigned int cpu, const struct cpumask *mask)",
            "{",
            "\t/*",
            "\t * Per the weight-of-one cpumask optimisations, the mask passed in this",
            "\t * function has a weight >= 2, so it is never equal to a single scalar.",
            "\t */",
            "\tswitch (op) {",
            "\tcase OP_EQ:",
            "\t\treturn false;",
            "\tcase OP_NE:",
            "\t\treturn true;",
            "\tcase OP_BAND:",
            "\t\treturn cpumask_test_cpu(cpu, mask);",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static inline int",
            "do_filter_cpumask_scalar(int op, const struct cpumask *mask, unsigned int cpu)",
            "{",
            "\tswitch (op) {",
            "\tcase OP_EQ:",
            "\t\treturn cpumask_test_cpu(cpu, mask) &&",
            "\t\t\tcpumask_nth(1, mask) >= nr_cpu_ids;",
            "\tcase OP_NE:",
            "\t\treturn !cpumask_test_cpu(cpu, mask) ||",
            "\t\t\tcpumask_nth(1, mask) < nr_cpu_ids;",
            "\tcase OP_BAND:",
            "\t\treturn cpumask_test_cpu(cpu, mask);",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static int filter_pred_string(struct filter_pred *pred, void *event)",
            "{",
            "\tchar *addr = (char *)(event + pred->offset);",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, pred->regex->field_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static __always_inline int filter_pchar(struct filter_pred *pred, char *str)",
            "{",
            "\tint cmp, match;",
            "\tint len;",
            "",
            "\tlen = strlen(str) + 1;\t/* including tailing '\\0' */",
            "\tcmp = pred->regex->match(str, pred->regex, len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}"
          ],
          "function_name": "is_not, update_preds, parse_error, free_predicate, do_filter_cpumask, do_filter_scalar_cpumask, do_filter_cpumask_scalar, filter_pred_string, filter_pchar",
          "description": "实现过滤条件的基本操作，包括取反判断、谓词更新、错误记录、CPUMASK和标量比较等核心过滤逻辑。",
          "similarity": 0.5076988935470581
        }
      ]
    }
  ]
}