{
  "query": "用于跟踪中断的处理状态 中断优先级",
  "timestamp": "2025-12-26 02:13:26",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/timings.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:10:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\timings.c`\n\n---\n\n# irq/timings.c 技术文档\n\n## 1. 文件概述\n\n`irq/timings.c` 是 Linux 内核中用于中断时间预测的核心模块。该文件实现了基于历史中断时间戳的预测算法，旨在通过分析中断发生的周期性模式，预测下一次中断可能发生的时间。此功能主要用于低功耗场景（如 CPU 空闲状态管理），帮助调度器或电源管理子系统更精确地设置唤醒时间，从而在保证响应性的同时减少不必要的唤醒开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irq_timings`：每个 CPU 私有的中断时间记录结构，包含一个循环缓冲区，用于存储 `<中断号, 时间戳>` 元组。\n- `irqt_stats`：全局 IDR（整数到指针映射）结构，用于按中断号索引中断统计信息。\n- `irq_timing_enabled`：静态分支键（`static_key`），用于在运行时动态启用/禁用中断时间跟踪功能，避免性能开销。\n\n### 主要函数\n\n- `irq_timings_enable(void)`：启用中断时间跟踪功能，激活静态分支。\n- `irq_timings_disable(void)`：禁用中断时间跟踪功能，关闭静态分支。\n- （注：实际的预测算法逻辑虽未在代码片段中完整展示，但文档详细描述了其实现原理）\n\n## 3. 关键实现\n\n### 中断时间预测算法\n\n该模块采用三阶段算法预测中断周期：\n\n#### 1) 后缀数组（Suffix Array）模式识别\n- 将中断间隔（经 `ilog2` 映射后的索引值）序列视为字符串。\n- 构建长度为 2 到 5 的后缀（受限于实际设备周期经验）。\n- 在最近 `3 × max_period`（即 15）个索引中搜索后缀的重复出现。\n- 若某后缀连续出现 3 次，则认为发现有效周期模式，其长度即为预测周期。\n\n#### 2) 对数间隔桶（Log Interval Bucketing）\n- 使用 `ilog2(interval)` 将原始时间间隔映射到 0~63 的桶索引（因 `u64` 最大为 2^64）。\n- 该方法将大范围的时间值压缩到小数组中，例如值 1123 映射到索引 10（因 2^10 = 1024 ≤ 1123 < 2048 = 2^11）。\n\n#### 3) 指数移动平均（Exponential Moving Average, EMA）\n- 每个桶维护一个 EMA 值，用于平滑同一数量级间隔的波动。\n- EMA 公式使平均值对新数据具有可调的响应速度（通过 alpha 参数隐式控制）。\n- 预测时，根据识别出的周期模式中的桶索引，返回对应桶的 EMA 值作为预测间隔。\n\n### 工作流程\n1. 中断发生时，若 `irq_timing_enabled` 为真，则将 `<irq, timestamp>` 记录到 per-CPU 的循环缓冲区。\n2. 当需要预测某中断的下次发生时间时：\n   - 清空并处理循环缓冲区，将间隔数据分发到各中断的统计结构中。\n   - 对每个中断的间隔序列执行上述三阶段算法。\n   - 若找到重复模式，则用 EMA 值计算预测时间；否则返回未预测。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：实现 per-CPU 变量 `irq_timings`。\n  - `<linux/static_key.h>`：提供静态分支优化，避免未启用时的条件判断开销。\n  - `<linux/math64.h>` 和 `<linux/log2.h>`：用于 `ilog2` 等数学运算。\n  - `<trace/events/irq.h>`：可能用于跟踪事件（虽未在片段中调用）。\n  - `\"internals.h\"`：内核中断子系统内部头文件。\n- **子系统依赖**：\n  - 通用中断子系统（`<linux/irq.h>`, `<linux/interrupt.h>`）。\n  - 内存管理（`<linux/slab.h>`）用于动态分配统计结构。\n  - IDR 机制（`<linux/idr.h>`）用于中断号到统计结构的映射。\n\n## 5. 使用场景\n\n- **CPU 空闲状态管理（cpuidle）**：在进入深度 C-state 前，预测下一次中断时间以设置精确的唤醒定时器，避免过早或过晚唤醒。\n- **实时系统调度**：辅助调度器预判周期性中断（如 tickless 系统中的高精度定时器），优化任务调度时机。\n- **电源管理**：结合设备驱动的中断模式，动态调整设备或 CPU 的电源状态。\n- **性能分析**：通过跟踪中断时间模式，诊断中断风暴或异常周期行为。\n\n该功能默认关闭，仅在需要时通过 `irq_timings_enable()` 动态启用，确保对常规系统性能无影响。",
      "similarity": 0.660457193851471,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/timings.c",
          "start_line": 1,
          "end_line": 25,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2016, Linaro Ltd - Daniel Lezcano <daniel.lezcano@linaro.org>",
            "#define pr_fmt(fmt) \"irq_timings: \" fmt",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/static_key.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/idr.h>",
            "#include <linux/irq.h>",
            "#include <linux/math64.h>",
            "#include <linux/log2.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(irq_timing_enabled);",
            "",
            "DEFINE_PER_CPU(struct irq_timings, irq_timings);",
            "",
            "static DEFINE_IDR(irqt_stats);",
            ""
          ],
          "function_name": null,
          "description": "定义中断计时模块的静态键开关和PER-CPU结构体，声明IDR管理器用于动态分配中断统计实例",
          "similarity": 0.6443448066711426
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/timings.c",
          "start_line": 26,
          "end_line": 165,
          "content": [
            "void irq_timings_enable(void)",
            "{",
            "\tstatic_branch_enable(&irq_timing_enabled);",
            "}",
            "void irq_timings_disable(void)",
            "{",
            "\tstatic_branch_disable(&irq_timing_enabled);",
            "}",
            "static u64 irq_timings_ema_new(u64 value, u64 ema_old)",
            "{",
            "\ts64 diff;",
            "",
            "\tif (unlikely(!ema_old))",
            "\t\treturn value;",
            "",
            "\tdiff = (value - ema_old) * EMA_ALPHA_VAL;",
            "\t/*",
            "\t * We can use a s64 type variable to be added with the u64",
            "\t * ema_old variable as this one will never have its topmost",
            "\t * bit set, it will be always smaller than 2^63 nanosec",
            "\t * interrupt interval (292 years).",
            "\t */",
            "\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);",
            "}",
            "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)",
            "{",
            "\tint period;",
            "",
            "\t/*",
            "\t * Move the beginning pointer to the end minus the max period x 3.",
            "\t * We are at the point we can begin searching the pattern",
            "\t */",
            "\tbuffer = &buffer[len - (period_max * 3)];",
            "",
            "\t/* Adjust the length to the maximum allowed period x 3 */",
            "\tlen = period_max * 3;",
            "",
            "\t/*",
            "\t * The buffer contains the suite of intervals, in a ilog2",
            "\t * basis, we are looking for a repetition. We point the",
            "\t * beginning of the search three times the length of the",
            "\t * period beginning at the end of the buffer. We do that for",
            "\t * each suffix.",
            "\t */",
            "\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {",
            "",
            "\t\t/*",
            "\t\t * The first comparison always succeed because the",
            "\t\t * suffix is deduced from the first n-period bytes of",
            "\t\t * the buffer and we compare the initial suffix with",
            "\t\t * itself, so we can skip the first iteration.",
            "\t\t */",
            "\t\tint idx = period;",
            "\t\tsize_t size = period;",
            "",
            "\t\t/*",
            "\t\t * We look if the suite with period 'i' repeat",
            "\t\t * itself. If it is truncated at the end, as it",
            "\t\t * repeats we can use the period to find out the next",
            "\t\t * element with the modulo.",
            "\t\t */",
            "\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {",
            "",
            "\t\t\t/*",
            "\t\t\t * Move the index in a period basis",
            "\t\t\t */",
            "\t\t\tidx += size;",
            "",
            "\t\t\t/*",
            "\t\t\t * If this condition is reached, all previous",
            "\t\t\t * memcmp were successful, so the period is",
            "\t\t\t * found.",
            "\t\t\t */",
            "\t\t\tif (idx == len)",
            "\t\t\t\treturn buffer[len % period];",
            "",
            "\t\t\t/*",
            "\t\t\t * If the remaining elements to compare are",
            "\t\t\t * smaller than the period, readjust the size",
            "\t\t\t * of the comparison for the last iteration.",
            "\t\t\t */",
            "\t\t\tif (len - idx < period)",
            "\t\t\t\tsize = len - idx;",
            "\t\t}",
            "\t}",
            "",
            "\treturn -1;",
            "}",
            "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)",
            "{",
            "\tint index, i, period_max, count, start, min = INT_MAX;",
            "",
            "\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {",
            "\t\tirqs->count = irqs->last_ts = 0;",
            "\t\treturn U64_MAX;",
            "\t}",
            "",
            "\t/*",
            "\t * As we want to find three times the repetition, we need a",
            "\t * number of intervals greater or equal to three times the",
            "\t * maximum period, otherwise we truncate the max period.",
            "\t */",
            "\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;",
            "",
            "\t/*",
            "\t * If we don't have enough irq timings for this prediction,",
            "\t * just bail out.",
            "\t */",
            "\tif (period_max <= PREDICTION_PERIOD_MIN)",
            "\t\treturn U64_MAX;",
            "",
            "\t/*",
            "\t * 'count' will depends if the circular buffer wrapped or not",
            "\t */",
            "\tcount = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\tirqs->count : IRQ_TIMINGS_SIZE;",
            "",
            "\tstart = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);",
            "",
            "\t/*",
            "\t * Copy the content of the circular buffer into another buffer",
            "\t * in order to linearize the buffer instead of dealing with",
            "\t * wrapping indexes and shifted array which will be prone to",
            "\t * error and extremely difficult to debug.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "",
            "\t\tirqs->timings[i] = irqs->circ_timings[index];",
            "\t\tmin = min_t(int, irqs->timings[i], min);",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);",
            "\tif (index < 0)",
            "\t\treturn irqs->last_ts + irqs->ema_time[min];",
            "",
            "\treturn irqs->last_ts + irqs->ema_time[index];",
            "}"
          ],
          "function_name": "irq_timings_enable, irq_timings_disable, irq_timings_ema_new, irq_timings_next_event_index, __irq_timings_next_event",
          "description": "实现中断计时功能的启用/禁用控制，EMA计算算法及基于模式匹配的周期预测核心逻辑",
          "similarity": 0.6288700699806213
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/timings.c",
          "start_line": 927,
          "end_line": 956,
          "content": [
            "static int __init irq_timings_selftest(void)",
            "{",
            "\tint ret;",
            "",
            "\tpr_info(\"------------------- selftest start -----------------\\n\");",
            "",
            "\t/*",
            "\t * At this point, we don't except any subsystem to use the irq",
            "\t * timings but us, so it should not be enabled.",
            "\t */",
            "\tif (static_branch_unlikely(&irq_timing_enabled)) {",
            "\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = irq_timings_irqts_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_irqs_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_next_index_selftest();",
            "out:",
            "\tpr_info(\"---------- selftest end with %s -----------\\n\",",
            "\t\tret ? \"failure\" : \"success\");",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_selftest",
          "description": "该代码段实现了中断定时功能的自我检测逻辑，用于验证中断时间戳、中断序列及索引管理等子系统的正确性。作为初始化函数，它通过调用三个子测试函数依次检查相关功能模块的行为是否符合预期。由于代码中引用了未展示的测试函数（如irq_timings_irqts_selftest），需结合上下文才能完整理解其工作机制。",
          "similarity": 0.6173608303070068
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/timings.c",
          "start_line": 594,
          "end_line": 739,
          "content": [
            "void irq_timings_free(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s) {",
            "\t\tfree_percpu(s);",
            "\t\tidr_remove(&irqt_stats, irq);",
            "\t}",
            "}",
            "int irq_timings_alloc(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tint id;",
            "",
            "\t/*",
            "\t * Some platforms can have the same private interrupt per cpu,",
            "\t * so this function may be called several times with the",
            "\t * same interrupt number. Just bail out in case the per cpu",
            "\t * stat structure is already allocated.",
            "\t */",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s)",
            "\t\treturn 0;",
            "",
            "\ts = alloc_percpu(*s);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\tidr_preload(GFP_KERNEL);",
            "\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);",
            "\tidr_preload_end();",
            "",
            "\tif (id < 0) {",
            "\t\tfree_percpu(s);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_test_next_index(struct timings_intervals *ti)",
            "{",
            "\tint _buffer[IRQ_TIMINGS_SIZE];",
            "\tint buffer[IRQ_TIMINGS_SIZE];",
            "\tint index, start, i, count, period_max;",
            "",
            "\tcount = ti->count - 1;",
            "",
            "\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : count / 3;",
            "",
            "\t/*",
            "\t * Inject all values except the last one which will be used",
            "\t * to compare with the next index result.",
            "\t */",
            "\tpr_debug(\"index suite: \");",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;",
            "\t\tpr_cont(\"%d \", index);",
            "\t}",
            "",
            "\tstart = count < IRQ_TIMINGS_SIZE ? 0 :",
            "\t\tcount & IRQ_TIMINGS_MASK;",
            "",
            "\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "\t\tbuffer[i] = _buffer[index];",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(buffer, count, period_max);",
            "\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);",
            "",
            "\tif (index != i) {",
            "\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",",
            "\t\t       i, index);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_next_index_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "",
            "\t\tret = irq_timings_test_next_index(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqs(struct timings_intervals *ti)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tstruct irqt_stat *irqs;",
            "\tint i, index, ret, irq = 0xACE5;",
            "",
            "\tret = irq_timings_alloc(irq);",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate irq timings\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (!s) {",
            "\t\tret = -EIDRM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tirqs = this_cpu_ptr(s);",
            "",
            "\tfor (i = 0; i < ti->count; i++) {",
            "",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",",
            "\t\t\t i, ti->intervals[i], index);",
            "",
            "\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);",
            "\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {",
            "\t\t\tret = -EBADSLT;",
            "\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (irqs->count != ti->count) {",
            "\t\tret = -ERANGE;",
            "\t\tpr_err(\"Count differs\\n\");",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "out:",
            "\tirq_timings_free(irq);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_free, irq_timings_alloc, irq_timings_test_next_index, irq_timings_next_index_selftest, irq_timings_test_irqs",
          "description": "实现中断统计结构的动态分配/释放机制，包含预测算法的自检测试函数",
          "similarity": 0.5697808265686035
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/timings.c",
          "start_line": 821,
          "end_line": 923,
          "content": [
            "static int __init irq_timings_irqs_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "\t\tret = irq_timings_test_irqs(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqts(struct irq_timings *irqts,",
            "\t\t\t\t\t unsigned count)",
            "{",
            "\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;",
            "\tint i, irq, oirq = 0xBEEF;",
            "\tu64 ots = 0xDEAD, ts;",
            "",
            "\t/*",
            "\t * Fill the circular buffer by using the dedicated function.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",",
            "\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);",
            "",
            "\t\tirq_timings_push(ots + i, oirq + i);",
            "\t}",
            "",
            "\t/*",
            "\t * Compute the first elements values after the index wrapped",
            "\t * up or not.",
            "\t */",
            "\tots += start;",
            "\toirq += start;",
            "",
            "\t/*",
            "\t * Test the circular buffer count is correct.",
            "\t */",
            "\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);",
            "\tif (WARN_ON(irqts->count != count))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Test the macro allowing to browse all the irqts.",
            "\t */",
            "\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");",
            "\tfor_each_irqts(i, irqts) {",
            "",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "",
            "\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",",
            "\t\t\t i, ts, ots, irq, oirq);",
            "",
            "\t\tif (WARN_ON(ts != ots || irq != oirq))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tots++; oirq++;",
            "\t}",
            "",
            "\t/*",
            "\t * The circular buffer should have be flushed when browsed",
            "\t * with for_each_irqts",
            "\t */",
            "\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");",
            "\tif (WARN_ON(irqts->count))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_irqts_selftest(void)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tint i, ret;",
            "",
            "\t/*",
            "\t * Test the circular buffer with different number of",
            "\t * elements. The purpose is to test at the limits (empty, half",
            "\t * full, full, wrapped with the cursor at the boundaries,",
            "\t * wrapped several times, etc ...",
            "\t */",
            "\tint count[] = { 0,",
            "\t\t\tIRQ_TIMINGS_SIZE >> 1,",
            "\t\t\tIRQ_TIMINGS_SIZE,",
            "\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),",
            "\t\t\t2 * IRQ_TIMINGS_SIZE,",
            "\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,",
            "\t};",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(count); i++) {",
            "",
            "\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",",
            "\t\t\tcount[i], IRQ_TIMINGS_SIZE);",
            "",
            "\t\tret = irq_timings_test_irqts(irqts, count[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_irqs_selftest, irq_timings_test_irqts, irq_timings_irqts_selftest",
          "description": "包含完整的中断计时模块自检框架，验证环形缓冲区操作和for_each_irqts宏的正确性",
          "similarity": 0.567712128162384
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_irqsoff.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:26:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_irqsoff.c`\n\n---\n\n# `trace_irqsoff.c` 技术文档\n\n## 1. 文件概述\n\n`trace_irqsoff.c` 是 Linux 内核中用于追踪 **中断关闭（IRQs-off）** 和 **抢占关闭（preempt-off）** 关键路径延迟的核心模块。该文件实现了 `irqsoff` 和 `preemptoff` 两种延迟追踪器（tracer），用于检测系统中因长时间关闭中断或禁止抢占而导致的延迟问题，是内核延迟分析（latency tracing）的重要组成部分。\n\n该模块通过监控中断和抢占状态的变化，记录最长的关闭时间（即“关键路径”），帮助开发者识别潜在的实时性瓶颈。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `irqsoff_trace`：全局 `trace_array` 指针，代表当前激活的追踪实例。\n- `tracer_enabled`：追踪器是否启用的全局标志。\n- `tracing_cpu`（per-CPU）：标记当前 CPU 是否处于被追踪状态。\n- `max_trace_lock`：保护最大延迟记录的原始自旋锁。\n- `trace_type`：指示当前追踪类型（`TRACER_IRQS_OFF` 或 `TRACER_PREEMPT_OFF`）。\n- `max_sequence`：用于避免并发最大值更新干扰的序列计数器（cache-line 对齐）。\n\n### 主要函数\n\n- `irq_trace()` / `preempt_trace()`：判断当前是否应追踪中断或抢占关闭状态。\n- `func_prolog_dec()`：函数追踪的通用前置处理，检查是否应记录当前调用。\n- `irqsoff_tracer_call()`：函数追踪回调，记录函数调用事件。\n- `irqsoff_graph_entry()` / `irqsoff_graph_return()`：函数图追踪（function graph tracer）的入口和返回回调。\n- `check_critical_timing()`：检查当前关闭时间是否构成新的最大延迟（未完整显示，但为关键逻辑）。\n- `report_latency()`：判断是否应报告或记录当前延迟（基于阈值或历史最大值）。\n- `irqsoff_display_graph()`：切换函数图显示模式。\n- `irqsoff_print_line()` / `irqsoff_print_header()`：格式化输出追踪结果。\n\n## 3. 关键实现\n\n### 延迟检测机制\n\n- 模块通过 `preemptirq:preempt_disable/enable` 和 `irq_disable/enable` 等 tracepoint（来自 `trace/events/preemptirq.h`）感知中断/抢占状态变化。\n- 当进入关闭状态时开始计时，恢复时计算持续时间（`delta`）。\n- 使用 `report_latency()` 判断该 `delta` 是否值得记录：若设置了 `tracing_thresh`，则只记录超过阈值的延迟；否则只记录超过当前 `max_latency` 的延迟。\n\n### 并发安全与准确性\n\n- 使用 per-CPU 变量 `tracing_cpu` 标记正在追踪的 CPU，避免跨 CPU 干扰。\n- 通过 `max_sequence` 序列号机制防止多个 CPU 同时更新最大延迟时互相覆盖或受串扰（如控制台输出）影响。\n- 使用 `atomic_inc_return(&data->disabled)` 确保同一 CPU 上追踪回调不会嵌套执行，避免重复记录。\n\n### 函数追踪集成\n\n- 若启用 `CONFIG_FUNCTION_TRACER`，使用自定义的 `irqsoff_tracer_call` 作为 ftrace 回调，仅在关键路径期间记录函数调用。\n- 若启用 `CONFIG_FUNCTION_GRAPH_TRACER`，则进一步支持函数调用图（call graph）追踪，通过 `fgraph_ops` 注册入口/返回钩子。\n- 通过 `is_graph(tr)` 动态判断是否使用图模式输出，并调用相应的格式化函数（如 `print_graph_function_flags`）。\n\n### 模式切换与资源管理\n\n- `start_irqsoff_tracer()` / `stop_irqsoff_tracer()`（声明但未在片段中定义）负责启用/禁用底层追踪机制（如注册 ftrace ops）。\n- 切换图模式时会重置追踪状态（清零 `tracing_cpu`、`max_latency` 并重置缓冲区）。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `trace.h`：提供通用追踪基础设施（`trace_array`, `trace_function` 等）。\n  - `trace/events/preemptirq.h`：提供中断/抢占状态变化的 tracepoint。\n  - `ftrace.h` / `kprobes.h`：支持动态函数追踪。\n- **条件编译依赖**：\n  - `CONFIG_IRQSOFF_TRACER`：启用中断关闭追踪。\n  - `CONFIG_PREEMPT_TRACER`：启用抢占关闭追踪。\n  - `CONFIG_FUNCTION_TRACER`：启用函数级追踪。\n  - `CONFIG_FUNCTION_GRAPH_TRACER`：启用函数调用图追踪。\n- **运行时依赖**：依赖内核的 per-CPU 数据、原子操作、自旋锁等同步原语。\n\n## 5. 使用场景\n\n- **实时系统调试**：在实时内核（如 PREEMPT_RT）开发中，用于定位导致调度延迟的长关键路径。\n- **性能分析**：通过 `/sys/kernel/debug/tracing/` 接口启用 `irqsoff` 或 `preemptoff` 追踪器，分析系统最大中断/抢占关闭时间。\n- **阈值告警**：结合 `tracing_thresh` 设置延迟阈值，仅记录超限事件，减少日志噪音。\n- **函数路径分析**：配合函数图追踪，可视化导致长延迟的具体函数调用链。\n- **内核开发与测试**：在提交可能影响中断/抢占延迟的补丁前，使用该追踪器验证性能影响。",
      "similarity": 0.6588759422302246,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 44,
          "end_line": 167,
          "content": [
            "static inline int",
            "preempt_trace(int pc)",
            "{",
            "\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);",
            "}",
            "static inline int",
            "irq_trace(void)",
            "{",
            "\treturn ((trace_type & TRACER_IRQS_OFF) &&",
            "\t\tirqs_disabled());",
            "}",
            "static inline int irqsoff_display_graph(struct trace_array *tr, int set)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int func_prolog_dec(struct trace_array *tr,",
            "\t\t\t   struct trace_array_cpu **data,",
            "\t\t\t   unsigned long *flags)",
            "{",
            "\tlong disabled;",
            "\tint cpu;",
            "",
            "\t/*",
            "\t * Does not matter if we preempt. We test the flags",
            "\t * afterward, to see if irqs are disabled or not.",
            "\t * If we preempt and get a false positive, the flags",
            "\t * test will fail.",
            "\t */",
            "\tcpu = raw_smp_processor_id();",
            "\tif (likely(!per_cpu(tracing_cpu, cpu)))",
            "\t\treturn 0;",
            "",
            "\tlocal_save_flags(*flags);",
            "\t/*",
            "\t * Slight chance to get a false positive on tracing_cpu,",
            "\t * although I'm starting to think there isn't a chance.",
            "\t * Leave this for now just to be paranoid.",
            "\t */",
            "\tif (!irqs_disabled_flags(*flags) && !preempt_count())",
            "\t\treturn 0;",
            "",
            "\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "\tdisabled = atomic_inc_return(&(*data)->disabled);",
            "",
            "\tif (likely(disabled == 1))",
            "\t\treturn 1;",
            "",
            "\tatomic_dec(&(*data)->disabled);",
            "",
            "\treturn 0;",
            "}",
            "static void",
            "irqsoff_tracer_call(unsigned long ip, unsigned long parent_ip,",
            "\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned long flags;",
            "\tunsigned int trace_ctx;",
            "",
            "\tif (!func_prolog_dec(tr, &data, &flags))",
            "\t\treturn;",
            "",
            "\ttrace_ctx = tracing_gen_ctx_flags(flags);",
            "",
            "\ttrace_function(tr, ip, parent_ip, trace_ctx);",
            "",
            "\tatomic_dec(&data->disabled);",
            "}",
            "static int irqsoff_display_graph(struct trace_array *tr, int set)",
            "{",
            "\tint cpu;",
            "",
            "\tif (!(is_graph(tr) ^ set))",
            "\t\treturn 0;",
            "",
            "\tstop_irqsoff_tracer(irqsoff_trace, !set);",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tper_cpu(tracing_cpu, cpu) = 0;",
            "",
            "\ttr->max_latency = 0;",
            "\ttracing_reset_online_cpus(&irqsoff_trace->array_buffer);",
            "",
            "\treturn start_irqsoff_tracer(irqsoff_trace, set);",
            "}",
            "static int irqsoff_graph_entry(struct ftrace_graph_ent *trace,",
            "\t\t\t       struct fgraph_ops *gops,",
            "\t\t\t       struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned long flags;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint ret;",
            "",
            "\tif (ftrace_graph_ignore_func(gops, trace))",
            "\t\treturn 0;",
            "\t/*",
            "\t * Do not trace a function if it's filtered by set_graph_notrace.",
            "\t * Make the index of ret stack negative to indicate that it should",
            "\t * ignore further functions.  But it needs its own ret stack entry",
            "\t * to recover the original index in order to continue tracing after",
            "\t * returning from the function.",
            "\t */",
            "\tif (ftrace_graph_notrace_addr(trace->func))",
            "\t\treturn 1;",
            "",
            "\tif (!func_prolog_dec(tr, &data, &flags))",
            "\t\treturn 0;",
            "",
            "\tcalltime = fgraph_reserve_data(gops->idx, sizeof(*calltime));",
            "\tif (!calltime)",
            "\t\treturn 0;",
            "",
            "\t*calltime = trace_clock_local();",
            "",
            "\ttrace_ctx = tracing_gen_ctx_flags(flags);",
            "\tret = __trace_graph_entry(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "preempt_trace, irq_trace, irqsoff_display_graph, func_prolog_dec, irqsoff_tracer_call, irqsoff_display_graph, irqsoff_graph_entry",
          "description": "实现抢占/中断关闭状态检测及跟踪点标记逻辑，包含函数用于识别中断禁用状态、管理跟踪数据流及图模式下的事件记录",
          "similarity": 0.7327110767364502
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 625,
          "end_line": 688,
          "content": [
            "void tracer_hardirqs_on(unsigned long a0, unsigned long a1)",
            "{",
            "\tif (!preempt_trace(preempt_count()) && irq_trace())",
            "\t\tstop_critical_timing(a0, a1);",
            "}",
            "void tracer_hardirqs_off(unsigned long a0, unsigned long a1)",
            "{",
            "\tif (!preempt_trace(preempt_count()) && irq_trace())",
            "\t\tstart_critical_timing(a0, a1);",
            "}",
            "static int irqsoff_tracer_init(struct trace_array *tr)",
            "{",
            "\ttrace_type = TRACER_IRQS_OFF;",
            "",
            "\treturn __irqsoff_tracer_init(tr);",
            "}",
            "static void irqsoff_tracer_reset(struct trace_array *tr)",
            "{",
            "\t__irqsoff_tracer_reset(tr);",
            "}",
            "void tracer_preempt_on(unsigned long a0, unsigned long a1)",
            "{",
            "\tif (preempt_trace(preempt_count()) && !irq_trace())",
            "\t\tstop_critical_timing(a0, a1);",
            "}",
            "void tracer_preempt_off(unsigned long a0, unsigned long a1)",
            "{",
            "\tif (preempt_trace(preempt_count()) && !irq_trace())",
            "\t\tstart_critical_timing(a0, a1);",
            "}",
            "static int preemptoff_tracer_init(struct trace_array *tr)",
            "{",
            "\ttrace_type = TRACER_PREEMPT_OFF;",
            "",
            "\treturn __irqsoff_tracer_init(tr);",
            "}",
            "static void preemptoff_tracer_reset(struct trace_array *tr)",
            "{",
            "\t__irqsoff_tracer_reset(tr);",
            "}",
            "static int preemptirqsoff_tracer_init(struct trace_array *tr)",
            "{",
            "\ttrace_type = TRACER_IRQS_OFF | TRACER_PREEMPT_OFF;",
            "",
            "\treturn __irqsoff_tracer_init(tr);",
            "}",
            "static void preemptirqsoff_tracer_reset(struct trace_array *tr)",
            "{",
            "\t__irqsoff_tracer_reset(tr);",
            "}",
            "__init static int init_irqsoff_tracer(void)",
            "{",
            "#ifdef CONFIG_IRQSOFF_TRACER",
            "\tregister_tracer(&irqsoff_tracer);",
            "#endif",
            "#ifdef CONFIG_PREEMPT_TRACER",
            "\tregister_tracer(&preemptoff_tracer);",
            "#endif",
            "#if defined(CONFIG_IRQSOFF_TRACER) && defined(CONFIG_PREEMPT_TRACER)",
            "\tregister_tracer(&preemptirqsoff_tracer);",
            "#endif",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "tracer_hardirqs_on, tracer_hardirqs_off, irqsoff_tracer_init, irqsoff_tracer_reset, tracer_preempt_on, tracer_preempt_off, preemptoff_tracer_init, preemptoff_tracer_reset, preemptirqsoff_tracer_init, preemptirqsoff_tracer_reset, init_irqsoff_tracer",
          "description": "该代码段实现了对硬中断和抢占状态变化的跟踪逻辑，提供三种跟踪模式（仅中断禁用、仅抢占禁用、两者均禁用）。各函数通过判断当前上下文是否处于中断/抢占禁用状态，调用`start_critical_timing`/`stop_critical_timing`记录关键时间点，具体实现依赖未展示的底层函数。代码通过条件编译注册对应跟踪器，但因上下文不完整无法确认全部细节。",
          "similarity": 0.6903834939002991
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 217,
          "end_line": 355,
          "content": [
            "static void irqsoff_graph_return(struct ftrace_graph_ret *trace,",
            "\t\t\t\t struct fgraph_ops *gops,",
            "\t\t\t\t struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned long flags;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint size;",
            "",
            "\tftrace_graph_addr_finish(gops, trace);",
            "",
            "\tif (!func_prolog_dec(tr, &data, &flags))",
            "\t\treturn;",
            "",
            "\tcalltime = fgraph_retrieve_data(gops->idx, &size);",
            "\tif (!calltime)",
            "\t\treturn;",
            "\ttrace->calltime = *calltime;",
            "",
            "\ttrace_ctx = tracing_gen_ctx_flags(flags);",
            "\t__trace_graph_return(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "}",
            "static void irqsoff_trace_open(struct trace_iterator *iter)",
            "{",
            "\tif (is_graph(iter->tr))",
            "\t\tgraph_trace_open(iter);",
            "}",
            "static void irqsoff_trace_close(struct trace_iterator *iter)",
            "{",
            "\tif (iter->private)",
            "\t\tgraph_trace_close(iter);",
            "}",
            "static enum print_line_t irqsoff_print_line(struct trace_iterator *iter)",
            "{",
            "\t/*",
            "\t * In graph mode call the graph tracer output function,",
            "\t * otherwise go with the TRACE_FN event handler",
            "\t */",
            "\tif (is_graph(iter->tr))",
            "\t\treturn print_graph_function_flags(iter, GRAPH_TRACER_FLAGS);",
            "",
            "\treturn TRACE_TYPE_UNHANDLED;",
            "}",
            "static void irqsoff_print_header(struct seq_file *s)",
            "{",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "",
            "\tif (is_graph(tr))",
            "\t\tprint_graph_headers_flags(s, GRAPH_TRACER_FLAGS);",
            "\telse",
            "\t\ttrace_default_header(s);",
            "}",
            "static void",
            "__trace_function(struct trace_array *tr,",
            "\t\t unsigned long ip, unsigned long parent_ip,",
            "\t\t unsigned int trace_ctx)",
            "{",
            "\tif (is_graph(tr))",
            "\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);",
            "\telse",
            "\t\ttrace_function(tr, ip, parent_ip, trace_ctx);",
            "}",
            "static enum print_line_t irqsoff_print_line(struct trace_iterator *iter)",
            "{",
            "\treturn TRACE_TYPE_UNHANDLED;",
            "}",
            "static void irqsoff_trace_open(struct trace_iterator *iter) { }",
            "static void irqsoff_trace_close(struct trace_iterator *iter) { }",
            "static void irqsoff_print_header(struct seq_file *s)",
            "{",
            "\ttrace_default_header(s);",
            "}",
            "static void irqsoff_print_header(struct seq_file *s)",
            "{",
            "\ttrace_latency_header(s);",
            "}",
            "static bool report_latency(struct trace_array *tr, u64 delta)",
            "{",
            "\tif (tracing_thresh) {",
            "\t\tif (delta < tracing_thresh)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\tif (delta <= tr->max_latency)",
            "\t\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void",
            "check_critical_timing(struct trace_array *tr,",
            "\t\t      struct trace_array_cpu *data,",
            "\t\t      unsigned long parent_ip,",
            "\t\t      int cpu)",
            "{",
            "\tu64 T0, T1, delta;",
            "\tunsigned long flags;",
            "\tunsigned int trace_ctx;",
            "",
            "\tT0 = data->preempt_timestamp;",
            "\tT1 = ftrace_now(cpu);",
            "\tdelta = T1-T0;",
            "",
            "\ttrace_ctx = tracing_gen_ctx();",
            "",
            "\tif (!report_latency(tr, delta))",
            "\t\tgoto out;",
            "",
            "\traw_spin_lock_irqsave(&max_trace_lock, flags);",
            "",
            "\t/* check if we are still the max latency */",
            "\tif (!report_latency(tr, delta))",
            "\t\tgoto out_unlock;",
            "",
            "\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);",
            "\t/* Skip 5 functions to get to the irq/preempt enable function */",
            "\t__trace_stack(tr, trace_ctx, 5);",
            "",
            "\tif (data->critical_sequence != max_sequence)",
            "\t\tgoto out_unlock;",
            "",
            "\tdata->critical_end = parent_ip;",
            "",
            "\tif (likely(!is_tracing_stopped())) {",
            "\t\ttr->max_latency = delta;",
            "\t\tupdate_max_tr_single(tr, current, cpu);",
            "\t}",
            "",
            "\tmax_sequence++;",
            "",
            "out_unlock:",
            "\traw_spin_unlock_irqrestore(&max_trace_lock, flags);",
            "",
            "out:",
            "\tdata->critical_sequence = max_sequence;",
            "\tdata->preempt_timestamp = ftrace_now(cpu);",
            "\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);",
            "}"
          ],
          "function_name": "irqsoff_graph_return, irqsoff_trace_open, irqsoff_trace_close, irqsoff_print_line, irqsoff_print_header, __trace_function, irqsoff_print_line, irqsoff_trace_open, irqsoff_trace_close, irqsoff_print_header, irqsoff_print_header, report_latency, check_critical_timing",
          "description": "提供跟踪事件输出格式化支持，包含关键路径延迟检测逻辑，通过时间差计算确定是否记录异常延迟事件",
          "similarity": 0.6749106645584106
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 387,
          "end_line": 490,
          "content": [
            "static nokprobe_inline void",
            "start_critical_timing(unsigned long ip, unsigned long parent_ip)",
            "{",
            "\tint cpu;",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "",
            "\tif (!tracer_enabled || !tracing_is_enabled())",
            "\t\treturn;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "",
            "\tif (per_cpu(tracing_cpu, cpu))",
            "\t\treturn;",
            "",
            "\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "",
            "\tif (unlikely(!data) || atomic_read(&data->disabled))",
            "\t\treturn;",
            "",
            "\tatomic_inc(&data->disabled);",
            "",
            "\tdata->critical_sequence = max_sequence;",
            "\tdata->preempt_timestamp = ftrace_now(cpu);",
            "\tdata->critical_start = parent_ip ? : ip;",
            "",
            "\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());",
            "",
            "\tper_cpu(tracing_cpu, cpu) = 1;",
            "",
            "\tatomic_dec(&data->disabled);",
            "}",
            "static nokprobe_inline void",
            "stop_critical_timing(unsigned long ip, unsigned long parent_ip)",
            "{",
            "\tint cpu;",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned int trace_ctx;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\t/* Always clear the tracing cpu on stopping the trace */",
            "\tif (unlikely(per_cpu(tracing_cpu, cpu)))",
            "\t\tper_cpu(tracing_cpu, cpu) = 0;",
            "\telse",
            "\t\treturn;",
            "",
            "\tif (!tracer_enabled || !tracing_is_enabled())",
            "\t\treturn;",
            "",
            "\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "",
            "\tif (unlikely(!data) ||",
            "\t    !data->critical_start || atomic_read(&data->disabled))",
            "\t\treturn;",
            "",
            "\tatomic_inc(&data->disabled);",
            "",
            "\ttrace_ctx = tracing_gen_ctx();",
            "\t__trace_function(tr, ip, parent_ip, trace_ctx);",
            "\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);",
            "\tdata->critical_start = 0;",
            "\tatomic_dec(&data->disabled);",
            "}",
            "void start_critical_timings(void)",
            "{",
            "\tif (preempt_trace(preempt_count()) || irq_trace())",
            "\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1);",
            "}",
            "void stop_critical_timings(void)",
            "{",
            "\tif (preempt_trace(preempt_count()) || irq_trace())",
            "\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);",
            "}",
            "static int register_irqsoff_function(struct trace_array *tr, int graph, int set)",
            "{",
            "\tint ret;",
            "",
            "\t/* 'set' is set if TRACE_ITER_FUNCTION is about to be set */",
            "\tif (function_enabled || (!set && !(tr->trace_flags & TRACE_ITER_FUNCTION)))",
            "\t\treturn 0;",
            "",
            "\tif (graph)",
            "\t\tret = register_ftrace_graph(&fgraph_ops);",
            "\telse",
            "\t\tret = register_ftrace_function(tr->ops);",
            "",
            "\tif (!ret)",
            "\t\tfunction_enabled = true;",
            "",
            "\treturn ret;",
            "}",
            "static void unregister_irqsoff_function(struct trace_array *tr, int graph)",
            "{",
            "\tif (!function_enabled)",
            "\t\treturn;",
            "",
            "\tif (graph)",
            "\t\tunregister_ftrace_graph(&fgraph_ops);",
            "\telse",
            "\t\tunregister_ftrace_function(tr->ops);",
            "",
            "\tfunction_enabled = false;",
            "}"
          ],
          "function_name": "start_critical_timing, stop_critical_timing, start_critical_timings, stop_critical_timings, register_irqsoff_function, unregister_irqsoff_function",
          "description": "实现中断关闭时间段的起止标记功能，管理跟踪器注册/注销流程，协调FTrace图形跟踪与普通函数跟踪模式",
          "similarity": 0.65072101354599
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace irqs off critical timings",
            " *",
            " * Copyright (C) 2007-2008 Steven Rostedt <srostedt@redhat.com>",
            " * Copyright (C) 2008 Ingo Molnar <mingo@redhat.com>",
            " *",
            " * From code in the latency_tracer, that is:",
            " *",
            " *  Copyright (C) 2004-2006 Ingo Molnar",
            " *  Copyright (C) 2004 Nadia Yvette Chambers",
            " */",
            "#include <linux/kallsyms.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kprobes.h>",
            "",
            "#include \"trace.h\"",
            "",
            "#include <trace/events/preemptirq.h>",
            "",
            "#if defined(CONFIG_IRQSOFF_TRACER) || defined(CONFIG_PREEMPT_TRACER)",
            "static struct trace_array\t\t*irqsoff_trace __read_mostly;",
            "static int\t\t\t\ttracer_enabled __read_mostly;",
            "",
            "static DEFINE_PER_CPU(int, tracing_cpu);",
            "",
            "static DEFINE_RAW_SPINLOCK(max_trace_lock);",
            "",
            "enum {",
            "\tTRACER_IRQS_OFF\t\t= (1 << 1),",
            "\tTRACER_PREEMPT_OFF\t= (1 << 2),",
            "};",
            "",
            "static int trace_type __read_mostly;",
            "",
            "static int save_flags;",
            "",
            "static void stop_irqsoff_tracer(struct trace_array *tr, int graph);",
            "static int start_irqsoff_tracer(struct trace_array *tr, int graph);",
            "",
            "#ifdef CONFIG_PREEMPT_TRACER"
          ],
          "function_name": null,
          "description": "定义中断关闭跟踪器的全局变量和常量，用于控制抢占和中断关闭状态的追踪功能，上下文不完整",
          "similarity": 0.6447571516036987
        }
      ]
    },
    {
      "source_file": "kernel/irq/debug.h",
      "md_summary": "> 自动生成时间: 2025-10-25 13:50:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\debug.h`\n\n---\n\n# `irq/debug.h` 技术文档\n\n## 1. 文件概述\n\n`irq/debug.h` 是 Linux 内核中断子系统中的一个调试辅助头文件，主要用于在运行时打印中断描述符（`struct irq_desc`）的详细状态信息。该文件提供了一个内联函数 `print_irq_desc()`，用于以结构化方式输出指定中断号对应的中断描述符的关键字段、状态标志、回调函数指针等信息，便于内核开发者诊断中断相关问题。为避免调试信息刷屏，该函数内置了速率限制机制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`print_irq_desc(unsigned int irq, struct irq_desc *desc)`**  \n  内联函数，用于打印指定中断号 `irq` 及其对应的中断描述符 `desc` 的详细调试信息，包括：\n  - 中断基本统计信息（深度、触发次数、未处理次数）\n  - 关键回调函数指针及其符号信息（`handle_irq`、`chip`、`action->handler`）\n  - 中断描述符的状态标志（通过 `___P` 和 `___PS` 宏展开）\n  - （预留但未实现）中断运行时状态标志（通过 `___PD` 宏）\n\n### 辅助宏\n\n- **`___P(f)`**  \n  检查 `desc->status_use_accessors` 是否包含标志 `f`，若包含则打印该标志名称。\n  \n- **`___PS(f)`**  \n  检查 `desc->istate` 是否包含标志 `f`，若包含则打印该标志名称。\n  \n- **`___PD(f)`**  \n  当前为空实现（`do { } while (0)`），注释标记为 `FIXME`，用于未来可能对 `desc->state_use_accessors` 或其他运行时状态字段的调试支持。\n\n## 3. 关键实现\n\n- **速率限制机制**：  \n  使用 `DEFINE_RATELIMIT_STATE(ratelimit, 5 * HZ, 5)` 定义一个速率限制器，确保每 5 秒最多打印 5 次调试信息，防止高频中断导致控制台日志泛滥。\n\n- **符号解析打印**：  \n  利用 `%pS` 格式说明符（内核特有）将函数指针转换为可读的符号名称（如函数名），极大提升调试可读性。\n\n- **状态标志分类打印**：\n  - `___P` 宏用于打印 `desc->status_use_accessors` 中的**配置类标志**，如 `IRQ_PER_CPU`、`IRQ_NOPROBE` 等。\n  - `___PS` 宏用于打印 `desc->istate` 中的**中断状态标志**，如 `IRQS_PENDING`、`IRQS_REPLAY` 等。\n  - `___PD` 宏当前未实现，可能用于未来打印如 `IRQS_INPROGRESS`、`IRQS_DISABLED` 等运行时状态（这些状态通常通过访问器函数管理，不直接暴露字段）。\n\n- **条件编译与清理**：  \n  所有辅助宏在函数定义结束后通过 `#undef` 清除，避免污染全局宏命名空间。\n\n## 4. 依赖关系\n\n- **依赖头文件**：  \n  虽未显式包含，但实际使用时需依赖以下内核头文件：\n  - `<linux/kernel.h>`：提供 `printk` 和 `__ratelimit`\n  - `<linux/ratelimit.h>`：提供 `DEFINE_RATELIMIT_STATE`\n  - `<linux/irqdesc.h>`：定义 `struct irq_desc`\n  - `<linux/irq.h>`：定义中断相关标志（如 `IRQ_LEVEL`、`IRQS_PENDING` 等）\n\n- **依赖内核子系统**：\n  - **中断子系统（IRQ Core）**：依赖 `irq_desc` 结构体及其字段语义。\n  - **打印子系统**：依赖内核日志机制和 `%pS` 符号解析功能。\n  - **速率限制框架**：依赖内核通用的速率限制 API。\n\n## 5. 使用场景\n\n- **中断调试与诊断**：  \n  在开发或调试中断控制器驱动、中断处理流程时，调用 `print_irq_desc()` 可快速查看中断描述符的当前状态，帮助定位如中断未触发、重复触发、处理函数异常等问题。\n\n- **内核 Oops/panic 分析**：  \n  可集成到中断相关的错误处理路径中，在发生异常时输出中断状态快照，辅助事后分析。\n\n- **动态探测工具支持**：  \n  可被 `ftrace`、`kprobe` 或自定义调试模块调用，用于运行时监控特定中断的行为。\n\n- **教学与文档参考**：  \n  作为理解 Linux 中断描述符结构和状态标志的实用示例代码。",
      "similarity": 0.6521558165550232,
      "chunks": []
    }
  ]
}