{
  "query": "ntp_sync",
  "timestamp": "2025-12-26 02:18:33",
  "retrieved_files": [
    {
      "source_file": "kernel/time/ntp.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:41:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\ntp.c`\n\n---\n\n# `time/ntp.c` 技术文档\n\n## 1. 文件概述\n\n`time/ntp.c` 是 Linux 内核中实现网络时间协议（NTP）状态机和时间同步逻辑的核心文件。该文件负责维护系统时钟的频率和相位调整，支持通过 NTP 或 PPS（Pulse Per Second）信号进行高精度时间同步。其主要功能包括：\n\n- 管理 NTP 状态（同步状态、错误标志等）\n- 实现 PLL（锁相环）和 FLL（频率锁定环）算法进行时钟校正\n- 处理闰秒事件\n- 支持 PPS 信号输入（当 `CONFIG_NTP_PPS` 启用时）\n- 提供用户空间通过 `adjtimex()` 系统调用访问和控制时间同步状态的接口\n\n该文件原为 `kernel/timer.c` 和 `kernel/time.c` 中相关逻辑的拆分整合，现专注于 NTP 时间同步的核心状态维护与算法实现。\n\n## 2. 核心功能\n\n### 主要全局变量\n\n| 变量名 | 类型 | 说明 |\n|--------|------|------|\n| `tick_usec` | `unsigned long` | 用户空间 HZ 对应的微秒周期（默认 10000，即 10ms） |\n| `tick_nsec` | `unsigned long` | 内核实际使用的纳秒 tick 周期 |\n| `tick_length` | `u64` | 当前 tick 长度（纳秒，已缩放） |\n| `tick_length_base` | `u64` | 基准 tick 长度（用于频率调整） |\n| `time_state` | `int` | 时钟同步状态（如 `TIME_OK`、`TIME_ERROR`） |\n| `time_status` | `int` | NTP 状态标志位（如 `STA_UNSYNC`、`STA_PPSSIGNAL`） |\n| `time_offset` | `s64` | 当前相位偏移（纳秒） |\n| `time_constant` | `long` | PLL 时间常数（控制收敛速度） |\n| `time_maxerror` / `time_esterror` | `long` | 最大/估计时间误差（微秒） |\n| `time_freq` | `s64` | 频率偏移（缩放后的纳秒/秒） |\n| `time_reftime` | `time64_t` | 上次调整时间（秒） |\n| `ntp_tick_adj` | `s64` | 启动参数配置的固定 tick 调整值 |\n| `ntp_next_leap_sec` | `time64_t` | 下一个闰秒发生的时间（`TIME64_MAX` 表示无） |\n\n### PPS 相关变量（`CONFIG_NTP_PPS` 启用时）\n\n- `pps_valid`：PPS 信号有效性计数器\n- `pps_tf[3]`：相位中值滤波器\n- `pps_jitter`：当前抖动（纳秒）\n- `pps_fbase`：频率校准区间起始时间\n- `pps_shift`：当前校准区间长度（以 2 的幂表示秒数）\n- `pps_freq`：PPS 控制下的频率偏移\n- 各类计数器：`pps_calcnt`, `pps_jitcnt`, `pps_stbcnt`, `pps_errcnt`\n\n### 主要内联函数\n\n| 函数 | 功能 |\n|------|------|\n| `ntp_synced()` | 判断 NTP 是否处于同步状态（非 `STA_UNSYNC`） |\n| `ntp_offset_chunk()` | 计算每次调整应修正的相位偏移量（PPS 模式下全量修正，否则按 PLL 衰减） |\n| `pps_reset_freq_interval()` | 重置 PPS 频率校准区间 |\n| `pps_clear()` | 清除所有 PPS 状态 |\n| `pps_dec_valid()` | 递减 PPS 有效性计数器，超时则清除 PPS 状态 |\n| `pps_set_freq()` | 设置 PPS 频率偏移 |\n| `is_error_status()` | 判断当前 `time_status` 是否表示错误状态 |\n| `pps_fill_timex()` | 将 PPS 统计信息填充到 `timex` 结构体供用户空间查询 |\n\n### 主要静态函数\n\n| 函数 | 功能 |\n|------|------|\n| `ntp_update_frequency()` | 根据 `tick_usec`、`ntp_tick_adj` 和 `time_freq` 更新 `tick_length` 等频率相关变量 |\n| `ntp_update_offset_fll()` | 在 FLL 模式下根据相位偏移和时间间隔计算频率调整量 |\n| `ntp_update_offset()` | （代码截断）实现 PLL 模式下的相位偏移处理和频率调整 |\n\n## 3. 关键实现\n\n### 3.1 时间频率调整机制\n\n内核通过 `tick_length` 控制系统 tick 的实际长度。`ntp_update_frequency()` 函数综合以下三部分计算每秒总长度：\n\n1. **基准长度**：`tick_usec * NSEC_PER_USEC * USER_HZ`（即 1 秒的理想纳秒数）\n2. **启动参数调整**：`ntp_tick_adj`（由 `tick_adj` 内核参数设置）\n3. **动态频率偏移**：`time_freq`（由 NTP 算法计算得出）\n\n总长度经缩放（`NTP_SCALE_SHIFT`）后，除以 `HZ` 得到 `tick_nsec`，除以 `NTP_INTERVAL_FREQ`（通常为 1000）得到 `tick_length_base`。`tick_length` 会立即应用新值，实现频率的平滑调整。\n\n### 3.2 PLL/FLL 算法\n\n- **PLL（Phase-Locked Loop）**：默认模式，通过 `ntp_offset_chunk()` 按 `SHIFT_PLL + time_constant` 位右移来衰减相位修正量，实现稳定收敛。\n- **FLL（Frequency-Locked Loop）**：在长时间偏移或大偏移场景下启用（通过 `STA_FLL` 标志），直接根据 `offset / time_interval` 计算频率修正（见 `ntp_update_offset_fll()`）。\n\n### 3.3 PPS 支持\n\n当启用 `CONFIG_NTP_PPS` 时：\n- 若同时设置 `STA_PPSTIME` 和 `STA_PPSSIGNAL`，相位偏移会**立即全量修正**（`ntp_offset_chunk()` 直接返回原偏移）\n- 实现了自适应频率校准区间（`pps_shift` 在 `PPS_INTMIN` 到 `PPS_INTMAX` 之间动态调整）\n- 使用三值中值滤波器（`pps_tf[3]`）抑制 PPS 信号的“爆米花”噪声（`PPS_POPCORN` 阈值）\n- 维护多个质量指标计数器供诊断使用\n\n### 3.4 状态管理\n\n- `time_status` 使用位标志（`STA_*`）表示同步状态、错误条件和 PPS 状态\n- `is_error_status()` 综合判断是否处于错误状态（包括 PPS 相关错误）\n- `time_state` 控制是否允许写入 CMOS 时钟（`TIME_ERROR` 时禁止）\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/timex.h>`：定义 `timex` 结构体和 `STA_*` 状态常量\n- `<linux/time.h>`、`<linux/time64.h>`：时间表示和转换\n- `<linux/math64.h>`：64 位除法等数学运算\n- `\"ntp_internal.h\"`：NTP 内部接口（如 `NTP_SCALE_SHIFT`、`MAXPHASE` 等常量）\n- `\"timekeeping_internal.h\"`：与时间保持子系统交互\n\n### 内核模块交互\n- **时间保持子系统（`timekeeping.c`）**：共享 `timekeeper` 锁，`tick_length` 被 `timekeeping` 用于更新系统时钟\n- **系统调用层**：通过 `do_adjtimex()`（在 `kernel/time/ntp.c` 或 `kernel/time/time.c` 中）访问本文件的状态变量\n- **PPS 子系统**：当 `CONFIG_NTP_PPS` 启用时，PPS 事件处理器会调用本文件的 PPS 状态更新函数\n- **RTC 驱动**：受 `time_state` 控制是否允许更新 CMOS 时钟\n\n## 5. 使用场景\n\n1. **NTP 客户端同步**：用户空间 NTP 守护进程（如 `ntpd`、`chronyd`）通过 `adjtimex()` 系统调用定期提供偏移量和状态，内核据此调整系统时钟频率和相位。\n\n2. **高精度时间源接入**：当连接 GPS 或原子钟等提供 PPS 信号的设备时，内核 PPS 子系统将信号传递给本模块，实现纳秒级时间同步。\n\n3. **闰秒处理**",
      "similarity": 0.6335499286651611,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/ntp.c",
          "start_line": 1,
          "end_line": 124,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * NTP state machine interfaces and logic.",
            " *",
            " * This code was mainly moved from kernel/timer.c and kernel/time.c",
            " * Please see those files for relevant copyright info and historical",
            " * changelogs.",
            " */",
            "#include <linux/capability.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/math64.h>",
            "#include <linux/timex.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/rtc.h>",
            "#include <linux/audit.h>",
            "",
            "#include \"ntp_internal.h\"",
            "#include \"timekeeping_internal.h\"",
            "",
            "",
            "/*",
            " * NTP timekeeping variables:",
            " *",
            " * Note: All of the NTP state is protected by the timekeeping locks.",
            " */",
            "",
            "",
            "/* USER_HZ period (usecs): */",
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "",
            "/* SHIFTED_HZ period (nsecs): */",
            "unsigned long\t\t\ttick_nsec;",
            "",
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "",
            "#define SECS_PER_DAY\t\t86400",
            "#define MAX_TICKADJ\t\t500LL\t\t/* usecs */",
            "#define MAX_TICKADJ_SCALED \\",
            "\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)",
            "#define MAX_TAI_OFFSET\t\t100000",
            "",
            "/*",
            " * phase-lock loop variables",
            " */",
            "",
            "/*",
            " * clock synchronization status",
            " *",
            " * (TIME_ERROR prevents overwriting the CMOS clock)",
            " */",
            "static int\t\t\ttime_state = TIME_OK;",
            "",
            "/* clock status bits:\t\t\t\t\t\t\t*/",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "",
            "/* time adjustment (nsecs):\t\t\t\t\t\t*/",
            "static s64\t\t\ttime_offset;",
            "",
            "/* pll time constant:\t\t\t\t\t\t\t*/",
            "static long\t\t\ttime_constant = 2;",
            "",
            "/* maximum error (usecs):\t\t\t\t\t\t*/",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "",
            "/* estimated error (usecs):\t\t\t\t\t\t*/",
            "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
            "",
            "/* frequency offset (scaled nsecs/secs):\t\t\t\t*/",
            "static s64\t\t\ttime_freq;",
            "",
            "/* time at last adjustment (secs):\t\t\t\t\t*/",
            "static time64_t\t\ttime_reftime;",
            "",
            "static long\t\t\ttime_adjust;",
            "",
            "/* constant (boot-param configurable) NTP tick adjustment (upscaled)\t*/",
            "static s64\t\t\tntp_tick_adj;",
            "",
            "/* second value of the next pending leapsecond, or TIME64_MAX if no leap */",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;",
            "",
            "#ifdef CONFIG_NTP_PPS",
            "",
            "/*",
            " * The following variables are used when a pulse-per-second (PPS) signal",
            " * is available. They establish the engineering parameters of the clock",
            " * discipline loop when controlled by the PPS signal.",
            " */",
            "#define PPS_VALID\t10\t/* PPS signal watchdog max (s) */",
            "#define PPS_POPCORN\t4\t/* popcorn spike threshold (shift) */",
            "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */",
            "#define PPS_INTMAX\t8\t/* max freq interval (s) (shift) */",
            "#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to",
            "\t\t\t\t   increase pps_shift or consecutive bad",
            "\t\t\t\t   intervals to decrease it */",
            "#define PPS_MAXWANDER\t100000\t/* max PPS freq wander (ns/s) */",
            "",
            "static int pps_valid;\t\t/* signal watchdog counter */",
            "static long pps_tf[3];\t\t/* phase median filter */",
            "static long pps_jitter;\t\t/* current jitter (ns) */",
            "static struct timespec64 pps_fbase; /* beginning of the last freq interval */",
            "static int pps_shift;\t\t/* current interval duration (s) (shift) */",
            "static int pps_intcnt;\t\t/* interval counter */",
            "static s64 pps_freq;\t\t/* frequency offset (scaled ns/s) */",
            "static long pps_stabil;\t\t/* current stability (scaled ns/s) */",
            "",
            "/*",
            " * PPS signal quality monitors",
            " */",
            "static long pps_calcnt;\t\t/* calibration intervals */",
            "static long pps_jitcnt;\t\t/* jitter limit exceeded */",
            "static long pps_stbcnt;\t\t/* stability limit exceeded */",
            "static long pps_errcnt;\t\t/* calibration errors */",
            "",
            "",
            "/* PPS kernel consumer compensates the whole phase error immediately.",
            " * Otherwise, reduce the offset by a fixed factor times the time constant.",
            " */"
          ],
          "function_name": null,
          "description": "定义NTP时间同步状态变量及辅助宏，存储时间状态、偏移量、频率调整参数及PPS相关变量，用于控制网络时间协议的同步逻辑。",
          "similarity": 0.6098002791404724
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/time/ntp.c",
          "start_line": 663,
          "end_line": 830,
          "content": [
            "void ntp_notify_cmos_timer(void)",
            "{",
            "\t/*",
            "\t * When the work is currently executed but has not yet the timer",
            "\t * rearmed this queues the work immediately again. No big issue,",
            "\t * just a pointless work scheduled.",
            "\t */",
            "\tif (ntp_synced() && !hrtimer_is_queued(&sync_hrtimer))",
            "\t\tqueue_work(system_freezable_power_efficient_wq, &sync_work);",
            "}",
            "static void __init ntp_init_cmos_sync(void)",
            "{",
            "\thrtimer_init(&sync_hrtimer, CLOCK_REALTIME, HRTIMER_MODE_ABS);",
            "\tsync_hrtimer.function = sync_timer_callback;",
            "}",
            "static inline void __init ntp_init_cmos_sync(void) { }",
            "static inline void process_adj_status(const struct __kernel_timex *txc)",
            "{",
            "\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {",
            "\t\ttime_state = TIME_OK;",
            "\t\ttime_status = STA_UNSYNC;",
            "\t\tntp_next_leap_sec = TIME64_MAX;",
            "\t\t/* restart PPS frequency calibration */",
            "\t\tpps_reset_freq_interval();",
            "\t}",
            "",
            "\t/*",
            "\t * If we turn on PLL adjustments then reset the",
            "\t * reference time to current time.",
            "\t */",
            "\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))",
            "\t\ttime_reftime = __ktime_get_real_seconds();",
            "",
            "\t/* only set allowed bits */",
            "\ttime_status &= STA_RONLY;",
            "\ttime_status |= txc->status & ~STA_RONLY;",
            "}",
            "static inline void process_adjtimex_modes(const struct __kernel_timex *txc,",
            "\t\t\t\t\t  s32 *time_tai)",
            "{",
            "\tif (txc->modes & ADJ_STATUS)",
            "\t\tprocess_adj_status(txc);",
            "",
            "\tif (txc->modes & ADJ_NANO)",
            "\t\ttime_status |= STA_NANO;",
            "",
            "\tif (txc->modes & ADJ_MICRO)",
            "\t\ttime_status &= ~STA_NANO;",
            "",
            "\tif (txc->modes & ADJ_FREQUENCY) {",
            "\t\ttime_freq = txc->freq * PPM_SCALE;",
            "\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);",
            "\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);",
            "\t\t/* update pps_freq */",
            "\t\tpps_set_freq(time_freq);",
            "\t}",
            "",
            "\tif (txc->modes & ADJ_MAXERROR)",
            "\t\ttime_maxerror = clamp(txc->maxerror, 0, NTP_PHASE_LIMIT);",
            "",
            "\tif (txc->modes & ADJ_ESTERROR)",
            "\t\ttime_esterror = clamp(txc->esterror, 0, NTP_PHASE_LIMIT);",
            "",
            "\tif (txc->modes & ADJ_TIMECONST) {",
            "\t\ttime_constant = clamp(txc->constant, 0, MAXTC);",
            "\t\tif (!(time_status & STA_NANO))",
            "\t\t\ttime_constant += 4;",
            "\t\ttime_constant = clamp(time_constant, 0, MAXTC);",
            "\t}",
            "",
            "\tif (txc->modes & ADJ_TAI &&",
            "\t\t\ttxc->constant >= 0 && txc->constant <= MAX_TAI_OFFSET)",
            "\t\t*time_tai = txc->constant;",
            "",
            "\tif (txc->modes & ADJ_OFFSET)",
            "\t\tntp_update_offset(txc->offset);",
            "",
            "\tif (txc->modes & ADJ_TICK)",
            "\t\ttick_usec = txc->tick;",
            "",
            "\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))",
            "\t\tntp_update_frequency();",
            "}",
            "int __do_adjtimex(struct __kernel_timex *txc, const struct timespec64 *ts,",
            "\t\t  s32 *time_tai, struct audit_ntp_data *ad)",
            "{",
            "\tint result;",
            "",
            "\tif (txc->modes & ADJ_ADJTIME) {",
            "\t\tlong save_adjust = time_adjust;",
            "",
            "\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {",
            "\t\t\t/* adjtime() is independent from ntp_adjtime() */",
            "\t\t\ttime_adjust = txc->offset;",
            "\t\t\tntp_update_frequency();",
            "",
            "\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_ADJUST,\tsave_adjust);",
            "\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_ADJUST,\ttime_adjust);",
            "\t\t}",
            "\t\ttxc->offset = save_adjust;",
            "\t} else {",
            "\t\t/* If there are input parameters, then process them: */",
            "\t\tif (txc->modes) {",
            "\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_OFFSET,\ttime_offset);",
            "\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_FREQ,\ttime_freq);",
            "\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_STATUS,\ttime_status);",
            "\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TAI,\t*time_tai);",
            "\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TICK,\ttick_usec);",
            "",
            "\t\t\tprocess_adjtimex_modes(txc, time_tai);",
            "",
            "\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_OFFSET,\ttime_offset);",
            "\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_FREQ,\ttime_freq);",
            "\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_STATUS,\ttime_status);",
            "\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TAI,\t*time_tai);",
            "\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TICK,\ttick_usec);",
            "\t\t}",
            "",
            "\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,",
            "\t\t\t\t  NTP_SCALE_SHIFT);",
            "\t\tif (!(time_status & STA_NANO))",
            "\t\t\ttxc->offset = div_s64(txc->offset, NSEC_PER_USEC);",
            "\t}",
            "",
            "\tresult = time_state;\t/* mostly `TIME_OK' */",
            "\t/* check for errors */",
            "\tif (is_error_status(time_status))",
            "\t\tresult = TIME_ERROR;",
            "",
            "\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *",
            "\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);",
            "\ttxc->maxerror\t   = time_maxerror;",
            "\ttxc->esterror\t   = time_esterror;",
            "\ttxc->status\t   = time_status;",
            "\ttxc->constant\t   = time_constant;",
            "\ttxc->precision\t   = 1;",
            "\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;",
            "\ttxc->tick\t   = tick_usec;",
            "\ttxc->tai\t   = *time_tai;",
            "",
            "\t/* fill PPS status fields */",
            "\tpps_fill_timex(txc);",
            "",
            "\ttxc->time.tv_sec = ts->tv_sec;",
            "\ttxc->time.tv_usec = ts->tv_nsec;",
            "\tif (!(time_status & STA_NANO))",
            "\t\ttxc->time.tv_usec = ts->tv_nsec / NSEC_PER_USEC;",
            "",
            "\t/* Handle leapsec adjustments */",
            "\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {",
            "\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {",
            "\t\t\tresult = TIME_OOP;",
            "\t\t\ttxc->tai++;",
            "\t\t\ttxc->time.tv_sec--;",
            "\t\t}",
            "\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {",
            "\t\t\tresult = TIME_WAIT;",
            "\t\t\ttxc->tai--;",
            "\t\t\ttxc->time.tv_sec++;",
            "\t\t}",
            "\t\tif ((time_state == TIME_OOP) &&",
            "\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {",
            "\t\t\tresult = TIME_WAIT;",
            "\t\t}",
            "\t}",
            "",
            "\treturn result;",
            "}"
          ],
          "function_name": "ntp_notify_cmos_timer, ntp_init_cmos_sync, ntp_init_cmos_sync, process_adj_status, process_adjtimex_modes, __do_adjtimex",
          "description": "实现adjtimex系统调用核心逻辑，解析时间调整参数并更新内部状态机，协调NTP调整模式与系统时间状态。",
          "similarity": 0.5775452256202698
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/time/ntp.c",
          "start_line": 987,
          "end_line": 1077,
          "content": [
            "static void hardpps_update_phase(long error)",
            "{",
            "\tlong correction = -error;",
            "\tlong jitter;",
            "",
            "\t/* add the sample to the median filter */",
            "\tpps_phase_filter_add(correction);",
            "\tcorrection = pps_phase_filter_get(&jitter);",
            "",
            "\t/* Nominal jitter is due to PPS signal noise. If it exceeds the",
            "\t * threshold, the sample is discarded; otherwise, if so enabled,",
            "\t * the time offset is updated.",
            "\t */",
            "\tif (jitter > (pps_jitter << PPS_POPCORN)) {",
            "\t\tprintk_deferred(KERN_WARNING",
            "\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",",
            "\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));",
            "\t\ttime_status |= STA_PPSJITTER;",
            "\t\tpps_jitcnt++;",
            "\t} else if (time_status & STA_PPSTIME) {",
            "\t\t/* correct the time using the phase offset */",
            "\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,",
            "\t\t\t\tNTP_INTERVAL_FREQ);",
            "\t\t/* cancel running adjtime() */",
            "\t\ttime_adjust = 0;",
            "\t}",
            "\t/* update jitter */",
            "\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;",
            "}",
            "void __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)",
            "{",
            "\tstruct pps_normtime pts_norm, freq_norm;",
            "",
            "\tpts_norm = pps_normalize_ts(*phase_ts);",
            "",
            "\t/* clear the error bits, they will be set again if needed */",
            "\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);",
            "",
            "\t/* indicate signal presence */",
            "\ttime_status |= STA_PPSSIGNAL;",
            "\tpps_valid = PPS_VALID;",
            "",
            "\t/* when called for the first time,",
            "\t * just start the frequency interval */",
            "\tif (unlikely(pps_fbase.tv_sec == 0)) {",
            "\t\tpps_fbase = *raw_ts;",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* ok, now we have a base for frequency calculation */",
            "\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));",
            "",
            "\t/* check that the signal is in the range",
            "\t * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */",
            "\tif ((freq_norm.sec == 0) ||",
            "\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||",
            "\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {",
            "\t\ttime_status |= STA_PPSJITTER;",
            "\t\t/* restart the frequency calibration interval */",
            "\t\tpps_fbase = *raw_ts;",
            "\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* signal is ok */",
            "",
            "\t/* check if the current frequency interval is finished */",
            "\tif (freq_norm.sec >= (1 << pps_shift)) {",
            "\t\tpps_calcnt++;",
            "\t\t/* restart the frequency calibration interval */",
            "\t\tpps_fbase = *raw_ts;",
            "\t\thardpps_update_freq(freq_norm);",
            "\t}",
            "",
            "\thardpps_update_phase(pts_norm.nsec);",
            "",
            "}",
            "static int __init ntp_tick_adj_setup(char *str)",
            "{",
            "\tint rc = kstrtos64(str, 0, &ntp_tick_adj);",
            "\tif (rc)",
            "\t\treturn rc;",
            "",
            "\tntp_tick_adj <<= NTP_SCALE_SHIFT;",
            "\treturn 1;",
            "}",
            "void __init ntp_init(void)",
            "{",
            "\tntp_clear();",
            "\tntp_init_cmos_sync();",
            "}"
          ],
          "function_name": "hardpps_update_phase, __hardpps, ntp_tick_adj_setup, ntp_init",
          "description": "该代码块实现PPS信号的相位校准与频率基准更新，包含事件时间标准化、频率基线检测、相位误差修正及初始化配置。__hardpps处理PPS信号的有效性验证和相位补偿，ntp_tick_adj_setup设置时钟调整参数，ntp_init完成NTP模块初始化。",
          "similarity": 0.5450438261032104
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/ntp.c",
          "start_line": 503,
          "end_line": 620,
          "content": [
            "static enum hrtimer_restart sync_timer_callback(struct hrtimer *timer)",
            "{",
            "\tqueue_work(system_freezable_power_efficient_wq, &sync_work);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}",
            "static void sched_sync_hw_clock(unsigned long offset_nsec, bool retry)",
            "{",
            "\tktime_t exp = ktime_set(ktime_get_real_seconds(), 0);",
            "",
            "\tif (retry)",
            "\t\texp = ktime_add_ns(exp, 2ULL * NSEC_PER_SEC - offset_nsec);",
            "\telse",
            "\t\texp = ktime_add_ns(exp, SYNC_PERIOD_NS - offset_nsec);",
            "",
            "\thrtimer_start(&sync_hrtimer, exp, HRTIMER_MODE_ABS);",
            "}",
            "static inline bool rtc_tv_nsec_ok(unsigned long set_offset_nsec,",
            "\t\t\t\t  struct timespec64 *to_set,",
            "\t\t\t\t  const struct timespec64 *now)",
            "{",
            "\t/* Allowed error in tv_nsec, arbitrarily set to 5 jiffies in ns. */",
            "\tconst unsigned long TIME_SET_NSEC_FUZZ = TICK_NSEC * 5;",
            "\tstruct timespec64 delay = {.tv_sec = -1,",
            "\t\t\t\t   .tv_nsec = set_offset_nsec};",
            "",
            "\t*to_set = timespec64_add(*now, delay);",
            "",
            "\tif (to_set->tv_nsec < TIME_SET_NSEC_FUZZ) {",
            "\t\tto_set->tv_nsec = 0;",
            "\t\treturn true;",
            "\t}",
            "",
            "\tif (to_set->tv_nsec > NSEC_PER_SEC - TIME_SET_NSEC_FUZZ) {",
            "\t\tto_set->tv_sec++;",
            "\t\tto_set->tv_nsec = 0;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "int __weak update_persistent_clock64(struct timespec64 now64)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "static inline int update_persistent_clock64(struct timespec64 now64)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "static int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)",
            "{",
            "\tstruct rtc_device *rtc;",
            "\tstruct rtc_time tm;",
            "\tint err = -ENODEV;",
            "",
            "\trtc = rtc_class_open(CONFIG_RTC_SYSTOHC_DEVICE);",
            "\tif (!rtc)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (!rtc->ops || !rtc->ops->set_time)",
            "\t\tgoto out_close;",
            "",
            "\t/* First call might not have the correct offset */",
            "\tif (*offset_nsec == rtc->set_offset_nsec) {",
            "\t\trtc_time64_to_tm(to_set->tv_sec, &tm);",
            "\t\terr = rtc_set_time(rtc, &tm);",
            "\t} else {",
            "\t\t/* Store the update offset and let the caller try again */",
            "\t\t*offset_nsec = rtc->set_offset_nsec;",
            "\t\terr = -EAGAIN;",
            "\t}",
            "out_close:",
            "\trtc_class_close(rtc);",
            "\treturn err;",
            "}",
            "static inline int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "static void sync_hw_clock(struct work_struct *work)",
            "{",
            "\t/*",
            "\t * The default synchronization offset is 500ms for the deprecated",
            "\t * update_persistent_clock64() under the assumption that it uses",
            "\t * the infamous CMOS clock (MC146818).",
            "\t */",
            "\tstatic unsigned long offset_nsec = NSEC_PER_SEC / 2;",
            "\tstruct timespec64 now, to_set;",
            "\tint res = -EAGAIN;",
            "",
            "\t/*",
            "\t * Don't update if STA_UNSYNC is set and if ntp_notify_cmos_timer()",
            "\t * managed to schedule the work between the timer firing and the",
            "\t * work being able to rearm the timer. Wait for the timer to expire.",
            "\t */",
            "\tif (!ntp_synced() || hrtimer_is_queued(&sync_hrtimer))",
            "\t\treturn;",
            "",
            "\tktime_get_real_ts64(&now);",
            "\t/* If @now is not in the allowed window, try again */",
            "\tif (!rtc_tv_nsec_ok(offset_nsec, &to_set, &now))",
            "\t\tgoto rearm;",
            "",
            "\t/* Take timezone adjusted RTCs into account */",
            "\tif (persistent_clock_is_local)",
            "\t\tto_set.tv_sec -= (sys_tz.tz_minuteswest * 60);",
            "",
            "\t/* Try the legacy RTC first. */",
            "\tres = update_persistent_clock64(to_set);",
            "\tif (res != -ENODEV)",
            "\t\tgoto rearm;",
            "",
            "\t/* Try the RTC class */",
            "\tres = update_rtc(&to_set, &offset_nsec);",
            "\tif (res == -ENODEV)",
            "\t\treturn;",
            "rearm:",
            "\tsched_sync_hw_clock(offset_nsec, res != 0);",
            "}"
          ],
          "function_name": "sync_timer_callback, sched_sync_hw_clock, rtc_tv_nsec_ok, update_persistent_clock64, update_persistent_clock64, update_rtc, update_rtc, sync_hw_clock",
          "description": "管理硬件时钟同步定时器，通过RTC设备更新系统时间，处理跨平台时钟源的适配与同步操作。",
          "similarity": 0.4770204424858093
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/ntp.c",
          "start_line": 281,
          "end_line": 470,
          "content": [
            "static inline s64 ntp_update_offset_fll(s64 offset64, long secs)",
            "{",
            "\ttime_status &= ~STA_MODE;",
            "",
            "\tif (secs < MINSEC)",
            "\t\treturn 0;",
            "",
            "\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))",
            "\t\treturn 0;",
            "",
            "\ttime_status |= STA_MODE;",
            "",
            "\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);",
            "}",
            "static void ntp_update_offset(long offset)",
            "{",
            "\ts64 freq_adj;",
            "\ts64 offset64;",
            "\tlong secs;",
            "",
            "\tif (!(time_status & STA_PLL))",
            "\t\treturn;",
            "",
            "\tif (!(time_status & STA_NANO)) {",
            "\t\t/* Make sure the multiplication below won't overflow */",
            "\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);",
            "\t\toffset *= NSEC_PER_USEC;",
            "\t}",
            "",
            "\t/*",
            "\t * Scale the phase adjustment and",
            "\t * clamp to the operating range.",
            "\t */",
            "\toffset = clamp(offset, -MAXPHASE, MAXPHASE);",
            "",
            "\t/*",
            "\t * Select how the frequency is to be controlled",
            "\t * and in which mode (PLL or FLL).",
            "\t */",
            "\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);",
            "\tif (unlikely(time_status & STA_FREQHOLD))",
            "\t\tsecs = 0;",
            "",
            "\ttime_reftime = __ktime_get_real_seconds();",
            "",
            "\toffset64    = offset;",
            "\tfreq_adj    = ntp_update_offset_fll(offset64, secs);",
            "",
            "\t/*",
            "\t * Clamp update interval to reduce PLL gain with low",
            "\t * sampling rate (e.g. intermittent network connection)",
            "\t * to avoid instability.",
            "\t */",
            "\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))",
            "\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);",
            "",
            "\tfreq_adj    += (offset64 * secs) <<",
            "\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));",
            "",
            "\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);",
            "",
            "\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);",
            "",
            "\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);",
            "}",
            "void ntp_clear(void)",
            "{",
            "\ttime_adjust\t= 0;\t\t/* stop active adjtime() */",
            "\ttime_status\t|= STA_UNSYNC;",
            "\ttime_maxerror\t= NTP_PHASE_LIMIT;",
            "\ttime_esterror\t= NTP_PHASE_LIMIT;",
            "",
            "\tntp_update_frequency();",
            "",
            "\ttick_length\t= tick_length_base;",
            "\ttime_offset\t= 0;",
            "",
            "\tntp_next_leap_sec = TIME64_MAX;",
            "\t/* Clear PPS state variables */",
            "\tpps_clear();",
            "}",
            "u64 ntp_tick_length(void)",
            "{",
            "\treturn tick_length;",
            "}",
            "ktime_t ntp_get_next_leap(void)",
            "{",
            "\tktime_t ret;",
            "",
            "\tif ((time_state == TIME_INS) && (time_status & STA_INS))",
            "\t\treturn ktime_set(ntp_next_leap_sec, 0);",
            "\tret = KTIME_MAX;",
            "\treturn ret;",
            "}",
            "int second_overflow(time64_t secs)",
            "{",
            "\ts64 delta;",
            "\tint leap = 0;",
            "\ts32 rem;",
            "",
            "\t/*",
            "\t * Leap second processing. If in leap-insert state at the end of the",
            "\t * day, the system clock is set back one second; if in leap-delete",
            "\t * state, the system clock is set ahead one second.",
            "\t */",
            "\tswitch (time_state) {",
            "\tcase TIME_OK:",
            "\t\tif (time_status & STA_INS) {",
            "\t\t\ttime_state = TIME_INS;",
            "\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);",
            "\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;",
            "\t\t} else if (time_status & STA_DEL) {",
            "\t\t\ttime_state = TIME_DEL;",
            "\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);",
            "\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase TIME_INS:",
            "\t\tif (!(time_status & STA_INS)) {",
            "\t\t\tntp_next_leap_sec = TIME64_MAX;",
            "\t\t\ttime_state = TIME_OK;",
            "\t\t} else if (secs == ntp_next_leap_sec) {",
            "\t\t\tleap = -1;",
            "\t\t\ttime_state = TIME_OOP;",
            "\t\t\tprintk(KERN_NOTICE",
            "\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");",
            "\t\t}",
            "\t\tbreak;",
            "\tcase TIME_DEL:",
            "\t\tif (!(time_status & STA_DEL)) {",
            "\t\t\tntp_next_leap_sec = TIME64_MAX;",
            "\t\t\ttime_state = TIME_OK;",
            "\t\t} else if (secs == ntp_next_leap_sec) {",
            "\t\t\tleap = 1;",
            "\t\t\tntp_next_leap_sec = TIME64_MAX;",
            "\t\t\ttime_state = TIME_WAIT;",
            "\t\t\tprintk(KERN_NOTICE",
            "\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");",
            "\t\t}",
            "\t\tbreak;",
            "\tcase TIME_OOP:",
            "\t\tntp_next_leap_sec = TIME64_MAX;",
            "\t\ttime_state = TIME_WAIT;",
            "\t\tbreak;",
            "\tcase TIME_WAIT:",
            "\t\tif (!(time_status & (STA_INS | STA_DEL)))",
            "\t\t\ttime_state = TIME_OK;",
            "\t\tbreak;",
            "\t}",
            "",
            "",
            "\t/* Bump the maxerror field */",
            "\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;",
            "\tif (time_maxerror > NTP_PHASE_LIMIT) {",
            "\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "\t\ttime_status |= STA_UNSYNC;",
            "\t}",
            "",
            "\t/* Compute the phase adjustment for the next second */",
            "\ttick_length\t = tick_length_base;",
            "",
            "\tdelta\t\t = ntp_offset_chunk(time_offset);",
            "\ttime_offset\t-= delta;",
            "\ttick_length\t+= delta;",
            "",
            "\t/* Check PPS signal */",
            "\tpps_dec_valid();",
            "",
            "\tif (!time_adjust)",
            "\t\tgoto out;",
            "",
            "\tif (time_adjust > MAX_TICKADJ) {",
            "\t\ttime_adjust -= MAX_TICKADJ;",
            "\t\ttick_length += MAX_TICKADJ_SCALED;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (time_adjust < -MAX_TICKADJ) {",
            "\t\ttime_adjust += MAX_TICKADJ;",
            "\t\ttick_length -= MAX_TICKADJ_SCALED;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)",
            "\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;",
            "\ttime_adjust = 0;",
            "",
            "out:",
            "\treturn leap;",
            "}"
          ],
          "function_name": "ntp_update_offset_fll, ntp_update_offset, ntp_clear, ntp_tick_length, ntp_get_next_leap, second_overflow",
          "description": "实现时间偏移更新算法、闰秒处理逻辑及频率调整机制，维护系统时间与参考源的一致性。",
          "similarity": 0.4739953875541687
        }
      ]
    },
    {
      "source_file": "kernel/time/ntp_internal.h",
      "md_summary": "> 自动生成时间: 2025-10-25 16:42:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\ntp_internal.h`\n\n---\n\n# `time/ntp_internal.h` 技术文档\n\n## 1. 文件概述\n\n`ntp_internal.h` 是 Linux 内核中网络时间协议（NTP）子系统的内部头文件，定义了 NTP 核心功能的内部接口。该文件为内核时间管理子系统提供高精度时间同步、闰秒处理、时钟调整等关键功能的底层支持，主要供内核内部模块（如时间子系统、RTC 驱动等）调用，不对外暴露给用户空间。\n\n## 2. 核心功能\n\n### 外部函数声明\n\n- **`ntp_init(void)`**  \n  初始化 NTP 子系统，设置初始状态和参数。\n\n- **`ntp_clear(void)`**  \n  清除 NTP 子系统的状态，通常在系统关闭或重置时调用。\n\n- **`ntp_tick_length(void) -> u64`**  \n  返回当前系统时钟 tick 的长度，单位为纳秒除以 \\(2^{\\text{NTP\\_SCALE\\_SHIFT}}\\)，用于高精度时间计算。\n\n- **`ntp_get_next_leap(void) -> ktime_t`**  \n  获取下一次闰秒事件发生的时间点（ktime_t 格式），若无计划中的闰秒则返回特殊值。\n\n- **`second_overflow(time64_t secs) -> int`**  \n  处理整秒溢出事件（如闰秒插入/删除），根据传入的秒数判断是否需要执行闰秒逻辑，并返回状态码。\n\n- **`__do_adjtimex(struct __kernel_timex *txc, const struct timespec64 *ts, s32 *time_tai, struct audit_ntp_data *ad) -> int`**  \n  执行底层时间调整操作，是 `adjtimex` 系统调用的核心实现，支持频率、相位、状态等参数的精细控制，并集成审计日志功能。\n\n- **`__hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)`**  \n  处理硬件脉冲每秒（PPS）信号，用于高精度时间同步，接收相位参考时间和原始时间戳。\n\n- **`ntp_notify_cmos_timer(void)`**  \n  通知 CMOS/RTC 时间更新事件。仅在启用 `CONFIG_GENERIC_CMOS_UPDATE` 或 `CONFIG_RTC_SYSTOHC` 时有效，否则为空内联函数。\n\n## 3. 关键实现\n\n- **高精度时间表示**：`ntp_tick_length()` 使用缩放因子 `NTP_SCALE_SHIFT`（通常为 32）将纳秒值转换为定点数，避免浮点运算，提升性能和精度。\n  \n- **闰秒处理机制**：通过 `second_overflow()` 和 `ntp_get_next_leap()` 协同工作，在内核时间推进过程中动态插入或跳过一秒，确保 UTC 时间与 TAI 时间的正确偏移。\n\n- **时间调整原子性**：`__do_adjtimex()` 在持有时间子系统锁的前提下修改全局时间参数，保证多线程环境下的数据一致性。\n\n- **PPS 硬件支持**：`__hardpps()` 接收来自硬件的精确时间戳，用于校准系统时钟，是实现亚微秒级时间同步的关键路径。\n\n- **条件编译优化**：`ntp_notify_cmos_timer()` 根据配置选项动态启用/禁用，避免在不支持 CMOS/RTC 同步的系统中引入无用代码。\n\n## 4. 依赖关系\n\n- **依赖头文件**：\n  - `<linux/types.h>`：提供 `u64`、`s32` 等基本类型\n  - `<linux/ktime.h>`：提供 `ktime_t` 时间类型\n  - `<linux/time64.h>`：提供 `time64_t` 和 `timespec64`\n  - `<uapi/linux/timex.h>`：提供 `__kernel_timex` 结构\n  - `<linux/audit.h>`：提供 `audit_ntp_data`（若启用审计）\n\n- **被依赖模块**：\n  - `kernel/time/ntp.c`：实现上述函数的具体逻辑\n  - `kernel/time/timekeeping.c`：调用 NTP 接口进行时间维护\n  - `drivers/rtc/`：在 RTC 同步时调用 `ntp_notify_cmos_timer()`\n  - `kernel/auditsc.c`：在时间调整审计中使用 `audit_ntp_data`\n\n- **配置依赖**：\n  - `CONFIG_GENERIC_CMOS_UPDATE` 或 `CONFIG_RTC_SYSTOHC`：决定是否启用 CMOS 通知功能\n\n## 5. 使用场景\n\n- **系统启动/关闭**：通过 `ntp_init()` 和 `ntp_clear()` 初始化和清理 NTP 状态。\n- **时间同步服务**：`ntpd`、`chronyd` 等用户空间守护进程通过 `adjtimex` 系统调用间接调用 `__do_adjtimex()` 调整系统时钟。\n- **闰秒事件处理**：在每秒时间更新路径中调用 `second_overflow()` 检测并处理闰秒。\n- **高精度时间源接入**：GPS 或原子钟等设备通过 PPS 信号触发 `__hardpps()` 实现纳秒级同步。\n- **RTC 时间回写**：当系统时间稳定后，通过 `ntp_notify_cmos_timer()` 触发将时间写入 CMOS/RTC 硬件。",
      "similarity": 0.6027794480323792,
      "chunks": []
    },
    {
      "source_file": "kernel/async.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:49:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `async.c`\n\n---\n\n# async.c 技术文档\n\n## 1. 文件概述\n\n`async.c` 实现了 Linux 内核中的异步函数调用机制，主要用于优化系统启动性能。该机制允许在内核初始化阶段将原本串行执行的、相互独立的硬件探测和初始化操作并行化，从而显著缩短启动时间。其核心思想是在保持对外可见操作顺序一致性的前提下，内部执行过程可乱序进行，类似于乱序执行 CPU 的“按序提交”语义。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct async_entry`**：表示一个异步任务条目，包含：\n  - `domain_list` / `global_list`：分别链接到所属域和全局的待处理链表\n  - `work`：关联的 workqueue 工作项\n  - `cookie`：序列号，用于同步控制\n  - `func` / `data`：要执行的函数及其参数\n  - `domain`：所属的异步域\n\n- **`struct async_domain`**：异步执行域，用于将异步任务分组管理，默认使用 `async_dfl_domain`\n\n- **全局变量**：\n  - `next_cookie`：单调递增的序列号生成器\n  - `async_global_pending`：所有已注册域的全局待处理任务链表\n  - `async_dfl_domain`：默认异步域\n  - `async_lock`：保护异步任务队列的自旋锁\n  - `entry_count`：当前挂起的异步任务计数\n\n### 主要函数\n\n- **`async_schedule_node_domain()`**：在指定 NUMA 节点和异步域中调度异步函数\n- **`async_schedule_node()`**：在指定 NUMA 节点上调度异步函数（使用默认域）\n- **`async_schedule_dev_nocall()`**：基于设备的 NUMA 信息调度异步函数（失败时不回退到同步执行）\n- **`lowest_in_progress()`**：获取指定域或全局中最早（最小 cookie）的未完成任务\n- **`async_run_entry_fn()`**：workqueue 回调函数，实际执行异步任务并清理资源\n\n## 3. 关键实现\n\n### 序列 Cookie 机制\n- 每个异步任务分配一个单调递增的 `async_cookie_t`（64 位无符号整数）\n- 任务执行前可通过 `async_synchronize_cookie()` 等待所有小于等于指定 cookie 的任务完成\n- 保证对外部可见操作（如设备注册）的顺序一致性\n\n### 内存与负载控制\n- 使用 `GFP_ATOMIC` 分配内存，支持原子上下文调用\n- 当内存不足或挂起任务超过 `MAX_WORK`（32768）时，自动回退到同步执行\n- 通过 `entry_count` 原子计数器跟踪挂起任务数量\n\n### 双链表管理\n- 每个任务同时链接到：\n  - 所属域的 `domain->pending` 链表（按 cookie 顺序）\n  - 全局 `async_global_pending` 链表（仅当域已注册）\n- 保证域内和全局的同步操作都能正确等待\n\n### NUMA 感知调度\n- 通过 `queue_work_node()` 将任务调度到指定 NUMA 节点\n- 若节点无效则自动分发到可用 CPU\n\n### 资源清理与通知\n- 任务执行完成后从链表移除并释放内存\n- 通过 `wake_up(&async_done)` 唤醒等待同步完成的线程\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/async.h>`：异步 API 定义\n  - `<linux/workqueue.h>`：工作队列机制\n  - `\"workqueue_internal.h\"`：内部 workqueue 接口\n  - 其他基础内核头文件（atomic、slab、wait 等）\n\n- **核心子系统**：\n  - **Workqueue 子系统**：实际执行异步任务的底层机制\n  - **内存管理子系统**：任务结构体内存分配\n  - **调度器**：NUMA 节点感知的任务调度\n\n- **导出符号**：\n  - `async_schedule_node_domain`\n  - `async_schedule_node`\n\n## 5. 使用场景\n\n- **内核启动优化**：\n  - 并行执行设备探测（如 PCI、USB 控制器初始化）\n  - 异步加载固件或执行硬件自检\n\n- **驱动初始化**：\n  - 驱动可将耗时的初始化操作（如 PHY 配置、固件加载）放入异步任务\n  - 通过 `async_synchronize_full()` 确保在模块初始化完成前所有异步任务结束\n\n- **NUMA 优化**：\n  - 将设备相关的初始化任务调度到设备所在 NUMA 节点，减少远程内存访问\n\n- **资源受限环境**：\n  - 在内存压力下自动回退到同步执行，保证系统稳定性\n  - 通过 `MAX_WORK` 限制防止异步任务无限堆积",
      "similarity": 0.5513826608657837,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/async.c",
          "start_line": 241,
          "end_line": 290,
          "content": [
            "async_cookie_t async_schedule_node(async_func_t func, void *data, int node)",
            "{",
            "\treturn async_schedule_node_domain(func, data, node, &async_dfl_domain);",
            "}",
            "bool async_schedule_dev_nocall(async_func_t func, struct device *dev)",
            "{",
            "\tstruct async_entry *entry;",
            "",
            "\tentry = kzalloc(sizeof(struct async_entry), GFP_KERNEL);",
            "",
            "\t/* Give up if there is no memory or too much work. */",
            "\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {",
            "\t\tkfree(entry);",
            "\t\treturn false;",
            "\t}",
            "",
            "\t__async_schedule_node_domain(func, dev, dev_to_node(dev),",
            "\t\t\t\t     &async_dfl_domain, entry);",
            "\treturn true;",
            "}",
            "void async_synchronize_full(void)",
            "{",
            "\tasync_synchronize_full_domain(NULL);",
            "}",
            "void async_synchronize_full_domain(struct async_domain *domain)",
            "{",
            "\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);",
            "}",
            "void async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)",
            "{",
            "\tktime_t starttime;",
            "",
            "\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));",
            "\tstarttime = ktime_get();",
            "",
            "\twait_event(async_done, lowest_in_progress(domain) >= cookie);",
            "",
            "\tpr_debug(\"async_continuing @ %i after %lli usec\\n\", task_pid_nr(current),",
            "\t\t microseconds_since(starttime));",
            "}",
            "void async_synchronize_cookie(async_cookie_t cookie)",
            "{",
            "\tasync_synchronize_cookie_domain(cookie, &async_dfl_domain);",
            "}",
            "bool current_is_async(void)",
            "{",
            "\tstruct worker *worker = current_wq_worker();",
            "",
            "\treturn worker && worker->current_func == async_run_entry_fn;",
            "}"
          ],
          "function_name": "async_schedule_node, async_schedule_dev_nocall, async_synchronize_full, async_synchronize_full_domain, async_synchronize_cookie_domain, async_synchronize_cookie, current_is_async",
          "description": "提供同步屏障接口和运行态检测，确保异步操作有序完成",
          "similarity": 0.5027428269386292
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/async.c",
          "start_line": 82,
          "end_line": 201,
          "content": [
            "static long long microseconds_since(ktime_t start)",
            "{",
            "\tktime_t now = ktime_get();",
            "\treturn ktime_to_ns(ktime_sub(now, start)) >> 10;",
            "}",
            "static async_cookie_t lowest_in_progress(struct async_domain *domain)",
            "{",
            "\tstruct async_entry *first = NULL;",
            "\tasync_cookie_t ret = ASYNC_COOKIE_MAX;",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&async_lock, flags);",
            "",
            "\tif (domain) {",
            "\t\tif (!list_empty(&domain->pending))",
            "\t\t\tfirst = list_first_entry(&domain->pending,",
            "\t\t\t\t\tstruct async_entry, domain_list);",
            "\t} else {",
            "\t\tif (!list_empty(&async_global_pending))",
            "\t\t\tfirst = list_first_entry(&async_global_pending,",
            "\t\t\t\t\tstruct async_entry, global_list);",
            "\t}",
            "",
            "\tif (first)",
            "\t\tret = first->cookie;",
            "",
            "\tspin_unlock_irqrestore(&async_lock, flags);",
            "\treturn ret;",
            "}",
            "static void async_run_entry_fn(struct work_struct *work)",
            "{",
            "\tstruct async_entry *entry =",
            "\t\tcontainer_of(work, struct async_entry, work);",
            "\tunsigned long flags;",
            "\tktime_t calltime;",
            "",
            "\t/* 1) run (and print duration) */",
            "\tpr_debug(\"calling  %lli_%pS @ %i\\n\", (long long)entry->cookie,",
            "\t\t entry->func, task_pid_nr(current));",
            "\tcalltime = ktime_get();",
            "",
            "\tentry->func(entry->data, entry->cookie);",
            "",
            "\tpr_debug(\"initcall %lli_%pS returned after %lld usecs\\n\",",
            "\t\t (long long)entry->cookie, entry->func,",
            "\t\t microseconds_since(calltime));",
            "",
            "\t/* 2) remove self from the pending queues */",
            "\tspin_lock_irqsave(&async_lock, flags);",
            "\tlist_del_init(&entry->domain_list);",
            "\tlist_del_init(&entry->global_list);",
            "",
            "\t/* 3) free the entry */",
            "\tkfree(entry);",
            "\tatomic_dec(&entry_count);",
            "",
            "\tspin_unlock_irqrestore(&async_lock, flags);",
            "",
            "\t/* 4) wake up any waiters */",
            "\twake_up(&async_done);",
            "}",
            "static async_cookie_t __async_schedule_node_domain(async_func_t func,",
            "\t\t\t\t\t\t   void *data, int node,",
            "\t\t\t\t\t\t   struct async_domain *domain,",
            "\t\t\t\t\t\t   struct async_entry *entry)",
            "{",
            "\tasync_cookie_t newcookie;",
            "\tunsigned long flags;",
            "",
            "\tINIT_LIST_HEAD(&entry->domain_list);",
            "\tINIT_LIST_HEAD(&entry->global_list);",
            "\tINIT_WORK(&entry->work, async_run_entry_fn);",
            "\tentry->func = func;",
            "\tentry->data = data;",
            "\tentry->domain = domain;",
            "",
            "\tspin_lock_irqsave(&async_lock, flags);",
            "",
            "\t/* allocate cookie and queue */",
            "\tnewcookie = entry->cookie = next_cookie++;",
            "",
            "\tlist_add_tail(&entry->domain_list, &domain->pending);",
            "\tif (domain->registered)",
            "\t\tlist_add_tail(&entry->global_list, &async_global_pending);",
            "",
            "\tatomic_inc(&entry_count);",
            "\tspin_unlock_irqrestore(&async_lock, flags);",
            "",
            "\t/* schedule for execution */",
            "\tqueue_work_node(node, system_unbound_wq, &entry->work);",
            "",
            "\treturn newcookie;",
            "}",
            "async_cookie_t async_schedule_node_domain(async_func_t func, void *data,",
            "\t\t\t\t\t  int node, struct async_domain *domain)",
            "{",
            "\tstruct async_entry *entry;",
            "\tunsigned long flags;",
            "\tasync_cookie_t newcookie;",
            "",
            "\t/* allow irq-off callers */",
            "\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);",
            "",
            "\t/*",
            "\t * If we're out of memory or if there's too much work",
            "\t * pending already, we execute synchronously.",
            "\t */",
            "\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {",
            "\t\tkfree(entry);",
            "\t\tspin_lock_irqsave(&async_lock, flags);",
            "\t\tnewcookie = next_cookie++;",
            "\t\tspin_unlock_irqrestore(&async_lock, flags);",
            "",
            "\t\t/* low on memory.. run synchronously */",
            "\t\tfunc(data, newcookie);",
            "\t\treturn newcookie;",
            "\t}",
            "",
            "\treturn __async_schedule_node_domain(func, data, node, domain, entry);",
            "}"
          ],
          "function_name": "microseconds_since, lowest_in_progress, async_run_entry_fn, __async_schedule_node_domain, async_schedule_node_domain",
          "description": "实现异步任务调度与执行逻辑，包含时间测量、任务排队及工作队列调度",
          "similarity": 0.4477722644805908
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/async.c",
          "start_line": 1,
          "end_line": 81,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * async.c: Asynchronous function calls for boot performance",
            " *",
            " * (C) Copyright 2009 Intel Corporation",
            " * Author: Arjan van de Ven <arjan@linux.intel.com>",
            " */",
            "",
            "",
            "/*",
            "",
            "Goals and Theory of Operation",
            "",
            "The primary goal of this feature is to reduce the kernel boot time,",
            "by doing various independent hardware delays and discovery operations",
            "decoupled and not strictly serialized.",
            "",
            "More specifically, the asynchronous function call concept allows",
            "certain operations (primarily during system boot) to happen",
            "asynchronously, out of order, while these operations still",
            "have their externally visible parts happen sequentially and in-order.",
            "(not unlike how out-of-order CPUs retire their instructions in order)",
            "",
            "Key to the asynchronous function call implementation is the concept of",
            "a \"sequence cookie\" (which, although it has an abstracted type, can be",
            "thought of as a monotonically incrementing number).",
            "",
            "The async core will assign each scheduled event such a sequence cookie and",
            "pass this to the called functions.",
            "",
            "The asynchronously called function should before doing a globally visible",
            "operation, such as registering device numbers, call the",
            "async_synchronize_cookie() function and pass in its own cookie. The",
            "async_synchronize_cookie() function will make sure that all asynchronous",
            "operations that were scheduled prior to the operation corresponding with the",
            "cookie have completed.",
            "",
            "Subsystem/driver initialization code that scheduled asynchronous probe",
            "functions, but which shares global resources with other drivers/subsystems",
            "that do not use the asynchronous call feature, need to do a full",
            "synchronization with the async_synchronize_full() function, before returning",
            "from their init function. This is to maintain strict ordering between the",
            "asynchronous and synchronous parts of the kernel.",
            "",
            "*/",
            "",
            "#include <linux/async.h>",
            "#include <linux/atomic.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/pid.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/workqueue.h>",
            "",
            "#include \"workqueue_internal.h\"",
            "",
            "static async_cookie_t next_cookie = 1;",
            "",
            "#define MAX_WORK\t\t32768",
            "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */",
            "",
            "static LIST_HEAD(async_global_pending);\t/* pending from all registered doms */",
            "static ASYNC_DOMAIN(async_dfl_domain);",
            "static DEFINE_SPINLOCK(async_lock);",
            "",
            "struct async_entry {",
            "\tstruct list_head\tdomain_list;",
            "\tstruct list_head\tglobal_list;",
            "\tstruct work_struct\twork;",
            "\tasync_cookie_t\t\tcookie;",
            "\tasync_func_t\t\tfunc;",
            "\tvoid\t\t\t*data;",
            "\tstruct async_domain\t*domain;",
            "};",
            "",
            "static DECLARE_WAIT_QUEUE_HEAD(async_done);",
            "",
            "static atomic_t entry_count;",
            ""
          ],
          "function_name": null,
          "description": "定义异步任务结构体和核心变量，支持多域异步调度",
          "similarity": 0.36811912059783936
        }
      ]
    }
  ]
}