{
  "query": "file system security",
  "timestamp": "2025-12-26 00:19:23",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/bpf_inode_storage.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:57:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_inode_storage.c`\n\n---\n\n# `bpf/bpf_inode_storage.c` 技术文档\n\n## 1. 文件概述\n\n`bpf_inode_storage.c` 实现了 BPF（Berkeley Packet Filter）程序对 **inode 级别本地存储（local storage）** 的支持。该机制允许 BPF 程序将任意用户定义的数据与内核中的 `struct inode` 实例关联，从而在不修改 VFS 层或文件系统代码的前提下，为 inode 附加自定义元数据。此功能主要用于 LSM（Linux Security Module）钩子、审计、追踪等场景。\n\n该文件基于通用的 `bpf_local_storage` 框架，为 inode 对象定制了存储管理逻辑，并提供了 BPF 辅助函数（helpers）和 map 操作接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `DEFINE_BPF_STORAGE_CACHE(inode_cache)`：为 inode 存储分配的专用内存缓存。\n- `inode_storage_map_ops`：`bpf_map_ops` 操作集，定义了 inode 存储 map 的行为。\n- `bpf_inode_storage_btf_ids`：BTF（BPF Type Format）类型 ID 列表，用于类型安全检查。\n\n### 关键函数\n- **存储访问与管理**\n  - `inode_storage_ptr()`：获取 inode 对应的 BPF 存储指针。\n  - `inode_storage_lookup()`：在指定 inode 和 map 中查找存储数据。\n  - `bpf_inode_storage_free()`：在 inode 销毁时释放其关联的 BPF 存储。\n  - `inode_storage_delete()`：从 inode 中删除指定 map 的存储项。\n\n- **BPF Map 操作接口**\n  - `bpf_fd_inode_storage_lookup_elem()`：通过文件描述符（fd）查找 inode 存储数据。\n  - `bpf_fd_inode_storage_update_elem()`：通过 fd 更新 inode 存储。\n  - `bpf_fd_inode_storage_delete_elem()`：通过 fd 删除 inode 存储。\n\n- **BPF 辅助函数（Helpers）**\n  - `bpf_inode_storage_get()`：BPF 程序调用的辅助函数，用于获取或创建 inode 存储。\n  - `bpf_inode_storage_delete()`：BPF 程序调用的辅助函数，用于删除 inode 存储。\n\n- **Map 生命周期管理**\n  - `inode_storage_map_alloc()`：分配 inode 存储类型的 BPF map。\n  - `inode_storage_map_free()`：释放该类型 map。\n\n## 3. 关键实现\n\n### 存储绑定机制\n- 每个 `struct inode` 通过 `bpf_inode()` 宏访问其内嵌的 `struct bpf_storage_blob`（通常位于 inode 的安全字段或扩展字段中）。\n- `bpf_storage_blob` 包含一个 RCU 保护的 `struct bpf_local_storage *storage` 指针，指向实际的存储容器。\n- 所有存储操作均通过 `bpf_local_storage` 通用框架完成，确保线程安全和内存管理一致性。\n\n### RCU 与锁策略\n- 查找操作使用 `rcu_read_lock()` 保护，避免持有写锁。\n- 更新/删除操作在必要时使用自旋锁（由 `bpf_local_storage_update` 内部处理）。\n- `bpf_inode_storage_get` 要求调用者已持有 RCU 锁（通过 `bpf_rcu_lock_held()` 验证），确保 inode 不会在操作期间被释放。\n\n### 内存分配策略\n- 存储项分配使用 `GFP_ATOMIC`（在 fd-based 接口）或由 verifier 传入的 `gfp_flags`（在 helper 中），以适应不同上下文（如中断、软中断）。\n- 使用专用 SLAB 缓存 `inode_cache` 优化内存分配性能。\n\n### BPF Map 与 Helper 集成\n- 提供两种访问路径：\n  1. **BPF 程序直接调用 helper**（如 `bpf_inode_storage_get`），传入 `struct inode *`。\n  2. **用户空间通过 fd 操作 map**（如 `bpf_map_lookup_elem`），内核自动解析 fd 到 inode。\n- `map_get_next_key` 返回 `-ENOTSUPP`，表明该 map 不支持迭代。\n\n### 类型安全\n- 通过 BTF 类型 ID (`bpf_inode_storage_btf_ids`) 确保 BPF 程序传入的 `inode` 指针类型正确。\n- `arg2_type = ARG_PTR_TO_BTF_ID_OR_NULL` 允许传入空指针（安全处理）。\n\n## 4. 依赖关系\n\n- **核心依赖**\n  - `<linux/bpf_local_storage.h>`：提供通用本地存储框架。\n  - `<linux/bpf.h>`：BPF 核心基础设施。\n  - `<linux/rculist.h>` / `<linux/spinlock.h>`：并发控制原语。\n  - `<linux/fdtable.h>`：fd 解析支持。\n\n- **关联子系统**\n  - **VFS（Virtual File System）**：依赖 `struct inode` 结构及生命周期管理。\n  - **BPF 子系统**：集成到 BPF map 和 helper 机制中。\n  - **LSM（Linux Security Modules）**：常用于在 LSM 钩子中附加安全上下文。\n  - **BTF（BPF Type Format）**：用于运行时类型验证。\n\n- **内存管理**\n  - 依赖 SLAB 分配器创建专用缓存 `inode_cache`。\n  - 与 RCU 机制深度集成，确保存储项安全回收。\n\n## 5. 使用场景\n\n1. **LSM 安全策略扩展**\n   - 在 LSM 钩子（如 `file_open`、`inode_permission`）中，BPF 程序可为 inode 附加自定义安全标签或策略数据。\n\n2. **文件系统审计与监控**\n   - 追踪特定 inode 的访问模式，记录额外审计信息（如首次访问时间、访问者 UID）。\n\n3. **资源配额与限制**\n   - 为 inode 关联配额计数器，实现细粒度资源控制（如单个文件的 I/O 限速）。\n\n4. **调试与性能分析**\n   - 在 BPF 程序中为热点 inode 附加调试信息，辅助性能调优。\n\n5. **用户空间工具集成**\n   - 通过 fd 操作 map，用户空间程序可查询/修改 inode 的 BPF 存储（如 `bpftool` 调试）。\n\n> **注意**：由于 inode 可能被频繁创建/销毁，BPF 程序必须确保在安全上下文中调用 helper（如持有 inode 引用或处于 RCU 临界区），避免访问已释放内存。",
      "similarity": 0.5743445754051208,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 57,
          "end_line": 121,
          "content": [
            "void bpf_inode_storage_free(struct inode *inode)",
            "{",
            "\tstruct bpf_local_storage *local_storage;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "",
            "\tlocal_storage = rcu_dereference(bsb->storage);",
            "\tif (!local_storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn;",
            "\t}",
            "",
            "\tbpf_local_storage_destroy(local_storage);",
            "\trcu_read_unlock();",
            "}",
            "static long bpf_fd_inode_storage_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t\t     void *value, u64 map_flags)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\tif (!inode_storage_ptr(file_inode(fd_file(f))))",
            "\t\treturn -EBADF;",
            "",
            "\tsdata = bpf_local_storage_update(file_inode(fd_file(f)),",
            "\t\t\t\t\t (struct bpf_local_storage_map *)map,",
            "\t\t\t\t\t value, map_flags, false, GFP_ATOMIC);",
            "\treturn PTR_ERR_OR_ZERO(sdata);",
            "}",
            "static int inode_storage_delete(struct inode *inode, struct bpf_map *map)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "",
            "\tsdata = inode_storage_lookup(inode, map, false);",
            "\tif (!sdata)",
            "\t\treturn -ENOENT;",
            "",
            "\tbpf_selem_unlink(SELEM(sdata), false);",
            "",
            "\treturn 0;",
            "}",
            "static long bpf_fd_inode_storage_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\treturn inode_storage_delete(file_inode(fd_file(f)), map);",
            "}",
            "static int notsupp_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\tvoid *next_key)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static void inode_storage_map_free(struct bpf_map *map)",
            "{",
            "\tbpf_local_storage_map_free(map, &inode_cache, NULL);",
            "}"
          ],
          "function_name": "bpf_inode_storage_free, bpf_fd_inode_storage_update_elem, inode_storage_delete, bpf_fd_inode_storage_delete_elem, notsupp_get_next_key, inode_storage_map_free",
          "description": "实现inode相关BPF存储资源的释放、更新、删除操作。包含释放存储空间、通过文件描述符更新存储项、删除存储条目等功能，同时注册了不支持的get_next_key操作并实现map销毁时的缓存回收逻辑。",
          "similarity": 0.5003745555877686
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 1,
          "end_line": 56,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (c) 2019 Facebook",
            " * Copyright 2020 Google LLC.",
            " */",
            "",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/rcupdate_trace.h>",
            "",
            "DEFINE_BPF_STORAGE_CACHE(inode_cache);",
            "",
            "static struct bpf_local_storage __rcu **",
            "inode_storage_ptr(void *owner)",
            "{",
            "\tstruct inode *inode = owner;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "\treturn &bsb->storage;",
            "}",
            "",
            "static struct bpf_local_storage_data *inode_storage_lookup(struct inode *inode,",
            "\t\t\t\t\t\t\t   struct bpf_map *map,",
            "\t\t\t\t\t\t\t   bool cacheit_lockit)",
            "{",
            "\tstruct bpf_local_storage *inode_storage;",
            "\tstruct bpf_local_storage_map *smap;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "",
            "\tinode_storage =",
            "\t\trcu_dereference_check(bsb->storage, bpf_rcu_lock_held());",
            "\tif (!inode_storage)",
            "\t\treturn NULL;",
            "",
            "\tsmap = (struct bpf_local_storage_map *)map;",
            "\treturn bpf_local_storage_lookup(inode_storage, smap, cacheit_lockit);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义inode级别的BPF本地存储缓存inode_cache，并提供用于获取inode存储指针及查询特定map中存储数据的辅助函数。其中inode_storage_lookup通过RCU读锁安全地检索存储实例并调用底层BPF本地存储查找逻辑。",
          "similarity": 0.47442004084587097
        }
      ]
    },
    {
      "source_file": "mm/memfd.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:40:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memfd.c`\n\n---\n\n# memfd.c 技术文档\n\n## 1. 文件概述\n\n`memfd.c` 实现了 Linux 内核中的 `memfd_create()` 系统调用及其配套的文件密封（file sealing）机制。该文件最初是 `shmem.c` 的一部分，后被拆分出来以同时支持 tmpfs 和 hugetlbfs 文件系统。其核心功能包括：\n\n- 创建匿名内存文件（memfd），无需关联磁盘或文件系统路径\n- 提供文件密封（sealing）能力，允许对共享内存区域施加不可逆的操作限制\n- 支持普通页和大页（hugetlb）两种内存分配模式\n- 通过引用计数检测和等待机制确保密封操作的安全性\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|---------|\n| `memfd_alloc_folio()` | 为 memfd 文件分配 folio（页），支持普通页和大页模式 |\n| `memfd_wait_for_pins()` | 等待所有被外部引用（如 GUP、DMA）的 folio 释放，用于 SEAL_WRITE 密封前的安全检查 |\n| `memfd_tag_pins()` | 扫描地址空间，标记具有额外引用计数的 folio |\n| `memfd_add_seals()` | 向文件添加密封标志，实现不可逆的访问控制 |\n| `memfd_get_seals()` | 获取文件当前的密封标志 |\n| `memfd_fcntl()` | 处理 F_ADD_SEALS 和 F_GET_SEALS fcntl 命令 |\n\n### 关键数据结构和常量\n\n- **密封标志**：\n  - `F_SEAL_SEAL`：禁止进一步添加密封\n  - `F_SEAL_WRITE`：禁止写入\n  - `F_SEAL_GROW/SHRINK`：禁止文件增长/缩小\n  - `F_SEAL_EXEC`：禁止修改执行权限位\n  - `F_SEAL_FUTURE_WRITE`：禁止未来写入（与 EXEC 相关）\n\n- **memfd 标志**：\n  - `MFD_CLOEXEC`：close-on-exec\n  - `MFD_ALLOW_SEALING`：允许密封\n  - `MFD_HUGETLB`：使用大页\n  - `MFD_NOEXEC_SEAL` / `MFD_EXEC`：控制执行权限\n\n- **内部标记**：\n  - `MEMFD_TAG_PINNED`：复用 `PAGECACHE_TAG_TOWRITE` 标记被外部引用的 folio\n\n## 3. 关键实现\n\n### 文件密封机制\n\n密封是一种**单向、不可逆**的访问控制机制：\n- 密封只能添加，不能移除\n- 一旦设置 `F_SEAL_SEAL`，不能再添加任何密封\n- 密封作用于整个 inode，影响所有文件描述符\n\n### 引用计数检测算法\n\n为安全实现 `SEAL_WRITE`，内核需确保无外部引用：\n1. **标记阶段** (`memfd_tag_pins`)：\n   - 遍历 radix tree 中的所有 folio\n   - 对 `folio_ref_count() - folio_mapcount() != folio_nr_pages()` 的 folio 标记为 PINNED\n   - 表示存在非映射引用（如 GUP、DMA）\n\n2. **等待阶段** (`memfd_wait_for_pins`)：\n   - 最多进行 5 次扫描（LAST_SCAN = 4）\n   - 指数退避等待（(HZ << scan) / 200）\n   - 最后一次扫描清理标记并返回 `-EBUSY`（如有残留引用）\n\n### 大页支持\n\n通过条件编译支持 hugetlbfs：\n- 检测 `is_file_hugepages()` 判断是否大页模式\n- 使用 `htlb_alloc_mask()` 并清除 `__GFP_HIGHMEM | __GFP_MOVABLE`\n- 调用 hugetlb 专用分配和缓存接口\n\n### 执行权限密封\n\n`F_SEAL_EXEC` 具有特殊语义：\n- 若文件已有执行权限（`i_mode & 0111`），自动添加 `WRITE|GROW|SHRINK|FUTURE_WRITE` 密封\n- 实现 W^X（Write XOR Execute）安全策略\n\n## 4. 依赖关系\n\n### 内核模块依赖\n\n- **内存管理**：\n  - `<linux/mm.h>`：folio 操作、GFP 标志\n  - `<linux/pagemap.h>`：address_space、radix tree 操作\n  - `<linux/shmem_fs.h>`：tmpfs inode 结构（`SHMEM_I`）\n  \n- **文件系统**：\n  - `<linux/hugetlb.h>`：大页支持（`HUGETLBFS_I`）\n  - `<linux/fs.h>` / `<linux/vfs.h>`：VFS 层接口\n  \n- **同步机制**：\n  - `<linux/sched/signal.h>`：可杀等待（`schedule_timeout_killable`）\n  - XArray 锁（`xas_lock_irq`）保证并发安全\n\n### 复用设计\n\n- **标记复用**：使用 `PAGECACHE_TAG_TOWRITE` 作为 `MEMFD_TAG_PINNED`，因 tmpfs/hugetlbfs 不使用此标记\n- **代码共享**：同时服务 tmpfs 和 hugetlbfs，通过 `memfd_file_seals_ptr()` 抽象 inode 访问\n\n## 5. 使用场景\n\n### 用户态应用场景\n\n1. **安全共享内存**：\n   - 多进程通过 `memfd_create()` 创建共享内存\n   - 生产者添加 `SEAL_WRITE` 后传递 fd 给消费者，确保数据不可篡改\n\n2. **动态代码加载**：\n   - JIT 编译器创建可执行 memfd\n   - 写入代码后密封 `SEAL_WRITE`，防止后续修改（配合 `SEAL_EXEC`）\n\n3. **容器/沙箱**：\n   - 限制不受信任进程对共享内存的操作能力\n   - 通过密封防止恶意进程破坏共享状态\n\n### 内核内部使用\n\n1. **GUP（Get User Pages）集成**：\n   - `memfd_alloc_folio()` 被 `gup.c` 调用，处理 memfd 的缺页\n   - 确保 DMA/GUP 场景下密封的安全性\n\n2. **大页优化**：\n   - 通过 `MFD_HUGETLB` 标志创建大页 memfd\n   - 适用于需要大块连续内存的高性能场景（如 DPDK）\n\n3. **安全增强**：\n   - `sysctl_memfd_noexec` 控制默认执行权限\n   - 防止 memfd 被滥用于代码注入攻击",
      "similarity": 0.5708414912223816,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/memfd.c",
          "start_line": 275,
          "end_line": 320,
          "content": [
            "static int memfd_get_seals(struct file *file)",
            "{",
            "\tunsigned int *seals = memfd_file_seals_ptr(file);",
            "",
            "\treturn seals ? *seals : -EINVAL;",
            "}",
            "long memfd_fcntl(struct file *file, unsigned int cmd, unsigned int arg)",
            "{",
            "\tlong error;",
            "",
            "\tswitch (cmd) {",
            "\tcase F_ADD_SEALS:",
            "\t\terror = memfd_add_seals(file, arg);",
            "\t\tbreak;",
            "\tcase F_GET_SEALS:",
            "\t\terror = memfd_get_seals(file);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\terror = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int check_sysctl_memfd_noexec(unsigned int *flags)",
            "{",
            "#ifdef CONFIG_SYSCTL",
            "\tstruct pid_namespace *ns = task_active_pid_ns(current);",
            "\tint sysctl = pidns_memfd_noexec_scope(ns);",
            "",
            "\tif (!(*flags & (MFD_EXEC | MFD_NOEXEC_SEAL))) {",
            "\t\tif (sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_SEAL)",
            "\t\t\t*flags |= MFD_NOEXEC_SEAL;",
            "\t\telse",
            "\t\t\t*flags |= MFD_EXEC;",
            "\t}",
            "",
            "\tif (!(*flags & MFD_NOEXEC_SEAL) && sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_ENFORCED) {",
            "\t\tpr_err_ratelimited(",
            "\t\t\t\"%s[%d]: memfd_create() requires MFD_NOEXEC_SEAL with vm.memfd_noexec=%d\\n\",",
            "\t\t\tcurrent->comm, task_pid_nr(current), sysctl);",
            "\t\treturn -EACCES;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "memfd_get_seals, memfd_fcntl, check_sysctl_memfd_noexec",
          "description": "提供密封信息查询接口(memfd_get_seals)和fcntl命令处理(memfd_fcntl)，check_sysctl_memfd_noexec根据内核配置动态调整内存文件执行权限标志，强制应用noexec安全策略。",
          "similarity": 0.5947775840759277
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memfd.c",
          "start_line": 32,
          "end_line": 194,
          "content": [
            "static bool memfd_folio_has_extra_refs(struct folio *folio)",
            "{",
            "\treturn folio_ref_count(folio) - folio_mapcount(folio) !=",
            "\t       folio_nr_pages(folio);",
            "}",
            "static void memfd_tag_pins(struct xa_state *xas)",
            "{",
            "\tstruct folio *folio;",
            "\tint latency = 0;",
            "",
            "\tlru_add_drain();",
            "",
            "\txas_lock_irq(xas);",
            "\txas_for_each(xas, folio, ULONG_MAX) {",
            "\t\tif (!xa_is_value(folio) && memfd_folio_has_extra_refs(folio))",
            "\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);",
            "",
            "\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\tcontinue;",
            "\t\tlatency = 0;",
            "",
            "\t\txas_pause(xas);",
            "\t\txas_unlock_irq(xas);",
            "\t\tcond_resched();",
            "\t\txas_lock_irq(xas);",
            "\t}",
            "\txas_unlock_irq(xas);",
            "}",
            "static int memfd_wait_for_pins(struct address_space *mapping)",
            "{",
            "\tXA_STATE(xas, &mapping->i_pages, 0);",
            "\tstruct folio *folio;",
            "\tint error, scan;",
            "",
            "\tmemfd_tag_pins(&xas);",
            "",
            "\terror = 0;",
            "\tfor (scan = 0; scan <= LAST_SCAN; scan++) {",
            "\t\tint latency = 0;",
            "",
            "\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))",
            "\t\t\tbreak;",
            "",
            "\t\tif (!scan)",
            "\t\t\tlru_add_drain_all();",
            "\t\telse if (schedule_timeout_killable((HZ << scan) / 200))",
            "\t\t\tscan = LAST_SCAN;",
            "",
            "\t\txas_set(&xas, 0);",
            "\t\txas_lock_irq(&xas);",
            "\t\txas_for_each_marked(&xas, folio, ULONG_MAX, MEMFD_TAG_PINNED) {",
            "\t\t\tbool clear = true;",
            "",
            "\t\t\tif (!xa_is_value(folio) &&",
            "\t\t\t    memfd_folio_has_extra_refs(folio)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * On the last scan, we clean up all those tags",
            "\t\t\t\t * we inserted; but make a note that we still",
            "\t\t\t\t * found folios pinned.",
            "\t\t\t\t */",
            "\t\t\t\tif (scan == LAST_SCAN)",
            "\t\t\t\t\terror = -EBUSY;",
            "\t\t\t\telse",
            "\t\t\t\t\tclear = false;",
            "\t\t\t}",
            "\t\t\tif (clear)",
            "\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);",
            "",
            "\t\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\t\tcontinue;",
            "\t\t\tlatency = 0;",
            "",
            "\t\t\txas_pause(&xas);",
            "\t\t\txas_unlock_irq(&xas);",
            "\t\t\tcond_resched();",
            "\t\t\txas_lock_irq(&xas);",
            "\t\t}",
            "\t\txas_unlock_irq(&xas);",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int memfd_add_seals(struct file *file, unsigned int seals)",
            "{",
            "\tstruct inode *inode = file_inode(file);",
            "\tunsigned int *file_seals;",
            "\tint error;",
            "",
            "\t/*",
            "\t * SEALING",
            "\t * Sealing allows multiple parties to share a tmpfs or hugetlbfs file",
            "\t * but restrict access to a specific subset of file operations. Seals",
            "\t * can only be added, but never removed. This way, mutually untrusted",
            "\t * parties can share common memory regions with a well-defined policy.",
            "\t * A malicious peer can thus never perform unwanted operations on a",
            "\t * shared object.",
            "\t *",
            "\t * Seals are only supported on special tmpfs or hugetlbfs files and",
            "\t * always affect the whole underlying inode. Once a seal is set, it",
            "\t * may prevent some kinds of access to the file. Currently, the",
            "\t * following seals are defined:",
            "\t *   SEAL_SEAL: Prevent further seals from being set on this file",
            "\t *   SEAL_SHRINK: Prevent the file from shrinking",
            "\t *   SEAL_GROW: Prevent the file from growing",
            "\t *   SEAL_WRITE: Prevent write access to the file",
            "\t *   SEAL_EXEC: Prevent modification of the exec bits in the file mode",
            "\t *",
            "\t * As we don't require any trust relationship between two parties, we",
            "\t * must prevent seals from being removed. Therefore, sealing a file",
            "\t * only adds a given set of seals to the file, it never touches",
            "\t * existing seals. Furthermore, the \"setting seals\"-operation can be",
            "\t * sealed itself, which basically prevents any further seal from being",
            "\t * added.",
            "\t *",
            "\t * Semantics of sealing are only defined on volatile files. Only",
            "\t * anonymous tmpfs and hugetlbfs files support sealing. More",
            "\t * importantly, seals are never written to disk. Therefore, there's",
            "\t * no plan to support it on other file types.",
            "\t */",
            "",
            "\tif (!(file->f_mode & FMODE_WRITE))",
            "\t\treturn -EPERM;",
            "\tif (seals & ~(unsigned int)F_ALL_SEALS)",
            "\t\treturn -EINVAL;",
            "",
            "\tinode_lock(inode);",
            "",
            "\tfile_seals = memfd_file_seals_ptr(file);",
            "\tif (!file_seals) {",
            "\t\terror = -EINVAL;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif (*file_seals & F_SEAL_SEAL) {",
            "\t\terror = -EPERM;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {",
            "\t\terror = mapping_deny_writable(file->f_mapping);",
            "\t\tif (error)",
            "\t\t\tgoto unlock;",
            "",
            "\t\terror = memfd_wait_for_pins(file->f_mapping);",
            "\t\tif (error) {",
            "\t\t\tmapping_allow_writable(file->f_mapping);",
            "\t\t\tgoto unlock;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * SEAL_EXEC implys SEAL_WRITE, making W^X from the start.",
            "\t */",
            "\tif (seals & F_SEAL_EXEC && inode->i_mode & 0111)",
            "\t\tseals |= F_SEAL_SHRINK|F_SEAL_GROW|F_SEAL_WRITE|F_SEAL_FUTURE_WRITE;",
            "",
            "\t*file_seals |= seals;",
            "\terror = 0;",
            "",
            "unlock:",
            "\tinode_unlock(inode);",
            "\treturn error;",
            "}"
          ],
          "function_name": "memfd_folio_has_extra_refs, memfd_tag_pins, memfd_wait_for_pins, memfd_add_seals",
          "description": "实现内存文件的页引用追踪与密封逻辑，memfd_tag_pins遍历页表标记额外引用页，memfd_wait_for_pins等待所有引用释放后清除标记，memfd_add_seals处理文件密封标志验证及权限限制设置。",
          "similarity": 0.521201491355896
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memfd.c",
          "start_line": 1,
          "end_line": 31,
          "content": [
            "/*",
            " * memfd_create system call and file sealing support",
            " *",
            " * Code was originally included in shmem.c, and broken out to facilitate",
            " * use by hugetlbfs as well as tmpfs.",
            " *",
            " * This file is released under the GPL.",
            " */",
            "",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/memfd.h>",
            "#include <linux/pid_namespace.h>",
            "#include <uapi/linux/memfd.h>",
            "",
            "/*",
            " * We need a tag: a new tag would expand every xa_node by 8 bytes,",
            " * so reuse a tag which we firmly believe is never set or cleared on tmpfs",
            " * or hugetlbfs because they are memory only filesystems.",
            " */",
            "#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE",
            "#define LAST_SCAN               4       /* about 150ms max */",
            ""
          ],
          "function_name": null,
          "description": "定义MEMFD_TAG_PINNED宏用于标识内存文件的特殊页缓存标记，通过复用tmpfs和hugetlbfs中未使用的PAGECACHE_TAG_TOWRITE标签，为后续内存文件的页管理提供标记支持。",
          "similarity": 0.42416563630104065
        }
      ]
    },
    {
      "source_file": "kernel/bpf/local_storage.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:15:04\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\local_storage.c`\n\n---\n\n# `bpf/local_storage.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/local_storage.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统的一部分，专门用于实现 **cgroup 本地存储（cgroup local storage）** 功能。该文件在 `CONFIG_CGROUP_BPF` 配置启用时编译，提供了一种机制，允许 BPF 程序为每个 cgroup 实例关联私有的、可持久化的存储空间（即“本地存储”）。这种存储可用于在 BPF 程序中跨调用保存状态，例如统计信息、配置参数等。\n\n该文件实现了两种 BPF map 类型：\n- `BPF_MAP_TYPE_CGROUP_STORAGE`\n- `BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE`\n\n分别用于单值存储和 per-CPU 存储，均基于 cgroup 的 inode ID（及可选的 attach type）作为键进行索引。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_cgroup_storage_map`**  \n  表示 cgroup 存储类型的 BPF map。包含：\n  - `struct bpf_map map`：继承自通用 BPF map 结构\n  - `spinlock_t lock`：保护红黑树和链表的自旋锁\n  - `struct rb_root root`：以键为索引的红黑树，用于快速查找\n  - `struct list_head list`：用于遍历所有存储项的链表\n\n- **`struct bpf_cgroup_storage_key`**  \n  键结构体，包含：\n  - `__u64 cgroup_inode_id`：cgroup 的 inode ID（唯一标识）\n  - `__u32 attach_type`：BPF 程序附加类型（如 `BPF_CGROUP_INET_INGRESS`）\n\n- **`struct bpf_cgroup_storage`**  \n  存储条目，包含：\n  - `struct rb_node node`：红黑树节点\n  - `struct list_head list_map`：链表节点\n  - `union { struct bpf_storage_buffer *buf; void __percpu *percpu_buf; }`：指向实际数据的指针（单值或 per-CPU）\n\n### 主要函数\n\n- **`cgroup_storage_lookup()`**  \n  在红黑树中根据 key 查找对应的 `bpf_cgroup_storage` 条目，支持加锁/不加锁模式。\n\n- **`cgroup_storage_insert()`**  \n  将新的存储条目插入红黑树，若键已存在则返回 `-EEXIST`。\n\n- **`cgroup_storage_lookup_elem()`**  \n  BPF map 的 `lookup` 操作回调，返回存储数据的起始地址。\n\n- **`cgroup_storage_update_elem()`**  \n  BPF map 的 `update` 操作回调，支持原子更新（带 `BPF_F_LOCK`）或替换整个缓冲区。\n\n- **`bpf_percpu_cgroup_storage_copy()`**  \n  用于 `PERCPU_CGROUP_STORAGE` 类型的 lookup，聚合所有 CPU 的数据。\n\n- **`bpf_percpu_cgroup_storage_update()`**  \n  用于 `PERCPU_CGROUP_STORAGE` 类型的 update，将用户提供的数据分发到各 CPU。\n\n- **`cgroup_storage_get_next_key()`**  \n  实现 BPF map 的 `get_next_key` 操作，用于遍历所有存储条目。\n\n- **`cgroup_storage_map_alloc()`**  \n  分配并初始化 cgroup storage 类型的 BPF map。\n\n- **`cgroup_storage_map_free()`**  \n  释放 map 及其所有存储条目（代码未完整显示，但功能明确）。\n\n## 3. 关键实现\n\n### 键值设计与比较逻辑\n\n- 支持两种键格式：\n  1. 仅 `__u64 cgroup_inode_id`（用于非隔离 attach type）\n  2. `struct bpf_cgroup_storage_key`（包含 inode ID + attach type，用于隔离场景）\n- `attach_type_isolated()` 判断是否使用完整键结构。\n- `bpf_cgroup_storage_key_cmp()` 实现红黑树的比较逻辑，先比较 inode ID，再比较 attach type（如适用）。\n\n### 并发控制\n\n- 使用 `spinlock_t lock` 保护红黑树和链表的修改操作（如插入、遍历）。\n- 查找操作可选择是否加锁（`locked` 参数），以支持 RCU 读路径（如 per-CPU update 中使用 `rcu_read_lock()`）。\n- 单值存储更新时使用 `xchg()` + `kfree_rcu()` 实现无锁读取和安全释放。\n\n### 内存管理\n\n- 单值存储使用 `bpf_map_kmalloc_node()` 分配 `bpf_storage_buffer`，包含数据和可能的 BTF 记录。\n- per-CPU 存储使用 `__percpu` 指针，通过 `per_cpu_ptr()` 访问各 CPU 数据。\n- 所有分配考虑 NUMA 节点（通过 `numa_node` 字段）。\n\n### 安全与限制\n\n- `value_size` 限制：\n  - 普通类型：最大 `BPF_LOCAL_STORAGE_MAX_VALUE_SIZE`\n  - per-CPU 类型：额外受限于 `PCPU_MIN_UNIT_SIZE`\n- 键大小必须为 `sizeof(__u64)` 或 `sizeof(bpf_cgroup_storage_key)`\n- `max_entries` 必须为 0（动态扩展）\n- `map_flags` 仅允许 `BPF_F_NUMA_NODE` 和访问权限标志\n\n### per-CPU 数据对齐\n\n- per-CPU 数据按 8 字节对齐（`round_up(value_size, 8)`），确保跨 CPU 访问安全，并防止内核数据泄露（因 per-CPU 区域初始化为零）。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf.h`、`bpf_map.h`、`filter.h` 等核心 BPF 头文件。\n- **cgroup 子系统**：依赖 `cgroup-internal.h` 获取 cgroup 内部结构（如 inode ID）。\n- **内存管理**：使用 `slab.h`、`mm.h` 进行内存分配。\n- **RCU 机制**：用于安全释放旧缓冲区（`kfree_rcu`）。\n- **BTF（BPF Type Format）**：支持带锁字段的类型验证（`btf_record_has_field`）。\n- **红黑树**：使用 `rbtree.h` 实现高效查找。\n- **Per-CPU 基础设施**：使用 `percpu.h` 相关宏（隐式包含）。\n\n## 5. 使用场景\n\n- **BPF 程序状态持久化**：  \n  BPF 程序（如 cgroup hook 程序）可为每个 cgroup 维护独立的计数器、配置或状态机。\n\n- **网络策略与限速**：  \n  在 `BPF_CGROUP_INET_*` 程序中，为每个 cgroup 存储流量统计或令牌桶状态。\n\n- **资源监控**：  \n  用户空间通过 BPF map 接口读取各 cgroup 的累计指标（如 I/O 次数、进程数）。\n\n- **安全策略**：  \n  存储 cgroup 特定的安全上下文或访问控制列表。\n\n- **调试与追踪**：  \n  在 BPF tracepoint 或 kprobe 程序中，按 cgroup 聚合事件数据。\n\n> **注意**：该机制仅在 cgroup BPF 支持启用（`CONFIG_CGROUP_BPF=y`）时可用，且必须通过 BPF 系统调用创建对应类型的 map，并由 BPF 程序或用户空间程序操作。",
      "similarity": 0.5679713487625122,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 414,
          "end_line": 530,
          "content": [
            "static void cgroup_storage_seq_show_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t\t struct seq_file *m)",
            "{",
            "\tenum bpf_cgroup_storage_type stype;",
            "\tstruct bpf_cgroup_storage *storage;",
            "\tint cpu;",
            "",
            "\trcu_read_lock();",
            "\tstorage = cgroup_storage_lookup(map_to_storage(map), key, false);",
            "\tif (!storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn;",
            "\t}",
            "",
            "\tbtf_type_seq_show(map->btf, map->btf_key_type_id, key, m);",
            "\tstype = cgroup_storage_type(map);",
            "\tif (stype == BPF_CGROUP_STORAGE_SHARED) {",
            "\t\tseq_puts(m, \": \");",
            "\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,",
            "\t\t\t\t  &READ_ONCE(storage->buf)->data[0], m);",
            "\t\tseq_puts(m, \"\\n\");",
            "\t} else {",
            "\t\tseq_puts(m, \": {\\n\");",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tseq_printf(m, \"\\tcpu%d: \", cpu);",
            "\t\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,",
            "\t\t\t\t\t  per_cpu_ptr(storage->percpu_buf, cpu),",
            "\t\t\t\t\t  m);",
            "\t\t\tseq_puts(m, \"\\n\");",
            "\t\t}",
            "\t\tseq_puts(m, \"}\\n\");",
            "\t}",
            "\trcu_read_unlock();",
            "}",
            "static u64 cgroup_storage_map_usage(const struct bpf_map *map)",
            "{",
            "\t/* Currently the dynamically allocated elements are not counted. */",
            "\treturn sizeof(struct bpf_cgroup_storage_map);",
            "}",
            "int bpf_cgroup_storage_assign(struct bpf_prog_aux *aux, struct bpf_map *_map)",
            "{",
            "\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);",
            "",
            "\tif (aux->cgroup_storage[stype] &&",
            "\t    aux->cgroup_storage[stype] != _map)",
            "\t\treturn -EBUSY;",
            "",
            "\taux->cgroup_storage[stype] = _map;",
            "\treturn 0;",
            "}",
            "static size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)",
            "{",
            "\tsize_t size;",
            "",
            "\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {",
            "\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;",
            "\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,",
            "\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;",
            "\t} else {",
            "\t\tsize = map->value_size;",
            "\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),",
            "\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;",
            "\t}",
            "",
            "\treturn size;",
            "}",
            "static void free_shared_cgroup_storage_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct bpf_cgroup_storage *storage =",
            "\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);",
            "",
            "\tkfree(storage->buf);",
            "\tkfree(storage);",
            "}",
            "static void free_percpu_cgroup_storage_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct bpf_cgroup_storage *storage =",
            "\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);",
            "",
            "\tfree_percpu(storage->percpu_buf);",
            "\tkfree(storage);",
            "}",
            "void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)",
            "{",
            "\tenum bpf_cgroup_storage_type stype;",
            "\tstruct bpf_map *map;",
            "",
            "\tif (!storage)",
            "\t\treturn;",
            "",
            "\tmap = &storage->map->map;",
            "\tstype = cgroup_storage_type(map);",
            "\tif (stype == BPF_CGROUP_STORAGE_SHARED)",
            "\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);",
            "\telse",
            "\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);",
            "}",
            "void bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,",
            "\t\t\t     struct cgroup *cgroup,",
            "\t\t\t     enum bpf_attach_type type)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map;",
            "",
            "\tif (!storage)",
            "\t\treturn;",
            "",
            "\tstorage->key.attach_type = type;",
            "\tstorage->key.cgroup_inode_id = cgroup_id(cgroup);",
            "",
            "\tmap = storage->map;",
            "",
            "\tspin_lock_bh(&map->lock);",
            "\tWARN_ON(cgroup_storage_insert(map, storage));",
            "\tlist_add(&storage->list_map, &map->list);",
            "\tlist_add(&storage->list_cg, &cgroup->bpf.storages);",
            "\tspin_unlock_bh(&map->lock);",
            "}"
          ],
          "function_name": "cgroup_storage_seq_show_elem, cgroup_storage_map_usage, bpf_cgroup_storage_assign, bpf_cgroup_storage_calculate_size, free_shared_cgroup_storage_rcu, free_percpu_cgroup_storage_rcu, bpf_cgroup_storage_free, bpf_cgroup_storage_link",
          "description": "包含存储元素序列化显示、内存占用统计、存储分配绑定及RCU安全的内存回收机制，区分共享与per-CPU存储的释放路径。",
          "similarity": 0.5140388011932373
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 211,
          "end_line": 363,
          "content": [
            "int bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *key,",
            "\t\t\t\t     void *value, u64 map_flags)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);",
            "\tstruct bpf_cgroup_storage *storage;",
            "\tint cpu, off = 0;",
            "\tu32 size;",
            "",
            "\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)",
            "\t\treturn -EINVAL;",
            "",
            "\trcu_read_lock();",
            "\tstorage = cgroup_storage_lookup(map, key, false);",
            "\tif (!storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ENOENT;",
            "\t}",
            "",
            "\t/* the user space will provide round_up(value_size, 8) bytes that",
            "\t * will be copied into per-cpu area. bpf programs can only access",
            "\t * value_size of it. During lookup the same extra bytes will be",
            "\t * returned or zeros which were zero-filled by percpu_alloc,",
            "\t * so no kernel data leaks possible",
            "\t */",
            "\tsize = round_up(_map->value_size, 8);",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),",
            "\t\t\t\tvalue + off, size);",
            "\t\toff += size;",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn 0;",
            "}",
            "static int cgroup_storage_get_next_key(struct bpf_map *_map, void *key,",
            "\t\t\t\t       void *_next_key)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);",
            "\tstruct bpf_cgroup_storage *storage;",
            "",
            "\tspin_lock_bh(&map->lock);",
            "",
            "\tif (list_empty(&map->list))",
            "\t\tgoto enoent;",
            "",
            "\tif (key) {",
            "\t\tstorage = cgroup_storage_lookup(map, key, true);",
            "\t\tif (!storage)",
            "\t\t\tgoto enoent;",
            "",
            "\t\tstorage = list_next_entry(storage, list_map);",
            "\t\tif (!storage)",
            "\t\t\tgoto enoent;",
            "\t} else {",
            "\t\tstorage = list_first_entry(&map->list,",
            "\t\t\t\t\t struct bpf_cgroup_storage, list_map);",
            "\t}",
            "",
            "\tspin_unlock_bh(&map->lock);",
            "",
            "\tif (attach_type_isolated(&map->map)) {",
            "\t\tstruct bpf_cgroup_storage_key *next = _next_key;",
            "\t\t*next = storage->key;",
            "\t} else {",
            "\t\t__u64 *next = _next_key;",
            "\t\t*next = storage->key.cgroup_inode_id;",
            "\t}",
            "\treturn 0;",
            "",
            "enoent:",
            "\tspin_unlock_bh(&map->lock);",
            "\treturn -ENOENT;",
            "}",
            "static void cgroup_storage_map_free(struct bpf_map *_map)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);",
            "\tstruct list_head *storages = &map->list;",
            "\tstruct bpf_cgroup_storage *storage, *stmp;",
            "",
            "\tcgroup_lock();",
            "",
            "\tlist_for_each_entry_safe(storage, stmp, storages, list_map) {",
            "\t\tbpf_cgroup_storage_unlink(storage);",
            "\t\tbpf_cgroup_storage_free(storage);",
            "\t}",
            "",
            "\tcgroup_unlock();",
            "",
            "\tWARN_ON(!RB_EMPTY_ROOT(&map->root));",
            "\tWARN_ON(!list_empty(&map->list));",
            "",
            "\tbpf_map_area_free(map);",
            "}",
            "static long cgroup_storage_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int cgroup_storage_check_btf(const struct bpf_map *map,",
            "\t\t\t\t    const struct btf *btf,",
            "\t\t\t\t    const struct btf_type *key_type,",
            "\t\t\t\t    const struct btf_type *value_type)",
            "{",
            "\tif (attach_type_isolated(map)) {",
            "\t\tstruct btf_member *m;",
            "\t\tu32 offset, size;",
            "",
            "\t\t/* Key is expected to be of struct bpf_cgroup_storage_key type,",
            "\t\t * which is:",
            "\t\t * struct bpf_cgroup_storage_key {",
            "\t\t *\t__u64\tcgroup_inode_id;",
            "\t\t *\t__u32\tattach_type;",
            "\t\t * };",
            "\t\t */",
            "",
            "\t\t/*",
            "\t\t * Key_type must be a structure with two fields.",
            "\t\t */",
            "\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ||",
            "\t\t    BTF_INFO_VLEN(key_type->info) != 2)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * The first field must be a 64 bit integer at 0 offset.",
            "\t\t */",
            "\t\tm = (struct btf_member *)(key_type + 1);",
            "\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, cgroup_inode_id);",
            "\t\tif (!btf_member_is_reg_int(btf, key_type, m, 0, size))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * The second field must be a 32 bit integer at 64 bit offset.",
            "\t\t */",
            "\t\tm++;",
            "\t\toffset = offsetof(struct bpf_cgroup_storage_key, attach_type);",
            "\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, attach_type);",
            "\t\tif (!btf_member_is_reg_int(btf, key_type, m, offset, size))",
            "\t\t\treturn -EINVAL;",
            "\t} else {",
            "\t\tu32 int_data;",
            "",
            "\t\t/*",
            "\t\t * Key is expected to be u64, which stores the cgroup_inode_id",
            "\t\t */",
            "",
            "\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tint_data = *(u32 *)(key_type + 1);",
            "\t\tif (BTF_INT_BITS(int_data) != 64 || BTF_INT_OFFSET(int_data))",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_percpu_cgroup_storage_update, cgroup_storage_get_next_key, cgroup_storage_map_free, cgroup_storage_delete_elem, cgroup_storage_check_btf",
          "description": "提供了存储遍历、资源释放和BTF类型校验功能，其中delete_elem未实际实现直接返回错误码，check_btf验证键值类型合法性。",
          "similarity": 0.5029767751693726
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 595,
          "end_line": 612,
          "content": [
            "void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map;",
            "\tstruct rb_root *root;",
            "",
            "\tif (!storage)",
            "\t\treturn;",
            "",
            "\tmap = storage->map;",
            "",
            "\tspin_lock_bh(&map->lock);",
            "\troot = &map->root;",
            "\trb_erase(&storage->node, root);",
            "",
            "\tlist_del(&storage->list_map);",
            "\tlist_del(&storage->list_cg);",
            "\tspin_unlock_bh(&map->lock);",
            "}"
          ],
          "function_name": "bpf_cgroup_storage_unlink",
          "description": "负责从红黑树和链表中移除存储项，通过自旋锁保护并发访问，同步维护存储结构与cgroup关联列表。",
          "similarity": 0.4795076251029968
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf.h>",
            "#include <linux/bug.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#ifdef CONFIG_CGROUP_BPF",
            "",
            "#include \"../cgroup/cgroup-internal.h\"",
            "",
            "#define LOCAL_STORAGE_CREATE_FLAG_MASK\t\t\t\t\t\\",
            "\t(BPF_F_NUMA_NODE | BPF_F_ACCESS_MASK)",
            "",
            "struct bpf_cgroup_storage_map {",
            "\tstruct bpf_map map;",
            "",
            "\tspinlock_t lock;",
            "\tstruct rb_root root;",
            "\tstruct list_head list;",
            "};",
            "",
            "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)",
            "{",
            "\treturn container_of(map, struct bpf_cgroup_storage_map, map);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了BPF cgroup存储管理的基础结构，包含红黑树根节点、锁和链表，通过map_to_storage函数将通用map转换为专用存储结构。",
          "similarity": 0.4772590696811676
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/local_storage.c",
          "start_line": 34,
          "end_line": 157,
          "content": [
            "static bool attach_type_isolated(const struct bpf_map *map)",
            "{",
            "\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);",
            "}",
            "static int bpf_cgroup_storage_key_cmp(const struct bpf_cgroup_storage_map *map,",
            "\t\t\t\t      const void *_key1, const void *_key2)",
            "{",
            "\tif (attach_type_isolated(&map->map)) {",
            "\t\tconst struct bpf_cgroup_storage_key *key1 = _key1;",
            "\t\tconst struct bpf_cgroup_storage_key *key2 = _key2;",
            "",
            "\t\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)",
            "\t\t\treturn -1;",
            "\t\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)",
            "\t\t\treturn 1;",
            "\t\telse if (key1->attach_type < key2->attach_type)",
            "\t\t\treturn -1;",
            "\t\telse if (key1->attach_type > key2->attach_type)",
            "\t\t\treturn 1;",
            "\t} else {",
            "\t\tconst __u64 *cgroup_inode_id1 = _key1;",
            "\t\tconst __u64 *cgroup_inode_id2 = _key2;",
            "",
            "\t\tif (*cgroup_inode_id1 < *cgroup_inode_id2)",
            "\t\t\treturn -1;",
            "\t\telse if (*cgroup_inode_id1 > *cgroup_inode_id2)",
            "\t\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,",
            "\t\t\t\t struct bpf_cgroup_storage *storage)",
            "{",
            "\tstruct rb_root *root = &map->root;",
            "\tstruct rb_node **new = &(root->rb_node), *parent = NULL;",
            "",
            "\twhile (*new) {",
            "\t\tstruct bpf_cgroup_storage *this;",
            "",
            "\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);",
            "",
            "\t\tparent = *new;",
            "\t\tswitch (bpf_cgroup_storage_key_cmp(map, &storage->key, &this->key)) {",
            "\t\tcase -1:",
            "\t\t\tnew = &((*new)->rb_left);",
            "\t\t\tbreak;",
            "\t\tcase 1:",
            "\t\t\tnew = &((*new)->rb_right);",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\treturn -EEXIST;",
            "\t\t}",
            "\t}",
            "",
            "\trb_link_node(&storage->node, parent, new);",
            "\trb_insert_color(&storage->node, root);",
            "",
            "\treturn 0;",
            "}",
            "static long cgroup_storage_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t       void *value, u64 flags)",
            "{",
            "\tstruct bpf_cgroup_storage *storage;",
            "\tstruct bpf_storage_buffer *new;",
            "",
            "\tif (unlikely(flags & ~(BPF_F_LOCK | BPF_EXIST)))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely((flags & BPF_F_LOCK) &&",
            "\t\t     !btf_record_has_field(map->record, BPF_SPIN_LOCK)))",
            "\t\treturn -EINVAL;",
            "",
            "\tstorage = cgroup_storage_lookup((struct bpf_cgroup_storage_map *)map,",
            "\t\t\t\t\tkey, false);",
            "\tif (!storage)",
            "\t\treturn -ENOENT;",
            "",
            "\tif (flags & BPF_F_LOCK) {",
            "\t\tcopy_map_value_locked(map, storage->buf->data, value, false);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tnew = bpf_map_kmalloc_node(map, struct_size(new, data, map->value_size),",
            "\t\t\t\t   __GFP_ZERO | GFP_NOWAIT | __GFP_NOWARN,",
            "\t\t\t\t   map->numa_node);",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tmemcpy(&new->data[0], value, map->value_size);",
            "\tcheck_and_init_map_value(map, new->data);",
            "",
            "\tnew = xchg(&storage->buf, new);",
            "\tkfree_rcu(new, rcu);",
            "",
            "\treturn 0;",
            "}",
            "int bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *key,",
            "\t\t\t\t   void *value)",
            "{",
            "\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);",
            "\tstruct bpf_cgroup_storage *storage;",
            "\tint cpu, off = 0;",
            "\tu32 size;",
            "",
            "\trcu_read_lock();",
            "\tstorage = cgroup_storage_lookup(map, key, false);",
            "\tif (!storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ENOENT;",
            "\t}",
            "",
            "\t/* per_cpu areas are zero-filled and bpf programs can only",
            "\t * access 'value_size' of them, so copying rounded areas",
            "\t * will not leak any kernel data",
            "\t */",
            "\tsize = round_up(_map->value_size, 8);",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tbpf_long_memcpy(value + off,",
            "\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);",
            "\t\toff += size;",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn 0;",
            "}"
          ],
          "function_name": "attach_type_isolated, bpf_cgroup_storage_key_cmp, cgroup_storage_insert, cgroup_storage_update_elem, bpf_percpu_cgroup_storage_copy",
          "description": "实现了键值比较逻辑、红黑树插入操作、多CPU数据复制及存储更新功能，支持基于cgroup inode ID和attach类型的键区分。",
          "similarity": 0.4526676535606384
        }
      ]
    }
  ]
}