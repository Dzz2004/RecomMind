{
  "query": "匿名管道内核实现原理",
  "timestamp": "2025-12-26 01:15:48",
  "retrieved_files": [
    {
      "source_file": "mm/secretmem.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:16:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `secretmem.c`\n\n---\n\n# secretmem.c 技术文档\n\n## 1. 文件概述\n\n`secretmem.c` 实现了 Linux 内核中的 **Secret Memory（秘密内存）** 功能，提供了一种安全的、不可交换（non-swappable）、不可转储（non-dumpable）且对内核页表隐藏的匿名内存区域。该功能通过新增系统调用 `memfd_secret(2)` 暴露给用户空间，用于创建具有特殊安全属性的内存文件描述符。此类内存主要用于存储敏感数据（如加密密钥），防止其被意外泄露到 swap、core dump 或通过 `/proc/pid/maps` 被探测。\n\n## 2. 核心功能\n\n### 主要函数\n- `memfd_secret(unsigned int flags)`：系统调用入口，创建 secret memory 文件描述符。\n- `secretmem_fault(struct vm_fault *vmf)`：处理缺页异常，按需分配并锁定秘密内存页。\n- `secretmem_mmap(struct file *file, struct vm_area_struct *vma)`：设置 VMA 属性，启用 `VM_LOCKED | VM_DONTDUMP` 并绑定 fault handler。\n- `secretmem_release(struct inode *inode, struct file *file)`：释放文件时减少用户计数。\n- `secretmem_file_create(unsigned long flags)`：创建基于伪文件系统的 secret memory 文件对象。\n- `secretmem_init(void)`：模块初始化，挂载 secretmem 伪文件系统。\n\n### 关键数据结构\n- `secretmem_fops`：文件操作结构体，定义 `.mmap` 和 `.release` 方法。\n- `secretmem_vm_ops`：VMA 操作结构体，仅实现 `.fault` 回调。\n- `secretmem_aops`：地址空间操作结构体，包含：\n  - `.free_folio`：释放页面前恢复直接映射并清零。\n  - `.migrate_folio`：返回 `-EBUSY` 禁止迁移。\n  - `.dirty_folio`：空操作（`noop_dirty_folio`），禁止脏页标记。\n- `secretmem_iops`：inode 操作结构体，限制文件大小不可修改（除初始为 0 外）。\n\n### 全局变量\n- `secretmem_enable`：模块参数，控制是否启用 secretmem 功能（默认启用）。\n- `secretmem_users`：原子计数器，跟踪当前活跃的 secret memory 用户数量。\n- `secretmem_mnt`：指向 secretmem 伪文件系统的内核挂载点。\n\n## 3. 关键实现\n\n### 内存安全性保障\n- **直接映射移除**：在 `secretmem_fault()` 中分配新页后，调用 `set_direct_map_invalid_noflush()` 将该物理页从内核直接映射区（direct map）中移除，使内核无法通过常规线性地址访问该页内容，增强对抗内核漏洞利用的能力。\n- **页面清零与恢复**：在 `secretmem_free_folio()` 中，先调用 `set_direct_map_default_noflush()` 恢复直接映射，再使用 `folio_zero_segment()` 安全清零页面内容，防止敏感数据残留。\n- **TLB 刷新**：分配新页并修改直接映射后，调用 `flush_tlb_kernel_range()` 刷新内核 TLB，确保 CPU 不再缓存旧映射。\n\n### 内存管理特性\n- **不可交换 & 不可回收**：通过 `mapping_set_unevictable()` 标记 address_space 为不可驱逐，确保页面不会被 swap 出或被内存回收机制回收。\n- **禁止迁移**：`.migrate_folio` 返回 `-EBUSY`，阻止 CMA、内存热插拔等场景下的页面迁移。\n- **禁止写脏**：使用 `noop_dirty_folio` 防止页面被标记为 dirty，避免写回行为。\n- **强制锁定**：`secretmem_mmap()` 强制设置 `VM_LOCKED`，结合 `mlock_future_ok()` 检查，确保内存常驻物理 RAM。\n\n### 文件系统与权限控制\n- 基于 `anon_inode` 构建伪文件系统（magic: `SECRETMEM_MAGIC`），挂载时设置 `MNT_NOEXEC` 禁止执行。\n- 文件大小只能为 0，`setattr` 操作拒绝任何非零的 `ATTR_SIZE` 修改。\n- 文件描述符默认具有 `O_RDWR` 权限，但实际 I/O 通过 mmap 访问。\n\n### 系统调用验证\n- 仅当 `secretmem_enable=1` 且平台支持 `can_set_direct_map()`（如 x86 的 `set_memory_valid()`）时才启用。\n- 参数 `flags` 必须为 `O_CLOEXEC` 或 0，其他位均视为非法。\n\n## 4. 依赖关系\n\n- **架构支持**：依赖 `asm/tlbflush.h` 和 `set_memory.h` 提供的 `set_direct_map_*` 及 TLB 刷新接口，目前主要在 x86 上实现。\n- **内存管理子系统**：重度依赖 `mm/` 下的 `filemap`、`folio`、`mlock`、`swap` 等机制。\n- **VFS 层**：使用 `pseudo_fs.h` 和 `anon_inode` 基础设施创建安全 inode。\n- **UAPI**：通过 `uapi/linux/magic.h` 定义文件系统 magic number。\n- **模块参数**：使用 `module_param_named` 提供运行时开关。\n\n## 5. 使用场景\n\n- **敏感数据保护**：应用程序（如加密库、密钥管理服务）可使用 `memfd_secret()` 创建内存区域存储私钥、会话密钥等，防止其出现在 swap 分区或 core dump 文件中。\n- **安全隔离**：由于页面从内核直接映射中移除，即使内核存在任意地址读取漏洞，攻击者也难以直接定位和提取 secret memory 中的数据。\n- **高性能安全内存**：相比传统 `mlock()` + `mmap()` 方案，secret memory 提供更严格的访问控制和自动清零机制，适用于对安全性要求极高的场景。\n- **容器与虚拟化**：可在容器或 VM 中为可信应用提供受保护的内存空间，降低侧信道攻击风险。",
      "similarity": 0.5740533471107483,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/secretmem.c",
          "start_line": 262,
          "end_line": 279,
          "content": [
            "static int secretmem_init_fs_context(struct fs_context *fc)",
            "{",
            "\treturn init_pseudo(fc, SECRETMEM_MAGIC) ? 0 : -ENOMEM;",
            "}",
            "static int __init secretmem_init(void)",
            "{",
            "\tif (!secretmem_enable || !can_set_direct_map())",
            "\t\treturn 0;",
            "",
            "\tsecretmem_mnt = kern_mount(&secretmem_fs);",
            "\tif (IS_ERR(secretmem_mnt))",
            "\t\treturn PTR_ERR(secretmem_mnt);",
            "",
            "\t/* prevent secretmem mappings from ever getting PROT_EXEC */",
            "\tsecretmem_mnt->mnt_flags |= MNT_NOEXEC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "secretmem_init_fs_context, secretmem_init",
          "description": "初始化secretmem伪文件系统，通过kern_mount创建挂载点并设置MNT_NOEXEC标志，防止秘密内存区域被赋予执行权限",
          "similarity": 0.5674351453781128
        },
        {
          "chunk_id": 1,
          "file_path": "mm/secretmem.c",
          "start_line": 45,
          "end_line": 163,
          "content": [
            "bool secretmem_active(void)",
            "{",
            "\treturn !!atomic_read(&secretmem_users);",
            "}",
            "static vm_fault_t secretmem_fault(struct vm_fault *vmf)",
            "{",
            "\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;",
            "\tstruct inode *inode = file_inode(vmf->vma->vm_file);",
            "\tpgoff_t offset = vmf->pgoff;",
            "\tgfp_t gfp = vmf->gfp_mask;",
            "\tunsigned long addr;",
            "\tstruct page *page;",
            "\tstruct folio *folio;",
            "\tvm_fault_t ret;",
            "\tint err;",
            "",
            "\tif (((loff_t)vmf->pgoff << PAGE_SHIFT) >= i_size_read(inode))",
            "\t\treturn vmf_error(-EINVAL);",
            "",
            "\tfilemap_invalidate_lock_shared(mapping);",
            "",
            "retry:",
            "\tpage = find_lock_page(mapping, offset);",
            "\tif (!page) {",
            "\t\tfolio = folio_alloc(gfp | __GFP_ZERO, 0);",
            "\t\tif (!folio) {",
            "\t\t\tret = VM_FAULT_OOM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tpage = &folio->page;",
            "\t\terr = set_direct_map_invalid_noflush(page);",
            "\t\tif (err) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\tret = vmf_error(err);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\t__folio_mark_uptodate(folio);",
            "\t\terr = filemap_add_folio(mapping, folio, offset, gfp);",
            "\t\tif (unlikely(err)) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\t/*",
            "\t\t\t * If a split of large page was required, it",
            "\t\t\t * already happened when we marked the page invalid",
            "\t\t\t * which guarantees that this call won't fail",
            "\t\t\t */",
            "\t\t\tset_direct_map_default_noflush(page);",
            "\t\t\tif (err == -EEXIST)",
            "\t\t\t\tgoto retry;",
            "",
            "\t\t\tret = vmf_error(err);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\taddr = (unsigned long)page_address(page);",
            "\t\tflush_tlb_kernel_range(addr, addr + PAGE_SIZE);",
            "\t}",
            "",
            "\tvmf->page = page;",
            "\tret = VM_FAULT_LOCKED;",
            "",
            "out:",
            "\tfilemap_invalidate_unlock_shared(mapping);",
            "\treturn ret;",
            "}",
            "static int secretmem_release(struct inode *inode, struct file *file)",
            "{",
            "\tatomic_dec(&secretmem_users);",
            "\treturn 0;",
            "}",
            "static int secretmem_mmap(struct file *file, struct vm_area_struct *vma)",
            "{",
            "\tunsigned long len = vma->vm_end - vma->vm_start;",
            "",
            "\tif ((vma->vm_flags & (VM_SHARED | VM_MAYSHARE)) == 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!mlock_future_ok(vma->vm_mm, vma->vm_flags | VM_LOCKED, len))",
            "\t\treturn -EAGAIN;",
            "",
            "\tvm_flags_set(vma, VM_LOCKED | VM_DONTDUMP);",
            "\tvma->vm_ops = &secretmem_vm_ops;",
            "",
            "\treturn 0;",
            "}",
            "bool vma_is_secretmem(struct vm_area_struct *vma)",
            "{",
            "\treturn vma->vm_ops == &secretmem_vm_ops;",
            "}",
            "static int secretmem_migrate_folio(struct address_space *mapping,",
            "\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)",
            "{",
            "\treturn -EBUSY;",
            "}",
            "static void secretmem_free_folio(struct folio *folio)",
            "{",
            "\tset_direct_map_default_noflush(&folio->page);",
            "\tfolio_zero_segment(folio, 0, folio_size(folio));",
            "}",
            "static int secretmem_setattr(struct mnt_idmap *idmap,",
            "\t\t\t     struct dentry *dentry, struct iattr *iattr)",
            "{",
            "\tstruct inode *inode = d_inode(dentry);",
            "\tstruct address_space *mapping = inode->i_mapping;",
            "\tunsigned int ia_valid = iattr->ia_valid;",
            "\tint ret;",
            "",
            "\tfilemap_invalidate_lock(mapping);",
            "",
            "\tif ((ia_valid & ATTR_SIZE) && inode->i_size)",
            "\t\tret = -EINVAL;",
            "\telse",
            "\t\tret = simple_setattr(idmap, dentry, iattr);",
            "",
            "\tfilemap_invalidate_unlock(mapping);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "secretmem_active, secretmem_fault, secretmem_release, secretmem_mmap, vma_is_secretmem, secretmem_migrate_folio, secretmem_free_folio, secretmem_setattr",
          "description": "实现secretmem核心功能，包括检查是否启用、处理页面故障时分配并标记不可执行页面、管理VMA标志、验证文件属性等内存加密相关操作",
          "similarity": 0.5566534996032715
        },
        {
          "chunk_id": 0,
          "file_path": "mm/secretmem.c",
          "start_line": 1,
          "end_line": 44,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright IBM Corporation, 2021",
            " *",
            " * Author: Mike Rapoport <rppt@linux.ibm.com>",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/memfd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/printk.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/sched/signal.h>",
            "",
            "#include <uapi/linux/magic.h>",
            "",
            "#include <asm/tlbflush.h>",
            "",
            "#include \"internal.h\"",
            "",
            "#undef pr_fmt",
            "#define pr_fmt(fmt) \"secretmem: \" fmt",
            "",
            "/*",
            " * Define mode and flag masks to allow validation of the system call",
            " * parameters.",
            " */",
            "#define SECRETMEM_MODE_MASK\t(0x0)",
            "#define SECRETMEM_FLAGS_MASK\tSECRETMEM_MODE_MASK",
            "",
            "static bool secretmem_enable __ro_after_init = 1;",
            "module_param_named(enable, secretmem_enable, bool, 0400);",
            "MODULE_PARM_DESC(secretmem_enable,",
            "\t\t \"Enable secretmem and memfd_secret(2) system call\");",
            "",
            "static atomic_t secretmem_users;",
            ""
          ],
          "function_name": null,
          "description": "定义secretmem模块的许可证和基本包含头文件，声明全局变量secretmem_enable用于控制功能启用状态，并注册模块参数供外部配置",
          "similarity": 0.513126015663147
        }
      ]
    },
    {
      "source_file": "kernel/watch_queue.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:50:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watch_queue.c`\n\n---\n\n# watch_queue.c 技术文档\n\n## 文件概述\n\n`watch_queue.c` 实现了 Linux 内核中的**监视队列**（Watch Queue）机制，这是一种基于管道（pipe）构建的通用事件通知系统。该机制允许内核子系统（如文件系统、密钥管理、设备驱动等）向用户空间异步发送结构化通知。用户空间通过创建特殊类型的管道并关联监视队列，即可接收来自内核的各类事件通知。该文件定义了通知的投递、过滤、缓冲管理及与管道集成的核心逻辑。\n\n## 核心功能\n\n### 主要函数\n\n- **`__post_watch_notification()`**  \n  核心通知投递函数。遍历指定 `watch_list` 中所有匹配 `id` 的监视器（`watch`），对每个关联的 `watch_queue` 应用过滤规则、安全检查，并将通知写入底层管道。\n\n- **`post_one_notification()`**  \n  将单个通知写入指定 `watch_queue` 的底层管道缓冲区。负责从预分配的通知页中获取空闲槽位、填充数据、更新管道头指针并唤醒等待读取的进程。\n\n- **`filter_watch_notification()`**  \n  根据 `watch_filter` 中的类型、子类型和信息掩码规则，判断是否允许特定通知通过。\n\n- **`watch_queue_set_size()`**  \n  为监视队列分配预分配的通知缓冲区（页数组和位图），并调整底层管道的环形缓冲区大小。\n\n- **`watch_queue_pipe_buf_release()`**  \n  管道缓冲区释放回调。当用户空间读取完通知后，将对应的通知槽位在位图中标记为空闲，供后续复用。\n\n### 关键数据结构\n\n- **`struct watch_queue`**  \n  表示一个监视队列，包含：\n  - 指向底层 `pipe_inode_info` 的指针\n  - 预分配的通知页数组（`notes`）\n  - 通知槽位空闲位图（`notes_bitmap`）\n  - 通知过滤器（`filter`）\n  - 保护锁（`lock`）\n\n- **`struct watch_notification`**  \n  通用通知记录格式，包含类型（`type`）、子类型（`subtype`）、信息字段（`info`，含长度和ID）及可变负载。\n\n- **`struct watch_filter` / `struct watch_type_filter`**  \n  定义通知过滤规则，支持按类型、子类型及信息字段的位掩码进行精确过滤。\n\n- **`watch_queue_pipe_buf_ops`**  \n  自定义的 `pipe_buf_operations`，用于管理监视队列专用管道缓冲区的生命周期。\n\n## 关键实现\n\n### 基于管道的通知传输\n- 监视队列复用内核管道（`pipe_inode_info`）作为通知传输通道，利用其成熟的读写、轮询、异步通知机制。\n- 通过自定义 `pipe_buf_operations`（`watch_queue_pipe_buf_ops`）实现通知槽位的回收：当用户读取通知后，`release` 回调将对应槽位在 `notes_bitmap` 中置位，标记为空闲。\n\n### 预分配通知缓冲区\n- 通知数据存储在预分配的内核页（`notes`）中，每页划分为多个固定大小（128字节）的槽位（`WATCH_QUEUE_NOTE_SIZE`）。\n- 使用位图（`notes_bitmap`）跟踪槽位使用状态，1 表示空闲。投递通知时通过 `find_first_bit()` 快速查找空闲槽位。\n- 缓冲区大小由用户通过 `watch_queue_set_size()` 设置（1-512个通知），并受管道缓冲区配额限制。\n\n### 通知投递流程\n1. **匹配监视器**：遍历 `watch_list`，查找 `id` 匹配的 `watch`。\n2. **应用过滤**：若队列配置了过滤器，调用 `filter_watch_notification()` 决定是否丢弃。\n3. **安全检查**：调用 LSM 钩子 `security_post_notification()` 进行权限验证。\n4. **写入管道**：\n   - 获取空闲通知槽位，复制通知数据。\n   - 构造 `pipe_buffer` 指向该槽位，设置自定义操作集。\n   - 更新管道 `head` 指针，唤醒等待读取的进程。\n   - 若缓冲区满，标记前一个缓冲区为 `PIPE_BUF_FLAG_LOSS` 表示丢包。\n\n### 并发与同步\n- **RCU 保护**：`watch_list` 和 `watch_queue` 的访问通过 RCU 机制保护，确保遍历时结构体不被释放。\n- **自旋锁**：\n  - `wqueue->lock`：保护 `wqueue` 状态（如 `pipe` 指针有效性）。\n  - `pipe->rd_wait.lock`：保护管道环形缓冲区的读写操作。\n- **原子操作**：管道 `head` 指针使用 `smp_store_release()` 更新，确保与 `pipe_read()` 的同步。\n\n## 依赖关系\n\n- **管道子系统**（`fs/pipe.c`）  \n  依赖管道的核心数据结构（`pipe_inode_info`、`pipe_buffer`）和操作接口（`pipe_buf()`、`pipe_full()`、`generic_pipe_buf_*`）。\n\n- **内存管理**  \n  使用 `alloc_page()`、`kmap_atomic()` 管理通知缓冲区页，`bitmap_alloc()` 管理槽位位图。\n\n- **安全模块**（LSM）  \n  通过 `security_post_notification()` 钩子集成安全策略。\n\n- **用户空间接口**  \n  与 `fs/watch_queue.c` 中的系统调用（如 `watch_queue_set_size()`）协同工作，后者负责创建监视队列并与管道关联。\n\n- **头文件依赖**  \n  `linux/watch_queue.h`（核心数据结构定义）、`linux/pipe_fs_i.h`（管道内部接口）。\n\n## 使用场景\n\n- **文件系统事件监控**  \n  如 `fsnotify` 子系统可通过监视队列向用户空间报告文件访问、修改等事件。\n\n- **密钥管理通知**  \n  内核密钥环（`KEYS`）子系统使用该机制通知密钥状态变更（如过期、撤销）。\n\n- **设备事件上报**  \n  设备驱动可利用监视队列异步上报硬件状态变化或错误事件。\n\n- **通用内核事件分发**  \n  任何需要向特权用户空间守护进程（如 `systemd`）发送结构化事件的内核子系统均可集成此机制。\n\n- **用户空间消费**  \n  应用程序通过 `open(\"/dev/watch_queue\")` 获取监视队列文件描述符，调用 `ioctl()` 设置缓冲区大小和过滤器，然后像读取普通管道一样接收通知。",
      "similarity": 0.5683389902114868,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/watch_queue.c",
          "start_line": 42,
          "end_line": 154,
          "content": [
            "static inline bool lock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_lock_bh(&wqueue->lock);",
            "\tif (unlikely(!wqueue->pipe)) {",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static inline void unlock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_unlock_bh(&wqueue->lock);",
            "}",
            "static void watch_queue_pipe_buf_release(struct pipe_inode_info *pipe,",
            "\t\t\t\t\t struct pipe_buffer *buf)",
            "{",
            "\tstruct watch_queue *wqueue = (struct watch_queue *)buf->private;",
            "\tstruct page *page;",
            "\tunsigned int bit;",
            "",
            "\t/* We need to work out which note within the page this refers to, but",
            "\t * the note might have been maximum size, so merely ANDing the offset",
            "\t * off doesn't work.  OTOH, the note must've been more than zero size.",
            "\t */",
            "\tbit = buf->offset + buf->len;",
            "\tif ((bit & (WATCH_QUEUE_NOTE_SIZE - 1)) == 0)",
            "\t\tbit -= WATCH_QUEUE_NOTE_SIZE;",
            "\tbit /= WATCH_QUEUE_NOTE_SIZE;",
            "",
            "\tpage = buf->page;",
            "\tbit += page->index;",
            "",
            "\tset_bit(bit, wqueue->notes_bitmap);",
            "\tgeneric_pipe_buf_release(pipe, buf);",
            "}",
            "static bool post_one_notification(struct watch_queue *wqueue,",
            "\t\t\t\t  struct watch_notification *n)",
            "{",
            "\tvoid *p;",
            "\tstruct pipe_inode_info *pipe = wqueue->pipe;",
            "\tstruct pipe_buffer *buf;",
            "\tstruct page *page;",
            "\tunsigned int head, tail, note, offset, len;",
            "\tbool done = false;",
            "",
            "\tspin_lock_irq(&pipe->rd_wait.lock);",
            "",
            "\thead = pipe->head;",
            "\ttail = pipe->tail;",
            "\tif (pipe_full(head, tail, pipe->ring_size))",
            "\t\tgoto lost;",
            "",
            "\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);",
            "\tif (note >= wqueue->nr_notes)",
            "\t\tgoto lost;",
            "",
            "\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];",
            "\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;",
            "\tget_page(page);",
            "\tlen = n->info & WATCH_INFO_LENGTH;",
            "\tp = kmap_atomic(page);",
            "\tmemcpy(p + offset, n, len);",
            "\tkunmap_atomic(p);",
            "",
            "\tbuf = pipe_buf(pipe, head);",
            "\tbuf->page = page;",
            "\tbuf->private = (unsigned long)wqueue;",
            "\tbuf->ops = &watch_queue_pipe_buf_ops;",
            "\tbuf->offset = offset;",
            "\tbuf->len = len;",
            "\tbuf->flags = PIPE_BUF_FLAG_WHOLE;",
            "\tsmp_store_release(&pipe->head, head + 1); /* vs pipe_read() */",
            "",
            "\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {",
            "\t\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\t\tBUG();",
            "\t}",
            "\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);",
            "\tdone = true;",
            "",
            "out:",
            "\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\tif (done)",
            "\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);",
            "\treturn done;",
            "",
            "lost:",
            "\tbuf = pipe_buf(pipe, head - 1);",
            "\tbuf->flags |= PIPE_BUF_FLAG_LOSS;",
            "\tgoto out;",
            "}",
            "static bool filter_watch_notification(const struct watch_filter *wf,",
            "\t\t\t\t      const struct watch_notification *n)",
            "{",
            "\tconst struct watch_type_filter *wt;",
            "\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;",
            "\tunsigned int st_index = n->subtype / st_bits;",
            "\tunsigned int st_bit = 1U << (n->subtype % st_bits);",
            "\tint i;",
            "",
            "\tif (!test_bit(n->type, wf->type_filter))",
            "\t\treturn false;",
            "",
            "\tfor (i = 0; i < wf->nr_filters; i++) {",
            "\t\twt = &wf->filters[i];",
            "\t\tif (n->type == wt->type &&",
            "\t\t    (wt->subtype_filter[st_index] & st_bit) &&",
            "\t\t    (n->info & wt->info_mask) == wt->info_filter)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false; /* If there is a filter, the default is to reject. */",
            "}"
          ],
          "function_name": "lock_wqueue, unlock_wqueue, watch_queue_pipe_buf_release, post_one_notification, filter_watch_notification",
          "description": "实现了watch_queue的锁操作、缓冲区释放、通知提交及过滤逻辑。lock_wqueue/unlock_wqueue用于保护队列访问，watch_queue_pipe_buf_release处理缓冲区回收并更新位图，post_one_notification将通知数据写入管道，filter_watch_notification进行类型和子类型的匹配判断。",
          "similarity": 0.47299808263778687
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/watch_queue.c",
          "start_line": 602,
          "end_line": 680,
          "content": [
            "void watch_queue_clear(struct watch_queue *wqueue)",
            "{",
            "\tstruct watch_list *wlist;",
            "\tstruct watch *watch;",
            "\tbool release;",
            "",
            "\trcu_read_lock();",
            "\tspin_lock_bh(&wqueue->lock);",
            "",
            "\t/*",
            "\t * This pipe can be freed by callers like free_pipe_info().",
            "\t * Removing this reference also prevents new notifications.",
            "\t */",
            "\twqueue->pipe = NULL;",
            "",
            "\twhile (!hlist_empty(&wqueue->watches)) {",
            "\t\twatch = hlist_entry(wqueue->watches.first, struct watch, queue_node);",
            "\t\thlist_del_init_rcu(&watch->queue_node);",
            "\t\t/* We now own a ref on the watch. */",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "",
            "\t\t/* We can't do the next bit under the queue lock as we need to",
            "\t\t * get the list lock - which would cause a deadlock if someone",
            "\t\t * was removing from the opposite direction at the same time or",
            "\t\t * posting a notification.",
            "\t\t */",
            "\t\twlist = rcu_dereference(watch->watch_list);",
            "\t\tif (wlist) {",
            "\t\t\tvoid (*release_watch)(struct watch *);",
            "",
            "\t\t\tspin_lock(&wlist->lock);",
            "",
            "\t\t\trelease = !hlist_unhashed(&watch->list_node);",
            "\t\t\tif (release) {",
            "\t\t\t\thlist_del_init_rcu(&watch->list_node);",
            "\t\t\t\trcu_assign_pointer(watch->watch_list, NULL);",
            "",
            "\t\t\t\t/* We now own a second ref on the watch. */",
            "\t\t\t}",
            "",
            "\t\t\trelease_watch = wlist->release_watch;",
            "\t\t\tspin_unlock(&wlist->lock);",
            "",
            "\t\t\tif (release) {",
            "\t\t\t\tif (release_watch) {",
            "\t\t\t\t\trcu_read_unlock();",
            "\t\t\t\t\t/* This might need to call dput(), so",
            "\t\t\t\t\t * we have to drop all the locks.",
            "\t\t\t\t\t */",
            "\t\t\t\t\t(*release_watch)(watch);",
            "\t\t\t\t\trcu_read_lock();",
            "\t\t\t\t}",
            "\t\t\t\tput_watch(watch);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tput_watch(watch);",
            "\t\tspin_lock_bh(&wqueue->lock);",
            "\t}",
            "",
            "\tspin_unlock_bh(&wqueue->lock);",
            "\trcu_read_unlock();",
            "}",
            "int watch_queue_init(struct pipe_inode_info *pipe)",
            "{",
            "\tstruct watch_queue *wqueue;",
            "",
            "\twqueue = kzalloc(sizeof(*wqueue), GFP_KERNEL);",
            "\tif (!wqueue)",
            "\t\treturn -ENOMEM;",
            "",
            "\twqueue->pipe = pipe;",
            "\tkref_init(&wqueue->usage);",
            "\tspin_lock_init(&wqueue->lock);",
            "\tINIT_HLIST_HEAD(&wqueue->watches);",
            "",
            "\tpipe->watch_queue = wqueue;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "watch_queue_clear, watch_queue_init",
          "description": "该代码实现了监视队列的初始化与清理功能。  \n`watch_queue_clear`通过RCU和自旋锁机制安全地移除所有监视项并释放资源，`watch_queue_init`初始化监视队列结构并绑定至管道对象。  \n上下文不完整：`release_watch`等关键函数依赖外部定义，部分RCU回调逻辑未完全展示。",
          "similarity": 0.472107470035553
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/watch_queue.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Watch queue and general notification mechanism, built on pipes",
            " *",
            " * Copyright (C) 2020 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " *",
            " * See Documentation/core-api/watch_queue.rst",
            " */",
            "",
            "#define pr_fmt(fmt) \"watchq: \" fmt",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/pipe_fs_i.h>",
            "",
            "MODULE_DESCRIPTION(\"Watch queue\");",
            "MODULE_AUTHOR(\"Red Hat, Inc.\");",
            "",
            "#define WATCH_QUEUE_NOTE_SIZE 128",
            "#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)",
            "",
            "/*",
            " * This must be called under the RCU read-lock, which makes",
            " * sure that the wqueue still exists. It can then take the lock,",
            " * and check that the wqueue hasn't been destroyed, which in",
            " * turn makes sure that the notification pipe still exists.",
            " */"
          ],
          "function_name": null,
          "description": "定义了watch_queue模块的头部信息，包含常量WATCH_QUEUE_NOTE_SIZE和NOTES_PER_PAGE，声明模块许可证及作者信息，并引入相关内核头文件，为后续实现提供基础框架。",
          "similarity": 0.44413793087005615
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/watch_queue.c",
          "start_line": 315,
          "end_line": 422,
          "content": [
            "long watch_queue_set_filter(struct pipe_inode_info *pipe,",
            "\t\t\t    struct watch_notification_filter __user *_filter)",
            "{",
            "\tstruct watch_notification_type_filter *tf;",
            "\tstruct watch_notification_filter filter;",
            "\tstruct watch_type_filter *q;",
            "\tstruct watch_filter *wfilter;",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tint ret, nr_filter = 0, i;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (!_filter) {",
            "\t\t/* Remove the old filter */",
            "\t\twfilter = NULL;",
            "\t\tgoto set;",
            "\t}",
            "",
            "\t/* Grab the user's filter specification */",
            "\tif (copy_from_user(&filter, _filter, sizeof(filter)) != 0)",
            "\t\treturn -EFAULT;",
            "\tif (filter.nr_filters == 0 ||",
            "\t    filter.nr_filters > 16 ||",
            "\t    filter.__reserved != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\ttf = memdup_array_user(_filter->filters, filter.nr_filters, sizeof(*tf));",
            "\tif (IS_ERR(tf))",
            "\t\treturn PTR_ERR(tf);",
            "",
            "\tret = -EINVAL;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif ((tf[i].info_filter & ~tf[i].info_mask) ||",
            "\t\t    tf[i].info_mask & WATCH_INFO_LENGTH)",
            "\t\t\tgoto err_filter;",
            "\t\t/* Ignore any unknown types */",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "\t\tnr_filter++;",
            "\t}",
            "",
            "\t/* Now we need to build the internal filter from only the relevant",
            "\t * user-specified filters.",
            "\t */",
            "\tret = -ENOMEM;",
            "\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);",
            "\tif (!wfilter)",
            "\t\tgoto err_filter;",
            "\twfilter->nr_filters = nr_filter;",
            "",
            "\tq = wfilter->filters;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "",
            "\t\tq->type\t\t\t= tf[i].type;",
            "\t\tq->info_filter\t\t= tf[i].info_filter;",
            "\t\tq->info_mask\t\t= tf[i].info_mask;",
            "\t\tq->subtype_filter[0]\t= tf[i].subtype_filter[0];",
            "\t\t__set_bit(q->type, wfilter->type_filter);",
            "\t\tq++;",
            "\t}",
            "",
            "\tkfree(tf);",
            "set:",
            "\tpipe_lock(pipe);",
            "\twfilter = rcu_replace_pointer(wqueue->filter, wfilter,",
            "\t\t\t\t      lockdep_is_held(&pipe->mutex));",
            "\tpipe_unlock(pipe);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\treturn 0;",
            "",
            "err_filter:",
            "\tkfree(tf);",
            "\treturn ret;",
            "}",
            "static void __put_watch_queue(struct kref *kref)",
            "{",
            "\tstruct watch_queue *wqueue =",
            "\t\tcontainer_of(kref, struct watch_queue, usage);",
            "\tstruct watch_filter *wfilter;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < wqueue->nr_pages; i++)",
            "\t\t__free_page(wqueue->notes[i]);",
            "\tkfree(wqueue->notes);",
            "\tbitmap_free(wqueue->notes_bitmap);",
            "",
            "\twfilter = rcu_access_pointer(wqueue->filter);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\tkfree_rcu(wqueue, rcu);",
            "}",
            "void put_watch_queue(struct watch_queue *wqueue)",
            "{",
            "\tkref_put(&wqueue->usage, __put_watch_queue);",
            "}",
            "static void free_watch(struct rcu_head *rcu)",
            "{",
            "\tstruct watch *watch = container_of(rcu, struct watch, rcu);",
            "",
            "\tput_watch_queue(rcu_access_pointer(watch->queue));",
            "\tatomic_dec(&watch->cred->user->nr_watches);",
            "\tput_cred(watch->cred);",
            "\tkfree(watch);",
            "}"
          ],
          "function_name": "watch_queue_set_filter, __put_watch_queue, put_watch_queue, free_watch",
          "description": "watch_queue_set_filter设置过滤规则并转换为内核内部结构，__put_watch_queue释放watch_queue相关资源包括页面、位图和过滤器，put_watch_queue通过引用计数管理watch_queue生命周期，free_watch执行RCU回调完成最终释放。",
          "similarity": 0.43707019090652466
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watch_queue.c",
          "start_line": 193,
          "end_line": 304,
          "content": [
            "void __post_watch_notification(struct watch_list *wlist,",
            "\t\t\t       struct watch_notification *n,",
            "\t\t\t       const struct cred *cred,",
            "\t\t\t       u64 id)",
            "{",
            "\tconst struct watch_filter *wf;",
            "\tstruct watch_queue *wqueue;",
            "\tstruct watch *watch;",
            "",
            "\tif (((n->info & WATCH_INFO_LENGTH) >> WATCH_INFO_LENGTH__SHIFT) == 0) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\trcu_read_lock();",
            "",
            "\thlist_for_each_entry_rcu(watch, &wlist->watchers, list_node) {",
            "\t\tif (watch->id != id)",
            "\t\t\tcontinue;",
            "\t\tn->info &= ~WATCH_INFO_ID;",
            "\t\tn->info |= watch->info_id;",
            "",
            "\t\twqueue = rcu_dereference(watch->queue);",
            "\t\twf = rcu_dereference(wqueue->filter);",
            "\t\tif (wf && !filter_watch_notification(wf, n))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (security_post_notification(watch->cred, cred, n) < 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (lock_wqueue(wqueue)) {",
            "\t\t\tpost_one_notification(wqueue, n);",
            "\t\t\tunlock_wqueue(wqueue);",
            "\t\t}",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "}",
            "long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)",
            "{",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tstruct page **pages;",
            "\tunsigned long *bitmap;",
            "\tunsigned long user_bufs;",
            "\tint ret, i, nr_pages;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "\tif (wqueue->notes)",
            "\t\treturn -EBUSY;",
            "",
            "\tif (nr_notes < 1 ||",
            "\t    nr_notes > 512) /* TODO: choose a better hard limit */",
            "\t\treturn -EINVAL;",
            "",
            "\tnr_pages = (nr_notes + WATCH_QUEUE_NOTES_PER_PAGE - 1);",
            "\tnr_pages /= WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tuser_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_pages);",
            "",
            "\tif (nr_pages > pipe->max_usage &&",
            "\t    (too_many_pipe_buffers_hard(user_bufs) ||",
            "\t     too_many_pipe_buffers_soft(user_bufs)) &&",
            "\t    pipe_is_unprivileged_user()) {",
            "\t\tret = -EPERM;",
            "\t\tgoto error;",
            "\t}",
            "",
            "\tnr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "",
            "\t/*",
            "\t * pipe_resize_ring() does not update nr_accounted for watch_queue",
            "\t * pipes, because the above vastly overprovisions. Set nr_accounted on",
            "\t * and max_usage this pipe to the number that was actually charged to",
            "\t * the user above via account_pipe_buffers.",
            "\t */",
            "\tpipe->max_usage = nr_pages;",
            "\tpipe->nr_accounted = nr_pages;",
            "",
            "\tret = -ENOMEM;",
            "\tpages = kcalloc(sizeof(struct page *), nr_pages, GFP_KERNEL);",
            "\tif (!pages)",
            "\t\tgoto error;",
            "",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tpages[i] = alloc_page(GFP_KERNEL);",
            "\t\tif (!pages[i])",
            "\t\t\tgoto error_p;",
            "\t\tpages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\t}",
            "",
            "\tbitmap = bitmap_alloc(nr_notes, GFP_KERNEL);",
            "\tif (!bitmap)",
            "\t\tgoto error_p;",
            "",
            "\tbitmap_fill(bitmap, nr_notes);",
            "\twqueue->notes = pages;",
            "\twqueue->notes_bitmap = bitmap;",
            "\twqueue->nr_pages = nr_pages;",
            "\twqueue->nr_notes = nr_notes;",
            "\treturn 0;",
            "",
            "error_p:",
            "\twhile (--i >= 0)",
            "\t\t__free_page(pages[i]);",
            "\tkfree(pages);",
            "error:",
            "\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->nr_accounted);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__post_watch_notification, watch_queue_set_size",
          "description": "__post_watch_notification遍历watch列表并应用过滤器后提交通知，watch_queue_set_size动态调整管道容量，通过计算所需页数和位图分配，限制最大容量为512个笔记，支持扩展性需求。",
          "similarity": 0.4074563980102539
        }
      ]
    },
    {
      "source_file": "kernel/irq/affinity.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:46:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\affinity.c`\n\n---\n\n# `irq/affinity.c` 技术文档\n\n## 1. 文件概述\n\n`irq/affinity.c` 是 Linux 内核中用于管理中断亲和性（IRQ affinity）的核心实现文件，主要负责为多队列设备（如多队列网卡、NVMe SSD 等）动态生成合理的 CPU 亲和性掩码（cpumask），以实现中断在多个 CPU 核心上的均衡分布。该文件提供了两个关键接口：  \n- `irq_create_affinity_masks()`：根据设备需求和系统 CPU 拓扑，生成每中断向量对应的 CPU 亲和性掩码。  \n- `irq_calc_affinity_vectors()`：计算在给定约束下可有效用于亲和性分配的最优中断向量数量。  \n\n该机制支持将中断向量划分为多个“集合”（sets），每个集合可独立分配 CPU 资源，适用于需要分层或分组中断处理的复杂设备。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`irq_create_affinity_masks(unsigned int nvecs, struct irq_affinity *affd)`**  \n  为指定数量的中断向量生成亲和性掩码数组。支持预定义（pre_vectors）、可管理（managed）和后置（post_vectors）三类中断向量，并通过 `group_cpus_evenly()` 实现 CPU 均匀分配。\n\n- **`irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec, const struct irq_affinity *affd)`**  \n  在 `[minvec, maxvec]` 范围内计算可用于亲和性分配的最优中断向量总数，考虑设备保留向量和系统 CPU 数量限制。\n\n### 关键数据结构\n\n- **`struct irq_affinity`**（定义于 `<linux/interrupt.h>`）  \n  描述中断亲和性分配需求：\n  - `pre_vectors` / `post_vectors`：保留的前后固定向量数（通常用于管理或特殊用途）。\n  - `calc_sets`：回调函数，用于自定义如何将可分配向量划分为多个集合（sets）。\n  - `nr_sets` / `set_size[]`：由 `calc_sets` 填充，表示集合数量及每个集合的向量数。\n\n- **`struct irq_affinity_desc`**（定义于 `<linux/interrupt.h>`）  \n  单个中断向量的亲和性描述：\n  - `mask`：该向量绑定的 CPU 掩码。\n  - `is_managed`：标志位，表示该向量是否由内核自动管理亲和性。\n\n### 辅助函数\n\n- **`default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)`**  \n  默认的集合划分策略：将所有可分配向量归入单个集合。\n\n## 3. 关键实现\n\n### 亲和性掩码生成流程（`irq_create_affinity_masks`）\n\n1. **计算可分配向量数**：  \n   `affvecs = nvecs - pre_vectors - post_vectors`，若结果 ≤0 则无需分配。\n\n2. **设置集合划分策略**：  \n   若用户未提供 `calc_sets` 回调，则使用 `default_calc_sets`（单集合）。\n\n3. **生成每集合的 CPU 掩码**：  \n   对每个集合调用 `group_cpus_evenly(this_vecs)`，该函数根据系统 CPU 拓扑（如 NUMA、超线程）将 `this_vecs` 个中断均匀分配到物理 CPU 上，返回一个 `cpumask` 数组。\n\n4. **填充掩码数组**：  \n   - 前 `pre_vectors` 个向量：使用全局默认亲和性 `irq_default_affinity`。\n   - 中间 `affvecs` 个向量：按集合依次填充 `group_cpus_evenly` 的结果。\n   - 后 `post_vectors` 个向量：同样使用默认亲和性。\n   - 标记 `pre_vectors` 到 `nvecs - post_vectors` 之间的向量为 `is_managed = 1`。\n\n### 向量数量计算（`irq_calc_affinity_vectors`）\n\n- 若设备保留向量数（`resv = pre + post`）超过 `minvec`，返回 0（无法满足最小需求）。\n- 若提供 `calc_sets` 回调，则最大可分配向量数为 `maxvec - resv`。\n- 否则，以系统可能 CPU 数（`cpu_possible_mask`）为上限。\n- 最终结果：`resv + min(可分配向量上限, maxvec - resv)`。\n\n### 错误处理\n\n- 集合数超过 `IRQ_AFFINITY_MAX_SETS`（通常为 4）时触发 `WARN_ON_ONCE` 并返回 `NULL`。\n- 内存分配失败或 `group_cpus_evenly` 失败时释放已分配资源并返回 `NULL`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/interrupt.h>`：定义 `irq_affinity`、`irq_affinity_desc` 等核心结构。\n  - `<linux/group_cpus.h>`：提供 `group_cpus_evenly()` 函数，实现基于拓扑的 CPU 分组。\n  - `<linux/cpu.h>`：访问 CPU 掩码（如 `cpu_possible_mask`）和锁机制（`cpus_read_lock/unlock`）。\n  - `<linux/slab.h>`：内存分配（`kcalloc`/`kfree`）。\n  - `<linux/kernel.h>`：基础内核 API（如 `WARN_ON_ONCE`、`min` 宏）。\n\n- **内核子系统**：\n  - **中断子系统**：与 `irqdesc`、`irqdomain` 等模块协同工作。\n  - **CPU 拓扑管理**：依赖 `group_cpus_evenly` 的底层实现（位于 `kernel/cpu.c`），该函数利用调度域（sched domain）信息进行 CPU 分组。\n\n## 5. 使用场景\n\n- **多队列设备驱动初始化**：  \n  网卡（如 `ixgbe`、`mlx5`）、NVMe SSD 等驱动在申请 MSI-X 中断时，调用 `irq_create_affinity_masks` 生成亲和性掩码，再通过 `pci_alloc_irq_vectors_affinity()` 申请中断，实现中断在 CPU 间的负载均衡。\n\n- **动态中断向量调整**：  \n  设备在运行时调整队列数量时，通过 `irq_calc_affinity_vectors` 计算可用向量数，确保不超过硬件和系统限制。\n\n- **NUMA 感知中断分配**：  \n  `group_cpus_evenly` 自动考虑 NUMA 节点拓扑，使同一队列的中断优先分配到同一 NUMA 节点的 CPU，减少跨节点访问延迟。\n\n- **保留中断向量处理**：  \n  设备可保留部分向量用于管理任务（如 `pre_vectors` 用于控制队列，`post_vectors` 用于错误处理），其余向量交由内核自动分配亲和性。",
      "similarity": 0.5649051666259766,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/affinity.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2016 Thomas Gleixner.",
            " * Copyright (C) 2016-2017 Christoph Hellwig.",
            " */",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpu.h>",
            "#include <linux/group_cpus.h>",
            ""
          ],
          "function_name": null,
          "description": "包含中断亲和性管理所需的头文件，为IRQ核心亲和性配置提供基础支持",
          "similarity": 0.48366641998291016
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/affinity.c",
          "start_line": 12,
          "end_line": 35,
          "content": [
            "static void default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)",
            "{",
            "\taffd->nr_sets = 1;",
            "\taffd->set_size[0] = affvecs;",
            "}",
            "unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,",
            "\t\t\t\t       const struct irq_affinity *affd)",
            "{",
            "\tunsigned int resv = affd->pre_vectors + affd->post_vectors;",
            "\tunsigned int set_vecs;",
            "",
            "\tif (resv > minvec)",
            "\t\treturn 0;",
            "",
            "\tif (affd->calc_sets) {",
            "\t\tset_vecs = maxvec - resv;",
            "\t} else {",
            "\t\tcpus_read_lock();",
            "\t\tset_vecs = cpumask_weight(cpu_possible_mask);",
            "\t\tcpus_read_unlock();",
            "\t}",
            "",
            "\treturn resv + min(set_vecs, maxvec - resv);",
            "}"
          ],
          "function_name": "default_calc_sets, irq_calc_affinity_vectors",
          "description": "定义默认亲和性集合计算函数并实现向量分配策略，用于确定中断向量在CPU核心间的分布方式",
          "similarity": 0.4588313698768616
        }
      ]
    }
  ]
}