{
  "query": "资源分配时如何进行死锁避免检查",
  "timestamp": "2025-12-26 01:08:32",
  "retrieved_files": [
    {
      "source_file": "kernel/locking/ww_mutex.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:56:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\ww_mutex.h`\n\n---\n\n# `locking/ww_mutex.h` 技术文档\n\n## 1. 文件概述\n\n`ww_mutex.h` 是 Linux 内核中用于实现 **Wound-Wait (WW) 互斥锁**（`ww_mutex`）的头文件。该机制主要用于解决 **死锁问题**，特别是在图形子系统（如 DRM/KMS）和资源管理场景中，多个事务（transactions）需要以特定顺序获取多个锁时。  \nWW 互斥锁通过为每个锁请求关联一个 **获取上下文**（`ww_acquire_ctx`），并基于事务的优先级或时间戳实现 **Wait-Die** 或 **Wound-Wait** 死锁避免策略。\n\n该文件通过条件编译（`WW_RT` 宏）支持两种底层锁实现：\n- **普通互斥锁**（`mutex`）：用于非实时（non-RT）内核配置。\n- **实时互斥锁**（`rt_mutex`）：用于实时（RT）内核补丁配置，支持优先级继承。\n\n## 2. 核心功能\n\n### 2.1 主要宏定义\n- `MUTEX` / `MUTEX_WAITER`：根据 `WW_RT` 宏分别映射到 `mutex`/`rt_mutex` 及其等待者结构。\n\n### 2.2 等待者链表/红黑树操作函数（抽象接口）\n- `__ww_waiter_first()`：获取等待队列中的第一个等待者。\n- `__ww_waiter_next()` / `__ww_waiter_prev()`：获取下一个/上一个等待者。\n- `__ww_waiter_last()`：获取等待队列中的最后一个等待者。\n- `__ww_waiter_add()`：将等待者插入到指定位置（普通 mutex 使用链表，RT 使用红黑树）。\n\n### 2.3 锁状态查询函数\n- `__ww_mutex_owner()`：获取当前锁的持有者任务。\n- `__ww_mutex_has_waiters()`：检查锁是否有等待者。\n- `lock_wait_lock()` / `unlock_wait_lock()`：获取/释放锁的等待队列自旋锁（`wait_lock`）。\n- `lockdep_assert_wait_lock_held()`：调试时断言 `wait_lock` 已被持有。\n\n### 2.4 WW 互斥锁核心逻辑函数\n- `ww_mutex_lock_acquired()`：在成功获取 `ww_mutex` 后，将其与获取上下文（`ww_ctx`）关联，并执行调试检查。\n- `__ww_ctx_less()`：比较两个获取上下文的优先级（用于决定谁应“等待”或“死亡/被抢占”）。\n- `__ww_mutex_die()`：**Wait-Die 策略**实现：若当前请求者（新事务）发现等待队列中有更老的事务持有其他锁，则唤醒该老事务使其“死亡”（回滚）。\n- `__ww_mutex_wound()`：**Wound-Wait 策略**实现：若当前请求者（老事务）发现锁持有者是更年轻的事务，则“刺伤”（标记 `wounded=1`）该年轻事务，迫使其回滚。\n\n## 3. 关键实现\n\n### 3.1 死锁避免策略\n- **Wait-Die**（`is_wait_die=1`）：\n  - **新事务**请求**老事务**持有的锁 → **新事务等待**。\n  - **新事务**请求**老事务**等待的锁 → **新事务死亡**（回滚）。\n- **Wound-Wait**（`is_wait_die=0`）：\n  - **老事务**请求**新事务**持有的锁 → **新事务被刺伤**（回滚）。\n  - **老事务**请求**新事务**等待的锁 → **老事务等待**。\n\n### 3.2 上下文比较 (`__ww_ctx_less`)\n- **非 RT 模式**：仅基于时间戳（`stamp`），值越大表示事务越新。\n- **RT 模式**：\n  1. 优先比较 **实时优先级**（`prio`），数值越小优先级越高。\n  2. 若均为 **Deadline 调度类**，比较 **截止时间**（`deadline`），越早截止优先级越高。\n  3. 若优先级相同，回退到时间戳比较。\n\n### 3.3 RT 与非 RT 差异\n- **数据结构**：\n  - 非 RT：等待者使用 **双向链表**（`list_head`）。\n  - RT：等待者使用 **红黑树**（`rb_root`），按优先级排序。\n- **插入逻辑**：\n  - 非 RT：`__ww_waiter_add` 显式插入到指定位置。\n  - RT：`__ww_waiter_add` 为空（RT 互斥锁内部自动处理插入）。\n\n### 3.4 调试支持 (`DEBUG_WW_MUTEXES`)\n- 检查 `ww_mutex` 是否被错误地用普通 `mutex_unlock` 释放。\n- 验证上下文一致性（如 `ww_class` 匹配、`contending_lock` 状态等）。\n\n## 4. 依赖关系\n\n- **基础锁机制**：\n  - 非 RT 模式依赖 `<linux/mutex.h>`。\n  - RT 模式依赖 `<linux/rtmutex.h>`。\n- **调度器**：依赖任务结构（`task_struct`）、优先级（`prio`）、调度类（如 `dl_prio`）。\n- **调试框架**：依赖 `lockdep`（`lockdep_assert_held`）和 `DEBUG_LOCKS_WARN_ON`。\n- **原子操作**：使用 `atomic_long_read` 检查锁状态标志（`MUTEX_FLAG_WAITERS`）。\n\n## 5. 使用场景\n\n- **图形子系统**（DRM/KMS）：  \n  多个 GPU 作业（如渲染、合成）需按顺序获取多个缓冲区（buffer）或 CRTC 锁，避免死锁。\n- **资源分配器**：  \n  当多个客户端竞争一组有限资源（如内存区域、I/O 端口）时，通过 WW 互斥锁确保无死锁的分配顺序。\n- **实时系统**（RT 补丁）：  \n  在需要确定性延迟的场景中，结合优先级继承（PI）避免优先级反转，同时通过 WW 策略解决多锁死锁。\n- **文件系统**：  \n  某些文件系统（如 Btrfs）在元数据操作中使用 WW 互斥锁管理多个 extent 锁。",
      "similarity": 0.5986835956573486,
      "chunks": []
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5690155625343323,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5266844630241394
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.4747646152973175
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.4146260619163513
        }
      ]
    },
    {
      "source_file": "kernel/power/wakelock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:29:10\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\wakelock.c`\n\n---\n\n# `power/wakelock.c` 技术文档\n\n## 1. 文件概述\n\n`power/wakelock.c` 实现了 Linux 内核中面向用户空间的 **wakelock（唤醒锁）机制**，允许用户空间程序通过 sysfs 接口创建、激活和释放唤醒锁，以防止系统在特定任务执行期间进入低功耗状态（如 suspend）。该实现借鉴了 Android 系统中的 wakelock 接口，但基于标准 Linux 内核的 `wakeup_source` 基础设施，提供更安全、可配置的用户空间电源管理能力。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct wakelock`**  \n  表示一个用户空间可操作的唤醒锁对象：\n  - `name`：唤醒锁名称（用户指定）\n  - `node`：用于在红黑树 `wakelocks_tree` 中组织所有 wakelock\n  - `ws`：指向内核 `wakeup_source` 对象，实际执行电源管理逻辑\n  - `lru`（条件编译）：用于垃圾回收（GC）机制的 LRU 链表节点（当 `CONFIG_PM_WAKELOCKS_GC` 启用时）\n\n### 主要函数\n\n- **`pm_show_wakelocks(char *buf, bool show_active)`**  \n  将当前所有（活跃或非活跃）wakelock 名称输出到缓冲区，供 sysfs 读取（如 `/sys/power/wake_lock` 或 `/sys/power/wake_unlock`）。\n\n- **`pm_wake_lock(const char *buf)`**  \n  用户空间通过写入 `/sys/power/wake_lock` 触发此函数，用于**获取**指定名称的 wakelock。支持可选超时参数（单位：纳秒）。\n\n- **`pm_wake_unlock(const char *buf)`**  \n  用户空间通过写入 `/sys/power/wake_unlock` 触发此函数，用于**释放**指定名称的 wakelock。\n\n- **`wakelock_lookup_add(const char *name, size_t len, bool add_if_not_found)`**  \n  在全局红黑树中查找或创建 wakelock 对象，是 `pm_wake_lock` 和 `pm_wake_unlock` 的核心辅助函数。\n\n- **`__wakelocks_gc(struct work_struct *work)`**（条件编译）  \n  垃圾回收工作函数，定期清理长时间未使用且非活跃的 wakelock 对象（当 `CONFIG_PM_WAKELOCKS_GC` 启用时）。\n\n### 辅助机制\n\n- **数量限制**：通过 `CONFIG_PM_WAKELOCKS_LIMIT` 控制系统中 wakelock 的最大数量。\n- **LRU 管理**：通过 `wakelocks_lru_add` / `wakelocks_lru_most_recent` 维护最近使用顺序。\n- **自动回收**：通过 `wakelocks_gc()` 触发异步 GC 工作队列。\n\n## 3. 关键实现\n\n### 红黑树管理\n所有 `wakelock` 对象通过名称作为键，存储在全局红黑树 `wakelocks_tree` 中，确保 O(log n) 时间复杂度的查找、插入和删除操作。\n\n### 唤醒源集成\n每个 `wakelock` 封装一个 `wakeup_source`（通过 `wakeup_source_register()` 创建），实际的电源阻止逻辑由内核 PM 子系统的 `wakeup_source` 机制处理：\n- `__pm_stay_awake(ws)`：永久保持唤醒（直到显式释放）\n- `__pm_wakeup_event(ws, timeout_ms)`：带超时的唤醒\n- `__pm_relax(ws)`：释放唤醒锁\n\n### 安全与权限控制\n- 仅具备 `CAP_BLOCK_SUSPEND` 能力的进程可操作 wakelock（防止普通用户滥用导致无法休眠）。\n- 名称解析严格处理空格和换行符，防止注入或解析错误。\n\n### 垃圾回收机制（可选）\n当启用 `CONFIG_PM_WAKELOCKS_GC`：\n- 每次访问 wakelock 时将其移至 LRU 链表头部（`wakelocks_lru_most_recent`）。\n- 每进行 `WL_GC_COUNT_MAX`（默认 100）次操作后，调度 GC 工作。\n- GC 遍历 LRU 链表（从最旧开始），删除满足以下条件的对象：\n  - 非活跃（`!active`）\n  - 空闲时间超过 `WL_GC_TIME_SEC`（默认 300 秒）\n\n### 数量限制（可选）\n当 `CONFIG_PM_WAKELOCKS_LIMIT > 0` 时，系统维护 `number_of_wakelocks` 计数器，防止用户空间创建过多 wakelock 耗尽内存。\n\n## 4. 依赖关系\n\n- **内核头文件**：\n  - `<linux/wakeup_source.h>`（通过 `\"power.h\"` 间接包含）：提供 `wakeup_source` 相关 API\n  - `<linux/sysfs.h>`：通过 `sysfs_emit_at` 实现 sysfs 输出\n  - `<linux/workqueue.h>`：用于 GC 异步任务调度\n  - `<linux/rbtree.h>`：红黑树数据结构支持\n  - `<linux/capability.h>`：权限检查\n\n- **内核子系统**：\n  - **电源管理 (PM) 子系统**：依赖 `wakeup_source` 基础设施实现实际的 suspend 阻止逻辑。\n  - **sysfs**：通过 sysfs 文件（如 `/sys/power/wake_lock`）暴露用户接口。\n  - **内存管理**：使用 `kzalloc`/`kstrndup`/`kfree` 管理动态内存。\n\n- **配置选项**：\n  - `CONFIG_PM_WAKELOCKS`：主开关\n  - `CONFIG_PM_WAKELOCKS_LIMIT`：限制最大数量\n  - `CONFIG_PM_WAKELOCKS_GC`：启用自动垃圾回收\n\n## 5. 使用场景\n\n- **Android 兼容层**：为基于 Android 的系统提供标准 Linux 内核上的 wakelock 支持，无需修改用户空间应用。\n- **用户空间电源控制**：允许特权应用（如媒体播放器、下载管理器）在执行关键任务时阻止系统休眠。\n- **调试与监控**：通过读取 `/sys/power/wake_lock` 查看当前活跃的 wakelock，辅助电源问题诊断。\n- **资源受限设备**：通过 `CONFIG_PM_WAKELOCKS_LIMIT` 和 GC 机制防止内存泄漏，适用于嵌入式或移动设备。",
      "similarity": 0.567794919013977,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/power/wakelock.c",
          "start_line": 254,
          "end_line": 288,
          "content": [
            "int pm_wake_unlock(const char *buf)",
            "{",
            "\tstruct wakelock *wl;",
            "\tsize_t len;",
            "\tint ret = 0;",
            "",
            "\tif (!capable(CAP_BLOCK_SUSPEND))",
            "\t\treturn -EPERM;",
            "",
            "\tlen = strlen(buf);",
            "\tif (!len)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (buf[len-1] == '\\n')",
            "\t\tlen--;",
            "",
            "\tif (!len)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&wakelocks_lock);",
            "",
            "\twl = wakelock_lookup_add(buf, len, false);",
            "\tif (IS_ERR(wl)) {",
            "\t\tret = PTR_ERR(wl);",
            "\t\tgoto out;",
            "\t}",
            "\t__pm_relax(wl->ws);",
            "",
            "\twakelocks_lru_most_recent(wl);",
            "\twakelocks_gc();",
            "",
            " out:",
            "\tmutex_unlock(&wakelocks_lock);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "pm_wake_unlock",
          "description": "提供唤醒锁解除接口，通过名称匹配目标唤醒锁并调用__pm_relax释放，同步更新LRU顺序并触发动态垃圾回收机制",
          "similarity": 0.5304067134857178
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/power/wakelock.c",
          "start_line": 38,
          "end_line": 172,
          "content": [
            "ssize_t pm_show_wakelocks(char *buf, bool show_active)",
            "{",
            "\tstruct rb_node *node;",
            "\tstruct wakelock *wl;",
            "\tint len = 0;",
            "",
            "\tmutex_lock(&wakelocks_lock);",
            "",
            "\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {",
            "\t\twl = rb_entry(node, struct wakelock, node);",
            "\t\tif (wl->ws->active == show_active)",
            "\t\t\tlen += sysfs_emit_at(buf, len, \"%s \", wl->name);",
            "\t}",
            "",
            "\tif (len > 0)",
            "\t\t--len;",
            "",
            "\tlen += sysfs_emit_at(buf, len, \"\\n\");",
            "",
            "\tmutex_unlock(&wakelocks_lock);",
            "\treturn len;",
            "}",
            "static inline bool wakelocks_limit_exceeded(void)",
            "{",
            "\treturn number_of_wakelocks > CONFIG_PM_WAKELOCKS_LIMIT;",
            "}",
            "static inline void increment_wakelocks_number(void)",
            "{",
            "\tnumber_of_wakelocks++;",
            "}",
            "static inline void decrement_wakelocks_number(void)",
            "{",
            "\tnumber_of_wakelocks--;",
            "}",
            "static inline bool wakelocks_limit_exceeded(void) { return false; }",
            "static inline void increment_wakelocks_number(void) {}",
            "static inline void decrement_wakelocks_number(void) {}",
            "static inline void wakelocks_lru_add(struct wakelock *wl)",
            "{",
            "\tlist_add(&wl->lru, &wakelocks_lru_list);",
            "}",
            "static inline void wakelocks_lru_most_recent(struct wakelock *wl)",
            "{",
            "\tlist_move(&wl->lru, &wakelocks_lru_list);",
            "}",
            "static void __wakelocks_gc(struct work_struct *work)",
            "{",
            "\tstruct wakelock *wl, *aux;",
            "\tktime_t now;",
            "",
            "\tmutex_lock(&wakelocks_lock);",
            "",
            "\tnow = ktime_get();",
            "\tlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {",
            "\t\tu64 idle_time_ns;",
            "\t\tbool active;",
            "",
            "\t\tspin_lock_irq(&wl->ws->lock);",
            "\t\tidle_time_ns = ktime_to_ns(ktime_sub(now, wl->ws->last_time));",
            "\t\tactive = wl->ws->active;",
            "\t\tspin_unlock_irq(&wl->ws->lock);",
            "",
            "\t\tif (idle_time_ns < ((u64)WL_GC_TIME_SEC * NSEC_PER_SEC))",
            "\t\t\tbreak;",
            "",
            "\t\tif (!active) {",
            "\t\t\twakeup_source_unregister(wl->ws);",
            "\t\t\trb_erase(&wl->node, &wakelocks_tree);",
            "\t\t\tlist_del(&wl->lru);",
            "\t\t\tkfree(wl->name);",
            "\t\t\tkfree(wl);",
            "\t\t\tdecrement_wakelocks_number();",
            "\t\t}",
            "\t}",
            "\twakelocks_gc_count = 0;",
            "",
            "\tmutex_unlock(&wakelocks_lock);",
            "}",
            "static void wakelocks_gc(void)",
            "{",
            "\tif (++wakelocks_gc_count <= WL_GC_COUNT_MAX)",
            "\t\treturn;",
            "",
            "\tschedule_work(&wakelock_work);",
            "}",
            "static inline void wakelocks_lru_add(struct wakelock *wl) {}",
            "static inline void wakelocks_lru_most_recent(struct wakelock *wl) {}",
            "static inline void wakelocks_gc(void) {}",
            "int pm_wake_lock(const char *buf)",
            "{",
            "\tconst char *str = buf;",
            "\tstruct wakelock *wl;",
            "\tu64 timeout_ns = 0;",
            "\tsize_t len;",
            "\tint ret = 0;",
            "",
            "\tif (!capable(CAP_BLOCK_SUSPEND))",
            "\t\treturn -EPERM;",
            "",
            "\twhile (*str && !isspace(*str))",
            "\t\tstr++;",
            "",
            "\tlen = str - buf;",
            "\tif (!len)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (*str && *str != '\\n') {",
            "\t\t/* Find out if there's a valid timeout string appended. */",
            "\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);",
            "\t\tif (ret)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tmutex_lock(&wakelocks_lock);",
            "",
            "\twl = wakelock_lookup_add(buf, len, true);",
            "\tif (IS_ERR(wl)) {",
            "\t\tret = PTR_ERR(wl);",
            "\t\tgoto out;",
            "\t}",
            "\tif (timeout_ns) {",
            "\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;",
            "",
            "\t\tdo_div(timeout_ms, NSEC_PER_MSEC);",
            "\t\t__pm_wakeup_event(wl->ws, timeout_ms);",
            "\t} else {",
            "\t\t__pm_stay_awake(wl->ws);",
            "\t}",
            "",
            "\twakelocks_lru_most_recent(wl);",
            "",
            " out:",
            "\tmutex_unlock(&wakelocks_lock);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "pm_show_wakelocks, wakelocks_limit_exceeded, increment_wakelocks_number, decrement_wakelocks_number, wakelocks_limit_exceeded, increment_wakelocks_number, decrement_wakelocks_number, wakelocks_lru_add, wakelocks_lru_most_recent, __wakelocks_gc, wakelocks_gc, wakelocks_lru_add, wakelocks_lru_most_recent, wakelocks_gc, pm_wake_lock",
          "description": "实现唤醒锁状态展示、计数控制、LRU列表维护及垃圾回收逻辑，包含唤醒锁激活/释放接口，通过工作队列异步清理闲置唤醒源",
          "similarity": 0.5075233578681946
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/power/wakelock.c",
          "start_line": 1,
          "end_line": 37,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * kernel/power/wakelock.c",
            " *",
            " * User space wakeup sources support.",
            " *",
            " * Copyright (C) 2012 Rafael J. Wysocki <rjw@sisk.pl>",
            " *",
            " * This code is based on the analogous interface allowing user space to",
            " * manipulate wakelocks on Android.",
            " */",
            "",
            "#include <linux/capability.h>",
            "#include <linux/ctype.h>",
            "#include <linux/device.h>",
            "#include <linux/err.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/list.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "",
            "#include \"power.h\"",
            "",
            "static DEFINE_MUTEX(wakelocks_lock);",
            "",
            "struct wakelock {",
            "\tchar\t\t\t*name;",
            "\tstruct rb_node\t\tnode;",
            "\tstruct wakeup_source\t*ws;",
            "#ifdef CONFIG_PM_WAKELOCKS_GC",
            "\tstruct list_head\tlru;",
            "#endif",
            "};",
            "",
            "static struct rb_root wakelocks_tree = RB_ROOT;",
            ""
          ],
          "function_name": null,
          "description": "定义唤醒锁数据结构及其红黑树管理基础，包含名称字段、RB节点、唤醒源指针及LRU链表节点（CONFIG_PM_WAKELOCKS_GC启用时），并初始化红黑树根节点",
          "similarity": 0.4814234972000122
        }
      ]
    }
  ]
}