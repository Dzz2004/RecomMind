{
  "query": "pthread_create在内核中的实现",
  "timestamp": "2025-12-26 00:46:42",
  "retrieved_files": [
    {
      "source_file": "kernel/kthread.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:30:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kthread.c`\n\n---\n\n# kthread.c 技术文档\n\n## 文件概述\n\n`kthread.c` 是 Linux 内核中实现内核线程（kernel thread, kthread）管理机制的核心文件。它提供了创建、控制、同步和销毁内核线程的基础设施，确保内核线程在干净、受控的环境中运行，即使是从用户空间（如 modprobe、CPU 热插拔等）触发创建也能保证一致性。该文件实现了 kthread 的生命周期管理、状态控制（如停止、暂停）、数据访问接口以及与调度器、cgroup、freezer 等子系统的集成。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct kthread_create_info`**  \n  用于在 `kthread_create()` 和后台守护线程 `kthreadd` 之间传递创建参数和结果，包含线程函数、数据、节点信息、任务结构体指针和完成量。\n\n- **`struct kthread`**  \n  内核线程的私有控制块，挂载在 `task_struct->worker_private` 上，包含：\n  - 状态标志位（`KTHREAD_IS_PER_CPU`, `KTHREAD_SHOULD_STOP`, `KTHREAD_SHOULD_PARK`）\n  - CPU 绑定信息\n  - 线程函数指针和用户数据\n  - 用于同步的 `parked` 和 `exited` 完成量\n  - 完整线程名（当 `task->comm` 被截断时使用）\n  - （可选）块设备 cgroup 上下文（`blkcg_css`）\n\n- **全局变量**\n  - `kthread_create_lock`：保护 `kthread_create_list` 的自旋锁\n  - `kthread_create_list`：待创建内核线程的请求队列\n  - `kthreadd_task`：负责实际创建内核线程的守护进程任务结构体\n\n### 主要函数\n\n- **状态查询函数**\n  - `kthread_should_stop()`：检查是否应停止线程（由 `kthread_stop()` 触发）\n  - `kthread_should_park()`：检查是否应暂停线程（由 `kthread_park()` 触发）\n  - `kthread_should_stop_or_park()`：同时检查停止或暂停请求\n  - `kthread_freezable_should_stop()`：支持冻结的 kthread 停止检查，集成 freezer 机制\n\n- **数据访问函数**\n  - `kthread_func()`：获取线程创建时指定的函数指针\n  - `kthread_data()`：获取线程创建时传入的私有数据\n  - `kthread_probe_data()`：安全地探测可能的 kthread 数据（使用 `copy_from_kernel_nofault` 避免崩溃）\n  - `get_kthread_comm()`：获取完整的线程名称（优先使用 `full_name`）\n\n- **生命周期管理**\n  - `set_kthread_struct()`：为新任务分配并初始化 `struct kthread`\n  - `free_kthread_struct()`：释放 `struct kthread` 及其资源\n  - `kthread_parkme()`：将当前线程置于 `TASK_PARKED` 状态并等待唤醒\n  - `kthread_exit()`：终止当前 kthread 并返回结果（未在代码片段中完整显示）\n\n- **辅助函数**\n  - `to_kthread()` / `__to_kthread()`：从 `task_struct` 安全转换为 `struct kthread`，后者不假设任务一定是 kthread\n\n## 关键实现\n\n### kthread 私有数据管理\n- 每个 kthread 通过 `task_struct->worker_private` 指向其 `struct kthread` 实例。\n- `to_kthread()` 在访问前验证 `PF_KTHREAD` 标志，确保类型安全。\n- `__to_kthread()` 更加保守，仅在同时满足 `worker_private != NULL` 且 `PF_KTHREAD` 时才返回有效指针，以应对 `kernel_thread()` 可能执行 `exec()` 导致标志失效的情况。\n\n### 线程暂停机制（Parking）\n- 使用 `TASK_PARKED` 特殊任务状态，避免与常规调度状态冲突。\n- 在设置状态和检查标志之间使用原子操作，防止唤醒丢失。\n- 调用 `schedule_preempt_disabled()` 禁用抢占，确保 `kthread_park()` 调用者能可靠检测到线程已暂停。\n\n### 安全数据访问\n- `kthread_probe_data()` 使用 `copy_from_kernel_nofault()` 安全读取数据指针，即使目标内存无效也不会导致内核 oops，适用于调试或不确定上下文。\n\n### 冻结集成\n- `kthread_freezable_should_stop()` 在检查停止标志前先处理冻结请求，调用 `__refrigerator()` 进入冻结状态，避免 freezer 与 kthread_stop 死锁。\n\n### 名称管理\n- 当线程名超过 `TASK_COMM_LEN` 时，原始名称存储在 `kthread->full_name` 中，`get_kthread_comm()` 优先返回完整名称。\n\n## 依赖关系\n\n- **调度子系统**：依赖 `sched.h` 提供任务状态管理、调度原语（`schedule()`）、CPU 隔离等。\n- **内存管理**：使用 `slab.h` 分配 `kthread` 结构，`mm.h` 处理内存上下文。\n- **同步机制**：依赖 `completion.h` 实现线程创建和状态同步。\n- **cgroup 子系统**：条件编译支持 `CONFIG_BLK_CGROUP`，集成块设备 cgroup 控制。\n- **冻结子系统**：通过 `freezer.h` 与系统 suspend/hibernate 机制协作。\n- **追踪系统**：集成 `trace/events/sched.h` 提供调度事件追踪。\n- **用户空间接口**：通过 `uaccess.h` 支持安全内核空间访问（用于 `kthread_probe_data`）。\n\n## 使用场景\n\n- **内核模块加载**：`modprobe` 触发的模块可能创建 kthread，需通过 `kthreadd` 确保干净环境。\n- **设备驱动**：驱动程序使用 `kthread_run()` 创建工作线程处理中断下半部或轮询任务。\n- **系统服务线程**：如 `kswapd`（内存回收）、`kcompactd`（内存压缩）等核心内核线程。\n- **CPU 热插拔**：在 CPU 上下线时创建或迁移 per-CPU kthread。\n- **电源管理**：通过 `kthread_freezable_should_stop()` 支持系统 suspend 时冻结 kthread。\n- **动态资源管理**：使用 `kthread_park/unpark` 暂停/恢复线程以节省资源（如空闲时暂停工作线程）。\n- **调试与监控**：工具通过 `kthread_func()` 和 `kthread_data()` 获取线程上下文信息。",
      "similarity": 0.6421884894371033,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/kthread.c",
          "start_line": 299,
          "end_line": 413,
          "content": [
            "void kthread_parkme(void)",
            "{",
            "\t__kthread_parkme(to_kthread(current));",
            "}",
            "void __noreturn kthread_exit(long result)",
            "{",
            "\tstruct kthread *kthread = to_kthread(current);",
            "\tkthread->result = result;",
            "\tdo_exit(0);",
            "}",
            "void __noreturn kthread_complete_and_exit(struct completion *comp, long code)",
            "{",
            "\tif (comp)",
            "\t\tcomplete(comp);",
            "",
            "\tkthread_exit(code);",
            "}",
            "static int kthread(void *_create)",
            "{",
            "\tstatic const struct sched_param param = { .sched_priority = 0 };",
            "\t/* Copy data: it's on kthread's stack */",
            "\tstruct kthread_create_info *create = _create;",
            "\tint (*threadfn)(void *data) = create->threadfn;",
            "\tvoid *data = create->data;",
            "\tstruct completion *done;",
            "\tstruct kthread *self;",
            "\tint ret;",
            "",
            "\tself = to_kthread(current);",
            "",
            "\t/* Release the structure when caller killed by a fatal signal. */",
            "\tdone = xchg(&create->done, NULL);",
            "\tif (!done) {",
            "\t\tkfree(create->full_name);",
            "\t\tkfree(create);",
            "\t\tkthread_exit(-EINTR);",
            "\t}",
            "",
            "\tself->full_name = create->full_name;",
            "\tself->threadfn = threadfn;",
            "\tself->data = data;",
            "",
            "\t/*",
            "\t * The new thread inherited kthreadd's priority and CPU mask. Reset",
            "\t * back to default in case they have been changed.",
            "\t */",
            "\tsched_setscheduler_nocheck(current, SCHED_NORMAL, &param);",
            "\tset_cpus_allowed_ptr(current, housekeeping_cpumask(HK_TYPE_KTHREAD));",
            "",
            "\t/* OK, tell user we're spawned, wait for stop or wakeup */",
            "\t__set_current_state(TASK_UNINTERRUPTIBLE);",
            "\tcreate->result = current;",
            "\t/*",
            "\t * Thread is going to call schedule(), do not preempt it,",
            "\t * or the creator may spend more time in wait_task_inactive().",
            "\t */",
            "\tpreempt_disable();",
            "\tcomplete(done);",
            "\tschedule_preempt_disabled();",
            "\tpreempt_enable();",
            "",
            "\tret = -EINTR;",
            "\tif (!test_bit(KTHREAD_SHOULD_STOP, &self->flags)) {",
            "\t\tcgroup_kthread_ready();",
            "\t\t__kthread_parkme(self);",
            "\t\tret = threadfn(data);",
            "\t}",
            "\tkthread_exit(ret);",
            "}",
            "int tsk_fork_get_node(struct task_struct *tsk)",
            "{",
            "#ifdef CONFIG_NUMA",
            "\tif (tsk == kthreadd_task)",
            "\t\treturn tsk->pref_node_fork;",
            "#endif",
            "\treturn NUMA_NO_NODE;",
            "}",
            "static void create_kthread(struct kthread_create_info *create)",
            "{",
            "\tint pid;",
            "",
            "#ifdef CONFIG_NUMA",
            "\tcurrent->pref_node_fork = create->node;",
            "#endif",
            "\t/* We want our own signal handler (we take no signals by default). */",
            "\tpid = kernel_thread(kthread, create, create->full_name,",
            "\t\t\t    CLONE_FS | CLONE_FILES | SIGCHLD);",
            "\tif (pid < 0) {",
            "\t\t/* Release the structure when caller killed by a fatal signal. */",
            "\t\tstruct completion *done = xchg(&create->done, NULL);",
            "",
            "\t\tkfree(create->full_name);",
            "\t\tif (!done) {",
            "\t\t\tkfree(create);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tcreate->result = ERR_PTR(pid);",
            "\t\tcomplete(done);",
            "\t}",
            "}",
            "static void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!wait_task_inactive(p, state)) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* It's safe because the task is inactive. */",
            "\traw_spin_lock_irqsave(&p->pi_lock, flags);",
            "\tdo_set_cpus_allowed(p, mask);",
            "\tp->flags |= PF_NO_SETAFFINITY;",
            "\traw_spin_unlock_irqrestore(&p->pi_lock, flags);",
            "}"
          ],
          "function_name": "kthread_parkme, kthread_exit, kthread_complete_and_exit, kthread, tsk_fork_get_node, create_kthread, __kthread_bind_mask",
          "description": "处理线程执行流程、节点绑定及异常退出，kthread作为内核线程入口执行指定函数，create_kthread创建新线程并绑定CPU，__kthread_bind_mask调整线程CPU亲和性。",
          "similarity": 0.6363894939422607
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/kthread.c",
          "start_line": 731,
          "end_line": 846,
          "content": [
            "int kthread_stop_put(struct task_struct *k)",
            "{",
            "\tint ret;",
            "",
            "\tret = kthread_stop(k);",
            "\tput_task_struct(k);",
            "\treturn ret;",
            "}",
            "int kthreadd(void *unused)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\t/* Setup a clean context for our children to inherit. */",
            "\tset_task_comm(tsk, \"kthreadd\");",
            "\tignore_signals(tsk);",
            "\tset_cpus_allowed_ptr(tsk, housekeeping_cpumask(HK_TYPE_KTHREAD));",
            "\tset_mems_allowed(node_states[N_MEMORY]);",
            "",
            "\tcurrent->flags |= PF_NOFREEZE;",
            "\tcgroup_init_kthreadd();",
            "",
            "\tfor (;;) {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tif (list_empty(&kthread_create_list))",
            "\t\t\tschedule();",
            "\t\t__set_current_state(TASK_RUNNING);",
            "",
            "\t\tspin_lock(&kthread_create_lock);",
            "\t\twhile (!list_empty(&kthread_create_list)) {",
            "\t\t\tstruct kthread_create_info *create;",
            "",
            "\t\t\tcreate = list_entry(kthread_create_list.next,",
            "\t\t\t\t\t    struct kthread_create_info, list);",
            "\t\t\tlist_del_init(&create->list);",
            "\t\t\tspin_unlock(&kthread_create_lock);",
            "",
            "\t\t\tcreate_kthread(create);",
            "",
            "\t\t\tspin_lock(&kthread_create_lock);",
            "\t\t}",
            "\t\tspin_unlock(&kthread_create_lock);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __kthread_init_worker(struct kthread_worker *worker,",
            "\t\t\t\tconst char *name,",
            "\t\t\t\tstruct lock_class_key *key)",
            "{",
            "\tmemset(worker, 0, sizeof(struct kthread_worker));",
            "\traw_spin_lock_init(&worker->lock);",
            "\tlockdep_set_class_and_name(&worker->lock, key, name);",
            "\tINIT_LIST_HEAD(&worker->work_list);",
            "\tINIT_LIST_HEAD(&worker->delayed_work_list);",
            "}",
            "int kthread_worker_fn(void *worker_ptr)",
            "{",
            "\tstruct kthread_worker *worker = worker_ptr;",
            "\tstruct kthread_work *work;",
            "",
            "\t/*",
            "\t * FIXME: Update the check and remove the assignment when all kthread",
            "\t * worker users are created using kthread_create_worker*() functions.",
            "\t */",
            "\tWARN_ON(worker->task && worker->task != current);",
            "\tworker->task = current;",
            "",
            "\tif (worker->flags & KTW_FREEZABLE)",
            "\t\tset_freezable();",
            "",
            "repeat:",
            "\tset_current_state(TASK_INTERRUPTIBLE);\t/* mb paired w/ kthread_stop */",
            "",
            "\tif (kthread_should_stop()) {",
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t\traw_spin_lock_irq(&worker->lock);",
            "\t\tworker->task = NULL;",
            "\t\traw_spin_unlock_irq(&worker->lock);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\twork = NULL;",
            "\traw_spin_lock_irq(&worker->lock);",
            "\tif (!list_empty(&worker->work_list)) {",
            "\t\twork = list_first_entry(&worker->work_list,",
            "\t\t\t\t\tstruct kthread_work, node);",
            "\t\tlist_del_init(&work->node);",
            "\t}",
            "\tworker->current_work = work;",
            "\traw_spin_unlock_irq(&worker->lock);",
            "",
            "\tif (work) {",
            "\t\tkthread_work_func_t func = work->func;",
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t\ttrace_sched_kthread_work_execute_start(work);",
            "\t\twork->func(work);",
            "\t\t/*",
            "\t\t * Avoid dereferencing work after this point.  The trace",
            "\t\t * event only cares about the address.",
            "\t\t */",
            "\t\ttrace_sched_kthread_work_execute_end(work, func);",
            "\t} else if (!freezing(current)) {",
            "\t\tschedule();",
            "\t} else {",
            "\t\t/*",
            "\t\t * Handle the case where the current remains",
            "\t\t * TASK_INTERRUPTIBLE. try_to_freeze() expects",
            "\t\t * the current to be TASK_RUNNING.",
            "\t\t */",
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t}",
            "",
            "\ttry_to_freeze();",
            "\tcond_resched();",
            "\tgoto repeat;",
            "}"
          ],
          "function_name": "kthread_stop_put, kthreadd, __kthread_init_worker, kthread_worker_fn",
          "description": "实现kthreadd主线程逻辑及工作队列管理，kthreadd持续处理线程创建请求，kthread_worker_fn作为工作队列执行入口，支持可冻结状态下的任务调度。",
          "similarity": 0.5801029801368713
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/kthread.c",
          "start_line": 982,
          "end_line": 1095,
          "content": [
            "static inline bool queuing_blocked(struct kthread_worker *worker,",
            "\t\t\t\t   struct kthread_work *work)",
            "{",
            "\tlockdep_assert_held(&worker->lock);",
            "",
            "\treturn !list_empty(&work->node) || work->canceling;",
            "}",
            "static void kthread_insert_work_sanity_check(struct kthread_worker *worker,",
            "\t\t\t\t\t     struct kthread_work *work)",
            "{",
            "\tlockdep_assert_held(&worker->lock);",
            "\tWARN_ON_ONCE(!list_empty(&work->node));",
            "\t/* Do not use a work with >1 worker, see kthread_queue_work() */",
            "\tWARN_ON_ONCE(work->worker && work->worker != worker);",
            "}",
            "static void kthread_insert_work(struct kthread_worker *worker,",
            "\t\t\t\tstruct kthread_work *work,",
            "\t\t\t\tstruct list_head *pos)",
            "{",
            "\tkthread_insert_work_sanity_check(worker, work);",
            "",
            "\ttrace_sched_kthread_work_queue_work(worker, work);",
            "",
            "\tlist_add_tail(&work->node, pos);",
            "\twork->worker = worker;",
            "\tif (!worker->current_work && likely(worker->task))",
            "\t\twake_up_process(worker->task);",
            "}",
            "bool kthread_queue_work(struct kthread_worker *worker,",
            "\t\t\tstruct kthread_work *work)",
            "{",
            "\tbool ret = false;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "\tif (!queuing_blocked(worker, work)) {",
            "\t\tkthread_insert_work(worker, work, &worker->work_list);",
            "\t\tret = true;",
            "\t}",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "\treturn ret;",
            "}",
            "void kthread_delayed_work_timer_fn(struct timer_list *t)",
            "{",
            "\tstruct kthread_delayed_work *dwork = from_timer(dwork, t, timer);",
            "\tstruct kthread_work *work = &dwork->work;",
            "\tstruct kthread_worker *worker = work->worker;",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * This might happen when a pending work is reinitialized.",
            "\t * It means that it is used a wrong way.",
            "\t */",
            "\tif (WARN_ON_ONCE(!worker))",
            "\t\treturn;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "\t/* Work must not be used with >1 worker, see kthread_queue_work(). */",
            "\tWARN_ON_ONCE(work->worker != worker);",
            "",
            "\t/* Move the work from worker->delayed_work_list. */",
            "\tWARN_ON_ONCE(list_empty(&work->node));",
            "\tlist_del_init(&work->node);",
            "\tif (!work->canceling)",
            "\t\tkthread_insert_work(worker, work, &worker->work_list);",
            "",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "}",
            "static void __kthread_queue_delayed_work(struct kthread_worker *worker,",
            "\t\t\t\t\t struct kthread_delayed_work *dwork,",
            "\t\t\t\t\t unsigned long delay)",
            "{",
            "\tstruct timer_list *timer = &dwork->timer;",
            "\tstruct kthread_work *work = &dwork->work;",
            "",
            "\tWARN_ON_ONCE(timer->function != kthread_delayed_work_timer_fn);",
            "",
            "\t/*",
            "\t * If @delay is 0, queue @dwork->work immediately.  This is for",
            "\t * both optimization and correctness.  The earliest @timer can",
            "\t * expire is on the closest next tick and delayed_work users depend",
            "\t * on that there's no such delay when @delay is 0.",
            "\t */",
            "\tif (!delay) {",
            "\t\tkthread_insert_work(worker, work, &worker->work_list);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Be paranoid and try to detect possible races already now. */",
            "\tkthread_insert_work_sanity_check(worker, work);",
            "",
            "\tlist_add(&work->node, &worker->delayed_work_list);",
            "\twork->worker = worker;",
            "\ttimer->expires = jiffies + delay;",
            "\tadd_timer(timer);",
            "}",
            "bool kthread_queue_delayed_work(struct kthread_worker *worker,",
            "\t\t\t\tstruct kthread_delayed_work *dwork,",
            "\t\t\t\tunsigned long delay)",
            "{",
            "\tstruct kthread_work *work = &dwork->work;",
            "\tunsigned long flags;",
            "\tbool ret = false;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "",
            "\tif (!queuing_blocked(worker, work)) {",
            "\t\t__kthread_queue_delayed_work(worker, dwork, delay);",
            "\t\tret = true;",
            "\t}",
            "",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "queuing_blocked, kthread_insert_work_sanity_check, kthread_insert_work, kthread_queue_work, kthread_delayed_work_timer_fn, __kthread_queue_delayed_work, kthread_queue_delayed_work",
          "description": "实现kthread_worker与kthread_work的队列管理，包含插入/延迟插入逻辑、锁保护及任务唤醒机制，处理工作项状态校验和延迟定时器回调",
          "similarity": 0.5703855752944946
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kthread.c",
          "start_line": 102,
          "end_line": 211,
          "content": [
            "void get_kthread_comm(char *buf, size_t buf_size, struct task_struct *tsk)",
            "{",
            "\tstruct kthread *kthread = to_kthread(tsk);",
            "",
            "\tif (!kthread || !kthread->full_name) {",
            "\t\t__get_task_comm(buf, buf_size, tsk);",
            "\t\treturn;",
            "\t}",
            "",
            "\tstrscpy_pad(buf, kthread->full_name, buf_size);",
            "}",
            "bool set_kthread_struct(struct task_struct *p)",
            "{",
            "\tstruct kthread *kthread;",
            "",
            "\tif (WARN_ON_ONCE(to_kthread(p)))",
            "\t\treturn false;",
            "",
            "\tkthread = kzalloc(sizeof(*kthread), GFP_KERNEL);",
            "\tif (!kthread)",
            "\t\treturn false;",
            "",
            "\tinit_completion(&kthread->exited);",
            "\tinit_completion(&kthread->parked);",
            "\tp->vfork_done = &kthread->exited;",
            "",
            "\tp->worker_private = kthread;",
            "\treturn true;",
            "}",
            "void free_kthread_struct(struct task_struct *k)",
            "{",
            "\tstruct kthread *kthread;",
            "",
            "\t/*",
            "\t * Can be NULL if kmalloc() in set_kthread_struct() failed.",
            "\t */",
            "\tkthread = to_kthread(k);",
            "\tif (!kthread)",
            "\t\treturn;",
            "",
            "#ifdef CONFIG_BLK_CGROUP",
            "\tWARN_ON_ONCE(kthread->blkcg_css);",
            "#endif",
            "\tk->worker_private = NULL;",
            "\tkfree(kthread->full_name);",
            "\tkfree(kthread);",
            "}",
            "bool kthread_should_stop(void)",
            "{",
            "\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);",
            "}",
            "static bool __kthread_should_park(struct task_struct *k)",
            "{",
            "\treturn test_bit(KTHREAD_SHOULD_PARK, &to_kthread(k)->flags);",
            "}",
            "bool kthread_should_park(void)",
            "{",
            "\treturn __kthread_should_park(current);",
            "}",
            "bool kthread_should_stop_or_park(void)",
            "{",
            "\tstruct kthread *kthread = __to_kthread(current);",
            "",
            "\tif (!kthread)",
            "\t\treturn false;",
            "",
            "\treturn kthread->flags & (BIT(KTHREAD_SHOULD_STOP) | BIT(KTHREAD_SHOULD_PARK));",
            "}",
            "bool kthread_freezable_should_stop(bool *was_frozen)",
            "{",
            "\tbool frozen = false;",
            "",
            "\tmight_sleep();",
            "",
            "\tif (unlikely(freezing(current)))",
            "\t\tfrozen = __refrigerator(true);",
            "",
            "\tif (was_frozen)",
            "\t\t*was_frozen = frozen;",
            "",
            "\treturn kthread_should_stop();",
            "}",
            "static void __kthread_parkme(struct kthread *self)",
            "{",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * TASK_PARKED is a special state; we must serialize against",
            "\t\t * possible pending wakeups to avoid store-store collisions on",
            "\t\t * task->state.",
            "\t\t *",
            "\t\t * Such a collision might possibly result in the task state",
            "\t\t * changin from TASK_PARKED and us failing the",
            "\t\t * wait_task_inactive() in kthread_park().",
            "\t\t */",
            "\t\tset_special_state(TASK_PARKED);",
            "\t\tif (!test_bit(KTHREAD_SHOULD_PARK, &self->flags))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * Thread is going to call schedule(), do not preempt it,",
            "\t\t * or the caller of kthread_park() may spend more time in",
            "\t\t * wait_task_inactive().",
            "\t\t */",
            "\t\tpreempt_disable();",
            "\t\tcomplete(&self->parked);",
            "\t\tschedule_preempt_disabled();",
            "\t\tpreempt_enable();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "}"
          ],
          "function_name": "get_kthread_comm, set_kthread_struct, free_kthread_struct, kthread_should_stop, __kthread_should_park, kthread_should_park, kthread_should_stop_or_park, kthread_freezable_should_stop, __kthread_parkme",
          "description": "实现内核线程的名称获取、结构体分配与释放、状态检测等功能，set_kthread_struct分配并初始化线程结构体，kthread_should_stop系列函数检测线程终止或停放标志。",
          "similarity": 0.5702913999557495
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/kthread.c",
          "start_line": 1490,
          "end_line": 1539,
          "content": [
            "void kthread_unuse_mm(struct mm_struct *mm)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tWARN_ON_ONCE(!(tsk->flags & PF_KTHREAD));",
            "\tWARN_ON_ONCE(!tsk->mm);",
            "",
            "\ttask_lock(tsk);",
            "\t/*",
            "\t * When a kthread stops operating on an address space, the loop",
            "\t * in membarrier_{private,global}_expedited() may not observe",
            "\t * that tsk->mm, and not issue an IPI. Membarrier requires a",
            "\t * memory barrier after accessing user-space memory, before",
            "\t * clearing tsk->mm.",
            "\t */",
            "\tsmp_mb__after_spinlock();",
            "\tsync_mm_rss(mm);",
            "\tlocal_irq_disable();",
            "\ttsk->mm = NULL;",
            "\tmembarrier_update_current_mm(NULL);",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(tsk, NULL);",
            "\t#endif",
            "\tmmgrab_lazy_tlb(mm);",
            "\t/* active_mm is still 'mm' */",
            "\tenter_lazy_tlb(mm, tsk);",
            "\tlocal_irq_enable();",
            "\ttask_unlock(tsk);",
            "",
            "\tmmdrop(mm);",
            "}",
            "void kthread_associate_blkcg(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct kthread *kthread;",
            "",
            "\tif (!(current->flags & PF_KTHREAD))",
            "\t\treturn;",
            "\tkthread = to_kthread(current);",
            "\tif (!kthread)",
            "\t\treturn;",
            "",
            "\tif (kthread->blkcg_css) {",
            "\t\tcss_put(kthread->blkcg_css);",
            "\t\tkthread->blkcg_css = NULL;",
            "\t}",
            "\tif (css) {",
            "\t\tcss_get(css);",
            "\t\tkthread->blkcg_css = css;",
            "\t}",
            "}"
          ],
          "function_name": "kthread_unuse_mm, kthread_associate_blkcg",
          "description": "管理kthread的地址空间切换，包含内存屏障同步、TLB更新及块控制组绑定操作，确保上下文切换安全性",
          "similarity": 0.533710777759552
        }
      ]
    },
    {
      "source_file": "kernel/pid_sysctl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_sysctl.h`\n\n---\n\n# `pid_sysctl.h` 技术文档\n\n## 1. 文件概述\n\n`pid_sysctl.h` 是 Linux 内核中用于定义与 PID 命名空间（`pid_namespace`）相关的系统控制（sysctl）接口的头文件。其核心功能是提供对 `memfd_noexec` 系统策略的运行时配置支持，该策略用于控制通过 `memfd_create()` 创建的内存文件是否允许执行代码。该配置具有层级继承语义：子 PID 命名空间的策略不能比其父命名空间更宽松，以确保安全策略的向下兼容性和强制性。\n\n## 2. 核心功能\n\n### 函数\n\n- **`pid_mfd_noexec_dointvec_minmax`**  \n  自定义的 sysctl 处理函数，用于读写 `memfd_noexec` 策略值。在写入时执行权限检查和策略继承约束验证。\n\n- **`register_pid_ns_sysctl_table_vm`**  \n  内联函数，用于向内核 sysctl 子系统注册 `vm.memfd_noexec` 控制项（仅在 `CONFIG_SYSCTL` 和 `CONFIG_MEMFD_CREATE` 同时启用时有效）。\n\n### 数据结构\n\n- **`pid_ns_ctl_table_vm`**  \n  `ctl_table` 类型的静态数组，定义了 `vm.memfd_noexec` sysctl 条目，包括其名称、数据指针、访问权限、处理函数及取值范围（0 到 2）。\n\n## 3. 关键实现\n\n- **权限控制**：  \n  在写入 `memfd_noexec` 值时，调用 `ns_capable(ns->user_ns, CAP_SYS_ADMIN)` 检查当前任务是否在对应用户命名空间中拥有 `CAP_SYS_ADMIN` 能力，防止非特权用户修改安全策略。\n\n- **策略继承约束**：  \n  通过 `pidns_memfd_noexec_scope(ns->parent)` 获取父 PID 命名空间的策略值 `parent_scope`，并确保当前命名空间的策略值 `scope` 不小于父策略（即不能更宽松）。实际写入前使用 `max(READ_ONCE(ns->memfd_noexec_scope), parent_scope)` 保证该约束。\n\n- **原子读写**：  \n  使用 `READ_ONCE()` 和 `WRITE_ONCE()` 对 `ns->memfd_noexec_scope` 进行访问，确保在并发环境下内存访问的可见性和顺序性。\n\n- **sysctl 注册**：  \n  通过 `register_sysctl(\"vm\", pid_ns_ctl_table_vm)` 将控制项注册到 `/proc/sys/vm/memfd_noexec` 路径下，供用户空间通过标准 sysctl 接口访问。\n\n- **条件编译**：  \n  整个功能仅在 `CONFIG_SYSCTL`（启用 sysctl 支持）和 `CONFIG_MEMFD_CREATE`（启用 memfd_create 系统调用）同时配置时编译，否则 `register_pid_ns_sysctl_table_vm` 为空内联函数，避免代码膨胀。\n\n## 4. 依赖关系\n\n- **`<linux/pid_namespace.h>`**：  \n  提供 `struct pid_namespace` 定义及辅助函数如 `task_active_pid_ns()` 和 `pidns_memfd_noexec_scope()`。\n\n- **`CONFIG_SYSCTL`**：  \n  内核配置选项，启用 sysctl 框架支持，提供 `register_sysctl`、`proc_dointvec_minmax` 等接口。\n\n- **`CONFIG_MEMFD_CREATE`**：  \n  内核配置选项，启用 `memfd_create()` 系统调用及相关功能（如 `memfd_noexec_scope` 字段）。\n\n- **能力子系统（Capabilities）**：  \n  依赖 `ns_capable()` 进行命名空间感知的权限检查。\n\n## 5. 使用场景\n\n- **安全策略配置**：  \n  系统管理员或容器运行时可通过写入 `/proc/sys/vm/memfd_noexec` 设置当前 PID 命名空间中 `memfd` 文件的执行限制级别（0=允许执行，1=禁止执行但可覆盖，2=严格禁止执行），用于防御基于内存文件的代码注入攻击。\n\n- **容器隔离**：  \n  在容器化环境中，不同容器运行在独立的 PID 命名空间中。父命名空间（如宿主机）可设置较严格的 `memfd_noexec` 策略，子容器无法降低该策略级别，从而实现自上而下的安全策略强制。\n\n- **运行时动态调整**：  \n  允许在系统运行期间动态调整 `memfd` 执行策略，无需重启或重新加载内核模块，提升系统灵活性与安全性。",
      "similarity": 0.5627689361572266,
      "chunks": []
    },
    {
      "source_file": "kernel/smpboot.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:25:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `smpboot.c`\n\n---\n\n# smpboot.c 技术文档\n\n## 1. 文件概述\n\n`smpboot.c` 是 Linux 内核中用于管理对称多处理（SMP）系统中 CPU 热插拔（hotplug）相关线程的通用框架实现。该文件主要提供两类功能：\n\n1. **空闲线程（idle thread）管理**：为每个 CPU 创建和维护专用的空闲任务（idle task），这是 CPU 启动和运行的基础。\n2. **每 CPU 热插拔线程注册机制**：为内核子系统（如迁移线程、RCU 线程等）提供统一的接口，用于创建、启停、挂起/恢复与 CPU 生命周期绑定的 per-CPU 内核线程。\n\n该文件是 SMP 系统 CPU 在线/离线流程中的关键组件，确保相关 per-CPU 资源能随 CPU 状态变化而正确初始化或清理。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct smpboot_thread_data`**  \n  封装每个 per-CPU 热插拔线程的运行时上下文，包含 CPU 编号、状态（NONE/ACTIVE/PARKED）和指向 `smp_hotplug_thread` 描述符的指针。\n\n- **`struct smp_hotplug_thread`**（定义在 `include/linux/smpboot.h`）  \n  用户注册的热插拔线程描述符，包含以下回调函数指针：\n  - `setup()`：CPU 上线前调用\n  - `unpark()`：线程从挂起状态恢复时调用\n  - `park()`：线程被挂起前调用\n  - `cleanup()`：线程退出前调用\n  - `thread_fn()`：线程主循环函数\n  - `thread_should_run()`：判断线程是否应执行主函数\n  - `create()`：线程创建后调用（需确保线程已挂起）\n  - `store`：per-CPU 指针，用于存储线程的 `task_struct`\n  - `thread_comm`：线程名称\n  - `selfparking`：标志位，指示线程是否自行管理挂起状态\n\n- **`idle_threads`**（per-CPU 变量）  \n  存储每个 CPU 对应的 idle 线程的 `task_struct` 指针。\n\n### 主要函数\n\n#### Idle 线程管理（仅当 `CONFIG_GENERIC_SMP_IDLE_THREAD` 启用时）\n- `idle_thread_get(cpu)`：获取指定 CPU 的 idle 线程\n- `idle_thread_set_boot_cpu()`：将当前 CPU（启动 CPU）的 idle 线程设为 `current`\n- `idle_init(cpu)`：为指定 CPU 创建 idle 线程（调用 `fork_idle()`）\n- `idle_threads_init()`：为所有非启动 CPU 初始化 idle 线程\n\n#### 热插拔线程管理\n- `smpboot_register_percpu_thread(plug_thread)`：注册一个 per-CPU 热插拔线程，并为所有在线 CPU 创建线程\n- `smpboot_unregister_percpu_thread(plug_thread)`：注销已注册的热插拔线程，并停止所有 CPU 上的对应线程\n- `smpboot_create_threads(cpu)`：为指定 CPU 创建所有已注册的热插拔线程\n- `smpboot_unpark_threads(cpu)`：恢复（unpark）指定 CPU 上所有热插拔线程\n- `smpboot_park_threads(cpu)`：挂起（park）指定 CPU 上所有热插拔线程\n\n#### 内部辅助函数\n- `smpboot_thread_fn(data)`：热插拔线程的通用主循环函数\n- `__smpboot_create_thread(ht, cpu)`：为指定 CPU 创建单个热插拔线程\n- `smpboot_destroy_threads(ht)`：销毁指定热插拔线程在所有可能 CPU 上的实例\n\n## 3. 关键实现\n\n### Idle 线程复用机制\n- 在支持热插拔的系统中，idle 线程不会在 CPU 离线时销毁，而是保留其 `task_struct` 以便 CPU 重新上线时复用，避免重复分配开销。\n- 启动 CPU 的 idle 线程直接使用内核初始化时创建的 `init_task`（即 `current`）。\n\n### 热插拔线程生命周期管理\n- **创建**：通过 `kthread_create_on_cpu()` 创建绑定到目标 CPU 的内核线程，并立即调用 `kthread_park()` 将其置于挂起状态，确保线程不会在 CPU 未准备好时运行。\n- **状态机**：线程内部维护 `HP_THREAD_NONE` → `HP_THREAD_ACTIVE` ↔ `HP_THREAD_PARKED` 的状态转换，精确控制回调函数的调用时机。\n- **挂起/恢复**：利用 `kthread_park()`/`kthread_unpark()` 机制，配合 `park()`/`unpark()` 回调，实现 CPU 离线/上线时的资源管理。\n- **退出**：通过 `kthread_stop()` 安全终止线程，并调用 `cleanup()` 回调进行资源释放。\n\n### 并发控制\n- 使用 `smpboot_threads_lock` 互斥锁保护全局热插拔线程链表 `hotplug_threads`，确保注册/注销操作的原子性。\n- 在注册/注销过程中使用 `cpus_read_lock()` 保证 CPU 在线状态的一致性。\n\n### 自托管线程支持\n- 通过 `selfparking` 标志位，允许某些特殊线程（如迁移线程）自行管理挂起状态，此时框架不会主动调用 `kthread_park()`/`kthread_unpark()`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/smpboot.h>`：定义 `struct smp_hotplug_thread` 和对外 API\n  - `<linux/kthread.h>`：内核线程创建和管理接口\n  - `<linux/cpu.h>`：CPU 热插拔通知机制\n  - `<linux/percpu.h>`：per-CPU 变量支持\n  - 其他基础内核头文件（如 `sched.h`, `slab.h` 等）\n\n- **功能依赖**：\n  - 依赖内核线程子系统（kthread）实现线程创建和状态管理\n  - 依赖 CPU 热插拔框架（通过 `cpuhp` 子系统调用 `smpboot_create_threads()` 等函数）\n  - 依赖调度器提供 `fork_idle()` 和任务状态管理\n\n- **被依赖模块**：\n  - 迁移线程（migration）、RCU 每 CPU 线程、工作队列（workqueue）等需要 per-CPU 热插拔线程的子系统\n\n## 5. 使用场景\n\n1. **系统启动阶段**：\n   - 为所有可能的 CPU 预创建 idle 线程（`idle_threads_init()`）\n   - 为在线 CPU 创建并启动已注册的 per-CPU 热插拔线程（如 migration 线程）\n\n2. **CPU 热插拔过程**：\n   - **CPU 上线**：调用 `smpboot_create_threads()` 创建线程，再调用 `smpboot_unpark_threads()` 恢复运行\n   - **CPU 离线**：调用 `smpboot_park_threads()` 挂起线程，使其停止执行\n\n3. **内核子系统初始化/退出**：\n   - 子系统通过 `smpboot_register_percpu_thread()` 注册自己的 per-CPU 线程（如 softirq、RCU）\n   - 退出时调用 `smpboot_unregister_percpu_thread()` 清理所有线程实例\n\n4. **动态 CPU 管理**：\n   - 在支持 CPU 热插拔的系统中，该框架确保 per-CPU 线程能随 CPU 状态变化而动态启停，维持系统稳定性。",
      "similarity": 0.5605081915855408,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/smpboot.c",
          "start_line": 39,
          "end_line": 170,
          "content": [
            "void __init idle_thread_set_boot_cpu(void)",
            "{",
            "\tper_cpu(idle_threads, smp_processor_id()) = current;",
            "}",
            "static __always_inline void idle_init(unsigned int cpu)",
            "{",
            "\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);",
            "",
            "\tif (!tsk) {",
            "\t\ttsk = fork_idle(cpu);",
            "\t\tif (IS_ERR(tsk))",
            "\t\t\tpr_err(\"SMP: fork_idle() failed for CPU %u\\n\", cpu);",
            "\t\telse",
            "\t\t\tper_cpu(idle_threads, cpu) = tsk;",
            "\t}",
            "}",
            "void __init idle_threads_init(void)",
            "{",
            "\tunsigned int cpu, boot_cpu;",
            "",
            "\tboot_cpu = smp_processor_id();",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tif (cpu != boot_cpu)",
            "\t\t\tidle_init(cpu);",
            "\t}",
            "}",
            "static int smpboot_thread_fn(void *data)",
            "{",
            "\tstruct smpboot_thread_data *td = data;",
            "\tstruct smp_hotplug_thread *ht = td->ht;",
            "",
            "\twhile (1) {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tpreempt_disable();",
            "\t\tif (kthread_should_stop()) {",
            "\t\t\t__set_current_state(TASK_RUNNING);",
            "\t\t\tpreempt_enable();",
            "\t\t\t/* cleanup must mirror setup */",
            "\t\t\tif (ht->cleanup && td->status != HP_THREAD_NONE)",
            "\t\t\t\tht->cleanup(td->cpu, cpu_online(td->cpu));",
            "\t\t\tkfree(td);",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\tif (kthread_should_park()) {",
            "\t\t\t__set_current_state(TASK_RUNNING);",
            "\t\t\tpreempt_enable();",
            "\t\t\tif (ht->park && td->status == HP_THREAD_ACTIVE) {",
            "\t\t\t\tBUG_ON(td->cpu != smp_processor_id());",
            "\t\t\t\tht->park(td->cpu);",
            "\t\t\t\ttd->status = HP_THREAD_PARKED;",
            "\t\t\t}",
            "\t\t\tkthread_parkme();",
            "\t\t\t/* We might have been woken for stop */",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tBUG_ON(td->cpu != smp_processor_id());",
            "",
            "\t\t/* Check for state change setup */",
            "\t\tswitch (td->status) {",
            "\t\tcase HP_THREAD_NONE:",
            "\t\t\t__set_current_state(TASK_RUNNING);",
            "\t\t\tpreempt_enable();",
            "\t\t\tif (ht->setup)",
            "\t\t\t\tht->setup(td->cpu);",
            "\t\t\ttd->status = HP_THREAD_ACTIVE;",
            "\t\t\tcontinue;",
            "",
            "\t\tcase HP_THREAD_PARKED:",
            "\t\t\t__set_current_state(TASK_RUNNING);",
            "\t\t\tpreempt_enable();",
            "\t\t\tif (ht->unpark)",
            "\t\t\t\tht->unpark(td->cpu);",
            "\t\t\ttd->status = HP_THREAD_ACTIVE;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!ht->thread_should_run(td->cpu)) {",
            "\t\t\tpreempt_enable_no_resched();",
            "\t\t\tschedule();",
            "\t\t} else {",
            "\t\t\t__set_current_state(TASK_RUNNING);",
            "\t\t\tpreempt_enable();",
            "\t\t\tht->thread_fn(td->cpu);",
            "\t\t}",
            "\t}",
            "}",
            "static int",
            "__smpboot_create_thread(struct smp_hotplug_thread *ht, unsigned int cpu)",
            "{",
            "\tstruct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);",
            "\tstruct smpboot_thread_data *td;",
            "",
            "\tif (tsk)",
            "\t\treturn 0;",
            "",
            "\ttd = kzalloc_node(sizeof(*td), GFP_KERNEL, cpu_to_node(cpu));",
            "\tif (!td)",
            "\t\treturn -ENOMEM;",
            "\ttd->cpu = cpu;",
            "\ttd->ht = ht;",
            "",
            "\ttsk = kthread_create_on_cpu(smpboot_thread_fn, td, cpu,",
            "\t\t\t\t    ht->thread_comm);",
            "\tif (IS_ERR(tsk)) {",
            "\t\tkfree(td);",
            "\t\treturn PTR_ERR(tsk);",
            "\t}",
            "\tkthread_set_per_cpu(tsk, cpu);",
            "\t/*",
            "\t * Park the thread so that it could start right on the CPU",
            "\t * when it is available.",
            "\t */",
            "\tkthread_park(tsk);",
            "\tget_task_struct(tsk);",
            "\t*per_cpu_ptr(ht->store, cpu) = tsk;",
            "\tif (ht->create) {",
            "\t\t/*",
            "\t\t * Make sure that the task has actually scheduled out",
            "\t\t * into park position, before calling the create",
            "\t\t * callback. At least the migration thread callback",
            "\t\t * requires that the task is off the runqueue.",
            "\t\t */",
            "\t\tif (!wait_task_inactive(tsk, TASK_PARKED))",
            "\t\t\tWARN_ON(1);",
            "\t\telse",
            "\t\t\tht->create(cpu);",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "idle_thread_set_boot_cpu, idle_init, idle_threads_init, smpboot_thread_fn, __smpboot_create_thread",
          "description": "实现SMP空闲线程初始化与管理逻辑，包含CPU空闲线程创建、状态切换处理及线程函数执行框架",
          "similarity": 0.5334226489067078
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/smpboot.c",
          "start_line": 213,
          "end_line": 304,
          "content": [
            "int smpboot_create_threads(unsigned int cpu)",
            "{",
            "\tstruct smp_hotplug_thread *cur;",
            "\tint ret = 0;",
            "",
            "\tmutex_lock(&smpboot_threads_lock);",
            "\tlist_for_each_entry(cur, &hotplug_threads, list) {",
            "\t\tret = __smpboot_create_thread(cur, cpu);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "\tmutex_unlock(&smpboot_threads_lock);",
            "\treturn ret;",
            "}",
            "static void smpboot_unpark_thread(struct smp_hotplug_thread *ht, unsigned int cpu)",
            "{",
            "\tstruct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);",
            "",
            "\tif (!ht->selfparking)",
            "\t\tkthread_unpark(tsk);",
            "}",
            "int smpboot_unpark_threads(unsigned int cpu)",
            "{",
            "\tstruct smp_hotplug_thread *cur;",
            "",
            "\tmutex_lock(&smpboot_threads_lock);",
            "\tlist_for_each_entry(cur, &hotplug_threads, list)",
            "\t\tsmpboot_unpark_thread(cur, cpu);",
            "\tmutex_unlock(&smpboot_threads_lock);",
            "\treturn 0;",
            "}",
            "static void smpboot_park_thread(struct smp_hotplug_thread *ht, unsigned int cpu)",
            "{",
            "\tstruct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);",
            "",
            "\tif (tsk && !ht->selfparking)",
            "\t\tkthread_park(tsk);",
            "}",
            "int smpboot_park_threads(unsigned int cpu)",
            "{",
            "\tstruct smp_hotplug_thread *cur;",
            "",
            "\tmutex_lock(&smpboot_threads_lock);",
            "\tlist_for_each_entry_reverse(cur, &hotplug_threads, list)",
            "\t\tsmpboot_park_thread(cur, cpu);",
            "\tmutex_unlock(&smpboot_threads_lock);",
            "\treturn 0;",
            "}",
            "static void smpboot_destroy_threads(struct smp_hotplug_thread *ht)",
            "{",
            "\tunsigned int cpu;",
            "",
            "\t/* We need to destroy also the parked threads of offline cpus */",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tstruct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);",
            "",
            "\t\tif (tsk) {",
            "\t\t\tkthread_stop_put(tsk);",
            "\t\t\t*per_cpu_ptr(ht->store, cpu) = NULL;",
            "\t\t}",
            "\t}",
            "}",
            "int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)",
            "{",
            "\tunsigned int cpu;",
            "\tint ret = 0;",
            "",
            "\tcpus_read_lock();",
            "\tmutex_lock(&smpboot_threads_lock);",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tret = __smpboot_create_thread(plug_thread, cpu);",
            "\t\tif (ret) {",
            "\t\t\tsmpboot_destroy_threads(plug_thread);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tsmpboot_unpark_thread(plug_thread, cpu);",
            "\t}",
            "\tlist_add(&plug_thread->list, &hotplug_threads);",
            "out:",
            "\tmutex_unlock(&smpboot_threads_lock);",
            "\tcpus_read_unlock();",
            "\treturn ret;",
            "}",
            "void smpboot_unregister_percpu_thread(struct smp_hotplug_thread *plug_thread)",
            "{",
            "\tcpus_read_lock();",
            "\tmutex_lock(&smpboot_threads_lock);",
            "\tlist_del(&plug_thread->list);",
            "\tsmpboot_destroy_threads(plug_thread);",
            "\tmutex_unlock(&smpboot_threads_lock);",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "smpboot_create_threads, smpboot_unpark_thread, smpboot_unpark_threads, smpboot_park_thread, smpboot_park_threads, smpboot_destroy_threads, smpboot_register_percpu_thread, smpboot_unregister_percpu_thread",
          "description": "提供SMP线程池的注册/注销接口，实现线程创建、唤醒、挂起和销毁操作，支持多CPU环境下的线程统一管理",
          "similarity": 0.49936985969543457
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/smpboot.c",
          "start_line": 1,
          "end_line": 38,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Common SMP CPU bringup/teardown functions",
            " */",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kthread.h>",
            "#include <linux/smpboot.h>",
            "",
            "#include \"smpboot.h\"",
            "",
            "#ifdef CONFIG_SMP",
            "",
            "#ifdef CONFIG_GENERIC_SMP_IDLE_THREAD",
            "/*",
            " * For the hotplug case we keep the task structs around and reuse",
            " * them.",
            " */",
            "static DEFINE_PER_CPU(struct task_struct *, idle_threads);",
            "",
            "struct task_struct *idle_thread_get(unsigned int cpu)",
            "{",
            "\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);",
            "",
            "\tif (!tsk)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "\treturn tsk;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义SMP空闲线程相关结构和辅助函数，提供跨CPU的空闲线程获取接口，支持热插拔场景下任务结构复用",
          "similarity": 0.43855035305023193
        }
      ]
    }
  ]
}