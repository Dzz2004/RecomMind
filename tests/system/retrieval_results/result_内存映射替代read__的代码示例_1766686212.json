{
  "query": "内存映射替代read()的代码示例",
  "timestamp": "2025-12-26 02:10:12",
  "retrieved_files": [
    {
      "source_file": "kernel/iomem.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:45:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `iomem.c`\n\n---\n\n# iomem.c 技术文档\n\n## 1. 文件概述\n\n`iomem.c` 实现了通用的内存重映射（`memremap`）接口，用于将物理地址空间（特别是 I/O 内存资源）映射为可直接访问的内核虚拟地址。与传统的 `ioremap` 不同，`memremap` 专为**无 I/O 副作用**的内存区域设计（如持久内存 PMEM、设备内存等），并支持多种缓存策略（如写回 WB、写通 WT、写合并 WC）。该文件还提供了资源管理版本（`devm_memremap`），可自动在设备卸载时释放映射。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`memremap()`**  \n  核心映射函数，根据指定的缓存策略（`MEMREMAP_WB`/`WT`/`WC`）将物理地址映射为内核虚拟地址。若映射区域为系统 RAM 且请求 `MEMREMAP_WB`，则直接返回线性映射地址。\n\n- **`memunmap()`**  \n  释放由 `memremap()` 创建的映射。若地址来自 `ioremap` 系列函数，则调用 `iounmap()`；若为直接映射地址则无需操作。\n\n- **`devm_memremap()`**  \n  设备资源管理版本的 `memremap()`，将映射资源与设备生命周期绑定，设备卸载时自动释放。\n\n- **`devm_memunmap()`**  \n  显式释放由 `devm_memremap()` 分配的资源（通常无需手动调用）。\n\n### 辅助函数\n\n- **`try_ram_remap()`**  \n  尝试对系统 RAM 区域使用内核直接映射（`__va()`），避免创建新页表。\n\n- **`arch_memremap_wb()`**（弱符号）  \n  架构特定的写回（WB）映射实现，默认回退到 `ioremap_cache()` 或 `ioremap()`。\n\n- **`arch_memremap_can_ram_remap()`**（弱符号）  \n  架构特定的 RAM 重映射能力检查，默认返回 `true`。\n\n### 标志位（Flags）\n\n- `MEMREMAP_WB`：写回缓存（默认系统 RAM 策略）\n- `MEMREMAP_WT`：写通缓存（禁止用于系统 RAM）\n- `MEMREMAP_WC`：写合并（禁止用于系统 RAM）\n- `MEMREMAP_ENC`/`DEC`：加密/解密映射（代码中未直接处理，由底层 `ioremap` 实现）\n\n## 3. 关键实现\n\n### 内存区域类型检测\n- 使用 `region_intersects()` 检查物理地址范围是否与 `IORESOURCE_SYSTEM_RAM` 重叠，返回：\n  - `REGION_INTERSECTS`：完全或部分在系统 RAM 内\n  - `REGION_MIXED`：跨越 RAM 与非 RAM 区域（视为错误）\n  - `REGION_DISJOINT`：完全在非 RAM 区域\n\n### RAM 直接映射优化\n- 当请求 `MEMREMAP_WB` 且区域为系统 RAM 时：\n  1. 调用 `try_ram_remap()` 检查是否满足直接映射条件：\n     - 物理页帧有效（`pfn_valid()`）\n     - 非高端内存（`!PageHighMem()`）\n     - 架构允许 RAM 重映射（`arch_memremap_can_ram_remap()`）\n  2. 若满足，直接返回 `__va(offset)`（内核线性映射地址），避免页表开销。\n\n### 非 RAM 区域映射\n- 对于非 RAM 区域或非 WB 请求：\n  - `MEMREMAP_WT` → `ioremap_wt()`\n  - `MEMREMAP_WC` → `ioremap_wc()`\n  - `MEMREMAP_WB` → `arch_memremap_wb()`（最终调用 `ioremap_cache()` 或 `ioremap()`）\n\n### 安全限制\n- 禁止对系统 RAM 使用 `WT`/`WC` 映射（会触发 `WARN_ONCE` 并返回 `NULL`）\n- 禁止映射混合 RAM/非 RAM 区域（视为编程错误）\n\n### 资源管理\n- `devm_memremap()` 使用设备资源管理框架（`devres`）：\n  - 分配资源描述符（`devres_alloc_node`）\n  - 注册释放回调（`devm_memremap_release`）\n  - 设备卸载时自动调用 `memunmap()`\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/io.h>`：提供 `ioremap_*()` 系列函数\n  - `<linux/mm.h>`：提供 `pfn_valid()`、`PageHighMem()` 等内存管理接口\n  - `<linux/ioremap.h>`：定义 `ioremap` 相关类型和函数\n  - `<linux/device.h>`：提供设备资源管理（`devres`）接口\n\n- **架构依赖**：\n  - 依赖架构实现的 `ioremap_cache()`、`ioremap_wt()`、`ioremap_wc()`\n  - 可选覆盖 `arch_memremap_wb()` 和 `arch_memremap_can_ram_remap()`\n\n- **内核子系统**：\n  - 内存管理子系统（MM）：页表管理、直接映射\n  - 设备驱动模型：设备资源生命周期管理\n\n## 5. 使用场景\n\n- **持久内存（PMEM）驱动**：  \n  将持久内存设备的物理地址映射为可直接读写的内核虚拟地址（通常使用 `MEMREMAP_WB`）。\n\n- **设备内存（Device Memory）访问**：  \n  访问无 I/O 副作用的设备内存区域（如 GPU 显存、FPGA 内存），根据性能需求选择缓存策略。\n\n- **EFI 运行时服务内存**：  \n  映射 EFI 固件提供的内存区域（需确保无副作用）。\n\n- **设备驱动资源管理**：  \n  使用 `devm_memremap()` 简化驱动代码，避免手动释放映射（尤其适用于 probe/remove 场景）。\n\n- **内核子系统通用映射**：  \n  为需要高性能内存访问的子系统（如 DAX、HMM）提供统一映射接口。",
      "similarity": 0.5882923603057861,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/iomem.c",
          "start_line": 20,
          "end_line": 42,
          "content": [
            "static bool arch_memremap_can_ram_remap(resource_size_t offset, size_t size,",
            "\t\t\t\t\tunsigned long flags)",
            "{",
            "\treturn true;",
            "}",
            "void memunmap(void *addr)",
            "{",
            "\tif (is_ioremap_addr(addr))",
            "\t\tiounmap((void __iomem *) addr);",
            "}",
            "static void devm_memremap_release(struct device *dev, void *res)",
            "{",
            "\tmemunmap(*(void **)res);",
            "}",
            "static int devm_memremap_match(struct device *dev, void *res, void *match_data)",
            "{",
            "\treturn *(void **)res == match_data;",
            "}",
            "void devm_memunmap(struct device *dev, void *addr)",
            "{",
            "\tWARN_ON(devres_release(dev, devm_memremap_release,",
            "\t\t\t\tdevm_memremap_match, addr));",
            "}"
          ],
          "function_name": "arch_memremap_can_ram_remap, memunmap, devm_memremap_release, devm_memremap_match, devm_memunmap",
          "description": "实现内存映射释放相关函数，包含判断能否进行RAM重映射的钩子函数、解除ioremap地址映射的memunmap函数，以及设备资源管理中的动态内存映射释放匹配逻辑",
          "similarity": 0.5887442827224731
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/iomem.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "/* SPDX-License-Identifier: GPL-2.0 */",
            "#include <linux/device.h>",
            "#include <linux/types.h>",
            "#include <linux/io.h>",
            "#include <linux/mm.h>",
            "#include <linux/ioremap.h>",
            "",
            "#ifndef arch_memremap_wb",
            "static void *arch_memremap_wb(resource_size_t offset, unsigned long size)",
            "{",
            "#ifdef ioremap_cache",
            "\treturn (__force void *)ioremap_cache(offset, size);",
            "#else",
            "\treturn (__force void *)ioremap(offset, size);",
            "#endif",
            "}",
            "#endif",
            "",
            "#ifndef arch_memremap_can_ram_remap"
          ],
          "function_name": null,
          "description": "定义arch_memremap_wb函数，根据ioremap_cache是否存在选择使用ioremap_cache或ioremap实现，用于创建带写回缓存策略的内存映射区域，上下文不完整",
          "similarity": 0.55340576171875
        }
      ]
    },
    {
      "source_file": "mm/memremap.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:45:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memremap.c`\n\n---\n\n# memremap.c 技术文档\n\n## 1. 文件概述\n\n`memremap.c` 是 Linux 内核中用于管理设备持久内存（Persistent Memory）映射的核心实现文件。它提供了将物理设备内存（如 NVDIMM、CXL 等）映射到内核虚拟地址空间并将其纳入内存管理子系统（特别是 ZONE_DEVICE）的机制。该文件主要实现了 `memremap_pages()` 和 `memunmap_pages()` 接口，用于注册和注销设备页映射（`dev_pagemap`），支持多种设备内存类型（如 FS_DAX、PRIVATE、COHERENT 等），并确保与内存热插拔、KASAN、NUMA 等子系统的正确集成。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct dev_pagemap`**：描述设备内存区域的元数据结构，包含内存范围、类型、引用计数、完成量等。\n- **`pgmap_array`**：全局 XArray 结构，用于按 PFN 范围快速查找对应的 `dev_pagemap` 实例。\n\n### 主要函数\n- **`memremap_compat_align()`**：返回设备内存映射的最小兼容对齐粒度（默认为 `SUBSECTION_SIZE`），确保在不同映射模式间切换时满足架构约束。\n- **`pgmap_pfn_valid()`**：判断给定 PFN 是否属于指定 `dev_pagemap` 的有效范围。\n- **`memunmap_pages()`**：释放通过 `memremap_pages()` 映射的设备内存区域，包括从内存管理子系统移除、清理 KASAN 影子内存、更新 XArray 等。\n- **`pagemap_range()`**：内部辅助函数，负责将单个内存范围添加到内核内存管理中（调用 `arch_add_memory()` 或 `add_pages()`）。\n- **`devm_memremap_pages_release()`**：资源管理释放回调，用于自动清理通过 `devm_` 接口分配的映射。\n- **`dev_pagemap_percpu_release()`**：percpu 引用计数释放回调，用于同步等待所有用户完成后再执行实际卸载。\n\n### 静态键（Static Keys）\n- **`devmap_managed_key`**：仅在 `CONFIG_FS_DAX` 启用时定义，用于优化 FS_DAX 设备内存路径的运行时分支预测。\n\n## 3. 关键实现\n\n### 设备内存映射流程 (`pagemap_range`)\n1. **冲突检测**：通过 `get_dev_pagemap()` 检查目标 PFN 范围是否已存在映射，避免重叠。\n2. **RAM 区域检查**：使用 `region_intersects()` 确保映射区域不与系统 RAM 重叠。\n3. **XArray 注册**：将 `dev_pagemap` 指针存入全局 `pgmap_array`，以 PFN 为键。\n4. **PFN 跟踪**：调用 `track_pfn_remap()` 建立页表映射。\n5. **内存热插拔**：\n   - 对于 `MEMORY_DEVICE_PRIVATE` 类型，调用 `add_pages()` 仅初始化 `struct page`，不建立线性映射。\n   - 对于其他类型（如 FS_DAX），调用 `kasan_add_zero_shadow()` 添加 KASAN 影子内存，再调用 `arch_add_memory()` 建立完整线性映射。\n6. **ZONE_DEVICE 集成**：调用 `move_pfn_range_to_zone()` 将 PFN 范围移动到 `ZONE_DEVICE`。\n7. **延迟初始化**：调用 `memmap_init_zone_device()` 初始化 `struct page` 的设备特定字段。\n8. **引用计数**：对非 PRIVATE/COHERENT 类型，增加 percpu 引用计数。\n\n### 设备内存卸载流程 (`memunmap_pages`)\n1. **引用计数终止**：调用 `percpu_ref_kill()` 标记引用不可再增加。\n2. **引用释放**：对非 PRIVATE/COHERENT 类型，批量减少 percpu 引用。\n3. **同步等待**：通过 `wait_for_completion()` 等待所有现有引用释放完毕。\n4. **逐范围卸载**：对每个范围调用 `pageunmap_range()`：\n   - 从对应 zone 移除 PFN 范围。\n   - 调用 `__remove_pages()`（PRIVATE）或 `arch_remove_memory()` + `kasan_remove_zero_shadow()`（其他类型）。\n   - 调用 `untrack_pfn()` 清理页表跟踪。\n   - 从 `pgmap_array` 中删除映射。\n5. **清理引用**：调用 `percpu_ref_exit()` 销毁 percpu 引用。\n6. **静态键更新**：若为 FS_DAX 类型，减少 `devmap_managed_key` 计数。\n\n### PFN 范围处理\n- **起始 PFN**：`pfn_first()` 考虑 `vmem_altmap` 的偏移（用于预留 struct page 存储空间）。\n- **结束 PFN**：`pfn_end()` 基于物理范围计算。\n- **有效长度**：`pfn_len()` 计算实际可使用的页数，并考虑 `vmemmap_shift`（用于大页优化）。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `memory_hotplug.h`、`mmzone.h`、`swap.h` 等，与 `ZONE_DEVICE`、内存热插拔机制紧密集成。\n- **体系结构相关代码**：调用 `arch_add_memory()`、`arch_remove_memory()`，依赖各架构的具体实现。\n- **KASAN**：通过 `kasan_add/remove_zero_shadow()` 管理影子内存。\n- **DAX 子系统**：当 `CONFIG_FS_DAX` 启用时，与 DAX 设备管理交互，使用 `devmap_managed_key` 优化路径。\n- **XArray**：使用 XArray 数据结构高效管理 PFN 到 `dev_pagemap` 的映射。\n- **Per-CPU 引用计数**：使用 `percpu_ref` 机制安全地管理设备内存的生命周期。\n- **内部头文件**：包含 `\"internal.h\"`，访问内核内存管理内部接口。\n\n## 5. 使用场景\n\n- **持久内存 (PMEM) 设备驱动**：如 `libnvdimm` 子系统中的 `nd_pmem` 驱动，使用 `memremap_pages()` 将 NVDIMM 映射为可直接访问的内存。\n- **CXL 内存设备**：CXL.mem 设备通过此接口将设备附加内存纳入内核管理。\n- **DAX 文件系统**：当挂载支持 DAX 的文件系统（如 ext4、xfs）到 PMEM 设备时，底层使用此机制建立直接映射。\n- **GPU/CXL 设备私有内存**：`MEMORY_DEVICE_PRIVATE` 类型用于管理 CPU 不可直接访问但可通过特殊指令（如迁移 API）操作的设备内存。\n- **异构内存管理**：作为统一内存架构（UMA/NUMA 扩展）的一部分，将设备内存作为特殊内存节点纳入调度和分配策略。",
      "similarity": 0.5665205121040344,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/memremap.c",
          "start_line": 34,
          "end_line": 137,
          "content": [
            "unsigned long memremap_compat_align(void)",
            "{",
            "\treturn SUBSECTION_SIZE;",
            "}",
            "static void devmap_managed_enable_put(struct dev_pagemap *pgmap)",
            "{",
            "\tif (pgmap->type == MEMORY_DEVICE_FS_DAX)",
            "\t\tstatic_branch_dec(&devmap_managed_key);",
            "}",
            "static void devmap_managed_enable_get(struct dev_pagemap *pgmap)",
            "{",
            "\tif (pgmap->type == MEMORY_DEVICE_FS_DAX)",
            "\t\tstatic_branch_inc(&devmap_managed_key);",
            "}",
            "static void devmap_managed_enable_get(struct dev_pagemap *pgmap)",
            "{",
            "}",
            "static void devmap_managed_enable_put(struct dev_pagemap *pgmap)",
            "{",
            "}",
            "static void pgmap_array_delete(struct range *range)",
            "{",
            "\txa_store_range(&pgmap_array, PHYS_PFN(range->start), PHYS_PFN(range->end),",
            "\t\t\tNULL, GFP_KERNEL);",
            "\tsynchronize_rcu();",
            "}",
            "static unsigned long pfn_first(struct dev_pagemap *pgmap, int range_id)",
            "{",
            "\tstruct range *range = &pgmap->ranges[range_id];",
            "\tunsigned long pfn = PHYS_PFN(range->start);",
            "",
            "\tif (range_id)",
            "\t\treturn pfn;",
            "\treturn pfn + vmem_altmap_offset(pgmap_altmap(pgmap));",
            "}",
            "bool pgmap_pfn_valid(struct dev_pagemap *pgmap, unsigned long pfn)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < pgmap->nr_range; i++) {",
            "\t\tstruct range *range = &pgmap->ranges[i];",
            "",
            "\t\tif (pfn >= PHYS_PFN(range->start) &&",
            "\t\t    pfn <= PHYS_PFN(range->end))",
            "\t\t\treturn pfn >= pfn_first(pgmap, i);",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static unsigned long pfn_end(struct dev_pagemap *pgmap, int range_id)",
            "{",
            "\tconst struct range *range = &pgmap->ranges[range_id];",
            "",
            "\treturn (range->start + range_len(range)) >> PAGE_SHIFT;",
            "}",
            "static unsigned long pfn_len(struct dev_pagemap *pgmap, unsigned long range_id)",
            "{",
            "\treturn (pfn_end(pgmap, range_id) -",
            "\t\tpfn_first(pgmap, range_id)) >> pgmap->vmemmap_shift;",
            "}",
            "static void pageunmap_range(struct dev_pagemap *pgmap, int range_id)",
            "{",
            "\tstruct range *range = &pgmap->ranges[range_id];",
            "\tstruct page *first_page;",
            "",
            "\t/* make sure to access a memmap that was actually initialized */",
            "\tfirst_page = pfn_to_page(pfn_first(pgmap, range_id));",
            "",
            "\t/* pages are dead and unused, undo the arch mapping */",
            "\tmem_hotplug_begin();",
            "\tremove_pfn_range_from_zone(page_zone(first_page), PHYS_PFN(range->start),",
            "\t\t\t\t   PHYS_PFN(range_len(range)));",
            "\tif (pgmap->type == MEMORY_DEVICE_PRIVATE) {",
            "\t\t__remove_pages(PHYS_PFN(range->start),",
            "\t\t\t       PHYS_PFN(range_len(range)), NULL);",
            "\t} else {",
            "\t\tarch_remove_memory(range->start, range_len(range),",
            "\t\t\t\tpgmap_altmap(pgmap));",
            "\t\tkasan_remove_zero_shadow(__va(range->start), range_len(range));",
            "\t}",
            "\tmem_hotplug_done();",
            "",
            "\tuntrack_pfn(NULL, PHYS_PFN(range->start), range_len(range), true);",
            "\tpgmap_array_delete(range);",
            "}",
            "void memunmap_pages(struct dev_pagemap *pgmap)",
            "{",
            "\tint i;",
            "",
            "\tpercpu_ref_kill(&pgmap->ref);",
            "\tif (pgmap->type != MEMORY_DEVICE_PRIVATE &&",
            "\t    pgmap->type != MEMORY_DEVICE_COHERENT)",
            "\t\tfor (i = 0; i < pgmap->nr_range; i++)",
            "\t\t\tpercpu_ref_put_many(&pgmap->ref, pfn_len(pgmap, i));",
            "",
            "\twait_for_completion(&pgmap->done);",
            "",
            "\tfor (i = 0; i < pgmap->nr_range; i++)",
            "\t\tpageunmap_range(pgmap, i);",
            "\tpercpu_ref_exit(&pgmap->ref);",
            "",
            "\tWARN_ONCE(pgmap->altmap.alloc, \"failed to free all reserved pages\\n\");",
            "\tdevmap_managed_enable_put(pgmap);",
            "}"
          ],
          "function_name": "memremap_compat_align, devmap_managed_enable_put, devmap_managed_enable_get, devmap_managed_enable_get, devmap_managed_enable_put, pgmap_array_delete, pfn_first, pgmap_pfn_valid, pfn_end, pfn_len, pageunmap_range, memunmap_pages",
          "description": "实现设备内存映射管理函数，包含兼容对齐返回、引用计数增减、PFN范围操作及内存解映射逻辑，通过xa操作维护pgmap_array并处理内存热插拔相关状态",
          "similarity": 0.5939528346061707
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memremap.c",
          "start_line": 419,
          "end_line": 499,
          "content": [
            "void devm_memunmap_pages(struct device *dev, struct dev_pagemap *pgmap)",
            "{",
            "\tdevm_release_action(dev, devm_memremap_pages_release, pgmap);",
            "}",
            "unsigned long vmem_altmap_offset(struct vmem_altmap *altmap)",
            "{",
            "\t/* number of pfns from base where pfn_to_page() is valid */",
            "\tif (altmap)",
            "\t\treturn altmap->reserve + altmap->free;",
            "\treturn 0;",
            "}",
            "void vmem_altmap_free(struct vmem_altmap *altmap, unsigned long nr_pfns)",
            "{",
            "\taltmap->alloc -= nr_pfns;",
            "}",
            "void free_zone_device_folio(struct folio *folio)",
            "{",
            "\tif (WARN_ON_ONCE(!folio->page.pgmap->ops ||",
            "\t\t\t!folio->page.pgmap->ops->page_free))",
            "\t\treturn;",
            "",
            "\tmem_cgroup_uncharge(folio);",
            "",
            "\t/*",
            "\t * Note: we don't expect anonymous compound pages yet. Once supported",
            "\t * and we could PTE-map them similar to THP, we'd have to clear",
            "\t * PG_anon_exclusive on all tail pages.",
            "\t */",
            "\tif (folio_test_anon(folio)) {",
            "\t\tVM_BUG_ON_FOLIO(folio_test_large(folio), folio);",
            "\t\t__ClearPageAnonExclusive(folio_page(folio, 0));",
            "\t}",
            "",
            "\t/*",
            "\t * When a device managed page is freed, the folio->mapping field",
            "\t * may still contain a (stale) mapping value. For example, the",
            "\t * lower bits of folio->mapping may still identify the folio as an",
            "\t * anonymous folio. Ultimately, this entire field is just stale",
            "\t * and wrong, and it will cause errors if not cleared.",
            "\t *",
            "\t * For other types of ZONE_DEVICE pages, migration is either",
            "\t * handled differently or not done at all, so there is no need",
            "\t * to clear folio->mapping.",
            "\t */",
            "\tfolio->mapping = NULL;",
            "\tfolio->page.pgmap->ops->page_free(folio_page(folio, 0));",
            "",
            "\tif (folio->page.pgmap->type != MEMORY_DEVICE_PRIVATE &&",
            "\t    folio->page.pgmap->type != MEMORY_DEVICE_COHERENT)",
            "\t\t/*",
            "\t\t * Reset the refcount to 1 to prepare for handing out the page",
            "\t\t * again.",
            "\t\t */",
            "\t\tfolio_set_count(folio, 1);",
            "\telse",
            "\t\tput_dev_pagemap(folio->page.pgmap);",
            "}",
            "void zone_device_page_init(struct page *page)",
            "{",
            "\t/*",
            "\t * Drivers shouldn't be allocating pages after calling",
            "\t * memunmap_pages().",
            "\t */",
            "\tWARN_ON_ONCE(!percpu_ref_tryget_live(&page->pgmap->ref));",
            "\tset_page_count(page, 1);",
            "\tlock_page(page);",
            "}",
            "bool __put_devmap_managed_folio_refs(struct folio *folio, int refs)",
            "{",
            "\tif (folio->page.pgmap->type != MEMORY_DEVICE_FS_DAX)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * fsdax page refcounts are 1-based, rather than 0-based: if",
            "\t * refcount is 1, then the page is free and the refcount is",
            "\t * stable because nobody holds a reference on the page.",
            "\t */",
            "\tif (folio_ref_sub_return(folio, refs) == 1)",
            "\t\twake_up_var(&folio->_refcount);",
            "\treturn true;",
            "}"
          ],
          "function_name": "devm_memunmap_pages, vmem_altmap_offset, vmem_altmap_free, free_zone_device_folio, zone_device_page_init, __put_devmap_managed_folio_refs",
          "description": "实现设备内存释放链路，包含虚拟映射偏移计算、ZONEdevice页帧回收、映射信息清理及引用计数管理，针对不同类型设备内存执行差异化释放策略",
          "similarity": 0.5458732843399048
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memremap.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright(c) 2015 Intel Corporation. All rights reserved. */",
            "#include <linux/device.h>",
            "#include <linux/io.h>",
            "#include <linux/kasan.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/swapops.h>",
            "#include <linux/types.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/xarray.h>",
            "#include \"internal.h\"",
            "",
            "static DEFINE_XARRAY(pgmap_array);",
            "",
            "/*",
            " * The memremap() and memremap_pages() interfaces are alternately used",
            " * to map persistent memory namespaces. These interfaces place different",
            " * constraints on the alignment and size of the mapping (namespace).",
            " * memremap() can map individual PAGE_SIZE pages. memremap_pages() can",
            " * only map subsections (2MB), and at least one architecture (PowerPC)",
            " * the minimum mapping granularity of memremap_pages() is 16MB.",
            " *",
            " * The role of memremap_compat_align() is to communicate the minimum",
            " * arch supported alignment of a namespace such that it can freely",
            " * switch modes without violating the arch constraint. Namely, do not",
            " * allow a namespace to be PAGE_SIZE aligned since that namespace may be",
            " * reconfigured into a mode that requires SUBSECTION_SIZE alignment.",
            " */",
            "#ifndef CONFIG_ARCH_HAS_MEMREMAP_COMPAT_ALIGN"
          ],
          "function_name": null,
          "description": "定义pgmap_array XArray用于存储设备内存映射范围，注释说明memremap接口的兼容性对齐约束及架构限制，因条件编译未完全展开导致上下文不完整",
          "similarity": 0.5188705921173096
        },
        {
          "chunk_id": 2,
          "file_path": "mm/memremap.c",
          "start_line": 157,
          "end_line": 281,
          "content": [
            "static void devm_memremap_pages_release(void *data)",
            "{",
            "\tmemunmap_pages(data);",
            "}",
            "static void dev_pagemap_percpu_release(struct percpu_ref *ref)",
            "{",
            "\tstruct dev_pagemap *pgmap = container_of(ref, struct dev_pagemap, ref);",
            "",
            "\tcomplete(&pgmap->done);",
            "}",
            "static int pagemap_range(struct dev_pagemap *pgmap, struct mhp_params *params,",
            "\t\tint range_id, int nid)",
            "{",
            "\tconst bool is_private = pgmap->type == MEMORY_DEVICE_PRIVATE;",
            "\tstruct range *range = &pgmap->ranges[range_id];",
            "\tstruct dev_pagemap *conflict_pgmap;",
            "\tint error, is_ram;",
            "",
            "\tif (WARN_ONCE(pgmap_altmap(pgmap) && range_id > 0,",
            "\t\t\t\t\"altmap not supported for multiple ranges\\n\"))",
            "\t\treturn -EINVAL;",
            "",
            "\tconflict_pgmap = get_dev_pagemap(PHYS_PFN(range->start), NULL);",
            "\tif (conflict_pgmap) {",
            "\t\tWARN(1, \"Conflicting mapping in same section\\n\");",
            "\t\tput_dev_pagemap(conflict_pgmap);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tconflict_pgmap = get_dev_pagemap(PHYS_PFN(range->end), NULL);",
            "\tif (conflict_pgmap) {",
            "\t\tWARN(1, \"Conflicting mapping in same section\\n\");",
            "\t\tput_dev_pagemap(conflict_pgmap);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tis_ram = region_intersects(range->start, range_len(range),",
            "\t\tIORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);",
            "",
            "\tif (is_ram != REGION_DISJOINT) {",
            "\t\tWARN_ONCE(1, \"attempted on %s region %#llx-%#llx\\n\",",
            "\t\t\t\tis_ram == REGION_MIXED ? \"mixed\" : \"ram\",",
            "\t\t\t\trange->start, range->end);",
            "\t\treturn -ENXIO;",
            "\t}",
            "",
            "\terror = xa_err(xa_store_range(&pgmap_array, PHYS_PFN(range->start),",
            "\t\t\t\tPHYS_PFN(range->end), pgmap, GFP_KERNEL));",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\tif (nid < 0)",
            "\t\tnid = numa_mem_id();",
            "",
            "\terror = track_pfn_remap(NULL, &params->pgprot, PHYS_PFN(range->start), 0,",
            "\t\t\trange_len(range));",
            "\tif (error)",
            "\t\tgoto err_pfn_remap;",
            "",
            "\tif (!mhp_range_allowed(range->start, range_len(range), !is_private)) {",
            "\t\terror = -EINVAL;",
            "\t\tgoto err_kasan;",
            "\t}",
            "",
            "\tmem_hotplug_begin();",
            "",
            "\t/*",
            "\t * For device private memory we call add_pages() as we only need to",
            "\t * allocate and initialize struct page for the device memory. More-",
            "\t * over the device memory is un-accessible thus we do not want to",
            "\t * create a linear mapping for the memory like arch_add_memory()",
            "\t * would do.",
            "\t *",
            "\t * For all other device memory types, which are accessible by",
            "\t * the CPU, we do want the linear mapping and thus use",
            "\t * arch_add_memory().",
            "\t */",
            "\tif (is_private) {",
            "\t\terror = add_pages(nid, PHYS_PFN(range->start),",
            "\t\t\t\tPHYS_PFN(range_len(range)), params);",
            "\t} else {",
            "\t\terror = kasan_add_zero_shadow(__va(range->start), range_len(range));",
            "\t\tif (error) {",
            "\t\t\tmem_hotplug_done();",
            "\t\t\tgoto err_kasan;",
            "\t\t}",
            "",
            "\t\terror = arch_add_memory(nid, range->start, range_len(range),",
            "\t\t\t\t\tparams);",
            "\t}",
            "",
            "\tif (!error) {",
            "\t\tstruct zone *zone;",
            "",
            "\t\tzone = &NODE_DATA(nid)->node_zones[ZONE_DEVICE];",
            "\t\tmove_pfn_range_to_zone(zone, PHYS_PFN(range->start),",
            "\t\t\t\tPHYS_PFN(range_len(range)), params->altmap,",
            "\t\t\t\tMIGRATE_MOVABLE);",
            "\t}",
            "",
            "\tmem_hotplug_done();",
            "\tif (error)",
            "\t\tgoto err_add_memory;",
            "",
            "\t/*",
            "\t * Initialization of the pages has been deferred until now in order",
            "\t * to allow us to do the work while not holding the hotplug lock.",
            "\t */",
            "\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],",
            "\t\t\t\tPHYS_PFN(range->start),",
            "\t\t\t\tPHYS_PFN(range_len(range)), pgmap);",
            "\tif (pgmap->type != MEMORY_DEVICE_PRIVATE &&",
            "\t    pgmap->type != MEMORY_DEVICE_COHERENT)",
            "\t\tpercpu_ref_get_many(&pgmap->ref, pfn_len(pgmap, range_id));",
            "\treturn 0;",
            "",
            "err_add_memory:",
            "\tif (!is_private)",
            "\t\tkasan_remove_zero_shadow(__va(range->start), range_len(range));",
            "err_kasan:",
            "\tuntrack_pfn(NULL, PHYS_PFN(range->start), range_len(range), true);",
            "err_pfn_remap:",
            "\tpgmap_array_delete(range);",
            "\treturn error;",
            "}"
          ],
          "function_name": "devm_memremap_pages_release, dev_pagemap_percpu_release, pagemap_range",
          "description": "提供设备内存注册流程，检查地址冲突与内存类型有效性，通过track_pfn_remap追踪PFN范围，依据内存类型调用add_pages或arch_add_memory完成设备内存注册",
          "similarity": 0.49629294872283936
        }
      ]
    },
    {
      "source_file": "kernel/rcu/refscale.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:42:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\refscale.c`\n\n---\n\n# `rcu/refscale.c` 技术文档\n\n## 1. 文件概述\n\n`rcu/refscale.c` 是 Linux 内核中用于**可扩展性基准测试**的模块，旨在比较不同同步机制（如 RCU、SRCU、引用计数、读写信号量、读写自旋锁等）在高并发读取场景下获取对象引用的性能表现。该模块通过模拟大量并发读取操作，测量不同机制在吞吐量、延迟和可扩展性方面的差异，为 RCU 及其他同步原语的优化提供数据支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct ref_scale_ops`**  \n  定义不同同步机制的操作接口，包含初始化、清理、读取段执行和延迟段执行等函数指针。\n  ```c\n  struct ref_scale_ops {\n      bool (*init)(void);\n      void (*cleanup)(void);\n      void (*readsection)(const int nloops);\n      void (*delaysection)(const int nloops, const int udl, const int ndl);\n      const char *name;\n  };\n  ```\n\n- **`struct reader_task`**  \n  表示每个读者线程的状态，包括任务结构、启动标志、等待队列和上次执行耗时。\n  ```c\n  struct reader_task {\n      struct task_struct *task;\n      int start_reader;\n      wait_queue_head_t wq;\n      u64 last_duration_ns;\n  };\n  ```\n\n### 主要函数\n\n- **`ref_rcu_read_section()` / `ref_rcu_delay_section()`**  \n  执行指定次数的 RCU 读临界区操作，后者在临界区内插入延迟。\n\n- **`srcu_ref_scale_read_section()` / `srcu_ref_scale_delay_section()`**  \n  针对 SRCU 的读操作测试函数。\n\n- **`ref_refcnt_section()` / `ref_refcnt_delay_section()`**  \n  使用原子引用计数（`atomic_inc/dec`）模拟引用获取/释放。\n\n- **`ref_rwlock_section()` / `ref_rwlock_delay_section()`**  \n  使用读写自旋锁（`rwlock_t`）进行读操作测试。\n\n- **`un_delay()`**  \n  根据参数执行微秒（`udelay`）或纳秒（`ndelay`）级延迟。\n\n- **`rcu_sync_scale_init()`**  \n  空初始化函数，适用于无需特殊初始化的机制（如 RCU、SRCU）。\n\n## 3. 关键实现\n\n### 测试机制选择\n通过 `scale_type` 模块参数动态选择测试的同步机制，支持：\n- `rcu`：经典 RCU\n- `srcu`：Sleepable RCU\n- `rcu-tasks`：基于任务的 RCU（需 `CONFIG_TASKS_RCU`）\n- `rcu-trace`：跟踪 RCU（需 `CONFIG_TASKS_TRACE_RCU`）\n- `refcnt`：原子引用计数\n- `rwlock`：读写自旋锁（代码片段未完整显示，但已定义）\n\n### 并发控制\n- 使用 `atomic_t` 变量（如 `nreaders_exp`, `n_init`）协调读者线程的启动、预热和冷却阶段。\n- 通过等待队列（`main_wq`, `shutdown_wq`）实现主线程与读者/关机线程的同步。\n\n### 日志输出控制\n- `VERBOSE_SCALEOUT`：条件性输出调试信息。\n- `VERBOSE_SCALEOUT_BATCH`：批量输出日志，避免高频打印影响性能测试结果。\n- `SCALEOUT_ERRSTRING`：高亮错误信息。\n\n### 延迟模拟\n通过 `readdelay` 参数在读临界区内插入纳秒级延迟（`udelay`/`ndelay`），模拟真实场景中的读操作耗时。\n\n### 实验配置\n- `nreaders`：读者线程数（默认为 CPU 数的 75%）。\n- `loops`：每轮实验的循环次数。\n- `nruns`：实验重复次数。\n- `holdoff`：启动前等待多 CPU 环境就绪的延迟时间。\n\n## 4. 依赖关系\n\n- **RCU 子系统**：依赖 `rcupdate.h`、`rcupdate_trace.h` 提供 RCU 及变体（SRCU、Tasks RCU）的 API。\n- **内核基础组件**：\n  - 原子操作（`atomic.h`）\n  - 内核线程（`kthread.h`）\n  - 等待队列（`wait.h`）\n  - 自旋锁/读写锁（`spinlock.h`）\n  - 内存管理（`slab.h`）\n- **测试框架**：使用 `torture.h` 提供的参数解析和测试基础设施。\n- **条件编译**：根据内核配置（如 `CONFIG_TASKS_RCU`）动态包含特定 RCU 变体的测试代码。\n\n## 5. 使用场景\n\n- **RCU 性能调优**：在开发新 RCU 变体或优化现有实现时，量化其可扩展性优势。\n- **同步原语选型**：为内核开发者提供不同同步机制在高并发读场景下的性能对比数据。\n- **回归测试**：确保内核修改不会降低 RCU 或其他机制的可扩展性。\n- **学术研究**：作为操作系统课程或并发算法研究的基准测试工具。\n\n> **注**：该模块通常作为内核测试模块（`CONFIG_RCU_REF_SCALE_TEST`）编译，不用于生产环境。",
      "similarity": 0.5656415224075317,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 321,
          "end_line": 428,
          "content": [
            "static bool ref_rwlock_init(void)",
            "{",
            "\trwlock_init(&test_rwlock);",
            "\treturn true;",
            "}",
            "static void ref_rwlock_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tread_lock(&test_rwlock);",
            "\t\tread_unlock(&test_rwlock);",
            "\t}",
            "}",
            "static void ref_rwlock_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tread_lock(&test_rwlock);",
            "\t\tun_delay(udl, ndl);",
            "\t\tread_unlock(&test_rwlock);",
            "\t}",
            "}",
            "static bool ref_rwsem_init(void)",
            "{",
            "\tinit_rwsem(&test_rwsem);",
            "\treturn true;",
            "}",
            "static void ref_rwsem_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tdown_read(&test_rwsem);",
            "\t\tup_read(&test_rwsem);",
            "\t}",
            "}",
            "static void ref_rwsem_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tdown_read(&test_rwsem);",
            "\t\tun_delay(udl, ndl);",
            "\t\tup_read(&test_rwsem);",
            "\t}",
            "}",
            "static void ref_lock_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock(&test_lock);",
            "\t\traw_spin_unlock(&test_lock);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_lock_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock(&test_lock);",
            "\t\tun_delay(udl, ndl);",
            "\t\traw_spin_unlock(&test_lock);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_lock_irq_section(const int nloops)",
            "{",
            "\tunsigned long flags;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock_irqsave(&test_lock, flags);",
            "\t\traw_spin_unlock_irqrestore(&test_lock, flags);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_lock_irq_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tunsigned long flags;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock_irqsave(&test_lock, flags);",
            "\t\tun_delay(udl, ndl);",
            "\t\traw_spin_unlock_irqrestore(&test_lock, flags);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_acqrel_section(const int nloops)",
            "{",
            "\tunsigned long x;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));",
            "\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);",
            "\t}",
            "\tpreempt_enable();",
            "}"
          ],
          "function_name": "ref_rwlock_init, ref_rwlock_section, ref_rwlock_delay_section, ref_rwsem_init, ref_rwsem_section, ref_rwsem_delay_section, ref_lock_section, ref_lock_delay_section, ref_lock_irq_section, ref_lock_irq_delay_section, ref_acqrel_section",
          "description": "提供基于读写锁、读写信号量、自旋锁等同步原语的测试函数，展示不同锁机制在高并发场景下的行为特征。",
          "similarity": 0.5461517572402954
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 138,
          "end_line": 240,
          "content": [
            "static void un_delay(const int udl, const int ndl)",
            "{",
            "\tif (udl)",
            "\t\tudelay(udl);",
            "\tif (ndl)",
            "\t\tndelay(ndl);",
            "}",
            "static void ref_rcu_read_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock();",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static void ref_rcu_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock();",
            "\t\tun_delay(udl, ndl);",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static bool rcu_sync_scale_init(void)",
            "{",
            "\treturn true;",
            "}",
            "static void srcu_ref_scale_read_section(const int nloops)",
            "{",
            "\tint i;",
            "\tint idx;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tidx = srcu_read_lock(srcu_ctlp);",
            "\t\tsrcu_read_unlock(srcu_ctlp, idx);",
            "\t}",
            "}",
            "static void srcu_ref_scale_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "\tint idx;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tidx = srcu_read_lock(srcu_ctlp);",
            "\t\tun_delay(udl, ndl);",
            "\t\tsrcu_read_unlock(srcu_ctlp, idx);",
            "\t}",
            "}",
            "static void rcu_tasks_ref_scale_read_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tcontinue;",
            "}",
            "static void rcu_tasks_ref_scale_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tun_delay(udl, ndl);",
            "}",
            "static void rcu_trace_ref_scale_read_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock_trace();",
            "\t\trcu_read_unlock_trace();",
            "\t}",
            "}",
            "static void rcu_trace_ref_scale_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock_trace();",
            "\t\tun_delay(udl, ndl);",
            "\t\trcu_read_unlock_trace();",
            "\t}",
            "}",
            "static void ref_refcnt_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tatomic_inc(&refcnt);",
            "\t\tatomic_dec(&refcnt);",
            "\t}",
            "}",
            "static void ref_refcnt_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tatomic_inc(&refcnt);",
            "\t\tun_delay(udl, ndl);",
            "\t\tatomic_dec(&refcnt);",
            "\t}",
            "}"
          ],
          "function_name": "un_delay, ref_rcu_read_section, ref_rcu_delay_section, rcu_sync_scale_init, srcu_ref_scale_read_section, srcu_ref_scale_delay_section, rcu_tasks_ref_scale_read_section, rcu_tasks_ref_scale_delay_section, rcu_trace_ref_scale_read_section, rcu_trace_ref_scale_delay_section, ref_refcnt_section, ref_refcnt_delay_section",
          "description": "实现多种同步机制的读操作与延迟逻辑，通过RCU、SRCU、自旋锁、读写锁等机制进行并发访问测试，包含延迟注入和基础读操作循环。",
          "similarity": 0.5429522395133972
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 876,
          "end_line": 1013,
          "content": [
            "static void reset_readers(void)",
            "{",
            "\tint i;",
            "\tstruct reader_task *rt;",
            "",
            "\tfor (i = 0; i < nreaders; i++) {",
            "\t\trt = &(reader_tasks[i]);",
            "",
            "\t\trt->last_duration_ns = 0;",
            "\t}",
            "}",
            "static u64 process_durations(int n)",
            "{",
            "\tint i;",
            "\tstruct reader_task *rt;",
            "\tchar buf1[64];",
            "\tchar *buf;",
            "\tu64 sum = 0;",
            "",
            "\tbuf = kmalloc(800 + 64, GFP_KERNEL);",
            "\tif (!buf)",
            "\t\treturn 0;",
            "\tbuf[0] = 0;",
            "\tsprintf(buf, \"Experiment #%d (Format: <THREAD-NUM>:<Total loop time in ns>)\",",
            "\t\texp_idx);",
            "",
            "\tfor (i = 0; i < n && !torture_must_stop(); i++) {",
            "\t\trt = &(reader_tasks[i]);",
            "\t\tsprintf(buf1, \"%d: %llu\\t\", i, rt->last_duration_ns);",
            "",
            "\t\tif (i % 5 == 0)",
            "\t\t\tstrcat(buf, \"\\n\");",
            "\t\tif (strlen(buf) >= 800) {",
            "\t\t\tpr_alert(\"%s\", buf);",
            "\t\t\tbuf[0] = 0;",
            "\t\t}",
            "\t\tstrcat(buf, buf1);",
            "",
            "\t\tsum += rt->last_duration_ns;",
            "\t}",
            "\tpr_alert(\"%s\\n\", buf);",
            "",
            "\tkfree(buf);",
            "\treturn sum;",
            "}",
            "static int main_func(void *arg)",
            "{",
            "\tint exp, r;",
            "\tchar buf1[64];",
            "\tchar *buf;",
            "\tu64 *result_avg;",
            "",
            "\tset_cpus_allowed_ptr(current, cpumask_of(nreaders % nr_cpu_ids));",
            "\tset_user_nice(current, MAX_NICE);",
            "",
            "\tVERBOSE_SCALEOUT(\"main_func task started\");",
            "\tresult_avg = kzalloc(nruns * sizeof(*result_avg), GFP_KERNEL);",
            "\tbuf = kzalloc(800 + 64, GFP_KERNEL);",
            "\tif (!result_avg || !buf) {",
            "\t\tSCALEOUT_ERRSTRING(\"out of memory\");",
            "\t\tgoto oom_exit;",
            "\t}",
            "\tif (holdoff)",
            "\t\tschedule_timeout_interruptible(holdoff * HZ);",
            "",
            "\t// Wait for all threads to start.",
            "\tatomic_inc(&n_init);",
            "\twhile (atomic_read(&n_init) < nreaders + 1)",
            "\t\tschedule_timeout_uninterruptible(1);",
            "",
            "\t// Start exp readers up per experiment",
            "\tfor (exp = 0; exp < nruns && !torture_must_stop(); exp++) {",
            "\t\tif (torture_must_stop())",
            "\t\t\tgoto end;",
            "",
            "\t\treset_readers();",
            "\t\tatomic_set(&nreaders_exp, nreaders);",
            "\t\tatomic_set(&n_started, nreaders);",
            "\t\tatomic_set(&n_warmedup, nreaders);",
            "\t\tatomic_set(&n_cooleddown, nreaders);",
            "",
            "\t\texp_idx = exp;",
            "",
            "\t\tfor (r = 0; r < nreaders; r++) {",
            "\t\t\tsmp_store_release(&reader_tasks[r].start_reader, 1);",
            "\t\t\twake_up(&reader_tasks[r].wq);",
            "\t\t}",
            "",
            "\t\tVERBOSE_SCALEOUT(\"main_func: experiment started, waiting for %d readers\",",
            "\t\t\t\tnreaders);",
            "",
            "\t\twait_event(main_wq,",
            "\t\t\t   !atomic_read(&nreaders_exp) || torture_must_stop());",
            "",
            "\t\tVERBOSE_SCALEOUT(\"main_func: experiment ended\");",
            "",
            "\t\tif (torture_must_stop())",
            "\t\t\tgoto end;",
            "",
            "\t\tresult_avg[exp] = div_u64(1000 * process_durations(nreaders), nreaders * loops);",
            "\t}",
            "",
            "\t// Print the average of all experiments",
            "\tSCALEOUT(\"END OF TEST. Calculating average duration per loop (nanoseconds)...\\n\");",
            "",
            "\tpr_alert(\"Runs\\tTime(ns)\\n\");",
            "\tfor (exp = 0; exp < nruns; exp++) {",
            "\t\tu64 avg;",
            "\t\tu32 rem;",
            "",
            "\t\tavg = div_u64_rem(result_avg[exp], 1000, &rem);",
            "\t\tsprintf(buf1, \"%d\\t%llu.%03u\\n\", exp + 1, avg, rem);",
            "\t\tstrcat(buf, buf1);",
            "\t\tif (strlen(buf) >= 800) {",
            "\t\t\tpr_alert(\"%s\", buf);",
            "\t\t\tbuf[0] = 0;",
            "\t\t}",
            "\t}",
            "",
            "\tpr_alert(\"%s\", buf);",
            "",
            "oom_exit:",
            "\t// This will shutdown everything including us.",
            "\tif (shutdown) {",
            "\t\tshutdown_start = 1;",
            "\t\twake_up(&shutdown_wq);",
            "\t}",
            "",
            "\t// Wait for torture to stop us",
            "\twhile (!torture_must_stop())",
            "\t\tschedule_timeout_uninterruptible(1);",
            "",
            "end:",
            "\ttorture_kthread_stopping(\"main_func\");",
            "\tkfree(result_avg);",
            "\tkfree(buf);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "reset_readers, process_durations, main_func",
          "description": "reset_readers 函数重置所有读者任务的 last_duration_ns 字段以准备新实验",
          "similarity": 0.5128479599952698
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 477,
          "end_line": 607,
          "content": [
            "static void ref_acqrel_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tunsigned long x;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));",
            "\t\tun_delay(udl, ndl);",
            "\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_clock_section(const int nloops)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tx += ktime_get_real_fast_ns();",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static void ref_clock_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx += ktime_get_real_fast_ns();",
            "\t\tun_delay(udl, ndl);",
            "\t}",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static void ref_jiffies_section(const int nloops)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tx += jiffies;",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static void ref_jiffies_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx += jiffies;",
            "\t\tun_delay(udl, ndl);",
            "\t}",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static bool typesafe_ref_acquire(struct refscale_typesafe *rtsp, unsigned int *start)",
            "{",
            "\treturn atomic_inc_not_zero(&rtsp->rts_refctr);",
            "}",
            "static bool typesafe_ref_release(struct refscale_typesafe *rtsp, unsigned int start)",
            "{",
            "\tif (!atomic_dec_return(&rtsp->rts_refctr)) {",
            "\t\tWRITE_ONCE(rtsp->a, rtsp->a + 1);",
            "\t\tkmem_cache_free(typesafe_kmem_cachep, rtsp);",
            "\t}",
            "\treturn true;",
            "}",
            "static bool typesafe_lock_acquire(struct refscale_typesafe *rtsp, unsigned int *start)",
            "{",
            "\tspin_lock(&rtsp->rts_lock);",
            "\treturn true;",
            "}",
            "static bool typesafe_lock_release(struct refscale_typesafe *rtsp, unsigned int start)",
            "{",
            "\tspin_unlock(&rtsp->rts_lock);",
            "\treturn true;",
            "}",
            "static bool typesafe_seqlock_acquire(struct refscale_typesafe *rtsp, unsigned int *start)",
            "{",
            "\t*start = read_seqbegin(&rtsp->rts_seqlock);",
            "\treturn true;",
            "}",
            "static bool typesafe_seqlock_release(struct refscale_typesafe *rtsp, unsigned int start)",
            "{",
            "\treturn !read_seqretry(&rtsp->rts_seqlock, start);",
            "}",
            "static void typesafe_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tunsigned int a;",
            "\tunsigned int b;",
            "\tint i;",
            "\tlong idx;",
            "\tstruct refscale_typesafe *rtsp;",
            "\tunsigned int start;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tpreempt_disable();",
            "\t\tidx = torture_random(this_cpu_ptr(&refscale_rand)) % rtsarray_size;",
            "\t\tpreempt_enable();",
            "retry:",
            "\t\trcu_read_lock();",
            "\t\trtsp = rcu_dereference(rtsarray[idx]);",
            "\t\ta = READ_ONCE(rtsp->a);",
            "\t\tif (!rts_acquire(rtsp, &start)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\tif (a != READ_ONCE(rtsp->a)) {",
            "\t\t\t(void)rts_release(rtsp, start);",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\tun_delay(udl, ndl);",
            "\t\t// Remember, seqlock read-side release can fail.",
            "\t\tif (!rts_release(rtsp, start)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\tb = READ_ONCE(rtsp->a);",
            "\t\tWARN_ONCE(a != b, \"Re-read of ->a changed from %u to %u.\\n\", a, b);",
            "\t\tb = rtsp->b;",
            "\t\trcu_read_unlock();",
            "\t\tWARN_ON_ONCE(a * a != b);",
            "\t}",
            "}"
          ],
          "function_name": "ref_acqrel_delay_section, ref_clock_section, ref_clock_delay_section, ref_jiffies_section, ref_jiffies_delay_section, typesafe_ref_acquire, typesafe_ref_release, typesafe_lock_acquire, typesafe_lock_release, typesafe_seqlock_acquire, typesafe_seqlock_release, typesafe_delay_section",
          "description": "实现原子操作、时钟读取、Jiffies计数及类型安全引用的获取/释放逻辑，包含序列化锁和SeqLock的读操作验证流程。",
          "similarity": 0.5126027464866638
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 1024,
          "end_line": 1162,
          "content": [
            "static void",
            "ref_scale_print_module_parms(struct ref_scale_ops *cur_ops, const char *tag)",
            "{",
            "\tpr_alert(\"%s\" SCALE_FLAG",
            "\t\t \"--- %s:  verbose=%d shutdown=%d holdoff=%d loops=%ld nreaders=%d nruns=%d readdelay=%d\\n\", scale_type, tag,",
            "\t\t verbose, shutdown, holdoff, loops, nreaders, nruns, readdelay);",
            "}",
            "static void",
            "ref_scale_cleanup(void)",
            "{",
            "\tint i;",
            "",
            "\tif (torture_cleanup_begin())",
            "\t\treturn;",
            "",
            "\tif (!cur_ops) {",
            "\t\ttorture_cleanup_end();",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (reader_tasks) {",
            "\t\tfor (i = 0; i < nreaders; i++)",
            "\t\t\ttorture_stop_kthread(\"ref_scale_reader\",",
            "\t\t\t\t\t     reader_tasks[i].task);",
            "\t}",
            "\tkfree(reader_tasks);",
            "",
            "\ttorture_stop_kthread(\"main_task\", main_task);",
            "\tkfree(main_task);",
            "",
            "\t// Do scale-type-specific cleanup operations.",
            "\tif (cur_ops->cleanup != NULL)",
            "\t\tcur_ops->cleanup();",
            "",
            "\ttorture_cleanup_end();",
            "}",
            "static int",
            "ref_scale_shutdown(void *arg)",
            "{",
            "\twait_event_idle(shutdown_wq, shutdown_start);",
            "",
            "\tsmp_mb(); // Wake before output.",
            "\tref_scale_cleanup();",
            "\tkernel_power_off();",
            "",
            "\treturn -EINVAL;",
            "}",
            "static int __init",
            "ref_scale_init(void)",
            "{",
            "\tlong i;",
            "\tint firsterr = 0;",
            "\tstatic struct ref_scale_ops *scale_ops[] = {",
            "\t\t&rcu_ops, &srcu_ops, RCU_TRACE_OPS RCU_TASKS_OPS &refcnt_ops, &rwlock_ops,",
            "\t\t&rwsem_ops, &lock_ops, &lock_irq_ops, &acqrel_ops, &clock_ops, &jiffies_ops,",
            "\t\t&typesafe_ref_ops, &typesafe_lock_ops, &typesafe_seqlock_ops,",
            "\t};",
            "",
            "\tif (!torture_init_begin(scale_type, verbose))",
            "\t\treturn -EBUSY;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++) {",
            "\t\tcur_ops = scale_ops[i];",
            "\t\tif (strcmp(scale_type, cur_ops->name) == 0)",
            "\t\t\tbreak;",
            "\t}",
            "\tif (i == ARRAY_SIZE(scale_ops)) {",
            "\t\tpr_alert(\"rcu-scale: invalid scale type: \\\"%s\\\"\\n\", scale_type);",
            "\t\tpr_alert(\"rcu-scale types:\");",
            "\t\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++)",
            "\t\t\tpr_cont(\" %s\", scale_ops[i]->name);",
            "\t\tpr_cont(\"\\n\");",
            "\t\tfirsterr = -EINVAL;",
            "\t\tcur_ops = NULL;",
            "\t\tgoto unwind;",
            "\t}",
            "\tif (cur_ops->init)",
            "\t\tif (!cur_ops->init()) {",
            "\t\t\tfirsterr = -EUCLEAN;",
            "\t\t\tgoto unwind;",
            "\t\t}",
            "",
            "\tref_scale_print_module_parms(cur_ops, \"Start of test\");",
            "",
            "\t// Shutdown task",
            "\tif (shutdown) {",
            "\t\tinit_waitqueue_head(&shutdown_wq);",
            "\t\tfirsterr = torture_create_kthread(ref_scale_shutdown, NULL,",
            "\t\t\t\t\t\t  shutdown_task);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t\tschedule_timeout_uninterruptible(1);",
            "\t}",
            "",
            "\t// Reader tasks (default to ~75% of online CPUs).",
            "\tif (nreaders < 0)",
            "\t\tnreaders = (num_online_cpus() >> 1) + (num_online_cpus() >> 2);",
            "\tif (WARN_ONCE(loops <= 0, \"%s: loops = %ld, adjusted to 1\\n\", __func__, loops))",
            "\t\tloops = 1;",
            "\tif (WARN_ONCE(nreaders <= 0, \"%s: nreaders = %d, adjusted to 1\\n\", __func__, nreaders))",
            "\t\tnreaders = 1;",
            "\tif (WARN_ONCE(nruns <= 0, \"%s: nruns = %d, adjusted to 1\\n\", __func__, nruns))",
            "\t\tnruns = 1;",
            "\treader_tasks = kcalloc(nreaders, sizeof(reader_tasks[0]),",
            "\t\t\t       GFP_KERNEL);",
            "\tif (!reader_tasks) {",
            "\t\tSCALEOUT_ERRSTRING(\"out of memory\");",
            "\t\tfirsterr = -ENOMEM;",
            "\t\tgoto unwind;",
            "\t}",
            "",
            "\tVERBOSE_SCALEOUT(\"Starting %d reader threads\", nreaders);",
            "",
            "\tfor (i = 0; i < nreaders; i++) {",
            "\t\tinit_waitqueue_head(&reader_tasks[i].wq);",
            "\t\tfirsterr = torture_create_kthread(ref_scale_reader, (void *)i,",
            "\t\t\t\t\t\t  reader_tasks[i].task);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "",
            "\t// Main Task",
            "\tinit_waitqueue_head(&main_wq);",
            "\tfirsterr = torture_create_kthread(main_func, NULL, main_task);",
            "\tif (torture_init_error(firsterr))",
            "\t\tgoto unwind;",
            "",
            "\ttorture_init_end();",
            "\treturn 0;",
            "",
            "unwind:",
            "\ttorture_init_end();",
            "\tref_scale_cleanup();",
            "\tif (shutdown) {",
            "\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_REF_SCALE_TEST));",
            "\t\tkernel_power_off();",
            "\t}",
            "\treturn firsterr;",
            "}"
          ],
          "function_name": "ref_scale_print_module_parms, ref_scale_cleanup, ref_scale_shutdown, ref_scale_init",
          "description": "process_durations 计算所有读者任务的持续时间总和并构建格式化输出字符串",
          "similarity": 0.511972188949585
        }
      ]
    }
  ]
}