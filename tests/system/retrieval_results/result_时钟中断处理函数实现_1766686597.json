{
  "query": "时钟中断处理函数实现",
  "timestamp": "2025-12-26 02:16:37",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/timings.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:10:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\timings.c`\n\n---\n\n# irq/timings.c 技术文档\n\n## 1. 文件概述\n\n`irq/timings.c` 是 Linux 内核中用于中断时间预测的核心模块。该文件实现了基于历史中断时间戳的预测算法，旨在通过分析中断发生的周期性模式，预测下一次中断可能发生的时间。此功能主要用于低功耗场景（如 CPU 空闲状态管理），帮助调度器或电源管理子系统更精确地设置唤醒时间，从而在保证响应性的同时减少不必要的唤醒开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irq_timings`：每个 CPU 私有的中断时间记录结构，包含一个循环缓冲区，用于存储 `<中断号, 时间戳>` 元组。\n- `irqt_stats`：全局 IDR（整数到指针映射）结构，用于按中断号索引中断统计信息。\n- `irq_timing_enabled`：静态分支键（`static_key`），用于在运行时动态启用/禁用中断时间跟踪功能，避免性能开销。\n\n### 主要函数\n\n- `irq_timings_enable(void)`：启用中断时间跟踪功能，激活静态分支。\n- `irq_timings_disable(void)`：禁用中断时间跟踪功能，关闭静态分支。\n- （注：实际的预测算法逻辑虽未在代码片段中完整展示，但文档详细描述了其实现原理）\n\n## 3. 关键实现\n\n### 中断时间预测算法\n\n该模块采用三阶段算法预测中断周期：\n\n#### 1) 后缀数组（Suffix Array）模式识别\n- 将中断间隔（经 `ilog2` 映射后的索引值）序列视为字符串。\n- 构建长度为 2 到 5 的后缀（受限于实际设备周期经验）。\n- 在最近 `3 × max_period`（即 15）个索引中搜索后缀的重复出现。\n- 若某后缀连续出现 3 次，则认为发现有效周期模式，其长度即为预测周期。\n\n#### 2) 对数间隔桶（Log Interval Bucketing）\n- 使用 `ilog2(interval)` 将原始时间间隔映射到 0~63 的桶索引（因 `u64` 最大为 2^64）。\n- 该方法将大范围的时间值压缩到小数组中，例如值 1123 映射到索引 10（因 2^10 = 1024 ≤ 1123 < 2048 = 2^11）。\n\n#### 3) 指数移动平均（Exponential Moving Average, EMA）\n- 每个桶维护一个 EMA 值，用于平滑同一数量级间隔的波动。\n- EMA 公式使平均值对新数据具有可调的响应速度（通过 alpha 参数隐式控制）。\n- 预测时，根据识别出的周期模式中的桶索引，返回对应桶的 EMA 值作为预测间隔。\n\n### 工作流程\n1. 中断发生时，若 `irq_timing_enabled` 为真，则将 `<irq, timestamp>` 记录到 per-CPU 的循环缓冲区。\n2. 当需要预测某中断的下次发生时间时：\n   - 清空并处理循环缓冲区，将间隔数据分发到各中断的统计结构中。\n   - 对每个中断的间隔序列执行上述三阶段算法。\n   - 若找到重复模式，则用 EMA 值计算预测时间；否则返回未预测。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：实现 per-CPU 变量 `irq_timings`。\n  - `<linux/static_key.h>`：提供静态分支优化，避免未启用时的条件判断开销。\n  - `<linux/math64.h>` 和 `<linux/log2.h>`：用于 `ilog2` 等数学运算。\n  - `<trace/events/irq.h>`：可能用于跟踪事件（虽未在片段中调用）。\n  - `\"internals.h\"`：内核中断子系统内部头文件。\n- **子系统依赖**：\n  - 通用中断子系统（`<linux/irq.h>`, `<linux/interrupt.h>`）。\n  - 内存管理（`<linux/slab.h>`）用于动态分配统计结构。\n  - IDR 机制（`<linux/idr.h>`）用于中断号到统计结构的映射。\n\n## 5. 使用场景\n\n- **CPU 空闲状态管理（cpuidle）**：在进入深度 C-state 前，预测下一次中断时间以设置精确的唤醒定时器，避免过早或过晚唤醒。\n- **实时系统调度**：辅助调度器预判周期性中断（如 tickless 系统中的高精度定时器），优化任务调度时机。\n- **电源管理**：结合设备驱动的中断模式，动态调整设备或 CPU 的电源状态。\n- **性能分析**：通过跟踪中断时间模式，诊断中断风暴或异常周期行为。\n\n该功能默认关闭，仅在需要时通过 `irq_timings_enable()` 动态启用，确保对常规系统性能无影响。",
      "similarity": 0.6574400067329407,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/timings.c",
          "start_line": 927,
          "end_line": 956,
          "content": [
            "static int __init irq_timings_selftest(void)",
            "{",
            "\tint ret;",
            "",
            "\tpr_info(\"------------------- selftest start -----------------\\n\");",
            "",
            "\t/*",
            "\t * At this point, we don't except any subsystem to use the irq",
            "\t * timings but us, so it should not be enabled.",
            "\t */",
            "\tif (static_branch_unlikely(&irq_timing_enabled)) {",
            "\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = irq_timings_irqts_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_irqs_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_next_index_selftest();",
            "out:",
            "\tpr_info(\"---------- selftest end with %s -----------\\n\",",
            "\t\tret ? \"failure\" : \"success\");",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_selftest",
          "description": "该代码段实现了中断定时功能的自我检测逻辑，用于验证中断时间戳、中断序列及索引管理等子系统的正确性。作为初始化函数，它通过调用三个子测试函数依次检查相关功能模块的行为是否符合预期。由于代码中引用了未展示的测试函数（如irq_timings_irqts_selftest），需结合上下文才能完整理解其工作机制。",
          "similarity": 0.6530031561851501
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/timings.c",
          "start_line": 26,
          "end_line": 165,
          "content": [
            "void irq_timings_enable(void)",
            "{",
            "\tstatic_branch_enable(&irq_timing_enabled);",
            "}",
            "void irq_timings_disable(void)",
            "{",
            "\tstatic_branch_disable(&irq_timing_enabled);",
            "}",
            "static u64 irq_timings_ema_new(u64 value, u64 ema_old)",
            "{",
            "\ts64 diff;",
            "",
            "\tif (unlikely(!ema_old))",
            "\t\treturn value;",
            "",
            "\tdiff = (value - ema_old) * EMA_ALPHA_VAL;",
            "\t/*",
            "\t * We can use a s64 type variable to be added with the u64",
            "\t * ema_old variable as this one will never have its topmost",
            "\t * bit set, it will be always smaller than 2^63 nanosec",
            "\t * interrupt interval (292 years).",
            "\t */",
            "\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);",
            "}",
            "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)",
            "{",
            "\tint period;",
            "",
            "\t/*",
            "\t * Move the beginning pointer to the end minus the max period x 3.",
            "\t * We are at the point we can begin searching the pattern",
            "\t */",
            "\tbuffer = &buffer[len - (period_max * 3)];",
            "",
            "\t/* Adjust the length to the maximum allowed period x 3 */",
            "\tlen = period_max * 3;",
            "",
            "\t/*",
            "\t * The buffer contains the suite of intervals, in a ilog2",
            "\t * basis, we are looking for a repetition. We point the",
            "\t * beginning of the search three times the length of the",
            "\t * period beginning at the end of the buffer. We do that for",
            "\t * each suffix.",
            "\t */",
            "\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {",
            "",
            "\t\t/*",
            "\t\t * The first comparison always succeed because the",
            "\t\t * suffix is deduced from the first n-period bytes of",
            "\t\t * the buffer and we compare the initial suffix with",
            "\t\t * itself, so we can skip the first iteration.",
            "\t\t */",
            "\t\tint idx = period;",
            "\t\tsize_t size = period;",
            "",
            "\t\t/*",
            "\t\t * We look if the suite with period 'i' repeat",
            "\t\t * itself. If it is truncated at the end, as it",
            "\t\t * repeats we can use the period to find out the next",
            "\t\t * element with the modulo.",
            "\t\t */",
            "\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {",
            "",
            "\t\t\t/*",
            "\t\t\t * Move the index in a period basis",
            "\t\t\t */",
            "\t\t\tidx += size;",
            "",
            "\t\t\t/*",
            "\t\t\t * If this condition is reached, all previous",
            "\t\t\t * memcmp were successful, so the period is",
            "\t\t\t * found.",
            "\t\t\t */",
            "\t\t\tif (idx == len)",
            "\t\t\t\treturn buffer[len % period];",
            "",
            "\t\t\t/*",
            "\t\t\t * If the remaining elements to compare are",
            "\t\t\t * smaller than the period, readjust the size",
            "\t\t\t * of the comparison for the last iteration.",
            "\t\t\t */",
            "\t\t\tif (len - idx < period)",
            "\t\t\t\tsize = len - idx;",
            "\t\t}",
            "\t}",
            "",
            "\treturn -1;",
            "}",
            "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)",
            "{",
            "\tint index, i, period_max, count, start, min = INT_MAX;",
            "",
            "\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {",
            "\t\tirqs->count = irqs->last_ts = 0;",
            "\t\treturn U64_MAX;",
            "\t}",
            "",
            "\t/*",
            "\t * As we want to find three times the repetition, we need a",
            "\t * number of intervals greater or equal to three times the",
            "\t * maximum period, otherwise we truncate the max period.",
            "\t */",
            "\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;",
            "",
            "\t/*",
            "\t * If we don't have enough irq timings for this prediction,",
            "\t * just bail out.",
            "\t */",
            "\tif (period_max <= PREDICTION_PERIOD_MIN)",
            "\t\treturn U64_MAX;",
            "",
            "\t/*",
            "\t * 'count' will depends if the circular buffer wrapped or not",
            "\t */",
            "\tcount = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\tirqs->count : IRQ_TIMINGS_SIZE;",
            "",
            "\tstart = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);",
            "",
            "\t/*",
            "\t * Copy the content of the circular buffer into another buffer",
            "\t * in order to linearize the buffer instead of dealing with",
            "\t * wrapping indexes and shifted array which will be prone to",
            "\t * error and extremely difficult to debug.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "",
            "\t\tirqs->timings[i] = irqs->circ_timings[index];",
            "\t\tmin = min_t(int, irqs->timings[i], min);",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);",
            "\tif (index < 0)",
            "\t\treturn irqs->last_ts + irqs->ema_time[min];",
            "",
            "\treturn irqs->last_ts + irqs->ema_time[index];",
            "}"
          ],
          "function_name": "irq_timings_enable, irq_timings_disable, irq_timings_ema_new, irq_timings_next_event_index, __irq_timings_next_event",
          "description": "实现中断计时功能的启用/禁用控制，EMA计算算法及基于模式匹配的周期预测核心逻辑",
          "similarity": 0.6500961780548096
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/timings.c",
          "start_line": 435,
          "end_line": 563,
          "content": [
            "static __always_inline int irq_timings_interval_index(u64 interval)",
            "{",
            "\t/*",
            "\t * The PREDICTION_FACTOR increase the interval size for the",
            "\t * array of exponential average.",
            "\t */",
            "\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;",
            "",
            "\treturn likely(interval_us) ? ilog2(interval_us) : 0;",
            "}",
            "static __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,",
            "\t\t\t\t\t\tu64 interval)",
            "{",
            "\tint index;",
            "",
            "\t/*",
            "\t * Get the index in the ema table for this interrupt.",
            "\t */",
            "\tindex = irq_timings_interval_index(interval);",
            "",
            "\tif (index > PREDICTION_BUFFER_SIZE - 1) {",
            "\t\tirqs->count = 0;",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Store the index as an element of the pattern in another",
            "\t * circular array.",
            "\t */",
            "\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;",
            "",
            "\tirqs->ema_time[index] = irq_timings_ema_new(interval,",
            "\t\t\t\t\t\t    irqs->ema_time[index]);",
            "",
            "\tirqs->count++;",
            "}",
            "static inline void irq_timings_store(int irq, struct irqt_stat *irqs, u64 ts)",
            "{",
            "\tu64 old_ts = irqs->last_ts;",
            "\tu64 interval;",
            "",
            "\t/*",
            "\t * The timestamps are absolute time values, we need to compute",
            "\t * the timing interval between two interrupts.",
            "\t */",
            "\tirqs->last_ts = ts;",
            "",
            "\t/*",
            "\t * The interval type is u64 in order to deal with the same",
            "\t * type in our computation, that prevent mindfuck issues with",
            "\t * overflow, sign and division.",
            "\t */",
            "\tinterval = ts - old_ts;",
            "",
            "\t/*",
            "\t * The interrupt triggered more than one second apart, that",
            "\t * ends the sequence as predictable for our purpose. In this",
            "\t * case, assume we have the beginning of a sequence and the",
            "\t * timestamp is the first value. As it is impossible to",
            "\t * predict anything at this point, return.",
            "\t *",
            "\t * Note the first timestamp of the sequence will always fall",
            "\t * in this test because the old_ts is zero. That is what we",
            "\t * want as we need another timestamp to compute an interval.",
            "\t */",
            "\tif (interval >= NSEC_PER_SEC) {",
            "\t\tirqs->count = 0;",
            "\t\treturn;",
            "\t}",
            "",
            "\t__irq_timings_store(irq, irqs, interval);",
            "}",
            "u64 irq_timings_next_event(u64 now)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tstruct irqt_stat *irqs;",
            "\tstruct irqt_stat __percpu *s;",
            "\tu64 ts, next_evt = U64_MAX;",
            "\tint i, irq = 0;",
            "",
            "\t/*",
            "\t * This function must be called with the local irq disabled in",
            "\t * order to prevent the timings circular buffer to be updated",
            "\t * while we are reading it.",
            "\t */",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\tif (!irqts->count)",
            "\t\treturn next_evt;",
            "",
            "\t/*",
            "\t * Number of elements in the circular buffer: If it happens it",
            "\t * was flushed before, then the number of elements could be",
            "\t * smaller than IRQ_TIMINGS_SIZE, so the count is used,",
            "\t * otherwise the array size is used as we wrapped. The index",
            "\t * begins from zero when we did not wrap. That could be done",
            "\t * in a nicer way with the proper circular array structure",
            "\t * type but with the cost of extra computation in the",
            "\t * interrupt handler hot path. We choose efficiency.",
            "\t *",
            "\t * Inject measured irq/timestamp to the pattern prediction",
            "\t * model while decrementing the counter because we consume the",
            "\t * data from our circular buffer.",
            "\t */",
            "\tfor_each_irqts(i, irqts) {",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "\t\ts = idr_find(&irqt_stats, irq);",
            "\t\tif (s)",
            "\t\t\tirq_timings_store(irq, this_cpu_ptr(s), ts);",
            "\t}",
            "",
            "\t/*",
            "\t * Look in the list of interrupts' statistics, the earliest",
            "\t * next event.",
            "\t */",
            "\tidr_for_each_entry(&irqt_stats, s, i) {",
            "",
            "\t\tirqs = this_cpu_ptr(s);",
            "",
            "\t\tts = __irq_timings_next_event(irqs, i, now);",
            "\t\tif (ts <= now)",
            "\t\t\treturn now;",
            "",
            "\t\tif (ts < next_evt)",
            "\t\t\tnext_evt = ts;",
            "\t}",
            "",
            "\treturn next_evt;",
            "}"
          ],
          "function_name": "irq_timings_interval_index, __irq_timings_store, irq_timings_store, irq_timings_next_event",
          "description": "提供时间间隔转索引的映射函数，实现环形缓冲区数据存储及主事件预测函数",
          "similarity": 0.6485583186149597
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/timings.c",
          "start_line": 594,
          "end_line": 739,
          "content": [
            "void irq_timings_free(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s) {",
            "\t\tfree_percpu(s);",
            "\t\tidr_remove(&irqt_stats, irq);",
            "\t}",
            "}",
            "int irq_timings_alloc(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tint id;",
            "",
            "\t/*",
            "\t * Some platforms can have the same private interrupt per cpu,",
            "\t * so this function may be called several times with the",
            "\t * same interrupt number. Just bail out in case the per cpu",
            "\t * stat structure is already allocated.",
            "\t */",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s)",
            "\t\treturn 0;",
            "",
            "\ts = alloc_percpu(*s);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\tidr_preload(GFP_KERNEL);",
            "\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);",
            "\tidr_preload_end();",
            "",
            "\tif (id < 0) {",
            "\t\tfree_percpu(s);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_test_next_index(struct timings_intervals *ti)",
            "{",
            "\tint _buffer[IRQ_TIMINGS_SIZE];",
            "\tint buffer[IRQ_TIMINGS_SIZE];",
            "\tint index, start, i, count, period_max;",
            "",
            "\tcount = ti->count - 1;",
            "",
            "\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : count / 3;",
            "",
            "\t/*",
            "\t * Inject all values except the last one which will be used",
            "\t * to compare with the next index result.",
            "\t */",
            "\tpr_debug(\"index suite: \");",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;",
            "\t\tpr_cont(\"%d \", index);",
            "\t}",
            "",
            "\tstart = count < IRQ_TIMINGS_SIZE ? 0 :",
            "\t\tcount & IRQ_TIMINGS_MASK;",
            "",
            "\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "\t\tbuffer[i] = _buffer[index];",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(buffer, count, period_max);",
            "\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);",
            "",
            "\tif (index != i) {",
            "\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",",
            "\t\t       i, index);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_next_index_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "",
            "\t\tret = irq_timings_test_next_index(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqs(struct timings_intervals *ti)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tstruct irqt_stat *irqs;",
            "\tint i, index, ret, irq = 0xACE5;",
            "",
            "\tret = irq_timings_alloc(irq);",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate irq timings\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (!s) {",
            "\t\tret = -EIDRM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tirqs = this_cpu_ptr(s);",
            "",
            "\tfor (i = 0; i < ti->count; i++) {",
            "",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",",
            "\t\t\t i, ti->intervals[i], index);",
            "",
            "\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);",
            "\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {",
            "\t\t\tret = -EBADSLT;",
            "\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (irqs->count != ti->count) {",
            "\t\tret = -ERANGE;",
            "\t\tpr_err(\"Count differs\\n\");",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "out:",
            "\tirq_timings_free(irq);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_free, irq_timings_alloc, irq_timings_test_next_index, irq_timings_next_index_selftest, irq_timings_test_irqs",
          "description": "实现中断统计结构的动态分配/释放机制，包含预测算法的自检测试函数",
          "similarity": 0.6254475712776184
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/timings.c",
          "start_line": 821,
          "end_line": 923,
          "content": [
            "static int __init irq_timings_irqs_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "\t\tret = irq_timings_test_irqs(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqts(struct irq_timings *irqts,",
            "\t\t\t\t\t unsigned count)",
            "{",
            "\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;",
            "\tint i, irq, oirq = 0xBEEF;",
            "\tu64 ots = 0xDEAD, ts;",
            "",
            "\t/*",
            "\t * Fill the circular buffer by using the dedicated function.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",",
            "\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);",
            "",
            "\t\tirq_timings_push(ots + i, oirq + i);",
            "\t}",
            "",
            "\t/*",
            "\t * Compute the first elements values after the index wrapped",
            "\t * up or not.",
            "\t */",
            "\tots += start;",
            "\toirq += start;",
            "",
            "\t/*",
            "\t * Test the circular buffer count is correct.",
            "\t */",
            "\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);",
            "\tif (WARN_ON(irqts->count != count))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Test the macro allowing to browse all the irqts.",
            "\t */",
            "\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");",
            "\tfor_each_irqts(i, irqts) {",
            "",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "",
            "\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",",
            "\t\t\t i, ts, ots, irq, oirq);",
            "",
            "\t\tif (WARN_ON(ts != ots || irq != oirq))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tots++; oirq++;",
            "\t}",
            "",
            "\t/*",
            "\t * The circular buffer should have be flushed when browsed",
            "\t * with for_each_irqts",
            "\t */",
            "\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");",
            "\tif (WARN_ON(irqts->count))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_irqts_selftest(void)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tint i, ret;",
            "",
            "\t/*",
            "\t * Test the circular buffer with different number of",
            "\t * elements. The purpose is to test at the limits (empty, half",
            "\t * full, full, wrapped with the cursor at the boundaries,",
            "\t * wrapped several times, etc ...",
            "\t */",
            "\tint count[] = { 0,",
            "\t\t\tIRQ_TIMINGS_SIZE >> 1,",
            "\t\t\tIRQ_TIMINGS_SIZE,",
            "\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),",
            "\t\t\t2 * IRQ_TIMINGS_SIZE,",
            "\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,",
            "\t};",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(count); i++) {",
            "",
            "\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",",
            "\t\t\tcount[i], IRQ_TIMINGS_SIZE);",
            "",
            "\t\tret = irq_timings_test_irqts(irqts, count[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_irqs_selftest, irq_timings_test_irqts, irq_timings_irqts_selftest",
          "description": "包含完整的中断计时模块自检框架，验证环形缓冲区操作和for_each_irqts宏的正确性",
          "similarity": 0.6184847354888916
        }
      ]
    },
    {
      "source_file": "kernel/time/posix-cpu-timers.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:43:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\posix-cpu-timers.c`\n\n---\n\n# `time/posix-cpu-timers.c` 技术文档\n\n## 1. 文件概述\n\n`posix-cpu-timers.c` 实现了 POSIX CPU 时间定时器（CPU time clocks）的核心逻辑，为用户空间提供基于进程或线程 CPU 使用时间的定时器功能。该文件支持三种 CPU 时钟类型：\n\n- `CPUCLOCK_PROF`：进程总 CPU 时间（用户态 + 内核态）\n- `CPUCLOCK_VIRT`：进程用户态 CPU 时间\n- `CPUCLOCK_SCHED`：基于调度器的运行时间（高精度）\n\n该模块负责定时器的创建、采样、到期处理、超限检测（如 `RLIMIT_CPU`）以及与进程/线程组 CPU 时间统计的集成。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `posix_cputimers_group_init()` | 初始化进程组的 POSIX CPU 定时器结构，设置 CPU 时间限制 |\n| `update_rlimit_cpu()` | 在 `RLIMIT_CPU` 资源限制更新后，重新设置进程级 PROF 定时器 |\n| `pid_for_clock()` | 根据 clockid 解析目标进程/线程的 PID，进行权限和有效性验证 |\n| `validate_clock_permissions()` | 验证给定 clockid 是否具有合法的目标任务 |\n| `bump_cpu_timer()` | 计算定时器超期次数（overrun）并更新下一次到期时间 |\n| `posix_cpu_clock_getres()` | 获取指定 CPU 时钟的分辨率 |\n| `posix_cpu_clock_set()` | 设置 CPU 时钟（始终返回 `-EPERM`，不可设置）|\n| `cpu_clock_sample()` | 采样指定任务的单个 CPU 时钟值 |\n| `thread_group_sample_cputime()` | 采样线程组的原子 CPU 时间（用于活跃定时器）|\n| `thread_group_start_cputime()` | 启动线程组 CPU 时间统计并返回初始采样（未完成）|\n\n### 关键数据结构\n\n- `struct posix_cputimers`：管理进程/线程组的三种 CPU 定时器基础结构和到期缓存\n- `struct k_itimer`：内核定时间器对象，包含 CPU 定时器特定字段（`it.cpu`）\n- `struct thread_group_cputimer`：线程组级别的原子 CPU 时间累加器\n- `struct task_cputime_atomic`：原子化的 CPU 时间存储（utime, stime, sum_exec_runtime）\n\n## 3. 关键实现\n\n### 定时器超期与 overrun 计算\n`bump_cpu_timer()` 使用位移算法高效计算定时器在当前时间点的超期次数。避免了简单的循环计数（在间隔小、延迟大时性能差），而是通过指数级逼近（类似二分）快速确定超期轮数，并累加 `1LL << i` 到 `it_overrun`。\n\n### CPU 时间采样机制\n- **单任务采样**：`cpu_clock_sample()` 直接调用 `task_cputime()` 或 `task_sched_runtime()` 获取实时值。\n- **线程组采样**：使用原子变量 `task_cputime_atomic` 存储累计值，通过 `proc_sample_cputime_atomic()` 无锁读取，保证在信号处理等上下文中的安全性。\n- **按需激活统计**：`thread_group_start_cputime()` 在首次设置 CPU 定时器时激活线程组 CPU 时间统计，避免无定时器时的性能开销。\n\n### 权限与目标验证\n`pid_for_clock()` 严格验证 clockid 编码的 PID：\n- PID=0 表示当前任务或其线程组\n- 线程定时器（`CPUCLOCK_PERTHREAD`）仅允许同一线程组内的任务\n- 进程定时器要求 PID 对应有效的 TGID\n- `clock_gettime` 允许通过当前任务 PID 获取其 TGID\n\n### 资源限制集成\n`update_rlimit_cpu()` 在 `setrlimit(RLIMIT_CPU)` 时，通过 `set_process_cpu_timer()` 更新 `CPUCLOCK_PROF` 定时器，实现 CPU 时间超限信号（`SIGXCPU`）的发送。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_cputime()`、`task_sched_runtime()`、`sum_exec_runtime` 等调度器提供的 CPU 时间统计\n- **信号子系统**：通过 `lock_task_sighand()` 保护信号结构，定时器到期时发送信号\n- **POSIX 定时器框架**：作为 `posix-timers.c` 的扩展，实现 CPU 时钟相关的回调（如 `getres`, `set`, 采样等）\n- **RCU 机制**：在任务查找（`pid_task`）和权限验证中使用 RCU 读锁\n- **原子操作**：使用 `atomic64_try_cmpxchg` 实现无锁的 CPU 时间更新\n- **追踪系统**：集成 `trace/events/timer.h` 用于定时器事件追踪\n\n## 5. 使用场景\n\n1. **用户空间 POSIX CPU 定时器**：\n   - `timer_create(CLOCK_PROCESS_CPUTIME_ID, ...)` 创建进程级 CPU 定时器\n   - `timer_create(CLOCK_THREAD_CPUTIME_ID, ...)` 创建线程级 CPU 定时器\n\n2. **CPU 时间资源限制**：\n   - 当进程调用 `setrlimit(RLIMIT_CPU, ...)` 时，内核通过 `update_rlimit_cpu()` 设置 PROF 定时器，在超限时发送 `SIGXCPU`\n\n3. **高精度调度时间监控**：\n   - 应用通过 `clock_gettime(CLOCK_SCHED, ...)` 获取纳秒级调度运行时间（如实时任务监控）\n\n4. **性能分析工具**：\n   - 工具如 `perf`、`strace` 利用 CPU 时钟获取精确的进程/线程 CPU 消耗\n\n5. **内核自检与调试**：\n   - 通过 `WARN_ON_ONCE` 检测非法时钟类型或未激活的定时器访问\n\n> **注**：文件末尾的 `thread_group_start_cputime()` 函数定义不完整，实际实现应在后续代码中完成线程组 CPU 时间统计的激活和初始化。",
      "similarity": 0.6258384585380554,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "kernel/time/posix-cpu-timers.c",
          "start_line": 1601,
          "end_line": 1670,
          "content": [
            "static int posix_cpu_nsleep(const clockid_t which_clock, int flags,",
            "\t\t\t    const struct timespec64 *rqtp)",
            "{",
            "\tstruct restart_block *restart_block = &current->restart_block;",
            "\tint error;",
            "",
            "\t/*",
            "\t * Diagnose required errors first.",
            "\t */",
            "\tif (CPUCLOCK_PERTHREAD(which_clock) &&",
            "\t    (CPUCLOCK_PID(which_clock) == 0 ||",
            "\t     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))",
            "\t\treturn -EINVAL;",
            "",
            "\terror = do_cpu_nanosleep(which_clock, flags, rqtp);",
            "",
            "\tif (error == -ERESTART_RESTARTBLOCK) {",
            "",
            "\t\tif (flags & TIMER_ABSTIME)",
            "\t\t\treturn -ERESTARTNOHAND;",
            "",
            "\t\trestart_block->nanosleep.clockid = which_clock;",
            "\t\tset_restart_fn(restart_block, posix_cpu_nsleep_restart);",
            "\t}",
            "\treturn error;",
            "}",
            "static long posix_cpu_nsleep_restart(struct restart_block *restart_block)",
            "{",
            "\tclockid_t which_clock = restart_block->nanosleep.clockid;",
            "\tstruct timespec64 t;",
            "",
            "\tt = ns_to_timespec64(restart_block->nanosleep.expires);",
            "",
            "\treturn do_cpu_nanosleep(which_clock, TIMER_ABSTIME, &t);",
            "}",
            "static int process_cpu_clock_getres(const clockid_t which_clock,",
            "\t\t\t\t    struct timespec64 *tp)",
            "{",
            "\treturn posix_cpu_clock_getres(PROCESS_CLOCK, tp);",
            "}",
            "static int process_cpu_clock_get(const clockid_t which_clock,",
            "\t\t\t\t struct timespec64 *tp)",
            "{",
            "\treturn posix_cpu_clock_get(PROCESS_CLOCK, tp);",
            "}",
            "static int process_cpu_timer_create(struct k_itimer *timer)",
            "{",
            "\ttimer->it_clock = PROCESS_CLOCK;",
            "\treturn posix_cpu_timer_create(timer);",
            "}",
            "static int process_cpu_nsleep(const clockid_t which_clock, int flags,",
            "\t\t\t      const struct timespec64 *rqtp)",
            "{",
            "\treturn posix_cpu_nsleep(PROCESS_CLOCK, flags, rqtp);",
            "}",
            "static int thread_cpu_clock_getres(const clockid_t which_clock,",
            "\t\t\t\t   struct timespec64 *tp)",
            "{",
            "\treturn posix_cpu_clock_getres(THREAD_CLOCK, tp);",
            "}",
            "static int thread_cpu_clock_get(const clockid_t which_clock,",
            "\t\t\t\tstruct timespec64 *tp)",
            "{",
            "\treturn posix_cpu_clock_get(THREAD_CLOCK, tp);",
            "}",
            "static int thread_cpu_timer_create(struct k_itimer *timer)",
            "{",
            "\ttimer->it_clock = THREAD_CLOCK;",
            "\treturn posix_cpu_timer_create(timer);",
            "}"
          ],
          "function_name": "posix_cpu_nsleep, posix_cpu_nsleep_restart, process_cpu_clock_getres, process_cpu_clock_get, process_cpu_timer_create, process_cpu_nsleep, thread_cpu_clock_getres, thread_cpu_clock_get, thread_cpu_timer_create",
          "description": "该代码块实现了基于进程和线程级别的POSIX CPU时钟操作，核心功能是处理纳秒睡眠、时间获取及定时器创建。  \n`posix_cpu_nsleep`及其重启函数用于管理带重启支持的CPU计时器睡眠，其余函数通过封装`PROCESS_CLOCK`/`THREAD_CLOCK`实现对进程/线程级时钟的统一接口。  \n代码片段未完整展示底层`do_cpu_nanosleep`等关键函数实现，存在上下文依赖。",
          "similarity": 0.6666706800460815
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/posix-cpu-timers.c",
          "start_line": 24,
          "end_line": 139,
          "content": [
            "void posix_cputimers_group_init(struct posix_cputimers *pct, u64 cpu_limit)",
            "{",
            "\tposix_cputimers_init(pct);",
            "\tif (cpu_limit != RLIM_INFINITY) {",
            "\t\tpct->bases[CPUCLOCK_PROF].nextevt = cpu_limit * NSEC_PER_SEC;",
            "\t\tpct->timers_active = true;",
            "\t}",
            "}",
            "int update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new)",
            "{",
            "\tu64 nsecs = rlim_new * NSEC_PER_SEC;",
            "\tunsigned long irq_fl;",
            "",
            "\tif (!lock_task_sighand(task, &irq_fl))",
            "\t\treturn -ESRCH;",
            "\tset_process_cpu_timer(task, CPUCLOCK_PROF, &nsecs, NULL);",
            "\tunlock_task_sighand(task, &irq_fl);",
            "\treturn 0;",
            "}",
            "static inline int validate_clock_permissions(const clockid_t clock)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = pid_for_clock(clock, false) ? 0 : -EINVAL;",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "static inline enum pid_type clock_pid_type(const clockid_t clock)",
            "{",
            "\treturn CPUCLOCK_PERTHREAD(clock) ? PIDTYPE_PID : PIDTYPE_TGID;",
            "}",
            "static u64 bump_cpu_timer(struct k_itimer *timer, u64 now)",
            "{",
            "\tu64 delta, incr, expires = timer->it.cpu.node.expires;",
            "\tint i;",
            "",
            "\tif (!timer->it_interval)",
            "\t\treturn expires;",
            "",
            "\tif (now < expires)",
            "\t\treturn expires;",
            "",
            "\tincr = timer->it_interval;",
            "\tdelta = now + incr - expires;",
            "",
            "\t/* Don't use (incr*2 < delta), incr*2 might overflow. */",
            "\tfor (i = 0; incr < delta - incr; i++)",
            "\t\tincr = incr << 1;",
            "",
            "\tfor (; i >= 0; incr >>= 1, i--) {",
            "\t\tif (delta < incr)",
            "\t\t\tcontinue;",
            "",
            "\t\ttimer->it.cpu.node.expires += incr;",
            "\t\ttimer->it_overrun += 1LL << i;",
            "\t\tdelta -= incr;",
            "\t}",
            "\treturn timer->it.cpu.node.expires;",
            "}",
            "static inline bool expiry_cache_is_inactive(const struct posix_cputimers *pct)",
            "{",
            "\treturn !(~pct->bases[CPUCLOCK_PROF].nextevt |",
            "\t\t ~pct->bases[CPUCLOCK_VIRT].nextevt |",
            "\t\t ~pct->bases[CPUCLOCK_SCHED].nextevt);",
            "}",
            "static int",
            "posix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)",
            "{",
            "\tint error = validate_clock_permissions(which_clock);",
            "",
            "\tif (!error) {",
            "\t\ttp->tv_sec = 0;",
            "\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);",
            "\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {",
            "\t\t\t/*",
            "\t\t\t * If sched_clock is using a cycle counter, we",
            "\t\t\t * don't have any idea of its true resolution",
            "\t\t\t * exported, but it is much more than 1s/HZ.",
            "\t\t\t */",
            "\t\t\ttp->tv_nsec = 1;",
            "\t\t}",
            "\t}",
            "\treturn error;",
            "}",
            "static int",
            "posix_cpu_clock_set(const clockid_t clock, const struct timespec64 *tp)",
            "{",
            "\tint error = validate_clock_permissions(clock);",
            "",
            "\t/*",
            "\t * You can never reset a CPU clock, but we check for other errors",
            "\t * in the call before failing with EPERM.",
            "\t */",
            "\treturn error ? : -EPERM;",
            "}",
            "static u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)",
            "{",
            "\tu64 utime, stime;",
            "",
            "\tif (clkid == CPUCLOCK_SCHED)",
            "\t\treturn task_sched_runtime(p);",
            "",
            "\ttask_cputime(p, &utime, &stime);",
            "",
            "\tswitch (clkid) {",
            "\tcase CPUCLOCK_PROF:",
            "\t\treturn utime + stime;",
            "\tcase CPUCLOCK_VIRT:",
            "\t\treturn utime;",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "posix_cputimers_group_init, update_rlimit_cpu, validate_clock_permissions, clock_pid_type, bump_cpu_timer, expiry_cache_is_inactive, posix_cpu_clock_getres, posix_cpu_clock_set, cpu_clock_sample",
          "description": "实现CPU时间钟的初始化配置、资源限制更新、权限校验、时间样本采集及基础时间计算，包含对进程和线程级别的CPU时间追踪与过期时间调整逻辑。",
          "similarity": 0.658929169178009
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/posix-cpu-timers.c",
          "start_line": 358,
          "end_line": 467,
          "content": [
            "static int posix_cpu_clock_get(const clockid_t clock, struct timespec64 *tp)",
            "{",
            "\tconst clockid_t clkid = CPUCLOCK_WHICH(clock);",
            "\tstruct task_struct *tsk;",
            "\tu64 t;",
            "",
            "\trcu_read_lock();",
            "\ttsk = pid_task(pid_for_clock(clock, true), clock_pid_type(clock));",
            "\tif (!tsk) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (CPUCLOCK_PERTHREAD(clock))",
            "\t\tt = cpu_clock_sample(clkid, tsk);",
            "\telse",
            "\t\tt = cpu_clock_sample_group(clkid, tsk, false);",
            "\trcu_read_unlock();",
            "",
            "\t*tp = ns_to_timespec64(t);",
            "\treturn 0;",
            "}",
            "static int posix_cpu_timer_create(struct k_itimer *new_timer)",
            "{",
            "\tstatic struct lock_class_key posix_cpu_timers_key;",
            "\tstruct pid *pid;",
            "",
            "\trcu_read_lock();",
            "\tpid = pid_for_clock(new_timer->it_clock, false);",
            "\tif (!pid) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/*",
            "\t * If posix timer expiry is handled in task work context then",
            "\t * timer::it_lock can be taken without disabling interrupts as all",
            "\t * other locking happens in task context. This requires a separate",
            "\t * lock class key otherwise regular posix timer expiry would record",
            "\t * the lock class being taken in interrupt context and generate a",
            "\t * false positive warning.",
            "\t */",
            "\tif (IS_ENABLED(CONFIG_POSIX_CPU_TIMERS_TASK_WORK))",
            "\t\tlockdep_set_class(&new_timer->it_lock, &posix_cpu_timers_key);",
            "",
            "\tnew_timer->kclock = &clock_posix_cpu;",
            "\ttimerqueue_init(&new_timer->it.cpu.node);",
            "\tnew_timer->it.cpu.pid = get_pid(pid);",
            "\trcu_read_unlock();",
            "\treturn 0;",
            "}",
            "static void trigger_base_recalc_expires(struct k_itimer *timer,",
            "\t\t\t\t\tstruct task_struct *tsk)",
            "{",
            "\tstruct posix_cputimer_base *base = timer_base(timer, tsk);",
            "",
            "\tbase->nextevt = 0;",
            "}",
            "static void disarm_timer(struct k_itimer *timer, struct task_struct *p)",
            "{",
            "\tstruct cpu_timer *ctmr = &timer->it.cpu;",
            "\tstruct posix_cputimer_base *base;",
            "",
            "\tif (!cpu_timer_dequeue(ctmr))",
            "\t\treturn;",
            "",
            "\tbase = timer_base(timer, p);",
            "\tif (cpu_timer_getexpires(ctmr) == base->nextevt)",
            "\t\ttrigger_base_recalc_expires(timer, p);",
            "}",
            "static int posix_cpu_timer_del(struct k_itimer *timer)",
            "{",
            "\tstruct cpu_timer *ctmr = &timer->it.cpu;",
            "\tstruct sighand_struct *sighand;",
            "\tstruct task_struct *p;",
            "\tunsigned long flags;",
            "\tint ret = 0;",
            "",
            "\trcu_read_lock();",
            "\tp = cpu_timer_task_rcu(timer);",
            "\tif (!p)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Protect against sighand release/switch in exit/exec and process/",
            "\t * thread timer list entry concurrent read/writes.",
            "\t */",
            "\tsighand = lock_task_sighand(p, &flags);",
            "\tif (unlikely(sighand == NULL)) {",
            "\t\t/*",
            "\t\t * This raced with the reaping of the task. The exit cleanup",
            "\t\t * should have removed this timer from the timer queue.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(ctmr->head || timerqueue_node_queued(&ctmr->node));",
            "\t} else {",
            "\t\tif (timer->it.cpu.firing)",
            "\t\t\tret = TIMER_RETRY;",
            "\t\telse",
            "\t\t\tdisarm_timer(timer, p);",
            "",
            "\t\tunlock_task_sighand(p, &flags);",
            "\t}",
            "",
            "out:",
            "\trcu_read_unlock();",
            "\tif (!ret)",
            "\t\tput_pid(ctmr->pid);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "posix_cpu_clock_get, posix_cpu_timer_create, trigger_base_recalc_expires, disarm_timer, posix_cpu_timer_del",
          "description": "实现CPU时间钟的读取操作、定时器创建及维护逻辑，包含定时器到期事件触发、过期时间重置、依赖关系注册等功能，确保定时器状态与系统时间同步。",
          "similarity": 0.6453043222427368
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/time/posix-cpu-timers.c",
          "start_line": 1434,
          "end_line": 1591,
          "content": [
            "void run_posix_cpu_timers(void)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\t/*",
            "\t * Ensure that release_task(tsk) can't happen while",
            "\t * handle_posix_cpu_timers() is running. Otherwise, a concurrent",
            "\t * posix_cpu_timer_del() may fail to lock_task_sighand(tsk) and",
            "\t * miss timer->it.cpu.firing != 0.",
            "\t */",
            "\tif (tsk->exit_state)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * If the actual expiry is deferred to task work context and the",
            "\t * work is already scheduled there is no point to do anything here.",
            "\t */",
            "\tif (posix_cpu_timers_work_scheduled(tsk))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * The fast path checks that there are no expired thread or thread",
            "\t * group timers.  If that's so, just return.",
            "\t */",
            "\tif (!fastpath_timer_check(tsk))",
            "\t\treturn;",
            "",
            "\t__run_posix_cpu_timers(tsk);",
            "}",
            "void set_process_cpu_timer(struct task_struct *tsk, unsigned int clkid,",
            "\t\t\t   u64 *newval, u64 *oldval)",
            "{",
            "\tu64 now, *nextevt;",
            "",
            "\tif (WARN_ON_ONCE(clkid >= CPUCLOCK_SCHED))",
            "\t\treturn;",
            "",
            "\tnextevt = &tsk->signal->posix_cputimers.bases[clkid].nextevt;",
            "\tnow = cpu_clock_sample_group(clkid, tsk, true);",
            "",
            "\tif (oldval) {",
            "\t\t/*",
            "\t\t * We are setting itimer. The *oldval is absolute and we update",
            "\t\t * it to be relative, *newval argument is relative and we update",
            "\t\t * it to be absolute.",
            "\t\t */",
            "\t\tif (*oldval) {",
            "\t\t\tif (*oldval <= now) {",
            "\t\t\t\t/* Just about to fire. */",
            "\t\t\t\t*oldval = TICK_NSEC;",
            "\t\t\t} else {",
            "\t\t\t\t*oldval -= now;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tif (*newval)",
            "\t\t\t*newval += now;",
            "\t}",
            "",
            "\t/*",
            "\t * Update expiration cache if this is the earliest timer. CPUCLOCK_PROF",
            "\t * expiry cache is also used by RLIMIT_CPU!.",
            "\t */",
            "\tif (*newval < *nextevt)",
            "\t\t*nextevt = *newval;",
            "",
            "\ttick_dep_set_signal(tsk, TICK_DEP_BIT_POSIX_TIMER);",
            "}",
            "static int do_cpu_nanosleep(const clockid_t which_clock, int flags,",
            "\t\t\t    const struct timespec64 *rqtp)",
            "{",
            "\tstruct itimerspec64 it;",
            "\tstruct k_itimer timer;",
            "\tu64 expires;",
            "\tint error;",
            "",
            "\t/*",
            "\t * Set up a temporary timer and then wait for it to go off.",
            "\t */",
            "\tmemset(&timer, 0, sizeof timer);",
            "\tspin_lock_init(&timer.it_lock);",
            "\ttimer.it_clock = which_clock;",
            "\ttimer.it_overrun = -1;",
            "\terror = posix_cpu_timer_create(&timer);",
            "\ttimer.it_process = current;",
            "",
            "\tif (!error) {",
            "\t\tstatic struct itimerspec64 zero_it;",
            "\t\tstruct restart_block *restart;",
            "",
            "\t\tmemset(&it, 0, sizeof(it));",
            "\t\tit.it_value = *rqtp;",
            "",
            "\t\tspin_lock_irq(&timer.it_lock);",
            "\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);",
            "\t\tif (error) {",
            "\t\t\tspin_unlock_irq(&timer.it_lock);",
            "\t\t\treturn error;",
            "\t\t}",
            "",
            "\t\twhile (!signal_pending(current)) {",
            "\t\t\tif (!cpu_timer_getexpires(&timer.it.cpu)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * Our timer fired and was reset, below",
            "\t\t\t\t * deletion can not fail.",
            "\t\t\t\t */",
            "\t\t\t\tposix_cpu_timer_del(&timer);",
            "\t\t\t\tspin_unlock_irq(&timer.it_lock);",
            "\t\t\t\treturn 0;",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.",
            "\t\t\t */",
            "\t\t\t__set_current_state(TASK_INTERRUPTIBLE);",
            "\t\t\tspin_unlock_irq(&timer.it_lock);",
            "\t\t\tschedule();",
            "\t\t\tspin_lock_irq(&timer.it_lock);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * We were interrupted by a signal.",
            "\t\t */",
            "\t\texpires = cpu_timer_getexpires(&timer.it.cpu);",
            "\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);",
            "\t\tif (!error) {",
            "\t\t\t/* Timer is now unarmed, deletion can not fail. */",
            "\t\t\tposix_cpu_timer_del(&timer);",
            "\t\t} else {",
            "\t\t\twhile (error == TIMER_RETRY) {",
            "\t\t\t\tposix_cpu_timer_wait_running_nsleep(&timer);",
            "\t\t\t\terror = posix_cpu_timer_del(&timer);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tspin_unlock_irq(&timer.it_lock);",
            "",
            "\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {",
            "\t\t\t/*",
            "\t\t\t * It actually did fire already.",
            "\t\t\t */",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\terror = -ERESTART_RESTARTBLOCK;",
            "\t\t/*",
            "\t\t * Report back to the user the time still remaining.",
            "\t\t */",
            "\t\trestart = &current->restart_block;",
            "\t\trestart->nanosleep.expires = expires;",
            "\t\tif (restart->nanosleep.type != TT_NONE)",
            "\t\t\terror = nanosleep_copyout(restart, &it.it_value);",
            "\t}",
            "",
            "\treturn error;",
            "}"
          ],
          "function_name": "run_posix_cpu_timers, set_process_cpu_timer, do_cpu_nanosleep",
          "description": "实现CPU纳秒休眠接口，通过临时定时器机制完成精确延时，包含定时器创建、设置、删除及异常处理逻辑，支持信号中断返回和剩余时间查询功能",
          "similarity": 0.6422216892242432
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/time/posix-cpu-timers.c",
          "start_line": 1232,
          "end_line": 1411,
          "content": [
            "void __init posix_cputimers_init_work(void)",
            "{",
            "\tclear_posix_cputimers_work(current);",
            "}",
            "static inline bool posix_cpu_timers_work_scheduled(struct task_struct *tsk)",
            "{",
            "\treturn tsk->posix_cputimers_work.scheduled;",
            "}",
            "static inline void __run_posix_cpu_timers(struct task_struct *tsk)",
            "{",
            "\tif (WARN_ON_ONCE(tsk->posix_cputimers_work.scheduled))",
            "\t\treturn;",
            "",
            "\t/* Schedule task work to actually expire the timers */",
            "\ttsk->posix_cputimers_work.scheduled = true;",
            "\ttask_work_add(tsk, &tsk->posix_cputimers_work.work, TWA_RESUME);",
            "}",
            "static inline bool posix_cpu_timers_enable_work(struct task_struct *tsk,",
            "\t\t\t\t\t\tunsigned long start)",
            "{",
            "\tbool ret = true;",
            "",
            "\t/*",
            "\t * On !RT kernels interrupts are disabled while collecting expired",
            "\t * timers, so no tick can happen and the fast path check can be",
            "\t * reenabled without further checks.",
            "\t */",
            "\tif (!IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\ttsk->posix_cputimers_work.scheduled = false;",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * On RT enabled kernels ticks can happen while the expired timers",
            "\t * are collected under sighand lock. But any tick which observes",
            "\t * the CPUTIMERS_WORK_SCHEDULED bit set, does not run the fastpath",
            "\t * checks. So reenabling the tick work has do be done carefully:",
            "\t *",
            "\t * Disable interrupts and run the fast path check if jiffies have",
            "\t * advanced since the collecting of expired timers started. If",
            "\t * jiffies have not advanced or the fast path check did not find",
            "\t * newly expired timers, reenable the fast path check in the timer",
            "\t * interrupt. If there are newly expired timers, return false and",
            "\t * let the collection loop repeat.",
            "\t */",
            "\tlocal_irq_disable();",
            "\tif (start != jiffies && fastpath_timer_check(tsk))",
            "\t\tret = false;",
            "\telse",
            "\t\ttsk->posix_cputimers_work.scheduled = false;",
            "\tlocal_irq_enable();",
            "",
            "\treturn ret;",
            "}",
            "static inline void __run_posix_cpu_timers(struct task_struct *tsk)",
            "{",
            "\tlockdep_posixtimer_enter();",
            "\thandle_posix_cpu_timers(tsk);",
            "\tlockdep_posixtimer_exit();",
            "}",
            "static void posix_cpu_timer_wait_running(struct k_itimer *timr)",
            "{",
            "\tcpu_relax();",
            "}",
            "static void posix_cpu_timer_wait_running_nsleep(struct k_itimer *timr)",
            "{",
            "\tspin_unlock_irq(&timr->it_lock);",
            "\tcpu_relax();",
            "\tspin_lock_irq(&timr->it_lock);",
            "}",
            "static inline bool posix_cpu_timers_work_scheduled(struct task_struct *tsk)",
            "{",
            "\treturn false;",
            "}",
            "static inline bool posix_cpu_timers_enable_work(struct task_struct *tsk,",
            "\t\t\t\t\t\tunsigned long start)",
            "{",
            "\treturn true;",
            "}",
            "static void handle_posix_cpu_timers(struct task_struct *tsk)",
            "{",
            "\tstruct k_itimer *timer, *next;",
            "\tunsigned long flags, start;",
            "\tLIST_HEAD(firing);",
            "",
            "\tif (!lock_task_sighand(tsk, &flags))",
            "\t\treturn;",
            "",
            "\tdo {",
            "\t\t/*",
            "\t\t * On RT locking sighand lock does not disable interrupts,",
            "\t\t * so this needs to be careful vs. ticks. Store the current",
            "\t\t * jiffies value.",
            "\t\t */",
            "\t\tstart = READ_ONCE(jiffies);",
            "\t\tbarrier();",
            "",
            "\t\t/*",
            "\t\t * Here we take off tsk->signal->cpu_timers[N] and",
            "\t\t * tsk->cpu_timers[N] all the timers that are firing, and",
            "\t\t * put them on the firing list.",
            "\t\t */",
            "\t\tcheck_thread_timers(tsk, &firing);",
            "",
            "\t\tcheck_process_timers(tsk, &firing);",
            "",
            "\t\t/*",
            "\t\t * The above timer checks have updated the expiry cache and",
            "\t\t * because nothing can have queued or modified timers after",
            "\t\t * sighand lock was taken above it is guaranteed to be",
            "\t\t * consistent. So the next timer interrupt fastpath check",
            "\t\t * will find valid data.",
            "\t\t *",
            "\t\t * If timer expiry runs in the timer interrupt context then",
            "\t\t * the loop is not relevant as timers will be directly",
            "\t\t * expired in interrupt context. The stub function below",
            "\t\t * returns always true which allows the compiler to",
            "\t\t * optimize the loop out.",
            "\t\t *",
            "\t\t * If timer expiry is deferred to task work context then",
            "\t\t * the following rules apply:",
            "\t\t *",
            "\t\t * - On !RT kernels no tick can have happened on this CPU",
            "\t\t *   after sighand lock was acquired because interrupts are",
            "\t\t *   disabled. So reenabling task work before dropping",
            "\t\t *   sighand lock and reenabling interrupts is race free.",
            "\t\t *",
            "\t\t * - On RT kernels ticks might have happened but the tick",
            "\t\t *   work ignored posix CPU timer handling because the",
            "\t\t *   CPUTIMERS_WORK_SCHEDULED bit is set. Reenabling work",
            "\t\t *   must be done very carefully including a check whether",
            "\t\t *   ticks have happened since the start of the timer",
            "\t\t *   expiry checks. posix_cpu_timers_enable_work() takes",
            "\t\t *   care of that and eventually lets the expiry checks",
            "\t\t *   run again.",
            "\t\t */",
            "\t} while (!posix_cpu_timers_enable_work(tsk, start));",
            "",
            "\t/*",
            "\t * We must release sighand lock before taking any timer's lock.",
            "\t * There is a potential race with timer deletion here, as the",
            "\t * siglock now protects our private firing list.  We have set",
            "\t * the firing flag in each timer, so that a deletion attempt",
            "\t * that gets the timer lock before we do will give it up and",
            "\t * spin until we've taken care of that timer below.",
            "\t */",
            "\tunlock_task_sighand(tsk, &flags);",
            "",
            "\t/*",
            "\t * Now that all the timers on our list have the firing flag,",
            "\t * no one will touch their list entries but us.  We'll take",
            "\t * each timer's lock before clearing its firing flag, so no",
            "\t * timer call will interfere.",
            "\t */",
            "\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {",
            "\t\tint cpu_firing;",
            "",
            "\t\t/*",
            "\t\t * spin_lock() is sufficient here even independent of the",
            "\t\t * expiry context. If expiry happens in hard interrupt",
            "\t\t * context it's obvious. For task work context it's safe",
            "\t\t * because all other operations on timer::it_lock happen in",
            "\t\t * task context (syscall or exit).",
            "\t\t */",
            "\t\tspin_lock(&timer->it_lock);",
            "\t\tlist_del_init(&timer->it.cpu.elist);",
            "\t\tcpu_firing = timer->it.cpu.firing;",
            "\t\ttimer->it.cpu.firing = 0;",
            "\t\t/*",
            "\t\t * The firing flag is -1 if we collided with a reset",
            "\t\t * of the timer, which already reported this",
            "\t\t * almost-firing as an overrun.  So don't generate an event.",
            "\t\t */",
            "\t\tif (likely(cpu_firing >= 0))",
            "\t\t\tcpu_timer_fire(timer);",
            "\t\t/* See posix_cpu_timer_wait_running() */",
            "\t\trcu_assign_pointer(timer->it.cpu.handling, NULL);",
            "\t\tspin_unlock(&timer->it_lock);",
            "\t}",
            "}"
          ],
          "function_name": "posix_cputimers_init_work, posix_cpu_timers_work_scheduled, __run_posix_cpu_timers, posix_cpu_timers_enable_work, __run_posix_cpu_timers, posix_cpu_timer_wait_running, posix_cpu_timer_wait_running_nsleep, posix_cpu_timers_work_scheduled, posix_cpu_timers_enable_work, handle_posix_cpu_timers",
          "description": "管理POSIX定时器工作队列的初始化和调度逻辑，包含工作状态标志位控制、中断上下文安全处理以及实际的定时器处理函数实现，协调锁保护和状态同步",
          "similarity": 0.6341842412948608
        }
      ]
    },
    {
      "source_file": "kernel/time/tick-legacy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:50:39\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\tick-legacy.c`\n\n---\n\n# `time/tick-legacy.c` 技术文档\n\n## 1. 文件概述\n\n`tick-legacy.c` 是 Linux 内核中用于处理传统定时器中断的实现文件，专为尚未迁移到通用时钟事件（generic clockevents）框架的架构提供支持。该文件将原本分散在 m68k、ia64、parisc 和 ARM 等架构中的重复代码统一整合，实现了统一的遗留定时器滴答（legacy timer tick）处理逻辑，用于推进内核的时间管理基础设施。\n\n## 2. 核心功能\n\n- **函数**：\n  - `legacy_timer_tick(unsigned long ticks)`：核心函数，用于处理定时器中断并更新系统时间与进程统计信息。\n\n- **数据结构**（间接使用）：\n  - `jiffies_lock`：保护 jiffies 全局变量的原始自旋锁。\n  - `jiffies_seq`：用于 jiffies 更新的顺序计数器（seqcount），支持无锁读取。\n  - `irq_regs`：中断上下文中的寄存器状态，用于判断当前是否处于用户模式。\n\n## 3. 关键实现\n\n- **时间推进机制**：\n  - 当 `ticks > 0` 时，表示当前 CPU 负责系统时间维护。函数会：\n    1. 获取 `jiffies_lock` 自旋锁以保护全局 jiffies 计数器；\n    2. 使用 `write_seqcount_begin/end()` 包裹 `do_timer(ticks)` 调用，确保 jiffies 更新的原子性和一致性；\n    3. 调用 `update_wall_time()` 更新墙上时间（wall time），即实际日历时间。\n\n- **进程与性能统计**：\n  - 无论 `ticks` 是否为零，都会调用：\n    - `update_process_times()`：根据当前是否处于用户模式（通过 `user_mode(get_irq_regs())` 判断），更新进程的 CPU 时间统计（如用户态/内核态时间）；\n    - `profile_tick(CPU_PROFILING)`：触发 CPU 性能剖析（profiling）事件，用于性能分析工具（如 oprofile）。\n\n- **中断上下文要求**：\n  - 函数必须在**中断关闭**的上下文中调用，以避免竞态条件，确保时间更新的正确性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`：提供中断相关函数，如 `get_irq_regs()`。\n  - `<linux/profile.h>`：提供 `profile_tick()` 函数声明。\n  - `<linux/timekeeper_internal.h>`：提供 `update_wall_time()` 等时间管理内部接口。\n  - `\"tick-internal.h\"`：包含 tick 子系统的内部定义，如 `do_timer()`。\n\n- **内核子系统依赖**：\n  - **时间子系统（Timekeeping）**：依赖 `do_timer()` 和 `update_wall_time()` 推进系统时间。\n  - **进程调度与统计**：通过 `update_process_times()` 更新进程时间片和 CPU 使用统计。\n  - **性能剖析子系统**：通过 `profile_tick()` 支持 CPU 级性能采样。\n\n## 5. 使用场景\n\n- **遗留架构支持**：用于尚未实现 generic clockevents 框架的旧架构（如部分 m68k、IA-64、PA-RISC 或早期 ARM 平台），作为其主定时器中断处理函数。\n- **单定时器系统**：在仅有一个周期性定时器中断源的系统中，由该中断处理程序定期调用 `legacy_timer_tick()`。\n- **非高精度定时器环境**：适用于不需要高分辨率定时器（hrtimers）或动态滴答（NO_HZ）特性的传统系统。\n- **引导或降级模式**：在某些架构的引导阶段或 clockevents 初始化失败时，可能回退到此遗留模式以维持基本时间功能。",
      "similarity": 0.6218742728233337,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/tick-legacy.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Timer tick function for architectures that lack generic clockevents,",
            " * consolidated here from m68k/ia64/parisc/arm.",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/profile.h>",
            "#include <linux/timekeeper_internal.h>",
            "",
            "#include \"tick-internal.h\"",
            "",
            "/**",
            " * legacy_timer_tick() - advances the timekeeping infrastructure",
            " * @ticks:\tnumber of ticks, that have elapsed since the last call.",
            " *",
            " * This is used by platforms that have not been converted to",
            " * generic clockevents.",
            " *",
            " * If 'ticks' is zero, the CPU is not handling timekeeping, so",
            " * only perform process accounting and profiling.",
            " *",
            " * Must be called with interrupts disabled.",
            " */"
          ],
          "function_name": null,
          "description": "定义legacy_timer_tick函数，用于传统架构的时间中断处理，推进时间保持基础设施，根据ticks值决定是否更新系统时间及执行过程计账与性能分析，需在中断禁止状态下调用",
          "similarity": 0.6146847009658813
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/tick-legacy.c",
          "start_line": 25,
          "end_line": 37,
          "content": [
            "void legacy_timer_tick(unsigned long ticks)",
            "{",
            "\tif (ticks) {",
            "\t\traw_spin_lock(&jiffies_lock);",
            "\t\twrite_seqcount_begin(&jiffies_seq);",
            "\t\tdo_timer(ticks);",
            "\t\twrite_seqcount_end(&jiffies_seq);",
            "\t\traw_spin_unlock(&jiffies_lock);",
            "\t\tupdate_wall_time();",
            "\t}",
            "\tupdate_process_times(user_mode(get_irq_regs()));",
            "\tprofile_tick(CPU_PROFILING);",
            "}"
          ],
          "function_name": "legacy_timer_tick",
          "description": "实现legacy_timer_tick函数，通过锁保护更新jiffies并调用do_timer处理时间增量，后续更新墙上时间及进程统计信息，无论ticks是否为零均执行过程时间更新与性能计数器递增",
          "similarity": 0.5984691381454468
        }
      ]
    }
  ]
}