{
  "query": "访问控制决策日志记录方法",
  "timestamp": "2025-12-26 01:35:11",
  "retrieved_files": [
    {
      "source_file": "kernel/entry/common.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:19:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\common.c`\n\n---\n\n# entry\\common.c 技术文档\n\n## 文件概述\n\n`entry\\common.c` 是 Linux 内核中处理系统调用入口/出口以及中断入口/出口路径的通用逻辑实现文件。该文件提供了一套架构无关的通用函数，用于在用户态与内核态之间切换时执行必要的上下文跟踪、审计、跟踪点、安全检查（如 seccomp）、信号处理、调度等工作。其目标是统一不同架构在系统调用和中断处理路径上的共性逻辑，减少重复代码。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `syscall_trace_enter()` | 系统调用进入时的通用处理函数，依次处理用户态分发、ptrace 跟踪、seccomp 安全检查、tracepoint 和审计 |\n| `syscall_enter_from_user_mode_prepare()` | 从用户模式进入系统调用前的准备，启用中断并进入内核上下文 |\n| `exit_to_user_mode_loop()` | 在返回用户空间前循环处理所有待办工作项（如调度、信号、uprobe、livepatch 等） |\n| `syscall_exit_work()` | 系统调用退出时的通用处理，包括审计、tracepoint、ptrace 退出报告等 |\n| `irqentry_enter()` / `irqentry_exit()` | 中断入口/出口的通用处理，管理 RCU、上下文跟踪、KMSAN、lockdep 等 |\n| `irqentry_enter_from_user_mode()` / `irqentry_exit_to_user_mode()` | 从中断上下文进入/退出用户模式的专用路径 |\n| `raw_irqentry_exit_cond_resched()` | 中断退出时的条件调度检查（仅在非抢占计数为 0 时） |\n\n### 关键数据结构\n\n- `irqentry_state_t`：记录中断入口状态，主要用于判断是否需要在退出时执行 RCU 相关操作。\n- `SYSCALL_WORK_*` 和 `_TIF_*` 标志位：用于标识待处理的工作类型（如 trace、seccomp、信号、调度等）。\n\n## 关键实现\n\n### 系统调用入口处理流程（`syscall_trace_enter`）\n\n1. **Syscall User Dispatch 优先处理**：若设置了 `SYSCALL_WORK_SYSCALL_USER_DISPATCH`，调用 `syscall_user_dispatch()`，若返回 true 则直接终止系统调用（返回 `-1`），因为此时 ABI 可能无效。\n2. **Ptrace 跟踪**：若设置了 `SYSCALL_WORK_SYSCALL_TRACE` 或 `SYSCALL_WORK_SYSCALL_EMU`，调用 `ptrace_report_syscall_entry()`。若 tracer 修改了行为或启用了 `SYSCALL_EMU`，则终止系统调用。\n3. **Seccomp 安全检查**：在 ptrace 之后执行，以捕获 tracer 可能引入的变更。调用 `__secure_computing()`，若返回 `-1` 则拒绝系统调用。\n4. **重新获取系统调用号**：上述步骤可能修改了系统调用号，需重新通过 `syscall_get_nr()` 获取。\n5. **Tracepoint 触发**：若启用 `SYSCALL_WORK_SYSCALL_TRACEPOINT`，触发 `trace_sys_enter`，并再次重新获取系统调用号（因 BPF 或 kprobe 可能修改）。\n6. **审计日志**：调用 `syscall_enter_audit()` 记录审计事件。\n7. **返回最终系统调用号或错误码**。\n\n### 返回用户空间前的工作循环（`exit_to_user_mode_loop`）\n\n- 使用 `while (ti_work & EXIT_TO_USER_MODE_WORK)` 循环处理所有待办工作，确保在返回用户态前完成：\n  - 调度（`_TIF_NEED_RESCHED`）\n  - Uprobe 通知（`_TIF_UPROBE`）\n  - Livepatch 状态更新（`_TIF_PATCH_PENDING`）\n  - 信号处理（`_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL`）\n  - 用户态恢复工作（`_TIF_NOTIFY_RESUME`）\n  - 架构特定工作（`arch_exit_to_user_mode_work`）\n- 每次循环启用中断（`local_irq_enable_exit_to_user`），处理完后再关闭中断并重新读取线程标志（`read_thread_flags()`），以应对处理过程中新产生的工作项。\n- 最后调用 `tick_nohz_user_enter_prepare()` 处理 NO_HZ 模式下的 tick 准备。\n\n### 中断入口/出口的 RCU 与上下文管理\n\n- **从中断进入用户态**：调用 `enter_from_user_mode()`，启用中断。\n- **从内核态中断入口**：\n  - 若当前是 idle 任务且非 `TINY_RCU`，无条件调用 `ct_irq_enter()` 以确保 RCU 状态一致（避免嵌套中断导致 grace period 错误结束）。\n  - 否则调用 `rcu_irq_enter_check_tick()`。\n- 所有路径均正确处理 `lockdep`、`KMSAN`（解除寄存器毒化）和 `trace_hardirqs_off` 的顺序，确保调试和安全工具正常工作。\n\n### 条件调度支持（Preemption）\n\n- `raw_irqentry_exit_cond_resched()` 在中断退出且 `preempt_count() == 0` 时检查是否需要调度。\n- 支持动态抢占（`CONFIG_PREEMPT_DYNAMIC`），通过 `static_call` 或 `static_key` 实现运行时切换，避免编译时硬编码。\n\n## 依赖关系\n\n### 头文件依赖\n- `<linux/context_tracking.h>`：上下文跟踪（用户/内核态切换）\n- `<linux/resume_user_mode.h>`：用户态恢复工作\n- `<linux/seccomp.h>`（隐式通过 `__secure_computing`）：系统调用过滤\n- `<linux/audit.h>`：审计子系统\n- `<linux/ptrace.h>`（隐式）：ptrace 跟踪\n- `<linux/livepatch.h>`：内核热补丁\n- `<linux/uprobes.h>`（隐式）：用户态探针\n- `<linux/rcupdate.h>`：RCU 机制\n- `<linux/kmsan.h>`：Kernel Memory Sanitizer 支持\n- `<trace/events/syscalls.h>`：系统调用跟踪点\n\n### 架构依赖\n- 依赖架构特定实现：\n  - `syscall_get_arguments()` / `syscall_get_nr()` / `syscall_get_return_value()`\n  - `user_mode()` / `regs_irqs_disabled()`\n  - `arch_do_signal_or_restart()`（弱符号，默认空实现）\n  - `arch_exit_to_user_mode_work()`\n\n### 子系统交互\n- **RCU**：管理中断和用户态切换时的宽限期\n- **Scheduler**：处理 `need_resched()` 和 `schedule()`\n- **Security**：seccomp、audit\n- **Tracing**：ftrace、kprobe、uprobe、BPF\n- **Livepatch**：动态补丁状态更新\n\n## 使用场景\n\n1. **系统调用入口路径**：  \n   当用户程序执行 `syscall` 指令（或其他系统调用机制）进入内核时，架构代码调用 `syscall_trace_enter()` 执行通用预处理。\n\n2. **系统调用出口路径**：  \n   系统调用返回前，若存在待处理工作（如审计、tracepoint），调用 `syscall_exit_work()`。\n\n3. **中断处理返回用户空间**：  \n   中断处理完成后，若返回用户态，调用 `irqentry_exit_to_user_mode()`，进而触发 `exit_to_user_mode_loop()` 处理所有 pending work。\n\n4. **中断嵌套与 idle 任务处理**：  \n   在 idle 任务中发生中断时，确保 RCU 正确进入 IRQ 上下文，防止 grace period 错误终止。\n\n5. **动态抢占支持**：  \n   在支持动态抢占的系统中，中断退出时根据运行时配置决定是否执行条件调度。\n\n6. **调试与安全工具集成**：  \n   为 KMSAN、Lockdep、ftrace、audit、seccomp 等子系统提供统一的入口/出口钩子，确保工具链在系统调用和中断路径上正常工作。",
      "similarity": 0.5668722987174988,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/common.c",
          "start_line": 18,
          "end_line": 124,
          "content": [
            "static inline void syscall_enter_audit(struct pt_regs *regs, long syscall)",
            "{",
            "\tif (unlikely(audit_context())) {",
            "\t\tunsigned long args[6];",
            "",
            "\t\tsyscall_get_arguments(current, regs, args);",
            "\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);",
            "\t}",
            "}",
            "long syscall_trace_enter(struct pt_regs *regs, long syscall,",
            "\t\t\t\tunsigned long work)",
            "{",
            "\tlong ret = 0;",
            "",
            "\t/*",
            "\t * Handle Syscall User Dispatch.  This must comes first, since",
            "\t * the ABI here can be something that doesn't make sense for",
            "\t * other syscall_work features.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (syscall_user_dispatch(regs))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Handle ptrace */",
            "\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {",
            "\t\tret = ptrace_report_syscall_entry(regs);",
            "\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Do seccomp after ptrace, to catch any tracer changes. */",
            "\tif (work & SYSCALL_WORK_SECCOMP) {",
            "\t\tret = __secure_computing(NULL);",
            "\t\tif (ret == -1L)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/* Either of the above might have changed the syscall number */",
            "\tsyscall = syscall_get_nr(current, regs);",
            "",
            "\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT)) {",
            "\t\ttrace_sys_enter(regs, syscall);",
            "\t\t/*",
            "\t\t * Probes or BPF hooks in the tracepoint may have changed the",
            "\t\t * system call number as well.",
            "\t\t */",
            "\t\tsyscall = syscall_get_nr(current, regs);",
            "\t}",
            "",
            "\tsyscall_enter_audit(regs, syscall);",
            "",
            "\treturn ret ? : syscall;",
            "}",
            "noinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "\tinstrumentation_begin();",
            "\tlocal_irq_enable();",
            "\tinstrumentation_end();",
            "}",
            "void __weak arch_do_signal_or_restart(struct pt_regs *regs) { }",
            "__always_inline unsigned long exit_to_user_mode_loop(struct pt_regs *regs,",
            "\t\t\t\t\t\t     unsigned long ti_work)",
            "{",
            "\t/*",
            "\t * Before returning to user space ensure that all pending work",
            "\t * items have been completed.",
            "\t */",
            "\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {",
            "",
            "\t\tlocal_irq_enable_exit_to_user(ti_work);",
            "",
            "\t\tif (ti_work & _TIF_NEED_RESCHED)",
            "\t\t\tschedule();",
            "",
            "\t\tif (ti_work & _TIF_UPROBE)",
            "\t\t\tuprobe_notify_resume(regs);",
            "",
            "\t\tif (ti_work & _TIF_PATCH_PENDING)",
            "\t\t\tklp_update_patch_state(current);",
            "",
            "\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))",
            "\t\t\tarch_do_signal_or_restart(regs);",
            "",
            "\t\tif (ti_work & _TIF_NOTIFY_RESUME)",
            "\t\t\tresume_user_mode_work(regs);",
            "",
            "\t\t/* Architecture specific TIF work */",
            "\t\tarch_exit_to_user_mode_work(regs, ti_work);",
            "",
            "\t\t/*",
            "\t\t * Disable interrupts and reevaluate the work flags as they",
            "\t\t * might have changed while interrupts and preemption was",
            "\t\t * enabled above.",
            "\t\t */",
            "\t\tlocal_irq_disable_exit_to_user();",
            "",
            "\t\t/* Check if any of the above work has queued a deferred wakeup */",
            "\t\ttick_nohz_user_enter_prepare();",
            "",
            "\t\tti_work = read_thread_flags();",
            "\t}",
            "",
            "\t/* Return the latest work state for arch_exit_to_user_mode() */",
            "\treturn ti_work;",
            "}"
          ],
          "function_name": "syscall_enter_audit, syscall_trace_enter, syscall_enter_from_user_mode_prepare, arch_do_signal_or_restart, exit_to_user_mode_loop",
          "description": "实现系统调用入口处理逻辑，依次处理审计追踪、指针观察、seccomp过滤及架构特定工作，通过位掩码控制不同安全机制的触发顺序并更新系统调用号",
          "similarity": 0.5846129059791565
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/common.c",
          "start_line": 141,
          "end_line": 250,
          "content": [
            "static inline bool report_single_step(unsigned long work)",
            "{",
            "\tif (work & SYSCALL_WORK_SYSCALL_EMU)",
            "\t\treturn false;",
            "",
            "\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;",
            "}",
            "void syscall_exit_work(struct pt_regs *regs, unsigned long work)",
            "{",
            "\tbool step;",
            "",
            "\t/*",
            "\t * If the syscall was rolled back due to syscall user dispatching,",
            "\t * then the tracers below are not invoked for the same reason as",
            "\t * the entry side was not invoked in syscall_trace_enter(): The ABI",
            "\t * of these syscalls is unknown.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {",
            "\t\t\tcurrent->syscall_dispatch.on_dispatch = false;",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\taudit_syscall_exit(regs);",
            "",
            "\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)",
            "\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));",
            "",
            "\tstep = report_single_step(work);",
            "\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)",
            "\t\tptrace_report_syscall_exit(regs, step);",
            "}",
            "noinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "}",
            "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)",
            "{",
            "\tinstrumentation_begin();",
            "\texit_to_user_mode_prepare(regs);",
            "\tinstrumentation_end();",
            "\texit_to_user_mode();",
            "}",
            "noinstr irqentry_state_t irqentry_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t ret = {",
            "\t\t.exit_rcu = false,",
            "\t};",
            "",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_enter_from_user_mode(regs);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If this entry hit the idle task invoke ct_irq_enter() whether",
            "\t * RCU is watching or not.",
            "\t *",
            "\t * Interrupts can nest when the first interrupt invokes softirq",
            "\t * processing on return which enables interrupts.",
            "\t *",
            "\t * Scheduler ticks in the idle task can mark quiescent state and",
            "\t * terminate a grace period, if and only if the timer interrupt is",
            "\t * not nested into another interrupt.",
            "\t *",
            "\t * Checking for rcu_is_watching() here would prevent the nesting",
            "\t * interrupt to invoke ct_irq_enter(). If that nested interrupt is",
            "\t * the tick then rcu_flavor_sched_clock_irq() would wrongfully",
            "\t * assume that it is the first interrupt and eventually claim",
            "\t * quiescent state and end grace periods prematurely.",
            "\t *",
            "\t * Unconditionally invoke ct_irq_enter() so RCU state stays",
            "\t * consistent.",
            "\t *",
            "\t * TINY_RCU does not support EQS, so let the compiler eliminate",
            "\t * this part when enabled.",
            "\t */",
            "\tif (!IS_ENABLED(CONFIG_TINY_RCU) && is_idle_task(current)) {",
            "\t\t/*",
            "\t\t * If RCU is not watching then the same careful",
            "\t\t * sequence vs. lockdep and tracing is required",
            "\t\t * as in irqentry_enter_from_user_mode().",
            "\t\t */",
            "\t\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\t\tct_irq_enter();",
            "\t\tinstrumentation_begin();",
            "\t\tkmsan_unpoison_entry_regs(regs);",
            "\t\ttrace_hardirqs_off_finish();",
            "\t\tinstrumentation_end();",
            "",
            "\t\tret.exit_rcu = true;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If RCU is watching then RCU only wants to check whether it needs",
            "\t * to restart the tick in NOHZ mode. rcu_irq_enter_check_tick()",
            "\t * already contains a warning when RCU is not watching, so no point",
            "\t * in having another one here.",
            "\t */",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\trcu_irq_enter_check_tick();",
            "\ttrace_hardirqs_off_finish();",
            "\tinstrumentation_end();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "report_single_step, syscall_exit_work, irqentry_enter_from_user_mode, irqentry_exit_to_user_mode, irqentry_enter",
          "description": "处理系统调用退出阶段工作，包括审计退出记录、单步调试报告和跟踪点事件，同时管理中断返回时的RCU状态转换和锁依赖检查",
          "similarity": 0.5495883226394653
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/entry/common.c",
          "start_line": 256,
          "end_line": 347,
          "content": [
            "void raw_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!preempt_count()) {",
            "\t\t/* Sanity check RCU and thread stack */",
            "\t\trcu_irq_exit_check_preempt();",
            "\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))",
            "\t\t\tWARN_ON_ONCE(!on_thread_stack());",
            "\t\tif (need_resched())",
            "\t\t\tpreempt_schedule_irq();",
            "\t}",
            "}",
            "void dynamic_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!static_branch_unlikely(&sk_dynamic_irqentry_exit_cond_resched))",
            "\t\treturn;",
            "\traw_irqentry_exit_cond_resched();",
            "}",
            "noinstr void irqentry_exit(struct pt_regs *regs, irqentry_state_t state)",
            "{",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\t/* Check whether this returns to user mode */",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_exit_to_user_mode(regs);",
            "\t} else if (!regs_irqs_disabled(regs)) {",
            "\t\t/*",
            "\t\t * If RCU was not watching on entry this needs to be done",
            "\t\t * carefully and needs the same ordering of lockdep/tracing",
            "\t\t * and RCU as the return to user mode path.",
            "\t\t */",
            "\t\tif (state.exit_rcu) {",
            "\t\t\tinstrumentation_begin();",
            "\t\t\t/* Tell the tracer that IRET will enable interrupts */",
            "\t\t\ttrace_hardirqs_on_prepare();",
            "\t\t\tlockdep_hardirqs_on_prepare();",
            "\t\t\tinstrumentation_end();",
            "\t\t\tct_irq_exit();",
            "\t\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tinstrumentation_begin();",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPTION))",
            "\t\t\tirqentry_exit_cond_resched();",
            "",
            "\t\t/* Covers both tracing and lockdep */",
            "\t\ttrace_hardirqs_on();",
            "\t\tinstrumentation_end();",
            "\t} else {",
            "\t\t/*",
            "\t\t * IRQ flags state is correct already. Just tell RCU if it",
            "\t\t * was not watching on entry.",
            "\t\t */",
            "\t\tif (state.exit_rcu)",
            "\t\t\tct_irq_exit();",
            "\t}",
            "}",
            "irqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t irq_state;",
            "",
            "\tirq_state.lockdep = lockdep_hardirqs_enabled();",
            "",
            "\t__nmi_enter();",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tlockdep_hardirq_enter();",
            "\tct_nmi_enter();",
            "",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\ttrace_hardirqs_off_finish();",
            "\tftrace_nmi_enter();",
            "\tinstrumentation_end();",
            "",
            "\treturn irq_state;",
            "}",
            "void noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state)",
            "{",
            "\tinstrumentation_begin();",
            "\tftrace_nmi_exit();",
            "\tif (irq_state.lockdep) {",
            "\t\ttrace_hardirqs_on_prepare();",
            "\t\tlockdep_hardirqs_on_prepare();",
            "\t}",
            "\tinstrumentation_end();",
            "",
            "\tct_nmi_exit();",
            "\tlockdep_hardirq_exit();",
            "\tif (irq_state.lockdep)",
            "\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t__nmi_exit();",
            "}"
          ],
          "function_name": "raw_irqentry_exit_cond_resched, dynamic_irqentry_exit_cond_resched, irqentry_exit, irqentry_nmi_enter, irqentry_nmi_exit",
          "description": "实现中断退出路径的条件调度检查和NMI上下文切换，维护中断标志状态一致性，处理RCU状态转换、锁依赖标记恢复及异常中断返回时的上下文还原",
          "similarity": 0.5230525732040405
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/common.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/context_tracking.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/highmem.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmsan.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/audit.h>",
            "#include <linux/tick.h>",
            "",
            "#include \"common.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/syscalls.h>",
            ""
          ],
          "function_name": null,
          "description": "声明系统调用通用功能所需头文件，包含审计、跟踪、KMSAN、LivePatch等模块的接口定义，为后续系统调用入口处理提供基础依赖",
          "similarity": 0.49334725737571716
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_sched_switch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:35:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_sched_switch.c`\n\n---\n\n# trace_sched_switch.c 技术文档\n\n## 1. 文件概述\n\n`trace_sched_switch.c` 是 Linux 内核 ftrace 框架中的一个核心组件，用于在任务调度上下文切换（context switch）和任务唤醒（wakeup）事件发生时，记录相关任务的辅助信息（如命令行名称和线程组 ID）。该文件通过注册到内核调度器的 tracepoint（`sched_switch`、`sched_wakeup` 和 `sched_wakeup_new`），在调度事件触发时动态捕获并缓存任务元数据，供后续跟踪系统（如 latency tracing、function tracer 等）使用。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `probe_sched_switch()`：`sched_switch` tracepoint 的回调函数，在任务切换时被调用。\n- `probe_sched_wakeup()`：`sched_wakeup` 和 `sched_wakeup_new` tracepoint 的回调函数，在任务被唤醒时被调用。\n- `tracing_sched_register()`：注册所有相关的调度 tracepoint 探针。\n- `tracing_sched_unregister()`：注销所有已注册的调度 tracepoint 探针。\n- `tracing_start_sched_switch()` / `tracing_stop_sched_switch()`：内部辅助函数，用于根据引用计数控制探针的启用/禁用。\n- `tracing_start_cmdline_record()` / `tracing_stop_cmdline_record()`：对外接口，用于启用/禁用命令行名称记录。\n- `tracing_start_tgid_record()` / `tracing_stop_tgid_record()`：对外接口，用于启用/禁用线程组 ID（TGID）记录。\n\n### 关键数据结构与变量\n\n- `sched_cmdline_ref`：记录请求启用命令行记录的引用计数。\n- `sched_tgid_ref`：记录请求启用 TGID 记录的引用计数。\n- `sched_register_mutex`：互斥锁，保护引用计数和探针注册状态的并发访问。\n- `RECORD_CMDLINE` / `RECORD_TGID`：标志位，分别表示是否需要记录命令行和 TGID。\n\n## 3. 关键实现\n\n- **引用计数机制**：通过 `sched_cmdline_ref` 和 `sched_tgid_ref` 两个引用计数变量，允许多个跟踪子系统（如 latency tracer、wakeup tracer 等）独立请求记录任务信息，避免重复注册或过早注销探针。\n  \n- **动态探针注册**：仅当至少有一个记录请求（命令行或 TGID）存在时，才调用 `tracing_sched_register()` 注册 tracepoint 探针；当所有请求都被释放后，自动注销探针以减少运行时开销。\n\n- **统一任务信息记录接口**：两个探针函数（`probe_sched_switch` 和 `probe_sched_wakeup`）均调用 `tracing_record_taskinfo_sched_switch()`，传入当前任务和目标任务以及记录标志，由底层统一处理任务元数据的缓存。\n\n- **错误回滚机制**：在 `tracing_sched_register()` 中，若任一 tracepoint 注册失败，则按顺序回滚已成功注册的探针，确保系统状态一致性。\n\n- **唤醒事件处理**：`probe_sched_wakeup` 使用 `current` 作为“前一个任务”，`wakee` 作为“下一个任务”，模拟上下文切换场景，确保被唤醒任务的信息也能被正确记录。\n\n## 4. 依赖关系\n\n- **Tracepoint 子系统**：依赖 `<trace/events/sched.h>` 中定义的 `sched_switch`、`sched_wakeup` 和 `sched_wakeup_new` tracepoint。\n- **Ftrace 框架**：通过 `#include <linux/ftrace.h>` 和 `\"trace.h\"` 与 ftrace 核心集成。\n- **任务信息记录接口**：调用 `tracing_record_taskinfo_sched_switch()`，该函数定义在 `kernel/trace/trace.c` 中，负责实际缓存任务的 cmdline 和 TGID。\n- **内核基础模块**：使用 `mutex`、`pr_info`、`register_trace_*` 等通用内核原语。\n\n## 5. 使用场景\n\n- **延迟跟踪（Latency Tracing）**：在分析调度延迟时，需要知道切换任务的名称和所属进程，便于定位性能瓶颈。\n- **唤醒路径分析（Wakeup Tracer）**：追踪哪个任务唤醒了目标任务，需记录唤醒者和被唤醒者的身份信息。\n- **函数图跟踪（Function Graph Tracer）**：结合任务上下文，提供更清晰的调用栈归属。\n- **动态调试与性能分析工具**：如 `perf`、`trace-cmd` 等用户态工具依赖此机制获取可读的任务标识信息。\n\n该模块本身不直接输出跟踪数据，而是作为基础设施，为其他跟踪器提供任务元数据支持，提升跟踪结果的可读性和诊断价值。",
      "similarity": 0.5588443279266357,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_sched_switch.c",
          "start_line": 132,
          "end_line": 147,
          "content": [
            "void tracing_start_cmdline_record(void)",
            "{",
            "\ttracing_start_sched_switch(RECORD_CMDLINE);",
            "}",
            "void tracing_stop_cmdline_record(void)",
            "{",
            "\ttracing_stop_sched_switch(RECORD_CMDLINE);",
            "}",
            "void tracing_start_tgid_record(void)",
            "{",
            "\ttracing_start_sched_switch(RECORD_TGID);",
            "}",
            "void tracing_stop_tgid_record(void)",
            "{",
            "\ttracing_stop_sched_switch(RECORD_TGID);",
            "}"
          ],
          "function_name": "tracing_start_cmdline_record, tracing_stop_cmdline_record, tracing_start_tgid_record, tracing_stop_tgid_record",
          "description": "提供对外暴露的控制接口函数，通过调用底层tracing_start_sched_switch/tracing_stop_sched_switch实现对命令行记录和线程组ID记录功能的启停控制",
          "similarity": 0.5916280150413513
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_sched_switch.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace context switch",
            " *",
            " * Copyright (C) 2007 Steven Rostedt <srostedt@redhat.com>",
            " *",
            " */",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/sched.h>",
            "",
            "#include \"trace.h\"",
            "",
            "#define RECORD_CMDLINE\t1",
            "#define RECORD_TGID\t2",
            "",
            "static int\t\tsched_cmdline_ref;",
            "static int\t\tsched_tgid_ref;",
            "static DEFINE_MUTEX(sched_register_mutex);",
            ""
          ],
          "function_name": null,
          "description": "定义了调度跟踪模块所需的全局变量和互斥锁，其中sched_cmdline_ref和sched_tgid_ref用于跟踪是否启用命令行和线程组ID记录功能，DEFINE_MUTEX用于保护注册过程的并发访问",
          "similarity": 0.5473876595497131
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_sched_switch.c",
          "start_line": 23,
          "end_line": 125,
          "content": [
            "static void",
            "probe_sched_switch(void *ignore, bool preempt,",
            "\t\t   struct task_struct *prev, struct task_struct *next,",
            "\t\t   unsigned int prev_state)",
            "{",
            "\tint flags;",
            "",
            "\tflags = (RECORD_TGID * !!sched_tgid_ref) +",
            "\t\t(RECORD_CMDLINE * !!sched_cmdline_ref);",
            "",
            "\tif (!flags)",
            "\t\treturn;",
            "\ttracing_record_taskinfo_sched_switch(prev, next, flags);",
            "}",
            "static void",
            "probe_sched_wakeup(void *ignore, struct task_struct *wakee)",
            "{",
            "\tint flags;",
            "",
            "\tflags = (RECORD_TGID * !!sched_tgid_ref) +",
            "\t\t(RECORD_CMDLINE * !!sched_cmdline_ref);",
            "",
            "\tif (!flags)",
            "\t\treturn;",
            "\ttracing_record_taskinfo_sched_switch(current, wakee, flags);",
            "}",
            "static int tracing_sched_register(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_trace_sched_wakeup(probe_sched_wakeup, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_wakeup\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tret = register_trace_sched_wakeup_new(probe_sched_wakeup, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_wakeup_new\\n\");",
            "\t\tgoto fail_deprobe;",
            "\t}",
            "",
            "\tret = register_trace_sched_switch(probe_sched_switch, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_switch\\n\");",
            "\t\tgoto fail_deprobe_wake_new;",
            "\t}",
            "",
            "\treturn ret;",
            "fail_deprobe_wake_new:",
            "\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);",
            "fail_deprobe:",
            "\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);",
            "\treturn ret;",
            "}",
            "static void tracing_sched_unregister(void)",
            "{",
            "\tunregister_trace_sched_switch(probe_sched_switch, NULL);",
            "\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);",
            "\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);",
            "}",
            "static void tracing_start_sched_switch(int ops)",
            "{",
            "\tbool sched_register;",
            "",
            "\tmutex_lock(&sched_register_mutex);",
            "\tsched_register = (!sched_cmdline_ref && !sched_tgid_ref);",
            "",
            "\tswitch (ops) {",
            "\tcase RECORD_CMDLINE:",
            "\t\tsched_cmdline_ref++;",
            "\t\tbreak;",
            "",
            "\tcase RECORD_TGID:",
            "\t\tsched_tgid_ref++;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tif (sched_register && (sched_cmdline_ref || sched_tgid_ref))",
            "\t\ttracing_sched_register();",
            "\tmutex_unlock(&sched_register_mutex);",
            "}",
            "static void tracing_stop_sched_switch(int ops)",
            "{",
            "\tmutex_lock(&sched_register_mutex);",
            "",
            "\tswitch (ops) {",
            "\tcase RECORD_CMDLINE:",
            "\t\tsched_cmdline_ref--;",
            "\t\tbreak;",
            "",
            "\tcase RECORD_TGID:",
            "\t\tsched_tgid_ref--;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tif (!sched_cmdline_ref && !sched_tgid_ref)",
            "\t\ttracing_sched_unregister();",
            "\tmutex_unlock(&sched_register_mutex);",
            "}"
          ],
          "function_name": "probe_sched_switch, probe_sched_wakeup, tracing_sched_register, tracing_sched_unregister, tracing_start_sched_switch, tracing_stop_sched_switch",
          "description": "实现了调度事件跟踪探针注册与注销逻辑，包括两个事件探针回调函数（sched_switch和sched_wakeup），以及根据引用计数动态注册/注销tracepoint的控制接口",
          "similarity": 0.5423299074172974
        }
      ]
    },
    {
      "source_file": "kernel/acct.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:48:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `acct.c`\n\n---\n\n# Linux 内核进程记账模块（acct.c）技术文档\n\n## 1. 文件概述\n\n`acct.c` 实现了 BSD 风格的 Linux 进程记账（Process Accounting）功能。当任意进程退出时，内核会向通过 `acct()` 系统调用指定的文件中写入一条类型为 `struct acct` 的记账记录。该模块仅负责生成原始记账数据，具体的数据分析和处理由用户空间程序完成。此功能可用于系统资源使用审计、用户行为追踪和性能分析等场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bsd_acct_struct`**：进程记账核心控制结构\n  - `pin`：文件系统 pin 机制，防止记账文件被意外卸载\n  - `count`：引用计数，用于安全释放资源\n  - `active`：记账功能是否处于激活状态\n  - `check_space`：是否启用磁盘空间检查\n  - `needcheck`：下次磁盘空间检查的时间点\n  - `file`：记账文件的 file 结构指针\n  - `ns`：关联的 PID 命名空间\n  - `work`：用于异步关闭记账文件的工作队列\n  - `ac`：实际的记账数据结构（`acct_t` 类型）\n\n### 主要函数\n\n- **`acct_on()`**：启用进程记账功能，打开指定文件并初始化记账结构\n- **`check_free_space()`**：检查磁盘剩余空间，根据阈值暂停或恢复记账\n- **`acct_pin_kill()`**：安全关闭记账功能，处理资源清理\n- **`close_work()`**：工作队列回调函数，异步执行记账文件关闭操作\n- **`acct_get()`**：获取当前命名空间的记账结构，带引用计数管理\n- **`acct_put()`**：减少记账结构引用计数，必要时释放内存\n- **`fill_ac()`** 和 **`acct_write_process()`**：填充和写入进程记账记录（声明但未在提供的代码片段中实现）\n\n### 系统参数\n\n- **`acct_parm[3]`**：记账系统控制参数数组\n  - `acct_parm[0]`（RESUME）：磁盘剩余空间百分比阈值，超过此值恢复记账\n  - `acct_parm[1]`（SUSPEND）：磁盘剩余空间百分比阈值，低于此值暂停记账  \n  - `acct_parm[2]`（ACCT_TIMEOUT）：磁盘空间检查间隔时间（秒）\n\n## 3. 关键实现\n\n### 磁盘空间监控机制\n\n记账系统实现了智能的磁盘空间管理：\n- 当可用磁盘空间低于 `SUSPEND` 百分比时，自动暂停记账以避免填满磁盘\n- 当可用磁盘空间恢复到 `RESUME` 百分比以上时，自动恢复记账\n- 通过 `needcheck` 字段控制检查频率，避免频繁的磁盘 I/O 操作\n\n### 资源安全管理和并发控制\n\n- **引用计数机制**：使用 `atomic_long_t count` 确保记账结构在多线程环境下的安全访问和释放\n- **RCU 读取优化**：通过 RCU 机制实现高效的记账结构读取，减少锁竞争\n- **互斥锁保护**：`mutex lock` 保护关键操作，防止竞态条件\n- **文件系统 pin 机制**：防止记账文件所在的文件系统被意外卸载\n\n### 异步关闭机制\n\n- 使用工作队列（`work_struct`）异步处理记账文件关闭操作\n- 通过 `completion` 机制确保关闭操作完成后再释放资源\n- 在关闭前调用文件操作的 `flush` 方法确保数据写入磁盘\n\n### 安全性和验证\n\n- 验证目标文件必须是普通文件（`S_ISREG`）\n- 排除内核内部文件系统（`SB_NOUSER | SB_KERNMOUNT`）\n- 排除特殊文件系统如 procfs 和 sysfs（`SB_I_USERNS_VISIBLE`）\n- 验证文件必须具有写权限（`FMODE_CAN_WRITE`）\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n\n- **内存管理**：`<linux/mm.h>`, `<linux/slab.h>`\n- **文件系统**：`<linux/vfs.h>`, `<linux/file.h>`, `<linux/mount.h>`, `<linux/fs_pin.h>`\n- **进程管理**：`<linux/sched/cputime.h>`, `<linux/pid_namespace.h>`\n- **系统调用**：`<linux/syscalls.h>`, `<linux/uaccess.h>`\n- **安全机制**：`<linux/capability.h>`, `<linux/security.h>`\n- **设备支持**：`<linux/tty.h>`\n- **时间管理**：`<linux/jiffies.h>`, `<linux/times.h>`\n\n### 内核子系统交互\n\n- **VFS 层**：通过标准 VFS 接口进行文件操作和文件系统状态查询\n- **内存管理子系统**：使用 slab 分配器分配记账结构内存\n- **工作队列子系统**：利用内核工作队列处理异步关闭操作\n- **RCU 机制**：使用 RCU 进行无锁读取操作\n- **sysctl 接口**：提供运行时可调参数（当 `CONFIG_SYSCTL` 启用时）\n\n## 5. 使用场景\n\n### 系统管理员监控\n\n- 通过 `acct()` 系统调用启用进程记账，收集系统中所有进程的执行信息\n- 分析用户资源使用情况，识别异常进程行为\n- 监控系统负载和进程执行模式\n\n### 安全审计\n\n- 记录所有进程的执行历史，包括命令名、执行时间、资源消耗等\n- 用于事后安全事件分析和取证\n- 检测未授权的程序执行\n\n### 性能分析\n\n- 收集进程 CPU 时间、内存使用、I/O 操作等性能指标\n- 分析系统资源瓶颈和优化机会\n- 监控长时间运行的进程资源消耗趋势\n\n### 容器环境支持\n\n- 通过 PID 命名空间隔离，支持容器级别的进程记账\n- 每个命名空间可以独立配置记账文件和参数\n- 为容器监控和计费提供基础数据支持",
      "similarity": 0.5572504997253418,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/acct.c",
          "start_line": 544,
          "end_line": 644,
          "content": [
            "static void acct_write_process(struct bsd_acct_struct *acct)",
            "{",
            "\tstruct file *file = acct->file;",
            "\tconst struct cred *cred;",
            "\tacct_t *ac = &acct->ac;",
            "",
            "\t/* Perform file operations on behalf of whoever enabled accounting */",
            "\tcred = override_creds(file->f_cred);",
            "",
            "\t/*",
            "\t * First check to see if there is enough free_space to continue",
            "\t * the process accounting system. Then get freeze protection. If",
            "\t * the fs is frozen, just skip the write as we could deadlock",
            "\t * the system otherwise.",
            "\t */",
            "\tif (check_free_space(acct) && file_start_write_trylock(file)) {",
            "\t\t/* it's been opened O_APPEND, so position is irrelevant */",
            "\t\tloff_t pos = 0;",
            "\t\t__kernel_write(file, ac, sizeof(acct_t), &pos);",
            "\t\tfile_end_write(file);",
            "\t}",
            "",
            "\trevert_creds(cred);",
            "}",
            "static void do_acct_process(struct bsd_acct_struct *acct)",
            "{",
            "\tunsigned long flim;",
            "",
            "\t/* Accounting records are not subject to resource limits. */",
            "\tflim = rlimit(RLIMIT_FSIZE);",
            "\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;",
            "\tfill_ac(acct);",
            "\tacct_write_process(acct);",
            "\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;",
            "}",
            "void acct_collect(long exitcode, int group_dead)",
            "{",
            "\tstruct pacct_struct *pacct = &current->signal->pacct;",
            "\tu64 utime, stime;",
            "\tunsigned long vsize = 0;",
            "",
            "\tif (group_dead && current->mm) {",
            "\t\tstruct mm_struct *mm = current->mm;",
            "\t\tVMA_ITERATOR(vmi, mm, 0);",
            "\t\tstruct vm_area_struct *vma;",
            "",
            "\t\tmmap_read_lock(mm);",
            "\t\tfor_each_vma(vmi, vma)",
            "\t\t\tvsize += vma->vm_end - vma->vm_start;",
            "\t\tmmap_read_unlock(mm);",
            "\t}",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tif (group_dead)",
            "\t\tpacct->ac_mem = vsize / 1024;",
            "\tif (thread_group_leader(current)) {",
            "\t\tpacct->ac_exitcode = exitcode;",
            "\t\tif (current->flags & PF_FORKNOEXEC)",
            "\t\t\tpacct->ac_flag |= AFORK;",
            "\t}",
            "\tif (current->flags & PF_SUPERPRIV)",
            "\t\tpacct->ac_flag |= ASU;",
            "\tif (current->flags & PF_DUMPCORE)",
            "\t\tpacct->ac_flag |= ACORE;",
            "\tif (current->flags & PF_SIGNALED)",
            "\t\tpacct->ac_flag |= AXSIG;",
            "",
            "\ttask_cputime(current, &utime, &stime);",
            "\tpacct->ac_utime += utime;",
            "\tpacct->ac_stime += stime;",
            "\tpacct->ac_minflt += current->min_flt;",
            "\tpacct->ac_majflt += current->maj_flt;",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "}",
            "static void slow_acct_process(struct pid_namespace *ns)",
            "{",
            "\tfor ( ; ns; ns = ns->parent) {",
            "\t\tstruct bsd_acct_struct *acct = acct_get(ns);",
            "\t\tif (acct) {",
            "\t\t\tdo_acct_process(acct);",
            "\t\t\tmutex_unlock(&acct->lock);",
            "\t\t\tacct_put(acct);",
            "\t\t}",
            "\t}",
            "}",
            "void acct_process(void)",
            "{",
            "\tstruct pid_namespace *ns;",
            "",
            "\t/*",
            "\t * This loop is safe lockless, since current is still",
            "\t * alive and holds its namespace, which in turn holds",
            "\t * its parent.",
            "\t */",
            "\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {",
            "\t\tif (ns->bacct)",
            "\t\t\tbreak;",
            "\t}",
            "\tif (unlikely(ns))",
            "\t\tslow_acct_process(ns);",
            "}"
          ],
          "function_name": "acct_write_process, do_acct_process, acct_collect, slow_acct_process, acct_process",
          "description": "实现会计记录的实际写入流程、进程状态收集逻辑及跨命名空间的递归计账处理，包含资源限制绕过、线程组统计信息聚合和锁安全的遍历机制。",
          "similarity": 0.5616583228111267
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/acct.c",
          "start_line": 1,
          "end_line": 88,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  linux/kernel/acct.c",
            " *",
            " *  BSD Process Accounting for Linux",
            " *",
            " *  Author: Marco van Wieringen <mvw@planets.elm.net>",
            " *",
            " *  Some code based on ideas and code from:",
            " *  Thomas K. Dyas <tdyas@eden.rutgers.edu>",
            " *",
            " *  This file implements BSD-style process accounting. Whenever any",
            " *  process exits, an accounting record of type \"struct acct\" is",
            " *  written to the file specified with the acct() system call. It is",
            " *  up to user-level programs to do useful things with the accounting",
            " *  log. The kernel just provides the raw accounting information.",
            " *",
            " * (C) Copyright 1995 - 1997 Marco van Wieringen - ELM Consultancy B.V.",
            " *",
            " *  Plugged two leaks. 1) It didn't return acct_file into the free_filps if",
            " *  the file happened to be read-only. 2) If the accounting was suspended",
            " *  due to the lack of space it happily allowed to reopen it and completely",
            " *  lost the old acct_file. 3/10/98, Al Viro.",
            " *",
            " *  Now we silently close acct_file on attempt to reopen. Cleaned sys_acct().",
            " *  XTerms and EMACS are manifestations of pure evil. 21/10/98, AV.",
            " *",
            " *  Fixed a nasty interaction with sys_umount(). If the accounting",
            " *  was suspeneded we failed to stop it on umount(). Messy.",
            " *  Another one: remount to readonly didn't stop accounting.",
            " *\tQuestion: what should we do if we have CAP_SYS_ADMIN but not",
            " *  CAP_SYS_PACCT? Current code does the following: umount returns -EBUSY",
            " *  unless we are messing with the root. In that case we are getting a",
            " *  real mess with do_remount_sb(). 9/11/98, AV.",
            " *",
            " *  Fixed a bunch of races (and pair of leaks). Probably not the best way,",
            " *  but this one obviously doesn't introduce deadlocks. Later. BTW, found",
            " *  one race (and leak) in BSD implementation.",
            " *  OK, that's better. ANOTHER race and leak in BSD variant. There always",
            " *  is one more bug... 10/11/98, AV.",
            " *",
            " *\tOh, fsck... Oopsable SMP race in do_process_acct() - we must hold",
            " * ->mmap_lock to walk the vma list of current->mm. Nasty, since it leaks",
            " * a struct file opened for write. Fixed. 2/6/2000, AV.",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/capability.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/security.h>",
            "#include <linux/vfs.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/times.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/cputime.h>",
            "",
            "#include <asm/div64.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/fs_pin.h>",
            "",
            "/*",
            " * These constants control the amount of freespace that suspend and",
            " * resume the process accounting system, and the time delay between",
            " * each check.",
            " * Turned into sysctl-controllable parameters. AV, 12/11/98",
            " */",
            "",
            "static int acct_parm[3] = {4, 2, 30};",
            "#define RESUME\t\t(acct_parm[0])\t/* >foo% free space - resume */",
            "#define SUSPEND\t\t(acct_parm[1])\t/* <foo% free space - suspend */",
            "#define ACCT_TIMEOUT\t(acct_parm[2])\t/* foo second timeout between checks */",
            "",
            "#ifdef CONFIG_SYSCTL",
            "static struct ctl_table kern_acct_table[] = {",
            "\t{",
            "\t\t.procname       = \"acct\",",
            "\t\t.data           = &acct_parm,",
            "\t\t.maxlen         = 3*sizeof(int),",
            "\t\t.mode           = 0644,",
            "\t\t.proc_handler   = proc_dointvec,",
            "\t},",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义BSD进程计账系统的常量和sysctl控制表，用于动态调整磁盘空间阈值和检查间隔，注册到内核sysctl接口以支持运行时配置。",
          "similarity": 0.5554991960525513
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/acct.c",
          "start_line": 338,
          "end_line": 498,
          "content": [
            "void acct_exit_ns(struct pid_namespace *ns)",
            "{",
            "\trcu_read_lock();",
            "\tpin_kill(ns->bacct);",
            "}",
            "static comp_t encode_comp_t(u64 value)",
            "{",
            "\tint exp, rnd;",
            "",
            "\texp = rnd = 0;",
            "\twhile (value > MAXFRACT) {",
            "\t\trnd = value & (1 << (EXPSIZE - 1));\t/* Round up? */",
            "\t\tvalue >>= EXPSIZE;\t/* Base 8 exponent == 3 bit shift. */",
            "\t\texp++;",
            "\t}",
            "",
            "\t/*",
            "\t * If we need to round up, do it (and handle overflow correctly).",
            "\t */",
            "\tif (rnd && (++value > MAXFRACT)) {",
            "\t\tvalue >>= EXPSIZE;",
            "\t\texp++;",
            "\t}",
            "",
            "\tif (exp > (((comp_t) ~0U) >> MANTSIZE))",
            "\t\treturn (comp_t) ~0U;",
            "\t/*",
            "\t * Clean it up and polish it off.",
            "\t */",
            "\texp <<= MANTSIZE;\t\t/* Shift the exponent into place */",
            "\texp += value;\t\t\t/* and add on the mantissa. */",
            "\treturn exp;",
            "}",
            "static comp2_t encode_comp2_t(u64 value)",
            "{",
            "\tint exp, rnd;",
            "",
            "\texp = (value > (MAXFRACT2>>1));",
            "\trnd = 0;",
            "\twhile (value > MAXFRACT2) {",
            "\t\trnd = value & 1;",
            "\t\tvalue >>= 1;",
            "\t\texp++;",
            "\t}",
            "",
            "\t/*",
            "\t * If we need to round up, do it (and handle overflow correctly).",
            "\t */",
            "\tif (rnd && (++value > MAXFRACT2)) {",
            "\t\tvalue >>= 1;",
            "\t\texp++;",
            "\t}",
            "",
            "\tif (exp > MAXEXP2) {",
            "\t\t/* Overflow. Return largest representable number instead. */",
            "\t\treturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;",
            "\t} else {",
            "\t\treturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));",
            "\t}",
            "}",
            "static u32 encode_float(u64 value)",
            "{",
            "\tunsigned exp = 190;",
            "\tunsigned u;",
            "",
            "\tif (value == 0)",
            "\t\treturn 0;",
            "\twhile ((s64)value > 0) {",
            "\t\tvalue <<= 1;",
            "\t\texp--;",
            "\t}",
            "\tu = (u32)(value >> 40) & 0x7fffffu;",
            "\treturn u | (exp << 23);",
            "}",
            "static void fill_ac(struct bsd_acct_struct *acct)",
            "{",
            "\tstruct pacct_struct *pacct = &current->signal->pacct;",
            "\tstruct file *file = acct->file;",
            "\tacct_t *ac = &acct->ac;",
            "\tu64 elapsed, run_time;",
            "\ttime64_t btime;",
            "\tstruct tty_struct *tty;",
            "",
            "\tlockdep_assert_held(&acct->lock);",
            "",
            "\tif (time_is_after_jiffies(acct->needcheck)) {",
            "\t\tacct->check_space = false;",
            "",
            "\t\t/* Don't fill in @ac if nothing will be written. */",
            "\t\tif (!acct->active)",
            "\t\t\treturn;",
            "\t} else {",
            "\t\tacct->check_space = true;",
            "\t}",
            "",
            "\t/*",
            "\t * Fill the accounting struct with the needed info as recorded",
            "\t * by the different kernel functions.",
            "\t */",
            "\tmemset(ac, 0, sizeof(acct_t));",
            "",
            "\tac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;",
            "\tstrscpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));",
            "",
            "\t/* calculate run_time in nsec*/",
            "\trun_time = ktime_get_ns();",
            "\trun_time -= current->group_leader->start_time;",
            "\t/* convert nsec -> AHZ */",
            "\telapsed = nsec_to_AHZ(run_time);",
            "#if ACCT_VERSION == 3",
            "\tac->ac_etime = encode_float(elapsed);",
            "#else",
            "\tac->ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?",
            "\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);",
            "#endif",
            "#if ACCT_VERSION == 1 || ACCT_VERSION == 2",
            "\t{",
            "\t\t/* new enlarged etime field */",
            "\t\tcomp2_t etime = encode_comp2_t(elapsed);",
            "",
            "\t\tac->ac_etime_hi = etime >> 16;",
            "\t\tac->ac_etime_lo = (u16) etime;",
            "\t}",
            "#endif",
            "\tdo_div(elapsed, AHZ);",
            "\tbtime = ktime_get_real_seconds() - elapsed;",
            "\tac->ac_btime = clamp_t(time64_t, btime, 0, U32_MAX);",
            "#if ACCT_VERSION == 2",
            "\tac->ac_ahz = AHZ;",
            "#endif",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\ttty = current->signal->tty;\t/* Safe as we hold the siglock */",
            "\tac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;",
            "\tac->ac_utime = encode_comp_t(nsec_to_AHZ(pacct->ac_utime));",
            "\tac->ac_stime = encode_comp_t(nsec_to_AHZ(pacct->ac_stime));",
            "\tac->ac_flag = pacct->ac_flag;",
            "\tac->ac_mem = encode_comp_t(pacct->ac_mem);",
            "\tac->ac_minflt = encode_comp_t(pacct->ac_minflt);",
            "\tac->ac_majflt = encode_comp_t(pacct->ac_majflt);",
            "\tac->ac_exitcode = pacct->ac_exitcode;",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\t/* we really need to bite the bullet and change layout */",
            "\tac->ac_uid = from_kuid_munged(file->f_cred->user_ns, current_uid());",
            "\tac->ac_gid = from_kgid_munged(file->f_cred->user_ns, current_gid());",
            "#if ACCT_VERSION == 1 || ACCT_VERSION == 2",
            "\t/* backward-compatible 16 bit fields */",
            "\tac->ac_uid16 = ac->ac_uid;",
            "\tac->ac_gid16 = ac->ac_gid;",
            "#elif ACCT_VERSION == 3",
            "\t{",
            "\t\tstruct pid_namespace *ns = acct->ns;",
            "",
            "\t\tac->ac_pid = task_tgid_nr_ns(current, ns);",
            "\t\trcu_read_lock();",
            "\t\tac->ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent), ns);",
            "\t\trcu_read_unlock();",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "acct_exit_ns, encode_comp_t, encode_comp2_t, encode_float, fill_ac",
          "description": "提供时间编码辅助函数和会计记录填充逻辑，实现不同版本会计结构的数据转换与字段填充，包含UID/GID映射和进程标识符获取等关键操作。",
          "similarity": 0.5073317289352417
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/acct.c",
          "start_line": 89,
          "end_line": 236,
          "content": [
            "static __init int kernel_acct_sysctls_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kern_acct_table);",
            "\treturn 0;",
            "}",
            "static bool check_free_space(struct bsd_acct_struct *acct)",
            "{",
            "\tstruct kstatfs sbuf;",
            "",
            "\tif (!acct->check_space)",
            "\t\treturn acct->active;",
            "",
            "\t/* May block */",
            "\tif (vfs_statfs(&acct->file->f_path, &sbuf))",
            "\t\treturn acct->active;",
            "",
            "\tif (acct->active) {",
            "\t\tu64 suspend = sbuf.f_blocks * SUSPEND;",
            "\t\tdo_div(suspend, 100);",
            "\t\tif (sbuf.f_bavail <= suspend) {",
            "\t\t\tacct->active = false;",
            "\t\t\tpr_info(\"Process accounting paused\\n\");",
            "\t\t}",
            "\t} else {",
            "\t\tu64 resume = sbuf.f_blocks * RESUME;",
            "\t\tdo_div(resume, 100);",
            "\t\tif (sbuf.f_bavail >= resume) {",
            "\t\t\tacct->active = true;",
            "\t\t\tpr_info(\"Process accounting resumed\\n\");",
            "\t\t}",
            "\t}",
            "",
            "\tacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;",
            "\treturn acct->active;",
            "}",
            "static void acct_put(struct bsd_acct_struct *p)",
            "{",
            "\tif (atomic_long_dec_and_test(&p->count))",
            "\t\tkfree_rcu(p, rcu);",
            "}",
            "static void acct_pin_kill(struct fs_pin *pin)",
            "{",
            "\tstruct bsd_acct_struct *acct = to_acct(pin);",
            "\tmutex_lock(&acct->lock);",
            "\t/*",
            "\t * Fill the accounting struct with the exiting task's info",
            "\t * before punting to the workqueue.",
            "\t */",
            "\tfill_ac(acct);",
            "\tschedule_work(&acct->work);",
            "\twait_for_completion(&acct->done);",
            "\tcmpxchg(&acct->ns->bacct, pin, NULL);",
            "\tmutex_unlock(&acct->lock);",
            "\tpin_remove(pin);",
            "\tacct_put(acct);",
            "}",
            "static void close_work(struct work_struct *work)",
            "{",
            "\tstruct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);",
            "\tstruct file *file = acct->file;",
            "",
            "\t/* We were fired by acct_pin_kill() which holds acct->lock. */",
            "\tacct_write_process(acct);",
            "\tif (file->f_op->flush)",
            "\t\tfile->f_op->flush(file, NULL);",
            "\t__fput_sync(file);",
            "\tcomplete(&acct->done);",
            "}",
            "static int acct_on(struct filename *pathname)",
            "{",
            "\tstruct file *file;",
            "\tstruct vfsmount *mnt, *internal;",
            "\tstruct pid_namespace *ns = task_active_pid_ns(current);",
            "\tstruct bsd_acct_struct *acct;",
            "\tstruct fs_pin *old;",
            "\tint err;",
            "",
            "\tacct = kzalloc(sizeof(struct bsd_acct_struct), GFP_KERNEL);",
            "\tif (!acct)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* Difference from BSD - they don't do O_APPEND */",
            "\tfile = file_open_name(pathname, O_WRONLY|O_APPEND|O_LARGEFILE, 0);",
            "\tif (IS_ERR(file)) {",
            "\t\tkfree(acct);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\tif (!S_ISREG(file_inode(file)->i_mode)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EACCES;",
            "\t}",
            "",
            "\t/* Exclude kernel kernel internal filesystems. */",
            "\tif (file_inode(file)->i_sb->s_flags & (SB_NOUSER | SB_KERNMOUNT)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* Exclude procfs and sysfs. */",
            "\tif (file_inode(file)->i_sb->s_iflags & SB_I_USERNS_VISIBLE) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (!(file->f_mode & FMODE_CAN_WRITE)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn -EIO;",
            "\t}",
            "\tinternal = mnt_clone_internal(&file->f_path);",
            "\tif (IS_ERR(internal)) {",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn PTR_ERR(internal);",
            "\t}",
            "\terr = mnt_get_write_access(internal);",
            "\tif (err) {",
            "\t\tmntput(internal);",
            "\t\tkfree(acct);",
            "\t\tfilp_close(file, NULL);",
            "\t\treturn err;",
            "\t}",
            "\tmnt = file->f_path.mnt;",
            "\tfile->f_path.mnt = internal;",
            "",
            "\tatomic_long_set(&acct->count, 1);",
            "\tinit_fs_pin(&acct->pin, acct_pin_kill);",
            "\tacct->file = file;",
            "\tacct->needcheck = jiffies;",
            "\tacct->ns = ns;",
            "\tmutex_init(&acct->lock);",
            "\tINIT_WORK(&acct->work, close_work);",
            "\tinit_completion(&acct->done);",
            "\tmutex_lock_nested(&acct->lock, 1);\t/* nobody has seen it yet */",
            "\tpin_insert(&acct->pin, mnt);",
            "",
            "\trcu_read_lock();",
            "\told = xchg(&ns->bacct, &acct->pin);",
            "\tmutex_unlock(&acct->lock);",
            "\tpin_kill(old);",
            "\tmnt_put_write_access(mnt);",
            "\tmntput(mnt);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "kernel_acct_sysctls_init, check_free_space, acct_put, acct_pin_kill, close_work, acct_on",
          "description": "实现计账文件的空间检查逻辑、资源释放机制、文件句柄管理及计账开启流程，包含磁盘空间监控、文件操作封装和命名空间绑定等功能。",
          "similarity": 0.47506579756736755
        }
      ]
    }
  ]
}