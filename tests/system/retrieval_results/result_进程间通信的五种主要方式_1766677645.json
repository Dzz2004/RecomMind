{
  "query": "进程间通信的五种主要方式",
  "timestamp": "2025-12-25 23:47:25",
  "retrieved_files": [
    {
      "source_file": "kernel/ptrace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ptrace.c`\n\n---\n\n# ptrace.c 技术文档\n\n## 1. 文件概述\n\n`ptrace.c` 是 Linux 内核中实现 **ptrace**（进程跟踪）机制的核心通用代码文件。该文件提供了跨架构的 ptrace 公共接口和基础功能，避免在每个体系结构中重复实现相同逻辑。ptrace 机制允许一个进程（tracer，通常是调试器）观察和控制另一个进程（tracee）的执行，包括读写其内存、寄存器状态、拦截系统调用等，是调试器（如 GDB）、系统调用追踪工具（如 strace）和安全监控工具的基础。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`ptrace_access_vm()`**  \n  安全地访问被跟踪进程（tracee）的虚拟内存空间，用于读写其内存内容。\n\n- **`__ptrace_link()`**  \n  将被跟踪进程链接到跟踪进程（tracer）的 `ptraced` 链表中，并设置其父进程为 tracer。\n\n- **`ptrace_link()`**  \n  封装 `__ptrace_link()`，使用当前进程的凭证建立跟踪关系。\n\n- **`__ptrace_unlink()`**  \n  解除跟踪关系：将被跟踪进程从 tracer 的链表中移除，恢复其原始父进程，并根据进程组停止状态调整其任务状态（如从 `TASK_TRACED` 转为 `TASK_STOPPED` 或唤醒）。\n\n- **`ptrace_freeze_traced()`** / **`ptrace_unfreeze_traced()`**  \n  在执行 ptrace 操作期间临时冻结被跟踪进程，防止其被意外唤醒（即使是 SIGKILL），确保操作的原子性和一致性。\n\n- **`ptrace_check_attach()`**  \n  验证当前进程是否有权对目标进程执行 ptrace 操作，并确保目标进程处于合适的跟踪状态（可选）。\n\n- **`looks_like_a_spurious_pid()`**  \n  辅助函数，用于检测因线程组 leader 更换（如 `de_thread()`）导致的“虚假”ptrace 事件，避免对已销毁进程的误操作。\n\n### 关键数据结构字段（在 `task_struct` 中）\n\n- `ptrace`：标志位，表示进程是否被跟踪。\n- `parent` / `real_parent`：分别表示当前父进程（通常是 tracer）和原始父进程。\n- `ptraced`：链表头，包含所有被当前进程跟踪的子进程。\n- `ptrace_entry`：链表节点，用于加入 tracer 的 `ptraced` 链表。\n- `ptracer_cred`：跟踪进程的凭证（credentials），用于权限检查。\n- `jobctl`：任务控制标志，包含 `JOBCTL_PTRACE_FROZEN`、`JOBCTL_TRACED`、`JOBCTL_STOP_PENDING` 等 ptrace 相关状态。\n\n## 3. 关键实现\n\n### 安全内存访问 (`ptrace_access_vm`)\n- 通过 `get_task_mm()` 获取目标进程的内存描述符 `mm_struct`。\n- 执行严格的权限检查：\n  - 目标进程必须正在被跟踪（`tsk->ptrace` 非零）。\n  - 当前进程必须是目标进程的直接父进程（`current == tsk->parent`）。\n  - 或者当前进程在目标进程的用户命名空间中具有 `CAP_SYS_PTRACE` 能力（通过 `ptracer_capable()` 检查）。\n- 使用 `__access_remote_vm()` 安全地读写目标进程内存，避免直接遍历页表。\n\n### 跟踪关系管理\n- **链接**：`ptrace_link()` 在持有 `tasklist_lock` 写锁时调用 `__ptrace_link()`，将 tracee 加入 tracer 的 `ptraced` 链表，并保存 tracer 的凭证。\n- **解链接**：`__ptrace_unlink()` 在 detach 或 tracer 退出时调用：\n  - 清除 syscall trace/emu 标志。\n  - 恢复 `real_parent`。\n  - 清除 `ptrace` 标志和 jobctl 中的 trap 相关位。\n  - 根据进程组停止状态决定是否设置 `JOBCTL_STOP_PENDING` 并唤醒进程（`ptrace_signal_wake_up()`）。\n\n### 进程状态冻结机制\n- 在执行 ptrace 操作前调用 `ptrace_freeze_traced()`：\n  - 若 tracee 处于 `TASK_TRACED` 且无致命信号待处理，则设置 `JOBCTL_PTRACE_FROZEN` 标志，使其无法被唤醒。\n- 操作完成后调用 `ptrace_unfreeze_traced()`：\n  - 清除冻结标志。\n  - 若存在致命信号（如 SIGKILL），则清除 `JOBCTL_TRACED` 并唤醒进程以处理信号。\n\n### 权限与状态验证 (`ptrace_check_attach`)\n- 在 `tasklist_lock` 读锁保护下验证：\n  - 目标进程确由当前进程跟踪（`child->ptrace && child->parent == current`）。\n  - 若 `ignore_state=false`，则进一步冻结 tracee 以确保其处于稳定状态。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`mm_struct`、`sighand_struct` 等核心数据结构，以及 `wake_up_state()`、`task_is_traced()` 等调度状态管理函数。\n- **内存管理**：通过 `get_task_mm()`、`mmput()` 和 `__access_remote_vm()` 访问远程进程内存。\n- **信号处理**：大量使用 `siglock`、`jobctl`、`signal_struct` 等信号相关机制管理进程状态转换。\n- **安全模块**：集成 LSM（Linux Security Module）钩子（`security_ptrace_access_check`）和能力检查（`capable()`）。\n- **审计与通知**：与 `audit` 和 `cn_proc`（进程事件连接器）交互，记录 ptrace 事件。\n- **体系结构相关代码**：依赖 `asm/syscall.h` 提供的 `syscall_get_*` 接口获取系统调用信息。\n- **硬件断点**：通过 `hw_breakpoint.h` 支持硬件断点调试功能。\n\n## 5. 使用场景\n\n- **调试器（如 GDB）**：attach 到目标进程，读取/修改寄存器和内存，设置断点，单步执行。\n- **系统调用追踪（如 strace）**：拦截并记录目标进程的所有系统调用及其参数和返回值。\n- **安全监控工具**：监控可疑进程的行为，如检测恶意代码注入或提权操作。\n- **容器与沙箱**：在用户命名空间中实现进程隔离和监控。\n- **内核测试**：用于内核自检和调试，验证进程行为和系统调用处理。\n- **进程注入与热补丁**：通过修改运行中进程的内存和寄存器状态实现代码注入或修复。",
      "similarity": 0.5639486312866211,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/ptrace.c",
          "start_line": 647,
          "end_line": 799,
          "content": [
            "int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tif (copy_from_user(buf, src, this_len))",
            "\t\t\treturn -EFAULT;",
            "\t\tretval = ptrace_access_vm(tsk, dst, buf, this_len,",
            "\t\t\t\tFOLL_FORCE | FOLL_WRITE);",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}",
            "static int ptrace_setoptions(struct task_struct *child, unsigned long data)",
            "{",
            "\tunsigned flags;",
            "\tint ret;",
            "",
            "\tret = check_ptrace_options(data);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* Avoid intermediate state when all opts are cleared */",
            "\tflags = child->ptrace;",
            "\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);",
            "\tflags |= (data << PT_OPT_FLAG_SHIFT);",
            "\tchild->ptrace = flags;",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(info, child->last_siginfo);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(child->last_siginfo, info);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_peek_siginfo(struct task_struct *child,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long data)",
            "{",
            "\tstruct ptrace_peeksiginfo_args arg;",
            "\tstruct sigpending *pending;",
            "\tstruct sigqueue *q;",
            "\tint ret, i;",
            "",
            "\tret = copy_from_user(&arg, (void __user *) addr,",
            "\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)",
            "\t\treturn -EINVAL; /* unknown flags */",
            "",
            "\tif (arg.nr < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure arg.off fits in an unsigned long */",
            "\tif (arg.off > ULONG_MAX)",
            "\t\treturn 0;",
            "",
            "\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)",
            "\t\tpending = &child->signal->shared_pending;",
            "\telse",
            "\t\tpending = &child->pending;",
            "",
            "\tfor (i = 0; i < arg.nr; ) {",
            "\t\tkernel_siginfo_t info;",
            "\t\tunsigned long off = arg.off + i;",
            "\t\tbool found = false;",
            "",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tlist_for_each_entry(q, &pending->list, list) {",
            "\t\t\tif (!off--) {",
            "\t\t\t\tfound = true;",
            "\t\t\t\tcopy_siginfo(&info, &q->info);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tif (!found) /* beyond the end of the list */",
            "\t\t\tbreak;",
            "",
            "#ifdef CONFIG_COMPAT",
            "\t\tif (unlikely(in_compat_syscall())) {",
            "\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);",
            "",
            "\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t} else",
            "#endif",
            "\t\t{",
            "\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;",
            "",
            "\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tdata += sizeof(siginfo_t);",
            "\t\ti++;",
            "",
            "\t\tif (signal_pending(current))",
            "\t\t\tbreak;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\tif (i > 0)",
            "\t\treturn i;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_writedata, ptrace_setoptions, ptrace_getsiginfo, ptrace_setsiginfo, ptrace_peek_siginfo",
          "description": "实现ptrace_writedata用于将数据写入被跟踪进程的内存，通过循环拷贝并处理错误；ptrace_setoptions用于更新跟踪选项标志位；ptrace_getsiginfo/ptrace_setsiginfo用于获取和设置进程的最后一个信号信息；ptrace_peek_siginfo用于遍历信号队列并复制信号信息到用户空间",
          "similarity": 0.583591639995575
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/ptrace.c",
          "start_line": 967,
          "end_line": 1267,
          "content": [
            "static unsigned long",
            "ptrace_get_syscall_info_exit(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t     struct ptrace_syscall_info *info)",
            "{",
            "\tinfo->op = PTRACE_SYSCALL_INFO_EXIT;",
            "\tinfo->exit.rval = syscall_get_error(child, regs);",
            "\tinfo->exit.is_error = !!info->exit.rval;",
            "\tif (!info->exit.is_error)",
            "\t\tinfo->exit.rval = syscall_get_return_value(child, regs);",
            "",
            "\t/* is_error is the last field in struct ptrace_syscall_info.exit */",
            "\treturn offsetofend(struct ptrace_syscall_info, exit.is_error);",
            "}",
            "static int",
            "ptrace_get_syscall_info(struct task_struct *child, unsigned long user_size,",
            "\t\t\tvoid __user *datavp)",
            "{",
            "\tstruct pt_regs *regs = task_pt_regs(child);",
            "\tstruct ptrace_syscall_info info = {",
            "\t\t.op = PTRACE_SYSCALL_INFO_NONE,",
            "\t\t.arch = syscall_get_arch(child),",
            "\t\t.instruction_pointer = instruction_pointer(regs),",
            "\t\t.stack_pointer = user_stack_pointer(regs),",
            "\t};",
            "\tunsigned long actual_size = offsetof(struct ptrace_syscall_info, entry);",
            "\tunsigned long write_size;",
            "",
            "\t/*",
            "\t * This does not need lock_task_sighand() to access",
            "\t * child->last_siginfo because ptrace_freeze_traced()",
            "\t * called earlier by ptrace_check_attach() ensures that",
            "\t * the tracee cannot go away and clear its last_siginfo.",
            "\t */",
            "\tswitch (child->last_siginfo ? child->last_siginfo->si_code : 0) {",
            "\tcase SIGTRAP | 0x80:",
            "\t\tswitch (child->ptrace_message) {",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_ENTRY:",
            "\t\t\tactual_size = ptrace_get_syscall_info_entry(child, regs,",
            "\t\t\t\t\t\t\t\t    &info);",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_EXIT:",
            "\t\t\tactual_size = ptrace_get_syscall_info_exit(child, regs,",
            "\t\t\t\t\t\t\t\t   &info);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase SIGTRAP | (PTRACE_EVENT_SECCOMP << 8):",
            "\t\tactual_size = ptrace_get_syscall_info_seccomp(child, regs,",
            "\t\t\t\t\t\t\t      &info);",
            "\t\tbreak;",
            "\t}",
            "",
            "\twrite_size = min(actual_size, user_size);",
            "\treturn copy_to_user(datavp, &info, write_size) ? -EFAULT : actual_size;",
            "}",
            "int ptrace_request(struct task_struct *child, long request,",
            "\t\t   unsigned long addr, unsigned long data)",
            "{",
            "\tbool seized = child->ptrace & PT_SEIZED;",
            "\tint ret = -EIO;",
            "\tkernel_siginfo_t siginfo, *si;",
            "\tvoid __user *datavp = (void __user *) data;",
            "\tunsigned long __user *datalp = datavp;",
            "\tunsigned long flags;",
            "",
            "\tswitch (request) {",
            "\tcase PTRACE_PEEKTEXT:",
            "\tcase PTRACE_PEEKDATA:",
            "\t\treturn generic_ptrace_peekdata(child, addr, data);",
            "\tcase PTRACE_POKETEXT:",
            "\tcase PTRACE_POKEDATA:",
            "\t\treturn generic_ptrace_pokedata(child, addr, data);",
            "",
            "#ifdef PTRACE_OLDSETOPTIONS",
            "\tcase PTRACE_OLDSETOPTIONS:",
            "#endif",
            "\tcase PTRACE_SETOPTIONS:",
            "\t\tret = ptrace_setoptions(child, data);",
            "\t\tbreak;",
            "\tcase PTRACE_GETEVENTMSG:",
            "\t\tret = put_user(child->ptrace_message, datalp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_PEEKSIGINFO:",
            "\t\tret = ptrace_peek_siginfo(child, addr, data);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGINFO:",
            "\t\tret = ptrace_getsiginfo(child, &siginfo);",
            "\t\tif (!ret)",
            "\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SETSIGINFO:",
            "\t\tret = copy_siginfo_from_user(&siginfo, datavp);",
            "\t\tif (!ret)",
            "\t\t\tret = ptrace_setsiginfo(child, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGMASK: {",
            "\t\tsigset_t *mask;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (test_tsk_restore_sigmask(child))",
            "\t\t\tmask = &child->saved_sigmask;",
            "\t\telse",
            "\t\t\tmask = &child->blocked;",
            "",
            "\t\tif (copy_to_user(datavp, mask, sizeof(sigset_t)))",
            "\t\t\tret = -EFAULT;",
            "\t\telse",
            "\t\t\tret = 0;",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_SETSIGMASK: {",
            "\t\tsigset_t new_set;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (copy_from_user(&new_set, datavp, sizeof(sigset_t))) {",
            "\t\t\tret = -EFAULT;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));",
            "",
            "\t\t/*",
            "\t\t * Every thread does recalc_sigpending() after resume, so",
            "\t\t * retarget_shared_pending() and recalc_sigpending() are not",
            "\t\t * called here.",
            "\t\t */",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tchild->blocked = new_set;",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tclear_tsk_restore_sigmask(child);",
            "",
            "\t\tret = 0;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_INTERRUPT:",
            "\t\t/*",
            "\t\t * Stop tracee without any side-effect on signal or job",
            "\t\t * control.  At least one trap is guaranteed to happen",
            "\t\t * after this request.  If @child is already trapped, the",
            "\t\t * current trap is not disturbed and another trap will",
            "\t\t * happen after the current trap is ended with PTRACE_CONT.",
            "\t\t *",
            "\t\t * The actual trap might not be PTRACE_EVENT_STOP trap but",
            "\t\t * the pending condition is cleared regardless.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * INTERRUPT doesn't disturb existing trap sans one",
            "\t\t * exception.  If ptracer issued LISTEN for the current",
            "\t\t * STOP, this INTERRUPT should clear LISTEN and re-trap",
            "\t\t * tracee into STOP.",
            "\t\t */",
            "\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))",
            "\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);",
            "",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tret = 0;",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_LISTEN:",
            "\t\t/*",
            "\t\t * Listen for events.  Tracee must be in STOP.  It's not",
            "\t\t * resumed per-se but is not considered to be in TRACED by",
            "\t\t * wait(2) or ptrace(2).  If an async event (e.g. group",
            "\t\t * stop state change) happens, tracee will enter STOP trap",
            "\t\t * again.  Alternatively, ptracer can issue INTERRUPT to",
            "\t\t * finish listening and re-trap tracee into STOP.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\tsi = child->last_siginfo;",
            "\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {",
            "\t\t\tchild->jobctl |= JOBCTL_LISTENING;",
            "\t\t\t/*",
            "\t\t\t * If NOTIFY is set, it means event happened between",
            "\t\t\t * start of this trap and now.  Trigger re-trap.",
            "\t\t\t */",
            "\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)",
            "\t\t\t\tptrace_signal_wake_up(child, true);",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_DETACH:\t /* detach a process that was attached. */",
            "\t\tret = ptrace_detach(child, data);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_BINFMT_ELF_FDPIC",
            "\tcase PTRACE_GETFDPIC: {",
            "\t\tstruct mm_struct *mm = get_task_mm(child);",
            "\t\tunsigned long tmp = 0;",
            "",
            "\t\tret = -ESRCH;",
            "\t\tif (!mm)",
            "\t\t\tbreak;",
            "",
            "\t\tswitch (addr) {",
            "\t\tcase PTRACE_GETFDPIC_EXEC:",
            "\t\t\ttmp = mm->context.exec_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_GETFDPIC_INTERP:",
            "\t\t\ttmp = mm->context.interp_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tmmput(mm);",
            "",
            "\t\tret = put_user(tmp, datalp);",
            "\t\tbreak;",
            "\t}",
            "#endif",
            "",
            "\tcase PTRACE_SINGLESTEP:",
            "#ifdef PTRACE_SINGLEBLOCK",
            "\tcase PTRACE_SINGLEBLOCK:",
            "#endif",
            "#ifdef PTRACE_SYSEMU",
            "\tcase PTRACE_SYSEMU:",
            "\tcase PTRACE_SYSEMU_SINGLESTEP:",
            "#endif",
            "\tcase PTRACE_SYSCALL:",
            "\tcase PTRACE_CONT:",
            "\t\treturn ptrace_resume(child, request, data);",
            "",
            "\tcase PTRACE_KILL:",
            "\t\tsend_sig_info(SIGKILL, SEND_SIG_NOINFO, child);",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_HAVE_ARCH_TRACEHOOK",
            "\tcase PTRACE_GETREGSET:",
            "\tcase PTRACE_SETREGSET: {",
            "\t\tstruct iovec kiov;",
            "\t\tstruct iovec __user *uiov = datavp;",
            "",
            "\t\tif (!access_ok(uiov, sizeof(*uiov)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||",
            "\t\t    __get_user(kiov.iov_len, &uiov->iov_len))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tret = ptrace_regset(child, request, addr, &kiov);",
            "\t\tif (!ret)",
            "\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_GET_SYSCALL_INFO:",
            "\t\tret = ptrace_get_syscall_info(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SECCOMP_GET_FILTER:",
            "\t\tret = seccomp_get_filter(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SECCOMP_GET_METADATA:",
            "\t\tret = seccomp_get_metadata(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_RSEQ",
            "\tcase PTRACE_GET_RSEQ_CONFIGURATION:",
            "\t\tret = ptrace_get_rseq_configuration(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_set_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_get_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_get_syscall_info_exit, ptrace_get_syscall_info, ptrace_request",
          "description": "ptrace_get_syscall_info根据进程最后信号信息构造系统调用详细数据结构；ptrace_request作为ptrace系统调用的核心分发函数，处理包括中断、继续执行、获取/设置信号掩码、获取系统调用信息等各类请求",
          "similarity": 0.5498765707015991
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/ptrace.c",
          "start_line": 44,
          "end_line": 148,
          "content": [
            "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,",
            "\t\t     void *buf, int len, unsigned int gup_flags)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint ret;",
            "",
            "\tmm = get_task_mm(tsk);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tif (!tsk->ptrace ||",
            "\t    (current != tsk->parent) ||",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptracer_capable(tsk, mm->user_ns))) {",
            "\t\tmmput(mm);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = __access_remote_vm(mm, addr, buf, len, gup_flags);",
            "\tmmput(mm);",
            "",
            "\treturn ret;",
            "}",
            "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,",
            "\t\t   const struct cred *ptracer_cred)",
            "{",
            "\tBUG_ON(!list_empty(&child->ptrace_entry));",
            "\tlist_add(&child->ptrace_entry, &new_parent->ptraced);",
            "\tchild->parent = new_parent;",
            "\tchild->ptracer_cred = get_cred(ptracer_cred);",
            "}",
            "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)",
            "{",
            "\t__ptrace_link(child, new_parent, current_cred());",
            "}",
            "void __ptrace_unlink(struct task_struct *child)",
            "{",
            "\tconst struct cred *old_cred;",
            "\tBUG_ON(!child->ptrace);",
            "",
            "\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tchild->parent = child->real_parent;",
            "\tlist_del_init(&child->ptrace_entry);",
            "\told_cred = child->ptracer_cred;",
            "\tchild->ptracer_cred = NULL;",
            "\tput_cred(old_cred);",
            "",
            "\tspin_lock(&child->sighand->siglock);",
            "\tchild->ptrace = 0;",
            "\t/*",
            "\t * Clear all pending traps and TRAPPING.  TRAPPING should be",
            "\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.",
            "\t */",
            "\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);",
            "\ttask_clear_jobctl_trapping(child);",
            "",
            "\t/*",
            "\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and",
            "\t * @child isn't dead.",
            "\t */",
            "\tif (!(child->flags & PF_EXITING) &&",
            "\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||",
            "\t     child->signal->group_stop_count)) {",
            "\t\tchild->jobctl |= JOBCTL_STOP_PENDING;",
            "",
            "\t\t/*",
            "\t\t * This is only possible if this thread was cloned by the",
            "\t\t * traced task running in the stopped group, set the signal",
            "\t\t * for the future reports.",
            "\t\t * FIXME: we should change ptrace_init_task() to handle this",
            "\t\t * case.",
            "\t\t */",
            "\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))",
            "\t\t\tchild->jobctl |= SIGSTOP;",
            "\t}",
            "",
            "\t/*",
            "\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick",
            "\t * @child in the butt.  Note that @resume should be used iff @child",
            "\t * is in TASK_TRACED; otherwise, we might unduly disrupt",
            "\t * TASK_KILLABLE sleeps.",
            "\t */",
            "\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))",
            "\t\tptrace_signal_wake_up(child, true);",
            "",
            "\tspin_unlock(&child->sighand->siglock);",
            "}",
            "static bool looks_like_a_spurious_pid(struct task_struct *task)",
            "{",
            "\tif (task->exit_code != ((PTRACE_EVENT_EXEC << 8) | SIGTRAP))",
            "\t\treturn false;",
            "",
            "\tif (task_pid_vnr(task) == task->ptrace_message)",
            "\t\treturn false;",
            "\t/*",
            "\t * The tracee changed its pid but the PTRACE_EVENT_EXEC event",
            "\t * was not wait()'ed, most probably debugger targets the old",
            "\t * leader which was destroyed in de_thread().",
            "\t */",
            "\treturn true;",
            "}"
          ],
          "function_name": "ptrace_access_vm, __ptrace_link, ptrace_link, __ptrace_unlink, looks_like_a_spurious_pid",
          "description": "实现进程跟踪核心操作，包含访问目标进程地址空间、维护跟踪链表、解除跟踪关系及检测虚假PID逻辑，用于安全控制和状态同步。",
          "similarity": 0.5486711859703064
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/ptrace.c",
          "start_line": 1309,
          "end_line": 1405,
          "content": [
            "int generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,",
            "\t\t\t    unsigned long data)",
            "{",
            "\tunsigned long tmp;",
            "\tint copied;",
            "",
            "\tcopied = ptrace_access_vm(tsk, addr, &tmp, sizeof(tmp), FOLL_FORCE);",
            "\tif (copied != sizeof(tmp))",
            "\t\treturn -EIO;",
            "\treturn put_user(tmp, (unsigned long __user *)data);",
            "}",
            "int generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,",
            "\t\t\t    unsigned long data)",
            "{",
            "\tint copied;",
            "",
            "\tcopied = ptrace_access_vm(tsk, addr, &data, sizeof(data),",
            "\t\t\tFOLL_FORCE | FOLL_WRITE);",
            "\treturn (copied == sizeof(data)) ? 0 : -EIO;",
            "}",
            "int compat_ptrace_request(struct task_struct *child, compat_long_t request,",
            "\t\t\t  compat_ulong_t addr, compat_ulong_t data)",
            "{",
            "\tcompat_ulong_t __user *datap = compat_ptr(data);",
            "\tcompat_ulong_t word;",
            "\tkernel_siginfo_t siginfo;",
            "\tint ret;",
            "",
            "\tswitch (request) {",
            "\tcase PTRACE_PEEKTEXT:",
            "\tcase PTRACE_PEEKDATA:",
            "\t\tret = ptrace_access_vm(child, addr, &word, sizeof(word),",
            "\t\t\t\tFOLL_FORCE);",
            "\t\tif (ret != sizeof(word))",
            "\t\t\tret = -EIO;",
            "\t\telse",
            "\t\t\tret = put_user(word, datap);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_POKETEXT:",
            "\tcase PTRACE_POKEDATA:",
            "\t\tret = ptrace_access_vm(child, addr, &data, sizeof(data),",
            "\t\t\t\tFOLL_FORCE | FOLL_WRITE);",
            "\t\tret = (ret != sizeof(data) ? -EIO : 0);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETEVENTMSG:",
            "\t\tret = put_user((compat_ulong_t) child->ptrace_message, datap);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGINFO:",
            "\t\tret = ptrace_getsiginfo(child, &siginfo);",
            "\t\tif (!ret)",
            "\t\t\tret = copy_siginfo_to_user32(",
            "\t\t\t\t(struct compat_siginfo __user *) datap,",
            "\t\t\t\t&siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SETSIGINFO:",
            "\t\tret = copy_siginfo_from_user32(",
            "\t\t\t&siginfo, (struct compat_siginfo __user *) datap);",
            "\t\tif (!ret)",
            "\t\t\tret = ptrace_setsiginfo(child, &siginfo);",
            "\t\tbreak;",
            "#ifdef CONFIG_HAVE_ARCH_TRACEHOOK",
            "\tcase PTRACE_GETREGSET:",
            "\tcase PTRACE_SETREGSET:",
            "\t{",
            "\t\tstruct iovec kiov;",
            "\t\tstruct compat_iovec __user *uiov =",
            "\t\t\t(struct compat_iovec __user *) datap;",
            "\t\tcompat_uptr_t ptr;",
            "\t\tcompat_size_t len;",
            "",
            "\t\tif (!access_ok(uiov, sizeof(*uiov)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (__get_user(ptr, &uiov->iov_base) ||",
            "\t\t    __get_user(len, &uiov->iov_len))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tkiov.iov_base = compat_ptr(ptr);",
            "\t\tkiov.iov_len = len;",
            "",
            "\t\tret = ptrace_regset(child, request, addr, &kiov);",
            "\t\tif (!ret)",
            "\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);",
            "\t\tbreak;",
            "\t}",
            "#endif",
            "",
            "\tdefault:",
            "\t\tret = ptrace_request(child, request, addr, data);",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "generic_ptrace_peekdata, generic_ptrace_pokedata, compat_ptrace_request",
          "description": "generic_ptrace_peekdata/generic_ptrace_pokedata分别为通用的内存读写接口，通过ptrace_access_vm实现虚拟内存访问；compat_ptrace_request处理32位兼容模式下的ptrace请求，包含对齐转换和特殊数据结构的兼容性处理",
          "similarity": 0.5297651290893555
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/ptrace.c",
          "start_line": 806,
          "end_line": 922,
          "content": [
            "static long ptrace_get_rseq_configuration(struct task_struct *task,",
            "\t\t\t\t\t  unsigned long size, void __user *data)",
            "{",
            "\tstruct ptrace_rseq_configuration conf = {",
            "\t\t.rseq_abi_pointer = (u64)(uintptr_t)task->rseq,",
            "\t\t.rseq_abi_size = task->rseq_len,",
            "\t\t.signature = task->rseq_sig,",
            "\t\t.flags = 0,",
            "\t};",
            "",
            "\tsize = min_t(unsigned long, size, sizeof(conf));",
            "\tif (copy_to_user(data, &conf, size))",
            "\t\treturn -EFAULT;",
            "\treturn sizeof(conf);",
            "}",
            "static int ptrace_resume(struct task_struct *child, long request,",
            "\t\t\t unsigned long data)",
            "{",
            "\tif (!valid_signal(data))",
            "\t\treturn -EIO;",
            "",
            "\tif (request == PTRACE_SYSCALL)",
            "\t\tset_task_syscall_work(child, SYSCALL_TRACE);",
            "\telse",
            "\t\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tif (request == PTRACE_SYSEMU || request == PTRACE_SYSEMU_SINGLESTEP)",
            "\t\tset_task_syscall_work(child, SYSCALL_EMU);",
            "\telse",
            "\t\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tif (is_singleblock(request)) {",
            "\t\tif (unlikely(!arch_has_block_step()))",
            "\t\t\treturn -EIO;",
            "\t\tuser_enable_block_step(child);",
            "\t} else if (is_singlestep(request) || is_sysemu_singlestep(request)) {",
            "\t\tif (unlikely(!arch_has_single_step()))",
            "\t\t\treturn -EIO;",
            "\t\tuser_enable_single_step(child);",
            "\t} else {",
            "\t\tuser_disable_single_step(child);",
            "\t}",
            "",
            "\t/*",
            "\t * Change ->exit_code and ->state under siglock to avoid the race",
            "\t * with wait_task_stopped() in between; a non-zero ->exit_code will",
            "\t * wrongly look like another report from tracee.",
            "\t *",
            "\t * Note that we need siglock even if ->exit_code == data and/or this",
            "\t * status was not reported yet, the new status must not be cleared by",
            "\t * wait_task_stopped() after resume.",
            "\t */",
            "\tspin_lock_irq(&child->sighand->siglock);",
            "\tchild->exit_code = data;",
            "\tchild->jobctl &= ~JOBCTL_TRACED;",
            "\twake_up_state(child, __TASK_TRACED);",
            "\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_regset(struct task_struct *task, int req, unsigned int type,",
            "\t\t\t struct iovec *kiov)",
            "{",
            "\tconst struct user_regset_view *view = task_user_regset_view(task);",
            "\tconst struct user_regset *regset = find_regset(view, type);",
            "\tint regset_no;",
            "",
            "\tif (!regset || (kiov->iov_len % regset->size) != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tregset_no = regset - view->regsets;",
            "\tkiov->iov_len = min(kiov->iov_len,",
            "\t\t\t    (__kernel_size_t) (regset->n * regset->size));",
            "",
            "\tif (req == PTRACE_GETREGSET)",
            "\t\treturn copy_regset_to_user(task, view, regset_no, 0,",
            "\t\t\t\t\t   kiov->iov_len, kiov->iov_base);",
            "\telse",
            "\t\treturn copy_regset_from_user(task, view, regset_no, 0,",
            "\t\t\t\t\t     kiov->iov_len, kiov->iov_base);",
            "}",
            "static unsigned long",
            "ptrace_get_syscall_info_entry(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t      struct ptrace_syscall_info *info)",
            "{",
            "\tunsigned long args[ARRAY_SIZE(info->entry.args)];",
            "\tint i;",
            "",
            "\tinfo->op = PTRACE_SYSCALL_INFO_ENTRY;",
            "\tinfo->entry.nr = syscall_get_nr(child, regs);",
            "\tsyscall_get_arguments(child, regs, args);",
            "\tfor (i = 0; i < ARRAY_SIZE(args); i++)",
            "\t\tinfo->entry.args[i] = args[i];",
            "",
            "\t/* args is the last field in struct ptrace_syscall_info.entry */",
            "\treturn offsetofend(struct ptrace_syscall_info, entry.args);",
            "}",
            "static unsigned long",
            "ptrace_get_syscall_info_seccomp(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t\tstruct ptrace_syscall_info *info)",
            "{",
            "\t/*",
            "\t * As struct ptrace_syscall_info.entry is currently a subset",
            "\t * of struct ptrace_syscall_info.seccomp, it makes sense to",
            "\t * initialize that subset using ptrace_get_syscall_info_entry().",
            "\t * This can be reconsidered in the future if these structures",
            "\t * diverge significantly enough.",
            "\t */",
            "\tptrace_get_syscall_info_entry(child, regs, info);",
            "\tinfo->op = PTRACE_SYSCALL_INFO_SECCOMP;",
            "\tinfo->seccomp.ret_data = child->ptrace_message;",
            "",
            "\t/* ret_data is the last field in struct ptrace_syscall_info.seccomp */",
            "\treturn offsetofend(struct ptrace_syscall_info, seccomp.ret_data);",
            "}"
          ],
          "function_name": "ptrace_get_rseq_configuration, ptrace_resume, ptrace_regset, ptrace_get_syscall_info_entry, ptrace_get_syscall_info_seccomp",
          "description": "ptrace_get_rseq_configuration获取RSEQ配置信息；ptrace_resume控制跟踪进程的恢复状态，包括系统调用跟踪、单步执行和信号处理；ptrace_regset处理用户寄存器集合的读写；ptrace_get_syscall_info_*系列函数构建系统调用相关信息结构体",
          "similarity": 0.5239351987838745
        }
      ]
    },
    {
      "source_file": "kernel/fork.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:30:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fork.c`\n\n---\n\n# fork.c 技术文档\n\n## 1. 文件概述\n\n`fork.c` 是 Linux 内核中实现进程创建（fork）系统调用的核心源文件。该文件包含了创建新进程所需的所有辅助例程，负责复制父进程的资源（如内存、文件描述符、信号处理等）以生成子进程。虽然 fork 逻辑本身概念简单，但其涉及的内存管理（尤其是写时复制 COW 机制）极为复杂，实际内存页的复制由 `mm/memory.c` 中的 `copy_page_range()` 等函数处理。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `total_forks`: 累计系统自启动以来创建的进程总数\n- `nr_threads`: 当前系统中的线程总数（不包括 idle 线程）\n- `max_threads`: 可配置的线程数量上限（默认为 `FUTEX_TID_MASK`）\n- `process_counts`: 每 CPU 的进程计数器（per-CPU 变量）\n- `tasklist_lock`: 保护任务链表的读写锁（全局任务列表的同步原语）\n\n### 关键辅助函数\n- `nr_processes()`: 计算系统中所有进程的总数（聚合各 CPU 的 `process_counts`）\n- `arch_release_task_struct()`: 架构相关的 task_struct 释放钩子（弱符号，默认为空）\n- `alloc_task_struct_node()` / `free_task_struct()`: 分配/释放 `task_struct` 结构（基于 slab 分配器）\n- `alloc_thread_stack_node()` / `thread_stack_delayed_free()`: 分配/延迟释放线程内核栈（支持 `CONFIG_VMAP_STACK`）\n\n### 核心数据结构\n- `resident_page_types[]`: 用于内存统计的页面类型名称映射数组\n- `vm_stack`: 用于 RCU 延迟释放的虚拟内存栈封装结构\n- `cached_stacks[NR_CACHED_STACKS]`: 每 CPU 的内核栈缓存（减少频繁 vmalloc/vfree 开销）\n\n## 3. 关键实现\n\n### 进程/线程计数管理\n- 使用 per-CPU 变量 `process_counts` 避免全局锁竞争\n- 全局计数器 `nr_threads` 和 `total_forks` 由 `tasklist_lock` 保护\n- `nr_processes()` 通过遍历所有可能的 CPU 聚合计数\n\n### 内核栈分配策略（`CONFIG_VMAP_STACK`）\n- **缓存机制**：每个 CPU 缓存最多 2 个已释放的栈（`NR_CACHED_STACKS`），减少 TLB 刷新和 vmalloc 开销\n- **内存分配**：\n  - 优先从本地缓存获取栈\n  - 缓存未命中时使用 `__vmalloc_node_range()` 分配连续虚拟地址空间\n  - 显式禁用 `__GFP_ACCOUNT`（因后续手动进行 memcg 计费）\n- **安全清理**：\n  - 重用栈时清零内存（`memset(stack, 0, THREAD_SIZE)`）\n  - KASAN 消毒（`kasan_unpoison_range`）和标签重置\n- **延迟释放**：\n  - 通过 RCU 机制延迟释放栈（`call_rcu`）\n  - 释放时尝试回填缓存，失败则直接 `vfree`\n\n### 内存控制组（memcg）集成\n- 手动对栈的每个物理页进行 memcg 计费（`memcg_kmem_charge_page`）\n- 计费失败时回滚已计费页面（`memcg_kmem_uncharge_page`）\n- 确保内核栈内存纳入 cgroup 内存限制\n\n### 锁与同步\n- `tasklist_lock` 作为全局任务列表的保护锁（读写锁）\n- 提供 `lockdep_tasklist_lock_is_held()` 供 RCU 锁验证使用\n- RCU 用于安全延迟释放内核栈资源\n\n## 4. 依赖关系\n\n### 内核子系统依赖\n- **内存管理 (MM)**：`<linux/mm.h>`, `<linux/vmalloc.h>`, `<linux/memcontrol.h>`\n- **调度器 (Scheduler)**：`<linux/sched/*.h>`, 任务状态和 CPU 绑定\n- **安全模块**：`<linux/security.h>`, `<linux/capability.h>`, `<linux/seccomp.h>`\n- **命名空间**：`<linux/nsproxy.h>`（UTS, IPC, PID, 网络等）\n- **文件系统**：`<linux/fs.h>`, `<linux/fdtable.h>`（文件描述符复制）\n- **跟踪与调试**：`<trace/events/sched.h>`, `<linux/ftrace.h>`, KASAN/KMSAN\n\n### 架构相关依赖\n- `<asm/pgalloc.h>`：页表分配\n- `<asm/mmu_context.h>`：MMU 上下文切换\n- `<asm/tlbflush.h>`：TLB 刷新操作\n- 架构特定的 `THREAD_SIZE` 和栈对齐要求\n\n### 配置选项依赖\n- `CONFIG_VMAP_STACK`：启用虚拟内存分配内核栈\n- `CONFIG_PROVE_RCU`：RCU 锁验证支持\n- `CONFIG_ARCH_TASK_STRUCT_ALLOCATOR`：架构自定义 task_struct 分配器\n- `CONFIG_MEMCG_KMEM`：内核内存 cgroup 支持\n\n## 5. 使用场景\n\n### 进程创建路径\n- **系统调用入口**：`sys_fork()`, `sys_vfork()`, `sys_clone()` 最终调用 `_do_fork()`\n- **内核线程创建**：`kthread_create()` 通过 `kernel_thread()` 触发 fork 逻辑\n- **容器/命名空间初始化**：新 PID/UTS/IPC 命名空间创建时伴随进程 fork\n\n### 资源复制关键点\n- **内存描述符 (mm_struct)**：通过 `dup_mm()` 复制地址空间（COW 页表）\n- **文件描述符表**：`dup_fd()` 复制打开文件表\n- **信号处理**：复制信号掩码和处理函数\n- **POSIX 定时器/异步 I/O**：复制相关上下文（如 `aio`, `posix-timers`）\n\n### 特殊场景处理\n- **写时复制优化**：避免物理内存立即复制，提升 fork 性能\n- **OOM Killer 集成**：在内存不足时参与进程选择\n- **审计与监控**：通过 `audit_alloc()` 和 `proc` 文件系统暴露进程信息\n- **实时性保障**：RT 任务 fork 时保持调度策略和优先级",
      "similarity": 0.562491774559021,
      "chunks": [
        {
          "chunk_id": 16,
          "file_path": "kernel/fork.c",
          "start_line": 3480,
          "end_line": 3518,
          "content": [
            "int unshare_files(void)",
            "{",
            "\tstruct task_struct *task = current;",
            "\tstruct files_struct *old, *copy = NULL;",
            "\tint error;",
            "",
            "\terror = unshare_fd(CLONE_FILES, &copy);",
            "\tif (error || !copy)",
            "\t\treturn error;",
            "",
            "\told = task->files;",
            "\ttask_lock(task);",
            "\ttask->files = copy;",
            "\ttask_unlock(task);",
            "\tput_files_struct(old);",
            "\treturn 0;",
            "}",
            "int sysctl_max_threads(struct ctl_table *table, int write,",
            "\t\t       void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct ctl_table t;",
            "\tint ret;",
            "\tint threads = max_threads;",
            "\tint min = 1;",
            "\tint max = MAX_THREADS;",
            "",
            "\tt = *table;",
            "\tt.data = &threads;",
            "\tt.extra1 = &min;",
            "\tt.extra2 = &max;",
            "",
            "\tret = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);",
            "\tif (ret || !write)",
            "\t\treturn ret;",
            "",
            "\tmax_threads = threads;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "unshare_files, sysctl_max_threads",
          "description": "unshare_files函数复制当前进程的文件表结构并将其绑定到当前任务，sysctl_max_threads函数通过proc_dointvec_minmax接口限制系统最大线程数，支持读取和写入操作，其中写入时会更新全局max_threads变量。",
          "similarity": 0.5652948617935181
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/fork.c",
          "start_line": 1503,
          "end_line": 1608,
          "content": [
            "int replace_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)",
            "{",
            "\tstruct vm_area_struct *vma;",
            "\tstruct file *old_exe_file;",
            "\tint ret = 0;",
            "",
            "\t/* Forbid mm->exe_file change if old file still mapped. */",
            "\told_exe_file = get_mm_exe_file(mm);",
            "\tif (old_exe_file) {",
            "\t\tVMA_ITERATOR(vmi, mm, 0);",
            "\t\tmmap_read_lock(mm);",
            "\t\tfor_each_vma(vmi, vma) {",
            "\t\t\tif (!vma->vm_file)",
            "\t\t\t\tcontinue;",
            "\t\t\tif (path_equal(&vma->vm_file->f_path,",
            "\t\t\t\t       &old_exe_file->f_path)) {",
            "\t\t\t\tret = -EBUSY;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tmmap_read_unlock(mm);",
            "\t\tfput(old_exe_file);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tret = deny_write_access(new_exe_file);",
            "\tif (ret)",
            "\t\treturn -EACCES;",
            "\tget_file(new_exe_file);",
            "",
            "\t/* set the new file */",
            "\tmmap_write_lock(mm);",
            "\told_exe_file = rcu_dereference_raw(mm->exe_file);",
            "\trcu_assign_pointer(mm->exe_file, new_exe_file);",
            "\tmmap_write_unlock(mm);",
            "",
            "\tif (old_exe_file) {",
            "\t\tallow_write_access(old_exe_file);",
            "\t\tfput(old_exe_file);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void complete_vfork_done(struct task_struct *tsk)",
            "{",
            "\tstruct completion *vfork;",
            "",
            "\ttask_lock(tsk);",
            "\tvfork = tsk->vfork_done;",
            "\tif (likely(vfork)) {",
            "\t\ttsk->vfork_done = NULL;",
            "\t\tcomplete(vfork);",
            "\t}",
            "\ttask_unlock(tsk);",
            "}",
            "static int wait_for_vfork_done(struct task_struct *child,",
            "\t\t\t\tstruct completion *vfork)",
            "{",
            "\tunsigned int state = TASK_UNINTERRUPTIBLE|TASK_KILLABLE|TASK_FREEZABLE;",
            "\tint killed;",
            "",
            "\tcgroup_enter_frozen();",
            "\tkilled = wait_for_completion_state(vfork, state);",
            "\tcgroup_leave_frozen(false);",
            "",
            "\tif (killed) {",
            "\t\ttask_lock(child);",
            "\t\tchild->vfork_done = NULL;",
            "\t\ttask_unlock(child);",
            "\t}",
            "",
            "\tput_task_struct(child);",
            "\treturn killed;",
            "}",
            "static void mm_release(struct task_struct *tsk, struct mm_struct *mm)",
            "{",
            "\tuprobe_free_utask(tsk);",
            "",
            "\t/* Get rid of any cached register state */",
            "\tdeactivate_mm(tsk, mm);",
            "",
            "\t/*",
            "\t * Signal userspace if we're not exiting with a core dump",
            "\t * because we want to leave the value intact for debugging",
            "\t * purposes.",
            "\t */",
            "\tif (tsk->clear_child_tid) {",
            "\t\tif (atomic_read(&mm->mm_users) > 1) {",
            "\t\t\t/*",
            "\t\t\t * We don't check the error code - if userspace has",
            "\t\t\t * not set up a proper pointer then tough luck.",
            "\t\t\t */",
            "\t\t\tput_user(0, tsk->clear_child_tid);",
            "\t\t\tdo_futex(tsk->clear_child_tid, FUTEX_WAKE,",
            "\t\t\t\t\t1, NULL, NULL, 0, 0);",
            "\t\t}",
            "\t\ttsk->clear_child_tid = NULL;",
            "\t}",
            "",
            "\t/*",
            "\t * All done, finally we can wake up parent and return this mm to him.",
            "\t * Also kthread_stop() uses this completion for synchronization.",
            "\t */",
            "\tif (tsk->vfork_done)",
            "\t\tcomplete_vfork_done(tsk);",
            "}"
          ],
          "function_name": "replace_mm_exe_file, complete_vfork_done, wait_for_vfork_done, mm_release",
          "description": "替换当前mm的可执行文件，完成vfork同步操作并等待子进程完成，释放mm时通知父进程完成vfork同步。",
          "similarity": 0.5228396654129028
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/fork.c",
          "start_line": 3273,
          "end_line": 3450,
          "content": [
            "static int check_unshare_flags(unsigned long unshare_flags)",
            "{",
            "\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|",
            "\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|",
            "\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|",
            "\t\t\t\tCLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP|",
            "\t\t\t\tCLONE_NEWTIME))",
            "\t\treturn -EINVAL;",
            "\t/*",
            "\t * Not implemented, but pretend it works if there is nothing",
            "\t * to unshare.  Note that unsharing the address space or the",
            "\t * signal handlers also need to unshare the signal queues (aka",
            "\t * CLONE_THREAD).",
            "\t */",
            "\tif (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {",
            "\t\tif (!thread_group_empty(current))",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "\tif (unshare_flags & (CLONE_SIGHAND | CLONE_VM)) {",
            "\t\tif (refcount_read(&current->sighand->count) > 1)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "\tif (unshare_flags & CLONE_VM) {",
            "\t\tif (!current_is_single_threaded())",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)",
            "{",
            "\tstruct fs_struct *fs = current->fs;",
            "",
            "\tif (!(unshare_flags & CLONE_FS) || !fs)",
            "\t\treturn 0;",
            "",
            "\t/* don't need lock here; in the worst case we'll do useless copy */",
            "\tif (fs->users == 1)",
            "\t\treturn 0;",
            "",
            "\t*new_fsp = copy_fs_struct(fs);",
            "\tif (!*new_fsp)",
            "\t\treturn -ENOMEM;",
            "",
            "\treturn 0;",
            "}",
            "static int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)",
            "{",
            "\tstruct files_struct *fd = current->files;",
            "",
            "\tif ((unshare_flags & CLONE_FILES) &&",
            "\t    (fd && atomic_read(&fd->count) > 1)) {",
            "\t\tfd = dup_fd(fd, NULL);",
            "\t\tif (IS_ERR(fd))",
            "\t\t\treturn PTR_ERR(fd);",
            "\t\t*new_fdp = fd;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int ksys_unshare(unsigned long unshare_flags)",
            "{",
            "\tstruct fs_struct *fs, *new_fs = NULL;",
            "\tstruct files_struct *new_fd = NULL;",
            "\tstruct cred *new_cred = NULL;",
            "\tstruct nsproxy *new_nsproxy = NULL;",
            "\tint do_sysvsem = 0;",
            "\tint err;",
            "",
            "\t/*",
            "\t * If unsharing a user namespace must also unshare the thread group",
            "\t * and unshare the filesystem root and working directories.",
            "\t */",
            "\tif (unshare_flags & CLONE_NEWUSER)",
            "\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;",
            "\t/*",
            "\t * If unsharing vm, must also unshare signal handlers.",
            "\t */",
            "\tif (unshare_flags & CLONE_VM)",
            "\t\tunshare_flags |= CLONE_SIGHAND;",
            "\t/*",
            "\t * If unsharing a signal handlers, must also unshare the signal queues.",
            "\t */",
            "\tif (unshare_flags & CLONE_SIGHAND)",
            "\t\tunshare_flags |= CLONE_THREAD;",
            "\t/*",
            "\t * If unsharing namespace, must also unshare filesystem information.",
            "\t */",
            "\tif (unshare_flags & CLONE_NEWNS)",
            "\t\tunshare_flags |= CLONE_FS;",
            "",
            "\terr = check_unshare_flags(unshare_flags);",
            "\tif (err)",
            "\t\tgoto bad_unshare_out;",
            "\t/*",
            "\t * CLONE_NEWIPC must also detach from the undolist: after switching",
            "\t * to a new ipc namespace, the semaphore arrays from the old",
            "\t * namespace are unreachable.",
            "\t */",
            "\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))",
            "\t\tdo_sysvsem = 1;",
            "\terr = unshare_fs(unshare_flags, &new_fs);",
            "\tif (err)",
            "\t\tgoto bad_unshare_out;",
            "\terr = unshare_fd(unshare_flags, &new_fd);",
            "\tif (err)",
            "\t\tgoto bad_unshare_cleanup_fs;",
            "\terr = unshare_userns(unshare_flags, &new_cred);",
            "\tif (err)",
            "\t\tgoto bad_unshare_cleanup_fd;",
            "\terr = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,",
            "\t\t\t\t\t new_cred, new_fs);",
            "\tif (err)",
            "\t\tgoto bad_unshare_cleanup_cred;",
            "",
            "\tif (new_cred) {",
            "\t\terr = set_cred_ucounts(new_cred);",
            "\t\tif (err)",
            "\t\t\tgoto bad_unshare_cleanup_cred;",
            "\t}",
            "",
            "\tif (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {",
            "\t\tif (do_sysvsem) {",
            "\t\t\t/*",
            "\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().",
            "\t\t\t */",
            "\t\t\texit_sem(current);",
            "\t\t}",
            "\t\tif (unshare_flags & CLONE_NEWIPC) {",
            "\t\t\t/* Orphan segments in old ns (see sem above). */",
            "\t\t\texit_shm(current);",
            "\t\t\tshm_init_task(current);",
            "\t\t}",
            "",
            "\t\tif (new_nsproxy)",
            "\t\t\tswitch_task_namespaces(current, new_nsproxy);",
            "",
            "\t\ttask_lock(current);",
            "",
            "\t\tif (new_fs) {",
            "\t\t\tfs = current->fs;",
            "\t\t\tspin_lock(&fs->lock);",
            "\t\t\tcurrent->fs = new_fs;",
            "\t\t\tif (--fs->users)",
            "\t\t\t\tnew_fs = NULL;",
            "\t\t\telse",
            "\t\t\t\tnew_fs = fs;",
            "\t\t\tspin_unlock(&fs->lock);",
            "\t\t}",
            "",
            "\t\tif (new_fd)",
            "\t\t\tswap(current->files, new_fd);",
            "",
            "\t\ttask_unlock(current);",
            "",
            "\t\tif (new_cred) {",
            "\t\t\t/* Install the new user namespace */",
            "\t\t\tcommit_creds(new_cred);",
            "\t\t\tnew_cred = NULL;",
            "\t\t}",
            "\t}",
            "",
            "\tperf_event_namespaces(current);",
            "",
            "bad_unshare_cleanup_cred:",
            "\tif (new_cred)",
            "\t\tput_cred(new_cred);",
            "bad_unshare_cleanup_fd:",
            "\tif (new_fd)",
            "\t\tput_files_struct(new_fd);",
            "",
            "bad_unshare_cleanup_fs:",
            "\tif (new_fs)",
            "\t\tfree_fs_struct(new_fs);",
            "",
            "bad_unshare_out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "check_unshare_flags, unshare_fs, unshare_fd, ksys_unshare",
          "description": "检查unshare标志的有效性，验证CLONE_THREAD/CLONE_SIGHAND/CLONE_VM等标志组合是否合法，确保线程组为空且信号处理共享计数正确。随后依次处理文件系统、文件描述符、用户命名空间等资源的分离操作，最终通过switch_task_namespaces切换命名空间并更新任务结构体。",
          "similarity": 0.5173038244247437
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/fork.c",
          "start_line": 666,
          "end_line": 845,
          "content": [
            "static __latent_entropy int dup_mmap(struct mm_struct *mm,",
            "\t\t\t\t\tstruct mm_struct *oldmm)",
            "{",
            "\tstruct vm_area_struct *mpnt, *tmp;",
            "\tint retval;",
            "\tunsigned long charge = 0;",
            "\tLIST_HEAD(uf);",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\tuprobe_start_dup_mmap();",
            "\tif (mmap_write_lock_killable(oldmm)) {",
            "\t\tretval = -EINTR;",
            "\t\tgoto fail_uprobe_end;",
            "\t}",
            "\tflush_cache_dup_mm(oldmm);",
            "\tuprobe_dup_mmap(oldmm, mm);",
            "\t/*",
            "\t * Not linked in yet - no deadlock potential:",
            "\t */",
            "\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);",
            "",
            "\t/* No ordering required: file already has been exposed. */",
            "\tdup_mm_exe_file(mm, oldmm);",
            "",
            "\tmm->total_vm = oldmm->total_vm;",
            "\tmm->data_vm = oldmm->data_vm;",
            "\tmm->exec_vm = oldmm->exec_vm;",
            "\tmm->stack_vm = oldmm->stack_vm;",
            "",
            "\t/* Use __mt_dup() to efficiently build an identical maple tree. */",
            "\tretval = __mt_dup(&oldmm->mm_mt, &mm->mm_mt, GFP_KERNEL);",
            "\tif (unlikely(retval))",
            "\t\tgoto out;",
            "",
            "\tmt_clear_in_rcu(vmi.mas.tree);",
            "\tfor_each_vma(vmi, mpnt) {",
            "\t\tstruct file *file;",
            "",
            "\t\tvma_start_write(mpnt);",
            "\t\tif (mpnt->vm_flags & VM_DONTCOPY) {",
            "\t\t\tretval = vma_iter_clear_gfp(&vmi, mpnt->vm_start,",
            "\t\t\t\t\t\t    mpnt->vm_end, GFP_KERNEL);",
            "\t\t\tif (retval)",
            "\t\t\t\tgoto loop_out;",
            "",
            "\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tcharge = 0;",
            "\t\t/*",
            "\t\t * Don't duplicate many vmas if we've been oom-killed (for",
            "\t\t * example)",
            "\t\t */",
            "\t\tif (fatal_signal_pending(current)) {",
            "\t\t\tretval = -EINTR;",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t\tif (mpnt->vm_flags & VM_ACCOUNT) {",
            "\t\t\tunsigned long len = vma_pages(mpnt);",
            "",
            "\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */",
            "\t\t\t\tgoto fail_nomem;",
            "\t\t\tcharge = len;",
            "\t\t}",
            "\t\ttmp = vm_area_dup(mpnt);",
            "\t\tif (!tmp)",
            "\t\t\tgoto fail_nomem;",
            "",
            "\t\t/* track_pfn_copy() will later take care of copying internal state. */",
            "\t\tif (unlikely(tmp->vm_flags & VM_PFNMAP))",
            "\t\t\tuntrack_pfn_clear(tmp);",
            "",
            "\t\tretval = vma_dup_policy(mpnt, tmp);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_policy;",
            "\t\ttmp->vm_mm = mm;",
            "\t\tretval = dup_userfaultfd(tmp, &uf);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tif (tmp->vm_flags & VM_WIPEONFORK) {",
            "\t\t\t/*",
            "\t\t\t * VM_WIPEONFORK gets a clean slate in the child.",
            "\t\t\t * Don't prepare anon_vma until fault since we don't",
            "\t\t\t * copy page for current vma.",
            "\t\t\t */",
            "\t\t\ttmp->anon_vma = NULL;",
            "\t\t} else if (anon_vma_fork(tmp, mpnt))",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tvm_flags_clear(tmp, VM_LOCKED_MASK);",
            "\t\tfile = tmp->vm_file;",
            "\t\tif (file) {",
            "\t\t\tstruct address_space *mapping = file->f_mapping;",
            "",
            "\t\t\tget_file(file);",
            "\t\t\ti_mmap_lock_write(mapping);",
            "\t\t\tif (vma_is_shared_maywrite(tmp))",
            "\t\t\t\tmapping_allow_writable(mapping);",
            "\t\t\tflush_dcache_mmap_lock(mapping);",
            "\t\t\t/* insert tmp into the share list, just after mpnt */",
            "\t\t\tvma_interval_tree_insert_after(tmp, mpnt,",
            "\t\t\t\t\t&mapping->i_mmap);",
            "\t\t\tflush_dcache_mmap_unlock(mapping);",
            "\t\t\ti_mmap_unlock_write(mapping);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Copy/update hugetlb private vma information.",
            "\t\t */",
            "\t\tif (is_vm_hugetlb_page(tmp))",
            "\t\t\thugetlb_dup_vma_private(tmp);",
            "",
            "\t\t/*",
            "\t\t * Link the vma into the MT. After using __mt_dup(), memory",
            "\t\t * allocation is not necessary here, so it cannot fail.",
            "\t\t */",
            "\t\tvma_iter_bulk_store(&vmi, tmp);",
            "",
            "\t\tmm->map_count++;",
            "\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))",
            "\t\t\tretval = copy_page_range(tmp, mpnt);",
            "",
            "\t\tif (tmp->vm_ops && tmp->vm_ops->open)",
            "\t\t\ttmp->vm_ops->open(tmp);",
            "",
            "\t\tif (retval) {",
            "\t\t\tmpnt = vma_next(&vmi);",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t}",
            "\t/* a new mm has just been created */",
            "\tretval = arch_dup_mmap(oldmm, mm);",
            "loop_out:",
            "\tvma_iter_free(&vmi);",
            "\tif (!retval) {",
            "\t\tmt_set_in_rcu(vmi.mas.tree);",
            "\t\tksm_fork(mm, oldmm);",
            "\t\tkhugepaged_fork(mm, oldmm);",
            "\t} else {",
            "",
            "\t\t/*",
            "\t\t * The entire maple tree has already been duplicated. If the",
            "\t\t * mmap duplication fails, mark the failure point with",
            "\t\t * XA_ZERO_ENTRY. In exit_mmap(), if this marker is encountered,",
            "\t\t * stop releasing VMAs that have not been duplicated after this",
            "\t\t * point.",
            "\t\t */",
            "\t\tif (mpnt) {",
            "\t\t\tmas_set_range(&vmi.mas, mpnt->vm_start, mpnt->vm_end - 1);",
            "\t\t\tmas_store(&vmi.mas, XA_ZERO_ENTRY);",
            "\t\t\t/* Avoid OOM iterating a broken tree */",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t}",
            "\t\t/*",
            "\t\t * The mm_struct is going to exit, but the locks will be dropped",
            "\t\t * first.  Set the mm_struct as unstable is advisable as it is",
            "\t\t * not fully initialised.",
            "\t\t */",
            "\t\tset_bit(MMF_UNSTABLE, &mm->flags);",
            "\t}",
            "out:",
            "\tmmap_write_unlock(mm);",
            "\tflush_tlb_mm(oldmm);",
            "\tmmap_write_unlock(oldmm);",
            "\tif (!retval)",
            "\t\tdup_userfaultfd_complete(&uf);",
            "\telse",
            "\t\tdup_userfaultfd_fail(&uf);",
            "fail_uprobe_end:",
            "\tuprobe_end_dup_mmap();",
            "\treturn retval;",
            "",
            "fail_nomem_anon_vma_fork:",
            "\tmpol_put(vma_policy(tmp));",
            "fail_nomem_policy:",
            "\tvm_area_free(tmp);",
            "fail_nomem:",
            "\tretval = -ENOMEM;",
            "\tvm_unacct_memory(charge);",
            "\tgoto loop_out;",
            "}"
          ],
          "function_name": "dup_mmap",
          "description": "实现进程fork时的内存映射复制逻辑，深度遍历原进程的VMA结构创建副本，处理共享文件映射、hugetlb页等特殊内存类型，并管理OOM异常情况下的失败恢复。",
          "similarity": 0.5167399644851685
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/fork.c",
          "start_line": 986,
          "end_line": 1127,
          "content": [
            "static void mmdrop_async_fn(struct work_struct *work)",
            "{",
            "\tstruct mm_struct *mm;",
            "",
            "\tmm = container_of(work, struct mm_struct, async_put_work);",
            "\t__mmdrop(mm);",
            "}",
            "static void mmdrop_async(struct mm_struct *mm)",
            "{",
            "\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {",
            "\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);",
            "\t\tschedule_work(&mm->async_put_work);",
            "\t}",
            "}",
            "static inline void free_signal_struct(struct signal_struct *sig)",
            "{",
            "\ttaskstats_tgid_free(sig);",
            "\tsched_autogroup_exit(sig);",
            "\t/*",
            "\t * __mmdrop is not safe to call from softirq context on x86 due to",
            "\t * pgd_dtor so postpone it to the async context",
            "\t */",
            "\tif (sig->oom_mm)",
            "\t\tmmdrop_async(sig->oom_mm);",
            "\tkmem_cache_free(signal_cachep, sig);",
            "}",
            "static inline void put_signal_struct(struct signal_struct *sig)",
            "{",
            "\tif (refcount_dec_and_test(&sig->sigcnt))",
            "\t\tfree_signal_struct(sig);",
            "}",
            "void __put_task_struct(struct task_struct *tsk)",
            "{",
            "\tWARN_ON(!tsk->exit_state);",
            "\tWARN_ON(refcount_read(&tsk->usage));",
            "\tWARN_ON(tsk == current);",
            "",
            "\tsched_ext_free(tsk);",
            "\tio_uring_free(tsk);",
            "\tcgroup_free(tsk);",
            "\ttask_numa_free(tsk, true);",
            "\tsecurity_task_free(tsk);",
            "\texit_creds(tsk);",
            "\tdelayacct_tsk_free(tsk);",
            "\tput_signal_struct(tsk->signal);",
            "\tsched_core_free(tsk);",
            "\tfree_task(tsk);",
            "}",
            "void __put_task_struct_rcu_cb(struct rcu_head *rhp)",
            "{",
            "\tstruct task_struct *task = container_of(rhp, struct task_struct, rcu);",
            "",
            "\t__put_task_struct(task);",
            "}",
            "void __init __weak arch_task_cache_init(void) { }",
            "static void __init set_max_threads(unsigned int max_threads_suggested)",
            "{",
            "\tu64 threads;",
            "\tunsigned long nr_pages = PHYS_PFN(memblock_phys_mem_size() - memblock_reserved_size());",
            "",
            "\t/*",
            "\t * The number of threads shall be limited such that the thread",
            "\t * structures may only consume a small part of the available memory.",
            "\t */",
            "\tif (fls64(nr_pages) + fls64(PAGE_SIZE) > 64)",
            "\t\tthreads = MAX_THREADS;",
            "\telse",
            "\t\tthreads = div64_u64((u64) nr_pages * (u64) PAGE_SIZE,",
            "\t\t\t\t    (u64) THREAD_SIZE * 8UL);",
            "",
            "\tif (threads > max_threads_suggested)",
            "\t\tthreads = max_threads_suggested;",
            "",
            "\tmax_threads = clamp_t(u64, threads, MIN_THREADS, MAX_THREADS);",
            "}",
            "static void __init task_struct_whitelist(unsigned long *offset, unsigned long *size)",
            "{",
            "\t/* Fetch thread_struct whitelist for the architecture. */",
            "\tarch_thread_struct_whitelist(offset, size);",
            "",
            "\t/*",
            "\t * Handle zero-sized whitelist or empty thread_struct, otherwise",
            "\t * adjust offset to position of thread_struct in task_struct.",
            "\t */",
            "\tif (unlikely(*size == 0))",
            "\t\t*offset = 0;",
            "\telse",
            "\t\t*offset += offsetof(struct task_struct, thread);",
            "}",
            "void __init fork_init(void)",
            "{",
            "\tint i;",
            "#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR",
            "#ifndef ARCH_MIN_TASKALIGN",
            "#define ARCH_MIN_TASKALIGN\t0",
            "#endif",
            "\tint align = max_t(int, L1_CACHE_BYTES, ARCH_MIN_TASKALIGN);",
            "\tunsigned long useroffset, usersize;",
            "",
            "\t/* create a slab on which task_structs can be allocated */",
            "\ttask_struct_whitelist(&useroffset, &usersize);",
            "\t#ifdef CONFIG_IEE",
            "\ttask_struct_cachep = kmem_cache_create_usercopy(\"task_struct\",",
            "\t\t\tarch_task_struct_size, align,",
            "\t\t\tSLAB_PANIC|SLAB_ACCOUNT|SLAB_RED_ZONE,",
            "\t\t\tuseroffset, usersize, NULL);",
            "\t#else",
            "\ttask_struct_cachep = kmem_cache_create_usercopy(\"task_struct\",",
            "\t\t\tarch_task_struct_size, align,",
            "\t\t\tSLAB_PANIC|SLAB_ACCOUNT,",
            "\t\t\tuseroffset, usersize, NULL);",
            "\t#endif",
            "#endif",
            "",
            "\t/* do the arch specific task caches init */",
            "\tarch_task_cache_init();",
            "",
            "\tset_max_threads(MAX_THREADS);",
            "",
            "\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;",
            "\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;",
            "\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =",
            "\t\tinit_task.signal->rlim[RLIMIT_NPROC];",
            "",
            "\tfor (i = 0; i < UCOUNT_COUNTS; i++)",
            "\t\tinit_user_ns.ucount_max[i] = max_threads/2;",
            "",
            "\tset_userns_rlimit_max(&init_user_ns, UCOUNT_RLIMIT_NPROC,      RLIM_INFINITY);",
            "\tset_userns_rlimit_max(&init_user_ns, UCOUNT_RLIMIT_MSGQUEUE,   RLIM_INFINITY);",
            "\tset_userns_rlimit_max(&init_user_ns, UCOUNT_RLIMIT_SIGPENDING, RLIM_INFINITY);",
            "\tset_userns_rlimit_max(&init_user_ns, UCOUNT_RLIMIT_MEMLOCK,    RLIM_INFINITY);",
            "",
            "#ifdef CONFIG_VMAP_STACK",
            "\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"fork:vm_stack_cache\",",
            "\t\t\t  NULL, free_vm_stack_cache);",
            "#endif",
            "",
            "\tscs_init();",
            "",
            "\tlockdep_init_task(&init_task);",
            "\tuprobes_init();",
            "}"
          ],
          "function_name": "mmdrop_async_fn, mmdrop_async, free_signal_struct, put_signal_struct, __put_task_struct, __put_task_struct_rcu_cb, arch_task_cache_init, set_max_threads, task_struct_whitelist, fork_init",
          "description": "异步释放mm结构体以避免软中断上下文问题，处理信号结构体释放及任务结构体初始化，设置最大线程数并初始化任务缓存。",
          "similarity": 0.4996355473995209
        }
      ]
    },
    {
      "source_file": "kernel/task_work.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:33:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `task_work.c`\n\n---\n\n# task_work.c 技术文档\n\n## 文件概述\n\n`task_work.c` 实现了 Linux 内核中的 **任务工作（task work）机制**，允许内核在特定时机（如任务返回用户态、收到信号或处于 NMI 上下文）异步执行回调函数。该机制主要用于在不阻塞当前执行路径的前提下，将工作延迟到目标任务的合适上下文中执行，常用于安全模块（如 seccomp）、用户态通知、延迟清理等场景。\n\n任务工作队列是 **LIFO（后进先出）** 的，且不保证多个工作项之间的执行顺序。该机制支持多种通知模式，以适应不同的延迟和中断需求。\n\n## 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `task_work_add()` | 向指定任务添加一个回调工作项，并根据通知模式触发相应通知 |\n| `task_work_run()` | 执行当前任务的所有挂起工作项，通常在返回用户态或任务退出前调用 |\n| `task_work_cancel_match()` | 根据自定义匹配函数取消队列中的某个工作项 |\n| `task_work_cancel_func()` | 取消队列中第一个函数指针匹配指定函数的工作项 |\n| `task_work_cancel()` | 取消队列中指定的回调结构体（精确匹配指针） |\n\n### 主要数据结构\n\n- `struct callback_head`：通用回调结构体，包含 `next` 指针和 `func` 回调函数指针。\n- `enum task_work_notify_mode`：通知模式枚举，包括：\n  - `TWA_NONE`：不通知\n  - `TWA_RESUME`：在任务返回用户态或进入 guest 模式前执行\n  - `TWA_SIGNAL`：类似信号，可中断内核态任务并立即调度执行\n  - `TWA_SIGNAL_NO_IPI`：类似 `TWA_SIGNAL`，但不发送 IPI 强制重调度\n  - `TWA_NMI_CURRENT`：仅用于当前任务且在 NMI 上下文中，通过 IRQ work 触发\n\n### 全局变量\n\n- `work_exited`：特殊标记，表示任务已退出，不能再接受新工作。\n- `irq_work_NMI_resume`（per-CPU）：用于 `TWA_NMI_CURRENT` 模式下触发 `TIF_NOTIFY_RESUME` 标志。\n\n## 关键实现\n\n### 1. 无锁队列插入（LIFO）\n\n`task_work_add()` 使用 `try_cmpxchg()` 原子操作将新工作项插入到 `task->task_works` 链表头部，实现无锁并发插入。若发现 `task_works == &work_exited`，说明任务正在退出，返回 `-ESRCH`。\n\n### 2. 多种通知机制\n\n- **`TWA_RESUME`**：调用 `set_notify_resume(task)`，设置 `TIF_NOTIFY_RESUME` 标志，确保任务在 `exit_to_user_mode()` 路径中调用 `task_work_run()`。\n- **`TWA_SIGNAL` / `TWA_SIGNAL_NO_IPI`**：分别调用 `set_notify_signal()` 和 `__set_notify_signal()`，设置 `TIF_NOTIFY_SIGNAL` 标志，并可能发送 IPI 强制目标 CPU 重调度。\n- **`TWA_NMI_CURRENT`**：在 NMI 上下文中，通过 per-CPU 的 `irq_work` 触发软中断，在 IRQ 上下文中设置 `TIF_NOTIFY_RESUME`。\n\n### 3. 安全退出处理\n\n`task_work_run()` 在循环中：\n- 原子地将 `task_works` 置为 `NULL`（或 `&work_exited`，若任务正在退出）。\n- 若任务正在退出（`PF_EXITING`），则标记为 `work_exited`，防止后续 `task_work_add()` 成功。\n- 执行所有取出的工作项，每个 `work->func(work)` 可能再次调用 `task_work_add()`，因此需循环处理。\n\n### 4. 并发取消机制\n\n`task_work_cancel_match()` 使用 `task->pi_lock` 保护遍历和删除操作：\n- 遍历链表查找匹配项。\n- 使用 `try_cmpxchg()` 原子地移除节点，避免与 `task_work_add()` 或 `task_work_run()` 冲突。\n- 特别地，`task_work_run()` 在执行前会短暂获取 `pi_lock`，确保取消操作不会在执行过程中移除正在运行的工作项。\n\n### 5. KASAN 辅助栈记录\n\n在 `task_work_add()` 中，根据 `TWAF_NO_ALLOC` 标志调用 `kasan_record_aux_stack()` 或 `kasan_record_aux_stack_noalloc()`，用于在 KASAN 报告中显示工作项的分配调用栈。\n\n## 依赖关系\n\n- **`<linux/irq_work.h>`**：提供 `irq_work` 机制，用于 `TWA_NMI_CURRENT` 模式。\n- **`<linux/resume_user_mode.h>`**：提供 `set_notify_resume()` 等接口，用于在返回用户态时触发回调。\n- **`<linux/spinlock.h>`**：使用 `raw_spinlock_t`（`pi_lock`）保护取消操作。\n- **`<linux/task_work.h>`**：定义 `task_work_notify_mode`、`callback_head` 等核心类型。\n- **调度子系统**：依赖 `TIF_NOTIFY_RESUME` / `TIF_NOTIFY_SIGNAL` 标志位，在调度路径中调用 `task_work_run()`。\n- **KASAN**：集成内存错误检测的调用栈记录功能。\n\n## 使用场景\n\n1. **Seccomp 通知**：当 seccomp 策略需要异步通知用户态代理时，通过 `task_work_add()` 添加回调。\n2. **用户态延迟操作**：内核模块需要在任务下次返回用户态时执行清理或通知，使用 `TWA_RESUME`。\n3. **NMI 上下文延迟处理**：在不可睡眠的 NMI 处理程序中，通过 `TWA_NMI_CURRENT` 安全地安排后续工作。\n4. **信号式中断执行**：需要立即中断目标任务（即使在内核态）以执行高优先级工作，使用 `TWA_SIGNAL`。\n5. **资源回收**：在任务退出路径中，确保所有挂起工作被执行或清理。\n6. **动态取消机制**：如 seccomp 可能需要在条件变化时取消之前安排的工作，使用 `task_work_cancel_func()`。",
      "similarity": 0.5603557229042053,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/task_work.c",
          "start_line": 10,
          "end_line": 125,
          "content": [
            "static void task_work_set_notify_irq(struct irq_work *entry)",
            "{",
            "\ttest_and_set_tsk_thread_flag(current, TIF_NOTIFY_RESUME);",
            "}",
            "int task_work_add(struct task_struct *task, struct callback_head *work,",
            "\t\t  enum task_work_notify_mode notify)",
            "{",
            "\tstruct callback_head *head;",
            "\tint flags = notify & TWA_FLAGS;",
            "",
            "\tnotify &= ~TWA_FLAGS;",
            "\tif (notify == TWA_NMI_CURRENT) {",
            "\t\tif (WARN_ON_ONCE(task != current))",
            "\t\t\treturn -EINVAL;",
            "\t\tif (!IS_ENABLED(CONFIG_IRQ_WORK))",
            "\t\t\treturn -EINVAL;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Record the work call stack in order to print it in KASAN",
            "\t\t * reports.",
            "\t\t *",
            "\t\t * Note that stack allocation can fail if TWAF_NO_ALLOC flag",
            "\t\t * is set and new page is needed to expand the stack buffer.",
            "\t\t */",
            "\t\tif (flags & TWAF_NO_ALLOC)",
            "\t\t\tkasan_record_aux_stack_noalloc(work);",
            "\t\telse",
            "\t\t\tkasan_record_aux_stack(work);",
            "\t}",
            "",
            "\thead = READ_ONCE(task->task_works);",
            "\tdo {",
            "\t\tif (unlikely(head == &work_exited))",
            "\t\t\treturn -ESRCH;",
            "\t\twork->next = head;",
            "\t} while (!try_cmpxchg(&task->task_works, &head, work));",
            "",
            "\tswitch (notify) {",
            "\tcase TWA_NONE:",
            "\t\tbreak;",
            "\tcase TWA_RESUME:",
            "\t\tset_notify_resume(task);",
            "\t\tbreak;",
            "\tcase TWA_SIGNAL:",
            "\t\tset_notify_signal(task);",
            "\t\tbreak;",
            "\tcase TWA_SIGNAL_NO_IPI:",
            "\t\t__set_notify_signal(task);",
            "\t\tbreak;",
            "#ifdef CONFIG_IRQ_WORK",
            "\tcase TWA_NMI_CURRENT:",
            "\t\tirq_work_queue(this_cpu_ptr(&irq_work_NMI_resume));",
            "\t\tbreak;",
            "#endif",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static bool task_work_func_match(struct callback_head *cb, void *data)",
            "{",
            "\treturn cb->func == data;",
            "}",
            "static bool task_work_match(struct callback_head *cb, void *data)",
            "{",
            "\treturn cb == data;",
            "}",
            "bool task_work_cancel(struct task_struct *task, struct callback_head *cb)",
            "{",
            "\tstruct callback_head *ret;",
            "",
            "\tret = task_work_cancel_match(task, task_work_match, cb);",
            "",
            "\treturn ret == cb;",
            "}",
            "void task_work_run(void)",
            "{",
            "\tstruct task_struct *task = current;",
            "\tstruct callback_head *work, *head, *next;",
            "",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * work->func() can do task_work_add(), do not set",
            "\t\t * work_exited unless the list is empty.",
            "\t\t */",
            "\t\twork = READ_ONCE(task->task_works);",
            "\t\tdo {",
            "\t\t\thead = NULL;",
            "\t\t\tif (!work) {",
            "\t\t\t\tif (task->flags & PF_EXITING)",
            "\t\t\t\t\thead = &work_exited;",
            "\t\t\t\telse",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t} while (!try_cmpxchg(&task->task_works, &work, head));",
            "",
            "\t\tif (!work)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * Synchronize with task_work_cancel_match(). It can not remove",
            "\t\t * the first entry == work, cmpxchg(task_works) must fail.",
            "\t\t * But it can remove another entry from the ->next list.",
            "\t\t */",
            "\t\traw_spin_lock_irq(&task->pi_lock);",
            "\t\traw_spin_unlock_irq(&task->pi_lock);",
            "",
            "\t\tdo {",
            "\t\t\tnext = work->next;",
            "\t\t\twork->func(work);",
            "\t\t\twork = next;",
            "\t\t\tcond_resched();",
            "\t\t} while (work);",
            "\t}",
            "}"
          ],
          "function_name": "task_work_set_notify_irq, task_work_add, task_work_func_match, task_work_match, task_work_cancel, task_work_run",
          "description": "实现任务工作队列的添加、匹配、取消及执行逻辑，支持多种通知模式（如RESUME/SIGNAL/NMI），通过原子操作维护链表并同步执行回调函数",
          "similarity": 0.515529990196228
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/task_work.c",
          "start_line": 1,
          "end_line": 9,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/task_work.h>",
            "#include <linux/resume_user_mode.h>",
            "",
            "static struct callback_head work_exited; /* all we need is ->next == NULL */",
            "",
            "#ifdef CONFIG_IRQ_WORK"
          ],
          "function_name": null,
          "description": "声明用于任务工作通知的静态变量work_exited，该变量通过next指针判断任务工作链表是否为空，上下文不完整",
          "similarity": 0.43356913328170776
        }
      ]
    }
  ]
}