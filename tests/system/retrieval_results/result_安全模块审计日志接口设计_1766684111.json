{
  "query": "安全模块审计日志接口设计",
  "timestamp": "2025-12-26 01:35:11",
  "retrieved_files": [
    {
      "source_file": "kernel/auditsc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:53:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `auditsc.c`\n\n---\n\n# auditsc.c 技术文档\n\n## 1. 文件概述\n\n`auditsc.c` 是 Linux 内核审计子系统的核心组件之一，专门负责**系统调用级别的审计功能**。该文件实现了系统调用进入和退出时的审计数据收集、过滤规则匹配、辅助数据管理以及与 LSM（Linux Security Module）安全模块的集成。它为内核审计框架提供了系统调用上下文的完整记录能力，支持对文件操作、网络配置、进程执行等关键系统行为进行细粒度监控和日志记录。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`audit_aux_data`**: 审计辅助数据的通用基类，用于链式存储额外的审计信息\n- **`audit_aux_data_pids`**: 存储目标进程相关信息（PID、UID、会话ID、安全上下文等），最多支持16个目标进程\n- **`audit_aux_data_bprm_fcaps`**: 记录可执行文件能力（capabilities）变更信息，包括文件能力、旧进程能力和新进程能力\n- **`audit_tree_refs`**: 用于管理文件系统审计树（audit tree）引用的链表结构，每个节点包含31个`audit_chunk`指针\n- **`audit_nfcfgop_tab`**: 网络过滤配置操作的枚举到字符串映射表，支持 iptables 和 nftables 操作审计\n\n### 关键函数\n\n- **`audit_match_perm()`**: 根据系统调用类型和访问模式（读/写/属性/执行）匹配审计权限过滤规则\n- **`audit_match_filetype()`**: 匹配审计上下文中文件的类型（如普通文件、目录、设备文件等）\n- **`audit_set_auditable()`**: 将审计上下文标记为可审计状态，设置优先级和记录状态\n- **`put_tree_ref()` / `grow_tree_refs()` / `unroll_tree_refs()`**: 管理审计树引用的动态分配和释放\n\n### 全局变量\n\n- **`audit_n_rules`**: 当前系统中审计规则的总数\n- **`audit_signals`**: 控制是否收集信号发送相关的审计数据\n\n## 3. 关键实现\n\n### 系统调用分类与权限匹配\n\n`audit_match_perm()` 函数实现了复杂的系统调用分类逻辑：\n- **原生系统调用**（`AUDITSC_NATIVE`）：通过预定义的系统调用类（`AUDIT_CLASS_WRITE`、`AUDIT_CLASS_READ` 等）进行匹配\n- **兼容模式系统调用**（`AUDITSC_COMPAT`）：针对32位兼容层的特殊处理\n- **特殊系统调用处理**：\n  - `open`/`openat`：直接从参数中提取访问模式\n  - `openat2`：从 `struct open_how` 的 flags 字段解析访问模式\n  - `socketcall`：特殊处理 `SYS_BIND` 操作\n  - `execve`：匹配执行权限\n\n### 审计树引用管理\n\n采用**固定大小数组链表**的设计模式管理 `audit_chunk` 引用：\n- 每个 `audit_tree_refs` 节点包含31个指针槽位\n- 初始状态为 `(NULL, NULL, 0)`，首次分配后变为 `(p, p, 31)`\n- 通过 `tree_count` 跟踪当前节点的可用槽位数\n- 不支持收缩，仅在上下文释放时统一清理\n\n### 辅助数据扩展机制\n\n通过**继承式链表设计**支持多种辅助数据类型：\n- 所有辅助数据结构都以 `audit_aux_data` 作为第一个成员\n- 通过 `type` 字段区分不同类型的数据\n- 支持动态添加新的辅助数据类型而无需修改核心逻辑\n\n### 网络配置审计支持\n\n内置对现代网络过滤框架的完整支持：\n- **iptables**（`xt_*` 操作）\n- **nftables**（`nft_*` 操作，包括表、链、规则、集合、对象、流表等）\n- 提供操作码到可读字符串的映射，便于用户空间解析\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n\n- **审计核心**：`<linux/audit.h>`、`\"audit.h\"`\n- **系统调用**：`<asm/syscall.h>`、`<linux/syscalls.h>`\n- **安全模块**：`<linux/security.h>`、`<linux/capability.h>`\n- **文件系统**：`<linux/fs.h>`、`<linux/namei.h>`、`<linux/mount.h>`\n- **网络**：`<linux/socket.h>`、`<uapi/linux/netfilter/nf_tables.h>`\n- **进程管理**：`<linux/binfmts.h>`、`<linux/personality.h>`\n\n### 功能依赖\n\n- **审计框架**：依赖 `audit.c` 提供的核心审计功能\n- **LSM 框架**：与 SELinux、Smack 等安全模块集成，支持安全上下文审计\n- **系统调用拦截**：依赖架构特定的系统调用入口/出口钩子（如 `entry.S`）\n- **文件系统通知**：与 `fsnotify` 子系统协作实现文件访问审计\n\n## 5. 使用场景\n\n### 系统调用审计\n\n- **文件操作监控**：记录所有文件创建、删除、重命名、权限修改等操作\n- **进程执行跟踪**：审计 `execve` 系统调用，记录命令行参数和环境变量\n- **网络配置变更**：监控 iptables/nftables 规则的添加、删除、修改\n- **能力变更审计**：跟踪进程能力的获取、丢弃和继承过程\n\n### 安全合规\n\n- **LSPP 认证**：支持主体/客体安全上下文标签审计，满足高安全等级要求\n- **访问控制审计**：记录所有违反 MAC（强制访问控制）策略的访问尝试\n- **特权操作监控**：审计所有涉及 root 权限或特殊能力的系统调用\n\n### 故障诊断与取证\n\n- **系统行为分析**：通过审计日志重建系统调用序列，分析异常行为\n- **安全事件响应**：在安全事件发生后，通过审计记录追踪攻击路径\n- **合规性报告**：生成满足法规要求的系统活动审计报告",
      "similarity": 0.6244949698448181,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/auditsc.c",
          "start_line": 1083,
          "end_line": 1295,
          "content": [
            "static inline void audit_free_context(struct audit_context *context)",
            "{",
            "\t/* resetting is extra work, but it is likely just noise */",
            "\taudit_reset_context(context);",
            "\taudit_proctitle_free(context);",
            "\tfree_tree_refs(context);",
            "\tkfree(context->filterkey);",
            "\tkfree(context);",
            "}",
            "static int audit_log_pid_context(struct audit_context *context, pid_t pid,",
            "\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,",
            "\t\t\t\t u32 sid, char *comm)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tchar *ctx = NULL;",
            "\tu32 len;",
            "\tint rc = 0;",
            "",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);",
            "\tif (!ab)",
            "\t\treturn rc;",
            "",
            "\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,",
            "\t\t\t from_kuid(&init_user_ns, auid),",
            "\t\t\t from_kuid(&init_user_ns, uid), sessionid);",
            "\tif (sid) {",
            "\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {",
            "\t\t\taudit_log_format(ab, \" obj=(none)\");",
            "\t\t\trc = 1;",
            "\t\t} else {",
            "\t\t\taudit_log_format(ab, \" obj=%s\", ctx);",
            "\t\t\tsecurity_release_secctx(ctx, len);",
            "\t\t}",
            "\t}",
            "\taudit_log_format(ab, \" ocomm=\");",
            "\taudit_log_untrustedstring(ab, comm);",
            "\taudit_log_end(ab);",
            "",
            "\treturn rc;",
            "}",
            "static void audit_log_execve_info(struct audit_context *context,",
            "\t\t\t\t  struct audit_buffer **ab)",
            "{",
            "\tlong len_max;",
            "\tlong len_rem;",
            "\tlong len_full;",
            "\tlong len_buf;",
            "\tlong len_abuf = 0;",
            "\tlong len_tmp;",
            "\tbool require_data;",
            "\tbool encode;",
            "\tunsigned int iter;",
            "\tunsigned int arg;",
            "\tchar *buf_head;",
            "\tchar *buf;",
            "\tconst char __user *p = (const char __user *)current->mm->arg_start;",
            "",
            "\t/* NOTE: this buffer needs to be large enough to hold all the non-arg",
            "\t *       data we put in the audit record for this argument (see the",
            "\t *       code below) ... at this point in time 96 is plenty */",
            "\tchar abuf[96];",
            "",
            "\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the",
            "\t *       current value of 7500 is not as important as the fact that it",
            "\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle",
            "\t *       room if we go over a little bit in the logging below */",
            "\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);",
            "\tlen_max = MAX_EXECVE_AUDIT_LEN;",
            "",
            "\t/* scratch buffer to hold the userspace args */",
            "\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);",
            "\tif (!buf_head) {",
            "\t\taudit_panic(\"out of memory for argv string\");",
            "\t\treturn;",
            "\t}",
            "\tbuf = buf_head;",
            "",
            "\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);",
            "",
            "\tlen_rem = len_max;",
            "\tlen_buf = 0;",
            "\tlen_full = 0;",
            "\trequire_data = true;",
            "\tencode = false;",
            "\titer = 0;",
            "\targ = 0;",
            "\tdo {",
            "\t\t/* NOTE: we don't ever want to trust this value for anything",
            "\t\t *       serious, but the audit record format insists we",
            "\t\t *       provide an argument length for really long arguments,",
            "\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but",
            "\t\t *       to use strncpy_from_user() to obtain this value for",
            "\t\t *       recording in the log, although we don't use it",
            "\t\t *       anywhere here to avoid a double-fetch problem */",
            "\t\tif (len_full == 0)",
            "\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;",
            "",
            "\t\t/* read more data from userspace */",
            "\t\tif (require_data) {",
            "\t\t\t/* can we make more room in the buffer? */",
            "\t\t\tif (buf != buf_head) {",
            "\t\t\t\tmemmove(buf_head, buf, len_buf);",
            "\t\t\t\tbuf = buf_head;",
            "\t\t\t}",
            "",
            "\t\t\t/* fetch as much as we can of the argument */",
            "\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,",
            "\t\t\t\t\t\t    len_max - len_buf);",
            "\t\t\tif (len_tmp == -EFAULT) {",
            "\t\t\t\t/* unable to copy from userspace */",
            "\t\t\t\tsend_sig(SIGKILL, current, 0);",
            "\t\t\t\tgoto out;",
            "\t\t\t} else if (len_tmp == (len_max - len_buf)) {",
            "\t\t\t\t/* buffer is not large enough */",
            "\t\t\t\trequire_data = true;",
            "\t\t\t\t/* NOTE: if we are going to span multiple",
            "\t\t\t\t *       buffers force the encoding so we stand",
            "\t\t\t\t *       a chance at a sane len_full value and",
            "\t\t\t\t *       consistent record encoding */",
            "\t\t\t\tencode = true;",
            "\t\t\t\tlen_full = len_full * 2;",
            "\t\t\t\tp += len_tmp;",
            "\t\t\t} else {",
            "\t\t\t\trequire_data = false;",
            "\t\t\t\tif (!encode)",
            "\t\t\t\t\tencode = audit_string_contains_control(",
            "\t\t\t\t\t\t\t\tbuf, len_tmp);",
            "\t\t\t\t/* try to use a trusted value for len_full */",
            "\t\t\t\tif (len_full < len_max)",
            "\t\t\t\t\tlen_full = (encode ?",
            "\t\t\t\t\t\t    len_tmp * 2 : len_tmp);",
            "\t\t\t\tp += len_tmp + 1;",
            "\t\t\t}",
            "\t\t\tlen_buf += len_tmp;",
            "\t\t\tbuf_head[len_buf] = '\\0';",
            "",
            "\t\t\t/* length of the buffer in the audit record? */",
            "\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);",
            "\t\t}",
            "",
            "\t\t/* write as much as we can to the audit log */",
            "\t\tif (len_buf >= 0) {",
            "\t\t\t/* NOTE: some magic numbers here - basically if we",
            "\t\t\t *       can't fit a reasonable amount of data into the",
            "\t\t\t *       existing audit buffer, flush it and start with",
            "\t\t\t *       a new buffer */",
            "\t\t\tif ((sizeof(abuf) + 8) > len_rem) {",
            "\t\t\t\tlen_rem = len_max;",
            "\t\t\t\taudit_log_end(*ab);",
            "\t\t\t\t*ab = audit_log_start(context,",
            "\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);",
            "\t\t\t\tif (!*ab)",
            "\t\t\t\t\tgoto out;",
            "\t\t\t}",
            "",
            "\t\t\t/* create the non-arg portion of the arg record */",
            "\t\t\tlen_tmp = 0;",
            "\t\t\tif (require_data || (iter > 0) ||",
            "\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {",
            "\t\t\t\tif (iter == 0) {",
            "\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],",
            "\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,",
            "\t\t\t\t\t\t\t\" a%d_len=%lu\",",
            "\t\t\t\t\t\t\targ, len_full);",
            "\t\t\t\t}",
            "\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],",
            "\t\t\t\t\t\t    sizeof(abuf) - len_tmp,",
            "\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);",
            "\t\t\t} else",
            "\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],",
            "\t\t\t\t\t\t    sizeof(abuf) - len_tmp,",
            "\t\t\t\t\t\t    \" a%d=\", arg);",
            "\t\t\tWARN_ON(len_tmp >= sizeof(abuf));",
            "\t\t\tabuf[sizeof(abuf) - 1] = '\\0';",
            "",
            "\t\t\t/* log the arg in the audit record */",
            "\t\t\taudit_log_format(*ab, \"%s\", abuf);",
            "\t\t\tlen_rem -= len_tmp;",
            "\t\t\tlen_tmp = len_buf;",
            "\t\t\tif (encode) {",
            "\t\t\t\tif (len_abuf > len_rem)",
            "\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */",
            "\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);",
            "\t\t\t\tlen_rem -= len_tmp * 2;",
            "\t\t\t\tlen_abuf -= len_tmp * 2;",
            "\t\t\t} else {",
            "\t\t\t\tif (len_abuf > len_rem)",
            "\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */",
            "\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);",
            "\t\t\t\tlen_rem -= len_tmp + 2;",
            "\t\t\t\t/* don't subtract the \"2\" because we still need",
            "\t\t\t\t * to add quotes to the remaining string */",
            "\t\t\t\tlen_abuf -= len_tmp;",
            "\t\t\t}",
            "\t\t\tlen_buf -= len_tmp;",
            "\t\t\tbuf += len_tmp;",
            "\t\t}",
            "",
            "\t\t/* ready to move to the next argument? */",
            "\t\tif ((len_buf == 0) && !require_data) {",
            "\t\t\targ++;",
            "\t\t\titer = 0;",
            "\t\t\tlen_full = 0;",
            "\t\t\trequire_data = true;",
            "\t\t\tencode = false;",
            "\t\t}",
            "\t} while (arg < context->execve.argc);",
            "",
            "\t/* NOTE: the caller handles the final audit_log_end() call */",
            "",
            "out:",
            "\tkfree(buf_head);",
            "}"
          ],
          "function_name": "audit_free_context, audit_log_pid_context, audit_log_execve_info",
          "description": "负责审计上下文释放、进程PID上下文日志记录及execve参数审计日志生成，包含用户态字符串复制与缓冲区管理逻辑",
          "similarity": 0.6461294293403625
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/auditsc.c",
          "start_line": 1299,
          "end_line": 1487,
          "content": [
            "static void audit_log_cap(struct audit_buffer *ab, char *prefix,",
            "\t\t\t  kernel_cap_t *cap)",
            "{",
            "\tif (cap_isclear(*cap)) {",
            "\t\taudit_log_format(ab, \" %s=0\", prefix);",
            "\t\treturn;",
            "\t}",
            "\taudit_log_format(ab, \" %s=%016llx\", prefix, cap->val);",
            "}",
            "static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)",
            "{",
            "\tif (name->fcap_ver == -1) {",
            "\t\taudit_log_format(ab, \" cap_fe=? cap_fver=? cap_fp=? cap_fi=?\");",
            "\t\treturn;",
            "\t}",
            "\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);",
            "\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);",
            "\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x cap_frootid=%d\",",
            "\t\t\t name->fcap.fE, name->fcap_ver,",
            "\t\t\t from_kuid(&init_user_ns, name->fcap.rootid));",
            "}",
            "static void audit_log_time(struct audit_context *context, struct audit_buffer **ab)",
            "{",
            "\tconst struct audit_ntp_data *ntp = &context->time.ntp_data;",
            "\tconst struct timespec64 *tk = &context->time.tk_injoffset;",
            "\tstatic const char * const ntp_name[] = {",
            "\t\t\"offset\",",
            "\t\t\"freq\",",
            "\t\t\"status\",",
            "\t\t\"tai\",",
            "\t\t\"tick\",",
            "\t\t\"adjust\",",
            "\t};",
            "\tint type;",
            "",
            "\tif (context->type == AUDIT_TIME_ADJNTPVAL) {",
            "\t\tfor (type = 0; type < AUDIT_NTP_NVALS; type++) {",
            "\t\t\tif (ntp->vals[type].newval != ntp->vals[type].oldval) {",
            "\t\t\t\tif (!*ab) {",
            "\t\t\t\t\t*ab = audit_log_start(context,",
            "\t\t\t\t\t\t\tGFP_KERNEL,",
            "\t\t\t\t\t\t\tAUDIT_TIME_ADJNTPVAL);",
            "\t\t\t\t\tif (!*ab)",
            "\t\t\t\t\t\treturn;",
            "\t\t\t\t}",
            "\t\t\t\taudit_log_format(*ab, \"op=%s old=%lli new=%lli\",",
            "\t\t\t\t\t\t ntp_name[type],",
            "\t\t\t\t\t\t ntp->vals[type].oldval,",
            "\t\t\t\t\t\t ntp->vals[type].newval);",
            "\t\t\t\taudit_log_end(*ab);",
            "\t\t\t\t*ab = NULL;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif (tk->tv_sec != 0 || tk->tv_nsec != 0) {",
            "\t\tif (!*ab) {",
            "\t\t\t*ab = audit_log_start(context, GFP_KERNEL,",
            "\t\t\t\t\t      AUDIT_TIME_INJOFFSET);",
            "\t\t\tif (!*ab)",
            "\t\t\t\treturn;",
            "\t\t}",
            "\t\taudit_log_format(*ab, \"sec=%lli nsec=%li\",",
            "\t\t\t\t (long long)tk->tv_sec, tk->tv_nsec);",
            "\t\taudit_log_end(*ab);",
            "\t\t*ab = NULL;",
            "\t}",
            "}",
            "static void show_special(struct audit_context *context, int *call_panic)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tint i;",
            "",
            "\tab = audit_log_start(context, GFP_KERNEL, context->type);",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tswitch (context->type) {",
            "\tcase AUDIT_SOCKETCALL: {",
            "\t\tint nargs = context->socketcall.nargs;",
            "",
            "\t\taudit_log_format(ab, \"nargs=%d\", nargs);",
            "\t\tfor (i = 0; i < nargs; i++)",
            "\t\t\taudit_log_format(ab, \" a%d=%lx\", i,",
            "\t\t\t\tcontext->socketcall.args[i]);",
            "\t\tbreak; }",
            "\tcase AUDIT_IPC: {",
            "\t\tu32 osid = context->ipc.osid;",
            "",
            "\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",",
            "\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),",
            "\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),",
            "\t\t\t\t context->ipc.mode);",
            "\t\tif (osid) {",
            "\t\t\tchar *ctx = NULL;",
            "\t\t\tu32 len;",
            "",
            "\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {",
            "\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);",
            "\t\t\t\t*call_panic = 1;",
            "\t\t\t} else {",
            "\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);",
            "\t\t\t\tsecurity_release_secctx(ctx, len);",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (context->ipc.has_perm) {",
            "\t\t\taudit_log_end(ab);",
            "\t\t\tab = audit_log_start(context, GFP_KERNEL,",
            "\t\t\t\t\t     AUDIT_IPC_SET_PERM);",
            "\t\t\tif (unlikely(!ab))",
            "\t\t\t\treturn;",
            "\t\t\taudit_log_format(ab,",
            "\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",",
            "\t\t\t\tcontext->ipc.qbytes,",
            "\t\t\t\tcontext->ipc.perm_uid,",
            "\t\t\t\tcontext->ipc.perm_gid,",
            "\t\t\t\tcontext->ipc.perm_mode);",
            "\t\t}",
            "\t\tbreak; }",
            "\tcase AUDIT_MQ_OPEN:",
            "\t\taudit_log_format(ab,",
            "\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"",
            "\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",",
            "\t\t\tcontext->mq_open.oflag, context->mq_open.mode,",
            "\t\t\tcontext->mq_open.attr.mq_flags,",
            "\t\t\tcontext->mq_open.attr.mq_maxmsg,",
            "\t\t\tcontext->mq_open.attr.mq_msgsize,",
            "\t\t\tcontext->mq_open.attr.mq_curmsgs);",
            "\t\tbreak;",
            "\tcase AUDIT_MQ_SENDRECV:",
            "\t\taudit_log_format(ab,",
            "\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"",
            "\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",",
            "\t\t\tcontext->mq_sendrecv.mqdes,",
            "\t\t\tcontext->mq_sendrecv.msg_len,",
            "\t\t\tcontext->mq_sendrecv.msg_prio,",
            "\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,",
            "\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);",
            "\t\tbreak;",
            "\tcase AUDIT_MQ_NOTIFY:",
            "\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",",
            "\t\t\t\tcontext->mq_notify.mqdes,",
            "\t\t\t\tcontext->mq_notify.sigev_signo);",
            "\t\tbreak;",
            "\tcase AUDIT_MQ_GETSETATTR: {",
            "\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;",
            "",
            "\t\taudit_log_format(ab,",
            "\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"",
            "\t\t\t\"mq_curmsgs=%ld \",",
            "\t\t\tcontext->mq_getsetattr.mqdes,",
            "\t\t\tattr->mq_flags, attr->mq_maxmsg,",
            "\t\t\tattr->mq_msgsize, attr->mq_curmsgs);",
            "\t\tbreak; }",
            "\tcase AUDIT_CAPSET:",
            "\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);",
            "\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);",
            "\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);",
            "\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);",
            "\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);",
            "\t\tbreak;",
            "\tcase AUDIT_MMAP:",
            "\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,",
            "\t\t\t\t context->mmap.flags);",
            "\t\tbreak;",
            "\tcase AUDIT_OPENAT2:",
            "\t\taudit_log_format(ab, \"oflag=0%llo mode=0%llo resolve=0x%llx\",",
            "\t\t\t\t context->openat2.flags,",
            "\t\t\t\t context->openat2.mode,",
            "\t\t\t\t context->openat2.resolve);",
            "\t\tbreak;",
            "\tcase AUDIT_EXECVE:",
            "\t\taudit_log_execve_info(context, &ab);",
            "\t\tbreak;",
            "\tcase AUDIT_KERN_MODULE:",
            "\t\taudit_log_format(ab, \"name=\");",
            "\t\tif (context->module.name) {",
            "\t\t\taudit_log_untrustedstring(ab, context->module.name);",
            "\t\t} else",
            "\t\t\taudit_log_format(ab, \"(null)\");",
            "",
            "\t\tbreak;",
            "\tcase AUDIT_TIME_ADJNTPVAL:",
            "\tcase AUDIT_TIME_INJOFFSET:",
            "\t\t/* this call deviates from the rest, eating the buffer */",
            "\t\taudit_log_time(context, &ab);",
            "\t\tbreak;",
            "\t}",
            "\taudit_log_end(ab);",
            "}"
          ],
          "function_name": "audit_log_cap, audit_log_fcaps, audit_log_time, show_special",
          "description": "实现能力标识、文件能力、时间调整等特殊审计事件的格式化记录，根据上下文类型触发不同日志格式化规则",
          "similarity": 0.6358025074005127
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/auditsc.c",
          "start_line": 1644,
          "end_line": 1818,
          "content": [
            "static void audit_log_uring(struct audit_context *ctx)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tconst struct cred *cred;",
            "",
            "\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);",
            "\tif (!ab)",
            "\t\treturn;",
            "\tcred = current_cred();",
            "\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);",
            "\tif (ctx->return_valid != AUDITSC_INVALID)",
            "\t\taudit_log_format(ab, \" success=%s exit=%ld\",",
            "\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?",
            "\t\t\t\t  \"yes\" : \"no\"),",
            "\t\t\t\t ctx->return_code);",
            "\taudit_log_format(ab,",
            "\t\t\t \" items=%d\"",
            "\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"",
            "\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",",
            "\t\t\t ctx->name_count,",
            "\t\t\t task_ppid_nr(current), task_tgid_nr(current),",
            "\t\t\t from_kuid(&init_user_ns, cred->uid),",
            "\t\t\t from_kgid(&init_user_ns, cred->gid),",
            "\t\t\t from_kuid(&init_user_ns, cred->euid),",
            "\t\t\t from_kuid(&init_user_ns, cred->suid),",
            "\t\t\t from_kuid(&init_user_ns, cred->fsuid),",
            "\t\t\t from_kgid(&init_user_ns, cred->egid),",
            "\t\t\t from_kgid(&init_user_ns, cred->sgid),",
            "\t\t\t from_kgid(&init_user_ns, cred->fsgid));",
            "\taudit_log_task_context(ab);",
            "\taudit_log_key(ab, ctx->filterkey);",
            "\taudit_log_end(ab);",
            "}",
            "static void audit_log_exit(void)",
            "{",
            "\tint i, call_panic = 0;",
            "\tstruct audit_context *context = audit_context();",
            "\tstruct audit_buffer *ab;",
            "\tstruct audit_aux_data *aux;",
            "\tstruct audit_names *n;",
            "",
            "\tcontext->personality = current->personality;",
            "",
            "\tswitch (context->context) {",
            "\tcase AUDIT_CTX_SYSCALL:",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);",
            "\t\tif (!ab)",
            "\t\t\treturn;",
            "\t\taudit_log_format(ab, \"arch=%x syscall=%d\",",
            "\t\t\t\t context->arch, context->major);",
            "\t\tif (context->personality != PER_LINUX)",
            "\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);",
            "\t\tif (context->return_valid != AUDITSC_INVALID)",
            "\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",",
            "\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?",
            "\t\t\t\t\t  \"yes\" : \"no\"),",
            "\t\t\t\t\t context->return_code);",
            "\t\taudit_log_format(ab,",
            "\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",",
            "\t\t\t\t context->argv[0],",
            "\t\t\t\t context->argv[1],",
            "\t\t\t\t context->argv[2],",
            "\t\t\t\t context->argv[3],",
            "\t\t\t\t context->name_count);",
            "\t\taudit_log_task_info(ab);",
            "\t\taudit_log_key(ab, context->filterkey);",
            "\t\taudit_log_end(ab);",
            "\t\tbreak;",
            "\tcase AUDIT_CTX_URING:",
            "\t\taudit_log_uring(context);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t\tbreak;",
            "\t}",
            "",
            "\tfor (aux = context->aux; aux; aux = aux->next) {",
            "",
            "\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);",
            "\t\tif (!ab)",
            "\t\t\tcontinue; /* audit_panic has been called */",
            "",
            "\t\tswitch (aux->type) {",
            "",
            "\t\tcase AUDIT_BPRM_FCAPS: {",
            "\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;",
            "",
            "\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);",
            "\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);",
            "\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);",
            "\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);",
            "\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);",
            "\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);",
            "\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);",
            "\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);",
            "\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);",
            "\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);",
            "\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);",
            "\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);",
            "\t\t\taudit_log_format(ab, \" frootid=%d\",",
            "\t\t\t\t\t from_kuid(&init_user_ns,",
            "\t\t\t\t\t\t   axs->fcap.rootid));",
            "\t\t\tbreak; }",
            "",
            "\t\t}",
            "\t\taudit_log_end(ab);",
            "\t}",
            "",
            "\tif (context->type)",
            "\t\tshow_special(context, &call_panic);",
            "",
            "\tif (context->fds[0] >= 0) {",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);",
            "\t\tif (ab) {",
            "\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",",
            "\t\t\t\t\tcontext->fds[0], context->fds[1]);",
            "\t\t\taudit_log_end(ab);",
            "\t\t}",
            "\t}",
            "",
            "\tif (context->sockaddr_len) {",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);",
            "\t\tif (ab) {",
            "\t\t\taudit_log_format(ab, \"saddr=\");",
            "\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,",
            "\t\t\t\t\tcontext->sockaddr_len);",
            "\t\t\taudit_log_end(ab);",
            "\t\t}",
            "\t}",
            "",
            "\tfor (aux = context->aux_pids; aux; aux = aux->next) {",
            "\t\tstruct audit_aux_data_pids *axs = (void *)aux;",
            "",
            "\t\tfor (i = 0; i < axs->pid_count; i++)",
            "\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],",
            "\t\t\t\t\t\t  axs->target_auid[i],",
            "\t\t\t\t\t\t  axs->target_uid[i],",
            "\t\t\t\t\t\t  axs->target_sessionid[i],",
            "\t\t\t\t\t\t  axs->target_sid[i],",
            "\t\t\t\t\t\t  axs->target_comm[i]))",
            "\t\t\t\tcall_panic = 1;",
            "\t}",
            "",
            "\tif (context->target_pid &&",
            "\t    audit_log_pid_context(context, context->target_pid,",
            "\t\t\t\t  context->target_auid, context->target_uid,",
            "\t\t\t\t  context->target_sessionid,",
            "\t\t\t\t  context->target_sid, context->target_comm))",
            "\t\t\tcall_panic = 1;",
            "",
            "\tif (context->pwd.dentry && context->pwd.mnt) {",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);",
            "\t\tif (ab) {",
            "\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);",
            "\t\t\taudit_log_end(ab);",
            "\t\t}",
            "\t}",
            "",
            "\ti = 0;",
            "\tlist_for_each_entry(n, &context->names_list, list) {",
            "\t\tif (n->hidden)",
            "\t\t\tcontinue;",
            "\t\taudit_log_name(context, n, NULL, i++, &call_panic);",
            "\t}",
            "",
            "\tif (context->context == AUDIT_CTX_SYSCALL)",
            "\t\taudit_log_proctitle();",
            "",
            "\t/* Send end of event record to help user space know we are finished */",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);",
            "\tif (ab)",
            "\t\taudit_log_end(ab);",
            "\tif (call_panic)",
            "\t\taudit_panic(\"error in audit_log_exit()\");",
            "}"
          ],
          "function_name": "audit_log_uring, audit_log_exit",
          "description": "实现uring操作审计日志记录及进程退出事件审计，包含系统调用参数、文件描述符、特殊辅助数据等多维度审计信息收集",
          "similarity": 0.6316284537315369
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/auditsc.c",
          "start_line": 2692,
          "end_line": 2803,
          "content": [
            "void __audit_fd_pair(int fd1, int fd2)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tcontext->fds[0] = fd1;",
            "\tcontext->fds[1] = fd2;",
            "}",
            "int __audit_sockaddr(int len, void *a)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tif (!context->sockaddr) {",
            "\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);",
            "",
            "\t\tif (!p)",
            "\t\t\treturn -ENOMEM;",
            "\t\tcontext->sockaddr = p;",
            "\t}",
            "",
            "\tcontext->sockaddr_len = len;",
            "\tmemcpy(context->sockaddr, a, len);",
            "\treturn 0;",
            "}",
            "void __audit_ptrace(struct task_struct *t)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tcontext->target_pid = task_tgid_nr(t);",
            "\tcontext->target_auid = audit_get_loginuid(t);",
            "\tcontext->target_uid = task_uid(t);",
            "\tcontext->target_sessionid = audit_get_sessionid(t);",
            "\tsecurity_task_getsecid_obj(t, &context->target_sid);",
            "\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);",
            "}",
            "int audit_signal_info_syscall(struct task_struct *t)",
            "{",
            "\tstruct audit_aux_data_pids *axp;",
            "\tstruct audit_context *ctx = audit_context();",
            "\tkuid_t t_uid = task_uid(t);",
            "",
            "\tif (!audit_signals || audit_dummy_context())",
            "\t\treturn 0;",
            "",
            "\t/* optimize the common case by putting first signal recipient directly",
            "\t * in audit_context */",
            "\tif (!ctx->target_pid) {",
            "\t\tctx->target_pid = task_tgid_nr(t);",
            "\t\tctx->target_auid = audit_get_loginuid(t);",
            "\t\tctx->target_uid = t_uid;",
            "\t\tctx->target_sessionid = audit_get_sessionid(t);",
            "\t\tsecurity_task_getsecid_obj(t, &ctx->target_sid);",
            "\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\taxp = (void *)ctx->aux_pids;",
            "\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {",
            "\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);",
            "\t\tif (!axp)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\taxp->d.type = AUDIT_OBJ_PID;",
            "\t\taxp->d.next = ctx->aux_pids;",
            "\t\tctx->aux_pids = (void *)axp;",
            "\t}",
            "\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);",
            "",
            "\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);",
            "\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);",
            "\taxp->target_uid[axp->pid_count] = t_uid;",
            "\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);",
            "\tsecurity_task_getsecid_obj(t, &axp->target_sid[axp->pid_count]);",
            "\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);",
            "\taxp->pid_count++;",
            "",
            "\treturn 0;",
            "}",
            "int __audit_log_bprm_fcaps(struct linux_binprm *bprm,",
            "\t\t\t   const struct cred *new, const struct cred *old)",
            "{",
            "\tstruct audit_aux_data_bprm_fcaps *ax;",
            "\tstruct audit_context *context = audit_context();",
            "\tstruct cpu_vfs_cap_data vcaps;",
            "",
            "\tax = kmalloc(sizeof(*ax), GFP_KERNEL);",
            "\tif (!ax)",
            "\t\treturn -ENOMEM;",
            "",
            "\tax->d.type = AUDIT_BPRM_FCAPS;",
            "\tax->d.next = context->aux;",
            "\tcontext->aux = (void *)ax;",
            "",
            "\tget_vfs_caps_from_disk(&nop_mnt_idmap,",
            "\t\t\t       bprm->file->f_path.dentry, &vcaps);",
            "",
            "\tax->fcap.permitted = vcaps.permitted;",
            "\tax->fcap.inheritable = vcaps.inheritable;",
            "\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);",
            "\tax->fcap.rootid = vcaps.rootid;",
            "\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;",
            "",
            "\tax->old_pcap.permitted   = old->cap_permitted;",
            "\tax->old_pcap.inheritable = old->cap_inheritable;",
            "\tax->old_pcap.effective   = old->cap_effective;",
            "\tax->old_pcap.ambient     = old->cap_ambient;",
            "",
            "\tax->new_pcap.permitted   = new->cap_permitted;",
            "\tax->new_pcap.inheritable = new->cap_inheritable;",
            "\tax->new_pcap.effective   = new->cap_effective;",
            "\tax->new_pcap.ambient     = new->cap_ambient;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__audit_fd_pair, __audit_sockaddr, __audit_ptrace, audit_signal_info_syscall, __audit_log_bprm_fcaps",
          "description": "该代码块定义了多个辅助函数，用于在审计上下文中记录文件描述符配对、套接字地址、ptrace目标信息、信号传递及二进制参数能力变化等安全相关事件，通过修改audit_context结构体成员存储关键数据，供后续审计日志生成使用。",
          "similarity": 0.6307163834571838
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/auditsc.c",
          "start_line": 921,
          "end_line": 1043,
          "content": [
            "static inline void audit_free_module(struct audit_context *context)",
            "{",
            "\tif (context->type == AUDIT_KERN_MODULE) {",
            "\t\tkfree(context->module.name);",
            "\t\tcontext->module.name = NULL;",
            "\t}",
            "}",
            "static inline void audit_free_names(struct audit_context *context)",
            "{",
            "\tstruct audit_names *n, *next;",
            "",
            "\tlist_for_each_entry_safe(n, next, &context->names_list, list) {",
            "\t\tlist_del(&n->list);",
            "\t\tif (n->name)",
            "\t\t\tputname(n->name);",
            "\t\tif (n->should_free)",
            "\t\t\tkfree(n);",
            "\t}",
            "\tcontext->name_count = 0;",
            "\tpath_put(&context->pwd);",
            "\tcontext->pwd.dentry = NULL;",
            "\tcontext->pwd.mnt = NULL;",
            "}",
            "static inline void audit_free_aux(struct audit_context *context)",
            "{",
            "\tstruct audit_aux_data *aux;",
            "",
            "\twhile ((aux = context->aux)) {",
            "\t\tcontext->aux = aux->next;",
            "\t\tkfree(aux);",
            "\t}",
            "\tcontext->aux = NULL;",
            "\twhile ((aux = context->aux_pids)) {",
            "\t\tcontext->aux_pids = aux->next;",
            "\t\tkfree(aux);",
            "\t}",
            "\tcontext->aux_pids = NULL;",
            "}",
            "static void audit_reset_context(struct audit_context *ctx)",
            "{",
            "\tif (!ctx)",
            "\t\treturn;",
            "",
            "\t/* if ctx is non-null, reset the \"ctx->context\" regardless */",
            "\tctx->context = AUDIT_CTX_UNUSED;",
            "\tif (ctx->dummy)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * NOTE: It shouldn't matter in what order we release the fields, so",
            "\t *       release them in the order in which they appear in the struct;",
            "\t *       this gives us some hope of quickly making sure we are",
            "\t *       resetting the audit_context properly.",
            "\t *",
            "\t *       Other things worth mentioning:",
            "\t *       - we don't reset \"dummy\"",
            "\t *       - we don't reset \"state\", we do reset \"current_state\"",
            "\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD",
            "\t *       - much of this is likely overkill, but play it safe for now",
            "\t *       - we really need to work on improving the audit_context struct",
            "\t */",
            "",
            "\tctx->current_state = ctx->state;",
            "\tctx->serial = 0;",
            "\tctx->major = 0;",
            "\tctx->uring_op = 0;",
            "\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };",
            "\tmemset(ctx->argv, 0, sizeof(ctx->argv));",
            "\tctx->return_code = 0;",
            "\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);",
            "\tctx->return_valid = AUDITSC_INVALID;",
            "\taudit_free_names(ctx);",
            "\tif (ctx->state != AUDIT_STATE_RECORD) {",
            "\t\tkfree(ctx->filterkey);",
            "\t\tctx->filterkey = NULL;",
            "\t}",
            "\taudit_free_aux(ctx);",
            "\tkfree(ctx->sockaddr);",
            "\tctx->sockaddr = NULL;",
            "\tctx->sockaddr_len = 0;",
            "\tctx->ppid = 0;",
            "\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);",
            "\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);",
            "\tctx->personality = 0;",
            "\tctx->arch = 0;",
            "\tctx->target_pid = 0;",
            "\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);",
            "\tctx->target_sessionid = 0;",
            "\tctx->target_sid = 0;",
            "\tctx->target_comm[0] = '\\0';",
            "\tunroll_tree_refs(ctx, NULL, 0);",
            "\tWARN_ON(!list_empty(&ctx->killed_trees));",
            "\taudit_free_module(ctx);",
            "\tctx->fds[0] = -1;",
            "\tctx->type = 0; /* reset last for audit_free_*() */",
            "}",
            "int audit_alloc(struct task_struct *tsk)",
            "{",
            "\tstruct audit_context *context;",
            "\tenum audit_state     state;",
            "\tchar *key = NULL;",
            "",
            "\tif (likely(!audit_ever_enabled))",
            "\t\treturn 0;",
            "",
            "\tstate = audit_filter_task(tsk, &key);",
            "\tif (state == AUDIT_STATE_DISABLED) {",
            "\t\tclear_task_syscall_work(tsk, SYSCALL_AUDIT);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tcontext = audit_alloc_context(state);",
            "\tif (!context) {",
            "\t\tkfree(key);",
            "\t\taudit_log_lost(\"out of memory in audit_alloc\");",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tcontext->filterkey = key;",
            "",
            "\taudit_set_context(tsk, context);",
            "\tset_task_syscall_work(tsk, SYSCALL_AUDIT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "audit_free_module, audit_free_names, audit_free_aux, audit_reset_context, audit_alloc",
          "description": "实现审计上下文的内存释放与状态重置，包含模块名、路径名列表、辅助数据等资源的清理及上下文状态初始化",
          "similarity": 0.624267041683197
        }
      ]
    },
    {
      "source_file": "kernel/audit.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:49:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit.c`\n\n---\n\n# audit.c 技术文档\n\n## 文件概述\n\n`audit.c` 是 Linux 内核审计子系统的核心实现文件，负责提供内核与用户空间审计守护进程（auditd）之间的通信网关。该文件实现了审计记录的生成、队列管理、速率控制、网络命名空间支持以及与安全模块（如 SELinux）的集成。系统调用相关的审计逻辑已移至 `auditsc.c`，本文件聚焦于通用审计基础设施。\n\n## 核心功能\n\n### 主要全局变量\n- `audit_enabled`：审计系统启用状态（导出符号）\n- `audit_ever_enabled`：标记审计是否曾被启用\n- `audit_failure`：审计失败时的行为策略（如打印内核日志）\n- `audit_rate_limit`：每秒允许发送的审计记录上限（防 DoS）\n- `audit_backlog_limit`：待发送审计消息队列的最大长度\n- `audit_lost`：原子计数器，记录丢失的审计记录数量\n- `audit_sig_uid/audit_sig_pid/audit_sig_sid`：关闭审计系统的用户身份信息\n\n### 核心数据结构\n- `struct audit_net`：每个网络命名空间的审计专用数据（含 netlink socket）\n- `struct auditd_connection`：内核与 auditd 守护进程的连接状态（RCU 保护）\n- `struct audit_buffer`：审计记录的临时格式化缓冲区\n- `struct audit_reply`：审计响应消息结构\n- `struct audit_ctl_mutex`：序列化用户空间请求的互斥锁（带所有者跟踪）\n\n### 关键函数\n- `auditd_test_task()`：检查指定任务是否为注册的 auditd 守护进程\n- `audit_ctl_lock()/audit_ctl_unlock()`：获取/释放审计控制锁\n- `audit_ctl_owner_current()`：检查当前任务是否持有审计控制锁\n- `auditd_pid_vnr()`：获取 auditd 在当前 PID 命名空间中的 PID\n\n### 队列系统\n- `audit_queue`：待发送审计消息的主队列\n- `audit_retry_queue`：因单播发送失败需重试的消息队列\n- `audit_hold_queue`：等待新 auditd 连接建立时暂存的消息队列\n\n## 关键实现\n\n### 初始化状态机\n审计系统通过 `audit_initialized` 三态变量控制初始化流程：\n- `AUDIT_DISABLED` (-1)：显式禁用\n- `AUDIT_UNINITIALIZED` (0)：初始状态\n- `AUDIT_INITIALIZED` (1)：完成初始化（需在 `skb_init` 后）\n\n### RCU 保护的 auditd 连接\n`auditd_conn` 指针通过 RCU 机制保护，读操作使用 `rcu_read_lock()`，写操作需持有 `auditd_conn_lock` 自旋锁。这种设计确保高并发场景下连接状态的安全访问。\n\n### 背压与速率控制\n- **速率限制**：通过 `audit_rate_limit` 限制每秒发送记录数\n- **背压机制**：当队列长度超过 `audit_backlog_limit` 时阻塞生产者，并累计等待时间到 `audit_backlog_wait_time_actual`\n- **内存保护**：使用 `audit_buffer_cache` slab 缓存减少内存分配开销\n\n### 锁所有权跟踪\n`audit_ctl_mutex` 扩展标准 mutex，记录锁所有者 (`owner`)。此设计避免在 `audit_log_start()` 等路径中因递归锁导致死锁，确保审计日志生成不会阻塞持有控制锁的任务。\n\n### 网络命名空间支持\n通过 `audit_net_id` 实现 per-netns 审计 socket，每个网络命名空间拥有独立的 auditd 通信通道，符合内核网络命名空间隔离原则。\n\n## 依赖关系\n\n- **核心依赖**：\n  - `<linux/audit.h>`：审计子系统公共接口\n  - `<net/netlink.h>`：Netlink 通信机制\n  - `<linux/security.h>`：LSM（Linux Security Module）集成点\n- **子系统交互**：\n  - **LSM 框架**：作为安全事件的消费者（如 SELinux 策略拒绝事件）\n  - **PID 命名空间**：通过 `pid_vnr()` 获取命名空间内 PID\n  - **RCU 机制**：用于 auditd 连接状态的无锁读取\n  - **kthread**：`kauditd_task` 内核线程处理消息队列\n- **配套文件**：\n  - `auditsc.c`：系统调用审计逻辑\n  - `audit.h`（本地）：内部头文件\n\n## 使用场景\n\n1. **安全事件记录**：当 LSM（如 SELinux/AppArmor）触发安全策略拒绝时，通过 `audit_log_*` 系列函数生成审计记录\n2. **系统调用审计**：配合 `auditsc.c` 记录符合规则的系统调用（需启用 syscall auditing）\n3. **用户空间交互**：\n   - 接收 auditctl 配置命令（规则加载/查询）\n   - 向 auditd 发送审计事件（通过 Netlink）\n   - 处理 auditd 守护进程的生命周期事件（启动/停止）\n4. **内核自检**：通过 `audit_failure` 配置项处理审计子系统内部错误（如内存不足）\n5. **容器环境支持**：在 PID/net 命名空间中为每个容器提供独立的审计上下文",
      "similarity": 0.6188636422157288,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/audit.c",
          "start_line": 383,
          "end_line": 503,
          "content": [
            "static int audit_log_config_change(char *function_name, u32 new, u32 old,",
            "\t\t\t\t   int allow_changes)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tint rc = 0;",
            "",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);",
            "\tif (unlikely(!ab))",
            "\t\treturn rc;",
            "\taudit_log_format(ab, \"op=set %s=%u old=%u \", function_name, new, old);",
            "\taudit_log_session_info(ab);",
            "\trc = audit_log_task_context(ab);",
            "\tif (rc)",
            "\t\tallow_changes = 0; /* Something weird, deny request */",
            "\taudit_log_format(ab, \" res=%d\", allow_changes);",
            "\taudit_log_end(ab);",
            "\treturn rc;",
            "}",
            "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)",
            "{",
            "\tint allow_changes, rc = 0;",
            "\tu32 old = *to_change;",
            "",
            "\t/* check if we are locked */",
            "\tif (audit_enabled == AUDIT_LOCKED)",
            "\t\tallow_changes = 0;",
            "\telse",
            "\t\tallow_changes = 1;",
            "",
            "\tif (audit_enabled != AUDIT_OFF) {",
            "\t\trc = audit_log_config_change(function_name, new, old, allow_changes);",
            "\t\tif (rc)",
            "\t\t\tallow_changes = 0;",
            "\t}",
            "",
            "\t/* If we are allowed, make the change */",
            "\tif (allow_changes == 1)",
            "\t\t*to_change = new;",
            "\t/* Not allowed, update reason */",
            "\telse if (rc == 0)",
            "\t\trc = -EPERM;",
            "\treturn rc;",
            "}",
            "static int audit_set_rate_limit(u32 limit)",
            "{",
            "\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);",
            "}",
            "static int audit_set_backlog_limit(u32 limit)",
            "{",
            "\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);",
            "}",
            "static int audit_set_backlog_wait_time(u32 timeout)",
            "{",
            "\treturn audit_do_config_change(\"audit_backlog_wait_time\",",
            "\t\t\t\t      &audit_backlog_wait_time, timeout);",
            "}",
            "static int audit_set_enabled(u32 state)",
            "{",
            "\tint rc;",
            "\tif (state > AUDIT_LOCKED)",
            "\t\treturn -EINVAL;",
            "",
            "\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);",
            "\tif (!rc)",
            "\t\taudit_ever_enabled |= !!state;",
            "",
            "\treturn rc;",
            "}",
            "static int audit_set_failure(u32 state)",
            "{",
            "\tif (state != AUDIT_FAIL_SILENT",
            "\t    && state != AUDIT_FAIL_PRINTK",
            "\t    && state != AUDIT_FAIL_PANIC)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);",
            "}",
            "static void auditd_conn_free(struct rcu_head *rcu)",
            "{",
            "\tstruct auditd_connection *ac;",
            "",
            "\tac = container_of(rcu, struct auditd_connection, rcu);",
            "\tput_pid(ac->pid);",
            "\tput_net(ac->net);",
            "\tkfree(ac);",
            "}",
            "static int auditd_set(struct pid *pid, u32 portid, struct net *net,",
            "\t\t      struct sk_buff *skb, bool *ack)",
            "{",
            "\tunsigned long flags;",
            "\tstruct auditd_connection *ac_old, *ac_new;",
            "\tstruct nlmsghdr *nlh;",
            "",
            "\tif (!pid || !net)",
            "\t\treturn -EINVAL;",
            "",
            "\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);",
            "\tif (!ac_new)",
            "\t\treturn -ENOMEM;",
            "\tac_new->pid = get_pid(pid);",
            "\tac_new->portid = portid;",
            "\tac_new->net = get_net(net);",
            "",
            "\t/* send the ack now to avoid a race with the queue backlog */",
            "\tif (*ack) {",
            "\t\tnlh = nlmsg_hdr(skb);",
            "\t\tnetlink_ack(skb, nlh, 0, NULL);",
            "\t\t*ack = false;",
            "\t}",
            "",
            "\tspin_lock_irqsave(&auditd_conn_lock, flags);",
            "\tac_old = rcu_dereference_protected(auditd_conn,",
            "\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));",
            "\trcu_assign_pointer(auditd_conn, ac_new);",
            "\tspin_unlock_irqrestore(&auditd_conn_lock, flags);",
            "",
            "\tif (ac_old)",
            "\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "audit_log_config_change, audit_do_config_change, audit_set_rate_limit, audit_set_backlog_limit, audit_set_backlog_wait_time, audit_set_enabled, audit_set_failure, auditd_conn_free, auditd_set",
          "description": "提供配置参数修改接口，通过审计日志记录配置变更并更新相关状态，同时管理审计守护进程连接信息。",
          "similarity": 0.7236998081207275
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/audit.c",
          "start_line": 2092,
          "end_line": 2193,
          "content": [
            "bool audit_string_contains_control(const char *string, size_t len)",
            "{",
            "\tconst unsigned char *p;",
            "\tfor (p = string; p < (const unsigned char *)string + len; p++) {",
            "\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,",
            "\t\t\t\t size_t len)",
            "{",
            "\tif (audit_string_contains_control(string, len))",
            "\t\taudit_log_n_hex(ab, string, len);",
            "\telse",
            "\t\taudit_log_n_string(ab, string, len);",
            "}",
            "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)",
            "{",
            "\taudit_log_n_untrustedstring(ab, string, strlen(string));",
            "}",
            "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,",
            "\t\t      const struct path *path)",
            "{",
            "\tchar *p, *pathname;",
            "",
            "\tif (prefix)",
            "\t\taudit_log_format(ab, \"%s\", prefix);",
            "",
            "\t/* We will allow 11 spaces for ' (deleted)' to be appended */",
            "\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);",
            "\tif (!pathname) {",
            "\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");",
            "\t\treturn;",
            "\t}",
            "\tp = d_path(path, pathname, PATH_MAX+11);",
            "\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */",
            "\t\t/* FIXME: can we save some information here? */",
            "\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");",
            "\t} else",
            "\t\taudit_log_untrustedstring(ab, p);",
            "\tkfree(pathname);",
            "}",
            "void audit_log_session_info(struct audit_buffer *ab)",
            "{",
            "\tunsigned int sessionid = audit_get_sessionid(current);",
            "\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));",
            "",
            "\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);",
            "}",
            "void audit_log_key(struct audit_buffer *ab, char *key)",
            "{",
            "\taudit_log_format(ab, \" key=\");",
            "\tif (key)",
            "\t\taudit_log_untrustedstring(ab, key);",
            "\telse",
            "\t\taudit_log_format(ab, \"(null)\");",
            "}",
            "int audit_log_task_context(struct audit_buffer *ab)",
            "{",
            "\tchar *ctx = NULL;",
            "\tunsigned len;",
            "\tint error;",
            "\tu32 sid;",
            "",
            "\tsecurity_current_getsecid_subj(&sid);",
            "\tif (!sid)",
            "\t\treturn 0;",
            "",
            "\terror = security_secid_to_secctx(sid, &ctx, &len);",
            "\tif (error) {",
            "\t\tif (error != -EINVAL)",
            "\t\t\tgoto error_path;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\taudit_log_format(ab, \" subj=%s\", ctx);",
            "\tsecurity_release_secctx(ctx, len);",
            "\treturn 0;",
            "",
            "error_path:",
            "\taudit_panic(\"error in audit_log_task_context\");",
            "\treturn error;",
            "}",
            "void audit_log_d_path_exe(struct audit_buffer *ab,",
            "\t\t\t  struct mm_struct *mm)",
            "{",
            "\tstruct file *exe_file;",
            "",
            "\tif (!mm)",
            "\t\tgoto out_null;",
            "",
            "\texe_file = get_mm_exe_file(mm);",
            "\tif (!exe_file)",
            "\t\tgoto out_null;",
            "",
            "\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);",
            "\tfput(exe_file);",
            "\treturn;",
            "out_null:",
            "\taudit_log_format(ab, \" exe=(null)\");",
            "}"
          ],
          "function_name": "audit_string_contains_control, audit_log_n_untrustedstring, audit_log_untrustedstring, audit_log_d_path, audit_log_session_info, audit_log_key, audit_log_task_context, audit_log_d_path_exe",
          "description": "检测字符串中的控制字符，记录受信/不受信字符串及路径信息，输出会话标识和安全上下文到审计日志",
          "similarity": 0.6964022517204285
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/audit.c",
          "start_line": 1086,
          "end_line": 1194,
          "content": [
            "static void audit_log_common_recv_msg(struct audit_context *context,",
            "\t\t\t\t\tstruct audit_buffer **ab, u16 msg_type)",
            "{",
            "\tuid_t uid = from_kuid(&init_user_ns, current_uid());",
            "\tpid_t pid = task_tgid_nr(current);",
            "",
            "\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {",
            "\t\t*ab = NULL;",
            "\t\treturn;",
            "\t}",
            "",
            "\t*ab = audit_log_start(context, GFP_KERNEL, msg_type);",
            "\tif (unlikely(!*ab))",
            "\t\treturn;",
            "\taudit_log_format(*ab, \"pid=%d uid=%u \", pid, uid);",
            "\taudit_log_session_info(*ab);",
            "\taudit_log_task_context(*ab);",
            "}",
            "static inline void audit_log_user_recv_msg(struct audit_buffer **ab,",
            "\t\t\t\t\t   u16 msg_type)",
            "{",
            "\taudit_log_common_recv_msg(NULL, ab, msg_type);",
            "}",
            "static int is_audit_feature_set(int i)",
            "{",
            "\treturn af.features & AUDIT_FEATURE_TO_MASK(i);",
            "}",
            "static int audit_get_feature(struct sk_buff *skb)",
            "{",
            "\tu32 seq;",
            "",
            "\tseq = nlmsg_hdr(skb)->nlmsg_seq;",
            "",
            "\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));",
            "",
            "\treturn 0;",
            "}",
            "static void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,",
            "\t\t\t\t     u32 old_lock, u32 new_lock, int res)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (audit_enabled == AUDIT_OFF)",
            "\t\treturn;",
            "",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);",
            "\tif (!ab)",
            "\t\treturn;",
            "\taudit_log_task_info(ab);",
            "\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",",
            "\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,",
            "\t\t\t !!old_lock, !!new_lock, res);",
            "\taudit_log_end(ab);",
            "}",
            "static int audit_set_feature(struct audit_features *uaf)",
            "{",
            "\tint i;",
            "",
            "\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));",
            "",
            "\t/* if there is ever a version 2 we should handle that here */",
            "",
            "\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {",
            "\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);",
            "\t\tu32 old_feature, new_feature, old_lock, new_lock;",
            "",
            "\t\t/* if we are not changing this feature, move along */",
            "\t\tif (!(feature & uaf->mask))",
            "\t\t\tcontinue;",
            "",
            "\t\told_feature = af.features & feature;",
            "\t\tnew_feature = uaf->features & feature;",
            "\t\tnew_lock = (uaf->lock | af.lock) & feature;",
            "\t\told_lock = af.lock & feature;",
            "",
            "\t\t/* are we changing a locked feature? */",
            "\t\tif (old_lock && (new_feature != old_feature)) {",
            "\t\t\taudit_log_feature_change(i, old_feature, new_feature,",
            "\t\t\t\t\t\t old_lock, new_lock, 0);",
            "\t\t\treturn -EPERM;",
            "\t\t}",
            "\t}",
            "\t/* nothing invalid, do the changes */",
            "\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {",
            "\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);",
            "\t\tu32 old_feature, new_feature, old_lock, new_lock;",
            "",
            "\t\t/* if we are not changing this feature, move along */",
            "\t\tif (!(feature & uaf->mask))",
            "\t\t\tcontinue;",
            "",
            "\t\told_feature = af.features & feature;",
            "\t\tnew_feature = uaf->features & feature;",
            "\t\told_lock = af.lock & feature;",
            "\t\tnew_lock = (uaf->lock | af.lock) & feature;",
            "",
            "\t\tif (new_feature != old_feature)",
            "\t\t\taudit_log_feature_change(i, old_feature, new_feature,",
            "\t\t\t\t\t\t old_lock, new_lock, 1);",
            "",
            "\t\tif (new_feature)",
            "\t\t\taf.features |= feature;",
            "\t\telse",
            "\t\t\taf.features &= ~feature;",
            "\t\taf.lock |= new_lock;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "audit_log_common_recv_msg, audit_log_user_recv_msg, is_audit_feature_set, audit_get_feature, audit_log_feature_change, audit_set_feature",
          "description": "提供通用审计消息接收日志记录接口，处理审计特征位操作，包含特征获取/设置逻辑及变更日志记录，支持对用户空间审计消息进行格式化记录。",
          "similarity": 0.6962918043136597
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/audit.c",
          "start_line": 2238,
          "end_line": 2362,
          "content": [
            "void audit_put_tty(struct tty_struct *tty)",
            "{",
            "\ttty_kref_put(tty);",
            "}",
            "void audit_log_task_info(struct audit_buffer *ab)",
            "{",
            "\tconst struct cred *cred;",
            "\tchar comm[sizeof(current->comm)];",
            "\tstruct tty_struct *tty;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tcred = current_cred();",
            "\ttty = audit_get_tty();",
            "\taudit_log_format(ab,",
            "\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"",
            "\t\t\t \" euid=%u suid=%u fsuid=%u\"",
            "\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",",
            "\t\t\t task_ppid_nr(current),",
            "\t\t\t task_tgid_nr(current),",
            "\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),",
            "\t\t\t from_kuid(&init_user_ns, cred->uid),",
            "\t\t\t from_kgid(&init_user_ns, cred->gid),",
            "\t\t\t from_kuid(&init_user_ns, cred->euid),",
            "\t\t\t from_kuid(&init_user_ns, cred->suid),",
            "\t\t\t from_kuid(&init_user_ns, cred->fsuid),",
            "\t\t\t from_kgid(&init_user_ns, cred->egid),",
            "\t\t\t from_kgid(&init_user_ns, cred->sgid),",
            "\t\t\t from_kgid(&init_user_ns, cred->fsgid),",
            "\t\t\t tty ? tty_name(tty) : \"(none)\",",
            "\t\t\t audit_get_sessionid(current));",
            "\taudit_put_tty(tty);",
            "\taudit_log_format(ab, \" comm=\");",
            "\taudit_log_untrustedstring(ab, get_task_comm(comm, current));",
            "\taudit_log_d_path_exe(ab, current->mm);",
            "\taudit_log_task_context(ab);",
            "}",
            "void audit_log_path_denied(int type, const char *operation)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled || audit_dummy_context())",
            "\t\treturn;",
            "",
            "\t/* Generate log with subject, operation, outcome. */",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, type);",
            "\tif (!ab)",
            "\t\treturn;",
            "\taudit_log_format(ab, \"op=%s\", operation);",
            "\taudit_log_task_info(ab);",
            "\taudit_log_format(ab, \" res=0\");",
            "\taudit_log_end(ab);",
            "}",
            "static int audit_set_loginuid_perm(kuid_t loginuid)",
            "{",
            "\t/* if we are unset, we don't need privs */",
            "\tif (!audit_loginuid_set(current))",
            "\t\treturn 0;",
            "\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/",
            "\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))",
            "\t\treturn -EPERM;",
            "\t/* it is set, you need permission */",
            "\tif (!capable(CAP_AUDIT_CONTROL))",
            "\t\treturn -EPERM;",
            "\t/* reject if this is not an unset and we don't allow that */",
            "\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID)",
            "\t\t\t\t && uid_valid(loginuid))",
            "\t\treturn -EPERM;",
            "\treturn 0;",
            "}",
            "static void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,",
            "\t\t\t\t   unsigned int oldsessionid,",
            "\t\t\t\t   unsigned int sessionid, int rc)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tuid_t uid, oldloginuid, loginuid;",
            "\tstruct tty_struct *tty;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_LOGIN);",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tuid = from_kuid(&init_user_ns, task_uid(current));",
            "\toldloginuid = from_kuid(&init_user_ns, koldloginuid);",
            "\tloginuid = from_kuid(&init_user_ns, kloginuid);",
            "\ttty = audit_get_tty();",
            "",
            "\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);",
            "\taudit_log_task_context(ab);",
            "\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",",
            "\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",",
            "\t\t\t oldsessionid, sessionid, !rc);",
            "\taudit_put_tty(tty);",
            "\taudit_log_end(ab);",
            "}",
            "int audit_set_loginuid(kuid_t loginuid)",
            "{",
            "\tunsigned int oldsessionid, sessionid = AUDIT_SID_UNSET;",
            "\tkuid_t oldloginuid;",
            "\tint rc;",
            "",
            "\toldloginuid = audit_get_loginuid(current);",
            "\toldsessionid = audit_get_sessionid(current);",
            "",
            "\trc = audit_set_loginuid_perm(loginuid);",
            "\tif (rc)",
            "\t\tgoto out;",
            "",
            "\t/* are we setting or clearing? */",
            "\tif (uid_valid(loginuid)) {",
            "\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);",
            "\t\tif (unlikely(sessionid == AUDIT_SID_UNSET))",
            "\t\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);",
            "\t}",
            "",
            "\tcurrent->sessionid = sessionid;",
            "\tcurrent->loginuid = loginuid;",
            "out:",
            "\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "audit_put_tty, audit_log_task_info, audit_log_path_denied, audit_set_loginuid_perm, audit_log_set_loginuid, audit_set_loginuid",
          "description": "记录任务详细信息到审计日志，处理路径访问拒绝事件，管理登录UID变更并触发审计日志记录",
          "similarity": 0.6896283030509949
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/audit.c",
          "start_line": 1834,
          "end_line": 1958,
          "content": [
            "static inline void audit_get_stamp(struct audit_context *ctx,",
            "\t\t\t\t   struct timespec64 *t, unsigned int *serial)",
            "{",
            "\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {",
            "\t\tktime_get_coarse_real_ts64(t);",
            "\t\t*serial = audit_serial();",
            "\t}",
            "}",
            "static inline int audit_expand(struct audit_buffer *ab, int extra)",
            "{",
            "\tstruct sk_buff *skb = ab->skb;",
            "\tint oldtail = skb_tailroom(skb);",
            "\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);",
            "\tint newtail = skb_tailroom(skb);",
            "",
            "\tif (ret < 0) {",
            "\t\taudit_log_lost(\"out of memory in audit_expand\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tskb->truesize += newtail - oldtail;",
            "\treturn newtail;",
            "}",
            "static void audit_log_vformat(struct audit_buffer *ab, const char *fmt,",
            "\t\t\t      va_list args)",
            "{",
            "\tint len, avail;",
            "\tstruct sk_buff *skb;",
            "\tva_list args2;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tBUG_ON(!ab->skb);",
            "\tskb = ab->skb;",
            "\tavail = skb_tailroom(skb);",
            "\tif (avail == 0) {",
            "\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);",
            "\t\tif (!avail)",
            "\t\t\tgoto out;",
            "\t}",
            "\tva_copy(args2, args);",
            "\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);",
            "\tif (len >= avail) {",
            "\t\t/* The printk buffer is 1024 bytes long, so if we get",
            "\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can",
            "\t\t * log everything that printk could have logged. */",
            "\t\tavail = audit_expand(ab,",
            "\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));",
            "\t\tif (!avail)",
            "\t\t\tgoto out_va_end;",
            "\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);",
            "\t}",
            "\tif (len > 0)",
            "\t\tskb_put(skb, len);",
            "out_va_end:",
            "\tva_end(args2);",
            "out:",
            "\treturn;",
            "}",
            "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "\tva_start(args, fmt);",
            "\taudit_log_vformat(ab, fmt, args);",
            "\tva_end(args);",
            "}",
            "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,",
            "\t\tsize_t len)",
            "{",
            "\tint i, avail, new_len;",
            "\tunsigned char *ptr;",
            "\tstruct sk_buff *skb;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tBUG_ON(!ab->skb);",
            "\tskb = ab->skb;",
            "\tavail = skb_tailroom(skb);",
            "\tnew_len = len<<1;",
            "\tif (new_len >= avail) {",
            "\t\t/* Round the buffer request up to the next multiple */",
            "\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);",
            "\t\tavail = audit_expand(ab, new_len);",
            "\t\tif (!avail)",
            "\t\t\treturn;",
            "\t}",
            "",
            "\tptr = skb_tail_pointer(skb);",
            "\tfor (i = 0; i < len; i++)",
            "\t\tptr = hex_byte_pack_upper(ptr, buf[i]);",
            "\t*ptr = 0;",
            "\tskb_put(skb, len << 1); /* new string is twice the old string */",
            "}",
            "void audit_log_n_string(struct audit_buffer *ab, const char *string,",
            "\t\t\tsize_t slen)",
            "{",
            "\tint avail, new_len;",
            "\tunsigned char *ptr;",
            "\tstruct sk_buff *skb;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tBUG_ON(!ab->skb);",
            "\tskb = ab->skb;",
            "\tavail = skb_tailroom(skb);",
            "\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */",
            "\tif (new_len > avail) {",
            "\t\tavail = audit_expand(ab, new_len);",
            "\t\tif (!avail)",
            "\t\t\treturn;",
            "\t}",
            "\tptr = skb_tail_pointer(skb);",
            "\t*ptr++ = '\"';",
            "\tmemcpy(ptr, string, slen);",
            "\tptr += slen;",
            "\t*ptr++ = '\"';",
            "\t*ptr = 0;",
            "\tskb_put(skb, slen + 2);\t/* don't include null terminator */",
            "}"
          ],
          "function_name": "audit_get_stamp, audit_expand, audit_log_vformat, audit_log_format, audit_log_n_hex, audit_log_n_string",
          "description": "提供审计上下文的时间戳和序列号获取，扩展skb缓冲区以容纳更多日志数据，实现格式化字符串和二进制数据的审计日志记录",
          "similarity": 0.6460860967636108
        }
      ]
    },
    {
      "source_file": "kernel/auditfilter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:52:34\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `auditfilter.c`\n\n---\n\n# auditfilter.c 技术文档\n\n## 文件概述\n\n`auditfilter.c` 是 Linux 内核审计子系统（Audit Subsystem）的核心组件之一，负责实现审计事件的过滤机制。该文件提供了审计规则的解析、存储、匹配和释放功能，支持基于系统调用、文件路径、用户身份、LSM（Linux Security Module）标签等多种条件的细粒度事件过滤。通过维护多个过滤规则链表，内核能够在事件发生时快速判断是否需要记录或忽略该事件。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`audit_filter_list[AUDIT_NR_FILTERS]`**：全局数组，包含 8 个链表头，分别对应不同类型的审计过滤器（如 `AUDIT_FILTER_EXIT`、`AUDIT_FILTER_USER` 等）。\n- **`audit_rules_list[AUDIT_NR_FILTERS]`**：与 `audit_filter_list` 并行的规则链表，用于规则管理。\n- **`audit_entry`**：审计规则的内核表示，包含 `audit_krule` 结构，用于存储规则字段、操作、动作等信息。\n- **`audit_field`**：表示单个过滤字段，支持整数、字符串、LSM 安全上下文等多种类型。\n- **`classes[AUDIT_SYSCALL_CLASSES]`**：系统调用分类映射表，用于将系统调用分组（如信号类、网络类等）。\n\n### 主要函数\n\n- **`audit_free_rule()` / `audit_free_rule_rcu()`**：释放审计规则及其关联资源（如 watch、LSM 规则、字符串等），支持 RCU 安全释放。\n- **`audit_init_entry()`**：分配并初始化一个新的审计规则条目。\n- **`audit_unpack_string()`**：从用户空间缓冲区解包字符串字段，用于规则解析。\n- **`audit_to_inode()`**：处理基于 inode 的审计规则字段。\n- **`audit_register_class()` / `audit_match_class()`**：注册和匹配系统调用分类。\n- **`audit_to_entry_common()`**：将用户空间传入的 `audit_rule_data` 转换为内核内部的 `audit_entry` 表示。\n- **`audit_match_signal()`**（仅在 `CONFIG_AUDITSYSCALL` 下）：判断规则是否匹配信号类系统调用。\n\n## 关键实现\n\n### 锁与并发控制\n\n- 使用 **`audit_filter_mutex`** 互斥锁保护对过滤规则链表的写操作和阻塞读操作。\n- 规则遍历和匹配过程使用 **RCU（Read-Copy-Update）** 机制，确保高并发下的读性能。\n- 修改规则时必须**复制整个结构体**并替换链表中的旧条目，而非原地修改，以保证 RCU 读取的安全性。\n\n### 规则解析与转换\n\n- `audit_to_entry_common()` 是规则解析的核心函数，负责：\n  - 验证规则合法性（动作、字段数量、过滤器类型等）\n  - 初始化内核规则结构\n  - 处理系统调用分类位图（将分类位展开为具体系统调用掩码）\n- 支持多种比较操作符（等于、不等于、位掩码、位测试、大小比较等），通过 `audit_ops[]` 数组映射。\n\n### LSM 集成\n\n- 支持 SELinux 等 LSM 框架的安全上下文字段（如 `AUDIT_SUBJ_USER`、`AUDIT_OBJ_ROLE` 等）。\n- 使用 `security_audit_rule_free()` 释放 LSM 规则，确保与安全模块的解耦。\n\n### 系统调用分类\n\n- 通过 `audit_register_class()` 动态注册系统调用分组（如信号、文件、网络等）。\n- 在规则匹配时，自动将分类位扩展为对应的系统调用位掩码，简化用户空间规则配置。\n\n## 依赖关系\n\n- **`<linux/audit.h>`**：定义审计子系统的公共接口、常量和数据结构。\n- **`<linux/security.h>`**：提供 LSM 审计规则的注册与释放接口。\n- **`<linux/rcupdate.h>`**（隐式）：通过 RCU 机制实现无锁读取。\n- **`audit.h`（本地头文件）**：包含审计子系统内部定义。\n- **`CONFIG_AUDITSYSCALL`**：条件编译依赖，启用系统调用审计相关功能。\n- **Netlink 子系统**：通过 netlink 接收用户空间下发的审计规则。\n\n## 使用场景\n\n1. **审计规则加载**：当用户空间工具（如 `auditctl`）通过 netlink 发送审计规则时，内核调用本文件中的解析函数将规则转换为内核格式并插入对应过滤链表。\n2. **事件过滤**：在系统调用入口/出口、文件访问、进程创建等关键路径上，审计钩子函数调用本模块的匹配逻辑，判断当前事件是否应被记录。\n3. **规则更新与删除**：管理员动态修改审计策略时，内核通过 `audit_filter_mutex` 保护规则链表的修改操作，并利用 RCU 机制安全替换旧规则。\n4. **LSM 审计集成**：当 SELinux 或其他 LSM 启用审计时，安全上下文相关的过滤规则通过本模块进行匹配。\n5. **系统调用分组监控**：用户可基于系统调用类别（如“所有信号相关调用”）设置规则，无需逐个指定系统调用号。",
      "similarity": 0.6013793349266052,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/auditfilter.c",
          "start_line": 624,
          "end_line": 737,
          "content": [
            "static inline size_t audit_pack_string(void **bufp, const char *str)",
            "{",
            "\tsize_t len = strlen(str);",
            "",
            "\tmemcpy(*bufp, str, len);",
            "\t*bufp += len;",
            "",
            "\treturn len;",
            "}",
            "static int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)",
            "{",
            "\tint i;",
            "",
            "\tif (a->flags != b->flags ||",
            "\t    a->pflags != b->pflags ||",
            "\t    a->listnr != b->listnr ||",
            "\t    a->action != b->action ||",
            "\t    a->field_count != b->field_count)",
            "\t\treturn 1;",
            "",
            "\tfor (i = 0; i < a->field_count; i++) {",
            "\t\tif (a->fields[i].type != b->fields[i].type ||",
            "\t\t    a->fields[i].op != b->fields[i].op)",
            "\t\t\treturn 1;",
            "",
            "\t\tswitch (a->fields[i].type) {",
            "\t\tcase AUDIT_SUBJ_USER:",
            "\t\tcase AUDIT_SUBJ_ROLE:",
            "\t\tcase AUDIT_SUBJ_TYPE:",
            "\t\tcase AUDIT_SUBJ_SEN:",
            "\t\tcase AUDIT_SUBJ_CLR:",
            "\t\tcase AUDIT_OBJ_USER:",
            "\t\tcase AUDIT_OBJ_ROLE:",
            "\t\tcase AUDIT_OBJ_TYPE:",
            "\t\tcase AUDIT_OBJ_LEV_LOW:",
            "\t\tcase AUDIT_OBJ_LEV_HIGH:",
            "\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_WATCH:",
            "\t\t\tif (strcmp(audit_watch_path(a->watch),",
            "\t\t\t\t   audit_watch_path(b->watch)))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_DIR:",
            "\t\t\tif (strcmp(audit_tree_path(a->tree),",
            "\t\t\t\t   audit_tree_path(b->tree)))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_FILTERKEY:",
            "\t\t\t/* both filterkeys exist based on above type compare */",
            "\t\t\tif (strcmp(a->filterkey, b->filterkey))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_EXE:",
            "\t\t\t/* both paths exist based on above type compare */",
            "\t\t\tif (strcmp(audit_mark_path(a->exe),",
            "\t\t\t\t   audit_mark_path(b->exe)))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_UID:",
            "\t\tcase AUDIT_EUID:",
            "\t\tcase AUDIT_SUID:",
            "\t\tcase AUDIT_FSUID:",
            "\t\tcase AUDIT_LOGINUID:",
            "\t\tcase AUDIT_OBJ_UID:",
            "\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tcase AUDIT_GID:",
            "\t\tcase AUDIT_EGID:",
            "\t\tcase AUDIT_SGID:",
            "\t\tcase AUDIT_FSGID:",
            "\t\tcase AUDIT_OBJ_GID:",
            "\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))",
            "\t\t\t\treturn 1;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tif (a->fields[i].val != b->fields[i].val)",
            "\t\t\t\treturn 1;",
            "\t\t}",
            "\t}",
            "",
            "\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)",
            "\t\tif (a->mask[i] != b->mask[i])",
            "\t\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static inline int audit_dupe_lsm_field(struct audit_field *df,",
            "\t\t\t\t\t   struct audit_field *sf)",
            "{",
            "\tint ret = 0;",
            "\tchar *lsm_str;",
            "",
            "\t/* our own copy of lsm_str */",
            "\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);",
            "\tif (unlikely(!lsm_str))",
            "\t\treturn -ENOMEM;",
            "\tdf->lsm_str = lsm_str;",
            "",
            "\t/* our own (refreshed) copy of lsm_rule */",
            "\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,",
            "\t\t\t\t       (void **)&df->lsm_rule, GFP_KERNEL);",
            "\t/* Keep currently invalid fields around in case they",
            "\t * become valid after a policy reload. */",
            "\tif (ret == -EINVAL) {",
            "\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",",
            "\t\t\tdf->lsm_str);",
            "\t\tret = 0;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "audit_pack_string, audit_compare_rule, audit_dupe_lsm_field",
          "description": "实现字符串序列化、规则全量对比和LSM规则复制功能，支持审计规则的精确匹配和安全模块规则初始化。",
          "similarity": 0.6222330331802368
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/auditfilter.c",
          "start_line": 1206,
          "end_line": 1313,
          "content": [
            "int audit_comparator(u32 left, u32 op, u32 right)",
            "{",
            "\tswitch (op) {",
            "\tcase Audit_equal:",
            "\t\treturn (left == right);",
            "\tcase Audit_not_equal:",
            "\t\treturn (left != right);",
            "\tcase Audit_lt:",
            "\t\treturn (left < right);",
            "\tcase Audit_le:",
            "\t\treturn (left <= right);",
            "\tcase Audit_gt:",
            "\t\treturn (left > right);",
            "\tcase Audit_ge:",
            "\t\treturn (left >= right);",
            "\tcase Audit_bitmask:",
            "\t\treturn (left & right);",
            "\tcase Audit_bittest:",
            "\t\treturn ((left & right) == right);",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)",
            "{",
            "\tswitch (op) {",
            "\tcase Audit_equal:",
            "\t\treturn uid_eq(left, right);",
            "\tcase Audit_not_equal:",
            "\t\treturn !uid_eq(left, right);",
            "\tcase Audit_lt:",
            "\t\treturn uid_lt(left, right);",
            "\tcase Audit_le:",
            "\t\treturn uid_lte(left, right);",
            "\tcase Audit_gt:",
            "\t\treturn uid_gt(left, right);",
            "\tcase Audit_ge:",
            "\t\treturn uid_gte(left, right);",
            "\tcase Audit_bitmask:",
            "\tcase Audit_bittest:",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)",
            "{",
            "\tswitch (op) {",
            "\tcase Audit_equal:",
            "\t\treturn gid_eq(left, right);",
            "\tcase Audit_not_equal:",
            "\t\treturn !gid_eq(left, right);",
            "\tcase Audit_lt:",
            "\t\treturn gid_lt(left, right);",
            "\tcase Audit_le:",
            "\t\treturn gid_lte(left, right);",
            "\tcase Audit_gt:",
            "\t\treturn gid_gt(left, right);",
            "\tcase Audit_ge:",
            "\t\treturn gid_gte(left, right);",
            "\tcase Audit_bitmask:",
            "\tcase Audit_bittest:",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "int parent_len(const char *path)",
            "{",
            "\tint plen;",
            "\tconst char *p;",
            "",
            "\tplen = strlen(path);",
            "",
            "\tif (plen == 0)",
            "\t\treturn plen;",
            "",
            "\t/* disregard trailing slashes */",
            "\tp = path + plen - 1;",
            "\twhile ((*p == '/') && (p > path))",
            "\t\tp--;",
            "",
            "\t/* walk backward until we find the next slash or hit beginning */",
            "\twhile ((*p != '/') && (p > path))",
            "\t\tp--;",
            "",
            "\t/* did we find a slash? Then increment to include it in path */",
            "\tif (*p == '/')",
            "\t\tp++;",
            "",
            "\treturn p - path;",
            "}",
            "int audit_compare_dname_path(const struct qstr *dname, const char *path, int parentlen)",
            "{",
            "\tint dlen, pathlen;",
            "\tconst char *p;",
            "",
            "\tdlen = dname->len;",
            "\tpathlen = strlen(path);",
            "\tif (pathlen < dlen)",
            "\t\treturn 1;",
            "",
            "\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;",
            "\tif (pathlen - parentlen != dlen)",
            "\t\treturn 1;",
            "",
            "\tp = path + parentlen;",
            "",
            "\treturn strncmp(p, dname->name, dlen);",
            "}"
          ],
          "function_name": "audit_comparator, audit_uid_comparator, audit_gid_comparator, parent_len, audit_compare_dname_path",
          "description": "提供通用比较逻辑及路径名匹配支持，用于审计规则字段的值比较与父目录长度计算",
          "similarity": 0.6159865260124207
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/auditfilter.c",
          "start_line": 1080,
          "end_line": 1188,
          "content": [
            "static void audit_list_rules(int seq, struct sk_buff_head *q)",
            "{",
            "\tstruct sk_buff *skb;",
            "\tstruct audit_krule *r;",
            "\tint i;",
            "",
            "\t/* This is a blocking read, so use audit_filter_mutex instead of rcu",
            "\t * iterator to sync with list writers. */",
            "\tfor (i = 0; i < AUDIT_NR_FILTERS; i++) {",
            "\t\tlist_for_each_entry(r, &audit_rules_list[i], list) {",
            "\t\t\tstruct audit_rule_data *data;",
            "",
            "\t\t\tdata = audit_krule_to_data(r);",
            "\t\t\tif (unlikely(!data))",
            "\t\t\t\tbreak;",
            "\t\t\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 0, 1,",
            "\t\t\t\t\t       data,",
            "\t\t\t\t\t       struct_size(data, buf, data->buflen));",
            "\t\t\tif (skb)",
            "\t\t\t\tskb_queue_tail(q, skb);",
            "\t\t\tkfree(data);",
            "\t\t}",
            "\t}",
            "\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 1, 1, NULL, 0);",
            "\tif (skb)",
            "\t\tskb_queue_tail(q, skb);",
            "}",
            "static void audit_log_rule_change(char *action, struct audit_krule *rule, int res)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);",
            "\tif (!ab)",
            "\t\treturn;",
            "\taudit_log_session_info(ab);",
            "\taudit_log_task_context(ab);",
            "\taudit_log_format(ab, \" op=%s\", action);",
            "\taudit_log_key(ab, rule->filterkey);",
            "\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);",
            "\taudit_log_end(ab);",
            "}",
            "int audit_rule_change(int type, int seq, void *data, size_t datasz)",
            "{",
            "\tint err = 0;",
            "\tstruct audit_entry *entry;",
            "",
            "\tswitch (type) {",
            "\tcase AUDIT_ADD_RULE:",
            "\t\tentry = audit_data_to_entry(data, datasz);",
            "\t\tif (IS_ERR(entry))",
            "\t\t\treturn PTR_ERR(entry);",
            "\t\terr = audit_add_rule(entry);",
            "\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);",
            "\t\tbreak;",
            "\tcase AUDIT_DEL_RULE:",
            "\t\tentry = audit_data_to_entry(data, datasz);",
            "\t\tif (IS_ERR(entry))",
            "\t\t\treturn PTR_ERR(entry);",
            "\t\terr = audit_del_rule(entry);",
            "\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ON(1);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (err || type == AUDIT_DEL_RULE) {",
            "\t\tif (entry->rule.exe)",
            "\t\t\taudit_remove_mark(entry->rule.exe);",
            "\t\taudit_free_rule(entry);",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "int audit_list_rules_send(struct sk_buff *request_skb, int seq)",
            "{",
            "\tstruct task_struct *tsk;",
            "\tstruct audit_netlink_list *dest;",
            "",
            "\t/* We can't just spew out the rules here because we might fill",
            "\t * the available socket buffer space and deadlock waiting for",
            "\t * auditctl to read from it... which isn't ever going to",
            "\t * happen if we're actually running in the context of auditctl",
            "\t * trying to _send_ the stuff */",
            "",
            "\tdest = kmalloc(sizeof(*dest), GFP_KERNEL);",
            "\tif (!dest)",
            "\t\treturn -ENOMEM;",
            "\tdest->net = get_net(sock_net(NETLINK_CB(request_skb).sk));",
            "\tdest->portid = NETLINK_CB(request_skb).portid;",
            "\tskb_queue_head_init(&dest->q);",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\taudit_list_rules(seq, &dest->q);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\ttsk = kthread_run(audit_send_list_thread, dest, \"audit_send_list\");",
            "\tif (IS_ERR(tsk)) {",
            "\t\tskb_queue_purge(&dest->q);",
            "\t\tput_net(dest->net);",
            "\t\tkfree(dest);",
            "\t\treturn PTR_ERR(tsk);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "audit_list_rules, audit_log_rule_change, audit_rule_change, audit_list_rules_send",
          "description": "实现审计规则列表的生成与发送功能，通过遍历audit_rules_list构建skb队列并异步发送至Netlink套接字，防止阻塞导致死锁",
          "similarity": 0.6147971153259277
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/auditfilter.c",
          "start_line": 940,
          "end_line": 1075,
          "content": [
            "static inline int audit_add_rule(struct audit_entry *entry)",
            "{",
            "\tstruct audit_entry *e;",
            "\tstruct audit_watch *watch = entry->rule.watch;",
            "\tstruct audit_tree *tree = entry->rule.tree;",
            "\tstruct list_head *list;",
            "\tint err = 0;",
            "#ifdef CONFIG_AUDITSYSCALL",
            "\tint dont_count = 0;",
            "",
            "\t/* If any of these, don't count towards total */",
            "\tswitch (entry->rule.listnr) {",
            "\tcase AUDIT_FILTER_USER:",
            "\tcase AUDIT_FILTER_EXCLUDE:",
            "\tcase AUDIT_FILTER_FS:",
            "\t\tdont_count = 1;",
            "\t}",
            "#endif",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\te = audit_find_rule(entry, &list);",
            "\tif (e) {",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\terr = -EEXIST;",
            "\t\t/* normally audit_add_tree_rule() will free it on failure */",
            "\t\tif (tree)",
            "\t\t\taudit_put_tree(tree);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tif (watch) {",
            "\t\t/* audit_filter_mutex is dropped and re-taken during this call */",
            "\t\terr = audit_add_watch(&entry->rule, &list);",
            "\t\tif (err) {",
            "\t\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\t\t/*",
            "\t\t\t * normally audit_add_tree_rule() will free it",
            "\t\t\t * on failure",
            "\t\t\t */",
            "\t\t\tif (tree)",
            "\t\t\t\taudit_put_tree(tree);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "\tif (tree) {",
            "\t\terr = audit_add_tree_rule(&entry->rule);",
            "\t\tif (err) {",
            "\t\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "",
            "\tentry->rule.prio = ~0ULL;",
            "\tif (entry->rule.listnr == AUDIT_FILTER_EXIT ||",
            "\t    entry->rule.listnr == AUDIT_FILTER_URING_EXIT) {",
            "\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)",
            "\t\t\tentry->rule.prio = ++prio_high;",
            "\t\telse",
            "\t\t\tentry->rule.prio = --prio_low;",
            "\t}",
            "",
            "\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {",
            "\t\tlist_add(&entry->rule.list,",
            "\t\t\t &audit_rules_list[entry->rule.listnr]);",
            "\t\tlist_add_rcu(&entry->list, list);",
            "\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;",
            "\t} else {",
            "\t\tlist_add_tail(&entry->rule.list,",
            "\t\t\t      &audit_rules_list[entry->rule.listnr]);",
            "\t\tlist_add_tail_rcu(&entry->list, list);",
            "\t}",
            "#ifdef CONFIG_AUDITSYSCALL",
            "\tif (!dont_count)",
            "\t\taudit_n_rules++;",
            "",
            "\tif (!audit_match_signal(entry))",
            "\t\taudit_signals++;",
            "#endif",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\treturn err;",
            "}",
            "int audit_del_rule(struct audit_entry *entry)",
            "{",
            "\tstruct audit_entry  *e;",
            "\tstruct audit_tree *tree = entry->rule.tree;",
            "\tstruct list_head *list;",
            "\tint ret = 0;",
            "#ifdef CONFIG_AUDITSYSCALL",
            "\tint dont_count = 0;",
            "",
            "\t/* If any of these, don't count towards total */",
            "\tswitch (entry->rule.listnr) {",
            "\tcase AUDIT_FILTER_USER:",
            "\tcase AUDIT_FILTER_EXCLUDE:",
            "\tcase AUDIT_FILTER_FS:",
            "\t\tdont_count = 1;",
            "\t}",
            "#endif",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\te = audit_find_rule(entry, &list);",
            "\tif (!e) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (e->rule.watch)",
            "\t\taudit_remove_watch_rule(&e->rule);",
            "",
            "\tif (e->rule.tree)",
            "\t\taudit_remove_tree_rule(&e->rule);",
            "",
            "\tif (e->rule.exe)",
            "\t\taudit_remove_mark_rule(&e->rule);",
            "",
            "#ifdef CONFIG_AUDITSYSCALL",
            "\tif (!dont_count)",
            "\t\taudit_n_rules--;",
            "",
            "\tif (!audit_match_signal(entry))",
            "\t\taudit_signals--;",
            "#endif",
            "",
            "\tlist_del_rcu(&e->list);",
            "\tlist_del(&e->rule.list);",
            "\tcall_rcu(&e->rcu, audit_free_rule_rcu);",
            "",
            "out:",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\tif (tree)",
            "\t\taudit_put_tree(tree);\t/* that's the temporary one */",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "audit_add_rule, audit_del_rule",
          "description": "提供审计规则增删操作，包含链表插入/删除、优先级分配、计数更新及资源引用计数管理，采用互斥锁和RCU机制保障线程安全。",
          "similarity": 0.5745720863342285
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/auditfilter.c",
          "start_line": 1331,
          "end_line": 1431,
          "content": [
            "int audit_filter(int msgtype, unsigned int listtype)",
            "{",
            "\tstruct audit_entry *e;",
            "\tint ret = 1; /* Audit by default */",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {",
            "\t\tint i, result = 0;",
            "",
            "\t\tfor (i = 0; i < e->rule.field_count; i++) {",
            "\t\t\tstruct audit_field *f = &e->rule.fields[i];",
            "\t\t\tpid_t pid;",
            "\t\t\tu32 sid;",
            "",
            "\t\t\tswitch (f->type) {",
            "\t\t\tcase AUDIT_PID:",
            "\t\t\t\tpid = task_pid_nr(current);",
            "\t\t\t\tresult = audit_comparator(pid, f->op, f->val);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_UID:",
            "\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_GID:",
            "\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_LOGINUID:",
            "\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),",
            "\t\t\t\t\t\t\t      f->op, f->uid);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_LOGINUID_SET:",
            "\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),",
            "\t\t\t\t\t\t\t  f->op, f->val);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_MSGTYPE:",
            "\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_SUBJ_USER:",
            "\t\t\tcase AUDIT_SUBJ_ROLE:",
            "\t\t\tcase AUDIT_SUBJ_TYPE:",
            "\t\t\tcase AUDIT_SUBJ_SEN:",
            "\t\t\tcase AUDIT_SUBJ_CLR:",
            "\t\t\t\tif (f->lsm_rule) {",
            "\t\t\t\t\tsecurity_current_getsecid_subj(&sid);",
            "\t\t\t\t\tresult = security_audit_rule_match(sid,",
            "\t\t\t\t\t\t   f->type, f->op, f->lsm_rule);",
            "\t\t\t\t}",
            "\t\t\t\tbreak;",
            "\t\t\tcase AUDIT_EXE:",
            "\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);",
            "\t\t\t\tif (f->op == Audit_not_equal)",
            "\t\t\t\t\tresult = !result;",
            "\t\t\t\tbreak;",
            "\t\t\tdefault:",
            "\t\t\t\tgoto unlock_and_return;",
            "\t\t\t}",
            "\t\t\tif (result < 0) /* error */",
            "\t\t\t\tgoto unlock_and_return;",
            "\t\t\tif (!result)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (result > 0) {",
            "\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)",
            "\t\t\t\tret = 0;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "unlock_and_return:",
            "\trcu_read_unlock();",
            "\treturn ret;",
            "}",
            "static int update_lsm_rule(struct audit_krule *r)",
            "{",
            "\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);",
            "\tstruct audit_entry *nentry;",
            "\tint err = 0;",
            "",
            "\tif (!security_audit_rule_known(r))",
            "\t\treturn 0;",
            "",
            "\tnentry = audit_dupe_rule(r);",
            "\tif (entry->rule.exe)",
            "\t\taudit_remove_mark(entry->rule.exe);",
            "\tif (IS_ERR(nentry)) {",
            "\t\t/* save the first error encountered for the",
            "\t\t * return value */",
            "\t\terr = PTR_ERR(nentry);",
            "\t\taudit_panic(\"error updating LSM filters\");",
            "\t\tif (r->watch)",
            "\t\t\tlist_del(&r->rlist);",
            "\t\tlist_del_rcu(&entry->list);",
            "\t\tlist_del(&r->list);",
            "\t} else {",
            "\t\tif (r->watch || r->tree)",
            "\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);",
            "\t\tlist_replace_rcu(&entry->list, &nentry->list);",
            "\t\tlist_replace(&r->list, &nentry->rule.list);",
            "\t}",
            "\tcall_rcu(&entry->rcu, audit_free_rule_rcu);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "audit_filter, update_lsm_rule",
          "description": "执行审计过滤决策逻辑，基于当前进程属性与规则字段进行匹配判断，并维护LSM安全模块的规则状态",
          "similarity": 0.5733509063720703
        }
      ]
    }
  ]
}