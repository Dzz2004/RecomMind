{
  "query": "pthread_cond_wait实现原理分析",
  "timestamp": "2025-12-26 00:55:44",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/wait.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:20:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\wait.c`\n\n---\n\n# `sched/wait.c` 技术文档\n\n## 1. 文件概述\n\n`sched/wait.c` 是 Linux 内核中实现通用等待队列（wait queue）机制的核心文件。该机制用于线程在特定条件满足前进入睡眠状态，并在条件就绪时被唤醒。文件提供了等待队列的初始化、添加/移除等待项、以及多种唤醒策略（包括普通唤醒、独占唤醒、优先级唤醒、同步唤醒等）的实现，是内核同步与调度子系统的重要组成部分。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__init_waitqueue_head`**  \n  初始化一个等待队列头，设置自旋锁、锁类信息和空链表。\n\n- **`add_wait_queue`**  \n  将一个非独占等待项添加到等待队列头部。\n\n- **`add_wait_queue_exclusive`**  \n  将一个独占等待项添加到等待队列尾部（用于避免“惊群”问题）。\n\n- **`add_wait_queue_priority`**  \n  添加具有独占性和优先级标志的等待项，插入到队列头部。\n\n- **`remove_wait_queue`**  \n  从等待队列中安全移除指定的等待项。\n\n- **`__wake_up` / `__wake_up_common`**  \n  核心唤醒函数，支持唤醒非独占任务和指定数量的独占任务。\n\n- **`__wake_up_sync_key` / `__wake_up_locked_sync_key`**  \n  同步唤醒函数，避免目标任务被迁移到其他 CPU，减少缓存颠簸。\n\n- **`__wake_up_on_current_cpu`**  \n  仅在当前 CPU 上唤醒一个任务。\n\n- **`__wake_up_pollfree`**  \n  专用于 poll 机制的唤醒，发送 `POLLFREE` 事件并验证队列已清空。\n\n- **`prepare_to_wait` / `prepare_to_wait_exclusive`**  \n  将当前任务加入等待队列并设置其睡眠状态，后者返回是否为队列中首个等待者。\n\n### 关键数据结构\n\n- **`struct wait_queue_head`**  \n  等待队列头，包含自旋锁 `lock` 和双向链表 `head`。\n\n- **`struct wait_queue_entry`**  \n  等待队列项，包含回调函数 `func`、任务指针、标志位（如 `WQ_FLAG_EXCLUSIVE`、`WQ_FLAG_PRIORITY`）及链表节点。\n\n## 3. 关键实现\n\n### 等待队列组织策略\n\n- **非独占任务**：通过 `add_wait_queue` 添加至队列**头部**，唤醒时优先处理。\n- **独占任务**：通过 `add_wait_queue_exclusive` 添加至队列**尾部**，确保在非独占任务之后唤醒，避免多个独占任务同时被唤醒（解决“惊群”问题）。\n- **优先级任务**：通过 `add_wait_queue_priority` 添加至**头部**，并标记为独占+优先级，可在唤醒时优先消费事件。\n\n### 唤醒逻辑（`__wake_up_common`）\n\n1. 遍历等待队列中的每个等待项。\n2. 调用其回调函数 `func`（通常为 `default_wake_function`），尝试唤醒对应任务。\n3. 若回调返回正值且该项为独占任务，则减少 `nr_exclusive` 计数；当计数归零时停止唤醒。\n4. 非独占任务始终被唤醒（除非回调返回负值中断流程）。\n\n### 内存屏障与 SMP 安全\n\n- 在 `prepare_to_wait` 中，**先加锁添加等待项，再调用 `set_current_state()`**，确保 SMP 系统下唤醒者能看到完整的等待状态，避免竞态。\n- 所有对外接口均使用 `spin_lock_irqsave`/`restore` 保证中断上下文安全。\n\n### 同步唤醒优化\n\n- `WF_SYNC` 标志告知调度器：唤醒者即将主动调度（如调用 `schedule()`），因此被唤醒任务应尽量留在当前 CPU，减少迁移开销。\n- 在单处理器（UP）系统上可避免不必要的抢占。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `try_to_wake_up()` 等底层唤醒函数（定义于 `kernel/sched/core.c`）。\n- **锁调试机制**：使用 `lockdep_set_class_and_name` 进行锁类跟踪（`kernel/locking/lockdep.c`）。\n- **内存屏障原语**：依赖架构相关的内存屏障实现（如 `smp_mb()`）。\n- **poll 机制**：`__wake_up_pollfree` 与 `fs/select.c` 中的 poll 实现紧密耦合。\n- **EXPORT_SYMBOL**：向内核其他模块（如驱动、文件系统）导出通用等待/唤醒接口。\n\n## 5. 使用场景\n\n- **设备驱动**：驱动程序在无数据可读/写时将进程加入等待队列，硬件就绪时唤醒。\n- **文件系统**：如 inode 锁、页缓存 I/O 等待。\n- **IPC 机制**：信号量、互斥锁、完成量（completion）等同步原语的底层实现。\n- **网络子系统**：socket 接收/发送缓冲区满或空时的阻塞等待。\n- **内核线程同步**：工作者线程等待工作项到达。\n- **poll/epoll**：通过 `poll_wait()` 注册等待队列，事件触发时唤醒用户进程。",
      "similarity": 0.6089599132537842,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/wait.c",
          "start_line": 8,
          "end_line": 111,
          "content": [
            "void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)",
            "{",
            "\tspin_lock_init(&wq_head->lock);",
            "\tlockdep_set_class_and_name(&wq_head->lock, key, name);",
            "\tINIT_LIST_HEAD(&wq_head->head);",
            "}",
            "void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t__add_wait_queue(wq_head, wq_entry);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t__add_wait_queue_entry_tail(wq_head, wq_entry);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "void add_wait_queue_priority(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\twq_entry->flags |= WQ_FLAG_EXCLUSIVE | WQ_FLAG_PRIORITY;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t__add_wait_queue(wq_head, wq_entry);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t__remove_wait_queue(wq_head, wq_entry);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,",
            "\t\t\tint nr_exclusive, int wake_flags, void *key)",
            "{",
            "\twait_queue_entry_t *curr, *next;",
            "",
            "\tlockdep_assert_held(&wq_head->lock);",
            "",
            "\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);",
            "",
            "\tif (&curr->entry == &wq_head->head)",
            "\t\treturn nr_exclusive;",
            "",
            "\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {",
            "\t\tunsigned flags = curr->flags;",
            "\t\tint ret;",
            "",
            "\t\tret = curr->func(curr, mode, wake_flags, key);",
            "\t\tif (ret < 0)",
            "\t\t\tbreak;",
            "\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn nr_exclusive;",
            "}",
            "static int __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,",
            "\t\t\tint nr_exclusive, int wake_flags, void *key)",
            "{",
            "\tunsigned long flags;",
            "\tint remaining;",
            "",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\tremaining = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags,",
            "\t\t\tkey);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "",
            "\treturn nr_exclusive - remaining;",
            "}",
            "int __wake_up(struct wait_queue_head *wq_head, unsigned int mode,",
            "\t      int nr_exclusive, void *key)",
            "{",
            "\treturn __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);",
            "}",
            "void __wake_up_on_current_cpu(struct wait_queue_head *wq_head, unsigned int mode, void *key)",
            "{",
            "\t__wake_up_common_lock(wq_head, mode, 1, WF_CURRENT_CPU, key);",
            "}",
            "void __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr)",
            "{",
            "\t__wake_up_common(wq_head, mode, nr, 0, NULL);",
            "}",
            "void __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key)",
            "{",
            "\t__wake_up_common(wq_head, mode, 1, 0, key);",
            "}",
            "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,",
            "\t\t\tvoid *key)",
            "{",
            "\tif (unlikely(!wq_head))",
            "\t\treturn;",
            "",
            "\t__wake_up_common_lock(wq_head, mode, 1, WF_SYNC, key);",
            "}"
          ],
          "function_name": "__init_waitqueue_head, add_wait_queue, add_wait_queue_exclusive, add_wait_queue_priority, remove_wait_queue, __wake_up_common, __wake_up_common_lock, __wake_up, __wake_up_on_current_cpu, __wake_up_locked, __wake_up_locked_key, __wake_up_sync_key",
          "description": "实现等待队列核心管理函数，包含初始化头结构、添加/移除等待项、唤醒逻辑及多种唤醒变体，通过自旋锁保护并发访问",
          "similarity": 0.587925910949707
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/wait.c",
          "start_line": 193,
          "end_line": 306,
          "content": [
            "void __wake_up_locked_sync_key(struct wait_queue_head *wq_head,",
            "\t\t\t       unsigned int mode, void *key)",
            "{",
            "        __wake_up_common(wq_head, mode, 1, WF_SYNC, key);",
            "}",
            "void __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode)",
            "{",
            "\t__wake_up_sync_key(wq_head, mode, NULL);",
            "}",
            "void __wake_up_pollfree(struct wait_queue_head *wq_head)",
            "{",
            "\t__wake_up(wq_head, TASK_NORMAL, 0, poll_to_key(EPOLLHUP | POLLFREE));",
            "\t/* POLLFREE must have cleared the queue. */",
            "\tWARN_ON_ONCE(waitqueue_active(wq_head));",
            "}",
            "void",
            "prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)",
            "{",
            "\tunsigned long flags;",
            "",
            "\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\tif (list_empty(&wq_entry->entry))",
            "\t\t__add_wait_queue(wq_head, wq_entry);",
            "\tset_current_state(state);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "bool",
            "prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)",
            "{",
            "\tunsigned long flags;",
            "\tbool was_empty = false;",
            "",
            "\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\tif (list_empty(&wq_entry->entry)) {",
            "\t\twas_empty = list_empty(&wq_head->head);",
            "\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);",
            "\t}",
            "\tset_current_state(state);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "\treturn was_empty;",
            "}",
            "void init_wait_entry(struct wait_queue_entry *wq_entry, int flags)",
            "{",
            "\twq_entry->flags = flags;",
            "\twq_entry->private = current;",
            "\twq_entry->func = autoremove_wake_function;",
            "\tINIT_LIST_HEAD(&wq_entry->entry);",
            "}",
            "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)",
            "{",
            "\tunsigned long flags;",
            "\tlong ret = 0;",
            "",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\tif (signal_pending_state(state, current)) {",
            "\t\t/*",
            "\t\t * Exclusive waiter must not fail if it was selected by wakeup,",
            "\t\t * it should \"consume\" the condition we were waiting for.",
            "\t\t *",
            "\t\t * The caller will recheck the condition and return success if",
            "\t\t * we were already woken up, we can not miss the event because",
            "\t\t * wakeup locks/unlocks the same wq_head->lock.",
            "\t\t *",
            "\t\t * But we need to ensure that set-condition + wakeup after that",
            "\t\t * can't see us, it should wake up another exclusive waiter if",
            "\t\t * we fail.",
            "\t\t */",
            "\t\tlist_del_init(&wq_entry->entry);",
            "\t\tret = -ERESTARTSYS;",
            "\t} else {",
            "\t\tif (list_empty(&wq_entry->entry)) {",
            "\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)",
            "\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);",
            "\t\t\telse",
            "\t\t\t\t__add_wait_queue(wq_head, wq_entry);",
            "\t\t}",
            "\t\tset_current_state(state);",
            "\t}",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "int do_wait_intr(wait_queue_head_t *wq, wait_queue_entry_t *wait)",
            "{",
            "\tif (likely(list_empty(&wait->entry)))",
            "\t\t__add_wait_queue_entry_tail(wq, wait);",
            "",
            "\tset_current_state(TASK_INTERRUPTIBLE);",
            "\tif (signal_pending(current))",
            "\t\treturn -ERESTARTSYS;",
            "",
            "\tspin_unlock(&wq->lock);",
            "\tschedule();",
            "\tspin_lock(&wq->lock);",
            "",
            "\treturn 0;",
            "}",
            "int do_wait_intr_irq(wait_queue_head_t *wq, wait_queue_entry_t *wait)",
            "{",
            "\tif (likely(list_empty(&wait->entry)))",
            "\t\t__add_wait_queue_entry_tail(wq, wait);",
            "",
            "\tset_current_state(TASK_INTERRUPTIBLE);",
            "\tif (signal_pending(current))",
            "\t\treturn -ERESTARTSYS;",
            "",
            "\tspin_unlock_irq(&wq->lock);",
            "\tschedule();",
            "\tspin_lock_irq(&wq->lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__wake_up_locked_sync_key, __wake_up_sync, __wake_up_pollfree, prepare_to_wait, prepare_to_wait_exclusive, init_wait_entry, prepare_to_wait_event, do_wait_intr, do_wait_intr_irq",
          "description": "提供等待状态准备、事件等待及中断处理辅助函数，支持独占等待、信号检测和任务调度，处理等待队列插入与状态切换",
          "similarity": 0.5689795017242432
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sched/wait.c",
          "start_line": 356,
          "end_line": 419,
          "content": [
            "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\t__set_current_state(TASK_RUNNING);",
            "\t/*",
            "\t * We can check for list emptiness outside the lock",
            "\t * IFF:",
            "\t *  - we use the \"careful\" check that verifies both",
            "\t *    the next and prev pointers, so that there cannot",
            "\t *    be any half-pending updates in progress on other",
            "\t *    CPU's that we haven't seen yet (and that might",
            "\t *    still change the stack area.",
            "\t * and",
            "\t *  - all other users take the lock (ie we can only",
            "\t *    have _one_ other CPU that looks at or modifies",
            "\t *    the list).",
            "\t */",
            "\tif (!list_empty_careful(&wq_entry->entry)) {",
            "\t\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t\tlist_del_init(&wq_entry->entry);",
            "\t\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "\t}",
            "}",
            "int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)",
            "{",
            "\tint ret = default_wake_function(wq_entry, mode, sync, key);",
            "",
            "\tif (ret)",
            "\t\tlist_del_init_careful(&wq_entry->entry);",
            "",
            "\treturn ret;",
            "}",
            "long wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout)",
            "{",
            "\t/*",
            "\t * The below executes an smp_mb(), which matches with the full barrier",
            "\t * executed by the try_to_wake_up() in woken_wake_function() such that",
            "\t * either we see the store to wq_entry->flags in woken_wake_function()",
            "\t * or woken_wake_function() sees our store to current->state.",
            "\t */",
            "\tset_current_state(mode); /* A */",
            "\tif (!(wq_entry->flags & WQ_FLAG_WOKEN) && !kthread_should_stop_or_park())",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\t/*",
            "\t * The below executes an smp_mb(), which matches with the smp_mb() (C)",
            "\t * in woken_wake_function() such that either we see the wait condition",
            "\t * being true or the store to wq_entry->flags in woken_wake_function()",
            "\t * follows ours in the coherence order.",
            "\t */",
            "\tsmp_store_mb(wq_entry->flags, wq_entry->flags & ~WQ_FLAG_WOKEN); /* B */",
            "",
            "\treturn timeout;",
            "}",
            "int woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)",
            "{",
            "\t/* Pairs with the smp_store_mb() in wait_woken(). */",
            "\tsmp_mb(); /* C */",
            "\twq_entry->flags |= WQ_FLAG_WOKEN;",
            "",
            "\treturn default_wake_function(wq_entry, mode, sync, key);",
            "}"
          ],
          "function_name": "finish_wait, autoremove_wake_function, wait_woken, woken_wake_function",
          "description": "实现等待结束清理与自动移除唤醒回调，包含状态转换屏障、唤醒标记更新及条件判断逻辑，确保内存顺序一致性",
          "similarity": 0.5364285707473755
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/wait.c",
          "start_line": 1,
          "end_line": 7,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Generic waiting primitives.",
            " *",
            " * (C) 2004 Nadia Yvette Chambers, Oracle",
            " */",
            ""
          ],
          "function_name": null,
          "description": "定义等待队列通用原语的头部注释，声明GPL许可及原始作者信息",
          "similarity": 0.5099464654922485
        }
      ]
    },
    {
      "source_file": "kernel/sched/wait_bit.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:21:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\wait_bit.c`\n\n---\n\n# `sched/wait_bit.c` 技术文档\n\n## 1. 文件概述\n\n`sched/wait_bit.c` 实现了 Linux 内核中基于**位（bit）等待机制**的通用等待/唤醒接口。该机制允许任务在某个内存地址的特定位被清除（或满足特定条件）之前进入睡眠状态，并在该位状态改变时被唤醒。这种机制广泛用于页缓存、inode 状态、设备状态等需要基于位标志进行同步的场景。\n\n该文件提供了一套标准化的等待队列哈希表、等待入口结构、唤醒函数以及通用等待循环逻辑，支持可中断、不可中断、带超时、I/O 调度等多种等待模式。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`bit_wait_table[WAIT_TABLE_SIZE]`**  \n  全局静态哈希等待队列数组，大小为 256（`WAIT_TABLE_BITS = 8`），用于将不同 `(word, bit)` 对映射到不同的等待队列，减少竞争。\n\n- **`struct wait_bit_key`**  \n  表示等待目标的键结构，包含：\n  - `void *flags`：指向被监视的位图（word）\n  - `int bit_nr`：被监视的位编号（-1 表示变量级等待）\n  - `unsigned long timeout`：超时时间（仅用于带超时的等待）\n\n- **`struct wait_bit_queue_entry`**  \n  等待队列项，内嵌 `wait_queue_entry`，包含一个 `wait_bit_key`，用于在唤醒时匹配目标。\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `bit_waitqueue(void *word, int bit)` | 根据 `(word, bit)` 计算并返回对应的哈希等待队列头 |\n| `__wait_on_bit()` | 通用位等待循环：测试位状态，调用用户动作函数，直到位清除或动作返回非零 |\n| `__wait_on_bit_lock()` | 带“锁语义”的位等待：在位清除后尝试原子置位，实现类似自旋锁的获取逻辑 |\n| `out_of_line_wait_on_bit*()` | 封装函数，用于避免内联膨胀，供外部模块调用 |\n| `wake_up_bit(void *word, int bit)` | 唤醒所有在 `(word, bit)` 上等待的任务 |\n| `__wake_up_bit()` | `wake_up_bit` 的底层实现 |\n| `bit_wait*()` 系列函数 | 预定义的等待动作函数：<br> - `bit_wait`：普通调度<br> - `bit_wait_io`：I/O 调度<br> - `bit_wait_timeout`：带超时普通调度<br> - `bit_wait_io_timeout`：带超时 I/O 调度 |\n| `init_wait_var_entry()` / `wake_up_var()` | 支持对整个变量（而非特定位）的等待/唤醒（`bit_nr = -1`） |\n| `wait_bit_init()` | 初始化 `bit_wait_table` 中的所有等待队列头 |\n\n## 3. 关键实现\n\n### 哈希映射机制\n- 使用 `hash_long(val, WAIT_TABLE_BITS)` 对 `(word << shift | bit)` 进行哈希，其中 `shift` 为 5（32 位）或 6（64 位），确保地址对齐不影响哈希分布。\n- `__cacheline_aligned` 保证 `bit_wait_table` 按缓存行对齐，减少 false sharing。\n\n### 等待循环逻辑\n- `__wait_on_bit()`：  \n  循环中先 `prepare_to_wait()` 加入队列，然后测试位是否仍置位。若是，则调用用户提供的 `action` 函数（如 `bit_wait`）。循环继续直到位被清除或 `action` 返回非零（如收到信号）。\n- `__wait_on_bit_lock()`：  \n  使用 `prepare_to_wait_exclusive()` 加入**独占等待队列**，避免惊群效应。在位清除后，尝试 `test_and_set_bit()` 原子置位，成功则获得“锁”；失败则继续等待。\n\n### 唤醒匹配机制\n- `wake_bit_function()` 作为默认唤醒回调，仅当 `wait_bit_key` 的 `flags` 和 `bit_nr` 与唤醒参数完全匹配 **且** 目标位**仍为置位状态**时，才调用 `autoremove_wake_function` 唤醒任务。\n- 注意：**唤醒前必须确保内存屏障**（如 `smp_mb__after_atomic()`），以保证位清除操作对等待者可见。\n\n### 变量级等待支持\n- 通过 `bit_nr = -1` 实现对整个指针变量的等待（如 `wait_var_event()` 宏），由 `var_wake_function()` 处理匹配逻辑（忽略 `bit_nr`）。\n\n### 超时处理\n- 超时版本（如 `out_of_line_wait_on_bit_timeout`）在 `wait_bit_key` 中设置 `timeout = jiffies + timeout`，由 `bit_wait_timeout` 等函数检查是否超时。\n\n## 4. 依赖关系\n\n- **头文件依赖**：  \n  依赖 `<linux/wait.h>`、`<linux/sched.h>`、`<linux/hash.h>` 等，使用 `wait_queue_head_t`、`prepare_to_wait`、`schedule` 等核心调度原语。\n- **内联宏依赖**：  \n  依赖 `DEFINE_WAIT_BIT`、`__WAIT_BIT_KEY_INITIALIZER` 等宏（定义在 `wait.h` 中）。\n- **导出符号**：  \n  多个函数通过 `EXPORT_SYMBOL` 或 `EXPORT_SYMBOL_GPL` 导出，供其他内核模块（如 `mm/`、`fs/`、`block/`）使用。\n- **初始化依赖**：  \n  `wait_bit_init()` 由内核启动时调用（通过 `core_initcall` 或类似机制），确保 `bit_wait_table` 在使用前初始化。\n\n## 5. 使用场景\n\n- **页缓存状态同步**：  \n  在 `mm/filemap.c` 中，等待页面 `PG_locked`、`PG_writeback` 等标志位清除。\n- **Inode 状态等待**：  \n  在 `fs/inode.c` 中，等待 `I_SYNC`、`I_FREEING` 等 inode 标志。\n- **块设备 I/O 等待**：  \n  等待请求完成标志位。\n- **通用位标志同步**：  \n  任何需要基于单个位进行任务阻塞/唤醒的场景，如设备状态机、资源锁等。\n- **变量值等待**：  \n  通过 `wait_var_event()` 等宏，等待某个变量变为特定值（底层使用 `bit_nr = -1` 机制）。\n\n该机制提供了一种轻量、高效、可扩展的基于位的同步原语，是 Linux 内核中重要的底层同步基础设施之一。",
      "similarity": 0.601638674736023,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/wait_bit.c",
          "start_line": 21,
          "end_line": 128,
          "content": [
            "int wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *arg)",
            "{",
            "\tstruct wait_bit_key *key = arg;",
            "\tstruct wait_bit_queue_entry *wait_bit = container_of(wq_entry, struct wait_bit_queue_entry, wq_entry);",
            "",
            "\tif (wait_bit->key.flags != key->flags ||",
            "\t\t\twait_bit->key.bit_nr != key->bit_nr ||",
            "\t\t\ttest_bit(key->bit_nr, key->flags))",
            "\t\treturn 0;",
            "",
            "\treturn autoremove_wake_function(wq_entry, mode, sync, key);",
            "}",
            "int __sched",
            "__wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,",
            "\t      wait_bit_action_f *action, unsigned mode)",
            "{",
            "\tint ret = 0;",
            "",
            "\tdo {",
            "\t\tprepare_to_wait(wq_head, &wbq_entry->wq_entry, mode);",
            "\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags))",
            "\t\t\tret = (*action)(&wbq_entry->key, mode);",
            "\t} while (test_bit_acquire(wbq_entry->key.bit_nr, wbq_entry->key.flags) && !ret);",
            "",
            "\tfinish_wait(wq_head, &wbq_entry->wq_entry);",
            "",
            "\treturn ret;",
            "}",
            "int __sched out_of_line_wait_on_bit(void *word, int bit,",
            "\t\t\t\t    wait_bit_action_f *action, unsigned mode)",
            "{",
            "\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);",
            "\tDEFINE_WAIT_BIT(wq_entry, word, bit);",
            "",
            "\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);",
            "}",
            "int __sched out_of_line_wait_on_bit_timeout(",
            "\tvoid *word, int bit, wait_bit_action_f *action,",
            "\tunsigned mode, unsigned long timeout)",
            "{",
            "\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);",
            "\tDEFINE_WAIT_BIT(wq_entry, word, bit);",
            "",
            "\twq_entry.key.timeout = jiffies + timeout;",
            "",
            "\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);",
            "}",
            "int __sched",
            "__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,",
            "\t\t\twait_bit_action_f *action, unsigned mode)",
            "{",
            "\tint ret = 0;",
            "",
            "\tfor (;;) {",
            "\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);",
            "\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {",
            "\t\t\tret = action(&wbq_entry->key, mode);",
            "\t\t\t/*",
            "\t\t\t * See the comment in prepare_to_wait_event().",
            "\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,",
            "\t\t\t * but test_and_set_bit() implies mb() which pairs with",
            "\t\t\t * smp_mb__after_atomic() before wake_up_page().",
            "\t\t\t */",
            "\t\t\tif (ret)",
            "\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);",
            "\t\t}",
            "\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {",
            "\t\t\tif (!ret)",
            "\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);",
            "\t\t\treturn 0;",
            "\t\t} else if (ret) {",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t}",
            "}",
            "int __sched out_of_line_wait_on_bit_lock(void *word, int bit,",
            "\t\t\t\t\t wait_bit_action_f *action, unsigned mode)",
            "{",
            "\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);",
            "\tDEFINE_WAIT_BIT(wq_entry, word, bit);",
            "",
            "\treturn __wait_on_bit_lock(wq_head, &wq_entry, action, mode);",
            "}",
            "void __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)",
            "{",
            "\tstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);",
            "",
            "\tif (waitqueue_active(wq_head))",
            "\t\t__wake_up(wq_head, TASK_NORMAL, 1, &key);",
            "}",
            "void wake_up_bit(void *word, int bit)",
            "{",
            "\t__wake_up_bit(bit_waitqueue(word, bit), word, bit);",
            "}",
            "static int",
            "var_wake_function(struct wait_queue_entry *wq_entry, unsigned int mode,",
            "\t\t  int sync, void *arg)",
            "{",
            "\tstruct wait_bit_key *key = arg;",
            "\tstruct wait_bit_queue_entry *wbq_entry =",
            "\t\tcontainer_of(wq_entry, struct wait_bit_queue_entry, wq_entry);",
            "",
            "\tif (wbq_entry->key.flags != key->flags ||",
            "\t    wbq_entry->key.bit_nr != key->bit_nr)",
            "\t\treturn 0;",
            "",
            "\treturn autoremove_wake_function(wq_entry, mode, sync, key);",
            "}"
          ],
          "function_name": "wake_bit_function, __wait_on_bit, out_of_line_wait_on_bit, out_of_line_wait_on_bit_timeout, __wait_on_bit_lock, out_of_line_wait_on_bit_lock, __wake_up_bit, wake_up_bit, var_wake_function",
          "description": "实现等待位相关的核心函数，包括等待操作、唤醒逻辑及锁操作，管理等待队列中的等待项并处理位状态变化；上下文不完整",
          "similarity": 0.5851700305938721
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/wait_bit.c",
          "start_line": 174,
          "end_line": 239,
          "content": [
            "void init_wait_var_entry(struct wait_bit_queue_entry *wbq_entry, void *var, int flags)",
            "{",
            "\t*wbq_entry = (struct wait_bit_queue_entry){",
            "\t\t.key = {",
            "\t\t\t.flags\t= (var),",
            "\t\t\t.bit_nr = -1,",
            "\t\t},",
            "\t\t.wq_entry = {",
            "\t\t\t.flags\t = flags,",
            "\t\t\t.private = current,",
            "\t\t\t.func\t = var_wake_function,",
            "\t\t\t.entry\t = LIST_HEAD_INIT(wbq_entry->wq_entry.entry),",
            "\t\t},",
            "\t};",
            "}",
            "void wake_up_var(void *var)",
            "{",
            "\t__wake_up_bit(__var_waitqueue(var), var, -1);",
            "}",
            "__sched int bit_wait(struct wait_bit_key *word, int mode)",
            "{",
            "\tschedule();",
            "\tif (signal_pending_state(mode, current))",
            "\t\treturn -EINTR;",
            "",
            "\treturn 0;",
            "}",
            "__sched int bit_wait_io(struct wait_bit_key *word, int mode)",
            "{",
            "\tio_schedule();",
            "\tif (signal_pending_state(mode, current))",
            "\t\treturn -EINTR;",
            "",
            "\treturn 0;",
            "}",
            "__sched int bit_wait_timeout(struct wait_bit_key *word, int mode)",
            "{",
            "\tunsigned long now = READ_ONCE(jiffies);",
            "",
            "\tif (time_after_eq(now, word->timeout))",
            "\t\treturn -EAGAIN;",
            "\tschedule_timeout(word->timeout - now);",
            "\tif (signal_pending_state(mode, current))",
            "\t\treturn -EINTR;",
            "",
            "\treturn 0;",
            "}",
            "__sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)",
            "{",
            "\tunsigned long now = READ_ONCE(jiffies);",
            "",
            "\tif (time_after_eq(now, word->timeout))",
            "\t\treturn -EAGAIN;",
            "\tio_schedule_timeout(word->timeout - now);",
            "\tif (signal_pending_state(mode, current))",
            "\t\treturn -EINTR;",
            "",
            "\treturn 0;",
            "}",
            "void __init wait_bit_init(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < WAIT_TABLE_SIZE; i++)",
            "\t\tinit_waitqueue_head(bit_wait_table + i);",
            "}"
          ],
          "function_name": "init_wait_var_entry, wake_up_var, bit_wait, bit_wait_io, bit_wait_timeout, bit_wait_io_timeout, wait_bit_init",
          "description": "提供等待变量初始化与唤醒接口，实现基于等待位的阻塞等待逻辑，并初始化等待位哈希表；上下文不完整",
          "similarity": 0.5696005821228027
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/wait_bit.c",
          "start_line": 1,
          "end_line": 20,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "/*",
            " * The implementation of the wait_bit*() and related waiting APIs:",
            " */",
            "",
            "#define WAIT_TABLE_BITS 8",
            "#define WAIT_TABLE_SIZE (1 << WAIT_TABLE_BITS)",
            "",
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE] __cacheline_aligned;",
            "",
            "wait_queue_head_t *bit_waitqueue(void *word, int bit)",
            "{",
            "\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;",
            "\tunsigned long val = (unsigned long)word << shift | bit;",
            "",
            "\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);",
            "}",
            "EXPORT_SYMBOL(bit_waitqueue);",
            ""
          ],
          "function_name": null,
          "description": "定义等待位哈希表及其查找函数，通过哈希将不同等待位映射到对应的等待队列头，用于后续的等待和唤醒操作；上下文不完整",
          "similarity": 0.5175010561943054
        }
      ]
    },
    {
      "source_file": "kernel/sched/swait.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:18:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\swait.c`\n\n---\n\n# `sched/swait.c` 技术文档\n\n## 1. 文件概述\n\n`sched/swait.c` 是 Linux 内核中 **简单等待队列（simple wait queues）** 的核心实现文件，对应头文件为 `<linux/swait.h>`。该机制提供了一种轻量级、低开销的进程等待与唤醒基础设施，相比传统的 `wait_queue`，`swait` 去除了复杂的回调函数、唤醒过滤器等特性，仅保留最基本的 FIFO 等待队列功能，适用于对性能和代码简洁性要求较高的场景（如 completion 机制）。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct swait_queue_head`：简单等待队列头，包含一个自旋锁 `lock` 和一个任务链表 `task_list`。\n- `struct swait_queue`：代表一个等待项，包含指向当前任务 `task` 的指针和链表节点 `task_list`。\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|---------|\n| `__init_swait_queue_head()` | 初始化 `swait_queue_head` 结构，设置锁类信息和初始化链表。 |\n| `swake_up_locked()` | 在已持有队列锁的前提下，唤醒队列中的**第一个**等待任务并将其从队列中移除。 |\n| `swake_up_all_locked()` | 在已持有队列锁的前提下，**循环唤醒所有**等待任务（专用于 completion）。 |\n| `swake_up_one()` | 安全地唤醒队列中的**第一个**等待任务（自动加锁/关中断）。 |\n| `swake_up_all()` | 安全地唤醒**所有**等待任务，支持从中断上下文调用，但内部会临时释放锁以避免长时间持锁。 |\n| `__prepare_to_swait()` | 将当前任务加入等待队列（需外部加锁）。 |\n| `prepare_to_swait_exclusive()` | 将当前任务以指定状态加入等待队列，并设置任务状态（自动加锁/关中断）。 |\n| `prepare_to_swait_event()` | 类似 `prepare_to_swait_exclusive()`，但会检查是否有挂起信号，若有则返回 `-ERESTARTSYS`。 |\n| `__finish_swait()` / `finish_swait()` | 清理等待状态，将任务从队列中移除并恢复为 `TASK_RUNNING` 状态。 |\n\n## 3. 关键实现\n\n### 等待队列管理\n- 所有等待任务通过 `list_add_tail()` 按 FIFO 顺序加入 `q->task_list`。\n- 每个 `swait_queue` 实例通常作为局部变量在栈上分配，生命周期由调用者控制。\n\n### 唤醒机制\n- **`swake_up_locked()`**：仅唤醒队首任务，适用于“一次唤醒一个”的场景（如互斥资源）。\n- **`swake_up_all()`**：\n  - 先将整个等待链表 `splice` 到临时链表 `tmp`，避免在唤醒过程中队列被并发修改。\n  - 采用 **“唤醒一个 → 释放锁 → 重新加锁”** 的循环策略，防止在唤醒大量任务时长时间持有自旋锁，从而避免影响系统实时性。\n  - **不适用于中断上下文**（因其内部会启用中断）。\n- **`swake_up_all_locked()`**：\n  - 专为 **completion** 设计，可在硬中断上下文或关中断区域调用。\n  - 直接循环调用 `swake_up_locked()`，不释放锁，因此要求调用者确保上下文安全。\n\n### 信号处理\n- `prepare_to_swait_event()` 在加入队列前检查 `signal_pending_state()`，若存在挂起信号，则**不加入队列**并返回 `-ERESTARTSYS`，确保后续 `swake_up_one()` 不会错误唤醒一个本应被信号中断的任务。\n\n### 锁与中断控制\n- 所有对外接口（如 `swake_up_one`, `prepare_to_swait_exclusive`）均使用 `raw_spin_lock_irqsave()` / `raw_spin_unlock_irqrestore()`，保证在中断上下文和 SMP 环境下的安全性。\n- `finish_swait()` 使用 `list_empty_careful()` 避免在无锁情况下误判链表状态，仅在必要时加锁删除节点。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/swait.h>`：定义 `swait_queue_head` 和 `swait_queue` 结构及函数原型。\n  - `<linux/sched.h>`：提供 `try_to_wake_up()`, `wake_up_state()`, `set_current_state()` 等调度器接口。\n  - `<linux/list.h>`：提供链表操作宏。\n  - `<linux/spinlock.h>`：提供原始自旋锁实现。\n  - `<linux/lockdep.h>`：用于锁类调试（`lockdep_set_class_and_name`）。\n- **模块依赖**：\n  - **Completion 机制**（`kernel/completion.c`）：是 `swait` 的主要用户，依赖 `swake_up_all_locked()` 实现中断安全的批量唤醒。\n  - 其他需要轻量级等待机制的子系统（如某些驱动或底层同步原语）。\n\n## 5. 使用场景\n\n- **Completion 同步原语**：`swait` 是 completion 的底层实现基础，用于线程间“完成通知”场景。\n- **轻量级条件等待**：当不需要传统 `wait_queue` 的复杂功能（如唤醒回调、非互斥等待等）时，可使用 `swait` 减少开销。\n- **中断上下文唤醒**：通过 `swake_up_all_locked()`，允许在硬中断或关中断区域安全地唤醒等待任务（仅限 completion 使用）。\n- **性能敏感路径**：由于 `swait` 代码路径短、无动态内存分配、无复杂逻辑，适用于对延迟要求极高的内核路径。",
      "similarity": 0.5992156267166138,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/swait.c",
          "start_line": 6,
          "end_line": 111,
          "content": [
            "void __init_swait_queue_head(struct swait_queue_head *q, const char *name,",
            "\t\t\t     struct lock_class_key *key)",
            "{",
            "\traw_spin_lock_init(&q->lock);",
            "\tlockdep_set_class_and_name(&q->lock, key, name);",
            "\tINIT_LIST_HEAD(&q->task_list);",
            "}",
            "void swake_up_locked(struct swait_queue_head *q, int wake_flags)",
            "{",
            "\tstruct swait_queue *curr;",
            "",
            "\tif (list_empty(&q->task_list))",
            "\t\treturn;",
            "",
            "\tcurr = list_first_entry(&q->task_list, typeof(*curr), task_list);",
            "\ttry_to_wake_up(curr->task, TASK_NORMAL, wake_flags);",
            "\tlist_del_init(&curr->task_list);",
            "}",
            "void swake_up_all_locked(struct swait_queue_head *q)",
            "{",
            "\twhile (!list_empty(&q->task_list))",
            "\t\tswake_up_locked(q, 0);",
            "}",
            "void swake_up_one(struct swait_queue_head *q)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&q->lock, flags);",
            "\tswake_up_locked(q, 0);",
            "\traw_spin_unlock_irqrestore(&q->lock, flags);",
            "}",
            "void swake_up_all(struct swait_queue_head *q)",
            "{",
            "\tstruct swait_queue *curr;",
            "\tLIST_HEAD(tmp);",
            "",
            "\traw_spin_lock_irq(&q->lock);",
            "\tlist_splice_init(&q->task_list, &tmp);",
            "\twhile (!list_empty(&tmp)) {",
            "\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);",
            "",
            "\t\twake_up_state(curr->task, TASK_NORMAL);",
            "\t\tlist_del_init(&curr->task_list);",
            "",
            "\t\tif (list_empty(&tmp))",
            "\t\t\tbreak;",
            "",
            "\t\traw_spin_unlock_irq(&q->lock);",
            "\t\traw_spin_lock_irq(&q->lock);",
            "\t}",
            "\traw_spin_unlock_irq(&q->lock);",
            "}",
            "void __prepare_to_swait(struct swait_queue_head *q, struct swait_queue *wait)",
            "{",
            "\twait->task = current;",
            "\tif (list_empty(&wait->task_list))",
            "\t\tlist_add_tail(&wait->task_list, &q->task_list);",
            "}",
            "void prepare_to_swait_exclusive(struct swait_queue_head *q, struct swait_queue *wait, int state)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&q->lock, flags);",
            "\t__prepare_to_swait(q, wait);",
            "\tset_current_state(state);",
            "\traw_spin_unlock_irqrestore(&q->lock, flags);",
            "}",
            "long prepare_to_swait_event(struct swait_queue_head *q, struct swait_queue *wait, int state)",
            "{",
            "\tunsigned long flags;",
            "\tlong ret = 0;",
            "",
            "\traw_spin_lock_irqsave(&q->lock, flags);",
            "\tif (signal_pending_state(state, current)) {",
            "\t\t/*",
            "\t\t * See prepare_to_wait_event(). TL;DR, subsequent swake_up_one()",
            "\t\t * must not see us.",
            "\t\t */",
            "\t\tlist_del_init(&wait->task_list);",
            "\t\tret = -ERESTARTSYS;",
            "\t} else {",
            "\t\t__prepare_to_swait(q, wait);",
            "\t\tset_current_state(state);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&q->lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "void __finish_swait(struct swait_queue_head *q, struct swait_queue *wait)",
            "{",
            "\t__set_current_state(TASK_RUNNING);",
            "\tif (!list_empty(&wait->task_list))",
            "\t\tlist_del_init(&wait->task_list);",
            "}",
            "void finish_swait(struct swait_queue_head *q, struct swait_queue *wait)",
            "{",
            "\tunsigned long flags;",
            "",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tif (!list_empty_careful(&wait->task_list)) {",
            "\t\traw_spin_lock_irqsave(&q->lock, flags);",
            "\t\tlist_del_init(&wait->task_list);",
            "\t\traw_spin_unlock_irqrestore(&q->lock, flags);",
            "\t}",
            "}"
          ],
          "function_name": "__init_swait_queue_head, swake_up_locked, swake_up_all_locked, swake_up_one, swake_up_all, __prepare_to_swait, prepare_to_swait_exclusive, prepare_to_swait_event, __finish_swait, finish_swait",
          "description": "实现简单等待队列相关函数，包括初始化头结构、唤醒单个/全部等待任务、准备等待状态及完成等待操作，支持锁保护与中断安全唤醒逻辑",
          "similarity": 0.5676212310791016
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/swait.c",
          "start_line": 1,
          "end_line": 5,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * <linux/swait.h> (simple wait queues ) implementation:",
            " */",
            ""
          ],
          "function_name": null,
          "description": "此代码块为swait.h头文件的实现片段，仅包含许可证声明与注释，未提供实际功能代码，上下文不完整",
          "similarity": 0.49244987964630127
        }
      ]
    }
  ]
}