{
  "query": "prefetch",
  "timestamp": "2025-12-26 01:44:48",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/preload/bpf_preload.h",
      "md_summary": "> 自动生成时间: 2025-10-25 12:23:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\preload\\bpf_preload.h`\n\n---\n\n# bpf_preload.h 技术文档\n\n## 1. 文件概述\n\n`bpf_preload.h` 是 Linux 内核中用于支持 BPF（Berkeley Packet Filter）预加载机制的头文件。该文件定义了 BPF 预加载所需的核心数据结构和接口，允许内核模块在系统启动早期阶段注册并自动加载预定义的 BPF 程序和链接（links），从而实现无需用户空间干预的 BPF 功能初始化。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_preload_info`**  \n  表示单个 BPF 预加载项的信息：\n  - `char link_name[16]`：BPF 链接的名称（最多 15 个字符 + 1 个终止符）\n  - `struct bpf_link *link`：指向已创建的 BPF 链接对象的指针\n\n- **`struct bpf_preload_ops`**  \n  定义 BPF 预加载操作的回调接口：\n  - `int (*preload)(struct bpf_preload_info *)`：预加载回调函数，用于初始化并填充 `bpf_preload_info`\n  - `struct module *owner`：拥有该操作集的内核模块指针，用于引用计数管理\n\n### 全局变量与宏\n\n- **`extern struct bpf_preload_ops *bpf_preload_ops;`**  \n  全局指针，指向当前注册的 BPF 预加载操作集。由支持预加载的模块在初始化时设置。\n\n- **`#define BPF_PRELOAD_LINKS 2`**  \n  定义系统支持的最大预加载 BPF 链接数量（当前为 2）。\n\n## 3. 关键实现\n\n- 该头文件本身不包含具体实现逻辑，而是提供接口规范。\n- 预加载机制依赖于外部模块（如 `bpf_preload.ko`）实现 `bpf_preload_ops` 中的 `preload` 回调。\n- 在内核初始化阶段，BPF 子系统会调用 `bpf_preload_ops->preload()`，传入一个 `bpf_preload_info` 数组（大小为 `BPF_PRELOAD_LINKS`），由回调函数负责创建 BPF 程序、附加到相应 hook 点，并填充对应的 `link` 字段。\n- `link_name` 字段用于在 `/sys/fs/bpf/` 或其他调试接口中标识该预加载链接，便于用户空间识别和管理。\n- `owner` 字段确保在模块卸载时能正确释放相关资源，防止悬空指针。\n\n## 4. 依赖关系\n\n- 依赖 **BPF 核心子系统**（`kernel/bpf/`）提供的 `struct bpf_link` 定义及链接管理 API。\n- 依赖 **内核模块系统**（`include/linux/module.h`），用于模块引用计数和生命周期管理。\n- 通常由 **`bpf_preload` 内核模块**（位于 `kernel/bpf/preload/`）实现并注册 `bpf_preload_ops`。\n- 可能与 **LSM（Linux Security Module）**、**Tracing** 或 **Networking** 子系统交互，具体取决于预加载的 BPF 程序类型。\n\n## 5. 使用场景\n\n- **系统启动早期自动加载关键 BPF 程序**：例如安全策略（如 Landlock）、性能监控或网络策略，无需等待用户空间初始化。\n- **嵌入式或安全敏感环境**：在用户空间不可信或尚未启动时，通过内核内置机制确保关键 BPF 功能可用。\n- **简化部署**：将常用 BPF 程序打包进内核模块，实现“开箱即用”的 BPF 功能，避免复杂的用户空间加载逻辑。\n- **内核自检与调试**：预加载用于内核自检或调试的 BPF 程序，辅助开发和故障排查。",
      "similarity": 0.49090737104415894,
      "chunks": []
    },
    {
      "source_file": "kernel/trace/trace_event_perf.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_event_perf.c`\n\n---\n\n# `trace/trace_event_perf.c` 技术文档\n\n## 1. 文件概述\n\n`trace/trace_event_perf.c` 是 Linux 内核中连接 **ftrace 事件子系统** 与 **perf 性能监控子系统** 的关键桥梁。该文件实现了将 ftrace 定义的 tracepoint、kprobe 和 uprobe 事件作为 perf event 使用的能力，使得用户空间可以通过 `perf_event_open()` 系统调用对内核 trace 事件进行采样、计数或原始数据采集。同时，该文件负责权限控制、资源管理、生命周期维护以及安全策略实施，确保 trace 事件在 perf 上下文中的安全和高效使用。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`perf_trace_buf[PERF_NR_CONTEXTS]`**  \n  每 CPU 的预分配缓冲区数组，用于在 perf 上下文中暂存 trace 事件数据，避免动态分配开销。类型为 `perf_trace_t`（对齐的 `unsigned long` 数组），大小为 `PERF_MAX_TRACE_SIZE`。\n\n- **`total_ref_count`**  \n  全局引用计数器，跟踪当前系统中所有通过 perf 使用的 trace 事件实例总数，用于管理全局缓冲区的分配与释放。\n\n- **`trace_event_call::perf_refcount`**  \n  每个 trace 事件的 perf 引用计数，用于管理该事件在 perf 上下文中的注册状态。\n\n- **`trace_event_call::perf_events`**  \n  指向 per-CPU 的 `hlist_head` 数组，用于存储与该 trace 事件关联的所有 perf event 实例。\n\n### 主要函数\n\n- **`perf_trace_event_perm()`**  \n  执行 trace 事件在 perf 上下文中的权限检查，包括 root 权限要求、函数 trace 的特殊限制（如禁止用户态调用链和栈采样）等。\n\n- **`perf_trace_event_reg()` / `perf_trace_event_unreg()`**  \n  负责 trace 事件在 perf 中的注册与注销，包括分配 per-CPU 列表、调用事件类的注册回调、管理全局缓冲区生命周期。\n\n- **`perf_trace_event_open()` / `perf_trace_event_close()`**  \n  对应 perf event 的打开与关闭操作，调用 trace 事件类的相应回调。\n\n- **`perf_trace_init()` / `perf_trace_destroy()`**  \n  perf event 初始化与销毁的入口函数，用于标准 tracepoint 事件。\n\n- **`perf_kprobe_init()` / `perf_kprobe_destroy()`**  \n  支持通过 perf 接口动态创建和销毁 kprobe/kretprobe 事件。\n\n- **`perf_uprobe_init()` / `perf_uprobe_destroy()`**  \n  支持通过 perf 接口动态创建和销毁 uprobe/uretprobe 事件。\n\n## 3. 关键实现\n\n### 权限与安全控制\n- **函数 trace 限制**：`ftrace_event_is_function()` 标记的事件（如 `function` tracepoint）仅允许 root 用户使用，且禁止启用 `PERF_SAMPLE_CALLCHAIN`（用户态部分）和 `PERF_SAMPLE_STACK_USER`，以避免在页错误处理路径中发生嵌套页错误。\n- **原始数据访问控制**：当 perf event 请求 `PERF_SAMPLE_RAW` 时，若非 `PERF_ATTACH_TASK` 模式或事件未设置 `TRACE_EVENT_FL_CAP_ANY` 标志，则必须为 root 用户。\n- **权限检查时机**：仅在 `perf_event_open()` 路径下检查当前进程权限，子事件（`p_event->parent`）继承父事件权限。\n\n### 资源管理\n- **Per-CPU 缓冲区池**：全局 `perf_trace_buf` 数组在首次有 perf trace 事件注册时分配，所有事件共享，按上下文（`PERF_NR_CONTEXTS`）区分，避免频繁分配。\n- **引用计数机制**：\n  - `total_ref_count` 控制全局缓冲区的生命周期。\n  - 每个 `trace_event_call` 的 `perf_refcount` 控制其 per-CPU 事件列表和底层 tracepoint 注册状态。\n- **同步注销**：`perf_trace_event_unreg()` 调用 `tracepoint_synchronize_unregister()` 确保所有 CPU 上的 tracepoint 回调执行完毕后再释放资源。\n\n### 动态探针支持\n- **Kprobe/Uprobe 集成**：通过 `create_local_trace_kprobe/uprobe()` 动态创建临时 trace 事件，绑定到 perf event 生命周期，销毁时自动清理。\n- **用户空间参数处理**：使用 `strndup_user()` 安全拷贝用户提供的函数名或文件路径，并进行长度和空值校验。\n\n### 事件注册流程\n1. **权限检查** (`perf_trace_event_perm`)\n2. **事件注册** (`perf_trace_event_reg`)：分配 per-CPU 列表，首次使用时分配全局缓冲区，调用 `TRACE_REG_PERF_REGISTER`\n3. **事件打开** (`perf_trace_event_open`)：调用 `TRACE_REG_PERF_OPEN`\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/perf_event.h>`：perf event 核心接口（通过 `trace.h` 间接包含）\n  - `\"trace.h\"`：ftrace 核心基础设施，包括 `trace_event_call`、`trace_event_class`、`ftrace_events` 列表等\n  - `\"trace_probe.h\"`：kprobe/uprobe 动态事件创建接口（`create_local_trace_kprobe/uprobe`）\n- **可选依赖**：\n  - `CONFIG_KPROBE_EVENTS`：启用 kprobe perf 支持\n  - `CONFIG_UPROBE_EVENTS`：启用 uprobe perf 支持\n- **同步原语**：\n  - `event_mutex`：保护 ftrace 事件列表的并发访问\n  - `tracepoint_synchronize_unregister()`：RCU 同步，确保 tracepoint 回调安全注销\n\n## 5. 使用场景\n\n- **用户空间 perf 工具**：`perf record -e 'tracepoint:*'` 或 `perf record -e 'kprobe:func'` 等命令通过此模块将 trace 事件转换为 perf event。\n- **动态内核探针**：应用程序通过 `perf_event_open()` 动态插入 kprobe/uprobe 监控特定函数或用户态地址，无需预定义 tracepoint。\n- **安全审计与性能分析**：结合 perf 的采样能力，对内核关键路径（如调度、内存管理）进行低开销监控，同时通过权限控制防止敏感数据泄露。\n- **eBPF 程序附加**：eBPF 程序可附加到 perf event 对应的 tracepoint/kprobe，此模块为 eBPF 提供底层事件源支持。",
      "similarity": 0.48266005516052246,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_event_perf.c",
          "start_line": 27,
          "end_line": 151,
          "content": [
            "static int perf_trace_event_perm(struct trace_event_call *tp_event,",
            "\t\t\t\t struct perf_event *p_event)",
            "{",
            "\tint ret;",
            "",
            "\tif (tp_event->perf_perm) {",
            "\t\tret = tp_event->perf_perm(tp_event, p_event);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * We checked and allowed to create parent,",
            "\t * allow children without checking.",
            "\t */",
            "\tif (p_event->parent)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * It's ok to check current process (owner) permissions in here,",
            "\t * because code below is called only via perf_event_open syscall.",
            "\t */",
            "",
            "\t/* The ftrace function trace is allowed only for root. */",
            "\tif (ftrace_event_is_function(tp_event)) {",
            "\t\tret = perf_allow_tracepoint(&p_event->attr);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "",
            "\t\tif (!is_sampling_event(p_event))",
            "\t\t\treturn 0;",
            "",
            "\t\t/*",
            "\t\t * We don't allow user space callchains for  function trace",
            "\t\t * event, due to issues with page faults while tracing page",
            "\t\t * fault handler and its overall trickiness nature.",
            "\t\t */",
            "\t\tif (!p_event->attr.exclude_callchain_user)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * Same reason to disable user stack dump as for user space",
            "\t\t * callchains above.",
            "\t\t */",
            "\t\tif (p_event->attr.sample_type & PERF_SAMPLE_STACK_USER)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* No tracing, just counting, so no obvious leak */",
            "\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))",
            "\t\treturn 0;",
            "",
            "\t/* Some events are ok to be traced by non-root users... */",
            "\tif (p_event->attach_state == PERF_ATTACH_TASK) {",
            "\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * ...otherwise raw tracepoint data can be a severe data leak,",
            "\t * only allow root to have these.",
            "\t */",
            "\tret = perf_allow_tracepoint(&p_event->attr);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn 0;",
            "}",
            "static int perf_trace_event_reg(struct trace_event_call *tp_event,",
            "\t\t\t\tstruct perf_event *p_event)",
            "{",
            "\tstruct hlist_head __percpu *list;",
            "\tint ret = -ENOMEM;",
            "\tint cpu;",
            "",
            "\tp_event->tp_event = tp_event;",
            "\tif (tp_event->perf_refcount++ > 0)",
            "\t\treturn 0;",
            "",
            "\tlist = alloc_percpu(struct hlist_head);",
            "\tif (!list)",
            "\t\tgoto fail;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tINIT_HLIST_HEAD(per_cpu_ptr(list, cpu));",
            "",
            "\ttp_event->perf_events = list;",
            "",
            "\tif (!total_ref_count) {",
            "\t\tchar __percpu *buf;",
            "\t\tint i;",
            "",
            "\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {",
            "\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);",
            "\t\t\tif (!buf)",
            "\t\t\t\tgoto fail;",
            "",
            "\t\t\tperf_trace_buf[i] = buf;",
            "\t\t}",
            "\t}",
            "",
            "\tret = tp_event->class->reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);",
            "\tif (ret)",
            "\t\tgoto fail;",
            "",
            "\ttotal_ref_count++;",
            "\treturn 0;",
            "",
            "fail:",
            "\tif (!total_ref_count) {",
            "\t\tint i;",
            "",
            "\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {",
            "\t\t\tfree_percpu(perf_trace_buf[i]);",
            "\t\t\tperf_trace_buf[i] = NULL;",
            "\t\t}",
            "\t}",
            "",
            "\tif (!--tp_event->perf_refcount) {",
            "\t\tfree_percpu(tp_event->perf_events);",
            "\t\ttp_event->perf_events = NULL;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "perf_trace_event_perm, perf_trace_event_reg",
          "description": "perf_trace_event_perm检查事件权限，限制非root用户访问敏感trace点；perf_trace_event_reg注册事件，分配per-CPU哈希表头并初始化引用计数。",
          "similarity": 0.49617379903793335
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_event_perf.c",
          "start_line": 425,
          "end_line": 524,
          "content": [
            "void perf_trace_buf_update(void *record, u16 type)",
            "{",
            "\tstruct trace_entry *entry = record;",
            "",
            "\ttracing_generic_entry_update(entry, type, tracing_gen_ctx());",
            "}",
            "static void",
            "perf_ftrace_function_call(unsigned long ip, unsigned long parent_ip,",
            "\t\t\t  struct ftrace_ops *ops,  struct ftrace_regs *fregs)",
            "{",
            "\tstruct ftrace_entry *entry;",
            "\tstruct perf_event *event;",
            "\tstruct hlist_head head;",
            "\tstruct pt_regs regs;",
            "\tint rctx;",
            "\tint bit;",
            "",
            "\tif (!rcu_is_watching())",
            "\t\treturn;",
            "",
            "\tbit = ftrace_test_recursion_trylock(ip, parent_ip);",
            "\tif (bit < 0)",
            "\t\treturn;",
            "",
            "\tif ((unsigned long)ops->private != smp_processor_id())",
            "\t\tgoto out;",
            "",
            "\tevent = container_of(ops, struct perf_event, ftrace_ops);",
            "",
            "\t/*",
            "\t * @event->hlist entry is NULL (per INIT_HLIST_NODE), and all",
            "\t * the perf code does is hlist_for_each_entry_rcu(), so we can",
            "\t * get away with simply setting the @head.first pointer in order",
            "\t * to create a singular list.",
            "\t */",
            "\thead.first = &event->hlist_entry;",
            "",
            "#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\",
            "\t\t    sizeof(u64)) - sizeof(u32))",
            "",
            "\tBUILD_BUG_ON(ENTRY_SIZE > PERF_MAX_TRACE_SIZE);",
            "",
            "\tmemset(&regs, 0, sizeof(regs));",
            "\tperf_fetch_caller_regs(&regs);",
            "",
            "\tentry = perf_trace_buf_alloc(ENTRY_SIZE, NULL, &rctx);",
            "\tif (!entry)",
            "\t\tgoto out;",
            "",
            "\tentry->ip = ip;",
            "\tentry->parent_ip = parent_ip;",
            "\tperf_trace_buf_submit(entry, ENTRY_SIZE, rctx, TRACE_FN,",
            "\t\t\t      1, &regs, &head, NULL);",
            "",
            "out:",
            "\tftrace_test_recursion_unlock(bit);",
            "#undef ENTRY_SIZE",
            "}",
            "static int perf_ftrace_function_register(struct perf_event *event)",
            "{",
            "\tstruct ftrace_ops *ops = &event->ftrace_ops;",
            "",
            "\tops->func    = perf_ftrace_function_call;",
            "\tops->private = (void *)(unsigned long)nr_cpu_ids;",
            "",
            "\treturn register_ftrace_function(ops);",
            "}",
            "static int perf_ftrace_function_unregister(struct perf_event *event)",
            "{",
            "\tstruct ftrace_ops *ops = &event->ftrace_ops;",
            "\tint ret = unregister_ftrace_function(ops);",
            "\tftrace_free_filter(ops);",
            "\treturn ret;",
            "}",
            "int perf_ftrace_event_register(struct trace_event_call *call,",
            "\t\t\t       enum trace_reg type, void *data)",
            "{",
            "\tstruct perf_event *event = data;",
            "",
            "\tswitch (type) {",
            "\tcase TRACE_REG_REGISTER:",
            "\tcase TRACE_REG_UNREGISTER:",
            "\t\tbreak;",
            "\tcase TRACE_REG_PERF_REGISTER:",
            "\tcase TRACE_REG_PERF_UNREGISTER:",
            "\t\treturn 0;",
            "\tcase TRACE_REG_PERF_OPEN:",
            "\t\treturn perf_ftrace_function_register(data);",
            "\tcase TRACE_REG_PERF_CLOSE:",
            "\t\treturn perf_ftrace_function_unregister(data);",
            "\tcase TRACE_REG_PERF_ADD:",
            "\t\tevent->ftrace_ops.private = (void *)(unsigned long)smp_processor_id();",
            "\t\treturn 1;",
            "\tcase TRACE_REG_PERF_DEL:",
            "\t\tevent->ftrace_ops.private = (void *)(unsigned long)nr_cpu_ids;",
            "\t\treturn 1;",
            "\t}",
            "",
            "\treturn -EINVAL;",
            "}"
          ],
          "function_name": "perf_trace_buf_update, perf_ftrace_function_call, perf_ftrace_function_register, perf_ftrace_function_unregister, perf_ftrace_event_register",
          "description": "perf_trace_buf_update更新跟踪条目；perf_ftrace_function_call作为函数入口点收集执行信息；perf_ftrace_function_register/unregister管理ftrace钩子注册；perf_ftrace_event_register处理不同注册类型的分发。",
          "similarity": 0.4912980794906616
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_event_perf.c",
          "start_line": 285,
          "end_line": 389,
          "content": [
            "void perf_kprobe_destroy(struct perf_event *p_event)",
            "{",
            "\tmutex_lock(&event_mutex);",
            "\tperf_trace_event_close(p_event);",
            "\tperf_trace_event_unreg(p_event);",
            "\ttrace_event_put_ref(p_event->tp_event);",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\tdestroy_local_trace_kprobe(p_event->tp_event);",
            "}",
            "int perf_uprobe_init(struct perf_event *p_event,",
            "\t\t     unsigned long ref_ctr_offset, bool is_retprobe)",
            "{",
            "\tint ret;",
            "\tchar *path = NULL;",
            "\tstruct trace_event_call *tp_event;",
            "",
            "\tif (!p_event->attr.uprobe_path)",
            "\t\treturn -EINVAL;",
            "",
            "\tpath = strndup_user(u64_to_user_ptr(p_event->attr.uprobe_path),",
            "\t\t\t    PATH_MAX);",
            "\tif (IS_ERR(path)) {",
            "\t\tret = PTR_ERR(path);",
            "\t\treturn (ret == -EINVAL) ? -E2BIG : ret;",
            "\t}",
            "\tif (path[0] == '\\0') {",
            "\t\tret = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\ttp_event = create_local_trace_uprobe(path, p_event->attr.probe_offset,",
            "\t\t\t\t\t     ref_ctr_offset, is_retprobe);",
            "\tif (IS_ERR(tp_event)) {",
            "\t\tret = PTR_ERR(tp_event);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * local trace_uprobe need to hold event_mutex to call",
            "\t * uprobe_buffer_enable() and uprobe_buffer_disable().",
            "\t * event_mutex is not required for local trace_kprobes.",
            "\t */",
            "\tmutex_lock(&event_mutex);",
            "\tret = perf_trace_event_init(tp_event, p_event);",
            "\tif (ret)",
            "\t\tdestroy_local_trace_uprobe(tp_event);",
            "\tmutex_unlock(&event_mutex);",
            "out:",
            "\tkfree(path);",
            "\treturn ret;",
            "}",
            "void perf_uprobe_destroy(struct perf_event *p_event)",
            "{",
            "\tmutex_lock(&event_mutex);",
            "\tperf_trace_event_close(p_event);",
            "\tperf_trace_event_unreg(p_event);",
            "\ttrace_event_put_ref(p_event->tp_event);",
            "\tmutex_unlock(&event_mutex);",
            "\tdestroy_local_trace_uprobe(p_event->tp_event);",
            "}",
            "int perf_trace_add(struct perf_event *p_event, int flags)",
            "{",
            "\tstruct trace_event_call *tp_event = p_event->tp_event;",
            "\tstruct hw_perf_event *hwc = &p_event->hw;",
            "",
            "\tif (!(flags & PERF_EF_START))",
            "\t\tp_event->hw.state = PERF_HES_STOPPED;",
            "",
            "\tif (is_sampling_event(p_event)) {",
            "\t\thwc->last_period = hwc->sample_period;",
            "\t\tperf_swevent_set_period(p_event);",
            "\t}",
            "",
            "\t/*",
            "\t * If TRACE_REG_PERF_ADD returns false; no custom action was performed",
            "\t * and we need to take the default action of enqueueing our event on",
            "\t * the right per-cpu hlist.",
            "\t */",
            "\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_ADD, p_event)) {",
            "\t\tstruct hlist_head __percpu *pcpu_list;",
            "\t\tstruct hlist_head *list;",
            "",
            "\t\tpcpu_list = tp_event->perf_events;",
            "\t\tif (WARN_ON_ONCE(!pcpu_list))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tlist = this_cpu_ptr(pcpu_list);",
            "\t\thlist_add_head_rcu(&p_event->hlist_entry, list);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void perf_trace_del(struct perf_event *p_event, int flags)",
            "{",
            "\tstruct trace_event_call *tp_event = p_event->tp_event;",
            "",
            "\t/*",
            "\t * If TRACE_REG_PERF_DEL returns false; no custom action was performed",
            "\t * and we need to take the default action of dequeueing our event from",
            "\t * the right per-cpu hlist.",
            "\t */",
            "\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_DEL, p_event))",
            "\t\thlist_del_rcu(&p_event->hlist_entry);",
            "}"
          ],
          "function_name": "perf_kprobe_destroy, perf_uprobe_init, perf_uprobe_destroy, perf_trace_add, perf_trace_del",
          "description": "perf_kprobe_destroy清理kprobe跟踪；perf_uprobe_init创建uprobe跟踪；perf_trace_add/del管理事件在CPU哈希表中的加入/移除。",
          "similarity": 0.45423388481140137
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_event_perf.c",
          "start_line": 154,
          "end_line": 276,
          "content": [
            "static void perf_trace_event_unreg(struct perf_event *p_event)",
            "{",
            "\tstruct trace_event_call *tp_event = p_event->tp_event;",
            "\tint i;",
            "",
            "\tif (--tp_event->perf_refcount > 0)",
            "\t\treturn;",
            "",
            "\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);",
            "",
            "\t/*",
            "\t * Ensure our callback won't be called anymore. The buffers",
            "\t * will be freed after that.",
            "\t */",
            "\ttracepoint_synchronize_unregister();",
            "",
            "\tfree_percpu(tp_event->perf_events);",
            "\ttp_event->perf_events = NULL;",
            "",
            "\tif (!--total_ref_count) {",
            "\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {",
            "\t\t\tfree_percpu(perf_trace_buf[i]);",
            "\t\t\tperf_trace_buf[i] = NULL;",
            "\t\t}",
            "\t}",
            "}",
            "static int perf_trace_event_open(struct perf_event *p_event)",
            "{",
            "\tstruct trace_event_call *tp_event = p_event->tp_event;",
            "\treturn tp_event->class->reg(tp_event, TRACE_REG_PERF_OPEN, p_event);",
            "}",
            "static void perf_trace_event_close(struct perf_event *p_event)",
            "{",
            "\tstruct trace_event_call *tp_event = p_event->tp_event;",
            "\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);",
            "}",
            "static int perf_trace_event_init(struct trace_event_call *tp_event,",
            "\t\t\t\t struct perf_event *p_event)",
            "{",
            "\tint ret;",
            "",
            "\tret = perf_trace_event_perm(tp_event, p_event);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = perf_trace_event_reg(tp_event, p_event);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = perf_trace_event_open(p_event);",
            "\tif (ret) {",
            "\t\tperf_trace_event_unreg(p_event);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int perf_trace_init(struct perf_event *p_event)",
            "{",
            "\tstruct trace_event_call *tp_event;",
            "\tu64 event_id = p_event->attr.config;",
            "\tint ret = -EINVAL;",
            "",
            "\tmutex_lock(&event_mutex);",
            "\tlist_for_each_entry(tp_event, &ftrace_events, list) {",
            "\t\tif (tp_event->event.type == event_id &&",
            "\t\t    tp_event->class && tp_event->class->reg &&",
            "\t\t    trace_event_try_get_ref(tp_event)) {",
            "\t\t\tret = perf_trace_event_init(tp_event, p_event);",
            "\t\t\tif (ret)",
            "\t\t\t\ttrace_event_put_ref(tp_event);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn ret;",
            "}",
            "void perf_trace_destroy(struct perf_event *p_event)",
            "{",
            "\tmutex_lock(&event_mutex);",
            "\tperf_trace_event_close(p_event);",
            "\tperf_trace_event_unreg(p_event);",
            "\ttrace_event_put_ref(p_event->tp_event);",
            "\tmutex_unlock(&event_mutex);",
            "}",
            "int perf_kprobe_init(struct perf_event *p_event, bool is_retprobe)",
            "{",
            "\tint ret;",
            "\tchar *func = NULL;",
            "\tstruct trace_event_call *tp_event;",
            "",
            "\tif (p_event->attr.kprobe_func) {",
            "\t\tfunc = strndup_user(u64_to_user_ptr(p_event->attr.kprobe_func),",
            "\t\t\t\t    KSYM_NAME_LEN);",
            "\t\tif (IS_ERR(func)) {",
            "\t\t\tret = PTR_ERR(func);",
            "\t\t\treturn (ret == -EINVAL) ? -E2BIG : ret;",
            "\t\t}",
            "",
            "\t\tif (func[0] == '\\0') {",
            "\t\t\tkfree(func);",
            "\t\t\tfunc = NULL;",
            "\t\t}",
            "\t}",
            "",
            "\ttp_event = create_local_trace_kprobe(",
            "\t\tfunc, (void *)(unsigned long)(p_event->attr.kprobe_addr),",
            "\t\tp_event->attr.probe_offset, is_retprobe);",
            "\tif (IS_ERR(tp_event)) {",
            "\t\tret = PTR_ERR(tp_event);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmutex_lock(&event_mutex);",
            "\tret = perf_trace_event_init(tp_event, p_event);",
            "\tif (ret)",
            "\t\tdestroy_local_trace_kprobe(tp_event);",
            "\tmutex_unlock(&event_mutex);",
            "out:",
            "\tkfree(func);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "perf_trace_event_unreg, perf_trace_event_open, perf_trace_event_close, perf_trace_event_init, perf_trace_init, perf_trace_destroy, perf_kprobe_init",
          "description": "perf_trace_event_unreg卸载事件并释放资源；perf_trace_event_open/close调用注册接口；perf_trace_init查找匹配事件类型并初始化；perf_kprobe_init创建本地kprobe跟踪事件。",
          "similarity": 0.4473569393157959
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_event_perf.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace event based perf event profiling/tracing",
            " *",
            " * Copyright (C) 2009 Red Hat Inc, Peter Zijlstra",
            " * Copyright (C) 2009-2010 Frederic Weisbecker <fweisbec@gmail.com>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "",
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "",
            "/*",
            " * Force it to be aligned to unsigned long to avoid misaligned accesses",
            " * surprises",
            " */",
            "typedef typeof(unsigned long [PERF_MAX_TRACE_SIZE / sizeof(unsigned long)])",
            "\tperf_trace_t;",
            "",
            "/* Count the events in use (per event id, not per instance) */",
            "static int\ttotal_ref_count;",
            ""
          ],
          "function_name": null,
          "description": "定义perf_trace_buf数组用于存储Perf事件的缓冲区，total_ref_count记录全局事件引用计数，perf_trace_t类型通过align到unsigned long防止对齐问题。",
          "similarity": 0.43931126594543457
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_events_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:18:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_events_filter.c`\n\n---\n\n# trace_events_filter.c 技术文档\n\n## 1. 文件概述\n\n`trace_events_filter.c` 是 Linux 内核中用于实现通用事件过滤（event filtering）功能的核心文件。它为 ftrace 事件跟踪系统提供了一套灵活的表达式解析和执行机制，允许用户通过逻辑表达式（支持 `&&`、`||`、`!` 等操作符）对跟踪事件进行动态过滤。该模块支持对事件字段进行数值比较、字符串匹配、位运算以及 CPU 掩码过滤等多种操作，广泛应用于性能分析、调试和系统监控场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct filter_pred`**  \n  表示一个过滤谓词（predicate），包含：\n  - 字段指针（`field`）\n  - 比较值（`val`, `val2`）\n  - 操作符（`op`，如 `==`, `<`, `&` 等）\n  - 谓词执行函数类型（`fn_num`）\n  - 正则表达式（`regex`）或 CPU 掩码（`mask`）\n  - 取反标志（`not`）\n\n- **`struct prog_entry`**  \n  表示过滤程序中的一个指令条目，用于构建基于跳转的执行逻辑：\n  - `pred`：关联的谓词\n  - `when_to_branch`：分支条件（0 或 1）\n  - `target`：跳转目标索引\n\n- **`struct filter_parse_error`**  \n  用于记录表达式解析过程中的错误类型和位置。\n\n- **`enum filter_op_ids` 和 `enum filter_pred_fn`**  \n  定义支持的操作符（如 `OP_EQ`, `OP_GT`）和谓词执行函数类型（如 `FILTER_PRED_FN_U64`, `FILTER_PRED_FN_STRING`）。\n\n- **错误码枚举（`FILT_ERR_*`）**  \n  定义了 20 余种解析和语义错误，如 `FIELD_NOT_FOUND`、`INVALID_OP`、`MISSING_QUOTE` 等。\n\n### 关键函数/逻辑\n\n- **`is_not()`**  \n  判断 `!` 是否表示逻辑取反（排除 `!=` 和 `!~` 的情况）。\n\n- **`update_preds()`**  \n  在构建过滤程序时动态更新跳转目标，用于处理 `&&` 和 `||` 的优先级和短路求值。\n\n- **`free_predicate()`**  \n  释放谓词结构及其关联资源（正则、CPU 掩码等）。\n\n- **表达式解析器框架**  \n  支持回调函数 `parse_pred_fn`，允许不同事件类型自定义谓词解析逻辑。\n\n## 3. 关键实现\n\n### 表达式解析与程序生成\n\n该文件实现了一个两阶段的逻辑表达式处理机制：\n\n1. **词法与语法解析**：将用户输入的字符串（如 `\"pid > 100 && comm == 'bash'\"`）解析为操作符、字段名和值的序列。\n2. **程序生成**：将逻辑表达式转换为线性“程序”（`prog_entry` 数组），通过条件跳转模拟 `&&`（短路与）和 `||`（短路或）的语义。\n\n例如，表达式 `a && !b || c` 被编译为类似以下的跳转逻辑：\n```text\neval a; if false goto L2\neval b; if true  goto L2\nreturn true\nL2: eval c; if false goto FAIL\nreturn true\nFAIL: return false\n```\n\n### 操作符优先级处理\n\n通过宏 `OPS` 定义操作符顺序，特别要求 `<=` 在 `<` 之前、`>=` 在 `>` 之前，以确保词法分析时长操作符优先匹配。\n\n### 取反逻辑（`!`）处理\n\n使用栈和 `invert` 标志跟踪当前作用域内的取反层数。每遇到一个 `!` 就翻转 `invert`，括号会将当前 `invert` 值压栈，确保作用域隔离。\n\n### 多类型谓词支持\n\n通过 `filter_pred_fn` 枚举区分不同数据类型的比较函数（如 8/16/32/64 位有无符号整数、字符串、CPU 掩码、函数指针等），实现类型安全的字段比较。\n\n### 错误报告机制\n\n提供详细的错误码和位置信息（`filter_parse_error`），便于用户调试无效过滤表达式。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `trace.h` / `trace_output.h`：ftrace 核心接口和事件定义\n  - `linux/slab.h`：内存分配（`kmalloc`/`kfree`）\n  - `linux/ctype.h`：字符处理\n  - `linux/perf_event.h`：与 perf 事件子系统集成\n  - `linux/uaccess.h`：用户空间数据访问\n\n- **模块依赖**：\n  - 依赖 ftrace 事件注册机制（`ftrace_event_field`）\n  - 与 `trace_events.c` 协同工作，提供过滤能力\n  - 被 perf 和 ftrace 用户接口（如 `/sys/kernel/debug/tracing/events/.../filter`）调用\n\n## 5. 使用场景\n\n- **动态事件过滤**：用户通过写入 `/sys/kernel/debug/tracing/events/<subsys>/<event>/filter` 设置过滤条件，仅记录满足条件的事件。\n- **全局过滤**：通过 `set_event_filter` 设置跨多个事件的统一过滤规则。\n- **性能分析**：在高负载系统中减少无关事件的记录开销，提升跟踪效率。\n- **调试特定行为**：例如 `filter='pid == 1234'` 仅跟踪指定进程的事件，或 `filter='latency > 1000'` 捕获高延迟操作。\n- **安全与审计**：结合字段值过滤实现细粒度的系统行为监控。",
      "similarity": 0.4818642735481262,
      "chunks": [
        {
          "chunk_id": 11,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2543,
          "end_line": 2647,
          "content": [
            "static int ftrace_function_set_filter_pred(struct filter_pred *pred,",
            "\t\t\t\t\t   struct function_filter_data *data)",
            "{",
            "\tint ret;",
            "",
            "\t/* Checking the node is valid for function trace. */",
            "\tret = ftrace_function_check_pred(pred);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn __ftrace_function_set_filter(pred->op == OP_EQ,",
            "\t\t\t\t\t    pred->regex->pattern,",
            "\t\t\t\t\t    pred->regex->len,",
            "\t\t\t\t\t    data);",
            "}",
            "static bool is_or(struct prog_entry *prog, int i)",
            "{",
            "\tint target;",
            "",
            "\t/*",
            "\t * Only \"||\" is allowed for function events, thus,",
            "\t * all true branches should jump to true, and any",
            "\t * false branch should jump to false.",
            "\t */",
            "\ttarget = prog[i].target + 1;",
            "\t/* True and false have NULL preds (all prog entries should jump to one */",
            "\tif (prog[target].pred)",
            "\t\treturn false;",
            "",
            "\t/* prog[target].target is 1 for TRUE, 0 for FALSE */",
            "\treturn prog[i].when_to_branch == prog[target].target;",
            "}",
            "static int ftrace_function_set_filter(struct perf_event *event,",
            "\t\t\t\t      struct event_filter *filter)",
            "{",
            "\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,",
            "\t\t\t\t\t\tlockdep_is_held(&event_mutex));",
            "\tstruct function_filter_data data = {",
            "\t\t.first_filter  = 1,",
            "\t\t.first_notrace = 1,",
            "\t\t.ops           = &event->ftrace_ops,",
            "\t};",
            "\tint i;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "",
            "\t\tif (!is_or(prog, i))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int ftrace_function_set_filter(struct perf_event *event,",
            "\t\t\t\t      struct event_filter *filter)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "int ftrace_profile_set_filter(struct perf_event *event, int event_id,",
            "\t\t\t      char *filter_str)",
            "{",
            "\tint err;",
            "\tstruct event_filter *filter = NULL;",
            "\tstruct trace_event_call *call;",
            "",
            "\tmutex_lock(&event_mutex);",
            "",
            "\tcall = event->tp_event;",
            "",
            "\terr = -EINVAL;",
            "\tif (!call)",
            "\t\tgoto out_unlock;",
            "",
            "\terr = -EEXIST;",
            "\tif (event->filter)",
            "\t\tgoto out_unlock;",
            "",
            "\terr = create_filter(NULL, call, filter_str, false, &filter);",
            "\tif (err)",
            "\t\tgoto free_filter;",
            "",
            "\tif (ftrace_event_is_function(call))",
            "\t\terr = ftrace_function_set_filter(event, filter);",
            "\telse",
            "\t\tevent->filter = filter;",
            "",
            "free_filter:",
            "\tif (err || ftrace_event_is_function(call))",
            "\t\t__free_filter(filter);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn err;",
            "}",
            "static int test_pred_visited_fn(struct filter_pred *pred, void *event)",
            "{",
            "\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\ttest_pred_visited = 1;",
            "\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);",
            "\treturn 1;",
            "}"
          ],
          "function_name": "ftrace_function_set_filter_pred, is_or, ftrace_function_set_filter, ftrace_function_set_filter, ftrace_profile_set_filter, test_pred_visited_fn",
          "description": "ftrace_function_set_filter_pred 将谓词转换为正则表达式并调用底层设置函数；is_or 检查程序流图中节点是否为OR逻辑分支；ftrace_function_set_filter 遍历过滤器谓词链表，校验逻辑结构后应用到函数跟踪；ftrace_profile_set_filter 创建事件过滤器并根据事件类型选择设置方式；test_pred_visited_fn 标记谓词访问状态用于测试",
          "similarity": 0.5016204714775085
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2400,
          "end_line": 2508,
          "content": [
            "int apply_subsystem_event_filter(struct trace_subsystem_dir *dir,",
            "\t\t\t\t char *filter_string)",
            "{",
            "\tstruct event_subsystem *system = dir->subsystem;",
            "\tstruct trace_array *tr = dir->tr;",
            "\tstruct event_filter *filter = NULL;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&event_mutex);",
            "",
            "\t/* Make sure the system still has events */",
            "\tif (!dir->nr_events) {",
            "\t\terr = -ENODEV;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (!strcmp(strstrip(filter_string), \"0\")) {",
            "\t\tfilter_free_subsystem_preds(dir, tr);",
            "\t\tremove_filter_string(system->filter);",
            "\t\tfilter = system->filter;",
            "\t\tsystem->filter = NULL;",
            "\t\t/* Ensure all filters are no longer used */",
            "\t\ttracepoint_synchronize_unregister();",
            "\t\tfilter_free_subsystem_filters(dir, tr);",
            "\t\t__free_filter(filter);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\terr = create_system_filter(dir, filter_string, &filter);",
            "\tif (filter) {",
            "\t\t/*",
            "\t\t * No event actually uses the system filter",
            "\t\t * we can free it without synchronize_rcu().",
            "\t\t */",
            "\t\t__free_filter(system->filter);",
            "\t\tsystem->filter = filter;",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn err;",
            "}",
            "void ftrace_profile_free_filter(struct perf_event *event)",
            "{",
            "\tstruct event_filter *filter = event->filter;",
            "",
            "\tevent->filter = NULL;",
            "\t__free_filter(filter);",
            "}",
            "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,",
            "\t\t\t\t      int reset, char *re, int len)",
            "{",
            "\tint ret;",
            "",
            "\tif (filter)",
            "\t\tret = ftrace_set_filter(ops, re, len, reset);",
            "\telse",
            "\t\tret = ftrace_set_notrace(ops, re, len, reset);",
            "",
            "\treturn ret;",
            "}",
            "static int __ftrace_function_set_filter(int filter, char *buf, int len,",
            "\t\t\t\t\tstruct function_filter_data *data)",
            "{",
            "\tint i, re_cnt, ret = -EINVAL;",
            "\tint *reset;",
            "\tchar **re;",
            "",
            "\treset = filter ? &data->first_filter : &data->first_notrace;",
            "",
            "\t/*",
            "\t * The 'ip' field could have multiple filters set, separated",
            "\t * either by space or comma. We first cut the filter and apply",
            "\t * all pieces separately.",
            "\t */",
            "\tre = ftrace_function_filter_re(buf, len, &re_cnt);",
            "\tif (!re)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < re_cnt; i++) {",
            "\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,",
            "\t\t\t\t\t\t re[i], strlen(re[i]));",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "",
            "\t\tif (*reset)",
            "\t\t\t*reset = 0;",
            "\t}",
            "",
            "\targv_free(re);",
            "\treturn ret;",
            "}",
            "static int ftrace_function_check_pred(struct filter_pred *pred)",
            "{",
            "\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\t/*",
            "\t * Check the predicate for function trace, verify:",
            "\t *  - only '==' and '!=' is used",
            "\t *  - the 'ip' field is used",
            "\t */",
            "\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (strcmp(field->name, \"ip\"))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "apply_subsystem_event_filter, ftrace_profile_free_filter, ftrace_function_set_regexp, __ftrace_function_set_filter, ftrace_function_check_pred",
          "description": "apply_subsystem_event_filter 根据过滤字符串设置子系统级事件过滤器，处理过滤器创建、释放及错误返回；ftrace_profile_free_filter 释放perf_event的过滤器指针；__ftrace_function_set_filter 将过滤字符串分割后依次应用正则表达式到函数跟踪操作；ftrace_function_check_pred 验证谓词操作类型和字段是否符合函数跟踪要求",
          "similarity": 0.4930708110332489
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2741,
          "end_line": 2822,
          "content": [
            "static void update_pred_fn(struct event_filter *filter, char *fields)",
            "{",
            "\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,",
            "\t\t\t\t\t\tlockdep_is_held(&event_mutex));",
            "\tint i;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "\t\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\t\tWARN_ON_ONCE(pred->fn_num == FILTER_PRED_FN_NOP);",
            "",
            "\t\tif (!field) {",
            "\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!strchr(fields, *field->name))",
            "\t\t\tcontinue;",
            "",
            "\t\tpred->fn_num = FILTER_PRED_TEST_VISITED;",
            "\t}",
            "}",
            "static __init int ftrace_test_event_filter(void)",
            "{",
            "\tint i;",
            "",
            "\tprintk(KERN_INFO \"Testing ftrace filter: \");",
            "",
            "\tfor (i = 0; i < DATA_CNT; i++) {",
            "\t\tstruct event_filter *filter = NULL;",
            "\t\tstruct test_filter_data_t *d = &test_filter_data[i];",
            "\t\tint err;",
            "",
            "\t\terr = create_filter(NULL, &event_ftrace_test_filter,",
            "\t\t\t\t    d->filter, false, &filter);",
            "\t\tif (err) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed to get filter for '%s', err %d\\n\",",
            "\t\t\t       d->filter, err);",
            "\t\t\t__free_filter(filter);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Needed to dereference filter->prog */",
            "\t\tmutex_lock(&event_mutex);",
            "\t\t/*",
            "\t\t * The preemption disabling is not really needed for self",
            "\t\t * tests, but the rcu dereference will complain without it.",
            "\t\t */",
            "\t\tpreempt_disable();",
            "\t\tif (*d->not_visited)",
            "\t\t\tupdate_pred_fn(filter, d->not_visited);",
            "",
            "\t\ttest_pred_visited = 0;",
            "\t\terr = filter_match_preds(filter, &d->rec);",
            "\t\tpreempt_enable();",
            "",
            "\t\tmutex_unlock(&event_mutex);",
            "",
            "\t\t__free_filter(filter);",
            "",
            "\t\tif (test_pred_visited) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",",
            "\t\t\t       d->filter);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (err != d->match) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed to match filter '%s', expected %d\\n\",",
            "\t\t\t       d->filter, d->match);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (i == DATA_CNT)",
            "\t\tprintk(KERN_CONT \"OK\\n\");",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "update_pred_fn, ftrace_test_event_filter",
          "description": "update_pred_fn 更新谓词节点的函数号标记已访问字段；ftrace_test_event_filter 自动测试过滤器匹配逻辑，通过创建过滤器、遍历谓词节点并验证匹配结果判断测试是否通过",
          "similarity": 0.4879918098449707
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 862,
          "end_line": 968,
          "content": [
            "static int filter_pred_pchar(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_string(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_pchar_user(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_ustring(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_strloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 str_item = *(u32 *)(event + pred->offset);",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(event + str_loc);",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_strrelloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 *item = (u32 *)(event + pred->offset);",
            "\tu32 str_item = *item;",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(&item[1]) + str_loc;",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu, cmp;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\tcmp = pred->val;",
            "",
            "\tswitch (pred->op) {",
            "\tcase OP_EQ:",
            "\t\treturn cpu == cmp;",
            "\tcase OP_NE:",
            "\t\treturn cpu != cmp;",
            "\tcase OP_LT:",
            "\t\treturn cpu < cmp;",
            "\tcase OP_LE:",
            "\t\treturn cpu <= cmp;",
            "\tcase OP_GT:",
            "\t\treturn cpu > cmp;",
            "\tcase OP_GE:",
            "\t\treturn cpu >= cmp;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static int filter_pred_cpu_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu = raw_smp_processor_id();",
            "",
            "\treturn do_filter_scalar_cpumask(pred->op, cpu, pred->mask);",
            "}",
            "static int filter_pred_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tconst struct cpumask *cmp = pred->mask;",
            "",
            "\treturn do_filter_cpumask(pred->op, mask, cmp);",
            "}",
            "static int filter_pred_cpumask_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tunsigned int cpu = pred->val;",
            "",
            "\treturn do_filter_cpumask_scalar(pred->op, mask, cpu);",
            "}",
            "static int filter_pred_comm(struct filter_pred *pred, void *event)",
            "{",
            "\tint cmp;",
            "",
            "\tcmp = pred->regex->match(current->comm, pred->regex,",
            "\t\t\t\tTASK_COMM_LEN);",
            "\treturn cmp ^ pred->not;",
            "}"
          ],
          "function_name": "filter_pred_pchar, filter_pred_pchar_user, filter_pred_strloc, filter_pred_strrelloc, filter_pred_cpu, filter_pred_cpu_cpumask, filter_pred_cpumask, filter_pred_cpumask_cpu, filter_pred_comm",
          "description": "提供针对字符串、位置、进程名等特殊数据类型的过滤实现，处理指针解引用和内存地址匹配。",
          "similarity": 0.4522550106048584
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 1281,
          "end_line": 1422,
          "content": [
            "static void free_prog(struct event_filter *filter)",
            "{",
            "\tstruct prog_entry *prog;",
            "\tint i;",
            "",
            "\tprog = rcu_access_pointer(filter->prog);",
            "\tif (!prog)",
            "\t\treturn;",
            "",
            "\tfor (i = 0; prog[i].pred; i++)",
            "\t\tfree_predicate(prog[i].pred);",
            "\tkfree(prog);",
            "}",
            "static void filter_disable(struct trace_event_file *file)",
            "{",
            "\tunsigned long old_flags = file->flags;",
            "",
            "\tfile->flags &= ~EVENT_FILE_FL_FILTERED;",
            "",
            "\tif (old_flags != file->flags)",
            "\t\ttrace_buffered_event_disable();",
            "}",
            "static void __free_filter(struct event_filter *filter)",
            "{",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tfree_prog(filter);",
            "\tkfree(filter->filter_string);",
            "\tkfree(filter);",
            "}",
            "void free_event_filter(struct event_filter *filter)",
            "{",
            "\t__free_filter(filter);",
            "}",
            "static inline void __remove_filter(struct trace_event_file *file)",
            "{",
            "\tfilter_disable(file);",
            "\tremove_filter_string(file->filter);",
            "}",
            "static void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,",
            "\t\t\t\t\tstruct trace_array *tr)",
            "{",
            "\tstruct trace_event_file *file;",
            "",
            "\tlist_for_each_entry(file, &tr->events, list) {",
            "\t\tif (file->system != dir)",
            "\t\t\tcontinue;",
            "\t\t__remove_filter(file);",
            "\t}",
            "}",
            "static inline void __free_subsystem_filter(struct trace_event_file *file)",
            "{",
            "\t__free_filter(file->filter);",
            "\tfile->filter = NULL;",
            "}",
            "static void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,",
            "\t\t\t\t\t  struct trace_array *tr)",
            "{",
            "\tstruct trace_event_file *file;",
            "",
            "\tlist_for_each_entry(file, &tr->events, list) {",
            "\t\tif (file->system != dir)",
            "\t\t\tcontinue;",
            "\t\t__free_subsystem_filter(file);",
            "\t}",
            "}",
            "int filter_assign_type(const char *type)",
            "{",
            "\tif (strstr(type, \"__data_loc\")) {",
            "\t\tif (strstr(type, \"char\"))",
            "\t\t\treturn FILTER_DYN_STRING;",
            "\t\tif (strstr(type, \"cpumask_t\"))",
            "\t\t\treturn FILTER_CPUMASK;",
            "\t}",
            "",
            "\tif (strstr(type, \"__rel_loc\") && strstr(type, \"char\"))",
            "\t\treturn FILTER_RDYN_STRING;",
            "",
            "\tif (strchr(type, '[') && strstr(type, \"char\"))",
            "\t\treturn FILTER_STATIC_STRING;",
            "",
            "\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)",
            "\t\treturn FILTER_PTR_STRING;",
            "",
            "\treturn FILTER_OTHER;",
            "}",
            "static enum filter_pred_fn select_comparison_fn(enum filter_op_ids op,",
            "\t\t\t\t\t\tint field_size, int field_is_signed)",
            "{",
            "\tenum filter_pred_fn fn = FILTER_PRED_FN_NOP;",
            "\tint pred_func_index = -1;",
            "",
            "\tswitch (op) {",
            "\tcase OP_EQ:",
            "\tcase OP_NE:",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))",
            "\t\t\treturn fn;",
            "\t\tpred_func_index = op - PRED_FUNC_START;",
            "\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))",
            "\t\t\treturn fn;",
            "\t}",
            "",
            "\tswitch (field_size) {",
            "\tcase 8:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_64;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S64;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U64;",
            "\t\tbreak;",
            "\tcase 4:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_32;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S32;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U32;",
            "\t\tbreak;",
            "\tcase 2:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_16;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S16;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U16;",
            "\t\tbreak;",
            "\tcase 1:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_8;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S8;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U8;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn fn;",
            "}"
          ],
          "function_name": "free_prog, filter_disable, __free_filter, free_event_filter, __remove_filter, filter_free_subsystem_preds, __free_subsystem_filter, filter_free_subsystem_filters, filter_assign_type, select_comparison_fn",
          "description": "实现事件过滤器资源释放逻辑，包括释放predicate、过滤字符串和过滤器结构体，处理子系统过滤器的遍历和销毁，定义字段类型判断函数及比较函数选择逻辑",
          "similarity": 0.43156060576438904
        }
      ]
    }
  ]
}