{
  "query": "CFS调度器时间片分配机制",
  "timestamp": "2025-12-25 23:24:01",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/fair.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:09:04\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\fair.c`\n\n---\n\n# `sched/fair.c` 技术文档\n\n## 1. 文件概述\n\n`sched/fair.c` 是 Linux 内核中 **完全公平调度器**（Completely Fair Scheduler, CFS）的核心实现文件，负责实现 `SCHED_NORMAL` 和 `SCHED_BATCH` 调度策略。CFS 旨在通过红黑树（RB-tree）维护可运行任务的虚拟运行时间（vruntime），以实现 CPU 时间的公平分配。该文件实现了任务调度、负载跟踪、时间片计算、组调度（group scheduling）、NUMA 负载均衡、带宽控制等关键机制，是 Linux 通用调度子系统的核心组成部分。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct sched_entity`：调度实体，代表一个可调度单元（任务或任务组）\n- `struct cfs_rq`：CFS 运行队列，管理一组调度实体\n- `struct load_weight`：负载权重结构，用于计算任务对系统负载的贡献\n\n### 关键函数与宏\n- `__calc_delta()` / `calc_delta_fair()`：计算基于权重的调度时间增量\n- `update_load_add()` / `update_load_sub()` / `update_load_set()`：更新负载权重\n- `__update_inv_weight()`：预计算权重的倒数以优化除法运算\n- `get_update_sysctl_factor()`：根据在线 CPU 数量动态调整调度参数\n- `update_sysctl()` / `sched_init_granularity()`：初始化和更新调度粒度参数\n- `for_each_sched_entity()`：遍历调度实体层级结构（用于组调度）\n\n### 可调参数（sysctl）\n- `sysctl_sched_base_slice`：基础时间片（默认 700,000 纳秒）\n- `sysctl_sched_tunable_scaling`：调度参数缩放策略（NONE/LOG/LINEAR）\n- `sysctl_sched_migration_cost`：任务迁移成本阈值（500 微秒）\n- `sysctl_sched_cfs_bandwidth_slice_us`（CFS 带宽控制切片，默认 5 毫秒）\n- `sysctl_numa_balancing_promote_rate_limit_MBps`（NUMA 页迁移速率限制）\n\n## 3. 关键实现\n\n### 虚拟时间与公平性\nCFS 使用 **虚拟运行时间**（vruntime）衡量任务已使用的 CPU 时间，并通过 `calc_delta_fair()` 将实际执行时间按任务权重归一化。权重由任务的 nice 值决定（`NICE_0_LOAD = 1024` 为基准）。调度器总是选择 vruntime 最小的任务运行，确保高优先级（高权重）任务获得更多 CPU 时间。\n\n### 高效除法优化\n为避免频繁除法运算，CFS 预计算 `inv_weight = WMULT_CONST / weight`（`WMULT_CONST = ~0U`），将除法转换为乘法和右移操作（`mul_u64_u32_shr`）。`__calc_delta()` 通过动态调整移位位数（`shift`）保证计算精度，适用于 32/64 位架构。\n\n### 动态粒度调整\n基础时间片 `sched_base_slice` 根据在线 CPU 数量动态缩放：\n- `SCHED_TUNABLESCALING_NONE`：固定值\n- `SCHED_TUNABLESCALING_LINEAR`：线性缩放（×ncpus）\n- `SCHED_TUNABLESCALING_LOG`（默认）：对数缩放（×(1 + ilog2(ncpus))）  \n此设计确保在多核系统中保持合理的调度延迟和交互性。\n\n### 组调度支持\n通过 `for_each_sched_entity()` 宏遍历任务所属的调度实体层级（任务 → 任务组 → 父任务组），实现 CPU 带宽在任务组间的公平分配。每个 `cfs_rq` 独立维护其子实体的红黑树。\n\n### SMP 相关优化\n- **非对称 CPU 优先级**：`arch_asym_cpu_priority()` 允许架构定义 CPU 能力差异（如大小核）\n- **容量比较宏**：`fits_capacity()`（20% 容差）和 `capacity_greater()`（5% 容差）用于负载均衡决策\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n- 调度核心：`\"sched.h\"`、`\"stats.h\"`、`\"autogroup.h\"`\n- 系统服务：`<linux/sched/clock.h>`、`<linux/sched/nohz.h>`、`<linux/psi.h>`\n- 内存管理：`<linux/mem_policy.h>`、`<linux/energy_model.h>`\n- SMP 支持：`<linux/topology.h>`、`<linux/cpumask_api.h>`\n- 数据结构：`<linux/rbtree_augmented.h>`\n\n### 条件编译特性\n- `CONFIG_SMP`：多处理器调度优化\n- `CONFIG_CFS_BANDWIDTH`：CPU 带宽限制（cgroup v1/v2）\n- `CONFIG_NUMA_BALANCING`：NUMA 自动迁移\n- `CONFIG_FAIR_GROUP_SCHED`：CFS 组调度（cgroup 支持）\n\n## 5. 使用场景\n\n- **通用任务调度**：所有使用 `SCHED_NORMAL` 或 `SCHED_BATCH` 策略的用户态进程\n- **cgroup CPU 资源控制**：通过 `cpu.cfs_quota_us` 和 `cpu.cfs_period_us` 限制任务组带宽\n- **NUMA 优化**：自动迁移内存页以减少远程访问（`numa_balancing`）\n- **节能调度**：结合 `energy_model` 在满足性能前提下选择低功耗 CPU\n- **实时性保障**：通过 `cond_resched()` 在长循环中主动让出 CPU，避免内核抢占延迟过高\n- **系统调优**：管理员通过 `/proc/sys/kernel/` 下的 sysctl 参数动态调整调度行为",
      "similarity": 0.5973471999168396,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/fair.c",
          "start_line": 1,
          "end_line": 82,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Completely Fair Scheduling (CFS) Class (SCHED_NORMAL/SCHED_BATCH)",
            " *",
            " *  Copyright (C) 2007 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>",
            " *",
            " *  Interactivity improvements by Mike Galbraith",
            " *  (C) 2007 Mike Galbraith <efault@gmx.de>",
            " *",
            " *  Various enhancements by Dmitry Adamushko.",
            " *  (C) 2007 Dmitry Adamushko <dmitry.adamushko@gmail.com>",
            " *",
            " *  Group scheduling enhancements by Srivatsa Vaddagiri",
            " *  Copyright IBM Corporation, 2007",
            " *  Author: Srivatsa Vaddagiri <vatsa@linux.vnet.ibm.com>",
            " *",
            " *  Scaled math optimizations by Thomas Gleixner",
            " *  Copyright (C) 2007, Thomas Gleixner <tglx@linutronix.de>",
            " *",
            " *  Adaptive scheduling granularity, math enhancements by Peter Zijlstra",
            " *  Copyright (C) 2007 Red Hat, Inc., Peter Zijlstra",
            " */",
            "#include <linux/energy_model.h>",
            "#include <linux/mmap_lock.h>",
            "#include <linux/hugetlb_inline.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/mm_api.h>",
            "#include <linux/highmem.h>",
            "#include <linux/spinlock_api.h>",
            "#include <linux/cpumask_api.h>",
            "#include <linux/lockdep_api.h>",
            "#include <linux/softirq.h>",
            "#include <linux/refcount_api.h>",
            "#include <linux/topology.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/cond_resched.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/nohz.h>",
            "",
            "#include <linux/cpuidle.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/memory-tiers.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mutex_api.h>",
            "#include <linux/profile.h>",
            "#include <linux/psi.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/task_work.h>",
            "#include <linux/rbtree_augmented.h>",
            "",
            "#include <asm/switch_to.h>",
            "",
            "#include <linux/sched/cond_resched.h>",
            "",
            "#include \"sched.h\"",
            "#include \"stats.h\"",
            "#include \"autogroup.h\"",
            "",
            "/*",
            " * The initial- and re-scaling of tunables is configurable",
            " *",
            " * Options are:",
            " *",
            " *   SCHED_TUNABLESCALING_NONE - unscaled, always *1",
            " *   SCHED_TUNABLESCALING_LOG - scaled logarithmical, *1+ilog(ncpus)",
            " *   SCHED_TUNABLESCALING_LINEAR - scaled linear, *ncpus",
            " *",
            " * (default SCHED_TUNABLESCALING_LOG = *(1+ilog(ncpus))",
            " */",
            "unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_LOG;",
            "",
            "/*",
            " * Minimal preemption granularity for CPU-bound tasks:",
            " *",
            " * (default: 0.70 msec * (1 + ilog(ncpus)), units: nanoseconds)",
            " */",
            "unsigned int sysctl_sched_base_slice\t\t\t= 700000ULL;",
            "static unsigned int normalized_sysctl_sched_base_slice\t= 700000ULL;",
            "",
            "const_debug unsigned int sysctl_sched_migration_cost\t= 500000UL;",
            ""
          ],
          "function_name": null,
          "description": "定义CFS调度器的可调参数及默认值，用于调整调度行为，包括时间片缩放方式（线性/对数）和基础时间片大小。",
          "similarity": 0.6720643639564514
        },
        {
          "chunk_id": 40,
          "file_path": "kernel/sched/fair.c",
          "start_line": 6542,
          "end_line": 6668,
          "content": [
            "void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b, struct cfs_bandwidth *parent)",
            "{",
            "\traw_spin_lock_init(&cfs_b->lock);",
            "\tcfs_b->runtime = 0;",
            "\tcfs_b->quota = RUNTIME_INF;",
            "\tcfs_b->period = ns_to_ktime(default_cfs_period());",
            "\tcfs_b->burst = 0;",
            "\tcfs_b->hierarchical_quota = parent ? parent->hierarchical_quota : RUNTIME_INF;",
            "",
            "\tINIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);",
            "\thrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);",
            "\tcfs_b->period_timer.function = sched_cfs_period_timer;",
            "",
            "\t/* Add a random offset so that timers interleave */",
            "\thrtimer_set_expires(&cfs_b->period_timer,",
            "\t\t\t    get_random_u32_below(cfs_b->period));",
            "\thrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);",
            "\tcfs_b->slack_timer.function = sched_cfs_slack_timer;",
            "\tcfs_b->slack_started = false;",
            "}",
            "static void init_cfs_rq_runtime(struct cfs_rq *cfs_rq)",
            "{",
            "\tcfs_rq->runtime_enabled = 0;",
            "\tINIT_LIST_HEAD(&cfs_rq->throttled_list);",
            "\tINIT_LIST_HEAD(&cfs_rq->throttled_csd_list);",
            "}",
            "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)",
            "{",
            "\tlockdep_assert_held(&cfs_b->lock);",
            "",
            "\tif (cfs_b->period_active)",
            "\t\treturn;",
            "",
            "\tcfs_b->period_active = 1;",
            "\thrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);",
            "\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);",
            "}",
            "static void destroy_cfs_bandwidth(struct cfs_bandwidth *cfs_b)",
            "{",
            "\tint __maybe_unused i;",
            "",
            "\t/* init_cfs_bandwidth() was not called */",
            "\tif (!cfs_b->throttled_cfs_rq.next)",
            "\t\treturn;",
            "",
            "\thrtimer_cancel(&cfs_b->period_timer);",
            "\thrtimer_cancel(&cfs_b->slack_timer);",
            "",
            "\t/*",
            "\t * It is possible that we still have some cfs_rq's pending on a CSD",
            "\t * list, though this race is very rare. In order for this to occur, we",
            "\t * must have raced with the last task leaving the group while there",
            "\t * exist throttled cfs_rq(s), and the period_timer must have queued the",
            "\t * CSD item but the remote cpu has not yet processed it. To handle this,",
            "\t * we can simply flush all pending CSD work inline here. We're",
            "\t * guaranteed at this point that no additional cfs_rq of this group can",
            "\t * join a CSD list.",
            "\t */",
            "#ifdef CONFIG_SMP",
            "\tfor_each_possible_cpu(i) {",
            "\t\tstruct rq *rq = cpu_rq(i);",
            "\t\tunsigned long flags;",
            "",
            "\t\tif (list_empty(&rq->cfsb_csd_list))",
            "\t\t\tcontinue;",
            "",
            "\t\tlocal_irq_save(flags);",
            "\t\t__cfsb_csd_unthrottle(rq);",
            "\t\tlocal_irq_restore(flags);",
            "\t}",
            "#endif",
            "}",
            "static void __maybe_unused update_runtime_enabled(struct rq *rq)",
            "{",
            "\tstruct task_group *tg;",
            "",
            "\tlockdep_assert_rq_held(rq);",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(tg, &task_groups, list) {",
            "\t\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;",
            "\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[cpu_of(rq)];",
            "",
            "\t\traw_spin_lock(&cfs_b->lock);",
            "\t\tcfs_rq->runtime_enabled = cfs_b->quota != RUNTIME_INF;",
            "\t\traw_spin_unlock(&cfs_b->lock);",
            "\t}",
            "\trcu_read_unlock();",
            "}",
            "static void __maybe_unused unthrottle_offline_cfs_rqs(struct rq *rq)",
            "{",
            "\tstruct task_group *tg;",
            "",
            "\tlockdep_assert_rq_held(rq);",
            "",
            "\t/*",
            "\t * The rq clock has already been updated in the",
            "\t * set_rq_offline(), so we should skip updating",
            "\t * the rq clock again in unthrottle_cfs_rq().",
            "\t */",
            "\trq_clock_start_loop_update(rq);",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(tg, &task_groups, list) {",
            "\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[cpu_of(rq)];",
            "",
            "\t\tif (!cfs_rq->runtime_enabled)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * clock_task is not advancing so we just need to make sure",
            "\t\t * there's some valid quota amount",
            "\t\t */",
            "\t\tcfs_rq->runtime_remaining = 1;",
            "\t\t/*",
            "\t\t * Offline rq is schedulable till CPU is completely disabled",
            "\t\t * in take_cpu_down(), so we prevent new cfs throttling here.",
            "\t\t */",
            "\t\tcfs_rq->runtime_enabled = 0;",
            "",
            "\t\tif (cfs_rq_throttled(cfs_rq))",
            "\t\t\tunthrottle_cfs_rq(cfs_rq);",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\trq_clock_stop_loop_update(rq);",
            "}"
          ],
          "function_name": "init_cfs_bandwidth, init_cfs_rq_runtime, start_cfs_bandwidth, destroy_cfs_bandwidth, update_runtime_enabled, unthrottle_offline_cfs_rqs",
          "description": "初始化CFS带宽结构体，配置锁、周期定时器及松弛定时器，设置默认周期和配额，用于调度器的带宽控制。",
          "similarity": 0.6456141471862793
        },
        {
          "chunk_id": 41,
          "file_path": "kernel/sched/fair.c",
          "start_line": 6684,
          "end_line": 6785,
          "content": [
            "bool cfs_task_bw_constrained(struct task_struct *p)",
            "{",
            "\tstruct cfs_rq *cfs_rq = task_cfs_rq(p);",
            "",
            "\tif (!cfs_bandwidth_used())",
            "\t\treturn false;",
            "",
            "\tif (cfs_rq->runtime_enabled ||",
            "\t    tg_cfs_bandwidth(cfs_rq->tg)->hierarchical_quota != RUNTIME_INF)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static void sched_fair_update_stop_tick(struct rq *rq, struct task_struct *p)",
            "{",
            "\tint cpu = cpu_of(rq);",
            "",
            "\tif (!cfs_bandwidth_used())",
            "\t\treturn;",
            "",
            "\tif (!tick_nohz_full_cpu(cpu))",
            "\t\treturn;",
            "",
            "\tif (rq->nr_running != 1)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t *  We know there is only one task runnable and we've just picked it. The",
            "\t *  normal enqueue path will have cleared TICK_DEP_BIT_SCHED if we will",
            "\t *  be otherwise able to stop the tick. Just need to check if we are using",
            "\t *  bandwidth control.",
            "\t */",
            "\tif (cfs_task_bw_constrained(p))",
            "\t\ttick_nohz_dep_set_cpu(cpu, TICK_DEP_BIT_SCHED);",
            "}",
            "static inline bool cfs_bandwidth_used(void)",
            "{",
            "\treturn false;",
            "}",
            "static void account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec) {}",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq) { return false; }",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq) {}",
            "static inline void sync_throttle(struct task_group *tg, int cpu) {}",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq) {}",
            "static inline int cfs_rq_throttled(struct cfs_rq *cfs_rq)",
            "{",
            "\treturn 0;",
            "}",
            "static inline int throttled_hierarchy(struct cfs_rq *cfs_rq)",
            "{",
            "\treturn 0;",
            "}",
            "static inline int throttled_lb_pair(struct task_group *tg,",
            "\t\t\t\t    int src_cpu, int dest_cpu)",
            "{",
            "\treturn 0;",
            "}",
            "void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b, struct cfs_bandwidth *parent) {}",
            "static void init_cfs_rq_runtime(struct cfs_rq *cfs_rq) {}",
            "static inline void destroy_cfs_bandwidth(struct cfs_bandwidth *cfs_b) {}",
            "static inline void update_runtime_enabled(struct rq *rq) {}",
            "static inline void unthrottle_offline_cfs_rqs(struct rq *rq) {}",
            "bool cfs_task_bw_constrained(struct task_struct *p)",
            "{",
            "\treturn false;",
            "}",
            "static inline void sched_fair_update_stop_tick(struct rq *rq, struct task_struct *p) {}",
            "static void hrtick_start_fair(struct rq *rq, struct task_struct *p)",
            "{",
            "\tstruct sched_entity *se = &p->se;",
            "",
            "\tSCHED_WARN_ON(task_rq(p) != rq);",
            "",
            "\tif (rq->cfs.h_nr_running > 1) {",
            "\t\tu64 ran = se->sum_exec_runtime - se->prev_sum_exec_runtime;",
            "\t\tu64 slice = se->slice;",
            "\t\ts64 delta = slice - ran;",
            "",
            "\t\tif (delta < 0) {",
            "\t\t\tif (task_current(rq, p))",
            "\t\t\t\tresched_curr(rq);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\thrtick_start(rq, delta);",
            "\t}",
            "}",
            "static void hrtick_update(struct rq *rq)",
            "{",
            "\tstruct task_struct *curr = rq->curr;",
            "",
            "\tif (!hrtick_enabled_fair(rq) || curr->sched_class != &fair_sched_class)",
            "\t\treturn;",
            "",
            "\thrtick_start_fair(rq, curr);",
            "}",
            "static inline void",
            "hrtick_start_fair(struct rq *rq, struct task_struct *p)",
            "{",
            "}",
            "static inline void hrtick_update(struct rq *rq)",
            "{",
            "}"
          ],
          "function_name": "cfs_task_bw_constrained, sched_fair_update_stop_tick, cfs_bandwidth_used, account_cfs_rq_runtime, check_cfs_rq_runtime, check_enqueue_throttle, sync_throttle, return_cfs_rq_runtime, cfs_rq_throttled, throttled_hierarchy, throttled_lb_pair, init_cfs_bandwidth, init_cfs_rq_runtime, destroy_cfs_bandwidth, update_runtime_enabled, unthrottle_offline_cfs_rqs, cfs_task_bw_constrained, sched_fair_update_stop_tick, hrtick_start_fair, hrtick_update, hrtick_start_fair, hrtick_update",
          "description": "提供CFS带宽约束检查及相关调度器回调钩子，大部分函数为空实现或条件编译，用于调度器的Tick管理、公平调度和抢占控制。",
          "similarity": 0.6024954319000244
        },
        {
          "chunk_id": 75,
          "file_path": "kernel/sched/fair.c",
          "start_line": 13124,
          "end_line": 13234,
          "content": [
            "static void set_next_task_fair(struct rq *rq, struct task_struct *p, bool first)",
            "{",
            "\tstruct sched_entity *se = &p->se;",
            "",
            "\tfor_each_sched_entity(se) {",
            "\t\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);",
            "",
            "\t\tset_next_entity(cfs_rq, se);",
            "\t\t/* ensure bandwidth has been allocated on our new cfs_rq */",
            "\t\taccount_cfs_rq_runtime(cfs_rq, 0);",
            "\t}",
            "",
            "\t__set_next_task_fair(rq, p, first);",
            "}",
            "void init_cfs_rq(struct cfs_rq *cfs_rq)",
            "{",
            "\tcfs_rq->tasks_timeline = RB_ROOT_CACHED;",
            "\tcfs_rq->min_vruntime = (u64)(-(1LL << 20));",
            "#ifdef CONFIG_SMP",
            "\traw_spin_lock_init(&cfs_rq->removed.lock);",
            "#endif",
            "}",
            "static void task_change_group_fair(struct task_struct *p)",
            "{",
            "\t/*",
            "\t * We couldn't detach or attach a forked task which",
            "\t * hasn't been woken up by wake_up_new_task().",
            "\t */",
            "\tif (READ_ONCE(p->__state) == TASK_NEW)",
            "\t\treturn;",
            "",
            "\tdetach_task_cfs_rq(p);",
            "",
            "#ifdef CONFIG_SMP",
            "\t/* Tell se's cfs_rq has been changed -- migrated */",
            "\tp->se.avg.last_update_time = 0;",
            "#endif",
            "\tset_task_rq(p, task_cpu(p));",
            "\tattach_task_cfs_rq(p);",
            "}",
            "void free_fair_sched_group(struct task_group *tg)",
            "{",
            "\tint i;",
            "",
            "\tfor_each_possible_cpu(i) {",
            "\t\tif (tg->cfs_rq)",
            "\t\t\tkfree(tg->cfs_rq[i]);",
            "\t\tif (tg->se)",
            "\t\t\tkfree(tg->se[i]);",
            "\t}",
            "",
            "\tkfree(tg->cfs_rq);",
            "\tkfree(tg->se);",
            "}",
            "int alloc_fair_sched_group(struct task_group *tg, struct task_group *parent)",
            "{",
            "\tstruct sched_entity *se;",
            "\tstruct cfs_rq *cfs_rq;",
            "\tint i;",
            "",
            "\ttg->cfs_rq = kcalloc(nr_cpu_ids, sizeof(cfs_rq), GFP_KERNEL);",
            "\tif (!tg->cfs_rq)",
            "\t\tgoto err;",
            "\ttg->se = kcalloc(nr_cpu_ids, sizeof(se), GFP_KERNEL);",
            "\tif (!tg->se)",
            "\t\tgoto err;",
            "",
            "\ttg->shares = NICE_0_LOAD;",
            "",
            "\tinit_cfs_bandwidth(tg_cfs_bandwidth(tg), tg_cfs_bandwidth(parent));",
            "",
            "\tfor_each_possible_cpu(i) {",
            "\t\tcfs_rq = kzalloc_node(sizeof(struct cfs_rq),",
            "\t\t\t\t      GFP_KERNEL, cpu_to_node(i));",
            "\t\tif (!cfs_rq)",
            "\t\t\tgoto err;",
            "",
            "\t\tse = kzalloc_node(sizeof(struct sched_entity_stats),",
            "\t\t\t\t  GFP_KERNEL, cpu_to_node(i));",
            "\t\tif (!se)",
            "\t\t\tgoto err_free_rq;",
            "",
            "\t\tinit_cfs_rq(cfs_rq);",
            "\t\tinit_tg_cfs_entry(tg, cfs_rq, se, i, parent->se[i]);",
            "\t\tinit_entity_runnable_average(se);",
            "\t}",
            "",
            "\treturn 1;",
            "",
            "err_free_rq:",
            "\tkfree(cfs_rq);",
            "err:",
            "\treturn 0;",
            "}",
            "void online_fair_sched_group(struct task_group *tg)",
            "{",
            "\tstruct sched_entity *se;",
            "\tstruct rq_flags rf;",
            "\tstruct rq *rq;",
            "\tint i;",
            "",
            "\tfor_each_possible_cpu(i) {",
            "\t\trq = cpu_rq(i);",
            "\t\tse = tg->se[i];",
            "\t\trq_lock_irq(rq, &rf);",
            "\t\tupdate_rq_clock(rq);",
            "\t\tattach_entity_cfs_rq(se);",
            "\t\tsync_throttle(tg, i);",
            "\t\trq_unlock_irq(rq, &rf);",
            "\t}",
            "}"
          ],
          "function_name": "set_next_task_fair, init_cfs_rq, task_change_group_fair, free_fair_sched_group, alloc_fair_sched_group, online_fair_sched_group",
          "description": "该代码段实现了CFS调度器中任务组（task group）的资源分配与调度实体管理。  \n`set_next_task_fair`负责将任务插入CFS队列并更新运行时间，`init_cfs_rq`初始化CFS运行队列数据结构，`alloc_fair_sched_group`和`free_fair_sched_group`分别用于分配/释放任务组的CFS队列及调度实体资源。  \n各函数协同维护`cfs_rq`和`sched_entity`链表，支持任务迁移、带宽分配及多CPU调度场景下的动态调整。",
          "similarity": 0.5932725071907043
        },
        {
          "chunk_id": 77,
          "file_path": "kernel/sched/fair.c",
          "start_line": 13359,
          "end_line": 13474,
          "content": [
            "int sched_group_set_idle(struct task_group *tg, long idle)",
            "{",
            "\tint i;",
            "",
            "\tif (tg == &root_task_group)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (idle < 0 || idle > 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&shares_mutex);",
            "",
            "\tif (tg->idle == idle) {",
            "\t\tmutex_unlock(&shares_mutex);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ttg->idle = idle;",
            "",
            "\tfor_each_possible_cpu(i) {",
            "\t\tstruct rq *rq = cpu_rq(i);",
            "\t\tstruct sched_entity *se = tg->se[i];",
            "\t\tstruct cfs_rq *parent_cfs_rq, *grp_cfs_rq = tg->cfs_rq[i];",
            "\t\tbool was_idle = cfs_rq_is_idle(grp_cfs_rq);",
            "\t\tlong idle_task_delta;",
            "\t\tstruct rq_flags rf;",
            "",
            "\t\trq_lock_irqsave(rq, &rf);",
            "",
            "\t\tgrp_cfs_rq->idle = idle;",
            "\t\tif (WARN_ON_ONCE(was_idle == cfs_rq_is_idle(grp_cfs_rq)))",
            "\t\t\tgoto next_cpu;",
            "",
            "\t\tif (se->on_rq) {",
            "\t\t\tparent_cfs_rq = cfs_rq_of(se);",
            "\t\t\tif (cfs_rq_is_idle(grp_cfs_rq))",
            "\t\t\t\tparent_cfs_rq->idle_nr_running++;",
            "\t\t\telse",
            "\t\t\t\tparent_cfs_rq->idle_nr_running--;",
            "\t\t}",
            "",
            "\t\tidle_task_delta = grp_cfs_rq->h_nr_running -",
            "\t\t\t\t  grp_cfs_rq->idle_h_nr_running;",
            "\t\tif (!cfs_rq_is_idle(grp_cfs_rq))",
            "\t\t\tidle_task_delta *= -1;",
            "",
            "\t\tfor_each_sched_entity(se) {",
            "\t\t\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);",
            "",
            "\t\t\tif (!se->on_rq)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\tcfs_rq->idle_h_nr_running += idle_task_delta;",
            "",
            "\t\t\t/* Already accounted at parent level and above. */",
            "\t\t\tif (cfs_rq_is_idle(cfs_rq))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "",
            "next_cpu:",
            "\t\trq_unlock_irqrestore(rq, &rf);",
            "\t}",
            "",
            "\t/* Idle groups have minimum weight. */",
            "\tif (tg_is_idle(tg))",
            "\t\t__sched_group_set_shares(tg, scale_load(WEIGHT_IDLEPRIO));",
            "\telse",
            "\t\t__sched_group_set_shares(tg, NICE_0_LOAD);",
            "",
            "\tmutex_unlock(&shares_mutex);",
            "\treturn 0;",
            "}",
            "static unsigned int get_rr_interval_fair(struct rq *rq, struct task_struct *task)",
            "{",
            "\tstruct sched_entity *se = &task->se;",
            "\tunsigned int rr_interval = 0;",
            "",
            "\t/*",
            "\t * Time slice is 0 for SCHED_OTHER tasks that are on an otherwise",
            "\t * idle runqueue:",
            "\t */",
            "\tif (rq->cfs.load.weight)",
            "\t\trr_interval = NS_TO_JIFFIES(se->slice);",
            "",
            "\treturn rr_interval;",
            "}",
            "void print_cfs_stats(struct seq_file *m, int cpu)",
            "{",
            "\tstruct cfs_rq *cfs_rq, *pos;",
            "",
            "\trcu_read_lock();",
            "\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)",
            "\t\tprint_cfs_rq(m, cpu, cfs_rq);",
            "\trcu_read_unlock();",
            "}",
            "void show_numa_stats(struct task_struct *p, struct seq_file *m)",
            "{",
            "\tint node;",
            "\tunsigned long tsf = 0, tpf = 0, gsf = 0, gpf = 0;",
            "\tstruct numa_group *ng;",
            "",
            "\trcu_read_lock();",
            "\tng = rcu_dereference(p->numa_group);",
            "\tfor_each_online_node(node) {",
            "\t\tif (p->numa_faults) {",
            "\t\t\ttsf = p->numa_faults[task_faults_idx(NUMA_MEM, node, 0)];",
            "\t\t\ttpf = p->numa_faults[task_faults_idx(NUMA_MEM, node, 1)];",
            "\t\t}",
            "\t\tif (ng) {",
            "\t\t\tgsf = ng->faults[task_faults_idx(NUMA_MEM, node, 0)],",
            "\t\t\tgpf = ng->faults[task_faults_idx(NUMA_MEM, node, 1)];",
            "\t\t}",
            "\t\tprint_numa_stats(m, node, tsf, tpf, gsf, gpf);",
            "\t}",
            "\trcu_read_unlock();",
            "}"
          ],
          "function_name": "sched_group_set_idle, get_rr_interval_fair, print_cfs_stats, show_numa_stats",
          "description": "该代码段主要处理CFS调度器中的空闲状态配置、时间片计算及统计信息输出。  \n`sched_group_set_idle` 设置任务组空闲状态并同步更新相关调度实体和运行队列；`get_rr_interval_fair` 计算公平调度类任务的时间片；`print_cfs_stats` 遍历CFS运行队列以输出调度统计；`show_numa_stats` 显示任务NUMA节点的页面错误统计。  \n上下文完整，未引入额外API或机制。",
          "similarity": 0.5923823118209839
        }
      ]
    },
    {
      "source_file": "kernel/time/timer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:57:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timer.c`\n\n---\n\n# `time/timer.c` 技术文档\n\n## 1. 文件概述\n\n`time/timer.c` 是 Linux 内核中实现**内核定时器子系统**的核心文件，负责管理基于**定时器轮（timer wheel）** 的动态定时器机制。该文件提供了高效、可扩展的定时器调度框架，支持高精度超时处理、SMP（对称多处理）环境下的 per-CPU 定时器管理，以及与 NO_HZ（动态 tick）节能机制的集成。其设计目标是在保证大多数超时场景（如网络、I/O 超时）性能的同时，通过多级粒度结构避免传统定时器轮中频繁的级联（cascading）操作，从而提升系统可扩展性。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`jiffies_64`**：全局 64 位 jiffies 计数器，记录自系统启动以来的时钟滴答数，对齐缓存行以优化 SMP 访问。\n- **多级定时器轮（Timer Wheel）结构**：\n  - 由 `LVL_DEPTH` 层（通常为 8 或 9）组成，每层包含 `LVL_SIZE`（64）个桶（buckets）。\n  - 每层具有不同的时间粒度（granularity），随层级升高而增大。\n- **定时器基础（Timer Bases）**：\n  - `BASE_STD`：标准定时器基础，用于普通定时器。\n  - `BASE_DEF`：可延迟定时器基础（仅当 `CONFIG_NO_HZ_COMMON` 启用时存在），用于在 CPU 空闲时可推迟执行的定时器。\n\n### 关键宏定义\n- `LVL_CLK_SHIFT` / `LVL_CLK_DIV`：定义层级间的时间粒度缩放因子（默认为 8 倍）。\n- `LVL_GRAN(n)`：第 `n` 层的时间粒度（单位：jiffies）。\n- `LVL_START(n)`：第 `n` 层的起始偏移时间，用于计算定时器应插入的层级。\n- `WHEEL_TIMEOUT_CUTOFF` / `WHEEL_TIMEOUT_MAX`：定时器轮的最大支持超时时间（约 12 天 @ HZ=1000）。\n\n### 主要功能\n- 定时器的注册（`add_timer`）、删除（`del_timer`）和修改（`mod_timer`）。\n- 定时器到期处理（软中断上下文执行）。\n- 与 tick 管理子系统（`tick.h`）和 NO_HZ 模式协同工作。\n- 提供 `sys_sysinfo` 系统调用的底层支持。\n\n## 3. 关键实现\n\n### 多级定时器轮算法\n- **层级设计**：定时器根据其到期时间的远近被分配到不同层级。近到期定时器放入低层（高精度），远到期放入高层（低精度）。\n- **无级联机制**：与经典定时器轮不同，本实现**不进行定时器的级联迁移**。高层定时器到期时直接触发，牺牲少量精度换取显著性能提升。\n- **隐式批处理**：高层的粗粒度天然实现超时事件的批处理，减少中断和软中断开销。\n- **超时截断**：超过 `WHEEL_TIMEOUT_MAX` 的定时器会被强制设为最大支持超时值，实测表明实际使用中超时极少超过 5 天。\n\n### 粒度与范围（以 HZ=1000 为例）\n| 层级 | 偏移 | 粒度 | 范围 |\n|------|------|------|------|\n| 0 | 0 | 1 ms | 0 – 63 ms |\n| 1 | 64 | 8 ms | 64 – 511 ms |\n| ... | ... | ... | ... |\n| 8 | 512 | ~4 小时 | ~1 天 – ~12 天 |\n\n### NO_HZ 支持\n- 当启用 `CONFIG_NO_HZ_COMMON` 时，系统维护**两个独立的定时器轮**：\n  - `BASE_STD`：标准定时器，必须准时触发。\n  - `BASE_DEF`：可延迟定时器，在 CPU 进入空闲状态时可推迟执行，用于节能。\n\n### SMP 优化\n- 定时器默认绑定到注册时的 CPU，利用 per-CPU 数据结构减少锁竞争。\n- `jiffies_64` 使用 `__cacheline_aligned_in_smp` 对齐，避免 false sharing。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **时间子系统**：`<linux/time.h>`, `<linux/jiffies.h>`, `<asm/timex.h>`\n- **调度与中断**：`<linux/interrupt.h>`, `<linux/irq_work.h>`, `<linux/sched/*.h>`\n- **内存管理**：`<linux/slab.h>`, `<linux/mm.h>`\n- **系统调用**：`<linux/syscalls.h>`, `<linux/uaccess.h>`\n- **内部模块**：`\"tick-internal.h\"`（tick 管理）、`<trace/events/timer.h>`（跟踪点）\n\n### 内核子系统交互\n- **Tick 管理**：通过 `tick.h` 接口获取时钟事件，驱动定时器轮推进。\n- **软中断**：定时器到期回调在 `TIMER_SOFTIRQ` 软中断上下文中执行。\n- **POSIX 定时器**：为 `<linux/posix-timers.h>` 提供底层支持。\n- **CPU 热插拔**：通过 `cpu.h` 处理 CPU 上下线时的定时器迁移。\n- **电源管理**：与 `NO_HZ` 和 `sched/nohz.h` 协同实现动态 tick。\n\n## 5. 使用场景\n\n- **内核超时机制**：网络协议栈（TCP 重传、连接超时）、块设备 I/O 超时、文件系统缓存回收等。\n- **延迟执行任务**：通过 `mod_timer` 实现延迟工作队列（如 `delayed_work`）。\n- **系统时间维护**：为 `jiffies` 和 `get_jiffies_64()` 提供原子更新。\n- **用户空间接口**：支撑 `sysinfo` 系统调用返回 uptime、负载等信息。\n- **高精度定时需求**：短超时（<64ms @ HZ=1000）可获得毫秒级精度，满足实时性要求。\n- **低功耗系统**：在 `NO_HZ_IDLE` 或 `NO_HZ_FULL` 模式下，通过 `BASE_DEF` 减少不必要的 tick 中断。",
      "similarity": 0.5307267904281616,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/timer.c",
          "start_line": 231,
          "end_line": 333,
          "content": [
            "static void timers_update_migration(void)",
            "{",
            "\tif (sysctl_timer_migration && tick_nohz_active)",
            "\t\tstatic_branch_enable(&timers_migration_enabled);",
            "\telse",
            "\t\tstatic_branch_disable(&timers_migration_enabled);",
            "}",
            "static int timer_migration_handler(struct ctl_table *table, int write,",
            "\t\t\t    void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret;",
            "",
            "\tmutex_lock(&timer_keys_mutex);",
            "\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (!ret && write)",
            "\t\ttimers_update_migration();",
            "\tmutex_unlock(&timer_keys_mutex);",
            "\treturn ret;",
            "}",
            "static int __init timer_sysctl_init(void)",
            "{",
            "\tregister_sysctl(\"kernel\", timer_sysctl);",
            "\treturn 0;",
            "}",
            "static inline void timers_update_migration(void) { }",
            "static void timer_update_keys(struct work_struct *work)",
            "{",
            "\tmutex_lock(&timer_keys_mutex);",
            "\ttimers_update_migration();",
            "\tstatic_branch_enable(&timers_nohz_active);",
            "\tmutex_unlock(&timer_keys_mutex);",
            "}",
            "void timers_update_nohz(void)",
            "{",
            "\tschedule_work(&timer_update_work);",
            "}",
            "static inline bool is_timers_nohz_active(void)",
            "{",
            "\treturn static_branch_unlikely(&timers_nohz_active);",
            "}",
            "static inline bool is_timers_nohz_active(void) { return false; }",
            "static unsigned long round_jiffies_common(unsigned long j, int cpu,",
            "\t\tbool force_up)",
            "{",
            "\tint rem;",
            "\tunsigned long original = j;",
            "",
            "\t/*",
            "\t * We don't want all cpus firing their timers at once hitting the",
            "\t * same lock or cachelines, so we skew each extra cpu with an extra",
            "\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which",
            "\t * already did this.",
            "\t * The skew is done by adding 3*cpunr, then round, then subtract this",
            "\t * extra offset again.",
            "\t */",
            "\tj += cpu * 3;",
            "",
            "\trem = j % HZ;",
            "",
            "\t/*",
            "\t * If the target jiffie is just after a whole second (which can happen",
            "\t * due to delays of the timer irq, long irq off times etc etc) then",
            "\t * we should round down to the whole second, not up. Use 1/4th second",
            "\t * as cutoff for this rounding as an extreme upper bound for this.",
            "\t * But never round down if @force_up is set.",
            "\t */",
            "\tif (rem < HZ/4 && !force_up) /* round down */",
            "\t\tj = j - rem;",
            "\telse /* round up */",
            "\t\tj = j - rem + HZ;",
            "",
            "\t/* now that we have rounded, subtract the extra skew again */",
            "\tj -= cpu * 3;",
            "",
            "\t/*",
            "\t * Make sure j is still in the future. Otherwise return the",
            "\t * unmodified value.",
            "\t */",
            "\treturn time_is_after_jiffies(j) ? j : original;",
            "}",
            "unsigned long __round_jiffies(unsigned long j, int cpu)",
            "{",
            "\treturn round_jiffies_common(j, cpu, false);",
            "}",
            "unsigned long __round_jiffies_relative(unsigned long j, int cpu)",
            "{",
            "\tunsigned long j0 = jiffies;",
            "",
            "\t/* Use j0 because jiffies might change while we run */",
            "\treturn round_jiffies_common(j + j0, cpu, false) - j0;",
            "}",
            "unsigned long round_jiffies(unsigned long j)",
            "{",
            "\treturn round_jiffies_common(j, raw_smp_processor_id(), false);",
            "}",
            "unsigned long round_jiffies_relative(unsigned long j)",
            "{",
            "\treturn __round_jiffies_relative(j, raw_smp_processor_id());",
            "}",
            "unsigned long __round_jiffies_up(unsigned long j, int cpu)",
            "{",
            "\treturn round_jiffies_common(j, cpu, true);",
            "}"
          ],
          "function_name": "timers_update_migration, timer_migration_handler, timer_sysctl_init, timers_update_migration, timer_update_keys, timers_update_nohz, is_timers_nohz_active, is_timers_nohz_active, round_jiffies_common, __round_jiffies, __round_jiffies_relative, round_jiffies, round_jiffies_relative, __round_jiffies_up",
          "description": "提供定时器迁移策略控制、Jiffies值调整逻辑及NOHZ相关功能，包含迁移开关配置、定时器分布优化算法和基于CPU负载的超时时间调整方法。",
          "similarity": 0.5564743280410767
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/timer.c",
          "start_line": 460,
          "end_line": 560,
          "content": [
            "unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)",
            "{",
            "\tunsigned long j0 = jiffies;",
            "",
            "\t/* Use j0 because jiffies might change while we run */",
            "\treturn round_jiffies_common(j + j0, cpu, true) - j0;",
            "}",
            "unsigned long round_jiffies_up(unsigned long j)",
            "{",
            "\treturn round_jiffies_common(j, raw_smp_processor_id(), true);",
            "}",
            "unsigned long round_jiffies_up_relative(unsigned long j)",
            "{",
            "\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());",
            "}",
            "static inline unsigned int timer_get_idx(struct timer_list *timer)",
            "{",
            "\treturn (timer->flags & TIMER_ARRAYMASK) >> TIMER_ARRAYSHIFT;",
            "}",
            "static inline void timer_set_idx(struct timer_list *timer, unsigned int idx)",
            "{",
            "\ttimer->flags = (timer->flags & ~TIMER_ARRAYMASK) |",
            "\t\t\tidx << TIMER_ARRAYSHIFT;",
            "}",
            "static inline unsigned calc_index(unsigned long expires, unsigned lvl,",
            "\t\t\t\t  unsigned long *bucket_expiry)",
            "{",
            "",
            "\t/*",
            "\t * The timer wheel has to guarantee that a timer does not fire",
            "\t * early. Early expiry can happen due to:",
            "\t * - Timer is armed at the edge of a tick",
            "\t * - Truncation of the expiry time in the outer wheel levels",
            "\t *",
            "\t * Round up with level granularity to prevent this.",
            "\t */",
            "\texpires = (expires >> LVL_SHIFT(lvl)) + 1;",
            "\t*bucket_expiry = expires << LVL_SHIFT(lvl);",
            "\treturn LVL_OFFS(lvl) + (expires & LVL_MASK);",
            "}",
            "static int calc_wheel_index(unsigned long expires, unsigned long clk,",
            "\t\t\t    unsigned long *bucket_expiry)",
            "{",
            "\tunsigned long delta = expires - clk;",
            "\tunsigned int idx;",
            "",
            "\tif (delta < LVL_START(1)) {",
            "\t\tidx = calc_index(expires, 0, bucket_expiry);",
            "\t} else if (delta < LVL_START(2)) {",
            "\t\tidx = calc_index(expires, 1, bucket_expiry);",
            "\t} else if (delta < LVL_START(3)) {",
            "\t\tidx = calc_index(expires, 2, bucket_expiry);",
            "\t} else if (delta < LVL_START(4)) {",
            "\t\tidx = calc_index(expires, 3, bucket_expiry);",
            "\t} else if (delta < LVL_START(5)) {",
            "\t\tidx = calc_index(expires, 4, bucket_expiry);",
            "\t} else if (delta < LVL_START(6)) {",
            "\t\tidx = calc_index(expires, 5, bucket_expiry);",
            "\t} else if (delta < LVL_START(7)) {",
            "\t\tidx = calc_index(expires, 6, bucket_expiry);",
            "\t} else if (LVL_DEPTH > 8 && delta < LVL_START(8)) {",
            "\t\tidx = calc_index(expires, 7, bucket_expiry);",
            "\t} else if ((long) delta < 0) {",
            "\t\tidx = clk & LVL_MASK;",
            "\t\t*bucket_expiry = clk;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Force expire obscene large timeouts to expire at the",
            "\t\t * capacity limit of the wheel.",
            "\t\t */",
            "\t\tif (delta >= WHEEL_TIMEOUT_CUTOFF)",
            "\t\t\texpires = clk + WHEEL_TIMEOUT_MAX;",
            "",
            "\t\tidx = calc_index(expires, LVL_DEPTH - 1, bucket_expiry);",
            "\t}",
            "\treturn idx;",
            "}",
            "static void",
            "trigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)",
            "{",
            "\tif (!is_timers_nohz_active())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * TODO: This wants some optimizing similar to the code below, but we",
            "\t * will do that when we switch from push to pull for deferrable timers.",
            "\t */",
            "\tif (timer->flags & TIMER_DEFERRABLE) {",
            "\t\tif (tick_nohz_full_cpu(base->cpu))",
            "\t\t\twake_up_nohz_cpu(base->cpu);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * We might have to IPI the remote CPU if the base is idle and the",
            "\t * timer is not deferrable. If the other CPU is on the way to idle",
            "\t * then it can't set base->is_idle as we hold the base lock:",
            "\t */",
            "\tif (base->is_idle)",
            "\t\twake_up_nohz_cpu(base->cpu);",
            "}"
          ],
          "function_name": "__round_jiffies_up_relative, round_jiffies_up, round_jiffies_up_relative, timer_get_idx, timer_set_idx, calc_index, calc_wheel_index, trigger_dyntick_cpu",
          "description": "实现定时器层级索引计算逻辑和动态tick触发机制，通过层级间转换规则确定定时器存储位置，处理非活动CPU上的定时器唤醒需求。",
          "similarity": 0.5156289339065552
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/time/timer.c",
          "start_line": 2190,
          "end_line": 2292,
          "content": [
            "signed long __sched schedule_timeout_killable(signed long timeout)",
            "{",
            "\t__set_current_state(TASK_KILLABLE);",
            "\treturn schedule_timeout(timeout);",
            "}",
            "signed long __sched schedule_timeout_uninterruptible(signed long timeout)",
            "{",
            "\t__set_current_state(TASK_UNINTERRUPTIBLE);",
            "\treturn schedule_timeout(timeout);",
            "}",
            "signed long __sched schedule_timeout_idle(signed long timeout)",
            "{",
            "\t__set_current_state(TASK_IDLE);",
            "\treturn schedule_timeout(timeout);",
            "}",
            "static void migrate_timer_list(struct timer_base *new_base, struct hlist_head *head)",
            "{",
            "\tstruct timer_list *timer;",
            "\tint cpu = new_base->cpu;",
            "",
            "\twhile (!hlist_empty(head)) {",
            "\t\ttimer = hlist_entry(head->first, struct timer_list, entry);",
            "\t\tdetach_timer(timer, false);",
            "\t\ttimer->flags = (timer->flags & ~TIMER_BASEMASK) | cpu;",
            "\t\tinternal_add_timer(new_base, timer);",
            "\t}",
            "}",
            "int timers_prepare_cpu(unsigned int cpu)",
            "{",
            "\tstruct timer_base *base;",
            "\tint b;",
            "",
            "\tfor (b = 0; b < NR_BASES; b++) {",
            "\t\tbase = per_cpu_ptr(&timer_bases[b], cpu);",
            "\t\tbase->clk = jiffies;",
            "\t\tbase->next_expiry = base->clk + NEXT_TIMER_MAX_DELTA;",
            "\t\tbase->next_expiry_recalc = false;",
            "\t\tbase->timers_pending = false;",
            "\t\tbase->is_idle = false;",
            "\t}",
            "\treturn 0;",
            "}",
            "int timers_dead_cpu(unsigned int cpu)",
            "{",
            "\tstruct timer_base *old_base;",
            "\tstruct timer_base *new_base;",
            "\tint b, i;",
            "",
            "\tfor (b = 0; b < NR_BASES; b++) {",
            "\t\told_base = per_cpu_ptr(&timer_bases[b], cpu);",
            "\t\tnew_base = get_cpu_ptr(&timer_bases[b]);",
            "\t\t/*",
            "\t\t * The caller is globally serialized and nobody else",
            "\t\t * takes two locks at once, deadlock is not possible.",
            "\t\t */",
            "\t\traw_spin_lock_irq(&new_base->lock);",
            "\t\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);",
            "",
            "\t\t/*",
            "\t\t * The current CPUs base clock might be stale. Update it",
            "\t\t * before moving the timers over.",
            "\t\t */",
            "\t\tforward_timer_base(new_base);",
            "",
            "\t\tWARN_ON_ONCE(old_base->running_timer);",
            "\t\told_base->running_timer = NULL;",
            "",
            "\t\tfor (i = 0; i < WHEEL_SIZE; i++)",
            "\t\t\tmigrate_timer_list(new_base, old_base->vectors + i);",
            "",
            "\t\traw_spin_unlock(&old_base->lock);",
            "\t\traw_spin_unlock_irq(&new_base->lock);",
            "\t\tput_cpu_ptr(&timer_bases);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void __init init_timer_cpu(int cpu)",
            "{",
            "\tstruct timer_base *base;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < NR_BASES; i++) {",
            "\t\tbase = per_cpu_ptr(&timer_bases[i], cpu);",
            "\t\tbase->cpu = cpu;",
            "\t\traw_spin_lock_init(&base->lock);",
            "\t\tbase->clk = jiffies;",
            "\t\tbase->next_expiry = base->clk + NEXT_TIMER_MAX_DELTA;",
            "\t\ttimer_base_init_expiry_lock(base);",
            "\t}",
            "}",
            "static void __init init_timer_cpus(void)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tinit_timer_cpu(cpu);",
            "}",
            "void __init init_timers(void)",
            "{",
            "\tinit_timer_cpus();",
            "\tposix_cputimers_init_work();",
            "\topen_softirq(TIMER_SOFTIRQ, run_timer_softirq);",
            "}"
          ],
          "function_name": "schedule_timeout_killable, schedule_timeout_uninterruptible, schedule_timeout_idle, migrate_timer_list, timers_prepare_cpu, timers_dead_cpu, init_timer_cpu, init_timer_cpus, init_timers",
          "description": "该代码段实现Linux内核中的定时器管理和进程睡眠控制功能。  \n三个`schedule_timeout_*`函数通过设置任务状态（可中断/不可中断/空闲）实现进程睡眠并返回超时值；`migrate_timer_list`及`timers_prepare_cpu`/`timers_dead_cpu`系列函数负责多CPU环境下定时器列表的迁移与初始化，保障定时器在CPU热插拔时的数据一致性。  \n其余函数（`init_timer_cpu`/`init_timer_cpus`/`init_timers`）完成全局定时器基础结构的初始化，构建多核系统中定时器调度所需的底层资源。",
          "similarity": 0.49770885705947876
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/timer.c",
          "start_line": 1,
          "end_line": 230,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  Kernel internal timers",
            " *",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " *",
            " *  1997-01-28  Modified by Finn Arne Gangstad to make timers scale better.",
            " *",
            " *  1997-09-10  Updated NTP code according to technical memorandum Jan '96",
            " *              \"A Kernel Model for Precision Timekeeping\" by Dave Mills",
            " *  1998-12-24  Fixed a xtime SMP race (we need the xtime_lock rw spinlock to",
            " *              serialize accesses to xtime/lost_ticks).",
            " *                              Copyright (C) 1998  Andrea Arcangeli",
            " *  1999-03-10  Improved NTP compatibility by Ulrich Windl",
            " *  2002-05-31\tMove sys_sysinfo here and make its locking sane, Robert Love",
            " *  2000-10-05  Implemented scalable SMP per-CPU timer handling.",
            " *                              Copyright (C) 2000, 2001, 2002  Ingo Molnar",
            " *              Designed by David S. Miller, Alexey Kuznetsov and Ingo Molnar",
            " */",
            "",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/notifier.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/delay.h>",
            "#include <linux/tick.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "",
            "#include <linux/uaccess.h>",
            "#include <asm/unistd.h>",
            "#include <asm/div64.h>",
            "#include <asm/timex.h>",
            "#include <asm/io.h>",
            "",
            "#include \"tick-internal.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/timer.h>",
            "",
            "__visible u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;",
            "",
            "EXPORT_SYMBOL(jiffies_64);",
            "",
            "/*",
            " * The timer wheel has LVL_DEPTH array levels. Each level provides an array of",
            " * LVL_SIZE buckets. Each level is driven by its own clock and therefor each",
            " * level has a different granularity.",
            " *",
            " * The level granularity is:\t\tLVL_CLK_DIV ^ lvl",
            " * The level clock frequency is:\tHZ / (LVL_CLK_DIV ^ level)",
            " *",
            " * The array level of a newly armed timer depends on the relative expiry",
            " * time. The farther the expiry time is away the higher the array level and",
            " * therefor the granularity becomes.",
            " *",
            " * Contrary to the original timer wheel implementation, which aims for 'exact'",
            " * expiry of the timers, this implementation removes the need for recascading",
            " * the timers into the lower array levels. The previous 'classic' timer wheel",
            " * implementation of the kernel already violated the 'exact' expiry by adding",
            " * slack to the expiry time to provide batched expiration. The granularity",
            " * levels provide implicit batching.",
            " *",
            " * This is an optimization of the original timer wheel implementation for the",
            " * majority of the timer wheel use cases: timeouts. The vast majority of",
            " * timeout timers (networking, disk I/O ...) are canceled before expiry. If",
            " * the timeout expires it indicates that normal operation is disturbed, so it",
            " * does not matter much whether the timeout comes with a slight delay.",
            " *",
            " * The only exception to this are networking timers with a small expiry",
            " * time. They rely on the granularity. Those fit into the first wheel level,",
            " * which has HZ granularity.",
            " *",
            " * We don't have cascading anymore. timers with a expiry time above the",
            " * capacity of the last wheel level are force expired at the maximum timeout",
            " * value of the last wheel level. From data sampling we know that the maximum",
            " * value observed is 5 days (network connection tracking), so this should not",
            " * be an issue.",
            " *",
            " * The currently chosen array constants values are a good compromise between",
            " * array size and granularity.",
            " *",
            " * This results in the following granularity and range levels:",
            " *",
            " * HZ 1000 steps",
            " * Level Offset  Granularity            Range",
            " *  0      0         1 ms                0 ms -         63 ms",
            " *  1     64         8 ms               64 ms -        511 ms",
            " *  2    128        64 ms              512 ms -       4095 ms (512ms - ~4s)",
            " *  3    192       512 ms             4096 ms -      32767 ms (~4s - ~32s)",
            " *  4    256      4096 ms (~4s)      32768 ms -     262143 ms (~32s - ~4m)",
            " *  5    320     32768 ms (~32s)    262144 ms -    2097151 ms (~4m - ~34m)",
            " *  6    384    262144 ms (~4m)    2097152 ms -   16777215 ms (~34m - ~4h)",
            " *  7    448   2097152 ms (~34m)  16777216 ms -  134217727 ms (~4h - ~1d)",
            " *  8    512  16777216 ms (~4h)  134217728 ms - 1073741822 ms (~1d - ~12d)",
            " *",
            " * HZ  300",
            " * Level Offset  Granularity            Range",
            " *  0\t   0         3 ms                0 ms -        210 ms",
            " *  1\t  64        26 ms              213 ms -       1703 ms (213ms - ~1s)",
            " *  2\t 128       213 ms             1706 ms -      13650 ms (~1s - ~13s)",
            " *  3\t 192      1706 ms (~1s)      13653 ms -     109223 ms (~13s - ~1m)",
            " *  4\t 256     13653 ms (~13s)    109226 ms -     873810 ms (~1m - ~14m)",
            " *  5\t 320    109226 ms (~1m)     873813 ms -    6990503 ms (~14m - ~1h)",
            " *  6\t 384    873813 ms (~14m)   6990506 ms -   55924050 ms (~1h - ~15h)",
            " *  7\t 448   6990506 ms (~1h)   55924053 ms -  447392423 ms (~15h - ~5d)",
            " *  8    512  55924053 ms (~15h) 447392426 ms - 3579139406 ms (~5d - ~41d)",
            " *",
            " * HZ  250",
            " * Level Offset  Granularity            Range",
            " *  0\t   0         4 ms                0 ms -        255 ms",
            " *  1\t  64        32 ms              256 ms -       2047 ms (256ms - ~2s)",
            " *  2\t 128       256 ms             2048 ms -      16383 ms (~2s - ~16s)",
            " *  3\t 192      2048 ms (~2s)      16384 ms -     131071 ms (~16s - ~2m)",
            " *  4\t 256     16384 ms (~16s)    131072 ms -    1048575 ms (~2m - ~17m)",
            " *  5\t 320    131072 ms (~2m)    1048576 ms -    8388607 ms (~17m - ~2h)",
            " *  6\t 384   1048576 ms (~17m)   8388608 ms -   67108863 ms (~2h - ~18h)",
            " *  7\t 448   8388608 ms (~2h)   67108864 ms -  536870911 ms (~18h - ~6d)",
            " *  8    512  67108864 ms (~18h) 536870912 ms - 4294967288 ms (~6d - ~49d)",
            " *",
            " * HZ  100",
            " * Level Offset  Granularity            Range",
            " *  0\t   0         10 ms               0 ms -        630 ms",
            " *  1\t  64         80 ms             640 ms -       5110 ms (640ms - ~5s)",
            " *  2\t 128        640 ms            5120 ms -      40950 ms (~5s - ~40s)",
            " *  3\t 192       5120 ms (~5s)     40960 ms -     327670 ms (~40s - ~5m)",
            " *  4\t 256      40960 ms (~40s)   327680 ms -    2621430 ms (~5m - ~43m)",
            " *  5\t 320     327680 ms (~5m)   2621440 ms -   20971510 ms (~43m - ~5h)",
            " *  6\t 384    2621440 ms (~43m) 20971520 ms -  167772150 ms (~5h - ~1d)",
            " *  7\t 448   20971520 ms (~5h) 167772160 ms - 1342177270 ms (~1d - ~15d)",
            " */",
            "",
            "/* Clock divisor for the next level */",
            "#define LVL_CLK_SHIFT\t3",
            "#define LVL_CLK_DIV\t(1UL << LVL_CLK_SHIFT)",
            "#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)",
            "#define LVL_SHIFT(n)\t((n) * LVL_CLK_SHIFT)",
            "#define LVL_GRAN(n)\t(1UL << LVL_SHIFT(n))",
            "",
            "/*",
            " * The time start value for each level to select the bucket at enqueue",
            " * time. We start from the last possible delta of the previous level",
            " * so that we can later add an extra LVL_GRAN(n) to n (see calc_index()).",
            " */",
            "#define LVL_START(n)\t((LVL_SIZE - 1) << (((n) - 1) * LVL_CLK_SHIFT))",
            "",
            "/* Size of each clock level */",
            "#define LVL_BITS\t6",
            "#define LVL_SIZE\t(1UL << LVL_BITS)",
            "#define LVL_MASK\t(LVL_SIZE - 1)",
            "#define LVL_OFFS(n)\t((n) * LVL_SIZE)",
            "",
            "/* Level depth */",
            "#if HZ > 100",
            "# define LVL_DEPTH\t9",
            "# else",
            "# define LVL_DEPTH\t8",
            "#endif",
            "",
            "/* The cutoff (max. capacity of the wheel) */",
            "#define WHEEL_TIMEOUT_CUTOFF\t(LVL_START(LVL_DEPTH))",
            "#define WHEEL_TIMEOUT_MAX\t(WHEEL_TIMEOUT_CUTOFF - LVL_GRAN(LVL_DEPTH - 1))",
            "",
            "/*",
            " * The resulting wheel size. If NOHZ is configured we allocate two",
            " * wheels so we have a separate storage for the deferrable timers.",
            " */",
            "#define WHEEL_SIZE\t(LVL_SIZE * LVL_DEPTH)",
            "",
            "#ifdef CONFIG_NO_HZ_COMMON",
            "# define NR_BASES\t2",
            "# define BASE_STD\t0",
            "# define BASE_DEF\t1",
            "#else",
            "# define NR_BASES\t1",
            "# define BASE_STD\t0",
            "# define BASE_DEF\t0",
            "#endif",
            "",
            "struct timer_base {",
            "\traw_spinlock_t\t\tlock;",
            "\tstruct timer_list\t*running_timer;",
            "#ifdef CONFIG_PREEMPT_RT",
            "\tspinlock_t\t\texpiry_lock;",
            "\tatomic_t\t\ttimer_waiters;",
            "#endif",
            "\tunsigned long\t\tclk;",
            "\tunsigned long\t\tnext_expiry;",
            "\tunsigned int\t\tcpu;",
            "\tbool\t\t\tnext_expiry_recalc;",
            "\tbool\t\t\tis_idle;",
            "\tbool\t\t\ttimers_pending;",
            "\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);",
            "\tstruct hlist_head\tvectors[WHEEL_SIZE];",
            "} ____cacheline_aligned;",
            "",
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);",
            "",
            "#ifdef CONFIG_NO_HZ_COMMON",
            "",
            "static DEFINE_STATIC_KEY_FALSE(timers_nohz_active);",
            "static DEFINE_MUTEX(timer_keys_mutex);",
            "",
            "static void timer_update_keys(struct work_struct *work);",
            "static DECLARE_WORK(timer_update_work, timer_update_keys);",
            "",
            "#ifdef CONFIG_SMP",
            "static unsigned int sysctl_timer_migration = 1;",
            "",
            "DEFINE_STATIC_KEY_FALSE(timers_migration_enabled);",
            ""
          ],
          "function_name": null,
          "description": "定义并实现了内核定时器轮（timer wheel）的数据结构和宏观布局，通过多层级桶结构管理定时器，支持不同粒度的超时处理，包含对NOHZ模式的支持及动态调整机制。",
          "similarity": 0.4899442493915558
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/time/timer.c",
          "start_line": 1154,
          "end_line": 1268,
          "content": [
            "int mod_timer_pending(struct timer_list *timer, unsigned long expires)",
            "{",
            "\treturn __mod_timer(timer, expires, MOD_TIMER_PENDING_ONLY);",
            "}",
            "int mod_timer(struct timer_list *timer, unsigned long expires)",
            "{",
            "\treturn __mod_timer(timer, expires, 0);",
            "}",
            "int timer_reduce(struct timer_list *timer, unsigned long expires)",
            "{",
            "\treturn __mod_timer(timer, expires, MOD_TIMER_REDUCE);",
            "}",
            "void add_timer(struct timer_list *timer)",
            "{",
            "\tif (WARN_ON_ONCE(timer_pending(timer)))",
            "\t\treturn;",
            "\t__mod_timer(timer, timer->expires, MOD_TIMER_NOTPENDING);",
            "}",
            "void add_timer_on(struct timer_list *timer, int cpu)",
            "{",
            "\tstruct timer_base *new_base, *base;",
            "\tunsigned long flags;",
            "",
            "\tdebug_assert_init(timer);",
            "",
            "\tif (WARN_ON_ONCE(timer_pending(timer)))",
            "\t\treturn;",
            "",
            "\tnew_base = get_timer_cpu_base(timer->flags, cpu);",
            "",
            "\t/*",
            "\t * If @timer was on a different CPU, it should be migrated with the",
            "\t * old base locked to prevent other operations proceeding with the",
            "\t * wrong base locked.  See lock_timer_base().",
            "\t */",
            "\tbase = lock_timer_base(timer, &flags);",
            "\t/*",
            "\t * Has @timer been shutdown? This needs to be evaluated while",
            "\t * holding base lock to prevent a race against the shutdown code.",
            "\t */",
            "\tif (!timer->function)",
            "\t\tgoto out_unlock;",
            "",
            "\tif (base != new_base) {",
            "\t\ttimer->flags |= TIMER_MIGRATING;",
            "",
            "\t\traw_spin_unlock(&base->lock);",
            "\t\tbase = new_base;",
            "\t\traw_spin_lock(&base->lock);",
            "\t\tWRITE_ONCE(timer->flags,",
            "\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);",
            "\t}",
            "\tforward_timer_base(base);",
            "",
            "\tdebug_timer_activate(timer);",
            "\tinternal_add_timer(base, timer);",
            "out_unlock:",
            "\traw_spin_unlock_irqrestore(&base->lock, flags);",
            "}",
            "static int __timer_delete(struct timer_list *timer, bool shutdown)",
            "{",
            "\tstruct timer_base *base;",
            "\tunsigned long flags;",
            "\tint ret = 0;",
            "",
            "\tdebug_assert_init(timer);",
            "",
            "\t/*",
            "\t * If @shutdown is set then the lock has to be taken whether the",
            "\t * timer is pending or not to protect against a concurrent rearm",
            "\t * which might hit between the lockless pending check and the lock",
            "\t * aquisition. By taking the lock it is ensured that such a newly",
            "\t * enqueued timer is dequeued and cannot end up with",
            "\t * timer->function == NULL in the expiry code.",
            "\t *",
            "\t * If timer->function is currently executed, then this makes sure",
            "\t * that the callback cannot requeue the timer.",
            "\t */",
            "\tif (timer_pending(timer) || shutdown) {",
            "\t\tbase = lock_timer_base(timer, &flags);",
            "\t\tret = detach_if_pending(timer, base, true);",
            "\t\tif (shutdown)",
            "\t\t\ttimer->function = NULL;",
            "\t\traw_spin_unlock_irqrestore(&base->lock, flags);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "int timer_delete(struct timer_list *timer)",
            "{",
            "\treturn __timer_delete(timer, false);",
            "}",
            "int timer_shutdown(struct timer_list *timer)",
            "{",
            "\treturn __timer_delete(timer, true);",
            "}",
            "static int __try_to_del_timer_sync(struct timer_list *timer, bool shutdown)",
            "{",
            "\tstruct timer_base *base;",
            "\tunsigned long flags;",
            "\tint ret = -1;",
            "",
            "\tdebug_assert_init(timer);",
            "",
            "\tbase = lock_timer_base(timer, &flags);",
            "",
            "\tif (base->running_timer != timer)",
            "\t\tret = detach_if_pending(timer, base, true);",
            "\tif (shutdown)",
            "\t\ttimer->function = NULL;",
            "",
            "\traw_spin_unlock_irqrestore(&base->lock, flags);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "mod_timer_pending, mod_timer, timer_reduce, add_timer, add_timer_on, __timer_delete, timer_delete, timer_shutdown, __try_to_del_timer_sync",
          "description": "提供多个定时器控制接口函数，包括mod_timer_pending、mod_timer、timer_reduce、add_timer、add_timer_on、timer_delete、timer_shutdown及__try_to_del_timer_sync。其中add_timer_on支持跨CPU调度，timer_delete/timer_shutdown用于安全移除定时器，__try_to_del_timer_sync尝试同步删除定时器。",
          "similarity": 0.46152350306510925
        }
      ]
    },
    {
      "source_file": "kernel/time/time.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:52:34\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\time.c`\n\n---\n\n# time/time.c 技术文档\n\n## 1. 文件概述\n\n`time/time.c` 是 Linux 内核中负责实现与时间相关的系统调用的核心文件。该文件提供了用户空间程序访问和设置系统时间的接口，包括 `time`、`stime`、`gettimeofday`、`settimeofday` 和 `adjtimex` 等传统 POSIX 时间系统调用。文件同时支持 32 位和 64 位时间表示，并处理不同架构和兼容性需求，确保内核时间子系统与用户空间的正确交互。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`sys_tz`** (`struct timezone`)：全局变量，存储系统默认时区信息，供 `gettimeofday` 系统调用返回。\n\n### 主要函数\n- **`SYSCALL_DEFINE1(time, ...)`**：返回自 Unix 纪元（1970-01-01 00:00:00 UTC）以来的秒数。\n- **`SYSCALL_DEFINE1(stime, ...)`**：设置系统时间（仅秒级精度）。\n- **`SYSCALL_DEFINE2(gettimeofday, ...)`**：获取高精度系统时间（微秒级）和时区信息。\n- **`SYSCALL_DEFINE2(settimeofday, ...)`**：设置系统时间（微秒级精度）和/或时区。\n- **`do_sys_settimeofday64(...)`**：`settimeofday` 的核心实现函数，处理时间/时区验证、安全检查和时钟调整。\n- **`SYSCALL_DEFINE1(adjtimex, ...)`**：用于 NTP（网络时间协议）时间同步，调整系统时钟频率和偏移。\n- **兼容性系统调用**：\n  - `time32` / `stime32`：32 位时间值的兼容接口（用于 `CONFIG_COMPAT_32BIT_TIME`）。\n  - `COMPAT_SYSCALL_DEFINE2(gettimeofday, ...)` / `COMPAT_SYSCALL_DEFINE2(settimeofday, ...)`：32 位用户空间兼容接口。\n- **辅助函数**：\n  - `get_old_timex32(...)`：将 32 位 `old_timex32` 结构转换为内核 `__kernel_timex`。\n  - `put_old_timex32(...)`：将内核 `__kernel_timex` 结构转换回 32 位 `old_timex32`（代码截断）。\n\n## 3. 关键实现\n\n### 时间获取与设置\n- 使用 `ktime_get_real_seconds()` 和 `ktime_get_real_ts64()` 从内核时间子系统获取高精度实时时间。\n- 时间设置通过 `do_settimeofday64()` 接口完成，该函数负责更新内核时间状态并通知相关子系统。\n\n### 时区处理\n- 全局变量 `sys_tz` 存储系统时区，通过 `settimeofday` 更新。\n- 首次设置时区时（`firsttime == 1`），若未同时设置时间，则调用 `timekeeping_warp_clock()` 将 CMOS 时钟从本地时间转换为 UTC 时间，避免时间跳变对应用程序造成影响。\n\n### 安全与验证\n- 所有修改系统时间的操作均调用 `security_settime64()` 进行 LSM（Linux Security Module）安全检查。\n- 输入参数严格验证：\n  - 时间值必须通过 `timespec64_valid_settod()` 检查有效性。\n  - 时区偏移限制在 ±15 小时范围内（`tz_minuteswest ∈ [-900, 900]`）。\n  - 微秒值必须在 `[0, USEC_PER_SEC)` 范围内。\n\n### 兼容性支持\n- 通过条件编译宏（如 `__ARCH_WANT_SYS_TIME`、`CONFIG_COMPAT_32BIT_TIME`、`CONFIG_COMPAT`）支持不同架构和位宽需求。\n- 32 位时间接口（`time32`/`stime32`）用于处理 `time_t` 为 32 位的旧应用程序。\n- 兼容层系统调用处理 32 位用户空间结构体与 64 位内核结构体之间的转换。\n\n### NTP 支持\n- `adjtimex` 系统调用提供对内核 PLL（锁相环）的精细控制，用于 NTP 时间同步。\n- 支持 NTPv4 规范，允许更大的时间常数（`time_constant > 6`）。\n\n## 4. 依赖关系\n\n- **内核时间子系统**：\n  - `<linux/timekeeper_internal.h>`、`\"timekeeping.h\"`：提供 `ktime_get_real_ts64()`、`do_settimeofday64()`、`timekeeping_warp_clock()` 等核心时间操作。\n- **安全框架**：\n  - `<linux/security.h>`：提供 `security_settime64()` 安全钩子。\n- **系统调用框架**：\n  - `<linux/syscalls.h>`：定义 `SYSCALL_DEFINE` 宏。\n  - `<linux/compat.h>`：提供 32/64 位兼容系统调用支持。\n- **架构相关**：\n  - `<asm/unistd.h>`：包含系统调用号定义。\n  - `__ARCH_WANT_SYS_TIME` 等宏由具体架构定义，决定是否编译传统时间系统调用。\n- **其他**：\n  - `<linux/uaccess.h>`：提供用户空间内存访问函数（`get_user`、`put_user`、`copy_to/from_user`）。\n  - `<generated/timeconst.h>`：包含编译时生成的时间常量。\n\n## 5. 使用场景\n\n- **用户空间时间获取**：应用程序通过 `gettimeofday()` 获取高精度当前时间，用于日志记录、性能分析、定时器等。\n- **系统时间设置**：管理员或 NTP 守护进程（如 `ntpd`、`chronyd`）通过 `settimeofday()` 或 `adjtimex()` 同步系统时间。\n- **时区配置**：系统初始化脚本（如 `/etc/rc`）通过 `settimeofday()` 设置时区，确保 CMOS 时钟以 UTC 运行。\n- **遗留应用支持**：32 位时间接口支持在 64 位系统上运行的旧版应用程序（Y2038 问题兼容）。\n- **NTP 精确时间同步**：`adjtimex()` 系统调用被 NTP 守护进程用于微调系统时钟频率和相位，实现高精度时间同步。",
      "similarity": 0.5306375026702881,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/time/time.c",
          "start_line": 616,
          "end_line": 720,
          "content": [
            "unsigned long",
            "timespec64_to_jiffies(const struct timespec64 *value)",
            "{",
            "\tu64 sec = value->tv_sec;",
            "\tlong nsec = value->tv_nsec + TICK_NSEC - 1;",
            "",
            "\tif (sec >= MAX_SEC_IN_JIFFIES){",
            "\t\tsec = MAX_SEC_IN_JIFFIES;",
            "\t\tnsec = 0;",
            "\t}",
            "\treturn ((sec * SEC_CONVERSION) +",
            "\t\t(((u64)nsec * NSEC_CONVERSION) >>",
            "\t\t (NSEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;",
            "",
            "}",
            "void",
            "jiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)",
            "{",
            "\t/*",
            "\t * Convert jiffies to nanoseconds and separate with",
            "\t * one divide.",
            "\t */",
            "\tu32 rem;",
            "\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,",
            "\t\t\t\t    NSEC_PER_SEC, &rem);",
            "\tvalue->tv_nsec = rem;",
            "}",
            "clock_t jiffies_to_clock_t(unsigned long x)",
            "{",
            "#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0",
            "# if HZ < USER_HZ",
            "\treturn x * (USER_HZ / HZ);",
            "# else",
            "\treturn x / (HZ / USER_HZ);",
            "# endif",
            "#else",
            "\treturn div_u64((u64)x * TICK_NSEC, NSEC_PER_SEC / USER_HZ);",
            "#endif",
            "}",
            "unsigned long clock_t_to_jiffies(unsigned long x)",
            "{",
            "#if (HZ % USER_HZ)==0",
            "\tif (x >= ~0UL / (HZ / USER_HZ))",
            "\t\treturn ~0UL;",
            "\treturn x * (HZ / USER_HZ);",
            "#else",
            "\t/* Don't worry about loss of precision here .. */",
            "\tif (x >= ~0UL / HZ * USER_HZ)",
            "\t\treturn ~0UL;",
            "",
            "\t/* .. but do try to contain it here */",
            "\treturn div_u64((u64)x * HZ, USER_HZ);",
            "#endif",
            "}",
            "u64 jiffies_64_to_clock_t(u64 x)",
            "{",
            "#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0",
            "# if HZ < USER_HZ",
            "\tx = div_u64(x * USER_HZ, HZ);",
            "# elif HZ > USER_HZ",
            "\tx = div_u64(x, HZ / USER_HZ);",
            "# else",
            "\t/* Nothing to do */",
            "# endif",
            "#else",
            "\t/*",
            "\t * There are better ways that don't overflow early,",
            "\t * but even this doesn't overflow in hundreds of years",
            "\t * in 64 bits, so..",
            "\t */",
            "\tx = div_u64(x * TICK_NSEC, (NSEC_PER_SEC / USER_HZ));",
            "#endif",
            "\treturn x;",
            "}",
            "u64 nsec_to_clock_t(u64 x)",
            "{",
            "#if (NSEC_PER_SEC % USER_HZ) == 0",
            "\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);",
            "#elif (USER_HZ % 512) == 0",
            "\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);",
            "#else",
            "\t/*",
            "         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,",
            "         * overflow after 64.99 years.",
            "         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...",
            "         */",
            "\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);",
            "#endif",
            "}",
            "u64 jiffies64_to_nsecs(u64 j)",
            "{",
            "#if !(NSEC_PER_SEC % HZ)",
            "\treturn (NSEC_PER_SEC / HZ) * j;",
            "# else",
            "\treturn div_u64(j * HZ_TO_NSEC_NUM, HZ_TO_NSEC_DEN);",
            "#endif",
            "}",
            "u64 jiffies64_to_msecs(const u64 j)",
            "{",
            "#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)",
            "\treturn (MSEC_PER_SEC / HZ) * j;",
            "#else",
            "\treturn div_u64(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);",
            "#endif",
            "}"
          ],
          "function_name": "timespec64_to_jiffies, jiffies_to_timespec64, jiffies_to_clock_t, clock_t_to_jiffies, jiffies_64_to_clock_t, nsec_to_clock_t, jiffies64_to_nsecs, jiffies64_to_msecs",
          "description": "提供多种时间表示形式转换函数，包括timespec64与jiffies互转，clock_t与jiffies转换，以及nsec到clock_t等不同时间域间的转换实现。",
          "similarity": 0.4921615719795227
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/time.c",
          "start_line": 1,
          "end_line": 168,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " *",
            " *  This file contains the interface functions for the various time related",
            " *  system calls: time, stime, gettimeofday, settimeofday, adjtime",
            " *",
            " * Modification history:",
            " *",
            " * 1993-09-02    Philip Gladstone",
            " *      Created file with time related functions from sched/core.c and adjtimex()",
            " * 1993-10-08    Torsten Duwe",
            " *      adjtime interface update and CMOS clock write code",
            " * 1995-08-13    Torsten Duwe",
            " *      kernel PLL updated to 1994-12-13 specs (rfc-1589)",
            " * 1999-01-16    Ulrich Windl",
            " *\tIntroduced error checking for many cases in adjtimex().",
            " *\tUpdated NTP code according to technical memorandum Jan '96",
            " *\t\"A Kernel Model for Precision Timekeeping\" by Dave Mills",
            " *\tAllow time_constant larger than MAXTC(6) for NTP v4 (MAXTC == 10)",
            " *\t(Even though the technical memorandum forbids it)",
            " * 2004-07-14\t Christoph Lameter",
            " *\tAdded getnstimeofday to allow the posix timer functions to return",
            " *\twith nanosecond accuracy",
            " */",
            "",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/timex.h>",
            "#include <linux/capability.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/errno.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/math64.h>",
            "#include <linux/ptrace.h>",
            "",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <asm/unistd.h>",
            "",
            "#include <generated/timeconst.h>",
            "#include \"timekeeping.h\"",
            "",
            "/*",
            " * The timezone where the local system is located.  Used as a default by some",
            " * programs who obtain this value by using gettimeofday.",
            " */",
            "struct timezone sys_tz;",
            "",
            "EXPORT_SYMBOL(sys_tz);",
            "",
            "#ifdef __ARCH_WANT_SYS_TIME",
            "",
            "/*",
            " * sys_time() can be implemented in user-level using",
            " * sys_gettimeofday().  Is this for backwards compatibility?  If so,",
            " * why not move it into the appropriate arch directory (for those",
            " * architectures that need it).",
            " */",
            "SYSCALL_DEFINE1(time, __kernel_old_time_t __user *, tloc)",
            "{",
            "\t__kernel_old_time_t i = (__kernel_old_time_t)ktime_get_real_seconds();",
            "",
            "\tif (tloc) {",
            "\t\tif (put_user(i,tloc))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\tforce_successful_syscall_return();",
            "\treturn i;",
            "}",
            "",
            "/*",
            " * sys_stime() can be implemented in user-level using",
            " * sys_settimeofday().  Is this for backwards compatibility?  If so,",
            " * why not move it into the appropriate arch directory (for those",
            " * architectures that need it).",
            " */",
            "",
            "SYSCALL_DEFINE1(stime, __kernel_old_time_t __user *, tptr)",
            "{",
            "\tstruct timespec64 tv;",
            "\tint err;",
            "",
            "\tif (get_user(tv.tv_sec, tptr))",
            "\t\treturn -EFAULT;",
            "",
            "\ttv.tv_nsec = 0;",
            "",
            "\terr = security_settime64(&tv, NULL);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tdo_settimeofday64(&tv);",
            "\treturn 0;",
            "}",
            "",
            "#endif /* __ARCH_WANT_SYS_TIME */",
            "",
            "#ifdef CONFIG_COMPAT_32BIT_TIME",
            "#ifdef __ARCH_WANT_SYS_TIME32",
            "",
            "/* old_time32_t is a 32 bit \"long\" and needs to get converted. */",
            "SYSCALL_DEFINE1(time32, old_time32_t __user *, tloc)",
            "{",
            "\told_time32_t i;",
            "",
            "\ti = (old_time32_t)ktime_get_real_seconds();",
            "",
            "\tif (tloc) {",
            "\t\tif (put_user(i,tloc))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\tforce_successful_syscall_return();",
            "\treturn i;",
            "}",
            "",
            "SYSCALL_DEFINE1(stime32, old_time32_t __user *, tptr)",
            "{",
            "\tstruct timespec64 tv;",
            "\tint err;",
            "",
            "\tif (get_user(tv.tv_sec, tptr))",
            "\t\treturn -EFAULT;",
            "",
            "\ttv.tv_nsec = 0;",
            "",
            "\terr = security_settime64(&tv, NULL);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tdo_settimeofday64(&tv);",
            "\treturn 0;",
            "}",
            "",
            "#endif /* __ARCH_WANT_SYS_TIME32 */",
            "#endif",
            "",
            "SYSCALL_DEFINE2(gettimeofday, struct __kernel_old_timeval __user *, tv,",
            "\t\tstruct timezone __user *, tz)",
            "{",
            "\tif (likely(tv != NULL)) {",
            "\t\tstruct timespec64 ts;",
            "",
            "\t\tktime_get_real_ts64(&ts);",
            "\t\tif (put_user(ts.tv_sec, &tv->tv_sec) ||",
            "\t\t    put_user(ts.tv_nsec / 1000, &tv->tv_usec))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\tif (unlikely(tz != NULL)) {",
            "\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\treturn 0;",
            "}",
            "",
            "/*",
            " * In case for some reason the CMOS clock has not already been running",
            " * in UTC, but in some local time: The first time we set the timezone,",
            " * we will warp the clock so that it is ticking UTC time instead of",
            " * local time. Presumably, if someone is setting the timezone then we",
            " * are running in an environment where the programs understand about",
            " * timezones. This should be done at boot time in the /etc/rc script,",
            " * as soon as possible, so that the clock can be set right. Otherwise,",
            " * various programs will get confused when the clock gets warped.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "定义了时间相关系统调用接口，包括time、stime、gettimeofday等函数，用于获取和设置系统时间及时区信息，包含安全检查和用户空间数据拷贝操作。",
          "similarity": 0.4906849265098572
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/time.c",
          "start_line": 400,
          "end_line": 501,
          "content": [
            "unsigned int jiffies_to_usecs(const unsigned long j)",
            "{",
            "\t/*",
            "\t * Hz usually doesn't go much further MSEC_PER_SEC.",
            "\t * jiffies_to_usecs() and usecs_to_jiffies() depend on that.",
            "\t */",
            "\tBUILD_BUG_ON(HZ > USEC_PER_SEC);",
            "",
            "#if !(USEC_PER_SEC % HZ)",
            "\treturn (USEC_PER_SEC / HZ) * j;",
            "#else",
            "# if BITS_PER_LONG == 32",
            "\treturn (HZ_TO_USEC_MUL32 * j) >> HZ_TO_USEC_SHR32;",
            "# else",
            "\treturn (j * HZ_TO_USEC_NUM) / HZ_TO_USEC_DEN;",
            "# endif",
            "#endif",
            "}",
            "time64_t mktime64(const unsigned int year0, const unsigned int mon0,",
            "\t\tconst unsigned int day, const unsigned int hour,",
            "\t\tconst unsigned int min, const unsigned int sec)",
            "{",
            "\tunsigned int mon = mon0, year = year0;",
            "",
            "\t/* 1..12 -> 11,12,1..10 */",
            "\tif (0 >= (int) (mon -= 2)) {",
            "\t\tmon += 12;\t/* Puts Feb last since it has leap day */",
            "\t\tyear -= 1;",
            "\t}",
            "",
            "\treturn ((((time64_t)",
            "\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +",
            "\t\t  year*365 - 719499",
            "\t    )*24 + hour /* now have hours - midnight tomorrow handled here */",
            "\t  )*60 + min /* now have minutes */",
            "\t)*60 + sec; /* finally seconds */",
            "}",
            "struct __kernel_old_timeval ns_to_kernel_old_timeval(s64 nsec)",
            "{",
            "\tstruct timespec64 ts = ns_to_timespec64(nsec);",
            "\tstruct __kernel_old_timeval tv;",
            "",
            "\ttv.tv_sec = ts.tv_sec;",
            "\ttv.tv_usec = (suseconds_t)ts.tv_nsec / 1000;",
            "",
            "\treturn tv;",
            "}",
            "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)",
            "{",
            "\twhile (nsec >= NSEC_PER_SEC) {",
            "\t\t/*",
            "\t\t * The following asm() prevents the compiler from",
            "\t\t * optimising this loop into a modulo operation. See",
            "\t\t * also __iter_div_u64_rem() in include/linux/time.h",
            "\t\t */",
            "\t\tasm(\"\" : \"+rm\"(nsec));",
            "\t\tnsec -= NSEC_PER_SEC;",
            "\t\t++sec;",
            "\t}",
            "\twhile (nsec < 0) {",
            "\t\tasm(\"\" : \"+rm\"(nsec));",
            "\t\tnsec += NSEC_PER_SEC;",
            "\t\t--sec;",
            "\t}",
            "\tts->tv_sec = sec;",
            "\tts->tv_nsec = nsec;",
            "}",
            "struct timespec64 ns_to_timespec64(s64 nsec)",
            "{",
            "\tstruct timespec64 ts = { 0, 0 };",
            "\ts32 rem;",
            "",
            "\tif (likely(nsec > 0)) {",
            "\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);",
            "\t\tts.tv_nsec = rem;",
            "\t} else if (nsec < 0) {",
            "\t\t/*",
            "\t\t * With negative times, tv_sec points to the earlier",
            "\t\t * second, and tv_nsec counts the nanoseconds since",
            "\t\t * then, so tv_nsec is always a positive number.",
            "\t\t */",
            "\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;",
            "\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;",
            "\t}",
            "",
            "\treturn ts;",
            "}",
            "unsigned long __msecs_to_jiffies(const unsigned int m)",
            "{",
            "\t/*",
            "\t * Negative value, means infinite timeout:",
            "\t */",
            "\tif ((int)m < 0)",
            "\t\treturn MAX_JIFFY_OFFSET;",
            "\treturn _msecs_to_jiffies(m);",
            "}",
            "unsigned long __usecs_to_jiffies(const unsigned int u)",
            "{",
            "\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))",
            "\t\treturn MAX_JIFFY_OFFSET;",
            "\treturn _usecs_to_jiffies(u);",
            "}"
          ],
          "function_name": "jiffies_to_usecs, mktime64, ns_to_kernel_old_timeval, set_normalized_timespec64, ns_to_timespec64, __msecs_to_jiffies, __usecs_to_jiffies",
          "description": "包含时间单位转换函数jiffies_to_usecs/msecs_to_jiffies等，实现mktime64日期转时间戳，ns_to_*系列纳秒到时间结构体转换，以及set_normalized_timespec64时间归一化处理。",
          "similarity": 0.4771782457828522
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/time.c",
          "start_line": 169,
          "end_line": 273,
          "content": [
            "int do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)",
            "{",
            "\tstatic int firsttime = 1;",
            "\tint error = 0;",
            "",
            "\tif (tv && !timespec64_valid_settod(tv))",
            "\t\treturn -EINVAL;",
            "",
            "\terror = security_settime64(tv, tz);",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\tif (tz) {",
            "\t\t/* Verify we're within the +-15 hrs range */",
            "\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tsys_tz = *tz;",
            "\t\tupdate_vsyscall_tz();",
            "\t\tif (firsttime) {",
            "\t\t\tfirsttime = 0;",
            "\t\t\tif (!tv)",
            "\t\t\t\ttimekeeping_warp_clock();",
            "\t\t}",
            "\t}",
            "\tif (tv)",
            "\t\treturn do_settimeofday64(tv);",
            "\treturn 0;",
            "}",
            "int get_old_timex32(struct __kernel_timex *txc, const struct old_timex32 __user *utp)",
            "{",
            "\tstruct old_timex32 tx32;",
            "",
            "\tmemset(txc, 0, sizeof(struct __kernel_timex));",
            "\tif (copy_from_user(&tx32, utp, sizeof(struct old_timex32)))",
            "\t\treturn -EFAULT;",
            "",
            "\ttxc->modes = tx32.modes;",
            "\ttxc->offset = tx32.offset;",
            "\ttxc->freq = tx32.freq;",
            "\ttxc->maxerror = tx32.maxerror;",
            "\ttxc->esterror = tx32.esterror;",
            "\ttxc->status = tx32.status;",
            "\ttxc->constant = tx32.constant;",
            "\ttxc->precision = tx32.precision;",
            "\ttxc->tolerance = tx32.tolerance;",
            "\ttxc->time.tv_sec = tx32.time.tv_sec;",
            "\ttxc->time.tv_usec = tx32.time.tv_usec;",
            "\ttxc->tick = tx32.tick;",
            "\ttxc->ppsfreq = tx32.ppsfreq;",
            "\ttxc->jitter = tx32.jitter;",
            "\ttxc->shift = tx32.shift;",
            "\ttxc->stabil = tx32.stabil;",
            "\ttxc->jitcnt = tx32.jitcnt;",
            "\ttxc->calcnt = tx32.calcnt;",
            "\ttxc->errcnt = tx32.errcnt;",
            "\ttxc->stbcnt = tx32.stbcnt;",
            "",
            "\treturn 0;",
            "}",
            "int put_old_timex32(struct old_timex32 __user *utp, const struct __kernel_timex *txc)",
            "{",
            "\tstruct old_timex32 tx32;",
            "",
            "\tmemset(&tx32, 0, sizeof(struct old_timex32));",
            "\ttx32.modes = txc->modes;",
            "\ttx32.offset = txc->offset;",
            "\ttx32.freq = txc->freq;",
            "\ttx32.maxerror = txc->maxerror;",
            "\ttx32.esterror = txc->esterror;",
            "\ttx32.status = txc->status;",
            "\ttx32.constant = txc->constant;",
            "\ttx32.precision = txc->precision;",
            "\ttx32.tolerance = txc->tolerance;",
            "\ttx32.time.tv_sec = txc->time.tv_sec;",
            "\ttx32.time.tv_usec = txc->time.tv_usec;",
            "\ttx32.tick = txc->tick;",
            "\ttx32.ppsfreq = txc->ppsfreq;",
            "\ttx32.jitter = txc->jitter;",
            "\ttx32.shift = txc->shift;",
            "\ttx32.stabil = txc->stabil;",
            "\ttx32.jitcnt = txc->jitcnt;",
            "\ttx32.calcnt = txc->calcnt;",
            "\ttx32.errcnt = txc->errcnt;",
            "\ttx32.stbcnt = txc->stbcnt;",
            "\ttx32.tai = txc->tai;",
            "\tif (copy_to_user(utp, &tx32, sizeof(struct old_timex32)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "unsigned int jiffies_to_msecs(const unsigned long j)",
            "{",
            "#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)",
            "\treturn (MSEC_PER_SEC / HZ) * j;",
            "#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)",
            "\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);",
            "#else",
            "# if BITS_PER_LONG == 32",
            "\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>",
            "\t       HZ_TO_MSEC_SHR32;",
            "# else",
            "\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);",
            "# endif",
            "#endif",
            "}"
          ],
          "function_name": "do_sys_settimeofday64, get_old_timex32, put_old_timex32, jiffies_to_msecs",
          "description": "实现do_sys_settimeofday64用于设置系统时间，提供old_timex结构体转换函数get_old_timex32/put_old_timex32，以及jiffies到毫秒的转换函数jiffies_to_msecs。",
          "similarity": 0.47637295722961426
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/time/time.c",
          "start_line": 796,
          "end_line": 899,
          "content": [
            "u64 nsecs_to_jiffies64(u64 n)",
            "{",
            "#if (NSEC_PER_SEC % HZ) == 0",
            "\t/* Common case, HZ = 100, 128, 200, 250, 256, 500, 512, 1000 etc. */",
            "\treturn div_u64(n, NSEC_PER_SEC / HZ);",
            "#elif (HZ % 512) == 0",
            "\t/* overflow after 292 years if HZ = 1024 */",
            "\treturn div_u64(n * HZ / 512, NSEC_PER_SEC / 512);",
            "#else",
            "\t/*",
            "\t * Generic case - optimized for cases where HZ is a multiple of 3.",
            "\t * overflow after 64.99 years, exact for HZ = 60, 72, 90, 120 etc.",
            "\t */",
            "\treturn div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);",
            "#endif",
            "}",
            "unsigned long nsecs_to_jiffies(u64 n)",
            "{",
            "\treturn (unsigned long)nsecs_to_jiffies64(n);",
            "}",
            "struct timespec64 timespec64_add_safe(const struct timespec64 lhs,",
            "\t\t\t\tconst struct timespec64 rhs)",
            "{",
            "\tstruct timespec64 res;",
            "",
            "\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,",
            "\t\t\tlhs.tv_nsec + rhs.tv_nsec);",
            "",
            "\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {",
            "\t\tres.tv_sec = TIME64_MAX;",
            "\t\tres.tv_nsec = 0;",
            "\t}",
            "",
            "\treturn res;",
            "}",
            "int get_timespec64(struct timespec64 *ts,",
            "\t\t   const struct __kernel_timespec __user *uts)",
            "{",
            "\tstruct __kernel_timespec kts;",
            "\tint ret;",
            "",
            "\tret = copy_from_user(&kts, uts, sizeof(kts));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tts->tv_sec = kts.tv_sec;",
            "",
            "\t/* Zero out the padding in compat mode */",
            "\tif (in_compat_syscall())",
            "\t\tkts.tv_nsec &= 0xFFFFFFFFUL;",
            "",
            "\t/* In 32-bit mode, this drops the padding */",
            "\tts->tv_nsec = kts.tv_nsec;",
            "",
            "\treturn 0;",
            "}",
            "int put_timespec64(const struct timespec64 *ts,",
            "\t\t   struct __kernel_timespec __user *uts)",
            "{",
            "\tstruct __kernel_timespec kts = {",
            "\t\t.tv_sec = ts->tv_sec,",
            "\t\t.tv_nsec = ts->tv_nsec",
            "\t};",
            "",
            "\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;",
            "}",
            "static int __get_old_timespec32(struct timespec64 *ts64,",
            "\t\t\t\t   const struct old_timespec32 __user *cts)",
            "{",
            "\tstruct old_timespec32 ts;",
            "\tint ret;",
            "",
            "\tret = copy_from_user(&ts, cts, sizeof(ts));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tts64->tv_sec = ts.tv_sec;",
            "\tts64->tv_nsec = ts.tv_nsec;",
            "",
            "\treturn 0;",
            "}",
            "static int __put_old_timespec32(const struct timespec64 *ts64,",
            "\t\t\t\t   struct old_timespec32 __user *cts)",
            "{",
            "\tstruct old_timespec32 ts = {",
            "\t\t.tv_sec = ts64->tv_sec,",
            "\t\t.tv_nsec = ts64->tv_nsec",
            "\t};",
            "\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;",
            "}",
            "int get_old_timespec32(struct timespec64 *ts, const void __user *uts)",
            "{",
            "\tif (COMPAT_USE_64BIT_TIME)",
            "\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;",
            "\telse",
            "\t\treturn __get_old_timespec32(ts, uts);",
            "}",
            "int put_old_timespec32(const struct timespec64 *ts, void __user *uts)",
            "{",
            "\tif (COMPAT_USE_64BIT_TIME)",
            "\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;",
            "\telse",
            "\t\treturn __put_old_timespec32(ts, uts);",
            "}"
          ],
          "function_name": "nsecs_to_jiffies64, nsecs_to_jiffies, timespec64_add_safe, get_timespec64, put_timespec64, __get_old_timespec32, __put_old_timespec32, get_old_timespec32, put_old_timespec32",
          "description": "实现纳秒到jiffies转换nsecs_to_jiffies64，时间相加函数timespec64_add_safe，以及timespec64与用户态old_timespec32结构体的数据复制函数get/put_old_timespec32。",
          "similarity": 0.45765990018844604
        }
      ]
    }
  ]
}