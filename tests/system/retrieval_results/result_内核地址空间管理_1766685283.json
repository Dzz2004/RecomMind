{
  "query": "内核地址空间管理",
  "timestamp": "2025-12-26 01:54:43",
  "retrieved_files": [
    {
      "source_file": "mm/memblock.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memblock.c`\n\n---\n\n# memblock.c 技术文档\n\n## 1. 文件概述\n\n`memblock.c` 实现了 Linux 内核早期启动阶段的内存管理机制——**memblock**。该机制用于在常规内存分配器（如 buddy allocator）尚未初始化之前，对物理内存进行粗粒度的区域管理。它将系统内存抽象为若干连续的内存区域（regions），支持“可用内存”（memory）、“保留内存”（reserved）和“物理内存”（physmem，部分架构支持）三种类型，为内核早期初始化提供内存添加、查询和分配能力。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct memblock_region`：表示一个连续的物理内存区域，包含基地址（base）、大小（size）、NUMA 节点 ID 和属性标志。\n- `struct memblock_type`：管理一类内存区域的集合，包含区域数组、当前数量（cnt）、最大容量（max）和名称。\n- `struct memblock`：全局 memblock 管理结构，包含 `memory` 和 `reserved` 两种类型的 `memblock_type`，以及分配方向（bottom_up）和当前分配上限（current_limit）。\n- `physmem`（条件编译）：描述不受 `mem=` 参数限制的实际物理内存布局。\n\n### 主要函数与变量\n- `memblock_add()` / `memblock_add_node()`：向 memblock 添加可用内存区域。\n- `memblock_reserve()`：标记内存区域为保留（不可用于动态分配）。\n- `memblock_phys_alloc*()` / `memblock_alloc*()`：分配物理或虚拟地址的内存。\n- `memblock_overlaps_region()`：判断指定区域是否与某类 memblock 区域重叠。\n- `__memblock_find_range_bottom_up()`：从低地址向高地址查找满足条件的空闲内存范围。\n- 全局变量 `memblock`：静态初始化的主 memblock 结构体。\n- `max_low_pfn`, `min_low_pfn`, `max_pfn`, `max_possible_pfn`：记录 PFN（页帧号）边界信息。\n\n### 配置宏\n- `INIT_MEMBLOCK_REGIONS`：初始内存/保留区域数组大小（默认 128）。\n- `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 类型支持。\n- `CONFIG_MEMBLOCK_KHO_SCRATCH`：支持仅从特定标记（KHO_SCRATCH）区域分配内存。\n- `CONFIG_ARCH_KEEP_MEMBLOCK`：决定是否在初始化完成后保留 memblock 数据结构。\n\n## 3. 关键实现\n\n### 初始化与存储\n- `memblock` 结构体在编译时静态初始化，其 `memory` 和 `reserved` 的区域数组分别使用 `memblock_memory_init_regions` 和 `memblock_reserved_init_regions`，初始容量由 `INIT_MEMBLOCK_*_REGIONS` 定义。\n- 每个 `memblock_type` 的 `cnt` 初始设为 1，但实际第一个条目为空的占位符，有效区域从索引 1 开始（后续代码处理）。\n- 支持通过 `memblock_allow_resize()` 动态扩容区域数组，但需谨慎避免与 initrd 等关键区域冲突。\n\n### 内存区域管理\n- 使用 `for_each_memblock_type` 宏遍历指定类型的区域。\n- `memblock_addrs_overlap()` 通过比较区间端点判断两个物理内存区域是否重叠。\n- `memblock_overlaps_region()` 封装了对某类所有区域的重叠检测。\n\n### 分配策略\n- 默认采用 **top-down**（从高地址向低地址）分配策略，可通过 `memblock_set_bottom_up(true)` 切换为 **bottom-up**。\n- 分配时受 `current_limit` 限制（默认 `MEMBLOCK_ALLOC_ANYWHERE` 表示无限制）。\n- 支持基于 NUMA 节点、对齐要求、内存属性（如 `MEMBLOCK_MIRROR`、`MEMBLOCK_KHO_SCRATCH`）的精细控制。\n- `choose_memblock_flags()` 根据 `kho_scratch_only` 和镜像内存存在性动态选择分配标志。\n\n### 安全与调试\n- `memblock_cap_size()` 防止地址计算溢出（确保 `base + size <= PHYS_ADDR_MAX`）。\n- 条件编译的 `memblock_dbg()` 宏用于调试输出（需开启 `memblock_debug`）。\n- 使用 `__initdata_memblock` 属性标记仅在初始化阶段使用的数据，便于后续释放。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memblock.h>`：定义 memblock API 和数据结构。\n  - `<linux/kernel.h>`, `<linux/init.h>`：提供基础内核功能和初始化宏。\n  - `<linux/pfn.h>`：PFN 相关操作。\n  - `<asm/sections.h>`：访问内核链接段信息。\n  - 架构相关头文件（如 `internal.h`）。\n- **配置依赖**：\n  - `CONFIG_NUMA`：影响 `contig_page_data` 的定义。\n  - `CONFIG_KEXEC_HANDOVER`：引入 kexec 相关头文件。\n  - `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 支持。\n- **后续移交**：在 `mem_init()` 中，memblock 管理的内存会被释放给 buddy allocator，完成内存管理权移交。\n\n## 5. 使用场景\n\n- **内核早期初始化**：在 `start_kernel()` 初期，架构代码（如 `setup_arch()`）调用 `memblock_add()` 注册可用物理内存，调用 `memblock_reserve()` 保留内核镜像、设备树、initrd 等关键区域。\n- **早期内存分配**：在 slab/buddy 分配器就绪前，使用 `memblock_alloc()` 分配大块连续内存（如页表、中断向量表、ACPI 表解析缓冲区）。\n- **内存布局查询**：通过 `for_each_memblock()` 等宏遍历内存区域，用于构建 e820 表、EFI 内存映射或 NUMA 拓扑。\n- **特殊分配需求**：支持从镜像内存（`MEMBLOCK_MIRROR`）或 KHO scratch 区域分配，满足安全启动或崩溃转储等场景。\n- **调试与分析**：通过 debugfs 接口（未在片段中体现）导出 memblock 布局，辅助内存问题诊断。",
      "similarity": 0.6286170482635498,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "mm/memblock.c",
          "start_line": 1954,
          "end_line": 2057,
          "content": [
            "void __init memblock_mem_limit_remove_map(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\tmemblock_cap_memory_range(0, max_addr);",
            "}",
            "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)",
            "{",
            "\tunsigned int left = 0, right = type->cnt;",
            "",
            "\tdo {",
            "\t\tunsigned int mid = (right + left) / 2;",
            "",
            "\t\tif (addr < type->regions[mid].base)",
            "\t\t\tright = mid;",
            "\t\telse if (addr >= (type->regions[mid].base +",
            "\t\t\t\t  type->regions[mid].size))",
            "\t\t\tleft = mid + 1;",
            "\t\telse",
            "\t\t\treturn mid;",
            "\t} while (left < right);",
            "\treturn -1;",
            "}",
            "bool __init_memblock memblock_is_reserved(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.reserved, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_memory(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.memory, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_map_memory(phys_addr_t addr)",
            "{",
            "\tint i = memblock_search(&memblock.memory, addr);",
            "",
            "\tif (i == -1)",
            "\t\treturn false;",
            "\treturn !memblock_is_nomap(&memblock.memory.regions[i]);",
            "}",
            "int __init_memblock memblock_search_pfn_nid(unsigned long pfn,",
            "\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)",
            "{",
            "\tstruct memblock_type *type = &memblock.memory;",
            "\tint mid = memblock_search(type, PFN_PHYS(pfn));",
            "",
            "\tif (mid == -1)",
            "\t\treturn -1;",
            "",
            "\t*start_pfn = PFN_DOWN(type->regions[mid].base);",
            "\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);",
            "",
            "\treturn memblock_get_region_node(&type->regions[mid]);",
            "}",
            "bool __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint idx = memblock_search(&memblock.memory, base);",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "",
            "\tif (idx == -1)",
            "\t\treturn false;",
            "\treturn (memblock.memory.regions[idx].base +",
            "\t\t memblock.memory.regions[idx].size) >= end;",
            "}",
            "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_overlaps_region(&memblock.reserved, base, size);",
            "}",
            "void __init_memblock memblock_trim_memory(phys_addr_t align)",
            "{",
            "\tphys_addr_t start, end, orig_start, orig_end;",
            "\tstruct memblock_region *r;",
            "",
            "\tfor_each_mem_region(r) {",
            "\t\torig_start = r->base;",
            "\t\torig_end = r->base + r->size;",
            "\t\tstart = round_up(orig_start, align);",
            "\t\tend = round_down(orig_end, align);",
            "",
            "\t\tif (start == orig_start && end == orig_end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start < end) {",
            "\t\t\tr->base = start;",
            "\t\t\tr->size = end - start;",
            "\t\t} else {",
            "\t\t\tmemblock_remove_region(&memblock.memory,",
            "\t\t\t\t\t       r - memblock.memory.regions);",
            "\t\t\tr--;",
            "\t\t}",
            "\t}",
            "}",
            "void __init_memblock memblock_set_current_limit(phys_addr_t limit)",
            "{",
            "\tmemblock.current_limit = limit;",
            "}"
          ],
          "function_name": "memblock_mem_limit_remove_map, memblock_search, memblock_is_reserved, memblock_is_memory, memblock_is_map_memory, memblock_search_pfn_nid, memblock_is_region_memory, memblock_is_region_reserved, memblock_trim_memory, memblock_set_current_limit",
          "description": "实现内存块限制移除、搜索和区域判断逻辑，用于管理内存和保留区域的地址范围查询及修剪操作",
          "similarity": 0.6946563124656677
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memblock.c",
          "start_line": 192,
          "end_line": 297,
          "content": [
            "static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)",
            "{",
            "\treturn *size = min(*size, PHYS_ADDR_MAX - base);",
            "}",
            "unsigned long __init_memblock",
            "memblock_addrs_overlap(phys_addr_t base1, phys_addr_t size1, phys_addr_t base2,",
            "\t\t       phys_addr_t size2)",
            "{",
            "\treturn ((base1 < (base2 + size2)) && (base2 < (base1 + size1)));",
            "}",
            "bool __init_memblock memblock_overlaps_region(struct memblock_type *type,",
            "\t\t\t\t\tphys_addr_t base, phys_addr_t size)",
            "{",
            "\tunsigned long i;",
            "",
            "\tmemblock_cap_size(base, &size);",
            "",
            "\tfor (i = 0; i < type->cnt; i++)",
            "\t\tif (memblock_addrs_overlap(base, size, type->regions[i].base,",
            "\t\t\t\t\t   type->regions[i].size))",
            "\t\t\tbreak;",
            "\treturn i < type->cnt;",
            "}",
            "static phys_addr_t __init_memblock",
            "__memblock_find_range_bottom_up(phys_addr_t start, phys_addr_t end,",
            "\t\t\t\tphys_addr_t size, phys_addr_t align, int nid,",
            "\t\t\t\tenum memblock_flags flags)",
            "{",
            "\tphys_addr_t this_start, this_end, cand;",
            "\tu64 i;",
            "",
            "\tfor_each_free_mem_range(i, nid, flags, &this_start, &this_end, NULL) {",
            "\t\tthis_start = clamp(this_start, start, end);",
            "\t\tthis_end = clamp(this_end, start, end);",
            "",
            "\t\tcand = round_up(this_start, align);",
            "\t\tif (cand < this_end && this_end - cand >= size)",
            "\t\t\treturn cand;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static phys_addr_t __init_memblock",
            "__memblock_find_range_top_down(phys_addr_t start, phys_addr_t end,",
            "\t\t\t       phys_addr_t size, phys_addr_t align, int nid,",
            "\t\t\t       enum memblock_flags flags)",
            "{",
            "\tphys_addr_t this_start, this_end, cand;",
            "\tu64 i;",
            "",
            "\tfor_each_free_mem_range_reverse(i, nid, flags, &this_start, &this_end,",
            "\t\t\t\t\tNULL) {",
            "\t\tthis_start = clamp(this_start, start, end);",
            "\t\tthis_end = clamp(this_end, start, end);",
            "",
            "\t\tif (this_end < size)",
            "\t\t\tcontinue;",
            "",
            "\t\tcand = round_down(this_end - size, align);",
            "\t\tif (cand >= this_start)",
            "\t\t\treturn cand;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,",
            "\t\t\t\t\tphys_addr_t align, phys_addr_t start,",
            "\t\t\t\t\tphys_addr_t end, int nid,",
            "\t\t\t\t\tenum memblock_flags flags)",
            "{",
            "\t/* pump up @end */",
            "\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE ||",
            "\t    end == MEMBLOCK_ALLOC_NOLEAKTRACE)",
            "\t\tend = memblock.current_limit;",
            "",
            "\t/* avoid allocating the first page */",
            "\tstart = max_t(phys_addr_t, start, PAGE_SIZE);",
            "\tend = max(start, end);",
            "",
            "\tif (memblock_bottom_up())",
            "\t\treturn __memblock_find_range_bottom_up(start, end, size, align,",
            "\t\t\t\t\t\t       nid, flags);",
            "\telse",
            "\t\treturn __memblock_find_range_top_down(start, end, size, align,",
            "\t\t\t\t\t\t      nid, flags);",
            "}",
            "static phys_addr_t __init_memblock memblock_find_in_range(phys_addr_t start,",
            "\t\t\t\t\tphys_addr_t end, phys_addr_t size,",
            "\t\t\t\t\tphys_addr_t align)",
            "{",
            "\tphys_addr_t ret;",
            "\tenum memblock_flags flags = choose_memblock_flags();",
            "",
            "again:",
            "\tret = memblock_find_in_range_node(size, align, start, end,",
            "\t\t\t\t\t    NUMA_NO_NODE, flags);",
            "",
            "\tif (!ret && (flags & MEMBLOCK_MIRROR)) {",
            "\t\tpr_warn_ratelimited(\"Could not allocate %pap bytes of mirrored memory\\n\",",
            "\t\t\t&size);",
            "\t\tflags &= ~MEMBLOCK_MIRROR;",
            "\t\tgoto again;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "memblock_cap_size, memblock_addrs_overlap, memblock_overlaps_region, __memblock_find_range_bottom_up, __memblock_find_range_top_down, memblock_find_in_range_node, memblock_find_in_range",
          "description": "实现内存区域地址重叠检测与分配策略选择逻辑，包含范围查找算法（底向顶/顶向底）及镜像内存分配失败回退机制。",
          "similarity": 0.6354473829269409
        },
        {
          "chunk_id": 9,
          "file_path": "mm/memblock.c",
          "start_line": 1607,
          "end_line": 1734,
          "content": [
            "phys_addr_t __init memblock_phys_alloc_range(phys_addr_t size,",
            "\t\t\t\t\t     phys_addr_t align,",
            "\t\t\t\t\t     phys_addr_t start,",
            "\t\t\t\t\t     phys_addr_t end)",
            "{",
            "\tmemblock_dbg(\"%s: %llu bytes align=0x%llx from=%pa max_addr=%pa %pS\\n\",",
            "\t\t     __func__, (u64)size, (u64)align, &start, &end,",
            "\t\t     (void *)_RET_IP_);",
            "\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,",
            "\t\t\t\t\tfalse);",
            "}",
            "phys_addr_t __init memblock_phys_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)",
            "{",
            "\treturn memblock_alloc_range_nid(size, align, 0,",
            "\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid, false);",
            "}",
            "void __init memblock_free_late(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t cursor, end;",
            "",
            "\tend = base + size - 1;",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\",",
            "\t\t     __func__, &base, &end, (void *)_RET_IP_);",
            "\tkmemleak_free_part_phys(base, size);",
            "\tcursor = PFN_UP(base);",
            "\tend = PFN_DOWN(base + size);",
            "",
            "\tfor (; cursor < end; cursor++) {",
            "\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);",
            "\t\ttotalram_pages_inc();",
            "\t}",
            "}",
            "phys_addr_t __init_memblock memblock_reserved_kern_size(phys_addr_t limit, int nid)",
            "{",
            "\tstruct memblock_region *r;",
            "\tphys_addr_t total = 0;",
            "",
            "\tfor_each_reserved_mem_region(r) {",
            "\t\tphys_addr_t size = r->size;",
            "",
            "\t\tif (r->base > limit)",
            "\t\t\tbreak;",
            "",
            "\t\tif (r->base + r->size > limit)",
            "\t\t\tsize = limit - r->base;",
            "",
            "\t\tif (nid == memblock_get_region_node(r) || !numa_valid_node(nid))",
            "\t\t\tif (r->flags & MEMBLOCK_RSRV_KERN)",
            "\t\t\t\ttotal += size;",
            "\t}",
            "",
            "\treturn total;",
            "}",
            "unsigned long __init memblock_estimated_nr_free_pages(void)",
            "{",
            "\treturn PHYS_PFN(memblock_phys_mem_size() - memblock_reserved_size());",
            "}",
            "static phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr = PHYS_ADDR_MAX;",
            "\tstruct memblock_region *r;",
            "",
            "\t/*",
            "\t * translate the memory @limit size into the max address within one of",
            "\t * the memory memblock regions, if the @limit exceeds the total size",
            "\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX",
            "\t */",
            "\tfor_each_mem_region(r) {",
            "\t\tif (limit <= r->size) {",
            "\t\t\tmax_addr = r->base + limit;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tlimit -= r->size;",
            "\t}",
            "",
            "\treturn max_addr;",
            "}",
            "void __init memblock_enforce_memory_limit(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\t/* truncate both memory and reserved regions */",
            "\tmemblock_remove_range(&memblock.memory, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "\tmemblock_remove_range(&memblock.reserved, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "}",
            "void __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint start_rgn, end_rgn;",
            "\tint i, ret;",
            "",
            "\tif (!size)",
            "\t\treturn;",
            "",
            "\tif (!memblock_memory->total_size) {",
            "\t\tpr_warn(\"%s: No memory registered yet\\n\", __func__);",
            "\t\treturn;",
            "\t}",
            "",
            "\tret = memblock_isolate_range(&memblock.memory, base, size,",
            "\t\t\t\t\t\t&start_rgn, &end_rgn);",
            "\tif (ret)",
            "\t\treturn;",
            "",
            "\t/* remove all the MAP regions */",
            "\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\tfor (i = start_rgn - 1; i >= 0; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\t/* truncate the reserved regions */",
            "\tmemblock_remove_range(&memblock.reserved, 0, base);",
            "\tmemblock_remove_range(&memblock.reserved,",
            "\t\t\tbase + size, PHYS_ADDR_MAX);",
            "}"
          ],
          "function_name": "memblock_phys_alloc_range, memblock_phys_alloc_try_nid, memblock_free_late, memblock_reserved_kern_size, memblock_estimated_nr_free_pages, __find_max_addr, memblock_enforce_memory_limit, memblock_cap_memory_range",
          "description": "实现物理内存分配/释放控制，包含内存上限强制限制、空闲页面估算、内存区域截断等管理功能，支持对保留内存的容量统计",
          "similarity": 0.6245949864387512
        },
        {
          "chunk_id": 6,
          "file_path": "mm/memblock.c",
          "start_line": 1052,
          "end_line": 1196,
          "content": [
            "int __init_memblock memblock_mark_mirror(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tif (!mirrored_kernelcore)",
            "\t\treturn 0;",
            "",
            "\tsystem_has_some_mirror = true;",
            "",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 1, MEMBLOCK_MIRROR);",
            "}",
            "int __init_memblock memblock_mark_nomap(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 1, MEMBLOCK_NOMAP);",
            "}",
            "int __init_memblock memblock_clear_nomap(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 0, MEMBLOCK_NOMAP);",
            "}",
            "int __init_memblock memblock_reserved_mark_noinit(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.reserved, base, size, 1,",
            "\t\t\t\t    MEMBLOCK_RSRV_NOINIT);",
            "}",
            "__init int memblock_mark_kho_scratch(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 1,",
            "\t\t\t\t    MEMBLOCK_KHO_SCRATCH);",
            "}",
            "__init int memblock_clear_kho_scratch(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 0,",
            "\t\t\t\t    MEMBLOCK_KHO_SCRATCH);",
            "}",
            "static bool should_skip_region(struct memblock_type *type,",
            "\t\t\t       struct memblock_region *m,",
            "\t\t\t       int nid, int flags)",
            "{",
            "\tint m_nid = memblock_get_region_node(m);",
            "",
            "\t/* we never skip regions when iterating memblock.reserved or physmem */",
            "\tif (type != memblock_memory)",
            "\t\treturn false;",
            "",
            "\t/* only memory regions are associated with nodes, check it */",
            "\tif (numa_valid_node(nid) && nid != m_nid)",
            "\t\treturn true;",
            "",
            "\t/* skip hotpluggable memory regions if needed */",
            "\tif (movable_node_is_enabled() && memblock_is_hotpluggable(m) &&",
            "\t    !(flags & MEMBLOCK_HOTPLUG))",
            "\t\treturn true;",
            "",
            "\t/* if we want mirror memory skip non-mirror memory regions */",
            "\tif ((flags & MEMBLOCK_MIRROR) && !memblock_is_mirror(m))",
            "\t\treturn true;",
            "",
            "\t/* skip nomap memory unless we were asked for it explicitly */",
            "\tif (!(flags & MEMBLOCK_NOMAP) && memblock_is_nomap(m))",
            "\t\treturn true;",
            "",
            "\t/* skip driver-managed memory unless we were asked for it explicitly */",
            "\tif (!(flags & MEMBLOCK_DRIVER_MANAGED) && memblock_is_driver_managed(m))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * In early alloc during kexec handover, we can only consider",
            "\t * MEMBLOCK_KHO_SCRATCH regions for the allocations",
            "\t */",
            "\tif ((flags & MEMBLOCK_KHO_SCRATCH) && !memblock_is_kho_scratch(m))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "void __next_mem_range(u64 *idx, int nid, enum memblock_flags flags,",
            "\t\t      struct memblock_type *type_a,",
            "\t\t      struct memblock_type *type_b, phys_addr_t *out_start,",
            "\t\t      phys_addr_t *out_end, int *out_nid)",
            "{",
            "\tint idx_a = *idx & 0xffffffff;",
            "\tint idx_b = *idx >> 32;",
            "",
            "\tfor (; idx_a < type_a->cnt; idx_a++) {",
            "\t\tstruct memblock_region *m = &type_a->regions[idx_a];",
            "",
            "\t\tphys_addr_t m_start = m->base;",
            "\t\tphys_addr_t m_end = m->base + m->size;",
            "\t\tint\t    m_nid = memblock_get_region_node(m);",
            "",
            "\t\tif (should_skip_region(type_a, m, nid, flags))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (!type_b) {",
            "\t\t\tif (out_start)",
            "\t\t\t\t*out_start = m_start;",
            "\t\t\tif (out_end)",
            "\t\t\t\t*out_end = m_end;",
            "\t\t\tif (out_nid)",
            "\t\t\t\t*out_nid = m_nid;",
            "\t\t\tidx_a++;",
            "\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t/* scan areas before each reservation */",
            "\t\tfor (; idx_b < type_b->cnt + 1; idx_b++) {",
            "\t\t\tstruct memblock_region *r;",
            "\t\t\tphys_addr_t r_start;",
            "\t\t\tphys_addr_t r_end;",
            "",
            "\t\t\tr = &type_b->regions[idx_b];",
            "\t\t\tr_start = idx_b ? r[-1].base + r[-1].size : 0;",
            "\t\t\tr_end = idx_b < type_b->cnt ?",
            "\t\t\t\tr->base : PHYS_ADDR_MAX;",
            "",
            "\t\t\t/*",
            "\t\t\t * if idx_b advanced past idx_a,",
            "\t\t\t * break out to advance idx_a",
            "\t\t\t */",
            "\t\t\tif (r_start >= m_end)",
            "\t\t\t\tbreak;",
            "\t\t\t/* if the two regions intersect, we're done */",
            "\t\t\tif (m_start < r_end) {",
            "\t\t\t\tif (out_start)",
            "\t\t\t\t\t*out_start =",
            "\t\t\t\t\t\tmax(m_start, r_start);",
            "\t\t\t\tif (out_end)",
            "\t\t\t\t\t*out_end = min(m_end, r_end);",
            "\t\t\t\tif (out_nid)",
            "\t\t\t\t\t*out_nid = m_nid;",
            "\t\t\t\t/*",
            "\t\t\t\t * The region which ends first is",
            "\t\t\t\t * advanced for the next iteration.",
            "\t\t\t\t */",
            "\t\t\t\tif (m_end <= r_end)",
            "\t\t\t\t\tidx_a++;",
            "\t\t\t\telse",
            "\t\t\t\t\tidx_b++;",
            "\t\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t/* signal end of iteration */",
            "\t*idx = ULLONG_MAX;",
            "}"
          ],
          "function_name": "memblock_mark_mirror, memblock_mark_nomap, memblock_clear_nomap, memblock_reserved_mark_noinit, memblock_mark_kho_scratch, memblock_clear_kho_scratch, should_skip_region, __next_mem_range",
          "description": "提供内存区域标记/清除接口，实现基于条件过滤的内存区域遍历逻辑，支持跳过特定属性（如非映射、非驱动管理等）的内存区域",
          "similarity": 0.6124774217605591
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memblock.c",
          "start_line": 537,
          "end_line": 685,
          "content": [
            "static void __init_memblock memblock_merge_regions(struct memblock_type *type,",
            "\t\t\t\t\t\t   unsigned long start_rgn,",
            "\t\t\t\t\t\t   unsigned long end_rgn)",
            "{",
            "\tint i = 0;",
            "\tif (start_rgn)",
            "\t\ti = start_rgn - 1;",
            "\tend_rgn = min(end_rgn, type->cnt - 1);",
            "\twhile (i < end_rgn) {",
            "\t\tstruct memblock_region *this = &type->regions[i];",
            "\t\tstruct memblock_region *next = &type->regions[i + 1];",
            "",
            "\t\tif (this->base + this->size != next->base ||",
            "\t\t    memblock_get_region_node(this) !=",
            "\t\t    memblock_get_region_node(next) ||",
            "\t\t    this->flags != next->flags) {",
            "\t\t\tBUG_ON(this->base + this->size > next->base);",
            "\t\t\ti++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tthis->size += next->size;",
            "\t\t/* move forward from next + 1, index of which is i + 2 */",
            "\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));",
            "\t\ttype->cnt--;",
            "\t\tend_rgn--;",
            "\t}",
            "}",
            "static void __init_memblock memblock_insert_region(struct memblock_type *type,",
            "\t\t\t\t\t\t   int idx, phys_addr_t base,",
            "\t\t\t\t\t\t   phys_addr_t size,",
            "\t\t\t\t\t\t   int nid,",
            "\t\t\t\t\t\t   enum memblock_flags flags)",
            "{",
            "\tstruct memblock_region *rgn = &type->regions[idx];",
            "",
            "\tBUG_ON(type->cnt >= type->max);",
            "\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));",
            "\trgn->base = base;",
            "\trgn->size = size;",
            "\trgn->flags = flags;",
            "\tmemblock_set_region_node(rgn, nid);",
            "\ttype->cnt++;",
            "\ttype->total_size += size;",
            "}",
            "static int __init_memblock memblock_add_range(struct memblock_type *type,",
            "\t\t\t\tphys_addr_t base, phys_addr_t size,",
            "\t\t\t\tint nid, enum memblock_flags flags)",
            "{",
            "\tbool insert = false;",
            "\tphys_addr_t obase = base;",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "\tint idx, nr_new, start_rgn = -1, end_rgn;",
            "\tstruct memblock_region *rgn;",
            "",
            "\tif (!size)",
            "\t\treturn 0;",
            "",
            "\t/* special case for empty array */",
            "\tif (type->regions[0].size == 0) {",
            "\t\tWARN_ON(type->cnt != 1 || type->total_size);",
            "\t\ttype->regions[0].base = base;",
            "\t\ttype->regions[0].size = size;",
            "\t\ttype->regions[0].flags = flags;",
            "\t\tmemblock_set_region_node(&type->regions[0], nid);",
            "\t\ttype->total_size = size;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * The worst case is when new range overlaps all existing regions,",
            "\t * then we'll need type->cnt + 1 empty regions in @type. So if",
            "\t * type->cnt * 2 + 1 is less than or equal to type->max, we know",
            "\t * that there is enough empty regions in @type, and we can insert",
            "\t * regions directly.",
            "\t */",
            "\tif (type->cnt * 2 + 1 <= type->max)",
            "\t\tinsert = true;",
            "",
            "repeat:",
            "\t/*",
            "\t * The following is executed twice.  Once with %false @insert and",
            "\t * then with %true.  The first counts the number of regions needed",
            "\t * to accommodate the new area.  The second actually inserts them.",
            "\t */",
            "\tbase = obase;",
            "\tnr_new = 0;",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tphys_addr_t rbase = rgn->base;",
            "\t\tphys_addr_t rend = rbase + rgn->size;",
            "",
            "\t\tif (rbase >= end)",
            "\t\t\tbreak;",
            "\t\tif (rend <= base)",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * @rgn overlaps.  If it separates the lower part of new",
            "\t\t * area, insert that portion.",
            "\t\t */",
            "\t\tif (rbase > base) {",
            "#ifdef CONFIG_NUMA",
            "\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));",
            "#endif",
            "\t\t\tWARN_ON(flags != MEMBLOCK_NONE && flags != rgn->flags);",
            "\t\t\tnr_new++;",
            "\t\t\tif (insert) {",
            "\t\t\t\tif (start_rgn == -1)",
            "\t\t\t\t\tstart_rgn = idx;",
            "\t\t\t\tend_rgn = idx + 1;",
            "\t\t\t\tmemblock_insert_region(type, idx++, base,",
            "\t\t\t\t\t\t       rbase - base, nid,",
            "\t\t\t\t\t\t       flags);",
            "\t\t\t}",
            "\t\t}",
            "\t\t/* area below @rend is dealt with, forget about it */",
            "\t\tbase = min(rend, end);",
            "\t}",
            "",
            "\t/* insert the remaining portion */",
            "\tif (base < end) {",
            "\t\tnr_new++;",
            "\t\tif (insert) {",
            "\t\t\tif (start_rgn == -1)",
            "\t\t\t\tstart_rgn = idx;",
            "\t\t\tend_rgn = idx + 1;",
            "\t\t\tmemblock_insert_region(type, idx, base, end - base,",
            "\t\t\t\t\t       nid, flags);",
            "\t\t}",
            "\t}",
            "",
            "\tif (!nr_new)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * If this was the first round, resize array and repeat for actual",
            "\t * insertions; otherwise, merge and return.",
            "\t */",
            "\tif (!insert) {",
            "\t\twhile (type->cnt + nr_new > type->max)",
            "\t\t\tif (memblock_double_array(type, obase, size) < 0)",
            "\t\t\t\treturn -ENOMEM;",
            "\t\tinsert = true;",
            "\t\tgoto repeat;",
            "\t} else {",
            "\t\tmemblock_merge_regions(type, start_rgn, end_rgn);",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "function_name": "memblock_merge_regions, memblock_insert_region, memblock_add_range",
          "description": "实现内存区域合并（merge_regions）与插入（insert_region）逻辑，处理新增内存范围的拆分与整合，优化连续区域管理。",
          "similarity": 0.6064697504043579
        }
      ]
    },
    {
      "source_file": "kernel/pid_sysctl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_sysctl.h`\n\n---\n\n# `pid_sysctl.h` 技术文档\n\n## 1. 文件概述\n\n`pid_sysctl.h` 是 Linux 内核中用于定义与 PID 命名空间（`pid_namespace`）相关的系统控制（sysctl）接口的头文件。其核心功能是提供对 `memfd_noexec` 系统策略的运行时配置支持，该策略用于控制通过 `memfd_create()` 创建的内存文件是否允许执行代码。该配置具有层级继承语义：子 PID 命名空间的策略不能比其父命名空间更宽松，以确保安全策略的向下兼容性和强制性。\n\n## 2. 核心功能\n\n### 函数\n\n- **`pid_mfd_noexec_dointvec_minmax`**  \n  自定义的 sysctl 处理函数，用于读写 `memfd_noexec` 策略值。在写入时执行权限检查和策略继承约束验证。\n\n- **`register_pid_ns_sysctl_table_vm`**  \n  内联函数，用于向内核 sysctl 子系统注册 `vm.memfd_noexec` 控制项（仅在 `CONFIG_SYSCTL` 和 `CONFIG_MEMFD_CREATE` 同时启用时有效）。\n\n### 数据结构\n\n- **`pid_ns_ctl_table_vm`**  \n  `ctl_table` 类型的静态数组，定义了 `vm.memfd_noexec` sysctl 条目，包括其名称、数据指针、访问权限、处理函数及取值范围（0 到 2）。\n\n## 3. 关键实现\n\n- **权限控制**：  \n  在写入 `memfd_noexec` 值时，调用 `ns_capable(ns->user_ns, CAP_SYS_ADMIN)` 检查当前任务是否在对应用户命名空间中拥有 `CAP_SYS_ADMIN` 能力，防止非特权用户修改安全策略。\n\n- **策略继承约束**：  \n  通过 `pidns_memfd_noexec_scope(ns->parent)` 获取父 PID 命名空间的策略值 `parent_scope`，并确保当前命名空间的策略值 `scope` 不小于父策略（即不能更宽松）。实际写入前使用 `max(READ_ONCE(ns->memfd_noexec_scope), parent_scope)` 保证该约束。\n\n- **原子读写**：  \n  使用 `READ_ONCE()` 和 `WRITE_ONCE()` 对 `ns->memfd_noexec_scope` 进行访问，确保在并发环境下内存访问的可见性和顺序性。\n\n- **sysctl 注册**：  \n  通过 `register_sysctl(\"vm\", pid_ns_ctl_table_vm)` 将控制项注册到 `/proc/sys/vm/memfd_noexec` 路径下，供用户空间通过标准 sysctl 接口访问。\n\n- **条件编译**：  \n  整个功能仅在 `CONFIG_SYSCTL`（启用 sysctl 支持）和 `CONFIG_MEMFD_CREATE`（启用 memfd_create 系统调用）同时配置时编译，否则 `register_pid_ns_sysctl_table_vm` 为空内联函数，避免代码膨胀。\n\n## 4. 依赖关系\n\n- **`<linux/pid_namespace.h>`**：  \n  提供 `struct pid_namespace` 定义及辅助函数如 `task_active_pid_ns()` 和 `pidns_memfd_noexec_scope()`。\n\n- **`CONFIG_SYSCTL`**：  \n  内核配置选项，启用 sysctl 框架支持，提供 `register_sysctl`、`proc_dointvec_minmax` 等接口。\n\n- **`CONFIG_MEMFD_CREATE`**：  \n  内核配置选项，启用 `memfd_create()` 系统调用及相关功能（如 `memfd_noexec_scope` 字段）。\n\n- **能力子系统（Capabilities）**：  \n  依赖 `ns_capable()` 进行命名空间感知的权限检查。\n\n## 5. 使用场景\n\n- **安全策略配置**：  \n  系统管理员或容器运行时可通过写入 `/proc/sys/vm/memfd_noexec` 设置当前 PID 命名空间中 `memfd` 文件的执行限制级别（0=允许执行，1=禁止执行但可覆盖，2=严格禁止执行），用于防御基于内存文件的代码注入攻击。\n\n- **容器隔离**：  \n  在容器化环境中，不同容器运行在独立的 PID 命名空间中。父命名空间（如宿主机）可设置较严格的 `memfd_noexec` 策略，子容器无法降低该策略级别，从而实现自上而下的安全策略强制。\n\n- **运行时动态调整**：  \n  允许在系统运行期间动态调整 `memfd` 执行策略，无需重启或重新加载内核模块，提升系统灵活性与安全性。",
      "similarity": 0.6284199953079224,
      "chunks": []
    },
    {
      "source_file": "kernel/range.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `range.c`\n\n---\n\n# range.c 技术文档\n\n## 1. 文件概述\n\n`range.c` 是 Linux 内核中用于管理地址范围（range）集合的核心工具文件。它提供了一组操作函数，用于动态地添加、合并、删除和排序不连续的地址区间（通常表示物理内存或 I/O 地址范围）。这些操作在内存管理、资源分配、NUMA 拓扑构建等场景中被广泛使用，尤其适用于需要维护非重叠、有序地址区间的子系统。\n\n## 2. 核心功能\n\n### 数据结构\n- `struct range`：表示一个地址区间，包含 `start`（起始地址）和 `end`（结束地址，不包含）两个 `u64` 字段。\n\n### 主要函数\n- `int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)`  \n  向范围数组中添加一个新的区间，不进行合并。\n- `int add_range_with_merge(struct range *range, int az, int nr_range, u64 start, u64 end)`  \n  添加新区间，并自动与已有区间合并重叠或相邻的部分。\n- `void subtract_range(struct range *range, int az, u64 start, u64 end)`  \n  从现有范围中减去指定区间，可能将一个区间拆分为两个。\n- `int clean_sort_range(struct range *range, int az)`  \n  清理数组中无效（`end == 0`）的条目，压缩有效区间到数组前端，并按起始地址排序，返回有效区间数量。\n- `void sort_range(struct range *range, int nr_range)`  \n  对指定数量的区间按起始地址进行排序。\n\n## 3. 关键实现\n\n### 区间合并逻辑（`add_range_with_merge`）\n1. 首先检查输入区间是否有效（`start < end`）。\n2. 遍历现有所有有效区间，查找与新区间有交集的部分：\n   - 若存在交集，则扩展新区间的 `start` 和 `end` 以覆盖合并后的范围。\n   - 将被合并的旧区间从数组中移除（通过 `memmove` 前移后续元素，并将末尾置零）。\n   - 由于移除了元素，需将索引 `i` 减 1 以重新检查当前位置。\n3. 最终将合并后的新区间通过 `add_range` 添加到数组末尾。\n\n### 区间相减逻辑（`subtract_range`）\n处理四种相交情况：\n1. **完全覆盖**：待减区间完全包含目标区间 → 将目标区间置为无效（`start = end = 0`）。\n2. **左覆盖**：待减区间覆盖目标区间的左部 → 将目标区间起始地址更新为 `end`。\n3. **右覆盖**：待减区间覆盖目标区间的右部 → 将目标区间结束地址更新为 `start`。\n4. **中间挖洞**：待减区间位于目标区间内部 → 将原区间拆分为两段：\n   - 原区间保留左段（`[start, subtract_start)`）。\n   - 在数组中寻找空闲槽位（`end == 0`），插入右段（`[subtract_end, original_end)`）。\n   - 若无空闲槽位，打印错误日志。\n\n### 数组清理与排序（`clean_sort_range`）\n- 采用双指针法：从前往后找无效项，从后往前找有效项，进行交换，将所有有效区间压缩到数组前端。\n- 遍历压缩后的数组，统计有效区间数量（首个 `end == 0` 的位置）。\n- 使用内核 `sort()` 函数按 `start` 升序排列有效区间。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/range.h>`：定义 `struct range`。\n  - `<linux/sort.h>`：提供 `sort()` 排序函数。\n  - `<linux/minmax.h>`：提供 `min()`/`max()` 宏。\n  - `<linux/printk.h>`：用于错误日志输出。\n  - `<linux/string.h>`：提供 `memmove()`。\n  - `<linux/init.h>`：可能用于初始化上下文（尽管本文件未直接使用初始化宏）。\n- **无外部模块依赖**：该文件为通用工具库，被多个内核子系统（如 `e820`、`memblock`、`ACPI`、`NUMA` 初始化等）直接调用。\n\n## 5. 使用场景\n\n- **物理内存布局管理**：在启动早期，通过 `e820` 或 `EFI` 获取物理内存范围后，使用 `add_range_with_merge` 合并连续内存块。\n- **内存热插拔/热移除**：动态调整可用内存范围时，使用 `subtract_range` 移除故障或离线内存区域。\n- **I/O 资源分配**：管理 PCI 或平台设备的 I/O 地址空间，避免冲突。\n- **NUMA 节点拓扑构建**：在解析 SRAT 表时，合并属于同一节点的内存范围。\n- **内核参数处理**：如 `mem=` 或 `memmap=` 参数指定的内存保留/排除区域，需与系统内存范围进行加减运算。\n- **资源冲突检测**：在设备枚举过程中，通过区间运算判断资源是否重叠。",
      "similarity": 0.6223821640014648,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/range.c",
          "start_line": 126,
          "end_line": 164,
          "content": [
            "int clean_sort_range(struct range *range, int az)",
            "{",
            "\tint i, j, k = az - 1, nr_range = az;",
            "",
            "\tfor (i = 0; i < k; i++) {",
            "\t\tif (range[i].end)",
            "\t\t\tcontinue;",
            "\t\tfor (j = k; j > i; j--) {",
            "\t\t\tif (range[j].end) {",
            "\t\t\t\tk = j;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (j == i)",
            "\t\t\tbreak;",
            "\t\trange[i].start = range[k].start;",
            "\t\trange[i].end   = range[k].end;",
            "\t\trange[k].start = 0;",
            "\t\trange[k].end   = 0;",
            "\t\tk--;",
            "\t}",
            "\t/* count it */",
            "\tfor (i = 0; i < az; i++) {",
            "\t\tif (!range[i].end) {",
            "\t\t\tnr_range = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\t/* sort them */",
            "\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);",
            "",
            "\treturn nr_range;",
            "}",
            "void sort_range(struct range *range, int nr_range)",
            "{",
            "\t/* sort them */",
            "\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);",
            "}"
          ],
          "function_name": "clean_sort_range, sort_range",
          "description": "clean_sort_range清理空闲范围槽位并排序有效区间，sort_range直接对有效范围数组进行排序，通过cmp_range保证区间按起始地址升序排列。",
          "similarity": 0.4856295585632324
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/range.c",
          "start_line": 12,
          "end_line": 121,
          "content": [
            "int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)",
            "{",
            "\tif (start >= end)",
            "\t\treturn nr_range;",
            "",
            "\t/* Out of slots: */",
            "\tif (nr_range >= az)",
            "\t\treturn nr_range;",
            "",
            "\trange[nr_range].start = start;",
            "\trange[nr_range].end = end;",
            "",
            "\tnr_range++;",
            "",
            "\treturn nr_range;",
            "}",
            "int add_range_with_merge(struct range *range, int az, int nr_range,",
            "\t\t     u64 start, u64 end)",
            "{",
            "\tint i;",
            "",
            "\tif (start >= end)",
            "\t\treturn nr_range;",
            "",
            "\t/* get new start/end: */",
            "\tfor (i = 0; i < nr_range; i++) {",
            "\t\tu64 common_start, common_end;",
            "",
            "\t\tif (!range[i].end)",
            "\t\t\tcontinue;",
            "",
            "\t\tcommon_start = max(range[i].start, start);",
            "\t\tcommon_end = min(range[i].end, end);",
            "\t\tif (common_start > common_end)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* new start/end, will add it back at last */",
            "\t\tstart = min(range[i].start, start);",
            "\t\tend = max(range[i].end, end);",
            "",
            "\t\tmemmove(&range[i], &range[i + 1],",
            "\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));",
            "\t\trange[nr_range - 1].start = 0;",
            "\t\trange[nr_range - 1].end   = 0;",
            "\t\tnr_range--;",
            "\t\ti--;",
            "\t}",
            "",
            "\t/* Need to add it: */",
            "\treturn add_range(range, az, nr_range, start, end);",
            "}",
            "void subtract_range(struct range *range, int az, u64 start, u64 end)",
            "{",
            "\tint i, j;",
            "",
            "\tif (start >= end)",
            "\t\treturn;",
            "",
            "\tfor (j = 0; j < az; j++) {",
            "\t\tif (!range[j].end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start <= range[j].start && end >= range[j].end) {",
            "\t\t\trange[j].start = 0;",
            "\t\t\trange[j].end = 0;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (start <= range[j].start && end < range[j].end &&",
            "\t\t    range[j].start < end) {",
            "\t\t\trange[j].start = end;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "",
            "\t\tif (start > range[j].start && end >= range[j].end &&",
            "\t\t    range[j].end > start) {",
            "\t\t\trange[j].end = start;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (start > range[j].start && end < range[j].end) {",
            "\t\t\t/* Find the new spare: */",
            "\t\t\tfor (i = 0; i < az; i++) {",
            "\t\t\t\tif (range[i].end == 0)",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif (i < az) {",
            "\t\t\t\trange[i].end = range[j].end;",
            "\t\t\t\trange[i].start = end;",
            "\t\t\t} else {",
            "\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",",
            "\t\t\t\t\t__func__);",
            "\t\t\t}",
            "\t\t\trange[j].end = start;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t}",
            "}",
            "static int cmp_range(const void *x1, const void *x2)",
            "{",
            "\tconst struct range *r1 = x1;",
            "\tconst struct range *r2 = x2;",
            "",
            "\tif (r1->start < r2->start)",
            "\t\treturn -1;",
            "\tif (r1->start > r2->start)",
            "\t\treturn 1;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "add_range, add_range_with_merge, subtract_range, cmp_range",
          "description": "实现范围添加与合并操作，add_range将新区间追加至数组，add_range_with_merge合并重叠区间并通过memmove优化存储，subtract_range执行区间差集计算，cmp_range用于范围排序比较。",
          "similarity": 0.4744690954685211
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/range.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Range add and subtract",
            " */",
            "#include <linux/init.h>",
            "#include <linux/minmax.h>",
            "#include <linux/printk.h>",
            "#include <linux/sort.h>",
            "#include <linux/string.h>",
            "#include <linux/range.h>",
            ""
          ],
          "function_name": null,
          "description": "定义范围操作模块的头文件，包含GPL-2.0许可证声明及基础依赖项，为后续范围运算提供类型和宏定义支持。",
          "similarity": 0.4346736669540405
        }
      ]
    }
  ]
}