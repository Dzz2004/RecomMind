{
  "query": "Linux内核进程创建流程详解",
  "timestamp": "2025-12-26 00:39:01",
  "retrieved_files": [
    {
      "source_file": "kernel/fork.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:30:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fork.c`\n\n---\n\n# fork.c 技术文档\n\n## 1. 文件概述\n\n`fork.c` 是 Linux 内核中实现进程创建（fork）系统调用的核心源文件。该文件包含了创建新进程所需的所有辅助例程，负责复制父进程的资源（如内存、文件描述符、信号处理等）以生成子进程。虽然 fork 逻辑本身概念简单，但其涉及的内存管理（尤其是写时复制 COW 机制）极为复杂，实际内存页的复制由 `mm/memory.c` 中的 `copy_page_range()` 等函数处理。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `total_forks`: 累计系统自启动以来创建的进程总数\n- `nr_threads`: 当前系统中的线程总数（不包括 idle 线程）\n- `max_threads`: 可配置的线程数量上限（默认为 `FUTEX_TID_MASK`）\n- `process_counts`: 每 CPU 的进程计数器（per-CPU 变量）\n- `tasklist_lock`: 保护任务链表的读写锁（全局任务列表的同步原语）\n\n### 关键辅助函数\n- `nr_processes()`: 计算系统中所有进程的总数（聚合各 CPU 的 `process_counts`）\n- `arch_release_task_struct()`: 架构相关的 task_struct 释放钩子（弱符号，默认为空）\n- `alloc_task_struct_node()` / `free_task_struct()`: 分配/释放 `task_struct` 结构（基于 slab 分配器）\n- `alloc_thread_stack_node()` / `thread_stack_delayed_free()`: 分配/延迟释放线程内核栈（支持 `CONFIG_VMAP_STACK`）\n\n### 核心数据结构\n- `resident_page_types[]`: 用于内存统计的页面类型名称映射数组\n- `vm_stack`: 用于 RCU 延迟释放的虚拟内存栈封装结构\n- `cached_stacks[NR_CACHED_STACKS]`: 每 CPU 的内核栈缓存（减少频繁 vmalloc/vfree 开销）\n\n## 3. 关键实现\n\n### 进程/线程计数管理\n- 使用 per-CPU 变量 `process_counts` 避免全局锁竞争\n- 全局计数器 `nr_threads` 和 `total_forks` 由 `tasklist_lock` 保护\n- `nr_processes()` 通过遍历所有可能的 CPU 聚合计数\n\n### 内核栈分配策略（`CONFIG_VMAP_STACK`）\n- **缓存机制**：每个 CPU 缓存最多 2 个已释放的栈（`NR_CACHED_STACKS`），减少 TLB 刷新和 vmalloc 开销\n- **内存分配**：\n  - 优先从本地缓存获取栈\n  - 缓存未命中时使用 `__vmalloc_node_range()` 分配连续虚拟地址空间\n  - 显式禁用 `__GFP_ACCOUNT`（因后续手动进行 memcg 计费）\n- **安全清理**：\n  - 重用栈时清零内存（`memset(stack, 0, THREAD_SIZE)`）\n  - KASAN 消毒（`kasan_unpoison_range`）和标签重置\n- **延迟释放**：\n  - 通过 RCU 机制延迟释放栈（`call_rcu`）\n  - 释放时尝试回填缓存，失败则直接 `vfree`\n\n### 内存控制组（memcg）集成\n- 手动对栈的每个物理页进行 memcg 计费（`memcg_kmem_charge_page`）\n- 计费失败时回滚已计费页面（`memcg_kmem_uncharge_page`）\n- 确保内核栈内存纳入 cgroup 内存限制\n\n### 锁与同步\n- `tasklist_lock` 作为全局任务列表的保护锁（读写锁）\n- 提供 `lockdep_tasklist_lock_is_held()` 供 RCU 锁验证使用\n- RCU 用于安全延迟释放内核栈资源\n\n## 4. 依赖关系\n\n### 内核子系统依赖\n- **内存管理 (MM)**：`<linux/mm.h>`, `<linux/vmalloc.h>`, `<linux/memcontrol.h>`\n- **调度器 (Scheduler)**：`<linux/sched/*.h>`, 任务状态和 CPU 绑定\n- **安全模块**：`<linux/security.h>`, `<linux/capability.h>`, `<linux/seccomp.h>`\n- **命名空间**：`<linux/nsproxy.h>`（UTS, IPC, PID, 网络等）\n- **文件系统**：`<linux/fs.h>`, `<linux/fdtable.h>`（文件描述符复制）\n- **跟踪与调试**：`<trace/events/sched.h>`, `<linux/ftrace.h>`, KASAN/KMSAN\n\n### 架构相关依赖\n- `<asm/pgalloc.h>`：页表分配\n- `<asm/mmu_context.h>`：MMU 上下文切换\n- `<asm/tlbflush.h>`：TLB 刷新操作\n- 架构特定的 `THREAD_SIZE` 和栈对齐要求\n\n### 配置选项依赖\n- `CONFIG_VMAP_STACK`：启用虚拟内存分配内核栈\n- `CONFIG_PROVE_RCU`：RCU 锁验证支持\n- `CONFIG_ARCH_TASK_STRUCT_ALLOCATOR`：架构自定义 task_struct 分配器\n- `CONFIG_MEMCG_KMEM`：内核内存 cgroup 支持\n\n## 5. 使用场景\n\n### 进程创建路径\n- **系统调用入口**：`sys_fork()`, `sys_vfork()`, `sys_clone()` 最终调用 `_do_fork()`\n- **内核线程创建**：`kthread_create()` 通过 `kernel_thread()` 触发 fork 逻辑\n- **容器/命名空间初始化**：新 PID/UTS/IPC 命名空间创建时伴随进程 fork\n\n### 资源复制关键点\n- **内存描述符 (mm_struct)**：通过 `dup_mm()` 复制地址空间（COW 页表）\n- **文件描述符表**：`dup_fd()` 复制打开文件表\n- **信号处理**：复制信号掩码和处理函数\n- **POSIX 定时器/异步 I/O**：复制相关上下文（如 `aio`, `posix-timers`）\n\n### 特殊场景处理\n- **写时复制优化**：避免物理内存立即复制，提升 fork 性能\n- **OOM Killer 集成**：在内存不足时参与进程选择\n- **审计与监控**：通过 `audit_alloc()` 和 `proc` 文件系统暴露进程信息\n- **实时性保障**：RT 任务 fork 时保持调度策略和优先级",
      "similarity": 0.7034443020820618,
      "chunks": [
        {
          "chunk_id": 12,
          "file_path": "kernel/fork.c",
          "start_line": 2176,
          "end_line": 2282,
          "content": [
            "static void rv_task_fork(struct task_struct *p)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++)",
            "\t\tp->rv[i].da_mon.monitoring = false;",
            "}",
            "static inline void init_idle_pids(struct task_struct *idle)",
            "{",
            "\tenum pid_type type;",
            "",
            "\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {",
            "\t\tINIT_HLIST_NODE(&idle->pid_links[type]); /* not really needed */",
            "\t\tinit_task_pid(idle, type, &init_struct_pid);",
            "\t}",
            "}",
            "static int idle_dummy(void *dummy)",
            "{",
            "\t/* This function is never called */",
            "\treturn 0;",
            "}",
            "pid_t kernel_clone(struct kernel_clone_args *args)",
            "{",
            "\tu64 clone_flags = args->flags;",
            "\tstruct completion vfork;",
            "\tstruct pid *pid;",
            "\tstruct task_struct *p;",
            "\tint trace = 0;",
            "\tpid_t nr;",
            "",
            "\t/*",
            "\t * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument",
            "\t * to return the pidfd. Hence, CLONE_PIDFD and CLONE_PARENT_SETTID are",
            "\t * mutually exclusive. With clone3() CLONE_PIDFD has grown a separate",
            "\t * field in struct clone_args and it still doesn't make sense to have",
            "\t * them both point at the same memory location. Performing this check",
            "\t * here has the advantage that we don't need to have a separate helper",
            "\t * to check for legacy clone().",
            "\t */",
            "\tif ((args->flags & CLONE_PIDFD) &&",
            "\t    (args->flags & CLONE_PARENT_SETTID) &&",
            "\t    (args->pidfd == args->parent_tid))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Determine whether and which event to report to ptracer.  When",
            "\t * called from kernel_thread or CLONE_UNTRACED is explicitly",
            "\t * requested, no event is reported; otherwise, report if the event",
            "\t * for the type of forking is enabled.",
            "\t */",
            "\tif (!(clone_flags & CLONE_UNTRACED)) {",
            "\t\tif (clone_flags & CLONE_VFORK)",
            "\t\t\ttrace = PTRACE_EVENT_VFORK;",
            "\t\telse if (args->exit_signal != SIGCHLD)",
            "\t\t\ttrace = PTRACE_EVENT_CLONE;",
            "\t\telse",
            "\t\t\ttrace = PTRACE_EVENT_FORK;",
            "",
            "\t\tif (likely(!ptrace_event_enabled(current, trace)))",
            "\t\t\ttrace = 0;",
            "\t}",
            "",
            "\tp = copy_process(NULL, trace, NUMA_NO_NODE, args);",
            "\tadd_latent_entropy();",
            "",
            "\tif (IS_ERR(p))",
            "\t\treturn PTR_ERR(p);",
            "",
            "\t/*",
            "\t * Do this prior waking up the new thread - the thread pointer",
            "\t * might get invalid after that point, if the thread exits quickly.",
            "\t */",
            "\ttrace_sched_process_fork(current, p);",
            "",
            "\tpid = get_task_pid(p, PIDTYPE_PID);",
            "\tnr = pid_vnr(pid);",
            "",
            "\tif (clone_flags & CLONE_PARENT_SETTID)",
            "\t\tput_user(nr, args->parent_tid);",
            "",
            "\tif (clone_flags & CLONE_VFORK) {",
            "\t\tp->vfork_done = &vfork;",
            "\t\tinit_completion(&vfork);",
            "\t\tget_task_struct(p);",
            "\t}",
            "",
            "\tif (IS_ENABLED(CONFIG_LRU_GEN_WALKS_MMU) && !(clone_flags & CLONE_VM)) {",
            "\t\t/* lock the task to synchronize with memcg migration */",
            "\t\ttask_lock(p);",
            "\t\tlru_gen_add_mm(p->mm);",
            "\t\ttask_unlock(p);",
            "\t}",
            "",
            "\twake_up_new_task(p);",
            "",
            "\t/* forking complete and child started to run, tell ptracer */",
            "\tif (unlikely(trace))",
            "\t\tptrace_event_pid(trace, pid);",
            "",
            "\tif (clone_flags & CLONE_VFORK) {",
            "\t\tif (!wait_for_vfork_done(p, &vfork))",
            "\t\t\tptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);",
            "\t}",
            "",
            "\tput_pid(pid);",
            "\treturn nr;",
            "}"
          ],
          "function_name": "rv_task_fork, init_idle_pids, idle_dummy, kernel_clone",
          "description": "实现kernel_clone核心逻辑，创建新进程并处理克隆标志，管理子进程启动、vfork等待及进程树遍历，包含空闲任务PID初始化与RV监控器重置",
          "similarity": 0.6055753231048584
        },
        {
          "chunk_id": 13,
          "file_path": "kernel/fork.c",
          "start_line": 2924,
          "end_line": 3037,
          "content": [
            "pid_t kernel_thread(int (*fn)(void *), void *arg, const char *name,",
            "\t\t    unsigned long flags)",
            "{",
            "\tstruct kernel_clone_args args = {",
            "\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |",
            "\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),",
            "\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),",
            "\t\t.fn\t\t= fn,",
            "\t\t.fn_arg\t\t= arg,",
            "\t\t.name\t\t= name,",
            "\t\t.kthread\t= 1,",
            "\t};",
            "",
            "\treturn kernel_clone(&args);",
            "}",
            "pid_t user_mode_thread(int (*fn)(void *), void *arg, unsigned long flags)",
            "{",
            "\tstruct kernel_clone_args args = {",
            "\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |",
            "\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),",
            "\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),",
            "\t\t.fn\t\t= fn,",
            "\t\t.fn_arg\t\t= arg,",
            "\t};",
            "",
            "\treturn kernel_clone(&args);",
            "}",
            "noinline static int copy_clone_args_from_user(struct kernel_clone_args *kargs,",
            "\t\t\t\t\t      struct clone_args __user *uargs,",
            "\t\t\t\t\t      size_t usize)",
            "{",
            "\tint err;",
            "\tstruct clone_args args;",
            "\tpid_t *kset_tid = kargs->set_tid;",
            "",
            "\tBUILD_BUG_ON(offsetofend(struct clone_args, tls) !=",
            "\t\t     CLONE_ARGS_SIZE_VER0);",
            "\tBUILD_BUG_ON(offsetofend(struct clone_args, set_tid_size) !=",
            "\t\t     CLONE_ARGS_SIZE_VER1);",
            "\tBUILD_BUG_ON(offsetofend(struct clone_args, cgroup) !=",
            "\t\t     CLONE_ARGS_SIZE_VER2);",
            "\tBUILD_BUG_ON(sizeof(struct clone_args) != CLONE_ARGS_SIZE_VER2);",
            "",
            "\tif (unlikely(usize > PAGE_SIZE))",
            "\t\treturn -E2BIG;",
            "\tif (unlikely(usize < CLONE_ARGS_SIZE_VER0))",
            "\t\treturn -EINVAL;",
            "",
            "\terr = copy_struct_from_user(&args, sizeof(args), uargs, usize);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (unlikely(args.set_tid_size > MAX_PID_NS_LEVEL))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(!args.set_tid && args.set_tid_size > 0))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(args.set_tid && args.set_tid_size == 0))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Verify that higher 32bits of exit_signal are unset and that",
            "\t * it is a valid signal",
            "\t */",
            "\tif (unlikely((args.exit_signal & ~((u64)CSIGNAL)) ||",
            "\t\t     !valid_signal(args.exit_signal)))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((args.flags & CLONE_INTO_CGROUP) &&",
            "\t    (args.cgroup > INT_MAX || usize < CLONE_ARGS_SIZE_VER2))",
            "\t\treturn -EINVAL;",
            "",
            "\t*kargs = (struct kernel_clone_args){",
            "\t\t.flags\t\t= args.flags,",
            "\t\t.pidfd\t\t= u64_to_user_ptr(args.pidfd),",
            "\t\t.child_tid\t= u64_to_user_ptr(args.child_tid),",
            "\t\t.parent_tid\t= u64_to_user_ptr(args.parent_tid),",
            "\t\t.exit_signal\t= args.exit_signal,",
            "\t\t.stack\t\t= args.stack,",
            "\t\t.stack_size\t= args.stack_size,",
            "\t\t.tls\t\t= args.tls,",
            "\t\t.set_tid_size\t= args.set_tid_size,",
            "\t\t.cgroup\t\t= args.cgroup,",
            "\t};",
            "",
            "\tif (args.set_tid &&",
            "\t\tcopy_from_user(kset_tid, u64_to_user_ptr(args.set_tid),",
            "\t\t\t(kargs->set_tid_size * sizeof(pid_t))))",
            "\t\treturn -EFAULT;",
            "",
            "\tkargs->set_tid = kset_tid;",
            "",
            "\treturn 0;",
            "}",
            "static inline bool clone3_stack_valid(struct kernel_clone_args *kargs)",
            "{",
            "\tif (kargs->stack == 0) {",
            "\t\tif (kargs->stack_size > 0)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\tif (kargs->stack_size == 0)",
            "\t\t\treturn false;",
            "",
            "\t\tif (!access_ok((void __user *)kargs->stack, kargs->stack_size))",
            "\t\t\treturn false;",
            "",
            "#if !defined(CONFIG_STACK_GROWSUP)",
            "\t\tkargs->stack += kargs->stack_size;",
            "#endif",
            "\t}",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "kernel_thread, user_mode_thread, copy_clone_args_from_user, clone3_stack_valid",
          "description": "提供内核线程与用户线程创建接口，解析并验证clone3参数，转换用户空间clone_args到内核结构体，校验栈地址有效性",
          "similarity": 0.5860319137573242
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/fork.c",
          "start_line": 666,
          "end_line": 845,
          "content": [
            "static __latent_entropy int dup_mmap(struct mm_struct *mm,",
            "\t\t\t\t\tstruct mm_struct *oldmm)",
            "{",
            "\tstruct vm_area_struct *mpnt, *tmp;",
            "\tint retval;",
            "\tunsigned long charge = 0;",
            "\tLIST_HEAD(uf);",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\tuprobe_start_dup_mmap();",
            "\tif (mmap_write_lock_killable(oldmm)) {",
            "\t\tretval = -EINTR;",
            "\t\tgoto fail_uprobe_end;",
            "\t}",
            "\tflush_cache_dup_mm(oldmm);",
            "\tuprobe_dup_mmap(oldmm, mm);",
            "\t/*",
            "\t * Not linked in yet - no deadlock potential:",
            "\t */",
            "\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);",
            "",
            "\t/* No ordering required: file already has been exposed. */",
            "\tdup_mm_exe_file(mm, oldmm);",
            "",
            "\tmm->total_vm = oldmm->total_vm;",
            "\tmm->data_vm = oldmm->data_vm;",
            "\tmm->exec_vm = oldmm->exec_vm;",
            "\tmm->stack_vm = oldmm->stack_vm;",
            "",
            "\t/* Use __mt_dup() to efficiently build an identical maple tree. */",
            "\tretval = __mt_dup(&oldmm->mm_mt, &mm->mm_mt, GFP_KERNEL);",
            "\tif (unlikely(retval))",
            "\t\tgoto out;",
            "",
            "\tmt_clear_in_rcu(vmi.mas.tree);",
            "\tfor_each_vma(vmi, mpnt) {",
            "\t\tstruct file *file;",
            "",
            "\t\tvma_start_write(mpnt);",
            "\t\tif (mpnt->vm_flags & VM_DONTCOPY) {",
            "\t\t\tretval = vma_iter_clear_gfp(&vmi, mpnt->vm_start,",
            "\t\t\t\t\t\t    mpnt->vm_end, GFP_KERNEL);",
            "\t\t\tif (retval)",
            "\t\t\t\tgoto loop_out;",
            "",
            "\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tcharge = 0;",
            "\t\t/*",
            "\t\t * Don't duplicate many vmas if we've been oom-killed (for",
            "\t\t * example)",
            "\t\t */",
            "\t\tif (fatal_signal_pending(current)) {",
            "\t\t\tretval = -EINTR;",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t\tif (mpnt->vm_flags & VM_ACCOUNT) {",
            "\t\t\tunsigned long len = vma_pages(mpnt);",
            "",
            "\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */",
            "\t\t\t\tgoto fail_nomem;",
            "\t\t\tcharge = len;",
            "\t\t}",
            "\t\ttmp = vm_area_dup(mpnt);",
            "\t\tif (!tmp)",
            "\t\t\tgoto fail_nomem;",
            "",
            "\t\t/* track_pfn_copy() will later take care of copying internal state. */",
            "\t\tif (unlikely(tmp->vm_flags & VM_PFNMAP))",
            "\t\t\tuntrack_pfn_clear(tmp);",
            "",
            "\t\tretval = vma_dup_policy(mpnt, tmp);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_policy;",
            "\t\ttmp->vm_mm = mm;",
            "\t\tretval = dup_userfaultfd(tmp, &uf);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tif (tmp->vm_flags & VM_WIPEONFORK) {",
            "\t\t\t/*",
            "\t\t\t * VM_WIPEONFORK gets a clean slate in the child.",
            "\t\t\t * Don't prepare anon_vma until fault since we don't",
            "\t\t\t * copy page for current vma.",
            "\t\t\t */",
            "\t\t\ttmp->anon_vma = NULL;",
            "\t\t} else if (anon_vma_fork(tmp, mpnt))",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tvm_flags_clear(tmp, VM_LOCKED_MASK);",
            "\t\tfile = tmp->vm_file;",
            "\t\tif (file) {",
            "\t\t\tstruct address_space *mapping = file->f_mapping;",
            "",
            "\t\t\tget_file(file);",
            "\t\t\ti_mmap_lock_write(mapping);",
            "\t\t\tif (vma_is_shared_maywrite(tmp))",
            "\t\t\t\tmapping_allow_writable(mapping);",
            "\t\t\tflush_dcache_mmap_lock(mapping);",
            "\t\t\t/* insert tmp into the share list, just after mpnt */",
            "\t\t\tvma_interval_tree_insert_after(tmp, mpnt,",
            "\t\t\t\t\t&mapping->i_mmap);",
            "\t\t\tflush_dcache_mmap_unlock(mapping);",
            "\t\t\ti_mmap_unlock_write(mapping);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Copy/update hugetlb private vma information.",
            "\t\t */",
            "\t\tif (is_vm_hugetlb_page(tmp))",
            "\t\t\thugetlb_dup_vma_private(tmp);",
            "",
            "\t\t/*",
            "\t\t * Link the vma into the MT. After using __mt_dup(), memory",
            "\t\t * allocation is not necessary here, so it cannot fail.",
            "\t\t */",
            "\t\tvma_iter_bulk_store(&vmi, tmp);",
            "",
            "\t\tmm->map_count++;",
            "\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))",
            "\t\t\tretval = copy_page_range(tmp, mpnt);",
            "",
            "\t\tif (tmp->vm_ops && tmp->vm_ops->open)",
            "\t\t\ttmp->vm_ops->open(tmp);",
            "",
            "\t\tif (retval) {",
            "\t\t\tmpnt = vma_next(&vmi);",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t}",
            "\t/* a new mm has just been created */",
            "\tretval = arch_dup_mmap(oldmm, mm);",
            "loop_out:",
            "\tvma_iter_free(&vmi);",
            "\tif (!retval) {",
            "\t\tmt_set_in_rcu(vmi.mas.tree);",
            "\t\tksm_fork(mm, oldmm);",
            "\t\tkhugepaged_fork(mm, oldmm);",
            "\t} else {",
            "",
            "\t\t/*",
            "\t\t * The entire maple tree has already been duplicated. If the",
            "\t\t * mmap duplication fails, mark the failure point with",
            "\t\t * XA_ZERO_ENTRY. In exit_mmap(), if this marker is encountered,",
            "\t\t * stop releasing VMAs that have not been duplicated after this",
            "\t\t * point.",
            "\t\t */",
            "\t\tif (mpnt) {",
            "\t\t\tmas_set_range(&vmi.mas, mpnt->vm_start, mpnt->vm_end - 1);",
            "\t\t\tmas_store(&vmi.mas, XA_ZERO_ENTRY);",
            "\t\t\t/* Avoid OOM iterating a broken tree */",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t}",
            "\t\t/*",
            "\t\t * The mm_struct is going to exit, but the locks will be dropped",
            "\t\t * first.  Set the mm_struct as unstable is advisable as it is",
            "\t\t * not fully initialised.",
            "\t\t */",
            "\t\tset_bit(MMF_UNSTABLE, &mm->flags);",
            "\t}",
            "out:",
            "\tmmap_write_unlock(mm);",
            "\tflush_tlb_mm(oldmm);",
            "\tmmap_write_unlock(oldmm);",
            "\tif (!retval)",
            "\t\tdup_userfaultfd_complete(&uf);",
            "\telse",
            "\t\tdup_userfaultfd_fail(&uf);",
            "fail_uprobe_end:",
            "\tuprobe_end_dup_mmap();",
            "\treturn retval;",
            "",
            "fail_nomem_anon_vma_fork:",
            "\tmpol_put(vma_policy(tmp));",
            "fail_nomem_policy:",
            "\tvm_area_free(tmp);",
            "fail_nomem:",
            "\tretval = -ENOMEM;",
            "\tvm_unacct_memory(charge);",
            "\tgoto loop_out;",
            "}"
          ],
          "function_name": "dup_mmap",
          "description": "实现进程fork时的内存映射复制逻辑，深度遍历原进程的VMA结构创建副本，处理共享文件映射、hugetlb页等特殊内存类型，并管理OOM异常情况下的失败恢复。",
          "similarity": 0.5550047159194946
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/fork.c",
          "start_line": 1,
          "end_line": 158,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/fork.c",
            " *",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " */",
            "",
            "/*",
            " *  'fork.c' contains the help-routines for the 'fork' system call",
            " * (see also entry.S and others).",
            " * Fork is rather simple, once you get the hang of it, but the memory",
            " * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'",
            " */",
            "",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/ext.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/init.h>",
            "#include <linux/unistd.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/completion.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/sem.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/key.h>",
            "#include <linux/kmsan.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/mman.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memblock.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/capability.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/security.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/futex.h>",
            "#include <linux/compat.h>",
            "#include <linux/kthread.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/mount.h>",
            "#include <linux/audit.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/profile.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/acct.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/magic.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/oom.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/aio.h>",
            "#include <linux/compiler.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/kcov.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/scs.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/bpf.h>",
            "#include <linux/stackprotector.h>",
            "#include <linux/user_events.h>",
            "#include <linux/iommu.h>",
            "#include <linux/rseq.h>",
            "#include <uapi/linux/pidfd.h>",
            "#include <linux/pidfs.h>",
            "#include <linux/tick.h>",
            "",
            "#include <asm/pgalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/tlbflush.h>",
            "",
            "#include <trace/events/sched.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/task.h>",
            "",
            "#ifdef CONFIG_IEE",
            "#include <asm/iee-token.h>",
            "#endif",
            "",
            "#include <kunit/visibility.h>",
            "",
            "/*",
            " * Minimum number of threads to boot the kernel",
            " */",
            "#define MIN_THREADS 20",
            "",
            "/*",
            " * Maximum number of threads",
            " */",
            "#define MAX_THREADS FUTEX_TID_MASK",
            "",
            "/*",
            " * Protected counters by write_lock_irq(&tasklist_lock)",
            " */",
            "unsigned long total_forks;\t/* Handle normal Linux uptimes. */",
            "int nr_threads;\t\t\t/* The idle threads do not count.. */",
            "",
            "static int max_threads;\t\t/* tunable limit on nr_threads */",
            "",
            "#define NAMED_ARRAY_INDEX(x)\t[x] = __stringify(x)",
            "",
            "static const char * const resident_page_types[] = {",
            "\tNAMED_ARRAY_INDEX(MM_FILEPAGES),",
            "\tNAMED_ARRAY_INDEX(MM_ANONPAGES),",
            "\tNAMED_ARRAY_INDEX(MM_SWAPENTS),",
            "\tNAMED_ARRAY_INDEX(MM_SHMEMPAGES),",
            "};",
            "",
            "DEFINE_PER_CPU(unsigned long, process_counts) = 0;",
            "",
            "__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */",
            "",
            "#ifdef CONFIG_PROVE_RCU"
          ],
          "function_name": null,
          "description": "此代码块包含fork.c的头文件和全局变量定义，主要用于声明任务列表锁、线程计数器及内核栈相关配置，为后续的进程fork操作提供基础设施支持。",
          "similarity": 0.5438705086708069
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/fork.c",
          "start_line": 3121,
          "end_line": 3229,
          "content": [
            "static bool clone3_args_valid(struct kernel_clone_args *kargs)",
            "{",
            "\t/* Verify that no unknown flags are passed along. */",
            "\tif (kargs->flags &",
            "\t    ~(CLONE_LEGACY_FLAGS | CLONE_CLEAR_SIGHAND | CLONE_INTO_CGROUP))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * - make the CLONE_DETACHED bit reusable for clone3",
            "\t * - make the CSIGNAL bits reusable for clone3",
            "\t */",
            "\tif (kargs->flags & (CLONE_DETACHED | (CSIGNAL & (~CLONE_NEWTIME))))",
            "\t\treturn false;",
            "",
            "\tif ((kargs->flags & (CLONE_SIGHAND | CLONE_CLEAR_SIGHAND)) ==",
            "\t    (CLONE_SIGHAND | CLONE_CLEAR_SIGHAND))",
            "\t\treturn false;",
            "",
            "\tif ((kargs->flags & (CLONE_THREAD | CLONE_PARENT)) &&",
            "\t    kargs->exit_signal)",
            "\t\treturn false;",
            "",
            "\tif (!clone3_stack_valid(kargs))",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "void walk_process_tree(struct task_struct *top, proc_visitor visitor, void *data)",
            "{",
            "\tstruct task_struct *leader, *parent, *child;",
            "\tint res;",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tleader = top = top->group_leader;",
            "down:",
            "\tfor_each_thread(leader, parent) {",
            "\t\tlist_for_each_entry(child, &parent->children, sibling) {",
            "\t\t\tres = visitor(child, data);",
            "\t\t\tif (res) {",
            "\t\t\t\tif (res < 0)",
            "\t\t\t\t\tgoto out;",
            "\t\t\t\tleader = child;",
            "\t\t\t\tgoto down;",
            "\t\t\t}",
            "up:",
            "\t\t\t;",
            "\t\t}",
            "\t}",
            "",
            "\tif (leader != top) {",
            "\t\tchild = leader;",
            "\t\tparent = child->real_parent;",
            "\t\tleader = parent->group_leader;",
            "\t\tgoto up;",
            "\t}",
            "out:",
            "\tread_unlock(&tasklist_lock);",
            "}",
            "static void sighand_ctor(void *data)",
            "{",
            "\tstruct sighand_struct *sighand = data;",
            "",
            "\tspin_lock_init(&sighand->siglock);",
            "\tinit_waitqueue_head(&sighand->signalfd_wqh);",
            "}",
            "void __init mm_cache_init(void)",
            "{",
            "\tunsigned int mm_size;",
            "",
            "\t/*",
            "\t * The mm_cpumask is located at the end of mm_struct, and is",
            "\t * dynamically sized based on the maximum CPU number this system",
            "\t * can have, taking hotplug into account (nr_cpu_ids).",
            "\t */",
            "\tmm_size = sizeof(struct mm_struct) + cpumask_size() + mm_cid_size();",
            "",
            "\tmm_cachep = kmem_cache_create_usercopy(\"mm_struct\",",
            "\t\t\tmm_size, ARCH_MIN_MMSTRUCT_ALIGN,",
            "\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,",
            "\t\t\toffsetof(struct mm_struct, saved_auxv),",
            "\t\t\tsizeof_field(struct mm_struct, saved_auxv),",
            "\t\t\tNULL);",
            "}",
            "void __init proc_caches_init(void)",
            "{",
            "\tsighand_cachep = kmem_cache_create(\"sighand_cache\",",
            "\t\t\tsizeof(struct sighand_struct), 0,",
            "\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_TYPESAFE_BY_RCU|",
            "\t\t\tSLAB_ACCOUNT, sighand_ctor);",
            "\tsignal_cachep = kmem_cache_create(\"signal_cache\",",
            "\t\t\tsizeof(struct signal_struct), 0,",
            "\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,",
            "\t\t\tNULL);",
            "\tfiles_cachep = kmem_cache_create(\"files_cache\",",
            "\t\t\tsizeof(struct files_struct), 0,",
            "\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,",
            "\t\t\tNULL);",
            "\tfs_cachep = kmem_cache_create(\"fs_cache\",",
            "\t\t\tsizeof(struct fs_struct), 0,",
            "\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,",
            "\t\t\tNULL);",
            "",
            "\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC|SLAB_ACCOUNT);",
            "#ifdef CONFIG_PER_VMA_LOCK",
            "\tvma_lock_cachep = KMEM_CACHE(vma_lock, SLAB_PANIC|SLAB_ACCOUNT);",
            "#endif",
            "\tmmap_init();",
            "\tnsproxy_cache_init();",
            "}"
          ],
          "function_name": "clone3_args_valid, walk_process_tree, sighand_ctor, mm_cache_init, proc_caches_init",
          "description": "验证clone3参数合法性，遍历进程树执行回调函数，初始化信号处理手柄构造函数及内存管理结构体缓存，注册信号、文件描述符等结构体的Slab缓存",
          "similarity": 0.531131386756897
        }
      ]
    },
    {
      "source_file": "kernel/kthread.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:30:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kthread.c`\n\n---\n\n# kthread.c 技术文档\n\n## 文件概述\n\n`kthread.c` 是 Linux 内核中实现内核线程（kernel thread, kthread）管理机制的核心文件。它提供了创建、控制、同步和销毁内核线程的基础设施，确保内核线程在干净、受控的环境中运行，即使是从用户空间（如 modprobe、CPU 热插拔等）触发创建也能保证一致性。该文件实现了 kthread 的生命周期管理、状态控制（如停止、暂停）、数据访问接口以及与调度器、cgroup、freezer 等子系统的集成。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct kthread_create_info`**  \n  用于在 `kthread_create()` 和后台守护线程 `kthreadd` 之间传递创建参数和结果，包含线程函数、数据、节点信息、任务结构体指针和完成量。\n\n- **`struct kthread`**  \n  内核线程的私有控制块，挂载在 `task_struct->worker_private` 上，包含：\n  - 状态标志位（`KTHREAD_IS_PER_CPU`, `KTHREAD_SHOULD_STOP`, `KTHREAD_SHOULD_PARK`）\n  - CPU 绑定信息\n  - 线程函数指针和用户数据\n  - 用于同步的 `parked` 和 `exited` 完成量\n  - 完整线程名（当 `task->comm` 被截断时使用）\n  - （可选）块设备 cgroup 上下文（`blkcg_css`）\n\n- **全局变量**\n  - `kthread_create_lock`：保护 `kthread_create_list` 的自旋锁\n  - `kthread_create_list`：待创建内核线程的请求队列\n  - `kthreadd_task`：负责实际创建内核线程的守护进程任务结构体\n\n### 主要函数\n\n- **状态查询函数**\n  - `kthread_should_stop()`：检查是否应停止线程（由 `kthread_stop()` 触发）\n  - `kthread_should_park()`：检查是否应暂停线程（由 `kthread_park()` 触发）\n  - `kthread_should_stop_or_park()`：同时检查停止或暂停请求\n  - `kthread_freezable_should_stop()`：支持冻结的 kthread 停止检查，集成 freezer 机制\n\n- **数据访问函数**\n  - `kthread_func()`：获取线程创建时指定的函数指针\n  - `kthread_data()`：获取线程创建时传入的私有数据\n  - `kthread_probe_data()`：安全地探测可能的 kthread 数据（使用 `copy_from_kernel_nofault` 避免崩溃）\n  - `get_kthread_comm()`：获取完整的线程名称（优先使用 `full_name`）\n\n- **生命周期管理**\n  - `set_kthread_struct()`：为新任务分配并初始化 `struct kthread`\n  - `free_kthread_struct()`：释放 `struct kthread` 及其资源\n  - `kthread_parkme()`：将当前线程置于 `TASK_PARKED` 状态并等待唤醒\n  - `kthread_exit()`：终止当前 kthread 并返回结果（未在代码片段中完整显示）\n\n- **辅助函数**\n  - `to_kthread()` / `__to_kthread()`：从 `task_struct` 安全转换为 `struct kthread`，后者不假设任务一定是 kthread\n\n## 关键实现\n\n### kthread 私有数据管理\n- 每个 kthread 通过 `task_struct->worker_private` 指向其 `struct kthread` 实例。\n- `to_kthread()` 在访问前验证 `PF_KTHREAD` 标志，确保类型安全。\n- `__to_kthread()` 更加保守，仅在同时满足 `worker_private != NULL` 且 `PF_KTHREAD` 时才返回有效指针，以应对 `kernel_thread()` 可能执行 `exec()` 导致标志失效的情况。\n\n### 线程暂停机制（Parking）\n- 使用 `TASK_PARKED` 特殊任务状态，避免与常规调度状态冲突。\n- 在设置状态和检查标志之间使用原子操作，防止唤醒丢失。\n- 调用 `schedule_preempt_disabled()` 禁用抢占，确保 `kthread_park()` 调用者能可靠检测到线程已暂停。\n\n### 安全数据访问\n- `kthread_probe_data()` 使用 `copy_from_kernel_nofault()` 安全读取数据指针，即使目标内存无效也不会导致内核 oops，适用于调试或不确定上下文。\n\n### 冻结集成\n- `kthread_freezable_should_stop()` 在检查停止标志前先处理冻结请求，调用 `__refrigerator()` 进入冻结状态，避免 freezer 与 kthread_stop 死锁。\n\n### 名称管理\n- 当线程名超过 `TASK_COMM_LEN` 时，原始名称存储在 `kthread->full_name` 中，`get_kthread_comm()` 优先返回完整名称。\n\n## 依赖关系\n\n- **调度子系统**：依赖 `sched.h` 提供任务状态管理、调度原语（`schedule()`）、CPU 隔离等。\n- **内存管理**：使用 `slab.h` 分配 `kthread` 结构，`mm.h` 处理内存上下文。\n- **同步机制**：依赖 `completion.h` 实现线程创建和状态同步。\n- **cgroup 子系统**：条件编译支持 `CONFIG_BLK_CGROUP`，集成块设备 cgroup 控制。\n- **冻结子系统**：通过 `freezer.h` 与系统 suspend/hibernate 机制协作。\n- **追踪系统**：集成 `trace/events/sched.h` 提供调度事件追踪。\n- **用户空间接口**：通过 `uaccess.h` 支持安全内核空间访问（用于 `kthread_probe_data`）。\n\n## 使用场景\n\n- **内核模块加载**：`modprobe` 触发的模块可能创建 kthread，需通过 `kthreadd` 确保干净环境。\n- **设备驱动**：驱动程序使用 `kthread_run()` 创建工作线程处理中断下半部或轮询任务。\n- **系统服务线程**：如 `kswapd`（内存回收）、`kcompactd`（内存压缩）等核心内核线程。\n- **CPU 热插拔**：在 CPU 上下线时创建或迁移 per-CPU kthread。\n- **电源管理**：通过 `kthread_freezable_should_stop()` 支持系统 suspend 时冻结 kthread。\n- **动态资源管理**：使用 `kthread_park/unpark` 暂停/恢复线程以节省资源（如空闲时暂停工作线程）。\n- **调试与监控**：工具通过 `kthread_func()` 和 `kthread_data()` 获取线程上下文信息。",
      "similarity": 0.6532641649246216,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/kthread.c",
          "start_line": 299,
          "end_line": 413,
          "content": [
            "void kthread_parkme(void)",
            "{",
            "\t__kthread_parkme(to_kthread(current));",
            "}",
            "void __noreturn kthread_exit(long result)",
            "{",
            "\tstruct kthread *kthread = to_kthread(current);",
            "\tkthread->result = result;",
            "\tdo_exit(0);",
            "}",
            "void __noreturn kthread_complete_and_exit(struct completion *comp, long code)",
            "{",
            "\tif (comp)",
            "\t\tcomplete(comp);",
            "",
            "\tkthread_exit(code);",
            "}",
            "static int kthread(void *_create)",
            "{",
            "\tstatic const struct sched_param param = { .sched_priority = 0 };",
            "\t/* Copy data: it's on kthread's stack */",
            "\tstruct kthread_create_info *create = _create;",
            "\tint (*threadfn)(void *data) = create->threadfn;",
            "\tvoid *data = create->data;",
            "\tstruct completion *done;",
            "\tstruct kthread *self;",
            "\tint ret;",
            "",
            "\tself = to_kthread(current);",
            "",
            "\t/* Release the structure when caller killed by a fatal signal. */",
            "\tdone = xchg(&create->done, NULL);",
            "\tif (!done) {",
            "\t\tkfree(create->full_name);",
            "\t\tkfree(create);",
            "\t\tkthread_exit(-EINTR);",
            "\t}",
            "",
            "\tself->full_name = create->full_name;",
            "\tself->threadfn = threadfn;",
            "\tself->data = data;",
            "",
            "\t/*",
            "\t * The new thread inherited kthreadd's priority and CPU mask. Reset",
            "\t * back to default in case they have been changed.",
            "\t */",
            "\tsched_setscheduler_nocheck(current, SCHED_NORMAL, &param);",
            "\tset_cpus_allowed_ptr(current, housekeeping_cpumask(HK_TYPE_KTHREAD));",
            "",
            "\t/* OK, tell user we're spawned, wait for stop or wakeup */",
            "\t__set_current_state(TASK_UNINTERRUPTIBLE);",
            "\tcreate->result = current;",
            "\t/*",
            "\t * Thread is going to call schedule(), do not preempt it,",
            "\t * or the creator may spend more time in wait_task_inactive().",
            "\t */",
            "\tpreempt_disable();",
            "\tcomplete(done);",
            "\tschedule_preempt_disabled();",
            "\tpreempt_enable();",
            "",
            "\tret = -EINTR;",
            "\tif (!test_bit(KTHREAD_SHOULD_STOP, &self->flags)) {",
            "\t\tcgroup_kthread_ready();",
            "\t\t__kthread_parkme(self);",
            "\t\tret = threadfn(data);",
            "\t}",
            "\tkthread_exit(ret);",
            "}",
            "int tsk_fork_get_node(struct task_struct *tsk)",
            "{",
            "#ifdef CONFIG_NUMA",
            "\tif (tsk == kthreadd_task)",
            "\t\treturn tsk->pref_node_fork;",
            "#endif",
            "\treturn NUMA_NO_NODE;",
            "}",
            "static void create_kthread(struct kthread_create_info *create)",
            "{",
            "\tint pid;",
            "",
            "#ifdef CONFIG_NUMA",
            "\tcurrent->pref_node_fork = create->node;",
            "#endif",
            "\t/* We want our own signal handler (we take no signals by default). */",
            "\tpid = kernel_thread(kthread, create, create->full_name,",
            "\t\t\t    CLONE_FS | CLONE_FILES | SIGCHLD);",
            "\tif (pid < 0) {",
            "\t\t/* Release the structure when caller killed by a fatal signal. */",
            "\t\tstruct completion *done = xchg(&create->done, NULL);",
            "",
            "\t\tkfree(create->full_name);",
            "\t\tif (!done) {",
            "\t\t\tkfree(create);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tcreate->result = ERR_PTR(pid);",
            "\t\tcomplete(done);",
            "\t}",
            "}",
            "static void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!wait_task_inactive(p, state)) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* It's safe because the task is inactive. */",
            "\traw_spin_lock_irqsave(&p->pi_lock, flags);",
            "\tdo_set_cpus_allowed(p, mask);",
            "\tp->flags |= PF_NO_SETAFFINITY;",
            "\traw_spin_unlock_irqrestore(&p->pi_lock, flags);",
            "}"
          ],
          "function_name": "kthread_parkme, kthread_exit, kthread_complete_and_exit, kthread, tsk_fork_get_node, create_kthread, __kthread_bind_mask",
          "description": "处理线程执行流程、节点绑定及异常退出，kthread作为内核线程入口执行指定函数，create_kthread创建新线程并绑定CPU，__kthread_bind_mask调整线程CPU亲和性。",
          "similarity": 0.5869385004043579
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/kthread.c",
          "start_line": 1,
          "end_line": 101,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Kernel thread helper functions.",
            " *   Copyright (C) 2004 IBM Corporation, Rusty Russell.",
            " *   Copyright (C) 2009 Red Hat, Inc.",
            " *",
            " * Creation is done via kthreadd, so that we get a clean environment",
            " * even if we're invoked from userspace (think modprobe, hotplug cpu,",
            " * etc.).",
            " */",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/mm.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/err.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/unistd.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/isolation.h>",
            "#include <trace/events/sched.h>",
            "",
            "#ifdef CONFIG_IEE",
            "#include <asm/iee-token.h>",
            "#endif",
            "",
            "static DEFINE_SPINLOCK(kthread_create_lock);",
            "static LIST_HEAD(kthread_create_list);",
            "struct task_struct *kthreadd_task;",
            "",
            "struct kthread_create_info",
            "{",
            "\t/* Information passed to kthread() from kthreadd. */",
            "\tchar *full_name;",
            "\tint (*threadfn)(void *data);",
            "\tvoid *data;",
            "\tint node;",
            "",
            "\t/* Result passed back to kthread_create() from kthreadd. */",
            "\tstruct task_struct *result;",
            "\tstruct completion *done;",
            "",
            "\tstruct list_head list;",
            "};",
            "",
            "struct kthread {",
            "\tunsigned long flags;",
            "\tunsigned int cpu;",
            "\tint result;",
            "\tint (*threadfn)(void *);",
            "\tvoid *data;",
            "\tstruct completion parked;",
            "\tstruct completion exited;",
            "#ifdef CONFIG_BLK_CGROUP",
            "\tstruct cgroup_subsys_state *blkcg_css;",
            "#endif",
            "\t/* To store the full name if task comm is truncated. */",
            "\tchar *full_name;",
            "};",
            "",
            "enum KTHREAD_BITS {",
            "\tKTHREAD_IS_PER_CPU = 0,",
            "\tKTHREAD_SHOULD_STOP,",
            "\tKTHREAD_SHOULD_PARK,",
            "};",
            "",
            "static inline struct kthread *to_kthread(struct task_struct *k)",
            "{",
            "\tWARN_ON(!(k->flags & PF_KTHREAD));",
            "\treturn k->worker_private;",
            "}",
            "",
            "/*",
            " * Variant of to_kthread() that doesn't assume @p is a kthread.",
            " *",
            " * Per construction; when:",
            " *",
            " *   (p->flags & PF_KTHREAD) && p->worker_private",
            " *",
            " * the task is both a kthread and struct kthread is persistent. However",
            " * PF_KTHREAD on it's own is not, kernel_thread() can exec() (See umh.c and",
            " * begin_new_exec()).",
            " */",
            "static inline struct kthread *__to_kthread(struct task_struct *p)",
            "{",
            "\tvoid *kthread = p->worker_private;",
            "\tif (kthread && !(p->flags & PF_KTHREAD))",
            "\t\tkthread = NULL;",
            "\treturn kthread;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义内核线程辅助函数所需的数据结构和全局变量，包括用于管理线程创建的锁、链表头、任务结构体及标志位枚举，核心功能是为后续内核线程创建和管理提供基础设施。",
          "similarity": 0.552112340927124
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kthread.c",
          "start_line": 102,
          "end_line": 211,
          "content": [
            "void get_kthread_comm(char *buf, size_t buf_size, struct task_struct *tsk)",
            "{",
            "\tstruct kthread *kthread = to_kthread(tsk);",
            "",
            "\tif (!kthread || !kthread->full_name) {",
            "\t\t__get_task_comm(buf, buf_size, tsk);",
            "\t\treturn;",
            "\t}",
            "",
            "\tstrscpy_pad(buf, kthread->full_name, buf_size);",
            "}",
            "bool set_kthread_struct(struct task_struct *p)",
            "{",
            "\tstruct kthread *kthread;",
            "",
            "\tif (WARN_ON_ONCE(to_kthread(p)))",
            "\t\treturn false;",
            "",
            "\tkthread = kzalloc(sizeof(*kthread), GFP_KERNEL);",
            "\tif (!kthread)",
            "\t\treturn false;",
            "",
            "\tinit_completion(&kthread->exited);",
            "\tinit_completion(&kthread->parked);",
            "\tp->vfork_done = &kthread->exited;",
            "",
            "\tp->worker_private = kthread;",
            "\treturn true;",
            "}",
            "void free_kthread_struct(struct task_struct *k)",
            "{",
            "\tstruct kthread *kthread;",
            "",
            "\t/*",
            "\t * Can be NULL if kmalloc() in set_kthread_struct() failed.",
            "\t */",
            "\tkthread = to_kthread(k);",
            "\tif (!kthread)",
            "\t\treturn;",
            "",
            "#ifdef CONFIG_BLK_CGROUP",
            "\tWARN_ON_ONCE(kthread->blkcg_css);",
            "#endif",
            "\tk->worker_private = NULL;",
            "\tkfree(kthread->full_name);",
            "\tkfree(kthread);",
            "}",
            "bool kthread_should_stop(void)",
            "{",
            "\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);",
            "}",
            "static bool __kthread_should_park(struct task_struct *k)",
            "{",
            "\treturn test_bit(KTHREAD_SHOULD_PARK, &to_kthread(k)->flags);",
            "}",
            "bool kthread_should_park(void)",
            "{",
            "\treturn __kthread_should_park(current);",
            "}",
            "bool kthread_should_stop_or_park(void)",
            "{",
            "\tstruct kthread *kthread = __to_kthread(current);",
            "",
            "\tif (!kthread)",
            "\t\treturn false;",
            "",
            "\treturn kthread->flags & (BIT(KTHREAD_SHOULD_STOP) | BIT(KTHREAD_SHOULD_PARK));",
            "}",
            "bool kthread_freezable_should_stop(bool *was_frozen)",
            "{",
            "\tbool frozen = false;",
            "",
            "\tmight_sleep();",
            "",
            "\tif (unlikely(freezing(current)))",
            "\t\tfrozen = __refrigerator(true);",
            "",
            "\tif (was_frozen)",
            "\t\t*was_frozen = frozen;",
            "",
            "\treturn kthread_should_stop();",
            "}",
            "static void __kthread_parkme(struct kthread *self)",
            "{",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * TASK_PARKED is a special state; we must serialize against",
            "\t\t * possible pending wakeups to avoid store-store collisions on",
            "\t\t * task->state.",
            "\t\t *",
            "\t\t * Such a collision might possibly result in the task state",
            "\t\t * changin from TASK_PARKED and us failing the",
            "\t\t * wait_task_inactive() in kthread_park().",
            "\t\t */",
            "\t\tset_special_state(TASK_PARKED);",
            "\t\tif (!test_bit(KTHREAD_SHOULD_PARK, &self->flags))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * Thread is going to call schedule(), do not preempt it,",
            "\t\t * or the caller of kthread_park() may spend more time in",
            "\t\t * wait_task_inactive().",
            "\t\t */",
            "\t\tpreempt_disable();",
            "\t\tcomplete(&self->parked);",
            "\t\tschedule_preempt_disabled();",
            "\t\tpreempt_enable();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "}"
          ],
          "function_name": "get_kthread_comm, set_kthread_struct, free_kthread_struct, kthread_should_stop, __kthread_should_park, kthread_should_park, kthread_should_stop_or_park, kthread_freezable_should_stop, __kthread_parkme",
          "description": "实现内核线程的名称获取、结构体分配与释放、状态检测等功能，set_kthread_struct分配并初始化线程结构体，kthread_should_stop系列函数检测线程终止或停放标志。",
          "similarity": 0.509830892086029
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/kthread.c",
          "start_line": 1316,
          "end_line": 1426,
          "content": [
            "static bool __kthread_cancel_work_sync(struct kthread_work *work, bool is_dwork)",
            "{",
            "\tstruct kthread_worker *worker = work->worker;",
            "\tunsigned long flags;",
            "\tint ret = false;",
            "",
            "\tif (!worker)",
            "\t\tgoto out;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "\t/* Work must not be used with >1 worker, see kthread_queue_work(). */",
            "\tWARN_ON_ONCE(work->worker != worker);",
            "",
            "\tif (is_dwork)",
            "\t\tkthread_cancel_delayed_work_timer(work, &flags);",
            "",
            "\tret = __kthread_cancel_work(work);",
            "",
            "\tif (worker->current_work != work)",
            "\t\tgoto out_fast;",
            "",
            "\t/*",
            "\t * The work is in progress and we need to wait with the lock released.",
            "\t * In the meantime, block any queuing by setting the canceling counter.",
            "\t */",
            "\twork->canceling++;",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "\tkthread_flush_work(work);",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "\twork->canceling--;",
            "",
            "out_fast:",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "out:",
            "\treturn ret;",
            "}",
            "bool kthread_cancel_work_sync(struct kthread_work *work)",
            "{",
            "\treturn __kthread_cancel_work_sync(work, false);",
            "}",
            "bool kthread_cancel_delayed_work_sync(struct kthread_delayed_work *dwork)",
            "{",
            "\treturn __kthread_cancel_work_sync(&dwork->work, true);",
            "}",
            "void kthread_flush_worker(struct kthread_worker *worker)",
            "{",
            "\tstruct kthread_flush_work fwork = {",
            "\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),",
            "\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),",
            "\t};",
            "",
            "\tkthread_queue_work(worker, &fwork.work);",
            "\twait_for_completion(&fwork.done);",
            "}",
            "void kthread_destroy_worker(struct kthread_worker *worker)",
            "{",
            "\tstruct task_struct *task;",
            "",
            "\ttask = worker->task;",
            "\tif (WARN_ON(!task))",
            "\t\treturn;",
            "",
            "\tkthread_flush_worker(worker);",
            "\tkthread_stop(task);",
            "\tWARN_ON(!list_empty(&worker->delayed_work_list));",
            "\tWARN_ON(!list_empty(&worker->work_list));",
            "\tkfree(worker);",
            "}",
            "void kthread_use_mm(struct mm_struct *mm)",
            "{",
            "\tstruct mm_struct *active_mm;",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tWARN_ON_ONCE(!(tsk->flags & PF_KTHREAD));",
            "\tWARN_ON_ONCE(tsk->mm);",
            "",
            "\t/*",
            "\t * It is possible for mm to be the same as tsk->active_mm, but",
            "\t * we must still mmgrab(mm) and mmdrop_lazy_tlb(active_mm),",
            "\t * because these references are not equivalent.",
            "\t */",
            "\tmmgrab(mm);",
            "",
            "\ttask_lock(tsk);",
            "\t/* Hold off tlb flush IPIs while switching mm's */",
            "\tlocal_irq_disable();",
            "\tactive_mm = tsk->active_mm;",
            "\ttsk->active_mm = mm;",
            "\ttsk->mm = mm;",
            "\tmembarrier_update_current_mm(mm);",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(tsk, mm->pgd);",
            "\t#endif",
            "\tswitch_mm_irqs_off(active_mm, mm, tsk);",
            "\tlocal_irq_enable();",
            "\ttask_unlock(tsk);",
            "#ifdef finish_arch_post_lock_switch",
            "\tfinish_arch_post_lock_switch();",
            "#endif",
            "",
            "\t/*",
            "\t * When a kthread starts operating on an address space, the loop",
            "\t * in membarrier_{private,global}_expedited() may not observe",
            "\t * that tsk->mm, and not issue an IPI. Membarrier requires a",
            "\t * memory barrier after storing to tsk->mm, before accessing",
            "\t * user-space memory. A full memory barrier for membarrier",
            "\t * {PRIVATE,GLOBAL}_EXPEDITED is implicitly provided by",
            "\t * mmdrop_lazy_tlb().",
            "\t */",
            "\tmmdrop_lazy_tlb(active_mm);",
            "}"
          ],
          "function_name": "__kthread_cancel_work_sync, kthread_cancel_work_sync, kthread_cancel_delayed_work_sync, kthread_flush_worker, kthread_destroy_worker, kthread_use_mm",
          "description": "实现同步取消工作项及延迟工作功能，强制刷新工作者队列并销毁工作者线程，包含内存管理切换和块控制组关联逻辑",
          "similarity": 0.5086830854415894
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/kthread.c",
          "start_line": 1490,
          "end_line": 1539,
          "content": [
            "void kthread_unuse_mm(struct mm_struct *mm)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tWARN_ON_ONCE(!(tsk->flags & PF_KTHREAD));",
            "\tWARN_ON_ONCE(!tsk->mm);",
            "",
            "\ttask_lock(tsk);",
            "\t/*",
            "\t * When a kthread stops operating on an address space, the loop",
            "\t * in membarrier_{private,global}_expedited() may not observe",
            "\t * that tsk->mm, and not issue an IPI. Membarrier requires a",
            "\t * memory barrier after accessing user-space memory, before",
            "\t * clearing tsk->mm.",
            "\t */",
            "\tsmp_mb__after_spinlock();",
            "\tsync_mm_rss(mm);",
            "\tlocal_irq_disable();",
            "\ttsk->mm = NULL;",
            "\tmembarrier_update_current_mm(NULL);",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(tsk, NULL);",
            "\t#endif",
            "\tmmgrab_lazy_tlb(mm);",
            "\t/* active_mm is still 'mm' */",
            "\tenter_lazy_tlb(mm, tsk);",
            "\tlocal_irq_enable();",
            "\ttask_unlock(tsk);",
            "",
            "\tmmdrop(mm);",
            "}",
            "void kthread_associate_blkcg(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct kthread *kthread;",
            "",
            "\tif (!(current->flags & PF_KTHREAD))",
            "\t\treturn;",
            "\tkthread = to_kthread(current);",
            "\tif (!kthread)",
            "\t\treturn;",
            "",
            "\tif (kthread->blkcg_css) {",
            "\t\tcss_put(kthread->blkcg_css);",
            "\t\tkthread->blkcg_css = NULL;",
            "\t}",
            "\tif (css) {",
            "\t\tcss_get(css);",
            "\t\tkthread->blkcg_css = css;",
            "\t}",
            "}"
          ],
          "function_name": "kthread_unuse_mm, kthread_associate_blkcg",
          "description": "管理kthread的地址空间切换，包含内存屏障同步、TLB更新及块控制组绑定操作，确保上下文切换安全性",
          "similarity": 0.50826096534729
        }
      ]
    },
    {
      "source_file": "kernel/exec_domain.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:26:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `exec_domain.c`\n\n---\n\n# exec_domain.c 技术文档\n\n## 1. 文件概述\n\n`exec_domain.c` 是 Linux 内核中用于管理不同 ABI（Application Binary Interface，应用程序二进制接口）执行域（execution domains）的核心文件。该文件实现了对“personality”机制的支持，允许进程在运行时切换其行为模式，以兼容不同操作系统或 ABI 的语义，例如信号处理、系统调用编号映射等。当前实现主要保留了基础框架，并默认仅支持标准 Linux personality。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`SYSCALL_DEFINE1(personality, unsigned int, personality)`**  \n  系统调用入口，用于获取或设置当前进程的 personality。若传入参数不为 `0xffffffff`，则调用 `set_personality()` 更新当前进程的 personality；无论是否更新，均返回旧值。\n\n- **`execdomains_proc_show(struct seq_file *m, void *v)`**（条件编译）  \n  在 `/proc/execdomains` 文件中输出当前内核支持的执行域列表。当前仅输出标准 Linux 执行域（ID 0-0）。\n\n- **`proc_execdomains_init(void)`**（条件编译）  \n  初始化 `/proc/execdomains` 接口，仅在 `CONFIG_PROC_FS` 配置启用时编译。\n\n## 3. 关键实现\n\n- **Personality 机制**：  \n  每个进程的 `task_struct` 中包含 `personality` 字段，用于标识其当前的执行域行为。通过 `personality()` 系统调用可动态切换该值，从而影响内核对信号、路径解析、系统调用等行为的处理方式。\n\n- **执行域注册与查询**：  \n  历史上 Linux 支持多种执行域（如 SVr4、BSD、OSF 等），但现代内核已移除大部分实现，仅保留 Linux 原生执行域（ID 0）。`/proc/execdomains` 接口静态返回 `\"0-0\\tLinux\\t[kernel]\\n\"`，表明当前仅支持标准 Linux ABI。\n\n- **系统调用接口**：  \n  `personality()` 系统调用是用户空间与内核 personality 机制交互的唯一入口。传入 `0xffffffff` 可用于仅查询当前值而不修改。\n\n- **模块初始化**：  \n  若启用了 `CONFIG_PROC_FS`，则在内核初始化阶段通过 `module_init()` 注册 `/proc/execdomains` 文件，供用户空间查询支持的执行域。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/personality.h>`：定义 personality 相关常量和 `set_personality()` 函数。\n  - `<linux/sched.h>`：访问 `current` 宏以获取当前进程的 `task_struct`。\n  - `<linux/proc_fs.h>` 和 `<linux/seq_file.h>`：用于实现 `/proc/execdomains` 接口。\n  - `<linux/syscalls.h>`：用于定义系统调用。\n  - 其他通用内核头文件（如 `init.h`, `kernel.h`, `module.h` 等）。\n\n- **内核配置依赖**：\n  - `CONFIG_PROC_FS`：控制是否编译 `/proc/execdomains` 接口。\n\n- **外部模块交互**：\n  - 该文件不导出符号供其他模块使用，属于内核核心 ABI 支持层。\n  - `set_personality()` 的具体实现位于 `kernel/sys.c` 中。\n\n## 5. 使用场景\n\n- **兼容性运行环境**：  \n  在早期 Linux 中，用于运行非 Linux 二进制程序（如通过 binfmt 模块加载的 SVr4 或 BSD 程序），通过设置特定 personality 使内核模拟目标系统的 ABI 行为。\n\n- **调试与沙箱**：  \n  用户空间程序可通过 `personality(PER_LINUX)` 或其他标志（如 `ADDR_NO_RANDOMIZE`）临时修改进程行为，例如禁用 ASLR 以辅助调试。\n\n- **系统信息查询**：  \n  用户可通过读取 `/proc/execdomains` 了解当前内核支持的执行域类型（尽管现代系统通常仅显示 Linux）。\n\n- **容器与虚拟化**：  \n  在某些轻量级虚拟化场景中，可通过 personality 机制微调进程的系统调用行为，但现代方案更多依赖 seccomp 或 namespaces。",
      "similarity": 0.6398376822471619,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/exec_domain.c",
          "start_line": 24,
          "end_line": 33,
          "content": [
            "static int execdomains_proc_show(struct seq_file *m, void *v)",
            "{",
            "\tseq_puts(m, \"0-0\\tLinux           \\t[kernel]\\n\");",
            "\treturn 0;",
            "}",
            "static int __init proc_execdomains_init(void)",
            "{",
            "\tproc_create_single(\"execdomains\", 0, NULL, execdomains_proc_show);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "execdomains_proc_show, proc_execdomains_init",
          "description": "定义用于 /proc/execdomains 文件的读取回调函数及初始化函数，通过 proc_create_single 创建 proc 文件节点以暴露当前系统运行的执行域标识及其关联的 ABI 类型信息",
          "similarity": 0.5270099639892578
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/exec_domain.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Handling of different ABIs (personalities).",
            " *",
            " * We group personalities into execution domains which have their",
            " * own handlers for kernel entry points, signal mapping, etc...",
            " *",
            " * 2001-05-06\tComplete rewrite,  Christoph Hellwig (hch@infradead.org)",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kmod.h>",
            "#include <linux/module.h>",
            "#include <linux/personality.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/types.h>",
            "",
            "#ifdef CONFIG_PROC_FS"
          ],
          "function_name": null,
          "description": "此代码块包含执行域（exec domain）相关的头文件声明，启用对 PROC_FS 的支持以实现 ABI 特性处理，因代码片段未展示核心逻辑故标记上下文不完整",
          "similarity": 0.45574653148651123
        }
      ]
    }
  ]
}