{
  "query": "VFS文件权限检查流程分析",
  "timestamp": "2025-12-26 00:17:48",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/token.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:36:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\token.c`\n\n---\n\n# `bpf/token.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/token.c` 实现了 BPF（Berkeley Packet Filter）令牌（token）机制，用于在受限环境中安全地委托 BPF 操作权限。该机制允许用户空间程序通过文件描述符形式的令牌，将特定的 BPF 命令、映射类型、程序类型和附加类型权限委托给其他进程，同时结合用户命名空间（user namespace）和 LSM（Linux Security Module）安全策略进行细粒度访问控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `bpf_ns_capable()`：检查用户命名空间是否具备指定能力，或具备 `CAP_SYS_ADMIN`（除 `CAP_SYS_ADMIN` 自身外）。\n- `bpf_token_capable()`：结合用户命名空间能力和 LSM 安全钩子，判断令牌是否具备指定能力。\n- `bpf_token_inc()` / `bpf_token_put()`：引用计数管理，支持延迟释放。\n- `bpf_token_free()`：释放令牌资源，包括用户命名空间引用和安全模块数据。\n- `bpf_token_create()`：创建 BPF 令牌文件描述符，基于挂载在 BPF 文件系统上的委托配置。\n- `bpf_token_get_from_fd()`：从文件描述符获取并增加引用计数的 `bpf_token` 结构。\n- `bpf_token_allow_cmd()` / `bpf_token_allow_map_type()` / `bpf_token_allow_prog_type()`：检查令牌是否允许执行特定 BPF 操作。\n\n### 关键数据结构\n\n- `struct bpf_token`：表示 BPF 令牌，包含：\n  - `refcnt`：引用计数（`atomic64_t`）\n  - `userns`：关联的用户命名空间\n  - `allowed_cmds` / `allowed_maps` / `allowed_progs` / `allowed_attachs`：位掩码，分别表示允许的 BPF 命令、映射类型、程序类型和附加类型\n  - `work`：用于延迟释放的工作队列项\n\n### 文件操作接口\n\n- `bpf_token_fops`：定义了 `release` 和 `show_fdinfo` 回调，用于文件关闭和 `/proc/pid/fdinfo/` 信息展示。\n\n## 3. 关键实现\n\n### 令牌创建流程 (`bpf_token_create`)\n\n1. **验证输入**：检查传入的 `bpffs_fd` 是否指向 BPF 文件系统的根目录。\n2. **权限校验**：\n   - 要求调用者与 BPF 文件系统实例处于同一用户命名空间。\n   - 必须具备 `CAP_BPF` 能力。\n   - 禁止在 `init_user_ns` 中创建令牌。\n3. **委托配置检查**：确保 BPF 文件系统挂载时已通过挂载选项设置了至少一项委托权限（`delegate_*` 字段非零）。\n4. **资源分配**：\n   - 创建匿名 inode 和文件。\n   - 分配 `bpf_token` 结构并初始化引用计数为 1。\n   - 复制挂载选项中的委托位掩码到令牌。\n5. **安全模块集成**：调用 `security_bpf_token_create()` 允许 LSM 进行额外策略检查。\n6. **返回文件描述符**：安装文件到进程 fd 表并返回。\n\n### 安全能力检查 (`bpf_token_capable`)\n\n- 默认允许 `CAP_SYS_ADMIN` 作为“超级能力”覆盖其他能力检查（但 `CAP_SYS_ADMIN` 本身仍需显式授权）。\n- 调用 `security_bpf_token_capable()` 允许 LSM 对令牌能力进行二次验证。\n\n### 引用计数与延迟释放\n\n- 使用 `atomic64_t refcnt` 管理生命周期。\n- 当引用计数归零时，通过 `schedule_work()` 将释放操作推迟到工作队列执行，避免在中断或原子上下文中调用可能睡眠的 `put_user_ns()` 和 `kfree()`。\n\n### `/proc/pid/fdinfo/` 支持\n\n- `bpf_token_show_fdinfo()` 将令牌的委托权限以十六进制或 \"any\" 形式输出，便于调试和审计。\n\n### 权限位掩码设计\n\n- 所有委托权限（命令、映射、程序、附加类型）均使用 64 位无符号整数位掩码表示。\n- 通过 `BUILD_BUG_ON()` 确保枚举类型数量不超过 64，防止位移溢出。\n- 若掩码全为 1，则显示为 \"any\"，表示无限制。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_super_ops`、`bpf_get_inode()` 等 BPF 文件系统接口。\n- **用户命名空间**：通过 `user_namespace` 和 `ns_capable()` 实现能力隔离。\n- **安全模块 (LSM)**：集成 `security_bpf_token_*` 钩子，支持 SELinux、AppArmor 等策略扩展。\n- **VFS 层**：使用 `inode`、`file`、`path`、`fdtable` 等通用文件系统抽象。\n- **内存管理**：使用 `kzalloc()`/`kfree()` 和 `vmalloc.h`（虽未直接使用，但为潜在扩展预留）。\n- **工作队列**：通过 `schedule_work()` 实现延迟释放。\n\n## 5. 使用场景\n\n- **容器化环境中的 BPF 权限委托**：在用户命名空间隔离的容器中，特权进程可创建 BPF 令牌并传递给非特权子进程，使其在受限范围内使用 BPF 功能（如 eBPF 程序加载、映射操作）。\n- **安全沙箱**：应用程序可通过令牌机制将特定 BPF 操作权限委托给插件或子模块，避免授予完整 `CAP_BPF` 或 `CAP_SYS_ADMIN`。\n- **审计与调试**：通过 `/proc/pid/fdinfo/` 查看进程持有的 BPF 令牌权限，辅助安全分析。\n- **LSM 策略集成**：安全模块可基于令牌内容实施更细粒度的访问控制，例如限制特定程序类型只能在特定挂载点使用。",
      "similarity": 0.6184011697769165,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/token.c",
          "start_line": 230,
          "end_line": 254,
          "content": [
            "bool bpf_token_allow_cmd(const struct bpf_token *token, enum bpf_cmd cmd)",
            "{",
            "\tif (!token)",
            "\t\treturn false;",
            "\tif (!(token->allowed_cmds & (1ULL << cmd)))",
            "\t\treturn false;",
            "\treturn security_bpf_token_cmd(token, cmd) == 0;",
            "}",
            "bool bpf_token_allow_map_type(const struct bpf_token *token, enum bpf_map_type type)",
            "{",
            "\tif (!token || type >= __MAX_BPF_MAP_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn token->allowed_maps & (1ULL << type);",
            "}",
            "bool bpf_token_allow_prog_type(const struct bpf_token *token,",
            "\t\t\t       enum bpf_prog_type prog_type,",
            "\t\t\t       enum bpf_attach_type attach_type)",
            "{",
            "\tif (!token || prog_type >= __MAX_BPF_PROG_TYPE || attach_type >= __MAX_BPF_ATTACH_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn (token->allowed_progs & (1ULL << prog_type)) &&",
            "\t       (token->allowed_attachs & (1ULL << attach_type));",
            "}"
          ],
          "function_name": "bpf_token_allow_cmd, bpf_token_allow_map_type, bpf_token_allow_prog_type",
          "description": "提供对BPF命令、映射类型和程序类型的访问控制检查，通过位掩码匹配并结合安全模块验证权限。",
          "similarity": 0.6133933067321777
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/token.c",
          "start_line": 12,
          "end_line": 195,
          "content": [
            "static bool bpf_ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable(ns, cap) || (cap != CAP_SYS_ADMIN && ns_capable(ns, CAP_SYS_ADMIN));",
            "}",
            "bool bpf_token_capable(const struct bpf_token *token, int cap)",
            "{",
            "\tstruct user_namespace *userns;",
            "",
            "\t/* BPF token allows ns_capable() level of capabilities */",
            "\tuserns = token ? token->userns : &init_user_ns;",
            "\tif (!bpf_ns_capable(userns, cap))",
            "\t\treturn false;",
            "\tif (token && security_bpf_token_capable(token, cap) < 0)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "void bpf_token_inc(struct bpf_token *token)",
            "{",
            "\tatomic64_inc(&token->refcnt);",
            "}",
            "static void bpf_token_free(struct bpf_token *token)",
            "{",
            "\tsecurity_bpf_token_free(token);",
            "\tput_user_ns(token->userns);",
            "\tkfree(token);",
            "}",
            "static void bpf_token_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_token *token = container_of(work, struct bpf_token, work);",
            "",
            "\tbpf_token_free(token);",
            "}",
            "void bpf_token_put(struct bpf_token *token)",
            "{",
            "\tif (!token)",
            "\t\treturn;",
            "",
            "\tif (!atomic64_dec_and_test(&token->refcnt))",
            "\t\treturn;",
            "",
            "\tINIT_WORK(&token->work, bpf_token_put_deferred);",
            "\tschedule_work(&token->work);",
            "}",
            "static int bpf_token_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "",
            "\tbpf_token_put(token);",
            "\treturn 0;",
            "}",
            "static void bpf_token_show_fdinfo(struct seq_file *m, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "\tu64 mask;",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_CMD >= 64);",
            "\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\tif ((token->allowed_cmds & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_cmds:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_cmds:\\t0x%llx\\n\", token->allowed_cmds);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_MAP_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\tif ((token->allowed_maps & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_maps:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_maps:\\t0x%llx\\n\", token->allowed_maps);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_PROG_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\tif ((token->allowed_progs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_progs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_progs:\\t0x%llx\\n\", token->allowed_progs);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_ATTACH_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\tif ((token->allowed_attachs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_attachs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_attachs:\\t0x%llx\\n\", token->allowed_attachs);",
            "}",
            "int bpf_token_create(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_mount_opts *mnt_opts;",
            "\tstruct bpf_token *token = NULL;",
            "\tstruct user_namespace *userns;",
            "\tstruct inode *inode;",
            "\tstruct file *file;",
            "\tCLASS(fd, f)(attr->token_create.bpffs_fd);",
            "\tstruct path path;",
            "\tstruct super_block *sb;",
            "\tumode_t mode;",
            "\tint err, fd;",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "",
            "\tpath = fd_file(f)->f_path;",
            "\tsb = path.dentry->d_sb;",
            "",
            "\tif (path.dentry != sb->s_root)",
            "\t\treturn -EINVAL;",
            "\tif (sb->s_op != &bpf_super_ops)",
            "\t\treturn -EINVAL;",
            "\terr = path_permission(&path, MAY_ACCESS);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tuserns = sb->s_user_ns;",
            "\t/*",
            "\t * Enforce that creators of BPF tokens are in the same user",
            "\t * namespace as the BPF FS instance. This makes reasoning about",
            "\t * permissions a lot easier and we can always relax this later.",
            "\t */",
            "\tif (current_user_ns() != userns)",
            "\t\treturn -EPERM;",
            "\tif (!ns_capable(userns, CAP_BPF))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Creating BPF token in init_user_ns doesn't make much sense. */",
            "\tif (current_user_ns() == &init_user_ns)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tmnt_opts = sb->s_fs_info;",
            "\tif (mnt_opts->delegate_cmds == 0 &&",
            "\t    mnt_opts->delegate_maps == 0 &&",
            "\t    mnt_opts->delegate_progs == 0 &&",
            "\t    mnt_opts->delegate_attachs == 0)",
            "\t\treturn -ENOENT; /* no BPF token delegation is set up */",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tinode = bpf_get_inode(sb, NULL, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_token_iops;",
            "\tinode->i_fop = &bpf_token_fops;",
            "\tclear_nlink(inode); /* make sure it is unlinked */",
            "",
            "\tfile = alloc_file_pseudo(inode, path.mnt, BPF_TOKEN_INODE_NAME, O_RDWR, &bpf_token_fops);",
            "\tif (IS_ERR(file)) {",
            "\t\tiput(inode);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\ttoken = kzalloc(sizeof(*token), GFP_USER);",
            "\tif (!token) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_file;",
            "\t}",
            "",
            "\tatomic64_set(&token->refcnt, 1);",
            "",
            "\t/* remember bpffs owning userns for future ns_capable() checks */",
            "\ttoken->userns = get_user_ns(userns);",
            "",
            "\ttoken->allowed_cmds = mnt_opts->delegate_cmds;",
            "\ttoken->allowed_maps = mnt_opts->delegate_maps;",
            "\ttoken->allowed_progs = mnt_opts->delegate_progs;",
            "\ttoken->allowed_attachs = mnt_opts->delegate_attachs;",
            "",
            "\terr = security_bpf_token_create(token, attr, &path);",
            "\tif (err)",
            "\t\tgoto out_token;",
            "",
            "\tfd = get_unused_fd_flags(O_CLOEXEC);",
            "\tif (fd < 0) {",
            "\t\terr = fd;",
            "\t\tgoto out_token;",
            "\t}",
            "",
            "\tfile->private_data = token;",
            "\tfd_install(fd, file);",
            "",
            "\treturn fd;",
            "",
            "out_token:",
            "\tbpf_token_free(token);",
            "out_file:",
            "\tfput(file);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_ns_capable, bpf_token_capable, bpf_token_inc, bpf_token_free, bpf_token_put_deferred, bpf_token_put, bpf_token_release, bpf_token_show_fdinfo, bpf_token_create",
          "description": "实现BPF令牌的权限检查、引用计数管理、延迟释放及创建逻辑，包括基于挂载选项的令牌初始化和安全策略校验。",
          "similarity": 0.5779858827590942
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/token.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            ""
          ],
          "function_name": null,
          "description": "包含BPF令牌功能所需的各种内核头文件，如用户命名空间、安全策略、文件操作及BPF相关定义。",
          "similarity": 0.5289983153343201
        }
      ]
    },
    {
      "source_file": "mm/userfaultfd.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:30:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `userfaultfd.c`\n\n---\n\n# userfaultfd.c 技术文档\n\n## 1. 文件概述\n\n`userfaultfd.c` 是 Linux 内核中实现 **用户态缺页处理（UserfaultFD）** 机制的核心文件之一，位于 `mm/` 子系统目录下。该文件主要负责在发生用户注册的缺页事件（如缺页、写保护等）时，通过原子操作安全地填充目标虚拟内存区域（VMA）的页表项（PTE），从而支持用户空间对缺页事件进行延迟处理或自定义处理。典型应用场景包括内存迁移、检查点/恢复（CRIU）、虚拟机热迁移等。\n\n本文件重点实现了 **原子性内存填充（mfill_atomic）** 相关逻辑，确保在并发环境下对目标 VMA 的 PTE 安装操作是线程安全且语义正确的。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `validate_dst_vma()`  \n  验证目标 VMA 是否有效：检查目标地址范围是否完全包含在 VMA 内，且该 VMA 已注册 userfaultfd 上下文。\n\n- `find_vma_and_prepare_anon()`  \n  在持有 `mmap_lock` 的前提下，查找包含指定地址的 VMA，并为匿名映射预分配 `anon_vma` 结构。\n\n- `uffd_lock_vma()`（仅当 `CONFIG_PER_VMA_LOCK` 启用时）  \n  在不持有 `mmap_lock` 的情况下，通过 RCU 或读写锁安全地查找并锁定目标 VMA。\n\n- `uffd_mfill_lock()` / `uffd_mfill_unlock()`  \n  封装了获取和释放目标 VMA 锁的逻辑，根据是否启用 per-VMA 锁采用不同策略（RCU + VMA 锁 或 全局 mmap_read_lock）。\n\n- `mfill_file_over_size()`  \n  检查目标地址是否超出底层文件的实际大小（用于文件映射场景）。\n\n- `mfill_atomic_install_pte()`  \n  **核心函数**：将指定物理页安装到目标 VMA 的 PTE 中，处理权限（可写、共享）、userfaultfd 写保护标志（`MFILL_ATOMIC_WP`）、反向映射（rmap）和 LRU 管理。\n\n- `mfill_atomic_pte_copy()`  \n  从用户空间源地址拷贝一页数据到新分配的内核页，并调用 `mfill_atomic_install_pte()` 安装该页。\n\n- `mfill_atomic_pte_zeroed_folio()`（未完整展示）  \n  用于安装已清零的页（如处理 `MCOPY_ATOMIC_CONTINUE` 或零页填充）。\n\n### 关键数据结构\n\n- `struct vm_area_struct`：虚拟内存区域描述符，包含 userfaultfd 上下文指针 `vm_userfaultfd_ctx.ctx`。\n- `uffd_flags_t`：传递 userfaultfd 特定标志（如 `MFILL_ATOMIC_WP` 表示需设置 UFFD 写保护位）。\n- `pmd_t *dst_pmd`：指向目标页中间目录项，用于定位 PTE。\n\n## 3. 关键实现\n\n### 原子性与并发控制\n- 支持两种锁模型：\n  - **传统模型**：使用全局 `mmap_read_lock` 保护整个 VMA 查找和操作过程。\n  - **细粒度模型（`CONFIG_PER_VMA_LOCK`）**：优先尝试 RCU 无锁查找 VMA，失败后回退到 `mmap_read_lock`，并在成功路径上使用 per-VMA 读锁（`vm_lock`），提升并发性能。\n- 在拷贝用户数据时临时禁用页错误（`pagefault_disable()`），避免因嵌套 `mmap_lock` 导致死锁。\n\n### PTE 安装逻辑\n- **权限处理**：\n  - 若 VMA 可写且非共享文件映射，则 PTE 不设写权限（防止 COW 问题）。\n  - 若请求写保护（`MFILL_ATOMIC_WP`），则设置 `pte_mkuffd_wp()` 标志位。\n- **反向映射（rmap）**：\n  - 匿名页：调用 `folio_add_new_anon_rmap()` 建立匿名反向映射。\n  - 文件页：调用 `folio_add_file_rmap_pte()` 建立文件反向映射。\n- **内存统计**：通过 `inc_mm_counter()` 更新进程的 RSS 计数器。\n- **安全检查**：\n  - 拒绝覆盖非空 PTE（`!pte_none_mostly()`），但允许覆盖 PTE 标记（如 userfaultfd 缺失标记）。\n  - 对文件映射检查是否越界（`mfill_file_over_size()`）。\n\n### 内存管理\n- 使用 `vma_alloc_folio()` 分配高优先级可移动页。\n- 通过 `mem_cgroup_charge()` 进行内存控制组记账。\n- 正确管理 folio 的 LRU 链表（`folio_add_lru()` / `folio_add_lru_vma()`）和引用计数。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/userfaultfd_k.h>`：提供 userfaultfd 内核接口和标志定义。\n  - `<linux/mmu_notifier.h>`：用于内存管理通知机制。\n  - `<linux/rmap.h>`、`<linux/swap.h>`：反向映射和交换相关操作。\n  - `<asm/tlbflush.h>`：TLB 刷新支持（虽未直接调用，但 `update_mmu_cache()` 可能触发）。\n- **内核子系统**：\n  - **MM 子系统**：深度集成 VMA 管理、页表操作、内存分配、LRU 和 rmap。\n  - **Filesystem**：通过 `shmem_fs.h` 和 `i_size_read()` 支持 tmpfs/shmem 映射。\n  - **HugeTLB**：包含 hugetlb 头文件，为未来扩展预留支持。\n- **配置选项**：\n  - 依赖 `CONFIG_USERFAULTFD`。\n  - 可选支持 `CONFIG_PER_VMA_LOCK`（Linux 6.3+ 引入的细粒度 VMA 锁）。\n\n## 5. 使用场景\n\n- **用户态缺页处理（UserfaultFD）**：\n  - 当进程访问未映射或写保护的内存区域时，内核暂停线程并通知用户态守护进程。\n  - 用户态通过 `UFFDIO_COPY` 或 `UFFDIO_ZEROPAGE` ioctl 请求内核填充页面，触发 `mfill_atomic_*` 系列函数。\n- **检查点/恢复（CRIU）**：\n  - 在恢复过程中，延迟加载内存页，由用户态按需提供内容。\n- **虚拟机/容器热迁移**：\n  - 目标机预先注册 userfaultfd，迁移过程中缺页由源机数据填充。\n- **高性能内存池/垃圾回收**：\n  - 应用程序可拦截缺页以实现自定义内存分配策略。\n\n> 注：本文档基于提供的代码片段生成，`mfill_atomic_pte_zeroed_folio()` 函数体未完整给出，其功能推测为安装预清零页。",
      "similarity": 0.5894999504089355,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/userfaultfd.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  mm/userfaultfd.c",
            " *",
            " *  Copyright (C) 2015  Red Hat, Inc.",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/swap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include \"internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "包含userfaultfd模块所需的头文件和许可证声明，定义了核心结构体及依赖的内核接口，为后续用户空间故障处理功能提供基础支持。",
          "similarity": 0.5766981244087219
        },
        {
          "chunk_id": 1,
          "file_path": "mm/userfaultfd.c",
          "start_line": 22,
          "end_line": 129,
          "content": [
            "static __always_inline",
            "bool validate_dst_vma(struct vm_area_struct *dst_vma, unsigned long dst_end)",
            "{",
            "\t/* Make sure that the dst range is fully within dst_vma. */",
            "\tif (dst_end > dst_vma->vm_end)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Check the vma is registered in uffd, this is required to",
            "\t * enforce the VM_MAYWRITE check done at uffd registration",
            "\t * time.",
            "\t */",
            "\tif (!dst_vma->vm_userfaultfd_ctx.ctx)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static void uffd_mfill_unlock(struct vm_area_struct *vma)",
            "{",
            "\tvma_end_read(vma);",
            "}",
            "static void uffd_mfill_unlock(struct vm_area_struct *vma)",
            "{",
            "\tmmap_read_unlock(vma->vm_mm);",
            "}",
            "static bool mfill_file_over_size(struct vm_area_struct *dst_vma,",
            "\t\t\t\t unsigned long dst_addr)",
            "{",
            "\tstruct inode *inode;",
            "\tpgoff_t offset, max_off;",
            "",
            "\tif (!dst_vma->vm_file)",
            "\t\treturn false;",
            "",
            "\tinode = dst_vma->vm_file->f_inode;",
            "\toffset = linear_page_index(dst_vma, dst_addr);",
            "\tmax_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);",
            "\treturn offset >= max_off;",
            "}",
            "int mfill_atomic_install_pte(pmd_t *dst_pmd,",
            "\t\t\t     struct vm_area_struct *dst_vma,",
            "\t\t\t     unsigned long dst_addr, struct page *page,",
            "\t\t\t     bool newly_allocated, uffd_flags_t flags)",
            "{",
            "\tint ret;",
            "\tstruct mm_struct *dst_mm = dst_vma->vm_mm;",
            "\tpte_t _dst_pte, *dst_pte;",
            "\tbool writable = dst_vma->vm_flags & VM_WRITE;",
            "\tbool vm_shared = dst_vma->vm_flags & VM_SHARED;",
            "\tbool page_in_cache = page_mapping(page);",
            "\tspinlock_t *ptl;",
            "\tstruct folio *folio;",
            "",
            "\t_dst_pte = mk_pte(page, dst_vma->vm_page_prot);",
            "\t_dst_pte = pte_mkdirty(_dst_pte);",
            "\tif (page_in_cache && !vm_shared)",
            "\t\twritable = false;",
            "\tif (writable)",
            "\t\t_dst_pte = pte_mkwrite(_dst_pte, dst_vma);",
            "\tif (flags & MFILL_ATOMIC_WP)",
            "\t\t_dst_pte = pte_mkuffd_wp(_dst_pte);",
            "",
            "\tret = -EAGAIN;",
            "\tdst_pte = pte_offset_map_lock(dst_mm, dst_pmd, dst_addr, &ptl);",
            "\tif (!dst_pte)",
            "\t\tgoto out;",
            "",
            "\tif (mfill_file_over_size(dst_vma, dst_addr)) {",
            "\t\tret = -EFAULT;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tret = -EEXIST;",
            "\t/*",
            "\t * We allow to overwrite a pte marker: consider when both MISSING|WP",
            "\t * registered, we firstly wr-protect a none pte which has no page cache",
            "\t * page backing it, then access the page.",
            "\t */",
            "\tif (!pte_none_mostly(ptep_get(dst_pte)))",
            "\t\tgoto out_unlock;",
            "",
            "\tfolio = page_folio(page);",
            "\tif (page_in_cache) {",
            "\t\t/* Usually, cache pages are already added to LRU */",
            "\t\tif (newly_allocated)",
            "\t\t\tfolio_add_lru(folio);",
            "\t\tfolio_add_file_rmap_pte(folio, page, dst_vma);",
            "\t} else {",
            "\t\tfolio_add_new_anon_rmap(folio, dst_vma, dst_addr, RMAP_EXCLUSIVE);",
            "\t\tfolio_add_lru_vma(folio, dst_vma);",
            "\t}",
            "",
            "\t/*",
            "\t * Must happen after rmap, as mm_counter() checks mapping (via",
            "\t * PageAnon()), which is set by __page_set_anon_rmap().",
            "\t */",
            "\tinc_mm_counter(dst_mm, mm_counter(folio));",
            "",
            "\tset_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);",
            "",
            "\t/* No need to invalidate - it was non-present before */",
            "\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);",
            "\tret = 0;",
            "out_unlock:",
            "\tpte_unmap_unlock(dst_pte, ptl);",
            "out:",
            "\treturn ret;",
            "}"
          ],
          "function_name": "validate_dst_vma, uffd_mfill_unlock, uffd_mfill_unlock, mfill_file_over_size, mfill_atomic_install_pte",
          "description": "validate_dst_vma校验目标VMA有效性，uffd_mfill_unlock释放VMA读锁，mfill_file_over_size检测文件偏移是否超限，mfill_atomic_install_pte原子化安装页表项并处理缓存页面关联。",
          "similarity": 0.5639863014221191
        },
        {
          "chunk_id": 9,
          "file_path": "mm/userfaultfd.c",
          "start_line": 1336,
          "end_line": 1472,
          "content": [
            "static inline bool move_splits_huge_pmd(unsigned long dst_addr,",
            "\t\t\t\t\tunsigned long src_addr,",
            "\t\t\t\t\tunsigned long src_end)",
            "{",
            "\treturn (src_addr & ~HPAGE_PMD_MASK) || (dst_addr & ~HPAGE_PMD_MASK) ||",
            "\t\tsrc_end - src_addr < HPAGE_PMD_SIZE;",
            "}",
            "static inline bool move_splits_huge_pmd(unsigned long dst_addr,",
            "\t\t\t\t\tunsigned long src_addr,",
            "\t\t\t\t\tunsigned long src_end)",
            "{",
            "\t/* This is unreachable anyway, just to avoid warnings when HPAGE_PMD_SIZE==0 */",
            "\treturn false;",
            "}",
            "static inline bool vma_move_compatible(struct vm_area_struct *vma)",
            "{",
            "\treturn !(vma->vm_flags & (VM_PFNMAP | VM_IO |  VM_HUGETLB |",
            "\t\t\t\t  VM_MIXEDMAP | VM_SHADOW_STACK));",
            "}",
            "static int validate_move_areas(struct userfaultfd_ctx *ctx,",
            "\t\t\t       struct vm_area_struct *src_vma,",
            "\t\t\t       struct vm_area_struct *dst_vma)",
            "{",
            "\t/* Only allow moving if both have the same access and protection */",
            "\tif ((src_vma->vm_flags & VM_ACCESS_FLAGS) != (dst_vma->vm_flags & VM_ACCESS_FLAGS) ||",
            "\t    pgprot_val(src_vma->vm_page_prot) != pgprot_val(dst_vma->vm_page_prot))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Only allow moving if both are mlocked or both aren't */",
            "\tif ((src_vma->vm_flags & VM_LOCKED) != (dst_vma->vm_flags & VM_LOCKED))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * For now, we keep it simple and only move between writable VMAs.",
            "\t * Access flags are equal, therefore cheching only the source is enough.",
            "\t */",
            "\tif (!(src_vma->vm_flags & VM_WRITE))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Check if vma flags indicate content which can be moved */",
            "\tif (!vma_move_compatible(src_vma) || !vma_move_compatible(dst_vma))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure dst_vma is registered in uffd we are operating on */",
            "\tif (!dst_vma->vm_userfaultfd_ctx.ctx ||",
            "\t    dst_vma->vm_userfaultfd_ctx.ctx != ctx)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Only allow moving across anonymous vmas */",
            "\tif (!vma_is_anonymous(src_vma) || !vma_is_anonymous(dst_vma))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static __always_inline",
            "int find_vmas_mm_locked(struct mm_struct *mm,",
            "\t\t\tunsigned long dst_start,",
            "\t\t\tunsigned long src_start,",
            "\t\t\tstruct vm_area_struct **dst_vmap,",
            "\t\t\tstruct vm_area_struct **src_vmap)",
            "{",
            "\tstruct vm_area_struct *vma;",
            "",
            "\tmmap_assert_locked(mm);",
            "\tvma = find_vma_and_prepare_anon(mm, dst_start);",
            "\tif (IS_ERR(vma))",
            "\t\treturn PTR_ERR(vma);",
            "",
            "\t*dst_vmap = vma;",
            "\t/* Skip finding src_vma if src_start is in dst_vma */",
            "\tif (src_start >= vma->vm_start && src_start < vma->vm_end)",
            "\t\tgoto out_success;",
            "",
            "\tvma = vma_lookup(mm, src_start);",
            "\tif (!vma)",
            "\t\treturn -ENOENT;",
            "out_success:",
            "\t*src_vmap = vma;",
            "\treturn 0;",
            "}",
            "static int uffd_move_lock(struct mm_struct *mm,",
            "\t\t\t  unsigned long dst_start,",
            "\t\t\t  unsigned long src_start,",
            "\t\t\t  struct vm_area_struct **dst_vmap,",
            "\t\t\t  struct vm_area_struct **src_vmap)",
            "{",
            "\tstruct vm_area_struct *vma;",
            "\tint err;",
            "",
            "\tvma = uffd_lock_vma(mm, dst_start);",
            "\tif (IS_ERR(vma))",
            "\t\treturn PTR_ERR(vma);",
            "",
            "\t*dst_vmap = vma;",
            "\t/*",
            "\t * Skip finding src_vma if src_start is in dst_vma. This also ensures",
            "\t * that we don't lock the same vma twice.",
            "\t */",
            "\tif (src_start >= vma->vm_start && src_start < vma->vm_end) {",
            "\t\t*src_vmap = vma;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * Using uffd_lock_vma() to get src_vma can lead to following deadlock:",
            "\t *",
            "\t * Thread1\t\t\t\tThread2",
            "\t * -------\t\t\t\t-------",
            "\t * vma_start_read(dst_vma)",
            "\t *\t\t\t\t\tmmap_write_lock(mm)",
            "\t *\t\t\t\t\tvma_start_write(src_vma)",
            "\t * vma_start_read(src_vma)",
            "\t * mmap_read_lock(mm)",
            "\t *\t\t\t\t\tvma_start_write(dst_vma)",
            "\t */",
            "\t*src_vmap = lock_vma_under_rcu(mm, src_start);",
            "\tif (likely(*src_vmap))",
            "\t\treturn 0;",
            "",
            "\t/* Undo any locking and retry in mmap_lock critical section */",
            "\tvma_end_read(*dst_vmap);",
            "",
            "\tmmap_read_lock(mm);",
            "\terr = find_vmas_mm_locked(mm, dst_start, src_start, dst_vmap, src_vmap);",
            "\tif (!err) {",
            "\t\t/*",
            "\t\t * See comment in uffd_lock_vma() as to why not using",
            "\t\t * vma_start_read() here.",
            "\t\t */",
            "\t\tdown_read(&(*dst_vmap)->vm_lock->lock);",
            "\t\tif (*dst_vmap != *src_vmap)",
            "\t\t\tdown_read_nested(&(*src_vmap)->vm_lock->lock,",
            "\t\t\t\t\t SINGLE_DEPTH_NESTING);",
            "\t}",
            "\tmmap_read_unlock(mm);",
            "\treturn err;",
            "}"
          ],
          "function_name": "move_splits_huge_pmd, move_splits_huge_pmd, vma_move_compatible, validate_move_areas, find_vmas_mm_locked, uffd_move_lock",
          "description": "辅助函数用于迁移前验证（vma_move_compatible/validate_move_areas）、VMA 查找（find_vmas_mm_locked）及锁管理（uffd_move_lock），确保迁移操作在有效且安全的地址范围内进行。",
          "similarity": 0.5483971238136292
        },
        {
          "chunk_id": 10,
          "file_path": "mm/userfaultfd.c",
          "start_line": 1481,
          "end_line": 1681,
          "content": [
            "static void uffd_move_unlock(struct vm_area_struct *dst_vma,",
            "\t\t\t     struct vm_area_struct *src_vma)",
            "{",
            "\tvma_end_read(src_vma);",
            "\tif (src_vma != dst_vma)",
            "\t\tvma_end_read(dst_vma);",
            "}",
            "static int uffd_move_lock(struct mm_struct *mm,",
            "\t\t\t  unsigned long dst_start,",
            "\t\t\t  unsigned long src_start,",
            "\t\t\t  struct vm_area_struct **dst_vmap,",
            "\t\t\t  struct vm_area_struct **src_vmap)",
            "{",
            "\tint err;",
            "",
            "\tmmap_read_lock(mm);",
            "\terr = find_vmas_mm_locked(mm, dst_start, src_start, dst_vmap, src_vmap);",
            "\tif (err)",
            "\t\tmmap_read_unlock(mm);",
            "\treturn err;",
            "}",
            "static void uffd_move_unlock(struct vm_area_struct *dst_vma,",
            "\t\t\t     struct vm_area_struct *src_vma)",
            "{",
            "\tmmap_assert_locked(src_vma->vm_mm);",
            "\tmmap_read_unlock(dst_vma->vm_mm);",
            "}",
            "ssize_t move_pages(struct userfaultfd_ctx *ctx, unsigned long dst_start,",
            "\t\t   unsigned long src_start, unsigned long len, __u64 mode)",
            "{",
            "\tstruct mm_struct *mm = ctx->mm;",
            "\tstruct vm_area_struct *src_vma, *dst_vma;",
            "\tunsigned long src_addr, dst_addr;",
            "\tpmd_t *src_pmd, *dst_pmd;",
            "\tlong err = -EINVAL;",
            "\tssize_t moved = 0;",
            "",
            "\t/* Sanitize the command parameters. */",
            "\tif (WARN_ON_ONCE(src_start & ~PAGE_MASK) ||",
            "\t    WARN_ON_ONCE(dst_start & ~PAGE_MASK) ||",
            "\t    WARN_ON_ONCE(len & ~PAGE_MASK))",
            "\t\tgoto out;",
            "",
            "\t/* Does the address range wrap, or is the span zero-sized? */",
            "\tif (WARN_ON_ONCE(src_start + len <= src_start) ||",
            "\t    WARN_ON_ONCE(dst_start + len <= dst_start))",
            "\t\tgoto out;",
            "",
            "\terr = uffd_move_lock(mm, dst_start, src_start, &dst_vma, &src_vma);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\t/* Re-check after taking map_changing_lock */",
            "\terr = -EAGAIN;",
            "\tdown_read(&ctx->map_changing_lock);",
            "\tif (likely(atomic_read(&ctx->mmap_changing)))",
            "\t\tgoto out_unlock;",
            "\t/*",
            "\t * Make sure the vma is not shared, that the src and dst remap",
            "\t * ranges are both valid and fully within a single existing",
            "\t * vma.",
            "\t */",
            "\terr = -EINVAL;",
            "\tif (src_vma->vm_flags & VM_SHARED)",
            "\t\tgoto out_unlock;",
            "\tif (src_start + len > src_vma->vm_end)",
            "\t\tgoto out_unlock;",
            "",
            "\tif (dst_vma->vm_flags & VM_SHARED)",
            "\t\tgoto out_unlock;",
            "\tif (dst_start + len > dst_vma->vm_end)",
            "\t\tgoto out_unlock;",
            "",
            "\terr = validate_move_areas(ctx, src_vma, dst_vma);",
            "\tif (err)",
            "\t\tgoto out_unlock;",
            "",
            "\tfor (src_addr = src_start, dst_addr = dst_start;",
            "\t     src_addr < src_start + len;) {",
            "\t\tspinlock_t *ptl;",
            "\t\tpmd_t dst_pmdval;",
            "\t\tunsigned long step_size;",
            "",
            "\t\t/*",
            "\t\t * Below works because anonymous area would not have a",
            "\t\t * transparent huge PUD. If file-backed support is added,",
            "\t\t * that case would need to be handled here.",
            "\t\t */",
            "\t\tsrc_pmd = mm_find_pmd(mm, src_addr);",
            "\t\tif (unlikely(!src_pmd)) {",
            "\t\t\tif (!(mode & UFFDIO_MOVE_MODE_ALLOW_SRC_HOLES)) {",
            "\t\t\t\terr = -ENOENT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tsrc_pmd = mm_alloc_pmd(mm, src_addr);",
            "\t\t\tif (unlikely(!src_pmd)) {",
            "\t\t\t\terr = -ENOMEM;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tdst_pmd = mm_alloc_pmd(mm, dst_addr);",
            "\t\tif (unlikely(!dst_pmd)) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tdst_pmdval = pmdp_get_lockless(dst_pmd);",
            "\t\t/*",
            "\t\t * If the dst_pmd is mapped as THP don't override it and just",
            "\t\t * be strict. If dst_pmd changes into TPH after this check, the",
            "\t\t * move_pages_huge_pmd() will detect the change and retry",
            "\t\t * while move_pages_pte() will detect the change and fail.",
            "\t\t */",
            "\t\tif (unlikely(pmd_trans_huge(dst_pmdval))) {",
            "\t\t\terr = -EEXIST;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tptl = pmd_trans_huge_lock(src_pmd, src_vma);",
            "\t\tif (ptl) {",
            "\t\t\tif (pmd_devmap(*src_pmd)) {",
            "\t\t\t\tspin_unlock(ptl);",
            "\t\t\t\terr = -ENOENT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\t/* Check if we can move the pmd without splitting it. */",
            "\t\t\tif (move_splits_huge_pmd(dst_addr, src_addr, src_start + len) ||",
            "\t\t\t    !pmd_none(dst_pmdval)) {",
            "\t\t\t\tstruct folio *folio = pmd_folio(*src_pmd);",
            "",
            "\t\t\t\tif (!folio || (!is_huge_zero_folio(folio) &&",
            "\t\t\t\t\t       !PageAnonExclusive(&folio->page))) {",
            "\t\t\t\t\tspin_unlock(ptl);",
            "\t\t\t\t\terr = -EBUSY;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "",
            "\t\t\t\tspin_unlock(ptl);",
            "\t\t\t\tsplit_huge_pmd(src_vma, src_pmd, src_addr);",
            "\t\t\t\t/* The folio will be split by move_pages_pte() */",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\terr = move_pages_huge_pmd(mm, dst_pmd, src_pmd,",
            "\t\t\t\t\t\t  dst_pmdval, dst_vma, src_vma,",
            "\t\t\t\t\t\t  dst_addr, src_addr);",
            "\t\t\tstep_size = HPAGE_PMD_SIZE;",
            "\t\t} else {",
            "\t\t\tif (pmd_none(*src_pmd)) {",
            "\t\t\t\tif (!(mode & UFFDIO_MOVE_MODE_ALLOW_SRC_HOLES)) {",
            "\t\t\t\t\terr = -ENOENT;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tif (unlikely(__pte_alloc(mm, src_pmd))) {",
            "\t\t\t\t\terr = -ENOMEM;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "",
            "\t\t\tif (unlikely(pte_alloc(mm, dst_pmd))) {",
            "\t\t\t\terr = -ENOMEM;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\terr = move_pages_pte(mm, dst_pmd, src_pmd,",
            "\t\t\t\t\t     dst_vma, src_vma,",
            "\t\t\t\t\t     dst_addr, src_addr, mode);",
            "\t\t\tstep_size = PAGE_SIZE;",
            "\t\t}",
            "",
            "\t\tcond_resched();",
            "",
            "\t\tif (fatal_signal_pending(current)) {",
            "\t\t\t/* Do not override an error */",
            "\t\t\tif (!err || err == -EAGAIN)",
            "\t\t\t\terr = -EINTR;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (err) {",
            "\t\t\tif (err == -EAGAIN)",
            "\t\t\t\tcontinue;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Proceed to the next page */",
            "\t\tdst_addr += step_size;",
            "\t\tsrc_addr += step_size;",
            "\t\tmoved += step_size;",
            "\t}",
            "",
            "out_unlock:",
            "\tup_read(&ctx->map_changing_lock);",
            "\tuffd_move_unlock(dst_vma, src_vma);",
            "out:",
            "\tVM_WARN_ON(moved < 0);",
            "\tVM_WARN_ON(err > 0);",
            "\tVM_WARN_ON(!moved && !err);",
            "\treturn moved ? moved : err;",
            "}"
          ],
          "function_name": "uffd_move_unlock, uffd_move_lock, uffd_move_unlock, move_pages",
          "description": "该代码段实现了用户faultfd接口中的页面迁移功能，核心在于通过`uffd_move_lock`获取目标/源VMA并加锁，`move_pages`处理具体迁移逻辑（含大页与普通页的差异化处理），并确保迁移过程中对VMA的并发控制。  \n`uffd_move_lock`用于安全地获取VMA并持有锁以防止竞争，`move_pages`则遍历页表项执行迁移，支持THP（Transparent Huge Pages）和标准页的迁移策略。  \n由于代码片段未包含所有辅助函数（如`validate_move_areas`等），上下文存在不完整性。",
          "similarity": 0.5259220600128174
        },
        {
          "chunk_id": 6,
          "file_path": "mm/userfaultfd.c",
          "start_line": 865,
          "end_line": 980,
          "content": [
            "ssize_t mfill_atomic_copy(struct userfaultfd_ctx *ctx, unsigned long dst_start,",
            "\t\t\t  unsigned long src_start, unsigned long len,",
            "\t\t\t  uffd_flags_t flags)",
            "{",
            "\treturn mfill_atomic(ctx, dst_start, src_start, len,",
            "\t\t\t    uffd_flags_set_mode(flags, MFILL_ATOMIC_COPY));",
            "}",
            "ssize_t mfill_atomic_zeropage(struct userfaultfd_ctx *ctx,",
            "\t\t\t      unsigned long start,",
            "\t\t\t      unsigned long len)",
            "{",
            "\treturn mfill_atomic(ctx, start, 0, len,",
            "\t\t\t    uffd_flags_set_mode(0, MFILL_ATOMIC_ZEROPAGE));",
            "}",
            "ssize_t mfill_atomic_continue(struct userfaultfd_ctx *ctx, unsigned long start,",
            "\t\t\t      unsigned long len, uffd_flags_t flags)",
            "{",
            "\treturn mfill_atomic(ctx, start, 0, len,",
            "\t\t\t    uffd_flags_set_mode(flags, MFILL_ATOMIC_CONTINUE));",
            "}",
            "ssize_t mfill_atomic_poison(struct userfaultfd_ctx *ctx, unsigned long start,",
            "\t\t\t    unsigned long len, uffd_flags_t flags)",
            "{",
            "\treturn mfill_atomic(ctx, start, 0, len,",
            "\t\t\t    uffd_flags_set_mode(flags, MFILL_ATOMIC_POISON));",
            "}",
            "long uffd_wp_range(struct vm_area_struct *dst_vma,",
            "\t\t   unsigned long start, unsigned long len, bool enable_wp)",
            "{",
            "\tunsigned int mm_cp_flags;",
            "\tstruct mmu_gather tlb;",
            "\tlong ret;",
            "",
            "\tVM_WARN_ONCE(start < dst_vma->vm_start || start + len > dst_vma->vm_end,",
            "\t\t\t\"The address range exceeds VMA boundary.\\n\");",
            "\tif (enable_wp)",
            "\t\tmm_cp_flags = MM_CP_UFFD_WP;",
            "\telse",
            "\t\tmm_cp_flags = MM_CP_UFFD_WP_RESOLVE;",
            "",
            "\t/*",
            "\t * vma->vm_page_prot already reflects that uffd-wp is enabled for this",
            "\t * VMA (see userfaultfd_set_vm_flags()) and that all PTEs are supposed",
            "\t * to be write-protected as default whenever protection changes.",
            "\t * Try upgrading write permissions manually.",
            "\t */",
            "\tif (!enable_wp && vma_wants_manual_pte_write_upgrade(dst_vma))",
            "\t\tmm_cp_flags |= MM_CP_TRY_CHANGE_WRITABLE;",
            "\ttlb_gather_mmu(&tlb, dst_vma->vm_mm);",
            "\tret = change_protection(&tlb, dst_vma, start, start + len, mm_cp_flags);",
            "\ttlb_finish_mmu(&tlb);",
            "",
            "\treturn ret;",
            "}",
            "int mwriteprotect_range(struct userfaultfd_ctx *ctx, unsigned long start,",
            "\t\t\tunsigned long len, bool enable_wp)",
            "{",
            "\tstruct mm_struct *dst_mm = ctx->mm;",
            "\tunsigned long end = start + len;",
            "\tunsigned long _start, _end;",
            "\tstruct vm_area_struct *dst_vma;",
            "\tunsigned long page_mask;",
            "\tlong err;",
            "\tVMA_ITERATOR(vmi, dst_mm, start);",
            "",
            "\t/*",
            "\t * Sanitize the command parameters:",
            "\t */",
            "\tBUG_ON(start & ~PAGE_MASK);",
            "\tBUG_ON(len & ~PAGE_MASK);",
            "",
            "\t/* Does the address range wrap, or is the span zero-sized? */",
            "\tBUG_ON(start + len <= start);",
            "",
            "\tmmap_read_lock(dst_mm);",
            "",
            "\t/*",
            "\t * If memory mappings are changing because of non-cooperative",
            "\t * operation (e.g. mremap) running in parallel, bail out and",
            "\t * request the user to retry later",
            "\t */",
            "\tdown_read(&ctx->map_changing_lock);",
            "\terr = -EAGAIN;",
            "\tif (atomic_read(&ctx->mmap_changing))",
            "\t\tgoto out_unlock;",
            "",
            "\terr = -ENOENT;",
            "\tfor_each_vma_range(vmi, dst_vma, end) {",
            "",
            "\t\tif (!userfaultfd_wp(dst_vma)) {",
            "\t\t\terr = -ENOENT;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (is_vm_hugetlb_page(dst_vma)) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tpage_mask = vma_kernel_pagesize(dst_vma) - 1;",
            "\t\t\tif ((start & page_mask) || (len & page_mask))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t_start = max(dst_vma->vm_start, start);",
            "\t\t_end = min(dst_vma->vm_end, end);",
            "",
            "\t\terr = uffd_wp_range(dst_vma, _start, _end - _start, enable_wp);",
            "",
            "\t\t/* Return 0 on success, <0 on failures */",
            "\t\tif (err < 0)",
            "\t\t\tbreak;",
            "\t\terr = 0;",
            "\t}",
            "out_unlock:",
            "\tup_read(&ctx->map_changing_lock);",
            "\tmmap_read_unlock(dst_mm);",
            "\treturn err;",
            "}"
          ],
          "function_name": "mfill_atomic_copy, mfill_atomic_zeropage, mfill_atomic_continue, mfill_atomic_poison, uffd_wp_range, mwriteprotect_range",
          "description": "mfill_atomic 系列函数封装不同填充模式（copy/zeropage/continue/poison），uffd_wp_range/mwriteprotect_range 实现用户faultfd 写保护范围的设置与验证，处理页表保护状态变更。",
          "similarity": 0.47259214520454407
        }
      ]
    },
    {
      "source_file": "kernel/kcsan/debugfs.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:18:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kcsan\\debugfs.c`\n\n---\n\n# kcsan/debugfs.c 技术文档\n\n## 1. 文件概述\n\n`kcsan/debugfs.c` 是 Linux 内核 KCSAN（Kernel Concurrency Sanitizer）动态数据竞争检测器的 debugfs 接口实现文件。该文件提供了通过 debugfs 文件系统与 KCSAN 运行时交互的能力，包括启用/禁用检测、查看内部统计计数器、配置函数报告过滤列表（白名单/黑名单）、以及执行微基准测试等功能。用户空间可通过读写 `/sys/kernel/debug/kcsan` 文件来控制和监控 KCSAN 的行为。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`kcsan_counters[KCSAN_COUNTER_COUNT]`**  \n  全局原子计数器数组，用于统计 KCSAN 各类内部事件（如设置观察点次数、检测到的数据竞争数等）。\n\n- **`counter_names[]`**  \n  与 `kcsan_counters` 对应的可读名称字符串数组，用于 debugfs 输出。\n\n- **`report_filterlist`**  \n  用于过滤报告的函数地址列表结构体，包含：\n  - `addrs`: 函数地址数组\n  - `size`: 数组容量\n  - `used`: 已使用元素数量\n  - `sorted`: 是否已排序（用于二分查找）\n  - `whitelist`: 布尔值，指示列表是白名单（true）还是黑名单（false）\n\n- **`report_filterlist_lock`**  \n  保护 `report_filterlist` 的原始自旋锁（raw spinlock），支持在原子上下文中安全访问。\n\n### 主要函数\n\n- **`microbenchmark(unsigned long iters)`**  \n  执行 KCSAN 核心路径的微基准测试，临时禁用 KCSAN 并反复调用 `__kcsan_check_access` 以测量性能开销。\n\n- **`kcsan_skip_report_debugfs(unsigned long func_addr)`**  \n  根据 `report_filterlist` 判断是否应跳过对指定函数地址的数据竞争报告。\n\n- **`insert_report_filterlist(const char *func)`**  \n  将指定函数名解析为地址并插入到过滤列表中，支持动态扩容。\n\n- **`set_report_filterlist_whitelist(bool whitelist)`**  \n  设置过滤列表模式为白名单或黑名单。\n\n- **`show_info(struct seq_file *file, void *v)`**  \n  向 debugfs 文件输出 KCSAN 当前状态，包括启用状态、所有计数器值和过滤列表内容。\n\n- **`debugfs_write(...)`**  \n  处理用户写入 debugfs 文件的命令，支持 `on`/`off`、`microbench=`、`whitelist`/`blacklist`、`!function_name` 等指令。\n\n- **`kcsan_debugfs_init(void)`**  \n  初始化函数，在内核启动时创建 debugfs 文件 `/sys/kernel/debug/kcsan`。\n\n## 3. 关键实现\n\n### 过滤列表的动态管理\n- 过滤列表采用动态数组实现，初始容量为 4，按需倍增扩容。\n- 插入新地址时，若容量不足，先在锁外预分配新数组，再在锁内验证并切换指针，避免在原子上下文中分配内存。\n- 使用 `kallsyms_lookup_name()` 将函数名解析为内核符号地址，并通过 `kallsyms_lookup_size_offset()` 获取函数起始地址以确保精确匹配。\n- 列表在首次查询时懒排序（`sorted = false` 触发 `sort()`），后续查询使用 `bsearch()` 进行高效二分查找。\n\n### 白名单/黑名单逻辑\n- 若为**白名单模式**（`whitelist = true`），仅当函数**不在**列表中时才跳过报告（即只报告列表中的函数）。\n- 若为**黑名单模式**（`whitelist = false`），当函数**在**列表中时跳过报告（即屏蔽列表中的函数）。\n- 默认行为等效于空黑名单（报告所有函数）。\n\n### 微基准测试设计\n- 临时保存并重置当前任务的 `kcsan_ctx` 上下文，避免干扰。\n- 强制设置 `kcsan_enabled = false`，确保只测试快速路径（fast-path）开销，不触发观察点设置等慢速路径。\n- 使用 `get_cycles()` 精确测量循环执行的 CPU 周期数。\n\n### 并发安全\n- 所有对 `report_filterlist` 的修改和查询均通过 `raw_spin_lock_irqsave()` 保护，确保在中断和原子上下文中的安全性。\n- 计数器使用 `atomic_long_t` 类型，保证多核并发更新的原子性。\n\n## 4. 依赖关系\n\n- **KCSAN 核心模块** (`kcsan.h`, `kcsan.c`)：依赖 `kcsan_enabled` 全局开关、`kcsan_counters` 计数器、`__kcsan_check_access()` 接口及 `KCSAN_ACCESS_*` 访问类型定义。\n- **内核符号解析** (`kallsyms.h`)：使用 `kallsyms_lookup_name()` 和 `kallsyms_lookup_size_offset()` 解析函数地址。\n- **Debugfs 子系统** (`debugfs.h`)：通过 `debugfs_create_file()` 创建调试接口文件。\n- **内存管理** (`slab.h`)：使用 `kmalloc_array()` 动态分配过滤列表内存。\n- **排序与查找** (`sort.h`, `bsearch.h`)：对过滤列表进行排序和二分查找。\n- **任务上下文** (`sched.h`)：访问 `current->kcsan_ctx` 任务特定的 KCSAN 上下文。\n\n## 5. 使用场景\n\n- **动态启停 KCSAN**：通过向 debugfs 文件写入 `on`/`off`，在运行时启用或禁用数据竞争检测，便于针对性测试。\n- **性能分析**：使用 `microbench=<iters>` 命令评估 KCSAN 快速路径的性能开销，辅助优化核心检测逻辑。\n- **报告过滤**：\n  - 添加函数到黑名单（`!function_name`）以屏蔽已知安全或无关紧要的竞争报告。\n  - 切换至白名单模式（`whitelist`）后，仅报告指定函数内的竞争，缩小问题排查范围。\n- **运行时监控**：读取 debugfs 文件获取 KCSAN 内部计数器（如 `data_races`、`no_capacity` 等），分析检测覆盖率和资源使用情况。\n- **调试辅助**：结合 `kallsyms` 符号信息，精确控制报告粒度，提升数据竞争调试效率。",
      "similarity": 0.5838480591773987,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/kcsan/debugfs.c",
          "start_line": 192,
          "end_line": 260,
          "content": [
            "static int show_info(struct seq_file *file, void *v)",
            "{",
            "\tint i;",
            "\tunsigned long flags;",
            "",
            "\t/* show stats */",
            "\tseq_printf(file, \"enabled: %i\\n\", READ_ONCE(kcsan_enabled));",
            "\tfor (i = 0; i < KCSAN_COUNTER_COUNT; ++i) {",
            "\t\tseq_printf(file, \"%s: %ld\\n\", counter_names[i],",
            "\t\t\t   atomic_long_read(&kcsan_counters[i]));",
            "\t}",
            "",
            "\t/* show filter functions, and filter type */",
            "\traw_spin_lock_irqsave(&report_filterlist_lock, flags);",
            "\tseq_printf(file, \"\\n%s functions: %s\\n\",",
            "\t\t   report_filterlist.whitelist ? \"whitelisted\" : \"blacklisted\",",
            "\t\t   report_filterlist.used == 0 ? \"none\" : \"\");",
            "\tfor (i = 0; i < report_filterlist.used; ++i)",
            "\t\tseq_printf(file, \" %ps\\n\", (void *)report_filterlist.addrs[i]);",
            "\traw_spin_unlock_irqrestore(&report_filterlist_lock, flags);",
            "",
            "\treturn 0;",
            "}",
            "static int debugfs_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn single_open(file, show_info, NULL);",
            "}",
            "static ssize_t",
            "debugfs_write(struct file *file, const char __user *buf, size_t count, loff_t *off)",
            "{",
            "\tchar kbuf[KSYM_NAME_LEN];",
            "\tchar *arg;",
            "\tint read_len = count < (sizeof(kbuf) - 1) ? count : (sizeof(kbuf) - 1);",
            "",
            "\tif (copy_from_user(kbuf, buf, read_len))",
            "\t\treturn -EFAULT;",
            "\tkbuf[read_len] = '\\0';",
            "\targ = strstrip(kbuf);",
            "",
            "\tif (!strcmp(arg, \"on\")) {",
            "\t\tWRITE_ONCE(kcsan_enabled, true);",
            "\t} else if (!strcmp(arg, \"off\")) {",
            "\t\tWRITE_ONCE(kcsan_enabled, false);",
            "\t} else if (str_has_prefix(arg, \"microbench=\")) {",
            "\t\tunsigned long iters;",
            "",
            "\t\tif (kstrtoul(&arg[strlen(\"microbench=\")], 0, &iters))",
            "\t\t\treturn -EINVAL;",
            "\t\tmicrobenchmark(iters);",
            "\t} else if (!strcmp(arg, \"whitelist\")) {",
            "\t\tset_report_filterlist_whitelist(true);",
            "\t} else if (!strcmp(arg, \"blacklist\")) {",
            "\t\tset_report_filterlist_whitelist(false);",
            "\t} else if (arg[0] == '!') {",
            "\t\tssize_t ret = insert_report_filterlist(&arg[1]);",
            "",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t} else {",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn count;",
            "}",
            "static int __init kcsan_debugfs_init(void)",
            "{",
            "\tdebugfs_create_file(\"kcsan\", 0644, NULL, NULL, &debugfs_ops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "show_info, debugfs_open, debugfs_write, kcsan_debugfs_init",
          "description": "实现调试文件系统的信息展示接口、文件打开操作、写入控制指令解析逻辑以及模块初始化函数，提供启用/禁用检测、执行基准测试、配置过滤规则等用户空间交互能力。",
          "similarity": 0.5201724767684937
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kcsan/debugfs.c",
          "start_line": 57,
          "end_line": 185,
          "content": [
            "static noinline void microbenchmark(unsigned long iters)",
            "{",
            "\tconst struct kcsan_ctx ctx_save = current->kcsan_ctx;",
            "\tconst bool was_enabled = READ_ONCE(kcsan_enabled);",
            "\tu64 cycles;",
            "",
            "\t/* We may have been called from an atomic region; reset context. */",
            "\tmemset(&current->kcsan_ctx, 0, sizeof(current->kcsan_ctx));",
            "\t/*",
            "\t * Disable to benchmark fast-path for all accesses, and (expected",
            "\t * negligible) call into slow-path, but never set up watchpoints.",
            "\t */",
            "\tWRITE_ONCE(kcsan_enabled, false);",
            "",
            "\tpr_info(\"%s begin | iters: %lu\\n\", __func__, iters);",
            "",
            "\tcycles = get_cycles();",
            "\twhile (iters--) {",
            "\t\tunsigned long addr = iters & ((PAGE_SIZE << 8) - 1);",
            "\t\tint type = !(iters & 0x7f) ? KCSAN_ACCESS_ATOMIC :",
            "\t\t\t\t(!(iters & 0xf) ? KCSAN_ACCESS_WRITE : 0);",
            "\t\t__kcsan_check_access((void *)addr, sizeof(long), type);",
            "\t}",
            "\tcycles = get_cycles() - cycles;",
            "",
            "\tpr_info(\"%s end   | cycles: %llu\\n\", __func__, cycles);",
            "",
            "\tWRITE_ONCE(kcsan_enabled, was_enabled);",
            "\t/* restore context */",
            "\tcurrent->kcsan_ctx = ctx_save;",
            "}",
            "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)",
            "{",
            "\tconst unsigned long a = *(const unsigned long *)rhs;",
            "\tconst unsigned long b = *(const unsigned long *)lhs;",
            "",
            "\treturn a < b ? -1 : a == b ? 0 : 1;",
            "}",
            "bool kcsan_skip_report_debugfs(unsigned long func_addr)",
            "{",
            "\tunsigned long symbolsize, offset;",
            "\tunsigned long flags;",
            "\tbool ret = false;",
            "",
            "\tif (!kallsyms_lookup_size_offset(func_addr, &symbolsize, &offset))",
            "\t\treturn false;",
            "\tfunc_addr -= offset; /* Get function start */",
            "",
            "\traw_spin_lock_irqsave(&report_filterlist_lock, flags);",
            "\tif (report_filterlist.used == 0)",
            "\t\tgoto out;",
            "",
            "\t/* Sort array if it is unsorted, and then do a binary search. */",
            "\tif (!report_filterlist.sorted) {",
            "\t\tsort(report_filterlist.addrs, report_filterlist.used,",
            "\t\t     sizeof(unsigned long), cmp_filterlist_addrs, NULL);",
            "\t\treport_filterlist.sorted = true;",
            "\t}",
            "\tret = !!bsearch(&func_addr, report_filterlist.addrs,",
            "\t\t\treport_filterlist.used, sizeof(unsigned long),",
            "\t\t\tcmp_filterlist_addrs);",
            "\tif (report_filterlist.whitelist)",
            "\t\tret = !ret;",
            "",
            "out:",
            "\traw_spin_unlock_irqrestore(&report_filterlist_lock, flags);",
            "\treturn ret;",
            "}",
            "static void set_report_filterlist_whitelist(bool whitelist)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&report_filterlist_lock, flags);",
            "\treport_filterlist.whitelist = whitelist;",
            "\traw_spin_unlock_irqrestore(&report_filterlist_lock, flags);",
            "}",
            "static ssize_t insert_report_filterlist(const char *func)",
            "{",
            "\tunsigned long flags;",
            "\tunsigned long addr = kallsyms_lookup_name(func);",
            "\tunsigned long *delay_free = NULL;",
            "\tunsigned long *new_addrs = NULL;",
            "\tsize_t new_size = 0;",
            "\tssize_t ret = 0;",
            "",
            "\tif (!addr) {",
            "\t\tpr_err(\"could not find function: '%s'\\n\", func);",
            "\t\treturn -ENOENT;",
            "\t}",
            "",
            "retry_alloc:",
            "\t/*",
            "\t * Check if we need an allocation, and re-validate under the lock. Since",
            "\t * the report_filterlist_lock is a raw, cannot allocate under the lock.",
            "\t */",
            "\tif (data_race(report_filterlist.used == report_filterlist.size)) {",
            "\t\tnew_size = (report_filterlist.size ?: 4) * 2;",
            "\t\tdelay_free = new_addrs = kmalloc_array(new_size, sizeof(unsigned long), GFP_KERNEL);",
            "\t\tif (!new_addrs)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\traw_spin_lock_irqsave(&report_filterlist_lock, flags);",
            "\tif (report_filterlist.used == report_filterlist.size) {",
            "\t\t/* Check we pre-allocated enough, and retry if not. */",
            "\t\tif (report_filterlist.used >= new_size) {",
            "\t\t\traw_spin_unlock_irqrestore(&report_filterlist_lock, flags);",
            "\t\t\tkfree(new_addrs); /* kfree(NULL) is safe */",
            "\t\t\tdelay_free = new_addrs = NULL;",
            "\t\t\tgoto retry_alloc;",
            "\t\t}",
            "",
            "\t\tif (report_filterlist.used)",
            "\t\t\tmemcpy(new_addrs, report_filterlist.addrs, report_filterlist.used * sizeof(unsigned long));",
            "\t\tdelay_free = report_filterlist.addrs; /* free the old list */",
            "\t\treport_filterlist.addrs = new_addrs;  /* switch to the new list */",
            "\t\treport_filterlist.size = new_size;",
            "\t}",
            "",
            "\t/* Note: deduplicating should be done in userspace. */",
            "\treport_filterlist.addrs[report_filterlist.used++] =",
            "\t\tkallsyms_lookup_name(func);",
            "\treport_filterlist.sorted = false;",
            "",
            "\traw_spin_unlock_irqrestore(&report_filterlist_lock, flags);",
            "",
            "\tkfree(delay_free);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "microbenchmark, cmp_filterlist_addrs, kcsan_skip_report_debugfs, set_report_filterlist_whitelist, insert_report_filterlist",
          "description": "实现微基准测试函数、地址过滤列表排序比较函数、地址过滤检查逻辑、切换白名单/黑名单模式及动态扩展过滤地址列表的功能，支持运行时性能测试和过滤规则管理。",
          "similarity": 0.4998689293861389
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/kcsan/debugfs.c",
          "start_line": 1,
          "end_line": 56,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * KCSAN debugfs interface.",
            " *",
            " * Copyright (C) 2019, Google LLC.",
            " */",
            "",
            "#define pr_fmt(fmt) \"kcsan: \" fmt",
            "",
            "#include <linux/atomic.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/bug.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include \"kcsan.h\"",
            "",
            "atomic_long_t kcsan_counters[KCSAN_COUNTER_COUNT];",
            "static const char *const counter_names[] = {",
            "\t[KCSAN_COUNTER_USED_WATCHPOINTS]\t\t= \"used_watchpoints\",",
            "\t[KCSAN_COUNTER_SETUP_WATCHPOINTS]\t\t= \"setup_watchpoints\",",
            "\t[KCSAN_COUNTER_DATA_RACES]\t\t\t= \"data_races\",",
            "\t[KCSAN_COUNTER_ASSERT_FAILURES]\t\t\t= \"assert_failures\",",
            "\t[KCSAN_COUNTER_NO_CAPACITY]\t\t\t= \"no_capacity\",",
            "\t[KCSAN_COUNTER_REPORT_RACES]\t\t\t= \"report_races\",",
            "\t[KCSAN_COUNTER_RACES_UNKNOWN_ORIGIN]\t\t= \"races_unknown_origin\",",
            "\t[KCSAN_COUNTER_UNENCODABLE_ACCESSES]\t\t= \"unencodable_accesses\",",
            "\t[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]\t= \"encoding_false_positives\",",
            "};",
            "static_assert(ARRAY_SIZE(counter_names) == KCSAN_COUNTER_COUNT);",
            "",
            "/*",
            " * Addresses for filtering functions from reporting. This list can be used as a",
            " * whitelist or blacklist.",
            " */",
            "static struct {",
            "\tunsigned long\t*addrs;\t\t/* array of addresses */",
            "\tsize_t\t\tsize;\t\t/* current size */",
            "\tint\t\tused;\t\t/* number of elements used */",
            "\tbool\t\tsorted;\t\t/* if elements are sorted */",
            "\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */",
            "} report_filterlist;",
            "static DEFINE_RAW_SPINLOCK(report_filterlist_lock);",
            "",
            "/*",
            " * The microbenchmark allows benchmarking KCSAN core runtime only. To run",
            " * multiple threads, pipe 'microbench=<iters>' from multiple tasks into the",
            " * debugfs file. This will not generate any conflicts, and tests fast-path only.",
            " */"
          ],
          "function_name": null,
          "description": "定义KCSAN调试文件系统的全局计数器和地址过滤列表相关变量，包括计数器名称数组、报告过滤地址列表及其锁，用于跟踪内存竞争检测统计信息和配置过滤规则。",
          "similarity": 0.46509045362472534
        }
      ]
    }
  ]
}