{
  "query": "OOM Killer触发条件分析",
  "timestamp": "2025-12-25 23:22:27",
  "retrieved_files": [
    {
      "source_file": "mm/oom_kill.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:58:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `oom_kill.c`\n\n---\n\n# oom_kill.c 技术文档\n\n## 1. 文件概述\n\n`oom_kill.c` 是 Linux 内核内存管理子系统中的关键组件，负责在系统严重内存不足（Out-Of-Memory, OOM）时选择并终止一个或多个进程，以释放内存资源、防止系统崩溃。该文件实现了 OOM Killer 的核心逻辑，包括候选进程的选择策略、内存压力评估、以及与内存控制组（memcg）、NUMA 策略、cpuset 等子系统的集成。OOM Killer 通常由 `__alloc_pages()` 在无法满足内存分配请求时触发。\n\n## 2. 核心功能\n\n### 主要函数\n- **`out_of_memory()`**：OOM Killer 的主入口函数（虽未在片段中完整显示，但为本文件核心）\n- **`oom_badness()`**：计算进程“坏度”（badness）分数的核心启发式函数，用于决定哪个进程最应被杀死\n- **`find_lock_task_mm()`**：在进程及其线程组中查找具有有效内存描述符（`mm_struct`）的可杀任务，并加锁\n- **`oom_unkillable_task()`**：判断某任务是否不可被 OOM Killer 杀死（如 init 进程、内核线程）\n- **`constrained_alloc()`**：确定当前内存分配所受的约束类型（如 memcg、cpuset、mempolicy）\n- **`oom_cpuset_eligible()`**（仅 CONFIG_NUMA）：在 NUMA 系统中检查任务是否符合 cpuset 或 mempolicy 的 OOM 杀死条件\n- **`should_dump_unreclaim_slab()`**：判断是否因不可回收 slab 内存过多而触发 OOM，用于辅助诊断\n\n### 关键数据结构\n- **`struct oom_control`**：封装 OOM 事件上下文，包括分配标志（`gfp_mask`）、节点掩码（`nodemask`）、内存控制组（`memcg`）、分配阶数（`order`）等\n- **`enum oom_constraint`**：表示内存分配受限的类型（`CONSTRAINT_NONE`、`CONSTRAINT_CPUSET`、`CONSTRAINT_MEMORY_POLICY`、`CONSTRAINT_MEMCG`）\n\n### 全局变量\n- **`sysctl_panic_on_oom`**：控制 OOM 时是否直接 panic\n- **`sysctl_oom_kill_allocating_task`**：若置位，则优先杀死触发 OOM 的进程\n- **`sysctl_oom_dump_tasks`**：控制 OOM 时是否打印所有任务的内存使用信息\n- **`oom_lock`**：互斥锁，序列化 OOM Killer 调用，防止并发过度杀进程\n- **`oom_adj_mutex`**：互斥锁，保护 `oom_score_adj` 和 `oom_score_adj_min` 的更新\n\n## 3. 关键实现\n\n### OOM 坏度评分算法 (`oom_badness`)\n- **基础分值**：基于进程的 RSS（Resident Set Size）、交换页数量（`MM_SWAPENTS`）和页表占用内存（`mm_pgtables_bytes`），单位为页数。\n- **调整因子**：通过 `oom_score_adj`（范围 [-1000, 1000]）进行线性调整。调整量 = `oom_score_adj * totalpages / 1000`，其中 `totalpages` 为当前 OOM 上下文允许的最大内存页数（全局或 memcg 限制）。\n- **排除规则**：\n  - 全局 init 进程（PID 1）和内核线程（`PF_KTHREAD`）不可杀。\n  - 显式设置 `oom_score_adj = OOM_SCORE_ADJ_MIN (-1000)` 的进程不可杀。\n  - 已被标记跳过（`MMF_OOM_SKIP`）或处于 `vfork` 中间状态的进程不可杀。\n- **返回值**：`LONG_MIN` 表示不可杀；否则返回综合评分，值越大越优先被杀。\n\n### 内存分配约束识别 (`constrained_alloc`)\n- **Memcg OOM**：若 `oc->memcg` 非空，则 `totalpages` 设为 memcg 的内存上限，约束类型为 `CONSTRAINT_MEMCG`。\n- **全局 OOM**：默认 `totalpages = totalram_pages + total_swap_pages`。\n- **NUMA 约束**：\n  - 若分配请求指定 `__GFP_THISNODE`，视为无特殊约束（避免杀死当前进程）。\n  - 若存在非全集的 `nodemask`（来自 mempolicy），则 `totalpages` 仅统计该 nodemask 覆盖节点的内存，约束类型为 `CONSTRAINT_MEMORY_POLICY`。\n  - Cpuset 约束由页面分配器处理，此处不直接计算。\n\n### 多线程与内存描述符处理 (`find_lock_task_mm`)\n- 遍历目标进程的整个线程组（`for_each_thread`），寻找任一仍持有有效 `mm_struct` 的线程。\n- 对找到的线程加 `task_lock` 并返回，确保在检查其内存状态时不会被释放。\n- 适用于主线程已退出但子线程仍在运行的场景。\n\n### NUMA 可杀性检查 (`oom_cpuset_eligible`)\n- 在 NUMA 系统中，仅当候选任务与触发 OOM 的当前任务在内存策略（mempolicy）或 cpuset 允许的节点集上有交集时，才视为可杀。\n- 若 OOM 由 mempolicy 触发（`oc->nodemask` 非空），则仅检查 mempolicy 交集。\n- 否则，检查 cpuset 的 `mems_allowed` 交集。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/gfp.h>`、`<linux/swap.h>` 获取内存状态、分配标志和交换信息。\n- **进程调度与管理**：依赖 `<linux/sched.h>` 及相关头文件访问任务结构、线程组、cpuset 和内存策略。\n- **内存控制组 (cgroup v2)**：通过 `<linux/memcontrol.h>` 集成 memcg，支持容器级 OOM。\n- **安全模块**：通过 `<linux/security.h>` 调用 LSM 钩子（如 `security_oom_kill()`）。\n- **调试与追踪**：使用 ftrace (`<linux/ftrace.h>`) 和自定义 tracepoint (`trace/events/oom.h`) 记录 OOM 事件。\n- **体系结构相关**：包含 `<asm/tlb.h>` 处理 TLB 刷新。\n- **内部 MM 实现**：包含 `\"internal.h\"` 和 `\"slab.h\"` 访问内核私有内存管理接口。\n\n## 5. 使用场景\n\n- **全局内存耗尽**：当系统整体可用内存（含 swap）低于临界阈值，且无法通过页面回收释放足够内存时，由页面分配器调用 `out_of_memory()`。\n- **Memcg 内存超限**：当某个 memory cgroup 的内存使用超过其配额时，触发该 cgroup 内的 OOM Killer。\n- **SysRq 触发**：通过 Magic SysRq 键（`Alt+SysRq+f`）手动触发 OOM Killer，此时 `oc->order = -1`。\n- **诊断辅助**：当不可回收 slab 内存（如内核对象缓存）异常增长导致 OOM 时，`should_dump_unreclaim_slab()` 可触发 slab 信息转储以辅助调试。\n- **策略约束下的 OOM**：在 NUMA 系统中，受 cpuset 或 mempolicy 限制的进程在局部节点内存耗尽时触发针对性 OOM。",
      "similarity": 0.6485046148300171,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "mm/oom_kill.c",
          "start_line": 826,
          "end_line": 995,
          "content": [
            "bool oom_killer_disable(signed long timeout)",
            "{",
            "\tsigned long ret;",
            "",
            "\t/*",
            "\t * Make sure to not race with an ongoing OOM killer. Check that the",
            "\t * current is not killed (possibly due to sharing the victim's memory).",
            "\t */",
            "\tif (mutex_lock_killable(&oom_lock))",
            "\t\treturn false;",
            "\toom_killer_disabled = true;",
            "\tmutex_unlock(&oom_lock);",
            "",
            "\tret = wait_event_interruptible_timeout(oom_victims_wait,",
            "\t\t\t!atomic_read(&oom_victims), timeout);",
            "\tif (ret <= 0) {",
            "\t\toom_killer_enable();",
            "\t\treturn false;",
            "\t}",
            "\tpr_info(\"OOM killer disabled.\\n\");",
            "",
            "\treturn true;",
            "}",
            "static inline bool __task_will_free_mem(struct task_struct *task)",
            "{",
            "\tstruct signal_struct *sig = task->signal;",
            "",
            "\t/*",
            "\t * A coredumping process may sleep for an extended period in",
            "\t * coredump_task_exit(), so the oom killer cannot assume that",
            "\t * the process will promptly exit and release memory.",
            "\t */",
            "\tif (sig->core_state)",
            "\t\treturn false;",
            "",
            "\tif (sig->flags & SIGNAL_GROUP_EXIT)",
            "\t\treturn true;",
            "",
            "\tif (thread_group_empty(task) && (task->flags & PF_EXITING))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static bool task_will_free_mem(struct task_struct *task)",
            "{",
            "\tstruct mm_struct *mm = task->mm;",
            "\tstruct task_struct *p;",
            "\tbool ret = true;",
            "",
            "\t/*",
            "\t * Skip tasks without mm because it might have passed its exit_mm and",
            "\t * exit_oom_victim. oom_reaper could have rescued that but do not rely",
            "\t * on that for now. We can consider find_lock_task_mm in future.",
            "\t */",
            "\tif (!mm)",
            "\t\treturn false;",
            "",
            "\tif (!__task_will_free_mem(task))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * This task has already been drained by the oom reaper so there are",
            "\t * only small chances it will free some more",
            "\t */",
            "\tif (test_bit(MMF_OOM_SKIP, &mm->flags))",
            "\t\treturn false;",
            "",
            "\tif (atomic_read(&mm->mm_users) <= 1)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Make sure that all tasks which share the mm with the given tasks",
            "\t * are dying as well to make sure that a) nobody pins its mm and",
            "\t * b) the task is also reapable by the oom reaper.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_process(p) {",
            "\t\tif (!process_shares_mm(p, mm))",
            "\t\t\tcontinue;",
            "\t\tif (same_thread_group(task, p))",
            "\t\t\tcontinue;",
            "\t\tret = __task_will_free_mem(p);",
            "\t\tif (!ret)",
            "\t\t\tbreak;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "static void __oom_kill_process(struct task_struct *victim, const char *message)",
            "{",
            "\tstruct task_struct *p;",
            "\tstruct mm_struct *mm;",
            "\tbool can_oom_reap = true;",
            "",
            "\tp = find_lock_task_mm(victim);",
            "\tif (!p) {",
            "\t\tpr_info(\"%s: OOM victim %d (%s) is already exiting. Skip killing the task\\n\",",
            "\t\t\tmessage, task_pid_nr(victim), victim->comm);",
            "\t\tput_task_struct(victim);",
            "\t\treturn;",
            "\t} else if (victim != p) {",
            "\t\tget_task_struct(p);",
            "\t\tput_task_struct(victim);",
            "\t\tvictim = p;",
            "\t}",
            "",
            "\t/* Get a reference to safely compare mm after task_unlock(victim) */",
            "\tmm = victim->mm;",
            "\tmmgrab(mm);",
            "",
            "\t/* Raise event before sending signal: task reaper must see this */",
            "\tcount_vm_event(OOM_KILL);",
            "\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);",
            "",
            "\t/*",
            "\t * We should send SIGKILL before granting access to memory reserves",
            "\t * in order to prevent the OOM victim from depleting the memory",
            "\t * reserves from the user space under its control.",
            "\t */",
            "\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);",
            "\tmark_oom_victim(victim);",
            "\tpr_err(\"%s: Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB, UID:%u pgtables:%lukB oom_score_adj:%hd\\n\",",
            "\t\tmessage, task_pid_nr(victim), victim->comm, K(mm->total_vm),",
            "\t\tK(get_mm_counter(mm, MM_ANONPAGES)),",
            "\t\tK(get_mm_counter(mm, MM_FILEPAGES)),",
            "\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)),",
            "\t\tfrom_kuid(&init_user_ns, task_uid(victim)),",
            "\t\tmm_pgtables_bytes(mm) >> 10, victim->signal->oom_score_adj);",
            "\ttask_unlock(victim);",
            "",
            "\t/*",
            "\t * Kill all user processes sharing victim->mm in other thread groups, if",
            "\t * any.  They don't get access to memory reserves, though, to avoid",
            "\t * depletion of all memory.  This prevents mm->mmap_lock livelock when an",
            "\t * oom killed thread cannot exit because it requires the semaphore and",
            "\t * its contended by another thread trying to allocate memory itself.",
            "\t * That thread will now get access to memory reserves since it has a",
            "\t * pending fatal signal.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_process(p) {",
            "\t\tif (!process_shares_mm(p, mm))",
            "\t\t\tcontinue;",
            "\t\tif (same_thread_group(p, victim))",
            "\t\t\tcontinue;",
            "\t\tif (is_global_init(p)) {",
            "\t\t\tcan_oom_reap = false;",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",",
            "\t\t\t\t\ttask_pid_nr(victim), victim->comm,",
            "\t\t\t\t\ttask_pid_nr(p), p->comm);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/*",
            "\t\t * No kthread_use_mm() user needs to read from the userspace so",
            "\t\t * we are ok to reap it.",
            "\t\t */",
            "\t\tif (unlikely(p->flags & PF_KTHREAD))",
            "\t\t\tcontinue;",
            "\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\tif (can_oom_reap)",
            "\t\tqueue_oom_reaper(victim);",
            "",
            "\tmmdrop(mm);",
            "\tput_task_struct(victim);",
            "}"
          ],
          "function_name": "oom_killer_disable, __task_will_free_mem, task_will_free_mem, __oom_kill_process",
          "description": "提供OOM杀手禁用逻辑及进程可回收性判断，实现OOM触发时的进程强制终止流程，包含共享MM处理、信号发送、内存统计等核心操作",
          "similarity": 0.6241993308067322
        },
        {
          "chunk_id": 7,
          "file_path": "mm/oom_kill.c",
          "start_line": 1011,
          "end_line": 1162,
          "content": [
            "static int oom_kill_memcg_member(struct task_struct *task, void *message)",
            "{",
            "\tif (task->signal->oom_score_adj != OOM_SCORE_ADJ_MIN &&",
            "\t    !is_global_init(task)) {",
            "\t\tget_task_struct(task);",
            "\t\t__oom_kill_process(task, message);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void oom_kill_process(struct oom_control *oc, const char *message)",
            "{",
            "\tstruct task_struct *victim = oc->chosen;",
            "\tstruct mem_cgroup *oom_group;",
            "\tstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,",
            "\t\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
            "",
            "\t/*",
            "\t * If the task is already exiting, don't alarm the sysadmin or kill",
            "\t * its children or threads, just give it access to memory reserves",
            "\t * so it can die quickly",
            "\t */",
            "\ttask_lock(victim);",
            "\tif (task_will_free_mem(victim)) {",
            "\t\tmark_oom_victim(victim);",
            "\t\tqueue_oom_reaper(victim);",
            "\t\ttask_unlock(victim);",
            "\t\tput_task_struct(victim);",
            "\t\treturn;",
            "\t}",
            "\ttask_unlock(victim);",
            "",
            "\tif (__ratelimit(&oom_rs))",
            "\t\tdump_header(oc, victim);",
            "",
            "\t/*",
            "\t * Do we need to kill the entire memory cgroup?",
            "\t * Or even one of the ancestor memory cgroups?",
            "\t * Check this out before killing the victim task.",
            "\t */",
            "\toom_group = mem_cgroup_get_oom_group(victim, oc->memcg);",
            "",
            "\t__oom_kill_process(victim, message);",
            "",
            "\t/*",
            "\t * If necessary, kill all tasks in the selected memory cgroup.",
            "\t */",
            "\tif (oom_group) {",
            "\t\tmemcg_memory_event(oom_group, MEMCG_OOM_GROUP_KILL);",
            "\t\tmem_cgroup_print_oom_group(oom_group);",
            "\t\tmem_cgroup_scan_tasks(oom_group, oom_kill_memcg_member,",
            "\t\t\t\t      (void *)message);",
            "\t\tmem_cgroup_put(oom_group);",
            "\t}",
            "}",
            "static void check_panic_on_oom(struct oom_control *oc)",
            "{",
            "\tif (likely(!sysctl_panic_on_oom))",
            "\t\treturn;",
            "\tif (sysctl_panic_on_oom != 2) {",
            "\t\t/*",
            "\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel",
            "\t\t * does not panic for cpuset, mempolicy, or memcg allocation",
            "\t\t * failures.",
            "\t\t */",
            "\t\tif (oc->constraint != CONSTRAINT_NONE)",
            "\t\t\treturn;",
            "\t}",
            "\t/* Do not panic for oom kills triggered by sysrq */",
            "\tif (is_sysrq_oom(oc))",
            "\t\treturn;",
            "\tdump_header(oc, NULL);",
            "\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",",
            "\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");",
            "}",
            "int register_oom_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&oom_notify_list, nb);",
            "}",
            "int unregister_oom_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&oom_notify_list, nb);",
            "}",
            "bool out_of_memory(struct oom_control *oc)",
            "{",
            "\tunsigned long freed = 0;",
            "",
            "\tif (oom_killer_disabled)",
            "\t\treturn false;",
            "",
            "\tif (!is_memcg_oom(oc)) {",
            "\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);",
            "\t\tif (freed > 0 && !is_sysrq_oom(oc))",
            "\t\t\t/* Got some memory back in the last second. */",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * If current has a pending SIGKILL or is exiting, then automatically",
            "\t * select it.  The goal is to allow it to allocate so that it may",
            "\t * quickly exit and free its memory.",
            "\t */",
            "\tif (task_will_free_mem(current)) {",
            "\t\tmark_oom_victim(current);",
            "\t\tqueue_oom_reaper(current);",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * The OOM killer does not compensate for IO-less reclaim.",
            "\t * But mem_cgroup_oom() has to invoke the OOM killer even",
            "\t * if it is a GFP_NOFS allocation.",
            "\t */",
            "\tif (!(oc->gfp_mask & __GFP_FS) && !is_memcg_oom(oc))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Check if there were limitations on the allocation (only relevant for",
            "\t * NUMA and memcg) that may require different handling.",
            "\t */",
            "\toc->constraint = constrained_alloc(oc);",
            "\tif (oc->constraint != CONSTRAINT_MEMORY_POLICY)",
            "\t\toc->nodemask = NULL;",
            "\tcheck_panic_on_oom(oc);",
            "",
            "\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&",
            "\t    current->mm && !oom_unkillable_task(current) &&",
            "\t    oom_cpuset_eligible(current, oc) &&",
            "\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {",
            "\t\tget_task_struct(current);",
            "\t\toc->chosen = current;",
            "\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");",
            "\t\treturn true;",
            "\t}",
            "",
            "\tselect_bad_process(oc);",
            "\t/* Found nothing?!?! */",
            "\tif (!oc->chosen) {",
            "\t\tdump_header(oc, NULL);",
            "\t\tpr_warn(\"Out of memory and no killable processes...\\n\");",
            "\t\t/*",
            "\t\t * If we got here due to an actual allocation at the",
            "\t\t * system level, we cannot survive this and will enter",
            "\t\t * an endless loop in the allocator. Bail out now.",
            "\t\t */",
            "\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))",
            "\t\t\tpanic(\"System is deadlocked on memory\\n\");",
            "\t}",
            "\tif (oc->chosen && oc->chosen != (void *)-1UL)",
            "\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :",
            "\t\t\t\t \"Memory cgroup out of memory\");",
            "\treturn !!oc->chosen;",
            "}"
          ],
          "function_name": "oom_kill_memcg_member, oom_kill_process, check_panic_on_oom, register_oom_notifier, unregister_oom_notifier, out_of_memory",
          "description": "实现基于内存控制组的OOM处理逻辑，集成OOM通知机制，包含OOM触发判定、进程选择算法、内存组遍历杀进程等功能，支持系统级OOM恐慌检测",
          "similarity": 0.6233886480331421
        },
        {
          "chunk_id": 1,
          "file_path": "mm/oom_kill.c",
          "start_line": 73,
          "end_line": 176,
          "content": [
            "static inline bool is_memcg_oom(struct oom_control *oc)",
            "{",
            "\treturn oc->memcg != NULL;",
            "}",
            "static bool oom_cpuset_eligible(struct task_struct *start,",
            "\t\t\t\tstruct oom_control *oc)",
            "{",
            "\tstruct task_struct *tsk;",
            "\tbool ret = false;",
            "\tconst nodemask_t *mask = oc->nodemask;",
            "",
            "\trcu_read_lock();",
            "\tfor_each_thread(start, tsk) {",
            "\t\tif (mask) {",
            "\t\t\t/*",
            "\t\t\t * If this is a mempolicy constrained oom, tsk's",
            "\t\t\t * cpuset is irrelevant.  Only return true if its",
            "\t\t\t * mempolicy intersects current, otherwise it may be",
            "\t\t\t * needlessly killed.",
            "\t\t\t */",
            "\t\t\tret = mempolicy_in_oom_domain(tsk, mask);",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * This is not a mempolicy constrained oom, so only",
            "\t\t\t * check the mems of tsk's cpuset.",
            "\t\t\t */",
            "\t\t\tret = cpuset_mems_allowed_intersects(current, tsk);",
            "\t\t}",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "static bool oom_cpuset_eligible(struct task_struct *tsk, struct oom_control *oc)",
            "{",
            "\treturn true;",
            "}",
            "static inline bool is_sysrq_oom(struct oom_control *oc)",
            "{",
            "\treturn oc->order == -1;",
            "}",
            "static bool oom_unkillable_task(struct task_struct *p)",
            "{",
            "\tif (is_global_init(p))",
            "\t\treturn true;",
            "\tif (p->flags & PF_KTHREAD)",
            "\t\treturn true;",
            "\treturn false;",
            "}",
            "static bool should_dump_unreclaim_slab(void)",
            "{",
            "\tunsigned long nr_lru;",
            "",
            "\tnr_lru = global_node_page_state(NR_ACTIVE_ANON) +",
            "\t\t global_node_page_state(NR_INACTIVE_ANON) +",
            "\t\t global_node_page_state(NR_ACTIVE_FILE) +",
            "\t\t global_node_page_state(NR_INACTIVE_FILE) +",
            "\t\t global_node_page_state(NR_ISOLATED_ANON) +",
            "\t\t global_node_page_state(NR_ISOLATED_FILE) +",
            "\t\t global_node_page_state(NR_UNEVICTABLE);",
            "",
            "\treturn (global_node_page_state_pages(NR_SLAB_UNRECLAIMABLE_B) > nr_lru);",
            "}",
            "long oom_badness(struct task_struct *p, unsigned long totalpages)",
            "{",
            "\tlong points;",
            "\tlong adj;",
            "",
            "\tif (oom_unkillable_task(p))",
            "\t\treturn LONG_MIN;",
            "",
            "\tp = find_lock_task_mm(p);",
            "\tif (!p)",
            "\t\treturn LONG_MIN;",
            "",
            "\t/*",
            "\t * Do not even consider tasks which are explicitly marked oom",
            "\t * unkillable or have been already oom reaped or the are in",
            "\t * the middle of vfork",
            "\t */",
            "\tadj = (long)p->signal->oom_score_adj;",
            "\tif (adj == OOM_SCORE_ADJ_MIN ||",
            "\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||",
            "\t\t\tin_vfork(p)) {",
            "\t\ttask_unlock(p);",
            "\t\treturn LONG_MIN;",
            "\t}",
            "",
            "\t/*",
            "\t * The baseline for the badness score is the proportion of RAM that each",
            "\t * task's rss, pagetable and swap space use.",
            "\t */",
            "\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +",
            "\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;",
            "\ttask_unlock(p);",
            "",
            "\t/* Normalize to oom_score_adj units */",
            "\tadj *= totalpages / 1000;",
            "\tpoints += adj;",
            "",
            "\treturn points;",
            "}"
          ],
          "function_name": "is_memcg_oom, oom_cpuset_eligible, oom_cpuset_eligible, is_sysrq_oom, oom_unkillable_task, should_dump_unreclaim_slab, oom_badness",
          "description": "实现OOM候选进程的过滤逻辑，判断进程是否满足内存组、CPU集、不可杀标记等条件，并计算进程的OOM不良程度评分。",
          "similarity": 0.602126955986023
        },
        {
          "chunk_id": 4,
          "file_path": "mm/oom_kill.c",
          "start_line": 496,
          "end_line": 624,
          "content": [
            "bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)",
            "{",
            "\tstruct task_struct *t;",
            "",
            "\tfor_each_thread(p, t) {",
            "\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);",
            "\t\tif (t_mm)",
            "\t\t\treturn t_mm == mm;",
            "\t}",
            "\treturn false;",
            "}",
            "static bool __oom_reap_task_mm(struct mm_struct *mm)",
            "{",
            "\tstruct vm_area_struct *vma;",
            "\tbool ret = true;",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\t/*",
            "\t * Tell all users of get_user/copy_from_user etc... that the content",
            "\t * is no longer stable. No barriers really needed because unmapping",
            "\t * should imply barriers already and the reader would hit a page fault",
            "\t * if it stumbled over a reaped memory.",
            "\t */",
            "\tset_bit(MMF_UNSTABLE, &mm->flags);",
            "",
            "\tfor_each_vma(vmi, vma) {",
            "\t\tif (vma->vm_flags & (VM_HUGETLB|VM_PFNMAP))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Only anonymous pages have a good chance to be dropped",
            "\t\t * without additional steps which we cannot afford as we",
            "\t\t * are OOM already.",
            "\t\t *",
            "\t\t * We do not even care about fs backed pages because all",
            "\t\t * which are reclaimable have already been reclaimed and",
            "\t\t * we do not want to block exit_mmap by keeping mm ref",
            "\t\t * count elevated without a good reason.",
            "\t\t */",
            "\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {",
            "\t\t\tstruct mmu_notifier_range range;",
            "\t\t\tstruct mmu_gather tlb;",
            "",
            "\t\t\tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0,",
            "\t\t\t\t\t\tmm, vma->vm_start,",
            "\t\t\t\t\t\tvma->vm_end);",
            "\t\t\ttlb_gather_mmu(&tlb, mm);",
            "\t\t\tif (mmu_notifier_invalidate_range_start_nonblock(&range)) {",
            "\t\t\t\ttlb_finish_mmu(&tlb);",
            "\t\t\t\tret = false;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tunmap_page_range(&tlb, vma, range.start, range.end, NULL);",
            "\t\t\tmmu_notifier_invalidate_range_end(&range);",
            "\t\t\ttlb_finish_mmu(&tlb);",
            "\t\t}",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)",
            "{",
            "\tbool ret = true;",
            "",
            "\tif (!mmap_read_trylock(mm)) {",
            "\t\ttrace_skip_task_reaping(tsk->pid);",
            "\t\treturn false;",
            "\t}",
            "",
            "\t/*",
            "\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't",
            "\t * work on the mm anymore. The check for MMF_OOM_SKIP must run",
            "\t * under mmap_lock for reading because it serializes against the",
            "\t * mmap_write_lock();mmap_write_unlock() cycle in exit_mmap().",
            "\t */",
            "\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {",
            "\t\ttrace_skip_task_reaping(tsk->pid);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\ttrace_start_task_reaping(tsk->pid);",
            "",
            "\t/* failed to reap part of the address space. Try again later */",
            "\tret = __oom_reap_task_mm(mm);",
            "\tif (!ret)",
            "\t\tgoto out_finish;",
            "",
            "\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",",
            "\t\t\ttask_pid_nr(tsk), tsk->comm,",
            "\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),",
            "\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),",
            "\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));",
            "out_finish:",
            "\ttrace_finish_task_reaping(tsk->pid);",
            "out_unlock:",
            "\tmmap_read_unlock(mm);",
            "",
            "\treturn ret;",
            "}",
            "static void oom_reap_task(struct task_struct *tsk)",
            "{",
            "\tint attempts = 0;",
            "\tstruct mm_struct *mm = tsk->signal->oom_mm;",
            "",
            "\t/* Retry the mmap_read_trylock(mm) a few times */",
            "\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))",
            "\t\tschedule_timeout_idle(HZ/10);",
            "",
            "\tif (attempts <= MAX_OOM_REAP_RETRIES ||",
            "\t    test_bit(MMF_OOM_SKIP, &mm->flags))",
            "\t\tgoto done;",
            "",
            "\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",",
            "\t\ttask_pid_nr(tsk), tsk->comm);",
            "\tsched_show_task(tsk);",
            "\tdebug_show_all_locks();",
            "",
            "done:",
            "\ttsk->oom_reaper_list = NULL;",
            "",
            "\t/*",
            "\t * Hide this mm from OOM killer because it has been either reaped or",
            "\t * somebody can't call mmap_write_unlock(mm).",
            "\t */",
            "\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "",
            "\t/* Drop a reference taken by queue_oom_reaper */",
            "\tput_task_struct(tsk);",
            "}"
          ],
          "function_name": "process_shares_mm, __oom_reap_task_mm, oom_reap_task_mm, oom_reap_task",
          "description": "通过强制解除地址空间映射、清除MMF_OOM_SKIP标志等方式尝试回收选定进程的内存资源，最终标记该进程为不可再次被OOM杀手处理。",
          "similarity": 0.6001311540603638
        },
        {
          "chunk_id": 3,
          "file_path": "mm/oom_kill.c",
          "start_line": 366,
          "end_line": 466,
          "content": [
            "static void select_bad_process(struct oom_control *oc)",
            "{",
            "\toc->chosen_points = LONG_MIN;",
            "",
            "\tif (is_memcg_oom(oc))",
            "\t\tmem_cgroup_scan_tasks(oc->memcg, oom_evaluate_task, oc);",
            "\telse {",
            "\t\tstruct task_struct *p;",
            "",
            "\t\trcu_read_lock();",
            "\t\tfor_each_process(p)",
            "\t\t\tif (oom_evaluate_task(p, oc))",
            "\t\t\t\tbreak;",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static int dump_task(struct task_struct *p, void *arg)",
            "{",
            "\tstruct oom_control *oc = arg;",
            "\tstruct task_struct *task;",
            "",
            "\tif (oom_unkillable_task(p))",
            "\t\treturn 0;",
            "",
            "\t/* p may not have freeable memory in nodemask */",
            "\tif (!is_memcg_oom(oc) && !oom_cpuset_eligible(p, oc))",
            "\t\treturn 0;",
            "",
            "\ttask = find_lock_task_mm(p);",
            "\tif (!task) {",
            "\t\t/*",
            "\t\t * All of p's threads have already detached their mm's. There's",
            "\t\t * no need to report them; they can't be oom killed anyway.",
            "\t\t */",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tpr_info(\"[%7d] %5d %5d %8lu %8lu %8lu %8lu %9lu %8ld %8lu         %5hd %s\\n\",",
            "\t\ttask->pid, from_kuid(&init_user_ns, task_uid(task)),",
            "\t\ttask->tgid, task->mm->total_vm, get_mm_rss(task->mm),",
            "\t\tget_mm_counter(task->mm, MM_ANONPAGES), get_mm_counter(task->mm, MM_FILEPAGES),",
            "\t\tget_mm_counter(task->mm, MM_SHMEMPAGES), mm_pgtables_bytes(task->mm),",
            "\t\tget_mm_counter(task->mm, MM_SWAPENTS),",
            "\t\ttask->signal->oom_score_adj, task->comm);",
            "\ttask_unlock(task);",
            "",
            "\treturn 0;",
            "}",
            "static void dump_tasks(struct oom_control *oc)",
            "{",
            "\tpr_info(\"Tasks state (memory values in pages):\\n\");",
            "\tpr_info(\"[  pid  ]   uid  tgid total_vm      rss rss_anon rss_file rss_shmem pgtables_bytes swapents oom_score_adj name\\n\");",
            "",
            "\tif (is_memcg_oom(oc))",
            "\t\tmem_cgroup_scan_tasks(oc->memcg, dump_task, oc);",
            "\telse {",
            "\t\tstruct task_struct *p;",
            "\t\tint i = 0;",
            "",
            "\t\trcu_read_lock();",
            "\t\tfor_each_process(p) {",
            "\t\t\t/* Avoid potential softlockup warning */",
            "\t\t\tif ((++i & 1023) == 0)",
            "\t\t\t\ttouch_softlockup_watchdog();",
            "\t\t\tdump_task(p, oc);",
            "\t\t}",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static void dump_oom_summary(struct oom_control *oc, struct task_struct *victim)",
            "{",
            "\t/* one line summary of the oom killer context. */",
            "\tpr_info(\"oom-kill:constraint=%s,nodemask=%*pbl\",",
            "\t\t\toom_constraint_text[oc->constraint],",
            "\t\t\tnodemask_pr_args(oc->nodemask));",
            "\tcpuset_print_current_mems_allowed();",
            "\tmem_cgroup_print_oom_context(oc->memcg, victim);",
            "\tpr_cont(\",task=%s,pid=%d,uid=%d\\n\", victim->comm, victim->pid,",
            "\t\tfrom_kuid(&init_user_ns, task_uid(victim)));",
            "}",
            "static void dump_header(struct oom_control *oc, struct task_struct *p)",
            "{",
            "\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), order=%d, oom_score_adj=%hd\\n\",",
            "\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask, oc->order,",
            "\t\t\tcurrent->signal->oom_score_adj);",
            "\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)",
            "\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");",
            "",
            "\tdump_stack();",
            "\tif (is_memcg_oom(oc))",
            "\t\tmem_cgroup_print_oom_meminfo(oc->memcg);",
            "\telse {",
            "\t\t__show_mem(SHOW_MEM_FILTER_NODES, oc->nodemask, gfp_zone(oc->gfp_mask));",
            "\t\tif (should_dump_unreclaim_slab())",
            "\t\t\tdump_unreclaimable_slab();",
            "\t}",
            "\tif (sysctl_oom_dump_tasks)",
            "\t\tdump_tasks(oc);",
            "\tif (p)",
            "\t\tdump_oom_summary(oc, p);",
            "}"
          ],
          "function_name": "select_bad_process, dump_task, dump_tasks, dump_oom_summary, dump_header",
          "description": "遍历所有进程选择最优OOM目标，输出详细的进程内存状态信息，并生成OOM事件的上下文摘要报告。",
          "similarity": 0.5942872762680054
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_events_trigger.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:21:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_events_trigger.c`\n\n---\n\n# trace_events_trigger.c 技术文档\n\n## 文件概述\n\n`trace_events_trigger.c` 是 Linux 内核 ftrace 子系统中用于实现 **事件触发器（event triggers）** 的核心模块。该文件提供了在特定 trace event 被记录时自动执行自定义操作（如打印、堆栈跟踪、快照、启用/禁用其他事件等）的机制。触发器通过 tracefs 接口配置，支持运行时动态添加、删除和查询。\n\n## 核心功能\n\n### 主要数据结构\n\n- `struct event_trigger_data`：表示一个事件触发器实例，包含操作函数指针、命令操作、过滤器、状态标志等。\n- `struct event_command`：表示一种触发器命令类型（如 `stacktrace`、`snapshot`、`enable_event` 等），包含解析、注册、注销等回调。\n- `trigger_commands`：全局链表，注册所有可用的触发器命令类型。\n- `enum event_trigger_type`：用于标识触发器类型，特别是区分是否为“后置触发器”（post-trigger）。\n\n### 主要函数\n\n- `event_triggers_call()`：在事件发生时调用所有关联的触发器，根据过滤条件和触发器类型决定是否立即执行或延迟执行。\n- `event_triggers_post_call()`：执行被标记为延迟（post-trigger）的触发器。\n- `__trace_trigger_soft_disabled()`：在事件记录前检查是否应跳过记录（如因触发器或 PID 过滤）。\n- `trigger_process_regex()`：解析用户通过 tracefs 写入的触发器命令字符串。\n- `event_trigger_regex_write()` / `event_trigger_regex_open()`：tracefs 文件操作接口，用于配置和管理触发器。\n- `trigger_data_free()`：安全释放触发器数据结构，确保 RCU 同步。\n\n## 关键实现\n\n### 触发器执行流程\n\n1. **事件发生时**：`event_triggers_call()` 被调用（在 tracepoint handler 中，持有 `rcu_read_lock_sched()`）。\n2. **过滤检查**：若事件记录 `rec` 非空且触发器关联了过滤器，则调用 `filter_match_preds()` 进行匹配。\n3. **执行策略**：\n   - 若为 **后置触发器**（如 `snapshot`），仅设置返回值中的对应位，不立即执行。\n   - 否则，立即调用 `data->ops->trigger()` 执行触发动作。\n4. **后置执行**：事件写入 ring buffer 后，调用 `event_triggers_post_call()` 执行所有标记的后置触发器。\n\n### 触发器注册与管理\n\n- 所有触发器命令类型通过 `register_trigger_cmds()` 注册到全局链表 `trigger_commands`。\n- 用户通过向 `tracefs/events/<subsys>/<event>/trigger` 写入命令（如 `echo 'stacktrace:100' > trigger`）来添加触发器。\n- 命令解析由 `trigger_process_regex()` 完成，调用对应 `event_command` 的 `parse()` 方法。\n- 支持通过写入 `!command` 或清空文件（`O_TRUNC`）来移除触发器。\n\n### 并发与同步\n\n- **RCU 保护**：触发器链表遍历使用 `list_for_each_entry_rcu()`，确保在读取路径无锁。\n- **互斥锁保护**：\n  - `event_mutex`：保护 trace event 文件的触发器链表修改。\n  - `trigger_cmd_mutex`：保护全局触发器命令链表的遍历和修改。\n- **安全释放**：`trigger_data_free()` 调用 `tracepoint_synchronize_unregister()` 确保所有 CPU 退出 tracepoint handler 后才释放内存。\n\n### 特殊状态处理\n\n- **暂停状态**：`data->paused` 为真时跳过触发器执行。\n- **软禁用**：`__trace_trigger_soft_disabled()` 在事件记录前检查：\n  - 若设置了 `EVENT_FILE_FL_TRIGGER_MODE`，先执行无条件触发器（`rec=NULL`）。\n  - 若设置了 `EVENT_FILE_FL_SOFT_DISABLED` 或 PID 过滤不匹配，则跳过事件记录。\n\n## 依赖关系\n\n- **核心依赖**：\n  - `trace.h`：ftrace 核心头文件，定义 trace event、ring buffer、过滤器等基础结构。\n  - `trace_events.h`：事件触发器相关数据结构定义。\n- **子系统依赖**：\n  - **Tracepoint**：触发器挂载在 tracepoint 事件上，依赖 tracepoint 注册/注销机制。\n  - **Ring Buffer**：事件记录和触发器执行依赖 ring buffer 基础设施。\n  - **Security Framework**：通过 `security_locked_down(LOCKDOWN_TRACEFS)` 限制触发器配置。\n- **其他模块**：\n  - 具体触发器命令实现（如 `trace_events_filter.c` 中的 `enable_event`、`snapshot` 等）通过 `register_trigger_cmds()` 注册到本模块。\n\n## 使用场景\n\n1. **动态调试**：\n   - 在特定事件发生时自动捕获内核栈（`stacktrace` 触发器）。\n   - 在事件触发时保存当前 ring buffer 快照（`snapshot` 触发器）。\n\n2. **事件联动**：\n   - 当事件 A 发生时启用/禁用事件 B（`enable_event`/`disable_event` 触发器）。\n   - 实现复杂的事件链式响应。\n\n3. **性能分析**：\n   - 统计特定事件的发生次数（`hist` 触发器，需配合其他模块）。\n   - 在满足特定条件（通过过滤器）时记录事件上下文。\n\n4. **安全监控**：\n   - 在关键系统调用或内核路径触发时记录详细信息。\n   - 结合 lockdown 机制限制非特权用户配置触发器。\n\n5. **用户接口**：\n   - 通过 tracefs 文件系统（`/sys/kernel/tracing/events/.../trigger`）提供运行时配置接口。\n   - 支持查询可用触发器列表（读取 `trigger` 文件）。",
      "similarity": 0.5191342830657959,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_events_trigger.c",
          "start_line": 863,
          "end_line": 966,
          "content": [
            "int event_trigger_parse_num(char *param,",
            "\t\t\t    struct event_trigger_data *trigger_data)",
            "{",
            "\tchar *number;",
            "\tint ret = 0;",
            "",
            "\tif (param) {",
            "\t\tnumber = strsep(&param, \":\");",
            "",
            "\t\tif (!strlen(number))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * We use the callback data field (which is a pointer)",
            "\t\t * as our counter.",
            "\t\t */",
            "\t\tret = kstrtoul(number, 0, &trigger_data->count);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "int event_trigger_set_filter(struct event_command *cmd_ops,",
            "\t\t\t     struct trace_event_file *file,",
            "\t\t\t     char *param,",
            "\t\t\t     struct event_trigger_data *trigger_data)",
            "{",
            "\tif (param && cmd_ops->set_filter)",
            "\t\treturn cmd_ops->set_filter(param, trigger_data, file);",
            "",
            "\treturn 0;",
            "}",
            "void event_trigger_reset_filter(struct event_command *cmd_ops,",
            "\t\t\t\tstruct event_trigger_data *trigger_data)",
            "{",
            "\tif (cmd_ops->set_filter)",
            "\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);",
            "}",
            "int event_trigger_register(struct event_command *cmd_ops,",
            "\t\t\t   struct trace_event_file *file,",
            "\t\t\t   char *glob,",
            "\t\t\t   struct event_trigger_data *trigger_data)",
            "{",
            "\treturn cmd_ops->reg(glob, trigger_data, file);",
            "}",
            "void event_trigger_unregister(struct event_command *cmd_ops,",
            "\t\t\t      struct trace_event_file *file,",
            "\t\t\t      char *glob,",
            "\t\t\t      struct event_trigger_data *trigger_data)",
            "{",
            "\tcmd_ops->unreg(glob, trigger_data, file);",
            "}",
            "static int",
            "event_trigger_parse(struct event_command *cmd_ops,",
            "\t\t    struct trace_event_file *file,",
            "\t\t    char *glob, char *cmd, char *param_and_filter)",
            "{",
            "\tstruct event_trigger_data *trigger_data;",
            "\tchar *param, *filter;",
            "\tbool remove;",
            "\tint ret;",
            "",
            "\tremove = event_trigger_check_remove(glob);",
            "",
            "\tret = event_trigger_separate_filter(param_and_filter, &param, &filter, false);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = -ENOMEM;",
            "\ttrigger_data = trigger_data_alloc(cmd_ops, cmd, param, file);",
            "\tif (!trigger_data)",
            "\t\tgoto out;",
            "",
            "\tif (remove) {",
            "\t\tevent_trigger_unregister(cmd_ops, file, glob+1, trigger_data);",
            "\t\ttrigger_data_free(trigger_data);",
            "\t\tret = 0;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = event_trigger_parse_num(param, trigger_data);",
            "\tif (ret)",
            "\t\tgoto out_free;",
            "",
            "\tret = event_trigger_set_filter(cmd_ops, file, filter, trigger_data);",
            "\tif (ret < 0)",
            "\t\tgoto out_free;",
            "",
            "\t/* Up the trigger_data count to make sure reg doesn't free it on failure */",
            "\tevent_trigger_init(trigger_data);",
            "",
            "\tret = event_trigger_register(cmd_ops, file, glob, trigger_data);",
            "\tif (ret)",
            "\t\tgoto out_free;",
            "",
            "\t/* Down the counter of trigger_data or free it if not used anymore */",
            "\tevent_trigger_free(trigger_data);",
            " out:",
            "\treturn ret;",
            "",
            " out_free:",
            "\tevent_trigger_reset_filter(cmd_ops, trigger_data);",
            "\ttrigger_data_free(trigger_data);",
            "\tgoto out;",
            "}"
          ],
          "function_name": "event_trigger_parse_num, event_trigger_set_filter, event_trigger_reset_filter, event_trigger_register, event_trigger_unregister, event_trigger_parse",
          "description": "实现事件触发器参数解析及过滤器设置功能，用于解析数值参数、调用对应的cmd_ops->set_filter方法设置过滤器，并完成触发器注册与注销流程。",
          "similarity": 0.5628341436386108
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_events_trigger.c",
          "start_line": 20,
          "end_line": 121,
          "content": [
            "void trigger_data_free(struct event_trigger_data *data)",
            "{",
            "\tif (data->cmd_ops->set_filter)",
            "\t\tdata->cmd_ops->set_filter(NULL, data, NULL);",
            "",
            "\t/* make sure current triggers exit before free */",
            "\ttracepoint_synchronize_unregister();",
            "",
            "\tkfree(data);",
            "}",
            "enum event_trigger_type",
            "event_triggers_call(struct trace_event_file *file,",
            "\t\t    struct trace_buffer *buffer, void *rec,",
            "\t\t    struct ring_buffer_event *event)",
            "{",
            "\tstruct event_trigger_data *data;",
            "\tenum event_trigger_type tt = ETT_NONE;",
            "\tstruct event_filter *filter;",
            "",
            "\tif (list_empty(&file->triggers))",
            "\t\treturn tt;",
            "",
            "\tlist_for_each_entry_rcu(data, &file->triggers, list) {",
            "\t\tif (data->paused)",
            "\t\t\tcontinue;",
            "\t\tif (!rec) {",
            "\t\t\tdata->ops->trigger(data, buffer, rec, event);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tfilter = rcu_dereference_sched(data->filter);",
            "\t\tif (filter && !filter_match_preds(filter, rec))",
            "\t\t\tcontinue;",
            "\t\tif (event_command_post_trigger(data->cmd_ops)) {",
            "\t\t\ttt |= data->cmd_ops->trigger_type;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tdata->ops->trigger(data, buffer, rec, event);",
            "\t}",
            "\treturn tt;",
            "}",
            "bool __trace_trigger_soft_disabled(struct trace_event_file *file)",
            "{",
            "\tunsigned long eflags = file->flags;",
            "",
            "\tif (eflags & EVENT_FILE_FL_TRIGGER_MODE)",
            "\t\tevent_triggers_call(file, NULL, NULL, NULL);",
            "\tif (eflags & EVENT_FILE_FL_SOFT_DISABLED)",
            "\t\treturn true;",
            "\tif (eflags & EVENT_FILE_FL_PID_FILTER)",
            "\t\treturn trace_event_ignore_this_pid(file);",
            "\treturn false;",
            "}",
            "void",
            "event_triggers_post_call(struct trace_event_file *file,",
            "\t\t\t enum event_trigger_type tt)",
            "{",
            "\tstruct event_trigger_data *data;",
            "",
            "\tlist_for_each_entry_rcu(data, &file->triggers, list) {",
            "\t\tif (data->paused)",
            "\t\t\tcontinue;",
            "\t\tif (data->cmd_ops->trigger_type & tt)",
            "\t\t\tdata->ops->trigger(data, NULL, NULL, NULL);",
            "\t}",
            "}",
            "static bool check_user_trigger(struct trace_event_file *file)",
            "{",
            "\tstruct event_trigger_data *data;",
            "",
            "\tlist_for_each_entry_rcu(data, &file->triggers, list,",
            "\t\t\t\tlockdep_is_held(&event_mutex)) {",
            "\t\tif (data->flags & EVENT_TRIGGER_FL_PROBE)",
            "\t\t\tcontinue;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static void trigger_stop(struct seq_file *m, void *t)",
            "{",
            "\tmutex_unlock(&event_mutex);",
            "}",
            "static int trigger_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct event_trigger_data *data;",
            "\tstruct event_command *p;",
            "",
            "\tif (v == SHOW_AVAILABLE_TRIGGERS) {",
            "\t\tseq_puts(m, \"# Available triggers:\\n\");",
            "\t\tseq_putc(m, '#');",
            "\t\tmutex_lock(&trigger_cmd_mutex);",
            "\t\tlist_for_each_entry_reverse(p, &trigger_commands, list)",
            "\t\t\tseq_printf(m, \" %s\", p->name);",
            "\t\tseq_putc(m, '\\n');",
            "\t\tmutex_unlock(&trigger_cmd_mutex);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tdata = list_entry(v, struct event_trigger_data, list);",
            "\tdata->ops->print(m, data);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "trigger_data_free, event_triggers_call, __trace_trigger_soft_disabled, event_triggers_post_call, check_user_trigger, trigger_stop, trigger_show",
          "description": "实现触发器数据释放、事件触发调用、软禁用检测、触发后处理及用户触发检查等功能。",
          "similarity": 0.5369188785552979
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_events_trigger.c",
          "start_line": 506,
          "end_line": 644,
          "content": [
            "void",
            "clear_event_triggers(struct trace_array *tr)",
            "{",
            "\tstruct trace_event_file *file;",
            "",
            "\tlist_for_each_entry(file, &tr->events, list) {",
            "\t\tstruct event_trigger_data *data, *n;",
            "\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {",
            "\t\t\ttrace_event_trigger_enable_disable(file, 0);",
            "\t\t\tlist_del_rcu(&data->list);",
            "\t\t\tif (data->ops->free)",
            "\t\t\t\tdata->ops->free(data);",
            "\t\t}",
            "\t}",
            "}",
            "void update_cond_flag(struct trace_event_file *file)",
            "{",
            "\tstruct event_trigger_data *data;",
            "\tbool set_cond = false;",
            "",
            "\tlockdep_assert_held(&event_mutex);",
            "",
            "\tlist_for_each_entry(data, &file->triggers, list) {",
            "\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||",
            "\t\t    event_command_needs_rec(data->cmd_ops)) {",
            "\t\t\tset_cond = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (set_cond)",
            "\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);",
            "\telse",
            "\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);",
            "}",
            "static int register_trigger(char *glob,",
            "\t\t\t    struct event_trigger_data *data,",
            "\t\t\t    struct trace_event_file *file)",
            "{",
            "\tstruct event_trigger_data *test;",
            "\tint ret = 0;",
            "",
            "\tlockdep_assert_held(&event_mutex);",
            "",
            "\tlist_for_each_entry(test, &file->triggers, list) {",
            "\t\tif (test->cmd_ops->trigger_type == data->cmd_ops->trigger_type) {",
            "\t\t\tret = -EEXIST;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (data->ops->init) {",
            "\t\tret = data->ops->init(data);",
            "\t\tif (ret < 0)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tlist_add_rcu(&data->list, &file->triggers);",
            "",
            "\tupdate_cond_flag(file);",
            "\tret = trace_event_trigger_enable_disable(file, 1);",
            "\tif (ret < 0) {",
            "\t\tlist_del_rcu(&data->list);",
            "\t\tupdate_cond_flag(file);",
            "\t}",
            "out:",
            "\treturn ret;",
            "}",
            "static void unregister_trigger(char *glob,",
            "\t\t\t       struct event_trigger_data *test,",
            "\t\t\t       struct trace_event_file *file)",
            "{",
            "\tstruct event_trigger_data *data = NULL, *iter;",
            "",
            "\tlockdep_assert_held(&event_mutex);",
            "",
            "\tlist_for_each_entry(iter, &file->triggers, list) {",
            "\t\tif (iter->cmd_ops->trigger_type == test->cmd_ops->trigger_type) {",
            "\t\t\tdata = iter;",
            "\t\t\tlist_del_rcu(&data->list);",
            "\t\t\ttrace_event_trigger_enable_disable(file, 0);",
            "\t\t\tupdate_cond_flag(file);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (data && data->ops->free)",
            "\t\tdata->ops->free(data);",
            "}",
            "bool event_trigger_check_remove(const char *glob)",
            "{",
            "\treturn (glob && glob[0] == '!') ? true : false;",
            "}",
            "bool event_trigger_empty_param(const char *param)",
            "{",
            "\treturn !param;",
            "}",
            "int event_trigger_separate_filter(char *param_and_filter, char **param,",
            "\t\t\t\t  char **filter, bool param_required)",
            "{",
            "\tint ret = 0;",
            "",
            "\t*param = *filter = NULL;",
            "",
            "\tif (!param_and_filter) {",
            "\t\tif (param_required)",
            "\t\t\tret = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * Here we check for an optional param. The only legal",
            "\t * optional param is :n, and if that's the case, continue",
            "\t * below. Otherwise we assume what's left is a filter and",
            "\t * return it as the filter string for the caller to deal with.",
            "\t */",
            "\tif (!param_required && param_and_filter && !isdigit(param_and_filter[0])) {",
            "\t\t*filter = param_and_filter;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * Separate the param from the filter (param [if filter]).",
            "\t * Here we have either an optional :n param or a required",
            "\t * param and an optional filter.",
            "\t */",
            "\t*param = strsep(&param_and_filter, \" \\t\");",
            "",
            "\t/*",
            "\t * Here we have a filter, though it may be empty.",
            "\t */",
            "\tif (param_and_filter) {",
            "\t\t*filter = skip_spaces(param_and_filter);",
            "\t\tif (!**filter)",
            "\t\t\t*filter = NULL;",
            "\t}",
            "out:",
            "\treturn ret;",
            "}"
          ],
          "function_name": "clear_event_triggers, update_cond_flag, register_trigger, unregister_trigger, event_trigger_check_remove, event_trigger_empty_param, event_trigger_separate_filter",
          "description": "实现触发器动态注册/取消逻辑，维护触发器状态标志，并支持过滤条件分离与参数解析。",
          "similarity": 0.5174344778060913
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/trace/trace_events_trigger.c",
          "start_line": 1624,
          "end_line": 1808,
          "content": [
            "static __init int register_trigger_stacktrace_cmd(void) { return 0; }",
            "static __init void unregister_trigger_traceon_traceoff_cmds(void)",
            "{",
            "\tunregister_event_command(&trigger_traceon_cmd);",
            "\tunregister_event_command(&trigger_traceoff_cmd);",
            "}",
            "static void",
            "event_enable_trigger(struct event_trigger_data *data,",
            "\t\t     struct trace_buffer *buffer,  void *rec,",
            "\t\t     struct ring_buffer_event *event)",
            "{",
            "\tstruct enable_trigger_data *enable_data = data->private_data;",
            "",
            "\tif (enable_data->enable)",
            "\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);",
            "\telse",
            "\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);",
            "}",
            "static void",
            "event_enable_count_trigger(struct event_trigger_data *data,",
            "\t\t\t   struct trace_buffer *buffer,  void *rec,",
            "\t\t\t   struct ring_buffer_event *event)",
            "{",
            "\tstruct enable_trigger_data *enable_data = data->private_data;",
            "",
            "\tif (!data->count)",
            "\t\treturn;",
            "",
            "\t/* Skip if the event is in a state we want to switch to */",
            "\tif (enable_data->enable == !(enable_data->file->flags & EVENT_FILE_FL_SOFT_DISABLED))",
            "\t\treturn;",
            "",
            "\tif (data->count != -1)",
            "\t\t(data->count)--;",
            "",
            "\tevent_enable_trigger(data, buffer, rec, event);",
            "}",
            "int event_enable_trigger_print(struct seq_file *m,",
            "\t\t\t       struct event_trigger_data *data)",
            "{",
            "\tstruct enable_trigger_data *enable_data = data->private_data;",
            "",
            "\tseq_printf(m, \"%s:%s:%s\",",
            "\t\t   enable_data->hist ?",
            "\t\t   (enable_data->enable ? ENABLE_HIST_STR : DISABLE_HIST_STR) :",
            "\t\t   (enable_data->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR),",
            "\t\t   enable_data->file->event_call->class->system,",
            "\t\t   trace_event_name(enable_data->file->event_call));",
            "",
            "\tif (data->count == -1)",
            "\t\tseq_puts(m, \":unlimited\");",
            "\telse",
            "\t\tseq_printf(m, \":count=%ld\", data->count);",
            "",
            "\tif (data->filter_str)",
            "\t\tseq_printf(m, \" if %s\\n\", data->filter_str);",
            "\telse",
            "\t\tseq_putc(m, '\\n');",
            "",
            "\treturn 0;",
            "}",
            "void event_enable_trigger_free(struct event_trigger_data *data)",
            "{",
            "\tstruct enable_trigger_data *enable_data = data->private_data;",
            "",
            "\tif (WARN_ON_ONCE(data->ref <= 0))",
            "\t\treturn;",
            "",
            "\tdata->ref--;",
            "\tif (!data->ref) {",
            "\t\t/* Remove the SOFT_MODE flag */",
            "\t\ttrace_event_enable_disable(enable_data->file, 0, 1);",
            "\t\ttrace_event_put_ref(enable_data->file->event_call);",
            "\t\ttrigger_data_free(data);",
            "\t\tkfree(enable_data);",
            "\t}",
            "}",
            "int event_enable_trigger_parse(struct event_command *cmd_ops,",
            "\t\t\t       struct trace_event_file *file,",
            "\t\t\t       char *glob, char *cmd, char *param_and_filter)",
            "{",
            "\tstruct trace_event_file *event_enable_file;",
            "\tstruct enable_trigger_data *enable_data;",
            "\tstruct event_trigger_data *trigger_data;",
            "\tstruct trace_array *tr = file->tr;",
            "\tchar *param, *filter;",
            "\tbool enable, remove;",
            "\tconst char *system;",
            "\tconst char *event;",
            "\tbool hist = false;",
            "\tint ret;",
            "",
            "\tremove = event_trigger_check_remove(glob);",
            "",
            "\tif (event_trigger_empty_param(param_and_filter))",
            "\t\treturn -EINVAL;",
            "",
            "\tret = event_trigger_separate_filter(param_and_filter, &param, &filter, true);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tsystem = strsep(&param, \":\");",
            "\tif (!param)",
            "\t\treturn -EINVAL;",
            "",
            "\tevent = strsep(&param, \":\");",
            "",
            "\tret = -EINVAL;",
            "\tevent_enable_file = find_event_file(tr, system, event);",
            "\tif (!event_enable_file)",
            "\t\tgoto out;",
            "",
            "#ifdef CONFIG_HIST_TRIGGERS",
            "\thist = ((strcmp(cmd, ENABLE_HIST_STR) == 0) ||",
            "\t\t(strcmp(cmd, DISABLE_HIST_STR) == 0));",
            "",
            "\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||",
            "\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));",
            "#else",
            "\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;",
            "#endif",
            "\tret = -ENOMEM;",
            "",
            "\tenable_data = kzalloc(sizeof(*enable_data), GFP_KERNEL);",
            "\tif (!enable_data)",
            "\t\tgoto out;",
            "",
            "\tenable_data->hist = hist;",
            "\tenable_data->enable = enable;",
            "\tenable_data->file = event_enable_file;",
            "",
            "\ttrigger_data = trigger_data_alloc(cmd_ops, cmd, param, enable_data);",
            "\tif (!trigger_data) {",
            "\t\tkfree(enable_data);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (remove) {",
            "\t\tevent_trigger_unregister(cmd_ops, file, glob+1, trigger_data);",
            "\t\tkfree(trigger_data);",
            "\t\tkfree(enable_data);",
            "\t\tret = 0;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Up the trigger_data count to make sure nothing frees it on failure */",
            "\tevent_trigger_init(trigger_data);",
            "",
            "\tret = event_trigger_parse_num(param, trigger_data);",
            "\tif (ret)",
            "\t\tgoto out_free;",
            "",
            "\tret = event_trigger_set_filter(cmd_ops, file, filter, trigger_data);",
            "\tif (ret < 0)",
            "\t\tgoto out_free;",
            "",
            "\t/* Don't let event modules unload while probe registered */",
            "\tret = trace_event_try_get_ref(event_enable_file->event_call);",
            "\tif (!ret) {",
            "\t\tret = -EBUSY;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\tret = trace_event_enable_disable(event_enable_file, 1, 1);",
            "\tif (ret < 0)",
            "\t\tgoto out_put;",
            "",
            "\tret = event_trigger_register(cmd_ops, file, glob, trigger_data);",
            "\tif (ret)",
            "\t\tgoto out_disable;",
            "",
            "\tevent_trigger_free(trigger_data);",
            " out:",
            "\treturn ret;",
            " out_disable:",
            "\ttrace_event_enable_disable(event_enable_file, 0, 1);",
            " out_put:",
            "\ttrace_event_put_ref(event_enable_file->event_call);",
            " out_free:",
            "\tevent_trigger_reset_filter(cmd_ops, trigger_data);",
            "\tevent_trigger_free(trigger_data);",
            "\tkfree(enable_data);",
            "",
            "\tgoto out;",
            "}"
          ],
          "function_name": "register_trigger_stacktrace_cmd, unregister_trigger_traceon_traceoff_cmds, event_enable_trigger, event_enable_count_trigger, event_enable_trigger_print, event_enable_trigger_free, event_enable_trigger_parse",
          "description": "实现事件启用/禁用触发器的解析与控制逻辑，包含启用状态切换、计数器控制、资源引用管理及触发器参数解析等完整生命周期处理。",
          "similarity": 0.5135398507118225
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/trace/trace_events_trigger.c",
          "start_line": 1222,
          "end_line": 1326,
          "content": [
            "void pause_named_trigger(struct event_trigger_data *data)",
            "{",
            "\t__pause_named_trigger(data, true);",
            "}",
            "void unpause_named_trigger(struct event_trigger_data *data)",
            "{",
            "\t__pause_named_trigger(data, false);",
            "}",
            "void set_named_trigger_data(struct event_trigger_data *data,",
            "\t\t\t    struct event_trigger_data *named_data)",
            "{",
            "\tdata->named_data = named_data;",
            "}",
            "static void",
            "traceon_trigger(struct event_trigger_data *data,",
            "\t\tstruct trace_buffer *buffer, void *rec,",
            "\t\tstruct ring_buffer_event *event)",
            "{",
            "\tstruct trace_event_file *file = data->private_data;",
            "",
            "\tif (file) {",
            "\t\tif (tracer_tracing_is_on(file->tr))",
            "\t\t\treturn;",
            "",
            "\t\ttracer_tracing_on(file->tr);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (tracing_is_on())",
            "\t\treturn;",
            "",
            "\ttracing_on();",
            "}",
            "static void",
            "traceon_count_trigger(struct event_trigger_data *data,",
            "\t\t      struct trace_buffer *buffer, void *rec,",
            "\t\t      struct ring_buffer_event *event)",
            "{",
            "\tstruct trace_event_file *file = data->private_data;",
            "",
            "\tif (file) {",
            "\t\tif (tracer_tracing_is_on(file->tr))",
            "\t\t\treturn;",
            "\t} else {",
            "\t\tif (tracing_is_on())",
            "\t\t\treturn;",
            "\t}",
            "",
            "\tif (!data->count)",
            "\t\treturn;",
            "",
            "\tif (data->count != -1)",
            "\t\t(data->count)--;",
            "",
            "\tif (file)",
            "\t\ttracer_tracing_on(file->tr);",
            "\telse",
            "\t\ttracing_on();",
            "}",
            "static void",
            "traceoff_trigger(struct event_trigger_data *data,",
            "\t\t struct trace_buffer *buffer, void *rec,",
            "\t\t struct ring_buffer_event *event)",
            "{",
            "\tstruct trace_event_file *file = data->private_data;",
            "",
            "\tif (file) {",
            "\t\tif (!tracer_tracing_is_on(file->tr))",
            "\t\t\treturn;",
            "",
            "\t\ttracer_tracing_off(file->tr);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!tracing_is_on())",
            "\t\treturn;",
            "",
            "\ttracing_off();",
            "}",
            "static void",
            "traceoff_count_trigger(struct event_trigger_data *data,",
            "\t\t       struct trace_buffer *buffer, void *rec,",
            "\t\t       struct ring_buffer_event *event)",
            "{",
            "\tstruct trace_event_file *file = data->private_data;",
            "",
            "\tif (file) {",
            "\t\tif (!tracer_tracing_is_on(file->tr))",
            "\t\t\treturn;",
            "\t} else {",
            "\t\tif (!tracing_is_on())",
            "\t\t\treturn;",
            "\t}",
            "",
            "\tif (!data->count)",
            "\t\treturn;",
            "",
            "\tif (data->count != -1)",
            "\t\t(data->count)--;",
            "",
            "\tif (file)",
            "\t\ttracer_tracing_off(file->tr);",
            "\telse",
            "\t\ttracing_off();",
            "}"
          ],
          "function_name": "pause_named_trigger, unpause_named_trigger, set_named_trigger_data, traceon_trigger, traceon_count_trigger, traceoff_trigger, traceoff_count_trigger",
          "description": "实现traceon/tracoff/snapshot/stacktrace等触发器的具体行为，根据触发器类型执行开启/关闭跟踪、生成快照或堆栈跟踪等操作。",
          "similarity": 0.5130822658538818
        }
      ]
    },
    {
      "source_file": "kernel/power/process.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:23:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\process.c`\n\n---\n\n# `power/process.c` 技术文档\n\n## 1. 文件概述\n\n`power/process.c` 是 Linux 内核电源管理子系统中的关键文件，负责在系统挂起（suspend）过程中冻结（freeze）和解冻（thaw）用户空间进程及可冻结的内核线程。该机制确保在系统进入低功耗状态前，所有可冻结任务已暂停执行，避免在挂起期间发生不一致状态或资源竞争；在恢复时再安全地唤醒这些任务。此功能最初源自 swsusp（Software Suspend）项目，现已成为通用冻结框架的一部分。\n\n## 2. 核心功能\n\n### 全局变量\n- `freeze_timeout_msecs`：冻结任务的超时时间（默认 20 秒），标记为 `__read_mostly` 以优化缓存。\n\n### 主要函数\n- `try_to_freeze_tasks(bool user_only)`：尝试冻结指定范围内的任务（仅用户进程或包括内核线程）。\n- `freeze_processes(void)`：冻结所有用户空间进程，并禁用用户模式辅助程序（usermodehelper）和 OOM killer。\n- `freeze_kernel_threads(void)`：冻结所有可冻结的内核线程（在用户进程已冻结后调用）。\n- `thaw_processes(void)`：解冻所有任务（包括用户进程和内核线程），并重新启用 OOM killer 和 usermodehelper。\n- `thaw_kernel_threads(void)`：仅解冻内核线程（用于错误恢复或分阶段解冻）。\n\n### 辅助机制\n- 使用 `PF_SUSPEND_TASK` 标志标记当前执行冻结操作的进程，防止其自身被冻结。\n- 通过 `freezer_active` 静态分支优化冻结状态的判断性能。\n- 集成 tracepoint（`trace_suspend_resume`）用于跟踪冻结/解冻事件。\n\n## 3. 关键实现\n\n### 冻结流程 (`try_to_freeze_tasks`)\n1. **初始化**：记录开始时间，设置超时阈值（基于 `freeze_timeout_msecs`）。\n2. **工作队列冻结**：若 `user_only=false`，调用 `freeze_workqueues_begin()` 开始冻结工作队列。\n3. **遍历任务**：通过 `for_each_process_thread` 遍历所有进程和线程，对每个非当前任务调用 `freeze_task()` 发送冻结信号。\n4. **重试与退避**：若仍有任务未冻结且未超时，使用指数退避策略（1ms → 2ms → 4ms → 8ms）进行短暂休眠后重试。\n5. **中断处理**：若在冻结过程中检测到唤醒事件（`pm_wakeup_pending()`），立即中止冻结。\n6. **错误诊断**：冻结失败时，打印未冻结任务列表（通过 `sched_show_task`）和繁忙的工作队列信息（`show_freezable_workqueues`）。\n\n### 用户进程冻结 (`freeze_processes`)\n- 禁用 `usermodehelper`（防止挂起期间加载内核模块）。\n- 设置当前任务 `PF_SUSPEND_TASK` 标志以豁免自身。\n- 激活全局冻结状态（`pm_freezing = true`）。\n- 冻结用户进程后，禁用 OOM killer（防止其在冻结期间杀死任务导致状态不一致）。\n- 若冻结失败，自动调用 `thaw_processes` 回滚状态。\n\n### 内核线程冻结 (`freeze_kernel_threads`)\n- 设置 `pm_nosig_freezing = true` 表示进入无信号冻结阶段（仅影响内核线程）。\n- 调用 `try_to_freeze_tasks(false)` 冻结剩余可冻结任务（包括内核线程和工作队列）。\n- 失败时仅解冻内核线程（`thaw_kernel_threads`），由调用者负责后续用户进程解冻。\n\n### 解冻流程 (`thaw_processes`)\n- 清除全局冻结标志，重新启用 OOM killer 和 usermodehelper。\n- 遍历所有任务，调用 `__thaw_task` 清除冻结状态。\n- 显式调用 `schedule()` 触发调度，确保解冻任务能及时运行。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/freezer.h>`：提供 `freeze_task`、`__thaw_task` 等冻结核心接口。\n  - `<linux/suspend.h>`：定义 `pm_freezing`、`pm_wakeup_pending` 等电源管理状态变量。\n  - `<linux/oom.h>`：提供 OOM killer 启用/禁用接口。\n  - `<linux/workqueue.h>`：提供工作队列冻结/解冻支持。\n  - `<trace/events/power.h>`：提供 suspend/resume 跟踪点。\n- **模块交互**：\n  - 与 **OOM killer** 协同：冻结期间禁用 OOM，防止干扰冻结任务。\n  - 与 **usermodehelper** 协同：冻结期间禁用用户模式辅助程序，避免挂起时执行外部命令。\n  - 与 **工作队列子系统** 协同：通过 `freeze_workqueues_begin`/`thaw_workqueues` 管理工作项执行。\n  - 与 **调度器** 协同：通过 `sched_show_task` 诊断冻结失败任务。\n\n## 5. 使用场景\n\n- **系统挂起（Suspend-to-RAM/Disk）**：\n  1. `freeze_processes()` 冻结用户空间进程。\n  2. `freeze_kernel_threads()` 冻结内核线程。\n  3. 系统进入低功耗状态。\n  4. 唤醒后，`thaw_processes()` 解冻所有任务。\n- **休眠（Hibernation）**：在保存内存镜像前冻结所有任务，确保系统状态一致性。\n- **错误恢复**：若冻结过程因超时或唤醒事件失败，自动回滚解冻状态，保证系统可用性。\n- **调试支持**：通过 `pm_debug_messages_on` 控制冻结失败时的详细任务信息输出，辅助诊断冻结问题。",
      "similarity": 0.4982606768608093,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/power/process.c",
          "start_line": 28,
          "end_line": 147,
          "content": [
            "static int try_to_freeze_tasks(bool user_only)",
            "{",
            "\tconst char *what = user_only ? \"user space processes\" :",
            "\t\t\t\t\t\"remaining freezable tasks\";",
            "\tstruct task_struct *g, *p;",
            "\tunsigned long end_time;",
            "\tunsigned int todo;",
            "\tbool wq_busy = false;",
            "\tktime_t start, end, elapsed;",
            "\tunsigned int elapsed_msecs;",
            "\tbool wakeup = false;",
            "\tint sleep_usecs = USEC_PER_MSEC;",
            "",
            "\tpr_info(\"Freezing %s\\n\", what);",
            "",
            "\tstart = ktime_get_boottime();",
            "",
            "\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);",
            "",
            "\tif (!user_only)",
            "\t\tfreeze_workqueues_begin();",
            "",
            "\twhile (true) {",
            "\t\ttodo = 0;",
            "\t\tread_lock(&tasklist_lock);",
            "\t\tfor_each_process_thread(g, p) {",
            "\t\t\tif (p == current || !freeze_task(p))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\ttodo++;",
            "\t\t}",
            "\t\tread_unlock(&tasklist_lock);",
            "",
            "\t\tif (!user_only) {",
            "\t\t\twq_busy = freeze_workqueues_busy();",
            "\t\t\ttodo += wq_busy;",
            "\t\t}",
            "",
            "\t\tif (!todo || time_after(jiffies, end_time))",
            "\t\t\tbreak;",
            "",
            "\t\tif (pm_wakeup_pending()) {",
            "\t\t\twakeup = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * We need to retry, but first give the freezing tasks some",
            "\t\t * time to enter the refrigerator.  Start with an initial",
            "\t\t * 1 ms sleep followed by exponential backoff until 8 ms.",
            "\t\t */",
            "\t\tusleep_range(sleep_usecs / 2, sleep_usecs);",
            "\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)",
            "\t\t\tsleep_usecs *= 2;",
            "\t}",
            "",
            "\tend = ktime_get_boottime();",
            "\telapsed = ktime_sub(end, start);",
            "\telapsed_msecs = ktime_to_ms(elapsed);",
            "",
            "\tif (todo) {",
            "\t\tpr_err(\"Freezing %s %s after %d.%03d seconds \"",
            "\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\", what,",
            "\t\t       wakeup ? \"aborted\" : \"failed\",",
            "\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,",
            "\t\t       todo - wq_busy, wq_busy);",
            "",
            "\t\tif (wq_busy)",
            "\t\t\tshow_freezable_workqueues();",
            "",
            "\t\tif (!wakeup || pm_debug_messages_on) {",
            "\t\t\tread_lock(&tasklist_lock);",
            "\t\t\tfor_each_process_thread(g, p) {",
            "\t\t\t\tif (p != current && freezing(p) && !frozen(p))",
            "\t\t\t\t\tsched_show_task(p);",
            "\t\t\t}",
            "\t\t\tread_unlock(&tasklist_lock);",
            "\t\t}",
            "\t} else {",
            "\t\tpr_info(\"Freezing %s completed (elapsed %d.%03d seconds)\\n\",",
            "\t\t\twhat, elapsed_msecs / 1000, elapsed_msecs % 1000);",
            "\t}",
            "",
            "\treturn todo ? -EBUSY : 0;",
            "}",
            "int freeze_processes(void)",
            "{",
            "\tint error;",
            "",
            "\terror = __usermodehelper_disable(UMH_FREEZING);",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\t/* Make sure this task doesn't get frozen */",
            "\tcurrent->flags |= PF_SUSPEND_TASK;",
            "",
            "\tif (!pm_freezing)",
            "\t\tstatic_branch_inc(&freezer_active);",
            "",
            "\tpm_wakeup_clear(0);",
            "\tpm_freezing = true;",
            "\terror = try_to_freeze_tasks(true);",
            "\tif (!error)",
            "\t\t__usermodehelper_set_disable_depth(UMH_DISABLED);",
            "",
            "\tBUG_ON(in_atomic());",
            "",
            "\t/*",
            "\t * Now that the whole userspace is frozen we need to disable",
            "\t * the OOM killer to disallow any further interference with",
            "\t * killable tasks. There is no guarantee oom victims will",
            "\t * ever reach a point they go away we have to wait with a timeout.",
            "\t */",
            "\tif (!error && !oom_killer_disable(msecs_to_jiffies(freeze_timeout_msecs)))",
            "\t\terror = -EBUSY;",
            "",
            "\tif (error)",
            "\t\tthaw_processes();",
            "\treturn error;",
            "}"
          ],
          "function_name": "try_to_freeze_tasks, freeze_processes",
          "description": "try_to_freeze_tasks尝试冻结所有可冻结任务，通过遍历进程列表并处理工作队列实现；freeze_processes执行完整进程冻结流程，包括禁用用户模式辅助、标记冻结状态及处理OOM防护",
          "similarity": 0.41228461265563965
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/power/process.c",
          "start_line": 165,
          "end_line": 231,
          "content": [
            "int freeze_kernel_threads(void)",
            "{",
            "\tint error;",
            "",
            "\tpm_nosig_freezing = true;",
            "\terror = try_to_freeze_tasks(false);",
            "",
            "\tBUG_ON(in_atomic());",
            "",
            "\tif (error)",
            "\t\tthaw_kernel_threads();",
            "\treturn error;",
            "}",
            "void thaw_processes(void)",
            "{",
            "\tstruct task_struct *g, *p;",
            "\tstruct task_struct *curr = current;",
            "",
            "\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, true);",
            "\tif (pm_freezing)",
            "\t\tstatic_branch_dec(&freezer_active);",
            "\tpm_freezing = false;",
            "\tpm_nosig_freezing = false;",
            "",
            "\toom_killer_enable();",
            "",
            "\tpr_info(\"Restarting tasks: Starting\\n\");",
            "",
            "\t__usermodehelper_set_disable_depth(UMH_FREEZING);",
            "\tthaw_workqueues();",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, p) {",
            "\t\t/* No other threads should have PF_SUSPEND_TASK set */",
            "\t\tWARN_ON((p != curr) && (p->flags & PF_SUSPEND_TASK));",
            "\t\t__thaw_task(p);",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tWARN_ON(!(curr->flags & PF_SUSPEND_TASK));",
            "\tcurr->flags &= ~PF_SUSPEND_TASK;",
            "",
            "\tusermodehelper_enable();",
            "",
            "\tschedule();",
            "\tpr_info(\"Restarting tasks: Done\\n\");",
            "\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, false);",
            "}",
            "void thaw_kernel_threads(void)",
            "{",
            "\tstruct task_struct *g, *p;",
            "",
            "\tpm_nosig_freezing = false;",
            "\tpr_info(\"Restarting kernel threads ... \");",
            "",
            "\tthaw_workqueues();",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, p) {",
            "\t\tif (p->flags & PF_KTHREAD)",
            "\t\t\t__thaw_task(p);",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tschedule();",
            "\tpr_cont(\"done.\\n\");",
            "}"
          ],
          "function_name": "freeze_kernel_threads, thaw_processes, thaw_kernel_threads",
          "description": "freeze_kernel_threads冻结内核线程；thaw_processes解冻所有进程并恢复系统状态；thaw_kernel_threads专门解冻内核线程，三者协同完成睡眠状态转换期间的任务冻结与恢复操作",
          "similarity": 0.3897362947463989
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/power/process.c",
          "start_line": 1,
          "end_line": 27,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * drivers/power/process.c - Functions for starting/stopping processes on",
            " *                           suspend transitions.",
            " *",
            " * Originally from swsusp.",
            " */",
            "",
            "#include <linux/interrupt.h>",
            "#include <linux/oom.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kmod.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "",
            "/*",
            " * Timeout for stopping processes",
            " */",
            "unsigned int __read_mostly freeze_timeout_msecs = 20 * MSEC_PER_SEC;",
            ""
          ],
          "function_name": null,
          "description": "定义进程冻结操作的超时时间常量freeze_timeout_msecs，用于控制冻结进程的最大等待时间",
          "similarity": 0.3790026605129242
        }
      ]
    }
  ]
}