{
  "query": "FIFO创建",
  "timestamp": "2025-12-26 01:18:05",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/inode.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:12:33\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\inode.c`\n\n---\n\n# `bpf/inode.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/inode.c` 实现了一个轻量级的虚拟文件系统（称为 **bpffs**），用于支持 eBPF 对象（包括 BPF 程序、映射和链接）的 **pinning（持久化）机制**。该文件系统允许用户空间通过标准文件系统操作（如 `mkdir`、`create`、`unlink` 等）将 BPF 对象绑定到文件系统路径，从而在进程退出后仍能保持对这些对象的引用，避免被内核自动释放。此机制是 `bpf(2)` 系统调用中 `BPF_OBJ_PIN` 和 `BPF_OBJ_GET` 功能的后端支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `enum bpf_type`：枚举类型，标识 BPF 对象类型（`BPF_TYPE_PROG`、`BPF_TYPE_MAP`、`BPF_TYPE_LINK`）。\n- `struct map_iter`：用于 BPF map 序列化遍历的迭代器结构，包含当前 key 和完成标志。\n- `const struct inode_operations`：分别为目录、程序、映射、链接定义的 inode 操作集合（`bpf_dir_iops`、`bpf_prog_iops` 等）。\n- `const struct file_operations`：\n  - `bpffs_map_fops`：支持对支持 `seq_show` 的 BPF map 进行 `cat` 读取。\n  - `bpffs_obj_fops`：通用只读文件操作，打开即返回 `-EIO`，防止误操作。\n\n### 主要函数\n\n- `bpf_any_get()` / `bpf_any_put()`：根据对象类型统一增加/减少引用计数。\n- `bpf_fd_probe_obj()`：通过文件描述符探测并获取对应的 BPF 对象及其类型。\n- `bpf_get_inode()`：为 bpffs 创建新的 inode（支持目录、普通文件、符号链接）。\n- `bpf_inode_type()`：根据 inode 的 `i_op` 字段反推其对应的 BPF 对象类型。\n- `bpf_dentry_finalize()`：完成 dentry 与 inode 的绑定并更新父目录时间戳。\n- `bpf_mkdir()`：实现 bpffs 中的目录创建。\n- `bpf_mkprog()` / `bpf_mkmap()` / `bpf_mklink()`：分别创建 BPF 程序、映射、链接对应的文件 inode。\n- `map_iter_alloc()` / `map_iter_free()`：管理 map 遍历迭代器的生命周期。\n- `map_seq_*` 系列函数：实现 BPF map 的 `seq_file` 遍历接口，用于 `cat` 输出。\n- `bpffs_map_open()` / `bpffs_map_release()`：map 文件的打开与释放，初始化 seq_file 上下文。\n- `bpf_lookup()`：自定义 lookup 逻辑，禁止文件名中包含 `.`（保留用于未来扩展）。\n\n## 3. 关键实现\n\n### BPF 对象引用管理\n通过 `bpf_any_get()` 和 `bpf_any_put()` 封装不同 BPF 对象（prog/map/link）的引用计数操作，确保在 inode 创建和销毁时正确持有/释放内核对象，防止内存泄漏或提前释放。\n\n### 对象类型识别\n利用 `inode->i_op` 指针的唯一性（分别指向 `bpf_prog_iops`、`bpf_map_iops` 等空结构体）作为类型标签，在运行时通过指针比较快速判断 inode 对应的 BPF 对象类型。\n\n### BPF Map 的可读性支持\n对于支持 `map_seq_show_elem` 操作的 BPF map（如 hash、array 等），通过 `seq_file` 机制实现 `cat /sys/fs/bpf/map_name` 输出内容。输出包含警告信息，强调格式不稳定，仅用于调试。\n\n### 安全与扩展性设计\n- 文件名中禁止出现 `.` 字符（如 `foo.bar`），为未来在 bpffs 中引入特殊文件（如元数据、控制接口）预留命名空间。\n- 普通 BPF 对象文件（prog/link 或不支持 seq_show 的 map）使用 `bpffs_obj_fops`，其 `open` 返回 `-EIO`，防止用户误读/误写导致未定义行为。\n\n### 虚拟文件系统集成\n基于 `simple_fs` 框架（如 `simple_dir_operations`、`simple_lookup`）构建，仅重写必要操作（如 `mkdir`、`lookup`、`create` 逻辑由上层调用 `bpf_mk*` 实现），保持代码简洁。\n\n## 4. 依赖关系\n\n- **BPF 子系统核心**：依赖 `<linux/bpf.h>`、`<linux/filter.h>` 提供的 `bpf_prog_*`、`bpf_map_*`、`bpf_link_*` 等核心 API。\n- **VFS 层**：依赖标准 VFS 接口（`<linux/fs.h>`、`<linux/namei.h>`、`<linux/dcache.h>`）实现 inode、dentry、file 操作。\n- **预加载机制**：包含 `\"preload/bpf_preload.h\"`，可能用于内核启动时预加载 BPF 对象。\n- **迭代器支持**：若 BPF link 为 iterator 类型，会使用 `bpf_iter_fops`（定义在其他文件中）。\n\n## 5. 使用场景\n\n- **BPF 对象持久化**：用户空间工具（如 `bpftool`）调用 `bpf(BPF_OBJ_PIN, ...)` 将 map/prog/link pin 到 `/sys/fs/bpf/` 下的路径，内核通过本文件创建对应 inode 并持有对象引用。\n- **跨进程共享 BPF 对象**：多个进程可通过 `bpf(BPF_OBJ_GET, ...)` 从同一 bpffs 路径获取已 pin 对象的 fd，实现共享。\n- **调试与可观测性**：支持 `seq_show` 的 map 可通过 `cat` 命令查看内容，辅助开发调试（注意：非稳定接口）。\n- **系统启动预加载**：结合 `bpf_preload` 机制，在内核初始化阶段将关键 BPF 程序/映射 pin 到 bpffs，供后续服务使用。",
      "similarity": 0.5091885328292847,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 53,
          "end_line": 155,
          "content": [
            "static void bpf_any_put(void *raw, enum bpf_type type)",
            "{",
            "\tswitch (type) {",
            "\tcase BPF_TYPE_PROG:",
            "\t\tbpf_prog_put(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_MAP:",
            "\t\tbpf_map_put_with_uref(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_LINK:",
            "\t\tbpf_link_put(raw);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "}",
            "static int bpf_inode_type(const struct inode *inode, enum bpf_type *type)",
            "{",
            "\t*type = BPF_TYPE_UNSPEC;",
            "\tif (inode->i_op == &bpf_prog_iops)",
            "\t\t*type = BPF_TYPE_PROG;",
            "\telse if (inode->i_op == &bpf_map_iops)",
            "\t\t*type = BPF_TYPE_MAP;",
            "\telse if (inode->i_op == &bpf_link_iops)",
            "\t\t*type = BPF_TYPE_LINK;",
            "\telse",
            "\t\treturn -EACCES;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,",
            "\t\t\t\tstruct inode *dir)",
            "{",
            "\td_instantiate(dentry, inode);",
            "\tdget(dentry);",
            "",
            "\tdir->i_mtime = inode_set_ctime_current(dir);",
            "}",
            "static int bpf_mkdir(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t     struct dentry *dentry, umode_t mode)",
            "{",
            "\tstruct inode *inode;",
            "",
            "\tinode = bpf_get_inode(dir->i_sb, dir, mode | S_IFDIR);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_dir_iops;",
            "\tinode->i_fop = &simple_dir_operations;",
            "",
            "\tinc_nlink(inode);",
            "\tinc_nlink(dir);",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static void map_iter_free(struct map_iter *iter)",
            "{",
            "\tif (iter) {",
            "\t\tkfree(iter->key);",
            "\t\tkfree(iter);",
            "\t}",
            "}",
            "static void map_seq_stop(struct seq_file *m, void *v)",
            "{",
            "}",
            "static int map_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct bpf_map *map = seq_file_to_map(m);",
            "\tvoid *key = map_iter(m)->key;",
            "",
            "\tif (unlikely(v == SEQ_START_TOKEN)) {",
            "\t\tseq_puts(m, \"# WARNING!! The output is for debug purpose only\\n\");",
            "\t\tseq_puts(m, \"# WARNING!! The output format will change\\n\");",
            "\t} else {",
            "\t\tmap->ops->map_seq_show_elem(map, key, m);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int bpffs_map_open(struct inode *inode, struct file *file)",
            "{",
            "\tstruct bpf_map *map = inode->i_private;",
            "\tstruct map_iter *iter;",
            "\tstruct seq_file *m;",
            "\tint err;",
            "",
            "\titer = map_iter_alloc(map);",
            "\tif (!iter)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = seq_open(file, &bpffs_map_seq_ops);",
            "\tif (err) {",
            "\t\tmap_iter_free(iter);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tm = file->private_data;",
            "\tm->private = iter;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_any_put, bpf_inode_type, bpf_dentry_finalize, bpf_mkdir, map_iter_free, map_seq_stop, map_seq_show, bpffs_map_open",
          "description": "实现BPF对象引用释放逻辑，inode类型识别，目录创建，迭代器管理及序列化展示功能",
          "similarity": 0.5084091424942017
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 296,
          "end_line": 425,
          "content": [
            "static int bpffs_map_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seq_file *m = file->private_data;",
            "",
            "\tmap_iter_free(map_iter(m));",
            "",
            "\treturn seq_release(inode, file);",
            "}",
            "static int bpffs_obj_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn -EIO;",
            "}",
            "static int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,",
            "\t\t\t const struct inode_operations *iops,",
            "\t\t\t const struct file_operations *fops)",
            "{",
            "\tstruct inode *dir = dentry->d_parent->d_inode;",
            "\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = iops;",
            "\tinode->i_fop = fops;",
            "\tinode->i_private = raw;",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static int bpf_mkprog(struct dentry *dentry, umode_t mode, void *arg)",
            "{",
            "\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_prog_iops,",
            "\t\t\t     &bpffs_obj_fops);",
            "}",
            "static int bpf_mkmap(struct dentry *dentry, umode_t mode, void *arg)",
            "{",
            "\tstruct bpf_map *map = arg;",
            "",
            "\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_map_iops,",
            "\t\t\t     bpf_map_support_seq_show(map) ?",
            "\t\t\t     &bpffs_map_fops : &bpffs_obj_fops);",
            "}",
            "static int bpf_mklink(struct dentry *dentry, umode_t mode, void *arg)",
            "{",
            "\tstruct bpf_link *link = arg;",
            "",
            "\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_link_iops,",
            "\t\t\t     bpf_link_is_iter(link) ?",
            "\t\t\t     &bpf_iter_fops : &bpffs_obj_fops);",
            "}",
            "static int bpf_symlink(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t       struct dentry *dentry, const char *target)",
            "{",
            "\tchar *link = kstrdup(target, GFP_USER | __GFP_NOWARN);",
            "\tstruct inode *inode;",
            "",
            "\tif (!link)",
            "\t\treturn -ENOMEM;",
            "",
            "\tinode = bpf_get_inode(dir->i_sb, dir, S_IRWXUGO | S_IFLNK);",
            "\tif (IS_ERR(inode)) {",
            "\t\tkfree(link);",
            "\t\treturn PTR_ERR(inode);",
            "\t}",
            "",
            "\tinode->i_op = &simple_symlink_inode_operations;",
            "\tinode->i_link = link;",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static int bpf_iter_link_pin_kernel(struct dentry *parent,",
            "\t\t\t\t    const char *name, struct bpf_link *link)",
            "{",
            "\tumode_t mode = S_IFREG | S_IRUSR;",
            "\tstruct dentry *dentry;",
            "\tint ret;",
            "",
            "\tinode_lock(parent->d_inode);",
            "\tdentry = lookup_one_len(name, parent, strlen(name));",
            "\tif (IS_ERR(dentry)) {",
            "\t\tinode_unlock(parent->d_inode);",
            "\t\treturn PTR_ERR(dentry);",
            "\t}",
            "\tret = bpf_mkobj_ops(dentry, mode, link, &bpf_link_iops,",
            "\t\t\t    &bpf_iter_fops);",
            "\tdput(dentry);",
            "\tinode_unlock(parent->d_inode);",
            "\treturn ret;",
            "}",
            "static int bpf_obj_do_pin(int path_fd, const char __user *pathname, void *raw,",
            "\t\t\t  enum bpf_type type)",
            "{",
            "\tstruct dentry *dentry;",
            "\tstruct inode *dir;",
            "\tstruct path path;",
            "\tumode_t mode;",
            "\tint ret;",
            "",
            "\tdentry = user_path_create(path_fd, pathname, &path, 0);",
            "\tif (IS_ERR(dentry))",
            "\t\treturn PTR_ERR(dentry);",
            "",
            "\tdir = d_inode(path.dentry);",
            "\tif (dir->i_op != &bpf_dir_iops) {",
            "\t\tret = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tret = security_path_mknod(&path, dentry, mode, 0);",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tswitch (type) {",
            "\tcase BPF_TYPE_PROG:",
            "\t\tret = vfs_mkobj(dentry, mode, bpf_mkprog, raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_MAP:",
            "\t\tret = vfs_mkobj(dentry, mode, bpf_mkmap, raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_LINK:",
            "\t\tret = vfs_mkobj(dentry, mode, bpf_mklink, raw);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tret = -EPERM;",
            "\t}",
            "out:",
            "\tdone_path_create(&path, dentry);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpffs_map_release, bpffs_obj_open, bpf_mkobj_ops, bpf_mkprog, bpf_mkmap, bpf_mklink, bpf_symlink, bpf_iter_link_pin_kernel, bpf_obj_do_pin",
          "description": "提供对象创建接口，符号链接处理，链接对象挂载及对象pin操作实现",
          "similarity": 0.47161948680877686
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 1080,
          "end_line": 1100,
          "content": [
            "static void bpf_kill_super(struct super_block *sb)",
            "{",
            "\tstruct bpf_mount_opts *opts = sb->s_fs_info;",
            "",
            "\tkill_litter_super(sb);",
            "\tkfree(opts);",
            "}",
            "static int __init bpf_init(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = sysfs_create_mount_point(fs_kobj, \"bpf\");",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = register_filesystem(&bpf_fs_type);",
            "\tif (ret)",
            "\t\tsysfs_remove_mount_point(fs_kobj, \"bpf\");",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_kill_super, bpf_init",
          "description": "注销BPF文件系统时释放超级块资源，初始化BPF文件系统类型并注册到sysfs挂载点",
          "similarity": 0.46268776059150696
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 479,
          "end_line": 593,
          "content": [
            "int bpf_obj_pin_user(u32 ufd, int path_fd, const char __user *pathname)",
            "{",
            "\tenum bpf_type type;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\traw = bpf_fd_probe_obj(ufd, &type);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tret = bpf_obj_do_pin(path_fd, pathname, raw, type);",
            "\tif (ret != 0)",
            "\t\tbpf_any_put(raw, type);",
            "",
            "\treturn ret;",
            "}",
            "int bpf_obj_get_user(int path_fd, const char __user *pathname, int flags)",
            "{",
            "\tenum bpf_type type = BPF_TYPE_UNSPEC;",
            "\tint f_flags;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\tf_flags = bpf_get_file_flag(flags);",
            "\tif (f_flags < 0)",
            "\t\treturn f_flags;",
            "",
            "\traw = bpf_obj_do_get(path_fd, pathname, &type, f_flags);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tif (type == BPF_TYPE_PROG)",
            "\t\tret = bpf_prog_new_fd(raw);",
            "\telse if (type == BPF_TYPE_MAP)",
            "\t\tret = bpf_map_new_fd(raw, f_flags);",
            "\telse if (type == BPF_TYPE_LINK)",
            "\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);",
            "\telse",
            "\t\treturn -ENOENT;",
            "",
            "\tif (ret < 0)",
            "\t\tbpf_any_put(raw, type);",
            "\treturn ret;",
            "}",
            "static int find_bpffs_btf_enums(struct bpffs_btf_enums *info)",
            "{",
            "\tconst struct btf *btf;",
            "\tconst struct btf_type *t;",
            "\tconst char *name;",
            "\tint i, n;",
            "",
            "\tmemset(info, 0, sizeof(*info));",
            "",
            "\tbtf = bpf_get_btf_vmlinux();",
            "\tif (IS_ERR(btf))",
            "\t\treturn PTR_ERR(btf);",
            "\tif (!btf)",
            "\t\treturn -ENOENT;",
            "",
            "\tinfo->btf = btf;",
            "",
            "\tfor (i = 1, n = btf_nr_types(btf); i < n; i++) {",
            "\t\tt = btf_type_by_id(btf, i);",
            "\t\tif (!btf_type_is_enum(t))",
            "\t\t\tcontinue;",
            "",
            "\t\tname = btf_name_by_offset(btf, t->name_off);",
            "\t\tif (!name)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (strcmp(name, \"bpf_cmd\") == 0)",
            "\t\t\tinfo->cmd_t = t;",
            "\t\telse if (strcmp(name, \"bpf_map_type\") == 0)",
            "\t\t\tinfo->map_t = t;",
            "\t\telse if (strcmp(name, \"bpf_prog_type\") == 0)",
            "\t\t\tinfo->prog_t = t;",
            "\t\telse if (strcmp(name, \"bpf_attach_type\") == 0)",
            "\t\t\tinfo->attach_t = t;",
            "\t\telse",
            "\t\t\tcontinue;",
            "",
            "\t\tif (info->cmd_t && info->map_t && info->prog_t && info->attach_t)",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\treturn -ESRCH;",
            "}",
            "static bool find_btf_enum_const(const struct btf *btf, const struct btf_type *enum_t,",
            "\t\t\t\tconst char *prefix, const char *str, int *value)",
            "{",
            "\tconst struct btf_enum *e;",
            "\tconst char *name;",
            "\tint i, n, pfx_len = strlen(prefix);",
            "",
            "\t*value = 0;",
            "",
            "\tif (!btf || !enum_t)",
            "\t\treturn false;",
            "",
            "\tfor (i = 0, n = btf_vlen(enum_t); i < n; i++) {",
            "\t\te = &btf_enum(enum_t)[i];",
            "",
            "\t\tname = btf_name_by_offset(btf, e->name_off);",
            "\t\tif (!name || strncasecmp(name, prefix, pfx_len) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* match symbolic name case insensitive and ignoring prefix */",
            "\t\tif (strcasecmp(name + pfx_len, str) == 0) {",
            "\t\t\t*value = e->val;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "bpf_obj_pin_user, bpf_obj_get_user, find_bpffs_btf_enums, find_btf_enum_const",
          "description": "实现用户空间对象pin操作，对象获取逻辑及BTF枚举常量解析功能",
          "similarity": 0.4388449788093567
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 948,
          "end_line": 1061,
          "content": [
            "static bool bpf_preload_mod_get(void)",
            "{",
            "\t/* If bpf_preload.ko wasn't loaded earlier then load it now.",
            "\t * When bpf_preload is built into vmlinux the module's __init",
            "\t * function will populate it.",
            "\t */",
            "\tif (!bpf_preload_ops) {",
            "\t\trequest_module(\"bpf_preload\");",
            "\t\tif (!bpf_preload_ops)",
            "\t\t\treturn false;",
            "\t}",
            "\t/* And grab the reference, so the module doesn't disappear while the",
            "\t * kernel is interacting with the kernel module and its UMD.",
            "\t */",
            "\tif (!try_module_get(bpf_preload_ops->owner)) {",
            "\t\tpr_err(\"bpf_preload module get failed.\\n\");",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void bpf_preload_mod_put(void)",
            "{",
            "\tif (bpf_preload_ops)",
            "\t\t/* now user can \"rmmod bpf_preload\" if necessary */",
            "\t\tmodule_put(bpf_preload_ops->owner);",
            "}",
            "static int populate_bpffs(struct dentry *parent)",
            "{",
            "\tstruct bpf_preload_info objs[BPF_PRELOAD_LINKS] = {};",
            "\tint err = 0, i;",
            "",
            "\t/* grab the mutex to make sure the kernel interactions with bpf_preload",
            "\t * are serialized",
            "\t */",
            "\tmutex_lock(&bpf_preload_lock);",
            "",
            "\t/* if bpf_preload.ko wasn't built into vmlinux then load it */",
            "\tif (!bpf_preload_mod_get())",
            "\t\tgoto out;",
            "",
            "\terr = bpf_preload_ops->preload(objs);",
            "\tif (err)",
            "\t\tgoto out_put;",
            "\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {",
            "\t\tbpf_link_inc(objs[i].link);",
            "\t\terr = bpf_iter_link_pin_kernel(parent,",
            "\t\t\t\t\t       objs[i].link_name, objs[i].link);",
            "\t\tif (err) {",
            "\t\t\tbpf_link_put(objs[i].link);",
            "\t\t\tgoto out_put;",
            "\t\t}",
            "\t}",
            "out_put:",
            "\tbpf_preload_mod_put();",
            "out:",
            "\tmutex_unlock(&bpf_preload_lock);",
            "\treturn err;",
            "}",
            "static int bpf_fill_super(struct super_block *sb, struct fs_context *fc)",
            "{",
            "\tstatic const struct tree_descr bpf_rfiles[] = { { \"\" } };",
            "\tstruct bpf_mount_opts *opts = sb->s_fs_info;",
            "\tstruct inode *inode;",
            "\tint ret;",
            "",
            "\t/* Mounting an instance of BPF FS requires privileges */",
            "\tif (fc->user_ns != &init_user_ns && !capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tret = simple_fill_super(sb, BPF_FS_MAGIC, bpf_rfiles);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tsb->s_op = &bpf_super_ops;",
            "",
            "\tinode = sb->s_root->d_inode;",
            "\tinode->i_uid = opts->uid;",
            "\tinode->i_gid = opts->gid;",
            "\tinode->i_op = &bpf_dir_iops;",
            "\tinode->i_mode &= ~S_IALLUGO;",
            "\tpopulate_bpffs(sb->s_root);",
            "\tinode->i_mode |= S_ISVTX | opts->mode;",
            "\treturn 0;",
            "}",
            "static int bpf_get_tree(struct fs_context *fc)",
            "{",
            "\treturn get_tree_nodev(fc, bpf_fill_super);",
            "}",
            "static void bpf_free_fc(struct fs_context *fc)",
            "{",
            "\tkfree(fc->s_fs_info);",
            "}",
            "static int bpf_init_fs_context(struct fs_context *fc)",
            "{",
            "\tstruct bpf_mount_opts *opts;",
            "",
            "\topts = kzalloc(sizeof(struct bpf_mount_opts), GFP_KERNEL);",
            "\tif (!opts)",
            "\t\treturn -ENOMEM;",
            "",
            "\topts->mode = S_IRWXUGO;",
            "\topts->uid = current_fsuid();",
            "\topts->gid = current_fsgid();",
            "",
            "\t/* start out with no BPF token delegation enabled */",
            "\topts->delegate_cmds = 0;",
            "\topts->delegate_maps = 0;",
            "\topts->delegate_progs = 0;",
            "\topts->delegate_attachs = 0;",
            "",
            "\tfc->s_fs_info = opts;",
            "\tfc->ops = &bpf_context_ops;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_preload_mod_get, bpf_preload_mod_put, populate_bpffs, bpf_fill_super, bpf_get_tree, bpf_free_fc, bpf_init_fs_context",
          "description": "管理BPF预加载模块引用计数，填充BPF文件系统超级块数据，初始化文件系统上下文并设置默认挂载选项",
          "similarity": 0.436748743057251
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_inode_storage.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:57:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_inode_storage.c`\n\n---\n\n# `bpf/bpf_inode_storage.c` 技术文档\n\n## 1. 文件概述\n\n`bpf_inode_storage.c` 实现了 BPF（Berkeley Packet Filter）程序对 **inode 级别本地存储（local storage）** 的支持。该机制允许 BPF 程序将任意用户定义的数据与内核中的 `struct inode` 实例关联，从而在不修改 VFS 层或文件系统代码的前提下，为 inode 附加自定义元数据。此功能主要用于 LSM（Linux Security Module）钩子、审计、追踪等场景。\n\n该文件基于通用的 `bpf_local_storage` 框架，为 inode 对象定制了存储管理逻辑，并提供了 BPF 辅助函数（helpers）和 map 操作接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `DEFINE_BPF_STORAGE_CACHE(inode_cache)`：为 inode 存储分配的专用内存缓存。\n- `inode_storage_map_ops`：`bpf_map_ops` 操作集，定义了 inode 存储 map 的行为。\n- `bpf_inode_storage_btf_ids`：BTF（BPF Type Format）类型 ID 列表，用于类型安全检查。\n\n### 关键函数\n- **存储访问与管理**\n  - `inode_storage_ptr()`：获取 inode 对应的 BPF 存储指针。\n  - `inode_storage_lookup()`：在指定 inode 和 map 中查找存储数据。\n  - `bpf_inode_storage_free()`：在 inode 销毁时释放其关联的 BPF 存储。\n  - `inode_storage_delete()`：从 inode 中删除指定 map 的存储项。\n\n- **BPF Map 操作接口**\n  - `bpf_fd_inode_storage_lookup_elem()`：通过文件描述符（fd）查找 inode 存储数据。\n  - `bpf_fd_inode_storage_update_elem()`：通过 fd 更新 inode 存储。\n  - `bpf_fd_inode_storage_delete_elem()`：通过 fd 删除 inode 存储。\n\n- **BPF 辅助函数（Helpers）**\n  - `bpf_inode_storage_get()`：BPF 程序调用的辅助函数，用于获取或创建 inode 存储。\n  - `bpf_inode_storage_delete()`：BPF 程序调用的辅助函数，用于删除 inode 存储。\n\n- **Map 生命周期管理**\n  - `inode_storage_map_alloc()`：分配 inode 存储类型的 BPF map。\n  - `inode_storage_map_free()`：释放该类型 map。\n\n## 3. 关键实现\n\n### 存储绑定机制\n- 每个 `struct inode` 通过 `bpf_inode()` 宏访问其内嵌的 `struct bpf_storage_blob`（通常位于 inode 的安全字段或扩展字段中）。\n- `bpf_storage_blob` 包含一个 RCU 保护的 `struct bpf_local_storage *storage` 指针，指向实际的存储容器。\n- 所有存储操作均通过 `bpf_local_storage` 通用框架完成，确保线程安全和内存管理一致性。\n\n### RCU 与锁策略\n- 查找操作使用 `rcu_read_lock()` 保护，避免持有写锁。\n- 更新/删除操作在必要时使用自旋锁（由 `bpf_local_storage_update` 内部处理）。\n- `bpf_inode_storage_get` 要求调用者已持有 RCU 锁（通过 `bpf_rcu_lock_held()` 验证），确保 inode 不会在操作期间被释放。\n\n### 内存分配策略\n- 存储项分配使用 `GFP_ATOMIC`（在 fd-based 接口）或由 verifier 传入的 `gfp_flags`（在 helper 中），以适应不同上下文（如中断、软中断）。\n- 使用专用 SLAB 缓存 `inode_cache` 优化内存分配性能。\n\n### BPF Map 与 Helper 集成\n- 提供两种访问路径：\n  1. **BPF 程序直接调用 helper**（如 `bpf_inode_storage_get`），传入 `struct inode *`。\n  2. **用户空间通过 fd 操作 map**（如 `bpf_map_lookup_elem`），内核自动解析 fd 到 inode。\n- `map_get_next_key` 返回 `-ENOTSUPP`，表明该 map 不支持迭代。\n\n### 类型安全\n- 通过 BTF 类型 ID (`bpf_inode_storage_btf_ids`) 确保 BPF 程序传入的 `inode` 指针类型正确。\n- `arg2_type = ARG_PTR_TO_BTF_ID_OR_NULL` 允许传入空指针（安全处理）。\n\n## 4. 依赖关系\n\n- **核心依赖**\n  - `<linux/bpf_local_storage.h>`：提供通用本地存储框架。\n  - `<linux/bpf.h>`：BPF 核心基础设施。\n  - `<linux/rculist.h>` / `<linux/spinlock.h>`：并发控制原语。\n  - `<linux/fdtable.h>`：fd 解析支持。\n\n- **关联子系统**\n  - **VFS（Virtual File System）**：依赖 `struct inode` 结构及生命周期管理。\n  - **BPF 子系统**：集成到 BPF map 和 helper 机制中。\n  - **LSM（Linux Security Modules）**：常用于在 LSM 钩子中附加安全上下文。\n  - **BTF（BPF Type Format）**：用于运行时类型验证。\n\n- **内存管理**\n  - 依赖 SLAB 分配器创建专用缓存 `inode_cache`。\n  - 与 RCU 机制深度集成，确保存储项安全回收。\n\n## 5. 使用场景\n\n1. **LSM 安全策略扩展**\n   - 在 LSM 钩子（如 `file_open`、`inode_permission`）中，BPF 程序可为 inode 附加自定义安全标签或策略数据。\n\n2. **文件系统审计与监控**\n   - 追踪特定 inode 的访问模式，记录额外审计信息（如首次访问时间、访问者 UID）。\n\n3. **资源配额与限制**\n   - 为 inode 关联配额计数器，实现细粒度资源控制（如单个文件的 I/O 限速）。\n\n4. **调试与性能分析**\n   - 在 BPF 程序中为热点 inode 附加调试信息，辅助性能调优。\n\n5. **用户空间工具集成**\n   - 通过 fd 操作 map，用户空间程序可查询/修改 inode 的 BPF 存储（如 `bpftool` 调试）。\n\n> **注意**：由于 inode 可能被频繁创建/销毁，BPF 程序必须确保在安全上下文中调用 helper（如持有 inode 引用或处于 RCU 临界区），避免访问已释放内存。",
      "similarity": 0.5083252191543579,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 57,
          "end_line": 121,
          "content": [
            "void bpf_inode_storage_free(struct inode *inode)",
            "{",
            "\tstruct bpf_local_storage *local_storage;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "",
            "\tlocal_storage = rcu_dereference(bsb->storage);",
            "\tif (!local_storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn;",
            "\t}",
            "",
            "\tbpf_local_storage_destroy(local_storage);",
            "\trcu_read_unlock();",
            "}",
            "static long bpf_fd_inode_storage_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t\t     void *value, u64 map_flags)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\tif (!inode_storage_ptr(file_inode(fd_file(f))))",
            "\t\treturn -EBADF;",
            "",
            "\tsdata = bpf_local_storage_update(file_inode(fd_file(f)),",
            "\t\t\t\t\t (struct bpf_local_storage_map *)map,",
            "\t\t\t\t\t value, map_flags, false, GFP_ATOMIC);",
            "\treturn PTR_ERR_OR_ZERO(sdata);",
            "}",
            "static int inode_storage_delete(struct inode *inode, struct bpf_map *map)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "",
            "\tsdata = inode_storage_lookup(inode, map, false);",
            "\tif (!sdata)",
            "\t\treturn -ENOENT;",
            "",
            "\tbpf_selem_unlink(SELEM(sdata), false);",
            "",
            "\treturn 0;",
            "}",
            "static long bpf_fd_inode_storage_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\treturn inode_storage_delete(file_inode(fd_file(f)), map);",
            "}",
            "static int notsupp_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\tvoid *next_key)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static void inode_storage_map_free(struct bpf_map *map)",
            "{",
            "\tbpf_local_storage_map_free(map, &inode_cache, NULL);",
            "}"
          ],
          "function_name": "bpf_inode_storage_free, bpf_fd_inode_storage_update_elem, inode_storage_delete, bpf_fd_inode_storage_delete_elem, notsupp_get_next_key, inode_storage_map_free",
          "description": "实现inode相关BPF存储资源的释放、更新、删除操作。包含释放存储空间、通过文件描述符更新存储项、删除存储条目等功能，同时注册了不支持的get_next_key操作并实现map销毁时的缓存回收逻辑。",
          "similarity": 0.4575881361961365
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 1,
          "end_line": 56,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (c) 2019 Facebook",
            " * Copyright 2020 Google LLC.",
            " */",
            "",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/rcupdate_trace.h>",
            "",
            "DEFINE_BPF_STORAGE_CACHE(inode_cache);",
            "",
            "static struct bpf_local_storage __rcu **",
            "inode_storage_ptr(void *owner)",
            "{",
            "\tstruct inode *inode = owner;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "\treturn &bsb->storage;",
            "}",
            "",
            "static struct bpf_local_storage_data *inode_storage_lookup(struct inode *inode,",
            "\t\t\t\t\t\t\t   struct bpf_map *map,",
            "\t\t\t\t\t\t\t   bool cacheit_lockit)",
            "{",
            "\tstruct bpf_local_storage *inode_storage;",
            "\tstruct bpf_local_storage_map *smap;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "",
            "\tinode_storage =",
            "\t\trcu_dereference_check(bsb->storage, bpf_rcu_lock_held());",
            "\tif (!inode_storage)",
            "\t\treturn NULL;",
            "",
            "\tsmap = (struct bpf_local_storage_map *)map;",
            "\treturn bpf_local_storage_lookup(inode_storage, smap, cacheit_lockit);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义inode级别的BPF本地存储缓存inode_cache，并提供用于获取inode存储指针及查询特定map中存储数据的辅助函数。其中inode_storage_lookup通过RCU读锁安全地检索存储实例并调用底层BPF本地存储查找逻辑。",
          "similarity": 0.4277265667915344
        }
      ]
    },
    {
      "source_file": "kernel/bpf/preload/iterators/iterators.lskel-little-endian.h",
      "md_summary": "> 自动生成时间: 2025-10-25 12:26:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\preload\\iterators\\iterators.lskel-little-endian.h`\n\n---\n\n# `bpf/preload/iterators/iterators.lskel-little-endian.h` 技术文档\n\n## 文件概述\n\n该文件是 **BPF skeleton 头文件**，由 `bpftool` 工具自动生成，用于在用户空间加载和管理一组与 BPF 迭代器（BPF iterators）相关的 eBPF 程序。文件专为小端（little-endian）架构生成，封装了两个 BPF 迭代器程序：`dump_bpf_map` 和 `dump_bpf_prog`，分别用于遍历内核中的 BPF map 和 BPF program 对象。该 skeleton 提供了统一的接口用于打开、加载、挂载（attach）、卸载（detach）和销毁 BPF 资源，是用户空间程序与内核 BPF 迭代器交互的桥梁。\n\n## 核心功能\n\n### 数据结构\n\n- **`struct iterators_bpf`**  \n  主 skeleton 结构体，包含以下成员：\n  - `ctx`：BPF 加载器上下文（`bpf_loader_ctx`）\n  - `maps`：包含只读数据段（`rodata`）的 map 描述符\n  - `progs`：包含两个 BPF 程序描述符：\n    - `dump_bpf_map`：用于遍历 BPF maps 的迭代器程序\n    - `dump_bpf_prog`：用于遍历 BPF programs 的迭代器程序\n  - `links`：存储已创建的 BPF trace link 文件描述符（FD）：\n    - `dump_bpf_map_fd`\n    - `dump_bpf_prog_fd`\n\n### 主要函数\n\n- **`iterators_bpf__open()`**  \n  分配并初始化 `iterators_bpf` 结构体内存，设置 loader 上下文大小。\n\n- **`iterators_bpf__load()`**  \n  将内嵌的 BPF 字节码（ELF 内容以字符串形式硬编码）加载到内核，并创建对应的 maps 和 programs。\n\n- **`iterators_bpf__dump_bpf_map__attach()`**  \n  为 `dump_bpf_map` 程序创建 `BPF_TRACE_ITER` 类型的 trace link，使其可被 `/sys/kernel/debug/tracing/trace_pipe` 或 `bpf_iter` 文件系统接口调用。\n\n- **`iterators_bpf__dump_bpf_prog__attach()`**  \n  为 `dump_bpf_prog` 程序创建 `BPF_TRACE_ITER` 类型的 trace link。\n\n- **`iterators_bpf__attach()`**  \n  批量挂载所有 BPF 迭代器程序。\n\n- **`iterators_bpf__detach()`**  \n  关闭所有已创建的 trace link FD。\n\n- **`iterators_bpf__destroy()`**  \n  安全释放所有资源（links、programs、maps）并释放 skeleton 内存。\n\n## 关键实现\n\n- **自动生成与硬编码字节码**  \n  文件中包含一个长度为 6208 字节的字符串字面量（`opts.data`），其中嵌入了完整的 BPF ELF 二进制数据（以小端格式编码）。该数据由 `bpftool gen skeleton` 在编译时生成并内联至此头文件，避免运行时依赖外部文件。\n\n- **BPF 迭代器挂载机制**  \n  通过 `skel_link_create(prog_fd, 0, BPF_TRACE_ITER)` 创建 `BPF_LINK_TYPE_TRACE_ITER` 类型的链接。该链接使 BPF 程序注册为内核迭代器，用户可通过打开 `/sys/fs/bpf/` 下的对应迭代器文件或使用 `bpf_iter_create()` 系统调用触发遍历。\n\n- **资源管理与错误处理**  \n  所有资源（FD）使用 `skel_closenz()` 安全关闭（检查非负值），`__attach` 函数采用“短路求值”逻辑：任一 attach 失败即返回错误码，后续 attach 不再执行。\n\n- **内存布局计算**  \n  `skel->ctx.sz` 通过指针算术 `&skel->links - (void *)skel` 动态计算 loader 上下文所需大小，确保 `bpf_loader_ctx` 能正确覆盖到 `links` 成员起始位置。\n\n## 依赖关系\n\n- **内核依赖**：\n  - `CONFIG_BPF`、`CONFIG_BPF_SYSCALL`：启用 BPF 子系统\n  - `CONFIG_BPF_ITER`：支持 BPF 迭代器功能\n  - `BPF_TRACE_ITER` 程序类型支持（v5.8+）\n\n- **用户空间依赖**：\n  - `libbpf` 库（提供 `skel_internal.h` 及底层 `bpf()` 系统调用封装）\n  - `bpftool`（用于生成此 skeleton 文件）\n  - 内核头文件中的 BPF 相关定义（如 `bpf.h`）\n\n- **内部依赖**：\n  - 依赖同目录下对应的 BPF 源文件（如 `iterators.bpf.c`）编译生成的 ELF 对象\n  - 依赖 `bpf/preload/iterators/` 中的 BPF 程序逻辑\n\n## 使用场景\n\n- **BPF 资源内省（Introspection）**  \n  用户空间工具（如 `bpftool map show` / `bpftool prog show` 的底层实现）通过此 skeleton 加载迭代器程序，安全遍历内核中所有 BPF maps 和 programs，获取其元数据（如类型、大小、引用计数等）。\n\n- **系统监控与调试**  \n  开发者或运维人员可利用此接口构建自定义监控工具，实时审计系统中运行的 BPF 程序和数据结构，用于性能分析或安全审计。\n\n- **BPF 预加载（Preload）机制**  \n  作为 `bpf/preload/` 子系统的一部分，该 skeleton 可在系统启动早期或特定服务初始化时预加载 BPF 迭代器，为后续诊断功能提供基础设施。\n\n- **容器与沙箱环境**  \n  在容器运行时中，通过受限的 BPF 迭代器接口，实现对容器内 BPF 资源的隔离查看，而无需全局权限。",
      "similarity": 0.4952884912490845,
      "chunks": []
    }
  ]
}