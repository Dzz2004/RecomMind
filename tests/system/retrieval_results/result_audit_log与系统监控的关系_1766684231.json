{
  "query": "audit_log与系统监控的关系",
  "timestamp": "2025-12-26 01:37:11",
  "retrieved_files": [
    {
      "source_file": "kernel/auditsc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:53:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `auditsc.c`\n\n---\n\n# auditsc.c 技术文档\n\n## 1. 文件概述\n\n`auditsc.c` 是 Linux 内核审计子系统的核心组件之一，专门负责**系统调用级别的审计功能**。该文件实现了系统调用进入和退出时的审计数据收集、过滤规则匹配、辅助数据管理以及与 LSM（Linux Security Module）安全模块的集成。它为内核审计框架提供了系统调用上下文的完整记录能力，支持对文件操作、网络配置、进程执行等关键系统行为进行细粒度监控和日志记录。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`audit_aux_data`**: 审计辅助数据的通用基类，用于链式存储额外的审计信息\n- **`audit_aux_data_pids`**: 存储目标进程相关信息（PID、UID、会话ID、安全上下文等），最多支持16个目标进程\n- **`audit_aux_data_bprm_fcaps`**: 记录可执行文件能力（capabilities）变更信息，包括文件能力、旧进程能力和新进程能力\n- **`audit_tree_refs`**: 用于管理文件系统审计树（audit tree）引用的链表结构，每个节点包含31个`audit_chunk`指针\n- **`audit_nfcfgop_tab`**: 网络过滤配置操作的枚举到字符串映射表，支持 iptables 和 nftables 操作审计\n\n### 关键函数\n\n- **`audit_match_perm()`**: 根据系统调用类型和访问模式（读/写/属性/执行）匹配审计权限过滤规则\n- **`audit_match_filetype()`**: 匹配审计上下文中文件的类型（如普通文件、目录、设备文件等）\n- **`audit_set_auditable()`**: 将审计上下文标记为可审计状态，设置优先级和记录状态\n- **`put_tree_ref()` / `grow_tree_refs()` / `unroll_tree_refs()`**: 管理审计树引用的动态分配和释放\n\n### 全局变量\n\n- **`audit_n_rules`**: 当前系统中审计规则的总数\n- **`audit_signals`**: 控制是否收集信号发送相关的审计数据\n\n## 3. 关键实现\n\n### 系统调用分类与权限匹配\n\n`audit_match_perm()` 函数实现了复杂的系统调用分类逻辑：\n- **原生系统调用**（`AUDITSC_NATIVE`）：通过预定义的系统调用类（`AUDIT_CLASS_WRITE`、`AUDIT_CLASS_READ` 等）进行匹配\n- **兼容模式系统调用**（`AUDITSC_COMPAT`）：针对32位兼容层的特殊处理\n- **特殊系统调用处理**：\n  - `open`/`openat`：直接从参数中提取访问模式\n  - `openat2`：从 `struct open_how` 的 flags 字段解析访问模式\n  - `socketcall`：特殊处理 `SYS_BIND` 操作\n  - `execve`：匹配执行权限\n\n### 审计树引用管理\n\n采用**固定大小数组链表**的设计模式管理 `audit_chunk` 引用：\n- 每个 `audit_tree_refs` 节点包含31个指针槽位\n- 初始状态为 `(NULL, NULL, 0)`，首次分配后变为 `(p, p, 31)`\n- 通过 `tree_count` 跟踪当前节点的可用槽位数\n- 不支持收缩，仅在上下文释放时统一清理\n\n### 辅助数据扩展机制\n\n通过**继承式链表设计**支持多种辅助数据类型：\n- 所有辅助数据结构都以 `audit_aux_data` 作为第一个成员\n- 通过 `type` 字段区分不同类型的数据\n- 支持动态添加新的辅助数据类型而无需修改核心逻辑\n\n### 网络配置审计支持\n\n内置对现代网络过滤框架的完整支持：\n- **iptables**（`xt_*` 操作）\n- **nftables**（`nft_*` 操作，包括表、链、规则、集合、对象、流表等）\n- 提供操作码到可读字符串的映射，便于用户空间解析\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n\n- **审计核心**：`<linux/audit.h>`、`\"audit.h\"`\n- **系统调用**：`<asm/syscall.h>`、`<linux/syscalls.h>`\n- **安全模块**：`<linux/security.h>`、`<linux/capability.h>`\n- **文件系统**：`<linux/fs.h>`、`<linux/namei.h>`、`<linux/mount.h>`\n- **网络**：`<linux/socket.h>`、`<uapi/linux/netfilter/nf_tables.h>`\n- **进程管理**：`<linux/binfmts.h>`、`<linux/personality.h>`\n\n### 功能依赖\n\n- **审计框架**：依赖 `audit.c` 提供的核心审计功能\n- **LSM 框架**：与 SELinux、Smack 等安全模块集成，支持安全上下文审计\n- **系统调用拦截**：依赖架构特定的系统调用入口/出口钩子（如 `entry.S`）\n- **文件系统通知**：与 `fsnotify` 子系统协作实现文件访问审计\n\n## 5. 使用场景\n\n### 系统调用审计\n\n- **文件操作监控**：记录所有文件创建、删除、重命名、权限修改等操作\n- **进程执行跟踪**：审计 `execve` 系统调用，记录命令行参数和环境变量\n- **网络配置变更**：监控 iptables/nftables 规则的添加、删除、修改\n- **能力变更审计**：跟踪进程能力的获取、丢弃和继承过程\n\n### 安全合规\n\n- **LSPP 认证**：支持主体/客体安全上下文标签审计，满足高安全等级要求\n- **访问控制审计**：记录所有违反 MAC（强制访问控制）策略的访问尝试\n- **特权操作监控**：审计所有涉及 root 权限或特殊能力的系统调用\n\n### 故障诊断与取证\n\n- **系统行为分析**：通过审计日志重建系统调用序列，分析异常行为\n- **安全事件响应**：在安全事件发生后，通过审计记录追踪攻击路径\n- **合规性报告**：生成满足法规要求的系统活动审计报告",
      "similarity": 0.6115574240684509,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "kernel/auditsc.c",
          "start_line": 1644,
          "end_line": 1818,
          "content": [
            "static void audit_log_uring(struct audit_context *ctx)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tconst struct cred *cred;",
            "",
            "\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);",
            "\tif (!ab)",
            "\t\treturn;",
            "\tcred = current_cred();",
            "\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);",
            "\tif (ctx->return_valid != AUDITSC_INVALID)",
            "\t\taudit_log_format(ab, \" success=%s exit=%ld\",",
            "\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?",
            "\t\t\t\t  \"yes\" : \"no\"),",
            "\t\t\t\t ctx->return_code);",
            "\taudit_log_format(ab,",
            "\t\t\t \" items=%d\"",
            "\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"",
            "\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",",
            "\t\t\t ctx->name_count,",
            "\t\t\t task_ppid_nr(current), task_tgid_nr(current),",
            "\t\t\t from_kuid(&init_user_ns, cred->uid),",
            "\t\t\t from_kgid(&init_user_ns, cred->gid),",
            "\t\t\t from_kuid(&init_user_ns, cred->euid),",
            "\t\t\t from_kuid(&init_user_ns, cred->suid),",
            "\t\t\t from_kuid(&init_user_ns, cred->fsuid),",
            "\t\t\t from_kgid(&init_user_ns, cred->egid),",
            "\t\t\t from_kgid(&init_user_ns, cred->sgid),",
            "\t\t\t from_kgid(&init_user_ns, cred->fsgid));",
            "\taudit_log_task_context(ab);",
            "\taudit_log_key(ab, ctx->filterkey);",
            "\taudit_log_end(ab);",
            "}",
            "static void audit_log_exit(void)",
            "{",
            "\tint i, call_panic = 0;",
            "\tstruct audit_context *context = audit_context();",
            "\tstruct audit_buffer *ab;",
            "\tstruct audit_aux_data *aux;",
            "\tstruct audit_names *n;",
            "",
            "\tcontext->personality = current->personality;",
            "",
            "\tswitch (context->context) {",
            "\tcase AUDIT_CTX_SYSCALL:",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);",
            "\t\tif (!ab)",
            "\t\t\treturn;",
            "\t\taudit_log_format(ab, \"arch=%x syscall=%d\",",
            "\t\t\t\t context->arch, context->major);",
            "\t\tif (context->personality != PER_LINUX)",
            "\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);",
            "\t\tif (context->return_valid != AUDITSC_INVALID)",
            "\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",",
            "\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?",
            "\t\t\t\t\t  \"yes\" : \"no\"),",
            "\t\t\t\t\t context->return_code);",
            "\t\taudit_log_format(ab,",
            "\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",",
            "\t\t\t\t context->argv[0],",
            "\t\t\t\t context->argv[1],",
            "\t\t\t\t context->argv[2],",
            "\t\t\t\t context->argv[3],",
            "\t\t\t\t context->name_count);",
            "\t\taudit_log_task_info(ab);",
            "\t\taudit_log_key(ab, context->filterkey);",
            "\t\taudit_log_end(ab);",
            "\t\tbreak;",
            "\tcase AUDIT_CTX_URING:",
            "\t\taudit_log_uring(context);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t\tbreak;",
            "\t}",
            "",
            "\tfor (aux = context->aux; aux; aux = aux->next) {",
            "",
            "\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);",
            "\t\tif (!ab)",
            "\t\t\tcontinue; /* audit_panic has been called */",
            "",
            "\t\tswitch (aux->type) {",
            "",
            "\t\tcase AUDIT_BPRM_FCAPS: {",
            "\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;",
            "",
            "\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);",
            "\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);",
            "\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);",
            "\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);",
            "\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);",
            "\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);",
            "\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);",
            "\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);",
            "\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);",
            "\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);",
            "\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);",
            "\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);",
            "\t\t\taudit_log_format(ab, \" frootid=%d\",",
            "\t\t\t\t\t from_kuid(&init_user_ns,",
            "\t\t\t\t\t\t   axs->fcap.rootid));",
            "\t\t\tbreak; }",
            "",
            "\t\t}",
            "\t\taudit_log_end(ab);",
            "\t}",
            "",
            "\tif (context->type)",
            "\t\tshow_special(context, &call_panic);",
            "",
            "\tif (context->fds[0] >= 0) {",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);",
            "\t\tif (ab) {",
            "\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",",
            "\t\t\t\t\tcontext->fds[0], context->fds[1]);",
            "\t\t\taudit_log_end(ab);",
            "\t\t}",
            "\t}",
            "",
            "\tif (context->sockaddr_len) {",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);",
            "\t\tif (ab) {",
            "\t\t\taudit_log_format(ab, \"saddr=\");",
            "\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,",
            "\t\t\t\t\tcontext->sockaddr_len);",
            "\t\t\taudit_log_end(ab);",
            "\t\t}",
            "\t}",
            "",
            "\tfor (aux = context->aux_pids; aux; aux = aux->next) {",
            "\t\tstruct audit_aux_data_pids *axs = (void *)aux;",
            "",
            "\t\tfor (i = 0; i < axs->pid_count; i++)",
            "\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],",
            "\t\t\t\t\t\t  axs->target_auid[i],",
            "\t\t\t\t\t\t  axs->target_uid[i],",
            "\t\t\t\t\t\t  axs->target_sessionid[i],",
            "\t\t\t\t\t\t  axs->target_sid[i],",
            "\t\t\t\t\t\t  axs->target_comm[i]))",
            "\t\t\t\tcall_panic = 1;",
            "\t}",
            "",
            "\tif (context->target_pid &&",
            "\t    audit_log_pid_context(context, context->target_pid,",
            "\t\t\t\t  context->target_auid, context->target_uid,",
            "\t\t\t\t  context->target_sessionid,",
            "\t\t\t\t  context->target_sid, context->target_comm))",
            "\t\t\tcall_panic = 1;",
            "",
            "\tif (context->pwd.dentry && context->pwd.mnt) {",
            "\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);",
            "\t\tif (ab) {",
            "\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);",
            "\t\t\taudit_log_end(ab);",
            "\t\t}",
            "\t}",
            "",
            "\ti = 0;",
            "\tlist_for_each_entry(n, &context->names_list, list) {",
            "\t\tif (n->hidden)",
            "\t\t\tcontinue;",
            "\t\taudit_log_name(context, n, NULL, i++, &call_panic);",
            "\t}",
            "",
            "\tif (context->context == AUDIT_CTX_SYSCALL)",
            "\t\taudit_log_proctitle();",
            "",
            "\t/* Send end of event record to help user space know we are finished */",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);",
            "\tif (ab)",
            "\t\taudit_log_end(ab);",
            "\tif (call_panic)",
            "\t\taudit_panic(\"error in audit_log_exit()\");",
            "}"
          ],
          "function_name": "audit_log_uring, audit_log_exit",
          "description": "实现uring操作审计日志记录及进程退出事件审计，包含系统调用参数、文件描述符、特殊辅助数据等多维度审计信息收集",
          "similarity": 0.5862843990325928
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/auditsc.c",
          "start_line": 2692,
          "end_line": 2803,
          "content": [
            "void __audit_fd_pair(int fd1, int fd2)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tcontext->fds[0] = fd1;",
            "\tcontext->fds[1] = fd2;",
            "}",
            "int __audit_sockaddr(int len, void *a)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tif (!context->sockaddr) {",
            "\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);",
            "",
            "\t\tif (!p)",
            "\t\t\treturn -ENOMEM;",
            "\t\tcontext->sockaddr = p;",
            "\t}",
            "",
            "\tcontext->sockaddr_len = len;",
            "\tmemcpy(context->sockaddr, a, len);",
            "\treturn 0;",
            "}",
            "void __audit_ptrace(struct task_struct *t)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tcontext->target_pid = task_tgid_nr(t);",
            "\tcontext->target_auid = audit_get_loginuid(t);",
            "\tcontext->target_uid = task_uid(t);",
            "\tcontext->target_sessionid = audit_get_sessionid(t);",
            "\tsecurity_task_getsecid_obj(t, &context->target_sid);",
            "\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);",
            "}",
            "int audit_signal_info_syscall(struct task_struct *t)",
            "{",
            "\tstruct audit_aux_data_pids *axp;",
            "\tstruct audit_context *ctx = audit_context();",
            "\tkuid_t t_uid = task_uid(t);",
            "",
            "\tif (!audit_signals || audit_dummy_context())",
            "\t\treturn 0;",
            "",
            "\t/* optimize the common case by putting first signal recipient directly",
            "\t * in audit_context */",
            "\tif (!ctx->target_pid) {",
            "\t\tctx->target_pid = task_tgid_nr(t);",
            "\t\tctx->target_auid = audit_get_loginuid(t);",
            "\t\tctx->target_uid = t_uid;",
            "\t\tctx->target_sessionid = audit_get_sessionid(t);",
            "\t\tsecurity_task_getsecid_obj(t, &ctx->target_sid);",
            "\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\taxp = (void *)ctx->aux_pids;",
            "\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {",
            "\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);",
            "\t\tif (!axp)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\taxp->d.type = AUDIT_OBJ_PID;",
            "\t\taxp->d.next = ctx->aux_pids;",
            "\t\tctx->aux_pids = (void *)axp;",
            "\t}",
            "\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);",
            "",
            "\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);",
            "\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);",
            "\taxp->target_uid[axp->pid_count] = t_uid;",
            "\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);",
            "\tsecurity_task_getsecid_obj(t, &axp->target_sid[axp->pid_count]);",
            "\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);",
            "\taxp->pid_count++;",
            "",
            "\treturn 0;",
            "}",
            "int __audit_log_bprm_fcaps(struct linux_binprm *bprm,",
            "\t\t\t   const struct cred *new, const struct cred *old)",
            "{",
            "\tstruct audit_aux_data_bprm_fcaps *ax;",
            "\tstruct audit_context *context = audit_context();",
            "\tstruct cpu_vfs_cap_data vcaps;",
            "",
            "\tax = kmalloc(sizeof(*ax), GFP_KERNEL);",
            "\tif (!ax)",
            "\t\treturn -ENOMEM;",
            "",
            "\tax->d.type = AUDIT_BPRM_FCAPS;",
            "\tax->d.next = context->aux;",
            "\tcontext->aux = (void *)ax;",
            "",
            "\tget_vfs_caps_from_disk(&nop_mnt_idmap,",
            "\t\t\t       bprm->file->f_path.dentry, &vcaps);",
            "",
            "\tax->fcap.permitted = vcaps.permitted;",
            "\tax->fcap.inheritable = vcaps.inheritable;",
            "\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);",
            "\tax->fcap.rootid = vcaps.rootid;",
            "\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;",
            "",
            "\tax->old_pcap.permitted   = old->cap_permitted;",
            "\tax->old_pcap.inheritable = old->cap_inheritable;",
            "\tax->old_pcap.effective   = old->cap_effective;",
            "\tax->old_pcap.ambient     = old->cap_ambient;",
            "",
            "\tax->new_pcap.permitted   = new->cap_permitted;",
            "\tax->new_pcap.inheritable = new->cap_inheritable;",
            "\tax->new_pcap.effective   = new->cap_effective;",
            "\tax->new_pcap.ambient     = new->cap_ambient;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__audit_fd_pair, __audit_sockaddr, __audit_ptrace, audit_signal_info_syscall, __audit_log_bprm_fcaps",
          "description": "该代码块定义了多个辅助函数，用于在审计上下文中记录文件描述符配对、套接字地址、ptrace目标信息、信号传递及二进制参数能力变化等安全相关事件，通过修改audit_context结构体成员存储关键数据，供后续审计日志生成使用。",
          "similarity": 0.5763552188873291
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/auditsc.c",
          "start_line": 2011,
          "end_line": 2156,
          "content": [
            "void __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,",
            "\t\t\t   unsigned long a3, unsigned long a4)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "\tenum audit_state     state;",
            "",
            "\tif (!audit_enabled || !context)",
            "\t\treturn;",
            "",
            "\tWARN_ON(context->context != AUDIT_CTX_UNUSED);",
            "\tWARN_ON(context->name_count);",
            "\tif (context->context != AUDIT_CTX_UNUSED || context->name_count) {",
            "\t\taudit_panic(\"unrecoverable error in audit_syscall_entry()\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tstate = context->state;",
            "\tif (state == AUDIT_STATE_DISABLED)",
            "\t\treturn;",
            "",
            "\tcontext->dummy = !audit_n_rules;",
            "\tif (!context->dummy && state == AUDIT_STATE_BUILD) {",
            "\t\tcontext->prio = 0;",
            "\t\tif (auditd_test_task(current))",
            "\t\t\treturn;",
            "\t}",
            "",
            "\tcontext->arch\t    = syscall_get_arch(current);",
            "\tcontext->major      = major;",
            "\tcontext->argv[0]    = a1;",
            "\tcontext->argv[1]    = a2;",
            "\tcontext->argv[2]    = a3;",
            "\tcontext->argv[3]    = a4;",
            "\tcontext->context = AUDIT_CTX_SYSCALL;",
            "\tcontext->current_state  = state;",
            "\tktime_get_coarse_real_ts64(&context->ctime);",
            "}",
            "void __audit_syscall_exit(int success, long return_code)",
            "{",
            "\tstruct audit_context *context = audit_context();",
            "",
            "\tif (!context || context->dummy ||",
            "\t    context->context != AUDIT_CTX_SYSCALL)",
            "\t\tgoto out;",
            "",
            "\t/* this may generate CONFIG_CHANGE records */",
            "\tif (!list_empty(&context->killed_trees))",
            "\t\taudit_kill_trees(context);",
            "",
            "\taudit_return_fixup(context, success, return_code);",
            "\t/* run through both filters to ensure we set the filterkey properly */",
            "\taudit_filter_syscall(current, context);",
            "\taudit_filter_inodes(current, context);",
            "\tif (context->current_state != AUDIT_STATE_RECORD)",
            "\t\tgoto out;",
            "",
            "\taudit_log_exit();",
            "",
            "out:",
            "\taudit_reset_context(context);",
            "}",
            "static inline void handle_one(const struct inode *inode)",
            "{",
            "\tstruct audit_context *context;",
            "\tstruct audit_tree_refs *p;",
            "\tstruct audit_chunk *chunk;",
            "\tint count;",
            "",
            "\tif (likely(!inode->i_fsnotify_marks))",
            "\t\treturn;",
            "\tcontext = audit_context();",
            "\tp = context->trees;",
            "\tcount = context->tree_count;",
            "\trcu_read_lock();",
            "\tchunk = audit_tree_lookup(inode);",
            "\trcu_read_unlock();",
            "\tif (!chunk)",
            "\t\treturn;",
            "\tif (likely(put_tree_ref(context, chunk)))",
            "\t\treturn;",
            "\tif (unlikely(!grow_tree_refs(context))) {",
            "\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");",
            "\t\taudit_set_auditable(context);",
            "\t\taudit_put_chunk(chunk);",
            "\t\tunroll_tree_refs(context, p, count);",
            "\t\treturn;",
            "\t}",
            "\tput_tree_ref(context, chunk);",
            "}",
            "static void handle_path(const struct dentry *dentry)",
            "{",
            "\tstruct audit_context *context;",
            "\tstruct audit_tree_refs *p;",
            "\tconst struct dentry *d, *parent;",
            "\tstruct audit_chunk *drop;",
            "\tunsigned long seq;",
            "\tint count;",
            "",
            "\tcontext = audit_context();",
            "\tp = context->trees;",
            "\tcount = context->tree_count;",
            "retry:",
            "\tdrop = NULL;",
            "\td = dentry;",
            "\trcu_read_lock();",
            "\tseq = read_seqbegin(&rename_lock);",
            "\tfor (;;) {",
            "\t\tstruct inode *inode = d_backing_inode(d);",
            "",
            "\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {",
            "\t\t\tstruct audit_chunk *chunk;",
            "",
            "\t\t\tchunk = audit_tree_lookup(inode);",
            "\t\t\tif (chunk) {",
            "\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {",
            "\t\t\t\t\tdrop = chunk;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tparent = d->d_parent;",
            "\t\tif (parent == d)",
            "\t\t\tbreak;",
            "\t\td = parent;",
            "\t}",
            "\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */",
            "\t\trcu_read_unlock();",
            "\t\tif (!drop) {",
            "\t\t\t/* just a race with rename */",
            "\t\t\tunroll_tree_refs(context, p, count);",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\taudit_put_chunk(drop);",
            "\t\tif (grow_tree_refs(context)) {",
            "\t\t\t/* OK, got more space */",
            "\t\t\tunroll_tree_refs(context, p, count);",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\t/* too bad */",
            "\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");",
            "\t\tunroll_tree_refs(context, p, count);",
            "\t\taudit_set_auditable(context);",
            "\t\treturn;",
            "\t}",
            "\trcu_read_unlock();",
            "}"
          ],
          "function_name": "__audit_syscall_entry, __audit_syscall_exit, handle_one, handle_path",
          "description": "此代码块处理系统调用的审计入口/出口记录，包含路径追踪功能。通过遍历文件系统节点检测变化，维护审计上下文中的树引用计数，确保在文件操作时正确记录审计信息。",
          "similarity": 0.5706809759140015
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/auditsc.c",
          "start_line": 1083,
          "end_line": 1295,
          "content": [
            "static inline void audit_free_context(struct audit_context *context)",
            "{",
            "\t/* resetting is extra work, but it is likely just noise */",
            "\taudit_reset_context(context);",
            "\taudit_proctitle_free(context);",
            "\tfree_tree_refs(context);",
            "\tkfree(context->filterkey);",
            "\tkfree(context);",
            "}",
            "static int audit_log_pid_context(struct audit_context *context, pid_t pid,",
            "\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,",
            "\t\t\t\t u32 sid, char *comm)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tchar *ctx = NULL;",
            "\tu32 len;",
            "\tint rc = 0;",
            "",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);",
            "\tif (!ab)",
            "\t\treturn rc;",
            "",
            "\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,",
            "\t\t\t from_kuid(&init_user_ns, auid),",
            "\t\t\t from_kuid(&init_user_ns, uid), sessionid);",
            "\tif (sid) {",
            "\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {",
            "\t\t\taudit_log_format(ab, \" obj=(none)\");",
            "\t\t\trc = 1;",
            "\t\t} else {",
            "\t\t\taudit_log_format(ab, \" obj=%s\", ctx);",
            "\t\t\tsecurity_release_secctx(ctx, len);",
            "\t\t}",
            "\t}",
            "\taudit_log_format(ab, \" ocomm=\");",
            "\taudit_log_untrustedstring(ab, comm);",
            "\taudit_log_end(ab);",
            "",
            "\treturn rc;",
            "}",
            "static void audit_log_execve_info(struct audit_context *context,",
            "\t\t\t\t  struct audit_buffer **ab)",
            "{",
            "\tlong len_max;",
            "\tlong len_rem;",
            "\tlong len_full;",
            "\tlong len_buf;",
            "\tlong len_abuf = 0;",
            "\tlong len_tmp;",
            "\tbool require_data;",
            "\tbool encode;",
            "\tunsigned int iter;",
            "\tunsigned int arg;",
            "\tchar *buf_head;",
            "\tchar *buf;",
            "\tconst char __user *p = (const char __user *)current->mm->arg_start;",
            "",
            "\t/* NOTE: this buffer needs to be large enough to hold all the non-arg",
            "\t *       data we put in the audit record for this argument (see the",
            "\t *       code below) ... at this point in time 96 is plenty */",
            "\tchar abuf[96];",
            "",
            "\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the",
            "\t *       current value of 7500 is not as important as the fact that it",
            "\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle",
            "\t *       room if we go over a little bit in the logging below */",
            "\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);",
            "\tlen_max = MAX_EXECVE_AUDIT_LEN;",
            "",
            "\t/* scratch buffer to hold the userspace args */",
            "\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);",
            "\tif (!buf_head) {",
            "\t\taudit_panic(\"out of memory for argv string\");",
            "\t\treturn;",
            "\t}",
            "\tbuf = buf_head;",
            "",
            "\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);",
            "",
            "\tlen_rem = len_max;",
            "\tlen_buf = 0;",
            "\tlen_full = 0;",
            "\trequire_data = true;",
            "\tencode = false;",
            "\titer = 0;",
            "\targ = 0;",
            "\tdo {",
            "\t\t/* NOTE: we don't ever want to trust this value for anything",
            "\t\t *       serious, but the audit record format insists we",
            "\t\t *       provide an argument length for really long arguments,",
            "\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but",
            "\t\t *       to use strncpy_from_user() to obtain this value for",
            "\t\t *       recording in the log, although we don't use it",
            "\t\t *       anywhere here to avoid a double-fetch problem */",
            "\t\tif (len_full == 0)",
            "\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;",
            "",
            "\t\t/* read more data from userspace */",
            "\t\tif (require_data) {",
            "\t\t\t/* can we make more room in the buffer? */",
            "\t\t\tif (buf != buf_head) {",
            "\t\t\t\tmemmove(buf_head, buf, len_buf);",
            "\t\t\t\tbuf = buf_head;",
            "\t\t\t}",
            "",
            "\t\t\t/* fetch as much as we can of the argument */",
            "\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,",
            "\t\t\t\t\t\t    len_max - len_buf);",
            "\t\t\tif (len_tmp == -EFAULT) {",
            "\t\t\t\t/* unable to copy from userspace */",
            "\t\t\t\tsend_sig(SIGKILL, current, 0);",
            "\t\t\t\tgoto out;",
            "\t\t\t} else if (len_tmp == (len_max - len_buf)) {",
            "\t\t\t\t/* buffer is not large enough */",
            "\t\t\t\trequire_data = true;",
            "\t\t\t\t/* NOTE: if we are going to span multiple",
            "\t\t\t\t *       buffers force the encoding so we stand",
            "\t\t\t\t *       a chance at a sane len_full value and",
            "\t\t\t\t *       consistent record encoding */",
            "\t\t\t\tencode = true;",
            "\t\t\t\tlen_full = len_full * 2;",
            "\t\t\t\tp += len_tmp;",
            "\t\t\t} else {",
            "\t\t\t\trequire_data = false;",
            "\t\t\t\tif (!encode)",
            "\t\t\t\t\tencode = audit_string_contains_control(",
            "\t\t\t\t\t\t\t\tbuf, len_tmp);",
            "\t\t\t\t/* try to use a trusted value for len_full */",
            "\t\t\t\tif (len_full < len_max)",
            "\t\t\t\t\tlen_full = (encode ?",
            "\t\t\t\t\t\t    len_tmp * 2 : len_tmp);",
            "\t\t\t\tp += len_tmp + 1;",
            "\t\t\t}",
            "\t\t\tlen_buf += len_tmp;",
            "\t\t\tbuf_head[len_buf] = '\\0';",
            "",
            "\t\t\t/* length of the buffer in the audit record? */",
            "\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);",
            "\t\t}",
            "",
            "\t\t/* write as much as we can to the audit log */",
            "\t\tif (len_buf >= 0) {",
            "\t\t\t/* NOTE: some magic numbers here - basically if we",
            "\t\t\t *       can't fit a reasonable amount of data into the",
            "\t\t\t *       existing audit buffer, flush it and start with",
            "\t\t\t *       a new buffer */",
            "\t\t\tif ((sizeof(abuf) + 8) > len_rem) {",
            "\t\t\t\tlen_rem = len_max;",
            "\t\t\t\taudit_log_end(*ab);",
            "\t\t\t\t*ab = audit_log_start(context,",
            "\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);",
            "\t\t\t\tif (!*ab)",
            "\t\t\t\t\tgoto out;",
            "\t\t\t}",
            "",
            "\t\t\t/* create the non-arg portion of the arg record */",
            "\t\t\tlen_tmp = 0;",
            "\t\t\tif (require_data || (iter > 0) ||",
            "\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {",
            "\t\t\t\tif (iter == 0) {",
            "\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],",
            "\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,",
            "\t\t\t\t\t\t\t\" a%d_len=%lu\",",
            "\t\t\t\t\t\t\targ, len_full);",
            "\t\t\t\t}",
            "\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],",
            "\t\t\t\t\t\t    sizeof(abuf) - len_tmp,",
            "\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);",
            "\t\t\t} else",
            "\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],",
            "\t\t\t\t\t\t    sizeof(abuf) - len_tmp,",
            "\t\t\t\t\t\t    \" a%d=\", arg);",
            "\t\t\tWARN_ON(len_tmp >= sizeof(abuf));",
            "\t\t\tabuf[sizeof(abuf) - 1] = '\\0';",
            "",
            "\t\t\t/* log the arg in the audit record */",
            "\t\t\taudit_log_format(*ab, \"%s\", abuf);",
            "\t\t\tlen_rem -= len_tmp;",
            "\t\t\tlen_tmp = len_buf;",
            "\t\t\tif (encode) {",
            "\t\t\t\tif (len_abuf > len_rem)",
            "\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */",
            "\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);",
            "\t\t\t\tlen_rem -= len_tmp * 2;",
            "\t\t\t\tlen_abuf -= len_tmp * 2;",
            "\t\t\t} else {",
            "\t\t\t\tif (len_abuf > len_rem)",
            "\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */",
            "\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);",
            "\t\t\t\tlen_rem -= len_tmp + 2;",
            "\t\t\t\t/* don't subtract the \"2\" because we still need",
            "\t\t\t\t * to add quotes to the remaining string */",
            "\t\t\t\tlen_abuf -= len_tmp;",
            "\t\t\t}",
            "\t\t\tlen_buf -= len_tmp;",
            "\t\t\tbuf += len_tmp;",
            "\t\t}",
            "",
            "\t\t/* ready to move to the next argument? */",
            "\t\tif ((len_buf == 0) && !require_data) {",
            "\t\t\targ++;",
            "\t\t\titer = 0;",
            "\t\t\tlen_full = 0;",
            "\t\t\trequire_data = true;",
            "\t\t\tencode = false;",
            "\t\t}",
            "\t} while (arg < context->execve.argc);",
            "",
            "\t/* NOTE: the caller handles the final audit_log_end() call */",
            "",
            "out:",
            "\tkfree(buf_head);",
            "}"
          ],
          "function_name": "audit_free_context, audit_log_pid_context, audit_log_execve_info",
          "description": "负责审计上下文释放、进程PID上下文日志记录及execve参数审计日志生成，包含用户态字符串复制与缓冲区管理逻辑",
          "similarity": 0.5670852065086365
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/auditsc.c",
          "start_line": 1827,
          "end_line": 1962,
          "content": [
            "void __audit_free(struct task_struct *tsk)",
            "{",
            "\tstruct audit_context *context = tsk->audit_context;",
            "",
            "\tif (!context)",
            "\t\treturn;",
            "",
            "\t/* this may generate CONFIG_CHANGE records */",
            "\tif (!list_empty(&context->killed_trees))",
            "\t\taudit_kill_trees(context);",
            "",
            "\t/* We are called either by do_exit() or the fork() error handling code;",
            "\t * in the former case tsk == current and in the latter tsk is a",
            "\t * random task_struct that doesn't have any meaningful data we",
            "\t * need to log via audit_log_exit().",
            "\t */",
            "\tif (tsk == current && !context->dummy) {",
            "\t\tcontext->return_valid = AUDITSC_INVALID;",
            "\t\tcontext->return_code = 0;",
            "\t\tif (context->context == AUDIT_CTX_SYSCALL) {",
            "\t\t\taudit_filter_syscall(tsk, context);",
            "\t\t\taudit_filter_inodes(tsk, context);",
            "\t\t\tif (context->current_state == AUDIT_STATE_RECORD)",
            "\t\t\t\taudit_log_exit();",
            "\t\t} else if (context->context == AUDIT_CTX_URING) {",
            "\t\t\t/* TODO: verify this case is real and valid */",
            "\t\t\taudit_filter_uring(tsk, context);",
            "\t\t\taudit_filter_inodes(tsk, context);",
            "\t\t\tif (context->current_state == AUDIT_STATE_RECORD)",
            "\t\t\t\taudit_log_uring(context);",
            "\t\t}",
            "\t}",
            "",
            "\taudit_set_context(tsk, NULL);",
            "\taudit_free_context(context);",
            "}",
            "static void audit_return_fixup(struct audit_context *ctx,",
            "\t\t\t       int success, long code)",
            "{",
            "\t/*",
            "\t * This is actually a test for:",
            "\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||",
            "\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)",
            "\t *",
            "\t * but is faster than a bunch of ||",
            "\t */",
            "\tif (unlikely(code <= -ERESTARTSYS) &&",
            "\t    (code >= -ERESTART_RESTARTBLOCK) &&",
            "\t    (code != -ENOIOCTLCMD))",
            "\t\tctx->return_code = -EINTR;",
            "\telse",
            "\t\tctx->return_code  = code;",
            "\tctx->return_valid = (success ? AUDITSC_SUCCESS : AUDITSC_FAILURE);",
            "}",
            "void __audit_uring_entry(u8 op)",
            "{",
            "\tstruct audit_context *ctx = audit_context();",
            "",
            "\tif (ctx->state == AUDIT_STATE_DISABLED)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * NOTE: It's possible that we can be called from the process' context",
            "\t *       before it returns to userspace, and before audit_syscall_exit()",
            "\t *       is called.  In this case there is not much to do, just record",
            "\t *       the io_uring details and return.",
            "\t */",
            "\tctx->uring_op = op;",
            "\tif (ctx->context == AUDIT_CTX_SYSCALL)",
            "\t\treturn;",
            "",
            "\tctx->dummy = !audit_n_rules;",
            "\tif (!ctx->dummy && ctx->state == AUDIT_STATE_BUILD)",
            "\t\tctx->prio = 0;",
            "",
            "\tctx->context = AUDIT_CTX_URING;",
            "\tctx->current_state = ctx->state;",
            "\tktime_get_coarse_real_ts64(&ctx->ctime);",
            "}",
            "void __audit_uring_exit(int success, long code)",
            "{",
            "\tstruct audit_context *ctx = audit_context();",
            "",
            "\tif (ctx->dummy) {",
            "\t\tif (ctx->context != AUDIT_CTX_URING)",
            "\t\t\treturn;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\taudit_return_fixup(ctx, success, code);",
            "\tif (ctx->context == AUDIT_CTX_SYSCALL) {",
            "\t\t/*",
            "\t\t * NOTE: See the note in __audit_uring_entry() about the case",
            "\t\t *       where we may be called from process context before we",
            "\t\t *       return to userspace via audit_syscall_exit().  In this",
            "\t\t *       case we simply emit a URINGOP record and bail, the",
            "\t\t *       normal syscall exit handling will take care of",
            "\t\t *       everything else.",
            "\t\t *       It is also worth mentioning that when we are called,",
            "\t\t *       the current process creds may differ from the creds",
            "\t\t *       used during the normal syscall processing; keep that",
            "\t\t *       in mind if/when we move the record generation code.",
            "\t\t */",
            "",
            "\t\t/*",
            "\t\t * We need to filter on the syscall info here to decide if we",
            "\t\t * should emit a URINGOP record.  I know it seems odd but this",
            "\t\t * solves the problem where users have a filter to block *all*",
            "\t\t * syscall records in the \"exit\" filter; we want to preserve",
            "\t\t * the behavior here.",
            "\t\t */",
            "\t\taudit_filter_syscall(current, ctx);",
            "\t\tif (ctx->current_state != AUDIT_STATE_RECORD)",
            "\t\t\taudit_filter_uring(current, ctx);",
            "\t\taudit_filter_inodes(current, ctx);",
            "\t\tif (ctx->current_state != AUDIT_STATE_RECORD)",
            "\t\t\treturn;",
            "",
            "\t\taudit_log_uring(ctx);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* this may generate CONFIG_CHANGE records */",
            "\tif (!list_empty(&ctx->killed_trees))",
            "\t\taudit_kill_trees(ctx);",
            "",
            "\t/* run through both filters to ensure we set the filterkey properly */",
            "\taudit_filter_uring(current, ctx);",
            "\taudit_filter_inodes(current, ctx);",
            "\tif (ctx->current_state != AUDIT_STATE_RECORD)",
            "\t\tgoto out;",
            "\taudit_log_exit();",
            "",
            "out:",
            "\taudit_reset_context(ctx);",
            "}"
          ],
          "function_name": "__audit_free, audit_return_fixup, __audit_uring_entry, __audit_uring_exit",
          "description": "该代码块实现了审计上下文的释放逻辑，处理进程退出时的审计记录生成，包含uring操作的入口/出口审计，以及对syscall返回值的修正。核心功能是清理任务的审计上下文，并根据当前状态决定是否记录审计日志。",
          "similarity": 0.5615618228912354
        }
      ]
    },
    {
      "source_file": "kernel/audit.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:49:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit.c`\n\n---\n\n# audit.c 技术文档\n\n## 文件概述\n\n`audit.c` 是 Linux 内核审计子系统的核心实现文件，负责提供内核与用户空间审计守护进程（auditd）之间的通信网关。该文件实现了审计记录的生成、队列管理、速率控制、网络命名空间支持以及与安全模块（如 SELinux）的集成。系统调用相关的审计逻辑已移至 `auditsc.c`，本文件聚焦于通用审计基础设施。\n\n## 核心功能\n\n### 主要全局变量\n- `audit_enabled`：审计系统启用状态（导出符号）\n- `audit_ever_enabled`：标记审计是否曾被启用\n- `audit_failure`：审计失败时的行为策略（如打印内核日志）\n- `audit_rate_limit`：每秒允许发送的审计记录上限（防 DoS）\n- `audit_backlog_limit`：待发送审计消息队列的最大长度\n- `audit_lost`：原子计数器，记录丢失的审计记录数量\n- `audit_sig_uid/audit_sig_pid/audit_sig_sid`：关闭审计系统的用户身份信息\n\n### 核心数据结构\n- `struct audit_net`：每个网络命名空间的审计专用数据（含 netlink socket）\n- `struct auditd_connection`：内核与 auditd 守护进程的连接状态（RCU 保护）\n- `struct audit_buffer`：审计记录的临时格式化缓冲区\n- `struct audit_reply`：审计响应消息结构\n- `struct audit_ctl_mutex`：序列化用户空间请求的互斥锁（带所有者跟踪）\n\n### 关键函数\n- `auditd_test_task()`：检查指定任务是否为注册的 auditd 守护进程\n- `audit_ctl_lock()/audit_ctl_unlock()`：获取/释放审计控制锁\n- `audit_ctl_owner_current()`：检查当前任务是否持有审计控制锁\n- `auditd_pid_vnr()`：获取 auditd 在当前 PID 命名空间中的 PID\n\n### 队列系统\n- `audit_queue`：待发送审计消息的主队列\n- `audit_retry_queue`：因单播发送失败需重试的消息队列\n- `audit_hold_queue`：等待新 auditd 连接建立时暂存的消息队列\n\n## 关键实现\n\n### 初始化状态机\n审计系统通过 `audit_initialized` 三态变量控制初始化流程：\n- `AUDIT_DISABLED` (-1)：显式禁用\n- `AUDIT_UNINITIALIZED` (0)：初始状态\n- `AUDIT_INITIALIZED` (1)：完成初始化（需在 `skb_init` 后）\n\n### RCU 保护的 auditd 连接\n`auditd_conn` 指针通过 RCU 机制保护，读操作使用 `rcu_read_lock()`，写操作需持有 `auditd_conn_lock` 自旋锁。这种设计确保高并发场景下连接状态的安全访问。\n\n### 背压与速率控制\n- **速率限制**：通过 `audit_rate_limit` 限制每秒发送记录数\n- **背压机制**：当队列长度超过 `audit_backlog_limit` 时阻塞生产者，并累计等待时间到 `audit_backlog_wait_time_actual`\n- **内存保护**：使用 `audit_buffer_cache` slab 缓存减少内存分配开销\n\n### 锁所有权跟踪\n`audit_ctl_mutex` 扩展标准 mutex，记录锁所有者 (`owner`)。此设计避免在 `audit_log_start()` 等路径中因递归锁导致死锁，确保审计日志生成不会阻塞持有控制锁的任务。\n\n### 网络命名空间支持\n通过 `audit_net_id` 实现 per-netns 审计 socket，每个网络命名空间拥有独立的 auditd 通信通道，符合内核网络命名空间隔离原则。\n\n## 依赖关系\n\n- **核心依赖**：\n  - `<linux/audit.h>`：审计子系统公共接口\n  - `<net/netlink.h>`：Netlink 通信机制\n  - `<linux/security.h>`：LSM（Linux Security Module）集成点\n- **子系统交互**：\n  - **LSM 框架**：作为安全事件的消费者（如 SELinux 策略拒绝事件）\n  - **PID 命名空间**：通过 `pid_vnr()` 获取命名空间内 PID\n  - **RCU 机制**：用于 auditd 连接状态的无锁读取\n  - **kthread**：`kauditd_task` 内核线程处理消息队列\n- **配套文件**：\n  - `auditsc.c`：系统调用审计逻辑\n  - `audit.h`（本地）：内部头文件\n\n## 使用场景\n\n1. **安全事件记录**：当 LSM（如 SELinux/AppArmor）触发安全策略拒绝时，通过 `audit_log_*` 系列函数生成审计记录\n2. **系统调用审计**：配合 `auditsc.c` 记录符合规则的系统调用（需启用 syscall auditing）\n3. **用户空间交互**：\n   - 接收 auditctl 配置命令（规则加载/查询）\n   - 向 auditd 发送审计事件（通过 Netlink）\n   - 处理 auditd 守护进程的生命周期事件（启动/停止）\n4. **内核自检**：通过 `audit_failure` 配置项处理审计子系统内部错误（如内存不足）\n5. **容器环境支持**：在 PID/net 命名空间中为每个容器提供独立的审计上下文",
      "similarity": 0.6092482805252075,
      "chunks": [
        {
          "chunk_id": 12,
          "file_path": "kernel/audit.c",
          "start_line": 2238,
          "end_line": 2362,
          "content": [
            "void audit_put_tty(struct tty_struct *tty)",
            "{",
            "\ttty_kref_put(tty);",
            "}",
            "void audit_log_task_info(struct audit_buffer *ab)",
            "{",
            "\tconst struct cred *cred;",
            "\tchar comm[sizeof(current->comm)];",
            "\tstruct tty_struct *tty;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tcred = current_cred();",
            "\ttty = audit_get_tty();",
            "\taudit_log_format(ab,",
            "\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"",
            "\t\t\t \" euid=%u suid=%u fsuid=%u\"",
            "\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",",
            "\t\t\t task_ppid_nr(current),",
            "\t\t\t task_tgid_nr(current),",
            "\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),",
            "\t\t\t from_kuid(&init_user_ns, cred->uid),",
            "\t\t\t from_kgid(&init_user_ns, cred->gid),",
            "\t\t\t from_kuid(&init_user_ns, cred->euid),",
            "\t\t\t from_kuid(&init_user_ns, cred->suid),",
            "\t\t\t from_kuid(&init_user_ns, cred->fsuid),",
            "\t\t\t from_kgid(&init_user_ns, cred->egid),",
            "\t\t\t from_kgid(&init_user_ns, cred->sgid),",
            "\t\t\t from_kgid(&init_user_ns, cred->fsgid),",
            "\t\t\t tty ? tty_name(tty) : \"(none)\",",
            "\t\t\t audit_get_sessionid(current));",
            "\taudit_put_tty(tty);",
            "\taudit_log_format(ab, \" comm=\");",
            "\taudit_log_untrustedstring(ab, get_task_comm(comm, current));",
            "\taudit_log_d_path_exe(ab, current->mm);",
            "\taudit_log_task_context(ab);",
            "}",
            "void audit_log_path_denied(int type, const char *operation)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled || audit_dummy_context())",
            "\t\treturn;",
            "",
            "\t/* Generate log with subject, operation, outcome. */",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, type);",
            "\tif (!ab)",
            "\t\treturn;",
            "\taudit_log_format(ab, \"op=%s\", operation);",
            "\taudit_log_task_info(ab);",
            "\taudit_log_format(ab, \" res=0\");",
            "\taudit_log_end(ab);",
            "}",
            "static int audit_set_loginuid_perm(kuid_t loginuid)",
            "{",
            "\t/* if we are unset, we don't need privs */",
            "\tif (!audit_loginuid_set(current))",
            "\t\treturn 0;",
            "\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/",
            "\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))",
            "\t\treturn -EPERM;",
            "\t/* it is set, you need permission */",
            "\tif (!capable(CAP_AUDIT_CONTROL))",
            "\t\treturn -EPERM;",
            "\t/* reject if this is not an unset and we don't allow that */",
            "\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID)",
            "\t\t\t\t && uid_valid(loginuid))",
            "\t\treturn -EPERM;",
            "\treturn 0;",
            "}",
            "static void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,",
            "\t\t\t\t   unsigned int oldsessionid,",
            "\t\t\t\t   unsigned int sessionid, int rc)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tuid_t uid, oldloginuid, loginuid;",
            "\tstruct tty_struct *tty;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_LOGIN);",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tuid = from_kuid(&init_user_ns, task_uid(current));",
            "\toldloginuid = from_kuid(&init_user_ns, koldloginuid);",
            "\tloginuid = from_kuid(&init_user_ns, kloginuid);",
            "\ttty = audit_get_tty();",
            "",
            "\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);",
            "\taudit_log_task_context(ab);",
            "\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",",
            "\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",",
            "\t\t\t oldsessionid, sessionid, !rc);",
            "\taudit_put_tty(tty);",
            "\taudit_log_end(ab);",
            "}",
            "int audit_set_loginuid(kuid_t loginuid)",
            "{",
            "\tunsigned int oldsessionid, sessionid = AUDIT_SID_UNSET;",
            "\tkuid_t oldloginuid;",
            "\tint rc;",
            "",
            "\toldloginuid = audit_get_loginuid(current);",
            "\toldsessionid = audit_get_sessionid(current);",
            "",
            "\trc = audit_set_loginuid_perm(loginuid);",
            "\tif (rc)",
            "\t\tgoto out;",
            "",
            "\t/* are we setting or clearing? */",
            "\tif (uid_valid(loginuid)) {",
            "\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);",
            "\t\tif (unlikely(sessionid == AUDIT_SID_UNSET))",
            "\t\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);",
            "\t}",
            "",
            "\tcurrent->sessionid = sessionid;",
            "\tcurrent->loginuid = loginuid;",
            "out:",
            "\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "audit_put_tty, audit_log_task_info, audit_log_path_denied, audit_set_loginuid_perm, audit_log_set_loginuid, audit_set_loginuid",
          "description": "记录任务详细信息到审计日志，处理路径访问拒绝事件，管理登录UID变更并触发审计日志记录",
          "similarity": 0.5834269523620605
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/audit.c",
          "start_line": 1554,
          "end_line": 1660,
          "content": [
            "static void audit_receive(struct sk_buff *skb)",
            "{",
            "\tstruct nlmsghdr *nlh;",
            "\tbool ack;",
            "\t/*",
            "\t * len MUST be signed for nlmsg_next to be able to dec it below 0",
            "\t * if the nlmsg_len was not aligned",
            "\t */",
            "\tint len;",
            "\tint err;",
            "",
            "\tnlh = nlmsg_hdr(skb);",
            "\tlen = skb->len;",
            "",
            "\taudit_ctl_lock();",
            "\twhile (nlmsg_ok(nlh, len)) {",
            "\t\tack = nlh->nlmsg_flags & NLM_F_ACK;",
            "\t\terr = audit_receive_msg(skb, nlh, &ack);",
            "",
            "\t\t/* send an ack if the user asked for one and audit_receive_msg",
            "\t\t * didn't already do it, or if there was an error. */",
            "\t\tif (ack || err)",
            "\t\t\tnetlink_ack(skb, nlh, err, NULL);",
            "",
            "\t\tnlh = nlmsg_next(nlh, &len);",
            "\t}",
            "\taudit_ctl_unlock();",
            "",
            "\t/* can't block with the ctrl lock, so penalize the sender now */",
            "\tif (audit_backlog_limit &&",
            "\t    (skb_queue_len(&audit_queue) > audit_backlog_limit)) {",
            "\t\tDECLARE_WAITQUEUE(wait, current);",
            "",
            "\t\t/* wake kauditd to try and flush the queue */",
            "\t\twake_up_interruptible(&kauditd_wait);",
            "",
            "\t\tadd_wait_queue_exclusive(&audit_backlog_wait, &wait);",
            "\t\tset_current_state(TASK_UNINTERRUPTIBLE);",
            "\t\tschedule_timeout(audit_backlog_wait_time);",
            "\t\tremove_wait_queue(&audit_backlog_wait, &wait);",
            "\t}",
            "}",
            "static void audit_log_multicast(int group, const char *op, int err)",
            "{",
            "\tconst struct cred *cred;",
            "\tstruct tty_struct *tty;",
            "\tchar comm[sizeof(current->comm)];",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_EVENT_LISTENER);",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tcred = current_cred();",
            "\ttty = audit_get_tty();",
            "\taudit_log_format(ab, \"pid=%u uid=%u auid=%u tty=%s ses=%u\",",
            "\t\t\t task_pid_nr(current),",
            "\t\t\t from_kuid(&init_user_ns, cred->uid),",
            "\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),",
            "\t\t\t tty ? tty_name(tty) : \"(none)\",",
            "\t\t\t audit_get_sessionid(current));",
            "\taudit_put_tty(tty);",
            "\taudit_log_task_context(ab); /* subj= */",
            "\taudit_log_format(ab, \" comm=\");",
            "\taudit_log_untrustedstring(ab, get_task_comm(comm, current));",
            "\taudit_log_d_path_exe(ab, current->mm); /* exe= */",
            "\taudit_log_format(ab, \" nl-mcgrp=%d op=%s res=%d\", group, op, !err);",
            "\taudit_log_end(ab);",
            "}",
            "static int audit_multicast_bind(struct net *net, int group)",
            "{",
            "\tint err = 0;",
            "",
            "\tif (!capable(CAP_AUDIT_READ))",
            "\t\terr = -EPERM;",
            "\taudit_log_multicast(group, \"connect\", err);",
            "\treturn err;",
            "}",
            "static void audit_multicast_unbind(struct net *net, int group)",
            "{",
            "\taudit_log_multicast(group, \"disconnect\", 0);",
            "}",
            "static int __net_init audit_net_init(struct net *net)",
            "{",
            "\tstruct netlink_kernel_cfg cfg = {",
            "\t\t.input\t= audit_receive,",
            "\t\t.bind\t= audit_multicast_bind,",
            "\t\t.unbind\t= audit_multicast_unbind,",
            "\t\t.flags\t= NL_CFG_F_NONROOT_RECV,",
            "\t\t.groups\t= AUDIT_NLGRP_MAX,",
            "\t};",
            "",
            "\tstruct audit_net *aunet = net_generic(net, audit_net_id);",
            "",
            "\taunet->sk = netlink_kernel_create(net, NETLINK_AUDIT, &cfg);",
            "\tif (aunet->sk == NULL) {",
            "\t\taudit_panic(\"cannot initialize netlink socket in namespace\");",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\t/* limit the timeout in case auditd is blocked/stopped */",
            "\taunet->sk->sk_sndtimeo = HZ / 10;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "audit_receive, audit_log_multicast, audit_multicast_bind, audit_multicast_unbind, audit_net_init",
          "description": "实现审计Netlink子系统的核心收发逻辑，包含消息接收处理、多播组连接事件记录，注册Netlink套接字并配置输入回调函数，维护审计多播绑定状态。",
          "similarity": 0.5660897493362427
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/audit.c",
          "start_line": 383,
          "end_line": 503,
          "content": [
            "static int audit_log_config_change(char *function_name, u32 new, u32 old,",
            "\t\t\t\t   int allow_changes)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tint rc = 0;",
            "",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);",
            "\tif (unlikely(!ab))",
            "\t\treturn rc;",
            "\taudit_log_format(ab, \"op=set %s=%u old=%u \", function_name, new, old);",
            "\taudit_log_session_info(ab);",
            "\trc = audit_log_task_context(ab);",
            "\tif (rc)",
            "\t\tallow_changes = 0; /* Something weird, deny request */",
            "\taudit_log_format(ab, \" res=%d\", allow_changes);",
            "\taudit_log_end(ab);",
            "\treturn rc;",
            "}",
            "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)",
            "{",
            "\tint allow_changes, rc = 0;",
            "\tu32 old = *to_change;",
            "",
            "\t/* check if we are locked */",
            "\tif (audit_enabled == AUDIT_LOCKED)",
            "\t\tallow_changes = 0;",
            "\telse",
            "\t\tallow_changes = 1;",
            "",
            "\tif (audit_enabled != AUDIT_OFF) {",
            "\t\trc = audit_log_config_change(function_name, new, old, allow_changes);",
            "\t\tif (rc)",
            "\t\t\tallow_changes = 0;",
            "\t}",
            "",
            "\t/* If we are allowed, make the change */",
            "\tif (allow_changes == 1)",
            "\t\t*to_change = new;",
            "\t/* Not allowed, update reason */",
            "\telse if (rc == 0)",
            "\t\trc = -EPERM;",
            "\treturn rc;",
            "}",
            "static int audit_set_rate_limit(u32 limit)",
            "{",
            "\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);",
            "}",
            "static int audit_set_backlog_limit(u32 limit)",
            "{",
            "\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);",
            "}",
            "static int audit_set_backlog_wait_time(u32 timeout)",
            "{",
            "\treturn audit_do_config_change(\"audit_backlog_wait_time\",",
            "\t\t\t\t      &audit_backlog_wait_time, timeout);",
            "}",
            "static int audit_set_enabled(u32 state)",
            "{",
            "\tint rc;",
            "\tif (state > AUDIT_LOCKED)",
            "\t\treturn -EINVAL;",
            "",
            "\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);",
            "\tif (!rc)",
            "\t\taudit_ever_enabled |= !!state;",
            "",
            "\treturn rc;",
            "}",
            "static int audit_set_failure(u32 state)",
            "{",
            "\tif (state != AUDIT_FAIL_SILENT",
            "\t    && state != AUDIT_FAIL_PRINTK",
            "\t    && state != AUDIT_FAIL_PANIC)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);",
            "}",
            "static void auditd_conn_free(struct rcu_head *rcu)",
            "{",
            "\tstruct auditd_connection *ac;",
            "",
            "\tac = container_of(rcu, struct auditd_connection, rcu);",
            "\tput_pid(ac->pid);",
            "\tput_net(ac->net);",
            "\tkfree(ac);",
            "}",
            "static int auditd_set(struct pid *pid, u32 portid, struct net *net,",
            "\t\t      struct sk_buff *skb, bool *ack)",
            "{",
            "\tunsigned long flags;",
            "\tstruct auditd_connection *ac_old, *ac_new;",
            "\tstruct nlmsghdr *nlh;",
            "",
            "\tif (!pid || !net)",
            "\t\treturn -EINVAL;",
            "",
            "\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);",
            "\tif (!ac_new)",
            "\t\treturn -ENOMEM;",
            "\tac_new->pid = get_pid(pid);",
            "\tac_new->portid = portid;",
            "\tac_new->net = get_net(net);",
            "",
            "\t/* send the ack now to avoid a race with the queue backlog */",
            "\tif (*ack) {",
            "\t\tnlh = nlmsg_hdr(skb);",
            "\t\tnetlink_ack(skb, nlh, 0, NULL);",
            "\t\t*ack = false;",
            "\t}",
            "",
            "\tspin_lock_irqsave(&auditd_conn_lock, flags);",
            "\tac_old = rcu_dereference_protected(auditd_conn,",
            "\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));",
            "\trcu_assign_pointer(auditd_conn, ac_new);",
            "\tspin_unlock_irqrestore(&auditd_conn_lock, flags);",
            "",
            "\tif (ac_old)",
            "\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "audit_log_config_change, audit_do_config_change, audit_set_rate_limit, audit_set_backlog_limit, audit_set_backlog_wait_time, audit_set_enabled, audit_set_failure, auditd_conn_free, auditd_set",
          "description": "提供配置参数修改接口，通过审计日志记录配置变更并更新相关状态，同时管理审计守护进程连接信息。",
          "similarity": 0.5657896995544434
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/audit.c",
          "start_line": 743,
          "end_line": 901,
          "content": [
            "static int kauditd_send_queue(struct sock *sk, u32 portid,",
            "\t\t\t      struct sk_buff_head *queue,",
            "\t\t\t      unsigned int retry_limit,",
            "\t\t\t      void (*skb_hook)(struct sk_buff *skb),",
            "\t\t\t      void (*err_hook)(struct sk_buff *skb, int error))",
            "{",
            "\tint rc = 0;",
            "\tstruct sk_buff *skb = NULL;",
            "\tstruct sk_buff *skb_tail;",
            "\tunsigned int failed = 0;",
            "",
            "\t/* NOTE: kauditd_thread takes care of all our locking, we just use",
            "\t *       the netlink info passed to us (e.g. sk and portid) */",
            "",
            "\tskb_tail = skb_peek_tail(queue);",
            "\twhile ((skb != skb_tail) && (skb = skb_dequeue(queue))) {",
            "\t\t/* call the skb_hook for each skb we touch */",
            "\t\tif (skb_hook)",
            "\t\t\t(*skb_hook)(skb);",
            "",
            "\t\t/* can we send to anyone via unicast? */",
            "\t\tif (!sk) {",
            "\t\t\tif (err_hook)",
            "\t\t\t\t(*err_hook)(skb, -ECONNREFUSED);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "retry:",
            "\t\t/* grab an extra skb reference in case of error */",
            "\t\tskb_get(skb);",
            "\t\trc = netlink_unicast(sk, skb, portid, 0);",
            "\t\tif (rc < 0) {",
            "\t\t\t/* send failed - try a few times unless fatal error */",
            "\t\t\tif (++failed >= retry_limit ||",
            "\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {",
            "\t\t\t\tsk = NULL;",
            "\t\t\t\tif (err_hook)",
            "\t\t\t\t\t(*err_hook)(skb, rc);",
            "\t\t\t\tif (rc == -EAGAIN)",
            "\t\t\t\t\trc = 0;",
            "\t\t\t\t/* continue to drain the queue */",
            "\t\t\t\tcontinue;",
            "\t\t\t} else",
            "\t\t\t\tgoto retry;",
            "\t\t} else {",
            "\t\t\t/* skb sent - drop the extra reference and continue */",
            "\t\t\tconsume_skb(skb);",
            "\t\t\tfailed = 0;",
            "\t\t}",
            "\t}",
            "",
            "\treturn (rc >= 0 ? 0 : rc);",
            "}",
            "static void kauditd_send_multicast_skb(struct sk_buff *skb)",
            "{",
            "\tstruct sk_buff *copy;",
            "\tstruct sock *sock = audit_get_sk(&init_net);",
            "\tstruct nlmsghdr *nlh;",
            "",
            "\t/* NOTE: we are not taking an additional reference for init_net since",
            "\t *       we don't have to worry about it going away */",
            "",
            "\tif (!netlink_has_listeners(sock, AUDIT_NLGRP_READLOG))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * The seemingly wasteful skb_copy() rather than bumping the refcount",
            "\t * using skb_get() is necessary because non-standard mods are made to",
            "\t * the skb by the original kaudit unicast socket send routine.  The",
            "\t * existing auditd daemon assumes this breakage.  Fixing this would",
            "\t * require co-ordinating a change in the established protocol between",
            "\t * the kaudit kernel subsystem and the auditd userspace code.  There is",
            "\t * no reason for new multicast clients to continue with this",
            "\t * non-compliance.",
            "\t */",
            "\tcopy = skb_copy(skb, GFP_KERNEL);",
            "\tif (!copy)",
            "\t\treturn;",
            "\tnlh = nlmsg_hdr(copy);",
            "\tnlh->nlmsg_len = skb->len;",
            "",
            "\tnlmsg_multicast(sock, copy, 0, AUDIT_NLGRP_READLOG, GFP_KERNEL);",
            "}",
            "static int kauditd_thread(void *dummy)",
            "{",
            "\tint rc;",
            "\tu32 portid = 0;",
            "\tstruct net *net = NULL;",
            "\tstruct sock *sk = NULL;",
            "\tstruct auditd_connection *ac;",
            "",
            "#define UNICAST_RETRIES 5",
            "",
            "\tset_freezable();",
            "\twhile (!kthread_should_stop()) {",
            "\t\t/* NOTE: see the lock comments in auditd_send_unicast_skb() */",
            "\t\trcu_read_lock();",
            "\t\tac = rcu_dereference(auditd_conn);",
            "\t\tif (!ac) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto main_queue;",
            "\t\t}",
            "\t\tnet = get_net(ac->net);",
            "\t\tsk = audit_get_sk(net);",
            "\t\tportid = ac->portid;",
            "\t\trcu_read_unlock();",
            "",
            "\t\t/* attempt to flush the hold queue */",
            "\t\trc = kauditd_send_queue(sk, portid,",
            "\t\t\t\t\t&audit_hold_queue, UNICAST_RETRIES,",
            "\t\t\t\t\tNULL, kauditd_rehold_skb);",
            "\t\tif (rc < 0) {",
            "\t\t\tsk = NULL;",
            "\t\t\tauditd_reset(ac);",
            "\t\t\tgoto main_queue;",
            "\t\t}",
            "",
            "\t\t/* attempt to flush the retry queue */",
            "\t\trc = kauditd_send_queue(sk, portid,",
            "\t\t\t\t\t&audit_retry_queue, UNICAST_RETRIES,",
            "\t\t\t\t\tNULL, kauditd_hold_skb);",
            "\t\tif (rc < 0) {",
            "\t\t\tsk = NULL;",
            "\t\t\tauditd_reset(ac);",
            "\t\t\tgoto main_queue;",
            "\t\t}",
            "",
            "main_queue:",
            "\t\t/* process the main queue - do the multicast send and attempt",
            "\t\t * unicast, dump failed record sends to the retry queue; if",
            "\t\t * sk == NULL due to previous failures we will just do the",
            "\t\t * multicast send and move the record to the hold queue */",
            "\t\trc = kauditd_send_queue(sk, portid, &audit_queue, 1,",
            "\t\t\t\t\tkauditd_send_multicast_skb,",
            "\t\t\t\t\t(sk ?",
            "\t\t\t\t\t kauditd_retry_skb : kauditd_hold_skb));",
            "\t\tif (ac && rc < 0)",
            "\t\t\tauditd_reset(ac);",
            "\t\tsk = NULL;",
            "",
            "\t\t/* drop our netns reference, no auditd sends past this line */",
            "\t\tif (net) {",
            "\t\t\tput_net(net);",
            "\t\t\tnet = NULL;",
            "\t\t}",
            "",
            "\t\t/* we have processed all the queues so wake everyone */",
            "\t\twake_up(&audit_backlog_wait);",
            "",
            "\t\t/* NOTE: we want to wake up if there is anything on the queue,",
            "\t\t *       regardless of if an auditd is connected, as we need to",
            "\t\t *       do the multicast send and rotate records from the",
            "\t\t *       main queue to the retry/hold queues */",
            "\t\twait_event_freezable(kauditd_wait,",
            "\t\t\t\t     (skb_queue_len(&audit_queue) ? 1 : 0));",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "kauditd_send_queue, kauditd_send_multicast_skb, kauditd_thread",
          "description": "审计线程主循环，负责从各队列取出审计记录并通过单播或多播方式发送至用户空间审计守护进程。",
          "similarity": 0.5504496693611145
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/audit.c",
          "start_line": 2092,
          "end_line": 2193,
          "content": [
            "bool audit_string_contains_control(const char *string, size_t len)",
            "{",
            "\tconst unsigned char *p;",
            "\tfor (p = string; p < (const unsigned char *)string + len; p++) {",
            "\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,",
            "\t\t\t\t size_t len)",
            "{",
            "\tif (audit_string_contains_control(string, len))",
            "\t\taudit_log_n_hex(ab, string, len);",
            "\telse",
            "\t\taudit_log_n_string(ab, string, len);",
            "}",
            "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)",
            "{",
            "\taudit_log_n_untrustedstring(ab, string, strlen(string));",
            "}",
            "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,",
            "\t\t      const struct path *path)",
            "{",
            "\tchar *p, *pathname;",
            "",
            "\tif (prefix)",
            "\t\taudit_log_format(ab, \"%s\", prefix);",
            "",
            "\t/* We will allow 11 spaces for ' (deleted)' to be appended */",
            "\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);",
            "\tif (!pathname) {",
            "\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");",
            "\t\treturn;",
            "\t}",
            "\tp = d_path(path, pathname, PATH_MAX+11);",
            "\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */",
            "\t\t/* FIXME: can we save some information here? */",
            "\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");",
            "\t} else",
            "\t\taudit_log_untrustedstring(ab, p);",
            "\tkfree(pathname);",
            "}",
            "void audit_log_session_info(struct audit_buffer *ab)",
            "{",
            "\tunsigned int sessionid = audit_get_sessionid(current);",
            "\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));",
            "",
            "\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);",
            "}",
            "void audit_log_key(struct audit_buffer *ab, char *key)",
            "{",
            "\taudit_log_format(ab, \" key=\");",
            "\tif (key)",
            "\t\taudit_log_untrustedstring(ab, key);",
            "\telse",
            "\t\taudit_log_format(ab, \"(null)\");",
            "}",
            "int audit_log_task_context(struct audit_buffer *ab)",
            "{",
            "\tchar *ctx = NULL;",
            "\tunsigned len;",
            "\tint error;",
            "\tu32 sid;",
            "",
            "\tsecurity_current_getsecid_subj(&sid);",
            "\tif (!sid)",
            "\t\treturn 0;",
            "",
            "\terror = security_secid_to_secctx(sid, &ctx, &len);",
            "\tif (error) {",
            "\t\tif (error != -EINVAL)",
            "\t\t\tgoto error_path;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\taudit_log_format(ab, \" subj=%s\", ctx);",
            "\tsecurity_release_secctx(ctx, len);",
            "\treturn 0;",
            "",
            "error_path:",
            "\taudit_panic(\"error in audit_log_task_context\");",
            "\treturn error;",
            "}",
            "void audit_log_d_path_exe(struct audit_buffer *ab,",
            "\t\t\t  struct mm_struct *mm)",
            "{",
            "\tstruct file *exe_file;",
            "",
            "\tif (!mm)",
            "\t\tgoto out_null;",
            "",
            "\texe_file = get_mm_exe_file(mm);",
            "\tif (!exe_file)",
            "\t\tgoto out_null;",
            "",
            "\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);",
            "\tfput(exe_file);",
            "\treturn;",
            "out_null:",
            "\taudit_log_format(ab, \" exe=(null)\");",
            "}"
          ],
          "function_name": "audit_string_contains_control, audit_log_n_untrustedstring, audit_log_untrustedstring, audit_log_d_path, audit_log_session_info, audit_log_key, audit_log_task_context, audit_log_d_path_exe",
          "description": "检测字符串中的控制字符，记录受信/不受信字符串及路径信息，输出会话标识和安全上下文到审计日志",
          "similarity": 0.547205924987793
        }
      ]
    },
    {
      "source_file": "kernel/audit_tree.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:51:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit_tree.c`\n\n---\n\n# audit_tree.c 技术文档\n\n## 1. 文件概述\n\n`audit_tree.c` 是 Linux 内核审计子系统中用于实现**目录树监控**（audit tree watching）的核心模块。该文件提供了对整个目录树（而不仅仅是单个 inode）进行审计监控的能力，通过将审计规则与目录路径关联，并在文件系统事件（如创建、删除、重命名等）发生时高效匹配规则。其核心机制基于 `fsnotify` 框架，在 inode 级别挂载通知标记（mark），并通过引用计数、RCU（Read-Copy-Update）和哈希表等技术保证高并发下的安全性和性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct audit_tree`**  \n  表示一个被监控的目录树。包含路径名、引用计数、关联的规则列表、关联的 chunk 列表等。\n  \n- **`struct audit_chunk`**  \n  表示与一个或多个 inode 关联的监控单元。每个 chunk 通过 `fsnotify_mark` 附加到 inode 上，并维护多个 `audit_tree` 的所有者关系（`owners[]` 数组）。\n\n- **`struct audit_tree_mark`**  \n  封装 `fsnotify_mark`，作为 chunk 与 inode 之间的桥梁，属于 `fsnotify` 框架的扩展标记类型。\n\n- **`struct audit_node`**  \n  嵌入在 `audit_chunk` 中，表示 chunk 与某个 `audit_tree` 的关联关系，包含 owner 指针和索引。\n\n### 主要函数\n\n- **`alloc_tree(const char *s)`**  \n  分配并初始化一个新的 `audit_tree` 实例。\n\n- **`get_tree()` / `put_tree()`**  \n  对 `audit_tree` 进行引用计数管理，`put_tree` 在引用归零时使用 RCU 安全释放。\n\n- **`audit_tree_lookup(const struct inode *inode)`**  \n  在 RCU 读临界区内，根据 inode 查找对应的 `audit_chunk`，并增加其引用计数。\n\n- **`audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)`**  \n  检查给定 chunk 是否属于指定的 audit tree。\n\n- **`alloc_chunk(int count)`**  \n  分配包含指定数量 `audit_node` 的 chunk。\n\n- **`insert_hash(struct audit_chunk *chunk)`**  \n  将 chunk 插入全局哈希表，用于快速查找。\n\n- **`audit_mark_put_chunk()` / `audit_put_chunk()`**  \n  安全释放 chunk 的引用，结合 RCU 机制确保并发安全。\n\n- **`replace_mark_chunk()` / `replace_chunk()`**  \n  在标记或 chunk 更新时进行原子替换（代码片段中 `replace_chunk` 未完整）。\n\n## 3. 关键实现\n\n### 哈希与查找机制\n- 使用 `inode->i_fsnotify_marks` 的地址作为哈希键（`inode_to_key`），确保每个 inode 对应唯一键。\n- 全局哈希表 `chunk_hash_heads[HASH_SIZE]`（大小为 128）配合 `hash_lock` 自旋锁保护写操作。\n- 查找操作（`audit_tree_lookup`）在 RCU 读锁下进行，通过 `READ_ONCE()` 和 `smp_wmb()` 保证内存可见性。\n\n### 引用计数与生命周期管理\n- `audit_tree` 使用 `refcount_t` 管理引用，来源包括：关联的审计规则、chunk 中的 owner 引用。\n- `audit_chunk` 使用 `atomic_long_t refs`，其中一份引用由 `fsnotify_mark` 持有。\n- 所有释放操作均通过 RCU（`call_rcu` / `kfree_rcu`）延迟执行，确保并发读取安全。\n\n### 与 fsnotify 集成\n- 每个被监控的 inode 通过 `audit_tree_mark`（继承 `fsnotify_mark`）关联一个 `audit_chunk`。\n- 当 inode 被删除或 untag 时，`fsnotify` 框架回调 `audit_tree_destroy_watch` 释放 mark。\n- `mark->mask = FS_IN_IGNORED` 表示仅用于内部结构关联，不主动监听事件（实际事件由审计规则触发匹配）。\n\n### 循环链表组织\n- `tree->chunks`：链接所有包含该 tree 的 chunk 中的 `audit_node.list`。\n- `chunk->trees`：链接所有以该 chunk 为根的 tree 的 `same_root` 链表。\n- `tree->rules`：链接所有引用该 tree 的审计规则。\n- 这些链表分别由 `hash_lock` 或 `audit_filter_mutex` 保护。\n\n### 索引位标记\n- `audit_node.index` 的最高位（MSB）用于标记“可能需要回滚”的临时状态，辅助复杂操作（如树重构）的清理逻辑。\n\n## 4. 依赖关系\n\n- **`<linux/fsnotify_backend.h>`**：依赖 fsnotify 框架实现 inode 级别事件通知和标记管理。\n- **`<linux/namei.h>` / `<linux/mount.h>`**：用于路径解析和挂载点处理（虽未在片段中直接调用，但 audit 树需处理跨挂载点语义）。\n- **`audit.h`**：与审计核心模块交互，提供 `audit_tree_path()` 等接口供规则匹配使用。\n- **`<linux/rcupdate.h>`**：使用 RCU 机制保证并发安全。\n- **`<linux/slab.h>`**：使用 `kmem_cache` 高效分配 `audit_tree_mark` 对象。\n\n## 5. 使用场景\n\n- **审计规则匹配**：当用户通过 `auditctl` 添加 `-w /path/to/dir -p wa -k key` 类型规则时，内核将 `/path/to/dir` 注册为 `audit_tree`。\n- **路径遍历监控**：在 `audit_inode()` 和 `audit_inode_child()` 中，内核收集路径上所有 inode 对应的 `audit_chunk`，用于后续与 `AUDIT_TREE` 类型规则匹配。\n- **动态目录结构变更**：当目录树内发生文件创建、删除、重命名或 inode 删除时，通过 fsnotify 机制触发 chunk 更新或 prune（修剪）操作，由专用内核线程 `prune_thread` 处理延迟清理。\n- **资源回收**：当审计规则被删除或监控目录被移除时，相关 `audit_tree` 和 `audit_chunk` 通过引用计数和 RCU 安全释放，避免内存泄漏。",
      "similarity": 0.6004706621170044,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/audit_tree.c",
          "start_line": 458,
          "end_line": 560,
          "content": [
            "static int tag_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk, *old;",
            "\tstruct audit_node *p;",
            "\tint n;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\tmark = fsnotify_find_inode_mark(inode, audit_tree_group);",
            "\tif (!mark)",
            "\t\treturn create_chunk(inode, tree);",
            "",
            "\t/*",
            "\t * Found mark is guaranteed to be attached and mark_mutex protects mark",
            "\t * from getting detached and thus it makes sure there is chunk attached",
            "\t * to the mark.",
            "\t */",
            "\t/* are we already there? */",
            "\tspin_lock(&hash_lock);",
            "\told = mark_chunk(mark);",
            "\tfor (n = 0; n < old->count; n++) {",
            "\t\tif (old->owners[n].owner == tree) {",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\t\tfsnotify_put_mark(mark);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "",
            "\tchunk = alloc_chunk(old->count + 1);",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\tp = &chunk->owners[chunk->count - 1];",
            "\tp->index = (chunk->count - 1) | (1U<<31);",
            "\tp->owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&p->list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(chunk, old);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\tfsnotify_put_mark(mark); /* pair to fsnotify_find_mark */",
            "\taudit_mark_put_chunk(old);",
            "",
            "\treturn 0;",
            "}",
            "static void audit_tree_log_remove_rule(struct audit_context *context,",
            "\t\t\t\t       struct audit_krule *rule)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CONFIG_CHANGE);",
            "\tif (unlikely(!ab))",
            "\t\treturn;",
            "\taudit_log_format(ab, \"op=remove_rule dir=\");",
            "\taudit_log_untrustedstring(ab, rule->tree->pathname);",
            "\taudit_log_key(ab, rule->filterkey);",
            "\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);",
            "\taudit_log_end(ab);",
            "}",
            "static void kill_rules(struct audit_context *context, struct audit_tree *tree)",
            "{",
            "\tstruct audit_krule *rule, *next;",
            "\tstruct audit_entry *entry;",
            "",
            "\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {",
            "\t\tentry = container_of(rule, struct audit_entry, rule);",
            "",
            "\t\tlist_del_init(&rule->rlist);",
            "\t\tif (rule->tree) {",
            "\t\t\t/* not a half-baked one */",
            "\t\t\taudit_tree_log_remove_rule(context, rule);",
            "\t\t\tif (entry->rule.exe)",
            "\t\t\t\taudit_remove_mark(entry->rule.exe);",
            "\t\t\trule->tree = NULL;",
            "\t\t\tlist_del_rcu(&entry->list);",
            "\t\t\tlist_del(&entry->rule.list);",
            "\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "tag_chunk, audit_tree_log_remove_rule, kill_rules",
          "description": "负责规则绑定和解绑操作，包含标记chunk的关联建立与断开。通过日志记录规则变更，触发清理流程，确保审计规则与文件系统事件的动态同步。",
          "similarity": 0.6306555867195129
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/audit_tree.c",
          "start_line": 1,
          "end_line": 110,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include \"audit.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/refcount.h>",
            "#include <linux/slab.h>",
            "",
            "struct audit_tree;",
            "struct audit_chunk;",
            "",
            "struct audit_tree {",
            "\trefcount_t count;",
            "\tint goner;",
            "\tstruct audit_chunk *root;",
            "\tstruct list_head chunks;",
            "\tstruct list_head rules;",
            "\tstruct list_head list;",
            "\tstruct list_head same_root;",
            "\tstruct rcu_head head;",
            "\tchar pathname[];",
            "};",
            "",
            "struct audit_chunk {",
            "\tstruct list_head hash;",
            "\tunsigned long key;",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct list_head trees;\t\t/* with root here */",
            "\tint count;",
            "\tatomic_long_t refs;",
            "\tstruct rcu_head head;",
            "\tstruct audit_node {",
            "\t\tstruct list_head list;",
            "\t\tstruct audit_tree *owner;",
            "\t\tunsigned index;\t\t/* index; upper bit indicates 'will prune' */",
            "\t} owners[];",
            "};",
            "",
            "struct audit_tree_mark {",
            "\tstruct fsnotify_mark mark;",
            "\tstruct audit_chunk *chunk;",
            "};",
            "",
            "static LIST_HEAD(tree_list);",
            "static LIST_HEAD(prune_list);",
            "static struct task_struct *prune_thread;",
            "",
            "/*",
            " * One struct chunk is attached to each inode of interest through",
            " * audit_tree_mark (fsnotify mark). We replace struct chunk on tagging /",
            " * untagging, the mark is stable as long as there is chunk attached. The",
            " * association between mark and chunk is protected by hash_lock and",
            " * audit_tree_group->mark_mutex. Thus as long as we hold",
            " * audit_tree_group->mark_mutex and check that the mark is alive by",
            " * FSNOTIFY_MARK_FLAG_ATTACHED flag check, we are sure the mark points to",
            " * the current chunk.",
            " *",
            " * Rules have pointer to struct audit_tree.",
            " * Rules have struct list_head rlist forming a list of rules over",
            " * the same tree.",
            " * References to struct chunk are collected at audit_inode{,_child}()",
            " * time and used in AUDIT_TREE rule matching.",
            " * These references are dropped at the same time we are calling",
            " * audit_free_names(), etc.",
            " *",
            " * Cyclic lists galore:",
            " * tree.chunks anchors chunk.owners[].list\t\t\thash_lock",
            " * tree.rules anchors rule.rlist\t\t\t\taudit_filter_mutex",
            " * chunk.trees anchors tree.same_root\t\t\t\thash_lock",
            " * chunk.hash is a hash with middle bits of watch.inode as",
            " * a hash function.\t\t\t\t\t\tRCU, hash_lock",
            " *",
            " * tree is refcounted; one reference for \"some rules on rules_list refer to",
            " * it\", one for each chunk with pointer to it.",
            " *",
            " * chunk is refcounted by embedded .refs. Mark associated with the chunk holds",
            " * one chunk reference. This reference is dropped either when a mark is going",
            " * to be freed (corresponding inode goes away) or when chunk attached to the",
            " * mark gets replaced. This reference must be dropped using",
            " * audit_mark_put_chunk() to make sure the reference is dropped only after RCU",
            " * grace period as it protects RCU readers of the hash table.",
            " *",
            " * node.index allows to get from node.list to containing chunk.",
            " * MSB of that sucker is stolen to mark taggings that we might have to",
            " * revert - several operations have very unpleasant cleanup logics and",
            " * that makes a difference.  Some.",
            " */",
            "",
            "static struct fsnotify_group *audit_tree_group __ro_after_init;",
            "static struct kmem_cache *audit_tree_mark_cachep __ro_after_init;",
            "",
            "static struct audit_tree *alloc_tree(const char *s)",
            "{",
            "\tstruct audit_tree *tree;",
            "",
            "\ttree = kmalloc(struct_size(tree, pathname, strlen(s) + 1), GFP_KERNEL);",
            "\tif (tree) {",
            "\t\trefcount_set(&tree->count, 1);",
            "\t\ttree->goner = 0;",
            "\t\tINIT_LIST_HEAD(&tree->chunks);",
            "\t\tINIT_LIST_HEAD(&tree->rules);",
            "\t\tINIT_LIST_HEAD(&tree->list);",
            "\t\tINIT_LIST_HEAD(&tree->same_root);",
            "\t\ttree->root = NULL;",
            "\t\tstrcpy(tree->pathname, s);",
            "\t}",
            "\treturn tree;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了审计树和chunk的数据结构，用于跟踪文件系统事件。audit_tree包含规则列表和路径名，audit_chunk管理与文件节点的关联。全局变量和辅助函数用于初始化、引用计数及哈希表操作，支持审计规则匹配和事件追踪。",
          "similarity": 0.5973317623138428
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/audit_tree.c",
          "start_line": 111,
          "end_line": 218,
          "content": [
            "static inline void get_tree(struct audit_tree *tree)",
            "{",
            "\trefcount_inc(&tree->count);",
            "}",
            "static inline void put_tree(struct audit_tree *tree)",
            "{",
            "\tif (refcount_dec_and_test(&tree->count))",
            "\t\tkfree_rcu(tree, head);",
            "}",
            "static void free_chunk(struct audit_chunk *chunk)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < chunk->count; i++) {",
            "\t\tif (chunk->owners[i].owner)",
            "\t\t\tput_tree(chunk->owners[i].owner);",
            "\t}",
            "\tkfree(chunk);",
            "}",
            "void audit_put_chunk(struct audit_chunk *chunk)",
            "{",
            "\tif (atomic_long_dec_and_test(&chunk->refs))",
            "\t\tfree_chunk(chunk);",
            "}",
            "static void __put_chunk(struct rcu_head *rcu)",
            "{",
            "\tstruct audit_chunk *chunk = container_of(rcu, struct audit_chunk, head);",
            "\taudit_put_chunk(chunk);",
            "}",
            "static void audit_mark_put_chunk(struct audit_chunk *chunk)",
            "{",
            "\tcall_rcu(&chunk->head, __put_chunk);",
            "}",
            "static void audit_tree_destroy_watch(struct fsnotify_mark *mark)",
            "{",
            "\tkmem_cache_free(audit_tree_mark_cachep, audit_mark(mark));",
            "}",
            "static unsigned long inode_to_key(const struct inode *inode)",
            "{",
            "\t/* Use address pointed to by connector->obj as the key */",
            "\treturn (unsigned long)&inode->i_fsnotify_marks;",
            "}",
            "static void insert_hash(struct audit_chunk *chunk)",
            "{",
            "\tstruct list_head *list;",
            "",
            "\t/*",
            "\t * Make sure chunk is fully initialized before making it visible in the",
            "\t * hash. Pairs with a data dependency barrier in READ_ONCE() in",
            "\t * audit_tree_lookup().",
            "\t */",
            "\tsmp_wmb();",
            "\tWARN_ON_ONCE(!chunk->key);",
            "\tlist = chunk_hash(chunk->key);",
            "\tlist_add_rcu(&chunk->hash, list);",
            "}",
            "bool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)",
            "{",
            "\tint n;",
            "\tfor (n = 0; n < chunk->count; n++)",
            "\t\tif (chunk->owners[n].owner == tree)",
            "\t\t\treturn true;",
            "\treturn false;",
            "}",
            "static void replace_mark_chunk(struct fsnotify_mark *mark,",
            "\t\t\t       struct audit_chunk *chunk)",
            "{",
            "\tstruct audit_chunk *old;",
            "",
            "\tassert_spin_locked(&hash_lock);",
            "\told = mark_chunk(mark);",
            "\taudit_mark(mark)->chunk = chunk;",
            "\tif (chunk)",
            "\t\tchunk->mark = mark;",
            "\tif (old)",
            "\t\told->mark = NULL;",
            "}",
            "static void replace_chunk(struct audit_chunk *new, struct audit_chunk *old)",
            "{",
            "\tstruct audit_tree *owner;",
            "\tint i, j;",
            "",
            "\tnew->key = old->key;",
            "\tlist_splice_init(&old->trees, &new->trees);",
            "\tlist_for_each_entry(owner, &new->trees, same_root)",
            "\t\towner->root = new;",
            "\tfor (i = j = 0; j < old->count; i++, j++) {",
            "\t\tif (!old->owners[j].owner) {",
            "\t\t\ti--;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\towner = old->owners[j].owner;",
            "\t\tnew->owners[i].owner = owner;",
            "\t\tnew->owners[i].index = old->owners[j].index - j + i;",
            "\t\tif (!owner) /* result of earlier fallback */",
            "\t\t\tcontinue;",
            "\t\tget_tree(owner);",
            "\t\tlist_replace_init(&old->owners[j].list, &new->owners[i].list);",
            "\t}",
            "\treplace_mark_chunk(old->mark, new);",
            "\t/*",
            "\t * Make sure chunk is fully initialized before making it visible in the",
            "\t * hash. Pairs with a data dependency barrier in READ_ONCE() in",
            "\t * audit_tree_lookup().",
            "\t */",
            "\tsmp_wmb();",
            "\tlist_replace_rcu(&old->hash, &new->hash);",
            "}"
          ],
          "function_name": "get_tree, put_tree, free_chunk, audit_put_chunk, __put_chunk, audit_mark_put_chunk, audit_tree_destroy_watch, inode_to_key, insert_hash, audit_tree_match, replace_mark_chunk, replace_chunk",
          "description": "提供对audit_tree和audit_chunk的引用计数管理，包含分配/释放chunk逻辑，处理标记替换及哈希表插入。通过RCU机制确保并发安全性，维护规则匹配所需的数据结构一致性。",
          "similarity": 0.593495786190033
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/audit_tree.c",
          "start_line": 325,
          "end_line": 451,
          "content": [
            "static void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)",
            "{",
            "\tstruct audit_tree *owner = p->owner;",
            "",
            "\tif (owner->root == chunk) {",
            "\t\tlist_del_init(&owner->same_root);",
            "\t\towner->root = NULL;",
            "\t}",
            "\tlist_del_init(&p->list);",
            "\tp->owner = NULL;",
            "\tput_tree(owner);",
            "}",
            "static int chunk_count_trees(struct audit_chunk *chunk)",
            "{",
            "\tint i;",
            "\tint ret = 0;",
            "",
            "\tfor (i = 0; i < chunk->count; i++)",
            "\t\tif (chunk->owners[i].owner)",
            "\t\t\tret++;",
            "\treturn ret;",
            "}",
            "static void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)",
            "{",
            "\tstruct audit_chunk *new;",
            "\tint size;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\t/*",
            "\t * mark_mutex stabilizes chunk attached to the mark so we can check",
            "\t * whether it didn't change while we've dropped hash_lock.",
            "\t */",
            "\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||",
            "\t    mark_chunk(mark) != chunk)",
            "\t\tgoto out_mutex;",
            "",
            "\tsize = chunk_count_trees(chunk);",
            "\tif (!size) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&chunk->trees);",
            "\t\tlist_del_rcu(&chunk->hash);",
            "\t\treplace_mark_chunk(mark, NULL);",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\taudit_mark_put_chunk(chunk);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\treturn;",
            "\t}",
            "",
            "\tnew = alloc_chunk(size);",
            "\tif (!new)",
            "\t\tgoto out_mutex;",
            "",
            "\tspin_lock(&hash_lock);",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(new, chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\taudit_mark_put_chunk(chunk);",
            "\treturn;",
            "",
            "out_mutex:",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "}",
            "static int create_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk = alloc_chunk(1);",
            "",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tmark = alloc_mark();",
            "\tif (!mark) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\treplace_mark_chunk(mark, chunk);",
            "\tchunk->owners[0].index = (1U << 31);",
            "\tchunk->owners[0].owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&chunk->owners[0].list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\tchunk->key = inode_to_key(inode);",
            "\t/*",
            "\t * Inserting into the hash table has to go last as once we do that RCU",
            "\t * readers can see the chunk.",
            "\t */",
            "\tinsert_hash(chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\t/*",
            "\t * Drop our initial reference. When mark we point to is getting freed,",
            "\t * we get notification through ->freeing_mark callback and cleanup",
            "\t * chunk pointing to this mark.",
            "\t */",
            "\tfsnotify_put_mark(mark);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "remove_chunk_node, chunk_count_trees, untag_chunk, create_chunk",
          "description": "实现文件节点标记的增删改查逻辑，包含chunk创建、旧chunk清理及哈希表更新。通过锁保护确保操作原子性，处理标记失效场景并释放无效资源，维持审计系统状态有效性。",
          "similarity": 0.5800006985664368
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/audit_tree.c",
          "start_line": 1006,
          "end_line": 1081,
          "content": [
            "static void evict_chunk(struct audit_chunk *chunk)",
            "{",
            "\tstruct audit_tree *owner;",
            "\tstruct list_head *postponed = audit_killed_trees();",
            "\tint need_prune = 0;",
            "\tint n;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tspin_lock(&hash_lock);",
            "\twhile (!list_empty(&chunk->trees)) {",
            "\t\towner = list_entry(chunk->trees.next,",
            "\t\t\t\t   struct audit_tree, same_root);",
            "\t\towner->goner = 1;",
            "\t\towner->root = NULL;",
            "\t\tlist_del_init(&owner->same_root);",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tif (!postponed) {",
            "\t\t\tkill_rules(audit_context(), owner);",
            "\t\t\tlist_move(&owner->list, &prune_list);",
            "\t\t\tneed_prune = 1;",
            "\t\t} else {",
            "\t\t\tlist_move(&owner->list, postponed);",
            "\t\t}",
            "\t\tspin_lock(&hash_lock);",
            "\t}",
            "\tlist_del_rcu(&chunk->hash);",
            "\tfor (n = 0; n < chunk->count; n++)",
            "\t\tlist_del_init(&chunk->owners[n].list);",
            "\tspin_unlock(&hash_lock);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\tif (need_prune)",
            "\t\taudit_schedule_prune();",
            "}",
            "static int audit_tree_handle_event(struct fsnotify_mark *mark, u32 mask,",
            "\t\t\t\t   struct inode *inode, struct inode *dir,",
            "\t\t\t\t   const struct qstr *file_name, u32 cookie)",
            "{",
            "\treturn 0;",
            "}",
            "static void audit_tree_freeing_mark(struct fsnotify_mark *mark,",
            "\t\t\t\t    struct fsnotify_group *group)",
            "{",
            "\tstruct audit_chunk *chunk;",
            "",
            "\tfsnotify_group_lock(mark->group);",
            "\tspin_lock(&hash_lock);",
            "\tchunk = mark_chunk(mark);",
            "\treplace_mark_chunk(mark, NULL);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(mark->group);",
            "\tif (chunk) {",
            "\t\tevict_chunk(chunk);",
            "\t\taudit_mark_put_chunk(chunk);",
            "\t}",
            "",
            "\t/*",
            "\t * We are guaranteed to have at least one reference to the mark from",
            "\t * either the inode or the caller of fsnotify_destroy_mark().",
            "\t */",
            "\tBUG_ON(refcount_read(&mark->refcnt) < 1);",
            "}",
            "static int __init audit_tree_init(void)",
            "{",
            "\tint i;",
            "",
            "\taudit_tree_mark_cachep = KMEM_CACHE(audit_tree_mark, SLAB_PANIC);",
            "",
            "\taudit_tree_group = fsnotify_alloc_group(&audit_tree_ops, 0);",
            "\tif (IS_ERR(audit_tree_group))",
            "\t\taudit_panic(\"cannot initialize fsnotify group for rectree watches\");",
            "",
            "\tfor (i = 0; i < HASH_SIZE; i++)",
            "\t\tINIT_LIST_HEAD(&chunk_hash_heads[i]);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "evict_chunk, audit_tree_handle_event, audit_tree_freeing_mark, audit_tree_init",
          "description": "实现审计块管理与初始化，evict_chunk负责移除失效块关联的树结构并触发展开修剪，audit_tree_handle_event处理文件系统事件但当前无实际逻辑，audit_tree_freeing_mark在释放标记时触发块回收，audit_tree_init初始化缓存与fsnotify组结构。",
          "similarity": 0.5784550905227661
        }
      ]
    }
  ]
}