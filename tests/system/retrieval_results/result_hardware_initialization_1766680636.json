{
  "query": "hardware_initialization",
  "timestamp": "2025-12-26 00:37:16",
  "retrieved_files": [
    {
      "source_file": "mm/kasan/hw_tags.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:14:10\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kasan\\hw_tags.c`\n\n---\n\n# `kasan/hw_tags.c` 技术文档\n\n## 1. 文件概述\n\n`kasan/hw_tags.c` 是 Linux 内核中硬件标签（Hardware Tag-Based）KASAN（Kernel Address Sanitizer）的核心实现文件。该文件负责初始化和管理基于硬件内存标签（如 ARM64 的 MTE，Memory Tagging Extension）的 KASAN 功能，包括命令行参数解析、运行模式配置、vmalloc 区域支持以及每 CPU 初始化逻辑。其目标是利用硬件特性高效检测内核中的内存安全问题（如越界访问、释放后使用等），同时提供同步（sync）、异步（async）和非对称（asymm）等多种检测模式。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `kasan_arg`：控制 KASAN 是否启用（`off`/`on`）。\n- `kasan_arg_mode`：指定 KASAN 运行模式（`sync`/`async`/`asymm`）。\n- `kasan_arg_vmalloc`：控制是否对 vmalloc 分配的内存启用标签。\n- `kasan_flag_enabled`：静态键（static key），表示 KASAN 是否已启用。\n- `kasan_mode`：当前生效的 KASAN 模式（`KASAN_MODE_SYNC` 等）。\n- `kasan_flag_vmalloc`：静态键，表示是否启用 vmalloc 标签。\n- `kasan_page_alloc_sample` 和 `kasan_page_alloc_sample_order`：用于对 page allocator 的分配进行采样（减少性能开销）。\n- `kasan_page_alloc_skip`（per-CPU）：记录跳过的 page allocator 分配次数。\n\n### 主要函数\n- `early_kasan_flag()` / `early_kasan_mode()` / `early_kasan_flag_vmalloc()` / `early_kasan_flag_page_alloc_sample()` / `early_kasan_flag_page_alloc_sample_order()`：解析内核启动参数（`kasan=`, `kasan.mode=`, `kasan.vmalloc=`, `kasan.page_alloc.sample=`, `kasan.page_alloc.sample.order=`）。\n- `kasan_init_hw_tags_cpu()`：为每个 CPU 初始化硬件标签功能（支持 CPU 热插拔）。\n- `kasan_init_hw_tags()`：在启动 CPU 上执行一次性的 KASAN 硬件标签初始化。\n- `__kasan_unpoison_vmalloc()`：对 vmalloc 分配的内存进行“解毒”（unpoison），即设置有效的内存标签（仅限 `VM_ALLOC` 类型）。\n- `unpoison_vmalloc_pages()`：为 vmalloc 区域中的每个物理页设置指定的标签。\n- `init_vmalloc_pages()`：清除 vmalloc 页面的高字节（用于未启用 KASAN 时的初始化）。\n\n## 3. 关键实现\n\n### 命令行参数处理\n通过 `early_param()` 宏注册多个启动参数：\n- `kasan=off/on`：全局开关。\n- `kasan.mode=sync/async/asymm`：选择检测模式。\n- `kasan.vmalloc=off/on`：控制 vmalloc 标签。\n- `kasan.page_alloc.sample=N` 和 `kasan.page_alloc.sample.order=M`：对大块页面分配启用采样机制，以降低性能开销。\n\n### 初始化流程\n1. **硬件能力检查**：`kasan_init_hw_tags()` 首先调用 `system_supports_mte()` 确认 CPU 支持 MTE。\n2. **参数应用**：根据命令行参数设置 `kasan_mode` 和 `kasan_flag_vmalloc` 静态键。\n3. **标签子系统初始化**：调用 `kasan_init_tags()` 完成底层标签管理结构的初始化。\n4. **启用 KASAN**：通过 `static_branch_enable(&kasan_flag_enabled)` 激活 KASAN 功能。\n5. **CPU 级初始化**：`kasan_init_hw_tags_cpu()` 在每个 CPU 上调用 `kasan_enable_hw_tags()` 启用硬件标签功能（如设置 TCR_EL1.TBI 等寄存器位）。\n\n### vmalloc 支持\n- **限制**：硬件标签 KASAN 仅支持 `VM_ALLOC` 类型的 vmalloc 分配（即通过 `vmalloc()`/`vzalloc()` 等分配的内存）。\n- **原因**：\n  - 硬件标签只能应用于物理内存，且一个物理页只能有一个有效标签。\n  - 非 `VM_ALLOC` 映射可能由其他子系统创建，难以统一管理标签。\n- **实现**：`__kasan_unpoison_vmalloc()` 为 `VM_ALLOC` 区域分配随机标签，并通过 `unpoison_vmalloc_pages()` 将标签写入每个物理页的 `page->flags` 中（通过 `page_kasan_tag_set()`）。\n\n### 采样机制\n- 对 `order >= kasan_page_alloc_sample_order` 的页面分配，以 `1/kasan_page_alloc_sample` 的概率跳过 KASAN 检查。\n- 使用 per-CPU 变量 `kasan_page_alloc_skip` 跟踪跳过次数，避免频繁调用随机数生成器。\n\n## 4. 依赖关系\n\n- **架构依赖**：依赖 ARM64 架构的 MTE（Memory Tagging Extension）支持，通过 `system_supports_mte()` 和 `kasan_enable_hw_tags()` 等架构相关函数交互。\n- **内存管理子系统**：\n  - 依赖 `mm/vmalloc.c` 提供 `find_vm_area()`、`vmalloc_to_page()` 等接口。\n  - 与页面分配器（`mm/page_alloc.c`）集成，通过 `___GFP_SKIP_KASAN` 标志跳过某些分配的标签处理。\n- **KASAN 通用框架**：包含 `\"kasan.h\"`，与软件 KASAN（shadow-based）共享部分基础设施，但实现独立。\n- **静态键（Static Keys）**：使用 `DEFINE_STATIC_KEY_FALSE/TRUE` 实现运行时零开销的条件判断。\n\n## 5. 使用场景\n\n- **内核开发与调试**：在支持 MTE 的 ARM64 平台上启用 KASAN，用于检测内核内存错误。\n- **性能敏感场景**：通过 `async` 或 `asymm` 模式降低运行时开销，或通过 `kasan.page_alloc.sample` 对大内存分配进行采样。\n- **虚拟内存调试**：当需要检测 vmalloc 区域的内存错误时，启用 `kasan.vmalloc=on`。\n- **生产环境部署**：在支持 MTE 的服务器或移动设备上，使用异步模式进行轻量级内存安全监控。\n- **CPU 热插拔**：通过 `kasan_init_hw_tags_cpu()` 确保新上线的 CPU 正确初始化硬件标签功能。",
      "similarity": 0.53973388671875,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/kasan/hw_tags.c",
          "start_line": 213,
          "end_line": 310,
          "content": [
            "void __init kasan_init_hw_tags(void)",
            "{",
            "\t/* If hardware doesn't support MTE, don't initialize KASAN. */",
            "\tif (!system_supports_mte())",
            "\t\treturn;",
            "",
            "\t/* If KASAN is disabled via command line, don't initialize it. */",
            "\tif (kasan_arg == KASAN_ARG_OFF)",
            "\t\treturn;",
            "",
            "\tswitch (kasan_arg_mode) {",
            "\tcase KASAN_ARG_MODE_DEFAULT:",
            "\t\t/* Default is specified by kasan_mode definition. */",
            "\t\tbreak;",
            "\tcase KASAN_ARG_MODE_SYNC:",
            "\t\tkasan_mode = KASAN_MODE_SYNC;",
            "\t\tbreak;",
            "\tcase KASAN_ARG_MODE_ASYNC:",
            "\t\tkasan_mode = KASAN_MODE_ASYNC;",
            "\t\tbreak;",
            "\tcase KASAN_ARG_MODE_ASYMM:",
            "\t\tkasan_mode = KASAN_MODE_ASYMM;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tswitch (kasan_arg_vmalloc) {",
            "\tcase KASAN_ARG_VMALLOC_DEFAULT:",
            "\t\t/* Default is specified by kasan_flag_vmalloc definition. */",
            "\t\tbreak;",
            "\tcase KASAN_ARG_VMALLOC_OFF:",
            "\t\tstatic_branch_disable(&kasan_flag_vmalloc);",
            "\t\tbreak;",
            "\tcase KASAN_ARG_VMALLOC_ON:",
            "\t\tstatic_branch_enable(&kasan_flag_vmalloc);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tkasan_init_tags();",
            "",
            "\t/* KASAN is now initialized, enable it. */",
            "\tstatic_branch_enable(&kasan_flag_enabled);",
            "",
            "\tpr_info(\"KernelAddressSanitizer initialized (hw-tags, mode=%s, vmalloc=%s, stacktrace=%s)\\n\",",
            "\t\tkasan_mode_info(),",
            "\t\tkasan_vmalloc_enabled() ? \"on\" : \"off\",",
            "\t\tkasan_stack_collection_enabled() ? \"on\" : \"off\");",
            "}",
            "static void unpoison_vmalloc_pages(const void *addr, u8 tag)",
            "{",
            "\tstruct vm_struct *area;",
            "\tint i;",
            "",
            "\t/*",
            "\t * As hardware tag-based KASAN only tags VM_ALLOC vmalloc allocations",
            "\t * (see the comment in __kasan_unpoison_vmalloc), all of the pages",
            "\t * should belong to a single area.",
            "\t */",
            "\tarea = find_vm_area((void *)addr);",
            "\tif (WARN_ON(!area))",
            "\t\treturn;",
            "",
            "\tfor (i = 0; i < area->nr_pages; i++) {",
            "\t\tstruct page *page = area->pages[i];",
            "",
            "\t\tpage_kasan_tag_set(page, tag);",
            "\t}",
            "}",
            "static void init_vmalloc_pages(const void *start, unsigned long size)",
            "{",
            "\tconst void *addr;",
            "",
            "\tfor (addr = start; addr < start + size; addr += PAGE_SIZE) {",
            "\t\tstruct page *page = vmalloc_to_page(addr);",
            "",
            "\t\tclear_highpage_kasan_tagged(page);",
            "\t}",
            "}",
            "void __kasan_poison_vmalloc(const void *start, unsigned long size)",
            "{",
            "\t/*",
            "\t * No tagging here.",
            "\t * The physical pages backing the vmalloc() allocation are poisoned",
            "\t * through the usual page_alloc paths.",
            "\t */",
            "}",
            "void kasan_enable_hw_tags(void)",
            "{",
            "\tif (kasan_arg_mode == KASAN_ARG_MODE_ASYNC)",
            "\t\thw_enable_tag_checks_async();",
            "\telse if (kasan_arg_mode == KASAN_ARG_MODE_ASYMM)",
            "\t\thw_enable_tag_checks_asymm();",
            "\telse",
            "\t\thw_enable_tag_checks_sync();",
            "}",
            "void kasan_force_async_fault(void)",
            "{",
            "\thw_force_async_tag_fault();",
            "}"
          ],
          "function_name": "kasan_init_hw_tags, unpoison_vmalloc_pages, init_vmalloc_pages, __kasan_poison_vmalloc, kasan_enable_hw_tags, kasan_force_async_fault",
          "description": "执行KASAN硬件标签初始化流程，根据系统能力检查MTE支持，配置KASAN工作模式与虚拟内存标签策略，调用底层接口完成标签初始化，并提供强制触发异步故障的接口。",
          "similarity": 0.600054144859314
        },
        {
          "chunk_id": 1,
          "file_path": "mm/kasan/hw_tags.c",
          "start_line": 82,
          "end_line": 182,
          "content": [
            "static int __init early_kasan_flag(char *arg)",
            "{",
            "\tif (!arg)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!strcmp(arg, \"off\"))",
            "\t\tkasan_arg = KASAN_ARG_OFF;",
            "\telse if (!strcmp(arg, \"on\"))",
            "\t\tkasan_arg = KASAN_ARG_ON;",
            "\telse",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int __init early_kasan_mode(char *arg)",
            "{",
            "\tif (!arg)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!strcmp(arg, \"sync\"))",
            "\t\tkasan_arg_mode = KASAN_ARG_MODE_SYNC;",
            "\telse if (!strcmp(arg, \"async\"))",
            "\t\tkasan_arg_mode = KASAN_ARG_MODE_ASYNC;",
            "\telse if (!strcmp(arg, \"asymm\"))",
            "\t\tkasan_arg_mode = KASAN_ARG_MODE_ASYMM;",
            "\telse",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int __init early_kasan_flag_vmalloc(char *arg)",
            "{",
            "\tif (!arg)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!strcmp(arg, \"off\"))",
            "\t\tkasan_arg_vmalloc = KASAN_ARG_VMALLOC_OFF;",
            "\telse if (!strcmp(arg, \"on\"))",
            "\t\tkasan_arg_vmalloc = KASAN_ARG_VMALLOC_ON;",
            "\telse",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int __init early_kasan_flag_page_alloc_sample(char *arg)",
            "{",
            "\tint rv;",
            "",
            "\tif (!arg)",
            "\t\treturn -EINVAL;",
            "",
            "\trv = kstrtoul(arg, 0, &kasan_page_alloc_sample);",
            "\tif (rv)",
            "\t\treturn rv;",
            "",
            "\tif (!kasan_page_alloc_sample || kasan_page_alloc_sample > LONG_MAX) {",
            "\t\tkasan_page_alloc_sample = PAGE_ALLOC_SAMPLE_DEFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init early_kasan_flag_page_alloc_sample_order(char *arg)",
            "{",
            "\tint rv;",
            "",
            "\tif (!arg)",
            "\t\treturn -EINVAL;",
            "",
            "\trv = kstrtouint(arg, 0, &kasan_page_alloc_sample_order);",
            "\tif (rv)",
            "\t\treturn rv;",
            "",
            "\tif (kasan_page_alloc_sample_order > INT_MAX) {",
            "\t\tkasan_page_alloc_sample_order = PAGE_ALLOC_SAMPLE_ORDER_DEFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void kasan_init_hw_tags_cpu(void)",
            "{",
            "\t/*",
            "\t * There's no need to check that the hardware is MTE-capable here,",
            "\t * as this function is only called for MTE-capable hardware.",
            "\t */",
            "",
            "\t/*",
            "\t * If KASAN is disabled via command line, don't initialize it.",
            "\t * When this function is called, kasan_flag_enabled is not yet",
            "\t * set by kasan_init_hw_tags(). Thus, check kasan_arg instead.",
            "\t */",
            "\tif (kasan_arg == KASAN_ARG_OFF)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Enable async or asymm modes only when explicitly requested",
            "\t * through the command line.",
            "\t */",
            "\tkasan_enable_hw_tags();",
            "}"
          ],
          "function_name": "early_kasan_flag, early_kasan_mode, early_kasan_flag_vmalloc, early_kasan_flag_page_alloc_sample, early_kasan_flag_page_alloc_sample_order, kasan_init_hw_tags_cpu",
          "description": "解析启动参数以配置KASAN运行时参数，通过early_*系列函数设置kasan_arg、kasan_arg_mode等变量，并在cpu初始化阶段根据参数决定是否启用硬件标签检查。",
          "similarity": 0.5622056722640991
        },
        {
          "chunk_id": 0,
          "file_path": "mm/kasan/hw_tags.c",
          "start_line": 1,
          "end_line": 81,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * This file contains core hardware tag-based KASAN code.",
            " *",
            " * Copyright (c) 2020 Google, Inc.",
            " * Author: Andrey Konovalov <andreyknvl@google.com>",
            " */",
            "",
            "#define pr_fmt(fmt) \"kasan: \" fmt",
            "",
            "#include <linux/init.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/static_key.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/vmalloc.h>",
            "",
            "#include \"kasan.h\"",
            "",
            "enum kasan_arg {",
            "\tKASAN_ARG_DEFAULT,",
            "\tKASAN_ARG_OFF,",
            "\tKASAN_ARG_ON,",
            "};",
            "",
            "enum kasan_arg_mode {",
            "\tKASAN_ARG_MODE_DEFAULT,",
            "\tKASAN_ARG_MODE_SYNC,",
            "\tKASAN_ARG_MODE_ASYNC,",
            "\tKASAN_ARG_MODE_ASYMM,",
            "};",
            "",
            "enum kasan_arg_vmalloc {",
            "\tKASAN_ARG_VMALLOC_DEFAULT,",
            "\tKASAN_ARG_VMALLOC_OFF,",
            "\tKASAN_ARG_VMALLOC_ON,",
            "};",
            "",
            "static enum kasan_arg kasan_arg __ro_after_init;",
            "static enum kasan_arg_mode kasan_arg_mode __ro_after_init;",
            "static enum kasan_arg_vmalloc kasan_arg_vmalloc __initdata;",
            "",
            "/*",
            " * Whether KASAN is enabled at all.",
            " * The value remains false until KASAN is initialized by kasan_init_hw_tags().",
            " */",
            "DEFINE_STATIC_KEY_FALSE(kasan_flag_enabled);",
            "EXPORT_SYMBOL(kasan_flag_enabled);",
            "",
            "/*",
            " * Whether the selected mode is synchronous, asynchronous, or asymmetric.",
            " * Defaults to KASAN_MODE_SYNC.",
            " */",
            "enum kasan_mode kasan_mode __ro_after_init;",
            "EXPORT_SYMBOL_GPL(kasan_mode);",
            "",
            "/* Whether to enable vmalloc tagging. */",
            "DEFINE_STATIC_KEY_TRUE(kasan_flag_vmalloc);",
            "",
            "#define PAGE_ALLOC_SAMPLE_DEFAULT\t1",
            "#define PAGE_ALLOC_SAMPLE_ORDER_DEFAULT\t3",
            "",
            "/*",
            " * Sampling interval of page_alloc allocation (un)poisoning.",
            " * Defaults to no sampling.",
            " */",
            "unsigned long kasan_page_alloc_sample = PAGE_ALLOC_SAMPLE_DEFAULT;",
            "",
            "/*",
            " * Minimum order of page_alloc allocations to be affected by sampling.",
            " * The default value is chosen to match both",
            " * PAGE_ALLOC_COSTLY_ORDER and SKB_FRAG_PAGE_ORDER.",
            " */",
            "unsigned int kasan_page_alloc_sample_order = PAGE_ALLOC_SAMPLE_ORDER_DEFAULT;",
            "",
            "DEFINE_PER_CPU(long, kasan_page_alloc_skip);",
            "",
            "/* kasan=off/on */"
          ],
          "function_name": null,
          "description": "定义KASAN硬件标签模式及相关参数，包括启用/禁用状态、模式选择（同步/异步/不对称）、虚拟内存分配标签控制及页面分配采样间隔等全局变量，并声明用于跟踪KASAN是否启用的静态键。",
          "similarity": 0.4244779348373413
        }
      ]
    },
    {
      "source_file": "kernel/sched/isolation.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:11:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\isolation.c`\n\n---\n\n# `sched/isolation.c` 技术文档\n\n## 1. 文件概述\n\n`sched/isolation.c` 实现了 Linux 内核中的 **housekeeping（家务管理）机制**，用于管理那些必须在特定 CPU 上运行的通用内核任务（如未绑定的工作队列、定时器、内核线程、RCU 回调、调度器相关任务等）。该机制支持通过内核启动参数（如 `nohz_full=` 和 `isolcpus=`）将某些 CPU 从常规内核任务中“隔离”出来，以提升实时性或减少干扰，常用于高性能计算、低延迟或实时系统场景。\n\n核心目标是：**允许用户指定一组“非隔离”CPU（即 housekeeping CPU）专门处理内核后台任务，而将其他 CPU 保留给用户关键任务使用**。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`enum hk_flags`**  \n  定义 housekeeping 功能类型对应的位标志，包括：\n  - `HK_FLAG_TIMER`：定时器\n  - `HK_FLAG_RCU`：RCU 回调\n  - `HK_FLAG_MISC`：杂项内核任务\n  - `HK_FLAG_SCHED`：调度器相关任务\n  - `HK_FLAG_TICK`：周期性 tick（与 NO_HZ_FULL 相关）\n  - `HK_FLAG_DOMAIN`：调度域构建\n  - `HK_FLAG_WQ`：工作队列\n  - `HK_FLAG_MANAGED_IRQ`：托管中断亲和性\n  - `HK_FLAG_KTHREAD`：内核线程\n\n- **`struct housekeeping`**  \n  全局结构体，包含：\n  - `cpumasks[HK_TYPE_MAX]`：每种 housekeeping 类型对应的 CPU 掩码\n  - `flags`：启用的 housekeeping 功能位图\n\n- **`housekeeping_overridden`**  \n  静态分支键（`static_key`），用于快速判断是否启用了自定义 housekeeping 配置。\n\n### 主要函数\n\n- **`housekeeping_enabled(enum hk_type type)`**  \n  检查指定类型的 housekeeping 是否启用。\n\n- **`housekeeping_any_cpu(enum hk_type type)`**  \n  返回适合执行指定类型 housekeeping 任务的 CPU（优先 NUMA 亲和，其次任意在线 CPU）。\n\n- **`housekeeping_cpumask(enum hk_type type)`**  \n  返回指定类型 housekeeping 任务允许运行的 CPU 掩码。\n\n- **`housekeeping_affine(struct task_struct *t, enum hk_type type)`**  \n  将任务 `t` 的 CPU 亲和性限制为指定类型 housekeeping 的 CPU 集合。\n\n- **`housekeeping_test_cpu(int cpu, enum hk_type type)`**  \n  检查指定 CPU 是否属于指定类型 housekeeping 的允许集合。\n\n- **`housekeeping_init(void)`**  \n  初始化 housekeeping 子系统，启用静态分支并验证配置。\n\n- **`housekeeping_setup(char *str, unsigned long flags)`**  \n  解析启动参数（CPU 列表），设置 housekeeping 的 CPU 掩码和功能标志。\n\n- **`housekeeping_nohz_full_setup()` / `housekeeping_isolcpus_setup()`**  \n  分别处理 `nohz_full=` 和 `isolcpus=` 内核启动参数。\n\n- **`enhanced_isolcpus_setup()`**  \n  处理 `enhanced_isolcpus` 启动参数，启用增强隔离模式（仅设标志，具体行为由其他子系统实现）。\n\n## 3. 关键实现\n\n### 静态分支优化\n使用 `static_branch_unlikely(&housekeeping_overridden)` 实现零开销快速路径：当未配置隔离时，所有 housekeeping 函数直接返回默认值（如 `smp_processor_id()` 或 `cpu_possible_mask`），避免条件判断开销。\n\n### 启动参数解析\n- **`nohz_full=cpu-list`**：自动启用 `HK_FLAG_TICK | WQ | TIMER | RCU | MISC | KTHREAD`，表示这些任务只能在非 `nohz_full` CPU 上运行。\n- **`isolcpus=flags,cpu-list`**：支持细粒度控制，如：\n  - `nohz` → 启用 `HK_FLAG_TICK`\n  - `domain` → 启用 `HK_FLAG_DOMAIN`（影响调度域构建）\n  - `managed_irq` → 启用 `HK_FLAG_MANAGED_IRQ`\n  - 无标志时默认启用 `HK_FLAG_DOMAIN`\n\n### 配置一致性检查\n若同时使用 `nohz_full=` 和 `isolcpus=`，要求两者指定的 housekeeping CPU 集合必须一致，否则报错。\n\n### 安全兜底机制\n若用户指定的 housekeeping CPU 集合中没有在线 CPU，则自动将引导 CPU（`smp_processor_id()`）加入，确保至少有一个 CPU 可处理内核任务。\n\n### NO_HZ_FULL 集成\n当启用 `HK_FLAG_TICK` 时：\n- 检查 `CONFIG_NO_HZ_FULL` 是否启用\n- 调用 `tick_nohz_full_setup()` 配置无周期 tick\n- 调用 `sched_tick_offload_init()` 初始化 tick 卸载\n\n## 4. 依赖关系\n\n- **调度器子系统 (`kernel/sched/`)**  \n  依赖 `sched_numa_find_closest()` 实现 NUMA 亲和调度；`housekeeping_affine()` 调用 `set_cpus_allowed_ptr()`。\n\n- **时间子系统 (`kernel/time/`)**  \n  与 `tick_nohz_full_setup()` 和 `sched_tick_offload_init()` 紧密集成，实现无周期 tick。\n\n- **CPU 热插拔与拓扑 (`kernel/cpu.c`, `arch/`)**  \n  使用 `cpu_possible_mask`、`cpu_online_mask`、`cpu_present_mask` 等全局 CPU 掩码。\n\n- **启动内存分配 (`mm/`)**  \n  使用 `alloc_bootmem_cpumask_var()` 在初始化阶段分配 CPU 掩码内存。\n\n- **RCU 子系统 (`kernel/rcu/`)**  \n  通过 `HK_FLAG_RCU` 控制 RCU 回调的执行 CPU。\n\n- **工作队列 (`kernel/workqueue.c`)**  \n  通过 `HK_FLAG_WQ` 限制未绑定工作队列的执行 CPU。\n\n## 5. 使用场景\n\n1. **实时系统**  \n   通过 `isolcpus=domain,managed_irq,1-7` 将 CPU 1-7 从调度域和中断中隔离，仅保留 CPU 0 处理内核任务，降低关键任务延迟。\n\n2. **高性能计算 (HPC)**  \n   使用 `nohz_full=1-15` 禁用 CPU 1-15 的周期性 tick，减少干扰，提升计算密集型应用性能。\n\n3. **低延迟应用**  \n   结合 `isolcpus=nohz,domain,1` 和用户空间任务绑定，确保 CPU 1 无内核后台活动，实现微秒级响应。\n\n4. **虚拟化环境**  \n   将部分 CPU 完全分配给虚拟机（通过隔离），避免宿主机内核任务抢占。\n\n5. **增强隔离模式**  \n   启用 `enhanced_isolcpus` 参数（需其他子系统支持），进一步限制隔离 CPU 上的内核活动（如禁止 softirq、禁止 page reclaim 等）。",
      "similarity": 0.5327863097190857,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/isolation.c",
          "start_line": 33,
          "end_line": 164,
          "content": [
            "bool housekeeping_enabled(enum hk_type type)",
            "{",
            "\treturn !!(housekeeping.flags & BIT(type));",
            "}",
            "int housekeeping_any_cpu(enum hk_type type)",
            "{",
            "\tint cpu;",
            "",
            "\tif (static_branch_unlikely(&housekeeping_overridden)) {",
            "\t\tif (housekeeping.flags & BIT(type)) {",
            "\t\t\tcpu = sched_numa_find_closest(housekeeping.cpumasks[type], smp_processor_id());",
            "\t\t\tif (cpu < nr_cpu_ids)",
            "\t\t\t\treturn cpu;",
            "",
            "\t\t\treturn cpumask_any_and(housekeeping.cpumasks[type], cpu_online_mask);",
            "\t\t}",
            "\t}",
            "\treturn smp_processor_id();",
            "}",
            "void housekeeping_affine(struct task_struct *t, enum hk_type type)",
            "{",
            "\tif (static_branch_unlikely(&housekeeping_overridden))",
            "\t\tif (housekeeping.flags & BIT(type))",
            "\t\t\tset_cpus_allowed_ptr(t, housekeeping.cpumasks[type]);",
            "}",
            "bool housekeeping_test_cpu(int cpu, enum hk_type type)",
            "{",
            "\tif (static_branch_unlikely(&housekeeping_overridden))",
            "\t\tif (housekeeping.flags & BIT(type))",
            "\t\t\treturn cpumask_test_cpu(cpu, housekeeping.cpumasks[type]);",
            "\treturn true;",
            "}",
            "void __init housekeeping_init(void)",
            "{",
            "\tenum hk_type type;",
            "",
            "\tif (!housekeeping.flags)",
            "\t\treturn;",
            "",
            "\tstatic_branch_enable(&housekeeping_overridden);",
            "",
            "\tif (housekeeping.flags & HK_FLAG_TICK)",
            "\t\tsched_tick_offload_init();",
            "",
            "\tfor_each_set_bit(type, &housekeeping.flags, HK_TYPE_MAX) {",
            "\t\t/* We need at least one CPU to handle housekeeping work */",
            "\t\tWARN_ON_ONCE(cpumask_empty(housekeeping.cpumasks[type]));",
            "\t}",
            "}",
            "static void __init housekeeping_setup_type(enum hk_type type,",
            "\t\t\t\t\t   cpumask_var_t housekeeping_staging)",
            "{",
            "",
            "\talloc_bootmem_cpumask_var(&housekeeping.cpumasks[type]);",
            "\tcpumask_copy(housekeeping.cpumasks[type],",
            "\t\t     housekeeping_staging);",
            "}",
            "static int __init housekeeping_setup(char *str, unsigned long flags)",
            "{",
            "\tcpumask_var_t non_housekeeping_mask, housekeeping_staging;",
            "\tunsigned int first_cpu;",
            "\tint err = 0;",
            "",
            "\tif ((flags & HK_FLAG_TICK) && !(housekeeping.flags & HK_FLAG_TICK)) {",
            "\t\tif (!IS_ENABLED(CONFIG_NO_HZ_FULL)) {",
            "\t\t\tpr_warn(\"Housekeeping: nohz unsupported.\"",
            "\t\t\t\t\" Build with CONFIG_NO_HZ_FULL\\n\");",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\talloc_bootmem_cpumask_var(&non_housekeeping_mask);",
            "\tif (cpulist_parse(str, non_housekeeping_mask) < 0) {",
            "\t\tpr_warn(\"Housekeeping: nohz_full= or isolcpus= incorrect CPU range\\n\");",
            "\t\tgoto free_non_housekeeping_mask;",
            "\t}",
            "",
            "\talloc_bootmem_cpumask_var(&housekeeping_staging);",
            "\tcpumask_andnot(housekeeping_staging,",
            "\t\t       cpu_possible_mask, non_housekeeping_mask);",
            "",
            "\tfirst_cpu = cpumask_first_and(cpu_present_mask, housekeeping_staging);",
            "\tif (first_cpu >= nr_cpu_ids || first_cpu >= setup_max_cpus) {",
            "\t\t__cpumask_set_cpu(smp_processor_id(), housekeeping_staging);",
            "\t\t__cpumask_clear_cpu(smp_processor_id(), non_housekeeping_mask);",
            "\t\tif (!housekeeping.flags) {",
            "\t\t\tpr_warn(\"Housekeeping: must include one present CPU, \"",
            "\t\t\t\t\"using boot CPU:%d\\n\", smp_processor_id());",
            "\t\t}",
            "\t}",
            "",
            "\tif (cpumask_empty(non_housekeeping_mask))",
            "\t\tgoto free_housekeeping_staging;",
            "",
            "\tif (!housekeeping.flags) {",
            "\t\t/* First setup call (\"nohz_full=\" or \"isolcpus=\") */",
            "\t\tenum hk_type type;",
            "",
            "\t\tfor_each_set_bit(type, &flags, HK_TYPE_MAX)",
            "\t\t\thousekeeping_setup_type(type, housekeeping_staging);",
            "\t} else {",
            "\t\t/* Second setup call (\"nohz_full=\" after \"isolcpus=\" or the reverse) */",
            "\t\tenum hk_type type;",
            "\t\tunsigned long iter_flags = flags & housekeeping.flags;",
            "",
            "\t\tfor_each_set_bit(type, &iter_flags, HK_TYPE_MAX) {",
            "\t\t\tif (!cpumask_equal(housekeeping_staging,",
            "\t\t\t\t\t   housekeeping.cpumasks[type])) {",
            "\t\t\t\tpr_warn(\"Housekeeping: nohz_full= must match isolcpus=\\n\");",
            "\t\t\t\tgoto free_housekeeping_staging;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\titer_flags = flags & ~housekeeping.flags;",
            "",
            "\t\tfor_each_set_bit(type, &iter_flags, HK_TYPE_MAX)",
            "\t\t\thousekeeping_setup_type(type, housekeeping_staging);",
            "\t}",
            "",
            "\tif ((flags & HK_FLAG_TICK) && !(housekeeping.flags & HK_FLAG_TICK))",
            "\t\ttick_nohz_full_setup(non_housekeeping_mask);",
            "",
            "\thousekeeping.flags |= flags;",
            "\terr = 1;",
            "",
            "free_housekeeping_staging:",
            "\tfree_bootmem_cpumask_var(housekeeping_staging);",
            "free_non_housekeeping_mask:",
            "\tfree_bootmem_cpumask_var(non_housekeeping_mask);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "housekeeping_enabled, housekeeping_any_cpu, housekeeping_affine, housekeeping_test_cpu, housekeeping_init, housekeeping_setup_type, housekeeping_setup",
          "description": "实现了housekeeping相关核心逻辑，包括判断类型是否启用、查找可用CPU、设置任务亲和性、验证CPU归属等，同时负责初始化和配置不同类型housekeeping任务的CPU掩码。",
          "similarity": 0.533223569393158
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/isolation.c",
          "start_line": 185,
          "end_line": 248,
          "content": [
            "static int __init housekeeping_nohz_full_setup(char *str)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tflags = HK_FLAG_TICK | HK_FLAG_WQ | HK_FLAG_TIMER | HK_FLAG_RCU |",
            "\t\tHK_FLAG_MISC | HK_FLAG_KTHREAD;",
            "",
            "\treturn housekeeping_setup(str, flags);",
            "}",
            "static int __init housekeeping_isolcpus_setup(char *str)",
            "{",
            "\tunsigned long flags = 0;",
            "\tbool illegal = false;",
            "\tchar *par;",
            "\tint len;",
            "",
            "\twhile (isalpha(*str)) {",
            "\t\tif (!strncmp(str, \"nohz,\", 5)) {",
            "\t\t\tstr += 5;",
            "\t\t\tflags |= HK_FLAG_TICK;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!strncmp(str, \"domain,\", 7)) {",
            "\t\t\tstr += 7;",
            "\t\t\tflags |= HK_FLAG_DOMAIN;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!strncmp(str, \"managed_irq,\", 12)) {",
            "\t\t\tstr += 12;",
            "\t\t\tflags |= HK_FLAG_MANAGED_IRQ;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Skip unknown sub-parameter and validate that it is not",
            "\t\t * containing an invalid character.",
            "\t\t */",
            "\t\tfor (par = str, len = 0; *str && *str != ','; str++, len++) {",
            "\t\t\tif (!isalpha(*str) && *str != '_')",
            "\t\t\t\tillegal = true;",
            "\t\t}",
            "",
            "\t\tif (illegal) {",
            "\t\t\tpr_warn(\"isolcpus: Invalid flag %.*s\\n\", len, par);",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\tpr_info(\"isolcpus: Skipped unknown flag %.*s\\n\", len, par);",
            "\t\tstr++;",
            "\t}",
            "",
            "\t/* Default behaviour for isolcpus without flags */",
            "\tif (!flags)",
            "\t\tflags |= HK_FLAG_DOMAIN;",
            "",
            "\treturn housekeeping_setup(str, flags);",
            "}",
            "static int __init enhanced_isolcpus_setup(char *str)",
            "{",
            "\tenhanced_isolcpus = true;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "housekeeping_nohz_full_setup, housekeeping_isolcpus_setup, enhanced_isolcpus_setup",
          "description": "提供命令行参数解析接口，通过housekeeping_nohz_full_setup和housekeeping_isolcpus_setup将参数转换为对应的标志位，调用housekeeping_setup完成CPU掩码配置，支持nohz_full和isolcpus特性。",
          "similarity": 0.5315879583358765
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/isolation.c",
          "start_line": 1,
          "end_line": 32,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  Housekeeping management. Manage the targets for routine code that can run on",
            " *  any CPU: unbound workqueues, timers, kthreads and any offloadable work.",
            " *",
            " * Copyright (C) 2017 Red Hat, Inc., Frederic Weisbecker",
            " * Copyright (C) 2017-2018 SUSE, Frederic Weisbecker",
            " *",
            " */",
            "",
            "enum hk_flags {",
            "\tHK_FLAG_TIMER\t\t= BIT(HK_TYPE_TIMER),",
            "\tHK_FLAG_RCU\t\t= BIT(HK_TYPE_RCU),",
            "\tHK_FLAG_MISC\t\t= BIT(HK_TYPE_MISC),",
            "\tHK_FLAG_SCHED\t\t= BIT(HK_TYPE_SCHED),",
            "\tHK_FLAG_TICK\t\t= BIT(HK_TYPE_TICK),",
            "\tHK_FLAG_DOMAIN\t\t= BIT(HK_TYPE_DOMAIN),",
            "\tHK_FLAG_WQ\t\t= BIT(HK_TYPE_WQ),",
            "\tHK_FLAG_MANAGED_IRQ\t= BIT(HK_TYPE_MANAGED_IRQ),",
            "\tHK_FLAG_KTHREAD\t\t= BIT(HK_TYPE_KTHREAD),",
            "};",
            "",
            "DEFINE_STATIC_KEY_FALSE(housekeeping_overridden);",
            "EXPORT_SYMBOL_GPL(housekeeping_overridden);",
            "",
            "struct housekeeping {",
            "\tcpumask_var_t cpumasks[HK_TYPE_MAX];",
            "\tunsigned long flags;",
            "};",
            "",
            "static struct housekeeping housekeeping;",
            ""
          ],
          "function_name": null,
          "description": "定义了用于管理不同类型housekeeping任务的标志位枚举和housekeeping结构体，其中包含各类型任务的CPU掩码数组及全局标志位，用于后续CPU亲和性控制。",
          "similarity": 0.49712666869163513
        }
      ]
    },
    {
      "source_file": "mm/early_ioremap.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:58:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `early_ioremap.c`\n\n---\n\n# early_ioremap.c 技术文档\n\n## 1. 文件概述\n\n`early_ioremap.c` 提供了在内核启动早期阶段（在标准 `ioremap()` 机制尚未可用时）进行临时 I/O 或内存映射的通用支持。该文件主要用于无 MMU 架构或需要在分页初始化完成前访问物理地址空间的体系结构。其实现基于固定映射（fixmap）机制，通过预分配的虚拟地址窗口动态映射物理内存区域。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `early_ioremap_setup(void)`  \n  初始化早期 ioremap 所需的虚拟地址槽位。\n\n- `__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)`  \n  内部实现函数，执行实际的早期映射操作。\n\n- `early_ioremap(resource_size_t phys_addr, unsigned long size)`  \n  映射 I/O 设备内存，使用 `FIXMAP_PAGE_IO` 页属性。\n\n- `early_memremap(resource_size_t phys_addr, unsigned long size)`  \n  映射普通内存，使用 `FIXMAP_PAGE_NORMAL` 页属性，并可由架构调整保护属性。\n\n- `early_memremap_ro(resource_size_t phys_addr, unsigned long size)`  \n  （条件编译）只读方式映射内存，使用 `FIXMAP_PAGE_RO` 属性。\n\n- `early_memremap_prot(resource_size_t phys_addr, unsigned long size, unsigned long prot_val)`  \n  （条件编译）使用自定义页表属性映射内存。\n\n- `early_iounmap(void __iomem *addr, unsigned long size)`  \n  解除早期 I/O 映射。\n\n- `early_memunmap(void *addr, unsigned long size)`  \n  解除早期内存映射，是对 `early_iounmap` 的封装。\n\n- `copy_from_early_mem(void *dest, phys_addr_t src, unsigned long size)`  \n  安全地从早期物理内存复制数据，自动处理跨映射块边界的情况。\n\n- `early_ioremap_reset(void)`  \n  标记分页初始化已完成，后续映射将使用晚期 fixmap 接口。\n\n- `check_early_ioremap_leak(void)`  \n  启动后期检查是否存在未释放的早期映射（用于调试）。\n\n### 主要数据结构与变量\n\n- `prev_map[FIX_BTMAPS_SLOTS]`：记录每个槽位当前映射的虚拟地址。\n- `prev_size[FIX_BTMAPS_SLOTS]`：记录每个槽位映射的大小。\n- `slot_virt[FIX_BTMAPS_SLOTS]`：每个槽位对应的固定虚拟地址基址。\n- `after_paging_init`：标志位，指示是否已完成分页初始化。\n- `early_ioremap_debug`：调试开关，启用详细日志输出。\n\n## 3. 关键实现\n\n### 固定映射槽位管理\n- 使用 `FIX_BTMAPS_SLOTS` 个独立的 fixmap 槽位（每个槽包含 `NR_FIX_BTMAPS` 个页面），支持并发的早期映射。\n- 每个槽位的虚拟地址通过 `__fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i)` 预计算。\n- 映射时线性搜索首个空闲槽位；解映射时通过虚拟地址反查槽位。\n\n### 分页初始化前后区分\n- 在 `paging_init()` 调用前，使用 `__early_set_fixmap()` 建立映射。\n- 调用 `early_ioremap_reset()` 后（即 `after_paging_init = 1`），改用 `__late_set_fixmap()` 和 `__late_clear_fixmap()`。\n- 若架构未定义晚期接口，则调用 `BUG()`，确保正确性。\n\n### 页对齐与大小限制\n- 输入物理地址和大小会被自动对齐到页边界。\n- 单次映射最大为 `NR_FIX_BTMAPS << PAGE_SHIFT`（即 `MAX_MAP_CHUNK`）。\n- 超出单槽容量的请求会被拒绝（`WARN_ON(nrpages > NR_FIX_BTMAPS)`）。\n\n### 内存属性定制\n- `early_memremap_pgprot_adjust()` 是弱符号函数，允许架构层根据物理地址调整页属性（如设置缓存策略）。\n- 支持只读 (`FIXMAP_PAGE_RO`) 和自定义属性 (`early_memremap_prot`) 的映射。\n\n### 泄漏检测\n- 通过 `late_initcall(check_early_ioremap_leak)` 在启动后期检查是否有未释放的映射。\n- 若存在泄漏且启用了 `early_ioremap_debug`，会提示用户上报 dmesg 日志。\n\n### 无 MMU 支持\n- 在 `!CONFIG_MMU` 配置下，所有 `early_*remap` 函数直接返回物理地址（无映射开销），`unmap` 操作为空。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<asm/fixmap.h>`：提供固定映射相关定义（如 `FIX_BTMAP_BEGIN`、`__fix_to_virt`）。\n  - `<asm/early_ioremap.h>`：必须由架构提供 `__early_set_fixmap` 等底层接口。\n  - `\"internal.h\"`：可能包含内核内部辅助宏或函数。\n\n- **架构依赖**：\n  - 必须实现 `__early_set_fixmap()` 和 `FIXMAP_PAGE_CLEAR`。\n  - 可选实现 `__late_set_fixmap()` / `__late_clear_fixmap()` 以支持分页初始化后的映射。\n  - 可重载 `early_memremap_pgprot_adjust()` 调整内存属性。\n\n- **内核子系统**：\n  - 依赖 `mm` 子系统的页表管理机制。\n  - 使用 `init` 段属性（`__init`）确保代码/数据在初始化后释放。\n  - 通过 `early_param()` 注册启动参数 `early_ioremap_debug`。\n\n## 5. 使用场景\n\n- **内核启动早期**：在 `paging_init()` 之前访问设备寄存器或 ACPI/SMBIOS 等固件表。\n- **ACPI/UEFI 初始化**：解析和访问位于高物理地址的固件数据结构。\n- **内存探测**：在建立完整内存映射前读取内存控制器寄存器。\n- **安全启动验证**：在初始化完整 I/O 子系统前验证硬件状态。\n- **架构移植**：为新架构提供标准化的早期映射接口，避免重复实现。\n\n> 注意：所有早期映射必须在内核进入 `SYSTEM_RUNNING` 状态前解除，否则会触发警告。生产系统应避免长期持有早期映射。",
      "similarity": 0.5327392816543579,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/early_ioremap.c",
          "start_line": 25,
          "end_line": 138,
          "content": [
            "static int __init early_ioremap_debug_setup(char *str)",
            "{",
            "\tearly_ioremap_debug = 1;",
            "",
            "\treturn 0;",
            "}",
            "pgprot_t __init __weak early_memremap_pgprot_adjust(resource_size_t phys_addr,",
            "\t\t\t\t\t\t    unsigned long size,",
            "\t\t\t\t\t\t    pgprot_t prot)",
            "{",
            "\treturn prot;",
            "}",
            "void __init early_ioremap_reset(void)",
            "{",
            "\tafter_paging_init = 1;",
            "}",
            "static inline void __init __late_set_fixmap(enum fixed_addresses idx,",
            "\t\t\t\t\t    phys_addr_t phys, pgprot_t prot)",
            "{",
            "\tBUG();",
            "}",
            "static inline void __init __late_clear_fixmap(enum fixed_addresses idx)",
            "{",
            "\tBUG();",
            "}",
            "void __init early_ioremap_setup(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {",
            "\t\tWARN_ON_ONCE(prev_map[i]);",
            "\t\tslot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);",
            "\t}",
            "}",
            "static int __init check_early_ioremap_leak(void)",
            "{",
            "\tint count = 0;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++)",
            "\t\tif (prev_map[i])",
            "\t\t\tcount++;",
            "",
            "\tif (WARN(count, KERN_WARNING",
            "\t\t \"Debug warning: early ioremap leak of %d areas detected.\\n\"",
            "\t\t \"please boot with early_ioremap_debug and report the dmesg.\\n\",",
            "\t\t count))",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "void __init early_iounmap(void __iomem *addr, unsigned long size)",
            "{",
            "\tunsigned long virt_addr;",
            "\tunsigned long offset;",
            "\tunsigned int nrpages;",
            "\tenum fixed_addresses idx;",
            "\tint i, slot;",
            "",
            "\tslot = -1;",
            "\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {",
            "\t\tif (prev_map[i] == addr) {",
            "\t\t\tslot = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (WARN(slot < 0, \"%s(%p, %08lx) not found slot\\n\",",
            "\t\t  __func__, addr, size))",
            "\t\treturn;",
            "",
            "\tif (WARN(prev_size[slot] != size,",
            "\t\t \"%s(%p, %08lx) [%d] size not consistent %08lx\\n\",",
            "\t\t  __func__, addr, size, slot, prev_size[slot]))",
            "\t\treturn;",
            "",
            "\tWARN(early_ioremap_debug, \"%s(%p, %08lx) [%d]\\n\",",
            "\t      __func__, addr, size, slot);",
            "",
            "\tvirt_addr = (unsigned long)addr;",
            "\tif (WARN_ON(virt_addr < fix_to_virt(FIX_BTMAP_BEGIN)))",
            "\t\treturn;",
            "",
            "\toffset = offset_in_page(virt_addr);",
            "\tnrpages = PAGE_ALIGN(offset + size) >> PAGE_SHIFT;",
            "",
            "\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;",
            "\twhile (nrpages > 0) {",
            "\t\tif (after_paging_init)",
            "\t\t\t__late_clear_fixmap(idx);",
            "\t\telse",
            "\t\t\t__early_set_fixmap(idx, 0, FIXMAP_PAGE_CLEAR);",
            "\t\t--idx;",
            "\t\t--nrpages;",
            "\t}",
            "\tprev_map[slot] = NULL;",
            "}",
            "void __init copy_from_early_mem(void *dest, phys_addr_t src, unsigned long size)",
            "{",
            "\tunsigned long slop, clen;",
            "\tchar *p;",
            "",
            "\twhile (size) {",
            "\t\tslop = offset_in_page(src);",
            "\t\tclen = size;",
            "\t\tif (clen > MAX_MAP_CHUNK - slop)",
            "\t\t\tclen = MAX_MAP_CHUNK - slop;",
            "\t\tp = early_memremap(src & PAGE_MASK, clen + slop);",
            "\t\tmemcpy(dest, p + slop, clen);",
            "\t\tearly_memunmap(p, clen + slop);",
            "\t\tdest += clen;",
            "\t\tsrc += clen;",
            "\t\tsize -= clen;",
            "\t}",
            "}"
          ],
          "function_name": "early_ioremap_debug_setup, early_memremap_pgprot_adjust, early_ioremap_reset, __late_set_fixmap, __late_clear_fixmap, early_ioremap_setup, check_early_ioremap_leak, early_iounmap, copy_from_early_mem",
          "description": "实现早期内存映射的调试控制、固定映射管理、内存泄漏检测及释放逻辑，包含ioremap区域解除映射、数据拷贝等关键操作函数",
          "similarity": 0.5479485392570496
        },
        {
          "chunk_id": 0,
          "file_path": "mm/early_ioremap.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Provide common bits of early_ioremap() support for architectures needing",
            " * temporary mappings during boot before ioremap() is available.",
            " *",
            " * This is mostly a direct copy of the x86 early_ioremap implementation.",
            " *",
            " * (C) Copyright 1995 1996, 2014 Linus Torvalds",
            " *",
            " */",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <asm/fixmap.h>",
            "#include <asm/early_ioremap.h>",
            "#include \"internal.h\"",
            "",
            "#ifdef CONFIG_MMU",
            "static int early_ioremap_debug __initdata;",
            ""
          ],
          "function_name": null,
          "description": "提供架构通用的早期ioremap支持框架，定义DEBUG调试标志及基础头文件，为需要启动阶段临时映射的架构准备MMU相关基础设施",
          "similarity": 0.5373461246490479
        },
        {
          "chunk_id": 2,
          "file_path": "mm/early_ioremap.c",
          "start_line": 287,
          "end_line": 293,
          "content": [
            "void __init early_iounmap(void __iomem *addr, unsigned long size)",
            "{",
            "}",
            "void __init early_memunmap(void *addr, unsigned long size)",
            "{",
            "\tearly_iounmap((__force void __iomem *)addr, size);",
            "}"
          ],
          "function_name": "early_iounmap, early_memunmap",
          "description": "定义early_iounmap空函数与early_memunmap封装函数，用于统一释放由early_ioremap分配的资源，但当前上下文不完整",
          "similarity": 0.4564170837402344
        }
      ]
    }
  ]
}