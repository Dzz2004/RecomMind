{
  "query": "操作系统模块化设计的核心原理与实现",
  "timestamp": "2025-12-26 02:00:10",
  "retrieved_files": [
    {
      "source_file": "kernel/module/main.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:04:44\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\main.c`\n\n---\n\n# `module/main.c` 技术文档\n\n## 1. 文件概述\n\n`module/main.c` 是 Linux 内核模块子系统的核心实现文件，负责模块的加载、卸载、符号解析、内存管理、状态跟踪以及模块间依赖关系的维护。该文件实现了内核模块机制的基础框架，包括模块列表管理、模块内存布局控制、符号查找、模块通知机制、模块引用计数等关键功能，是内核动态加载模块能力的核心支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mod_tree_root mod_tree`**：用于加速地址到模块映射的全局模块地址范围树，包含 `addr_min`/`addr_max`（及可选的 `data_addr_min`/`data_addr_max`）。\n- **`LIST_HEAD(modules)`**：全局模块链表，存储所有已加载模块。\n- **`DEFINE_MUTEX(module_mutex)`**：保护模块列表、模块使用关系及地址边界的关键互斥锁。\n- **`struct symsearch`**：用于描述符号搜索范围，包含符号起止位置、CRC 校验数组及许可证类型。\n- **`struct find_symbol_arg`**：符号查找的参数结构体，用于传递查找目标及接收结果（所有者、符号指针、CRC、许可证等）。\n\n### 主要函数与接口\n\n- **模块注册/注销通知**：\n  - `register_module_notifier()` / `unregister_module_notifier()`：注册/注销模块生命周期事件通知回调。\n- **模块引用管理**：\n  - `strong_try_module_get()`：强引用获取，拒绝处于 `COMING` 状态的模块。\n  - `__module_put_and_kthread_exit()`：专用于内核线程在退出前释放模块引用。\n- **模块内存边界管理**：\n  - `__mod_update_bounds()` / `mod_update_bounds()`：更新全局模块地址范围，用于加速 `__module_address()`。\n- **ELF 节区辅助函数**：\n  - `find_sec()` / `find_any_sec()`：根据名称查找 ELF 节区索引。\n  - `section_addr()` / `section_objs()`：获取节区地址及对象数量。\n- **符号查找**：\n  - `find_symbol()`：在内核及已加载模块中查找导出符号。\n  - `find_exported_symbol_in_section()`：在指定符号段中二分查找符号。\n- **模块状态与安全**：\n  - `add_taint_module()`：为模块添加污点标记（taint flag）。\n- **全局控制**：\n  - `modules_disabled`：通过 `nomodule` 内核参数控制是否禁用模块加载。\n\n### 全局变量与工作队列\n\n- **`init_free_wq`**：用于异步释放模块初始化段（`.init`）内存的工作队列。\n- **`init_free_list`**：待释放初始化内存的无锁链表。\n- **`module_wq`**：等待模块初始化完成的等待队列。\n\n## 3. 关键实现\n\n### 模块地址范围加速\n\n通过 `mod_tree` 全局结构维护所有模块（或核心数据）的最小/最大虚拟地址。`__module_address()` 可先检查目标地址是否落在 `[addr_min, addr_max]` 范围内，若不在则直接返回 `NULL`，避免遍历整个模块链表，显著提升性能。\n\n### 符号查找机制\n\n- 使用 `bsearch()` 在已排序的导出符号表中进行二分查找，时间复杂度为 O(log n)。\n- 支持符号命名空间（namespace）和 GPL 许可证检查：非 GPL 模块无法使用 `GPL_ONLY` 符号。\n- 通过 `symsearch` 数组统一管理内核及各模块的符号段，实现统一查找接口。\n\n### 模块内存管理\n\n- 模块内存按 `mod_mem_type`（如代码、只读数据、可写数据、初始化段等）分类管理。\n- 初始化段（`.init`）在模块初始化成功后通过工作队列异步释放，节省内存。\n- 支持 `CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC` 架构选项，将模块数据段单独纳入地址范围管理。\n\n### 模块状态与引用安全\n\n- `strong_try_module_get()` 确保不会对处于 `MODULE_STATE_COMING`（正在初始化）或 `MODULE_STATE_UNFORMED`（未形成）状态的模块增加引用，防止竞态。\n- `__module_put_and_kthread_exit()` 为内核线程提供安全退出路径，在释放模块引用后终止线程。\n\n### 模块通知机制\n\n基于 `blocking_notifier_chain` 实现模块生命周期事件（如加载、卸载、初始化完成等）的通知，允许其他子系统（如 livepatch、ftrace）监听并响应模块状态变化。\n\n### 构建标识与版本校验\n\n- 通过 `INCLUDE_VERMAGIC` 宏包含模块魔数（vermagic）信息，用于加载时内核版本兼容性检查。\n- 支持 `CONFIG_MODVERSIONS`，在符号查找时返回 CRC 校验值，确保符号 ABI 兼容性。\n\n## 4. 依赖关系\n\n- **架构相关**：\n  - 依赖 `asm/cacheflush.h`、`asm/mmu_context.h`、`asm/sections.h` 等架构头文件，处理指令缓存刷新、内存映射等。\n  - 使用 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 优化符号字符串存储。\n- **内核子系统**：\n  - **内存管理**：`vmalloc`、`slab` 用于模块内存分配。\n  - **安全机制**：`capability`、`audit`、`module_signature` 用于模块加载权限和签名验证。\n  - **调试与追踪**：`kallsyms`、`trace_events`、`ftrace`、`dynamic_debug`、`debugfs` 提供模块调试支持。\n  - **并发控制**：`RCU`、`mutex`、`percpu` 用于同步。\n  - **文件系统**：`fs.h`、`kernel_read_file.h` 用于从文件加载模块。\n- **内部依赖**：\n  - 依赖同目录下的 `internal.h`，包含模块子系统内部数据结构和函数声明。\n  - 使用 `uapi/linux/module.h` 定义用户空间接口常量。\n\n## 5. 使用场景\n\n- **动态加载内核模块**：通过 `init_module()` 或 `finit_module()` 系统调用加载 `.ko` 文件时，该文件中的函数负责解析 ELF、重定位、符号解析、执行初始化函数。\n- **模块卸载**：通过 `delete_module()` 系统调用卸载模块时，管理模块引用计数、执行清理函数、释放内存。\n- **内核符号解析**：当模块或内核其他部分调用 `symbol_get()` 或通过 `EXPORT_SYMBOL` 机制访问符号时，`find_symbol()` 被调用。\n- **运行时模块查询**：`/proc/modules`、`/sys/module/` 等接口依赖此文件维护的模块列表和状态信息。\n- **内核热补丁（Livepatch）**：依赖模块通知机制和符号查找功能实现函数替换。\n- **内核调试与性能分析**：ftrace、kprobes 等工具依赖模块地址范围和符号信息进行函数跟踪。",
      "similarity": 0.6252038478851318,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/module/main.c",
          "start_line": 303,
          "end_line": 412,
          "content": [
            "bool find_symbol(struct find_symbol_arg *fsa)",
            "{",
            "\tstatic const struct symsearch arr[] = {",
            "\t\t{ __start___ksymtab, __stop___ksymtab, __start___kcrctab,",
            "\t\t  NOT_GPL_ONLY },",
            "\t\t{ __start___ksymtab_gpl, __stop___ksymtab_gpl,",
            "\t\t  __start___kcrctab_gpl,",
            "\t\t  GPL_ONLY },",
            "\t};",
            "\tstruct module *mod;",
            "\tunsigned int i;",
            "",
            "\tmodule_assert_mutex_or_preempt();",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(arr); i++)",
            "\t\tif (find_exported_symbol_in_section(&arr[i], NULL, fsa))",
            "\t\t\treturn true;",
            "",
            "\tlist_for_each_entry_rcu(mod, &modules, list,",
            "\t\t\t\tlockdep_is_held(&module_mutex)) {",
            "\t\tstruct symsearch arr[] = {",
            "\t\t\t{ mod->syms, mod->syms + mod->num_syms, mod->crcs,",
            "\t\t\t  NOT_GPL_ONLY },",
            "\t\t\t{ mod->gpl_syms, mod->gpl_syms + mod->num_gpl_syms,",
            "\t\t\t  mod->gpl_crcs,",
            "\t\t\t  GPL_ONLY },",
            "\t\t};",
            "",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (i = 0; i < ARRAY_SIZE(arr); i++)",
            "\t\t\tif (find_exported_symbol_in_section(&arr[i], mod, fsa))",
            "\t\t\t\treturn true;",
            "\t}",
            "",
            "\tpr_debug(\"Failed to find symbol %s\\n\", fsa->name);",
            "\treturn false;",
            "}",
            "static int percpu_modalloc(struct module *mod, struct load_info *info)",
            "{",
            "\tElf_Shdr *pcpusec = &info->sechdrs[info->index.pcpu];",
            "\tunsigned long align = pcpusec->sh_addralign;",
            "",
            "\tif (!pcpusec->sh_size)",
            "\t\treturn 0;",
            "",
            "\tif (align > PAGE_SIZE) {",
            "\t\tpr_warn(\"%s: per-cpu alignment %li > %li\\n\",",
            "\t\t\tmod->name, align, PAGE_SIZE);",
            "\t\talign = PAGE_SIZE;",
            "\t}",
            "",
            "\tmod->percpu = __alloc_reserved_percpu(pcpusec->sh_size, align);",
            "\tif (!mod->percpu) {",
            "\t\tpr_warn(\"%s: Could not allocate %lu bytes percpu data\\n\",",
            "\t\t\tmod->name, (unsigned long)pcpusec->sh_size);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tmod->percpu_size = pcpusec->sh_size;",
            "\treturn 0;",
            "}",
            "static void percpu_modfree(struct module *mod)",
            "{",
            "\tfree_percpu(mod->percpu);",
            "}",
            "static unsigned int find_pcpusec(struct load_info *info)",
            "{",
            "\treturn find_sec(info, \".data..percpu\");",
            "}",
            "static void percpu_modcopy(struct module *mod,",
            "\t\t\t   const void *from, unsigned long size)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tmemcpy(per_cpu_ptr(mod->percpu, cpu), from, size);",
            "}",
            "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)",
            "{",
            "\tstruct module *mod;",
            "\tunsigned int cpu;",
            "",
            "\tpreempt_disable();",
            "",
            "\tlist_for_each_entry_rcu(mod, &modules, list) {",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "\t\tif (!mod->percpu_size)",
            "\t\t\tcontinue;",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tvoid *start = per_cpu_ptr(mod->percpu, cpu);",
            "\t\t\tvoid *va = (void *)addr;",
            "",
            "\t\t\tif (va >= start && va < start + mod->percpu_size) {",
            "\t\t\t\tif (can_addr) {",
            "\t\t\t\t\t*can_addr = (unsigned long) (va - start);",
            "\t\t\t\t\t*can_addr += (unsigned long)",
            "\t\t\t\t\t\tper_cpu_ptr(mod->percpu,",
            "\t\t\t\t\t\t\t    get_boot_cpu_id());",
            "\t\t\t\t}",
            "\t\t\t\tpreempt_enable();",
            "\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tpreempt_enable();",
            "\treturn false;",
            "}"
          ],
          "function_name": "find_symbol, percpu_modalloc, percpu_modfree, find_pcpusec, percpu_modcopy, __is_module_percpu_address",
          "description": "提供符号查找核心实现，通过遍历内核符号表和模块符号表定位目标符号；实现Per-CPU数据区的动态分配、复制和释放机制，确保多CPU环境下模块数据的正确访问。",
          "similarity": 0.5769757032394409
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/module/main.c",
          "start_line": 460,
          "end_line": 567,
          "content": [
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn __is_module_percpu_address(addr, NULL);",
            "}",
            "static int percpu_modalloc(struct module *mod, struct load_info *info)",
            "{",
            "\t/* UP modules shouldn't have this section: ENOMEM isn't quite right */",
            "\tif (info->sechdrs[info->index.pcpu].sh_size != 0)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static inline void percpu_modfree(struct module *mod)",
            "{",
            "}",
            "static unsigned int find_pcpusec(struct load_info *info)",
            "{",
            "\treturn 0;",
            "}",
            "static inline void percpu_modcopy(struct module *mod,",
            "\t\t\t\t  const void *from, unsigned long size)",
            "{",
            "\t/* pcpusec should be 0, and size of that section should be 0. */",
            "\tBUG_ON(size != 0);",
            "}",
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn false;",
            "}",
            "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)",
            "{",
            "\treturn false;",
            "}",
            "static int module_unload_init(struct module *mod)",
            "{",
            "\t/*",
            "\t * Initialize reference counter to MODULE_REF_BASE.",
            "\t * refcnt == 0 means module is going.",
            "\t */",
            "\tatomic_set(&mod->refcnt, MODULE_REF_BASE);",
            "",
            "\tINIT_LIST_HEAD(&mod->source_list);",
            "\tINIT_LIST_HEAD(&mod->target_list);",
            "",
            "\t/* Hold reference count during initialization. */",
            "\tatomic_inc(&mod->refcnt);",
            "",
            "\treturn 0;",
            "}",
            "static int already_uses(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tlist_for_each_entry(use, &b->source_list, source_list) {",
            "\t\tif (use->source == a)",
            "\t\t\treturn 1;",
            "\t}",
            "\tpr_debug(\"%s does not use %s!\\n\", a->name, b->name);",
            "\treturn 0;",
            "}",
            "static int add_module_usage(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tpr_debug(\"Allocating new usage for %s.\\n\", a->name);",
            "\tuse = kmalloc(sizeof(*use), GFP_ATOMIC);",
            "\tif (!use)",
            "\t\treturn -ENOMEM;",
            "",
            "\tuse->source = a;",
            "\tuse->target = b;",
            "\tlist_add(&use->source_list, &b->source_list);",
            "\tlist_add(&use->target_list, &a->target_list);",
            "\treturn 0;",
            "}",
            "static int ref_module(struct module *a, struct module *b)",
            "{",
            "\tint err;",
            "",
            "\tif (b == NULL || already_uses(a, b))",
            "\t\treturn 0;",
            "",
            "\t/* If module isn't available, we fail. */",
            "\terr = strong_try_module_get(b);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = add_module_usage(a, b);",
            "\tif (err) {",
            "\t\tmodule_put(b);",
            "\t\treturn err;",
            "\t}",
            "\treturn 0;",
            "}",
            "static void module_unload_free(struct module *mod)",
            "{",
            "\tstruct module_use *use, *tmp;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\tlist_for_each_entry_safe(use, tmp, &mod->target_list, target_list) {",
            "\t\tstruct module *i = use->target;",
            "\t\tpr_debug(\"%s unusing %s\\n\", mod->name, i->name);",
            "\t\tmodule_put(i);",
            "\t\tlist_del(&use->source_list);",
            "\t\tlist_del(&use->target_list);",
            "\t\tkfree(use);",
            "\t}",
            "\tmutex_unlock(&module_mutex);",
            "}"
          ],
          "function_name": "is_module_percpu_address, percpu_modalloc, percpu_modfree, find_pcpusec, percpu_modcopy, is_module_percpu_address, __is_module_percpu_address, module_unload_init, already_uses, add_module_usage, ref_module, module_unload_free",
          "description": "包含模块卸载初始化逻辑，管理模块间依赖关系（通过module_use结构），实现模块引用计数调整及依赖链清理，在模块卸载时安全解除其他模块对其的依赖。",
          "similarity": 0.575578510761261
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/main.c",
          "start_line": 96,
          "end_line": 202,
          "content": [
            "static void __mod_update_bounds(enum mod_mem_type type __maybe_unused, void *base,",
            "\t\t\t\tunsigned int size, struct mod_tree_root *tree)",
            "{",
            "\tunsigned long min = (unsigned long)base;",
            "\tunsigned long max = min + size;",
            "",
            "#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC",
            "\tif (mod_mem_type_is_core_data(type)) {",
            "\t\tif (min < tree->data_addr_min)",
            "\t\t\ttree->data_addr_min = min;",
            "\t\tif (max > tree->data_addr_max)",
            "\t\t\ttree->data_addr_max = max;",
            "\t\treturn;",
            "\t}",
            "#endif",
            "\tif (min < tree->addr_min)",
            "\t\ttree->addr_min = min;",
            "\tif (max > tree->addr_max)",
            "\t\ttree->addr_max = max;",
            "}",
            "static void mod_update_bounds(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size)",
            "\t\t\t__mod_update_bounds(type, mod_mem->base, mod_mem->size, &mod_tree);",
            "\t}",
            "}",
            "int register_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&module_notify_list, nb);",
            "}",
            "int unregister_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);",
            "}",
            "static inline int strong_try_module_get(struct module *mod)",
            "{",
            "\tBUG_ON(mod && mod->state == MODULE_STATE_UNFORMED);",
            "\tif (mod && mod->state == MODULE_STATE_COMING)",
            "\t\treturn -EBUSY;",
            "\tif (try_module_get(mod))",
            "\t\treturn 0;",
            "\telse",
            "\t\treturn -ENOENT;",
            "}",
            "static inline void add_taint_module(struct module *mod, unsigned flag,",
            "\t\t\t\t    enum lockdep_ok lockdep_ok)",
            "{",
            "\tadd_taint(flag, lockdep_ok);",
            "\tset_bit(flag, &mod->taints);",
            "}",
            "void __noreturn __module_put_and_kthread_exit(struct module *mod, long code)",
            "{",
            "\tmodule_put(mod);",
            "\tkthread_exit(code);",
            "}",
            "static unsigned int find_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\t/* Alloc bit cleared means \"ignore it.\" */",
            "\t\tif ((shdr->sh_flags & SHF_ALLOC)",
            "\t\t    && strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "static unsigned int find_any_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tif (strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "int cmp_name(const void *name, const void *sym)",
            "{",
            "\treturn strcmp(name, kernel_symbol_name(sym));",
            "}",
            "static bool find_exported_symbol_in_section(const struct symsearch *syms,",
            "\t\t\t\t\t    struct module *owner,",
            "\t\t\t\t\t    struct find_symbol_arg *fsa)",
            "{",
            "\tstruct kernel_symbol *sym;",
            "",
            "\tif (!fsa->gplok && syms->license == GPL_ONLY)",
            "\t\treturn false;",
            "",
            "\tsym = bsearch(fsa->name, syms->start, syms->stop - syms->start,",
            "\t\t\tsizeof(struct kernel_symbol), cmp_name);",
            "\tif (!sym)",
            "\t\treturn false;",
            "",
            "\tfsa->owner = owner;",
            "\tfsa->crc = symversion(syms->crcs, sym - syms->start);",
            "\tfsa->sym = sym;",
            "\tfsa->license = syms->license;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "__mod_update_bounds, mod_update_bounds, register_module_notifier, unregister_module_notifier, strong_try_module_get, add_taint_module, __module_put_and_kthread_exit, find_sec, find_any_sec, cmp_name, find_exported_symbol_in_section",
          "description": "实现模块内存边界更新逻辑、模块状态变更通知注册与注销接口，以及强引用获取检查函数，用于维护模块内存范围并控制模块生命周期事件。",
          "similarity": 0.5587421655654907
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/module/main.c",
          "start_line": 1925,
          "end_line": 2029,
          "content": [
            "static int copy_chunked_from_user(void *dst, const void __user *usrc, unsigned long len)",
            "{",
            "\tdo {",
            "\t\tunsigned long n = min(len, COPY_CHUNK_SIZE);",
            "",
            "\t\tif (copy_from_user(dst, usrc, n) != 0)",
            "\t\t\treturn -EFAULT;",
            "\t\tcond_resched();",
            "\t\tdst += n;",
            "\t\tusrc += n;",
            "\t\tlen -= n;",
            "\t} while (len);",
            "\treturn 0;",
            "}",
            "static int check_modinfo_livepatch(struct module *mod, struct load_info *info)",
            "{",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (!get_modinfo(info, \"livepatch\")) {",
            "\t\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_NONE);",
            "\t\treturn 0;",
            "\t}",
            "\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_UNDO);",
            "#else /* !CONFIG_LIVEPATCH_WO_FTRACE */",
            "\tif (!get_modinfo(info, \"livepatch\"))",
            "\t\t/* Nothing more to do */",
            "\t\treturn 0;",
            "#endif /* CONFIG_LIVEPATCH_WO_FTRACE */",
            "",
            "\tif (set_livepatch_module(mod))",
            "\t\treturn 0;",
            "",
            "\tpr_err(\"%s: module is marked as livepatch module, but livepatch support is disabled\",",
            "\t       mod->name);",
            "\treturn -ENOEXEC;",
            "}",
            "static void check_modinfo_retpoline(struct module *mod, struct load_info *info)",
            "{",
            "\tif (retpoline_module_ok(get_modinfo(info, \"retpoline\")))",
            "\t\treturn;",
            "",
            "\tpr_warn(\"%s: loading module not compiled with retpoline compiler.\\n\",",
            "\t\tmod->name);",
            "}",
            "static int copy_module_from_user(const void __user *umod, unsigned long len,",
            "\t\t\t\t  struct load_info *info)",
            "{",
            "\tint err;",
            "",
            "\tinfo->len = len;",
            "\tif (info->len < sizeof(*(info->hdr)))",
            "\t\treturn -ENOEXEC;",
            "",
            "\terr = security_kernel_load_data(LOADING_MODULE, true);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Suck in entire file: we'll want most of it. */",
            "\tinfo->hdr = __vmalloc(info->len, GFP_KERNEL | __GFP_NOWARN);",
            "\tif (!info->hdr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (copy_chunked_from_user(info->hdr, umod, info->len) != 0) {",
            "\t\terr = -EFAULT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terr = security_kernel_post_load_data((char *)info->hdr, info->len,",
            "\t\t\t\t\t     LOADING_MODULE, \"init_module\");",
            "out:",
            "\tif (err)",
            "\t\tvfree(info->hdr);",
            "",
            "\treturn err;",
            "}",
            "static void free_copy(struct load_info *info, int flags)",
            "{",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tmodule_decompress_cleanup(info);",
            "\telse",
            "\t\tvfree(info->hdr);",
            "}",
            "static int rewrite_section_headers(struct load_info *info, int flags)",
            "{",
            "\tunsigned int i;",
            "",
            "\t/* This should always be true, but let's be sure. */",
            "\tinfo->sechdrs[0].sh_addr = 0;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "",
            "\t\t/*",
            "\t\t * Mark all sections sh_addr with their address in the",
            "\t\t * temporary image.",
            "\t\t */",
            "\t\tshdr->sh_addr = (size_t)info->hdr + shdr->sh_offset;",
            "",
            "\t}",
            "",
            "\t/* Track but don't keep modinfo and version sections. */",
            "\tinfo->sechdrs[info->index.vers].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "\tinfo->sechdrs[info->index.info].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_chunked_from_user, check_modinfo_livepatch, check_modinfo_retpoline, copy_module_from_user, free_copy, rewrite_section_headers",
          "description": "实现分块从用户空间复制数据到内核缓冲区，检查模块livepatch属性，校验retpoline标志，复制模块元信息到内核，释放动态分配的模块数据，重写ELF节头地址以匹配实际内存布局",
          "similarity": 0.5533775687217712
        },
        {
          "chunk_id": 16,
          "file_path": "kernel/module/main.c",
          "start_line": 3116,
          "end_line": 3223,
          "content": [
            "static bool idempotent(struct idempotent *u, const void *cookie)",
            "{",
            "\tint hash = hash_ptr(cookie, IDEM_HASH_BITS);",
            "\tstruct hlist_head *head = idem_hash + hash;",
            "\tstruct idempotent *existing;",
            "\tbool first;",
            "",
            "\tu->ret = -EINTR;",
            "\tu->cookie = cookie;",
            "\tinit_completion(&u->complete);",
            "",
            "\tspin_lock(&idem_lock);",
            "\tfirst = true;",
            "\thlist_for_each_entry(existing, head, entry) {",
            "\t\tif (existing->cookie != cookie)",
            "\t\t\tcontinue;",
            "\t\tfirst = false;",
            "\t\tbreak;",
            "\t}",
            "\thlist_add_head(&u->entry, idem_hash + hash);",
            "\tspin_unlock(&idem_lock);",
            "",
            "\treturn !first;",
            "}",
            "static int idempotent_complete(struct idempotent *u, int ret)",
            "{",
            "\tconst void *cookie = u->cookie;",
            "\tint hash = hash_ptr(cookie, IDEM_HASH_BITS);",
            "\tstruct hlist_head *head = idem_hash + hash;",
            "\tstruct hlist_node *next;",
            "\tstruct idempotent *pos;",
            "",
            "\tspin_lock(&idem_lock);",
            "\thlist_for_each_entry_safe(pos, next, head, entry) {",
            "\t\tif (pos->cookie != cookie)",
            "\t\t\tcontinue;",
            "\t\thlist_del_init(&pos->entry);",
            "\t\tpos->ret = ret;",
            "\t\tcomplete(&pos->complete);",
            "\t}",
            "\tspin_unlock(&idem_lock);",
            "\treturn ret;",
            "}",
            "static int idempotent_wait_for_completion(struct idempotent *u)",
            "{",
            "\tif (wait_for_completion_interruptible(&u->complete)) {",
            "\t\tspin_lock(&idem_lock);",
            "\t\tif (!hlist_unhashed(&u->entry))",
            "\t\t\thlist_del(&u->entry);",
            "\t\tspin_unlock(&idem_lock);",
            "\t}",
            "\treturn u->ret;",
            "}",
            "static int init_module_from_file(struct file *f, const char __user * uargs, int flags)",
            "{",
            "\tstruct load_info info = { };",
            "\tvoid *buf = NULL;",
            "\tint len;",
            "",
            "\tlen = kernel_read_file(f, 0, &buf, INT_MAX, NULL, READING_MODULE);",
            "\tif (len < 0) {",
            "\t\tmod_stat_inc(&failed_kreads);",
            "\t\treturn len;",
            "\t}",
            "",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE) {",
            "\t\tint err = module_decompress(&info, buf, len);",
            "\t\tvfree(buf); /* compressed data is no longer needed */",
            "\t\tif (err) {",
            "\t\t\tmod_stat_inc(&failed_decompress);",
            "\t\t\tmod_stat_add_long(len, &invalid_decompress_bytes);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t} else {",
            "\t\tinfo.hdr = buf;",
            "\t\tinfo.len = len;",
            "\t}",
            "",
            "\treturn load_module(&info, uargs, flags);",
            "}",
            "static int idempotent_init_module(struct file *f, const char __user * uargs, int flags)",
            "{",
            "\tstruct idempotent idem;",
            "",
            "\tif (!(f->f_mode & FMODE_READ))",
            "\t\treturn -EBADF;",
            "",
            "\t/* Are we the winners of the race and get to do this? */",
            "\tif (!idempotent(&idem, file_inode(f))) {",
            "\t\tint ret = init_module_from_file(f, uargs, flags);",
            "\t\treturn idempotent_complete(&idem, ret);",
            "\t}",
            "",
            "\t/*",
            "\t * Somebody else won the race and is loading the module.",
            "\t */",
            "\treturn idempotent_wait_for_completion(&idem);",
            "}",
            "bool is_module_address(unsigned long addr)",
            "{",
            "\tbool ret;",
            "",
            "\tpreempt_disable();",
            "\tret = __module_address(addr) != NULL;",
            "\tpreempt_enable();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "idempotent, idempotent_complete, idempotent_wait_for_completion, init_module_from_file, idempotent_init_module, is_module_address",
          "description": "idempotent 系列函数实现幂等性控制，通过哈希表防止重复模块加载；init_module_from_file 解析模块文件并调用load_module加载",
          "similarity": 0.544641375541687
        }
      ]
    },
    {
      "source_file": "kernel/module/kallsyms.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:02:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\kallsyms.c`\n\n---\n\n# module/kallsyms.c 技术文档\n\n## 1. 文件概述\n\n`module/kallsyms.c` 是 Linux 内核模块子系统中用于支持 **模块符号表（kallsyms）** 的核心实现文件。该文件负责在模块加载过程中处理 ELF 符号表（`.symtab`）和字符串表（`.strtab`），为模块提供运行时符号解析、调试信息支持以及 `/proc/kallsyms` 中模块符号的展示能力。它实现了模块符号的筛选、布局、复制和类型标注，确保只有“核心符号”（即非初始化段符号）在模块初始化完成后仍可被访问，同时支持 livepatch 模块的特殊需求。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`lookup_exported_symbol()`**  \n  在指定的 `kernel_symbol` 数组范围内使用二分查找（`bsearch`）定位导出符号。\n\n- **`is_exported()`**  \n  判断给定名称和地址的符号是否为内核或指定模块的已导出符号。\n\n- **`elf_type()`**  \n  根据 ELF 符号属性和节区信息，返回与 `nm` 工具兼容的符号类型字符（如 `'t'` 表示代码，`'d'` 表示已初始化数据等）。\n\n- **`is_core_symbol()`**  \n  判断一个 ELF 符号是否属于“核心符号”（即在模块初始化完成后仍需保留的符号），依据包括节区属性（`SHF_ALLOC`、`SHF_EXECINSTR`）、是否为 per-CPU 符号（受 `CONFIG_KALLSYMS_ALL` 控制）以及是否属于初始化内存类型。\n\n- **`layout_symtab()`**  \n  在模块内存布局阶段，计算并预留用于存储核心符号表、字符串表及类型表的空间，同时将原始符号表和字符串表标记为可分配（`SHF_ALLOC`）并放置在初始化数据段末尾。\n\n- **`add_kallsyms()`**  \n  在模块加载过程中，将完整的符号信息（用于初始化阶段）和裁剪后的核心符号信息（用于运行时）分别填充到初始化数据段和核心数据段，并设置符号类型。\n\n- **`init_build_id()`**  \n  （条件编译）从模块的 `SHT_NOTE` 节区中解析并初始化 Build ID，用于栈追踪和调试。\n\n- **`kallsyms_symbol_name()`**  \n  辅助函数，根据符号索引返回符号名称字符串。\n\n- **`find_kallsyms_sym()`**  \n  （未完整显示）用于根据地址在模块符号表中查找对应的符号名称，并可返回符号大小和偏移。\n\n### 关键数据结构\n\n- **`struct mod_kallsyms`**  \n  存储模块的完整符号表信息（在初始化阶段使用），包含 `symtab`、`strtab`、`typetab` 和符号数量。\n\n- **`mod->core_kallsyms`**  \n  模块结构体中的字段，存储裁剪后的核心符号表信息（初始化完成后使用）。\n\n- **`info->symoffs` / `info->stroffs` / `info->core_typeoffs` / `info->init_typeoffs`**  \n  `load_info` 中的偏移量字段，用于记录符号表、字符串表和类型表在模块内存中的布局位置。\n\n## 3. 关键实现\n\n### 符号筛选与内存布局\n- **两阶段符号表**：模块加载时维护两套符号表：\n  - **完整符号表**：包含所有符号，存放在 `MOD_INIT_DATA` 段，仅在模块初始化期间有效。\n  - **核心符号表**：仅包含 `is_core_symbol()` 判定为有效的符号（如代码段、只读数据、per-CPU 符号等），存放在 `MOD_DATA` 段，模块初始化完成后长期保留。\n- **内存分配**：通过 `layout_symtab()` 预先计算核心符号所需空间，并在模块内存布局中预留连续区域，避免运行时动态分配。\n\n### 符号类型标注\n- **`elf_type()`** 函数模拟 `nm` 工具的符号分类逻辑，根据 ELF 节区标志（如 `SHF_EXECINSTR`、`SHF_WRITE`）和符号绑定类型（如 `STB_WEAK`）生成单字符类型标识，用于 `/proc/kallsyms` 输出。\n\n### RCU 安全访问\n- 模块的 `kallsyms` 字段通过 **RCU（Read-Copy-Update）** 机制保护，在 `add_kallsyms()` 中使用 `rcu_dereference()` 和 `rcu_read_lock()` 确保并发安全。\n\n### Build ID 支持\n- 当启用 `CONFIG_STACKTRACE_BUILD_ID` 时，从模块的 `SHT_NOTE` 节区解析 GNU Build ID，用于唯一标识模块二进制，辅助崩溃分析和调试。\n\n### Livepatch 特殊处理\n- 在符号筛选逻辑中，若模块为 livepatch 模块（`is_livepatch_module(mod)`），则保留所有符号（包括初始化符号），以支持动态补丁的符号解析需求。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：模块核心结构体和 API。\n  - `<linux/kallsyms.h>`：内核符号表相关定义（如 `cmp_name`、`kernel_symbol_value`）。\n  - `<linux/buildid.h>`：Build ID 解析函数。\n  - `\"internal.h\"`：模块子系统内部头文件，包含 `module_memory`、`mod_mem_type` 等私有定义。\n- **内核配置依赖**：\n  - `CONFIG_KALLSYMS_ALL`：控制是否将所有已分配节区的符号（包括数据符号）纳入核心符号表。\n  - `CONFIG_STACKTRACE_BUILD_ID`：启用 Build ID 解析功能。\n- **与其他模块交互**：\n  - 与 `kernel/kallsyms.c` 协同工作，为 `/proc/kallsyms` 提供模块符号信息。\n  - 依赖模块加载器（`module.c`）提供的 `load_info` 结构和内存布局机制。\n\n## 5. 使用场景\n\n- **模块加载过程**：在 `load_module()` 流程中，由 `layout_symtab()` 和 `add_kallsyms()` 处理符号表，为模块提供运行时符号信息。\n- **内核符号解析**：当内核需要解析模块内的符号地址（如 Oops 日志、ftrace、perf）时，通过 `find_kallsyms_sym()` 查询模块的核心符号表。\n- **调试与分析**：通过 `/proc/kallsyms` 导出模块符号，供调试工具（如 GDB、perf）使用；Build ID 用于匹配调试符号文件。\n- **Livepatch 动态补丁**：确保 livepatch 模块的所有符号（包括初始化符号）在运行时可被解析，支持热补丁的符号重定向。\n- **内存优化**：在模块初始化完成后释放初始化段（包括完整符号表），仅保留核心符号表，减少内存占用。",
      "similarity": 0.6054198145866394,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/module/kallsyms.c",
          "start_line": 414,
          "end_line": 516,
          "content": [
            "static unsigned long __find_kallsyms_symbol_value(struct module *mod, const char *name)",
            "{",
            "\tunsigned int i;",
            "\tstruct mod_kallsyms *kallsyms = rcu_dereference_sched(mod->kallsyms);",
            "",
            "\tfor (i = 0; i < kallsyms->num_symtab; i++) {",
            "\t\tconst Elf_Sym *sym = &kallsyms->symtab[i];",
            "",
            "\t\tif (strcmp(name, kallsyms_symbol_name(kallsyms, i)) == 0 &&",
            "\t\t    sym->st_shndx != SHN_UNDEF)",
            "\t\t\treturn kallsyms_symbol_value(sym);",
            "\t}",
            "\treturn 0;",
            "}",
            "static unsigned long __module_kallsyms_lookup_name(const char *name)",
            "{",
            "\tstruct module *mod;",
            "\tchar *colon;",
            "",
            "\tcolon = strnchr(name, MODULE_NAME_LEN, ':');",
            "\tif (colon) {",
            "\t\tmod = find_module_all(name, colon - name, false);",
            "\t\tif (mod)",
            "\t\t\treturn __find_kallsyms_symbol_value(mod, colon + 1);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tlist_for_each_entry_rcu(mod, &modules, list) {",
            "\t\tunsigned long ret;",
            "",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "\t\tret = __find_kallsyms_symbol_value(mod, name);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "\treturn 0;",
            "}",
            "unsigned long module_kallsyms_lookup_name(const char *name)",
            "{",
            "\tunsigned long ret;",
            "",
            "\t/* Don't lock: we're in enough trouble already. */",
            "\tpreempt_disable();",
            "\tret = __module_kallsyms_lookup_name(name);",
            "\tpreempt_enable();",
            "\treturn ret;",
            "}",
            "unsigned long find_kallsyms_symbol_value(struct module *mod, const char *name)",
            "{",
            "\tunsigned long ret;",
            "",
            "\tpreempt_disable();",
            "\tret = __find_kallsyms_symbol_value(mod, name);",
            "\tpreempt_enable();",
            "\treturn ret;",
            "}",
            "int module_kallsyms_on_each_symbol(const char *modname,",
            "\t\t\t\t   int (*fn)(void *, const char *, unsigned long),",
            "\t\t\t\t   void *data)",
            "{",
            "\tstruct module *mod;",
            "\tunsigned int i;",
            "\tint ret = 0;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\tlist_for_each_entry(mod, &modules, list) {",
            "\t\tstruct mod_kallsyms *kallsyms;",
            "",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (modname && strcmp(modname, mod->name))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Use rcu_dereference_sched() to remain compliant with the sparse tool */",
            "\t\tpreempt_disable();",
            "\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);",
            "\t\tpreempt_enable();",
            "",
            "\t\tfor (i = 0; i < kallsyms->num_symtab; i++) {",
            "\t\t\tconst Elf_Sym *sym = &kallsyms->symtab[i];",
            "",
            "\t\t\tif (sym->st_shndx == SHN_UNDEF)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tret = fn(data, kallsyms_symbol_name(kallsyms, i),",
            "\t\t\t\t kallsyms_symbol_value(sym));",
            "\t\t\tif (ret != 0)",
            "\t\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * The given module is found, the subsequent modules do not",
            "\t\t * need to be compared.",
            "\t\t */",
            "\t\tif (modname)",
            "\t\t\tbreak;",
            "\t}",
            "out:",
            "\tmutex_unlock(&module_mutex);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__find_kallsyms_symbol_value, __module_kallsyms_lookup_name, module_kallsyms_lookup_name, find_kallsyms_symbol_value, module_kallsyms_on_each_symbol",
          "description": "实现符号值查找、带模块限定的符号查找及遍历所有符号的函数，提供内核模块符号访问的核心实现逻辑",
          "similarity": 0.5724736452102661
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/kallsyms.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module kallsyms support",
            " *",
            " * Copyright (C) 2010 Rusty Russell",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/module_symbol.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buildid.h>",
            "#include <linux/bsearch.h>",
            "#include \"internal.h\"",
            "",
            "/* Lookup exported symbol in given range of kernel_symbols */",
            "static const struct kernel_symbol *lookup_exported_symbol(const char *name,",
            "\t\t\t\t\t\t\t  const struct kernel_symbol *start,",
            "\t\t\t\t\t\t\t  const struct kernel_symbol *stop)",
            "{",
            "\treturn bsearch(name, start, stop - start,",
            "\t\t\tsizeof(struct kernel_symbol), cmp_name);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现通过二分查找在内核符号表中定位导出符号的辅助函数，用于模块符号查找。",
          "similarity": 0.49847790598869324
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/kallsyms.c",
          "start_line": 170,
          "end_line": 293,
          "content": [
            "void add_kallsyms(struct module *mod, const struct load_info *info)",
            "{",
            "\tunsigned int i, ndst;",
            "\tconst Elf_Sym *src;",
            "\tElf_Sym *dst;",
            "\tchar *s;",
            "\tElf_Shdr *symsec = &info->sechdrs[info->index.sym];",
            "\tunsigned long strtab_size;",
            "\tvoid *data_base = mod->mem[MOD_DATA].base;",
            "\tvoid *init_data_base = mod->mem[MOD_INIT_DATA].base;",
            "",
            "\t/* Set up to point into init section. */",
            "\tmod->kallsyms = (void __rcu *)init_data_base +",
            "\t\tinfo->mod_kallsyms_init_off;",
            "",
            "\trcu_read_lock();",
            "\t/* The following is safe since this pointer cannot change */",
            "\trcu_dereference(mod->kallsyms)->symtab = (void *)symsec->sh_addr;",
            "\trcu_dereference(mod->kallsyms)->num_symtab = symsec->sh_size / sizeof(Elf_Sym);",
            "\t/* Make sure we get permanent strtab: don't use info->strtab. */",
            "\trcu_dereference(mod->kallsyms)->strtab =",
            "\t\t(void *)info->sechdrs[info->index.str].sh_addr;",
            "\trcu_dereference(mod->kallsyms)->typetab = init_data_base + info->init_typeoffs;",
            "",
            "\t/*",
            "\t * Now populate the cut down core kallsyms for after init",
            "\t * and set types up while we still have access to sections.",
            "\t */",
            "\tmod->core_kallsyms.symtab = dst = data_base + info->symoffs;",
            "\tmod->core_kallsyms.strtab = s = data_base + info->stroffs;",
            "\tmod->core_kallsyms.typetab = data_base + info->core_typeoffs;",
            "\tstrtab_size = info->core_typeoffs - info->stroffs;",
            "\tsrc = rcu_dereference(mod->kallsyms)->symtab;",
            "\tfor (ndst = i = 0; i < rcu_dereference(mod->kallsyms)->num_symtab; i++) {",
            "\t\trcu_dereference(mod->kallsyms)->typetab[i] = elf_type(src + i, info);",
            "\t\tif (i == 0 || is_livepatch_module(mod) ||",
            "\t\t    is_core_symbol(src + i, info->sechdrs, info->hdr->e_shnum,",
            "\t\t\t\t   info->index.pcpu)) {",
            "\t\t\tssize_t ret;",
            "",
            "\t\t\tmod->core_kallsyms.typetab[ndst] =",
            "\t\t\t    rcu_dereference(mod->kallsyms)->typetab[i];",
            "\t\t\tdst[ndst] = src[i];",
            "\t\t\tdst[ndst++].st_name = s - mod->core_kallsyms.strtab;",
            "\t\t\tret = strscpy(s,",
            "\t\t\t\t      &rcu_dereference(mod->kallsyms)->strtab[src[i].st_name],",
            "\t\t\t\t      strtab_size);",
            "\t\t\tif (ret < 0)",
            "\t\t\t\tbreak;",
            "\t\t\ts += ret + 1;",
            "\t\t\tstrtab_size -= ret + 1;",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock();",
            "\tmod->core_kallsyms.num_symtab = ndst;",
            "}",
            "void init_build_id(struct module *mod, const struct load_info *info)",
            "{",
            "\tconst Elf_Shdr *sechdr;",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < info->hdr->e_shnum; i++) {",
            "\t\tsechdr = &info->sechdrs[i];",
            "\t\tif (!sect_empty(sechdr) && sechdr->sh_type == SHT_NOTE &&",
            "\t\t    !build_id_parse_buf((void *)sechdr->sh_addr, mod->build_id,",
            "\t\t\t\t\tsechdr->sh_size))",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "void init_build_id(struct module *mod, const struct load_info *info)",
            "{",
            "}",
            "int lookup_module_symbol_name(unsigned long addr, char *symname)",
            "{",
            "\tstruct module *mod;",
            "",
            "\tpreempt_disable();",
            "\tlist_for_each_entry_rcu(mod, &modules, list) {",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "\t\tif (within_module(addr, mod)) {",
            "\t\t\tconst char *sym;",
            "",
            "\t\t\tsym = find_kallsyms_symbol(mod, addr, NULL, NULL);",
            "\t\t\tif (!sym)",
            "\t\t\t\tgoto out;",
            "",
            "\t\t\tstrscpy(symname, sym, KSYM_NAME_LEN);",
            "\t\t\tpreempt_enable();",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "out:",
            "\tpreempt_enable();",
            "\treturn -ERANGE;",
            "}",
            "int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,",
            "\t\t       char *name, char *module_name, int *exported)",
            "{",
            "\tstruct module *mod;",
            "",
            "\tpreempt_disable();",
            "\tlist_for_each_entry_rcu(mod, &modules, list) {",
            "\t\tstruct mod_kallsyms *kallsyms;",
            "",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);",
            "\t\tif (symnum < kallsyms->num_symtab) {",
            "\t\t\tconst Elf_Sym *sym = &kallsyms->symtab[symnum];",
            "",
            "\t\t\t*value = kallsyms_symbol_value(sym);",
            "\t\t\t*type = kallsyms->typetab[symnum];",
            "\t\t\tstrscpy(name, kallsyms_symbol_name(kallsyms, symnum), KSYM_NAME_LEN);",
            "\t\t\tstrscpy(module_name, mod->name, MODULE_NAME_LEN);",
            "\t\t\t*exported = is_exported(name, *value, mod);",
            "\t\t\tpreempt_enable();",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tsymnum -= kallsyms->num_symtab;",
            "\t}",
            "\tpreempt_enable();",
            "\treturn -ERANGE;",
            "}"
          ],
          "function_name": "add_kallsyms, init_build_id, init_build_id, lookup_module_symbol_name, module_get_kallsym",
          "description": "初始化模块kallsyms数据结构并填充符号信息，包含构建ID解析、符号查找及模块符号表访问接口。存在重复函数声明",
          "similarity": 0.4953347444534302
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/kallsyms.c",
          "start_line": 24,
          "end_line": 152,
          "content": [
            "static int is_exported(const char *name, unsigned long value,",
            "\t\t       const struct module *mod)",
            "{",
            "\tconst struct kernel_symbol *ks;",
            "",
            "\tif (!mod)",
            "\t\tks = lookup_exported_symbol(name, __start___ksymtab, __stop___ksymtab);",
            "\telse",
            "\t\tks = lookup_exported_symbol(name, mod->syms, mod->syms + mod->num_syms);",
            "",
            "\treturn ks && kernel_symbol_value(ks) == value;",
            "}",
            "static char elf_type(const Elf_Sym *sym, const struct load_info *info)",
            "{",
            "\tconst Elf_Shdr *sechdrs = info->sechdrs;",
            "",
            "\tif (ELF_ST_BIND(sym->st_info) == STB_WEAK) {",
            "\t\tif (ELF_ST_TYPE(sym->st_info) == STT_OBJECT)",
            "\t\t\treturn 'v';",
            "\t\telse",
            "\t\t\treturn 'w';",
            "\t}",
            "\tif (sym->st_shndx == SHN_UNDEF)",
            "\t\treturn 'U';",
            "\tif (sym->st_shndx == SHN_ABS || sym->st_shndx == info->index.pcpu)",
            "\t\treturn 'a';",
            "\tif (sym->st_shndx >= SHN_LORESERVE)",
            "\t\treturn '?';",
            "\tif (sechdrs[sym->st_shndx].sh_flags & SHF_EXECINSTR)",
            "\t\treturn 't';",
            "\tif (sechdrs[sym->st_shndx].sh_flags & SHF_ALLOC &&",
            "\t    sechdrs[sym->st_shndx].sh_type != SHT_NOBITS) {",
            "\t\tif (!(sechdrs[sym->st_shndx].sh_flags & SHF_WRITE))",
            "\t\t\treturn 'r';",
            "\t\telse if (sechdrs[sym->st_shndx].sh_flags & ARCH_SHF_SMALL)",
            "\t\t\treturn 'g';",
            "\t\telse",
            "\t\t\treturn 'd';",
            "\t}",
            "\tif (sechdrs[sym->st_shndx].sh_type == SHT_NOBITS) {",
            "\t\tif (sechdrs[sym->st_shndx].sh_flags & ARCH_SHF_SMALL)",
            "\t\t\treturn 's';",
            "\t\telse",
            "\t\t\treturn 'b';",
            "\t}",
            "\tif (strstarts(info->secstrings + sechdrs[sym->st_shndx].sh_name,",
            "\t\t      \".debug\")) {",
            "\t\treturn 'n';",
            "\t}",
            "\treturn '?';",
            "}",
            "static bool is_core_symbol(const Elf_Sym *src, const Elf_Shdr *sechdrs,",
            "\t\t\t   unsigned int shnum, unsigned int pcpundx)",
            "{",
            "\tconst Elf_Shdr *sec;",
            "\tenum mod_mem_type type;",
            "",
            "\tif (src->st_shndx == SHN_UNDEF ||",
            "\t    src->st_shndx >= shnum ||",
            "\t    !src->st_name)",
            "\t\treturn false;",
            "",
            "#ifdef CONFIG_KALLSYMS_ALL",
            "\tif (src->st_shndx == pcpundx)",
            "\t\treturn true;",
            "#endif",
            "",
            "\tsec = sechdrs + src->st_shndx;",
            "\ttype = sec->sh_entsize >> SH_ENTSIZE_TYPE_SHIFT;",
            "\tif (!(sec->sh_flags & SHF_ALLOC)",
            "#ifndef CONFIG_KALLSYMS_ALL",
            "\t    || !(sec->sh_flags & SHF_EXECINSTR)",
            "#endif",
            "\t    || mod_mem_type_is_init(type))",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "void layout_symtab(struct module *mod, struct load_info *info)",
            "{",
            "\tElf_Shdr *symsect = info->sechdrs + info->index.sym;",
            "\tElf_Shdr *strsect = info->sechdrs + info->index.str;",
            "\tconst Elf_Sym *src;",
            "\tunsigned int i, nsrc, ndst, strtab_size = 0;",
            "\tstruct module_memory *mod_mem_data = &mod->mem[MOD_DATA];",
            "\tstruct module_memory *mod_mem_init_data = &mod->mem[MOD_INIT_DATA];",
            "",
            "\t/* Put symbol section at end of init part of module. */",
            "\tsymsect->sh_flags |= SHF_ALLOC;",
            "\tsymsect->sh_entsize = module_get_offset_and_type(mod, MOD_INIT_DATA,",
            "\t\t\t\t\t\t\t symsect, info->index.sym);",
            "\tpr_debug(\"\\t%s\\n\", info->secstrings + symsect->sh_name);",
            "",
            "\tsrc = (void *)info->hdr + symsect->sh_offset;",
            "\tnsrc = symsect->sh_size / sizeof(*src);",
            "",
            "\t/* Compute total space required for the core symbols' strtab. */",
            "\tfor (ndst = i = 0; i < nsrc; i++) {",
            "\t\tif (i == 0 || is_livepatch_module(mod) ||",
            "\t\t    is_core_symbol(src + i, info->sechdrs, info->hdr->e_shnum,",
            "\t\t\t\t   info->index.pcpu)) {",
            "\t\t\tstrtab_size += strlen(&info->strtab[src[i].st_name]) + 1;",
            "\t\t\tndst++;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Append room for core symbols at end of core part. */",
            "\tinfo->symoffs = ALIGN(mod_mem_data->size, symsect->sh_addralign ?: 1);",
            "\tinfo->stroffs = mod_mem_data->size = info->symoffs + ndst * sizeof(Elf_Sym);",
            "\tmod_mem_data->size += strtab_size;",
            "\t/* Note add_kallsyms() computes strtab_size as core_typeoffs - stroffs */",
            "\tinfo->core_typeoffs = mod_mem_data->size;",
            "\tmod_mem_data->size += ndst * sizeof(char);",
            "",
            "\t/* Put string table section at end of init part of module. */",
            "\tstrsect->sh_flags |= SHF_ALLOC;",
            "\tstrsect->sh_entsize = module_get_offset_and_type(mod, MOD_INIT_DATA,",
            "\t\t\t\t\t\t\t strsect, info->index.str);",
            "\tpr_debug(\"\\t%s\\n\", info->secstrings + strsect->sh_name);",
            "",
            "\t/* We'll tack temporary mod_kallsyms on the end. */",
            "\tmod_mem_init_data->size = ALIGN(mod_mem_init_data->size,",
            "\t\t\t\t\t__alignof__(struct mod_kallsyms));",
            "\tinfo->mod_kallsyms_init_off = mod_mem_init_data->size;",
            "",
            "\tmod_mem_init_data->size += sizeof(struct mod_kallsyms);",
            "\tinfo->init_typeoffs = mod_mem_init_data->size;",
            "\tmod_mem_init_data->size += nsrc * sizeof(char);",
            "}"
          ],
          "function_name": "is_exported, elf_type, is_core_symbol, layout_symtab",
          "description": "定义符号导出检查、ELF符号类型识别及核心符号判定逻辑，用于模块符号表布局与符号分类处理。上下文不完整",
          "similarity": 0.4882383346557617
        }
      ]
    },
    {
      "source_file": "kernel/module/internal.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:01:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\internal.h`\n\n---\n\n# `module/internal.h` 技术文档\n\n## 1. 文件概述\n\n`module/internal.h` 是 Linux 内核模块子系统的核心内部头文件，定义了模块加载、符号解析、内存布局、调试统计等关键内部数据结构和辅助函数。该文件仅供内核模块子系统内部使用，不对外暴露给模块开发者。它封装了模块加载过程中的中间状态、符号查找逻辑、内存管理细节以及与架构相关的重定位处理，并集成了模块压缩、热补丁（livepatch）、污点追踪（taint tracking）和调试统计等可选功能的支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct kernel_symbol`**  \n  内核符号的内部表示，支持两种模式：  \n  - 普通模式：直接存储符号值（`value`）、名称（`name`）和命名空间（`namespace`）指针。  \n  - `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 模式：使用偏移量（`value_offset` 等）以节省内存并支持位置无关代码。\n\n- **`struct load_info`**  \n  模块加载过程中的临时信息容器，包含 ELF 头、节头表、字符串表、符号表、各节偏移、签名状态、解压页信息等，贯穿整个 `load_module()` 流程。\n\n- **`struct find_symbol_arg`**  \n  符号查找的输入/输出参数结构，用于 `find_symbol()` 函数，支持按名称、GPL 许可限制进行符号搜索。\n\n- **`enum fail_dup_mod_reason`**  \n  定义重复模块加载失败的两种场景：`FAIL_DUP_MOD_BECOMING`（早期检查阶段发现重复）和 `FAIL_DUP_MOD_LOAD`（分配内存后发现重复）。\n\n- **`struct mod_fail_load`**（仅当 `CONFIG_MODULE_STATS` 启用）  \n  用于统计重复加载失败的模块信息。\n\n- **`struct mod_unload_taint`**（仅当 `CONFIG_MODULE_UNLOAD_TAINT_TRACKING` 启用）  \n  记录卸载时带有污点（taint）的模块信息。\n\n### 主要函数\n\n- **符号管理**  \n  - `find_symbol()`：在全局符号表中查找指定名称的符号。  \n  - `kernel_symbol_value()`：获取 `kernel_symbol` 结构中符号的实际地址。\n\n- **模块加载辅助**  \n  - `mod_verify_sig()`：验证模块签名。  \n  - `try_to_force_load()`：在特定条件下强制加载被拒绝的模块（如 taint 原因）。  \n  - `module_get_offset_and_type()`：计算模块节在目标内存布局中的偏移和内存类型。  \n  - `module_flags()` / `module_flags_taint()`：生成模块状态或污点标志的字符串表示。\n\n- **模块信息解析**  \n  - `module_next_tag_pair()`：解析模块信息（modinfo）中的键值对。  \n  - `for_each_modinfo_entry`：遍历指定名称的 modinfo 条目。\n\n- **热补丁支持**（`CONFIG_LIVEPATCH`）  \n  - `copy_module_elf()` / `free_module_elf()`：复制或释放模块的 ELF 原始数据，供 livepatch 使用。  \n  - `set_livepatch_module()`：标记模块为 livepatch 模块。\n\n- **统计与调试**（条件编译）  \n  - `try_add_failed_module()`：记录重复加载失败事件。  \n  - `mod_stat_bump_invalid()` / `mod_stat_bump_becoming()`：更新无效或正在加载的模块统计。  \n  - `try_add_tainted_module()` / `print_unloaded_tainted_modules()`：跟踪并打印卸载时带污点的模块。  \n  - `kmod_dup_request_exists_wait()` / `kmod_dup_request_announce()`：用于调试自动加载重复请求。\n\n- **解压支持**（`CONFIG_MODULE_DECOMPRESS`）  \n  - `module_decompress()` / `module_decompress_cleanup()`：解压压缩的模块镜像。\n\n### 全局变量\n\n- `module_mutex`：保护模块列表和状态的全局互斥锁。  \n- `modules`：已加载模块的全局链表。  \n- `modinfo_attrs[]` / `modinfo_attrs_count`：模块信息属性数组及其数量。  \n- `__start___ksymtab[]` 等：链接器生成的内核符号表起止标记。  \n- 各类统计计数器（如 `total_mod_size`, `modcount` 等，仅当 `CONFIG_MODULE_STATS` 启用）。\n\n## 3. 关键实现\n\n### 符号表与重定位优化\n- 通过 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 支持使用 32 位相对偏移代替 64 位绝对指针，显著减少符号表内存占用，尤其在 64 位系统上。\n- `kernel_symbol_value()` 宏根据配置自动选择解析方式，对上层透明。\n\n### 节类型编码\n- 利用 ELF 节头 `sh_entsize` 的高 4 位存储 `mod_mem_type`（内存类型），低 28/60 位存储偏移量。\n- 定义了 `SH_ENTSIZE_TYPE_BITS`、`SH_ENTSIZE_TYPE_MASK` 等宏进行位操作，确保在 32/64 位系统上正确分离类型与偏移。\n\n### 模块加载状态保护\n- `module_assert_mutex_or_preempt()` 利用 `lockdep` 和 `rcu_read_lock_sched_held()` 确保关键操作在持有 `module_mutex` 或处于 RCU 读临界区中执行，防止并发错误。\n\n### 重复模块检测\n- `enum fail_dup_mod_reason` 精确区分重复模块在加载流程中被发现的两个关键点，有助于分析资源浪费（如 vmap 空间）和竞态条件。\n\n### 条件编译功能集成\n- 通过 `#ifdef CONFIG_XXX` 将模块统计、污点追踪、自动加载调试、解压、热补丁等功能模块化，保持核心逻辑简洁，按需启用。\n\n## 4. 依赖关系\n\n- **内核核心头文件**：  \n  - `<linux/elf.h>`：ELF 格式定义。  \n  - `<linux/module.h>`：模块公共接口。  \n  - `<linux/mutex.h>`, `<linux/rculist.h>`, `<linux/rcupdate.h>`：同步原语。  \n  - `<linux/mm.h>`：内存管理相关定义。\n\n- **架构相关**：  \n  - `ARCH_SHF_SMALL`：架构特定的节标志，用于小内存模型。\n\n- **可选子系统**：  \n  - `CONFIG_KALLSYMS`：内核符号表支持。  \n  - `CONFIG_LIVEPATCH`：内核热补丁。  \n  - `CONFIG_MODULE_DECOMPRESS`：模块解压。  \n  - `CONFIG_MODULE_STATS` / `CONFIG_MODULE_DEBUGFS` / `CONFIG_MODULE_UNLOAD_TAINT_TRACKING` / `CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS`：各类调试与统计功能。\n\n- **链接器脚本**：  \n  - 依赖链接器生成的 `__start___ksymtab`、`__stop___ksymtab_gpl` 等符号，用于遍历内建符号表。\n\n## 5. 使用场景\n\n- **模块加载流程**：`load_module()` 及其辅助函数使用 `struct load_info` 传递解析后的 ELF 信息，并调用 `mod_verify_sig()`、`module_decompress()` 等进行预处理。\n- **符号解析**：`find_symbol()` 被 `kernel/module.c` 中的符号导出/导入机制调用，实现模块间及内核与模块间的符号链接。\n- **内存布局**：`module_get_offset_and_type()` 在 `layout_and_allocate()` 阶段确定各节在模块内存映像中的位置。\n- **调试与监控**：  \n  - `module_flags()` 用于 `/sys/module/<name>/taint` 等接口显示模块状态。  \n  - 统计功能（`CONFIG_MODULE_STATS`）帮助分析模块加载性能与失败原因。  \n  - 污点追踪（`CONFIG_MODULE_UNLOAD_TAINT_TRACKING`）记录可能导致系统不稳定模块的卸载信息。\n- **热补丁**：livepatch 子系统通过 `copy_module_elf()` 保留原始 ELF 用于补丁验证和回滚。\n- **并发控制**：所有修改全局模块列表或状态的操作必须通过 `module_mutex` 保护，`module_assert_mutex_or_preempt()` 用于运行时检查。",
      "similarity": 0.5948224663734436,
      "chunks": []
    }
  ]
}