{
  "query": "宏内核如何管理硬件资源",
  "timestamp": "2025-12-26 01:54:32",
  "retrieved_files": [
    {
      "source_file": "mm/memblock.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memblock.c`\n\n---\n\n# memblock.c 技术文档\n\n## 1. 文件概述\n\n`memblock.c` 实现了 Linux 内核早期启动阶段的内存管理机制——**memblock**。该机制用于在常规内存分配器（如 buddy allocator）尚未初始化之前，对物理内存进行粗粒度的区域管理。它将系统内存抽象为若干连续的内存区域（regions），支持“可用内存”（memory）、“保留内存”（reserved）和“物理内存”（physmem，部分架构支持）三种类型，为内核早期初始化提供内存添加、查询和分配能力。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct memblock_region`：表示一个连续的物理内存区域，包含基地址（base）、大小（size）、NUMA 节点 ID 和属性标志。\n- `struct memblock_type`：管理一类内存区域的集合，包含区域数组、当前数量（cnt）、最大容量（max）和名称。\n- `struct memblock`：全局 memblock 管理结构，包含 `memory` 和 `reserved` 两种类型的 `memblock_type`，以及分配方向（bottom_up）和当前分配上限（current_limit）。\n- `physmem`（条件编译）：描述不受 `mem=` 参数限制的实际物理内存布局。\n\n### 主要函数与变量\n- `memblock_add()` / `memblock_add_node()`：向 memblock 添加可用内存区域。\n- `memblock_reserve()`：标记内存区域为保留（不可用于动态分配）。\n- `memblock_phys_alloc*()` / `memblock_alloc*()`：分配物理或虚拟地址的内存。\n- `memblock_overlaps_region()`：判断指定区域是否与某类 memblock 区域重叠。\n- `__memblock_find_range_bottom_up()`：从低地址向高地址查找满足条件的空闲内存范围。\n- 全局变量 `memblock`：静态初始化的主 memblock 结构体。\n- `max_low_pfn`, `min_low_pfn`, `max_pfn`, `max_possible_pfn`：记录 PFN（页帧号）边界信息。\n\n### 配置宏\n- `INIT_MEMBLOCK_REGIONS`：初始内存/保留区域数组大小（默认 128）。\n- `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 类型支持。\n- `CONFIG_MEMBLOCK_KHO_SCRATCH`：支持仅从特定标记（KHO_SCRATCH）区域分配内存。\n- `CONFIG_ARCH_KEEP_MEMBLOCK`：决定是否在初始化完成后保留 memblock 数据结构。\n\n## 3. 关键实现\n\n### 初始化与存储\n- `memblock` 结构体在编译时静态初始化，其 `memory` 和 `reserved` 的区域数组分别使用 `memblock_memory_init_regions` 和 `memblock_reserved_init_regions`，初始容量由 `INIT_MEMBLOCK_*_REGIONS` 定义。\n- 每个 `memblock_type` 的 `cnt` 初始设为 1，但实际第一个条目为空的占位符，有效区域从索引 1 开始（后续代码处理）。\n- 支持通过 `memblock_allow_resize()` 动态扩容区域数组，但需谨慎避免与 initrd 等关键区域冲突。\n\n### 内存区域管理\n- 使用 `for_each_memblock_type` 宏遍历指定类型的区域。\n- `memblock_addrs_overlap()` 通过比较区间端点判断两个物理内存区域是否重叠。\n- `memblock_overlaps_region()` 封装了对某类所有区域的重叠检测。\n\n### 分配策略\n- 默认采用 **top-down**（从高地址向低地址）分配策略，可通过 `memblock_set_bottom_up(true)` 切换为 **bottom-up**。\n- 分配时受 `current_limit` 限制（默认 `MEMBLOCK_ALLOC_ANYWHERE` 表示无限制）。\n- 支持基于 NUMA 节点、对齐要求、内存属性（如 `MEMBLOCK_MIRROR`、`MEMBLOCK_KHO_SCRATCH`）的精细控制。\n- `choose_memblock_flags()` 根据 `kho_scratch_only` 和镜像内存存在性动态选择分配标志。\n\n### 安全与调试\n- `memblock_cap_size()` 防止地址计算溢出（确保 `base + size <= PHYS_ADDR_MAX`）。\n- 条件编译的 `memblock_dbg()` 宏用于调试输出（需开启 `memblock_debug`）。\n- 使用 `__initdata_memblock` 属性标记仅在初始化阶段使用的数据，便于后续释放。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memblock.h>`：定义 memblock API 和数据结构。\n  - `<linux/kernel.h>`, `<linux/init.h>`：提供基础内核功能和初始化宏。\n  - `<linux/pfn.h>`：PFN 相关操作。\n  - `<asm/sections.h>`：访问内核链接段信息。\n  - 架构相关头文件（如 `internal.h`）。\n- **配置依赖**：\n  - `CONFIG_NUMA`：影响 `contig_page_data` 的定义。\n  - `CONFIG_KEXEC_HANDOVER`：引入 kexec 相关头文件。\n  - `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 支持。\n- **后续移交**：在 `mem_init()` 中，memblock 管理的内存会被释放给 buddy allocator，完成内存管理权移交。\n\n## 5. 使用场景\n\n- **内核早期初始化**：在 `start_kernel()` 初期，架构代码（如 `setup_arch()`）调用 `memblock_add()` 注册可用物理内存，调用 `memblock_reserve()` 保留内核镜像、设备树、initrd 等关键区域。\n- **早期内存分配**：在 slab/buddy 分配器就绪前，使用 `memblock_alloc()` 分配大块连续内存（如页表、中断向量表、ACPI 表解析缓冲区）。\n- **内存布局查询**：通过 `for_each_memblock()` 等宏遍历内存区域，用于构建 e820 表、EFI 内存映射或 NUMA 拓扑。\n- **特殊分配需求**：支持从镜像内存（`MEMBLOCK_MIRROR`）或 KHO scratch 区域分配，满足安全启动或崩溃转储等场景。\n- **调试与分析**：通过 debugfs 接口（未在片段中体现）导出 memblock 布局，辅助内存问题诊断。",
      "similarity": 0.6105107069015503,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "mm/memblock.c",
          "start_line": 1607,
          "end_line": 1734,
          "content": [
            "phys_addr_t __init memblock_phys_alloc_range(phys_addr_t size,",
            "\t\t\t\t\t     phys_addr_t align,",
            "\t\t\t\t\t     phys_addr_t start,",
            "\t\t\t\t\t     phys_addr_t end)",
            "{",
            "\tmemblock_dbg(\"%s: %llu bytes align=0x%llx from=%pa max_addr=%pa %pS\\n\",",
            "\t\t     __func__, (u64)size, (u64)align, &start, &end,",
            "\t\t     (void *)_RET_IP_);",
            "\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,",
            "\t\t\t\t\tfalse);",
            "}",
            "phys_addr_t __init memblock_phys_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)",
            "{",
            "\treturn memblock_alloc_range_nid(size, align, 0,",
            "\t\t\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid, false);",
            "}",
            "void __init memblock_free_late(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t cursor, end;",
            "",
            "\tend = base + size - 1;",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\",",
            "\t\t     __func__, &base, &end, (void *)_RET_IP_);",
            "\tkmemleak_free_part_phys(base, size);",
            "\tcursor = PFN_UP(base);",
            "\tend = PFN_DOWN(base + size);",
            "",
            "\tfor (; cursor < end; cursor++) {",
            "\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);",
            "\t\ttotalram_pages_inc();",
            "\t}",
            "}",
            "phys_addr_t __init_memblock memblock_reserved_kern_size(phys_addr_t limit, int nid)",
            "{",
            "\tstruct memblock_region *r;",
            "\tphys_addr_t total = 0;",
            "",
            "\tfor_each_reserved_mem_region(r) {",
            "\t\tphys_addr_t size = r->size;",
            "",
            "\t\tif (r->base > limit)",
            "\t\t\tbreak;",
            "",
            "\t\tif (r->base + r->size > limit)",
            "\t\t\tsize = limit - r->base;",
            "",
            "\t\tif (nid == memblock_get_region_node(r) || !numa_valid_node(nid))",
            "\t\t\tif (r->flags & MEMBLOCK_RSRV_KERN)",
            "\t\t\t\ttotal += size;",
            "\t}",
            "",
            "\treturn total;",
            "}",
            "unsigned long __init memblock_estimated_nr_free_pages(void)",
            "{",
            "\treturn PHYS_PFN(memblock_phys_mem_size() - memblock_reserved_size());",
            "}",
            "static phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr = PHYS_ADDR_MAX;",
            "\tstruct memblock_region *r;",
            "",
            "\t/*",
            "\t * translate the memory @limit size into the max address within one of",
            "\t * the memory memblock regions, if the @limit exceeds the total size",
            "\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX",
            "\t */",
            "\tfor_each_mem_region(r) {",
            "\t\tif (limit <= r->size) {",
            "\t\t\tmax_addr = r->base + limit;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tlimit -= r->size;",
            "\t}",
            "",
            "\treturn max_addr;",
            "}",
            "void __init memblock_enforce_memory_limit(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\t/* truncate both memory and reserved regions */",
            "\tmemblock_remove_range(&memblock.memory, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "\tmemblock_remove_range(&memblock.reserved, max_addr,",
            "\t\t\t      PHYS_ADDR_MAX);",
            "}",
            "void __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint start_rgn, end_rgn;",
            "\tint i, ret;",
            "",
            "\tif (!size)",
            "\t\treturn;",
            "",
            "\tif (!memblock_memory->total_size) {",
            "\t\tpr_warn(\"%s: No memory registered yet\\n\", __func__);",
            "\t\treturn;",
            "\t}",
            "",
            "\tret = memblock_isolate_range(&memblock.memory, base, size,",
            "\t\t\t\t\t\t&start_rgn, &end_rgn);",
            "\tif (ret)",
            "\t\treturn;",
            "",
            "\t/* remove all the MAP regions */",
            "\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\tfor (i = start_rgn - 1; i >= 0; i--)",
            "\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))",
            "\t\t\tmemblock_remove_region(&memblock.memory, i);",
            "",
            "\t/* truncate the reserved regions */",
            "\tmemblock_remove_range(&memblock.reserved, 0, base);",
            "\tmemblock_remove_range(&memblock.reserved,",
            "\t\t\tbase + size, PHYS_ADDR_MAX);",
            "}"
          ],
          "function_name": "memblock_phys_alloc_range, memblock_phys_alloc_try_nid, memblock_free_late, memblock_reserved_kern_size, memblock_estimated_nr_free_pages, __find_max_addr, memblock_enforce_memory_limit, memblock_cap_memory_range",
          "description": "实现物理内存分配/释放控制，包含内存上限强制限制、空闲页面估算、内存区域截断等管理功能，支持对保留内存的容量统计",
          "similarity": 0.6041818261146545
        },
        {
          "chunk_id": 10,
          "file_path": "mm/memblock.c",
          "start_line": 1954,
          "end_line": 2057,
          "content": [
            "void __init memblock_mem_limit_remove_map(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\tmemblock_cap_memory_range(0, max_addr);",
            "}",
            "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)",
            "{",
            "\tunsigned int left = 0, right = type->cnt;",
            "",
            "\tdo {",
            "\t\tunsigned int mid = (right + left) / 2;",
            "",
            "\t\tif (addr < type->regions[mid].base)",
            "\t\t\tright = mid;",
            "\t\telse if (addr >= (type->regions[mid].base +",
            "\t\t\t\t  type->regions[mid].size))",
            "\t\t\tleft = mid + 1;",
            "\t\telse",
            "\t\t\treturn mid;",
            "\t} while (left < right);",
            "\treturn -1;",
            "}",
            "bool __init_memblock memblock_is_reserved(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.reserved, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_memory(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.memory, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_map_memory(phys_addr_t addr)",
            "{",
            "\tint i = memblock_search(&memblock.memory, addr);",
            "",
            "\tif (i == -1)",
            "\t\treturn false;",
            "\treturn !memblock_is_nomap(&memblock.memory.regions[i]);",
            "}",
            "int __init_memblock memblock_search_pfn_nid(unsigned long pfn,",
            "\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)",
            "{",
            "\tstruct memblock_type *type = &memblock.memory;",
            "\tint mid = memblock_search(type, PFN_PHYS(pfn));",
            "",
            "\tif (mid == -1)",
            "\t\treturn -1;",
            "",
            "\t*start_pfn = PFN_DOWN(type->regions[mid].base);",
            "\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);",
            "",
            "\treturn memblock_get_region_node(&type->regions[mid]);",
            "}",
            "bool __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint idx = memblock_search(&memblock.memory, base);",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "",
            "\tif (idx == -1)",
            "\t\treturn false;",
            "\treturn (memblock.memory.regions[idx].base +",
            "\t\t memblock.memory.regions[idx].size) >= end;",
            "}",
            "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_overlaps_region(&memblock.reserved, base, size);",
            "}",
            "void __init_memblock memblock_trim_memory(phys_addr_t align)",
            "{",
            "\tphys_addr_t start, end, orig_start, orig_end;",
            "\tstruct memblock_region *r;",
            "",
            "\tfor_each_mem_region(r) {",
            "\t\torig_start = r->base;",
            "\t\torig_end = r->base + r->size;",
            "\t\tstart = round_up(orig_start, align);",
            "\t\tend = round_down(orig_end, align);",
            "",
            "\t\tif (start == orig_start && end == orig_end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start < end) {",
            "\t\t\tr->base = start;",
            "\t\t\tr->size = end - start;",
            "\t\t} else {",
            "\t\t\tmemblock_remove_region(&memblock.memory,",
            "\t\t\t\t\t       r - memblock.memory.regions);",
            "\t\t\tr--;",
            "\t\t}",
            "\t}",
            "}",
            "void __init_memblock memblock_set_current_limit(phys_addr_t limit)",
            "{",
            "\tmemblock.current_limit = limit;",
            "}"
          ],
          "function_name": "memblock_mem_limit_remove_map, memblock_search, memblock_is_reserved, memblock_is_memory, memblock_is_map_memory, memblock_search_pfn_nid, memblock_is_region_memory, memblock_is_region_reserved, memblock_trim_memory, memblock_set_current_limit",
          "description": "实现内存块限制移除、搜索和区域判断逻辑，用于管理内存和保留区域的地址范围查询及修剪操作",
          "similarity": 0.601245641708374
        },
        {
          "chunk_id": 11,
          "file_path": "mm/memblock.c",
          "start_line": 2094,
          "end_line": 2203,
          "content": [
            "static void __init_memblock memblock_dump(struct memblock_type *type)",
            "{",
            "\tphys_addr_t base, end, size;",
            "\tenum memblock_flags flags;",
            "\tint idx;",
            "\tstruct memblock_region *rgn;",
            "",
            "\tpr_info(\" %s.cnt  = 0x%lx\\n\", type->name, type->cnt);",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tchar nid_buf[32] = \"\";",
            "",
            "\t\tbase = rgn->base;",
            "\t\tsize = rgn->size;",
            "\t\tend = base + size - 1;",
            "\t\tflags = rgn->flags;",
            "#ifdef CONFIG_NUMA",
            "\t\tif (numa_valid_node(memblock_get_region_node(rgn)))",
            "\t\t\tsnprintf(nid_buf, sizeof(nid_buf), \" on node %d\",",
            "\t\t\t\t memblock_get_region_node(rgn));",
            "#endif",
            "\t\tpr_info(\" %s[%#x]\\t[%pa-%pa], %pa bytes%s flags: %#x\\n\",",
            "\t\t\ttype->name, idx, &base, &end, &size, nid_buf, flags);",
            "\t}",
            "}",
            "void __init memblock_allow_resize(void)",
            "{",
            "\tmemblock_can_resize = 1;",
            "}",
            "static int __init early_memblock(char *p)",
            "{",
            "\tif (p && strstr(p, \"debug\"))",
            "\t\tmemblock_debug = 1;",
            "\treturn 0;",
            "}",
            "static void __init free_memmap(unsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tstruct page *start_pg, *end_pg;",
            "\tphys_addr_t pg, pgend;",
            "",
            "\t/*",
            "\t * Convert start_pfn/end_pfn to a struct page pointer.",
            "\t */",
            "\tstart_pg = pfn_to_page(start_pfn - 1) + 1;",
            "\tend_pg = pfn_to_page(end_pfn - 1) + 1;",
            "",
            "\t/*",
            "\t * Convert to physical addresses, and round start upwards and end",
            "\t * downwards.",
            "\t */",
            "\tpg = PAGE_ALIGN(__pa(start_pg));",
            "\tpgend = __pa(end_pg) & PAGE_MASK;",
            "",
            "\t/*",
            "\t * If there are free pages between these, free the section of the",
            "\t * memmap array.",
            "\t */",
            "\tif (pg < pgend)",
            "\t\tmemblock_phys_free(pg, pgend - pg);",
            "}",
            "static void __init free_unused_memmap(void)",
            "{",
            "\tunsigned long start, end, prev_end = 0;",
            "\tint i;",
            "",
            "\tif (!IS_ENABLED(CONFIG_HAVE_ARCH_PFN_VALID) ||",
            "\t    IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This relies on each bank being in address order.",
            "\t * The banks are sorted previously in bootmem_init().",
            "\t */",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, NULL) {",
            "#ifdef CONFIG_SPARSEMEM",
            "\t\t/*",
            "\t\t * Take care not to free memmap entries that don't exist",
            "\t\t * due to SPARSEMEM sections which aren't present.",
            "\t\t */",
            "\t\tstart = min(start, ALIGN(prev_end, PAGES_PER_SECTION));",
            "#endif",
            "\t\t/*",
            "\t\t * Align down here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tstart = pageblock_start_pfn(start);",
            "",
            "\t\t/*",
            "\t\t * If we had a previous bank, and there is a space",
            "\t\t * between the current bank and the previous, free it.",
            "\t\t */",
            "\t\tif (prev_end && prev_end < start)",
            "\t\t\tfree_memmap(prev_end, start);",
            "",
            "\t\t/*",
            "\t\t * Align up here since many operations in VM subsystem",
            "\t\t * presume that there are no holes in the memory map inside",
            "\t\t * a pageblock",
            "\t\t */",
            "\t\tprev_end = pageblock_align(end);",
            "\t}",
            "",
            "#ifdef CONFIG_SPARSEMEM",
            "\tif (!IS_ALIGNED(prev_end, PAGES_PER_SECTION)) {",
            "\t\tprev_end = pageblock_align(end);",
            "\t\tfree_memmap(prev_end, ALIGN(prev_end, PAGES_PER_SECTION));",
            "\t}",
            "#endif",
            "}"
          ],
          "function_name": "memblock_dump, memblock_allow_resize, early_memblock, free_memmap, free_unused_memmap",
          "description": "提供内存块状态调试、调整支持、早期内存处理及未使用memmap释放功能，用于优化内存映射管理",
          "similarity": 0.5784705877304077
        },
        {
          "chunk_id": 6,
          "file_path": "mm/memblock.c",
          "start_line": 1052,
          "end_line": 1196,
          "content": [
            "int __init_memblock memblock_mark_mirror(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tif (!mirrored_kernelcore)",
            "\t\treturn 0;",
            "",
            "\tsystem_has_some_mirror = true;",
            "",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 1, MEMBLOCK_MIRROR);",
            "}",
            "int __init_memblock memblock_mark_nomap(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 1, MEMBLOCK_NOMAP);",
            "}",
            "int __init_memblock memblock_clear_nomap(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 0, MEMBLOCK_NOMAP);",
            "}",
            "int __init_memblock memblock_reserved_mark_noinit(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.reserved, base, size, 1,",
            "\t\t\t\t    MEMBLOCK_RSRV_NOINIT);",
            "}",
            "__init int memblock_mark_kho_scratch(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 1,",
            "\t\t\t\t    MEMBLOCK_KHO_SCRATCH);",
            "}",
            "__init int memblock_clear_kho_scratch(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 0,",
            "\t\t\t\t    MEMBLOCK_KHO_SCRATCH);",
            "}",
            "static bool should_skip_region(struct memblock_type *type,",
            "\t\t\t       struct memblock_region *m,",
            "\t\t\t       int nid, int flags)",
            "{",
            "\tint m_nid = memblock_get_region_node(m);",
            "",
            "\t/* we never skip regions when iterating memblock.reserved or physmem */",
            "\tif (type != memblock_memory)",
            "\t\treturn false;",
            "",
            "\t/* only memory regions are associated with nodes, check it */",
            "\tif (numa_valid_node(nid) && nid != m_nid)",
            "\t\treturn true;",
            "",
            "\t/* skip hotpluggable memory regions if needed */",
            "\tif (movable_node_is_enabled() && memblock_is_hotpluggable(m) &&",
            "\t    !(flags & MEMBLOCK_HOTPLUG))",
            "\t\treturn true;",
            "",
            "\t/* if we want mirror memory skip non-mirror memory regions */",
            "\tif ((flags & MEMBLOCK_MIRROR) && !memblock_is_mirror(m))",
            "\t\treturn true;",
            "",
            "\t/* skip nomap memory unless we were asked for it explicitly */",
            "\tif (!(flags & MEMBLOCK_NOMAP) && memblock_is_nomap(m))",
            "\t\treturn true;",
            "",
            "\t/* skip driver-managed memory unless we were asked for it explicitly */",
            "\tif (!(flags & MEMBLOCK_DRIVER_MANAGED) && memblock_is_driver_managed(m))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * In early alloc during kexec handover, we can only consider",
            "\t * MEMBLOCK_KHO_SCRATCH regions for the allocations",
            "\t */",
            "\tif ((flags & MEMBLOCK_KHO_SCRATCH) && !memblock_is_kho_scratch(m))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "void __next_mem_range(u64 *idx, int nid, enum memblock_flags flags,",
            "\t\t      struct memblock_type *type_a,",
            "\t\t      struct memblock_type *type_b, phys_addr_t *out_start,",
            "\t\t      phys_addr_t *out_end, int *out_nid)",
            "{",
            "\tint idx_a = *idx & 0xffffffff;",
            "\tint idx_b = *idx >> 32;",
            "",
            "\tfor (; idx_a < type_a->cnt; idx_a++) {",
            "\t\tstruct memblock_region *m = &type_a->regions[idx_a];",
            "",
            "\t\tphys_addr_t m_start = m->base;",
            "\t\tphys_addr_t m_end = m->base + m->size;",
            "\t\tint\t    m_nid = memblock_get_region_node(m);",
            "",
            "\t\tif (should_skip_region(type_a, m, nid, flags))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (!type_b) {",
            "\t\t\tif (out_start)",
            "\t\t\t\t*out_start = m_start;",
            "\t\t\tif (out_end)",
            "\t\t\t\t*out_end = m_end;",
            "\t\t\tif (out_nid)",
            "\t\t\t\t*out_nid = m_nid;",
            "\t\t\tidx_a++;",
            "\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t/* scan areas before each reservation */",
            "\t\tfor (; idx_b < type_b->cnt + 1; idx_b++) {",
            "\t\t\tstruct memblock_region *r;",
            "\t\t\tphys_addr_t r_start;",
            "\t\t\tphys_addr_t r_end;",
            "",
            "\t\t\tr = &type_b->regions[idx_b];",
            "\t\t\tr_start = idx_b ? r[-1].base + r[-1].size : 0;",
            "\t\t\tr_end = idx_b < type_b->cnt ?",
            "\t\t\t\tr->base : PHYS_ADDR_MAX;",
            "",
            "\t\t\t/*",
            "\t\t\t * if idx_b advanced past idx_a,",
            "\t\t\t * break out to advance idx_a",
            "\t\t\t */",
            "\t\t\tif (r_start >= m_end)",
            "\t\t\t\tbreak;",
            "\t\t\t/* if the two regions intersect, we're done */",
            "\t\t\tif (m_start < r_end) {",
            "\t\t\t\tif (out_start)",
            "\t\t\t\t\t*out_start =",
            "\t\t\t\t\t\tmax(m_start, r_start);",
            "\t\t\t\tif (out_end)",
            "\t\t\t\t\t*out_end = min(m_end, r_end);",
            "\t\t\t\tif (out_nid)",
            "\t\t\t\t\t*out_nid = m_nid;",
            "\t\t\t\t/*",
            "\t\t\t\t * The region which ends first is",
            "\t\t\t\t * advanced for the next iteration.",
            "\t\t\t\t */",
            "\t\t\t\tif (m_end <= r_end)",
            "\t\t\t\t\tidx_a++;",
            "\t\t\t\telse",
            "\t\t\t\t\tidx_b++;",
            "\t\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t/* signal end of iteration */",
            "\t*idx = ULLONG_MAX;",
            "}"
          ],
          "function_name": "memblock_mark_mirror, memblock_mark_nomap, memblock_clear_nomap, memblock_reserved_mark_noinit, memblock_mark_kho_scratch, memblock_clear_kho_scratch, should_skip_region, __next_mem_range",
          "description": "提供内存区域标记/清除接口，实现基于条件过滤的内存区域遍历逻辑，支持跳过特定属性（如非映射、非驱动管理等）的内存区域",
          "similarity": 0.5536611080169678
        },
        {
          "chunk_id": 5,
          "file_path": "mm/memblock.c",
          "start_line": 887,
          "end_line": 987,
          "content": [
            "int __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\", __func__,",
            "\t\t     &base, &end, (void *)_RET_IP_);",
            "",
            "\treturn memblock_remove_range(&memblock.memory, base, size);",
            "}",
            "void __init_memblock memblock_free(void *ptr, size_t size)",
            "{",
            "\tif (ptr)",
            "\t\tmemblock_phys_free(__pa(ptr), size);",
            "}",
            "int __init_memblock memblock_phys_free(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\", __func__,",
            "\t\t     &base, &end, (void *)_RET_IP_);",
            "",
            "\tkmemleak_free_part_phys(base, size);",
            "\treturn memblock_remove_range(&memblock.reserved, base, size);",
            "}",
            "int __init_memblock __memblock_reserve(phys_addr_t base, phys_addr_t size,",
            "\t\t\t\t       int nid, enum memblock_flags flags)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] nid=%d flags=%x %pS\\n\", __func__,",
            "\t\t     &base, &end, nid, flags, (void *)_RET_IP_);",
            "",
            "\treturn memblock_add_range(&memblock.reserved, base, size, nid, flags);",
            "}",
            "int __init_memblock memblock_physmem_add(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\", __func__,",
            "\t\t     &base, &end, (void *)_RET_IP_);",
            "",
            "\treturn memblock_add_range(&physmem, base, size, MAX_NUMNODES, 0);",
            "}",
            "__init void memblock_set_kho_scratch_only(void)",
            "{",
            "\tkho_scratch_only = true;",
            "}",
            "__init void memblock_clear_kho_scratch_only(void)",
            "{",
            "\tkho_scratch_only = false;",
            "}",
            "__init void memmap_init_kho_scratch_pages(void)",
            "{",
            "\tphys_addr_t start, end;",
            "\tunsigned long pfn;",
            "\tint nid;",
            "\tu64 i;",
            "",
            "\tif (!IS_ENABLED(CONFIG_DEFERRED_STRUCT_PAGE_INIT))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Initialize struct pages for free scratch memory.",
            "\t * The struct pages for reserved scratch memory will be set up in",
            "\t * reserve_bootmem_region()",
            "\t */",
            "\t__for_each_mem_range(i, &memblock.memory, NULL, NUMA_NO_NODE,",
            "\t\t\t     MEMBLOCK_KHO_SCRATCH, &start, &end, &nid) {",
            "\t\tfor (pfn = PFN_UP(start); pfn < PFN_DOWN(end); pfn++)",
            "\t\t\tinit_deferred_page(pfn, nid);",
            "\t}",
            "}",
            "static int __init_memblock memblock_setclr_flag(struct memblock_type *type,",
            "\t\t\t\tphys_addr_t base, phys_addr_t size, int set, int flag)",
            "{",
            "\tint i, ret, start_rgn, end_rgn;",
            "",
            "\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tfor (i = start_rgn; i < end_rgn; i++) {",
            "\t\tstruct memblock_region *r = &type->regions[i];",
            "",
            "\t\tif (set)",
            "\t\t\tr->flags |= flag;",
            "\t\telse",
            "\t\t\tr->flags &= ~flag;",
            "\t}",
            "",
            "\tmemblock_merge_regions(type, start_rgn, end_rgn);",
            "\treturn 0;",
            "}",
            "int __init_memblock memblock_mark_hotplug(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 1, MEMBLOCK_HOTPLUG);",
            "}",
            "int __init_memblock memblock_clear_hotplug(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 0, MEMBLOCK_HOTPLUG);",
            "}"
          ],
          "function_name": "memblock_remove, memblock_free, memblock_phys_free, __memblock_reserve, memblock_physmem_add, memblock_set_kho_scratch_only, memblock_clear_kho_scratch_only, memmap_init_kho_scratch_pages, memblock_setclr_flag, memblock_mark_hotplug, memblock_clear_hotplug",
          "description": "定义并实现内存块操作函数，用于移除/释放内存区域，标记预留内存属性，初始化KHO_SCRATCH页结构，并通过memblock_setclr_flag修改内存区域标志位，支持热插拔、镜像等特性",
          "similarity": 0.5535932183265686
        }
      ]
    },
    {
      "source_file": "mm/list_lru.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:35:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `list_lru.c`\n\n---\n\n# list_lru.c 技术文档\n\n## 1. 文件概述\n\n`list_lru.c` 实现了 Linux 内核中通用的 **List-based LRU（Least Recently Used）基础设施**，用于管理可回收对象的双向链表。该机制支持按 NUMA 节点（node）和内存控制组（memcg）进行细粒度组织，便于内存压力下的高效回收。主要服务于 slab 分配器等子系统，作为 shrinker 框架的一部分，在内存紧张时协助释放非活跃对象。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct list_lru`：顶层 LRU 管理结构，包含 per-node 的 `list_lru_node`\n- `struct list_lru_node`：每个 NUMA 节点对应的 LRU 节点，含自旋锁和总项数\n- `struct list_lru_one`：实际存储对象链表和计数的单元（per-memcg per-node）\n- `struct list_lru_memcg`：当启用 `CONFIG_MEMCG` 时，为每个 memcg 存储 per-node 的 `list_lru_one`\n\n### 主要导出函数\n- `list_lru_add()` / `list_lru_add_obj()`：向 LRU 添加对象\n- `list_lru_del()` / `list_lru_del_obj()`：从 LRU 删除对象\n- `list_lru_isolate()` / `list_lru_isolate_move()`：在回收过程中隔离对象\n- `list_lru_count_one()` / `list_lru_count_node()`：查询 LRU 中对象数量\n- `list_lru_walk_one()` / `list_lru_walk_node()`：遍历并处理 LRU 中的对象（用于 shrinker 回调）\n\n### 内部辅助函数\n- `list_lru_from_memcg_idx()`：根据 memcg ID 获取对应的 `list_lru_one`\n- `__list_lru_walk_one()`：带锁的 LRU 遍历核心逻辑\n- `list_lru_register()` / `list_lru_unregister()`：注册/注销 memcg-aware 的 LRU（用于全局追踪）\n\n## 3. 关键实现\n\n### 内存控制组（memcg）支持\n- 通过 `CONFIG_MEMCG` 条件编译控制 memcg 相关逻辑\n- 使用 XArray (`lru->xa`) 动态存储每个 memcg 对应的 `list_lru_memcg` 结构\n- 每个 memcg 在每个 NUMA 节点上拥有独立的 `list_lru_one`，实现资源隔离\n- 全局 `memcg_list_lrus` 链表和 `list_lrus_mutex` 用于跟踪所有 memcg-aware 的 LRU 实例\n\n### 并发控制\n- 每个 NUMA 节点 (`list_lru_node`) 拥有独立的自旋锁 (`nlru->lock`)\n- 所有对 LRU 链表的操作（增、删、遍历）均在对应节点锁保护下进行\n- 提供 `_irq` 版本的遍历函数（`list_lru_walk_one_irq`）用于中断上下文\n\n### 回收遍历机制\n- `list_lru_walk_*` 函数接受回调函数 `isolate`，由调用者定义回收策略\n- 回调返回值控制遍历行为：\n  - `LRU_REMOVED`：成功移除\n  - `LRU_REMOVED_RETRY`：移除后需重新开始遍历（锁曾被释放）\n  - `LRU_RETRY`：未移除但需重新开始遍历\n  - `LRU_ROTATE`：将对象移到链表尾部（标记为最近使用）\n  - `LRU_SKIP`：跳过当前对象\n  - `LRU_STOP`：立即停止遍历\n- 通过 `nr_to_walk` 限制单次遍历的最大对象数，防止长时间持锁\n\n### Shrinker 集成\n- 当向空的 `list_lru_one` 添加首个对象时，调用 `set_shrinker_bit()` 标记该 memcg/node 需要被 shrinker 处理\n- `lru_shrinker_id()` 返回关联的 shrinker ID，用于通知内存回收子系统\n\n### 对象归属识别\n- `list_lru_add_obj()` / `list_lru_del_obj()` 通过 `mem_cgroup_from_slab_obj()` 自动获取对象所属的 memcg\n- 使用 `page_to_nid(virt_to_page(item))` 确定对象所在的 NUMA 节点\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/list_lru.h>`：定义核心数据结构和 API\n  - `<linux/memcontrol.h>`：memcg 相关接口（如 `memcg_kmem_id`）\n  - `\"slab.h\"` 和 `\"internal.h\"`：slab 分配器内部接口（如 `mem_cgroup_from_slab_obj`）\n- **配置依赖**：\n  - `CONFIG_MEMCG`：决定是否编译 memcg 相关代码\n  - `CONFIG_NUMA`：影响 per-node 数据结构的大小（通过 `nr_node_ids`）\n- **子系统依赖**：\n  - Slab 分配器：作为主要使用者，管理可回收 slab 对象\n  - Memory Control Group (memcg)：提供内存隔离和记账\n  - Shrinker 框架：通过 shrinker 回调触发 LRU 遍历回收\n\n## 5. 使用场景\n\n- **Slab 对象回收**：当系统内存压力大时，shrinker 通过 `list_lru_walk_*` 遍历 inactive slab 对象链表，释放可回收对象\n- **Per-memcg 内存限制**：在 cgroup 内存超限时，仅遍历该 memcg 对应的 LRU 部分，实现精确回收\n- **NUMA 感知管理**：按 NUMA 节点分离 LRU 链表，减少远程内存访问，提升性能\n- **通用 LRU 容器**：任何需要按 LRU 策略管理可回收对象的内核子系统均可使用此基础设施（如 dentry、inode 缓存等）",
      "similarity": 0.5874063372612,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "mm/list_lru.c",
          "start_line": 556,
          "end_line": 605,
          "content": [
            "static inline void memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)",
            "{",
            "}",
            "static void memcg_destroy_list_lru(struct list_lru *lru)",
            "{",
            "}",
            "int __list_lru_init(struct list_lru *lru, bool memcg_aware,",
            "\t\t    struct lock_class_key *key, struct shrinker *shrinker)",
            "{",
            "\tint i;",
            "",
            "#ifdef CONFIG_MEMCG",
            "\tif (shrinker)",
            "\t\tlru->shrinker_id = shrinker->id;",
            "\telse",
            "\t\tlru->shrinker_id = -1;",
            "#endif",
            "",
            "\tlru->node = kcalloc(nr_node_ids, sizeof(*lru->node), GFP_KERNEL);",
            "\tif (!lru->node)",
            "\t\treturn -ENOMEM;",
            "",
            "\tfor_each_node(i) {",
            "\t\tspin_lock_init(&lru->node[i].lock);",
            "\t\tif (key)",
            "\t\t\tlockdep_set_class(&lru->node[i].lock, key);",
            "\t\tinit_one_lru(&lru->node[i].lru);",
            "\t}",
            "",
            "\tmemcg_init_list_lru(lru, memcg_aware);",
            "\tlist_lru_register(lru);",
            "",
            "\treturn 0;",
            "}",
            "void list_lru_destroy(struct list_lru *lru)",
            "{",
            "\t/* Already destroyed or not yet initialized? */",
            "\tif (!lru->node)",
            "\t\treturn;",
            "",
            "\tlist_lru_unregister(lru);",
            "",
            "\tmemcg_destroy_list_lru(lru);",
            "\tkfree(lru->node);",
            "\tlru->node = NULL;",
            "",
            "#ifdef CONFIG_MEMCG",
            "\tlru->shrinker_id = -1;",
            "#endif",
            "}"
          ],
          "function_name": "memcg_init_list_lru, memcg_destroy_list_lru, __list_lru_init, list_lru_destroy",
          "description": "该代码段实现了基于内存控制组（MEMCG）的LRU列表管理功能。  \n`__list_lru_init` 初始化 `list_lru` 结构体并注册到系统，其中包含 MEMCG 相关的 shrinker ID 设置及节点锁初始化；`list_lru_destroy` 反向清理资源，但 `memcg_init_list_lru` 和 `memcg_destroy_list_lru` 的具体实现缺失，上下文不完整。",
          "similarity": 0.5570969581604004
        },
        {
          "chunk_id": 3,
          "file_path": "mm/list_lru.c",
          "start_line": 289,
          "end_line": 400,
          "content": [
            "unsigned long",
            "list_lru_walk_one_irq(struct list_lru *lru, int nid, struct mem_cgroup *memcg,",
            "\t\t      list_lru_walk_cb isolate, void *cb_arg,",
            "\t\t      unsigned long *nr_to_walk)",
            "{",
            "\tstruct list_lru_node *nlru = &lru->node[nid];",
            "\tunsigned long ret;",
            "",
            "\tspin_lock_irq(&nlru->lock);",
            "\tret = __list_lru_walk_one(lru, nid, memcg_kmem_id(memcg), isolate,",
            "\t\t\t\t  cb_arg, nr_to_walk);",
            "\tspin_unlock_irq(&nlru->lock);",
            "\treturn ret;",
            "}",
            "unsigned long list_lru_walk_node(struct list_lru *lru, int nid,",
            "\t\t\t\t list_lru_walk_cb isolate, void *cb_arg,",
            "\t\t\t\t unsigned long *nr_to_walk)",
            "{",
            "\tlong isolated = 0;",
            "",
            "\tisolated += list_lru_walk_one(lru, nid, NULL, isolate, cb_arg,",
            "\t\t\t\t      nr_to_walk);",
            "",
            "#ifdef CONFIG_MEMCG",
            "\tif (*nr_to_walk > 0 && list_lru_memcg_aware(lru)) {",
            "\t\tstruct list_lru_memcg *mlru;",
            "\t\tunsigned long index;",
            "",
            "\t\txa_for_each(&lru->xa, index, mlru) {",
            "\t\t\tstruct list_lru_node *nlru = &lru->node[nid];",
            "",
            "\t\t\tspin_lock(&nlru->lock);",
            "\t\t\tisolated += __list_lru_walk_one(lru, nid, index,",
            "\t\t\t\t\t\t\tisolate, cb_arg,",
            "\t\t\t\t\t\t\tnr_to_walk);",
            "\t\t\tspin_unlock(&nlru->lock);",
            "",
            "\t\t\tif (*nr_to_walk <= 0)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "#endif",
            "",
            "\treturn isolated;",
            "}",
            "static void init_one_lru(struct list_lru_one *l)",
            "{",
            "\tINIT_LIST_HEAD(&l->list);",
            "\tl->nr_items = 0;",
            "}",
            "static void memcg_list_lru_free(struct list_lru *lru, int src_idx)",
            "{",
            "\tstruct list_lru_memcg *mlru = xa_erase_irq(&lru->xa, src_idx);",
            "",
            "\t/*",
            "\t * The __list_lru_walk_one() can walk the list of this node.",
            "\t * We need kvfree_rcu() here. And the walking of the list",
            "\t * is under lru->node[nid]->lock, which can serve as a RCU",
            "\t * read-side critical section.",
            "\t */",
            "\tif (mlru)",
            "\t\tkvfree_rcu(mlru, rcu);",
            "}",
            "static inline void memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)",
            "{",
            "\tif (memcg_aware)",
            "\t\txa_init_flags(&lru->xa, XA_FLAGS_LOCK_IRQ);",
            "\tlru->memcg_aware = memcg_aware;",
            "}",
            "static void memcg_destroy_list_lru(struct list_lru *lru)",
            "{",
            "\tXA_STATE(xas, &lru->xa, 0);",
            "\tstruct list_lru_memcg *mlru;",
            "",
            "\tif (!list_lru_memcg_aware(lru))",
            "\t\treturn;",
            "",
            "\txas_lock_irq(&xas);",
            "\txas_for_each(&xas, mlru, ULONG_MAX) {",
            "\t\tkfree(mlru);",
            "\t\txas_store(&xas, NULL);",
            "\t}",
            "\txas_unlock_irq(&xas);",
            "}",
            "static void memcg_reparent_list_lru_node(struct list_lru *lru, int nid,",
            "\t\t\t\t\t int src_idx, struct mem_cgroup *dst_memcg)",
            "{",
            "\tstruct list_lru_node *nlru = &lru->node[nid];",
            "\tint dst_idx = dst_memcg->kmemcg_id;",
            "\tstruct list_lru_one *src, *dst;",
            "",
            "\t/*",
            "\t * Since list_lru_{add,del} may be called under an IRQ-safe lock,",
            "\t * we have to use IRQ-safe primitives here to avoid deadlock.",
            "\t */",
            "\tspin_lock_irq(&nlru->lock);",
            "",
            "\tsrc = list_lru_from_memcg_idx(lru, nid, src_idx);",
            "\tif (!src)",
            "\t\tgoto out;",
            "\tdst = list_lru_from_memcg_idx(lru, nid, dst_idx);",
            "",
            "\tlist_splice_init(&src->list, &dst->list);",
            "",
            "\tif (src->nr_items) {",
            "\t\tdst->nr_items += src->nr_items;",
            "\t\tset_shrinker_bit(dst_memcg, nid, lru_shrinker_id(lru));",
            "\t\tsrc->nr_items = 0;",
            "\t}",
            "out:",
            "\tspin_unlock_irq(&nlru->lock);",
            "}"
          ],
          "function_name": "list_lru_walk_one_irq, list_lru_walk_node, init_one_lru, memcg_list_lru_free, memcg_init_list_lru, memcg_destroy_list_lru, memcg_reparent_list_lru_node",
          "description": "包含LRU节点初始化、内存组间列表迁移、资源释放等高级操作，涉及XA表管理、中断安全锁操作及内存组重新归属处理。",
          "similarity": 0.5462291240692139
        },
        {
          "chunk_id": 1,
          "file_path": "mm/list_lru.c",
          "start_line": 22,
          "end_line": 129,
          "content": [
            "static inline bool list_lru_memcg_aware(struct list_lru *lru)",
            "{",
            "\treturn lru->memcg_aware;",
            "}",
            "static void list_lru_register(struct list_lru *lru)",
            "{",
            "\tif (!list_lru_memcg_aware(lru))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&list_lrus_mutex);",
            "\tlist_add(&lru->list, &memcg_list_lrus);",
            "\tmutex_unlock(&list_lrus_mutex);",
            "}",
            "static void list_lru_unregister(struct list_lru *lru)",
            "{",
            "\tif (!list_lru_memcg_aware(lru))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&list_lrus_mutex);",
            "\tlist_del(&lru->list);",
            "\tmutex_unlock(&list_lrus_mutex);",
            "}",
            "static int lru_shrinker_id(struct list_lru *lru)",
            "{",
            "\treturn lru->shrinker_id;",
            "}",
            "static void list_lru_register(struct list_lru *lru)",
            "{",
            "}",
            "static void list_lru_unregister(struct list_lru *lru)",
            "{",
            "}",
            "static int lru_shrinker_id(struct list_lru *lru)",
            "{",
            "\treturn -1;",
            "}",
            "static inline bool list_lru_memcg_aware(struct list_lru *lru)",
            "{",
            "\treturn false;",
            "}",
            "bool list_lru_add(struct list_lru *lru, struct list_head *item, int nid,",
            "\t\t    struct mem_cgroup *memcg)",
            "{",
            "\tstruct list_lru_node *nlru = &lru->node[nid];",
            "\tstruct list_lru_one *l;",
            "",
            "\tspin_lock(&nlru->lock);",
            "\tif (list_empty(item)) {",
            "\t\tl = list_lru_from_memcg_idx(lru, nid, memcg_kmem_id(memcg));",
            "\t\tlist_add_tail(item, &l->list);",
            "\t\t/* Set shrinker bit if the first element was added */",
            "\t\tif (!l->nr_items++)",
            "\t\t\tset_shrinker_bit(memcg, nid, lru_shrinker_id(lru));",
            "\t\tnlru->nr_items++;",
            "\t\tspin_unlock(&nlru->lock);",
            "\t\treturn true;",
            "\t}",
            "\tspin_unlock(&nlru->lock);",
            "\treturn false;",
            "}",
            "bool list_lru_add_obj(struct list_lru *lru, struct list_head *item)",
            "{",
            "\tbool ret;",
            "\tint nid = page_to_nid(virt_to_page(item));",
            "",
            "\tif (list_lru_memcg_aware(lru)) {",
            "\t\trcu_read_lock();",
            "\t\tret = list_lru_add(lru, item, nid, mem_cgroup_from_slab_obj(item));",
            "\t\trcu_read_unlock();",
            "\t} else {",
            "\t\tret = list_lru_add(lru, item, nid, NULL);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "bool list_lru_del(struct list_lru *lru, struct list_head *item, int nid,",
            "\t\t    struct mem_cgroup *memcg)",
            "{",
            "\tstruct list_lru_node *nlru = &lru->node[nid];",
            "\tstruct list_lru_one *l;",
            "",
            "\tspin_lock(&nlru->lock);",
            "\tif (!list_empty(item)) {",
            "\t\tl = list_lru_from_memcg_idx(lru, nid, memcg_kmem_id(memcg));",
            "\t\tlist_del_init(item);",
            "\t\tl->nr_items--;",
            "\t\tnlru->nr_items--;",
            "\t\tspin_unlock(&nlru->lock);",
            "\t\treturn true;",
            "\t}",
            "\tspin_unlock(&nlru->lock);",
            "\treturn false;",
            "}",
            "bool list_lru_del_obj(struct list_lru *lru, struct list_head *item)",
            "{",
            "\tbool ret;",
            "\tint nid = page_to_nid(virt_to_page(item));",
            "",
            "\tif (list_lru_memcg_aware(lru)) {",
            "\t\trcu_read_lock();",
            "\t\tret = list_lru_del(lru, item, nid, mem_cgroup_from_slab_obj(item));",
            "\t\trcu_read_unlock();",
            "\t} else {",
            "\t\tret = list_lru_del(lru, item, nid, NULL);",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "list_lru_memcg_aware, list_lru_register, list_lru_unregister, lru_shrinker_id, list_lru_register, list_lru_unregister, lru_shrinker_id, list_lru_memcg_aware, list_lru_add, list_lru_add_obj, list_lru_del, list_lru_del_obj",
          "description": "实现了LRU列表的添加/删除操作，支持MemCG感知的节点和内存组粒度管理，包含处理多核、内存组切换及RCU安全访问的逻辑。",
          "similarity": 0.5374104976654053
        },
        {
          "chunk_id": 0,
          "file_path": "mm/list_lru.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2013 Red Hat, Inc. and Parallels Inc. All rights reserved.",
            " * Authors: David Chinner and Glauber Costa",
            " *",
            " * Generic LRU infrastructure",
            " */",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/memcontrol.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "",
            "#ifdef CONFIG_MEMCG",
            "static LIST_HEAD(memcg_list_lrus);",
            "static DEFINE_MUTEX(list_lrus_mutex);",
            ""
          ],
          "function_name": null,
          "description": "定义了支持内存控制组（MemCG）的LRU基础设施，声明了全局链表头memcg_list_lrus和互斥锁list_lrus_mutex，用于管理MemCG环境下的LRU列表注册与注销操作。",
          "similarity": 0.5373259782791138
        },
        {
          "chunk_id": 4,
          "file_path": "mm/list_lru.c",
          "start_line": 425,
          "end_line": 551,
          "content": [
            "static void memcg_reparent_list_lru(struct list_lru *lru,",
            "\t\t\t\t    int src_idx, struct mem_cgroup *dst_memcg)",
            "{",
            "\tint i;",
            "",
            "\tfor_each_node(i)",
            "\t\tmemcg_reparent_list_lru_node(lru, i, src_idx, dst_memcg);",
            "",
            "\tmemcg_list_lru_free(lru, src_idx);",
            "}",
            "void memcg_reparent_list_lrus(struct mem_cgroup *memcg, struct mem_cgroup *parent)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct list_lru *lru;",
            "\tint src_idx = memcg->kmemcg_id;",
            "",
            "\t/*",
            "\t * Change kmemcg_id of this cgroup and all its descendants to the",
            "\t * parent's id, and then move all entries from this cgroup's list_lrus",
            "\t * to ones of the parent.",
            "\t *",
            "\t * After we have finished, all list_lrus corresponding to this cgroup",
            "\t * are guaranteed to remain empty. So we can safely free this cgroup's",
            "\t * list lrus in memcg_list_lru_free().",
            "\t *",
            "\t * Changing ->kmemcg_id to the parent can prevent memcg_list_lru_alloc()",
            "\t * from allocating list lrus for this cgroup after memcg_list_lru_free()",
            "\t * call.",
            "\t */",
            "\trcu_read_lock();",
            "\tcss_for_each_descendant_pre(css, &memcg->css) {",
            "\t\tstruct mem_cgroup *child;",
            "",
            "\t\tchild = mem_cgroup_from_css(css);",
            "\t\tWRITE_ONCE(child->kmemcg_id, parent->kmemcg_id);",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\tmutex_lock(&list_lrus_mutex);",
            "\tlist_for_each_entry(lru, &memcg_list_lrus, list)",
            "\t\tmemcg_reparent_list_lru(lru, src_idx, parent);",
            "\tmutex_unlock(&list_lrus_mutex);",
            "}",
            "static inline bool memcg_list_lru_allocated(struct mem_cgroup *memcg,",
            "\t\t\t\t\t    struct list_lru *lru)",
            "{",
            "\tint idx = memcg->kmemcg_id;",
            "",
            "\treturn idx < 0 || xa_load(&lru->xa, idx);",
            "}",
            "int memcg_list_lru_alloc(struct mem_cgroup *memcg, struct list_lru *lru,",
            "\t\t\t gfp_t gfp)",
            "{",
            "\tint i;",
            "\tunsigned long flags;",
            "\tstruct list_lru_memcg_table {",
            "\t\tstruct list_lru_memcg *mlru;",
            "\t\tstruct mem_cgroup *memcg;",
            "\t} *table;",
            "\tXA_STATE(xas, &lru->xa, 0);",
            "",
            "\tif (!list_lru_memcg_aware(lru) || memcg_list_lru_allocated(memcg, lru))",
            "\t\treturn 0;",
            "",
            "\tgfp &= GFP_RECLAIM_MASK;",
            "\ttable = kmalloc_array(memcg->css.cgroup->level, sizeof(*table), gfp);",
            "\tif (!table)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/*",
            "\t * Because the list_lru can be reparented to the parent cgroup's",
            "\t * list_lru, we should make sure that this cgroup and all its",
            "\t * ancestors have allocated list_lru_memcg.",
            "\t */",
            "\tfor (i = 0; memcg; memcg = parent_mem_cgroup(memcg), i++) {",
            "\t\tif (memcg_list_lru_allocated(memcg, lru))",
            "\t\t\tbreak;",
            "",
            "\t\ttable[i].memcg = memcg;",
            "\t\ttable[i].mlru = memcg_init_list_lru_one(gfp);",
            "\t\tif (!table[i].mlru) {",
            "\t\t\twhile (i--)",
            "\t\t\t\tkfree(table[i].mlru);",
            "\t\t\tkfree(table);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "\t}",
            "",
            "\txas_lock_irqsave(&xas, flags);",
            "\twhile (i--) {",
            "\t\tint index = READ_ONCE(table[i].memcg->kmemcg_id);",
            "\t\tstruct list_lru_memcg *mlru = table[i].mlru;",
            "",
            "\t\txas_set(&xas, index);",
            "retry:",
            "\t\tif (unlikely(index < 0 || xas_error(&xas) || xas_load(&xas))) {",
            "\t\t\tkfree(mlru);",
            "\t\t} else {",
            "\t\t\txas_store(&xas, mlru);",
            "\t\t\tif (xas_error(&xas) == -ENOMEM) {",
            "\t\t\t\txas_unlock_irqrestore(&xas, flags);",
            "\t\t\t\tif (xas_nomem(&xas, gfp))",
            "\t\t\t\t\txas_set_err(&xas, 0);",
            "\t\t\t\txas_lock_irqsave(&xas, flags);",
            "\t\t\t\t/*",
            "\t\t\t\t * The xas lock has been released, this memcg",
            "\t\t\t\t * can be reparented before us. So reload",
            "\t\t\t\t * memcg id. More details see the comments",
            "\t\t\t\t * in memcg_reparent_list_lrus().",
            "\t\t\t\t */",
            "\t\t\t\tindex = READ_ONCE(table[i].memcg->kmemcg_id);",
            "\t\t\t\tif (index < 0)",
            "\t\t\t\t\txas_set_err(&xas, 0);",
            "\t\t\t\telse if (!xas_error(&xas) && index != xas.xa_index)",
            "\t\t\t\t\txas_set(&xas, index);",
            "\t\t\t\tgoto retry;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t/* xas_nomem() is used to free memory instead of memory allocation. */",
            "\tif (xas.xa_alloc)",
            "\t\txas_nomem(&xas, gfp);",
            "\txas_unlock_irqrestore(&xas, flags);",
            "\tkfree(table);",
            "",
            "\treturn xas_error(&xas);",
            "}"
          ],
          "function_name": "memcg_reparent_list_lru, memcg_reparent_list_lrus, memcg_list_lru_allocated, memcg_list_lru_alloc",
          "description": "实现内存组层级间的LRU列表迁移与分配机制，包含递归子组处理、动态分配/释放LRU结构体及冲突解决逻辑。",
          "similarity": 0.5243511199951172
        }
      ]
    },
    {
      "source_file": "kernel/resource.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:53:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `resource.c`\n\n---\n\n# resource.c 技术文档\n\n## 1. 文件概述\n\n`resource.c` 是 Linux 内核中用于管理和分配系统资源（如 I/O 端口和内存区域）的核心实现文件。它提供了一套通用的资源树管理机制，支持资源的申请、释放、查找和冲突检测。该文件维护了两个全局根资源节点：`ioport_resource`（用于 I/O 端口空间）和 `iomem_resource`（用于内存映射 I/O 空间），并通过树形结构组织所有已分配的子资源，确保资源分配的唯一性和安全性。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `struct resource ioport_resource`：I/O 端口资源的根节点，范围为 `[0, IO_SPACE_LIMIT]`，标志为 `IORESOURCE_IO`。\n- `struct resource iomem_resource`：内存映射 I/O 资源的根节点，范围为 `[0, -1]`（即全地址空间），标志为 `IORESOURCE_MEM`。\n- `struct resource_constraint`：用于描述资源分配时的约束条件（最小/最大地址、对齐要求及自定义对齐函数）。\n\n### 关键函数\n- `request_resource(struct resource *root, struct resource *new)`：尝试在指定根资源下申请一段新资源，成功返回 0，冲突返回 `-EBUSY`。\n- `request_resource_conflict(...)`：与 `request_resource` 类似，但冲突时直接返回冲突的资源指针。\n- `release_resource(struct resource *old)`：释放已分配的资源。\n- `release_child_resources(struct resource *r)`：递归释放指定资源的所有子资源。\n- `find_next_iomem_res(...)`：在 `iomem_resource` 树中查找与指定区间 `[start, end]` 重叠且满足标志和描述符条件的下一个内存资源。\n- `for_each_resource` 宏：遍历资源树的通用宏，支持是否跳过子树的选项。\n\n### /proc 接口（条件编译）\n- 通过 `CONFIG_PROC_FS` 启用时，注册 `/proc/ioports` 和 `/proc/iomem` 文件，以树形格式展示当前系统中已分配的 I/O 端口和内存资源（仅对 `CAP_SYS_ADMIN` 权限用户显示实际地址）。\n\n## 3. 关键实现\n\n### 资源树结构\n- 资源以多叉树形式组织，每个 `struct resource` 包含 `child`（第一个子节点）、`sibling`（下一个兄弟节点）和 `parent` 指针。\n- 树内节点按起始地址升序排列，便于快速查找和插入。\n\n### 资源申请（`__request_resource`）\n- 在持有写锁 `resource_lock` 的前提下，遍历根节点的子链表。\n- 若新资源与现有节点无重叠，则按地址顺序插入；若存在重叠，则返回冲突节点。\n- 插入操作维护树的有序性：新节点插入到第一个起始地址大于其结束地址的节点之前。\n\n### 资源释放（`__release_resource`）\n- 支持两种模式：完全释放（含子资源）或仅提升子资源（当 `release_child=false` 时，将子节点直接挂到父节点下）。\n- 释放时调整兄弟链表指针，确保树结构完整性。\n\n### 资源遍历\n- `next_resource()`：深度优先遍历（先子节点，再兄弟节点）。\n- `next_resource_skip_children()`：仅遍历同级兄弟节点，跳过子树。\n- `/proc` 显示使用深度优先遍历，并限制最大显示层级（`MAX_IORES_LEVEL=5`）以避免过深嵌套。\n\n### 内存管理\n- 资源结构体通过 `alloc_resource()`（即 `kzalloc`）分配，通过 `free_resource()` 释放。\n- 注释指出：若资源由早期 `memblock` 分配，则无法安全释放（因非页对齐），会轻微泄漏，这是有意为之的简化设计。\n\n### 并发控制\n- 使用读写锁 `resource_lock` 保护全局资源树：\n  - 读操作（如 `/proc` 显示、`find_next_iomem_res`）使用 `read_lock`。\n  - 写操作（申请/释放资源）使用 `write_lock`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ioport.h>`：定义 `struct resource` 及相关宏（如 `IORESOURCE_IO`）。\n  - `<linux/proc_fs.h>`、`<linux/seq_file.h>`：实现 `/proc` 接口。\n  - `<linux/slab.h>`：资源结构体的动态分配。\n  - `<linux/spinlock.h>`：读写锁 `resource_lock` 的实现。\n  - `<asm/io.h>`：架构相关的 I/O 定义（如 `IO_SPACE_LIMIT`）。\n- **导出符号**：\n  - `ioport_resource`、`iomem_resource`、`request_resource`、`release_resource` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如 PCI、platform_device 驱动）使用。\n- **配置依赖**：\n  - `/proc` 接口依赖 `CONFIG_PROC_FS`。\n\n## 5. 使用场景\n\n- **设备驱动资源管理**：PCI、platform 等总线驱动在探测设备时，调用 `request_resource()` 申请 I/O 端口或内存区域，防止资源冲突。\n- **固件/ACPI 资源解析**：内核解析 ACPI 表或 EFI 内存映射时，将保留区域注册到 `iomem_resource` 树中。\n- **系统调试与监控**：用户空间通过 `/proc/ioports` 和 `/proc/iomem` 查看硬件资源分配情况（需 root 权限）。\n- **内核子系统协作**：内存管理子系统（如 `devm_request_mem_region`）、DMA 引擎等依赖此机制确保物理地址资源的独占使用。\n- **热插拔支持**：设备移除时调用 `release_resource()` 释放资源，供后续设备重用。",
      "similarity": 0.5874011516571045,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/resource.c",
          "start_line": 492,
          "end_line": 601,
          "content": [
            "int walk_mem_res(u64 start, u64 end, void *arg,",
            "\t\t int (*func)(struct resource *, void *))",
            "{",
            "\tunsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;",
            "",
            "\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,",
            "\t\t\t\t     func);",
            "}",
            "int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,",
            "\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))",
            "{",
            "\tresource_size_t start, end;",
            "\tunsigned long flags;",
            "\tstruct resource res;",
            "\tunsigned long pfn, end_pfn;",
            "\tint ret = -EINVAL;",
            "",
            "\tstart = (u64) start_pfn << PAGE_SHIFT;",
            "\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;",
            "\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;",
            "\twhile (start < end &&",
            "\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res)) {",
            "\t\tpfn = PFN_UP(res.start);",
            "\t\tend_pfn = PFN_DOWN(res.end + 1);",
            "\t\tif (end_pfn > pfn)",
            "\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t\tstart = res.end + 1;",
            "\t}",
            "\treturn ret;",
            "}",
            "static int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)",
            "{",
            "\treturn 1;",
            "}",
            "int __weak page_is_ram(unsigned long pfn)",
            "{",
            "\treturn walk_system_ram_range(pfn, 1, NULL, __is_ram) == 1;",
            "}",
            "static int __region_intersects(struct resource *parent, resource_size_t start,",
            "\t\t\t       size_t size, unsigned long flags,",
            "\t\t\t       unsigned long desc)",
            "{",
            "\tresource_size_t ostart, oend;",
            "\tint type = 0; int other = 0;",
            "\tstruct resource *p, *dp;",
            "\tbool is_type, covered;",
            "\tstruct resource res;",
            "",
            "\tres.start = start;",
            "\tres.end = start + size - 1;",
            "",
            "\tfor (p = parent->child; p ; p = p->sibling) {",
            "\t\tif (!resource_overlaps(p, &res))",
            "\t\t\tcontinue;",
            "\t\tis_type = (p->flags & flags) == flags &&",
            "\t\t\t(desc == IORES_DESC_NONE || desc == p->desc);",
            "\t\tif (is_type) {",
            "\t\t\ttype++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Continue to search in descendant resources as if the",
            "\t\t * matched descendant resources cover some ranges of 'p'.",
            "\t\t *",
            "\t\t * |------------- \"CXL Window 0\" ------------|",
            "\t\t * |-- \"System RAM\" --|",
            "\t\t *",
            "\t\t * will behave similar as the following fake resource",
            "\t\t * tree when searching \"System RAM\".",
            "\t\t *",
            "\t\t * |-- \"System RAM\" --||-- \"CXL Window 0a\" --|",
            "\t\t */",
            "\t\tcovered = false;",
            "\t\tostart = max(res.start, p->start);",
            "\t\toend = min(res.end, p->end);",
            "\t\tfor_each_resource(p, dp, false) {",
            "\t\t\tif (!resource_overlaps(dp, &res))",
            "\t\t\t\tcontinue;",
            "\t\t\tis_type = (dp->flags & flags) == flags &&",
            "\t\t\t\t(desc == IORES_DESC_NONE || desc == dp->desc);",
            "\t\t\tif (is_type) {",
            "\t\t\t\ttype++;",
            "\t\t\t\t/*",
            "\t\t\t\t * Range from 'ostart' to 'dp->start'",
            "\t\t\t\t * isn't covered by matched resource.",
            "\t\t\t\t */",
            "\t\t\t\tif (dp->start > ostart)",
            "\t\t\t\t\tbreak;",
            "\t\t\t\tif (dp->end >= oend) {",
            "\t\t\t\t\tcovered = true;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\t/* Remove covered range */",
            "\t\t\t\tostart = max(ostart, dp->end + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (!covered)",
            "\t\t\tother++;",
            "\t}",
            "",
            "\tif (type == 0)",
            "\t\treturn REGION_DISJOINT;",
            "",
            "\tif (other == 0)",
            "\t\treturn REGION_INTERSECTS;",
            "",
            "\treturn REGION_MIXED;",
            "}"
          ],
          "function_name": "walk_mem_res, walk_system_ram_range, __is_ram, page_is_ram, __region_intersects",
          "description": "提供内存资源遍历接口，将物理地址转换为资源结构进行处理，包含判断内存区域是否为RAM的弱符号实现及区域交集检测逻辑。",
          "similarity": 0.5901389122009277
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/resource.c",
          "start_line": 802,
          "end_line": 912,
          "content": [
            "int allocate_resource(struct resource *root, struct resource *new,",
            "\t\t      resource_size_t size, resource_size_t min,",
            "\t\t      resource_size_t max, resource_size_t align,",
            "\t\t      resource_size_t (*alignf)(void *,",
            "\t\t\t\t\t\tconst struct resource *,",
            "\t\t\t\t\t\tresource_size_t,",
            "\t\t\t\t\t\tresource_size_t),",
            "\t\t      void *alignf_data)",
            "{",
            "\tint err;",
            "\tstruct resource_constraint constraint;",
            "",
            "\tif (!alignf)",
            "\t\talignf = simple_align_resource;",
            "",
            "\tconstraint.min = min;",
            "\tconstraint.max = max;",
            "\tconstraint.align = align;",
            "\tconstraint.alignf = alignf;",
            "\tconstraint.alignf_data = alignf_data;",
            "",
            "\tif ( new->parent ) {",
            "\t\t/* resource is already allocated, try reallocating with",
            "\t\t   the new constraints */",
            "\t\treturn reallocate_resource(root, new, size, &constraint);",
            "\t}",
            "",
            "\twrite_lock(&resource_lock);",
            "\terr = find_resource(root, new, size, &constraint);",
            "\tif (err >= 0 && __request_resource(root, new))",
            "\t\terr = -EBUSY;",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}",
            "int insert_resource(struct resource *parent, struct resource *new)",
            "{",
            "\tstruct resource *conflict;",
            "",
            "\tconflict = insert_resource_conflict(parent, new);",
            "\treturn conflict ? -EBUSY : 0;",
            "}",
            "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)",
            "{",
            "\tif (new->parent)",
            "\t\treturn;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tconflict = __insert_resource(root, new);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\tif (conflict == root)",
            "\t\t\tbreak;",
            "",
            "\t\t/* Ok, expand resource to cover the conflict, then try again .. */",
            "\t\tif (conflict->start < new->start)",
            "\t\t\tnew->start = conflict->start;",
            "\t\tif (conflict->end > new->end)",
            "\t\t\tnew->end = conflict->end;",
            "",
            "\t\tpr_info(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);",
            "\t}",
            "\twrite_unlock(&resource_lock);",
            "}",
            "int remove_resource(struct resource *old)",
            "{",
            "\tint retval;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tretval = __release_resource(old, false);",
            "\twrite_unlock(&resource_lock);",
            "\treturn retval;",
            "}",
            "static int __adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t\t\tresource_size_t size)",
            "{",
            "\tstruct resource *tmp, *parent = res->parent;",
            "\tresource_size_t end = start + size - 1;",
            "\tint result = -EBUSY;",
            "",
            "\tif (!parent)",
            "\t\tgoto skip;",
            "",
            "\tif ((start < parent->start) || (end > parent->end))",
            "\t\tgoto out;",
            "",
            "\tif (res->sibling && (res->sibling->start <= end))",
            "\t\tgoto out;",
            "",
            "\ttmp = parent->child;",
            "\tif (tmp != res) {",
            "\t\twhile (tmp->sibling != res)",
            "\t\t\ttmp = tmp->sibling;",
            "\t\tif (start <= tmp->end)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "skip:",
            "\tfor (tmp = res->child; tmp; tmp = tmp->sibling)",
            "\t\tif ((tmp->start < start) || (tmp->end > end))",
            "\t\t\tgoto out;",
            "",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tresult = 0;",
            "",
            " out:",
            "\treturn result;",
            "}"
          ],
          "function_name": "allocate_resource, insert_resource, insert_resource_expand_to_fit, remove_resource, __adjust_resource",
          "description": "实现资源分配逻辑，支持带约束条件的资源查找与申请，处理资源冲突及扩展调整，提供基础资源管理框架。",
          "similarity": 0.5778350830078125
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/resource.c",
          "start_line": 1407,
          "end_line": 1533,
          "content": [
            "void release_mem_region_adjustable(resource_size_t start, resource_size_t size)",
            "{",
            "\tstruct resource *parent = &iomem_resource;",
            "\tstruct resource *new_res = NULL;",
            "\tbool alloc_nofail = false;",
            "\tstruct resource **p;",
            "\tstruct resource *res;",
            "\tresource_size_t end;",
            "",
            "\tend = start + size - 1;",
            "\tif (WARN_ON_ONCE((start < parent->start) || (end > parent->end)))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * We free up quite a lot of memory on memory hotunplug (esp., memap),",
            "\t * just before releasing the region. This is highly unlikely to",
            "\t * fail - let's play save and make it never fail as the caller cannot",
            "\t * perform any error handling (e.g., trying to re-add memory will fail",
            "\t * similarly).",
            "\t */",
            "retry:",
            "\tnew_res = alloc_resource(GFP_KERNEL | (alloc_nofail ? __GFP_NOFAIL : 0));",
            "",
            "\tp = &parent->child;",
            "\twrite_lock(&resource_lock);",
            "",
            "\twhile ((res = *p)) {",
            "\t\tif (res->start >= end)",
            "\t\t\tbreak;",
            "",
            "\t\t/* look for the next resource if it does not fit into */",
            "\t\tif (res->start > start || res->end < end) {",
            "\t\t\tp = &res->sibling;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!(res->flags & IORESOURCE_MEM))",
            "\t\t\tbreak;",
            "",
            "\t\tif (!(res->flags & IORESOURCE_BUSY)) {",
            "\t\t\tp = &res->child;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/* found the target resource; let's adjust accordingly */",
            "\t\tif (res->start == start && res->end == end) {",
            "\t\t\t/* free the whole entry */",
            "\t\t\t*p = res->sibling;",
            "\t\t\tfree_resource(res);",
            "\t\t} else if (res->start == start && res->end != end) {",
            "\t\t\t/* adjust the start */",
            "\t\t\tWARN_ON_ONCE(__adjust_resource(res, end + 1,",
            "\t\t\t\t\t\t       res->end - end));",
            "\t\t} else if (res->start != start && res->end == end) {",
            "\t\t\t/* adjust the end */",
            "\t\t\tWARN_ON_ONCE(__adjust_resource(res, res->start,",
            "\t\t\t\t\t\t       start - res->start));",
            "\t\t} else {",
            "\t\t\t/* split into two entries - we need a new resource */",
            "\t\t\tif (!new_res) {",
            "\t\t\t\tnew_res = alloc_resource(GFP_ATOMIC);",
            "\t\t\t\tif (!new_res) {",
            "\t\t\t\t\talloc_nofail = true;",
            "\t\t\t\t\twrite_unlock(&resource_lock);",
            "\t\t\t\t\tgoto retry;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tnew_res->name = res->name;",
            "\t\t\tnew_res->start = end + 1;",
            "\t\t\tnew_res->end = res->end;",
            "\t\t\tnew_res->flags = res->flags;",
            "\t\t\tnew_res->desc = res->desc;",
            "\t\t\tnew_res->parent = res->parent;",
            "\t\t\tnew_res->sibling = res->sibling;",
            "\t\t\tnew_res->child = NULL;",
            "",
            "\t\t\tif (WARN_ON_ONCE(__adjust_resource(res, res->start,",
            "\t\t\t\t\t\t\t   start - res->start)))",
            "\t\t\t\tbreak;",
            "\t\t\tres->sibling = new_res;",
            "\t\t\tnew_res = NULL;",
            "\t\t}",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\twrite_unlock(&resource_lock);",
            "\tfree_resource(new_res);",
            "}",
            "static bool system_ram_resources_mergeable(struct resource *r1,",
            "\t\t\t\t\t   struct resource *r2)",
            "{",
            "\t/* We assume either r1 or r2 is IORESOURCE_SYSRAM_MERGEABLE. */",
            "\treturn r1->flags == r2->flags && r1->end + 1 == r2->start &&",
            "\t       r1->name == r2->name && r1->desc == r2->desc &&",
            "\t       !r1->child && !r2->child;",
            "}",
            "void merge_system_ram_resource(struct resource *res)",
            "{",
            "\tconst unsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;",
            "\tstruct resource *cur;",
            "",
            "\tif (WARN_ON_ONCE((res->flags & flags) != flags))",
            "\t\treturn;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tres->flags |= IORESOURCE_SYSRAM_MERGEABLE;",
            "",
            "\t/* Try to merge with next item in the list. */",
            "\tcur = res->sibling;",
            "\tif (cur && system_ram_resources_mergeable(res, cur)) {",
            "\t\tres->end = cur->end;",
            "\t\tres->sibling = cur->sibling;",
            "\t\tfree_resource(cur);",
            "\t}",
            "",
            "\t/* Try to merge with previous item in the list. */",
            "\tcur = res->parent->child;",
            "\twhile (cur && cur->sibling != res)",
            "\t\tcur = cur->sibling;",
            "\tif (cur && system_ram_resources_mergeable(cur, res)) {",
            "\t\tcur->end = res->end;",
            "\t\tcur->sibling = res->sibling;",
            "\t\tfree_resource(res);",
            "\t}",
            "\twrite_unlock(&resource_lock);",
            "}"
          ],
          "function_name": "release_mem_region_adjustable, system_ram_resources_mergeable, merge_system_ram_resource",
          "description": "实现可调整内存区域释放与系统RAM资源合并功能，支持热插拔场景下的动态资源调整与碎片化优化。",
          "similarity": 0.5726175308227539
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/resource.c",
          "start_line": 1561,
          "end_line": 1661,
          "content": [
            "static void devm_resource_release(struct device *dev, void *ptr)",
            "{",
            "\tstruct resource **r = ptr;",
            "",
            "\trelease_resource(*r);",
            "}",
            "int devm_request_resource(struct device *dev, struct resource *root,",
            "\t\t\t  struct resource *new)",
            "{",
            "\tstruct resource *conflict, **ptr;",
            "",
            "\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);",
            "\tif (!ptr)",
            "\t\treturn -ENOMEM;",
            "",
            "\t*ptr = new;",
            "",
            "\tconflict = request_resource_conflict(root, new);",
            "\tif (conflict) {",
            "\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",",
            "\t\t\tnew, conflict->name, conflict);",
            "\t\tdevres_free(ptr);",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tdevres_add(dev, ptr);",
            "\treturn 0;",
            "}",
            "static int devm_resource_match(struct device *dev, void *res, void *data)",
            "{",
            "\tstruct resource **ptr = res;",
            "",
            "\treturn *ptr == data;",
            "}",
            "void devm_release_resource(struct device *dev, struct resource *new)",
            "{",
            "\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,",
            "\t\t\t       new));",
            "}",
            "static void devm_region_release(struct device *dev, void *res)",
            "{",
            "\tstruct region_devres *this = res;",
            "",
            "\t__release_region(this->parent, this->start, this->n);",
            "}",
            "static int devm_region_match(struct device *dev, void *res, void *match_data)",
            "{",
            "\tstruct region_devres *this = res, *match = match_data;",
            "",
            "\treturn this->parent == match->parent &&",
            "\t\tthis->start == match->start && this->n == match->n;",
            "}",
            "void __devm_release_region(struct device *dev, struct resource *parent,",
            "\t\t\t   resource_size_t start, resource_size_t n)",
            "{",
            "\tstruct region_devres match_data = { parent, start, n };",
            "",
            "\t__release_region(parent, start, n);",
            "\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,",
            "\t\t\t       &match_data));",
            "}",
            "static int __init reserve_setup(char *str)",
            "{",
            "\tstatic int reserved;",
            "\tstatic struct resource reserve[MAXRESERVE];",
            "",
            "\tfor (;;) {",
            "\t\tunsigned int io_start, io_num;",
            "\t\tint x = reserved;",
            "\t\tstruct resource *parent;",
            "",
            "\t\tif (get_option(&str, &io_start) != 2)",
            "\t\t\tbreak;",
            "\t\tif (get_option(&str, &io_num) == 0)",
            "\t\t\tbreak;",
            "\t\tif (x < MAXRESERVE) {",
            "\t\t\tstruct resource *res = reserve + x;",
            "",
            "\t\t\t/*",
            "\t\t\t * If the region starts below 0x10000, we assume it's",
            "\t\t\t * I/O port space; otherwise assume it's memory.",
            "\t\t\t */",
            "\t\t\tif (io_start < 0x10000) {",
            "\t\t\t\tres->flags = IORESOURCE_IO;",
            "\t\t\t\tparent = &ioport_resource;",
            "\t\t\t} else {",
            "\t\t\t\tres->flags = IORESOURCE_MEM;",
            "\t\t\t\tparent = &iomem_resource;",
            "\t\t\t}",
            "\t\t\tres->name = \"reserved\";",
            "\t\t\tres->start = io_start;",
            "\t\t\tres->end = io_start + io_num - 1;",
            "\t\t\tres->flags |= IORESOURCE_BUSY;",
            "\t\t\tres->desc = IORES_DESC_NONE;",
            "\t\t\tres->child = NULL;",
            "\t\t\tif (request_resource(parent, res) == 0)",
            "\t\t\t\treserved = x+1;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}"
          ],
          "function_name": "devm_resource_release, devm_request_resource, devm_resource_match, devm_release_resource, devm_region_release, devm_region_match, __devm_release_region, reserve_setup",
          "description": "实现设备资源管理器（devm）的资源申请/释放机制，包含预留资源初始化及设备资源生命周期绑定功能。",
          "similarity": 0.5688509345054626
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/resource.c",
          "start_line": 104,
          "end_line": 208,
          "content": [
            "static void r_stop(struct seq_file *m, void *v)",
            "\t__releases(resource_lock)",
            "{",
            "\tread_unlock(&resource_lock);",
            "}",
            "static int r_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct resource *root = pde_data(file_inode(m->file));",
            "\tstruct resource *r = v, *p;",
            "\tunsigned long long start, end;",
            "\tint width = root->end < 0x10000 ? 4 : 8;",
            "\tint depth;",
            "",
            "\tfor (depth = 0, p = r; depth < MAX_IORES_LEVEL; depth++, p = p->parent)",
            "\t\tif (p->parent == root)",
            "\t\t\tbreak;",
            "",
            "\tif (file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN)) {",
            "\t\tstart = r->start;",
            "\t\tend = r->end;",
            "\t} else {",
            "\t\tstart = end = 0;",
            "\t}",
            "",
            "\tseq_printf(m, \"%*s%0*llx-%0*llx : %s\\n\",",
            "\t\t\tdepth * 2, \"\",",
            "\t\t\twidth, start,",
            "\t\t\twidth, end,",
            "\t\t\tr->name ? r->name : \"<BAD>\");",
            "\treturn 0;",
            "}",
            "static int __init ioresources_init(void)",
            "{",
            "\tproc_create_seq_data(\"ioports\", 0, NULL, &resource_op,",
            "\t\t\t&ioport_resource);",
            "\tproc_create_seq_data(\"iomem\", 0, NULL, &resource_op, &iomem_resource);",
            "\treturn 0;",
            "}",
            "static void free_resource(struct resource *res)",
            "{",
            "\t/**",
            "\t * If the resource was allocated using memblock early during boot",
            "\t * we'll leak it here: we can only return full pages back to the",
            "\t * buddy and trying to be smart and reusing them eventually in",
            "\t * alloc_resource() overcomplicates resource handling.",
            "\t */",
            "\tif (res && PageSlab(virt_to_head_page(res)))",
            "\t\tkfree(res);",
            "}",
            "static int __release_resource(struct resource *old, bool release_child)",
            "{",
            "\tstruct resource *tmp, **p, *chd;",
            "",
            "\tp = &old->parent->child;",
            "\tfor (;;) {",
            "\t\ttmp = *p;",
            "\t\tif (!tmp)",
            "\t\t\tbreak;",
            "\t\tif (tmp == old) {",
            "\t\t\tif (release_child || !(tmp->child)) {",
            "\t\t\t\t*p = tmp->sibling;",
            "\t\t\t} else {",
            "\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {",
            "\t\t\t\t\tchd->parent = tmp->parent;",
            "\t\t\t\t\tif (!(chd->sibling))",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\t*p = tmp->child;",
            "\t\t\t\tchd->sibling = tmp->sibling;",
            "\t\t\t}",
            "\t\t\told->parent = NULL;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tp = &tmp->sibling;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static void __release_child_resources(struct resource *r)",
            "{",
            "\tstruct resource *tmp, *p;",
            "\tresource_size_t size;",
            "",
            "\tp = r->child;",
            "\tr->child = NULL;",
            "\twhile (p) {",
            "\t\ttmp = p;",
            "\t\tp = p->sibling;",
            "",
            "\t\ttmp->parent = NULL;",
            "\t\ttmp->sibling = NULL;",
            "\t\t__release_child_resources(tmp);",
            "",
            "\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);",
            "\t\t/* need to restore size, and keep flags */",
            "\t\tsize = resource_size(tmp);",
            "\t\ttmp->start = 0;",
            "\t\ttmp->end = size - 1;",
            "\t}",
            "}",
            "void release_child_resources(struct resource *r)",
            "{",
            "\twrite_lock(&resource_lock);",
            "\t__release_child_resources(r);",
            "\twrite_unlock(&resource_lock);",
            "}"
          ],
          "function_name": "r_stop, r_show, ioresources_init, free_resource, __release_resource, __release_child_resources, release_child_resources",
          "description": "实现资源遍历显示接口、资源释放逻辑及初始化函数，提供资源冲突检测、子资源释放、内存区域遍历等功能，支持进程命名空间下的资源访问控制。",
          "similarity": 0.5675441026687622
        }
      ]
    }
  ]
}