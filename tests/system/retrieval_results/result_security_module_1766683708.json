{
  "query": "security module",
  "timestamp": "2025-12-26 01:28:28",
  "retrieved_files": [
    {
      "source_file": "kernel/module/signing.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:06:05\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\signing.c`\n\n---\n\n# module/signing.c 技术文档\n\n## 1. 文件概述\n\n`module/signing.c` 是 Linux 内核中用于验证内核模块数字签名的核心实现文件。该文件提供了模块加载过程中对 PKCS#7 格式签名的解析、验证和策略控制功能，确保只有经过合法签名的模块才能被加载到内核中，从而增强系统的安全性和完整性。该机制是内核模块签名（Module Signature）子系统的关键组成部分，支持强制签名（`CONFIG_MODULE_SIG_FORCE`）和运行时策略控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`is_module_sig_enforced(void)`**  \n  返回当前是否强制要求模块必须具有有效签名。该函数导出为符号，供其他内核子系统使用。\n\n- **`set_module_sig_enforced(void)`**  \n  在运行时将模块签名强制策略设置为启用状态（`true`），通常由安全机制（如 Lockdown）调用。\n\n- **`mod_verify_sig(const void *mod, struct load_info *info)`**  \n  执行模块签名的实际验证逻辑：解析模块末尾的 `module_signature` 结构，提取签名数据，并调用通用 PKCS#7 验证接口进行验证。\n\n- **`module_sig_check(struct load_info *info, int flags)`**  \n  模块加载流程中的主入口函数，负责检测模块是否包含签名标记（`~Module signature appended~\\n`），决定是否调用 `mod_verify_sig`，并根据验证结果和系统策略决定是否允许加载。\n\n### 关键数据结构与变量\n\n- **`sig_enforce`**  \n  全局布尔变量，表示是否强制执行模块签名验证。初始值由 `CONFIG_MODULE_SIG_FORCE` 决定，可通过内核命令行参数 `module.sig_enforce=1` 或运行时调用 `set_module_sig_enforced()` 修改。\n\n- **`module_signature`**  \n  定义在 `<linux/module_signature.h>` 中的结构体，位于模块二进制末尾，包含签名元数据（如签名长度、哈希算法、密钥标识等）。\n\n- **`MODULE_SIG_STRING`**  \n  签名结束标记字符串 `\"~Module signature appended~\\n\"`，用于识别模块是否包含签名。\n\n## 3. 关键实现\n\n### 签名验证流程\n\n1. **签名检测**：  \n   `module_sig_check` 检查模块末尾是否存在 `MODULE_SIG_STRING` 标记。若存在，则认为模块包含签名。\n\n2. **签名解析**：  \n   `mod_verify_sig` 从模块末尾读取 `struct module_signature`，调用 `mod_check_sig()` 验证其格式合法性。\n\n3. **数据截断**：  \n   从模块总长度中扣除签名数据和签名结构体的长度，得到实际代码/数据部分的长度（`info->len` 更新为此值）。\n\n4. **PKCS#7 验证**：  \n   调用 `verify_pkcs7_signature()`，使用内核的 `VERIFY_USE_SECONDARY_KEYRING`（通常为 `.module_signing` 密钥环）验证模块主体的完整性与签名有效性。\n\n### 安全策略处理\n\n- **强制模式（`sig_enforce == true`）**：  \n  任何未签名、密钥不可用或加密算法不支持的模块均被拒绝加载，返回 `-EKEYREJECTED`。\n\n- **非强制模式**：  \n  允许加载未签名模块，但会检查系统是否处于 Lockdown 模式（通过 `security_locked_down(LOCKDOWN_MODULE_SIGNATURE)`）。若处于 Lockdown，则仍拒绝加载。\n\n- **模块篡改防护**：  \n  若加载标志包含 `MODULE_INIT_IGNORE_MODVERSIONS` 或 `MODULE_INIT_IGNORE_VERMAGIC`（即忽略版本魔数或模块版本），则视为“被篡改”的模块，即使有签名也不予验证，防止绕过签名保护。\n\n### 错误分类\n\n- **非致命错误**（仅在非强制模式下可忽略）：\n  - `-ENODATA`：模块未签名\n  - `-ENOPKG`：使用了内核不支持的加密算法\n  - `-ENOKEY`：签名所用公钥不在信任密钥环中\n\n- **致命错误**（无论是否强制均拒绝）：\n  - 内存分配失败、签名格式错误、哈希不匹配等\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/verification.h>`：提供 `verify_pkcs7_signature()` 接口\n  - `<crypto/public_key.h>`：PKCS#7 验证所需的密码学支持\n  - `<linux/module_signature.h>`：定义 `module_signature` 结构\n  - `\"internal.h\"`：模块子系统内部头文件\n\n- **内核配置依赖**：\n  - `CONFIG_MODULE_SIG`：启用模块签名功能\n  - `CONFIG_MODULE_SIG_FORCE`：决定 `sig_enforce` 的默认值\n  - `CONFIG_SECURITY_LOCKDOWN_LSM`：提供 `security_locked_down()` 支持\n\n- **密钥管理依赖**：  \n  依赖内核密钥环服务（Key Retention Service），特别是 `.module_signing` 二级密钥环存储用于验证模块的公钥。\n\n## 5. 使用场景\n\n- **模块加载流程**：  \n  在 `load_module()` 函数中，内核调用 `module_sig_check()` 对待加载模块进行签名验证，是模块安全加载的关键环节。\n\n- **安全启动（Secure Boot）环境**：  \n  当系统启用 UEFI Secure Boot 时，通常会强制启用模块签名（`sig_enforce = true`），确保所有内核模块均来自可信源。\n\n- **内核 Lockdown 模式**：  \n  在 Lockdown 的 `integrity` 或 `confidentiality` 级别下，即使未设置 `CONFIG_MODULE_SIG_FORCE`，也会通过 `security_locked_down()` 阻止未签名模块加载。\n\n- **动态策略调整**：  \n  安全模块（如 Lockdown LSM）可在运行时调用 `set_module_sig_enforced()` 动态提升安全策略，禁止后续未签名模块加载。",
      "similarity": 0.6034544110298157,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/signing.c",
          "start_line": 29,
          "end_line": 118,
          "content": [
            "bool is_module_sig_enforced(void)",
            "{",
            "\treturn sig_enforce;",
            "}",
            "void set_module_sig_enforced(void)",
            "{",
            "\tsig_enforce = true;",
            "}",
            "int mod_verify_sig(const void *mod, struct load_info *info)",
            "{",
            "\tstruct module_signature ms;",
            "\tsize_t sig_len, modlen = info->len;",
            "\tint ret;",
            "",
            "\tpr_devel(\"==>%s(,%zu)\\n\", __func__, modlen);",
            "",
            "\tif (modlen <= sizeof(ms))",
            "\t\treturn -EBADMSG;",
            "",
            "\tmemcpy(&ms, mod + (modlen - sizeof(ms)), sizeof(ms));",
            "",
            "\tret = mod_check_sig(&ms, modlen, \"module\");",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tsig_len = be32_to_cpu(ms.sig_len);",
            "\tmodlen -= sig_len + sizeof(ms);",
            "\tinfo->len = modlen;",
            "",
            "\treturn verify_pkcs7_signature(mod, modlen, mod + modlen, sig_len,",
            "\t\t\t\t      VERIFY_USE_SECONDARY_KEYRING,",
            "\t\t\t\t      VERIFYING_MODULE_SIGNATURE,",
            "\t\t\t\t      NULL, NULL);",
            "}",
            "int module_sig_check(struct load_info *info, int flags)",
            "{",
            "\tint err = -ENODATA;",
            "\tconst unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;",
            "\tconst char *reason;",
            "\tconst void *mod = info->hdr;",
            "\tbool mangled_module = flags & (MODULE_INIT_IGNORE_MODVERSIONS |",
            "\t\t\t\t       MODULE_INIT_IGNORE_VERMAGIC);",
            "\t/*",
            "\t * Do not allow mangled modules as a module with version information",
            "\t * removed is no longer the module that was signed.",
            "\t */",
            "\tif (!mangled_module &&",
            "\t    info->len > markerlen &&",
            "\t    memcmp(mod + info->len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {",
            "\t\t/* We truncate the module to discard the signature */",
            "\t\tinfo->len -= markerlen;",
            "\t\terr = mod_verify_sig(mod, info);",
            "\t\tif (!err) {",
            "\t\t\tinfo->sig_ok = true;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * We don't permit modules to be loaded into the trusted kernels",
            "\t * without a valid signature on them, but if we're not enforcing,",
            "\t * certain errors are non-fatal.",
            "\t */",
            "\tswitch (err) {",
            "\tcase -ENODATA:",
            "\t\treason = \"unsigned module\";",
            "\t\tbreak;",
            "\tcase -ENOPKG:",
            "\t\treason = \"module with unsupported crypto\";",
            "\t\tbreak;",
            "\tcase -ENOKEY:",
            "\t\treason = \"module with unavailable key\";",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\t/*",
            "\t\t * All other errors are fatal, including lack of memory,",
            "\t\t * unparseable signatures, and signature check failures --",
            "\t\t * even if signatures aren't required.",
            "\t\t */",
            "\t\treturn err;",
            "\t}",
            "",
            "\tif (is_module_sig_enforced()) {",
            "\t\tpr_notice(\"Loading of %s is rejected\\n\", reason);",
            "\t\treturn -EKEYREJECTED;",
            "\t}",
            "",
            "\treturn security_locked_down(LOCKDOWN_MODULE_SIGNATURE);",
            "}"
          ],
          "function_name": "is_module_sig_enforced, set_module_sig_enforced, mod_verify_sig, module_sig_check",
          "description": "实现模块签名验证核心逻辑，包含签名状态查询接口、签名验证执行函数以及综合检查入口，通过标记比对与证书验证完成模块签名有效性校验",
          "similarity": 0.5176548361778259
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/signing.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* Module signature checker",
            " *",
            " * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/string.h>",
            "#include <linux/verification.h>",
            "#include <linux/security.h>",
            "#include <crypto/public_key.h>",
            "#include <uapi/linux/module.h>",
            "#include \"internal.h\"",
            "",
            "#undef MODULE_PARAM_PREFIX",
            "#define MODULE_PARAM_PREFIX \"module.\"",
            "",
            "static bool sig_enforce = IS_ENABLED(CONFIG_MODULE_SIG_FORCE);",
            "module_param(sig_enforce, bool_enable_only, 0644);",
            "",
            "/*",
            " * Export sig_enforce kernel cmdline parameter to allow other subsystems rely",
            " * on that instead of directly to CONFIG_MODULE_SIG_FORCE config.",
            " */"
          ],
          "function_name": null,
          "description": "定义sig_enforce全局变量用于控制模块签名强制检查标志位，并注册模块参数供外部配置",
          "similarity": 0.4560297131538391
        }
      ]
    },
    {
      "source_file": "kernel/module_signature.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:10:38\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module_signature.c`\n\n---\n\n# module_signature.c 技术文档\n\n## 1. 文件概述\n\n`module_signature.c` 是 Linux 内核中用于验证内核模块数字签名有效性的核心组件。该文件实现了对附加在模块末尾的 PKCS#7 格式签名的初步格式校验逻辑，确保加载的模块签名结构合法且符合内核预期的安全要求。此功能是内核模块签名验证机制的第一道防线，用于防止加载格式错误或使用非预期签名算法的模块。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`mod_check_sig`**  \n  函数原型：  \n  ```c\n  int mod_check_sig(const struct module_signature *ms, size_t file_len, const char *name)\n  ```  \n  功能：验证模块签名结构的合法性，包括签名长度、签名类型及保留字段是否符合预期。\n\n### 关键数据结构\n\n- **`struct module_signature`**  \n  定义在 `<linux/module_signature.h>` 中，描述附加在模块文件末尾的签名元数据结构，包含签名长度、标识类型、算法、哈希方式、签名人长度、密钥 ID 长度及填充字段等。\n\n## 3. 关键实现\n\n- **签名长度校验**：  \n  使用 `be32_to_cpu(ms->sig_len)` 将大端序存储的签名长度转换为主机字节序，并验证其不超过模块文件总长度减去签名结构本身的大小，防止缓冲区越界。\n\n- **签名类型强制约束**：  \n  仅接受 `PKEY_ID_PKCS7` 类型的签名，这是内核模块签名的标准格式。若使用其他签名类型（如 X.509 直接签名），则拒绝加载并返回 `-ENOPKG`。\n\n- **保留字段清零检查**：  \n  对于 PKCS#7 签名，`algo`、`hash`、`signer_len`、`key_id_len` 及三个填充字节 `__pad` 必须为零。这是因为 PKCS#7 本身已包含完整的算法和身份信息，无需在签名头中重复指定。任何非零值均视为格式错误，返回 `-EBADMSG`。\n\n- **错误报告机制**：  \n  使用 `pr_err()` 输出带上下文名称（如模块文件名）的详细错误信息，便于调试和审计。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/errno.h>`：提供标准错误码（如 `-EBADMSG`, `-ENOPKG`）\n  - `<linux/printk.h>`：提供内核日志输出接口 `pr_err()`\n  - `<linux/module_signature.h>`：定义 `struct module_signature` 结构体\n  - `<asm/byteorder.h>`：提供字节序转换函数 `be32_to_cpu()`\n\n- **内核子系统依赖**：\n  - **模块加载子系统（module loader）**：在模块加载流程中调用此函数进行签名预检\n  - **密钥管理子系统（KEYS）**：后续的 PKCS#7 签名验证由 KEYS 子系统完成，本文件仅做格式检查\n\n## 5. 使用场景\n\n- **内核模块加载时的安全校验**：  \n  当用户通过 `insmod`、`modprobe` 等命令加载内核模块时，内核模块加载器会读取模块文件末尾的签名数据，并调用 `mod_check_sig()` 进行初步格式验证。只有通过此检查的模块才会进入后续的 PKCS#7 签名验证阶段。\n\n- **启用模块签名强制策略时的关键环节**：  \n  在配置了 `CONFIG_MODULE_SIG_FORCE=y` 的系统中，所有模块必须带有有效签名。`mod_check_sig()` 作为签名验证链的第一步，确保签名结构本身合法，防止恶意构造的签名数据绕过安全检查。\n\n- **内核自保护机制的一部分**：  \n  该文件与内核完整性子系统（如 IMA）协同工作，共同保障运行时内核代码的完整性与可信性。",
      "similarity": 0.5984392166137695,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module_signature.c",
          "start_line": 21,
          "end_line": 46,
          "content": [
            "int mod_check_sig(const struct module_signature *ms, size_t file_len,",
            "\t\t  const char *name)",
            "{",
            "\tif (be32_to_cpu(ms->sig_len) >= file_len - sizeof(*ms))",
            "\t\treturn -EBADMSG;",
            "",
            "\tif (ms->id_type != PKEY_ID_PKCS7) {",
            "\t\tpr_err(\"%s: not signed with expected PKCS#7 message\\n\",",
            "\t\t       name);",
            "\t\treturn -ENOPKG;",
            "\t}",
            "",
            "\tif (ms->algo != 0 ||",
            "\t    ms->hash != 0 ||",
            "\t    ms->signer_len != 0 ||",
            "\t    ms->key_id_len != 0 ||",
            "\t    ms->__pad[0] != 0 ||",
            "\t    ms->__pad[1] != 0 ||",
            "\t    ms->__pad[2] != 0) {",
            "\t\tpr_err(\"%s: PKCS#7 signature info has unexpected non-zero params\\n\",",
            "\t\t       name);",
            "\t\treturn -EBADMSG;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "mod_check_sig",
          "description": "实现模块签名验证函数mod_check_sig，检查签名长度是否超出有效范围，验证PKCS#7标识符类型，并确保签名结构中的非关键字段均为零值以保证签名数据完整性",
          "similarity": 0.5522516965866089
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module_signature.c",
          "start_line": 1,
          "end_line": 20,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Module signature checker",
            " *",
            " * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " */",
            "",
            "#include <linux/errno.h>",
            "#include <linux/printk.h>",
            "#include <linux/module_signature.h>",
            "#include <asm/byteorder.h>",
            "",
            "/**",
            " * mod_check_sig - check that the given signature is sane",
            " *",
            " * @ms:\t\tSignature to check.",
            " * @file_len:\tSize of the file to which @ms is appended.",
            " * @name:\tWhat is being checked. Used for error messages.",
            " */"
          ],
          "function_name": null,
          "description": "定义模块签名检查函数mod_check_sig的原型，用于验证模块签名结构有效性，包含签名长度检查、算法标识符类型校验及字段初始化状态检测，但尚未包含完整实现逻辑",
          "similarity": 0.5193734169006348
        }
      ]
    },
    {
      "source_file": "kernel/module/main.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:04:44\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\main.c`\n\n---\n\n# `module/main.c` 技术文档\n\n## 1. 文件概述\n\n`module/main.c` 是 Linux 内核模块子系统的核心实现文件，负责模块的加载、卸载、符号解析、内存管理、状态跟踪以及模块间依赖关系的维护。该文件实现了内核模块机制的基础框架，包括模块列表管理、模块内存布局控制、符号查找、模块通知机制、模块引用计数等关键功能，是内核动态加载模块能力的核心支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mod_tree_root mod_tree`**：用于加速地址到模块映射的全局模块地址范围树，包含 `addr_min`/`addr_max`（及可选的 `data_addr_min`/`data_addr_max`）。\n- **`LIST_HEAD(modules)`**：全局模块链表，存储所有已加载模块。\n- **`DEFINE_MUTEX(module_mutex)`**：保护模块列表、模块使用关系及地址边界的关键互斥锁。\n- **`struct symsearch`**：用于描述符号搜索范围，包含符号起止位置、CRC 校验数组及许可证类型。\n- **`struct find_symbol_arg`**：符号查找的参数结构体，用于传递查找目标及接收结果（所有者、符号指针、CRC、许可证等）。\n\n### 主要函数与接口\n\n- **模块注册/注销通知**：\n  - `register_module_notifier()` / `unregister_module_notifier()`：注册/注销模块生命周期事件通知回调。\n- **模块引用管理**：\n  - `strong_try_module_get()`：强引用获取，拒绝处于 `COMING` 状态的模块。\n  - `__module_put_and_kthread_exit()`：专用于内核线程在退出前释放模块引用。\n- **模块内存边界管理**：\n  - `__mod_update_bounds()` / `mod_update_bounds()`：更新全局模块地址范围，用于加速 `__module_address()`。\n- **ELF 节区辅助函数**：\n  - `find_sec()` / `find_any_sec()`：根据名称查找 ELF 节区索引。\n  - `section_addr()` / `section_objs()`：获取节区地址及对象数量。\n- **符号查找**：\n  - `find_symbol()`：在内核及已加载模块中查找导出符号。\n  - `find_exported_symbol_in_section()`：在指定符号段中二分查找符号。\n- **模块状态与安全**：\n  - `add_taint_module()`：为模块添加污点标记（taint flag）。\n- **全局控制**：\n  - `modules_disabled`：通过 `nomodule` 内核参数控制是否禁用模块加载。\n\n### 全局变量与工作队列\n\n- **`init_free_wq`**：用于异步释放模块初始化段（`.init`）内存的工作队列。\n- **`init_free_list`**：待释放初始化内存的无锁链表。\n- **`module_wq`**：等待模块初始化完成的等待队列。\n\n## 3. 关键实现\n\n### 模块地址范围加速\n\n通过 `mod_tree` 全局结构维护所有模块（或核心数据）的最小/最大虚拟地址。`__module_address()` 可先检查目标地址是否落在 `[addr_min, addr_max]` 范围内，若不在则直接返回 `NULL`，避免遍历整个模块链表，显著提升性能。\n\n### 符号查找机制\n\n- 使用 `bsearch()` 在已排序的导出符号表中进行二分查找，时间复杂度为 O(log n)。\n- 支持符号命名空间（namespace）和 GPL 许可证检查：非 GPL 模块无法使用 `GPL_ONLY` 符号。\n- 通过 `symsearch` 数组统一管理内核及各模块的符号段，实现统一查找接口。\n\n### 模块内存管理\n\n- 模块内存按 `mod_mem_type`（如代码、只读数据、可写数据、初始化段等）分类管理。\n- 初始化段（`.init`）在模块初始化成功后通过工作队列异步释放，节省内存。\n- 支持 `CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC` 架构选项，将模块数据段单独纳入地址范围管理。\n\n### 模块状态与引用安全\n\n- `strong_try_module_get()` 确保不会对处于 `MODULE_STATE_COMING`（正在初始化）或 `MODULE_STATE_UNFORMED`（未形成）状态的模块增加引用，防止竞态。\n- `__module_put_and_kthread_exit()` 为内核线程提供安全退出路径，在释放模块引用后终止线程。\n\n### 模块通知机制\n\n基于 `blocking_notifier_chain` 实现模块生命周期事件（如加载、卸载、初始化完成等）的通知，允许其他子系统（如 livepatch、ftrace）监听并响应模块状态变化。\n\n### 构建标识与版本校验\n\n- 通过 `INCLUDE_VERMAGIC` 宏包含模块魔数（vermagic）信息，用于加载时内核版本兼容性检查。\n- 支持 `CONFIG_MODVERSIONS`，在符号查找时返回 CRC 校验值，确保符号 ABI 兼容性。\n\n## 4. 依赖关系\n\n- **架构相关**：\n  - 依赖 `asm/cacheflush.h`、`asm/mmu_context.h`、`asm/sections.h` 等架构头文件，处理指令缓存刷新、内存映射等。\n  - 使用 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 优化符号字符串存储。\n- **内核子系统**：\n  - **内存管理**：`vmalloc`、`slab` 用于模块内存分配。\n  - **安全机制**：`capability`、`audit`、`module_signature` 用于模块加载权限和签名验证。\n  - **调试与追踪**：`kallsyms`、`trace_events`、`ftrace`、`dynamic_debug`、`debugfs` 提供模块调试支持。\n  - **并发控制**：`RCU`、`mutex`、`percpu` 用于同步。\n  - **文件系统**：`fs.h`、`kernel_read_file.h` 用于从文件加载模块。\n- **内部依赖**：\n  - 依赖同目录下的 `internal.h`，包含模块子系统内部数据结构和函数声明。\n  - 使用 `uapi/linux/module.h` 定义用户空间接口常量。\n\n## 5. 使用场景\n\n- **动态加载内核模块**：通过 `init_module()` 或 `finit_module()` 系统调用加载 `.ko` 文件时，该文件中的函数负责解析 ELF、重定位、符号解析、执行初始化函数。\n- **模块卸载**：通过 `delete_module()` 系统调用卸载模块时，管理模块引用计数、执行清理函数、释放内存。\n- **内核符号解析**：当模块或内核其他部分调用 `symbol_get()` 或通过 `EXPORT_SYMBOL` 机制访问符号时，`find_symbol()` 被调用。\n- **运行时模块查询**：`/proc/modules`、`/sys/module/` 等接口依赖此文件维护的模块列表和状态信息。\n- **内核热补丁（Livepatch）**：依赖模块通知机制和符号查找功能实现函数替换。\n- **内核调试与性能分析**：ftrace、kprobes 等工具依赖模块地址范围和符号信息进行函数跟踪。",
      "similarity": 0.5828726887702942,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/module/main.c",
          "start_line": 1071,
          "end_line": 1218,
          "content": [
            "static int verify_namespace_is_imported(const struct load_info *info,",
            "\t\t\t\t\tconst struct kernel_symbol *sym,",
            "\t\t\t\t\tstruct module *mod)",
            "{",
            "\tconst char *namespace;",
            "\tchar *imported_namespace;",
            "",
            "\tnamespace = kernel_symbol_namespace(sym);",
            "\tif (namespace && namespace[0]) {",
            "\t\tfor_each_modinfo_entry(imported_namespace, info, \"import_ns\") {",
            "\t\t\tif (strcmp(namespace, imported_namespace) == 0)",
            "\t\t\t\treturn 0;",
            "\t\t}",
            "#ifdef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\tpr_warn(",
            "#else",
            "\t\tpr_err(",
            "#endif",
            "\t\t\t\"%s: module uses symbol (%s) from namespace %s, but does not import it.\\n\",",
            "\t\t\tmod->name, kernel_symbol_name(sym), namespace);",
            "#ifndef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\treturn -EINVAL;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool inherit_taint(struct module *mod, struct module *owner, const char *name)",
            "{",
            "\tif (!owner || !test_bit(TAINT_PROPRIETARY_MODULE, &owner->taints))",
            "\t\treturn true;",
            "",
            "\tif (mod->using_gplonly_symbols) {",
            "\t\tpr_err(\"%s: module using GPL-only symbols uses symbols %s from proprietary module %s.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (!test_bit(TAINT_PROPRIETARY_MODULE, &mod->taints)) {",
            "\t\tpr_warn(\"%s: module uses symbols %s from proprietary module %s, inheriting taint.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\tset_bit(TAINT_PROPRIETARY_MODULE, &mod->taints);",
            "\t}",
            "\treturn true;",
            "}",
            "void __weak module_memfree(void *module_region)",
            "{",
            "\t/*",
            "\t * This memory may be RO, and freeing RO memory in an interrupt is not",
            "\t * supported by vmalloc.",
            "\t */",
            "\tWARN_ON(in_interrupt());",
            "\tvfree(module_region);",
            "}",
            "void __weak module_arch_cleanup(struct module *mod)",
            "{",
            "}",
            "void __weak module_arch_freeing_init(struct module *mod)",
            "{",
            "}",
            "static bool mod_mem_use_vmalloc(enum mod_mem_type type)",
            "{",
            "\treturn IS_ENABLED(CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC) &&",
            "\t\tmod_mem_type_is_core_data(type);",
            "}",
            "static void module_memory_free(void *ptr, enum mod_mem_type type,",
            "\t\t\t       bool unload_codetags)",
            "{",
            "\tif (!unload_codetags && mod_mem_type_is_core_data(type))",
            "\t\treturn;",
            "",
            "\tif (mod_mem_use_vmalloc(type))",
            "\t\tvfree(ptr);",
            "\telse",
            "\t\tmodule_memfree(ptr);",
            "}",
            "static void free_mod_mem(struct module *mod, bool unload_codetags)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (type == MOD_DATA)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Free lock-classes; relies on the preceding sync_rcu(). */",
            "\t\tlockdep_free_key_range(mod_mem->base, mod_mem->size);",
            "\t\tif (mod_mem->size)",
            "\t\t\tmodule_memory_free(mod_mem->base, type,",
            "\t\t\t\t\t   unload_codetags);",
            "\t}",
            "",
            "\t/* MOD_DATA hosts mod, so free it at last */",
            "\tlockdep_free_key_range(mod->mem[MOD_DATA].base, mod->mem[MOD_DATA].size);",
            "\tmodule_memory_free(mod->mem[MOD_DATA].base, MOD_DATA, unload_codetags);",
            "}",
            "static void free_module(struct module *mod)",
            "{",
            "\tbool unload_codetags;",
            "",
            "\ttrace_module_free(mod);",
            "",
            "\tunload_codetags = codetag_unload_module(mod);",
            "\tif (!unload_codetags)",
            "\t\tpr_warn(\"%s: memory allocation(s) from the module still alive, cannot unload cleanly\\n\",",
            "\t\t\tmod->name);",
            "",
            "\tmod_sysfs_teardown(mod);",
            "",
            "\t/*",
            "\t * We leave it in list to prevent duplicate loads, but make sure",
            "\t * that noone uses it while it's being deconstructed.",
            "\t */",
            "\tmutex_lock(&module_mutex);",
            "\tmod->state = MODULE_STATE_UNFORMED;",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* Arch-specific cleanup. */",
            "\tmodule_arch_cleanup(mod);",
            "",
            "\t/* Module unload stuff */",
            "\tmodule_unload_free(mod);",
            "",
            "\t/* Free any allocated parameters. */",
            "\tdestroy_params(mod->kp, mod->num_kp);",
            "",
            "\tif (is_livepatch_module(mod))",
            "\t\tfree_module_elf(mod);",
            "",
            "\t/* Now we can delete it from the lists */",
            "\tmutex_lock(&module_mutex);",
            "\t/* Unlink carefully: kallsyms could be walking list. */",
            "\tlist_del_rcu(&mod->list);",
            "\tmod_tree_remove(mod);",
            "\t/* Remove this module from bug list, this uses list_del_rcu */",
            "\tmodule_bug_cleanup(mod);",
            "\t/* Wait for RCU-sched synchronizing before releasing mod->list and buglist. */",
            "\tsynchronize_rcu();",
            "\tif (try_add_tainted_module(mod))",
            "\t\tpr_err(\"%s: adding tainted module to the unloaded tainted modules list failed.\\n\",",
            "\t\t       mod->name);",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* This may be empty, but that's OK */",
            "\tmodule_arch_freeing_init(mod);",
            "\tkfree(mod->args);",
            "\tpercpu_modfree(mod);",
            "",
            "\tfree_mod_mem(mod, unload_codetags);",
            "}"
          ],
          "function_name": "verify_namespace_is_imported, inherit_taint, module_memfree, module_arch_cleanup, module_arch_freeing_init, mod_mem_use_vmalloc, module_memory_free, free_mod_mem, free_module",
          "description": "实现模块符号命名空间验证(verify_namespace_is_imported)、污点继承逻辑(herit_taint)、内存释放(module_memory_free/free_mod_mem)及架构特定清理(module_arch_cleanup/module_arch_freeing_init)，包含弱符号声明供架构扩展。",
          "similarity": 0.5889444351196289
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/module/main.c",
          "start_line": 1584,
          "end_line": 1887,
          "content": [
            "static void layout_sections(struct module *mod, struct load_info *info)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < info->hdr->e_shnum; i++)",
            "\t\tinfo->sechdrs[i].sh_entsize = ~0UL;",
            "",
            "\tpr_debug(\"Core section allocation order for %s:\\n\", mod->name);",
            "\t__layout_sections(mod, info, false);",
            "",
            "\tpr_debug(\"Init section allocation order for %s:\\n\", mod->name);",
            "\t__layout_sections(mod, info, true);",
            "}",
            "static void module_license_taint_check(struct module *mod, const char *license)",
            "{",
            "\tif (!license)",
            "\t\tlicense = \"unspecified\";",
            "",
            "\tif (!license_is_gpl_compatible(license)) {",
            "\t\tif (!test_taint(TAINT_PROPRIETARY_MODULE))",
            "\t\t\tpr_warn(\"%s: module license '%s' taints kernel.\\n\",",
            "\t\t\t\tmod->name, license);",
            "\t\tadd_taint_module(mod, TAINT_PROPRIETARY_MODULE,",
            "\t\t\t\t LOCKDEP_STILL_OK);",
            "\t}",
            "}",
            "static void setup_modinfo(struct module *mod, struct load_info *info)",
            "{",
            "\tstruct module_attribute *attr;",
            "\tint i;",
            "",
            "\tfor (i = 0; (attr = modinfo_attrs[i]); i++) {",
            "\t\tif (attr->setup)",
            "\t\t\tattr->setup(mod, get_modinfo(info, attr->attr.name));",
            "\t}",
            "}",
            "static void free_modinfo(struct module *mod)",
            "{",
            "\tstruct module_attribute *attr;",
            "\tint i;",
            "",
            "\tfor (i = 0; (attr = modinfo_attrs[i]); i++) {",
            "\t\tif (attr->free)",
            "\t\t\tattr->free(mod);",
            "\t}",
            "}",
            "bool __weak module_init_section(const char *name)",
            "{",
            "\treturn strstarts(name, \".init\");",
            "}",
            "bool __weak module_exit_section(const char *name)",
            "{",
            "\treturn strstarts(name, \".exit\");",
            "}",
            "static int validate_section_offset(struct load_info *info, Elf_Shdr *shdr)",
            "{",
            "#if defined(CONFIG_64BIT)",
            "\tunsigned long long secend;",
            "#else",
            "\tunsigned long secend;",
            "#endif",
            "",
            "\t/*",
            "\t * Check for both overflow and offset/size being",
            "\t * too large.",
            "\t */",
            "\tsecend = shdr->sh_offset + shdr->sh_size;",
            "\tif (secend < shdr->sh_offset || secend > info->len)",
            "\t\treturn -ENOEXEC;",
            "",
            "\treturn 0;",
            "}",
            "static int elf_validity_cache_copy(struct load_info *info, int flags)",
            "{",
            "\tunsigned int i;",
            "\tElf_Shdr *shdr, *strhdr;",
            "\tint err;",
            "\tunsigned int num_mod_secs = 0, mod_idx;",
            "\tunsigned int num_info_secs = 0, info_idx;",
            "\tunsigned int num_sym_secs = 0, sym_idx;",
            "",
            "\tif (info->len < sizeof(*(info->hdr))) {",
            "\t\tpr_err(\"Invalid ELF header len %lu\\n\", info->len);",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\tif (memcmp(info->hdr->e_ident, ELFMAG, SELFMAG) != 0) {",
            "\t\tpr_err(\"Invalid ELF header magic: != %s\\n\", ELFMAG);",
            "\t\tgoto no_exec;",
            "\t}",
            "\tif (info->hdr->e_type != ET_REL) {",
            "\t\tpr_err(\"Invalid ELF header type: %u != %u\\n\",",
            "\t\t       info->hdr->e_type, ET_REL);",
            "\t\tgoto no_exec;",
            "\t}",
            "\tif (!elf_check_arch(info->hdr)) {",
            "\t\tpr_err(\"Invalid architecture in ELF header: %u\\n\",",
            "\t\t       info->hdr->e_machine);",
            "\t\tgoto no_exec;",
            "\t}",
            "\tif (!module_elf_check_arch(info->hdr)) {",
            "\t\tpr_err(\"Invalid module architecture in ELF header: %u\\n\",",
            "\t\t       info->hdr->e_machine);",
            "\t\tgoto no_exec;",
            "\t}",
            "\tif (info->hdr->e_shentsize != sizeof(Elf_Shdr)) {",
            "\t\tpr_err(\"Invalid ELF section header size\\n\");",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\t/*",
            "\t * e_shnum is 16 bits, and sizeof(Elf_Shdr) is",
            "\t * known and small. So e_shnum * sizeof(Elf_Shdr)",
            "\t * will not overflow unsigned long on any platform.",
            "\t */",
            "\tif (info->hdr->e_shoff >= info->len",
            "\t    || (info->hdr->e_shnum * sizeof(Elf_Shdr) >",
            "\t\tinfo->len - info->hdr->e_shoff)) {",
            "\t\tpr_err(\"Invalid ELF section header overflow\\n\");",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\tinfo->sechdrs = (void *)info->hdr + info->hdr->e_shoff;",
            "",
            "\t/*",
            "\t * Verify if the section name table index is valid.",
            "\t */",
            "\tif (info->hdr->e_shstrndx == SHN_UNDEF",
            "\t    || info->hdr->e_shstrndx >= info->hdr->e_shnum) {",
            "\t\tpr_err(\"Invalid ELF section name index: %d || e_shstrndx (%d) >= e_shnum (%d)\\n\",",
            "\t\t       info->hdr->e_shstrndx, info->hdr->e_shstrndx,",
            "\t\t       info->hdr->e_shnum);",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\tstrhdr = &info->sechdrs[info->hdr->e_shstrndx];",
            "\terr = validate_section_offset(info, strhdr);",
            "\tif (err < 0) {",
            "\t\tpr_err(\"Invalid ELF section hdr(type %u)\\n\", strhdr->sh_type);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/*",
            "\t * The section name table must be NUL-terminated, as required",
            "\t * by the spec. This makes strcmp and pr_* calls that access",
            "\t * strings in the section safe.",
            "\t */",
            "\tinfo->secstrings = (void *)info->hdr + strhdr->sh_offset;",
            "\tif (strhdr->sh_size == 0) {",
            "\t\tpr_err(\"empty section name table\\n\");",
            "\t\tgoto no_exec;",
            "\t}",
            "\tif (info->secstrings[strhdr->sh_size - 1] != '\\0') {",
            "\t\tpr_err(\"ELF Spec violation: section name table isn't null terminated\\n\");",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\t/*",
            "\t * The code assumes that section 0 has a length of zero and",
            "\t * an addr of zero, so check for it.",
            "\t */",
            "\tif (info->sechdrs[0].sh_type != SHT_NULL",
            "\t    || info->sechdrs[0].sh_size != 0",
            "\t    || info->sechdrs[0].sh_addr != 0) {",
            "\t\tpr_err(\"ELF Spec violation: section 0 type(%d)!=SH_NULL or non-zero len or addr\\n\",",
            "\t\t       info->sechdrs[0].sh_type);",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tshdr = &info->sechdrs[i];",
            "\t\tswitch (shdr->sh_type) {",
            "\t\tcase SHT_NULL:",
            "\t\tcase SHT_NOBITS:",
            "\t\t\tcontinue;",
            "\t\tcase SHT_SYMTAB:",
            "\t\t\tif (shdr->sh_link == SHN_UNDEF",
            "\t\t\t    || shdr->sh_link >= info->hdr->e_shnum) {",
            "\t\t\t\tpr_err(\"Invalid ELF sh_link!=SHN_UNDEF(%d) or (sh_link(%d) >= hdr->e_shnum(%d)\\n\",",
            "\t\t\t\t       shdr->sh_link, shdr->sh_link,",
            "\t\t\t\t       info->hdr->e_shnum);",
            "\t\t\t\tgoto no_exec;",
            "\t\t\t}",
            "\t\t\tnum_sym_secs++;",
            "\t\t\tsym_idx = i;",
            "\t\t\tfallthrough;",
            "\t\tdefault:",
            "\t\t\terr = validate_section_offset(info, shdr);",
            "\t\t\tif (err < 0) {",
            "\t\t\t\tpr_err(\"Invalid ELF section in module (section %u type %u)\\n\",",
            "\t\t\t\t\ti, shdr->sh_type);",
            "\t\t\t\treturn err;",
            "\t\t\t}",
            "\t\t\tif (strcmp(info->secstrings + shdr->sh_name,",
            "\t\t\t\t   \".gnu.linkonce.this_module\") == 0) {",
            "\t\t\t\tnum_mod_secs++;",
            "\t\t\t\tmod_idx = i;",
            "\t\t\t} else if (strcmp(info->secstrings + shdr->sh_name,",
            "\t\t\t\t   \".modinfo\") == 0) {",
            "\t\t\t\tnum_info_secs++;",
            "\t\t\t\tinfo_idx = i;",
            "\t\t\t}",
            "",
            "\t\t\tif (shdr->sh_flags & SHF_ALLOC) {",
            "\t\t\t\tif (shdr->sh_name >= strhdr->sh_size) {",
            "\t\t\t\t\tpr_err(\"Invalid ELF section name in module (section %u type %u)\\n\",",
            "\t\t\t\t\t       i, shdr->sh_type);",
            "\t\t\t\t\treturn -ENOEXEC;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (num_info_secs > 1) {",
            "\t\tpr_err(\"Only one .modinfo section must exist.\\n\");",
            "\t\tgoto no_exec;",
            "\t} else if (num_info_secs == 1) {",
            "\t\t/* Try to find a name early so we can log errors with a module name */",
            "\t\tinfo->index.info = info_idx;",
            "\t\tinfo->name = get_modinfo(info, \"name\");",
            "\t}",
            "",
            "\tif (num_sym_secs != 1) {",
            "\t\tpr_warn(\"%s: module has no symbols (stripped?)\\n\",",
            "\t\t\tinfo->name ?: \"(missing .modinfo section or name field)\");",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\t/* Sets internal symbols and strings. */",
            "\tinfo->index.sym = sym_idx;",
            "\tshdr = &info->sechdrs[sym_idx];",
            "\tinfo->index.str = shdr->sh_link;",
            "\tinfo->strtab = (char *)info->hdr + info->sechdrs[info->index.str].sh_offset;",
            "",
            "\t/*",
            "\t * The \".gnu.linkonce.this_module\" ELF section is special. It is",
            "\t * what modpost uses to refer to __this_module and let's use rely",
            "\t * on THIS_MODULE to point to &__this_module properly. The kernel's",
            "\t * modpost declares it on each modules's *.mod.c file. If the struct",
            "\t * module of the kernel changes a full kernel rebuild is required.",
            "\t *",
            "\t * We have a few expectaions for this special section, the following",
            "\t * code validates all this for us:",
            "\t *",
            "\t *   o Only one section must exist",
            "\t *   o We expect the kernel to always have to allocate it: SHF_ALLOC",
            "\t *   o The section size must match the kernel's run time's struct module",
            "\t *     size",
            "\t */",
            "\tif (num_mod_secs != 1) {",
            "\t\tpr_err(\"module %s: Only one .gnu.linkonce.this_module section must exist.\\n\",",
            "\t\t       info->name ?: \"(missing .modinfo section or name field)\");",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\tshdr = &info->sechdrs[mod_idx];",
            "",
            "\t/*",
            "\t * This is already implied on the switch above, however let's be",
            "\t * pedantic about it.",
            "\t */",
            "\tif (shdr->sh_type == SHT_NOBITS) {",
            "\t\tpr_err(\"module %s: .gnu.linkonce.this_module section must have a size set\\n\",",
            "\t\t       info->name ?: \"(missing .modinfo section or name field)\");",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\tif (!(shdr->sh_flags & SHF_ALLOC)) {",
            "\t\tpr_err(\"module %s: .gnu.linkonce.this_module must occupy memory during process execution\\n\",",
            "\t\t       info->name ?: \"(missing .modinfo section or name field)\");",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\tif (shdr->sh_size != sizeof(struct module)) {",
            "\t\tpr_err(\"module %s: .gnu.linkonce.this_module section size must match the kernel's built struct module size at run time\\n\",",
            "\t\t       info->name ?: \"(missing .modinfo section or name field)\");",
            "\t\tgoto no_exec;",
            "\t}",
            "",
            "\tinfo->index.mod = mod_idx;",
            "",
            "\t/* This is temporary: point mod into copy of data. */",
            "\tinfo->mod = (void *)info->hdr + shdr->sh_offset;",
            "",
            "\t/*",
            "\t * If we didn't load the .modinfo 'name' field earlier, fall back to",
            "\t * on-disk struct mod 'name' field.",
            "\t */",
            "\tif (!info->name)",
            "\t\tinfo->name = info->mod->name;",
            "",
            "\tif (flags & MODULE_INIT_IGNORE_MODVERSIONS)",
            "\t\tinfo->index.vers = 0; /* Pretend no __versions section! */",
            "\telse",
            "\t\tinfo->index.vers = find_sec(info, \"__versions\");",
            "",
            "\tinfo->index.pcpu = find_pcpusec(info);",
            "",
            "\treturn 0;",
            "",
            "no_exec:",
            "\treturn -ENOEXEC;",
            "}"
          ],
          "function_name": "layout_sections, module_license_taint_check, setup_modinfo, free_modinfo, module_init_section, module_exit_section, validate_section_offset, elf_validity_cache_copy",
          "description": "完成模块节布局(layout_sections)、许可证污点检测(module_license_taint_check)、模块信息处理(setup_modinfo/free_modinfo)及ELF有效性校验(elf_validity_cache_copy)，验证ELF头、节表结构完整性并识别关键元数据(section.modinfo/.gnu.linkonce.this_module)。",
          "similarity": 0.5652108192443848
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/module/main.c",
          "start_line": 2039,
          "end_line": 2252,
          "content": [
            "static void module_augment_kernel_taints(struct module *mod, struct load_info *info)",
            "{",
            "\tint prev_taint = test_taint(TAINT_PROPRIETARY_MODULE);",
            "",
            "\tif (!get_modinfo(info, \"intree\")) {",
            "\t\tif (!test_taint(TAINT_OOT_MODULE))",
            "\t\t\tpr_warn(\"%s: loading out-of-tree module taints kernel.\\n\",",
            "\t\t\t\tmod->name);",
            "\t\tadd_taint_module(mod, TAINT_OOT_MODULE, LOCKDEP_STILL_OK);",
            "\t}",
            "",
            "\tcheck_modinfo_retpoline(mod, info);",
            "",
            "\tif (get_modinfo(info, \"staging\")) {",
            "\t\tadd_taint_module(mod, TAINT_CRAP, LOCKDEP_STILL_OK);",
            "\t\tpr_warn(\"%s: module is from the staging directory, the quality \"",
            "\t\t\t\"is unknown, you have been warned.\\n\", mod->name);",
            "\t}",
            "",
            "\tif (is_livepatch_module(mod)) {",
            "\t\tadd_taint_module(mod, TAINT_LIVEPATCH, LOCKDEP_STILL_OK);",
            "\t\tpr_notice_once(\"%s: tainting kernel with TAINT_LIVEPATCH\\n\",",
            "\t\t\t\tmod->name);",
            "\t}",
            "",
            "\tmodule_license_taint_check(mod, get_modinfo(info, \"license\"));",
            "",
            "\tif (get_modinfo(info, \"test\")) {",
            "\t\tif (!test_taint(TAINT_TEST))",
            "\t\t\tpr_warn(\"%s: loading test module taints kernel.\\n\",",
            "\t\t\t\tmod->name);",
            "\t\tadd_taint_module(mod, TAINT_TEST, LOCKDEP_STILL_OK);",
            "\t}",
            "#ifdef CONFIG_MODULE_SIG",
            "\tmod->sig_ok = info->sig_ok;",
            "\tif (!mod->sig_ok) {",
            "\t\tpr_notice_once(\"%s: module verification failed: signature \"",
            "\t\t\t       \"and/or required key missing - tainting \"",
            "\t\t\t       \"kernel\\n\", mod->name);",
            "\t\tadd_taint_module(mod, TAINT_UNSIGNED_MODULE, LOCKDEP_STILL_OK);",
            "\t}",
            "#endif",
            "",
            "\t/*",
            "\t * ndiswrapper is under GPL by itself, but loads proprietary modules.",
            "\t * Don't use add_taint_module(), as it would prevent ndiswrapper from",
            "\t * using GPL-only symbols it needs.",
            "\t */",
            "\tif (strcmp(mod->name, \"ndiswrapper\") == 0)",
            "\t\tadd_taint(TAINT_PROPRIETARY_MODULE, LOCKDEP_NOW_UNRELIABLE);",
            "",
            "\t/* driverloader was caught wrongly pretending to be under GPL */",
            "\tif (strcmp(mod->name, \"driverloader\") == 0)",
            "\t\tadd_taint_module(mod, TAINT_PROPRIETARY_MODULE,",
            "\t\t\t\t LOCKDEP_NOW_UNRELIABLE);",
            "",
            "\t/* lve claims to be GPL but upstream won't provide source */",
            "\tif (strcmp(mod->name, \"lve\") == 0)",
            "\t\tadd_taint_module(mod, TAINT_PROPRIETARY_MODULE,",
            "\t\t\t\t LOCKDEP_NOW_UNRELIABLE);",
            "",
            "\tif (!prev_taint && test_taint(TAINT_PROPRIETARY_MODULE))",
            "\t\tpr_warn(\"%s: module license taints kernel.\\n\", mod->name);",
            "",
            "}",
            "static int check_modinfo(struct module *mod, struct load_info *info, int flags)",
            "{",
            "\tconst char *modmagic = get_modinfo(info, \"vermagic\");",
            "\tint err;",
            "",
            "\tif (flags & MODULE_INIT_IGNORE_VERMAGIC)",
            "\t\tmodmagic = NULL;",
            "",
            "\t/* This is allowed: modprobe --force will invalidate it. */",
            "\tif (!modmagic) {",
            "\t\terr = try_to_force_load(mod, \"bad vermagic\");",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t} else if (!same_magic(modmagic, vermagic, info->index.vers)) {",
            "\t\tpr_err(\"%s: version magic '%s' should be '%s'\\n\",",
            "\t\t       info->name, modmagic, vermagic);",
            "\t\treturn -ENOEXEC;",
            "\t}",
            "",
            "\terr = check_modinfo_livepatch(mod, info);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn 0;",
            "}",
            "static int find_module_sections(struct module *mod, struct load_info *info)",
            "{",
            "\tmod->kp = section_objs(info, \"__param\",",
            "\t\t\t       sizeof(*mod->kp), &mod->num_kp);",
            "\tmod->syms = section_objs(info, \"__ksymtab\",",
            "\t\t\t\t sizeof(*mod->syms), &mod->num_syms);",
            "\tmod->crcs = section_addr(info, \"__kcrctab\");",
            "\tmod->gpl_syms = section_objs(info, \"__ksymtab_gpl\",",
            "\t\t\t\t     sizeof(*mod->gpl_syms),",
            "\t\t\t\t     &mod->num_gpl_syms);",
            "\tmod->gpl_crcs = section_addr(info, \"__kcrctab_gpl\");",
            "",
            "#ifdef CONFIG_CONSTRUCTORS",
            "\tmod->ctors = section_objs(info, \".ctors\",",
            "\t\t\t\t  sizeof(*mod->ctors), &mod->num_ctors);",
            "\tif (!mod->ctors)",
            "\t\tmod->ctors = section_objs(info, \".init_array\",",
            "\t\t\t\tsizeof(*mod->ctors), &mod->num_ctors);",
            "\telse if (find_sec(info, \".init_array\")) {",
            "\t\t/*",
            "\t\t * This shouldn't happen with same compiler and binutils",
            "\t\t * building all parts of the module.",
            "\t\t */",
            "\t\tpr_warn(\"%s: has both .ctors and .init_array.\\n\",",
            "\t\t       mod->name);",
            "\t\treturn -EINVAL;",
            "\t}",
            "#endif",
            "",
            "\tmod->noinstr_text_start = section_objs(info, \".noinstr.text\", 1,",
            "\t\t\t\t\t\t&mod->noinstr_text_size);",
            "",
            "#ifdef CONFIG_TRACEPOINTS",
            "\tmod->tracepoints_ptrs = section_objs(info, \"__tracepoints_ptrs\",",
            "\t\t\t\t\t     sizeof(*mod->tracepoints_ptrs),",
            "\t\t\t\t\t     &mod->num_tracepoints);",
            "#endif",
            "#ifdef CONFIG_TREE_SRCU",
            "\tmod->srcu_struct_ptrs = section_objs(info, \"___srcu_struct_ptrs\",",
            "\t\t\t\t\t     sizeof(*mod->srcu_struct_ptrs),",
            "\t\t\t\t\t     &mod->num_srcu_structs);",
            "#endif",
            "#ifdef CONFIG_BPF_EVENTS",
            "\tmod->bpf_raw_events = section_objs(info, \"__bpf_raw_tp_map\",",
            "\t\t\t\t\t   sizeof(*mod->bpf_raw_events),",
            "\t\t\t\t\t   &mod->num_bpf_raw_events);",
            "#endif",
            "#ifdef CONFIG_DEBUG_INFO_BTF_MODULES",
            "\tmod->btf_data = any_section_objs(info, \".BTF\", 1, &mod->btf_data_size);",
            "\tmod->btf_base_data = any_section_objs(info, \".BTF.base\", 1,",
            "\t\t\t\t\t      &mod->btf_base_data_size);",
            "#endif",
            "#ifdef CONFIG_JUMP_LABEL",
            "\tmod->jump_entries = section_objs(info, \"__jump_table\",",
            "\t\t\t\t\tsizeof(*mod->jump_entries),",
            "\t\t\t\t\t&mod->num_jump_entries);",
            "#endif",
            "#ifdef CONFIG_EVENT_TRACING",
            "\tmod->trace_events = section_objs(info, \"_ftrace_events\",",
            "\t\t\t\t\t sizeof(*mod->trace_events),",
            "\t\t\t\t\t &mod->num_trace_events);",
            "\tmod->trace_evals = section_objs(info, \"_ftrace_eval_map\",",
            "\t\t\t\t\tsizeof(*mod->trace_evals),",
            "\t\t\t\t\t&mod->num_trace_evals);",
            "#endif",
            "#ifdef CONFIG_TRACING",
            "\tmod->trace_bprintk_fmt_start = section_objs(info, \"__trace_printk_fmt\",",
            "\t\t\t\t\t sizeof(*mod->trace_bprintk_fmt_start),",
            "\t\t\t\t\t &mod->num_trace_bprintk_fmt);",
            "#endif",
            "#ifdef CONFIG_FTRACE_MCOUNT_RECORD",
            "\t/* sechdrs[0].sh_size is always zero */",
            "\tmod->ftrace_callsites = section_objs(info, FTRACE_CALLSITE_SECTION,",
            "\t\t\t\t\t     sizeof(*mod->ftrace_callsites),",
            "\t\t\t\t\t     &mod->num_ftrace_callsites);",
            "#endif",
            "#ifdef CONFIG_FUNCTION_ERROR_INJECTION",
            "\tmod->ei_funcs = section_objs(info, \"_error_injection_whitelist\",",
            "\t\t\t\t\t    sizeof(*mod->ei_funcs),",
            "\t\t\t\t\t    &mod->num_ei_funcs);",
            "#endif",
            "#ifdef CONFIG_KPROBES",
            "\tmod->kprobes_text_start = section_objs(info, \".kprobes.text\", 1,",
            "\t\t\t\t\t\t&mod->kprobes_text_size);",
            "\tmod->kprobe_blacklist = section_objs(info, \"_kprobe_blacklist\",",
            "\t\t\t\t\t\tsizeof(unsigned long),",
            "\t\t\t\t\t\t&mod->num_kprobe_blacklist);",
            "#endif",
            "#ifdef CONFIG_PRINTK_INDEX",
            "\tmod->printk_index_start = section_objs(info, \".printk_index\",",
            "\t\t\t\t\t       sizeof(*mod->printk_index_start),",
            "\t\t\t\t\t       &mod->printk_index_size);",
            "#endif",
            "#ifdef CONFIG_HAVE_STATIC_CALL_INLINE",
            "\tmod->static_call_sites = section_objs(info, \".static_call_sites\",",
            "\t\t\t\t\t      sizeof(*mod->static_call_sites),",
            "\t\t\t\t\t      &mod->num_static_call_sites);",
            "#endif",
            "#if IS_ENABLED(CONFIG_KUNIT)",
            "\tmod->kunit_suites = section_objs(info, \".kunit_test_suites\",",
            "\t\t\t\t\t      sizeof(*mod->kunit_suites),",
            "\t\t\t\t\t      &mod->num_kunit_suites);",
            "\tmod->kunit_init_suites = section_objs(info, \".kunit_init_test_suites\",",
            "\t\t\t\t\t      sizeof(*mod->kunit_init_suites),",
            "\t\t\t\t\t      &mod->num_kunit_init_suites);",
            "#endif",
            "",
            "\tmod->extable = section_objs(info, \"__ex_table\",",
            "\t\t\t\t    sizeof(*mod->extable), &mod->num_exentries);",
            "",
            "\tif (section_addr(info, \"__obsparm\"))",
            "\t\tpr_warn(\"%s: Ignoring obsolete parameters\\n\", mod->name);",
            "",
            "#ifdef CONFIG_DYNAMIC_DEBUG_CORE",
            "\tmod->dyndbg_info.descs = section_objs(info, \"__dyndbg\",",
            "\t\t\t\t\t      sizeof(*mod->dyndbg_info.descs),",
            "\t\t\t\t\t      &mod->dyndbg_info.num_descs);",
            "\tmod->dyndbg_info.classes = section_objs(info, \"__dyndbg_classes\",",
            "\t\t\t\t\t\tsizeof(*mod->dyndbg_info.classes),",
            "\t\t\t\t\t\t&mod->dyndbg_info.num_classes);",
            "#endif",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "module_augment_kernel_taints, check_modinfo, find_module_sections",
          "description": "根据模块元信息增强内核污点标记，验证版本魔法字符串，解析模块各节区信息并填充至module结构体，处理特殊节区如ctors、tracepoints等",
          "similarity": 0.5538210272789001
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/module/main.c",
          "start_line": 2666,
          "end_line": 2781,
          "content": [
            "static int may_init_module(void)",
            "{",
            "\tif (!capable(CAP_SYS_MODULE) || modules_disabled)",
            "\t\treturn -EPERM;",
            "",
            "\treturn 0;",
            "}",
            "static bool finished_loading(const char *name)",
            "{",
            "\tstruct module *mod;",
            "\tbool ret;",
            "",
            "\t/*",
            "\t * The module_mutex should not be a heavily contended lock;",
            "\t * if we get the occasional sleep here, we'll go an extra iteration",
            "\t * in the wait_event_interruptible(), which is harmless.",
            "\t */",
            "\tsched_annotate_sleep();",
            "\tmutex_lock(&module_mutex);",
            "\tmod = find_module_all(name, strlen(name), true);",
            "\tret = !mod || mod->state == MODULE_STATE_LIVE",
            "\t\t|| mod->state == MODULE_STATE_GOING;",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\treturn ret;",
            "}",
            "static int module_patient_check_exists(const char *name,",
            "\t\t\t\t       enum fail_dup_mod_reason reason)",
            "{",
            "\tstruct module *old;",
            "\tint err = 0;",
            "",
            "\told = find_module_all(name, strlen(name), true);",
            "\tif (old == NULL)",
            "\t\treturn 0;",
            "",
            "\tif (old->state == MODULE_STATE_COMING ||",
            "\t    old->state == MODULE_STATE_UNFORMED) {",
            "\t\t/* Wait in case it fails to load. */",
            "\t\tmutex_unlock(&module_mutex);",
            "\t\terr = wait_event_interruptible(module_wq,",
            "\t\t\t\t       finished_loading(name));",
            "\t\tmutex_lock(&module_mutex);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "",
            "\t\t/* The module might have gone in the meantime. */",
            "\t\told = find_module_all(name, strlen(name), true);",
            "\t}",
            "",
            "\tif (try_add_failed_module(name, reason))",
            "\t\tpr_warn(\"Could not add fail-tracking for module: %s\\n\", name);",
            "",
            "\t/*",
            "\t * We are here only when the same module was being loaded. Do",
            "\t * not try to load it again right now. It prevents long delays",
            "\t * caused by serialized module load failures. It might happen",
            "\t * when more devices of the same type trigger load of",
            "\t * a particular module.",
            "\t */",
            "\tif (old && old->state == MODULE_STATE_LIVE)",
            "\t\treturn -EEXIST;",
            "\treturn -EBUSY;",
            "}",
            "static int add_unformed_module(struct module *mod)",
            "{",
            "\tint err;",
            "",
            "\tmod->state = MODULE_STATE_UNFORMED;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\terr = module_patient_check_exists(mod->name, FAIL_DUP_MOD_LOAD);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\tmod_update_bounds(mod);",
            "\tlist_add_rcu(&mod->list, &modules);",
            "\tmod_tree_insert(mod);",
            "\terr = 0;",
            "",
            "out:",
            "\tmutex_unlock(&module_mutex);",
            "\treturn err;",
            "}",
            "static int complete_formation(struct module *mod, struct load_info *info)",
            "{",
            "\tint err;",
            "",
            "\tmutex_lock(&module_mutex);",
            "",
            "\t/* Find duplicate symbols (must be called under lock). */",
            "\terr = verify_exported_symbols(mod);",
            "\tif (err < 0)",
            "\t\tgoto out;",
            "",
            "\t/* These rely on module_mutex for list integrity. */",
            "\tmodule_bug_finalize(info->hdr, info->sechdrs, mod);",
            "\tmodule_cfi_finalize(info->hdr, info->sechdrs, mod);",
            "",
            "\tmodule_enable_ro(mod, false);",
            "\tmodule_enable_nx(mod);",
            "\tmodule_enable_x(mod);",
            "",
            "\t/*",
            "\t * Mark state as coming so strong_try_module_get() ignores us,",
            "\t * but kallsyms etc. can see us.",
            "\t */",
            "\tmod->state = MODULE_STATE_COMING;",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\treturn 0;",
            "",
            "out:",
            "\tmutex_unlock(&module_mutex);",
            "\treturn err;",
            "}"
          ],
          "function_name": "may_init_module, finished_loading, module_patient_check_exists, add_unformed_module, complete_formation",
          "description": "检查模块加载权限，确认模块是否已完成加载，处理重复模块加载场景，将未完全形成的模块加入系统，完成模块最终形成流程包括符号验证和只读标记设置",
          "similarity": 0.5505900979042053
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/main.c",
          "start_line": 96,
          "end_line": 202,
          "content": [
            "static void __mod_update_bounds(enum mod_mem_type type __maybe_unused, void *base,",
            "\t\t\t\tunsigned int size, struct mod_tree_root *tree)",
            "{",
            "\tunsigned long min = (unsigned long)base;",
            "\tunsigned long max = min + size;",
            "",
            "#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC",
            "\tif (mod_mem_type_is_core_data(type)) {",
            "\t\tif (min < tree->data_addr_min)",
            "\t\t\ttree->data_addr_min = min;",
            "\t\tif (max > tree->data_addr_max)",
            "\t\t\ttree->data_addr_max = max;",
            "\t\treturn;",
            "\t}",
            "#endif",
            "\tif (min < tree->addr_min)",
            "\t\ttree->addr_min = min;",
            "\tif (max > tree->addr_max)",
            "\t\ttree->addr_max = max;",
            "}",
            "static void mod_update_bounds(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size)",
            "\t\t\t__mod_update_bounds(type, mod_mem->base, mod_mem->size, &mod_tree);",
            "\t}",
            "}",
            "int register_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&module_notify_list, nb);",
            "}",
            "int unregister_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);",
            "}",
            "static inline int strong_try_module_get(struct module *mod)",
            "{",
            "\tBUG_ON(mod && mod->state == MODULE_STATE_UNFORMED);",
            "\tif (mod && mod->state == MODULE_STATE_COMING)",
            "\t\treturn -EBUSY;",
            "\tif (try_module_get(mod))",
            "\t\treturn 0;",
            "\telse",
            "\t\treturn -ENOENT;",
            "}",
            "static inline void add_taint_module(struct module *mod, unsigned flag,",
            "\t\t\t\t    enum lockdep_ok lockdep_ok)",
            "{",
            "\tadd_taint(flag, lockdep_ok);",
            "\tset_bit(flag, &mod->taints);",
            "}",
            "void __noreturn __module_put_and_kthread_exit(struct module *mod, long code)",
            "{",
            "\tmodule_put(mod);",
            "\tkthread_exit(code);",
            "}",
            "static unsigned int find_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\t/* Alloc bit cleared means \"ignore it.\" */",
            "\t\tif ((shdr->sh_flags & SHF_ALLOC)",
            "\t\t    && strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "static unsigned int find_any_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tif (strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "int cmp_name(const void *name, const void *sym)",
            "{",
            "\treturn strcmp(name, kernel_symbol_name(sym));",
            "}",
            "static bool find_exported_symbol_in_section(const struct symsearch *syms,",
            "\t\t\t\t\t    struct module *owner,",
            "\t\t\t\t\t    struct find_symbol_arg *fsa)",
            "{",
            "\tstruct kernel_symbol *sym;",
            "",
            "\tif (!fsa->gplok && syms->license == GPL_ONLY)",
            "\t\treturn false;",
            "",
            "\tsym = bsearch(fsa->name, syms->start, syms->stop - syms->start,",
            "\t\t\tsizeof(struct kernel_symbol), cmp_name);",
            "\tif (!sym)",
            "\t\treturn false;",
            "",
            "\tfsa->owner = owner;",
            "\tfsa->crc = symversion(syms->crcs, sym - syms->start);",
            "\tfsa->sym = sym;",
            "\tfsa->license = syms->license;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "__mod_update_bounds, mod_update_bounds, register_module_notifier, unregister_module_notifier, strong_try_module_get, add_taint_module, __module_put_and_kthread_exit, find_sec, find_any_sec, cmp_name, find_exported_symbol_in_section",
          "description": "实现模块内存边界更新逻辑、模块状态变更通知注册与注销接口，以及强引用获取检查函数，用于维护模块内存范围并控制模块生命周期事件。",
          "similarity": 0.5467038154602051
        }
      ]
    }
  ]
}