{
  "query": "Docker image format",
  "timestamp": "2025-12-26 01:50:37",
  "retrieved_files": [
    {
      "source_file": "mm/shrinker.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:19:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `shrinker.c`\n\n---\n\n# shrinker.c 技术文档\n\n## 1. 文件概述\n\n`shrinker.c` 是 Linux 内核内存管理子系统中负责管理 **shrinker**（收缩器）机制的核心实现文件。Shrinker 是一种回调机制，允许内核子系统（如 dentry、inode、buffer cache 等）在系统内存压力下释放可回收的缓存对象。该文件主要实现了：\n\n- 全局 shrinker 列表的注册与管理\n- 基于 cgroup v2 的 memcg（memory control group）感知的 shrinker 支持\n- 每个 memcg 对每个 shrinker 的延迟扫描计数（`nr_deferred`）和活跃状态位图（`shrinker_bit`）的动态分配与维护\n- 在 memcg 层级结构变化（如 cgroup 删除）时，将子 cgroup 的 deferred 计数迁移至父 cgroup（reparent）\n\n该文件特别关注 **memcg-aware shrinker** 的可扩展性设计，通过分块（unit-based）数据结构支持动态增长的 shrinker ID 空间。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `shrinker_list`：全局链表，用于链接所有已注册的 `struct shrinker` 实例。\n- `shrinker_mutex`：保护 shrinker 注册/注销及 memcg shrinker info 扩展操作的互斥锁。\n- `shrinker_idr`（仅 CONFIG_MEMCG）：IDR 结构，为每个 memcg-aware shrinker 分配唯一 ID。\n- `shrinker_nr_max`（仅 CONFIG_MEMCG）：当前系统中 shrinker ID 的最大值（向上对齐到 `SHRINKER_UNIT_BITS`）。\n\n### 主要数据结构（仅 CONFIG_MEMCG）\n- `struct shrinker_info`：每个 memcg 每个 NUMA 节点维护的 shrinker 元数据容器。\n- `struct shrinker_info_unit`：`shrinker_info` 中的分块单元，包含：\n  - `map[SHRINKER_UNIT_BITS]`：位图，标记对应 shrinker 是否在此 memcg 中有可回收对象。\n  - `nr_deferred[SHRINKER_UNIT_BITS]`：原子长整型数组，记录每个 shrinker 在此 memcg 中的延迟扫描计数。\n\n### 主要函数\n\n#### 全局 shrinker 管理\n- `register_shrinker()` / `unregister_shrinker()`（定义在其他文件，但使用本文件的 list 和 mutex）\n\n#### Memcg Shrinker Info 生命周期管理（仅 CONFIG_MEMCG）\n- `alloc_shrinker_info(struct mem_cgroup *memcg)`：为指定 memcg 分配所有 NUMA 节点的 `shrinker_info`。\n- `free_shrinker_info(struct mem_cgroup *memcg)`：释放指定 memcg 的所有 `shrinker_info`。\n- `expand_shrinker_info(int new_id)`：当新 shrinker ID 超出当前 `shrinker_nr_max` 时，扩展所有 memcg 的 `shrinker_info` 容量。\n\n#### Shrinker 状态操作（仅 CONFIG_MEMCG）\n- `set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)`：设置指定 memcg/nid/shrinker 的活跃位。\n- `xchg_nr_deferred_memcg()` / `add_nr_deferred_memcg()`：原子地交换或增加指定 shrinker 在 memcg 中的 deferred 计数。\n\n#### Memcg 层级维护\n- `reparent_shrinker_deferred(struct mem_cgroup *memcg)`：将被销毁 memcg 的 deferred 计数累加到其父 memcg。\n\n#### 辅助函数（条件编译）\n- `shrinker_memcg_alloc()` / `shrinker_memcg_remove()`：为 shrinker 分配/移除 memcg ID。\n- `xchg_nr_deferred()` / `add_nr_deferred()`：根据是否启用 memcg，调用全局或 memcg 特定的 deferred 操作。\n\n## 3. 关键实现\n\n### 动态可扩展的 Shrinker ID 管理\n- 使用 `idr` 为每个 memcg-aware shrinker 分配唯一 ID。\n- `shrinker_nr_max` 记录当前最大 ID（向上对齐到 `SHRINKER_UNIT_BITS`，通常为 `PAGE_SIZE * 8`）。\n- 当新 shrinker ID ≥ `shrinker_nr_max` 时，调用 `expand_shrinker_info()` 遍历所有 memcg，为其 `shrinker_info` 分配更多 `shrinker_info_unit` 块。\n\n### 分块存储设计（Unit-based Storage）\n- `shrinker_info` 不直接存储大数组，而是通过指针数组 `unit[]` 指向多个 `shrinker_info_unit`。\n- 每个 `unit` 管理 `SHRINKER_UNIT_BITS` 个 shrinker 的状态（位图 + deferred 计数）。\n- 扩展时只需分配新增的 unit 块，已有数据通过 `memcpy` 复用，避免全量重分配。\n\n### RCU 与锁协同\n- `shrinker_info` 的读取使用 RCU（`rcu_dereference`），保证扫描路径无锁。\n- 修改（分配、扩展、释放）受 `shrinker_mutex` 保护，并使用 `rcu_assign_pointer` / `kvfree_rcu` 实现安全替换。\n\n### Deferred 计数迁移（Reparenting）\n- 当 memcg 被销毁时，其所有 shrinker 的 deferred 计数需合并到父 memcg。\n- 通过 `reparent_shrinker_deferred()` 在 `shrinker_mutex` 保护下遍历所有 shrinker 单元，原子累加计数。\n\n### 内存节点（NUMA）感知\n- 每个 memcg 为每个 NUMA 节点维护独立的 `shrinker_info`，支持 `SHRINKER_NUMA_AWARE` shrinker 按节点回收。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memcontrol.h>`：memcg 核心接口\n  - `<linux/shrinker.h>`：shrinker 结构定义\n  - `<linux/rculist.h>`：RCU 保护的链表操作\n  - `\"internal.h\"`：mm 子系统内部头文件\n- **内核配置依赖**：\n  - `CONFIG_MEMCG`：启用 memcg-aware shrinker 支持\n  - `CONFIG_SHRINKER_DEBUG`（间接）：可能影响 tracepoint 行为\n- **协作模块**：\n  - VFS（dentry/inode cache）、Buffer Cache、Tmpfs 等通过注册 shrinker 使用此机制\n  - Memory Cgroup（memcg）子系统提供层级结构和 per-node 数据\n  - VM writeback 和 kswapd 调用 shrinker 回调进行内存回收\n\n## 5. 使用场景\n\n1. **内存压力下的缓存回收**：\n   - 当系统内存不足时，kswapd 或 direct reclaim 路径调用 `shrink_slab()`，遍历 `shrinker_list` 并执行各 shrinker 的 `.scan_objects` 回调。\n\n2. **Memcg 内存限制回收**：\n   - 当某个 memcg 超过内存限制时，reclaim 过程会针对该 memcg 调用 shrinker，利用 `shrinker_bit` 快速判断哪些 shrinker 在此 memcg 中有对象，避免无效扫描。\n\n3. **Shrinker 注册/注销**：\n   - 子系统初始化时调用 `register_shrinker()`，将 shrinker 加入全局列表；模块卸载时调用 `unregister_shrinker()` 移除。\n\n4. **Cgroup 层级变更**：\n   - 当 memcg 被删除时，其资源（包括 shrinker deferred 计数）通过 `reparent_shrinker_deferred()` 迁移到父 cgroup，确保回收逻辑连续性。\n\n5. **动态 Shrinker 扩展**：\n   - 系统运行时加载新模块（如新文件系统）注册 shrinker，若 ID 超出现有范围，自动触发 `expand_shrinker_info()` 扩容所有 memcg 的元数据。",
      "similarity": 0.5043121576309204,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/shrinker.c",
          "start_line": 16,
          "end_line": 136,
          "content": [
            "static inline int shrinker_unit_size(int nr_items)",
            "{",
            "\treturn (DIV_ROUND_UP(nr_items, SHRINKER_UNIT_BITS) * sizeof(struct shrinker_info_unit *));",
            "}",
            "static inline void shrinker_unit_free(struct shrinker_info *info, int start)",
            "{",
            "\tstruct shrinker_info_unit **unit;",
            "\tint nr, i;",
            "",
            "\tif (!info)",
            "\t\treturn;",
            "",
            "\tunit = info->unit;",
            "\tnr = DIV_ROUND_UP(info->map_nr_max, SHRINKER_UNIT_BITS);",
            "",
            "\tfor (i = start; i < nr; i++) {",
            "\t\tif (!unit[i])",
            "\t\t\tbreak;",
            "",
            "\t\tkfree(unit[i]);",
            "\t\tunit[i] = NULL;",
            "\t}",
            "}",
            "static inline int shrinker_unit_alloc(struct shrinker_info *new,",
            "\t\t\t\t       struct shrinker_info *old, int nid)",
            "{",
            "\tstruct shrinker_info_unit *unit;",
            "\tint nr = DIV_ROUND_UP(new->map_nr_max, SHRINKER_UNIT_BITS);",
            "\tint start = old ? DIV_ROUND_UP(old->map_nr_max, SHRINKER_UNIT_BITS) : 0;",
            "\tint i;",
            "",
            "\tfor (i = start; i < nr; i++) {",
            "\t\tunit = kzalloc_node(sizeof(*unit), GFP_KERNEL, nid);",
            "\t\tif (!unit) {",
            "\t\t\tshrinker_unit_free(new, start);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "",
            "\t\tnew->unit[i] = unit;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void free_shrinker_info(struct mem_cgroup *memcg)",
            "{",
            "\tstruct mem_cgroup_per_node *pn;",
            "\tstruct shrinker_info *info;",
            "\tint nid;",
            "",
            "\tfor_each_node(nid) {",
            "\t\tpn = memcg->nodeinfo[nid];",
            "\t\tinfo = rcu_dereference_protected(pn->shrinker_info, true);",
            "\t\tshrinker_unit_free(info, 0);",
            "\t\tkvfree(info);",
            "\t\trcu_assign_pointer(pn->shrinker_info, NULL);",
            "\t}",
            "}",
            "int alloc_shrinker_info(struct mem_cgroup *memcg)",
            "{",
            "\tint nid, ret = 0;",
            "\tint array_size = 0;",
            "",
            "\tmutex_lock(&shrinker_mutex);",
            "\tarray_size = shrinker_unit_size(shrinker_nr_max);",
            "\tfor_each_node(nid) {",
            "\t\tstruct shrinker_info *info = kvzalloc_node(sizeof(*info) + array_size,",
            "\t\t\t\t\t\t\t   GFP_KERNEL, nid);",
            "\t\tif (!info)",
            "\t\t\tgoto err;",
            "\t\tinfo->map_nr_max = shrinker_nr_max;",
            "\t\tif (shrinker_unit_alloc(info, NULL, nid)) {",
            "\t\t\tkvfree(info);",
            "\t\t\tgoto err;",
            "\t\t}",
            "\t\trcu_assign_pointer(memcg->nodeinfo[nid]->shrinker_info, info);",
            "\t}",
            "\tmutex_unlock(&shrinker_mutex);",
            "",
            "\treturn ret;",
            "",
            "err:",
            "\tmutex_unlock(&shrinker_mutex);",
            "\tfree_shrinker_info(memcg);",
            "\treturn -ENOMEM;",
            "}",
            "static int expand_one_shrinker_info(struct mem_cgroup *memcg, int new_size,",
            "\t\t\t\t    int old_size, int new_nr_max)",
            "{",
            "\tstruct shrinker_info *new, *old;",
            "\tstruct mem_cgroup_per_node *pn;",
            "\tint nid;",
            "",
            "\tfor_each_node(nid) {",
            "\t\tpn = memcg->nodeinfo[nid];",
            "\t\told = shrinker_info_protected(memcg, nid);",
            "\t\t/* Not yet online memcg */",
            "\t\tif (!old)",
            "\t\t\treturn 0;",
            "",
            "\t\t/* Already expanded this shrinker_info */",
            "\t\tif (new_nr_max <= old->map_nr_max)",
            "\t\t\tcontinue;",
            "",
            "\t\tnew = kvzalloc_node(sizeof(*new) + new_size, GFP_KERNEL, nid);",
            "\t\tif (!new)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\tnew->map_nr_max = new_nr_max;",
            "",
            "\t\tmemcpy(new->unit, old->unit, old_size);",
            "\t\tif (shrinker_unit_alloc(new, old, nid)) {",
            "\t\t\tkvfree(new);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "",
            "\t\trcu_assign_pointer(pn->shrinker_info, new);",
            "\t\tkvfree_rcu(old, rcu);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "shrinker_unit_size, shrinker_unit_free, shrinker_unit_alloc, free_shrinker_info, alloc_shrinker_info, expand_one_shrinker_info",
          "description": "实现shrinker_info单元的动态内存管理，包含单位尺寸计算、单元释放/分配逻辑，以及mem_cgroup的shrinker_info结构体的创建与销毁操作。",
          "similarity": 0.4416259527206421
        },
        {
          "chunk_id": 3,
          "file_path": "mm/shrinker.c",
          "start_line": 268,
          "end_line": 454,
          "content": [
            "static long add_nr_deferred_memcg(long nr, int nid, struct shrinker *shrinker,",
            "\t\t\t\t  struct mem_cgroup *memcg)",
            "{",
            "\tstruct shrinker_info *info;",
            "\tstruct shrinker_info_unit *unit;",
            "\tlong nr_deferred;",
            "",
            "\trcu_read_lock();",
            "\tinfo = rcu_dereference(memcg->nodeinfo[nid]->shrinker_info);",
            "\tunit = info->unit[shrinker_id_to_index(shrinker->id)];",
            "\tnr_deferred =",
            "\t\tatomic_long_add_return(nr, &unit->nr_deferred[shrinker_id_to_offset(shrinker->id)]);",
            "\trcu_read_unlock();",
            "",
            "\treturn nr_deferred;",
            "}",
            "void reparent_shrinker_deferred(struct mem_cgroup *memcg)",
            "{",
            "\tint nid, index, offset;",
            "\tlong nr;",
            "\tstruct mem_cgroup *parent;",
            "\tstruct shrinker_info *child_info, *parent_info;",
            "\tstruct shrinker_info_unit *child_unit, *parent_unit;",
            "",
            "\tparent = parent_mem_cgroup(memcg);",
            "\tif (!parent)",
            "\t\tparent = root_mem_cgroup;",
            "",
            "\t/* Prevent from concurrent shrinker_info expand */",
            "\tmutex_lock(&shrinker_mutex);",
            "\tfor_each_node(nid) {",
            "\t\tchild_info = shrinker_info_protected(memcg, nid);",
            "\t\tparent_info = shrinker_info_protected(parent, nid);",
            "\t\tfor (index = 0; index < shrinker_id_to_index(child_info->map_nr_max); index++) {",
            "\t\t\tchild_unit = child_info->unit[index];",
            "\t\t\tparent_unit = parent_info->unit[index];",
            "\t\t\tfor (offset = 0; offset < SHRINKER_UNIT_BITS; offset++) {",
            "\t\t\t\tnr = atomic_long_read(&child_unit->nr_deferred[offset]);",
            "\t\t\t\tatomic_long_add(nr, &parent_unit->nr_deferred[offset]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&shrinker_mutex);",
            "}",
            "static int shrinker_memcg_alloc(struct shrinker *shrinker)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "static void shrinker_memcg_remove(struct shrinker *shrinker)",
            "{",
            "}",
            "static long xchg_nr_deferred_memcg(int nid, struct shrinker *shrinker,",
            "\t\t\t\t   struct mem_cgroup *memcg)",
            "{",
            "\treturn 0;",
            "}",
            "static long add_nr_deferred_memcg(long nr, int nid, struct shrinker *shrinker,",
            "\t\t\t\t  struct mem_cgroup *memcg)",
            "{",
            "\treturn 0;",
            "}",
            "static long xchg_nr_deferred(struct shrinker *shrinker,",
            "\t\t\t     struct shrink_control *sc)",
            "{",
            "\tint nid = sc->nid;",
            "",
            "\tif (!(shrinker->flags & SHRINKER_NUMA_AWARE))",
            "\t\tnid = 0;",
            "",
            "\tif (sc->memcg &&",
            "\t    (shrinker->flags & SHRINKER_MEMCG_AWARE))",
            "\t\treturn xchg_nr_deferred_memcg(nid, shrinker,",
            "\t\t\t\t\t      sc->memcg);",
            "",
            "\treturn atomic_long_xchg(&shrinker->nr_deferred[nid], 0);",
            "}",
            "static long add_nr_deferred(long nr, struct shrinker *shrinker,",
            "\t\t\t    struct shrink_control *sc)",
            "{",
            "\tint nid = sc->nid;",
            "",
            "\tif (!(shrinker->flags & SHRINKER_NUMA_AWARE))",
            "\t\tnid = 0;",
            "",
            "\tif (sc->memcg &&",
            "\t    (shrinker->flags & SHRINKER_MEMCG_AWARE))",
            "\t\treturn add_nr_deferred_memcg(nr, nid, shrinker,",
            "\t\t\t\t\t     sc->memcg);",
            "",
            "\treturn atomic_long_add_return(nr, &shrinker->nr_deferred[nid]);",
            "}",
            "static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,",
            "\t\t\t\t    struct shrinker *shrinker, int priority)",
            "{",
            "\tunsigned long freed = 0;",
            "\tunsigned long long delta;",
            "\tlong total_scan;",
            "\tlong freeable;",
            "\tlong nr;",
            "\tlong new_nr;",
            "\tlong batch_size = shrinker->batch ? shrinker->batch",
            "\t\t\t\t\t  : SHRINK_BATCH;",
            "\tlong scanned = 0, next_deferred;",
            "",
            "\tfreeable = shrinker->count_objects(shrinker, shrinkctl);",
            "\tif (freeable == 0 || freeable == SHRINK_EMPTY)",
            "\t\treturn freeable;",
            "",
            "\t/*",
            "\t * copy the current shrinker scan count into a local variable",
            "\t * and zero it so that other concurrent shrinker invocations",
            "\t * don't also do this scanning work.",
            "\t */",
            "\tnr = xchg_nr_deferred(shrinker, shrinkctl);",
            "",
            "\tif (shrinker->seeks) {",
            "\t\tdelta = freeable >> priority;",
            "\t\tdelta *= 4;",
            "\t\tdo_div(delta, shrinker->seeks);",
            "\t} else {",
            "\t\t/*",
            "\t\t * These objects don't require any IO to create. Trim",
            "\t\t * them aggressively under memory pressure to keep",
            "\t\t * them from causing refetches in the IO caches.",
            "\t\t */",
            "\t\tdelta = freeable / 2;",
            "\t}",
            "",
            "\ttotal_scan = nr >> priority;",
            "\ttotal_scan += delta;",
            "\ttotal_scan = min(total_scan, (2 * freeable));",
            "",
            "\ttrace_mm_shrink_slab_start(shrinker, shrinkctl, nr,",
            "\t\t\t\t   freeable, delta, total_scan, priority);",
            "",
            "\t/*",
            "\t * Normally, we should not scan less than batch_size objects in one",
            "\t * pass to avoid too frequent shrinker calls, but if the slab has less",
            "\t * than batch_size objects in total and we are really tight on memory,",
            "\t * we will try to reclaim all available objects, otherwise we can end",
            "\t * up failing allocations although there are plenty of reclaimable",
            "\t * objects spread over several slabs with usage less than the",
            "\t * batch_size.",
            "\t *",
            "\t * We detect the \"tight on memory\" situations by looking at the total",
            "\t * number of objects we want to scan (total_scan). If it is greater",
            "\t * than the total number of objects on slab (freeable), we must be",
            "\t * scanning at high prio and therefore should try to reclaim as much as",
            "\t * possible.",
            "\t */",
            "\twhile (total_scan >= batch_size ||",
            "\t       total_scan >= freeable) {",
            "\t\tunsigned long ret;",
            "\t\tunsigned long nr_to_scan = min(batch_size, total_scan);",
            "",
            "\t\tshrinkctl->nr_to_scan = nr_to_scan;",
            "\t\tshrinkctl->nr_scanned = nr_to_scan;",
            "\t\tret = shrinker->scan_objects(shrinker, shrinkctl);",
            "\t\tif (ret == SHRINK_STOP)",
            "\t\t\tbreak;",
            "\t\tfreed += ret;",
            "",
            "\t\tcount_vm_events(SLABS_SCANNED, shrinkctl->nr_scanned);",
            "\t\ttotal_scan -= shrinkctl->nr_scanned;",
            "\t\tscanned += shrinkctl->nr_scanned;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\t/*",
            "\t * The deferred work is increased by any new work (delta) that wasn't",
            "\t * done, decreased by old deferred work that was done now.",
            "\t *",
            "\t * And it is capped to two times of the freeable items.",
            "\t */",
            "\tnext_deferred = max_t(long, (nr + delta - scanned), 0);",
            "\tnext_deferred = min(next_deferred, (2 * freeable));",
            "",
            "\t/*",
            "\t * move the unused scan count back into the shrinker in a",
            "\t * manner that handles concurrent updates.",
            "\t */",
            "\tnew_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);",
            "",
            "\ttrace_mm_shrink_slab_end(shrinker, shrinkctl->nid, freed, nr, new_nr, total_scan);",
            "\treturn freed;",
            "}"
          ],
          "function_name": "add_nr_deferred_memcg, reparent_shrinker_deferred, shrinker_memcg_alloc, shrinker_memcg_remove, xchg_nr_deferred_memcg, add_nr_deferred_memcg, xchg_nr_deferred, add_nr_deferred, do_shrink_slab",
          "description": "实现延迟扫描计数管理，包含跨内存控制组的缩减器数据迁移（reparent_shrinker_deferred），以及执行实际对象回收的do_shrink_slab函数。",
          "similarity": 0.4318949580192566
        },
        {
          "chunk_id": 2,
          "file_path": "mm/shrinker.c",
          "start_line": 150,
          "end_line": 257,
          "content": [
            "static int expand_shrinker_info(int new_id)",
            "{",
            "\tint ret = 0;",
            "\tint new_nr_max = round_up(new_id + 1, SHRINKER_UNIT_BITS);",
            "\tint new_size, old_size = 0;",
            "\tstruct mem_cgroup *memcg;",
            "",
            "\tif (!root_mem_cgroup)",
            "\t\tgoto out;",
            "",
            "\tlockdep_assert_held(&shrinker_mutex);",
            "",
            "\tnew_size = shrinker_unit_size(new_nr_max);",
            "\told_size = shrinker_unit_size(shrinker_nr_max);",
            "",
            "\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);",
            "\tdo {",
            "\t\tret = expand_one_shrinker_info(memcg, new_size, old_size,",
            "\t\t\t\t\t       new_nr_max);",
            "\t\tif (ret) {",
            "\t\t\tmem_cgroup_iter_break(NULL, memcg);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t} while ((memcg = mem_cgroup_iter(NULL, memcg, NULL)) != NULL);",
            "out:",
            "\tif (!ret)",
            "\t\tshrinker_nr_max = new_nr_max;",
            "",
            "\treturn ret;",
            "}",
            "static inline int shrinker_id_to_index(int shrinker_id)",
            "{",
            "\treturn shrinker_id / SHRINKER_UNIT_BITS;",
            "}",
            "static inline int shrinker_id_to_offset(int shrinker_id)",
            "{",
            "\treturn shrinker_id % SHRINKER_UNIT_BITS;",
            "}",
            "static inline int calc_shrinker_id(int index, int offset)",
            "{",
            "\treturn index * SHRINKER_UNIT_BITS + offset;",
            "}",
            "void set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)",
            "{",
            "\tif (shrinker_id >= 0 && memcg && !mem_cgroup_is_root(memcg)) {",
            "\t\tstruct shrinker_info *info;",
            "\t\tstruct shrinker_info_unit *unit;",
            "",
            "\t\trcu_read_lock();",
            "\t\tinfo = rcu_dereference(memcg->nodeinfo[nid]->shrinker_info);",
            "\t\tunit = info->unit[shrinker_id_to_index(shrinker_id)];",
            "\t\tif (!WARN_ON_ONCE(shrinker_id >= info->map_nr_max)) {",
            "\t\t\t/* Pairs with smp mb in shrink_slab() */",
            "\t\t\tsmp_mb__before_atomic();",
            "\t\t\tset_bit(shrinker_id_to_offset(shrinker_id), unit->map);",
            "\t\t}",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static int shrinker_memcg_alloc(struct shrinker *shrinker)",
            "{",
            "\tint id, ret = -ENOMEM;",
            "",
            "\tif (mem_cgroup_disabled())",
            "\t\treturn -ENOSYS;",
            "",
            "\tmutex_lock(&shrinker_mutex);",
            "\tid = idr_alloc(&shrinker_idr, shrinker, 0, 0, GFP_KERNEL);",
            "\tif (id < 0)",
            "\t\tgoto unlock;",
            "",
            "\tif (id >= shrinker_nr_max) {",
            "\t\tif (expand_shrinker_info(id)) {",
            "\t\t\tidr_remove(&shrinker_idr, id);",
            "\t\t\tgoto unlock;",
            "\t\t}",
            "\t}",
            "\tshrinker->id = id;",
            "\tret = 0;",
            "unlock:",
            "\tmutex_unlock(&shrinker_mutex);",
            "\treturn ret;",
            "}",
            "static void shrinker_memcg_remove(struct shrinker *shrinker)",
            "{",
            "\tint id = shrinker->id;",
            "",
            "\tBUG_ON(id < 0);",
            "",
            "\tlockdep_assert_held(&shrinker_mutex);",
            "",
            "\tidr_remove(&shrinker_idr, id);",
            "}",
            "static long xchg_nr_deferred_memcg(int nid, struct shrinker *shrinker,",
            "\t\t\t\t   struct mem_cgroup *memcg)",
            "{",
            "\tstruct shrinker_info *info;",
            "\tstruct shrinker_info_unit *unit;",
            "\tlong nr_deferred;",
            "",
            "\trcu_read_lock();",
            "\tinfo = rcu_dereference(memcg->nodeinfo[nid]->shrinker_info);",
            "\tunit = info->unit[shrinker_id_to_index(shrinker->id)];",
            "\tnr_deferred = atomic_long_xchg(&unit->nr_deferred[shrinker_id_to_offset(shrinker->id)], 0);",
            "\trcu_read_unlock();",
            "",
            "\treturn nr_deferred;",
            "}"
          ],
          "function_name": "expand_shrinker_info, shrinker_id_to_index, shrinker_id_to_offset, calc_shrinker_id, set_shrinker_bit, shrinker_memcg_alloc, shrinker_memcg_remove, xchg_nr_deferred_memcg",
          "description": "提供缩小器ID映射管理功能，包含ID到索引/偏移转换逻辑，支持动态扩展缩小器信息表，并维护缩小器位图标记。",
          "similarity": 0.4272606372833252
        },
        {
          "chunk_id": 5,
          "file_path": "mm/shrinker.c",
          "start_line": 587,
          "end_line": 724,
          "content": [
            "static unsigned long shrink_slab_memcg(gfp_t gfp_mask, int nid,",
            "\t\t\tstruct mem_cgroup *memcg, int priority)",
            "{",
            "\treturn 0;",
            "}",
            "unsigned long shrink_slab(gfp_t gfp_mask, int nid, struct mem_cgroup *memcg,",
            "\t\t\t  int priority)",
            "{",
            "\tunsigned long ret, freed = 0;",
            "\tstruct shrinker *shrinker;",
            "",
            "\t/*",
            "\t * The root memcg might be allocated even though memcg is disabled",
            "\t * via \"cgroup_disable=memory\" boot parameter.  This could make",
            "\t * mem_cgroup_is_root() return false, then just run memcg slab",
            "\t * shrink, but skip global shrink.  This may result in premature",
            "\t * oom.",
            "\t */",
            "\tif (!mem_cgroup_disabled() && !mem_cgroup_is_root(memcg))",
            "\t\treturn shrink_slab_memcg(gfp_mask, nid, memcg, priority);",
            "",
            "\t/*",
            "\t * lockless algorithm of global shrink.",
            "\t *",
            "\t * In the unregistration setp, the shrinker will be freed asynchronously",
            "\t * via RCU after its refcount reaches 0. So both rcu_read_lock() and",
            "\t * shrinker_try_get() can be used to ensure the existence of the shrinker.",
            "\t *",
            "\t * So in the global shrink:",
            "\t *  step 1: use rcu_read_lock() to guarantee existence of the shrinker",
            "\t *          and the validity of the shrinker_list walk.",
            "\t *  step 2: use shrinker_try_get() to try get the refcount, if successful,",
            "\t *          then the existence of the shrinker can also be guaranteed,",
            "\t *          so we can release the RCU lock to do do_shrink_slab() that",
            "\t *          may sleep.",
            "\t *  step 3: *MUST* to reacquire the RCU lock before calling shrinker_put(),",
            "\t *          which ensures that neither this shrinker nor the next shrinker",
            "\t *          will be freed in the next traversal operation.",
            "\t *  step 4: do shrinker_put() paired with step 2 to put the refcount,",
            "\t *          if the refcount reaches 0, then wake up the waiter in",
            "\t *          shrinker_free() by calling complete().",
            "\t */",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(shrinker, &shrinker_list, list) {",
            "\t\tstruct shrink_control sc = {",
            "\t\t\t.gfp_mask = gfp_mask,",
            "\t\t\t.nid = nid,",
            "\t\t\t.memcg = memcg,",
            "\t\t};",
            "",
            "\t\tif (!shrinker_try_get(shrinker))",
            "\t\t\tcontinue;",
            "",
            "\t\trcu_read_unlock();",
            "",
            "\t\tret = do_shrink_slab(&sc, shrinker, priority);",
            "\t\tif (ret == SHRINK_EMPTY)",
            "\t\t\tret = 0;",
            "\t\tfreed += ret;",
            "",
            "\t\trcu_read_lock();",
            "\t\tshrinker_put(shrinker);",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "\tcond_resched();",
            "\treturn freed;",
            "}",
            "void shrinker_register(struct shrinker *shrinker)",
            "{",
            "\tif (unlikely(!(shrinker->flags & SHRINKER_ALLOCATED))) {",
            "\t\tpr_warn(\"Must use shrinker_alloc() to dynamically allocate the shrinker\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tmutex_lock(&shrinker_mutex);",
            "\tlist_add_tail_rcu(&shrinker->list, &shrinker_list);",
            "\tshrinker->flags |= SHRINKER_REGISTERED;",
            "\tshrinker_debugfs_add(shrinker);",
            "\tmutex_unlock(&shrinker_mutex);",
            "",
            "\tinit_completion(&shrinker->done);",
            "\t/*",
            "\t * Now the shrinker is fully set up, take the first reference to it to",
            "\t * indicate that lookup operations are now allowed to use it via",
            "\t * shrinker_try_get().",
            "\t */",
            "\trefcount_set(&shrinker->refcount, 1);",
            "}",
            "static void shrinker_free_rcu_cb(struct rcu_head *head)",
            "{",
            "\tstruct shrinker *shrinker = container_of(head, struct shrinker, rcu);",
            "",
            "\tkfree(shrinker->nr_deferred);",
            "\tkfree(shrinker);",
            "}",
            "void shrinker_free(struct shrinker *shrinker)",
            "{",
            "\tstruct dentry *debugfs_entry = NULL;",
            "\tint debugfs_id;",
            "",
            "\tif (!shrinker)",
            "\t\treturn;",
            "",
            "\tif (shrinker->flags & SHRINKER_REGISTERED) {",
            "\t\t/* drop the initial refcount */",
            "\t\tshrinker_put(shrinker);",
            "\t\t/*",
            "\t\t * Wait for all lookups of the shrinker to complete, after that,",
            "\t\t * no shrinker is running or will run again, then we can safely",
            "\t\t * free it asynchronously via RCU and safely free the structure",
            "\t\t * where the shrinker is located, such as super_block etc.",
            "\t\t */",
            "\t\twait_for_completion(&shrinker->done);",
            "\t}",
            "",
            "\tmutex_lock(&shrinker_mutex);",
            "\tif (shrinker->flags & SHRINKER_REGISTERED) {",
            "\t\t/*",
            "\t\t * Now we can safely remove it from the shrinker_list and then",
            "\t\t * free it.",
            "\t\t */",
            "\t\tlist_del_rcu(&shrinker->list);",
            "\t\tdebugfs_entry = shrinker_debugfs_detach(shrinker, &debugfs_id);",
            "\t\tshrinker->flags &= ~SHRINKER_REGISTERED;",
            "\t}",
            "",
            "\tshrinker_debugfs_name_free(shrinker);",
            "",
            "\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)",
            "\t\tshrinker_memcg_remove(shrinker);",
            "\tmutex_unlock(&shrinker_mutex);",
            "",
            "\tif (debugfs_entry)",
            "\t\tshrinker_debugfs_remove(debugfs_entry, debugfs_id);",
            "",
            "\tcall_rcu(&shrinker->rcu, shrinker_free_rcu_cb);",
            "}"
          ],
          "function_name": "shrink_slab_memcg, shrink_slab, shrinker_register, shrinker_free_rcu_cb, shrinker_free",
          "description": "该代码实现内存收缩机制的核心管理逻辑，包含注册、遍历与清理缩放器（shrinker）的全流程。  \n`shrink_slab` 函数通过 RCU 锁机制安全遍历全局缩放器列表，按优先级回收 slab 缓存，支持内存组（memcg）隔离场景下的差异化回收。  \n`shrinker_register` 注册缩放器至全局链表，`shrinker_free` 安全移除并释放缩放器资源，采用 RCU 延迟销毁以避免并发竞争。  \n注：`shrink_slab_memcg` 未实现具体逻辑，上下文不完整。",
          "similarity": 0.4136962294578552
        },
        {
          "chunk_id": 4,
          "file_path": "mm/shrinker.c",
          "start_line": 469,
          "end_line": 585,
          "content": [
            "static unsigned long shrink_slab_memcg(gfp_t gfp_mask, int nid,",
            "\t\t\tstruct mem_cgroup *memcg, int priority)",
            "{",
            "\tstruct shrinker_info *info;",
            "\tunsigned long ret, freed = 0;",
            "\tint offset, index = 0;",
            "",
            "\tif (!mem_cgroup_online(memcg))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * lockless algorithm of memcg shrink.",
            "\t *",
            "\t * The shrinker_info may be freed asynchronously via RCU in the",
            "\t * expand_one_shrinker_info(), so the rcu_read_lock() needs to be used",
            "\t * to ensure the existence of the shrinker_info.",
            "\t *",
            "\t * The shrinker_info_unit is never freed unless its corresponding memcg",
            "\t * is destroyed. Here we already hold the refcount of memcg, so the",
            "\t * memcg will not be destroyed, and of course shrinker_info_unit will",
            "\t * not be freed.",
            "\t *",
            "\t * So in the memcg shrink:",
            "\t *  step 1: use rcu_read_lock() to guarantee existence of the",
            "\t *          shrinker_info.",
            "\t *  step 2: after getting shrinker_info_unit we can safely release the",
            "\t *          RCU lock.",
            "\t *  step 3: traverse the bitmap and calculate shrinker_id",
            "\t *  step 4: use rcu_read_lock() to guarantee existence of the shrinker.",
            "\t *  step 5: use shrinker_id to find the shrinker, then use",
            "\t *          shrinker_try_get() to guarantee existence of the shrinker,",
            "\t *          then we can release the RCU lock to do do_shrink_slab() that",
            "\t *          may sleep.",
            "\t *  step 6: do shrinker_put() paired with step 5 to put the refcount,",
            "\t *          if the refcount reaches 0, then wake up the waiter in",
            "\t *          shrinker_free() by calling complete().",
            "\t *          Note: here is different from the global shrink, we don't",
            "\t *                need to acquire the RCU lock to guarantee existence of",
            "\t *                the shrinker, because we don't need to use this",
            "\t *                shrinker to traverse the next shrinker in the bitmap.",
            "\t *  step 7: we have already exited the read-side of rcu critical section",
            "\t *          before calling do_shrink_slab(), the shrinker_info may be",
            "\t *          released in expand_one_shrinker_info(), so go back to step 1",
            "\t *          to reacquire the shrinker_info.",
            "\t */",
            "again:",
            "\trcu_read_lock();",
            "\tinfo = rcu_dereference(memcg->nodeinfo[nid]->shrinker_info);",
            "\tif (unlikely(!info))",
            "\t\tgoto unlock;",
            "",
            "\tif (index < shrinker_id_to_index(info->map_nr_max)) {",
            "\t\tstruct shrinker_info_unit *unit;",
            "",
            "\t\tunit = info->unit[index];",
            "",
            "\t\trcu_read_unlock();",
            "",
            "\t\tfor_each_set_bit(offset, unit->map, SHRINKER_UNIT_BITS) {",
            "\t\t\tstruct shrink_control sc = {",
            "\t\t\t\t.gfp_mask = gfp_mask,",
            "\t\t\t\t.nid = nid,",
            "\t\t\t\t.memcg = memcg,",
            "\t\t\t};",
            "\t\t\tstruct shrinker *shrinker;",
            "\t\t\tint shrinker_id = calc_shrinker_id(index, offset);",
            "",
            "\t\t\trcu_read_lock();",
            "\t\t\tshrinker = idr_find(&shrinker_idr, shrinker_id);",
            "\t\t\tif (unlikely(!shrinker || !shrinker_try_get(shrinker))) {",
            "\t\t\t\tclear_bit(offset, unit->map);",
            "\t\t\t\trcu_read_unlock();",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\trcu_read_unlock();",
            "",
            "\t\t\t/* Call non-slab shrinkers even though kmem is disabled */",
            "\t\t\tif (!memcg_kmem_online() &&",
            "\t\t\t    !(shrinker->flags & SHRINKER_NONSLAB))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tret = do_shrink_slab(&sc, shrinker, priority);",
            "\t\t\tif (ret == SHRINK_EMPTY) {",
            "\t\t\t\tclear_bit(offset, unit->map);",
            "\t\t\t\t/*",
            "\t\t\t\t * After the shrinker reported that it had no objects to",
            "\t\t\t\t * free, but before we cleared the corresponding bit in",
            "\t\t\t\t * the memcg shrinker map, a new object might have been",
            "\t\t\t\t * added. To make sure, we have the bit set in this",
            "\t\t\t\t * case, we invoke the shrinker one more time and reset",
            "\t\t\t\t * the bit if it reports that it is not empty anymore.",
            "\t\t\t\t * The memory barrier here pairs with the barrier in",
            "\t\t\t\t * set_shrinker_bit():",
            "\t\t\t\t *",
            "\t\t\t\t * list_lru_add()     shrink_slab_memcg()",
            "\t\t\t\t *   list_add_tail()    clear_bit()",
            "\t\t\t\t *   <MB>               <MB>",
            "\t\t\t\t *   set_bit()          do_shrink_slab()",
            "\t\t\t\t */",
            "\t\t\t\tsmp_mb__after_atomic();",
            "\t\t\t\tret = do_shrink_slab(&sc, shrinker, priority);",
            "\t\t\t\tif (ret == SHRINK_EMPTY)",
            "\t\t\t\t\tret = 0;",
            "\t\t\t\telse",
            "\t\t\t\t\tset_shrinker_bit(memcg, nid, shrinker_id);",
            "\t\t\t}",
            "\t\t\tfreed += ret;",
            "\t\t\tshrinker_put(shrinker);",
            "\t\t}",
            "",
            "\t\tindex++;",
            "\t\tgoto again;",
            "\t}",
            "unlock:",
            "\trcu_read_unlock();",
            "\treturn freed;",
            "}"
          ],
          "function_name": "shrink_slab_memcg",
          "description": "实现内存控制组级别的slab回收逻辑，通过RCU读锁保护访问缩小器信息表，遍历所有注册缩小器并执行相应的对象回收操作。",
          "similarity": 0.39437437057495117
        }
      ]
    },
    {
      "source_file": "kernel/bpf/kmem_cache_iter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:13:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\kmem_cache_iter.c`\n\n---\n\n# `bpf/kmem_cache_iter.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了 BPF（Berkeley Packet Filter）迭代器（iterator）机制对内核 slab 分配器中所有 `kmem_cache` 对象的遍历支持。通过该迭代器，BPF 程序可以在运行时安全地遍历系统中所有活动的内存缓存（slab caches），用于监控、调试或性能分析等用途。该实现同时支持 BPF kfunc 接口（供 BPF 程序直接调用）和基于 `seq_file` 的传统 BPF 迭代器接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_iter_kmem_cache`**  \n  用户态或 BPF 程序可见的不透明迭代器句柄，用于封装内部状态。\n\n- **`struct bpf_iter_kmem_cache_kern`**  \n  内核内部使用的迭代器状态结构，包含当前遍历位置（`pos` 指向 `kmem_cache`）。\n\n- **`struct bpf_iter__kmem_cache`**  \n  BPF 迭代器上下文结构，作为 BPF 程序的输入参数，包含元数据和当前 `kmem_cache` 指针。\n\n- **`union kmem_cache_iter_priv`**  \n  联合体，用于在 `seq_file` 私有数据中同时容纳用户态和内核态的迭代器结构。\n\n### 主要函数\n\n- **`bpf_iter_kmem_cache_new()`**  \n  初始化一个新的 `kmem_cache` 迭代器，设置起始位置为特殊标记 `KMEM_CACHE_POS_START`。\n\n- **`bpf_iter_kmem_cache_next()`**  \n  获取下一个有效的 `kmem_cache` 对象。负责引用计数管理：对新对象增加引用，对旧对象减少引用并在引用归零时调用 `kmem_cache_destroy()`。\n\n- **`bpf_iter_kmem_cache_destroy()`**  \n  销毁迭代器，释放当前持有的 `kmem_cache` 引用（如需要则触发销毁）。\n\n- **`kmem_cache_iter_seq_start()` / `next()` / `stop()` / `show()`**  \n  实现 `seq_file` 接口，用于支持通过 BPF 迭代器文件描述符进行遍历。\n\n- **`bpf_kmem_cache_iter_init()`**  \n  模块初始化函数，注册 `kmem_cache` 类型的 BPF 迭代器目标。\n\n## 3. 关键实现\n\n### 引用计数管理\n- 遍历时对每个非启动缓存（`boot_cache`，其 `refcount < 0`）的 `kmem_cache` 对象进行引用计数操作：\n  - 进入时（`next` 或 `start`）若 `refcount > 0`，则递增引用。\n  - 离开时（`next` 的前一个或 `stop`）若引用计数降至 1，则标记为可销毁，并在锁外调用 `kmem_cache_destroy()`。\n- 此机制确保遍历过程中目标对象不会被意外释放，同时避免内存泄漏。\n\n### 并发安全\n- 所有对全局 `slab_caches` 链表的访问均受 `slab_mutex` 互斥锁保护。\n- 由于遍历过程可能释放锁（如 `kmem_cache_destroy()` 需要睡眠），实现采用“按位置查找”策略（`seq_start` 中通过 `*pos` 重新定位），而非保存链表指针，以容忍中间元素的删除（虽可能跳过，但保证安全）。\n\n### BPF 接口集成\n- 通过 `DEFINE_BPF_ITER_FUNC` 和 `bpf_iter_reg_target()` 注册为 BPF 迭代器目标 `\"kmem_cache\"`。\n- 使用 `BTF_ID_LIST_GLOBAL_SINGLE` 导出 `kmem_cache` 结构的 BTF ID，使 BPF 程序能安全访问其字段。\n- 上下文参数 `s` 被标记为 `PTR_TO_BTF_ID_OR_NULL | PTR_TRUSTED`，表明其为可信的、类型安全的指针。\n\n### 特殊起始标记\n- 使用 `(void *)1L` 作为 `KMEM_CACHE_POS_START`，避免与合法指针或 `NULL` 冲突，用于标识迭代尚未开始。\n\n## 4. 依赖关系\n\n- **`<linux/slab.h>`**：提供 `kmem_cache`、`slab_caches` 链表和 `slab_mutex` 的定义。\n- **`<linux/bpf.h>`**：BPF 核心接口，包括迭代器注册、程序执行等。\n- **`<linux/btf_ids.h>`**：BTF（BPF Type Format）ID 管理，用于类型安全。\n- **`../../mm/slab.h`**：内核内部 slab 实现头文件，暴露 `kmem_cache` 结构细节。\n- **`kmem_cache_destroy()`**：依赖 slab 子系统的缓存销毁逻辑。\n\n## 5. 使用场景\n\n- **系统监控工具**：BPF 程序可通过此迭代器收集所有 slab 缓存的统计信息（如对象数量、内存使用量），用于内存泄漏检测或性能分析。\n- **安全审计**：检查异常或可疑的 `kmem_cache` 创建行为。\n- **内核调试**：在运行时动态查询 slab 子系统的状态，无需修改内核代码或重启系统。\n- **eBPF 应用开发**：为高级内存分析工具（如 `bpftrace`、`bcc` 工具集）提供底层支持。",
      "similarity": 0.4945005774497986,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/kmem_cache_iter.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2024 Google */",
            "#include <linux/bpf.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/seq_file.h>",
            "",
            "#include \"../../mm/slab.h\" /* kmem_cache, slab_caches and slab_mutex */",
            "",
            "/* open-coded version */",
            "struct bpf_iter_kmem_cache {",
            "\t__u64 __opaque[1];",
            "} __attribute__((aligned(8)));",
            "",
            "struct bpf_iter_kmem_cache_kern {",
            "\tstruct kmem_cache *pos;",
            "} __attribute__((aligned(8)));",
            "",
            "#define KMEM_CACHE_POS_START  ((void *)1L)",
            "",
            "__bpf_kfunc_start_defs();",
            ""
          ],
          "function_name": null,
          "description": "定义BPF kmem_cache迭代器的通用结构体和宏，用于支持BPF程序访问slab缓存对象，包含对齐属性和位置起始标记，但未包含完整实现",
          "similarity": 0.4357929825782776
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/kmem_cache_iter.c",
          "start_line": 24,
          "end_line": 99,
          "content": [
            "__bpf_kfunc int bpf_iter_kmem_cache_new(struct bpf_iter_kmem_cache *it)",
            "{",
            "\tstruct bpf_iter_kmem_cache_kern *kit = (void *)it;",
            "",
            "\tBUILD_BUG_ON(sizeof(*kit) > sizeof(*it));",
            "\tBUILD_BUG_ON(__alignof__(*kit) != __alignof__(*it));",
            "",
            "\tkit->pos = KMEM_CACHE_POS_START;",
            "\treturn 0;",
            "}",
            "__bpf_kfunc void bpf_iter_kmem_cache_destroy(struct bpf_iter_kmem_cache *it)",
            "{",
            "\tstruct bpf_iter_kmem_cache_kern *kit = (void *)it;",
            "\tstruct kmem_cache *s = kit->pos;",
            "\tbool destroy = false;",
            "",
            "\tif (s == NULL || s == KMEM_CACHE_POS_START)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&slab_mutex);",
            "",
            "\t/* Skip kmem_cache_destroy() for active entries */",
            "\tif (s->refcount > 1)",
            "\t\ts->refcount--;",
            "\telse if (s->refcount == 1)",
            "\t\tdestroy = true;",
            "",
            "\tmutex_unlock(&slab_mutex);",
            "",
            "\tif (destroy)",
            "\t\tkmem_cache_destroy(s);",
            "}",
            "static void kmem_cache_iter_seq_stop(struct seq_file *seq, void *v)",
            "{",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_iter__kmem_cache ctx = {",
            "\t\t.meta = &meta,",
            "\t\t.s = v,",
            "\t};",
            "\tunion kmem_cache_iter_priv *p = seq->private;",
            "\tstruct bpf_prog *prog;",
            "",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, true);",
            "\tif (prog && !ctx.s)",
            "\t\tbpf_iter_run_prog(prog, &ctx);",
            "",
            "\tbpf_iter_kmem_cache_destroy(&p->it);",
            "}",
            "static int kmem_cache_iter_seq_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_iter__kmem_cache ctx = {",
            "\t\t.meta = &meta,",
            "\t\t.s = v,",
            "\t};",
            "\tstruct bpf_prog *prog;",
            "\tint ret = 0;",
            "",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, false);",
            "\tif (prog)",
            "\t\tret = bpf_iter_run_prog(prog, &ctx);",
            "",
            "\treturn ret;",
            "}",
            "static void bpf_iter_kmem_cache_show_fdinfo(const struct bpf_iter_aux_info *aux,",
            "\t\t\t\t\t    struct seq_file *seq)",
            "{",
            "\tseq_puts(seq, \"kmem_cache iter\\n\");",
            "}",
            "static int __init bpf_kmem_cache_iter_init(void)",
            "{",
            "\tbpf_kmem_cache_reg_info.ctx_arg_info[0].btf_id = bpf_kmem_cache_btf_id[0];",
            "\treturn bpf_iter_reg_target(&bpf_kmem_cache_reg_info);",
            "}"
          ],
          "function_name": "bpf_iter_kmem_cache_new, bpf_iter_kmem_cache_destroy, kmem_cache_iter_seq_stop, kmem_cache_iter_seq_show, bpf_iter_kmem_cache_show_fdinfo, bpf_kmem_cache_iter_init",
          "description": "实现BPF kmem_cache迭代器的核心函数，包含迭代器创建/销毁逻辑、序列化遍历控制、BPF程序执行及注册机制，通过slab_mutex保护缓存引用计数并处理销毁操作",
          "similarity": 0.4065602421760559
        }
      ]
    },
    {
      "source_file": "kernel/printk/index.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:30:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `printk\\index.c`\n\n---\n\n# printk/index.c 技术文档\n\n## 1. 文件概述\n\n`printk/index.c` 实现了对内核中所有 `printk` 格式字符串的用户空间索引功能。该文件通过 debugfs 接口暴露一个结构化的视图，使得用户空间工具可以查询每个 `printk` 调用的位置（文件名、行号、函数名）、日志级别、标志以及完整的格式字符串。此功能主要用于日志分析、调试信息提取和内核日志格式的静态分析。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct pi_entry`：表示单个 `printk` 调用的元数据条目，包含格式字符串、文件路径、行号、函数名、日志级别前缀等信息（定义在 `internal.h` 中）。\n- `dfs_index_sops`：`seq_operations` 结构体，定义了 debugfs 文件的序列化读取操作。\n- `dfs_index_fops`：通过 `DEFINE_SEQ_ATTRIBUTE` 宏生成的文件操作结构，用于 debugfs 文件访问。\n\n### 主要函数\n- `pi_get_entry()`：根据模块指针和位置索引获取对应的 `pi_entry` 条目。\n- `pi_start()` / `pi_next()` / `pi_stop()` / `pi_show()`：实现 `seq_file` 接口，用于按行遍历并格式化输出索引内容。\n- `pi_create_file()`：为指定模块（或 vmlinux）在 debugfs 中创建对应的索引文件。\n- `pi_remove_file()`：移除模块卸载时对应的 debugfs 索引文件（仅在 `CONFIG_MODULES` 启用时）。\n- `pi_module_notify()`：模块状态通知回调，用于动态管理模块加载/卸载时的索引文件。\n- `pi_init()`：初始化 debugfs 目录结构并注册初始索引文件。\n\n## 3. 关键实现\n\n### printk 索引数据来源\n- **内核镜像（vmlinux）**：通过链接器生成的符号 `__start_printk_index` 和 `__stop_printk_index` 访问编译时收集的 `pi_entry` 数组。\n- **内核模块**：每个模块在加载时会携带自己的 `printk_index_start` 和 `printk_index_size` 字段，指向其私有的 `pi_entry` 数组。\n\n### 序列化输出格式\n- 每行输出格式为：`<level/flags> filename:line function \"format\"`\n- 日志级别和标志通过 `printk_parse_prefix()` 解析：\n  - 若存在 `LOG_CONT` 标志，输出 `<c>` 或 `<level,c>`\n  - 否则输出 `<level>`\n- 格式字符串经过转义处理（使用 `seq_escape_str()`），确保双引号和反斜杠被正确转义，避免破坏输出格式。\n\n### 动态模块支持\n- 通过 `register_module_notifier()` 注册模块状态监听器。\n- 模块加载（`MODULE_STATE_COMING`）时自动创建其 debugfs 索引文件。\n- 模块卸载（`MODULE_STATE_GOING`）时自动删除对应文件。\n\n### 初始化时机\n- 使用 `postcore_initcall()` 确保在 core 初始化阶段早期执行，早于大多数模块加载，以保证 debugfs 结构可用。\n\n## 4. 依赖关系\n\n- **内核配置**：\n  - 依赖 `CONFIG_PRINTK_INDEX`（隐含在编译此文件的条件中）\n  - 可选依赖 `CONFIG_MODULES`（启用模块动态索引管理）\n- **头文件**：\n  - `linux/debugfs.h`：提供 debugfs 接口\n  - `linux/printk.h` 和 `internal.h`：提供 `pi_entry` 和 `printk_parse_prefix()` 等内部接口\n  - `linux/module.h`：模块通知机制\n- **链接器支持**：依赖链接脚本生成 `__start_printk_index` / `__stop_printk_index` 符号\n\n## 5. 使用场景\n\n- **内核日志分析工具**：如 `crash`、`trace-cmd` 等工具可读取此索引，将二进制日志中的格式字符串 ID 映射回原始格式，实现日志解码。\n- **静态分析与验证**：安全或合规工具可扫描所有 `printk` 格式，检查是否存在敏感信息泄露或格式错误。\n- **调试辅助**：开发者可通过 `/sys/kernel/debug/printk/index/` 目录快速定位内核中所有日志输出点及其上下文。\n- **模块热插拔支持**：动态加载的模块也能被索引，确保运行时新增的日志点可被工具识别。",
      "similarity": 0.48412024974823,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/printk/index.c",
          "start_line": 73,
          "end_line": 157,
          "content": [
            "static int pi_show(struct seq_file *s, void *v)",
            "{",
            "\tconst struct pi_entry *entry = v;",
            "\tint level = LOGLEVEL_DEFAULT;",
            "\tenum printk_info_flags flags = 0;",
            "\tu16 prefix_len = 0;",
            "",
            "\tif (v == SEQ_START_TOKEN) {",
            "\t\tseq_puts(s, \"# <level/flags> filename:line function \\\"format\\\"\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (!entry->fmt)",
            "\t\treturn 0;",
            "",
            "\tif (entry->level)",
            "\t\tprintk_parse_prefix(entry->level, &level, &flags);",
            "\telse",
            "\t\tprefix_len = printk_parse_prefix(entry->fmt, &level, &flags);",
            "",
            "",
            "\tif (flags & LOG_CONT) {",
            "\t\t/*",
            "\t\t * LOGLEVEL_DEFAULT here means \"use the same level as the",
            "\t\t * message we're continuing from\", not the default message",
            "\t\t * loglevel, so don't display it as such.",
            "\t\t */",
            "\t\tif (level == LOGLEVEL_DEFAULT)",
            "\t\t\tseq_puts(s, \"<c>\");",
            "\t\telse",
            "\t\t\tseq_printf(s, \"<%d,c>\", level);",
            "\t} else",
            "\t\tseq_printf(s, \"<%d>\", level);",
            "",
            "\tseq_printf(s, \" %s:%d %s \\\"\", entry->file, entry->line, entry->func);",
            "\tif (entry->subsys_fmt_prefix)",
            "\t\tseq_escape_printf_format(s, entry->subsys_fmt_prefix);",
            "\tseq_escape_printf_format(s, entry->fmt + prefix_len);",
            "\tseq_puts(s, \"\\\"\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static void pi_stop(struct seq_file *p, void *v) { }",
            "static void pi_create_file(struct module *mod)",
            "{",
            "\tdebugfs_create_file(pi_get_module_name(mod), 0444, dfs_index,",
            "\t\t\t\t       mod, &dfs_index_fops);",
            "}",
            "static void pi_remove_file(struct module *mod)",
            "{",
            "\tdebugfs_lookup_and_remove(pi_get_module_name(mod), dfs_index);",
            "}",
            "static int pi_module_notify(struct notifier_block *nb, unsigned long op,",
            "\t\t\t    void *data)",
            "{",
            "\tstruct module *mod = data;",
            "",
            "\tswitch (op) {",
            "\tcase MODULE_STATE_COMING:",
            "\t\tpi_create_file(mod);",
            "\t\tbreak;",
            "\tcase MODULE_STATE_GOING:",
            "\t\tpi_remove_file(mod);",
            "\t\tbreak;",
            "\tdefault: /* we don't care about other module states */",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn NOTIFY_OK;",
            "}",
            "static void __init pi_setup_module_notifier(void)",
            "{",
            "\tregister_module_notifier(&module_printk_fmts_nb);",
            "}",
            "static inline void __init pi_setup_module_notifier(void) { }",
            "static int __init pi_init(void)",
            "{",
            "\tstruct dentry *dfs_root = debugfs_create_dir(\"printk\", NULL);",
            "",
            "\tdfs_index = debugfs_create_dir(\"index\", dfs_root);",
            "\tpi_setup_module_notifier();",
            "\tpi_create_file(NULL);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pi_show, pi_stop, pi_create_file, pi_remove_file, pi_module_notify, pi_setup_module_notifier, pi_setup_module_notifier, pi_init",
          "description": "实现 printk 格式索引的 debugfs 显示逻辑，包含模块加载/卸载时的文件创建与删除操作，支持通过 seq_file 遍历格式条目并安全转义敏感字符",
          "similarity": 0.4366713762283325
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/printk/index.c",
          "start_line": 1,
          "end_line": 72,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Userspace indexing of printk formats",
            " */",
            "",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/string_helpers.h>",
            "",
            "#include \"internal.h\"",
            "",
            "extern struct pi_entry *__start_printk_index[];",
            "extern struct pi_entry *__stop_printk_index[];",
            "",
            "/* The base dir for module formats, typically debugfs/printk/index/ */",
            "static struct dentry *dfs_index;",
            "",
            "static struct pi_entry *pi_get_entry(const struct module *mod, loff_t pos)",
            "{",
            "\tstruct pi_entry **entries;",
            "\tunsigned int nr_entries;",
            "",
            "#ifdef CONFIG_MODULES",
            "\tif (mod) {",
            "\t\tentries = mod->printk_index_start;",
            "\t\tnr_entries = mod->printk_index_size;",
            "\t} else",
            "#endif",
            "\t{",
            "\t\t/* vmlinux, comes from linker symbols */",
            "\t\tentries = __start_printk_index;",
            "\t\tnr_entries = __stop_printk_index - __start_printk_index;",
            "\t}",
            "",
            "\tif (pos >= nr_entries)",
            "\t\treturn NULL;",
            "",
            "\treturn entries[pos];",
            "}",
            "",
            "static void *pi_next(struct seq_file *s, void *v, loff_t *pos)",
            "{",
            "\tconst struct module *mod = s->file->f_inode->i_private;",
            "\tstruct pi_entry *entry = pi_get_entry(mod, *pos);",
            "",
            "\t(*pos)++;",
            "",
            "\treturn entry;",
            "}",
            "",
            "static void *pi_start(struct seq_file *s, loff_t *pos)",
            "{",
            "\t/*",
            "\t * Make show() print the header line. Do not update *pos because",
            "\t * pi_next() still has to return the entry at index 0 later.",
            "\t */",
            "\tif (*pos == 0)",
            "\t\treturn SEQ_START_TOKEN;",
            "",
            "\treturn pi_next(s, NULL, pos);",
            "}",
            "",
            "/*",
            " * We need both ESCAPE_ANY and explicit characters from ESCAPE_SPECIAL in @only",
            " * because otherwise ESCAPE_NAP will cause double quotes and backslashes to be",
            " * ignored for quoting.",
            " */",
            "#define seq_escape_printf_format(s, src) \\",
            "\tseq_escape_str(s, src, ESCAPE_ANY | ESCAPE_NAP | ESCAPE_APPEND, \"\\\"\\\\\")",
            ""
          ],
          "function_name": null,
          "description": "定义用于模块 printk 格式索引的辅助函数，通过模块或内核镜像的符号表获取 printk 条目，实现基于 debugfs 的格式信息遍历接口",
          "similarity": 0.4348321557044983
        }
      ]
    }
  ]
}