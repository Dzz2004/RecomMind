{
  "query": "确保资源安全释放 访问控制列表",
  "timestamp": "2025-12-26 01:30:49",
  "retrieved_files": [
    {
      "source_file": "kernel/resource.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:53:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `resource.c`\n\n---\n\n# resource.c 技术文档\n\n## 1. 文件概述\n\n`resource.c` 是 Linux 内核中用于管理和分配系统资源（如 I/O 端口和内存区域）的核心实现文件。它提供了一套通用的资源树管理机制，支持资源的申请、释放、查找和冲突检测。该文件维护了两个全局根资源节点：`ioport_resource`（用于 I/O 端口空间）和 `iomem_resource`（用于内存映射 I/O 空间），并通过树形结构组织所有已分配的子资源，确保资源分配的唯一性和安全性。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `struct resource ioport_resource`：I/O 端口资源的根节点，范围为 `[0, IO_SPACE_LIMIT]`，标志为 `IORESOURCE_IO`。\n- `struct resource iomem_resource`：内存映射 I/O 资源的根节点，范围为 `[0, -1]`（即全地址空间），标志为 `IORESOURCE_MEM`。\n- `struct resource_constraint`：用于描述资源分配时的约束条件（最小/最大地址、对齐要求及自定义对齐函数）。\n\n### 关键函数\n- `request_resource(struct resource *root, struct resource *new)`：尝试在指定根资源下申请一段新资源，成功返回 0，冲突返回 `-EBUSY`。\n- `request_resource_conflict(...)`：与 `request_resource` 类似，但冲突时直接返回冲突的资源指针。\n- `release_resource(struct resource *old)`：释放已分配的资源。\n- `release_child_resources(struct resource *r)`：递归释放指定资源的所有子资源。\n- `find_next_iomem_res(...)`：在 `iomem_resource` 树中查找与指定区间 `[start, end]` 重叠且满足标志和描述符条件的下一个内存资源。\n- `for_each_resource` 宏：遍历资源树的通用宏，支持是否跳过子树的选项。\n\n### /proc 接口（条件编译）\n- 通过 `CONFIG_PROC_FS` 启用时，注册 `/proc/ioports` 和 `/proc/iomem` 文件，以树形格式展示当前系统中已分配的 I/O 端口和内存资源（仅对 `CAP_SYS_ADMIN` 权限用户显示实际地址）。\n\n## 3. 关键实现\n\n### 资源树结构\n- 资源以多叉树形式组织，每个 `struct resource` 包含 `child`（第一个子节点）、`sibling`（下一个兄弟节点）和 `parent` 指针。\n- 树内节点按起始地址升序排列，便于快速查找和插入。\n\n### 资源申请（`__request_resource`）\n- 在持有写锁 `resource_lock` 的前提下，遍历根节点的子链表。\n- 若新资源与现有节点无重叠，则按地址顺序插入；若存在重叠，则返回冲突节点。\n- 插入操作维护树的有序性：新节点插入到第一个起始地址大于其结束地址的节点之前。\n\n### 资源释放（`__release_resource`）\n- 支持两种模式：完全释放（含子资源）或仅提升子资源（当 `release_child=false` 时，将子节点直接挂到父节点下）。\n- 释放时调整兄弟链表指针，确保树结构完整性。\n\n### 资源遍历\n- `next_resource()`：深度优先遍历（先子节点，再兄弟节点）。\n- `next_resource_skip_children()`：仅遍历同级兄弟节点，跳过子树。\n- `/proc` 显示使用深度优先遍历，并限制最大显示层级（`MAX_IORES_LEVEL=5`）以避免过深嵌套。\n\n### 内存管理\n- 资源结构体通过 `alloc_resource()`（即 `kzalloc`）分配，通过 `free_resource()` 释放。\n- 注释指出：若资源由早期 `memblock` 分配，则无法安全释放（因非页对齐），会轻微泄漏，这是有意为之的简化设计。\n\n### 并发控制\n- 使用读写锁 `resource_lock` 保护全局资源树：\n  - 读操作（如 `/proc` 显示、`find_next_iomem_res`）使用 `read_lock`。\n  - 写操作（申请/释放资源）使用 `write_lock`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ioport.h>`：定义 `struct resource` 及相关宏（如 `IORESOURCE_IO`）。\n  - `<linux/proc_fs.h>`、`<linux/seq_file.h>`：实现 `/proc` 接口。\n  - `<linux/slab.h>`：资源结构体的动态分配。\n  - `<linux/spinlock.h>`：读写锁 `resource_lock` 的实现。\n  - `<asm/io.h>`：架构相关的 I/O 定义（如 `IO_SPACE_LIMIT`）。\n- **导出符号**：\n  - `ioport_resource`、`iomem_resource`、`request_resource`、`release_resource` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如 PCI、platform_device 驱动）使用。\n- **配置依赖**：\n  - `/proc` 接口依赖 `CONFIG_PROC_FS`。\n\n## 5. 使用场景\n\n- **设备驱动资源管理**：PCI、platform 等总线驱动在探测设备时，调用 `request_resource()` 申请 I/O 端口或内存区域，防止资源冲突。\n- **固件/ACPI 资源解析**：内核解析 ACPI 表或 EFI 内存映射时，将保留区域注册到 `iomem_resource` 树中。\n- **系统调试与监控**：用户空间通过 `/proc/ioports` 和 `/proc/iomem` 查看硬件资源分配情况（需 root 权限）。\n- **内核子系统协作**：内存管理子系统（如 `devm_request_mem_region`）、DMA 引擎等依赖此机制确保物理地址资源的独占使用。\n- **热插拔支持**：设备移除时调用 `release_resource()` 释放资源，供后续设备重用。",
      "similarity": 0.5959321856498718,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/resource.c",
          "start_line": 104,
          "end_line": 208,
          "content": [
            "static void r_stop(struct seq_file *m, void *v)",
            "\t__releases(resource_lock)",
            "{",
            "\tread_unlock(&resource_lock);",
            "}",
            "static int r_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct resource *root = pde_data(file_inode(m->file));",
            "\tstruct resource *r = v, *p;",
            "\tunsigned long long start, end;",
            "\tint width = root->end < 0x10000 ? 4 : 8;",
            "\tint depth;",
            "",
            "\tfor (depth = 0, p = r; depth < MAX_IORES_LEVEL; depth++, p = p->parent)",
            "\t\tif (p->parent == root)",
            "\t\t\tbreak;",
            "",
            "\tif (file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN)) {",
            "\t\tstart = r->start;",
            "\t\tend = r->end;",
            "\t} else {",
            "\t\tstart = end = 0;",
            "\t}",
            "",
            "\tseq_printf(m, \"%*s%0*llx-%0*llx : %s\\n\",",
            "\t\t\tdepth * 2, \"\",",
            "\t\t\twidth, start,",
            "\t\t\twidth, end,",
            "\t\t\tr->name ? r->name : \"<BAD>\");",
            "\treturn 0;",
            "}",
            "static int __init ioresources_init(void)",
            "{",
            "\tproc_create_seq_data(\"ioports\", 0, NULL, &resource_op,",
            "\t\t\t&ioport_resource);",
            "\tproc_create_seq_data(\"iomem\", 0, NULL, &resource_op, &iomem_resource);",
            "\treturn 0;",
            "}",
            "static void free_resource(struct resource *res)",
            "{",
            "\t/**",
            "\t * If the resource was allocated using memblock early during boot",
            "\t * we'll leak it here: we can only return full pages back to the",
            "\t * buddy and trying to be smart and reusing them eventually in",
            "\t * alloc_resource() overcomplicates resource handling.",
            "\t */",
            "\tif (res && PageSlab(virt_to_head_page(res)))",
            "\t\tkfree(res);",
            "}",
            "static int __release_resource(struct resource *old, bool release_child)",
            "{",
            "\tstruct resource *tmp, **p, *chd;",
            "",
            "\tp = &old->parent->child;",
            "\tfor (;;) {",
            "\t\ttmp = *p;",
            "\t\tif (!tmp)",
            "\t\t\tbreak;",
            "\t\tif (tmp == old) {",
            "\t\t\tif (release_child || !(tmp->child)) {",
            "\t\t\t\t*p = tmp->sibling;",
            "\t\t\t} else {",
            "\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {",
            "\t\t\t\t\tchd->parent = tmp->parent;",
            "\t\t\t\t\tif (!(chd->sibling))",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\t*p = tmp->child;",
            "\t\t\t\tchd->sibling = tmp->sibling;",
            "\t\t\t}",
            "\t\t\told->parent = NULL;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tp = &tmp->sibling;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static void __release_child_resources(struct resource *r)",
            "{",
            "\tstruct resource *tmp, *p;",
            "\tresource_size_t size;",
            "",
            "\tp = r->child;",
            "\tr->child = NULL;",
            "\twhile (p) {",
            "\t\ttmp = p;",
            "\t\tp = p->sibling;",
            "",
            "\t\ttmp->parent = NULL;",
            "\t\ttmp->sibling = NULL;",
            "\t\t__release_child_resources(tmp);",
            "",
            "\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);",
            "\t\t/* need to restore size, and keep flags */",
            "\t\tsize = resource_size(tmp);",
            "\t\ttmp->start = 0;",
            "\t\ttmp->end = size - 1;",
            "\t}",
            "}",
            "void release_child_resources(struct resource *r)",
            "{",
            "\twrite_lock(&resource_lock);",
            "\t__release_child_resources(r);",
            "\twrite_unlock(&resource_lock);",
            "}"
          ],
          "function_name": "r_stop, r_show, ioresources_init, free_resource, __release_resource, __release_child_resources, release_child_resources",
          "description": "实现资源遍历显示接口、资源释放逻辑及初始化函数，提供资源冲突检测、子资源释放、内存区域遍历等功能，支持进程命名空间下的资源访问控制。",
          "similarity": 0.6836304664611816
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/resource.c",
          "start_line": 1208,
          "end_line": 1327,
          "content": [
            "static void revoke_iomem(struct resource *res)",
            "{",
            "\t/* pairs with smp_store_release() in iomem_init_inode() */",
            "\tstruct inode *inode = smp_load_acquire(&iomem_inode);",
            "",
            "\t/*",
            "\t * Check that the initialization has completed. Losing the race",
            "\t * is ok because it means drivers are claiming resources before",
            "\t * the fs_initcall level of init and prevent iomem_get_mapping users",
            "\t * from establishing mappings.",
            "\t */",
            "\tif (!inode)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * The expectation is that the driver has successfully marked",
            "\t * the resource busy by this point, so devmem_is_allowed()",
            "\t * should start returning false, however for performance this",
            "\t * does not iterate the entire resource range.",
            "\t */",
            "\tif (devmem_is_allowed(PHYS_PFN(res->start)) &&",
            "\t    devmem_is_allowed(PHYS_PFN(res->end))) {",
            "\t\t/*",
            "\t\t * *cringe* iomem=relaxed says \"go ahead, what's the",
            "\t\t * worst that can happen?\"",
            "\t\t */",
            "\t\treturn;",
            "\t}",
            "",
            "\tunmap_mapping_range(inode->i_mapping, res->start, resource_size(res), 1);",
            "}",
            "static void revoke_iomem(struct resource *res) {}",
            "static int __request_region_locked(struct resource *res, struct resource *parent,",
            "\t\t\t\t   resource_size_t start, resource_size_t n,",
            "\t\t\t\t   const char *name, int flags)",
            "{",
            "\tDECLARE_WAITQUEUE(wait, current);",
            "",
            "\tres->name = name;",
            "\tres->start = start;",
            "\tres->end = start + n - 1;",
            "",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tres->flags = resource_type(parent) | resource_ext_type(parent);",
            "\t\tres->flags |= IORESOURCE_BUSY | flags;",
            "\t\tres->desc = parent->desc;",
            "",
            "\t\tconflict = __request_resource(parent, res);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * mm/hmm.c reserves physical addresses which then",
            "\t\t * become unavailable to other users.  Conflicts are",
            "\t\t * not expected.  Warn to aid debugging if encountered.",
            "\t\t */",
            "\t\tif (parent == &iomem_resource &&",
            "\t\t    conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {",
            "\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\\n\",",
            "\t\t\t\tconflict->name, conflict, res);",
            "\t\t}",
            "\t\tif (conflict != parent) {",
            "\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {",
            "\t\t\t\tparent = conflict;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {",
            "\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);",
            "\t\t\twrite_unlock(&resource_lock);",
            "\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);",
            "\t\t\tschedule();",
            "\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);",
            "\t\t\twrite_lock(&resource_lock);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/* Uhhuh, that didn't work out.. */",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __release_region(struct resource *parent, resource_size_t start,",
            "\t\t      resource_size_t n)",
            "{",
            "\tstruct resource **p;",
            "\tresource_size_t end;",
            "",
            "\tp = &parent->child;",
            "\tend = start + n - 1;",
            "",
            "\twrite_lock(&resource_lock);",
            "",
            "\tfor (;;) {",
            "\t\tstruct resource *res = *p;",
            "",
            "\t\tif (!res)",
            "\t\t\tbreak;",
            "\t\tif (res->start <= start && res->end >= end) {",
            "\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {",
            "\t\t\t\tp = &res->child;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif (res->start != start || res->end != end)",
            "\t\t\t\tbreak;",
            "\t\t\t*p = res->sibling;",
            "\t\t\twrite_unlock(&resource_lock);",
            "\t\t\tif (res->flags & IORESOURCE_MUXED)",
            "\t\t\t\twake_up(&muxed_resource_wait);",
            "\t\t\tfree_resource(res);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tp = &res->sibling;",
            "\t}",
            "",
            "\twrite_unlock(&resource_lock);",
            "",
            "\tpr_warn(\"Trying to free nonexistent resource <%pa-%pa>\\n\", &start, &end);",
            "}"
          ],
          "function_name": "revoke_iomem, revoke_iomem, __request_region_locked, __release_region",
          "description": "实现IOMEM资源撤销机制，包含受保护的区域请求锁管理、资源释放及冲突处理逻辑，维护资源树结构。",
          "similarity": 0.6140718460083008
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/resource.c",
          "start_line": 1739,
          "end_line": 1846,
          "content": [
            "int iomem_map_sanity_check(resource_size_t addr, unsigned long size)",
            "{",
            "\tstruct resource *p = &iomem_resource;",
            "\tresource_size_t end = addr + size - 1;",
            "\tint err = 0;",
            "\tloff_t l;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {",
            "\t\t/*",
            "\t\t * We can probably skip the resources without",
            "\t\t * IORESOURCE_IO attribute?",
            "\t\t */",
            "\t\tif (p->start > end)",
            "\t\t\tcontinue;",
            "\t\tif (p->end < addr)",
            "\t\t\tcontinue;",
            "\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&",
            "\t\t    PFN_DOWN(p->end) >= PFN_DOWN(end))",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * if a resource is \"BUSY\", it's not a hardware resource",
            "\t\t * but a driver mapping of such a resource; we don't want",
            "\t\t * to warn for those; some drivers legitimately map only",
            "\t\t * partial hardware resources. (example: vesafb)",
            "\t\t */",
            "\t\tif (p->flags & IORESOURCE_BUSY)",
            "\t\t\tcontinue;",
            "",
            "\t\tpr_warn(\"resource sanity check: requesting [mem %pa-%pa], which spans more than %s %pR\\n\",",
            "\t\t\t&addr, &end, p->name, p);",
            "\t\terr = -1;",
            "\t\tbreak;",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool resource_is_exclusive(struct resource *root, u64 addr, resource_size_t size)",
            "{",
            "\tconst unsigned int exclusive_system_ram = IORESOURCE_SYSTEM_RAM |",
            "\t\t\t\t\t\t  IORESOURCE_EXCLUSIVE;",
            "\tbool skip_children = false, err = false;",
            "\tstruct resource *p;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor_each_resource(root, p, skip_children) {",
            "\t\tif (p->start >= addr + size)",
            "\t\t\tbreak;",
            "\t\tif (p->end < addr) {",
            "\t\t\tskip_children = true;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tskip_children = false;",
            "",
            "\t\t/*",
            "\t\t * IORESOURCE_SYSTEM_RAM resources are exclusive if",
            "\t\t * IORESOURCE_EXCLUSIVE is set, even if they",
            "\t\t * are not busy and even if \"iomem=relaxed\" is set. The",
            "\t\t * responsible driver dynamically adds/removes system RAM within",
            "\t\t * such an area and uncontrolled access is dangerous.",
            "\t\t */",
            "\t\tif ((p->flags & exclusive_system_ram) == exclusive_system_ram) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * A resource is exclusive if IORESOURCE_EXCLUSIVE is set",
            "\t\t * or CONFIG_IO_STRICT_DEVMEM is enabled and the",
            "\t\t * resource is busy.",
            "\t\t */",
            "\t\tif (!strict_iomem_checks || !(p->flags & IORESOURCE_BUSY))",
            "\t\t\tcontinue;",
            "\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)",
            "\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool iomem_is_exclusive(u64 addr)",
            "{",
            "\treturn resource_is_exclusive(&iomem_resource, addr & PAGE_MASK,",
            "\t\t\t\t     PAGE_SIZE);",
            "}",
            "void resource_list_free(struct list_head *head)",
            "{",
            "\tstruct resource_entry *entry, *tmp;",
            "",
            "\tlist_for_each_entry_safe(entry, tmp, head, node)",
            "\t\tresource_list_destroy_entry(entry);",
            "}",
            "static resource_size_t gfr_start(struct resource *base, resource_size_t size,",
            "\t\t\t\t resource_size_t align, unsigned long flags)",
            "{",
            "\tif (flags & GFR_DESCENDING) {",
            "\t\tresource_size_t end;",
            "",
            "\t\tend = min_t(resource_size_t, base->end, PHYSMEM_END);",
            "\t\treturn end - size + 1;",
            "\t}",
            "",
            "\treturn ALIGN(base->start, align);",
            "}"
          ],
          "function_name": "iomem_map_sanity_check, resource_is_exclusive, iomem_is_exclusive, resource_list_free, gfr_start",
          "description": "iomem_map_sanity_check 检查新请求的I/O内存区域是否与现有资源冲突，若存在覆盖则返回-1；resource_is_exclusive 判断目标地址是否属于独占资源，依据IORESOURCE_EXCLUSIVE标志及CONFIG_IO_STRICT_DEVMEM配置；iomem_is_exclusive 简化调用resource_is_exclusive检查单个地址；resource_list_free 遍历并销毁指定链表中的所有resource_entry；gfr_start 根据对齐方向计算起始地址，支持降序分配模式。",
          "similarity": 0.601255476474762
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/resource.c",
          "start_line": 802,
          "end_line": 912,
          "content": [
            "int allocate_resource(struct resource *root, struct resource *new,",
            "\t\t      resource_size_t size, resource_size_t min,",
            "\t\t      resource_size_t max, resource_size_t align,",
            "\t\t      resource_size_t (*alignf)(void *,",
            "\t\t\t\t\t\tconst struct resource *,",
            "\t\t\t\t\t\tresource_size_t,",
            "\t\t\t\t\t\tresource_size_t),",
            "\t\t      void *alignf_data)",
            "{",
            "\tint err;",
            "\tstruct resource_constraint constraint;",
            "",
            "\tif (!alignf)",
            "\t\talignf = simple_align_resource;",
            "",
            "\tconstraint.min = min;",
            "\tconstraint.max = max;",
            "\tconstraint.align = align;",
            "\tconstraint.alignf = alignf;",
            "\tconstraint.alignf_data = alignf_data;",
            "",
            "\tif ( new->parent ) {",
            "\t\t/* resource is already allocated, try reallocating with",
            "\t\t   the new constraints */",
            "\t\treturn reallocate_resource(root, new, size, &constraint);",
            "\t}",
            "",
            "\twrite_lock(&resource_lock);",
            "\terr = find_resource(root, new, size, &constraint);",
            "\tif (err >= 0 && __request_resource(root, new))",
            "\t\terr = -EBUSY;",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}",
            "int insert_resource(struct resource *parent, struct resource *new)",
            "{",
            "\tstruct resource *conflict;",
            "",
            "\tconflict = insert_resource_conflict(parent, new);",
            "\treturn conflict ? -EBUSY : 0;",
            "}",
            "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)",
            "{",
            "\tif (new->parent)",
            "\t\treturn;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tconflict = __insert_resource(root, new);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\tif (conflict == root)",
            "\t\t\tbreak;",
            "",
            "\t\t/* Ok, expand resource to cover the conflict, then try again .. */",
            "\t\tif (conflict->start < new->start)",
            "\t\t\tnew->start = conflict->start;",
            "\t\tif (conflict->end > new->end)",
            "\t\t\tnew->end = conflict->end;",
            "",
            "\t\tpr_info(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);",
            "\t}",
            "\twrite_unlock(&resource_lock);",
            "}",
            "int remove_resource(struct resource *old)",
            "{",
            "\tint retval;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tretval = __release_resource(old, false);",
            "\twrite_unlock(&resource_lock);",
            "\treturn retval;",
            "}",
            "static int __adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t\t\tresource_size_t size)",
            "{",
            "\tstruct resource *tmp, *parent = res->parent;",
            "\tresource_size_t end = start + size - 1;",
            "\tint result = -EBUSY;",
            "",
            "\tif (!parent)",
            "\t\tgoto skip;",
            "",
            "\tif ((start < parent->start) || (end > parent->end))",
            "\t\tgoto out;",
            "",
            "\tif (res->sibling && (res->sibling->start <= end))",
            "\t\tgoto out;",
            "",
            "\ttmp = parent->child;",
            "\tif (tmp != res) {",
            "\t\twhile (tmp->sibling != res)",
            "\t\t\ttmp = tmp->sibling;",
            "\t\tif (start <= tmp->end)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "skip:",
            "\tfor (tmp = res->child; tmp; tmp = tmp->sibling)",
            "\t\tif ((tmp->start < start) || (tmp->end > end))",
            "\t\t\tgoto out;",
            "",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tresult = 0;",
            "",
            " out:",
            "\treturn result;",
            "}"
          ],
          "function_name": "allocate_resource, insert_resource, insert_resource_expand_to_fit, remove_resource, __adjust_resource",
          "description": "实现资源分配逻辑，支持带约束条件的资源查找与申请，处理资源冲突及扩展调整，提供基础资源管理框架。",
          "similarity": 0.6002656817436218
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/resource.c",
          "start_line": 1561,
          "end_line": 1661,
          "content": [
            "static void devm_resource_release(struct device *dev, void *ptr)",
            "{",
            "\tstruct resource **r = ptr;",
            "",
            "\trelease_resource(*r);",
            "}",
            "int devm_request_resource(struct device *dev, struct resource *root,",
            "\t\t\t  struct resource *new)",
            "{",
            "\tstruct resource *conflict, **ptr;",
            "",
            "\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);",
            "\tif (!ptr)",
            "\t\treturn -ENOMEM;",
            "",
            "\t*ptr = new;",
            "",
            "\tconflict = request_resource_conflict(root, new);",
            "\tif (conflict) {",
            "\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",",
            "\t\t\tnew, conflict->name, conflict);",
            "\t\tdevres_free(ptr);",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tdevres_add(dev, ptr);",
            "\treturn 0;",
            "}",
            "static int devm_resource_match(struct device *dev, void *res, void *data)",
            "{",
            "\tstruct resource **ptr = res;",
            "",
            "\treturn *ptr == data;",
            "}",
            "void devm_release_resource(struct device *dev, struct resource *new)",
            "{",
            "\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,",
            "\t\t\t       new));",
            "}",
            "static void devm_region_release(struct device *dev, void *res)",
            "{",
            "\tstruct region_devres *this = res;",
            "",
            "\t__release_region(this->parent, this->start, this->n);",
            "}",
            "static int devm_region_match(struct device *dev, void *res, void *match_data)",
            "{",
            "\tstruct region_devres *this = res, *match = match_data;",
            "",
            "\treturn this->parent == match->parent &&",
            "\t\tthis->start == match->start && this->n == match->n;",
            "}",
            "void __devm_release_region(struct device *dev, struct resource *parent,",
            "\t\t\t   resource_size_t start, resource_size_t n)",
            "{",
            "\tstruct region_devres match_data = { parent, start, n };",
            "",
            "\t__release_region(parent, start, n);",
            "\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,",
            "\t\t\t       &match_data));",
            "}",
            "static int __init reserve_setup(char *str)",
            "{",
            "\tstatic int reserved;",
            "\tstatic struct resource reserve[MAXRESERVE];",
            "",
            "\tfor (;;) {",
            "\t\tunsigned int io_start, io_num;",
            "\t\tint x = reserved;",
            "\t\tstruct resource *parent;",
            "",
            "\t\tif (get_option(&str, &io_start) != 2)",
            "\t\t\tbreak;",
            "\t\tif (get_option(&str, &io_num) == 0)",
            "\t\t\tbreak;",
            "\t\tif (x < MAXRESERVE) {",
            "\t\t\tstruct resource *res = reserve + x;",
            "",
            "\t\t\t/*",
            "\t\t\t * If the region starts below 0x10000, we assume it's",
            "\t\t\t * I/O port space; otherwise assume it's memory.",
            "\t\t\t */",
            "\t\t\tif (io_start < 0x10000) {",
            "\t\t\t\tres->flags = IORESOURCE_IO;",
            "\t\t\t\tparent = &ioport_resource;",
            "\t\t\t} else {",
            "\t\t\t\tres->flags = IORESOURCE_MEM;",
            "\t\t\t\tparent = &iomem_resource;",
            "\t\t\t}",
            "\t\t\tres->name = \"reserved\";",
            "\t\t\tres->start = io_start;",
            "\t\t\tres->end = io_start + io_num - 1;",
            "\t\t\tres->flags |= IORESOURCE_BUSY;",
            "\t\t\tres->desc = IORES_DESC_NONE;",
            "\t\t\tres->child = NULL;",
            "\t\t\tif (request_resource(parent, res) == 0)",
            "\t\t\t\treserved = x+1;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}"
          ],
          "function_name": "devm_resource_release, devm_request_resource, devm_resource_match, devm_release_resource, devm_region_release, devm_region_match, __devm_release_region, reserve_setup",
          "description": "实现设备资源管理器（devm）的资源申请/释放机制，包含预留资源初始化及设备资源生命周期绑定功能。",
          "similarity": 0.5878587961196899
        }
      ]
    },
    {
      "source_file": "kernel/bpf/token.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:36:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\token.c`\n\n---\n\n# `bpf/token.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/token.c` 实现了 BPF（Berkeley Packet Filter）令牌（token）机制，用于在受限环境中安全地委托 BPF 操作权限。该机制允许用户空间程序通过文件描述符形式的令牌，将特定的 BPF 命令、映射类型、程序类型和附加类型权限委托给其他进程，同时结合用户命名空间（user namespace）和 LSM（Linux Security Module）安全策略进行细粒度访问控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `bpf_ns_capable()`：检查用户命名空间是否具备指定能力，或具备 `CAP_SYS_ADMIN`（除 `CAP_SYS_ADMIN` 自身外）。\n- `bpf_token_capable()`：结合用户命名空间能力和 LSM 安全钩子，判断令牌是否具备指定能力。\n- `bpf_token_inc()` / `bpf_token_put()`：引用计数管理，支持延迟释放。\n- `bpf_token_free()`：释放令牌资源，包括用户命名空间引用和安全模块数据。\n- `bpf_token_create()`：创建 BPF 令牌文件描述符，基于挂载在 BPF 文件系统上的委托配置。\n- `bpf_token_get_from_fd()`：从文件描述符获取并增加引用计数的 `bpf_token` 结构。\n- `bpf_token_allow_cmd()` / `bpf_token_allow_map_type()` / `bpf_token_allow_prog_type()`：检查令牌是否允许执行特定 BPF 操作。\n\n### 关键数据结构\n\n- `struct bpf_token`：表示 BPF 令牌，包含：\n  - `refcnt`：引用计数（`atomic64_t`）\n  - `userns`：关联的用户命名空间\n  - `allowed_cmds` / `allowed_maps` / `allowed_progs` / `allowed_attachs`：位掩码，分别表示允许的 BPF 命令、映射类型、程序类型和附加类型\n  - `work`：用于延迟释放的工作队列项\n\n### 文件操作接口\n\n- `bpf_token_fops`：定义了 `release` 和 `show_fdinfo` 回调，用于文件关闭和 `/proc/pid/fdinfo/` 信息展示。\n\n## 3. 关键实现\n\n### 令牌创建流程 (`bpf_token_create`)\n\n1. **验证输入**：检查传入的 `bpffs_fd` 是否指向 BPF 文件系统的根目录。\n2. **权限校验**：\n   - 要求调用者与 BPF 文件系统实例处于同一用户命名空间。\n   - 必须具备 `CAP_BPF` 能力。\n   - 禁止在 `init_user_ns` 中创建令牌。\n3. **委托配置检查**：确保 BPF 文件系统挂载时已通过挂载选项设置了至少一项委托权限（`delegate_*` 字段非零）。\n4. **资源分配**：\n   - 创建匿名 inode 和文件。\n   - 分配 `bpf_token` 结构并初始化引用计数为 1。\n   - 复制挂载选项中的委托位掩码到令牌。\n5. **安全模块集成**：调用 `security_bpf_token_create()` 允许 LSM 进行额外策略检查。\n6. **返回文件描述符**：安装文件到进程 fd 表并返回。\n\n### 安全能力检查 (`bpf_token_capable`)\n\n- 默认允许 `CAP_SYS_ADMIN` 作为“超级能力”覆盖其他能力检查（但 `CAP_SYS_ADMIN` 本身仍需显式授权）。\n- 调用 `security_bpf_token_capable()` 允许 LSM 对令牌能力进行二次验证。\n\n### 引用计数与延迟释放\n\n- 使用 `atomic64_t refcnt` 管理生命周期。\n- 当引用计数归零时，通过 `schedule_work()` 将释放操作推迟到工作队列执行，避免在中断或原子上下文中调用可能睡眠的 `put_user_ns()` 和 `kfree()`。\n\n### `/proc/pid/fdinfo/` 支持\n\n- `bpf_token_show_fdinfo()` 将令牌的委托权限以十六进制或 \"any\" 形式输出，便于调试和审计。\n\n### 权限位掩码设计\n\n- 所有委托权限（命令、映射、程序、附加类型）均使用 64 位无符号整数位掩码表示。\n- 通过 `BUILD_BUG_ON()` 确保枚举类型数量不超过 64，防止位移溢出。\n- 若掩码全为 1，则显示为 \"any\"，表示无限制。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_super_ops`、`bpf_get_inode()` 等 BPF 文件系统接口。\n- **用户命名空间**：通过 `user_namespace` 和 `ns_capable()` 实现能力隔离。\n- **安全模块 (LSM)**：集成 `security_bpf_token_*` 钩子，支持 SELinux、AppArmor 等策略扩展。\n- **VFS 层**：使用 `inode`、`file`、`path`、`fdtable` 等通用文件系统抽象。\n- **内存管理**：使用 `kzalloc()`/`kfree()` 和 `vmalloc.h`（虽未直接使用，但为潜在扩展预留）。\n- **工作队列**：通过 `schedule_work()` 实现延迟释放。\n\n## 5. 使用场景\n\n- **容器化环境中的 BPF 权限委托**：在用户命名空间隔离的容器中，特权进程可创建 BPF 令牌并传递给非特权子进程，使其在受限范围内使用 BPF 功能（如 eBPF 程序加载、映射操作）。\n- **安全沙箱**：应用程序可通过令牌机制将特定 BPF 操作权限委托给插件或子模块，避免授予完整 `CAP_BPF` 或 `CAP_SYS_ADMIN`。\n- **审计与调试**：通过 `/proc/pid/fdinfo/` 查看进程持有的 BPF 令牌权限，辅助安全分析。\n- **LSM 策略集成**：安全模块可基于令牌内容实施更细粒度的访问控制，例如限制特定程序类型只能在特定挂载点使用。",
      "similarity": 0.5869605541229248,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/token.c",
          "start_line": 230,
          "end_line": 254,
          "content": [
            "bool bpf_token_allow_cmd(const struct bpf_token *token, enum bpf_cmd cmd)",
            "{",
            "\tif (!token)",
            "\t\treturn false;",
            "\tif (!(token->allowed_cmds & (1ULL << cmd)))",
            "\t\treturn false;",
            "\treturn security_bpf_token_cmd(token, cmd) == 0;",
            "}",
            "bool bpf_token_allow_map_type(const struct bpf_token *token, enum bpf_map_type type)",
            "{",
            "\tif (!token || type >= __MAX_BPF_MAP_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn token->allowed_maps & (1ULL << type);",
            "}",
            "bool bpf_token_allow_prog_type(const struct bpf_token *token,",
            "\t\t\t       enum bpf_prog_type prog_type,",
            "\t\t\t       enum bpf_attach_type attach_type)",
            "{",
            "\tif (!token || prog_type >= __MAX_BPF_PROG_TYPE || attach_type >= __MAX_BPF_ATTACH_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn (token->allowed_progs & (1ULL << prog_type)) &&",
            "\t       (token->allowed_attachs & (1ULL << attach_type));",
            "}"
          ],
          "function_name": "bpf_token_allow_cmd, bpf_token_allow_map_type, bpf_token_allow_prog_type",
          "description": "提供对BPF命令、映射类型和程序类型的访问控制检查，通过位掩码匹配并结合安全模块验证权限。",
          "similarity": 0.5976680517196655
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/token.c",
          "start_line": 12,
          "end_line": 195,
          "content": [
            "static bool bpf_ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable(ns, cap) || (cap != CAP_SYS_ADMIN && ns_capable(ns, CAP_SYS_ADMIN));",
            "}",
            "bool bpf_token_capable(const struct bpf_token *token, int cap)",
            "{",
            "\tstruct user_namespace *userns;",
            "",
            "\t/* BPF token allows ns_capable() level of capabilities */",
            "\tuserns = token ? token->userns : &init_user_ns;",
            "\tif (!bpf_ns_capable(userns, cap))",
            "\t\treturn false;",
            "\tif (token && security_bpf_token_capable(token, cap) < 0)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "void bpf_token_inc(struct bpf_token *token)",
            "{",
            "\tatomic64_inc(&token->refcnt);",
            "}",
            "static void bpf_token_free(struct bpf_token *token)",
            "{",
            "\tsecurity_bpf_token_free(token);",
            "\tput_user_ns(token->userns);",
            "\tkfree(token);",
            "}",
            "static void bpf_token_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_token *token = container_of(work, struct bpf_token, work);",
            "",
            "\tbpf_token_free(token);",
            "}",
            "void bpf_token_put(struct bpf_token *token)",
            "{",
            "\tif (!token)",
            "\t\treturn;",
            "",
            "\tif (!atomic64_dec_and_test(&token->refcnt))",
            "\t\treturn;",
            "",
            "\tINIT_WORK(&token->work, bpf_token_put_deferred);",
            "\tschedule_work(&token->work);",
            "}",
            "static int bpf_token_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "",
            "\tbpf_token_put(token);",
            "\treturn 0;",
            "}",
            "static void bpf_token_show_fdinfo(struct seq_file *m, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "\tu64 mask;",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_CMD >= 64);",
            "\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\tif ((token->allowed_cmds & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_cmds:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_cmds:\\t0x%llx\\n\", token->allowed_cmds);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_MAP_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\tif ((token->allowed_maps & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_maps:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_maps:\\t0x%llx\\n\", token->allowed_maps);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_PROG_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\tif ((token->allowed_progs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_progs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_progs:\\t0x%llx\\n\", token->allowed_progs);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_ATTACH_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\tif ((token->allowed_attachs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_attachs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_attachs:\\t0x%llx\\n\", token->allowed_attachs);",
            "}",
            "int bpf_token_create(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_mount_opts *mnt_opts;",
            "\tstruct bpf_token *token = NULL;",
            "\tstruct user_namespace *userns;",
            "\tstruct inode *inode;",
            "\tstruct file *file;",
            "\tCLASS(fd, f)(attr->token_create.bpffs_fd);",
            "\tstruct path path;",
            "\tstruct super_block *sb;",
            "\tumode_t mode;",
            "\tint err, fd;",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "",
            "\tpath = fd_file(f)->f_path;",
            "\tsb = path.dentry->d_sb;",
            "",
            "\tif (path.dentry != sb->s_root)",
            "\t\treturn -EINVAL;",
            "\tif (sb->s_op != &bpf_super_ops)",
            "\t\treturn -EINVAL;",
            "\terr = path_permission(&path, MAY_ACCESS);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tuserns = sb->s_user_ns;",
            "\t/*",
            "\t * Enforce that creators of BPF tokens are in the same user",
            "\t * namespace as the BPF FS instance. This makes reasoning about",
            "\t * permissions a lot easier and we can always relax this later.",
            "\t */",
            "\tif (current_user_ns() != userns)",
            "\t\treturn -EPERM;",
            "\tif (!ns_capable(userns, CAP_BPF))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Creating BPF token in init_user_ns doesn't make much sense. */",
            "\tif (current_user_ns() == &init_user_ns)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tmnt_opts = sb->s_fs_info;",
            "\tif (mnt_opts->delegate_cmds == 0 &&",
            "\t    mnt_opts->delegate_maps == 0 &&",
            "\t    mnt_opts->delegate_progs == 0 &&",
            "\t    mnt_opts->delegate_attachs == 0)",
            "\t\treturn -ENOENT; /* no BPF token delegation is set up */",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tinode = bpf_get_inode(sb, NULL, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_token_iops;",
            "\tinode->i_fop = &bpf_token_fops;",
            "\tclear_nlink(inode); /* make sure it is unlinked */",
            "",
            "\tfile = alloc_file_pseudo(inode, path.mnt, BPF_TOKEN_INODE_NAME, O_RDWR, &bpf_token_fops);",
            "\tif (IS_ERR(file)) {",
            "\t\tiput(inode);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\ttoken = kzalloc(sizeof(*token), GFP_USER);",
            "\tif (!token) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_file;",
            "\t}",
            "",
            "\tatomic64_set(&token->refcnt, 1);",
            "",
            "\t/* remember bpffs owning userns for future ns_capable() checks */",
            "\ttoken->userns = get_user_ns(userns);",
            "",
            "\ttoken->allowed_cmds = mnt_opts->delegate_cmds;",
            "\ttoken->allowed_maps = mnt_opts->delegate_maps;",
            "\ttoken->allowed_progs = mnt_opts->delegate_progs;",
            "\ttoken->allowed_attachs = mnt_opts->delegate_attachs;",
            "",
            "\terr = security_bpf_token_create(token, attr, &path);",
            "\tif (err)",
            "\t\tgoto out_token;",
            "",
            "\tfd = get_unused_fd_flags(O_CLOEXEC);",
            "\tif (fd < 0) {",
            "\t\terr = fd;",
            "\t\tgoto out_token;",
            "\t}",
            "",
            "\tfile->private_data = token;",
            "\tfd_install(fd, file);",
            "",
            "\treturn fd;",
            "",
            "out_token:",
            "\tbpf_token_free(token);",
            "out_file:",
            "\tfput(file);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_ns_capable, bpf_token_capable, bpf_token_inc, bpf_token_free, bpf_token_put_deferred, bpf_token_put, bpf_token_release, bpf_token_show_fdinfo, bpf_token_create",
          "description": "实现BPF令牌的权限检查、引用计数管理、延迟释放及创建逻辑，包括基于挂载选项的令牌初始化和安全策略校验。",
          "similarity": 0.5762567520141602
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/token.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            ""
          ],
          "function_name": null,
          "description": "包含BPF令牌功能所需的各种内核头文件，如用户命名空间、安全策略、文件操作及BPF相关定义。",
          "similarity": 0.5495604276657104
        }
      ]
    },
    {
      "source_file": "mm/memcontrol-v1.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memcontrol-v1.c`\n\n---\n\n# memcontrol-v1.c 技术文档\n\n## 1. 文件概述\n\n`memcontrol-v1.c` 是 Linux 内核内存控制组（Memory Cgroup）v1 接口的核心实现文件之一，主要负责基于软限制（soft limit）的内存回收机制、OOM 事件通知以及与 cgroup v1 兼容的资源统计和管理功能。该文件维护了一个独立于 cgroup 层级结构的红黑树（RB-Tree），用于高效地追踪和选择超出软限制最多的内存控制组进行内存回收。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mem_cgroup_tree_per_node`**  \n  每个 NUMA 节点对应的红黑树结构，用于存储超出软限制的 `mem_cgroup_per_node` 实例。\n  - `rb_root`: 红黑树根节点\n  - `rb_rightmost`: 指向使用量超出软限制最多的节点（树中最右侧节点）\n  - `lock`: 保护该树的自旋锁\n\n- **`struct mem_cgroup_tree`**  \n  全局软限制树结构，包含每个 NUMA 节点对应的 `mem_cgroup_tree_per_node`。\n\n- **`struct mem_cgroup_eventfd_list`**  \n  用于 OOM 事件通知的 eventfd 列表项。\n\n- **`struct mem_cgroup_event`**  \n  表示用户空间注册的内存事件（如 OOM、阈值触发等），支持通过 eventfd 通知用户空间。\n\n- **枚举常量 `RES_*`**  \n  定义了 cgroup v1 接口中可读写的资源属性类型（如使用量、限制、最大使用量、失败计数、软限制等）。\n\n### 主要函数\n\n- **`__mem_cgroup_insert_exceeded()` / `__mem_cgroup_remove_exceeded()`**  \n  在指定节点的软限制红黑树中插入或移除一个 `mem_cgroup_per_node` 节点。\n\n- **`memcg1_update_tree()`**  \n  根据当前内存使用量与软限制的差值，更新指定 memcg 及其所有祖先在软限制树中的位置。\n\n- **`memcg1_remove_from_trees()`**  \n  在 memcg 销毁时，将其从所有 NUMA 节点的软限制树中移除。\n\n- **`mem_cgroup_largest_soft_limit_node()`**  \n  从指定节点的软限制树中找出超出软限制最多的 memcg 节点，用于优先回收。\n\n- **`mem_cgroup_soft_reclaim()`**  \n  对指定 memcg 层级结构执行软限制驱动的内存回收。\n\n- **`memcg1_soft_limit_reclaim()`**（未完整显示）  \n  全局软限制回收入口函数，由内存短缺路径调用，尝试从超出软限制的 memcg 中回收内存。\n\n## 3. 关键实现\n\n### 软限制红黑树机制\n\n- 所有超出软限制（`memory.usage > soft_limit`）的 `mem_cgroup_per_node` 实例被组织到 per-NUMA-node 的红黑树中。\n- 树按 `usage_in_excess = usage - soft_limit` 升序排列，最右侧节点即为超出最多的 memcg。\n- 当 memcg 的内存使用量变化或软限制被修改时，调用 `memcg1_update_tree()` 更新其在树中的位置（先删除再重新插入）。\n- 回收时优先选择 `rb_rightmost` 节点，确保优先回收“最违规”的 memcg。\n\n### 层级遍历与祖先更新\n\n- 在启用 cgroup 层级模式时，子 memcg 的内存使用会影响父 memcg 的统计。\n- 因此，当子 memcg 的使用量变化时，需向上遍历所有祖先，更新它们在软限制树中的状态。\n\n### 防止无限循环的回收控制\n\n- `MEM_CGROUP_MAX_RECLAIM_LOOPS`（100）和 `MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS`（2）用于限制回收循环次数。\n- 若一轮遍历未回收足够内存（`total < excess >> 2`），最多再尝试一次。\n\n### 与 LRU_GEN 的集成\n\n- 若启用了多代 LRU（`lru_gen_enabled()`），则绕过红黑树机制，直接调用 `lru_gen_soft_reclaim()` 进行软限制回收。\n\n### 事件通知机制\n\n- 支持通过 `eventfd` 向用户空间发送 OOM 或其他内存事件通知。\n- 使用 `poll_table` 和 `wait_queue` 实现 eventfd 的自动注销（当 fd 关闭时）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memcontrol.h>`：内存控制组核心接口\n  - `<linux/swap.h>`, `\"swap.h\"`：交换子系统支持\n  - `<linux/eventfd.h>`, `<linux/poll.h>`：事件通知机制\n  - `\"internal.h\"`：内核内存管理内部接口\n\n- **功能依赖**：\n  - 依赖 `page_counter` 子系统进行内存使用量统计\n  - 依赖 `mem_cgroup_iter()` 实现层级遍历\n  - 依赖 `mem_cgroup_shrink_node()` 执行实际页面回收\n  - 可选依赖 `lru_gen` 多代 LRU 回收器\n\n- **配置依赖**：\n  - `CONFIG_MEMCG`：必须启用内存 cgroup\n  - `CONFIG_LOCKDEP`：仅在调试时定义锁依赖映射\n\n## 5. 使用场景\n\n- **内存压力下的软限制回收**：当系统内存紧张时，`kswapd` 或直接回收路径会调用 `memcg1_soft_limit_reclaim()`，优先从超出软限制的 memcg 中回收内存，以维持服务质量（QoS）。\n- **cgroup v1 接口兼容**：为 `/sys/fs/cgroup/memory/` 下的 `memory.soft_limit_in_bytes` 等文件提供后端支持。\n- **OOM 事件通知**：当 memcg 触发 OOM 时，通过预先注册的 eventfd 向用户空间守护进程（如容器运行时）发送通知。\n- **动态资源调整**：当用户通过写入 `memory.soft_limit_in_bytes` 修改软限制时，触发 `memcg1_update_tree()` 更新红黑树结构。\n- **memcg 销毁清理**：在 cgroup 被删除时，确保其从所有软限制树中正确移除，防止悬挂指针。",
      "similarity": 0.5806723237037659,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 1400,
          "end_line": 1528,
          "content": [
            "static int mem_cgroup_force_empty(struct mem_cgroup *memcg)",
            "{",
            "\tint nr_retries = MAX_RECLAIM_RETRIES;",
            "",
            "\t/* we call try-to-free pages for make this cgroup empty */",
            "\tlru_add_drain_all();",
            "",
            "\tdrain_all_stock(memcg);",
            "",
            "\t/* try to free all pages in this cgroup */",
            "\twhile (nr_retries && page_counter_read(&memcg->memory)) {",
            "\t\tif (signal_pending(current))",
            "\t\t\treturn -EINTR;",
            "",
            "\t\tif (!try_to_free_mem_cgroup_pages(memcg, 1, GFP_KERNEL,",
            "\t\t\t\t\t\t  MEMCG_RECLAIM_MAY_SWAP))",
            "\t\t\tnr_retries--;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static ssize_t mem_cgroup_force_empty_write(struct kernfs_open_file *of,",
            "\t\t\t\t\t    char *buf, size_t nbytes,",
            "\t\t\t\t\t    loff_t off)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));",
            "",
            "\tif (mem_cgroup_is_root(memcg))",
            "\t\treturn -EINVAL;",
            "\treturn mem_cgroup_force_empty(memcg) ?: nbytes;",
            "}",
            "static u64 mem_cgroup_hierarchy_read(struct cgroup_subsys_state *css,",
            "\t\t\t\t     struct cftype *cft)",
            "{",
            "\treturn 1;",
            "}",
            "static int mem_cgroup_hierarchy_write(struct cgroup_subsys_state *css,",
            "\t\t\t\t      struct cftype *cft, u64 val)",
            "{",
            "\tif (val == 1)",
            "\t\treturn 0;",
            "",
            "\tpr_warn_once(\"Non-hierarchical mode is deprecated. \"",
            "\t\t     \"Please report your usecase to linux-mm@kvack.org if you \"",
            "\t\t     \"depend on this functionality.\\n\");",
            "",
            "\treturn -EINVAL;",
            "}",
            "static u64 mem_cgroup_read_u64(struct cgroup_subsys_state *css,",
            "\t\t\t       struct cftype *cft)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);",
            "\tstruct page_counter *counter;",
            "",
            "\tswitch (MEMFILE_TYPE(cft->private)) {",
            "\tcase _MEM:",
            "\t\tcounter = &memcg->memory;",
            "\t\tbreak;",
            "\tcase _MEMSWAP:",
            "\t\tcounter = &memcg->memsw;",
            "\t\tbreak;",
            "\tcase _KMEM:",
            "\t\tcounter = &memcg->kmem;",
            "\t\tbreak;",
            "\tcase _TCP:",
            "\t\tcounter = &memcg->tcpmem;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\tswitch (MEMFILE_ATTR(cft->private)) {",
            "\tcase RES_USAGE:",
            "\t\tif (counter == &memcg->memory)",
            "\t\t\treturn (u64)mem_cgroup_usage(memcg, false) * PAGE_SIZE;",
            "\t\tif (counter == &memcg->memsw)",
            "\t\t\treturn (u64)mem_cgroup_usage(memcg, true) * PAGE_SIZE;",
            "\t\treturn (u64)page_counter_read(counter) * PAGE_SIZE;",
            "\tcase RES_LIMIT:",
            "\t\treturn (u64)counter->max * PAGE_SIZE;",
            "\tcase RES_MAX_USAGE:",
            "\t\treturn (u64)counter->watermark * PAGE_SIZE;",
            "\tcase RES_FAILCNT:",
            "\t\treturn counter->failcnt;",
            "\tcase RES_SOFT_LIMIT:",
            "\t\treturn (u64)READ_ONCE(memcg->soft_limit) * PAGE_SIZE;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "static int mem_cgroup_dummy_seq_show(__always_unused struct seq_file *m,",
            "\t\t\t\t     __always_unused void *v)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int memcg_update_tcp_max(struct mem_cgroup *memcg, unsigned long max)",
            "{",
            "\tint ret;",
            "",
            "\tmutex_lock(&memcg_max_mutex);",
            "",
            "\tret = page_counter_set_max(&memcg->tcpmem, max);",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tif (!memcg->tcpmem_active) {",
            "\t\t/*",
            "\t\t * The active flag needs to be written after the static_key",
            "\t\t * update. This is what guarantees that the socket activation",
            "\t\t * function is the last one to run. See mem_cgroup_sk_alloc()",
            "\t\t * for details, and note that we don't mark any socket as",
            "\t\t * belonging to this memcg until that flag is up.",
            "\t\t *",
            "\t\t * We need to do this, because static_keys will span multiple",
            "\t\t * sites, but we can't control their order. If we mark a socket",
            "\t\t * as accounted, but the accounting functions are not patched in",
            "\t\t * yet, we'll lose accounting.",
            "\t\t *",
            "\t\t * We never race with the readers in mem_cgroup_sk_alloc(),",
            "\t\t * because when this value change, the code to process it is not",
            "\t\t * patched in yet.",
            "\t\t */",
            "\t\tstatic_branch_inc(&memcg_sockets_enabled_key);",
            "\t\tmemcg->tcpmem_active = true;",
            "\t}",
            "out:",
            "\tmutex_unlock(&memcg_max_mutex);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "mem_cgroup_force_empty, mem_cgroup_force_empty_write, mem_cgroup_hierarchy_read, mem_cgroup_hierarchy_write, mem_cgroup_read_u64, mem_cgroup_dummy_seq_show, memcg_update_tcp_max",
          "description": "提供内存控制组的强制清空、层级参数读写及统计信息查询功能。包含内存使用量读取接口、虚拟内存软限制更新及TCP内存上限调整逻辑，支持不同资源类型的计数器访问。",
          "similarity": 0.639068603515625
        },
        {
          "chunk_id": 10,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 1544,
          "end_line": 1646,
          "content": [
            "static ssize_t mem_cgroup_write(struct kernfs_open_file *of,",
            "\t\t\t\tchar *buf, size_t nbytes, loff_t off)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));",
            "\tunsigned long nr_pages;",
            "\tint ret;",
            "",
            "\tbuf = strstrip(buf);",
            "\tret = page_counter_memparse(buf, \"-1\", &nr_pages);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {",
            "\tcase RES_LIMIT:",
            "\t\tif (mem_cgroup_is_root(memcg)) { /* Can't set limit on root */",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {",
            "\t\tcase _MEM:",
            "\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, false);",
            "\t\t\tbreak;",
            "\t\tcase _MEMSWAP:",
            "\t\t\tret = mem_cgroup_resize_max(memcg, nr_pages, true);",
            "\t\t\tbreak;",
            "\t\tcase _KMEM:",
            "\t\t\tpr_warn_once(\"kmem.limit_in_bytes is deprecated and will be removed. \"",
            "\t\t\t\t     \"Writing any value to this file has no effect. \"",
            "\t\t\t\t     \"Please report your usecase to linux-mm@kvack.org if you \"",
            "\t\t\t\t     \"depend on this functionality.\\n\");",
            "\t\t\tret = 0;",
            "\t\t\tbreak;",
            "\t\tcase _TCP:",
            "\t\t\tret = memcg_update_tcp_max(memcg, nr_pages);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase RES_SOFT_LIMIT:",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\t\tret = -EOPNOTSUPP;",
            "\t\t} else {",
            "\t\t\tWRITE_ONCE(memcg->soft_limit, nr_pages);",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t\tbreak;",
            "\t}",
            "\treturn ret ?: nbytes;",
            "}",
            "static ssize_t mem_cgroup_reset(struct kernfs_open_file *of, char *buf,",
            "\t\t\t\tsize_t nbytes, loff_t off)",
            "{",
            "\tstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));",
            "\tstruct page_counter *counter;",
            "",
            "\tswitch (MEMFILE_TYPE(of_cft(of)->private)) {",
            "\tcase _MEM:",
            "\t\tcounter = &memcg->memory;",
            "\t\tbreak;",
            "\tcase _MEMSWAP:",
            "\t\tcounter = &memcg->memsw;",
            "\t\tbreak;",
            "\tcase _KMEM:",
            "\t\tcounter = &memcg->kmem;",
            "\t\tbreak;",
            "\tcase _TCP:",
            "\t\tcounter = &memcg->tcpmem;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {",
            "\tcase RES_MAX_USAGE:",
            "\t\tpage_counter_reset_watermark(counter);",
            "\t\tbreak;",
            "\tcase RES_FAILCNT:",
            "\t\tcounter->failcnt = 0;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\treturn nbytes;",
            "}",
            "static unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,",
            "\t\t\t\tint nid, unsigned int lru_mask, bool tree)",
            "{",
            "\tstruct lruvec *lruvec = mem_cgroup_lruvec(memcg, NODE_DATA(nid));",
            "\tunsigned long nr = 0;",
            "\tenum lru_list lru;",
            "",
            "\tVM_BUG_ON((unsigned)nid >= nr_node_ids);",
            "",
            "\tfor_each_lru(lru) {",
            "\t\tif (!(BIT(lru) & lru_mask))",
            "\t\t\tcontinue;",
            "\t\tif (tree)",
            "\t\t\tnr += lruvec_page_state(lruvec, NR_LRU_BASE + lru);",
            "\t\telse",
            "\t\t\tnr += lruvec_page_state_local(lruvec, NR_LRU_BASE + lru);",
            "\t}",
            "\treturn nr;",
            "}"
          ],
          "function_name": "mem_cgroup_write, mem_cgroup_reset, mem_cgroup_node_nr_lru_pages",
          "description": "实现内存控制组的写操作接口，根据不同的属性类型设置内存限制（如RES_LIMIT、RES_SOFT_LIMIT），对根控制组禁止设置限制并处理相应错误码。",
          "similarity": 0.6153530478477478
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 404,
          "end_line": 520,
          "content": [
            "static u64 mem_cgroup_move_charge_read(struct cgroup_subsys_state *css,",
            "\t\t\t\tstruct cftype *cft)",
            "{",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,",
            "\t\t\t\t struct cftype *cft, u64 val)",
            "{",
            "\tpr_warn_once(\"Cgroup memory moving (move_charge_at_immigrate) is deprecated. \"",
            "\t\t     \"Please report your usecase to linux-mm@kvack.org if you \"",
            "\t\t     \"depend on this functionality.\\n\");",
            "",
            "\tif (val != 0)",
            "\t\treturn -EINVAL;",
            "\treturn 0;",
            "}",
            "static int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,",
            "\t\t\t\t struct cftype *cft, u64 val)",
            "{",
            "\treturn -ENOSYS;",
            "}",
            "static void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)",
            "{",
            "\tstruct mem_cgroup_threshold_ary *t;",
            "\tunsigned long usage;",
            "\tint i;",
            "",
            "\trcu_read_lock();",
            "\tif (!swap)",
            "\t\tt = rcu_dereference(memcg->thresholds.primary);",
            "\telse",
            "\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);",
            "",
            "\tif (!t)",
            "\t\tgoto unlock;",
            "",
            "\tusage = mem_cgroup_usage(memcg, swap);",
            "",
            "\t/*",
            "\t * current_threshold points to threshold just below or equal to usage.",
            "\t * If it's not true, a threshold was crossed after last",
            "\t * call of __mem_cgroup_threshold().",
            "\t */",
            "\ti = t->current_threshold;",
            "",
            "\t/*",
            "\t * Iterate backward over array of thresholds starting from",
            "\t * current_threshold and check if a threshold is crossed.",
            "\t * If none of thresholds below usage is crossed, we read",
            "\t * only one element of the array here.",
            "\t */",
            "\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)",
            "\t\teventfd_signal(t->entries[i].eventfd);",
            "",
            "\t/* i = current_threshold + 1 */",
            "\ti++;",
            "",
            "\t/*",
            "\t * Iterate forward over array of thresholds starting from",
            "\t * current_threshold+1 and check if a threshold is crossed.",
            "\t * If none of thresholds above usage is crossed, we read",
            "\t * only one element of the array here.",
            "\t */",
            "\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)",
            "\t\teventfd_signal(t->entries[i].eventfd);",
            "",
            "\t/* Update current_threshold */",
            "\tt->current_threshold = i - 1;",
            "unlock:",
            "\trcu_read_unlock();",
            "}",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg)",
            "{",
            "\twhile (memcg) {",
            "\t\t__mem_cgroup_threshold(memcg, false);",
            "\t\tif (do_memsw_account())",
            "\t\t\t__mem_cgroup_threshold(memcg, true);",
            "",
            "\t\tmemcg = parent_mem_cgroup(memcg);",
            "\t}",
            "}",
            "static void memcg1_charge_statistics(struct mem_cgroup *memcg, int nr_pages)",
            "{",
            "\t/* pagein of a big page is an event. So, ignore page size */",
            "\tif (nr_pages > 0)",
            "\t\t__count_memcg_events(memcg, PGPGIN, 1);",
            "\telse {",
            "\t\t__count_memcg_events(memcg, PGPGOUT, 1);",
            "\t\tnr_pages = -nr_pages; /* for event */",
            "\t}",
            "",
            "\t__this_cpu_add(memcg->events_percpu->nr_page_events, nr_pages);",
            "}",
            "static bool memcg1_event_ratelimit(struct mem_cgroup *memcg,",
            "\t\t\t\tenum mem_cgroup_events_target target)",
            "{",
            "\tunsigned long val, next;",
            "",
            "\tval = __this_cpu_read(memcg->events_percpu->nr_page_events);",
            "\tnext = __this_cpu_read(memcg->events_percpu->targets[target]);",
            "\t/* from time_after() in jiffies.h */",
            "\tif ((long)(next - val) < 0) {",
            "\t\tswitch (target) {",
            "\t\tcase MEM_CGROUP_TARGET_THRESH:",
            "\t\t\tnext = val + THRESHOLDS_EVENTS_TARGET;",
            "\t\t\tbreak;",
            "\t\tcase MEM_CGROUP_TARGET_SOFTLIMIT:",
            "\t\t\tnext = val + SOFTLIMIT_EVENTS_TARGET;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t__this_cpu_write(memcg->events_percpu->targets[target], next);",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}"
          ],
          "function_name": "mem_cgroup_move_charge_read, mem_cgroup_move_charge_write, mem_cgroup_move_charge_write, __mem_cgroup_threshold, mem_cgroup_threshold, memcg1_charge_statistics, memcg1_event_ratelimit",
          "description": "实现内存使用阈值监测与事件触发机制，包含阈值比较排序、事件信号发送及页面事件统计功能，通过事件限速机制控制通知频率，支持软限制和交换空间双重阈值监控。",
          "similarity": 0.6096367835998535
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 109,
          "end_line": 216,
          "content": [
            "static void __mem_cgroup_insert_exceeded(struct mem_cgroup_per_node *mz,",
            "\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz,",
            "\t\t\t\t\t unsigned long new_usage_in_excess)",
            "{",
            "\tstruct rb_node **p = &mctz->rb_root.rb_node;",
            "\tstruct rb_node *parent = NULL;",
            "\tstruct mem_cgroup_per_node *mz_node;",
            "\tbool rightmost = true;",
            "",
            "\tif (mz->on_tree)",
            "\t\treturn;",
            "",
            "\tmz->usage_in_excess = new_usage_in_excess;",
            "\tif (!mz->usage_in_excess)",
            "\t\treturn;",
            "\twhile (*p) {",
            "\t\tparent = *p;",
            "\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_node,",
            "\t\t\t\t\ttree_node);",
            "\t\tif (mz->usage_in_excess < mz_node->usage_in_excess) {",
            "\t\t\tp = &(*p)->rb_left;",
            "\t\t\trightmost = false;",
            "\t\t} else {",
            "\t\t\tp = &(*p)->rb_right;",
            "\t\t}",
            "\t}",
            "",
            "\tif (rightmost)",
            "\t\tmctz->rb_rightmost = &mz->tree_node;",
            "",
            "\trb_link_node(&mz->tree_node, parent, p);",
            "\trb_insert_color(&mz->tree_node, &mctz->rb_root);",
            "\tmz->on_tree = true;",
            "}",
            "static void __mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,",
            "\t\t\t\t\t struct mem_cgroup_tree_per_node *mctz)",
            "{",
            "\tif (!mz->on_tree)",
            "\t\treturn;",
            "",
            "\tif (&mz->tree_node == mctz->rb_rightmost)",
            "\t\tmctz->rb_rightmost = rb_prev(&mz->tree_node);",
            "",
            "\trb_erase(&mz->tree_node, &mctz->rb_root);",
            "\tmz->on_tree = false;",
            "}",
            "static void mem_cgroup_remove_exceeded(struct mem_cgroup_per_node *mz,",
            "\t\t\t\t       struct mem_cgroup_tree_per_node *mctz)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&mctz->lock, flags);",
            "\t__mem_cgroup_remove_exceeded(mz, mctz);",
            "\tspin_unlock_irqrestore(&mctz->lock, flags);",
            "}",
            "static unsigned long soft_limit_excess(struct mem_cgroup *memcg)",
            "{",
            "\tunsigned long nr_pages = page_counter_read(&memcg->memory);",
            "\tunsigned long soft_limit = READ_ONCE(memcg->soft_limit);",
            "\tunsigned long excess = 0;",
            "",
            "\tif (nr_pages > soft_limit)",
            "\t\texcess = nr_pages - soft_limit;",
            "",
            "\treturn excess;",
            "}",
            "static void memcg1_update_tree(struct mem_cgroup *memcg, int nid)",
            "{",
            "\tunsigned long excess;",
            "\tstruct mem_cgroup_per_node *mz;",
            "\tstruct mem_cgroup_tree_per_node *mctz;",
            "",
            "\tif (lru_gen_enabled()) {",
            "\t\tif (soft_limit_excess(memcg))",
            "\t\t\tlru_gen_soft_reclaim(memcg, nid);",
            "\t\treturn;",
            "\t}",
            "",
            "\tmctz = soft_limit_tree.rb_tree_per_node[nid];",
            "\tif (!mctz)",
            "\t\treturn;",
            "\t/*",
            "\t * Necessary to update all ancestors when hierarchy is used.",
            "\t * because their event counter is not touched.",
            "\t */",
            "\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {",
            "\t\tmz = memcg->nodeinfo[nid];",
            "\t\texcess = soft_limit_excess(memcg);",
            "\t\t/*",
            "\t\t * We have to update the tree if mz is on RB-tree or",
            "\t\t * mem is over its softlimit.",
            "\t\t */",
            "\t\tif (excess || mz->on_tree) {",
            "\t\t\tunsigned long flags;",
            "",
            "\t\t\tspin_lock_irqsave(&mctz->lock, flags);",
            "\t\t\t/* if on-tree, remove it */",
            "\t\t\tif (mz->on_tree)",
            "\t\t\t\t__mem_cgroup_remove_exceeded(mz, mctz);",
            "\t\t\t/*",
            "\t\t\t * Insert again. mz->usage_in_excess will be updated.",
            "\t\t\t * If excess is 0, no tree ops.",
            "\t\t\t */",
            "\t\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);",
            "\t\t\tspin_unlock_irqrestore(&mctz->lock, flags);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "__mem_cgroup_insert_exceeded, __mem_cgroup_remove_exceeded, mem_cgroup_remove_exceeded, soft_limit_excess, memcg1_update_tree",
          "description": "实现RB树操作函数，用于将超出软限制的内存控制组节点插入或删除到RB树中，同时维护树的右极值指针，并通过遍历层级更新树结构以反映当前软限制状态。",
          "similarity": 0.5700795650482178
        },
        {
          "chunk_id": 2,
          "file_path": "mm/memcontrol-v1.c",
          "start_line": 222,
          "end_line": 364,
          "content": [
            "void memcg1_remove_from_trees(struct mem_cgroup *memcg)",
            "{",
            "\tstruct mem_cgroup_tree_per_node *mctz;",
            "\tstruct mem_cgroup_per_node *mz;",
            "\tint nid;",
            "",
            "\tfor_each_node(nid) {",
            "\t\tmz = memcg->nodeinfo[nid];",
            "\t\tmctz = soft_limit_tree.rb_tree_per_node[nid];",
            "\t\tif (mctz)",
            "\t\t\tmem_cgroup_remove_exceeded(mz, mctz);",
            "\t}",
            "}",
            "static int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,",
            "\t\t\t\t   pg_data_t *pgdat,",
            "\t\t\t\t   gfp_t gfp_mask,",
            "\t\t\t\t   unsigned long *total_scanned)",
            "{",
            "\tstruct mem_cgroup *victim = NULL;",
            "\tint total = 0;",
            "\tint loop = 0;",
            "\tunsigned long excess;",
            "\tunsigned long nr_scanned;",
            "\tstruct mem_cgroup_reclaim_cookie reclaim = {",
            "\t\t.pgdat = pgdat,",
            "\t};",
            "",
            "\texcess = soft_limit_excess(root_memcg);",
            "",
            "\twhile (1) {",
            "\t\tvictim = mem_cgroup_iter(root_memcg, victim, &reclaim);",
            "\t\tif (!victim) {",
            "\t\t\tloop++;",
            "\t\t\tif (loop >= 2) {",
            "\t\t\t\t/*",
            "\t\t\t\t * If we have not been able to reclaim",
            "\t\t\t\t * anything, it might because there are",
            "\t\t\t\t * no reclaimable pages under this hierarchy",
            "\t\t\t\t */",
            "\t\t\t\tif (!total)",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t/*",
            "\t\t\t\t * We want to do more targeted reclaim.",
            "\t\t\t\t * excess >> 2 is not to excessive so as to",
            "\t\t\t\t * reclaim too much, nor too less that we keep",
            "\t\t\t\t * coming back to reclaim from this cgroup",
            "\t\t\t\t */",
            "\t\t\t\tif (total >= (excess >> 2) ||",
            "\t\t\t\t\t(loop > MEM_CGROUP_MAX_RECLAIM_LOOPS))",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\ttotal += mem_cgroup_shrink_node(victim, gfp_mask, false,",
            "\t\t\t\t\tpgdat, &nr_scanned);",
            "\t\t*total_scanned += nr_scanned;",
            "\t\tif (!soft_limit_excess(root_memcg))",
            "\t\t\tbreak;",
            "\t}",
            "\tmem_cgroup_iter_break(root_memcg, victim);",
            "\treturn total;",
            "}",
            "unsigned long memcg1_soft_limit_reclaim(pg_data_t *pgdat, int order,",
            "\t\t\t\t\t    gfp_t gfp_mask,",
            "\t\t\t\t\t    unsigned long *total_scanned)",
            "{",
            "\tunsigned long nr_reclaimed = 0;",
            "\tstruct mem_cgroup_per_node *mz, *next_mz = NULL;",
            "\tunsigned long reclaimed;",
            "\tint loop = 0;",
            "\tstruct mem_cgroup_tree_per_node *mctz;",
            "\tunsigned long excess;",
            "",
            "\tif (lru_gen_enabled())",
            "\t\treturn 0;",
            "",
            "\tif (order > 0)",
            "\t\treturn 0;",
            "",
            "\tmctz = soft_limit_tree.rb_tree_per_node[pgdat->node_id];",
            "",
            "\t/*",
            "\t * Do not even bother to check the largest node if the root",
            "\t * is empty. Do it lockless to prevent lock bouncing. Races",
            "\t * are acceptable as soft limit is best effort anyway.",
            "\t */",
            "\tif (!mctz || RB_EMPTY_ROOT(&mctz->rb_root))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * This loop can run a while, specially if mem_cgroup's continuously",
            "\t * keep exceeding their soft limit and putting the system under",
            "\t * pressure",
            "\t */",
            "\tdo {",
            "\t\tif (next_mz)",
            "\t\t\tmz = next_mz;",
            "\t\telse",
            "\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);",
            "\t\tif (!mz)",
            "\t\t\tbreak;",
            "",
            "\t\treclaimed = mem_cgroup_soft_reclaim(mz->memcg, pgdat,",
            "\t\t\t\t\t\t    gfp_mask, total_scanned);",
            "\t\tnr_reclaimed += reclaimed;",
            "\t\tspin_lock_irq(&mctz->lock);",
            "",
            "\t\t/*",
            "\t\t * If we failed to reclaim anything from this memory cgroup",
            "\t\t * it is time to move on to the next cgroup",
            "\t\t */",
            "\t\tnext_mz = NULL;",
            "\t\tif (!reclaimed)",
            "\t\t\tnext_mz = __mem_cgroup_largest_soft_limit_node(mctz);",
            "",
            "\t\texcess = soft_limit_excess(mz->memcg);",
            "\t\t/*",
            "\t\t * One school of thought says that we should not add",
            "\t\t * back the node to the tree if reclaim returns 0.",
            "\t\t * But our reclaim could return 0, simply because due",
            "\t\t * to priority we are exposing a smaller subset of",
            "\t\t * memory to reclaim from. Consider this as a longer",
            "\t\t * term TODO.",
            "\t\t */",
            "\t\t/* If excess == 0, no tree ops */",
            "\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);",
            "\t\tspin_unlock_irq(&mctz->lock);",
            "\t\tcss_put(&mz->memcg->css);",
            "\t\tloop++;",
            "\t\t/*",
            "\t\t * Could not reclaim anything and there are no more",
            "\t\t * mem cgroups to try or we seem to be looping without",
            "\t\t * reclaiming anything.",
            "\t\t */",
            "\t\tif (!nr_reclaimed &&",
            "\t\t\t(next_mz == NULL ||",
            "\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))",
            "\t\t\tbreak;",
            "\t} while (!nr_reclaimed);",
            "\tif (next_mz)",
            "\t\tcss_put(&next_mz->memcg->css);",
            "\treturn nr_reclaimed;",
            "}"
          ],
          "function_name": "memcg1_remove_from_trees, mem_cgroup_soft_reclaim, memcg1_soft_limit_reclaim",
          "description": "提供内存回收逻辑，当内存控制组超过软限制时，通过迭代寻找目标cgroup执行内存回收操作，并通过循环控制防止无限回收，最终返回回收的页面数量。",
          "similarity": 0.5595515966415405
        }
      ]
    }
  ]
}