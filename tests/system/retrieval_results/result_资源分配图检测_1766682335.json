{
  "query": "资源分配图检测",
  "timestamp": "2025-12-26 01:05:35",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/matrix.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:03:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\matrix.c`\n\n---\n\n# `irq/matrix.c` 技术文档\n\n## 1. 文件概述\n\n`irq/matrix.c` 实现了一个通用的中断位图（IRQ matrix）管理机制，用于在多 CPU 系统中高效地分配和管理中断向量（或中断位）。该机制支持两类中断分配：\n\n- **普通分配（allocated）**：由设备驱动等动态申请的中断。\n- **托管分配（managed）**：由内核子系统（如 MSI/MSI-X）预先保留、按需激活的中断。\n\n该文件通过 per-CPU 的位图结构，结合全局状态跟踪，实现了跨 CPU 的中断资源分配、预留、释放和在线/离线管理，特别适用于中断向量数量有限（如 x86 的 256 个向量）的架构。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct cpumap`**：每个 CPU 的本地中断位图状态\n  - `available`：当前 CPU 可用的中断数量\n  - `allocated`：已分配的普通中断数量\n  - `managed` / `managed_allocated`：预留和已激活的托管中断数量\n  - `alloc_map[]`：记录已分配的普通中断位\n  - `managed_map[]`：记录预留的托管中断位\n  - `initialized` / `online`：CPU 初始化和在线状态\n\n- **`struct irq_matrix`**：全局中断矩阵控制结构\n  - `matrix_bits`：总位图大小（≤ `IRQ_MATRIX_BITS`）\n  - `alloc_start` / `alloc_end`：可分配范围\n  - `global_available`：全局可用中断总数\n  - `system_map[]`：系统保留位（如 APIC 自身使用的向量）\n  - `maps`：指向 per-CPU `cpumap` 的指针\n  - `scratch_map[]`：临时位图，用于分配时的合并计算\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `irq_alloc_matrix()` | 分配并初始化一个 `irq_matrix` 结构 |\n| `irq_matrix_online()` / `irq_matrix_offline()` | 将本地 CPU 的中断矩阵置为在线/离线状态 |\n| `irq_matrix_assign_system()` | 在矩阵中保留系统级中断位（如 APIC 向量） |\n| `irq_matrix_reserve_managed()` | 在指定 CPU 掩码上为托管中断预留位 |\n| `irq_matrix_remove_managed()` | 移除托管中断的预留位 |\n| `irq_matrix_alloc_managed()` | 从预留的托管中断中分配一个实际使用的中断 |\n| `matrix_alloc_area()` | 内部辅助函数：在合并位图中查找连续空闲区域 |\n| `matrix_find_best_cpu()` / `matrix_find_best_cpu_managed()` | 选择最优 CPU（基于可用数或托管分配数最少） |\n\n## 3. 关键实现\n\n### 位图合并分配策略\n- 在分配中断时，`matrix_alloc_area()` 会临时合并三个位图：\n  1. 当前 CPU 的 `managed_map`（托管预留）\n  2. 全局 `system_map`（系统保留）\n  3. 当前 CPU 的 `alloc_map`（已分配）\n- 使用 `bitmap_find_next_zero_area()` 在合并后的位图中查找连续空闲区域，确保不会重复分配。\n\n### 托管中断（Managed IRQ）机制\n- **两阶段分配**：\n  1. **预留（reserve）**：调用 `irq_matrix_reserve_managed()` 在多个 CPU 上各预留一个位（不一定对齐）。\n  2. **激活（alloc）**：调用 `irq_matrix_alloc_managed()` 从预留位中选择一个未使用的位进行实际分配。\n- **动态 CPU 选择**：`matrix_find_best_cpu_managed()` 优先选择 `managed_allocated` 最少的 CPU，实现负载均衡。\n\n### 系统中断保留\n- `irq_matrix_assign_system()` 用于保留如 x86 的 `IRQ0_VECTOR`（时钟中断）等关键系统向量。\n- 通过 `BUG_ON()` 强制保证：系统中断只能在单 CPU 初始化阶段分配，防止运行时冲突。\n\n### 在线/离线管理\n- CPU 上线时，将其 `available` 计数加入 `global_available`。\n- CPU 离线时，从全局计数中减去，但保留其位图数据（支持重新上线）。\n\n### 跟踪与调试\n- 集成 `trace/events/irq_matrix.h`，提供分配、预留、系统保留等关键操作的 tracepoint，便于调试中断分配问题。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/bitmap.h>`：位图操作（`bitmap_set`, `bitmap_find_next_zero_area` 等）\n  - `<linux/percpu.h>`：Per-CPU 变量支持\n  - `<linux/cpu.h>`：CPU 在线/离线状态\n  - `<linux/irq.h>`：中断子系统基础定义\n  - `<trace/events/irq_matrix.h>`：自定义 tracepoint\n\n- **内核子系统**：\n  - **中断子系统**：作为底层分配器，被 `irqdomain`、MSI/MSI-X 驱动等使用。\n  - **x86 APIC 驱动**：典型使用者，用于管理 256 个中断向量的分配（如 `kernel/irq/vector.c`）。\n\n## 5. 使用场景\n\n- **x86 中断向量管理**：在 `CONFIG_X86_IO_APIC` 或 `CONFIG_X86_LOCAL_APIC` 下，用于分配 IRQ 向量（0-255），区分系统向量、普通设备中断和 MSI 中断。\n- **MSI/MSI-X 中断分配**：PCIe 设备的 MSI 中断通过托管机制预留和分配，确保每个设备在多个 CPU 上有可用向量。\n- **CPU 热插拔**：支持 CPU 动态上线/下线时的中断资源重新平衡。\n- **中断负载均衡**：通过 `matrix_find_best_cpu*` 函数，在多 CPU 间均匀分配中断，避免单 CPU 向量耗尽。",
      "similarity": 0.5975828766822815,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 418,
          "end_line": 483,
          "content": [
            "void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,",
            "\t\t     unsigned int bit, bool managed)",
            "{",
            "\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))",
            "\t\treturn;",
            "",
            "\tif (WARN_ON_ONCE(!test_and_clear_bit(bit, cm->alloc_map)))",
            "\t\treturn;",
            "",
            "\tcm->allocated--;",
            "\tif(managed)",
            "\t\tcm->managed_allocated--;",
            "",
            "\tif (cm->online)",
            "\t\tm->total_allocated--;",
            "",
            "\tif (!managed) {",
            "\t\tcm->available++;",
            "\t\tif (cm->online)",
            "\t\t\tm->global_available++;",
            "\t}",
            "\ttrace_irq_matrix_free(bit, cpu, m, cm);",
            "}",
            "unsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tif (!cpudown)",
            "\t\treturn m->global_available;",
            "\treturn m->global_available - cm->available;",
            "}",
            "unsigned int irq_matrix_reserved(struct irq_matrix *m)",
            "{",
            "\treturn m->global_reserved;",
            "}",
            "unsigned int irq_matrix_allocated(struct irq_matrix *m)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\treturn cm->allocated - cm->managed_allocated;",
            "}",
            "void irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind)",
            "{",
            "\tunsigned int nsys = bitmap_weight(m->system_map, m->matrix_bits);",
            "\tint cpu;",
            "",
            "\tseq_printf(sf, \"Online bitmaps:   %6u\\n\", m->online_maps);",
            "\tseq_printf(sf, \"Global available: %6u\\n\", m->global_available);",
            "\tseq_printf(sf, \"Global reserved:  %6u\\n\", m->global_reserved);",
            "\tseq_printf(sf, \"Total allocated:  %6u\\n\", m->total_allocated);",
            "\tseq_printf(sf, \"System: %u: %*pbl\\n\", nsys, m->matrix_bits,",
            "\t\t   m->system_map);",
            "\tseq_printf(sf, \"%*s| CPU | avl | man | mac | act | vectors\\n\", ind, \" \");",
            "\tcpus_read_lock();",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\t\tseq_printf(sf, \"%*s %4d  %4u  %4u  %4u %4u  %*pbl\\n\", ind, \" \",",
            "\t\t\t   cpu, cm->available, cm->managed,",
            "\t\t\t   cm->managed_allocated, cm->allocated,",
            "\t\t\t   m->matrix_bits, cm->alloc_map);",
            "\t}",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "irq_matrix_free, irq_matrix_available, irq_matrix_reserved, irq_matrix_allocated, irq_matrix_debug_show",
          "description": "提供中断资源的释放接口，实现全局和CPU级的资源使用统计查询，包含调试信息展示功能，通过位图操作维护系统中断位的使用状态",
          "similarity": 0.6149075627326965
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 251,
          "end_line": 365,
          "content": [
            "void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)",
            "{",
            "\tunsigned int cpu;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "\t\tunsigned int bit, end = m->alloc_end;",
            "",
            "\t\tif (WARN_ON_ONCE(!cm->managed))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Get managed bit which are not allocated */",
            "\t\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);",
            "",
            "\t\tbit = find_first_bit(m->scratch_map, end);",
            "\t\tif (WARN_ON_ONCE(bit >= end))",
            "\t\t\tcontinue;",
            "",
            "\t\tclear_bit(bit, cm->managed_map);",
            "",
            "\t\tcm->managed--;",
            "\t\tif (cm->online) {",
            "\t\t\tcm->available++;",
            "\t\t\tm->global_available++;",
            "\t\t}",
            "\t\ttrace_irq_matrix_remove_managed(bit, cpu, m, cm);",
            "\t}",
            "}",
            "int irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,",
            "\t\t\t     unsigned int *mapped_cpu)",
            "{",
            "\tunsigned int bit, cpu, end;",
            "\tstruct cpumap *cm;",
            "",
            "\tif (cpumask_empty(msk))",
            "\t\treturn -EINVAL;",
            "",
            "\tcpu = matrix_find_best_cpu_managed(m, msk);",
            "\tif (cpu == UINT_MAX)",
            "\t\treturn -ENOSPC;",
            "",
            "\tcm = per_cpu_ptr(m->maps, cpu);",
            "\tend = m->alloc_end;",
            "\t/* Get managed bit which are not allocated */",
            "\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);",
            "\tbit = find_first_bit(m->scratch_map, end);",
            "\tif (bit >= end)",
            "\t\treturn -ENOSPC;",
            "\tset_bit(bit, cm->alloc_map);",
            "\tcm->allocated++;",
            "\tcm->managed_allocated++;",
            "\tm->total_allocated++;",
            "\t*mapped_cpu = cpu;",
            "\ttrace_irq_matrix_alloc_managed(bit, cpu, m, cm);",
            "\treturn bit;",
            "}",
            "void irq_matrix_assign(struct irq_matrix *m, unsigned int bit)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))",
            "\t\treturn;",
            "\tif (WARN_ON_ONCE(test_and_set_bit(bit, cm->alloc_map)))",
            "\t\treturn;",
            "\tcm->allocated++;",
            "\tm->total_allocated++;",
            "\tcm->available--;",
            "\tm->global_available--;",
            "\ttrace_irq_matrix_assign(bit, smp_processor_id(), m, cm);",
            "}",
            "void irq_matrix_reserve(struct irq_matrix *m)",
            "{",
            "\tif (m->global_reserved == m->global_available)",
            "\t\tpr_warn(\"Interrupt reservation exceeds available resources\\n\");",
            "",
            "\tm->global_reserved++;",
            "\ttrace_irq_matrix_reserve(m);",
            "}",
            "void irq_matrix_remove_reserved(struct irq_matrix *m)",
            "{",
            "\tm->global_reserved--;",
            "\ttrace_irq_matrix_remove_reserved(m);",
            "}",
            "int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,",
            "\t\t     bool reserved, unsigned int *mapped_cpu)",
            "{",
            "\tunsigned int cpu, bit;",
            "\tstruct cpumap *cm;",
            "",
            "\t/*",
            "\t * Not required in theory, but matrix_find_best_cpu() uses",
            "\t * for_each_cpu() which ignores the cpumask on UP .",
            "\t */",
            "\tif (cpumask_empty(msk))",
            "\t\treturn -EINVAL;",
            "",
            "\tcpu = matrix_find_best_cpu(m, msk);",
            "\tif (cpu == UINT_MAX)",
            "\t\treturn -ENOSPC;",
            "",
            "\tcm = per_cpu_ptr(m->maps, cpu);",
            "\tbit = matrix_alloc_area(m, cm, 1, false);",
            "\tif (bit >= m->alloc_end)",
            "\t\treturn -ENOSPC;",
            "\tcm->allocated++;",
            "\tcm->available--;",
            "\tm->total_allocated++;",
            "\tm->global_available--;",
            "\tif (reserved)",
            "\t\tm->global_reserved--;",
            "\t*mapped_cpu = cpu;",
            "\ttrace_irq_matrix_alloc(bit, cpu, m, cm);",
            "\treturn bit;",
            "",
            "}"
          ],
          "function_name": "irq_matrix_remove_managed, irq_matrix_alloc_managed, irq_matrix_assign, irq_matrix_reserve, irq_matrix_remove_reserved, irq_matrix_alloc",
          "description": "实现中断位的分配/回收机制，包含保留中断位的管理、跨CPU的中断分配逻辑，以及根据预留状态进行资源分配的控制流程",
          "similarity": 0.5772511959075928
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 78,
          "end_line": 205,
          "content": [
            "void irq_matrix_online(struct irq_matrix *m)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tBUG_ON(cm->online);",
            "",
            "\tif (!cm->initialized) {",
            "\t\tcm->available = m->alloc_size;",
            "\t\tcm->available -= cm->managed + m->systembits_inalloc;",
            "\t\tcm->initialized = true;",
            "\t}",
            "\tm->global_available += cm->available;",
            "\tcm->online = true;",
            "\tm->online_maps++;",
            "\ttrace_irq_matrix_online(m);",
            "}",
            "void irq_matrix_offline(struct irq_matrix *m)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\t/* Update the global available size */",
            "\tm->global_available -= cm->available;",
            "\tcm->online = false;",
            "\tm->online_maps--;",
            "\ttrace_irq_matrix_offline(m);",
            "}",
            "static unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,",
            "\t\t\t\t      unsigned int num, bool managed)",
            "{",
            "\tunsigned int area, start = m->alloc_start;",
            "\tunsigned int end = m->alloc_end;",
            "",
            "\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);",
            "\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);",
            "\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);",
            "\tif (area >= end)",
            "\t\treturn area;",
            "\tif (managed)",
            "\t\tbitmap_set(cm->managed_map, area, num);",
            "\telse",
            "\t\tbitmap_set(cm->alloc_map, area, num);",
            "\treturn area;",
            "}",
            "static unsigned int matrix_find_best_cpu(struct irq_matrix *m,",
            "\t\t\t\t\tconst struct cpumask *msk)",
            "{",
            "\tunsigned int cpu, best_cpu, maxavl = 0;",
            "\tstruct cpumap *cm;",
            "",
            "\tbest_cpu = UINT_MAX;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tcm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\t\tif (!cm->online || cm->available <= maxavl)",
            "\t\t\tcontinue;",
            "",
            "\t\tbest_cpu = cpu;",
            "\t\tmaxavl = cm->available;",
            "\t}",
            "\treturn best_cpu;",
            "}",
            "static unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,",
            "\t\t\t\t\t\tconst struct cpumask *msk)",
            "{",
            "\tunsigned int cpu, best_cpu, allocated = UINT_MAX;",
            "\tstruct cpumap *cm;",
            "",
            "\tbest_cpu = UINT_MAX;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tcm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\t\tif (!cm->online || cm->managed_allocated > allocated)",
            "\t\t\tcontinue;",
            "",
            "\t\tbest_cpu = cpu;",
            "\t\tallocated = cm->managed_allocated;",
            "\t}",
            "\treturn best_cpu;",
            "}",
            "void irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit,",
            "\t\t\t      bool replace)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tBUG_ON(bit > m->matrix_bits);",
            "\tBUG_ON(m->online_maps > 1 || (m->online_maps && !replace));",
            "",
            "\tset_bit(bit, m->system_map);",
            "\tif (replace) {",
            "\t\tBUG_ON(!test_and_clear_bit(bit, cm->alloc_map));",
            "\t\tcm->allocated--;",
            "\t\tm->total_allocated--;",
            "\t}",
            "\tif (bit >= m->alloc_start && bit < m->alloc_end)",
            "\t\tm->systembits_inalloc++;",
            "",
            "\ttrace_irq_matrix_assign_system(bit, m);",
            "}",
            "int irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk)",
            "{",
            "\tunsigned int cpu, failed_cpu;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "\t\tunsigned int bit;",
            "",
            "\t\tbit = matrix_alloc_area(m, cm, 1, true);",
            "\t\tif (bit >= m->alloc_end)",
            "\t\t\tgoto cleanup;",
            "\t\tcm->managed++;",
            "\t\tif (cm->online) {",
            "\t\t\tcm->available--;",
            "\t\t\tm->global_available--;",
            "\t\t}",
            "\t\ttrace_irq_matrix_reserve_managed(bit, cpu, m, cm);",
            "\t}",
            "\treturn 0;",
            "cleanup:",
            "\tfailed_cpu = cpu;",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tif (cpu == failed_cpu)",
            "\t\t\tbreak;",
            "\t\tirq_matrix_remove_managed(m, cpumask_of(cpu));",
            "\t}",
            "\treturn -ENOSPC;",
            "}"
          ],
          "function_name": "irq_matrix_online, irq_matrix_offline, matrix_alloc_area, matrix_find_best_cpu, matrix_find_best_cpu_managed, irq_matrix_assign_system, irq_matrix_reserve_managed",
          "description": "实现CPU矩阵的上线/下线操作，通过bitmap操作实现中断位的分配策略，包含寻找最佳CPU的逻辑，支持系统位管理和保留区域的分配与追踪",
          "similarity": 0.5768276453018188
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 1,
          "end_line": 77,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2017 Thomas Gleixner <tglx@linutronix.de>",
            "",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpu.h>",
            "#include <linux/irq.h>",
            "",
            "#define IRQ_MATRIX_SIZE\t(BITS_TO_LONGS(IRQ_MATRIX_BITS))",
            "",
            "struct cpumap {",
            "\tunsigned int\t\tavailable;",
            "\tunsigned int\t\tallocated;",
            "\tunsigned int\t\tmanaged;",
            "\tunsigned int\t\tmanaged_allocated;",
            "\tbool\t\t\tinitialized;",
            "\tbool\t\t\tonline;",
            "\tunsigned long\t\talloc_map[IRQ_MATRIX_SIZE];",
            "\tunsigned long\t\tmanaged_map[IRQ_MATRIX_SIZE];",
            "};",
            "",
            "struct irq_matrix {",
            "\tunsigned int\t\tmatrix_bits;",
            "\tunsigned int\t\talloc_start;",
            "\tunsigned int\t\talloc_end;",
            "\tunsigned int\t\talloc_size;",
            "\tunsigned int\t\tglobal_available;",
            "\tunsigned int\t\tglobal_reserved;",
            "\tunsigned int\t\tsystembits_inalloc;",
            "\tunsigned int\t\ttotal_allocated;",
            "\tunsigned int\t\tonline_maps;",
            "\tstruct cpumap __percpu\t*maps;",
            "\tunsigned long\t\tscratch_map[IRQ_MATRIX_SIZE];",
            "\tunsigned long\t\tsystem_map[IRQ_MATRIX_SIZE];",
            "};",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/irq_matrix.h>",
            "",
            "/**",
            " * irq_alloc_matrix - Allocate a irq_matrix structure and initialize it",
            " * @matrix_bits:\tNumber of matrix bits must be <= IRQ_MATRIX_BITS",
            " * @alloc_start:\tFrom which bit the allocation search starts",
            " * @alloc_end:\t\tAt which bit the allocation search ends, i.e first",
            " *\t\t\tinvalid bit",
            " */",
            "__init struct irq_matrix *irq_alloc_matrix(unsigned int matrix_bits,",
            "\t\t\t\t\t   unsigned int alloc_start,",
            "\t\t\t\t\t   unsigned int alloc_end)",
            "{",
            "\tstruct irq_matrix *m;",
            "",
            "\tif (matrix_bits > IRQ_MATRIX_BITS)",
            "\t\treturn NULL;",
            "",
            "\tm = kzalloc(sizeof(*m), GFP_KERNEL);",
            "\tif (!m)",
            "\t\treturn NULL;",
            "",
            "\tm->matrix_bits = matrix_bits;",
            "\tm->alloc_start = alloc_start;",
            "\tm->alloc_end = alloc_end;",
            "\tm->alloc_size = alloc_end - alloc_start;",
            "\tm->maps = alloc_percpu(*m->maps);",
            "\tif (!m->maps) {",
            "\t\tkfree(m);",
            "\t\treturn NULL;",
            "\t}",
            "\treturn m;",
            "}",
            "",
            "/**",
            " * irq_matrix_online - Bring the local CPU matrix online",
            " * @m:\t\tMatrix pointer",
            " */"
          ],
          "function_name": null,
          "description": "定义irq_matrix结构体和相关辅助数据结构，提供irq_alloc_matrix函数用于初始化并分配irq_matrix实例，设置矩阵大小、起始结束位置等参数，并分配per-CPU的cpumap数组",
          "similarity": 0.45705264806747437
        }
      ]
    },
    {
      "source_file": "mm/percpu-stats.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:09:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `percpu-stats.c`\n\n---\n\n# percpu-stats.c 技术文档\n\n## 1. 文件概述\n\n`percpu-stats.c` 是 Linux 内核中用于收集和展示 per-CPU（每 CPU）内存分配器运行时统计信息的调试模块。该文件通过 debugfs 接口 `/sys/kernel/debug/percpu_stats` 向用户空间暴露详细的 per-CPU 内存分配状态，包括全局统计、分配参数以及每个内存块（chunk）的碎片、分配大小分布等信息，主要用于性能分析和内存调试。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct percpu_stats pcpu_stats`：全局 per-CPU 分配器统计信息，记录分配/释放次数、当前/最大分配数、最小/最大分配大小等。\n- `struct pcpu_alloc_info pcpu_stats_ai`：per-CPU 内存布局配置信息，如单元大小、静态区大小、动态区大小等。\n- `int *buffer`：临时缓冲区，用于在 `chunk_map_stats()` 中存储每个 chunk 的分配/空闲片段大小。\n\n### 主要函数\n- `find_max_nr_alloc(void)`：遍历所有 per-CPU 内存块（chunks），找出具有最多分配项（`nr_alloc`）的块，用于预分配临时缓冲区。\n- `chunk_map_stats(struct seq_file *m, struct pcpu_chunk *chunk, int *buffer)`：分析并打印单个 chunk 的详细状态，包括碎片情况、分配大小分布（最小、中位数、最大）等。\n- `percpu_stats_show(struct seq_file *m, void *v)`：debugfs 文件的读取回调函数，汇总并输出全局统计、分配配置及所有 chunk 的详细信息。\n- `init_percpu_stats_debugfs(void)`：模块初始化函数，在 debugfs 中创建 `percpu_stats` 文件。\n\n## 3. 关键实现\n\n### Chunk 状态分析算法\n`chunk_map_stats()` 函数通过遍历 `alloc_map` 和 `bound_map` 位图来重建 chunk 的内存布局：\n- `alloc_map` 标记已分配的最小单位（`PCPU_MIN_ALLOC_SIZE`）；\n- `bound_map` 标记每个分配区域的结束边界；\n- 通过交替查找 `alloc_map` 和 `bound_map` 中的下一个置位位，将连续区域划分为“已分配”或“空闲”片段；\n- 已分配片段记录为正数，空闲片段记录为负数，并统一转换为字节数；\n- 对片段数组排序后，负值（空闲）在前且按绝对值降序排列，便于计算总碎片（`sum_frag`）和最大连续空闲块（`max_frag`）；\n- 从第一个非负值开始，提取当前最小、中位数和最大分配大小。\n\n### 并发安全与重试机制\n由于 per-CPU 分配器状态可能在缓冲区分配前后发生变化，`percpu_stats_show()` 采用以下策略确保一致性：\n1. 先在 `pcpu_lock` 保护下获取当前最大 `nr_alloc`；\n2. 按此值分配足够大的临时缓冲区；\n3. 再次加锁检查 `nr_alloc` 是否增长，若增长则释放缓冲区并重试；\n4. 整个统计过程在 `pcpu_lock` 临界区内完成，避免并发修改导致的数据不一致。\n\n### 输出格式\n使用宏 `P(X, Y)`、`PL(X)`、`PU(X)` 统一格式化输出，字段对齐，数值右对齐，便于阅读和脚本解析。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/debugfs.h>`：提供 debugfs 文件系统接口；\n  - `<linux/percpu.h>` 和 `\"percpu-internal.h\"`：访问 per-CPU 分配器内部数据结构（如 `pcpu_chunk`、`pcpu_chunk_lists`、`pcpu_lock` 等）；\n  - `<linux/seq_file.h>`：支持顺序文件输出；\n  - `<linux/sort.h>`：用于对分配/空闲片段数组排序；\n  - `<linux/vmalloc.h>`：使用 `vmalloc_array()` 分配大块临时内存。\n\n- **内核子系统**：\n  - 依赖 per-CPU 内存管理子系统（`mm/percpu.c`）提供的全局变量和内部结构；\n  - 通过 `late_initcall` 在内核初始化后期注册 debugfs 接口。\n\n## 5. 使用场景\n\n- **内核开发者调试**：当怀疑 per-CPU 内存分配存在碎片化、性能下降或内存泄漏时，可通过读取 `/sys/kernel/debug/percpu_stats` 获取详细分配状态。\n- **系统性能分析**：运维人员或性能工程师可监控 `nr_cur_alloc`、`free_bytes`、`sum_frag` 等指标，评估 per-CPU 内存使用效率。\n- **内存优化参考**：通过观察 `cur_min_alloc`、`cur_med_alloc`、`cur_max_alloc` 等分配大小分布，指导内核模块调整 per-CPU 变量的大小或对齐方式。\n- **验证内存布局**：检查 `unit_size`、`static_size`、`dyn_size` 等配置是否符合预期，特别是在自定义内核配置或架构移植时。",
      "similarity": 0.5761629939079285,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/percpu-stats.c",
          "start_line": 25,
          "end_line": 212,
          "content": [
            "static int cmpint(const void *a, const void *b)",
            "{",
            "\treturn *(int *)a - *(int *)b;",
            "}",
            "static int find_max_nr_alloc(void)",
            "{",
            "\tstruct pcpu_chunk *chunk;",
            "\tint slot, max_nr_alloc;",
            "",
            "\tmax_nr_alloc = 0;",
            "\tfor (slot = 0; slot < pcpu_nr_slots; slot++)",
            "\t\tlist_for_each_entry(chunk, &pcpu_chunk_lists[slot], list)",
            "\t\t\tmax_nr_alloc = max(max_nr_alloc, chunk->nr_alloc);",
            "",
            "\treturn max_nr_alloc;",
            "}",
            "static void chunk_map_stats(struct seq_file *m, struct pcpu_chunk *chunk,",
            "\t\t\t    int *buffer)",
            "{",
            "\tstruct pcpu_block_md *chunk_md = &chunk->chunk_md;",
            "\tint i, last_alloc, as_len, start, end;",
            "\tint *alloc_sizes, *p;",
            "\t/* statistics */",
            "\tint sum_frag = 0, max_frag = 0;",
            "\tint cur_min_alloc = 0, cur_med_alloc = 0, cur_max_alloc = 0;",
            "",
            "\talloc_sizes = buffer;",
            "",
            "\t/*",
            "\t * find_last_bit returns the start value if nothing found.",
            "\t * Therefore, we must determine if it is a failure of find_last_bit",
            "\t * and set the appropriate value.",
            "\t */",
            "\tlast_alloc = find_last_bit(chunk->alloc_map,",
            "\t\t\t\t   pcpu_chunk_map_bits(chunk) -",
            "\t\t\t\t   chunk->end_offset / PCPU_MIN_ALLOC_SIZE - 1);",
            "\tlast_alloc = test_bit(last_alloc, chunk->alloc_map) ?",
            "\t\t     last_alloc + 1 : 0;",
            "",
            "\tas_len = 0;",
            "\tstart = chunk->start_offset / PCPU_MIN_ALLOC_SIZE;",
            "",
            "\t/*",
            "\t * If a bit is set in the allocation map, the bound_map identifies",
            "\t * where the allocation ends.  If the allocation is not set, the",
            "\t * bound_map does not identify free areas as it is only kept accurate",
            "\t * on allocation, not free.",
            "\t *",
            "\t * Positive values are allocations and negative values are free",
            "\t * fragments.",
            "\t */",
            "\twhile (start < last_alloc) {",
            "\t\tif (test_bit(start, chunk->alloc_map)) {",
            "\t\t\tend = find_next_bit(chunk->bound_map, last_alloc,",
            "\t\t\t\t\t    start + 1);",
            "\t\t\talloc_sizes[as_len] = 1;",
            "\t\t} else {",
            "\t\t\tend = find_next_bit(chunk->alloc_map, last_alloc,",
            "\t\t\t\t\t    start + 1);",
            "\t\t\talloc_sizes[as_len] = -1;",
            "\t\t}",
            "",
            "\t\talloc_sizes[as_len++] *= (end - start) * PCPU_MIN_ALLOC_SIZE;",
            "",
            "\t\tstart = end;",
            "\t}",
            "",
            "\t/*",
            "\t * The negative values are free fragments and thus sorting gives the",
            "\t * free fragments at the beginning in largest first order.",
            "\t */",
            "\tif (as_len > 0) {",
            "\t\tsort(alloc_sizes, as_len, sizeof(int), cmpint, NULL);",
            "",
            "\t\t/* iterate through the unallocated fragments */",
            "\t\tfor (i = 0, p = alloc_sizes; *p < 0 && i < as_len; i++, p++) {",
            "\t\t\tsum_frag -= *p;",
            "\t\t\tmax_frag = max(max_frag, -1 * (*p));",
            "\t\t}",
            "",
            "\t\tcur_min_alloc = alloc_sizes[i];",
            "\t\tcur_med_alloc = alloc_sizes[(i + as_len - 1) / 2];",
            "\t\tcur_max_alloc = alloc_sizes[as_len - 1];",
            "\t}",
            "",
            "\tP(\"nr_alloc\", chunk->nr_alloc);",
            "\tP(\"max_alloc_size\", chunk->max_alloc_size);",
            "\tP(\"empty_pop_pages\", chunk->nr_empty_pop_pages);",
            "\tP(\"first_bit\", chunk_md->first_free);",
            "\tP(\"free_bytes\", chunk->free_bytes);",
            "\tP(\"contig_bytes\", chunk_md->contig_hint * PCPU_MIN_ALLOC_SIZE);",
            "\tP(\"sum_frag\", sum_frag);",
            "\tP(\"max_frag\", max_frag);",
            "\tP(\"cur_min_alloc\", cur_min_alloc);",
            "\tP(\"cur_med_alloc\", cur_med_alloc);",
            "\tP(\"cur_max_alloc\", cur_max_alloc);",
            "\tseq_putc(m, '\\n');",
            "}",
            "static int percpu_stats_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct pcpu_chunk *chunk;",
            "\tint slot, max_nr_alloc;",
            "\tint *buffer;",
            "",
            "alloc_buffer:",
            "\tspin_lock_irq(&pcpu_lock);",
            "\tmax_nr_alloc = find_max_nr_alloc();",
            "\tspin_unlock_irq(&pcpu_lock);",
            "",
            "\t/* there can be at most this many free and allocated fragments */",
            "\tbuffer = vmalloc_array(2 * max_nr_alloc + 1, sizeof(int));",
            "\tif (!buffer)",
            "\t\treturn -ENOMEM;",
            "",
            "\tspin_lock_irq(&pcpu_lock);",
            "",
            "\t/* if the buffer allocated earlier is too small */",
            "\tif (max_nr_alloc < find_max_nr_alloc()) {",
            "\t\tspin_unlock_irq(&pcpu_lock);",
            "\t\tvfree(buffer);",
            "\t\tgoto alloc_buffer;",
            "\t}",
            "",
            "#define PL(X)\t\t\t\t\t\t\t\t\\",
            "\tseq_printf(m, \"  %-20s: %12lld\\n\", #X, (long long int)pcpu_stats_ai.X)",
            "",
            "\tseq_printf(m,",
            "\t\t\t\"Percpu Memory Statistics\\n\"",
            "\t\t\t\"Allocation Info:\\n\"",
            "\t\t\t\"----------------------------------------\\n\");",
            "\tPL(unit_size);",
            "\tPL(static_size);",
            "\tPL(reserved_size);",
            "\tPL(dyn_size);",
            "\tPL(atom_size);",
            "\tPL(alloc_size);",
            "\tseq_putc(m, '\\n');",
            "",
            "#undef PL",
            "",
            "#define PU(X) \\",
            "\tseq_printf(m, \"  %-20s: %12llu\\n\", #X, (unsigned long long)pcpu_stats.X)",
            "",
            "\tseq_printf(m,",
            "\t\t\t\"Global Stats:\\n\"",
            "\t\t\t\"----------------------------------------\\n\");",
            "\tPU(nr_alloc);",
            "\tPU(nr_dealloc);",
            "\tPU(nr_cur_alloc);",
            "\tPU(nr_max_alloc);",
            "\tPU(nr_chunks);",
            "\tPU(nr_max_chunks);",
            "\tPU(min_alloc_size);",
            "\tPU(max_alloc_size);",
            "\tP(\"empty_pop_pages\", pcpu_nr_empty_pop_pages);",
            "\tseq_putc(m, '\\n');",
            "",
            "#undef PU",
            "",
            "\tseq_printf(m,",
            "\t\t\t\"Per Chunk Stats:\\n\"",
            "\t\t\t\"----------------------------------------\\n\");",
            "",
            "\tif (pcpu_reserved_chunk) {",
            "\t\tseq_puts(m, \"Chunk: <- Reserved Chunk\\n\");",
            "\t\tchunk_map_stats(m, pcpu_reserved_chunk, buffer);",
            "\t}",
            "",
            "\tfor (slot = 0; slot < pcpu_nr_slots; slot++) {",
            "\t\tlist_for_each_entry(chunk, &pcpu_chunk_lists[slot], list) {",
            "\t\t\tif (chunk == pcpu_first_chunk)",
            "\t\t\t\tseq_puts(m, \"Chunk: <- First Chunk\\n\");",
            "\t\t\telse if (slot == pcpu_to_depopulate_slot)",
            "\t\t\t\tseq_puts(m, \"Chunk (to_depopulate)\\n\");",
            "\t\t\telse if (slot == pcpu_sidelined_slot)",
            "\t\t\t\tseq_puts(m, \"Chunk (sidelined):\\n\");",
            "\t\t\telse",
            "\t\t\t\tseq_puts(m, \"Chunk:\\n\");",
            "\t\t\tchunk_map_stats(m, chunk, buffer);",
            "\t\t}",
            "\t}",
            "",
            "\tspin_unlock_irq(&pcpu_lock);",
            "",
            "\tvfree(buffer);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "cmpint, find_max_nr_alloc, chunk_map_stats, percpu_stats_show",
          "description": "实现percpu内存分配统计的核心逻辑，包含比较函数、最大分配计算、块级统计分析及总体统计展示函数，通过遍历所有内存块生成详细的分配状态报告。",
          "similarity": 0.5963219404220581
        },
        {
          "chunk_id": 2,
          "file_path": "mm/percpu-stats.c",
          "start_line": 227,
          "end_line": 233,
          "content": [
            "static int __init init_percpu_stats_debugfs(void)",
            "{",
            "\tdebugfs_create_file(\"percpu_stats\", 0444, NULL, NULL,",
            "\t\t\t&percpu_stats_fops);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "init_percpu_stats_debugfs",
          "description": "注册debugfs文件系统接口，创建名为percpu_stats的调试文件节点，用于暴露percpu内存分配的统计信息给用户空间工具。",
          "similarity": 0.5576488971710205
        },
        {
          "chunk_id": 0,
          "file_path": "mm/percpu-stats.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * mm/percpu-debug.c",
            " *",
            " * Copyright (C) 2017\t\tFacebook Inc.",
            " * Copyright (C) 2017\t\tDennis Zhou <dennis@kernel.org>",
            " *",
            " * Prints statistics about the percpu allocator and backing chunks.",
            " */",
            "#include <linux/debugfs.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sort.h>",
            "#include <linux/vmalloc.h>",
            "",
            "#include \"percpu-internal.h\"",
            "",
            "#define P(X, Y) \\",
            "\tseq_printf(m, \"  %-20s: %12lld\\n\", X, (long long int)Y)",
            "",
            "struct percpu_stats pcpu_stats;",
            "struct pcpu_alloc_info pcpu_stats_ai;",
            ""
          ],
          "function_name": null,
          "description": "定义用于存储percpu分配器统计信息的全局结构体pcpu_stats和pcpu_stats_ai，为后续统计信息收集和调试输出提供数据容器。",
          "similarity": 0.4852215051651001
        }
      ]
    },
    {
      "source_file": "kernel/resource.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:53:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `resource.c`\n\n---\n\n# resource.c 技术文档\n\n## 1. 文件概述\n\n`resource.c` 是 Linux 内核中用于管理和分配系统资源（如 I/O 端口和内存区域）的核心实现文件。它提供了一套通用的资源树管理机制，支持资源的申请、释放、查找和冲突检测。该文件维护了两个全局根资源节点：`ioport_resource`（用于 I/O 端口空间）和 `iomem_resource`（用于内存映射 I/O 空间），并通过树形结构组织所有已分配的子资源，确保资源分配的唯一性和安全性。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `struct resource ioport_resource`：I/O 端口资源的根节点，范围为 `[0, IO_SPACE_LIMIT]`，标志为 `IORESOURCE_IO`。\n- `struct resource iomem_resource`：内存映射 I/O 资源的根节点，范围为 `[0, -1]`（即全地址空间），标志为 `IORESOURCE_MEM`。\n- `struct resource_constraint`：用于描述资源分配时的约束条件（最小/最大地址、对齐要求及自定义对齐函数）。\n\n### 关键函数\n- `request_resource(struct resource *root, struct resource *new)`：尝试在指定根资源下申请一段新资源，成功返回 0，冲突返回 `-EBUSY`。\n- `request_resource_conflict(...)`：与 `request_resource` 类似，但冲突时直接返回冲突的资源指针。\n- `release_resource(struct resource *old)`：释放已分配的资源。\n- `release_child_resources(struct resource *r)`：递归释放指定资源的所有子资源。\n- `find_next_iomem_res(...)`：在 `iomem_resource` 树中查找与指定区间 `[start, end]` 重叠且满足标志和描述符条件的下一个内存资源。\n- `for_each_resource` 宏：遍历资源树的通用宏，支持是否跳过子树的选项。\n\n### /proc 接口（条件编译）\n- 通过 `CONFIG_PROC_FS` 启用时，注册 `/proc/ioports` 和 `/proc/iomem` 文件，以树形格式展示当前系统中已分配的 I/O 端口和内存资源（仅对 `CAP_SYS_ADMIN` 权限用户显示实际地址）。\n\n## 3. 关键实现\n\n### 资源树结构\n- 资源以多叉树形式组织，每个 `struct resource` 包含 `child`（第一个子节点）、`sibling`（下一个兄弟节点）和 `parent` 指针。\n- 树内节点按起始地址升序排列，便于快速查找和插入。\n\n### 资源申请（`__request_resource`）\n- 在持有写锁 `resource_lock` 的前提下，遍历根节点的子链表。\n- 若新资源与现有节点无重叠，则按地址顺序插入；若存在重叠，则返回冲突节点。\n- 插入操作维护树的有序性：新节点插入到第一个起始地址大于其结束地址的节点之前。\n\n### 资源释放（`__release_resource`）\n- 支持两种模式：完全释放（含子资源）或仅提升子资源（当 `release_child=false` 时，将子节点直接挂到父节点下）。\n- 释放时调整兄弟链表指针，确保树结构完整性。\n\n### 资源遍历\n- `next_resource()`：深度优先遍历（先子节点，再兄弟节点）。\n- `next_resource_skip_children()`：仅遍历同级兄弟节点，跳过子树。\n- `/proc` 显示使用深度优先遍历，并限制最大显示层级（`MAX_IORES_LEVEL=5`）以避免过深嵌套。\n\n### 内存管理\n- 资源结构体通过 `alloc_resource()`（即 `kzalloc`）分配，通过 `free_resource()` 释放。\n- 注释指出：若资源由早期 `memblock` 分配，则无法安全释放（因非页对齐），会轻微泄漏，这是有意为之的简化设计。\n\n### 并发控制\n- 使用读写锁 `resource_lock` 保护全局资源树：\n  - 读操作（如 `/proc` 显示、`find_next_iomem_res`）使用 `read_lock`。\n  - 写操作（申请/释放资源）使用 `write_lock`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ioport.h>`：定义 `struct resource` 及相关宏（如 `IORESOURCE_IO`）。\n  - `<linux/proc_fs.h>`、`<linux/seq_file.h>`：实现 `/proc` 接口。\n  - `<linux/slab.h>`：资源结构体的动态分配。\n  - `<linux/spinlock.h>`：读写锁 `resource_lock` 的实现。\n  - `<asm/io.h>`：架构相关的 I/O 定义（如 `IO_SPACE_LIMIT`）。\n- **导出符号**：\n  - `ioport_resource`、`iomem_resource`、`request_resource`、`release_resource` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如 PCI、platform_device 驱动）使用。\n- **配置依赖**：\n  - `/proc` 接口依赖 `CONFIG_PROC_FS`。\n\n## 5. 使用场景\n\n- **设备驱动资源管理**：PCI、platform 等总线驱动在探测设备时，调用 `request_resource()` 申请 I/O 端口或内存区域，防止资源冲突。\n- **固件/ACPI 资源解析**：内核解析 ACPI 表或 EFI 内存映射时，将保留区域注册到 `iomem_resource` 树中。\n- **系统调试与监控**：用户空间通过 `/proc/ioports` 和 `/proc/iomem` 查看硬件资源分配情况（需 root 权限）。\n- **内核子系统协作**：内存管理子系统（如 `devm_request_mem_region`）、DMA 引擎等依赖此机制确保物理地址资源的独占使用。\n- **热插拔支持**：设备移除时调用 `release_resource()` 释放资源，供后续设备重用。",
      "similarity": 0.5742964148521423,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/resource.c",
          "start_line": 637,
          "end_line": 763,
          "content": [
            "int region_intersects(resource_size_t start, size_t size, unsigned long flags,",
            "\t\t      unsigned long desc)",
            "{",
            "\tint ret;",
            "",
            "\tread_lock(&resource_lock);",
            "\tret = __region_intersects(&iomem_resource, start, size, flags, desc);",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn ret;",
            "}",
            "void __weak arch_remove_reservations(struct resource *avail)",
            "{",
            "}",
            "static resource_size_t simple_align_resource(void *data,",
            "\t\t\t\t\t     const struct resource *avail,",
            "\t\t\t\t\t     resource_size_t size,",
            "\t\t\t\t\t     resource_size_t align)",
            "{",
            "\treturn avail->start;",
            "}",
            "static void resource_clip(struct resource *res, resource_size_t min,",
            "\t\t\t  resource_size_t max)",
            "{",
            "\tif (res->start < min)",
            "\t\tres->start = min;",
            "\tif (res->end > max)",
            "\t\tres->end = max;",
            "}",
            "static int __find_resource(struct resource *root, struct resource *old,",
            "\t\t\t struct resource *new,",
            "\t\t\t resource_size_t  size,",
            "\t\t\t struct resource_constraint *constraint)",
            "{",
            "\tstruct resource *this = root->child;",
            "\tstruct resource tmp = *new, avail, alloc;",
            "",
            "\ttmp.start = root->start;",
            "\t/*",
            "\t * Skip past an allocated resource that starts at 0, since the assignment",
            "\t * of this->start - 1 to tmp->end below would cause an underflow.",
            "\t */",
            "\tif (this && this->start == root->start) {",
            "\t\ttmp.start = (this == old) ? old->start : this->end + 1;",
            "\t\tthis = this->sibling;",
            "\t}",
            "\tfor(;;) {",
            "\t\tif (this)",
            "\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;",
            "\t\telse",
            "\t\t\ttmp.end = root->end;",
            "",
            "\t\tif (tmp.end < tmp.start)",
            "\t\t\tgoto next;",
            "",
            "\t\tresource_clip(&tmp, constraint->min, constraint->max);",
            "\t\tarch_remove_reservations(&tmp);",
            "",
            "\t\t/* Check for overflow after ALIGN() */",
            "\t\tavail.start = ALIGN(tmp.start, constraint->align);",
            "\t\tavail.end = tmp.end;",
            "\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;",
            "\t\tif (avail.start >= tmp.start) {",
            "\t\t\talloc.flags = avail.flags;",
            "\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,",
            "\t\t\t\t\tsize, constraint->align);",
            "\t\t\talloc.end = alloc.start + size - 1;",
            "\t\t\tif (alloc.start <= alloc.end &&",
            "\t\t\t    resource_contains(&avail, &alloc)) {",
            "\t\t\t\tnew->start = alloc.start;",
            "\t\t\t\tnew->end = alloc.end;",
            "\t\t\t\treturn 0;",
            "\t\t\t}",
            "\t\t}",
            "",
            "next:\t\tif (!this || this->end == root->end)",
            "\t\t\tbreak;",
            "",
            "\t\tif (this != old)",
            "\t\t\ttmp.start = this->end + 1;",
            "\t\tthis = this->sibling;",
            "\t}",
            "\treturn -EBUSY;",
            "}",
            "static int find_resource(struct resource *root, struct resource *new,",
            "\t\t\tresource_size_t size,",
            "\t\t\tstruct resource_constraint  *constraint)",
            "{",
            "\treturn  __find_resource(root, NULL, new, size, constraint);",
            "}",
            "static int reallocate_resource(struct resource *root, struct resource *old,",
            "\t\t\t       resource_size_t newsize,",
            "\t\t\t       struct resource_constraint *constraint)",
            "{",
            "\tint err=0;",
            "\tstruct resource new = *old;",
            "\tstruct resource *conflict;",
            "",
            "\twrite_lock(&resource_lock);",
            "",
            "\tif ((err = __find_resource(root, old, &new, newsize, constraint)))",
            "\t\tgoto out;",
            "",
            "\tif (resource_contains(&new, old)) {",
            "\t\told->start = new.start;",
            "\t\told->end = new.end;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (old->child) {",
            "\t\terr = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (resource_contains(old, &new)) {",
            "\t\told->start = new.start;",
            "\t\told->end = new.end;",
            "\t} else {",
            "\t\t__release_resource(old, true);",
            "\t\t*old = new;",
            "\t\tconflict = __request_resource(root, old);",
            "\t\tBUG_ON(conflict);",
            "\t}",
            "out:",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}"
          ],
          "function_name": "region_intersects, arch_remove_reservations, simple_align_resource, resource_clip, __find_resource, find_resource, reallocate_resource",
          "description": "实现资源分配策略核心逻辑，包含资源位置查找、尺寸调整、冲突检测等关键功能，支持带约束条件的资源重新分配与位置确定。",
          "similarity": 0.6716938614845276
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/resource.c",
          "start_line": 802,
          "end_line": 912,
          "content": [
            "int allocate_resource(struct resource *root, struct resource *new,",
            "\t\t      resource_size_t size, resource_size_t min,",
            "\t\t      resource_size_t max, resource_size_t align,",
            "\t\t      resource_size_t (*alignf)(void *,",
            "\t\t\t\t\t\tconst struct resource *,",
            "\t\t\t\t\t\tresource_size_t,",
            "\t\t\t\t\t\tresource_size_t),",
            "\t\t      void *alignf_data)",
            "{",
            "\tint err;",
            "\tstruct resource_constraint constraint;",
            "",
            "\tif (!alignf)",
            "\t\talignf = simple_align_resource;",
            "",
            "\tconstraint.min = min;",
            "\tconstraint.max = max;",
            "\tconstraint.align = align;",
            "\tconstraint.alignf = alignf;",
            "\tconstraint.alignf_data = alignf_data;",
            "",
            "\tif ( new->parent ) {",
            "\t\t/* resource is already allocated, try reallocating with",
            "\t\t   the new constraints */",
            "\t\treturn reallocate_resource(root, new, size, &constraint);",
            "\t}",
            "",
            "\twrite_lock(&resource_lock);",
            "\terr = find_resource(root, new, size, &constraint);",
            "\tif (err >= 0 && __request_resource(root, new))",
            "\t\terr = -EBUSY;",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}",
            "int insert_resource(struct resource *parent, struct resource *new)",
            "{",
            "\tstruct resource *conflict;",
            "",
            "\tconflict = insert_resource_conflict(parent, new);",
            "\treturn conflict ? -EBUSY : 0;",
            "}",
            "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)",
            "{",
            "\tif (new->parent)",
            "\t\treturn;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tconflict = __insert_resource(root, new);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\tif (conflict == root)",
            "\t\t\tbreak;",
            "",
            "\t\t/* Ok, expand resource to cover the conflict, then try again .. */",
            "\t\tif (conflict->start < new->start)",
            "\t\t\tnew->start = conflict->start;",
            "\t\tif (conflict->end > new->end)",
            "\t\t\tnew->end = conflict->end;",
            "",
            "\t\tpr_info(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);",
            "\t}",
            "\twrite_unlock(&resource_lock);",
            "}",
            "int remove_resource(struct resource *old)",
            "{",
            "\tint retval;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tretval = __release_resource(old, false);",
            "\twrite_unlock(&resource_lock);",
            "\treturn retval;",
            "}",
            "static int __adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t\t\tresource_size_t size)",
            "{",
            "\tstruct resource *tmp, *parent = res->parent;",
            "\tresource_size_t end = start + size - 1;",
            "\tint result = -EBUSY;",
            "",
            "\tif (!parent)",
            "\t\tgoto skip;",
            "",
            "\tif ((start < parent->start) || (end > parent->end))",
            "\t\tgoto out;",
            "",
            "\tif (res->sibling && (res->sibling->start <= end))",
            "\t\tgoto out;",
            "",
            "\ttmp = parent->child;",
            "\tif (tmp != res) {",
            "\t\twhile (tmp->sibling != res)",
            "\t\t\ttmp = tmp->sibling;",
            "\t\tif (start <= tmp->end)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "skip:",
            "\tfor (tmp = res->child; tmp; tmp = tmp->sibling)",
            "\t\tif ((tmp->start < start) || (tmp->end > end))",
            "\t\t\tgoto out;",
            "",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tresult = 0;",
            "",
            " out:",
            "\treturn result;",
            "}"
          ],
          "function_name": "allocate_resource, insert_resource, insert_resource_expand_to_fit, remove_resource, __adjust_resource",
          "description": "实现资源分配逻辑，支持带约束条件的资源查找与申请，处理资源冲突及扩展调整，提供基础资源管理框架。",
          "similarity": 0.6366452574729919
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/resource.c",
          "start_line": 492,
          "end_line": 601,
          "content": [
            "int walk_mem_res(u64 start, u64 end, void *arg,",
            "\t\t int (*func)(struct resource *, void *))",
            "{",
            "\tunsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;",
            "",
            "\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,",
            "\t\t\t\t     func);",
            "}",
            "int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,",
            "\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))",
            "{",
            "\tresource_size_t start, end;",
            "\tunsigned long flags;",
            "\tstruct resource res;",
            "\tunsigned long pfn, end_pfn;",
            "\tint ret = -EINVAL;",
            "",
            "\tstart = (u64) start_pfn << PAGE_SHIFT;",
            "\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;",
            "\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;",
            "\twhile (start < end &&",
            "\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res)) {",
            "\t\tpfn = PFN_UP(res.start);",
            "\t\tend_pfn = PFN_DOWN(res.end + 1);",
            "\t\tif (end_pfn > pfn)",
            "\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t\tstart = res.end + 1;",
            "\t}",
            "\treturn ret;",
            "}",
            "static int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)",
            "{",
            "\treturn 1;",
            "}",
            "int __weak page_is_ram(unsigned long pfn)",
            "{",
            "\treturn walk_system_ram_range(pfn, 1, NULL, __is_ram) == 1;",
            "}",
            "static int __region_intersects(struct resource *parent, resource_size_t start,",
            "\t\t\t       size_t size, unsigned long flags,",
            "\t\t\t       unsigned long desc)",
            "{",
            "\tresource_size_t ostart, oend;",
            "\tint type = 0; int other = 0;",
            "\tstruct resource *p, *dp;",
            "\tbool is_type, covered;",
            "\tstruct resource res;",
            "",
            "\tres.start = start;",
            "\tres.end = start + size - 1;",
            "",
            "\tfor (p = parent->child; p ; p = p->sibling) {",
            "\t\tif (!resource_overlaps(p, &res))",
            "\t\t\tcontinue;",
            "\t\tis_type = (p->flags & flags) == flags &&",
            "\t\t\t(desc == IORES_DESC_NONE || desc == p->desc);",
            "\t\tif (is_type) {",
            "\t\t\ttype++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Continue to search in descendant resources as if the",
            "\t\t * matched descendant resources cover some ranges of 'p'.",
            "\t\t *",
            "\t\t * |------------- \"CXL Window 0\" ------------|",
            "\t\t * |-- \"System RAM\" --|",
            "\t\t *",
            "\t\t * will behave similar as the following fake resource",
            "\t\t * tree when searching \"System RAM\".",
            "\t\t *",
            "\t\t * |-- \"System RAM\" --||-- \"CXL Window 0a\" --|",
            "\t\t */",
            "\t\tcovered = false;",
            "\t\tostart = max(res.start, p->start);",
            "\t\toend = min(res.end, p->end);",
            "\t\tfor_each_resource(p, dp, false) {",
            "\t\t\tif (!resource_overlaps(dp, &res))",
            "\t\t\t\tcontinue;",
            "\t\t\tis_type = (dp->flags & flags) == flags &&",
            "\t\t\t\t(desc == IORES_DESC_NONE || desc == dp->desc);",
            "\t\t\tif (is_type) {",
            "\t\t\t\ttype++;",
            "\t\t\t\t/*",
            "\t\t\t\t * Range from 'ostart' to 'dp->start'",
            "\t\t\t\t * isn't covered by matched resource.",
            "\t\t\t\t */",
            "\t\t\t\tif (dp->start > ostart)",
            "\t\t\t\t\tbreak;",
            "\t\t\t\tif (dp->end >= oend) {",
            "\t\t\t\t\tcovered = true;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\t/* Remove covered range */",
            "\t\t\t\tostart = max(ostart, dp->end + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (!covered)",
            "\t\t\tother++;",
            "\t}",
            "",
            "\tif (type == 0)",
            "\t\treturn REGION_DISJOINT;",
            "",
            "\tif (other == 0)",
            "\t\treturn REGION_INTERSECTS;",
            "",
            "\treturn REGION_MIXED;",
            "}"
          ],
          "function_name": "walk_mem_res, walk_system_ram_range, __is_ram, page_is_ram, __region_intersects",
          "description": "提供内存资源遍历接口，将物理地址转换为资源结构进行处理，包含判断内存区域是否为RAM的弱符号实现及区域交集检测逻辑。",
          "similarity": 0.6250383257865906
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/resource.c",
          "start_line": 1072,
          "end_line": 1180,
          "content": [
            "int adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t    resource_size_t size)",
            "{",
            "\tint result;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tresult = __adjust_resource(res, start, size);",
            "\twrite_unlock(&resource_lock);",
            "\treturn result;",
            "}",
            "static void __init",
            "__reserve_region_with_split(struct resource *root, resource_size_t start,",
            "\t\t\t    resource_size_t end, const char *name)",
            "{",
            "\tstruct resource *parent = root;",
            "\tstruct resource *conflict;",
            "\tstruct resource *res = alloc_resource(GFP_ATOMIC);",
            "\tstruct resource *next_res = NULL;",
            "\tint type = resource_type(root);",
            "",
            "\tif (!res)",
            "\t\treturn;",
            "",
            "\tres->name = name;",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tres->flags = type | IORESOURCE_BUSY;",
            "\tres->desc = IORES_DESC_NONE;",
            "",
            "\twhile (1) {",
            "",
            "\t\tconflict = __request_resource(parent, res);",
            "\t\tif (!conflict) {",
            "\t\t\tif (!next_res)",
            "\t\t\t\tbreak;",
            "\t\t\tres = next_res;",
            "\t\t\tnext_res = NULL;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/* conflict covered whole area */",
            "\t\tif (conflict->start <= res->start &&",
            "\t\t\t\tconflict->end >= res->end) {",
            "\t\t\tfree_resource(res);",
            "\t\t\tWARN_ON(next_res);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* failed, split and try again */",
            "\t\tif (conflict->start > res->start) {",
            "\t\t\tend = res->end;",
            "\t\t\tres->end = conflict->start - 1;",
            "\t\t\tif (conflict->end < end) {",
            "\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);",
            "\t\t\t\tif (!next_res) {",
            "\t\t\t\t\tfree_resource(res);",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tnext_res->name = name;",
            "\t\t\t\tnext_res->start = conflict->end + 1;",
            "\t\t\t\tnext_res->end = end;",
            "\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;",
            "\t\t\t\tnext_res->desc = IORES_DESC_NONE;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tres->start = conflict->end + 1;",
            "\t\t}",
            "\t}",
            "",
            "}",
            "void __init",
            "reserve_region_with_split(struct resource *root, resource_size_t start,",
            "\t\t\t  resource_size_t end, const char *name)",
            "{",
            "\tint abort = 0;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tif (root->start > start || root->end < end) {",
            "\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",",
            "\t\t       (unsigned long long)start, (unsigned long long)end,",
            "\t\t       root);",
            "\t\tif (start > root->end || end < root->start)",
            "\t\t\tabort = 1;",
            "\t\telse {",
            "\t\t\tif (end > root->end)",
            "\t\t\t\tend = root->end;",
            "\t\t\tif (start < root->start)",
            "\t\t\t\tstart = root->start;",
            "\t\t\tpr_err(\"fixing request to [0x%llx-0x%llx]\\n\",",
            "\t\t\t       (unsigned long long)start,",
            "\t\t\t       (unsigned long long)end);",
            "\t\t}",
            "\t\tdump_stack();",
            "\t}",
            "\tif (!abort)",
            "\t\t__reserve_region_with_split(root, start, end, name);",
            "\twrite_unlock(&resource_lock);",
            "}",
            "resource_size_t resource_alignment(struct resource *res)",
            "{",
            "\tswitch (res->flags & (IORESOURCE_SIZEALIGN | IORESOURCE_STARTALIGN)) {",
            "\tcase IORESOURCE_SIZEALIGN:",
            "\t\treturn resource_size(res);",
            "\tcase IORESOURCE_STARTALIGN:",
            "\t\treturn res->start;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "function_name": "adjust_resource, __reserve_region_with_split, reserve_region_with_split, resource_alignment",
          "description": "实现资源区域分裂分配逻辑，处理大范围资源请求时的冲突分裂与重叠区域处理，提供资源对齐策略查询接口。",
          "similarity": 0.623023509979248
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/resource.c",
          "start_line": 1739,
          "end_line": 1846,
          "content": [
            "int iomem_map_sanity_check(resource_size_t addr, unsigned long size)",
            "{",
            "\tstruct resource *p = &iomem_resource;",
            "\tresource_size_t end = addr + size - 1;",
            "\tint err = 0;",
            "\tloff_t l;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {",
            "\t\t/*",
            "\t\t * We can probably skip the resources without",
            "\t\t * IORESOURCE_IO attribute?",
            "\t\t */",
            "\t\tif (p->start > end)",
            "\t\t\tcontinue;",
            "\t\tif (p->end < addr)",
            "\t\t\tcontinue;",
            "\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&",
            "\t\t    PFN_DOWN(p->end) >= PFN_DOWN(end))",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * if a resource is \"BUSY\", it's not a hardware resource",
            "\t\t * but a driver mapping of such a resource; we don't want",
            "\t\t * to warn for those; some drivers legitimately map only",
            "\t\t * partial hardware resources. (example: vesafb)",
            "\t\t */",
            "\t\tif (p->flags & IORESOURCE_BUSY)",
            "\t\t\tcontinue;",
            "",
            "\t\tpr_warn(\"resource sanity check: requesting [mem %pa-%pa], which spans more than %s %pR\\n\",",
            "\t\t\t&addr, &end, p->name, p);",
            "\t\terr = -1;",
            "\t\tbreak;",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool resource_is_exclusive(struct resource *root, u64 addr, resource_size_t size)",
            "{",
            "\tconst unsigned int exclusive_system_ram = IORESOURCE_SYSTEM_RAM |",
            "\t\t\t\t\t\t  IORESOURCE_EXCLUSIVE;",
            "\tbool skip_children = false, err = false;",
            "\tstruct resource *p;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor_each_resource(root, p, skip_children) {",
            "\t\tif (p->start >= addr + size)",
            "\t\t\tbreak;",
            "\t\tif (p->end < addr) {",
            "\t\t\tskip_children = true;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tskip_children = false;",
            "",
            "\t\t/*",
            "\t\t * IORESOURCE_SYSTEM_RAM resources are exclusive if",
            "\t\t * IORESOURCE_EXCLUSIVE is set, even if they",
            "\t\t * are not busy and even if \"iomem=relaxed\" is set. The",
            "\t\t * responsible driver dynamically adds/removes system RAM within",
            "\t\t * such an area and uncontrolled access is dangerous.",
            "\t\t */",
            "\t\tif ((p->flags & exclusive_system_ram) == exclusive_system_ram) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * A resource is exclusive if IORESOURCE_EXCLUSIVE is set",
            "\t\t * or CONFIG_IO_STRICT_DEVMEM is enabled and the",
            "\t\t * resource is busy.",
            "\t\t */",
            "\t\tif (!strict_iomem_checks || !(p->flags & IORESOURCE_BUSY))",
            "\t\t\tcontinue;",
            "\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)",
            "\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool iomem_is_exclusive(u64 addr)",
            "{",
            "\treturn resource_is_exclusive(&iomem_resource, addr & PAGE_MASK,",
            "\t\t\t\t     PAGE_SIZE);",
            "}",
            "void resource_list_free(struct list_head *head)",
            "{",
            "\tstruct resource_entry *entry, *tmp;",
            "",
            "\tlist_for_each_entry_safe(entry, tmp, head, node)",
            "\t\tresource_list_destroy_entry(entry);",
            "}",
            "static resource_size_t gfr_start(struct resource *base, resource_size_t size,",
            "\t\t\t\t resource_size_t align, unsigned long flags)",
            "{",
            "\tif (flags & GFR_DESCENDING) {",
            "\t\tresource_size_t end;",
            "",
            "\t\tend = min_t(resource_size_t, base->end, PHYSMEM_END);",
            "\t\treturn end - size + 1;",
            "\t}",
            "",
            "\treturn ALIGN(base->start, align);",
            "}"
          ],
          "function_name": "iomem_map_sanity_check, resource_is_exclusive, iomem_is_exclusive, resource_list_free, gfr_start",
          "description": "iomem_map_sanity_check 检查新请求的I/O内存区域是否与现有资源冲突，若存在覆盖则返回-1；resource_is_exclusive 判断目标地址是否属于独占资源，依据IORESOURCE_EXCLUSIVE标志及CONFIG_IO_STRICT_DEVMEM配置；iomem_is_exclusive 简化调用resource_is_exclusive检查单个地址；resource_list_free 遍历并销毁指定链表中的所有resource_entry；gfr_start 根据对齐方向计算起始地址，支持降序分配模式。",
          "similarity": 0.6153128147125244
        }
      ]
    }
  ]
}