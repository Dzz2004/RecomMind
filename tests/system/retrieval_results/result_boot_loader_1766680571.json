{
  "query": "boot loader",
  "timestamp": "2025-12-26 00:36:11",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/preload/bpf_preload.h",
      "md_summary": "> 自动生成时间: 2025-10-25 12:23:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\preload\\bpf_preload.h`\n\n---\n\n# bpf_preload.h 技术文档\n\n## 1. 文件概述\n\n`bpf_preload.h` 是 Linux 内核中用于支持 BPF（Berkeley Packet Filter）预加载机制的头文件。该文件定义了 BPF 预加载所需的核心数据结构和接口，允许内核模块在系统启动早期阶段注册并自动加载预定义的 BPF 程序和链接（links），从而实现无需用户空间干预的 BPF 功能初始化。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_preload_info`**  \n  表示单个 BPF 预加载项的信息：\n  - `char link_name[16]`：BPF 链接的名称（最多 15 个字符 + 1 个终止符）\n  - `struct bpf_link *link`：指向已创建的 BPF 链接对象的指针\n\n- **`struct bpf_preload_ops`**  \n  定义 BPF 预加载操作的回调接口：\n  - `int (*preload)(struct bpf_preload_info *)`：预加载回调函数，用于初始化并填充 `bpf_preload_info`\n  - `struct module *owner`：拥有该操作集的内核模块指针，用于引用计数管理\n\n### 全局变量与宏\n\n- **`extern struct bpf_preload_ops *bpf_preload_ops;`**  \n  全局指针，指向当前注册的 BPF 预加载操作集。由支持预加载的模块在初始化时设置。\n\n- **`#define BPF_PRELOAD_LINKS 2`**  \n  定义系统支持的最大预加载 BPF 链接数量（当前为 2）。\n\n## 3. 关键实现\n\n- 该头文件本身不包含具体实现逻辑，而是提供接口规范。\n- 预加载机制依赖于外部模块（如 `bpf_preload.ko`）实现 `bpf_preload_ops` 中的 `preload` 回调。\n- 在内核初始化阶段，BPF 子系统会调用 `bpf_preload_ops->preload()`，传入一个 `bpf_preload_info` 数组（大小为 `BPF_PRELOAD_LINKS`），由回调函数负责创建 BPF 程序、附加到相应 hook 点，并填充对应的 `link` 字段。\n- `link_name` 字段用于在 `/sys/fs/bpf/` 或其他调试接口中标识该预加载链接，便于用户空间识别和管理。\n- `owner` 字段确保在模块卸载时能正确释放相关资源，防止悬空指针。\n\n## 4. 依赖关系\n\n- 依赖 **BPF 核心子系统**（`kernel/bpf/`）提供的 `struct bpf_link` 定义及链接管理 API。\n- 依赖 **内核模块系统**（`include/linux/module.h`），用于模块引用计数和生命周期管理。\n- 通常由 **`bpf_preload` 内核模块**（位于 `kernel/bpf/preload/`）实现并注册 `bpf_preload_ops`。\n- 可能与 **LSM（Linux Security Module）**、**Tracing** 或 **Networking** 子系统交互，具体取决于预加载的 BPF 程序类型。\n\n## 5. 使用场景\n\n- **系统启动早期自动加载关键 BPF 程序**：例如安全策略（如 Landlock）、性能监控或网络策略，无需等待用户空间初始化。\n- **嵌入式或安全敏感环境**：在用户空间不可信或尚未启动时，通过内核内置机制确保关键 BPF 功能可用。\n- **简化部署**：将常用 BPF 程序打包进内核模块，实现“开箱即用”的 BPF 功能，避免复杂的用户空间加载逻辑。\n- **内核自检与调试**：预加载用于内核自检或调试的 BPF 程序，辅助开发和故障排查。",
      "similarity": 0.5259188413619995,
      "chunks": []
    },
    {
      "source_file": "mm/bootmem_info.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:41:59\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bootmem_info.c`\n\n---\n\n# bootmem_info.c 技术文档\n\n## 1. 文件概述\n\n`bootmem_info.c` 是 Linux 内核中用于管理启动阶段保留内存（bootmem）元数据的辅助模块。该文件主要负责在系统初始化期间，为与内存热插拔（memory hotplug）相关的内核数据结构（如 `pglist_data`、`mem_section` 的 memmap 和 usage 结构）所占用的物理页面打上特殊的标记，并通过引用计数机制跟踪这些页面的生命周期。当这些页面不再被需要时（例如在内存热移除过程中），可安全地释放回 buddy allocator。\n\n该机制确保了在内存热插拔操作中，用于描述内存布局的关键元数据页面不会被意外释放或重用，同时支持在适当时候回收这些保留页面以提高内存利用率。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`get_page_bootmem(unsigned long info, struct page *page, unsigned long type)`**  \n  为指定的 `struct page` 设置 bootmem 标记：  \n  - 将 `page->index` 设为类型 `type`  \n  - 设置 `PG_private` 标志  \n  - 将 `page->private` 设为附加信息 `info`  \n  - 增加页面引用计数\n\n- **`put_page_bootmem(struct page *page)`**  \n  减少 bootmem 页面的引用计数；若引用计数降至 1（表示仅剩 bootmem 引用），则清除标记并释放该页面：  \n  - 验证 `type` 在合法范围内（`MEMORY_HOTPLUG_MIN/MAX_BOOTMEM_TYPE`）  \n  - 清除 `PG_private` 标志和 `private` 字段  \n  - 初始化 `lru` 链表头  \n  - 调用 `kmemleak_free_part_phys()` 通知内存泄漏检测器  \n  - 调用 `free_reserved_page()` 将页面归还给伙伴系统\n\n- **`register_page_bootmem_info_section(unsigned long start_pfn)`**  \n  （`__init` 函数）为指定 PFN 所属内存 section 的以下结构注册 bootmem 信息：  \n  - `mem_section` 对应的 `memmap`（即 `struct page` 数组）  \n  - `mem_section_usage` 结构  \n  根据是否启用 `CONFIG_SPARSEMEM_VMEMMAP`，对 `memmap` 的处理方式不同\n\n- **`register_page_bootmem_info_node(struct pglist_data *pgdat)`**  \n  （`__init` 函数）为指定 NUMA 节点的以下结构注册 bootmem 信息：  \n  - `pglist_data`（即 `node` 描述符）本身  \n  - 该节点包含的所有有效内存 section 的 memmap 和 usage 结构\n\n### 关键数据结构依赖\n\n- `struct page`：通过其 `index`、`private` 字段和 `PG_private` 标志存储 bootmem 元数据\n- `struct pglist_data`：NUMA 节点内存描述符\n- `struct mem_section`：稀疏内存模型中的内存段描述符\n- `struct mem_section_usage`：内存段使用状态位图\n\n## 3. 关键实现\n\n### Bootmem 页面标记机制\n- 利用 `struct page` 中未在普通页面中使用的字段：\n  - `index` 存储页面类型（`NODE_INFO`、`SECTION_INFO` 或 `MIX_SECTION_INFO`）\n  - `private` 存储附加信息（如节点 ID 或 section 编号）\n- 通过 `SetPagePrivate()` 标记页面为“私有”，表明其受特殊管理\n- 引用计数用于跟踪页面是否仍被 bootmem 系统或其他子系统使用\n\n### 稀疏内存模型适配\n- **非 `VMEMMAP` 模式**（`!CONFIG_SPARSEMEM_VMEMMAP`）：  \n  `memmap` 是动态分配的虚拟地址，需手动遍历其对应的物理页面并逐个调用 `get_page_bootmem()`\n- **`VMEMMAP` 模式**：  \n  `memmap` 是线性映射，通过专用函数 `register_page_bootmem_memmap()` 处理（定义在其他文件中）\n\n### 节点与 Section 注册逻辑\n- `register_page_bootmem_info_node()` 遍历节点内所有 PFN，按 `PAGES_PER_SECTION` 步进\n- 使用 `early_pfn_to_nid()` 确保 PFN 仅在其所属节点注册，避免多节点平台上的重复注册\n- 仅对 `pfn_valid(pfn)` 有效的 PFN 进行处理\n\n### 安全释放机制\n- `put_page_bootmem()` 中的 `BUG_ON()` 确保类型值在预定义范围内，防止非法操作\n- 引用计数检查 (`page_ref_dec_return() == 1`) 确保只有最后一个引用释放时才真正归还页面\n- 调用 `kmemleak_free_part_phys()` 避免内存泄漏检测器误报\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`：核心内存管理定义\n  - `<linux/memblock.h>`：早期内存分配器\n  - `<linux/bootmem_info.h>`：本模块的公共接口声明（含类型常量和函数原型）\n  - `<linux/memory_hotplug.h>`：内存热插拔相关定义（如 `MEMORY_HOTPLUG_MIN/MAX_BOOTMEM_TYPE`）\n  - `<linux/kmemleak.h>`：内存泄漏检测接口\n\n- **功能依赖**：\n  - 稀疏内存模型（`CONFIG_SPARSEMEM`）：`register_page_bootmem_info_section` 的实现依赖于 sparse memory 架构\n  - 内存热插拔子系统：bootmem 类型常量和释放逻辑服务于热插拔场景\n  - 伙伴分配器（buddy allocator）：通过 `free_reserved_page()` 归还页面\n\n- **外部调用**：\n  - `register_page_bootmem_memmap()`（仅在 `VMEMMAP` 模式下）：由 `mm/sparse-vmemmap.c` 提供\n  - `free_reserved_page()`：由 `mm/page_alloc.c` 提供\n\n## 5. 使用场景\n\n- **系统初始化阶段**：  \n  在 `mm_init()` 或类似初始化路径中，通过 `register_page_bootmem_info_node()` 为每个 NUMA 节点的元数据页面注册 bootmem 信息\n\n- **内存热移除（Memory Hot-Unplug）**：  \n  当某个内存 section 被移除时，相关代码（如 `memory_block_release()`）会调用 `put_page_bootmem()` 释放之前保留的 memmap 和 usage 页面\n\n- **内存热添加（Memory Hot-Add）的逆向操作**：  \n  在热添加过程中分配的元数据页面，在后续移除时通过此机制安全回收\n\n- **调试与内存泄漏检测**：  \n  通过 `kmemleak` 集成，确保 bootmem 页面在释放时被正确跟踪，避免误报内存泄漏\n\n该文件是内存热插拔基础设施的重要组成部分，确保内核元数据页面的生命周期得到精确管理，从而支持动态内存配置的可靠性。",
      "similarity": 0.5224515199661255,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/bootmem_info.c",
          "start_line": 1,
          "end_line": 16,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Bootmem core functions.",
            " *",
            " * Copyright (c) 2020, Bytedance.",
            " *",
            " *     Author: Muchun Song <songmuchun@bytedance.com>",
            " *",
            " */",
            "#include <linux/mm.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bootmem_info.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            ""
          ],
          "function_name": null,
          "description": "包含 bootmem 信息模块的头部文件，声明核心函数和数据结构，用于支持内存热插拔场景下的页框信息跟踪与管理",
          "similarity": 0.5729274153709412
        },
        {
          "chunk_id": 1,
          "file_path": "mm/bootmem_info.c",
          "start_line": 17,
          "end_line": 122,
          "content": [
            "void get_page_bootmem(unsigned long info, struct page *page, unsigned long type)",
            "{",
            "\tpage->index = type;",
            "\tSetPagePrivate(page);",
            "\tset_page_private(page, info);",
            "\tpage_ref_inc(page);",
            "}",
            "void put_page_bootmem(struct page *page)",
            "{",
            "\tunsigned long type = page->index;",
            "",
            "\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||",
            "\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);",
            "",
            "\tif (page_ref_dec_return(page) == 1) {",
            "\t\tpage->index = 0;",
            "\t\tClearPagePrivate(page);",
            "\t\tset_page_private(page, 0);",
            "\t\tINIT_LIST_HEAD(&page->lru);",
            "\t\tkmemleak_free_part_phys(PFN_PHYS(page_to_pfn(page)), PAGE_SIZE);",
            "\t\tfree_reserved_page(page);",
            "\t}",
            "}",
            "static void __init register_page_bootmem_info_section(unsigned long start_pfn)",
            "{",
            "\tunsigned long mapsize, section_nr, i;",
            "\tstruct mem_section *ms;",
            "\tstruct page *page, *memmap;",
            "\tstruct mem_section_usage *usage;",
            "",
            "\tsection_nr = pfn_to_section_nr(start_pfn);",
            "\tms = __nr_to_section(section_nr);",
            "",
            "\t/* Get section's memmap address */",
            "\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);",
            "",
            "\t/*",
            "\t * Get page for the memmap's phys address",
            "\t * XXX: need more consideration for sparse_vmemmap...",
            "\t */",
            "\tpage = virt_to_page(memmap);",
            "\tmapsize = sizeof(struct page) * PAGES_PER_SECTION;",
            "\tmapsize = PAGE_ALIGN(mapsize) >> PAGE_SHIFT;",
            "",
            "\t/* remember memmap's page */",
            "\tfor (i = 0; i < mapsize; i++, page++)",
            "\t\tget_page_bootmem(section_nr, page, SECTION_INFO);",
            "",
            "\tusage = ms->usage;",
            "\tpage = virt_to_page(usage);",
            "",
            "\tmapsize = PAGE_ALIGN(mem_section_usage_size()) >> PAGE_SHIFT;",
            "",
            "\tfor (i = 0; i < mapsize; i++, page++)",
            "\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);",
            "",
            "}",
            "static void __init register_page_bootmem_info_section(unsigned long start_pfn)",
            "{",
            "\tunsigned long mapsize, section_nr, i;",
            "\tstruct mem_section *ms;",
            "\tstruct page *page, *memmap;",
            "\tstruct mem_section_usage *usage;",
            "",
            "\tsection_nr = pfn_to_section_nr(start_pfn);",
            "\tms = __nr_to_section(section_nr);",
            "",
            "\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);",
            "",
            "\tregister_page_bootmem_memmap(section_nr, memmap, PAGES_PER_SECTION);",
            "",
            "\tusage = ms->usage;",
            "\tpage = virt_to_page(usage);",
            "",
            "\tmapsize = PAGE_ALIGN(mem_section_usage_size()) >> PAGE_SHIFT;",
            "",
            "\tfor (i = 0; i < mapsize; i++, page++)",
            "\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);",
            "}",
            "void __init register_page_bootmem_info_node(struct pglist_data *pgdat)",
            "{",
            "\tunsigned long i, pfn, end_pfn, nr_pages;",
            "\tint node = pgdat->node_id;",
            "\tstruct page *page;",
            "",
            "\tnr_pages = PAGE_ALIGN(sizeof(struct pglist_data)) >> PAGE_SHIFT;",
            "\tpage = virt_to_page(pgdat);",
            "",
            "\tfor (i = 0; i < nr_pages; i++, page++)",
            "\t\tget_page_bootmem(node, page, NODE_INFO);",
            "",
            "\tpfn = pgdat->node_start_pfn;",
            "\tend_pfn = pgdat_end_pfn(pgdat);",
            "",
            "\t/* register section info */",
            "\tfor (; pfn < end_pfn; pfn += PAGES_PER_SECTION) {",
            "\t\t/*",
            "\t\t * Some platforms can assign the same pfn to multiple nodes - on",
            "\t\t * node0 as well as nodeN.  To avoid registering a pfn against",
            "\t\t * multiple nodes we check that this pfn does not already",
            "\t\t * reside in some other nodes.",
            "\t\t */",
            "\t\tif (pfn_valid(pfn) && (early_pfn_to_nid(pfn) == node))",
            "\t\t\tregister_page_bootmem_info_section(pfn);",
            "\t}",
            "}"
          ],
          "function_name": "get_page_bootmem, put_page_bootmem, register_page_bootmem_info_section, register_page_bootmem_info_section, register_page_bootmem_info_node",
          "description": "实现 bootmem 页面引用计数管理和注册逻辑，通过 get/put_page_bootmem 控制页面生命周期，register_page_bootmem_info_section 注册内存段信息，存在重复函数定义导致上下文不完整",
          "similarity": 0.5292761921882629
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_boot.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:13:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_boot.c`\n\n---\n\n# `trace_boot.c` 技术文档\n\n## 1. 文件概述\n\n`trace_boot.c` 是 Linux 内核中用于在系统启动阶段（boot-time）配置和启用 ftrace 跟踪功能的核心实现文件。该文件通过解析内核启动参数中由 BootConfig（`/bootconfig`）提供的配置项，动态设置跟踪实例（`trace_array`）的各项参数，包括跟踪选项、事件启用、缓冲区大小、CPU 掩码、时钟源等，并支持高级功能如 kprobe 事件、合成事件（synthetic events）和直方图触发器（histogram triggers）。其目标是在内核初始化早期阶段完成跟踪系统的自动化配置，无需用户空间干预。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`trace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)`**  \n  解析 BootConfig 节点中与跟踪实例相关的通用配置项，设置 `tracing_on`、`trace_clock`、`buffer_size`、`cpumask` 和通用 ftrace 选项。\n\n- **`trace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)`**（需 `CONFIG_EVENT_TRACING`）  \n  根据 BootConfig 中的 `events` 数组启用指定的静态跟踪事件。\n\n- **`trace_boot_add_kprobe_event(struct xbc_node *node, const char *event)`**（需 `CONFIG_KPROBE_EVENTS`）  \n  动态创建并注册 kprobe 类型的动态事件，支持在启动时注入探针。\n\n- **`trace_boot_add_synth_event(struct xbc_node *node, const char *event)`**（需 `CONFIG_SYNTH_EVENTS`）  \n  根据 BootConfig 定义创建合成事件（synthetic event），用于组合多个事件数据。\n\n- **`trace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)`**（需 `CONFIG_HIST_TRIGGERS`）  \n  将 BootConfig 中的直方图触发器配置转换为内核可识别的命令字符串，用于设置复杂的事件触发逻辑（如 `onmax`、`onmatch` 等）。\n\n- **辅助函数（仅 `CONFIG_HIST_TRIGGERS` 下）**：\n  - `append_printf()`：安全地向缓冲区追加格式化字符串。\n  - `append_str_nospace()`：追加去除空白字符的字符串。\n  - `trace_boot_hist_add_array()`：处理直方图的数组型参数（如 `keys`、`values`）。\n  - `trace_boot_hist_add_one_handler()`：构建单个触发动作（如 `onmax(...).save(...)`）。\n  - `trace_boot_hist_add_handlers()`：处理多个或默认的触发器实例。\n\n## 3. 关键实现\n\n- **BootConfig 集成**：  \n  所有配置均通过 `xbc_node` 接口从 BootConfig 树中读取。使用 `xbc_node_find_value()` 获取标量值，`xbc_node_for_each_array_value()` 遍历数组，`xbc_node_for_each_subkey()` 处理嵌套结构。\n\n- **动态事件创建**：  \n  利用 `dynevent_cmd` 框架（`kprobe_event_cmd_init` / `synth_event_cmd_init`）构建动态事件命令，通过 `*_gen_cmd_start/end` 完成注册，确保与运行时动态事件机制一致。\n\n- **直方图触发器语法转换**：  \n  将 BootConfig 的树形结构（如 `hist { keys = ...; onmax.0 { var=...; save=... } }`）转换为内核直方图子系统所需的线性命令字符串（如 `\"hist:keys=...:onmax(var).save(...)\"`），通过递归解析子节点和参数完成。\n\n- **错误处理与日志**：  \n  所有配置项解析失败时均通过 `pr_err()` 输出错误信息，但不中断整体启动流程，保证系统稳定性。\n\n- **内存安全**：  \n  使用固定大小缓冲区（`MAX_BUF_LEN = 256`）并配合 `strscpy()` 防止溢出；CPU 掩码操作使用 `alloc_cpumask_var()` 动态分配。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/bootconfig.h>`：BootConfig 解析接口。\n  - `<linux/ftrace.h>`、`<linux/trace.h>`、`\"trace.h\"`：ftrace 核心 API 和内部结构。\n  - `<linux/trace_events.h>`：事件跟踪基础设施。\n\n- **条件编译依赖**：\n  - `CONFIG_EVENT_TRACING`：启用静态事件跟踪。\n  - `CONFIG_KPROBE_EVENTS`：支持 kprobe 动态事件。\n  - `CONFIG_SYNTH_EVENTS`：支持合成事件。\n  - `CONFIG_HIST_TRIGGERS`：支持直方图触发器。\n\n- **内核子系统交互**：\n  - **ftrace 子系统**：通过 `trace_set_options()`、`tracer_tracing_on/off()` 等接口控制跟踪行为。\n  - **Ring Buffer**：通过 `tracing_resize_ring_buffer()` 调整缓冲区。\n  - **CPU 热插拔**：通过 `tracing_set_cpumask()` 设置参与跟踪的 CPU 集合。\n\n## 5. 使用场景\n\n- **内核启动调试**：  \n  在系统早期初始化阶段自动启用特定跟踪事件（如调度器、内存分配），捕获传统用户空间工具无法观测的启动路径。\n\n- **自动化性能分析**：  \n  通过预置 BootConfig 配置，在每次启动时自动收集性能数据（如函数调用图、事件延迟），用于持续集成或基准测试。\n\n- **动态探针部署**：  \n  在无用户空间介入的情况下，于启动时注入 kprobe 探针监控关键函数，适用于嵌入式或安全受限环境。\n\n- **复杂事件关联**：  \n  利用合成事件和直方图触发器，在启动阶段实现跨事件的数据聚合与条件触发（如“当某函数延迟超过阈值时保存上下文”）。\n\n- **资源受限系统优化**：  \n  通过 `buffer_size` 和 `cpumask` 精确控制跟踪开销，避免在低内存或单核系统上影响启动性能。",
      "similarity": 0.5209681391716003,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace_boot.c",
            " * Tracing kernel boot-time",
            " */",
            "",
            "#define pr_fmt(fmt)\t\"trace_boot: \" fmt",
            "",
            "#include <linux/bootconfig.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace.h>",
            "#include <linux/trace_events.h>",
            "",
            "#include \"trace.h\"",
            "",
            "#define MAX_BUF_LEN 256",
            ""
          ],
          "function_name": null,
          "description": "定义trace_boot模块的基础头文件和宏，为跟踪启动时间相关功能提供基础设施。",
          "similarity": 0.5421891808509827
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 591,
          "end_line": 663,
          "content": [
            "static void __init",
            "trace_boot_enable_tracer(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tconst char *p;",
            "",
            "\ttrace_boot_set_ftrace_filter(tr, node);",
            "",
            "\tp = xbc_node_find_value(node, \"tracer\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (tracing_set_tracer(tr, p) < 0)",
            "\t\t\tpr_err(\"Failed to set given tracer: %s\\n\", p);",
            "\t}",
            "",
            "\t/* Since tracer can free snapshot buffer, allocate snapshot here.*/",
            "\tif (xbc_node_find_value(node, \"alloc_snapshot\", NULL)) {",
            "\t\tif (tracing_alloc_snapshot_instance(tr) < 0)",
            "\t\t\tpr_err(\"Failed to allocate snapshot buffer\\n\");",
            "\t}",
            "}",
            "static void __init",
            "trace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\ttrace_boot_set_instance_options(tr, node);",
            "\ttrace_boot_init_events(tr, node);",
            "\ttrace_boot_enable_events(tr, node);",
            "\ttrace_boot_enable_tracer(tr, node);",
            "}",
            "static void __init",
            "trace_boot_init_instances(struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *inode;",
            "\tstruct trace_array *tr;",
            "\tconst char *p;",
            "",
            "\tnode = xbc_node_find_subkey(node, \"instance\");",
            "\tif (!node)",
            "\t\treturn;",
            "",
            "\txbc_node_for_each_subkey(node, inode) {",
            "\t\tp = xbc_node_get_data(inode);",
            "\t\tif (!p || *p == '\\0')",
            "\t\t\tcontinue;",
            "",
            "\t\ttr = trace_array_get_by_name(p, NULL);",
            "\t\tif (!tr) {",
            "\t\t\tpr_err(\"Failed to get trace instance %s\\n\", p);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\ttrace_boot_init_one_instance(tr, inode);",
            "\t\ttrace_array_put(tr);",
            "\t}",
            "}",
            "static int __init trace_boot_init(void)",
            "{",
            "\tstruct xbc_node *trace_node;",
            "\tstruct trace_array *tr;",
            "",
            "\ttrace_node = xbc_find_node(\"ftrace\");",
            "\tif (!trace_node)",
            "\t\treturn 0;",
            "",
            "\ttr = top_trace_array();",
            "\tif (!tr)",
            "\t\treturn 0;",
            "",
            "\t/* Global trace array is also one instance */",
            "\ttrace_boot_init_one_instance(tr, trace_node);",
            "\ttrace_boot_init_instances(trace_node);",
            "",
            "\tdisable_tracing_selftest(\"running boot-time tracing\");",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "trace_boot_enable_tracer, trace_boot_init_one_instance, trace_boot_init_instances, trace_boot_init",
          "description": "该代码段实现了Boot-Time Tracing的初始化逻辑，核心功能是根据Xenon Boot Config（xbc）节点动态创建和配置跟踪实例。  \n`trace_boot_enable_tracer`启用指定tracer并分配快照缓冲区，`trace_boot_init_one_instance`初始化单个跟踪实例的事件与选项，`trace_boot_init_instances`遍历xbc节点注册多实例跟踪配置。  \n上下文不完整，缺少xbc_node结构体定义及部分辅助函数实现。",
          "similarity": 0.5294241905212402
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 453,
          "end_line": 577,
          "content": [
            "static void __init",
            "trace_boot_init_histograms(struct trace_event_file *file,",
            "\t\t\t   struct xbc_node *hnode, char *buf, size_t size)",
            "{",
            "\t/* do nothing */",
            "}",
            "static void __init",
            "trace_boot_init_one_event(struct trace_array *tr, struct xbc_node *gnode,",
            "\t\t\t  struct xbc_node *enode)",
            "{",
            "\tstruct trace_event_file *file;",
            "\tstruct xbc_node *anode;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tconst char *p, *group, *event;",
            "",
            "\tgroup = xbc_node_get_data(gnode);",
            "\tevent = xbc_node_get_data(enode);",
            "",
            "\tif (!strcmp(group, \"kprobes\"))",
            "\t\tif (trace_boot_add_kprobe_event(enode, event) < 0)",
            "\t\t\treturn;",
            "\tif (!strcmp(group, \"synthetic\"))",
            "\t\tif (trace_boot_add_synth_event(enode, event) < 0)",
            "\t\t\treturn;",
            "",
            "\tmutex_lock(&event_mutex);",
            "\tfile = find_event_file(tr, group, event);",
            "\tif (!file) {",
            "\t\tpr_err(\"Failed to find event: %s:%s\\n\", group, event);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tp = xbc_node_find_value(enode, \"filter\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0)",
            "\t\t\tpr_err(\"filter string is too long: %s\\n\", p);",
            "\t\telse if (apply_event_filter(file, buf) < 0)",
            "\t\t\tpr_err(\"Failed to apply filter: %s\\n\", buf);",
            "\t}",
            "",
            "\tif (IS_ENABLED(CONFIG_HIST_TRIGGERS)) {",
            "\t\txbc_node_for_each_array_value(enode, \"actions\", anode, p) {",
            "\t\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0)",
            "\t\t\t\tpr_err(\"action string is too long: %s\\n\", p);",
            "\t\t\telse if (trigger_process_regex(file, buf) < 0)",
            "\t\t\t\tpr_err(\"Failed to apply an action: %s\\n\", p);",
            "\t\t}",
            "\t\tanode = xbc_node_find_subkey(enode, \"hist\");",
            "\t\tif (anode)",
            "\t\t\ttrace_boot_init_histograms(file, anode, buf, ARRAY_SIZE(buf));",
            "\t} else if (xbc_node_find_value(enode, \"actions\", NULL))",
            "\t\tpr_err(\"Failed to apply event actions because CONFIG_HIST_TRIGGERS is not set.\\n\");",
            "",
            "\tif (xbc_node_find_value(enode, \"enable\", NULL)) {",
            "\t\tif (trace_event_enable_disable(file, 1, 0) < 0)",
            "\t\t\tpr_err(\"Failed to enable event node: %s:%s\\n\",",
            "\t\t\t\tgroup, event);",
            "\t}",
            "out:",
            "\tmutex_unlock(&event_mutex);",
            "}",
            "static void __init",
            "trace_boot_init_events(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *gnode, *enode;",
            "\tbool enable, enable_all = false;",
            "\tconst char *data;",
            "",
            "\tnode = xbc_node_find_subkey(node, \"event\");",
            "\tif (!node)",
            "\t\treturn;",
            "\t/* per-event key starts with \"event.GROUP.EVENT\" */",
            "\txbc_node_for_each_subkey(node, gnode) {",
            "\t\tdata = xbc_node_get_data(gnode);",
            "\t\tif (!strcmp(data, \"enable\")) {",
            "\t\t\tenable_all = true;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tenable = false;",
            "\t\txbc_node_for_each_subkey(gnode, enode) {",
            "\t\t\tdata = xbc_node_get_data(enode);",
            "\t\t\tif (!strcmp(data, \"enable\")) {",
            "\t\t\t\tenable = true;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\ttrace_boot_init_one_event(tr, gnode, enode);",
            "\t\t}",
            "\t\t/* Event enablement must be done after event settings */",
            "\t\tif (enable) {",
            "\t\t\tdata = xbc_node_get_data(gnode);",
            "\t\t\ttrace_array_set_clr_event(tr, data, NULL, true);",
            "\t\t}",
            "\t}",
            "\t/* Ditto */",
            "\tif (enable_all)",
            "\t\ttrace_array_set_clr_event(tr, NULL, NULL, true);",
            "}",
            "static void __init",
            "trace_boot_set_ftrace_filter(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *anode;",
            "\tconst char *p;",
            "\tchar *q;",
            "",
            "\txbc_node_for_each_array_value(node, \"ftrace.filters\", anode, p) {",
            "\t\tq = kstrdup(p, GFP_KERNEL);",
            "\t\tif (!q)",
            "\t\t\treturn;",
            "\t\tif (ftrace_set_filter(tr->ops, q, strlen(q), 0) < 0)",
            "\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);",
            "\t\telse",
            "\t\t\tftrace_filter_param = true;",
            "\t\tkfree(q);",
            "\t}",
            "\txbc_node_for_each_array_value(node, \"ftrace.notraces\", anode, p) {",
            "\t\tq = kstrdup(p, GFP_KERNEL);",
            "\t\tif (!q)",
            "\t\t\treturn;",
            "\t\tif (ftrace_set_notrace(tr->ops, q, strlen(q), 0) < 0)",
            "\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);",
            "\t\telse",
            "\t\t\tftrace_filter_param = true;",
            "\t\tkfree(q);",
            "\t}",
            "}"
          ],
          "function_name": "trace_boot_init_histograms, trace_boot_init_one_event, trace_boot_init_events, trace_boot_set_ftrace_filter",
          "description": "初始化事件及其过滤器设置，包含被覆盖的空实现函数及事件启用逻辑，处理ftrace过滤器参数注册。",
          "similarity": 0.3946784734725952
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 24,
          "end_line": 129,
          "content": [
            "static void __init",
            "trace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *anode;",
            "\tconst char *p;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tunsigned long v = 0;",
            "",
            "\t/* Common ftrace options */",
            "\txbc_node_for_each_array_value(node, \"options\", anode, p) {",
            "\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0) {",
            "\t\t\tpr_err(\"String is too long: %s\\n\", p);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (trace_set_options(tr, buf) < 0)",
            "\t\t\tpr_err(\"Failed to set option: %s\\n\", buf);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"tracing_on\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (kstrtoul(p, 10, &v))",
            "\t\t\tpr_err(\"Failed to set tracing on: %s\\n\", p);",
            "\t\tif (v)",
            "\t\t\ttracer_tracing_on(tr);",
            "\t\telse",
            "\t\t\ttracer_tracing_off(tr);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"trace_clock\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (tracing_set_clock(tr, p) < 0)",
            "\t\t\tpr_err(\"Failed to set trace clock: %s\\n\", p);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"buffer_size\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tv = memparse(p, NULL);",
            "\t\tif (v < PAGE_SIZE)",
            "\t\t\tpr_err(\"Buffer size is too small: %s\\n\", p);",
            "\t\tif (tracing_resize_ring_buffer(tr, v, RING_BUFFER_ALL_CPUS) < 0)",
            "\t\t\tpr_err(\"Failed to resize trace buffer to %s\\n\", p);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"cpumask\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tcpumask_var_t new_mask;",
            "",
            "\t\tif (alloc_cpumask_var(&new_mask, GFP_KERNEL)) {",
            "\t\t\tif (cpumask_parse(p, new_mask) < 0 ||",
            "\t\t\t    tracing_set_cpumask(tr, new_mask) < 0)",
            "\t\t\t\tpr_err(\"Failed to set new CPU mask %s\\n\", p);",
            "\t\t\tfree_cpumask_var(new_mask);",
            "\t\t}",
            "\t}",
            "}",
            "static void __init",
            "trace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *anode;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tconst char *p;",
            "",
            "\txbc_node_for_each_array_value(node, \"events\", anode, p) {",
            "\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0) {",
            "\t\t\tpr_err(\"String is too long: %s\\n\", p);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (ftrace_set_clr_event(tr, buf, 1) < 0)",
            "\t\t\tpr_err(\"Failed to enable event: %s\\n\", p);",
            "\t}",
            "}",
            "static int __init",
            "trace_boot_add_kprobe_event(struct xbc_node *node, const char *event)",
            "{",
            "\tstruct dynevent_cmd cmd;",
            "\tstruct xbc_node *anode;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tconst char *val;",
            "\tint ret = 0;",
            "",
            "\txbc_node_for_each_array_value(node, \"probes\", anode, val) {",
            "\t\tkprobe_event_cmd_init(&cmd, buf, MAX_BUF_LEN);",
            "",
            "\t\tret = kprobe_event_gen_cmd_start(&cmd, event, val);",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"Failed to generate probe: %s\\n\", buf);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tret = kprobe_event_gen_cmd_end(&cmd);",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"Failed to add probe: %s\\n\", buf);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static inline int __init",
            "trace_boot_add_kprobe_event(struct xbc_node *node, const char *event)",
            "{",
            "\tpr_err(\"Kprobe event is not supported.\\n\");",
            "\treturn -ENOTSUPP;",
            "}"
          ],
          "function_name": "trace_boot_set_instance_options, trace_boot_enable_events, trace_boot_add_kprobe_event, trace_boot_add_kprobe_event",
          "description": "实现初始化跟踪实例选项设置、事件启用、kprobe事件添加等功能，包含重复定义的函数导致潜在冲突。",
          "similarity": 0.39029228687286377
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 297,
          "end_line": 427,
          "content": [
            "static int __init",
            "trace_boot_hist_add_handlers(struct xbc_node *hnode, char **bufp,",
            "\t\t\t     char *end, const char *param)",
            "{",
            "\tstruct xbc_node *node;",
            "\tconst char *p, *handler;",
            "\tint ret = 0;",
            "",
            "\thandler = xbc_node_get_data(hnode);",
            "",
            "\txbc_node_for_each_subkey(hnode, node) {",
            "\t\tp = xbc_node_get_data(node);",
            "\t\tif (!isdigit(p[0]))",
            "\t\t\tcontinue;",
            "\t\t/* All digit started node should be instances. */",
            "\t\tret = trace_boot_hist_add_one_handler(node, bufp, end, handler, param);",
            "\t\tif (ret < 0)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\tif (xbc_node_find_subkey(hnode, param))",
            "\t\tret = trace_boot_hist_add_one_handler(hnode, bufp, end, handler, param);",
            "",
            "\treturn ret;",
            "}",
            "static int __init",
            "trace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)",
            "{",
            "\tstruct xbc_node *node, *knode;",
            "\tchar *end = buf + size;",
            "\tconst char *p;",
            "\tint ret = 0;",
            "",
            "\tappend_printf(&buf, end, \"hist\");",
            "",
            "\tret = trace_boot_hist_add_array(hnode, &buf, end, \"keys\");",
            "\tif (ret < 0) {",
            "\t\tif (ret == -ENOENT)",
            "\t\t\tpr_err(\"hist requires keys.\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tret = trace_boot_hist_add_array(hnode, &buf, end, \"values\");",
            "\tif (ret == -EINVAL)",
            "\t\treturn ret;",
            "\tret = trace_boot_hist_add_array(hnode, &buf, end, \"sort\");",
            "\tif (ret == -EINVAL)",
            "\t\treturn ret;",
            "",
            "\tp = xbc_node_find_value(hnode, \"size\", NULL);",
            "\tif (p)",
            "\t\tappend_printf(&buf, end, \":size=%s\", p);",
            "",
            "\tp = xbc_node_find_value(hnode, \"name\", NULL);",
            "\tif (p)",
            "\t\tappend_printf(&buf, end, \":name=%s\", p);",
            "",
            "\tnode = xbc_node_find_subkey(hnode, \"var\");",
            "\tif (node) {",
            "\t\txbc_node_for_each_key_value(node, knode, p) {",
            "\t\t\t/* Expression must not include spaces. */",
            "\t\t\tappend_printf(&buf, end, \":%s=\",",
            "\t\t\t\t      xbc_node_get_data(knode));",
            "\t\t\tappend_str_nospace(&buf, end, p);",
            "\t\t}",
            "\t}",
            "",
            "\t/* Histogram control attributes (mutual exclusive) */",
            "\tif (xbc_node_find_value(hnode, \"pause\", NULL))",
            "\t\tappend_printf(&buf, end, \":pause\");",
            "\telse if (xbc_node_find_value(hnode, \"continue\", NULL))",
            "\t\tappend_printf(&buf, end, \":continue\");",
            "\telse if (xbc_node_find_value(hnode, \"clear\", NULL))",
            "\t\tappend_printf(&buf, end, \":clear\");",
            "",
            "\t/* Histogram handler and actions */",
            "\tnode = xbc_node_find_subkey(hnode, \"onmax\");",
            "\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)",
            "\t\treturn -EINVAL;",
            "\tnode = xbc_node_find_subkey(hnode, \"onchange\");",
            "\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)",
            "\t\treturn -EINVAL;",
            "\tnode = xbc_node_find_subkey(hnode, \"onmatch\");",
            "\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"event\") < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tp = xbc_node_find_value(hnode, \"filter\", NULL);",
            "\tif (p)",
            "\t\tappend_printf(&buf, end, \" if %s\", p);",
            "",
            "\tif (buf == end) {",
            "\t\tpr_err(\"hist exceeds the max command length.\\n\");",
            "\t\treturn -E2BIG;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void __init",
            "trace_boot_init_histograms(struct trace_event_file *file,",
            "\t\t\t   struct xbc_node *hnode, char *buf, size_t size)",
            "{",
            "\tstruct xbc_node *node;",
            "\tconst char *p;",
            "\tchar *tmp;",
            "",
            "\txbc_node_for_each_subkey(hnode, node) {",
            "\t\tp = xbc_node_get_data(node);",
            "\t\tif (!isdigit(p[0]))",
            "\t\t\tcontinue;",
            "\t\t/* All digit started node should be instances. */",
            "\t\tif (trace_boot_compose_hist_cmd(node, buf, size) == 0) {",
            "\t\t\ttmp = kstrdup(buf, GFP_KERNEL);",
            "\t\t\tif (!tmp)",
            "\t\t\t\treturn;",
            "\t\t\tif (trigger_process_regex(file, buf) < 0)",
            "\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);",
            "\t\t\tkfree(tmp);",
            "\t\t}",
            "\t}",
            "",
            "\tif (xbc_node_find_subkey(hnode, \"keys\")) {",
            "\t\tif (trace_boot_compose_hist_cmd(hnode, buf, size) == 0) {",
            "\t\t\ttmp = kstrdup(buf, GFP_KERNEL);",
            "\t\t\tif (!tmp)",
            "\t\t\t\treturn;",
            "\t\t\tif (trigger_process_regex(file, buf) < 0)",
            "\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);",
            "\t\t\tkfree(tmp);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "trace_boot_hist_add_handlers, trace_boot_compose_hist_cmd, trace_boot_init_histograms",
          "description": "构建直方图控制命令字符串，组合关键字、值、排序等参数，并处理事件触发动作配置。",
          "similarity": 0.38781556487083435
        }
      ]
    }
  ]
}