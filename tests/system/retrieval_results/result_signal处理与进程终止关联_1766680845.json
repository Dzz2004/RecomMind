{
  "query": "signal处理与进程终止关联",
  "timestamp": "2025-12-26 00:40:45",
  "retrieved_files": [
    {
      "source_file": "kernel/signal.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:24:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `signal.c`\n\n---\n\n# signal.c 技术文档\n\n## 1. 文件概述\n\n`signal.c` 是 Linux 内核中信号子系统的核心实现文件，负责管理进程间信号的发送、接收、排队、处理以及相关状态的维护。该文件实现了 POSIX 信号语义，包括标准信号和实时信号（通过 sigqueue），并处理信号的阻塞、忽略、默认行为及用户自定义处理函数的调用逻辑。它还集成了对 ptrace 调试、作业控制（job control）、冻结（freezer）和 cgroup 等子系统的支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `sigqueue_cachep`：用于分配 `sigqueue` 结构的 slab 缓存，支持可靠信号排队。\n- `task_struct::pending`：每个任务私有的挂起信号队列。\n- `signal_struct::shared_pending`：线程组共享的挂起信号队列。\n- `task_struct::blocked` / `real_blocked`：信号阻塞掩码。\n- `task_struct::jobctl`：作业控制相关状态位（如停止、陷阱等）。\n\n### 主要函数\n- `sig_handler()`：获取指定信号的处理函数指针。\n- `sig_handler_ignored()`：判断信号是否被显式或隐式忽略。\n- `sig_task_ignored()` / `sig_ignored()`：判断任务是否忽略某信号（考虑 init、kthread、ptrace 等特殊情况）。\n- `has_pending_signals()`：检查在给定阻塞掩码下是否存在可投递的挂起信号。\n- `recalc_sigpending_tsk()` / `recalc_sigpending()` / `recalc_sigpending_and_wake()`：重新计算并设置 `TIF_SIGPENDING` 线程标志。\n- `next_signal()`：从挂起信号中选择下一个应被处理的信号，优先处理同步信号（如 SIGSEGV、SIGILL 等）。\n- `task_set_jobctl_pending()`：设置任务的作业控制挂起状态（如停止请求）。\n- `task_clear_jobctl_trapping()`：清除作业控制陷阱状态并唤醒跟踪者（ptracer）。\n- `print_dropped_signal()`：当日志开启且达到 `RLIMIT_SIGPENDING` 限制时，记录被丢弃的信号。\n\n## 3. 关键实现\n\n### 信号忽略逻辑\n信号是否被忽略不仅取决于处理函数是否为 `SIG_IGN` 或默认且内核定义为可忽略（`sig_kernel_ignore()`），还需考虑：\n- 全局 init 进程不能接收 `SIGKILL`/`SIGSTOP`。\n- `SIGNAL_UNKILLABLE` 任务对默认处理的内核信号有特殊豁免。\n- 内核线程（`PF_KTHREAD`）仅响应强制（`force=true`）的内核信号。\n- 若任务被 ptrace 跟踪，除 `SIGKILL` 外，即使信号被忽略也需通知调试器。\n\n### 挂起信号检测优化\n`has_pending_signals()` 使用位运算高效检查 `signal & ~blocked` 是否非零，并针对 `_NSIG_WORDS` 的常见值（1、2、4）进行展开优化，避免循环开销。\n\n### 信号选择策略\n`next_signal()` 优先处理同步信号（定义在 `SYNCHRONOUS_MASK` 中），确保如段错误、非法指令等异常能被及时响应，符合 POSIX 对同步信号“立即投递”的要求。\n\n### TIF_SIGPENDING 标志管理\n- `recalc_sigpending_tsk()` 综合检查私有/共享挂起信号、作业控制状态和 cgroup 冻结状态，决定是否设置 `TIF_SIGPENDING`。\n- 为避免竞态，**不清除**该标志，仅由明确知道安全的调用者（如 `recalc_sigpending()`）在适当上下文中清除。\n- `recalc_sigpending_and_wake()` 在设置标志后主动唤醒任务，确保其能及时处理信号。\n\n### 作业控制集成\n通过 `jobctl` 字段和 `JOBCTL_*` 位掩码，支持 ptrace 和作业控制的复杂状态机（如停止、陷阱、信号消费），并在 `siglock` 保护下安全更新。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`thread_info` 标志（如 `TIF_SIGPENDING`）、`PF_EXITING` 等。\n- **内存管理**：使用 slab 分配器（`kmem_cache`）管理 `sigqueue`。\n- **进程管理**：与 `fork`/`exec`/`exit` 流程交互（如 `calculate_sigpending` 在 fork 后调用）。\n- **ptrace**：通过 `ptrace` 字段和 `JOBCTL_TRAPPING` 支持调试器信号拦截。\n- **cgroup/freezer**：检查 `cgroup_task_frozen()` 状态影响信号挂起判断。\n- **安全模块**：通过 `security_task_kill()` 等钩子（虽未在片段中体现，但完整文件包含）。\n- **tracepoint**：定义 `trace/events/signal.h` 中的跟踪点用于调试。\n- **架构相关代码**：依赖 `asm/siginfo.h`、`uaccess.h` 等处理用户空间信号帧。\n\n## 5. 使用场景\n\n- **系统调用处理**：`kill()`、`tkill()`、`rt_sigqueueinfo()` 等信号发送系统调用最终调用本文件逻辑。\n- **异常处理**：CPU 异常（如页错误、除零）触发同步信号（SIGSEGV、SIGFPE），由本文件选择并准备投递。\n- **进程生命周期管理**：在 `do_exit()`、`flush_old_exec()` 等路径中清理或重置信号状态。\n- **调试器支持**：ptrace 在注入信号或单步执行时依赖作业控制状态和信号忽略逻辑。\n- **资源限制**：当信号队列达到 `RLIMIT_SIGPENDING` 限制时，调用 `print_dropped_signal()` 记录丢弃事件。\n- **冻结/恢复**：cgroup freezer 或 suspend 流程通过 `cgroup_task_frozen()` 影响信号挂起状态，确保任务在冻结期间不处理信号。",
      "similarity": 0.6399643421173096,
      "chunks": [
        {
          "chunk_id": 20,
          "file_path": "kernel/signal.c",
          "start_line": 3086,
          "end_line": 3191,
          "content": [
            "long do_no_restart_syscall(struct restart_block *param)",
            "{",
            "\treturn -EINTR;",
            "}",
            "static void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)",
            "{",
            "\tif (task_sigpending(tsk) && !thread_group_empty(tsk)) {",
            "\t\tsigset_t newblocked;",
            "\t\t/* A set of now blocked but previously unblocked signals. */",
            "\t\tsigandnsets(&newblocked, newset, &current->blocked);",
            "\t\tretarget_shared_pending(tsk, &newblocked);",
            "\t}",
            "\ttsk->blocked = *newset;",
            "\trecalc_sigpending();",
            "}",
            "void set_current_blocked(sigset_t *newset)",
            "{",
            "\tsigdelsetmask(newset, sigmask(SIGKILL) | sigmask(SIGSTOP));",
            "\t__set_current_blocked(newset);",
            "}",
            "void __set_current_blocked(const sigset_t *newset)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\t/*",
            "\t * In case the signal mask hasn't changed, there is nothing we need",
            "\t * to do. The current->blocked shouldn't be modified by other task.",
            "\t */",
            "\tif (sigequalsets(&tsk->blocked, newset))",
            "\t\treturn;",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t__set_task_blocked(tsk, newset);",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "}",
            "int sigprocmask(int how, sigset_t *set, sigset_t *oldset)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tsigset_t newset;",
            "",
            "\t/* Lockless, only current can change ->blocked, never from irq */",
            "\tif (oldset)",
            "\t\t*oldset = tsk->blocked;",
            "",
            "\tswitch (how) {",
            "\tcase SIG_BLOCK:",
            "\t\tsigorsets(&newset, &tsk->blocked, set);",
            "\t\tbreak;",
            "\tcase SIG_UNBLOCK:",
            "\t\tsigandnsets(&newset, &tsk->blocked, set);",
            "\t\tbreak;",
            "\tcase SIG_SETMASK:",
            "\t\tnewset = *set;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t__set_current_blocked(&newset);",
            "\treturn 0;",
            "}",
            "int set_user_sigmask(const sigset_t __user *umask, size_t sigsetsize)",
            "{",
            "\tsigset_t kmask;",
            "",
            "\tif (!umask)",
            "\t\treturn 0;",
            "\tif (sigsetsize != sizeof(sigset_t))",
            "\t\treturn -EINVAL;",
            "\tif (copy_from_user(&kmask, umask, sizeof(sigset_t)))",
            "\t\treturn -EFAULT;",
            "",
            "\tset_restore_sigmask();",
            "\tcurrent->saved_sigmask = current->blocked;",
            "\tset_current_blocked(&kmask);",
            "",
            "\treturn 0;",
            "}",
            "int set_compat_user_sigmask(const compat_sigset_t __user *umask,",
            "\t\t\t    size_t sigsetsize)",
            "{",
            "\tsigset_t kmask;",
            "",
            "\tif (!umask)",
            "\t\treturn 0;",
            "\tif (sigsetsize != sizeof(compat_sigset_t))",
            "\t\treturn -EINVAL;",
            "\tif (get_compat_sigset(&kmask, umask))",
            "\t\treturn -EFAULT;",
            "",
            "\tset_restore_sigmask();",
            "\tcurrent->saved_sigmask = current->blocked;",
            "\tset_current_blocked(&kmask);",
            "",
            "\treturn 0;",
            "}",
            "static void do_sigpending(sigset_t *set)",
            "{",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tsigorsets(set, &current->pending.signal,",
            "\t\t  &current->signal->shared_pending.signal);",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\t/* Outside the lock because only this thread touches it.  */",
            "\tsigandsets(set, &current->blocked, set);",
            "}"
          ],
          "function_name": "do_no_restart_syscall, __set_task_blocked, set_current_blocked, __set_current_blocked, sigprocmask, set_user_sigmask, set_compat_user_sigmask, do_sigpending",
          "description": "定义并实现信号处理相关函数，用于管理进程信号屏蔽集，包括更新阻塞信号集、处理信号掩码变更、计算待处理信号等操作。",
          "similarity": 0.6694925427436829
        },
        {
          "chunk_id": 19,
          "file_path": "kernel/signal.c",
          "start_line": 2961,
          "end_line": 3063,
          "content": [
            "static void signal_delivered(struct ksignal *ksig, int stepping)",
            "{",
            "\tsigset_t blocked;",
            "",
            "\t/* A signal was successfully delivered, and the",
            "\t   saved sigmask was stored on the signal frame,",
            "\t   and will be restored by sigreturn.  So we can",
            "\t   simply clear the restore sigmask flag.  */",
            "\tclear_restore_sigmask();",
            "",
            "\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);",
            "\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))",
            "\t\tsigaddset(&blocked, ksig->sig);",
            "\tset_current_blocked(&blocked);",
            "\tif (current->sas_ss_flags & SS_AUTODISARM)",
            "\t\tsas_ss_reset(current);",
            "\tif (stepping)",
            "\t\tptrace_notify(SIGTRAP, 0);",
            "}",
            "void signal_setup_done(int failed, struct ksignal *ksig, int stepping)",
            "{",
            "\tif (failed)",
            "\t\tforce_sigsegv(ksig->sig);",
            "\telse",
            "\t\tsignal_delivered(ksig, stepping);",
            "}",
            "static void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)",
            "{",
            "\tsigset_t retarget;",
            "\tstruct task_struct *t;",
            "",
            "\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);",
            "\tif (sigisemptyset(&retarget))",
            "\t\treturn;",
            "",
            "\tt = tsk;",
            "\twhile_each_thread(tsk, t) {",
            "\t\tif (t->flags & PF_EXITING)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (!has_pending_signals(&retarget, &t->blocked))",
            "\t\t\tcontinue;",
            "\t\t/* Remove the signals this thread can handle. */",
            "\t\tsigandsets(&retarget, &retarget, &t->blocked);",
            "",
            "\t\tif (!task_sigpending(t))",
            "\t\t\tsignal_wake_up(t, 0);",
            "",
            "\t\tif (sigisemptyset(&retarget))",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "void exit_signals(struct task_struct *tsk)",
            "{",
            "\tint group_stop = 0;",
            "\tsigset_t unblocked;",
            "",
            "\t/*",
            "\t * @tsk is about to have PF_EXITING set - lock out users which",
            "\t * expect stable threadgroup.",
            "\t */",
            "\tcgroup_threadgroup_change_begin(tsk);",
            "",
            "\tif (thread_group_empty(tsk) || (tsk->signal->flags & SIGNAL_GROUP_EXIT)) {",
            "\t\tsched_mm_cid_exit_signals(tsk);",
            "\t\ttsk->flags |= PF_EXITING;",
            "\t\tcgroup_threadgroup_change_end(tsk);",
            "\t\treturn;",
            "\t}",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t/*",
            "\t * From now this task is not visible for group-wide signals,",
            "\t * see wants_signal(), do_signal_stop().",
            "\t */",
            "\tsched_mm_cid_exit_signals(tsk);",
            "\ttsk->flags |= PF_EXITING;",
            "",
            "\tcgroup_threadgroup_change_end(tsk);",
            "",
            "\tif (!task_sigpending(tsk))",
            "\t\tgoto out;",
            "",
            "\tunblocked = tsk->blocked;",
            "\tsignotset(&unblocked);",
            "\tretarget_shared_pending(tsk, &unblocked);",
            "",
            "\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&",
            "\t    task_participate_group_stop(tsk))",
            "\t\tgroup_stop = CLD_STOPPED;",
            "out:",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\t/*",
            "\t * If group stop has completed, deliver the notification.  This",
            "\t * should always go to the real parent of the group leader.",
            "\t */",
            "\tif (unlikely(group_stop)) {",
            "\t\tread_lock(&tasklist_lock);",
            "\t\tdo_notify_parent_cldstop(tsk, false, group_stop);",
            "\t\tread_unlock(&tasklist_lock);",
            "\t}",
            "}"
          ],
          "function_name": "signal_delivered, signal_setup_done, retarget_shared_pending, exit_signals",
          "description": "signal_delivered 完成信号送达后的阻塞集更新；signal_setup_done 根据信号处理结果设置异常；retarget_shared_pending 重新分配共享挂起信号；exit_signals 处理进程退出时的信号清理和组停止通知",
          "similarity": 0.6604886651039124
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/signal.c",
          "start_line": 2054,
          "end_line": 2161,
          "content": [
            "void do_notify_pidfd(struct task_struct *task)",
            "{",
            "\tstruct pid *pid;",
            "",
            "\tWARN_ON(task->exit_state == 0);",
            "\tpid = task_pid(task);",
            "\twake_up_all(&pid->wait_pidfd);",
            "}",
            "bool do_notify_parent(struct task_struct *tsk, int sig)",
            "{",
            "\tstruct kernel_siginfo info;",
            "\tunsigned long flags;",
            "\tstruct sighand_struct *psig;",
            "\tbool autoreap = false;",
            "\tu64 utime, stime;",
            "",
            "\tWARN_ON_ONCE(sig == -1);",
            "",
            "\t/* do_notify_parent_cldstop should have been called instead.  */",
            "\tWARN_ON_ONCE(task_is_stopped_or_traced(tsk));",
            "",
            "\tWARN_ON_ONCE(!tsk->ptrace &&",
            "\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));",
            "\t/*",
            "\t * tsk is a group leader and has no threads, wake up the",
            "\t * non-PIDFD_THREAD waiters.",
            "\t */",
            "\tif (thread_group_empty(tsk))",
            "\t\tdo_notify_pidfd(tsk);",
            "",
            "\tif (sig != SIGCHLD) {",
            "\t\t/*",
            "\t\t * This is only possible if parent == real_parent.",
            "\t\t * Check if it has changed security domain.",
            "\t\t */",
            "\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))",
            "\t\t\tsig = SIGCHLD;",
            "\t}",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\t/*",
            "\t * We are under tasklist_lock here so our parent is tied to",
            "\t * us and cannot change.",
            "\t *",
            "\t * task_active_pid_ns will always return the same pid namespace",
            "\t * until a task passes through release_task.",
            "\t *",
            "\t * write_lock() currently calls preempt_disable() which is the",
            "\t * same as rcu_read_lock(), but according to Oleg, this is not",
            "\t * correct to rely on this",
            "\t */",
            "\trcu_read_lock();",
            "\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));",
            "\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),",
            "\t\t\t\t       task_uid(tsk));",
            "\trcu_read_unlock();",
            "",
            "\ttask_cputime(tsk, &utime, &stime);",
            "\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);",
            "\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);",
            "",
            "\tinfo.si_status = tsk->exit_code & 0x7f;",
            "\tif (tsk->exit_code & 0x80)",
            "\t\tinfo.si_code = CLD_DUMPED;",
            "\telse if (tsk->exit_code & 0x7f)",
            "\t\tinfo.si_code = CLD_KILLED;",
            "\telse {",
            "\t\tinfo.si_code = CLD_EXITED;",
            "\t\tinfo.si_status = tsk->exit_code >> 8;",
            "\t}",
            "",
            "\tpsig = tsk->parent->sighand;",
            "\tspin_lock_irqsave(&psig->siglock, flags);",
            "\tif (!tsk->ptrace && sig == SIGCHLD &&",
            "\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||",
            "\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {",
            "\t\t/*",
            "\t\t * We are exiting and our parent doesn't care.  POSIX.1",
            "\t\t * defines special semantics for setting SIGCHLD to SIG_IGN",
            "\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped",
            "\t\t * automatically and not left for our parent's wait4 call.",
            "\t\t * Rather than having the parent do it as a magic kind of",
            "\t\t * signal handler, we just set this to tell do_exit that we",
            "\t\t * can be cleaned up without becoming a zombie.  Note that",
            "\t\t * we still call __wake_up_parent in this case, because a",
            "\t\t * blocked sys_wait4 might now return -ECHILD.",
            "\t\t *",
            "\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT",
            "\t\t * is implementation-defined: we do (if you don't want",
            "\t\t * it, just use SIG_IGN instead).",
            "\t\t */",
            "\t\tautoreap = true;",
            "\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)",
            "\t\t\tsig = 0;",
            "\t}",
            "\t/*",
            "\t * Send with __send_signal as si_pid and si_uid are in the",
            "\t * parent's namespaces.",
            "\t */",
            "\tif (valid_signal(sig) && sig)",
            "\t\t__send_signal_locked(sig, &info, tsk->parent, PIDTYPE_TGID, false);",
            "\t__wake_up_parent(tsk, tsk->parent);",
            "\tspin_unlock_irqrestore(&psig->siglock, flags);",
            "",
            "\treturn autoreap;",
            "}"
          ],
          "function_name": "do_notify_pidfd, do_notify_parent",
          "description": "处理进程终止通知机制，do_notify_pidfd唤醒等待PIDFD的进程，do_notify_parent构建SIGCHLD信号信息并发送。包含对SA_NOCLDWAIT标志的处理、父进程信号屏蔽检查，以及僵尸进程自动回收逻辑。",
          "similarity": 0.6526732444763184
        },
        {
          "chunk_id": 24,
          "file_path": "kernel/signal.c",
          "start_line": 3998,
          "end_line": 4145,
          "content": [
            "static int",
            "do_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)",
            "{",
            "\tstruct task_struct *p;",
            "\tint error = -ESRCH;",
            "",
            "\trcu_read_lock();",
            "\tp = find_task_by_vpid(pid);",
            "\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {",
            "\t\terror = check_kill_permission(sig, info, p);",
            "\t\t/*",
            "\t\t * The null signal is a permissions and process existence",
            "\t\t * probe.  No signal is actually delivered.",
            "\t\t */",
            "\t\tif (!error && sig) {",
            "\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);",
            "\t\t\t/*",
            "\t\t\t * If lock_task_sighand() failed we pretend the task",
            "\t\t\t * dies after receiving the signal. The window is tiny,",
            "\t\t\t * and the signal is private anyway.",
            "\t\t\t */",
            "\t\t\tif (unlikely(error == -ESRCH))",
            "\t\t\t\terror = 0;",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn error;",
            "}",
            "static int do_tkill(pid_t tgid, pid_t pid, int sig)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tprepare_kill_siginfo(sig, &info, PIDTYPE_PID);",
            "",
            "\treturn do_send_specific(tgid, pid, sig, &info);",
            "}",
            "static int do_rt_sigqueueinfo(pid_t pid, int sig, kernel_siginfo_t *info)",
            "{",
            "\t/* Not even root can pretend to send signals from the kernel.",
            "\t * Nor can they impersonate a kill()/tgkill(), which adds source info.",
            "\t */",
            "\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&",
            "\t    (task_pid_vnr(current) != pid))",
            "\t\treturn -EPERM;",
            "",
            "\t/* POSIX.1b doesn't mention process groups.  */",
            "\treturn kill_proc_info(sig, info, pid);",
            "}",
            "static int do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, kernel_siginfo_t *info)",
            "{",
            "\t/* This is only valid for single tasks */",
            "\tif (pid <= 0 || tgid <= 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Not even root can pretend to send signals from the kernel.",
            "\t * Nor can they impersonate a kill()/tgkill(), which adds source info.",
            "\t */",
            "\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&",
            "\t    (task_pid_vnr(current) != pid))",
            "\t\treturn -EPERM;",
            "",
            "\treturn do_send_specific(tgid, pid, sig, info);",
            "}",
            "void kernel_sigaction(int sig, __sighandler_t action)",
            "{",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;",
            "\tif (action == SIG_IGN) {",
            "\t\tsigset_t mask;",
            "",
            "\t\tsigemptyset(&mask);",
            "\t\tsigaddset(&mask, sig);",
            "",
            "\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);",
            "\t\tflush_sigqueue_mask(&mask, &current->pending);",
            "\t\trecalc_sigpending();",
            "\t}",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "}",
            "void __weak sigaction_compat_abi(struct k_sigaction *act,",
            "\t\tstruct k_sigaction *oact)",
            "{",
            "}",
            "int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)",
            "{",
            "\tstruct task_struct *p = current, *t;",
            "\tstruct k_sigaction *k;",
            "\tsigset_t mask;",
            "",
            "\tif (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))",
            "\t\treturn -EINVAL;",
            "",
            "\tk = &p->sighand->action[sig-1];",
            "",
            "\tspin_lock_irq(&p->sighand->siglock);",
            "\tif (k->sa.sa_flags & SA_IMMUTABLE) {",
            "\t\tspin_unlock_irq(&p->sighand->siglock);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\tif (oact)",
            "\t\t*oact = *k;",
            "",
            "\t/*",
            "\t * Make sure that we never accidentally claim to support SA_UNSUPPORTED,",
            "\t * e.g. by having an architecture use the bit in their uapi.",
            "\t */",
            "\tBUILD_BUG_ON(UAPI_SA_FLAGS & SA_UNSUPPORTED);",
            "",
            "\t/*",
            "\t * Clear unknown flag bits in order to allow userspace to detect missing",
            "\t * support for flag bits and to allow the kernel to use non-uapi bits",
            "\t * internally.",
            "\t */",
            "\tif (act)",
            "\t\tact->sa.sa_flags &= UAPI_SA_FLAGS;",
            "\tif (oact)",
            "\t\toact->sa.sa_flags &= UAPI_SA_FLAGS;",
            "",
            "\tsigaction_compat_abi(act, oact);",
            "",
            "\tif (act) {",
            "\t\tsigdelsetmask(&act->sa.sa_mask,",
            "\t\t\t      sigmask(SIGKILL) | sigmask(SIGSTOP));",
            "\t\t*k = *act;",
            "\t\t/*",
            "\t\t * POSIX 3.3.1.3:",
            "\t\t *  \"Setting a signal action to SIG_IGN for a signal that is",
            "\t\t *   pending shall cause the pending signal to be discarded,",
            "\t\t *   whether or not it is blocked.\"",
            "\t\t *",
            "\t\t *  \"Setting a signal action to SIG_DFL for a signal that is",
            "\t\t *   pending and whose default action is to ignore the signal",
            "\t\t *   (for example, SIGCHLD), shall cause the pending signal to",
            "\t\t *   be discarded, whether or not it is blocked\"",
            "\t\t */",
            "\t\tif (sig_handler_ignored(sig_handler(p, sig), sig)) {",
            "\t\t\tsigemptyset(&mask);",
            "\t\t\tsigaddset(&mask, sig);",
            "\t\t\tflush_sigqueue_mask(&mask, &p->signal->shared_pending);",
            "\t\t\tfor_each_thread(p, t)",
            "\t\t\t\tflush_sigqueue_mask(&mask, &t->pending);",
            "\t\t}",
            "\t}",
            "",
            "\tspin_unlock_irq(&p->sighand->siglock);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "do_send_specific, do_tkill, do_rt_sigqueueinfo, do_rt_tgsigqueueinfo, kernel_sigaction, sigaction_compat_abi, do_sigaction",
          "description": "处理信号动作设置与定向信号发送，包含信号处理函数注册、信号屏蔽更新及跨进程信号注入等关键控制流程。",
          "similarity": 0.6371476650238037
        },
        {
          "chunk_id": 18,
          "file_path": "kernel/signal.c",
          "start_line": 2706,
          "end_line": 2949,
          "content": [
            "bool get_signal(struct ksignal *ksig)",
            "{",
            "\tstruct sighand_struct *sighand = current->sighand;",
            "\tstruct signal_struct *signal = current->signal;",
            "\tint signr;",
            "",
            "\tclear_notify_signal();",
            "\tif (unlikely(task_work_pending(current)))",
            "\t\ttask_work_run();",
            "",
            "\tif (!task_sigpending(current))",
            "\t\treturn false;",
            "",
            "\tif (unlikely(uprobe_deny_signal()))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Do this once, we can't return to user-mode if freezing() == T.",
            "\t * do_signal_stop() and ptrace_stop() do freezable_schedule() and",
            "\t * thus do not need another check after return.",
            "\t */",
            "\ttry_to_freeze();",
            "",
            "relock:",
            "\tspin_lock_irq(&sighand->siglock);",
            "",
            "\t/*",
            "\t * Every stopped thread goes here after wakeup. Check to see if",
            "\t * we should notify the parent, prepare_signal(SIGCONT) encodes",
            "\t * the CLD_ si_code into SIGNAL_CLD_MASK bits.",
            "\t */",
            "\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {",
            "\t\tint why;",
            "",
            "\t\tif (signal->flags & SIGNAL_CLD_CONTINUED)",
            "\t\t\twhy = CLD_CONTINUED;",
            "\t\telse",
            "\t\t\twhy = CLD_STOPPED;",
            "",
            "\t\tsignal->flags &= ~SIGNAL_CLD_MASK;",
            "",
            "\t\tspin_unlock_irq(&sighand->siglock);",
            "",
            "\t\t/*",
            "\t\t * Notify the parent that we're continuing.  This event is",
            "\t\t * always per-process and doesn't make whole lot of sense",
            "\t\t * for ptracers, who shouldn't consume the state via",
            "\t\t * wait(2) either, but, for backward compatibility, notify",
            "\t\t * the ptracer of the group leader too unless it's gonna be",
            "\t\t * a duplicate.",
            "\t\t */",
            "\t\tread_lock(&tasklist_lock);",
            "\t\tdo_notify_parent_cldstop(current, false, why);",
            "",
            "\t\tif (ptrace_reparented(current->group_leader))",
            "\t\t\tdo_notify_parent_cldstop(current->group_leader,",
            "\t\t\t\t\t\ttrue, why);",
            "\t\tread_unlock(&tasklist_lock);",
            "",
            "\t\tgoto relock;",
            "\t}",
            "",
            "\tfor (;;) {",
            "\t\tstruct k_sigaction *ka;",
            "\t\tenum pid_type type;",
            "",
            "\t\t/* Has this task already been marked for death? */",
            "\t\tif ((signal->flags & SIGNAL_GROUP_EXIT) ||",
            "\t\t     signal->group_exec_task) {",
            "\t\t\tclear_siginfo(&ksig->info);",
            "\t\t\tksig->info.si_signo = signr = SIGKILL;",
            "\t\t\tsigdelset(&current->pending.signal, SIGKILL);",
            "\t\t\ttrace_signal_deliver(SIGKILL, SEND_SIG_NOINFO,",
            "\t\t\t\t&sighand->action[SIGKILL - 1]);",
            "\t\t\trecalc_sigpending();",
            "\t\t\tgoto fatal;",
            "\t\t}",
            "",
            "\t\tif (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&",
            "\t\t    do_signal_stop(0))",
            "\t\t\tgoto relock;",
            "",
            "\t\tif (unlikely(current->jobctl &",
            "\t\t\t     (JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE))) {",
            "\t\t\tif (current->jobctl & JOBCTL_TRAP_MASK) {",
            "\t\t\t\tdo_jobctl_trap();",
            "\t\t\t\tspin_unlock_irq(&sighand->siglock);",
            "\t\t\t} else if (current->jobctl & JOBCTL_TRAP_FREEZE)",
            "\t\t\t\tdo_freezer_trap();",
            "",
            "\t\t\tgoto relock;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If the task is leaving the frozen state, let's update",
            "\t\t * cgroup counters and reset the frozen bit.",
            "\t\t */",
            "\t\tif (unlikely(cgroup_task_frozen(current))) {",
            "\t\t\tspin_unlock_irq(&sighand->siglock);",
            "\t\t\tcgroup_leave_frozen(false);",
            "\t\t\tgoto relock;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Signals generated by the execution of an instruction",
            "\t\t * need to be delivered before any other pending signals",
            "\t\t * so that the instruction pointer in the signal stack",
            "\t\t * frame points to the faulting instruction.",
            "\t\t */",
            "\t\ttype = PIDTYPE_PID;",
            "\t\tsignr = dequeue_synchronous_signal(&ksig->info);",
            "\t\tif (!signr)",
            "\t\t\tsignr = dequeue_signal(current, &current->blocked,",
            "\t\t\t\t\t       &ksig->info, &type);",
            "",
            "\t\tif (!signr)",
            "\t\t\tbreak; /* will return 0 */",
            "",
            "\t\tif (unlikely(current->ptrace) && (signr != SIGKILL) &&",
            "\t\t    !(sighand->action[signr -1].sa.sa_flags & SA_IMMUTABLE)) {",
            "\t\t\tsignr = ptrace_signal(signr, &ksig->info, type);",
            "\t\t\tif (!signr)",
            "\t\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tka = &sighand->action[signr-1];",
            "",
            "\t\t/* Trace actually delivered signals. */",
            "\t\ttrace_signal_deliver(signr, &ksig->info, ka);",
            "",
            "\t\tif (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */",
            "\t\t\tcontinue;",
            "\t\tif (ka->sa.sa_handler != SIG_DFL) {",
            "\t\t\t/* Run the handler.  */",
            "\t\t\tksig->ka = *ka;",
            "",
            "\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)",
            "\t\t\t\tka->sa.sa_handler = SIG_DFL;",
            "",
            "\t\t\tbreak; /* will return non-zero \"signr\" value */",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Now we are doing the default action for this signal.",
            "\t\t */",
            "\t\tif (sig_kernel_ignore(signr)) /* Default is nothing. */",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Global init gets no signals it doesn't want.",
            "\t\t * Container-init gets no signals it doesn't want from same",
            "\t\t * container.",
            "\t\t *",
            "\t\t * Note that if global/container-init sees a sig_kernel_only()",
            "\t\t * signal here, the signal must have been generated internally",
            "\t\t * or must have come from an ancestor namespace. In either",
            "\t\t * case, the signal cannot be dropped.",
            "\t\t */",
            "\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&",
            "\t\t\t\t!sig_kernel_only(signr))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (sig_kernel_stop(signr)) {",
            "\t\t\t/*",
            "\t\t\t * The default action is to stop all threads in",
            "\t\t\t * the thread group.  The job control signals",
            "\t\t\t * do nothing in an orphaned pgrp, but SIGSTOP",
            "\t\t\t * always works.  Note that siglock needs to be",
            "\t\t\t * dropped during the call to is_orphaned_pgrp()",
            "\t\t\t * because of lock ordering with tasklist_lock.",
            "\t\t\t * This allows an intervening SIGCONT to be posted.",
            "\t\t\t * We need to check for that and bail out if necessary.",
            "\t\t\t */",
            "\t\t\tif (signr != SIGSTOP) {",
            "\t\t\t\tspin_unlock_irq(&sighand->siglock);",
            "",
            "\t\t\t\t/* signals can be posted during this window */",
            "",
            "\t\t\t\tif (is_current_pgrp_orphaned())",
            "\t\t\t\t\tgoto relock;",
            "",
            "\t\t\t\tspin_lock_irq(&sighand->siglock);",
            "\t\t\t}",
            "",
            "\t\t\tif (likely(do_signal_stop(ksig->info.si_signo))) {",
            "\t\t\t\t/* It released the siglock.  */",
            "\t\t\t\tgoto relock;",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * We didn't actually stop, due to a race",
            "\t\t\t * with SIGCONT or something like that.",
            "\t\t\t */",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\tfatal:",
            "\t\tspin_unlock_irq(&sighand->siglock);",
            "\t\tif (unlikely(cgroup_task_frozen(current)))",
            "\t\t\tcgroup_leave_frozen(true);",
            "",
            "\t\t/*",
            "\t\t * Anything else is fatal, maybe with a core dump.",
            "\t\t */",
            "\t\tcurrent->flags |= PF_SIGNALED;",
            "",
            "\t\tif (sig_kernel_coredump(signr)) {",
            "\t\t\tif (print_fatal_signals)",
            "\t\t\t\tprint_fatal_signal(ksig->info.si_signo);",
            "\t\t\tproc_coredump_connector(current);",
            "\t\t\t/*",
            "\t\t\t * If it was able to dump core, this kills all",
            "\t\t\t * other threads in the group and synchronizes with",
            "\t\t\t * their demise.  If we lost the race with another",
            "\t\t\t * thread getting here, it set group_exit_code",
            "\t\t\t * first and our do_group_exit call below will use",
            "\t\t\t * that value and ignore the one we pass it.",
            "\t\t\t */",
            "\t\t\tdo_coredump(&ksig->info);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * PF_USER_WORKER threads will catch and exit on fatal signals",
            "\t\t * themselves. They have cleanup that must be performed, so",
            "\t\t * we cannot call do_exit() on their behalf.",
            "\t\t */",
            "\t\tif (current->flags & PF_USER_WORKER)",
            "\t\t\tgoto out;",
            "",
            "\t\t/*",
            "\t\t * Death signals, no core dump.",
            "\t\t */",
            "\t\tdo_group_exit(ksig->info.si_signo);",
            "\t\t/* NOTREACHED */",
            "\t}",
            "\tspin_unlock_irq(&sighand->siglock);",
            "out:",
            "\tksig->sig = signr;",
            "",
            "\tif (!(ksig->ka.sa.sa_flags & SA_EXPOSE_TAGBITS))",
            "\t\thide_si_addr_tag_bits(ksig);",
            "",
            "\treturn ksig->sig > 0;",
            "}"
          ],
          "function_name": "get_signal",
          "description": "get_signal 获取并处理待交付信号，包含同步信号处理、组停止检测、致命信号处理、调试器交互等复杂逻辑分支",
          "similarity": 0.6277992725372314
        }
      ]
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.6052342653274536,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.6054418087005615
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.5806443691253662
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.5494042634963989
        }
      ]
    },
    {
      "source_file": "kernel/exit.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:27:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `exit.c`\n\n---\n\n# `exit.c` 技术文档\n\n## 1. 文件概述\n\n`exit.c` 是 Linux 内核中负责进程退出（termination）核心逻辑的关键源文件，位于 `kernel/` 目录下。该文件实现了进程终止时的资源回收、信号处理、线程组清理、引用计数释放以及与用户空间和内核其他子系统的协调机制。其主要职责包括：\n\n- 安全地释放进程占用的内核资源（如内存、文件描述符、信号处理结构等）\n- 更新进程组和会话的统计信息\n- 通知父进程子进程已退出（通过 `SIGCHLD` 信号）\n- 管理僵尸进程（zombie）的生命周期\n- 支持线程组（thread group）的协同退出\n- 提供与 oops（内核异常）相关的计数和限制机制\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|---------|\n| `__unhash_process()` | 从内核的进程哈希表和链表中移除进程，减少线程计数 |\n| `__exit_signal()` | 清理进程的信号相关资源，累加 CPU 时间和 I/O 统计到 `signal_struct` |\n| `delayed_put_task_struct()` | RCU 回调函数，延迟释放 `task_struct` 及其关联资源 |\n| `put_task_struct_rcu_user()` | 安全地减少 `task_struct` 的 RCU 用户引用计数，并在为零时调度延迟释放 |\n| `release_thread()` | 架构相关的线程资源释放钩子（弱符号，可由架构代码覆盖） |\n| `release_task()` | 主进程释放入口函数，协调整个退出流程，包括通知父进程、释放资源等 |\n| `rcuwait_wake_up()` | 唤醒等待在 `rcuwait` 上的任务（代码片段未完整） |\n\n### 关键数据结构与变量\n\n| 名称 | 类型/说明 |\n|------|----------|\n| `oops_limit` | `unsigned int`，限制内核 oops 发生次数的阈值（默认 10000） |\n| `oops_count` | `atomic_t`，原子计数器，记录系统发生 oops 的总次数 |\n| `kern_exit_table` | `ctl_table`，用于 `/proc/sys/kernel/oops_limit` 的 sysctl 接口 |\n| `oops_count_attr` | `kobj_attribute`，用于 `/sys/kernel/oops_count` 的 sysfs 接口 |\n\n## 3. 关键实现\n\n### 进程退出流程\n\n1. **资源统计聚合**：  \n   在 `__exit_signal()` 中，将退出线程的 CPU 时间（`utime`/`stime`）、I/O 操作、上下文切换次数等统计信息累加到所属线程组的 `signal_struct` 中，确保即使线程组 leader 尚未退出，也能被 `wait4()` 等系统调用正确获取。\n\n2. **线程组协同退出**：  \n   - 若当前退出的是线程组 leader（`group_dead == true`），则清理整个线程组的 PID 类型（TGID、PGID、SID），并从全局任务链表中移除。\n   - 若非 leader，则仅减少线程组计数，并可能更新 `curr_target`（用于信号投递）。\n\n3. **僵尸进程处理**：  \n   在 `release_task()` 中，检查线程组 leader 是否已变为僵尸状态。若是且当前线程是最后一个成员，则调用 `do_notify_parent()` 通知其父进程。若父进程忽略 `SIGCHLD`，则直接将 leader 状态置为 `EXIT_DEAD` 并递归释放。\n\n4. **延迟释放机制**：  \n   通过 RCU（Read-Copy-Update）机制安全释放 `task_struct`。`put_task_struct_rcu_user()` 在引用计数归零时调用 `call_rcu()`，由 `delayed_put_task_struct()` 在 RCU 宽限期后执行实际释放，确保并发读取安全。\n\n5. **Oops 计数与限制**：  \n   提供 `oops_count`（只读）和 `oops_limit`（可调）两个接口，用于监控和限制内核异常次数，防止因频繁崩溃导致资源耗尽或引用计数溢出。\n\n### 锁与同步\n\n- **`tasklist_lock`**：写锁保护进程链表和 PID 哈希表的修改。\n- **`sighand->siglock`**：自旋锁保护信号处理结构。\n- **`signal->stats_lock`**：顺序锁（seqlock）保护线程组统计信息的聚合。\n- **RCU**：用于安全地延迟释放 `task_struct`，避免在遍历任务链表时访问已释放内存。\n\n## 4. 依赖关系\n\n`exit.c` 与内核多个子系统紧密耦合，主要依赖包括：\n\n- **调度器（SCHED）**：`<linux/sched/*.h>`，用于任务状态管理、CPU 时间统计、任务链表操作。\n- **内存管理（MM）**：`<linux/mm.h>`、`<linux/slab.h>`，用于内存释放和 slab 分配器交互。\n- **文件系统（VFS）**：`<linux/file.h>`、`<linux/fdtable.h>`、`<linux/fs_struct.h>`，用于关闭文件描述符和释放文件系统上下文。\n- **进程间通信（IPC）**：`<linux/shm.h>`、`<linux/posix-timers.h>`，用于清理共享内存和定时器资源。\n- **安全与审计**：`<linux/audit.h>`、`<linux/seccomp.h>`（通过 `seccomp_filter_release`），用于释放安全策略和审计上下文。\n- **cgroup 与资源控制**：`<linux/cgroup.h>`、`<linux/resource.h>`，用于资源计数释放和限制检查。\n- **跟踪与性能**：`<linux/perf_event.h>`、`<trace/events/sched.h>`，用于性能事件清理和调度跟踪点。\n- **架构相关代码**：`<asm/mmu_context.h>`、`release_thread()` 弱符号，允许架构层定制线程释放逻辑。\n\n## 5. 使用场景\n\n- **进程正常退出**：当用户程序调用 `exit()` 或 `exit_group()` 系统调用时，内核通过此文件执行清理。\n- **进程被信号终止**：如收到 `SIGKILL` 或 `SIGTERM` 后，内核调度退出路径。\n- **线程退出**：POSIX 线程（通过 `pthread_exit()` 或线程函数返回）触发 `release_task()` 清理单个线程。\n- **内核 Oops/panic 处理**：每次内核异常会递增 `oops_count`，用于监控系统稳定性。\n- **僵尸进程回收**：父进程调用 `wait()` 系列系统调用后，内核最终通过 `release_task()` 释放僵尸进程的内核结构。\n- **容器/命名空间退出**：在 PID 命名空间或 cgroup 中进程退出时，协调资源释放和通知机制。",
      "similarity": 0.5961011052131653,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/exit.c",
          "start_line": 354,
          "end_line": 526,
          "content": [
            "int is_current_pgrp_orphaned(void)",
            "{",
            "\tint retval;",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\treturn retval;",
            "}",
            "static bool has_stopped_jobs(struct pid *pgrp)",
            "{",
            "\tstruct task_struct *p;",
            "",
            "\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {",
            "\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)",
            "\t\t\treturn true;",
            "\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);",
            "",
            "\treturn false;",
            "}",
            "static void",
            "kill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)",
            "{",
            "\tstruct pid *pgrp = task_pgrp(tsk);",
            "\tstruct task_struct *ignored_task = tsk;",
            "",
            "\tif (!parent)",
            "\t\t/* exit: our father is in a different pgrp than",
            "\t\t * we are and we were the only connection outside.",
            "\t\t */",
            "\t\tparent = tsk->real_parent;",
            "\telse",
            "\t\t/* reparent: our child is in a different pgrp than",
            "\t\t * we are, and it was the only connection outside.",
            "\t\t */",
            "\t\tignored_task = NULL;",
            "",
            "\tif (task_pgrp(parent) != pgrp &&",
            "\t    task_session(parent) == task_session(tsk) &&",
            "\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&",
            "\t    has_stopped_jobs(pgrp)) {",
            "\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);",
            "\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);",
            "\t}",
            "}",
            "static void coredump_task_exit(struct task_struct *tsk)",
            "{",
            "\tstruct core_state *core_state;",
            "",
            "\t/*",
            "\t * Serialize with any possible pending coredump.",
            "\t * We must hold siglock around checking core_state",
            "\t * and setting PF_POSTCOREDUMP.  The core-inducing thread",
            "\t * will increment ->nr_threads for each thread in the",
            "\t * group without PF_POSTCOREDUMP set.",
            "\t */",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "\ttsk->flags |= PF_POSTCOREDUMP;",
            "\tcore_state = tsk->signal->core_state;",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\t/* The vhost_worker does not particpate in coredumps */",
            "\tif (core_state &&",
            "\t    ((tsk->flags & (PF_IO_WORKER | PF_USER_WORKER)) != PF_USER_WORKER)) {",
            "\t\tstruct core_thread self;",
            "",
            "\t\tself.task = current;",
            "\t\tif (self.task->flags & PF_SIGNALED)",
            "\t\t\tself.next = xchg(&core_state->dumper.next, &self);",
            "\t\telse",
            "\t\t\tself.task = NULL;",
            "\t\t/*",
            "\t\t * Implies mb(), the result of xchg() must be visible",
            "\t\t * to core_state->dumper.",
            "\t\t */",
            "\t\tif (atomic_dec_and_test(&core_state->nr_threads))",
            "\t\t\tcomplete(&core_state->startup);",
            "",
            "\t\tfor (;;) {",
            "\t\t\tset_current_state(TASK_UNINTERRUPTIBLE|TASK_FREEZABLE);",
            "\t\t\tif (!self.task) /* see coredump_finish() */",
            "\t\t\t\tbreak;",
            "\t\t\tschedule();",
            "\t\t}",
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t}",
            "}",
            "void mm_update_next_owner(struct mm_struct *mm)",
            "{",
            "\tstruct task_struct *c, *g, *p = current;",
            "",
            "retry:",
            "\t/*",
            "\t * If the exiting or execing task is not the owner, it's",
            "\t * someone else's problem.",
            "\t */",
            "\tif (mm->owner != p)",
            "\t\treturn;",
            "\t/*",
            "\t * The current owner is exiting/execing and there are no other",
            "\t * candidates.  Do not leave the mm pointing to a possibly",
            "\t * freed task structure.",
            "\t */",
            "\tif (atomic_read(&mm->mm_users) <= 1) {",
            "\t\tWRITE_ONCE(mm->owner, NULL);",
            "\t\treturn;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\t/*",
            "\t * Search in the children",
            "\t */",
            "\tlist_for_each_entry(c, &p->children, sibling) {",
            "\t\tif (c->mm == mm)",
            "\t\t\tgoto assign_new_owner;",
            "\t}",
            "",
            "\t/*",
            "\t * Search in the siblings",
            "\t */",
            "\tlist_for_each_entry(c, &p->real_parent->children, sibling) {",
            "\t\tif (c->mm == mm)",
            "\t\t\tgoto assign_new_owner;",
            "\t}",
            "",
            "\t/*",
            "\t * Search through everything else, we should not get here often.",
            "\t */",
            "\tfor_each_process(g) {",
            "\t\tif (atomic_read(&mm->mm_users) <= 1)",
            "\t\t\tbreak;",
            "\t\tif (g->flags & PF_KTHREAD)",
            "\t\t\tcontinue;",
            "\t\tfor_each_thread(g, c) {",
            "\t\t\tif (c->mm == mm)",
            "\t\t\t\tgoto assign_new_owner;",
            "\t\t\tif (c->mm)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "\t/*",
            "\t * We found no owner yet mm_users > 1: this implies that we are",
            "\t * most likely racing with swapoff (try_to_unuse()) or /proc or",
            "\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.",
            "\t */",
            "\tWRITE_ONCE(mm->owner, NULL);",
            "\treturn;",
            "",
            "assign_new_owner:",
            "\tBUG_ON(c == p);",
            "\tget_task_struct(c);",
            "\t/*",
            "\t * The task_lock protects c->mm from changing.",
            "\t * We always want mm->owner->mm == mm",
            "\t */",
            "\ttask_lock(c);",
            "\t/*",
            "\t * Delay read_unlock() till we have the task_lock()",
            "\t * to ensure that c does not slip away underneath us",
            "\t */",
            "\tread_unlock(&tasklist_lock);",
            "\tif (c->mm != mm) {",
            "\t\ttask_unlock(c);",
            "\t\tput_task_struct(c);",
            "\t\tgoto retry;",
            "\t}",
            "\tWRITE_ONCE(mm->owner, c);",
            "\tlru_gen_migrate_mm(mm);",
            "\ttask_unlock(c);",
            "\tput_task_struct(c);",
            "}"
          ],
          "function_name": "is_current_pgrp_orphaned, has_stopped_jobs, kill_orphaned_pgrp, coredump_task_exit, mm_update_next_owner",
          "description": "实现进程组孤儿检测、停止状态判断、异常终止信号分发及核心转储协调逻辑。",
          "similarity": 0.657328724861145
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/exit.c",
          "start_line": 546,
          "end_line": 686,
          "content": [
            "static void exit_mm(void)",
            "{",
            "\tstruct mm_struct *mm = current->mm;",
            "",
            "\texit_mm_release(current, mm);",
            "\tif (!mm)",
            "\t\treturn;",
            "\tsync_mm_rss(mm);",
            "\tmmap_read_lock(mm);",
            "\tmmgrab_lazy_tlb(mm);",
            "\tBUG_ON(mm != current->active_mm);",
            "\t/* more a memory barrier than a real lock */",
            "\ttask_lock(current);",
            "\t/*",
            "\t * When a thread stops operating on an address space, the loop",
            "\t * in membarrier_private_expedited() may not observe that",
            "\t * tsk->mm, and the loop in membarrier_global_expedited() may",
            "\t * not observe a MEMBARRIER_STATE_GLOBAL_EXPEDITED",
            "\t * rq->membarrier_state, so those would not issue an IPI.",
            "\t * Membarrier requires a memory barrier after accessing",
            "\t * user-space memory, before clearing tsk->mm or the",
            "\t * rq->membarrier_state.",
            "\t */",
            "\tsmp_mb__after_spinlock();",
            "\tlocal_irq_disable();",
            "\tcurrent->mm = NULL;",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(current, NULL);",
            "\t#endif",
            "\tmembarrier_update_current_mm(NULL);",
            "\tenter_lazy_tlb(mm, current);",
            "\tlocal_irq_enable();",
            "\ttask_unlock(current);",
            "\tmmap_read_unlock(mm);",
            "\tmm_update_next_owner(mm);",
            "\tmmput(mm);",
            "\tif (test_thread_flag(TIF_MEMDIE))",
            "\t\texit_oom_victim();",
            "}",
            "static void reparent_leader(struct task_struct *father, struct task_struct *p,",
            "\t\t\t\tstruct list_head *dead)",
            "{",
            "\tif (unlikely(p->exit_state == EXIT_DEAD))",
            "\t\treturn;",
            "",
            "\t/* We don't want people slaying init. */",
            "\tp->exit_signal = SIGCHLD;",
            "",
            "\t/* If it has exited notify the new parent about this child's death. */",
            "\tif (!p->ptrace &&",
            "\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {",
            "\t\tif (do_notify_parent(p, p->exit_signal)) {",
            "\t\t\tp->exit_state = EXIT_DEAD;",
            "\t\t\tlist_add(&p->ptrace_entry, dead);",
            "\t\t}",
            "\t}",
            "",
            "\tkill_orphaned_pgrp(p, father);",
            "}",
            "static void forget_original_parent(struct task_struct *father,",
            "\t\t\t\t\tstruct list_head *dead)",
            "{",
            "\tstruct task_struct *p, *t, *reaper;",
            "",
            "\tif (unlikely(!list_empty(&father->ptraced)))",
            "\t\texit_ptrace(father, dead);",
            "",
            "\t/* Can drop and reacquire tasklist_lock */",
            "\treaper = find_child_reaper(father, dead);",
            "\tif (list_empty(&father->children))",
            "\t\treturn;",
            "",
            "\treaper = find_new_reaper(father, reaper);",
            "\tlist_for_each_entry(p, &father->children, sibling) {",
            "\t\tfor_each_thread(p, t) {",
            "\t\t\tRCU_INIT_POINTER(t->real_parent, reaper);",
            "\t\t\tBUG_ON((!t->ptrace) != (rcu_access_pointer(t->parent) == father));",
            "\t\t\tif (likely(!t->ptrace))",
            "\t\t\t\tt->parent = t->real_parent;",
            "\t\t\tif (t->pdeath_signal)",
            "\t\t\t\tgroup_send_sig_info(t->pdeath_signal,",
            "\t\t\t\t\t\t    SEND_SIG_NOINFO, t,",
            "\t\t\t\t\t\t    PIDTYPE_TGID);",
            "\t\t}",
            "\t\t/*",
            "\t\t * If this is a threaded reparent there is no need to",
            "\t\t * notify anyone anything has happened.",
            "\t\t */",
            "\t\tif (!same_thread_group(reaper, father))",
            "\t\t\treparent_leader(father, p, dead);",
            "\t}",
            "\tlist_splice_tail_init(&father->children, &reaper->children);",
            "}",
            "static void exit_notify(struct task_struct *tsk, int group_dead)",
            "{",
            "\tbool autoreap;",
            "\tstruct task_struct *p, *n;",
            "\tLIST_HEAD(dead);",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\tforget_original_parent(tsk, &dead);",
            "",
            "\tif (group_dead)",
            "\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);",
            "",
            "\ttsk->exit_state = EXIT_ZOMBIE;",
            "\t/*",
            "\t * sub-thread or delay_group_leader(), wake up the",
            "\t * PIDFD_THREAD waiters.",
            "\t */",
            "\tif (!thread_group_empty(tsk))",
            "\t\tdo_notify_pidfd(tsk);",
            "",
            "\tif (unlikely(tsk->ptrace)) {",
            "\t\tint sig = thread_group_leader(tsk) &&",
            "\t\t\t\tthread_group_empty(tsk) &&",
            "\t\t\t\t!ptrace_reparented(tsk) ?",
            "\t\t\ttsk->exit_signal : SIGCHLD;",
            "\t\tautoreap = do_notify_parent(tsk, sig);",
            "\t} else if (thread_group_leader(tsk)) {",
            "\t\tautoreap = thread_group_empty(tsk) &&",
            "\t\t\tdo_notify_parent(tsk, tsk->exit_signal);",
            "\t} else {",
            "\t\tautoreap = true;",
            "\t}",
            "",
            "\tif (autoreap) {",
            "\t\ttsk->exit_state = EXIT_DEAD;",
            "\t\tlist_add(&tsk->ptrace_entry, &dead);",
            "\t}",
            "",
            "\t/* mt-exec, de_thread() is waiting for group leader */",
            "\tif (unlikely(tsk->signal->notify_count < 0))",
            "\t\twake_up_process(tsk->signal->group_exec_task);",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {",
            "\t\tlist_del_init(&p->ptrace_entry);",
            "\t\trelease_task(p);",
            "\t}",
            "}"
          ],
          "function_name": "exit_mm, reparent_leader, forget_original_parent, exit_notify",
          "description": "完成内存映射释放、父进程重定位、原始父进程解除关联及进程退出状态通知流程。",
          "similarity": 0.5877776145935059
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/exit.c",
          "start_line": 791,
          "end_line": 942,
          "content": [
            "static void check_stack_usage(void)",
            "{",
            "\tstatic DEFINE_SPINLOCK(low_water_lock);",
            "\tstatic int lowest_to_date = THREAD_SIZE;",
            "\tunsigned long free;",
            "",
            "\tfree = stack_not_used(current);",
            "",
            "\tif (free >= lowest_to_date)",
            "\t\treturn;",
            "",
            "\tspin_lock(&low_water_lock);",
            "\tif (free < lowest_to_date) {",
            "\t\tpr_info(\"%s (%d) used greatest stack depth: %lu bytes left\\n\",",
            "\t\t\tcurrent->comm, task_pid_nr(current), free);",
            "\t\tlowest_to_date = free;",
            "\t}",
            "\tspin_unlock(&low_water_lock);",
            "}",
            "static inline void check_stack_usage(void) {}",
            "static void synchronize_group_exit(struct task_struct *tsk, long code)",
            "{",
            "\tstruct sighand_struct *sighand = tsk->sighand;",
            "\tstruct signal_struct *signal = tsk->signal;",
            "",
            "\tspin_lock_irq(&sighand->siglock);",
            "\tsignal->quick_threads--;",
            "\tif ((signal->quick_threads == 0) &&",
            "\t    !(signal->flags & SIGNAL_GROUP_EXIT)) {",
            "\t\tsignal->flags = SIGNAL_GROUP_EXIT;",
            "\t\tsignal->group_exit_code = code;",
            "\t\tsignal->group_stop_count = 0;",
            "\t}",
            "\tspin_unlock_irq(&sighand->siglock);",
            "}",
            "void __noreturn do_exit(long code)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tint group_dead;",
            "",
            "\tWARN_ON(irqs_disabled());",
            "",
            "\tsynchronize_group_exit(tsk, code);",
            "",
            "\tWARN_ON(tsk->plug);",
            "",
            "\tkcov_task_exit(tsk);",
            "\tkmsan_task_exit(tsk);",
            "",
            "\tcoredump_task_exit(tsk);",
            "\tptrace_event(PTRACE_EVENT_EXIT, code);",
            "\tuser_events_exit(tsk);",
            "",
            "\tio_uring_files_cancel();",
            "\texit_signals(tsk);  /* sets PF_EXITING */",
            "",
            "\t/* sync mm's RSS info before statistics gathering */",
            "\tif (tsk->mm)",
            "\t\tsync_mm_rss(tsk->mm);",
            "\tacct_update_integrals(tsk);",
            "\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);",
            "\tif (group_dead) {",
            "\t\t/*",
            "\t\t * If the last thread of global init has exited, panic",
            "\t\t * immediately to get a useable coredump.",
            "\t\t */",
            "\t\tif (unlikely(is_global_init(tsk)))",
            "\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",",
            "\t\t\t\ttsk->signal->group_exit_code ?: (int)code);",
            "",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\t\thrtimer_cancel(&tsk->signal->real_timer);",
            "\t\texit_itimers(tsk);",
            "#endif",
            "\t\tif (tsk->mm)",
            "\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);",
            "\t}",
            "\tacct_collect(code, group_dead);",
            "\tif (group_dead)",
            "\t\ttty_audit_exit();",
            "\taudit_free(tsk);",
            "",
            "\ttsk->exit_code = code;",
            "\ttaskstats_exit(tsk, group_dead);",
            "",
            "\t/*",
            "\t * Since sampling can touch ->mm, make sure to stop everything before we",
            "\t * tear it down.",
            "\t *",
            "\t * Also flushes inherited counters to the parent - before the parent",
            "\t * gets woken up by child-exit notifications.",
            "\t */",
            "\tperf_event_exit_task(tsk);",
            "",
            "\texit_mm();",
            "",
            "\tif (group_dead)",
            "\t\tacct_process();",
            "\ttrace_sched_process_exit(tsk);",
            "",
            "\texit_sem(tsk);",
            "\texit_shm(tsk);",
            "\texit_files(tsk);",
            "\texit_fs(tsk);",
            "\tif (group_dead)",
            "\t\tdisassociate_ctty(1);",
            "\texit_task_namespaces(tsk);",
            "\texit_task_work(tsk);",
            "\texit_thread(tsk);",
            "",
            "\tsched_autogroup_exit_task(tsk);",
            "\tcgroup_exit(tsk);",
            "",
            "\t/*",
            "\t * FIXME: do that only when needed, using sched_exit tracepoint",
            "\t */",
            "\tflush_ptrace_hw_breakpoint(tsk);",
            "",
            "\texit_tasks_rcu_start();",
            "\texit_notify(tsk, group_dead);",
            "\tproc_exit_connector(tsk);",
            "\tmpol_put_task_policy(tsk);",
            "#ifdef CONFIG_FUTEX",
            "\tif (unlikely(current->pi_state_cache))",
            "\t\tkfree(current->pi_state_cache);",
            "#endif",
            "\t/*",
            "\t * Make sure we are holding no locks:",
            "\t */",
            "\tdebug_check_no_locks_held();",
            "",
            "\tif (tsk->io_context)",
            "\t\texit_io_context(tsk);",
            "",
            "\tif (tsk->splice_pipe)",
            "\t\tfree_pipe_info(tsk->splice_pipe);",
            "",
            "\tif (tsk->task_frag.page)",
            "\t\tput_page(tsk->task_frag.page);",
            "",
            "\texit_task_stack_account(tsk);",
            "",
            "\tcheck_stack_usage();",
            "\tpreempt_disable();",
            "\tif (tsk->nr_dirtied)",
            "\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);",
            "\texit_rcu();",
            "\texit_tasks_rcu_finish();",
            "",
            "\tlockdep_free_task(tsk);",
            "\tdo_task_dead();",
            "}"
          ],
          "function_name": "check_stack_usage, check_stack_usage, synchronize_group_exit, do_exit",
          "description": "do_exit函数负责处理进程退出流程，包括同步线程组退出、释放资源、更新统计信息、清理内存映射、解除命名空间关联等操作。其中synchronize_group_exit用于减少信号量计数并标记线程组退出状态，check_stack_usage监控最大堆栈使用量。",
          "similarity": 0.5821613073348999
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/exit.c",
          "start_line": 102,
          "end_line": 209,
          "content": [
            "static __init int kernel_exit_sysctls_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kern_exit_table);",
            "\treturn 0;",
            "}",
            "static ssize_t oops_count_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\t\t       char *page)",
            "{",
            "\treturn sysfs_emit(page, \"%d\\n\", atomic_read(&oops_count));",
            "}",
            "static __init int kernel_exit_sysfs_init(void)",
            "{",
            "\tsysfs_add_file_to_group(kernel_kobj, &oops_count_attr.attr, NULL);",
            "\treturn 0;",
            "}",
            "static void __unhash_process(struct task_struct *p, bool group_dead)",
            "{",
            "\tnr_threads--;",
            "\tdetach_pid(p, PIDTYPE_PID);",
            "\tif (group_dead) {",
            "\t\tdetach_pid(p, PIDTYPE_TGID);",
            "\t\tdetach_pid(p, PIDTYPE_PGID);",
            "\t\tdetach_pid(p, PIDTYPE_SID);",
            "",
            "\t\tlist_del_rcu(&p->tasks);",
            "\t\tlist_del_init(&p->sibling);",
            "\t\t__this_cpu_dec(process_counts);",
            "\t}",
            "\tlist_del_rcu(&p->thread_group);",
            "\tlist_del_rcu(&p->thread_node);",
            "}",
            "static void __exit_signal(struct task_struct *tsk)",
            "{",
            "\tstruct signal_struct *sig = tsk->signal;",
            "\tbool group_dead = thread_group_leader(tsk);",
            "\tstruct sighand_struct *sighand;",
            "\tstruct tty_struct *tty;",
            "\tu64 utime, stime;",
            "",
            "\tsighand = rcu_dereference_check(tsk->sighand,",
            "\t\t\t\t\tlockdep_tasklist_lock_is_held());",
            "\tspin_lock(&sighand->siglock);",
            "",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\tposix_cpu_timers_exit(tsk);",
            "\tif (group_dead)",
            "\t\tposix_cpu_timers_exit_group(tsk);",
            "#endif",
            "",
            "\tif (group_dead) {",
            "\t\ttty = sig->tty;",
            "\t\tsig->tty = NULL;",
            "\t} else {",
            "\t\t/*",
            "\t\t * If there is any task waiting for the group exit",
            "\t\t * then notify it:",
            "\t\t */",
            "\t\tif (sig->notify_count > 0 && !--sig->notify_count)",
            "\t\t\twake_up_process(sig->group_exec_task);",
            "",
            "\t\tif (tsk == sig->curr_target)",
            "\t\t\tsig->curr_target = next_thread(tsk);",
            "\t}",
            "",
            "\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,",
            "\t\t\t      sizeof(unsigned long long));",
            "",
            "\t/*",
            "\t * Accumulate here the counters for all threads as they die. We could",
            "\t * skip the group leader because it is the last user of signal_struct,",
            "\t * but we want to avoid the race with thread_group_cputime() which can",
            "\t * see the empty ->thread_head list.",
            "\t */",
            "\ttask_cputime(tsk, &utime, &stime);",
            "\twrite_seqlock(&sig->stats_lock);",
            "\tsig->utime += utime;",
            "\tsig->stime += stime;",
            "\tsig->gtime += task_gtime(tsk);",
            "\tsig->min_flt += tsk->min_flt;",
            "\tsig->maj_flt += tsk->maj_flt;",
            "\tsig->nvcsw += tsk->nvcsw;",
            "\tsig->nivcsw += tsk->nivcsw;",
            "\tsig->inblock += task_io_get_inblock(tsk);",
            "\tsig->oublock += task_io_get_oublock(tsk);",
            "\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);",
            "\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;",
            "\tsig->nr_threads--;",
            "\t__unhash_process(tsk, group_dead);",
            "\twrite_sequnlock(&sig->stats_lock);",
            "",
            "\ttsk->sighand = NULL;",
            "\tspin_unlock(&sighand->siglock);",
            "",
            "\t__cleanup_sighand(sighand);",
            "\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);",
            "\tif (group_dead)",
            "\t\ttty_kref_put(tty);",
            "}",
            "static void delayed_put_task_struct(struct rcu_head *rhp)",
            "{",
            "\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);",
            "",
            "\tkprobe_flush_task(tsk);",
            "\trethook_flush_task(tsk);",
            "\tperf_event_delayed_put(tsk);",
            "\ttrace_sched_process_free(tsk);",
            "\tput_task_struct(tsk);",
            "}"
          ],
          "function_name": "kernel_exit_sysctls_init, oops_count_show, kernel_exit_sysfs_init, __unhash_process, __exit_signal, delayed_put_task_struct",
          "description": "初始化sysctl和sysfs接口，实现进程卸载、信号处理、线程组分离及统计信息汇总功能。",
          "similarity": 0.5818865299224854
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/exit.c",
          "start_line": 228,
          "end_line": 339,
          "content": [
            "void put_task_struct_rcu_user(struct task_struct *task)",
            "{",
            "\tif (refcount_dec_and_test(&task->rcu_users))",
            "\t\tcall_rcu(&task->rcu, delayed_put_task_struct);",
            "}",
            "void __weak release_thread(struct task_struct *dead_task)",
            "{",
            "}",
            "void release_task(struct task_struct *p)",
            "{",
            "\tstruct task_struct *leader;",
            "\tstruct pid *thread_pid;",
            "\tint zap_leader;",
            "repeat:",
            "\t/* don't need to get the RCU readlock here - the process is dead and",
            "\t * can't be modifying its own credentials. But shut RCU-lockdep up */",
            "\trcu_read_lock();",
            "\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);",
            "\trcu_read_unlock();",
            "",
            "\tcgroup_release(p);",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\tptrace_release_task(p);",
            "\tthread_pid = get_pid(p->thread_pid);",
            "\t__exit_signal(p);",
            "",
            "\t/*",
            "\t * If we are the last non-leader member of the thread",
            "\t * group, and the leader is zombie, then notify the",
            "\t * group leader's parent process. (if it wants notification.)",
            "\t */",
            "\tzap_leader = 0;",
            "\tleader = p->group_leader;",
            "\tif (leader != p && thread_group_empty(leader)",
            "\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {",
            "\t\t/*",
            "\t\t * If we were the last child thread and the leader has",
            "\t\t * exited already, and the leader's parent ignores SIGCHLD,",
            "\t\t * then we are the one who should release the leader.",
            "\t\t */",
            "\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);",
            "\t\tif (zap_leader)",
            "\t\t\tleader->exit_state = EXIT_DEAD;",
            "\t}",
            "",
            "\twrite_unlock_irq(&tasklist_lock);",
            "\tseccomp_filter_release(p);",
            "\tproc_flush_pid(thread_pid);",
            "\tput_pid(thread_pid);",
            "\trelease_thread(p);",
            "\t/*",
            "\t * This task was already removed from the process/thread/pid lists",
            "\t * and lock_task_sighand(p) can't succeed. Nobody else can touch",
            "\t * ->pending or, if group dead, signal->shared_pending. We can call",
            "\t * flush_sigqueue() lockless.",
            "\t */",
            "\tflush_sigqueue(&p->pending);",
            "\tif (thread_group_leader(p))",
            "\t\tflush_sigqueue(&p->signal->shared_pending);",
            "",
            "\tput_task_struct_rcu_user(p);",
            "",
            "\tp = leader;",
            "\tif (unlikely(zap_leader))",
            "\t\tgoto repeat;",
            "}",
            "int rcuwait_wake_up(struct rcuwait *w)",
            "{",
            "\tint ret = 0;",
            "\tstruct task_struct *task;",
            "",
            "\trcu_read_lock();",
            "",
            "\t/*",
            "\t * Order condition vs @task, such that everything prior to the load",
            "\t * of @task is visible. This is the condition as to why the user called",
            "\t * rcuwait_wake() in the first place. Pairs with set_current_state()",
            "\t * barrier (A) in rcuwait_wait_event().",
            "\t *",
            "\t *    WAIT                WAKE",
            "\t *    [S] tsk = current\t  [S] cond = true",
            "\t *        MB (A)\t      MB (B)",
            "\t *    [L] cond\t\t  [L] tsk",
            "\t */",
            "\tsmp_mb(); /* (B) */",
            "",
            "\ttask = rcu_dereference(w->task);",
            "\tif (task)",
            "\t\tret = wake_up_process(task);",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "static int will_become_orphaned_pgrp(struct pid *pgrp,",
            "\t\t\t\t\tstruct task_struct *ignored_task)",
            "{",
            "\tstruct task_struct *p;",
            "",
            "\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {",
            "\t\tif ((p == ignored_task) ||",
            "\t\t    (p->exit_state && thread_group_empty(p)) ||",
            "\t\t    is_global_init(p->real_parent))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (task_pgrp(p->real_parent) != pgrp &&",
            "\t\t    task_session(p->real_parent) == task_session(p))",
            "\t\t\treturn 0;",
            "\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);",
            "",
            "\treturn 1;",
            "}"
          ],
          "function_name": "put_task_struct_rcu_user, release_thread, release_task, rcuwait_wake_up, will_become_orphaned_pgrp",
          "description": "提供RCU安全的任务结构释放机制，处理线程组解关联、会话管理及条件唤醒操作。",
          "similarity": 0.5618054866790771
        }
      ]
    }
  ]
}