{
  "query": "零拷贝技术在Linux内核中的实现",
  "timestamp": "2025-12-26 02:10:12",
  "retrieved_files": [
    {
      "source_file": "kernel/rcu/tree_nocb.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:48:05\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\tree_nocb.h`\n\n---\n\n# `rcu/tree_nocb.h` 技术文档\n\n## 1. 文件概述\n\n`rcu/tree_nocb.h` 是 Linux 内核 RCU（Read-Copy Update）子系统中用于实现 **无回调（No-CB）CPU 机制** 的内部头文件。该机制允许将指定 CPU 上的 RCU 回调处理任务从本地 CPU 卸载（offload）到专用内核线程（kthread）中执行，从而减少主 CPU 的中断和调度开销，提升实时性、降低 OS 抖动（jitter），并有助于节能（通过更积极地进入 dyntick-idle 状态）。该文件仅在 `CONFIG_RCU_NOCB_CPU` 配置选项启用时生效。\n\n## 2. 核心功能\n\n### 全局变量\n- `rcu_nocb_mask`：`cpumask_var_t` 类型，指定哪些 CPU 启用 No-CB 模式（即回调被卸载）。\n- `rcu_nocb_poll`：布尔值，若为 `true`，表示 No-CB kthread 采用轮询而非休眠等待。\n- `nocb_nobypass_lim_per_jiffy`：模块参数，控制在低 `call_rcu()` 调用率下是否绕过 bypass 机制。\n- `jiffies_till_flush`：定义 lazy 回调的最大延迟时间（默认 10 秒）。\n\n### 主要函数\n\n#### 初始化与解析\n- `rcu_nocb_setup(char *str)`：解析内核启动参数 `rcu_nocbs=`，设置 `rcu_nocb_mask`。\n- `parse_rcu_nocb_poll(char *arg)`：解析 `rcu_nocb_poll` 启动参数。\n- `rcu_init_one_nocb(struct rcu_node *rnp)`：初始化 `rcu_node` 的 No-CB 等待队列。\n\n#### 锁操作\n- `rcu_nocb_bypass_lock/unlock/trylock()`：操作 `nocb_bypass_lock`，用于保护 bypass 队列。\n- `rcu_nocb_lock/unlock/unlock_irqrestore()`：条件性操作 `nocb_lock`，仅对 No-CB CPU 生效。\n- `rcu_lockdep_assert_cblist_protected()`：Lockdep 断言，确保 `cblist` 访问受保护。\n\n#### 线程管理与唤醒\n- `rcu_current_is_nocb_kthread()`：判断当前任务是否为 No-CB kthread。\n- `wake_nocb_gp()` / `__wake_nocb_gp()`：唤醒 GP（Grace Period）kthread。\n- `wake_nocb_gp_defer()`：延迟唤醒 GP kthread（代码未完整，但功能明确）。\n- `rcu_nocb_gp_cleanup()`：清理 GP 等待队列。\n- `rcu_nocb_gp_get()`：获取当前 GP 序号对应的等待队列。\n\n#### 调试与锁依赖\n- `rcu_lockdep_is_held_nocb()`：Lockdep 检查 `nocb_lock` 是否已被持有。\n\n#### Lazy 回调控制（仅当 `CONFIG_RCU_LAZY` 启用）\n- `rcu_lazy_set_jiffies_till_flush()` / `rcu_lazy_get_jiffies_till_flush()`：设置/获取 lazy 回调刷新超时时间（主要用于测试）。\n\n## 3. 关键实现\n\n### No-CB 架构\n- **双线程模型**：每个 No-CB CPU 组关联两个 kthread：\n  - **GP kthread**：负责管理回调队列、等待宽限期结束、唤醒 CB kthread。\n  - **CB kthread**：仅负责执行回调函数。\n- **唤醒策略**：\n  - 默认：当 CPU 向空回调队列插入回调时，唤醒 GP kthread。\n  - 若启用 `rcu_nocb_poll`：kthread 主动轮询，减少本地 CPU 开销但牺牲能效。\n- **延迟唤醒**：通过 `nocb_defer_wakeup` 和定时器实现批量唤醒，避免频繁唤醒开销。\n\n### 锁设计\n- 使用两个自旋锁：\n  - `nocb_lock`：保护主回调链表（`cblist`）。\n  - `nocb_bypass_lock`：保护 bypass 队列（用于高吞吐场景避免锁竞争）。\n- 所有锁操作均要求中断关闭（`lockdep_assert_irqs_disabled()`）。\n\n### Grace Period 同步\n- 使用 `swait_queue_head`（simple wait queue）实现轻量级等待。\n- 通过 `rcu_seq_ctr(gp_seq) & 0x1` 实现双缓冲等待队列，避免 ABA 问题。\n\n### Lazy 回调处理\n- 在 `CONFIG_RCU_LAZY` 下，延迟执行低优先级回调，最多延迟 `LAZY_FLUSH_JIFFIES`（默认 10 秒）。\n\n## 4. 依赖关系\n\n- **内核配置**：\n  - 依赖 `CONFIG_RCU_NOCB_CPU` 编译。\n  - 可选依赖 `CONFIG_RCU_LAZY`（lazy 回调支持）。\n- **数据结构**：\n  - 依赖 `struct rcu_data` 中的 No-CB 相关字段（如 `nocb_cb_kthread`, `nocb_gp_kthread`, `nocb_lock` 等）。\n  - 依赖 `struct rcu_node` 中的 `nocb_gp_wq[2]`。\n- **子系统**：\n  - 与 RCU 树形实现（`tree.c`）紧密集成。\n  - 使用内核调度器（`wake_up_process`）、定时器（`del_timer`）、cpumask 和 lockdep 机制。\n\n## 5. 使用场景\n\n- **实时系统**：卸载 RCU 回调可减少 CPU-bound 任务的 OS 抖动，提升实时性。\n- **节能场景**：No-CB CPU 可更早进入 dyntick-idle 状态，降低功耗。\n- **高吞吐系统**：通过 bypass 机制和专用 kthread 减少 `call_rcu()` 的锁竞争。\n- **调试与测试**：通过启动参数（如 `rcu_nocbs=`, `rcu_nocb_poll`）和 lazy 回调接口进行行为调优和验证。",
      "similarity": 0.607138454914093,
      "chunks": []
    },
    {
      "source_file": "mm/secretmem.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:16:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `secretmem.c`\n\n---\n\n# secretmem.c 技术文档\n\n## 1. 文件概述\n\n`secretmem.c` 实现了 Linux 内核中的 **Secret Memory（秘密内存）** 功能，提供了一种安全的、不可交换（non-swappable）、不可转储（non-dumpable）且对内核页表隐藏的匿名内存区域。该功能通过新增系统调用 `memfd_secret(2)` 暴露给用户空间，用于创建具有特殊安全属性的内存文件描述符。此类内存主要用于存储敏感数据（如加密密钥），防止其被意外泄露到 swap、core dump 或通过 `/proc/pid/maps` 被探测。\n\n## 2. 核心功能\n\n### 主要函数\n- `memfd_secret(unsigned int flags)`：系统调用入口，创建 secret memory 文件描述符。\n- `secretmem_fault(struct vm_fault *vmf)`：处理缺页异常，按需分配并锁定秘密内存页。\n- `secretmem_mmap(struct file *file, struct vm_area_struct *vma)`：设置 VMA 属性，启用 `VM_LOCKED | VM_DONTDUMP` 并绑定 fault handler。\n- `secretmem_release(struct inode *inode, struct file *file)`：释放文件时减少用户计数。\n- `secretmem_file_create(unsigned long flags)`：创建基于伪文件系统的 secret memory 文件对象。\n- `secretmem_init(void)`：模块初始化，挂载 secretmem 伪文件系统。\n\n### 关键数据结构\n- `secretmem_fops`：文件操作结构体，定义 `.mmap` 和 `.release` 方法。\n- `secretmem_vm_ops`：VMA 操作结构体，仅实现 `.fault` 回调。\n- `secretmem_aops`：地址空间操作结构体，包含：\n  - `.free_folio`：释放页面前恢复直接映射并清零。\n  - `.migrate_folio`：返回 `-EBUSY` 禁止迁移。\n  - `.dirty_folio`：空操作（`noop_dirty_folio`），禁止脏页标记。\n- `secretmem_iops`：inode 操作结构体，限制文件大小不可修改（除初始为 0 外）。\n\n### 全局变量\n- `secretmem_enable`：模块参数，控制是否启用 secretmem 功能（默认启用）。\n- `secretmem_users`：原子计数器，跟踪当前活跃的 secret memory 用户数量。\n- `secretmem_mnt`：指向 secretmem 伪文件系统的内核挂载点。\n\n## 3. 关键实现\n\n### 内存安全性保障\n- **直接映射移除**：在 `secretmem_fault()` 中分配新页后，调用 `set_direct_map_invalid_noflush()` 将该物理页从内核直接映射区（direct map）中移除，使内核无法通过常规线性地址访问该页内容，增强对抗内核漏洞利用的能力。\n- **页面清零与恢复**：在 `secretmem_free_folio()` 中，先调用 `set_direct_map_default_noflush()` 恢复直接映射，再使用 `folio_zero_segment()` 安全清零页面内容，防止敏感数据残留。\n- **TLB 刷新**：分配新页并修改直接映射后，调用 `flush_tlb_kernel_range()` 刷新内核 TLB，确保 CPU 不再缓存旧映射。\n\n### 内存管理特性\n- **不可交换 & 不可回收**：通过 `mapping_set_unevictable()` 标记 address_space 为不可驱逐，确保页面不会被 swap 出或被内存回收机制回收。\n- **禁止迁移**：`.migrate_folio` 返回 `-EBUSY`，阻止 CMA、内存热插拔等场景下的页面迁移。\n- **禁止写脏**：使用 `noop_dirty_folio` 防止页面被标记为 dirty，避免写回行为。\n- **强制锁定**：`secretmem_mmap()` 强制设置 `VM_LOCKED`，结合 `mlock_future_ok()` 检查，确保内存常驻物理 RAM。\n\n### 文件系统与权限控制\n- 基于 `anon_inode` 构建伪文件系统（magic: `SECRETMEM_MAGIC`），挂载时设置 `MNT_NOEXEC` 禁止执行。\n- 文件大小只能为 0，`setattr` 操作拒绝任何非零的 `ATTR_SIZE` 修改。\n- 文件描述符默认具有 `O_RDWR` 权限，但实际 I/O 通过 mmap 访问。\n\n### 系统调用验证\n- 仅当 `secretmem_enable=1` 且平台支持 `can_set_direct_map()`（如 x86 的 `set_memory_valid()`）时才启用。\n- 参数 `flags` 必须为 `O_CLOEXEC` 或 0，其他位均视为非法。\n\n## 4. 依赖关系\n\n- **架构支持**：依赖 `asm/tlbflush.h` 和 `set_memory.h` 提供的 `set_direct_map_*` 及 TLB 刷新接口，目前主要在 x86 上实现。\n- **内存管理子系统**：重度依赖 `mm/` 下的 `filemap`、`folio`、`mlock`、`swap` 等机制。\n- **VFS 层**：使用 `pseudo_fs.h` 和 `anon_inode` 基础设施创建安全 inode。\n- **UAPI**：通过 `uapi/linux/magic.h` 定义文件系统 magic number。\n- **模块参数**：使用 `module_param_named` 提供运行时开关。\n\n## 5. 使用场景\n\n- **敏感数据保护**：应用程序（如加密库、密钥管理服务）可使用 `memfd_secret()` 创建内存区域存储私钥、会话密钥等，防止其出现在 swap 分区或 core dump 文件中。\n- **安全隔离**：由于页面从内核直接映射中移除，即使内核存在任意地址读取漏洞，攻击者也难以直接定位和提取 secret memory 中的数据。\n- **高性能安全内存**：相比传统 `mlock()` + `mmap()` 方案，secret memory 提供更严格的访问控制和自动清零机制，适用于对安全性要求极高的场景。\n- **容器与虚拟化**：可在容器或 VM 中为可信应用提供受保护的内存空间，降低侧信道攻击风险。",
      "similarity": 0.606859028339386,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/secretmem.c",
          "start_line": 262,
          "end_line": 279,
          "content": [
            "static int secretmem_init_fs_context(struct fs_context *fc)",
            "{",
            "\treturn init_pseudo(fc, SECRETMEM_MAGIC) ? 0 : -ENOMEM;",
            "}",
            "static int __init secretmem_init(void)",
            "{",
            "\tif (!secretmem_enable || !can_set_direct_map())",
            "\t\treturn 0;",
            "",
            "\tsecretmem_mnt = kern_mount(&secretmem_fs);",
            "\tif (IS_ERR(secretmem_mnt))",
            "\t\treturn PTR_ERR(secretmem_mnt);",
            "",
            "\t/* prevent secretmem mappings from ever getting PROT_EXEC */",
            "\tsecretmem_mnt->mnt_flags |= MNT_NOEXEC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "secretmem_init_fs_context, secretmem_init",
          "description": "初始化secretmem伪文件系统，通过kern_mount创建挂载点并设置MNT_NOEXEC标志，防止秘密内存区域被赋予执行权限",
          "similarity": 0.5740826725959778
        },
        {
          "chunk_id": 1,
          "file_path": "mm/secretmem.c",
          "start_line": 45,
          "end_line": 163,
          "content": [
            "bool secretmem_active(void)",
            "{",
            "\treturn !!atomic_read(&secretmem_users);",
            "}",
            "static vm_fault_t secretmem_fault(struct vm_fault *vmf)",
            "{",
            "\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;",
            "\tstruct inode *inode = file_inode(vmf->vma->vm_file);",
            "\tpgoff_t offset = vmf->pgoff;",
            "\tgfp_t gfp = vmf->gfp_mask;",
            "\tunsigned long addr;",
            "\tstruct page *page;",
            "\tstruct folio *folio;",
            "\tvm_fault_t ret;",
            "\tint err;",
            "",
            "\tif (((loff_t)vmf->pgoff << PAGE_SHIFT) >= i_size_read(inode))",
            "\t\treturn vmf_error(-EINVAL);",
            "",
            "\tfilemap_invalidate_lock_shared(mapping);",
            "",
            "retry:",
            "\tpage = find_lock_page(mapping, offset);",
            "\tif (!page) {",
            "\t\tfolio = folio_alloc(gfp | __GFP_ZERO, 0);",
            "\t\tif (!folio) {",
            "\t\t\tret = VM_FAULT_OOM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tpage = &folio->page;",
            "\t\terr = set_direct_map_invalid_noflush(page);",
            "\t\tif (err) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\tret = vmf_error(err);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\t__folio_mark_uptodate(folio);",
            "\t\terr = filemap_add_folio(mapping, folio, offset, gfp);",
            "\t\tif (unlikely(err)) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\t/*",
            "\t\t\t * If a split of large page was required, it",
            "\t\t\t * already happened when we marked the page invalid",
            "\t\t\t * which guarantees that this call won't fail",
            "\t\t\t */",
            "\t\t\tset_direct_map_default_noflush(page);",
            "\t\t\tif (err == -EEXIST)",
            "\t\t\t\tgoto retry;",
            "",
            "\t\t\tret = vmf_error(err);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\taddr = (unsigned long)page_address(page);",
            "\t\tflush_tlb_kernel_range(addr, addr + PAGE_SIZE);",
            "\t}",
            "",
            "\tvmf->page = page;",
            "\tret = VM_FAULT_LOCKED;",
            "",
            "out:",
            "\tfilemap_invalidate_unlock_shared(mapping);",
            "\treturn ret;",
            "}",
            "static int secretmem_release(struct inode *inode, struct file *file)",
            "{",
            "\tatomic_dec(&secretmem_users);",
            "\treturn 0;",
            "}",
            "static int secretmem_mmap(struct file *file, struct vm_area_struct *vma)",
            "{",
            "\tunsigned long len = vma->vm_end - vma->vm_start;",
            "",
            "\tif ((vma->vm_flags & (VM_SHARED | VM_MAYSHARE)) == 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!mlock_future_ok(vma->vm_mm, vma->vm_flags | VM_LOCKED, len))",
            "\t\treturn -EAGAIN;",
            "",
            "\tvm_flags_set(vma, VM_LOCKED | VM_DONTDUMP);",
            "\tvma->vm_ops = &secretmem_vm_ops;",
            "",
            "\treturn 0;",
            "}",
            "bool vma_is_secretmem(struct vm_area_struct *vma)",
            "{",
            "\treturn vma->vm_ops == &secretmem_vm_ops;",
            "}",
            "static int secretmem_migrate_folio(struct address_space *mapping,",
            "\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)",
            "{",
            "\treturn -EBUSY;",
            "}",
            "static void secretmem_free_folio(struct folio *folio)",
            "{",
            "\tset_direct_map_default_noflush(&folio->page);",
            "\tfolio_zero_segment(folio, 0, folio_size(folio));",
            "}",
            "static int secretmem_setattr(struct mnt_idmap *idmap,",
            "\t\t\t     struct dentry *dentry, struct iattr *iattr)",
            "{",
            "\tstruct inode *inode = d_inode(dentry);",
            "\tstruct address_space *mapping = inode->i_mapping;",
            "\tunsigned int ia_valid = iattr->ia_valid;",
            "\tint ret;",
            "",
            "\tfilemap_invalidate_lock(mapping);",
            "",
            "\tif ((ia_valid & ATTR_SIZE) && inode->i_size)",
            "\t\tret = -EINVAL;",
            "\telse",
            "\t\tret = simple_setattr(idmap, dentry, iattr);",
            "",
            "\tfilemap_invalidate_unlock(mapping);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "secretmem_active, secretmem_fault, secretmem_release, secretmem_mmap, vma_is_secretmem, secretmem_migrate_folio, secretmem_free_folio, secretmem_setattr",
          "description": "实现secretmem核心功能，包括检查是否启用、处理页面故障时分配并标记不可执行页面、管理VMA标志、验证文件属性等内存加密相关操作",
          "similarity": 0.5056469440460205
        },
        {
          "chunk_id": 0,
          "file_path": "mm/secretmem.c",
          "start_line": 1,
          "end_line": 44,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright IBM Corporation, 2021",
            " *",
            " * Author: Mike Rapoport <rppt@linux.ibm.com>",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/memfd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/printk.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/sched/signal.h>",
            "",
            "#include <uapi/linux/magic.h>",
            "",
            "#include <asm/tlbflush.h>",
            "",
            "#include \"internal.h\"",
            "",
            "#undef pr_fmt",
            "#define pr_fmt(fmt) \"secretmem: \" fmt",
            "",
            "/*",
            " * Define mode and flag masks to allow validation of the system call",
            " * parameters.",
            " */",
            "#define SECRETMEM_MODE_MASK\t(0x0)",
            "#define SECRETMEM_FLAGS_MASK\tSECRETMEM_MODE_MASK",
            "",
            "static bool secretmem_enable __ro_after_init = 1;",
            "module_param_named(enable, secretmem_enable, bool, 0400);",
            "MODULE_PARM_DESC(secretmem_enable,",
            "\t\t \"Enable secretmem and memfd_secret(2) system call\");",
            "",
            "static atomic_t secretmem_users;",
            ""
          ],
          "function_name": null,
          "description": "定义secretmem模块的许可证和基本包含头文件，声明全局变量secretmem_enable用于控制功能启用状态，并注册模块参数供外部配置",
          "similarity": 0.45307111740112305
        }
      ]
    },
    {
      "source_file": "kernel/fork.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:30:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fork.c`\n\n---\n\n# fork.c 技术文档\n\n## 1. 文件概述\n\n`fork.c` 是 Linux 内核中实现进程创建（fork）系统调用的核心源文件。该文件包含了创建新进程所需的所有辅助例程，负责复制父进程的资源（如内存、文件描述符、信号处理等）以生成子进程。虽然 fork 逻辑本身概念简单，但其涉及的内存管理（尤其是写时复制 COW 机制）极为复杂，实际内存页的复制由 `mm/memory.c` 中的 `copy_page_range()` 等函数处理。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `total_forks`: 累计系统自启动以来创建的进程总数\n- `nr_threads`: 当前系统中的线程总数（不包括 idle 线程）\n- `max_threads`: 可配置的线程数量上限（默认为 `FUTEX_TID_MASK`）\n- `process_counts`: 每 CPU 的进程计数器（per-CPU 变量）\n- `tasklist_lock`: 保护任务链表的读写锁（全局任务列表的同步原语）\n\n### 关键辅助函数\n- `nr_processes()`: 计算系统中所有进程的总数（聚合各 CPU 的 `process_counts`）\n- `arch_release_task_struct()`: 架构相关的 task_struct 释放钩子（弱符号，默认为空）\n- `alloc_task_struct_node()` / `free_task_struct()`: 分配/释放 `task_struct` 结构（基于 slab 分配器）\n- `alloc_thread_stack_node()` / `thread_stack_delayed_free()`: 分配/延迟释放线程内核栈（支持 `CONFIG_VMAP_STACK`）\n\n### 核心数据结构\n- `resident_page_types[]`: 用于内存统计的页面类型名称映射数组\n- `vm_stack`: 用于 RCU 延迟释放的虚拟内存栈封装结构\n- `cached_stacks[NR_CACHED_STACKS]`: 每 CPU 的内核栈缓存（减少频繁 vmalloc/vfree 开销）\n\n## 3. 关键实现\n\n### 进程/线程计数管理\n- 使用 per-CPU 变量 `process_counts` 避免全局锁竞争\n- 全局计数器 `nr_threads` 和 `total_forks` 由 `tasklist_lock` 保护\n- `nr_processes()` 通过遍历所有可能的 CPU 聚合计数\n\n### 内核栈分配策略（`CONFIG_VMAP_STACK`）\n- **缓存机制**：每个 CPU 缓存最多 2 个已释放的栈（`NR_CACHED_STACKS`），减少 TLB 刷新和 vmalloc 开销\n- **内存分配**：\n  - 优先从本地缓存获取栈\n  - 缓存未命中时使用 `__vmalloc_node_range()` 分配连续虚拟地址空间\n  - 显式禁用 `__GFP_ACCOUNT`（因后续手动进行 memcg 计费）\n- **安全清理**：\n  - 重用栈时清零内存（`memset(stack, 0, THREAD_SIZE)`）\n  - KASAN 消毒（`kasan_unpoison_range`）和标签重置\n- **延迟释放**：\n  - 通过 RCU 机制延迟释放栈（`call_rcu`）\n  - 释放时尝试回填缓存，失败则直接 `vfree`\n\n### 内存控制组（memcg）集成\n- 手动对栈的每个物理页进行 memcg 计费（`memcg_kmem_charge_page`）\n- 计费失败时回滚已计费页面（`memcg_kmem_uncharge_page`）\n- 确保内核栈内存纳入 cgroup 内存限制\n\n### 锁与同步\n- `tasklist_lock` 作为全局任务列表的保护锁（读写锁）\n- 提供 `lockdep_tasklist_lock_is_held()` 供 RCU 锁验证使用\n- RCU 用于安全延迟释放内核栈资源\n\n## 4. 依赖关系\n\n### 内核子系统依赖\n- **内存管理 (MM)**：`<linux/mm.h>`, `<linux/vmalloc.h>`, `<linux/memcontrol.h>`\n- **调度器 (Scheduler)**：`<linux/sched/*.h>`, 任务状态和 CPU 绑定\n- **安全模块**：`<linux/security.h>`, `<linux/capability.h>`, `<linux/seccomp.h>`\n- **命名空间**：`<linux/nsproxy.h>`（UTS, IPC, PID, 网络等）\n- **文件系统**：`<linux/fs.h>`, `<linux/fdtable.h>`（文件描述符复制）\n- **跟踪与调试**：`<trace/events/sched.h>`, `<linux/ftrace.h>`, KASAN/KMSAN\n\n### 架构相关依赖\n- `<asm/pgalloc.h>`：页表分配\n- `<asm/mmu_context.h>`：MMU 上下文切换\n- `<asm/tlbflush.h>`：TLB 刷新操作\n- 架构特定的 `THREAD_SIZE` 和栈对齐要求\n\n### 配置选项依赖\n- `CONFIG_VMAP_STACK`：启用虚拟内存分配内核栈\n- `CONFIG_PROVE_RCU`：RCU 锁验证支持\n- `CONFIG_ARCH_TASK_STRUCT_ALLOCATOR`：架构自定义 task_struct 分配器\n- `CONFIG_MEMCG_KMEM`：内核内存 cgroup 支持\n\n## 5. 使用场景\n\n### 进程创建路径\n- **系统调用入口**：`sys_fork()`, `sys_vfork()`, `sys_clone()` 最终调用 `_do_fork()`\n- **内核线程创建**：`kthread_create()` 通过 `kernel_thread()` 触发 fork 逻辑\n- **容器/命名空间初始化**：新 PID/UTS/IPC 命名空间创建时伴随进程 fork\n\n### 资源复制关键点\n- **内存描述符 (mm_struct)**：通过 `dup_mm()` 复制地址空间（COW 页表）\n- **文件描述符表**：`dup_fd()` 复制打开文件表\n- **信号处理**：复制信号掩码和处理函数\n- **POSIX 定时器/异步 I/O**：复制相关上下文（如 `aio`, `posix-timers`）\n\n### 特殊场景处理\n- **写时复制优化**：避免物理内存立即复制，提升 fork 性能\n- **OOM Killer 集成**：在内存不足时参与进程选择\n- **审计与监控**：通过 `audit_alloc()` 和 `proc` 文件系统暴露进程信息\n- **实时性保障**：RT 任务 fork 时保持调度策略和优先级",
      "similarity": 0.6068122386932373,
      "chunks": [
        {
          "chunk_id": 12,
          "file_path": "kernel/fork.c",
          "start_line": 2176,
          "end_line": 2282,
          "content": [
            "static void rv_task_fork(struct task_struct *p)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++)",
            "\t\tp->rv[i].da_mon.monitoring = false;",
            "}",
            "static inline void init_idle_pids(struct task_struct *idle)",
            "{",
            "\tenum pid_type type;",
            "",
            "\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {",
            "\t\tINIT_HLIST_NODE(&idle->pid_links[type]); /* not really needed */",
            "\t\tinit_task_pid(idle, type, &init_struct_pid);",
            "\t}",
            "}",
            "static int idle_dummy(void *dummy)",
            "{",
            "\t/* This function is never called */",
            "\treturn 0;",
            "}",
            "pid_t kernel_clone(struct kernel_clone_args *args)",
            "{",
            "\tu64 clone_flags = args->flags;",
            "\tstruct completion vfork;",
            "\tstruct pid *pid;",
            "\tstruct task_struct *p;",
            "\tint trace = 0;",
            "\tpid_t nr;",
            "",
            "\t/*",
            "\t * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument",
            "\t * to return the pidfd. Hence, CLONE_PIDFD and CLONE_PARENT_SETTID are",
            "\t * mutually exclusive. With clone3() CLONE_PIDFD has grown a separate",
            "\t * field in struct clone_args and it still doesn't make sense to have",
            "\t * them both point at the same memory location. Performing this check",
            "\t * here has the advantage that we don't need to have a separate helper",
            "\t * to check for legacy clone().",
            "\t */",
            "\tif ((args->flags & CLONE_PIDFD) &&",
            "\t    (args->flags & CLONE_PARENT_SETTID) &&",
            "\t    (args->pidfd == args->parent_tid))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Determine whether and which event to report to ptracer.  When",
            "\t * called from kernel_thread or CLONE_UNTRACED is explicitly",
            "\t * requested, no event is reported; otherwise, report if the event",
            "\t * for the type of forking is enabled.",
            "\t */",
            "\tif (!(clone_flags & CLONE_UNTRACED)) {",
            "\t\tif (clone_flags & CLONE_VFORK)",
            "\t\t\ttrace = PTRACE_EVENT_VFORK;",
            "\t\telse if (args->exit_signal != SIGCHLD)",
            "\t\t\ttrace = PTRACE_EVENT_CLONE;",
            "\t\telse",
            "\t\t\ttrace = PTRACE_EVENT_FORK;",
            "",
            "\t\tif (likely(!ptrace_event_enabled(current, trace)))",
            "\t\t\ttrace = 0;",
            "\t}",
            "",
            "\tp = copy_process(NULL, trace, NUMA_NO_NODE, args);",
            "\tadd_latent_entropy();",
            "",
            "\tif (IS_ERR(p))",
            "\t\treturn PTR_ERR(p);",
            "",
            "\t/*",
            "\t * Do this prior waking up the new thread - the thread pointer",
            "\t * might get invalid after that point, if the thread exits quickly.",
            "\t */",
            "\ttrace_sched_process_fork(current, p);",
            "",
            "\tpid = get_task_pid(p, PIDTYPE_PID);",
            "\tnr = pid_vnr(pid);",
            "",
            "\tif (clone_flags & CLONE_PARENT_SETTID)",
            "\t\tput_user(nr, args->parent_tid);",
            "",
            "\tif (clone_flags & CLONE_VFORK) {",
            "\t\tp->vfork_done = &vfork;",
            "\t\tinit_completion(&vfork);",
            "\t\tget_task_struct(p);",
            "\t}",
            "",
            "\tif (IS_ENABLED(CONFIG_LRU_GEN_WALKS_MMU) && !(clone_flags & CLONE_VM)) {",
            "\t\t/* lock the task to synchronize with memcg migration */",
            "\t\ttask_lock(p);",
            "\t\tlru_gen_add_mm(p->mm);",
            "\t\ttask_unlock(p);",
            "\t}",
            "",
            "\twake_up_new_task(p);",
            "",
            "\t/* forking complete and child started to run, tell ptracer */",
            "\tif (unlikely(trace))",
            "\t\tptrace_event_pid(trace, pid);",
            "",
            "\tif (clone_flags & CLONE_VFORK) {",
            "\t\tif (!wait_for_vfork_done(p, &vfork))",
            "\t\t\tptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);",
            "\t}",
            "",
            "\tput_pid(pid);",
            "\treturn nr;",
            "}"
          ],
          "function_name": "rv_task_fork, init_idle_pids, idle_dummy, kernel_clone",
          "description": "实现kernel_clone核心逻辑，创建新进程并处理克隆标志，管理子进程启动、vfork等待及进程树遍历，包含空闲任务PID初始化与RV监控器重置",
          "similarity": 0.562961995601654
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/fork.c",
          "start_line": 666,
          "end_line": 845,
          "content": [
            "static __latent_entropy int dup_mmap(struct mm_struct *mm,",
            "\t\t\t\t\tstruct mm_struct *oldmm)",
            "{",
            "\tstruct vm_area_struct *mpnt, *tmp;",
            "\tint retval;",
            "\tunsigned long charge = 0;",
            "\tLIST_HEAD(uf);",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\tuprobe_start_dup_mmap();",
            "\tif (mmap_write_lock_killable(oldmm)) {",
            "\t\tretval = -EINTR;",
            "\t\tgoto fail_uprobe_end;",
            "\t}",
            "\tflush_cache_dup_mm(oldmm);",
            "\tuprobe_dup_mmap(oldmm, mm);",
            "\t/*",
            "\t * Not linked in yet - no deadlock potential:",
            "\t */",
            "\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);",
            "",
            "\t/* No ordering required: file already has been exposed. */",
            "\tdup_mm_exe_file(mm, oldmm);",
            "",
            "\tmm->total_vm = oldmm->total_vm;",
            "\tmm->data_vm = oldmm->data_vm;",
            "\tmm->exec_vm = oldmm->exec_vm;",
            "\tmm->stack_vm = oldmm->stack_vm;",
            "",
            "\t/* Use __mt_dup() to efficiently build an identical maple tree. */",
            "\tretval = __mt_dup(&oldmm->mm_mt, &mm->mm_mt, GFP_KERNEL);",
            "\tif (unlikely(retval))",
            "\t\tgoto out;",
            "",
            "\tmt_clear_in_rcu(vmi.mas.tree);",
            "\tfor_each_vma(vmi, mpnt) {",
            "\t\tstruct file *file;",
            "",
            "\t\tvma_start_write(mpnt);",
            "\t\tif (mpnt->vm_flags & VM_DONTCOPY) {",
            "\t\t\tretval = vma_iter_clear_gfp(&vmi, mpnt->vm_start,",
            "\t\t\t\t\t\t    mpnt->vm_end, GFP_KERNEL);",
            "\t\t\tif (retval)",
            "\t\t\t\tgoto loop_out;",
            "",
            "\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tcharge = 0;",
            "\t\t/*",
            "\t\t * Don't duplicate many vmas if we've been oom-killed (for",
            "\t\t * example)",
            "\t\t */",
            "\t\tif (fatal_signal_pending(current)) {",
            "\t\t\tretval = -EINTR;",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t\tif (mpnt->vm_flags & VM_ACCOUNT) {",
            "\t\t\tunsigned long len = vma_pages(mpnt);",
            "",
            "\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */",
            "\t\t\t\tgoto fail_nomem;",
            "\t\t\tcharge = len;",
            "\t\t}",
            "\t\ttmp = vm_area_dup(mpnt);",
            "\t\tif (!tmp)",
            "\t\t\tgoto fail_nomem;",
            "",
            "\t\t/* track_pfn_copy() will later take care of copying internal state. */",
            "\t\tif (unlikely(tmp->vm_flags & VM_PFNMAP))",
            "\t\t\tuntrack_pfn_clear(tmp);",
            "",
            "\t\tretval = vma_dup_policy(mpnt, tmp);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_policy;",
            "\t\ttmp->vm_mm = mm;",
            "\t\tretval = dup_userfaultfd(tmp, &uf);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tif (tmp->vm_flags & VM_WIPEONFORK) {",
            "\t\t\t/*",
            "\t\t\t * VM_WIPEONFORK gets a clean slate in the child.",
            "\t\t\t * Don't prepare anon_vma until fault since we don't",
            "\t\t\t * copy page for current vma.",
            "\t\t\t */",
            "\t\t\ttmp->anon_vma = NULL;",
            "\t\t} else if (anon_vma_fork(tmp, mpnt))",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tvm_flags_clear(tmp, VM_LOCKED_MASK);",
            "\t\tfile = tmp->vm_file;",
            "\t\tif (file) {",
            "\t\t\tstruct address_space *mapping = file->f_mapping;",
            "",
            "\t\t\tget_file(file);",
            "\t\t\ti_mmap_lock_write(mapping);",
            "\t\t\tif (vma_is_shared_maywrite(tmp))",
            "\t\t\t\tmapping_allow_writable(mapping);",
            "\t\t\tflush_dcache_mmap_lock(mapping);",
            "\t\t\t/* insert tmp into the share list, just after mpnt */",
            "\t\t\tvma_interval_tree_insert_after(tmp, mpnt,",
            "\t\t\t\t\t&mapping->i_mmap);",
            "\t\t\tflush_dcache_mmap_unlock(mapping);",
            "\t\t\ti_mmap_unlock_write(mapping);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Copy/update hugetlb private vma information.",
            "\t\t */",
            "\t\tif (is_vm_hugetlb_page(tmp))",
            "\t\t\thugetlb_dup_vma_private(tmp);",
            "",
            "\t\t/*",
            "\t\t * Link the vma into the MT. After using __mt_dup(), memory",
            "\t\t * allocation is not necessary here, so it cannot fail.",
            "\t\t */",
            "\t\tvma_iter_bulk_store(&vmi, tmp);",
            "",
            "\t\tmm->map_count++;",
            "\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))",
            "\t\t\tretval = copy_page_range(tmp, mpnt);",
            "",
            "\t\tif (tmp->vm_ops && tmp->vm_ops->open)",
            "\t\t\ttmp->vm_ops->open(tmp);",
            "",
            "\t\tif (retval) {",
            "\t\t\tmpnt = vma_next(&vmi);",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t}",
            "\t/* a new mm has just been created */",
            "\tretval = arch_dup_mmap(oldmm, mm);",
            "loop_out:",
            "\tvma_iter_free(&vmi);",
            "\tif (!retval) {",
            "\t\tmt_set_in_rcu(vmi.mas.tree);",
            "\t\tksm_fork(mm, oldmm);",
            "\t\tkhugepaged_fork(mm, oldmm);",
            "\t} else {",
            "",
            "\t\t/*",
            "\t\t * The entire maple tree has already been duplicated. If the",
            "\t\t * mmap duplication fails, mark the failure point with",
            "\t\t * XA_ZERO_ENTRY. In exit_mmap(), if this marker is encountered,",
            "\t\t * stop releasing VMAs that have not been duplicated after this",
            "\t\t * point.",
            "\t\t */",
            "\t\tif (mpnt) {",
            "\t\t\tmas_set_range(&vmi.mas, mpnt->vm_start, mpnt->vm_end - 1);",
            "\t\t\tmas_store(&vmi.mas, XA_ZERO_ENTRY);",
            "\t\t\t/* Avoid OOM iterating a broken tree */",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t}",
            "\t\t/*",
            "\t\t * The mm_struct is going to exit, but the locks will be dropped",
            "\t\t * first.  Set the mm_struct as unstable is advisable as it is",
            "\t\t * not fully initialised.",
            "\t\t */",
            "\t\tset_bit(MMF_UNSTABLE, &mm->flags);",
            "\t}",
            "out:",
            "\tmmap_write_unlock(mm);",
            "\tflush_tlb_mm(oldmm);",
            "\tmmap_write_unlock(oldmm);",
            "\tif (!retval)",
            "\t\tdup_userfaultfd_complete(&uf);",
            "\telse",
            "\t\tdup_userfaultfd_fail(&uf);",
            "fail_uprobe_end:",
            "\tuprobe_end_dup_mmap();",
            "\treturn retval;",
            "",
            "fail_nomem_anon_vma_fork:",
            "\tmpol_put(vma_policy(tmp));",
            "fail_nomem_policy:",
            "\tvm_area_free(tmp);",
            "fail_nomem:",
            "\tretval = -ENOMEM;",
            "\tvm_unacct_memory(charge);",
            "\tgoto loop_out;",
            "}"
          ],
          "function_name": "dup_mmap",
          "description": "实现进程fork时的内存映射复制逻辑，深度遍历原进程的VMA结构创建副本，处理共享文件映射、hugetlb页等特殊内存类型，并管理OOM异常情况下的失败恢复。",
          "similarity": 0.5624086856842041
        },
        {
          "chunk_id": 13,
          "file_path": "kernel/fork.c",
          "start_line": 2924,
          "end_line": 3037,
          "content": [
            "pid_t kernel_thread(int (*fn)(void *), void *arg, const char *name,",
            "\t\t    unsigned long flags)",
            "{",
            "\tstruct kernel_clone_args args = {",
            "\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |",
            "\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),",
            "\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),",
            "\t\t.fn\t\t= fn,",
            "\t\t.fn_arg\t\t= arg,",
            "\t\t.name\t\t= name,",
            "\t\t.kthread\t= 1,",
            "\t};",
            "",
            "\treturn kernel_clone(&args);",
            "}",
            "pid_t user_mode_thread(int (*fn)(void *), void *arg, unsigned long flags)",
            "{",
            "\tstruct kernel_clone_args args = {",
            "\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |",
            "\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),",
            "\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),",
            "\t\t.fn\t\t= fn,",
            "\t\t.fn_arg\t\t= arg,",
            "\t};",
            "",
            "\treturn kernel_clone(&args);",
            "}",
            "noinline static int copy_clone_args_from_user(struct kernel_clone_args *kargs,",
            "\t\t\t\t\t      struct clone_args __user *uargs,",
            "\t\t\t\t\t      size_t usize)",
            "{",
            "\tint err;",
            "\tstruct clone_args args;",
            "\tpid_t *kset_tid = kargs->set_tid;",
            "",
            "\tBUILD_BUG_ON(offsetofend(struct clone_args, tls) !=",
            "\t\t     CLONE_ARGS_SIZE_VER0);",
            "\tBUILD_BUG_ON(offsetofend(struct clone_args, set_tid_size) !=",
            "\t\t     CLONE_ARGS_SIZE_VER1);",
            "\tBUILD_BUG_ON(offsetofend(struct clone_args, cgroup) !=",
            "\t\t     CLONE_ARGS_SIZE_VER2);",
            "\tBUILD_BUG_ON(sizeof(struct clone_args) != CLONE_ARGS_SIZE_VER2);",
            "",
            "\tif (unlikely(usize > PAGE_SIZE))",
            "\t\treturn -E2BIG;",
            "\tif (unlikely(usize < CLONE_ARGS_SIZE_VER0))",
            "\t\treturn -EINVAL;",
            "",
            "\terr = copy_struct_from_user(&args, sizeof(args), uargs, usize);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (unlikely(args.set_tid_size > MAX_PID_NS_LEVEL))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(!args.set_tid && args.set_tid_size > 0))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(args.set_tid && args.set_tid_size == 0))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Verify that higher 32bits of exit_signal are unset and that",
            "\t * it is a valid signal",
            "\t */",
            "\tif (unlikely((args.exit_signal & ~((u64)CSIGNAL)) ||",
            "\t\t     !valid_signal(args.exit_signal)))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((args.flags & CLONE_INTO_CGROUP) &&",
            "\t    (args.cgroup > INT_MAX || usize < CLONE_ARGS_SIZE_VER2))",
            "\t\treturn -EINVAL;",
            "",
            "\t*kargs = (struct kernel_clone_args){",
            "\t\t.flags\t\t= args.flags,",
            "\t\t.pidfd\t\t= u64_to_user_ptr(args.pidfd),",
            "\t\t.child_tid\t= u64_to_user_ptr(args.child_tid),",
            "\t\t.parent_tid\t= u64_to_user_ptr(args.parent_tid),",
            "\t\t.exit_signal\t= args.exit_signal,",
            "\t\t.stack\t\t= args.stack,",
            "\t\t.stack_size\t= args.stack_size,",
            "\t\t.tls\t\t= args.tls,",
            "\t\t.set_tid_size\t= args.set_tid_size,",
            "\t\t.cgroup\t\t= args.cgroup,",
            "\t};",
            "",
            "\tif (args.set_tid &&",
            "\t\tcopy_from_user(kset_tid, u64_to_user_ptr(args.set_tid),",
            "\t\t\t(kargs->set_tid_size * sizeof(pid_t))))",
            "\t\treturn -EFAULT;",
            "",
            "\tkargs->set_tid = kset_tid;",
            "",
            "\treturn 0;",
            "}",
            "static inline bool clone3_stack_valid(struct kernel_clone_args *kargs)",
            "{",
            "\tif (kargs->stack == 0) {",
            "\t\tif (kargs->stack_size > 0)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\tif (kargs->stack_size == 0)",
            "\t\t\treturn false;",
            "",
            "\t\tif (!access_ok((void __user *)kargs->stack, kargs->stack_size))",
            "\t\t\treturn false;",
            "",
            "#if !defined(CONFIG_STACK_GROWSUP)",
            "\t\tkargs->stack += kargs->stack_size;",
            "#endif",
            "\t}",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "kernel_thread, user_mode_thread, copy_clone_args_from_user, clone3_stack_valid",
          "description": "提供内核线程与用户线程创建接口，解析并验证clone3参数，转换用户空间clone_args到内核结构体，校验栈地址有效性",
          "similarity": 0.5461986660957336
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/fork.c",
          "start_line": 847,
          "end_line": 965,
          "content": [
            "static inline int mm_alloc_pgd(struct mm_struct *mm)",
            "{",
            "\tmm->pgd = pgd_alloc(mm);",
            "\tif (unlikely(!mm->pgd))",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static inline void mm_free_pgd(struct mm_struct *mm)",
            "{",
            "\tpgd_free(mm, mm->pgd);",
            "}",
            "static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)",
            "{",
            "\tmmap_write_lock(oldmm);",
            "\tdup_mm_exe_file(mm, oldmm);",
            "\tmmap_write_unlock(oldmm);",
            "\treturn 0;",
            "}",
            "static void check_mm(struct mm_struct *mm)",
            "{",
            "\tint i;",
            "",
            "\tBUILD_BUG_ON_MSG(ARRAY_SIZE(resident_page_types) != NR_MM_COUNTERS,",
            "\t\t\t \"Please make sure 'struct resident_page_types[]' is updated as well\");",
            "",
            "\tfor (i = 0; i < NR_MM_COUNTERS; i++) {",
            "\t\tlong x = percpu_counter_sum(&mm->rss_stat[i]);",
            "",
            "\t\tif (unlikely(x))",
            "\t\t\tpr_alert(\"BUG: Bad rss-counter state mm:%p type:%s val:%ld\\n\",",
            "\t\t\t\t mm, resident_page_types[i], x);",
            "\t}",
            "",
            "\tif (mm_pgtables_bytes(mm))",
            "\t\tpr_alert(\"BUG: non-zero pgtables_bytes on freeing mm: %ld\\n\",",
            "\t\t\t\tmm_pgtables_bytes(mm));",
            "",
            "#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !defined(CONFIG_SPLIT_PMD_PTLOCKS)",
            "\tVM_BUG_ON_MM(mm->pmd_huge_pte, mm);",
            "#endif",
            "}",
            "static void do_check_lazy_tlb(void *arg)",
            "{",
            "\tstruct mm_struct *mm = arg;",
            "",
            "\tWARN_ON_ONCE(current->active_mm == mm);",
            "}",
            "static void do_shoot_lazy_tlb(void *arg)",
            "{",
            "\tstruct mm_struct *mm = arg;",
            "",
            "\tif (current->active_mm == mm) {",
            "\t\tWARN_ON_ONCE(current->mm);",
            "\t\tcurrent->active_mm = &init_mm;",
            "\t\tswitch_mm(mm, &init_mm, current);",
            "\t}",
            "}",
            "static void cleanup_lazy_tlbs(struct mm_struct *mm)",
            "{",
            "\tif (!IS_ENABLED(CONFIG_MMU_LAZY_TLB_SHOOTDOWN)) {",
            "\t\t/*",
            "\t\t * In this case, lazy tlb mms are refounted and would not reach",
            "\t\t * __mmdrop until all CPUs have switched away and mmdrop()ed.",
            "\t\t */",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Lazy mm shootdown does not refcount \"lazy tlb mm\" usage, rather it",
            "\t * requires lazy mm users to switch to another mm when the refcount",
            "\t * drops to zero, before the mm is freed. This requires IPIs here to",
            "\t * switch kernel threads to init_mm.",
            "\t *",
            "\t * archs that use IPIs to flush TLBs can piggy-back that lazy tlb mm",
            "\t * switch with the final userspace teardown TLB flush which leaves the",
            "\t * mm lazy on this CPU but no others, reducing the need for additional",
            "\t * IPIs here. There are cases where a final IPI is still required here,",
            "\t * such as the final mmdrop being performed on a different CPU than the",
            "\t * one exiting, or kernel threads using the mm when userspace exits.",
            "\t *",
            "\t * IPI overheads have not found to be expensive, but they could be",
            "\t * reduced in a number of possible ways, for example (roughly",
            "\t * increasing order of complexity):",
            "\t * - The last lazy reference created by exit_mm() could instead switch",
            "\t *   to init_mm, however it's probable this will run on the same CPU",
            "\t *   immediately afterwards, so this may not reduce IPIs much.",
            "\t * - A batch of mms requiring IPIs could be gathered and freed at once.",
            "\t * - CPUs store active_mm where it can be remotely checked without a",
            "\t *   lock, to filter out false-positives in the cpumask.",
            "\t * - After mm_users or mm_count reaches zero, switching away from the",
            "\t *   mm could clear mm_cpumask to reduce some IPIs, perhaps together",
            "\t *   with some batching or delaying of the final IPIs.",
            "\t * - A delayed freeing and RCU-like quiescing sequence based on mm",
            "\t *   switching to avoid IPIs completely.",
            "\t */",
            "\ton_each_cpu_mask(mm_cpumask(mm), do_shoot_lazy_tlb, (void *)mm, 1);",
            "\tif (IS_ENABLED(CONFIG_DEBUG_VM_SHOOT_LAZIES))",
            "\t\ton_each_cpu(do_check_lazy_tlb, (void *)mm, 1);",
            "}",
            "void __mmdrop(struct mm_struct *mm)",
            "{",
            "\tBUG_ON(mm == &init_mm);",
            "\tWARN_ON_ONCE(mm == current->mm);",
            "",
            "\t/* Ensure no CPUs are using this as their lazy tlb mm */",
            "\tcleanup_lazy_tlbs(mm);",
            "",
            "\tWARN_ON_ONCE(mm == current->active_mm);",
            "\tmm_free_pgd(mm);",
            "\tdestroy_context(mm);",
            "\tmmu_notifier_subscriptions_destroy(mm);",
            "\tcheck_mm(mm);",
            "\tput_user_ns(mm->user_ns);",
            "\tmm_pasid_drop(mm);",
            "\tmm_destroy_cid(mm);",
            "\tpercpu_counter_destroy_many(mm->rss_stat, NR_MM_COUNTERS);",
            "",
            "\tfree_mm(mm);",
            "}"
          ],
          "function_name": "mm_alloc_pgd, mm_free_pgd, dup_mmap, check_mm, do_check_lazy_tlb, do_shoot_lazy_tlb, cleanup_lazy_tlbs, __mmdrop",
          "description": "实现mm结构体的页目录表分配与释放，dup_mmap复制mmap信息，check_mm验证内存计数器状态，清理延迟TLB射杀并安全释放mm资源。",
          "similarity": 0.5345615148544312
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/fork.c",
          "start_line": 1710,
          "end_line": 1810,
          "content": [
            "void exit_mm_release(struct task_struct *tsk, struct mm_struct *mm)",
            "{",
            "\tfutex_exit_release(tsk);",
            "\tmm_release(tsk, mm);",
            "}",
            "void exec_mm_release(struct task_struct *tsk, struct mm_struct *mm)",
            "{",
            "\tfutex_exec_release(tsk);",
            "\tmm_release(tsk, mm);",
            "}",
            "static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)",
            "{",
            "\tstruct mm_struct *mm, *oldmm;",
            "",
            "\ttsk->min_flt = tsk->maj_flt = 0;",
            "\ttsk->nvcsw = tsk->nivcsw = 0;",
            "#ifdef CONFIG_DETECT_HUNG_TASK",
            "\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;",
            "\ttsk->last_switch_time = 0;",
            "#endif",
            "",
            "\ttsk->mm = NULL;",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(tsk, NULL);",
            "\t#endif",
            "\ttsk->active_mm = NULL;",
            "",
            "\t/*",
            "\t * Are we cloning a kernel thread?",
            "\t *",
            "\t * We need to steal a active VM for that..",
            "\t */",
            "\toldmm = current->mm;",
            "\tif (!oldmm)",
            "\t\treturn 0;",
            "",
            "\tif (clone_flags & CLONE_VM) {",
            "\t\tmmget(oldmm);",
            "\t\tmm = oldmm;",
            "\t} else {",
            "\t\tmm = dup_mm(tsk, current->mm);",
            "\t\tif (!mm)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\ttsk->mm = mm;",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(tsk, mm->pgd);",
            "\t#endif",
            "\ttsk->active_mm = mm;",
            "\tsched_mm_cid_fork(tsk);",
            "\treturn 0;",
            "}",
            "static int copy_fs(unsigned long clone_flags, struct task_struct *tsk)",
            "{",
            "\tstruct fs_struct *fs = current->fs;",
            "\tif (clone_flags & CLONE_FS) {",
            "\t\t/* tsk->fs is already what we want */",
            "\t\tspin_lock(&fs->lock);",
            "\t\tif (fs->in_exec) {",
            "\t\t\tspin_unlock(&fs->lock);",
            "\t\t\treturn -EAGAIN;",
            "\t\t}",
            "\t\tfs->users++;",
            "\t\tspin_unlock(&fs->lock);",
            "\t\treturn 0;",
            "\t}",
            "\ttsk->fs = copy_fs_struct(fs);",
            "\tif (!tsk->fs)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static int copy_files(unsigned long clone_flags, struct task_struct *tsk,",
            "\t\t      int no_files)",
            "{",
            "\tstruct files_struct *oldf, *newf;",
            "",
            "\t/*",
            "\t * A background process may not have any files ...",
            "\t */",
            "\toldf = current->files;",
            "\tif (!oldf)",
            "\t\treturn 0;",
            "",
            "\tif (no_files) {",
            "\t\ttsk->files = NULL;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (clone_flags & CLONE_FILES) {",
            "\t\tatomic_inc(&oldf->count);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tnewf = dup_fd(oldf, NULL);",
            "\tif (IS_ERR(newf))",
            "\t\treturn PTR_ERR(newf);",
            "",
            "\ttsk->files = newf;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "exit_mm_release, exec_mm_release, copy_mm, copy_fs, copy_files",
          "description": "处理进程退出时的mm释放流程，复制mm结构体及其相关资源（文件系统、文件描述符），支持CLONE_VM等克隆标志的差异化处理。",
          "similarity": 0.5194215774536133
        }
      ]
    }
  ]
}