{
  "query": "signal delivery mechanism",
  "timestamp": "2025-12-26 00:40:52",
  "retrieved_files": [
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5637216567993164,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5456364154815674
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.5051988363265991
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.487369567155838
        }
      ]
    },
    {
      "source_file": "kernel/signal.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:24:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `signal.c`\n\n---\n\n# signal.c 技术文档\n\n## 1. 文件概述\n\n`signal.c` 是 Linux 内核中信号子系统的核心实现文件，负责管理进程间信号的发送、接收、排队、处理以及相关状态的维护。该文件实现了 POSIX 信号语义，包括标准信号和实时信号（通过 sigqueue），并处理信号的阻塞、忽略、默认行为及用户自定义处理函数的调用逻辑。它还集成了对 ptrace 调试、作业控制（job control）、冻结（freezer）和 cgroup 等子系统的支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `sigqueue_cachep`：用于分配 `sigqueue` 结构的 slab 缓存，支持可靠信号排队。\n- `task_struct::pending`：每个任务私有的挂起信号队列。\n- `signal_struct::shared_pending`：线程组共享的挂起信号队列。\n- `task_struct::blocked` / `real_blocked`：信号阻塞掩码。\n- `task_struct::jobctl`：作业控制相关状态位（如停止、陷阱等）。\n\n### 主要函数\n- `sig_handler()`：获取指定信号的处理函数指针。\n- `sig_handler_ignored()`：判断信号是否被显式或隐式忽略。\n- `sig_task_ignored()` / `sig_ignored()`：判断任务是否忽略某信号（考虑 init、kthread、ptrace 等特殊情况）。\n- `has_pending_signals()`：检查在给定阻塞掩码下是否存在可投递的挂起信号。\n- `recalc_sigpending_tsk()` / `recalc_sigpending()` / `recalc_sigpending_and_wake()`：重新计算并设置 `TIF_SIGPENDING` 线程标志。\n- `next_signal()`：从挂起信号中选择下一个应被处理的信号，优先处理同步信号（如 SIGSEGV、SIGILL 等）。\n- `task_set_jobctl_pending()`：设置任务的作业控制挂起状态（如停止请求）。\n- `task_clear_jobctl_trapping()`：清除作业控制陷阱状态并唤醒跟踪者（ptracer）。\n- `print_dropped_signal()`：当日志开启且达到 `RLIMIT_SIGPENDING` 限制时，记录被丢弃的信号。\n\n## 3. 关键实现\n\n### 信号忽略逻辑\n信号是否被忽略不仅取决于处理函数是否为 `SIG_IGN` 或默认且内核定义为可忽略（`sig_kernel_ignore()`），还需考虑：\n- 全局 init 进程不能接收 `SIGKILL`/`SIGSTOP`。\n- `SIGNAL_UNKILLABLE` 任务对默认处理的内核信号有特殊豁免。\n- 内核线程（`PF_KTHREAD`）仅响应强制（`force=true`）的内核信号。\n- 若任务被 ptrace 跟踪，除 `SIGKILL` 外，即使信号被忽略也需通知调试器。\n\n### 挂起信号检测优化\n`has_pending_signals()` 使用位运算高效检查 `signal & ~blocked` 是否非零，并针对 `_NSIG_WORDS` 的常见值（1、2、4）进行展开优化，避免循环开销。\n\n### 信号选择策略\n`next_signal()` 优先处理同步信号（定义在 `SYNCHRONOUS_MASK` 中），确保如段错误、非法指令等异常能被及时响应，符合 POSIX 对同步信号“立即投递”的要求。\n\n### TIF_SIGPENDING 标志管理\n- `recalc_sigpending_tsk()` 综合检查私有/共享挂起信号、作业控制状态和 cgroup 冻结状态，决定是否设置 `TIF_SIGPENDING`。\n- 为避免竞态，**不清除**该标志，仅由明确知道安全的调用者（如 `recalc_sigpending()`）在适当上下文中清除。\n- `recalc_sigpending_and_wake()` 在设置标志后主动唤醒任务，确保其能及时处理信号。\n\n### 作业控制集成\n通过 `jobctl` 字段和 `JOBCTL_*` 位掩码，支持 ptrace 和作业控制的复杂状态机（如停止、陷阱、信号消费），并在 `siglock` 保护下安全更新。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`thread_info` 标志（如 `TIF_SIGPENDING`）、`PF_EXITING` 等。\n- **内存管理**：使用 slab 分配器（`kmem_cache`）管理 `sigqueue`。\n- **进程管理**：与 `fork`/`exec`/`exit` 流程交互（如 `calculate_sigpending` 在 fork 后调用）。\n- **ptrace**：通过 `ptrace` 字段和 `JOBCTL_TRAPPING` 支持调试器信号拦截。\n- **cgroup/freezer**：检查 `cgroup_task_frozen()` 状态影响信号挂起判断。\n- **安全模块**：通过 `security_task_kill()` 等钩子（虽未在片段中体现，但完整文件包含）。\n- **tracepoint**：定义 `trace/events/signal.h` 中的跟踪点用于调试。\n- **架构相关代码**：依赖 `asm/siginfo.h`、`uaccess.h` 等处理用户空间信号帧。\n\n## 5. 使用场景\n\n- **系统调用处理**：`kill()`、`tkill()`、`rt_sigqueueinfo()` 等信号发送系统调用最终调用本文件逻辑。\n- **异常处理**：CPU 异常（如页错误、除零）触发同步信号（SIGSEGV、SIGFPE），由本文件选择并准备投递。\n- **进程生命周期管理**：在 `do_exit()`、`flush_old_exec()` 等路径中清理或重置信号状态。\n- **调试器支持**：ptrace 在注入信号或单步执行时依赖作业控制状态和信号忽略逻辑。\n- **资源限制**：当信号队列达到 `RLIMIT_SIGPENDING` 限制时，调用 `print_dropped_signal()` 记录丢弃事件。\n- **冻结/恢复**：cgroup freezer 或 suspend 流程通过 `cgroup_task_frozen()` 影响信号挂起状态，确保任务在冻结期间不处理信号。",
      "similarity": 0.5415340662002563,
      "chunks": [
        {
          "chunk_id": 23,
          "file_path": "kernel/signal.c",
          "start_line": 3620,
          "end_line": 3730,
          "content": [
            "static int __copy_siginfo_from_user32(int signo, struct kernel_siginfo *to,",
            "\t\t\t\t      const struct compat_siginfo __user *ufrom)",
            "{",
            "\tstruct compat_siginfo from;",
            "",
            "\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))",
            "\t\treturn -EFAULT;",
            "",
            "\tfrom.si_signo = signo;",
            "\treturn post_copy_siginfo_from_user32(to, &from);",
            "}",
            "int copy_siginfo_from_user32(struct kernel_siginfo *to,",
            "\t\t\t     const struct compat_siginfo __user *ufrom)",
            "{",
            "\tstruct compat_siginfo from;",
            "",
            "\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn post_copy_siginfo_from_user32(to, &from);",
            "}",
            "static int do_sigtimedwait(const sigset_t *which, kernel_siginfo_t *info,",
            "\t\t    const struct timespec64 *ts)",
            "{",
            "\tktime_t *to = NULL, timeout = KTIME_MAX;",
            "\tstruct task_struct *tsk = current;",
            "\tsigset_t mask = *which;",
            "\tenum pid_type type;",
            "\tint sig, ret = 0;",
            "",
            "\tif (ts) {",
            "\t\tif (!timespec64_valid(ts))",
            "\t\t\treturn -EINVAL;",
            "\t\ttimeout = timespec64_to_ktime(*ts);",
            "\t\tto = &timeout;",
            "\t}",
            "",
            "\t/*",
            "\t * Invert the set of allowed signals to get those we want to block.",
            "\t */",
            "\tsigdelsetmask(&mask, sigmask(SIGKILL) | sigmask(SIGSTOP));",
            "\tsignotset(&mask);",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "\tsig = dequeue_signal(tsk, &mask, info, &type);",
            "\tif (!sig && timeout) {",
            "\t\t/*",
            "\t\t * None ready, temporarily unblock those we're interested",
            "\t\t * while we are sleeping in so that we'll be awakened when",
            "\t\t * they arrive. Unblocking is always fine, we can avoid",
            "\t\t * set_current_blocked().",
            "\t\t */",
            "\t\ttsk->real_blocked = tsk->blocked;",
            "\t\tsigandsets(&tsk->blocked, &tsk->blocked, &mask);",
            "\t\trecalc_sigpending();",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\t\t__set_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE);",
            "\t\tret = schedule_hrtimeout_range(to, tsk->timer_slack_ns,",
            "\t\t\t\t\t       HRTIMER_MODE_REL);",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\t__set_task_blocked(tsk, &tsk->real_blocked);",
            "\t\tsigemptyset(&tsk->real_blocked);",
            "\t\tsig = dequeue_signal(tsk, &mask, info, &type);",
            "\t}",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tif (sig)",
            "\t\treturn sig;",
            "\treturn ret ? -EINTR : -EAGAIN;",
            "}",
            "static void prepare_kill_siginfo(int sig, struct kernel_siginfo *info,",
            "\t\t\t\t enum pid_type type)",
            "{",
            "\tclear_siginfo(info);",
            "\tinfo->si_signo = sig;",
            "\tinfo->si_errno = 0;",
            "\tinfo->si_code = (type == PIDTYPE_PID) ? SI_TKILL : SI_USER;",
            "\tinfo->si_pid = task_tgid_vnr(current);",
            "\tinfo->si_uid = from_kuid_munged(current_user_ns(), current_uid());",
            "}",
            "static bool access_pidfd_pidns(struct pid *pid)",
            "{",
            "\tstruct pid_namespace *active = task_active_pid_ns(current);",
            "\tstruct pid_namespace *p = ns_of_pid(pid);",
            "",
            "\tfor (;;) {",
            "\t\tif (!p)",
            "\t\t\treturn false;",
            "\t\tif (p == active)",
            "\t\t\tbreak;",
            "\t\tp = p->parent;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,",
            "\t\tsiginfo_t __user *info)",
            "{",
            "#ifdef CONFIG_COMPAT",
            "\t/*",
            "\t * Avoid hooking up compat syscalls and instead handle necessary",
            "\t * conversions here. Note, this is a stop-gap measure and should not be",
            "\t * considered a generic solution.",
            "\t */",
            "\tif (in_compat_syscall())",
            "\t\treturn copy_siginfo_from_user32(",
            "\t\t\tkinfo, (struct compat_siginfo __user *)info);",
            "#endif",
            "\treturn copy_siginfo_from_user(kinfo, info);",
            "}"
          ],
          "function_name": "__copy_siginfo_from_user32, copy_siginfo_from_user32, do_sigtimedwait, prepare_kill_siginfo, access_pidfd_pidns, copy_siginfo_from_user_any",
          "description": "实现信号等待、发送及信号信息解析功能，包含定时等待信号、进程权限检查和信号信息格式转换等核心逻辑。",
          "similarity": 0.5729160308837891
        },
        {
          "chunk_id": 18,
          "file_path": "kernel/signal.c",
          "start_line": 2706,
          "end_line": 2949,
          "content": [
            "bool get_signal(struct ksignal *ksig)",
            "{",
            "\tstruct sighand_struct *sighand = current->sighand;",
            "\tstruct signal_struct *signal = current->signal;",
            "\tint signr;",
            "",
            "\tclear_notify_signal();",
            "\tif (unlikely(task_work_pending(current)))",
            "\t\ttask_work_run();",
            "",
            "\tif (!task_sigpending(current))",
            "\t\treturn false;",
            "",
            "\tif (unlikely(uprobe_deny_signal()))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Do this once, we can't return to user-mode if freezing() == T.",
            "\t * do_signal_stop() and ptrace_stop() do freezable_schedule() and",
            "\t * thus do not need another check after return.",
            "\t */",
            "\ttry_to_freeze();",
            "",
            "relock:",
            "\tspin_lock_irq(&sighand->siglock);",
            "",
            "\t/*",
            "\t * Every stopped thread goes here after wakeup. Check to see if",
            "\t * we should notify the parent, prepare_signal(SIGCONT) encodes",
            "\t * the CLD_ si_code into SIGNAL_CLD_MASK bits.",
            "\t */",
            "\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {",
            "\t\tint why;",
            "",
            "\t\tif (signal->flags & SIGNAL_CLD_CONTINUED)",
            "\t\t\twhy = CLD_CONTINUED;",
            "\t\telse",
            "\t\t\twhy = CLD_STOPPED;",
            "",
            "\t\tsignal->flags &= ~SIGNAL_CLD_MASK;",
            "",
            "\t\tspin_unlock_irq(&sighand->siglock);",
            "",
            "\t\t/*",
            "\t\t * Notify the parent that we're continuing.  This event is",
            "\t\t * always per-process and doesn't make whole lot of sense",
            "\t\t * for ptracers, who shouldn't consume the state via",
            "\t\t * wait(2) either, but, for backward compatibility, notify",
            "\t\t * the ptracer of the group leader too unless it's gonna be",
            "\t\t * a duplicate.",
            "\t\t */",
            "\t\tread_lock(&tasklist_lock);",
            "\t\tdo_notify_parent_cldstop(current, false, why);",
            "",
            "\t\tif (ptrace_reparented(current->group_leader))",
            "\t\t\tdo_notify_parent_cldstop(current->group_leader,",
            "\t\t\t\t\t\ttrue, why);",
            "\t\tread_unlock(&tasklist_lock);",
            "",
            "\t\tgoto relock;",
            "\t}",
            "",
            "\tfor (;;) {",
            "\t\tstruct k_sigaction *ka;",
            "\t\tenum pid_type type;",
            "",
            "\t\t/* Has this task already been marked for death? */",
            "\t\tif ((signal->flags & SIGNAL_GROUP_EXIT) ||",
            "\t\t     signal->group_exec_task) {",
            "\t\t\tclear_siginfo(&ksig->info);",
            "\t\t\tksig->info.si_signo = signr = SIGKILL;",
            "\t\t\tsigdelset(&current->pending.signal, SIGKILL);",
            "\t\t\ttrace_signal_deliver(SIGKILL, SEND_SIG_NOINFO,",
            "\t\t\t\t&sighand->action[SIGKILL - 1]);",
            "\t\t\trecalc_sigpending();",
            "\t\t\tgoto fatal;",
            "\t\t}",
            "",
            "\t\tif (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&",
            "\t\t    do_signal_stop(0))",
            "\t\t\tgoto relock;",
            "",
            "\t\tif (unlikely(current->jobctl &",
            "\t\t\t     (JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE))) {",
            "\t\t\tif (current->jobctl & JOBCTL_TRAP_MASK) {",
            "\t\t\t\tdo_jobctl_trap();",
            "\t\t\t\tspin_unlock_irq(&sighand->siglock);",
            "\t\t\t} else if (current->jobctl & JOBCTL_TRAP_FREEZE)",
            "\t\t\t\tdo_freezer_trap();",
            "",
            "\t\t\tgoto relock;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If the task is leaving the frozen state, let's update",
            "\t\t * cgroup counters and reset the frozen bit.",
            "\t\t */",
            "\t\tif (unlikely(cgroup_task_frozen(current))) {",
            "\t\t\tspin_unlock_irq(&sighand->siglock);",
            "\t\t\tcgroup_leave_frozen(false);",
            "\t\t\tgoto relock;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Signals generated by the execution of an instruction",
            "\t\t * need to be delivered before any other pending signals",
            "\t\t * so that the instruction pointer in the signal stack",
            "\t\t * frame points to the faulting instruction.",
            "\t\t */",
            "\t\ttype = PIDTYPE_PID;",
            "\t\tsignr = dequeue_synchronous_signal(&ksig->info);",
            "\t\tif (!signr)",
            "\t\t\tsignr = dequeue_signal(current, &current->blocked,",
            "\t\t\t\t\t       &ksig->info, &type);",
            "",
            "\t\tif (!signr)",
            "\t\t\tbreak; /* will return 0 */",
            "",
            "\t\tif (unlikely(current->ptrace) && (signr != SIGKILL) &&",
            "\t\t    !(sighand->action[signr -1].sa.sa_flags & SA_IMMUTABLE)) {",
            "\t\t\tsignr = ptrace_signal(signr, &ksig->info, type);",
            "\t\t\tif (!signr)",
            "\t\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tka = &sighand->action[signr-1];",
            "",
            "\t\t/* Trace actually delivered signals. */",
            "\t\ttrace_signal_deliver(signr, &ksig->info, ka);",
            "",
            "\t\tif (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */",
            "\t\t\tcontinue;",
            "\t\tif (ka->sa.sa_handler != SIG_DFL) {",
            "\t\t\t/* Run the handler.  */",
            "\t\t\tksig->ka = *ka;",
            "",
            "\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)",
            "\t\t\t\tka->sa.sa_handler = SIG_DFL;",
            "",
            "\t\t\tbreak; /* will return non-zero \"signr\" value */",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Now we are doing the default action for this signal.",
            "\t\t */",
            "\t\tif (sig_kernel_ignore(signr)) /* Default is nothing. */",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Global init gets no signals it doesn't want.",
            "\t\t * Container-init gets no signals it doesn't want from same",
            "\t\t * container.",
            "\t\t *",
            "\t\t * Note that if global/container-init sees a sig_kernel_only()",
            "\t\t * signal here, the signal must have been generated internally",
            "\t\t * or must have come from an ancestor namespace. In either",
            "\t\t * case, the signal cannot be dropped.",
            "\t\t */",
            "\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&",
            "\t\t\t\t!sig_kernel_only(signr))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (sig_kernel_stop(signr)) {",
            "\t\t\t/*",
            "\t\t\t * The default action is to stop all threads in",
            "\t\t\t * the thread group.  The job control signals",
            "\t\t\t * do nothing in an orphaned pgrp, but SIGSTOP",
            "\t\t\t * always works.  Note that siglock needs to be",
            "\t\t\t * dropped during the call to is_orphaned_pgrp()",
            "\t\t\t * because of lock ordering with tasklist_lock.",
            "\t\t\t * This allows an intervening SIGCONT to be posted.",
            "\t\t\t * We need to check for that and bail out if necessary.",
            "\t\t\t */",
            "\t\t\tif (signr != SIGSTOP) {",
            "\t\t\t\tspin_unlock_irq(&sighand->siglock);",
            "",
            "\t\t\t\t/* signals can be posted during this window */",
            "",
            "\t\t\t\tif (is_current_pgrp_orphaned())",
            "\t\t\t\t\tgoto relock;",
            "",
            "\t\t\t\tspin_lock_irq(&sighand->siglock);",
            "\t\t\t}",
            "",
            "\t\t\tif (likely(do_signal_stop(ksig->info.si_signo))) {",
            "\t\t\t\t/* It released the siglock.  */",
            "\t\t\t\tgoto relock;",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * We didn't actually stop, due to a race",
            "\t\t\t * with SIGCONT or something like that.",
            "\t\t\t */",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\tfatal:",
            "\t\tspin_unlock_irq(&sighand->siglock);",
            "\t\tif (unlikely(cgroup_task_frozen(current)))",
            "\t\t\tcgroup_leave_frozen(true);",
            "",
            "\t\t/*",
            "\t\t * Anything else is fatal, maybe with a core dump.",
            "\t\t */",
            "\t\tcurrent->flags |= PF_SIGNALED;",
            "",
            "\t\tif (sig_kernel_coredump(signr)) {",
            "\t\t\tif (print_fatal_signals)",
            "\t\t\t\tprint_fatal_signal(ksig->info.si_signo);",
            "\t\t\tproc_coredump_connector(current);",
            "\t\t\t/*",
            "\t\t\t * If it was able to dump core, this kills all",
            "\t\t\t * other threads in the group and synchronizes with",
            "\t\t\t * their demise.  If we lost the race with another",
            "\t\t\t * thread getting here, it set group_exit_code",
            "\t\t\t * first and our do_group_exit call below will use",
            "\t\t\t * that value and ignore the one we pass it.",
            "\t\t\t */",
            "\t\t\tdo_coredump(&ksig->info);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * PF_USER_WORKER threads will catch and exit on fatal signals",
            "\t\t * themselves. They have cleanup that must be performed, so",
            "\t\t * we cannot call do_exit() on their behalf.",
            "\t\t */",
            "\t\tif (current->flags & PF_USER_WORKER)",
            "\t\t\tgoto out;",
            "",
            "\t\t/*",
            "\t\t * Death signals, no core dump.",
            "\t\t */",
            "\t\tdo_group_exit(ksig->info.si_signo);",
            "\t\t/* NOTREACHED */",
            "\t}",
            "\tspin_unlock_irq(&sighand->siglock);",
            "out:",
            "\tksig->sig = signr;",
            "",
            "\tif (!(ksig->ka.sa.sa_flags & SA_EXPOSE_TAGBITS))",
            "\t\thide_si_addr_tag_bits(ksig);",
            "",
            "\treturn ksig->sig > 0;",
            "}"
          ],
          "function_name": "get_signal",
          "description": "get_signal 获取并处理待交付信号，包含同步信号处理、组停止检测、致命信号处理、调试器交互等复杂逻辑分支",
          "similarity": 0.5717250108718872
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/signal.c",
          "start_line": 559,
          "end_line": 706,
          "content": [
            "bool unhandled_signal(struct task_struct *tsk, int sig)",
            "{",
            "\tvoid __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;",
            "\tif (is_global_init(tsk))",
            "\t\treturn true;",
            "",
            "\tif (handler != SIG_IGN && handler != SIG_DFL)",
            "\t\treturn false;",
            "",
            "\t/* If dying, we handle all new signals by ignoring them */",
            "\tif (fatal_signal_pending(tsk))",
            "\t\treturn false;",
            "",
            "\t/* if ptraced, let the tracer determine */",
            "\treturn !tsk->ptrace;",
            "}",
            "static void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,",
            "\t\t\t   bool *resched_timer)",
            "{",
            "\tstruct sigqueue *q, *first = NULL;",
            "",
            "\t/*",
            "\t * Collect the siginfo appropriate to this signal.  Check if",
            "\t * there is another siginfo for the same signal.",
            "\t*/",
            "\tlist_for_each_entry(q, &list->list, list) {",
            "\t\tif (q->info.si_signo == sig) {",
            "\t\t\tif (first)",
            "\t\t\t\tgoto still_pending;",
            "\t\t\tfirst = q;",
            "\t\t}",
            "\t}",
            "",
            "\tsigdelset(&list->signal, sig);",
            "",
            "\tif (first) {",
            "still_pending:",
            "\t\tlist_del_init(&first->list);",
            "\t\tcopy_siginfo(info, &first->info);",
            "",
            "\t\t*resched_timer =",
            "\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&",
            "\t\t\t(info->si_code == SI_TIMER) &&",
            "\t\t\t(info->si_sys_private);",
            "",
            "\t\t__sigqueue_free(first);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Ok, it wasn't in the queue.  This must be",
            "\t\t * a fast-pathed signal or we must have been",
            "\t\t * out of queue space.  So zero out the info.",
            "\t\t */",
            "\t\tclear_siginfo(info);",
            "\t\tinfo->si_signo = sig;",
            "\t\tinfo->si_errno = 0;",
            "\t\tinfo->si_code = SI_USER;",
            "\t\tinfo->si_pid = 0;",
            "\t\tinfo->si_uid = 0;",
            "\t}",
            "}",
            "static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,",
            "\t\t\tkernel_siginfo_t *info, bool *resched_timer)",
            "{",
            "\tint sig = next_signal(pending, mask);",
            "",
            "\tif (sig)",
            "\t\tcollect_signal(sig, pending, info, resched_timer);",
            "\treturn sig;",
            "}",
            "int dequeue_signal(struct task_struct *tsk, sigset_t *mask,",
            "\t\t   kernel_siginfo_t *info, enum pid_type *type)",
            "{",
            "\tbool resched_timer = false;",
            "\tint signr;",
            "",
            "\t/* We only dequeue private signals from ourselves, we don't let",
            "\t * signalfd steal them",
            "\t */",
            "\t*type = PIDTYPE_PID;",
            "\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);",
            "\tif (!signr) {",
            "\t\t*type = PIDTYPE_TGID;",
            "\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,",
            "\t\t\t\t\t mask, info, &resched_timer);",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\t\t/*",
            "\t\t * itimer signal ?",
            "\t\t *",
            "\t\t * itimers are process shared and we restart periodic",
            "\t\t * itimers in the signal delivery path to prevent DoS",
            "\t\t * attacks in the high resolution timer case. This is",
            "\t\t * compliant with the old way of self-restarting",
            "\t\t * itimers, as the SIGALRM is a legacy signal and only",
            "\t\t * queued once. Changing the restart behaviour to",
            "\t\t * restart the timer in the signal dequeue path is",
            "\t\t * reducing the timer noise on heavy loaded !highres",
            "\t\t * systems too.",
            "\t\t */",
            "\t\tif (unlikely(signr == SIGALRM)) {",
            "\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;",
            "",
            "\t\t\tif (!hrtimer_is_queued(tmr) &&",
            "\t\t\t    tsk->signal->it_real_incr != 0) {",
            "\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),",
            "\t\t\t\t\t\ttsk->signal->it_real_incr);",
            "\t\t\t\thrtimer_restart(tmr);",
            "\t\t\t}",
            "\t\t}",
            "#endif",
            "\t}",
            "",
            "\trecalc_sigpending();",
            "\tif (!signr)",
            "\t\treturn 0;",
            "",
            "\tif (unlikely(sig_kernel_stop(signr))) {",
            "\t\t/*",
            "\t\t * Set a marker that we have dequeued a stop signal.  Our",
            "\t\t * caller might release the siglock and then the pending",
            "\t\t * stop signal it is about to process is no longer in the",
            "\t\t * pending bitmasks, but must still be cleared by a SIGCONT",
            "\t\t * (and overruled by a SIGKILL).  So those cases clear this",
            "\t\t * shared flag after we've set it.  Note that this flag may",
            "\t\t * remain set after the signal we return is ignored or",
            "\t\t * handled.  That doesn't matter because its only purpose",
            "\t\t * is to alert stop-signal processing code when another",
            "\t\t * processor has come along and cleared the flag.",
            "\t\t */",
            "\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;",
            "\t}",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\tif (resched_timer) {",
            "\t\t/*",
            "\t\t * Release the siglock to ensure proper locking order",
            "\t\t * of timer locks outside of siglocks.  Note, we leave",
            "\t\t * irqs disabled here, since the posix-timers code is",
            "\t\t * about to disable them again anyway.",
            "\t\t */",
            "\t\tspin_unlock(&tsk->sighand->siglock);",
            "\t\tposixtimer_rearm(info);",
            "\t\tspin_lock(&tsk->sighand->siglock);",
            "",
            "\t\t/* Don't expose the si_sys_private value to userspace */",
            "\t\tinfo->si_sys_private = 0;",
            "\t}",
            "#endif",
            "\treturn signr;",
            "}"
          ],
          "function_name": "unhandled_signal, collect_signal, __dequeue_signal, dequeue_signal",
          "description": "实现信号处理路径，包含未处理信号判定、信号信息收集、信号队列弹出操作及特殊信号（如SIGALRM）的处理逻辑。",
          "similarity": 0.5483975410461426
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/signal.c",
          "start_line": 1668,
          "end_line": 1770,
          "content": [
            "int",
            "send_sig(int sig, struct task_struct *p, int priv)",
            "{",
            "\treturn send_sig_info(sig, __si_special(priv), p);",
            "}",
            "void force_sig(int sig)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code = SI_KERNEL;",
            "\tinfo.si_pid = 0;",
            "\tinfo.si_uid = 0;",
            "\tforce_sig_info(&info);",
            "}",
            "void force_fatal_sig(int sig)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code = SI_KERNEL;",
            "\tinfo.si_pid = 0;",
            "\tinfo.si_uid = 0;",
            "\tforce_sig_info_to_task(&info, current, HANDLER_SIG_DFL);",
            "}",
            "void force_exit_sig(int sig)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code = SI_KERNEL;",
            "\tinfo.si_pid = 0;",
            "\tinfo.si_uid = 0;",
            "\tforce_sig_info_to_task(&info, current, HANDLER_EXIT);",
            "}",
            "void force_sigsegv(int sig)",
            "{",
            "\tif (sig == SIGSEGV)",
            "\t\tforce_fatal_sig(SIGSEGV);",
            "\telse",
            "\t\tforce_sig(SIGSEGV);",
            "}",
            "int force_sig_fault_to_task(int sig, int code, void __user *addr",
            "\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)",
            "\t, struct task_struct *t)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = code;",
            "\tinfo.si_addr  = addr;",
            "#ifdef __ia64__",
            "\tinfo.si_imm = imm;",
            "\tinfo.si_flags = flags;",
            "\tinfo.si_isr = isr;",
            "#endif",
            "\treturn force_sig_info_to_task(&info, t, HANDLER_CURRENT);",
            "}",
            "int force_sig_fault(int sig, int code, void __user *addr",
            "\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr))",
            "{",
            "\treturn force_sig_fault_to_task(sig, code, addr",
            "\t\t\t\t       ___ARCH_SI_IA64(imm, flags, isr), current);",
            "}",
            "int send_sig_fault(int sig, int code, void __user *addr",
            "\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)",
            "\t, struct task_struct *t)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = code;",
            "\tinfo.si_addr  = addr;",
            "#ifdef __ia64__",
            "\tinfo.si_imm = imm;",
            "\tinfo.si_flags = flags;",
            "\tinfo.si_isr = isr;",
            "#endif",
            "\treturn send_sig_info(info.si_signo, &info, t);",
            "}",
            "int force_sig_mceerr(int code, void __user *addr, short lsb)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGBUS;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code = code;",
            "\tinfo.si_addr = addr;",
            "\tinfo.si_addr_lsb = lsb;",
            "\treturn force_sig_info(&info);",
            "}"
          ],
          "function_name": "send_sig, force_sig, force_fatal_sig, force_exit_sig, force_sigsegv, force_sig_fault_to_task, force_sig_fault, send_sig_fault, force_sig_mceerr",
          "description": "提供强制发送信号的接口，force_sig系列函数构建标准信号信息并发送，force_sig_mceerr等处理特定硬件异常信号，send_sig_fault用于传递故障信息。所有函数均通过force_sig_info_to_task或send_sig_info实现信号投递。",
          "similarity": 0.5475040674209595
        },
        {
          "chunk_id": 27,
          "file_path": "kernel/signal.c",
          "start_line": 4872,
          "end_line": 4907,
          "content": [
            "void __init signals_init(void)",
            "{",
            "\tsiginfo_buildtime_checks();",
            "",
            "\tsigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC | SLAB_ACCOUNT);",
            "}",
            "void kdb_send_sig(struct task_struct *t, int sig)",
            "{",
            "\tstatic struct task_struct *kdb_prev_t;",
            "\tint new_t, ret;",
            "\tif (!spin_trylock(&t->sighand->siglock)) {",
            "\t\tkdb_printf(\"Can't do kill command now.\\n\"",
            "\t\t\t   \"The sigmask lock is held somewhere else in \"",
            "\t\t\t   \"kernel, try again later\\n\");",
            "\t\treturn;",
            "\t}",
            "\tnew_t = kdb_prev_t != t;",
            "\tkdb_prev_t = t;",
            "\tif (!task_is_running(t) && new_t) {",
            "\t\tspin_unlock(&t->sighand->siglock);",
            "\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"",
            "\t\t\t   \"kdb risks deadlock\\n\"",
            "\t\t\t   \"on the run queue locks. \"",
            "\t\t\t   \"The signal has _not_ been sent.\\n\"",
            "\t\t\t   \"Reissue the kill command if you want to risk \"",
            "\t\t\t   \"the deadlock.\\n\");",
            "\t\treturn;",
            "\t}",
            "\tret = send_signal_locked(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);",
            "\tspin_unlock(&t->sighand->siglock);",
            "\tif (ret)",
            "\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",",
            "\t\t\t   sig, t->pid);",
            "\telse",
            "\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);",
            "}"
          ],
          "function_name": "signals_init, kdb_send_sig",
          "description": "完成信号系统初始化并注册信号队列缓存，实现kdb_send_sig向指定进程发送信号的接口，包含并发控制检查和进程运行态验证以避免死锁风险",
          "similarity": 0.538510262966156
        }
      ]
    },
    {
      "source_file": "kernel/time/tick-broadcast.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:48:04\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\tick-broadcast.c`\n\n---\n\n# `time/tick-broadcast.c` 技术文档\n\n## 1. 文件概述\n\n`tick-broadcast.c` 实现了 Linux 内核中的 **时钟事件广播机制（tick broadcast）**，用于在某些硬件平台（如部分 x86 系统）上，当本地 APIC 定时器在深度 C 状态（如 C3）下停止工作时，通过一个全局的、始终可用的广播时钟事件设备（broadcast clock event device）来为多个 CPU 提供周期性或单次（oneshot）的时钟中断服务。该机制确保即使本地定时器失效，系统仍能维持正确的调度、时间管理和电源管理功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `tick_broadcast_device`：全局的广播时钟设备封装（`struct tick_device`）\n- `tick_broadcast_mask`：记录当前依赖广播机制接收 tick 的 CPU 掩码\n- `tick_broadcast_on`：记录处于周期性广播模式的 CPU 掩码\n- `tmpmask`：临时 CPU 掩码，用于内部计算\n- `tick_broadcast_forced`：标志位，指示是否强制启用广播模式\n- `tick_oneshot_wakeup_device`（per-CPU）：每个 CPU 可选的专用单次唤醒设备（用于优化）\n\n### 主要函数\n\n- `tick_install_broadcast_device()`：安装或替换广播时钟设备\n- `tick_device_uses_broadcast()`：判断某 CPU 的本地设备是否需依赖广播\n- `tick_is_broadcast_device()`：检查设备是否为当前广播设备\n- `tick_broadcast_update_freq()`：更新广播设备频率\n- `tick_get_broadcast_device()` / `tick_get_broadcast_mask()`：调试接口\n- `tick_set_oneshot_wakeup_device()`：为 CPU 设置专用单次唤醒设备\n- `tick_broadcast_setup_oneshot()` / `tick_broadcast_clear_oneshot()`：管理单次广播模式\n- `tick_oneshot_wakeup_handler()`：专用唤醒设备的中断处理函数\n\n## 3. 关键实现\n\n### 广播设备选择策略\n- 通过 `tick_check_broadcast_device()` 评估候选设备：\n  - 排除 `DUMMY`、`PERCPU` 或 `C3STOP` 特性的设备\n  - 在 oneshot 模式下要求设备支持 `ONESHOT`\n  - 优先选择 `rating` 更高的设备\n\n### 两种广播模式\n- **周期性模式（Periodic）**：通过 `tick_broadcast_start_periodic()` 启动固定频率中断\n- **单次模式（Oneshot）**：通过 `tick_broadcast_setup_oneshot()` 动态编程下次中断时间\n\n### CPU 依赖管理\n- 当 CPU 的本地设备不支持深度睡眠（无 `C3STOP`）或功能不全时，将其加入 `tick_broadcast_mask`\n- 支持为特定 CPU 分配专用的 `tick_oneshot_wakeup_device`，避免全局广播开销\n\n### 安全机制\n- 使用 `tick_broadcast_lock` 自旋锁保护全局状态\n- 通过 `try_module_get()` 确保设备驱动模块不会在使用中被卸载\n- 提供 `err_broadcast()` 作为兜底处理，防止系统完全失去 tick\n\n### 模式切换\n- 若系统已运行在 oneshot 模式，新注册的广播设备会自动切换至 oneshot\n- 通过 `tick_clock_notify()` 通知所有 CPU 重新评估 tick 模式\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `tick-internal.h`：tick 子系统内部接口\n  - `clockevents` 框架：设备注册、频率更新、事件处理\n  - `tick-sched.c`：与 per-CPU tick 调度器交互\n- **外部依赖**：\n  - `CONFIG_GENERIC_CLOCKEVENTS`：时钟事件设备基础框架\n  - `CONFIG_TICK_ONESHOT`：单次 tick 模式支持（可选）\n  - `CONFIG_HOTPLUG_CPU`：CPU 热插拔时的广播状态管理（可选）\n- **头文件**：\n  - `<linux/cpumask.h>`、`<linux/smp.h>`：CPU 掩码和 SMP 操作\n  - `<linux/interrupt.h>`、`<linux/hrtimer.h>`：中断和高精度定时器支持\n\n## 5. 使用场景\n\n1. **x86 C3+ 电源状态**：在 Intel/AMD 处理器进入 C3 或更深睡眠状态时，本地 APIC 定时器停止，必须依赖 HPET 或 TSC_DEADLINE 等全局设备广播 tick。\n2. **无本地定时器的架构**：某些嵌入式或旧平台可能缺乏 per-CPU 定时器，完全依赖广播机制。\n3. **调试与监控**：通过 `timer_list` 等工具可查看广播设备状态，辅助诊断 tick 相关问题。\n4. **CPU 热插拔**：在线 CPU 下线时，需将其从广播掩码中移除（`tick_broadcast_oneshot_offline`）。\n5. **动态 tick 模式切换**：系统在周期性 tick 与 NO_HZ（动态 tick）模式间切换时，广播设备需同步调整工作模式。",
      "similarity": 0.5376853942871094,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 328,
          "end_line": 488,
          "content": [
            "int tick_receive_broadcast(void)",
            "{",
            "\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);",
            "\tstruct clock_event_device *evt = td->evtdev;",
            "",
            "\tif (!evt)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (!evt->event_handler)",
            "\t\treturn -EINVAL;",
            "",
            "\tevt->event_handler(evt);",
            "\treturn 0;",
            "}",
            "static bool tick_do_broadcast(struct cpumask *mask)",
            "{",
            "\tint cpu = smp_processor_id();",
            "\tstruct tick_device *td;",
            "\tbool local = false;",
            "",
            "\t/*",
            "\t * Check, if the current cpu is in the mask",
            "\t */",
            "\tif (cpumask_test_cpu(cpu, mask)) {",
            "\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;",
            "",
            "\t\tcpumask_clear_cpu(cpu, mask);",
            "\t\t/*",
            "\t\t * We only run the local handler, if the broadcast",
            "\t\t * device is not hrtimer based. Otherwise we run into",
            "\t\t * a hrtimer recursion.",
            "\t\t *",
            "\t\t * local timer_interrupt()",
            "\t\t *   local_handler()",
            "\t\t *     expire_hrtimers()",
            "\t\t *       bc_handler()",
            "\t\t *         local_handler()",
            "\t\t *\t     expire_hrtimers()",
            "\t\t */",
            "\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);",
            "\t}",
            "",
            "\tif (!cpumask_empty(mask)) {",
            "\t\t/*",
            "\t\t * It might be necessary to actually check whether the devices",
            "\t\t * have different broadcast functions. For now, just use the",
            "\t\t * one of the first device. This works as long as we have this",
            "\t\t * misfeature only on x86 (lapic)",
            "\t\t */",
            "\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));",
            "\t\ttd->evtdev->broadcast(mask);",
            "\t}",
            "\treturn local;",
            "}",
            "static bool tick_do_periodic_broadcast(void)",
            "{",
            "\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);",
            "\treturn tick_do_broadcast(tmpmask);",
            "}",
            "static void tick_handle_periodic_broadcast(struct clock_event_device *dev)",
            "{",
            "\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);",
            "\tbool bc_local;",
            "",
            "\traw_spin_lock(&tick_broadcast_lock);",
            "",
            "\t/* Handle spurious interrupts gracefully */",
            "\tif (clockevent_state_shutdown(tick_broadcast_device.evtdev)) {",
            "\t\traw_spin_unlock(&tick_broadcast_lock);",
            "\t\treturn;",
            "\t}",
            "",
            "\tbc_local = tick_do_periodic_broadcast();",
            "",
            "\tif (clockevent_state_oneshot(dev)) {",
            "\t\tktime_t next = ktime_add_ns(dev->next_event, TICK_NSEC);",
            "",
            "\t\tclockevents_program_event(dev, next, true);",
            "\t}",
            "\traw_spin_unlock(&tick_broadcast_lock);",
            "",
            "\t/*",
            "\t * We run the handler of the local cpu after dropping",
            "\t * tick_broadcast_lock because the handler might deadlock when",
            "\t * trying to switch to oneshot mode.",
            "\t */",
            "\tif (bc_local)",
            "\t\ttd->evtdev->event_handler(td->evtdev);",
            "}",
            "void tick_broadcast_control(enum tick_broadcast_mode mode)",
            "{",
            "\tstruct clock_event_device *bc, *dev;",
            "\tstruct tick_device *td;",
            "\tint cpu, bc_stopped;",
            "\tunsigned long flags;",
            "",
            "\t/* Protects also the local clockevent device. */",
            "\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);",
            "\ttd = this_cpu_ptr(&tick_cpu_device);",
            "\tdev = td->evtdev;",
            "",
            "\t/*",
            "\t * Is the device not affected by the powerstate ?",
            "\t */",
            "\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_C3STOP))",
            "\t\tgoto out;",
            "",
            "\tif (!tick_device_is_functional(dev))",
            "\t\tgoto out;",
            "",
            "\tcpu = smp_processor_id();",
            "\tbc = tick_broadcast_device.evtdev;",
            "\tbc_stopped = cpumask_empty(tick_broadcast_mask);",
            "",
            "\tswitch (mode) {",
            "\tcase TICK_BROADCAST_FORCE:",
            "\t\ttick_broadcast_forced = 1;",
            "\t\tfallthrough;",
            "\tcase TICK_BROADCAST_ON:",
            "\t\tcpumask_set_cpu(cpu, tick_broadcast_on);",
            "\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_mask)) {",
            "\t\t\t/*",
            "\t\t\t * Only shutdown the cpu local device, if:",
            "\t\t\t *",
            "\t\t\t * - the broadcast device exists",
            "\t\t\t * - the broadcast device is not a hrtimer based one",
            "\t\t\t * - the broadcast device is in periodic mode to",
            "\t\t\t *   avoid a hiccup during switch to oneshot mode",
            "\t\t\t */",
            "\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER) &&",
            "\t\t\t    tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)",
            "\t\t\t\tclockevents_shutdown(dev);",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase TICK_BROADCAST_OFF:",
            "\t\tif (tick_broadcast_forced)",
            "\t\t\tbreak;",
            "\t\tcpumask_clear_cpu(cpu, tick_broadcast_on);",
            "\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_mask)) {",
            "\t\t\tif (tick_broadcast_device.mode ==",
            "\t\t\t    TICKDEV_MODE_PERIODIC)",
            "\t\t\t\ttick_setup_periodic(dev, 0);",
            "\t\t}",
            "\t\tbreak;",
            "\t}",
            "",
            "\tif (bc) {",
            "\t\tif (cpumask_empty(tick_broadcast_mask)) {",
            "\t\t\tif (!bc_stopped)",
            "\t\t\t\tclockevents_shutdown(bc);",
            "\t\t} else if (bc_stopped) {",
            "\t\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)",
            "\t\t\t\ttick_broadcast_start_periodic(bc);",
            "\t\t\telse",
            "\t\t\t\ttick_broadcast_setup_oneshot(bc, false);",
            "\t\t}",
            "\t}",
            "out:",
            "\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);",
            "}"
          ],
          "function_name": "tick_receive_broadcast, tick_do_broadcast, tick_do_periodic_broadcast, tick_handle_periodic_broadcast, tick_broadcast_control",
          "description": "实现广播中断接收、分发及控制逻辑，包含周期性广播处理、中断状态管理及广播模式开关操作，处理多CPU间同步与状态一致性保障。",
          "similarity": 0.5423773527145386
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 209,
          "end_line": 317,
          "content": [
            "int tick_is_broadcast_device(struct clock_event_device *dev)",
            "{",
            "\treturn (dev && tick_broadcast_device.evtdev == dev);",
            "}",
            "int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)",
            "{",
            "\tint ret = -ENODEV;",
            "",
            "\tif (tick_is_broadcast_device(dev)) {",
            "\t\traw_spin_lock(&tick_broadcast_lock);",
            "\t\tret = __clockevents_update_freq(dev, freq);",
            "\t\traw_spin_unlock(&tick_broadcast_lock);",
            "\t}",
            "\treturn ret;",
            "}",
            "static void err_broadcast(const struct cpumask *mask)",
            "{",
            "\tpr_crit_once(\"Failed to broadcast timer tick. Some CPUs may be unresponsive.\\n\");",
            "}",
            "static void tick_device_setup_broadcast_func(struct clock_event_device *dev)",
            "{",
            "\tif (!dev->broadcast)",
            "\t\tdev->broadcast = tick_broadcast;",
            "\tif (!dev->broadcast) {",
            "\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",",
            "\t\t\t     dev->name);",
            "\t\tdev->broadcast = err_broadcast;",
            "\t}",
            "}",
            "int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)",
            "{",
            "\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;",
            "\tunsigned long flags;",
            "\tint ret = 0;",
            "",
            "\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);",
            "",
            "\t/*",
            "\t * Devices might be registered with both periodic and oneshot",
            "\t * mode disabled. This signals, that the device needs to be",
            "\t * operated from the broadcast device and is a placeholder for",
            "\t * the cpu local device.",
            "\t */",
            "\tif (!tick_device_is_functional(dev)) {",
            "\t\tdev->event_handler = tick_handle_periodic;",
            "\t\ttick_device_setup_broadcast_func(dev);",
            "\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);",
            "\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)",
            "\t\t\ttick_broadcast_start_periodic(bc);",
            "\t\telse",
            "\t\t\ttick_broadcast_setup_oneshot(bc, false);",
            "\t\tret = 1;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Clear the broadcast bit for this cpu if the",
            "\t\t * device is not power state affected.",
            "\t\t */",
            "\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))",
            "\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);",
            "\t\telse",
            "\t\t\ttick_device_setup_broadcast_func(dev);",
            "",
            "\t\t/*",
            "\t\t * Clear the broadcast bit if the CPU is not in",
            "\t\t * periodic broadcast on state.",
            "\t\t */",
            "\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))",
            "\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);",
            "",
            "\t\tswitch (tick_broadcast_device.mode) {",
            "\t\tcase TICKDEV_MODE_ONESHOT:",
            "\t\t\t/*",
            "\t\t\t * If the system is in oneshot mode we can",
            "\t\t\t * unconditionally clear the oneshot mask bit,",
            "\t\t\t * because the CPU is running and therefore",
            "\t\t\t * not in an idle state which causes the power",
            "\t\t\t * state affected device to stop. Let the",
            "\t\t\t * caller initialize the device.",
            "\t\t\t */",
            "\t\t\ttick_broadcast_clear_oneshot(cpu);",
            "\t\t\tret = 0;",
            "\t\t\tbreak;",
            "",
            "\t\tcase TICKDEV_MODE_PERIODIC:",
            "\t\t\t/*",
            "\t\t\t * If the system is in periodic mode, check",
            "\t\t\t * whether the broadcast device can be",
            "\t\t\t * switched off now.",
            "\t\t\t */",
            "\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)",
            "\t\t\t\tclockevents_shutdown(bc);",
            "\t\t\t/*",
            "\t\t\t * If we kept the cpu in the broadcast mask,",
            "\t\t\t * tell the caller to leave the per cpu device",
            "\t\t\t * in shutdown state. The periodic interrupt",
            "\t\t\t * is delivered by the broadcast device, if",
            "\t\t\t * the broadcast device exists and is not",
            "\t\t\t * hrtimer based.",
            "\t\t\t */",
            "\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))",
            "\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "tick_is_broadcast_device, tick_broadcast_update_freq, err_broadcast, tick_device_setup_broadcast_func, tick_device_uses_broadcast",
          "description": "提供广播设备识别、频率更新及设备功能设置接口，动态调整CPU广播掩码并根据设备特性选择处理方式，处理设备功能缺失时的备用方案。",
          "similarity": 0.504451334476471
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 779,
          "end_line": 931,
          "content": [
            "static void broadcast_shutdown_local(struct clock_event_device *bc,",
            "\t\t\t\t     struct clock_event_device *dev)",
            "{",
            "\t/*",
            "\t * For hrtimer based broadcasting we cannot shutdown the cpu",
            "\t * local device if our own event is the first one to expire or",
            "\t * if we own the broadcast timer.",
            "\t */",
            "\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {",
            "\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))",
            "\t\t\treturn;",
            "\t\tif (dev->next_event < bc->next_event)",
            "\t\t\treturn;",
            "\t}",
            "\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);",
            "}",
            "static int ___tick_broadcast_oneshot_control(enum tick_broadcast_state state,",
            "\t\t\t\t\t     struct tick_device *td,",
            "\t\t\t\t\t     int cpu)",
            "{",
            "\tstruct clock_event_device *bc, *dev = td->evtdev;",
            "\tint ret = 0;",
            "\tktime_t now;",
            "",
            "\traw_spin_lock(&tick_broadcast_lock);",
            "\tbc = tick_broadcast_device.evtdev;",
            "",
            "\tif (state == TICK_BROADCAST_ENTER) {",
            "\t\t/*",
            "\t\t * If the current CPU owns the hrtimer broadcast",
            "\t\t * mechanism, it cannot go deep idle and we do not add",
            "\t\t * the CPU to the broadcast mask. We don't have to go",
            "\t\t * through the EXIT path as the local timer is not",
            "\t\t * shutdown.",
            "\t\t */",
            "\t\tret = broadcast_needs_cpu(bc, cpu);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "",
            "\t\t/*",
            "\t\t * If the broadcast device is in periodic mode, we",
            "\t\t * return.",
            "\t\t */",
            "\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {",
            "\t\t\t/* If it is a hrtimer based broadcast, return busy */",
            "\t\t\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER)",
            "\t\t\t\tret = -EBUSY;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_oneshot_mask)) {",
            "\t\t\tWARN_ON_ONCE(cpumask_test_cpu(cpu, tick_broadcast_pending_mask));",
            "",
            "\t\t\t/* Conditionally shut down the local timer. */",
            "\t\t\tbroadcast_shutdown_local(bc, dev);",
            "",
            "\t\t\t/*",
            "\t\t\t * We only reprogram the broadcast timer if we",
            "\t\t\t * did not mark ourself in the force mask and",
            "\t\t\t * if the cpu local event is earlier than the",
            "\t\t\t * broadcast event. If the current CPU is in",
            "\t\t\t * the force mask, then we are going to be",
            "\t\t\t * woken by the IPI right away; we return",
            "\t\t\t * busy, so the CPU does not try to go deep",
            "\t\t\t * idle.",
            "\t\t\t */",
            "\t\t\tif (cpumask_test_cpu(cpu, tick_broadcast_force_mask)) {",
            "\t\t\t\tret = -EBUSY;",
            "\t\t\t} else if (dev->next_event < bc->next_event) {",
            "\t\t\t\ttick_broadcast_set_event(bc, cpu, dev->next_event);",
            "\t\t\t\t/*",
            "\t\t\t\t * In case of hrtimer broadcasts the",
            "\t\t\t\t * programming might have moved the",
            "\t\t\t\t * timer to this cpu. If yes, remove",
            "\t\t\t\t * us from the broadcast mask and",
            "\t\t\t\t * return busy.",
            "\t\t\t\t */",
            "\t\t\t\tret = broadcast_needs_cpu(bc, cpu);",
            "\t\t\t\tif (ret) {",
            "\t\t\t\t\tcpumask_clear_cpu(cpu,",
            "\t\t\t\t\t\ttick_broadcast_oneshot_mask);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t} else {",
            "\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_oneshot_mask)) {",
            "\t\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);",
            "\t\t\t/*",
            "\t\t\t * The cpu which was handling the broadcast",
            "\t\t\t * timer marked this cpu in the broadcast",
            "\t\t\t * pending mask and fired the broadcast",
            "\t\t\t * IPI. So we are going to handle the expired",
            "\t\t\t * event anyway via the broadcast IPI",
            "\t\t\t * handler. No need to reprogram the timer",
            "\t\t\t * with an already expired event.",
            "\t\t\t */",
            "\t\t\tif (cpumask_test_and_clear_cpu(cpu,",
            "\t\t\t\t       tick_broadcast_pending_mask))",
            "\t\t\t\tgoto out;",
            "",
            "\t\t\t/*",
            "\t\t\t * Bail out if there is no next event.",
            "\t\t\t */",
            "\t\t\tif (dev->next_event == KTIME_MAX)",
            "\t\t\t\tgoto out;",
            "\t\t\t/*",
            "\t\t\t * If the pending bit is not set, then we are",
            "\t\t\t * either the CPU handling the broadcast",
            "\t\t\t * interrupt or we got woken by something else.",
            "\t\t\t *",
            "\t\t\t * We are no longer in the broadcast mask, so",
            "\t\t\t * if the cpu local expiry time is already",
            "\t\t\t * reached, we would reprogram the cpu local",
            "\t\t\t * timer with an already expired event.",
            "\t\t\t *",
            "\t\t\t * This can lead to a ping-pong when we return",
            "\t\t\t * to idle and therefore rearm the broadcast",
            "\t\t\t * timer before the cpu local timer was able",
            "\t\t\t * to fire. This happens because the forced",
            "\t\t\t * reprogramming makes sure that the event",
            "\t\t\t * will happen in the future and depending on",
            "\t\t\t * the min_delta setting this might be far",
            "\t\t\t * enough out that the ping-pong starts.",
            "\t\t\t *",
            "\t\t\t * If the cpu local next_event has expired",
            "\t\t\t * then we know that the broadcast timer",
            "\t\t\t * next_event has expired as well and",
            "\t\t\t * broadcast is about to be handled. So we",
            "\t\t\t * avoid reprogramming and enforce that the",
            "\t\t\t * broadcast handler, which did not run yet,",
            "\t\t\t * will invoke the cpu local handler.",
            "\t\t\t *",
            "\t\t\t * We cannot call the handler directly from",
            "\t\t\t * here, because we might be in a NOHZ phase",
            "\t\t\t * and we did not go through the irq_enter()",
            "\t\t\t * nohz fixups.",
            "\t\t\t */",
            "\t\t\tnow = ktime_get();",
            "\t\t\tif (dev->next_event <= now) {",
            "\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);",
            "\t\t\t\tgoto out;",
            "\t\t\t}",
            "\t\t\t/*",
            "\t\t\t * We got woken by something else. Reprogram",
            "\t\t\t * the cpu local timer device.",
            "\t\t\t */",
            "\t\t\ttick_program_event(dev->next_event, 1);",
            "\t\t}",
            "\t}",
            "out:",
            "\traw_spin_unlock(&tick_broadcast_lock);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "broadcast_shutdown_local, ___tick_broadcast_oneshot_control",
          "description": "broadcast_shutdown_local根据HRTIMER特征决定是否关闭本地定时器；___tick_broadcast_oneshot_control处理单次模式状态转换，包括CPU加入/移出广播掩码、本地定时器关闭及下次事件设置逻辑",
          "similarity": 0.4705851674079895
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 515,
          "end_line": 617,
          "content": [
            "void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)",
            "{",
            "\tif (!broadcast)",
            "\t\tdev->event_handler = tick_handle_periodic;",
            "\telse",
            "\t\tdev->event_handler = tick_handle_periodic_broadcast;",
            "}",
            "static void tick_shutdown_broadcast(void)",
            "{",
            "\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;",
            "",
            "\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {",
            "\t\tif (bc && cpumask_empty(tick_broadcast_mask))",
            "\t\t\tclockevents_shutdown(bc);",
            "\t}",
            "}",
            "void tick_broadcast_offline(unsigned int cpu)",
            "{",
            "\traw_spin_lock(&tick_broadcast_lock);",
            "\tcpumask_clear_cpu(cpu, tick_broadcast_mask);",
            "\tcpumask_clear_cpu(cpu, tick_broadcast_on);",
            "\ttick_broadcast_oneshot_offline(cpu);",
            "\ttick_shutdown_broadcast();",
            "\traw_spin_unlock(&tick_broadcast_lock);",
            "}",
            "void tick_suspend_broadcast(void)",
            "{",
            "\tstruct clock_event_device *bc;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);",
            "",
            "\tbc = tick_broadcast_device.evtdev;",
            "\tif (bc)",
            "\t\tclockevents_shutdown(bc);",
            "",
            "\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);",
            "}",
            "bool tick_resume_check_broadcast(void)",
            "{",
            "\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT)",
            "\t\treturn false;",
            "\telse",
            "\t\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_mask);",
            "}",
            "void tick_resume_broadcast(void)",
            "{",
            "\tstruct clock_event_device *bc;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);",
            "",
            "\tbc = tick_broadcast_device.evtdev;",
            "",
            "\tif (bc) {",
            "\t\tclockevents_tick_resume(bc);",
            "",
            "\t\tswitch (tick_broadcast_device.mode) {",
            "\t\tcase TICKDEV_MODE_PERIODIC:",
            "\t\t\tif (!cpumask_empty(tick_broadcast_mask))",
            "\t\t\t\ttick_broadcast_start_periodic(bc);",
            "\t\t\tbreak;",
            "\t\tcase TICKDEV_MODE_ONESHOT:",
            "\t\t\tif (!cpumask_empty(tick_broadcast_mask))",
            "\t\t\t\ttick_resume_broadcast_oneshot(bc);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);",
            "}",
            "noinstr int tick_check_broadcast_expired(void)",
            "{",
            "#ifdef _ASM_GENERIC_BITOPS_INSTRUMENTED_NON_ATOMIC_H",
            "\treturn arch_test_bit(smp_processor_id(), cpumask_bits(tick_broadcast_force_mask));",
            "#else",
            "\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);",
            "#endif",
            "}",
            "static void tick_broadcast_set_affinity(struct clock_event_device *bc,",
            "\t\t\t\t\tconst struct cpumask *cpumask)",
            "{",
            "\tif (!(bc->features & CLOCK_EVT_FEAT_DYNIRQ))",
            "\t\treturn;",
            "",
            "\tif (cpumask_equal(bc->cpumask, cpumask))",
            "\t\treturn;",
            "",
            "\tbc->cpumask = cpumask;",
            "\tirq_set_affinity(bc->irq, bc->cpumask);",
            "}",
            "static void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,",
            "\t\t\t\t     ktime_t expires)",
            "{",
            "\tif (!clockevent_state_oneshot(bc))",
            "\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);",
            "",
            "\tclockevents_program_event(bc, expires, 1);",
            "\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));",
            "}",
            "static void tick_resume_broadcast_oneshot(struct clock_event_device *bc)",
            "{",
            "\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);",
            "}"
          ],
          "function_name": "tick_set_periodic_handler, tick_shutdown_broadcast, tick_broadcast_offline, tick_suspend_broadcast, tick_resume_check_broadcast, tick_resume_broadcast, tick_check_broadcast_expired, tick_broadcast_set_affinity, tick_broadcast_set_event, tick_resume_broadcast_oneshot",
          "description": "包含广播模式恢复、事件编程、亲缘性设置等辅助功能，支持动态调整广播设备参数并处理系统挂起/恢复场景下的广播设备状态维护。",
          "similarity": 0.4608432948589325
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/time/tick-broadcast.c",
          "start_line": 670,
          "end_line": 772,
          "content": [
            "void tick_check_oneshot_broadcast_this_cpu(void)",
            "{",
            "\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {",
            "\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);",
            "",
            "\t\t/*",
            "\t\t * We might be in the middle of switching over from",
            "\t\t * periodic to oneshot. If the CPU has not yet",
            "\t\t * switched over, leave the device alone.",
            "\t\t */",
            "\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {",
            "\t\t\tclockevents_switch_state(td->evtdev,",
            "\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);",
            "\t\t}",
            "\t}",
            "}",
            "static void tick_handle_oneshot_broadcast(struct clock_event_device *dev)",
            "{",
            "\tstruct tick_device *td;",
            "\tktime_t now, next_event;",
            "\tint cpu, next_cpu = 0;",
            "\tbool bc_local;",
            "",
            "\traw_spin_lock(&tick_broadcast_lock);",
            "\tdev->next_event = KTIME_MAX;",
            "\tnext_event = KTIME_MAX;",
            "\tcpumask_clear(tmpmask);",
            "\tnow = ktime_get();",
            "\t/* Find all expired events */",
            "\tfor_each_cpu(cpu, tick_broadcast_oneshot_mask) {",
            "\t\t/*",
            "\t\t * Required for !SMP because for_each_cpu() reports",
            "\t\t * unconditionally CPU0 as set on UP kernels.",
            "\t\t */",
            "\t\tif (!IS_ENABLED(CONFIG_SMP) &&",
            "\t\t    cpumask_empty(tick_broadcast_oneshot_mask))",
            "\t\t\tbreak;",
            "",
            "\t\ttd = &per_cpu(tick_cpu_device, cpu);",
            "\t\tif (td->evtdev->next_event <= now) {",
            "\t\t\tcpumask_set_cpu(cpu, tmpmask);",
            "\t\t\t/*",
            "\t\t\t * Mark the remote cpu in the pending mask, so",
            "\t\t\t * it can avoid reprogramming the cpu local",
            "\t\t\t * timer in tick_broadcast_oneshot_control().",
            "\t\t\t */",
            "\t\t\tcpumask_set_cpu(cpu, tick_broadcast_pending_mask);",
            "\t\t} else if (td->evtdev->next_event < next_event) {",
            "\t\t\tnext_event = td->evtdev->next_event;",
            "\t\t\tnext_cpu = cpu;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Remove the current cpu from the pending mask. The event is",
            "\t * delivered immediately in tick_do_broadcast() !",
            "\t */",
            "\tcpumask_clear_cpu(smp_processor_id(), tick_broadcast_pending_mask);",
            "",
            "\t/* Take care of enforced broadcast requests */",
            "\tcpumask_or(tmpmask, tmpmask, tick_broadcast_force_mask);",
            "\tcpumask_clear(tick_broadcast_force_mask);",
            "",
            "\t/*",
            "\t * Sanity check. Catch the case where we try to broadcast to",
            "\t * offline cpus.",
            "\t */",
            "\tif (WARN_ON_ONCE(!cpumask_subset(tmpmask, cpu_online_mask)))",
            "\t\tcpumask_and(tmpmask, tmpmask, cpu_online_mask);",
            "",
            "\t/*",
            "\t * Wakeup the cpus which have an expired event.",
            "\t */",
            "\tbc_local = tick_do_broadcast(tmpmask);",
            "",
            "\t/*",
            "\t * Two reasons for reprogram:",
            "\t *",
            "\t * - The global event did not expire any CPU local",
            "\t * events. This happens in dyntick mode, as the maximum PIT",
            "\t * delta is quite small.",
            "\t *",
            "\t * - There are pending events on sleeping CPUs which were not",
            "\t * in the event mask",
            "\t */",
            "\tif (next_event != KTIME_MAX)",
            "\t\ttick_broadcast_set_event(dev, next_cpu, next_event);",
            "",
            "\traw_spin_unlock(&tick_broadcast_lock);",
            "",
            "\tif (bc_local) {",
            "\t\ttd = this_cpu_ptr(&tick_cpu_device);",
            "\t\ttd->evtdev->event_handler(td->evtdev);",
            "\t}",
            "}",
            "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)",
            "{",
            "\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))",
            "\t\treturn 0;",
            "\tif (bc->next_event == KTIME_MAX)",
            "\t\treturn 0;",
            "\treturn bc->bound_on == cpu ? -EBUSY : 0;",
            "}"
          ],
          "function_name": "tick_check_oneshot_broadcast_this_cpu, tick_handle_oneshot_broadcast, broadcast_needs_cpu",
          "description": "tick_check_oneshot_broadcast_this_cpu检查当前CPU是否在单次广播掩码中，若处于单次模式则切换到CLOCK_EVT_STATE_ONESHOT状态；tick_handle_oneshot_broadcast遍历所有广播CPU寻找已到期事件，唤醒相应CPU并设置下次触发时间；broadcast_needs_cpu判断HRTIMER类型设备是否需要当前CPU处理",
          "similarity": 0.4571324288845062
        }
      ]
    }
  ]
}