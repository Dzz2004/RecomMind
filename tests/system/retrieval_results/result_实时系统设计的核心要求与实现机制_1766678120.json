{
  "query": "实时系统设计的核心要求与实现机制",
  "timestamp": "2025-12-25 23:55:20",
  "retrieved_files": [
    {
      "source_file": "kernel/time/timekeeping.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:55:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timekeeping.c`\n\n---\n\n# timekeeping.c 技术文档\n\n## 1. 文件概述\n\n`timekeeping.c` 是 Linux 内核中负责时间保持（timekeeping）的核心实现文件。它维护系统时间的连续性和准确性，提供高精度的时间读取接口，并处理与 NTP（网络时间协议）、时钟源（clocksource）、系统挂起/恢复等相关的时间同步逻辑。该文件实现了单调时钟（monotonic）、原始时钟（raw）、实时时钟（wall-clock）等多种时间视图，并确保在中断上下文、NMI（不可屏蔽中断）等特殊场景下也能安全读取时间。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct timekeeper`**  \n  核心时间保持结构体，包含当前时间、时钟偏移、TAI 偏移、启动时间偏移等关键字段。\n\n- **`struct tk_read_base`**  \n  用于快速时间读取的基础结构，包含时钟源指针、乘数（mult）、移位（shift）、掩码（mask）和上次周期值（cycle_last）等。\n\n- **`struct tk_fast`**  \n  专为 NMI 和中断上下文设计的快速时间读取结构，使用双缓冲（latch-based seqcount）机制实现无锁安全读取。\n\n- **`tk_core`**  \n  全局核心时间保持对象，包含一个 `seqcount_raw_spinlock_t` 序列锁和 `timekeeper` 实例，对齐到 64 字节缓存行以优化性能。\n\n- **`shadow_timekeeper`**  \n  时间保持器的影子副本，用于在更新过程中暂存新值，避免直接修改主结构导致不一致。\n\n- **`dummy_clock`**  \n  早期启动阶段使用的虚拟时钟源，基于 `local_clock()`，在真实时钟源注册前提供基本时间服务。\n\n### 主要函数与宏\n\n- **`tk_normalize_xtime()`**  \n  将纳秒部分规范化，确保 `xtime_nsec` 不超过每秒纳秒数的表示范围。\n\n- **`tk_xtime()` / `tk_set_xtime()` / `tk_xtime_add()`**  \n  用于获取、设置和累加系统实时时钟（wall time）。\n\n- **`tk_set_wall_to_mono()`**  \n  设置 wall-to-monotonic 偏移，并同步更新 `offs_real` 和 `offs_tai`。\n\n- **`tk_update_sleep_time()`**  \n  在系统从挂起状态恢复时，更新启动时间偏移（`offs_boot`）。\n\n- **`tk_clock_read()`**  \n  安全读取当前时钟源的周期值，防止在时钟源切换过程中发生崩溃。\n\n- **`timekeeping_check_update()`（仅调试模式）**  \n  检查时钟周期偏移是否超出安全范围，防止溢出或下溢。\n\n- **`update_fast_timekeeper()`（未完整显示但被引用）**  \n  更新 `tk_fast_mono` 和 `tk_fast_raw`，用于 NMI 安全的时间读取。\n\n### 全局变量\n\n- `timekeeper_lock`：保护 `tk_core` 的原始自旋锁。\n- `timekeeping_suspended`：标志系统时间保持是否处于挂起状态。\n- `cycles_at_suspend`：系统挂起时记录的时钟周期值。\n- `tk_fast_mono` / `tk_fast_raw`：分别用于单调时间和原始时间的快速读取路径。\n\n## 3. 关键实现\n\n### 时间读取的无锁安全机制\n\n为支持在 NMI、中断等不可睡眠上下文中安全读取时间，内核引入了 `tk_fast` 结构。它使用 `seqcount_latch_t`（一种双缓冲序列计数器），通过切换两个 `tk_read_base` 实例（索引由序列计数器最低位决定）来实现更新与读取的分离。读取时只需读取当前有效的副本，无需加锁。\n\n### 时间规范化与溢出处理\n\n`tk_normalize_xtime()` 确保纳秒字段不会超过 `NSEC_PER_SEC << shift`，避免在时间计算中出现逻辑错误。同时，`CONFIG_DEBUG_TIMEKEEPING` 启用时会检查周期偏移是否超过时钟源的 `max_cycles`，防止因时钟源回绕或频率异常导致时间跳变。\n\n### 早期启动支持\n\n在系统早期启动阶段，真实时钟源尚未注册，此时使用 `dummy_clock` 作为占位时钟源。其 `read` 函数返回 `local_clock()`（通常基于 TSC 或 jiffies），并设置 `mult=1, shift=0`，因为 `local_clock()` 直接返回纳秒值，无需转换。\n\n### 挂起/恢复处理\n\n当系统挂起时，`timekeeping_suspend()` 会记录当前时钟周期值到 `cycles_at_suspend`，并将 `dummy_clock` 的 `read` 函数改为返回该固定值，防止挂起期间时间继续推进。恢复时再切换回真实时钟源并补偿睡眠时间。\n\n### 序列锁保护\n\n主时间保持结构 `tk_core` 使用 `seqcount_raw_spinlock_t` 保护。写操作需持有 `timekeeper_lock`，读操作通过 `read_seqcount_begin()` / `read_seqcount_retry()` 实现无锁但一致的读取，适用于大多数用户空间时间查询路径（如 VDSO）。\n\n## 4. 依赖关系\n\n- **`<linux/clocksource.h>`**：依赖时钟源抽象，用于获取高精度硬件计时器。\n- **`<linux/tick.h>` / `tick-internal.h`**：与 tick 管理子系统交互，处理周期性时间更新。\n- **`ntp_internal.h`**：集成 NTP 频率调整和闰秒处理逻辑。\n- **`timekeeping_internal.h`**：包含内部辅助函数和结构定义。\n- **`<linux/vdso.h>` / `pvclock_gtod.h`**：为 VDSO 和虚拟化环境（如 Xen、KVM）提供高效时间读取支持。\n- **`<linux/sched/clock.h>`**：使用 `local_clock()` 作为早期启动和虚拟时钟源。\n- **`<linux/stop_machine.h>`**：在某些关键更新路径中可能使用 stop-machine 机制确保全局一致性。\n\n## 5. 使用场景\n\n- **系统调用时间查询**：如 `clock_gettime(CLOCK_REALTIME)`、`CLOCK_MONOTONIC` 等通过此模块获取高精度时间。\n- **VDSO 加速**：用户空间通过 VDSO 直接读取 `tk_fast` 结构，避免陷入内核。\n- **NMI 和中断处理**：在不可睡眠上下文中安全获取时间戳（如 perf、ftrace、oops 打印）。\n- **系统挂起/恢复**：在 suspend/resume 流程中冻结和恢复时间推进。\n- **NTP 时间同步**：接收用户空间 `adjtimex` 调用，调整时钟频率和偏移。\n- **内核日志时间戳**：`printk` 等日志系统依赖此模块提供单调或实时时钟。\n- **调度器和负载计算**：`update_wall_time()` 被 tick 中断定期调用，驱动时间推进，影响调度、负载均衡等子系统。",
      "similarity": 0.5889566540718079,
      "chunks": [
        {
          "chunk_id": 11,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 1840,
          "end_line": 1985,
          "content": [
            "int timekeeping_suspend(void)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned long flags;",
            "\tstruct timespec64\t\tdelta, delta_delta;",
            "\tstatic struct timespec64\told_delta;",
            "\tstruct clocksource *curr_clock;",
            "\tu64 cycle_now;",
            "",
            "\tread_persistent_clock64(&timekeeping_suspend_time);",
            "",
            "\t/*",
            "\t * On some systems the persistent_clock can not be detected at",
            "\t * timekeeping_init by its return value, so if we see a valid",
            "\t * value returned, update the persistent_clock_exists flag.",
            "\t */",
            "\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)",
            "\t\tpersistent_clock_exists = true;",
            "",
            "\tsuspend_timing_needed = true;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "\ttimekeeping_forward_now(tk);",
            "\ttimekeeping_suspended = 1;",
            "",
            "\t/*",
            "\t * Since we've called forward_now, cycle_last stores the value",
            "\t * just read from the current clocksource. Save this to potentially",
            "\t * use in suspend timing.",
            "\t */",
            "\tcurr_clock = tk->tkr_mono.clock;",
            "\tcycle_now = tk->tkr_mono.cycle_last;",
            "\tclocksource_start_suspend_timing(curr_clock, cycle_now);",
            "",
            "\tif (persistent_clock_exists) {",
            "\t\t/*",
            "\t\t * To avoid drift caused by repeated suspend/resumes,",
            "\t\t * which each can add ~1 second drift error,",
            "\t\t * try to compensate so the difference in system time",
            "\t\t * and persistent_clock time stays close to constant.",
            "\t\t */",
            "\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);",
            "\t\tdelta_delta = timespec64_sub(delta, old_delta);",
            "\t\tif (abs(delta_delta.tv_sec) >= 2) {",
            "\t\t\t/*",
            "\t\t\t * if delta_delta is too large, assume time correction",
            "\t\t\t * has occurred and set old_delta to the current delta.",
            "\t\t\t */",
            "\t\t\told_delta = delta;",
            "\t\t} else {",
            "\t\t\t/* Otherwise try to adjust old_system to compensate */",
            "\t\t\ttimekeeping_suspend_time =",
            "\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);",
            "\t\t}",
            "\t}",
            "",
            "\ttimekeeping_update(tk, TK_MIRROR);",
            "\thalt_fast_timekeeper(tk);",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\ttick_suspend();",
            "\tclocksource_suspend();",
            "\tclockevents_suspend();",
            "",
            "\treturn 0;",
            "}",
            "static int __init timekeeping_init_ops(void)",
            "{",
            "\tregister_syscore_ops(&timekeeping_syscore_ops);",
            "\treturn 0;",
            "}",
            "static __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,",
            "\t\t\t\t\t\t\t s64 offset,",
            "\t\t\t\t\t\t\t s32 mult_adj)",
            "{",
            "\ts64 interval = tk->cycle_interval;",
            "",
            "\tif (mult_adj == 0) {",
            "\t\treturn;",
            "\t} else if (mult_adj == -1) {",
            "\t\tinterval = -interval;",
            "\t\toffset = -offset;",
            "\t} else if (mult_adj != 1) {",
            "\t\tinterval *= mult_adj;",
            "\t\toffset *= mult_adj;",
            "\t}",
            "",
            "\t/*",
            "\t * So the following can be confusing.",
            "\t *",
            "\t * To keep things simple, lets assume mult_adj == 1 for now.",
            "\t *",
            "\t * When mult_adj != 1, remember that the interval and offset values",
            "\t * have been appropriately scaled so the math is the same.",
            "\t *",
            "\t * The basic idea here is that we're increasing the multiplier",
            "\t * by one, this causes the xtime_interval to be incremented by",
            "\t * one cycle_interval. This is because:",
            "\t *\txtime_interval = cycle_interval * mult",
            "\t * So if mult is being incremented by one:",
            "\t *\txtime_interval = cycle_interval * (mult + 1)",
            "\t * Its the same as:",
            "\t *\txtime_interval = (cycle_interval * mult) + cycle_interval",
            "\t * Which can be shortened to:",
            "\t *\txtime_interval += cycle_interval",
            "\t *",
            "\t * So offset stores the non-accumulated cycles. Thus the current",
            "\t * time (in shifted nanoseconds) is:",
            "\t *\tnow = (offset * adj) + xtime_nsec",
            "\t * Now, even though we're adjusting the clock frequency, we have",
            "\t * to keep time consistent. In other words, we can't jump back",
            "\t * in time, and we also want to avoid jumping forward in time.",
            "\t *",
            "\t * So given the same offset value, we need the time to be the same",
            "\t * both before and after the freq adjustment.",
            "\t *\tnow = (offset * adj_1) + xtime_nsec_1",
            "\t *\tnow = (offset * adj_2) + xtime_nsec_2",
            "\t * So:",
            "\t *\t(offset * adj_1) + xtime_nsec_1 =",
            "\t *\t\t(offset * adj_2) + xtime_nsec_2",
            "\t * And we know:",
            "\t *\tadj_2 = adj_1 + 1",
            "\t * So:",
            "\t *\t(offset * adj_1) + xtime_nsec_1 =",
            "\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2",
            "\t *\t(offset * adj_1) + xtime_nsec_1 =",
            "\t *\t\t(offset * adj_1) + offset + xtime_nsec_2",
            "\t * Canceling the sides:",
            "\t *\txtime_nsec_1 = offset + xtime_nsec_2",
            "\t * Which gives us:",
            "\t *\txtime_nsec_2 = xtime_nsec_1 - offset",
            "\t * Which simplifies to:",
            "\t *\txtime_nsec -= offset",
            "\t */",
            "\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {",
            "\t\t/* NTP adjustment caused clocksource mult overflow */",
            "\t\tWARN_ON_ONCE(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\ttk->tkr_mono.mult += mult_adj;",
            "\ttk->xtime_interval += interval;",
            "\ttk->tkr_mono.xtime_nsec -= offset;",
            "}"
          ],
          "function_name": "timekeeping_suspend, timekeeping_init_ops, timekeeping_apply_adjustment",
          "description": "实现系统挂起时的持久化时间记录与调整逻辑，初始化时间管理核心操作，应用频率调整参数以保持时间一致性",
          "similarity": 0.5725988149642944
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 2290,
          "end_line": 2394,
          "content": [
            "void do_timer(unsigned long ticks)",
            "{",
            "\tjiffies_64 += ticks;",
            "\tcalc_global_load();",
            "}",
            "ktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,",
            "\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned int seq;",
            "\tktime_t base;",
            "\tu64 nsecs;",
            "",
            "\tdo {",
            "\t\tseq = read_seqcount_begin(&tk_core.seq);",
            "",
            "\t\tbase = tk->tkr_mono.base;",
            "\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);",
            "\t\tbase = ktime_add_ns(base, nsecs);",
            "",
            "\t\tif (*cwsseq != tk->clock_was_set_seq) {",
            "\t\t\t*cwsseq = tk->clock_was_set_seq;",
            "\t\t\t*offs_real = tk->offs_real;",
            "\t\t\t*offs_boot = tk->offs_boot;",
            "\t\t\t*offs_tai = tk->offs_tai;",
            "\t\t}",
            "",
            "\t\t/* Handle leapsecond insertion adjustments */",
            "\t\tif (unlikely(base >= tk->next_leap_ktime))",
            "\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));",
            "",
            "\t} while (read_seqcount_retry(&tk_core.seq, seq));",
            "",
            "\treturn base;",
            "}",
            "static int timekeeping_validate_timex(const struct __kernel_timex *txc)",
            "{",
            "\tif (txc->modes & ADJ_ADJTIME) {",
            "\t\t/* singleshot must not be used with any other mode bits */",
            "\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))",
            "\t\t\treturn -EINVAL;",
            "\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&",
            "\t\t    !capable(CAP_SYS_TIME))",
            "\t\t\treturn -EPERM;",
            "\t} else {",
            "\t\t/* In order to modify anything, you gotta be super-user! */",
            "\t\tif (txc->modes && !capable(CAP_SYS_TIME))",
            "\t\t\treturn -EPERM;",
            "\t\t/*",
            "\t\t * if the quartz is off by more than 10% then",
            "\t\t * something is VERY wrong!",
            "\t\t */",
            "\t\tif (txc->modes & ADJ_TICK &&",
            "\t\t    (txc->tick <  900000/USER_HZ ||",
            "\t\t     txc->tick > 1100000/USER_HZ))",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (txc->modes & ADJ_SETOFFSET) {",
            "\t\t/* In order to inject time, you gotta be super-user! */",
            "\t\tif (!capable(CAP_SYS_TIME))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t/*",
            "\t\t * Validate if a timespec/timeval used to inject a time",
            "\t\t * offset is valid.  Offsets can be positive or negative, so",
            "\t\t * we don't check tv_sec. The value of the timeval/timespec",
            "\t\t * is the sum of its fields,but *NOTE*:",
            "\t\t * The field tv_usec/tv_nsec must always be non-negative and",
            "\t\t * we can't have more nanoseconds/microseconds than a second.",
            "\t\t */",
            "\t\tif (txc->time.tv_usec < 0)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (txc->modes & ADJ_NANO) {",
            "\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)",
            "\t\t\t\treturn -EINVAL;",
            "\t\t} else {",
            "\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)",
            "\t\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Check for potential multiplication overflows that can",
            "\t * only happen on 64-bit systems:",
            "\t */",
            "\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {",
            "\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)",
            "\t\t\treturn -EINVAL;",
            "\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "unsigned long random_get_entropy_fallback(void)",
            "{",
            "\tstruct tk_read_base *tkr = &tk_core.timekeeper.tkr_mono;",
            "\tstruct clocksource *clock = READ_ONCE(tkr->clock);",
            "",
            "\tif (unlikely(timekeeping_suspended || !clock))",
            "\t\treturn 0;",
            "\treturn clock->read(clock);",
            "}"
          ],
          "function_name": "do_timer, ktime_get_update_offsets_now, timekeeping_validate_timex, random_get_entropy_fallback",
          "description": "处理定时器中断更新jiffies，获取并验证时间校准参数有效性，提供熵收集回退函数读取钟源读数",
          "similarity": 0.5196052193641663
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 79,
          "end_line": 183,
          "content": [
            "static u64 dummy_clock_read(struct clocksource *cs)",
            "{",
            "\tif (timekeeping_suspended)",
            "\t\treturn cycles_at_suspend;",
            "\treturn local_clock();",
            "}",
            "static inline void tk_normalize_xtime(struct timekeeper *tk)",
            "{",
            "\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {",
            "\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;",
            "\t\ttk->xtime_sec++;",
            "\t}",
            "\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {",
            "\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;",
            "\t\ttk->raw_sec++;",
            "\t}",
            "}",
            "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)",
            "{",
            "\tstruct timespec64 ts;",
            "",
            "\tts.tv_sec = tk->xtime_sec;",
            "\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);",
            "\treturn ts;",
            "}",
            "static void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)",
            "{",
            "\ttk->xtime_sec = ts->tv_sec;",
            "\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;",
            "}",
            "static void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)",
            "{",
            "\ttk->xtime_sec += ts->tv_sec;",
            "\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;",
            "\ttk_normalize_xtime(tk);",
            "}",
            "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)",
            "{",
            "\tstruct timespec64 tmp;",
            "",
            "\t/*",
            "\t * Verify consistency of: offset_real = -wall_to_monotonic",
            "\t * before modifying anything",
            "\t */",
            "\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,",
            "\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);",
            "\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));",
            "\ttk->wall_to_monotonic = wtm;",
            "\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);",
            "\ttk->offs_real = timespec64_to_ktime(tmp);",
            "\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));",
            "}",
            "static inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)",
            "{",
            "\ttk->offs_boot = ktime_add(tk->offs_boot, delta);",
            "\t/*",
            "\t * Timespec representation for VDSO update to avoid 64bit division",
            "\t * on every update.",
            "\t */",
            "\ttk->monotonic_to_boot = ktime_to_timespec64(tk->offs_boot);",
            "}",
            "static inline u64 tk_clock_read(const struct tk_read_base *tkr)",
            "{",
            "\tstruct clocksource *clock = READ_ONCE(tkr->clock);",
            "",
            "\treturn clock->read(clock);",
            "}",
            "static void timekeeping_check_update(struct timekeeper *tk, u64 offset)",
            "{",
            "",
            "\tu64 max_cycles = tk->tkr_mono.clock->max_cycles;",
            "\tconst char *name = tk->tkr_mono.clock->name;",
            "",
            "\tif (offset > max_cycles) {",
            "\t\tprintk_deferred(\"WARNING: timekeeping: Cycle offset (%lld) is larger than allowed by the '%s' clock's max_cycles value (%lld): time overflow danger\\n\",",
            "\t\t\t\toffset, name, max_cycles);",
            "\t\tprintk_deferred(\"         timekeeping: Your kernel is sick, but tries to cope by capping time updates\\n\");",
            "\t} else {",
            "\t\tif (offset > (max_cycles >> 1)) {",
            "\t\t\tprintk_deferred(\"INFO: timekeeping: Cycle offset (%lld) is larger than the '%s' clock's 50%% safety margin (%lld)\\n\",",
            "\t\t\t\t\toffset, name, max_cycles >> 1);",
            "\t\t\tprintk_deferred(\"      timekeeping: Your kernel is still fine, but is feeling a bit nervous\\n\");",
            "\t\t}",
            "\t}",
            "",
            "\tif (tk->underflow_seen) {",
            "\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {",
            "\t\t\tprintk_deferred(\"WARNING: Underflow in clocksource '%s' observed, time update ignored.\\n\", name);",
            "\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");",
            "\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");",
            "\t\t\ttk->last_warning = jiffies;",
            "\t\t}",
            "\t\ttk->underflow_seen = 0;",
            "\t}",
            "",
            "\tif (tk->overflow_seen) {",
            "\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {",
            "\t\t\tprintk_deferred(\"WARNING: Overflow in clocksource '%s' observed, time update capped.\\n\", name);",
            "\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");",
            "\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");",
            "\t\t\ttk->last_warning = jiffies;",
            "\t\t}",
            "\t\ttk->overflow_seen = 0;",
            "\t}",
            "}"
          ],
          "function_name": "dummy_clock_read, tk_normalize_xtime, tk_xtime, tk_set_xtime, tk_xtime_add, tk_set_wall_to_mono, tk_update_sleep_time, tk_clock_read, timekeeping_check_update",
          "description": "实现时间归一化处理、时间戳转换、时间偏移设置及更新逻辑，检测时钟源偏移量是否超出允许范围，输出警告信息以防止时间溢出或下溢问题",
          "similarity": 0.5087895393371582
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 1689,
          "end_line": 1793,
          "content": [
            "static void __timekeeping_inject_sleeptime(struct timekeeper *tk,",
            "\t\t\t\t\t   const struct timespec64 *delta)",
            "{",
            "\tif (!timespec64_valid_strict(delta)) {",
            "\t\tprintk_deferred(KERN_WARNING",
            "\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"",
            "\t\t\t\t\"sleep delta value!\\n\");",
            "\t\treturn;",
            "\t}",
            "\ttk_xtime_add(tk, delta);",
            "\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));",
            "\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));",
            "\ttk_debug_account_sleep_time(delta);",
            "}",
            "bool timekeeping_rtc_skipresume(void)",
            "{",
            "\treturn !suspend_timing_needed;",
            "}",
            "bool timekeeping_rtc_skipsuspend(void)",
            "{",
            "\treturn persistent_clock_exists;",
            "}",
            "void timekeeping_inject_sleeptime64(const struct timespec64 *delta)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\tsuspend_timing_needed = false;",
            "",
            "\ttimekeeping_forward_now(tk);",
            "",
            "\t__timekeeping_inject_sleeptime(tk, delta);",
            "",
            "\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);",
            "",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\t/* Signal hrtimers about time change */",
            "\tclock_was_set(CLOCK_SET_WALL | CLOCK_SET_BOOT);",
            "}",
            "void timekeeping_resume(void)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tstruct clocksource *clock = tk->tkr_mono.clock;",
            "\tunsigned long flags;",
            "\tstruct timespec64 ts_new, ts_delta;",
            "\tu64 cycle_now, nsec;",
            "\tbool inject_sleeptime = false;",
            "",
            "\tread_persistent_clock64(&ts_new);",
            "",
            "\tclockevents_resume();",
            "\tclocksource_resume();",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\t/*",
            "\t * After system resumes, we need to calculate the suspended time and",
            "\t * compensate it for the OS time. There are 3 sources that could be",
            "\t * used: Nonstop clocksource during suspend, persistent clock and rtc",
            "\t * device.",
            "\t *",
            "\t * One specific platform may have 1 or 2 or all of them, and the",
            "\t * preference will be:",
            "\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc",
            "\t * The less preferred source will only be tried if there is no better",
            "\t * usable source. The rtc part is handled separately in rtc core code.",
            "\t */",
            "\tcycle_now = tk_clock_read(&tk->tkr_mono);",
            "\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);",
            "\tif (nsec > 0) {",
            "\t\tts_delta = ns_to_timespec64(nsec);",
            "\t\tinject_sleeptime = true;",
            "\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {",
            "\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);",
            "\t\tinject_sleeptime = true;",
            "\t}",
            "",
            "\tif (inject_sleeptime) {",
            "\t\tsuspend_timing_needed = false;",
            "\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);",
            "\t}",
            "",
            "\t/* Re-base the last cycle value */",
            "\ttk->tkr_mono.cycle_last = cycle_now;",
            "\ttk->tkr_raw.cycle_last  = cycle_now;",
            "",
            "\ttk->ntp_error = 0;",
            "\ttimekeeping_suspended = 0;",
            "\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\ttouch_softlockup_watchdog();",
            "",
            "\t/* Resume the clockevent device(s) and hrtimers */",
            "\ttick_resume();",
            "\t/* Notify timerfd as resume is equivalent to clock_was_set() */",
            "\ttimerfd_resume();",
            "}"
          ],
          "function_name": "__timekeeping_inject_sleeptime, timekeeping_rtc_skipresume, timekeeping_rtc_skipsuspend, timekeeping_inject_sleeptime64, timekeeping_resume",
          "description": "处理系统挂起/恢复时的时间调整，注入睡眠时间到时间保持器，控制RTC跳过逻辑，并通过clocksource计算周期差补偿系统时间",
          "similarity": 0.5064165592193604
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 2423,
          "end_line": 2497,
          "content": [
            "int do_adjtimex(struct __kernel_timex *txc)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tstruct audit_ntp_data ad;",
            "\tbool clock_set = false;",
            "\tstruct timespec64 ts;",
            "\tunsigned long flags;",
            "\ts32 orig_tai, tai;",
            "\tint ret;",
            "",
            "\t/* Validate the data before disabling interrupts */",
            "\tret = timekeeping_validate_timex(txc);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tadd_device_randomness(txc, sizeof(*txc));",
            "",
            "\tif (txc->modes & ADJ_SETOFFSET) {",
            "\t\tstruct timespec64 delta;",
            "\t\tdelta.tv_sec  = txc->time.tv_sec;",
            "\t\tdelta.tv_nsec = txc->time.tv_usec;",
            "\t\tif (!(txc->modes & ADJ_NANO))",
            "\t\t\tdelta.tv_nsec *= 1000;",
            "\t\tret = timekeeping_inject_offset(&delta);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "",
            "\t\taudit_tk_injoffset(delta);",
            "\t}",
            "",
            "\taudit_ntp_init(&ad);",
            "",
            "\tktime_get_real_ts64(&ts);",
            "\tadd_device_randomness(&ts, sizeof(ts));",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\torig_tai = tai = tk->tai_offset;",
            "\tret = __do_adjtimex(txc, &ts, &tai, &ad);",
            "",
            "\tif (tai != orig_tai) {",
            "\t\t__timekeeping_set_tai_offset(tk, tai);",
            "\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);",
            "\t\tclock_set = true;",
            "\t}",
            "\ttk_update_leap_state(tk);",
            "",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\taudit_ntp_log(&ad);",
            "",
            "\t/* Update the multiplier immediately if frequency was set directly */",
            "\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))",
            "\t\tclock_set |= timekeeping_advance(TK_ADV_FREQ);",
            "",
            "\tif (clock_set)",
            "\t\tclock_was_set(CLOCK_SET_WALL);",
            "",
            "\tntp_notify_cmos_timer();",
            "",
            "\treturn ret;",
            "}",
            "void hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\t__hardpps(phase_ts, raw_ts);",
            "",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "}"
          ],
          "function_name": "do_adjtimex, hardpps",
          "description": "该代码段实现时间调整与硬件脉冲信号处理功能。do_adjtimex函数负责解析并应用用户空间通过TIMEX接口提交的时间校准请求（如偏移量设置、频率调整），通过锁定时间保持器并更新TAI偏移量实现系统时间同步，同时记录审计日志。hardpps函数作为硬件PPS信号处理入口，通过加锁机制将相位时间戳传递给底层时间校准逻辑以修正系统时钟。",
          "similarity": 0.5060406923294067
        }
      ]
    },
    {
      "source_file": "kernel/sched/deadline.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:06:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\deadline.c`\n\n---\n\n# `sched/deadline.c` 技术文档\n\n## 1. 文件概述\n\n`sched/deadline.c` 是 Linux 内核调度器中 **SCHED_DEADLINE** 调度类的核心实现文件。该调度类基于 **最早截止时间优先（Earliest Deadline First, EDF）** 算法，并结合 **恒定带宽服务器（Constant Bandwidth Server, CBS）** 机制，为具有严格实时性要求的任务提供可预测的调度保障。\n\n其核心目标是：  \n- 对于周期性任务，若其实际运行时间不超过所申请的运行时间（runtime），则保证不会错过任何截止时间（deadline）；  \n- 对于非周期性任务、突发任务或试图超出其预留带宽的任务，系统会对其进行节流（throttling），防止其影响其他任务的实时性保障。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct sched_dl_entity`：表示一个 deadline 调度实体，包含任务的运行时间（runtime）、截止期限（deadline）、周期（period）、带宽（dl_bw）等关键参数。\n- `struct dl_rq`：每个 CPU 的 deadline 运行队列，维护该 CPU 上所有 deadline 任务的红黑树、当前带宽使用情况（`this_bw`、`running_bw`）等。\n- `struct dl_bw`：deadline 带宽管理结构，用于跟踪系统或调度域中已分配的总带宽（`total_bw`）。\n\n### 主要函数与辅助宏\n\n#### 调度实体与运行队列关联\n- `dl_task_of(dl_se)`：从 `sched_dl_entity` 获取对应的 `task_struct`（仅适用于普通任务，不适用于服务器实体）。\n- `rq_of_dl_rq(dl_rq)` / `rq_of_dl_se(dl_se)`：获取与 deadline 运行队列或调度实体关联的 `rq`（runqueue）。\n- `dl_rq_of_se(dl_se)`：获取调度实体所属的 `dl_rq`。\n- `on_dl_rq(dl_se)`：判断调度实体是否已在 deadline 运行队列中（通过红黑树节点是否为空判断）。\n\n#### 优先级继承（PI）支持（`CONFIG_RT_MUTEXES`）\n- `pi_of(dl_se)`：获取当前调度实体因优先级继承而提升后的“代理”实体。\n- `is_dl_boosted(dl_se)`：判断该 deadline 实体是否因优先级继承被提升。\n\n#### 带宽管理（SMP 与 UP 差异处理）\n- `dl_bw_of(cpu)`：获取指定 CPU 所属调度域（或本地）的 `dl_bw` 结构。\n- `dl_bw_cpus(cpu)`：返回该 CPU 所在调度域中活跃 CPU 的数量。\n- `dl_bw_capacity(cpu)`：计算调度域的总 CPU 容量（考虑异构 CPU 的 `arch_scale_cpu_capacity`）。\n- `__dl_add()` / `__dl_sub()`：向带宽池中添加或移除任务带宽，并更新 `extra_bw`（用于负载均衡）。\n- `__dl_overflow()`：检查新增带宽是否超出系统/调度域的可用带宽上限。\n\n#### 运行时带宽跟踪\n- `__add_running_bw()` / `__sub_running_bw()`：更新 `dl_rq->running_bw`（当前正在运行的 deadline 任务所消耗的带宽）。\n- `__add_rq_bw()` / `__sub_rq_bw()`：更新 `dl_rq->this_bw`（该运行队列上所有 deadline 任务的总预留带宽）。\n- `add_running_bw()` / `sub_running_bw()` / `add_rq_bw()` / `sub_rq_bw()`：带宽操作的封装，跳过“特殊”调度实体（如服务器）。\n\n#### 其他\n- `dl_server(dl_se)`：判断调度实体是否为 CBS 服务器（而非普通任务）。\n- `dl_bw_visited(cpu, gen)`：用于带宽遍历去重（SMP 场景）。\n\n### 系统控制接口（`CONFIG_SYSCTL`）\n- `sched_deadline_period_max_us`：deadline 任务周期上限（默认 ~4 秒）。\n- `sched_deadline_period_min_us`：deadline 任务周期下限（默认 100 微秒），防止定时器 DoS。\n\n## 3. 关键实现\n\n### EDF + CBS 调度模型\n- 每个 deadline 任务通过 `runtime`、`deadline`、`period` 三个参数定义其资源需求。\n- 调度器按 **绝对截止时间（absolute deadline）** 对任务排序，使用红黑树实现 O(log n) 的调度决策。\n- CBS 机制确保任务即使突发执行，也不会长期占用超过其 `runtime/period` 的 CPU 带宽，超限任务会被 throttled。\n\n### 带宽隔离与全局限制\n- 在 SMP 系统中，deadline 带宽按 **调度域（root domain）** 进行管理，防止跨 CPU 的带宽滥用。\n- 总带宽限制默认为 CPU 总容量的 95%（由 `sysctl_sched_util_clamp_min` 等机制间接控制，具体限制逻辑在带宽分配函数中体现）。\n- `dl_bw->total_bw` 跟踪已分配带宽，`__dl_overflow()` 用于在任务加入时检查是否超限。\n\n### 异构 CPU 支持\n- 通过 `arch_scale_cpu_capacity()` 获取每个 CPU 的相对性能权重。\n- `dl_bw_capacity()` 在异构系统中返回调度域内所有活跃 CPU 的容量总和，用于带宽比例计算（`cap_scale()`）。\n\n### 与 cpufreq 集成\n- 每次 `running_bw` 变化时调用 `cpufreq_update_util()`，通知 CPU 频率调节器当前 deadline 负载，确保满足实时性能需求。\n\n### 优先级继承（PI）\n- 当 deadline 任务因持有 mutex 而阻塞高优先级任务时，通过 `pi_se` 字段临时提升其调度参数，避免优先级反转。\n\n## 4. 依赖关系\n\n- **核心调度框架**：依赖 `kernel/sched/sched.h` 中定义的通用调度结构（如 `rq`、`task_struct`）和宏（如 `SCHED_CAPACITY_SCALE`）。\n- **CPU 拓扑与容量**：依赖 `arch_scale_cpu_capacity()`（由各架构实现）获取 CPU 性能信息。\n- **RCU 机制**：在 SMP 路径中大量使用 `rcu_read_lock_sched_held()` 进行锁依赖检查。\n- **cpufreq 子系统**：通过 `cpufreq_update_util()` 与 CPU 频率调节器交互。\n- **实时互斥锁**：`CONFIG_RT_MUTEXES` 启用时，支持 deadline 任务的优先级继承。\n- **Sysctl 接口**：`CONFIG_SYSCTL` 启用时，提供用户空间可调的 deadline 参数。\n\n## 5. 使用场景\n\n- **工业实时控制**：如机器人控制、数控机床等需要严格周期性和低延迟响应的场景。\n- **音视频处理**：专业音视频采集、编码、播放等对 jitter 敏感的应用。\n- **电信基础设施**：5G 基站、核心网网元中的高优先级信令处理。\n- **汽车电子**：ADAS、自动驾驶系统中的关键任务调度。\n- **科研与高性能计算**：需要确定性执行时间的实验或仿真任务。\n\n用户通过 `sched_setattr(2)` 系统调用设置任务的 `SCHED_DEADLINE` 策略及对应的 `runtime`、`deadline`、`period` 参数，内核则通过本文件实现的调度逻辑确保其满足实时性约束。",
      "similarity": 0.5862058997154236,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 1741,
          "end_line": 1857,
          "content": [
            "static void update_curr_dl(struct rq *rq)",
            "{",
            "\tstruct task_struct *curr = rq->curr;",
            "\tstruct sched_dl_entity *dl_se = &curr->dl;",
            "\ts64 delta_exec;",
            "",
            "\tif (!dl_task(curr) || !on_dl_rq(dl_se))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Consumed budget is computed considering the time as",
            "\t * observed by schedulable tasks (excluding time spent",
            "\t * in hardirq context, etc.). Deadlines are instead",
            "\t * computed using hard walltime. This seems to be the more",
            "\t * natural solution, but the full ramifications of this",
            "\t * approach need further study.",
            "\t */",
            "\tdelta_exec = update_curr_common(rq);",
            "\tupdate_curr_dl_se(rq, dl_se, delta_exec);",
            "}",
            "static enum hrtimer_restart inactive_task_timer(struct hrtimer *timer)",
            "{",
            "\tstruct sched_dl_entity *dl_se = container_of(timer,",
            "\t\t\t\t\t\t     struct sched_dl_entity,",
            "\t\t\t\t\t\t     inactive_timer);",
            "\tstruct task_struct *p = NULL;",
            "\tstruct rq_flags rf;",
            "\tstruct rq *rq;",
            "",
            "\tif (!dl_server(dl_se)) {",
            "\t\tp = dl_task_of(dl_se);",
            "\t\trq = task_rq_lock(p, &rf);",
            "\t} else {",
            "\t\trq = dl_se->rq;",
            "\t\trq_lock(rq, &rf);",
            "\t}",
            "",
            "\tsched_clock_tick();",
            "\tupdate_rq_clock(rq);",
            "",
            "\tif (dl_server(dl_se))",
            "\t\tgoto no_task;",
            "",
            "\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {",
            "\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));",
            "",
            "\t\tif (READ_ONCE(p->__state) == TASK_DEAD && dl_se->dl_non_contending) {",
            "\t\t\tsub_running_bw(&p->dl, dl_rq_of_se(&p->dl));",
            "\t\t\tsub_rq_bw(&p->dl, dl_rq_of_se(&p->dl));",
            "\t\t\tdl_se->dl_non_contending = 0;",
            "\t\t}",
            "",
            "\t\traw_spin_lock(&dl_b->lock);",
            "\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));",
            "\t\traw_spin_unlock(&dl_b->lock);",
            "\t\t__dl_clear_params(dl_se);",
            "",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "no_task:",
            "\tif (dl_se->dl_non_contending == 0)",
            "\t\tgoto unlock;",
            "",
            "\tsub_running_bw(dl_se, &rq->dl);",
            "\tdl_se->dl_non_contending = 0;",
            "unlock:",
            "",
            "\tif (!dl_server(dl_se)) {",
            "\t\ttask_rq_unlock(rq, p, &rf);",
            "\t\tput_task_struct(p);",
            "\t} else {",
            "\t\trq_unlock(rq, &rf);",
            "\t}",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}",
            "static void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct hrtimer *timer = &dl_se->inactive_timer;",
            "",
            "\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);",
            "\ttimer->function = inactive_task_timer;",
            "}",
            "static void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline)",
            "{",
            "\tstruct rq *rq = rq_of_dl_rq(dl_rq);",
            "",
            "\tif (dl_rq->earliest_dl.curr == 0 ||",
            "\t    dl_time_before(deadline, dl_rq->earliest_dl.curr)) {",
            "\t\tif (dl_rq->earliest_dl.curr == 0)",
            "\t\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, CPUPRI_HIGHER);",
            "\t\tdl_rq->earliest_dl.curr = deadline;",
            "\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, deadline);",
            "\t}",
            "}",
            "static void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline)",
            "{",
            "\tstruct rq *rq = rq_of_dl_rq(dl_rq);",
            "",
            "\t/*",
            "\t * Since we may have removed our earliest (and/or next earliest)",
            "\t * task we must recompute them.",
            "\t */",
            "\tif (!dl_rq->dl_nr_running) {",
            "\t\tdl_rq->earliest_dl.curr = 0;",
            "\t\tdl_rq->earliest_dl.next = 0;",
            "\t\tcpudl_clear(&rq->rd->cpudl, rq->cpu);",
            "\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, rq->rt.highest_prio.curr);",
            "\t} else {",
            "\t\tstruct rb_node *leftmost = rb_first_cached(&dl_rq->root);",
            "\t\tstruct sched_dl_entity *entry = __node_2_dle(leftmost);",
            "",
            "\t\tdl_rq->earliest_dl.curr = entry->deadline;",
            "\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, entry->deadline);",
            "\t}",
            "}"
          ],
          "function_name": "update_curr_dl, inactive_task_timer, init_dl_inactive_task_timer, inc_dl_deadline, dec_dl_deadline",
          "description": "实现截止时间调度器的核心逻辑，包含update_curr_dl更新当前任务执行时间，inactive_task_timer处理非竞争任务的定时器逻辑，init_dl_inactive_task_timer初始化定时器，inc_dl_deadline和dec_dl_deadline维护截止时间队列的最早截止时间",
          "similarity": 0.5479952096939087
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 514,
          "end_line": 616,
          "content": [
            "static inline int is_leftmost(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)",
            "{",
            "\treturn rb_first_cached(&dl_rq->root) == &dl_se->rb_node;",
            "}",
            "void init_dl_bw(struct dl_bw *dl_b)",
            "{",
            "\traw_spin_lock_init(&dl_b->lock);",
            "\tif (global_rt_runtime() == RUNTIME_INF)",
            "\t\tdl_b->bw = -1;",
            "\telse",
            "\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());",
            "\tdl_b->total_bw = 0;",
            "}",
            "void init_dl_rq(struct dl_rq *dl_rq)",
            "{",
            "\tdl_rq->root = RB_ROOT_CACHED;",
            "",
            "#ifdef CONFIG_SMP",
            "\t/* zero means no -deadline tasks */",
            "\tdl_rq->earliest_dl.curr = dl_rq->earliest_dl.next = 0;",
            "",
            "\tdl_rq->overloaded = 0;",
            "\tdl_rq->pushable_dl_tasks_root = RB_ROOT_CACHED;",
            "#else",
            "\tinit_dl_bw(&dl_rq->dl_bw);",
            "#endif",
            "",
            "\tdl_rq->running_bw = 0;",
            "\tdl_rq->this_bw = 0;",
            "\tinit_dl_rq_bw_ratio(dl_rq);",
            "}",
            "static inline int dl_overloaded(struct rq *rq)",
            "{",
            "\treturn atomic_read(&rq->rd->dlo_count);",
            "}",
            "static inline void dl_set_overload(struct rq *rq)",
            "{",
            "\tif (!rq->online)",
            "\t\treturn;",
            "",
            "\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);",
            "\t/*",
            "\t * Must be visible before the overload count is",
            "\t * set (as in sched_rt.c).",
            "\t *",
            "\t * Matched by the barrier in pull_dl_task().",
            "\t */",
            "\tsmp_wmb();",
            "\tatomic_inc(&rq->rd->dlo_count);",
            "}",
            "static inline void dl_clear_overload(struct rq *rq)",
            "{",
            "\tif (!rq->online)",
            "\t\treturn;",
            "",
            "\tatomic_dec(&rq->rd->dlo_count);",
            "\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);",
            "}",
            "static inline bool __pushable_less(struct rb_node *a, const struct rb_node *b)",
            "{",
            "\treturn dl_entity_preempt(&__node_2_pdl(a)->dl, &__node_2_pdl(b)->dl);",
            "}",
            "static inline int has_pushable_dl_tasks(struct rq *rq)",
            "{",
            "\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);",
            "}",
            "static void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)",
            "{",
            "\tstruct rb_node *leftmost;",
            "",
            "\tWARN_ON_ONCE(!RB_EMPTY_NODE(&p->pushable_dl_tasks));",
            "",
            "\tleftmost = rb_add_cached(&p->pushable_dl_tasks,",
            "\t\t\t\t &rq->dl.pushable_dl_tasks_root,",
            "\t\t\t\t __pushable_less);",
            "\tif (leftmost)",
            "\t\trq->dl.earliest_dl.next = p->dl.deadline;",
            "",
            "\tif (!rq->dl.overloaded) {",
            "\t\tdl_set_overload(rq);",
            "\t\trq->dl.overloaded = 1;",
            "\t}",
            "}",
            "static void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)",
            "{",
            "\tstruct dl_rq *dl_rq = &rq->dl;",
            "\tstruct rb_root_cached *root = &dl_rq->pushable_dl_tasks_root;",
            "\tstruct rb_node *leftmost;",
            "",
            "\tif (RB_EMPTY_NODE(&p->pushable_dl_tasks))",
            "\t\treturn;",
            "",
            "\tleftmost = rb_erase_cached(&p->pushable_dl_tasks, root);",
            "\tif (leftmost)",
            "\t\tdl_rq->earliest_dl.next = __node_2_pdl(leftmost)->dl.deadline;",
            "",
            "\tRB_CLEAR_NODE(&p->pushable_dl_tasks);",
            "",
            "\tif (!has_pushable_dl_tasks(rq) && rq->dl.overloaded) {",
            "\t\tdl_clear_overload(rq);",
            "\t\trq->dl.overloaded = 0;",
            "\t}",
            "}"
          ],
          "function_name": "is_leftmost, init_dl_bw, init_dl_rq, dl_overloaded, dl_set_overload, dl_clear_overload, __pushable_less, has_pushable_dl_tasks, enqueue_pushable_dl_task, dequeue_pushable_dl_task",
          "description": "实现截止时间调度的抢占判定和过载管理机制，包含任务优先级比较、过载标记维护及可推送任务的数据结构操作。",
          "similarity": 0.5471577644348145
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 2271,
          "end_line": 2386,
          "content": [
            "static void migrate_task_rq_dl(struct task_struct *p, int new_cpu __maybe_unused)",
            "{",
            "\tstruct rq_flags rf;",
            "\tstruct rq *rq;",
            "",
            "\tif (READ_ONCE(p->__state) != TASK_WAKING)",
            "\t\treturn;",
            "",
            "\trq = task_rq(p);",
            "\t/*",
            "\t * Since p->state == TASK_WAKING, set_task_cpu() has been called",
            "\t * from try_to_wake_up(). Hence, p->pi_lock is locked, but",
            "\t * rq->lock is not... So, lock it",
            "\t */",
            "\trq_lock(rq, &rf);",
            "\tif (p->dl.dl_non_contending) {",
            "\t\tupdate_rq_clock(rq);",
            "\t\tsub_running_bw(&p->dl, &rq->dl);",
            "\t\tp->dl.dl_non_contending = 0;",
            "\t\t/*",
            "\t\t * If the timer handler is currently running and the",
            "\t\t * timer cannot be canceled, inactive_task_timer()",
            "\t\t * will see that dl_not_contending is not set, and",
            "\t\t * will not touch the rq's active utilization,",
            "\t\t * so we are still safe.",
            "\t\t */",
            "\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)",
            "\t\t\tput_task_struct(p);",
            "\t}",
            "\tsub_rq_bw(&p->dl, &rq->dl);",
            "\trq_unlock(rq, &rf);",
            "}",
            "static void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)",
            "{",
            "\t/*",
            "\t * Current can't be migrated, useless to reschedule,",
            "\t * let's hope p can move out.",
            "\t */",
            "\tif (rq->curr->nr_cpus_allowed == 1 ||",
            "\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * p is migratable, so let's not schedule it and",
            "\t * see if it is pushed or pulled somewhere else.",
            "\t */",
            "\tif (p->nr_cpus_allowed != 1 &&",
            "\t    cpudl_find(&rq->rd->cpudl, p, NULL))",
            "\t\treturn;",
            "",
            "\tresched_curr(rq);",
            "}",
            "static int balance_dl(struct rq *rq, struct task_struct *p, struct rq_flags *rf)",
            "{",
            "\tif (!on_dl_rq(&p->dl) && need_pull_dl_task(rq, p)) {",
            "\t\t/*",
            "\t\t * This is OK, because current is on_cpu, which avoids it being",
            "\t\t * picked for load-balance and preemption/IRQs are still",
            "\t\t * disabled avoiding further scheduler activity on it and we've",
            "\t\t * not yet started the picking loop.",
            "\t\t */",
            "\t\trq_unpin_lock(rq, rf);",
            "\t\tpull_dl_task(rq);",
            "\t\trq_repin_lock(rq, rf);",
            "\t}",
            "",
            "\treturn sched_stop_runnable(rq) || sched_dl_runnable(rq);",
            "}",
            "static void wakeup_preempt_dl(struct rq *rq, struct task_struct *p,",
            "\t\t\t\t  int flags)",
            "{",
            "\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {",
            "\t\tresched_curr(rq);",
            "\t\treturn;",
            "\t}",
            "",
            "#ifdef CONFIG_SMP",
            "\t/*",
            "\t * In the unlikely case current and p have the same deadline",
            "\t * let us try to decide what's the best thing to do...",
            "\t */",
            "\tif ((p->dl.deadline == rq->curr->dl.deadline) &&",
            "\t    !test_tsk_need_resched(rq->curr))",
            "\t\tcheck_preempt_equal_dl(rq, p);",
            "#endif /* CONFIG_SMP */",
            "}",
            "static void start_hrtick_dl(struct rq *rq, struct sched_dl_entity *dl_se)",
            "{",
            "\thrtick_start(rq, dl_se->runtime);",
            "}",
            "static void start_hrtick_dl(struct rq *rq, struct sched_dl_entity *dl_se)",
            "{",
            "}",
            "static void set_next_task_dl(struct rq *rq, struct task_struct *p, bool first)",
            "{",
            "\tstruct sched_dl_entity *dl_se = &p->dl;",
            "\tstruct dl_rq *dl_rq = &rq->dl;",
            "",
            "\tp->se.exec_start = rq_clock_task(rq);",
            "\tif (on_dl_rq(&p->dl))",
            "\t\tupdate_stats_wait_end_dl(dl_rq, dl_se);",
            "",
            "\t/* You can't push away the running task */",
            "\tdequeue_pushable_dl_task(rq, p);",
            "",
            "\tif (!first)",
            "\t\treturn;",
            "",
            "\tif (rq->curr->sched_class != &dl_sched_class)",
            "\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);",
            "",
            "\tdeadline_queue_push_tasks(rq);",
            "",
            "\tif (hrtick_enabled(rq))",
            "\t\tstart_hrtick_dl(rq, &p->dl);",
            "}"
          ],
          "function_name": "migrate_task_rq_dl, check_preempt_equal_dl, balance_dl, wakeup_preempt_dl, start_hrtick_dl, start_hrtick_dl, set_next_task_dl",
          "description": "实现截止时间调度器的迁移处理、抢占检测、负载平衡及定时器控制，包含任务迁移、相等截止时间抢占决策、负载平衡及高精度定时器启动逻辑，存在重复函数定义表明上下文不完整",
          "similarity": 0.5465967655181885
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 966,
          "end_line": 1100,
          "content": [
            "static bool dl_entity_overflow(struct sched_dl_entity *dl_se, u64 t)",
            "{",
            "\tu64 left, right;",
            "",
            "\t/*",
            "\t * left and right are the two sides of the equation above,",
            "\t * after a bit of shuffling to use multiplications instead",
            "\t * of divisions.",
            "\t *",
            "\t * Note that none of the time values involved in the two",
            "\t * multiplications are absolute: dl_deadline and dl_runtime",
            "\t * are the relative deadline and the maximum runtime of each",
            "\t * instance, runtime is the runtime left for the last instance",
            "\t * and (deadline - t), since t is rq->clock, is the time left",
            "\t * to the (absolute) deadline. Even if overflowing the u64 type",
            "\t * is very unlikely to occur in both cases, here we scale down",
            "\t * as we want to avoid that risk at all. Scaling down by 10",
            "\t * means that we reduce granularity to 1us. We are fine with it,",
            "\t * since this is only a true/false check and, anyway, thinking",
            "\t * of anything below microseconds resolution is actually fiction",
            "\t * (but still we want to give the user that illusion >;).",
            "\t */",
            "\tleft = (pi_of(dl_se)->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);",
            "\tright = ((dl_se->deadline - t) >> DL_SCALE) *",
            "\t\t(pi_of(dl_se)->dl_runtime >> DL_SCALE);",
            "",
            "\treturn dl_time_before(right, left);",
            "}",
            "static void",
            "update_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)",
            "{",
            "\tu64 laxity = dl_se->deadline - rq_clock(rq);",
            "",
            "\t/*",
            "\t * If the task has deadline < period, and the deadline is in the past,",
            "\t * it should already be throttled before this check.",
            "\t *",
            "\t * See update_dl_entity() comments for further details.",
            "\t */",
            "\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));",
            "",
            "\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;",
            "}",
            "static inline bool dl_is_implicit(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn dl_se->dl_deadline == dl_se->dl_period;",
            "}",
            "static void update_dl_entity(struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct rq *rq = rq_of_dl_se(dl_se);",
            "",
            "\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||",
            "\t    dl_entity_overflow(dl_se, rq_clock(rq))) {",
            "",
            "\t\tif (unlikely(!dl_is_implicit(dl_se) &&",
            "\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&",
            "\t\t\t     !is_dl_boosted(dl_se))) {",
            "\t\t\tupdate_dl_revised_wakeup(dl_se, rq);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\treplenish_dl_new_period(dl_se, rq);",
            "\t} else if (dl_server(dl_se) && dl_se->dl_defer) {",
            "\t\t/*",
            "\t\t * The server can still use its previous deadline, so check if",
            "\t\t * it left the dl_defer_running state.",
            "\t\t */",
            "\t\tif (!dl_se->dl_defer_running) {",
            "\t\t\tdl_se->dl_defer_armed = 1;",
            "\t\t\tdl_se->dl_throttled = 1;",
            "\t\t}",
            "\t}",
            "}",
            "static inline u64 dl_next_period(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;",
            "}",
            "static int start_dl_timer(struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct hrtimer *timer = &dl_se->dl_timer;",
            "\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);",
            "\tstruct rq *rq = rq_of_dl_rq(dl_rq);",
            "\tktime_t now, act;",
            "\ts64 delta;",
            "",
            "\tlockdep_assert_rq_held(rq);",
            "",
            "\t/*",
            "\t * We want the timer to fire at the deadline, but considering",
            "\t * that it is actually coming from rq->clock and not from",
            "\t * hrtimer's time base reading.",
            "\t *",
            "\t * The deferred reservation will have its timer set to",
            "\t * (deadline - runtime). At that point, the CBS rule will decide",
            "\t * if the current deadline can be used, or if a replenishment is",
            "\t * required to avoid add too much pressure on the system",
            "\t * (current u > U).",
            "\t */",
            "\tif (dl_se->dl_defer_armed) {",
            "\t\tWARN_ON_ONCE(!dl_se->dl_throttled);",
            "\t\tact = ns_to_ktime(dl_se->deadline - dl_se->runtime);",
            "\t} else {",
            "\t\t/* act = deadline - rel-deadline + period */",
            "\t\tact = ns_to_ktime(dl_next_period(dl_se));",
            "\t}",
            "",
            "\tnow = hrtimer_cb_get_time(timer);",
            "\tdelta = ktime_to_ns(now) - rq_clock(rq);",
            "\tact = ktime_add_ns(act, delta);",
            "",
            "\t/*",
            "\t * If the expiry time already passed, e.g., because the value",
            "\t * chosen as the deadline is too small, don't even try to",
            "\t * start the timer in the past!",
            "\t */",
            "\tif (ktime_us_delta(act, now) < 0)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * !enqueued will guarantee another callback; even if one is already in",
            "\t * progress. This ensures a balanced {get,put}_task_struct().",
            "\t *",
            "\t * The race against __run_timer() clearing the enqueued state is",
            "\t * harmless because we're holding task_rq()->lock, therefore the timer",
            "\t * expiring after we've done the check will wait on its task_rq_lock()",
            "\t * and observe our state.",
            "\t */",
            "\tif (!hrtimer_is_queued(timer)) {",
            "\t\tif (!dl_server(dl_se))",
            "\t\t\tget_task_struct(dl_task_of(dl_se));",
            "\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS_HARD);",
            "\t}",
            "",
            "\treturn 1;",
            "}"
          ],
          "function_name": "dl_entity_overflow, update_dl_revised_wakeup, dl_is_implicit, update_dl_entity, dl_next_period, start_dl_timer",
          "description": "实现了截止时间任务的溢出检测、唤醒时间调整、隐式截止时间判定及动态实体更新逻辑，包含基于带宽的调度策略和超时处理机制。",
          "similarity": 0.5411604046821594
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 1176,
          "end_line": 1341,
          "content": [
            "static void __push_dl_task(struct rq *rq, struct rq_flags *rf)",
            "{",
            "#ifdef CONFIG_SMP",
            "\t/*",
            "\t * Queueing this task back might have overloaded rq, check if we need",
            "\t * to kick someone away.",
            "\t */",
            "\tif (has_pushable_dl_tasks(rq)) {",
            "\t\t/*",
            "\t\t * Nothing relies on rq->lock after this, so its safe to drop",
            "\t\t * rq->lock.",
            "\t\t */",
            "\t\trq_unpin_lock(rq, rf);",
            "\t\tpush_dl_task(rq);",
            "\t\trq_repin_lock(rq, rf);",
            "\t}",
            "#endif",
            "}",
            "static enum hrtimer_restart dl_server_timer(struct hrtimer *timer, struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct rq *rq = rq_of_dl_se(dl_se);",
            "\tu64 fw;",
            "",
            "\tscoped_guard (rq_lock, rq) {",
            "\t\tstruct rq_flags *rf = &scope.rf;",
            "",
            "\t\tif (!dl_se->dl_throttled || !dl_se->dl_runtime)",
            "\t\t\treturn HRTIMER_NORESTART;",
            "",
            "\t\tsched_clock_tick();",
            "\t\tupdate_rq_clock(rq);",
            "",
            "\t\tif (!dl_se->dl_runtime)",
            "\t\t\treturn HRTIMER_NORESTART;",
            "",
            "\t\tif (!dl_se->server_has_tasks(dl_se)) {",
            "\t\t\treplenish_dl_entity(dl_se);",
            "\t\t\treturn HRTIMER_NORESTART;",
            "\t\t}",
            "",
            "\t\tif (dl_se->dl_defer_armed) {",
            "\t\t\t/*",
            "\t\t\t * First check if the server could consume runtime in background.",
            "\t\t\t * If so, it is possible to push the defer timer for this amount",
            "\t\t\t * of time. The dl_server_min_res serves as a limit to avoid",
            "\t\t\t * forwarding the timer for a too small amount of time.",
            "\t\t\t */",
            "\t\t\tif (dl_time_before(rq_clock(dl_se->rq),",
            "\t\t\t\t\t   (dl_se->deadline - dl_se->runtime - dl_server_min_res))) {",
            "",
            "\t\t\t\t/* reset the defer timer */",
            "\t\t\t\tfw = dl_se->deadline - rq_clock(dl_se->rq) - dl_se->runtime;",
            "",
            "\t\t\t\thrtimer_forward_now(timer, ns_to_ktime(fw));",
            "\t\t\t\treturn HRTIMER_RESTART;",
            "\t\t\t}",
            "",
            "\t\t\tdl_se->dl_defer_running = 1;",
            "\t\t}",
            "",
            "\t\tenqueue_dl_entity(dl_se, ENQUEUE_REPLENISH);",
            "",
            "\t\tif (!dl_task(dl_se->rq->curr) || dl_entity_preempt(dl_se, &dl_se->rq->curr->dl))",
            "\t\t\tresched_curr(rq);",
            "",
            "\t\t__push_dl_task(rq, rf);",
            "\t}",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}",
            "static enum hrtimer_restart dl_task_timer(struct hrtimer *timer)",
            "{",
            "\tstruct sched_dl_entity *dl_se = container_of(timer,",
            "\t\t\t\t\t\t     struct sched_dl_entity,",
            "\t\t\t\t\t\t     dl_timer);",
            "\tstruct task_struct *p;",
            "\tstruct rq_flags rf;",
            "\tstruct rq *rq;",
            "",
            "\tif (dl_server(dl_se))",
            "\t\treturn dl_server_timer(timer, dl_se);",
            "",
            "\tp = dl_task_of(dl_se);",
            "\trq = task_rq_lock(p, &rf);",
            "",
            "\t/*",
            "\t * The task might have changed its scheduling policy to something",
            "\t * different than SCHED_DEADLINE (through switched_from_dl()).",
            "\t */",
            "\tif (!dl_task(p))",
            "\t\tgoto unlock;",
            "",
            "\t/*",
            "\t * The task might have been boosted by someone else and might be in the",
            "\t * boosting/deboosting path, its not throttled.",
            "\t */",
            "\tif (is_dl_boosted(dl_se))",
            "\t\tgoto unlock;",
            "",
            "\t/*",
            "\t * Spurious timer due to start_dl_timer() race; or we already received",
            "\t * a replenishment from rt_mutex_setprio().",
            "\t */",
            "\tif (!dl_se->dl_throttled)",
            "\t\tgoto unlock;",
            "",
            "\tsched_clock_tick();",
            "\tupdate_rq_clock(rq);",
            "",
            "\t/*",
            "\t * If the throttle happened during sched-out; like:",
            "\t *",
            "\t *   schedule()",
            "\t *     deactivate_task()",
            "\t *       dequeue_task_dl()",
            "\t *         update_curr_dl()",
            "\t *           start_dl_timer()",
            "\t *         __dequeue_task_dl()",
            "\t *     prev->on_rq = 0;",
            "\t *",
            "\t * We can be both throttled and !queued. Replenish the counter",
            "\t * but do not enqueue -- wait for our wakeup to do that.",
            "\t */",
            "\tif (!task_on_rq_queued(p)) {",
            "\t\treplenish_dl_entity(dl_se);",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "#ifdef CONFIG_SMP",
            "\tif (unlikely(!rq->online)) {",
            "\t\t/*",
            "\t\t * If the runqueue is no longer available, migrate the",
            "\t\t * task elsewhere. This necessarily changes rq.",
            "\t\t */",
            "\t\tlockdep_unpin_lock(__rq_lockp(rq), rf.cookie);",
            "\t\trq = dl_task_offline_migration(rq, p);",
            "\t\trf.cookie = lockdep_pin_lock(__rq_lockp(rq));",
            "\t\tupdate_rq_clock(rq);",
            "",
            "\t\t/*",
            "\t\t * Now that the task has been migrated to the new RQ and we",
            "\t\t * have that locked, proceed as normal and enqueue the task",
            "\t\t * there.",
            "\t\t */",
            "\t}",
            "#endif",
            "",
            "\tenqueue_task_dl(rq, p, ENQUEUE_REPLENISH);",
            "\tif (dl_task(rq->curr))",
            "\t\twakeup_preempt_dl(rq, p, 0);",
            "\telse",
            "\t\tresched_curr(rq);",
            "",
            "\t__push_dl_task(rq, &rf);",
            "",
            "unlock:",
            "\ttask_rq_unlock(rq, p, &rf);",
            "",
            "\t/*",
            "\t * This can free the task_struct, including this hrtimer, do not touch",
            "\t * anything related to that after this.",
            "\t */",
            "\tput_task_struct(p);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}"
          ],
          "function_name": "__push_dl_task, dl_server_timer, dl_task_timer",
          "description": "处理截止时间任务的推送逻辑和定时器回调，通过服务器定时器管理延迟任务重排，协调多核环境下的任务迁移与抢占。",
          "similarity": 0.5240498185157776
        }
      ]
    },
    {
      "source_file": "kernel/time/timer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:57:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timer.c`\n\n---\n\n# `time/timer.c` 技术文档\n\n## 1. 文件概述\n\n`time/timer.c` 是 Linux 内核中实现**内核定时器子系统**的核心文件，负责管理基于**定时器轮（timer wheel）** 的动态定时器机制。该文件提供了高效、可扩展的定时器调度框架，支持高精度超时处理、SMP（对称多处理）环境下的 per-CPU 定时器管理，以及与 NO_HZ（动态 tick）节能机制的集成。其设计目标是在保证大多数超时场景（如网络、I/O 超时）性能的同时，通过多级粒度结构避免传统定时器轮中频繁的级联（cascading）操作，从而提升系统可扩展性。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`jiffies_64`**：全局 64 位 jiffies 计数器，记录自系统启动以来的时钟滴答数，对齐缓存行以优化 SMP 访问。\n- **多级定时器轮（Timer Wheel）结构**：\n  - 由 `LVL_DEPTH` 层（通常为 8 或 9）组成，每层包含 `LVL_SIZE`（64）个桶（buckets）。\n  - 每层具有不同的时间粒度（granularity），随层级升高而增大。\n- **定时器基础（Timer Bases）**：\n  - `BASE_STD`：标准定时器基础，用于普通定时器。\n  - `BASE_DEF`：可延迟定时器基础（仅当 `CONFIG_NO_HZ_COMMON` 启用时存在），用于在 CPU 空闲时可推迟执行的定时器。\n\n### 关键宏定义\n- `LVL_CLK_SHIFT` / `LVL_CLK_DIV`：定义层级间的时间粒度缩放因子（默认为 8 倍）。\n- `LVL_GRAN(n)`：第 `n` 层的时间粒度（单位：jiffies）。\n- `LVL_START(n)`：第 `n` 层的起始偏移时间，用于计算定时器应插入的层级。\n- `WHEEL_TIMEOUT_CUTOFF` / `WHEEL_TIMEOUT_MAX`：定时器轮的最大支持超时时间（约 12 天 @ HZ=1000）。\n\n### 主要功能\n- 定时器的注册（`add_timer`）、删除（`del_timer`）和修改（`mod_timer`）。\n- 定时器到期处理（软中断上下文执行）。\n- 与 tick 管理子系统（`tick.h`）和 NO_HZ 模式协同工作。\n- 提供 `sys_sysinfo` 系统调用的底层支持。\n\n## 3. 关键实现\n\n### 多级定时器轮算法\n- **层级设计**：定时器根据其到期时间的远近被分配到不同层级。近到期定时器放入低层（高精度），远到期放入高层（低精度）。\n- **无级联机制**：与经典定时器轮不同，本实现**不进行定时器的级联迁移**。高层定时器到期时直接触发，牺牲少量精度换取显著性能提升。\n- **隐式批处理**：高层的粗粒度天然实现超时事件的批处理，减少中断和软中断开销。\n- **超时截断**：超过 `WHEEL_TIMEOUT_MAX` 的定时器会被强制设为最大支持超时值，实测表明实际使用中超时极少超过 5 天。\n\n### 粒度与范围（以 HZ=1000 为例）\n| 层级 | 偏移 | 粒度 | 范围 |\n|------|------|------|------|\n| 0 | 0 | 1 ms | 0 – 63 ms |\n| 1 | 64 | 8 ms | 64 – 511 ms |\n| ... | ... | ... | ... |\n| 8 | 512 | ~4 小时 | ~1 天 – ~12 天 |\n\n### NO_HZ 支持\n- 当启用 `CONFIG_NO_HZ_COMMON` 时，系统维护**两个独立的定时器轮**：\n  - `BASE_STD`：标准定时器，必须准时触发。\n  - `BASE_DEF`：可延迟定时器，在 CPU 进入空闲状态时可推迟执行，用于节能。\n\n### SMP 优化\n- 定时器默认绑定到注册时的 CPU，利用 per-CPU 数据结构减少锁竞争。\n- `jiffies_64` 使用 `__cacheline_aligned_in_smp` 对齐，避免 false sharing。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **时间子系统**：`<linux/time.h>`, `<linux/jiffies.h>`, `<asm/timex.h>`\n- **调度与中断**：`<linux/interrupt.h>`, `<linux/irq_work.h>`, `<linux/sched/*.h>`\n- **内存管理**：`<linux/slab.h>`, `<linux/mm.h>`\n- **系统调用**：`<linux/syscalls.h>`, `<linux/uaccess.h>`\n- **内部模块**：`\"tick-internal.h\"`（tick 管理）、`<trace/events/timer.h>`（跟踪点）\n\n### 内核子系统交互\n- **Tick 管理**：通过 `tick.h` 接口获取时钟事件，驱动定时器轮推进。\n- **软中断**：定时器到期回调在 `TIMER_SOFTIRQ` 软中断上下文中执行。\n- **POSIX 定时器**：为 `<linux/posix-timers.h>` 提供底层支持。\n- **CPU 热插拔**：通过 `cpu.h` 处理 CPU 上下线时的定时器迁移。\n- **电源管理**：与 `NO_HZ` 和 `sched/nohz.h` 协同实现动态 tick。\n\n## 5. 使用场景\n\n- **内核超时机制**：网络协议栈（TCP 重传、连接超时）、块设备 I/O 超时、文件系统缓存回收等。\n- **延迟执行任务**：通过 `mod_timer` 实现延迟工作队列（如 `delayed_work`）。\n- **系统时间维护**：为 `jiffies` 和 `get_jiffies_64()` 提供原子更新。\n- **用户空间接口**：支撑 `sysinfo` 系统调用返回 uptime、负载等信息。\n- **高精度定时需求**：短超时（<64ms @ HZ=1000）可获得毫秒级精度，满足实时性要求。\n- **低功耗系统**：在 `NO_HZ_IDLE` 或 `NO_HZ_FULL` 模式下，通过 `BASE_DEF` 减少不必要的 tick 中断。",
      "similarity": 0.5801571607589722,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/time/timer.c",
          "start_line": 460,
          "end_line": 560,
          "content": [
            "unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)",
            "{",
            "\tunsigned long j0 = jiffies;",
            "",
            "\t/* Use j0 because jiffies might change while we run */",
            "\treturn round_jiffies_common(j + j0, cpu, true) - j0;",
            "}",
            "unsigned long round_jiffies_up(unsigned long j)",
            "{",
            "\treturn round_jiffies_common(j, raw_smp_processor_id(), true);",
            "}",
            "unsigned long round_jiffies_up_relative(unsigned long j)",
            "{",
            "\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());",
            "}",
            "static inline unsigned int timer_get_idx(struct timer_list *timer)",
            "{",
            "\treturn (timer->flags & TIMER_ARRAYMASK) >> TIMER_ARRAYSHIFT;",
            "}",
            "static inline void timer_set_idx(struct timer_list *timer, unsigned int idx)",
            "{",
            "\ttimer->flags = (timer->flags & ~TIMER_ARRAYMASK) |",
            "\t\t\tidx << TIMER_ARRAYSHIFT;",
            "}",
            "static inline unsigned calc_index(unsigned long expires, unsigned lvl,",
            "\t\t\t\t  unsigned long *bucket_expiry)",
            "{",
            "",
            "\t/*",
            "\t * The timer wheel has to guarantee that a timer does not fire",
            "\t * early. Early expiry can happen due to:",
            "\t * - Timer is armed at the edge of a tick",
            "\t * - Truncation of the expiry time in the outer wheel levels",
            "\t *",
            "\t * Round up with level granularity to prevent this.",
            "\t */",
            "\texpires = (expires >> LVL_SHIFT(lvl)) + 1;",
            "\t*bucket_expiry = expires << LVL_SHIFT(lvl);",
            "\treturn LVL_OFFS(lvl) + (expires & LVL_MASK);",
            "}",
            "static int calc_wheel_index(unsigned long expires, unsigned long clk,",
            "\t\t\t    unsigned long *bucket_expiry)",
            "{",
            "\tunsigned long delta = expires - clk;",
            "\tunsigned int idx;",
            "",
            "\tif (delta < LVL_START(1)) {",
            "\t\tidx = calc_index(expires, 0, bucket_expiry);",
            "\t} else if (delta < LVL_START(2)) {",
            "\t\tidx = calc_index(expires, 1, bucket_expiry);",
            "\t} else if (delta < LVL_START(3)) {",
            "\t\tidx = calc_index(expires, 2, bucket_expiry);",
            "\t} else if (delta < LVL_START(4)) {",
            "\t\tidx = calc_index(expires, 3, bucket_expiry);",
            "\t} else if (delta < LVL_START(5)) {",
            "\t\tidx = calc_index(expires, 4, bucket_expiry);",
            "\t} else if (delta < LVL_START(6)) {",
            "\t\tidx = calc_index(expires, 5, bucket_expiry);",
            "\t} else if (delta < LVL_START(7)) {",
            "\t\tidx = calc_index(expires, 6, bucket_expiry);",
            "\t} else if (LVL_DEPTH > 8 && delta < LVL_START(8)) {",
            "\t\tidx = calc_index(expires, 7, bucket_expiry);",
            "\t} else if ((long) delta < 0) {",
            "\t\tidx = clk & LVL_MASK;",
            "\t\t*bucket_expiry = clk;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Force expire obscene large timeouts to expire at the",
            "\t\t * capacity limit of the wheel.",
            "\t\t */",
            "\t\tif (delta >= WHEEL_TIMEOUT_CUTOFF)",
            "\t\t\texpires = clk + WHEEL_TIMEOUT_MAX;",
            "",
            "\t\tidx = calc_index(expires, LVL_DEPTH - 1, bucket_expiry);",
            "\t}",
            "\treturn idx;",
            "}",
            "static void",
            "trigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)",
            "{",
            "\tif (!is_timers_nohz_active())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * TODO: This wants some optimizing similar to the code below, but we",
            "\t * will do that when we switch from push to pull for deferrable timers.",
            "\t */",
            "\tif (timer->flags & TIMER_DEFERRABLE) {",
            "\t\tif (tick_nohz_full_cpu(base->cpu))",
            "\t\t\twake_up_nohz_cpu(base->cpu);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * We might have to IPI the remote CPU if the base is idle and the",
            "\t * timer is not deferrable. If the other CPU is on the way to idle",
            "\t * then it can't set base->is_idle as we hold the base lock:",
            "\t */",
            "\tif (base->is_idle)",
            "\t\twake_up_nohz_cpu(base->cpu);",
            "}"
          ],
          "function_name": "__round_jiffies_up_relative, round_jiffies_up, round_jiffies_up_relative, timer_get_idx, timer_set_idx, calc_index, calc_wheel_index, trigger_dyntick_cpu",
          "description": "实现定时器层级索引计算逻辑和动态tick触发机制，通过层级间转换规则确定定时器存储位置，处理非活动CPU上的定时器唤醒需求。",
          "similarity": 0.5539743900299072
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/time/timer.c",
          "start_line": 2030,
          "end_line": 2130,
          "content": [
            "static __latent_entropy void run_timer_softirq(struct softirq_action *h)",
            "{",
            "\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);",
            "",
            "\t__run_timers(base);",
            "\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON))",
            "\t\t__run_timers(this_cpu_ptr(&timer_bases[BASE_DEF]));",
            "}",
            "static void run_local_timers(void)",
            "{",
            "\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);",
            "",
            "\thrtimer_run_queues();",
            "\t/* Raise the softirq only if required. */",
            "\tif (time_before(jiffies, base->next_expiry)) {",
            "\t\tif (!IS_ENABLED(CONFIG_NO_HZ_COMMON))",
            "\t\t\treturn;",
            "\t\t/* CPU is awake, so check the deferrable base. */",
            "\t\tbase++;",
            "\t\tif (time_before(jiffies, base->next_expiry))",
            "\t\t\treturn;",
            "\t}",
            "\traise_timer_softirq(TIMER_SOFTIRQ);",
            "}",
            "void update_process_times(int user_tick)",
            "{",
            "\tstruct task_struct *p = current;",
            "",
            "\t/* Note: this timer irq context must be accounted for as well. */",
            "\taccount_process_tick(p, user_tick);",
            "\trun_local_timers();",
            "\trcu_sched_clock_irq(user_tick);",
            "#ifdef CONFIG_IRQ_WORK",
            "\tif (in_irq())",
            "\t\tirq_work_tick();",
            "#endif",
            "\tsched_tick();",
            "\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))",
            "\t\trun_posix_cpu_timers();",
            "}",
            "static void process_timeout(struct timer_list *t)",
            "{",
            "\tstruct process_timer *timeout = from_timer(timeout, t, timer);",
            "",
            "\twake_up_process(timeout->task);",
            "}",
            "signed long __sched schedule_timeout(signed long timeout)",
            "{",
            "\tstruct process_timer timer;",
            "\tunsigned long expire;",
            "",
            "\tswitch (timeout)",
            "\t{",
            "\tcase MAX_SCHEDULE_TIMEOUT:",
            "\t\t/*",
            "\t\t * These two special cases are useful to be comfortable",
            "\t\t * in the caller. Nothing more. We could take",
            "\t\t * MAX_SCHEDULE_TIMEOUT from one of the negative value",
            "\t\t * but I' d like to return a valid offset (>=0) to allow",
            "\t\t * the caller to do everything it want with the retval.",
            "\t\t */",
            "\t\tschedule();",
            "\t\tgoto out;",
            "\tdefault:",
            "\t\t/*",
            "\t\t * Another bit of PARANOID. Note that the retval will be",
            "\t\t * 0 since no piece of kernel is supposed to do a check",
            "\t\t * for a negative retval of schedule_timeout() (since it",
            "\t\t * should never happens anyway). You just have the printk()",
            "\t\t * that will tell you if something is gone wrong and where.",
            "\t\t */",
            "\t\tif (timeout < 0) {",
            "\t\t\tprintk(KERN_ERR \"schedule_timeout: wrong timeout \"",
            "\t\t\t\t\"value %lx\\n\", timeout);",
            "\t\t\tdump_stack();",
            "\t\t\t__set_current_state(TASK_RUNNING);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\texpire = timeout + jiffies;",
            "",
            "\ttimer.task = current;",
            "\ttimer_setup_on_stack(&timer.timer, process_timeout, 0);",
            "\t__mod_timer(&timer.timer, expire, MOD_TIMER_NOTPENDING);",
            "\tschedule();",
            "\tdel_timer_sync(&timer.timer);",
            "",
            "\t/* Remove the timer from the object tracker */",
            "\tdestroy_timer_on_stack(&timer.timer);",
            "",
            "\ttimeout = expire - jiffies;",
            "",
            " out:",
            "\treturn timeout < 0 ? 0 : timeout;",
            "}",
            "signed long __sched schedule_timeout_interruptible(signed long timeout)",
            "{",
            "\t__set_current_state(TASK_INTERRUPTIBLE);",
            "\treturn schedule_timeout(timeout);",
            "}"
          ],
          "function_name": "run_timer_softirq, run_local_timers, update_process_times, process_timeout, schedule_timeout, schedule_timeout_interruptible",
          "description": "该代码段核心功能是处理定时器相关操作，涵盖软中断处理、本地定时器管理、进程时间更新及休眠超时控制。  \n`run_timer_softirq`和`run_local_timers`分别用于处理软中断中的定时器队列和本地定时器检查，`update_process_times`更新进程时间并触发本地定时器，`schedule_timeout`系列通过定时器实现进程休眠与超时唤醒。  \n上下文不完整：部分关键函数（如`__run_timers`、`hrtimer_run_queues`）的实现未展示，依赖外部知识理解其行为。",
          "similarity": 0.5342296361923218
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/timer.c",
          "start_line": 1,
          "end_line": 230,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  Kernel internal timers",
            " *",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " *",
            " *  1997-01-28  Modified by Finn Arne Gangstad to make timers scale better.",
            " *",
            " *  1997-09-10  Updated NTP code according to technical memorandum Jan '96",
            " *              \"A Kernel Model for Precision Timekeeping\" by Dave Mills",
            " *  1998-12-24  Fixed a xtime SMP race (we need the xtime_lock rw spinlock to",
            " *              serialize accesses to xtime/lost_ticks).",
            " *                              Copyright (C) 1998  Andrea Arcangeli",
            " *  1999-03-10  Improved NTP compatibility by Ulrich Windl",
            " *  2002-05-31\tMove sys_sysinfo here and make its locking sane, Robert Love",
            " *  2000-10-05  Implemented scalable SMP per-CPU timer handling.",
            " *                              Copyright (C) 2000, 2001, 2002  Ingo Molnar",
            " *              Designed by David S. Miller, Alexey Kuznetsov and Ingo Molnar",
            " */",
            "",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/notifier.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/delay.h>",
            "#include <linux/tick.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "",
            "#include <linux/uaccess.h>",
            "#include <asm/unistd.h>",
            "#include <asm/div64.h>",
            "#include <asm/timex.h>",
            "#include <asm/io.h>",
            "",
            "#include \"tick-internal.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/timer.h>",
            "",
            "__visible u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;",
            "",
            "EXPORT_SYMBOL(jiffies_64);",
            "",
            "/*",
            " * The timer wheel has LVL_DEPTH array levels. Each level provides an array of",
            " * LVL_SIZE buckets. Each level is driven by its own clock and therefor each",
            " * level has a different granularity.",
            " *",
            " * The level granularity is:\t\tLVL_CLK_DIV ^ lvl",
            " * The level clock frequency is:\tHZ / (LVL_CLK_DIV ^ level)",
            " *",
            " * The array level of a newly armed timer depends on the relative expiry",
            " * time. The farther the expiry time is away the higher the array level and",
            " * therefor the granularity becomes.",
            " *",
            " * Contrary to the original timer wheel implementation, which aims for 'exact'",
            " * expiry of the timers, this implementation removes the need for recascading",
            " * the timers into the lower array levels. The previous 'classic' timer wheel",
            " * implementation of the kernel already violated the 'exact' expiry by adding",
            " * slack to the expiry time to provide batched expiration. The granularity",
            " * levels provide implicit batching.",
            " *",
            " * This is an optimization of the original timer wheel implementation for the",
            " * majority of the timer wheel use cases: timeouts. The vast majority of",
            " * timeout timers (networking, disk I/O ...) are canceled before expiry. If",
            " * the timeout expires it indicates that normal operation is disturbed, so it",
            " * does not matter much whether the timeout comes with a slight delay.",
            " *",
            " * The only exception to this are networking timers with a small expiry",
            " * time. They rely on the granularity. Those fit into the first wheel level,",
            " * which has HZ granularity.",
            " *",
            " * We don't have cascading anymore. timers with a expiry time above the",
            " * capacity of the last wheel level are force expired at the maximum timeout",
            " * value of the last wheel level. From data sampling we know that the maximum",
            " * value observed is 5 days (network connection tracking), so this should not",
            " * be an issue.",
            " *",
            " * The currently chosen array constants values are a good compromise between",
            " * array size and granularity.",
            " *",
            " * This results in the following granularity and range levels:",
            " *",
            " * HZ 1000 steps",
            " * Level Offset  Granularity            Range",
            " *  0      0         1 ms                0 ms -         63 ms",
            " *  1     64         8 ms               64 ms -        511 ms",
            " *  2    128        64 ms              512 ms -       4095 ms (512ms - ~4s)",
            " *  3    192       512 ms             4096 ms -      32767 ms (~4s - ~32s)",
            " *  4    256      4096 ms (~4s)      32768 ms -     262143 ms (~32s - ~4m)",
            " *  5    320     32768 ms (~32s)    262144 ms -    2097151 ms (~4m - ~34m)",
            " *  6    384    262144 ms (~4m)    2097152 ms -   16777215 ms (~34m - ~4h)",
            " *  7    448   2097152 ms (~34m)  16777216 ms -  134217727 ms (~4h - ~1d)",
            " *  8    512  16777216 ms (~4h)  134217728 ms - 1073741822 ms (~1d - ~12d)",
            " *",
            " * HZ  300",
            " * Level Offset  Granularity            Range",
            " *  0\t   0         3 ms                0 ms -        210 ms",
            " *  1\t  64        26 ms              213 ms -       1703 ms (213ms - ~1s)",
            " *  2\t 128       213 ms             1706 ms -      13650 ms (~1s - ~13s)",
            " *  3\t 192      1706 ms (~1s)      13653 ms -     109223 ms (~13s - ~1m)",
            " *  4\t 256     13653 ms (~13s)    109226 ms -     873810 ms (~1m - ~14m)",
            " *  5\t 320    109226 ms (~1m)     873813 ms -    6990503 ms (~14m - ~1h)",
            " *  6\t 384    873813 ms (~14m)   6990506 ms -   55924050 ms (~1h - ~15h)",
            " *  7\t 448   6990506 ms (~1h)   55924053 ms -  447392423 ms (~15h - ~5d)",
            " *  8    512  55924053 ms (~15h) 447392426 ms - 3579139406 ms (~5d - ~41d)",
            " *",
            " * HZ  250",
            " * Level Offset  Granularity            Range",
            " *  0\t   0         4 ms                0 ms -        255 ms",
            " *  1\t  64        32 ms              256 ms -       2047 ms (256ms - ~2s)",
            " *  2\t 128       256 ms             2048 ms -      16383 ms (~2s - ~16s)",
            " *  3\t 192      2048 ms (~2s)      16384 ms -     131071 ms (~16s - ~2m)",
            " *  4\t 256     16384 ms (~16s)    131072 ms -    1048575 ms (~2m - ~17m)",
            " *  5\t 320    131072 ms (~2m)    1048576 ms -    8388607 ms (~17m - ~2h)",
            " *  6\t 384   1048576 ms (~17m)   8388608 ms -   67108863 ms (~2h - ~18h)",
            " *  7\t 448   8388608 ms (~2h)   67108864 ms -  536870911 ms (~18h - ~6d)",
            " *  8    512  67108864 ms (~18h) 536870912 ms - 4294967288 ms (~6d - ~49d)",
            " *",
            " * HZ  100",
            " * Level Offset  Granularity            Range",
            " *  0\t   0         10 ms               0 ms -        630 ms",
            " *  1\t  64         80 ms             640 ms -       5110 ms (640ms - ~5s)",
            " *  2\t 128        640 ms            5120 ms -      40950 ms (~5s - ~40s)",
            " *  3\t 192       5120 ms (~5s)     40960 ms -     327670 ms (~40s - ~5m)",
            " *  4\t 256      40960 ms (~40s)   327680 ms -    2621430 ms (~5m - ~43m)",
            " *  5\t 320     327680 ms (~5m)   2621440 ms -   20971510 ms (~43m - ~5h)",
            " *  6\t 384    2621440 ms (~43m) 20971520 ms -  167772150 ms (~5h - ~1d)",
            " *  7\t 448   20971520 ms (~5h) 167772160 ms - 1342177270 ms (~1d - ~15d)",
            " */",
            "",
            "/* Clock divisor for the next level */",
            "#define LVL_CLK_SHIFT\t3",
            "#define LVL_CLK_DIV\t(1UL << LVL_CLK_SHIFT)",
            "#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)",
            "#define LVL_SHIFT(n)\t((n) * LVL_CLK_SHIFT)",
            "#define LVL_GRAN(n)\t(1UL << LVL_SHIFT(n))",
            "",
            "/*",
            " * The time start value for each level to select the bucket at enqueue",
            " * time. We start from the last possible delta of the previous level",
            " * so that we can later add an extra LVL_GRAN(n) to n (see calc_index()).",
            " */",
            "#define LVL_START(n)\t((LVL_SIZE - 1) << (((n) - 1) * LVL_CLK_SHIFT))",
            "",
            "/* Size of each clock level */",
            "#define LVL_BITS\t6",
            "#define LVL_SIZE\t(1UL << LVL_BITS)",
            "#define LVL_MASK\t(LVL_SIZE - 1)",
            "#define LVL_OFFS(n)\t((n) * LVL_SIZE)",
            "",
            "/* Level depth */",
            "#if HZ > 100",
            "# define LVL_DEPTH\t9",
            "# else",
            "# define LVL_DEPTH\t8",
            "#endif",
            "",
            "/* The cutoff (max. capacity of the wheel) */",
            "#define WHEEL_TIMEOUT_CUTOFF\t(LVL_START(LVL_DEPTH))",
            "#define WHEEL_TIMEOUT_MAX\t(WHEEL_TIMEOUT_CUTOFF - LVL_GRAN(LVL_DEPTH - 1))",
            "",
            "/*",
            " * The resulting wheel size. If NOHZ is configured we allocate two",
            " * wheels so we have a separate storage for the deferrable timers.",
            " */",
            "#define WHEEL_SIZE\t(LVL_SIZE * LVL_DEPTH)",
            "",
            "#ifdef CONFIG_NO_HZ_COMMON",
            "# define NR_BASES\t2",
            "# define BASE_STD\t0",
            "# define BASE_DEF\t1",
            "#else",
            "# define NR_BASES\t1",
            "# define BASE_STD\t0",
            "# define BASE_DEF\t0",
            "#endif",
            "",
            "struct timer_base {",
            "\traw_spinlock_t\t\tlock;",
            "\tstruct timer_list\t*running_timer;",
            "#ifdef CONFIG_PREEMPT_RT",
            "\tspinlock_t\t\texpiry_lock;",
            "\tatomic_t\t\ttimer_waiters;",
            "#endif",
            "\tunsigned long\t\tclk;",
            "\tunsigned long\t\tnext_expiry;",
            "\tunsigned int\t\tcpu;",
            "\tbool\t\t\tnext_expiry_recalc;",
            "\tbool\t\t\tis_idle;",
            "\tbool\t\t\ttimers_pending;",
            "\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);",
            "\tstruct hlist_head\tvectors[WHEEL_SIZE];",
            "} ____cacheline_aligned;",
            "",
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);",
            "",
            "#ifdef CONFIG_NO_HZ_COMMON",
            "",
            "static DEFINE_STATIC_KEY_FALSE(timers_nohz_active);",
            "static DEFINE_MUTEX(timer_keys_mutex);",
            "",
            "static void timer_update_keys(struct work_struct *work);",
            "static DECLARE_WORK(timer_update_work, timer_update_keys);",
            "",
            "#ifdef CONFIG_SMP",
            "static unsigned int sysctl_timer_migration = 1;",
            "",
            "DEFINE_STATIC_KEY_FALSE(timers_migration_enabled);",
            ""
          ],
          "function_name": null,
          "description": "定义并实现了内核定时器轮（timer wheel）的数据结构和宏观布局，通过多层级桶结构管理定时器，支持不同粒度的超时处理，包含对NOHZ模式的支持及动态调整机制。",
          "similarity": 0.5302894711494446
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/timer.c",
          "start_line": 231,
          "end_line": 333,
          "content": [
            "static void timers_update_migration(void)",
            "{",
            "\tif (sysctl_timer_migration && tick_nohz_active)",
            "\t\tstatic_branch_enable(&timers_migration_enabled);",
            "\telse",
            "\t\tstatic_branch_disable(&timers_migration_enabled);",
            "}",
            "static int timer_migration_handler(struct ctl_table *table, int write,",
            "\t\t\t    void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret;",
            "",
            "\tmutex_lock(&timer_keys_mutex);",
            "\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (!ret && write)",
            "\t\ttimers_update_migration();",
            "\tmutex_unlock(&timer_keys_mutex);",
            "\treturn ret;",
            "}",
            "static int __init timer_sysctl_init(void)",
            "{",
            "\tregister_sysctl(\"kernel\", timer_sysctl);",
            "\treturn 0;",
            "}",
            "static inline void timers_update_migration(void) { }",
            "static void timer_update_keys(struct work_struct *work)",
            "{",
            "\tmutex_lock(&timer_keys_mutex);",
            "\ttimers_update_migration();",
            "\tstatic_branch_enable(&timers_nohz_active);",
            "\tmutex_unlock(&timer_keys_mutex);",
            "}",
            "void timers_update_nohz(void)",
            "{",
            "\tschedule_work(&timer_update_work);",
            "}",
            "static inline bool is_timers_nohz_active(void)",
            "{",
            "\treturn static_branch_unlikely(&timers_nohz_active);",
            "}",
            "static inline bool is_timers_nohz_active(void) { return false; }",
            "static unsigned long round_jiffies_common(unsigned long j, int cpu,",
            "\t\tbool force_up)",
            "{",
            "\tint rem;",
            "\tunsigned long original = j;",
            "",
            "\t/*",
            "\t * We don't want all cpus firing their timers at once hitting the",
            "\t * same lock or cachelines, so we skew each extra cpu with an extra",
            "\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which",
            "\t * already did this.",
            "\t * The skew is done by adding 3*cpunr, then round, then subtract this",
            "\t * extra offset again.",
            "\t */",
            "\tj += cpu * 3;",
            "",
            "\trem = j % HZ;",
            "",
            "\t/*",
            "\t * If the target jiffie is just after a whole second (which can happen",
            "\t * due to delays of the timer irq, long irq off times etc etc) then",
            "\t * we should round down to the whole second, not up. Use 1/4th second",
            "\t * as cutoff for this rounding as an extreme upper bound for this.",
            "\t * But never round down if @force_up is set.",
            "\t */",
            "\tif (rem < HZ/4 && !force_up) /* round down */",
            "\t\tj = j - rem;",
            "\telse /* round up */",
            "\t\tj = j - rem + HZ;",
            "",
            "\t/* now that we have rounded, subtract the extra skew again */",
            "\tj -= cpu * 3;",
            "",
            "\t/*",
            "\t * Make sure j is still in the future. Otherwise return the",
            "\t * unmodified value.",
            "\t */",
            "\treturn time_is_after_jiffies(j) ? j : original;",
            "}",
            "unsigned long __round_jiffies(unsigned long j, int cpu)",
            "{",
            "\treturn round_jiffies_common(j, cpu, false);",
            "}",
            "unsigned long __round_jiffies_relative(unsigned long j, int cpu)",
            "{",
            "\tunsigned long j0 = jiffies;",
            "",
            "\t/* Use j0 because jiffies might change while we run */",
            "\treturn round_jiffies_common(j + j0, cpu, false) - j0;",
            "}",
            "unsigned long round_jiffies(unsigned long j)",
            "{",
            "\treturn round_jiffies_common(j, raw_smp_processor_id(), false);",
            "}",
            "unsigned long round_jiffies_relative(unsigned long j)",
            "{",
            "\treturn __round_jiffies_relative(j, raw_smp_processor_id());",
            "}",
            "unsigned long __round_jiffies_up(unsigned long j, int cpu)",
            "{",
            "\treturn round_jiffies_common(j, cpu, true);",
            "}"
          ],
          "function_name": "timers_update_migration, timer_migration_handler, timer_sysctl_init, timers_update_migration, timer_update_keys, timers_update_nohz, is_timers_nohz_active, is_timers_nohz_active, round_jiffies_common, __round_jiffies, __round_jiffies_relative, round_jiffies, round_jiffies_relative, __round_jiffies_up",
          "description": "提供定时器迁移策略控制、Jiffies值调整逻辑及NOHZ相关功能，包含迁移开关配置、定时器分布优化算法和基于CPU负载的超时时间调整方法。",
          "similarity": 0.5257164835929871
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/time/timer.c",
          "start_line": 1883,
          "end_line": 2004,
          "content": [
            "static u64 cmp_next_hrtimer_event(u64 basem, u64 expires)",
            "{",
            "\tu64 nextevt = hrtimer_get_next_event();",
            "",
            "\t/*",
            "\t * If high resolution timers are enabled",
            "\t * hrtimer_get_next_event() returns KTIME_MAX.",
            "\t */",
            "\tif (expires <= nextevt)",
            "\t\treturn expires;",
            "",
            "\t/*",
            "\t * If the next timer is already expired, return the tick base",
            "\t * time so the tick is fired immediately.",
            "\t */",
            "\tif (nextevt <= basem)",
            "\t\treturn basem;",
            "",
            "\t/*",
            "\t * Round up to the next jiffie. High resolution timers are",
            "\t * off, so the hrtimers are expired in the tick and we need to",
            "\t * make sure that this tick really expires the timer to avoid",
            "\t * a ping pong of the nohz stop code.",
            "\t *",
            "\t * Use DIV_ROUND_UP_ULL to prevent gcc calling __divdi3",
            "\t */",
            "\treturn DIV_ROUND_UP_ULL(nextevt, TICK_NSEC) * TICK_NSEC;",
            "}",
            "u64 get_next_timer_interrupt(unsigned long basej, u64 basem)",
            "{",
            "\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);",
            "\tu64 expires = KTIME_MAX;",
            "\tunsigned long nextevt;",
            "",
            "\t/*",
            "\t * Pretend that there is no timer pending if the cpu is offline.",
            "\t * Possible pending timers will be migrated later to an active cpu.",
            "\t */",
            "\tif (cpu_is_offline(smp_processor_id()))",
            "\t\treturn expires;",
            "",
            "\traw_spin_lock(&base->lock);",
            "\tif (base->next_expiry_recalc)",
            "\t\tbase->next_expiry = __next_timer_interrupt(base);",
            "\tnextevt = base->next_expiry;",
            "",
            "\t/*",
            "\t * We have a fresh next event. Check whether we can forward the",
            "\t * base. We can only do that when @basej is past base->clk",
            "\t * otherwise we might rewind base->clk.",
            "\t */",
            "\tif (time_after(basej, base->clk)) {",
            "\t\tif (time_after(nextevt, basej))",
            "\t\t\tbase->clk = basej;",
            "\t\telse if (time_after(nextevt, base->clk))",
            "\t\t\tbase->clk = nextevt;",
            "\t}",
            "",
            "\tif (time_before_eq(nextevt, basej)) {",
            "\t\texpires = basem;",
            "\t\tbase->is_idle = false;",
            "\t} else {",
            "\t\tif (base->timers_pending)",
            "\t\t\texpires = basem + (u64)(nextevt - basej) * TICK_NSEC;",
            "\t\t/*",
            "\t\t * If we expect to sleep more than a tick, mark the base idle.",
            "\t\t * Also the tick is stopped so any added timer must forward",
            "\t\t * the base clk itself to keep granularity small. This idle",
            "\t\t * logic is only maintained for the BASE_STD base, deferrable",
            "\t\t * timers may still see large granularity skew (by design).",
            "\t\t */",
            "\t\tif ((expires - basem) > TICK_NSEC)",
            "\t\t\tbase->is_idle = true;",
            "\t}",
            "\traw_spin_unlock(&base->lock);",
            "",
            "\treturn cmp_next_hrtimer_event(basem, expires);",
            "}",
            "void timer_clear_idle(void)",
            "{",
            "\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);",
            "",
            "\t/*",
            "\t * We do this unlocked. The worst outcome is a remote enqueue sending",
            "\t * a pointless IPI, but taking the lock would just make the window for",
            "\t * sending the IPI a few instructions smaller for the cost of taking",
            "\t * the lock in the exit from idle path.",
            "\t */",
            "\tbase->is_idle = false;",
            "}",
            "static inline void __run_timers(struct timer_base *base)",
            "{",
            "\tstruct hlist_head heads[LVL_DEPTH];",
            "\tint levels;",
            "",
            "\tif (time_before(jiffies, base->next_expiry))",
            "\t\treturn;",
            "",
            "\ttimer_base_lock_expiry(base);",
            "\traw_spin_lock_irq(&base->lock);",
            "",
            "\twhile (time_after_eq(jiffies, base->clk) &&",
            "\t       time_after_eq(jiffies, base->next_expiry)) {",
            "\t\tlevels = collect_expired_timers(base, heads);",
            "\t\t/*",
            "\t\t * The two possible reasons for not finding any expired",
            "\t\t * timer at this clk are that all matching timers have been",
            "\t\t * dequeued or no timer has been queued since",
            "\t\t * base::next_expiry was set to base::clk +",
            "\t\t * NEXT_TIMER_MAX_DELTA.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(!levels && !base->next_expiry_recalc",
            "\t\t\t     && base->timers_pending);",
            "\t\tbase->clk++;",
            "\t\tbase->next_expiry = __next_timer_interrupt(base);",
            "",
            "\t\twhile (levels--)",
            "\t\t\texpire_timers(base, heads + levels);",
            "\t}",
            "\traw_spin_unlock_irq(&base->lock);",
            "\ttimer_base_unlock_expiry(base);",
            "}"
          ],
          "function_name": "cmp_next_hrtimer_event, get_next_timer_interrupt, timer_clear_idle, __run_timers",
          "description": "实现高精度定时器协调逻辑，cmp_next_hrtimer_event比较下一个高精度定时器事件；get_next_timer_interrupt计算下一中断时间；timer_clear_idle清除空闲标记；__run_timers驱动定时器执行流程，处理多级桶中到期定时器。",
          "similarity": 0.5225816965103149
        }
      ]
    }
  ]
}