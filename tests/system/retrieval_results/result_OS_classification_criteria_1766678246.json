{
  "query": "OS classification criteria",
  "timestamp": "2025-12-25 23:57:26",
  "retrieved_files": [
    {
      "source_file": "mm/oom_kill.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:58:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `oom_kill.c`\n\n---\n\n# oom_kill.c 技术文档\n\n## 1. 文件概述\n\n`oom_kill.c` 是 Linux 内核内存管理子系统中的关键组件，负责在系统严重内存不足（Out-Of-Memory, OOM）时选择并终止一个或多个进程，以释放内存资源、防止系统崩溃。该文件实现了 OOM Killer 的核心逻辑，包括候选进程的选择策略、内存压力评估、以及与内存控制组（memcg）、NUMA 策略、cpuset 等子系统的集成。OOM Killer 通常由 `__alloc_pages()` 在无法满足内存分配请求时触发。\n\n## 2. 核心功能\n\n### 主要函数\n- **`out_of_memory()`**：OOM Killer 的主入口函数（虽未在片段中完整显示，但为本文件核心）\n- **`oom_badness()`**：计算进程“坏度”（badness）分数的核心启发式函数，用于决定哪个进程最应被杀死\n- **`find_lock_task_mm()`**：在进程及其线程组中查找具有有效内存描述符（`mm_struct`）的可杀任务，并加锁\n- **`oom_unkillable_task()`**：判断某任务是否不可被 OOM Killer 杀死（如 init 进程、内核线程）\n- **`constrained_alloc()`**：确定当前内存分配所受的约束类型（如 memcg、cpuset、mempolicy）\n- **`oom_cpuset_eligible()`**（仅 CONFIG_NUMA）：在 NUMA 系统中检查任务是否符合 cpuset 或 mempolicy 的 OOM 杀死条件\n- **`should_dump_unreclaim_slab()`**：判断是否因不可回收 slab 内存过多而触发 OOM，用于辅助诊断\n\n### 关键数据结构\n- **`struct oom_control`**：封装 OOM 事件上下文，包括分配标志（`gfp_mask`）、节点掩码（`nodemask`）、内存控制组（`memcg`）、分配阶数（`order`）等\n- **`enum oom_constraint`**：表示内存分配受限的类型（`CONSTRAINT_NONE`、`CONSTRAINT_CPUSET`、`CONSTRAINT_MEMORY_POLICY`、`CONSTRAINT_MEMCG`）\n\n### 全局变量\n- **`sysctl_panic_on_oom`**：控制 OOM 时是否直接 panic\n- **`sysctl_oom_kill_allocating_task`**：若置位，则优先杀死触发 OOM 的进程\n- **`sysctl_oom_dump_tasks`**：控制 OOM 时是否打印所有任务的内存使用信息\n- **`oom_lock`**：互斥锁，序列化 OOM Killer 调用，防止并发过度杀进程\n- **`oom_adj_mutex`**：互斥锁，保护 `oom_score_adj` 和 `oom_score_adj_min` 的更新\n\n## 3. 关键实现\n\n### OOM 坏度评分算法 (`oom_badness`)\n- **基础分值**：基于进程的 RSS（Resident Set Size）、交换页数量（`MM_SWAPENTS`）和页表占用内存（`mm_pgtables_bytes`），单位为页数。\n- **调整因子**：通过 `oom_score_adj`（范围 [-1000, 1000]）进行线性调整。调整量 = `oom_score_adj * totalpages / 1000`，其中 `totalpages` 为当前 OOM 上下文允许的最大内存页数（全局或 memcg 限制）。\n- **排除规则**：\n  - 全局 init 进程（PID 1）和内核线程（`PF_KTHREAD`）不可杀。\n  - 显式设置 `oom_score_adj = OOM_SCORE_ADJ_MIN (-1000)` 的进程不可杀。\n  - 已被标记跳过（`MMF_OOM_SKIP`）或处于 `vfork` 中间状态的进程不可杀。\n- **返回值**：`LONG_MIN` 表示不可杀；否则返回综合评分，值越大越优先被杀。\n\n### 内存分配约束识别 (`constrained_alloc`)\n- **Memcg OOM**：若 `oc->memcg` 非空，则 `totalpages` 设为 memcg 的内存上限，约束类型为 `CONSTRAINT_MEMCG`。\n- **全局 OOM**：默认 `totalpages = totalram_pages + total_swap_pages`。\n- **NUMA 约束**：\n  - 若分配请求指定 `__GFP_THISNODE`，视为无特殊约束（避免杀死当前进程）。\n  - 若存在非全集的 `nodemask`（来自 mempolicy），则 `totalpages` 仅统计该 nodemask 覆盖节点的内存，约束类型为 `CONSTRAINT_MEMORY_POLICY`。\n  - Cpuset 约束由页面分配器处理，此处不直接计算。\n\n### 多线程与内存描述符处理 (`find_lock_task_mm`)\n- 遍历目标进程的整个线程组（`for_each_thread`），寻找任一仍持有有效 `mm_struct` 的线程。\n- 对找到的线程加 `task_lock` 并返回，确保在检查其内存状态时不会被释放。\n- 适用于主线程已退出但子线程仍在运行的场景。\n\n### NUMA 可杀性检查 (`oom_cpuset_eligible`)\n- 在 NUMA 系统中，仅当候选任务与触发 OOM 的当前任务在内存策略（mempolicy）或 cpuset 允许的节点集上有交集时，才视为可杀。\n- 若 OOM 由 mempolicy 触发（`oc->nodemask` 非空），则仅检查 mempolicy 交集。\n- 否则，检查 cpuset 的 `mems_allowed` 交集。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/gfp.h>`、`<linux/swap.h>` 获取内存状态、分配标志和交换信息。\n- **进程调度与管理**：依赖 `<linux/sched.h>` 及相关头文件访问任务结构、线程组、cpuset 和内存策略。\n- **内存控制组 (cgroup v2)**：通过 `<linux/memcontrol.h>` 集成 memcg，支持容器级 OOM。\n- **安全模块**：通过 `<linux/security.h>` 调用 LSM 钩子（如 `security_oom_kill()`）。\n- **调试与追踪**：使用 ftrace (`<linux/ftrace.h>`) 和自定义 tracepoint (`trace/events/oom.h`) 记录 OOM 事件。\n- **体系结构相关**：包含 `<asm/tlb.h>` 处理 TLB 刷新。\n- **内部 MM 实现**：包含 `\"internal.h\"` 和 `\"slab.h\"` 访问内核私有内存管理接口。\n\n## 5. 使用场景\n\n- **全局内存耗尽**：当系统整体可用内存（含 swap）低于临界阈值，且无法通过页面回收释放足够内存时，由页面分配器调用 `out_of_memory()`。\n- **Memcg 内存超限**：当某个 memory cgroup 的内存使用超过其配额时，触发该 cgroup 内的 OOM Killer。\n- **SysRq 触发**：通过 Magic SysRq 键（`Alt+SysRq+f`）手动触发 OOM Killer，此时 `oc->order = -1`。\n- **诊断辅助**：当不可回收 slab 内存（如内核对象缓存）异常增长导致 OOM 时，`should_dump_unreclaim_slab()` 可触发 slab 信息转储以辅助调试。\n- **策略约束下的 OOM**：在 NUMA 系统中，受 cpuset 或 mempolicy 限制的进程在局部节点内存耗尽时触发针对性 OOM。",
      "similarity": 0.5071713924407959,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/oom_kill.c",
          "start_line": 73,
          "end_line": 176,
          "content": [
            "static inline bool is_memcg_oom(struct oom_control *oc)",
            "{",
            "\treturn oc->memcg != NULL;",
            "}",
            "static bool oom_cpuset_eligible(struct task_struct *start,",
            "\t\t\t\tstruct oom_control *oc)",
            "{",
            "\tstruct task_struct *tsk;",
            "\tbool ret = false;",
            "\tconst nodemask_t *mask = oc->nodemask;",
            "",
            "\trcu_read_lock();",
            "\tfor_each_thread(start, tsk) {",
            "\t\tif (mask) {",
            "\t\t\t/*",
            "\t\t\t * If this is a mempolicy constrained oom, tsk's",
            "\t\t\t * cpuset is irrelevant.  Only return true if its",
            "\t\t\t * mempolicy intersects current, otherwise it may be",
            "\t\t\t * needlessly killed.",
            "\t\t\t */",
            "\t\t\tret = mempolicy_in_oom_domain(tsk, mask);",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * This is not a mempolicy constrained oom, so only",
            "\t\t\t * check the mems of tsk's cpuset.",
            "\t\t\t */",
            "\t\t\tret = cpuset_mems_allowed_intersects(current, tsk);",
            "\t\t}",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "static bool oom_cpuset_eligible(struct task_struct *tsk, struct oom_control *oc)",
            "{",
            "\treturn true;",
            "}",
            "static inline bool is_sysrq_oom(struct oom_control *oc)",
            "{",
            "\treturn oc->order == -1;",
            "}",
            "static bool oom_unkillable_task(struct task_struct *p)",
            "{",
            "\tif (is_global_init(p))",
            "\t\treturn true;",
            "\tif (p->flags & PF_KTHREAD)",
            "\t\treturn true;",
            "\treturn false;",
            "}",
            "static bool should_dump_unreclaim_slab(void)",
            "{",
            "\tunsigned long nr_lru;",
            "",
            "\tnr_lru = global_node_page_state(NR_ACTIVE_ANON) +",
            "\t\t global_node_page_state(NR_INACTIVE_ANON) +",
            "\t\t global_node_page_state(NR_ACTIVE_FILE) +",
            "\t\t global_node_page_state(NR_INACTIVE_FILE) +",
            "\t\t global_node_page_state(NR_ISOLATED_ANON) +",
            "\t\t global_node_page_state(NR_ISOLATED_FILE) +",
            "\t\t global_node_page_state(NR_UNEVICTABLE);",
            "",
            "\treturn (global_node_page_state_pages(NR_SLAB_UNRECLAIMABLE_B) > nr_lru);",
            "}",
            "long oom_badness(struct task_struct *p, unsigned long totalpages)",
            "{",
            "\tlong points;",
            "\tlong adj;",
            "",
            "\tif (oom_unkillable_task(p))",
            "\t\treturn LONG_MIN;",
            "",
            "\tp = find_lock_task_mm(p);",
            "\tif (!p)",
            "\t\treturn LONG_MIN;",
            "",
            "\t/*",
            "\t * Do not even consider tasks which are explicitly marked oom",
            "\t * unkillable or have been already oom reaped or the are in",
            "\t * the middle of vfork",
            "\t */",
            "\tadj = (long)p->signal->oom_score_adj;",
            "\tif (adj == OOM_SCORE_ADJ_MIN ||",
            "\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||",
            "\t\t\tin_vfork(p)) {",
            "\t\ttask_unlock(p);",
            "\t\treturn LONG_MIN;",
            "\t}",
            "",
            "\t/*",
            "\t * The baseline for the badness score is the proportion of RAM that each",
            "\t * task's rss, pagetable and swap space use.",
            "\t */",
            "\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +",
            "\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;",
            "\ttask_unlock(p);",
            "",
            "\t/* Normalize to oom_score_adj units */",
            "\tadj *= totalpages / 1000;",
            "\tpoints += adj;",
            "",
            "\treturn points;",
            "}"
          ],
          "function_name": "is_memcg_oom, oom_cpuset_eligible, oom_cpuset_eligible, is_sysrq_oom, oom_unkillable_task, should_dump_unreclaim_slab, oom_badness",
          "description": "实现OOM候选进程的过滤逻辑，判断进程是否满足内存组、CPU集、不可杀标记等条件，并计算进程的OOM不良程度评分。",
          "similarity": 0.5483297109603882
        },
        {
          "chunk_id": 7,
          "file_path": "mm/oom_kill.c",
          "start_line": 1011,
          "end_line": 1162,
          "content": [
            "static int oom_kill_memcg_member(struct task_struct *task, void *message)",
            "{",
            "\tif (task->signal->oom_score_adj != OOM_SCORE_ADJ_MIN &&",
            "\t    !is_global_init(task)) {",
            "\t\tget_task_struct(task);",
            "\t\t__oom_kill_process(task, message);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void oom_kill_process(struct oom_control *oc, const char *message)",
            "{",
            "\tstruct task_struct *victim = oc->chosen;",
            "\tstruct mem_cgroup *oom_group;",
            "\tstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,",
            "\t\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
            "",
            "\t/*",
            "\t * If the task is already exiting, don't alarm the sysadmin or kill",
            "\t * its children or threads, just give it access to memory reserves",
            "\t * so it can die quickly",
            "\t */",
            "\ttask_lock(victim);",
            "\tif (task_will_free_mem(victim)) {",
            "\t\tmark_oom_victim(victim);",
            "\t\tqueue_oom_reaper(victim);",
            "\t\ttask_unlock(victim);",
            "\t\tput_task_struct(victim);",
            "\t\treturn;",
            "\t}",
            "\ttask_unlock(victim);",
            "",
            "\tif (__ratelimit(&oom_rs))",
            "\t\tdump_header(oc, victim);",
            "",
            "\t/*",
            "\t * Do we need to kill the entire memory cgroup?",
            "\t * Or even one of the ancestor memory cgroups?",
            "\t * Check this out before killing the victim task.",
            "\t */",
            "\toom_group = mem_cgroup_get_oom_group(victim, oc->memcg);",
            "",
            "\t__oom_kill_process(victim, message);",
            "",
            "\t/*",
            "\t * If necessary, kill all tasks in the selected memory cgroup.",
            "\t */",
            "\tif (oom_group) {",
            "\t\tmemcg_memory_event(oom_group, MEMCG_OOM_GROUP_KILL);",
            "\t\tmem_cgroup_print_oom_group(oom_group);",
            "\t\tmem_cgroup_scan_tasks(oom_group, oom_kill_memcg_member,",
            "\t\t\t\t      (void *)message);",
            "\t\tmem_cgroup_put(oom_group);",
            "\t}",
            "}",
            "static void check_panic_on_oom(struct oom_control *oc)",
            "{",
            "\tif (likely(!sysctl_panic_on_oom))",
            "\t\treturn;",
            "\tif (sysctl_panic_on_oom != 2) {",
            "\t\t/*",
            "\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel",
            "\t\t * does not panic for cpuset, mempolicy, or memcg allocation",
            "\t\t * failures.",
            "\t\t */",
            "\t\tif (oc->constraint != CONSTRAINT_NONE)",
            "\t\t\treturn;",
            "\t}",
            "\t/* Do not panic for oom kills triggered by sysrq */",
            "\tif (is_sysrq_oom(oc))",
            "\t\treturn;",
            "\tdump_header(oc, NULL);",
            "\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",",
            "\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");",
            "}",
            "int register_oom_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&oom_notify_list, nb);",
            "}",
            "int unregister_oom_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&oom_notify_list, nb);",
            "}",
            "bool out_of_memory(struct oom_control *oc)",
            "{",
            "\tunsigned long freed = 0;",
            "",
            "\tif (oom_killer_disabled)",
            "\t\treturn false;",
            "",
            "\tif (!is_memcg_oom(oc)) {",
            "\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);",
            "\t\tif (freed > 0 && !is_sysrq_oom(oc))",
            "\t\t\t/* Got some memory back in the last second. */",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * If current has a pending SIGKILL or is exiting, then automatically",
            "\t * select it.  The goal is to allow it to allocate so that it may",
            "\t * quickly exit and free its memory.",
            "\t */",
            "\tif (task_will_free_mem(current)) {",
            "\t\tmark_oom_victim(current);",
            "\t\tqueue_oom_reaper(current);",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * The OOM killer does not compensate for IO-less reclaim.",
            "\t * But mem_cgroup_oom() has to invoke the OOM killer even",
            "\t * if it is a GFP_NOFS allocation.",
            "\t */",
            "\tif (!(oc->gfp_mask & __GFP_FS) && !is_memcg_oom(oc))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Check if there were limitations on the allocation (only relevant for",
            "\t * NUMA and memcg) that may require different handling.",
            "\t */",
            "\toc->constraint = constrained_alloc(oc);",
            "\tif (oc->constraint != CONSTRAINT_MEMORY_POLICY)",
            "\t\toc->nodemask = NULL;",
            "\tcheck_panic_on_oom(oc);",
            "",
            "\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&",
            "\t    current->mm && !oom_unkillable_task(current) &&",
            "\t    oom_cpuset_eligible(current, oc) &&",
            "\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {",
            "\t\tget_task_struct(current);",
            "\t\toc->chosen = current;",
            "\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");",
            "\t\treturn true;",
            "\t}",
            "",
            "\tselect_bad_process(oc);",
            "\t/* Found nothing?!?! */",
            "\tif (!oc->chosen) {",
            "\t\tdump_header(oc, NULL);",
            "\t\tpr_warn(\"Out of memory and no killable processes...\\n\");",
            "\t\t/*",
            "\t\t * If we got here due to an actual allocation at the",
            "\t\t * system level, we cannot survive this and will enter",
            "\t\t * an endless loop in the allocator. Bail out now.",
            "\t\t */",
            "\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))",
            "\t\t\tpanic(\"System is deadlocked on memory\\n\");",
            "\t}",
            "\tif (oc->chosen && oc->chosen != (void *)-1UL)",
            "\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :",
            "\t\t\t\t \"Memory cgroup out of memory\");",
            "\treturn !!oc->chosen;",
            "}"
          ],
          "function_name": "oom_kill_memcg_member, oom_kill_process, check_panic_on_oom, register_oom_notifier, unregister_oom_notifier, out_of_memory",
          "description": "实现基于内存控制组的OOM处理逻辑，集成OOM通知机制，包含OOM触发判定、进程选择算法、内存组遍历杀进程等功能，支持系统级OOM恐慌检测",
          "similarity": 0.5072561502456665
        },
        {
          "chunk_id": 2,
          "file_path": "mm/oom_kill.c",
          "start_line": 253,
          "end_line": 359,
          "content": [
            "static enum oom_constraint constrained_alloc(struct oom_control *oc)",
            "{",
            "\tstruct zone *zone;",
            "\tstruct zoneref *z;",
            "\tenum zone_type highest_zoneidx = gfp_zone(oc->gfp_mask);",
            "\tbool cpuset_limited = false;",
            "\tint nid;",
            "",
            "\tif (is_memcg_oom(oc)) {",
            "\t\toc->totalpages = mem_cgroup_get_max(oc->memcg) ?: 1;",
            "\t\treturn CONSTRAINT_MEMCG;",
            "\t}",
            "",
            "\t/* Default to all available memory */",
            "\toc->totalpages = totalram_pages() + total_swap_pages;",
            "",
            "\tif (!IS_ENABLED(CONFIG_NUMA))",
            "\t\treturn CONSTRAINT_NONE;",
            "",
            "\tif (!oc->zonelist)",
            "\t\treturn CONSTRAINT_NONE;",
            "\t/*",
            "\t * Reach here only when __GFP_NOFAIL is used. So, we should avoid",
            "\t * to kill current.We have to random task kill in this case.",
            "\t * Hopefully, CONSTRAINT_THISNODE...but no way to handle it, now.",
            "\t */",
            "\tif (oc->gfp_mask & __GFP_THISNODE)",
            "\t\treturn CONSTRAINT_NONE;",
            "",
            "\t/*",
            "\t * This is not a __GFP_THISNODE allocation, so a truncated nodemask in",
            "\t * the page allocator means a mempolicy is in effect.  Cpuset policy",
            "\t * is enforced in get_page_from_freelist().",
            "\t */",
            "\tif (oc->nodemask &&",
            "\t    !nodes_subset(node_states[N_MEMORY], *oc->nodemask)) {",
            "\t\toc->totalpages = total_swap_pages;",
            "\t\tfor_each_node_mask(nid, *oc->nodemask)",
            "\t\t\toc->totalpages += node_present_pages(nid);",
            "\t\treturn CONSTRAINT_MEMORY_POLICY;",
            "\t}",
            "",
            "\t/* Check this allocation failure is caused by cpuset's wall function */",
            "\tfor_each_zone_zonelist_nodemask(zone, z, oc->zonelist,",
            "\t\t\thighest_zoneidx, oc->nodemask)",
            "\t\tif (!cpuset_zone_allowed(zone, oc->gfp_mask))",
            "\t\t\tcpuset_limited = true;",
            "",
            "\tif (cpuset_limited) {",
            "\t\toc->totalpages = total_swap_pages;",
            "\t\tfor_each_node_mask(nid, cpuset_current_mems_allowed)",
            "\t\t\toc->totalpages += node_present_pages(nid);",
            "\t\treturn CONSTRAINT_CPUSET;",
            "\t}",
            "\treturn CONSTRAINT_NONE;",
            "}",
            "static int oom_evaluate_task(struct task_struct *task, void *arg)",
            "{",
            "\tstruct oom_control *oc = arg;",
            "\tlong points;",
            "",
            "\tif (oom_unkillable_task(task))",
            "\t\tgoto next;",
            "",
            "\t/* p may not have freeable memory in nodemask */",
            "\tif (!is_memcg_oom(oc) && !oom_cpuset_eligible(task, oc))",
            "\t\tgoto next;",
            "",
            "\t/*",
            "\t * This task already has access to memory reserves and is being killed.",
            "\t * Don't allow any other task to have access to the reserves unless",
            "\t * the task has MMF_OOM_SKIP because chances that it would release",
            "\t * any memory is quite low.",
            "\t */",
            "\tif (!is_sysrq_oom(oc) && tsk_is_oom_victim(task)) {",
            "\t\tif (test_bit(MMF_OOM_SKIP, &task->signal->oom_mm->flags))",
            "\t\t\tgoto next;",
            "\t\tgoto abort;",
            "\t}",
            "",
            "\t/*",
            "\t * If task is allocating a lot of memory and has been marked to be",
            "\t * killed first if it triggers an oom, then select it.",
            "\t */",
            "\tif (oom_task_origin(task)) {",
            "\t\tpoints = LONG_MAX;",
            "\t\tgoto select;",
            "\t}",
            "",
            "\tpoints = oom_badness(task, oc->totalpages);",
            "\tif (points == LONG_MIN || points < oc->chosen_points)",
            "\t\tgoto next;",
            "",
            "select:",
            "\tif (oc->chosen)",
            "\t\tput_task_struct(oc->chosen);",
            "\tget_task_struct(task);",
            "\toc->chosen = task;",
            "\toc->chosen_points = points;",
            "next:",
            "\treturn 0;",
            "abort:",
            "\tif (oc->chosen)",
            "\t\tput_task_struct(oc->chosen);",
            "\toc->chosen = (void *)-1UL;",
            "\treturn 1;",
            "}"
          ],
          "function_name": "constrained_alloc, oom_evaluate_task",
          "description": "根据内存分配约束条件（如NUMA节点、内存组）动态调整可回收内存总量，并通过评估函数筛选出具有最高OOM不良值的任务作为潜在受害者。",
          "similarity": 0.48519167304039
        },
        {
          "chunk_id": 5,
          "file_path": "mm/oom_kill.c",
          "start_line": 646,
          "end_line": 746,
          "content": [
            "static int oom_reaper(void *unused)",
            "{",
            "\tset_freezable();",
            "",
            "\twhile (true) {",
            "\t\tstruct task_struct *tsk = NULL;",
            "",
            "\t\twait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);",
            "\t\tspin_lock_irq(&oom_reaper_lock);",
            "\t\tif (oom_reaper_list != NULL) {",
            "\t\t\ttsk = oom_reaper_list;",
            "\t\t\toom_reaper_list = tsk->oom_reaper_list;",
            "\t\t}",
            "\t\tspin_unlock_irq(&oom_reaper_lock);",
            "",
            "\t\tif (tsk)",
            "\t\t\toom_reap_task(tsk);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void wake_oom_reaper(struct timer_list *timer)",
            "{",
            "\tstruct task_struct *tsk = container_of(timer, struct task_struct,",
            "\t\t\toom_reaper_timer);",
            "\tstruct mm_struct *mm = tsk->signal->oom_mm;",
            "\tunsigned long flags;",
            "",
            "\t/* The victim managed to terminate on its own - see exit_mmap */",
            "\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {",
            "\t\tput_task_struct(tsk);",
            "\t\treturn;",
            "\t}",
            "",
            "\tspin_lock_irqsave(&oom_reaper_lock, flags);",
            "\ttsk->oom_reaper_list = oom_reaper_list;",
            "\toom_reaper_list = tsk;",
            "\tspin_unlock_irqrestore(&oom_reaper_lock, flags);",
            "\ttrace_wake_reaper(tsk->pid);",
            "\twake_up(&oom_reaper_wait);",
            "}",
            "static void queue_oom_reaper(struct task_struct *tsk)",
            "{",
            "\t/* mm is already queued? */",
            "\tif (test_and_set_bit(MMF_OOM_REAP_QUEUED, &tsk->signal->oom_mm->flags))",
            "\t\treturn;",
            "",
            "\tget_task_struct(tsk);",
            "\ttimer_setup(&tsk->oom_reaper_timer, wake_oom_reaper, 0);",
            "\ttsk->oom_reaper_timer.expires = jiffies + OOM_REAPER_DELAY;",
            "\tadd_timer(&tsk->oom_reaper_timer);",
            "}",
            "static int __init oom_init(void)",
            "{",
            "\toom_reaper_th = kthread_run(oom_reaper, NULL, \"oom_reaper\");",
            "#ifdef CONFIG_SYSCTL",
            "\tregister_sysctl_init(\"vm\", vm_oom_kill_table);",
            "#endif",
            "\treturn 0;",
            "}",
            "static inline void queue_oom_reaper(struct task_struct *tsk)",
            "{",
            "}",
            "static void mark_oom_victim(struct task_struct *tsk)",
            "{",
            "\tconst struct cred *cred;",
            "\tstruct mm_struct *mm = tsk->mm;",
            "",
            "\tWARN_ON(oom_killer_disabled);",
            "\t/* OOM killer might race with memcg OOM */",
            "\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))",
            "\t\treturn;",
            "",
            "\t/* oom_mm is bound to the signal struct life time. */",
            "\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm))",
            "\t\tmmgrab(tsk->signal->oom_mm);",
            "",
            "\t/*",
            "\t * Make sure that the task is woken up from uninterruptible sleep",
            "\t * if it is frozen because OOM killer wouldn't be able to free",
            "\t * any memory and livelock. freezing_slow_path will tell the freezer",
            "\t * that TIF_MEMDIE tasks should be ignored.",
            "\t */",
            "\t__thaw_task(tsk);",
            "\tatomic_inc(&oom_victims);",
            "\tcred = get_task_cred(tsk);",
            "\ttrace_mark_victim(tsk, cred->uid.val);",
            "\tput_cred(cred);",
            "}",
            "void exit_oom_victim(void)",
            "{",
            "\tclear_thread_flag(TIF_MEMDIE);",
            "",
            "\tif (!atomic_dec_return(&oom_victims))",
            "\t\twake_up_all(&oom_victims_wait);",
            "}",
            "void oom_killer_enable(void)",
            "{",
            "\toom_killer_disabled = false;",
            "\tpr_info(\"OOM killer enabled.\\n\");",
            "}"
          ],
          "function_name": "oom_reaper, wake_oom_reaper, queue_oom_reaper, oom_init, queue_oom_reaper, mark_oom_victim, exit_oom_victim, oom_killer_enable",
          "description": "定义OOM杀手线程及其管理逻辑，通过等待队列和自旋锁协调进程回收，支持定时唤醒和任务标记机制，初始化OOM杀手线程并注册sysctl接口，部分函数存在重复定义导致上下文不完整",
          "similarity": 0.46937185525894165
        },
        {
          "chunk_id": 6,
          "file_path": "mm/oom_kill.c",
          "start_line": 826,
          "end_line": 995,
          "content": [
            "bool oom_killer_disable(signed long timeout)",
            "{",
            "\tsigned long ret;",
            "",
            "\t/*",
            "\t * Make sure to not race with an ongoing OOM killer. Check that the",
            "\t * current is not killed (possibly due to sharing the victim's memory).",
            "\t */",
            "\tif (mutex_lock_killable(&oom_lock))",
            "\t\treturn false;",
            "\toom_killer_disabled = true;",
            "\tmutex_unlock(&oom_lock);",
            "",
            "\tret = wait_event_interruptible_timeout(oom_victims_wait,",
            "\t\t\t!atomic_read(&oom_victims), timeout);",
            "\tif (ret <= 0) {",
            "\t\toom_killer_enable();",
            "\t\treturn false;",
            "\t}",
            "\tpr_info(\"OOM killer disabled.\\n\");",
            "",
            "\treturn true;",
            "}",
            "static inline bool __task_will_free_mem(struct task_struct *task)",
            "{",
            "\tstruct signal_struct *sig = task->signal;",
            "",
            "\t/*",
            "\t * A coredumping process may sleep for an extended period in",
            "\t * coredump_task_exit(), so the oom killer cannot assume that",
            "\t * the process will promptly exit and release memory.",
            "\t */",
            "\tif (sig->core_state)",
            "\t\treturn false;",
            "",
            "\tif (sig->flags & SIGNAL_GROUP_EXIT)",
            "\t\treturn true;",
            "",
            "\tif (thread_group_empty(task) && (task->flags & PF_EXITING))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static bool task_will_free_mem(struct task_struct *task)",
            "{",
            "\tstruct mm_struct *mm = task->mm;",
            "\tstruct task_struct *p;",
            "\tbool ret = true;",
            "",
            "\t/*",
            "\t * Skip tasks without mm because it might have passed its exit_mm and",
            "\t * exit_oom_victim. oom_reaper could have rescued that but do not rely",
            "\t * on that for now. We can consider find_lock_task_mm in future.",
            "\t */",
            "\tif (!mm)",
            "\t\treturn false;",
            "",
            "\tif (!__task_will_free_mem(task))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * This task has already been drained by the oom reaper so there are",
            "\t * only small chances it will free some more",
            "\t */",
            "\tif (test_bit(MMF_OOM_SKIP, &mm->flags))",
            "\t\treturn false;",
            "",
            "\tif (atomic_read(&mm->mm_users) <= 1)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Make sure that all tasks which share the mm with the given tasks",
            "\t * are dying as well to make sure that a) nobody pins its mm and",
            "\t * b) the task is also reapable by the oom reaper.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_process(p) {",
            "\t\tif (!process_shares_mm(p, mm))",
            "\t\t\tcontinue;",
            "\t\tif (same_thread_group(task, p))",
            "\t\t\tcontinue;",
            "\t\tret = __task_will_free_mem(p);",
            "\t\tif (!ret)",
            "\t\t\tbreak;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "static void __oom_kill_process(struct task_struct *victim, const char *message)",
            "{",
            "\tstruct task_struct *p;",
            "\tstruct mm_struct *mm;",
            "\tbool can_oom_reap = true;",
            "",
            "\tp = find_lock_task_mm(victim);",
            "\tif (!p) {",
            "\t\tpr_info(\"%s: OOM victim %d (%s) is already exiting. Skip killing the task\\n\",",
            "\t\t\tmessage, task_pid_nr(victim), victim->comm);",
            "\t\tput_task_struct(victim);",
            "\t\treturn;",
            "\t} else if (victim != p) {",
            "\t\tget_task_struct(p);",
            "\t\tput_task_struct(victim);",
            "\t\tvictim = p;",
            "\t}",
            "",
            "\t/* Get a reference to safely compare mm after task_unlock(victim) */",
            "\tmm = victim->mm;",
            "\tmmgrab(mm);",
            "",
            "\t/* Raise event before sending signal: task reaper must see this */",
            "\tcount_vm_event(OOM_KILL);",
            "\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);",
            "",
            "\t/*",
            "\t * We should send SIGKILL before granting access to memory reserves",
            "\t * in order to prevent the OOM victim from depleting the memory",
            "\t * reserves from the user space under its control.",
            "\t */",
            "\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);",
            "\tmark_oom_victim(victim);",
            "\tpr_err(\"%s: Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB, UID:%u pgtables:%lukB oom_score_adj:%hd\\n\",",
            "\t\tmessage, task_pid_nr(victim), victim->comm, K(mm->total_vm),",
            "\t\tK(get_mm_counter(mm, MM_ANONPAGES)),",
            "\t\tK(get_mm_counter(mm, MM_FILEPAGES)),",
            "\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)),",
            "\t\tfrom_kuid(&init_user_ns, task_uid(victim)),",
            "\t\tmm_pgtables_bytes(mm) >> 10, victim->signal->oom_score_adj);",
            "\ttask_unlock(victim);",
            "",
            "\t/*",
            "\t * Kill all user processes sharing victim->mm in other thread groups, if",
            "\t * any.  They don't get access to memory reserves, though, to avoid",
            "\t * depletion of all memory.  This prevents mm->mmap_lock livelock when an",
            "\t * oom killed thread cannot exit because it requires the semaphore and",
            "\t * its contended by another thread trying to allocate memory itself.",
            "\t * That thread will now get access to memory reserves since it has a",
            "\t * pending fatal signal.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_process(p) {",
            "\t\tif (!process_shares_mm(p, mm))",
            "\t\t\tcontinue;",
            "\t\tif (same_thread_group(p, victim))",
            "\t\t\tcontinue;",
            "\t\tif (is_global_init(p)) {",
            "\t\t\tcan_oom_reap = false;",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",",
            "\t\t\t\t\ttask_pid_nr(victim), victim->comm,",
            "\t\t\t\t\ttask_pid_nr(p), p->comm);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/*",
            "\t\t * No kthread_use_mm() user needs to read from the userspace so",
            "\t\t * we are ok to reap it.",
            "\t\t */",
            "\t\tif (unlikely(p->flags & PF_KTHREAD))",
            "\t\t\tcontinue;",
            "\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\tif (can_oom_reap)",
            "\t\tqueue_oom_reaper(victim);",
            "",
            "\tmmdrop(mm);",
            "\tput_task_struct(victim);",
            "}"
          ],
          "function_name": "oom_killer_disable, __task_will_free_mem, task_will_free_mem, __oom_kill_process",
          "description": "提供OOM杀手禁用逻辑及进程可回收性判断，实现OOM触发时的进程强制终止流程，包含共享MM处理、信号发送、内存统计等核心操作",
          "similarity": 0.4688326418399811
        }
      ]
    },
    {
      "source_file": "mm/damon/ops-common.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:48:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `damon\\ops-common.c`\n\n---\n\n# `damon/ops-common.c` 技术文档\n\n## 1. 文件概述\n\n`damon/ops-common.c` 是 Linux 内核中 **DAMON（Data Access MONitor）** 子系统的一部分，提供与底层内存访问监控相关的通用操作原语。该文件实现了用于获取页面信息、标记页面为“旧”（即非活跃）、以及基于访问频率和区域年龄计算内存区域“热度”或“冷度”评分的核心函数，为 DAMON 的策略决策（如 DAMOS：DAMON-based Operation Schemes）提供基础支持。\n\n## 2. 核心功能\n\n### 主要函数：\n\n- **`damon_get_folio(unsigned long pfn)`**  \n  根据物理页帧号（PFN）安全地获取对应的在线 `struct folio` 对象，前提是该 folio 在 LRU 链表中且可成功增加引用计数。\n\n- **`damon_ptep_mkold(pte_t *pte, struct vm_area_struct *vma, unsigned long addr)`**  \n  将指定 PTE（页表项）所映射的页面标记为“旧”（idle），并清除其年轻（young）状态（如有），适用于普通 4KB 页面。\n\n- **`damon_pmdp_mkold(pmd_t *pmd, struct vm_area_struct *vma, unsigned long addr)`**  \n  功能同上，但作用于 PMD（页中间目录）项，用于透明大页（Transparent Huge Page, THP），仅在 `CONFIG_TRANSPARENT_HUGEPAGE` 启用时有效。\n\n- **`damon_hot_score(struct damon_ctx *c, struct damon_region *r, struct damos *s)`**  \n  基于区域的访问次数（`nr_accesses`）和年龄（`age`），结合策略权重，计算该区域的“热度”评分（范围 `[0, DAMOS_MAX_SCORE]`）。\n\n- **`damon_cold_score(struct damon_ctx *c, struct damon_region *r, struct damos *s)`**  \n  返回区域的“冷度”评分，即 `DAMOS_MAX_SCORE - 热度评分`。\n\n### 关键宏定义：\n\n- `DAMON_MAX_SUBSCORE`：子评分最大值（100），用于归一化。\n- `DAMON_MAX_AGE_IN_LOG`：年龄对数尺度的最大值（32），用于将线性年龄转换为对数尺度。\n\n## 3. 关键实现\n\n### 页面获取 (`damon_get_folio`)\n- 调用 `pfn_to_online_page()` 获取对应 PFN 的 `struct page`。\n- 排除尾页（`PageTail`）以确保只处理 folio 头页。\n- 检查 folio 是否在 LRU 链表中（`folio_test_lru`）并尝试增加引用计数（`folio_try_get`）。\n- 进行二次验证以防止并发修改导致状态不一致，若验证失败则释放引用并返回 `NULL`。\n\n### 页面标记为“旧” (`damon_*_mkold`)\n- 通过 `damon_get_folio` 安全获取 folio。\n- 调用 `ptep_clear_young_notify` / `pmdp_clear_young_notify` 清除硬件/软件的“young”位，并通知 MMU notifier。\n- 若页面曾被访问（young 位被置位），则调用 `folio_set_young` 更新 folio 的软件状态。\n- 最终调用 `folio_set_idle` 显式标记该 folio 为 idle（未被近期访问）。\n- 函数结束前释放 folio 引用。\n\n### 热度评分算法 (`damon_hot_score`)\n1. **频率子评分**：  \n   将区域访问次数 `r->nr_accesses` 归一化到 `[0, 100]`，基于当前上下文的最大可能访问次数（由 `damon_max_nr_accesses()` 提供）。\n\n2. **年龄子评分**：  \n   - 将区域年龄（单位：聚合间隔次数）转换为秒数。\n   - 使用对数尺度（右移计数）将年龄压缩到 `[0, 32]` 范围。\n   - **关键逻辑**：若频率为 0（从未访问），则年龄越大表示越“冷”，因此将 `age_in_log` 取负值。\n   - 将 `age_in_log` 平移到 `[0, 64]` 区间，再缩放到 `[0, 100]` 作为年龄子评分。\n\n3. **加权平均与归一化**：  \n   - 使用策略 `s->quota.weight_nr_accesses` 和 `s->quota.weight_age` 对两个子评分加权平均。\n   - 最终将结果缩放到 DAMOS 评分范围 `[0, DAMOS_MAX_SCORE]`。\n\n## 4. 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/mmu_notifier.h>`：用于 `*_clear_young_notify` 的 MMU 通知机制。\n  - `<linux/page_idle.h>`：提供 `folio_set_idle()` 等页面空闲状态管理接口。\n  - `<linux/pagemap.h>` 和 `<linux/rmap.h>`：提供页面到 folio 转换、LRU 状态检查等内存管理原语。\n- **内部依赖**：\n  - `\"ops-common.h\"`：声明本文件中实现的函数。\n  - 依赖 DAMON 核心结构体：`struct damon_ctx`、`struct damon_region`、`struct damos`。\n- **配置依赖**：\n  - `damon_pmdp_mkold` 依赖 `CONFIG_TRANSPARENT_HUGEPAGE`。\n\n## 5. 使用场景\n\n- **DAMON 监控阶段**：在定期采样内存访问模式时，DAMON 需要将已监控的页面重置为“旧”状态，以便下次采样能检测到新的访问。`damon_ptep_mkold` 和 `damon_pmdp_mkold` 用于此目的。\n- **DAMOS 策略执行**：当 DAMON 启用基于策略的操作（如内存回收、迁移、THP 降级等）时，需对内存区域进行热度排序。`damon_hot_score` 和 `damon_cold_score` 为 DAMOS 提供统一的评分机制，使策略可根据用户配置的权重（访问频率 vs. 年龄）动态评估区域价值。\n- **内存优化工具链**：该文件是 `mm/damon/` 子系统的基础组件，服务于 `damon_reclaim`、`damon_lru_sort` 等高级内存管理特性。",
      "similarity": 0.4949270486831665,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/damon/ops-common.c",
          "start_line": 40,
          "end_line": 115,
          "content": [
            "void damon_ptep_mkold(pte_t *pte, struct vm_area_struct *vma, unsigned long addr)",
            "{",
            "\tstruct folio *folio = damon_get_folio(pte_pfn(ptep_get(pte)));",
            "",
            "\tif (!folio)",
            "\t\treturn;",
            "",
            "\tif (ptep_clear_young_notify(vma, addr, pte))",
            "\t\tfolio_set_young(folio);",
            "",
            "\tfolio_set_idle(folio);",
            "\tfolio_put(folio);",
            "}",
            "void damon_pmdp_mkold(pmd_t *pmd, struct vm_area_struct *vma, unsigned long addr)",
            "{",
            "#ifdef CONFIG_TRANSPARENT_HUGEPAGE",
            "\tstruct folio *folio = damon_get_folio(pmd_pfn(pmdp_get(pmd)));",
            "",
            "\tif (!folio)",
            "\t\treturn;",
            "",
            "\tif (pmdp_clear_young_notify(vma, addr, pmd))",
            "\t\tfolio_set_young(folio);",
            "",
            "\tfolio_set_idle(folio);",
            "\tfolio_put(folio);",
            "#endif /* CONFIG_TRANSPARENT_HUGEPAGE */",
            "}",
            "int damon_hot_score(struct damon_ctx *c, struct damon_region *r,",
            "\t\t\tstruct damos *s)",
            "{",
            "\tint freq_subscore;",
            "\tunsigned int age_in_sec;",
            "\tint age_in_log, age_subscore;",
            "\tunsigned int freq_weight = s->quota.weight_nr_accesses;",
            "\tunsigned int age_weight = s->quota.weight_age;",
            "\tint hotness;",
            "",
            "\tfreq_subscore = r->nr_accesses * DAMON_MAX_SUBSCORE /",
            "\t\tdamon_max_nr_accesses(&c->attrs);",
            "",
            "\tage_in_sec = (unsigned long)r->age * c->attrs.aggr_interval / 1000000;",
            "\tfor (age_in_log = 0; age_in_log < DAMON_MAX_AGE_IN_LOG && age_in_sec;",
            "\t\t\tage_in_log++, age_in_sec >>= 1)",
            "\t\t;",
            "",
            "\t/* If frequency is 0, higher age means it's colder */",
            "\tif (freq_subscore == 0)",
            "\t\tage_in_log *= -1;",
            "",
            "\t/*",
            "\t * Now age_in_log is in [-DAMON_MAX_AGE_IN_LOG, DAMON_MAX_AGE_IN_LOG].",
            "\t * Scale it to be in [0, 100] and set it as age subscore.",
            "\t */",
            "\tage_in_log += DAMON_MAX_AGE_IN_LOG;",
            "\tage_subscore = age_in_log * DAMON_MAX_SUBSCORE /",
            "\t\tDAMON_MAX_AGE_IN_LOG / 2;",
            "",
            "\thotness = (freq_weight * freq_subscore + age_weight * age_subscore);",
            "\tif (freq_weight + age_weight)",
            "\t\thotness /= freq_weight + age_weight;",
            "\t/*",
            "\t * Transform it to fit in [0, DAMOS_MAX_SCORE]",
            "\t */",
            "\thotness = hotness * DAMOS_MAX_SCORE / DAMON_MAX_SUBSCORE;",
            "",
            "\treturn hotness;",
            "}",
            "int damon_cold_score(struct damon_ctx *c, struct damon_region *r,",
            "\t\t\tstruct damos *s)",
            "{",
            "\tint hotness = damon_hot_score(c, r, s);",
            "",
            "\t/* Return coldness of the region */",
            "\treturn DAMOS_MAX_SCORE - hotness;",
            "}"
          ],
          "function_name": "damon_ptep_mkold, damon_pmdp_mkold, damon_hot_score, damon_cold_score",
          "description": "damon_ptep_mkold清除页表项年轻标志并设置页面为空闲；damon_pmdp_mkold同上但针对大页；damon_hot_score根据访问频率和年龄计算热点评分；damon_cold_score返回对应冷点评分",
          "similarity": 0.4428032636642456
        },
        {
          "chunk_id": 0,
          "file_path": "mm/damon/ops-common.c",
          "start_line": 1,
          "end_line": 39,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Common Primitives for Data Access Monitoring",
            " *",
            " * Author: SeongJae Park <sj@kernel.org>",
            " */",
            "",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rmap.h>",
            "",
            "#include \"ops-common.h\"",
            "",
            "/*",
            " * Get an online page for a pfn if it's in the LRU list.  Otherwise, returns",
            " * NULL.",
            " *",
            " * The body of this function is stolen from the 'page_idle_get_folio()'.  We",
            " * steal rather than reuse it because the code is quite simple.",
            " */",
            "struct folio *damon_get_folio(unsigned long pfn)",
            "{",
            "\tstruct page *page = pfn_to_online_page(pfn);",
            "\tstruct folio *folio;",
            "",
            "\tif (!page || PageTail(page))",
            "\t\treturn NULL;",
            "",
            "\tfolio = page_folio(page);",
            "\tif (!folio_test_lru(folio) || !folio_try_get(folio))",
            "\t\treturn NULL;",
            "\tif (unlikely(page_folio(page) != folio || !folio_test_lru(folio))) {",
            "\t\tfolio_put(folio);",
            "\t\tfolio = NULL;",
            "\t}",
            "\treturn folio;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "获取在线LRU页面的folio结构，通过pfn转换为page后检查其是否为尾页，随后尝试获取folio引用并验证其LRU状态，成功则设置为idle并返回",
          "similarity": 0.3376512825489044
        }
      ]
    },
    {
      "source_file": "mm/kasan/kasan.h",
      "md_summary": "> 自动生成时间: 2025-12-07 16:15:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kasan\\kasan.h`\n\n---\n\n# `kasan/kasan.h` 技术文档\n\n## 1. 文件概述\n\n`kasan/kasan.h` 是 Linux 内核中 **Kernel Address Sanitizer (KASAN)** 子系统的核心头文件，用于定义 KASAN 的通用接口、数据结构和配置宏。该文件为三种 KASAN 模式（Generic、Software Tagging、Hardware Tagging）提供统一的抽象层，并根据编译配置条件性地启用特定功能。其主要作用包括：\n\n- 定义 KASAN 元数据布局和内存粒度\n- 提供堆栈跟踪、采样分配、故障模式判断等运行时辅助函数\n- 声明通用报告结构体和全局变量元数据格式\n- 实现不同 KASAN 模式下的行为差异（如是否需要元数据、影子内存映射等）\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能说明 |\n|------|--------|\n| `kasan_stack_collection_enabled()` | 判断是否启用堆栈跟踪收集（受 `kasan.stacktrace` 启动参数控制） |\n| `kasan_vmalloc_enabled()` | （仅 HW_TAGS）判断是否对 vmalloc 区域启用 KASAN |\n| `kasan_async_fault_possible()` / `kasan_sync_fault_possible()` | 判断当前 KASAN 模式是否可能触发异步/同步错误报告 |\n| `kasan_sample_page_alloc(unsigned int order)` | （仅 HW_TAGS）基于采样率决定是否对指定阶数的页面分配进行检测 |\n| `kasan_requires_meta()` | 判断当前 KASAN 模式是否需要为每个对象存储元数据 |\n| `kasan_shadow_to_mem(const void *shadow_addr)` | 将影子内存地址转换回对应的原始内存地址 |\n| `addr_has_metadata(const void *addr)` | 判断给定地址是否位于具有 KASAN 元数据覆盖的内存区域 |\n\n### 主要数据结构\n\n| 结构体 | 用途 |\n|-------|------|\n| `struct kasan_track` | 记录内存分配/释放时的 PID 和调用栈（通过 stackdepot 存储） |\n| `struct kasan_report_info` | 统一的错误报告上下文，包含访问信息、对象元数据、错误类型等 |\n| `struct kasan_source_location` | 编译器生成的全局变量源码位置信息（ABI 兼容） |\n| `struct kasan_global` | 描述全局变量的 KASAN 元数据（由编译器插桩生成） |\n| `struct kasan_alloc_meta` / `struct kasan_free_meta` | （仅 GENERIC）存储 slab 对象的分配/释放元数据 |\n| `struct kasan_stack_ring_entry` / `struct kasan_stack_ring` | （SW/HW_TAGS）用于记录近期内存操作的环形缓冲区 |\n\n### 关键宏定义\n\n| 宏 | 说明 |\n|----|------|\n| `KASAN_GRANULE_SIZE` | KASAN 检测的基本内存粒度（Generic/SW_TAGS 为 8 字节，HW_TAGS 为 MTE 粒度） |\n| `KASAN_PAGE_FREE`, `KASAN_SLAB_REDZONE` 等 | 影子内存中的特殊标记值，表示不同类型的无效/红区内存 |\n| `KASAN_STACK_*`, `KASAN_ALLOCA_*` | （仅 GENERIC）栈和 alloca 红区的影子值（编译器 ABI） |\n| `META_*` 系列宏 | 定义元数据在调试输出中的显示格式（每行块数、字节数等） |\n\n## 3. 关键实现\n\n### 多模式支持机制\n文件通过 `#ifdef CONFIG_KASAN_*` 条件编译区分三种 KASAN 模式：\n- **Generic**：使用影子内存 + 每对象元数据，支持精确错误定位\n- **SW_TAGS**：使用软件生成的 8-bit 标签，无每对象元数据\n- **HW_TAGS**：利用 ARM MTE 硬件标签，依赖 CPU 特性\n\n### 堆栈跟踪控制\n通过 `static_key` 优化性能：\n```c\nDECLARE_STATIC_KEY_TRUE(kasan_flag_stacktrace);\n```\n默认启用堆栈收集，但可通过启动参数 `kasan.stacktrace=off` 动态关闭，减少运行时开销。\n\n### 页面分配采样（HW_TAGS 特有）\n为平衡性能与覆盖率，HW_TAGS 模式引入概率采样：\n- 小于 `kasan_page_alloc_sample_order` 的分配总是检测\n- 更大分配按 `1/kasan_page_alloc_sample` 概率检测\n- 使用 per-CPU 计数器 `kasan_page_alloc_skip` 实现无锁采样\n\n### 元数据管理差异\n- **Generic 模式**：在对象前后或 quarantine 中存储 `kasan_alloc_meta`/`free_meta`\n- **Tag-based 模式**：不使用每对象元数据，改用环形缓冲区 `kasan_stack_ring` 记录近期操作\n\n### 影子内存映射\n通过 `kasan_shadow_to_mem()` 实现影子地址到原始地址的转换，公式为：\n```\n原始地址 = (影子地址 - KASAN_SHADOW_OFFSET) << KASAN_SHADOW_SCALE_SHIFT\n```\n\n## 4. 依赖关系\n\n| 依赖模块 | 用途 |\n|---------|------|\n| `<linux/kasan.h>` | KASAN 公共 API（如 `kasan_enable/disable_current()`） |\n| `<linux/kasan-tags.h>` | 标签操作辅助函数（如 `kasan_reset_tag()`） |\n| `<linux/stackdepot.h>` | 调用栈压缩存储（`depot_stack_handle_t`） |\n| `<asm/mte-kasan.h>` | （HW_TAGS）ARM MTE 架构相关定义 |\n| `<linux/slab.h>` | （HW_TAGS）slab 分配器集成 |\n| `<linux/static_key.h>` | 静态分支优化（堆栈跟踪开关） |\n| `<linux/kfence.h>` | 与 KFENCE 内存检测器协同工作 |\n\n## 5. 使用场景\n\n1. **内存错误检测**  \n   在内核内存访问（读/写）时，KASAN 运行时通过此头文件定义的接口检查影子内存状态，捕获越界、释放后使用等错误。\n\n2. **错误报告生成**  \n   当检测到非法访问时，`kasan_report_info` 结构体被填充，结合 `kasan_track` 中的堆栈信息生成详细错误报告。\n\n3. **编译器插桩支持**  \n   Clang/GCC 在编译时生成对 `__asan_load*/store*` 的调用，这些函数内部使用本文件定义的宏（如 `KASAN_GRANULE_SIZE`）和地址转换逻辑。\n\n4. **全局变量保护**  \n   编译器为全局变量生成 `kasan_global` 结构体数组，在初始化阶段通过 `kasan_register_globals()` 注册红区。\n\n5. **动态配置调整**  \n   通过 `kasan.stacktrace`、`kasan.vmalloc` 等启动参数，可在运行时调整 KASAN 行为（如关闭堆栈收集以提升性能）。\n\n6. **硬件加速集成**  \n   在 ARM64 平台上，HW_TAGS 模式利用 MTE 指令自动验证内存标签，本文件提供与硬件特性的抽象层对接。",
      "similarity": 0.49087756872177124,
      "chunks": []
    }
  ]
}