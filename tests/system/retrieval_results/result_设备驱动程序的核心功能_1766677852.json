{
  "query": "设备驱动程序的核心功能",
  "timestamp": "2025-12-25 23:50:52",
  "retrieved_files": [
    {
      "source_file": "kernel/hardware_message.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:43:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `hardware_message.c`\n\n---\n\n# hardware_message.c 技术文档\n\n## 文件概述\n\n`hardware_message.c` 是麒麟操作系统（Kylin Linux Advanced Desktop/Server，简称 KLAS/KLAD）内核中用于向用户发出硬件或驱动程序支持状态警告的专用模块。该文件定义了一系列函数，用于在内核启动或驱动加载过程中，根据硬件或驱动的生命周期状态（如“已弃用”、“不再维护”、“已禁用”或“技术预览”）向系统日志输出高优先级的 `pr_crit()` 警告信息。这些函数仅在启用了 `CONFIG_KYLIN_DIFFERENCES` 内核配置选项时生效，体现了麒麟操作系统对特定硬件兼容性与支持策略的管理机制。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `mark_hardware_unmaintained()` | 标记特定硬件设备为“不再维护”，输出包含设备描述的严重警告 |\n| `mark_driver_unmaintained()` | 标记驱动程序为“不再维护”，适用于无法关联具体硬件的通用驱动 |\n| `mark_hardware_deprecated()` | 标记特定硬件为“已弃用”，提示将在未来版本停止维护 |\n| `mark_driver_deprecated()` | 标记驱动为“已弃用”，适用于抽象或高层驱动 |\n| `mark_hardware_disabled()` | 标记硬件支持已被完全禁用，设备无法在当前版本使用 |\n| `mark_tech_preview()` | 标记驱动或子系统为“技术预览”状态（函数声明未完整实现） |\n\n### 数据结构与常量\n\n- `DEV_DESC_LEN`：定义设备描述字符串的最大长度（256 字节）\n- 使用 `va_list` 和可变参数处理设备描述格式化\n\n### 导出符号\n\n所有上述函数均通过 `EXPORT_SYMBOL()` 导出，可供其他内核模块调用。\n\n## 关键实现\n\n### 条件编译控制\n\n所有函数的实现均被 `#ifdef CONFIG_KYLIN_DIFFERENCES` 包裹，确保仅在麒麟定制内核中启用该功能，避免对上游 Linux 内核造成影响。\n\n### 驱动/模块名称解析逻辑\n\n函数优先使用传入的 `driver_name` 参数；若为空且启用了 `CONFIG_MODULES`，则回退到从 `struct module *mod` 中提取模块名；若两者均不可用，则使用默认字符串 `\"Kernel\"`。\n\n### 可变参数处理\n\n对于硬件相关的函数（`_hardware_*`），使用 `va_start`/`vsnprintf`/`va_end` 机制格式化设备描述信息，支持动态构造设备标识（如 PCI ID、设备型号等）。\n\n### 日志级别\n\n统一使用 `pr_crit()` 输出 **Critical** 级别日志，确保警告信息在系统日志中高亮显示，引起管理员注意。\n\n### 生命周期状态语义\n\n- **Deprecated（已弃用）**：当前仍可用，但计划在未来主版本中转为“不再维护”或“禁用”\n- **Unmaintained（不再维护）**：仅修复安全或严重问题，常规更新已停止\n- **Disabled（已禁用）**：当前版本已完全移除支持\n- **Tech Preview（技术预览）**：新功能，测试有限，不保证稳定性与支持（函数未完整实现）\n\n## 依赖关系\n\n### 头文件依赖\n\n- `<linux/kernel.h>`：提供 `pr_crit()`、`vsnprintf()`、`va_list` 等内核日志与字符串处理接口\n- `<linux/module.h>`：提供 `struct module` 定义及模块相关信息\n\n### 内核配置依赖\n\n- **必需**：`CONFIG_KYLIN_DIFFERENCES` — 启用麒麟特有差异功能\n- **可选**：`CONFIG_MODULES` — 支持从模块指针获取名称（若未启用模块，则跳过该路径）\n\n### 符号导出\n\n所有函数通过 `EXPORT_SYMBOL()` 导出，供其他驱动模块在初始化时调用，以声明自身支持状态。\n\n## 使用场景\n\n1. **驱动弃用通知**  \n   当某硬件厂商停止维护某款网卡，麒麟内核团队决定在下一主版本移除支持。当前版本中，该驱动在 `probe()` 时调用 `mark_hardware_deprecated()`，提示用户规划迁移。\n\n2. **通用驱动生命周期管理**  \n   某旧版 RAID 管理驱动因上游废弃，麒麟将其标记为“不再维护”，调用 `mark_driver_unmaintained()`，适用于所有使用该驱动的系统。\n\n3. **已禁用硬件检测**  \n   用户尝试加载已被内核配置禁用的旧显卡驱动，驱动框架调用 `mark_hardware_disabled()` 明确告知设备不可用。\n\n4. **新技术预览**  \n   引入实验性文件系统或新硬件支持时，通过 `mark_tech_preview()` 声明其非生产就绪状态（注：当前代码中该函数未实现完整逻辑）。\n\n5. **发布合规性**  \n   所有调用必须记录于 KLAS/KLAD 发行说明，并获得管理层审批，确保用户对硬件支持变更有明确预期。",
      "similarity": 0.6343821287155151,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/hardware_message.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Author: Jackie Liu <liuyun01@kylinos.cn>",
            " * Copyright (C) 2024, KylinSoft Corporation.",
            " *",
            " * The following functions are used by 'Kylin Linux Advanced Desktop/Server",
            " * Operation System' to indicate to users that hardware and drivers are",
            " * unsupported, or have limited support in KLAS/KLAD major and minor releases.",
            " * These functions output loud warning messages to the end user and should",
            " * be USED WITH CAUTION.",
            " *",
            " * Any use of these functions _MUST_ be documented in the KLAS/KLAD Release",
            " * Notes, and have approval of management.",
            " *",
            " * Generally, the process of disabling a driver or device in KLAS/KLAD requires",
            " * the driver or device to be marked as 'deprecated' in all existing releases,",
            " * and then either 'unmaintained' or 'disabled' in a future release.",
            " *",
            " * In general, deprecated and unmaintained drivers continue to receive security",
            " * related fixes until they are disabled.",
            " */",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "",
            "#define DEV_DESC_LEN 256",
            "",
            "/**",
            " * mark_hardware_unmaintained() - Mark hardware as unmaintained.",
            " * @driver_name: driver name",
            " * @mod: module pointer",
            " * @fmt: format for device description",
            " * @...: args for device description",
            " *",
            " * Called to notify users that the device will no longer be tested on a routine",
            " * basis and driver code associated with this device is no longer being updated.",
            " * KYLIN may fix security-related and critical issues. Support for this device",
            " * will be disabled in a future major release and users deploying this device",
            " * should plan to replace the device in production systems.",
            " *",
            " * This function should be used when the driver's usage can be tied to a",
            " * specific hardware device. For example, a network device driver loading on a",
            " * specific device that is no longer maintained by the manufacturer.",
            " */"
          ],
          "function_name": null,
          "description": "此代码块定义了用于标记硬件和驱动状态的函数原型，描述了各函数的用途及使用规范，核心功能是通知用户硬件/驱动的支持状态变化，但未提供函数实现，上下文不完整",
          "similarity": 0.6369491815567017
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/hardware_message.c",
          "start_line": 44,
          "end_line": 145,
          "content": [
            "void mark_hardware_unmaintained(const char *driver_name, struct module *mod,",
            "\t\t\t\tchar *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Unmaintained hardware is detected: %s:%s\\n\",",
            "\t\tname ?: \"Kernel\",",
            "\t\tdevice_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_driver_unmaintained(const char *driver_name, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tpr_crit(\"Warning: Unmaintained driver is detected: %s\\n\",",
            "\t\tname ?: \"Kernel\");",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_hardware_deprecated(const char *driver_name, struct module *mod,",
            "\t\t\t      char *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Deprecated Hardware is detected: %s:%s will not be \"",
            "\t\t\"maintained in a future major release and may be disabled.\\n\",",
            "\t\tname ?: \"Kernel\", device_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_driver_deprecated(const char *driver_name, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tpr_crit(\"Warning: Deprecated Driver is detected: %s will not be \"",
            "\t\t\"maintained in a future major release and may be disabled.\\n\",",
            "\t\tname ?: \"Kernel\");",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_hardware_disabled(const char *driver_name, struct module *mod,",
            "\t\t\t    char *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Disabled Hardware is detected: %s:%s is no longer \"",
            "\t\t\"enabled in this release.\\n\",",
            "\t\tname ?: \"Kernel\", device_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}"
          ],
          "function_name": "mark_hardware_unmaintained, mark_driver_unmaintained, mark_hardware_deprecated, mark_driver_deprecated, mark_hardware_disabled",
          "description": "实现了标记硬件/驱动状态的五个函数，通过变参处理构建设备描述信息并输出内核警告日志，核心功能是根据配置条件触发不同级别硬件/驱动支持状态的警告提示",
          "similarity": 0.6241682767868042
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/hardware_message.c",
          "start_line": 230,
          "end_line": 283,
          "content": [
            "void mark_tech_preview(const char *msg, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *str = NULL;",
            "",
            "\tif (msg)",
            "\t\tstr = msg;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tstr = mod->name;",
            "#endif",
            "",
            "\tpr_warn(\"TECH PREVIEW: %s may not be fully supported.\\n\"",
            "\t\t\"Please review provided documentation for limitations.\\n\",",
            "\t\tstr ?: \"kernel\");",
            "\tadd_taint(TAINT_AUX, LOCKDEP_STILL_OK);",
            "#ifdef CONFIG_MODULES",
            "\tif (mod)",
            "\t\tmod->taints |= (1U << TAINT_AUX);",
            "#endif",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_partner_supported(const char *msg, const char *partner,",
            "\t\t\t    struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *str = NULL;",
            "",
            "\tif (msg)",
            "\t\tstr = msg;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tstr = mod->name;",
            "#endif",
            "",
            "\tpr_warn(\"Warning: %s is a partner (%s) supported and not supported \"",
            "\t\t\"directly by KylinSoft Corporation.\\n\",",
            "\t\tstr ?: \"Kernel\", partner ?: \"Unknown\");",
            "\tadd_taint(TAINT_PARTNER_SUPPORTED, LOCKDEP_STILL_OK);",
            "#ifdef CONFIG_MODULES",
            "\tif (mod)",
            "\t\tmod->taints |= (1U << TAINT_PARTNER_SUPPORTED);",
            "#endif",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_partner_supported_module(const char *partner, struct module *mod)",
            "{",
            "#if defined(CONFIG_KYLIN_DIFFERENCES) && defined(CONFIG_MODULES)",
            "\tif (!mod)",
            "\t\treturn;",
            "",
            "\tmark_partner_supported(NULL, partner, mod);",
            "#endif",
            "}"
          ],
          "function_name": "mark_tech_preview, mark_partner_supported, mark_partner_supported_module",
          "description": "实现了与合作伙伴支持相关联的标记函数，通过添加特定污点标识和模块状态修改，核心功能是标注技术预览特性或第三方合作组件的非官方支持状态",
          "similarity": 0.5142613649368286
        }
      ]
    },
    {
      "source_file": "mm/backing-dev.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:40:32\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `backing-dev.c`\n\n---\n\n# backing-dev.c 技术文档\n\n## 1. 文件概述\n\n`backing-dev.c` 是 Linux 内核中实现 **Backing Device Information（BDI）** 子系统的核心文件。该子系统用于管理块设备或伪设备的写回（writeback）行为、脏页限制、预读策略等 I/O 相关属性。它为每个具有写回能力的设备（如磁盘、tmpfs、网络文件系统等）提供一个 `struct backing_dev_info` 实例，用于跟踪和控制其脏数据的生成与刷写行为，并与全局及 cgroup 级别的脏页限制机制协同工作。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct backing_dev_info`：表示一个后备设备的信息，包含写回控制参数、统计信息、关联的 `bdi_writeback` 实例等。\n- `struct bdi_writeback`（定义在其他文件）：每个 BDI 可关联一个或多个写回任务（在启用 cgroup writeback 时支持多实例）。\n- `noop_backing_dev_info`：一个特殊的全局 BDI 实例，用于不支持写回的设备（如 RAM-based filesystems），其行为为空操作。\n\n### 全局变量与锁\n- `bdi_lock`：自旋锁，保护 `bdi_tree`（红黑树）和 `bdi_list`（链表）的更新操作。\n- `bdi_tree`：以 BDI ID 为键的红黑树，用于快速查找 BDI。\n- `bdi_list`：所有已注册 BDI 的双向链表（RCU 安全读取）。\n- `bdi_wq`：全局工作队列，用于执行异步写回任务。\n\n### 调试接口（CONFIG_DEBUG_FS）\n- `bdi_debug_stats_show`：输出指定 BDI 的全局统计信息（脏页数、阈值、带宽等）。\n- `cgwb_debug_stats_show`：在启用 cgroup writeback 时，输出该 BDI 下所有 cgroup 写回实例的详细统计。\n- `bdi_debug_register/unregister`：在 debugfs 中为 BDI 创建/移除调试目录和文件。\n\n### Sysfs 属性接口\n- `read_ahead_kb`：可读写属性，控制设备的预读窗口大小（单位 KB）。\n- `min_ratio` / `min_ratio_fine`：控制该 BDI 在全局脏页限制中所占的最小比例（用于保证关键设备的写回带宽）。\n\n### 辅助函数\n- `bdi_collect_stats`：聚合 BDI 下所有写回实例（或单个实例）的脏页和 I/O 统计。\n- `collect_wb_stats`：收集单个 `bdi_writeback` 实例的 inode 队列状态和计数器。\n\n## 3. 关键实现\n\n### BDI 注册与管理\n- 所有 BDI 实例通过 `bdi_lock` 保护，插入到全局 `bdi_tree` 和 `bdi_list` 中，支持高效查找和遍历。\n- 使用 RCU 机制允许在无锁情况下遍历 `bdi_list`，提高并发性能。\n\n### 写回任务调度\n- 所有异步写回任务（如 balance_dirty_pages 触发的回写）统一提交到全局工作队列 `bdi_wq`，避免为每个设备创建独立内核线程，节省资源。\n\n### 调试信息聚合\n- 在 `CONFIG_CGROUP_WRITEBACK` 启用时，一个 BDI 可能对应多个 `bdi_writeback` 实例（每个 memcg 一个）。调试接口会遍历所有实例并汇总或分别显示其状态。\n- 统计信息包括：\n  - 各 inode 队列长度（`b_dirty`, `b_io`, `b_more_io`, `b_dirty_time`）\n  - 脏页计数器（`WB_DIRTIED`, `WB_WRITTEN`, `WB_WRITEBACK`, `WB_RECLAIMABLE`）\n  - 动态计算的写回阈值（`wb_thresh`）\n\n### 预读与比例控制\n- `read_ahead_kb` 属性通过 sysfs 暴露，用户空间可动态调整预读大小，内核将其转换为页数存储于 `bdi->ra_pages`。\n- `min_ratio` 控制该设备在全局 dirty limit 中的最低保障比例，防止低速设备被高速设备饿死。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/writeback.h>`：写回机制核心接口\n  - `<linux/backing-dev.h>`：BDI 数据结构定义\n  - `<linux/blkdev.h>`、`<linux/fs.h>`：块设备和 VFS 层集成\n  - `<linux/pagemap.h>`、`<linux/mm.h>`：内存管理与页缓存交互\n- **可选依赖**：\n  - `CONFIG_CGROUP_WRITEBACK`：启用基于 cgroup 的写回隔离\n  - `CONFIG_DEBUG_FS`：提供运行时调试信息\n  - `CONFIG_BLK_CGROUP`：与块层 cgroup 集成\n- **内部依赖**：`internal.h`（内核内部 writeback 实现头文件）\n\n## 5. 使用场景\n\n- **块设备驱动**：如 ext4、xfs 等文件系统在挂载时为其超级块分配 BDI，用于控制该文件系统的脏页行为。\n- **伪文件系统**：如 tmpfs、ramfs 使用 `noop_backing_dev_info` 表示无需写回。\n- **网络文件系统**：NFS、CIFS 等使用 BDI 控制客户端缓存的写回策略。\n- **内存回收**：当系统内存紧张时，`balance_dirty_pages()` 依据 BDI 的阈值和状态触发写回。\n- **cgroup I/O 控制**：在启用 writeback cgroup 时，每个 memcg 对同一设备拥有独立的 `bdi_writeback`，实现 per-cgroup 的脏页限制。\n- **性能调优与诊断**：通过 sysfs 调整 `read_ahead_kb` 或 `min_ratio`；通过 debugfs 查看实时写回状态，辅助排查 I/O 性能问题。",
      "similarity": 0.6208943128585815,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "mm/backing-dev.c",
          "start_line": 449,
          "end_line": 549,
          "content": [
            "static ssize_t strict_limit_show(struct device *dev,",
            "\t\tstruct device_attribute *attr, char *buf)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "",
            "\treturn sysfs_emit(buf, \"%d\\n\",",
            "\t\t\t!!(bdi->capabilities & BDI_CAP_STRICTLIMIT));",
            "}",
            "static __init int bdi_class_init(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = class_register(&bdi_class);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tbdi_debug_init();",
            "",
            "\treturn 0;",
            "}",
            "static int __init default_bdi_init(void)",
            "{",
            "\tbdi_wq = alloc_workqueue(\"writeback\", WQ_MEM_RECLAIM | WQ_UNBOUND |",
            "\t\t\t\t WQ_SYSFS, 0);",
            "\tif (!bdi_wq)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static void wb_update_bandwidth_workfn(struct work_struct *work)",
            "{",
            "\tstruct bdi_writeback *wb = container_of(to_delayed_work(work),",
            "\t\t\t\t\t\tstruct bdi_writeback, bw_dwork);",
            "",
            "\twb_update_bandwidth(wb);",
            "}",
            "static int wb_init(struct bdi_writeback *wb, struct backing_dev_info *bdi,",
            "\t\t   gfp_t gfp)",
            "{",
            "\tint i, err;",
            "",
            "\tmemset(wb, 0, sizeof(*wb));",
            "",
            "\twb->bdi = bdi;",
            "\twb->last_old_flush = jiffies;",
            "\tINIT_LIST_HEAD(&wb->b_dirty);",
            "\tINIT_LIST_HEAD(&wb->b_io);",
            "\tINIT_LIST_HEAD(&wb->b_more_io);",
            "\tINIT_LIST_HEAD(&wb->b_dirty_time);",
            "\tspin_lock_init(&wb->list_lock);",
            "",
            "\tatomic_set(&wb->writeback_inodes, 0);",
            "\twb->bw_time_stamp = jiffies;",
            "\twb->balanced_dirty_ratelimit = INIT_BW;",
            "\twb->dirty_ratelimit = INIT_BW;",
            "\twb->write_bandwidth = INIT_BW;",
            "\twb->avg_write_bandwidth = INIT_BW;",
            "",
            "\tspin_lock_init(&wb->work_lock);",
            "\tINIT_LIST_HEAD(&wb->work_list);",
            "\tINIT_DELAYED_WORK(&wb->dwork, wb_workfn);",
            "\tINIT_DELAYED_WORK(&wb->bw_dwork, wb_update_bandwidth_workfn);",
            "",
            "\terr = fprop_local_init_percpu(&wb->completions, gfp);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tfor (i = 0; i < NR_WB_STAT_ITEMS; i++) {",
            "\t\terr = percpu_counter_init(&wb->stat[i], 0, gfp);",
            "\t\tif (err)",
            "\t\t\tgoto out_destroy_stat;",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "out_destroy_stat:",
            "\twhile (i--)",
            "\t\tpercpu_counter_destroy(&wb->stat[i]);",
            "\tfprop_local_destroy_percpu(&wb->completions);",
            "\treturn err;",
            "}",
            "static void wb_shutdown(struct bdi_writeback *wb)",
            "{",
            "\t/* Make sure nobody queues further work */",
            "\tspin_lock_irq(&wb->work_lock);",
            "\tif (!test_and_clear_bit(WB_registered, &wb->state)) {",
            "\t\tspin_unlock_irq(&wb->work_lock);",
            "\t\treturn;",
            "\t}",
            "\tspin_unlock_irq(&wb->work_lock);",
            "",
            "\tcgwb_remove_from_bdi_list(wb);",
            "\t/*",
            "\t * Drain work list and shutdown the delayed_work.  !WB_registered",
            "\t * tells wb_workfn() that @wb is dying and its work_list needs to",
            "\t * be drained no matter what.",
            "\t */",
            "\tmod_delayed_work(bdi_wq, &wb->dwork, 0);",
            "\tflush_delayed_work(&wb->dwork);",
            "\tWARN_ON(!list_empty(&wb->work_list));",
            "\tflush_delayed_work(&wb->bw_dwork);",
            "}"
          ],
          "function_name": "strict_limit_show, bdi_class_init, default_bdi_init, wb_update_bandwidth_workfn, wb_init, wb_shutdown",
          "description": "实现BDS类初始化、默认BDS创建、写回结构体初始化与销毁逻辑，包含工作队列管理、延迟任务调度及资源清理流程。",
          "similarity": 0.5342233180999756
        },
        {
          "chunk_id": 6,
          "file_path": "mm/backing-dev.c",
          "start_line": 843,
          "end_line": 946,
          "content": [
            "static int cgwb_bdi_init(struct backing_dev_info *bdi)",
            "{",
            "\tint ret;",
            "",
            "\tINIT_RADIX_TREE(&bdi->cgwb_tree, GFP_ATOMIC);",
            "\tmutex_init(&bdi->cgwb_release_mutex);",
            "\tinit_rwsem(&bdi->wb_switch_rwsem);",
            "",
            "\tret = wb_init(&bdi->wb, bdi, GFP_KERNEL);",
            "\tif (!ret) {",
            "\t\tbdi->wb.memcg_css = &root_mem_cgroup->css;",
            "\t\tbdi->wb.blkcg_css = blkcg_root_css;",
            "\t}",
            "\treturn ret;",
            "}",
            "static void cgwb_bdi_unregister(struct backing_dev_info *bdi)",
            "{",
            "\tstruct radix_tree_iter iter;",
            "\tvoid **slot;",
            "\tstruct bdi_writeback *wb;",
            "",
            "\tWARN_ON(test_bit(WB_registered, &bdi->wb.state));",
            "",
            "\tspin_lock_irq(&cgwb_lock);",
            "\tradix_tree_for_each_slot(slot, &bdi->cgwb_tree, &iter, 0)",
            "\t\tcgwb_kill(*slot);",
            "\tspin_unlock_irq(&cgwb_lock);",
            "",
            "\tmutex_lock(&bdi->cgwb_release_mutex);",
            "\tspin_lock_irq(&cgwb_lock);",
            "\twhile (!list_empty(&bdi->wb_list)) {",
            "\t\twb = list_first_entry(&bdi->wb_list, struct bdi_writeback,",
            "\t\t\t\t      bdi_node);",
            "\t\tspin_unlock_irq(&cgwb_lock);",
            "\t\twb_shutdown(wb);",
            "\t\tspin_lock_irq(&cgwb_lock);",
            "\t}",
            "\tspin_unlock_irq(&cgwb_lock);",
            "\tmutex_unlock(&bdi->cgwb_release_mutex);",
            "}",
            "static void cleanup_offline_cgwbs_workfn(struct work_struct *work)",
            "{",
            "\tstruct bdi_writeback *wb;",
            "\tLIST_HEAD(processed);",
            "",
            "\tspin_lock_irq(&cgwb_lock);",
            "",
            "\twhile (!list_empty(&offline_cgwbs)) {",
            "\t\twb = list_first_entry(&offline_cgwbs, struct bdi_writeback,",
            "\t\t\t\t      offline_node);",
            "\t\tlist_move(&wb->offline_node, &processed);",
            "",
            "\t\t/*",
            "\t\t * If wb is dirty, cleaning up the writeback by switching",
            "\t\t * attached inodes will result in an effective removal of any",
            "\t\t * bandwidth restrictions, which isn't the goal.  Instead,",
            "\t\t * it can be postponed until the next time, when all io",
            "\t\t * will be likely completed.  If in the meantime some inodes",
            "\t\t * will get re-dirtied, they should be eventually switched to",
            "\t\t * a new cgwb.",
            "\t\t */",
            "\t\tif (wb_has_dirty_io(wb))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (!wb_tryget(wb))",
            "\t\t\tcontinue;",
            "",
            "\t\tspin_unlock_irq(&cgwb_lock);",
            "\t\twhile (cleanup_offline_cgwb(wb))",
            "\t\t\tcond_resched();",
            "\t\tspin_lock_irq(&cgwb_lock);",
            "",
            "\t\twb_put(wb);",
            "\t}",
            "",
            "\tif (!list_empty(&processed))",
            "\t\tlist_splice_tail(&processed, &offline_cgwbs);",
            "",
            "\tspin_unlock_irq(&cgwb_lock);",
            "}",
            "void wb_memcg_offline(struct mem_cgroup *memcg)",
            "{",
            "\tstruct list_head *memcg_cgwb_list = &memcg->cgwb_list;",
            "\tstruct bdi_writeback *wb, *next;",
            "",
            "\tspin_lock_irq(&cgwb_lock);",
            "\tlist_for_each_entry_safe(wb, next, memcg_cgwb_list, memcg_node)",
            "\t\tcgwb_kill(wb);",
            "\tmemcg_cgwb_list->next = NULL;\t/* prevent new wb's */",
            "\tspin_unlock_irq(&cgwb_lock);",
            "",
            "\tqueue_work(system_unbound_wq, &cleanup_offline_cgwbs_work);",
            "}",
            "void wb_blkcg_offline(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct bdi_writeback *wb, *next;",
            "\tstruct list_head *list = blkcg_get_cgwb_list(css);",
            "",
            "\tspin_lock_irq(&cgwb_lock);",
            "\tlist_for_each_entry_safe(wb, next, list, blkcg_node)",
            "\t\tcgwb_kill(wb);",
            "\tlist->next = NULL;\t/* prevent new wb's */",
            "\tspin_unlock_irq(&cgwb_lock);",
            "}"
          ],
          "function_name": "cgwb_bdi_init, cgwb_bdi_unregister, cleanup_offline_cgwbs_workfn, wb_memcg_offline, wb_blkcg_offline",
          "description": "该代码块负责bdi_writeback的初始化与注销操作，包含cgwb_bdi_init初始化radix树和互斥锁，cgwb_bdi_unregister遍历并终止所有关联实例，cleanup_offline_cgwbs_workfn清理离线writeback，wb_memcg_offline和wb_blkcg_offline处理内存组/块组离线时的资源回收。",
          "similarity": 0.5151132345199585
        },
        {
          "chunk_id": 2,
          "file_path": "mm/backing-dev.c",
          "start_line": 193,
          "end_line": 303,
          "content": [
            "static int cgwb_debug_stats_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct backing_dev_info *bdi = m->private;",
            "\tunsigned long background_thresh;",
            "\tunsigned long dirty_thresh;",
            "\tstruct bdi_writeback *wb;",
            "",
            "\tglobal_dirty_limits(&background_thresh, &dirty_thresh);",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(wb, &bdi->wb_list, bdi_node) {",
            "\t\tstruct wb_stats stats = { .dirty_thresh = dirty_thresh };",
            "",
            "\t\tif (!wb_tryget(wb))",
            "\t\t\tcontinue;",
            "",
            "\t\tcollect_wb_stats(&stats, wb);",
            "",
            "\t\t/*",
            "\t\t * Calculate thresh of wb in writeback cgroup which is min of",
            "\t\t * thresh in global domain and thresh in cgroup domain. Drop",
            "\t\t * rcu lock because cgwb_calc_thresh may sleep in",
            "\t\t * cgroup_rstat_flush. We can do so here because we have a ref.",
            "\t\t */",
            "\t\tif (mem_cgroup_wb_domain(wb)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tstats.wb_thresh = min(stats.wb_thresh, cgwb_calc_thresh(wb));",
            "\t\t\trcu_read_lock();",
            "\t\t}",
            "",
            "\t\twb_stats_show(m, wb, &stats);",
            "",
            "\t\twb_put(wb);",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn 0;",
            "}",
            "static void bdi_debug_register(struct backing_dev_info *bdi, const char *name)",
            "{",
            "\tbdi->debug_dir = debugfs_create_dir(name, bdi_debug_root);",
            "",
            "\tdebugfs_create_file(\"stats\", 0444, bdi->debug_dir, bdi,",
            "\t\t\t    &bdi_debug_stats_fops);",
            "\tdebugfs_create_file(\"wb_stats\", 0444, bdi->debug_dir, bdi,",
            "\t\t\t    &cgwb_debug_stats_fops);",
            "}",
            "static void bdi_debug_unregister(struct backing_dev_info *bdi)",
            "{",
            "\tdebugfs_remove_recursive(bdi->debug_dir);",
            "}",
            "static inline void bdi_debug_init(void)",
            "{",
            "}",
            "static inline void bdi_debug_register(struct backing_dev_info *bdi,",
            "\t\t\t\t      const char *name)",
            "{",
            "}",
            "static inline void bdi_debug_unregister(struct backing_dev_info *bdi)",
            "{",
            "}",
            "static ssize_t read_ahead_kb_store(struct device *dev,",
            "\t\t\t\t  struct device_attribute *attr,",
            "\t\t\t\t  const char *buf, size_t count)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "\tunsigned long read_ahead_kb;",
            "\tssize_t ret;",
            "",
            "\tret = kstrtoul(buf, 10, &read_ahead_kb);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tbdi->ra_pages = read_ahead_kb >> (PAGE_SHIFT - 10);",
            "",
            "\treturn count;",
            "}",
            "static ssize_t min_ratio_store(struct device *dev,",
            "\t\tstruct device_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "\tunsigned int ratio;",
            "\tssize_t ret;",
            "",
            "\tret = kstrtouint(buf, 10, &ratio);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tret = bdi_set_min_ratio(bdi, ratio);",
            "\tif (!ret)",
            "\t\tret = count;",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t min_ratio_fine_store(struct device *dev,",
            "\t\tstruct device_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "\tunsigned int ratio;",
            "\tssize_t ret;",
            "",
            "\tret = kstrtouint(buf, 10, &ratio);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tret = bdi_set_min_ratio_no_scale(bdi, ratio);",
            "\tif (!ret)",
            "\t\tret = count;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "cgwb_debug_stats_show, bdi_debug_register, bdi_debug_unregister, bdi_debug_init, bdi_debug_register, bdi_debug_unregister, read_ahead_kb_store, min_ratio_store, min_ratio_fine_store",
          "description": "实现debugfs注册/注销接口，定义读Ahead参数存储函数，通过sysfs接口暴露读Ahead_kb等参数配置，支持动态修改读Ahead页面数。",
          "similarity": 0.5121243000030518
        },
        {
          "chunk_id": 7,
          "file_path": "mm/backing-dev.c",
          "start_line": 971,
          "end_line": 1076,
          "content": [
            "static void cgwb_bdi_register(struct backing_dev_info *bdi)",
            "{",
            "\tspin_lock_irq(&cgwb_lock);",
            "\tlist_add_tail_rcu(&bdi->wb.bdi_node, &bdi->wb_list);",
            "\tspin_unlock_irq(&cgwb_lock);",
            "}",
            "static int __init cgwb_init(void)",
            "{",
            "\t/*",
            "\t * There can be many concurrent release work items overwhelming",
            "\t * system_wq.  Put them in a separate wq and limit concurrency.",
            "\t * There's no point in executing many of these in parallel.",
            "\t */",
            "\tcgwb_release_wq = alloc_workqueue(\"cgwb_release\", 0, 1);",
            "\tif (!cgwb_release_wq)",
            "\t\treturn -ENOMEM;",
            "",
            "\treturn 0;",
            "}",
            "static int cgwb_bdi_init(struct backing_dev_info *bdi)",
            "{",
            "\treturn wb_init(&bdi->wb, bdi, GFP_KERNEL);",
            "}",
            "static void cgwb_bdi_unregister(struct backing_dev_info *bdi) { }",
            "static void cgwb_bdi_register(struct backing_dev_info *bdi)",
            "{",
            "\tlist_add_tail_rcu(&bdi->wb.bdi_node, &bdi->wb_list);",
            "}",
            "static void cgwb_remove_from_bdi_list(struct bdi_writeback *wb)",
            "{",
            "\tlist_del_rcu(&wb->bdi_node);",
            "}",
            "int bdi_init(struct backing_dev_info *bdi)",
            "{",
            "\tbdi->dev = NULL;",
            "",
            "\tkref_init(&bdi->refcnt);",
            "\tbdi->min_ratio = 0;",
            "\tbdi->max_ratio = 100 * BDI_RATIO_SCALE;",
            "\tbdi->max_prop_frac = FPROP_FRAC_BASE;",
            "\tINIT_LIST_HEAD(&bdi->bdi_list);",
            "\tINIT_LIST_HEAD(&bdi->wb_list);",
            "\tinit_waitqueue_head(&bdi->wb_waitq);",
            "\tbdi->last_bdp_sleep = jiffies;",
            "",
            "\treturn cgwb_bdi_init(bdi);",
            "}",
            "int bdi_register_va(struct backing_dev_info *bdi, const char *fmt, va_list args)",
            "{",
            "\tstruct device *dev;",
            "\tstruct rb_node *parent, **p;",
            "",
            "\tif (bdi->dev)\t/* The driver needs to use separate queues per device */",
            "\t\treturn 0;",
            "",
            "\tvsnprintf(bdi->dev_name, sizeof(bdi->dev_name), fmt, args);",
            "\tdev = device_create(&bdi_class, NULL, MKDEV(0, 0), bdi, bdi->dev_name);",
            "\tif (IS_ERR(dev))",
            "\t\treturn PTR_ERR(dev);",
            "",
            "\tcgwb_bdi_register(bdi);",
            "\tbdi->dev = dev;",
            "",
            "\tbdi_debug_register(bdi, dev_name(dev));",
            "\tset_bit(WB_registered, &bdi->wb.state);",
            "",
            "\tspin_lock_bh(&bdi_lock);",
            "",
            "\tbdi->id = ++bdi_id_cursor;",
            "",
            "\tp = bdi_lookup_rb_node(bdi->id, &parent);",
            "\trb_link_node(&bdi->rb_node, parent, p);",
            "\trb_insert_color(&bdi->rb_node, &bdi_tree);",
            "",
            "\tlist_add_tail_rcu(&bdi->bdi_list, &bdi_list);",
            "",
            "\tspin_unlock_bh(&bdi_lock);",
            "",
            "\ttrace_writeback_bdi_register(bdi);",
            "\treturn 0;",
            "}",
            "int bdi_register(struct backing_dev_info *bdi, const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "\tint ret;",
            "",
            "\tva_start(args, fmt);",
            "\tret = bdi_register_va(bdi, fmt, args);",
            "\tva_end(args);",
            "\treturn ret;",
            "}",
            "void bdi_set_owner(struct backing_dev_info *bdi, struct device *owner)",
            "{",
            "\tWARN_ON_ONCE(bdi->owner);",
            "\tbdi->owner = owner;",
            "\tget_device(owner);",
            "}",
            "static void bdi_remove_from_list(struct backing_dev_info *bdi)",
            "{",
            "\tspin_lock_bh(&bdi_lock);",
            "\trb_erase(&bdi->rb_node, &bdi_tree);",
            "\tlist_del_rcu(&bdi->bdi_list);",
            "\tspin_unlock_bh(&bdi_lock);",
            "",
            "\tsynchronize_rcu_expedited();",
            "}"
          ],
          "function_name": "cgwb_bdi_register, cgwb_init, cgwb_bdi_init, cgwb_bdi_unregister, cgwb_bdi_register, cgwb_remove_from_bdi_list, bdi_init, bdi_register_va, bdi_register, bdi_set_owner, bdi_remove_from_list",
          "description": "该代码块实现bdi的注册与初始化流程，包含cgwb_bdi_register将bdi添加到全局列表，cgwb_init创建专用工作队列，bdi_init初始化基础结构，bdi_register_va注册设备并设置标识，bdi_register封装参数传递接口，bdi_set_owner设置拥有者设备，bdi_remove_from_list从RB树和链表中删除bdi。",
          "similarity": 0.5071247220039368
        },
        {
          "chunk_id": 3,
          "file_path": "mm/backing-dev.c",
          "start_line": 327,
          "end_line": 435,
          "content": [
            "static ssize_t max_ratio_store(struct device *dev,",
            "\t\tstruct device_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "\tunsigned int ratio;",
            "\tssize_t ret;",
            "",
            "\tret = kstrtouint(buf, 10, &ratio);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tret = bdi_set_max_ratio(bdi, ratio);",
            "\tif (!ret)",
            "\t\tret = count;",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t max_ratio_fine_store(struct device *dev,",
            "\t\tstruct device_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "\tunsigned int ratio;",
            "\tssize_t ret;",
            "",
            "\tret = kstrtouint(buf, 10, &ratio);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tret = bdi_set_max_ratio_no_scale(bdi, ratio);",
            "\tif (!ret)",
            "\t\tret = count;",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t min_bytes_show(struct device *dev,",
            "\t\t\t      struct device_attribute *attr,",
            "\t\t\t      char *buf)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "",
            "\treturn sysfs_emit(buf, \"%llu\\n\", bdi_get_min_bytes(bdi));",
            "}",
            "static ssize_t min_bytes_store(struct device *dev,",
            "\t\tstruct device_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "\tu64 bytes;",
            "\tssize_t ret;",
            "",
            "\tret = kstrtoull(buf, 10, &bytes);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tret = bdi_set_min_bytes(bdi, bytes);",
            "\tif (!ret)",
            "\t\tret = count;",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t max_bytes_show(struct device *dev,",
            "\t\t\t      struct device_attribute *attr,",
            "\t\t\t      char *buf)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "",
            "\treturn sysfs_emit(buf, \"%llu\\n\", bdi_get_max_bytes(bdi));",
            "}",
            "static ssize_t max_bytes_store(struct device *dev,",
            "\t\tstruct device_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "\tu64 bytes;",
            "\tssize_t ret;",
            "",
            "\tret = kstrtoull(buf, 10, &bytes);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tret = bdi_set_max_bytes(bdi, bytes);",
            "\tif (!ret)",
            "\t\tret = count;",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t stable_pages_required_show(struct device *dev,",
            "\t\t\t\t\t  struct device_attribute *attr,",
            "\t\t\t\t\t  char *buf)",
            "{",
            "\tdev_warn_once(dev,",
            "\t\t\"the stable_pages_required attribute has been removed. Use the stable_writes queue attribute instead.\\n\");",
            "\treturn sysfs_emit(buf, \"%d\\n\", 0);",
            "}",
            "static ssize_t strict_limit_store(struct device *dev,",
            "\t\tstruct device_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct backing_dev_info *bdi = dev_get_drvdata(dev);",
            "\tunsigned int strict_limit;",
            "\tssize_t ret;",
            "",
            "\tret = kstrtouint(buf, 10, &strict_limit);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tret = bdi_set_strict_limit(bdi, strict_limit);",
            "\tif (!ret)",
            "\t\tret = count;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "max_ratio_store, max_ratio_fine_store, min_bytes_show, min_bytes_store, max_bytes_show, max_bytes_store, stable_pages_required_show, strict_limit_store",
          "description": "实现内存限制参数(sysfs)的存取控制，提供min/max bytes/ratio等参数的设置接口，用于调节后台回收策略的约束条件。",
          "similarity": 0.5005635619163513
        }
      ]
    },
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.6094101667404175,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.6003803014755249
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.4769033193588257
        }
      ]
    }
  ]
}