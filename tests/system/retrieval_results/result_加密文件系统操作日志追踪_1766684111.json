{
  "query": "加密文件系统操作日志追踪",
  "timestamp": "2025-12-26 01:35:11",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/log.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:15:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\log.c`\n\n---\n\n# bpf/log.c 技术文档\n\n## 1. 文件概述\n\n`bpf/log.c` 是 Linux 内核 BPF（Berkeley Packet Filter）子系统中负责日志记录的核心实现文件。该文件为 BPF 验证器（verifier）提供灵活、高效的日志输出机制，支持将验证过程中的诊断信息输出到用户空间缓冲区或内核日志（`pr_err`）。日志系统支持两种模式：**固定模式**（`BPF_LOG_FIXED`）和**循环缓冲模式**（默认），并能处理大容量日志的截断、回绕和最终整理，确保用户获得连续、有效的验证日志。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`bpf_verifier_log_attr_valid()`**  \n  验证 `bpf_verifier_log` 结构体的属性是否合法，包括用户缓冲区指针与大小的一致性、日志级别有效性等。\n\n- **`bpf_vlog_init()`**  \n  初始化 `bpf_verifier_log` 结构体，设置日志级别、用户缓冲区指针和大小，并进行合法性校验。\n\n- **`bpf_verifier_vlog()`**  \n  核心日志写入函数，接收格式化字符串和可变参数列表，根据日志模式（固定/循环）将内容写入内核临时缓冲区并复制到用户空间，或直接输出到内核日志。\n\n- **`bpf_vlog_reset()`**  \n  重置日志写入位置（用于回溯验证路径时清理无效日志），并更新用户缓冲区对应位置为 `\\0`。\n\n- **`bpf_vlog_finalize()`**  \n  在验证结束时整理日志内容：若使用循环缓冲且发生回绕，则通过三次反转算法将日志内容原地旋转为从缓冲区开头开始的连续字符串。\n\n- **`bpf_vlog_reverse_kbuf()` / `bpf_vlog_reverse_ubuf()`**  \n  辅助函数，分别用于反转内核临时缓冲区和用户空间日志缓冲区的指定区段，支撑 `bpf_vlog_finalize()` 中的原地旋转算法。\n\n### 关键数据结构\n\n- **`struct bpf_verifier_log`**（定义在 `bpf_verifier.h` 中）  \n  包含日志级别（`level`）、用户缓冲区指针（`ubuf`）、缓冲区总大小（`len_total`）、当前写入结束位置（`end_pos`）、循环缓冲起始位置（`start_pos`）、最大日志长度（`len_max`）以及内核临时缓冲区（`kbuf`）等字段。\n\n## 3. 关键实现\n\n### 日志模式\n\n- **固定模式（`BPF_LOG_FIXED`）**：日志从缓冲区开头顺序写入，超出部分被丢弃。适用于需要完整前缀日志的场景。\n- **循环缓冲模式（默认）**：当日志超出缓冲区大小时，覆盖最早写入的内容，始终保持最新的日志。适用于关注最新错误信息的场景。\n\n### 日志写入流程\n\n1. 使用 `vscnprintf` 将格式化日志写入内核临时缓冲区 `kbuf`（大小为 `BPF_VERIFIER_TMP_LOG_SIZE`）。\n2. 若日志级别为 `BPF_LOG_KERNEL`，直接通过 `pr_err` 输出到内核日志。\n3. 否则，根据日志模式：\n   - **固定模式**：计算可写入用户缓冲区的字节数，调用 `copy_to_user`。\n   - **循环模式**：计算写入位置（可能回绕），分一或两个片段调用 `copy_to_user`。\n\n### 日志最终整理（`bpf_vlog_finalize`）\n\n当使用循环缓冲且日志发生回绕（`start_pos != 0`）时，需将日志整理为从缓冲区开头开始的连续字符串。采用**三次反转原地旋转算法**：\n1. 反转整个缓冲区；\n2. 反转前 `sublen` 字节（原尾部）；\n3. 反转后 `len_total - sublen` 字节（原头部）。  \n该算法避免了大内存分配，仅使用固定大小的内核临时缓冲区 `kbuf` 分块处理用户空间内存。\n\n### 安全与健壮性\n\n- 所有 `copy_to_user`/`copy_from_user` 操作均检查返回值，失败时置空 `ubuf` 指针以禁用后续写入。\n- 对日志长度进行溢出检查（`len_total > UINT_MAX >> 2`）。\n- 使用 `WARN_ON_ONCE` 检测非法重置位置。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<uapi/linux/btf.h>`：BTF（BPF Type Format）相关定义。\n  - `<linux/bpf.h>`：BPF 核心数据结构和常量（如 `BPF_LOG_MASK`、`BPF_LOG_KERNEL`、`BPF_LOG_FIXED`）。\n  - `<linux/bpf_verifier.h>`：`struct bpf_verifier_log` 定义及辅助宏（如 `bpf_verifier_log_needed`）。\n  - `<linux/math64.h>`：提供 `div_u64_rem` 等 64 位除法函数。\n- **内核子系统**：\n  - **BPF 验证器**：作为验证器的输出后端，由 `bpf_verifier.c` 调用。\n  - **用户空间交互**：通过 `copy_to_user`/`copy_from_user` 与用户态 BPF 加载程序（如 `libbpf`）通信。\n\n## 5. 使用场景\n\n- **BPF 程序加载验证**：当用户通过 `bpf(BPF_PROG_LOAD, ...)` 系统调用加载 BPF 程序时，内核验证器在检查程序安全性过程中调用本文件的日志函数，将详细错误或警告信息写入用户提供的日志缓冲区。\n- **调试与诊断**：开发者通过设置 `log_level` 和提供足够大的 `log_buf`，获取验证失败的具体原因（如无效指针访问、未初始化寄存器等）。\n- **内核日志输出**：当 `log_level` 设为 `BPF_LOG_KERNEL` 时，日志直接输出到内核日志（`dmesg`），用于内核开发者调试 BPF 验证器本身。\n- **资源受限环境**：循环缓冲模式允许在有限缓冲区大小下捕获最新的验证日志，适用于嵌入式或内存受限系统。",
      "similarity": 0.6155122518539429,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/log.c",
          "start_line": 303,
          "end_line": 462,
          "content": [
            "__printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,",
            "\t\t\t\t\t   const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(&env->log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(2, 3) void bpf_log(struct bpf_verifier_log *log,",
            "\t\t\t    const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(3, 4) void verbose_linfo(struct bpf_verifier_env *env,",
            "\t\t\t\t  u32 insn_off,",
            "\t\t\t\t  const char *prefix_fmt, ...)",
            "{",
            "\tconst struct bpf_line_info *linfo;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tlinfo = find_linfo(env, insn_off);",
            "\tif (!linfo || linfo == env->prev_linfo)",
            "\t\treturn;",
            "",
            "\tif (prefix_fmt) {",
            "\t\tva_list args;",
            "",
            "\t\tva_start(args, prefix_fmt);",
            "\t\tbpf_verifier_vlog(&env->log, prefix_fmt, args);",
            "\t\tva_end(args);",
            "\t}",
            "",
            "\tverbose(env, \"%s\\n\",",
            "\t\tltrim(btf_name_by_offset(env->prog->aux->btf,",
            "\t\t\t\t\t linfo->line_off)));",
            "",
            "\tenv->prev_linfo = linfo;",
            "}",
            "static void print_liveness(struct bpf_verifier_env *env,",
            "\t\t\t   enum bpf_reg_liveness live)",
            "{",
            "\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))",
            "\t    verbose(env, \"_\");",
            "\tif (live & REG_LIVE_READ)",
            "\t\tverbose(env, \"r\");",
            "\tif (live & REG_LIVE_WRITTEN)",
            "\t\tverbose(env, \"w\");",
            "\tif (live & REG_LIVE_DONE)",
            "\t\tverbose(env, \"D\");",
            "}",
            "static bool is_unum_decimal(u64 num)",
            "{",
            "\treturn num <= UNUM_MAX_DECIMAL;",
            "}",
            "static bool is_snum_decimal(s64 num)",
            "{",
            "\treturn num >= SNUM_MIN_DECIMAL && num <= SNUM_MAX_DECIMAL;",
            "}",
            "static void verbose_unum(struct bpf_verifier_env *env, u64 num)",
            "{",
            "\tif (is_unum_decimal(num))",
            "\t\tverbose(env, \"%llu\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "static void verbose_snum(struct bpf_verifier_env *env, s64 num)",
            "{",
            "\tif (is_snum_decimal(num))",
            "\t\tverbose(env, \"%lld\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "int tnum_strn(char *str, size_t size, struct tnum a)",
            "{",
            "\t/* print as a constant, if tnum is fully known */",
            "\tif (a.mask == 0) {",
            "\t\tif (is_unum_decimal(a.value))",
            "\t\t\treturn snprintf(str, size, \"%llu\", a.value);",
            "\t\telse",
            "\t\t\treturn snprintf(str, size, \"%#llx\", a.value);",
            "\t}",
            "\treturn snprintf(str, size, \"(%#llx; %#llx)\", a.value, a.mask);",
            "}",
            "static void print_scalar_ranges(struct bpf_verifier_env *env,",
            "\t\t\t\tconst struct bpf_reg_state *reg,",
            "\t\t\t\tconst char **sep)",
            "{",
            "\t/* For signed ranges, we want to unify 64-bit and 32-bit values in the",
            "\t * output as much as possible, but there is a bit of a complication.",
            "\t * If we choose to print values as decimals, this is natural to do,",
            "\t * because negative 64-bit and 32-bit values >= -S32_MIN have the same",
            "\t * representation due to sign extension. But if we choose to print",
            "\t * them in hex format (see is_snum_decimal()), then sign extension is",
            "\t * misleading.",
            "\t * E.g., smin=-2 and smin32=-2 are exactly the same in decimal, but in",
            "\t * hex they will be smin=0xfffffffffffffffe and smin32=0xfffffffe, two",
            "\t * very different numbers.",
            "\t * So we avoid sign extension if we choose to print values in hex.",
            "\t */",
            "\tstruct {",
            "\t\tconst char *name;",
            "\t\tu64 val;",
            "\t\tbool omit;",
            "\t} minmaxs[] = {",
            "\t\t{\"smin\",   reg->smin_value,         reg->smin_value == S64_MIN},",
            "\t\t{\"smax\",   reg->smax_value,         reg->smax_value == S64_MAX},",
            "\t\t{\"umin\",   reg->umin_value,         reg->umin_value == 0},",
            "\t\t{\"umax\",   reg->umax_value,         reg->umax_value == U64_MAX},",
            "\t\t{\"smin32\",",
            "\t\t is_snum_decimal((s64)reg->s32_min_value)",
            "\t\t\t ? (s64)reg->s32_min_value",
            "\t\t\t : (u32)reg->s32_min_value, reg->s32_min_value == S32_MIN},",
            "\t\t{\"smax32\",",
            "\t\t is_snum_decimal((s64)reg->s32_max_value)",
            "\t\t\t ? (s64)reg->s32_max_value",
            "\t\t\t : (u32)reg->s32_max_value, reg->s32_max_value == S32_MAX},",
            "\t\t{\"umin32\", reg->u32_min_value,      reg->u32_min_value == 0},",
            "\t\t{\"umax32\", reg->u32_max_value,      reg->u32_max_value == U32_MAX},",
            "\t}, *m1, *m2, *mend = &minmaxs[ARRAY_SIZE(minmaxs)];",
            "\tbool neg1, neg2;",
            "",
            "\tfor (m1 = &minmaxs[0]; m1 < mend; m1++) {",
            "\t\tif (m1->omit)",
            "\t\t\tcontinue;",
            "",
            "\t\tneg1 = m1->name[0] == 's' && (s64)m1->val < 0;",
            "",
            "\t\tverbose(env, \"%s%s=\", *sep, m1->name);",
            "\t\t*sep = \",\";",
            "",
            "\t\tfor (m2 = m1 + 2; m2 < mend; m2 += 2) {",
            "\t\t\tif (m2->omit || m2->val != m1->val)",
            "\t\t\t\tcontinue;",
            "\t\t\t/* don't mix negatives with positives */",
            "\t\t\tneg2 = m2->name[0] == 's' && (s64)m2->val < 0;",
            "\t\t\tif (neg2 != neg1)",
            "\t\t\t\tcontinue;",
            "\t\t\tm2->omit = true;",
            "\t\t\tverbose(env, \"%s=\", m2->name);",
            "\t\t}",
            "",
            "\t\tif (m1->name[0] == 's')",
            "\t\t\tverbose_snum(env, m1->val);",
            "\t\telse",
            "\t\t\tverbose_unum(env, m1->val);",
            "\t}",
            "}"
          ],
          "function_name": "bpf_verifier_log_write, bpf_log, verbose_linfo, print_liveness, is_unum_decimal, is_snum_decimal, verbose_unum, verbose_snum, tnum_strn, print_scalar_ranges",
          "description": "包含日志格式化辅助函数，支持指令信息打印、寄存器存活状态显示及数值范围解析等多样化日志输出需求。",
          "similarity": 0.6169647574424744
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/log.c",
          "start_line": 148,
          "end_line": 294,
          "content": [
            "void bpf_vlog_reset(struct bpf_verifier_log *log, u64 new_pos)",
            "{",
            "\tchar zero = 0;",
            "\tu32 pos;",
            "",
            "\tif (WARN_ON_ONCE(new_pos > log->end_pos))",
            "\t\treturn;",
            "",
            "\tif (!bpf_verifier_log_needed(log) || log->level == BPF_LOG_KERNEL)",
            "\t\treturn;",
            "",
            "\t/* if position to which we reset is beyond current log window,",
            "\t * then we didn't preserve any useful content and should adjust",
            "\t * start_pos to end up with an empty log (start_pos == end_pos)",
            "\t */",
            "\tlog->end_pos = new_pos;",
            "\tif (log->end_pos < log->start_pos)",
            "\t\tlog->start_pos = log->end_pos;",
            "",
            "\tif (!log->ubuf)",
            "\t\treturn;",
            "",
            "\tif (log->level & BPF_LOG_FIXED)",
            "\t\tpos = log->end_pos + 1;",
            "\telse",
            "\t\tdiv_u64_rem(new_pos, log->len_total, &pos);",
            "",
            "\tif (pos < log->len_total && put_user(zero, log->ubuf + pos))",
            "\t\tlog->ubuf = NULL;",
            "}",
            "static void bpf_vlog_reverse_kbuf(char *buf, int len)",
            "{",
            "\tint i, j;",
            "",
            "\tfor (i = 0, j = len - 1; i < j; i++, j--)",
            "\t\tswap(buf[i], buf[j]);",
            "}",
            "static int bpf_vlog_reverse_ubuf(struct bpf_verifier_log *log, int start, int end)",
            "{",
            "\t/* we split log->kbuf into two equal parts for both ends of array */",
            "\tint n = sizeof(log->kbuf) / 2, nn;",
            "\tchar *lbuf = log->kbuf, *rbuf = log->kbuf + n;",
            "",
            "\t/* Read ubuf's section [start, end) two chunks at a time, from left",
            "\t * and right side; within each chunk, swap all the bytes; after that",
            "\t * reverse the order of lbuf and rbuf and write result back to ubuf.",
            "\t * This way we'll end up with swapped contents of specified",
            "\t * [start, end) ubuf segment.",
            "\t */",
            "\twhile (end - start > 1) {",
            "\t\tnn = min(n, (end - start ) / 2);",
            "",
            "\t\tif (copy_from_user(lbuf, log->ubuf + start, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_from_user(rbuf, log->ubuf + end - nn, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbpf_vlog_reverse_kbuf(lbuf, nn);",
            "\t\tbpf_vlog_reverse_kbuf(rbuf, nn);",
            "",
            "\t\t/* we write lbuf to the right end of ubuf, while rbuf to the",
            "\t\t * left one to end up with properly reversed overall ubuf",
            "\t\t */",
            "\t\tif (copy_to_user(log->ubuf + start, rbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_to_user(log->ubuf + end - nn, lbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tstart += nn;",
            "\t\tend -= nn;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int bpf_vlog_finalize(struct bpf_verifier_log *log, u32 *log_size_actual)",
            "{",
            "\tu32 sublen;",
            "\tint err;",
            "",
            "\t*log_size_actual = 0;",
            "\tif (!log || log->level == 0 || log->level == BPF_LOG_KERNEL)",
            "\t\treturn 0;",
            "",
            "\tif (!log->ubuf)",
            "\t\tgoto skip_log_rotate;",
            "\t/* If we never truncated log, there is nothing to move around. */",
            "\tif (log->start_pos == 0)",
            "\t\tgoto skip_log_rotate;",
            "",
            "\t/* Otherwise we need to rotate log contents to make it start from the",
            "\t * buffer beginning and be a continuous zero-terminated string. Note",
            "\t * that if log->start_pos != 0 then we definitely filled up entire log",
            "\t * buffer with no gaps, and we just need to shift buffer contents to",
            "\t * the left by (log->start_pos % log->len_total) bytes.",
            "\t *",
            "\t * Unfortunately, user buffer could be huge and we don't want to",
            "\t * allocate temporary kernel memory of the same size just to shift",
            "\t * contents in a straightforward fashion. Instead, we'll be clever and",
            "\t * do in-place array rotation. This is a leetcode-style problem, which",
            "\t * could be solved by three rotations.",
            "\t *",
            "\t * Let's say we have log buffer that has to be shifted left by 7 bytes",
            "\t * (spaces and vertical bar is just for demonstrative purposes):",
            "\t *   E F G H I J K | A B C D",
            "\t *",
            "\t * First, we reverse entire array:",
            "\t *   D C B A | K J I H G F E",
            "\t *",
            "\t * Then we rotate first 4 bytes (DCBA) and separately last 7 bytes",
            "\t * (KJIHGFE), resulting in a properly rotated array:",
            "\t *   A B C D | E F G H I J K",
            "\t *",
            "\t * We'll utilize log->kbuf to read user memory chunk by chunk, swap",
            "\t * bytes, and write them back. Doing it byte-by-byte would be",
            "\t * unnecessarily inefficient. Altogether we are going to read and",
            "\t * write each byte twice, for total 4 memory copies between kernel and",
            "\t * user space.",
            "\t */",
            "",
            "\t/* length of the chopped off part that will be the beginning;",
            "\t * len(ABCD) in the example above",
            "\t */",
            "\tdiv_u64_rem(log->start_pos, log->len_total, &sublen);",
            "\tsublen = log->len_total - sublen;",
            "",
            "\terr = bpf_vlog_reverse_ubuf(log, 0, log->len_total);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, 0, sublen);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, sublen, log->len_total);",
            "\tif (err)",
            "\t\tlog->ubuf = NULL;",
            "",
            "skip_log_rotate:",
            "\t*log_size_actual = log->len_max;",
            "",
            "\t/* properly initialized log has either both ubuf!=NULL and len_total>0",
            "\t * or ubuf==NULL and len_total==0, so if this condition doesn't hold,",
            "\t * we got a fault somewhere along the way, so report it back",
            "\t */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn -EFAULT;",
            "",
            "\t/* did truncation actually happen? */",
            "\tif (log->ubuf && log->len_max > log->len_total)",
            "\t\treturn -ENOSPC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_vlog_reset, bpf_vlog_reverse_kbuf, bpf_vlog_reverse_ubuf, bpf_vlog_finalize",
          "description": "提供日志重置、缓冲区反转及最终化功能，通过旋转日志缓冲区实现连续日志存储并保证数据完整性。",
          "similarity": 0.596379280090332
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/log.c",
          "start_line": 15,
          "end_line": 143,
          "content": [
            "static bool bpf_verifier_log_attr_valid(const struct bpf_verifier_log *log)",
            "{",
            "\t/* ubuf and len_total should both be specified (or not) together */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn false;",
            "\t/* log buf without log_level is meaningless */",
            "\tif (log->ubuf && log->level == 0)",
            "\t\treturn false;",
            "\tif (log->level & ~BPF_LOG_MASK)",
            "\t\treturn false;",
            "\tif (log->len_total > UINT_MAX >> 2)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "int bpf_vlog_init(struct bpf_verifier_log *log, u32 log_level,",
            "\t\t  char __user *log_buf, u32 log_size)",
            "{",
            "\tlog->level = log_level;",
            "\tlog->ubuf = log_buf;",
            "\tlog->len_total = log_size;",
            "",
            "\t/* log attributes have to be sane */",
            "\tif (!bpf_verifier_log_attr_valid(log))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_vlog_update_len_max(struct bpf_verifier_log *log, u32 add_len)",
            "{",
            "\t/* add_len includes terminal \\0, so no need for +1. */",
            "\tu64 len = log->end_pos + add_len;",
            "",
            "\t/* log->len_max could be larger than our current len due to",
            "\t * bpf_vlog_reset() calls, so we maintain the max of any length at any",
            "\t * previous point",
            "\t */",
            "\tif (len > UINT_MAX)",
            "\t\tlog->len_max = UINT_MAX;",
            "\telse if (len > log->len_max)",
            "\t\tlog->len_max = len;",
            "}",
            "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,",
            "\t\t       va_list args)",
            "{",
            "\tu64 cur_pos;",
            "\tu32 new_n, n;",
            "",
            "\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);",
            "",
            "\tif (log->level == BPF_LOG_KERNEL) {",
            "\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';",
            "",
            "\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tn += 1; /* include terminating zero */",
            "\tbpf_vlog_update_len_max(log, n);",
            "",
            "\tif (log->level & BPF_LOG_FIXED) {",
            "\t\t/* check if we have at least something to put into user buf */",
            "\t\tnew_n = 0;",
            "\t\tif (log->end_pos < log->len_total) {",
            "\t\t\tnew_n = min_t(u32, log->len_total - log->end_pos, n);",
            "\t\t\tlog->kbuf[new_n - 1] = '\\0';",
            "\t\t}",
            "",
            "\t\tcur_pos = log->end_pos;",
            "\t\tlog->end_pos += n - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (log->ubuf && new_n &&",
            "\t\t    copy_to_user(log->ubuf + cur_pos, log->kbuf, new_n))",
            "\t\t\tgoto fail;",
            "\t} else {",
            "\t\tu64 new_end, new_start;",
            "\t\tu32 buf_start, buf_end, new_n;",
            "",
            "\t\tnew_end = log->end_pos + n;",
            "\t\tif (new_end - log->start_pos >= log->len_total)",
            "\t\t\tnew_start = new_end - log->len_total;",
            "\t\telse",
            "\t\t\tnew_start = log->start_pos;",
            "",
            "\t\tlog->start_pos = new_start;",
            "\t\tlog->end_pos = new_end - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (!log->ubuf)",
            "\t\t\treturn;",
            "",
            "\t\tnew_n = min(n, log->len_total);",
            "\t\tcur_pos = new_end - new_n;",
            "\t\tdiv_u64_rem(cur_pos, log->len_total, &buf_start);",
            "\t\tdiv_u64_rem(new_end, log->len_total, &buf_end);",
            "\t\t/* new_end and buf_end are exclusive indices, so if buf_end is",
            "\t\t * exactly zero, then it actually points right to the end of",
            "\t\t * ubuf and there is no wrap around",
            "\t\t */",
            "\t\tif (buf_end == 0)",
            "\t\t\tbuf_end = log->len_total;",
            "",
            "\t\t/* if buf_start > buf_end, we wrapped around;",
            "\t\t * if buf_start == buf_end, then we fill ubuf completely; we",
            "\t\t * can't have buf_start == buf_end to mean that there is",
            "\t\t * nothing to write, because we always write at least",
            "\t\t * something, even if terminal '\\0'",
            "\t\t */",
            "\t\tif (buf_start < buf_end) {",
            "\t\t\t/* message fits within contiguous chunk of ubuf */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t buf_end - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t} else {",
            "\t\t\t/* message wraps around the end of ubuf, copy in two chunks */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t log->len_total - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t\tif (copy_to_user(log->ubuf,",
            "\t\t\t\t\t log->kbuf + n - buf_end,",
            "\t\t\t\t\t buf_end))",
            "\t\t\t\tgoto fail;",
            "\t\t}",
            "\t}",
            "",
            "\treturn;",
            "fail:",
            "\tlog->ubuf = NULL;",
            "}"
          ],
          "function_name": "bpf_verifier_log_attr_valid, bpf_vlog_init, bpf_vlog_update_len_max, bpf_verifier_vlog",
          "description": "实现日志属性校验、初始化、长度更新及日志写入逻辑，负责管理日志缓冲区的有效性和数据写入操作。",
          "similarity": 0.5870729684829712
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/log.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com",
            " * Copyright (c) 2016 Facebook",
            " * Copyright (c) 2018 Covalent IO, Inc. http://covalent.io",
            " */",
            "#include <uapi/linux/btf.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/math64.h>",
            "",
            "#define verbose(env, fmt, args...) bpf_verifier_log_write(env, fmt, ##args)",
            ""
          ],
          "function_name": null,
          "description": "定义了BPF验证器日志相关的头文件和宏，其中`verbose`宏用于向内核日志写入验证器相关信息。",
          "similarity": 0.5358511209487915
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/log.c",
          "start_line": 814,
          "end_line": 830,
          "content": [
            "static inline u32 vlog_alignment(u32 pos)",
            "{",
            "\treturn round_up(max(pos + BPF_LOG_MIN_ALIGNMENT / 2, BPF_LOG_ALIGNMENT),",
            "\t\t\tBPF_LOG_MIN_ALIGNMENT) - pos - 1;",
            "}",
            "void print_insn_state(struct bpf_verifier_env *env, const struct bpf_verifier_state *vstate,",
            "\t\t      u32 frameno)",
            "{",
            "\tif (env->prev_log_pos && env->prev_log_pos == env->log.end_pos) {",
            "\t\t/* remove new line character */",
            "\t\tbpf_vlog_reset(&env->log, env->prev_log_pos - 1);",
            "\t\tverbose(env, \"%*c;\", vlog_alignment(env->prev_insn_print_pos), ' ');",
            "\t} else {",
            "\t\tverbose(env, \"%d:\", env->insn_idx);",
            "\t}",
            "\tprint_verifier_state(env, vstate, frameno, false);",
            "}"
          ],
          "function_name": "vlog_alignment, print_insn_state",
          "description": "该代码片段实现BPF验证日志的格式化输出控制。vlog_alignment函数计算日志记录时所需的对齐空格数量，通过取当前位置到下一个对齐边界的距离实现。print_insn_state函数负责在验证过程中按需输出指令状态信息，通过判断日志位置状态决定是否重置日志并添加对齐符号，但存在依赖未展示的宏定义和print_verifier_state函数，上下文不完整。",
          "similarity": 0.5297403335571289
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_uprobe.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:40:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_uprobe.c`\n\n---\n\n# `trace_uprobe.c` 技术文档\n\n## 1. 文件概述\n\n`trace_uprobe.c` 是 Linux 内核中用于实现基于 **uprobes** 的动态用户空间函数追踪事件的核心模块。该文件将 uprobes 机制与内核的通用追踪子系统（ftrace）集成，允许用户在不修改目标程序的情况下，在用户空间可执行文件的指定偏移地址处动态插入探针（probe），用于采集函数调用、返回值、寄存器状态、栈内容及内存数据等信息。支持普通探针（uprobe）和返回探针（uretprobe）两种模式，并可通过 tracefs 接口进行动态创建、查询和销毁。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct trace_uprobe`**  \n  表示一个 uprobe 追踪事件实例，包含：\n  - `devent`：动态事件基类，用于注册到 `dyn_event` 框架\n  - `consumer`：uprobes 消费者回调（`uprobe_dispatcher` / `uretprobe_dispatcher`）\n  - `path` / `inode` / `filename`：目标可执行文件路径信息\n  - `offset`：在文件中的插入偏移地址\n  - `ref_ctr_offset`：引用计数器偏移（用于 uretprobe）\n  - `tp`：通用追踪探针结构（`trace_probe`），管理参数、过滤器、事件格式等\n\n- **`struct uprobe_trace_entry_head`**  \n  追踪事件记录的头部结构，包含标准 `trace_entry` 和可变长度的虚拟地址数组（用于存储插入地址及返回地址）\n\n- **`trace_uprobe_ops`**  \n  实现 `dyn_event_operations` 接口，提供动态事件的创建、显示、释放、匹配等操作\n\n### 主要函数\n\n- **事件生命周期管理**\n  - `trace_uprobe_create()`：解析用户命令并创建 uprobe 事件\n  - `register_uprobe_event()` / `unregister_uprobe_event()`：注册/注销 uprobe 到 uprobes 子系统\n  - `trace_uprobe_release()`：释放 uprobe 资源\n  - `trace_uprobe_is_busy()`：检查事件是否处于启用状态\n\n- **探针触发回调**\n  - `uprobe_dispatcher()`：普通 uprobe 触发时的处理函数\n  - `uretprobe_dispatcher()`：uretprobe（函数返回探针）触发时的处理函数\n\n- **数据采集与解析**\n  - `process_fetch_insn()`：根据指令码从用户上下文（寄存器、栈、内存等）提取数据\n  - `fetch_store_string()` / `fetch_store_strlen()`：安全读取用户空间字符串\n  - `get_user_stack_nth()`：读取用户栈第 N 个字（考虑栈增长方向）\n  - `translate_user_vaddr()`：将文件偏移转换为运行时虚拟地址\n\n- **辅助函数**\n  - `is_ret_probe()`：判断是否为返回探针\n  - `trace_uprobe_match()`：匹配动态事件查询条件\n  - `for_each_trace_uprobe()`：遍历所有 uprobe 事件的宏\n\n## 3. 关键实现\n\n### 动态事件集成\n通过 `dyn_event` 框架将 uprobe 事件纳入统一管理，支持通过 tracefs 的 `dyn_events` 接口进行动态操作（如 `echo 'p:uprobes/myprobe /bin/bash:0x1234' > /sys/kernel/tracing/dynamic_events`）。\n\n### 用户空间数据安全读取\n所有从用户空间读取数据的操作（如 `copy_from_user`、`strncpy_from_user`）均被封装在 `nokprobe_inline` 函数中，确保在 kprobe/uprobe 上下文中安全执行，避免页面错误。\n\n### 栈方向适配\n通过 `CONFIG_STACK_GROWSUP` 宏判断架构栈增长方向，`adjust_stack_addr()` 动态计算栈偏移，保证跨架构兼容性。\n\n### 字符串处理\n使用“数据位置描述符”（data location descriptor）机制存储变长字符串：\n- `fetch_store_string()` 将字符串拷贝到事件记录缓冲区，并返回 `(长度 << 16) | 偏移` 的 32 位描述符\n- 支持特殊令牌 `FETCH_TOKEN_COMM` 直接读取当前进程名\n\n### 地址翻译\n`translate_user_vaddr()` 利用 `current->utask->vaddr` 中存储的 `uprobe_dispatch_data`，将文件偏移（`code->immediate`）转换为进程实际加载的虚拟地址，用于内存读取。\n\n### 指令驱动的数据提取\n`process_fetch_insn()` 实现基于字节码的灵活数据提取：\n- 支持寄存器（`FETCH_OP_REG`）、栈（`FETCH_OP_STACK`）、返回值（`FETCH_OP_RETVAL`）等上下文源\n- 通过 `process_common_fetch_insn()` 处理通用操作（如立即数、间接寻址）\n- 最终调用 `process_fetch_insn_bottom()` 将值存入目标缓冲区\n\n## 4. 依赖关系\n\n- **核心依赖**\n  - `<linux/uprobes.h>`：uprobes 子系统 API（注册/注销探针、消费者回调）\n  - `\"trace_probe.h\"` / `\"trace_dynevent.h\"`：通用追踪探针框架和动态事件管理\n  - `<linux/filter.h>`：事件过滤支持\n  - `<linux/bpf-cgroup.h>`：BPF 程序附加支持（用于 perf 事件）\n\n- **架构依赖**\n  - `user_stack_pointer()` / `regs_get_register()`：架构相关的寄存器和栈指针访问\n  - `regs_return_value()`：架构相关的函数返回值获取\n\n- **安全与内存**\n  - `<linux/uaccess.h>`：用户空间内存安全访问\n  - `<linux/security.h>`：LSM 安全钩子（未在片段中体现，但通常用于权限检查）\n\n## 5. 使用场景\n\n- **动态用户空间函数追踪**  \n  开发者或系统管理员可通过 tracefs 动态在任意用户程序的指定地址插入探针，监控函数调用、参数、返回值等，无需重新编译程序。\n\n- **性能分析与调试**  \n  结合 ftrace 或 perf 工具，采集用户程序热点函数的执行时间、调用栈、内存状态，用于性能瓶颈分析或故障诊断。\n\n- **安全监控**  \n  监控敏感系统调用或库函数（如 `execve`、`open`）的调用行为，结合 eBPF 实现运行时安全策略。\n\n- **uretprobe 返回值捕获**  \n  在函数返回时自动捕获返回值和调用上下文，适用于监控 API 调用结果（如系统调用成功/失败）。\n\n- **生产环境无侵入观测**  \n  由于 uprobes 基于动态指令替换（插入 `int3` 断点），对目标程序性能影响极小，适合在生产环境中临时启用观测。",
      "similarity": 0.6153982877731323,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 69,
          "end_line": 169,
          "content": [
            "static bool is_trace_uprobe(struct dyn_event *ev)",
            "{",
            "\treturn ev->ops == &trace_uprobe_ops;",
            "}",
            "static unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)",
            "{",
            "\treturn addr - (n * sizeof(long));",
            "}",
            "static unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)",
            "{",
            "\treturn addr + (n * sizeof(long));",
            "}",
            "static unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)",
            "{",
            "\tunsigned long ret;",
            "\tunsigned long addr = user_stack_pointer(regs);",
            "",
            "\taddr = adjust_stack_addr(addr, n);",
            "",
            "\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))",
            "\t\treturn 0;",
            "",
            "\treturn ret;",
            "}",
            "static nokprobe_inline int",
            "probe_mem_read(void *dest, void *src, size_t size)",
            "{",
            "\tvoid __user *vaddr = (void __force __user *)src;",
            "",
            "\treturn copy_from_user(dest, vaddr, size) ? -EFAULT : 0;",
            "}",
            "static nokprobe_inline int",
            "probe_mem_read_user(void *dest, void *src, size_t size)",
            "{",
            "\treturn probe_mem_read(dest, src, size);",
            "}",
            "static nokprobe_inline int",
            "fetch_store_string(unsigned long addr, void *dest, void *base)",
            "{",
            "\tlong ret;",
            "\tu32 loc = *(u32 *)dest;",
            "\tint maxlen  = get_loc_len(loc);",
            "\tu8 *dst = get_loc_data(dest, base);",
            "\tvoid __user *src = (void __force __user *) addr;",
            "",
            "\tif (unlikely(!maxlen))",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (addr == FETCH_TOKEN_COMM)",
            "\t\tret = strlcpy(dst, current->comm, maxlen);",
            "\telse",
            "\t\tret = strncpy_from_user(dst, src, maxlen);",
            "\tif (ret >= 0) {",
            "\t\tif (ret == maxlen)",
            "\t\t\tdst[ret - 1] = '\\0';",
            "\t\telse",
            "\t\t\t/*",
            "\t\t\t * Include the terminating null byte. In this case it",
            "\t\t\t * was copied by strncpy_from_user but not accounted",
            "\t\t\t * for in ret.",
            "\t\t\t */",
            "\t\t\tret++;",
            "\t\t*(u32 *)dest = make_data_loc(ret, (void *)dst - base);",
            "\t} else",
            "\t\t*(u32 *)dest = make_data_loc(0, (void *)dst - base);",
            "",
            "\treturn ret;",
            "}",
            "static nokprobe_inline int",
            "fetch_store_string_user(unsigned long addr, void *dest, void *base)",
            "{",
            "\treturn fetch_store_string(addr, dest, base);",
            "}",
            "static nokprobe_inline int",
            "fetch_store_strlen(unsigned long addr)",
            "{",
            "\tint len;",
            "\tvoid __user *vaddr = (void __force __user *) addr;",
            "",
            "\tif (addr == FETCH_TOKEN_COMM)",
            "\t\tlen = strlen(current->comm) + 1;",
            "\telse",
            "\t\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);",
            "",
            "\treturn (len > MAX_STRING_SIZE) ? 0 : len;",
            "}",
            "static nokprobe_inline int",
            "fetch_store_strlen_user(unsigned long addr)",
            "{",
            "\treturn fetch_store_strlen(addr);",
            "}",
            "static unsigned long translate_user_vaddr(unsigned long file_offset)",
            "{",
            "\tunsigned long base_addr;",
            "\tstruct uprobe_dispatch_data *udd;",
            "",
            "\tudd = (void *) current->utask->vaddr;",
            "",
            "\tbase_addr = udd->bp_addr - udd->tu->offset;",
            "\treturn base_addr + file_offset;",
            "}"
          ],
          "function_name": "is_trace_uprobe, adjust_stack_addr, adjust_stack_addr, get_user_stack_nth, probe_mem_read, probe_mem_read_user, fetch_store_string, fetch_store_string_user, fetch_store_strlen, fetch_store_strlen_user, translate_user_vaddr",
          "description": "实现用户态地址调整、栈帧访问、内存读取及字符串提取等辅助函数，支持从进程上下文获取寄存器值、堆栈数据、字符串内容等，用于探针事件的数据采集与处理。",
          "similarity": 0.5863652229309082
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 723,
          "end_line": 846,
          "content": [
            "int trace_uprobe_create(const char *raw_command)",
            "{",
            "\treturn trace_probe_create(raw_command, __trace_uprobe_create);",
            "}",
            "static int create_or_delete_trace_uprobe(const char *raw_command)",
            "{",
            "\tint ret;",
            "",
            "\tif (raw_command[0] == '-')",
            "\t\treturn dyn_event_release(raw_command, &trace_uprobe_ops);",
            "",
            "\tret = dyn_event_create(raw_command, &trace_uprobe_ops);",
            "\treturn ret == -ECANCELED ? -EINVAL : ret;",
            "}",
            "static int trace_uprobe_release(struct dyn_event *ev)",
            "{",
            "\tstruct trace_uprobe *tu = to_trace_uprobe(ev);",
            "",
            "\treturn unregister_trace_uprobe(tu);",
            "}",
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev)",
            "{",
            "\tstruct trace_uprobe *tu = to_trace_uprobe(ev);",
            "\tchar c = is_ret_probe(tu) ? 'r' : 'p';",
            "\tint i;",
            "",
            "\tseq_printf(m, \"%c:%s/%s %s:0x%0*lx\", c, trace_probe_group_name(&tu->tp),",
            "\t\t\ttrace_probe_name(&tu->tp), tu->filename,",
            "\t\t\t(int)(sizeof(void *) * 2), tu->offset);",
            "",
            "\tif (tu->ref_ctr_offset)",
            "\t\tseq_printf(m, \"(0x%lx)\", tu->ref_ctr_offset);",
            "",
            "\tfor (i = 0; i < tu->tp.nr_args; i++)",
            "\t\tseq_printf(m, \" %s=%s\", tu->tp.args[i].name, tu->tp.args[i].comm);",
            "",
            "\tseq_putc(m, '\\n');",
            "\treturn 0;",
            "}",
            "static int probes_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct dyn_event *ev = v;",
            "",
            "\tif (!is_trace_uprobe(ev))",
            "\t\treturn 0;",
            "",
            "\treturn trace_uprobe_show(m, ev);",
            "}",
            "static int probes_open(struct inode *inode, struct file *file)",
            "{",
            "\tint ret;",
            "",
            "\tret = security_locked_down(LOCKDOWN_TRACEFS);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {",
            "\t\tret = dyn_events_release_all(&trace_uprobe_ops);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\treturn seq_open(file, &probes_seq_op);",
            "}",
            "static ssize_t probes_write(struct file *file, const char __user *buffer,",
            "\t\t\t    size_t count, loff_t *ppos)",
            "{",
            "\treturn trace_parse_run_command(file, buffer, count, ppos,",
            "\t\t\t\t\tcreate_or_delete_trace_uprobe);",
            "}",
            "static int probes_profile_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct dyn_event *ev = v;",
            "\tstruct trace_uprobe *tu;",
            "",
            "\tif (!is_trace_uprobe(ev))",
            "\t\treturn 0;",
            "",
            "\ttu = to_trace_uprobe(ev);",
            "\tseq_printf(m, \"  %s %-44s %15lu\\n\", tu->filename,",
            "\t\t\ttrace_probe_name(&tu->tp), tu->nhit);",
            "\treturn 0;",
            "}",
            "static int profile_open(struct inode *inode, struct file *file)",
            "{",
            "\tint ret;",
            "",
            "\tret = security_locked_down(LOCKDOWN_TRACEFS);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn seq_open(file, &profile_seq_op);",
            "}",
            "static int uprobe_buffer_init(void)",
            "{",
            "\tint cpu, err_cpu;",
            "",
            "\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);",
            "\tif (uprobe_cpu_buffer == NULL)",
            "\t\treturn -ENOMEM;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),",
            "\t\t\t\t\t\t  GFP_KERNEL, 0);",
            "\t\tif (p == NULL) {",
            "\t\t\terr_cpu = cpu;",
            "\t\t\tgoto err;",
            "\t\t}",
            "\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);",
            "\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "err:",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tif (cpu == err_cpu)",
            "\t\t\tbreak;",
            "\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);",
            "\t}",
            "",
            "\tfree_percpu(uprobe_cpu_buffer);",
            "\treturn -ENOMEM;",
            "}"
          ],
          "function_name": "trace_uprobe_create, create_or_delete_trace_uprobe, trace_uprobe_release, trace_uprobe_show, probes_seq_show, probes_open, probes_write, probes_profile_seq_show, profile_open, uprobe_buffer_init",
          "description": "实现 uprobes 动态事件管理，提供创建/删除探针接口，初始化 CPU 缓冲区并管理引用计数，包含探针展示、文件打开/写入及事件触发逻辑",
          "similarity": 0.5725455284118652
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 1579,
          "end_line": 1624,
          "content": [
            "static inline void init_trace_event_call(struct trace_uprobe *tu)",
            "{",
            "\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);",
            "\tcall->event.funcs = &uprobe_funcs;",
            "\tcall->class->fields_array = uprobe_fields_array;",
            "",
            "\tcall->flags = TRACE_EVENT_FL_UPROBE | TRACE_EVENT_FL_CAP_ANY;",
            "\tcall->class->reg = trace_uprobe_register;",
            "}",
            "static int register_uprobe_event(struct trace_uprobe *tu)",
            "{",
            "\tinit_trace_event_call(tu);",
            "",
            "\treturn trace_probe_register_event_call(&tu->tp);",
            "}",
            "static int unregister_uprobe_event(struct trace_uprobe *tu)",
            "{",
            "\treturn trace_probe_unregister_event_call(&tu->tp);",
            "}",
            "void destroy_local_trace_uprobe(struct trace_event_call *event_call)",
            "{",
            "\tstruct trace_uprobe *tu;",
            "",
            "\ttu = trace_uprobe_primary_from_call(event_call);",
            "",
            "\tfree_trace_uprobe(tu);",
            "}",
            "static __init int init_uprobe_trace(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = dyn_event_register(&trace_uprobe_ops);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = tracing_init_dentry();",
            "\tif (ret)",
            "\t\treturn 0;",
            "",
            "\ttrace_create_file(\"uprobe_events\", TRACE_MODE_WRITE, NULL,",
            "\t\t\t\t    NULL, &uprobe_events_ops);",
            "\t/* Profile interface */",
            "\ttrace_create_file(\"uprobe_profile\", TRACE_MODE_READ, NULL,",
            "\t\t\t\t    NULL, &uprobe_profile_ops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "init_trace_event_call, register_uprobe_event, unregister_uprobe_event, destroy_local_trace_uprobe, init_uprobe_trace",
          "description": "该代码段实现了 uprobes 跟踪事件的注册与管理功能，主要包含事件结构初始化、注册/注销逻辑及模块初始化。  \n`init_trace_event_call` 初始化跟踪事件结构并绑定uprobes专用函数集，`register_uprobe_event` 和 `unregister_uprobe_event` 分别负责注册与注销事件调用，`destroy_local_trace_uprobe` 用于清理本地跟踪探针资源。  \n上下文完整，代码展示了 uprobes 跟踪模块的事件生命周期管理和初始化流程。",
          "similarity": 0.5437136888504028
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 1304,
          "end_line": 1428,
          "content": [
            "static int uprobe_perf_close(struct trace_event_call *call,",
            "\t\t\t     struct perf_event *event)",
            "{",
            "\tstruct trace_probe *tp;",
            "\tstruct trace_uprobe *tu;",
            "\tint ret = 0;",
            "",
            "\ttp = trace_probe_primary_from_call(call);",
            "\tif (WARN_ON_ONCE(!tp))",
            "\t\treturn -ENODEV;",
            "",
            "\ttu = container_of(tp, struct trace_uprobe, tp);",
            "\tif (trace_uprobe_filter_remove(tu->tp.event->filter, event))",
            "\t\treturn 0;",
            "",
            "\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {",
            "\t\tret = uprobe_apply(tu->uprobe, &tu->consumer, false);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int uprobe_perf_open(struct trace_event_call *call,",
            "\t\t\t    struct perf_event *event)",
            "{",
            "\tstruct trace_probe *tp;",
            "\tstruct trace_uprobe *tu;",
            "\tint err = 0;",
            "",
            "\ttp = trace_probe_primary_from_call(call);",
            "\tif (WARN_ON_ONCE(!tp))",
            "\t\treturn -ENODEV;",
            "",
            "\ttu = container_of(tp, struct trace_uprobe, tp);",
            "\tif (trace_uprobe_filter_add(tu->tp.event->filter, event))",
            "\t\treturn 0;",
            "",
            "\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {",
            "\t\terr = uprobe_apply(tu->uprobe, &tu->consumer, true);",
            "\t\tif (err) {",
            "\t\t\tuprobe_perf_close(call, event);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "static bool uprobe_perf_filter(struct uprobe_consumer *uc, struct mm_struct *mm)",
            "{",
            "\tstruct trace_uprobe_filter *filter;",
            "\tstruct trace_uprobe *tu;",
            "\tint ret;",
            "",
            "\ttu = container_of(uc, struct trace_uprobe, consumer);",
            "\tfilter = tu->tp.event->filter;",
            "",
            "\tread_lock(&filter->rwlock);",
            "\tret = __uprobe_perf_filter(filter, mm);",
            "\tread_unlock(&filter->rwlock);",
            "",
            "\treturn ret;",
            "}",
            "static void __uprobe_perf_func(struct trace_uprobe *tu,",
            "\t\t\t       unsigned long func, struct pt_regs *regs,",
            "\t\t\t       struct uprobe_cpu_buffer **ucbp)",
            "{",
            "\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);",
            "\tstruct uprobe_trace_entry_head *entry;",
            "\tstruct uprobe_cpu_buffer *ucb;",
            "\tstruct hlist_head *head;",
            "\tvoid *data;",
            "\tint size, esize;",
            "\tint rctx;",
            "",
            "#ifdef CONFIG_BPF_EVENTS",
            "\tif (bpf_prog_array_valid(call)) {",
            "\t\tconst struct bpf_prog_array *array;",
            "\t\tu32 ret;",
            "",
            "\t\trcu_read_lock_trace();",
            "\t\tarray = rcu_dereference_check(call->prog_array, rcu_read_lock_trace_held());",
            "\t\tret = bpf_prog_run_array_uprobe(array, regs, bpf_prog_run);",
            "\t\trcu_read_unlock_trace();",
            "\t\tif (!ret)",
            "\t\t\treturn;",
            "\t}",
            "#endif /* CONFIG_BPF_EVENTS */",
            "",
            "\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));",
            "",
            "\tucb = prepare_uprobe_buffer(tu, regs, ucbp);",
            "\tsize = esize + ucb->dsize;",
            "\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);",
            "\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))",
            "\t\treturn;",
            "",
            "\tpreempt_disable();",
            "\thead = this_cpu_ptr(call->perf_events);",
            "\tif (hlist_empty(head))",
            "\t\tgoto out;",
            "",
            "\tentry = perf_trace_buf_alloc(size, NULL, &rctx);",
            "\tif (!entry)",
            "\t\tgoto out;",
            "",
            "\tif (is_ret_probe(tu)) {",
            "\t\tentry->vaddr[0] = func;",
            "\t\tentry->vaddr[1] = instruction_pointer(regs);",
            "\t\tdata = DATAOF_TRACE_ENTRY(entry, true);",
            "\t} else {",
            "\t\tentry->vaddr[0] = instruction_pointer(regs);",
            "\t\tdata = DATAOF_TRACE_ENTRY(entry, false);",
            "\t}",
            "",
            "\tmemcpy(data, ucb->buf, ucb->dsize);",
            "",
            "\tif (size - esize > ucb->dsize)",
            "\t\tmemset(data + ucb->dsize, 0, size - esize - ucb->dsize);",
            "",
            "\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,",
            "\t\t\t      head, NULL);",
            " out:",
            "\tpreempt_enable();",
            "}"
          ],
          "function_name": "uprobe_perf_close, uprobe_perf_open, uprobe_perf_filter, __uprobe_perf_func",
          "description": "实现 uprobes 性能事件的注册/注销逻辑，通过 BPF 扩展支持，处理事件数据采集并提交至 perf 追踪缓冲区",
          "similarity": 0.5400623083114624
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 534,
          "end_line": 721,
          "content": [
            "static int __trace_uprobe_create(int argc, const char **argv)",
            "{",
            "\tstruct trace_uprobe *tu;",
            "\tconst char *event = NULL, *group = UPROBE_EVENT_SYSTEM;",
            "\tchar *arg, *filename, *rctr, *rctr_end, *tmp;",
            "\tchar buf[MAX_EVENT_NAME_LEN];",
            "\tchar gbuf[MAX_EVENT_NAME_LEN];",
            "\tenum probe_print_type ptype;",
            "\tstruct path path;",
            "\tunsigned long offset, ref_ctr_offset;",
            "\tbool is_return = false;",
            "\tint i, ret;",
            "",
            "\tref_ctr_offset = 0;",
            "",
            "\tswitch (argv[0][0]) {",
            "\tcase 'r':",
            "\t\tis_return = true;",
            "\t\tbreak;",
            "\tcase 'p':",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -ECANCELED;",
            "\t}",
            "",
            "\tif (argc < 2)",
            "\t\treturn -ECANCELED;",
            "\tif (argc - 2 > MAX_TRACE_ARGS)",
            "\t\treturn -E2BIG;",
            "",
            "\tif (argv[0][1] == ':')",
            "\t\tevent = &argv[0][2];",
            "",
            "\tif (!strchr(argv[1], '/'))",
            "\t\treturn -ECANCELED;",
            "",
            "\tfilename = kstrdup(argv[1], GFP_KERNEL);",
            "\tif (!filename)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* Find the last occurrence, in case the path contains ':' too. */",
            "\targ = strrchr(filename, ':');",
            "\tif (!arg || !isdigit(arg[1])) {",
            "\t\tkfree(filename);",
            "\t\treturn -ECANCELED;",
            "\t}",
            "",
            "\ttrace_probe_log_init(\"trace_uprobe\", argc, argv);",
            "\ttrace_probe_log_set_index(1);\t/* filename is the 2nd argument */",
            "",
            "\t*arg++ = '\\0';",
            "\tret = kern_path(filename, LOOKUP_FOLLOW, &path);",
            "\tif (ret) {",
            "\t\ttrace_probe_log_err(0, FILE_NOT_FOUND);",
            "\t\tkfree(filename);",
            "\t\ttrace_probe_log_clear();",
            "\t\treturn ret;",
            "\t}",
            "\tif (!d_is_reg(path.dentry)) {",
            "\t\ttrace_probe_log_err(0, NO_REGULAR_FILE);",
            "\t\tret = -EINVAL;",
            "\t\tgoto fail_address_parse;",
            "\t}",
            "",
            "\t/* Parse reference counter offset if specified. */",
            "\trctr = strchr(arg, '(');",
            "\tif (rctr) {",
            "\t\trctr_end = strchr(rctr, ')');",
            "\t\tif (!rctr_end) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\trctr_end = rctr + strlen(rctr);",
            "\t\t\ttrace_probe_log_err(rctr_end - filename,",
            "\t\t\t\t\t    REFCNT_OPEN_BRACE);",
            "\t\t\tgoto fail_address_parse;",
            "\t\t} else if (rctr_end[1] != '\\0') {",
            "\t\t\tret = -EINVAL;",
            "\t\t\ttrace_probe_log_err(rctr_end + 1 - filename,",
            "\t\t\t\t\t    BAD_REFCNT_SUFFIX);",
            "\t\t\tgoto fail_address_parse;",
            "\t\t}",
            "",
            "\t\t*rctr++ = '\\0';",
            "\t\t*rctr_end = '\\0';",
            "\t\tret = kstrtoul(rctr, 0, &ref_ctr_offset);",
            "\t\tif (ret) {",
            "\t\t\ttrace_probe_log_err(rctr - filename, BAD_REFCNT);",
            "\t\t\tgoto fail_address_parse;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Check if there is %return suffix */",
            "\ttmp = strchr(arg, '%');",
            "\tif (tmp) {",
            "\t\tif (!strcmp(tmp, \"%return\")) {",
            "\t\t\t*tmp = '\\0';",
            "\t\t\tis_return = true;",
            "\t\t} else {",
            "\t\t\ttrace_probe_log_err(tmp - filename, BAD_ADDR_SUFFIX);",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto fail_address_parse;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Parse uprobe offset. */",
            "\tret = kstrtoul(arg, 0, &offset);",
            "\tif (ret) {",
            "\t\ttrace_probe_log_err(arg - filename, BAD_UPROBE_OFFS);",
            "\t\tgoto fail_address_parse;",
            "\t}",
            "",
            "\t/* setup a probe */",
            "\ttrace_probe_log_set_index(0);",
            "\tif (event) {",
            "\t\tret = traceprobe_parse_event_name(&event, &group, gbuf,",
            "\t\t\t\t\t\t  event - argv[0]);",
            "\t\tif (ret)",
            "\t\t\tgoto fail_address_parse;",
            "\t}",
            "",
            "\tif (!event) {",
            "\t\tchar *tail;",
            "\t\tchar *ptr;",
            "",
            "\t\ttail = kstrdup(kbasename(filename), GFP_KERNEL);",
            "\t\tif (!tail) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto fail_address_parse;",
            "\t\t}",
            "",
            "\t\tptr = strpbrk(tail, \".-_\");",
            "\t\tif (ptr)",
            "\t\t\t*ptr = '\\0';",
            "",
            "\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_0x%lx\", 'p', tail, offset);",
            "\t\tevent = buf;",
            "\t\tkfree(tail);",
            "\t}",
            "",
            "\targc -= 2;",
            "\targv += 2;",
            "",
            "\ttu = alloc_trace_uprobe(group, event, argc, is_return);",
            "\tif (IS_ERR(tu)) {",
            "\t\tret = PTR_ERR(tu);",
            "\t\t/* This must return -ENOMEM otherwise there is a bug */",
            "\t\tWARN_ON_ONCE(ret != -ENOMEM);",
            "\t\tgoto fail_address_parse;",
            "\t}",
            "\ttu->offset = offset;",
            "\ttu->ref_ctr_offset = ref_ctr_offset;",
            "\ttu->path = path;",
            "\ttu->filename = filename;",
            "",
            "\t/* parse arguments */",
            "\tfor (i = 0; i < argc; i++) {",
            "\t\tstruct traceprobe_parse_context ctx = {",
            "\t\t\t.flags = (is_return ? TPARG_FL_RETURN : 0) | TPARG_FL_USER,",
            "\t\t};",
            "",
            "\t\ttrace_probe_log_set_index(i + 2);",
            "\t\tret = traceprobe_parse_probe_arg(&tu->tp, i, argv[i], &ctx);",
            "\t\ttraceprobe_finish_parse(&ctx);",
            "\t\tif (ret)",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;",
            "\tret = traceprobe_set_print_fmt(&tu->tp, ptype);",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "",
            "\tret = register_trace_uprobe(tu);",
            "\tif (!ret)",
            "\t\tgoto out;",
            "",
            "error:",
            "\tfree_trace_uprobe(tu);",
            "out:",
            "\ttrace_probe_log_clear();",
            "\treturn ret;",
            "",
            "fail_address_parse:",
            "\ttrace_probe_log_clear();",
            "\tpath_put(&path);",
            "\tkfree(filename);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__trace_uprobe_create",
          "description": "实现 uprobes 探针创建主流程，解析命令行参数构建路径与偏移量，设置打印格式并调用 register_trace_uprobe 注册探针，完成从用户输入到内核探针结构的完整转换与验证。",
          "similarity": 0.5260800123214722
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_sched_wakeup.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:35:56\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_sched_wakeup.c`\n\n---\n\n# `trace_sched_wakeup.c` 技术文档\n\n## 1. 文件概述\n\n`trace_sched_wakeup.c` 是 Linux 内核中用于追踪任务唤醒延迟（wakeup latency）的关键调度器跟踪模块。该文件实现了 **wakeup tracer**，用于记录从一个高优先级任务被唤醒（例如通过 `wake_up_process()`）到它实际获得 CPU 执行之间的时间延迟。该 tracer 主要用于实时系统性能分析和调度延迟调试，是内核 ftrace 框架的一部分。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `wakeup_trace`：指向当前 wakeup tracer 实例的 `struct trace_array`。\n- `tracer_enabled`：标记 tracer 是否启用。\n- `wakeup_task`：当前被追踪唤醒的目标任务。\n- `wakeup_cpu` / `wakeup_current_cpu`：记录目标任务所在 CPU 和当前执行 CPU。\n- `wakeup_prio`：目标任务的优先级（初始为 -1 表示无效）。\n- `wakeup_rt` / `wakeup_dl` / `tracing_dl`：标志位，分别表示是否为实时任务（RT）、截止时间任务（Deadline）以及是否正在追踪 Deadline 任务。\n- `wakeup_lock`：用于保护关键数据结构的自旋锁。\n\n### 主要函数\n- `func_prolog_preempt_disable()`：函数追踪的前置处理，用于判断是否应记录当前函数调用，并禁用抢占。\n- `wakeup_tracer_call()`：函数追踪回调函数，记录函数调用事件。\n- `wakeup_graph_entry()` / `wakeup_graph_return()`：函数图追踪（function graph tracer）的入口和返回钩子。\n- `register_wakeup_function()` / `unregister_wakeup_function()`：注册/注销函数追踪回调。\n- `wakeup_function_set()`：处理 `TRACE_ITER_FUNCTION` 标志变更。\n- `wakeup_flag_changed()`：处理 tracer 标志变化（如启用函数追踪或函数图追踪）。\n- `wakeup_print_line()` / `wakeup_print_header()`：格式化输出追踪结果。\n- `wakeup_trace_open()` / `wakeup_trace_close()`：追踪迭代器的打开/关闭回调。\n\n### 回调结构体\n- `fgraph_wakeup_ops`：定义了用于函数图追踪的入口和返回回调函数。\n\n## 3. 关键实现\n\n### 唤醒追踪机制\n- 当一个高优先级任务被唤醒时，wakeup tracer 会记录该任务信息（`wakeup_task`、`wakeup_prio`、CPU 等）。\n- 在后续调度过程中，tracer 会追踪从唤醒点到该任务实际运行之间的所有函数调用（如果启用了函数追踪）。\n- 通过比较时间戳，可计算出唤醒延迟（latency），并记录最大延迟值（`tr->max_latency`）。\n\n### 函数追踪集成\n- 若启用 `CONFIG_FUNCTION_TRACER`，tracer 会注册 `wakeup_tracer_call` 作为函数追踪回调。\n- 若同时启用 `CONFIG_FUNCTION_GRAPH_TRACER`，则使用 `fgraph_wakeup_ops` 实现函数调用图追踪，记录完整的调用栈。\n- 使用 `func_prolog_preempt_disable()` 确保只在追踪目标 CPU 上记录，并通过 `data->disabled` 原子计数防止嵌套追踪。\n\n### 并发与抢占控制\n- 使用 `preempt_disable_notrace()` 禁用抢占以保证追踪上下文一致性。\n- 使用 `local_irq_save/restore()` 保护关键追踪路径。\n- 通过 `arch_spinlock_t wakeup_lock` 保护共享状态（虽在代码片段中未直接使用，但为全局同步预留）。\n\n### 动态追踪模式切换\n- 支持在运行时切换普通函数追踪与函数图追踪模式（通过 `TRACE_ITER_DISPLAY_GRAPH` 标志）。\n- 切换时会重置追踪状态（`wakeup_reset`）并重新注册对应的追踪回调。\n\n## 4. 依赖关系\n\n- **ftrace 框架**：依赖 `ftrace.h` 提供的函数追踪基础设施。\n- **调度子系统**：通过 `trace/events/sched.h` 接收任务唤醒事件（如 `sched_wakeup`、`sched_wakeup_new`）。\n- **实时调度类**：包含对 `SCHED_FIFO`/`SCHED_RR`（RT）和 `SCHED_DEADLINE` 调度策略的特殊处理。\n- **函数图追踪**：若启用 `CONFIG_FUNCTION_GRAPH_TRACER`，依赖其回调机制和栈管理。\n- **内核符号解析**：通过 `kallsyms.h` 支持函数名解析（间接依赖）。\n\n## 5. 使用场景\n\n- **实时系统延迟分析**：用于测量高优先级 RT 或 Deadline 任务从唤醒到执行的延迟，验证系统是否满足实时性要求。\n- **调度器调试**：帮助开发者分析调度延迟来源，如中断处理、锁竞争、低优先级任务占用 CPU 等。\n- **性能调优**：结合函数追踪或函数图追踪，定位导致唤醒延迟的具体代码路径。\n- **内核测试**：作为 `ftrace` 的标准 tracer 之一，可通过 `/sys/kernel/debug/tracing/current_tracer` 设置为 `wakeup` 或 `wakeup_rt` 进行测试。",
      "similarity": 0.6153470873832703,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 67,
          "end_line": 173,
          "content": [
            "static int",
            "func_prolog_preempt_disable(struct trace_array *tr,",
            "\t\t\t    struct trace_array_cpu **data,",
            "\t\t\t    unsigned int *trace_ctx)",
            "{",
            "\tlong disabled;",
            "\tint cpu;",
            "",
            "\tif (likely(!wakeup_task))",
            "\t\treturn 0;",
            "",
            "\t*trace_ctx = tracing_gen_ctx();",
            "\tpreempt_disable_notrace();",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\tif (cpu != wakeup_current_cpu)",
            "\t\tgoto out_enable;",
            "",
            "\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "\tdisabled = atomic_inc_return(&(*data)->disabled);",
            "\tif (unlikely(disabled != 1))",
            "\t\tgoto out;",
            "",
            "\treturn 1;",
            "",
            "out:",
            "\tatomic_dec(&(*data)->disabled);",
            "",
            "out_enable:",
            "\tpreempt_enable_notrace();",
            "\treturn 0;",
            "}",
            "static int wakeup_display_graph(struct trace_array *tr, int set)",
            "{",
            "\tif (!(is_graph(tr) ^ set))",
            "\t\treturn 0;",
            "",
            "\tstop_func_tracer(tr, !set);",
            "",
            "\twakeup_reset(wakeup_trace);",
            "\ttr->max_latency = 0;",
            "",
            "\treturn start_func_tracer(tr, set);",
            "}",
            "static int wakeup_graph_entry(struct ftrace_graph_ent *trace,",
            "\t\t\t      struct fgraph_ops *gops,",
            "\t\t\t      struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = wakeup_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint ret = 0;",
            "",
            "\tif (ftrace_graph_ignore_func(gops, trace))",
            "\t\treturn 0;",
            "\t/*",
            "\t * Do not trace a function if it's filtered by set_graph_notrace.",
            "\t * Make the index of ret stack negative to indicate that it should",
            "\t * ignore further functions.  But it needs its own ret stack entry",
            "\t * to recover the original index in order to continue tracing after",
            "\t * returning from the function.",
            "\t */",
            "\tif (ftrace_graph_notrace_addr(trace->func))",
            "\t\treturn 1;",
            "",
            "\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))",
            "\t\treturn 0;",
            "",
            "\tcalltime = fgraph_reserve_data(gops->idx, sizeof(*calltime));",
            "\tif (!calltime)",
            "\t\treturn 0;",
            "",
            "\t*calltime = trace_clock_local();",
            "",
            "\tret = __trace_graph_entry(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "\tpreempt_enable_notrace();",
            "",
            "\treturn ret;",
            "}",
            "static void wakeup_graph_return(struct ftrace_graph_ret *trace,",
            "\t\t\t\tstruct fgraph_ops *gops,",
            "\t\t\t\tstruct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = wakeup_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint size;",
            "",
            "\tftrace_graph_addr_finish(gops, trace);",
            "",
            "\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))",
            "\t\treturn;",
            "",
            "\tcalltime = fgraph_retrieve_data(gops->idx, &size);",
            "\tif (!calltime)",
            "\t\treturn;",
            "\ttrace->calltime = *calltime;",
            "",
            "\t__trace_graph_return(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "",
            "\tpreempt_enable_notrace();",
            "\treturn;",
            "}"
          ],
          "function_name": "func_prolog_preempt_disable, wakeup_display_graph, wakeup_graph_entry, wakeup_graph_return",
          "description": "实现抢占禁用、图形跟踪模式切换及函数入口/返回的跟踪逻辑，用于管理跟踪上下文和数据采集。",
          "similarity": 0.5928517580032349
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 445,
          "end_line": 613,
          "content": [
            "static void notrace",
            "probe_wakeup_sched_switch(void *ignore, bool preempt,",
            "\t\t\t  struct task_struct *prev, struct task_struct *next,",
            "\t\t\t  unsigned int prev_state)",
            "{",
            "\tstruct trace_array_cpu *data;",
            "\tu64 T0, T1, delta;",
            "\tunsigned long flags;",
            "\tlong disabled;",
            "\tint cpu;",
            "\tunsigned int trace_ctx;",
            "",
            "\ttracing_record_cmdline(prev);",
            "",
            "\tif (unlikely(!tracer_enabled))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * When we start a new trace, we set wakeup_task to NULL",
            "\t * and then set tracer_enabled = 1. We want to make sure",
            "\t * that another CPU does not see the tracer_enabled = 1",
            "\t * and the wakeup_task with an older task, that might",
            "\t * actually be the same as next.",
            "\t */",
            "\tsmp_rmb();",
            "",
            "\tif (next != wakeup_task)",
            "\t\treturn;",
            "",
            "\t/* disable local data, not wakeup_cpu data */",
            "\tcpu = raw_smp_processor_id();",
            "\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "\tif (likely(disabled != 1))",
            "\t\tgoto out;",
            "",
            "\tlocal_irq_save(flags);",
            "\ttrace_ctx = tracing_gen_ctx_flags(flags);",
            "",
            "\tarch_spin_lock(&wakeup_lock);",
            "",
            "\t/* We could race with grabbing wakeup_lock */",
            "\tif (unlikely(!tracer_enabled || next != wakeup_task))",
            "\t\tgoto out_unlock;",
            "",
            "\t/* The task we are waiting for is waking up */",
            "\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);",
            "",
            "\t__trace_function(wakeup_trace, CALLER_ADDR0, CALLER_ADDR1, trace_ctx);",
            "\ttracing_sched_switch_trace(wakeup_trace, prev, next, trace_ctx);",
            "\t__trace_stack(wakeup_trace, trace_ctx, 0);",
            "",
            "\tT0 = data->preempt_timestamp;",
            "\tT1 = ftrace_now(cpu);",
            "\tdelta = T1-T0;",
            "",
            "\tif (!report_latency(wakeup_trace, delta))",
            "\t\tgoto out_unlock;",
            "",
            "\tif (likely(!is_tracing_stopped())) {",
            "\t\twakeup_trace->max_latency = delta;",
            "\t\tupdate_max_tr(wakeup_trace, wakeup_task, wakeup_cpu, NULL);",
            "\t}",
            "",
            "out_unlock:",
            "\t__wakeup_reset(wakeup_trace);",
            "\tarch_spin_unlock(&wakeup_lock);",
            "\tlocal_irq_restore(flags);",
            "out:",
            "\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "}",
            "static void __wakeup_reset(struct trace_array *tr)",
            "{",
            "\twakeup_cpu = -1;",
            "\twakeup_prio = -1;",
            "\ttracing_dl = false;",
            "",
            "\tif (wakeup_task)",
            "\t\tput_task_struct(wakeup_task);",
            "",
            "\twakeup_task = NULL;",
            "}",
            "static void wakeup_reset(struct trace_array *tr)",
            "{",
            "\tunsigned long flags;",
            "",
            "\ttracing_reset_online_cpus(&tr->array_buffer);",
            "",
            "\tlocal_irq_save(flags);",
            "\tarch_spin_lock(&wakeup_lock);",
            "\t__wakeup_reset(tr);",
            "\tarch_spin_unlock(&wakeup_lock);",
            "\tlocal_irq_restore(flags);",
            "}",
            "static void",
            "probe_wakeup(void *ignore, struct task_struct *p)",
            "{",
            "\tstruct trace_array_cpu *data;",
            "\tint cpu = smp_processor_id();",
            "\tlong disabled;",
            "\tunsigned int trace_ctx;",
            "",
            "\tif (likely(!tracer_enabled))",
            "\t\treturn;",
            "",
            "\ttracing_record_cmdline(p);",
            "\ttracing_record_cmdline(current);",
            "",
            "\t/*",
            "\t * Semantic is like this:",
            "\t *  - wakeup tracer handles all tasks in the system, independently",
            "\t *    from their scheduling class;",
            "\t *  - wakeup_rt tracer handles tasks belonging to sched_dl and",
            "\t *    sched_rt class;",
            "\t *  - wakeup_dl handles tasks belonging to sched_dl class only.",
            "\t */",
            "\tif (tracing_dl || (wakeup_dl && !dl_task(p)) ||",
            "\t    (wakeup_rt && !rt_or_dl_task(p)) ||",
            "\t    (!dl_task(p) && (p->prio >= wakeup_prio || p->prio >= current->prio)))",
            "\t\treturn;",
            "",
            "\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "\tif (unlikely(disabled != 1))",
            "\t\tgoto out;",
            "",
            "\ttrace_ctx = tracing_gen_ctx();",
            "",
            "\t/* interrupts should be off from try_to_wake_up */",
            "\tarch_spin_lock(&wakeup_lock);",
            "",
            "\t/* check for races. */",
            "\tif (!tracer_enabled || tracing_dl ||",
            "\t    (!dl_task(p) && p->prio >= wakeup_prio))",
            "\t\tgoto out_locked;",
            "",
            "\t/* reset the trace */",
            "\t__wakeup_reset(wakeup_trace);",
            "",
            "\twakeup_cpu = task_cpu(p);",
            "\twakeup_current_cpu = wakeup_cpu;",
            "\twakeup_prio = p->prio;",
            "",
            "\t/*",
            "\t * Once you start tracing a -deadline task, don't bother tracing",
            "\t * another task until the first one wakes up.",
            "\t */",
            "\tif (dl_task(p))",
            "\t\ttracing_dl = true;",
            "\telse",
            "\t\ttracing_dl = false;",
            "",
            "\twakeup_task = get_task_struct(p);",
            "",
            "\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);",
            "\tdata->preempt_timestamp = ftrace_now(cpu);",
            "\ttracing_sched_wakeup_trace(wakeup_trace, p, current, trace_ctx);",
            "\t__trace_stack(wakeup_trace, trace_ctx, 0);",
            "",
            "\t/*",
            "\t * We must be careful in using CALLER_ADDR2. But since wake_up",
            "\t * is not called by an assembly function  (where as schedule is)",
            "\t * it should be safe to use it here.",
            "\t */",
            "\t__trace_function(wakeup_trace, CALLER_ADDR1, CALLER_ADDR2, trace_ctx);",
            "",
            "out_locked:",
            "\tarch_spin_unlock(&wakeup_lock);",
            "out:",
            "\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "}"
          ],
          "function_name": "probe_wakeup_sched_switch, __wakeup_reset, wakeup_reset, probe_wakeup",
          "description": "通过探针函数捕获任务唤醒事件，维护当前跟踪目标任务状态，同步时间戳并触发相应跟踪记录操作。",
          "similarity": 0.5711082816123962
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 309,
          "end_line": 430,
          "content": [
            "static void wakeup_trace_open(struct trace_iterator *iter) { }",
            "static void wakeup_trace_close(struct trace_iterator *iter) { }",
            "static void wakeup_print_header(struct seq_file *s)",
            "{",
            "\ttrace_default_header(s);",
            "}",
            "static void",
            "__trace_function(struct trace_array *tr,",
            "\t\t unsigned long ip, unsigned long parent_ip,",
            "\t\t unsigned int trace_ctx)",
            "{",
            "\tif (is_graph(tr))",
            "\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);",
            "\telse",
            "\t\ttrace_function(tr, ip, parent_ip, trace_ctx);",
            "}",
            "static int wakeup_flag_changed(struct trace_array *tr, u32 mask, int set)",
            "{",
            "\tstruct tracer *tracer = tr->current_trace;",
            "",
            "\tif (wakeup_function_set(tr, mask, set))",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_FUNCTION_GRAPH_TRACER",
            "\tif (mask & TRACE_ITER_DISPLAY_GRAPH)",
            "\t\treturn wakeup_display_graph(tr, set);",
            "#endif",
            "",
            "\treturn trace_keep_overwrite(tracer, mask, set);",
            "}",
            "static int start_func_tracer(struct trace_array *tr, int graph)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_wakeup_function(tr, graph, 0);",
            "",
            "\tif (!ret && tracing_is_enabled())",
            "\t\ttracer_enabled = 1;",
            "\telse",
            "\t\ttracer_enabled = 0;",
            "",
            "\treturn ret;",
            "}",
            "static void stop_func_tracer(struct trace_array *tr, int graph)",
            "{",
            "\ttracer_enabled = 0;",
            "",
            "\tunregister_wakeup_function(tr, graph);",
            "}",
            "static bool report_latency(struct trace_array *tr, u64 delta)",
            "{",
            "\tif (tracing_thresh) {",
            "\t\tif (delta < tracing_thresh)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\tif (delta <= tr->max_latency)",
            "\t\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void",
            "probe_wakeup_migrate_task(void *ignore, struct task_struct *task, int cpu)",
            "{",
            "\tif (task != wakeup_task)",
            "\t\treturn;",
            "",
            "\twakeup_current_cpu = cpu;",
            "}",
            "static void",
            "tracing_sched_switch_trace(struct trace_array *tr,",
            "\t\t\t   struct task_struct *prev,",
            "\t\t\t   struct task_struct *next,",
            "\t\t\t   unsigned int trace_ctx)",
            "{",
            "\tstruct trace_event_call *call = &event_context_switch;",
            "\tstruct trace_buffer *buffer = tr->array_buffer.buffer;",
            "\tstruct ring_buffer_event *event;",
            "\tstruct ctx_switch_entry *entry;",
            "",
            "\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,",
            "\t\t\t\t\t  sizeof(*entry), trace_ctx);",
            "\tif (!event)",
            "\t\treturn;",
            "\tentry\t= ring_buffer_event_data(event);",
            "\tentry->prev_pid\t\t\t= prev->pid;",
            "\tentry->prev_prio\t\t= prev->prio;",
            "\tentry->prev_state\t\t= task_state_index(prev);",
            "\tentry->next_pid\t\t\t= next->pid;",
            "\tentry->next_prio\t\t= next->prio;",
            "\tentry->next_state\t\t= task_state_index(next);",
            "\tentry->next_cpu\t= task_cpu(next);",
            "",
            "\tif (!call_filter_check_discard(call, entry, buffer, event))",
            "\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);",
            "}",
            "static void",
            "tracing_sched_wakeup_trace(struct trace_array *tr,",
            "\t\t\t   struct task_struct *wakee,",
            "\t\t\t   struct task_struct *curr,",
            "\t\t\t   unsigned int trace_ctx)",
            "{",
            "\tstruct trace_event_call *call = &event_wakeup;",
            "\tstruct ring_buffer_event *event;",
            "\tstruct ctx_switch_entry *entry;",
            "\tstruct trace_buffer *buffer = tr->array_buffer.buffer;",
            "",
            "\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,",
            "\t\t\t\t\t  sizeof(*entry), trace_ctx);",
            "\tif (!event)",
            "\t\treturn;",
            "\tentry\t= ring_buffer_event_data(event);",
            "\tentry->prev_pid\t\t\t= curr->pid;",
            "\tentry->prev_prio\t\t= curr->prio;",
            "\tentry->prev_state\t\t= task_state_index(curr);",
            "\tentry->next_pid\t\t\t= wakee->pid;",
            "\tentry->next_prio\t\t= wakee->prio;",
            "\tentry->next_state\t\t= task_state_index(wakee);",
            "\tentry->next_cpu\t\t\t= task_cpu(wakee);",
            "",
            "\tif (!call_filter_check_discard(call, entry, buffer, event))",
            "\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);",
            "}"
          ],
          "function_name": "wakeup_trace_open, wakeup_trace_close, wakeup_print_header, __trace_function, wakeup_flag_changed, start_func_tracer, stop_func_tracer, report_latency, probe_wakeup_migrate_task, tracing_sched_switch_trace, tracing_sched_wakeup_trace",
          "description": "实现任务切换和唤醒事件的记录功能，包含延迟上报判断、时间戳计算及事件数据的缓冲区管理。",
          "similarity": 0.558755099773407
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 618,
          "end_line": 723,
          "content": [
            "static void start_wakeup_tracer(struct trace_array *tr)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_trace_sched_wakeup(probe_wakeup, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_wakeup\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_wakeup_new\\n\");",
            "\t\tgoto fail_deprobe;",
            "\t}",
            "",
            "\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_switch\\n\");",
            "\t\tgoto fail_deprobe_wake_new;",
            "\t}",
            "",
            "\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_migrate_task\\n\");",
            "\t\tgoto fail_deprobe_sched_switch;",
            "\t}",
            "",
            "\twakeup_reset(tr);",
            "",
            "\t/*",
            "\t * Don't let the tracer_enabled = 1 show up before",
            "\t * the wakeup_task is reset. This may be overkill since",
            "\t * wakeup_reset does a spin_unlock after setting the",
            "\t * wakeup_task to NULL, but I want to be safe.",
            "\t * This is a slow path anyway.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tif (start_func_tracer(tr, is_graph(tr)))",
            "\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");",
            "",
            "\treturn;",
            "fail_deprobe_sched_switch:",
            "\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);",
            "fail_deprobe_wake_new:",
            "\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);",
            "fail_deprobe:",
            "\tunregister_trace_sched_wakeup(probe_wakeup, NULL);",
            "}",
            "static void stop_wakeup_tracer(struct trace_array *tr)",
            "{",
            "\ttracer_enabled = 0;",
            "\tstop_func_tracer(tr, is_graph(tr));",
            "\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);",
            "\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);",
            "\tunregister_trace_sched_wakeup(probe_wakeup, NULL);",
            "\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);",
            "}",
            "static int __wakeup_tracer_init(struct trace_array *tr)",
            "{",
            "\tsave_flags = tr->trace_flags;",
            "",
            "\t/* non overwrite screws up the latency tracers */",
            "\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);",
            "\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);",
            "",
            "\ttr->max_latency = 0;",
            "\twakeup_trace = tr;",
            "\tftrace_init_array_ops(tr, wakeup_tracer_call);",
            "\tstart_wakeup_tracer(tr);",
            "",
            "\twakeup_busy = true;",
            "\treturn 0;",
            "}",
            "static int wakeup_tracer_init(struct trace_array *tr)",
            "{",
            "\tif (wakeup_busy)",
            "\t\treturn -EBUSY;",
            "",
            "\twakeup_dl = false;",
            "\twakeup_rt = false;",
            "\treturn __wakeup_tracer_init(tr);",
            "}",
            "static int wakeup_rt_tracer_init(struct trace_array *tr)",
            "{",
            "\tif (wakeup_busy)",
            "\t\treturn -EBUSY;",
            "",
            "\twakeup_dl = false;",
            "\twakeup_rt = true;",
            "\treturn __wakeup_tracer_init(tr);",
            "}",
            "static int wakeup_dl_tracer_init(struct trace_array *tr)",
            "{",
            "\tif (wakeup_busy)",
            "\t\treturn -EBUSY;",
            "",
            "\twakeup_dl = true;",
            "\twakeup_rt = false;",
            "\treturn __wakeup_tracer_init(tr);",
            "}"
          ],
          "function_name": "start_wakeup_tracer, stop_wakeup_tracer, __wakeup_tracer_init, wakeup_tracer_init, wakeup_rt_tracer_init, wakeup_dl_tracer_init",
          "description": "实现调度唤醒跟踪器的启动逻辑，注册 sched_wakeup、sched_switch 等 tracepoint 探针，处理注册失败时的资源清理，并通过 smp_wmb() 确保内存屏障顺序。",
          "similarity": 0.5549826622009277
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 1,
          "end_line": 66,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace task wakeup timings",
            " *",
            " * Copyright (C) 2007-2008 Steven Rostedt <srostedt@redhat.com>",
            " * Copyright (C) 2008 Ingo Molnar <mingo@redhat.com>",
            " *",
            " * Based on code from the latency_tracer, that is:",
            " *",
            " *  Copyright (C) 2004-2006 Ingo Molnar",
            " *  Copyright (C) 2004 Nadia Yvette Chambers",
            " */",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/deadline.h>",
            "#include <trace/events/sched.h>",
            "#include \"trace.h\"",
            "",
            "static struct trace_array\t*wakeup_trace;",
            "static int __read_mostly\ttracer_enabled;",
            "",
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_cpu;",
            "static int\t\t\twakeup_current_cpu;",
            "static unsigned\t\t\twakeup_prio = -1;",
            "static bool\t\t\twakeup_rt;",
            "static bool\t\t\twakeup_dl;",
            "static bool\t\t\ttracing_dl;",
            "",
            "static arch_spinlock_t wakeup_lock =",
            "\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int start_func_tracer(struct trace_array *tr, int graph);",
            "static void stop_func_tracer(struct trace_array *tr, int graph);",
            "",
            "static int save_flags;",
            "",
            "#ifdef CONFIG_FUNCTION_GRAPH_TRACER",
            "# define is_graph(tr) ((tr)->trace_flags & TRACE_ITER_DISPLAY_GRAPH)",
            "#else",
            "# define is_graph(tr) false",
            "#endif",
            "",
            "#ifdef CONFIG_FUNCTION_TRACER",
            "",
            "static bool function_enabled;",
            "",
            "/*",
            " * Prologue for the wakeup function tracers.",
            " *",
            " * Returns 1 if it is OK to continue, and preemption",
            " *            is disabled and data->disabled is incremented.",
            " *         0 if the trace is to be ignored, and preemption",
            " *            is not disabled and data->disabled is",
            " *            kept the same.",
            " *",
            " * Note, this function is also used outside this ifdef but",
            " *  inside the #ifdef of the function graph tracer below.",
            " *  This is OK, since the function graph tracer is",
            " *  dependent on the function tracer.",
            " */"
          ],
          "function_name": null,
          "description": "定义调度唤醒跟踪模块的全局变量和锁，包含必要的头文件，为后续跟踪功能提供基础支持。",
          "similarity": 0.5421531796455383
        }
      ]
    }
  ]
}