{
  "query": "管程 定义",
  "timestamp": "2025-12-25 23:45:53",
  "retrieved_files": [
    {
      "source_file": "kernel/kthread.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:30:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kthread.c`\n\n---\n\n# kthread.c 技术文档\n\n## 文件概述\n\n`kthread.c` 是 Linux 内核中实现内核线程（kernel thread, kthread）管理机制的核心文件。它提供了创建、控制、同步和销毁内核线程的基础设施，确保内核线程在干净、受控的环境中运行，即使是从用户空间（如 modprobe、CPU 热插拔等）触发创建也能保证一致性。该文件实现了 kthread 的生命周期管理、状态控制（如停止、暂停）、数据访问接口以及与调度器、cgroup、freezer 等子系统的集成。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct kthread_create_info`**  \n  用于在 `kthread_create()` 和后台守护线程 `kthreadd` 之间传递创建参数和结果，包含线程函数、数据、节点信息、任务结构体指针和完成量。\n\n- **`struct kthread`**  \n  内核线程的私有控制块，挂载在 `task_struct->worker_private` 上，包含：\n  - 状态标志位（`KTHREAD_IS_PER_CPU`, `KTHREAD_SHOULD_STOP`, `KTHREAD_SHOULD_PARK`）\n  - CPU 绑定信息\n  - 线程函数指针和用户数据\n  - 用于同步的 `parked` 和 `exited` 完成量\n  - 完整线程名（当 `task->comm` 被截断时使用）\n  - （可选）块设备 cgroup 上下文（`blkcg_css`）\n\n- **全局变量**\n  - `kthread_create_lock`：保护 `kthread_create_list` 的自旋锁\n  - `kthread_create_list`：待创建内核线程的请求队列\n  - `kthreadd_task`：负责实际创建内核线程的守护进程任务结构体\n\n### 主要函数\n\n- **状态查询函数**\n  - `kthread_should_stop()`：检查是否应停止线程（由 `kthread_stop()` 触发）\n  - `kthread_should_park()`：检查是否应暂停线程（由 `kthread_park()` 触发）\n  - `kthread_should_stop_or_park()`：同时检查停止或暂停请求\n  - `kthread_freezable_should_stop()`：支持冻结的 kthread 停止检查，集成 freezer 机制\n\n- **数据访问函数**\n  - `kthread_func()`：获取线程创建时指定的函数指针\n  - `kthread_data()`：获取线程创建时传入的私有数据\n  - `kthread_probe_data()`：安全地探测可能的 kthread 数据（使用 `copy_from_kernel_nofault` 避免崩溃）\n  - `get_kthread_comm()`：获取完整的线程名称（优先使用 `full_name`）\n\n- **生命周期管理**\n  - `set_kthread_struct()`：为新任务分配并初始化 `struct kthread`\n  - `free_kthread_struct()`：释放 `struct kthread` 及其资源\n  - `kthread_parkme()`：将当前线程置于 `TASK_PARKED` 状态并等待唤醒\n  - `kthread_exit()`：终止当前 kthread 并返回结果（未在代码片段中完整显示）\n\n- **辅助函数**\n  - `to_kthread()` / `__to_kthread()`：从 `task_struct` 安全转换为 `struct kthread`，后者不假设任务一定是 kthread\n\n## 关键实现\n\n### kthread 私有数据管理\n- 每个 kthread 通过 `task_struct->worker_private` 指向其 `struct kthread` 实例。\n- `to_kthread()` 在访问前验证 `PF_KTHREAD` 标志，确保类型安全。\n- `__to_kthread()` 更加保守，仅在同时满足 `worker_private != NULL` 且 `PF_KTHREAD` 时才返回有效指针，以应对 `kernel_thread()` 可能执行 `exec()` 导致标志失效的情况。\n\n### 线程暂停机制（Parking）\n- 使用 `TASK_PARKED` 特殊任务状态，避免与常规调度状态冲突。\n- 在设置状态和检查标志之间使用原子操作，防止唤醒丢失。\n- 调用 `schedule_preempt_disabled()` 禁用抢占，确保 `kthread_park()` 调用者能可靠检测到线程已暂停。\n\n### 安全数据访问\n- `kthread_probe_data()` 使用 `copy_from_kernel_nofault()` 安全读取数据指针，即使目标内存无效也不会导致内核 oops，适用于调试或不确定上下文。\n\n### 冻结集成\n- `kthread_freezable_should_stop()` 在检查停止标志前先处理冻结请求，调用 `__refrigerator()` 进入冻结状态，避免 freezer 与 kthread_stop 死锁。\n\n### 名称管理\n- 当线程名超过 `TASK_COMM_LEN` 时，原始名称存储在 `kthread->full_name` 中，`get_kthread_comm()` 优先返回完整名称。\n\n## 依赖关系\n\n- **调度子系统**：依赖 `sched.h` 提供任务状态管理、调度原语（`schedule()`）、CPU 隔离等。\n- **内存管理**：使用 `slab.h` 分配 `kthread` 结构，`mm.h` 处理内存上下文。\n- **同步机制**：依赖 `completion.h` 实现线程创建和状态同步。\n- **cgroup 子系统**：条件编译支持 `CONFIG_BLK_CGROUP`，集成块设备 cgroup 控制。\n- **冻结子系统**：通过 `freezer.h` 与系统 suspend/hibernate 机制协作。\n- **追踪系统**：集成 `trace/events/sched.h` 提供调度事件追踪。\n- **用户空间接口**：通过 `uaccess.h` 支持安全内核空间访问（用于 `kthread_probe_data`）。\n\n## 使用场景\n\n- **内核模块加载**：`modprobe` 触发的模块可能创建 kthread，需通过 `kthreadd` 确保干净环境。\n- **设备驱动**：驱动程序使用 `kthread_run()` 创建工作线程处理中断下半部或轮询任务。\n- **系统服务线程**：如 `kswapd`（内存回收）、`kcompactd`（内存压缩）等核心内核线程。\n- **CPU 热插拔**：在 CPU 上下线时创建或迁移 per-CPU kthread。\n- **电源管理**：通过 `kthread_freezable_should_stop()` 支持系统 suspend 时冻结 kthread。\n- **动态资源管理**：使用 `kthread_park/unpark` 暂停/恢复线程以节省资源（如空闲时暂停工作线程）。\n- **调试与监控**：工具通过 `kthread_func()` 和 `kthread_data()` 获取线程上下文信息。",
      "similarity": 0.454290509223938,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/kthread.c",
          "start_line": 299,
          "end_line": 413,
          "content": [
            "void kthread_parkme(void)",
            "{",
            "\t__kthread_parkme(to_kthread(current));",
            "}",
            "void __noreturn kthread_exit(long result)",
            "{",
            "\tstruct kthread *kthread = to_kthread(current);",
            "\tkthread->result = result;",
            "\tdo_exit(0);",
            "}",
            "void __noreturn kthread_complete_and_exit(struct completion *comp, long code)",
            "{",
            "\tif (comp)",
            "\t\tcomplete(comp);",
            "",
            "\tkthread_exit(code);",
            "}",
            "static int kthread(void *_create)",
            "{",
            "\tstatic const struct sched_param param = { .sched_priority = 0 };",
            "\t/* Copy data: it's on kthread's stack */",
            "\tstruct kthread_create_info *create = _create;",
            "\tint (*threadfn)(void *data) = create->threadfn;",
            "\tvoid *data = create->data;",
            "\tstruct completion *done;",
            "\tstruct kthread *self;",
            "\tint ret;",
            "",
            "\tself = to_kthread(current);",
            "",
            "\t/* Release the structure when caller killed by a fatal signal. */",
            "\tdone = xchg(&create->done, NULL);",
            "\tif (!done) {",
            "\t\tkfree(create->full_name);",
            "\t\tkfree(create);",
            "\t\tkthread_exit(-EINTR);",
            "\t}",
            "",
            "\tself->full_name = create->full_name;",
            "\tself->threadfn = threadfn;",
            "\tself->data = data;",
            "",
            "\t/*",
            "\t * The new thread inherited kthreadd's priority and CPU mask. Reset",
            "\t * back to default in case they have been changed.",
            "\t */",
            "\tsched_setscheduler_nocheck(current, SCHED_NORMAL, &param);",
            "\tset_cpus_allowed_ptr(current, housekeeping_cpumask(HK_TYPE_KTHREAD));",
            "",
            "\t/* OK, tell user we're spawned, wait for stop or wakeup */",
            "\t__set_current_state(TASK_UNINTERRUPTIBLE);",
            "\tcreate->result = current;",
            "\t/*",
            "\t * Thread is going to call schedule(), do not preempt it,",
            "\t * or the creator may spend more time in wait_task_inactive().",
            "\t */",
            "\tpreempt_disable();",
            "\tcomplete(done);",
            "\tschedule_preempt_disabled();",
            "\tpreempt_enable();",
            "",
            "\tret = -EINTR;",
            "\tif (!test_bit(KTHREAD_SHOULD_STOP, &self->flags)) {",
            "\t\tcgroup_kthread_ready();",
            "\t\t__kthread_parkme(self);",
            "\t\tret = threadfn(data);",
            "\t}",
            "\tkthread_exit(ret);",
            "}",
            "int tsk_fork_get_node(struct task_struct *tsk)",
            "{",
            "#ifdef CONFIG_NUMA",
            "\tif (tsk == kthreadd_task)",
            "\t\treturn tsk->pref_node_fork;",
            "#endif",
            "\treturn NUMA_NO_NODE;",
            "}",
            "static void create_kthread(struct kthread_create_info *create)",
            "{",
            "\tint pid;",
            "",
            "#ifdef CONFIG_NUMA",
            "\tcurrent->pref_node_fork = create->node;",
            "#endif",
            "\t/* We want our own signal handler (we take no signals by default). */",
            "\tpid = kernel_thread(kthread, create, create->full_name,",
            "\t\t\t    CLONE_FS | CLONE_FILES | SIGCHLD);",
            "\tif (pid < 0) {",
            "\t\t/* Release the structure when caller killed by a fatal signal. */",
            "\t\tstruct completion *done = xchg(&create->done, NULL);",
            "",
            "\t\tkfree(create->full_name);",
            "\t\tif (!done) {",
            "\t\t\tkfree(create);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tcreate->result = ERR_PTR(pid);",
            "\t\tcomplete(done);",
            "\t}",
            "}",
            "static void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!wait_task_inactive(p, state)) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* It's safe because the task is inactive. */",
            "\traw_spin_lock_irqsave(&p->pi_lock, flags);",
            "\tdo_set_cpus_allowed(p, mask);",
            "\tp->flags |= PF_NO_SETAFFINITY;",
            "\traw_spin_unlock_irqrestore(&p->pi_lock, flags);",
            "}"
          ],
          "function_name": "kthread_parkme, kthread_exit, kthread_complete_and_exit, kthread, tsk_fork_get_node, create_kthread, __kthread_bind_mask",
          "description": "处理线程执行流程、节点绑定及异常退出，kthread作为内核线程入口执行指定函数，create_kthread创建新线程并绑定CPU，__kthread_bind_mask调整线程CPU亲和性。",
          "similarity": 0.47612541913986206
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/kthread.c",
          "start_line": 1,
          "end_line": 101,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Kernel thread helper functions.",
            " *   Copyright (C) 2004 IBM Corporation, Rusty Russell.",
            " *   Copyright (C) 2009 Red Hat, Inc.",
            " *",
            " * Creation is done via kthreadd, so that we get a clean environment",
            " * even if we're invoked from userspace (think modprobe, hotplug cpu,",
            " * etc.).",
            " */",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/mm.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/err.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/unistd.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/isolation.h>",
            "#include <trace/events/sched.h>",
            "",
            "#ifdef CONFIG_IEE",
            "#include <asm/iee-token.h>",
            "#endif",
            "",
            "static DEFINE_SPINLOCK(kthread_create_lock);",
            "static LIST_HEAD(kthread_create_list);",
            "struct task_struct *kthreadd_task;",
            "",
            "struct kthread_create_info",
            "{",
            "\t/* Information passed to kthread() from kthreadd. */",
            "\tchar *full_name;",
            "\tint (*threadfn)(void *data);",
            "\tvoid *data;",
            "\tint node;",
            "",
            "\t/* Result passed back to kthread_create() from kthreadd. */",
            "\tstruct task_struct *result;",
            "\tstruct completion *done;",
            "",
            "\tstruct list_head list;",
            "};",
            "",
            "struct kthread {",
            "\tunsigned long flags;",
            "\tunsigned int cpu;",
            "\tint result;",
            "\tint (*threadfn)(void *);",
            "\tvoid *data;",
            "\tstruct completion parked;",
            "\tstruct completion exited;",
            "#ifdef CONFIG_BLK_CGROUP",
            "\tstruct cgroup_subsys_state *blkcg_css;",
            "#endif",
            "\t/* To store the full name if task comm is truncated. */",
            "\tchar *full_name;",
            "};",
            "",
            "enum KTHREAD_BITS {",
            "\tKTHREAD_IS_PER_CPU = 0,",
            "\tKTHREAD_SHOULD_STOP,",
            "\tKTHREAD_SHOULD_PARK,",
            "};",
            "",
            "static inline struct kthread *to_kthread(struct task_struct *k)",
            "{",
            "\tWARN_ON(!(k->flags & PF_KTHREAD));",
            "\treturn k->worker_private;",
            "}",
            "",
            "/*",
            " * Variant of to_kthread() that doesn't assume @p is a kthread.",
            " *",
            " * Per construction; when:",
            " *",
            " *   (p->flags & PF_KTHREAD) && p->worker_private",
            " *",
            " * the task is both a kthread and struct kthread is persistent. However",
            " * PF_KTHREAD on it's own is not, kernel_thread() can exec() (See umh.c and",
            " * begin_new_exec()).",
            " */",
            "static inline struct kthread *__to_kthread(struct task_struct *p)",
            "{",
            "\tvoid *kthread = p->worker_private;",
            "\tif (kthread && !(p->flags & PF_KTHREAD))",
            "\t\tkthread = NULL;",
            "\treturn kthread;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义内核线程辅助函数所需的数据结构和全局变量，包括用于管理线程创建的锁、链表头、任务结构体及标志位枚举，核心功能是为后续内核线程创建和管理提供基础设施。",
          "similarity": 0.4648210406303406
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/kthread.c",
          "start_line": 538,
          "end_line": 639,
          "content": [
            "static void __kthread_bind(struct task_struct *p, unsigned int cpu, unsigned int state)",
            "{",
            "\t__kthread_bind_mask(p, cpumask_of(cpu), state);",
            "}",
            "void kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)",
            "{",
            "\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);",
            "}",
            "void kthread_bind(struct task_struct *p, unsigned int cpu)",
            "{",
            "\t__kthread_bind(p, cpu, TASK_UNINTERRUPTIBLE);",
            "}",
            "void kthread_set_per_cpu(struct task_struct *k, int cpu)",
            "{",
            "\tstruct kthread *kthread = to_kthread(k);",
            "\tif (!kthread)",
            "\t\treturn;",
            "",
            "\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));",
            "",
            "\tif (cpu < 0) {",
            "\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);",
            "\t\treturn;",
            "\t}",
            "",
            "\tkthread->cpu = cpu;",
            "\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);",
            "}",
            "bool kthread_is_per_cpu(struct task_struct *p)",
            "{",
            "\tstruct kthread *kthread = __to_kthread(p);",
            "\tif (!kthread)",
            "\t\treturn false;",
            "",
            "\treturn test_bit(KTHREAD_IS_PER_CPU, &kthread->flags);",
            "}",
            "void kthread_unpark(struct task_struct *k)",
            "{",
            "\tstruct kthread *kthread = to_kthread(k);",
            "",
            "\tif (!test_bit(KTHREAD_SHOULD_PARK, &kthread->flags))",
            "\t\treturn;",
            "\t/*",
            "\t * Newly created kthread was parked when the CPU was offline.",
            "\t * The binding was lost and we need to set it again.",
            "\t */",
            "\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))",
            "\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);",
            "",
            "\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);",
            "\t/*",
            "\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.",
            "\t */",
            "\twake_up_state(k, TASK_PARKED);",
            "}",
            "int kthread_park(struct task_struct *k)",
            "{",
            "\tstruct kthread *kthread = to_kthread(k);",
            "",
            "\tif (WARN_ON(k->flags & PF_EXITING))",
            "\t\treturn -ENOSYS;",
            "",
            "\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))",
            "\t\treturn -EBUSY;",
            "",
            "\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);",
            "\tif (k != current) {",
            "\t\twake_up_process(k);",
            "\t\t/*",
            "\t\t * Wait for __kthread_parkme() to complete(), this means we",
            "\t\t * _will_ have TASK_PARKED and are about to call schedule().",
            "\t\t */",
            "\t\twait_for_completion(&kthread->parked);",
            "\t\t/*",
            "\t\t * Now wait for that schedule() to complete and the task to",
            "\t\t * get scheduled out.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int kthread_stop(struct task_struct *k)",
            "{",
            "\tstruct kthread *kthread;",
            "\tint ret;",
            "",
            "\ttrace_sched_kthread_stop(k);",
            "",
            "\tget_task_struct(k);",
            "\tkthread = to_kthread(k);",
            "\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);",
            "\tkthread_unpark(k);",
            "\tset_tsk_thread_flag(k, TIF_NOTIFY_SIGNAL);",
            "\twake_up_process(k);",
            "\twait_for_completion(&kthread->exited);",
            "\tret = kthread->result;",
            "\tput_task_struct(k);",
            "",
            "\ttrace_sched_kthread_stop_ret(ret);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__kthread_bind, kthread_bind_mask, kthread_bind, kthread_set_per_cpu, kthread_is_per_cpu, kthread_unpark, kthread_park, kthread_stop",
          "description": "提供线程CPU绑定、停放/终止控制接口，kthread_park/kthread_stop修改线程状态标志并触发唤醒，kthread_is_per_cpu检测线程是否固定CPU运行。",
          "similarity": 0.4389558434486389
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kthread.c",
          "start_line": 102,
          "end_line": 211,
          "content": [
            "void get_kthread_comm(char *buf, size_t buf_size, struct task_struct *tsk)",
            "{",
            "\tstruct kthread *kthread = to_kthread(tsk);",
            "",
            "\tif (!kthread || !kthread->full_name) {",
            "\t\t__get_task_comm(buf, buf_size, tsk);",
            "\t\treturn;",
            "\t}",
            "",
            "\tstrscpy_pad(buf, kthread->full_name, buf_size);",
            "}",
            "bool set_kthread_struct(struct task_struct *p)",
            "{",
            "\tstruct kthread *kthread;",
            "",
            "\tif (WARN_ON_ONCE(to_kthread(p)))",
            "\t\treturn false;",
            "",
            "\tkthread = kzalloc(sizeof(*kthread), GFP_KERNEL);",
            "\tif (!kthread)",
            "\t\treturn false;",
            "",
            "\tinit_completion(&kthread->exited);",
            "\tinit_completion(&kthread->parked);",
            "\tp->vfork_done = &kthread->exited;",
            "",
            "\tp->worker_private = kthread;",
            "\treturn true;",
            "}",
            "void free_kthread_struct(struct task_struct *k)",
            "{",
            "\tstruct kthread *kthread;",
            "",
            "\t/*",
            "\t * Can be NULL if kmalloc() in set_kthread_struct() failed.",
            "\t */",
            "\tkthread = to_kthread(k);",
            "\tif (!kthread)",
            "\t\treturn;",
            "",
            "#ifdef CONFIG_BLK_CGROUP",
            "\tWARN_ON_ONCE(kthread->blkcg_css);",
            "#endif",
            "\tk->worker_private = NULL;",
            "\tkfree(kthread->full_name);",
            "\tkfree(kthread);",
            "}",
            "bool kthread_should_stop(void)",
            "{",
            "\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);",
            "}",
            "static bool __kthread_should_park(struct task_struct *k)",
            "{",
            "\treturn test_bit(KTHREAD_SHOULD_PARK, &to_kthread(k)->flags);",
            "}",
            "bool kthread_should_park(void)",
            "{",
            "\treturn __kthread_should_park(current);",
            "}",
            "bool kthread_should_stop_or_park(void)",
            "{",
            "\tstruct kthread *kthread = __to_kthread(current);",
            "",
            "\tif (!kthread)",
            "\t\treturn false;",
            "",
            "\treturn kthread->flags & (BIT(KTHREAD_SHOULD_STOP) | BIT(KTHREAD_SHOULD_PARK));",
            "}",
            "bool kthread_freezable_should_stop(bool *was_frozen)",
            "{",
            "\tbool frozen = false;",
            "",
            "\tmight_sleep();",
            "",
            "\tif (unlikely(freezing(current)))",
            "\t\tfrozen = __refrigerator(true);",
            "",
            "\tif (was_frozen)",
            "\t\t*was_frozen = frozen;",
            "",
            "\treturn kthread_should_stop();",
            "}",
            "static void __kthread_parkme(struct kthread *self)",
            "{",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * TASK_PARKED is a special state; we must serialize against",
            "\t\t * possible pending wakeups to avoid store-store collisions on",
            "\t\t * task->state.",
            "\t\t *",
            "\t\t * Such a collision might possibly result in the task state",
            "\t\t * changin from TASK_PARKED and us failing the",
            "\t\t * wait_task_inactive() in kthread_park().",
            "\t\t */",
            "\t\tset_special_state(TASK_PARKED);",
            "\t\tif (!test_bit(KTHREAD_SHOULD_PARK, &self->flags))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * Thread is going to call schedule(), do not preempt it,",
            "\t\t * or the caller of kthread_park() may spend more time in",
            "\t\t * wait_task_inactive().",
            "\t\t */",
            "\t\tpreempt_disable();",
            "\t\tcomplete(&self->parked);",
            "\t\tschedule_preempt_disabled();",
            "\t\tpreempt_enable();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "}"
          ],
          "function_name": "get_kthread_comm, set_kthread_struct, free_kthread_struct, kthread_should_stop, __kthread_should_park, kthread_should_park, kthread_should_stop_or_park, kthread_freezable_should_stop, __kthread_parkme",
          "description": "实现内核线程的名称获取、结构体分配与释放、状态检测等功能，set_kthread_struct分配并初始化线程结构体，kthread_should_stop系列函数检测线程终止或停放标志。",
          "similarity": 0.43582865595817566
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/kthread.c",
          "start_line": 982,
          "end_line": 1095,
          "content": [
            "static inline bool queuing_blocked(struct kthread_worker *worker,",
            "\t\t\t\t   struct kthread_work *work)",
            "{",
            "\tlockdep_assert_held(&worker->lock);",
            "",
            "\treturn !list_empty(&work->node) || work->canceling;",
            "}",
            "static void kthread_insert_work_sanity_check(struct kthread_worker *worker,",
            "\t\t\t\t\t     struct kthread_work *work)",
            "{",
            "\tlockdep_assert_held(&worker->lock);",
            "\tWARN_ON_ONCE(!list_empty(&work->node));",
            "\t/* Do not use a work with >1 worker, see kthread_queue_work() */",
            "\tWARN_ON_ONCE(work->worker && work->worker != worker);",
            "}",
            "static void kthread_insert_work(struct kthread_worker *worker,",
            "\t\t\t\tstruct kthread_work *work,",
            "\t\t\t\tstruct list_head *pos)",
            "{",
            "\tkthread_insert_work_sanity_check(worker, work);",
            "",
            "\ttrace_sched_kthread_work_queue_work(worker, work);",
            "",
            "\tlist_add_tail(&work->node, pos);",
            "\twork->worker = worker;",
            "\tif (!worker->current_work && likely(worker->task))",
            "\t\twake_up_process(worker->task);",
            "}",
            "bool kthread_queue_work(struct kthread_worker *worker,",
            "\t\t\tstruct kthread_work *work)",
            "{",
            "\tbool ret = false;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "\tif (!queuing_blocked(worker, work)) {",
            "\t\tkthread_insert_work(worker, work, &worker->work_list);",
            "\t\tret = true;",
            "\t}",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "\treturn ret;",
            "}",
            "void kthread_delayed_work_timer_fn(struct timer_list *t)",
            "{",
            "\tstruct kthread_delayed_work *dwork = from_timer(dwork, t, timer);",
            "\tstruct kthread_work *work = &dwork->work;",
            "\tstruct kthread_worker *worker = work->worker;",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * This might happen when a pending work is reinitialized.",
            "\t * It means that it is used a wrong way.",
            "\t */",
            "\tif (WARN_ON_ONCE(!worker))",
            "\t\treturn;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "\t/* Work must not be used with >1 worker, see kthread_queue_work(). */",
            "\tWARN_ON_ONCE(work->worker != worker);",
            "",
            "\t/* Move the work from worker->delayed_work_list. */",
            "\tWARN_ON_ONCE(list_empty(&work->node));",
            "\tlist_del_init(&work->node);",
            "\tif (!work->canceling)",
            "\t\tkthread_insert_work(worker, work, &worker->work_list);",
            "",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "}",
            "static void __kthread_queue_delayed_work(struct kthread_worker *worker,",
            "\t\t\t\t\t struct kthread_delayed_work *dwork,",
            "\t\t\t\t\t unsigned long delay)",
            "{",
            "\tstruct timer_list *timer = &dwork->timer;",
            "\tstruct kthread_work *work = &dwork->work;",
            "",
            "\tWARN_ON_ONCE(timer->function != kthread_delayed_work_timer_fn);",
            "",
            "\t/*",
            "\t * If @delay is 0, queue @dwork->work immediately.  This is for",
            "\t * both optimization and correctness.  The earliest @timer can",
            "\t * expire is on the closest next tick and delayed_work users depend",
            "\t * on that there's no such delay when @delay is 0.",
            "\t */",
            "\tif (!delay) {",
            "\t\tkthread_insert_work(worker, work, &worker->work_list);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Be paranoid and try to detect possible races already now. */",
            "\tkthread_insert_work_sanity_check(worker, work);",
            "",
            "\tlist_add(&work->node, &worker->delayed_work_list);",
            "\twork->worker = worker;",
            "\ttimer->expires = jiffies + delay;",
            "\tadd_timer(timer);",
            "}",
            "bool kthread_queue_delayed_work(struct kthread_worker *worker,",
            "\t\t\t\tstruct kthread_delayed_work *dwork,",
            "\t\t\t\tunsigned long delay)",
            "{",
            "\tstruct kthread_work *work = &dwork->work;",
            "\tunsigned long flags;",
            "\tbool ret = false;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "",
            "\tif (!queuing_blocked(worker, work)) {",
            "\t\t__kthread_queue_delayed_work(worker, dwork, delay);",
            "\t\tret = true;",
            "\t}",
            "",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "queuing_blocked, kthread_insert_work_sanity_check, kthread_insert_work, kthread_queue_work, kthread_delayed_work_timer_fn, __kthread_queue_delayed_work, kthread_queue_delayed_work",
          "description": "实现kthread_worker与kthread_work的队列管理，包含插入/延迟插入逻辑、锁保护及任务唤醒机制，处理工作项状态校验和延迟定时器回调",
          "similarity": 0.42949745059013367
        }
      ]
    },
    {
      "source_file": "kernel/watch_queue.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:50:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watch_queue.c`\n\n---\n\n# watch_queue.c 技术文档\n\n## 文件概述\n\n`watch_queue.c` 实现了 Linux 内核中的**监视队列**（Watch Queue）机制，这是一种基于管道（pipe）构建的通用事件通知系统。该机制允许内核子系统（如文件系统、密钥管理、设备驱动等）向用户空间异步发送结构化通知。用户空间通过创建特殊类型的管道并关联监视队列，即可接收来自内核的各类事件通知。该文件定义了通知的投递、过滤、缓冲管理及与管道集成的核心逻辑。\n\n## 核心功能\n\n### 主要函数\n\n- **`__post_watch_notification()`**  \n  核心通知投递函数。遍历指定 `watch_list` 中所有匹配 `id` 的监视器（`watch`），对每个关联的 `watch_queue` 应用过滤规则、安全检查，并将通知写入底层管道。\n\n- **`post_one_notification()`**  \n  将单个通知写入指定 `watch_queue` 的底层管道缓冲区。负责从预分配的通知页中获取空闲槽位、填充数据、更新管道头指针并唤醒等待读取的进程。\n\n- **`filter_watch_notification()`**  \n  根据 `watch_filter` 中的类型、子类型和信息掩码规则，判断是否允许特定通知通过。\n\n- **`watch_queue_set_size()`**  \n  为监视队列分配预分配的通知缓冲区（页数组和位图），并调整底层管道的环形缓冲区大小。\n\n- **`watch_queue_pipe_buf_release()`**  \n  管道缓冲区释放回调。当用户空间读取完通知后，将对应的通知槽位在位图中标记为空闲，供后续复用。\n\n### 关键数据结构\n\n- **`struct watch_queue`**  \n  表示一个监视队列，包含：\n  - 指向底层 `pipe_inode_info` 的指针\n  - 预分配的通知页数组（`notes`）\n  - 通知槽位空闲位图（`notes_bitmap`）\n  - 通知过滤器（`filter`）\n  - 保护锁（`lock`）\n\n- **`struct watch_notification`**  \n  通用通知记录格式，包含类型（`type`）、子类型（`subtype`）、信息字段（`info`，含长度和ID）及可变负载。\n\n- **`struct watch_filter` / `struct watch_type_filter`**  \n  定义通知过滤规则，支持按类型、子类型及信息字段的位掩码进行精确过滤。\n\n- **`watch_queue_pipe_buf_ops`**  \n  自定义的 `pipe_buf_operations`，用于管理监视队列专用管道缓冲区的生命周期。\n\n## 关键实现\n\n### 基于管道的通知传输\n- 监视队列复用内核管道（`pipe_inode_info`）作为通知传输通道，利用其成熟的读写、轮询、异步通知机制。\n- 通过自定义 `pipe_buf_operations`（`watch_queue_pipe_buf_ops`）实现通知槽位的回收：当用户读取通知后，`release` 回调将对应槽位在 `notes_bitmap` 中置位，标记为空闲。\n\n### 预分配通知缓冲区\n- 通知数据存储在预分配的内核页（`notes`）中，每页划分为多个固定大小（128字节）的槽位（`WATCH_QUEUE_NOTE_SIZE`）。\n- 使用位图（`notes_bitmap`）跟踪槽位使用状态，1 表示空闲。投递通知时通过 `find_first_bit()` 快速查找空闲槽位。\n- 缓冲区大小由用户通过 `watch_queue_set_size()` 设置（1-512个通知），并受管道缓冲区配额限制。\n\n### 通知投递流程\n1. **匹配监视器**：遍历 `watch_list`，查找 `id` 匹配的 `watch`。\n2. **应用过滤**：若队列配置了过滤器，调用 `filter_watch_notification()` 决定是否丢弃。\n3. **安全检查**：调用 LSM 钩子 `security_post_notification()` 进行权限验证。\n4. **写入管道**：\n   - 获取空闲通知槽位，复制通知数据。\n   - 构造 `pipe_buffer` 指向该槽位，设置自定义操作集。\n   - 更新管道 `head` 指针，唤醒等待读取的进程。\n   - 若缓冲区满，标记前一个缓冲区为 `PIPE_BUF_FLAG_LOSS` 表示丢包。\n\n### 并发与同步\n- **RCU 保护**：`watch_list` 和 `watch_queue` 的访问通过 RCU 机制保护，确保遍历时结构体不被释放。\n- **自旋锁**：\n  - `wqueue->lock`：保护 `wqueue` 状态（如 `pipe` 指针有效性）。\n  - `pipe->rd_wait.lock`：保护管道环形缓冲区的读写操作。\n- **原子操作**：管道 `head` 指针使用 `smp_store_release()` 更新，确保与 `pipe_read()` 的同步。\n\n## 依赖关系\n\n- **管道子系统**（`fs/pipe.c`）  \n  依赖管道的核心数据结构（`pipe_inode_info`、`pipe_buffer`）和操作接口（`pipe_buf()`、`pipe_full()`、`generic_pipe_buf_*`）。\n\n- **内存管理**  \n  使用 `alloc_page()`、`kmap_atomic()` 管理通知缓冲区页，`bitmap_alloc()` 管理槽位位图。\n\n- **安全模块**（LSM）  \n  通过 `security_post_notification()` 钩子集成安全策略。\n\n- **用户空间接口**  \n  与 `fs/watch_queue.c` 中的系统调用（如 `watch_queue_set_size()`）协同工作，后者负责创建监视队列并与管道关联。\n\n- **头文件依赖**  \n  `linux/watch_queue.h`（核心数据结构定义）、`linux/pipe_fs_i.h`（管道内部接口）。\n\n## 使用场景\n\n- **文件系统事件监控**  \n  如 `fsnotify` 子系统可通过监视队列向用户空间报告文件访问、修改等事件。\n\n- **密钥管理通知**  \n  内核密钥环（`KEYS`）子系统使用该机制通知密钥状态变更（如过期、撤销）。\n\n- **设备事件上报**  \n  设备驱动可利用监视队列异步上报硬件状态变化或错误事件。\n\n- **通用内核事件分发**  \n  任何需要向特权用户空间守护进程（如 `systemd`）发送结构化事件的内核子系统均可集成此机制。\n\n- **用户空间消费**  \n  应用程序通过 `open(\"/dev/watch_queue\")` 获取监视队列文件描述符，调用 `ioctl()` 设置缓冲区大小和过滤器，然后像读取普通管道一样接收通知。",
      "similarity": 0.45424312353134155,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/watch_queue.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Watch queue and general notification mechanism, built on pipes",
            " *",
            " * Copyright (C) 2020 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " *",
            " * See Documentation/core-api/watch_queue.rst",
            " */",
            "",
            "#define pr_fmt(fmt) \"watchq: \" fmt",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/pipe_fs_i.h>",
            "",
            "MODULE_DESCRIPTION(\"Watch queue\");",
            "MODULE_AUTHOR(\"Red Hat, Inc.\");",
            "",
            "#define WATCH_QUEUE_NOTE_SIZE 128",
            "#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)",
            "",
            "/*",
            " * This must be called under the RCU read-lock, which makes",
            " * sure that the wqueue still exists. It can then take the lock,",
            " * and check that the wqueue hasn't been destroyed, which in",
            " * turn makes sure that the notification pipe still exists.",
            " */"
          ],
          "function_name": null,
          "description": "定义了watch_queue模块的头部信息，包含常量WATCH_QUEUE_NOTE_SIZE和NOTES_PER_PAGE，声明模块许可证及作者信息，并引入相关内核头文件，为后续实现提供基础框架。",
          "similarity": 0.38894203305244446
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/watch_queue.c",
          "start_line": 42,
          "end_line": 154,
          "content": [
            "static inline bool lock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_lock_bh(&wqueue->lock);",
            "\tif (unlikely(!wqueue->pipe)) {",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static inline void unlock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_unlock_bh(&wqueue->lock);",
            "}",
            "static void watch_queue_pipe_buf_release(struct pipe_inode_info *pipe,",
            "\t\t\t\t\t struct pipe_buffer *buf)",
            "{",
            "\tstruct watch_queue *wqueue = (struct watch_queue *)buf->private;",
            "\tstruct page *page;",
            "\tunsigned int bit;",
            "",
            "\t/* We need to work out which note within the page this refers to, but",
            "\t * the note might have been maximum size, so merely ANDing the offset",
            "\t * off doesn't work.  OTOH, the note must've been more than zero size.",
            "\t */",
            "\tbit = buf->offset + buf->len;",
            "\tif ((bit & (WATCH_QUEUE_NOTE_SIZE - 1)) == 0)",
            "\t\tbit -= WATCH_QUEUE_NOTE_SIZE;",
            "\tbit /= WATCH_QUEUE_NOTE_SIZE;",
            "",
            "\tpage = buf->page;",
            "\tbit += page->index;",
            "",
            "\tset_bit(bit, wqueue->notes_bitmap);",
            "\tgeneric_pipe_buf_release(pipe, buf);",
            "}",
            "static bool post_one_notification(struct watch_queue *wqueue,",
            "\t\t\t\t  struct watch_notification *n)",
            "{",
            "\tvoid *p;",
            "\tstruct pipe_inode_info *pipe = wqueue->pipe;",
            "\tstruct pipe_buffer *buf;",
            "\tstruct page *page;",
            "\tunsigned int head, tail, note, offset, len;",
            "\tbool done = false;",
            "",
            "\tspin_lock_irq(&pipe->rd_wait.lock);",
            "",
            "\thead = pipe->head;",
            "\ttail = pipe->tail;",
            "\tif (pipe_full(head, tail, pipe->ring_size))",
            "\t\tgoto lost;",
            "",
            "\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);",
            "\tif (note >= wqueue->nr_notes)",
            "\t\tgoto lost;",
            "",
            "\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];",
            "\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;",
            "\tget_page(page);",
            "\tlen = n->info & WATCH_INFO_LENGTH;",
            "\tp = kmap_atomic(page);",
            "\tmemcpy(p + offset, n, len);",
            "\tkunmap_atomic(p);",
            "",
            "\tbuf = pipe_buf(pipe, head);",
            "\tbuf->page = page;",
            "\tbuf->private = (unsigned long)wqueue;",
            "\tbuf->ops = &watch_queue_pipe_buf_ops;",
            "\tbuf->offset = offset;",
            "\tbuf->len = len;",
            "\tbuf->flags = PIPE_BUF_FLAG_WHOLE;",
            "\tsmp_store_release(&pipe->head, head + 1); /* vs pipe_read() */",
            "",
            "\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {",
            "\t\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\t\tBUG();",
            "\t}",
            "\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);",
            "\tdone = true;",
            "",
            "out:",
            "\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\tif (done)",
            "\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);",
            "\treturn done;",
            "",
            "lost:",
            "\tbuf = pipe_buf(pipe, head - 1);",
            "\tbuf->flags |= PIPE_BUF_FLAG_LOSS;",
            "\tgoto out;",
            "}",
            "static bool filter_watch_notification(const struct watch_filter *wf,",
            "\t\t\t\t      const struct watch_notification *n)",
            "{",
            "\tconst struct watch_type_filter *wt;",
            "\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;",
            "\tunsigned int st_index = n->subtype / st_bits;",
            "\tunsigned int st_bit = 1U << (n->subtype % st_bits);",
            "\tint i;",
            "",
            "\tif (!test_bit(n->type, wf->type_filter))",
            "\t\treturn false;",
            "",
            "\tfor (i = 0; i < wf->nr_filters; i++) {",
            "\t\twt = &wf->filters[i];",
            "\t\tif (n->type == wt->type &&",
            "\t\t    (wt->subtype_filter[st_index] & st_bit) &&",
            "\t\t    (n->info & wt->info_mask) == wt->info_filter)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false; /* If there is a filter, the default is to reject. */",
            "}"
          ],
          "function_name": "lock_wqueue, unlock_wqueue, watch_queue_pipe_buf_release, post_one_notification, filter_watch_notification",
          "description": "实现了watch_queue的锁操作、缓冲区释放、通知提交及过滤逻辑。lock_wqueue/unlock_wqueue用于保护队列访问，watch_queue_pipe_buf_release处理缓冲区回收并更新位图，post_one_notification将通知数据写入管道，filter_watch_notification进行类型和子类型的匹配判断。",
          "similarity": 0.3840349018573761
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/watch_queue.c",
          "start_line": 602,
          "end_line": 680,
          "content": [
            "void watch_queue_clear(struct watch_queue *wqueue)",
            "{",
            "\tstruct watch_list *wlist;",
            "\tstruct watch *watch;",
            "\tbool release;",
            "",
            "\trcu_read_lock();",
            "\tspin_lock_bh(&wqueue->lock);",
            "",
            "\t/*",
            "\t * This pipe can be freed by callers like free_pipe_info().",
            "\t * Removing this reference also prevents new notifications.",
            "\t */",
            "\twqueue->pipe = NULL;",
            "",
            "\twhile (!hlist_empty(&wqueue->watches)) {",
            "\t\twatch = hlist_entry(wqueue->watches.first, struct watch, queue_node);",
            "\t\thlist_del_init_rcu(&watch->queue_node);",
            "\t\t/* We now own a ref on the watch. */",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "",
            "\t\t/* We can't do the next bit under the queue lock as we need to",
            "\t\t * get the list lock - which would cause a deadlock if someone",
            "\t\t * was removing from the opposite direction at the same time or",
            "\t\t * posting a notification.",
            "\t\t */",
            "\t\twlist = rcu_dereference(watch->watch_list);",
            "\t\tif (wlist) {",
            "\t\t\tvoid (*release_watch)(struct watch *);",
            "",
            "\t\t\tspin_lock(&wlist->lock);",
            "",
            "\t\t\trelease = !hlist_unhashed(&watch->list_node);",
            "\t\t\tif (release) {",
            "\t\t\t\thlist_del_init_rcu(&watch->list_node);",
            "\t\t\t\trcu_assign_pointer(watch->watch_list, NULL);",
            "",
            "\t\t\t\t/* We now own a second ref on the watch. */",
            "\t\t\t}",
            "",
            "\t\t\trelease_watch = wlist->release_watch;",
            "\t\t\tspin_unlock(&wlist->lock);",
            "",
            "\t\t\tif (release) {",
            "\t\t\t\tif (release_watch) {",
            "\t\t\t\t\trcu_read_unlock();",
            "\t\t\t\t\t/* This might need to call dput(), so",
            "\t\t\t\t\t * we have to drop all the locks.",
            "\t\t\t\t\t */",
            "\t\t\t\t\t(*release_watch)(watch);",
            "\t\t\t\t\trcu_read_lock();",
            "\t\t\t\t}",
            "\t\t\t\tput_watch(watch);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tput_watch(watch);",
            "\t\tspin_lock_bh(&wqueue->lock);",
            "\t}",
            "",
            "\tspin_unlock_bh(&wqueue->lock);",
            "\trcu_read_unlock();",
            "}",
            "int watch_queue_init(struct pipe_inode_info *pipe)",
            "{",
            "\tstruct watch_queue *wqueue;",
            "",
            "\twqueue = kzalloc(sizeof(*wqueue), GFP_KERNEL);",
            "\tif (!wqueue)",
            "\t\treturn -ENOMEM;",
            "",
            "\twqueue->pipe = pipe;",
            "\tkref_init(&wqueue->usage);",
            "\tspin_lock_init(&wqueue->lock);",
            "\tINIT_HLIST_HEAD(&wqueue->watches);",
            "",
            "\tpipe->watch_queue = wqueue;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "watch_queue_clear, watch_queue_init",
          "description": "该代码实现了监视队列的初始化与清理功能。  \n`watch_queue_clear`通过RCU和自旋锁机制安全地移除所有监视项并释放资源，`watch_queue_init`初始化监视队列结构并绑定至管道对象。  \n上下文不完整：`release_watch`等关键函数依赖外部定义，部分RCU回调逻辑未完全展示。",
          "similarity": 0.37105274200439453
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watch_queue.c",
          "start_line": 193,
          "end_line": 304,
          "content": [
            "void __post_watch_notification(struct watch_list *wlist,",
            "\t\t\t       struct watch_notification *n,",
            "\t\t\t       const struct cred *cred,",
            "\t\t\t       u64 id)",
            "{",
            "\tconst struct watch_filter *wf;",
            "\tstruct watch_queue *wqueue;",
            "\tstruct watch *watch;",
            "",
            "\tif (((n->info & WATCH_INFO_LENGTH) >> WATCH_INFO_LENGTH__SHIFT) == 0) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\trcu_read_lock();",
            "",
            "\thlist_for_each_entry_rcu(watch, &wlist->watchers, list_node) {",
            "\t\tif (watch->id != id)",
            "\t\t\tcontinue;",
            "\t\tn->info &= ~WATCH_INFO_ID;",
            "\t\tn->info |= watch->info_id;",
            "",
            "\t\twqueue = rcu_dereference(watch->queue);",
            "\t\twf = rcu_dereference(wqueue->filter);",
            "\t\tif (wf && !filter_watch_notification(wf, n))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (security_post_notification(watch->cred, cred, n) < 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (lock_wqueue(wqueue)) {",
            "\t\t\tpost_one_notification(wqueue, n);",
            "\t\t\tunlock_wqueue(wqueue);",
            "\t\t}",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "}",
            "long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)",
            "{",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tstruct page **pages;",
            "\tunsigned long *bitmap;",
            "\tunsigned long user_bufs;",
            "\tint ret, i, nr_pages;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "\tif (wqueue->notes)",
            "\t\treturn -EBUSY;",
            "",
            "\tif (nr_notes < 1 ||",
            "\t    nr_notes > 512) /* TODO: choose a better hard limit */",
            "\t\treturn -EINVAL;",
            "",
            "\tnr_pages = (nr_notes + WATCH_QUEUE_NOTES_PER_PAGE - 1);",
            "\tnr_pages /= WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tuser_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_pages);",
            "",
            "\tif (nr_pages > pipe->max_usage &&",
            "\t    (too_many_pipe_buffers_hard(user_bufs) ||",
            "\t     too_many_pipe_buffers_soft(user_bufs)) &&",
            "\t    pipe_is_unprivileged_user()) {",
            "\t\tret = -EPERM;",
            "\t\tgoto error;",
            "\t}",
            "",
            "\tnr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "",
            "\t/*",
            "\t * pipe_resize_ring() does not update nr_accounted for watch_queue",
            "\t * pipes, because the above vastly overprovisions. Set nr_accounted on",
            "\t * and max_usage this pipe to the number that was actually charged to",
            "\t * the user above via account_pipe_buffers.",
            "\t */",
            "\tpipe->max_usage = nr_pages;",
            "\tpipe->nr_accounted = nr_pages;",
            "",
            "\tret = -ENOMEM;",
            "\tpages = kcalloc(sizeof(struct page *), nr_pages, GFP_KERNEL);",
            "\tif (!pages)",
            "\t\tgoto error;",
            "",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tpages[i] = alloc_page(GFP_KERNEL);",
            "\t\tif (!pages[i])",
            "\t\t\tgoto error_p;",
            "\t\tpages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\t}",
            "",
            "\tbitmap = bitmap_alloc(nr_notes, GFP_KERNEL);",
            "\tif (!bitmap)",
            "\t\tgoto error_p;",
            "",
            "\tbitmap_fill(bitmap, nr_notes);",
            "\twqueue->notes = pages;",
            "\twqueue->notes_bitmap = bitmap;",
            "\twqueue->nr_pages = nr_pages;",
            "\twqueue->nr_notes = nr_notes;",
            "\treturn 0;",
            "",
            "error_p:",
            "\twhile (--i >= 0)",
            "\t\t__free_page(pages[i]);",
            "\tkfree(pages);",
            "error:",
            "\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->nr_accounted);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__post_watch_notification, watch_queue_set_size",
          "description": "__post_watch_notification遍历watch列表并应用过滤器后提交通知，watch_queue_set_size动态调整管道容量，通过计算所需页数和位图分配，限制最大容量为512个笔记，支持扩展性需求。",
          "similarity": 0.3444265127182007
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/watch_queue.c",
          "start_line": 315,
          "end_line": 422,
          "content": [
            "long watch_queue_set_filter(struct pipe_inode_info *pipe,",
            "\t\t\t    struct watch_notification_filter __user *_filter)",
            "{",
            "\tstruct watch_notification_type_filter *tf;",
            "\tstruct watch_notification_filter filter;",
            "\tstruct watch_type_filter *q;",
            "\tstruct watch_filter *wfilter;",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tint ret, nr_filter = 0, i;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (!_filter) {",
            "\t\t/* Remove the old filter */",
            "\t\twfilter = NULL;",
            "\t\tgoto set;",
            "\t}",
            "",
            "\t/* Grab the user's filter specification */",
            "\tif (copy_from_user(&filter, _filter, sizeof(filter)) != 0)",
            "\t\treturn -EFAULT;",
            "\tif (filter.nr_filters == 0 ||",
            "\t    filter.nr_filters > 16 ||",
            "\t    filter.__reserved != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\ttf = memdup_array_user(_filter->filters, filter.nr_filters, sizeof(*tf));",
            "\tif (IS_ERR(tf))",
            "\t\treturn PTR_ERR(tf);",
            "",
            "\tret = -EINVAL;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif ((tf[i].info_filter & ~tf[i].info_mask) ||",
            "\t\t    tf[i].info_mask & WATCH_INFO_LENGTH)",
            "\t\t\tgoto err_filter;",
            "\t\t/* Ignore any unknown types */",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "\t\tnr_filter++;",
            "\t}",
            "",
            "\t/* Now we need to build the internal filter from only the relevant",
            "\t * user-specified filters.",
            "\t */",
            "\tret = -ENOMEM;",
            "\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);",
            "\tif (!wfilter)",
            "\t\tgoto err_filter;",
            "\twfilter->nr_filters = nr_filter;",
            "",
            "\tq = wfilter->filters;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "",
            "\t\tq->type\t\t\t= tf[i].type;",
            "\t\tq->info_filter\t\t= tf[i].info_filter;",
            "\t\tq->info_mask\t\t= tf[i].info_mask;",
            "\t\tq->subtype_filter[0]\t= tf[i].subtype_filter[0];",
            "\t\t__set_bit(q->type, wfilter->type_filter);",
            "\t\tq++;",
            "\t}",
            "",
            "\tkfree(tf);",
            "set:",
            "\tpipe_lock(pipe);",
            "\twfilter = rcu_replace_pointer(wqueue->filter, wfilter,",
            "\t\t\t\t      lockdep_is_held(&pipe->mutex));",
            "\tpipe_unlock(pipe);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\treturn 0;",
            "",
            "err_filter:",
            "\tkfree(tf);",
            "\treturn ret;",
            "}",
            "static void __put_watch_queue(struct kref *kref)",
            "{",
            "\tstruct watch_queue *wqueue =",
            "\t\tcontainer_of(kref, struct watch_queue, usage);",
            "\tstruct watch_filter *wfilter;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < wqueue->nr_pages; i++)",
            "\t\t__free_page(wqueue->notes[i]);",
            "\tkfree(wqueue->notes);",
            "\tbitmap_free(wqueue->notes_bitmap);",
            "",
            "\twfilter = rcu_access_pointer(wqueue->filter);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\tkfree_rcu(wqueue, rcu);",
            "}",
            "void put_watch_queue(struct watch_queue *wqueue)",
            "{",
            "\tkref_put(&wqueue->usage, __put_watch_queue);",
            "}",
            "static void free_watch(struct rcu_head *rcu)",
            "{",
            "\tstruct watch *watch = container_of(rcu, struct watch, rcu);",
            "",
            "\tput_watch_queue(rcu_access_pointer(watch->queue));",
            "\tatomic_dec(&watch->cred->user->nr_watches);",
            "\tput_cred(watch->cred);",
            "\tkfree(watch);",
            "}"
          ],
          "function_name": "watch_queue_set_filter, __put_watch_queue, put_watch_queue, free_watch",
          "description": "watch_queue_set_filter设置过滤规则并转换为内核内部结构，__put_watch_queue释放watch_queue相关资源包括页面、位图和过滤器，put_watch_queue通过引用计数管理watch_queue生命周期，free_watch执行RCU回调完成最终释放。",
          "similarity": 0.341327965259552
        }
      ]
    },
    {
      "source_file": "kernel/vhost_task.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:48:59\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `vhost_task.c`\n\n---\n\n# vhost_task.c 技术文档\n\n## 1. 文件概述\n\n`vhost_task.c` 实现了一个专用于 vhost 子系统的轻量级内核工作线程（worker thread）管理机制。该机制允许 vhost 驱动创建、启动、唤醒和安全停止专用的内核线程，用于处理 I/O 或控制路径任务。线程支持优雅退出，并能区分由用户空间发送的 `SIGKILL` 信号与内核主动调用的停止操作，确保资源清理的正确性和线程生命周期的安全管理。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`enum vhost_task_flags`**  \n  定义线程状态标志：\n  - `VHOST_TASK_FLAGS_STOP`：表示线程应被主动停止（由 `vhost_task_stop` 触发）。\n  - `VHOST_TASK_FLAGS_KILLED`：表示线程因接收到 `SIGKILL` 信号而终止。\n\n- **`struct vhost_task`**  \n  表示一个 vhost 工作线程的控制结构，包含：\n  - `fn`：主工作函数，返回 `bool` 表示是否完成工作。\n  - `handle_sigkill`：当线程因 `SIGKILL` 被终止时调用的清理回调。\n  - `data`：传递给上述函数的私有数据指针。\n  - `exited`：完成量（`completion`），用于同步线程退出。\n  - `flags`：线程状态标志位。\n  - `task`：指向内核线程 `task_struct` 的指针。\n  - `exit_mutex`：互斥锁，用于序列化 `vhost_task_stop` 与 `SIGKILL` 处理，避免竞态。\n\n### 主要函数\n\n- **`vhost_task_create`**  \n  创建一个新的 `vhost_task` 实例，但不启动线程。配置线程属性（如共享地址空间、信号处理等），并初始化内部结构。\n\n- **`vhost_task_start`**  \n  启动由 `vhost_task_create` 创建的线程，调用 `wake_up_new_task` 使其投入运行。\n\n- **`vhost_task_wake`**  \n  唤醒处于睡眠状态的 vhost 工作线程，通常用于通知有新工作待处理。\n\n- **`vhost_task_stop`**  \n  安全停止并释放 vhost 工作线程。设置停止标志、唤醒线程，并等待其完全退出后释放内存。\n\n- **`vhost_task_fn`**（静态内部函数）  \n  线程的主执行函数，循环调用用户提供的 `fn`，处理信号，并根据停止标志或 `SIGKILL` 决定退出路径。\n\n## 3. 关键实现\n\n- **线程生命周期管理**  \n  线程创建（`vhost_task_create`）与启动（`vhost_task_start`）分离，便于在创建后进行额外配置。线程通过 `copy_process` 创建，使用 `CLONE_THREAD | CLONE_SIGHAND | CLONE_VM` 等标志，使其行为类似用户线程组成员，但运行在内核上下文。\n\n- **退出同步机制**  \n  使用 `completion`（`exited`）确保 `vhost_task_stop` 调用者能安全等待线程完全退出后再释放 `vhost_task` 结构，防止 use-after-free。\n\n- **信号与主动停止的竞态处理**  \n  通过 `exit_mutex` 保护对 `VHOST_TASK_FLAGS_STOP` 和 `VHOST_TASK_FLAGS_KILLED` 的检查与设置。若 `vhost_task_stop` 先执行，则忽略后续的 `SIGKILL`；反之，若先收到 `SIGKILL`，则调用 `handle_sigkill` 进行清理。\n\n- **工作循环设计**  \n  线程主循环中：\n  1. 检查挂起信号（`signal_pending`），若为 `SIGKILL` 则退出。\n  2. 设置为 `TASK_INTERRUPTIBLE` 状态。\n  3. 检查 `STOP` 标志，若置位则退出。\n  4. 调用用户函数 `fn`；若无工作（返回 `false`），则调用 `schedule()` 睡眠。\n  5. 被唤醒后继续循环。\n\n- **内存屏障语义**  \n  注释中提到 `mb paired w/ vhost_task_stop`，暗示在设置 `STOP` 标志与线程读取之间存在隐式的内存顺序要求，确保标志变更对工作线程可见。\n\n## 4. 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/slab.h>`：用于 `kzalloc`/`kfree` 内存分配。\n  - `<linux/completion.h>`：提供 `completion` 同步原语。\n  - `<linux/sched/task.h>` 和 `<linux/sched/signal.h>`：提供任务创建、信号处理（`get_signal`）等接口。\n  - `<linux/sched/vhost_task.h>`：声明 vhost_task 相关的公共 API（如函数原型）。\n\n- **内核子系统依赖**：\n  - **调度子系统**：依赖 `wake_up_process`、`wake_up_new_task`、`schedule` 等调度接口。\n  - **进程管理子系统**：使用 `copy_process` 创建内核线程。\n  - **信号子系统**：通过 `signal_pending` 和 `get_signal` 处理 `SIGKILL`。\n\n## 5. 使用场景\n\n- **vhost 驱动框架**：  \n  该文件为 vhost（如 `vhost-net`、`vhost-scsi`、`vhost-vsock` 等）提供统一的内核线程抽象，用于在内核中异步处理 virtio 设备的后端逻辑（如数据包转发、命令处理等）。\n\n- **需要内核工作线程的场景**：  \n  当驱动需要一个长期运行、可被信号中断、并支持优雅停止的专用线程时，可复用此机制，避免自行实现复杂的线程管理逻辑。\n\n- **与用户空间协同的终止语义**：  \n  支持区分“驱动主动停止”和“用户 kill -9 强制终止”，前者用于正常关闭设备，后者用于异常恢复，确保两种路径下资源都能正确释放。",
      "similarity": 0.4399592876434326,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/vhost_task.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (C) 2021 Oracle Corporation",
            " */",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/vhost_task.h>",
            "#include <linux/sched/signal.h>",
            "",
            "enum vhost_task_flags {",
            "\tVHOST_TASK_FLAGS_STOP,",
            "\tVHOST_TASK_FLAGS_KILLED,",
            "};",
            "",
            "struct vhost_task {",
            "\tbool (*fn)(void *data);",
            "\tvoid (*handle_sigkill)(void *data);",
            "\tvoid *data;",
            "\tstruct completion exited;",
            "\tunsigned long flags;",
            "\tstruct task_struct *task;",
            "\t/* serialize SIGKILL and vhost_task_stop calls */",
            "\tstruct mutex exit_mutex;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义vhost_task结构体，用于管理虚拟化任务的执行状态，包含任务函数指针、信号处理回调、数据指针、退出通知机制、运行标志位及互斥锁等成员",
          "similarity": 0.4473353624343872
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/vhost_task.c",
          "start_line": 27,
          "end_line": 93,
          "content": [
            "static int vhost_task_fn(void *data)",
            "{",
            "\tstruct vhost_task *vtsk = data;",
            "",
            "\tfor (;;) {",
            "\t\tbool did_work;",
            "",
            "\t\tif (signal_pending(current)) {",
            "\t\t\tstruct ksignal ksig;",
            "",
            "\t\t\tif (get_signal(&ksig))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* mb paired w/ vhost_task_stop */",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "",
            "\t\tif (test_bit(VHOST_TASK_FLAGS_STOP, &vtsk->flags)) {",
            "\t\t\t__set_current_state(TASK_RUNNING);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tdid_work = vtsk->fn(vtsk->data);",
            "\t\tif (!did_work)",
            "\t\t\tschedule();",
            "\t}",
            "",
            "\tmutex_lock(&vtsk->exit_mutex);",
            "\t/*",
            "\t * If a vhost_task_stop and SIGKILL race, we can ignore the SIGKILL.",
            "\t * When the vhost layer has called vhost_task_stop it's already stopped",
            "\t * new work and flushed.",
            "\t */",
            "\tif (!test_bit(VHOST_TASK_FLAGS_STOP, &vtsk->flags)) {",
            "\t\tset_bit(VHOST_TASK_FLAGS_KILLED, &vtsk->flags);",
            "\t\tvtsk->handle_sigkill(vtsk->data);",
            "\t}",
            "\tmutex_unlock(&vtsk->exit_mutex);",
            "\tcomplete(&vtsk->exited);",
            "",
            "\tdo_exit(0);",
            "}",
            "void vhost_task_wake(struct vhost_task *vtsk)",
            "{",
            "\twake_up_process(vtsk->task);",
            "}",
            "void vhost_task_stop(struct vhost_task *vtsk)",
            "{",
            "\tmutex_lock(&vtsk->exit_mutex);",
            "\tif (!test_bit(VHOST_TASK_FLAGS_KILLED, &vtsk->flags)) {",
            "\t\tset_bit(VHOST_TASK_FLAGS_STOP, &vtsk->flags);",
            "\t\tvhost_task_wake(vtsk);",
            "\t}",
            "\tmutex_unlock(&vtsk->exit_mutex);",
            "",
            "\t/*",
            "\t * Make sure vhost_task_fn is no longer accessing the vhost_task before",
            "\t * freeing it below.",
            "\t */",
            "\twait_for_completion(&vtsk->exited);",
            "\tput_task_struct(vtsk->task);",
            "\tkfree(vtsk);",
            "}",
            "void vhost_task_start(struct vhost_task *vtsk)",
            "{",
            "\twake_up_new_task(vtsk->task);",
            "}"
          ],
          "function_name": "vhost_task_fn, vhost_task_wake, vhost_task_stop, vhost_task_start",
          "description": "实现vhost_task任务调度逻辑，包含任务执行循环（处理信号与工作函数）、任务唤醒、安全停止（含标志位竞争保护）及启动接口，通过互斥锁保证状态一致性",
          "similarity": 0.3644059896469116
        }
      ]
    }
  ]
}