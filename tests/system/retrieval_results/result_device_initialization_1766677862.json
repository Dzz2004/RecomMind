{
  "query": "device initialization",
  "timestamp": "2025-12-25 23:51:02",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/irqdesc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:59:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\irqdesc.c`\n\n---\n\n# `irq/irqdesc.c` 技术文档\n\n## 1. 文件概述\n\n`irq/irqdesc.c` 是 Linux 内核通用中断子系统（Generic IRQ）的核心实现文件之一，负责中断描述符（`struct irq_desc`）的分配、初始化、管理和释放。该文件实现了中断描述符的生命周期管理，包括在稀疏 IRQ（`CONFIG_SPARSE_IRQ`）配置下的动态分配机制，以及与 SMP（对称多处理）相关的中断亲和性（affinity）管理。它为上层中断处理（如设备驱动注册中断处理函数）和底层硬件中断控制器（通过 `irq_chip`）之间提供了统一的抽象层。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct irq_desc`**：中断描述符，代表一个逻辑中断号（IRQ number），包含中断状态、处理函数、统计信息、锁、亲和性掩码等。\n- **`struct irq_data`**：嵌入在 `irq_desc` 中，包含与硬件中断控制器相关的数据（如 `irq_chip`、`hwirq`、`irq_domain` 等）。\n- **`struct irq_common_data`**：`irq_desc` 和 `irq_data` 共享的数据，如 MSI 描述符、亲和性掩码等。\n- **`sparse_irqs`**：基于 Maple Tree 的稀疏 IRQ 描述符存储结构，用于动态分配 IRQ 号。\n\n### 主要函数\n- **`init_desc()`**：初始化一个 `irq_desc` 实例，包括分配 per-CPU 统计结构、SMP 掩码、初始化锁和默认值。\n- **`desc_set_defaults()`**：设置 `irq_desc` 的默认初始状态（如禁用、屏蔽、默认处理函数为 `handle_bad_irq`）。\n- **`alloc_masks()` / `free_masks()` / `desc_smp_init()`**：SMP 相关的亲和性掩码（affinity、effective_affinity、pending_mask）的分配、释放和初始化。\n- **`irq_find_free_area()` / `irq_find_at_or_after()`**：在稀疏 IRQ 模式下查找可用的 IRQ 号范围或下一个可用 IRQ。\n- **`irq_insert_desc()` / `delete_irq_desc()`**：将 `irq_desc` 插入或从稀疏 IRQ 的 Maple Tree 中删除。\n- **`init_irq_default_affinity()`**：初始化默认的中断亲和性掩码（通常为所有 CPU）。\n- **`irq_kobj_release()` 及相关 sysfs 属性函数**：实现 IRQ 描述符的 sysfs 接口（如 `per_cpu_count`、`chip_name`、`hwirq` 等）。\n\n### 全局变量\n- **`nr_irqs`**：系统支持的最大 IRQ 数量，可被平台代码覆盖。\n- **`irq_default_affinity`**：默认的中断亲和性 CPU 掩码（SMP 模式下）。\n- **`irq_desc_lock_class`**：用于 lockdep 的 IRQ 描述符自旋锁的统一锁类。\n\n## 3. 关键实现\n\n### 稀疏 IRQ 管理（`CONFIG_SPARSE_IRQ`）\n- 使用 **Maple Tree** 数据结构（`sparse_irqs`）替代传统的静态数组，支持动态分配 IRQ 描述符。\n- `irq_find_free_area()` 利用 Maple Tree 的空闲区间查找功能，高效分配连续的 IRQ 号。\n- `irq_insert_desc()` 和 `delete_irq_desc()` 通过 RCU 安全地插入/删除描述符，支持运行时 IRQ 的动态增删。\n- 每个 `irq_desc` 作为独立的 kobject，通过 sysfs 暴露属性（如中断计数、芯片名称等）。\n\n### SMP 中断亲和性\n- **亲和性掩码**：每个 IRQ 可配置其允许运行的 CPU 集合（`affinity`），支持负载均衡和局部性优化。\n- **有效亲和性**（`effective_affinity`）：实际生效的亲和性（可能受中断迁移或 pending 状态影响）。\n- **Pending 掩码**（`pending_mask`）：用于在中断迁移过程中暂存中断事件。\n- 启动参数 `irqaffinity=` 可设置全局默认亲和性，但至少包含引导 CPU 以防配置错误。\n\n### 描述符初始化\n- `init_desc()` 完成描述符的完整初始化：\n  - 分配 per-CPU 中断统计结构（`kstat_irqs`）。\n  - 初始化 SMP 相关掩码（若启用）。\n  - 设置自旋锁（带 lockdep 类）和互斥锁（`request_mutex`）。\n  - 调用 `desc_set_defaults()` 设置默认状态（禁用、屏蔽、无效处理函数）。\n  - 初始化 RCU 回调（用于稀疏 IRQ 的延迟释放）。\n\n### 锁与并发控制\n- **`desc->lock`**：raw spinlock，保护描述符关键字段（如状态、处理函数），在中断上下文中使用。\n- **`desc->request_mutex`**：mutex，用于串行化中断请求/释放操作（如 `request_irq()`）。\n- **Maple Tree 操作**：通过外部互斥锁（`sparse_irq_lock`）和 RCU 保证并发安全。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：IRQ 子系统核心 API 和数据结构。\n  - `<linux/irqdomain.h>`：硬件中断号（hwirq）到逻辑 IRQ 号的映射。\n  - `<linux/maple_tree.h>`：稀疏 IRQ 的底层存储实现。\n  - `<linux/sysfs.h>`：sysfs 属性支持。\n  - `\"internals.h\"`：IRQ 子系统内部函数和宏。\n- **配置依赖**：\n  - `CONFIG_SMP`：启用多处理器支持（亲和性掩码管理）。\n  - `CONFIG_SPARSE_IRQ`：启用动态 IRQ 分配（替代静态数组）。\n  - `CONFIG_GENERIC_PENDING_IRQ` / `CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK`：扩展的 SMP 中断管理功能。\n- **模块交互**：\n  - **中断控制器驱动**：通过 `irq_chip` 操作硬件，依赖 `irq_desc` 提供的抽象。\n  - **设备驱动**：通过 `request_irq()` 等接口注册中断处理函数，操作 `irq_desc`。\n  - **电源管理**：通过 `wakeup` 属性控制中断的唤醒能力。\n\n## 5. 使用场景\n\n- **系统启动阶段**：\n  - 初始化默认中断亲和性（`init_irq_default_affinity()`）。\n  - 预分配或动态创建平台所需的 IRQ 描述符（通过 `alloc_descs()` 等）。\n- **设备驱动加载/卸载**：\n  - 动态分配 IRQ 描述符（稀疏 IRQ 模式下通过 `irq_alloc_desc()`）。\n  - 注册/注销中断处理函数（修改 `handle_irq` 和 action 链表）。\n- **运行时中断管理**：\n  - 修改中断亲和性（`/proc/irq/<n>/smp_affinity`）。\n  - 查询中断统计信息（`/proc/interrupts`，通过 per-CPU 计数）。\n  - 通过 sysfs 查看 IRQ 属性（芯片名称、硬件 IRQ 号、触发类型等）。\n- **中断迁移**（SMP）：\n  - 在 CPU 热插拔或负载均衡时，更新 `affinity` 和 `pending_mask`。\n- **错误处理**：\n  - 未处理的中断由 `handle_bad_irq` 处理，记录到 `irqs_unhandled`。",
      "similarity": 0.563842236995697,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 562,
          "end_line": 667,
          "content": [
            "int __init early_irq_init(void)",
            "{",
            "\tint i, initcnt, node = first_online_node;",
            "\tstruct irq_desc *desc;",
            "",
            "\tinit_irq_default_affinity();",
            "",
            "\t/* Let arch update nr_irqs and return the nr of preallocated irqs */",
            "\tinitcnt = arch_probe_nr_irqs();",
            "\tprintk(KERN_INFO \"NR_IRQS: %d, nr_irqs: %d, preallocated irqs: %d\\n\",",
            "\t       NR_IRQS, nr_irqs, initcnt);",
            "",
            "\tif (WARN_ON(nr_irqs > MAX_SPARSE_IRQS))",
            "\t\tnr_irqs = MAX_SPARSE_IRQS;",
            "",
            "\tif (WARN_ON(initcnt > MAX_SPARSE_IRQS))",
            "\t\tinitcnt = MAX_SPARSE_IRQS;",
            "",
            "\tif (initcnt > nr_irqs)",
            "\t\tnr_irqs = initcnt;",
            "",
            "\tfor (i = 0; i < initcnt; i++) {",
            "\t\tdesc = alloc_desc(i, node, 0, NULL, NULL);",
            "\t\tirq_insert_desc(i, desc);",
            "\t}",
            "\treturn arch_early_irq_init();",
            "}",
            "int __init early_irq_init(void)",
            "{",
            "\tint count, i, node = first_online_node;",
            "\tint ret;",
            "",
            "\tinit_irq_default_affinity();",
            "",
            "\tprintk(KERN_INFO \"NR_IRQS: %d\\n\", NR_IRQS);",
            "",
            "\tcount = ARRAY_SIZE(irq_desc);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tret = init_desc(irq_desc + i, i, node, 0, NULL, NULL);",
            "\t\tif (unlikely(ret))",
            "\t\t\tgoto __free_desc_res;",
            "\t}",
            "",
            "\treturn arch_early_irq_init();",
            "",
            "__free_desc_res:",
            "\twhile (--i >= 0) {",
            "\t\tfree_masks(irq_desc + i);",
            "\t\tfree_percpu(irq_desc[i].kstat_irqs);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static void free_desc(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\tdesc_set_defaults(irq, desc, irq_desc_get_node(desc), NULL, NULL);",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\tdelete_irq_desc(irq);",
            "}",
            "static inline int alloc_descs(unsigned int start, unsigned int cnt, int node,",
            "\t\t\t      const struct irq_affinity_desc *affinity,",
            "\t\t\t      struct module *owner)",
            "{",
            "\tu32 i;",
            "",
            "\tfor (i = 0; i < cnt; i++) {",
            "\t\tstruct irq_desc *desc = irq_to_desc(start + i);",
            "",
            "\t\tdesc->owner = owner;",
            "\t\tirq_insert_desc(start + i, desc);",
            "\t}",
            "\treturn start;",
            "}",
            "static int irq_expand_nr_irqs(unsigned int nr)",
            "{",
            "\treturn -ENOMEM;",
            "}",
            "void irq_mark_irq(unsigned int irq)",
            "{",
            "\tmutex_lock(&sparse_irq_lock);",
            "\tirq_insert_desc(irq, irq_desc + irq);",
            "\tmutex_unlock(&sparse_irq_lock);",
            "}",
            "void irq_init_desc(unsigned int irq)",
            "{",
            "\tfree_desc(irq);",
            "}",
            "int handle_irq_desc(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *data;",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tdata = irq_desc_get_irq_data(desc);",
            "\tif (WARN_ON_ONCE(!in_hardirq() && handle_enforce_irqctx(data)))",
            "\t\treturn -EPERM;",
            "",
            "\tgeneric_handle_irq_desc(desc);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "early_irq_init, early_irq_init, free_desc, alloc_descs, irq_expand_nr_irqs, irq_mark_irq, irq_init_desc, handle_irq_desc",
          "description": "early_irq_init 初始化早期中断描述符，调用架构特定函数确定中断数量并分配初始中断描述符。free_desc 释放中断描述符并重置为其默认状态。alloc_descs 批量分配中断描述符到指定范围。irq_mark_irq 将中断标记为已初始化。irq_init_desc 初始化指定中断描述符。handle_irq_desc 处理中断描述符，检查硬中断上下文并调用通用处理函数。",
          "similarity": 0.554114818572998
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 27,
          "end_line": 127,
          "content": [
            "static int __init irq_affinity_setup(char *str)",
            "{",
            "\talloc_bootmem_cpumask_var(&irq_default_affinity);",
            "\tcpulist_parse(str, irq_default_affinity);",
            "\t/*",
            "\t * Set at least the boot cpu. We don't want to end up with",
            "\t * bugreports caused by random commandline masks",
            "\t */",
            "\tcpumask_set_cpu(smp_processor_id(), irq_default_affinity);",
            "\treturn 1;",
            "}",
            "static void __init init_irq_default_affinity(void)",
            "{",
            "\tif (!cpumask_available(irq_default_affinity))",
            "\t\tzalloc_cpumask_var(&irq_default_affinity, GFP_NOWAIT);",
            "\tif (cpumask_empty(irq_default_affinity))",
            "\t\tcpumask_setall(irq_default_affinity);",
            "}",
            "static void __init init_irq_default_affinity(void)",
            "{",
            "}",
            "static int alloc_masks(struct irq_desc *desc, int node)",
            "{",
            "\tif (!zalloc_cpumask_var_node(&desc->irq_common_data.affinity,",
            "\t\t\t\t     GFP_KERNEL, node))",
            "\t\treturn -ENOMEM;",
            "",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\tif (!zalloc_cpumask_var_node(&desc->irq_common_data.effective_affinity,",
            "\t\t\t\t     GFP_KERNEL, node)) {",
            "\t\tfree_cpumask_var(desc->irq_common_data.affinity);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\tif (!zalloc_cpumask_var_node(&desc->pending_mask, GFP_KERNEL, node)) {",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\t\tfree_cpumask_var(desc->irq_common_data.effective_affinity);",
            "#endif",
            "\t\tfree_cpumask_var(desc->irq_common_data.affinity);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}",
            "static void desc_smp_init(struct irq_desc *desc, int node,",
            "\t\t\t  const struct cpumask *affinity)",
            "{",
            "\tif (!affinity)",
            "\t\taffinity = irq_default_affinity;",
            "\tcpumask_copy(desc->irq_common_data.affinity, affinity);",
            "",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\tcpumask_clear(desc->pending_mask);",
            "#endif",
            "#ifdef CONFIG_NUMA",
            "\tdesc->irq_common_data.node = node;",
            "#endif",
            "}",
            "static void free_masks(struct irq_desc *desc)",
            "{",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\tfree_cpumask_var(desc->pending_mask);",
            "#endif",
            "\tfree_cpumask_var(desc->irq_common_data.affinity);",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\tfree_cpumask_var(desc->irq_common_data.effective_affinity);",
            "#endif",
            "}",
            "static inline int",
            "alloc_masks(struct irq_desc *desc, int node) { return 0; }",
            "static inline void",
            "desc_smp_init(struct irq_desc *desc, int node, const struct cpumask *affinity) { }",
            "static inline void free_masks(struct irq_desc *desc) { }",
            "static void desc_set_defaults(unsigned int irq, struct irq_desc *desc, int node,",
            "\t\t\t      const struct cpumask *affinity, struct module *owner)",
            "{",
            "\tint cpu;",
            "",
            "\tdesc->irq_common_data.handler_data = NULL;",
            "\tdesc->irq_common_data.msi_desc = NULL;",
            "",
            "\tdesc->irq_data.common = &desc->irq_common_data;",
            "\tdesc->irq_data.irq = irq;",
            "\tdesc->irq_data.chip = &no_irq_chip;",
            "\tdesc->irq_data.chip_data = NULL;",
            "\tirq_settings_clr_and_set(desc, ~0, _IRQ_DEFAULT_INIT_FLAGS);",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);",
            "\tdesc->handle_irq = handle_bad_irq;",
            "\tdesc->depth = 1;",
            "\tdesc->irq_count = 0;",
            "\tdesc->irqs_unhandled = 0;",
            "\tdesc->tot_count = 0;",
            "\tdesc->name = NULL;",
            "\tdesc->owner = owner;",
            "\tfor_each_possible_cpu(cpu)",
            "\t\t*per_cpu_ptr(desc->kstat_irqs, cpu) = (struct irqstat) { };",
            "\tdesc_smp_init(desc, node, affinity);",
            "}"
          ],
          "function_name": "irq_affinity_setup, init_irq_default_affinity, init_irq_default_affinity, alloc_masks, desc_smp_init, free_masks, alloc_masks, desc_smp_init, free_masks, desc_set_defaults",
          "description": "包含中断亲和性初始化与内存分配相关函数，负责设置默认CPU亲和掩码、分配irq_desc结构体的affinity字段、初始化SMP相关信息及释放相关资源。存在多处函数重载实现，体现不同配置条件下的差异化处理。",
          "similarity": 0.5395302772521973
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 278,
          "end_line": 385,
          "content": [
            "static ssize_t type_show(struct kobject *kobj,",
            "\t\t\t struct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct irq_desc *desc = container_of(kobj, struct irq_desc, kobj);",
            "\tssize_t ret = 0;",
            "",
            "\traw_spin_lock_irq(&desc->lock);",
            "\tret = sprintf(buf, \"%s\\n\",",
            "\t\t      irqd_is_level_type(&desc->irq_data) ? \"level\" : \"edge\");",
            "\traw_spin_unlock_irq(&desc->lock);",
            "",
            "\treturn ret;",
            "",
            "}",
            "static ssize_t wakeup_show(struct kobject *kobj,",
            "\t\t\t   struct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct irq_desc *desc = container_of(kobj, struct irq_desc, kobj);",
            "\tssize_t ret = 0;",
            "",
            "\traw_spin_lock_irq(&desc->lock);",
            "\tret = sprintf(buf, \"%s\\n\",",
            "\t\t      irqd_is_wakeup_set(&desc->irq_data) ? \"enabled\" : \"disabled\");",
            "\traw_spin_unlock_irq(&desc->lock);",
            "",
            "\treturn ret;",
            "",
            "}",
            "static ssize_t name_show(struct kobject *kobj,",
            "\t\t\t struct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct irq_desc *desc = container_of(kobj, struct irq_desc, kobj);",
            "\tssize_t ret = 0;",
            "",
            "\traw_spin_lock_irq(&desc->lock);",
            "\tif (desc->name)",
            "\t\tret = scnprintf(buf, PAGE_SIZE, \"%s\\n\", desc->name);",
            "\traw_spin_unlock_irq(&desc->lock);",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t actions_show(struct kobject *kobj,",
            "\t\t\t    struct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct irq_desc *desc = container_of(kobj, struct irq_desc, kobj);",
            "\tstruct irqaction *action;",
            "\tssize_t ret = 0;",
            "\tchar *p = \"\";",
            "",
            "\traw_spin_lock_irq(&desc->lock);",
            "\tfor_each_action_of_desc(desc, action) {",
            "\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret, \"%s%s\",",
            "\t\t\t\t p, action->name);",
            "\t\tp = \",\";",
            "\t}",
            "\traw_spin_unlock_irq(&desc->lock);",
            "",
            "\tif (ret)",
            "\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret, \"\\n\");",
            "",
            "\treturn ret;",
            "}",
            "static void irq_sysfs_add(int irq, struct irq_desc *desc)",
            "{",
            "\tif (irq_kobj_base) {",
            "\t\t/*",
            "\t\t * Continue even in case of failure as this is nothing",
            "\t\t * crucial and failures in the late irq_sysfs_init()",
            "\t\t * cannot be rolled back.",
            "\t\t */",
            "\t\tif (kobject_add(&desc->kobj, irq_kobj_base, \"%d\", irq))",
            "\t\t\tpr_warn(\"Failed to add kobject for irq %d\\n\", irq);",
            "\t\telse",
            "\t\t\tdesc->istate |= IRQS_SYSFS;",
            "\t}",
            "}",
            "static void irq_sysfs_del(struct irq_desc *desc)",
            "{",
            "\t/*",
            "\t * Only invoke kobject_del() when kobject_add() was successfully",
            "\t * invoked for the descriptor. This covers both early boot, where",
            "\t * sysfs is not initialized yet, and the case of a failed",
            "\t * kobject_add() invocation.",
            "\t */",
            "\tif (desc->istate & IRQS_SYSFS)",
            "\t\tkobject_del(&desc->kobj);",
            "}",
            "static int __init irq_sysfs_init(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint irq;",
            "",
            "\t/* Prevent concurrent irq alloc/free */",
            "\tirq_lock_sparse();",
            "",
            "\tirq_kobj_base = kobject_create_and_add(\"irq\", kernel_kobj);",
            "\tif (!irq_kobj_base) {",
            "\t\tirq_unlock_sparse();",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\t/* Add the already allocated interrupts */",
            "\tfor_each_irq_desc(irq, desc)",
            "\t\tirq_sysfs_add(irq, desc);",
            "\tirq_unlock_sparse();",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "type_show, wakeup_show, name_show, actions_show, irq_sysfs_add, irq_sysfs_del, irq_sysfs_init",
          "description": "通过sysfs接口暴露中断属性信息，包含中断类型、唤醒状态、名称、连接动作等展示函数，以及管理sysfs节点的添加删除操作，实现了中断设备的系统级调试信息导出功能。",
          "similarity": 0.5127302408218384
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 938,
          "end_line": 1027,
          "content": [
            "int irq_set_percpu_devid(unsigned int irq)",
            "{",
            "\treturn irq_set_percpu_devid_partition(irq, NULL);",
            "}",
            "int irq_get_percpu_devid_partition(unsigned int irq, struct cpumask *affinity)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc || !desc->percpu_enabled)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (affinity)",
            "\t\tcpumask_copy(affinity, desc->percpu_affinity);",
            "",
            "\treturn 0;",
            "}",
            "void kstat_incr_irq_this_cpu(unsigned int irq)",
            "{",
            "\tkstat_incr_irqs_this_cpu(irq_to_desc(irq));",
            "}",
            "unsigned int kstat_irqs_cpu(unsigned int irq, int cpu)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\treturn desc && desc->kstat_irqs ? per_cpu(desc->kstat_irqs->cnt, cpu) : 0;",
            "}",
            "static bool irq_is_nmi(struct irq_desc *desc)",
            "{",
            "\treturn desc->istate & IRQS_NMI;",
            "}",
            "unsigned int kstat_irqs_desc(struct irq_desc *desc, const struct cpumask *cpumask)",
            "{",
            "\tunsigned int sum = 0;",
            "\tint cpu;",
            "",
            "\tif (!irq_settings_is_per_cpu_devid(desc) &&",
            "\t    !irq_settings_is_per_cpu(desc) &&",
            "\t    !irq_is_nmi(desc))",
            "\t\treturn data_race(desc->tot_count);",
            "",
            "\tfor_each_cpu(cpu, cpumask)",
            "\t\tsum += data_race(per_cpu(desc->kstat_irqs->cnt, cpu));",
            "\treturn sum;",
            "}",
            "static unsigned int kstat_irqs(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc || !desc->kstat_irqs)",
            "\t\treturn 0;",
            "\treturn kstat_irqs_desc(desc, cpu_possible_mask);",
            "}",
            "void kstat_snapshot_irqs(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tunsigned int irq;",
            "",
            "\tfor_each_irq_desc(irq, desc) {",
            "\t\tif (!desc->kstat_irqs)",
            "\t\t\tcontinue;",
            "\t\tthis_cpu_write(desc->kstat_irqs->ref, this_cpu_read(desc->kstat_irqs->cnt));",
            "\t}",
            "}",
            "unsigned int kstat_get_irq_since_snapshot(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc || !desc->kstat_irqs)",
            "\t\treturn 0;",
            "\treturn this_cpu_read(desc->kstat_irqs->cnt) - this_cpu_read(desc->kstat_irqs->ref);",
            "}",
            "unsigned int kstat_irqs_usr(unsigned int irq)",
            "{",
            "\tunsigned int sum;",
            "",
            "\trcu_read_lock();",
            "\tsum = kstat_irqs(irq);",
            "\trcu_read_unlock();",
            "\treturn sum;",
            "}",
            "void __irq_set_lockdep_class(unsigned int irq, struct lock_class_key *lock_class,",
            "\t\t\t     struct lock_class_key *request_class)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (desc) {",
            "\t\tlockdep_set_class(&desc->lock, lock_class);",
            "\t\tlockdep_set_class(&desc->request_mutex, request_class);",
            "\t}",
            "}"
          ],
          "function_name": "irq_set_percpu_devid, irq_get_percpu_devid_partition, kstat_incr_irq_this_cpu, kstat_irqs_cpu, irq_is_nmi, kstat_irqs_desc, kstat_irqs, kstat_snapshot_irqs, kstat_get_irq_since_snapshot, kstat_irqs_usr, __irq_set_lockdep_class",
          "description": "irq_set_percpu_devid 设置中断为每个CPU专用模式。irq_get_percpu_devid_partition 获取中断的亲和性掩码。kstat_incr_irq_this_cpu 增加当前CPU的中断统计计数。kstat_irqs_cpu 查询指定CPU的中断次数。irq_is_nmi 判断中断是否为NMI。kstat_irqs_desc 计算指定CPU掩码下的中断总数。kstat_snapshot_irqs 快照中断统计数据。kstat_get_irq_since_snapshot 获取自快照后的中断次数。__irq_set_lockdep_class 设置中断描述符锁的锁跟踪类别。",
          "similarity": 0.5006232261657715
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 705,
          "end_line": 824,
          "content": [
            "int generic_handle_irq(unsigned int irq)",
            "{",
            "\treturn handle_irq_desc(irq_to_desc(irq));",
            "}",
            "int generic_handle_irq_safe(unsigned int irq)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tlocal_irq_save(flags);",
            "\tret = handle_irq_desc(irq_to_desc(irq));",
            "\tlocal_irq_restore(flags);",
            "\treturn ret;",
            "}",
            "int generic_handle_domain_irq(struct irq_domain *domain, unsigned int hwirq)",
            "{",
            "\treturn handle_irq_desc(irq_resolve_mapping(domain, hwirq));",
            "}",
            "int generic_handle_domain_irq_safe(struct irq_domain *domain, unsigned int hwirq)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tlocal_irq_save(flags);",
            "\tret = handle_irq_desc(irq_resolve_mapping(domain, hwirq));",
            "\tlocal_irq_restore(flags);",
            "\treturn ret;",
            "}",
            "int generic_handle_domain_nmi(struct irq_domain *domain, unsigned int hwirq)",
            "{",
            "\tWARN_ON_ONCE(!in_nmi());",
            "\treturn handle_irq_desc(irq_resolve_mapping(domain, hwirq));",
            "}",
            "void irq_free_descs(unsigned int from, unsigned int cnt)",
            "{",
            "\tint i;",
            "",
            "\tif (from >= nr_irqs || (from + cnt) > nr_irqs)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&sparse_irq_lock);",
            "\tfor (i = 0; i < cnt; i++)",
            "\t\tfree_desc(from + i);",
            "",
            "\tmutex_unlock(&sparse_irq_lock);",
            "}",
            "int __ref",
            "__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,",
            "\t\t  struct module *owner, const struct irq_affinity_desc *affinity)",
            "{",
            "\tint start, ret;",
            "",
            "\tif (!cnt)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (irq >= 0) {",
            "\t\tif (from > irq)",
            "\t\t\treturn -EINVAL;",
            "\t\tfrom = irq;",
            "\t} else {",
            "\t\t/*",
            "\t\t * For interrupts which are freely allocated the",
            "\t\t * architecture can force a lower bound to the @from",
            "\t\t * argument. x86 uses this to exclude the GSI space.",
            "\t\t */",
            "\t\tfrom = arch_dynirq_lower_bound(from);",
            "\t}",
            "",
            "\tmutex_lock(&sparse_irq_lock);",
            "",
            "\tstart = irq_find_free_area(from, cnt);",
            "\tret = -EEXIST;",
            "\tif (irq >=0 && start != irq)",
            "\t\tgoto unlock;",
            "",
            "\tif (start + cnt > nr_irqs) {",
            "\t\tret = irq_expand_nr_irqs(start + cnt);",
            "\t\tif (ret)",
            "\t\t\tgoto unlock;",
            "\t}",
            "\tret = alloc_descs(start, cnt, node, affinity, owner);",
            "unlock:",
            "\tmutex_unlock(&sparse_irq_lock);",
            "\treturn ret;",
            "}",
            "unsigned int irq_get_next_irq(unsigned int offset)",
            "{",
            "\treturn irq_find_at_or_after(offset);",
            "}",
            "void __irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags, bool bus)",
            "\t__releases(&desc->lock)",
            "{",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\tif (bus)",
            "\t\tchip_bus_sync_unlock(desc);",
            "}",
            "int irq_set_percpu_devid_partition(unsigned int irq,",
            "\t\t\t\t   const struct cpumask *affinity)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (desc->percpu_enabled)",
            "\t\treturn -EINVAL;",
            "",
            "\tdesc->percpu_enabled = kzalloc(sizeof(*desc->percpu_enabled), GFP_KERNEL);",
            "",
            "\tif (!desc->percpu_enabled)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (affinity)",
            "\t\tdesc->percpu_affinity = affinity;",
            "\telse",
            "\t\tdesc->percpu_affinity = cpu_possible_mask;",
            "",
            "\tirq_set_percpu_devid_flags(irq);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "generic_handle_irq, generic_handle_irq_safe, generic_handle_domain_irq, generic_handle_domain_irq_safe, generic_handle_domain_nmi, irq_free_descs, __irq_alloc_descs, irq_get_next_irq, __irq_put_desc_unlock, irq_set_percpu_devid_partition",
          "description": "generic_handle_irq 安全处理通用中断，调用handle_irq_desc。generic_handle_domain_irq 处理IRQ domain映射的硬件中断。irq_free_descs 释放指定范围的中断描述符。__irq_alloc_descs 动态分配连续中断号并初始化描述符。irq_get_next_irq 获取下一个可用中断号。__irq_put_desc_unlock 解锁中断描述符并同步总线。irq_set_percpu_devid_partition 设置中断亲和性分区。",
          "similarity": 0.4918460547924042
        }
      ]
    },
    {
      "source_file": "kernel/irq/autoprobe.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:47:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\autoprobe.c`\n\n---\n\n# `irq/autoprobe.c` 技术文档\n\n## 1. 文件概述\n\n`irq/autoprobe.c` 实现了 Linux 内核中的中断自动探测（IRQ autodetection）机制。该机制用于在设备驱动程序无法预先知道其所使用的中断号时，动态探测硬件实际触发的中断线。文件提供了一组 API，允许驱动程序在安全、受控的环境下扫描并识别有效的中断请求（IRQ）线路。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`probe_irq_on(void)`**  \n  启动中断自动探测过程。激活所有可探测的未分配中断线，等待潜在中断触发，并返回一个位掩码，表示可能有效的低编号（<32）中断线。\n\n- **`probe_irq_mask(unsigned long val)`**  \n  扫描所有中断线，返回在指定掩码 `val` 范围内被触发的有效中断位图，并清理探测状态。\n\n- **`probe_irq_off(unsigned long val)`**  \n  结束中断探测，检查哪些中断线在探测期间被触发。若唯一中断被触发，返回其中断号；若多个中断被触发，返回负值表示冲突；若无中断触发，返回 0。\n\n### 关键数据结构与状态标志\n\n- **`IRQS_AUTODETECT`**：标记该中断正处于自动探测状态。\n- **`IRQS_WAITING`**：表示该中断尚未被触发；若在探测期间被触发，此标志会被清除。\n- **`probing_active`**：全局互斥锁（`mutex`），确保同一时间只有一个探测过程在进行。\n\n## 3. 关键实现\n\n### 探测流程\n\n1. **准备阶段（`probe_irq_on`）**：\n   - 调用 `async_synchronize_full()` 确保异步任务完成，避免干扰。\n   - 获取 `probing_active` 互斥锁，防止并发探测。\n   - 遍历所有中断描述符（`irq_desc`），对未分配（`!desc->action`）且允许探测（`irq_settings_can_probe`）的中断：\n     - 若芯片支持，调用 `irq_set_type(..., IRQ_TYPE_PROBE)` 通知硬件进入探测模式。\n     - 调用 `irq_activate_and_startup()` 激活并启用中断（不重发）。\n   - 等待 20ms，让“陈旧”中断（longstanding irq）有机会触发并自屏蔽。\n\n2. **正式探测阶段**：\n   - 再次遍历中断描述符，为可探测中断设置 `IRQS_AUTODETECT | IRQS_WAITING`。\n   - 重新激活中断（处理可能因陈旧中断而被屏蔽的情况）。\n   - 等待 100ms，让真实硬件中断触发。\n\n3. **结果收集与清理**：\n   - 在 `probe_irq_off` 或 `probe_irq_mask` 中：\n     - 检查哪些中断仍带有 `IRQS_AUTODETECT` 且 **未** 设置 `IRQS_WAITING`（即已被触发）。\n     - 清除 `IRQS_AUTODETECT` 标志，并调用 `irq_shutdown_and_deactivate()` 关闭中断。\n     - 根据触发中断的数量返回结果：唯一中断返回正号，多个返回负号，无触发返回 0。\n\n### 并发控制\n\n- 使用 `probing_active` 互斥锁保证探测过程的原子性。\n- 所有对 `irq_desc` 的访问均在 `raw_spin_lock_irq()` 保护下进行，确保中断上下文安全。\n\n### 硬件交互\n\n- 支持通过 `irq_chip->irq_set_type()` 向中断控制器发送 `IRQ_TYPE_PROBE` 类型，使某些硬件（如 ISA 控制器）进入探测兼容模式。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`：IRQ 核心定义。\n  - `<linux/interrupt.h>`：中断处理相关 API。\n  - `<linux/delay.h>`：提供 `msleep()`。\n  - `<linux/async.h>`：用于同步异步任务。\n  - `\"internals.h\"`：包含 IRQ 子系统内部函数（如 `irq_activate_and_startup`、`irq_shutdown_and_deactivate`）。\n\n- **内核子系统依赖**：\n  - **IRQ 子系统核心**：依赖 `irq_desc` 管理、中断激活/关闭逻辑。\n  - **中断控制器驱动**：依赖 `irq_chip` 回调（特别是 `irq_set_type`）。\n\n## 5. 使用场景\n\n- **传统 ISA/PnP 设备驱动**：在即插即用（PnP）或资源未知的旧硬件驱动中，用于动态确定设备使用的 IRQ 号。\n- **调试与诊断工具**：内核调试时用于验证硬件中断线路是否正常工作。\n- **模块化驱动初始化**：在 `module_init` 阶段，当设备资源未通过 ACPI/FDT 等机制明确指定时，作为后备探测手段。\n\n> **注意**：现代设备通常通过设备树（Device Tree）、ACPI 或 PCI 配置空间明确指定中断号，因此该机制主要用于遗留硬件支持。文档中也指出，在模块中使用时存在并发风险，应避免重叠调用。",
      "similarity": 0.5592762231826782,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/autoprobe.c",
          "start_line": 30,
          "end_line": 149,
          "content": [
            "unsigned long probe_irq_on(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tunsigned long mask = 0;",
            "\tint i;",
            "",
            "\t/*",
            "\t * quiesce the kernel, or at least the asynchronous portion",
            "\t */",
            "\tasync_synchronize_full();",
            "\tmutex_lock(&probing_active);",
            "\t/*",
            "\t * something may have generated an irq long ago and we want to",
            "\t * flush such a longstanding irq before considering it as spurious.",
            "\t */",
            "\tfor_each_irq_desc_reverse(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "\t\tif (!desc->action && irq_settings_can_probe(desc)) {",
            "\t\t\t/*",
            "\t\t\t * Some chips need to know about probing in",
            "\t\t\t * progress:",
            "\t\t\t */",
            "\t\t\tif (desc->irq_data.chip->irq_set_type)",
            "\t\t\t\tdesc->irq_data.chip->irq_set_type(&desc->irq_data,",
            "\t\t\t\t\t\t\t IRQ_TYPE_PROBE);",
            "\t\t\tirq_activate_and_startup(desc, IRQ_NORESEND);",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "",
            "\t/* Wait for longstanding interrupts to trigger. */",
            "\tmsleep(20);",
            "",
            "\t/*",
            "\t * enable any unassigned irqs",
            "\t * (we must startup again here because if a longstanding irq",
            "\t * happened in the previous stage, it may have masked itself)",
            "\t */",
            "\tfor_each_irq_desc_reverse(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "\t\tif (!desc->action && irq_settings_can_probe(desc)) {",
            "\t\t\tdesc->istate |= IRQS_AUTODETECT | IRQS_WAITING;",
            "\t\t\tif (irq_activate_and_startup(desc, IRQ_NORESEND))",
            "\t\t\t\tdesc->istate |= IRQS_PENDING;",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "",
            "\t/*",
            "\t * Wait for spurious interrupts to trigger",
            "\t */",
            "\tmsleep(100);",
            "",
            "\t/*",
            "\t * Now filter out any obviously spurious interrupts",
            "\t */",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "",
            "\t\tif (desc->istate & IRQS_AUTODETECT) {",
            "\t\t\t/* It triggered already - consider it spurious. */",
            "\t\t\tif (!(desc->istate & IRQS_WAITING)) {",
            "\t\t\t\tdesc->istate &= ~IRQS_AUTODETECT;",
            "\t\t\t\tirq_shutdown_and_deactivate(desc);",
            "\t\t\t} else",
            "\t\t\t\tif (i < 32)",
            "\t\t\t\t\tmask |= 1 << i;",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "",
            "\treturn mask;",
            "}",
            "unsigned int probe_irq_mask(unsigned long val)",
            "{",
            "\tunsigned int mask = 0;",
            "\tstruct irq_desc *desc;",
            "\tint i;",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "\t\tif (desc->istate & IRQS_AUTODETECT) {",
            "\t\t\tif (i < 16 && !(desc->istate & IRQS_WAITING))",
            "\t\t\t\tmask |= 1 << i;",
            "",
            "\t\t\tdesc->istate &= ~IRQS_AUTODETECT;",
            "\t\t\tirq_shutdown_and_deactivate(desc);",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "\tmutex_unlock(&probing_active);",
            "",
            "\treturn mask & val;",
            "}",
            "int probe_irq_off(unsigned long val)",
            "{",
            "\tint i, irq_found = 0, nr_of_irqs = 0;",
            "\tstruct irq_desc *desc;",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "",
            "\t\tif (desc->istate & IRQS_AUTODETECT) {",
            "\t\t\tif (!(desc->istate & IRQS_WAITING)) {",
            "\t\t\t\tif (!nr_of_irqs)",
            "\t\t\t\t\tirq_found = i;",
            "\t\t\t\tnr_of_irqs++;",
            "\t\t\t}",
            "\t\t\tdesc->istate &= ~IRQS_AUTODETECT;",
            "\t\t\tirq_shutdown_and_deactivate(desc);",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "\tmutex_unlock(&probing_active);",
            "",
            "\tif (nr_of_irqs > 1)",
            "\t\tirq_found = -irq_found;",
            "",
            "\treturn irq_found;",
            "}"
          ],
          "function_name": "probe_irq_on, probe_irq_mask, probe_irq_off",
          "description": "实现中断自动检测三阶段流程，probe_irq_on启用未分配中断并收集触发掩码，probe_irq_mask筛选有效中断位，probe_irq_off解析最终中断号，通过遍历中断描述符完成状态修改与激活控制。",
          "similarity": 0.5297342538833618
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/autoprobe.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2004 Linus Torvalds, Ingo Molnar",
            " *",
            " * This file contains the interrupt probing code and driver APIs.",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "",
            "#include \"internals.h\"",
            "",
            "/*",
            " * Autodetection depends on the fact that any interrupt that",
            " * comes in on to an unassigned handler will get stuck with",
            " * \"IRQS_WAITING\" cleared and the interrupt disabled.",
            " */",
            "static DEFINE_MUTEX(probing_active);",
            "",
            "/**",
            " *\tprobe_irq_on\t- begin an interrupt autodetect",
            " *",
            " *\tCommence probing for an interrupt. The interrupts are scanned",
            " *\tand a mask of potential interrupt lines is returned.",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "定义用于中断自动检测的互斥锁probing_active，并声明probe_irq_on、probe_irq_mask和probe_irq_off函数，为后续中断探针流程提供基础框架。",
          "similarity": 0.43956252932548523
        }
      ]
    },
    {
      "source_file": "kernel/irq/settings.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:08:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\settings.h`\n\n---\n\n# `irq/settings.h` 技术文档\n\n## 1. 文件概述\n\n`irq/settings.h` 是 Linux 内核中断子系统中的一个内部头文件，用于封装对 `irq_desc` 结构体中中断状态（原 `status` 字段，现为 `status_use_accessors`）的访问逻辑。该文件通过定义一组带下划线前缀的枚举常量（如 `_IRQ_PER_CPU`）映射原始中断标志（如 `IRQ_PER_CPU`），并提供一系列内联函数以安全、统一的方式读取和修改中断描述符的配置属性。同时，文件通过将原始标志宏（如 `IRQ_PER_CPU`）重定义为无效值（`GOT_YOU_MORON`），强制开发者使用封装后的访问器函数，避免直接操作底层状态位，从而提升代码的可维护性和安全性。\n\n## 2. 核心功能\n\n### 枚举常量\n- `_IRQ_DEFAULT_INIT_FLAGS`：中断描述符的默认初始化标志。\n- `_IRQ_PER_CPU`：表示该中断仅绑定到特定 CPU。\n- `_IRQ_LEVEL`：表示该中断为电平触发。\n- `_IRQ_NOPROBE`：禁止对该中断进行探测。\n- `_IRQ_NOREQUEST`：禁止通过 `request_irq()` 请求该中断。\n- `_IRQ_NOTHREAD`：禁止为该中断创建线程化处理程序。\n- `_IRQ_NOAUTOEN`：中断不会在注册后自动启用。\n- `_IRQ_MOVE_PCNTXT`：允许在进程上下文中迁移该中断。\n- `_IRQ_NO_BALANCING`：禁用中断负载均衡。\n- `_IRQ_NESTED_THREAD`：表示该中断是嵌套线程化中断。\n- `_IRQ_PER_CPU_DEVID`：表示该中断为 per-CPU 类型，且使用设备 ID。\n- `_IRQ_IS_POLLED`：表示该中断由轮询机制处理。\n- `_IRQ_DISABLE_UNLAZY`：禁用 lazy disable 优化。\n- `_IRQ_HIDDEN`：该中断对用户空间隐藏。\n- `_IRQ_NO_DEBUG`：禁用对该中断的调试跟踪。\n- `_IRQF_MODIFY_MASK`：定义哪些标志位允许被修改。\n\n### 内联函数\n- **通用操作**：\n  - `irq_settings_clr_and_set()`：原子地清除和设置指定的中断标志位。\n- **Per-CPU 相关**：\n  - `irq_settings_is_per_cpu()` / `irq_settings_set_per_cpu()`\n  - `irq_settings_is_per_cpu_devid()`\n- **负载均衡**：\n  - `irq_settings_set_no_balancing()` / `irq_settings_has_no_balance_set()`\n- **触发类型**：\n  - `irq_settings_get_trigger_mask()` / `irq_settings_set_trigger_mask()`\n  - `irq_settings_is_level()` / `irq_settings_set_level()` / `irq_settings_clr_level()`\n- **请求与探测控制**：\n  - `irq_settings_can_request()` / `irq_settings_set_norequest()` / `irq_settings_clr_norequest()`\n  - `irq_settings_can_probe()` / `irq_settings_set_noprobe()` / `irq_settings_clr_noprobe()`\n- **线程化处理**：\n  - `irq_settings_can_thread()` / `irq_settings_set_nothread()` / `irq_settings_clr_nothread()`\n  - `irq_settings_is_nested_thread()`\n- **其他属性**：\n  - `irq_settings_can_move_pcntxt()`\n  - `irq_settings_can_autoenable()`\n  - `irq_settings_is_polled()`\n  - `irq_settings_disable_unlazy()` / `irq_settings_clr_disable_unlazy()`\n  - `irq_settings_is_hidden()`\n  - `irq_settings_no_debug()` / `irq_settings_set_no_debug()`\n\n## 3. 关键实现\n\n- **标志位封装**：所有原始中断标志（如 `IRQ_PER_CPU`）被重定义为无效标识符（`GOT_YOU_MORON`），强制开发者使用带下划线前缀的枚举值（如 `_IRQ_PER_CPU`）配合封装函数进行操作，防止直接访问 `irq_desc->status_use_accessors`。\n- **安全位操作**：`irq_settings_clr_and_set()` 函数在修改标志位时，会与 `_IRQF_MODIFY_MASK` 进行掩码操作，确保只有允许修改的位被更新，防止意外覆盖关键状态。\n- **触发类型管理**：通过 `IRQ_TYPE_SENSE_MASK` 掩码单独管理中断触发类型（如边沿/电平），与其他标志位解耦。\n- **布尔语义封装**：对于“禁止”类标志（如 `_IRQ_NOREQUEST`），封装函数（如 `irq_settings_can_request()`）返回其逻辑否定值，使接口语义更直观（“能否请求”而非“是否禁止请求”）。\n\n## 4. 依赖关系\n\n- **依赖头文件**：隐式依赖 `linux/irq.h` 或 `linux/interrupt.h`，其中定义了原始中断标志（如 `IRQ_PER_CPU`、`IRQ_TYPE_SENSE_MASK`）和 `struct irq_desc`。\n- **被依赖模块**：\n  - 中断核心子系统（`kernel/irq/` 下的 `.c` 文件）：如 `irqdesc.c`、`manage.c` 等，在初始化、配置和管理中断描述符时调用本文件提供的访问器函数。\n  - 中断控制器驱动（如 GIC、APIC 驱动）：在设置特定中断属性时使用这些封装接口。\n  - 线程化中断和中断亲和性管理模块：依赖 per-CPU、线程化、负载均衡等相关接口。\n\n## 5. 使用场景\n\n- **中断描述符初始化**：在 `alloc_desc()` 或 `irq_setup_virq()` 等函数中，使用 `irq_settings_set_*` 系列函数设置中断的初始属性（如 per-CPU、触发类型等）。\n- **中断注册与配置**：在 `request_irq()`、`devm_request_irq()` 或驱动的中断设置路径中，通过 `irq_settings_can_request()` 等函数检查中断是否可被请求，并通过 `irq_settings_set_norequest()` 等函数动态调整属性。\n- **中断迁移与负载均衡**：在 `irq_set_affinity()` 或中断均衡逻辑中，使用 `irq_settings_has_no_balance_set()` 判断是否跳过均衡处理。\n- **调试与监控**：调试子系统通过 `irq_settings_no_debug()` 判断是否应跳过特定中断的跟踪。\n- **电源管理与轮询**：在中断休眠或轮询模式下，通过 `irq_settings_is_polled()` 和 `irq_settings_disable_unlazy()` 控制中断行为。",
      "similarity": 0.5533773303031921,
      "chunks": []
    }
  ]
}