{
  "query": "page allocation algorithm",
  "timestamp": "2025-12-26 00:02:32",
  "retrieved_files": [
    {
      "source_file": "mm/page_alloc.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:59:58\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_alloc.c`\n\n---\n\n# page_alloc.c 技术文档\n\n## 1. 文件概述\n\n`page_alloc.c` 是 Linux 内核内存管理子系统的核心文件之一，负责物理页面的分配与释放。该文件实现了基于区域（zone）和迁移类型（migratetype）的伙伴系统（Buddy System）内存分配器，管理系统的空闲页链表，并提供高效的页面分配/回收机制。它不处理小对象分配（由 slab/slub/slob 子系统负责），而是专注于以页为单位的大块物理内存管理。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct per_cpu_pages`**：每个 CPU 的每区（per-zone）页面缓存，用于减少锁竞争，提升分配性能。\n- **`node_states[NR_NODE_STATES]`**：全局节点状态掩码数组，跟踪各 NUMA 节点的状态（如在线、有内存等）。\n- **`sysctl_lowmem_reserve_ratio[MAX_NR_ZONES]`**：各内存区域的低内存保留比例，防止高优先级区域耗尽低优先级区域的内存。\n- **`zone_names[]` 和 `migratetype_names[]`**：内存区域和页面迁移类型的名称字符串，用于调试和日志。\n- **`gfp_allowed_mask`**：全局 GFP（Get Free Page）标志掩码，控制启动早期可使用的分配标志。\n\n### 主要函数（部分声明）\n- **`__free_pages_ok()`**：内部页面释放函数，执行实际的伙伴系统合并与链表插入逻辑。\n- 各种页面分配函数（如 `alloc_pages()`、`__alloc_pages()` 等，定义在其他位置但在此文件中实现核心逻辑）。\n- 每 CPU 页面列表操作辅助宏（如 `pcp_spin_lock()`、`pcp_spin_trylock()`）。\n\n### 关键常量与标志\n- **`fpi_t` 类型及标志**：\n  - `FPI_NONE`：无特殊要求。\n  - `FPI_SKIP_REPORT_NOTIFY`：跳过空闲页报告通知。\n  - `FPI_TO_TAIL`：将页面放回空闲链表尾部（用于优化场景如内存热插拔）。\n- **`min_free_kbytes`**：系统保留的最小空闲内存（KB），影响水位线计算。\n\n## 3. 关键实现\n\n### 每 CPU 页面缓存（Per-CPU Page Caching）\n- 通过 `struct per_cpu_pages` 为每个 CPU 维护热/冷页列表，避免频繁访问全局 zone 锁。\n- 使用 `pcpu_spin_lock` 宏族安全地访问每 CPU 数据，结合 `preempt_disable()`（非 RT）或 `migrate_disable()`（RT）防止任务迁移导致访问错误 CPU 的数据。\n- 在 UP 系统上，使用 IRQ 关闭防止重入；在 SMP/RT 系统上依赖自旋锁语义。\n\n### 内存区域（Zone）与 NUMA 支持\n- 支持多种内存区域（DMA、DMA32、Normal、HighMem、Movable、Device），通过 `zone_names` 标识。\n- 实现 `lowmem_reserve_ratio` 机制，确保高区域分配不会耗尽低区域的保留内存（如 ZONE_DMA 为设备保留）。\n- 通过 `node_states` 和 per-CPU 变量（如 `numa_node`、`_numa_mem_`）支持 NUMA 和无内存节点架构。\n\n### 空闲页管理优化\n- **`FPI_TO_TAIL` 标志**：允许将页面放回空闲链表尾部，配合内存打乱（shuffle）或热插拔时批量初始化。\n- **`FPI_SKIP_REPORT_NOTIFY` 标志**：在临时取出并归还页面时不触发空闲页报告机制，减少开销。\n- **水位线与保留内存**：`min_free_kbytes` 控制最低水位，影响 OOM（Out-Of-Memory）决策和内存回收行为。\n\n### 实时内核（PREEMPT_RT）适配\n- 在 RT 内核中使用 `migrate_disable()` 替代 `preempt_disable()`，避免干扰 RT 自旋锁的优先级继承机制。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **核心内存管理**：`<linux/mm.h>`, `<linux/highmem.h>`, `\"internal.h\"`\n- **同步机制**：`<linux/spinlock.h>`（隐含）、`<linux/mutex.h>`\n- **NUMA 与拓扑**：`<linux/topology.h>`, `<linux/nodemask.h>`\n- **调试与追踪**：`<linux/kasan.h>`, `<trace/events/kmem.h>`, `<linux/page_owner.h>`\n- **高级特性**：`<linux/compaction.h>`, `<linux/migrate.h>`, `<linux/memcontrol.h>`\n\n### 子系统交互\n- **Slab 分配器**：本文件不处理 kmalloc，由 `slab.c` 等负责。\n- **内存回收**：与 `vmscan.c` 协同，通过水位线触发 reclaim。\n- **内存热插拔**：通过 `memory_hotplug.h` 接口管理动态内存。\n- **OOM Killer**：通过 `oom.h` 和水位线机制触发 OOM。\n- **透明大页（THP）**：与 `khugepaged` 协同进行大页分配。\n\n## 5. 使用场景\n\n- **内核内存分配**：所有以页为单位的内核内存请求（如 `alloc_pages()`）最终由本文件处理。\n- **用户空间缺页处理**：匿名页、文件页的物理页分配。\n- **内存映射（mmap）**：大块物理内存的分配与管理。\n- **内存回收与迁移**：页面回收、压缩（compaction）、迁移（migration）过程中涉及的页面释放与重新分配。\n- **系统启动与热插拔**：初始化内存区域、处理动态添加/移除内存。\n- **实时系统**：在 PREEMPT_RT 内核中提供低延迟的页面分配路径。\n- **调试与监控**：通过 page owner、KASAN、tracepoint 等机制提供内存使用追踪。",
      "similarity": 0.5817797780036926,
      "chunks": [
        {
          "chunk_id": 23,
          "file_path": "mm/page_alloc.c",
          "start_line": 4471,
          "end_line": 4660,
          "content": [
            "static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order,",
            "\t\tint preferred_nid, nodemask_t *nodemask,",
            "\t\tstruct alloc_context *ac, gfp_t *alloc_gfp,",
            "\t\tunsigned int *alloc_flags)",
            "{",
            "\tac->highest_zoneidx = gfp_zone(gfp_mask);",
            "\tac->zonelist = node_zonelist(preferred_nid, gfp_mask);",
            "\tac->nodemask = nodemask;",
            "\tac->migratetype = gfp_migratetype(gfp_mask);",
            "",
            "\tif (cpusets_enabled()) {",
            "\t\t*alloc_gfp |= __GFP_HARDWALL;",
            "\t\t/*",
            "\t\t * When we are in the interrupt context, it is irrelevant",
            "\t\t * to the current task context. It means that any node ok.",
            "\t\t */",
            "\t\tif (in_task() && !ac->nodemask)",
            "\t\t\tac->nodemask = &cpuset_current_mems_allowed;",
            "\t\telse",
            "\t\t\t*alloc_flags |= ALLOC_CPUSET;",
            "\t}",
            "",
            "\tmight_alloc(gfp_mask);",
            "",
            "\tif (should_fail_alloc_page(gfp_mask, order))",
            "\t\treturn false;",
            "",
            "\t*alloc_flags = gfp_to_alloc_flags_cma(gfp_mask, *alloc_flags);",
            "",
            "\t/* Dirty zone balancing only done in the fast path */",
            "\tac->spread_dirty_pages = (gfp_mask & __GFP_WRITE);",
            "",
            "\t/*",
            "\t * The preferred zone is used for statistics but crucially it is",
            "\t * also used as the starting point for the zonelist iterator. It",
            "\t * may get reset for allocations that ignore memory policies.",
            "\t */",
            "\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,",
            "\t\t\t\t\tac->highest_zoneidx, ac->nodemask);",
            "",
            "\treturn true;",
            "}",
            "unsigned long alloc_pages_bulk_noprof(gfp_t gfp, int preferred_nid,",
            "\t\t\tnodemask_t *nodemask, int nr_pages,",
            "\t\t\tstruct list_head *page_list,",
            "\t\t\tstruct page **page_array)",
            "{",
            "\tstruct page *page;",
            "\tunsigned long __maybe_unused UP_flags;",
            "\tstruct zone *zone;",
            "\tstruct zoneref *z;",
            "\tstruct per_cpu_pages *pcp;",
            "\tstruct list_head *pcp_list;",
            "\tstruct alloc_context ac;",
            "\tgfp_t alloc_gfp;",
            "\tunsigned int alloc_flags = ALLOC_WMARK_LOW;",
            "\tint nr_populated = 0, nr_account = 0;",
            "",
            "\t/*",
            "\t * Skip populated array elements to determine if any pages need",
            "\t * to be allocated before disabling IRQs.",
            "\t */",
            "\twhile (page_array && nr_populated < nr_pages && page_array[nr_populated])",
            "\t\tnr_populated++;",
            "",
            "\t/* No pages requested? */",
            "\tif (unlikely(nr_pages <= 0))",
            "\t\tgoto out;",
            "",
            "\t/* Already populated array? */",
            "\tif (unlikely(page_array && nr_pages - nr_populated == 0))",
            "\t\tgoto out;",
            "",
            "\t/* Bulk allocator does not support memcg accounting. */",
            "\tif (memcg_kmem_online() && (gfp & __GFP_ACCOUNT))",
            "\t\tgoto failed;",
            "",
            "\t/* Use the single page allocator for one page. */",
            "\tif (nr_pages - nr_populated == 1)",
            "\t\tgoto failed;",
            "",
            "#ifdef CONFIG_PAGE_OWNER",
            "\t/*",
            "\t * PAGE_OWNER may recurse into the allocator to allocate space to",
            "\t * save the stack with pagesets.lock held. Releasing/reacquiring",
            "\t * removes much of the performance benefit of bulk allocation so",
            "\t * force the caller to allocate one page at a time as it'll have",
            "\t * similar performance to added complexity to the bulk allocator.",
            "\t */",
            "\tif (static_branch_unlikely(&page_owner_inited))",
            "\t\tgoto failed;",
            "#endif",
            "",
            "\t/* May set ALLOC_NOFRAGMENT, fragmentation will return 1 page. */",
            "\tgfp &= gfp_allowed_mask;",
            "\talloc_gfp = gfp;",
            "\tif (!prepare_alloc_pages(gfp, 0, preferred_nid, nodemask, &ac, &alloc_gfp, &alloc_flags))",
            "\t\tgoto out;",
            "\tgfp = alloc_gfp;",
            "",
            "\t/* Find an allowed local zone that meets the low watermark. */",
            "\tz = ac.preferred_zoneref;",
            "\tfor_next_zone_zonelist_nodemask(zone, z, ac.highest_zoneidx, ac.nodemask) {",
            "\t\tunsigned long mark;",
            "",
            "\t\tif (cpusets_enabled() && (alloc_flags & ALLOC_CPUSET) &&",
            "\t\t    !__cpuset_zone_allowed(zone, gfp)) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (nr_online_nodes > 1 && zone != ac.preferred_zoneref->zone &&",
            "\t\t    zone_to_nid(zone) != zone_to_nid(ac.preferred_zoneref->zone)) {",
            "\t\t\tgoto failed;",
            "\t\t}",
            "",
            "\t\tmark = wmark_pages(zone, alloc_flags & ALLOC_WMARK_MASK) + nr_pages;",
            "\t\tif (zone_watermark_fast(zone, 0,  mark,",
            "\t\t\t\tzonelist_zone_idx(ac.preferred_zoneref),",
            "\t\t\t\talloc_flags, gfp)) {",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * If there are no allowed local zones that meets the watermarks then",
            "\t * try to allocate a single page and reclaim if necessary.",
            "\t */",
            "\tif (unlikely(!zone))",
            "\t\tgoto failed;",
            "",
            "\t/* spin_trylock may fail due to a parallel drain or IRQ reentrancy. */",
            "\tpcp_trylock_prepare(UP_flags);",
            "\tpcp = pcp_spin_trylock(zone->per_cpu_pageset);",
            "\tif (!pcp)",
            "\t\tgoto failed_irq;",
            "",
            "\t/* Attempt the batch allocation */",
            "\tpcp_list = &pcp->lists[order_to_pindex(ac.migratetype, 0)];",
            "\twhile (nr_populated < nr_pages) {",
            "",
            "\t\t/* Skip existing pages */",
            "\t\tif (page_array && page_array[nr_populated]) {",
            "\t\t\tnr_populated++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tpage = __rmqueue_pcplist(zone, 0, ac.migratetype, alloc_flags,",
            "\t\t\t\t\t\t\t\tpcp, pcp_list);",
            "\t\tif (unlikely(!page)) {",
            "\t\t\t/* Try and allocate at least one page */",
            "\t\t\tif (!nr_account) {",
            "\t\t\t\tpcp_spin_unlock(pcp);",
            "\t\t\t\tgoto failed_irq;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tnr_account++;",
            "",
            "\t\tprep_new_page(page, 0, gfp, 0);",
            "\t\tif (page_list)",
            "\t\t\tlist_add(&page->lru, page_list);",
            "\t\telse",
            "\t\t\tpage_array[nr_populated] = page;",
            "\t\tnr_populated++;",
            "\t}",
            "",
            "\tpcp_spin_unlock(pcp);",
            "\tpcp_trylock_finish(UP_flags);",
            "",
            "\t__count_zid_vm_events(PGALLOC, zone_idx(zone), nr_account);",
            "\tzone_statistics(ac.preferred_zoneref->zone, zone, nr_account);",
            "",
            "out:",
            "\treturn nr_populated;",
            "",
            "failed_irq:",
            "\tpcp_trylock_finish(UP_flags);",
            "",
            "failed:",
            "\tpage = __alloc_pages_noprof(gfp, 0, preferred_nid, nodemask);",
            "\tif (page) {",
            "\t\tif (page_list)",
            "\t\t\tlist_add(&page->lru, page_list);",
            "\t\telse",
            "\t\t\tpage_array[nr_populated] = page;",
            "\t\tnr_populated++;",
            "\t}",
            "",
            "\tgoto out;",
            "}"
          ],
          "function_name": "prepare_alloc_pages, alloc_pages_bulk_noprof",
          "description": "该代码段实现了内存页面的批量分配逻辑，其中`prepare_alloc_pages`用于初始化分配上下文参数并配置内存策略，`alloc_pages_bulk_noprof`则通过遍历内存区域尝试批量分配连续页面，优先使用本地节点且支持CPU集约束。  \n`prepare_alloc_pages`构建分配上下文，设置Zone列表、迁移类型及节点掩码，处理CPU集隔离与水位线检查；`alloc_pages_bulk_noprof`在满足水位线前提下批量分配页面，失败时回退至单页分配。  \n上下文完整，未引入未展示的API或机制。",
          "similarity": 0.6232714056968689
        },
        {
          "chunk_id": 24,
          "file_path": "mm/page_alloc.c",
          "start_line": 4766,
          "end_line": 4869,
          "content": [
            "unsigned long get_free_pages_noprof(gfp_t gfp_mask, unsigned int order)",
            "{",
            "\tstruct page *page;",
            "",
            "\tpage = alloc_pages_noprof(gfp_mask & ~__GFP_HIGHMEM, order);",
            "\tif (!page)",
            "\t\treturn 0;",
            "\treturn (unsigned long) page_address(page);",
            "}",
            "unsigned long get_zeroed_page_noprof(gfp_t gfp_mask)",
            "{",
            "\treturn get_free_pages_noprof(gfp_mask | __GFP_ZERO, 0);",
            "}",
            "void __free_pages(struct page *page, unsigned int order)",
            "{",
            "\t/* get PageHead before we drop reference */",
            "\tint head = PageHead(page);",
            "\t/* get alloc tag in case the page is released by others */",
            "\tstruct alloc_tag *tag = pgalloc_tag_get(page);",
            "",
            "\tif (put_page_testzero(page))",
            "\t\tfree_unref_page(page, order);",
            "\telse if (!head) {",
            "\t\tpgalloc_tag_sub_pages(tag, (1 << order) - 1);",
            "\t\twhile (order-- > 0)",
            "\t\t\tfree_unref_page(page + (1 << order), order);",
            "\t}",
            "}",
            "void free_pages(unsigned long addr, unsigned int order)",
            "{",
            "\tif (addr != 0) {",
            "\t\tVM_BUG_ON(!virt_addr_valid((void *)addr));",
            "\t\t__free_pages(virt_to_page((void *)addr), order);",
            "\t}",
            "}",
            "void __page_frag_cache_drain(struct page *page, unsigned int count)",
            "{",
            "\tVM_BUG_ON_PAGE(page_ref_count(page) == 0, page);",
            "",
            "\tif (page_ref_sub_and_test(page, count))",
            "\t\tfree_unref_page(page, compound_order(page));",
            "}",
            "void page_frag_free(void *addr)",
            "{",
            "\tstruct page *page = virt_to_head_page(addr);",
            "",
            "\tif (unlikely(put_page_testzero(page)))",
            "\t\tfree_unref_page(page, compound_order(page));",
            "}",
            "void free_pages_exact(void *virt, size_t size)",
            "{",
            "\tunsigned long addr = (unsigned long)virt;",
            "\tunsigned long end = addr + PAGE_ALIGN(size);",
            "",
            "\twhile (addr < end) {",
            "\t\tfree_page(addr);",
            "\t\taddr += PAGE_SIZE;",
            "\t}",
            "}",
            "static unsigned long nr_free_zone_pages(int offset)",
            "{",
            "\tstruct zoneref *z;",
            "\tstruct zone *zone;",
            "",
            "\t/* Just pick one node, since fallback list is circular */",
            "\tunsigned long sum = 0;",
            "",
            "\tstruct zonelist *zonelist = node_zonelist(numa_node_id(), GFP_KERNEL);",
            "",
            "\tfor_each_zone_zonelist(zone, z, zonelist, offset) {",
            "\t\tunsigned long size = zone_managed_pages(zone);",
            "\t\tunsigned long high = high_wmark_pages(zone);",
            "\t\tif (size > high)",
            "\t\t\tsum += size - high;",
            "\t}",
            "",
            "\treturn sum;",
            "}",
            "unsigned long nr_free_buffer_pages(void)",
            "{",
            "\treturn nr_free_zone_pages(gfp_zone(GFP_USER));",
            "}",
            "static void zoneref_set_zone(struct zone *zone, struct zoneref *zoneref)",
            "{",
            "\tzoneref->zone = zone;",
            "\tzoneref->zone_idx = zone_idx(zone);",
            "}",
            "static int build_zonerefs_node(pg_data_t *pgdat, struct zoneref *zonerefs)",
            "{",
            "\tstruct zone *zone;",
            "\tenum zone_type zone_type = MAX_NR_ZONES;",
            "\tint nr_zones = 0;",
            "",
            "\tdo {",
            "\t\tzone_type--;",
            "\t\tzone = pgdat->node_zones + zone_type;",
            "\t\tif (populated_zone(zone)) {",
            "\t\t\tzoneref_set_zone(zone, &zonerefs[nr_zones++]);",
            "\t\t\tcheck_highest_zone(zone_type);",
            "\t\t}",
            "\t} while (zone_type);",
            "",
            "\treturn nr_zones;",
            "}"
          ],
          "function_name": "get_free_pages_noprof, get_zeroed_page_noprof, __free_pages, free_pages, __page_frag_cache_drain, page_frag_free, free_pages_exact, nr_free_zone_pages, nr_free_buffer_pages, zoneref_set_zone, build_zonerefs_node",
          "description": "该代码段实现非profile模式下的页面分配与释放逻辑，包含get_free_pages_noprof等函数用于分配带零填充的连续页框，__free_pages及其辅助函数负责处理复杂引用计数和碎片化页面回收，同时通过nr_free_zone_pages等接口统计ZONE层级的空闲页数量。部分函数依赖未展示的上下文（如alloc_pages_noprof、compound_order等）。",
          "similarity": 0.5995193123817444
        },
        {
          "chunk_id": 16,
          "file_path": "mm/page_alloc.c",
          "start_line": 2768,
          "end_line": 2902,
          "content": [
            "void split_page(struct page *page, unsigned int order)",
            "{",
            "\tint i;",
            "",
            "\tVM_BUG_ON_PAGE(PageCompound(page), page);",
            "\tVM_BUG_ON_PAGE(!page_count(page), page);",
            "",
            "\tfor (i = 1; i < (1 << order); i++)",
            "\t\tset_page_refcounted(page + i);",
            "\tsplit_page_owner(page, order, 0);",
            "\tpgalloc_tag_split(page_folio(page), order, 0);",
            "\tsplit_page_memcg(page, order, 0);",
            "}",
            "int __isolate_free_page(struct page *page, unsigned int order)",
            "{",
            "\tstruct zone *zone = page_zone(page);",
            "\tint mt = get_pageblock_migratetype(page);",
            "",
            "\tif (!is_migrate_isolate(mt)) {",
            "\t\tunsigned long watermark;",
            "\t\t/*",
            "\t\t * Obey watermarks as if the page was being allocated. We can",
            "\t\t * emulate a high-order watermark check with a raised order-0",
            "\t\t * watermark, because we already know our high-order page",
            "\t\t * exists.",
            "\t\t */",
            "\t\twatermark = zone->_watermark[WMARK_MIN] + (1UL << order);",
            "\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\tdel_page_from_free_list(page, zone, order, mt);",
            "",
            "\t/*",
            "\t * Set the pageblock if the isolated page is at least half of a",
            "\t * pageblock",
            "\t */",
            "\tif (order >= pageblock_order - 1) {",
            "\t\tstruct page *endpage = page + (1 << order) - 1;",
            "\t\tfor (; page < endpage; page += pageblock_nr_pages) {",
            "\t\t\tint mt = get_pageblock_migratetype(page);",
            "\t\t\t/*",
            "\t\t\t * Only change normal pageblocks (i.e., they can merge",
            "\t\t\t * with others)",
            "\t\t\t */",
            "\t\t\tif (migratetype_is_mergeable(mt))",
            "\t\t\t\tmove_freepages_block(zone, page, mt,",
            "\t\t\t\t\t\t     MIGRATE_MOVABLE);",
            "\t\t}",
            "\t}",
            "",
            "\treturn 1UL << order;",
            "}",
            "void __putback_isolated_page(struct page *page, unsigned int order, int mt)",
            "{",
            "\tstruct zone *zone = page_zone(page);",
            "",
            "\t/* zone lock should be held when this function is called */",
            "\tlockdep_assert_held(&zone->lock);",
            "",
            "\t/* Return isolated page to tail of freelist. */",
            "\t__free_one_page(page, page_to_pfn(page), zone, order, mt,",
            "\t\t\tFPI_SKIP_REPORT_NOTIFY | FPI_TO_TAIL);",
            "}",
            "static inline void zone_statistics(struct zone *preferred_zone, struct zone *z,",
            "\t\t\t\t   long nr_account)",
            "{",
            "#ifdef CONFIG_NUMA",
            "\tenum numa_stat_item local_stat = NUMA_LOCAL;",
            "",
            "\t/* skip numa counters update if numa stats is disabled */",
            "\tif (!static_branch_likely(&vm_numa_stat_key))",
            "\t\treturn;",
            "",
            "\tif (zone_to_nid(z) != numa_node_id())",
            "\t\tlocal_stat = NUMA_OTHER;",
            "",
            "\tif (zone_to_nid(z) == zone_to_nid(preferred_zone))",
            "\t\t__count_numa_events(z, NUMA_HIT, nr_account);",
            "\telse {",
            "\t\t__count_numa_events(z, NUMA_MISS, nr_account);",
            "\t\t__count_numa_events(preferred_zone, NUMA_FOREIGN, nr_account);",
            "\t}",
            "\t__count_numa_events(z, local_stat, nr_account);",
            "#endif",
            "}",
            "static int nr_pcp_alloc(struct per_cpu_pages *pcp, struct zone *zone, int order)",
            "{",
            "\tint high, base_batch, batch, max_nr_alloc;",
            "\tint high_max, high_min;",
            "",
            "\tbase_batch = READ_ONCE(pcp->batch);",
            "\thigh_min = READ_ONCE(pcp->high_min);",
            "\thigh_max = READ_ONCE(pcp->high_max);",
            "\thigh = pcp->high = clamp(pcp->high, high_min, high_max);",
            "",
            "\t/* Check for PCP disabled or boot pageset */",
            "\tif (unlikely(high < base_batch))",
            "\t\treturn 1;",
            "",
            "\tif (order)",
            "\t\tbatch = base_batch;",
            "\telse",
            "\t\tbatch = (base_batch << pcp->alloc_factor);",
            "",
            "\t/*",
            "\t * If we had larger pcp->high, we could avoid to allocate from",
            "\t * zone.",
            "\t */",
            "\tif (high_min != high_max && !test_bit(ZONE_BELOW_HIGH, &zone->flags))",
            "\t\thigh = pcp->high = min(high + batch, high_max);",
            "",
            "\tif (!order) {",
            "\t\tmax_nr_alloc = max(high - pcp->count - base_batch, base_batch);",
            "\t\t/*",
            "\t\t * Double the number of pages allocated each time there is",
            "\t\t * subsequent allocation of order-0 pages without any freeing.",
            "\t\t */",
            "\t\tif (batch <= max_nr_alloc &&",
            "\t\t    pcp->alloc_factor < CONFIG_PCP_BATCH_SCALE_MAX)",
            "\t\t\tpcp->alloc_factor++;",
            "\t\tbatch = min(batch, max_nr_alloc);",
            "\t}",
            "",
            "\t/*",
            "\t * Scale batch relative to order if batch implies free pages",
            "\t * can be stored on the PCP. Batch can be 1 for small zones or",
            "\t * for boot pagesets which should never store free pages as",
            "\t * the pages may belong to arbitrary zones.",
            "\t */",
            "\tif (batch > 1)",
            "\t\tbatch = max(batch >> order, 2);",
            "",
            "\treturn batch;",
            "}"
          ],
          "function_name": "split_page, __isolate_free_page, __putback_isolated_page, zone_statistics, nr_pcp_alloc",
          "description": "split_page 分裂复合页面为独立页；__isolate_free_page 将隔离页从自由列表移除并调整页块类型；__putback_isolated_page 将隔离页重新放入自由列表尾部；nr_pcp_alloc 计算 PCP 列表可容纳的页面数量，动态调整批次大小以优化内存分配效率。",
          "similarity": 0.5719121694564819
        },
        {
          "chunk_id": 29,
          "file_path": "mm/page_alloc.c",
          "start_line": 5701,
          "end_line": 5807,
          "content": [
            "void __meminit setup_zone_pageset(struct zone *zone)",
            "{",
            "\tint cpu;",
            "",
            "\t/* Size may be 0 on !SMP && !NUMA */",
            "\tif (sizeof(struct per_cpu_zonestat) > 0)",
            "\t\tzone->per_cpu_zonestats = alloc_percpu(struct per_cpu_zonestat);",
            "",
            "\tzone->per_cpu_pageset = alloc_percpu(struct per_cpu_pages);",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tstruct per_cpu_pages *pcp;",
            "\t\tstruct per_cpu_zonestat *pzstats;",
            "",
            "\t\tpcp = per_cpu_ptr(zone->per_cpu_pageset, cpu);",
            "\t\tpzstats = per_cpu_ptr(zone->per_cpu_zonestats, cpu);",
            "\t\tper_cpu_pages_init(pcp, pzstats);",
            "\t}",
            "",
            "\tzone_set_pageset_high_and_batch(zone, 0);",
            "}",
            "static void zone_pcp_update(struct zone *zone, int cpu_online)",
            "{",
            "\tmutex_lock(&pcp_batch_high_lock);",
            "\tzone_set_pageset_high_and_batch(zone, cpu_online);",
            "\tmutex_unlock(&pcp_batch_high_lock);",
            "}",
            "static void zone_pcp_update_cacheinfo(struct zone *zone, unsigned int cpu)",
            "{",
            "\tstruct per_cpu_pages *pcp;",
            "\tstruct cpu_cacheinfo *cci;",
            "",
            "\tpcp = per_cpu_ptr(zone->per_cpu_pageset, cpu);",
            "\tcci = get_cpu_cacheinfo(cpu);",
            "\t/*",
            "\t * If data cache slice of CPU is large enough, \"pcp->batch\"",
            "\t * pages can be preserved in PCP before draining PCP for",
            "\t * consecutive high-order pages freeing without allocation.",
            "\t * This can reduce zone lock contention without hurting",
            "\t * cache-hot pages sharing.",
            "\t */",
            "\tspin_lock(&pcp->lock);",
            "\tif ((cci->per_cpu_data_slice_size >> PAGE_SHIFT) > 3 * pcp->batch)",
            "\t\tpcp->flags |= PCPF_FREE_HIGH_BATCH;",
            "\telse",
            "\t\tpcp->flags &= ~PCPF_FREE_HIGH_BATCH;",
            "\tspin_unlock(&pcp->lock);",
            "}",
            "void setup_pcp_cacheinfo(unsigned int cpu)",
            "{",
            "\tstruct zone *zone;",
            "",
            "\tfor_each_populated_zone(zone)",
            "\t\tzone_pcp_update_cacheinfo(zone, cpu);",
            "}",
            "void __init setup_per_cpu_pageset(void)",
            "{",
            "\tstruct pglist_data *pgdat;",
            "\tstruct zone *zone;",
            "\tint __maybe_unused cpu;",
            "",
            "\tfor_each_populated_zone(zone)",
            "\t\tsetup_zone_pageset(zone);",
            "",
            "#ifdef CONFIG_NUMA",
            "\t/*",
            "\t * Unpopulated zones continue using the boot pagesets.",
            "\t * The numa stats for these pagesets need to be reset.",
            "\t * Otherwise, they will end up skewing the stats of",
            "\t * the nodes these zones are associated with.",
            "\t */",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tstruct per_cpu_zonestat *pzstats = &per_cpu(boot_zonestats, cpu);",
            "\t\tmemset(pzstats->vm_numa_event, 0,",
            "\t\t       sizeof(pzstats->vm_numa_event));",
            "\t}",
            "#endif",
            "",
            "\tfor_each_online_pgdat(pgdat)",
            "\t\tpgdat->per_cpu_nodestats =",
            "\t\t\talloc_percpu(struct per_cpu_nodestat);",
            "}",
            "__meminit void zone_pcp_init(struct zone *zone)",
            "{",
            "\t/*",
            "\t * per cpu subsystem is not up at this point. The following code",
            "\t * relies on the ability of the linker to provide the",
            "\t * offset of a (static) per cpu variable into the per cpu area.",
            "\t */",
            "\tzone->per_cpu_pageset = &boot_pageset;",
            "\tzone->per_cpu_zonestats = &boot_zonestats;",
            "\tzone->pageset_high_min = BOOT_PAGESET_HIGH;",
            "\tzone->pageset_high_max = BOOT_PAGESET_HIGH;",
            "\tzone->pageset_batch = BOOT_PAGESET_BATCH;",
            "",
            "\tif (populated_zone(zone))",
            "\t\tpr_debug(\"  %s zone: %lu pages, LIFO batch:%u\\n\", zone->name,",
            "\t\t\t zone->present_pages, zone_batchsize(zone));",
            "}",
            "void adjust_managed_page_count(struct page *page, long count)",
            "{",
            "\tatomic_long_add(count, &page_zone(page)->managed_pages);",
            "\ttotalram_pages_add(count);",
            "#ifdef CONFIG_HIGHMEM",
            "\tif (PageHighMem(page))",
            "\t\ttotalhigh_pages_add(count);",
            "#endif",
            "}"
          ],
          "function_name": "setup_zone_pageset, zone_pcp_update, zone_pcp_update_cacheinfo, setup_pcp_cacheinfo, setup_per_cpu_pageset, zone_pcp_init, adjust_managed_page_count",
          "description": "分配并初始化每个区的页集结构，设置初始参数，根据CPU状态更新页集配置，维护管理页面计数统计信息。",
          "similarity": 0.5706207752227783
        },
        {
          "chunk_id": 8,
          "file_path": "mm/page_alloc.c",
          "start_line": 1380,
          "end_line": 1524,
          "content": [
            "static inline void expand(struct zone *zone, struct page *page,",
            "\tint low, int high, int migratetype)",
            "{",
            "\tunsigned long size = 1 << high;",
            "\tunsigned long nr_added = 0;",
            "",
            "\twhile (high > low) {",
            "\t\thigh--;",
            "\t\tsize >>= 1;",
            "\t\tVM_BUG_ON_PAGE(bad_range(zone, &page[size]), &page[size]);",
            "",
            "\t\t/*",
            "\t\t * Mark as guard pages (or page), that will allow to",
            "\t\t * merge back to allocator when buddy will be freed.",
            "\t\t * Corresponding page table entries will not be touched,",
            "\t\t * pages will stay not present in virtual address space",
            "\t\t */",
            "\t\tif (set_page_guard(zone, &page[size], high))",
            "\t\t\tcontinue;",
            "",
            "\t\t__add_to_free_list(&page[size], zone, high, migratetype, false);",
            "\t\tset_buddy_order(&page[size], high);",
            "\t\tnr_added += size;",
            "\t}",
            "\taccount_freepages(zone, nr_added, migratetype);",
            "}",
            "static void check_new_page_bad(struct page *page)",
            "{",
            "\tif (unlikely(page->flags & __PG_HWPOISON)) {",
            "\t\t/* Don't complain about hwpoisoned pages */",
            "\t\tpage_mapcount_reset(page); /* remove PageBuddy */",
            "\t\treturn;",
            "\t}",
            "",
            "\tbad_page(page,",
            "\t\t page_bad_reason(page, PAGE_FLAGS_CHECK_AT_PREP));",
            "}",
            "static bool check_new_page(struct page *page)",
            "{",
            "\tif (likely(page_expected_state(page,",
            "\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)))",
            "\t\treturn false;",
            "",
            "\tcheck_new_page_bad(page);",
            "\treturn true;",
            "}",
            "static inline bool check_new_pages(struct page *page, unsigned int order)",
            "{",
            "\tif (is_check_pages_enabled()) {",
            "\t\tfor (int i = 0; i < (1 << order); i++) {",
            "\t\t\tstruct page *p = page + i;",
            "",
            "\t\t\tif (check_new_page(p))",
            "\t\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static inline bool should_skip_kasan_unpoison(gfp_t flags)",
            "{",
            "\t/* Don't skip if a software KASAN mode is enabled. */",
            "\tif (IS_ENABLED(CONFIG_KASAN_GENERIC) ||",
            "\t    IS_ENABLED(CONFIG_KASAN_SW_TAGS))",
            "\t\treturn false;",
            "",
            "\t/* Skip, if hardware tag-based KASAN is not enabled. */",
            "\tif (!kasan_hw_tags_enabled())",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * With hardware tag-based KASAN enabled, skip if this has been",
            "\t * requested via __GFP_SKIP_KASAN.",
            "\t */",
            "\treturn flags & __GFP_SKIP_KASAN;",
            "}",
            "static inline bool should_skip_init(gfp_t flags)",
            "{",
            "\t/* Don't skip, if hardware tag-based KASAN is not enabled. */",
            "\tif (!kasan_hw_tags_enabled())",
            "\t\treturn false;",
            "",
            "\t/* For hardware tag-based KASAN, skip if requested. */",
            "\treturn (flags & __GFP_SKIP_ZERO);",
            "}",
            "inline void post_alloc_hook(struct page *page, unsigned int order,",
            "\t\t\t\tgfp_t gfp_flags)",
            "{",
            "\tbool init = !want_init_on_free() && want_init_on_alloc(gfp_flags) &&",
            "\t\t\t!should_skip_init(gfp_flags);",
            "\tbool zero_tags = init && (gfp_flags & __GFP_ZEROTAGS);",
            "\tint i;",
            "",
            "\tset_page_private(page, 0);",
            "\tset_page_refcounted(page);",
            "",
            "\tarch_alloc_page(page, order);",
            "\tdebug_pagealloc_map_pages(page, 1 << order);",
            "",
            "\t/*",
            "\t * Page unpoisoning must happen before memory initialization.",
            "\t * Otherwise, the poison pattern will be overwritten for __GFP_ZERO",
            "\t * allocations and the page unpoisoning code will complain.",
            "\t */",
            "\tkernel_unpoison_pages(page, 1 << order);",
            "",
            "\t/*",
            "\t * As memory initialization might be integrated into KASAN,",
            "\t * KASAN unpoisoning and memory initializion code must be",
            "\t * kept together to avoid discrepancies in behavior.",
            "\t */",
            "",
            "\t/*",
            "\t * If memory tags should be zeroed",
            "\t * (which happens only when memory should be initialized as well).",
            "\t */",
            "\tif (zero_tags) {",
            "\t\t/* Initialize both memory and memory tags. */",
            "\t\tfor (i = 0; i != 1 << order; ++i)",
            "\t\t\ttag_clear_highpage(page + i);",
            "",
            "\t\t/* Take note that memory was initialized by the loop above. */",
            "\t\tinit = false;",
            "\t}",
            "\tif (!should_skip_kasan_unpoison(gfp_flags) &&",
            "\t    kasan_unpoison_pages(page, order, init)) {",
            "\t\t/* Take note that memory was initialized by KASAN. */",
            "\t\tif (kasan_has_integrated_init())",
            "\t\t\tinit = false;",
            "\t} else {",
            "\t\t/*",
            "\t\t * If memory tags have not been set by KASAN, reset the page",
            "\t\t * tags to ensure page_address() dereferencing does not fault.",
            "\t\t */",
            "\t\tfor (i = 0; i != 1 << order; ++i)",
            "\t\t\tpage_kasan_tag_reset(page + i);",
            "\t}",
            "\t/* If memory is still not initialized, initialize it now. */",
            "\tif (init)",
            "\t\tkernel_init_pages(page, 1 << order);",
            "",
            "\tset_page_owner(page, order, gfp_flags);",
            "\tpage_table_check_alloc(page, order);",
            "\tpgalloc_tag_add(page, current, 1 << order);",
            "}"
          ],
          "function_name": "expand, check_new_page_bad, check_new_page, check_new_pages, should_skip_kasan_unpoison, should_skip_init, post_alloc_hook",
          "description": "expand扩展空闲区域并设置保护页，check_new_page系列检查新分配页面有效性，post_alloc_hook处理分配后初始化、标签清除及KASAN集成初始化",
          "similarity": 0.5560571551322937
        }
      ]
    },
    {
      "source_file": "mm/debug_page_alloc.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:54:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `debug_page_alloc.c`\n\n---\n\n# debug_page_alloc.c 技术文档\n\n## 1. 文件概述\n\n`debug_page_alloc.c` 是 Linux 内核中用于支持页分配调试功能的核心实现文件。该文件主要提供两个关键调试机制：\n\n- **页分配调试（debug_pagealloc）**：在内存分配/释放时对页面进行特殊标记和保护，用于检测内存越界访问、重复释放等错误。\n- **守护页（guard page）机制**：在分配的大块内存前后插入不可访问的“守护页”，用于捕获缓冲区溢出等内存破坏问题。\n\n该文件通过内核启动参数控制调试功能的启用状态和行为参数，并提供底层页标志操作接口供内存管理子系统调用。\n\n## 2. 核心功能\n\n### 全局变量\n- `_debug_guardpage_minorder`：守护页机制生效的最小分配阶数阈值\n- `_debug_pagealloc_enabled_early`：早期启动阶段页分配调试的启用状态\n- `_debug_pagealloc_enabled`：运行时页分配调试功能的静态键开关\n- `_debug_guardpage_enabled`：守护页功能的静态键开关\n\n### 函数接口\n- `early_debug_pagealloc()`：解析 `debug_pagealloc=` 内核启动参数\n- `debug_guardpage_minorder_setup()`：解析 `debug_guardpage_minorder=` 内核启动参数\n- `__set_page_guard()`：为指定页面设置守护页标志和相关属性\n- `__clear_page_guard()`：清除页面的守护页标志和相关属性\n\n### 宏定义\n- `debug_guardpage_minorder()`：获取当前守护页最小阶数值（内联函数）\n\n## 3. 关键实现\n\n### 启动参数处理\n- **`debug_pagealloc` 参数**：通过 `early_param()` 在内核早期初始化阶段解析布尔值参数，控制 `_debug_pagealloc_enabled_early` 的初始状态\n- **`debug_guardpage_minorder` 参数**：解析无符号长整型参数，验证其有效性（0 ≤ value ≤ MAX_PAGE_ORDER/2），设置 `_debug_guardpage_minorder` 全局变量\n\n### 守护页管理\n- **设置守护页 (`__set_page_guard`)**：\n  - 仅当请求的分配阶数小于 `_debug_guardpage_minorder` 时才启用守护页\n  - 设置 `PG_guard` 页面标志位\n  - 初始化 buddy_list 为空链表（防止误用）\n  - 将分配阶数存储在 page->private 字段中\n- **清除守护页 (`__clear_page_guard`)**：\n  - 清除 `PG_guard` 标志位\n  - 将 page->private 重置为 0\n\n### 静态键优化\n- 使用 `DEFINE_STATIC_KEY_FALSE` 定义运行时开关，避免调试代码路径的性能开销\n- 通过 `EXPORT_SYMBOL` 导出符号供其他内核模块使用\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/mm.h>`：提供核心内存管理数据结构和函数声明\n- `<linux/page-isolation.h>`：提供页面隔离相关功能（如 `__SetPageGuard` 等宏定义）\n\n### 内核配置依赖\n- `CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT`：控制默认是否启用页分配调试功能\n- `MAX_PAGE_ORDER`：定义最大分配阶数常量，用于参数验证\n\n### 符号导出\n- `_debug_pagealloc_enabled_early` 和 `_debug_pagealloc_enabled` 被导出，供内存管理子系统（如伙伴系统）查询调试状态\n\n## 5. 使用场景\n\n### 内存错误检测\n- 在开发和调试阶段启用 `debug_pagealloc=1`，可检测内存越界写入、使用已释放内存等问题\n- 守护页机制特别适用于捕获大内存块分配时的缓冲区溢出错误\n\n### 性能敏感环境\n- 默认情况下调试功能关闭，避免运行时性能开销\n- 通过静态键机制确保禁用时调试代码路径完全不执行\n\n### 内核启动配置\n- 系统管理员可通过内核命令行参数动态调整调试行为：\n  - `debug_pagealloc=1` 启用页分配调试\n  - `debug_guardpage_minorder=N` 设置守护页触发的最小分配阶数\n\n### 内存管理子系统集成\n- 伙伴系统（buddy allocator）在页面分配/释放时调用 `__set_page_guard()` 和 `__clear_page_guard()` 管理守护页状态\n- 页面迁移、内存热插拔等子系统依赖此模块提供的页面状态管理功能",
      "similarity": 0.5499892234802246,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/debug_page_alloc.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/mm.h>",
            "#include <linux/page-isolation.h>",
            "",
            "unsigned int _debug_guardpage_minorder;",
            "",
            "bool _debug_pagealloc_enabled_early __read_mostly",
            "\t\t\t= IS_ENABLED(CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT);",
            "EXPORT_SYMBOL(_debug_pagealloc_enabled_early);",
            "DEFINE_STATIC_KEY_FALSE(_debug_pagealloc_enabled);",
            "EXPORT_SYMBOL(_debug_pagealloc_enabled);",
            "",
            "DEFINE_STATIC_KEY_FALSE(_debug_guardpage_enabled);",
            ""
          ],
          "function_name": null,
          "description": "定义调试页面分配相关全局变量及符号导出，用于控制早期调试功能启用状态和静态键，支持动态开关调试页保护机制",
          "similarity": 0.46988189220428467
        },
        {
          "chunk_id": 1,
          "file_path": "mm/debug_page_alloc.c",
          "start_line": 15,
          "end_line": 46,
          "content": [
            "static int __init early_debug_pagealloc(char *buf)",
            "{",
            "\treturn kstrtobool(buf, &_debug_pagealloc_enabled_early);",
            "}",
            "static int __init debug_guardpage_minorder_setup(char *buf)",
            "{",
            "\tunsigned long res;",
            "",
            "\tif (kstrtoul(buf, 10, &res) < 0 ||  res > MAX_PAGE_ORDER / 2) {",
            "\t\tpr_err(\"Bad debug_guardpage_minorder value\\n\");",
            "\t\treturn 0;",
            "\t}",
            "\t_debug_guardpage_minorder = res;",
            "\tpr_info(\"Setting debug_guardpage_minorder to %lu\\n\", res);",
            "\treturn 0;",
            "}",
            "bool __set_page_guard(struct zone *zone, struct page *page, unsigned int order)",
            "{",
            "\tif (order >= debug_guardpage_minorder())",
            "\t\treturn false;",
            "",
            "\t__SetPageGuard(page);",
            "\tINIT_LIST_HEAD(&page->buddy_list);",
            "\tset_page_private(page, order);",
            "",
            "\treturn true;",
            "}",
            "void __clear_page_guard(struct zone *zone, struct page *page, unsigned int order)",
            "{",
            "\t__ClearPageGuard(page);",
            "\tset_page_private(page, 0);",
            "}"
          ],
          "function_name": "early_debug_pagealloc, debug_guardpage_minorder_setup, __set_page_guard, __clear_page_guard",
          "description": "实现早期调试参数解析、最小订单值设置及页保护状态管理逻辑，通过订单阈值控制是否对页面添加守护标志并修改页面私有数据",
          "similarity": 0.4521247446537018
        }
      ]
    },
    {
      "source_file": "mm/page_owner.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:04:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_owner.c`\n\n---\n\n# page_owner.c 技术文档\n\n## 1. 文件概述\n\n`page_owner.c` 是 Linux 内核中用于追踪物理内存页分配与释放信息的调试模块。它通过记录每个页面（或页块）的分配者、释放者、分配时间、调用栈、GFP 标志、进程上下文等元数据，帮助开发者诊断内存泄漏、非法释放、重复释放等内存管理问题。该功能可通过内核启动参数 `page_owner=on` 启用，并通过 debugfs 接口（如 `/sys/kernel/debug/page_owner`）导出详细信息。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct page_owner`**：存储单个页面（或页块）的归属信息\n  - `order`：分配时的页阶数（2^order 个连续页）\n  - `last_migrate_reason`：最后一次迁移的原因（-1 表示未迁移）\n  - `gfp_mask`：分配时使用的 GFP 标志\n  - `handle` / `free_handle`：分配/释放时的调用栈句柄（由 stackdepot 管理）\n  - `ts_nsec` / `free_ts_nsec`：分配/释放的时间戳（纳秒级）\n  - `comm` / `pid` / `tgid`：分配进程的名称、PID 和线程组 ID\n  - `free_pid` / `free_tgid`：释放进程的 PID 和线程组 ID\n\n### 主要函数\n\n- **`__set_page_owner()`**：在页面分配时记录归属信息\n- **`__reset_page_owner()`**：在页面释放时记录释放信息\n- **`__set_page_owner_migrate_reason()`**：记录页面迁移原因\n- **`__split_page_owner()`**：在页面分裂时更新页阶信息\n- **`__folio_copy_owner()`**：在 folio 迁移时复制归属信息\n- **`pagetypeinfo_showmixedcount_print()`**：统计并打印混合迁移类型的页块信息（未完整实现）\n\n### 全局变量与初始化\n\n- `page_owner_enabled`：是否启用 page owner 功能（由启动参数控制）\n- `page_owner_inited`：静态跳转键，标识 page owner 是否已初始化\n- `dummy_handle` / `failure_handle` / `early_handle`：特殊调用栈句柄，用于避免递归或处理异常情况\n- `page_owner_ops`：`page_ext` 框架的操作集，用于注册 page owner 扩展\n\n## 3. 关键实现\n\n### 调用栈捕获与去重\n\n- 使用 `stack_trace_save()` 捕获深度为 `PAGE_OWNER_STACK_DEPTH`（16 层）的调用栈\n- 通过 `stack_depot_save()` 将调用栈存入全局去重仓库（stack depot），返回紧凑句柄\n- 为避免在分配 page owner 元数据时触发递归（如 stack depot 自身需要分配内存），使用 `current->in_page_owner` 标志临时禁用追踪，并返回 `dummy_handle`\n\n### 页面扩展（page_ext）集成\n\n- 利用内核的 `page_ext` 机制为每个 struct page 附加 `struct page_owner` 元数据\n- 通过 `page_ext_get()` / `page_ext_put()` 安全访问扩展数据\n- 在 `init_page_owner()` 中注册 `page_owner_ops`，使 page_ext 框架在初始化时为所有页面预留空间\n\n### 特殊句柄处理\n\n- **`dummy_handle`**：用于递归保护场景\n- **`failure_handle`**：当 `stack_depot_save()` 失败时的备用句柄\n- **`early_handle`**：用于早期分配页面（如 memblock 阶段）的归属标记\n\n### 内存操作一致性\n\n- 在页面分配（`__set_page_owner`）、释放（`__reset_page_owner`）、迁移（`__folio_copy_owner`）和分裂（`__split_page_owner`）等关键路径上同步更新元数据\n- 使用 `PAGE_EXT_OWNER_ALLOCATED` 位标记页面当前是否处于已分配状态\n- 时间戳使用 `local_clock()` 获取高精度单调时钟\n\n## 4. 依赖关系\n\n- **`<linux/page_ext.h>`**：提供页面扩展框架，用于附加元数据\n- **`<linux/stackdepot.h>`**：提供调用栈去重存储服务\n- **`<linux/stacktrace.h>`**：提供调用栈捕获接口\n- **`<linux/debugfs.h>`**：用于创建 debugfs 接口（虽未在代码片段中体现，但通常配套实现）\n- **`mm/internal.h`**：包含内部内存管理辅助函数\n- **`<linux/memcontrol.h>`**、**`<linux/migrate.h>`**：支持内存控制组和页面迁移场景\n\n## 5. 使用场景\n\n- **内存泄漏检测**：通过分析未释放页面的分配栈和进程上下文定位泄漏源\n- **Use-after-free 调试**：检查已释放页面的释放者信息，判断非法访问来源\n- **内存碎片分析**：结合迁移类型和分配模式，识别导致碎片化的分配行为\n- **性能调优**：通过分配/释放时间戳分析内存分配延迟\n- **内核开发与测试**：在启用 `CONFIG_PAGE_OWNER` 配置选项后，作为内存子系统的重要调试工具\n\n> 注：该功能会显著增加内存开销（每个页面约 64 字节元数据）和运行时开销，仅建议在调试环境中启用。",
      "similarity": 0.5375720858573914,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "mm/page_owner.c",
          "start_line": 514,
          "end_line": 624,
          "content": [
            "static ssize_t",
            "read_page_owner(struct file *file, char __user *buf, size_t count, loff_t *ppos)",
            "{",
            "\tunsigned long pfn;",
            "\tstruct page *page;",
            "\tstruct page_ext *page_ext;",
            "\tstruct page_owner *page_owner;",
            "\tdepot_stack_handle_t handle;",
            "",
            "\tif (!static_branch_unlikely(&page_owner_inited))",
            "\t\treturn -EINVAL;",
            "",
            "\tpage = NULL;",
            "\tif (*ppos == 0)",
            "\t\tpfn = min_low_pfn;",
            "\telse",
            "\t\tpfn = *ppos;",
            "\t/* Find a valid PFN or the start of a MAX_ORDER_NR_PAGES area */",
            "\twhile (!pfn_valid(pfn) && (pfn & (MAX_ORDER_NR_PAGES - 1)) != 0)",
            "\t\tpfn++;",
            "",
            "\t/* Find an allocated page */",
            "\tfor (; pfn < max_pfn; pfn++) {",
            "\t\t/*",
            "\t\t * This temporary page_owner is required so",
            "\t\t * that we can avoid the context switches while holding",
            "\t\t * the rcu lock and copying the page owner information to",
            "\t\t * user through copy_to_user() or GFP_KERNEL allocations.",
            "\t\t */",
            "\t\tstruct page_owner page_owner_tmp;",
            "",
            "\t\t/*",
            "\t\t * If the new page is in a new MAX_ORDER_NR_PAGES area,",
            "\t\t * validate the area as existing, skip it if not",
            "\t\t */",
            "\t\tif ((pfn & (MAX_ORDER_NR_PAGES - 1)) == 0 && !pfn_valid(pfn)) {",
            "\t\t\tpfn += MAX_ORDER_NR_PAGES - 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tpage = pfn_to_page(pfn);",
            "\t\tif (PageBuddy(page)) {",
            "\t\t\tunsigned long freepage_order = buddy_order_unsafe(page);",
            "",
            "\t\t\tif (freepage_order <= MAX_PAGE_ORDER)",
            "\t\t\t\tpfn += (1UL << freepage_order) - 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tpage_ext = page_ext_get(page);",
            "\t\tif (unlikely(!page_ext))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Some pages could be missed by concurrent allocation or free,",
            "\t\t * because we don't hold the zone lock.",
            "\t\t */",
            "\t\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags))",
            "\t\t\tgoto ext_put_continue;",
            "",
            "\t\t/*",
            "\t\t * Although we do have the info about past allocation of free",
            "\t\t * pages, it's not relevant for current memory usage.",
            "\t\t */",
            "\t\tif (!test_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags))",
            "\t\t\tgoto ext_put_continue;",
            "",
            "\t\tpage_owner = get_page_owner(page_ext);",
            "",
            "\t\t/*",
            "\t\t * Don't print \"tail\" pages of high-order allocations as that",
            "\t\t * would inflate the stats.",
            "\t\t */",
            "\t\tif (!IS_ALIGNED(pfn, 1 << page_owner->order))",
            "\t\t\tgoto ext_put_continue;",
            "",
            "\t\t/*",
            "\t\t * Access to page_ext->handle isn't synchronous so we should",
            "\t\t * be careful to access it.",
            "\t\t */",
            "\t\thandle = READ_ONCE(page_owner->handle);",
            "\t\tif (!handle)",
            "\t\t\tgoto ext_put_continue;",
            "",
            "\t\t/* Record the next PFN to read in the file offset */",
            "\t\t*ppos = pfn + 1;",
            "",
            "\t\tpage_owner_tmp = *page_owner;",
            "\t\tpage_ext_put(page_ext);",
            "\t\treturn print_page_owner(buf, count, pfn, page,",
            "\t\t\t\t&page_owner_tmp, handle);",
            "ext_put_continue:",
            "\t\tpage_ext_put(page_ext);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static loff_t lseek_page_owner(struct file *file, loff_t offset, int orig)",
            "{",
            "\tswitch (orig) {",
            "\tcase SEEK_SET:",
            "\t\tfile->f_pos = offset;",
            "\t\tbreak;",
            "\tcase SEEK_CUR:",
            "\t\tfile->f_pos += offset;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn file->f_pos;",
            "}"
          ],
          "function_name": "read_page_owner, lseek_page_owner",
          "description": "提供基于文件操作的页面所有者信息遍历接口，通过PFN扫描实现按序读取页面分配记录，支持文件指针偏移量管理和数据同步访问。",
          "similarity": 0.5464315414428711
        },
        {
          "chunk_id": 5,
          "file_path": "mm/page_owner.c",
          "start_line": 627,
          "end_line": 725,
          "content": [
            "static void init_pages_in_zone(pg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tunsigned long pfn = zone->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(zone);",
            "\tunsigned long count = 0;",
            "",
            "\t/*",
            "\t * Walk the zone in pageblock_nr_pages steps. If a page block spans",
            "\t * a zone boundary, it will be double counted between zones. This does",
            "\t * not matter as the mixed block count will still be correct",
            "\t */",
            "\tfor (; pfn < end_pfn; ) {",
            "\t\tunsigned long block_end_pfn;",
            "",
            "\t\tif (!pfn_valid(pfn)) {",
            "\t\t\tpfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tblock_end_pfn = pageblock_end_pfn(pfn);",
            "\t\tblock_end_pfn = min(block_end_pfn, end_pfn);",
            "",
            "\t\tfor (; pfn < block_end_pfn; pfn++) {",
            "\t\t\tstruct page *page = pfn_to_page(pfn);",
            "\t\t\tstruct page_ext *page_ext;",
            "",
            "\t\t\tif (page_zone(page) != zone)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\t/*",
            "\t\t\t * To avoid having to grab zone->lock, be a little",
            "\t\t\t * careful when reading buddy page order. The only",
            "\t\t\t * danger is that we skip too much and potentially miss",
            "\t\t\t * some early allocated pages, which is better than",
            "\t\t\t * heavy lock contention.",
            "\t\t\t */",
            "\t\t\tif (PageBuddy(page)) {",
            "\t\t\t\tunsigned long order = buddy_order_unsafe(page);",
            "",
            "\t\t\t\tif (order > 0 && order <= MAX_PAGE_ORDER)",
            "\t\t\t\t\tpfn += (1UL << order) - 1;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tif (PageReserved(page))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tpage_ext = page_ext_get(page);",
            "\t\t\tif (unlikely(!page_ext))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\t/* Maybe overlapping zone */",
            "\t\t\tif (test_bit(PAGE_EXT_OWNER, &page_ext->flags))",
            "\t\t\t\tgoto ext_put_continue;",
            "",
            "\t\t\t/* Found early allocated page */",
            "\t\t\t__set_page_owner_handle(page_ext, early_handle,",
            "\t\t\t\t\t\t0, 0);",
            "\t\t\tcount++;",
            "ext_put_continue:",
            "\t\t\tpage_ext_put(page_ext);",
            "\t\t}",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\tpr_info(\"Node %d, zone %8s: page owner found early allocated %lu pages\\n\",",
            "\t\tpgdat->node_id, zone->name, count);",
            "}",
            "static void init_zones_in_node(pg_data_t *pgdat)",
            "{",
            "\tstruct zone *zone;",
            "\tstruct zone *node_zones = pgdat->node_zones;",
            "",
            "\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {",
            "\t\tif (!populated_zone(zone))",
            "\t\t\tcontinue;",
            "",
            "\t\tinit_pages_in_zone(pgdat, zone);",
            "\t}",
            "}",
            "static void init_early_allocated_pages(void)",
            "{",
            "\tpg_data_t *pgdat;",
            "",
            "\tfor_each_online_pgdat(pgdat)",
            "\t\tinit_zones_in_node(pgdat);",
            "}",
            "static int __init pageowner_init(void)",
            "{",
            "\tif (!static_branch_unlikely(&page_owner_inited)) {",
            "\t\tpr_info(\"page_owner is disabled\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tdebugfs_create_file(\"page_owner\", 0400, NULL, NULL,",
            "\t\t\t    &proc_page_owner_operations);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "init_pages_in_zone, init_zones_in_node, init_early_allocated_pages, pageowner_init",
          "description": "该代码块实现了页面所有者跟踪机制的初始化，主要功能是扫描内存区域以识别并标记早期分配的页面。`init_pages_in_zone`遍历指定zone内的物理页帧，跳过无效/特殊状态页面后，为早期分配的页面设置所有者标识；`init_zones_in_node`和`init_early_allocated_pages`则协调遍历全节点内存区域。由于`pageowner_init`仅注册调试接口而未显式初始化核心数据结构，上下文存在不完整性。",
          "similarity": 0.5429502129554749
        },
        {
          "chunk_id": 0,
          "file_path": "mm/page_owner.c",
          "start_line": 1,
          "end_line": 47,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memblock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/migrate.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/sched/clock.h>",
            "",
            "#include \"internal.h\"",
            "",
            "/*",
            " * TODO: teach PAGE_OWNER_STACK_DEPTH (__dump_page_owner and save_stack)",
            " * to use off stack temporal storage",
            " */",
            "#define PAGE_OWNER_STACK_DEPTH (16)",
            "",
            "struct page_owner {",
            "\tunsigned short order;",
            "\tshort last_migrate_reason;",
            "\tgfp_t gfp_mask;",
            "\tdepot_stack_handle_t handle;",
            "\tdepot_stack_handle_t free_handle;",
            "\tu64 ts_nsec;",
            "\tu64 free_ts_nsec;",
            "\tchar comm[TASK_COMM_LEN];",
            "\tpid_t pid;",
            "\tpid_t tgid;",
            "\tpid_t free_pid;",
            "\tpid_t free_tgid;",
            "};",
            "",
            "static bool page_owner_enabled __initdata;",
            "DEFINE_STATIC_KEY_FALSE(page_owner_inited);",
            "",
            "static depot_stack_handle_t dummy_handle;",
            "static depot_stack_handle_t failure_handle;",
            "static depot_stack_handle_t early_handle;",
            "",
            "static void init_early_allocated_pages(void);",
            ""
          ],
          "function_name": null,
          "description": "定义page_owner结构体及辅助变量，用于跟踪页面分配信息，包含订单、时间戳、进程ID、堆栈句柄等字段，为核心数据结构和初始化参数。",
          "similarity": 0.5382168292999268
        },
        {
          "chunk_id": 2,
          "file_path": "mm/page_owner.c",
          "start_line": 189,
          "end_line": 357,
          "content": [
            "noinline void __set_page_owner(struct page *page, unsigned short order,",
            "\t\t\t\t\tgfp_t gfp_mask)",
            "{",
            "\tstruct page_ext *page_ext;",
            "\tdepot_stack_handle_t handle;",
            "",
            "\thandle = save_stack(gfp_mask);",
            "",
            "\tpage_ext = page_ext_get(page);",
            "\tif (unlikely(!page_ext))",
            "\t\treturn;",
            "\t__set_page_owner_handle(page_ext, handle, order, gfp_mask);",
            "\tpage_ext_put(page_ext);",
            "}",
            "void __set_page_owner_migrate_reason(struct page *page, int reason)",
            "{",
            "\tstruct page_ext *page_ext = page_ext_get(page);",
            "\tstruct page_owner *page_owner;",
            "",
            "\tif (unlikely(!page_ext))",
            "\t\treturn;",
            "",
            "\tpage_owner = get_page_owner(page_ext);",
            "\tpage_owner->last_migrate_reason = reason;",
            "\tpage_ext_put(page_ext);",
            "}",
            "void __split_page_owner(struct page *page, int old_order, int new_order)",
            "{",
            "\tint i;",
            "\tstruct page_ext *page_ext = page_ext_get(page);",
            "\tstruct page_owner *page_owner;",
            "",
            "\tif (unlikely(!page_ext))",
            "\t\treturn;",
            "",
            "\tfor (i = 0; i < (1 << old_order); i++) {",
            "\t\tpage_owner = get_page_owner(page_ext);",
            "\t\tpage_owner->order = new_order;",
            "\t\tpage_ext = page_ext_next(page_ext);",
            "\t}",
            "\tpage_ext_put(page_ext);",
            "}",
            "void __folio_copy_owner(struct folio *newfolio, struct folio *old)",
            "{",
            "\tstruct page_ext *old_ext;",
            "\tstruct page_ext *new_ext;",
            "\tstruct page_owner *old_page_owner, *new_page_owner;",
            "",
            "\told_ext = page_ext_get(&old->page);",
            "\tif (unlikely(!old_ext))",
            "\t\treturn;",
            "",
            "\tnew_ext = page_ext_get(&newfolio->page);",
            "\tif (unlikely(!new_ext)) {",
            "\t\tpage_ext_put(old_ext);",
            "\t\treturn;",
            "\t}",
            "",
            "\told_page_owner = get_page_owner(old_ext);",
            "\tnew_page_owner = get_page_owner(new_ext);",
            "\tnew_page_owner->order = old_page_owner->order;",
            "\tnew_page_owner->gfp_mask = old_page_owner->gfp_mask;",
            "\tnew_page_owner->last_migrate_reason =",
            "\t\told_page_owner->last_migrate_reason;",
            "\tnew_page_owner->handle = old_page_owner->handle;",
            "\tnew_page_owner->pid = old_page_owner->pid;",
            "\tnew_page_owner->tgid = old_page_owner->tgid;",
            "\tnew_page_owner->free_pid = old_page_owner->free_pid;",
            "\tnew_page_owner->free_tgid = old_page_owner->free_tgid;",
            "\tnew_page_owner->ts_nsec = old_page_owner->ts_nsec;",
            "\tnew_page_owner->free_ts_nsec = old_page_owner->ts_nsec;",
            "\tstrcpy(new_page_owner->comm, old_page_owner->comm);",
            "",
            "\t/*",
            "\t * We don't clear the bit on the old folio as it's going to be freed",
            "\t * after migration. Until then, the info can be useful in case of",
            "\t * a bug, and the overall stats will be off a bit only temporarily.",
            "\t * Also, migrate_misplaced_transhuge_page() can still fail the",
            "\t * migration and then we want the old folio to retain the info. But",
            "\t * in that case we also don't need to explicitly clear the info from",
            "\t * the new page, which will be freed.",
            "\t */",
            "\t__set_bit(PAGE_EXT_OWNER, &new_ext->flags);",
            "\t__set_bit(PAGE_EXT_OWNER_ALLOCATED, &new_ext->flags);",
            "\tpage_ext_put(new_ext);",
            "\tpage_ext_put(old_ext);",
            "}",
            "void pagetypeinfo_showmixedcount_print(struct seq_file *m,",
            "\t\t\t\t       pg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tstruct page *page;",
            "\tstruct page_ext *page_ext;",
            "\tstruct page_owner *page_owner;",
            "\tunsigned long pfn, block_end_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(zone);",
            "\tunsigned long count[MIGRATE_TYPES] = { 0, };",
            "\tint pageblock_mt, page_mt;",
            "\tint i;",
            "",
            "\t/* Scan block by block. First and last block may be incomplete */",
            "\tpfn = zone->zone_start_pfn;",
            "",
            "\t/*",
            "\t * Walk the zone in pageblock_nr_pages steps. If a page block spans",
            "\t * a zone boundary, it will be double counted between zones. This does",
            "\t * not matter as the mixed block count will still be correct",
            "\t */",
            "\tfor (; pfn < end_pfn; ) {",
            "\t\tpage = pfn_to_online_page(pfn);",
            "\t\tif (!page) {",
            "\t\t\tpfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tblock_end_pfn = pageblock_end_pfn(pfn);",
            "\t\tblock_end_pfn = min(block_end_pfn, end_pfn);",
            "",
            "\t\tpageblock_mt = get_pageblock_migratetype(page);",
            "",
            "\t\tfor (; pfn < block_end_pfn; pfn++) {",
            "\t\t\t/* The pageblock is online, no need to recheck. */",
            "\t\t\tpage = pfn_to_page(pfn);",
            "",
            "\t\t\tif (page_zone(page) != zone)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (PageBuddy(page)) {",
            "\t\t\t\tunsigned long freepage_order;",
            "",
            "\t\t\t\tfreepage_order = buddy_order_unsafe(page);",
            "\t\t\t\tif (freepage_order <= MAX_PAGE_ORDER)",
            "\t\t\t\t\tpfn += (1UL << freepage_order) - 1;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tif (PageReserved(page))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tpage_ext = page_ext_get(page);",
            "\t\t\tif (unlikely(!page_ext))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (!test_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags))",
            "\t\t\t\tgoto ext_put_continue;",
            "",
            "\t\t\tpage_owner = get_page_owner(page_ext);",
            "\t\t\tpage_mt = gfp_migratetype(page_owner->gfp_mask);",
            "\t\t\tif (pageblock_mt != page_mt) {",
            "\t\t\t\tif (is_migrate_cma(pageblock_mt))",
            "\t\t\t\t\tcount[MIGRATE_MOVABLE]++;",
            "\t\t\t\telse",
            "\t\t\t\t\tcount[pageblock_mt]++;",
            "",
            "\t\t\t\tpfn = block_end_pfn;",
            "\t\t\t\tpage_ext_put(page_ext);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tpfn += (1UL << page_owner->order) - 1;",
            "ext_put_continue:",
            "\t\t\tpage_ext_put(page_ext);",
            "\t\t}",
            "\t}",
            "",
            "\t/* Print counts */",
            "\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);",
            "\tfor (i = 0; i < MIGRATE_TYPES; i++)",
            "\t\tseq_printf(m, \"%12lu \", count[i]);",
            "\tseq_putc(m, '\\n');",
            "}"
          ],
          "function_name": "__set_page_owner, __set_page_owner_migrate_reason, __split_page_owner, __folio_copy_owner, pagetypeinfo_showmixedcount_print",
          "description": "提供页面所有者信息的设置、分裂、复制及混合统计打印功能，通过遍历页面扩展结构体维护分配/释放状态和迁移类型信息。",
          "similarity": 0.5113717317581177
        },
        {
          "chunk_id": 1,
          "file_path": "mm/page_owner.c",
          "start_line": 48,
          "end_line": 157,
          "content": [
            "static int __init early_page_owner_param(char *buf)",
            "{",
            "\tint ret = kstrtobool(buf, &page_owner_enabled);",
            "",
            "\tif (page_owner_enabled)",
            "\t\tstack_depot_request_early_init();",
            "",
            "\treturn ret;",
            "}",
            "static __init bool need_page_owner(void)",
            "{",
            "\treturn page_owner_enabled;",
            "}",
            "static noinline void register_dummy_stack(void)",
            "{",
            "\tdummy_handle = create_dummy_stack();",
            "}",
            "static noinline void register_failure_stack(void)",
            "{",
            "\tfailure_handle = create_dummy_stack();",
            "}",
            "static noinline void register_early_stack(void)",
            "{",
            "\tearly_handle = create_dummy_stack();",
            "}",
            "static __init void init_page_owner(void)",
            "{",
            "\tif (!page_owner_enabled)",
            "\t\treturn;",
            "",
            "\tregister_dummy_stack();",
            "\tregister_failure_stack();",
            "\tregister_early_stack();",
            "\tstatic_branch_enable(&page_owner_inited);",
            "\tinit_early_allocated_pages();",
            "}",
            "static noinline depot_stack_handle_t save_stack(gfp_t flags)",
            "{",
            "\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];",
            "\tdepot_stack_handle_t handle;",
            "\tunsigned int nr_entries;",
            "",
            "\t/*",
            "\t * Avoid recursion.",
            "\t *",
            "\t * Sometimes page metadata allocation tracking requires more",
            "\t * memory to be allocated:",
            "\t * - when new stack trace is saved to stack depot",
            "\t */",
            "\tif (current->in_page_owner)",
            "\t\treturn dummy_handle;",
            "\tcurrent->in_page_owner = 1;",
            "",
            "\tnr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 2);",
            "\thandle = stack_depot_save(entries, nr_entries, flags);",
            "\tif (!handle)",
            "\t\thandle = failure_handle;",
            "",
            "\tcurrent->in_page_owner = 0;",
            "\treturn handle;",
            "}",
            "void __reset_page_owner(struct page *page, unsigned short order)",
            "{",
            "\tint i;",
            "\tstruct page_ext *page_ext;",
            "\tdepot_stack_handle_t handle;",
            "\tstruct page_owner *page_owner;",
            "\tu64 free_ts_nsec = local_clock();",
            "",
            "\tpage_ext = page_ext_get(page);",
            "\tif (unlikely(!page_ext))",
            "\t\treturn;",
            "",
            "\thandle = save_stack(GFP_NOWAIT | __GFP_NOWARN);",
            "\tfor (i = 0; i < (1 << order); i++) {",
            "\t\t__clear_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags);",
            "\t\tpage_owner = get_page_owner(page_ext);",
            "\t\tpage_owner->free_handle = handle;",
            "\t\tpage_owner->free_ts_nsec = free_ts_nsec;",
            "\t\tpage_owner->free_pid = current->pid;",
            "\t\tpage_owner->free_tgid = current->tgid;",
            "\t\tpage_ext = page_ext_next(page_ext);",
            "\t}",
            "\tpage_ext_put(page_ext);",
            "}",
            "static inline void __set_page_owner_handle(struct page_ext *page_ext,",
            "\t\t\t\t\tdepot_stack_handle_t handle,",
            "\t\t\t\t\tunsigned short order, gfp_t gfp_mask)",
            "{",
            "\tstruct page_owner *page_owner;",
            "\tint i;",
            "\tu64 ts_nsec = local_clock();",
            "",
            "\tfor (i = 0; i < (1 << order); i++) {",
            "\t\tpage_owner = get_page_owner(page_ext);",
            "\t\tpage_owner->handle = handle;",
            "\t\tpage_owner->order = order;",
            "\t\tpage_owner->gfp_mask = gfp_mask;",
            "\t\tpage_owner->last_migrate_reason = -1;",
            "\t\tpage_owner->pid = current->pid;",
            "\t\tpage_owner->tgid = current->tgid;",
            "\t\tpage_owner->ts_nsec = ts_nsec;",
            "\t\tstrscpy(page_owner->comm, current->comm,",
            "\t\t\tsizeof(page_owner->comm));",
            "\t\t__set_bit(PAGE_EXT_OWNER, &page_ext->flags);",
            "\t\t__set_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags);",
            "",
            "\t\tpage_ext = page_ext_next(page_ext);",
            "\t}",
            "}"
          ],
          "function_name": "early_page_owner_param, need_page_owner, register_dummy_stack, register_failure_stack, register_early_stack, init_page_owner, save_stack, __reset_page_owner, __set_page_owner_handle",
          "description": "实现页面所有者跟踪模块的初始化逻辑，包含堆栈句柄注册、堆栈保存、页面释放标记更新等功能，支持递归保护和堆栈深度限制。",
          "similarity": 0.5035408735275269
        }
      ]
    }
  ]
}