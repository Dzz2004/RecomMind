{
  "query": "Linux内核进程调度算法实现原理",
  "timestamp": "2025-12-25 23:24:01",
  "retrieved_files": [
    {
      "source_file": "kernel/fork.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:30:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fork.c`\n\n---\n\n# fork.c 技术文档\n\n## 1. 文件概述\n\n`fork.c` 是 Linux 内核中实现进程创建（fork）系统调用的核心源文件。该文件包含了创建新进程所需的所有辅助例程，负责复制父进程的资源（如内存、文件描述符、信号处理等）以生成子进程。虽然 fork 逻辑本身概念简单，但其涉及的内存管理（尤其是写时复制 COW 机制）极为复杂，实际内存页的复制由 `mm/memory.c` 中的 `copy_page_range()` 等函数处理。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `total_forks`: 累计系统自启动以来创建的进程总数\n- `nr_threads`: 当前系统中的线程总数（不包括 idle 线程）\n- `max_threads`: 可配置的线程数量上限（默认为 `FUTEX_TID_MASK`）\n- `process_counts`: 每 CPU 的进程计数器（per-CPU 变量）\n- `tasklist_lock`: 保护任务链表的读写锁（全局任务列表的同步原语）\n\n### 关键辅助函数\n- `nr_processes()`: 计算系统中所有进程的总数（聚合各 CPU 的 `process_counts`）\n- `arch_release_task_struct()`: 架构相关的 task_struct 释放钩子（弱符号，默认为空）\n- `alloc_task_struct_node()` / `free_task_struct()`: 分配/释放 `task_struct` 结构（基于 slab 分配器）\n- `alloc_thread_stack_node()` / `thread_stack_delayed_free()`: 分配/延迟释放线程内核栈（支持 `CONFIG_VMAP_STACK`）\n\n### 核心数据结构\n- `resident_page_types[]`: 用于内存统计的页面类型名称映射数组\n- `vm_stack`: 用于 RCU 延迟释放的虚拟内存栈封装结构\n- `cached_stacks[NR_CACHED_STACKS]`: 每 CPU 的内核栈缓存（减少频繁 vmalloc/vfree 开销）\n\n## 3. 关键实现\n\n### 进程/线程计数管理\n- 使用 per-CPU 变量 `process_counts` 避免全局锁竞争\n- 全局计数器 `nr_threads` 和 `total_forks` 由 `tasklist_lock` 保护\n- `nr_processes()` 通过遍历所有可能的 CPU 聚合计数\n\n### 内核栈分配策略（`CONFIG_VMAP_STACK`）\n- **缓存机制**：每个 CPU 缓存最多 2 个已释放的栈（`NR_CACHED_STACKS`），减少 TLB 刷新和 vmalloc 开销\n- **内存分配**：\n  - 优先从本地缓存获取栈\n  - 缓存未命中时使用 `__vmalloc_node_range()` 分配连续虚拟地址空间\n  - 显式禁用 `__GFP_ACCOUNT`（因后续手动进行 memcg 计费）\n- **安全清理**：\n  - 重用栈时清零内存（`memset(stack, 0, THREAD_SIZE)`）\n  - KASAN 消毒（`kasan_unpoison_range`）和标签重置\n- **延迟释放**：\n  - 通过 RCU 机制延迟释放栈（`call_rcu`）\n  - 释放时尝试回填缓存，失败则直接 `vfree`\n\n### 内存控制组（memcg）集成\n- 手动对栈的每个物理页进行 memcg 计费（`memcg_kmem_charge_page`）\n- 计费失败时回滚已计费页面（`memcg_kmem_uncharge_page`）\n- 确保内核栈内存纳入 cgroup 内存限制\n\n### 锁与同步\n- `tasklist_lock` 作为全局任务列表的保护锁（读写锁）\n- 提供 `lockdep_tasklist_lock_is_held()` 供 RCU 锁验证使用\n- RCU 用于安全延迟释放内核栈资源\n\n## 4. 依赖关系\n\n### 内核子系统依赖\n- **内存管理 (MM)**：`<linux/mm.h>`, `<linux/vmalloc.h>`, `<linux/memcontrol.h>`\n- **调度器 (Scheduler)**：`<linux/sched/*.h>`, 任务状态和 CPU 绑定\n- **安全模块**：`<linux/security.h>`, `<linux/capability.h>`, `<linux/seccomp.h>`\n- **命名空间**：`<linux/nsproxy.h>`（UTS, IPC, PID, 网络等）\n- **文件系统**：`<linux/fs.h>`, `<linux/fdtable.h>`（文件描述符复制）\n- **跟踪与调试**：`<trace/events/sched.h>`, `<linux/ftrace.h>`, KASAN/KMSAN\n\n### 架构相关依赖\n- `<asm/pgalloc.h>`：页表分配\n- `<asm/mmu_context.h>`：MMU 上下文切换\n- `<asm/tlbflush.h>`：TLB 刷新操作\n- 架构特定的 `THREAD_SIZE` 和栈对齐要求\n\n### 配置选项依赖\n- `CONFIG_VMAP_STACK`：启用虚拟内存分配内核栈\n- `CONFIG_PROVE_RCU`：RCU 锁验证支持\n- `CONFIG_ARCH_TASK_STRUCT_ALLOCATOR`：架构自定义 task_struct 分配器\n- `CONFIG_MEMCG_KMEM`：内核内存 cgroup 支持\n\n## 5. 使用场景\n\n### 进程创建路径\n- **系统调用入口**：`sys_fork()`, `sys_vfork()`, `sys_clone()` 最终调用 `_do_fork()`\n- **内核线程创建**：`kthread_create()` 通过 `kernel_thread()` 触发 fork 逻辑\n- **容器/命名空间初始化**：新 PID/UTS/IPC 命名空间创建时伴随进程 fork\n\n### 资源复制关键点\n- **内存描述符 (mm_struct)**：通过 `dup_mm()` 复制地址空间（COW 页表）\n- **文件描述符表**：`dup_fd()` 复制打开文件表\n- **信号处理**：复制信号掩码和处理函数\n- **POSIX 定时器/异步 I/O**：复制相关上下文（如 `aio`, `posix-timers`）\n\n### 特殊场景处理\n- **写时复制优化**：避免物理内存立即复制，提升 fork 性能\n- **OOM Killer 集成**：在内存不足时参与进程选择\n- **审计与监控**：通过 `audit_alloc()` 和 `proc` 文件系统暴露进程信息\n- **实时性保障**：RT 任务 fork 时保持调度策略和优先级",
      "similarity": 0.6540318131446838,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/fork.c",
          "start_line": 159,
          "end_line": 303,
          "content": [
            "int lockdep_tasklist_lock_is_held(void)",
            "{",
            "\treturn lockdep_is_held(&tasklist_lock);",
            "}",
            "int nr_processes(void)",
            "{",
            "\tint cpu;",
            "\tint total = 0;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\ttotal += per_cpu(process_counts, cpu);",
            "",
            "\treturn total;",
            "}",
            "void __weak arch_release_task_struct(struct task_struct *tsk)",
            "{",
            "}",
            "static inline void free_task_struct(struct task_struct *tsk)",
            "{",
            "\tkmem_cache_free(task_struct_cachep, tsk);",
            "}",
            "static bool try_release_thread_stack_to_cache(struct vm_struct *vm)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < NR_CACHED_STACKS; i++) {",
            "\t\tif (this_cpu_cmpxchg(cached_stacks[i], NULL, vm) != NULL)",
            "\t\t\tcontinue;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static void thread_stack_free_rcu(struct rcu_head *rh)",
            "{",
            "\tstruct vm_stack *vm_stack = container_of(rh, struct vm_stack, rcu);",
            "",
            "\tif (try_release_thread_stack_to_cache(vm_stack->stack_vm_area))",
            "\t\treturn;",
            "",
            "\tvfree(vm_stack);",
            "}",
            "static void thread_stack_delayed_free(struct task_struct *tsk)",
            "{",
            "\tstruct vm_stack *vm_stack = tsk->stack;",
            "",
            "\tvm_stack->stack_vm_area = tsk->stack_vm_area;",
            "\tcall_rcu(&vm_stack->rcu, thread_stack_free_rcu);",
            "}",
            "static int free_vm_stack_cache(unsigned int cpu)",
            "{",
            "\tstruct vm_struct **cached_vm_stacks = per_cpu_ptr(cached_stacks, cpu);",
            "\tint i;",
            "",
            "\tfor (i = 0; i < NR_CACHED_STACKS; i++) {",
            "\t\tstruct vm_struct *vm_stack = cached_vm_stacks[i];",
            "",
            "\t\tif (!vm_stack)",
            "\t\t\tcontinue;",
            "",
            "\t\tvfree(vm_stack->addr);",
            "\t\tcached_vm_stacks[i] = NULL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int memcg_charge_kernel_stack(struct vm_struct *vm)",
            "{",
            "\tint i;",
            "\tint ret;",
            "\tint nr_charged = 0;",
            "",
            "\tBUG_ON(vm->nr_pages != THREAD_SIZE / PAGE_SIZE);",
            "",
            "\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++) {",
            "\t\tret = memcg_kmem_charge_page(vm->pages[i], GFP_KERNEL, 0);",
            "\t\tif (ret)",
            "\t\t\tgoto err;",
            "\t\tnr_charged++;",
            "\t}",
            "\treturn 0;",
            "err:",
            "\tfor (i = 0; i < nr_charged; i++)",
            "\t\tmemcg_kmem_uncharge_page(vm->pages[i], 0);",
            "\treturn ret;",
            "}",
            "static int alloc_thread_stack_node(struct task_struct *tsk, int node)",
            "{",
            "\tstruct vm_struct *vm;",
            "\tvoid *stack;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < NR_CACHED_STACKS; i++) {",
            "\t\tstruct vm_struct *s;",
            "",
            "\t\ts = this_cpu_xchg(cached_stacks[i], NULL);",
            "",
            "\t\tif (!s)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Reset stack metadata. */",
            "\t\tkasan_unpoison_range(s->addr, THREAD_SIZE);",
            "",
            "\t\tstack = kasan_reset_tag(s->addr);",
            "",
            "\t\t/* Clear stale pointers from reused stack. */",
            "\t\tmemset(stack, 0, THREAD_SIZE);",
            "",
            "\t\tif (memcg_charge_kernel_stack(s)) {",
            "\t\t\tvfree(s->addr);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "",
            "\t\ttsk->stack_vm_area = s;",
            "\t\ttsk->stack = stack;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * Allocated stacks are cached and later reused by new threads,",
            "\t * so memcg accounting is performed manually on assigning/releasing",
            "\t * stacks to tasks. Drop __GFP_ACCOUNT.",
            "\t */",
            "\tstack = __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,",
            "\t\t\t\t     VMALLOC_START, VMALLOC_END,",
            "\t\t\t\t     THREADINFO_GFP & ~__GFP_ACCOUNT,",
            "\t\t\t\t     PAGE_KERNEL,",
            "\t\t\t\t     0, node, __builtin_return_address(0));",
            "\tif (!stack)",
            "\t\treturn -ENOMEM;",
            "",
            "\tvm = find_vm_area(stack);",
            "\tif (memcg_charge_kernel_stack(vm)) {",
            "\t\tvfree(stack);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\t/*",
            "\t * We can't call find_vm_area() in interrupt context, and",
            "\t * free_thread_stack() can be called in interrupt context,",
            "\t * so cache the vm_struct.",
            "\t */",
            "\ttsk->stack_vm_area = vm;",
            "\tstack = kasan_reset_tag(stack);",
            "\ttsk->stack = stack;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "lockdep_tasklist_lock_is_held, nr_processes, arch_release_task_struct, free_task_struct, try_release_thread_stack_to_cache, thread_stack_free_rcu, thread_stack_delayed_free, free_vm_stack_cache, memcg_charge_kernel_stack, alloc_thread_stack_node",
          "description": "实现任务列表锁状态检测、进程总数统计及线程栈分配释放逻辑，通过缓存机制优化线程栈复用并利用RCU实现延迟释放，包含栈内存管理和内存会计功能。",
          "similarity": 0.5761525630950928
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/fork.c",
          "start_line": 666,
          "end_line": 845,
          "content": [
            "static __latent_entropy int dup_mmap(struct mm_struct *mm,",
            "\t\t\t\t\tstruct mm_struct *oldmm)",
            "{",
            "\tstruct vm_area_struct *mpnt, *tmp;",
            "\tint retval;",
            "\tunsigned long charge = 0;",
            "\tLIST_HEAD(uf);",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\tuprobe_start_dup_mmap();",
            "\tif (mmap_write_lock_killable(oldmm)) {",
            "\t\tretval = -EINTR;",
            "\t\tgoto fail_uprobe_end;",
            "\t}",
            "\tflush_cache_dup_mm(oldmm);",
            "\tuprobe_dup_mmap(oldmm, mm);",
            "\t/*",
            "\t * Not linked in yet - no deadlock potential:",
            "\t */",
            "\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);",
            "",
            "\t/* No ordering required: file already has been exposed. */",
            "\tdup_mm_exe_file(mm, oldmm);",
            "",
            "\tmm->total_vm = oldmm->total_vm;",
            "\tmm->data_vm = oldmm->data_vm;",
            "\tmm->exec_vm = oldmm->exec_vm;",
            "\tmm->stack_vm = oldmm->stack_vm;",
            "",
            "\t/* Use __mt_dup() to efficiently build an identical maple tree. */",
            "\tretval = __mt_dup(&oldmm->mm_mt, &mm->mm_mt, GFP_KERNEL);",
            "\tif (unlikely(retval))",
            "\t\tgoto out;",
            "",
            "\tmt_clear_in_rcu(vmi.mas.tree);",
            "\tfor_each_vma(vmi, mpnt) {",
            "\t\tstruct file *file;",
            "",
            "\t\tvma_start_write(mpnt);",
            "\t\tif (mpnt->vm_flags & VM_DONTCOPY) {",
            "\t\t\tretval = vma_iter_clear_gfp(&vmi, mpnt->vm_start,",
            "\t\t\t\t\t\t    mpnt->vm_end, GFP_KERNEL);",
            "\t\t\tif (retval)",
            "\t\t\t\tgoto loop_out;",
            "",
            "\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tcharge = 0;",
            "\t\t/*",
            "\t\t * Don't duplicate many vmas if we've been oom-killed (for",
            "\t\t * example)",
            "\t\t */",
            "\t\tif (fatal_signal_pending(current)) {",
            "\t\t\tretval = -EINTR;",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t\tif (mpnt->vm_flags & VM_ACCOUNT) {",
            "\t\t\tunsigned long len = vma_pages(mpnt);",
            "",
            "\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */",
            "\t\t\t\tgoto fail_nomem;",
            "\t\t\tcharge = len;",
            "\t\t}",
            "\t\ttmp = vm_area_dup(mpnt);",
            "\t\tif (!tmp)",
            "\t\t\tgoto fail_nomem;",
            "",
            "\t\t/* track_pfn_copy() will later take care of copying internal state. */",
            "\t\tif (unlikely(tmp->vm_flags & VM_PFNMAP))",
            "\t\t\tuntrack_pfn_clear(tmp);",
            "",
            "\t\tretval = vma_dup_policy(mpnt, tmp);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_policy;",
            "\t\ttmp->vm_mm = mm;",
            "\t\tretval = dup_userfaultfd(tmp, &uf);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tif (tmp->vm_flags & VM_WIPEONFORK) {",
            "\t\t\t/*",
            "\t\t\t * VM_WIPEONFORK gets a clean slate in the child.",
            "\t\t\t * Don't prepare anon_vma until fault since we don't",
            "\t\t\t * copy page for current vma.",
            "\t\t\t */",
            "\t\t\ttmp->anon_vma = NULL;",
            "\t\t} else if (anon_vma_fork(tmp, mpnt))",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tvm_flags_clear(tmp, VM_LOCKED_MASK);",
            "\t\tfile = tmp->vm_file;",
            "\t\tif (file) {",
            "\t\t\tstruct address_space *mapping = file->f_mapping;",
            "",
            "\t\t\tget_file(file);",
            "\t\t\ti_mmap_lock_write(mapping);",
            "\t\t\tif (vma_is_shared_maywrite(tmp))",
            "\t\t\t\tmapping_allow_writable(mapping);",
            "\t\t\tflush_dcache_mmap_lock(mapping);",
            "\t\t\t/* insert tmp into the share list, just after mpnt */",
            "\t\t\tvma_interval_tree_insert_after(tmp, mpnt,",
            "\t\t\t\t\t&mapping->i_mmap);",
            "\t\t\tflush_dcache_mmap_unlock(mapping);",
            "\t\t\ti_mmap_unlock_write(mapping);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Copy/update hugetlb private vma information.",
            "\t\t */",
            "\t\tif (is_vm_hugetlb_page(tmp))",
            "\t\t\thugetlb_dup_vma_private(tmp);",
            "",
            "\t\t/*",
            "\t\t * Link the vma into the MT. After using __mt_dup(), memory",
            "\t\t * allocation is not necessary here, so it cannot fail.",
            "\t\t */",
            "\t\tvma_iter_bulk_store(&vmi, tmp);",
            "",
            "\t\tmm->map_count++;",
            "\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))",
            "\t\t\tretval = copy_page_range(tmp, mpnt);",
            "",
            "\t\tif (tmp->vm_ops && tmp->vm_ops->open)",
            "\t\t\ttmp->vm_ops->open(tmp);",
            "",
            "\t\tif (retval) {",
            "\t\t\tmpnt = vma_next(&vmi);",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t}",
            "\t/* a new mm has just been created */",
            "\tretval = arch_dup_mmap(oldmm, mm);",
            "loop_out:",
            "\tvma_iter_free(&vmi);",
            "\tif (!retval) {",
            "\t\tmt_set_in_rcu(vmi.mas.tree);",
            "\t\tksm_fork(mm, oldmm);",
            "\t\tkhugepaged_fork(mm, oldmm);",
            "\t} else {",
            "",
            "\t\t/*",
            "\t\t * The entire maple tree has already been duplicated. If the",
            "\t\t * mmap duplication fails, mark the failure point with",
            "\t\t * XA_ZERO_ENTRY. In exit_mmap(), if this marker is encountered,",
            "\t\t * stop releasing VMAs that have not been duplicated after this",
            "\t\t * point.",
            "\t\t */",
            "\t\tif (mpnt) {",
            "\t\t\tmas_set_range(&vmi.mas, mpnt->vm_start, mpnt->vm_end - 1);",
            "\t\t\tmas_store(&vmi.mas, XA_ZERO_ENTRY);",
            "\t\t\t/* Avoid OOM iterating a broken tree */",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t}",
            "\t\t/*",
            "\t\t * The mm_struct is going to exit, but the locks will be dropped",
            "\t\t * first.  Set the mm_struct as unstable is advisable as it is",
            "\t\t * not fully initialised.",
            "\t\t */",
            "\t\tset_bit(MMF_UNSTABLE, &mm->flags);",
            "\t}",
            "out:",
            "\tmmap_write_unlock(mm);",
            "\tflush_tlb_mm(oldmm);",
            "\tmmap_write_unlock(oldmm);",
            "\tif (!retval)",
            "\t\tdup_userfaultfd_complete(&uf);",
            "\telse",
            "\t\tdup_userfaultfd_fail(&uf);",
            "fail_uprobe_end:",
            "\tuprobe_end_dup_mmap();",
            "\treturn retval;",
            "",
            "fail_nomem_anon_vma_fork:",
            "\tmpol_put(vma_policy(tmp));",
            "fail_nomem_policy:",
            "\tvm_area_free(tmp);",
            "fail_nomem:",
            "\tretval = -ENOMEM;",
            "\tvm_unacct_memory(charge);",
            "\tgoto loop_out;",
            "}"
          ],
          "function_name": "dup_mmap",
          "description": "实现进程fork时的内存映射复制逻辑，深度遍历原进程的VMA结构创建副本，处理共享文件映射、hugetlb页等特殊内存类型，并管理OOM异常情况下的失败恢复。",
          "similarity": 0.5696186423301697
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/fork.c",
          "start_line": 2176,
          "end_line": 2282,
          "content": [
            "static void rv_task_fork(struct task_struct *p)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++)",
            "\t\tp->rv[i].da_mon.monitoring = false;",
            "}",
            "static inline void init_idle_pids(struct task_struct *idle)",
            "{",
            "\tenum pid_type type;",
            "",
            "\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {",
            "\t\tINIT_HLIST_NODE(&idle->pid_links[type]); /* not really needed */",
            "\t\tinit_task_pid(idle, type, &init_struct_pid);",
            "\t}",
            "}",
            "static int idle_dummy(void *dummy)",
            "{",
            "\t/* This function is never called */",
            "\treturn 0;",
            "}",
            "pid_t kernel_clone(struct kernel_clone_args *args)",
            "{",
            "\tu64 clone_flags = args->flags;",
            "\tstruct completion vfork;",
            "\tstruct pid *pid;",
            "\tstruct task_struct *p;",
            "\tint trace = 0;",
            "\tpid_t nr;",
            "",
            "\t/*",
            "\t * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument",
            "\t * to return the pidfd. Hence, CLONE_PIDFD and CLONE_PARENT_SETTID are",
            "\t * mutually exclusive. With clone3() CLONE_PIDFD has grown a separate",
            "\t * field in struct clone_args and it still doesn't make sense to have",
            "\t * them both point at the same memory location. Performing this check",
            "\t * here has the advantage that we don't need to have a separate helper",
            "\t * to check for legacy clone().",
            "\t */",
            "\tif ((args->flags & CLONE_PIDFD) &&",
            "\t    (args->flags & CLONE_PARENT_SETTID) &&",
            "\t    (args->pidfd == args->parent_tid))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Determine whether and which event to report to ptracer.  When",
            "\t * called from kernel_thread or CLONE_UNTRACED is explicitly",
            "\t * requested, no event is reported; otherwise, report if the event",
            "\t * for the type of forking is enabled.",
            "\t */",
            "\tif (!(clone_flags & CLONE_UNTRACED)) {",
            "\t\tif (clone_flags & CLONE_VFORK)",
            "\t\t\ttrace = PTRACE_EVENT_VFORK;",
            "\t\telse if (args->exit_signal != SIGCHLD)",
            "\t\t\ttrace = PTRACE_EVENT_CLONE;",
            "\t\telse",
            "\t\t\ttrace = PTRACE_EVENT_FORK;",
            "",
            "\t\tif (likely(!ptrace_event_enabled(current, trace)))",
            "\t\t\ttrace = 0;",
            "\t}",
            "",
            "\tp = copy_process(NULL, trace, NUMA_NO_NODE, args);",
            "\tadd_latent_entropy();",
            "",
            "\tif (IS_ERR(p))",
            "\t\treturn PTR_ERR(p);",
            "",
            "\t/*",
            "\t * Do this prior waking up the new thread - the thread pointer",
            "\t * might get invalid after that point, if the thread exits quickly.",
            "\t */",
            "\ttrace_sched_process_fork(current, p);",
            "",
            "\tpid = get_task_pid(p, PIDTYPE_PID);",
            "\tnr = pid_vnr(pid);",
            "",
            "\tif (clone_flags & CLONE_PARENT_SETTID)",
            "\t\tput_user(nr, args->parent_tid);",
            "",
            "\tif (clone_flags & CLONE_VFORK) {",
            "\t\tp->vfork_done = &vfork;",
            "\t\tinit_completion(&vfork);",
            "\t\tget_task_struct(p);",
            "\t}",
            "",
            "\tif (IS_ENABLED(CONFIG_LRU_GEN_WALKS_MMU) && !(clone_flags & CLONE_VM)) {",
            "\t\t/* lock the task to synchronize with memcg migration */",
            "\t\ttask_lock(p);",
            "\t\tlru_gen_add_mm(p->mm);",
            "\t\ttask_unlock(p);",
            "\t}",
            "",
            "\twake_up_new_task(p);",
            "",
            "\t/* forking complete and child started to run, tell ptracer */",
            "\tif (unlikely(trace))",
            "\t\tptrace_event_pid(trace, pid);",
            "",
            "\tif (clone_flags & CLONE_VFORK) {",
            "\t\tif (!wait_for_vfork_done(p, &vfork))",
            "\t\t\tptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);",
            "\t}",
            "",
            "\tput_pid(pid);",
            "\treturn nr;",
            "}"
          ],
          "function_name": "rv_task_fork, init_idle_pids, idle_dummy, kernel_clone",
          "description": "实现kernel_clone核心逻辑，创建新进程并处理克隆标志，管理子进程启动、vfork等待及进程树遍历，包含空闲任务PID初始化与RV监控器重置",
          "similarity": 0.5569165349006653
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/fork.c",
          "start_line": 350,
          "end_line": 450,
          "content": [
            "static void free_thread_stack(struct task_struct *tsk)",
            "{",
            "\tif (!try_release_thread_stack_to_cache(tsk->stack_vm_area))",
            "\t\tthread_stack_delayed_free(tsk);",
            "",
            "\ttsk->stack = NULL;",
            "\ttsk->stack_vm_area = NULL;",
            "}",
            "static void thread_stack_free_rcu(struct rcu_head *rh)",
            "{",
            "\t__free_pages(virt_to_page(rh), THREAD_SIZE_ORDER);",
            "}",
            "static void thread_stack_delayed_free(struct task_struct *tsk)",
            "{",
            "\tstruct rcu_head *rh = tsk->stack;",
            "",
            "\tcall_rcu(rh, thread_stack_free_rcu);",
            "}",
            "static int alloc_thread_stack_node(struct task_struct *tsk, int node)",
            "{",
            "\tstruct page *page = alloc_pages_node(node, THREADINFO_GFP,",
            "\t\t\t\t\t     THREAD_SIZE_ORDER);",
            "",
            "\tif (likely(page)) {",
            "\t\ttsk->stack = kasan_reset_tag(page_address(page));",
            "\t\treturn 0;",
            "\t}",
            "\treturn -ENOMEM;",
            "}",
            "static void free_thread_stack(struct task_struct *tsk)",
            "{",
            "\tthread_stack_delayed_free(tsk);",
            "\ttsk->stack = NULL;",
            "}",
            "static void thread_stack_free_rcu(struct rcu_head *rh)",
            "{",
            "\tkmem_cache_free(thread_stack_cache, rh);",
            "}",
            "static void thread_stack_delayed_free(struct task_struct *tsk)",
            "{",
            "\tstruct rcu_head *rh = tsk->stack;",
            "",
            "\tcall_rcu(rh, thread_stack_free_rcu);",
            "}",
            "static int alloc_thread_stack_node(struct task_struct *tsk, int node)",
            "{",
            "\tunsigned long *stack;",
            "\tstack = kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);",
            "\tstack = kasan_reset_tag(stack);",
            "\ttsk->stack = stack;",
            "\treturn stack ? 0 : -ENOMEM;",
            "}",
            "static void free_thread_stack(struct task_struct *tsk)",
            "{",
            "\tthread_stack_delayed_free(tsk);",
            "\ttsk->stack = NULL;",
            "}",
            "void thread_stack_cache_init(void)",
            "{",
            "\tthread_stack_cache = kmem_cache_create_usercopy(\"thread_stack\",",
            "\t\t\t\t\tTHREAD_SIZE, THREAD_SIZE, 0, 0,",
            "\t\t\t\t\tTHREAD_SIZE, NULL);",
            "\tBUG_ON(thread_stack_cache == NULL);",
            "}",
            "static int alloc_thread_stack_node(struct task_struct *tsk, int node)",
            "{",
            "\tunsigned long *stack;",
            "",
            "\tstack = arch_alloc_thread_stack_node(tsk, node);",
            "\ttsk->stack = stack;",
            "\treturn stack ? 0 : -ENOMEM;",
            "}",
            "static void free_thread_stack(struct task_struct *tsk)",
            "{",
            "\tarch_free_thread_stack(tsk);",
            "\ttsk->stack = NULL;",
            "}",
            "static bool vma_lock_alloc(struct vm_area_struct *vma)",
            "{",
            "\tvma->vm_lock = kmem_cache_alloc(vma_lock_cachep, GFP_KERNEL);",
            "\tif (!vma->vm_lock)",
            "\t\treturn false;",
            "",
            "\tinit_rwsem(&vma->vm_lock->lock);",
            "\tvma->vm_lock_seq = -1;",
            "",
            "\treturn true;",
            "}",
            "static inline void vma_lock_free(struct vm_area_struct *vma)",
            "{",
            "\tkmem_cache_free(vma_lock_cachep, vma->vm_lock);",
            "}",
            "static inline bool vma_lock_alloc(struct vm_area_struct *vma) { return true; }",
            "static inline void vma_lock_free(struct vm_area_struct *vma) {}",
            "void __vm_area_free(struct vm_area_struct *vma)",
            "{",
            "\tvma_numab_state_free(vma);",
            "\tfree_anon_vma_name(vma);",
            "\tvma_lock_free(vma);",
            "\tkmem_cache_free(vm_area_cachep, vma);",
            "}"
          ],
          "function_name": "free_thread_stack, thread_stack_free_rcu, thread_stack_delayed_free, alloc_thread_stack_node, free_thread_stack, thread_stack_free_rcu, thread_stack_delayed_free, alloc_thread_stack_node, free_thread_stack, thread_stack_cache_init, alloc_thread_stack_node, free_thread_stack, vma_lock_alloc, vma_lock_free, vma_lock_alloc, vma_lock_free, __vm_area_free",
          "description": "上下文不完整：存在重复函数定义和不一致的实现方式，显示线程栈分配/释放流程中使用了多种不同的内存管理策略，包括基于页面的分配、SLAB缓存及架构特定实现。",
          "similarity": 0.5258951187133789
        },
        {
          "chunk_id": 16,
          "file_path": "kernel/fork.c",
          "start_line": 3480,
          "end_line": 3518,
          "content": [
            "int unshare_files(void)",
            "{",
            "\tstruct task_struct *task = current;",
            "\tstruct files_struct *old, *copy = NULL;",
            "\tint error;",
            "",
            "\terror = unshare_fd(CLONE_FILES, &copy);",
            "\tif (error || !copy)",
            "\t\treturn error;",
            "",
            "\told = task->files;",
            "\ttask_lock(task);",
            "\ttask->files = copy;",
            "\ttask_unlock(task);",
            "\tput_files_struct(old);",
            "\treturn 0;",
            "}",
            "int sysctl_max_threads(struct ctl_table *table, int write,",
            "\t\t       void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct ctl_table t;",
            "\tint ret;",
            "\tint threads = max_threads;",
            "\tint min = 1;",
            "\tint max = MAX_THREADS;",
            "",
            "\tt = *table;",
            "\tt.data = &threads;",
            "\tt.extra1 = &min;",
            "\tt.extra2 = &max;",
            "",
            "\tret = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);",
            "\tif (ret || !write)",
            "\t\treturn ret;",
            "",
            "\tmax_threads = threads;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "unshare_files, sysctl_max_threads",
          "description": "unshare_files函数复制当前进程的文件表结构并将其绑定到当前任务，sysctl_max_threads函数通过proc_dointvec_minmax接口限制系统最大线程数，支持读取和写入操作，其中写入时会更新全局max_threads变量。",
          "similarity": 0.5249258279800415
        }
      ]
    },
    {
      "source_file": "kernel/workqueue.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:53:20\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `workqueue.c`\n\n---\n\n# workqueue.c 技术文档\n\n## 1. 文件概述\n\n`workqueue.c` 是 Linux 内核中实现通用异步执行机制的核心文件，提供基于共享工作线程池（worker pool）的延迟任务调度功能。工作项（work items）在进程上下文中执行，支持 CPU 绑定和非绑定两种模式。每个 CPU 默认拥有两个标准工作池（普通优先级和高优先级），同时支持动态创建非绑定工作池以满足不同工作队列的需求。该机制替代了早期的 taskqueue/keventd 实现，具有更高的可扩展性和资源利用率。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct worker_pool`**  \n  工作线程池结构体，管理一组工作线程（workers），包含：\n  - `lock`：保护池状态的自旋锁\n  - `cpu` / `node`：关联的 CPU 和 NUMA 节点（绑定池）\n  - `worklist`：待处理工作项队列\n  - `idle_list` / `busy_hash`：空闲和忙碌工作线程的管理结构\n  - `nr_workers` / `nr_idle`：工作线程数量统计\n  - `attrs`：工作线程属性（如优先级、CPU 亲和性）\n  - `mayday_timer`：紧急情况下的救援请求定时器\n\n- **`struct pool_workqueue`**  \n  工作队列与工作池之间的关联结构，每个工作队列在每个池中都有一个对应的 `pool_workqueue` 实例，用于：\n  - 管理工作项的入队和执行\n  - 实现 `max_active` 限制（控制并发执行数）\n  - 支持 flush 操作（等待所有工作完成）\n  - 统计性能指标（如启动/完成次数、CPU 时间等）\n\n- **`struct worker`**（定义在 `workqueue_internal.h`）  \n  工作线程的运行时上下文，包含状态标志（如 `WORKER_IDLE`, `WORKER_UNBOUND`）、当前执行的工作项等。\n\n### 关键枚举与常量\n\n- **池/工作线程标志**：\n  - `POOL_DISASSOCIATED`：CPU 离线时池进入非绑定状态\n  - `WORKER_UNBOUND`：工作线程可在任意 CPU 上运行\n  - `WORKER_CPU_INTENSIVE`：标记 CPU 密集型任务，影响并发控制\n\n- **配置参数**：\n  - `NR_STD_WORKER_POOLS = 2`：每 CPU 标准池数量（普通 + 高优先级）\n  - `IDLE_WORKER_TIMEOUT = 300 * HZ`：空闲线程保留时间（5 分钟）\n  - `MAYDAY_INITIAL_TIMEOUT`：工作积压时触发救援的延迟（10ms）\n\n- **统计指标**（`pool_workqueue_stats`）：\n  - `PWQ_STAT_STARTED` / `PWQ_STAT_COMPLETED`：工作项执行统计\n  - `PWQ_STAT_MAYDAY` / `PWQ_STAT_RESCUED`：紧急救援事件计数\n\n## 3. 关键实现\n\n### 工作池管理\n- **绑定池（Bound Pool）**：与特定 CPU 关联，工作线程默认绑定到该 CPU。当 CPU 离线时，池进入 `DISASSOCIATED` 状态，工作线程转为非绑定模式。\n- **非绑定池（Unbound Pool）**：动态创建，通过哈希表（`unbound_pool_hash`）按属性（`workqueue_attrs`）去重，支持跨 CPU 调度。\n- **并发控制**：通过 `nr_running` 计数器和 `max_active` 限制，防止工作项过度并发执行。\n\n### 工作线程生命周期\n- **空闲管理**：空闲线程加入 `idle_list`，超时（`IDLE_WORKER_TIMEOUT`）后被回收。\n- **动态伸缩**：当工作积压时，通过 `mayday_timer` 触发新线程创建；若创建失败，向全局救援线程（rescuer）求助。\n- **状态标志**：使用位标志（如 `WORKER_IDLE`, `WORKER_PREP`）高效管理线程状态，避免锁竞争。\n\n### 内存与同步\n- **RCU 保护**：工作池销毁通过 RCU 延迟释放，确保 `get_work_pool()` 等读取路径无锁安全。\n- **锁分层**：\n  - `pool->lock`（自旋锁）：保护池内部状态\n  - `wq_pool_mutex`：全局池管理互斥锁\n  - `wq_pool_attach_mutex`：防止 CPU 绑定状态变更冲突\n\n### 工作项调度\n- **数据指针复用**：`work_struct->data` 的高有效位存储 `pool_workqueue` 指针，低有效位用于标志位（如 `WORK_STRUCT_INACTIVE`）。\n- **优先级支持**：高优先级工作池使用 `HIGHPRI_NICE_LEVEL = MIN_NICE` 提升调度优先级。\n\n## 4. 依赖关系\n\n- **内核子系统**：\n  - **调度器**（`<linux/sched.h>`）：创建工作线程（kworker），管理 CPU 亲和性\n  - **内存管理**（`<linux/slab.h>`）：分配工作池、工作队列等结构\n  - **CPU 热插拔**（`<linux/cpu.h>`）：处理 CPU 上下线时的池绑定状态切换\n  - **RCU**（`<linux/rculist.h>`）：实现无锁读取路径\n  - **定时器**（`<linux/timer.h>`）：实现空闲超时和救援机制\n\n- **内部依赖**：\n  - `workqueue_internal.h`：定义 `struct worker` 等内部结构\n  - `Documentation/core-api/workqueue.rst`：详细设计文档\n\n## 5. 使用场景\n\n- **驱动程序延迟操作**：硬件中断后调度下半部处理（如网络包处理、磁盘 I/O 完成回调）。\n- **内核子系统异步任务**：文件系统元数据更新、内存回收、电源管理状态切换。\n- **高优先级任务**：使用 `WQ_HIGHPRI` 标志创建工作队列，确保关键任务及时执行（如死锁恢复）。\n- **CPU 密集型任务**：标记 `WQ_CPU_INTENSIVE` 避免占用过多并发槽位，提升系统响应性。\n- **NUMA 感知调度**：非绑定工作队列可指定 NUMA 节点，优化内存访问延迟。",
      "similarity": 0.6496108174324036,
      "chunks": [
        {
          "chunk_id": 33,
          "file_path": "kernel/workqueue.c",
          "start_line": 6492,
          "end_line": 6592,
          "content": [
            "static void panic_on_wq_watchdog(void)",
            "{",
            "\tstatic unsigned int wq_stall;",
            "",
            "\tif (wq_panic_on_stall) {",
            "\t\twq_stall++;",
            "\t\tBUG_ON(wq_stall >= wq_panic_on_stall);",
            "\t}",
            "}",
            "static void wq_watchdog_reset_touched(void)",
            "{",
            "\tint cpu;",
            "",
            "\twq_watchdog_touched = jiffies;",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;",
            "}",
            "static void wq_watchdog_timer_fn(struct timer_list *unused)",
            "{",
            "\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;",
            "\tbool lockup_detected = false;",
            "\tbool cpu_pool_stall = false;",
            "\tunsigned long now = jiffies;",
            "\tstruct worker_pool *pool;",
            "\tint pi;",
            "",
            "\tif (!thresh)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "",
            "\tfor_each_pool(pool, pi) {",
            "\t\tunsigned long pool_ts, touched, ts;",
            "",
            "\t\tpool->cpu_stall = false;",
            "\t\tif (list_empty(&pool->worklist))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * If a virtual machine is stopped by the host it can look to",
            "\t\t * the watchdog like a stall.",
            "\t\t */",
            "\t\tkvm_check_and_clear_guest_paused();",
            "",
            "\t\t/* get the latest of pool and touched timestamps */",
            "\t\tif (pool->cpu >= 0)",
            "\t\t\ttouched = READ_ONCE(per_cpu(wq_watchdog_touched_cpu, pool->cpu));",
            "\t\telse",
            "\t\t\ttouched = READ_ONCE(wq_watchdog_touched);",
            "\t\tpool_ts = READ_ONCE(pool->watchdog_ts);",
            "",
            "\t\tif (time_after(pool_ts, touched))",
            "\t\t\tts = pool_ts;",
            "\t\telse",
            "\t\t\tts = touched;",
            "",
            "\t\t/* did we stall? */",
            "\t\tif (time_after(now, ts + thresh)) {",
            "\t\t\tlockup_detected = true;",
            "\t\t\tif (pool->cpu >= 0) {",
            "\t\t\t\tpool->cpu_stall = true;",
            "\t\t\t\tcpu_pool_stall = true;",
            "\t\t\t}",
            "\t\t\tpr_emerg(\"BUG: workqueue lockup - pool\");",
            "\t\t\tpr_cont_pool_info(pool);",
            "\t\t\tpr_cont(\" stuck for %us!\\n\",",
            "\t\t\t\tjiffies_to_msecs(now - pool_ts) / 1000);",
            "\t\t}",
            "",
            "",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "",
            "\tif (lockup_detected)",
            "\t\tshow_all_workqueues();",
            "",
            "\tif (cpu_pool_stall)",
            "\t\tshow_cpu_pools_hogs();",
            "",
            "\tif (lockup_detected)",
            "\t\tpanic_on_wq_watchdog();",
            "",
            "\twq_watchdog_reset_touched();",
            "\tmod_timer(&wq_watchdog_timer, jiffies + thresh);",
            "}",
            "notrace void wq_watchdog_touch(int cpu)",
            "{",
            "\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;",
            "\tunsigned long touch_ts = READ_ONCE(wq_watchdog_touched);",
            "\tunsigned long now = jiffies;",
            "",
            "\tif (cpu >= 0)",
            "\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = now;",
            "\telse",
            "\t\tWARN_ONCE(1, \"%s should be called with valid CPU\", __func__);",
            "",
            "\t/* Don't unnecessarily store to global cacheline */",
            "\tif (time_after(now, touch_ts + thresh / 4))",
            "\t\tWRITE_ONCE(wq_watchdog_touched, jiffies);",
            "}"
          ],
          "function_name": "panic_on_wq_watchdog, wq_watchdog_reset_touched, wq_watchdog_timer_fn, wq_watchdog_touch",
          "description": "实现工作队列看门狗机制，通过定时器周期性检测任务阻塞状态，当检测到CPU池超时时触发警告日志和panic，包含超时阈值管理、时间戳更新及阻塞状态标识逻辑。",
          "similarity": 0.5859038829803467
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/workqueue.c",
          "start_line": 1832,
          "end_line": 1933,
          "content": [
            "bool queue_work_on(int cpu, struct workqueue_struct *wq,",
            "\t\t   struct work_struct *work)",
            "{",
            "\tbool ret = false;",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "",
            "\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {",
            "\t\t__queue_work(cpu, wq, work);",
            "\t\tret = true;",
            "\t}",
            "",
            "\tlocal_irq_restore(flags);",
            "\treturn ret;",
            "}",
            "static int select_numa_node_cpu(int node)",
            "{",
            "\tint cpu;",
            "",
            "\t/* Delay binding to CPU if node is not valid or online */",
            "\tif (node < 0 || node >= MAX_NUMNODES || !node_online(node))",
            "\t\treturn WORK_CPU_UNBOUND;",
            "",
            "\t/* Use local node/cpu if we are already there */",
            "\tcpu = raw_smp_processor_id();",
            "\tif (node == cpu_to_node(cpu))",
            "\t\treturn cpu;",
            "",
            "\t/* Use \"random\" otherwise know as \"first\" online CPU of node */",
            "\tcpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);",
            "",
            "\t/* If CPU is valid return that, otherwise just defer */",
            "\treturn cpu < nr_cpu_ids ? cpu : WORK_CPU_UNBOUND;",
            "}",
            "bool queue_work_node(int node, struct workqueue_struct *wq,",
            "\t\t     struct work_struct *work)",
            "{",
            "\tunsigned long flags;",
            "\tbool ret = false;",
            "",
            "\t/*",
            "\t * This current implementation is specific to unbound workqueues.",
            "\t * Specifically we only return the first available CPU for a given",
            "\t * node instead of cycling through individual CPUs within the node.",
            "\t *",
            "\t * If this is used with a per-cpu workqueue then the logic in",
            "\t * workqueue_select_cpu_near would need to be updated to allow for",
            "\t * some round robin type logic.",
            "\t */",
            "\tWARN_ON_ONCE(!(wq->flags & WQ_UNBOUND));",
            "",
            "\tlocal_irq_save(flags);",
            "",
            "\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {",
            "\t\tint cpu = select_numa_node_cpu(node);",
            "",
            "\t\t__queue_work(cpu, wq, work);",
            "\t\tret = true;",
            "\t}",
            "",
            "\tlocal_irq_restore(flags);",
            "\treturn ret;",
            "}",
            "void delayed_work_timer_fn(struct timer_list *t)",
            "{",
            "\tstruct delayed_work *dwork = from_timer(dwork, t, timer);",
            "",
            "\t/* should have been called from irqsafe timer with irq already off */",
            "\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);",
            "}",
            "static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,",
            "\t\t\t\tstruct delayed_work *dwork, unsigned long delay)",
            "{",
            "\tstruct timer_list *timer = &dwork->timer;",
            "\tstruct work_struct *work = &dwork->work;",
            "",
            "\tWARN_ON_ONCE(!wq);",
            "\tWARN_ON_ONCE(timer->function != delayed_work_timer_fn);",
            "\tWARN_ON_ONCE(timer_pending(timer));",
            "\tWARN_ON_ONCE(!list_empty(&work->entry));",
            "",
            "\t/*",
            "\t * If @delay is 0, queue @dwork->work immediately.  This is for",
            "\t * both optimization and correctness.  The earliest @timer can",
            "\t * expire is on the closest next tick and delayed_work users depend",
            "\t * on that there's no such delay when @delay is 0.",
            "\t */",
            "\tif (!delay) {",
            "\t\t__queue_work(cpu, wq, &dwork->work);",
            "\t\treturn;",
            "\t}",
            "",
            "\tdwork->wq = wq;",
            "\tdwork->cpu = cpu;",
            "\ttimer->expires = jiffies + delay;",
            "",
            "\tif (unlikely(cpu != WORK_CPU_UNBOUND))",
            "\t\tadd_timer_on(timer, cpu);",
            "\telse",
            "\t\tadd_timer(timer);",
            "}"
          ],
          "function_name": "queue_work_on, select_numa_node_cpu, queue_work_node, delayed_work_timer_fn, __queue_delayed_work",
          "description": "该代码块实现基于NUMA节点的延迟工作调度。queue_work_on指定CPU提交工作；select_numa_node_cpu选择节点对应的CPU；delayed_work_timer_fn作为延迟工作超时时的回调；__queue_delayed_work设置定时器并安排工作项执行。",
          "similarity": 0.5611757040023804
        },
        {
          "chunk_id": 29,
          "file_path": "kernel/workqueue.c",
          "start_line": 5864,
          "end_line": 5966,
          "content": [
            "int workqueue_unbound_exclude_cpumask(cpumask_var_t exclude_cpumask)",
            "{",
            "\tcpumask_var_t cpumask;",
            "\tint ret = 0;",
            "",
            "\tif (!zalloc_cpumask_var(&cpumask, GFP_KERNEL))",
            "\t\treturn -ENOMEM;",
            "",
            "\tlockdep_assert_cpus_held();",
            "\tmutex_lock(&wq_pool_mutex);",
            "",
            "\t/* Save the current isolated cpumask & export it via sysfs */",
            "\tcpumask_copy(wq_isolated_cpumask, exclude_cpumask);",
            "",
            "\t/*",
            "\t * If the operation fails, it will fall back to",
            "\t * wq_requested_unbound_cpumask which is initially set to",
            "\t * (HK_TYPE_WQ ∩ HK_TYPE_DOMAIN) house keeping mask and rewritten",
            "\t * by any subsequent write to workqueue/cpumask sysfs file.",
            "\t */",
            "\tif (!cpumask_andnot(cpumask, wq_requested_unbound_cpumask, exclude_cpumask))",
            "\t\tcpumask_copy(cpumask, wq_requested_unbound_cpumask);",
            "\tif (!cpumask_equal(cpumask, wq_unbound_cpumask))",
            "\t\tret = workqueue_apply_unbound_cpumask(cpumask);",
            "",
            "\tmutex_unlock(&wq_pool_mutex);",
            "\tfree_cpumask_var(cpumask);",
            "\treturn ret;",
            "}",
            "static int parse_affn_scope(const char *val)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(wq_affn_names); i++) {",
            "\t\tif (!strncasecmp(val, wq_affn_names[i], strlen(wq_affn_names[i])))",
            "\t\t\treturn i;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static int wq_affn_dfl_set(const char *val, const struct kernel_param *kp)",
            "{",
            "\tstruct workqueue_struct *wq;",
            "\tint affn, cpu;",
            "",
            "\taffn = parse_affn_scope(val);",
            "\tif (affn < 0)",
            "\t\treturn affn;",
            "\tif (affn == WQ_AFFN_DFL)",
            "\t\treturn -EINVAL;",
            "",
            "\tcpus_read_lock();",
            "\tmutex_lock(&wq_pool_mutex);",
            "",
            "\twq_affn_dfl = affn;",
            "",
            "\tlist_for_each_entry(wq, &workqueues, list) {",
            "\t\tfor_each_online_cpu(cpu) {",
            "\t\t\twq_update_pod(wq, cpu, cpu, true);",
            "\t\t}",
            "\t}",
            "",
            "\tmutex_unlock(&wq_pool_mutex);",
            "\tcpus_read_unlock();",
            "",
            "\treturn 0;",
            "}",
            "static int wq_affn_dfl_get(char *buffer, const struct kernel_param *kp)",
            "{",
            "\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", wq_affn_names[wq_affn_dfl]);",
            "}",
            "static ssize_t per_cpu_show(struct device *dev, struct device_attribute *attr,",
            "\t\t\t    char *buf)",
            "{",
            "\tstruct workqueue_struct *wq = dev_to_wq(dev);",
            "",
            "\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (bool)!(wq->flags & WQ_UNBOUND));",
            "}",
            "static ssize_t max_active_show(struct device *dev,",
            "\t\t\t       struct device_attribute *attr, char *buf)",
            "{",
            "\tstruct workqueue_struct *wq = dev_to_wq(dev);",
            "",
            "\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", wq->saved_max_active);",
            "}",
            "static ssize_t max_active_store(struct device *dev,",
            "\t\t\t\tstruct device_attribute *attr, const char *buf,",
            "\t\t\t\tsize_t count)",
            "{",
            "\tstruct workqueue_struct *wq = dev_to_wq(dev);",
            "\tint val;",
            "",
            "\tif (sscanf(buf, \"%d\", &val) != 1 || val <= 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tworkqueue_set_max_active(wq, val);",
            "\treturn count;",
            "}",
            "static void apply_wqattrs_lock(void)",
            "{",
            "\t/* CPUs should stay stable across pwq creations and installations */",
            "\tcpus_read_lock();",
            "\tmutex_lock(&wq_pool_mutex);",
            "}"
          ],
          "function_name": "workqueue_unbound_exclude_cpumask, parse_affn_scope, wq_affn_dfl_set, wq_affn_dfl_get, per_cpu_show, max_active_show, max_active_store, apply_wqattrs_lock",
          "description": "配置非绑定工作者的CPU排除掩码和默认亲和性策略，暴露工作队列属性供sysfs访问并管理最大并发数参数",
          "similarity": 0.5549370646476746
        },
        {
          "chunk_id": 28,
          "file_path": "kernel/workqueue.c",
          "start_line": 5717,
          "end_line": 5828,
          "content": [
            "void freeze_workqueues_begin(void)",
            "{",
            "\tstruct workqueue_struct *wq;",
            "\tstruct pool_workqueue *pwq;",
            "",
            "\tmutex_lock(&wq_pool_mutex);",
            "",
            "\tWARN_ON_ONCE(workqueue_freezing);",
            "\tworkqueue_freezing = true;",
            "",
            "\tlist_for_each_entry(wq, &workqueues, list) {",
            "\t\tmutex_lock(&wq->mutex);",
            "\t\tfor_each_pwq(pwq, wq)",
            "\t\t\tpwq_adjust_max_active(pwq);",
            "\t\tmutex_unlock(&wq->mutex);",
            "\t}",
            "",
            "\tmutex_unlock(&wq_pool_mutex);",
            "}",
            "bool freeze_workqueues_busy(void)",
            "{",
            "\tbool busy = false;",
            "\tstruct workqueue_struct *wq;",
            "\tstruct pool_workqueue *pwq;",
            "",
            "\tmutex_lock(&wq_pool_mutex);",
            "",
            "\tWARN_ON_ONCE(!workqueue_freezing);",
            "",
            "\tlist_for_each_entry(wq, &workqueues, list) {",
            "\t\tif (!(wq->flags & WQ_FREEZABLE))",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * nr_active is monotonically decreasing.  It's safe",
            "\t\t * to peek without lock.",
            "\t\t */",
            "\t\trcu_read_lock();",
            "\t\tfor_each_pwq(pwq, wq) {",
            "\t\t\tWARN_ON_ONCE(pwq->nr_active < 0);",
            "\t\t\tif (pwq->nr_active) {",
            "\t\t\t\tbusy = true;",
            "\t\t\t\trcu_read_unlock();",
            "\t\t\t\tgoto out_unlock;",
            "\t\t\t}",
            "\t\t}",
            "\t\trcu_read_unlock();",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&wq_pool_mutex);",
            "\treturn busy;",
            "}",
            "void thaw_workqueues(void)",
            "{",
            "\tstruct workqueue_struct *wq;",
            "\tstruct pool_workqueue *pwq;",
            "",
            "\tmutex_lock(&wq_pool_mutex);",
            "",
            "\tif (!workqueue_freezing)",
            "\t\tgoto out_unlock;",
            "",
            "\tworkqueue_freezing = false;",
            "",
            "\t/* restore max_active and repopulate worklist */",
            "\tlist_for_each_entry(wq, &workqueues, list) {",
            "\t\tmutex_lock(&wq->mutex);",
            "\t\tfor_each_pwq(pwq, wq)",
            "\t\t\tpwq_adjust_max_active(pwq);",
            "\t\tmutex_unlock(&wq->mutex);",
            "\t}",
            "",
            "out_unlock:",
            "\tmutex_unlock(&wq_pool_mutex);",
            "}",
            "static int workqueue_apply_unbound_cpumask(const cpumask_var_t unbound_cpumask)",
            "{",
            "\tLIST_HEAD(ctxs);",
            "\tint ret = 0;",
            "\tstruct workqueue_struct *wq;",
            "\tstruct apply_wqattrs_ctx *ctx, *n;",
            "",
            "\tlockdep_assert_held(&wq_pool_mutex);",
            "",
            "\tlist_for_each_entry(wq, &workqueues, list) {",
            "\t\tif (!(wq->flags & WQ_UNBOUND))",
            "\t\t\tcontinue;",
            "\t\t/* creating multiple pwqs breaks ordering guarantee */",
            "\t\tif (wq->flags & __WQ_ORDERED)",
            "\t\t\tcontinue;",
            "",
            "\t\tctx = apply_wqattrs_prepare(wq, wq->unbound_attrs, unbound_cpumask);",
            "\t\tif (IS_ERR(ctx)) {",
            "\t\t\tret = PTR_ERR(ctx);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tlist_add_tail(&ctx->list, &ctxs);",
            "\t}",
            "",
            "\tlist_for_each_entry_safe(ctx, n, &ctxs, list) {",
            "\t\tif (!ret)",
            "\t\t\tapply_wqattrs_commit(ctx);",
            "\t\tapply_wqattrs_cleanup(ctx);",
            "\t}",
            "",
            "\tif (!ret) {",
            "\t\tmutex_lock(&wq_pool_attach_mutex);",
            "\t\tcpumask_copy(wq_unbound_cpumask, unbound_cpumask);",
            "\t\tmutex_unlock(&wq_pool_attach_mutex);",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "freeze_workqueues_begin, freeze_workqueues_busy, thaw_workqueues, workqueue_apply_unbound_cpumask",
          "description": "实现工作队列冻结/解冻逻辑，检查是否存在活跃任务并调整最大并发数，动态修改非绑定工作者的CPU掩码配置",
          "similarity": 0.5497210621833801
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/workqueue.c",
          "start_line": 1686,
          "end_line": 1815,
          "content": [
            "static int wq_select_unbound_cpu(int cpu)",
            "{",
            "\tint new_cpu;",
            "",
            "\tif (likely(!wq_debug_force_rr_cpu)) {",
            "\t\tif (cpumask_test_cpu(cpu, wq_unbound_cpumask))",
            "\t\t\treturn cpu;",
            "\t} else {",
            "\t\tpr_warn_once(\"workqueue: round-robin CPU selection forced, expect performance impact\\n\");",
            "\t}",
            "",
            "\tnew_cpu = __this_cpu_read(wq_rr_cpu_last);",
            "\tnew_cpu = cpumask_next_and(new_cpu, wq_unbound_cpumask, cpu_online_mask);",
            "\tif (unlikely(new_cpu >= nr_cpu_ids)) {",
            "\t\tnew_cpu = cpumask_first_and(wq_unbound_cpumask, cpu_online_mask);",
            "\t\tif (unlikely(new_cpu >= nr_cpu_ids))",
            "\t\t\treturn cpu;",
            "\t}",
            "\t__this_cpu_write(wq_rr_cpu_last, new_cpu);",
            "",
            "\treturn new_cpu;",
            "}",
            "static void __queue_work(int cpu, struct workqueue_struct *wq,",
            "\t\t\t struct work_struct *work)",
            "{",
            "\tstruct pool_workqueue *pwq;",
            "\tstruct worker_pool *last_pool, *pool;",
            "\tunsigned int work_flags;",
            "\tunsigned int req_cpu = cpu;",
            "",
            "\t/*",
            "\t * While a work item is PENDING && off queue, a task trying to",
            "\t * steal the PENDING will busy-loop waiting for it to either get",
            "\t * queued or lose PENDING.  Grabbing PENDING and queueing should",
            "\t * happen with IRQ disabled.",
            "\t */",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "",
            "\t/*",
            "\t * For a draining wq, only works from the same workqueue are",
            "\t * allowed. The __WQ_DESTROYING helps to spot the issue that",
            "\t * queues a new work item to a wq after destroy_workqueue(wq).",
            "\t */",
            "\tif (unlikely(wq->flags & (__WQ_DESTROYING | __WQ_DRAINING) &&",
            "\t\t     WARN_ON_ONCE(!is_chained_work(wq))))",
            "\t\treturn;",
            "\trcu_read_lock();",
            "retry:",
            "\t/* pwq which will be used unless @work is executing elsewhere */",
            "\tif (req_cpu == WORK_CPU_UNBOUND) {",
            "\t\tif (wq->flags & WQ_UNBOUND)",
            "\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());",
            "\t\telse",
            "\t\t\tcpu = raw_smp_processor_id();",
            "\t}",
            "",
            "\tpwq = rcu_dereference(*per_cpu_ptr(wq->cpu_pwq, cpu));",
            "\tpool = pwq->pool;",
            "",
            "\t/*",
            "\t * If @work was previously on a different pool, it might still be",
            "\t * running there, in which case the work needs to be queued on that",
            "\t * pool to guarantee non-reentrancy.",
            "\t */",
            "\tlast_pool = get_work_pool(work);",
            "\tif (last_pool && last_pool != pool) {",
            "\t\tstruct worker *worker;",
            "",
            "\t\traw_spin_lock(&last_pool->lock);",
            "",
            "\t\tworker = find_worker_executing_work(last_pool, work);",
            "",
            "\t\tif (worker && worker->current_pwq->wq == wq) {",
            "\t\t\tpwq = worker->current_pwq;",
            "\t\t\tpool = pwq->pool;",
            "\t\t\tWARN_ON_ONCE(pool != last_pool);",
            "\t\t} else {",
            "\t\t\t/* meh... not running there, queue here */",
            "\t\t\traw_spin_unlock(&last_pool->lock);",
            "\t\t\traw_spin_lock(&pool->lock);",
            "\t\t}",
            "\t} else {",
            "\t\traw_spin_lock(&pool->lock);",
            "\t}",
            "",
            "\t/*",
            "\t * pwq is determined and locked. For unbound pools, we could have raced",
            "\t * with pwq release and it could already be dead. If its refcnt is zero,",
            "\t * repeat pwq selection. Note that unbound pwqs never die without",
            "\t * another pwq replacing it in cpu_pwq or while work items are executing",
            "\t * on it, so the retrying is guaranteed to make forward-progress.",
            "\t */",
            "\tif (unlikely(!pwq->refcnt)) {",
            "\t\tif (wq->flags & WQ_UNBOUND) {",
            "\t\t\traw_spin_unlock(&pool->lock);",
            "\t\t\tcpu_relax();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\t/* oops */",
            "\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",",
            "\t\t\t  wq->name, cpu);",
            "\t}",
            "",
            "\t/* pwq determined, queue */",
            "\ttrace_workqueue_queue_work(req_cpu, pwq, work);",
            "",
            "\tif (WARN_ON(!list_empty(&work->entry)))",
            "\t\tgoto out;",
            "",
            "\tpwq->nr_in_flight[pwq->work_color]++;",
            "\twork_flags = work_color_to_flags(pwq->work_color);",
            "",
            "\tif (likely(pwq->nr_active < pwq->max_active)) {",
            "\t\tif (list_empty(&pool->worklist))",
            "\t\t\tpool->watchdog_ts = jiffies;",
            "",
            "\t\ttrace_workqueue_activate_work(work);",
            "\t\tpwq->nr_active++;",
            "\t\tinsert_work(pwq, work, &pool->worklist, work_flags);",
            "\t\tkick_pool(pool);",
            "\t} else {",
            "\t\twork_flags |= WORK_STRUCT_INACTIVE;",
            "\t\tinsert_work(pwq, work, &pwq->inactive_works, work_flags);",
            "\t}",
            "",
            "out:",
            "\traw_spin_unlock(&pool->lock);",
            "\trcu_read_unlock();",
            "}"
          ],
          "function_name": "wq_select_unbound_cpu, __queue_work",
          "description": "该代码块处理工作项的CPU亲和性调度。wq_select_unbound_cpu选择非绑定CPU；__queue_work将工作项分配到对应worker池，处理NUMA节点绑定、工作项激活及负载均衡逻辑。",
          "similarity": 0.5472501516342163
        }
      ]
    },
    {
      "source_file": "kernel/ptrace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ptrace.c`\n\n---\n\n# ptrace.c 技术文档\n\n## 1. 文件概述\n\n`ptrace.c` 是 Linux 内核中实现 **ptrace**（进程跟踪）机制的核心通用代码文件。该文件提供了跨架构的 ptrace 公共接口和基础功能，避免在每个体系结构中重复实现相同逻辑。ptrace 机制允许一个进程（tracer，通常是调试器）观察和控制另一个进程（tracee）的执行，包括读写其内存、寄存器状态、拦截系统调用等，是调试器（如 GDB）、系统调用追踪工具（如 strace）和安全监控工具的基础。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`ptrace_access_vm()`**  \n  安全地访问被跟踪进程（tracee）的虚拟内存空间，用于读写其内存内容。\n\n- **`__ptrace_link()`**  \n  将被跟踪进程链接到跟踪进程（tracer）的 `ptraced` 链表中，并设置其父进程为 tracer。\n\n- **`ptrace_link()`**  \n  封装 `__ptrace_link()`，使用当前进程的凭证建立跟踪关系。\n\n- **`__ptrace_unlink()`**  \n  解除跟踪关系：将被跟踪进程从 tracer 的链表中移除，恢复其原始父进程，并根据进程组停止状态调整其任务状态（如从 `TASK_TRACED` 转为 `TASK_STOPPED` 或唤醒）。\n\n- **`ptrace_freeze_traced()`** / **`ptrace_unfreeze_traced()`**  \n  在执行 ptrace 操作期间临时冻结被跟踪进程，防止其被意外唤醒（即使是 SIGKILL），确保操作的原子性和一致性。\n\n- **`ptrace_check_attach()`**  \n  验证当前进程是否有权对目标进程执行 ptrace 操作，并确保目标进程处于合适的跟踪状态（可选）。\n\n- **`looks_like_a_spurious_pid()`**  \n  辅助函数，用于检测因线程组 leader 更换（如 `de_thread()`）导致的“虚假”ptrace 事件，避免对已销毁进程的误操作。\n\n### 关键数据结构字段（在 `task_struct` 中）\n\n- `ptrace`：标志位，表示进程是否被跟踪。\n- `parent` / `real_parent`：分别表示当前父进程（通常是 tracer）和原始父进程。\n- `ptraced`：链表头，包含所有被当前进程跟踪的子进程。\n- `ptrace_entry`：链表节点，用于加入 tracer 的 `ptraced` 链表。\n- `ptracer_cred`：跟踪进程的凭证（credentials），用于权限检查。\n- `jobctl`：任务控制标志，包含 `JOBCTL_PTRACE_FROZEN`、`JOBCTL_TRACED`、`JOBCTL_STOP_PENDING` 等 ptrace 相关状态。\n\n## 3. 关键实现\n\n### 安全内存访问 (`ptrace_access_vm`)\n- 通过 `get_task_mm()` 获取目标进程的内存描述符 `mm_struct`。\n- 执行严格的权限检查：\n  - 目标进程必须正在被跟踪（`tsk->ptrace` 非零）。\n  - 当前进程必须是目标进程的直接父进程（`current == tsk->parent`）。\n  - 或者当前进程在目标进程的用户命名空间中具有 `CAP_SYS_PTRACE` 能力（通过 `ptracer_capable()` 检查）。\n- 使用 `__access_remote_vm()` 安全地读写目标进程内存，避免直接遍历页表。\n\n### 跟踪关系管理\n- **链接**：`ptrace_link()` 在持有 `tasklist_lock` 写锁时调用 `__ptrace_link()`，将 tracee 加入 tracer 的 `ptraced` 链表，并保存 tracer 的凭证。\n- **解链接**：`__ptrace_unlink()` 在 detach 或 tracer 退出时调用：\n  - 清除 syscall trace/emu 标志。\n  - 恢复 `real_parent`。\n  - 清除 `ptrace` 标志和 jobctl 中的 trap 相关位。\n  - 根据进程组停止状态决定是否设置 `JOBCTL_STOP_PENDING` 并唤醒进程（`ptrace_signal_wake_up()`）。\n\n### 进程状态冻结机制\n- 在执行 ptrace 操作前调用 `ptrace_freeze_traced()`：\n  - 若 tracee 处于 `TASK_TRACED` 且无致命信号待处理，则设置 `JOBCTL_PTRACE_FROZEN` 标志，使其无法被唤醒。\n- 操作完成后调用 `ptrace_unfreeze_traced()`：\n  - 清除冻结标志。\n  - 若存在致命信号（如 SIGKILL），则清除 `JOBCTL_TRACED` 并唤醒进程以处理信号。\n\n### 权限与状态验证 (`ptrace_check_attach`)\n- 在 `tasklist_lock` 读锁保护下验证：\n  - 目标进程确由当前进程跟踪（`child->ptrace && child->parent == current`）。\n  - 若 `ignore_state=false`，则进一步冻结 tracee 以确保其处于稳定状态。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`mm_struct`、`sighand_struct` 等核心数据结构，以及 `wake_up_state()`、`task_is_traced()` 等调度状态管理函数。\n- **内存管理**：通过 `get_task_mm()`、`mmput()` 和 `__access_remote_vm()` 访问远程进程内存。\n- **信号处理**：大量使用 `siglock`、`jobctl`、`signal_struct` 等信号相关机制管理进程状态转换。\n- **安全模块**：集成 LSM（Linux Security Module）钩子（`security_ptrace_access_check`）和能力检查（`capable()`）。\n- **审计与通知**：与 `audit` 和 `cn_proc`（进程事件连接器）交互，记录 ptrace 事件。\n- **体系结构相关代码**：依赖 `asm/syscall.h` 提供的 `syscall_get_*` 接口获取系统调用信息。\n- **硬件断点**：通过 `hw_breakpoint.h` 支持硬件断点调试功能。\n\n## 5. 使用场景\n\n- **调试器（如 GDB）**：attach 到目标进程，读取/修改寄存器和内存，设置断点，单步执行。\n- **系统调用追踪（如 strace）**：拦截并记录目标进程的所有系统调用及其参数和返回值。\n- **安全监控工具**：监控可疑进程的行为，如检测恶意代码注入或提权操作。\n- **容器与沙箱**：在用户命名空间中实现进程隔离和监控。\n- **内核测试**：用于内核自检和调试，验证进程行为和系统调用处理。\n- **进程注入与热补丁**：通过修改运行中进程的内存和寄存器状态实现代码注入或修复。",
      "similarity": 0.6400187611579895,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/ptrace.c",
          "start_line": 44,
          "end_line": 148,
          "content": [
            "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,",
            "\t\t     void *buf, int len, unsigned int gup_flags)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint ret;",
            "",
            "\tmm = get_task_mm(tsk);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tif (!tsk->ptrace ||",
            "\t    (current != tsk->parent) ||",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptracer_capable(tsk, mm->user_ns))) {",
            "\t\tmmput(mm);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = __access_remote_vm(mm, addr, buf, len, gup_flags);",
            "\tmmput(mm);",
            "",
            "\treturn ret;",
            "}",
            "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,",
            "\t\t   const struct cred *ptracer_cred)",
            "{",
            "\tBUG_ON(!list_empty(&child->ptrace_entry));",
            "\tlist_add(&child->ptrace_entry, &new_parent->ptraced);",
            "\tchild->parent = new_parent;",
            "\tchild->ptracer_cred = get_cred(ptracer_cred);",
            "}",
            "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)",
            "{",
            "\t__ptrace_link(child, new_parent, current_cred());",
            "}",
            "void __ptrace_unlink(struct task_struct *child)",
            "{",
            "\tconst struct cred *old_cred;",
            "\tBUG_ON(!child->ptrace);",
            "",
            "\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tchild->parent = child->real_parent;",
            "\tlist_del_init(&child->ptrace_entry);",
            "\told_cred = child->ptracer_cred;",
            "\tchild->ptracer_cred = NULL;",
            "\tput_cred(old_cred);",
            "",
            "\tspin_lock(&child->sighand->siglock);",
            "\tchild->ptrace = 0;",
            "\t/*",
            "\t * Clear all pending traps and TRAPPING.  TRAPPING should be",
            "\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.",
            "\t */",
            "\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);",
            "\ttask_clear_jobctl_trapping(child);",
            "",
            "\t/*",
            "\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and",
            "\t * @child isn't dead.",
            "\t */",
            "\tif (!(child->flags & PF_EXITING) &&",
            "\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||",
            "\t     child->signal->group_stop_count)) {",
            "\t\tchild->jobctl |= JOBCTL_STOP_PENDING;",
            "",
            "\t\t/*",
            "\t\t * This is only possible if this thread was cloned by the",
            "\t\t * traced task running in the stopped group, set the signal",
            "\t\t * for the future reports.",
            "\t\t * FIXME: we should change ptrace_init_task() to handle this",
            "\t\t * case.",
            "\t\t */",
            "\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))",
            "\t\t\tchild->jobctl |= SIGSTOP;",
            "\t}",
            "",
            "\t/*",
            "\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick",
            "\t * @child in the butt.  Note that @resume should be used iff @child",
            "\t * is in TASK_TRACED; otherwise, we might unduly disrupt",
            "\t * TASK_KILLABLE sleeps.",
            "\t */",
            "\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))",
            "\t\tptrace_signal_wake_up(child, true);",
            "",
            "\tspin_unlock(&child->sighand->siglock);",
            "}",
            "static bool looks_like_a_spurious_pid(struct task_struct *task)",
            "{",
            "\tif (task->exit_code != ((PTRACE_EVENT_EXEC << 8) | SIGTRAP))",
            "\t\treturn false;",
            "",
            "\tif (task_pid_vnr(task) == task->ptrace_message)",
            "\t\treturn false;",
            "\t/*",
            "\t * The tracee changed its pid but the PTRACE_EVENT_EXEC event",
            "\t * was not wait()'ed, most probably debugger targets the old",
            "\t * leader which was destroyed in de_thread().",
            "\t */",
            "\treturn true;",
            "}"
          ],
          "function_name": "ptrace_access_vm, __ptrace_link, ptrace_link, __ptrace_unlink, looks_like_a_spurious_pid",
          "description": "实现进程跟踪核心操作，包含访问目标进程地址空间、维护跟踪链表、解除跟踪关系及检测虚假PID逻辑，用于安全控制和状态同步。",
          "similarity": 0.5996750593185425
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/ptrace.c",
          "start_line": 195,
          "end_line": 336,
          "content": [
            "static bool ptrace_freeze_traced(struct task_struct *task)",
            "{",
            "\tbool ret = false;",
            "",
            "\t/* Lockless, nobody but us can set this flag */",
            "\tif (task->jobctl & JOBCTL_LISTENING)",
            "\t\treturn ret;",
            "",
            "\tspin_lock_irq(&task->sighand->siglock);",
            "\tif (task_is_traced(task) && !looks_like_a_spurious_pid(task) &&",
            "\t    !__fatal_signal_pending(task)) {",
            "\t\ttask->jobctl |= JOBCTL_PTRACE_FROZEN;",
            "\t\tret = true;",
            "\t}",
            "\tspin_unlock_irq(&task->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void ptrace_unfreeze_traced(struct task_struct *task)",
            "{",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * The child may be awake and may have cleared",
            "\t * JOBCTL_PTRACE_FROZEN (see ptrace_resume).  The child will",
            "\t * not set JOBCTL_PTRACE_FROZEN or enter __TASK_TRACED anew.",
            "\t */",
            "\tif (lock_task_sighand(task, &flags)) {",
            "\t\ttask->jobctl &= ~JOBCTL_PTRACE_FROZEN;",
            "\t\tif (__fatal_signal_pending(task)) {",
            "\t\t\ttask->jobctl &= ~JOBCTL_TRACED;",
            "\t\t\twake_up_state(task, __TASK_TRACED);",
            "\t\t}",
            "\t\tunlock_task_sighand(task, &flags);",
            "\t}",
            "}",
            "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)",
            "{",
            "\tint ret = -ESRCH;",
            "",
            "\t/*",
            "\t * We take the read lock around doing both checks to close a",
            "\t * possible race where someone else was tracing our child and",
            "\t * detached between these two checks.  After this locked check,",
            "\t * we are sure that this is our traced child and that can only",
            "\t * be changed by us so it's not changing right after this.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tif (child->ptrace && child->parent == current) {",
            "\t\t/*",
            "\t\t * child->sighand can't be NULL, release_task()",
            "\t\t * does ptrace_unlink() before __exit_signal().",
            "\t\t */",
            "\t\tif (ignore_state || ptrace_freeze_traced(child))",
            "\t\t\tret = 0;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tif (!ret && !ignore_state &&",
            "\t    WARN_ON_ONCE(!wait_task_inactive(child, __TASK_TRACED|TASK_FROZEN)))",
            "\t\tret = -ESRCH;",
            "",
            "\treturn ret;",
            "}",
            "static bool ptrace_has_cap(struct user_namespace *ns, unsigned int mode)",
            "{",
            "\tif (mode & PTRACE_MODE_NOAUDIT)",
            "\t\treturn ns_capable_noaudit(ns, CAP_SYS_PTRACE);",
            "\treturn ns_capable(ns, CAP_SYS_PTRACE);",
            "}",
            "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tconst struct cred *cred = current_cred(), *tcred;",
            "\tstruct mm_struct *mm;",
            "\tkuid_t caller_uid;",
            "\tkgid_t caller_gid;",
            "",
            "\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {",
            "\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* May we inspect the given task?",
            "\t * This check is used both for attaching with ptrace",
            "\t * and for allowing access to sensitive information in /proc.",
            "\t *",
            "\t * ptrace_attach denies several cases that /proc allows",
            "\t * because setting up the necessary parent/child relationship",
            "\t * or halting the specified task is impossible.",
            "\t */",
            "",
            "\t/* Don't let security modules deny introspection */",
            "\tif (same_thread_group(task, current))",
            "\t\treturn 0;",
            "\trcu_read_lock();",
            "\tif (mode & PTRACE_MODE_FSCREDS) {",
            "\t\tcaller_uid = cred->fsuid;",
            "\t\tcaller_gid = cred->fsgid;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Using the euid would make more sense here, but something",
            "\t\t * in userland might rely on the old behavior, and this",
            "\t\t * shouldn't be a security problem since",
            "\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly",
            "\t\t * used a syscall that requests access to another process",
            "\t\t * (and not a filesystem syscall to procfs).",
            "\t\t */",
            "\t\tcaller_uid = cred->uid;",
            "\t\tcaller_gid = cred->gid;",
            "\t}",
            "\ttcred = __task_cred(task);",
            "\tif (uid_eq(caller_uid, tcred->euid) &&",
            "\t    uid_eq(caller_uid, tcred->suid) &&",
            "\t    uid_eq(caller_uid, tcred->uid)  &&",
            "\t    gid_eq(caller_gid, tcred->egid) &&",
            "\t    gid_eq(caller_gid, tcred->sgid) &&",
            "\t    gid_eq(caller_gid, tcred->gid))",
            "\t\tgoto ok;",
            "\tif (ptrace_has_cap(tcred->user_ns, mode))",
            "\t\tgoto ok;",
            "\trcu_read_unlock();",
            "\treturn -EPERM;",
            "ok:",
            "\trcu_read_unlock();",
            "\t/*",
            "\t * If a task drops privileges and becomes nondumpable (through a syscall",
            "\t * like setresuid()) while we are trying to access it, we must ensure",
            "\t * that the dumpability is read after the credentials; otherwise,",
            "\t * we may be able to attach to a task that we shouldn't be able to",
            "\t * attach to (as if the task had dropped privileges without becoming",
            "\t * nondumpable).",
            "\t * Pairs with a write barrier in commit_creds().",
            "\t */",
            "\tsmp_rmb();",
            "\tmm = task->mm;",
            "\tif (mm &&",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptrace_has_cap(mm->user_ns, mode)))",
            "\t    return -EPERM;",
            "",
            "\treturn security_ptrace_access_check(task, mode);",
            "}"
          ],
          "function_name": "ptrace_freeze_traced, ptrace_unfreeze_traced, ptrace_check_attach, ptrace_has_cap, __ptrace_may_access",
          "description": "处理跟踪进程的冻结/解冻机制，检查附加合法性并验证能力权限，确保跟踪操作符合安全策略和内核状态约束。",
          "similarity": 0.5660413503646851
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/ptrace.c",
          "start_line": 647,
          "end_line": 799,
          "content": [
            "int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tif (copy_from_user(buf, src, this_len))",
            "\t\t\treturn -EFAULT;",
            "\t\tretval = ptrace_access_vm(tsk, dst, buf, this_len,",
            "\t\t\t\tFOLL_FORCE | FOLL_WRITE);",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}",
            "static int ptrace_setoptions(struct task_struct *child, unsigned long data)",
            "{",
            "\tunsigned flags;",
            "\tint ret;",
            "",
            "\tret = check_ptrace_options(data);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* Avoid intermediate state when all opts are cleared */",
            "\tflags = child->ptrace;",
            "\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);",
            "\tflags |= (data << PT_OPT_FLAG_SHIFT);",
            "\tchild->ptrace = flags;",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(info, child->last_siginfo);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)",
            "{",
            "\tunsigned long flags;",
            "\tint error = -ESRCH;",
            "",
            "\tif (lock_task_sighand(child, &flags)) {",
            "\t\terror = -EINVAL;",
            "\t\tif (likely(child->last_siginfo != NULL)) {",
            "\t\t\tcopy_siginfo(child->last_siginfo, info);",
            "\t\t\terror = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t}",
            "\treturn error;",
            "}",
            "static int ptrace_peek_siginfo(struct task_struct *child,",
            "\t\t\t\tunsigned long addr,",
            "\t\t\t\tunsigned long data)",
            "{",
            "\tstruct ptrace_peeksiginfo_args arg;",
            "\tstruct sigpending *pending;",
            "\tstruct sigqueue *q;",
            "\tint ret, i;",
            "",
            "\tret = copy_from_user(&arg, (void __user *) addr,",
            "\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "",
            "\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)",
            "\t\treturn -EINVAL; /* unknown flags */",
            "",
            "\tif (arg.nr < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure arg.off fits in an unsigned long */",
            "\tif (arg.off > ULONG_MAX)",
            "\t\treturn 0;",
            "",
            "\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)",
            "\t\tpending = &child->signal->shared_pending;",
            "\telse",
            "\t\tpending = &child->pending;",
            "",
            "\tfor (i = 0; i < arg.nr; ) {",
            "\t\tkernel_siginfo_t info;",
            "\t\tunsigned long off = arg.off + i;",
            "\t\tbool found = false;",
            "",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tlist_for_each_entry(q, &pending->list, list) {",
            "\t\t\tif (!off--) {",
            "\t\t\t\tfound = true;",
            "\t\t\t\tcopy_siginfo(&info, &q->info);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tif (!found) /* beyond the end of the list */",
            "\t\t\tbreak;",
            "",
            "#ifdef CONFIG_COMPAT",
            "\t\tif (unlikely(in_compat_syscall())) {",
            "\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);",
            "",
            "\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t} else",
            "#endif",
            "\t\t{",
            "\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;",
            "",
            "\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {",
            "\t\t\t\tret = -EFAULT;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tdata += sizeof(siginfo_t);",
            "\t\ti++;",
            "",
            "\t\tif (signal_pending(current))",
            "\t\t\tbreak;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\tif (i > 0)",
            "\t\treturn i;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_writedata, ptrace_setoptions, ptrace_getsiginfo, ptrace_setsiginfo, ptrace_peek_siginfo",
          "description": "实现ptrace_writedata用于将数据写入被跟踪进程的内存，通过循环拷贝并处理错误；ptrace_setoptions用于更新跟踪选项标志位；ptrace_getsiginfo/ptrace_setsiginfo用于获取和设置进程的最后一个信号信息；ptrace_peek_siginfo用于遍历信号队列并复制信号信息到用户空间",
          "similarity": 0.5459856986999512
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/ptrace.c",
          "start_line": 501,
          "end_line": 618,
          "content": [
            "static int ptrace_traceme(void)",
            "{",
            "\tint ret = -EPERM;",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\t/* Are we already being traced? */",
            "\tif (!current->ptrace) {",
            "\t\tret = security_ptrace_traceme(current->parent);",
            "\t\t/*",
            "\t\t * Check PF_EXITING to ensure ->real_parent has not passed",
            "\t\t * exit_ptrace(). Otherwise we don't report the error but",
            "\t\t * pretend ->real_parent untraces us right after return.",
            "\t\t */",
            "\t\tif (!ret && !(current->real_parent->flags & PF_EXITING)) {",
            "\t\t\tcurrent->ptrace = PT_PTRACED;",
            "\t\t\tptrace_link(current, current->real_parent);",
            "\t\t}",
            "\t}",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\treturn ret;",
            "}",
            "static int ignoring_children(struct sighand_struct *sigh)",
            "{",
            "\tint ret;",
            "\tspin_lock(&sigh->siglock);",
            "\tret = (sigh->action[SIGCHLD-1].sa.sa_handler == SIG_IGN) ||",
            "\t      (sigh->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT);",
            "\tspin_unlock(&sigh->siglock);",
            "\treturn ret;",
            "}",
            "static bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)",
            "{",
            "\tbool dead;",
            "",
            "\t__ptrace_unlink(p);",
            "",
            "\tif (p->exit_state != EXIT_ZOMBIE)",
            "\t\treturn false;",
            "",
            "\tdead = !thread_group_leader(p);",
            "",
            "\tif (!dead && thread_group_empty(p)) {",
            "\t\tif (!same_thread_group(p->real_parent, tracer))",
            "\t\t\tdead = do_notify_parent(p, p->exit_signal);",
            "\t\telse if (ignoring_children(tracer->sighand)) {",
            "\t\t\t__wake_up_parent(p, tracer);",
            "\t\t\tdead = true;",
            "\t\t}",
            "\t}",
            "\t/* Mark it as in the process of being reaped. */",
            "\tif (dead)",
            "\t\tp->exit_state = EXIT_DEAD;",
            "\treturn dead;",
            "}",
            "static int ptrace_detach(struct task_struct *child, unsigned int data)",
            "{",
            "\tif (!valid_signal(data))",
            "\t\treturn -EIO;",
            "",
            "\t/* Architecture-specific hardware disable .. */",
            "\tptrace_disable(child);",
            "",
            "\twrite_lock_irq(&tasklist_lock);",
            "\t/*",
            "\t * We rely on ptrace_freeze_traced(). It can't be killed and",
            "\t * untraced by another thread, it can't be a zombie.",
            "\t */",
            "\tWARN_ON(!child->ptrace || child->exit_state);",
            "\t/*",
            "\t * tasklist_lock avoids the race with wait_task_stopped(), see",
            "\t * the comment in ptrace_resume().",
            "\t */",
            "\tchild->exit_code = data;",
            "\t__ptrace_detach(current, child);",
            "\twrite_unlock_irq(&tasklist_lock);",
            "",
            "\tproc_ptrace_connector(child, PTRACE_DETACH);",
            "",
            "\treturn 0;",
            "}",
            "void exit_ptrace(struct task_struct *tracer, struct list_head *dead)",
            "{",
            "\tstruct task_struct *p, *n;",
            "",
            "\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {",
            "\t\tif (unlikely(p->ptrace & PT_EXITKILL))",
            "\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);",
            "",
            "\t\tif (__ptrace_detach(tracer, p))",
            "\t\t\tlist_add(&p->ptrace_entry, dead);",
            "\t}",
            "}",
            "int ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst, int len)",
            "{",
            "\tint copied = 0;",
            "",
            "\twhile (len > 0) {",
            "\t\tchar buf[128];",
            "\t\tint this_len, retval;",
            "",
            "\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;",
            "\t\tretval = ptrace_access_vm(tsk, src, buf, this_len, FOLL_FORCE);",
            "",
            "\t\tif (!retval) {",
            "\t\t\tif (copied)",
            "\t\t\t\tbreak;",
            "\t\t\treturn -EIO;",
            "\t\t}",
            "\t\tif (copy_to_user(dst, buf, retval))",
            "\t\t\treturn -EFAULT;",
            "\t\tcopied += retval;",
            "\t\tsrc += retval;",
            "\t\tdst += retval;",
            "\t\tlen -= retval;",
            "\t}",
            "\treturn copied;",
            "}"
          ],
          "function_name": "ptrace_traceme, ignoring_children, __ptrace_detach, ptrace_detach, exit_ptrace, ptrace_readdata",
          "description": "完成跟踪关系建立与终止，包含被跟踪进程自我注册、子进程忽略信号检测、跟踪分离及资源释放逻辑，处理进程退出时的跟踪清理。",
          "similarity": 0.5234071016311646
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/ptrace.c",
          "start_line": 967,
          "end_line": 1267,
          "content": [
            "static unsigned long",
            "ptrace_get_syscall_info_exit(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t     struct ptrace_syscall_info *info)",
            "{",
            "\tinfo->op = PTRACE_SYSCALL_INFO_EXIT;",
            "\tinfo->exit.rval = syscall_get_error(child, regs);",
            "\tinfo->exit.is_error = !!info->exit.rval;",
            "\tif (!info->exit.is_error)",
            "\t\tinfo->exit.rval = syscall_get_return_value(child, regs);",
            "",
            "\t/* is_error is the last field in struct ptrace_syscall_info.exit */",
            "\treturn offsetofend(struct ptrace_syscall_info, exit.is_error);",
            "}",
            "static int",
            "ptrace_get_syscall_info(struct task_struct *child, unsigned long user_size,",
            "\t\t\tvoid __user *datavp)",
            "{",
            "\tstruct pt_regs *regs = task_pt_regs(child);",
            "\tstruct ptrace_syscall_info info = {",
            "\t\t.op = PTRACE_SYSCALL_INFO_NONE,",
            "\t\t.arch = syscall_get_arch(child),",
            "\t\t.instruction_pointer = instruction_pointer(regs),",
            "\t\t.stack_pointer = user_stack_pointer(regs),",
            "\t};",
            "\tunsigned long actual_size = offsetof(struct ptrace_syscall_info, entry);",
            "\tunsigned long write_size;",
            "",
            "\t/*",
            "\t * This does not need lock_task_sighand() to access",
            "\t * child->last_siginfo because ptrace_freeze_traced()",
            "\t * called earlier by ptrace_check_attach() ensures that",
            "\t * the tracee cannot go away and clear its last_siginfo.",
            "\t */",
            "\tswitch (child->last_siginfo ? child->last_siginfo->si_code : 0) {",
            "\tcase SIGTRAP | 0x80:",
            "\t\tswitch (child->ptrace_message) {",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_ENTRY:",
            "\t\t\tactual_size = ptrace_get_syscall_info_entry(child, regs,",
            "\t\t\t\t\t\t\t\t    &info);",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_EXIT:",
            "\t\t\tactual_size = ptrace_get_syscall_info_exit(child, regs,",
            "\t\t\t\t\t\t\t\t   &info);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase SIGTRAP | (PTRACE_EVENT_SECCOMP << 8):",
            "\t\tactual_size = ptrace_get_syscall_info_seccomp(child, regs,",
            "\t\t\t\t\t\t\t      &info);",
            "\t\tbreak;",
            "\t}",
            "",
            "\twrite_size = min(actual_size, user_size);",
            "\treturn copy_to_user(datavp, &info, write_size) ? -EFAULT : actual_size;",
            "}",
            "int ptrace_request(struct task_struct *child, long request,",
            "\t\t   unsigned long addr, unsigned long data)",
            "{",
            "\tbool seized = child->ptrace & PT_SEIZED;",
            "\tint ret = -EIO;",
            "\tkernel_siginfo_t siginfo, *si;",
            "\tvoid __user *datavp = (void __user *) data;",
            "\tunsigned long __user *datalp = datavp;",
            "\tunsigned long flags;",
            "",
            "\tswitch (request) {",
            "\tcase PTRACE_PEEKTEXT:",
            "\tcase PTRACE_PEEKDATA:",
            "\t\treturn generic_ptrace_peekdata(child, addr, data);",
            "\tcase PTRACE_POKETEXT:",
            "\tcase PTRACE_POKEDATA:",
            "\t\treturn generic_ptrace_pokedata(child, addr, data);",
            "",
            "#ifdef PTRACE_OLDSETOPTIONS",
            "\tcase PTRACE_OLDSETOPTIONS:",
            "#endif",
            "\tcase PTRACE_SETOPTIONS:",
            "\t\tret = ptrace_setoptions(child, data);",
            "\t\tbreak;",
            "\tcase PTRACE_GETEVENTMSG:",
            "\t\tret = put_user(child->ptrace_message, datalp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_PEEKSIGINFO:",
            "\t\tret = ptrace_peek_siginfo(child, addr, data);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGINFO:",
            "\t\tret = ptrace_getsiginfo(child, &siginfo);",
            "\t\tif (!ret)",
            "\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SETSIGINFO:",
            "\t\tret = copy_siginfo_from_user(&siginfo, datavp);",
            "\t\tif (!ret)",
            "\t\t\tret = ptrace_setsiginfo(child, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGMASK: {",
            "\t\tsigset_t *mask;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (test_tsk_restore_sigmask(child))",
            "\t\t\tmask = &child->saved_sigmask;",
            "\t\telse",
            "\t\t\tmask = &child->blocked;",
            "",
            "\t\tif (copy_to_user(datavp, mask, sizeof(sigset_t)))",
            "\t\t\tret = -EFAULT;",
            "\t\telse",
            "\t\t\tret = 0;",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_SETSIGMASK: {",
            "\t\tsigset_t new_set;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (copy_from_user(&new_set, datavp, sizeof(sigset_t))) {",
            "\t\t\tret = -EFAULT;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));",
            "",
            "\t\t/*",
            "\t\t * Every thread does recalc_sigpending() after resume, so",
            "\t\t * retarget_shared_pending() and recalc_sigpending() are not",
            "\t\t * called here.",
            "\t\t */",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tchild->blocked = new_set;",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tclear_tsk_restore_sigmask(child);",
            "",
            "\t\tret = 0;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_INTERRUPT:",
            "\t\t/*",
            "\t\t * Stop tracee without any side-effect on signal or job",
            "\t\t * control.  At least one trap is guaranteed to happen",
            "\t\t * after this request.  If @child is already trapped, the",
            "\t\t * current trap is not disturbed and another trap will",
            "\t\t * happen after the current trap is ended with PTRACE_CONT.",
            "\t\t *",
            "\t\t * The actual trap might not be PTRACE_EVENT_STOP trap but",
            "\t\t * the pending condition is cleared regardless.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * INTERRUPT doesn't disturb existing trap sans one",
            "\t\t * exception.  If ptracer issued LISTEN for the current",
            "\t\t * STOP, this INTERRUPT should clear LISTEN and re-trap",
            "\t\t * tracee into STOP.",
            "\t\t */",
            "\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))",
            "\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);",
            "",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tret = 0;",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_LISTEN:",
            "\t\t/*",
            "\t\t * Listen for events.  Tracee must be in STOP.  It's not",
            "\t\t * resumed per-se but is not considered to be in TRACED by",
            "\t\t * wait(2) or ptrace(2).  If an async event (e.g. group",
            "\t\t * stop state change) happens, tracee will enter STOP trap",
            "\t\t * again.  Alternatively, ptracer can issue INTERRUPT to",
            "\t\t * finish listening and re-trap tracee into STOP.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\tsi = child->last_siginfo;",
            "\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {",
            "\t\t\tchild->jobctl |= JOBCTL_LISTENING;",
            "\t\t\t/*",
            "\t\t\t * If NOTIFY is set, it means event happened between",
            "\t\t\t * start of this trap and now.  Trigger re-trap.",
            "\t\t\t */",
            "\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)",
            "\t\t\t\tptrace_signal_wake_up(child, true);",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_DETACH:\t /* detach a process that was attached. */",
            "\t\tret = ptrace_detach(child, data);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_BINFMT_ELF_FDPIC",
            "\tcase PTRACE_GETFDPIC: {",
            "\t\tstruct mm_struct *mm = get_task_mm(child);",
            "\t\tunsigned long tmp = 0;",
            "",
            "\t\tret = -ESRCH;",
            "\t\tif (!mm)",
            "\t\t\tbreak;",
            "",
            "\t\tswitch (addr) {",
            "\t\tcase PTRACE_GETFDPIC_EXEC:",
            "\t\t\ttmp = mm->context.exec_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_GETFDPIC_INTERP:",
            "\t\t\ttmp = mm->context.interp_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tmmput(mm);",
            "",
            "\t\tret = put_user(tmp, datalp);",
            "\t\tbreak;",
            "\t}",
            "#endif",
            "",
            "\tcase PTRACE_SINGLESTEP:",
            "#ifdef PTRACE_SINGLEBLOCK",
            "\tcase PTRACE_SINGLEBLOCK:",
            "#endif",
            "#ifdef PTRACE_SYSEMU",
            "\tcase PTRACE_SYSEMU:",
            "\tcase PTRACE_SYSEMU_SINGLESTEP:",
            "#endif",
            "\tcase PTRACE_SYSCALL:",
            "\tcase PTRACE_CONT:",
            "\t\treturn ptrace_resume(child, request, data);",
            "",
            "\tcase PTRACE_KILL:",
            "\t\tsend_sig_info(SIGKILL, SEND_SIG_NOINFO, child);",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_HAVE_ARCH_TRACEHOOK",
            "\tcase PTRACE_GETREGSET:",
            "\tcase PTRACE_SETREGSET: {",
            "\t\tstruct iovec kiov;",
            "\t\tstruct iovec __user *uiov = datavp;",
            "",
            "\t\tif (!access_ok(uiov, sizeof(*uiov)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||",
            "\t\t    __get_user(kiov.iov_len, &uiov->iov_len))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tret = ptrace_regset(child, request, addr, &kiov);",
            "\t\tif (!ret)",
            "\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_GET_SYSCALL_INFO:",
            "\t\tret = ptrace_get_syscall_info(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SECCOMP_GET_FILTER:",
            "\t\tret = seccomp_get_filter(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SECCOMP_GET_METADATA:",
            "\t\tret = seccomp_get_metadata(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_RSEQ",
            "\tcase PTRACE_GET_RSEQ_CONFIGURATION:",
            "\t\tret = ptrace_get_rseq_configuration(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_set_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_get_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_get_syscall_info_exit, ptrace_get_syscall_info, ptrace_request",
          "description": "ptrace_get_syscall_info根据进程最后信号信息构造系统调用详细数据结构；ptrace_request作为ptrace系统调用的核心分发函数，处理包括中断、继续执行、获取/设置信号掩码、获取系统调用信息等各类请求",
          "similarity": 0.5210003852844238
        }
      ]
    }
  ]
}