{
  "query": "container runtime",
  "timestamp": "2025-12-26 01:50:37",
  "retrieved_files": [
    {
      "source_file": "kernel/time/namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:40:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\namespace.c`\n\n---\n\n# time/namespace.c 技术文档\n\n## 1. 文件概述\n\n`time/namespace.c` 实现了 Linux 内核中的 **时间命名空间（time namespace）** 功能，允许不同进程组拥有独立的时间视图。该机制主要用于容器化环境中，使容器内的进程能够看到与宿主机或其他容器不同的系统时间（特别是 `CLOCK_MONOTONIC` 和 `CLOCK_BOOTTIME` 等单调时钟）。时间命名空间通过偏移量（offset）机制实现，不影响真实硬件时钟，仅在用户空间通过 VDSO（虚拟动态共享对象）提供转换后的时间值。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `do_timens_ktime_to_host()` | 将时间命名空间中的时间值转换回宿主机时间（减去偏移量），用于内核内部时间比较 |\n| `clone_time_ns()` | 克隆一个时间命名空间，分配资源并初始化 VVAR 页面 |\n| `copy_time_ns()` | 根据 `CLONE_NEWTIME` 标志决定是克隆还是复用现有时间命名空间 |\n| `timens_setup_vdso_data()` | 在 VDSO 数据页中设置时间偏移量，供用户空间读取 |\n| `find_timens_vvar_page()` | 为进程查找其所属时间命名空间的 VVAR 页面 |\n| `timens_set_vvar_page()` | 初始化时间命名空间的 VVAR 页面（仅首次进入时执行） |\n| `free_time_ns()` | 释放时间命名空间占用的资源 |\n| `timens_commit()` | 在任务切换到新时间命名空间时提交配置（设置 VVAR 和 VDSO） |\n| `timens_install()` | 安装新的时间命名空间到当前进程（需权限检查） |\n| `timens_on_fork()` | 子进程 fork 时继承父进程的 `time_ns_for_children` |\n\n### 关键数据结构\n\n- `struct time_namespace`：时间命名空间的核心结构，包含：\n  - `vvar_page`：用于 VDSO 的特殊内存页\n  - `offsets`：`monotonic` 和 `boottime` 时钟的偏移量\n  - `frozen_offsets`：标志位，表示偏移量是否已固化（防止重复初始化）\n  - `user_ns`：所属的用户命名空间\n  - `ucounts`：资源计数器，限制时间命名空间创建数量\n\n- `struct timens_offsets`：存储 `CLOCK_MONOTONIC` 和 `CLOCK_BOOTTIME` 的偏移量（`timespec64` 格式）\n\n- `struct timens_offset`：VDSO 中使用的偏移量结构（`sec` + `nsec`）\n\n## 3. 关键实现\n\n### 时间偏移转换机制\n- `do_timens_ktime_to_host()` 负责将命名空间内的时间值（如定时器到期时间）转换为宿主机视角的时间。\n- 对于 `CLOCK_MONOTONIC` 和 `CLOCK_BOOTTIME`，减去对应的偏移量。\n- 若转换后时间小于 0，则视为已过期，返回 0。\n- 转换结果被限制在 `[0, KTIME_MAX]` 范围内。\n\n### VDSO 集成\n- 时间命名空间通过 **VVAR 页面** 向用户空间暴露偏移量。\n- 正常进程的 VDSO 布局：`VVAR → PVCLOCK → HVCLOCK`\n- 时间命名空间进程的 VDSO 布局：`TIMENS → PVCLOCK → HVCLOCK → VVAR`\n- `timens_setup_vdso_data()` 在 VVAR 页面中设置 `clock_mode = VDSO_CLOCKMODE_TIMENS` 并填充各时钟的偏移量。\n- 用户空间 VDSO 代码根据 `clock_mode` 决定是否应用偏移。\n\n### 偏移量初始化保护\n- 使用全局 `offset_lock` 互斥锁确保 `vvar_page` 仅被初始化一次。\n- `frozen_offsets` 标志位避免重复初始化，提高性能（快路径无锁）。\n\n### 资源管理与权限控制\n- 通过 `ucounts` 限制每个用户命名空间可创建的时间命名空间数量（防 DoS）。\n- `timens_install()` 要求调用者在**目标命名空间**和**当前命名空间**均具备 `CAP_SYS_ADMIN` 权限。\n- 仅允许单线程进程（`current_is_single_threaded()`）切换时间命名空间，避免多线程一致性问题。\n\n### 进程继承模型\n- 每个进程拥有两个时间命名空间指针：\n  - `time_ns`：当前生效的时间命名空间\n  - `time_ns_for_children`：子进程将继承的时间命名空间\n- `timens_on_fork()` 确保子进程正确继承父进程的 `time_ns_for_children`\n\n## 4. 依赖关系\n\n| 依赖模块 | 用途 |\n|---------|------|\n| `<linux/user_namespace.h>` | 用户命名空间支持，用于权限隔离和资源计数 |\n| `<linux/proc_ns.h>` | 命名空间 proc 接口（如 `/proc/PID/ns/time`） |\n| `<vdso/datapage.h>` | VDSO 数据页结构定义 |\n| `<linux/clocksource.h>` | 时钟源相关常量（如 `CS_BASES`） |\n| `<linux/sched/*.h>` | 进程调度和 nsproxy 管理 |\n| `<linux/cred.h>` | 凭据和权限检查（`ns_capable()`） |\n| `<linux/mm.h>` | 内存管理（`alloc_page()`、`vm_area_struct`） |\n\n## 5. 使用场景\n\n1. **容器时间隔离**  \n   容器运行时（如 LXC、systemd-nspawn）可通过 `unshare(CLONE_NEWTIME)` 创建独立时间视图，使容器内 `CLOCK_MONOTONIC` 从 0 开始计时，便于测试或迁移。\n\n2. **系统时间回滚测试**  \n   开发者可在时间命名空间中设置负偏移量，模拟系统时间回退场景，验证应用程序的健壮性。\n\n3. **沙箱环境**  \n   安全沙箱可限制进程看到的时间范围，防止基于时间的侧信道攻击。\n\n4. **VDSO 优化路径**  \n   用户空间通过 VDSO 直接读取偏移后的时间，无需系统调用，性能开销极低。\n\n5. **命名空间组合**  \n   时间命名空间通常与 PID、mount、user 等命名空间联合使用，构建完整的隔离环境。",
      "similarity": 0.5680930018424988,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/time/namespace.c",
          "start_line": 298,
          "end_line": 448,
          "content": [
            "void timens_commit(struct task_struct *tsk, struct time_namespace *ns)",
            "{",
            "\ttimens_set_vvar_page(tsk, ns);",
            "\tvdso_join_timens(tsk, ns);",
            "}",
            "static int timens_install(struct nsset *nsset, struct ns_common *new)",
            "{",
            "\tstruct nsproxy *nsproxy = nsset->nsproxy;",
            "\tstruct time_namespace *ns = to_time_ns(new);",
            "",
            "\tif (!current_is_single_threaded())",
            "\t\treturn -EUSERS;",
            "",
            "\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||",
            "\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tget_time_ns(ns);",
            "\tput_time_ns(nsproxy->time_ns);",
            "\tnsproxy->time_ns = ns;",
            "",
            "\tget_time_ns(ns);",
            "\tput_time_ns(nsproxy->time_ns_for_children);",
            "\tnsproxy->time_ns_for_children = ns;",
            "\treturn 0;",
            "}",
            "void timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk)",
            "{",
            "\tstruct ns_common *nsc = &nsproxy->time_ns_for_children->ns;",
            "\tstruct time_namespace *ns = to_time_ns(nsc);",
            "",
            "\t/* create_new_namespaces() already incremented the ref counter */",
            "\tif (nsproxy->time_ns == nsproxy->time_ns_for_children)",
            "\t\treturn;",
            "",
            "\tget_time_ns(ns);",
            "\tput_time_ns(nsproxy->time_ns);",
            "\tnsproxy->time_ns = ns;",
            "",
            "\ttimens_commit(tsk, ns);",
            "}",
            "static void show_offset(struct seq_file *m, int clockid, struct timespec64 *ts)",
            "{",
            "\tchar *clock;",
            "",
            "\tswitch (clockid) {",
            "\tcase CLOCK_BOOTTIME:",
            "\t\tclock = \"boottime\";",
            "\t\tbreak;",
            "\tcase CLOCK_MONOTONIC:",
            "\t\tclock = \"monotonic\";",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tclock = \"unknown\";",
            "\t\tbreak;",
            "\t}",
            "\tseq_printf(m, \"%-10s %10lld %9ld\\n\", clock, ts->tv_sec, ts->tv_nsec);",
            "}",
            "void proc_timens_show_offsets(struct task_struct *p, struct seq_file *m)",
            "{",
            "\tstruct ns_common *ns;",
            "\tstruct time_namespace *time_ns;",
            "",
            "\tns = timens_for_children_get(p);",
            "\tif (!ns)",
            "\t\treturn;",
            "\ttime_ns = to_time_ns(ns);",
            "",
            "\tshow_offset(m, CLOCK_MONOTONIC, &time_ns->offsets.monotonic);",
            "\tshow_offset(m, CLOCK_BOOTTIME, &time_ns->offsets.boottime);",
            "\tput_time_ns(time_ns);",
            "}",
            "int proc_timens_set_offset(struct file *file, struct task_struct *p,",
            "\t\t\t   struct proc_timens_offset *offsets, int noffsets)",
            "{",
            "\tstruct ns_common *ns;",
            "\tstruct time_namespace *time_ns;",
            "\tstruct timespec64 tp;",
            "\tint i, err;",
            "",
            "\tns = timens_for_children_get(p);",
            "\tif (!ns)",
            "\t\treturn -ESRCH;",
            "\ttime_ns = to_time_ns(ns);",
            "",
            "\tif (!file_ns_capable(file, time_ns->user_ns, CAP_SYS_TIME)) {",
            "\t\tput_time_ns(time_ns);",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\tfor (i = 0; i < noffsets; i++) {",
            "\t\tstruct proc_timens_offset *off = &offsets[i];",
            "",
            "\t\tswitch (off->clockid) {",
            "\t\tcase CLOCK_MONOTONIC:",
            "\t\t\tktime_get_ts64(&tp);",
            "\t\t\tbreak;",
            "\t\tcase CLOCK_BOOTTIME:",
            "\t\t\tktime_get_boottime_ts64(&tp);",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\terr = -ERANGE;",
            "",
            "\t\tif (off->val.tv_sec > KTIME_SEC_MAX ||",
            "\t\t    off->val.tv_sec < -KTIME_SEC_MAX)",
            "\t\t\tgoto out;",
            "",
            "\t\ttp = timespec64_add(tp, off->val);",
            "\t\t/*",
            "\t\t * KTIME_SEC_MAX is divided by 2 to be sure that KTIME_MAX is",
            "\t\t * still unreachable.",
            "\t\t */",
            "\t\tif (tp.tv_sec < 0 || tp.tv_sec > KTIME_SEC_MAX / 2)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tmutex_lock(&offset_lock);",
            "\tif (time_ns->frozen_offsets) {",
            "\t\terr = -EACCES;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\terr = 0;",
            "\t/* Don't report errors after this line */",
            "\tfor (i = 0; i < noffsets; i++) {",
            "\t\tstruct proc_timens_offset *off = &offsets[i];",
            "\t\tstruct timespec64 *offset = NULL;",
            "",
            "\t\tswitch (off->clockid) {",
            "\t\tcase CLOCK_MONOTONIC:",
            "\t\t\toffset = &time_ns->offsets.monotonic;",
            "\t\t\tbreak;",
            "\t\tcase CLOCK_BOOTTIME:",
            "\t\t\toffset = &time_ns->offsets.boottime;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t*offset = off->val;",
            "\t}",
            "",
            "out_unlock:",
            "\tmutex_unlock(&offset_lock);",
            "out:",
            "\tput_time_ns(time_ns);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "timens_commit, timens_install, timens_on_fork, show_offset, proc_timens_show_offsets, proc_timens_set_offset",
          "description": "实现时间命名空间的安装传播机制，包含命名空间继承处理、偏移量展示接口、时钟偏移量设置接口及其权限校验逻辑。",
          "similarity": 0.46860766410827637
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/namespace.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Author: Andrei Vagin <avagin@openvz.org>",
            " * Author: Dmitry Safonov <dima@arista.com>",
            " */",
            "",
            "#include <linux/time_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/export.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "",
            "#include <vdso/datapage.h>",
            ""
          ],
          "function_name": null,
          "description": "包含时间命名空间所需头文件，声明时间、用户命名空间及内核通用结构体，为后续时间命名空间实现提供类型和函数声明支持。",
          "similarity": 0.46487393975257874
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/namespace.c",
          "start_line": 23,
          "end_line": 124,
          "content": [
            "ktime_t do_timens_ktime_to_host(clockid_t clockid, ktime_t tim,",
            "\t\t\t\tstruct timens_offsets *ns_offsets)",
            "{",
            "\tktime_t offset;",
            "",
            "\tswitch (clockid) {",
            "\tcase CLOCK_MONOTONIC:",
            "\t\toffset = timespec64_to_ktime(ns_offsets->monotonic);",
            "\t\tbreak;",
            "\tcase CLOCK_BOOTTIME:",
            "\tcase CLOCK_BOOTTIME_ALARM:",
            "\t\toffset = timespec64_to_ktime(ns_offsets->boottime);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn tim;",
            "\t}",
            "",
            "\t/*",
            "\t * Check that @tim value is in [offset, KTIME_MAX + offset]",
            "\t * and subtract offset.",
            "\t */",
            "\tif (tim < offset) {",
            "\t\t/*",
            "\t\t * User can specify @tim *absolute* value - if it's lesser than",
            "\t\t * the time namespace's offset - it's already expired.",
            "\t\t */",
            "\t\ttim = 0;",
            "\t} else {",
            "\t\ttim = ktime_sub(tim, offset);",
            "\t\tif (unlikely(tim > KTIME_MAX))",
            "\t\t\ttim = KTIME_MAX;",
            "\t}",
            "",
            "\treturn tim;",
            "}",
            "static void dec_time_namespaces(struct ucounts *ucounts)",
            "{",
            "\tdec_ucount(ucounts, UCOUNT_TIME_NAMESPACES);",
            "}",
            "static struct timens_offset offset_from_ts(struct timespec64 off)",
            "{",
            "\tstruct timens_offset ret;",
            "",
            "\tret.sec = off.tv_sec;",
            "\tret.nsec = off.tv_nsec;",
            "",
            "\treturn ret;",
            "}",
            "static void timens_setup_vdso_data(struct vdso_data *vdata,",
            "\t\t\t\t   struct time_namespace *ns)",
            "{",
            "\tstruct timens_offset *offset = vdata->offset;",
            "\tstruct timens_offset monotonic = offset_from_ts(ns->offsets.monotonic);",
            "\tstruct timens_offset boottime = offset_from_ts(ns->offsets.boottime);",
            "",
            "\tvdata->seq\t\t\t= 1;",
            "\tvdata->clock_mode\t\t= VDSO_CLOCKMODE_TIMENS;",
            "\toffset[CLOCK_MONOTONIC]\t\t= monotonic;",
            "\toffset[CLOCK_MONOTONIC_RAW]\t= monotonic;",
            "\toffset[CLOCK_MONOTONIC_COARSE]\t= monotonic;",
            "\toffset[CLOCK_BOOTTIME]\t\t= boottime;",
            "\toffset[CLOCK_BOOTTIME_ALARM]\t= boottime;",
            "}",
            "static void timens_set_vvar_page(struct task_struct *task,",
            "\t\t\t\tstruct time_namespace *ns)",
            "{",
            "\tstruct vdso_data *vdata;",
            "\tunsigned int i;",
            "",
            "\tif (ns == &init_time_ns)",
            "\t\treturn;",
            "",
            "\t/* Fast-path, taken by every task in namespace except the first. */",
            "\tif (likely(ns->frozen_offsets))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&offset_lock);",
            "\t/* Nothing to-do: vvar_page has been already initialized. */",
            "\tif (ns->frozen_offsets)",
            "\t\tgoto out;",
            "",
            "\tns->frozen_offsets = true;",
            "\tvdata = arch_get_vdso_data(page_address(ns->vvar_page));",
            "",
            "\tfor (i = 0; i < CS_BASES; i++)",
            "\t\ttimens_setup_vdso_data(&vdata[i], ns);",
            "",
            "out:",
            "\tmutex_unlock(&offset_lock);",
            "}",
            "void free_time_ns(struct time_namespace *ns)",
            "{",
            "\tdec_time_namespaces(ns->ucounts);",
            "\tput_user_ns(ns->user_ns);",
            "\tns_free_inum(&ns->ns);",
            "\t__free_page(ns->vvar_page);",
            "\tkfree(ns);",
            "}",
            "static void timens_put(struct ns_common *ns)",
            "{",
            "\tput_time_ns(to_time_ns(ns));",
            "}"
          ],
          "function_name": "do_timens_ktime_to_host, dec_time_namespaces, offset_from_ts, timens_setup_vdso_data, timens_set_vvar_page, free_time_ns, timens_put",
          "description": "实现时间命名空间偏移转换逻辑，包括时间转换、引用计数更新、VDSO数据初始化、页内存释放及命名空间引用计数管理等功能模块。",
          "similarity": 0.42156514525413513
        }
      ]
    },
    {
      "source_file": "kernel/futex/syscalls.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:35:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `futex\\syscalls.c`\n\n---\n\n# futex/syscalls.c 技术文档\n\n## 1. 文件概述\n\n`futex/syscalls.c` 是 Linux 内核中实现 futex（Fast Userspace muTEX）系统调用的核心文件之一。该文件主要负责处理与 futex 相关的用户空间系统调用接口，包括基础 futex 操作、健壮 futex（robust futex）支持以及多 futex 等待（`futex_waitv`）功能。futex 是一种高效的用户态同步原语，内核仅在必要时（如竞争或阻塞）介入，从而在无竞争场景下实现零内核开销。\n\n## 2. 核心功能\n\n### 主要系统调用函数：\n\n- `sys_set_robust_list()`：为当前任务设置健壮 futex 列表头指针。\n- `sys_get_robust_list()`：获取指定任务（或当前任务）的健壮 futex 列表头指针。\n- `sys_futex()`：主 futex 系统调用，支持多种操作（如 `FUTEX_WAIT`、`FUTEX_WAKE`、`FUTEX_LOCK_PI` 等）。\n- `sys_futex_waitv()`：等待多个 futex 中任意一个被唤醒（尚未完整实现，仅声明）。\n\n### 辅助函数：\n\n- `do_futex()`：统一调度所有 futex 操作的核心分发函数。\n- `futex_cmd_has_timeout()`：判断指定 futex 命令是否支持超时。\n- `futex_init_timeout()`：解析并转换用户提供的超时时间（支持 `CLOCK_REALTIME` 和 `CLOCK_MONOTONIC`）。\n- `futex_parse_waitv()`：从用户空间解析 `futex_waitv` 数组，验证并初始化内核侧等待结构。\n- `futex2_setup_timeout()` / `futex2_destroy_timeout()`：为 `futex_waitv` 设置和销毁高精度定时器。\n\n### 关键数据结构（引用）：\n\n- `struct robust_list_head`：健壮 futex 列表头，由用户空间维护。\n- `struct futex_waitv`：用于 `futex_waitv` 的用户空间输入结构，包含地址、期望值和标志。\n- `struct futex_vector`：内核侧表示多个 futex 等待项的结构。\n\n## 3. 关键实现\n\n### 健壮 Futex（Robust Futex）机制\n- 用户空间为每个线程维护一个持有锁的链表（`robust_list`）。\n- 当线程异常退出时，内核遍历该链表，将所有属于该线程的 futex 标记为 `FUTEX_OWNER_DIED` 并唤醒等待者。\n- 通过 `list_op_pending` 字段处理“已加锁但尚未加入链表”的临界状态，确保清理完整性。\n- `set_robust_list` / `get_robust_list` 系统调用用于注册和查询该链表。\n\n### Futex 操作分发\n- `do_futex()` 根据操作码（`op & FUTEX_CMD_MASK`）分发到具体实现函数（如 `futex_wait`、`futex_wake`、`futex_lock_pi` 等）。\n- 支持多种 futex 类型：普通 futex、PI（优先级继承）futex、bitset futex、requeue 操作等。\n- 对于带超时的操作（如 `FUTEX_WAIT`），根据是否使用 `FUTEX_CLOCK_REALTIME` 标志决定使用绝对时间还是相对时间，并进行时间命名空间转换（`timens_ktime_to_host`）。\n\n### 多 Futex 等待（`futex_waitv`）\n- 允许线程同时等待多个 futex，任一 futex 被唤醒即返回。\n- 用户传入 `futex_waitv` 数组，每个元素包含独立的地址、期望值和标志（如私有/共享、size）。\n- 使用 `futex2_to_flags()` 将用户标志转换为内核内部标志，并验证合法性。\n- 超时使用高精度定时器（`hrtimer`），支持 `CLOCK_REALTIME` 或 `CLOCK_MONOTONIC`。\n\n### 时间处理\n- 超时参数通过 `__kernel_timespec` 传入，经 `get_timespec64()` 转换为 `timespec64`。\n- `futex_init_timeout()` 根据命令类型和时钟标志，将用户时间转换为内核 `ktime_t`，并处理绝对/相对时间语义。\n- 时间命名空间支持：非 `REALTIME` 的单调时钟时间会通过 `timens_ktime_to_host()` 转换为主机时间。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/syscalls.h>`：系统调用宏定义（如 `SYSCALL_DEFINE*`）。\n  - `<linux/time_namespace.h>`：时间命名空间支持（`timens_ktime_to_host`）。\n  - `\"futex.h\"`：futex 内部实现头文件，包含核心函数声明、标志定义和数据结构。\n\n- **内核模块依赖**：\n  - **Futex 核心逻辑**：实际的等待、唤醒、锁操作由 `futex.c` 中的函数（如 `futex_wait`、`futex_wake`）实现。\n  - **调度器与 PI 机制**：PI futex 依赖内核的优先级继承和 RT 调度支持。\n  - **高精度定时器（hrtimer）**：用于实现精确超时。\n  - **RCU 机制**：`get_robust_list` 使用 RCU 保护任务结构体访问。\n  - **Ptrace 安全检查**：`get_robust_list` 调用 `ptrace_may_access` 验证权限。\n\n## 5. 使用场景\n\n- **用户态同步原语实现**：glibc 的 `pthread_mutex`、`semaphore` 等在无竞争时完全在用户态运行，仅在需要阻塞或唤醒时调用 `futex` 系统调用。\n- **健壮互斥锁**：当持有互斥锁的线程崩溃时，其他线程可通过 `FUTEX_OWNER_DIED` 检测并恢复锁状态，避免死锁。\n- **高性能事件通知**：一个线程可等待多个事件源（如 I/O 完成、信号量、条件变量），通过 `futex_waitv` 实现“任一触发即返回”的语义。\n- **实时应用**：通过 `FUTEX_CLOCK_REALTIME` 支持基于系统实时钟的绝对超时，适用于需要与外部时间对齐的场景。\n- **容器与命名空间**：时间命名空间支持确保容器内 futex 超时行为符合容器视角的时间。",
      "similarity": 0.5605027675628662,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/futex/syscalls.c",
          "start_line": 224,
          "end_line": 261,
          "content": [
            "static int futex2_setup_timeout(struct __kernel_timespec __user *timeout,",
            "\t\t\t\tclockid_t clockid, struct hrtimer_sleeper *to)",
            "{",
            "\tint flag_clkid = 0, flag_init = 0;",
            "\tstruct timespec64 ts;",
            "\tktime_t time;",
            "\tint ret;",
            "",
            "\tif (!timeout)",
            "\t\treturn 0;",
            "",
            "\tif (clockid == CLOCK_REALTIME) {",
            "\t\tflag_clkid = FLAGS_CLOCKRT;",
            "\t\tflag_init = FUTEX_CLOCK_REALTIME;",
            "\t}",
            "",
            "\tif (clockid != CLOCK_REALTIME && clockid != CLOCK_MONOTONIC)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (get_timespec64(&ts, timeout))",
            "\t\treturn -EFAULT;",
            "",
            "\t/*",
            "\t * Since there's no opcode for futex_waitv, use",
            "\t * FUTEX_WAIT_BITSET that uses absolute timeout as well",
            "\t */",
            "\tret = futex_init_timeout(FUTEX_WAIT_BITSET, flag_init, &ts, &time);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tfutex_setup_timer(&time, to, flag_clkid, 0);",
            "\treturn 0;",
            "}",
            "static inline void futex2_destroy_timeout(struct hrtimer_sleeper *to)",
            "{",
            "\thrtimer_cancel(&to->timer);",
            "\tdestroy_hrtimer_on_stack(&to->timer);",
            "}"
          ],
          "function_name": "futex2_setup_timeout, futex2_destroy_timeout",
          "description": "futex2_setup_timeout将用户态超时参数转换为内核时间戳并初始化定时器，futex2_destroy_timeout负责安全地取消和销毁定时器资源",
          "similarity": 0.48533299565315247
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/futex/syscalls.c",
          "start_line": 84,
          "end_line": 187,
          "content": [
            "long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,",
            "\t\tu32 __user *uaddr2, u32 val2, u32 val3)",
            "{",
            "\tunsigned int flags = futex_to_flags(op);",
            "\tint cmd = op & FUTEX_CMD_MASK;",
            "",
            "\tif (flags & FLAGS_CLOCKRT) {",
            "\t\tif (cmd != FUTEX_WAIT_BITSET &&",
            "\t\t    cmd != FUTEX_WAIT_REQUEUE_PI &&",
            "\t\t    cmd != FUTEX_LOCK_PI2)",
            "\t\t\treturn -ENOSYS;",
            "\t}",
            "",
            "\tswitch (cmd) {",
            "\tcase FUTEX_WAIT:",
            "\t\tval3 = FUTEX_BITSET_MATCH_ANY;",
            "\t\tfallthrough;",
            "\tcase FUTEX_WAIT_BITSET:",
            "\t\treturn futex_wait(uaddr, flags, val, timeout, val3);",
            "\tcase FUTEX_WAKE:",
            "\t\tval3 = FUTEX_BITSET_MATCH_ANY;",
            "\t\tfallthrough;",
            "\tcase FUTEX_WAKE_BITSET:",
            "\t\treturn futex_wake(uaddr, flags, val, val3);",
            "\tcase FUTEX_REQUEUE:",
            "\t\treturn futex_requeue(uaddr, flags, uaddr2, flags, val, val2, NULL, 0);",
            "\tcase FUTEX_CMP_REQUEUE:",
            "\t\treturn futex_requeue(uaddr, flags, uaddr2, flags, val, val2, &val3, 0);",
            "\tcase FUTEX_WAKE_OP:",
            "\t\treturn futex_wake_op(uaddr, flags, uaddr2, val, val2, val3);",
            "\tcase FUTEX_LOCK_PI:",
            "\t\tflags |= FLAGS_CLOCKRT;",
            "\t\tfallthrough;",
            "\tcase FUTEX_LOCK_PI2:",
            "\t\treturn futex_lock_pi(uaddr, flags, timeout, 0);",
            "\tcase FUTEX_UNLOCK_PI:",
            "\t\treturn futex_unlock_pi(uaddr, flags);",
            "\tcase FUTEX_TRYLOCK_PI:",
            "\t\treturn futex_lock_pi(uaddr, flags, NULL, 1);",
            "\tcase FUTEX_WAIT_REQUEUE_PI:",
            "\t\tval3 = FUTEX_BITSET_MATCH_ANY;",
            "\t\treturn futex_wait_requeue_pi(uaddr, flags, val, timeout, val3,",
            "\t\t\t\t\t     uaddr2);",
            "\tcase FUTEX_CMP_REQUEUE_PI:",
            "\t\treturn futex_requeue(uaddr, flags, uaddr2, flags, val, val2, &val3, 1);",
            "\t}",
            "\treturn -ENOSYS;",
            "}",
            "static __always_inline bool futex_cmd_has_timeout(u32 cmd)",
            "{",
            "\tswitch (cmd) {",
            "\tcase FUTEX_WAIT:",
            "\tcase FUTEX_LOCK_PI:",
            "\tcase FUTEX_LOCK_PI2:",
            "\tcase FUTEX_WAIT_BITSET:",
            "\tcase FUTEX_WAIT_REQUEUE_PI:",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static __always_inline int",
            "futex_init_timeout(u32 cmd, u32 op, struct timespec64 *ts, ktime_t *t)",
            "{",
            "\tif (!timespec64_valid(ts))",
            "\t\treturn -EINVAL;",
            "",
            "\t*t = timespec64_to_ktime(*ts);",
            "\tif (cmd == FUTEX_WAIT)",
            "\t\t*t = ktime_add_safe(ktime_get(), *t);",
            "\telse if (cmd != FUTEX_LOCK_PI && !(op & FUTEX_CLOCK_REALTIME))",
            "\t\t*t = timens_ktime_to_host(CLOCK_MONOTONIC, *t);",
            "\treturn 0;",
            "}",
            "static int futex_parse_waitv(struct futex_vector *futexv,",
            "\t\t\t     struct futex_waitv __user *uwaitv,",
            "\t\t\t     unsigned int nr_futexes)",
            "{",
            "\tstruct futex_waitv aux;",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < nr_futexes; i++) {",
            "\t\tunsigned int flags;",
            "",
            "\t\tif (copy_from_user(&aux, &uwaitv[i], sizeof(aux)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif ((aux.flags & ~FUTEX2_VALID_MASK) || aux.__reserved)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tflags = futex2_to_flags(aux.flags);",
            "\t\tif (!futex_flags_valid(flags))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (!futex_validate_input(flags, aux.val))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tfutexv[i].w.flags = flags;",
            "\t\tfutexv[i].w.val = aux.val;",
            "\t\tfutexv[i].w.uaddr = aux.uaddr;",
            "\t\tfutexv[i].q = futex_q_init;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "do_futex, futex_cmd_has_timeout, futex_init_timeout, futex_parse_waitv",
          "description": "do_futex处理各类futex操作命令，包含超时检测逻辑和waitv参数解析，通过条件判断分发到相应子函数实现不同操作",
          "similarity": 0.46865952014923096
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/futex/syscalls.c",
          "start_line": 1,
          "end_line": 83,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "",
            "#include <linux/syscalls.h>",
            "#include <linux/time_namespace.h>",
            "",
            "#include \"futex.h\"",
            "",
            "/*",
            " * Support for robust futexes: the kernel cleans up held futexes at",
            " * thread exit time.",
            " *",
            " * Implementation: user-space maintains a per-thread list of locks it",
            " * is holding. Upon do_exit(), the kernel carefully walks this list,",
            " * and marks all locks that are owned by this thread with the",
            " * FUTEX_OWNER_DIED bit, and wakes up a waiter (if any). The list is",
            " * always manipulated with the lock held, so the list is private and",
            " * per-thread. Userspace also maintains a per-thread 'list_op_pending'",
            " * field, to allow the kernel to clean up if the thread dies after",
            " * acquiring the lock, but just before it could have added itself to",
            " * the list. There can only be one such pending lock.",
            " */",
            "",
            "/**",
            " * sys_set_robust_list() - Set the robust-futex list head of a task",
            " * @head:\tpointer to the list-head",
            " * @len:\tlength of the list-head, as userspace expects",
            " */",
            "SYSCALL_DEFINE2(set_robust_list, struct robust_list_head __user *, head,",
            "\t\tsize_t, len)",
            "{",
            "\t/*",
            "\t * The kernel knows only one size for now:",
            "\t */",
            "\tif (unlikely(len != sizeof(*head)))",
            "\t\treturn -EINVAL;",
            "",
            "\tcurrent->robust_list = head;",
            "",
            "\treturn 0;",
            "}",
            "",
            "/**",
            " * sys_get_robust_list() - Get the robust-futex list head of a task",
            " * @pid:\tpid of the process [zero for current task]",
            " * @head_ptr:\tpointer to a list-head pointer, the kernel fills it in",
            " * @len_ptr:\tpointer to a length field, the kernel fills in the header size",
            " */",
            "SYSCALL_DEFINE3(get_robust_list, int, pid,",
            "\t\tstruct robust_list_head __user * __user *, head_ptr,",
            "\t\tsize_t __user *, len_ptr)",
            "{",
            "\tstruct robust_list_head __user *head;",
            "\tunsigned long ret;",
            "\tstruct task_struct *p;",
            "",
            "\trcu_read_lock();",
            "",
            "\tret = -ESRCH;",
            "\tif (!pid)",
            "\t\tp = current;",
            "\telse {",
            "\t\tp = find_task_by_vpid(pid);",
            "\t\tif (!p)",
            "\t\t\tgoto err_unlock;",
            "\t}",
            "",
            "\tret = -EPERM;",
            "\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))",
            "\t\tgoto err_unlock;",
            "",
            "\thead = p->robust_list;",
            "\trcu_read_unlock();",
            "",
            "\tif (put_user(sizeof(*head), len_ptr))",
            "\t\treturn -EFAULT;",
            "\treturn put_user(head, head_ptr);",
            "",
            "err_unlock:",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现set_robust_list和get_robust_list系统调用，用于设置/获取当前任务的robust-futex列表头，支持线程退出时自动清理持有锁的机制",
          "similarity": 0.45513832569122314
        }
      ]
    },
    {
      "source_file": "kernel/time/itimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:39:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\itimer.c`\n\n---\n\n# `time/itimer.c` 技术文档\n\n## 1. 文件概述\n\n`time/itimer.c` 是 Linux 内核中实现 POSIX 间隔定时器（interval timers，简称 itimers）的核心文件。该文件提供了对三种经典 Unix 间隔定时器的支持：\n\n- **ITIMER_REAL**：基于真实时间（墙上时钟）的定时器，到期时发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL**：基于进程用户态 CPU 时间的定时器，到期时发送 `SIGVTALRM` 信号\n- **ITIMER_PROF**：基于进程总 CPU 时间（用户态+内核态）的定时器，到期时发送 `SIGPROF` 信号\n\n该文件实现了 `getitimer()`、`setitimer()` 系统调用以及 `alarm()` 系统调用（在架构支持的情况下），为用户空间程序提供间隔定时器功能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`itimer_get_remtime()`**：获取高精度实时定时器的剩余时间\n- **`get_cpu_itimer()`**：获取 CPU 时间相关的定时器（虚拟/性能）状态\n- **`do_getitimer()`**：内部实现获取指定类型定时器状态的逻辑\n- **`put_itimerval()`**：将内核内部的 `itimerspec64` 格式转换为用户空间的 `old_itimerval` 格式\n- **`getitimer()` 系统调用**：用户空间获取定时器状态的入口\n- **`it_real_fn()`**：ITIMER_REAL 定时器到期时的回调函数\n- **`set_cpu_itimer()`**：设置 CPU 时间相关的定时器\n- **`do_setitimer()`**：内部实现设置指定类型定时器的逻辑\n- **`clear_itimer()`**：在 SELinux 环境下清除所有定时器（安全相关）\n- **`alarm_setitimer()`**：实现 `alarm()` 系统调用的内部函数\n- **`alarm()` 系统调用**：设置单次实时定时器的简化接口\n\n### 数据结构\n\n- **`struct cpu_itimer`**：存储 CPU 时间定时器的状态（在 `signal_struct` 中）\n- **`struct hrtimer`**：高精度定时器，用于实现 ITIMER_REAL\n- **`struct itimerspec64`**：64 位时间规格结构，内核内部使用\n- **`struct __kernel_old_itimerval`**：用户空间兼容的定时器值结构\n\n## 3. 关键实现\n\n### 定时器类型实现差异\n\n- **ITIMER_REAL**：使用高精度定时器（`hrtimer`）实现，基于真实时间，通过 `hrtimer_start()` 启动，到期时调用 `it_real_fn()` 发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL/ITIMER_PROF**：基于 CPU 时间采样实现，通过 `thread_group_sample_cputime()` 获取当前进程组的 CPU 时间，与设定的过期时间比较来判断是否到期\n\n### 时间精度处理\n\n- 使用纳秒级精度的 `ktime_t` 和 `timespec64` 进行内部计算\n- 用户空间接口使用微秒精度（`tv_usec`），通过 `NSEC_PER_USEC` 进行单位转换\n- 对于即将到期的定时器，返回 `TICK_NSEC`（1 微秒）作为剩余时间，避免返回 0 导致用户误判\n\n### 并发安全\n\n- 使用 `siglock` 自旋锁保护信号结构体中的定时器状态\n- ITIMER_REAL 的设置操作需要处理定时器可能正在执行的竞态条件，通过 `hrtimer_try_to_cancel()` 和重试机制确保安全\n- CPU 定时器操作在 `siglock` 保护下进行，确保线程组内的一致性\n\n### 兼容性支持\n\n- 提供 32 位兼容接口（`COMPAT_SYSCALL_DEFINE2`）\n- 支持 `alarm()` 系统调用（在 `__ARCH_WANT_SYS_ALARM` 定义时）\n- 处理 32 位系统上的时间值溢出问题（限制为 `INT_MAX`）\n\n## 4. 依赖关系\n\n### 头文件依赖\n\n- **`<linux/hrtimer.h>`**：高精度定时器框架，用于 ITIMER_REAL 实现\n- **`<linux/sched/cputime.h>`**：CPU 时间采样功能，用于虚拟和性能定时器\n- **`<linux/posix-timers.h>`**：POSIX 定时器相关定义\n- **`<linux/sched/signal.h>`**：信号处理和 `signal_struct` 结构定义\n- **`<linux/time.h>`**：时间转换和操作函数\n- **`<trace/events/timer.h>`**：定时器事件跟踪支持\n\n### 内核子系统依赖\n\n- **调度子系统**：通过 `current` 获取当前任务，使用 `thread_group_sample_cputime()` 采样 CPU 时间\n- **信号子系统**：通过 `kill_pid_info()` 发送信号，使用 `siglock` 进行同步\n- **高精度定时器子系统**：ITIMER_REAL 的底层实现依赖 hrtimer 框架\n- **安全子系统**：SELinux 相关的 `clear_itimer()` 函数\n\n## 5. 使用场景\n\n### 用户空间编程\n\n- **定时任务**：应用程序使用 `setitimer()` 设置周期性或一次性定时器\n- **超时控制**：网络编程中设置 I/O 操作超时\n- **性能监控**：使用 ITIMER_PROF 监控程序 CPU 使用情况\n- **简单定时**：使用 `alarm()` 系统调用设置简单的秒级定时器\n\n### 内核内部使用\n\n- **进程管理**：在进程退出或权限变更时清除定时器（SELinux 场景）\n- **信号处理**：定时器到期时向进程发送相应信号\n- **时间跟踪**：通过 tracepoint 记录定时器状态变化和到期事件\n- **兼容层**：为不同架构和位数提供统一的定时器接口\n\n### 系统调用路径\n\n- **`getitimer()`** → `do_getitimer()` → 对应定时器类型的具体获取函数\n- **`setitimer()`** → `do_setitimer()` → 对应定时器类型的具体设置函数  \n- **`alarm()`** → `alarm_setitimer()` → `do_setitimer(ITIMER_REAL, ...)`\n\n该文件是 Linux 内核 POSIX 定时器功能的重要组成部分，为用户空间提供了经典的 Unix 间隔定时器接口。",
      "similarity": 0.5459141135215759,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/itimer.c",
          "start_line": 29,
          "end_line": 129,
          "content": [
            "static struct timespec64 itimer_get_remtime(struct hrtimer *timer)",
            "{",
            "\tktime_t rem = __hrtimer_get_remaining(timer, true);",
            "",
            "\t/*",
            "\t * Racy but safe: if the itimer expires after the above",
            "\t * hrtimer_get_remtime() call but before this condition",
            "\t * then we return 0 - which is correct.",
            "\t */",
            "\tif (hrtimer_active(timer)) {",
            "\t\tif (rem <= 0)",
            "\t\t\trem = NSEC_PER_USEC;",
            "\t} else",
            "\t\trem = 0;",
            "",
            "\treturn ktime_to_timespec64(rem);",
            "}",
            "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   struct itimerspec64 *const value)",
            "{",
            "\tu64 val, interval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\tval = it->expires;",
            "\tinterval = it->incr;",
            "\tif (val) {",
            "\t\tu64 t, samples[CPUCLOCK_MAX];",
            "",
            "\t\tthread_group_sample_cputime(tsk, samples);",
            "\t\tt = samples[clock_id];",
            "",
            "\t\tif (val < t)",
            "\t\t\t/* about to fire */",
            "\t\t\tval = TICK_NSEC;",
            "\t\telse",
            "\t\t\tval -= t;",
            "\t}",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tvalue->it_value = ns_to_timespec64(val);",
            "\tvalue->it_interval = ns_to_timespec64(interval);",
            "}",
            "static int do_getitimer(int which, struct itimerspec64 *value)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);",
            "\t\tvalue->it_interval =",
            "\t\t\tktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn(-EINVAL);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int put_itimerval(struct __kernel_old_itimerval __user *o,",
            "\t\t\t const struct itimerspec64 *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tv.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v, sizeof(struct __kernel_old_itimerval)) ? -EFAULT : 0;",
            "}",
            "static int put_old_itimerval32(struct old_itimerval32 __user *o,",
            "\t\t\t       const struct itimerspec64 *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tv32.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv32.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv32.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv32.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v32, sizeof(struct old_itimerval32)) ? -EFAULT : 0;",
            "}",
            "enum hrtimer_restart it_real_fn(struct hrtimer *timer)",
            "{",
            "\tstruct signal_struct *sig =",
            "\t\tcontainer_of(timer, struct signal_struct, real_timer);",
            "\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];",
            "",
            "\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);",
            "\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}"
          ],
          "function_name": "itimer_get_remtime, get_cpu_itimer, do_getitimer, put_itimerval, put_old_itimerval32, it_real_fn",
          "description": "实现了itimer_get_remtime获取剩余时间、get_cpu_itimer读取CPU定时器信息、do_getitimer根据时钟类型获取定时器状态、put_itimerval/put_old_itimerval32转换并复制时间值到用户空间，以及it_real_fn作为实时时钟的超时处理函数",
          "similarity": 0.5389121174812317
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/itimer.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992 Darren Senn",
            " */",
            "",
            "/* These are all the functions necessary to implement itimers */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/time.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/hrtimer.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/compat.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "/**",
            " * itimer_get_remtime - get remaining time for the timer",
            " *",
            " * @timer: the timer to read",
            " *",
            " * Returns the delta between the expiry time and now, which can be",
            " * less than zero or 1usec for an pending expired timer",
            " */"
          ],
          "function_name": null,
          "description": "该代码块定义了itimer_get_remtime函数的原型，用于获取高精度定时器的剩余时间，通过计算当前时间与定时器到期时间的差值得到剩余时间，但未提供完整实现，上下文不完整",
          "similarity": 0.4817865788936615
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/itimer.c",
          "start_line": 168,
          "end_line": 275,
          "content": [
            "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   const struct itimerspec64 *const value,",
            "\t\t\t   struct itimerspec64 *const ovalue)",
            "{",
            "\tu64 oval, nval, ointerval, ninterval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tnval = timespec64_to_ns(&value->it_value);",
            "\tninterval = timespec64_to_ns(&value->it_interval);",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\toval = it->expires;",
            "\tointerval = it->incr;",
            "\tif (oval || nval) {",
            "\t\tif (nval > 0)",
            "\t\t\tnval += TICK_NSEC;",
            "\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);",
            "\t}",
            "\tit->expires = nval;",
            "\tit->incr = ninterval;",
            "\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?",
            "\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tif (ovalue) {",
            "\t\tovalue->it_value = ns_to_timespec64(oval);",
            "\t\tovalue->it_interval = ns_to_timespec64(ointerval);",
            "\t}",
            "}",
            "static int do_setitimer(int which, struct itimerspec64 *value,",
            "\t\t\tstruct itimerspec64 *ovalue)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct hrtimer *timer;",
            "\tktime_t expires;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "again:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\ttimer = &tsk->signal->real_timer;",
            "\t\tif (ovalue) {",
            "\t\t\tovalue->it_value = itimer_get_remtime(timer);",
            "\t\t\tovalue->it_interval",
            "\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\t}",
            "\t\t/* We are sharing ->siglock with it_real_fn() */",
            "\t\tif (hrtimer_try_to_cancel(timer) < 0) {",
            "\t\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\t\thrtimer_cancel_wait_running(timer);",
            "\t\t\tgoto again;",
            "\t\t}",
            "\t\texpires = timespec64_to_ktime(value->it_value);",
            "\t\tif (expires != 0) {",
            "\t\t\ttsk->signal->it_real_incr =",
            "\t\t\t\ttimespec64_to_ktime(value->it_interval);",
            "\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);",
            "\t\t} else",
            "\t\t\ttsk->signal->it_real_incr = 0;",
            "",
            "\t\ttrace_itimer_state(ITIMER_REAL, value, 0);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "void clear_itimer(void)",
            "{",
            "\tstruct itimerspec64 v = {};",
            "\tint i;",
            "",
            "\tfor (i = 0; i < 3; i++)",
            "\t\tdo_setitimer(i, &v, NULL);",
            "}",
            "static unsigned int alarm_setitimer(unsigned int seconds)",
            "{",
            "\tstruct itimerspec64 it_new, it_old;",
            "",
            "#if BITS_PER_LONG < 64",
            "\tif (seconds > INT_MAX)",
            "\t\tseconds = INT_MAX;",
            "#endif",
            "\tit_new.it_value.tv_sec = seconds;",
            "\tit_new.it_value.tv_nsec = 0;",
            "\tit_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;",
            "",
            "\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);",
            "",
            "\t/*",
            "\t * We can't return 0 if we have an alarm pending ...  And we'd",
            "\t * better return too much than too little anyway",
            "\t */",
            "\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||",
            "\t      it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))",
            "\t\tit_old.it_value.tv_sec++;",
            "",
            "\treturn it_old.it_value.tv_sec;",
            "}"
          ],
          "function_name": "set_cpu_itimer, do_setitimer, clear_itimer, alarm_setitimer",
          "description": "包含set_cpu_itimer设置CPU定时器参数、do_setitimer根据时钟类型配置定时器、clear_itimer清除所有定时器、alarm_setitimer设置一次性闹钟，其中do_setitimer处理实时时钟的启动和取消操作",
          "similarity": 0.48166048526763916
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/itimer.c",
          "start_line": 313,
          "end_line": 348,
          "content": [
            "static int get_itimerval(struct itimerspec64 *o, const struct __kernel_old_itimerval __user *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tif (copy_from_user(&v, i, sizeof(struct __kernel_old_itimerval)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value. */",
            "\tif (!timeval_valid(&v.it_value) ||",
            "\t    !timeval_valid(&v.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}",
            "static int get_old_itimerval32(struct itimerspec64 *o, const struct old_itimerval32 __user *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tif (copy_from_user(&v32, i, sizeof(struct old_itimerval32)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value.  */",
            "\tif (!timeval_valid(&v32.it_value) ||",
            "\t    !timeval_valid(&v32.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v32.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v32.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v32.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v32.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_itimerval, get_old_itimerval32",
          "description": "实现get_itimerval/get_old_itimerval32将用户态时间值转换为内核时间结构体，执行有效性校验，确保输入时间值在合法范围内",
          "similarity": 0.45806434750556946
        }
      ]
    }
  ]
}