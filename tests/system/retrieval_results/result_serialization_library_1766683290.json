{
  "query": "serialization library",
  "timestamp": "2025-12-26 01:21:30",
  "retrieved_files": [
    {
      "source_file": "kernel/rcu/refscale.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:42:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\refscale.c`\n\n---\n\n# `rcu/refscale.c` 技术文档\n\n## 1. 文件概述\n\n`rcu/refscale.c` 是 Linux 内核中用于**可扩展性基准测试**的模块，旨在比较不同同步机制（如 RCU、SRCU、引用计数、读写信号量、读写自旋锁等）在高并发读取场景下获取对象引用的性能表现。该模块通过模拟大量并发读取操作，测量不同机制在吞吐量、延迟和可扩展性方面的差异，为 RCU 及其他同步原语的优化提供数据支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct ref_scale_ops`**  \n  定义不同同步机制的操作接口，包含初始化、清理、读取段执行和延迟段执行等函数指针。\n  ```c\n  struct ref_scale_ops {\n      bool (*init)(void);\n      void (*cleanup)(void);\n      void (*readsection)(const int nloops);\n      void (*delaysection)(const int nloops, const int udl, const int ndl);\n      const char *name;\n  };\n  ```\n\n- **`struct reader_task`**  \n  表示每个读者线程的状态，包括任务结构、启动标志、等待队列和上次执行耗时。\n  ```c\n  struct reader_task {\n      struct task_struct *task;\n      int start_reader;\n      wait_queue_head_t wq;\n      u64 last_duration_ns;\n  };\n  ```\n\n### 主要函数\n\n- **`ref_rcu_read_section()` / `ref_rcu_delay_section()`**  \n  执行指定次数的 RCU 读临界区操作，后者在临界区内插入延迟。\n\n- **`srcu_ref_scale_read_section()` / `srcu_ref_scale_delay_section()`**  \n  针对 SRCU 的读操作测试函数。\n\n- **`ref_refcnt_section()` / `ref_refcnt_delay_section()`**  \n  使用原子引用计数（`atomic_inc/dec`）模拟引用获取/释放。\n\n- **`ref_rwlock_section()` / `ref_rwlock_delay_section()`**  \n  使用读写自旋锁（`rwlock_t`）进行读操作测试。\n\n- **`un_delay()`**  \n  根据参数执行微秒（`udelay`）或纳秒（`ndelay`）级延迟。\n\n- **`rcu_sync_scale_init()`**  \n  空初始化函数，适用于无需特殊初始化的机制（如 RCU、SRCU）。\n\n## 3. 关键实现\n\n### 测试机制选择\n通过 `scale_type` 模块参数动态选择测试的同步机制，支持：\n- `rcu`：经典 RCU\n- `srcu`：Sleepable RCU\n- `rcu-tasks`：基于任务的 RCU（需 `CONFIG_TASKS_RCU`）\n- `rcu-trace`：跟踪 RCU（需 `CONFIG_TASKS_TRACE_RCU`）\n- `refcnt`：原子引用计数\n- `rwlock`：读写自旋锁（代码片段未完整显示，但已定义）\n\n### 并发控制\n- 使用 `atomic_t` 变量（如 `nreaders_exp`, `n_init`）协调读者线程的启动、预热和冷却阶段。\n- 通过等待队列（`main_wq`, `shutdown_wq`）实现主线程与读者/关机线程的同步。\n\n### 日志输出控制\n- `VERBOSE_SCALEOUT`：条件性输出调试信息。\n- `VERBOSE_SCALEOUT_BATCH`：批量输出日志，避免高频打印影响性能测试结果。\n- `SCALEOUT_ERRSTRING`：高亮错误信息。\n\n### 延迟模拟\n通过 `readdelay` 参数在读临界区内插入纳秒级延迟（`udelay`/`ndelay`），模拟真实场景中的读操作耗时。\n\n### 实验配置\n- `nreaders`：读者线程数（默认为 CPU 数的 75%）。\n- `loops`：每轮实验的循环次数。\n- `nruns`：实验重复次数。\n- `holdoff`：启动前等待多 CPU 环境就绪的延迟时间。\n\n## 4. 依赖关系\n\n- **RCU 子系统**：依赖 `rcupdate.h`、`rcupdate_trace.h` 提供 RCU 及变体（SRCU、Tasks RCU）的 API。\n- **内核基础组件**：\n  - 原子操作（`atomic.h`）\n  - 内核线程（`kthread.h`）\n  - 等待队列（`wait.h`）\n  - 自旋锁/读写锁（`spinlock.h`）\n  - 内存管理（`slab.h`）\n- **测试框架**：使用 `torture.h` 提供的参数解析和测试基础设施。\n- **条件编译**：根据内核配置（如 `CONFIG_TASKS_RCU`）动态包含特定 RCU 变体的测试代码。\n\n## 5. 使用场景\n\n- **RCU 性能调优**：在开发新 RCU 变体或优化现有实现时，量化其可扩展性优势。\n- **同步原语选型**：为内核开发者提供不同同步机制在高并发读场景下的性能对比数据。\n- **回归测试**：确保内核修改不会降低 RCU 或其他机制的可扩展性。\n- **学术研究**：作为操作系统课程或并发算法研究的基准测试工具。\n\n> **注**：该模块通常作为内核测试模块（`CONFIG_RCU_REF_SCALE_TEST`）编译，不用于生产环境。",
      "similarity": 0.5215005278587341,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 477,
          "end_line": 607,
          "content": [
            "static void ref_acqrel_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tunsigned long x;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));",
            "\t\tun_delay(udl, ndl);",
            "\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_clock_section(const int nloops)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tx += ktime_get_real_fast_ns();",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static void ref_clock_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx += ktime_get_real_fast_ns();",
            "\t\tun_delay(udl, ndl);",
            "\t}",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static void ref_jiffies_section(const int nloops)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tx += jiffies;",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static void ref_jiffies_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx += jiffies;",
            "\t\tun_delay(udl, ndl);",
            "\t}",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static bool typesafe_ref_acquire(struct refscale_typesafe *rtsp, unsigned int *start)",
            "{",
            "\treturn atomic_inc_not_zero(&rtsp->rts_refctr);",
            "}",
            "static bool typesafe_ref_release(struct refscale_typesafe *rtsp, unsigned int start)",
            "{",
            "\tif (!atomic_dec_return(&rtsp->rts_refctr)) {",
            "\t\tWRITE_ONCE(rtsp->a, rtsp->a + 1);",
            "\t\tkmem_cache_free(typesafe_kmem_cachep, rtsp);",
            "\t}",
            "\treturn true;",
            "}",
            "static bool typesafe_lock_acquire(struct refscale_typesafe *rtsp, unsigned int *start)",
            "{",
            "\tspin_lock(&rtsp->rts_lock);",
            "\treturn true;",
            "}",
            "static bool typesafe_lock_release(struct refscale_typesafe *rtsp, unsigned int start)",
            "{",
            "\tspin_unlock(&rtsp->rts_lock);",
            "\treturn true;",
            "}",
            "static bool typesafe_seqlock_acquire(struct refscale_typesafe *rtsp, unsigned int *start)",
            "{",
            "\t*start = read_seqbegin(&rtsp->rts_seqlock);",
            "\treturn true;",
            "}",
            "static bool typesafe_seqlock_release(struct refscale_typesafe *rtsp, unsigned int start)",
            "{",
            "\treturn !read_seqretry(&rtsp->rts_seqlock, start);",
            "}",
            "static void typesafe_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tunsigned int a;",
            "\tunsigned int b;",
            "\tint i;",
            "\tlong idx;",
            "\tstruct refscale_typesafe *rtsp;",
            "\tunsigned int start;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tpreempt_disable();",
            "\t\tidx = torture_random(this_cpu_ptr(&refscale_rand)) % rtsarray_size;",
            "\t\tpreempt_enable();",
            "retry:",
            "\t\trcu_read_lock();",
            "\t\trtsp = rcu_dereference(rtsarray[idx]);",
            "\t\ta = READ_ONCE(rtsp->a);",
            "\t\tif (!rts_acquire(rtsp, &start)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\tif (a != READ_ONCE(rtsp->a)) {",
            "\t\t\t(void)rts_release(rtsp, start);",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\tun_delay(udl, ndl);",
            "\t\t// Remember, seqlock read-side release can fail.",
            "\t\tif (!rts_release(rtsp, start)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\tb = READ_ONCE(rtsp->a);",
            "\t\tWARN_ONCE(a != b, \"Re-read of ->a changed from %u to %u.\\n\", a, b);",
            "\t\tb = rtsp->b;",
            "\t\trcu_read_unlock();",
            "\t\tWARN_ON_ONCE(a * a != b);",
            "\t}",
            "}"
          ],
          "function_name": "ref_acqrel_delay_section, ref_clock_section, ref_clock_delay_section, ref_jiffies_section, ref_jiffies_delay_section, typesafe_ref_acquire, typesafe_ref_release, typesafe_lock_acquire, typesafe_lock_release, typesafe_seqlock_acquire, typesafe_seqlock_release, typesafe_delay_section",
          "description": "实现原子操作、时钟读取、Jiffies计数及类型安全引用的获取/释放逻辑，包含序列化锁和SeqLock的读操作验证流程。",
          "similarity": 0.542730450630188
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 1024,
          "end_line": 1162,
          "content": [
            "static void",
            "ref_scale_print_module_parms(struct ref_scale_ops *cur_ops, const char *tag)",
            "{",
            "\tpr_alert(\"%s\" SCALE_FLAG",
            "\t\t \"--- %s:  verbose=%d shutdown=%d holdoff=%d loops=%ld nreaders=%d nruns=%d readdelay=%d\\n\", scale_type, tag,",
            "\t\t verbose, shutdown, holdoff, loops, nreaders, nruns, readdelay);",
            "}",
            "static void",
            "ref_scale_cleanup(void)",
            "{",
            "\tint i;",
            "",
            "\tif (torture_cleanup_begin())",
            "\t\treturn;",
            "",
            "\tif (!cur_ops) {",
            "\t\ttorture_cleanup_end();",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (reader_tasks) {",
            "\t\tfor (i = 0; i < nreaders; i++)",
            "\t\t\ttorture_stop_kthread(\"ref_scale_reader\",",
            "\t\t\t\t\t     reader_tasks[i].task);",
            "\t}",
            "\tkfree(reader_tasks);",
            "",
            "\ttorture_stop_kthread(\"main_task\", main_task);",
            "\tkfree(main_task);",
            "",
            "\t// Do scale-type-specific cleanup operations.",
            "\tif (cur_ops->cleanup != NULL)",
            "\t\tcur_ops->cleanup();",
            "",
            "\ttorture_cleanup_end();",
            "}",
            "static int",
            "ref_scale_shutdown(void *arg)",
            "{",
            "\twait_event_idle(shutdown_wq, shutdown_start);",
            "",
            "\tsmp_mb(); // Wake before output.",
            "\tref_scale_cleanup();",
            "\tkernel_power_off();",
            "",
            "\treturn -EINVAL;",
            "}",
            "static int __init",
            "ref_scale_init(void)",
            "{",
            "\tlong i;",
            "\tint firsterr = 0;",
            "\tstatic struct ref_scale_ops *scale_ops[] = {",
            "\t\t&rcu_ops, &srcu_ops, RCU_TRACE_OPS RCU_TASKS_OPS &refcnt_ops, &rwlock_ops,",
            "\t\t&rwsem_ops, &lock_ops, &lock_irq_ops, &acqrel_ops, &clock_ops, &jiffies_ops,",
            "\t\t&typesafe_ref_ops, &typesafe_lock_ops, &typesafe_seqlock_ops,",
            "\t};",
            "",
            "\tif (!torture_init_begin(scale_type, verbose))",
            "\t\treturn -EBUSY;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++) {",
            "\t\tcur_ops = scale_ops[i];",
            "\t\tif (strcmp(scale_type, cur_ops->name) == 0)",
            "\t\t\tbreak;",
            "\t}",
            "\tif (i == ARRAY_SIZE(scale_ops)) {",
            "\t\tpr_alert(\"rcu-scale: invalid scale type: \\\"%s\\\"\\n\", scale_type);",
            "\t\tpr_alert(\"rcu-scale types:\");",
            "\t\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++)",
            "\t\t\tpr_cont(\" %s\", scale_ops[i]->name);",
            "\t\tpr_cont(\"\\n\");",
            "\t\tfirsterr = -EINVAL;",
            "\t\tcur_ops = NULL;",
            "\t\tgoto unwind;",
            "\t}",
            "\tif (cur_ops->init)",
            "\t\tif (!cur_ops->init()) {",
            "\t\t\tfirsterr = -EUCLEAN;",
            "\t\t\tgoto unwind;",
            "\t\t}",
            "",
            "\tref_scale_print_module_parms(cur_ops, \"Start of test\");",
            "",
            "\t// Shutdown task",
            "\tif (shutdown) {",
            "\t\tinit_waitqueue_head(&shutdown_wq);",
            "\t\tfirsterr = torture_create_kthread(ref_scale_shutdown, NULL,",
            "\t\t\t\t\t\t  shutdown_task);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t\tschedule_timeout_uninterruptible(1);",
            "\t}",
            "",
            "\t// Reader tasks (default to ~75% of online CPUs).",
            "\tif (nreaders < 0)",
            "\t\tnreaders = (num_online_cpus() >> 1) + (num_online_cpus() >> 2);",
            "\tif (WARN_ONCE(loops <= 0, \"%s: loops = %ld, adjusted to 1\\n\", __func__, loops))",
            "\t\tloops = 1;",
            "\tif (WARN_ONCE(nreaders <= 0, \"%s: nreaders = %d, adjusted to 1\\n\", __func__, nreaders))",
            "\t\tnreaders = 1;",
            "\tif (WARN_ONCE(nruns <= 0, \"%s: nruns = %d, adjusted to 1\\n\", __func__, nruns))",
            "\t\tnruns = 1;",
            "\treader_tasks = kcalloc(nreaders, sizeof(reader_tasks[0]),",
            "\t\t\t       GFP_KERNEL);",
            "\tif (!reader_tasks) {",
            "\t\tSCALEOUT_ERRSTRING(\"out of memory\");",
            "\t\tfirsterr = -ENOMEM;",
            "\t\tgoto unwind;",
            "\t}",
            "",
            "\tVERBOSE_SCALEOUT(\"Starting %d reader threads\", nreaders);",
            "",
            "\tfor (i = 0; i < nreaders; i++) {",
            "\t\tinit_waitqueue_head(&reader_tasks[i].wq);",
            "\t\tfirsterr = torture_create_kthread(ref_scale_reader, (void *)i,",
            "\t\t\t\t\t\t  reader_tasks[i].task);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "",
            "\t// Main Task",
            "\tinit_waitqueue_head(&main_wq);",
            "\tfirsterr = torture_create_kthread(main_func, NULL, main_task);",
            "\tif (torture_init_error(firsterr))",
            "\t\tgoto unwind;",
            "",
            "\ttorture_init_end();",
            "\treturn 0;",
            "",
            "unwind:",
            "\ttorture_init_end();",
            "\tref_scale_cleanup();",
            "\tif (shutdown) {",
            "\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_REF_SCALE_TEST));",
            "\t\tkernel_power_off();",
            "\t}",
            "\treturn firsterr;",
            "}"
          ],
          "function_name": "ref_scale_print_module_parms, ref_scale_cleanup, ref_scale_shutdown, ref_scale_init",
          "description": "process_durations 计算所有读者任务的持续时间总和并构建格式化输出字符串",
          "similarity": 0.5418238043785095
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 138,
          "end_line": 240,
          "content": [
            "static void un_delay(const int udl, const int ndl)",
            "{",
            "\tif (udl)",
            "\t\tudelay(udl);",
            "\tif (ndl)",
            "\t\tndelay(ndl);",
            "}",
            "static void ref_rcu_read_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock();",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static void ref_rcu_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock();",
            "\t\tun_delay(udl, ndl);",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static bool rcu_sync_scale_init(void)",
            "{",
            "\treturn true;",
            "}",
            "static void srcu_ref_scale_read_section(const int nloops)",
            "{",
            "\tint i;",
            "\tint idx;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tidx = srcu_read_lock(srcu_ctlp);",
            "\t\tsrcu_read_unlock(srcu_ctlp, idx);",
            "\t}",
            "}",
            "static void srcu_ref_scale_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "\tint idx;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tidx = srcu_read_lock(srcu_ctlp);",
            "\t\tun_delay(udl, ndl);",
            "\t\tsrcu_read_unlock(srcu_ctlp, idx);",
            "\t}",
            "}",
            "static void rcu_tasks_ref_scale_read_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tcontinue;",
            "}",
            "static void rcu_tasks_ref_scale_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tun_delay(udl, ndl);",
            "}",
            "static void rcu_trace_ref_scale_read_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock_trace();",
            "\t\trcu_read_unlock_trace();",
            "\t}",
            "}",
            "static void rcu_trace_ref_scale_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock_trace();",
            "\t\tun_delay(udl, ndl);",
            "\t\trcu_read_unlock_trace();",
            "\t}",
            "}",
            "static void ref_refcnt_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tatomic_inc(&refcnt);",
            "\t\tatomic_dec(&refcnt);",
            "\t}",
            "}",
            "static void ref_refcnt_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tatomic_inc(&refcnt);",
            "\t\tun_delay(udl, ndl);",
            "\t\tatomic_dec(&refcnt);",
            "\t}",
            "}"
          ],
          "function_name": "un_delay, ref_rcu_read_section, ref_rcu_delay_section, rcu_sync_scale_init, srcu_ref_scale_read_section, srcu_ref_scale_delay_section, rcu_tasks_ref_scale_read_section, rcu_tasks_ref_scale_delay_section, rcu_trace_ref_scale_read_section, rcu_trace_ref_scale_delay_section, ref_refcnt_section, ref_refcnt_delay_section",
          "description": "实现多种同步机制的读操作与延迟逻辑，通过RCU、SRCU、自旋锁、读写锁等机制进行并发访问测试，包含延迟注入和基础读操作循环。",
          "similarity": 0.4887247681617737
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 675,
          "end_line": 820,
          "content": [
            "static void typesafe_read_section(const int nloops)",
            "{",
            "\ttypesafe_delay_section(nloops, 0, 0);",
            "}",
            "static void refscale_typesafe_ctor(void *rtsp_in)",
            "{",
            "\tstruct refscale_typesafe *rtsp = rtsp_in;",
            "",
            "\tspin_lock_init(&rtsp->rts_lock);",
            "\tseqlock_init(&rtsp->rts_seqlock);",
            "\tpreempt_disable();",
            "\trtsp->a = torture_random(this_cpu_ptr(&refscale_rand));",
            "\tpreempt_enable();",
            "}",
            "static bool typesafe_init(void)",
            "{",
            "\tlong idx;",
            "\tlong si = lookup_instances;",
            "",
            "\ttypesafe_kmem_cachep = kmem_cache_create(\"refscale_typesafe\",",
            "\t\t\t\t\t\t sizeof(struct refscale_typesafe), sizeof(void *),",
            "\t\t\t\t\t\t SLAB_TYPESAFE_BY_RCU, refscale_typesafe_ctor);",
            "\tif (!typesafe_kmem_cachep)",
            "\t\treturn false;",
            "\tif (si < 0)",
            "\t\tsi = -si * nr_cpu_ids;",
            "\telse if (si == 0)",
            "\t\tsi = nr_cpu_ids;",
            "\trtsarray_size = si;",
            "\trtsarray = kcalloc(si, sizeof(*rtsarray), GFP_KERNEL);",
            "\tif (!rtsarray)",
            "\t\treturn false;",
            "\tfor (idx = 0; idx < rtsarray_size; idx++) {",
            "\t\trtsarray[idx] = typesafe_alloc_one();",
            "\t\tif (!rtsarray[idx])",
            "\t\t\treturn false;",
            "\t}",
            "\tif (cur_ops == &typesafe_ref_ops) {",
            "\t\trts_acquire = typesafe_ref_acquire;",
            "\t\trts_release = typesafe_ref_release;",
            "\t} else if (cur_ops == &typesafe_lock_ops) {",
            "\t\trts_acquire = typesafe_lock_acquire;",
            "\t\trts_release = typesafe_lock_release;",
            "\t} else if (cur_ops == &typesafe_seqlock_ops) {",
            "\t\trts_acquire = typesafe_seqlock_acquire;",
            "\t\trts_release = typesafe_seqlock_release;",
            "\t} else {",
            "\t\tWARN_ON_ONCE(1);",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void typesafe_cleanup(void)",
            "{",
            "\tlong idx;",
            "",
            "\tif (rtsarray) {",
            "\t\tfor (idx = 0; idx < rtsarray_size; idx++)",
            "\t\t\tkmem_cache_free(typesafe_kmem_cachep, rtsarray[idx]);",
            "\t\tkfree(rtsarray);",
            "\t\trtsarray = NULL;",
            "\t\trtsarray_size = 0;",
            "\t}",
            "\tkmem_cache_destroy(typesafe_kmem_cachep);",
            "\ttypesafe_kmem_cachep = NULL;",
            "\trts_acquire = NULL;",
            "\trts_release = NULL;",
            "}",
            "static void rcu_scale_one_reader(void)",
            "{",
            "\tif (readdelay <= 0)",
            "\t\tcur_ops->readsection(loops);",
            "\telse",
            "\t\tcur_ops->delaysection(loops, readdelay / 1000, readdelay % 1000);",
            "}",
            "static int",
            "ref_scale_reader(void *arg)",
            "{",
            "\tunsigned long flags;",
            "\tlong me = (long)arg;",
            "\tstruct reader_task *rt = &(reader_tasks[me]);",
            "\tu64 start;",
            "\ts64 duration;",
            "",
            "\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: task started\", me);",
            "\tWARN_ON_ONCE(set_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids)));",
            "\tset_user_nice(current, MAX_NICE);",
            "\tatomic_inc(&n_init);",
            "\tif (holdoff)",
            "\t\tschedule_timeout_interruptible(holdoff * HZ);",
            "repeat:",
            "\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: waiting to start next experiment on cpu %d\", me, raw_smp_processor_id());",
            "",
            "\t// Wait for signal that this reader can start.",
            "\twait_event(rt->wq, (atomic_read(&nreaders_exp) && smp_load_acquire(&rt->start_reader)) ||",
            "\t\t\t   torture_must_stop());",
            "",
            "\tif (torture_must_stop())",
            "\t\tgoto end;",
            "",
            "\t// Make sure that the CPU is affinitized appropriately during testing.",
            "\tWARN_ON_ONCE(raw_smp_processor_id() != me);",
            "",
            "\tWRITE_ONCE(rt->start_reader, 0);",
            "\tif (!atomic_dec_return(&n_started))",
            "\t\twhile (atomic_read_acquire(&n_started))",
            "\t\t\tcpu_relax();",
            "",
            "\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: experiment %d started\", me, exp_idx);",
            "",
            "",
            "\t// To reduce noise, do an initial cache-warming invocation, check",
            "\t// in, and then keep warming until everyone has checked in.",
            "\trcu_scale_one_reader();",
            "\tif (!atomic_dec_return(&n_warmedup))",
            "\t\twhile (atomic_read_acquire(&n_warmedup))",
            "\t\t\trcu_scale_one_reader();",
            "\t// Also keep interrupts disabled.  This also has the effect",
            "\t// of preventing entries into slow path for rcu_read_unlock().",
            "\tlocal_irq_save(flags);",
            "\tstart = ktime_get_mono_fast_ns();",
            "",
            "\trcu_scale_one_reader();",
            "",
            "\tduration = ktime_get_mono_fast_ns() - start;",
            "\tlocal_irq_restore(flags);",
            "",
            "\trt->last_duration_ns = WARN_ON_ONCE(duration < 0) ? 0 : duration;",
            "\t// To reduce runtime-skew noise, do maintain-load invocations until",
            "\t// everyone is done.",
            "\tif (!atomic_dec_return(&n_cooleddown))",
            "\t\twhile (atomic_read_acquire(&n_cooleddown))",
            "\t\t\trcu_scale_one_reader();",
            "",
            "\tif (atomic_dec_and_test(&nreaders_exp))",
            "\t\twake_up(&main_wq);",
            "",
            "\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: experiment %d ended, (readers remaining=%d)\",",
            "\t\t\t\tme, exp_idx, atomic_read(&nreaders_exp));",
            "",
            "\tif (!torture_must_stop())",
            "\t\tgoto repeat;",
            "end:",
            "\ttorture_kthread_stopping(\"ref_scale_reader\");",
            "\treturn 0;",
            "}"
          ],
          "function_name": "typesafe_read_section, refscale_typesafe_ctor, typesafe_init, typesafe_cleanup, rcu_scale_one_reader, ref_scale_reader",
          "description": "定义类型安全引用的读操作入口，初始化和清理类型安全对象池，实现多线程测试任务的启动与执行控制逻辑。",
          "similarity": 0.47993481159210205
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 321,
          "end_line": 428,
          "content": [
            "static bool ref_rwlock_init(void)",
            "{",
            "\trwlock_init(&test_rwlock);",
            "\treturn true;",
            "}",
            "static void ref_rwlock_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tread_lock(&test_rwlock);",
            "\t\tread_unlock(&test_rwlock);",
            "\t}",
            "}",
            "static void ref_rwlock_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tread_lock(&test_rwlock);",
            "\t\tun_delay(udl, ndl);",
            "\t\tread_unlock(&test_rwlock);",
            "\t}",
            "}",
            "static bool ref_rwsem_init(void)",
            "{",
            "\tinit_rwsem(&test_rwsem);",
            "\treturn true;",
            "}",
            "static void ref_rwsem_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tdown_read(&test_rwsem);",
            "\t\tup_read(&test_rwsem);",
            "\t}",
            "}",
            "static void ref_rwsem_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tdown_read(&test_rwsem);",
            "\t\tun_delay(udl, ndl);",
            "\t\tup_read(&test_rwsem);",
            "\t}",
            "}",
            "static void ref_lock_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock(&test_lock);",
            "\t\traw_spin_unlock(&test_lock);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_lock_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock(&test_lock);",
            "\t\tun_delay(udl, ndl);",
            "\t\traw_spin_unlock(&test_lock);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_lock_irq_section(const int nloops)",
            "{",
            "\tunsigned long flags;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock_irqsave(&test_lock, flags);",
            "\t\traw_spin_unlock_irqrestore(&test_lock, flags);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_lock_irq_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tunsigned long flags;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock_irqsave(&test_lock, flags);",
            "\t\tun_delay(udl, ndl);",
            "\t\traw_spin_unlock_irqrestore(&test_lock, flags);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_acqrel_section(const int nloops)",
            "{",
            "\tunsigned long x;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));",
            "\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);",
            "\t}",
            "\tpreempt_enable();",
            "}"
          ],
          "function_name": "ref_rwlock_init, ref_rwlock_section, ref_rwlock_delay_section, ref_rwsem_init, ref_rwsem_section, ref_rwsem_delay_section, ref_lock_section, ref_lock_delay_section, ref_lock_irq_section, ref_lock_irq_delay_section, ref_acqrel_section",
          "description": "提供基于读写锁、读写信号量、自旋锁等同步原语的测试函数，展示不同锁机制在高并发场景下的行为特征。",
          "similarity": 0.44655030965805054
        }
      ]
    },
    {
      "source_file": "kernel/trace/ring_buffer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:07:21\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\ring_buffer.c`\n\n---\n\n# `trace/ring_buffer.c` 技术文档\n\n## 1. 文件概述\n\n`trace/ring_buffer.c` 实现了 Linux 内核中通用的高性能环形缓冲区（ring buffer）机制，主要用于跟踪（tracing）子系统。该缓冲区支持多 CPU 并发写入、单读者或多读者无锁读取，并通过时间戳压缩、事件类型编码和页面交换等技术优化内存使用和性能。该实现是 ftrace、perf 和其他内核跟踪工具的核心基础设施。\n\n## 2. 核心功能\n\n### 主要函数\n- `ring_buffer_print_entry_header()`：输出环形缓冲区条目头部格式说明，用于调试或用户空间解析。\n- `ring_buffer_event_length()`：返回事件有效载荷（payload）的长度，对 TIME_EXTEND 类型自动跳过扩展头。\n- `rb_event_data()`（内联）：返回指向事件实际数据的指针，处理 TIME_EXTEND 和不同长度编码。\n- `rb_event_length()`：返回完整事件结构（含头部）的字节长度。\n- `rb_event_ts_length()`：返回 TIME_EXTEND 事件及其后续数据事件的总长度。\n- `rb_event_data_length()`：计算数据类型事件的总长度（含头部）。\n- `rb_null_event()` / `rb_event_set_padding()`：判断或设置空/填充事件。\n\n### 关键数据结构（隐含或引用）\n- `struct ring_buffer_event`：环形缓冲区中每个事件的通用头部结构。\n- `struct buffer_data_page`：每个 CPU 缓冲区页面的封装，包含数据和元数据。\n- 每 CPU 页面链表：每个 CPU 拥有独立的环形页面链，写者仅写本地 CPU 缓冲区。\n\n### 核心常量与宏\n- `RINGBUF_TYPE_PADDING`、`RINGBUF_TYPE_TIME_EXTEND`、`RINGBUF_TYPE_TIME_STAMP`、`RINGBUF_TYPE_DATA`：事件类型标识。\n- `RB_ALIGNMENT` / `RB_ARCH_ALIGNMENT`：数据对齐策略，根据架构是否支持 64 位对齐访问调整。\n- `RB_MAX_SMALL_DATA`：小数据事件的最大长度（基于 4 字节对齐和类型长度上限）。\n- `TS_MSB` / `ABS_TS_MASK`：用于处理 59 位时间戳的高位截断与恢复。\n\n## 3. 关键实现\n\n### 无锁读写架构\n- **写者**：每个 CPU 只能写入其对应的 per-CPU 缓冲区，通过原子操作和内存屏障保证写入一致性，无需全局锁。\n- **读者**：每个 per-CPU 缓冲区维护一个独立的“reader page”。当 reader page 被读完后，通过原子交换（未来使用 `cmpxchg`）将其与环形缓冲区中的一个页面互换。交换后，原 reader page 不再被写者访问，读者可安全地将其用于 splice、复制或释放。\n\n### 事件编码与压缩\n- 事件头部使用紧凑位域编码：\n  - `type_len`（5 位）：事件类型或小数据长度（≤31）。\n  - `time_delta`（27 位）：相对于前一事件的时间增量。\n  - `array`（32 位）：用于存储大长度值或事件数据。\n- **TIME_EXTEND 事件**：当时间增量超出 27 位或需要绝对时间戳时，插入一个 8 字节的 TIME_EXTEND 事件，后跟实际数据事件。\n- **数据长度编码**：\n  - 若 `type_len > 0` 且 ≤ `RINGBUF_TYPE_DATA_TYPE_LEN_MAX`，则数据长度 = `type_len * RB_ALIGNMENT`，数据从 `array[0]` 开始。\n  - 否则，数据长度存储在 `array[0]`，实际数据从 `array[1]` 开始。\n\n### 时间戳处理\n- 绝对时间戳仅保留低 59 位（`ABS_TS_MASK`），高 5 位（`TS_MSB`）若非零需单独保存并在读取时恢复，以支持长时间运行的跟踪。\n\n### 内存对齐优化\n- 在支持 64 位对齐访问的架构上（`CONFIG_HAVE_64BIT_ALIGNED_ACCESS`），强制 8 字节对齐（`RB_FORCE_8BYTE_ALIGNMENT`），提升访问性能；否则使用 4 字节对齐。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ring_buffer.h>`：定义公共 API 和数据结构。\n  - `<linux/trace_clock.h>`、`<linux/sched/clock.h>`：提供高精度时间戳源。\n  - `<linux/percpu.h>`：支持 per-CPU 缓冲区分配。\n  - `<linux/spinlock.h>`、`<asm/local.h>`：提供底层原子操作和锁原语。\n  - `<linux/trace_recursion.h>`：防止跟踪递归。\n- **子系统依赖**：\n  - **ftrace**：主要消费者，用于函数跟踪、事件跟踪等。\n  - **perf**：通过 ring buffer 获取性能事件数据。\n  - **Security Module**：通过 `<linux/security.h>` 集成 LSM 钩子（如 trace 访问控制）。\n- **架构依赖**：依赖 `CONFIG_HAVE_64BIT_ALIGNED_ACCESS` 配置项优化对齐策略。\n\n## 5. 使用场景\n\n- **内核跟踪（ftrace）**：记录函数调用、上下文切换、中断等事件，数据写入 per-CPU ring buffer，用户通过 `tracefs` 读取。\n- **性能分析（perf）**：perf 工具通过 ring buffer 接收内核采样事件（如 PMU 中断、软件事件）。\n- **实时监控与调试**：开发者或运维人员通过读取 ring buffer 内容分析系统行为、延迟或错误。\n- **自测试（selftest）**：文件包含自测试逻辑（依赖 `<linux/kthread.h>`），用于验证 ring buffer 功能正确性。\n- **低开销事件记录**：由于其无锁设计和压缩编码，适用于高频事件记录场景（如每秒百万级事件）。",
      "similarity": 0.5163071155548096,
      "chunks": [
        {
          "chunk_id": 27,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 6041,
          "end_line": 6232,
          "content": [
            "static __init int rb_test(void *arg)",
            "{",
            "\tstruct rb_test_data *data = arg;",
            "",
            "\twhile (!kthread_should_stop()) {",
            "\t\trb_write_something(data, false);",
            "\t\tdata->cnt++;",
            "",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\t/* Now sleep between a min of 100-300us and a max of 1ms */",
            "\t\tusleep_range(((data->cnt % 3) + 1) * 100, 1000);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static __init void rb_ipi(void *ignore)",
            "{",
            "\tstruct rb_test_data *data;",
            "\tint cpu = smp_processor_id();",
            "",
            "\tdata = &rb_data[cpu];",
            "\trb_write_something(data, true);",
            "}",
            "static __init int rb_hammer_test(void *arg)",
            "{",
            "\twhile (!kthread_should_stop()) {",
            "",
            "\t\t/* Send an IPI to all cpus to write data! */",
            "\t\tsmp_call_function(rb_ipi, NULL, 1);",
            "\t\t/* No sleep, but for non preempt, let others run */",
            "\t\tschedule();",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static __init int test_ringbuffer(void)",
            "{",
            "\tstruct task_struct *rb_hammer;",
            "\tstruct trace_buffer *buffer;",
            "\tint cpu;",
            "\tint ret = 0;",
            "",
            "\tif (security_locked_down(LOCKDOWN_TRACEFS)) {",
            "\t\tpr_warn(\"Lockdown is enabled, skipping ring buffer tests\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tpr_info(\"Running ring buffer tests...\\n\");",
            "",
            "\tbuffer = ring_buffer_alloc(RB_TEST_BUFFER_SIZE, RB_FL_OVERWRITE);",
            "\tif (WARN_ON(!buffer))",
            "\t\treturn 0;",
            "",
            "\t/* Disable buffer so that threads can't write to it yet */",
            "\tring_buffer_record_off(buffer);",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\trb_data[cpu].buffer = buffer;",
            "\t\trb_data[cpu].cpu = cpu;",
            "\t\trb_data[cpu].cnt = cpu;",
            "\t\trb_threads[cpu] = kthread_run_on_cpu(rb_test, &rb_data[cpu],",
            "\t\t\t\t\t\t     cpu, \"rbtester/%u\");",
            "\t\tif (WARN_ON(IS_ERR(rb_threads[cpu]))) {",
            "\t\t\tpr_cont(\"FAILED\\n\");",
            "\t\t\tret = PTR_ERR(rb_threads[cpu]);",
            "\t\t\tgoto out_free;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Now create the rb hammer! */",
            "\trb_hammer = kthread_run(rb_hammer_test, NULL, \"rbhammer\");",
            "\tif (WARN_ON(IS_ERR(rb_hammer))) {",
            "\t\tpr_cont(\"FAILED\\n\");",
            "\t\tret = PTR_ERR(rb_hammer);",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\tring_buffer_record_on(buffer);",
            "\t/*",
            "\t * Show buffer is enabled before setting rb_test_started.",
            "\t * Yes there's a small race window where events could be",
            "\t * dropped and the thread wont catch it. But when a ring",
            "\t * buffer gets enabled, there will always be some kind of",
            "\t * delay before other CPUs see it. Thus, we don't care about",
            "\t * those dropped events. We care about events dropped after",
            "\t * the threads see that the buffer is active.",
            "\t */",
            "\tsmp_wmb();",
            "\trb_test_started = true;",
            "",
            "\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t/* Just run for 10 seconds */;",
            "\tschedule_timeout(10 * HZ);",
            "",
            "\tkthread_stop(rb_hammer);",
            "",
            " out_free:",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tif (!rb_threads[cpu])",
            "\t\t\tbreak;",
            "\t\tkthread_stop(rb_threads[cpu]);",
            "\t}",
            "\tif (ret) {",
            "\t\tring_buffer_free(buffer);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/* Report! */",
            "\tpr_info(\"finished\\n\");",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct ring_buffer_event *event;",
            "\t\tstruct rb_test_data *data = &rb_data[cpu];",
            "\t\tstruct rb_item *item;",
            "\t\tunsigned long total_events;",
            "\t\tunsigned long total_dropped;",
            "\t\tunsigned long total_written;",
            "\t\tunsigned long total_alloc;",
            "\t\tunsigned long total_read = 0;",
            "\t\tunsigned long total_size = 0;",
            "\t\tunsigned long total_len = 0;",
            "\t\tunsigned long total_lost = 0;",
            "\t\tunsigned long lost;",
            "\t\tint big_event_size;",
            "\t\tint small_event_size;",
            "",
            "\t\tret = -1;",
            "",
            "\t\ttotal_events = data->events + data->events_nested;",
            "\t\ttotal_written = data->bytes_written + data->bytes_written_nested;",
            "\t\ttotal_alloc = data->bytes_alloc + data->bytes_alloc_nested;",
            "\t\ttotal_dropped = data->bytes_dropped + data->bytes_dropped_nested;",
            "",
            "\t\tbig_event_size = data->max_size + data->max_size_nested;",
            "\t\tsmall_event_size = data->min_size + data->min_size_nested;",
            "",
            "\t\tpr_info(\"CPU %d:\\n\", cpu);",
            "\t\tpr_info(\"              events:    %ld\\n\", total_events);",
            "\t\tpr_info(\"       dropped bytes:    %ld\\n\", total_dropped);",
            "\t\tpr_info(\"       alloced bytes:    %ld\\n\", total_alloc);",
            "\t\tpr_info(\"       written bytes:    %ld\\n\", total_written);",
            "\t\tpr_info(\"       biggest event:    %d\\n\", big_event_size);",
            "\t\tpr_info(\"      smallest event:    %d\\n\", small_event_size);",
            "",
            "\t\tif (RB_WARN_ON(buffer, total_dropped))",
            "\t\t\tbreak;",
            "",
            "\t\tret = 0;",
            "",
            "\t\twhile ((event = ring_buffer_consume(buffer, cpu, NULL, &lost))) {",
            "\t\t\ttotal_lost += lost;",
            "\t\t\titem = ring_buffer_event_data(event);",
            "\t\t\ttotal_len += ring_buffer_event_length(event);",
            "\t\t\ttotal_size += item->size + sizeof(struct rb_item);",
            "\t\t\tif (memcmp(&item->str[0], rb_string, item->size) != 0) {",
            "\t\t\t\tpr_info(\"FAILED!\\n\");",
            "\t\t\t\tpr_info(\"buffer had: %.*s\\n\", item->size, item->str);",
            "\t\t\t\tpr_info(\"expected:   %.*s\\n\", item->size, rb_string);",
            "\t\t\t\tRB_WARN_ON(buffer, 1);",
            "\t\t\t\tret = -1;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\ttotal_read++;",
            "\t\t}",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "",
            "\t\tret = -1;",
            "",
            "\t\tpr_info(\"         read events:   %ld\\n\", total_read);",
            "\t\tpr_info(\"         lost events:   %ld\\n\", total_lost);",
            "\t\tpr_info(\"        total events:   %ld\\n\", total_lost + total_read);",
            "\t\tpr_info(\"  recorded len bytes:   %ld\\n\", total_len);",
            "\t\tpr_info(\" recorded size bytes:   %ld\\n\", total_size);",
            "\t\tif (total_lost) {",
            "\t\t\tpr_info(\" With dropped events, record len and size may not match\\n\"",
            "\t\t\t\t\" alloced and written from above\\n\");",
            "\t\t} else {",
            "\t\t\tif (RB_WARN_ON(buffer, total_len != total_alloc ||",
            "\t\t\t\t       total_size != total_written))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (RB_WARN_ON(buffer, total_lost + total_read != total_events))",
            "\t\t\tbreak;",
            "",
            "\t\tret = 0;",
            "\t}",
            "\tif (!ret)",
            "\t\tpr_info(\"Ring buffer PASSED!\\n\");",
            "",
            "\tring_buffer_free(buffer);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "rb_test, rb_ipi, rb_hammer_test, test_ringbuffer",
          "description": "rb_test 循环执行写入操作并休眠；rb_ipi 通过IPI触发其他CPU写入；rb_hammer_test 连续发送IPI进行并发写入；test_ringbuffer 初始化缓冲区，启动测试线程，运行测试用例并验证数据完整性，统计事件数量、丢弃情况及数据一致性",
          "similarity": 0.4931585192680359
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 45,
          "end_line": 148,
          "content": [
            "int ring_buffer_print_entry_header(struct trace_seq *s)",
            "{",
            "\ttrace_seq_puts(s, \"# compressed entry header\\n\");",
            "\ttrace_seq_puts(s, \"\\ttype_len    :    5 bits\\n\");",
            "\ttrace_seq_puts(s, \"\\ttime_delta  :   27 bits\\n\");",
            "\ttrace_seq_puts(s, \"\\tarray       :   32 bits\\n\");",
            "\ttrace_seq_putc(s, '\\n');",
            "\ttrace_seq_printf(s, \"\\tpadding     : type == %d\\n\",",
            "\t\t\t RINGBUF_TYPE_PADDING);",
            "\ttrace_seq_printf(s, \"\\ttime_extend : type == %d\\n\",",
            "\t\t\t RINGBUF_TYPE_TIME_EXTEND);",
            "\ttrace_seq_printf(s, \"\\ttime_stamp : type == %d\\n\",",
            "\t\t\t RINGBUF_TYPE_TIME_STAMP);",
            "\ttrace_seq_printf(s, \"\\tdata max type_len  == %d\\n\",",
            "\t\t\t RINGBUF_TYPE_DATA_TYPE_LEN_MAX);",
            "",
            "\treturn !trace_seq_has_overflowed(s);",
            "}",
            "static inline bool rb_null_event(struct ring_buffer_event *event)",
            "{",
            "\treturn event->type_len == RINGBUF_TYPE_PADDING && !event->time_delta;",
            "}",
            "static void rb_event_set_padding(struct ring_buffer_event *event)",
            "{",
            "\t/* padding has a NULL time_delta */",
            "\tevent->type_len = RINGBUF_TYPE_PADDING;",
            "\tevent->time_delta = 0;",
            "}",
            "static unsigned",
            "rb_event_data_length(struct ring_buffer_event *event)",
            "{",
            "\tunsigned length;",
            "",
            "\tif (event->type_len)",
            "\t\tlength = event->type_len * RB_ALIGNMENT;",
            "\telse",
            "\t\tlength = event->array[0];",
            "\treturn length + RB_EVNT_HDR_SIZE;",
            "}",
            "static inline unsigned",
            "rb_event_length(struct ring_buffer_event *event)",
            "{",
            "\tswitch (event->type_len) {",
            "\tcase RINGBUF_TYPE_PADDING:",
            "\t\tif (rb_null_event(event))",
            "\t\t\t/* undefined */",
            "\t\t\treturn -1;",
            "\t\treturn  event->array[0] + RB_EVNT_HDR_SIZE;",
            "",
            "\tcase RINGBUF_TYPE_TIME_EXTEND:",
            "\t\treturn RB_LEN_TIME_EXTEND;",
            "",
            "\tcase RINGBUF_TYPE_TIME_STAMP:",
            "\t\treturn RB_LEN_TIME_STAMP;",
            "",
            "\tcase RINGBUF_TYPE_DATA:",
            "\t\treturn rb_event_data_length(event);",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t}",
            "\t/* not hit */",
            "\treturn 0;",
            "}",
            "static inline unsigned",
            "rb_event_ts_length(struct ring_buffer_event *event)",
            "{",
            "\tunsigned len = 0;",
            "",
            "\tif (extended_time(event)) {",
            "\t\t/* time extends include the data event after it */",
            "\t\tlen = RB_LEN_TIME_EXTEND;",
            "\t\tevent = skip_time_extend(event);",
            "\t}",
            "\treturn len + rb_event_length(event);",
            "}",
            "unsigned ring_buffer_event_length(struct ring_buffer_event *event)",
            "{",
            "\tunsigned length;",
            "",
            "\tif (extended_time(event))",
            "\t\tevent = skip_time_extend(event);",
            "",
            "\tlength = rb_event_length(event);",
            "\tif (event->type_len > RINGBUF_TYPE_DATA_TYPE_LEN_MAX)",
            "\t\treturn length;",
            "\tlength -= RB_EVNT_HDR_SIZE;",
            "\tif (length > RB_MAX_SMALL_DATA + sizeof(event->array[0]))",
            "                length -= sizeof(event->array[0]);",
            "\treturn length;",
            "}",
            "static u64 rb_event_time_stamp(struct ring_buffer_event *event)",
            "{",
            "\tu64 ts;",
            "",
            "\tts = event->array[0];",
            "\tts <<= TS_SHIFT;",
            "\tts += event->time_delta;",
            "",
            "\treturn ts;",
            "}",
            "static void rb_init_page(struct buffer_data_page *bpage)",
            "{",
            "\tlocal_set(&bpage->commit, 0);",
            "}"
          ],
          "function_name": "ring_buffer_print_entry_header, rb_null_event, rb_event_set_padding, rb_event_data_length, rb_event_length, rb_event_ts_length, ring_buffer_event_length, rb_event_time_stamp, rb_init_page",
          "description": "实现环形缓冲区事件解析功能，包括打印事件头信息、识别空事件、设置填充事件、计算不同事件类型的数据长度及时间戳，提供事件长度和时间戳读取接口",
          "similarity": 0.4916342794895172
        },
        {
          "chunk_id": 22,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 4955,
          "end_line": 5087,
          "content": [
            "static inline void",
            "rb_reader_unlock(struct ring_buffer_per_cpu *cpu_buffer, bool locked)",
            "{",
            "\tif (likely(locked))",
            "\t\traw_spin_unlock(&cpu_buffer->reader_lock);",
            "}",
            "bool ring_buffer_iter_dropped(struct ring_buffer_iter *iter)",
            "{",
            "\tbool ret = iter->missed_events != 0;",
            "",
            "\titer->missed_events = 0;",
            "\treturn ret;",
            "}",
            "void",
            "ring_buffer_read_prepare_sync(void)",
            "{",
            "\tsynchronize_rcu();",
            "}",
            "void",
            "ring_buffer_read_start(struct ring_buffer_iter *iter)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer;",
            "\tunsigned long flags;",
            "",
            "\tif (!iter)",
            "\t\treturn;",
            "",
            "\tcpu_buffer = iter->cpu_buffer;",
            "",
            "\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);",
            "\tarch_spin_lock(&cpu_buffer->lock);",
            "\trb_iter_reset(iter);",
            "\tarch_spin_unlock(&cpu_buffer->lock);",
            "\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);",
            "}",
            "void",
            "ring_buffer_read_finish(struct ring_buffer_iter *iter)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * Ring buffer is disabled from recording, here's a good place",
            "\t * to check the integrity of the ring buffer.",
            "\t * Must prevent readers from trying to read, as the check",
            "\t * clears the HEAD page and readers require it.",
            "\t */",
            "\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);",
            "\trb_check_pages(cpu_buffer);",
            "\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);",
            "",
            "\tatomic_dec(&cpu_buffer->resize_disabled);",
            "\tkfree(iter->event);",
            "\tkfree(iter);",
            "}",
            "void ring_buffer_iter_advance(struct ring_buffer_iter *iter)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);",
            "",
            "\trb_advance_iter(iter);",
            "",
            "\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);",
            "}",
            "unsigned long ring_buffer_size(struct trace_buffer *buffer, int cpu)",
            "{",
            "\t/*",
            "\t * Earlier, this method returned",
            "\t *\tBUF_PAGE_SIZE * buffer->nr_pages",
            "\t * Since the nr_pages field is now removed, we have converted this to",
            "\t * return the per cpu buffer value.",
            "\t */",
            "\tif (!cpumask_test_cpu(cpu, buffer->cpumask))",
            "\t\treturn 0;",
            "",
            "\treturn BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;",
            "}",
            "static void rb_clear_buffer_page(struct buffer_page *page)",
            "{",
            "\tlocal_set(&page->write, 0);",
            "\tlocal_set(&page->entries, 0);",
            "\trb_init_page(page->page);",
            "\tpage->read = 0;",
            "}",
            "static void",
            "rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer)",
            "{",
            "\tstruct buffer_page *page;",
            "",
            "\trb_head_page_deactivate(cpu_buffer);",
            "",
            "\tcpu_buffer->head_page",
            "\t\t= list_entry(cpu_buffer->pages, struct buffer_page, list);",
            "\trb_clear_buffer_page(cpu_buffer->head_page);",
            "\tlist_for_each_entry(page, cpu_buffer->pages, list) {",
            "\t\trb_clear_buffer_page(page);",
            "\t}",
            "",
            "\tcpu_buffer->tail_page = cpu_buffer->head_page;",
            "\tcpu_buffer->commit_page = cpu_buffer->head_page;",
            "",
            "\tINIT_LIST_HEAD(&cpu_buffer->reader_page->list);",
            "\tINIT_LIST_HEAD(&cpu_buffer->new_pages);",
            "\trb_clear_buffer_page(cpu_buffer->reader_page);",
            "",
            "\tlocal_set(&cpu_buffer->entries_bytes, 0);",
            "\tlocal_set(&cpu_buffer->overrun, 0);",
            "\tlocal_set(&cpu_buffer->commit_overrun, 0);",
            "\tlocal_set(&cpu_buffer->dropped_events, 0);",
            "\tlocal_set(&cpu_buffer->entries, 0);",
            "\tlocal_set(&cpu_buffer->committing, 0);",
            "\tlocal_set(&cpu_buffer->commits, 0);",
            "\tlocal_set(&cpu_buffer->pages_touched, 0);",
            "\tlocal_set(&cpu_buffer->pages_lost, 0);",
            "\tlocal_set(&cpu_buffer->pages_read, 0);",
            "\tcpu_buffer->last_pages_touch = 0;",
            "\tcpu_buffer->shortest_full = 0;",
            "\tcpu_buffer->read = 0;",
            "\tcpu_buffer->read_bytes = 0;",
            "",
            "\trb_time_set(&cpu_buffer->write_stamp, 0);",
            "\trb_time_set(&cpu_buffer->before_stamp, 0);",
            "",
            "\tmemset(cpu_buffer->event_stamp, 0, sizeof(cpu_buffer->event_stamp));",
            "",
            "\tcpu_buffer->lost_events = 0;",
            "\tcpu_buffer->last_overrun = 0;",
            "",
            "\trb_head_page_activate(cpu_buffer);",
            "\tcpu_buffer->pages_removed = 0;",
            "}"
          ],
          "function_name": "rb_reader_unlock, ring_buffer_iter_dropped, ring_buffer_read_prepare_sync, ring_buffer_read_start, ring_buffer_read_finish, ring_buffer_iter_advance, ring_buffer_size, rb_clear_buffer_page, rb_reset_cpu",
          "description": "该代码段实现环形缓冲区（ring buffer）的读取控制与状态管理。  \n其中 `rb_reader_unlock` 管理读锁释放，`ring_buffer_read_start` 和 `ring_buffer_read_finish` 负责读取前的锁同步与资源清理，`rb_reset_cpu` 用于重置指定 CPU 的缓冲区状态。  \n其他函数如 `ring_buffer_iter_advance` 推进迭代器位置，`ring_buffer_size` 计算缓冲区容量，`rb_clear_buffer_page` 清空页面数据，共同支撑事件追踪的并发安全与状态维护。",
          "similarity": 0.4851447343826294
        },
        {
          "chunk_id": 21,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 4511,
          "end_line": 4617,
          "content": [
            "static void",
            "rb_update_iter_read_stamp(struct ring_buffer_iter *iter,",
            "\t\t\t  struct ring_buffer_event *event)",
            "{",
            "\tu64 delta;",
            "",
            "\tswitch (event->type_len) {",
            "\tcase RINGBUF_TYPE_PADDING:",
            "\t\treturn;",
            "",
            "\tcase RINGBUF_TYPE_TIME_EXTEND:",
            "\t\tdelta = rb_event_time_stamp(event);",
            "\t\titer->read_stamp += delta;",
            "\t\treturn;",
            "",
            "\tcase RINGBUF_TYPE_TIME_STAMP:",
            "\t\tdelta = rb_event_time_stamp(event);",
            "\t\tdelta = rb_fix_abs_ts(delta, iter->read_stamp);",
            "\t\titer->read_stamp = delta;",
            "\t\treturn;",
            "",
            "\tcase RINGBUF_TYPE_DATA:",
            "\t\titer->read_stamp += event->time_delta;",
            "\t\treturn;",
            "",
            "\tdefault:",
            "\t\tRB_WARN_ON(iter->cpu_buffer, 1);",
            "\t}",
            "}",
            "static void rb_advance_reader(struct ring_buffer_per_cpu *cpu_buffer)",
            "{",
            "\tstruct ring_buffer_event *event;",
            "\tstruct buffer_page *reader;",
            "\tunsigned length;",
            "",
            "\treader = rb_get_reader_page(cpu_buffer);",
            "",
            "\t/* This function should not be called when buffer is empty */",
            "\tif (RB_WARN_ON(cpu_buffer, !reader))",
            "\t\treturn;",
            "",
            "\tevent = rb_reader_event(cpu_buffer);",
            "",
            "\tif (event->type_len <= RINGBUF_TYPE_DATA_TYPE_LEN_MAX)",
            "\t\tcpu_buffer->read++;",
            "",
            "\trb_update_read_stamp(cpu_buffer, event);",
            "",
            "\tlength = rb_event_length(event);",
            "\tcpu_buffer->reader_page->read += length;",
            "\tcpu_buffer->read_bytes += length;",
            "}",
            "static void rb_advance_iter(struct ring_buffer_iter *iter)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer;",
            "",
            "\tcpu_buffer = iter->cpu_buffer;",
            "",
            "\t/* If head == next_event then we need to jump to the next event */",
            "\tif (iter->head == iter->next_event) {",
            "\t\t/* If the event gets overwritten again, there's nothing to do */",
            "\t\tif (rb_iter_head_event(iter) == NULL)",
            "\t\t\treturn;",
            "\t}",
            "",
            "\titer->head = iter->next_event;",
            "",
            "\t/*",
            "\t * Check if we are at the end of the buffer.",
            "\t */",
            "\tif (iter->next_event >= rb_page_size(iter->head_page)) {",
            "\t\t/* discarded commits can make the page empty */",
            "\t\tif (iter->head_page == cpu_buffer->commit_page)",
            "\t\t\treturn;",
            "\t\trb_inc_iter(iter);",
            "\t\treturn;",
            "\t}",
            "",
            "\trb_update_iter_read_stamp(iter, iter->event);",
            "}",
            "static int rb_lost_events(struct ring_buffer_per_cpu *cpu_buffer)",
            "{",
            "\treturn cpu_buffer->lost_events;",
            "}",
            "static inline bool rb_reader_lock(struct ring_buffer_per_cpu *cpu_buffer)",
            "{",
            "\tif (likely(!in_nmi())) {",
            "\t\traw_spin_lock(&cpu_buffer->reader_lock);",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * If an NMI die dumps out the content of the ring buffer",
            "\t * trylock must be used to prevent a deadlock if the NMI",
            "\t * preempted a task that holds the ring buffer locks. If",
            "\t * we get the lock then all is fine, if not, then continue",
            "\t * to do the read, but this can corrupt the ring buffer,",
            "\t * so it must be permanently disabled from future writes.",
            "\t * Reading from NMI is a oneshot deal.",
            "\t */",
            "\tif (raw_spin_trylock(&cpu_buffer->reader_lock))",
            "\t\treturn true;",
            "",
            "\t/* Continue without locking, but disable the ring buffer */",
            "\tatomic_inc(&cpu_buffer->record_disabled);",
            "\treturn false;",
            "}"
          ],
          "function_name": "rb_update_iter_read_stamp, rb_advance_reader, rb_advance_iter, rb_lost_events, rb_reader_lock",
          "description": "该代码段实现了环形缓冲区（ring buffer）的读取逻辑，包含事件时间戳更新、读指针推进、迭代器状态管理和锁控制等功能。  \n`rb_update_iter_read_stamp` 根据事件类型动态调整迭代器的读取时间戳，确保时间序列一致性；`rb_advance_reader` 和 `rb_advance_iter` 共同推进读取位置并维护事件追踪状态。  \n`rb_lost_events` 提供丢失事件计数接口，`rb_reader_lock` 在 NMI 场景下通过尝试加锁避免死锁，保障多线程环境下的数据安全。",
          "similarity": 0.4800366759300232
        },
        {
          "chunk_id": 20,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 4388,
          "end_line": 4493,
          "content": [
            "static void rb_iter_reset(struct ring_buffer_iter *iter)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;",
            "",
            "\t/* Iterator usage is expected to have record disabled */",
            "\titer->head_page = cpu_buffer->reader_page;",
            "\titer->head = cpu_buffer->reader_page->read;",
            "\titer->next_event = iter->head;",
            "",
            "\titer->cache_reader_page = iter->head_page;",
            "\titer->cache_read = cpu_buffer->read;",
            "\titer->cache_pages_removed = cpu_buffer->pages_removed;",
            "",
            "\tif (iter->head) {",
            "\t\titer->read_stamp = cpu_buffer->read_stamp;",
            "\t\titer->page_stamp = cpu_buffer->reader_page->page->time_stamp;",
            "\t} else {",
            "\t\titer->read_stamp = iter->head_page->page->time_stamp;",
            "\t\titer->page_stamp = iter->read_stamp;",
            "\t}",
            "}",
            "void ring_buffer_iter_reset(struct ring_buffer_iter *iter)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer;",
            "\tunsigned long flags;",
            "",
            "\tif (!iter)",
            "\t\treturn;",
            "",
            "\tcpu_buffer = iter->cpu_buffer;",
            "",
            "\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);",
            "\trb_iter_reset(iter);",
            "\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);",
            "}",
            "int ring_buffer_iter_empty(struct ring_buffer_iter *iter)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer;",
            "\tstruct buffer_page *reader;",
            "\tstruct buffer_page *head_page;",
            "\tstruct buffer_page *commit_page;",
            "\tstruct buffer_page *curr_commit_page;",
            "\tunsigned commit;",
            "\tu64 curr_commit_ts;",
            "\tu64 commit_ts;",
            "",
            "\tcpu_buffer = iter->cpu_buffer;",
            "\treader = cpu_buffer->reader_page;",
            "\thead_page = cpu_buffer->head_page;",
            "\tcommit_page = READ_ONCE(cpu_buffer->commit_page);",
            "\tcommit_ts = commit_page->page->time_stamp;",
            "",
            "\t/*",
            "\t * When the writer goes across pages, it issues a cmpxchg which",
            "\t * is a mb(), which will synchronize with the rmb here.",
            "\t * (see rb_tail_page_update())",
            "\t */",
            "\tsmp_rmb();",
            "\tcommit = rb_page_commit(commit_page);",
            "\t/* We want to make sure that the commit page doesn't change */",
            "\tsmp_rmb();",
            "",
            "\t/* Make sure commit page didn't change */",
            "\tcurr_commit_page = READ_ONCE(cpu_buffer->commit_page);",
            "\tcurr_commit_ts = READ_ONCE(curr_commit_page->page->time_stamp);",
            "",
            "\t/* If the commit page changed, then there's more data */",
            "\tif (curr_commit_page != commit_page ||",
            "\t    curr_commit_ts != commit_ts)",
            "\t\treturn 0;",
            "",
            "\t/* Still racy, as it may return a false positive, but that's OK */",
            "\treturn ((iter->head_page == commit_page && iter->head >= commit) ||",
            "\t\t(iter->head_page == reader && commit_page == head_page &&",
            "\t\t head_page->read == commit &&",
            "\t\t iter->head == rb_page_commit(cpu_buffer->reader_page)));",
            "}",
            "static void",
            "rb_update_read_stamp(struct ring_buffer_per_cpu *cpu_buffer,",
            "\t\t     struct ring_buffer_event *event)",
            "{",
            "\tu64 delta;",
            "",
            "\tswitch (event->type_len) {",
            "\tcase RINGBUF_TYPE_PADDING:",
            "\t\treturn;",
            "",
            "\tcase RINGBUF_TYPE_TIME_EXTEND:",
            "\t\tdelta = rb_event_time_stamp(event);",
            "\t\tcpu_buffer->read_stamp += delta;",
            "\t\treturn;",
            "",
            "\tcase RINGBUF_TYPE_TIME_STAMP:",
            "\t\tdelta = rb_event_time_stamp(event);",
            "\t\tdelta = rb_fix_abs_ts(delta, cpu_buffer->read_stamp);",
            "\t\tcpu_buffer->read_stamp = delta;",
            "\t\treturn;",
            "",
            "\tcase RINGBUF_TYPE_DATA:",
            "\t\tcpu_buffer->read_stamp += event->time_delta;",
            "\t\treturn;",
            "",
            "\tdefault:",
            "\t\tRB_WARN_ON(cpu_buffer, 1);",
            "\t}",
            "}"
          ],
          "function_name": "rb_iter_reset, ring_buffer_iter_reset, ring_buffer_iter_empty, rb_update_read_stamp",
          "description": "该代码段主要管理环形缓冲区迭代器状态及时间戳更新机制。  \n`rb_iter_reset` 和 `ring_buffer_iter_reset` 用于安全重置迭代器状态，后者通过锁保护确保多线程环境下的一致性；`ring_buffer_iter_empty` 检测迭代器当前位置是否已到达缓冲区末尾；`rb_update_read_stamp` 根据事件类型动态调整读取时间戳以支持时间戳校准。  \n所有函数协同保障了在高并发场景下对环形缓冲区事件的精确追踪与状态同步。",
          "similarity": 0.47364771366119385
        }
      ]
    },
    {
      "source_file": "kernel/rcu/rcuscale.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:40:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\rcuscale.c`\n\n---\n\n# rcu/rcuscale.c 技术文档\n\n## 1. 文件概述\n\n`rcuscale.c` 是 Linux 内核中用于测试 **Read-Copy Update (RCU)** 机制可扩展性（scalability）的模块化压力测试工具。该文件通过创建多个读者线程和写者线程，模拟高并发读写负载，以评估不同 RCU 变体（如经典 RCU、SRCU、Tasks RCU 等）在多核系统下的性能表现和扩展能力。该测试主要用于内核开发和性能调优，属于 `torture` 测试框架的一部分。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct rcu_scale_ops`**  \n  定义了针对不同 RCU 类型的统一操作接口，包括初始化、清理、读锁/解锁、同步原语、异步回调等函数指针，支持 RCU、SRCU、Tasks RCU 等多种实现。\n\n- **全局控制变量**  \n  - `nrealreaders` / `nrealwriters`：实际创建的读者/写者线程数  \n  - `writer_tasks` / `reader_tasks`：线程任务结构数组  \n  - `writer_durations`：记录每个写者线程的延迟测量数据  \n  - `atomic_t` 计数器：用于同步线程启动与结束状态  \n  - `scale_type`：指定测试的 RCU 类型（如 \"rcu\"、\"srcu\"）\n\n- **模块参数（通过 `torture_param` 定义）**  \n  - `nreaders` / `nwriters`：读者/写者线程数量  \n  - `gp_async` / `gp_exp`：是否使用异步或加速（expedited）宽限期  \n  - `writer_holdoff`：写者间延迟控制  \n  - `kfree_rcu_test`：是否测试 `kfree_rcu()` 的可扩展性  \n  - `verbose`：是否启用详细日志输出\n\n### 主要函数\n\n- **RCU 操作封装函数**  \n  - `rcu_scale_read_lock()` / `rcu_scale_read_unlock()`：封装 `rcu_read_lock/unlock`  \n  - `srcu_scale_read_lock()` / `srcu_scale_read_unlock()`：封装 SRCU 读操作  \n  - `tasks_scale_read_lock()`：Tasks RCU 无操作占位实现\n\n- **初始化与清理函数**  \n  - `rcu_sync_scale_init()`：空初始化（用于经典 RCU）  \n  - `srcu_sync_scale_init()` / `srcu_sync_scale_cleanup()`：动态 SRCU 结构初始化与释放\n\n- **日志宏**  \n  - `SCALEOUT_STRING()` / `VERBOSE_SCALEOUT_STRING()` / `SCALEOUT_ERRSTRING()`：统一格式化测试输出\n\n## 3. 关键实现\n\n### 可扩展性测试架构\n\n- 采用 **策略模式**：通过 `rcu_scale_ops` 结构体抽象不同 RCU 类型的操作，实现测试逻辑与具体 RCU 实现解耦。\n- 支持 **混合负载模式**：根据 `nreaders` 和 `nwriters` 参数组合，可进行纯读、纯写或读写混合压力测试。\n- **异步宽限期支持**：通过 `gp_async` 参数启用 `call_rcu()` 异步回调，并限制最大并发请求数（`gp_async_max`），避免资源耗尽。\n- **延迟测量机制**：每个写者线程记录宽限期耗时（`writer_durations`），用于后续性能分析。\n\n### 特殊测试模式\n\n- **`kfree_rcu` 可扩展性测试**：通过分配不同大小对象并调用 `kfree_rcu()`（或模拟 `call_rcu()`），评估延迟释放机制在高负载下的表现。\n- **SRCU 动态实例支持**：提供静态（`srcu_ctl_scale`）和动态（`srcud`）两种 SRCU 实例，分别对应 `srcu` 和 `srcud` 测试类型。\n\n### 启动与关闭控制\n\n- **启动延迟**：通过 `holdoff` 参数在测试开始前等待系统稳定。\n- **自动关机**：若 `shutdown=1`（默认在 built-in 模式下启用），测试结束后触发系统关机，便于自动化测试流程。\n- **线程同步**：使用原子计数器和等待队列（`shutdown_wq`）确保所有测试线程正确启动和终止。\n\n## 4. 依赖关系\n\n- **内核子系统依赖**：\n  - `RCU 核心机制`：`<linux/rcupdate.h>`、`<linux/srcu.h>`、`<linux/rcupdate_trace.h>`\n  - `调度与线程管理`：`<linux/kthread.h>`、`<linux/sched.h>`\n  - `内存管理`：`<linux/slab.h>`、`<linux/vmalloc.h>`\n  - `同步原语`：`<linux/spinlock.h>`、`<linux/completion.h>`\n  - `CPU 热插拔`：`<linux/cpu.h>`\n  - `Torture 测试框架`：`<linux/torture.h>`\n\n- **配置依赖**：\n  - `CONFIG_TASKS_RCU`：启用 Tasks RCU 测试支持\n  - `CONFIG_SRCU`：SRCU 功能必需\n\n## 5. 使用场景\n\n- **内核 RCU 子系统开发**：验证 RCU 实现的可扩展性，特别是在大规模多核系统上的性能表现。\n- **性能回归测试**：在内核版本迭代中监控 RCU 相关性能变化。\n- **硬件平台评估**：测试不同 CPU 架构（如 x86、ARM64）下 RCU 的扩展效率。\n- **参数调优**：通过调整 `writer_holdoff`、`gp_async` 等参数，研究 RCU 行为对系统负载的响应。\n- **`kfree_rcu` 压力测试**：评估延迟内存释放机制在高频率分配/释放场景下的稳定性与延迟。",
      "similarity": 0.5150994062423706,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/rcu/rcuscale.c",
          "start_line": 154,
          "end_line": 265,
          "content": [
            "static int rcu_scale_read_lock(void) __acquires(RCU)",
            "{",
            "\trcu_read_lock();",
            "\treturn 0;",
            "}",
            "static void rcu_scale_read_unlock(int idx) __releases(RCU)",
            "{",
            "\trcu_read_unlock();",
            "}",
            "static unsigned long __maybe_unused rcu_no_completed(void)",
            "{",
            "\treturn 0;",
            "}",
            "static void rcu_sync_scale_init(void)",
            "{",
            "}",
            "static int srcu_scale_read_lock(void) __acquires(srcu_ctlp)",
            "{",
            "\treturn srcu_read_lock(srcu_ctlp);",
            "}",
            "static void srcu_scale_read_unlock(int idx) __releases(srcu_ctlp)",
            "{",
            "\tsrcu_read_unlock(srcu_ctlp, idx);",
            "}",
            "static unsigned long srcu_scale_completed(void)",
            "{",
            "\treturn srcu_batches_completed(srcu_ctlp);",
            "}",
            "static void srcu_call_rcu(struct rcu_head *head, rcu_callback_t func)",
            "{",
            "\tcall_srcu(srcu_ctlp, head, func);",
            "}",
            "static void srcu_rcu_barrier(void)",
            "{",
            "\tsrcu_barrier(srcu_ctlp);",
            "}",
            "static void srcu_scale_synchronize(void)",
            "{",
            "\tsynchronize_srcu(srcu_ctlp);",
            "}",
            "static void srcu_scale_synchronize_expedited(void)",
            "{",
            "\tsynchronize_srcu_expedited(srcu_ctlp);",
            "}",
            "static void srcu_sync_scale_init(void)",
            "{",
            "\tsrcu_ctlp = &srcud;",
            "\tinit_srcu_struct(srcu_ctlp);",
            "}",
            "static void srcu_sync_scale_cleanup(void)",
            "{",
            "\tcleanup_srcu_struct(srcu_ctlp);",
            "}",
            "static int tasks_scale_read_lock(void)",
            "{",
            "\treturn 0;",
            "}",
            "static void tasks_scale_read_unlock(int idx)",
            "{",
            "}",
            "static int tasks_rude_scale_read_lock(void)",
            "{",
            "\treturn 0;",
            "}",
            "static void tasks_rude_scale_read_unlock(int idx)",
            "{",
            "}",
            "static int tasks_trace_scale_read_lock(void)",
            "{",
            "\trcu_read_lock_trace();",
            "\treturn 0;",
            "}",
            "static void tasks_trace_scale_read_unlock(int idx)",
            "{",
            "\trcu_read_unlock_trace();",
            "}",
            "static unsigned long rcuscale_seq_diff(unsigned long new, unsigned long old)",
            "{",
            "\tif (!cur_ops->gp_diff)",
            "\t\treturn new - old;",
            "\treturn cur_ops->gp_diff(new, old);",
            "}",
            "static void rcu_scale_wait_shutdown(void)",
            "{",
            "\tcond_resched_tasks_rcu_qs();",
            "\tif (atomic_read(&n_rcu_scale_writer_finished) < nrealwriters)",
            "\t\treturn;",
            "\twhile (!torture_must_stop())",
            "\t\tschedule_timeout_uninterruptible(1);",
            "}",
            "static int",
            "rcu_scale_reader(void *arg)",
            "{",
            "\tunsigned long flags;",
            "\tint idx;",
            "\tlong me = (long)arg;",
            "",
            "\tVERBOSE_SCALEOUT_STRING(\"rcu_scale_reader task started\");",
            "\tset_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));",
            "\tset_user_nice(current, MAX_NICE);",
            "\tatomic_inc(&n_rcu_scale_reader_started);",
            "",
            "\tdo {",
            "\t\tlocal_irq_save(flags);",
            "\t\tidx = cur_ops->readlock();",
            "\t\tcur_ops->readunlock(idx);",
            "\t\tlocal_irq_restore(flags);",
            "\t\trcu_scale_wait_shutdown();",
            "\t} while (!torture_must_stop());",
            "\ttorture_kthread_stopping(\"rcu_scale_reader\");",
            "\treturn 0;",
            "}"
          ],
          "function_name": "rcu_scale_read_lock, rcu_scale_read_unlock, rcu_no_completed, rcu_sync_scale_init, srcu_scale_read_lock, srcu_scale_read_unlock, srcu_scale_completed, srcu_call_rcu, srcu_rcu_barrier, srcu_scale_synchronize, srcu_scale_synchronize_expedited, srcu_sync_scale_init, srcu_sync_scale_cleanup, tasks_scale_read_lock, tasks_scale_read_unlock, tasks_rude_scale_read_lock, tasks_rude_scale_read_unlock, tasks_trace_scale_read_lock, tasks_trace_scale_read_unlock, rcuscale_seq_diff, rcu_scale_wait_shutdown, rcu_scale_reader",
          "description": "实现针对不同RCU变种（如RCU、SRCU、Tasks RCU）的读锁、解锁、同步及回调处理函数，提供统一的接口抽象层。",
          "similarity": 0.5044659376144409
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/rcu/rcuscale.c",
          "start_line": 950,
          "end_line": 1057,
          "content": [
            "static int __init",
            "rcu_scale_init(void)",
            "{",
            "\tlong i;",
            "\tint firsterr = 0;",
            "\tstatic struct rcu_scale_ops *scale_ops[] = {",
            "\t\t&rcu_ops, &srcu_ops, &srcud_ops, TASKS_OPS TASKS_RUDE_OPS TASKS_TRACING_OPS",
            "\t};",
            "",
            "\tif (!torture_init_begin(scale_type, verbose))",
            "\t\treturn -EBUSY;",
            "",
            "\t/* Process args and announce that the scalability'er is on the job. */",
            "\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++) {",
            "\t\tcur_ops = scale_ops[i];",
            "\t\tif (strcmp(scale_type, cur_ops->name) == 0)",
            "\t\t\tbreak;",
            "\t}",
            "\tif (i == ARRAY_SIZE(scale_ops)) {",
            "\t\tpr_alert(\"rcu-scale: invalid scale type: \\\"%s\\\"\\n\", scale_type);",
            "\t\tpr_alert(\"rcu-scale types:\");",
            "\t\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++)",
            "\t\t\tpr_cont(\" %s\", scale_ops[i]->name);",
            "\t\tpr_cont(\"\\n\");",
            "\t\tfirsterr = -EINVAL;",
            "\t\tcur_ops = NULL;",
            "\t\tgoto unwind;",
            "\t}",
            "\tif (cur_ops->init)",
            "\t\tcur_ops->init();",
            "",
            "\tif (cur_ops->rso_gp_kthread) {",
            "\t\tkthread_tp = cur_ops->rso_gp_kthread();",
            "\t\tif (kthread_tp)",
            "\t\t\tkthread_stime = kthread_tp->stime;",
            "\t}",
            "\tif (kfree_rcu_test)",
            "\t\treturn kfree_scale_init();",
            "",
            "\tnrealwriters = compute_real(nwriters);",
            "\tnrealreaders = compute_real(nreaders);",
            "\tatomic_set(&n_rcu_scale_reader_started, 0);",
            "\tatomic_set(&n_rcu_scale_writer_started, 0);",
            "\tatomic_set(&n_rcu_scale_writer_finished, 0);",
            "\trcu_scale_print_module_parms(cur_ops, \"Start of test\");",
            "",
            "\t/* Start up the kthreads. */",
            "",
            "\tif (shutdown) {",
            "\t\tinit_waitqueue_head(&shutdown_wq);",
            "\t\tfirsterr = torture_create_kthread(rcu_scale_shutdown, NULL,",
            "\t\t\t\t\t\t  shutdown_task);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t\tschedule_timeout_uninterruptible(1);",
            "\t}",
            "\treader_tasks = kcalloc(nrealreaders, sizeof(reader_tasks[0]),",
            "\t\t\t       GFP_KERNEL);",
            "\tif (reader_tasks == NULL) {",
            "\t\tSCALEOUT_ERRSTRING(\"out of memory\");",
            "\t\tfirsterr = -ENOMEM;",
            "\t\tgoto unwind;",
            "\t}",
            "\tfor (i = 0; i < nrealreaders; i++) {",
            "\t\tfirsterr = torture_create_kthread(rcu_scale_reader, (void *)i,",
            "\t\t\t\t\t\t  reader_tasks[i]);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "\twhile (atomic_read(&n_rcu_scale_reader_started) < nrealreaders)",
            "\t\tschedule_timeout_uninterruptible(1);",
            "\twriter_tasks = kcalloc(nrealwriters, sizeof(reader_tasks[0]),",
            "\t\t\t       GFP_KERNEL);",
            "\twriter_durations = kcalloc(nrealwriters, sizeof(*writer_durations),",
            "\t\t\t\t   GFP_KERNEL);",
            "\twriter_n_durations =",
            "\t\tkcalloc(nrealwriters, sizeof(*writer_n_durations),",
            "\t\t\tGFP_KERNEL);",
            "\tif (!writer_tasks || !writer_durations || !writer_n_durations) {",
            "\t\tSCALEOUT_ERRSTRING(\"out of memory\");",
            "\t\tfirsterr = -ENOMEM;",
            "\t\tgoto unwind;",
            "\t}",
            "\tfor (i = 0; i < nrealwriters; i++) {",
            "\t\twriter_durations[i] =",
            "\t\t\tkcalloc(MAX_MEAS, sizeof(*writer_durations[i]),",
            "\t\t\t\tGFP_KERNEL);",
            "\t\tif (!writer_durations[i]) {",
            "\t\t\tfirsterr = -ENOMEM;",
            "\t\t\tgoto unwind;",
            "\t\t}",
            "\t\tfirsterr = torture_create_kthread(rcu_scale_writer, (void *)i,",
            "\t\t\t\t\t\t  writer_tasks[i]);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "\ttorture_init_end();",
            "\treturn 0;",
            "",
            "unwind:",
            "\ttorture_init_end();",
            "\trcu_scale_cleanup();",
            "\tif (shutdown) {",
            "\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_SCALE_TEST));",
            "\t\tkernel_power_off();",
            "\t}",
            "\treturn firsterr;",
            "}"
          ],
          "function_name": "rcu_scale_init",
          "description": "该代码块实现了RCU扩展测试的初始化逻辑，根据传入的scale类型选择对应的RCU操作集，分配并初始化测试所需的数据结构，创建读写线程，并设置.shutdown回调以支持测试结束时的系统关机操作。",
          "similarity": 0.49953988194465637
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/rcu/rcuscale.c",
          "start_line": 442,
          "end_line": 559,
          "content": [
            "static void rcu_scale_async_cb(struct rcu_head *rhp)",
            "{",
            "\tatomic_dec(this_cpu_ptr(&n_async_inflight));",
            "\tkfree(rhp);",
            "}",
            "static int",
            "rcu_scale_writer(void *arg)",
            "{",
            "\tint i = 0;",
            "\tint i_max;",
            "\tunsigned long jdone;",
            "\tlong me = (long)arg;",
            "\tstruct rcu_head *rhp = NULL;",
            "\tbool started = false, done = false, alldone = false;",
            "\tu64 t;",
            "\tDEFINE_TORTURE_RANDOM(tr);",
            "\tu64 *wdp;",
            "\tu64 *wdpp = writer_durations[me];",
            "",
            "\tVERBOSE_SCALEOUT_STRING(\"rcu_scale_writer task started\");",
            "\tWARN_ON(!wdpp);",
            "\tset_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));",
            "\tcurrent->flags |= PF_NO_SETAFFINITY;",
            "\tsched_set_fifo_low(current);",
            "",
            "\tif (holdoff)",
            "\t\tschedule_timeout_idle(holdoff * HZ);",
            "",
            "\t/*",
            "\t * Wait until rcu_end_inkernel_boot() is called for normal GP tests",
            "\t * so that RCU is not always expedited for normal GP tests.",
            "\t * The system_state test is approximate, but works well in practice.",
            "\t */",
            "\twhile (!gp_exp && system_state != SYSTEM_RUNNING)",
            "\t\tschedule_timeout_uninterruptible(1);",
            "",
            "\tt = ktime_get_mono_fast_ns();",
            "\tif (atomic_inc_return(&n_rcu_scale_writer_started) >= nrealwriters) {",
            "\t\tt_rcu_scale_writer_started = t;",
            "\t\tif (gp_exp) {",
            "\t\t\tb_rcu_gp_test_started =",
            "\t\t\t\tcur_ops->exp_completed() / 2;",
            "\t\t} else {",
            "\t\t\tb_rcu_gp_test_started = cur_ops->get_gp_seq();",
            "\t\t}",
            "\t}",
            "",
            "\tjdone = jiffies + minruntime * HZ;",
            "\tdo {",
            "\t\tif (writer_holdoff)",
            "\t\t\tudelay(writer_holdoff);",
            "\t\tif (writer_holdoff_jiffies)",
            "\t\t\tschedule_timeout_idle(torture_random(&tr) % writer_holdoff_jiffies + 1);",
            "\t\twdp = &wdpp[i];",
            "\t\t*wdp = ktime_get_mono_fast_ns();",
            "\t\tif (gp_async && !WARN_ON_ONCE(!cur_ops->async)) {",
            "retry:",
            "\t\t\tif (!rhp)",
            "\t\t\t\trhp = kmalloc(sizeof(*rhp), GFP_KERNEL);",
            "\t\t\tif (rhp && atomic_read(this_cpu_ptr(&n_async_inflight)) < gp_async_max) {",
            "\t\t\t\tatomic_inc(this_cpu_ptr(&n_async_inflight));",
            "\t\t\t\tcur_ops->async(rhp, rcu_scale_async_cb);",
            "\t\t\t\trhp = NULL;",
            "\t\t\t} else if (!kthread_should_stop()) {",
            "\t\t\t\tcur_ops->gp_barrier();",
            "\t\t\t\tgoto retry;",
            "\t\t\t} else {",
            "\t\t\t\tkfree(rhp); /* Because we are stopping. */",
            "\t\t\t}",
            "\t\t} else if (gp_exp) {",
            "\t\t\tcur_ops->exp_sync();",
            "\t\t} else {",
            "\t\t\tcur_ops->sync();",
            "\t\t}",
            "\t\tt = ktime_get_mono_fast_ns();",
            "\t\t*wdp = t - *wdp;",
            "\t\ti_max = i;",
            "\t\tif (!started &&",
            "\t\t    atomic_read(&n_rcu_scale_writer_started) >= nrealwriters)",
            "\t\t\tstarted = true;",
            "\t\tif (!done && i >= MIN_MEAS && time_after(jiffies, jdone)) {",
            "\t\t\tdone = true;",
            "\t\t\tsched_set_normal(current, 0);",
            "\t\t\tpr_alert(\"%s%s rcu_scale_writer %ld has %d measurements\\n\",",
            "\t\t\t\t scale_type, SCALE_FLAG, me, MIN_MEAS);",
            "\t\t\tif (atomic_inc_return(&n_rcu_scale_writer_finished) >=",
            "\t\t\t    nrealwriters) {",
            "\t\t\t\tschedule_timeout_interruptible(10);",
            "\t\t\t\trcu_ftrace_dump(DUMP_ALL);",
            "\t\t\t\tSCALEOUT_STRING(\"Test complete\");",
            "\t\t\t\tt_rcu_scale_writer_finished = t;",
            "\t\t\t\tif (gp_exp) {",
            "\t\t\t\t\tb_rcu_gp_test_finished =",
            "\t\t\t\t\t\tcur_ops->exp_completed() / 2;",
            "\t\t\t\t} else {",
            "\t\t\t\t\tb_rcu_gp_test_finished =",
            "\t\t\t\t\t\tcur_ops->get_gp_seq();",
            "\t\t\t\t}",
            "\t\t\t\tif (shutdown) {",
            "\t\t\t\t\tsmp_mb(); /* Assign before wake. */",
            "\t\t\t\t\twake_up(&shutdown_wq);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (done && !alldone &&",
            "\t\t    atomic_read(&n_rcu_scale_writer_finished) >= nrealwriters)",
            "\t\t\talldone = true;",
            "\t\tif (started && !alldone && i < MAX_MEAS - 1)",
            "\t\t\ti++;",
            "\t\trcu_scale_wait_shutdown();",
            "\t} while (!torture_must_stop());",
            "\tif (gp_async && cur_ops->async) {",
            "\t\tcur_ops->gp_barrier();",
            "\t}",
            "\twriter_n_durations[me] = i_max + 1;",
            "\ttorture_kthread_stopping(\"rcu_scale_writer\");",
            "\treturn 0;",
            "}"
          ],
          "function_name": "rcu_scale_async_cb, rcu_scale_writer",
          "description": "实现写线程逻辑，包含异步回调处理、同步屏障操作及性能计时，通过控制流分析评估RCU的并发性能特性。",
          "similarity": 0.4921535849571228
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/rcu/rcuscale.c",
          "start_line": 565,
          "end_line": 668,
          "content": [
            "static void",
            "rcu_scale_print_module_parms(struct rcu_scale_ops *cur_ops, const char *tag)",
            "{",
            "\tpr_alert(\"%s\" SCALE_FLAG",
            "\t\t \"--- %s: gp_async=%d gp_async_max=%d gp_exp=%d holdoff=%d minruntime=%d nreaders=%d nwriters=%d writer_holdoff=%d writer_holdoff_jiffies=%d verbose=%d shutdown=%d\\n\",",
            "\t\t scale_type, tag, gp_async, gp_async_max, gp_exp, holdoff, minruntime, nrealreaders, nrealwriters, writer_holdoff, writer_holdoff_jiffies, verbose, shutdown);",
            "}",
            "static int compute_real(int n)",
            "{",
            "\tint nr;",
            "",
            "\tif (n >= 0) {",
            "\t\tnr = n;",
            "\t} else {",
            "\t\tnr = num_online_cpus() + 1 + n;",
            "\t\tif (nr <= 0)",
            "\t\t\tnr = 1;",
            "\t}",
            "\treturn nr;",
            "}",
            "static void kfree_call_rcu(struct rcu_head *rh)",
            "{",
            "\tstruct kfree_obj *obj = container_of(rh, struct kfree_obj, rh);",
            "",
            "\tkfree(obj);",
            "}",
            "static int",
            "kfree_scale_thread(void *arg)",
            "{",
            "\tint i, loop = 0;",
            "\tlong me = (long)arg;",
            "\tstruct kfree_obj *alloc_ptr;",
            "\tu64 start_time, end_time;",
            "\tlong long mem_begin, mem_during = 0;",
            "\tbool kfree_rcu_test_both;",
            "\tDEFINE_TORTURE_RANDOM(tr);",
            "",
            "\tVERBOSE_SCALEOUT_STRING(\"kfree_scale_thread task started\");",
            "\tset_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));",
            "\tset_user_nice(current, MAX_NICE);",
            "\tkfree_rcu_test_both = (kfree_rcu_test_single == kfree_rcu_test_double);",
            "",
            "\tstart_time = ktime_get_mono_fast_ns();",
            "",
            "\tif (atomic_inc_return(&n_kfree_scale_thread_started) >= kfree_nrealthreads) {",
            "\t\tif (gp_exp)",
            "\t\t\tb_rcu_gp_test_started = cur_ops->exp_completed() / 2;",
            "\t\telse",
            "\t\t\tb_rcu_gp_test_started = cur_ops->get_gp_seq();",
            "\t}",
            "",
            "\tdo {",
            "\t\tif (!mem_during) {",
            "\t\t\tmem_during = mem_begin = si_mem_available();",
            "\t\t} else if (loop % (kfree_loops / 4) == 0) {",
            "\t\t\tmem_during = (mem_during + si_mem_available()) / 2;",
            "\t\t}",
            "",
            "\t\tfor (i = 0; i < kfree_alloc_num; i++) {",
            "\t\t\talloc_ptr = kmalloc(kfree_mult * sizeof(struct kfree_obj), GFP_KERNEL);",
            "\t\t\tif (!alloc_ptr)",
            "\t\t\t\treturn -ENOMEM;",
            "",
            "\t\t\tif (kfree_by_call_rcu) {",
            "\t\t\t\tcall_rcu(&(alloc_ptr->rh), kfree_call_rcu);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\t// By default kfree_rcu_test_single and kfree_rcu_test_double are",
            "\t\t\t// initialized to false. If both have the same value (false or true)",
            "\t\t\t// both are randomly tested, otherwise only the one with value true",
            "\t\t\t// is tested.",
            "\t\t\tif ((kfree_rcu_test_single && !kfree_rcu_test_double) ||",
            "\t\t\t\t\t(kfree_rcu_test_both && torture_random(&tr) & 0x800))",
            "\t\t\t\tkfree_rcu_mightsleep(alloc_ptr);",
            "\t\t\telse",
            "\t\t\t\tkfree_rcu(alloc_ptr, rh);",
            "\t\t}",
            "",
            "\t\tcond_resched();",
            "\t} while (!torture_must_stop() && ++loop < kfree_loops);",
            "",
            "\tif (atomic_inc_return(&n_kfree_scale_thread_ended) >= kfree_nrealthreads) {",
            "\t\tend_time = ktime_get_mono_fast_ns();",
            "",
            "\t\tif (gp_exp)",
            "\t\t\tb_rcu_gp_test_finished = cur_ops->exp_completed() / 2;",
            "\t\telse",
            "\t\t\tb_rcu_gp_test_finished = cur_ops->get_gp_seq();",
            "",
            "\t\tpr_alert(\"Total time taken by all kfree'ers: %llu ns, loops: %d, batches: %ld, memory footprint: %lldMB\\n\",",
            "\t\t       (unsigned long long)(end_time - start_time), kfree_loops,",
            "\t\t       rcuscale_seq_diff(b_rcu_gp_test_finished, b_rcu_gp_test_started),",
            "\t\t       (mem_begin - mem_during) >> (20 - PAGE_SHIFT));",
            "",
            "\t\tif (shutdown) {",
            "\t\t\tsmp_mb(); /* Assign before wake. */",
            "\t\t\twake_up(&shutdown_wq);",
            "\t\t}",
            "\t}",
            "",
            "\ttorture_kthread_stopping(\"kfree_scale_thread\");",
            "\treturn 0;",
            "}"
          ],
          "function_name": "rcu_scale_print_module_parms, compute_real, kfree_call_rcu, kfree_scale_thread",
          "description": "实现基于kfree_rcu的内存压力测试，包含对象分配释放逻辑、内存占用监测及RCU批次序列号差异计算，用于评估内存回收延迟。",
          "similarity": 0.4803118109703064
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/rcu/rcuscale.c",
          "start_line": 836,
          "end_line": 943,
          "content": [
            "static void",
            "rcu_scale_cleanup(void)",
            "{",
            "\tint i;",
            "\tint j;",
            "\tint ngps = 0;",
            "\tu64 *wdp;",
            "\tu64 *wdpp;",
            "",
            "\t/*",
            "\t * Would like warning at start, but everything is expedited",
            "\t * during the mid-boot phase, so have to wait till the end.",
            "\t */",
            "\tif (rcu_gp_is_expedited() && !rcu_gp_is_normal() && !gp_exp)",
            "\t\tSCALEOUT_ERRSTRING(\"All grace periods expedited, no normal ones to measure!\");",
            "\tif (rcu_gp_is_normal() && gp_exp)",
            "\t\tSCALEOUT_ERRSTRING(\"All grace periods normal, no expedited ones to measure!\");",
            "\tif (gp_exp && gp_async)",
            "\t\tSCALEOUT_ERRSTRING(\"No expedited async GPs, so went with async!\");",
            "",
            "\t// If built-in, just report all of the GP kthread's CPU time.",
            "\tif (IS_BUILTIN(CONFIG_RCU_SCALE_TEST) && !kthread_tp && cur_ops->rso_gp_kthread)",
            "\t\tkthread_tp = cur_ops->rso_gp_kthread();",
            "\tif (kthread_tp) {",
            "\t\tu32 ns;",
            "\t\tu64 us;",
            "",
            "\t\tkthread_stime = kthread_tp->stime - kthread_stime;",
            "\t\tus = div_u64_rem(kthread_stime, 1000, &ns);",
            "\t\tpr_info(\"rcu_scale: Grace-period kthread CPU time: %llu.%03u us\\n\", us, ns);",
            "\t\tshow_rcu_gp_kthreads();",
            "\t}",
            "\tif (kfree_rcu_test) {",
            "\t\tkfree_scale_cleanup();",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (torture_cleanup_begin())",
            "\t\treturn;",
            "\tif (!cur_ops) {",
            "\t\ttorture_cleanup_end();",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (reader_tasks) {",
            "\t\tfor (i = 0; i < nrealreaders; i++)",
            "\t\t\ttorture_stop_kthread(rcu_scale_reader,",
            "\t\t\t\t\t     reader_tasks[i]);",
            "\t\tkfree(reader_tasks);",
            "\t}",
            "",
            "\tif (writer_tasks) {",
            "\t\tfor (i = 0; i < nrealwriters; i++) {",
            "\t\t\ttorture_stop_kthread(rcu_scale_writer,",
            "\t\t\t\t\t     writer_tasks[i]);",
            "\t\t\tif (!writer_n_durations)",
            "\t\t\t\tcontinue;",
            "\t\t\tj = writer_n_durations[i];",
            "\t\t\tpr_alert(\"%s%s writer %d gps: %d\\n\",",
            "\t\t\t\t scale_type, SCALE_FLAG, i, j);",
            "\t\t\tngps += j;",
            "\t\t}",
            "\t\tpr_alert(\"%s%s start: %llu end: %llu duration: %llu gps: %d batches: %ld\\n\",",
            "\t\t\t scale_type, SCALE_FLAG,",
            "\t\t\t t_rcu_scale_writer_started, t_rcu_scale_writer_finished,",
            "\t\t\t t_rcu_scale_writer_finished -",
            "\t\t\t t_rcu_scale_writer_started,",
            "\t\t\t ngps,",
            "\t\t\t rcuscale_seq_diff(b_rcu_gp_test_finished,",
            "\t\t\t\t\t   b_rcu_gp_test_started));",
            "\t\tfor (i = 0; i < nrealwriters; i++) {",
            "\t\t\tif (!writer_durations)",
            "\t\t\t\tbreak;",
            "\t\t\tif (!writer_n_durations)",
            "\t\t\t\tcontinue;",
            "\t\t\twdpp = writer_durations[i];",
            "\t\t\tif (!wdpp)",
            "\t\t\t\tcontinue;",
            "\t\t\tfor (j = 0; j < writer_n_durations[i]; j++) {",
            "\t\t\t\twdp = &wdpp[j];",
            "\t\t\t\tpr_alert(\"%s%s %4d writer-duration: %5d %llu\\n\",",
            "\t\t\t\t\tscale_type, SCALE_FLAG,",
            "\t\t\t\t\ti, j, *wdp);",
            "\t\t\t\tif (j % 100 == 0)",
            "\t\t\t\t\tschedule_timeout_uninterruptible(1);",
            "\t\t\t}",
            "\t\t\tkfree(writer_durations[i]);",
            "\t\t}",
            "\t\tkfree(writer_tasks);",
            "\t\tkfree(writer_durations);",
            "\t\tkfree(writer_n_durations);",
            "\t}",
            "",
            "\t/* Do torture-type-specific cleanup operations.  */",
            "\tif (cur_ops->cleanup != NULL)",
            "\t\tcur_ops->cleanup();",
            "",
            "\ttorture_cleanup_end();",
            "}",
            "static int",
            "rcu_scale_shutdown(void *arg)",
            "{",
            "\twait_event_idle(shutdown_wq, atomic_read(&n_rcu_scale_writer_finished) >= nrealwriters);",
            "\tsmp_mb(); /* Wake before output. */",
            "\trcu_scale_cleanup();",
            "\tkernel_power_off();",
            "\treturn -EINVAL;",
            "}"
          ],
          "function_name": "rcu_scale_cleanup, rcu_scale_shutdown",
          "description": "该代码块实现了RCU扩展测试的清理逻辑，用于终止所有测试线程、释放内存资源，并统计和输出测试结果。包含对grace period状态的验证、kthread CPU时间记录、异步/正常grace period的检测，以及针对不同测试类型的特定清理操作。",
          "similarity": 0.4608811140060425
        }
      ]
    }
  ]
}