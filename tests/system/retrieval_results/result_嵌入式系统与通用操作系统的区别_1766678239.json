{
  "query": "嵌入式系统与通用操作系统的区别",
  "timestamp": "2025-12-25 23:57:19",
  "retrieved_files": [
    {
      "source_file": "kernel/entry/common.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:19:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\common.c`\n\n---\n\n# entry\\common.c 技术文档\n\n## 文件概述\n\n`entry\\common.c` 是 Linux 内核中处理系统调用入口/出口以及中断入口/出口路径的通用逻辑实现文件。该文件提供了一套架构无关的通用函数，用于在用户态与内核态之间切换时执行必要的上下文跟踪、审计、跟踪点、安全检查（如 seccomp）、信号处理、调度等工作。其目标是统一不同架构在系统调用和中断处理路径上的共性逻辑，减少重复代码。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `syscall_trace_enter()` | 系统调用进入时的通用处理函数，依次处理用户态分发、ptrace 跟踪、seccomp 安全检查、tracepoint 和审计 |\n| `syscall_enter_from_user_mode_prepare()` | 从用户模式进入系统调用前的准备，启用中断并进入内核上下文 |\n| `exit_to_user_mode_loop()` | 在返回用户空间前循环处理所有待办工作项（如调度、信号、uprobe、livepatch 等） |\n| `syscall_exit_work()` | 系统调用退出时的通用处理，包括审计、tracepoint、ptrace 退出报告等 |\n| `irqentry_enter()` / `irqentry_exit()` | 中断入口/出口的通用处理，管理 RCU、上下文跟踪、KMSAN、lockdep 等 |\n| `irqentry_enter_from_user_mode()` / `irqentry_exit_to_user_mode()` | 从中断上下文进入/退出用户模式的专用路径 |\n| `raw_irqentry_exit_cond_resched()` | 中断退出时的条件调度检查（仅在非抢占计数为 0 时） |\n\n### 关键数据结构\n\n- `irqentry_state_t`：记录中断入口状态，主要用于判断是否需要在退出时执行 RCU 相关操作。\n- `SYSCALL_WORK_*` 和 `_TIF_*` 标志位：用于标识待处理的工作类型（如 trace、seccomp、信号、调度等）。\n\n## 关键实现\n\n### 系统调用入口处理流程（`syscall_trace_enter`）\n\n1. **Syscall User Dispatch 优先处理**：若设置了 `SYSCALL_WORK_SYSCALL_USER_DISPATCH`，调用 `syscall_user_dispatch()`，若返回 true 则直接终止系统调用（返回 `-1`），因为此时 ABI 可能无效。\n2. **Ptrace 跟踪**：若设置了 `SYSCALL_WORK_SYSCALL_TRACE` 或 `SYSCALL_WORK_SYSCALL_EMU`，调用 `ptrace_report_syscall_entry()`。若 tracer 修改了行为或启用了 `SYSCALL_EMU`，则终止系统调用。\n3. **Seccomp 安全检查**：在 ptrace 之后执行，以捕获 tracer 可能引入的变更。调用 `__secure_computing()`，若返回 `-1` 则拒绝系统调用。\n4. **重新获取系统调用号**：上述步骤可能修改了系统调用号，需重新通过 `syscall_get_nr()` 获取。\n5. **Tracepoint 触发**：若启用 `SYSCALL_WORK_SYSCALL_TRACEPOINT`，触发 `trace_sys_enter`，并再次重新获取系统调用号（因 BPF 或 kprobe 可能修改）。\n6. **审计日志**：调用 `syscall_enter_audit()` 记录审计事件。\n7. **返回最终系统调用号或错误码**。\n\n### 返回用户空间前的工作循环（`exit_to_user_mode_loop`）\n\n- 使用 `while (ti_work & EXIT_TO_USER_MODE_WORK)` 循环处理所有待办工作，确保在返回用户态前完成：\n  - 调度（`_TIF_NEED_RESCHED`）\n  - Uprobe 通知（`_TIF_UPROBE`）\n  - Livepatch 状态更新（`_TIF_PATCH_PENDING`）\n  - 信号处理（`_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL`）\n  - 用户态恢复工作（`_TIF_NOTIFY_RESUME`）\n  - 架构特定工作（`arch_exit_to_user_mode_work`）\n- 每次循环启用中断（`local_irq_enable_exit_to_user`），处理完后再关闭中断并重新读取线程标志（`read_thread_flags()`），以应对处理过程中新产生的工作项。\n- 最后调用 `tick_nohz_user_enter_prepare()` 处理 NO_HZ 模式下的 tick 准备。\n\n### 中断入口/出口的 RCU 与上下文管理\n\n- **从中断进入用户态**：调用 `enter_from_user_mode()`，启用中断。\n- **从内核态中断入口**：\n  - 若当前是 idle 任务且非 `TINY_RCU`，无条件调用 `ct_irq_enter()` 以确保 RCU 状态一致（避免嵌套中断导致 grace period 错误结束）。\n  - 否则调用 `rcu_irq_enter_check_tick()`。\n- 所有路径均正确处理 `lockdep`、`KMSAN`（解除寄存器毒化）和 `trace_hardirqs_off` 的顺序，确保调试和安全工具正常工作。\n\n### 条件调度支持（Preemption）\n\n- `raw_irqentry_exit_cond_resched()` 在中断退出且 `preempt_count() == 0` 时检查是否需要调度。\n- 支持动态抢占（`CONFIG_PREEMPT_DYNAMIC`），通过 `static_call` 或 `static_key` 实现运行时切换，避免编译时硬编码。\n\n## 依赖关系\n\n### 头文件依赖\n- `<linux/context_tracking.h>`：上下文跟踪（用户/内核态切换）\n- `<linux/resume_user_mode.h>`：用户态恢复工作\n- `<linux/seccomp.h>`（隐式通过 `__secure_computing`）：系统调用过滤\n- `<linux/audit.h>`：审计子系统\n- `<linux/ptrace.h>`（隐式）：ptrace 跟踪\n- `<linux/livepatch.h>`：内核热补丁\n- `<linux/uprobes.h>`（隐式）：用户态探针\n- `<linux/rcupdate.h>`：RCU 机制\n- `<linux/kmsan.h>`：Kernel Memory Sanitizer 支持\n- `<trace/events/syscalls.h>`：系统调用跟踪点\n\n### 架构依赖\n- 依赖架构特定实现：\n  - `syscall_get_arguments()` / `syscall_get_nr()` / `syscall_get_return_value()`\n  - `user_mode()` / `regs_irqs_disabled()`\n  - `arch_do_signal_or_restart()`（弱符号，默认空实现）\n  - `arch_exit_to_user_mode_work()`\n\n### 子系统交互\n- **RCU**：管理中断和用户态切换时的宽限期\n- **Scheduler**：处理 `need_resched()` 和 `schedule()`\n- **Security**：seccomp、audit\n- **Tracing**：ftrace、kprobe、uprobe、BPF\n- **Livepatch**：动态补丁状态更新\n\n## 使用场景\n\n1. **系统调用入口路径**：  \n   当用户程序执行 `syscall` 指令（或其他系统调用机制）进入内核时，架构代码调用 `syscall_trace_enter()` 执行通用预处理。\n\n2. **系统调用出口路径**：  \n   系统调用返回前，若存在待处理工作（如审计、tracepoint），调用 `syscall_exit_work()`。\n\n3. **中断处理返回用户空间**：  \n   中断处理完成后，若返回用户态，调用 `irqentry_exit_to_user_mode()`，进而触发 `exit_to_user_mode_loop()` 处理所有 pending work。\n\n4. **中断嵌套与 idle 任务处理**：  \n   在 idle 任务中发生中断时，确保 RCU 正确进入 IRQ 上下文，防止 grace period 错误终止。\n\n5. **动态抢占支持**：  \n   在支持动态抢占的系统中，中断退出时根据运行时配置决定是否执行条件调度。\n\n6. **调试与安全工具集成**：  \n   为 KMSAN、Lockdep、ftrace、audit、seccomp 等子系统提供统一的入口/出口钩子，确保工具链在系统调用和中断路径上正常工作。",
      "similarity": 0.5686904191970825,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/common.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/context_tracking.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/highmem.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmsan.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/audit.h>",
            "#include <linux/tick.h>",
            "",
            "#include \"common.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/syscalls.h>",
            ""
          ],
          "function_name": null,
          "description": "声明系统调用通用功能所需头文件，包含审计、跟踪、KMSAN、LivePatch等模块的接口定义，为后续系统调用入口处理提供基础依赖",
          "similarity": 0.501313328742981
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/common.c",
          "start_line": 18,
          "end_line": 124,
          "content": [
            "static inline void syscall_enter_audit(struct pt_regs *regs, long syscall)",
            "{",
            "\tif (unlikely(audit_context())) {",
            "\t\tunsigned long args[6];",
            "",
            "\t\tsyscall_get_arguments(current, regs, args);",
            "\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);",
            "\t}",
            "}",
            "long syscall_trace_enter(struct pt_regs *regs, long syscall,",
            "\t\t\t\tunsigned long work)",
            "{",
            "\tlong ret = 0;",
            "",
            "\t/*",
            "\t * Handle Syscall User Dispatch.  This must comes first, since",
            "\t * the ABI here can be something that doesn't make sense for",
            "\t * other syscall_work features.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (syscall_user_dispatch(regs))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Handle ptrace */",
            "\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {",
            "\t\tret = ptrace_report_syscall_entry(regs);",
            "\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))",
            "\t\t\treturn -1L;",
            "\t}",
            "",
            "\t/* Do seccomp after ptrace, to catch any tracer changes. */",
            "\tif (work & SYSCALL_WORK_SECCOMP) {",
            "\t\tret = __secure_computing(NULL);",
            "\t\tif (ret == -1L)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/* Either of the above might have changed the syscall number */",
            "\tsyscall = syscall_get_nr(current, regs);",
            "",
            "\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT)) {",
            "\t\ttrace_sys_enter(regs, syscall);",
            "\t\t/*",
            "\t\t * Probes or BPF hooks in the tracepoint may have changed the",
            "\t\t * system call number as well.",
            "\t\t */",
            "\t\tsyscall = syscall_get_nr(current, regs);",
            "\t}",
            "",
            "\tsyscall_enter_audit(regs, syscall);",
            "",
            "\treturn ret ? : syscall;",
            "}",
            "noinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "\tinstrumentation_begin();",
            "\tlocal_irq_enable();",
            "\tinstrumentation_end();",
            "}",
            "void __weak arch_do_signal_or_restart(struct pt_regs *regs) { }",
            "__always_inline unsigned long exit_to_user_mode_loop(struct pt_regs *regs,",
            "\t\t\t\t\t\t     unsigned long ti_work)",
            "{",
            "\t/*",
            "\t * Before returning to user space ensure that all pending work",
            "\t * items have been completed.",
            "\t */",
            "\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {",
            "",
            "\t\tlocal_irq_enable_exit_to_user(ti_work);",
            "",
            "\t\tif (ti_work & _TIF_NEED_RESCHED)",
            "\t\t\tschedule();",
            "",
            "\t\tif (ti_work & _TIF_UPROBE)",
            "\t\t\tuprobe_notify_resume(regs);",
            "",
            "\t\tif (ti_work & _TIF_PATCH_PENDING)",
            "\t\t\tklp_update_patch_state(current);",
            "",
            "\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))",
            "\t\t\tarch_do_signal_or_restart(regs);",
            "",
            "\t\tif (ti_work & _TIF_NOTIFY_RESUME)",
            "\t\t\tresume_user_mode_work(regs);",
            "",
            "\t\t/* Architecture specific TIF work */",
            "\t\tarch_exit_to_user_mode_work(regs, ti_work);",
            "",
            "\t\t/*",
            "\t\t * Disable interrupts and reevaluate the work flags as they",
            "\t\t * might have changed while interrupts and preemption was",
            "\t\t * enabled above.",
            "\t\t */",
            "\t\tlocal_irq_disable_exit_to_user();",
            "",
            "\t\t/* Check if any of the above work has queued a deferred wakeup */",
            "\t\ttick_nohz_user_enter_prepare();",
            "",
            "\t\tti_work = read_thread_flags();",
            "\t}",
            "",
            "\t/* Return the latest work state for arch_exit_to_user_mode() */",
            "\treturn ti_work;",
            "}"
          ],
          "function_name": "syscall_enter_audit, syscall_trace_enter, syscall_enter_from_user_mode_prepare, arch_do_signal_or_restart, exit_to_user_mode_loop",
          "description": "实现系统调用入口处理逻辑，依次处理审计追踪、指针观察、seccomp过滤及架构特定工作，通过位掩码控制不同安全机制的触发顺序并更新系统调用号",
          "similarity": 0.48611053824424744
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/entry/common.c",
          "start_line": 256,
          "end_line": 347,
          "content": [
            "void raw_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!preempt_count()) {",
            "\t\t/* Sanity check RCU and thread stack */",
            "\t\trcu_irq_exit_check_preempt();",
            "\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))",
            "\t\t\tWARN_ON_ONCE(!on_thread_stack());",
            "\t\tif (need_resched())",
            "\t\t\tpreempt_schedule_irq();",
            "\t}",
            "}",
            "void dynamic_irqentry_exit_cond_resched(void)",
            "{",
            "\tif (!static_branch_unlikely(&sk_dynamic_irqentry_exit_cond_resched))",
            "\t\treturn;",
            "\traw_irqentry_exit_cond_resched();",
            "}",
            "noinstr void irqentry_exit(struct pt_regs *regs, irqentry_state_t state)",
            "{",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\t/* Check whether this returns to user mode */",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_exit_to_user_mode(regs);",
            "\t} else if (!regs_irqs_disabled(regs)) {",
            "\t\t/*",
            "\t\t * If RCU was not watching on entry this needs to be done",
            "\t\t * carefully and needs the same ordering of lockdep/tracing",
            "\t\t * and RCU as the return to user mode path.",
            "\t\t */",
            "\t\tif (state.exit_rcu) {",
            "\t\t\tinstrumentation_begin();",
            "\t\t\t/* Tell the tracer that IRET will enable interrupts */",
            "\t\t\ttrace_hardirqs_on_prepare();",
            "\t\t\tlockdep_hardirqs_on_prepare();",
            "\t\t\tinstrumentation_end();",
            "\t\t\tct_irq_exit();",
            "\t\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tinstrumentation_begin();",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPTION))",
            "\t\t\tirqentry_exit_cond_resched();",
            "",
            "\t\t/* Covers both tracing and lockdep */",
            "\t\ttrace_hardirqs_on();",
            "\t\tinstrumentation_end();",
            "\t} else {",
            "\t\t/*",
            "\t\t * IRQ flags state is correct already. Just tell RCU if it",
            "\t\t * was not watching on entry.",
            "\t\t */",
            "\t\tif (state.exit_rcu)",
            "\t\t\tct_irq_exit();",
            "\t}",
            "}",
            "irqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t irq_state;",
            "",
            "\tirq_state.lockdep = lockdep_hardirqs_enabled();",
            "",
            "\t__nmi_enter();",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tlockdep_hardirq_enter();",
            "\tct_nmi_enter();",
            "",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\ttrace_hardirqs_off_finish();",
            "\tftrace_nmi_enter();",
            "\tinstrumentation_end();",
            "",
            "\treturn irq_state;",
            "}",
            "void noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state)",
            "{",
            "\tinstrumentation_begin();",
            "\tftrace_nmi_exit();",
            "\tif (irq_state.lockdep) {",
            "\t\ttrace_hardirqs_on_prepare();",
            "\t\tlockdep_hardirqs_on_prepare();",
            "\t}",
            "\tinstrumentation_end();",
            "",
            "\tct_nmi_exit();",
            "\tlockdep_hardirq_exit();",
            "\tif (irq_state.lockdep)",
            "\t\tlockdep_hardirqs_on(CALLER_ADDR0);",
            "\t__nmi_exit();",
            "}"
          ],
          "function_name": "raw_irqentry_exit_cond_resched, dynamic_irqentry_exit_cond_resched, irqentry_exit, irqentry_nmi_enter, irqentry_nmi_exit",
          "description": "实现中断退出路径的条件调度检查和NMI上下文切换，维护中断标志状态一致性，处理RCU状态转换、锁依赖标记恢复及异常中断返回时的上下文还原",
          "similarity": 0.4279177188873291
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/common.c",
          "start_line": 141,
          "end_line": 250,
          "content": [
            "static inline bool report_single_step(unsigned long work)",
            "{",
            "\tif (work & SYSCALL_WORK_SYSCALL_EMU)",
            "\t\treturn false;",
            "",
            "\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;",
            "}",
            "void syscall_exit_work(struct pt_regs *regs, unsigned long work)",
            "{",
            "\tbool step;",
            "",
            "\t/*",
            "\t * If the syscall was rolled back due to syscall user dispatching,",
            "\t * then the tracers below are not invoked for the same reason as",
            "\t * the entry side was not invoked in syscall_trace_enter(): The ABI",
            "\t * of these syscalls is unknown.",
            "\t */",
            "\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {",
            "\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {",
            "\t\t\tcurrent->syscall_dispatch.on_dispatch = false;",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\taudit_syscall_exit(regs);",
            "",
            "\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)",
            "\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));",
            "",
            "\tstep = report_single_step(work);",
            "\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)",
            "\t\tptrace_report_syscall_exit(regs, step);",
            "}",
            "noinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)",
            "{",
            "\tenter_from_user_mode(regs);",
            "}",
            "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)",
            "{",
            "\tinstrumentation_begin();",
            "\texit_to_user_mode_prepare(regs);",
            "\tinstrumentation_end();",
            "\texit_to_user_mode();",
            "}",
            "noinstr irqentry_state_t irqentry_enter(struct pt_regs *regs)",
            "{",
            "\tirqentry_state_t ret = {",
            "\t\t.exit_rcu = false,",
            "\t};",
            "",
            "\tif (user_mode(regs)) {",
            "\t\tirqentry_enter_from_user_mode(regs);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If this entry hit the idle task invoke ct_irq_enter() whether",
            "\t * RCU is watching or not.",
            "\t *",
            "\t * Interrupts can nest when the first interrupt invokes softirq",
            "\t * processing on return which enables interrupts.",
            "\t *",
            "\t * Scheduler ticks in the idle task can mark quiescent state and",
            "\t * terminate a grace period, if and only if the timer interrupt is",
            "\t * not nested into another interrupt.",
            "\t *",
            "\t * Checking for rcu_is_watching() here would prevent the nesting",
            "\t * interrupt to invoke ct_irq_enter(). If that nested interrupt is",
            "\t * the tick then rcu_flavor_sched_clock_irq() would wrongfully",
            "\t * assume that it is the first interrupt and eventually claim",
            "\t * quiescent state and end grace periods prematurely.",
            "\t *",
            "\t * Unconditionally invoke ct_irq_enter() so RCU state stays",
            "\t * consistent.",
            "\t *",
            "\t * TINY_RCU does not support EQS, so let the compiler eliminate",
            "\t * this part when enabled.",
            "\t */",
            "\tif (!IS_ENABLED(CONFIG_TINY_RCU) && is_idle_task(current)) {",
            "\t\t/*",
            "\t\t * If RCU is not watching then the same careful",
            "\t\t * sequence vs. lockdep and tracing is required",
            "\t\t * as in irqentry_enter_from_user_mode().",
            "\t\t */",
            "\t\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\t\tct_irq_enter();",
            "\t\tinstrumentation_begin();",
            "\t\tkmsan_unpoison_entry_regs(regs);",
            "\t\ttrace_hardirqs_off_finish();",
            "\t\tinstrumentation_end();",
            "",
            "\t\tret.exit_rcu = true;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * If RCU is watching then RCU only wants to check whether it needs",
            "\t * to restart the tick in NOHZ mode. rcu_irq_enter_check_tick()",
            "\t * already contains a warning when RCU is not watching, so no point",
            "\t * in having another one here.",
            "\t */",
            "\tlockdep_hardirqs_off(CALLER_ADDR0);",
            "\tinstrumentation_begin();",
            "\tkmsan_unpoison_entry_regs(regs);",
            "\trcu_irq_enter_check_tick();",
            "\ttrace_hardirqs_off_finish();",
            "\tinstrumentation_end();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "report_single_step, syscall_exit_work, irqentry_enter_from_user_mode, irqentry_exit_to_user_mode, irqentry_enter",
          "description": "处理系统调用退出阶段工作，包括审计退出记录、单步调试报告和跟踪点事件，同时管理中断返回时的RCU状态转换和锁依赖检查",
          "similarity": 0.41552090644836426
        }
      ]
    },
    {
      "source_file": "kernel/irq/generic-chip.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:54:33\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\generic-chip.c`\n\n---\n\n# `irq/generic-chip.c` 技术文档\n\n## 1. 文件概述\n\n`generic-chip.c` 是 Linux 内核中断子系统中的一个通用中断控制器（IRQ chip）实现库。该文件提供了一系列通用的、可复用的中断芯片回调函数（如 mask、unmask、ack、eoi、wake 等），用于简化各类硬件中断控制器驱动的开发。通过抽象出常见的寄存器操作模式（如通过置位/清位掩码寄存器、独立的使能/禁止寄存器等），该模块允许驱动开发者无需重复实现标准中断操作逻辑，只需配置通用芯片结构体即可快速集成中断控制器。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct irq_chip_generic`：表示一个通用中断控制器实例，包含寄存器基地址、中断基数、锁、掩码缓存、芯片类型数组等。\n- `struct irq_chip_type`：描述中断控制器的一种操作类型（如电平触发、边沿触发），包含寄存器偏移、掩码缓存指针、流控处理函数等。\n- `enum irq_gc_flags`：控制通用芯片初始化行为的标志（如是否为每种类型维护独立掩码缓存、是否从硬件读取初始掩码值等）。\n\n### 主要导出函数\n- **中断屏蔽/解除屏蔽**：\n  - `irq_gc_mask_disable_reg()`：通过写入 disable 寄存器屏蔽中断。\n  - `irq_gc_mask_set_bit()` / `irq_gc_mask_clr_bit()`：通过置位/清位 mask 寄存器屏蔽中断。\n  - `irq_gc_unmask_enable_reg()`：通过写入 enable 寄存器解除屏蔽。\n- **中断确认（ACK）**：\n  - `irq_gc_ack_set_bit()`：通过置位 ack 寄存器确认中断。\n  - `irq_gc_ack_clr_bit()`：通过清位 ack 寄存器确认中断。\n- **组合操作**：\n  - `irq_gc_mask_disable_and_ack_set()`：同时屏蔽中断并确认（适用于特定硬件）。\n- **中断结束（EOI）**：\n  - `irq_gc_eoi()`：向 eoi 寄存器写入以结束中断处理。\n- **唤醒控制**：\n  - `irq_gc_set_wake()`：设置/清除中断的唤醒能力（用于系统挂起/恢复）。\n- **资源管理**：\n  - `irq_alloc_generic_chip()`：分配并初始化一个通用中断芯片结构。\n  - `__irq_alloc_domain_generic_chips()`：为整个 IRQ domain 分配多个通用芯片实例（未在代码片段中完整展示，但声明存在）。\n\n### 辅助函数\n- `irq_gc_noop()`：空操作回调，用于不需要实际操作的场景。\n- `irq_init_generic_chip()`：初始化已分配的 `irq_chip_generic` 结构。\n- `irq_gc_init_mask_cache()`：根据标志初始化掩码缓存（可选从硬件读取初始值）。\n\n## 3. 关键实现\n\n### 寄存器访问抽象\n- 使用 `irq_reg_writel()` 和 `irq_reg_readl()` 进行寄存器读写，支持大小端配置（通过 `irq_writel_be`/`irq_readl_be`）。\n- 所有寄存器操作均在 `irq_gc_lock()` / `irq_gc_unlock()` 保护下进行，确保多中断线程安全。\n\n### 掩码缓存机制\n- 通用芯片维护一个或多个掩码缓存（`mask_cache`），避免频繁读取硬件寄存器。\n- 缓存更新与硬件写入原子执行，保证状态一致性。\n- 支持两种缓存模式：\n  - 全局共享缓存（默认）：所有 `chip_type` 共享同一个掩码值。\n  - 每类型独立缓存（`IRQ_GC_MASK_CACHE_PER_TYPE`）：每个 `chip_type` 拥有独立掩码。\n\n### 初始化灵活性\n- `irq_alloc_generic_chip()` 允许指定芯片名称、中断数量、寄存器基址和默认流控处理函数。\n- `__irq_alloc_domain_generic_chips()` 支持为整个 IRQ domain 批量分配芯片，适用于处理大量中断线的控制器（如 GPIO 控制器）。\n\n### 唤醒功能实现\n- `irq_gc_set_wake()` 通过位掩码 `wake_active` 跟踪哪些中断被配置为唤醒源。\n- 仅当请求的中断在 `wake_enabled` 掩码中时才允许设置唤醒状态，提供安全检查。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/irqdomain.h>`：中断核心数据结构和 API。\n  - `<linux/io.h>`：寄存器 I/O 操作（`ioread32be`/`iowrite32be`）。\n  - `\"internals.h\"`：中断子系统内部函数（如 `irq_data_get_irq_chip_data`）。\n- **内核子系统**：\n  - 中断子系统（`kernel/irq/`）：作为通用 IRQ chip 实现，被具体硬件驱动调用。\n  - 内存管理（`slab.h`）：用于动态分配 `irq_chip_generic` 结构。\n  - 电源管理：`irq_gc_set_wake` 与系统挂起/恢复机制集成。\n\n## 5. 使用场景\n\n- **嵌入式 SoC 中断控制器**：如 ARM GIC 的简化变种、厂商自定义中断控制器。\n- **GPIO 控制器中断**：GPIO 控制器常提供中断功能，每个 GPIO 组可映射为一个通用芯片实例。\n- **PCI/PCIe MSI 中断**：部分 MSI 控制器可复用通用芯片逻辑。\n- **快速原型开发**：驱动开发者可通过配置通用芯片结构快速支持新硬件，无需从零实现所有 IRQ 回调。\n- **设备树集成**：配合 IRQ domain 机制，通过 `__irq_alloc_domain_generic_chips` 自动为设备树中描述的中断控制器分配资源。",
      "similarity": 0.5347103476524353,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 208,
          "end_line": 351,
          "content": [
            "static u32 irq_readl_be(void __iomem *addr)",
            "{",
            "\treturn ioread32be(addr);",
            "}",
            "static void irq_writel_be(u32 val, void __iomem *addr)",
            "{",
            "\tiowrite32be(val, addr);",
            "}",
            "void irq_init_generic_chip(struct irq_chip_generic *gc, const char *name,",
            "\t\t\t   int num_ct, unsigned int irq_base,",
            "\t\t\t   void __iomem *reg_base, irq_flow_handler_t handler)",
            "{",
            "\traw_spin_lock_init(&gc->lock);",
            "\tgc->num_ct = num_ct;",
            "\tgc->irq_base = irq_base;",
            "\tgc->reg_base = reg_base;",
            "\tgc->chip_types->chip.name = name;",
            "\tgc->chip_types->handler = handler;",
            "}",
            "static void",
            "irq_gc_init_mask_cache(struct irq_chip_generic *gc, enum irq_gc_flags flags)",
            "{",
            "\tstruct irq_chip_type *ct = gc->chip_types;",
            "\tu32 *mskptr = &gc->mask_cache, mskreg = ct->regs.mask;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < gc->num_ct; i++) {",
            "\t\tif (flags & IRQ_GC_MASK_CACHE_PER_TYPE) {",
            "\t\t\tmskptr = &ct[i].mask_cache_priv;",
            "\t\t\tmskreg = ct[i].regs.mask;",
            "\t\t}",
            "\t\tct[i].mask_cache = mskptr;",
            "\t\tif (flags & IRQ_GC_INIT_MASK_CACHE)",
            "\t\t\t*mskptr = irq_reg_readl(gc, mskreg);",
            "\t}",
            "}",
            "int __irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,",
            "\t\t\t\t     int num_ct, const char *name,",
            "\t\t\t\t     irq_flow_handler_t handler,",
            "\t\t\t\t     unsigned int clr, unsigned int set,",
            "\t\t\t\t     enum irq_gc_flags gcflags)",
            "{",
            "\tstruct irq_domain_chip_generic *dgc;",
            "\tstruct irq_chip_generic *gc;",
            "\tunsigned long flags;",
            "\tint numchips, i;",
            "\tsize_t dgc_sz;",
            "\tsize_t gc_sz;",
            "\tsize_t sz;",
            "\tvoid *tmp;",
            "",
            "\tif (d->gc)",
            "\t\treturn -EBUSY;",
            "",
            "\tnumchips = DIV_ROUND_UP(d->revmap_size, irqs_per_chip);",
            "\tif (!numchips)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Allocate a pointer, generic chip and chiptypes for each chip */",
            "\tgc_sz = struct_size(gc, chip_types, num_ct);",
            "\tdgc_sz = struct_size(dgc, gc, numchips);",
            "\tsz = dgc_sz + numchips * gc_sz;",
            "",
            "\ttmp = dgc = kzalloc(sz, GFP_KERNEL);",
            "\tif (!dgc)",
            "\t\treturn -ENOMEM;",
            "\tdgc->irqs_per_chip = irqs_per_chip;",
            "\tdgc->num_chips = numchips;",
            "\tdgc->irq_flags_to_set = set;",
            "\tdgc->irq_flags_to_clear = clr;",
            "\tdgc->gc_flags = gcflags;",
            "\td->gc = dgc;",
            "",
            "\t/* Calc pointer to the first generic chip */",
            "\ttmp += dgc_sz;",
            "\tfor (i = 0; i < numchips; i++) {",
            "\t\t/* Store the pointer to the generic chip */",
            "\t\tdgc->gc[i] = gc = tmp;",
            "\t\tirq_init_generic_chip(gc, name, num_ct, i * irqs_per_chip,",
            "\t\t\t\t      NULL, handler);",
            "",
            "\t\tgc->domain = d;",
            "\t\tif (gcflags & IRQ_GC_BE_IO) {",
            "\t\t\tgc->reg_readl = &irq_readl_be;",
            "\t\t\tgc->reg_writel = &irq_writel_be;",
            "\t\t}",
            "",
            "\t\traw_spin_lock_irqsave(&gc_lock, flags);",
            "\t\tlist_add_tail(&gc->list, &gc_list);",
            "\t\traw_spin_unlock_irqrestore(&gc_lock, flags);",
            "\t\t/* Calc pointer to the next generic chip */",
            "\t\ttmp += gc_sz;",
            "\t}",
            "\treturn 0;",
            "}",
            "int irq_map_generic_chip(struct irq_domain *d, unsigned int virq,",
            "\t\t\t irq_hw_number_t hw_irq)",
            "{",
            "\tstruct irq_data *data = irq_domain_get_irq_data(d, virq);",
            "\tstruct irq_domain_chip_generic *dgc = d->gc;",
            "\tstruct irq_chip_generic *gc;",
            "\tstruct irq_chip_type *ct;",
            "\tstruct irq_chip *chip;",
            "\tunsigned long flags;",
            "\tint idx;",
            "",
            "\tgc = __irq_get_domain_generic_chip(d, hw_irq);",
            "\tif (IS_ERR(gc))",
            "\t\treturn PTR_ERR(gc);",
            "",
            "\tidx = hw_irq % dgc->irqs_per_chip;",
            "",
            "\tif (test_bit(idx, &gc->unused))",
            "\t\treturn -ENOTSUPP;",
            "",
            "\tif (test_bit(idx, &gc->installed))",
            "\t\treturn -EBUSY;",
            "",
            "\tct = gc->chip_types;",
            "\tchip = &ct->chip;",
            "",
            "\t/* We only init the cache for the first mapping of a generic chip */",
            "\tif (!gc->installed) {",
            "\t\traw_spin_lock_irqsave(&gc->lock, flags);",
            "\t\tirq_gc_init_mask_cache(gc, dgc->gc_flags);",
            "\t\traw_spin_unlock_irqrestore(&gc->lock, flags);",
            "\t}",
            "",
            "\t/* Mark the interrupt as installed */",
            "\tset_bit(idx, &gc->installed);",
            "",
            "\tif (dgc->gc_flags & IRQ_GC_INIT_NESTED_LOCK)",
            "\t\tirq_set_lockdep_class(virq, &irq_nested_lock_class,",
            "\t\t\t\t      &irq_nested_request_class);",
            "",
            "\tif (chip->irq_calc_mask)",
            "\t\tchip->irq_calc_mask(data);",
            "\telse",
            "\t\tdata->mask = 1 << idx;",
            "",
            "\tirq_domain_set_info(d, virq, hw_irq, chip, gc, ct->handler, NULL, NULL);",
            "\tirq_modify_status(virq, dgc->irq_flags_to_clear, dgc->irq_flags_to_set);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "irq_readl_be, irq_writel_be, irq_init_generic_chip, irq_gc_init_mask_cache, __irq_alloc_domain_generic_chips, irq_map_generic_chip",
          "description": "提供大端访问辅助函数及通用芯片初始化接口，构建中断域与硬件寄存器映射关系",
          "similarity": 0.5626833438873291
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Library implementing the most common irq chip callback functions",
            " *",
            " * Copyright (C) 2011, Thomas Gleixner",
            " */",
            "#include <linux/io.h>",
            "#include <linux/irq.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/syscore_ops.h>",
            "",
            "#include \"internals.h\"",
            "",
            "static LIST_HEAD(gc_list);",
            "static DEFINE_RAW_SPINLOCK(gc_lock);",
            "",
            "/**",
            " * irq_gc_noop - NOOP function",
            " * @d: irq_data",
            " */"
          ],
          "function_name": null,
          "description": "定义通用中断芯片回调函数及数据结构，提供基础框架支持多种中断控制器实现",
          "similarity": 0.5418429374694824
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 598,
          "end_line": 654,
          "content": [
            "static int irq_gc_suspend(void)",
            "{",
            "\tstruct irq_chip_generic *gc;",
            "",
            "\tlist_for_each_entry(gc, &gc_list, list) {",
            "\t\tstruct irq_chip_type *ct = gc->chip_types;",
            "",
            "\t\tif (ct->chip.irq_suspend) {",
            "\t\t\tstruct irq_data *data = irq_gc_get_irq_data(gc);",
            "",
            "\t\t\tif (data)",
            "\t\t\t\tct->chip.irq_suspend(data);",
            "\t\t}",
            "",
            "\t\tif (gc->suspend)",
            "\t\t\tgc->suspend(gc);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void irq_gc_resume(void)",
            "{",
            "\tstruct irq_chip_generic *gc;",
            "",
            "\tlist_for_each_entry(gc, &gc_list, list) {",
            "\t\tstruct irq_chip_type *ct = gc->chip_types;",
            "",
            "\t\tif (gc->resume)",
            "\t\t\tgc->resume(gc);",
            "",
            "\t\tif (ct->chip.irq_resume) {",
            "\t\t\tstruct irq_data *data = irq_gc_get_irq_data(gc);",
            "",
            "\t\t\tif (data)",
            "\t\t\t\tct->chip.irq_resume(data);",
            "\t\t}",
            "\t}",
            "}",
            "static void irq_gc_shutdown(void)",
            "{",
            "\tstruct irq_chip_generic *gc;",
            "",
            "\tlist_for_each_entry(gc, &gc_list, list) {",
            "\t\tstruct irq_chip_type *ct = gc->chip_types;",
            "",
            "\t\tif (ct->chip.irq_pm_shutdown) {",
            "\t\t\tstruct irq_data *data = irq_gc_get_irq_data(gc);",
            "",
            "\t\t\tif (data)",
            "\t\t\t\tct->chip.irq_pm_shutdown(data);",
            "\t\t}",
            "\t}",
            "}",
            "static int __init irq_gc_init_ops(void)",
            "{",
            "\tregister_syscore_ops(&irq_gc_syscore_ops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "irq_gc_suspend, irq_gc_resume, irq_gc_shutdown, irq_gc_init_ops",
          "description": "集成电源管理操作，通过系统核心操作注册中断控制器的挂起/恢复/关闭处理流程",
          "similarity": 0.4725137948989868
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 25,
          "end_line": 129,
          "content": [
            "void irq_gc_noop(struct irq_data *d)",
            "{",
            "}",
            "void irq_gc_mask_disable_reg(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.disable);",
            "\t*ct->mask_cache &= ~mask;",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_mask_set_bit(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\t*ct->mask_cache |= mask;",
            "\tirq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_mask_clr_bit(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\t*ct->mask_cache &= ~mask;",
            "\tirq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_unmask_enable_reg(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.enable);",
            "\t*ct->mask_cache |= mask;",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_ack_set_bit(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.ack);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_ack_clr_bit(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = ~d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.ack);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_mask_disable_and_ack_set(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.disable);",
            "\t*ct->mask_cache &= ~mask;",
            "\tirq_reg_writel(gc, mask, ct->regs.ack);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_eoi(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.eoi);",
            "\tirq_gc_unlock(gc);",
            "}",
            "int irq_gc_set_wake(struct irq_data *d, unsigned int on)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tif (!(mask & gc->wake_enabled))",
            "\t\treturn -EINVAL;",
            "",
            "\tirq_gc_lock(gc);",
            "\tif (on)",
            "\t\tgc->wake_active |= mask;",
            "\telse",
            "\t\tgc->wake_active &= ~mask;",
            "\tirq_gc_unlock(gc);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "irq_gc_noop, irq_gc_mask_disable_reg, irq_gc_mask_set_bit, irq_gc_mask_clr_bit, irq_gc_unmask_enable_reg, irq_gc_ack_set_bit, irq_gc_ack_clr_bit, irq_gc_mask_disable_and_ack_set, irq_gc_eoi, irq_gc_set_wake",
          "description": "实现通用中断掩码、ACK、使能等操作的底层函数，用于控制中断线路状态",
          "similarity": 0.45631325244903564
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 434,
          "end_line": 536,
          "content": [
            "void irq_unmap_generic_chip(struct irq_domain *d, unsigned int virq)",
            "{",
            "\tstruct irq_data *data = irq_domain_get_irq_data(d, virq);",
            "\tstruct irq_domain_chip_generic *dgc = d->gc;",
            "\tunsigned int hw_irq = data->hwirq;",
            "\tstruct irq_chip_generic *gc;",
            "\tint irq_idx;",
            "",
            "\tgc = irq_get_domain_generic_chip(d, hw_irq);",
            "\tif (!gc)",
            "\t\treturn;",
            "",
            "\tirq_idx = hw_irq % dgc->irqs_per_chip;",
            "",
            "\tclear_bit(irq_idx, &gc->installed);",
            "\tirq_domain_set_info(d, virq, hw_irq, &no_irq_chip, NULL, NULL, NULL,",
            "\t\t\t    NULL);",
            "",
            "}",
            "void irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,",
            "\t\t\t    enum irq_gc_flags flags, unsigned int clr,",
            "\t\t\t    unsigned int set)",
            "{",
            "\tstruct irq_chip_type *ct = gc->chip_types;",
            "\tstruct irq_chip *chip = &ct->chip;",
            "\tunsigned int i;",
            "",
            "\traw_spin_lock(&gc_lock);",
            "\tlist_add_tail(&gc->list, &gc_list);",
            "\traw_spin_unlock(&gc_lock);",
            "",
            "\tirq_gc_init_mask_cache(gc, flags);",
            "",
            "\tfor (i = gc->irq_base; msk; msk >>= 1, i++) {",
            "\t\tif (!(msk & 0x01))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (flags & IRQ_GC_INIT_NESTED_LOCK)",
            "\t\t\tirq_set_lockdep_class(i, &irq_nested_lock_class,",
            "\t\t\t\t\t      &irq_nested_request_class);",
            "",
            "\t\tif (!(flags & IRQ_GC_NO_MASK)) {",
            "\t\t\tstruct irq_data *d = irq_get_irq_data(i);",
            "",
            "\t\t\tif (chip->irq_calc_mask)",
            "\t\t\t\tchip->irq_calc_mask(d);",
            "\t\t\telse",
            "\t\t\t\td->mask = 1 << (i - gc->irq_base);",
            "\t\t}",
            "\t\tirq_set_chip_and_handler(i, chip, ct->handler);",
            "\t\tirq_set_chip_data(i, gc);",
            "\t\tirq_modify_status(i, clr, set);",
            "\t}",
            "\tgc->irq_cnt = i - gc->irq_base;",
            "}",
            "int irq_setup_alt_chip(struct irq_data *d, unsigned int type)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = gc->chip_types;",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < gc->num_ct; i++, ct++) {",
            "\t\tif (ct->type & type) {",
            "\t\t\td->chip = &ct->chip;",
            "\t\t\tirq_data_to_desc(d)->handle_irq = ct->handler;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "void irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,",
            "\t\t\t     unsigned int clr, unsigned int set)",
            "{",
            "\tunsigned int i, virq;",
            "",
            "\traw_spin_lock(&gc_lock);",
            "\tlist_del(&gc->list);",
            "\traw_spin_unlock(&gc_lock);",
            "",
            "\tfor (i = 0; msk; msk >>= 1, i++) {",
            "\t\tif (!(msk & 0x01))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Interrupt domain based chips store the base hardware",
            "\t\t * interrupt number in gc::irq_base. Otherwise gc::irq_base",
            "\t\t * contains the base Linux interrupt number.",
            "\t\t */",
            "\t\tif (gc->domain) {",
            "\t\t\tvirq = irq_find_mapping(gc->domain, gc->irq_base + i);",
            "\t\t\tif (!virq)",
            "\t\t\t\tcontinue;",
            "\t\t} else {",
            "\t\t\tvirq = gc->irq_base + i;",
            "\t\t}",
            "",
            "\t\t/* Remove handler first. That will mask the irq line */",
            "\t\tirq_set_handler(virq, NULL);",
            "\t\tirq_set_chip(virq, &no_irq_chip);",
            "\t\tirq_set_chip_data(virq, NULL);",
            "\t\tirq_modify_status(virq, clr, set);",
            "\t}",
            "}"
          ],
          "function_name": "irq_unmap_generic_chip, irq_setup_generic_chip, irq_setup_alt_chip, irq_remove_generic_chip",
          "description": "实现中断芯片的注册/注销与多处理类型切换，支持动态配置中断处理逻辑",
          "similarity": 0.44051146507263184
        }
      ]
    },
    {
      "source_file": "kernel/compat.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `compat.c`\n\n---\n\n# compat.c 技术文档\n\n## 文件概述\n\n`compat.c` 是 Linux 内核中用于提供 32 位系统调用兼容性支持的核心文件，主要运行在 64 位内核上。该文件实现了将 32 位用户空间程序发出的系统调用转换为内核内部 64 位数据结构和接口所需的适配逻辑，确保 32 位应用程序能够在 64 位系统上正常运行。其核心功能包括信号处理、资源使用统计（rusage）、CPU 亲和性设置、位图操作以及信号集转换等兼容层封装。\n\n## 核心功能\n\n### 主要函数\n\n- `compat_sigprocmask`：32 位兼容版的 `sigprocmask` 系统调用，用于操作进程的信号掩码。\n- `put_compat_rusage`：将内核的 `struct rusage` 转换为 32 位兼容格式并复制到用户空间。\n- `compat_get_user_cpu_mask`：从用户空间读取 32 位 CPU 亲和性位图并转换为内核 `cpumask`。\n- `compat_sched_setaffinity` / `compat_sched_getaffinity`：32 位兼容的 CPU 亲和性设置与获取系统调用。\n- `get_compat_sigevent`：将 32 位 `sigevent` 结构从用户空间复制并转换为内核格式。\n- `compat_get_bitmap` / `compat_put_bitmap`：在 32 位用户空间与 64 位内核之间安全地传输位图数据。\n- `get_compat_sigset`：将 32 位信号集（`compat_sigset_t`）转换为内核内部的 `sigset_t`。\n\n### 关键数据结构\n\n- `compat_sigset_t`：32 位信号集表示。\n- `compat_rusage`：32 位资源使用统计结构。\n- `compat_sigevent`：32 位信号事件描述结构。\n- `compat_ulong_t`：32 位无符号长整型（通常为 `u32`）。\n\n## 关键实现\n\n### 信号掩码处理（`compat_sigprocmask`）\n\n该函数仅操作信号掩码的第一个字（32 位），通过 `compat_sig_setmask` 直接内存拷贝实现 `SIG_SETMASK` 行为。对于 `SIG_BLOCK` 和 `SIG_UNBLOCK`，则调用内核通用的 `sigaddsetmask` 和 `sigdelsetmask` 辅助函数。特别地，它会自动屏蔽 `SIGKILL` 和 `SIGSTOP`，因为这两个信号不可被阻塞。\n\n### 位图转换（`compat_get_bitmap` / `compat_put_bitmap`）\n\n由于 64 位内核中 `unsigned long` 为 64 位，而 32 位用户空间使用 32 位 `compat_ulong_t`，位图需进行高低位重组：\n- **读取**：每两个 32 位值组合成一个 64 位内核值（低位在前，高位在后）。\n- **写入**：将一个 64 位内核值拆分为两个 32 位值写回用户空间。\n使用 `user_read_access_begin`/`user_write_access_end` 配合 `unsafe_get/put_user` 实现高效、安全的批量访问。\n\n### 字节序处理（`get_compat_sigset`）\n\n在大端（Big-Endian）架构上，32 位信号集的高低 32 位在内存中的排列与小端不同，需显式重组为 64 位内核信号字。小端架构可直接内存拷贝。\n\n### CPU 亲和性兼容（`sched_setaffinity`/`getaffinity`）\n\n- **设置**：通过 `compat_get_user_cpu_mask` 将用户传入的 32 位位图转换为内核 `cpumask`，再调用通用 `sched_setaffinity`。\n- **获取**：先调用通用接口获取内核 `cpumask`，再通过 `compat_put_bitmap` 转换回 32 位格式返回给用户。返回长度为实际写入的字节数。\n\n### 资源使用统计（`put_compat_rusage`）\n\n逐字段将 64 位 `rusage` 中的时间（`tv_sec`/`tv_usec`）及其他统计值复制到 32 位结构体，确保字段对齐和截断安全，最后通过 `copy_to_user` 返回。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/compat.h>`：提供兼容层宏定义和类型（如 `COMPAT_SYSCALL_DEFINE`）。\n  - `<linux/uaccess.h>`：用户空间内存访问接口（`get_user`、`put_user` 等）。\n  - `<linux/sched.h>`、`<linux/cpumask.h>`：调度和 CPU 亲和性相关 API。\n  - `<linux/signal.h>`：信号处理核心接口。\n  - `<linux/posix-timers.h>`：`sigevent` 相关定义。\n- **内核模块依赖**：\n  - 调度子系统（`kernel/sched/`）：`sched_setaffinity`/`getaffinity` 实现。\n  - 信号子系统（`kernel/signal.c`）：信号掩码操作函数。\n  - 内存管理：`GFP_KERNEL` 内存分配。\n- **架构依赖**：通过 `__ARCH_WANT_SYS_SIGPROCMASK` 宏控制是否编译 `sigprocmask` 兼容实现，依赖 `__BIG_ENDIAN` 处理字节序差异。\n\n## 使用场景\n\n1. **32 位应用程序在 64 位内核上运行**：当 32 位 ELF 程序执行系统调用（如 `sigprocmask`、`sched_setaffinity`）时，内核通过此文件中的兼容层函数处理参数转换。\n2. **跨架构二进制兼容**：在 x86_64、ARM64 等支持 32 位兼容模式的架构上，该文件是运行旧版 32 位软件的关键组件。\n3. **系统调用拦截与转换**：安全模块（如 SELinux）或容器运行时可能依赖此兼容层正确解析 32 位进程的系统调用参数。\n4. **性能监控工具**：32 位 `getrusage` 调用通过 `put_compat_rusage` 获取资源统计信息。\n5. **实时/多线程应用**：32 位程序使用 `timer_create` 等 POSIX 定时器接口时，`sigevent` 结构通过 `get_compat_sigevent` 转换。",
      "similarity": 0.5206055641174316,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/compat.c",
          "start_line": 35,
          "end_line": 144,
          "content": [
            "static inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)",
            "{",
            "\tmemcpy(blocked->sig, &set, sizeof(set));",
            "}",
            "int put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)",
            "{",
            "\tstruct compat_rusage r32;",
            "\tmemset(&r32, 0, sizeof(r32));",
            "\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;",
            "\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;",
            "\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;",
            "\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;",
            "\tr32.ru_maxrss = r->ru_maxrss;",
            "\tr32.ru_ixrss = r->ru_ixrss;",
            "\tr32.ru_idrss = r->ru_idrss;",
            "\tr32.ru_isrss = r->ru_isrss;",
            "\tr32.ru_minflt = r->ru_minflt;",
            "\tr32.ru_majflt = r->ru_majflt;",
            "\tr32.ru_nswap = r->ru_nswap;",
            "\tr32.ru_inblock = r->ru_inblock;",
            "\tr32.ru_oublock = r->ru_oublock;",
            "\tr32.ru_msgsnd = r->ru_msgsnd;",
            "\tr32.ru_msgrcv = r->ru_msgrcv;",
            "\tr32.ru_nsignals = r->ru_nsignals;",
            "\tr32.ru_nvcsw = r->ru_nvcsw;",
            "\tr32.ru_nivcsw = r->ru_nivcsw;",
            "\tif (copy_to_user(ru, &r32, sizeof(r32)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "static int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,",
            "\t\t\t\t    unsigned len, struct cpumask *new_mask)",
            "{",
            "\tunsigned long *k;",
            "",
            "\tif (len < cpumask_size())",
            "\t\tmemset(new_mask, 0, cpumask_size());",
            "\telse if (len > cpumask_size())",
            "\t\tlen = cpumask_size();",
            "",
            "\tk = cpumask_bits(new_mask);",
            "\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);",
            "}",
            "int get_compat_sigevent(struct sigevent *event,",
            "\t\tconst struct compat_sigevent __user *u_event)",
            "{",
            "\tmemset(event, 0, sizeof(*event));",
            "\treturn (!access_ok(u_event, sizeof(*u_event)) ||",
            "\t\t__get_user(event->sigev_value.sival_int,",
            "\t\t\t&u_event->sigev_value.sival_int) ||",
            "\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||",
            "\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||",
            "\t\t__get_user(event->sigev_notify_thread_id,",
            "\t\t\t&u_event->sigev_notify_thread_id))",
            "\t\t? -EFAULT : 0;",
            "}",
            "long compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,",
            "\t\t       unsigned long bitmap_size)",
            "{",
            "\tunsigned long nr_compat_longs;",
            "",
            "\t/* align bitmap up to nearest compat_long_t boundary */",
            "\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);",
            "\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);",
            "",
            "\tif (!user_read_access_begin(umask, bitmap_size / 8))",
            "\t\treturn -EFAULT;",
            "",
            "\twhile (nr_compat_longs > 1) {",
            "\t\tcompat_ulong_t l1, l2;",
            "\t\tunsafe_get_user(l1, umask++, Efault);",
            "\t\tunsafe_get_user(l2, umask++, Efault);",
            "\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;",
            "\t\tnr_compat_longs -= 2;",
            "\t}",
            "\tif (nr_compat_longs)",
            "\t\tunsafe_get_user(*mask, umask++, Efault);",
            "\tuser_read_access_end();",
            "\treturn 0;",
            "",
            "Efault:",
            "\tuser_read_access_end();",
            "\treturn -EFAULT;",
            "}",
            "long compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,",
            "\t\t       unsigned long bitmap_size)",
            "{",
            "\tunsigned long nr_compat_longs;",
            "",
            "\t/* align bitmap up to nearest compat_long_t boundary */",
            "\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);",
            "\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);",
            "",
            "\tif (!user_write_access_begin(umask, bitmap_size / 8))",
            "\t\treturn -EFAULT;",
            "",
            "\twhile (nr_compat_longs > 1) {",
            "\t\tunsigned long m = *mask++;",
            "\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);",
            "\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);",
            "\t\tnr_compat_longs -= 2;",
            "\t}",
            "\tif (nr_compat_longs)",
            "\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);",
            "\tuser_write_access_end();",
            "\treturn 0;",
            "Efault:",
            "\tuser_write_access_end();",
            "\treturn -EFAULT;",
            "}"
          ],
          "function_name": "compat_sig_setmask, put_compat_rusage, compat_get_user_cpu_mask, get_compat_sigevent, compat_get_bitmap, compat_put_bitmap",
          "description": "实现多个兼容性转换函数，包括将rusage结构体转换为32位格式、处理CPU掩码位图转换、提取sigevent事件信息以及双向转换信号集位图，核心功能是解决64位内核与32位用户态数据类型的差异。",
          "similarity": 0.5004012584686279
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/compat.c",
          "start_line": 1,
          "end_line": 34,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/compat.c",
            " *",
            " *  Kernel compatibililty routines for e.g. 32 bit syscall support",
            " *  on 64 bit kernels.",
            " *",
            " *  Copyright (C) 2002-2003 Stephen Rothwell, IBM Corporation",
            " */",
            "",
            "#include <linux/linkage.h>",
            "#include <linux/compat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/signal.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/times.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#ifdef __ARCH_WANT_SYS_SIGPROCMASK",
            "",
            "/*",
            " * sys_sigprocmask SIG_SETMASK sets the first (compat) word of the",
            " * blocked set of signals to the supplied signal set",
            " */"
          ],
          "function_name": null,
          "description": "此代码块包含兼容性支持所需的基础头文件和注释，定义了处理32位系统调用兼容性的框架，主要用于实现64位内核对32位进程的信号集操作等兼容逻辑。",
          "similarity": 0.4674023985862732
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/compat.c",
          "start_line": 249,
          "end_line": 270,
          "content": [
            "int",
            "get_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)",
            "{",
            "#ifdef __BIG_ENDIAN",
            "\tcompat_sigset_t v;",
            "\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))",
            "\t\treturn -EFAULT;",
            "\tswitch (_NSIG_WORDS) {",
            "\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );",
            "\t}",
            "#else",
            "\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))",
            "\t\treturn -EFAULT;",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_compat_sigset",
          "description": "将用户态的兼容信号集（compat_sigset_t）转换为内核态sigset_t结构，在大端架构下通过字节序调整确保信号掩码的正确解析，实现信号集的跨字节序兼容转换。",
          "similarity": 0.4586900472640991
        }
      ]
    }
  ]
}