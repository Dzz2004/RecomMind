{
  "query": "系统调用上下文切换",
  "timestamp": "2025-12-26 02:08:36",
  "retrieved_files": [
    {
      "source_file": "kernel/livepatch/transition.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:34:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `livepatch\\transition.c`\n\n---\n\n# livepatch/transition.c 技术文档\n\n## 1. 文件概述\n\n`livepatch/transition.c` 是 Linux 内核实时补丁（Kernel Live Patching）子系统的核心组件之一，负责管理补丁状态转换过程。该文件实现了从旧代码到新补丁代码（或反向）的安全过渡机制，确保所有正在运行的任务（包括内核线程、用户态进程和 idle 线程）都能安全地切换到目标补丁状态，避免在函数栈中仍存在待替换函数时进行切换，从而防止系统崩溃或行为异常。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `klp_transition_patch`：指向当前正在进行状态转换的补丁对象。\n- `klp_target_state`：目标补丁状态（`KLP_PATCHED` 或 `KLP_UNPATCHED`），初始为 `KLP_UNDEFINED`。\n- `klp_signals_cnt`：用于统计信号处理相关计数（当前未在代码片段中完整使用）。\n- `klp_stack_entries`：每 CPU 栈追踪缓冲区，用于保存任务调用栈。\n\n### 主要函数\n- `klp_transition_work_fn()`：延迟工作队列回调，用于重试未能完成转换的“滞留”任务。\n- `klp_synchronize_transition()`：强制在所有 CPU 上执行调度同步，确保 RCU 不可见区域也能完成同步。\n- `klp_complete_transition()`：完成整个补丁状态转换，清理数据结构并调用回调。\n- `klp_cancel_transition()`：在转换开始前取消补丁操作。\n- `klp_update_patch_state()`：更新指定任务的补丁状态。\n- `klp_check_stack_func()`：检查给定函数是否出现在栈追踪中。\n- `klp_check_stack()`：检查任务栈中是否存在待替换/待移除的函数（代码片段中被截断）。\n\n### 静态键与调度集成\n- 在支持 `CONFIG_PREEMPT_DYNAMIC` 的系统上，通过 `sched_dynamic_klp_enable/disable()` 启用/禁用 cond_resched 中的栈检查。\n- 否则使用静态键 `klp_sched_try_switch_key` 控制是否在 `cond_resched()` 中进行补丁栈检查，以帮助 CPU 密集型内核线程完成补丁切换。\n\n## 3. 关键实现\n\n### 补丁状态转换流程\n1. **初始化阶段**：设置 `klp_transition_patch` 和 `klp_target_state`。\n2. **任务状态更新**：通过 `TIF_PATCH_PENDING` 标志标记需要更新状态的任务。\n3. **栈安全检查**：使用 `stack_trace_save_tsk_reliable()` 获取可靠栈追踪，检查是否存在待替换函数。\n4. **同步机制**：\n   - 使用 `klp_synchronize_transition()` 调用 `schedule_on_each_cpu(klp_sync)`，强制所有 CPU（包括 idle 和用户态）参与同步。\n   - 此机制绕过标准 RCU，适用于 RCU 不活跃的上下文（如 `user_exit()` 前）。\n5. **完成清理**：\n   - 清除所有任务的 `patch_state` 为 `KLP_UNDEFINED`。\n   - 调用对象级的 `post_patch` 或 `post_unpatch` 回调。\n   - 重置全局状态变量。\n\n### 栈检查逻辑\n- **打补丁时（KLP_PATCHED）**：检查栈中是否包含**旧函数**（原始函数或上一个补丁版本的函数）。\n- **卸补丁时（KLP_UNPATCHED）**：检查栈中是否包含**新函数**（当前补丁中的函数）。\n- 若发现相关函数在栈中，则返回 `-EAGAIN`，推迟该任务的状态切换。\n\n### 内存屏障与并发控制\n- `test_and_clear_tsk_thread_flag()` 不仅清除 `TIF_PATCH_PENDING`，还充当读屏障（`smp_rmb`），确保：\n  1. `klp_target_state` 的读取顺序正确。\n  2. 后续 `klp_ftrace_handler()` 能看到一致的 `func->transition` 状态。\n\n### 滞留任务处理\n- 通过 `DECLARE_DELAYED_WORK(klp_transition_work, ...)` 定期重试未能完成转换的任务，提高转换成功率。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `core.h`：提供 `klp_mutex`、`klp_for_each_object/func` 等核心宏和函数。\n  - `patch.h`：定义 `klp_func`、`klp_object`、`klp_patch` 等数据结构及操作函数（如 `klp_unpatch_objects`）。\n  - `transition.h`：声明本文件导出的接口（如 `klp_cancel_transition`）。\n- **内核子系统**：\n  - **RCU**：用于常规同步，但在 RCU 不活跃区域使用自定义同步。\n  - **调度器**：通过 `cond_resched()` 集成补丁检查，依赖 `CONFIG_PREEMPT_DYNAMIC` 或静态键。\n  - **栈追踪**：使用 `stack_trace_save_tsk_reliable()` 获取可靠调用栈。\n  - **CPU 热插拔**：通过 `for_each_possible_cpu` 处理所有可能的 CPU（包括离线 CPU 的 idle 任务）。\n\n## 5. 使用场景\n\n- **应用实时补丁**：当管理员通过 sysfs 启用一个 livepatch 模块时，内核调用此文件中的函数将所有任务从旧代码切换到新补丁代码。\n- **卸载实时补丁**：当禁用补丁时，安全地将所有任务切换回旧函数，并清理补丁数据结构。\n- **处理滞留任务**：对于因长时间运行或处于不可中断状态而未能及时切换的任务，通过延迟工作队列周期性重试。\n- **支持特殊上下文**：确保在 RCU 不活跃的上下文（如系统调用入口/出口、idle 循环）中也能安全完成补丁切换。\n- **错误恢复**：在补丁初始化后、实际切换前发生错误时，调用 `klp_cancel_transition()` 安全回滚。",
      "similarity": 0.5708227753639221,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 366,
          "end_line": 509,
          "content": [
            "void __klp_sched_try_switch(void)",
            "{",
            "\tif (likely(!klp_patch_pending(current)))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This function is called from cond_resched() which is called in many",
            "\t * places throughout the kernel.  Using the klp_mutex here might",
            "\t * deadlock.",
            "\t *",
            "\t * Instead, disable preemption to prevent racing with other callers of",
            "\t * klp_try_switch_task().  Thanks to task_call_func() they won't be",
            "\t * able to switch this task while it's running.",
            "\t */",
            "\tpreempt_disable();",
            "",
            "\t/*",
            "\t * Make sure current didn't get patched between the above check and",
            "\t * preempt_disable().",
            "\t */",
            "\tif (unlikely(!klp_patch_pending(current)))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Enforce the order of the TIF_PATCH_PENDING read above and the",
            "\t * klp_target_state read in klp_try_switch_task().  The corresponding",
            "\t * write barriers are in klp_init_transition() and",
            "\t * klp_reverse_transition().",
            "\t */",
            "\tsmp_rmb();",
            "",
            "\tklp_try_switch_task(current);",
            "",
            "out:",
            "\tpreempt_enable();",
            "}",
            "static void klp_send_signals(void)",
            "{",
            "\tstruct task_struct *g, *task;",
            "",
            "\tif (klp_signals_cnt == SIGNALS_TIMEOUT)",
            "\t\tpr_notice(\"signaling remaining tasks\\n\");",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task) {",
            "\t\tif (!klp_patch_pending(task))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * There is a small race here. We could see TIF_PATCH_PENDING",
            "\t\t * set and decide to wake up a kthread or send a fake signal.",
            "\t\t * Meanwhile the task could migrate itself and the action",
            "\t\t * would be meaningless. It is not serious though.",
            "\t\t */",
            "\t\tif (task->flags & PF_KTHREAD) {",
            "\t\t\t/*",
            "\t\t\t * Wake up a kthread which sleeps interruptedly and",
            "\t\t\t * still has not been migrated.",
            "\t\t\t */",
            "\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * Send fake signal to all non-kthread tasks which are",
            "\t\t\t * still not migrated.",
            "\t\t\t */",
            "\t\t\tset_notify_signal(task);",
            "\t\t}",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "}",
            "void klp_try_complete_transition(void)",
            "{",
            "\tunsigned int cpu;",
            "\tstruct task_struct *g, *task;",
            "\tstruct klp_patch *patch;",
            "\tbool complete = true;",
            "",
            "\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);",
            "",
            "\t/*",
            "\t * Try to switch the tasks to the target patch state by walking their",
            "\t * stacks and looking for any to-be-patched or to-be-unpatched",
            "\t * functions.  If such functions are found on a stack, or if the stack",
            "\t * is deemed unreliable, the task can't be switched yet.",
            "\t *",
            "\t * Usually this will transition most (or all) of the tasks on a system",
            "\t * unless the patch includes changes to a very common function.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tif (!klp_try_switch_task(task))",
            "\t\t\tcomplete = false;",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\t/*",
            "\t * Ditto for the idle \"swapper\" tasks.",
            "\t */",
            "\tcpus_read_lock();",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tif (cpu_online(cpu)) {",
            "\t\t\tif (!klp_try_switch_task(task)) {",
            "\t\t\t\tcomplete = false;",
            "\t\t\t\t/* Make idle task go through the main loop. */",
            "\t\t\t\twake_up_if_idle(cpu);",
            "\t\t\t}",
            "\t\t} else if (task->patch_state != klp_target_state) {",
            "\t\t\t/* offline idle tasks can be switched immediately */",
            "\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\t\t\ttask->patch_state = klp_target_state;",
            "\t\t}",
            "\t}",
            "\tcpus_read_unlock();",
            "",
            "\tif (!complete) {",
            "\t\tif (klp_signals_cnt && !(klp_signals_cnt % SIGNALS_TIMEOUT))",
            "\t\t\tklp_send_signals();",
            "\t\tklp_signals_cnt++;",
            "",
            "\t\t/*",
            "\t\t * Some tasks weren't able to be switched over.  Try again",
            "\t\t * later and/or wait for other methods like kernel exit",
            "\t\t * switching.",
            "\t\t */",
            "\t\tschedule_delayed_work(&klp_transition_work,",
            "\t\t\t\t      round_jiffies_relative(HZ));",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Done!  Now cleanup the data structures. */",
            "\tklp_cond_resched_disable();",
            "\tpatch = klp_transition_patch;",
            "\tklp_complete_transition();",
            "",
            "\t/*",
            "\t * It would make more sense to free the unused patches in",
            "\t * klp_complete_transition() but it is called also",
            "\t * from klp_cancel_transition().",
            "\t */",
            "\tif (!patch->enabled)",
            "\t\tklp_free_patch_async(patch);",
            "\telse if (patch->replace)",
            "\t\tklp_free_replaced_patches_async(patch);",
            "}"
          ],
          "function_name": "__klp_sched_try_switch, klp_send_signals, klp_try_complete_transition",
          "description": "调度器层面的过渡辅助函数，通过禁止抢占防止竞态条件，并向未迁移任务发送信号触发上下文切换以完成补丁应用",
          "similarity": 0.657909631729126
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 648,
          "end_line": 740,
          "content": [
            "void klp_reverse_transition(void)",
            "{",
            "\tunsigned int cpu;",
            "\tstruct task_struct *g, *task;",
            "",
            "\tpr_debug(\"'%s': reversing transition from %s\\n\",",
            "\t\t klp_transition_patch->mod->name,",
            "\t\t klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :",
            "\t\t\t\t\t\t   \"unpatching to patching\");",
            "",
            "\t/*",
            "\t * Clear all TIF_PATCH_PENDING flags to prevent races caused by",
            "\t * klp_update_patch_state() or __klp_sched_try_switch() running in",
            "\t * parallel with the reverse transition.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tclear_tsk_thread_flag(idle_task(cpu), TIF_PATCH_PENDING);",
            "",
            "\t/*",
            "\t * Make sure all existing invocations of klp_update_patch_state() and",
            "\t * __klp_sched_try_switch() see the cleared TIF_PATCH_PENDING before",
            "\t * starting the reverse transition.",
            "\t */",
            "\tklp_synchronize_transition();",
            "",
            "\t/*",
            "\t * All patching has stopped, now re-initialize the global variables to",
            "\t * prepare for the reverse transition.",
            "\t */",
            "\tklp_transition_patch->enabled = !klp_transition_patch->enabled;",
            "\tklp_target_state = !klp_target_state;",
            "",
            "\t/*",
            "\t * Enforce the order of the klp_target_state write and the",
            "\t * TIF_PATCH_PENDING writes in klp_start_transition() to ensure",
            "\t * klp_update_patch_state() and __klp_sched_try_switch() don't set",
            "\t * task->patch_state to the wrong value.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tklp_start_transition();",
            "}",
            "void klp_copy_process(struct task_struct *child)",
            "{",
            "",
            "\t/*",
            "\t * The parent process may have gone through a KLP transition since",
            "\t * the thread flag was copied in setup_thread_stack earlier. Bring",
            "\t * the task flag up to date with the parent here.",
            "\t *",
            "\t * The operation is serialized against all klp_*_transition()",
            "\t * operations by the tasklist_lock. The only exceptions are",
            "\t * klp_update_patch_state(current) and __klp_sched_try_switch(), but we",
            "\t * cannot race with them because we are current.",
            "\t */",
            "\tif (test_tsk_thread_flag(current, TIF_PATCH_PENDING))",
            "\t\tset_tsk_thread_flag(child, TIF_PATCH_PENDING);",
            "\telse",
            "\t\tclear_tsk_thread_flag(child, TIF_PATCH_PENDING);",
            "",
            "\tchild->patch_state = current->patch_state;",
            "}",
            "void klp_force_transition(void)",
            "{",
            "\tstruct klp_patch *patch;",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "",
            "\tpr_warn(\"forcing remaining tasks to the patched state\\n\");",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tklp_update_patch_state(task);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tklp_update_patch_state(idle_task(cpu));",
            "",
            "\t/* Set forced flag for patches being removed. */",
            "\tif (klp_target_state == KLP_UNPATCHED)",
            "\t\tklp_transition_patch->forced = true;",
            "\telse if (klp_transition_patch->replace) {",
            "\t\tklp_for_each_patch(patch) {",
            "\t\t\tif (patch != klp_transition_patch)",
            "\t\t\t\tpatch->forced = true;",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "klp_reverse_transition, klp_copy_process, klp_force_transition",
          "description": "该代码段实现Live Patching框架中的状态转换控制逻辑。  \n`klp_reverse_transition`负责反向转换补丁状态，清除所有任务的TIF_PATCH_PENDING标志并切换全局状态后启动反向迁移；`klp_copy_process`在进程复制时同步父进程的补丁状态标志；`klp_force_transition`强制将剩余任务设为目标状态，并标记待移除补丁的强制属性。  \n\n注：代码依赖`klp_transition_patch`、`klp_target_state`等全局变量及`tasklist_lock`等上下文，此处仅展示部分实现。",
          "similarity": 0.5643231868743896
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 214,
          "end_line": 352,
          "content": [
            "static int klp_check_stack_func(struct klp_func *func, unsigned long *entries,",
            "\t\t\t\tunsigned int nr_entries)",
            "{",
            "\tunsigned long func_addr, func_size, address;",
            "\tstruct klp_ops *ops;",
            "\tint i;",
            "",
            "\tif (klp_target_state == KLP_UNPATCHED) {",
            "\t\t /*",
            "\t\t  * Check for the to-be-unpatched function",
            "\t\t  * (the func itself).",
            "\t\t  */",
            "\t\tfunc_addr = (unsigned long)func->new_func;",
            "\t\tfunc_size = func->new_size;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Check for the to-be-patched function",
            "\t\t * (the previous func).",
            "\t\t */",
            "\t\tops = klp_find_ops(func->old_func);",
            "",
            "\t\tif (list_is_singular(&ops->func_stack)) {",
            "\t\t\t/* original function */",
            "\t\t\tfunc_addr = (unsigned long)func->old_func;",
            "\t\t\tfunc_size = func->old_size;",
            "\t\t} else {",
            "\t\t\t/* previously patched function */",
            "\t\t\tstruct klp_func *prev;",
            "",
            "\t\t\tprev = list_next_entry(func, stack_node);",
            "\t\t\tfunc_addr = (unsigned long)prev->new_func;",
            "\t\t\tfunc_size = prev->new_size;",
            "\t\t}",
            "\t}",
            "",
            "\tfor (i = 0; i < nr_entries; i++) {",
            "\t\taddress = entries[i];",
            "",
            "\t\tif (address >= func_addr && address < func_addr + func_size)",
            "\t\t\treturn -EAGAIN;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int klp_check_stack(struct task_struct *task, const char **oldname)",
            "{",
            "\tunsigned long *entries = this_cpu_ptr(klp_stack_entries);",
            "\tstruct klp_object *obj;",
            "\tstruct klp_func *func;",
            "\tint ret, nr_entries;",
            "",
            "\t/* Protect 'klp_stack_entries' */",
            "\tlockdep_assert_preemption_disabled();",
            "",
            "\tret = stack_trace_save_tsk_reliable(task, entries, MAX_STACK_ENTRIES);",
            "\tif (ret < 0)",
            "\t\treturn -EINVAL;",
            "\tnr_entries = ret;",
            "",
            "\tklp_for_each_object(klp_transition_patch, obj) {",
            "\t\tif (!obj->patched)",
            "\t\t\tcontinue;",
            "\t\tklp_for_each_func(obj, func) {",
            "\t\t\tret = klp_check_stack_func(func, entries, nr_entries);",
            "\t\t\tif (ret) {",
            "\t\t\t\t*oldname = func->old_name;",
            "\t\t\t\treturn -EADDRINUSE;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int klp_check_and_switch_task(struct task_struct *task, void *arg)",
            "{",
            "\tint ret;",
            "",
            "\tif (task_curr(task) && task != current)",
            "\t\treturn -EBUSY;",
            "",
            "\tret = klp_check_stack(task, arg);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\ttask->patch_state = klp_target_state;",
            "\treturn 0;",
            "}",
            "static bool klp_try_switch_task(struct task_struct *task)",
            "{",
            "\tconst char *old_name;",
            "\tint ret;",
            "",
            "\t/* check if this task has already switched over */",
            "\tif (task->patch_state == klp_target_state)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * For arches which don't have reliable stack traces, we have to rely",
            "\t * on other methods (e.g., switching tasks at kernel exit).",
            "\t */",
            "\tif (!klp_have_reliable_stack())",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Now try to check the stack for any to-be-patched or to-be-unpatched",
            "\t * functions.  If all goes well, switch the task to the target patch",
            "\t * state.",
            "\t */",
            "\tif (task == current)",
            "\t\tret = klp_check_and_switch_task(current, &old_name);",
            "\telse",
            "\t\tret = task_call_func(task, klp_check_and_switch_task, &old_name);",
            "",
            "\tswitch (ret) {",
            "\tcase 0:\t\t/* success */",
            "\t\tbreak;",
            "",
            "\tcase -EBUSY:\t/* klp_check_and_switch_task() */",
            "\t\tpr_debug(\"%s: %s:%d is running\\n\",",
            "\t\t\t __func__, task->comm, task->pid);",
            "\t\tbreak;",
            "\tcase -EINVAL:\t/* klp_check_and_switch_task() */",
            "\t\tpr_debug(\"%s: %s:%d has an unreliable stack\\n\",",
            "\t\t\t __func__, task->comm, task->pid);",
            "\t\tbreak;",
            "\tcase -EADDRINUSE: /* klp_check_and_switch_task() */",
            "\t\tpr_debug(\"%s: %s:%d is sleeping on function %s\\n\",",
            "\t\t\t __func__, task->comm, task->pid, old_name);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tpr_debug(\"%s: Unknown error code (%d) when trying to switch %s:%d\\n\",",
            "\t\t\t __func__, ret, task->comm, task->pid);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn !ret;",
            "}"
          ],
          "function_name": "klp_check_stack_func, klp_check_stack, klp_check_and_switch_task, klp_try_switch_task",
          "description": "提供堆栈检查与任务状态切换机制，验证当前线程堆栈中是否包含待修改函数地址，确保安全切换到目标补丁状态",
          "similarity": 0.546964168548584
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 530,
          "end_line": 634,
          "content": [
            "void klp_start_transition(void)",
            "{",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "",
            "\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);",
            "",
            "\tpr_notice(\"'%s': starting %s transition\\n\",",
            "\t\t  klp_transition_patch->mod->name,",
            "\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\t/*",
            "\t * Mark all normal tasks as needing a patch state update.  They'll",
            "\t * switch either in klp_try_complete_transition() or as they exit the",
            "\t * kernel.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tif (task->patch_state != klp_target_state)",
            "\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\t/*",
            "\t * Mark all idle tasks as needing a patch state update.  They'll switch",
            "\t * either in klp_try_complete_transition() or at the idle loop switch",
            "\t * point.",
            "\t */",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tif (task->patch_state != klp_target_state)",
            "\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\t}",
            "",
            "\tklp_cond_resched_enable();",
            "",
            "\tklp_signals_cnt = 0;",
            "}",
            "void klp_init_transition(struct klp_patch *patch, int state)",
            "{",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "\tstruct klp_object *obj;",
            "\tstruct klp_func *func;",
            "\tint initial_state = !state;",
            "",
            "\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);",
            "",
            "\tklp_transition_patch = patch;",
            "",
            "\t/*",
            "\t * Set the global target patch state which tasks will switch to.  This",
            "\t * has no effect until the TIF_PATCH_PENDING flags get set later.",
            "\t */",
            "\tklp_target_state = state;",
            "",
            "\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,",
            "\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\t/*",
            "\t * Initialize all tasks to the initial patch state to prepare them for",
            "\t * switching to the target state.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task) {",
            "\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);",
            "\t\ttask->patch_state = initial_state;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\t/*",
            "\t * Ditto for the idle \"swapper\" tasks.",
            "\t */",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);",
            "\t\ttask->patch_state = initial_state;",
            "\t}",
            "",
            "\t/*",
            "\t * Enforce the order of the task->patch_state initializations and the",
            "\t * func->transition updates to ensure that klp_ftrace_handler() doesn't",
            "\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.",
            "\t *",
            "\t * Also enforce the order of the klp_target_state write and future",
            "\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() and",
            "\t * __klp_sched_try_switch() don't set a task->patch_state to",
            "\t * KLP_UNDEFINED.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\t/*",
            "\t * Set the func transition states so klp_ftrace_handler() will know to",
            "\t * switch to the transition logic.",
            "\t *",
            "\t * When patching, the funcs aren't yet in the func_stack and will be",
            "\t * made visible to the ftrace handler shortly by the calls to",
            "\t * klp_patch_object().",
            "\t *",
            "\t * When unpatching, the funcs are already in the func_stack and so are",
            "\t * already visible to the ftrace handler.",
            "\t */",
            "\tklp_for_each_object(patch, obj)",
            "\t\tklp_for_each_func(obj, func)",
            "\t\t\tfunc->transition = true;",
            "}"
          ],
          "function_name": "klp_start_transition, klp_init_transition",
          "description": "初始化热补丁过渡阶段，设置全局目标状态并批量标记所有任务需更新补丁状态，通过内存屏障保证状态更新顺序性",
          "similarity": 0.530284583568573
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 53,
          "end_line": 172,
          "content": [
            "static void klp_transition_work_fn(struct work_struct *work)",
            "{",
            "\tmutex_lock(&klp_mutex);",
            "",
            "\tif (klp_transition_patch)",
            "\t\tklp_try_complete_transition();",
            "",
            "\tmutex_unlock(&klp_mutex);",
            "}",
            "static void klp_sync(struct work_struct *work)",
            "{",
            "}",
            "static void klp_synchronize_transition(void)",
            "{",
            "\tschedule_on_each_cpu(klp_sync);",
            "}",
            "static void klp_complete_transition(void)",
            "{",
            "\tstruct klp_object *obj;",
            "\tstruct klp_func *func;",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "",
            "\tpr_debug(\"'%s': completing %s transition\\n\",",
            "\t\t klp_transition_patch->mod->name,",
            "\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\tif (klp_transition_patch->replace && klp_target_state == KLP_PATCHED) {",
            "\t\tklp_unpatch_replaced_patches(klp_transition_patch);",
            "\t\tklp_discard_nops(klp_transition_patch);",
            "\t}",
            "",
            "\tif (klp_target_state == KLP_UNPATCHED) {",
            "\t\t/*",
            "\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now",
            "\t\t * remove the new functions from the func_stack.",
            "\t\t */",
            "\t\tklp_unpatch_objects(klp_transition_patch);",
            "",
            "\t\t/*",
            "\t\t * Make sure klp_ftrace_handler() can no longer see functions",
            "\t\t * from this patch on the ops->func_stack.  Otherwise, after",
            "\t\t * func->transition gets cleared, the handler may choose a",
            "\t\t * removed function.",
            "\t\t */",
            "\t\tklp_synchronize_transition();",
            "\t}",
            "",
            "\tklp_for_each_object(klp_transition_patch, obj)",
            "\t\tklp_for_each_func(obj, func)",
            "\t\t\tfunc->transition = false;",
            "",
            "\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */",
            "\tif (klp_target_state == KLP_PATCHED)",
            "\t\tklp_synchronize_transition();",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task) {",
            "\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));",
            "\t\ttask->patch_state = KLP_UNDEFINED;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));",
            "\t\ttask->patch_state = KLP_UNDEFINED;",
            "\t}",
            "",
            "\tklp_for_each_object(klp_transition_patch, obj) {",
            "\t\tif (!klp_is_object_loaded(obj))",
            "\t\t\tcontinue;",
            "\t\tif (klp_target_state == KLP_PATCHED)",
            "\t\t\tklp_post_patch_callback(obj);",
            "\t\telse if (klp_target_state == KLP_UNPATCHED)",
            "\t\t\tklp_post_unpatch_callback(obj);",
            "\t}",
            "",
            "\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,",
            "\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\tklp_target_state = KLP_UNDEFINED;",
            "\tklp_transition_patch = NULL;",
            "}",
            "void klp_cancel_transition(void)",
            "{",
            "\tif (WARN_ON_ONCE(klp_target_state != KLP_PATCHED))",
            "\t\treturn;",
            "",
            "\tpr_debug(\"'%s': canceling patching transition, going to unpatch\\n\",",
            "\t\t klp_transition_patch->mod->name);",
            "",
            "\tklp_target_state = KLP_UNPATCHED;",
            "\tklp_complete_transition();",
            "}",
            "void klp_update_patch_state(struct task_struct *task)",
            "{",
            "\t/*",
            "\t * A variant of synchronize_rcu() is used to allow patching functions",
            "\t * where RCU is not watching, see klp_synchronize_transition().",
            "\t */",
            "\tpreempt_disable_notrace();",
            "",
            "\t/*",
            "\t * This test_and_clear_tsk_thread_flag() call also serves as a read",
            "\t * barrier (smp_rmb) for two cases:",
            "\t *",
            "\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the",
            "\t *    klp_target_state read.  The corresponding write barriers are in",
            "\t *    klp_init_transition() and klp_reverse_transition().",
            "\t *",
            "\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read",
            "\t *    of func->transition, if klp_ftrace_handler() is called later on",
            "\t *    the same CPU.  See __klp_disable_patch().",
            "\t */",
            "\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))",
            "\t\ttask->patch_state = READ_ONCE(klp_target_state);",
            "",
            "\tpreempt_enable_notrace();",
            "}"
          ],
          "function_name": "klp_transition_work_fn, klp_sync, klp_synchronize_transition, klp_complete_transition, klp_cancel_transition, klp_update_patch_state",
          "description": "实现热补丁过渡的核心协程逻辑，包含任务状态同步、补丁完成处理、取消操作及状态更新，通过循环遍历进程和空闲任务确保全部迁移",
          "similarity": 0.5299276113510132
        }
      ]
    },
    {
      "source_file": "kernel/power/console.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:19:20\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\console.c`\n\n---\n\n# power/console.c 技术文档\n\n## 1. 文件概述\n\n`power/console.c` 是 Linux 内核电源管理子系统中的一个组件，负责在系统挂起（suspend）和恢复（resume）过程中对控制台（console）进行保存与恢复操作。其主要目标是通过虚拟终端（VT）切换机制，确保在系统休眠期间控制台状态的正确性和可视性，同时支持部分图形或控制台驱动实现“无闪烁”（flicker-free）的挂起/恢复流程。\n\n该文件最初源自 `swsusp`（Software Suspend）项目，现用于协调多个控制台驱动对 VT 切换的需求，避免不必要的屏幕闪烁，并在必要时将内核日志重定向到专用的挂起控制台。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `pm_vt_switch_required(struct device *dev, bool required)`  \n  注册设备对 VT 切换的需求。若 `required` 为 `true`，表示该设备驱动在挂起/恢复时需要进行 VT 切换；若为 `false`，则表示支持无切换挂起。\n\n- `pm_vt_switch_unregister(struct device *dev)`  \n  注销设备的 VT 切换需求，将其从跟踪列表中移除。\n\n- `pm_prepare_console(void)`  \n  在系统挂起前准备控制台：若需要 VT 切换，则切换到专用的挂起控制台（`SUSPEND_CONSOLE`），并重定向内核消息输出。\n\n- `pm_restore_console(void)`  \n  在系统恢复后还原控制台：切换回原始前台控制台，并恢复内核消息的原始重定向目标。\n\n### 主要数据结构\n\n- `struct pm_vt_switch`  \n  表示一个设备对 VT 切换的需求：\n  ```c\n  struct pm_vt_switch {\n      struct list_head head;   // 链表节点\n      struct device *dev;      // 关联的设备\n      bool required;           // 是否需要 VT 切换\n  };\n  ```\n\n- 全局变量：\n  - `orig_fgconsole`：原始前台控制台编号。\n  - `orig_kmsg`：原始内核消息重定向目标控制台。\n  - `vt_switch_done`：标志位，表示是否已执行 VT 切换。\n  - `pm_vt_switch_list`：所有注册设备的 VT 切换需求链表。\n  - `vt_switch_mutex`：保护链表操作的互斥锁。\n\n## 3. 关键实现\n\n### VT 切换决策逻辑（`pm_vt_switch()`）\n\n系统是否执行 VT 切换由以下三个条件之一触发：\n1. **无任何驱动注册需求**：保留传统行为（默认切换）。\n2. **`console_suspend_enabled` 被禁用**（通过内核命令行参数 `no_console_suspend`）：需显示挂起/恢复期间的调试信息。\n3. **任一已注册驱动声明需要 VT 切换**（`required == true`）。\n\n只有当**所有已注册驱动都明确声明不需要 VT 切换**，且 `console_suspend_enabled` 为 `true` 时，才可跳过 VT 切换，实现无闪烁恢复。\n\n### 控制台保存与恢复流程\n\n- **挂起前（`pm_prepare_console`）**：\n  - 若需切换，调用 `vt_move_to_console(SUSPEND_CONSOLE, 1)` 切换到专用控制台（编号 `MAX_NR_CONSOLES-1`）。\n  - 使用 `vt_kmsg_redirect()` 将内核日志重定向至该控制台。\n  - 记录原始前台控制台编号和原始重定向目标。\n\n- **恢复后（`pm_restore_console`）**：\n  - 若曾执行切换，调用 `vt_move_to_console(orig_fgconsole, 0)` 切回原前台控制台。\n  - 恢复内核消息重定向至原始目标。\n  - 清除 `vt_switch_done` 标志。\n\n### 线程安全\n\n所有对 `pm_vt_switch_list` 的访问均受 `vt_switch_mutex` 互斥锁保护，确保在并发注册/注销场景下的数据一致性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/console.h>`：控制台核心接口。\n  - `<linux/vt_kern.h>` 和 `<linux/vt.h>`：虚拟终端内核接口，提供 `vt_move_to_console()` 和 `vt_kmsg_redirect()`。\n  - `<linux/kbd_kern.h>`：键盘相关（虽未直接使用，但 VT 子系统依赖）。\n  - `\"power.h\"`：本地电源管理头文件（可能定义 `console_suspend_enabled` 等）。\n\n- **内核子系统依赖**：\n  - **VT 子系统**：提供虚拟终端管理和切换能力。\n  - **电源管理核心（PM Core）**：本文件被 PM Core 在挂起/恢复流程中调用。\n  - **控制台驱动**：如 `fbcon`、`vgacon` 等可通过 `pm_vt_switch_required()` 声明自身需求。\n\n- **导出符号**：\n  - `pm_vt_switch_required` 和 `pm_vt_switch_unregister` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如显卡驱动）调用。\n\n## 5. 使用场景\n\n- **系统挂起/恢复流程**：  \n  在 `suspend` 阶段调用 `pm_prepare_console()`，在 `resume` 阶段调用 `pm_restore_console()`，确保控制台状态一致。\n\n- **图形驱动优化**：  \n  支持现代显示驱动（如 DRM/KMS 驱动）在挂起/恢复时自行管理显示状态，无需 VT 切换，从而避免屏幕闪烁，提升用户体验。\n\n- **调试支持**：  \n  当启用 `no_console_suspend` 内核参数时，强制进行 VT 切换并将内核日志输出到可见控制台，便于调试挂起/恢复问题。\n\n- **多控制台环境协调**：  \n  在存在多个控制台驱动（如文本控制台与帧缓冲控制台共存）时，统一协调 VT 切换策略，防止冲突。",
      "similarity": 0.5697784423828125,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/power/console.c",
          "start_line": 47,
          "end_line": 132,
          "content": [
            "void pm_vt_switch_required(struct device *dev, bool required)",
            "{",
            "\tstruct pm_vt_switch *entry, *tmp;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {",
            "\t\tif (tmp->dev == dev) {",
            "\t\t\t/* already registered, update requirement */",
            "\t\t\ttmp->required = required;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);",
            "\tif (!entry)",
            "\t\tgoto out;",
            "",
            "\tentry->required = required;",
            "\tentry->dev = dev;",
            "",
            "\tlist_add(&entry->head, &pm_vt_switch_list);",
            "out:",
            "\tmutex_unlock(&vt_switch_mutex);",
            "}",
            "void pm_vt_switch_unregister(struct device *dev)",
            "{",
            "\tstruct pm_vt_switch *tmp;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {",
            "\t\tif (tmp->dev == dev) {",
            "\t\t\tlist_del(&tmp->head);",
            "\t\t\tkfree(tmp);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&vt_switch_mutex);",
            "}",
            "static bool pm_vt_switch(void)",
            "{",
            "\tstruct pm_vt_switch *entry;",
            "\tbool ret = true;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tif (list_empty(&pm_vt_switch_list))",
            "\t\tgoto out;",
            "",
            "\tif (!console_suspend_enabled)",
            "\t\tgoto out;",
            "",
            "\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {",
            "\t\tif (entry->required)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tret = false;",
            "out:",
            "\tmutex_unlock(&vt_switch_mutex);",
            "\treturn ret;",
            "}",
            "void pm_prepare_console(void)",
            "{",
            "\tif (!pm_vt_switch())",
            "\t\treturn;",
            "",
            "\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);",
            "\tif (orig_fgconsole < 0)",
            "\t\treturn;",
            "",
            "\tvt_switch_done = true;",
            "",
            "\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);",
            "\treturn;",
            "}",
            "void pm_restore_console(void)",
            "{",
            "\tif (!pm_vt_switch() && !vt_switch_done)",
            "\t\treturn;",
            "",
            "\tif (orig_fgconsole >= 0) {",
            "\t\tvt_move_to_console(orig_fgconsole, 0);",
            "\t\tvt_kmsg_redirect(orig_kmsg);",
            "\t}",
            "",
            "\tvt_switch_done = false;",
            "}"
          ],
          "function_name": "pm_vt_switch_required, pm_vt_switch_unregister, pm_vt_switch, pm_prepare_console, pm_restore_console",
          "description": "实现VT切换需求注册/注销操作，判断是否需执行VT切换的辅助函数，以及准备/恢复控制台状态的完整流程，包含控制台切换和kmsg重定向的原子操作",
          "similarity": 0.5293712019920349
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/power/console.c",
          "start_line": 1,
          "end_line": 46,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Functions for saving/restoring console.",
            " *",
            " * Originally from swsusp.",
            " */",
            "",
            "#include <linux/console.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include \"power.h\"",
            "",
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)",
            "",
            "static int orig_fgconsole, orig_kmsg;",
            "static bool vt_switch_done;",
            "",
            "static DEFINE_MUTEX(vt_switch_mutex);",
            "",
            "struct pm_vt_switch {",
            "\tstruct list_head head;",
            "\tstruct device *dev;",
            "\tbool required;",
            "};",
            "",
            "static LIST_HEAD(pm_vt_switch_list);",
            "",
            "",
            "/**",
            " * pm_vt_switch_required - indicate VT switch at suspend requirements",
            " * @dev: device",
            " * @required: if true, caller needs VT switch at suspend/resume time",
            " *",
            " * The different console drivers may or may not require VT switches across",
            " * suspend/resume, depending on how they handle restoring video state and",
            " * what may be running.",
            " *",
            " * Drivers can indicate support for switchless suspend/resume, which can",
            " * save time and flicker, by using this routine and passing 'false' as",
            " * the argument.  If any loaded driver needs VT switching, or the",
            " * no_console_suspend argument has been passed on the command line, VT",
            " * switches will occur.",
            " */"
          ],
          "function_name": null,
          "description": "定义控制台保存/恢复相关全局变量及结构体，用于记录原始前台控制台和kmsg重定向信息，声明PM VT切换需求管理接口，包含VT切换所需锁和链表结构",
          "similarity": 0.49162882566452026
        }
      ]
    },
    {
      "source_file": "kernel/static_call_inline.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:29:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `static_call_inline.c`\n\n---\n\n# static_call_inline.c 技术文档\n\n## 1. 文件概述\n\n`static_call_inline.c` 是 Linux 内核中实现 **静态调用（Static Call）** 机制的核心文件之一。静态调用是一种运行时可动态更新的函数调用优化技术，它在编译时将函数调用点内联为对跳板（trampoline）的直接跳转，而在运行时可通过 `__static_call_update()` 动态修改所有调用点，使其跳转到新的目标函数，从而避免传统函数指针调用的间接开销。该机制常用于性能敏感路径（如调度、RCU、tracepoint 等），同时支持模块热插拔和初始化阶段的特殊处理。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `static_call_force_reinit(void)`  \n  强制重新初始化静态调用机制，用于调试或特殊场景，必须在 `early_initcall()` 之前调用。\n\n- `__static_call_update(struct static_call_key *key, void *tramp, void *func)`  \n  核心更新函数：将指定 `key` 对应的所有静态调用点更新为调用 `func`，并更新跳板 `tramp`。支持内核和模块中的调用点。\n\n- `__static_call_init(struct module *mod, struct static_call_site *start, struct static_call_site *stop)`  \n  初始化静态调用站点，对站点按 `key` 排序，并建立 `key` 到站点的映射关系，同时执行首次 `arch_static_call_transform`。\n\n- `__static_call_text_reserved(...)`  \n  检查指定代码区间是否与活跃的静态调用站点冲突，用于内存热插拔或代码修改前的安全校验。\n\n### 主要数据结构\n\n- `struct static_call_site`  \n  描述一个静态调用点的位置（`addr`）和关联的 `key`（带标志位）。\n\n- `struct static_call_key`  \n  静态调用的“键”，用于将多个调用点分组。包含当前函数指针 `func` 和类型/模块信息。\n\n- `struct static_call_mod`  \n  用于模块场景下，将模块与该模块中属于某 `key` 的调用点列表关联。\n\n- 全局符号：\n  - `__start_static_call_sites[]` / `__stop_static_call_sites[]`：内核镜像中所有静态调用点的链接器生成数组。\n  - `__start_static_call_tramp_key[]` / `__stop_static_call_tramp_key[]`：跳板与 key 的映射。\n\n### 辅助函数与宏\n\n- `static_call_addr(site)`：计算调用点的实际地址（处理重定位）。\n- `static_call_key(site)`：从站点中提取 `static_call_key*`（忽略标志位）。\n- `static_call_is_init(site)` / `static_call_is_tail(site)`：检查站点是否位于 `__init` 段或是否为尾调用。\n- `static_call_sort_entries()`：对站点按 `key` 排序，便于批量处理。\n- `static_call_key_has_mods()` / `static_call_key_sites()`：判断 key 是否关联模块或直接站点。\n\n## 3. 关键实现\n\n### 地址重定位处理\n由于静态调用站点在编译时使用相对地址存储，`static_call_addr()` 和 `__static_call_key()` 通过 `(long)field + (long)&field` 的方式计算出运行时绝对地址，这是处理位置无关代码（PIC）和内核重定位的关键技巧。\n\n### 站点组织与模块支持\n- **内核（vmlinux）场景**：为节省内存和避免早期内存分配，将首个站点指针直接编码到 `key->type` 的低有效位中（通过 `| 1` 标记）。\n- **模块场景**：使用 `static_call_mod` 链表管理不同模块中属于同一 `key` 的站点，支持模块加载/卸载时的动态注册。\n\n### 初始化与更新流程\n1. **初始化**（`__static_call_init`）：\n   - 对站点按 `key` 排序。\n   - 标记位于 `__init` 段的站点（后续更新可跳过）。\n   - 建立 `key` 到站点的映射。\n   - 调用架构相关 `arch_static_call_transform` 执行首次转换（通常设为跳板）。\n\n2. **更新**（`__static_call_update`）：\n   - 更新 `key->func`。\n   - 更新跳板 `tramp` 指向新函数。\n   - 遍历所有关联站点（包括模块），调用 `arch_static_call_transform` 修改调用点指令（如 x86 的 `jmp` 目标）。\n   - 跳过 `__init` 段中已初始化的站点（因不会被执行）。\n\n### 安全与并发控制\n- 使用 `cpus_read_lock()` 防止 CPU 热插拔期间的并发问题。\n- 使用 `static_call_mutex` 保护 `key` 和站点数据结构的修改。\n- 通过 `kernel_text_address()` 验证调用点是否在可执行内核文本段，避免修改无效地址。\n\n## 4. 依赖关系\n\n- **架构依赖**：依赖 `asm/sections.h` 和 `arch_static_call_transform()`（由各架构实现，如 x86、ARM64）。\n- **内核子系统**：\n  - `linux/module.h`：模块加载/卸载时的静态调用站点管理。\n  - `linux/cpu.h` / `linux/smp.h`：CPU 热插拔和并发控制。\n  - `linux/sort.h`：站点排序。\n  - `linux/slab.h`：模块场景下的动态内存分配。\n- **链接器脚本**：依赖链接器生成的 `__start/stop_static_call_sites` 等符号，这些在 `vmlinux.lds` 中定义。\n\n## 5. 使用场景\n\n- **内核核心优化**：在调度器、RCU、中断处理等高频路径中替代函数指针，减少间接调用开销。\n- **动态追踪（ftrace）**：作为 tracepoint 或 kprobe 的底层机制，实现零开销探针。\n- **模块热插拔**：模块加载时注册其静态调用站点，卸载时自动清理，确保调用点始终有效。\n- **初始化优化**：`__init` 段的调用点在初始化完成后可被安全忽略，减少运行时开销。\n- **安全代码修改**：在 livepatch 或内核热补丁中，安全地替换函数实现而不影响运行中的调用。",
      "similarity": 0.5643073320388794,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 220,
          "end_line": 340,
          "content": [
            "static int __static_call_init(struct module *mod,",
            "\t\t\t      struct static_call_site *start,",
            "\t\t\t      struct static_call_site *stop)",
            "{",
            "\tstruct static_call_site *site;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod;",
            "",
            "\tif (start == stop)",
            "\t\treturn 0;",
            "",
            "\tstatic_call_sort_entries(start, stop);",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||",
            "\t\t    (!mod && init_section_contains(site_addr, 1)))",
            "\t\t\tstatic_call_set_init(site);",
            "",
            "\t\tkey = static_call_key(site);",
            "\t\tif (key != prev_key) {",
            "\t\t\tprev_key = key;",
            "",
            "\t\t\t/*",
            "\t\t\t * For vmlinux (!mod) avoid the allocation by storing",
            "\t\t\t * the sites pointer in the key itself. Also see",
            "\t\t\t * __static_call_update()'s @first.",
            "\t\t\t *",
            "\t\t\t * This allows architectures (eg. x86) to call",
            "\t\t\t * static_call_init() before memory allocation works.",
            "\t\t\t */",
            "\t\t\tif (!mod) {",
            "\t\t\t\tkey->sites = site;",
            "\t\t\t\tkey->type |= 1;",
            "\t\t\t\tgoto do_transform;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\tif (!site_mod)",
            "\t\t\t\treturn -ENOMEM;",
            "",
            "\t\t\t/*",
            "\t\t\t * When the key has a direct sites pointer, extract",
            "\t\t\t * that into an explicit struct static_call_mod, so we",
            "\t\t\t * can have a list of modules.",
            "\t\t\t */",
            "\t\t\tif (static_call_key_sites(key)) {",
            "\t\t\t\tsite_mod->mod = NULL;",
            "\t\t\t\tsite_mod->next = NULL;",
            "\t\t\t\tsite_mod->sites = static_call_key_sites(key);",
            "",
            "\t\t\t\tkey->mods = site_mod;",
            "",
            "\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\t\tif (!site_mod)",
            "\t\t\t\t\treturn -ENOMEM;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod->mod = mod;",
            "\t\t\tsite_mod->sites = site;",
            "\t\t\tsite_mod->next = static_call_key_next(key);",
            "\t\t\tkey->mods = site_mod;",
            "\t\t}",
            "",
            "do_transform:",
            "\t\tarch_static_call_transform(site_addr, NULL, key->func,",
            "\t\t\t\tstatic_call_is_tail(site));",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int addr_conflict(struct static_call_site *site, void *start, void *end)",
            "{",
            "\tunsigned long addr = (unsigned long)static_call_addr(site);",
            "",
            "\tif (addr <= (unsigned long)end &&",
            "\t    addr + CALL_INSN_SIZE > (unsigned long)start)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_text_reserved(struct static_call_site *iter_start,",
            "\t\t\t\t       struct static_call_site *iter_stop,",
            "\t\t\t\t       void *start, void *end, bool init)",
            "{",
            "\tstruct static_call_site *iter = iter_start;",
            "",
            "\twhile (iter < iter_stop) {",
            "\t\tif (init || !static_call_is_init(iter)) {",
            "\t\t\tif (addr_conflict(iter, start, end))",
            "\t\t\t\treturn 1;",
            "\t\t}",
            "\t\titer++;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\tstruct module *mod;",
            "\tint ret;",
            "",
            "\tpreempt_disable();",
            "\tmod = __module_text_address((unsigned long)start);",
            "\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);",
            "\tif (!try_module_get(mod))",
            "\t\tmod = NULL;",
            "\tpreempt_enable();",
            "",
            "\tif (!mod)",
            "\t\treturn 0;",
            "",
            "\tret = __static_call_text_reserved(mod->static_call_sites,",
            "\t\t\tmod->static_call_sites + mod->num_static_call_sites,",
            "\t\t\tstart, end, mod->state == MODULE_STATE_COMING);",
            "",
            "\tmodule_put(mod);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__static_call_init, addr_conflict, __static_call_text_reserved, __static_call_mod_text_reserved",
          "description": "执行静态调用初始化流程，分配模块关联结构体并进行地址转换，实现文本区域预留检查以避免内存覆盖。",
          "similarity": 0.5953561067581177
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 347,
          "end_line": 449,
          "content": [
            "static unsigned long tramp_key_lookup(unsigned long addr)",
            "{",
            "\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *tramp_key;",
            "",
            "\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {",
            "\t\tunsigned long tramp;",
            "",
            "\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;",
            "\t\tif (tramp == addr)",
            "\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int static_call_add_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = start + mod->num_static_call_sites;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn 0;",
            "#endif",
            "",
            "\tfor (site = start; site != stop; site++) {",
            "\t\tunsigned long s_key = __static_call_key(site);",
            "\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;",
            "\t\tunsigned long key;",
            "",
            "\t\t/*",
            "\t\t * Is the key is exported, 'addr' points to the key, which",
            "\t\t * means modules are allowed to call static_call_update() on",
            "\t\t * it.",
            "\t\t *",
            "\t\t * Otherwise, the key isn't exported, and 'addr' points to the",
            "\t\t * trampoline so we need to lookup the key.",
            "\t\t *",
            "\t\t * We go through this dance to prevent crazy modules from",
            "\t\t * abusing sensitive static calls.",
            "\t\t */",
            "\t\tif (!kernel_text_address(addr))",
            "\t\t\tcontinue;",
            "",
            "\t\tkey = tramp_key_lookup(addr);",
            "\t\tif (!key) {",
            "\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",",
            "\t\t\t\tstatic_call_addr(site));",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;",
            "\t\tsite->key = key - (long)&site->key;",
            "\t}",
            "",
            "\treturn __static_call_init(mod, start, stop);",
            "}",
            "static void static_call_del_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = mod->static_call_sites +",
            "\t\t\t\t\tmod->num_static_call_sites;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod, **prev;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn;",
            "#endif",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tkey = static_call_key(site);",
            "",
            "\t\t/*",
            "\t\t * If the key was not updated due to a memory allocation",
            "\t\t * failure in __static_call_init() then treating key::sites",
            "\t\t * as key::mods in the code below would cause random memory",
            "\t\t * access and #GP. In that case all subsequent sites have",
            "\t\t * not been touched either, so stop iterating.",
            "\t\t */",
            "\t\tif (!static_call_key_has_mods(key))",
            "\t\t\tbreak;",
            "",
            "\t\tif (key == prev_key)",
            "\t\t\tcontinue;",
            "",
            "\t\tprev_key = key;",
            "",
            "\t\tfor (prev = &key->mods, site_mod = key->mods;",
            "\t\t     site_mod && site_mod->mod != mod;",
            "\t\t     prev = &site_mod->next, site_mod = site_mod->next)",
            "\t\t\t;",
            "",
            "\t\tif (!site_mod)",
            "\t\t\tcontinue;",
            "",
            "\t\t*prev = site_mod->next;",
            "\t\tkfree(site_mod);",
            "\t}",
            "}"
          ],
          "function_name": "tramp_key_lookup, static_call_add_module, static_call_del_module",
          "description": "处理模块动态加载/卸载时的静态调用更新，通过键查找机制确保跨模块调用正确性，并维护静态调用站点的模块绑定关系。",
          "similarity": 0.5681087970733643
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 23,
          "end_line": 176,
          "content": [
            "void static_call_force_reinit(void)",
            "{",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\treturn;",
            "",
            "\tstatic_call_initialized++;",
            "}",
            "static void static_call_lock(void)",
            "{",
            "\tmutex_lock(&static_call_mutex);",
            "}",
            "static void static_call_unlock(void)",
            "{",
            "\tmutex_unlock(&static_call_mutex);",
            "}",
            "static inline unsigned long __static_call_key(const struct static_call_site *site)",
            "{",
            "\treturn (long)site->key + (long)&site->key;",
            "}",
            "static inline bool static_call_is_init(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;",
            "}",
            "static inline bool static_call_is_tail(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;",
            "}",
            "static inline void static_call_set_init(struct static_call_site *site)",
            "{",
            "\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -",
            "\t\t    (long)&site->key;",
            "}",
            "static int static_call_site_cmp(const void *_a, const void *_b)",
            "{",
            "\tconst struct static_call_site *a = _a;",
            "\tconst struct static_call_site *b = _b;",
            "\tconst struct static_call_key *key_a = static_call_key(a);",
            "\tconst struct static_call_key *key_b = static_call_key(b);",
            "",
            "\tif (key_a < key_b)",
            "\t\treturn -1;",
            "",
            "\tif (key_a > key_b)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static void static_call_site_swap(void *_a, void *_b, int size)",
            "{",
            "\tlong delta = (unsigned long)_a - (unsigned long)_b;",
            "\tstruct static_call_site *a = _a;",
            "\tstruct static_call_site *b = _b;",
            "\tstruct static_call_site tmp = *a;",
            "",
            "\ta->addr = b->addr  - delta;",
            "\ta->key  = b->key   - delta;",
            "",
            "\tb->addr = tmp.addr + delta;",
            "\tb->key  = tmp.key  + delta;",
            "}",
            "static inline void static_call_sort_entries(struct static_call_site *start,",
            "\t\t\t\t\t    struct static_call_site *stop)",
            "{",
            "\tsort(start, stop - start, sizeof(struct static_call_site),",
            "\t     static_call_site_cmp, static_call_site_swap);",
            "}",
            "static inline bool static_call_key_has_mods(struct static_call_key *key)",
            "{",
            "\treturn !(key->type & 1);",
            "}",
            "void __static_call_update(struct static_call_key *key, void *tramp, void *func)",
            "{",
            "\tstruct static_call_site *site, *stop;",
            "\tstruct static_call_mod *site_mod, first;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tif (key->func == func)",
            "\t\tgoto done;",
            "",
            "\tkey->func = func;",
            "",
            "\tarch_static_call_transform(NULL, tramp, func, false);",
            "",
            "\t/*",
            "\t * If uninitialized, we'll not update the callsites, but they still",
            "\t * point to the trampoline and we just patched that.",
            "\t */",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\tgoto done;",
            "",
            "\tfirst = (struct static_call_mod){",
            "\t\t.next = static_call_key_next(key),",
            "\t\t.mod = NULL,",
            "\t\t.sites = static_call_key_sites(key),",
            "\t};",
            "",
            "\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {",
            "\t\tbool init = system_state < SYSTEM_RUNNING;",
            "\t\tstruct module *mod = site_mod->mod;",
            "",
            "\t\tif (!site_mod->sites) {",
            "\t\t\t/*",
            "\t\t\t * This can happen if the static call key is defined in",
            "\t\t\t * a module which doesn't use it.",
            "\t\t\t *",
            "\t\t\t * It also happens in the has_mods case, where the",
            "\t\t\t * 'first' entry has no sites associated with it.",
            "\t\t\t */",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tstop = __stop_static_call_sites;",
            "",
            "\t\tif (mod) {",
            "#ifdef CONFIG_MODULES",
            "\t\t\tstop = mod->static_call_sites +",
            "\t\t\t       mod->num_static_call_sites;",
            "\t\t\tinit = mod->state == MODULE_STATE_COMING;",
            "#endif",
            "\t\t}",
            "",
            "\t\tfor (site = site_mod->sites;",
            "\t\t     site < stop && static_call_key(site) == key; site++) {",
            "\t\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\t\tif (!init && static_call_is_init(site))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * This skips patching built-in __exit, which",
            "\t\t\t\t * is part of init_section_contains() but is",
            "\t\t\t\t * not part of kernel_text_address().",
            "\t\t\t\t *",
            "\t\t\t\t * Skipping built-in __exit is fine since it",
            "\t\t\t\t * will never be executed.",
            "\t\t\t\t */",
            "\t\t\t\tWARN_ONCE(!static_call_is_init(site),",
            "\t\t\t\t\t  \"can't patch static call site at %pS\",",
            "\t\t\t\t\t  site_addr);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tarch_static_call_transform(site_addr, NULL, func,",
            "\t\t\t\t\t\t   static_call_is_tail(site));",
            "\t\t}",
            "\t}",
            "",
            "done:",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "static_call_force_reinit, static_call_lock, static_call_unlock, __static_call_key, static_call_is_init, static_call_is_tail, static_call_set_init, static_call_site_cmp, static_call_site_swap, static_call_sort_entries, static_call_key_has_mods, __static_call_update",
          "description": "实现静态调用的互斥锁控制、键值计算、站点排序及更新逻辑，包含地址冲突检测和模块间调用关系维护功能。",
          "similarity": 0.5664163827896118
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/init.h>",
            "#include <linux/static_call.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/cpu.h>",
            "#include <linux/processor.h>",
            "#include <asm/sections.h>",
            "",
            "extern struct static_call_site __start_static_call_sites[],",
            "\t\t\t       __stop_static_call_sites[];",
            "extern struct static_call_tramp_key __start_static_call_tramp_key[],",
            "\t\t\t\t    __stop_static_call_tramp_key[];",
            "",
            "int static_call_initialized;",
            "",
            "/*",
            " * Must be called before early_initcall() to be effective.",
            " */"
          ],
          "function_name": null,
          "description": "声明静态调用相关的全局变量和外部符号，定义静态调用初始化标志位，为后续静态调用站点管理和地址转换提供基础结构。",
          "similarity": 0.5622783899307251
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 453,
          "end_line": 552,
          "content": [
            "static int static_call_module_notify(struct notifier_block *nb,",
            "\t\t\t\t     unsigned long val, void *data)",
            "{",
            "\tstruct module *mod = data;",
            "\tint ret = 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tswitch (val) {",
            "\tcase MODULE_STATE_COMING:",
            "\t\tret = static_call_add_module(mod);",
            "\t\tif (ret) {",
            "\t\t\tpr_warn(\"Failed to allocate memory for static calls\\n\");",
            "\t\t\tstatic_call_del_module(mod);",
            "\t\t}",
            "\t\tbreak;",
            "\tcase MODULE_STATE_GOING:",
            "\t\tstatic_call_del_module(mod);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\treturn notifier_from_errno(ret);",
            "}",
            "int klp_static_call_register(struct module *mod)",
            "{",
            "\tint ret;",
            "",
            "\tret = static_call_module_notify(&static_call_module_nb, MODULE_STATE_COMING, mod);",
            "\treturn notifier_to_errno(ret);",
            "}",
            "static inline int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\treturn 0;",
            "}",
            "int static_call_text_reserved(void *start, void *end)",
            "{",
            "\tbool init = system_state < SYSTEM_RUNNING;",
            "\tint ret = __static_call_text_reserved(__start_static_call_sites,",
            "\t\t\t__stop_static_call_sites, start, end, init);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn __static_call_mod_text_reserved(start, end);",
            "}",
            "int __init static_call_init(void)",
            "{",
            "\tint ret;",
            "",
            "\t/* See static_call_force_reinit(). */",
            "\tif (static_call_initialized == 1)",
            "\t\treturn 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "\tret = __static_call_init(NULL, __start_static_call_sites,",
            "\t\t\t\t __stop_static_call_sites);",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate memory for static_call!\\n\");",
            "\t\tBUG();",
            "\t}",
            "",
            "#ifdef CONFIG_MODULES",
            "\tif (!static_call_initialized)",
            "\t\tregister_module_notifier(&static_call_module_nb);",
            "#endif",
            "",
            "\tstatic_call_initialized = 1;",
            "\treturn 0;",
            "}",
            "static int func_a(int x)",
            "{",
            "\treturn x+1;",
            "}",
            "static int func_b(int x)",
            "{",
            "\treturn x+2;",
            "}",
            "static int __init test_static_call_init(void)",
            "{",
            "      int i;",
            "",
            "      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {",
            "\t      struct static_call_data *scd = &static_call_data[i];",
            "",
            "              if (scd->func)",
            "                      static_call_update(sc_selftest, scd->func);",
            "",
            "              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);",
            "      }",
            "",
            "      return 0;",
            "}"
          ],
          "function_name": "static_call_module_notify, klp_static_call_register, __static_call_mod_text_reserved, static_call_text_reserved, static_call_init, func_a, func_b, test_static_call_init",
          "description": "实现模块状态变更通知机制，完成静态调用系统的初始化注册，包含测试函数用于验证静态调用逻辑的正确性。",
          "similarity": 0.5480641722679138
        }
      ]
    }
  ]
}