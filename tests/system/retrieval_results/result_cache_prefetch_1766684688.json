{
  "query": "cache prefetch",
  "timestamp": "2025-12-26 01:44:48",
  "retrieved_files": [
    {
      "source_file": "mm/shuffle.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:21:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `shuffle.c`\n\n---\n\n# shuffle.c 技术文档\n\n## 1. 文件概述\n\n`shuffle.c` 实现了 Linux 内核内存管理子系统中的**页面分配随机化（Page Allocation Shuffling）**功能。该机制通过在内存初始化阶段对空闲页面链表进行 Fisher-Yates 洗牌操作，降低物理页帧分配的可预测性，从而增强系统安全性，抵御基于内存布局预测的攻击（如堆喷射、地址泄露等）。该功能默认关闭，可通过内核启动参数 `shuffle=1` 启用。\n\n## 2. 核心功能\n\n### 数据结构与全局变量\n- `page_alloc_shuffle_key`：静态分支键（static key），用于运行时启用/禁用洗牌逻辑，减少未启用时的性能开销。\n- `shuffle_param`：模块参数布尔值，控制是否启用洗牌功能。\n- `shuffle_param_ops`：自定义模块参数操作集，用于处理 `shuffle` 参数的设置和读取。\n\n### 主要函数\n- `shuffle_param_set()`：解析并设置 `shuffle` 内核参数，若启用则激活 `page_alloc_shuffle_key`。\n- `shuffle_valid_page()`：验证指定 PFN 的页面是否满足洗牌条件（属于 buddy 系统、同 zone、空闲、相同 order 和 migratetype）。\n- `__shuffle_zone()`：对指定内存区域（zone）执行 Fisher-Yates 洗牌算法，随机交换同阶空闲页面。\n- `__shuffle_free_memory()`：遍历节点（pgdat）中所有 zone，依次调用 `shuffle_zone()` 进行洗牌。\n- `shuffle_pick_tail()`：提供轻量级随机位生成器，用于在分配时决定从链表头部还是尾部取页（增强运行时随机性）。\n\n## 3. 关键实现\n\n### 洗牌算法（Fisher-Yates）\n- **粒度**：以 `SHUFFLE_ORDER`（通常为 0，即单页）为单位进行洗牌。\n- **范围**：遍历 zone 内所有按 order 对齐的 PFN，对每个有效页面 `page_i` 随机选择另一个有效页面 `page_j` 进行交换。\n- **有效性校验**：通过 `shuffle_valid_page()` 确保交换双方均为 buddy 系统管理的空闲页，且具有相同的迁移类型（migratetype）。\n- **重试机制**：最多尝试 `SHUFFLE_RETRY`（10 次）寻找有效的随机目标页，避免因内存空洞导致失败。\n- **锁优化**：每处理 100 个页面后释放 zone 自旋锁并调度，防止长时间持锁影响系统响应。\n\n### 随机性来源\n- 使用 `get_random_long()` 获取高质量伪随机数作为洗牌索引。\n- `shuffle_pick_tail()` 使用无锁的 64 位随机状态生成器，每次返回最低位并右移，用于运行时分配策略的微调。\n\n### 安全性权衡\n- 明确承认不消除模运算偏差（modulo bias）或 PRNG 偏差，目标是“提高攻击门槛”而非完美随机。\n- 仅在内存初始化阶段（`__meminit`）执行一次洗牌，不影响运行时分配性能。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`、`<linux/mmzone.h>`：内存管理核心数据结构（`struct zone`, `struct page`）。\n  - `<linux/random.h>`：提供 `get_random_long()` 和 `get_random_u64()`。\n  - `\"internal.h\"`、`\"shuffle.h\"`：内核 MM 子系统内部接口及洗牌功能声明。\n- **功能依赖**：\n  - Buddy 分配器：依赖 `PageBuddy()`、`buddy_order()` 等接口判断页面状态。\n  - 页面迁移类型（Migratetype）：确保洗牌不破坏不同迁移类型页面的隔离。\n  - 静态分支（Static Keys）：通过 `static_branch_enable()` 动态启用洗牌路径。\n\n## 5. 使用场景\n\n- **安全加固**：在需要防范物理地址预测攻击的场景（如虚拟化宿主机、安全敏感设备）中启用，增加攻击者利用内存布局漏洞的难度。\n- **内核初始化**：在 `free_area_init_core()` 等内存子系统初始化流程中调用 `__shuffle_free_memory()`，对初始空闲内存进行一次性洗牌。\n- **运行时分配辅助**：`shuffle_pick_tail()` 被页面分配器调用，决定从空闲链表头/尾取页，进一步增加分配时序的不可预测性。\n- **调试支持**：通过 `pr_debug()` 输出洗牌失败或迁移类型不匹配的日志，便于问题诊断（需开启 `DEBUG_SHUFFLE`）。",
      "similarity": 0.5439450144767761,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/shuffle.c",
          "start_line": 16,
          "end_line": 121,
          "content": [
            "static __meminit int shuffle_param_set(const char *val,",
            "\t\tconst struct kernel_param *kp)",
            "{",
            "\tif (param_set_bool(val, kp))",
            "\t\treturn -EINVAL;",
            "\tif (*(bool *)kp->arg)",
            "\t\tstatic_branch_enable(&page_alloc_shuffle_key);",
            "\treturn 0;",
            "}",
            "void __meminit __shuffle_zone(struct zone *z)",
            "{",
            "\tunsigned long i, flags;",
            "\tunsigned long start_pfn = z->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(z);",
            "\tconst int order = SHUFFLE_ORDER;",
            "\tconst int order_pages = 1 << order;",
            "",
            "\tspin_lock_irqsave(&z->lock, flags);",
            "\tstart_pfn = ALIGN(start_pfn, order_pages);",
            "\tfor (i = start_pfn; i < end_pfn; i += order_pages) {",
            "\t\tunsigned long j;",
            "\t\tint migratetype, retry;",
            "\t\tstruct page *page_i, *page_j;",
            "",
            "\t\t/*",
            "\t\t * We expect page_i, in the sub-range of a zone being added",
            "\t\t * (@start_pfn to @end_pfn), to more likely be valid compared to",
            "\t\t * page_j randomly selected in the span @zone_start_pfn to",
            "\t\t * @spanned_pages.",
            "\t\t */",
            "\t\tpage_i = shuffle_valid_page(z, i, order);",
            "\t\tif (!page_i)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (retry = 0; retry < SHUFFLE_RETRY; retry++) {",
            "\t\t\t/*",
            "\t\t\t * Pick a random order aligned page in the zone span as",
            "\t\t\t * a swap target. If the selected pfn is a hole, retry",
            "\t\t\t * up to SHUFFLE_RETRY attempts find a random valid pfn",
            "\t\t\t * in the zone.",
            "\t\t\t */",
            "\t\t\tj = z->zone_start_pfn +",
            "\t\t\t\tALIGN_DOWN(get_random_long() % z->spanned_pages,",
            "\t\t\t\t\t\torder_pages);",
            "\t\t\tpage_j = shuffle_valid_page(z, j, order);",
            "\t\t\tif (page_j && page_j != page_i)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (retry >= SHUFFLE_RETRY) {",
            "\t\t\tpr_debug(\"%s: failed to swap %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Each migratetype corresponds to its own list, make sure the",
            "\t\t * types match otherwise we're moving pages to lists where they",
            "\t\t * do not belong.",
            "\t\t */",
            "\t\tmigratetype = get_pageblock_migratetype(page_i);",
            "\t\tif (get_pageblock_migratetype(page_j) != migratetype) {",
            "\t\t\tpr_debug(\"%s: migratetype mismatch %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tlist_swap(&page_i->lru, &page_j->lru);",
            "",
            "\t\tpr_debug(\"%s: swap: %#lx -> %#lx\\n\", __func__, i, j);",
            "",
            "\t\t/* take it easy on the zone lock */",
            "\t\tif ((i % (100 * order_pages)) == 0) {",
            "\t\t\tspin_unlock_irqrestore(&z->lock, flags);",
            "\t\t\tcond_resched();",
            "\t\t\tspin_lock_irqsave(&z->lock, flags);",
            "\t\t}",
            "\t}",
            "\tspin_unlock_irqrestore(&z->lock, flags);",
            "}",
            "void __meminit __shuffle_free_memory(pg_data_t *pgdat)",
            "{",
            "\tstruct zone *z;",
            "",
            "\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)",
            "\t\tshuffle_zone(z);",
            "}",
            "bool shuffle_pick_tail(void)",
            "{",
            "\tstatic u64 rand;",
            "\tstatic u8 rand_bits;",
            "\tbool ret;",
            "",
            "\t/*",
            "\t * The lack of locking is deliberate. If 2 threads race to",
            "\t * update the rand state it just adds to the entropy.",
            "\t */",
            "\tif (rand_bits == 0) {",
            "\t\trand_bits = 64;",
            "\t\trand = get_random_u64();",
            "\t}",
            "",
            "\tret = rand & 1;",
            "",
            "\trand_bits--;",
            "\trand >>= 1;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "shuffle_param_set, __shuffle_zone, __shuffle_free_memory, shuffle_pick_tail",
          "description": "shuffle_param_set设置参数并启用/禁用静态键；__shuffle_zone在内存区随机交换页面以打乱物理顺序；__shuffle_free_memory初始化时调用__shuffle_zone；shuffle_pick_tail生成随机布尔值用于选择尾部页",
          "similarity": 0.5114932060241699
        },
        {
          "chunk_id": 0,
          "file_path": "mm/shuffle.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright(c) 2018 Intel Corporation. All rights reserved.",
            "",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/random.h>",
            "#include <linux/moduleparam.h>",
            "#include \"internal.h\"",
            "#include \"shuffle.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(page_alloc_shuffle_key);",
            "",
            "static bool shuffle_param;",
            ""
          ],
          "function_name": null,
          "description": "定义静态键用于控制页面分配随机化功能，并声明参数变量shuffle_param，用于启用或禁用相关机制",
          "similarity": 0.3153318762779236
        }
      ]
    },
    {
      "source_file": "kernel/sched/core_sched.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:00:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\core_sched.c`\n\n---\n\n# `sched/core_sched.c` 技术文档\n\n## 1. 文件概述\n\n`sched/core_sched.c` 是 Linux 内核调度器中用于实现 **核心调度（Core Scheduling）** 功能的核心文件之一。核心调度是一种安全机制，旨在防止来自不同安全上下文的任务在同一个物理 CPU 核心（特别是超线程/SMT 共享核心）上并发执行，从而缓解侧信道攻击（如 Spectre、MDS 等）。\n\n该文件主要负责管理任务的 **调度 cookie**（`core_cookie`），通过引用计数的 cookie 对象将具有相同安全上下文的任务分组，确保只有拥有相同 cookie 的任务才能在同一个 CPU 核心上并发运行。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct sched_core_cookie`**  \n  表示一个调度 cookie，仅包含一个引用计数器 `refcnt`。其内存地址本身即作为 cookie 值使用。\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `sched_core_alloc_cookie()` | 分配一个新的 `sched_core_cookie` 对象，初始化引用计数为 1，并启用核心调度全局状态。返回 cookie 地址（转换为 `unsigned long`）。 |\n| `sched_core_put_cookie(unsigned long cookie)` | 释放 cookie 引用；若引用计数归零，则释放内存并关闭核心调度全局状态。 |\n| `sched_core_get_cookie(unsigned long cookie)` | 增加 cookie 引用计数，返回原 cookie 值。 |\n| `sched_core_update_cookie(struct task_struct *p, unsigned long cookie)` | 原子地更新任务 `p` 的 `core_cookie`，处理任务在运行队列中的入队/出队，并在必要时触发重调度。 |\n| `sched_core_clone_cookie(struct task_struct *p)` | 安全地复制任务 `p` 的当前 cookie（带锁保护），用于 fork 或共享操作。 |\n| `sched_core_fork(struct task_struct *p)` | 在 `fork()` 时初始化子任务的核心调度状态，继承父进程的 cookie。 |\n| `sched_core_free(struct task_struct *p)` | 在任务退出时释放其持有的 cookie 引用。 |\n| `__sched_core_set(struct task_struct *p, unsigned long cookie)` | 设置任务 `p` 的 cookie，自动处理引用计数的获取与释放。 |\n| `sched_core_share_pid(...)` | 用户空间通过 `prctl(PR_SCHED_CORE, ...)` 调用的核心接口，支持创建、查询、共享 cookie。 |\n| `__sched_core_account_forceidle(struct rq *rq)` | （仅当 `CONFIG_SCHEDSTATS` 启用）统计核心强制空闲（force-idle）时间，并分摊到相关任务。 |\n| `__sched_core_tick(struct rq *rq)` | 在调度 tick 中调用，用于更新强制空闲时间统计。 |\n\n## 3. 关键实现\n\n### Cookie 生命周期管理\n- Cookie 通过 `kmalloc` 动态分配，其地址作为唯一标识。\n- 使用 `refcount_t` 实现线程安全的引用计数。\n- `sched_core_get()` / `sched_core_put()` 控制全局核心调度使能状态。\n\n### 任务 Cookie 更新\n- 在 `task_rq_lock()` 保护下更新 `p->core_cookie`，确保调度器一致性。\n- 若任务已在运行队列中，先出队再根据新 cookie 决定是否重新入队。\n- 若任务正在 CPU 上运行，调用 `resched_curr()` 触发重调度，以确保新 cookie 策略立即生效。\n\n### 安全访问控制\n- 通过 `ptrace_may_access()` 检查调用者是否有权限操作目标进程的 cookie。\n- 仅当系统存在 SMT（超线程）时（`sched_smt_present` 为真），才允许使用核心调度功能。\n\n### prctl 接口支持\n- 支持四种命令：\n  - `PR_SCHED_CORE_CREATE`：创建新 cookie。\n  - `PR_SCHED_CORE_SHARE_TO`：将当前进程的 cookie 应用于目标进程（或进程组）。\n  - `PR_SCHED_CORE_SHARE_FROM`：将目标进程的 cookie 应用于当前进程。\n  - `PR_SCHED_CORE_GET`：获取目标进程的 cookie 哈希值（用于用户空间识别）。\n- 支持作用域：线程（`PIDTYPE_PID`）、线程组（`PIDTYPE_TGID`）、进程组（`PIDTYPE_PGID`）。\n\n### 强制空闲时间统计（`CONFIG_SCHEDSTATS`）\n- 当核心因 cookie 不兼容而进入强制空闲状态时，记录空闲时间。\n- 时间按 `core_forceidle_count / core_forceidle_occupation` 比例分摊到所有相关 CPU 上的非 idle 任务。\n- 通过 `__account_forceidle_time()` 更新任务的调度统计信息。\n\n## 4. 依赖关系\n\n- **调度器核心**：依赖 `kernel/sched/` 下的通用调度器基础设施，如 `task_rq_lock()`、`resched_curr()`、`rq` 结构等。\n- **SMT 检测**：依赖 `sched_smt_present` 静态分支判断系统是否支持超线程。\n- **内存管理**：使用 `kmalloc`/`kfree` 进行动态内存分配。\n- **进程管理**：依赖 `find_task_by_vpid()`、`tasklist_lock`、`do_each_pid_thread` 等进程遍历机制。\n- **安全机制**：依赖 `ptrace_may_access()` 进行权限检查。\n- **调度统计**：`__sched_core_account_forceidle` 依赖 `CONFIG_SCHEDSTATS` 和 `__account_forceidle_time`。\n\n## 5. 使用场景\n\n- **安全敏感应用**：如浏览器、虚拟机监控器（VMM）、加密服务等，需防止跨任务的侧信道攻击。\n- **用户空间控制**：通过 `prctl(PR_SCHED_CORE, ...)` 接口，应用程序可显式创建和共享调度 cookie，将信任的任务分组。\n- **进程 fork 行为**：子进程自动继承父进程的 cookie，确保同源任务保持调度兼容性。\n- **系统资源隔离**：在多租户或容器环境中，确保不同租户的任务不会在同一个物理核心上并发执行。\n- **性能调优与监控**：通过 `CONFIG_SCHEDSTATS` 收集核心强制空闲开销，评估安全策略对性能的影响。",
      "similarity": 0.5368984341621399,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 1,
          "end_line": 10,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "/*",
            " * A simple wrapper around refcount. An allocated sched_core_cookie's",
            " * address is used to compute the cookie of the task.",
            " */",
            "struct sched_core_cookie {",
            "\trefcount_t refcnt;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了 sched_core_cookie 结构体，用于核心调度系统中管理任务的 cookie 引用计数，通过结构体地址计算 cookie 值",
          "similarity": 0.4528267979621887
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 11,
          "end_line": 216,
          "content": [
            "static unsigned long sched_core_alloc_cookie(void)",
            "{",
            "\tstruct sched_core_cookie *ck = kmalloc(sizeof(*ck), GFP_KERNEL);",
            "\tif (!ck)",
            "\t\treturn 0;",
            "",
            "\trefcount_set(&ck->refcnt, 1);",
            "\tsched_core_get();",
            "",
            "\treturn (unsigned long)ck;",
            "}",
            "static void sched_core_put_cookie(unsigned long cookie)",
            "{",
            "\tstruct sched_core_cookie *ptr = (void *)cookie;",
            "",
            "\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {",
            "\t\tkfree(ptr);",
            "\t\tsched_core_put();",
            "\t}",
            "}",
            "static unsigned long sched_core_get_cookie(unsigned long cookie)",
            "{",
            "\tstruct sched_core_cookie *ptr = (void *)cookie;",
            "",
            "\tif (ptr)",
            "\t\trefcount_inc(&ptr->refcnt);",
            "",
            "\treturn cookie;",
            "}",
            "static unsigned long sched_core_update_cookie(struct task_struct *p,",
            "\t\t\t\t\t      unsigned long cookie)",
            "{",
            "\tunsigned long old_cookie;",
            "\tstruct rq_flags rf;",
            "\tstruct rq *rq;",
            "",
            "\trq = task_rq_lock(p, &rf);",
            "",
            "\t/*",
            "\t * Since creating a cookie implies sched_core_get(), and we cannot set",
            "\t * a cookie until after we've created it, similarly, we cannot destroy",
            "\t * a cookie until after we've removed it, we must have core scheduling",
            "\t * enabled here.",
            "\t */",
            "\tSCHED_WARN_ON((p->core_cookie || cookie) && !sched_core_enabled(rq));",
            "",
            "\tif (sched_core_enqueued(p))",
            "\t\tsched_core_dequeue(rq, p, DEQUEUE_SAVE);",
            "",
            "\told_cookie = p->core_cookie;",
            "\tp->core_cookie = cookie;",
            "",
            "\t/*",
            "\t * Consider the cases: !prev_cookie and !cookie.",
            "\t */",
            "\tif (cookie && task_on_rq_queued(p))",
            "\t\tsched_core_enqueue(rq, p);",
            "",
            "\t/*",
            "\t * If task is currently running, it may not be compatible anymore after",
            "\t * the cookie change, so enter the scheduler on its CPU to schedule it",
            "\t * away.",
            "\t *",
            "\t * Note that it is possible that as a result of this cookie change, the",
            "\t * core has now entered/left forced idle state. Defer accounting to the",
            "\t * next scheduling edge, rather than always forcing a reschedule here.",
            "\t */",
            "\tif (task_on_cpu(rq, p))",
            "\t\tresched_curr(rq);",
            "",
            "\ttask_rq_unlock(rq, p, &rf);",
            "",
            "\treturn old_cookie;",
            "}",
            "static unsigned long sched_core_clone_cookie(struct task_struct *p)",
            "{",
            "\tunsigned long cookie, flags;",
            "",
            "\traw_spin_lock_irqsave(&p->pi_lock, flags);",
            "\tcookie = sched_core_get_cookie(p->core_cookie);",
            "\traw_spin_unlock_irqrestore(&p->pi_lock, flags);",
            "",
            "\treturn cookie;",
            "}",
            "void sched_core_fork(struct task_struct *p)",
            "{",
            "\tRB_CLEAR_NODE(&p->core_node);",
            "\tp->core_cookie = sched_core_clone_cookie(current);",
            "}",
            "void sched_core_free(struct task_struct *p)",
            "{",
            "\tsched_core_put_cookie(p->core_cookie);",
            "}",
            "static void __sched_core_set(struct task_struct *p, unsigned long cookie)",
            "{",
            "\tcookie = sched_core_get_cookie(cookie);",
            "\tcookie = sched_core_update_cookie(p, cookie);",
            "\tsched_core_put_cookie(cookie);",
            "}",
            "int sched_core_share_pid(unsigned int cmd, pid_t pid, enum pid_type type,",
            "\t\t\t unsigned long uaddr)",
            "{",
            "\tunsigned long cookie = 0, id = 0;",
            "\tstruct task_struct *task, *p;",
            "\tstruct pid *grp;",
            "\tint err = 0;",
            "",
            "\tif (!static_branch_likely(&sched_smt_present))",
            "\t\treturn -ENODEV;",
            "",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD != PIDTYPE_PID);",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD_GROUP != PIDTYPE_TGID);",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_PROCESS_GROUP != PIDTYPE_PGID);",
            "",
            "\tif (type > PIDTYPE_PGID || cmd >= PR_SCHED_CORE_MAX || pid < 0 ||",
            "\t    (cmd != PR_SCHED_CORE_GET && uaddr))",
            "\t\treturn -EINVAL;",
            "",
            "\trcu_read_lock();",
            "\tif (pid == 0) {",
            "\t\ttask = current;",
            "\t} else {",
            "\t\ttask = find_task_by_vpid(pid);",
            "\t\tif (!task) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\treturn -ESRCH;",
            "\t\t}",
            "\t}",
            "\tget_task_struct(task);",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Check if this process has the right to modify the specified",
            "\t * process. Use the regular \"ptrace_may_access()\" checks.",
            "\t */",
            "\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\terr = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tswitch (cmd) {",
            "\tcase PR_SCHED_CORE_GET:",
            "\t\tif (type != PIDTYPE_PID || uaddr & 7) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tcookie = sched_core_clone_cookie(task);",
            "\t\tif (cookie) {",
            "\t\t\t/* XXX improve ? */",
            "\t\t\tptr_to_hashval((void *)cookie, &id);",
            "\t\t}",
            "\t\terr = put_user(id, (u64 __user *)uaddr);",
            "\t\tgoto out;",
            "",
            "\tcase PR_SCHED_CORE_CREATE:",
            "\t\tcookie = sched_core_alloc_cookie();",
            "\t\tif (!cookie) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase PR_SCHED_CORE_SHARE_TO:",
            "\t\tcookie = sched_core_clone_cookie(current);",
            "\t\tbreak;",
            "",
            "\tcase PR_SCHED_CORE_SHARE_FROM:",
            "\t\tif (type != PIDTYPE_PID) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tcookie = sched_core_clone_cookie(task);",
            "\t\t__sched_core_set(current, cookie);",
            "\t\tgoto out;",
            "",
            "\tdefault:",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (type == PIDTYPE_PID) {",
            "\t\t__sched_core_set(task, cookie);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tgrp = task_pid_type(task, type);",
            "",
            "\tdo_each_pid_thread(grp, type, p) {",
            "\t\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\t\terr = -EPERM;",
            "\t\t\tgoto out_tasklist;",
            "\t\t}",
            "\t} while_each_pid_thread(grp, type, p);",
            "",
            "\tdo_each_pid_thread(grp, type, p) {",
            "\t\t__sched_core_set(p, cookie);",
            "\t} while_each_pid_thread(grp, type, p);",
            "out_tasklist:",
            "\tread_unlock(&tasklist_lock);",
            "",
            "out:",
            "\tsched_core_put_cookie(cookie);",
            "\tput_task_struct(task);",
            "\treturn err;",
            "}"
          ],
          "function_name": "sched_core_alloc_cookie, sched_core_put_cookie, sched_core_get_cookie, sched_core_update_cookie, sched_core_clone_cookie, sched_core_fork, sched_core_free, __sched_core_set, sched_core_share_pid",
          "description": "实现了核心调度 cookie 的分配、释放、获取和更新机制，包含 cookie 分配/回收、任务核心绑定变更、进程克隆共享及核心调度策略控制等功能",
          "similarity": 0.4501427412033081
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 240,
          "end_line": 297,
          "content": [
            "void __sched_core_account_forceidle(struct rq *rq)",
            "{",
            "\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));",
            "\tu64 delta, now = rq_clock(rq->core);",
            "\tstruct rq *rq_i;",
            "\tstruct task_struct *p;",
            "\tint i;",
            "",
            "\tlockdep_assert_rq_held(rq);",
            "",
            "\tWARN_ON_ONCE(!rq->core->core_forceidle_count);",
            "",
            "\tif (rq->core->core_forceidle_start == 0)",
            "\t\treturn;",
            "",
            "\tdelta = now - rq->core->core_forceidle_start;",
            "\tif (unlikely((s64)delta <= 0))",
            "\t\treturn;",
            "",
            "\trq->core->core_forceidle_start = now;",
            "",
            "\tif (WARN_ON_ONCE(!rq->core->core_forceidle_occupation)) {",
            "\t\t/* can't be forced idle without a running task */",
            "\t} else if (rq->core->core_forceidle_count > 1 ||",
            "\t\t   rq->core->core_forceidle_occupation > 1) {",
            "\t\t/*",
            "\t\t * For larger SMT configurations, we need to scale the charged",
            "\t\t * forced idle amount since there can be more than one forced",
            "\t\t * idle sibling and more than one running cookied task.",
            "\t\t */",
            "\t\tdelta *= rq->core->core_forceidle_count;",
            "\t\tdelta = div_u64(delta, rq->core->core_forceidle_occupation);",
            "\t}",
            "",
            "\tfor_each_cpu(i, smt_mask) {",
            "\t\trq_i = cpu_rq(i);",
            "\t\tp = rq_i->core_pick ?: rq_i->curr;",
            "",
            "\t\tif (p == rq_i->idle)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Note: this will account forceidle to the current cpu, even",
            "\t\t * if it comes from our SMT sibling.",
            "\t\t */",
            "\t\t__account_forceidle_time(p, delta);",
            "\t}",
            "}",
            "void __sched_core_tick(struct rq *rq)",
            "{",
            "\tif (!rq->core->core_forceidle_count)",
            "\t\treturn;",
            "",
            "\tif (rq != rq->core)",
            "\t\tupdate_rq_clock(rq->core);",
            "",
            "\t__sched_core_account_forceidle(rq);",
            "}"
          ],
          "function_name": "__sched_core_account_forceidle, __sched_core_tick",
          "description": "提供强制空闲时间统计功能，通过遍历 SMT 核心计算并分摊强制空闲时间消耗，tick 中断触发强制空闲会计入逻辑",
          "similarity": 0.4060170650482178
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_sched_wakeup.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:35:56\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_sched_wakeup.c`\n\n---\n\n# `trace_sched_wakeup.c` 技术文档\n\n## 1. 文件概述\n\n`trace_sched_wakeup.c` 是 Linux 内核中用于追踪任务唤醒延迟（wakeup latency）的关键调度器跟踪模块。该文件实现了 **wakeup tracer**，用于记录从一个高优先级任务被唤醒（例如通过 `wake_up_process()`）到它实际获得 CPU 执行之间的时间延迟。该 tracer 主要用于实时系统性能分析和调度延迟调试，是内核 ftrace 框架的一部分。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `wakeup_trace`：指向当前 wakeup tracer 实例的 `struct trace_array`。\n- `tracer_enabled`：标记 tracer 是否启用。\n- `wakeup_task`：当前被追踪唤醒的目标任务。\n- `wakeup_cpu` / `wakeup_current_cpu`：记录目标任务所在 CPU 和当前执行 CPU。\n- `wakeup_prio`：目标任务的优先级（初始为 -1 表示无效）。\n- `wakeup_rt` / `wakeup_dl` / `tracing_dl`：标志位，分别表示是否为实时任务（RT）、截止时间任务（Deadline）以及是否正在追踪 Deadline 任务。\n- `wakeup_lock`：用于保护关键数据结构的自旋锁。\n\n### 主要函数\n- `func_prolog_preempt_disable()`：函数追踪的前置处理，用于判断是否应记录当前函数调用，并禁用抢占。\n- `wakeup_tracer_call()`：函数追踪回调函数，记录函数调用事件。\n- `wakeup_graph_entry()` / `wakeup_graph_return()`：函数图追踪（function graph tracer）的入口和返回钩子。\n- `register_wakeup_function()` / `unregister_wakeup_function()`：注册/注销函数追踪回调。\n- `wakeup_function_set()`：处理 `TRACE_ITER_FUNCTION` 标志变更。\n- `wakeup_flag_changed()`：处理 tracer 标志变化（如启用函数追踪或函数图追踪）。\n- `wakeup_print_line()` / `wakeup_print_header()`：格式化输出追踪结果。\n- `wakeup_trace_open()` / `wakeup_trace_close()`：追踪迭代器的打开/关闭回调。\n\n### 回调结构体\n- `fgraph_wakeup_ops`：定义了用于函数图追踪的入口和返回回调函数。\n\n## 3. 关键实现\n\n### 唤醒追踪机制\n- 当一个高优先级任务被唤醒时，wakeup tracer 会记录该任务信息（`wakeup_task`、`wakeup_prio`、CPU 等）。\n- 在后续调度过程中，tracer 会追踪从唤醒点到该任务实际运行之间的所有函数调用（如果启用了函数追踪）。\n- 通过比较时间戳，可计算出唤醒延迟（latency），并记录最大延迟值（`tr->max_latency`）。\n\n### 函数追踪集成\n- 若启用 `CONFIG_FUNCTION_TRACER`，tracer 会注册 `wakeup_tracer_call` 作为函数追踪回调。\n- 若同时启用 `CONFIG_FUNCTION_GRAPH_TRACER`，则使用 `fgraph_wakeup_ops` 实现函数调用图追踪，记录完整的调用栈。\n- 使用 `func_prolog_preempt_disable()` 确保只在追踪目标 CPU 上记录，并通过 `data->disabled` 原子计数防止嵌套追踪。\n\n### 并发与抢占控制\n- 使用 `preempt_disable_notrace()` 禁用抢占以保证追踪上下文一致性。\n- 使用 `local_irq_save/restore()` 保护关键追踪路径。\n- 通过 `arch_spinlock_t wakeup_lock` 保护共享状态（虽在代码片段中未直接使用，但为全局同步预留）。\n\n### 动态追踪模式切换\n- 支持在运行时切换普通函数追踪与函数图追踪模式（通过 `TRACE_ITER_DISPLAY_GRAPH` 标志）。\n- 切换时会重置追踪状态（`wakeup_reset`）并重新注册对应的追踪回调。\n\n## 4. 依赖关系\n\n- **ftrace 框架**：依赖 `ftrace.h` 提供的函数追踪基础设施。\n- **调度子系统**：通过 `trace/events/sched.h` 接收任务唤醒事件（如 `sched_wakeup`、`sched_wakeup_new`）。\n- **实时调度类**：包含对 `SCHED_FIFO`/`SCHED_RR`（RT）和 `SCHED_DEADLINE` 调度策略的特殊处理。\n- **函数图追踪**：若启用 `CONFIG_FUNCTION_GRAPH_TRACER`，依赖其回调机制和栈管理。\n- **内核符号解析**：通过 `kallsyms.h` 支持函数名解析（间接依赖）。\n\n## 5. 使用场景\n\n- **实时系统延迟分析**：用于测量高优先级 RT 或 Deadline 任务从唤醒到执行的延迟，验证系统是否满足实时性要求。\n- **调度器调试**：帮助开发者分析调度延迟来源，如中断处理、锁竞争、低优先级任务占用 CPU 等。\n- **性能调优**：结合函数追踪或函数图追踪，定位导致唤醒延迟的具体代码路径。\n- **内核测试**：作为 `ftrace` 的标准 tracer 之一，可通过 `/sys/kernel/debug/tracing/current_tracer` 设置为 `wakeup` 或 `wakeup_rt` 进行测试。",
      "similarity": 0.5287924408912659,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 618,
          "end_line": 723,
          "content": [
            "static void start_wakeup_tracer(struct trace_array *tr)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_trace_sched_wakeup(probe_wakeup, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_wakeup\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_wakeup_new\\n\");",
            "\t\tgoto fail_deprobe;",
            "\t}",
            "",
            "\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_switch\\n\");",
            "\t\tgoto fail_deprobe_wake_new;",
            "\t}",
            "",
            "\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"",
            "\t\t\t\" probe to kernel_sched_migrate_task\\n\");",
            "\t\tgoto fail_deprobe_sched_switch;",
            "\t}",
            "",
            "\twakeup_reset(tr);",
            "",
            "\t/*",
            "\t * Don't let the tracer_enabled = 1 show up before",
            "\t * the wakeup_task is reset. This may be overkill since",
            "\t * wakeup_reset does a spin_unlock after setting the",
            "\t * wakeup_task to NULL, but I want to be safe.",
            "\t * This is a slow path anyway.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tif (start_func_tracer(tr, is_graph(tr)))",
            "\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");",
            "",
            "\treturn;",
            "fail_deprobe_sched_switch:",
            "\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);",
            "fail_deprobe_wake_new:",
            "\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);",
            "fail_deprobe:",
            "\tunregister_trace_sched_wakeup(probe_wakeup, NULL);",
            "}",
            "static void stop_wakeup_tracer(struct trace_array *tr)",
            "{",
            "\ttracer_enabled = 0;",
            "\tstop_func_tracer(tr, is_graph(tr));",
            "\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);",
            "\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);",
            "\tunregister_trace_sched_wakeup(probe_wakeup, NULL);",
            "\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);",
            "}",
            "static int __wakeup_tracer_init(struct trace_array *tr)",
            "{",
            "\tsave_flags = tr->trace_flags;",
            "",
            "\t/* non overwrite screws up the latency tracers */",
            "\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);",
            "\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);",
            "",
            "\ttr->max_latency = 0;",
            "\twakeup_trace = tr;",
            "\tftrace_init_array_ops(tr, wakeup_tracer_call);",
            "\tstart_wakeup_tracer(tr);",
            "",
            "\twakeup_busy = true;",
            "\treturn 0;",
            "}",
            "static int wakeup_tracer_init(struct trace_array *tr)",
            "{",
            "\tif (wakeup_busy)",
            "\t\treturn -EBUSY;",
            "",
            "\twakeup_dl = false;",
            "\twakeup_rt = false;",
            "\treturn __wakeup_tracer_init(tr);",
            "}",
            "static int wakeup_rt_tracer_init(struct trace_array *tr)",
            "{",
            "\tif (wakeup_busy)",
            "\t\treturn -EBUSY;",
            "",
            "\twakeup_dl = false;",
            "\twakeup_rt = true;",
            "\treturn __wakeup_tracer_init(tr);",
            "}",
            "static int wakeup_dl_tracer_init(struct trace_array *tr)",
            "{",
            "\tif (wakeup_busy)",
            "\t\treturn -EBUSY;",
            "",
            "\twakeup_dl = true;",
            "\twakeup_rt = false;",
            "\treturn __wakeup_tracer_init(tr);",
            "}"
          ],
          "function_name": "start_wakeup_tracer, stop_wakeup_tracer, __wakeup_tracer_init, wakeup_tracer_init, wakeup_rt_tracer_init, wakeup_dl_tracer_init",
          "description": "实现调度唤醒跟踪器的启动逻辑，注册 sched_wakeup、sched_switch 等 tracepoint 探针，处理注册失败时的资源清理，并通过 smp_wmb() 确保内存屏障顺序。",
          "similarity": 0.48229533433914185
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 309,
          "end_line": 430,
          "content": [
            "static void wakeup_trace_open(struct trace_iterator *iter) { }",
            "static void wakeup_trace_close(struct trace_iterator *iter) { }",
            "static void wakeup_print_header(struct seq_file *s)",
            "{",
            "\ttrace_default_header(s);",
            "}",
            "static void",
            "__trace_function(struct trace_array *tr,",
            "\t\t unsigned long ip, unsigned long parent_ip,",
            "\t\t unsigned int trace_ctx)",
            "{",
            "\tif (is_graph(tr))",
            "\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);",
            "\telse",
            "\t\ttrace_function(tr, ip, parent_ip, trace_ctx);",
            "}",
            "static int wakeup_flag_changed(struct trace_array *tr, u32 mask, int set)",
            "{",
            "\tstruct tracer *tracer = tr->current_trace;",
            "",
            "\tif (wakeup_function_set(tr, mask, set))",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_FUNCTION_GRAPH_TRACER",
            "\tif (mask & TRACE_ITER_DISPLAY_GRAPH)",
            "\t\treturn wakeup_display_graph(tr, set);",
            "#endif",
            "",
            "\treturn trace_keep_overwrite(tracer, mask, set);",
            "}",
            "static int start_func_tracer(struct trace_array *tr, int graph)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_wakeup_function(tr, graph, 0);",
            "",
            "\tif (!ret && tracing_is_enabled())",
            "\t\ttracer_enabled = 1;",
            "\telse",
            "\t\ttracer_enabled = 0;",
            "",
            "\treturn ret;",
            "}",
            "static void stop_func_tracer(struct trace_array *tr, int graph)",
            "{",
            "\ttracer_enabled = 0;",
            "",
            "\tunregister_wakeup_function(tr, graph);",
            "}",
            "static bool report_latency(struct trace_array *tr, u64 delta)",
            "{",
            "\tif (tracing_thresh) {",
            "\t\tif (delta < tracing_thresh)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\tif (delta <= tr->max_latency)",
            "\t\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void",
            "probe_wakeup_migrate_task(void *ignore, struct task_struct *task, int cpu)",
            "{",
            "\tif (task != wakeup_task)",
            "\t\treturn;",
            "",
            "\twakeup_current_cpu = cpu;",
            "}",
            "static void",
            "tracing_sched_switch_trace(struct trace_array *tr,",
            "\t\t\t   struct task_struct *prev,",
            "\t\t\t   struct task_struct *next,",
            "\t\t\t   unsigned int trace_ctx)",
            "{",
            "\tstruct trace_event_call *call = &event_context_switch;",
            "\tstruct trace_buffer *buffer = tr->array_buffer.buffer;",
            "\tstruct ring_buffer_event *event;",
            "\tstruct ctx_switch_entry *entry;",
            "",
            "\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,",
            "\t\t\t\t\t  sizeof(*entry), trace_ctx);",
            "\tif (!event)",
            "\t\treturn;",
            "\tentry\t= ring_buffer_event_data(event);",
            "\tentry->prev_pid\t\t\t= prev->pid;",
            "\tentry->prev_prio\t\t= prev->prio;",
            "\tentry->prev_state\t\t= task_state_index(prev);",
            "\tentry->next_pid\t\t\t= next->pid;",
            "\tentry->next_prio\t\t= next->prio;",
            "\tentry->next_state\t\t= task_state_index(next);",
            "\tentry->next_cpu\t= task_cpu(next);",
            "",
            "\tif (!call_filter_check_discard(call, entry, buffer, event))",
            "\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);",
            "}",
            "static void",
            "tracing_sched_wakeup_trace(struct trace_array *tr,",
            "\t\t\t   struct task_struct *wakee,",
            "\t\t\t   struct task_struct *curr,",
            "\t\t\t   unsigned int trace_ctx)",
            "{",
            "\tstruct trace_event_call *call = &event_wakeup;",
            "\tstruct ring_buffer_event *event;",
            "\tstruct ctx_switch_entry *entry;",
            "\tstruct trace_buffer *buffer = tr->array_buffer.buffer;",
            "",
            "\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,",
            "\t\t\t\t\t  sizeof(*entry), trace_ctx);",
            "\tif (!event)",
            "\t\treturn;",
            "\tentry\t= ring_buffer_event_data(event);",
            "\tentry->prev_pid\t\t\t= curr->pid;",
            "\tentry->prev_prio\t\t= curr->prio;",
            "\tentry->prev_state\t\t= task_state_index(curr);",
            "\tentry->next_pid\t\t\t= wakee->pid;",
            "\tentry->next_prio\t\t= wakee->prio;",
            "\tentry->next_state\t\t= task_state_index(wakee);",
            "\tentry->next_cpu\t\t\t= task_cpu(wakee);",
            "",
            "\tif (!call_filter_check_discard(call, entry, buffer, event))",
            "\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);",
            "}"
          ],
          "function_name": "wakeup_trace_open, wakeup_trace_close, wakeup_print_header, __trace_function, wakeup_flag_changed, start_func_tracer, stop_func_tracer, report_latency, probe_wakeup_migrate_task, tracing_sched_switch_trace, tracing_sched_wakeup_trace",
          "description": "实现任务切换和唤醒事件的记录功能，包含延迟上报判断、时间戳计算及事件数据的缓冲区管理。",
          "similarity": 0.47588619589805603
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 67,
          "end_line": 173,
          "content": [
            "static int",
            "func_prolog_preempt_disable(struct trace_array *tr,",
            "\t\t\t    struct trace_array_cpu **data,",
            "\t\t\t    unsigned int *trace_ctx)",
            "{",
            "\tlong disabled;",
            "\tint cpu;",
            "",
            "\tif (likely(!wakeup_task))",
            "\t\treturn 0;",
            "",
            "\t*trace_ctx = tracing_gen_ctx();",
            "\tpreempt_disable_notrace();",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\tif (cpu != wakeup_current_cpu)",
            "\t\tgoto out_enable;",
            "",
            "\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "\tdisabled = atomic_inc_return(&(*data)->disabled);",
            "\tif (unlikely(disabled != 1))",
            "\t\tgoto out;",
            "",
            "\treturn 1;",
            "",
            "out:",
            "\tatomic_dec(&(*data)->disabled);",
            "",
            "out_enable:",
            "\tpreempt_enable_notrace();",
            "\treturn 0;",
            "}",
            "static int wakeup_display_graph(struct trace_array *tr, int set)",
            "{",
            "\tif (!(is_graph(tr) ^ set))",
            "\t\treturn 0;",
            "",
            "\tstop_func_tracer(tr, !set);",
            "",
            "\twakeup_reset(wakeup_trace);",
            "\ttr->max_latency = 0;",
            "",
            "\treturn start_func_tracer(tr, set);",
            "}",
            "static int wakeup_graph_entry(struct ftrace_graph_ent *trace,",
            "\t\t\t      struct fgraph_ops *gops,",
            "\t\t\t      struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = wakeup_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint ret = 0;",
            "",
            "\tif (ftrace_graph_ignore_func(gops, trace))",
            "\t\treturn 0;",
            "\t/*",
            "\t * Do not trace a function if it's filtered by set_graph_notrace.",
            "\t * Make the index of ret stack negative to indicate that it should",
            "\t * ignore further functions.  But it needs its own ret stack entry",
            "\t * to recover the original index in order to continue tracing after",
            "\t * returning from the function.",
            "\t */",
            "\tif (ftrace_graph_notrace_addr(trace->func))",
            "\t\treturn 1;",
            "",
            "\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))",
            "\t\treturn 0;",
            "",
            "\tcalltime = fgraph_reserve_data(gops->idx, sizeof(*calltime));",
            "\tif (!calltime)",
            "\t\treturn 0;",
            "",
            "\t*calltime = trace_clock_local();",
            "",
            "\tret = __trace_graph_entry(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "\tpreempt_enable_notrace();",
            "",
            "\treturn ret;",
            "}",
            "static void wakeup_graph_return(struct ftrace_graph_ret *trace,",
            "\t\t\t\tstruct fgraph_ops *gops,",
            "\t\t\t\tstruct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = wakeup_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint size;",
            "",
            "\tftrace_graph_addr_finish(gops, trace);",
            "",
            "\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))",
            "\t\treturn;",
            "",
            "\tcalltime = fgraph_retrieve_data(gops->idx, &size);",
            "\tif (!calltime)",
            "\t\treturn;",
            "\ttrace->calltime = *calltime;",
            "",
            "\t__trace_graph_return(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "",
            "\tpreempt_enable_notrace();",
            "\treturn;",
            "}"
          ],
          "function_name": "func_prolog_preempt_disable, wakeup_display_graph, wakeup_graph_entry, wakeup_graph_return",
          "description": "实现抢占禁用、图形跟踪模式切换及函数入口/返回的跟踪逻辑，用于管理跟踪上下文和数据采集。",
          "similarity": 0.42719411849975586
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 445,
          "end_line": 613,
          "content": [
            "static void notrace",
            "probe_wakeup_sched_switch(void *ignore, bool preempt,",
            "\t\t\t  struct task_struct *prev, struct task_struct *next,",
            "\t\t\t  unsigned int prev_state)",
            "{",
            "\tstruct trace_array_cpu *data;",
            "\tu64 T0, T1, delta;",
            "\tunsigned long flags;",
            "\tlong disabled;",
            "\tint cpu;",
            "\tunsigned int trace_ctx;",
            "",
            "\ttracing_record_cmdline(prev);",
            "",
            "\tif (unlikely(!tracer_enabled))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * When we start a new trace, we set wakeup_task to NULL",
            "\t * and then set tracer_enabled = 1. We want to make sure",
            "\t * that another CPU does not see the tracer_enabled = 1",
            "\t * and the wakeup_task with an older task, that might",
            "\t * actually be the same as next.",
            "\t */",
            "\tsmp_rmb();",
            "",
            "\tif (next != wakeup_task)",
            "\t\treturn;",
            "",
            "\t/* disable local data, not wakeup_cpu data */",
            "\tcpu = raw_smp_processor_id();",
            "\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "\tif (likely(disabled != 1))",
            "\t\tgoto out;",
            "",
            "\tlocal_irq_save(flags);",
            "\ttrace_ctx = tracing_gen_ctx_flags(flags);",
            "",
            "\tarch_spin_lock(&wakeup_lock);",
            "",
            "\t/* We could race with grabbing wakeup_lock */",
            "\tif (unlikely(!tracer_enabled || next != wakeup_task))",
            "\t\tgoto out_unlock;",
            "",
            "\t/* The task we are waiting for is waking up */",
            "\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);",
            "",
            "\t__trace_function(wakeup_trace, CALLER_ADDR0, CALLER_ADDR1, trace_ctx);",
            "\ttracing_sched_switch_trace(wakeup_trace, prev, next, trace_ctx);",
            "\t__trace_stack(wakeup_trace, trace_ctx, 0);",
            "",
            "\tT0 = data->preempt_timestamp;",
            "\tT1 = ftrace_now(cpu);",
            "\tdelta = T1-T0;",
            "",
            "\tif (!report_latency(wakeup_trace, delta))",
            "\t\tgoto out_unlock;",
            "",
            "\tif (likely(!is_tracing_stopped())) {",
            "\t\twakeup_trace->max_latency = delta;",
            "\t\tupdate_max_tr(wakeup_trace, wakeup_task, wakeup_cpu, NULL);",
            "\t}",
            "",
            "out_unlock:",
            "\t__wakeup_reset(wakeup_trace);",
            "\tarch_spin_unlock(&wakeup_lock);",
            "\tlocal_irq_restore(flags);",
            "out:",
            "\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "}",
            "static void __wakeup_reset(struct trace_array *tr)",
            "{",
            "\twakeup_cpu = -1;",
            "\twakeup_prio = -1;",
            "\ttracing_dl = false;",
            "",
            "\tif (wakeup_task)",
            "\t\tput_task_struct(wakeup_task);",
            "",
            "\twakeup_task = NULL;",
            "}",
            "static void wakeup_reset(struct trace_array *tr)",
            "{",
            "\tunsigned long flags;",
            "",
            "\ttracing_reset_online_cpus(&tr->array_buffer);",
            "",
            "\tlocal_irq_save(flags);",
            "\tarch_spin_lock(&wakeup_lock);",
            "\t__wakeup_reset(tr);",
            "\tarch_spin_unlock(&wakeup_lock);",
            "\tlocal_irq_restore(flags);",
            "}",
            "static void",
            "probe_wakeup(void *ignore, struct task_struct *p)",
            "{",
            "\tstruct trace_array_cpu *data;",
            "\tint cpu = smp_processor_id();",
            "\tlong disabled;",
            "\tunsigned int trace_ctx;",
            "",
            "\tif (likely(!tracer_enabled))",
            "\t\treturn;",
            "",
            "\ttracing_record_cmdline(p);",
            "\ttracing_record_cmdline(current);",
            "",
            "\t/*",
            "\t * Semantic is like this:",
            "\t *  - wakeup tracer handles all tasks in the system, independently",
            "\t *    from their scheduling class;",
            "\t *  - wakeup_rt tracer handles tasks belonging to sched_dl and",
            "\t *    sched_rt class;",
            "\t *  - wakeup_dl handles tasks belonging to sched_dl class only.",
            "\t */",
            "\tif (tracing_dl || (wakeup_dl && !dl_task(p)) ||",
            "\t    (wakeup_rt && !rt_or_dl_task(p)) ||",
            "\t    (!dl_task(p) && (p->prio >= wakeup_prio || p->prio >= current->prio)))",
            "\t\treturn;",
            "",
            "\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "\tif (unlikely(disabled != 1))",
            "\t\tgoto out;",
            "",
            "\ttrace_ctx = tracing_gen_ctx();",
            "",
            "\t/* interrupts should be off from try_to_wake_up */",
            "\tarch_spin_lock(&wakeup_lock);",
            "",
            "\t/* check for races. */",
            "\tif (!tracer_enabled || tracing_dl ||",
            "\t    (!dl_task(p) && p->prio >= wakeup_prio))",
            "\t\tgoto out_locked;",
            "",
            "\t/* reset the trace */",
            "\t__wakeup_reset(wakeup_trace);",
            "",
            "\twakeup_cpu = task_cpu(p);",
            "\twakeup_current_cpu = wakeup_cpu;",
            "\twakeup_prio = p->prio;",
            "",
            "\t/*",
            "\t * Once you start tracing a -deadline task, don't bother tracing",
            "\t * another task until the first one wakes up.",
            "\t */",
            "\tif (dl_task(p))",
            "\t\ttracing_dl = true;",
            "\telse",
            "\t\ttracing_dl = false;",
            "",
            "\twakeup_task = get_task_struct(p);",
            "",
            "\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);",
            "\tdata->preempt_timestamp = ftrace_now(cpu);",
            "\ttracing_sched_wakeup_trace(wakeup_trace, p, current, trace_ctx);",
            "\t__trace_stack(wakeup_trace, trace_ctx, 0);",
            "",
            "\t/*",
            "\t * We must be careful in using CALLER_ADDR2. But since wake_up",
            "\t * is not called by an assembly function  (where as schedule is)",
            "\t * it should be safe to use it here.",
            "\t */",
            "\t__trace_function(wakeup_trace, CALLER_ADDR1, CALLER_ADDR2, trace_ctx);",
            "",
            "out_locked:",
            "\tarch_spin_unlock(&wakeup_lock);",
            "out:",
            "\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);",
            "}"
          ],
          "function_name": "probe_wakeup_sched_switch, __wakeup_reset, wakeup_reset, probe_wakeup",
          "description": "通过探针函数捕获任务唤醒事件，维护当前跟踪目标任务状态，同步时间戳并触发相应跟踪记录操作。",
          "similarity": 0.4140787720680237
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/trace/trace_sched_wakeup.c",
          "start_line": 732,
          "end_line": 772,
          "content": [
            "static void wakeup_tracer_reset(struct trace_array *tr)",
            "{",
            "\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;",
            "\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;",
            "",
            "\tstop_wakeup_tracer(tr);",
            "\t/* make sure we put back any tasks we are tracing */",
            "\twakeup_reset(tr);",
            "",
            "\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);",
            "\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);",
            "\tftrace_reset_array_ops(tr);",
            "\twakeup_busy = false;",
            "}",
            "static void wakeup_tracer_start(struct trace_array *tr)",
            "{",
            "\twakeup_reset(tr);",
            "\ttracer_enabled = 1;",
            "}",
            "static void wakeup_tracer_stop(struct trace_array *tr)",
            "{",
            "\ttracer_enabled = 0;",
            "}",
            "__init static int init_wakeup_tracer(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = register_tracer(&wakeup_tracer);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = register_tracer(&wakeup_rt_tracer);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = register_tracer(&wakeup_dl_tracer);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "wakeup_tracer_reset, wakeup_tracer_start, wakeup_tracer_stop, init_wakeup_tracer",
          "description": "提供调度唤醒跟踪器的重置、启动与停止接口，其中 init_wakeup_tracer 注册三种调度跟踪器（常规/实时/延迟）到内核跟踪系统。",
          "similarity": 0.4125356078147888
        }
      ]
    }
  ]
}