{
  "query": "time slicing",
  "timestamp": "2025-12-25 23:54:11",
  "retrieved_files": [
    {
      "source_file": "kernel/time/timeconv.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:53:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timeconv.c`\n\n---\n\n# time/timeconv.c 技术文档\n\n## 1. 文件概述\n\n`time/timeconv.c` 是 Linux 内核中用于将日历时间（自 Unix 纪元 1970-01-01 00:00:00 UTC 起的秒数）转换为本地“分解时间”（broken-down time）表示的核心实现文件。该文件提供了一个高效、精确且支持 64 位时间戳（`time64_t`）的转换函数，适用于跨越 2038 年的时间处理需求。其算法基于 Cassio Neri 与 Schneider 提出的欧几里得仿射函数方法，具有良好的数学严谨性和性能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`time64_to_tm(time64_t totalsecs, int offset, struct tm *result)`**  \n  将 64 位日历时间（UTC 秒数）结合时区偏移量转换为本地分解时间结构体 `struct tm`。\n\n### 数据结构\n\n- **`struct tm`**（定义于 `<linux/time.h>`）  \n  表示分解时间的标准结构体，包含年、月、日、时、分、秒、星期、年内日等字段。\n\n### 宏定义\n\n- `SECS_PER_HOUR`：每小时秒数（3600）\n- `SECS_PER_DAY`：每天秒数（86400）\n\n## 3. 关键实现\n\n### 时间归一化\n函数首先将输入的总秒数 `totalsecs` 与偏移量 `offset` 相加，并通过循环调整，确保秒数部分 `rem` 落在 `[0, SECS_PER_DAY)` 范围内，同时相应调整天数 `days`。这一步处理了跨日边界的情况（如负偏移导致前一天）。\n\n### 时分秒计算\n基于归一化后的 `rem`，直接通过整除和取模运算得出 `tm_hour`、`tm_min` 和 `tm_sec`。\n\n### 星期计算\n利用已知事实“1970 年 1 月 1 日是星期四”，通过 `(4 + days) % 7` 计算星期几（`tm_wday`），并确保结果为非负。\n\n### 日期计算（核心算法）\n采用 **“计算日历”**（computational calendar）方法，该日历将每年起点设为 **3 月 1 日**（即 3 月为第 0 月，次年 2 月为第 13 月），从而消除闰年对年内日计算的影响：\n\n1. **天数偏移**：将 `days` 加上常量 `2305843009213814918ULL`，使日历对齐到便于计算的周期起点。\n2. **世纪与年内日分解**：\n   - 使用 `div64_u64_rem` 将总天数按 400 年周期（146097 天）分解为世纪数 `century` 和世纪内天数 `day_of_century`。\n   - 进一步将 `day_of_century` 分解为年份偏移 `year_of_century` 和年内日 `day_of_year`。\n3. **月份与日计算**：\n   - 利用线性近似 `2141 * day_of_year + 132377` 的高 16 位作为月份索引，低 16 位除以 2141 得到日。\n4. **日历转换**：\n   - 判断是否为 1 月或 2 月（即 `day_of_year >= 306`），据此调整年、月、日及年内日 `tm_yday`。\n   - 通过减去大常量 `6313183731940000ULL` 将计算年份映射回实际 Gregorian 年份。\n5. **结果适配**：\n   - `tm_year` 设为实际年份减 1900（符合 POSIX 规范）。\n   - `tm_mon` 为 0 起始（0=1月），`tm_mday` 为 1 起始。\n\n该算法避免了传统循环或查表方式，完全基于整数算术，高效且无分支预测惩罚。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/time.h>`：提供 `time64_t`、`struct tm` 等时间相关定义\n  - `<linux/module.h>`：提供 `EXPORT_SYMBOL` 宏\n  - `<linux/kernel.h>`：提供 `div_s64_rem`、`div64_u64_rem`、`upper_32_bits`、`lower_32_bits` 等内核数学辅助函数\n- **导出符号**：\n  - `time64_to_tm` 通过 `EXPORT_SYMBOL` 导出，可供其他内核模块使用\n\n## 5. 使用场景\n\n- **系统调用实现**：如 `localtime()`、`gmtime()` 等用户空间时间转换函数的内核支持\n- **文件系统时间戳处理**：在需要将 inode 时间戳转换为可读日期时使用\n- **日志与调试**：内核日志中打印人类可读的时间信息\n- **网络协议栈**：处理 HTTP、NTP 等协议中的日期字段\n- **定时器与调度**：在需要将绝对时间转换为日历时间进行调度决策时\n- **Y2038 安全**：作为 64 位时间基础设施的一部分，确保内核在 2038 年后仍能正确处理时间",
      "similarity": 0.5343118906021118,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/timeconv.c",
          "start_line": 1,
          "end_line": 46,
          "content": [
            "// SPDX-License-Identifier: LGPL-2.0+",
            "/*",
            " * Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.",
            " * This file is part of the GNU C Library.",
            " * Contributed by Paul Eggert (eggert@twinsun.com).",
            " *",
            " * The GNU C Library is free software; you can redistribute it and/or",
            " * modify it under the terms of the GNU Library General Public License as",
            " * published by the Free Software Foundation; either version 2 of the",
            " * License, or (at your option) any later version.",
            " *",
            " * The GNU C Library is distributed in the hope that it will be useful,",
            " * but WITHOUT ANY WARRANTY; without even the implied warranty of",
            " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            " * Library General Public License for more details.",
            " *",
            " * You should have received a copy of the GNU Library General Public",
            " * License along with the GNU C Library; see the file COPYING.LIB.  If not,",
            " * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,",
            " * Boston, MA 02111-1307, USA.",
            " */",
            "",
            "/*",
            " * Converts the calendar time to broken-down time representation",
            " *",
            " * 2009-7-14:",
            " *   Moved from glibc-2.6 to kernel by Zhaolei<zhaolei@cn.fujitsu.com>",
            " * 2021-06-02:",
            " *   Reimplemented by Cassio Neri <cassio.neri@gmail.com>",
            " */",
            "",
            "#include <linux/time.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "",
            "#define SECS_PER_HOUR\t(60 * 60)",
            "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
            "",
            "/**",
            " * time64_to_tm - converts the calendar time to local broken-down time",
            " *",
            " * @totalsecs:\tthe number of seconds elapsed since 00:00:00 on January 1, 1970,",
            " *\t\tCoordinated Universal Time (UTC).",
            " * @offset:\toffset seconds adding to totalsecs.",
            " * @result:\tpointer to struct tm variable to receive broken-down time",
            " */"
          ],
          "function_name": null,
          "description": "此代码块定义了time64_to_tm函数的原型，用于将Unix时间戳（以秒为单位）转换为本地分解时间结构体tm，接受总秒数、时区偏移量和结果缓冲区参数，但未包含函数实现细节",
          "similarity": 0.5188547968864441
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/timeconv.c",
          "start_line": 47,
          "end_line": 140,
          "content": [
            "void time64_to_tm(time64_t totalsecs, int offset, struct tm *result)",
            "{",
            "\tu32 u32tmp, day_of_century, year_of_century, day_of_year, month, day;",
            "\tu64 u64tmp, udays, century, year;",
            "\tbool is_Jan_or_Feb, is_leap_year;",
            "\tlong days, rem;",
            "\tint remainder;",
            "",
            "\tdays = div_s64_rem(totalsecs, SECS_PER_DAY, &remainder);",
            "\trem = remainder;",
            "\trem += offset;",
            "\twhile (rem < 0) {",
            "\t\trem += SECS_PER_DAY;",
            "\t\t--days;",
            "\t}",
            "\twhile (rem >= SECS_PER_DAY) {",
            "\t\trem -= SECS_PER_DAY;",
            "\t\t++days;",
            "\t}",
            "",
            "\tresult->tm_hour = rem / SECS_PER_HOUR;",
            "\trem %= SECS_PER_HOUR;",
            "\tresult->tm_min = rem / 60;",
            "\tresult->tm_sec = rem % 60;",
            "",
            "\t/* January 1, 1970 was a Thursday. */",
            "\tresult->tm_wday = (4 + days) % 7;",
            "\tif (result->tm_wday < 0)",
            "\t\tresult->tm_wday += 7;",
            "",
            "\t/*",
            "\t * The following algorithm is, basically, Proposition 6.3 of Neri",
            "\t * and Schneider [1]. In a few words: it works on the computational",
            "\t * (fictitious) calendar where the year starts in March, month = 2",
            "\t * (*), and finishes in February, month = 13. This calendar is",
            "\t * mathematically convenient because the day of the year does not",
            "\t * depend on whether the year is leap or not. For instance:",
            "\t *",
            "\t * March 1st\t\t0-th day of the year;",
            "\t * ...",
            "\t * April 1st\t\t31-st day of the year;",
            "\t * ...",
            "\t * January 1st\t\t306-th day of the year; (Important!)",
            "\t * ...",
            "\t * February 28th\t364-th day of the year;",
            "\t * February 29th\t365-th day of the year (if it exists).",
            "\t *",
            "\t * After having worked out the date in the computational calendar",
            "\t * (using just arithmetics) it's easy to convert it to the",
            "\t * corresponding date in the Gregorian calendar.",
            "\t *",
            "\t * [1] \"Euclidean Affine Functions and Applications to Calendar",
            "\t * Algorithms\". https://arxiv.org/abs/2102.06959",
            "\t *",
            "\t * (*) The numbering of months follows tm more closely and thus,",
            "\t * is slightly different from [1].",
            "\t */",
            "",
            "\tudays\t= ((u64) days) + 2305843009213814918ULL;",
            "",
            "\tu64tmp\t\t= 4 * udays + 3;",
            "\tcentury\t\t= div64_u64_rem(u64tmp, 146097, &u64tmp);",
            "\tday_of_century\t= (u32) (u64tmp / 4);",
            "",
            "\tu32tmp\t\t= 4 * day_of_century + 3;",
            "\tu64tmp\t\t= 2939745ULL * u32tmp;",
            "\tyear_of_century\t= upper_32_bits(u64tmp);",
            "\tday_of_year\t= lower_32_bits(u64tmp) / 2939745 / 4;",
            "",
            "\tyear\t\t= 100 * century + year_of_century;",
            "\tis_leap_year\t= year_of_century ? !(year_of_century % 4) : !(century % 4);",
            "",
            "\tu32tmp\t\t= 2141 * day_of_year + 132377;",
            "\tmonth\t\t= u32tmp >> 16;",
            "\tday\t\t= ((u16) u32tmp) / 2141;",
            "",
            "\t/*",
            "\t * Recall that January 1st is the 306-th day of the year in the",
            "\t * computational (not Gregorian) calendar.",
            "\t */",
            "\tis_Jan_or_Feb\t= day_of_year >= 306;",
            "",
            "\t/* Convert to the Gregorian calendar and adjust to Unix time. */",
            "\tyear\t\t= year + is_Jan_or_Feb - 6313183731940000ULL;",
            "\tmonth\t\t= is_Jan_or_Feb ? month - 12 : month;",
            "\tday\t\t= day + 1;",
            "\tday_of_year\t+= is_Jan_or_Feb ? -306 : 31 + 28 + is_leap_year;",
            "",
            "\t/* Convert to tm's format. */",
            "\tresult->tm_year = (long) (year - 1900);",
            "\tresult->tm_mon  = (int) month;",
            "\tresult->tm_mday = (int) day;",
            "\tresult->tm_yday = (int) day_of_year;",
            "}"
          ],
          "function_name": "time64_to_tm",
          "description": "该函数实现将64位时间戳转换为tm结构体，通过计算天数、处理闰年规则、应用纪元起始日星期信息，并采用基于数学推导的格里高利历算法进行月日转换，最终填充tm结构体成员",
          "similarity": 0.47581493854522705
        }
      ]
    },
    {
      "source_file": "kernel/time/timecounter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:54:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timecounter.c`\n\n---\n\n# `time/timecounter.c` 技术文档\n\n## 1. 文件概述\n\n`time/timecounter.c` 实现了 Linux 内核中的 **timecounter** 机制，用于将底层硬件周期计数器（cycle counter）的原始计数值转换为高精度的纳秒时间戳。该机制基于 `cyclecounter` 抽象，能够处理计数器溢出，并支持将任意周期时间戳转换为对应的纳秒时间，广泛应用于网络时间戳、PTP（精确时间协议）等需要高精度时间同步的场景。\n\n## 2. 核心功能\n\n### 数据结构\n- `struct timecounter`：时间计数器抽象，包含指向底层 `cyclecounter` 的指针、上次读取的周期值、当前纳秒时间戳、掩码和分数部分等字段。\n\n### 主要函数\n- `timecounter_init()`：初始化 `timecounter` 实例。\n- `timecounter_read()`：获取当前纳秒时间戳，并更新内部状态。\n- `timecounter_read_delta()`（静态）：计算自上次调用以来经过的纳秒数。\n- `timecounter_cyc2time()`：将给定的周期计数值转换为对应的纳秒时间戳（支持向前或向后转换）。\n- `cc_cyc2ns_backwards()`（静态）：辅助函数，用于反向（历史时间）的周期到纳秒转换。\n\n## 3. 关键实现\n\n### 初始化 (`timecounter_init`)\n- 将用户提供的 `cyclecounter` 指针保存到 `tc->cc`。\n- 读取当前硬件周期值作为 `cycle_last`。\n- 设置初始纳秒时间戳 `nsec` 为 `start_tstamp`。\n- 计算掩码 `mask = (1ULL << cc->shift) - 1`，用于后续溢出处理。\n- 初始化分数部分 `frac = 0`，用于高精度纳秒转换。\n\n### 时间读取 (`timecounter_read`)\n- 调用 `timecounter_read_delta()` 获取自上次读取以来的纳秒增量。\n- 将增量累加到 `tc->nsec`，并返回更新后的时间戳。\n- **注意**：首次调用返回值未定义，仅用于初始化内部状态。\n\n### 增量计算 (`timecounter_read_delta`)\n- 读取当前周期值 `cycle_now`。\n- 计算与上次值的差值 `cycle_delta`，并通过 `& cc->mask` 处理单次溢出。\n- 使用 `cyclecounter_cyc2ns()` 将周期差值转换为纳秒偏移量（含分数精度补偿）。\n- 更新 `cycle_last` 为当前值。\n\n### 周期转时间 (`timecounter_cyc2time`)\n- 计算目标周期 `cycle_tstamp` 与 `cycle_last` 的差值 `delta`。\n- **智能方向判断**：若 `delta > mask / 2`，说明 `cycle_tstamp` 实际是历史时间（因计数器回绕），则反向计算。\n  - 使用 `cc_cyc2ns_backwards()` 从当前纳秒时间减去对应的历史偏移。\n- 否则视为未来时间，使用标准 `cyclecounter_cyc2ns()` 正向累加。\n- 该设计确保即使在计数器溢出边界附近，也能正确解析时间戳。\n\n### 反向转换 (`cc_cyc2ns_backwards`)\n- 与 `cyclecounter_cyc2ns()` 类似，但先减去分数部分再右移，适用于历史时间计算。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/timecounter.h>`：定义 `struct timecounter` 和相关函数原型。\n  - `<linux/export.h>`：提供 `EXPORT_SYMBOL_GPL` 宏，用于导出符号供其他模块使用。\n- **功能依赖**：\n  - 依赖 `cyclecounter` 子系统（定义在 `include/linux/cyclecounter.h`），特别是 `cyclecounter_cyc2ns()` 函数。\n  - 依赖底层硬件驱动提供符合 `cyclecounter` 接口的周期计数器（如 `read()` 函数和 `mask`/`mult`/`shift` 参数）。\n\n## 5. 使用场景\n\n- **网络时间戳**：在网络驱动中，硬件捕获数据包到达/发送时的周期计数值，通过 `timecounter_cyc2time()` 转换为精确的纳秒时间戳，用于 PTP（IEEE 1588）等协议。\n- **高精度定时**：在需要比 `jiffies` 或 `ktime` 更高分辨率的场景中，结合硬件计数器使用。\n- **跨溢出时间计算**：当底层计数器位宽有限（如 32 位）且频率较高时，频繁溢出，`timecounter` 能透明处理单次溢出，保证时间连续性。\n- **时间同步子系统**：作为 PTP 硬件时钟（PHC）实现的基础组件，将硬件寄存器值映射到系统时间域。",
      "similarity": 0.5311002731323242,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/timecounter.c",
          "start_line": 8,
          "end_line": 77,
          "content": [
            "void timecounter_init(struct timecounter *tc,",
            "\t\t      const struct cyclecounter *cc,",
            "\t\t      u64 start_tstamp)",
            "{",
            "\ttc->cc = cc;",
            "\ttc->cycle_last = cc->read(cc);",
            "\ttc->nsec = start_tstamp;",
            "\ttc->mask = (1ULL << cc->shift) - 1;",
            "\ttc->frac = 0;",
            "}",
            "static u64 timecounter_read_delta(struct timecounter *tc)",
            "{",
            "\tu64 cycle_now, cycle_delta;",
            "\tu64 ns_offset;",
            "",
            "\t/* read cycle counter: */",
            "\tcycle_now = tc->cc->read(tc->cc);",
            "",
            "\t/* calculate the delta since the last timecounter_read_delta(): */",
            "\tcycle_delta = (cycle_now - tc->cycle_last) & tc->cc->mask;",
            "",
            "\t/* convert to nanoseconds: */",
            "\tns_offset = cyclecounter_cyc2ns(tc->cc, cycle_delta,",
            "\t\t\t\t\ttc->mask, &tc->frac);",
            "",
            "\t/* update time stamp of timecounter_read_delta() call: */",
            "\ttc->cycle_last = cycle_now;",
            "",
            "\treturn ns_offset;",
            "}",
            "u64 timecounter_read(struct timecounter *tc)",
            "{",
            "\tu64 nsec;",
            "",
            "\t/* increment time by nanoseconds since last call */",
            "\tnsec = timecounter_read_delta(tc);",
            "\tnsec += tc->nsec;",
            "\ttc->nsec = nsec;",
            "",
            "\treturn nsec;",
            "}",
            "static u64 cc_cyc2ns_backwards(const struct cyclecounter *cc,",
            "\t\t\t       u64 cycles, u64 mask, u64 frac)",
            "{",
            "\tu64 ns = (u64) cycles;",
            "",
            "\tns = ((ns * cc->mult) - frac) >> cc->shift;",
            "",
            "\treturn ns;",
            "}",
            "u64 timecounter_cyc2time(const struct timecounter *tc,",
            "\t\t\t u64 cycle_tstamp)",
            "{",
            "\tu64 delta = (cycle_tstamp - tc->cycle_last) & tc->cc->mask;",
            "\tu64 nsec = tc->nsec, frac = tc->frac;",
            "",
            "\t/*",
            "\t * Instead of always treating cycle_tstamp as more recent",
            "\t * than tc->cycle_last, detect when it is too far in the",
            "\t * future and treat it as old time stamp instead.",
            "\t */",
            "\tif (delta > tc->cc->mask / 2) {",
            "\t\tdelta = (tc->cycle_last - cycle_tstamp) & tc->cc->mask;",
            "\t\tnsec -= cc_cyc2ns_backwards(tc->cc, delta, tc->mask, frac);",
            "\t} else {",
            "\t\tnsec += cyclecounter_cyc2ns(tc->cc, delta, tc->mask, &frac);",
            "\t}",
            "",
            "\treturn nsec;",
            "}"
          ],
          "function_name": "timecounter_init, timecounter_read_delta, timecounter_read, cc_cyc2ns_backwards, timecounter_cyc2time",
          "description": "实现时间计数器初始化与时间读取逻辑，包含周期计数转纳秒计算、时间差获取及时间戳更新功能",
          "similarity": 0.5490495562553406
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/timecounter.c",
          "start_line": 1,
          "end_line": 7,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Based on clocksource code. See commit 74d23cc704d1",
            " */",
            "#include <linux/export.h>",
            "#include <linux/timecounter.h>",
            ""
          ],
          "function_name": null,
          "description": "声明时间计数器模块的许可证及包含必要头文件，为后续时间计数器实现提供基础",
          "similarity": 0.49712085723876953
        }
      ]
    },
    {
      "source_file": "kernel/time/sched_clock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:46:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\sched_clock.c`\n\n---\n\n# `time/sched_clock.c` 技术文档\n\n## 1. 文件概述\n\n`time/sched_clock.c` 实现了 Linux 内核中通用的 `sched_clock()` 机制，用于将底层硬件计数器（如 TSC、ARM arch timer 等）扩展为 64 位纳秒级单调时间戳。该机制为调度器、延迟跟踪、性能分析等子系统提供高精度、低开销的时间基准。文件通过双缓冲（双副本）+ 序列锁（`seqcount_latch_t`）的方式，确保即使在 NMI（不可屏蔽中断）上下文中调用 `sched_clock()` 也能获得一致、无撕裂的时间读数。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct clock_data`**  \n  全局状态结构体，包含：\n  - `seq`: `seqcount_latch_t` 类型的序列计数器，用于同步读写。\n  - `read_data[2]`: 双缓冲数组，分别存储当前有效和更新中的读取参数。\n  - `wrap_kt`: 计数器溢出前的最大持续时间（ktime_t 格式）。\n  - `rate`: 当前注册的时钟源频率（Hz）。\n  - `actual_read_sched_clock`: 指向底层硬件读取函数的指针。\n\n- **`struct clock_read_data`**（定义在头文件中）  \n  包含读取 `sched_clock` 所需的关键参数：\n  - `read_sched_clock`: 当前使用的读取函数（可能为挂起状态下的特殊函数）。\n  - `sched_clock_mask`: 计数器位宽掩码（如 `CLOCKSOURCE_MASK(bits)`）。\n  - `mult/shift`: 用于将计数器周期转换为纳秒的乘法/移位因子。\n  - `epoch_cyc/epoch_ns`: 上次校准时刻的计数器值和对应的纳秒时间戳。\n\n### 主要函数\n\n- **`sched_clock_noinstr(void)`**  \n  无插桩（noinstr）版本的 `sched_clock()`，在禁用抢占的上下文中直接读取并计算纳秒时间，使用序列锁保证一致性。\n\n- **`sched_clock(void)`**  \n  对外公开的 `sched_clock()` 接口，内部调用 `sched_clock_noinstr()` 并确保抢占被禁用。\n\n- **`sched_clock_register(read, bits, rate)`**  \n  注册新的底层硬件时钟源。计算 `mult/shift` 转换参数，更新全局 `clock_data`，并启动防溢出定时器。\n\n- **`generic_sched_clock_init(void)`**  \n  初始化通用 `sched_clock` 机制。若未注册硬件时钟，则回退到基于 `jiffies` 的实现，并启动周期性更新定时器。\n\n- **`sched_clock_suspend()/sched_clock_resume()`**  \n  系统挂起/恢复时的回调函数。挂起时切换读取函数为返回最后校准值的静态函数，恢复时重新同步并启用硬件读取。\n\n- **`update_sched_clock()`**  \n  更新 `epoch_cyc` 和 `epoch_ns`，防止因计数器长时间运行导致转换溢出。\n\n- **`sched_clock_poll()`**  \n  高精度定时器（hrtimer）回调函数，周期性调用 `update_sched_clock()`。\n\n## 3. 关键实现\n\n### 双缓冲 + Latch 序列锁机制\n\n- 使用 `seqcount_latch_t` 实现无锁读取：读操作通过 `sched_clock_read_begin()` 获取当前有效副本索引（`seq & 1`），并在末尾通过 `sched_clock_read_retry()` 验证读取期间未发生更新。\n- 写操作（如 `update_clock_read_data()`）先更新奇数副本（索引 1），通过 `raw_write_seqcount_latch()` 切换读者到奇数副本；再更新偶数副本（索引 0），再次切换回偶数副本。确保读者始终看到一致的旧数据或新数据，不会看到中间状态。\n\n### 时间转换与防溢出\n\n- 使用 `clocks_calc_mult_shift()` 计算最优的 `mult/shift` 对，将硬件计数器周期高效转换为纳秒（公式：`ns = (cyc * mult) >> shift`）。\n- 通过 `clocks_calc_max_nsecs()` 计算计数器在溢出前可安全表示的最大纳秒数，并以此设置 `hrtimer` 的超时时间（`wrap_kt`），定期调用 `update_sched_clock()` 重置 `epoch`，避免 64 位中间结果溢出。\n\n### 挂起/恢复处理\n\n- 系统挂起时，将 `read_sched_clock` 替换为 `suspended_sched_clock_read()`，该函数返回最后一次校准的 `epoch_cyc`，使 `sched_clock()` 在挂起期间表现为“冻结”。\n- 恢复时重新读取硬件计数器作为新的 `epoch_cyc`，并恢复原始读取函数。\n\n### 中断上下文安全\n\n- 所有读路径（`sched_clock*`）标记为 `notrace` 和 `noinstr`，避免在关键路径引入追踪或插桩开销。\n- 写操作（如注册、更新）在关中断（`local_irq_save`）下执行，确保与 NMI 上下文的读操作互斥。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/clocksource.h>`：提供 `CLOCKSOURCE_MASK`、`clocks_calc_mult_shift` 等时钟源工具。\n  - `<linux/hrtimer.h>`：用于实现防溢出定时器。\n  - `<linux/seqlock.h>`：提供 `seqcount_latch_t` 及相关操作。\n  - `\"timekeeping.h\"`：内核时间管理内部头文件。\n  - `<linux/sched/clock.h>`：定义 `sched_clock()` 接口及 `enable_sched_clock_irqtime()`。\n\n- **模块交互**：\n  - **调度器（scheduler）**：`sched_clock()` 是 `rq_clock()` 等调度时间基准的底层实现。\n  - **时间子系统（timekeeping）**：与 `ktime_get()` 等接口协同，但 `sched_clock()` 更侧重低开销、单调性。\n  - **电源管理（PM）**：通过 `syscore_ops` 注册挂起/恢复回调。\n  - **中断子系统**：若时钟频率 ≥ 1MHz 且 `irqtime` 未禁用，则启用中断时间统计（`enable_sched_clock_irqtime()`）。\n\n## 5. 使用场景\n\n- **调度延迟测量**：调度器使用 `sched_clock()` 计算任务运行时间、睡眠时间及调度延迟。\n- **性能分析工具**：如 `ftrace`、`perf` 使用 `sched_clock()` 作为事件时间戳。\n- **内核延迟跟踪**：`irqsoff`、`preemptoff` 等 tracer 依赖高精度单调时钟。\n- **硬件计数器抽象**：为架构特定的高精度计数器（如 x86 TSC、ARM arch timer）提供统一的 64 位纳秒接口。\n- **系统挂起/恢复**：在 Suspend-to-RAM 等场景下保持时间连续性，避免挂起期间时间“跳跃”。",
      "similarity": 0.5208553075790405,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 1,
          "end_line": 51,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Generic sched_clock() support, to extend low level hardware time",
            " * counters to full 64-bit ns values.",
            " */",
            "#include <linux/clocksource.h>",
            "#include <linux/init.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/math.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/bitops.h>",
            "",
            "#include \"timekeeping.h\"",
            "",
            "/**",
            " * struct clock_data - all data needed for sched_clock() (including",
            " *                     registration of a new clock source)",
            " *",
            " * @seq:\t\tSequence counter for protecting updates. The lowest",
            " *\t\t\tbit is the index for @read_data.",
            " * @read_data:\t\tData required to read from sched_clock.",
            " * @wrap_kt:\t\tDuration for which clock can run before wrapping.",
            " * @rate:\t\tTick rate of the registered clock.",
            " * @actual_read_sched_clock: Registered hardware level clock read function.",
            " *",
            " * The ordering of this structure has been chosen to optimize cache",
            " * performance. In particular 'seq' and 'read_data[0]' (combined) should fit",
            " * into a single 64-byte cache line.",
            " */",
            "struct clock_data {",
            "\tseqcount_latch_t\tseq;",
            "\tstruct clock_read_data\tread_data[2];",
            "\tktime_t\t\t\twrap_kt;",
            "\tunsigned long\t\trate;",
            "",
            "\tu64 (*actual_read_sched_clock)(void);",
            "};",
            "",
            "static struct hrtimer sched_clock_timer;",
            "static int irqtime = -1;",
            "",
            "core_param(irqtime, irqtime, int, 0400);",
            ""
          ],
          "function_name": null,
          "description": "定义调度时钟所需的数据结构和全局变量，其中struct clock_data用于存储时钟读取数据、序列计数器、包装时间、速率及实际读取函数指针，通过结构体布局优化缓存性能",
          "similarity": 0.4979218542575836
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 237,
          "end_line": 285,
          "content": [
            "void __init generic_sched_clock_init(void)",
            "{",
            "\t/*",
            "\t * If no sched_clock() function has been provided at that point,",
            "\t * make it the final one.",
            "\t */",
            "\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)",
            "\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);",
            "",
            "\tupdate_sched_clock();",
            "",
            "\t/*",
            "\t * Start the timer to keep sched_clock() properly updated and",
            "\t * sets the initial epoch.",
            "\t */",
            "\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);",
            "\tsched_clock_timer.function = sched_clock_poll;",
            "\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);",
            "}",
            "static u64 notrace suspended_sched_clock_read(void)",
            "{",
            "\tunsigned int seq = raw_read_seqcount_latch(&cd.seq);",
            "",
            "\treturn cd.read_data[seq & 1].epoch_cyc;",
            "}",
            "int sched_clock_suspend(void)",
            "{",
            "\tstruct clock_read_data *rd = &cd.read_data[0];",
            "",
            "\tupdate_sched_clock();",
            "\thrtimer_cancel(&sched_clock_timer);",
            "\trd->read_sched_clock = suspended_sched_clock_read;",
            "",
            "\treturn 0;",
            "}",
            "void sched_clock_resume(void)",
            "{",
            "\tstruct clock_read_data *rd = &cd.read_data[0];",
            "",
            "\trd->epoch_cyc = cd.actual_read_sched_clock();",
            "\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);",
            "\trd->read_sched_clock = cd.actual_read_sched_clock;",
            "}",
            "static int __init sched_clock_syscore_init(void)",
            "{",
            "\tregister_syscore_ops(&sched_clock_ops);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "generic_sched_clock_init, suspended_sched_clock_read, sched_clock_suspend, sched_clock_resume, sched_clock_syscore_init",
          "description": "提供调度时钟初始化、挂起/恢复处理及系统核心操作注册，初始化阶段设置默认时钟源并启动更新定时器，挂起时切换至专用读取函数以保持时间连续性",
          "similarity": 0.4812948405742645
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 52,
          "end_line": 202,
          "content": [
            "static u64 notrace jiffy_sched_clock_read(void)",
            "{",
            "\t/*",
            "\t * We don't need to use get_jiffies_64 on 32-bit arches here",
            "\t * because we register with BITS_PER_LONG",
            "\t */",
            "\treturn (u64)(jiffies - INITIAL_JIFFIES);",
            "}",
            "static __always_inline u64 cyc_to_ns(u64 cyc, u32 mult, u32 shift)",
            "{",
            "\treturn (cyc * mult) >> shift;",
            "}",
            "notrace int sched_clock_read_retry(unsigned int seq)",
            "{",
            "\treturn raw_read_seqcount_latch_retry(&cd.seq, seq);",
            "}",
            "unsigned long long noinstr sched_clock_noinstr(void)",
            "{",
            "\tstruct clock_read_data *rd;",
            "\tunsigned int seq;",
            "\tu64 cyc, res;",
            "",
            "\tdo {",
            "\t\tseq = raw_read_seqcount_latch(&cd.seq);",
            "\t\trd = cd.read_data + (seq & 1);",
            "",
            "\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &",
            "\t\t      rd->sched_clock_mask;",
            "\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);",
            "\t} while (raw_read_seqcount_latch_retry(&cd.seq, seq));",
            "",
            "\treturn res;",
            "}",
            "unsigned long long notrace sched_clock(void)",
            "{",
            "\tunsigned long long ns;",
            "\tpreempt_disable_notrace();",
            "\tns = sched_clock_noinstr();",
            "\tpreempt_enable_notrace();",
            "\treturn ns;",
            "}",
            "static void update_clock_read_data(struct clock_read_data *rd)",
            "{",
            "\t/* update the backup (odd) copy with the new data */",
            "\tcd.read_data[1] = *rd;",
            "",
            "\t/* steer readers towards the odd copy */",
            "\traw_write_seqcount_latch(&cd.seq);",
            "",
            "\t/* now its safe for us to update the normal (even) copy */",
            "\tcd.read_data[0] = *rd;",
            "",
            "\t/* switch readers back to the even copy */",
            "\traw_write_seqcount_latch(&cd.seq);",
            "}",
            "static void update_sched_clock(void)",
            "{",
            "\tu64 cyc;",
            "\tu64 ns;",
            "\tstruct clock_read_data rd;",
            "",
            "\trd = cd.read_data[0];",
            "",
            "\tcyc = cd.actual_read_sched_clock();",
            "\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);",
            "",
            "\trd.epoch_ns = ns;",
            "\trd.epoch_cyc = cyc;",
            "",
            "\tupdate_clock_read_data(&rd);",
            "}",
            "static enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)",
            "{",
            "\tupdate_sched_clock();",
            "\thrtimer_forward_now(hrt, cd.wrap_kt);",
            "",
            "\treturn HRTIMER_RESTART;",
            "}",
            "void __init",
            "sched_clock_register(u64 (*read)(void), int bits, unsigned long rate)",
            "{",
            "\tu64 res, wrap, new_mask, new_epoch, cyc, ns;",
            "\tu32 new_mult, new_shift;",
            "\tunsigned long r, flags;",
            "\tchar r_unit;",
            "\tstruct clock_read_data rd;",
            "",
            "\tif (cd.rate > rate)",
            "\t\treturn;",
            "",
            "\t/* Cannot register a sched_clock with interrupts on */",
            "\tlocal_irq_save(flags);",
            "",
            "\t/* Calculate the mult/shift to convert counter ticks to ns. */",
            "\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);",
            "",
            "\tnew_mask = CLOCKSOURCE_MASK(bits);",
            "\tcd.rate = rate;",
            "",
            "\t/* Calculate how many nanosecs until we risk wrapping */",
            "\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);",
            "\tcd.wrap_kt = ns_to_ktime(wrap);",
            "",
            "\trd = cd.read_data[0];",
            "",
            "\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/",
            "\tnew_epoch = read();",
            "\tcyc = cd.actual_read_sched_clock();",
            "\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);",
            "\tcd.actual_read_sched_clock = read;",
            "",
            "\trd.read_sched_clock\t= read;",
            "\trd.sched_clock_mask\t= new_mask;",
            "\trd.mult\t\t\t= new_mult;",
            "\trd.shift\t\t= new_shift;",
            "\trd.epoch_cyc\t\t= new_epoch;",
            "\trd.epoch_ns\t\t= ns;",
            "",
            "\tupdate_clock_read_data(&rd);",
            "",
            "\tif (sched_clock_timer.function != NULL) {",
            "\t\t/* update timeout for clock wrap */",
            "\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt,",
            "\t\t\t      HRTIMER_MODE_REL_HARD);",
            "\t}",
            "",
            "\tr = rate;",
            "\tif (r >= 4000000) {",
            "\t\tr = DIV_ROUND_CLOSEST(r, 1000000);",
            "\t\tr_unit = 'M';",
            "\t} else if (r >= 4000) {",
            "\t\tr = DIV_ROUND_CLOSEST(r, 1000);",
            "\t\tr_unit = 'k';",
            "\t} else {",
            "\t\tr_unit = ' ';",
            "\t}",
            "",
            "\t/* Calculate the ns resolution of this counter */",
            "\tres = cyc_to_ns(1ULL, new_mult, new_shift);",
            "",
            "\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",",
            "\t\tbits, r, r_unit, res, wrap);",
            "",
            "\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */",
            "\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))",
            "\t\tenable_sched_clock_irqtime();",
            "",
            "\tlocal_irq_restore(flags);",
            "",
            "\tpr_debug(\"Registered %pS as sched_clock source\\n\", read);",
            "}"
          ],
          "function_name": "jiffy_sched_clock_read, cyc_to_ns, sched_clock_read_retry, sched_clock_noinstr, sched_clock, update_clock_read_data, update_sched_clock, sched_clock_poll, sched_clock_register",
          "description": "实现调度时钟读取逻辑，包含周期到纳秒转换、时钟数据更新、定时器回调及注册接口，支持多版本读取数据的原子更新和时钟包装检测",
          "similarity": 0.4742860794067383
        }
      ]
    }
  ]
}