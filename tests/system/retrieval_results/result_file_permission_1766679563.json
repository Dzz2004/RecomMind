{
  "query": "file permission",
  "timestamp": "2025-12-26 00:19:23",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/token.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:36:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\token.c`\n\n---\n\n# `bpf/token.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/token.c` 实现了 BPF（Berkeley Packet Filter）令牌（token）机制，用于在受限环境中安全地委托 BPF 操作权限。该机制允许用户空间程序通过文件描述符形式的令牌，将特定的 BPF 命令、映射类型、程序类型和附加类型权限委托给其他进程，同时结合用户命名空间（user namespace）和 LSM（Linux Security Module）安全策略进行细粒度访问控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `bpf_ns_capable()`：检查用户命名空间是否具备指定能力，或具备 `CAP_SYS_ADMIN`（除 `CAP_SYS_ADMIN` 自身外）。\n- `bpf_token_capable()`：结合用户命名空间能力和 LSM 安全钩子，判断令牌是否具备指定能力。\n- `bpf_token_inc()` / `bpf_token_put()`：引用计数管理，支持延迟释放。\n- `bpf_token_free()`：释放令牌资源，包括用户命名空间引用和安全模块数据。\n- `bpf_token_create()`：创建 BPF 令牌文件描述符，基于挂载在 BPF 文件系统上的委托配置。\n- `bpf_token_get_from_fd()`：从文件描述符获取并增加引用计数的 `bpf_token` 结构。\n- `bpf_token_allow_cmd()` / `bpf_token_allow_map_type()` / `bpf_token_allow_prog_type()`：检查令牌是否允许执行特定 BPF 操作。\n\n### 关键数据结构\n\n- `struct bpf_token`：表示 BPF 令牌，包含：\n  - `refcnt`：引用计数（`atomic64_t`）\n  - `userns`：关联的用户命名空间\n  - `allowed_cmds` / `allowed_maps` / `allowed_progs` / `allowed_attachs`：位掩码，分别表示允许的 BPF 命令、映射类型、程序类型和附加类型\n  - `work`：用于延迟释放的工作队列项\n\n### 文件操作接口\n\n- `bpf_token_fops`：定义了 `release` 和 `show_fdinfo` 回调，用于文件关闭和 `/proc/pid/fdinfo/` 信息展示。\n\n## 3. 关键实现\n\n### 令牌创建流程 (`bpf_token_create`)\n\n1. **验证输入**：检查传入的 `bpffs_fd` 是否指向 BPF 文件系统的根目录。\n2. **权限校验**：\n   - 要求调用者与 BPF 文件系统实例处于同一用户命名空间。\n   - 必须具备 `CAP_BPF` 能力。\n   - 禁止在 `init_user_ns` 中创建令牌。\n3. **委托配置检查**：确保 BPF 文件系统挂载时已通过挂载选项设置了至少一项委托权限（`delegate_*` 字段非零）。\n4. **资源分配**：\n   - 创建匿名 inode 和文件。\n   - 分配 `bpf_token` 结构并初始化引用计数为 1。\n   - 复制挂载选项中的委托位掩码到令牌。\n5. **安全模块集成**：调用 `security_bpf_token_create()` 允许 LSM 进行额外策略检查。\n6. **返回文件描述符**：安装文件到进程 fd 表并返回。\n\n### 安全能力检查 (`bpf_token_capable`)\n\n- 默认允许 `CAP_SYS_ADMIN` 作为“超级能力”覆盖其他能力检查（但 `CAP_SYS_ADMIN` 本身仍需显式授权）。\n- 调用 `security_bpf_token_capable()` 允许 LSM 对令牌能力进行二次验证。\n\n### 引用计数与延迟释放\n\n- 使用 `atomic64_t refcnt` 管理生命周期。\n- 当引用计数归零时，通过 `schedule_work()` 将释放操作推迟到工作队列执行，避免在中断或原子上下文中调用可能睡眠的 `put_user_ns()` 和 `kfree()`。\n\n### `/proc/pid/fdinfo/` 支持\n\n- `bpf_token_show_fdinfo()` 将令牌的委托权限以十六进制或 \"any\" 形式输出，便于调试和审计。\n\n### 权限位掩码设计\n\n- 所有委托权限（命令、映射、程序、附加类型）均使用 64 位无符号整数位掩码表示。\n- 通过 `BUILD_BUG_ON()` 确保枚举类型数量不超过 64，防止位移溢出。\n- 若掩码全为 1，则显示为 \"any\"，表示无限制。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_super_ops`、`bpf_get_inode()` 等 BPF 文件系统接口。\n- **用户命名空间**：通过 `user_namespace` 和 `ns_capable()` 实现能力隔离。\n- **安全模块 (LSM)**：集成 `security_bpf_token_*` 钩子，支持 SELinux、AppArmor 等策略扩展。\n- **VFS 层**：使用 `inode`、`file`、`path`、`fdtable` 等通用文件系统抽象。\n- **内存管理**：使用 `kzalloc()`/`kfree()` 和 `vmalloc.h`（虽未直接使用，但为潜在扩展预留）。\n- **工作队列**：通过 `schedule_work()` 实现延迟释放。\n\n## 5. 使用场景\n\n- **容器化环境中的 BPF 权限委托**：在用户命名空间隔离的容器中，特权进程可创建 BPF 令牌并传递给非特权子进程，使其在受限范围内使用 BPF 功能（如 eBPF 程序加载、映射操作）。\n- **安全沙箱**：应用程序可通过令牌机制将特定 BPF 操作权限委托给插件或子模块，避免授予完整 `CAP_BPF` 或 `CAP_SYS_ADMIN`。\n- **审计与调试**：通过 `/proc/pid/fdinfo/` 查看进程持有的 BPF 令牌权限，辅助安全分析。\n- **LSM 策略集成**：安全模块可基于令牌内容实施更细粒度的访问控制，例如限制特定程序类型只能在特定挂载点使用。",
      "similarity": 0.5999916791915894,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/token.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            ""
          ],
          "function_name": null,
          "description": "包含BPF令牌功能所需的各种内核头文件，如用户命名空间、安全策略、文件操作及BPF相关定义。",
          "similarity": 0.5381837487220764
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/token.c",
          "start_line": 12,
          "end_line": 195,
          "content": [
            "static bool bpf_ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable(ns, cap) || (cap != CAP_SYS_ADMIN && ns_capable(ns, CAP_SYS_ADMIN));",
            "}",
            "bool bpf_token_capable(const struct bpf_token *token, int cap)",
            "{",
            "\tstruct user_namespace *userns;",
            "",
            "\t/* BPF token allows ns_capable() level of capabilities */",
            "\tuserns = token ? token->userns : &init_user_ns;",
            "\tif (!bpf_ns_capable(userns, cap))",
            "\t\treturn false;",
            "\tif (token && security_bpf_token_capable(token, cap) < 0)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "void bpf_token_inc(struct bpf_token *token)",
            "{",
            "\tatomic64_inc(&token->refcnt);",
            "}",
            "static void bpf_token_free(struct bpf_token *token)",
            "{",
            "\tsecurity_bpf_token_free(token);",
            "\tput_user_ns(token->userns);",
            "\tkfree(token);",
            "}",
            "static void bpf_token_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_token *token = container_of(work, struct bpf_token, work);",
            "",
            "\tbpf_token_free(token);",
            "}",
            "void bpf_token_put(struct bpf_token *token)",
            "{",
            "\tif (!token)",
            "\t\treturn;",
            "",
            "\tif (!atomic64_dec_and_test(&token->refcnt))",
            "\t\treturn;",
            "",
            "\tINIT_WORK(&token->work, bpf_token_put_deferred);",
            "\tschedule_work(&token->work);",
            "}",
            "static int bpf_token_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "",
            "\tbpf_token_put(token);",
            "\treturn 0;",
            "}",
            "static void bpf_token_show_fdinfo(struct seq_file *m, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "\tu64 mask;",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_CMD >= 64);",
            "\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\tif ((token->allowed_cmds & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_cmds:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_cmds:\\t0x%llx\\n\", token->allowed_cmds);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_MAP_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\tif ((token->allowed_maps & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_maps:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_maps:\\t0x%llx\\n\", token->allowed_maps);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_PROG_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\tif ((token->allowed_progs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_progs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_progs:\\t0x%llx\\n\", token->allowed_progs);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_ATTACH_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\tif ((token->allowed_attachs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_attachs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_attachs:\\t0x%llx\\n\", token->allowed_attachs);",
            "}",
            "int bpf_token_create(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_mount_opts *mnt_opts;",
            "\tstruct bpf_token *token = NULL;",
            "\tstruct user_namespace *userns;",
            "\tstruct inode *inode;",
            "\tstruct file *file;",
            "\tCLASS(fd, f)(attr->token_create.bpffs_fd);",
            "\tstruct path path;",
            "\tstruct super_block *sb;",
            "\tumode_t mode;",
            "\tint err, fd;",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "",
            "\tpath = fd_file(f)->f_path;",
            "\tsb = path.dentry->d_sb;",
            "",
            "\tif (path.dentry != sb->s_root)",
            "\t\treturn -EINVAL;",
            "\tif (sb->s_op != &bpf_super_ops)",
            "\t\treturn -EINVAL;",
            "\terr = path_permission(&path, MAY_ACCESS);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tuserns = sb->s_user_ns;",
            "\t/*",
            "\t * Enforce that creators of BPF tokens are in the same user",
            "\t * namespace as the BPF FS instance. This makes reasoning about",
            "\t * permissions a lot easier and we can always relax this later.",
            "\t */",
            "\tif (current_user_ns() != userns)",
            "\t\treturn -EPERM;",
            "\tif (!ns_capable(userns, CAP_BPF))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Creating BPF token in init_user_ns doesn't make much sense. */",
            "\tif (current_user_ns() == &init_user_ns)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tmnt_opts = sb->s_fs_info;",
            "\tif (mnt_opts->delegate_cmds == 0 &&",
            "\t    mnt_opts->delegate_maps == 0 &&",
            "\t    mnt_opts->delegate_progs == 0 &&",
            "\t    mnt_opts->delegate_attachs == 0)",
            "\t\treturn -ENOENT; /* no BPF token delegation is set up */",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tinode = bpf_get_inode(sb, NULL, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_token_iops;",
            "\tinode->i_fop = &bpf_token_fops;",
            "\tclear_nlink(inode); /* make sure it is unlinked */",
            "",
            "\tfile = alloc_file_pseudo(inode, path.mnt, BPF_TOKEN_INODE_NAME, O_RDWR, &bpf_token_fops);",
            "\tif (IS_ERR(file)) {",
            "\t\tiput(inode);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\ttoken = kzalloc(sizeof(*token), GFP_USER);",
            "\tif (!token) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_file;",
            "\t}",
            "",
            "\tatomic64_set(&token->refcnt, 1);",
            "",
            "\t/* remember bpffs owning userns for future ns_capable() checks */",
            "\ttoken->userns = get_user_ns(userns);",
            "",
            "\ttoken->allowed_cmds = mnt_opts->delegate_cmds;",
            "\ttoken->allowed_maps = mnt_opts->delegate_maps;",
            "\ttoken->allowed_progs = mnt_opts->delegate_progs;",
            "\ttoken->allowed_attachs = mnt_opts->delegate_attachs;",
            "",
            "\terr = security_bpf_token_create(token, attr, &path);",
            "\tif (err)",
            "\t\tgoto out_token;",
            "",
            "\tfd = get_unused_fd_flags(O_CLOEXEC);",
            "\tif (fd < 0) {",
            "\t\terr = fd;",
            "\t\tgoto out_token;",
            "\t}",
            "",
            "\tfile->private_data = token;",
            "\tfd_install(fd, file);",
            "",
            "\treturn fd;",
            "",
            "out_token:",
            "\tbpf_token_free(token);",
            "out_file:",
            "\tfput(file);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_ns_capable, bpf_token_capable, bpf_token_inc, bpf_token_free, bpf_token_put_deferred, bpf_token_put, bpf_token_release, bpf_token_show_fdinfo, bpf_token_create",
          "description": "实现BPF令牌的权限检查、引用计数管理、延迟释放及创建逻辑，包括基于挂载选项的令牌初始化和安全策略校验。",
          "similarity": 0.5338118672370911
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/token.c",
          "start_line": 230,
          "end_line": 254,
          "content": [
            "bool bpf_token_allow_cmd(const struct bpf_token *token, enum bpf_cmd cmd)",
            "{",
            "\tif (!token)",
            "\t\treturn false;",
            "\tif (!(token->allowed_cmds & (1ULL << cmd)))",
            "\t\treturn false;",
            "\treturn security_bpf_token_cmd(token, cmd) == 0;",
            "}",
            "bool bpf_token_allow_map_type(const struct bpf_token *token, enum bpf_map_type type)",
            "{",
            "\tif (!token || type >= __MAX_BPF_MAP_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn token->allowed_maps & (1ULL << type);",
            "}",
            "bool bpf_token_allow_prog_type(const struct bpf_token *token,",
            "\t\t\t       enum bpf_prog_type prog_type,",
            "\t\t\t       enum bpf_attach_type attach_type)",
            "{",
            "\tif (!token || prog_type >= __MAX_BPF_PROG_TYPE || attach_type >= __MAX_BPF_ATTACH_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn (token->allowed_progs & (1ULL << prog_type)) &&",
            "\t       (token->allowed_attachs & (1ULL << attach_type));",
            "}"
          ],
          "function_name": "bpf_token_allow_cmd, bpf_token_allow_map_type, bpf_token_allow_prog_type",
          "description": "提供对BPF命令、映射类型和程序类型的访问控制检查，通过位掩码匹配并结合安全模块验证权限。",
          "similarity": 0.5199738144874573
        }
      ]
    },
    {
      "source_file": "mm/memfd.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:40:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memfd.c`\n\n---\n\n# memfd.c 技术文档\n\n## 1. 文件概述\n\n`memfd.c` 实现了 Linux 内核中的 `memfd_create()` 系统调用及其配套的文件密封（file sealing）机制。该文件最初是 `shmem.c` 的一部分，后被拆分出来以同时支持 tmpfs 和 hugetlbfs 文件系统。其核心功能包括：\n\n- 创建匿名内存文件（memfd），无需关联磁盘或文件系统路径\n- 提供文件密封（sealing）能力，允许对共享内存区域施加不可逆的操作限制\n- 支持普通页和大页（hugetlb）两种内存分配模式\n- 通过引用计数检测和等待机制确保密封操作的安全性\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|---------|\n| `memfd_alloc_folio()` | 为 memfd 文件分配 folio（页），支持普通页和大页模式 |\n| `memfd_wait_for_pins()` | 等待所有被外部引用（如 GUP、DMA）的 folio 释放，用于 SEAL_WRITE 密封前的安全检查 |\n| `memfd_tag_pins()` | 扫描地址空间，标记具有额外引用计数的 folio |\n| `memfd_add_seals()` | 向文件添加密封标志，实现不可逆的访问控制 |\n| `memfd_get_seals()` | 获取文件当前的密封标志 |\n| `memfd_fcntl()` | 处理 F_ADD_SEALS 和 F_GET_SEALS fcntl 命令 |\n\n### 关键数据结构和常量\n\n- **密封标志**：\n  - `F_SEAL_SEAL`：禁止进一步添加密封\n  - `F_SEAL_WRITE`：禁止写入\n  - `F_SEAL_GROW/SHRINK`：禁止文件增长/缩小\n  - `F_SEAL_EXEC`：禁止修改执行权限位\n  - `F_SEAL_FUTURE_WRITE`：禁止未来写入（与 EXEC 相关）\n\n- **memfd 标志**：\n  - `MFD_CLOEXEC`：close-on-exec\n  - `MFD_ALLOW_SEALING`：允许密封\n  - `MFD_HUGETLB`：使用大页\n  - `MFD_NOEXEC_SEAL` / `MFD_EXEC`：控制执行权限\n\n- **内部标记**：\n  - `MEMFD_TAG_PINNED`：复用 `PAGECACHE_TAG_TOWRITE` 标记被外部引用的 folio\n\n## 3. 关键实现\n\n### 文件密封机制\n\n密封是一种**单向、不可逆**的访问控制机制：\n- 密封只能添加，不能移除\n- 一旦设置 `F_SEAL_SEAL`，不能再添加任何密封\n- 密封作用于整个 inode，影响所有文件描述符\n\n### 引用计数检测算法\n\n为安全实现 `SEAL_WRITE`，内核需确保无外部引用：\n1. **标记阶段** (`memfd_tag_pins`)：\n   - 遍历 radix tree 中的所有 folio\n   - 对 `folio_ref_count() - folio_mapcount() != folio_nr_pages()` 的 folio 标记为 PINNED\n   - 表示存在非映射引用（如 GUP、DMA）\n\n2. **等待阶段** (`memfd_wait_for_pins`)：\n   - 最多进行 5 次扫描（LAST_SCAN = 4）\n   - 指数退避等待（(HZ << scan) / 200）\n   - 最后一次扫描清理标记并返回 `-EBUSY`（如有残留引用）\n\n### 大页支持\n\n通过条件编译支持 hugetlbfs：\n- 检测 `is_file_hugepages()` 判断是否大页模式\n- 使用 `htlb_alloc_mask()` 并清除 `__GFP_HIGHMEM | __GFP_MOVABLE`\n- 调用 hugetlb 专用分配和缓存接口\n\n### 执行权限密封\n\n`F_SEAL_EXEC` 具有特殊语义：\n- 若文件已有执行权限（`i_mode & 0111`），自动添加 `WRITE|GROW|SHRINK|FUTURE_WRITE` 密封\n- 实现 W^X（Write XOR Execute）安全策略\n\n## 4. 依赖关系\n\n### 内核模块依赖\n\n- **内存管理**：\n  - `<linux/mm.h>`：folio 操作、GFP 标志\n  - `<linux/pagemap.h>`：address_space、radix tree 操作\n  - `<linux/shmem_fs.h>`：tmpfs inode 结构（`SHMEM_I`）\n  \n- **文件系统**：\n  - `<linux/hugetlb.h>`：大页支持（`HUGETLBFS_I`）\n  - `<linux/fs.h>` / `<linux/vfs.h>`：VFS 层接口\n  \n- **同步机制**：\n  - `<linux/sched/signal.h>`：可杀等待（`schedule_timeout_killable`）\n  - XArray 锁（`xas_lock_irq`）保证并发安全\n\n### 复用设计\n\n- **标记复用**：使用 `PAGECACHE_TAG_TOWRITE` 作为 `MEMFD_TAG_PINNED`，因 tmpfs/hugetlbfs 不使用此标记\n- **代码共享**：同时服务 tmpfs 和 hugetlbfs，通过 `memfd_file_seals_ptr()` 抽象 inode 访问\n\n## 5. 使用场景\n\n### 用户态应用场景\n\n1. **安全共享内存**：\n   - 多进程通过 `memfd_create()` 创建共享内存\n   - 生产者添加 `SEAL_WRITE` 后传递 fd 给消费者，确保数据不可篡改\n\n2. **动态代码加载**：\n   - JIT 编译器创建可执行 memfd\n   - 写入代码后密封 `SEAL_WRITE`，防止后续修改（配合 `SEAL_EXEC`）\n\n3. **容器/沙箱**：\n   - 限制不受信任进程对共享内存的操作能力\n   - 通过密封防止恶意进程破坏共享状态\n\n### 内核内部使用\n\n1. **GUP（Get User Pages）集成**：\n   - `memfd_alloc_folio()` 被 `gup.c` 调用，处理 memfd 的缺页\n   - 确保 DMA/GUP 场景下密封的安全性\n\n2. **大页优化**：\n   - 通过 `MFD_HUGETLB` 标志创建大页 memfd\n   - 适用于需要大块连续内存的高性能场景（如 DPDK）\n\n3. **安全增强**：\n   - `sysctl_memfd_noexec` 控制默认执行权限\n   - 防止 memfd 被滥用于代码注入攻击",
      "similarity": 0.5857254862785339,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/memfd.c",
          "start_line": 275,
          "end_line": 320,
          "content": [
            "static int memfd_get_seals(struct file *file)",
            "{",
            "\tunsigned int *seals = memfd_file_seals_ptr(file);",
            "",
            "\treturn seals ? *seals : -EINVAL;",
            "}",
            "long memfd_fcntl(struct file *file, unsigned int cmd, unsigned int arg)",
            "{",
            "\tlong error;",
            "",
            "\tswitch (cmd) {",
            "\tcase F_ADD_SEALS:",
            "\t\terror = memfd_add_seals(file, arg);",
            "\t\tbreak;",
            "\tcase F_GET_SEALS:",
            "\t\terror = memfd_get_seals(file);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\terror = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int check_sysctl_memfd_noexec(unsigned int *flags)",
            "{",
            "#ifdef CONFIG_SYSCTL",
            "\tstruct pid_namespace *ns = task_active_pid_ns(current);",
            "\tint sysctl = pidns_memfd_noexec_scope(ns);",
            "",
            "\tif (!(*flags & (MFD_EXEC | MFD_NOEXEC_SEAL))) {",
            "\t\tif (sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_SEAL)",
            "\t\t\t*flags |= MFD_NOEXEC_SEAL;",
            "\t\telse",
            "\t\t\t*flags |= MFD_EXEC;",
            "\t}",
            "",
            "\tif (!(*flags & MFD_NOEXEC_SEAL) && sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_ENFORCED) {",
            "\t\tpr_err_ratelimited(",
            "\t\t\t\"%s[%d]: memfd_create() requires MFD_NOEXEC_SEAL with vm.memfd_noexec=%d\\n\",",
            "\t\t\tcurrent->comm, task_pid_nr(current), sysctl);",
            "\t\treturn -EACCES;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "memfd_get_seals, memfd_fcntl, check_sysctl_memfd_noexec",
          "description": "提供密封信息查询接口(memfd_get_seals)和fcntl命令处理(memfd_fcntl)，check_sysctl_memfd_noexec根据内核配置动态调整内存文件执行权限标志，强制应用noexec安全策略。",
          "similarity": 0.5735050439834595
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memfd.c",
          "start_line": 32,
          "end_line": 194,
          "content": [
            "static bool memfd_folio_has_extra_refs(struct folio *folio)",
            "{",
            "\treturn folio_ref_count(folio) - folio_mapcount(folio) !=",
            "\t       folio_nr_pages(folio);",
            "}",
            "static void memfd_tag_pins(struct xa_state *xas)",
            "{",
            "\tstruct folio *folio;",
            "\tint latency = 0;",
            "",
            "\tlru_add_drain();",
            "",
            "\txas_lock_irq(xas);",
            "\txas_for_each(xas, folio, ULONG_MAX) {",
            "\t\tif (!xa_is_value(folio) && memfd_folio_has_extra_refs(folio))",
            "\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);",
            "",
            "\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\tcontinue;",
            "\t\tlatency = 0;",
            "",
            "\t\txas_pause(xas);",
            "\t\txas_unlock_irq(xas);",
            "\t\tcond_resched();",
            "\t\txas_lock_irq(xas);",
            "\t}",
            "\txas_unlock_irq(xas);",
            "}",
            "static int memfd_wait_for_pins(struct address_space *mapping)",
            "{",
            "\tXA_STATE(xas, &mapping->i_pages, 0);",
            "\tstruct folio *folio;",
            "\tint error, scan;",
            "",
            "\tmemfd_tag_pins(&xas);",
            "",
            "\terror = 0;",
            "\tfor (scan = 0; scan <= LAST_SCAN; scan++) {",
            "\t\tint latency = 0;",
            "",
            "\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))",
            "\t\t\tbreak;",
            "",
            "\t\tif (!scan)",
            "\t\t\tlru_add_drain_all();",
            "\t\telse if (schedule_timeout_killable((HZ << scan) / 200))",
            "\t\t\tscan = LAST_SCAN;",
            "",
            "\t\txas_set(&xas, 0);",
            "\t\txas_lock_irq(&xas);",
            "\t\txas_for_each_marked(&xas, folio, ULONG_MAX, MEMFD_TAG_PINNED) {",
            "\t\t\tbool clear = true;",
            "",
            "\t\t\tif (!xa_is_value(folio) &&",
            "\t\t\t    memfd_folio_has_extra_refs(folio)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * On the last scan, we clean up all those tags",
            "\t\t\t\t * we inserted; but make a note that we still",
            "\t\t\t\t * found folios pinned.",
            "\t\t\t\t */",
            "\t\t\t\tif (scan == LAST_SCAN)",
            "\t\t\t\t\terror = -EBUSY;",
            "\t\t\t\telse",
            "\t\t\t\t\tclear = false;",
            "\t\t\t}",
            "\t\t\tif (clear)",
            "\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);",
            "",
            "\t\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\t\tcontinue;",
            "\t\t\tlatency = 0;",
            "",
            "\t\t\txas_pause(&xas);",
            "\t\t\txas_unlock_irq(&xas);",
            "\t\t\tcond_resched();",
            "\t\t\txas_lock_irq(&xas);",
            "\t\t}",
            "\t\txas_unlock_irq(&xas);",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int memfd_add_seals(struct file *file, unsigned int seals)",
            "{",
            "\tstruct inode *inode = file_inode(file);",
            "\tunsigned int *file_seals;",
            "\tint error;",
            "",
            "\t/*",
            "\t * SEALING",
            "\t * Sealing allows multiple parties to share a tmpfs or hugetlbfs file",
            "\t * but restrict access to a specific subset of file operations. Seals",
            "\t * can only be added, but never removed. This way, mutually untrusted",
            "\t * parties can share common memory regions with a well-defined policy.",
            "\t * A malicious peer can thus never perform unwanted operations on a",
            "\t * shared object.",
            "\t *",
            "\t * Seals are only supported on special tmpfs or hugetlbfs files and",
            "\t * always affect the whole underlying inode. Once a seal is set, it",
            "\t * may prevent some kinds of access to the file. Currently, the",
            "\t * following seals are defined:",
            "\t *   SEAL_SEAL: Prevent further seals from being set on this file",
            "\t *   SEAL_SHRINK: Prevent the file from shrinking",
            "\t *   SEAL_GROW: Prevent the file from growing",
            "\t *   SEAL_WRITE: Prevent write access to the file",
            "\t *   SEAL_EXEC: Prevent modification of the exec bits in the file mode",
            "\t *",
            "\t * As we don't require any trust relationship between two parties, we",
            "\t * must prevent seals from being removed. Therefore, sealing a file",
            "\t * only adds a given set of seals to the file, it never touches",
            "\t * existing seals. Furthermore, the \"setting seals\"-operation can be",
            "\t * sealed itself, which basically prevents any further seal from being",
            "\t * added.",
            "\t *",
            "\t * Semantics of sealing are only defined on volatile files. Only",
            "\t * anonymous tmpfs and hugetlbfs files support sealing. More",
            "\t * importantly, seals are never written to disk. Therefore, there's",
            "\t * no plan to support it on other file types.",
            "\t */",
            "",
            "\tif (!(file->f_mode & FMODE_WRITE))",
            "\t\treturn -EPERM;",
            "\tif (seals & ~(unsigned int)F_ALL_SEALS)",
            "\t\treturn -EINVAL;",
            "",
            "\tinode_lock(inode);",
            "",
            "\tfile_seals = memfd_file_seals_ptr(file);",
            "\tif (!file_seals) {",
            "\t\terror = -EINVAL;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif (*file_seals & F_SEAL_SEAL) {",
            "\t\terror = -EPERM;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {",
            "\t\terror = mapping_deny_writable(file->f_mapping);",
            "\t\tif (error)",
            "\t\t\tgoto unlock;",
            "",
            "\t\terror = memfd_wait_for_pins(file->f_mapping);",
            "\t\tif (error) {",
            "\t\t\tmapping_allow_writable(file->f_mapping);",
            "\t\t\tgoto unlock;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * SEAL_EXEC implys SEAL_WRITE, making W^X from the start.",
            "\t */",
            "\tif (seals & F_SEAL_EXEC && inode->i_mode & 0111)",
            "\t\tseals |= F_SEAL_SHRINK|F_SEAL_GROW|F_SEAL_WRITE|F_SEAL_FUTURE_WRITE;",
            "",
            "\t*file_seals |= seals;",
            "\terror = 0;",
            "",
            "unlock:",
            "\tinode_unlock(inode);",
            "\treturn error;",
            "}"
          ],
          "function_name": "memfd_folio_has_extra_refs, memfd_tag_pins, memfd_wait_for_pins, memfd_add_seals",
          "description": "实现内存文件的页引用追踪与密封逻辑，memfd_tag_pins遍历页表标记额外引用页，memfd_wait_for_pins等待所有引用释放后清除标记，memfd_add_seals处理文件密封标志验证及权限限制设置。",
          "similarity": 0.5411348342895508
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memfd.c",
          "start_line": 1,
          "end_line": 31,
          "content": [
            "/*",
            " * memfd_create system call and file sealing support",
            " *",
            " * Code was originally included in shmem.c, and broken out to facilitate",
            " * use by hugetlbfs as well as tmpfs.",
            " *",
            " * This file is released under the GPL.",
            " */",
            "",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/memfd.h>",
            "#include <linux/pid_namespace.h>",
            "#include <uapi/linux/memfd.h>",
            "",
            "/*",
            " * We need a tag: a new tag would expand every xa_node by 8 bytes,",
            " * so reuse a tag which we firmly believe is never set or cleared on tmpfs",
            " * or hugetlbfs because they are memory only filesystems.",
            " */",
            "#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE",
            "#define LAST_SCAN               4       /* about 150ms max */",
            ""
          ],
          "function_name": null,
          "description": "定义MEMFD_TAG_PINNED宏用于标识内存文件的特殊页缓存标记，通过复用tmpfs和hugetlbfs中未使用的PAGECACHE_TAG_TOWRITE标签，为后续内存文件的页管理提供标记支持。",
          "similarity": 0.4588333070278168
        }
      ]
    },
    {
      "source_file": "kernel/capability.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:39:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `capability.c`\n\n---\n\n# capability.c 技术文档\n\n## 1. 文件概述\n\n`capability.c` 是 Linux 内核中实现 POSIX 能力（Capabilities）机制的核心文件，位于 `kernel/` 目录下。该文件主要负责提供用户空间与内核之间进行能力获取（`capget`）和设置（`capset`）的系统调用接口，并维护能力模型的版本兼容性、安全策略检查以及与 LSM（Linux Security Module）框架的集成。能力机制允许将传统超级用户权限细分为多个独立的特权单元，从而实现最小权限原则。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `file_caps_enabled`：控制是否启用文件能力（File Capabilities）功能的全局开关，默认启用。可通过内核启动参数 `no_file_caps` 禁用。\n\n### 主要函数\n- **`cap_validate_magic()`**：验证用户传入的能力结构体版本号，支持 v1、v2、v3 版本，并对旧版本发出警告。\n- **`cap_get_target_pid()`**：安全地获取指定进程（通过 PID）的有效（Effective）、可继承（Inheritable）和允许（Permitted）能力集。\n- **`sys_capget()`**：`capget(2)` 系统调用的实现，用于查询指定进程的能力集。\n- **`sys_capset()`**：`capset(2)` 系统调用的实现，用于设置当前进程的能力集（仅限自身）。\n- **`mk_kernel_cap()`**：将用户空间传入的高低 32 位能力值组合成内核内部的 `kernel_cap_t` 类型。\n- **`has_ns_capability()`**（截断）：检查指定任务在给定用户命名空间中是否拥有某项能力（函数体在提供的代码中被截断）。\n\n### 辅助函数\n- `warn_legacy_capability_use()`：对使用 v1（32 位）能力接口的应用程序发出一次性警告。\n- `warn_deprecated_v2()`：对使用已弃用的 v2 能力接口的应用程序发出一次性警告。\n\n## 3. 关键实现\n\n### 能力版本兼容性处理\n- 支持三种能力结构版本：\n  - **v1 (`_LINUX_CAPABILITY_VERSION_1`)**：仅支持 32 位能力（旧版），调用时触发 `warn_legacy_capability_use()`。\n  - **v2 (`_LINUX_CAPABILITY_VERSION_2`)**：支持 64 位能力但存在安全风险，调用时触发 `warn_deprecated_v2()`。\n  - **v3 (`_LINUX_CAPABILITY_VERSION_3`)**：当前推荐版本，功能等同于 v2 但通过头文件变更避免误用。\n- 对于无效版本，内核会尝试将当前支持的版本号写回用户空间并返回 `-EINVAL`。\n\n### 能力数据传输格式\n- 用户空间使用两个 `__user_cap_data_struct` 结构体（`kdata[2]`）来表示 64 位能力值：\n  - `kdata[0]` 存储低 32 位\n  - `kdata[1]` 存储高 32 位\n- 在 `capget` 中，内核能力值被拆分为高低 32 位写入用户缓冲区；在 `capset` 中则反向组合。\n- **向后兼容策略**：当用户空间请求的版本只支持 32 位（`tocopy = 1`）时，内核会静默丢弃高 32 位能力，避免旧版 `libcap` 应用崩溃。\n\n### 安全限制\n- **`capset` 限制**：仅允许进程修改自身能力（`pid` 必须为 0 或当前进程 PID），修改其他进程能力的功能已被移除。\n- **能力设置规则**（由 LSM 实现，如 `security_capset`）：\n  - 新的 **可继承集（I）** 和 **允许集（P）** 只能是旧允许集的子集。\n  - 新的 **有效集（E）** 必须是新允许集的子集。\n- 使用 `prepare_creds()` / `commit_creds()` 机制安全地更新进程凭证（credentials），并在失败时通过 `abort_creds()` 回滚。\n\n### 并发与锁机制\n- 获取**其他进程**能力时，使用 `rcu_read_lock()` 保护对进程链表的访问（通过 `find_task_by_vpid()`）。\n- 获取**当前进程**能力时无需加锁，因为能力修改是原子的（通过凭证替换）。\n\n### 审计与日志\n- `capset` 成功时调用 `audit_log_capset()` 记录能力变更事件，用于安全审计。\n- 对旧版能力接口的使用通过 `pr_info_once()` 发出一次性内核日志警告。\n\n## 4. 依赖关系\n\n- **LSM 框架**：通过 `security_capget()` 和 `security_capset()` 钩子与安全模块（如 SELinux、AppArmor）交互，实际的能力检查和设置策略由 LSM 实现。\n- **凭证子系统**：依赖 `cred` 结构体管理进程权限，使用 `prepare_creds()`、`commit_creds()` 等函数安全更新。\n- **命名空间**：支持用户命名空间（`user_namespace.h`），能力检查与命名空间隔离相关（体现在 `has_ns_capability` 等函数中）。\n- **审计子系统**：通过 `audit.h` 提供能力变更的审计日志。\n- **系统调用接口**：通过 `SYSCALL_DEFINE2` 定义 `capget` 和 `capset` 系统调用。\n- **用户空间访问**：使用 `uaccess.h` 中的 `copy_to_user()` 和 `copy_from_user()` 安全传输数据。\n\n## 5. 使用场景\n\n- **容器与沙箱**：容器运行时（如 Docker、runc）通过 `capset` 限制容器内进程的能力集，实现权限隔离。\n- **特权程序降权**：需要临时提升权限的程序（如 `ping` 使用 `CAP_NET_RAW`）可在执行关键操作后通过 `capset` 丢弃多余能力。\n- **安全策略实施**：系统管理员或安全模块通过限制进程能力，遵循最小权限原则，减少攻击面。\n- **调试与监控**：安全工具（如 `getpcaps`）通过 `capget` 查询进程当前能力状态，用于诊断或合规检查。\n- **文件能力加载**：虽然本文件不直接处理文件能力，但 `file_caps_enabled` 开关控制是否启用基于文件扩展属性（xattr）的能力加载机制（由 `fs/` 子系统实现）。",
      "similarity": 0.5851567983627319,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/capability.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/capability.c",
            " *",
            " * Copyright (C) 1997  Andrew Main <zefram@fysh.org>",
            " *",
            " * Integrated into 2.1.97+,  Andrew G. Morgan <morgan@kernel.org>",
            " * 30 May 2002:\tCleanup, Robert M. Love <rml@tech9.net>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/uaccess.h>",
            "",
            "int file_caps_enabled = 1;",
            ""
          ],
          "function_name": null,
          "description": "声明模块许可证并包含必要的头文件，定义控制文件能力启用状态的全局变量file_caps_enabled",
          "similarity": 0.6095213294029236
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/capability.c",
          "start_line": 25,
          "end_line": 125,
          "content": [
            "static int __init file_caps_disable(char *str)",
            "{",
            "\tfile_caps_enabled = 0;",
            "\treturn 1;",
            "}",
            "static void warn_legacy_capability_use(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static void warn_deprecated_v2(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)",
            "{",
            "\t__u32 version;",
            "",
            "\tif (get_user(version, &header->version))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (version) {",
            "\tcase _LINUX_CAPABILITY_VERSION_1:",
            "\t\twarn_legacy_capability_use();",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;",
            "\t\tbreak;",
            "\tcase _LINUX_CAPABILITY_VERSION_2:",
            "\t\twarn_deprecated_v2();",
            "\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */",
            "\tcase _LINUX_CAPABILITY_VERSION_3:",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))",
            "\t\t\treturn -EFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,",
            "\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)",
            "{",
            "\tint ret;",
            "",
            "\tif (pid && (pid != task_pid_vnr(current))) {",
            "\t\tconst struct task_struct *target;",
            "",
            "\t\trcu_read_lock();",
            "",
            "\t\ttarget = find_task_by_vpid(pid);",
            "\t\tif (!target)",
            "\t\t\tret = -ESRCH;",
            "\t\telse",
            "\t\t\tret = security_capget(target, pEp, pIp, pPp);",
            "",
            "\t\trcu_read_unlock();",
            "\t} else",
            "\t\tret = security_capget(current, pEp, pIp, pPp);",
            "",
            "\treturn ret;",
            "}",
            "static kernel_cap_t mk_kernel_cap(u32 low, u32 high)",
            "{",
            "\treturn (kernel_cap_t) { (low | ((u64)high << 32)) & CAP_VALID_MASK };",
            "}",
            "bool has_ns_capability(struct task_struct *t,",
            "\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability(t, &init_user_ns, cap);",
            "}",
            "bool has_ns_capability_noaudit(struct task_struct *t,",
            "\t\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability_noaudit(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);",
            "}"
          ],
          "function_name": "file_caps_disable, warn_legacy_capability_use, warn_deprecated_v2, cap_validate_magic, cap_get_target_pid, mk_kernel_cap, has_ns_capability, has_capability, has_ns_capability_noaudit, has_capability_noaudit",
          "description": "提供能力相关辅助函数，包括禁用文件能力标志、版本验证警告、目标进程能力获取及能力结构构建，实现命名空间能力检查和权限验证逻辑",
          "similarity": 0.5715469717979431
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/capability.c",
          "start_line": 351,
          "end_line": 424,
          "content": [
            "static bool ns_capable_common(struct user_namespace *ns,",
            "\t\t\t      int cap,",
            "\t\t\t      unsigned int opts)",
            "{",
            "\tint capable;",
            "",
            "\tif (unlikely(!cap_valid(cap))) {",
            "\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);",
            "\t\tBUG();",
            "\t}",
            "",
            "\tcapable = security_capable(current_cred(), ns, cap, opts);",
            "\tif (capable == 0) {",
            "\t\tcurrent->flags |= PF_SUPERPRIV;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "bool ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);",
            "}",
            "bool ns_capable_noaudit(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);",
            "}",
            "bool ns_capable_setid(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);",
            "}",
            "bool capable(int cap)",
            "{",
            "\treturn ns_capable(&init_user_ns, cap);",
            "}",
            "bool file_ns_capable(const struct file *file, struct user_namespace *ns,",
            "\t\t     int cap)",
            "{",
            "",
            "\tif (WARN_ON_ONCE(!cap_valid(cap)))",
            "\t\treturn false;",
            "",
            "\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,",
            "\t\t\t\t struct mnt_idmap *idmap,",
            "\t\t\t\t const struct inode *inode)",
            "{",
            "\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&",
            "\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));",
            "}",
            "bool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,",
            "\t\t\t      const struct inode *inode, int cap)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "",
            "\treturn ns_capable(ns, cap) &&",
            "\t       privileged_wrt_inode_uidgid(ns, idmap, inode);",
            "}",
            "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)",
            "{",
            "\tint ret = 0;  /* An absent tracer adds no restrictions */",
            "\tconst struct cred *cred;",
            "",
            "\trcu_read_lock();",
            "\tcred = rcu_dereference(tsk->ptracer_cred);",
            "\tif (cred)",
            "\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,",
            "\t\t\t\t       CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "\treturn (ret == 0);",
            "}"
          ],
          "function_name": "ns_capable_common, ns_capable, ns_capable_noaudit, ns_capable_setid, capable, file_ns_capable, privileged_wrt_inode_uidgid, capable_wrt_inode_uidgid, ptracer_capable",
          "description": "实现核心能力检查函数，包含通用命名空间能力检测、当前命名空间能力检查、文件能力验证、基于inode UID/GID的特权判断及跟踪者能力检查等功能",
          "similarity": 0.513018012046814
        }
      ]
    }
  ]
}