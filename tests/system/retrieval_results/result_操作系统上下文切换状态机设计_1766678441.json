{
  "query": "操作系统上下文切换状态机设计",
  "timestamp": "2025-12-26 00:00:41",
  "retrieved_files": [
    {
      "source_file": "kernel/power/console.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:19:20\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\console.c`\n\n---\n\n# power/console.c 技术文档\n\n## 1. 文件概述\n\n`power/console.c` 是 Linux 内核电源管理子系统中的一个组件，负责在系统挂起（suspend）和恢复（resume）过程中对控制台（console）进行保存与恢复操作。其主要目标是通过虚拟终端（VT）切换机制，确保在系统休眠期间控制台状态的正确性和可视性，同时支持部分图形或控制台驱动实现“无闪烁”（flicker-free）的挂起/恢复流程。\n\n该文件最初源自 `swsusp`（Software Suspend）项目，现用于协调多个控制台驱动对 VT 切换的需求，避免不必要的屏幕闪烁，并在必要时将内核日志重定向到专用的挂起控制台。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `pm_vt_switch_required(struct device *dev, bool required)`  \n  注册设备对 VT 切换的需求。若 `required` 为 `true`，表示该设备驱动在挂起/恢复时需要进行 VT 切换；若为 `false`，则表示支持无切换挂起。\n\n- `pm_vt_switch_unregister(struct device *dev)`  \n  注销设备的 VT 切换需求，将其从跟踪列表中移除。\n\n- `pm_prepare_console(void)`  \n  在系统挂起前准备控制台：若需要 VT 切换，则切换到专用的挂起控制台（`SUSPEND_CONSOLE`），并重定向内核消息输出。\n\n- `pm_restore_console(void)`  \n  在系统恢复后还原控制台：切换回原始前台控制台，并恢复内核消息的原始重定向目标。\n\n### 主要数据结构\n\n- `struct pm_vt_switch`  \n  表示一个设备对 VT 切换的需求：\n  ```c\n  struct pm_vt_switch {\n      struct list_head head;   // 链表节点\n      struct device *dev;      // 关联的设备\n      bool required;           // 是否需要 VT 切换\n  };\n  ```\n\n- 全局变量：\n  - `orig_fgconsole`：原始前台控制台编号。\n  - `orig_kmsg`：原始内核消息重定向目标控制台。\n  - `vt_switch_done`：标志位，表示是否已执行 VT 切换。\n  - `pm_vt_switch_list`：所有注册设备的 VT 切换需求链表。\n  - `vt_switch_mutex`：保护链表操作的互斥锁。\n\n## 3. 关键实现\n\n### VT 切换决策逻辑（`pm_vt_switch()`）\n\n系统是否执行 VT 切换由以下三个条件之一触发：\n1. **无任何驱动注册需求**：保留传统行为（默认切换）。\n2. **`console_suspend_enabled` 被禁用**（通过内核命令行参数 `no_console_suspend`）：需显示挂起/恢复期间的调试信息。\n3. **任一已注册驱动声明需要 VT 切换**（`required == true`）。\n\n只有当**所有已注册驱动都明确声明不需要 VT 切换**，且 `console_suspend_enabled` 为 `true` 时，才可跳过 VT 切换，实现无闪烁恢复。\n\n### 控制台保存与恢复流程\n\n- **挂起前（`pm_prepare_console`）**：\n  - 若需切换，调用 `vt_move_to_console(SUSPEND_CONSOLE, 1)` 切换到专用控制台（编号 `MAX_NR_CONSOLES-1`）。\n  - 使用 `vt_kmsg_redirect()` 将内核日志重定向至该控制台。\n  - 记录原始前台控制台编号和原始重定向目标。\n\n- **恢复后（`pm_restore_console`）**：\n  - 若曾执行切换，调用 `vt_move_to_console(orig_fgconsole, 0)` 切回原前台控制台。\n  - 恢复内核消息重定向至原始目标。\n  - 清除 `vt_switch_done` 标志。\n\n### 线程安全\n\n所有对 `pm_vt_switch_list` 的访问均受 `vt_switch_mutex` 互斥锁保护，确保在并发注册/注销场景下的数据一致性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/console.h>`：控制台核心接口。\n  - `<linux/vt_kern.h>` 和 `<linux/vt.h>`：虚拟终端内核接口，提供 `vt_move_to_console()` 和 `vt_kmsg_redirect()`。\n  - `<linux/kbd_kern.h>`：键盘相关（虽未直接使用，但 VT 子系统依赖）。\n  - `\"power.h\"`：本地电源管理头文件（可能定义 `console_suspend_enabled` 等）。\n\n- **内核子系统依赖**：\n  - **VT 子系统**：提供虚拟终端管理和切换能力。\n  - **电源管理核心（PM Core）**：本文件被 PM Core 在挂起/恢复流程中调用。\n  - **控制台驱动**：如 `fbcon`、`vgacon` 等可通过 `pm_vt_switch_required()` 声明自身需求。\n\n- **导出符号**：\n  - `pm_vt_switch_required` 和 `pm_vt_switch_unregister` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如显卡驱动）调用。\n\n## 5. 使用场景\n\n- **系统挂起/恢复流程**：  \n  在 `suspend` 阶段调用 `pm_prepare_console()`，在 `resume` 阶段调用 `pm_restore_console()`，确保控制台状态一致。\n\n- **图形驱动优化**：  \n  支持现代显示驱动（如 DRM/KMS 驱动）在挂起/恢复时自行管理显示状态，无需 VT 切换，从而避免屏幕闪烁，提升用户体验。\n\n- **调试支持**：  \n  当启用 `no_console_suspend` 内核参数时，强制进行 VT 切换并将内核日志输出到可见控制台，便于调试挂起/恢复问题。\n\n- **多控制台环境协调**：  \n  在存在多个控制台驱动（如文本控制台与帧缓冲控制台共存）时，统一协调 VT 切换策略，防止冲突。",
      "similarity": 0.5661449432373047,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/power/console.c",
          "start_line": 47,
          "end_line": 132,
          "content": [
            "void pm_vt_switch_required(struct device *dev, bool required)",
            "{",
            "\tstruct pm_vt_switch *entry, *tmp;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {",
            "\t\tif (tmp->dev == dev) {",
            "\t\t\t/* already registered, update requirement */",
            "\t\t\ttmp->required = required;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);",
            "\tif (!entry)",
            "\t\tgoto out;",
            "",
            "\tentry->required = required;",
            "\tentry->dev = dev;",
            "",
            "\tlist_add(&entry->head, &pm_vt_switch_list);",
            "out:",
            "\tmutex_unlock(&vt_switch_mutex);",
            "}",
            "void pm_vt_switch_unregister(struct device *dev)",
            "{",
            "\tstruct pm_vt_switch *tmp;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {",
            "\t\tif (tmp->dev == dev) {",
            "\t\t\tlist_del(&tmp->head);",
            "\t\t\tkfree(tmp);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&vt_switch_mutex);",
            "}",
            "static bool pm_vt_switch(void)",
            "{",
            "\tstruct pm_vt_switch *entry;",
            "\tbool ret = true;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tif (list_empty(&pm_vt_switch_list))",
            "\t\tgoto out;",
            "",
            "\tif (!console_suspend_enabled)",
            "\t\tgoto out;",
            "",
            "\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {",
            "\t\tif (entry->required)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tret = false;",
            "out:",
            "\tmutex_unlock(&vt_switch_mutex);",
            "\treturn ret;",
            "}",
            "void pm_prepare_console(void)",
            "{",
            "\tif (!pm_vt_switch())",
            "\t\treturn;",
            "",
            "\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);",
            "\tif (orig_fgconsole < 0)",
            "\t\treturn;",
            "",
            "\tvt_switch_done = true;",
            "",
            "\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);",
            "\treturn;",
            "}",
            "void pm_restore_console(void)",
            "{",
            "\tif (!pm_vt_switch() && !vt_switch_done)",
            "\t\treturn;",
            "",
            "\tif (orig_fgconsole >= 0) {",
            "\t\tvt_move_to_console(orig_fgconsole, 0);",
            "\t\tvt_kmsg_redirect(orig_kmsg);",
            "\t}",
            "",
            "\tvt_switch_done = false;",
            "}"
          ],
          "function_name": "pm_vt_switch_required, pm_vt_switch_unregister, pm_vt_switch, pm_prepare_console, pm_restore_console",
          "description": "实现VT切换需求注册/注销操作，判断是否需执行VT切换的辅助函数，以及准备/恢复控制台状态的完整流程，包含控制台切换和kmsg重定向的原子操作",
          "similarity": 0.5173354744911194
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/power/console.c",
          "start_line": 1,
          "end_line": 46,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Functions for saving/restoring console.",
            " *",
            " * Originally from swsusp.",
            " */",
            "",
            "#include <linux/console.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include \"power.h\"",
            "",
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)",
            "",
            "static int orig_fgconsole, orig_kmsg;",
            "static bool vt_switch_done;",
            "",
            "static DEFINE_MUTEX(vt_switch_mutex);",
            "",
            "struct pm_vt_switch {",
            "\tstruct list_head head;",
            "\tstruct device *dev;",
            "\tbool required;",
            "};",
            "",
            "static LIST_HEAD(pm_vt_switch_list);",
            "",
            "",
            "/**",
            " * pm_vt_switch_required - indicate VT switch at suspend requirements",
            " * @dev: device",
            " * @required: if true, caller needs VT switch at suspend/resume time",
            " *",
            " * The different console drivers may or may not require VT switches across",
            " * suspend/resume, depending on how they handle restoring video state and",
            " * what may be running.",
            " *",
            " * Drivers can indicate support for switchless suspend/resume, which can",
            " * save time and flicker, by using this routine and passing 'false' as",
            " * the argument.  If any loaded driver needs VT switching, or the",
            " * no_console_suspend argument has been passed on the command line, VT",
            " * switches will occur.",
            " */"
          ],
          "function_name": null,
          "description": "定义控制台保存/恢复相关全局变量及结构体，用于记录原始前台控制台和kmsg重定向信息，声明PM VT切换需求管理接口，包含VT切换所需锁和链表结构",
          "similarity": 0.4778650999069214
        }
      ]
    },
    {
      "source_file": "kernel/printk/nbcon.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:32:39\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `printk\\nbcon.c`\n\n---\n\n# printk/nbcon.c 技术文档\n\n## 文件概述\n\n`printk/nbcon.c` 实现了新一代的 printk 控制台（nbcon，即 \"new console\"）打印机制，该机制不依赖传统的 `console_lock` 互斥锁，而是采用基于原子操作的状态机模型来管理控制台访问。其核心目标是支持高优先级上下文（如中断、NMI、panic）安全、高效地抢占低优先级上下文对控制台的使用权，同时避免死锁和优先级反转问题。该机制特别适用于实时系统和 panic 场景下的可靠日志输出。\n\n## 核心功能\n\n### 主要数据结构\n- **`struct nbcon_state`**：封装控制台状态的原子变量，包含以下关键字段：\n  - `prio`：当前持有控制台的上下文优先级（0 表示未锁定）\n  - `cpu`：当前持有控制台的 CPU 编号\n  - `req_prio`：请求友好移交的更高优先级上下文的优先级\n  - `unsafe`：标志当前是否处于不安全状态（如正在操作共享资源）\n  - `unsafe_takeover`：标志是否发生过不安全的强制接管\n\n### 主要函数\n- **`nbcon_state_set()`**：初始化或重置控制台状态（仅限未注册或初始化阶段使用）\n- **`nbcon_state_read()`**：原子读取当前控制台状态\n- **`nbcon_state_try_cmpxchg()`**：原子比较并交换控制台状态\n- **`nbcon_seq_read()`**：读取控制台当前应打印的 printk 记录序列号\n- **`nbcon_seq_force()`**：强制设置控制台序列号（用于初始化或 panic 场景）\n- **`nbcon_seq_try_update()`**：尝试原子更新控制台序列号\n- **`nbcon_context_try_acquire_direct()`**：尝试直接获取控制台所有权（核心获取逻辑之一）\n\n## 关键实现\n\n### 控制台状态管理机制\n控制台状态通过 `nbcon_state` 原子变量管理，支持三种获取策略：\n1. **直接获取**：当控制台未被占用，或当前持有者优先级更低且处于安全状态时，直接抢占。\n2. **友好移交**：当持有者优先级更低但处于不安全状态时，请求者设置 `req_prio`，持有者在退出不安全状态后主动释放。\n3. **强制接管**：仅在 `panic()` 的最后尝试中使用，无视不安全状态强制接管（标记 `unsafe_takeover`）。\n\n### 安全状态标记\n- **`unsafe` 字段**：在操作共享资源或控制台设备时置位，操作完成后清除。确保高优先级上下文不会在设备不一致状态下接管。\n- **`unsafe_takeover` 字段**：记录强制接管事件，后续需重新初始化控制台状态。\n\n### 序列号管理\n- 使用 64 位序列号跟踪下一条待打印的 printk 记录。\n- 在 32 位系统上，仅存储低 32 位，高 32 位通过 ringbuffer 中的有效序列号推导。\n- `nbcon_seq_force()` 确保设置的序列号不低于 ringbuffer 中最早的有效记录。\n\n### 优先级与 CPU 绑定\n- 优先级数值越大表示优先级越高（`NBCON_PRIO_NONE = 0` 表示无持有者）。\n- `cpu` 字段防止同 CPU 上的忙等待，并处理复杂场景下优先级相同但 CPU 切换的情况。\n\n## 依赖关系\n\n- **内部依赖**：\n  - `printk_ringbuffer.h`：提供 printk 环形缓冲区操作接口（如 `prb_first_valid_seq()`）\n  - `internal.h`：包含 nbcon 内部定义的辅助宏和类型（如 `ACCESS_PRIVATE`、`__ulseq_to_u64seq`）\n- **内核核心模块**：\n  - `linux/atomic.h`：提供原子操作支持\n  - `linux/console.h`：定义 `struct console` 及相关常量\n  - `linux/irqflags.h`：用于中断上下文判断\n  - `linux/smp.h`：SMP 相关支持（如 `smp_processor_id()`）\n- **关键子系统**：\n  - **Printk 子系统**：作为 printk 输出后端，与 ringbuffer 紧密集成\n  - **调度器/中断子系统**：依赖上下文优先级模型（如 NMI > IRQ > 进程）\n\n## 使用场景\n\n1. **常规 printk 输出**：\n   - 高优先级中断/NMI 日志可安全抢占低优先级进程的控制台输出。\n   - 每条 printk 记录独立输出，被抢占时由新持有者重试整条记录。\n\n2. **Panic 处理**：\n   - 在 `panic()` 流程中，通过强制接管机制确保最后的日志能输出。\n   - 使用独立的 panic 记录缓冲区，避免因不安全状态导致数据损坏。\n\n3. **实时系统**：\n   - 避免传统 `console_lock` 导致的优先级反转问题。\n   - 保证高优先级任务/中断的日志能及时输出。\n\n4. **控制台驱动实现**：\n   - 控制台驱动需在关键操作（如设备寄存器访问）前后标记 `unsafe` 状态。\n   - 驱动需在每次输出字符后检查移交请求（`req_prio`），及时释放控制台。",
      "similarity": 0.5530789494514465,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 1087,
          "end_line": 1200,
          "content": [
            "static bool nbcon_emit_one(struct nbcon_write_context *wctxt, bool use_atomic)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(wctxt, ctxt);",
            "\tstruct console *con = ctxt->console;",
            "\tunsigned long flags;",
            "\tbool ret = false;",
            "",
            "\tif (!use_atomic) {",
            "\t\tcon->device_lock(con, &flags);",
            "",
            "\t\t/*",
            "\t\t * Ensure this stays on the CPU to make handover and",
            "\t\t * takeover possible.",
            "\t\t */",
            "\t\tcant_migrate();",
            "\t}",
            "",
            "\tif (!nbcon_context_try_acquire(ctxt))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * nbcon_emit_next_record() returns false when the console was",
            "\t * handed over or taken over. In both cases the context is no",
            "\t * longer valid.",
            "\t *",
            "\t * The higher priority printing context takes over responsibility",
            "\t * to print the pending records.",
            "\t */",
            "\tif (!nbcon_emit_next_record(wctxt, use_atomic))",
            "\t\tgoto out;",
            "",
            "\tnbcon_context_release(ctxt);",
            "",
            "\tret = ctxt->backlog;",
            "out:",
            "\tif (!use_atomic)",
            "\t\tcon->device_unlock(con, flags);",
            "\treturn ret;",
            "}",
            "static bool nbcon_kthread_should_wakeup(struct console *con, struct nbcon_context *ctxt)",
            "{",
            "\tbool ret = false;",
            "\tshort flags;",
            "\tint cookie;",
            "",
            "\tif (kthread_should_stop())",
            "\t\treturn true;",
            "",
            "\tcookie = console_srcu_read_lock();",
            "",
            "\tflags = console_srcu_read_flags(con);",
            "\tif (console_is_usable(con, flags, false)) {",
            "\t\t/* Bring the sequence in @ctxt up to date */",
            "\t\tctxt->seq = nbcon_seq_read(con);",
            "",
            "\t\tret = prb_read_valid(prb, ctxt->seq, NULL);",
            "\t}",
            "",
            "\tconsole_srcu_read_unlock(cookie);",
            "\treturn ret;",
            "}",
            "static int nbcon_kthread_func(void *__console)",
            "{",
            "\tstruct console *con = __console;",
            "\tstruct nbcon_write_context wctxt = {",
            "\t\t.ctxt.console\t= con,",
            "\t\t.ctxt.prio\t= NBCON_PRIO_NORMAL,",
            "\t};",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(&wctxt, ctxt);",
            "\tshort con_flags;",
            "\tbool backlog;",
            "\tint cookie;",
            "",
            "wait_for_event:",
            "\t/*",
            "\t * Guarantee this task is visible on the rcuwait before",
            "\t * checking the wake condition.",
            "\t *",
            "\t * The full memory barrier within set_current_state() of",
            "\t * ___rcuwait_wait_event() pairs with the full memory",
            "\t * barrier within rcuwait_has_sleeper().",
            "\t *",
            "\t * This pairs with rcuwait_has_sleeper:A and nbcon_kthread_wake:A.",
            "\t */",
            "\trcuwait_wait_event(&con->rcuwait,",
            "\t\t\t   nbcon_kthread_should_wakeup(con, ctxt),",
            "\t\t\t   TASK_INTERRUPTIBLE); /* LMM(nbcon_kthread_func:A) */",
            "",
            "\tdo {",
            "\t\tif (kthread_should_stop())",
            "\t\t\treturn 0;",
            "",
            "\t\tbacklog = false;",
            "",
            "\t\t/*",
            "\t\t * Keep the srcu read lock around the entire operation so that",
            "\t\t * synchronize_srcu() can guarantee that the kthread stopped",
            "\t\t * or suspended printing.",
            "\t\t */",
            "\t\tcookie = console_srcu_read_lock();",
            "",
            "\t\tcon_flags = console_srcu_read_flags(con);",
            "",
            "\t\tif (console_is_usable(con, con_flags, false))",
            "\t\t\tbacklog = nbcon_emit_one(&wctxt, false);",
            "",
            "\t\tconsole_srcu_read_unlock(cookie);",
            "",
            "\t\tcond_resched();",
            "",
            "\t} while (backlog);",
            "",
            "\tgoto wait_for_event;",
            "}"
          ],
          "function_name": "nbcon_emit_one, nbcon_kthread_should_wakeup, nbcon_kthread_func",
          "description": "实现了控制台消息异步发射机制，包含nbcon_emit_one用于单条消息处理，nbcon_kthread_func作为打印线程主循环，通过RCU等待条件判断是否需要唤醒打印线程进行消息输出。",
          "similarity": 0.5572569966316223
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 128,
          "end_line": 242,
          "content": [
            "static inline void nbcon_state_set(struct console *con, struct nbcon_state *new)",
            "{",
            "\tatomic_set(&ACCESS_PRIVATE(con, nbcon_state), new->atom);",
            "}",
            "static inline void nbcon_state_read(struct console *con, struct nbcon_state *state)",
            "{",
            "\tstate->atom = atomic_read(&ACCESS_PRIVATE(con, nbcon_state));",
            "}",
            "static inline bool nbcon_state_try_cmpxchg(struct console *con, struct nbcon_state *cur,",
            "\t\t\t\t\t   struct nbcon_state *new)",
            "{",
            "\treturn atomic_try_cmpxchg(&ACCESS_PRIVATE(con, nbcon_state), &cur->atom, new->atom);",
            "}",
            "u64 nbcon_seq_read(struct console *con)",
            "{",
            "\tunsigned long nbcon_seq = atomic_long_read(&ACCESS_PRIVATE(con, nbcon_seq));",
            "",
            "\treturn __ulseq_to_u64seq(prb, nbcon_seq);",
            "}",
            "void nbcon_seq_force(struct console *con, u64 seq)",
            "{",
            "\t/*",
            "\t * If the specified record no longer exists, the oldest available record",
            "\t * is chosen. This is especially important on 32bit systems because only",
            "\t * the lower 32 bits of the sequence number are stored. The upper 32 bits",
            "\t * are derived from the sequence numbers available in the ringbuffer.",
            "\t */",
            "\tu64 valid_seq = max_t(u64, seq, prb_first_valid_seq(prb));",
            "",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_seq), __u64seq_to_ulseq(valid_seq));",
            "}",
            "static void nbcon_seq_try_update(struct nbcon_context *ctxt, u64 new_seq)",
            "{",
            "\tunsigned long nbcon_seq = __u64seq_to_ulseq(ctxt->seq);",
            "\tstruct console *con = ctxt->console;",
            "",
            "\tif (atomic_long_try_cmpxchg(&ACCESS_PRIVATE(con, nbcon_seq), &nbcon_seq,",
            "\t\t\t\t    __u64seq_to_ulseq(new_seq))) {",
            "\t\tctxt->seq = new_seq;",
            "\t} else {",
            "\t\tctxt->seq = nbcon_seq_read(con);",
            "\t}",
            "}",
            "static int nbcon_context_try_acquire_direct(struct nbcon_context *ctxt,",
            "\t\t\t\t\t    struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\tdo {",
            "\t\t/*",
            "\t\t * Panic does not imply that the console is owned. However, it",
            "\t\t * is critical that non-panic CPUs during panic are unable to",
            "\t\t * acquire ownership in order to satisfy the assumptions of",
            "\t\t * nbcon_waiter_matches(). In particular, the assumption that",
            "\t\t * lower priorities are ignored during panic.",
            "\t\t */",
            "\t\tif (other_cpu_in_panic())",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio)",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (cur->unsafe)",
            "\t\t\treturn -EBUSY;",
            "",
            "\t\t/*",
            "\t\t * The console should never be safe for a direct acquire",
            "\t\t * if an unsafe hostile takeover has ever happened.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(cur->unsafe_takeover);",
            "",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.prio\t= ctxt->prio;",
            "\t\tnew.req_prio\t= NBCON_PRIO_NONE;",
            "\t\tnew.unsafe\t= cur->unsafe_takeover;",
            "\t\tnew.cpu\t\t= cpu;",
            "",
            "\t} while (!nbcon_state_try_cmpxchg(con, cur, &new));",
            "",
            "\treturn 0;",
            "}",
            "static bool nbcon_waiter_matches(struct nbcon_state *cur, int expected_prio)",
            "{",
            "\t/*",
            "\t * The request context is well defined by the @req_prio because:",
            "\t *",
            "\t * - Only a context with a priority higher than the owner can become",
            "\t *   a waiter.",
            "\t * - Only a context with a priority higher than the waiter can",
            "\t *   directly take over the request.",
            "\t * - There are only three priorities.",
            "\t * - Only one CPU is allowed to request PANIC priority.",
            "\t * - Lower priorities are ignored during panic() until reboot.",
            "\t *",
            "\t * As a result, the following scenario is *not* possible:",
            "\t *",
            "\t * 1. This context is currently a waiter.",
            "\t * 2. Another context with a higher priority than this context",
            "\t *    directly takes ownership.",
            "\t * 3. The higher priority context releases the ownership.",
            "\t * 4. Another lower priority context takes the ownership.",
            "\t * 5. Another context with the same priority as this context",
            "\t *    creates a request and starts waiting.",
            "\t *",
            "\t * Event #1 implies this context is EMERGENCY.",
            "\t * Event #2 implies the new context is PANIC.",
            "\t * Event #3 occurs when panic() has flushed the console.",
            "\t * Events #4 and #5 are not possible due to the other_cpu_in_panic()",
            "\t * check in nbcon_context_try_acquire_direct().",
            "\t */",
            "",
            "\treturn (cur->req_prio == expected_prio);",
            "}"
          ],
          "function_name": "nbcon_state_set, nbcon_state_read, nbcon_state_try_cmpxchg, nbcon_seq_read, nbcon_seq_force, nbcon_seq_try_update, nbcon_context_try_acquire_direct, nbcon_waiter_matches",
          "description": "实现直接获取控制台的逻辑，包含优先级检查、安全状态验证和状态原子更新，通过cmpxchg保证并发安全性，处理跨CPU和panic场景下的所有权转移规则。",
          "similarity": 0.5517033338546753
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 335,
          "end_line": 473,
          "content": [
            "static int nbcon_context_try_acquire_requested(struct nbcon_context *ctxt,",
            "\t\t\t\t\t       struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "",
            "\t/* Note that the caller must still remove the request! */",
            "\tif (other_cpu_in_panic())",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Note that the waiter will also change if there was an unsafe",
            "\t * hostile takeover.",
            "\t */",
            "\tif (!nbcon_waiter_matches(cur, ctxt->prio))",
            "\t\treturn -EPERM;",
            "",
            "\t/* If still locked, caller should continue waiting. */",
            "\tif (cur->prio != NBCON_PRIO_NONE)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * The previous owner should have never released ownership",
            "\t * in an unsafe region.",
            "\t */",
            "\tWARN_ON_ONCE(cur->unsafe);",
            "",
            "\tnew.atom = cur->atom;",
            "\tnew.prio\t= ctxt->prio;",
            "\tnew.req_prio\t= NBCON_PRIO_NONE;",
            "\tnew.unsafe\t= cur->unsafe_takeover;",
            "\tnew.cpu\t\t= cpu;",
            "",
            "\tif (!nbcon_state_try_cmpxchg(con, cur, &new)) {",
            "\t\t/*",
            "\t\t * The acquire could fail only when it has been taken",
            "\t\t * over by a higher priority context.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(nbcon_waiter_matches(cur, ctxt->prio));",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* Handover success. This context now owns the console. */",
            "\treturn 0;",
            "}",
            "static int nbcon_context_try_acquire_handover(struct nbcon_context *ctxt,",
            "\t\t\t\t\t      struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state new;",
            "\tint timeout;",
            "\tint request_err = -EBUSY;",
            "",
            "\t/*",
            "\t * Check that the handover is called when the direct acquire failed",
            "\t * with -EBUSY.",
            "\t */",
            "\tWARN_ON_ONCE(ctxt->prio <= cur->prio || ctxt->prio <= cur->req_prio);",
            "\tWARN_ON_ONCE(!cur->unsafe);",
            "",
            "\t/* Handover is not possible on the same CPU. */",
            "\tif (cur->cpu == cpu)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * Console stays unsafe after an unsafe takeover until re-initialized.",
            "\t * Waiting is not going to help in this case.",
            "\t */",
            "\tif (cur->unsafe_takeover)",
            "\t\treturn -EBUSY;",
            "",
            "\t/* Is the caller willing to wait? */",
            "\tif (ctxt->spinwait_max_us == 0)",
            "\t\treturn -EBUSY;",
            "",
            "\t/*",
            "\t * Setup a request for the handover. The caller should try to acquire",
            "\t * the console directly when the current state has been modified.",
            "\t */",
            "\tnew.atom = cur->atom;",
            "\tnew.req_prio = ctxt->prio;",
            "\tif (!nbcon_state_try_cmpxchg(con, cur, &new))",
            "\t\treturn -EAGAIN;",
            "",
            "\tcur->atom = new.atom;",
            "",
            "\t/* Wait until there is no owner and then acquire the console. */",
            "\tfor (timeout = ctxt->spinwait_max_us; timeout >= 0; timeout--) {",
            "\t\t/* On successful acquire, this request is cleared. */",
            "\t\trequest_err = nbcon_context_try_acquire_requested(ctxt, cur);",
            "\t\tif (!request_err)",
            "\t\t\treturn 0;",
            "",
            "\t\t/*",
            "\t\t * If the acquire should be aborted, it must be ensured",
            "\t\t * that the request is removed before returning to caller.",
            "\t\t */",
            "\t\tif (request_err == -EPERM)",
            "\t\t\tbreak;",
            "",
            "\t\tudelay(1);",
            "",
            "\t\t/* Re-read the state because some time has passed. */",
            "\t\tnbcon_state_read(con, cur);",
            "\t}",
            "",
            "\t/* Timed out or aborted. Carefully remove handover request. */",
            "\tdo {",
            "\t\t/*",
            "\t\t * No need to remove request if there is a new waiter. This",
            "\t\t * can only happen if a higher priority context has taken over",
            "\t\t * the console or the handover request.",
            "\t\t */",
            "\t\tif (!nbcon_waiter_matches(cur, ctxt->prio))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t/* Unset request for handover. */",
            "\t\tnew.atom = cur->atom;",
            "\t\tnew.req_prio = NBCON_PRIO_NONE;",
            "\t\tif (nbcon_state_try_cmpxchg(con, cur, &new)) {",
            "\t\t\t/*",
            "\t\t\t * Request successfully unset. Report failure of",
            "\t\t\t * acquiring via handover.",
            "\t\t\t */",
            "\t\t\tcur->atom = new.atom;",
            "\t\t\treturn request_err;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Unable to remove request. Try to acquire in case",
            "\t\t * the owner has released the lock.",
            "\t\t */",
            "\t} while (nbcon_context_try_acquire_requested(ctxt, cur));",
            "",
            "\t/* Lucky timing. The acquire succeeded while removing the request. */",
            "\treturn 0;",
            "}"
          ],
          "function_name": "nbcon_context_try_acquire_requested, nbcon_context_try_acquire_handover",
          "description": "实现友好移交机制，通过设置请求优先级并轮询等待所有者释放，包含超时控制和状态同步，确保高优先级任务可中断低优先级控制台输出。",
          "similarity": 0.5454890727996826
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 651,
          "end_line": 757,
          "content": [
            "static void nbcon_context_release(struct nbcon_context *ctxt)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "\tstruct nbcon_state new;",
            "",
            "\tnbcon_state_read(con, &cur);",
            "",
            "\tdo {",
            "\t\tif (!nbcon_owner_matches(&cur, cpu, ctxt->prio))",
            "\t\t\tbreak;",
            "",
            "\t\tnew.atom = cur.atom;",
            "\t\tnew.prio = NBCON_PRIO_NONE;",
            "",
            "\t\t/*",
            "\t\t * If @unsafe_takeover is set, it is kept set so that",
            "\t\t * the state remains permanently unsafe.",
            "\t\t */",
            "\t\tnew.unsafe |= cur.unsafe_takeover;",
            "",
            "\t} while (!nbcon_state_try_cmpxchg(con, &cur, &new));",
            "",
            "\tctxt->pbufs = NULL;",
            "}",
            "static bool nbcon_context_can_proceed(struct nbcon_context *ctxt, struct nbcon_state *cur)",
            "{",
            "\tunsigned int cpu = smp_processor_id();",
            "",
            "\t/* Make sure this context still owns the console. */",
            "\tif (!nbcon_owner_matches(cur, cpu, ctxt->prio))",
            "\t\treturn false;",
            "",
            "\t/* The console owner can proceed if there is no waiter. */",
            "\tif (cur->req_prio == NBCON_PRIO_NONE)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * A console owner within an unsafe region is always allowed to",
            "\t * proceed, even if there are waiters. It can perform a handover",
            "\t * when exiting the unsafe region. Otherwise the waiter will",
            "\t * need to perform an unsafe hostile takeover.",
            "\t */",
            "\tif (cur->unsafe)",
            "\t\treturn true;",
            "",
            "\t/* Waiters always have higher priorities than owners. */",
            "\tWARN_ON_ONCE(cur->req_prio <= cur->prio);",
            "",
            "\t/*",
            "\t * Having a safe point for take over and eventually a few",
            "\t * duplicated characters or a full line is way better than a",
            "\t * hostile takeover. Post processing can take care of the garbage.",
            "\t * Release and hand over.",
            "\t */",
            "\tnbcon_context_release(ctxt);",
            "",
            "\t/*",
            "\t * It is not clear whether the waiter really took over ownership. The",
            "\t * outermost callsite must make the final decision whether console",
            "\t * ownership is needed for it to proceed. If yes, it must reacquire",
            "\t * ownership (possibly hostile) before carefully proceeding.",
            "\t *",
            "\t * The calling context no longer owns the console so go back all the",
            "\t * way instead of trying to implement reacquire heuristics in tons of",
            "\t * places.",
            "\t */",
            "\treturn false;",
            "}",
            "bool nbcon_can_proceed(struct nbcon_write_context *wctxt)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(wctxt, ctxt);",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "",
            "\tnbcon_state_read(con, &cur);",
            "",
            "\treturn nbcon_context_can_proceed(ctxt, &cur);",
            "}",
            "static bool __nbcon_context_update_unsafe(struct nbcon_context *ctxt, bool unsafe)",
            "{",
            "\tstruct console *con = ctxt->console;",
            "\tstruct nbcon_state cur;",
            "\tstruct nbcon_state new;",
            "",
            "\tnbcon_state_read(con, &cur);",
            "",
            "\tdo {",
            "\t\t/*",
            "\t\t * The unsafe bit must not be cleared if an",
            "\t\t * unsafe hostile takeover has occurred.",
            "\t\t */",
            "\t\tif (!unsafe && cur.unsafe_takeover)",
            "\t\t\tgoto out;",
            "",
            "\t\tif (!nbcon_context_can_proceed(ctxt, &cur))",
            "\t\t\treturn false;",
            "",
            "\t\tnew.atom = cur.atom;",
            "\t\tnew.unsafe = unsafe;",
            "\t} while (!nbcon_state_try_cmpxchg(con, &cur, &new));",
            "",
            "\tcur.atom = new.atom;",
            "out:",
            "\treturn nbcon_context_can_proceed(ctxt, &cur);",
            "}"
          ],
          "function_name": "nbcon_context_release, nbcon_context_can_proceed, nbcon_can_proceed, __nbcon_context_update_unsafe",
          "description": "实现控制台释放与状态检查逻辑，包含安全状态维护、所有权验证和异常处理，通过循环CAS更新状态并在不安全状态下阻止进一步操作。",
          "similarity": 0.5394388437271118
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/printk/nbcon.c",
          "start_line": 1619,
          "end_line": 1720,
          "content": [
            "void nbcon_atomic_flush_unsafe(void)",
            "{",
            "\t__nbcon_atomic_flush_pending(prb_next_reserve_seq(prb), true);",
            "}",
            "void nbcon_cpu_emergency_enter(void)",
            "{",
            "\tunsigned int *cpu_emergency_nesting;",
            "",
            "\tpreempt_disable();",
            "",
            "\tcpu_emergency_nesting = nbcon_get_cpu_emergency_nesting();",
            "\t(*cpu_emergency_nesting)++;",
            "}",
            "void nbcon_cpu_emergency_exit(void)",
            "{",
            "\tunsigned int *cpu_emergency_nesting;",
            "",
            "\tcpu_emergency_nesting = nbcon_get_cpu_emergency_nesting();",
            "",
            "\tif (!WARN_ON_ONCE(*cpu_emergency_nesting == 0))",
            "\t\t(*cpu_emergency_nesting)--;",
            "",
            "\tpreempt_enable();",
            "}",
            "bool nbcon_alloc(struct console *con)",
            "{",
            "\tstruct nbcon_state state = { };",
            "",
            "\t/* The write_thread() callback is mandatory. */",
            "\tif (WARN_ON(!con->write_thread))",
            "\t\treturn false;",
            "",
            "\trcuwait_init(&con->rcuwait);",
            "\tinit_irq_work(&con->irq_work, nbcon_irq_work);",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_prev_seq), -1UL);",
            "\tnbcon_state_set(con, &state);",
            "",
            "\t/*",
            "\t * Initialize @nbcon_seq to the highest possible sequence number so",
            "\t * that practically speaking it will have nothing to print until a",
            "\t * desired initial sequence number has been set via nbcon_seq_force().",
            "\t */",
            "\tatomic_long_set(&ACCESS_PRIVATE(con, nbcon_seq), ULSEQ_MAX(prb));",
            "",
            "\tif (con->flags & CON_BOOT) {",
            "\t\t/*",
            "\t\t * Boot console printing is synchronized with legacy console",
            "\t\t * printing, so boot consoles can share the same global printk",
            "\t\t * buffers.",
            "\t\t */",
            "\t\tcon->pbufs = &printk_shared_pbufs;",
            "\t} else {",
            "\t\tcon->pbufs = kmalloc(sizeof(*con->pbufs), GFP_KERNEL);",
            "\t\tif (!con->pbufs) {",
            "\t\t\tcon_printk(KERN_ERR, con, \"failed to allocate printing buffer\\n\");",
            "\t\t\treturn false;",
            "\t\t}",
            "",
            "\t\tif (printk_kthreads_running) {",
            "\t\t\tif (!nbcon_kthread_create(con)) {",
            "\t\t\t\tkfree(con->pbufs);",
            "\t\t\t\tcon->pbufs = NULL;",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "void nbcon_free(struct console *con)",
            "{",
            "\tstruct nbcon_state state = { };",
            "",
            "\tif (printk_kthreads_running)",
            "\t\tnbcon_kthread_stop(con);",
            "",
            "\tnbcon_state_set(con, &state);",
            "",
            "\t/* Boot consoles share global printk buffers. */",
            "\tif (!(con->flags & CON_BOOT))",
            "\t\tkfree(con->pbufs);",
            "",
            "\tcon->pbufs = NULL;",
            "}",
            "bool nbcon_device_try_acquire(struct console *con)",
            "{",
            "\tstruct nbcon_context *ctxt = &ACCESS_PRIVATE(con, nbcon_device_ctxt);",
            "",
            "\tcant_migrate();",
            "",
            "\tmemset(ctxt, 0, sizeof(*ctxt));",
            "\tctxt->console\t= con;",
            "\tctxt->prio\t= NBCON_PRIO_NORMAL;",
            "",
            "\tif (!nbcon_context_try_acquire(ctxt))",
            "\t\treturn false;",
            "",
            "\tif (!nbcon_context_enter_unsafe(ctxt))",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "nbcon_atomic_flush_unsafe, nbcon_cpu_emergency_enter, nbcon_cpu_emergency_exit, nbcon_alloc, nbcon_free, nbcon_device_try_acquire",
          "description": "包含CPU紧急模式的嵌套计数器增减接口，控制台资源分配释放逻辑(nbcon_alloc/free)，以及设备抢占尝试函数nbcon_device_try_acquire，用于协调控制台设备的并发访问。",
          "similarity": 0.5290905237197876
        }
      ]
    },
    {
      "source_file": "kernel/irq_work.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:11:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq_work.c`\n\n---\n\n# `irq_work.c` 技术文档\n\n## 1. 文件概述\n\n`irq_work.c` 实现了一个轻量级的中断上下文工作队列机制，允许在硬中断（hardirq）或 NMI（不可屏蔽中断）上下文中安全地调度回调函数，并在稍后的硬中断上下文或专用内核线程中执行。该机制的核心目标是提供一种 **NMI 安全** 的方式来延迟执行某些不能在 NMI 或硬中断中直接完成的操作。\n\n该框架特别适用于需要从 NMI 或硬中断中触发后续处理（如 perf 事件、ftrace、RCU 等子系统）但又不能阻塞或执行复杂逻辑的场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irq_work`：表示一个中断工作项，包含回调函数 `func` 和状态标志（如 `IRQ_WORK_PENDING`、`IRQ_WORK_CLAIMED`、`IRQ_WORK_BUSY`、`IRQ_WORK_LAZY`、`IRQ_WORK_HARD_IRQ`）。\n- 每 CPU 变量：\n  - `raised_list`：存放需在硬中断上下文中立即处理的工作项。\n  - `lazy_list`：存放“惰性”工作项，在非硬中断上下文（如 tick 或专用线程）中处理。\n  - `irq_workd`：指向每 CPU 的 `irq_work` 内核线程（仅在 `CONFIG_PREEMPT_RT` 下使用）。\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `irq_work_queue(struct irq_work *work)` | 在当前 CPU 上排队一个 `irq_work`，若未被声明则声明并入队。 |\n| `irq_work_queue_on(struct irq_work *work, int cpu)` | 将 `irq_work` 排队到指定 CPU（支持跨 CPU 调度）。 |\n| `irq_work_run(void)` | 在当前 CPU 上执行所有 `raised_list` 和（非 RT 下的）`lazy_list` 中的工作项。 |\n| `irq_work_tick(void)` | 由时钟 tick 调用，处理未被硬中断处理的 `raised_list` 和 `lazy_list`。 |\n| `irq_work_sync(struct irq_work *work)` | 同步等待指定 `irq_work` 执行完毕。 |\n| `irq_work_single(void *arg)` | 执行单个工作项的回调函数，并清理状态。 |\n| `arch_irq_work_raise(void)` | 架构相关函数，用于触发 IPI 或中断以唤醒处理逻辑（弱符号，默认为空）。 |\n\n## 3. 关键实现\n\n### 状态管理与原子操作\n\n- 每个 `irq_work` 通过 `atomic_t node.a_flags` 管理状态：\n  - `IRQ_WORK_PENDING`：表示工作项已入队但尚未执行。\n  - `IRQ_WORK_CLAIMED`：表示已被声明，防止重复入队。\n  - `IRQ_WORK_BUSY`：表示正在执行中。\n- `irq_work_claim()` 使用 `atomic_fetch_or()` 原子地设置 `CLAIMED` 和 `PENDING` 标志，并检查是否已存在，避免重复入队。\n\n### 双队列设计\n\n- **`raised_list`**：用于需要尽快在硬中断上下文执行的工作（如标记为 `IRQ_WORK_HARD_IRQ` 的项）。\n- **`lazy_list`**：\n  - 在非 RT 内核中，由 `irq_work_tick()` 或 `irq_work_run()` 在软中断或进程上下文中处理。\n  - 在 `CONFIG_PREEMPT_RT` 下，由每 CPU 的 `irq_work/%u` 内核线程处理（以避免在硬中断中执行非硬实时代码）。\n\n### NMI 安全性\n\n- 入队操作（如 `irq_work_queue`）仅使用原子操作和每 CPU 链表（`llist`），不涉及锁或内存分配，因此可在 NMI 上下文中安全调用。\n- 跨 CPU 入队时（`irq_work_queue_on`）会检查 `in_nmi()`，防止在 NMI 中调用非 NMI 安全的 IPI 发送函数。\n\n### PREEMPT_RT 支持\n\n- 在 RT 内核中，非 `IRQ_WORK_HARD_IRQ` 的工作项被放入 `lazy_list`，并通过专用内核线程执行，以避免在硬中断中运行可能阻塞或延迟高的代码。\n- 使用 `rcuwait` 机制实现 `irq_work_sync()` 的睡眠等待。\n\n### IPI 触发机制\n\n- 若架构支持（通过 `arch_irq_work_has_interrupt()`），调用 `arch_irq_work_raise()` 触发本地中断处理。\n- 否则依赖时钟 tick（`irq_work_tick`）或显式调用 `irq_work_run` 来处理队列。\n\n## 4. 依赖关系\n\n- **架构依赖**：\n  - `arch_irq_work_raise()` 和 `arch_irq_work_has_interrupt()` 需由具体架构实现（如 x86 提供）。\n- **内核子系统**：\n  - `llist`（无锁链表）：用于高效、无锁的每 CPU 队列管理。\n  - `smpboot`：用于注册每 CPU 内核线程（RT 模式）。\n  - `rcu`：`rcuwait` 用于同步等待（RT 模式）。\n  - `tick`：`tick_nohz_tick_stopped()` 用于判断是否需要立即触发处理。\n  - `trace_events`：IPI 跟踪点 `trace_ipi_send_cpu`。\n- **配置选项**：\n  - `CONFIG_SMP`：启用跨 CPU 调度和 IPI 支持。\n  - `CONFIG_PREEMPT_RT`：启用 RT 模式下的线程化处理。\n\n## 5. 使用场景\n\n- **性能监控（perf）**：从 NMI 中记录采样后，通过 `irq_work` 安全地将数据传递到常规上下文处理。\n- **ftrace / tracing**：在中断上下文中触发延迟的跟踪事件处理。\n- **RCU**：某些 RCU 实现使用 `irq_work` 来触发宽限期处理。\n- **热插拔 CPU**：在 CPU 离线前通过 `flush_smp_call_function_queue()` 调用 `irq_work_run()` 确保工作项被清空。\n- **中断负载均衡或延迟处理**：将非关键中断处理逻辑延迟到更安全的上下文执行。\n\n该机制为内核提供了一种高效、安全且可扩展的中断后处理框架，尤其适用于实时性和可靠性要求高的子系统。",
      "similarity": 0.548973798751831,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq_work.c",
          "start_line": 31,
          "end_line": 157,
          "content": [
            "static void wake_irq_workd(void)",
            "{",
            "\tstruct task_struct *tsk = __this_cpu_read(irq_workd);",
            "",
            "\tif (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)",
            "\t\twake_up_process(tsk);",
            "}",
            "static void irq_work_wake(struct irq_work *entry)",
            "{",
            "\twake_irq_workd();",
            "}",
            "static int irq_workd_should_run(unsigned int cpu)",
            "{",
            "\treturn !llist_empty(this_cpu_ptr(&lazy_list));",
            "}",
            "static bool irq_work_claim(struct irq_work *work)",
            "{",
            "\tint oflags;",
            "",
            "\toflags = atomic_fetch_or(IRQ_WORK_CLAIMED | CSD_TYPE_IRQ_WORK, &work->node.a_flags);",
            "\t/*",
            "\t * If the work is already pending, no need to raise the IPI.",
            "\t * The pairing smp_mb() in irq_work_single() makes sure",
            "\t * everything we did before is visible.",
            "\t */",
            "\tif (oflags & IRQ_WORK_PENDING)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "void __weak arch_irq_work_raise(void)",
            "{",
            "\t/*",
            "\t * Lame architectures will get the timer tick callback",
            "\t */",
            "}",
            "static __always_inline void irq_work_raise(struct irq_work *work)",
            "{",
            "\tif (trace_ipi_send_cpu_enabled() && arch_irq_work_has_interrupt())",
            "\t\ttrace_ipi_send_cpu(smp_processor_id(), _RET_IP_, work->func);",
            "",
            "\tarch_irq_work_raise();",
            "}",
            "static void __irq_work_queue_local(struct irq_work *work)",
            "{",
            "\tstruct llist_head *list;",
            "\tbool rt_lazy_work = false;",
            "\tbool lazy_work = false;",
            "\tint work_flags;",
            "",
            "\twork_flags = atomic_read(&work->node.a_flags);",
            "\tif (work_flags & IRQ_WORK_LAZY)",
            "\t\tlazy_work = true;",
            "\telse if (IS_ENABLED(CONFIG_PREEMPT_RT) &&",
            "\t\t !(work_flags & IRQ_WORK_HARD_IRQ))",
            "\t\trt_lazy_work = true;",
            "",
            "\tif (lazy_work || rt_lazy_work)",
            "\t\tlist = this_cpu_ptr(&lazy_list);",
            "\telse",
            "\t\tlist = this_cpu_ptr(&raised_list);",
            "",
            "\tif (!llist_add(&work->node.llist, list))",
            "\t\treturn;",
            "",
            "\t/* If the work is \"lazy\", handle it from next tick if any */",
            "\tif (!lazy_work || tick_nohz_tick_stopped())",
            "\t\tirq_work_raise(work);",
            "}",
            "bool irq_work_queue(struct irq_work *work)",
            "{",
            "\t/* Only queue if not already pending */",
            "\tif (!irq_work_claim(work))",
            "\t\treturn false;",
            "",
            "\t/* Queue the entry and raise the IPI if needed. */",
            "\tpreempt_disable();",
            "\t__irq_work_queue_local(work);",
            "\tpreempt_enable();",
            "",
            "\treturn true;",
            "}",
            "bool irq_work_queue_on(struct irq_work *work, int cpu)",
            "{",
            "#ifndef CONFIG_SMP",
            "\treturn irq_work_queue(work);",
            "",
            "#else /* CONFIG_SMP: */",
            "\t/* All work should have been flushed before going offline */",
            "\tWARN_ON_ONCE(cpu_is_offline(cpu));",
            "",
            "\t/* Only queue if not already pending */",
            "\tif (!irq_work_claim(work))",
            "\t\treturn false;",
            "",
            "\tkasan_record_aux_stack_noalloc(work);",
            "",
            "\tpreempt_disable();",
            "\tif (cpu != smp_processor_id()) {",
            "\t\t/* Arch remote IPI send/receive backend aren't NMI safe */",
            "\t\tWARN_ON_ONCE(in_nmi());",
            "",
            "\t\t/*",
            "\t\t * On PREEMPT_RT the items which are not marked as",
            "\t\t * IRQ_WORK_HARD_IRQ are added to the lazy list and a HARD work",
            "\t\t * item is used on the remote CPU to wake the thread.",
            "\t\t */",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT) &&",
            "\t\t    !(atomic_read(&work->node.a_flags) & IRQ_WORK_HARD_IRQ)) {",
            "",
            "\t\t\tif (!llist_add(&work->node.llist, &per_cpu(lazy_list, cpu)))",
            "\t\t\t\tgoto out;",
            "",
            "\t\t\twork = &per_cpu(irq_work_wakeup, cpu);",
            "\t\t\tif (!irq_work_claim(work))",
            "\t\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\t__smp_call_single_queue(cpu, &work->node.llist);",
            "\t} else {",
            "\t\t__irq_work_queue_local(work);",
            "\t}",
            "out:",
            "\tpreempt_enable();",
            "",
            "\treturn true;",
            "#endif /* CONFIG_SMP */",
            "}"
          ],
          "function_name": "wake_irq_workd, irq_work_wake, irq_workd_should_run, irq_work_claim, arch_irq_work_raise, irq_work_raise, __irq_work_queue_local, irq_work_queue, irq_work_queue_on",
          "description": "实现了中断工作项的排队逻辑，区分硬中断与延迟工作项，通过IPI或线程唤醒机制确保跨CPU执行，支持PREEMPT_RT配置下的延迟处理",
          "similarity": 0.5334191918373108
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq_work.c",
          "start_line": 303,
          "end_line": 316,
          "content": [
            "static void run_irq_workd(unsigned int cpu)",
            "{",
            "\tirq_work_run_list(this_cpu_ptr(&lazy_list));",
            "}",
            "static void irq_workd_setup(unsigned int cpu)",
            "{",
            "\tsched_set_fifo_low(current);",
            "}",
            "static __init int irq_work_init_threads(void)",
            "{",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT))",
            "\t\tBUG_ON(smpboot_register_percpu_thread(&irqwork_threads));",
            "\treturn 0;",
            "}"
          ],
          "function_name": "run_irq_workd, irq_workd_setup, irq_work_init_threads",
          "description": "初始化PREEMPT_RT环境下的per-CPU工作线程，注册并启动处理延迟工作项的专用线程，通过smpboot接口创建线程实体",
          "similarity": 0.5058119297027588
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq_work.c",
          "start_line": 184,
          "end_line": 286,
          "content": [
            "bool irq_work_needs_cpu(void)",
            "{",
            "\tstruct llist_head *raised, *lazy;",
            "",
            "\traised = this_cpu_ptr(&raised_list);",
            "\tlazy = this_cpu_ptr(&lazy_list);",
            "",
            "\tif (llist_empty(raised) || arch_irq_work_has_interrupt())",
            "\t\tif (llist_empty(lazy))",
            "\t\t\treturn false;",
            "",
            "\t/* All work should have been flushed before going offline */",
            "\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));",
            "",
            "\treturn true;",
            "}",
            "void irq_work_single(void *arg)",
            "{",
            "\tstruct irq_work *work = arg;",
            "\tint flags;",
            "",
            "\t/*",
            "\t * Clear the PENDING bit, after this point the @work can be re-used.",
            "\t * The PENDING bit acts as a lock, and we own it, so we can clear it",
            "\t * without atomic ops.",
            "\t */",
            "\tflags = atomic_read(&work->node.a_flags);",
            "\tflags &= ~IRQ_WORK_PENDING;",
            "\tatomic_set(&work->node.a_flags, flags);",
            "",
            "\t/*",
            "\t * See irq_work_claim().",
            "\t */",
            "\tsmp_mb();",
            "",
            "\tlockdep_irq_work_enter(flags);",
            "\twork->func(work);",
            "\tlockdep_irq_work_exit(flags);",
            "",
            "\t/*",
            "\t * Clear the BUSY bit, if set, and return to the free state if no-one",
            "\t * else claimed it meanwhile.",
            "\t */",
            "\t(void)atomic_cmpxchg(&work->node.a_flags, flags, flags & ~IRQ_WORK_BUSY);",
            "",
            "\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||",
            "\t    !arch_irq_work_has_interrupt())",
            "\t\trcuwait_wake_up(&work->irqwait);",
            "}",
            "static void irq_work_run_list(struct llist_head *list)",
            "{",
            "\tstruct irq_work *work, *tmp;",
            "\tstruct llist_node *llnode;",
            "",
            "\t/*",
            "\t * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed",
            "\t * in a per-CPU thread in preemptible context. Only the items which are",
            "\t * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.",
            "\t */",
            "\tBUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));",
            "",
            "\tif (llist_empty(list))",
            "\t\treturn;",
            "",
            "\tllnode = llist_del_all(list);",
            "\tllist_for_each_entry_safe(work, tmp, llnode, node.llist)",
            "\t\tirq_work_single(work);",
            "}",
            "void irq_work_run(void)",
            "{",
            "\tirq_work_run_list(this_cpu_ptr(&raised_list));",
            "\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))",
            "\t\tirq_work_run_list(this_cpu_ptr(&lazy_list));",
            "\telse",
            "\t\twake_irq_workd();",
            "}",
            "void irq_work_tick(void)",
            "{",
            "\tstruct llist_head *raised = this_cpu_ptr(&raised_list);",
            "",
            "\tif (!llist_empty(raised) && !arch_irq_work_has_interrupt())",
            "\t\tirq_work_run_list(raised);",
            "",
            "\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))",
            "\t\tirq_work_run_list(this_cpu_ptr(&lazy_list));",
            "\telse",
            "\t\twake_irq_workd();",
            "}",
            "void irq_work_sync(struct irq_work *work)",
            "{",
            "\tlockdep_assert_irqs_enabled();",
            "\tmight_sleep();",
            "",
            "\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||",
            "\t    !arch_irq_work_has_interrupt()) {",
            "\t\trcuwait_wait_event(&work->irqwait, !irq_work_is_busy(work),",
            "\t\t\t\t   TASK_UNINTERRUPTIBLE);",
            "\t\treturn;",
            "\t}",
            "",
            "\twhile (irq_work_is_busy(work))",
            "\t\tcpu_relax();",
            "}"
          ],
          "function_name": "irq_work_needs_cpu, irq_work_single, irq_work_run_list, irq_work_run, irq_work_tick, irq_work_sync",
          "description": "处理工作项的实际执行流程，包含单次执行逻辑、链表遍历运行及同步等待机制，区分硬中断上下文与RCU等待状态的处理",
          "similarity": 0.5010309219360352
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq_work.c",
          "start_line": 1,
          "end_line": 30,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (C) 2010 Red Hat, Inc., Peter Zijlstra",
            " *",
            " * Provides a framework for enqueueing and running callbacks from hardirq",
            " * context. The enqueueing is NMI-safe.",
            " */",
            "",
            "#include <linux/bug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/sched.h>",
            "#include <linux/tick.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/smp.h>",
            "#include <linux/smpboot.h>",
            "#include <asm/processor.h>",
            "#include <linux/kasan.h>",
            "",
            "#include <trace/events/ipi.h>",
            "",
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);",
            "static DEFINE_PER_CPU(struct task_struct *, irq_workd);",
            ""
          ],
          "function_name": null,
          "description": "定义了用于管理中断工作队列的per-CPU链表（raised_list/lazy_list）和irq_workd线程指针，提供NMI安全的enqueue框架",
          "similarity": 0.4674729108810425
        }
      ]
    }
  ]
}