{
  "query": "虚拟化技术与微内核隔离机制",
  "timestamp": "2025-12-26 01:52:39",
  "retrieved_files": [
    {
      "source_file": "mm/kasan/quarantine.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:17:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kasan\\quarantine.c`\n\n---\n\n# kasan/quarantine.c 技术文档\n\n## 1. 文件概述\n\n`kasan/quarantine.c` 实现了 KASAN（Kernel Address Sanitizer）的隔离区（Quarantine）机制。该机制用于延迟释放已释放但可能仍被非法访问的内存对象，从而提高检测 Use-After-Free（UAF）错误的能力。通过将释放的对象暂时放入隔离队列而非立即归还给内存分配器，KASAN 能在后续访问这些“已释放”内存时捕获违规行为。\n\n隔离区由每个 CPU 的本地队列和一个全局循环批次队列组成，并支持动态调整大小以适应系统内存压力，防止因隔离区过大导致 OOM（Out-Of-Memory）。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct qlist_head`**  \n  表示一个单向链表队列，包含头指针、尾指针、总字节数和离线标志。\n  \n- **`cpu_quarantine`**（per-CPU）  \n  每个 CPU 的本地隔离队列，用于暂存刚释放的对象。\n\n- **`global_quarantine[QUARANTINE_BATCHES]`**  \n  全局隔离批次数组，采用循环 FIFO 结构，存储从各 CPU 队列转移过来的批量对象。\n\n- **`shrink_qlist`**（per-CPU）  \n  用于内存回收路径的辅助队列，带自旋锁保护。\n\n- **`remove_cache_srcu`**  \n  SRCU（Sleepable RCU）同步机制，用于安全地移除特定 slab 缓存的所有隔离对象。\n\n### 主要函数\n\n- **`kasan_quarantine_put()`**  \n  将指定对象放入当前 CPU 的隔离队列；若队列超过阈值，则批量转移到全局隔离区。\n\n- **`kasan_quarantine_reduce()`**  \n  当全局隔离区总大小超过限制时，释放最早一批对象以回收内存。\n\n- **`qlist_free_all()`**  \n  遍历并实际释放队列中所有对象回 slab 分配器。\n\n- **`qlink_free()`**  \n  执行单个隔离对象的实际释放操作，包括清除 KASAN 元数据和 shadow 内存标记。\n\n- **`qlist_move_cache()`**（未完成）  \n  （代码截断）预期用于将特定缓存类型的所有对象从一个队列迁移到另一个队列，通常用于缓存销毁时清理隔离对象。\n\n## 3. 关键实现\n\n### 隔离队列结构\n- 使用轻量级单向链表 `qlist_head` 管理对象，每个节点为 `struct qlist_node`（嵌入在 `kasan_free_meta` 中）。\n- 每个 CPU 维护一个本地队列（`cpu_quarantine`），避免锁竞争，提升性能。\n- 全局隔离区由 `QUARANTINE_BATCHES` 个批次组成环形缓冲区，通过 `quarantine_head` 和 `quarantine_tail` 实现 FIFO。\n\n### 内存管理策略\n- 单个 CPU 队列最大为 `QUARANTINE_PERCPU_SIZE`（1MB）。\n- 全局隔离区最大容量为系统物理内存的 `1/QUARANTINE_FRACTION`（即 1/32），再减去所有 CPU 队列的上限总和。\n- 批次大小 `quarantine_batch_size` 动态计算，至少为 `QUARANTINE_PERCPU_SIZE`，确保高效批量处理。\n\n### 并发与同步\n- CPU 本地操作使用 `local_irq_save/restore` 禁用中断，保证原子性。\n- 全局队列操作受 `quarantine_lock`（raw spinlock）保护。\n- 使用 `SRCU`（`remove_cache_srcu`）协调 `kasan_quarantine_remove_cache()` 与隔离对象释放之间的同步，确保在缓存销毁时不会遗漏隔离中的对象。\n\n### 安全释放机制\n- 对象释放前会将对应的 KASAN shadow 字节设为 `KASAN_SLAB_FREE`，使后续访问触发 KASAN 报告。\n- 若启用了 `init_on_free` 且 free metadata 存储在对象内部，则在释放前显式清零元数据，避免残留敏感信息。\n\n## 4. 依赖关系\n\n- **KASAN 核心模块**：依赖 `kasan.h` 中定义的元数据结构（如 `kasan_free_meta`）、shadow 内存操作和 `kasan_get_free_meta()` 等接口。\n- **Slab 分配器**：通过 `___cache_free()` 将对象归还给底层 slab（SLAB/SLUB）；使用 `virt_to_slab()` 和 `slab_want_init_on_free()` 等 slab 内部接口。\n- **内存管理子系统**：调用 `totalram_pages()` 获取系统内存总量，用于动态调整隔离区大小。\n- **CPU 热插拔**：通过 `num_online_cpus()` 适配 CPU 数量变化。\n- **同步原语**：使用 `percpu`、`raw_spinlock`、`SRCU` 和 `local_irq_*` 实现并发控制。\n- **内存回收**：虽未直接注册 shrinker（注释提及 SLAB 不支持），但 `kasan_quarantine_reduce()` 可被外部调用以响应内存压力。\n\n## 5. 使用场景\n\n- **Use-After-Free 检测增强**：当内核启用 KASAN（特别是 `CONFIG_KASAN_GENERIC` 或 `CONFIG_KASAN_SW_TAGS`）时，`kfree()` 或 `kmem_cache_free()` 调用会先将对象放入隔离区而非立即释放，延长 UAF 检测窗口。\n- **内存压力下的自动回收**：当系统内存紧张或隔离区超过阈值时，调用 `kasan_quarantine_reduce()` 释放最早隔离的一批对象，防止内存耗尽。\n- **Slab 缓存销毁**：当某个 `kmem_cache` 被销毁时，需调用未在本文件中完整实现的 `kasan_quarantine_remove_cache()`（依赖 `qlist_move_cache`），将该缓存的所有隔离对象立即释放，避免悬空引用。\n- **调试与测试**：在内核开发和测试阶段，隔离机制显著提升内存错误的可复现性和诊断能力。",
      "similarity": 0.5495878458023071,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 238,
          "end_line": 375,
          "content": [
            "void kasan_quarantine_reduce(void)",
            "{",
            "\tsize_t total_size, new_quarantine_size, percpu_quarantines;",
            "\tunsigned long flags;",
            "\tint srcu_idx;",
            "\tstruct qlist_head to_free = QLIST_INIT;",
            "",
            "\tif (likely(READ_ONCE(quarantine_size) <=",
            "\t\t   READ_ONCE(quarantine_max_size)))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * srcu critical section ensures that kasan_quarantine_remove_cache()",
            "\t * will not miss objects belonging to the cache while they are in our",
            "\t * local to_free list. srcu is chosen because (1) it gives us private",
            "\t * grace period domain that does not interfere with anything else,",
            "\t * and (2) it allows synchronize_srcu() to return without waiting",
            "\t * if there are no pending read critical sections (which is the",
            "\t * expected case).",
            "\t */",
            "\tsrcu_idx = srcu_read_lock(&remove_cache_srcu);",
            "\traw_spin_lock_irqsave(&quarantine_lock, flags);",
            "",
            "\t/*",
            "\t * Update quarantine size in case of hotplug. Allocate a fraction of",
            "\t * the installed memory to quarantine minus per-cpu queue limits.",
            "\t */",
            "\ttotal_size = (totalram_pages() << PAGE_SHIFT) /",
            "\t\tQUARANTINE_FRACTION;",
            "\tpercpu_quarantines = QUARANTINE_PERCPU_SIZE * num_online_cpus();",
            "\tnew_quarantine_size = (total_size < percpu_quarantines) ?",
            "\t\t0 : total_size - percpu_quarantines;",
            "\tWRITE_ONCE(quarantine_max_size, new_quarantine_size);",
            "\t/* Aim at consuming at most 1/2 of slots in quarantine. */",
            "\tWRITE_ONCE(quarantine_batch_size, max((size_t)QUARANTINE_PERCPU_SIZE,",
            "\t\t2 * total_size / QUARANTINE_BATCHES));",
            "",
            "\tif (likely(quarantine_size > quarantine_max_size)) {",
            "\t\tqlist_move_all(&global_quarantine[quarantine_head], &to_free);",
            "\t\tWRITE_ONCE(quarantine_size, quarantine_size - to_free.bytes);",
            "\t\tquarantine_head++;",
            "\t\tif (quarantine_head == QUARANTINE_BATCHES)",
            "\t\t\tquarantine_head = 0;",
            "\t}",
            "",
            "\traw_spin_unlock_irqrestore(&quarantine_lock, flags);",
            "",
            "\tqlist_free_all(&to_free, NULL);",
            "\tsrcu_read_unlock(&remove_cache_srcu, srcu_idx);",
            "}",
            "static void qlist_move_cache(struct qlist_head *from,",
            "\t\t\t\t   struct qlist_head *to,",
            "\t\t\t\t   struct kmem_cache *cache)",
            "{",
            "\tstruct qlist_node *curr;",
            "",
            "\tif (unlikely(qlist_empty(from)))",
            "\t\treturn;",
            "",
            "\tcurr = from->head;",
            "\tqlist_init(from);",
            "\twhile (curr) {",
            "\t\tstruct qlist_node *next = curr->next;",
            "\t\tstruct kmem_cache *obj_cache = qlink_to_cache(curr);",
            "",
            "\t\tif (obj_cache == cache)",
            "\t\t\tqlist_put(to, curr, obj_cache->size);",
            "\t\telse",
            "\t\t\tqlist_put(from, curr, obj_cache->size);",
            "",
            "\t\tcurr = next;",
            "\t}",
            "}",
            "static void __per_cpu_remove_cache(struct qlist_head *q, void *arg)",
            "{",
            "\tstruct kmem_cache *cache = arg;",
            "\tunsigned long flags;",
            "\tstruct cpu_shrink_qlist *sq;",
            "",
            "\tsq = this_cpu_ptr(&shrink_qlist);",
            "\traw_spin_lock_irqsave(&sq->lock, flags);",
            "\tqlist_move_cache(q, &sq->qlist, cache);",
            "\traw_spin_unlock_irqrestore(&sq->lock, flags);",
            "}",
            "static void per_cpu_remove_cache(void *arg)",
            "{",
            "\tstruct qlist_head *q;",
            "",
            "\tq = this_cpu_ptr(&cpu_quarantine);",
            "\t/*",
            "\t * Ensure the ordering between the writing to q->offline and",
            "\t * per_cpu_remove_cache.  Prevent cpu_quarantine from being corrupted",
            "\t * by interrupt.",
            "\t */",
            "\tif (READ_ONCE(q->offline))",
            "\t\treturn;",
            "\t__per_cpu_remove_cache(q, arg);",
            "}",
            "void kasan_quarantine_remove_cache(struct kmem_cache *cache)",
            "{",
            "\tunsigned long flags, i;",
            "\tstruct qlist_head to_free = QLIST_INIT;",
            "\tint cpu;",
            "\tstruct cpu_shrink_qlist *sq;",
            "",
            "\t/*",
            "\t * Must be careful to not miss any objects that are being moved from",
            "\t * per-cpu list to the global quarantine in kasan_quarantine_put(),",
            "\t * nor objects being freed in kasan_quarantine_reduce(). on_each_cpu()",
            "\t * achieves the first goal, while synchronize_srcu() achieves the",
            "\t * second.",
            "\t */",
            "\ton_each_cpu(per_cpu_remove_cache, cache, 1);",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tsq = per_cpu_ptr(&shrink_qlist, cpu);",
            "\t\traw_spin_lock_irqsave(&sq->lock, flags);",
            "\t\tqlist_move_cache(&sq->qlist, &to_free, cache);",
            "\t\traw_spin_unlock_irqrestore(&sq->lock, flags);",
            "\t}",
            "\tqlist_free_all(&to_free, cache);",
            "",
            "\traw_spin_lock_irqsave(&quarantine_lock, flags);",
            "\tfor (i = 0; i < QUARANTINE_BATCHES; i++) {",
            "\t\tif (qlist_empty(&global_quarantine[i]))",
            "\t\t\tcontinue;",
            "\t\tqlist_move_cache(&global_quarantine[i], &to_free, cache);",
            "\t\t/* Scanning whole quarantine can take a while. */",
            "\t\traw_spin_unlock_irqrestore(&quarantine_lock, flags);",
            "\t\tcond_resched();",
            "\t\traw_spin_lock_irqsave(&quarantine_lock, flags);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&quarantine_lock, flags);",
            "",
            "\tqlist_free_all(&to_free, cache);",
            "",
            "\tsynchronize_srcu(&remove_cache_srcu);",
            "}"
          ],
          "function_name": "kasan_quarantine_reduce, qlist_move_cache, __per_cpu_remove_cache, per_cpu_remove_cache, kasan_quarantine_remove_cache",
          "description": "提供隔离区缩减机制(kasan_quarantine_reduce)，通过srcu同步和跨CPU遍历清除指定缓存对象，利用qlist_move_cache实现基于缓存类型的对象转移与释放。",
          "similarity": 0.5836911201477051
        },
        {
          "chunk_id": 1,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 42,
          "end_line": 172,
          "content": [
            "static bool qlist_empty(struct qlist_head *q)",
            "{",
            "\treturn !q->head;",
            "}",
            "static void qlist_init(struct qlist_head *q)",
            "{",
            "\tq->head = q->tail = NULL;",
            "\tq->bytes = 0;",
            "}",
            "static void qlist_put(struct qlist_head *q, struct qlist_node *qlink,",
            "\t\tsize_t size)",
            "{",
            "\tif (unlikely(qlist_empty(q)))",
            "\t\tq->head = qlink;",
            "\telse",
            "\t\tq->tail->next = qlink;",
            "\tq->tail = qlink;",
            "\tqlink->next = NULL;",
            "\tq->bytes += size;",
            "}",
            "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)",
            "{",
            "\tif (unlikely(qlist_empty(from)))",
            "\t\treturn;",
            "",
            "\tif (qlist_empty(to)) {",
            "\t\t*to = *from;",
            "\t\tqlist_init(from);",
            "\t\treturn;",
            "\t}",
            "",
            "\tto->tail->next = from->head;",
            "\tto->tail = from->tail;",
            "\tto->bytes += from->bytes;",
            "",
            "\tqlist_init(from);",
            "}",
            "static void qlink_free(struct qlist_node *qlink, struct kmem_cache *cache)",
            "{",
            "\tvoid *object = qlink_to_object(qlink, cache);",
            "\tstruct kasan_free_meta *meta = kasan_get_free_meta(cache, object);",
            "",
            "\t/*",
            "\t * If init_on_free is enabled and KASAN's free metadata is stored in",
            "\t * the object, zero the metadata. Otherwise, the object's memory will",
            "\t * not be properly zeroed, as KASAN saves the metadata after the slab",
            "\t * allocator zeroes the object.",
            "\t */",
            "\tif (slab_want_init_on_free(cache) &&",
            "\t    cache->kasan_info.free_meta_offset == 0)",
            "\t\tmemzero_explicit(meta, sizeof(*meta));",
            "",
            "\t/*",
            "\t * As the object now gets freed from the quarantine, assume that its",
            "\t * free track is no longer valid.",
            "\t */",
            "\t*(u8 *)kasan_mem_to_shadow(object) = KASAN_SLAB_FREE;",
            "",
            "\t___cache_free(cache, object, _THIS_IP_);",
            "}",
            "static void qlist_free_all(struct qlist_head *q, struct kmem_cache *cache)",
            "{",
            "\tstruct qlist_node *qlink;",
            "",
            "\tif (unlikely(qlist_empty(q)))",
            "\t\treturn;",
            "",
            "\tqlink = q->head;",
            "\twhile (qlink) {",
            "\t\tstruct kmem_cache *obj_cache =",
            "\t\t\tcache ? cache :\tqlink_to_cache(qlink);",
            "\t\tstruct qlist_node *next = qlink->next;",
            "",
            "\t\tqlink_free(qlink, obj_cache);",
            "\t\tqlink = next;",
            "\t}",
            "\tqlist_init(q);",
            "}",
            "bool kasan_quarantine_put(struct kmem_cache *cache, void *object)",
            "{",
            "\tunsigned long flags;",
            "\tstruct qlist_head *q;",
            "\tstruct qlist_head temp = QLIST_INIT;",
            "\tstruct kasan_free_meta *meta = kasan_get_free_meta(cache, object);",
            "",
            "\t/*",
            "\t * If there's no metadata for this object, don't put it into",
            "\t * quarantine.",
            "\t */",
            "\tif (!meta)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Note: irq must be disabled until after we move the batch to the",
            "\t * global quarantine. Otherwise kasan_quarantine_remove_cache() can",
            "\t * miss some objects belonging to the cache if they are in our local",
            "\t * temp list. kasan_quarantine_remove_cache() executes on_each_cpu()",
            "\t * at the beginning which ensures that it either sees the objects in",
            "\t * per-cpu lists or in the global quarantine.",
            "\t */",
            "\tlocal_irq_save(flags);",
            "",
            "\tq = this_cpu_ptr(&cpu_quarantine);",
            "\tif (q->offline) {",
            "\t\tlocal_irq_restore(flags);",
            "\t\treturn false;",
            "\t}",
            "\tqlist_put(q, &meta->quarantine_link, cache->size);",
            "\tif (unlikely(q->bytes > QUARANTINE_PERCPU_SIZE)) {",
            "\t\tqlist_move_all(q, &temp);",
            "",
            "\t\traw_spin_lock(&quarantine_lock);",
            "\t\tWRITE_ONCE(quarantine_size, quarantine_size + temp.bytes);",
            "\t\tqlist_move_all(&temp, &global_quarantine[quarantine_tail]);",
            "\t\tif (global_quarantine[quarantine_tail].bytes >=",
            "\t\t\t\tREAD_ONCE(quarantine_batch_size)) {",
            "\t\t\tint new_tail;",
            "",
            "\t\t\tnew_tail = quarantine_tail + 1;",
            "\t\t\tif (new_tail == QUARANTINE_BATCHES)",
            "\t\t\t\tnew_tail = 0;",
            "\t\t\tif (new_tail != quarantine_head)",
            "\t\t\t\tquarantine_tail = new_tail;",
            "\t\t}",
            "\t\traw_spin_unlock(&quarantine_lock);",
            "\t}",
            "",
            "\tlocal_irq_restore(flags);",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "qlist_empty, qlist_init, qlist_put, qlist_move_all, qlink_free, qlist_free_all, kasan_quarantine_put",
          "description": "实现了隔离区队列的基本操作（空判断、初始化、插入、转移和释放），kasan_quarantine_put将对象加入当前CPU隔离队列并触发全局隔离区迁移，通过中断屏蔽保证并发安全性。",
          "similarity": 0.5510344505310059
        },
        {
          "chunk_id": 3,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 382,
          "end_line": 410,
          "content": [
            "static int kasan_cpu_online(unsigned int cpu)",
            "{",
            "\tthis_cpu_ptr(&cpu_quarantine)->offline = false;",
            "\treturn 0;",
            "}",
            "static int kasan_cpu_offline(unsigned int cpu)",
            "{",
            "\tstruct qlist_head *q;",
            "",
            "\tq = this_cpu_ptr(&cpu_quarantine);",
            "\t/* Ensure the ordering between the writing to q->offline and",
            "\t * qlist_free_all. Otherwise, cpu_quarantine may be corrupted",
            "\t * by interrupt.",
            "\t */",
            "\tWRITE_ONCE(q->offline, true);",
            "\tbarrier();",
            "\tqlist_free_all(q, NULL);",
            "\treturn 0;",
            "}",
            "static int __init kasan_cpu_quarantine_init(void)",
            "{",
            "\tint ret = 0;",
            "",
            "\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/kasan:online\",",
            "\t\t\t\tkasan_cpu_online, kasan_cpu_offline);",
            "\tif (ret < 0)",
            "\t\tpr_err(\"kasan cpu quarantine register failed [%d]\\n\", ret);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "kasan_cpu_online, kasan_cpu_offline, kasan_cpu_quarantine_init",
          "description": "实现CPU热插拔时隔离区状态管理，kasan_cpu_online/kasan_cpu_offline控制隔离区可用性，kasan_cpu_quarantine_init注册CPU状态回调接口。",
          "similarity": 0.5367972254753113
        },
        {
          "chunk_id": 0,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * KASAN quarantine.",
            " *",
            " * Author: Alexander Potapenko <glider@google.com>",
            " * Copyright (C) 2016 Google, Inc.",
            " *",
            " * Based on code by Dmitry Chernenkov.",
            " */",
            "",
            "#include <linux/gfp.h>",
            "#include <linux/hash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/percpu.h>",
            "#include <linux/printk.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/cpuhotplug.h>",
            "",
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "",
            "/* Data structure and operations for quarantine queues. */",
            "",
            "/*",
            " * Each queue is a single-linked list, which also stores the total size of",
            " * objects inside of it.",
            " */",
            "struct qlist_head {",
            "\tstruct qlist_node *head;",
            "\tstruct qlist_node *tail;",
            "\tsize_t bytes;",
            "\tbool offline;",
            "};",
            "",
            "#define QLIST_INIT { NULL, NULL, 0 }",
            ""
          ],
          "function_name": null,
          "description": "定义了KASAN隔离区队列的数据结构qlist_head，包含头尾指针、总字节数和离线标志位，用于管理隔离对象的链表队列。",
          "similarity": 0.4626077115535736
        }
      ]
    },
    {
      "source_file": "kernel/locking/qspinlock_paravirt.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:46:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\qspinlock_paravirt.h`\n\n---\n\n# `locking/qspinlock_paravirt.h` 技术文档\n\n## 1. 文件概述\n\n`qspinlock_paravirt.h` 是 Linux 内核中用于实现 **半虚拟化（paravirtualized, PV）队列自旋锁（qspinlock）** 的头文件。其核心目标是在虚拟化环境中优化自旋锁行为：当虚拟 CPU（vCPU）无法立即获取锁时，不进行忙等待（busy-waiting），而是通过 **挂起（halt）** 当前 vCPU 并等待被唤醒，从而显著降低在锁竞争激烈或宿主机过载（overcommitted）场景下的 CPU 资源浪费和延迟。\n\n该文件依赖架构层提供的两个关键半虚拟化超调用（hypercall）：\n- `pv_wait(u8 *ptr, u8 val)`：当 `*ptr == val` 时挂起当前 vCPU。\n- `pv_kick(cpu)`：唤醒指定的已挂起 vCPU。\n\n此文件 **不能直接包含**，必须通过定义 `_GEN_PV_LOCK_SLOWPATH` 宏后由其他文件（如 `qspinlock.c`）条件包含，以替换原生的慢路径锁实现。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`enum vcpu_state`**  \n  表示 vCPU 在锁等待队列中的状态：\n  - `vcpu_running`：正在运行（默认状态）。\n  - `vcpu_halted`：已挂起，等待被唤醒（仅用于 `pv_wait_node`）。\n  - `vcpu_hashed`：已挂起且其节点信息已加入哈希表（用于快速查找）。\n\n- **`struct pv_node`**  \n  扩展的 MCS 锁节点，包含：\n  - `mcs`：标准 MCS 自旋锁节点。\n  - `cpu`：关联的 CPU ID。\n  - `state`：当前 vCPU 状态（`vcpu_state` 枚举值）。\n\n- **`struct pv_hash_entry`**  \n  哈希表条目，用于快速映射锁地址到对应的 `pv_node`：\n  - `lock`：指向 `qspinlock` 的指针。\n  - `node`：指向 `pv_node` 的指针。\n\n### 主要函数与宏\n\n- **`pv_hybrid_queued_unfair_trylock()`**  \n  实现混合模式的锁尝试获取逻辑，结合了公平队列锁与非公平锁的优点。\n\n- **`set_pending()` / `trylock_clear_pending()`**  \n  操作锁的 `pending` 位，用于协调队列头 vCPU 与新到来的竞争者。\n\n- **`__pv_init_lock_hash()`**  \n  初始化 PV 锁哈希表，分配足够大的内存空间以支持所有可能的 CPU。\n\n- **`pv_hash()` / `pv_unhash()`**  \n  在哈希表中插入/删除锁与节点的映射关系，用于快速唤醒等待者。\n\n- **`pv_wait_early()`**  \n  （代码不完整）用于判断是否应提前检查前驱节点状态并挂起当前 vCPU。\n\n### 关键宏定义\n\n- **`PV_PREV_CHECK_MASK`**  \n  控制检查前驱节点状态的频率（每 256 次循环检查一次），避免缓存行抖动。\n\n- **`_Q_SLOW_VAL`**  \n  表示锁处于慢路径状态的值（`locked=1, pending=1`）。\n\n- **`queued_spin_trylock`**  \n  重定义为 `pv_hybrid_queued_unfair_trylock`，启用混合锁机制。\n\n## 3. 关键实现\n\n### 混合 PV 队列/非公平锁机制\n\n该实现采用 **混合策略**：\n- 当锁的 MCS 等待队列为空或 `pending` 位未设置时，新竞争者尝试 **非公平方式抢锁**（直接 CAS `locked` 位），提升低竞争场景性能。\n- 一旦有 vCPU 进入等待队列并成为队列头，它会设置 `pending` 位，**禁止后续抢锁**，强制新竞争者进入公平队列，避免锁饥饿。\n- 队列头 vCPU 在自旋等待锁释放时保持 `pending=1`，确保公平性。\n\n### 自适应挂起（Adaptive Spinning）\n\n- 等待队列中的 vCPU 会周期性（由 `PV_PREV_CHECK_MASK` 控制）检查 **前驱节点是否正在运行**。\n- 若前驱 **未运行**（如已挂起），当前 vCPU 也立即挂起，避免无意义的忙等。\n- 此机制在虚拟化过载环境中显著减少 CPU 浪费，同时在非过载场景下通过一次抢锁尝试维持性能。\n\n### 锁-节点哈希表\n\n- 为支持 `pv_kick()` 快速定位等待某锁的 vCPU，内核维护一个全局哈希表 `pv_lock_hash`。\n- 哈希表大小为 `4 * num_possible_cpus()`，确保即使在最大嵌套深度（4 层）下也有足够条目。\n- 使用 **开放寻址法**，每缓存行存放多个条目（`PV_HE_PER_LINE`），减少缓存未命中。\n- 锁持有者在释放锁前必须调用 `pv_unhash()` 移除映射，保证哈希表一致性。\n\n### Pending 位操作优化\n\n- 根据 `_Q_PENDING_BITS` 是否为 8（即 `pending` 字段是否独立字节），提供两种实现：\n  - **独立字节**：直接写 `pending` 字段，使用 `cmpxchg_acquire` 尝试获取锁。\n  - **共享字段**：使用原子位操作（`atomic_or` / `atomic_cmpxchg_acquire`）修改 `val`。\n\n## 4. 依赖关系\n\n- **架构依赖**：必须由底层架构（如 x86 KVM/Xen）提供 `pv_wait()` 和 `pv_kick()` 超调用。\n- **头文件依赖**：\n  - `<linux/hash.h>`：提供 `hash_ptr()` 哈希函数。\n  - `<linux/memblock.h>`：用于早期内存分配（`alloc_large_system_hash`）。\n  - `<linux/debug_locks.h>`：锁调试支持。\n- **锁核心依赖**：基于 `qspinlock` 和 `mcs_spinlock` 实现，需与 `locking/qspinlock.c` 协同工作。\n- **编译依赖**：必须由定义了 `_GEN_PV_LOCK_SLOWPATH` 的源文件包含，不能独立编译。\n\n## 5. 使用场景\n\n- **虚拟化环境**：主要在 KVM、Xen 等半虚拟化 Hypervisor 上启用，优化多 vCPU 虚拟机中的锁竞争。\n- **高竞争锁场景**：当多个 vCPU 频繁争用同一自旋锁时，避免忙等待导致的宿主机 CPU 资源耗尽。\n- **过载宿主机**：在物理 CPU 资源不足时，挂起等待锁的 vCPU 可减少调度开销和上下文切换延迟。\n- **混合工作负载**：通过混合锁机制，在低竞争时保持高性能，高竞争时保证公平性，适用于通用服务器场景。",
      "similarity": 0.5400874614715576,
      "chunks": []
    },
    {
      "source_file": "mm/balloon_compaction.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:41:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `balloon_compaction.c`\n\n---\n\n# balloon_compaction.c 技术文档\n\n## 1. 文件概述\n\n`balloon_compaction.c` 是 Linux 内核中用于支持内存气球（Memory Ballooning）机制与内存压缩（Compaction）协同工作的核心模块。该文件提供了通用接口，使得由气球驱动程序管理的页面可以被内存压缩子系统识别为可迁移（movable），从而在内存碎片整理过程中安全地移动这些页面，提升高阶内存分配的成功率。此机制主要用于虚拟化环境中，允许宿主机动态调整客户机（Guest）的可用内存。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`balloon_page_alloc()`**  \n  分配一个新的页面，专用于加入气球页面列表。使用特殊的 GFP 标志（如 `__GFP_NOMEMALLOC`, `__GFP_NORETRY`, `__GFP_NOWARN`）以避免在内存压力下触发 OOM 或重试。\n\n- **`balloon_page_enqueue()`**  \n  将单个通过 `balloon_page_alloc()` 分配的页面插入到指定气球设备的页面列表中，并增加 `BALLOON_INFLATE` 统计计数。\n\n- **`balloon_page_list_enqueue()`**  \n  批量将一个页面链表中的所有页面插入到气球设备的页面列表中，适用于高效批量操作。\n\n- **`balloon_page_dequeue()`**  \n  从气球设备的页面列表中移除并返回一个页面，供驱动释放回系统。若无法出队且无孤立页面，则触发 `BUG()` 防止死循环。\n\n- **`balloon_page_list_dequeue()`**  \n  批量从气球设备中取出最多 `n_req_pages` 个页面，放入调用者提供的链表中，用于批量释放。\n\n- **`balloon_page_isolate()`**（仅当 `CONFIG_BALLOON_COMPACTION` 启用）  \n  在内存压缩过程中，将气球页面从主列表中隔离，防止并发访问，并增加 `isolated_pages` 计数。\n\n- **`balloon_page_putback()`**（仅当 `CONFIG_BALLOON_COMPACTION` 启用）  \n  将被隔离的气球页面重新放回主页面列表，并减少 `isolated_pages` 计数。\n\n- **`balloon_page_migrate()`**（仅当 `CONFIG_BALLOON_COMPACTION` 启用）  \n  实现气球页面的迁移逻辑，作为内存压缩中 `move_to_new_page()` 的对应处理函数（代码片段未完整）。\n\n### 关键数据结构\n\n- **`struct balloon_dev_info`**  \n  气球设备信息结构体，包含：\n  - `pages`：已入队的气球页面链表\n  - `pages_lock`：保护页面列表的自旋锁\n  - `isolated_pages`：当前被压缩子系统隔离的页面数量（仅在 `CONFIG_BALLOON_COMPACTION` 下使用）\n\n## 3. 关键实现\n\n- **线程安全与并发控制**  \n  所有对 `balloon_dev_info->pages` 链表的操作均受 `pages_lock` 自旋锁保护，并在中断禁用上下文中执行（`spin_lock_irqsave`），确保在高并发或中断上下文中的安全性。\n\n- **页面锁定机制**  \n  在入队和出队时使用 `trylock_page()` 确保当前是唯一持有页面引用的实体。若加锁失败，说明存在并发访问，可能意味着内存损坏或状态不一致，此时会跳过或报错。\n\n- **与内存压缩集成**  \n  当启用 `CONFIG_BALLOON_COMPACTION` 时，气球页面可通过 `PageIsolated()` 标志被识别为正在被压缩子系统处理。出队操作会跳过这些页面，避免破坏压缩流程。\n\n- **统计计数**  \n  使用 `__count_vm_event(BALLOON_INFLATE)` 和 `__count_vm_event(BALLOON_DEFLATE)` 跟踪气球膨胀/收缩操作次数，便于性能监控和调试。\n\n- **错误检测与防御性编程**  \n  在 `balloon_page_dequeue()` 中，若页面列表为空且无孤立页面，说明页面丢失，触发 `BUG()` 以防止驱动陷入无限循环。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`：内存管理基础接口\n  - `<linux/slab.h>`：内存分配\n  - `<linux/balloon_compaction.h>`：气球压缩相关声明（如 `balloon_page_insert`, `balloon_page_delete`, `balloon_page_device` 等）\n\n- **内核配置依赖**：\n  - `CONFIG_MEMORY_BALLOONING`：启用内存气球机制\n  - `CONFIG_BALLOON_COMPACTION`：启用气球页面的可压缩支持（条件编译）\n\n- **与其他子系统交互**：\n  - **内存压缩子系统（mm/compaction.c）**：通过注册的 `isolate` / `migrate` 回调函数参与页面迁移\n  - **虚拟化驱动（如 virtio_balloon）**：作为使用者调用本模块提供的 enqueue/dequeue 接口管理气球内存\n\n## 5. 使用场景\n\n- **虚拟化环境中的内存动态调整**  \n  客户机操作系统通过气球驱动（如 `virtio_balloon`）向宿主机“归还”内存时，调用 `balloon_page_alloc()` + `balloon_page_enqueue()` 将页面加入气球列表；当宿主机释放内存给客户机时，驱动调用 `balloon_page_dequeue()` 获取页面并释放回 buddy allocator。\n\n- **高阶内存分配优化**  \n  当系统需要大块连续物理内存（如透明大页 THP）但存在碎片时，内存压缩子系统会尝试迁移可移动页面。气球页面因本模块支持而被视为可移动，从而被安全迁移，帮助形成连续内存区域。\n\n- **内存热插拔与 NUMA 迁移**  \n  在 NUMA 节点间迁移内存或热移除内存区域时，气球页面可被压缩机制迁移，提高操作成功率。\n\n- **OOM 避免与内存回收**  \n  气球机制本身是一种主动内存回收手段，配合压缩可进一步提升内存利用率，减少 OOM 发生概率。",
      "similarity": 0.5166136026382446,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/balloon_compaction.c",
          "start_line": 14,
          "end_line": 129,
          "content": [
            "static void balloon_page_enqueue_one(struct balloon_dev_info *b_dev_info,",
            "\t\t\t\t     struct page *page)",
            "{",
            "\t/*",
            "\t * Block others from accessing the 'page' when we get around to",
            "\t * establishing additional references. We should be the only one",
            "\t * holding a reference to the 'page' at this point. If we are not, then",
            "\t * memory corruption is possible and we should stop execution.",
            "\t */",
            "\tBUG_ON(!trylock_page(page));",
            "\tballoon_page_insert(b_dev_info, page);",
            "\tunlock_page(page);",
            "\t__count_vm_event(BALLOON_INFLATE);",
            "}",
            "size_t balloon_page_list_enqueue(struct balloon_dev_info *b_dev_info,",
            "\t\t\t\t struct list_head *pages)",
            "{",
            "\tstruct page *page, *tmp;",
            "\tunsigned long flags;",
            "\tsize_t n_pages = 0;",
            "",
            "\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);",
            "\tlist_for_each_entry_safe(page, tmp, pages, lru) {",
            "\t\tlist_del(&page->lru);",
            "\t\tballoon_page_enqueue_one(b_dev_info, page);",
            "\t\tn_pages++;",
            "\t}",
            "\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);",
            "\treturn n_pages;",
            "}",
            "size_t balloon_page_list_dequeue(struct balloon_dev_info *b_dev_info,",
            "\t\t\t\t struct list_head *pages, size_t n_req_pages)",
            "{",
            "\tstruct page *page, *tmp;",
            "\tunsigned long flags;",
            "\tsize_t n_pages = 0;",
            "",
            "\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);",
            "\tlist_for_each_entry_safe(page, tmp, &b_dev_info->pages, lru) {",
            "\t\tif (n_pages == n_req_pages)",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * Block others from accessing the 'page' while we get around to",
            "\t\t * establishing additional references and preparing the 'page'",
            "\t\t * to be released by the balloon driver.",
            "\t\t */",
            "\t\tif (!trylock_page(page))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (IS_ENABLED(CONFIG_BALLOON_COMPACTION) &&",
            "\t\t    PageIsolated(page)) {",
            "\t\t\t/* raced with isolation */",
            "\t\t\tunlock_page(page);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tballoon_page_delete(page);",
            "\t\t__count_vm_event(BALLOON_DEFLATE);",
            "\t\tlist_add(&page->lru, pages);",
            "\t\tunlock_page(page);",
            "\t\tn_pages++;",
            "\t}",
            "\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);",
            "",
            "\treturn n_pages;",
            "}",
            "void balloon_page_enqueue(struct balloon_dev_info *b_dev_info,",
            "\t\t\t  struct page *page)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);",
            "\tballoon_page_enqueue_one(b_dev_info, page);",
            "\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);",
            "}",
            "static bool balloon_page_isolate(struct page *page, isolate_mode_t mode)",
            "",
            "{",
            "\tstruct balloon_dev_info *b_dev_info = balloon_page_device(page);",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);",
            "\tlist_del(&page->lru);",
            "\tb_dev_info->isolated_pages++;",
            "\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);",
            "",
            "\treturn true;",
            "}",
            "static void balloon_page_putback(struct page *page)",
            "{",
            "\tstruct balloon_dev_info *b_dev_info = balloon_page_device(page);",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);",
            "\tlist_add(&page->lru, &b_dev_info->pages);",
            "\tb_dev_info->isolated_pages--;",
            "\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);",
            "}",
            "static int balloon_page_migrate(struct page *newpage, struct page *page,",
            "\t\tenum migrate_mode mode)",
            "{",
            "\tstruct balloon_dev_info *balloon = balloon_page_device(page);",
            "",
            "\t/*",
            "\t * We can not easily support the no copy case here so ignore it as it",
            "\t * is unlikely to be used with balloon pages. See include/linux/hmm.h",
            "\t * for a user of the MIGRATE_SYNC_NO_COPY mode.",
            "\t */",
            "\tif (mode == MIGRATE_SYNC_NO_COPY)",
            "\t\treturn -EINVAL;",
            "",
            "\tVM_BUG_ON_PAGE(!PageLocked(page), page);",
            "\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);",
            "",
            "\treturn balloon->migratepage(balloon, newpage, page, mode);",
            "}"
          ],
          "function_name": "balloon_page_enqueue_one, balloon_page_list_enqueue, balloon_page_list_dequeue, balloon_page_enqueue, balloon_page_isolate, balloon_page_putback, balloon_page_migrate",
          "description": "提供气球内存页的并发控制及迁移管理，通过自旋锁保护页表操作，实现页面在LRU链表间的移动、隔离和迁移，支持气球膨胀/收缩事件统计",
          "similarity": 0.47462156414985657
        },
        {
          "chunk_id": 0,
          "file_path": "mm/balloon_compaction.c",
          "start_line": 1,
          "end_line": 13,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * mm/balloon_compaction.c",
            " *",
            " * Common interface for making balloon pages movable by compaction.",
            " *",
            " * Copyright (C) 2012, Red Hat, Inc.  Rafael Aquini <aquini@redhat.com>",
            " */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/balloon_compaction.h>",
            ""
          ],
          "function_name": null,
          "description": "上下文不完整",
          "similarity": 0.3333066403865814
        }
      ]
    }
  ]
}