{
  "query": "缓冲区同步机制",
  "timestamp": "2025-12-25 23:48:56",
  "retrieved_files": [
    {
      "source_file": "kernel/async.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:49:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `async.c`\n\n---\n\n# async.c 技术文档\n\n## 1. 文件概述\n\n`async.c` 实现了 Linux 内核中的异步函数调用机制，主要用于优化系统启动性能。该机制允许在内核初始化阶段将原本串行执行的、相互独立的硬件探测和初始化操作并行化，从而显著缩短启动时间。其核心思想是在保持对外可见操作顺序一致性的前提下，内部执行过程可乱序进行，类似于乱序执行 CPU 的“按序提交”语义。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct async_entry`**：表示一个异步任务条目，包含：\n  - `domain_list` / `global_list`：分别链接到所属域和全局的待处理链表\n  - `work`：关联的 workqueue 工作项\n  - `cookie`：序列号，用于同步控制\n  - `func` / `data`：要执行的函数及其参数\n  - `domain`：所属的异步域\n\n- **`struct async_domain`**：异步执行域，用于将异步任务分组管理，默认使用 `async_dfl_domain`\n\n- **全局变量**：\n  - `next_cookie`：单调递增的序列号生成器\n  - `async_global_pending`：所有已注册域的全局待处理任务链表\n  - `async_dfl_domain`：默认异步域\n  - `async_lock`：保护异步任务队列的自旋锁\n  - `entry_count`：当前挂起的异步任务计数\n\n### 主要函数\n\n- **`async_schedule_node_domain()`**：在指定 NUMA 节点和异步域中调度异步函数\n- **`async_schedule_node()`**：在指定 NUMA 节点上调度异步函数（使用默认域）\n- **`async_schedule_dev_nocall()`**：基于设备的 NUMA 信息调度异步函数（失败时不回退到同步执行）\n- **`lowest_in_progress()`**：获取指定域或全局中最早（最小 cookie）的未完成任务\n- **`async_run_entry_fn()`**：workqueue 回调函数，实际执行异步任务并清理资源\n\n## 3. 关键实现\n\n### 序列 Cookie 机制\n- 每个异步任务分配一个单调递增的 `async_cookie_t`（64 位无符号整数）\n- 任务执行前可通过 `async_synchronize_cookie()` 等待所有小于等于指定 cookie 的任务完成\n- 保证对外部可见操作（如设备注册）的顺序一致性\n\n### 内存与负载控制\n- 使用 `GFP_ATOMIC` 分配内存，支持原子上下文调用\n- 当内存不足或挂起任务超过 `MAX_WORK`（32768）时，自动回退到同步执行\n- 通过 `entry_count` 原子计数器跟踪挂起任务数量\n\n### 双链表管理\n- 每个任务同时链接到：\n  - 所属域的 `domain->pending` 链表（按 cookie 顺序）\n  - 全局 `async_global_pending` 链表（仅当域已注册）\n- 保证域内和全局的同步操作都能正确等待\n\n### NUMA 感知调度\n- 通过 `queue_work_node()` 将任务调度到指定 NUMA 节点\n- 若节点无效则自动分发到可用 CPU\n\n### 资源清理与通知\n- 任务执行完成后从链表移除并释放内存\n- 通过 `wake_up(&async_done)` 唤醒等待同步完成的线程\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/async.h>`：异步 API 定义\n  - `<linux/workqueue.h>`：工作队列机制\n  - `\"workqueue_internal.h\"`：内部 workqueue 接口\n  - 其他基础内核头文件（atomic、slab、wait 等）\n\n- **核心子系统**：\n  - **Workqueue 子系统**：实际执行异步任务的底层机制\n  - **内存管理子系统**：任务结构体内存分配\n  - **调度器**：NUMA 节点感知的任务调度\n\n- **导出符号**：\n  - `async_schedule_node_domain`\n  - `async_schedule_node`\n\n## 5. 使用场景\n\n- **内核启动优化**：\n  - 并行执行设备探测（如 PCI、USB 控制器初始化）\n  - 异步加载固件或执行硬件自检\n\n- **驱动初始化**：\n  - 驱动可将耗时的初始化操作（如 PHY 配置、固件加载）放入异步任务\n  - 通过 `async_synchronize_full()` 确保在模块初始化完成前所有异步任务结束\n\n- **NUMA 优化**：\n  - 将设备相关的初始化任务调度到设备所在 NUMA 节点，减少远程内存访问\n\n- **资源受限环境**：\n  - 在内存压力下自动回退到同步执行，保证系统稳定性\n  - 通过 `MAX_WORK` 限制防止异步任务无限堆积",
      "similarity": 0.5830578804016113,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/async.c",
          "start_line": 241,
          "end_line": 290,
          "content": [
            "async_cookie_t async_schedule_node(async_func_t func, void *data, int node)",
            "{",
            "\treturn async_schedule_node_domain(func, data, node, &async_dfl_domain);",
            "}",
            "bool async_schedule_dev_nocall(async_func_t func, struct device *dev)",
            "{",
            "\tstruct async_entry *entry;",
            "",
            "\tentry = kzalloc(sizeof(struct async_entry), GFP_KERNEL);",
            "",
            "\t/* Give up if there is no memory or too much work. */",
            "\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {",
            "\t\tkfree(entry);",
            "\t\treturn false;",
            "\t}",
            "",
            "\t__async_schedule_node_domain(func, dev, dev_to_node(dev),",
            "\t\t\t\t     &async_dfl_domain, entry);",
            "\treturn true;",
            "}",
            "void async_synchronize_full(void)",
            "{",
            "\tasync_synchronize_full_domain(NULL);",
            "}",
            "void async_synchronize_full_domain(struct async_domain *domain)",
            "{",
            "\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);",
            "}",
            "void async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)",
            "{",
            "\tktime_t starttime;",
            "",
            "\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));",
            "\tstarttime = ktime_get();",
            "",
            "\twait_event(async_done, lowest_in_progress(domain) >= cookie);",
            "",
            "\tpr_debug(\"async_continuing @ %i after %lli usec\\n\", task_pid_nr(current),",
            "\t\t microseconds_since(starttime));",
            "}",
            "void async_synchronize_cookie(async_cookie_t cookie)",
            "{",
            "\tasync_synchronize_cookie_domain(cookie, &async_dfl_domain);",
            "}",
            "bool current_is_async(void)",
            "{",
            "\tstruct worker *worker = current_wq_worker();",
            "",
            "\treturn worker && worker->current_func == async_run_entry_fn;",
            "}"
          ],
          "function_name": "async_schedule_node, async_schedule_dev_nocall, async_synchronize_full, async_synchronize_full_domain, async_synchronize_cookie_domain, async_synchronize_cookie, current_is_async",
          "description": "提供同步屏障接口和运行态检测，确保异步操作有序完成",
          "similarity": 0.6116465330123901
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/async.c",
          "start_line": 82,
          "end_line": 201,
          "content": [
            "static long long microseconds_since(ktime_t start)",
            "{",
            "\tktime_t now = ktime_get();",
            "\treturn ktime_to_ns(ktime_sub(now, start)) >> 10;",
            "}",
            "static async_cookie_t lowest_in_progress(struct async_domain *domain)",
            "{",
            "\tstruct async_entry *first = NULL;",
            "\tasync_cookie_t ret = ASYNC_COOKIE_MAX;",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&async_lock, flags);",
            "",
            "\tif (domain) {",
            "\t\tif (!list_empty(&domain->pending))",
            "\t\t\tfirst = list_first_entry(&domain->pending,",
            "\t\t\t\t\tstruct async_entry, domain_list);",
            "\t} else {",
            "\t\tif (!list_empty(&async_global_pending))",
            "\t\t\tfirst = list_first_entry(&async_global_pending,",
            "\t\t\t\t\tstruct async_entry, global_list);",
            "\t}",
            "",
            "\tif (first)",
            "\t\tret = first->cookie;",
            "",
            "\tspin_unlock_irqrestore(&async_lock, flags);",
            "\treturn ret;",
            "}",
            "static void async_run_entry_fn(struct work_struct *work)",
            "{",
            "\tstruct async_entry *entry =",
            "\t\tcontainer_of(work, struct async_entry, work);",
            "\tunsigned long flags;",
            "\tktime_t calltime;",
            "",
            "\t/* 1) run (and print duration) */",
            "\tpr_debug(\"calling  %lli_%pS @ %i\\n\", (long long)entry->cookie,",
            "\t\t entry->func, task_pid_nr(current));",
            "\tcalltime = ktime_get();",
            "",
            "\tentry->func(entry->data, entry->cookie);",
            "",
            "\tpr_debug(\"initcall %lli_%pS returned after %lld usecs\\n\",",
            "\t\t (long long)entry->cookie, entry->func,",
            "\t\t microseconds_since(calltime));",
            "",
            "\t/* 2) remove self from the pending queues */",
            "\tspin_lock_irqsave(&async_lock, flags);",
            "\tlist_del_init(&entry->domain_list);",
            "\tlist_del_init(&entry->global_list);",
            "",
            "\t/* 3) free the entry */",
            "\tkfree(entry);",
            "\tatomic_dec(&entry_count);",
            "",
            "\tspin_unlock_irqrestore(&async_lock, flags);",
            "",
            "\t/* 4) wake up any waiters */",
            "\twake_up(&async_done);",
            "}",
            "static async_cookie_t __async_schedule_node_domain(async_func_t func,",
            "\t\t\t\t\t\t   void *data, int node,",
            "\t\t\t\t\t\t   struct async_domain *domain,",
            "\t\t\t\t\t\t   struct async_entry *entry)",
            "{",
            "\tasync_cookie_t newcookie;",
            "\tunsigned long flags;",
            "",
            "\tINIT_LIST_HEAD(&entry->domain_list);",
            "\tINIT_LIST_HEAD(&entry->global_list);",
            "\tINIT_WORK(&entry->work, async_run_entry_fn);",
            "\tentry->func = func;",
            "\tentry->data = data;",
            "\tentry->domain = domain;",
            "",
            "\tspin_lock_irqsave(&async_lock, flags);",
            "",
            "\t/* allocate cookie and queue */",
            "\tnewcookie = entry->cookie = next_cookie++;",
            "",
            "\tlist_add_tail(&entry->domain_list, &domain->pending);",
            "\tif (domain->registered)",
            "\t\tlist_add_tail(&entry->global_list, &async_global_pending);",
            "",
            "\tatomic_inc(&entry_count);",
            "\tspin_unlock_irqrestore(&async_lock, flags);",
            "",
            "\t/* schedule for execution */",
            "\tqueue_work_node(node, system_unbound_wq, &entry->work);",
            "",
            "\treturn newcookie;",
            "}",
            "async_cookie_t async_schedule_node_domain(async_func_t func, void *data,",
            "\t\t\t\t\t  int node, struct async_domain *domain)",
            "{",
            "\tstruct async_entry *entry;",
            "\tunsigned long flags;",
            "\tasync_cookie_t newcookie;",
            "",
            "\t/* allow irq-off callers */",
            "\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);",
            "",
            "\t/*",
            "\t * If we're out of memory or if there's too much work",
            "\t * pending already, we execute synchronously.",
            "\t */",
            "\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {",
            "\t\tkfree(entry);",
            "\t\tspin_lock_irqsave(&async_lock, flags);",
            "\t\tnewcookie = next_cookie++;",
            "\t\tspin_unlock_irqrestore(&async_lock, flags);",
            "",
            "\t\t/* low on memory.. run synchronously */",
            "\t\tfunc(data, newcookie);",
            "\t\treturn newcookie;",
            "\t}",
            "",
            "\treturn __async_schedule_node_domain(func, data, node, domain, entry);",
            "}"
          ],
          "function_name": "microseconds_since, lowest_in_progress, async_run_entry_fn, __async_schedule_node_domain, async_schedule_node_domain",
          "description": "实现异步任务调度与执行逻辑，包含时间测量、任务排队及工作队列调度",
          "similarity": 0.5274287462234497
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/async.c",
          "start_line": 1,
          "end_line": 81,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * async.c: Asynchronous function calls for boot performance",
            " *",
            " * (C) Copyright 2009 Intel Corporation",
            " * Author: Arjan van de Ven <arjan@linux.intel.com>",
            " */",
            "",
            "",
            "/*",
            "",
            "Goals and Theory of Operation",
            "",
            "The primary goal of this feature is to reduce the kernel boot time,",
            "by doing various independent hardware delays and discovery operations",
            "decoupled and not strictly serialized.",
            "",
            "More specifically, the asynchronous function call concept allows",
            "certain operations (primarily during system boot) to happen",
            "asynchronously, out of order, while these operations still",
            "have their externally visible parts happen sequentially and in-order.",
            "(not unlike how out-of-order CPUs retire their instructions in order)",
            "",
            "Key to the asynchronous function call implementation is the concept of",
            "a \"sequence cookie\" (which, although it has an abstracted type, can be",
            "thought of as a monotonically incrementing number).",
            "",
            "The async core will assign each scheduled event such a sequence cookie and",
            "pass this to the called functions.",
            "",
            "The asynchronously called function should before doing a globally visible",
            "operation, such as registering device numbers, call the",
            "async_synchronize_cookie() function and pass in its own cookie. The",
            "async_synchronize_cookie() function will make sure that all asynchronous",
            "operations that were scheduled prior to the operation corresponding with the",
            "cookie have completed.",
            "",
            "Subsystem/driver initialization code that scheduled asynchronous probe",
            "functions, but which shares global resources with other drivers/subsystems",
            "that do not use the asynchronous call feature, need to do a full",
            "synchronization with the async_synchronize_full() function, before returning",
            "from their init function. This is to maintain strict ordering between the",
            "asynchronous and synchronous parts of the kernel.",
            "",
            "*/",
            "",
            "#include <linux/async.h>",
            "#include <linux/atomic.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/pid.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/workqueue.h>",
            "",
            "#include \"workqueue_internal.h\"",
            "",
            "static async_cookie_t next_cookie = 1;",
            "",
            "#define MAX_WORK\t\t32768",
            "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */",
            "",
            "static LIST_HEAD(async_global_pending);\t/* pending from all registered doms */",
            "static ASYNC_DOMAIN(async_dfl_domain);",
            "static DEFINE_SPINLOCK(async_lock);",
            "",
            "struct async_entry {",
            "\tstruct list_head\tdomain_list;",
            "\tstruct list_head\tglobal_list;",
            "\tstruct work_struct\twork;",
            "\tasync_cookie_t\t\tcookie;",
            "\tasync_func_t\t\tfunc;",
            "\tvoid\t\t\t*data;",
            "\tstruct async_domain\t*domain;",
            "};",
            "",
            "static DECLARE_WAIT_QUEUE_HEAD(async_done);",
            "",
            "static atomic_t entry_count;",
            ""
          ],
          "function_name": null,
          "description": "定义异步任务结构体和核心变量，支持多域异步调度",
          "similarity": 0.4667903780937195
        }
      ]
    },
    {
      "source_file": "kernel/rcu/sync.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:44:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\sync.c`\n\n---\n\n# rcu/sync.c 技术文档\n\n## 文件概述\n\n`rcu/sync.c` 实现了一个基于 RCU（Read-Copy-Update）机制的轻量级读写同步基础设施，称为 `rcu_sync`。该机制允许写者（更新者）在需要时强制所有读者切换到“慢路径”（slow path），并在更新完成后经过一个 RCU 宽限期（grace period）后，允许读者重新使用“快路径”（fast path）。该设计特别适用于需要频繁但短暂地禁用读者快路径的场景，避免了传统读写锁的开销，同时利用 RCU 的无锁读取特性提升性能。\n\n## 核心功能\n\n### 数据结构\n\n- **`struct rcu_sync`**  \n  核心同步控制结构，包含以下关键字段：\n  - `gp_state`：当前同步状态（`GP_IDLE`, `GP_ENTER`, `GP_PASSED`, `GP_EXIT`, `GP_REPLAY`）\n  - `gp_count`：嵌套的 `rcu_sync_enter()` 调用计数\n  - `cb_head`：用于 RCU 回调的 `rcu_head`\n  - `gp_wait`：等待队列，用于阻塞等待状态转换完成\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `rcu_sync_init()` | 初始化 `rcu_sync` 结构体 |\n| `rcu_sync_enter_start()` | 预激活同步机制，使 `rcu_sync_is_idle()` 返回 false，且后续 enter/exit 成为 NO-OP |\n| `rcu_sync_enter()` | 强制读者进入慢路径，确保后续读者不会使用快路径 |\n| `rcu_sync_exit()` | 标记更新结束，安排在宽限期后恢复读者快路径 |\n| `rcu_sync_dtor()` | 销毁 `rcu_sync` 结构，确保所有 RCU 回调已完成 |\n| `rcu_sync_func()` | RCU 回调函数，根据当前状态推进状态机 |\n\n## 关键实现\n\n### 状态机设计\n\n`rcu_sync` 使用五种状态实现高效的状态转换：\n\n- **`GP_IDLE`**：初始状态，读者可使用快路径。\n- **`GP_ENTER`**：正在进入同步状态，需等待宽限期。\n- **`GP_PASSED`**：宽限期已过，读者已全部进入慢路径。\n- **`GP_EXIT`**：正在退出同步，需等待另一个宽限期以恢复快路径。\n- **`GP_REPLAY`**：在退出过程中又有新的 enter/exit 对发生，需重新调度回调。\n\n### 嵌套与优化\n\n- **嵌套支持**：通过 `gp_count` 支持 `rcu_sync_enter()` 的嵌套调用。只有当 `gp_count` 从 1 递减到 0 时，才触发退出流程。\n- **宽限期合并**：连续的 `enter/exit` 调用可避免多次等待宽限期。例如：\n  - 若在 `GP_PASSED` 状态下调用 `exit`，直接进入 `GP_EXIT` 并调度回调。\n  - 若在回调执行前再次调用 `enter/exit`，状态转为 `GP_REPLAY`，并在回调中重新调度，避免冗余宽限期。\n- **快速路径优化**：首次 `enter` 时若处于 `GP_IDLE`，直接调用 `synchronize_rcu()` 而非异步 `call_rcu()`，可利用 `rcu_expedited` 或 `rcu_blocking_is_gp()` 加速。\n\n### 同步与唤醒\n\n- 写者调用 `rcu_sync_enter()` 后，若非首次进入，会阻塞在 `wait_event()`，直到状态变为 `GP_PASSED` 或更高。\n- `rcu_sync_func()` 在宽限期后执行，根据 `gp_count` 和当前状态决定是唤醒等待者、重调度回调，还是恢复到 `GP_IDLE`。\n\n## 依赖关系\n\n- **`<linux/rcu_sync.h>`**：定义 `struct rcu_sync` 及相关 API。\n- **`<linux/sched.h>`**：提供 `wait_event()`、`wake_up_locked()` 等调度和等待队列原语。\n- **RCU 子系统**：\n  - `call_rcu_hurry()` / `call_rcu()`：用于注册宽限期后的回调。\n  - `synchronize_rcu()`：用于同步等待宽限期。\n  - `rcu_barrier()`：在析构时确保所有回调完成。\n- **自旋锁**：使用 `spin_lock_irqsave()` 保护状态和计数器，确保中断上下文安全。\n\n## 使用场景\n\n- **文件系统元数据更新**：如 overlayfs、btrfs 等在修改共享元数据结构时，临时禁止读者使用快路径缓存。\n- **动态配置更新**：内核模块或子系统在热更新全局配置时，确保读者看到一致状态。\n- **轻量级写者同步**：适用于写操作较少但需高效读者路径的场景，避免传统 rwlock 的读者竞争开销。\n- **替代 `synchronize_rcu()` 的批量操作**：当多个连续更新可合并为一次宽限期等待时，提升性能。",
      "similarity": 0.5807579755783081,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/rcu/sync.c",
          "start_line": 21,
          "end_line": 136,
          "content": [
            "void rcu_sync_init(struct rcu_sync *rsp)",
            "{",
            "\tmemset(rsp, 0, sizeof(*rsp));",
            "\tinit_waitqueue_head(&rsp->gp_wait);",
            "}",
            "void rcu_sync_enter_start(struct rcu_sync *rsp)",
            "{",
            "\trsp->gp_count++;",
            "\trsp->gp_state = GP_PASSED;",
            "}",
            "static void rcu_sync_call(struct rcu_sync *rsp)",
            "{",
            "\tcall_rcu_hurry(&rsp->cb_head, rcu_sync_func);",
            "}",
            "static void rcu_sync_func(struct rcu_head *rhp)",
            "{",
            "\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);",
            "\tunsigned long flags;",
            "",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);",
            "",
            "\tspin_lock_irqsave(&rsp->rss_lock, flags);",
            "\tif (rsp->gp_count) {",
            "\t\t/*",
            "\t\t * We're at least a GP after the GP_IDLE->GP_ENTER transition.",
            "\t\t */",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_PASSED);",
            "\t\twake_up_locked(&rsp->gp_wait);",
            "\t} else if (rsp->gp_state == GP_REPLAY) {",
            "\t\t/*",
            "\t\t * A new rcu_sync_exit() has happened; requeue the callback to",
            "\t\t * catch a later GP.",
            "\t\t */",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);",
            "\t\trcu_sync_call(rsp);",
            "\t} else {",
            "\t\t/*",
            "\t\t * We're at least a GP after the last rcu_sync_exit(); everybody",
            "\t\t * will now have observed the write side critical section.",
            "\t\t * Let 'em rip!",
            "\t\t */",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_IDLE);",
            "\t}",
            "\tspin_unlock_irqrestore(&rsp->rss_lock, flags);",
            "}",
            "void rcu_sync_enter(struct rcu_sync *rsp)",
            "{",
            "\tint gp_state;",
            "",
            "\tspin_lock_irq(&rsp->rss_lock);",
            "\tgp_state = rsp->gp_state;",
            "\tif (gp_state == GP_IDLE) {",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_ENTER);",
            "\t\tWARN_ON_ONCE(rsp->gp_count);",
            "\t\t/*",
            "\t\t * Note that we could simply do rcu_sync_call(rsp) here and",
            "\t\t * avoid the \"if (gp_state == GP_IDLE)\" block below.",
            "\t\t *",
            "\t\t * However, synchronize_rcu() can be faster if rcu_expedited",
            "\t\t * or rcu_blocking_is_gp() is true.",
            "\t\t *",
            "\t\t * Another reason is that we can't wait for rcu callback if",
            "\t\t * we are called at early boot time but this shouldn't happen.",
            "\t\t */",
            "\t}",
            "\trsp->gp_count++;",
            "\tspin_unlock_irq(&rsp->rss_lock);",
            "",
            "\tif (gp_state == GP_IDLE) {",
            "\t\t/*",
            "\t\t * See the comment above, this simply does the \"synchronous\"",
            "\t\t * call_rcu(rcu_sync_func) which does GP_ENTER -> GP_PASSED.",
            "\t\t */",
            "\t\tsynchronize_rcu();",
            "\t\trcu_sync_func(&rsp->cb_head);",
            "\t\t/* Not really needed, wait_event() would see GP_PASSED. */",
            "\t\treturn;",
            "\t}",
            "",
            "\twait_event(rsp->gp_wait, READ_ONCE(rsp->gp_state) >= GP_PASSED);",
            "}",
            "void rcu_sync_exit(struct rcu_sync *rsp)",
            "{",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count) == 0);",
            "",
            "\tspin_lock_irq(&rsp->rss_lock);",
            "\tif (!--rsp->gp_count) {",
            "\t\tif (rsp->gp_state == GP_PASSED) {",
            "\t\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);",
            "\t\t\trcu_sync_call(rsp);",
            "\t\t} else if (rsp->gp_state == GP_EXIT) {",
            "\t\t\tWRITE_ONCE(rsp->gp_state, GP_REPLAY);",
            "\t\t}",
            "\t}",
            "\tspin_unlock_irq(&rsp->rss_lock);",
            "}",
            "void rcu_sync_dtor(struct rcu_sync *rsp)",
            "{",
            "\tint gp_state;",
            "",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count));",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);",
            "",
            "\tspin_lock_irq(&rsp->rss_lock);",
            "\tif (rsp->gp_state == GP_REPLAY)",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);",
            "\tgp_state = rsp->gp_state;",
            "\tspin_unlock_irq(&rsp->rss_lock);",
            "",
            "\tif (gp_state != GP_IDLE) {",
            "\t\trcu_barrier();",
            "\t\tWARN_ON_ONCE(rsp->gp_state != GP_IDLE);",
            "\t}",
            "}"
          ],
          "function_name": "rcu_sync_init, rcu_sync_enter_start, rcu_sync_call, rcu_sync_func, rcu_sync_enter, rcu_sync_exit, rcu_sync_dtor",
          "description": "实现了RCU同步核心函数，包括初始化、状态管理、回调触发和退出处理，通过spinlock保护状态机并利用RCU回调实现延迟同步，用于协调读者-写者并发访问的安全转换",
          "similarity": 0.6157456636428833
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/rcu/sync.c",
          "start_line": 1,
          "end_line": 20,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * RCU-based infrastructure for lightweight reader-writer locking",
            " *",
            " * Copyright (c) 2015, Red Hat, Inc.",
            " *",
            " * Author: Oleg Nesterov <oleg@redhat.com>",
            " */",
            "",
            "#include <linux/rcu_sync.h>",
            "#include <linux/sched.h>",
            "",
            "enum { GP_IDLE = 0, GP_ENTER, GP_PASSED, GP_EXIT, GP_REPLAY };",
            "",
            "#define\trss_lock\tgp_wait.lock",
            "",
            "/**",
            " * rcu_sync_init() - Initialize an rcu_sync structure",
            " * @rsp: Pointer to rcu_sync structure to be initialized",
            " */"
          ],
          "function_name": null,
          "description": "定义了RCU同步基础设施的枚举常量和rcu_sync_init函数声明，用于初始化rcu_sync结构体，但代码上下文不完整",
          "similarity": 0.5009686946868896
        }
      ]
    },
    {
      "source_file": "kernel/sched/wait_bit.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:21:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\wait_bit.c`\n\n---\n\n# `sched/wait_bit.c` 技术文档\n\n## 1. 文件概述\n\n`sched/wait_bit.c` 实现了 Linux 内核中基于**位（bit）等待机制**的通用等待/唤醒接口。该机制允许任务在某个内存地址的特定位被清除（或满足特定条件）之前进入睡眠状态，并在该位状态改变时被唤醒。这种机制广泛用于页缓存、inode 状态、设备状态等需要基于位标志进行同步的场景。\n\n该文件提供了一套标准化的等待队列哈希表、等待入口结构、唤醒函数以及通用等待循环逻辑，支持可中断、不可中断、带超时、I/O 调度等多种等待模式。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`bit_wait_table[WAIT_TABLE_SIZE]`**  \n  全局静态哈希等待队列数组，大小为 256（`WAIT_TABLE_BITS = 8`），用于将不同 `(word, bit)` 对映射到不同的等待队列，减少竞争。\n\n- **`struct wait_bit_key`**  \n  表示等待目标的键结构，包含：\n  - `void *flags`：指向被监视的位图（word）\n  - `int bit_nr`：被监视的位编号（-1 表示变量级等待）\n  - `unsigned long timeout`：超时时间（仅用于带超时的等待）\n\n- **`struct wait_bit_queue_entry`**  \n  等待队列项，内嵌 `wait_queue_entry`，包含一个 `wait_bit_key`，用于在唤醒时匹配目标。\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `bit_waitqueue(void *word, int bit)` | 根据 `(word, bit)` 计算并返回对应的哈希等待队列头 |\n| `__wait_on_bit()` | 通用位等待循环：测试位状态，调用用户动作函数，直到位清除或动作返回非零 |\n| `__wait_on_bit_lock()` | 带“锁语义”的位等待：在位清除后尝试原子置位，实现类似自旋锁的获取逻辑 |\n| `out_of_line_wait_on_bit*()` | 封装函数，用于避免内联膨胀，供外部模块调用 |\n| `wake_up_bit(void *word, int bit)` | 唤醒所有在 `(word, bit)` 上等待的任务 |\n| `__wake_up_bit()` | `wake_up_bit` 的底层实现 |\n| `bit_wait*()` 系列函数 | 预定义的等待动作函数：<br> - `bit_wait`：普通调度<br> - `bit_wait_io`：I/O 调度<br> - `bit_wait_timeout`：带超时普通调度<br> - `bit_wait_io_timeout`：带超时 I/O 调度 |\n| `init_wait_var_entry()` / `wake_up_var()` | 支持对整个变量（而非特定位）的等待/唤醒（`bit_nr = -1`） |\n| `wait_bit_init()` | 初始化 `bit_wait_table` 中的所有等待队列头 |\n\n## 3. 关键实现\n\n### 哈希映射机制\n- 使用 `hash_long(val, WAIT_TABLE_BITS)` 对 `(word << shift | bit)` 进行哈希，其中 `shift` 为 5（32 位）或 6（64 位），确保地址对齐不影响哈希分布。\n- `__cacheline_aligned` 保证 `bit_wait_table` 按缓存行对齐，减少 false sharing。\n\n### 等待循环逻辑\n- `__wait_on_bit()`：  \n  循环中先 `prepare_to_wait()` 加入队列，然后测试位是否仍置位。若是，则调用用户提供的 `action` 函数（如 `bit_wait`）。循环继续直到位被清除或 `action` 返回非零（如收到信号）。\n- `__wait_on_bit_lock()`：  \n  使用 `prepare_to_wait_exclusive()` 加入**独占等待队列**，避免惊群效应。在位清除后，尝试 `test_and_set_bit()` 原子置位，成功则获得“锁”；失败则继续等待。\n\n### 唤醒匹配机制\n- `wake_bit_function()` 作为默认唤醒回调，仅当 `wait_bit_key` 的 `flags` 和 `bit_nr` 与唤醒参数完全匹配 **且** 目标位**仍为置位状态**时，才调用 `autoremove_wake_function` 唤醒任务。\n- 注意：**唤醒前必须确保内存屏障**（如 `smp_mb__after_atomic()`），以保证位清除操作对等待者可见。\n\n### 变量级等待支持\n- 通过 `bit_nr = -1` 实现对整个指针变量的等待（如 `wait_var_event()` 宏），由 `var_wake_function()` 处理匹配逻辑（忽略 `bit_nr`）。\n\n### 超时处理\n- 超时版本（如 `out_of_line_wait_on_bit_timeout`）在 `wait_bit_key` 中设置 `timeout = jiffies + timeout`，由 `bit_wait_timeout` 等函数检查是否超时。\n\n## 4. 依赖关系\n\n- **头文件依赖**：  \n  依赖 `<linux/wait.h>`、`<linux/sched.h>`、`<linux/hash.h>` 等，使用 `wait_queue_head_t`、`prepare_to_wait`、`schedule` 等核心调度原语。\n- **内联宏依赖**：  \n  依赖 `DEFINE_WAIT_BIT`、`__WAIT_BIT_KEY_INITIALIZER` 等宏（定义在 `wait.h` 中）。\n- **导出符号**：  \n  多个函数通过 `EXPORT_SYMBOL` 或 `EXPORT_SYMBOL_GPL` 导出，供其他内核模块（如 `mm/`、`fs/`、`block/`）使用。\n- **初始化依赖**：  \n  `wait_bit_init()` 由内核启动时调用（通过 `core_initcall` 或类似机制），确保 `bit_wait_table` 在使用前初始化。\n\n## 5. 使用场景\n\n- **页缓存状态同步**：  \n  在 `mm/filemap.c` 中，等待页面 `PG_locked`、`PG_writeback` 等标志位清除。\n- **Inode 状态等待**：  \n  在 `fs/inode.c` 中，等待 `I_SYNC`、`I_FREEING` 等 inode 标志。\n- **块设备 I/O 等待**：  \n  等待请求完成标志位。\n- **通用位标志同步**：  \n  任何需要基于单个位进行任务阻塞/唤醒的场景，如设备状态机、资源锁等。\n- **变量值等待**：  \n  通过 `wait_var_event()` 等宏，等待某个变量变为特定值（底层使用 `bit_nr = -1` 机制）。\n\n该机制提供了一种轻量、高效、可扩展的基于位的同步原语，是 Linux 内核中重要的底层同步基础设施之一。",
      "similarity": 0.5806942582130432,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/wait_bit.c",
          "start_line": 174,
          "end_line": 239,
          "content": [
            "void init_wait_var_entry(struct wait_bit_queue_entry *wbq_entry, void *var, int flags)",
            "{",
            "\t*wbq_entry = (struct wait_bit_queue_entry){",
            "\t\t.key = {",
            "\t\t\t.flags\t= (var),",
            "\t\t\t.bit_nr = -1,",
            "\t\t},",
            "\t\t.wq_entry = {",
            "\t\t\t.flags\t = flags,",
            "\t\t\t.private = current,",
            "\t\t\t.func\t = var_wake_function,",
            "\t\t\t.entry\t = LIST_HEAD_INIT(wbq_entry->wq_entry.entry),",
            "\t\t},",
            "\t};",
            "}",
            "void wake_up_var(void *var)",
            "{",
            "\t__wake_up_bit(__var_waitqueue(var), var, -1);",
            "}",
            "__sched int bit_wait(struct wait_bit_key *word, int mode)",
            "{",
            "\tschedule();",
            "\tif (signal_pending_state(mode, current))",
            "\t\treturn -EINTR;",
            "",
            "\treturn 0;",
            "}",
            "__sched int bit_wait_io(struct wait_bit_key *word, int mode)",
            "{",
            "\tio_schedule();",
            "\tif (signal_pending_state(mode, current))",
            "\t\treturn -EINTR;",
            "",
            "\treturn 0;",
            "}",
            "__sched int bit_wait_timeout(struct wait_bit_key *word, int mode)",
            "{",
            "\tunsigned long now = READ_ONCE(jiffies);",
            "",
            "\tif (time_after_eq(now, word->timeout))",
            "\t\treturn -EAGAIN;",
            "\tschedule_timeout(word->timeout - now);",
            "\tif (signal_pending_state(mode, current))",
            "\t\treturn -EINTR;",
            "",
            "\treturn 0;",
            "}",
            "__sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)",
            "{",
            "\tunsigned long now = READ_ONCE(jiffies);",
            "",
            "\tif (time_after_eq(now, word->timeout))",
            "\t\treturn -EAGAIN;",
            "\tio_schedule_timeout(word->timeout - now);",
            "\tif (signal_pending_state(mode, current))",
            "\t\treturn -EINTR;",
            "",
            "\treturn 0;",
            "}",
            "void __init wait_bit_init(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < WAIT_TABLE_SIZE; i++)",
            "\t\tinit_waitqueue_head(bit_wait_table + i);",
            "}"
          ],
          "function_name": "init_wait_var_entry, wake_up_var, bit_wait, bit_wait_io, bit_wait_timeout, bit_wait_io_timeout, wait_bit_init",
          "description": "提供等待变量初始化与唤醒接口，实现基于等待位的阻塞等待逻辑，并初始化等待位哈希表；上下文不完整",
          "similarity": 0.5176464319229126
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/wait_bit.c",
          "start_line": 21,
          "end_line": 128,
          "content": [
            "int wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *arg)",
            "{",
            "\tstruct wait_bit_key *key = arg;",
            "\tstruct wait_bit_queue_entry *wait_bit = container_of(wq_entry, struct wait_bit_queue_entry, wq_entry);",
            "",
            "\tif (wait_bit->key.flags != key->flags ||",
            "\t\t\twait_bit->key.bit_nr != key->bit_nr ||",
            "\t\t\ttest_bit(key->bit_nr, key->flags))",
            "\t\treturn 0;",
            "",
            "\treturn autoremove_wake_function(wq_entry, mode, sync, key);",
            "}",
            "int __sched",
            "__wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,",
            "\t      wait_bit_action_f *action, unsigned mode)",
            "{",
            "\tint ret = 0;",
            "",
            "\tdo {",
            "\t\tprepare_to_wait(wq_head, &wbq_entry->wq_entry, mode);",
            "\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags))",
            "\t\t\tret = (*action)(&wbq_entry->key, mode);",
            "\t} while (test_bit_acquire(wbq_entry->key.bit_nr, wbq_entry->key.flags) && !ret);",
            "",
            "\tfinish_wait(wq_head, &wbq_entry->wq_entry);",
            "",
            "\treturn ret;",
            "}",
            "int __sched out_of_line_wait_on_bit(void *word, int bit,",
            "\t\t\t\t    wait_bit_action_f *action, unsigned mode)",
            "{",
            "\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);",
            "\tDEFINE_WAIT_BIT(wq_entry, word, bit);",
            "",
            "\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);",
            "}",
            "int __sched out_of_line_wait_on_bit_timeout(",
            "\tvoid *word, int bit, wait_bit_action_f *action,",
            "\tunsigned mode, unsigned long timeout)",
            "{",
            "\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);",
            "\tDEFINE_WAIT_BIT(wq_entry, word, bit);",
            "",
            "\twq_entry.key.timeout = jiffies + timeout;",
            "",
            "\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);",
            "}",
            "int __sched",
            "__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,",
            "\t\t\twait_bit_action_f *action, unsigned mode)",
            "{",
            "\tint ret = 0;",
            "",
            "\tfor (;;) {",
            "\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);",
            "\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {",
            "\t\t\tret = action(&wbq_entry->key, mode);",
            "\t\t\t/*",
            "\t\t\t * See the comment in prepare_to_wait_event().",
            "\t\t\t * finish_wait() does not necessarily takes wwq_head->lock,",
            "\t\t\t * but test_and_set_bit() implies mb() which pairs with",
            "\t\t\t * smp_mb__after_atomic() before wake_up_page().",
            "\t\t\t */",
            "\t\t\tif (ret)",
            "\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);",
            "\t\t}",
            "\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {",
            "\t\t\tif (!ret)",
            "\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);",
            "\t\t\treturn 0;",
            "\t\t} else if (ret) {",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t}",
            "}",
            "int __sched out_of_line_wait_on_bit_lock(void *word, int bit,",
            "\t\t\t\t\t wait_bit_action_f *action, unsigned mode)",
            "{",
            "\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);",
            "\tDEFINE_WAIT_BIT(wq_entry, word, bit);",
            "",
            "\treturn __wait_on_bit_lock(wq_head, &wq_entry, action, mode);",
            "}",
            "void __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)",
            "{",
            "\tstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);",
            "",
            "\tif (waitqueue_active(wq_head))",
            "\t\t__wake_up(wq_head, TASK_NORMAL, 1, &key);",
            "}",
            "void wake_up_bit(void *word, int bit)",
            "{",
            "\t__wake_up_bit(bit_waitqueue(word, bit), word, bit);",
            "}",
            "static int",
            "var_wake_function(struct wait_queue_entry *wq_entry, unsigned int mode,",
            "\t\t  int sync, void *arg)",
            "{",
            "\tstruct wait_bit_key *key = arg;",
            "\tstruct wait_bit_queue_entry *wbq_entry =",
            "\t\tcontainer_of(wq_entry, struct wait_bit_queue_entry, wq_entry);",
            "",
            "\tif (wbq_entry->key.flags != key->flags ||",
            "\t    wbq_entry->key.bit_nr != key->bit_nr)",
            "\t\treturn 0;",
            "",
            "\treturn autoremove_wake_function(wq_entry, mode, sync, key);",
            "}"
          ],
          "function_name": "wake_bit_function, __wait_on_bit, out_of_line_wait_on_bit, out_of_line_wait_on_bit_timeout, __wait_on_bit_lock, out_of_line_wait_on_bit_lock, __wake_up_bit, wake_up_bit, var_wake_function",
          "description": "实现等待位相关的核心函数，包括等待操作、唤醒逻辑及锁操作，管理等待队列中的等待项并处理位状态变化；上下文不完整",
          "similarity": 0.5104839205741882
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/wait_bit.c",
          "start_line": 1,
          "end_line": 20,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "/*",
            " * The implementation of the wait_bit*() and related waiting APIs:",
            " */",
            "",
            "#define WAIT_TABLE_BITS 8",
            "#define WAIT_TABLE_SIZE (1 << WAIT_TABLE_BITS)",
            "",
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE] __cacheline_aligned;",
            "",
            "wait_queue_head_t *bit_waitqueue(void *word, int bit)",
            "{",
            "\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;",
            "\tunsigned long val = (unsigned long)word << shift | bit;",
            "",
            "\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);",
            "}",
            "EXPORT_SYMBOL(bit_waitqueue);",
            ""
          ],
          "function_name": null,
          "description": "定义等待位哈希表及其查找函数，通过哈希将不同等待位映射到对应的等待队列头，用于后续的等待和唤醒操作；上下文不完整",
          "similarity": 0.4385981857776642
        }
      ]
    }
  ]
}