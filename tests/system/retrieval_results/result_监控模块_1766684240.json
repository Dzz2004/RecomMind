{
  "query": "监控模块",
  "timestamp": "2025-12-26 01:37:20",
  "retrieved_files": [
    {
      "source_file": "kernel/trace/rv/rv.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:10:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\rv\\rv.c`\n\n---\n\n# `trace/rv/rv.c` 技术文档\n\n## 1. 文件概述\n\n`rv.c` 是 Linux 内核中运行时验证（Runtime Verification, RV）子系统的主接口实现文件。该文件提供了注册、启用、禁用运行时监控器（monitor）的统一接口，并实现了用户空间与内核 RV 子系统交互的 tracefs 文件系统接口。RV 通过将内核实际执行轨迹与形式化规范进行比对，实现对关键行为的实时监控与异常响应，适用于安全关键系统。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct rv_monitor`**  \n  定义运行时监控器的回调接口，包括 `enable()` 和 `disable()` 等函数指针，用于挂载/卸载内核追踪点。\n\n- **`struct rv_monitor_def`**  \n  监控器定义结构体，封装 `rv_monitor` 实例及其元数据（如名称、描述、启用状态等）。\n\n- **`struct rv_interface`**  \n  表示 RV 子系统的根接口结构，包含 tracefs 目录项（如 `monitors_dir`）。\n\n- **`task_monitor_slots[]` 与 `task_monitor_count`**  \n  管理 per-task 监控器槽位的位图与计数器，限制同时启用的 per-task 监控器数量（上限为 `RV_PER_TASK_MONITORS`）。\n\n### 主要函数\n\n- **`rv_register_monitor()` / `rv_unregister_monitor()`**  \n  用于向 RV 子系统注册或注销一个监控器。\n\n- **`rv_get_task_monitor_slot()` / `rv_put_task_monitor_slot()`**  \n  分配和释放 per-task 监控器槽位，确保不超过系统限制。\n\n- **`__rv_disable_monitor()` / `rv_disable_monitor()`**  \n  禁用已启用的监控器，可选择是否同步等待所有追踪点执行完成（通过 `tracepoint_synchronize_unregister()`）。\n\n- **`monitor_enable_read_data()`**  \n  实现 tracefs 中每个监控器目录下 `enable` 文件的读取操作，返回当前启用状态（\"0\\n\" 或 \"1\\n\"）。\n\n- **`get_monitors_root()`**  \n  返回 tracefs 中 `monitors/` 目录的 dentry，供其他模块创建子目录使用。\n\n## 3. 关键实现\n\n- **互斥锁保护**  \n  全局互斥锁 `rv_interface_lock` 保护所有监控器注册、启用/禁用及槽位分配操作，确保并发安全。\n\n- **槽位管理机制**  \n  使用位图 `task_monitor_slots[]` 和计数器 `task_monitor_count` 跟踪 per-task 监控器资源使用情况，防止超额分配。\n\n- **同步禁用机制**  \n  在禁用监控器时调用 `tracepoint_synchronize_unregister()`，确保所有 CPU 上的追踪点回调执行完毕后再释放资源，避免竞态导致的数据不一致。\n\n- **tracefs 接口布局**  \n  模仿内核 tracing 子系统的 `events/` 目录结构，在 tracefs 下创建：\n  - `available_monitors`：列出所有已注册监控器\n  - `enabled_monitors`：控制监控器启用/禁用（支持前缀 `!` 禁用和清空禁用全部）\n  - `monitoring_on`：全局开关，暂停所有监控逻辑但不卸载追踪点\n  - `monitors/<name>/`：每个监控器的专属目录，包含 `desc`（描述）和 `enable`（状态控制）文件\n\n- **Lockdep 断言**  \n  关键函数（如槽位分配/释放、监控器禁用）使用 `lockdep_assert_held(&rv_interface_lock)` 确保调用者已持有锁，增强代码健壮性。\n\n## 4. 依赖关系\n\n- **内核追踪子系统**  \n  依赖 tracepoint 机制实现事件注入，使用 `tracepoint_synchronize_unregister()` 进行同步。\n  \n- **tracefs 文件系统**  \n  通过 tracefs 暴露用户接口，依赖 `<linux/fs.h>` 和 dentry 操作。\n\n- **内存管理**  \n  使用 `kmalloc()`/`kfree()`（通过 `rv.h` 中的封装）管理监控器定义结构体内存。\n\n- **模块系统**  \n  作为可加载模块实现（`MODULE_LICENSE(\"GPL\")`），支持动态加载/卸载。\n\n- **RV 子系统头文件**  \n  包含本地头文件 `\"rv.h\"`，定义监控器结构、常量（如 `RV_PER_TASK_MONITORS`）和辅助函数。\n\n- **DA_MON_EVENTS 支持**  \n  若配置 `CONFIG_DA_MON_EVENTS`，则生成 RV 专用追踪点（`<trace/events/rv.h>`）。\n\n## 5. 使用场景\n\n- **形式化验证集成**  \n  作为学术研究（如论文 *Efficient formal verification for the Linux kernel*）的工程实现，将自动机模型与内核实例绑定。\n\n- **实时行为监控**  \n  在安全关键系统（如工业控制、自动驾驶）中监控内核行为是否违反预定义规范（如“禁止在中断上下文中睡眠”）。\n\n- **调试与诊断**  \n  开发者通过启用特定监控器（如 `wip`、`wwnr`）捕获复杂并发 bug 或时序违规。\n\n- **动态策略执行**  \n  用户空间可通过写入 `enabled_monitors` 动态切换监控策略，无需重启系统。\n\n- **资源受限环境**  \n  per-task 监控器槽位限制机制确保 RV 子系统在资源受限设备上可控运行。",
      "similarity": 0.6119800209999084,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 170,
          "end_line": 278,
          "content": [
            "int rv_get_task_monitor_slot(void)",
            "{",
            "\tint i;",
            "",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (task_monitor_count == RV_PER_TASK_MONITORS)",
            "\t\treturn -EBUSY;",
            "",
            "\ttask_monitor_count++;",
            "",
            "\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++) {",
            "\t\tif (task_monitor_slots[i] == false) {",
            "\t\t\ttask_monitor_slots[i] = true;",
            "\t\t\treturn i;",
            "\t\t}",
            "\t}",
            "",
            "\tWARN_ONCE(1, \"RV task_monitor_count and slots are out of sync\\n\");",
            "",
            "\treturn -EINVAL;",
            "}",
            "void rv_put_task_monitor_slot(int slot)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (slot < 0 || slot >= RV_PER_TASK_MONITORS) {",
            "\t\tWARN_ONCE(1, \"RV releasing an invalid slot!: %d\\n\", slot);",
            "\t\treturn;",
            "\t}",
            "",
            "\tWARN_ONCE(!task_monitor_slots[slot], \"RV releasing unused task_monitor_slots: %d\\n\",",
            "\t\t  slot);",
            "",
            "\ttask_monitor_count--;",
            "\ttask_monitor_slots[slot] = false;",
            "}",
            "static ssize_t monitor_enable_read_data(struct file *filp, char __user *user_buf, size_t count,",
            "\t\t\t\t\tloff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tconst char *buff;",
            "",
            "\tbuff = mdef->monitor->enabled ? \"1\\n\" : \"0\\n\";",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff)+1);",
            "}",
            "static int __rv_disable_monitor(struct rv_monitor_def *mdef, bool sync)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (mdef->monitor->enabled) {",
            "\t\tmdef->monitor->enabled = 0;",
            "\t\tmdef->monitor->disable();",
            "",
            "\t\t/*",
            "\t\t * Wait for the execution of all events to finish.",
            "\t\t * Otherwise, the data used by the monitor could",
            "\t\t * be inconsistent. i.e., if the monitor is re-enabled.",
            "\t\t */",
            "\t\tif (sync)",
            "\t\t\ttracepoint_synchronize_unregister();",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "int rv_disable_monitor(struct rv_monitor_def *mdef)",
            "{",
            "\t__rv_disable_monitor(mdef, true);",
            "\treturn 0;",
            "}",
            "int rv_enable_monitor(struct rv_monitor_def *mdef)",
            "{",
            "\tint retval;",
            "",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (mdef->monitor->enabled)",
            "\t\treturn 0;",
            "",
            "\tretval = mdef->monitor->enable();",
            "",
            "\tif (!retval)",
            "\t\tmdef->monitor->enabled = 1;",
            "",
            "\treturn retval;",
            "}",
            "static ssize_t monitor_enable_write_data(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t\t size_t count, loff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tint retval;",
            "\tbool val;",
            "",
            "\tretval = kstrtobool_from_user(user_buf, count, &val);",
            "\tif (retval)",
            "\t\treturn retval;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tif (val)",
            "\t\tretval = rv_enable_monitor(mdef);",
            "\telse",
            "\t\tretval = rv_disable_monitor(mdef);",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "",
            "\treturn retval ? : count;",
            "}"
          ],
          "function_name": "rv_get_task_monitor_slot, rv_put_task_monitor_slot, monitor_enable_read_data, __rv_disable_monitor, rv_disable_monitor, rv_enable_monitor, monitor_enable_write_data",
          "description": "管理任务级监控槽位分配与回收，实现监控启停控制逻辑，通过互斥锁保护监控状态变更并同步跟踪事件处理。",
          "similarity": 0.6747773885726929
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 586,
          "end_line": 710,
          "content": [
            "bool rv_monitoring_on(void)",
            "{",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_rmb();",
            "\treturn READ_ONCE(monitoring_on);",
            "}",
            "static ssize_t monitoring_on_read_data(struct file *filp, char __user *user_buf,",
            "\t\t\t\t       size_t count, loff_t *ppos)",
            "{",
            "\tconst char *buff;",
            "",
            "\tbuff = rv_monitoring_on() ? \"1\\n\" : \"0\\n\";",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);",
            "}",
            "static void turn_monitoring_off(void)",
            "{",
            "\tWRITE_ONCE(monitoring_on, false);",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_wmb();",
            "}",
            "static void reset_all_monitors(void)",
            "{",
            "\tstruct rv_monitor_def *mdef;",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list) {",
            "\t\tif (mdef->monitor->enabled)",
            "\t\t\tmdef->monitor->reset();",
            "\t}",
            "}",
            "static void turn_monitoring_on(void)",
            "{",
            "\tWRITE_ONCE(monitoring_on, true);",
            "\t/* Ensures that concurrent monitors read consistent monitoring_on */",
            "\tsmp_wmb();",
            "}",
            "static void turn_monitoring_on_with_reset(void)",
            "{",
            "\tlockdep_assert_held(&rv_interface_lock);",
            "",
            "\tif (rv_monitoring_on())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Monitors might be out of sync with the system if events were not",
            "\t * processed because of !rv_monitoring_on().",
            "\t *",
            "\t * Reset all monitors, forcing a re-sync.",
            "\t */",
            "\treset_all_monitors();",
            "\tturn_monitoring_on();",
            "}",
            "static ssize_t monitoring_on_write_data(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t\tsize_t count, loff_t *ppos)",
            "{",
            "\tint retval;",
            "\tbool val;",
            "",
            "\tretval = kstrtobool_from_user(user_buf, count, &val);",
            "\tif (retval)",
            "\t\treturn retval;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tif (val)",
            "\t\tturn_monitoring_on_with_reset();",
            "\telse",
            "\t\tturn_monitoring_off();",
            "",
            "\t/*",
            "\t * Wait for the execution of all events to finish",
            "\t * before returning to user-space.",
            "\t */",
            "\ttracepoint_synchronize_unregister();",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "",
            "\treturn count;",
            "}",
            "static void destroy_monitor_dir(struct rv_monitor_def *mdef)",
            "{",
            "\treactor_cleanup_monitor(mdef);",
            "\trv_remove(mdef->root_d);",
            "}",
            "int rv_register_monitor(struct rv_monitor *monitor)",
            "{",
            "\tstruct rv_monitor_def *r;",
            "\tint retval = 0;",
            "",
            "\tif (strlen(monitor->name) >= MAX_RV_MONITOR_NAME_SIZE) {",
            "\t\tpr_info(\"Monitor %s has a name longer than %d\\n\", monitor->name,",
            "\t\t\tMAX_RV_MONITOR_NAME_SIZE);",
            "\t\treturn -1;",
            "\t}",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry(r, &rv_monitors_list, list) {",
            "\t\tif (strcmp(monitor->name, r->monitor->name) == 0) {",
            "\t\t\tpr_info(\"Monitor %s is already registered\\n\", monitor->name);",
            "\t\t\tretval = -1;",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "\t}",
            "",
            "\tr = kzalloc(sizeof(struct rv_monitor_def), GFP_KERNEL);",
            "\tif (!r) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tr->monitor = monitor;",
            "",
            "\tretval = create_monitor_dir(r);",
            "\tif (retval) {",
            "\t\tkfree(r);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tlist_add_tail(&r->list, &rv_monitors_list);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "rv_monitoring_on, monitoring_on_read_data, turn_monitoring_off, reset_all_monitors, turn_monitoring_on, turn_monitoring_on_with_reset, monitoring_on_write_data, destroy_monitor_dir, rv_register_monitor",
          "description": "控制整体监控开关状态，提供监控开关切换接口，包含监控状态同步和异常恢复机制，确保监控器与系统状态一致性。",
          "similarity": 0.645519495010376
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 317,
          "end_line": 459,
          "content": [
            "static ssize_t monitor_desc_read_data(struct file *filp, char __user *user_buf, size_t count,",
            "\t\t\t\t      loff_t *ppos)",
            "{",
            "\tstruct rv_monitor_def *mdef = filp->private_data;",
            "\tchar buff[256];",
            "",
            "\tmemset(buff, 0, sizeof(buff));",
            "",
            "\tsnprintf(buff, sizeof(buff), \"%s\\n\", mdef->monitor->description);",
            "",
            "\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);",
            "}",
            "static int create_monitor_dir(struct rv_monitor_def *mdef)",
            "{",
            "\tstruct dentry *root = get_monitors_root();",
            "\tconst char *name = mdef->monitor->name;",
            "\tstruct dentry *tmp;",
            "\tint retval;",
            "",
            "\tmdef->root_d = rv_create_dir(name, root);",
            "\tif (!mdef->root_d)",
            "\t\treturn -ENOMEM;",
            "",
            "\ttmp = rv_create_file(\"enable\", RV_MODE_WRITE, mdef->root_d, mdef, &interface_enable_fops);",
            "\tif (!tmp) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_remove_root;",
            "\t}",
            "",
            "\ttmp = rv_create_file(\"desc\", RV_MODE_READ, mdef->root_d, mdef, &interface_desc_fops);",
            "\tif (!tmp) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_remove_root;",
            "\t}",
            "",
            "\tretval = reactor_populate_monitor(mdef);",
            "\tif (retval)",
            "\t\tgoto out_remove_root;",
            "",
            "\treturn 0;",
            "",
            "out_remove_root:",
            "\trv_remove(mdef->root_d);",
            "\treturn retval;",
            "}",
            "static int monitors_show(struct seq_file *m, void *p)",
            "{",
            "\tstruct rv_monitor_def *mon_def = p;",
            "",
            "\tseq_printf(m, \"%s\\n\", mon_def->monitor->name);",
            "\treturn 0;",
            "}",
            "static void monitors_stop(struct seq_file *m, void *p)",
            "{",
            "\tmutex_unlock(&rv_interface_lock);",
            "}",
            "static int available_monitors_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn seq_open(file, &available_monitors_seq_ops);",
            "};",
            "static void disable_all_monitors(void)",
            "{",
            "\tstruct rv_monitor_def *mdef;",
            "\tint enabled = 0;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list)",
            "\t\tenabled += __rv_disable_monitor(mdef, false);",
            "",
            "\tif (enabled) {",
            "\t\t/*",
            "\t\t * Wait for the execution of all events to finish.",
            "\t\t * Otherwise, the data used by the monitor could",
            "\t\t * be inconsistent. i.e., if the monitor is re-enabled.",
            "\t\t */",
            "\t\ttracepoint_synchronize_unregister();",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "}",
            "static int enabled_monitors_open(struct inode *inode, struct file *file)",
            "{",
            "\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC))",
            "\t\tdisable_all_monitors();",
            "",
            "\treturn seq_open(file, &enabled_monitors_seq_ops);",
            "};",
            "static ssize_t enabled_monitors_write(struct file *filp, const char __user *user_buf,",
            "\t\t\t\t      size_t count, loff_t *ppos)",
            "{",
            "\tchar buff[MAX_RV_MONITOR_NAME_SIZE + 2];",
            "\tstruct rv_monitor_def *mdef;",
            "\tint retval = -EINVAL;",
            "\tbool enable = true;",
            "\tchar *ptr;",
            "\tint len;",
            "",
            "\tif (count < 1 || count > MAX_RV_MONITOR_NAME_SIZE + 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tmemset(buff, 0, sizeof(buff));",
            "",
            "\tretval = simple_write_to_buffer(buff, sizeof(buff) - 1, ppos, user_buf, count);",
            "\tif (retval < 0)",
            "\t\treturn -EFAULT;",
            "",
            "\tptr = strim(buff);",
            "",
            "\tif (ptr[0] == '!') {",
            "\t\tenable = false;",
            "\t\tptr++;",
            "\t}",
            "",
            "\tlen = strlen(ptr);",
            "\tif (!len)",
            "\t\treturn count;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tretval = -EINVAL;",
            "",
            "\tlist_for_each_entry(mdef, &rv_monitors_list, list) {",
            "\t\tif (strcmp(ptr, mdef->monitor->name) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Monitor found!",
            "\t\t */",
            "\t\tif (enable)",
            "\t\t\tretval = rv_enable_monitor(mdef);",
            "\t\telse",
            "\t\t\tretval = rv_disable_monitor(mdef);",
            "",
            "\t\tif (!retval)",
            "\t\t\tretval = count;",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "monitor_desc_read_data, create_monitor_dir, monitors_show, monitors_stop, available_monitors_open, disable_all_monitors, enabled_monitors_open, enabled_monitors_write",
          "description": "创建监控专用目录结构，实现监控描述信息读取和可用监控列表展示，支持动态监控使能状态管理和全局禁用操作。",
          "similarity": 0.6432343125343323
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 742,
          "end_line": 798,
          "content": [
            "int rv_unregister_monitor(struct rv_monitor *monitor)",
            "{",
            "\tstruct rv_monitor_def *ptr, *next;",
            "",
            "\tmutex_lock(&rv_interface_lock);",
            "",
            "\tlist_for_each_entry_safe(ptr, next, &rv_monitors_list, list) {",
            "\t\tif (strcmp(monitor->name, ptr->monitor->name) == 0) {",
            "\t\t\trv_disable_monitor(ptr);",
            "\t\t\tlist_del(&ptr->list);",
            "\t\t\tdestroy_monitor_dir(ptr);",
            "\t\t}",
            "\t}",
            "",
            "\tmutex_unlock(&rv_interface_lock);",
            "\treturn 0;",
            "}",
            "int __init rv_init_interface(void)",
            "{",
            "\tstruct dentry *tmp;",
            "\tint retval;",
            "",
            "\trv_root.root_dir = rv_create_dir(\"rv\", NULL);",
            "\tif (!rv_root.root_dir)",
            "\t\tgoto out_err;",
            "",
            "\trv_root.monitors_dir = rv_create_dir(\"monitors\", rv_root.root_dir);",
            "\tif (!rv_root.monitors_dir)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"available_monitors\", RV_MODE_READ, rv_root.root_dir, NULL,",
            "\t\t\t     &available_monitors_ops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"enabled_monitors\", RV_MODE_WRITE, rv_root.root_dir, NULL,",
            "\t\t\t     &enabled_monitors_ops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "",
            "\ttmp = rv_create_file(\"monitoring_on\", RV_MODE_WRITE, rv_root.root_dir, NULL,",
            "\t\t\t     &monitoring_on_fops);",
            "\tif (!tmp)",
            "\t\tgoto out_err;",
            "\tretval = init_rv_reactors(rv_root.root_dir);",
            "\tif (retval)",
            "\t\tgoto out_err;",
            "",
            "\tturn_monitoring_on();",
            "",
            "\treturn 0;",
            "",
            "out_err:",
            "\trv_remove(rv_root.root_dir);",
            "\tprintk(KERN_ERR \"RV: Error while creating the RV interface\\n\");",
            "\treturn 1;",
            "}"
          ],
          "function_name": "rv_unregister_monitor, rv_init_interface",
          "description": "实现监控器注册注销流程，完成RV接口初始化，建立监控管理核心结构并注册基础控制接口，处理初始化失败时的资源清理。",
          "similarity": 0.6128739714622498
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/rv/rv.c",
          "start_line": 1,
          "end_line": 169,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2019-2022 Red Hat, Inc. Daniel Bristot de Oliveira <bristot@kernel.org>",
            " *",
            " * This is the online Runtime Verification (RV) interface.",
            " *",
            " * RV is a lightweight (yet rigorous) method that complements classical",
            " * exhaustive verification techniques (such as model checking and",
            " * theorem proving) with a more practical approach to complex systems.",
            " *",
            " * RV works by analyzing the trace of the system's actual execution,",
            " * comparing it against a formal specification of the system behavior.",
            " * RV can give precise information on the runtime behavior of the",
            " * monitored system while enabling the reaction for unexpected",
            " * events, avoiding, for example, the propagation of a failure on",
            " * safety-critical systems.",
            " *",
            " * The development of this interface roots in the development of the",
            " * paper:",
            " *",
            " * De Oliveira, Daniel Bristot; Cucinotta, Tommaso; De Oliveira, Romulo",
            " * Silva. Efficient formal verification for the Linux kernel. In:",
            " * International Conference on Software Engineering and Formal Methods.",
            " * Springer, Cham, 2019. p. 315-332.",
            " *",
            " * And:",
            " *",
            " * De Oliveira, Daniel Bristot, et al. Automata-based formal analysis",
            " * and verification of the real-time Linux kernel. PhD Thesis, 2020.",
            " *",
            " * == Runtime monitor interface ==",
            " *",
            " * A monitor is the central part of the runtime verification of a system.",
            " *",
            " * The monitor stands in between the formal specification of the desired",
            " * (or undesired) behavior, and the trace of the actual system.",
            " *",
            " * In Linux terms, the runtime verification monitors are encapsulated",
            " * inside the \"RV monitor\" abstraction. A RV monitor includes a reference",
            " * model of the system, a set of instances of the monitor (per-cpu monitor,",
            " * per-task monitor, and so on), and the helper functions that glue the",
            " * monitor to the system via trace. Generally, a monitor includes some form",
            " * of trace output as a reaction for event parsing and exceptions,",
            " * as depicted bellow:",
            " *",
            " * Linux  +----- RV Monitor ----------------------------------+ Formal",
            " *  Realm |                                                   |  Realm",
            " *  +-------------------+     +----------------+     +-----------------+",
            " *  |   Linux kernel    |     |     Monitor    |     |     Reference   |",
            " *  |     Tracing       |  -> |   Instance(s)  | <-  |       Model     |",
            " *  | (instrumentation) |     | (verification) |     | (specification) |",
            " *  +-------------------+     +----------------+     +-----------------+",
            " *         |                          |                       |",
            " *         |                          V                       |",
            " *         |                     +----------+                 |",
            " *         |                     | Reaction |                 |",
            " *         |                     +--+--+--+-+                 |",
            " *         |                        |  |  |                   |",
            " *         |                        |  |  +-> trace output ?  |",
            " *         +------------------------|--|----------------------+",
            " *                                  |  +----> panic ?",
            " *                                  +-------> <user-specified>",
            " *",
            " * This file implements the interface for loading RV monitors, and",
            " * to control the verification session.",
            " *",
            " * == Registering monitors ==",
            " *",
            " * The struct rv_monitor defines a set of callback functions to control",
            " * a verification session. For instance, when a given monitor is enabled,",
            " * the \"enable\" callback function is called to hook the instrumentation",
            " * functions to the kernel trace events. The \"disable\" function is called",
            " * when disabling the verification session.",
            " *",
            " * A RV monitor is registered via:",
            " *   int rv_register_monitor(struct rv_monitor *monitor);",
            " * And unregistered via:",
            " *   int rv_unregister_monitor(struct rv_monitor *monitor);",
            " *",
            " * == User interface ==",
            " *",
            " * The user interface resembles kernel tracing interface. It presents",
            " * these files:",
            " *",
            " *  \"available_monitors\"",
            " *    - List the available monitors, one per line.",
            " *",
            " *    For example:",
            " *      # cat available_monitors",
            " *      wip",
            " *      wwnr",
            " *",
            " *  \"enabled_monitors\"",
            " *    - Lists the enabled monitors, one per line;",
            " *    - Writing to it enables a given monitor;",
            " *    - Writing a monitor name with a '!' prefix disables it;",
            " *    - Truncating the file disables all enabled monitors.",
            " *",
            " *    For example:",
            " *      # cat enabled_monitors",
            " *      # echo wip > enabled_monitors",
            " *      # echo wwnr >> enabled_monitors",
            " *      # cat enabled_monitors",
            " *      wip",
            " *      wwnr",
            " *      # echo '!wip' >> enabled_monitors",
            " *      # cat enabled_monitors",
            " *      wwnr",
            " *      # echo > enabled_monitors",
            " *      # cat enabled_monitors",
            " *      #",
            " *",
            " *    Note that more than one monitor can be enabled concurrently.",
            " *",
            " *  \"monitoring_on\"",
            " *    - It is an on/off general switcher for monitoring. Note",
            " *    that it does not disable enabled monitors or detach events,",
            " *    but stops the per-entity monitors from monitoring the events",
            " *    received from the instrumentation. It resembles the \"tracing_on\"",
            " *    switcher.",
            " *",
            " *  \"monitors/\"",
            " *    Each monitor will have its own directory inside \"monitors/\". There",
            " *    the monitor specific files will be presented.",
            " *    The \"monitors/\" directory resembles the \"events\" directory on",
            " *    tracefs.",
            " *",
            " *    For example:",
            " *      # cd monitors/wip/",
            " *      # ls",
            " *      desc  enable",
            " *      # cat desc",
            " *      auto-generated wakeup in preemptive monitor.",
            " *      # cat enable",
            " *      0",
            " *",
            " *  For further information, see:",
            " *   Documentation/trace/rv/runtime-verification.rst",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "",
            "#ifdef CONFIG_DA_MON_EVENTS",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/rv.h>",
            "#endif",
            "",
            "#include \"rv.h\"",
            "",
            "DEFINE_MUTEX(rv_interface_lock);",
            "",
            "static struct rv_interface rv_root;",
            "",
            "struct dentry *get_monitors_root(void)",
            "{",
            "\treturn rv_root.monitors_dir;",
            "}",
            "",
            "/*",
            " * Interface for the monitor register.",
            " */",
            "static LIST_HEAD(rv_monitors_list);",
            "",
            "static int task_monitor_count;",
            "static bool task_monitor_slots[RV_PER_TASK_MONITORS];",
            ""
          ],
          "function_name": null,
          "description": "定义RV监控接口的基础结构，包括互斥锁、全局监控根节点及监控列表，为后续监控注册和管理提供基础设施。",
          "similarity": 0.5679820775985718
        }
      ]
    },
    {
      "source_file": "kernel/module/tracking.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:08:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\tracking.c`\n\n---\n\n# module/tracking.c 技术文档\n\n## 1. 文件概述\n\n`module/tracking.c` 实现了对已卸载但带有污染标记（tainted）的内核模块的跟踪机制。该功能用于记录那些在卸载时已被标记为“污染”（tainted）的模块信息，包括模块名称、污染标志类型以及重复卸载的次数。这些信息可用于内核调试、安全审计或故障分析，帮助开发者识别可能导致系统不稳定或不可信状态的模块行为。\n\n## 2. 核心功能\n\n### 数据结构\n- `struct mod_unload_taint`（定义在 `internal.h` 中）：\n  - `name`：模块名称（最多 `MODULE_NAME_LEN` 字节）\n  - `taints`：模块的污染标志位掩码\n  - `count`：该模块（同名且污染标志有交集）被卸载的次数\n  - `list`：用于链入全局链表 `unloaded_tainted_modules`\n\n### 全局变量\n- `unloaded_tainted_modules`：全局 RCU 保护的链表头，存储所有已卸载的污染模块记录\n- `mod_debugfs_root`：外部声明的 debugfs 根目录入口（由模块子系统提供）\n\n### 主要函数\n- `try_add_tainted_module(struct module *mod)`  \n  尝试将带有污染标志的模块添加到跟踪列表中。若同名模块且污染标志有重叠，则仅递增计数；否则分配新条目并加入链表。\n\n- `print_unloaded_tainted_modules(void)`  \n  在内核日志中打印所有已跟踪的卸载污染模块信息，格式为：`模块名(污染标志):计数`。\n\n- `unloaded_tainted_modules_seq_*` 系列函数（仅当 `CONFIG_DEBUG_FS` 启用时）  \n  实现 debugfs 接口 `/sys/kernel/debug/modules/unloaded_tainted`，以 seq_file 方式暴露跟踪数据。\n\n- `unloaded_tainted_modules_init(void)`  \n  模块初始化函数，注册 debugfs 文件。\n\n## 3. 关键实现\n\n### 污染模块去重与计数逻辑\n- 在 `try_add_tainted_module()` 中，通过遍历 `unloaded_tainted_modules` 链表，检查是否存在**同名**且**污染标志有交集**（`mod_taint->taints & mod->taints`）的条目。\n- 若存在，则仅将 `count` 字段加一，避免重复记录相同污染行为。\n- 若不存在，则分配新 `mod_unload_taint` 结构体，拷贝模块名和污染标志，并初始化 `count` 为 1，然后通过 `list_add_rcu()` 安全加入链表。\n\n### 并发安全机制\n- 所有链表遍历操作均使用 **RCU（Read-Copy-Update）** 机制保护：\n  - 写操作（如 `list_add_rcu`）在持有 `module_mutex` 时执行（由 `module_assert_mutex_or_preempt()` 保证）\n  - 读操作（如 `print_unloaded_tainted_modules` 和 debugfs 序列化函数）使用 `rcu_read_lock()` / `rcu_read_unlock()`\n- `list_for_each_entry_rcu` 宏配合 `lockdep_is_held(&module_mutex)` 提供锁依赖检查，确保正确性。\n\n### DebugFS 接口实现\n- 使用标准 `seq_file` 接口实现高效、可分页的文件读取。\n- `unloaded_tainted_modules_seq_start/next/stop` 封装了 RCU 读端临界区。\n- `unloaded_tainted_modules_seq_show` 调用 `module_flags_taint()` 将污染位掩码转换为可读字符串（如 \"P\", \"O\", \"E\" 等）。\n\n### 内存管理\n- 动态分配 `mod_unload_taint` 结构体使用 `kmalloc(..., GFP_KERNEL)`，失败时返回 `-ENOMEM`。\n- 条目一旦加入链表，其生命周期由 RCU 机制管理，但当前代码未实现显式释放（通常在系统关机或模块子系统清理时处理）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：模块核心定义、`module_mutex`、污染标志相关 API\n  - `<linux/rculist.h>`：RCU 安全的链表操作\n  - `<linux/debugfs.h>`：debugfs 文件系统支持\n  - `\"internal.h\"`：包含 `struct mod_unload_taint` 定义及 `module_flags_taint()` 声明\n\n- **外部符号**：\n  - `mod_debugfs_root`：由 `kernel/module.c` 导出，作为模块子系统的 debugfs 根目录\n  - `module_flags_taint()`：在 `kernel/module.c` 中实现，用于将污染位转换为字符串\n\n- **配置依赖**：\n  - `CONFIG_DEBUG_FS`：控制是否编译 debugfs 接口\n\n## 5. 使用场景\n\n- **内核崩溃或错误诊断**：当系统出现异常时，可通过 `print_unloaded_tainted_modules()` 输出或 debugfs 文件查看历史上卸载的污染模块，辅助定位问题根源。\n- **安全审计**：系统管理员可通过 `/sys/kernel/debug/modules/unloaded_tainted` 监控是否有加载过带污染标志（如专有模块、强制加载等）的模块，即使这些模块已被卸载。\n- **内核测试与验证**：在自动化测试中，可验证模块污染行为是否被正确记录和跟踪。\n- **模块生命周期分析**：结合其他跟踪机制，分析模块加载/卸载模式及其对系统可信状态的影响。",
      "similarity": 0.5991665124893188,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/tracking.c",
          "start_line": 20,
          "end_line": 95,
          "content": [
            "int try_add_tainted_module(struct module *mod)",
            "{",
            "\tstruct mod_unload_taint *mod_taint;",
            "",
            "\tmodule_assert_mutex_or_preempt();",
            "",
            "\tif (!mod->taints)",
            "\t\tgoto out;",
            "",
            "\tlist_for_each_entry_rcu(mod_taint, &unloaded_tainted_modules, list,",
            "\t\t\t\tlockdep_is_held(&module_mutex)) {",
            "\t\tif (!strcmp(mod_taint->name, mod->name) &&",
            "\t\t    mod_taint->taints & mod->taints) {",
            "\t\t\tmod_taint->count++;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tmod_taint = kmalloc(sizeof(*mod_taint), GFP_KERNEL);",
            "\tif (unlikely(!mod_taint))",
            "\t\treturn -ENOMEM;",
            "\tstrscpy(mod_taint->name, mod->name, MODULE_NAME_LEN);",
            "\tmod_taint->taints = mod->taints;",
            "\tlist_add_rcu(&mod_taint->list, &unloaded_tainted_modules);",
            "\tmod_taint->count = 1;",
            "out:",
            "\treturn 0;",
            "}",
            "void print_unloaded_tainted_modules(void)",
            "{",
            "\tstruct mod_unload_taint *mod_taint;",
            "\tchar buf[MODULE_FLAGS_BUF_SIZE];",
            "",
            "\tif (!list_empty(&unloaded_tainted_modules)) {",
            "\t\tprintk(KERN_DEFAULT \"Unloaded tainted modules:\");",
            "\t\tlist_for_each_entry_rcu(mod_taint, &unloaded_tainted_modules,",
            "\t\t\t\t\tlist) {",
            "\t\t\tsize_t l;",
            "",
            "\t\t\tl = module_flags_taint(mod_taint->taints, buf);",
            "\t\t\tbuf[l++] = '\\0';",
            "\t\t\tpr_cont(\" %s(%s):%llu\", mod_taint->name, buf,",
            "\t\t\t\tmod_taint->count);",
            "\t\t}",
            "\t}",
            "}",
            "static void unloaded_tainted_modules_seq_stop(struct seq_file *m, void *p)",
            "\t__releases(rcu)",
            "{",
            "\trcu_read_unlock();",
            "}",
            "static int unloaded_tainted_modules_seq_show(struct seq_file *m, void *p)",
            "{",
            "\tstruct mod_unload_taint *mod_taint;",
            "\tchar buf[MODULE_FLAGS_BUF_SIZE];",
            "\tsize_t l;",
            "",
            "\tmod_taint = list_entry(p, struct mod_unload_taint, list);",
            "\tl = module_flags_taint(mod_taint->taints, buf);",
            "\tbuf[l++] = '\\0';",
            "",
            "\tseq_printf(m, \"%s (%s) %llu\", mod_taint->name, buf, mod_taint->count);",
            "\tseq_puts(m, \"\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static int unloaded_tainted_modules_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn seq_open(file, &unloaded_tainted_modules_seq_ops);",
            "}",
            "static int __init unloaded_tainted_modules_init(void)",
            "{",
            "\tdebugfs_create_file(\"unloaded_tainted\", 0444, mod_debugfs_root, NULL,",
            "\t\t\t    &unloaded_tainted_modules_fops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "try_add_tainted_module, print_unloaded_tainted_modules, unloaded_tainted_modules_seq_stop, unloaded_tainted_modules_seq_show, unloaded_tainted_modules_open, unloaded_tainted_modules_init",
          "description": "实现污点模块追踪功能，包含添加污点模块记录、遍历打印污点模块信息、调试文件系统接口注册等，核心功能是维护和展示卸载模块的污点状态",
          "similarity": 0.6213290691375732
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/tracking.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module taint unload tracking support",
            " *",
            " * Copyright (C) 2022 Aaron Tomlin",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/rculist.h>",
            "#include \"internal.h\"",
            "",
            "static LIST_HEAD(unloaded_tainted_modules);",
            "extern struct dentry *mod_debugfs_root;",
            ""
          ],
          "function_name": null,
          "description": "定义用于跟踪卸载污点模块的链表头及调试文件系统根目录引用，核心功能是管理卸载模块的污点状态数据结构",
          "similarity": 0.5704115629196167
        }
      ]
    },
    {
      "source_file": "mm/damon/vaddr.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:53:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `damon\\vaddr.c`\n\n---\n\n# `damon/vaddr.c` 技术文档\n\n## 1. 文件概述\n\n`damon/vaddr.c` 是 Linux 内核中 DAMON（Data Access MONitor）子系统的一部分，专门用于在**虚拟地址空间**（Virtual Address Space）上实现监控原语。该文件提供了针对进程虚拟内存布局的区域初始化、内存映射分析以及与页表和 VMA（Virtual Memory Area）交互的核心逻辑，旨在高效地将复杂的虚拟地址空间抽象为少量可监控的区域，从而降低监控开销并提升适应性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`damon_get_task_struct()`**  \n  根据 `damon_target` 中保存的 `pid` 获取对应的 `task_struct`，并增加其引用计数。\n\n- **`damon_get_mm()`**  \n  获取目标进程的 `mm_struct`（内存描述符），调用者需在使用后调用 `mmput()` 释放。\n\n- **`damon_va_evenly_split_region()`**  \n  将一个 DAMON 监控区域均匀分割为指定数量的小区域，每个小区域大小对齐到 `DAMON_MIN_REGION`。\n\n- **`__damon_va_three_regions()`**  \n  在给定的 `mm_struct` 中扫描 VMA，找出两个最大的未映射间隙（unmapped gaps），并据此划分出三个覆盖所有已映射区域的地址范围。\n\n- **`damon_va_three_regions()`**  \n  封装 `__damon_va_three_regions()`，负责获取目标进程的内存上下文并加读锁后调用。\n\n- **`__damon_va_init_regions()`**  \n  为指定的监控目标（进程）初始化三个初始监控区域，并根据配置进一步细分为多个子区域。\n\n- **`damon_va_init()`**  \n  （代码截断，但意图明确）遍历 DAMON 上下文中的所有目标，为每个目标调用 `__damon_va_init_regions()` 进行初始化。\n\n### 关键数据结构\n\n- **`struct damon_target`**  \n  表示一个被监控的目标（通常是一个进程），包含 `pid` 指针等信息。\n\n- **`struct damon_region`**  \n  DAMON 监控的基本单位，表示一段连续的虚拟地址区间（`ar.start` 到 `ar.end`）。\n\n- **`struct damon_addr_range`**  \n  简单的地址范围结构，用于临时存储起止地址。\n\n## 3. 关键实现\n\n### 三区域划分算法（Three-Region Heuristic）\n\n该文件的核心思想是：**避免直接监控整个虚拟地址空间**（含大量未映射区域）。为此，采用启发式方法：\n\n1. 遍历进程的 VMA 链表（通过 `VMA_ITERATOR` 和 RCU 读锁安全访问）。\n2. 记录所有相邻 VMA 之间的间隙（`gap = vma->vm_start - prev->vm_end`）。\n3. 找出**两个最大的间隙**（`first_gap` 和 `second_gap`）。\n4. 将整个已映射地址空间划分为三个区域：\n   - 区域0：从第一个 VMA 起始地址到第一个大间隙的开始\n   - 区域1：从第一个大间隙结束到第二个大间隙开始\n   - 区域2：从第二个大间隙结束到最后一个 VMA 结束地址\n5. 所有边界对齐到 `DAMON_MIN_REGION`（通常为页大小或更大）。\n\n此方法有效跳过了堆与 mmap 区之间、mmap 区与栈之间的巨大空洞，显著减少无效监控区域。\n\n### 区域细分策略\n\n初始化的三个大区域会根据 DAMON 上下文配置的 `min_nr_regions` 进一步细分：\n- 计算平均区域大小：`总监控大小 / min_nr_regions`\n- 若计算结果小于 `DAMON_MIN_REGION`，则使用后者作为最小粒度\n- 调用 `damon_va_evenly_split_region()` 将每个大区域均匀切分为若干子区域\n\n这确保了初始监控粒度既不过粗（丢失细节），也不过细（开销过大）。\n\n### 内存安全与同步\n\n- 使用 `mmap_read_lock()`/`mmap_read_unlock()` 保护 VMA 遍历，兼容并发内存映射变更。\n- 通过 `get_task_mm()` 安全获取 `mm_struct`，防止进程退出导致悬空指针。\n- 所有 `mm_struct` 和 `task_struct` 的引用均正确配对（`get`/`put`）。\n\n## 4. 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/mm.h>` 相关：`hugetlb.h`, `highmem.h`, `page_idle.h`, `pagewalk.h`, `sched/mm.h`\n  - `<linux/mmu_notifier.h>`：用于内存映射变更通知（虽未直接使用，但为 DAMON 整体架构所需）\n  - `<asm-generic/mman-common.h>`：内存管理常量\n- **DAMON 内部依赖**：\n  - `\"ops-common.h\"`：提供 `damon_new_region()`, `damon_add_region()` 等通用操作\n  - 依赖 DAMON 核心框架的 `damon_ctx`, `damon_target`, `damon_region` 等结构定义\n- **KUnit 测试支持**：\n  - `CONFIG_DAMON_VADDR_KUNIT_TEST` 宏用于测试时调整 `DAMON_MIN_REGION` 为 1，便于验证逻辑\n\n## 5. 使用场景\n\n- **DAMON 虚拟地址监控模式初始化**：当用户通过 DAMON 接口（如 debugfs 或 tracepoint）启动对一组进程的内存访问模式监控时，DAMON 核心调用 `damon_va_init()` 为每个目标进程构建初始监控区域。\n- **内存优化工具基础**：为 `damo`（DAMON 用户空间工具）等提供底层支持，用于识别冷热内存、指导内存回收（如 `reclaim`）、透明大页（THP）优化等。\n- **低开销内存行为分析**：适用于需要长期、低性能影响地监控进程内存访问模式的场景，如云环境中的资源调度、性能剖析等。\n- **自适应内存监控起点**：所生成的初始区域将作为 DAMON 自适应区域调整机制（合并/分裂）的起点，在后续监控周期中动态优化区域划分。",
      "similarity": 0.5776453614234924,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 64,
          "end_line": 170,
          "content": [
            "static int damon_va_evenly_split_region(struct damon_target *t,",
            "\t\tstruct damon_region *r, unsigned int nr_pieces)",
            "{",
            "\tunsigned long sz_orig, sz_piece, orig_end;",
            "\tstruct damon_region *n = NULL, *next;",
            "\tunsigned long start;",
            "\tunsigned int i;",
            "",
            "\tif (!r || !nr_pieces)",
            "\t\treturn -EINVAL;",
            "",
            "\torig_end = r->ar.end;",
            "\tsz_orig = damon_sz_region(r);",
            "\tsz_piece = ALIGN_DOWN(sz_orig / nr_pieces, DAMON_MIN_REGION);",
            "",
            "\tif (!sz_piece)",
            "\t\treturn -EINVAL;",
            "",
            "\tr->ar.end = r->ar.start + sz_piece;",
            "\tnext = damon_next_region(r);",
            "\tfor (start = r->ar.end, i = 1; i < nr_pieces; start += sz_piece, i++) {",
            "\t\tn = damon_new_region(start, start + sz_piece);",
            "\t\tif (!n)",
            "\t\t\treturn -ENOMEM;",
            "\t\tdamon_insert_region(n, r, next, t);",
            "\t\tr = n;",
            "\t}",
            "\t/* complement last region for possible rounding error */",
            "\tif (n)",
            "\t\tn->ar.end = orig_end;",
            "",
            "\treturn 0;",
            "}",
            "static unsigned long sz_range(struct damon_addr_range *r)",
            "{",
            "\treturn r->end - r->start;",
            "}",
            "static int __damon_va_three_regions(struct mm_struct *mm,",
            "\t\t\t\t       struct damon_addr_range regions[3])",
            "{",
            "\tstruct damon_addr_range first_gap = {0}, second_gap = {0};",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "\tstruct vm_area_struct *vma, *prev = NULL;",
            "\tunsigned long start;",
            "",
            "\t/*",
            "\t * Find the two biggest gaps so that first_gap > second_gap > others.",
            "\t * If this is too slow, it can be optimised to examine the maple",
            "\t * tree gaps.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_vma(vmi, vma) {",
            "\t\tunsigned long gap;",
            "",
            "\t\tif (!prev) {",
            "\t\t\tstart = vma->vm_start;",
            "\t\t\tgoto next;",
            "\t\t}",
            "\t\tgap = vma->vm_start - prev->vm_end;",
            "",
            "\t\tif (gap > sz_range(&first_gap)) {",
            "\t\t\tsecond_gap = first_gap;",
            "\t\t\tfirst_gap.start = prev->vm_end;",
            "\t\t\tfirst_gap.end = vma->vm_start;",
            "\t\t} else if (gap > sz_range(&second_gap)) {",
            "\t\t\tsecond_gap.start = prev->vm_end;",
            "\t\t\tsecond_gap.end = vma->vm_start;",
            "\t\t}",
            "next:",
            "\t\tprev = vma;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\tif (!sz_range(&second_gap) || !sz_range(&first_gap))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Sort the two biggest gaps by address */",
            "\tif (first_gap.start > second_gap.start)",
            "\t\tswap(first_gap, second_gap);",
            "",
            "\t/* Store the result */",
            "\tregions[0].start = ALIGN(start, DAMON_MIN_REGION);",
            "\tregions[0].end = ALIGN(first_gap.start, DAMON_MIN_REGION);",
            "\tregions[1].start = ALIGN(first_gap.end, DAMON_MIN_REGION);",
            "\tregions[1].end = ALIGN(second_gap.start, DAMON_MIN_REGION);",
            "\tregions[2].start = ALIGN(second_gap.end, DAMON_MIN_REGION);",
            "\tregions[2].end = ALIGN(prev->vm_end, DAMON_MIN_REGION);",
            "",
            "\treturn 0;",
            "}",
            "static int damon_va_three_regions(struct damon_target *t,",
            "\t\t\t\tstruct damon_addr_range regions[3])",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint rc;",
            "",
            "\tmm = damon_get_mm(t);",
            "\tif (!mm)",
            "\t\treturn -EINVAL;",
            "",
            "\tmmap_read_lock(mm);",
            "\trc = __damon_va_three_regions(mm, regions);",
            "\tmmap_read_unlock(mm);",
            "",
            "\tmmput(mm);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "damon_va_evenly_split_region, sz_range, __damon_va_three_regions, damon_va_three_regions",
          "description": "实现将监控区域均分、计算范围大小及寻找最大空闲间隙的函数，核心功能是通过遍历VMA找到两个最大空闲区间用于后续监控区域划分。",
          "similarity": 0.6134518384933472
        },
        {
          "chunk_id": 2,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 235,
          "end_line": 358,
          "content": [
            "static void __damon_va_init_regions(struct damon_ctx *ctx,",
            "\t\t\t\t     struct damon_target *t)",
            "{",
            "\tstruct damon_target *ti;",
            "\tstruct damon_region *r;",
            "\tstruct damon_addr_range regions[3];",
            "\tunsigned long sz = 0, nr_pieces;",
            "\tint i, tidx = 0;",
            "",
            "\tif (damon_va_three_regions(t, regions)) {",
            "\t\tdamon_for_each_target(ti, ctx) {",
            "\t\t\tif (ti == t)",
            "\t\t\t\tbreak;",
            "\t\t\ttidx++;",
            "\t\t}",
            "\t\tpr_debug(\"Failed to get three regions of %dth target\\n\", tidx);",
            "\t\treturn;",
            "\t}",
            "",
            "\tfor (i = 0; i < 3; i++)",
            "\t\tsz += regions[i].end - regions[i].start;",
            "\tif (ctx->attrs.min_nr_regions)",
            "\t\tsz /= ctx->attrs.min_nr_regions;",
            "\tif (sz < DAMON_MIN_REGION)",
            "\t\tsz = DAMON_MIN_REGION;",
            "",
            "\t/* Set the initial three regions of the target */",
            "\tfor (i = 0; i < 3; i++) {",
            "\t\tr = damon_new_region(regions[i].start, regions[i].end);",
            "\t\tif (!r) {",
            "\t\t\tpr_err(\"%d'th init region creation failed\\n\", i);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tdamon_add_region(r, t);",
            "",
            "\t\tnr_pieces = (regions[i].end - regions[i].start) / sz;",
            "\t\tdamon_va_evenly_split_region(t, r, nr_pieces);",
            "\t}",
            "}",
            "static void damon_va_init(struct damon_ctx *ctx)",
            "{",
            "\tstruct damon_target *t;",
            "",
            "\tdamon_for_each_target(t, ctx) {",
            "\t\t/* the user may set the target regions as they want */",
            "\t\tif (!damon_nr_regions(t))",
            "\t\t\t__damon_va_init_regions(ctx, t);",
            "\t}",
            "}",
            "static void damon_va_update(struct damon_ctx *ctx)",
            "{",
            "\tstruct damon_addr_range three_regions[3];",
            "\tstruct damon_target *t;",
            "",
            "\tdamon_for_each_target(t, ctx) {",
            "\t\tif (damon_va_three_regions(t, three_regions))",
            "\t\t\tcontinue;",
            "\t\tdamon_set_regions(t, three_regions, 3);",
            "\t}",
            "}",
            "static int damon_mkold_pmd_entry(pmd_t *pmd, unsigned long addr,",
            "\t\tunsigned long next, struct mm_walk *walk)",
            "{",
            "\tpte_t *pte;",
            "\tpmd_t pmde;",
            "\tspinlock_t *ptl;",
            "",
            "\tif (pmd_trans_huge(pmdp_get(pmd))) {",
            "\t\tptl = pmd_lock(walk->mm, pmd);",
            "\t\tpmde = pmdp_get(pmd);",
            "",
            "\t\tif (!pmd_present(pmde)) {",
            "\t\t\tspin_unlock(ptl);",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\tif (pmd_trans_huge(pmde)) {",
            "\t\t\tdamon_pmdp_mkold(pmd, walk->vma, addr);",
            "\t\t\tspin_unlock(ptl);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tspin_unlock(ptl);",
            "\t}",
            "",
            "\tpte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);",
            "\tif (!pte) {",
            "\t\twalk->action = ACTION_AGAIN;",
            "\t\treturn 0;",
            "\t}",
            "\tif (!pte_present(ptep_get(pte)))",
            "\t\tgoto out;",
            "\tdamon_ptep_mkold(pte, walk->vma, addr);",
            "out:",
            "\tpte_unmap_unlock(pte, ptl);",
            "\treturn 0;",
            "}",
            "static void damon_hugetlb_mkold(pte_t *pte, struct mm_struct *mm,",
            "\t\t\t\tstruct vm_area_struct *vma, unsigned long addr)",
            "{",
            "\tbool referenced = false;",
            "\tpte_t entry = huge_ptep_get(pte);",
            "\tstruct folio *folio = pfn_folio(pte_pfn(entry));",
            "\tunsigned long psize = huge_page_size(hstate_vma(vma));",
            "",
            "\tfolio_get(folio);",
            "",
            "\tif (pte_young(entry)) {",
            "\t\treferenced = true;",
            "\t\tentry = pte_mkold(entry);",
            "\t\tset_huge_pte_at(mm, addr, pte, entry, psize);",
            "\t}",
            "",
            "#ifdef CONFIG_MMU_NOTIFIER",
            "\tif (mmu_notifier_clear_young(mm, addr,",
            "\t\t\t\t     addr + huge_page_size(hstate_vma(vma))))",
            "\t\treferenced = true;",
            "#endif /* CONFIG_MMU_NOTIFIER */",
            "",
            "\tif (referenced)",
            "\t\tfolio_set_young(folio);",
            "",
            "\tfolio_set_idle(folio);",
            "\tfolio_put(folio);",
            "}"
          ],
          "function_name": "__damon_va_init_regions, damon_va_init, damon_va_update, damon_mkold_pmd_entry, damon_hugetlb_mkold",
          "description": "初始化和更新监控区域的函数，以及处理大页表项的mkold操作，核心功能是构建初始监控区域并维护页面年轻状态标记。",
          "similarity": 0.596602201461792
        },
        {
          "chunk_id": 0,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 1,
          "end_line": 63,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * DAMON Primitives for Virtual Address Spaces",
            " *",
            " * Author: SeongJae Park <sjpark@amazon.de>",
            " */",
            "",
            "#define pr_fmt(fmt) \"damon-va: \" fmt",
            "",
            "#include <asm-generic/mman-common.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/pagewalk.h>",
            "#include <linux/sched/mm.h>",
            "",
            "#include \"ops-common.h\"",
            "",
            "#ifdef CONFIG_DAMON_VADDR_KUNIT_TEST",
            "#undef DAMON_MIN_REGION",
            "#define DAMON_MIN_REGION 1",
            "#endif",
            "",
            "/*",
            " * 't->pid' should be the pointer to the relevant 'struct pid' having reference",
            " * count.  Caller must put the returned task, unless it is NULL.",
            " */",
            "static inline struct task_struct *damon_get_task_struct(struct damon_target *t)",
            "{",
            "\treturn get_pid_task(t->pid, PIDTYPE_PID);",
            "}",
            "",
            "/*",
            " * Get the mm_struct of the given target",
            " *",
            " * Caller _must_ put the mm_struct after use, unless it is NULL.",
            " *",
            " * Returns the mm_struct of the target on success, NULL on failure",
            " */",
            "static struct mm_struct *damon_get_mm(struct damon_target *t)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct mm_struct *mm;",
            "",
            "\ttask = damon_get_task_struct(t);",
            "\tif (!task)",
            "\t\treturn NULL;",
            "",
            "\tmm = get_task_mm(task);",
            "\tput_task_struct(task);",
            "\treturn mm;",
            "}",
            "",
            "/*",
            " * Functions for the initial monitoring target regions construction",
            " */",
            "",
            "/*",
            " * Size-evenly split a region into 'nr_pieces' small regions",
            " *",
            " * Returns 0 on success, or negative error code otherwise.",
            " */"
          ],
          "function_name": null,
          "description": "定义获取进程任务结构体和MM结构体的辅助函数，并声明用于初始监控区域构造的相关函数，核心功能是提供虚拟地址空间监控的基本支持。",
          "similarity": 0.594009518623352
        },
        {
          "chunk_id": 4,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 503,
          "end_line": 605,
          "content": [
            "static int damon_young_hugetlb_entry(pte_t *pte, unsigned long hmask,",
            "\t\t\t\t     unsigned long addr, unsigned long end,",
            "\t\t\t\t     struct mm_walk *walk)",
            "{",
            "\tstruct damon_young_walk_private *priv = walk->private;",
            "\tstruct hstate *h = hstate_vma(walk->vma);",
            "\tstruct folio *folio;",
            "\tspinlock_t *ptl;",
            "\tpte_t entry;",
            "",
            "\tptl = huge_pte_lock(h, walk->mm, pte);",
            "\tentry = huge_ptep_get(pte);",
            "\tif (!pte_present(entry))",
            "\t\tgoto out;",
            "",
            "\tfolio = pfn_folio(pte_pfn(entry));",
            "\tfolio_get(folio);",
            "",
            "\tif (pte_young(entry) || !folio_test_idle(folio) ||",
            "\t    mmu_notifier_test_young(walk->mm, addr))",
            "\t\tpriv->young = true;",
            "\t*priv->folio_sz = huge_page_size(h);",
            "",
            "\tfolio_put(folio);",
            "",
            "out:",
            "\tspin_unlock(ptl);",
            "\treturn 0;",
            "}",
            "static bool damon_va_young(struct mm_struct *mm, unsigned long addr,",
            "\t\tunsigned long *folio_sz)",
            "{",
            "\tstruct damon_young_walk_private arg = {",
            "\t\t.folio_sz = folio_sz,",
            "\t\t.young = false,",
            "\t};",
            "",
            "\tmmap_read_lock(mm);",
            "\twalk_page_range(mm, addr, addr + 1, &damon_young_ops, &arg);",
            "\tmmap_read_unlock(mm);",
            "\treturn arg.young;",
            "}",
            "static void __damon_va_check_access(struct mm_struct *mm,",
            "\t\t\t\tstruct damon_region *r, bool same_target)",
            "{",
            "\tstatic unsigned long last_addr;",
            "\tstatic unsigned long last_folio_sz = PAGE_SIZE;",
            "\tstatic bool last_accessed;",
            "",
            "\t/* If the region is in the last checked page, reuse the result */",
            "\tif (same_target && (ALIGN_DOWN(last_addr, last_folio_sz) ==",
            "\t\t\t\tALIGN_DOWN(r->sampling_addr, last_folio_sz))) {",
            "\t\tif (last_accessed)",
            "\t\t\tr->nr_accesses++;",
            "\t\treturn;",
            "\t}",
            "",
            "\tlast_accessed = damon_va_young(mm, r->sampling_addr, &last_folio_sz);",
            "\tif (last_accessed)",
            "\t\tr->nr_accesses++;",
            "",
            "\tlast_addr = r->sampling_addr;",
            "}",
            "static unsigned int damon_va_check_accesses(struct damon_ctx *ctx)",
            "{",
            "\tstruct damon_target *t;",
            "\tstruct mm_struct *mm;",
            "\tstruct damon_region *r;",
            "\tunsigned int max_nr_accesses = 0;",
            "\tbool same_target;",
            "",
            "\tdamon_for_each_target(t, ctx) {",
            "\t\tmm = damon_get_mm(t);",
            "\t\tif (!mm)",
            "\t\t\tcontinue;",
            "\t\tsame_target = false;",
            "\t\tdamon_for_each_region(r, t) {",
            "\t\t\t__damon_va_check_access(mm, r, same_target);",
            "\t\t\tmax_nr_accesses = max(r->nr_accesses, max_nr_accesses);",
            "\t\t\tsame_target = true;",
            "\t\t}",
            "\t\tmmput(mm);",
            "\t}",
            "",
            "\treturn max_nr_accesses;",
            "}",
            "static bool damon_va_target_valid(struct damon_target *t)",
            "{",
            "\tstruct task_struct *task;",
            "",
            "\ttask = damon_get_task_struct(t);",
            "\tif (task) {",
            "\t\tput_task_struct(task);",
            "\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static unsigned long damos_madvise(struct damon_target *target,",
            "\t\tstruct damon_region *r, int behavior)",
            "{",
            "\treturn 0;",
            "}"
          ],
          "function_name": "damon_young_hugetlb_entry, damon_va_young, __damon_va_check_access, damon_va_check_accesses, damon_va_target_valid, damos_madvise",
          "description": "检查页面访问状态及统计访问次数的函数，核心功能是通过遍历内存区域判断页面是否被访问并更新监控数据。",
          "similarity": 0.5293599367141724
        },
        {
          "chunk_id": 5,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 632,
          "end_line": 723,
          "content": [
            "static unsigned long damos_madvise(struct damon_target *target,",
            "\t\tstruct damon_region *r, int behavior)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tunsigned long start = PAGE_ALIGN(r->ar.start);",
            "\tunsigned long len = PAGE_ALIGN(damon_sz_region(r));",
            "\tunsigned long applied;",
            "",
            "\tmm = damon_get_mm(target);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tapplied = do_madvise(mm, start, len, behavior) ? 0 : len;",
            "\tmmput(mm);",
            "",
            "\treturn applied;",
            "}",
            "static unsigned long damon_va_apply_scheme(struct damon_ctx *ctx,",
            "\t\tstruct damon_target *t, struct damon_region *r,",
            "\t\tstruct damos *scheme)",
            "{",
            "\tint madv_action;",
            "",
            "\tswitch (scheme->action) {",
            "\tcase DAMOS_WILLNEED:",
            "\t\tmadv_action = MADV_WILLNEED;",
            "\t\tbreak;",
            "\tcase DAMOS_COLD:",
            "\t\tmadv_action = MADV_COLD;",
            "\t\tbreak;",
            "\tcase DAMOS_PAGEOUT:",
            "\t\tmadv_action = MADV_PAGEOUT;",
            "\t\tbreak;",
            "\tcase DAMOS_HUGEPAGE:",
            "\t\tmadv_action = MADV_HUGEPAGE;",
            "\t\tbreak;",
            "\tcase DAMOS_NOHUGEPAGE:",
            "\t\tmadv_action = MADV_NOHUGEPAGE;",
            "\t\tbreak;",
            "\tcase DAMOS_STAT:",
            "\t\treturn 0;",
            "\tdefault:",
            "\t\t/*",
            "\t\t * DAMOS actions that are not yet supported by 'vaddr'.",
            "\t\t */",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn damos_madvise(t, r, madv_action);",
            "}",
            "static int damon_va_scheme_score(struct damon_ctx *context,",
            "\t\tstruct damon_target *t, struct damon_region *r,",
            "\t\tstruct damos *scheme)",
            "{",
            "",
            "\tswitch (scheme->action) {",
            "\tcase DAMOS_PAGEOUT:",
            "\t\treturn damon_cold_score(context, r, scheme);",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn DAMOS_MAX_SCORE;",
            "}",
            "static int __init damon_va_initcall(void)",
            "{",
            "\tstruct damon_operations ops = {",
            "\t\t.id = DAMON_OPS_VADDR,",
            "\t\t.init = damon_va_init,",
            "\t\t.update = damon_va_update,",
            "\t\t.prepare_access_checks = damon_va_prepare_access_checks,",
            "\t\t.check_accesses = damon_va_check_accesses,",
            "\t\t.reset_aggregated = NULL,",
            "\t\t.target_valid = damon_va_target_valid,",
            "\t\t.cleanup = NULL,",
            "\t\t.apply_scheme = damon_va_apply_scheme,",
            "\t\t.get_scheme_score = damon_va_scheme_score,",
            "\t};",
            "\t/* ops for fixed virtual address ranges */",
            "\tstruct damon_operations ops_fvaddr = ops;",
            "\tint err;",
            "",
            "\t/* Don't set the monitoring target regions for the entire mapping */",
            "\tops_fvaddr.id = DAMON_OPS_FVADDR;",
            "\tops_fvaddr.init = NULL;",
            "\tops_fvaddr.update = NULL;",
            "",
            "\terr = damon_register_ops(&ops);",
            "\tif (err)",
            "\t\treturn err;",
            "\treturn damon_register_ops(&ops_fvaddr);",
            "};"
          ],
          "function_name": "damos_madvise, damon_va_apply_scheme, damon_va_scheme_score, damon_va_initcall",
          "description": "该代码实现基于虚拟地址的内存优化策略管理，主要功能包括：  \n1. `damos_madvise` 和 `damon_va_apply_scheme` 通过 `madvise` 系统调用对内存区域应用特定行为（如预读、冷页迁移等），`damon_va_scheme_score` 根据策略动态计算区域评分；  \n2. `damon_va_initcall` 注册虚拟地址范围监控操作集，支持两种模式（普通/固定范围），关联策略应用与评分逻辑；  \n3. 代码上下文不完整，依赖外部未展示的 `do_madvise`、`damon_cold_score` 等函数及 `damon_operations` 操作接口。",
          "similarity": 0.47261175513267517
        }
      ]
    }
  ]
}