{
  "query": "进程创建时内存复制机制分析",
  "timestamp": "2025-12-26 00:39:01",
  "retrieved_files": [
    {
      "source_file": "kernel/fork.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:30:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fork.c`\n\n---\n\n# fork.c 技术文档\n\n## 1. 文件概述\n\n`fork.c` 是 Linux 内核中实现进程创建（fork）系统调用的核心源文件。该文件包含了创建新进程所需的所有辅助例程，负责复制父进程的资源（如内存、文件描述符、信号处理等）以生成子进程。虽然 fork 逻辑本身概念简单，但其涉及的内存管理（尤其是写时复制 COW 机制）极为复杂，实际内存页的复制由 `mm/memory.c` 中的 `copy_page_range()` 等函数处理。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `total_forks`: 累计系统自启动以来创建的进程总数\n- `nr_threads`: 当前系统中的线程总数（不包括 idle 线程）\n- `max_threads`: 可配置的线程数量上限（默认为 `FUTEX_TID_MASK`）\n- `process_counts`: 每 CPU 的进程计数器（per-CPU 变量）\n- `tasklist_lock`: 保护任务链表的读写锁（全局任务列表的同步原语）\n\n### 关键辅助函数\n- `nr_processes()`: 计算系统中所有进程的总数（聚合各 CPU 的 `process_counts`）\n- `arch_release_task_struct()`: 架构相关的 task_struct 释放钩子（弱符号，默认为空）\n- `alloc_task_struct_node()` / `free_task_struct()`: 分配/释放 `task_struct` 结构（基于 slab 分配器）\n- `alloc_thread_stack_node()` / `thread_stack_delayed_free()`: 分配/延迟释放线程内核栈（支持 `CONFIG_VMAP_STACK`）\n\n### 核心数据结构\n- `resident_page_types[]`: 用于内存统计的页面类型名称映射数组\n- `vm_stack`: 用于 RCU 延迟释放的虚拟内存栈封装结构\n- `cached_stacks[NR_CACHED_STACKS]`: 每 CPU 的内核栈缓存（减少频繁 vmalloc/vfree 开销）\n\n## 3. 关键实现\n\n### 进程/线程计数管理\n- 使用 per-CPU 变量 `process_counts` 避免全局锁竞争\n- 全局计数器 `nr_threads` 和 `total_forks` 由 `tasklist_lock` 保护\n- `nr_processes()` 通过遍历所有可能的 CPU 聚合计数\n\n### 内核栈分配策略（`CONFIG_VMAP_STACK`）\n- **缓存机制**：每个 CPU 缓存最多 2 个已释放的栈（`NR_CACHED_STACKS`），减少 TLB 刷新和 vmalloc 开销\n- **内存分配**：\n  - 优先从本地缓存获取栈\n  - 缓存未命中时使用 `__vmalloc_node_range()` 分配连续虚拟地址空间\n  - 显式禁用 `__GFP_ACCOUNT`（因后续手动进行 memcg 计费）\n- **安全清理**：\n  - 重用栈时清零内存（`memset(stack, 0, THREAD_SIZE)`）\n  - KASAN 消毒（`kasan_unpoison_range`）和标签重置\n- **延迟释放**：\n  - 通过 RCU 机制延迟释放栈（`call_rcu`）\n  - 释放时尝试回填缓存，失败则直接 `vfree`\n\n### 内存控制组（memcg）集成\n- 手动对栈的每个物理页进行 memcg 计费（`memcg_kmem_charge_page`）\n- 计费失败时回滚已计费页面（`memcg_kmem_uncharge_page`）\n- 确保内核栈内存纳入 cgroup 内存限制\n\n### 锁与同步\n- `tasklist_lock` 作为全局任务列表的保护锁（读写锁）\n- 提供 `lockdep_tasklist_lock_is_held()` 供 RCU 锁验证使用\n- RCU 用于安全延迟释放内核栈资源\n\n## 4. 依赖关系\n\n### 内核子系统依赖\n- **内存管理 (MM)**：`<linux/mm.h>`, `<linux/vmalloc.h>`, `<linux/memcontrol.h>`\n- **调度器 (Scheduler)**：`<linux/sched/*.h>`, 任务状态和 CPU 绑定\n- **安全模块**：`<linux/security.h>`, `<linux/capability.h>`, `<linux/seccomp.h>`\n- **命名空间**：`<linux/nsproxy.h>`（UTS, IPC, PID, 网络等）\n- **文件系统**：`<linux/fs.h>`, `<linux/fdtable.h>`（文件描述符复制）\n- **跟踪与调试**：`<trace/events/sched.h>`, `<linux/ftrace.h>`, KASAN/KMSAN\n\n### 架构相关依赖\n- `<asm/pgalloc.h>`：页表分配\n- `<asm/mmu_context.h>`：MMU 上下文切换\n- `<asm/tlbflush.h>`：TLB 刷新操作\n- 架构特定的 `THREAD_SIZE` 和栈对齐要求\n\n### 配置选项依赖\n- `CONFIG_VMAP_STACK`：启用虚拟内存分配内核栈\n- `CONFIG_PROVE_RCU`：RCU 锁验证支持\n- `CONFIG_ARCH_TASK_STRUCT_ALLOCATOR`：架构自定义 task_struct 分配器\n- `CONFIG_MEMCG_KMEM`：内核内存 cgroup 支持\n\n## 5. 使用场景\n\n### 进程创建路径\n- **系统调用入口**：`sys_fork()`, `sys_vfork()`, `sys_clone()` 最终调用 `_do_fork()`\n- **内核线程创建**：`kthread_create()` 通过 `kernel_thread()` 触发 fork 逻辑\n- **容器/命名空间初始化**：新 PID/UTS/IPC 命名空间创建时伴随进程 fork\n\n### 资源复制关键点\n- **内存描述符 (mm_struct)**：通过 `dup_mm()` 复制地址空间（COW 页表）\n- **文件描述符表**：`dup_fd()` 复制打开文件表\n- **信号处理**：复制信号掩码和处理函数\n- **POSIX 定时器/异步 I/O**：复制相关上下文（如 `aio`, `posix-timers`）\n\n### 特殊场景处理\n- **写时复制优化**：避免物理内存立即复制，提升 fork 性能\n- **OOM Killer 集成**：在内存不足时参与进程选择\n- **审计与监控**：通过 `audit_alloc()` 和 `proc` 文件系统暴露进程信息\n- **实时性保障**：RT 任务 fork 时保持调度策略和优先级",
      "similarity": 0.6837098002433777,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/fork.c",
          "start_line": 666,
          "end_line": 845,
          "content": [
            "static __latent_entropy int dup_mmap(struct mm_struct *mm,",
            "\t\t\t\t\tstruct mm_struct *oldmm)",
            "{",
            "\tstruct vm_area_struct *mpnt, *tmp;",
            "\tint retval;",
            "\tunsigned long charge = 0;",
            "\tLIST_HEAD(uf);",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\tuprobe_start_dup_mmap();",
            "\tif (mmap_write_lock_killable(oldmm)) {",
            "\t\tretval = -EINTR;",
            "\t\tgoto fail_uprobe_end;",
            "\t}",
            "\tflush_cache_dup_mm(oldmm);",
            "\tuprobe_dup_mmap(oldmm, mm);",
            "\t/*",
            "\t * Not linked in yet - no deadlock potential:",
            "\t */",
            "\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);",
            "",
            "\t/* No ordering required: file already has been exposed. */",
            "\tdup_mm_exe_file(mm, oldmm);",
            "",
            "\tmm->total_vm = oldmm->total_vm;",
            "\tmm->data_vm = oldmm->data_vm;",
            "\tmm->exec_vm = oldmm->exec_vm;",
            "\tmm->stack_vm = oldmm->stack_vm;",
            "",
            "\t/* Use __mt_dup() to efficiently build an identical maple tree. */",
            "\tretval = __mt_dup(&oldmm->mm_mt, &mm->mm_mt, GFP_KERNEL);",
            "\tif (unlikely(retval))",
            "\t\tgoto out;",
            "",
            "\tmt_clear_in_rcu(vmi.mas.tree);",
            "\tfor_each_vma(vmi, mpnt) {",
            "\t\tstruct file *file;",
            "",
            "\t\tvma_start_write(mpnt);",
            "\t\tif (mpnt->vm_flags & VM_DONTCOPY) {",
            "\t\t\tretval = vma_iter_clear_gfp(&vmi, mpnt->vm_start,",
            "\t\t\t\t\t\t    mpnt->vm_end, GFP_KERNEL);",
            "\t\t\tif (retval)",
            "\t\t\t\tgoto loop_out;",
            "",
            "\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tcharge = 0;",
            "\t\t/*",
            "\t\t * Don't duplicate many vmas if we've been oom-killed (for",
            "\t\t * example)",
            "\t\t */",
            "\t\tif (fatal_signal_pending(current)) {",
            "\t\t\tretval = -EINTR;",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t\tif (mpnt->vm_flags & VM_ACCOUNT) {",
            "\t\t\tunsigned long len = vma_pages(mpnt);",
            "",
            "\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */",
            "\t\t\t\tgoto fail_nomem;",
            "\t\t\tcharge = len;",
            "\t\t}",
            "\t\ttmp = vm_area_dup(mpnt);",
            "\t\tif (!tmp)",
            "\t\t\tgoto fail_nomem;",
            "",
            "\t\t/* track_pfn_copy() will later take care of copying internal state. */",
            "\t\tif (unlikely(tmp->vm_flags & VM_PFNMAP))",
            "\t\t\tuntrack_pfn_clear(tmp);",
            "",
            "\t\tretval = vma_dup_policy(mpnt, tmp);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_policy;",
            "\t\ttmp->vm_mm = mm;",
            "\t\tretval = dup_userfaultfd(tmp, &uf);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tif (tmp->vm_flags & VM_WIPEONFORK) {",
            "\t\t\t/*",
            "\t\t\t * VM_WIPEONFORK gets a clean slate in the child.",
            "\t\t\t * Don't prepare anon_vma until fault since we don't",
            "\t\t\t * copy page for current vma.",
            "\t\t\t */",
            "\t\t\ttmp->anon_vma = NULL;",
            "\t\t} else if (anon_vma_fork(tmp, mpnt))",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tvm_flags_clear(tmp, VM_LOCKED_MASK);",
            "\t\tfile = tmp->vm_file;",
            "\t\tif (file) {",
            "\t\t\tstruct address_space *mapping = file->f_mapping;",
            "",
            "\t\t\tget_file(file);",
            "\t\t\ti_mmap_lock_write(mapping);",
            "\t\t\tif (vma_is_shared_maywrite(tmp))",
            "\t\t\t\tmapping_allow_writable(mapping);",
            "\t\t\tflush_dcache_mmap_lock(mapping);",
            "\t\t\t/* insert tmp into the share list, just after mpnt */",
            "\t\t\tvma_interval_tree_insert_after(tmp, mpnt,",
            "\t\t\t\t\t&mapping->i_mmap);",
            "\t\t\tflush_dcache_mmap_unlock(mapping);",
            "\t\t\ti_mmap_unlock_write(mapping);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Copy/update hugetlb private vma information.",
            "\t\t */",
            "\t\tif (is_vm_hugetlb_page(tmp))",
            "\t\t\thugetlb_dup_vma_private(tmp);",
            "",
            "\t\t/*",
            "\t\t * Link the vma into the MT. After using __mt_dup(), memory",
            "\t\t * allocation is not necessary here, so it cannot fail.",
            "\t\t */",
            "\t\tvma_iter_bulk_store(&vmi, tmp);",
            "",
            "\t\tmm->map_count++;",
            "\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))",
            "\t\t\tretval = copy_page_range(tmp, mpnt);",
            "",
            "\t\tif (tmp->vm_ops && tmp->vm_ops->open)",
            "\t\t\ttmp->vm_ops->open(tmp);",
            "",
            "\t\tif (retval) {",
            "\t\t\tmpnt = vma_next(&vmi);",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t}",
            "\t/* a new mm has just been created */",
            "\tretval = arch_dup_mmap(oldmm, mm);",
            "loop_out:",
            "\tvma_iter_free(&vmi);",
            "\tif (!retval) {",
            "\t\tmt_set_in_rcu(vmi.mas.tree);",
            "\t\tksm_fork(mm, oldmm);",
            "\t\tkhugepaged_fork(mm, oldmm);",
            "\t} else {",
            "",
            "\t\t/*",
            "\t\t * The entire maple tree has already been duplicated. If the",
            "\t\t * mmap duplication fails, mark the failure point with",
            "\t\t * XA_ZERO_ENTRY. In exit_mmap(), if this marker is encountered,",
            "\t\t * stop releasing VMAs that have not been duplicated after this",
            "\t\t * point.",
            "\t\t */",
            "\t\tif (mpnt) {",
            "\t\t\tmas_set_range(&vmi.mas, mpnt->vm_start, mpnt->vm_end - 1);",
            "\t\t\tmas_store(&vmi.mas, XA_ZERO_ENTRY);",
            "\t\t\t/* Avoid OOM iterating a broken tree */",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t}",
            "\t\t/*",
            "\t\t * The mm_struct is going to exit, but the locks will be dropped",
            "\t\t * first.  Set the mm_struct as unstable is advisable as it is",
            "\t\t * not fully initialised.",
            "\t\t */",
            "\t\tset_bit(MMF_UNSTABLE, &mm->flags);",
            "\t}",
            "out:",
            "\tmmap_write_unlock(mm);",
            "\tflush_tlb_mm(oldmm);",
            "\tmmap_write_unlock(oldmm);",
            "\tif (!retval)",
            "\t\tdup_userfaultfd_complete(&uf);",
            "\telse",
            "\t\tdup_userfaultfd_fail(&uf);",
            "fail_uprobe_end:",
            "\tuprobe_end_dup_mmap();",
            "\treturn retval;",
            "",
            "fail_nomem_anon_vma_fork:",
            "\tmpol_put(vma_policy(tmp));",
            "fail_nomem_policy:",
            "\tvm_area_free(tmp);",
            "fail_nomem:",
            "\tretval = -ENOMEM;",
            "\tvm_unacct_memory(charge);",
            "\tgoto loop_out;",
            "}"
          ],
          "function_name": "dup_mmap",
          "description": "实现进程fork时的内存映射复制逻辑，深度遍历原进程的VMA结构创建副本，处理共享文件映射、hugetlb页等特殊内存类型，并管理OOM异常情况下的失败恢复。",
          "similarity": 0.6686949133872986
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/fork.c",
          "start_line": 2004,
          "end_line": 2110,
          "content": [
            "static void rt_mutex_init_task(struct task_struct *p)",
            "{",
            "\traw_spin_lock_init(&p->pi_lock);",
            "#ifdef CONFIG_RT_MUTEXES",
            "\tp->pi_waiters = RB_ROOT_CACHED;",
            "\tp->pi_top_task = NULL;",
            "\tp->pi_blocked_on = NULL;",
            "#endif",
            "}",
            "static inline void init_task_pid_links(struct task_struct *task)",
            "{",
            "\tenum pid_type type;",
            "",
            "\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)",
            "\t\tINIT_HLIST_NODE(&task->pid_links[type]);",
            "}",
            "static inline void",
            "init_task_pid(struct task_struct *task, enum pid_type type, struct pid *pid)",
            "{",
            "\tif (type == PIDTYPE_PID)",
            "\t\ttask->thread_pid = pid;",
            "\telse",
            "\t\ttask->signal->pids[type] = pid;",
            "}",
            "static inline void rcu_copy_process(struct task_struct *p)",
            "{",
            "#ifdef CONFIG_PREEMPT_RCU",
            "\tp->rcu_read_lock_nesting = 0;",
            "\tp->rcu_read_unlock_special.s = 0;",
            "\tp->rcu_blocked_node = NULL;",
            "\tINIT_LIST_HEAD(&p->rcu_node_entry);",
            "#endif /* #ifdef CONFIG_PREEMPT_RCU */",
            "#ifdef CONFIG_TASKS_RCU",
            "\tp->rcu_tasks_holdout = false;",
            "\tINIT_LIST_HEAD(&p->rcu_tasks_holdout_list);",
            "\tp->rcu_tasks_idle_cpu = -1;",
            "\tINIT_LIST_HEAD(&p->rcu_tasks_exit_list);",
            "#endif /* #ifdef CONFIG_TASKS_RCU */",
            "#ifdef CONFIG_TASKS_TRACE_RCU",
            "\tp->trc_reader_nesting = 0;",
            "\tp->trc_reader_special.s = 0;",
            "\tINIT_LIST_HEAD(&p->trc_holdout_list);",
            "\tINIT_LIST_HEAD(&p->trc_blkd_node);",
            "#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */",
            "}",
            "static int __pidfd_prepare(struct pid *pid, unsigned int flags, struct file **ret)",
            "{",
            "\tint pidfd;",
            "\tstruct file *pidfd_file;",
            "",
            "\tpidfd = get_unused_fd_flags(O_CLOEXEC);",
            "\tif (pidfd < 0)",
            "\t\treturn pidfd;",
            "",
            "\tpidfd_file = pidfs_alloc_file(pid, flags | O_RDWR);",
            "\tif (IS_ERR(pidfd_file)) {",
            "\t\tput_unused_fd(pidfd);",
            "\t\treturn PTR_ERR(pidfd_file);",
            "\t}",
            "\t/*",
            "\t * anon_inode_getfile() ignores everything outside of the",
            "\t * O_ACCMODE | O_NONBLOCK mask, set PIDFD_THREAD manually.",
            "\t */",
            "\tpidfd_file->f_flags |= (flags & PIDFD_THREAD);",
            "\t*ret = pidfd_file;",
            "\treturn pidfd;",
            "}",
            "int pidfd_prepare(struct pid *pid, unsigned int flags, struct file **ret)",
            "{",
            "\tbool thread = flags & PIDFD_THREAD;",
            "",
            "\tif (!pid || !pid_has_task(pid, thread ? PIDTYPE_PID : PIDTYPE_TGID))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn __pidfd_prepare(pid, flags, ret);",
            "}",
            "static void __delayed_free_task(struct rcu_head *rhp)",
            "{",
            "\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);",
            "",
            "\tfree_task(tsk);",
            "}",
            "static __always_inline void delayed_free_task(struct task_struct *tsk)",
            "{",
            "\tif (IS_ENABLED(CONFIG_MEMCG))",
            "\t\tcall_rcu(&tsk->rcu, __delayed_free_task);",
            "\telse",
            "\t\tfree_task(tsk);",
            "}",
            "static void copy_oom_score_adj(u64 clone_flags, struct task_struct *tsk)",
            "{",
            "\t/* Skip if kernel thread */",
            "\tif (!tsk->mm)",
            "\t\treturn;",
            "",
            "\t/* Skip if spawning a thread or using vfork */",
            "\tif ((clone_flags & (CLONE_VM | CLONE_THREAD | CLONE_VFORK)) != CLONE_VM)",
            "\t\treturn;",
            "",
            "\t/* We need to synchronize with __set_oom_adj */",
            "\tmutex_lock(&oom_adj_mutex);",
            "\tset_bit(MMF_MULTIPROCESS, &tsk->mm->flags);",
            "\t/* Update the values in case they were changed after copy_signal */",
            "\ttsk->signal->oom_score_adj = current->signal->oom_score_adj;",
            "\ttsk->signal->oom_score_adj_min = current->signal->oom_score_adj_min;",
            "\tmutex_unlock(&oom_adj_mutex);",
            "}"
          ],
          "function_name": "rt_mutex_init_task, init_task_pid_links, init_task_pid, rcu_copy_process, __pidfd_prepare, pidfd_prepare, __delayed_free_task, delayed_free_task, copy_oom_score_adj",
          "description": "初始化任务PID链接与RCU相关数据结构，处理进程克隆时PID复制、延迟释放任务结构及OOM分数调整的复制逻辑",
          "similarity": 0.6224838495254517
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/fork.c",
          "start_line": 1863,
          "end_line": 1988,
          "content": [
            "static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)",
            "{",
            "\tstruct sighand_struct *sig;",
            "",
            "\tif (clone_flags & CLONE_SIGHAND) {",
            "\t\trefcount_inc(&current->sighand->count);",
            "\t\treturn 0;",
            "\t}",
            "\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);",
            "\tRCU_INIT_POINTER(tsk->sighand, sig);",
            "\tif (!sig)",
            "\t\treturn -ENOMEM;",
            "",
            "\trefcount_set(&sig->count, 1);",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\t/* Reset all signal handler not set to SIG_IGN to SIG_DFL. */",
            "\tif (clone_flags & CLONE_CLEAR_SIGHAND)",
            "\t\tflush_signal_handlers(tsk, 0);",
            "",
            "\treturn 0;",
            "}",
            "void __cleanup_sighand(struct sighand_struct *sighand)",
            "{",
            "\tif (refcount_dec_and_test(&sighand->count)) {",
            "\t\tsignalfd_cleanup(sighand);",
            "\t\t/*",
            "\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it",
            "\t\t * without an RCU grace period, see __lock_task_sighand().",
            "\t\t */",
            "\t\tkmem_cache_free(sighand_cachep, sighand);",
            "\t}",
            "}",
            "static void posix_cpu_timers_init_group(struct signal_struct *sig)",
            "{",
            "\tstruct posix_cputimers *pct = &sig->posix_cputimers;",
            "\tunsigned long cpu_limit;",
            "",
            "\tcpu_limit = READ_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);",
            "\tposix_cputimers_group_init(pct, cpu_limit);",
            "}",
            "static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)",
            "{",
            "\tstruct signal_struct *sig;",
            "",
            "\tif (clone_flags & CLONE_THREAD)",
            "\t\treturn 0;",
            "",
            "\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);",
            "\ttsk->signal = sig;",
            "\tif (!sig)",
            "\t\treturn -ENOMEM;",
            "",
            "\tsig->nr_threads = 1;",
            "\tsig->quick_threads = 1;",
            "\tatomic_set(&sig->live, 1);",
            "\trefcount_set(&sig->sigcnt, 1);",
            "",
            "\t/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */",
            "\tsig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);",
            "\ttsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);",
            "",
            "\tinit_waitqueue_head(&sig->wait_chldexit);",
            "\tsig->curr_target = tsk;",
            "\tinit_sigpending(&sig->shared_pending);",
            "\tINIT_HLIST_HEAD(&sig->multiprocess);",
            "\tseqlock_init(&sig->stats_lock);",
            "\tprev_cputime_init(&sig->prev_cputime);",
            "",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\tINIT_LIST_HEAD(&sig->posix_timers);",
            "\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);",
            "\tsig->real_timer.function = it_real_fn;",
            "#endif",
            "",
            "\ttask_lock(current->group_leader);",
            "\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);",
            "\ttask_unlock(current->group_leader);",
            "",
            "\tposix_cpu_timers_init_group(sig);",
            "",
            "\ttty_audit_fork(sig);",
            "\tsched_autogroup_fork(sig);",
            "",
            "\tsig->oom_score_adj = current->signal->oom_score_adj;",
            "\tsig->oom_score_adj_min = current->signal->oom_score_adj_min;",
            "",
            "\tmutex_init(&sig->cred_guard_mutex);",
            "\tinit_rwsem(&sig->exec_update_lock);",
            "",
            "\treturn 0;",
            "}",
            "static void copy_seccomp(struct task_struct *p)",
            "{",
            "#ifdef CONFIG_SECCOMP",
            "\t/*",
            "\t * Must be called with sighand->lock held, which is common to",
            "\t * all threads in the group. Holding cred_guard_mutex is not",
            "\t * needed because this new task is not yet running and cannot",
            "\t * be racing exec.",
            "\t */",
            "\tassert_spin_locked(&current->sighand->siglock);",
            "",
            "\t/* Ref-count the new filter user, and assign it. */",
            "\tget_seccomp_filter(current);",
            "\tp->seccomp = current->seccomp;",
            "",
            "\t/*",
            "\t * Explicitly enable no_new_privs here in case it got set",
            "\t * between the task_struct being duplicated and holding the",
            "\t * sighand lock. The seccomp state and nnp must be in sync.",
            "\t */",
            "\tif (task_no_new_privs(current))",
            "\t\ttask_set_no_new_privs(p);",
            "",
            "\t/*",
            "\t * If the parent gained a seccomp mode after copying thread",
            "\t * flags and between before we held the sighand lock, we have",
            "\t * to manually enable the seccomp thread flag here.",
            "\t */",
            "\tif (p->seccomp.mode != SECCOMP_MODE_DISABLED)",
            "\t\tset_task_syscall_work(p, SECCOMP);",
            "#endif",
            "}"
          ],
          "function_name": "copy_sighand, __cleanup_sighand, posix_cpu_timers_init_group, copy_signal, copy_seccomp",
          "description": "实现进程克隆时信号处理手柄的复制逻辑，根据克隆标志决定是否共享或新建sighand结构体，同步信号动作数组并处理信号处理器重置，包含seccomp过滤器和线程组资源的复制",
          "similarity": 0.5903092622756958
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/fork.c",
          "start_line": 350,
          "end_line": 450,
          "content": [
            "static void free_thread_stack(struct task_struct *tsk)",
            "{",
            "\tif (!try_release_thread_stack_to_cache(tsk->stack_vm_area))",
            "\t\tthread_stack_delayed_free(tsk);",
            "",
            "\ttsk->stack = NULL;",
            "\ttsk->stack_vm_area = NULL;",
            "}",
            "static void thread_stack_free_rcu(struct rcu_head *rh)",
            "{",
            "\t__free_pages(virt_to_page(rh), THREAD_SIZE_ORDER);",
            "}",
            "static void thread_stack_delayed_free(struct task_struct *tsk)",
            "{",
            "\tstruct rcu_head *rh = tsk->stack;",
            "",
            "\tcall_rcu(rh, thread_stack_free_rcu);",
            "}",
            "static int alloc_thread_stack_node(struct task_struct *tsk, int node)",
            "{",
            "\tstruct page *page = alloc_pages_node(node, THREADINFO_GFP,",
            "\t\t\t\t\t     THREAD_SIZE_ORDER);",
            "",
            "\tif (likely(page)) {",
            "\t\ttsk->stack = kasan_reset_tag(page_address(page));",
            "\t\treturn 0;",
            "\t}",
            "\treturn -ENOMEM;",
            "}",
            "static void free_thread_stack(struct task_struct *tsk)",
            "{",
            "\tthread_stack_delayed_free(tsk);",
            "\ttsk->stack = NULL;",
            "}",
            "static void thread_stack_free_rcu(struct rcu_head *rh)",
            "{",
            "\tkmem_cache_free(thread_stack_cache, rh);",
            "}",
            "static void thread_stack_delayed_free(struct task_struct *tsk)",
            "{",
            "\tstruct rcu_head *rh = tsk->stack;",
            "",
            "\tcall_rcu(rh, thread_stack_free_rcu);",
            "}",
            "static int alloc_thread_stack_node(struct task_struct *tsk, int node)",
            "{",
            "\tunsigned long *stack;",
            "\tstack = kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);",
            "\tstack = kasan_reset_tag(stack);",
            "\ttsk->stack = stack;",
            "\treturn stack ? 0 : -ENOMEM;",
            "}",
            "static void free_thread_stack(struct task_struct *tsk)",
            "{",
            "\tthread_stack_delayed_free(tsk);",
            "\ttsk->stack = NULL;",
            "}",
            "void thread_stack_cache_init(void)",
            "{",
            "\tthread_stack_cache = kmem_cache_create_usercopy(\"thread_stack\",",
            "\t\t\t\t\tTHREAD_SIZE, THREAD_SIZE, 0, 0,",
            "\t\t\t\t\tTHREAD_SIZE, NULL);",
            "\tBUG_ON(thread_stack_cache == NULL);",
            "}",
            "static int alloc_thread_stack_node(struct task_struct *tsk, int node)",
            "{",
            "\tunsigned long *stack;",
            "",
            "\tstack = arch_alloc_thread_stack_node(tsk, node);",
            "\ttsk->stack = stack;",
            "\treturn stack ? 0 : -ENOMEM;",
            "}",
            "static void free_thread_stack(struct task_struct *tsk)",
            "{",
            "\tarch_free_thread_stack(tsk);",
            "\ttsk->stack = NULL;",
            "}",
            "static bool vma_lock_alloc(struct vm_area_struct *vma)",
            "{",
            "\tvma->vm_lock = kmem_cache_alloc(vma_lock_cachep, GFP_KERNEL);",
            "\tif (!vma->vm_lock)",
            "\t\treturn false;",
            "",
            "\tinit_rwsem(&vma->vm_lock->lock);",
            "\tvma->vm_lock_seq = -1;",
            "",
            "\treturn true;",
            "}",
            "static inline void vma_lock_free(struct vm_area_struct *vma)",
            "{",
            "\tkmem_cache_free(vma_lock_cachep, vma->vm_lock);",
            "}",
            "static inline bool vma_lock_alloc(struct vm_area_struct *vma) { return true; }",
            "static inline void vma_lock_free(struct vm_area_struct *vma) {}",
            "void __vm_area_free(struct vm_area_struct *vma)",
            "{",
            "\tvma_numab_state_free(vma);",
            "\tfree_anon_vma_name(vma);",
            "\tvma_lock_free(vma);",
            "\tkmem_cache_free(vm_area_cachep, vma);",
            "}"
          ],
          "function_name": "free_thread_stack, thread_stack_free_rcu, thread_stack_delayed_free, alloc_thread_stack_node, free_thread_stack, thread_stack_free_rcu, thread_stack_delayed_free, alloc_thread_stack_node, free_thread_stack, thread_stack_cache_init, alloc_thread_stack_node, free_thread_stack, vma_lock_alloc, vma_lock_free, vma_lock_alloc, vma_lock_free, __vm_area_free",
          "description": "上下文不完整：存在重复函数定义和不一致的实现方式，显示线程栈分配/释放流程中使用了多种不同的内存管理策略，包括基于页面的分配、SLAB缓存及架构特定实现。",
          "similarity": 0.5840787291526794
        },
        {
          "chunk_id": 16,
          "file_path": "kernel/fork.c",
          "start_line": 3480,
          "end_line": 3518,
          "content": [
            "int unshare_files(void)",
            "{",
            "\tstruct task_struct *task = current;",
            "\tstruct files_struct *old, *copy = NULL;",
            "\tint error;",
            "",
            "\terror = unshare_fd(CLONE_FILES, &copy);",
            "\tif (error || !copy)",
            "\t\treturn error;",
            "",
            "\told = task->files;",
            "\ttask_lock(task);",
            "\ttask->files = copy;",
            "\ttask_unlock(task);",
            "\tput_files_struct(old);",
            "\treturn 0;",
            "}",
            "int sysctl_max_threads(struct ctl_table *table, int write,",
            "\t\t       void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct ctl_table t;",
            "\tint ret;",
            "\tint threads = max_threads;",
            "\tint min = 1;",
            "\tint max = MAX_THREADS;",
            "",
            "\tt = *table;",
            "\tt.data = &threads;",
            "\tt.extra1 = &min;",
            "\tt.extra2 = &max;",
            "",
            "\tret = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);",
            "\tif (ret || !write)",
            "\t\treturn ret;",
            "",
            "\tmax_threads = threads;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "unshare_files, sysctl_max_threads",
          "description": "unshare_files函数复制当前进程的文件表结构并将其绑定到当前任务，sysctl_max_threads函数通过proc_dointvec_minmax接口限制系统最大线程数，支持读取和写入操作，其中写入时会更新全局max_threads变量。",
          "similarity": 0.579093337059021
        }
      ]
    },
    {
      "source_file": "kernel/nsproxy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:12:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `nsproxy.c`\n\n---\n\n# nsproxy.c 技术文档\n\n## 1. 文件概述\n\n`nsproxy.c` 是 Linux 内核中实现命名空间（namespaces）代理机制的核心文件。该文件负责管理进程的命名空间代理结构 `nsproxy`，提供创建、复制、切换和释放命名空间集合的功能。命名空间是 Linux 容器技术（如 Docker、LXC）的基础，用于隔离进程视图，包括挂载点、UTS（主机名）、IPC、PID、网络、cgroup 和时间等资源。`nsproxy` 作为指向各类命名空间实例的容器，使得一个进程可以拥有独立的命名空间视图。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct nsproxy`**  \n  命名空间代理结构体，包含指向各类命名空间的指针：\n  - `uts_ns`：UTS 命名空间（主机名、域名）\n  - `ipc_ns`：IPC 命名空间（System V IPC 和 POSIX 消息队列）\n  - `mnt_ns`：挂载命名空间（文件系统挂载点视图）\n  - `pid_ns_for_children`：子进程将加入的 PID 命名空间\n  - `net_ns`：网络命名空间（网络设备、协议栈等）\n  - `cgroup_ns`：cgroup 命名空间（cgroup 层级视图）\n  - `time_ns` / `time_ns_for_children`：时间命名空间（用于虚拟化时间）\n\n- **`init_nsproxy`**  \n  全局初始化的命名空间代理实例，作为系统初始命名空间的引用。\n\n### 主要函数\n\n- **`create_nsproxy()`**  \n  从 slab 缓存分配一个新的 `nsproxy` 结构并初始化引用计数。\n\n- **`create_new_namespaces()`**  \n  根据指定标志位（如 `CLONE_NEWNS` 等）为任务创建全新的命名空间集合。\n\n- **`copy_namespaces()`**  \n  在 `clone()` 系统调用中被调用，根据 `clone_flags` 决定是否复制命名空间。\n\n- **`free_nsproxy()`**  \n  释放 `nsproxy` 及其引用的所有命名空间资源。\n\n- **`unshare_nsproxy_namespaces()`**  \n  在 `unshare()` 系统调用中使用，允许进程脱离当前命名空间并创建新的命名空间。\n\n- **`switch_task_namespaces()`**  \n  安全地切换任务的 `nsproxy`，并释放旧的引用。\n\n- **`exit_task_namespaces()`**  \n  进程退出时清理命名空间引用。\n\n- **`exec_task_namespaces()`**  \n  在 `execve()` 期间处理时间命名空间的特殊语义（子进程继承 `time_ns_for_children`）。\n\n- **`check_setns_flags()`**  \n  验证 `setns()` 系统调用传入的命名空间标志是否合法且内核已启用对应支持。\n\n## 3. 关键实现\n\n### 命名空间复制逻辑\n\n`create_new_namespaces()` 函数按顺序复制各类命名空间。若某一步失败（如内存不足或权限不足），则回滚已分配的资源，确保无内存泄漏。每个命名空间的复制由对应模块提供 `copy_xxx_ns()` 函数实现（如 `copy_mnt_ns()`、`copy_net_ns()` 等）。\n\n### 引用计数管理\n\n所有命名空间结构均使用引用计数（`refcount_t` 或类似机制）。`nsproxy` 本身也通过 `refcount_t count` 管理生命周期。`get_nsproxy()` 增加引用，`put_nsproxy()`（内联调用 `free_nsproxy()`）减少引用并在归零时释放。\n\n### 时间命名空间特殊处理\n\n时间命名空间具有两个字段：\n- `time_ns`：当前任务使用的时间命名空间。\n- `time_ns_for_children`：新创建子进程将继承的时间命名空间。\n\n在 `execve()` 时，若两者不同，需创建新的 `nsproxy` 并调用 `timens_on_fork()` 更新时间命名空间状态。\n\n### 权限与安全检查\n\n- 除 `CLONE_VM` 优化路径外，创建新命名空间需 `CAP_SYS_ADMIN` 能力。\n- 禁止同时指定 `CLONE_NEWIPC` 和 `CLONE_SYSVSEM`，因语义冲突。\n- `check_setns_flags()` 确保仅启用的命名空间类型可被操作。\n\n### 优化路径\n\n若 `clone_flags` 未请求任何新命名空间，且满足 `CLONE_VM` 或时间命名空间一致，则直接复用父进程的 `nsproxy`（仅增加引用计数），避免不必要的复制开销。\n\n## 4. 依赖关系\n\n- **内存管理**：依赖 `slab.h` 的 `kmem_cache` 机制分配 `nsproxy`。\n- **各命名空间子系统**：\n  - 挂载命名空间：`mnt_namespace.h`\n  - UTS：`utsname.h`\n  - IPC：`ipc_namespace.h`\n  - PID：`pid_namespace.h`\n  - 网络：`net_namespace.h`\n  - cgroup：`cgroup.h`\n  - 时间：`time_namespace.h`\n- **进程管理**：依赖 `task_struct`、`cred`、`fs_struct` 等结构。\n- **能力机制**：通过 `ns_capable()` 检查 `CAP_SYS_ADMIN`。\n- **proc 文件系统**：支持 `/proc/[pid]/ns/` 下的命名空间符号链接（通过 `proc_ns.h`）。\n\n## 5. 使用场景\n\n- **`clone()` 系统调用**：当指定 `CLONE_NEW*` 标志时，`copy_namespaces()` 被调用以创建子进程的命名空间视图。\n- **`unshare()` 系统调用**：进程调用 `unshare(CLONE_NEWNS | ...)` 时，`unshare_nsproxy_namespaces()` 创建新命名空间并切换。\n- **`setns()` 系统调用**：通过 `check_setns_flags()` 验证传入的命名空间类型合法性。\n- **`execve()` 系统调用**：处理时间命名空间的继承语义，确保子进程使用正确的 `time_ns_for_children`。\n- **进程退出**：`exit_task_namespaces()` 在进程终止时释放命名空间资源。\n- **容器运行时**：Docker、Podman、LXC 等依赖此机制实现资源隔离。",
      "similarity": 0.6528966426849365,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/nsproxy.c",
          "start_line": 1,
          "end_line": 150,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  Copyright (C) 2006 IBM Corporation",
            " *",
            " *  Author: Serge Hallyn <serue@us.ibm.com>",
            " *",
            " *  Jun 2006 - namespaces support",
            " *             OpenVZ, SWsoft Inc.",
            " *             Pavel Emelianov <xemul@openvz.org>",
            " */",
            "",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/init_task.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pid_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/perf_event.h>",
            "",
            "static struct kmem_cache *nsproxy_cachep;",
            "",
            "struct nsproxy init_nsproxy = {",
            "\t.count\t\t\t= REFCOUNT_INIT(1),",
            "\t.uts_ns\t\t\t= &init_uts_ns,",
            "#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)",
            "\t.ipc_ns\t\t\t= &init_ipc_ns,",
            "#endif",
            "\t.mnt_ns\t\t\t= NULL,",
            "\t.pid_ns_for_children\t= &init_pid_ns,",
            "#ifdef CONFIG_NET",
            "\t.net_ns\t\t\t= &init_net,",
            "#endif",
            "#ifdef CONFIG_CGROUPS",
            "\t.cgroup_ns\t\t= &init_cgroup_ns,",
            "#endif",
            "#ifdef CONFIG_TIME_NS",
            "\t.time_ns\t\t= &init_time_ns,",
            "\t.time_ns_for_children\t= &init_time_ns,",
            "#endif",
            "};",
            "",
            "static inline struct nsproxy *create_nsproxy(void)",
            "{",
            "\tstruct nsproxy *nsproxy;",
            "",
            "\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);",
            "\tif (nsproxy)",
            "\t\trefcount_set(&nsproxy->count, 1);",
            "\treturn nsproxy;",
            "}",
            "",
            "/*",
            " * Create new nsproxy and all of its the associated namespaces.",
            " * Return the newly created nsproxy.  Do not attach this to the task,",
            " * leave it to the caller to do proper locking and attach it to task.",
            " */",
            "static struct nsproxy *create_new_namespaces(unsigned long flags,",
            "\tstruct task_struct *tsk, struct user_namespace *user_ns,",
            "\tstruct fs_struct *new_fs)",
            "{",
            "\tstruct nsproxy *new_nsp;",
            "\tint err;",
            "",
            "\tnew_nsp = create_nsproxy();",
            "\tif (!new_nsp)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "",
            "\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);",
            "\tif (IS_ERR(new_nsp->mnt_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->mnt_ns);",
            "\t\tgoto out_ns;",
            "\t}",
            "",
            "\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);",
            "\tif (IS_ERR(new_nsp->uts_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->uts_ns);",
            "\t\tgoto out_uts;",
            "\t}",
            "",
            "\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);",
            "\tif (IS_ERR(new_nsp->ipc_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->ipc_ns);",
            "\t\tgoto out_ipc;",
            "\t}",
            "",
            "\tnew_nsp->pid_ns_for_children =",
            "\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);",
            "\tif (IS_ERR(new_nsp->pid_ns_for_children)) {",
            "\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);",
            "\t\tgoto out_pid;",
            "\t}",
            "",
            "\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,",
            "\t\t\t\t\t    tsk->nsproxy->cgroup_ns);",
            "\tif (IS_ERR(new_nsp->cgroup_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->cgroup_ns);",
            "\t\tgoto out_cgroup;",
            "\t}",
            "",
            "\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);",
            "\tif (IS_ERR(new_nsp->net_ns)) {",
            "\t\terr = PTR_ERR(new_nsp->net_ns);",
            "\t\tgoto out_net;",
            "\t}",
            "",
            "\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,",
            "\t\t\t\t\ttsk->nsproxy->time_ns_for_children);",
            "\tif (IS_ERR(new_nsp->time_ns_for_children)) {",
            "\t\terr = PTR_ERR(new_nsp->time_ns_for_children);",
            "\t\tgoto out_time;",
            "\t}",
            "\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);",
            "",
            "\treturn new_nsp;",
            "",
            "out_time:",
            "\tput_net(new_nsp->net_ns);",
            "out_net:",
            "\tput_cgroup_ns(new_nsp->cgroup_ns);",
            "out_cgroup:",
            "\tif (new_nsp->pid_ns_for_children)",
            "\t\tput_pid_ns(new_nsp->pid_ns_for_children);",
            "out_pid:",
            "\tif (new_nsp->ipc_ns)",
            "\t\tput_ipc_ns(new_nsp->ipc_ns);",
            "out_ipc:",
            "\tif (new_nsp->uts_ns)",
            "\t\tput_uts_ns(new_nsp->uts_ns);",
            "out_uts:",
            "\tif (new_nsp->mnt_ns)",
            "\t\tput_mnt_ns(new_nsp->mnt_ns);",
            "out_ns:",
            "\tkmem_cache_free(nsproxy_cachep, new_nsp);",
            "\treturn ERR_PTR(err);",
            "}",
            "",
            "/*",
            " * called from clone.  This now handles copy for nsproxy and all",
            " * namespaces therein.",
            " */"
          ],
          "function_name": null,
          "description": "定义了nsproxy结构体的初始值和创建逻辑，包括各命名空间（如mnt、uts、ipc等）的初始化及通过create_new_namespaces函数创建新命名空间的流程，用于进程克隆时复制命名空间环境",
          "similarity": 0.6034646034240723
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/nsproxy.c",
          "start_line": 512,
          "end_line": 549,
          "content": [
            "static void commit_nsset(struct nsset *nsset)",
            "{",
            "\tunsigned flags = nsset->flags;",
            "\tstruct task_struct *me = current;",
            "",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER) {",
            "\t\t/* transfer ownership */",
            "\t\tcommit_creds(nsset_cred(nsset));",
            "\t\tnsset->cred = NULL;",
            "\t}",
            "#endif",
            "",
            "\t/* We only need to commit if we have used a temporary fs_struct. */",
            "\tif ((flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS)) {",
            "\t\tset_fs_root(me->fs, &nsset->fs->root);",
            "\t\tset_fs_pwd(me->fs, &nsset->fs->pwd);",
            "\t}",
            "",
            "#ifdef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC)",
            "\t\texit_sem(me);",
            "#endif",
            "",
            "#ifdef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME)",
            "\t\ttimens_commit(me, nsset->nsproxy->time_ns);",
            "#endif",
            "",
            "\t/* transfer ownership */",
            "\tswitch_task_namespaces(me, nsset->nsproxy);",
            "\tnsset->nsproxy = NULL;",
            "}",
            "int __init nsproxy_cache_init(void)",
            "{",
            "\tnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC|SLAB_ACCOUNT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "commit_nsset, nsproxy_cache_init",
          "description": "完成命名空间变更提交（commit_nsset）和缓存初始化（nsproxy_cache_init），将临时命名空间绑定到当前任务并持久化，同时建立nsproxy结构体的Slab缓存以优化内存分配",
          "similarity": 0.5897924304008484
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/nsproxy.c",
          "start_line": 151,
          "end_line": 265,
          "content": [
            "int copy_namespaces(unsigned long flags, struct task_struct *tsk)",
            "{",
            "\tstruct nsproxy *old_ns = tsk->nsproxy;",
            "\tstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);",
            "\tstruct nsproxy *new_ns;",
            "",
            "\tif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t      CLONE_NEWPID | CLONE_NEWNET |",
            "\t\t\t      CLONE_NEWCGROUP | CLONE_NEWTIME)))) {",
            "\t\tif ((flags & CLONE_VM) ||",
            "\t\t    likely(old_ns->time_ns_for_children == old_ns->time_ns)) {",
            "\t\t\tget_nsproxy(old_ns);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t} else if (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * CLONE_NEWIPC must detach from the undolist: after switching",
            "\t * to a new ipc namespace, the semaphore arrays from the old",
            "\t * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM",
            "\t * means share undolist with parent, so we must forbid using",
            "\t * it along with CLONE_NEWIPC.",
            "\t */",
            "\tif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==",
            "\t\t(CLONE_NEWIPC | CLONE_SYSVSEM))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);",
            "\tif (IS_ERR(new_ns))",
            "\t\treturn  PTR_ERR(new_ns);",
            "",
            "\tif ((flags & CLONE_VM) == 0)",
            "\t\ttimens_on_fork(new_ns, tsk);",
            "",
            "\ttsk->nsproxy = new_ns;",
            "\treturn 0;",
            "}",
            "void free_nsproxy(struct nsproxy *ns)",
            "{",
            "\tif (ns->mnt_ns)",
            "\t\tput_mnt_ns(ns->mnt_ns);",
            "\tif (ns->uts_ns)",
            "\t\tput_uts_ns(ns->uts_ns);",
            "\tif (ns->ipc_ns)",
            "\t\tput_ipc_ns(ns->ipc_ns);",
            "\tif (ns->pid_ns_for_children)",
            "\t\tput_pid_ns(ns->pid_ns_for_children);",
            "\tif (ns->time_ns)",
            "\t\tput_time_ns(ns->time_ns);",
            "\tif (ns->time_ns_for_children)",
            "\t\tput_time_ns(ns->time_ns_for_children);",
            "\tput_cgroup_ns(ns->cgroup_ns);",
            "\tput_net(ns->net_ns);",
            "\tkmem_cache_free(nsproxy_cachep, ns);",
            "}",
            "int unshare_nsproxy_namespaces(unsigned long unshare_flags,",
            "\tstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)",
            "{",
            "\tstruct user_namespace *user_ns;",
            "\tint err = 0;",
            "",
            "\tif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP |",
            "\t\t\t       CLONE_NEWTIME)))",
            "\t\treturn 0;",
            "",
            "\tuser_ns = new_cred ? new_cred->user_ns : current_user_ns();",
            "\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,",
            "\t\t\t\t\t new_fs ? new_fs : current->fs);",
            "\tif (IS_ERR(*new_nsp)) {",
            "\t\terr = PTR_ERR(*new_nsp);",
            "\t\tgoto out;",
            "\t}",
            "",
            "out:",
            "\treturn err;",
            "}",
            "void switch_task_namespaces(struct task_struct *p, struct nsproxy *new)",
            "{",
            "\tstruct nsproxy *ns;",
            "",
            "\tmight_sleep();",
            "",
            "\ttask_lock(p);",
            "\tns = p->nsproxy;",
            "\tp->nsproxy = new;",
            "\ttask_unlock(p);",
            "",
            "\tif (ns)",
            "\t\tput_nsproxy(ns);",
            "}",
            "void exit_task_namespaces(struct task_struct *p)",
            "{",
            "\tswitch_task_namespaces(p, NULL);",
            "}",
            "int exec_task_namespaces(void)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct nsproxy *new;",
            "",
            "\tif (tsk->nsproxy->time_ns_for_children == tsk->nsproxy->time_ns)",
            "\t\treturn 0;",
            "",
            "\tnew = create_new_namespaces(0, tsk, current_user_ns(), tsk->fs);",
            "\tif (IS_ERR(new))",
            "\t\treturn PTR_ERR(new);",
            "",
            "\ttimens_on_fork(new, tsk);",
            "\tswitch_task_namespaces(tsk, new);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_namespaces, free_nsproxy, unshare_nsproxy_namespaces, switch_task_namespaces, exit_task_namespaces, exec_task_namespaces",
          "description": "实现了命名空间相关操作，包括复制（copy_namespaces）、释放（free_nsproxy）、分离（unshare_nsproxy_namespaces）、切换（switch_task_namespaces）和验证（validate_nsset）等功能，支持多命名空间的动态管理",
          "similarity": 0.544622540473938
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/nsproxy.c",
          "start_line": 276,
          "end_line": 490,
          "content": [
            "static int check_setns_flags(unsigned long flags)",
            "{",
            "\tif (!flags || (flags & ~(CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |",
            "\t\t\t\t CLONE_NEWNET | CLONE_NEWTIME | CLONE_NEWUSER |",
            "\t\t\t\t CLONE_NEWPID | CLONE_NEWCGROUP)))",
            "\t\treturn -EINVAL;",
            "",
            "#ifndef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_UTS_NS",
            "\tif (flags & CLONE_NEWUTS)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_CGROUPS",
            "\tif (flags & CLONE_NEWCGROUP)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_NET_NS",
            "\tif (flags & CLONE_NEWNET)",
            "\t\treturn -EINVAL;",
            "#endif",
            "#ifndef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME)",
            "\t\treturn -EINVAL;",
            "#endif",
            "",
            "\treturn 0;",
            "}",
            "static void put_nsset(struct nsset *nsset)",
            "{",
            "\tunsigned flags = nsset->flags;",
            "",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tput_cred(nsset_cred(nsset));",
            "\t/*",
            "\t * We only created a temporary copy if we attached to more than just",
            "\t * the mount namespace.",
            "\t */",
            "\tif (nsset->fs && (flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS))",
            "\t\tfree_fs_struct(nsset->fs);",
            "\tif (nsset->nsproxy)",
            "\t\tfree_nsproxy(nsset->nsproxy);",
            "}",
            "static int prepare_nsset(unsigned flags, struct nsset *nsset)",
            "{",
            "\tstruct task_struct *me = current;",
            "",
            "\tnsset->nsproxy = create_new_namespaces(0, me, current_user_ns(), me->fs);",
            "\tif (IS_ERR(nsset->nsproxy))",
            "\t\treturn PTR_ERR(nsset->nsproxy);",
            "",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tnsset->cred = prepare_creds();",
            "\telse",
            "\t\tnsset->cred = current_cred();",
            "\tif (!nsset->cred)",
            "\t\tgoto out;",
            "",
            "\t/* Only create a temporary copy of fs_struct if we really need to. */",
            "\tif (flags == CLONE_NEWNS) {",
            "\t\tnsset->fs = me->fs;",
            "\t} else if (flags & CLONE_NEWNS) {",
            "\t\tnsset->fs = copy_fs_struct(me->fs);",
            "\t\tif (!nsset->fs)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tnsset->flags = flags;",
            "\treturn 0;",
            "",
            "out:",
            "\tput_nsset(nsset);",
            "\treturn -ENOMEM;",
            "}",
            "static inline int validate_ns(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\treturn ns->ops->install(nsset, ns);",
            "}",
            "static int validate_nsset(struct nsset *nsset, struct pid *pid)",
            "{",
            "\tint ret = 0;",
            "\tunsigned flags = nsset->flags;",
            "\tstruct user_namespace *user_ns = NULL;",
            "\tstruct pid_namespace *pid_ns = NULL;",
            "\tstruct nsproxy *nsp;",
            "\tstruct task_struct *tsk;",
            "",
            "\t/* Take a \"snapshot\" of the target task's namespaces. */",
            "\trcu_read_lock();",
            "\ttsk = pid_task(pid, PIDTYPE_PID);",
            "\tif (!tsk) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "\tif (!ptrace_may_access(tsk, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\ttask_lock(tsk);",
            "\tnsp = tsk->nsproxy;",
            "\tif (nsp)",
            "\t\tget_nsproxy(nsp);",
            "\ttask_unlock(tsk);",
            "\tif (!nsp) {",
            "\t\trcu_read_unlock();",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "#ifdef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID) {",
            "\t\tpid_ns = task_active_pid_ns(tsk);",
            "\t\tif (unlikely(!pid_ns)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tret = -ESRCH;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tget_pid_ns(pid_ns);",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER)",
            "\t\tuser_ns = get_user_ns(__task_cred(tsk)->user_ns);",
            "#endif",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Install requested namespaces. The caller will have",
            "\t * verified earlier that the requested namespaces are",
            "\t * supported on this kernel. We don't report errors here",
            "\t * if a namespace is requested that isn't supported.",
            "\t */",
            "#ifdef CONFIG_USER_NS",
            "\tif (flags & CLONE_NEWUSER) {",
            "\t\tret = validate_ns(nsset, &user_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "\tif (flags & CLONE_NEWNS) {",
            "\t\tret = validate_ns(nsset, from_mnt_ns(nsp->mnt_ns));",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "#ifdef CONFIG_UTS_NS",
            "\tif (flags & CLONE_NEWUTS) {",
            "\t\tret = validate_ns(nsset, &nsp->uts_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_IPC_NS",
            "\tif (flags & CLONE_NEWIPC) {",
            "\t\tret = validate_ns(nsset, &nsp->ipc_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_PID_NS",
            "\tif (flags & CLONE_NEWPID) {",
            "\t\tret = validate_ns(nsset, &pid_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_CGROUPS",
            "\tif (flags & CLONE_NEWCGROUP) {",
            "\t\tret = validate_ns(nsset, &nsp->cgroup_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_NET_NS",
            "\tif (flags & CLONE_NEWNET) {",
            "\t\tret = validate_ns(nsset, &nsp->net_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_TIME_NS",
            "\tif (flags & CLONE_NEWTIME) {",
            "\t\tret = validate_ns(nsset, &nsp->time_ns->ns);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "#endif",
            "",
            "out:",
            "\tif (pid_ns)",
            "\t\tput_pid_ns(pid_ns);",
            "\tif (nsp)",
            "\t\tput_nsproxy(nsp);",
            "\tput_user_ns(user_ns);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "check_setns_flags, put_nsset, prepare_nsset, validate_ns, validate_nsset",
          "description": "提供命名空间集合的校验与准备逻辑，check_setns_flags验证标志位有效性，prepare_nsset构建临时命名空间集，validate_nsset检查目标命名空间权限和可用性，确保安全操作",
          "similarity": 0.4737998843193054
        }
      ]
    },
    {
      "source_file": "mm/memblock.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:38:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memblock.c`\n\n---\n\n# memblock.c 技术文档\n\n## 1. 文件概述\n\n`memblock.c` 实现了 Linux 内核早期启动阶段的内存管理机制——**memblock**。该机制用于在常规内存分配器（如 buddy allocator）尚未初始化之前，对物理内存进行粗粒度的区域管理。它将系统内存抽象为若干连续的内存区域（regions），支持“可用内存”（memory）、“保留内存”（reserved）和“物理内存”（physmem，部分架构支持）三种类型，为内核早期初始化提供内存添加、查询和分配能力。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct memblock_region`：表示一个连续的物理内存区域，包含基地址（base）、大小（size）、NUMA 节点 ID 和属性标志。\n- `struct memblock_type`：管理一类内存区域的集合，包含区域数组、当前数量（cnt）、最大容量（max）和名称。\n- `struct memblock`：全局 memblock 管理结构，包含 `memory` 和 `reserved` 两种类型的 `memblock_type`，以及分配方向（bottom_up）和当前分配上限（current_limit）。\n- `physmem`（条件编译）：描述不受 `mem=` 参数限制的实际物理内存布局。\n\n### 主要函数与变量\n- `memblock_add()` / `memblock_add_node()`：向 memblock 添加可用内存区域。\n- `memblock_reserve()`：标记内存区域为保留（不可用于动态分配）。\n- `memblock_phys_alloc*()` / `memblock_alloc*()`：分配物理或虚拟地址的内存。\n- `memblock_overlaps_region()`：判断指定区域是否与某类 memblock 区域重叠。\n- `__memblock_find_range_bottom_up()`：从低地址向高地址查找满足条件的空闲内存范围。\n- 全局变量 `memblock`：静态初始化的主 memblock 结构体。\n- `max_low_pfn`, `min_low_pfn`, `max_pfn`, `max_possible_pfn`：记录 PFN（页帧号）边界信息。\n\n### 配置宏\n- `INIT_MEMBLOCK_REGIONS`：初始内存/保留区域数组大小（默认 128）。\n- `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 类型支持。\n- `CONFIG_MEMBLOCK_KHO_SCRATCH`：支持仅从特定标记（KHO_SCRATCH）区域分配内存。\n- `CONFIG_ARCH_KEEP_MEMBLOCK`：决定是否在初始化完成后保留 memblock 数据结构。\n\n## 3. 关键实现\n\n### 初始化与存储\n- `memblock` 结构体在编译时静态初始化，其 `memory` 和 `reserved` 的区域数组分别使用 `memblock_memory_init_regions` 和 `memblock_reserved_init_regions`，初始容量由 `INIT_MEMBLOCK_*_REGIONS` 定义。\n- 每个 `memblock_type` 的 `cnt` 初始设为 1，但实际第一个条目为空的占位符，有效区域从索引 1 开始（后续代码处理）。\n- 支持通过 `memblock_allow_resize()` 动态扩容区域数组，但需谨慎避免与 initrd 等关键区域冲突。\n\n### 内存区域管理\n- 使用 `for_each_memblock_type` 宏遍历指定类型的区域。\n- `memblock_addrs_overlap()` 通过比较区间端点判断两个物理内存区域是否重叠。\n- `memblock_overlaps_region()` 封装了对某类所有区域的重叠检测。\n\n### 分配策略\n- 默认采用 **top-down**（从高地址向低地址）分配策略，可通过 `memblock_set_bottom_up(true)` 切换为 **bottom-up**。\n- 分配时受 `current_limit` 限制（默认 `MEMBLOCK_ALLOC_ANYWHERE` 表示无限制）。\n- 支持基于 NUMA 节点、对齐要求、内存属性（如 `MEMBLOCK_MIRROR`、`MEMBLOCK_KHO_SCRATCH`）的精细控制。\n- `choose_memblock_flags()` 根据 `kho_scratch_only` 和镜像内存存在性动态选择分配标志。\n\n### 安全与调试\n- `memblock_cap_size()` 防止地址计算溢出（确保 `base + size <= PHYS_ADDR_MAX`）。\n- 条件编译的 `memblock_dbg()` 宏用于调试输出（需开启 `memblock_debug`）。\n- 使用 `__initdata_memblock` 属性标记仅在初始化阶段使用的数据，便于后续释放。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/memblock.h>`：定义 memblock API 和数据结构。\n  - `<linux/kernel.h>`, `<linux/init.h>`：提供基础内核功能和初始化宏。\n  - `<linux/pfn.h>`：PFN 相关操作。\n  - `<asm/sections.h>`：访问内核链接段信息。\n  - 架构相关头文件（如 `internal.h`）。\n- **配置依赖**：\n  - `CONFIG_NUMA`：影响 `contig_page_data` 的定义。\n  - `CONFIG_KEXEC_HANDOVER`：引入 kexec 相关头文件。\n  - `CONFIG_HAVE_MEMBLOCK_PHYS_MAP`：启用 `physmem` 支持。\n- **后续移交**：在 `mem_init()` 中，memblock 管理的内存会被释放给 buddy allocator，完成内存管理权移交。\n\n## 5. 使用场景\n\n- **内核早期初始化**：在 `start_kernel()` 初期，架构代码（如 `setup_arch()`）调用 `memblock_add()` 注册可用物理内存，调用 `memblock_reserve()` 保留内核镜像、设备树、initrd 等关键区域。\n- **早期内存分配**：在 slab/buddy 分配器就绪前，使用 `memblock_alloc()` 分配大块连续内存（如页表、中断向量表、ACPI 表解析缓冲区）。\n- **内存布局查询**：通过 `for_each_memblock()` 等宏遍历内存区域，用于构建 e820 表、EFI 内存映射或 NUMA 拓扑。\n- **特殊分配需求**：支持从镜像内存（`MEMBLOCK_MIRROR`）或 KHO scratch 区域分配，满足安全启动或崩溃转储等场景。\n- **调试与分析**：通过 debugfs 接口（未在片段中体现）导出 memblock 布局，辅助内存问题诊断。",
      "similarity": 0.6304198503494263,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "mm/memblock.c",
          "start_line": 887,
          "end_line": 987,
          "content": [
            "int __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\", __func__,",
            "\t\t     &base, &end, (void *)_RET_IP_);",
            "",
            "\treturn memblock_remove_range(&memblock.memory, base, size);",
            "}",
            "void __init_memblock memblock_free(void *ptr, size_t size)",
            "{",
            "\tif (ptr)",
            "\t\tmemblock_phys_free(__pa(ptr), size);",
            "}",
            "int __init_memblock memblock_phys_free(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\", __func__,",
            "\t\t     &base, &end, (void *)_RET_IP_);",
            "",
            "\tkmemleak_free_part_phys(base, size);",
            "\treturn memblock_remove_range(&memblock.reserved, base, size);",
            "}",
            "int __init_memblock __memblock_reserve(phys_addr_t base, phys_addr_t size,",
            "\t\t\t\t       int nid, enum memblock_flags flags)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] nid=%d flags=%x %pS\\n\", __func__,",
            "\t\t     &base, &end, nid, flags, (void *)_RET_IP_);",
            "",
            "\treturn memblock_add_range(&memblock.reserved, base, size, nid, flags);",
            "}",
            "int __init_memblock memblock_physmem_add(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tphys_addr_t end = base + size - 1;",
            "",
            "\tmemblock_dbg(\"%s: [%pa-%pa] %pS\\n\", __func__,",
            "\t\t     &base, &end, (void *)_RET_IP_);",
            "",
            "\treturn memblock_add_range(&physmem, base, size, MAX_NUMNODES, 0);",
            "}",
            "__init void memblock_set_kho_scratch_only(void)",
            "{",
            "\tkho_scratch_only = true;",
            "}",
            "__init void memblock_clear_kho_scratch_only(void)",
            "{",
            "\tkho_scratch_only = false;",
            "}",
            "__init void memmap_init_kho_scratch_pages(void)",
            "{",
            "\tphys_addr_t start, end;",
            "\tunsigned long pfn;",
            "\tint nid;",
            "\tu64 i;",
            "",
            "\tif (!IS_ENABLED(CONFIG_DEFERRED_STRUCT_PAGE_INIT))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Initialize struct pages for free scratch memory.",
            "\t * The struct pages for reserved scratch memory will be set up in",
            "\t * reserve_bootmem_region()",
            "\t */",
            "\t__for_each_mem_range(i, &memblock.memory, NULL, NUMA_NO_NODE,",
            "\t\t\t     MEMBLOCK_KHO_SCRATCH, &start, &end, &nid) {",
            "\t\tfor (pfn = PFN_UP(start); pfn < PFN_DOWN(end); pfn++)",
            "\t\t\tinit_deferred_page(pfn, nid);",
            "\t}",
            "}",
            "static int __init_memblock memblock_setclr_flag(struct memblock_type *type,",
            "\t\t\t\tphys_addr_t base, phys_addr_t size, int set, int flag)",
            "{",
            "\tint i, ret, start_rgn, end_rgn;",
            "",
            "\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tfor (i = start_rgn; i < end_rgn; i++) {",
            "\t\tstruct memblock_region *r = &type->regions[i];",
            "",
            "\t\tif (set)",
            "\t\t\tr->flags |= flag;",
            "\t\telse",
            "\t\t\tr->flags &= ~flag;",
            "\t}",
            "",
            "\tmemblock_merge_regions(type, start_rgn, end_rgn);",
            "\treturn 0;",
            "}",
            "int __init_memblock memblock_mark_hotplug(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 1, MEMBLOCK_HOTPLUG);",
            "}",
            "int __init_memblock memblock_clear_hotplug(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_setclr_flag(&memblock.memory, base, size, 0, MEMBLOCK_HOTPLUG);",
            "}"
          ],
          "function_name": "memblock_remove, memblock_free, memblock_phys_free, __memblock_reserve, memblock_physmem_add, memblock_set_kho_scratch_only, memblock_clear_kho_scratch_only, memmap_init_kho_scratch_pages, memblock_setclr_flag, memblock_mark_hotplug, memblock_clear_hotplug",
          "description": "定义并实现内存块操作函数，用于移除/释放内存区域，标记预留内存属性，初始化KHO_SCRATCH页结构，并通过memblock_setclr_flag修改内存区域标志位，支持热插拔、镜像等特性",
          "similarity": 0.5977039337158203
        },
        {
          "chunk_id": 12,
          "file_path": "mm/memblock.c",
          "start_line": 2233,
          "end_line": 2340,
          "content": [
            "static void __init __free_pages_memory(unsigned long start, unsigned long end)",
            "{",
            "\tint order;",
            "",
            "\twhile (start < end) {",
            "\t\t/*",
            "\t\t * Free the pages in the largest chunks alignment allows.",
            "\t\t *",
            "\t\t * __ffs() behaviour is undefined for 0. start == 0 is",
            "\t\t * MAX_PAGE_ORDER-aligned, set order to MAX_PAGE_ORDER for",
            "\t\t * the case.",
            "\t\t */",
            "\t\tif (start)",
            "\t\t\torder = min_t(int, MAX_PAGE_ORDER, __ffs(start));",
            "\t\telse",
            "\t\t\torder = MAX_PAGE_ORDER;",
            "",
            "\t\twhile (start + (1UL << order) > end)",
            "\t\t\torder--;",
            "",
            "\t\tmemblock_free_pages(pfn_to_page(start), start, order);",
            "",
            "\t\tstart += (1UL << order);",
            "\t}",
            "}",
            "static unsigned long __init __free_memory_core(phys_addr_t start,",
            "\t\t\t\t phys_addr_t end)",
            "{",
            "\tunsigned long start_pfn = PFN_UP(start);",
            "\tunsigned long end_pfn = min_t(unsigned long,",
            "\t\t\t\t      PFN_DOWN(end), max_low_pfn);",
            "",
            "\tif (start_pfn >= end_pfn)",
            "\t\treturn 0;",
            "",
            "\t__free_pages_memory(start_pfn, end_pfn);",
            "",
            "\treturn end_pfn - start_pfn;",
            "}",
            "static void __init memmap_init_reserved_pages(void)",
            "{",
            "\tstruct memblock_region *region;",
            "\tphys_addr_t start, end;",
            "\tint nid;",
            "\tunsigned long max_reserved;",
            "",
            "\t/*",
            "\t * set nid on all reserved pages and also treat struct",
            "\t * pages for the NOMAP regions as PageReserved",
            "\t */",
            "repeat:",
            "\tmax_reserved = memblock.reserved.max;",
            "\tfor_each_mem_region(region) {",
            "\t\tnid = memblock_get_region_node(region);",
            "\t\tstart = region->base;",
            "\t\tend = start + region->size;",
            "",
            "\t\tif (memblock_is_nomap(region))",
            "\t\t\treserve_bootmem_region(start, end, nid);",
            "",
            "\t\tmemblock_set_node(start, region->size, &memblock.reserved, nid);",
            "\t}",
            "\t/*",
            "\t * 'max' is changed means memblock.reserved has been doubled its",
            "\t * array, which may result a new reserved region before current",
            "\t * 'start'. Now we should repeat the procedure to set its node id.",
            "\t */",
            "\tif (max_reserved != memblock.reserved.max)",
            "\t\tgoto repeat;",
            "",
            "\t/*",
            "\t * initialize struct pages for reserved regions that don't have",
            "\t * the MEMBLOCK_RSRV_NOINIT flag set",
            "\t */",
            "\tfor_each_reserved_mem_region(region) {",
            "\t\tif (!memblock_is_reserved_noinit(region)) {",
            "\t\t\tnid = memblock_get_region_node(region);",
            "\t\t\tstart = region->base;",
            "\t\t\tend = start + region->size;",
            "",
            "\t\t\tif (!numa_valid_node(nid))",
            "\t\t\t\tnid = early_pfn_to_nid(PFN_DOWN(start));",
            "",
            "\t\t\treserve_bootmem_region(start, end, nid);",
            "\t\t}",
            "\t}",
            "}",
            "static unsigned long __init free_low_memory_core_early(void)",
            "{",
            "\tunsigned long count = 0;",
            "\tphys_addr_t start, end;",
            "\tu64 i;",
            "",
            "\tmemblock_clear_hotplug(0, -1);",
            "",
            "\tmemmap_init_reserved_pages();",
            "",
            "\t/*",
            "\t * We need to use NUMA_NO_NODE instead of NODE_DATA(0)->node_id",
            "\t *  because in some case like Node0 doesn't have RAM installed",
            "\t *  low ram will be on Node1",
            "\t */",
            "\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,",
            "\t\t\t\tNULL)",
            "\t\tcount += __free_memory_core(start, end);",
            "",
            "\treturn count;",
            "}"
          ],
          "function_name": "__free_pages_memory, __free_memory_core, memmap_init_reserved_pages, free_low_memory_core_early",
          "description": "核心实现内存页面释放逻辑，初始化保留区域页结构并处理低内存核心区域的提前释放操作",
          "similarity": 0.5951744318008423
        },
        {
          "chunk_id": 10,
          "file_path": "mm/memblock.c",
          "start_line": 1954,
          "end_line": 2057,
          "content": [
            "void __init memblock_mem_limit_remove_map(phys_addr_t limit)",
            "{",
            "\tphys_addr_t max_addr;",
            "",
            "\tif (!limit)",
            "\t\treturn;",
            "",
            "\tmax_addr = __find_max_addr(limit);",
            "",
            "\t/* @limit exceeds the total size of the memory, do nothing */",
            "\tif (max_addr == PHYS_ADDR_MAX)",
            "\t\treturn;",
            "",
            "\tmemblock_cap_memory_range(0, max_addr);",
            "}",
            "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)",
            "{",
            "\tunsigned int left = 0, right = type->cnt;",
            "",
            "\tdo {",
            "\t\tunsigned int mid = (right + left) / 2;",
            "",
            "\t\tif (addr < type->regions[mid].base)",
            "\t\t\tright = mid;",
            "\t\telse if (addr >= (type->regions[mid].base +",
            "\t\t\t\t  type->regions[mid].size))",
            "\t\t\tleft = mid + 1;",
            "\t\telse",
            "\t\t\treturn mid;",
            "\t} while (left < right);",
            "\treturn -1;",
            "}",
            "bool __init_memblock memblock_is_reserved(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.reserved, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_memory(phys_addr_t addr)",
            "{",
            "\treturn memblock_search(&memblock.memory, addr) != -1;",
            "}",
            "bool __init_memblock memblock_is_map_memory(phys_addr_t addr)",
            "{",
            "\tint i = memblock_search(&memblock.memory, addr);",
            "",
            "\tif (i == -1)",
            "\t\treturn false;",
            "\treturn !memblock_is_nomap(&memblock.memory.regions[i]);",
            "}",
            "int __init_memblock memblock_search_pfn_nid(unsigned long pfn,",
            "\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)",
            "{",
            "\tstruct memblock_type *type = &memblock.memory;",
            "\tint mid = memblock_search(type, PFN_PHYS(pfn));",
            "",
            "\tif (mid == -1)",
            "\t\treturn -1;",
            "",
            "\t*start_pfn = PFN_DOWN(type->regions[mid].base);",
            "\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);",
            "",
            "\treturn memblock_get_region_node(&type->regions[mid]);",
            "}",
            "bool __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)",
            "{",
            "\tint idx = memblock_search(&memblock.memory, base);",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "",
            "\tif (idx == -1)",
            "\t\treturn false;",
            "\treturn (memblock.memory.regions[idx].base +",
            "\t\t memblock.memory.regions[idx].size) >= end;",
            "}",
            "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)",
            "{",
            "\treturn memblock_overlaps_region(&memblock.reserved, base, size);",
            "}",
            "void __init_memblock memblock_trim_memory(phys_addr_t align)",
            "{",
            "\tphys_addr_t start, end, orig_start, orig_end;",
            "\tstruct memblock_region *r;",
            "",
            "\tfor_each_mem_region(r) {",
            "\t\torig_start = r->base;",
            "\t\torig_end = r->base + r->size;",
            "\t\tstart = round_up(orig_start, align);",
            "\t\tend = round_down(orig_end, align);",
            "",
            "\t\tif (start == orig_start && end == orig_end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start < end) {",
            "\t\t\tr->base = start;",
            "\t\t\tr->size = end - start;",
            "\t\t} else {",
            "\t\t\tmemblock_remove_region(&memblock.memory,",
            "\t\t\t\t\t       r - memblock.memory.regions);",
            "\t\t\tr--;",
            "\t\t}",
            "\t}",
            "}",
            "void __init_memblock memblock_set_current_limit(phys_addr_t limit)",
            "{",
            "\tmemblock.current_limit = limit;",
            "}"
          ],
          "function_name": "memblock_mem_limit_remove_map, memblock_search, memblock_is_reserved, memblock_is_memory, memblock_is_map_memory, memblock_search_pfn_nid, memblock_is_region_memory, memblock_is_region_reserved, memblock_trim_memory, memblock_set_current_limit",
          "description": "实现内存块限制移除、搜索和区域判断逻辑，用于管理内存和保留区域的地址范围查询及修剪操作",
          "similarity": 0.5876178741455078
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memblock.c",
          "start_line": 537,
          "end_line": 685,
          "content": [
            "static void __init_memblock memblock_merge_regions(struct memblock_type *type,",
            "\t\t\t\t\t\t   unsigned long start_rgn,",
            "\t\t\t\t\t\t   unsigned long end_rgn)",
            "{",
            "\tint i = 0;",
            "\tif (start_rgn)",
            "\t\ti = start_rgn - 1;",
            "\tend_rgn = min(end_rgn, type->cnt - 1);",
            "\twhile (i < end_rgn) {",
            "\t\tstruct memblock_region *this = &type->regions[i];",
            "\t\tstruct memblock_region *next = &type->regions[i + 1];",
            "",
            "\t\tif (this->base + this->size != next->base ||",
            "\t\t    memblock_get_region_node(this) !=",
            "\t\t    memblock_get_region_node(next) ||",
            "\t\t    this->flags != next->flags) {",
            "\t\t\tBUG_ON(this->base + this->size > next->base);",
            "\t\t\ti++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tthis->size += next->size;",
            "\t\t/* move forward from next + 1, index of which is i + 2 */",
            "\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));",
            "\t\ttype->cnt--;",
            "\t\tend_rgn--;",
            "\t}",
            "}",
            "static void __init_memblock memblock_insert_region(struct memblock_type *type,",
            "\t\t\t\t\t\t   int idx, phys_addr_t base,",
            "\t\t\t\t\t\t   phys_addr_t size,",
            "\t\t\t\t\t\t   int nid,",
            "\t\t\t\t\t\t   enum memblock_flags flags)",
            "{",
            "\tstruct memblock_region *rgn = &type->regions[idx];",
            "",
            "\tBUG_ON(type->cnt >= type->max);",
            "\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));",
            "\trgn->base = base;",
            "\trgn->size = size;",
            "\trgn->flags = flags;",
            "\tmemblock_set_region_node(rgn, nid);",
            "\ttype->cnt++;",
            "\ttype->total_size += size;",
            "}",
            "static int __init_memblock memblock_add_range(struct memblock_type *type,",
            "\t\t\t\tphys_addr_t base, phys_addr_t size,",
            "\t\t\t\tint nid, enum memblock_flags flags)",
            "{",
            "\tbool insert = false;",
            "\tphys_addr_t obase = base;",
            "\tphys_addr_t end = base + memblock_cap_size(base, &size);",
            "\tint idx, nr_new, start_rgn = -1, end_rgn;",
            "\tstruct memblock_region *rgn;",
            "",
            "\tif (!size)",
            "\t\treturn 0;",
            "",
            "\t/* special case for empty array */",
            "\tif (type->regions[0].size == 0) {",
            "\t\tWARN_ON(type->cnt != 1 || type->total_size);",
            "\t\ttype->regions[0].base = base;",
            "\t\ttype->regions[0].size = size;",
            "\t\ttype->regions[0].flags = flags;",
            "\t\tmemblock_set_region_node(&type->regions[0], nid);",
            "\t\ttype->total_size = size;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * The worst case is when new range overlaps all existing regions,",
            "\t * then we'll need type->cnt + 1 empty regions in @type. So if",
            "\t * type->cnt * 2 + 1 is less than or equal to type->max, we know",
            "\t * that there is enough empty regions in @type, and we can insert",
            "\t * regions directly.",
            "\t */",
            "\tif (type->cnt * 2 + 1 <= type->max)",
            "\t\tinsert = true;",
            "",
            "repeat:",
            "\t/*",
            "\t * The following is executed twice.  Once with %false @insert and",
            "\t * then with %true.  The first counts the number of regions needed",
            "\t * to accommodate the new area.  The second actually inserts them.",
            "\t */",
            "\tbase = obase;",
            "\tnr_new = 0;",
            "",
            "\tfor_each_memblock_type(idx, type, rgn) {",
            "\t\tphys_addr_t rbase = rgn->base;",
            "\t\tphys_addr_t rend = rbase + rgn->size;",
            "",
            "\t\tif (rbase >= end)",
            "\t\t\tbreak;",
            "\t\tif (rend <= base)",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * @rgn overlaps.  If it separates the lower part of new",
            "\t\t * area, insert that portion.",
            "\t\t */",
            "\t\tif (rbase > base) {",
            "#ifdef CONFIG_NUMA",
            "\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));",
            "#endif",
            "\t\t\tWARN_ON(flags != MEMBLOCK_NONE && flags != rgn->flags);",
            "\t\t\tnr_new++;",
            "\t\t\tif (insert) {",
            "\t\t\t\tif (start_rgn == -1)",
            "\t\t\t\t\tstart_rgn = idx;",
            "\t\t\t\tend_rgn = idx + 1;",
            "\t\t\t\tmemblock_insert_region(type, idx++, base,",
            "\t\t\t\t\t\t       rbase - base, nid,",
            "\t\t\t\t\t\t       flags);",
            "\t\t\t}",
            "\t\t}",
            "\t\t/* area below @rend is dealt with, forget about it */",
            "\t\tbase = min(rend, end);",
            "\t}",
            "",
            "\t/* insert the remaining portion */",
            "\tif (base < end) {",
            "\t\tnr_new++;",
            "\t\tif (insert) {",
            "\t\t\tif (start_rgn == -1)",
            "\t\t\t\tstart_rgn = idx;",
            "\t\t\tend_rgn = idx + 1;",
            "\t\t\tmemblock_insert_region(type, idx, base, end - base,",
            "\t\t\t\t\t       nid, flags);",
            "\t\t}",
            "\t}",
            "",
            "\tif (!nr_new)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * If this was the first round, resize array and repeat for actual",
            "\t * insertions; otherwise, merge and return.",
            "\t */",
            "\tif (!insert) {",
            "\t\twhile (type->cnt + nr_new > type->max)",
            "\t\t\tif (memblock_double_array(type, obase, size) < 0)",
            "\t\t\t\treturn -ENOMEM;",
            "\t\tinsert = true;",
            "\t\tgoto repeat;",
            "\t} else {",
            "\t\tmemblock_merge_regions(type, start_rgn, end_rgn);",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "function_name": "memblock_merge_regions, memblock_insert_region, memblock_add_range",
          "description": "实现内存区域合并（merge_regions）与插入（insert_region）逻辑，处理新增内存范围的拆分与整合，优化连续区域管理。",
          "similarity": 0.5868642330169678
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memblock.c",
          "start_line": 192,
          "end_line": 297,
          "content": [
            "static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)",
            "{",
            "\treturn *size = min(*size, PHYS_ADDR_MAX - base);",
            "}",
            "unsigned long __init_memblock",
            "memblock_addrs_overlap(phys_addr_t base1, phys_addr_t size1, phys_addr_t base2,",
            "\t\t       phys_addr_t size2)",
            "{",
            "\treturn ((base1 < (base2 + size2)) && (base2 < (base1 + size1)));",
            "}",
            "bool __init_memblock memblock_overlaps_region(struct memblock_type *type,",
            "\t\t\t\t\tphys_addr_t base, phys_addr_t size)",
            "{",
            "\tunsigned long i;",
            "",
            "\tmemblock_cap_size(base, &size);",
            "",
            "\tfor (i = 0; i < type->cnt; i++)",
            "\t\tif (memblock_addrs_overlap(base, size, type->regions[i].base,",
            "\t\t\t\t\t   type->regions[i].size))",
            "\t\t\tbreak;",
            "\treturn i < type->cnt;",
            "}",
            "static phys_addr_t __init_memblock",
            "__memblock_find_range_bottom_up(phys_addr_t start, phys_addr_t end,",
            "\t\t\t\tphys_addr_t size, phys_addr_t align, int nid,",
            "\t\t\t\tenum memblock_flags flags)",
            "{",
            "\tphys_addr_t this_start, this_end, cand;",
            "\tu64 i;",
            "",
            "\tfor_each_free_mem_range(i, nid, flags, &this_start, &this_end, NULL) {",
            "\t\tthis_start = clamp(this_start, start, end);",
            "\t\tthis_end = clamp(this_end, start, end);",
            "",
            "\t\tcand = round_up(this_start, align);",
            "\t\tif (cand < this_end && this_end - cand >= size)",
            "\t\t\treturn cand;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static phys_addr_t __init_memblock",
            "__memblock_find_range_top_down(phys_addr_t start, phys_addr_t end,",
            "\t\t\t       phys_addr_t size, phys_addr_t align, int nid,",
            "\t\t\t       enum memblock_flags flags)",
            "{",
            "\tphys_addr_t this_start, this_end, cand;",
            "\tu64 i;",
            "",
            "\tfor_each_free_mem_range_reverse(i, nid, flags, &this_start, &this_end,",
            "\t\t\t\t\tNULL) {",
            "\t\tthis_start = clamp(this_start, start, end);",
            "\t\tthis_end = clamp(this_end, start, end);",
            "",
            "\t\tif (this_end < size)",
            "\t\t\tcontinue;",
            "",
            "\t\tcand = round_down(this_end - size, align);",
            "\t\tif (cand >= this_start)",
            "\t\t\treturn cand;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,",
            "\t\t\t\t\tphys_addr_t align, phys_addr_t start,",
            "\t\t\t\t\tphys_addr_t end, int nid,",
            "\t\t\t\t\tenum memblock_flags flags)",
            "{",
            "\t/* pump up @end */",
            "\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE ||",
            "\t    end == MEMBLOCK_ALLOC_NOLEAKTRACE)",
            "\t\tend = memblock.current_limit;",
            "",
            "\t/* avoid allocating the first page */",
            "\tstart = max_t(phys_addr_t, start, PAGE_SIZE);",
            "\tend = max(start, end);",
            "",
            "\tif (memblock_bottom_up())",
            "\t\treturn __memblock_find_range_bottom_up(start, end, size, align,",
            "\t\t\t\t\t\t       nid, flags);",
            "\telse",
            "\t\treturn __memblock_find_range_top_down(start, end, size, align,",
            "\t\t\t\t\t\t      nid, flags);",
            "}",
            "static phys_addr_t __init_memblock memblock_find_in_range(phys_addr_t start,",
            "\t\t\t\t\tphys_addr_t end, phys_addr_t size,",
            "\t\t\t\t\tphys_addr_t align)",
            "{",
            "\tphys_addr_t ret;",
            "\tenum memblock_flags flags = choose_memblock_flags();",
            "",
            "again:",
            "\tret = memblock_find_in_range_node(size, align, start, end,",
            "\t\t\t\t\t    NUMA_NO_NODE, flags);",
            "",
            "\tif (!ret && (flags & MEMBLOCK_MIRROR)) {",
            "\t\tpr_warn_ratelimited(\"Could not allocate %pap bytes of mirrored memory\\n\",",
            "\t\t\t&size);",
            "\t\tflags &= ~MEMBLOCK_MIRROR;",
            "\t\tgoto again;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "memblock_cap_size, memblock_addrs_overlap, memblock_overlaps_region, __memblock_find_range_bottom_up, __memblock_find_range_top_down, memblock_find_in_range_node, memblock_find_in_range",
          "description": "实现内存区域地址重叠检测与分配策略选择逻辑，包含范围查找算法（底向顶/顶向底）及镜像内存分配失败回退机制。",
          "similarity": 0.585008978843689
        }
      ]
    }
  ]
}