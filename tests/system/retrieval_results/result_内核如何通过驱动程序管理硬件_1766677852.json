{
  "query": "内核如何通过驱动程序管理硬件",
  "timestamp": "2025-12-25 23:50:52",
  "retrieved_files": [
    {
      "source_file": "kernel/hardware_message.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:43:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `hardware_message.c`\n\n---\n\n# hardware_message.c 技术文档\n\n## 文件概述\n\n`hardware_message.c` 是麒麟操作系统（Kylin Linux Advanced Desktop/Server，简称 KLAS/KLAD）内核中用于向用户发出硬件或驱动程序支持状态警告的专用模块。该文件定义了一系列函数，用于在内核启动或驱动加载过程中，根据硬件或驱动的生命周期状态（如“已弃用”、“不再维护”、“已禁用”或“技术预览”）向系统日志输出高优先级的 `pr_crit()` 警告信息。这些函数仅在启用了 `CONFIG_KYLIN_DIFFERENCES` 内核配置选项时生效，体现了麒麟操作系统对特定硬件兼容性与支持策略的管理机制。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `mark_hardware_unmaintained()` | 标记特定硬件设备为“不再维护”，输出包含设备描述的严重警告 |\n| `mark_driver_unmaintained()` | 标记驱动程序为“不再维护”，适用于无法关联具体硬件的通用驱动 |\n| `mark_hardware_deprecated()` | 标记特定硬件为“已弃用”，提示将在未来版本停止维护 |\n| `mark_driver_deprecated()` | 标记驱动为“已弃用”，适用于抽象或高层驱动 |\n| `mark_hardware_disabled()` | 标记硬件支持已被完全禁用，设备无法在当前版本使用 |\n| `mark_tech_preview()` | 标记驱动或子系统为“技术预览”状态（函数声明未完整实现） |\n\n### 数据结构与常量\n\n- `DEV_DESC_LEN`：定义设备描述字符串的最大长度（256 字节）\n- 使用 `va_list` 和可变参数处理设备描述格式化\n\n### 导出符号\n\n所有上述函数均通过 `EXPORT_SYMBOL()` 导出，可供其他内核模块调用。\n\n## 关键实现\n\n### 条件编译控制\n\n所有函数的实现均被 `#ifdef CONFIG_KYLIN_DIFFERENCES` 包裹，确保仅在麒麟定制内核中启用该功能，避免对上游 Linux 内核造成影响。\n\n### 驱动/模块名称解析逻辑\n\n函数优先使用传入的 `driver_name` 参数；若为空且启用了 `CONFIG_MODULES`，则回退到从 `struct module *mod` 中提取模块名；若两者均不可用，则使用默认字符串 `\"Kernel\"`。\n\n### 可变参数处理\n\n对于硬件相关的函数（`_hardware_*`），使用 `va_start`/`vsnprintf`/`va_end` 机制格式化设备描述信息，支持动态构造设备标识（如 PCI ID、设备型号等）。\n\n### 日志级别\n\n统一使用 `pr_crit()` 输出 **Critical** 级别日志，确保警告信息在系统日志中高亮显示，引起管理员注意。\n\n### 生命周期状态语义\n\n- **Deprecated（已弃用）**：当前仍可用，但计划在未来主版本中转为“不再维护”或“禁用”\n- **Unmaintained（不再维护）**：仅修复安全或严重问题，常规更新已停止\n- **Disabled（已禁用）**：当前版本已完全移除支持\n- **Tech Preview（技术预览）**：新功能，测试有限，不保证稳定性与支持（函数未完整实现）\n\n## 依赖关系\n\n### 头文件依赖\n\n- `<linux/kernel.h>`：提供 `pr_crit()`、`vsnprintf()`、`va_list` 等内核日志与字符串处理接口\n- `<linux/module.h>`：提供 `struct module` 定义及模块相关信息\n\n### 内核配置依赖\n\n- **必需**：`CONFIG_KYLIN_DIFFERENCES` — 启用麒麟特有差异功能\n- **可选**：`CONFIG_MODULES` — 支持从模块指针获取名称（若未启用模块，则跳过该路径）\n\n### 符号导出\n\n所有函数通过 `EXPORT_SYMBOL()` 导出，供其他驱动模块在初始化时调用，以声明自身支持状态。\n\n## 使用场景\n\n1. **驱动弃用通知**  \n   当某硬件厂商停止维护某款网卡，麒麟内核团队决定在下一主版本移除支持。当前版本中，该驱动在 `probe()` 时调用 `mark_hardware_deprecated()`，提示用户规划迁移。\n\n2. **通用驱动生命周期管理**  \n   某旧版 RAID 管理驱动因上游废弃，麒麟将其标记为“不再维护”，调用 `mark_driver_unmaintained()`，适用于所有使用该驱动的系统。\n\n3. **已禁用硬件检测**  \n   用户尝试加载已被内核配置禁用的旧显卡驱动，驱动框架调用 `mark_hardware_disabled()` 明确告知设备不可用。\n\n4. **新技术预览**  \n   引入实验性文件系统或新硬件支持时，通过 `mark_tech_preview()` 声明其非生产就绪状态（注：当前代码中该函数未实现完整逻辑）。\n\n5. **发布合规性**  \n   所有调用必须记录于 KLAS/KLAD 发行说明，并获得管理层审批，确保用户对硬件支持变更有明确预期。",
      "similarity": 0.6349384188652039,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/hardware_message.c",
          "start_line": 44,
          "end_line": 145,
          "content": [
            "void mark_hardware_unmaintained(const char *driver_name, struct module *mod,",
            "\t\t\t\tchar *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Unmaintained hardware is detected: %s:%s\\n\",",
            "\t\tname ?: \"Kernel\",",
            "\t\tdevice_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_driver_unmaintained(const char *driver_name, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tpr_crit(\"Warning: Unmaintained driver is detected: %s\\n\",",
            "\t\tname ?: \"Kernel\");",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_hardware_deprecated(const char *driver_name, struct module *mod,",
            "\t\t\t      char *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Deprecated Hardware is detected: %s:%s will not be \"",
            "\t\t\"maintained in a future major release and may be disabled.\\n\",",
            "\t\tname ?: \"Kernel\", device_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_driver_deprecated(const char *driver_name, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tpr_crit(\"Warning: Deprecated Driver is detected: %s will not be \"",
            "\t\t\"maintained in a future major release and may be disabled.\\n\",",
            "\t\tname ?: \"Kernel\");",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_hardware_disabled(const char *driver_name, struct module *mod,",
            "\t\t\t    char *fmt, ...)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tchar device_description[DEV_DESC_LEN];",
            "\tva_list args;",
            "\tconst char *name = NULL;",
            "",
            "\tif (driver_name)",
            "\t\tname = driver_name;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tname = mod->name;",
            "#endif",
            "",
            "\tva_start(args, fmt);",
            "\tvsnprintf(device_description, DEV_DESC_LEN, fmt, args);",
            "\tpr_crit(\"Warning: Disabled Hardware is detected: %s:%s is no longer \"",
            "\t\t\"enabled in this release.\\n\",",
            "\t\tname ?: \"Kernel\", device_description);",
            "\tva_end(args);",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}"
          ],
          "function_name": "mark_hardware_unmaintained, mark_driver_unmaintained, mark_hardware_deprecated, mark_driver_deprecated, mark_hardware_disabled",
          "description": "实现了标记硬件/驱动状态的五个函数，通过变参处理构建设备描述信息并输出内核警告日志，核心功能是根据配置条件触发不同级别硬件/驱动支持状态的警告提示",
          "similarity": 0.6228222846984863
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/hardware_message.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Author: Jackie Liu <liuyun01@kylinos.cn>",
            " * Copyright (C) 2024, KylinSoft Corporation.",
            " *",
            " * The following functions are used by 'Kylin Linux Advanced Desktop/Server",
            " * Operation System' to indicate to users that hardware and drivers are",
            " * unsupported, or have limited support in KLAS/KLAD major and minor releases.",
            " * These functions output loud warning messages to the end user and should",
            " * be USED WITH CAUTION.",
            " *",
            " * Any use of these functions _MUST_ be documented in the KLAS/KLAD Release",
            " * Notes, and have approval of management.",
            " *",
            " * Generally, the process of disabling a driver or device in KLAS/KLAD requires",
            " * the driver or device to be marked as 'deprecated' in all existing releases,",
            " * and then either 'unmaintained' or 'disabled' in a future release.",
            " *",
            " * In general, deprecated and unmaintained drivers continue to receive security",
            " * related fixes until they are disabled.",
            " */",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "",
            "#define DEV_DESC_LEN 256",
            "",
            "/**",
            " * mark_hardware_unmaintained() - Mark hardware as unmaintained.",
            " * @driver_name: driver name",
            " * @mod: module pointer",
            " * @fmt: format for device description",
            " * @...: args for device description",
            " *",
            " * Called to notify users that the device will no longer be tested on a routine",
            " * basis and driver code associated with this device is no longer being updated.",
            " * KYLIN may fix security-related and critical issues. Support for this device",
            " * will be disabled in a future major release and users deploying this device",
            " * should plan to replace the device in production systems.",
            " *",
            " * This function should be used when the driver's usage can be tied to a",
            " * specific hardware device. For example, a network device driver loading on a",
            " * specific device that is no longer maintained by the manufacturer.",
            " */"
          ],
          "function_name": null,
          "description": "此代码块定义了用于标记硬件和驱动状态的函数原型，描述了各函数的用途及使用规范，核心功能是通知用户硬件/驱动的支持状态变化，但未提供函数实现，上下文不完整",
          "similarity": 0.5878280997276306
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/hardware_message.c",
          "start_line": 230,
          "end_line": 283,
          "content": [
            "void mark_tech_preview(const char *msg, struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *str = NULL;",
            "",
            "\tif (msg)",
            "\t\tstr = msg;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tstr = mod->name;",
            "#endif",
            "",
            "\tpr_warn(\"TECH PREVIEW: %s may not be fully supported.\\n\"",
            "\t\t\"Please review provided documentation for limitations.\\n\",",
            "\t\tstr ?: \"kernel\");",
            "\tadd_taint(TAINT_AUX, LOCKDEP_STILL_OK);",
            "#ifdef CONFIG_MODULES",
            "\tif (mod)",
            "\t\tmod->taints |= (1U << TAINT_AUX);",
            "#endif",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_partner_supported(const char *msg, const char *partner,",
            "\t\t\t    struct module *mod)",
            "{",
            "#ifdef CONFIG_KYLIN_DIFFERENCES",
            "\tconst char *str = NULL;",
            "",
            "\tif (msg)",
            "\t\tstr = msg;",
            "#ifdef CONFIG_MODULES",
            "\telse if (mod)",
            "\t\tstr = mod->name;",
            "#endif",
            "",
            "\tpr_warn(\"Warning: %s is a partner (%s) supported and not supported \"",
            "\t\t\"directly by KylinSoft Corporation.\\n\",",
            "\t\tstr ?: \"Kernel\", partner ?: \"Unknown\");",
            "\tadd_taint(TAINT_PARTNER_SUPPORTED, LOCKDEP_STILL_OK);",
            "#ifdef CONFIG_MODULES",
            "\tif (mod)",
            "\t\tmod->taints |= (1U << TAINT_PARTNER_SUPPORTED);",
            "#endif",
            "#endif /* CONFIG_KYLIN_DIFFERENCES */",
            "}",
            "void mark_partner_supported_module(const char *partner, struct module *mod)",
            "{",
            "#if defined(CONFIG_KYLIN_DIFFERENCES) && defined(CONFIG_MODULES)",
            "\tif (!mod)",
            "\t\treturn;",
            "",
            "\tmark_partner_supported(NULL, partner, mod);",
            "#endif",
            "}"
          ],
          "function_name": "mark_tech_preview, mark_partner_supported, mark_partner_supported_module",
          "description": "实现了与合作伙伴支持相关联的标记函数，通过添加特定污点标识和模块状态修改，核心功能是标注技术预览特性或第三方合作组件的非官方支持状态",
          "similarity": 0.47839415073394775
        }
      ]
    },
    {
      "source_file": "mm/memory_hotplug.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:43:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memory_hotplug.c`\n\n---\n\n# memory_hotplug.c 技术文档\n\n## 1. 文件概述\n\n`memory_hotplug.c` 是 Linux 内核中实现内存热插拔（Memory Hotplug）功能的核心源文件，位于 `mm/` 子系统目录下。该文件提供了在系统运行时动态添加或移除物理内存区域的能力，包括内存资源注册、页表映射管理、内存上线策略控制、以及与 NUMA 架构的协同支持。它主要处理热添加内存时的初始化、内存块（memory block）管理、vmemmap 映射优化、以及在线策略配置等关键逻辑。\n\n## 2. 核心功能\n\n### 主要全局变量与参数\n- `memmap_mode`：控制是否启用“内存上的 memmap”（memmap on memory）特性，支持 `disable`、`enable` 和 `force` 三种模式。\n- `online_policy`：定义内存上线时的默认区域分配策略，可选 `contig-zones`（保持区域连续）或 `auto-movable`（自动分配到 ZONE_MOVABLE）。\n- `auto_movable_ratio`：在 `auto-movable` 策略下，系统允许的 MOVABLE 与 KERNEL 内存的最大百分比比例（默认 301%，即约 3:1）。\n- `auto_movable_numa_aware`（仅 CONFIG_NUMA）：是否在 `auto-movable` 策略中考虑 NUMA 节点级别的内存统计。\n- `mhp_default_online_type`：内存热插拔时的默认上线类型（如 `MMOP_ONLINE_KERNEL`、`MMOP_ONLINE_MOVABLE` 等）。\n- `movable_node_enabled`：标志是否启用了可移动节点（movable node）功能。\n- `max_mem_size`：系统允许的最大内存大小上限（默认为 `U64_MAX`）。\n\n### 主要函数与接口\n- `get_online_mems()` / `put_online_mems()`：获取/释放内存热插拔读锁，用于保护内存上线/下线操作。\n- `mem_hotplug_begin()` / `mem_hotplug_done()`：执行内存热插拔写操作前后的同步原语，同时持有 CPU 热插拔读锁和内存热插拔写锁。\n- `mhp_get_default_online_type()` / `mhp_set_default_online_type()`：获取或设置内存热插拔的默认上线类型。\n- `register_memory_resource()`：将新添加的内存区域注册为 I/O 资源（`System RAM` 类型），并检查是否超出 `max_mem_size` 限制。\n- `mhp_memmap_on_memory()`：判断当前是否启用了 memmap on memory 特性。\n- `memory_block_memmap_on_memory_pages()`：计算在 memmap on memory 模式下，每个内存块所需的额外页数（可能因对齐而浪费内存）。\n\n### 回调机制\n- `online_page_callback`：指向当前用于上线单个页面的回调函数，默认为 `generic_online_page`。\n- `set_online_page_callback()` / `restore_online_page_callback()`（声明未在片段中，但有注释说明）：用于动态替换或恢复页面上线回调。\n\n### 内核参数（module_param）\n- `memmap_on_memory`：启用 memmap on memory 功能（Y/N/force）。\n- `online_policy`：设置默认上线策略。\n- `auto_movable_ratio`：设置 MOVABLE/KERNEL 内存比例上限。\n- `auto_movable_numa_aware`：是否在 NUMA 感知下应用 auto-movable 策略。\n- 启动参数 `memhp_default_state=`：通过内核命令行设置默认上线状态。\n\n## 3. 关键实现\n\n### Memmap on Memory 机制\n当启用 `CONFIG_MHP_MEMMAP_ON_MEMORY` 时，内核尝试将描述物理页的 `struct page` 数组（即 vmemmap）直接放置在待热插拔的内存区域内，而非依赖预先保留的虚拟地址空间。这减少了对固定 vmemmap 区域的依赖，提升灵活性：\n- **ENABLE 模式**：仅当 vmemmap 大小能被页块（pageblock）整除时才启用。\n- **FORCE 模式**：强制对齐到页块边界，即使造成内存浪费（通过 `pageblock_align()` 实现），确保总能使用该内存区域存放 memmap。\n\n### 内存上线策略\n- **contig-zones（默认）**：将新内存添加到现有内存区域末尾，保持 ZONE_NORMAL 等区域的物理连续性。\n- **auto-movable**：根据全局（及 NUMA 节点）的 KERNEL 与 MOVABLE 内存比例，智能决定是否将新内存加入 ZONE_MOVABLE，以提高内存可迁移性和碎片整理效率。比例由 `auto_movable_ratio` 控制。\n\n### 并发控制\n使用 `percpu_rwsem mem_hotplug_lock` 作为内存热插拔操作的主同步机制：\n- 读操作（如内存访问路径）调用 `get/put_online_mems()` 获取读锁。\n- 写操作（如 add_memory）调用 `mem_hotplug_begin/done()` 获取写锁，并同时持有 `cpus_read_lock()` 防止 CPU 热插拔干扰。\n\n### 资源与大小限制\n- 通过 `mhp_range_allowed()` 检查待添加内存是否超出 `max_mem_size`。\n- 使用 `register_memory_resource()` 将内存注册为 `IORESOURCE_SYSTEM_RAM` 资源，若资源名非 \"System RAM\" 则标记为驱动管理（`IORESOURCE_SYSRAM_DRIVER_MANAGED`）。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `mm.h`、`page-isolation.h`、`migrate.h`、`compaction.h` 等，用于页面分配、隔离、迁移和压缩。\n- **体系结构相关**：包含 `asm/tlbflush.h` 用于 TLB 刷新；依赖 `pfn.h`、`memblock.h` 处理物理页帧和启动内存布局。\n- **设备模型与 sysfs**：通过 `memory.h` 与用户空间交互（如 `/sys/devices/system/memory/`）。\n- **NUMA 支持**：在 `CONFIG_NUMA` 下使用节点感知策略。\n- **虚拟内存**：依赖 `vmalloc.h` 和 `memremap.h` 管理 vmemmap 映射。\n- **电源管理**：包含 `suspend.h`，可能与休眠/唤醒流程协调。\n- **固件接口**：使用 `firmware-map.h` 与平台固件交互内存布局信息。\n\n## 5. 使用场景\n\n- **物理内存热添加**：在支持内存热插拔的服务器（如 IBM Power、x86 ACPI 系统）上，动态增加 DIMM 或内存模块后，内核通过此文件完成内存初始化和上线。\n- **虚拟化环境**：KVM、Xen 等 hypervisor 向客户机热添加内存时，客户机内核调用此模块处理新增内存。\n- **内存故障恢复**：在某些 RAS（Reliability, Availability, Serviceability）场景中，隔离坏页后重新上线备用内存。\n- **测试与开发**：通过 sysfs 接口（如 `echo online > /sys/devices/system/memory/memoryX/state`）手动上线内存块，配合 `online_policy` 和 `memmap_on_memory` 参数进行功能验证。\n- **容器与云平台**：支持弹性内存扩展，按需分配物理内存资源。",
      "similarity": 0.6334941387176514,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 1,
          "end_line": 51,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/mm/memory_hotplug.c",
            " *",
            " *  Copyright (C)",
            " */",
            "",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/cpu.h>",
            "#include <linux/memory.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/ioport.h>",
            "#include <linux/delay.h>",
            "#include <linux/migrate.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/pfn.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memblock.h>",
            "#include <linux/compaction.h>",
            "#include <linux/rmap.h>",
            "#include <linux/module.h>",
            "",
            "#include <asm/tlbflush.h>",
            "",
            "#include \"internal.h\"",
            "#include \"shuffle.h\"",
            "",
            "enum {",
            "\tMEMMAP_ON_MEMORY_DISABLE = 0,",
            "\tMEMMAP_ON_MEMORY_ENABLE,",
            "\tMEMMAP_ON_MEMORY_FORCE,",
            "};",
            "",
            "static int memmap_mode __read_mostly = MEMMAP_ON_MEMORY_DISABLE;",
            ""
          ],
          "function_name": null,
          "description": "声明内存热插拔相关枚举常量和全局变量，定义memmap_mode控制内存映射策略，包含必要的内核头文件和模块化实现依赖项。",
          "similarity": 0.5896293520927429
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 52,
          "end_line": 153,
          "content": [
            "static inline unsigned long memory_block_memmap_size(void)",
            "{",
            "\treturn PHYS_PFN(memory_block_size_bytes()) * sizeof(struct page);",
            "}",
            "static inline unsigned long memory_block_memmap_on_memory_pages(void)",
            "{",
            "\tunsigned long nr_pages = PFN_UP(memory_block_memmap_size());",
            "",
            "\t/*",
            "\t * In \"forced\" memmap_on_memory mode, we add extra pages to align the",
            "\t * vmemmap size to cover full pageblocks. That way, we can add memory",
            "\t * even if the vmemmap size is not properly aligned, however, we might waste",
            "\t * memory.",
            "\t */",
            "\tif (memmap_mode == MEMMAP_ON_MEMORY_FORCE)",
            "\t\treturn pageblock_align(nr_pages);",
            "\treturn nr_pages;",
            "}",
            "static int set_memmap_mode(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint ret, mode;",
            "\tbool enabled;",
            "",
            "\tif (sysfs_streq(val, \"force\") ||  sysfs_streq(val, \"FORCE\")) {",
            "\t\tmode = MEMMAP_ON_MEMORY_FORCE;",
            "\t} else {",
            "\t\tret = kstrtobool(val, &enabled);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t\tif (enabled)",
            "\t\t\tmode = MEMMAP_ON_MEMORY_ENABLE;",
            "\t\telse",
            "\t\t\tmode = MEMMAP_ON_MEMORY_DISABLE;",
            "\t}",
            "\t*((int *)kp->arg) = mode;",
            "\tif (mode == MEMMAP_ON_MEMORY_FORCE) {",
            "\t\tunsigned long memmap_pages = memory_block_memmap_on_memory_pages();",
            "",
            "\t\tpr_info_once(\"Memory hotplug will waste %ld pages in each memory block\\n\",",
            "\t\t\t     memmap_pages - PFN_UP(memory_block_memmap_size()));",
            "\t}",
            "\treturn 0;",
            "}",
            "static int get_memmap_mode(char *buffer, const struct kernel_param *kp)",
            "{",
            "\tint mode = *((int *)kp->arg);",
            "",
            "\tif (mode == MEMMAP_ON_MEMORY_FORCE)",
            "\t\treturn sprintf(buffer, \"force\\n\");",
            "\treturn sprintf(buffer, \"%c\\n\", mode ? 'Y' : 'N');",
            "}",
            "static inline bool mhp_memmap_on_memory(void)",
            "{",
            "\treturn memmap_mode != MEMMAP_ON_MEMORY_DISABLE;",
            "}",
            "static inline bool mhp_memmap_on_memory(void)",
            "{",
            "\treturn false;",
            "}",
            "static int set_online_policy(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint ret = sysfs_match_string(online_policy_to_str, val);",
            "",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\t*((int *)kp->arg) = ret;",
            "\treturn 0;",
            "}",
            "static int get_online_policy(char *buffer, const struct kernel_param *kp)",
            "{",
            "\treturn sprintf(buffer, \"%s\\n\", online_policy_to_str[*((int *)kp->arg)]);",
            "}",
            "void get_online_mems(void)",
            "{",
            "\tpercpu_down_read(&mem_hotplug_lock);",
            "}",
            "void put_online_mems(void)",
            "{",
            "\tpercpu_up_read(&mem_hotplug_lock);",
            "}",
            "int mhp_get_default_online_type(void)",
            "{",
            "\tif (mhp_default_online_type >= 0)",
            "\t\treturn mhp_default_online_type;",
            "",
            "\tif (IS_ENABLED(CONFIG_MHP_DEFAULT_ONLINE_TYPE_OFFLINE))",
            "\t\tmhp_default_online_type = MMOP_OFFLINE;",
            "\telse if (IS_ENABLED(CONFIG_MHP_DEFAULT_ONLINE_TYPE_ONLINE_AUTO))",
            "\t\tmhp_default_online_type = MMOP_ONLINE;",
            "\telse if (IS_ENABLED(CONFIG_MHP_DEFAULT_ONLINE_TYPE_ONLINE_KERNEL))",
            "\t\tmhp_default_online_type = MMOP_ONLINE_KERNEL;",
            "\telse if (IS_ENABLED(CONFIG_MHP_DEFAULT_ONLINE_TYPE_ONLINE_MOVABLE))",
            "\t\tmhp_default_online_type = MMOP_ONLINE_MOVABLE;",
            "\telse",
            "\t\tmhp_default_online_type = MMOP_OFFLINE;",
            "",
            "\treturn mhp_default_online_type;",
            "}",
            "void mhp_set_default_online_type(int online_type)",
            "{",
            "\tmhp_default_online_type = online_type;",
            "}"
          ],
          "function_name": "memory_block_memmap_size, memory_block_memmap_on_memory_pages, set_memmap_mode, get_memmap_mode, mhp_memmap_on_memory, mhp_memmap_on_memory, set_online_policy, get_online_policy, get_online_mems, put_online_mems, mhp_get_default_online_type, mhp_set_default_online_type",
          "description": "提供内存映射模式配置接口(set/get)，实现memmap_on_memory策略判断逻辑，包含在线策略设置与获取函数及默认类型处理逻辑。",
          "similarity": 0.5527864694595337
        },
        {
          "chunk_id": 4,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 592,
          "end_line": 697,
          "content": [
            "void __remove_pages(unsigned long pfn, unsigned long nr_pages,",
            "\t\t    struct vmem_altmap *altmap)",
            "{",
            "\tconst unsigned long end_pfn = pfn + nr_pages;",
            "\tunsigned long cur_nr_pages;",
            "",
            "\tif (check_pfn_span(pfn, nr_pages)) {",
            "\t\tWARN(1, \"Misaligned %s start: %#lx end: %#lx\\n\", __func__, pfn, pfn + nr_pages - 1);",
            "\t\treturn;",
            "\t}",
            "",
            "\tfor (; pfn < end_pfn; pfn += cur_nr_pages) {",
            "\t\tcond_resched();",
            "\t\t/* Select all remaining pages up to the next section boundary */",
            "\t\tcur_nr_pages = min(end_pfn - pfn,",
            "\t\t\t\t   SECTION_ALIGN_UP(pfn + 1) - pfn);",
            "\t\tsparse_remove_section(pfn, cur_nr_pages, altmap);",
            "\t}",
            "}",
            "int set_online_page_callback(online_page_callback_t callback)",
            "{",
            "\tint rc = -EINVAL;",
            "",
            "\tget_online_mems();",
            "\tmutex_lock(&online_page_callback_lock);",
            "",
            "\tif (online_page_callback == generic_online_page) {",
            "\t\tonline_page_callback = callback;",
            "\t\trc = 0;",
            "\t}",
            "",
            "\tmutex_unlock(&online_page_callback_lock);",
            "\tput_online_mems();",
            "",
            "\treturn rc;",
            "}",
            "int restore_online_page_callback(online_page_callback_t callback)",
            "{",
            "\tint rc = -EINVAL;",
            "",
            "\tget_online_mems();",
            "\tmutex_lock(&online_page_callback_lock);",
            "",
            "\tif (online_page_callback == callback) {",
            "\t\tonline_page_callback = generic_online_page;",
            "\t\trc = 0;",
            "\t}",
            "",
            "\tmutex_unlock(&online_page_callback_lock);",
            "\tput_online_mems();",
            "",
            "\treturn rc;",
            "}",
            "void generic_online_page(struct page *page, unsigned int order)",
            "{",
            "\t__free_pages_core(page, order, MEMINIT_HOTPLUG);",
            "}",
            "static void online_pages_range(unsigned long start_pfn, unsigned long nr_pages)",
            "{",
            "\tconst unsigned long end_pfn = start_pfn + nr_pages;",
            "\tunsigned long pfn;",
            "",
            "\t/*",
            "\t * Online the pages in MAX_PAGE_ORDER aligned chunks. The callback might",
            "\t * decide to not expose all pages to the buddy (e.g., expose them",
            "\t * later). We account all pages as being online and belonging to this",
            "\t * zone (\"present\").",
            "\t * When using memmap_on_memory, the range might not be aligned to",
            "\t * MAX_ORDER_NR_PAGES - 1, but pageblock aligned. __ffs() will detect",
            "\t * this and the first chunk to online will be pageblock_nr_pages.",
            "\t */",
            "\tfor (pfn = start_pfn; pfn < end_pfn;) {",
            "\t\tint order;",
            "",
            "\t\t/*",
            "\t\t * Free to online pages in the largest chunks alignment allows.",
            "\t\t *",
            "\t\t * __ffs() behaviour is undefined for 0. start == 0 is",
            "\t\t * MAX_PAGE_ORDER-aligned, Set order to MAX_PAGE_ORDER for",
            "\t\t * the case.",
            "\t\t */",
            "\t\tif (pfn)",
            "\t\t\torder = min_t(int, MAX_PAGE_ORDER, __ffs(pfn));",
            "\t\telse",
            "\t\t\torder = MAX_PAGE_ORDER;",
            "",
            "\t\t(*online_page_callback)(pfn_to_page(pfn), order);",
            "\t\tpfn += (1UL << order);",
            "\t}",
            "",
            "\t/* mark all involved sections as online */",
            "\tonline_mem_sections(start_pfn, end_pfn);",
            "}",
            "static void node_states_check_changes_online(unsigned long nr_pages,",
            "\tstruct zone *zone, struct memory_notify *arg)",
            "{",
            "\tint nid = zone_to_nid(zone);",
            "",
            "\targ->status_change_nid = NUMA_NO_NODE;",
            "\targ->status_change_nid_normal = NUMA_NO_NODE;",
            "",
            "\tif (!node_state(nid, N_MEMORY))",
            "\t\targ->status_change_nid = nid;",
            "\tif (zone_idx(zone) <= ZONE_NORMAL && !node_state(nid, N_NORMAL_MEMORY))",
            "\t\targ->status_change_nid_normal = nid;",
            "}"
          ],
          "function_name": "__remove_pages, set_online_page_callback, restore_online_page_callback, generic_online_page, online_pages_range, node_states_check_changes_online",
          "description": "实现内存页面移除操作，提供在线回调函数注册/恢复接口，分块执行页面上线处理，同步更新内存section在线状态并通知节点状态变化。",
          "similarity": 0.5354785323143005
        },
        {
          "chunk_id": 13,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 2233,
          "end_line": 2352,
          "content": [
            "void __remove_memory(u64 start, u64 size)",
            "{",
            "",
            "\t/*",
            "\t * trigger BUG() if some memory is not offlined prior to calling this",
            "\t * function",
            "\t */",
            "\tif (try_remove_memory(start, size))",
            "\t\tBUG();",
            "}",
            "int remove_memory(u64 start, u64 size)",
            "{",
            "\tint rc;",
            "",
            "\tlock_device_hotplug();",
            "\trc = try_remove_memory(start, size);",
            "\tunlock_device_hotplug();",
            "",
            "\treturn rc;",
            "}",
            "static int try_offline_memory_block(struct memory_block *mem, void *arg)",
            "{",
            "\tuint8_t online_type = MMOP_ONLINE_KERNEL;",
            "\tuint8_t **online_types = arg;",
            "\tstruct page *page;",
            "\tint rc;",
            "",
            "\t/*",
            "\t * Sense the online_type via the zone of the memory block. Offlining",
            "\t * with multiple zones within one memory block will be rejected",
            "\t * by offlining code ... so we don't care about that.",
            "\t */",
            "\tpage = pfn_to_online_page(section_nr_to_pfn(mem->start_section_nr));",
            "\tif (page && zone_idx(page_zone(page)) == ZONE_MOVABLE)",
            "\t\tonline_type = MMOP_ONLINE_MOVABLE;",
            "",
            "\trc = device_offline(&mem->dev);",
            "\t/*",
            "\t * Default is MMOP_OFFLINE - change it only if offlining succeeded,",
            "\t * so try_reonline_memory_block() can do the right thing.",
            "\t */",
            "\tif (!rc)",
            "\t\t**online_types = online_type;",
            "",
            "\t(*online_types)++;",
            "\t/* Ignore if already offline. */",
            "\treturn rc < 0 ? rc : 0;",
            "}",
            "static int try_reonline_memory_block(struct memory_block *mem, void *arg)",
            "{",
            "\tuint8_t **online_types = arg;",
            "\tint rc;",
            "",
            "\tif (**online_types != MMOP_OFFLINE) {",
            "\t\tmem->online_type = **online_types;",
            "\t\trc = device_online(&mem->dev);",
            "\t\tif (rc < 0)",
            "\t\t\tpr_warn(\"%s: Failed to re-online memory: %d\",",
            "\t\t\t\t__func__, rc);",
            "\t}",
            "",
            "\t/* Continue processing all remaining memory blocks. */",
            "\t(*online_types)++;",
            "\treturn 0;",
            "}",
            "int offline_and_remove_memory(u64 start, u64 size)",
            "{",
            "\tconst unsigned long mb_count = size / memory_block_size_bytes();",
            "\tuint8_t *online_types, *tmp;",
            "\tint rc;",
            "",
            "\tif (!IS_ALIGNED(start, memory_block_size_bytes()) ||",
            "\t    !IS_ALIGNED(size, memory_block_size_bytes()) || !size)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * We'll remember the old online type of each memory block, so we can",
            "\t * try to revert whatever we did when offlining one memory block fails",
            "\t * after offlining some others succeeded.",
            "\t */",
            "\tonline_types = kmalloc_array(mb_count, sizeof(*online_types),",
            "\t\t\t\t     GFP_KERNEL);",
            "\tif (!online_types)",
            "\t\treturn -ENOMEM;",
            "\t/*",
            "\t * Initialize all states to MMOP_OFFLINE, so when we abort processing in",
            "\t * try_offline_memory_block(), we'll skip all unprocessed blocks in",
            "\t * try_reonline_memory_block().",
            "\t */",
            "\tmemset(online_types, MMOP_OFFLINE, mb_count);",
            "",
            "\tlock_device_hotplug();",
            "",
            "\ttmp = online_types;",
            "\trc = walk_memory_blocks(start, size, &tmp, try_offline_memory_block);",
            "",
            "\t/*",
            "\t * In case we succeeded to offline all memory, remove it.",
            "\t * This cannot fail as it cannot get onlined in the meantime.",
            "\t */",
            "\tif (!rc) {",
            "\t\trc = try_remove_memory(start, size);",
            "\t\tif (rc)",
            "\t\t\tpr_err(\"%s: Failed to remove memory: %d\", __func__, rc);",
            "\t}",
            "",
            "\t/*",
            "\t * Rollback what we did. While memory onlining might theoretically fail",
            "\t * (nacked by a notifier), it barely ever happens.",
            "\t */",
            "\tif (rc) {",
            "\t\ttmp = online_types;",
            "\t\twalk_memory_blocks(start, size, &tmp,",
            "\t\t\t\t   try_reonline_memory_block);",
            "\t}",
            "\tunlock_device_hotplug();",
            "",
            "\tkfree(online_types);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "__remove_memory, remove_memory, try_offline_memory_block, try_reonline_memory_block, offline_and_remove_memory",
          "description": "offline_and_remove_memory 管理内存块的离线与移除流程，记录各内存块原始在线类型，在部分失败时回滚操作；try_offline_memory_block 和 try_reonline_memory_block 分别用于设置内存块离线状态及恢复在线状态",
          "similarity": 0.5320470333099365
        },
        {
          "chunk_id": 2,
          "file_path": "mm/memory_hotplug.c",
          "start_line": 247,
          "end_line": 355,
          "content": [
            "static int __init setup_memhp_default_state(char *str)",
            "{",
            "\tconst int online_type = mhp_online_type_from_str(str);",
            "",
            "\tif (online_type >= 0)",
            "\t\tmhp_default_online_type = online_type;",
            "",
            "\treturn 1;",
            "}",
            "void mem_hotplug_begin(void)",
            "{",
            "\tcpus_read_lock();",
            "\tpercpu_down_write(&mem_hotplug_lock);",
            "}",
            "void mem_hotplug_done(void)",
            "{",
            "\tpercpu_up_write(&mem_hotplug_lock);",
            "\tcpus_read_unlock();",
            "}",
            "static void release_memory_resource(struct resource *res)",
            "{",
            "\tif (!res)",
            "\t\treturn;",
            "\trelease_resource(res);",
            "\tkfree(res);",
            "}",
            "static int check_pfn_span(unsigned long pfn, unsigned long nr_pages)",
            "{",
            "\t/*",
            "\t * Disallow all operations smaller than a sub-section and only",
            "\t * allow operations smaller than a section for",
            "\t * SPARSEMEM_VMEMMAP. Note that check_hotplug_memory_range()",
            "\t * enforces a larger memory_block_size_bytes() granularity for",
            "\t * memory that will be marked online, so this check should only",
            "\t * fire for direct arch_{add,remove}_memory() users outside of",
            "\t * add_memory_resource().",
            "\t */",
            "\tunsigned long min_align;",
            "",
            "\tif (IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP))",
            "\t\tmin_align = PAGES_PER_SUBSECTION;",
            "\telse",
            "\t\tmin_align = PAGES_PER_SECTION;",
            "\tif (!IS_ALIGNED(pfn | nr_pages, min_align))",
            "\t\treturn -EINVAL;",
            "\treturn 0;",
            "}",
            "int __ref __add_pages(int nid, unsigned long pfn, unsigned long nr_pages,",
            "\t\tstruct mhp_params *params)",
            "{",
            "\tconst unsigned long end_pfn = pfn + nr_pages;",
            "\tunsigned long cur_nr_pages;",
            "\tint err;",
            "\tstruct vmem_altmap *altmap = params->altmap;",
            "",
            "\tif (WARN_ON_ONCE(!pgprot_val(params->pgprot)))",
            "\t\treturn -EINVAL;",
            "",
            "\tVM_BUG_ON(!mhp_range_allowed(PFN_PHYS(pfn), nr_pages * PAGE_SIZE, false));",
            "",
            "\tif (altmap) {",
            "\t\t/*",
            "\t\t * Validate altmap is within bounds of the total request",
            "\t\t */",
            "\t\tif (altmap->base_pfn != pfn",
            "\t\t\t\t|| vmem_altmap_offset(altmap) > nr_pages) {",
            "\t\t\tpr_warn_once(\"memory add fail, invalid altmap\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\taltmap->alloc = 0;",
            "\t}",
            "",
            "\tif (check_pfn_span(pfn, nr_pages)) {",
            "\t\tWARN(1, \"Misaligned %s start: %#lx end: %#lx\\n\", __func__, pfn, pfn + nr_pages - 1);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tfor (; pfn < end_pfn; pfn += cur_nr_pages) {",
            "\t\t/* Select all remaining pages up to the next section boundary */",
            "\t\tcur_nr_pages = min(end_pfn - pfn,",
            "\t\t\t\t   SECTION_ALIGN_UP(pfn + 1) - pfn);",
            "\t\terr = sparse_add_section(nid, pfn, cur_nr_pages, altmap,",
            "\t\t\t\t\t params->pgmap);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t\tcond_resched();",
            "\t}",
            "\tvmemmap_populate_print_last();",
            "\treturn err;",
            "}",
            "static unsigned long find_smallest_section_pfn(int nid, struct zone *zone,",
            "\t\t\t\t     unsigned long start_pfn,",
            "\t\t\t\t     unsigned long end_pfn)",
            "{",
            "\tfor (; start_pfn < end_pfn; start_pfn += PAGES_PER_SUBSECTION) {",
            "\t\tif (unlikely(!pfn_to_online_page(start_pfn)))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (unlikely(pfn_to_nid(start_pfn) != nid))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (zone != page_zone(pfn_to_page(start_pfn)))",
            "\t\t\tcontinue;",
            "",
            "\t\treturn start_pfn;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "setup_memhp_default_state, mem_hotplug_begin, mem_hotplug_done, release_memory_resource, check_pfn_span, __add_pages, find_smallest_section_pfn",
          "description": "初始化内存热插拔默认状态，实现内存热插拔锁操作，验证PFN对齐有效性，执行内存添加操作并处理替代映射信息。",
          "similarity": 0.5292659401893616
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/cpuset.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:43:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\cpuset.c`\n\n---\n\n# `cpuset.c` 技术文档\n\n## 1. 文件概述\n\n`cpuset.c` 是 Linux 内核中实现 **CPU 和内存节点资源约束控制组（cgroup）子系统** 的核心文件。它允许系统管理员将一组任务（进程/线程）限制在特定的 CPU 核心和内存节点（NUMA 节点）上运行，从而实现资源隔离、性能优化和拓扑感知调度。该文件同时支持 **传统（legacy）cgroup 层级** 和 **统一（default/unified）cgroup 层级**，并在统一层级中引入了 **分区（partition）** 和 **独占 CPU（exclusive CPUs）** 等高级特性，以支持实时任务、低延迟应用和系统关键服务的资源保障。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n*   **`struct cpuset`**: 核心数据结构，代表一个 cpuset 控制组实例。包含：\n    *   `css`: 嵌入的 cgroup 子系统状态。\n    *   `cpus_allowed` / `mems_allowed`: 用户配置的 CPU 和内存节点掩码。\n    *   `effective_cpus` / `effective_mems`: 实际生效的 CPU 和内存节点掩码（受父级和热插拔影响）。\n    *   `exclusive_cpus` / `effective_xcpus`: （统一层级）用户请求的独占 CPU 和实际分配的独占 CPU。\n    *   `partition_root_state`: 分区根状态（普通成员、分区根、隔离分区根、无效等）。\n    *   `nr_deadline_tasks` 等: 跟踪 `SCHED_DEADLINE` 任务，用于带宽管理。\n    *   `prs_err`: 分区配置错误代码。\n    *   各种标志位（`flags`）、计数器（`nr_subparts`, `child_ecpus_count`）和辅助结构（`fmeter`, `uf_node`）。\n*   **`enum prs_errcode`**: 定义分区配置无效时的错误代码（如 `PERR_INVCPUS`, `PERR_NOTPART` 等）。\n*   **`struct fmeter`**: “频率计”，用于平滑 `memory_pressure` 指标。\n*   **`struct cpuset_remove_tasks_struct`**: 用于异步处理传统层级中任务迁移的工作结构。\n\n### 全局变量\n\n*   **`cpusets_pre_enable_key` / `cpusets_enabled_key`**: 静态分支预测键，用于优化 cpuset 功能未启用时的代码路径。\n*   **`cpusets_insane_config_key`**: 静态分支预测键，用于快速判断是否存在异常的 cpuset 配置。\n*   **`subpartitions_cpus` / `isolated_cpus`**: 全局 CPU 掩码，跟踪已分配给子分区和隔离分区的独占 CPU。\n*   **`boot_hk_cpus` / `have_boot_isolcpus`**: 记录启动时由 `isolcpus` 内核参数指定的 housekeeping CPU。\n*   **`remote_children`**: 链表头，用于管理远程分区根子节点。\n\n## 3. 关键实现\n\n*   **层级模型差异处理**:\n    *   **传统层级**: 用户配置的 `cpus_allowed`/`mems_allowed` 直接作为有效掩码，并且必须是父级掩码的子集。\n    *   **统一层级**: 引入了 `effective_cpus`/`effective_mems` 概念。有效掩码是用户配置掩码与父级有效掩码的交集。如果交集为空，则继承父级掩码。这提供了更大的配置灵活性。\n*   **分区（Partition）机制**:\n    *   允许将一个 cpuset 标记为分区根（通过 `cpuset.cpus.partition` 文件）。\n    *   **本地分区**: 父级本身也是分区根。`cpuset.cpus.exclusive` 可选。\n    *   **远程分区**: 父级不是分区根。**必须**通过祖先链上的 `cpuset.cpus.exclusive` 属性将独占 CPU 传递下来。\n    *   分区根的有效 CPU (`effective_cpus`) 主要来源于其 `effective_xcpus`（独占 CPU），而非 `cpus_allowed`。\n    *   严格的验证逻辑确保分区配置的有效性（如 CPU 不重叠、父级状态正确等），错误通过 `prs_err` 报告。\n*   **独占 CPU (`exclusive_cpus`) 管理**:\n    *   用户通过 `cpuset.cpus.exclusive` 指定希望独占的 CPU 集合。\n    *   内核负责在分区创建和 CPU 热插拔时，从祖先的独占 CPU 池中分配 `effective_xcpus` 给子分区，并确保全局唯一性。\n    *   全局变量 `subpartitions_cpus` 和 `isolated_cpus` 用于跟踪已分配的独占 CPU。\n*   **与调度器集成**:\n    *   更新 `cpus_allowed` 会触发任务的 CPU 亲和性 (`cpus_mask`) 更新。\n    *   跟踪 `SCHED_DEADLINE` 任务数量 (`nr_deadline_tasks`)，以便在需要时重建调度域的带宽信息。\n    *   `relax_domain_level` 用于自定义调度域的松弛级别。\n*   **内存策略集成**:\n    *   更新 `mems_allowed` 会触发任务内存策略 (`mempolicy`) 的更新，确保内存分配遵守新的节点约束。\n    *   `old_mems_allowed` 用于在迁移内存策略时进行比较。\n*   **CPU/内存热插拔处理**: 在 CPU 或内存节点上线/下线时，会递归更新受影响的 cpuset 的有效掩码，并可能触发任务迁移。\n*   **Housekeeping 集成**: 检查分区配置是否与启动时通过 `isolcpus` 指定的 housekeeping CPU 设置冲突 (`PERR_HKEEPING`)。\n\n## 4. 依赖关系\n\n*   **`cgroup`**: 核心依赖，`cpuset` 是 cgroup v1 和 v2 的一个子系统。使用 `cgroup_subsys_state (css)` 进行集成。\n*   **`sched`**: 深度依赖。cpuset 通过修改任务的 `cpus_mask` 影响调度器的 CPU 选择。与 `SCHED_DEADLINE` 带宽管理和调度域 (`sched_domain`) 构建紧密相关。\n*   **`mm` / `mempolicy`**: 依赖内存管理子系统。cpuset 通过设置任务的内存策略 (`set_mempolicy`) 来约束内存分配的 NUMA 节点。\n*   **`cpu` / `memory`**: 依赖 CPU 和内存热插拔通知机制，以动态调整 cpuset 的有效资源掩码。\n*   **`cpumask` / `nodemask`**: 基础数据结构，用于表示 CPU 和内存节点的集合。\n*   **`rcupdate` / `spinlock`**: 用于实现并发安全的数据访问。\n*   **`workqueue`**: 用于异步处理任务迁移等可能耗时的操作（主要在传统层级）。\n\n## 5. 使用场景\n\n*   **资源隔离**: 将关键应用（如数据库、实时控制系统）限制在特定 CPU 和内存节点上，避免被其他任务干扰。\n*   **NUMA 优化**: 将任务和其内存分配绑定到同一 NUMA 节点，减少远程内存访问延迟，提升性能。\n*   **实时系统**: 结合 `SCHED_DEADLINE` 调度策略和 cpuset 分区/独占 CPU 功能，为硬实时任务提供确定性的 CPU 资源保障。\n*   **虚拟化**: Hypervisor 或容器运行时（如 Docker, Kubernetes）使用 cpuset 为虚拟机或容器分配专属的 CPU 和内存资源。\n*   **系统管理**: 通过 `/sys/fs/cgroup/cpuset/` (v1) 或 `/sys/fs/cgroup/` (v2) 下的接口，管理员可以动态调整进程组的资源约束。\n*   **内核自保护**: 将内核线程或中断处理程序限制在特定 CPU 上，保证系统关键路径的响应性。",
      "similarity": 0.6229391694068909,
      "chunks": [
        {
          "chunk_id": 19,
          "file_path": "kernel/cgroup/cpuset.c",
          "start_line": 3691,
          "end_line": 3804,
          "content": [
            "static int cpuset_common_seq_show(struct seq_file *sf, void *v)",
            "{",
            "\tstruct cpuset *cs = css_cs(seq_css(sf));",
            "\tcpuset_filetype_t type = seq_cft(sf)->private;",
            "\tint ret = 0;",
            "",
            "\tspin_lock_irq(&callback_lock);",
            "",
            "\tswitch (type) {",
            "\tcase FILE_CPULIST:",
            "\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->cpus_allowed));",
            "\t\tbreak;",
            "\tcase FILE_MEMLIST:",
            "\t\tseq_printf(sf, \"%*pbl\\n\", nodemask_pr_args(&cs->mems_allowed));",
            "\t\tbreak;",
            "\tcase FILE_EFFECTIVE_CPULIST:",
            "\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->effective_cpus));",
            "\t\tbreak;",
            "\tcase FILE_EFFECTIVE_MEMLIST:",
            "\t\tseq_printf(sf, \"%*pbl\\n\", nodemask_pr_args(&cs->effective_mems));",
            "\t\tbreak;",
            "\tcase FILE_EXCLUSIVE_CPULIST:",
            "\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->exclusive_cpus));",
            "\t\tbreak;",
            "\tcase FILE_EFFECTIVE_XCPULIST:",
            "\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->effective_xcpus));",
            "\t\tbreak;",
            "\tcase FILE_SUBPARTS_CPULIST:",
            "\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(subpartitions_cpus));",
            "\t\tbreak;",
            "\tcase FILE_ISOLATED_CPULIST:",
            "\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(isolated_cpus));",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tret = -EINVAL;",
            "\t}",
            "",
            "\tspin_unlock_irq(&callback_lock);",
            "\treturn ret;",
            "}",
            "static u64 cpuset_read_u64(struct cgroup_subsys_state *css, struct cftype *cft)",
            "{",
            "\tstruct cpuset *cs = css_cs(css);",
            "\tcpuset_filetype_t type = cft->private;",
            "\tswitch (type) {",
            "\tcase FILE_CPU_EXCLUSIVE:",
            "\t\treturn is_cpu_exclusive(cs);",
            "\tcase FILE_MEM_EXCLUSIVE:",
            "\t\treturn is_mem_exclusive(cs);",
            "\tcase FILE_MEM_HARDWALL:",
            "\t\treturn is_mem_hardwall(cs);",
            "\tcase FILE_SCHED_LOAD_BALANCE:",
            "\t\treturn is_sched_load_balance(cs);",
            "\tcase FILE_MEMORY_MIGRATE:",
            "\t\treturn is_memory_migrate(cs);",
            "\tcase FILE_MEMORY_PRESSURE_ENABLED:",
            "\t\treturn cpuset_memory_pressure_enabled;",
            "\tcase FILE_MEMORY_PRESSURE:",
            "\t\treturn fmeter_getrate(&cs->fmeter);",
            "\tcase FILE_SPREAD_PAGE:",
            "\t\treturn is_spread_page(cs);",
            "\tcase FILE_SPREAD_SLAB:",
            "\t\treturn is_spread_slab(cs);",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\t/* Unreachable but makes gcc happy */",
            "\treturn 0;",
            "}",
            "static s64 cpuset_read_s64(struct cgroup_subsys_state *css, struct cftype *cft)",
            "{",
            "\tstruct cpuset *cs = css_cs(css);",
            "\tcpuset_filetype_t type = cft->private;",
            "\tswitch (type) {",
            "\tcase FILE_SCHED_RELAX_DOMAIN_LEVEL:",
            "\t\treturn cs->relax_domain_level;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "",
            "\t/* Unreachable but makes gcc happy */",
            "\treturn 0;",
            "}",
            "static int sched_partition_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct cpuset *cs = css_cs(seq_css(seq));",
            "\tconst char *err, *type = NULL;",
            "",
            "\tswitch (cs->partition_root_state) {",
            "\tcase PRS_ROOT:",
            "\t\tseq_puts(seq, \"root\\n\");",
            "\t\tbreak;",
            "\tcase PRS_ISOLATED:",
            "\t\tseq_puts(seq, \"isolated\\n\");",
            "\t\tbreak;",
            "\tcase PRS_MEMBER:",
            "\t\tseq_puts(seq, \"member\\n\");",
            "\t\tbreak;",
            "\tcase PRS_INVALID_ROOT:",
            "\t\ttype = \"root\";",
            "\t\tfallthrough;",
            "\tcase PRS_INVALID_ISOLATED:",
            "\t\tif (!type)",
            "\t\t\ttype = \"isolated\";",
            "\t\terr = perr_strings[READ_ONCE(cs->prs_err)];",
            "\t\tif (err)",
            "\t\t\tseq_printf(seq, \"%s invalid (%s)\\n\", type, err);",
            "\t\telse",
            "\t\t\tseq_printf(seq, \"%s invalid\\n\", type);",
            "\t\tbreak;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "cpuset_common_seq_show, cpuset_read_u64, cpuset_read_s64, sched_partition_show",
          "description": "实现资源掩码的序列化展示、状态值读取及分区类型显示，通过遍历内核结构体字段输出 CPU/内存限制信息，暴露调度分区状态供用户空间查询",
          "similarity": 0.5684000253677368
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/cpuset.c",
          "start_line": 304,
          "end_line": 418,
          "content": [
            "void inc_dl_tasks_cs(struct task_struct *p)",
            "{",
            "\tstruct cpuset *cs = task_cs(p);",
            "",
            "\tcs->nr_deadline_tasks++;",
            "}",
            "void dec_dl_tasks_cs(struct task_struct *p)",
            "{",
            "\tstruct cpuset *cs = task_cs(p);",
            "",
            "\tcs->nr_deadline_tasks--;",
            "}",
            "static inline bool is_cpuset_online(struct cpuset *cs)",
            "{",
            "\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);",
            "}",
            "static inline int is_cpu_exclusive(const struct cpuset *cs)",
            "{",
            "\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);",
            "}",
            "static inline int is_mem_exclusive(const struct cpuset *cs)",
            "{",
            "\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);",
            "}",
            "static inline int is_mem_hardwall(const struct cpuset *cs)",
            "{",
            "\treturn test_bit(CS_MEM_HARDWALL, &cs->flags);",
            "}",
            "static inline int is_sched_load_balance(const struct cpuset *cs)",
            "{",
            "\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);",
            "}",
            "static inline int is_memory_migrate(const struct cpuset *cs)",
            "{",
            "\treturn test_bit(CS_MEMORY_MIGRATE, &cs->flags);",
            "}",
            "static inline int is_spread_page(const struct cpuset *cs)",
            "{",
            "\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);",
            "}",
            "static inline int is_spread_slab(const struct cpuset *cs)",
            "{",
            "\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);",
            "}",
            "static inline int is_partition_valid(const struct cpuset *cs)",
            "{",
            "\treturn cs->partition_root_state > 0;",
            "}",
            "static inline int is_partition_invalid(const struct cpuset *cs)",
            "{",
            "\treturn cs->partition_root_state < 0;",
            "}",
            "static inline void make_partition_invalid(struct cpuset *cs)",
            "{",
            "\tif (cs->partition_root_state > 0)",
            "\t\tcs->partition_root_state = -cs->partition_root_state;",
            "}",
            "static inline void notify_partition_change(struct cpuset *cs, int old_prs)",
            "{",
            "\tif (old_prs == cs->partition_root_state)",
            "\t\treturn;",
            "\tcgroup_file_notify(&cs->partition_file);",
            "",
            "\t/* Reset prs_err if not invalid */",
            "\tif (is_partition_valid(cs))",
            "\t\tWRITE_ONCE(cs->prs_err, PERR_NONE);",
            "}",
            "void cpuset_lock(void)",
            "{",
            "\tmutex_lock(&cpuset_mutex);",
            "}",
            "void cpuset_unlock(void)",
            "{",
            "\tmutex_unlock(&cpuset_mutex);",
            "}",
            "static inline void check_insane_mems_config(nodemask_t *nodes)",
            "{",
            "\tif (!cpusets_insane_config() &&",
            "\t\tmovable_only_nodes(nodes)) {",
            "\t\tstatic_branch_enable_cpuslocked(&cpusets_insane_config_key);",
            "\t\tpr_info(\"Unsupported (movable nodes only) cpuset configuration detected (nmask=%*pbl)!\\n\"",
            "\t\t\t\"Cpuset allocations might fail even with a lot of memory available.\\n\",",
            "\t\t\tnodemask_pr_args(nodes));",
            "\t}",
            "}",
            "static inline bool is_in_v2_mode(void)",
            "{",
            "\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||",
            "\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);",
            "}",
            "static inline bool partition_is_populated(struct cpuset *cs,",
            "\t\t\t\t\t  struct cpuset *excluded_child)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct cpuset *child;",
            "",
            "\tif (cs->css.cgroup->nr_populated_csets)",
            "\t\treturn true;",
            "\tif (!excluded_child && !cs->nr_subparts)",
            "\t\treturn cgroup_is_populated(cs->css.cgroup);",
            "",
            "\trcu_read_lock();",
            "\tcpuset_for_each_child(child, css, cs) {",
            "\t\tif (child == excluded_child)",
            "\t\t\tcontinue;",
            "\t\tif (is_partition_valid(child))",
            "\t\t\tcontinue;",
            "\t\tif (cgroup_is_populated(child->css.cgroup)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn false;",
            "}"
          ],
          "function_name": "inc_dl_tasks_cs, dec_dl_tasks_cs, is_cpuset_online, is_cpu_exclusive, is_mem_exclusive, is_mem_hardwall, is_sched_load_balance, is_memory_migrate, is_spread_page, is_spread_slab, is_partition_valid, is_partition_invalid, make_partition_invalid, notify_partition_change, cpuset_lock, cpuset_unlock, check_insane_mems_config, is_in_v2_mode, partition_is_populated",
          "description": "提供一系列内联函数用于查询和设置cpuset属性标志位，包含锁操作、配置有效性检查及分区状态变更通知，用于维护cpuset的运行时状态和约束条件。",
          "similarity": 0.5611235499382019
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/cpuset.c",
          "start_line": 568,
          "end_line": 672,
          "content": [
            "static void guarantee_online_cpus(struct task_struct *tsk,",
            "\t\t\t\t  struct cpumask *pmask)",
            "{",
            "\tconst struct cpumask *possible_mask = task_cpu_possible_mask(tsk);",
            "\tstruct cpuset *cs;",
            "",
            "\tif (WARN_ON(!cpumask_and(pmask, possible_mask, cpu_online_mask)))",
            "\t\tcpumask_copy(pmask, cpu_online_mask);",
            "",
            "\trcu_read_lock();",
            "\tcs = task_cs(tsk);",
            "",
            "\twhile (!cpumask_intersects(cs->effective_cpus, pmask))",
            "\t\tcs = parent_cs(cs);",
            "",
            "\tcpumask_and(pmask, pmask, cs->effective_cpus);",
            "\trcu_read_unlock();",
            "}",
            "static void guarantee_online_mems(struct cpuset *cs, nodemask_t *pmask)",
            "{",
            "\twhile (!nodes_intersects(cs->effective_mems, node_states[N_MEMORY]))",
            "\t\tcs = parent_cs(cs);",
            "\tnodes_and(*pmask, cs->effective_mems, node_states[N_MEMORY]);",
            "}",
            "static void cpuset_update_task_spread_flags(struct cpuset *cs,",
            "\t\t\t\t\tstruct task_struct *tsk)",
            "{",
            "\tif (cgroup_subsys_on_dfl(cpuset_cgrp_subsys))",
            "\t\treturn;",
            "",
            "\tif (is_spread_page(cs))",
            "\t\ttask_set_spread_page(tsk);",
            "\telse",
            "\t\ttask_clear_spread_page(tsk);",
            "",
            "\tif (is_spread_slab(cs))",
            "\t\ttask_set_spread_slab(tsk);",
            "\telse",
            "\t\ttask_clear_spread_slab(tsk);",
            "}",
            "static int is_cpuset_subset(const struct cpuset *p, const struct cpuset *q)",
            "{",
            "\treturn\tcpumask_subset(p->cpus_allowed, q->cpus_allowed) &&",
            "\t\tnodes_subset(p->mems_allowed, q->mems_allowed) &&",
            "\t\tis_cpu_exclusive(p) <= is_cpu_exclusive(q) &&",
            "\t\tis_mem_exclusive(p) <= is_mem_exclusive(q);",
            "}",
            "static inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)",
            "{",
            "\tcpumask_var_t *pmask1, *pmask2, *pmask3, *pmask4;",
            "",
            "\tif (cs) {",
            "\t\tpmask1 = &cs->cpus_allowed;",
            "\t\tpmask2 = &cs->effective_cpus;",
            "\t\tpmask3 = &cs->effective_xcpus;",
            "\t\tpmask4 = &cs->exclusive_cpus;",
            "\t} else {",
            "\t\tpmask1 = &tmp->new_cpus;",
            "\t\tpmask2 = &tmp->addmask;",
            "\t\tpmask3 = &tmp->delmask;",
            "\t\tpmask4 = NULL;",
            "\t}",
            "",
            "\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))",
            "\t\tgoto free_one;",
            "",
            "\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))",
            "\t\tgoto free_two;",
            "",
            "\tif (pmask4 && !zalloc_cpumask_var(pmask4, GFP_KERNEL))",
            "\t\tgoto free_three;",
            "",
            "",
            "\treturn 0;",
            "",
            "free_three:",
            "\tfree_cpumask_var(*pmask3);",
            "free_two:",
            "\tfree_cpumask_var(*pmask2);",
            "free_one:",
            "\tfree_cpumask_var(*pmask1);",
            "\treturn -ENOMEM;",
            "}",
            "static inline void free_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)",
            "{",
            "\tif (cs) {",
            "\t\tfree_cpumask_var(cs->cpus_allowed);",
            "\t\tfree_cpumask_var(cs->effective_cpus);",
            "\t\tfree_cpumask_var(cs->effective_xcpus);",
            "\t\tfree_cpumask_var(cs->exclusive_cpus);",
            "\t}",
            "\tif (tmp) {",
            "\t\tfree_cpumask_var(tmp->new_cpus);",
            "\t\tfree_cpumask_var(tmp->addmask);",
            "\t\tfree_cpumask_var(tmp->delmask);",
            "\t}",
            "}",
            "static inline void free_cpuset(struct cpuset *cs)",
            "{",
            "\tfree_cpumasks(cs, NULL);",
            "\tkfree(cs);",
            "}"
          ],
          "function_name": "guarantee_online_cpus, guarantee_online_mems, cpuset_update_task_spread_flags, is_cpuset_subset, alloc_cpumasks, free_cpumasks, free_cpuset",
          "description": "实现CPU/内存在线掩码保障、任务扩展标志更新及掩码内存管理，通过动态分配/释放cpu_masks维护不同层级的资源使用范围，确保配置变更时的资源有效性。",
          "similarity": 0.5579879283905029
        },
        {
          "chunk_id": 18,
          "file_path": "kernel/cgroup/cpuset.c",
          "start_line": 3563,
          "end_line": 3676,
          "content": [
            "static int cpuset_write_u64(struct cgroup_subsys_state *css, struct cftype *cft,",
            "\t\t\t    u64 val)",
            "{",
            "\tstruct cpuset *cs = css_cs(css);",
            "\tcpuset_filetype_t type = cft->private;",
            "\tint retval = 0;",
            "",
            "\tcpus_read_lock();",
            "\tmutex_lock(&cpuset_mutex);",
            "\tif (!is_cpuset_online(cs)) {",
            "\t\tretval = -ENODEV;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tswitch (type) {",
            "\tcase FILE_CPU_EXCLUSIVE:",
            "\t\tretval = update_flag(CS_CPU_EXCLUSIVE, cs, val);",
            "\t\tbreak;",
            "\tcase FILE_MEM_EXCLUSIVE:",
            "\t\tretval = update_flag(CS_MEM_EXCLUSIVE, cs, val);",
            "\t\tbreak;",
            "\tcase FILE_MEM_HARDWALL:",
            "\t\tretval = update_flag(CS_MEM_HARDWALL, cs, val);",
            "\t\tbreak;",
            "\tcase FILE_SCHED_LOAD_BALANCE:",
            "\t\tretval = update_flag(CS_SCHED_LOAD_BALANCE, cs, val);",
            "\t\tbreak;",
            "\tcase FILE_MEMORY_MIGRATE:",
            "\t\tretval = update_flag(CS_MEMORY_MIGRATE, cs, val);",
            "\t\tbreak;",
            "\tcase FILE_MEMORY_PRESSURE_ENABLED:",
            "\t\tcpuset_memory_pressure_enabled = !!val;",
            "\t\tbreak;",
            "\tcase FILE_SPREAD_PAGE:",
            "\t\tretval = update_flag(CS_SPREAD_PAGE, cs, val);",
            "\t\tbreak;",
            "\tcase FILE_SPREAD_SLAB:",
            "\t\tretval = update_flag(CS_SPREAD_SLAB, cs, val);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tretval = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&cpuset_mutex);",
            "\tcpus_read_unlock();",
            "\treturn retval;",
            "}",
            "static int cpuset_write_s64(struct cgroup_subsys_state *css, struct cftype *cft,",
            "\t\t\t    s64 val)",
            "{",
            "\tstruct cpuset *cs = css_cs(css);",
            "\tcpuset_filetype_t type = cft->private;",
            "\tint retval = -ENODEV;",
            "",
            "\tcpus_read_lock();",
            "\tmutex_lock(&cpuset_mutex);",
            "\tif (!is_cpuset_online(cs))",
            "\t\tgoto out_unlock;",
            "",
            "\tswitch (type) {",
            "\tcase FILE_SCHED_RELAX_DOMAIN_LEVEL:",
            "\t\tretval = update_relax_domain_level(cs, val);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tretval = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&cpuset_mutex);",
            "\tcpus_read_unlock();",
            "\treturn retval;",
            "}",
            "static ssize_t cpuset_write_resmask(struct kernfs_open_file *of,",
            "\t\t\t\t    char *buf, size_t nbytes, loff_t off)",
            "{",
            "\tstruct cpuset *cs = css_cs(of_css(of));",
            "\tstruct cpuset *trialcs;",
            "\tint retval = -ENODEV;",
            "",
            "\tbuf = strstrip(buf);",
            "\tcpus_read_lock();",
            "\tmutex_lock(&cpuset_mutex);",
            "\tif (!is_cpuset_online(cs))",
            "\t\tgoto out_unlock;",
            "",
            "\ttrialcs = alloc_trial_cpuset(cs);",
            "\tif (!trialcs) {",
            "\t\tretval = -ENOMEM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tswitch (of_cft(of)->private) {",
            "\tcase FILE_CPULIST:",
            "\t\tretval = update_cpumask(cs, trialcs, buf);",
            "\t\tbreak;",
            "\tcase FILE_EXCLUSIVE_CPULIST:",
            "\t\tretval = update_exclusive_cpumask(cs, trialcs, buf);",
            "\t\tbreak;",
            "\tcase FILE_MEMLIST:",
            "\t\tretval = update_nodemask(cs, trialcs, buf);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tretval = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tfree_cpuset(trialcs);",
            "out_unlock:",
            "\tmutex_unlock(&cpuset_mutex);",
            "\tcpus_read_unlock();",
            "\tflush_workqueue(cpuset_migrate_mm_wq);",
            "\treturn retval ?: nbytes;",
            "}"
          ],
          "function_name": "cpuset_write_u64, cpuset_write_s64, cpuset_write_resmask",
          "description": "提供对 CPU 集参数的写入接口，支持布尔标志位、整数参数及资源掩码配置，通过锁保护并发访问，验证掩码有效性后更新内核结构体",
          "similarity": 0.5452989339828491
        },
        {
          "chunk_id": 24,
          "file_path": "kernel/cgroup/cpuset.c",
          "start_line": 4586,
          "end_line": 4692,
          "content": [
            "static void cpuset_handle_hotplug(void)",
            "{",
            "\tstatic cpumask_t new_cpus;",
            "\tstatic nodemask_t new_mems;",
            "\tbool cpus_updated, mems_updated;",
            "\tbool on_dfl = is_in_v2_mode();",
            "\tstruct tmpmasks tmp, *ptmp = NULL;",
            "",
            "\tif (on_dfl && !alloc_cpumasks(NULL, &tmp))",
            "\t\tptmp = &tmp;",
            "",
            "\tlockdep_assert_cpus_held();",
            "\tmutex_lock(&cpuset_mutex);",
            "",
            "\t/* fetch the available cpus/mems and find out which changed how */",
            "\tcpumask_copy(&new_cpus, cpu_active_mask);",
            "\tnew_mems = node_states[N_MEMORY];",
            "",
            "\t/*",
            "\t * If subpartitions_cpus is populated, it is likely that the check",
            "\t * below will produce a false positive on cpus_updated when the cpu",
            "\t * list isn't changed. It is extra work, but it is better to be safe.",
            "\t */",
            "\tcpus_updated = !cpumask_equal(top_cpuset.effective_cpus, &new_cpus) ||",
            "\t\t       !cpumask_empty(subpartitions_cpus);",
            "\tmems_updated = !nodes_equal(top_cpuset.effective_mems, new_mems);",
            "",
            "\t/*",
            "\t * In the rare case that hotplug removes all the cpus in",
            "\t * subpartitions_cpus, we assumed that cpus are updated.",
            "\t */",
            "\tif (!cpus_updated && !cpumask_empty(subpartitions_cpus))",
            "\t\tcpus_updated = true;",
            "",
            "\t/* For v1, synchronize cpus_allowed to cpu_active_mask */",
            "\tif (cpus_updated) {",
            "\t\tspin_lock_irq(&callback_lock);",
            "\t\tif (!on_dfl)",
            "\t\t\tcpumask_copy(top_cpuset.cpus_allowed, &new_cpus);",
            "\t\t/*",
            "\t\t * Make sure that CPUs allocated to child partitions",
            "\t\t * do not show up in effective_cpus. If no CPU is left,",
            "\t\t * we clear the subpartitions_cpus & let the child partitions",
            "\t\t * fight for the CPUs again.",
            "\t\t */",
            "\t\tif (!cpumask_empty(subpartitions_cpus)) {",
            "\t\t\tif (cpumask_subset(&new_cpus, subpartitions_cpus)) {",
            "\t\t\t\ttop_cpuset.nr_subparts = 0;",
            "\t\t\t\tcpumask_clear(subpartitions_cpus);",
            "\t\t\t} else {",
            "\t\t\t\tcpumask_andnot(&new_cpus, &new_cpus,",
            "\t\t\t\t\t       subpartitions_cpus);",
            "\t\t\t}",
            "\t\t}",
            "\t\tcpumask_copy(top_cpuset.effective_cpus, &new_cpus);",
            "\t\tspin_unlock_irq(&callback_lock);",
            "\t\t/* we don't mess with cpumasks of tasks in top_cpuset */",
            "\t}",
            "",
            "\t/* synchronize mems_allowed to N_MEMORY */",
            "\tif (mems_updated) {",
            "\t\tspin_lock_irq(&callback_lock);",
            "\t\tif (!on_dfl)",
            "\t\t\ttop_cpuset.mems_allowed = new_mems;",
            "\t\ttop_cpuset.effective_mems = new_mems;",
            "\t\tspin_unlock_irq(&callback_lock);",
            "\t\tupdate_tasks_nodemask(&top_cpuset);",
            "\t}",
            "",
            "\tmutex_unlock(&cpuset_mutex);",
            "",
            "\t/* if cpus or mems changed, we need to propagate to descendants */",
            "\tif (cpus_updated || mems_updated) {",
            "\t\tstruct cpuset *cs;",
            "\t\tstruct cgroup_subsys_state *pos_css;",
            "",
            "\t\trcu_read_lock();",
            "\t\tcpuset_for_each_descendant_pre(cs, pos_css, &top_cpuset) {",
            "\t\t\tif (cs == &top_cpuset || !css_tryget_online(&cs->css))",
            "\t\t\t\tcontinue;",
            "\t\t\trcu_read_unlock();",
            "",
            "\t\t\tcpuset_hotplug_update_tasks(cs, ptmp);",
            "",
            "\t\t\trcu_read_lock();",
            "\t\t\tcss_put(&cs->css);",
            "\t\t}",
            "\t\trcu_read_unlock();",
            "\t}",
            "",
            "\t/* rebuild sched domains if cpus_allowed has changed */",
            "\tif (cpus_updated || force_rebuild) {",
            "\t\tforce_rebuild = false;",
            "\t\trebuild_sched_domains_cpuslocked();",
            "\t}",
            "",
            "\tfree_cpumasks(NULL, ptmp);",
            "}",
            "void cpuset_update_active_cpus(void)",
            "{",
            "\t/*",
            "\t * We're inside cpu hotplug critical region which usually nests",
            "\t * inside cgroup synchronization.  Bounce actual hotplug processing",
            "\t * to a work item to avoid reverse locking order.",
            "\t */",
            "\tcpuset_handle_hotplug();",
            "}"
          ],
          "function_name": "cpuset_handle_hotplug, cpuset_update_active_cpus",
          "description": "cpuset_handle_hotplug 处理 CPU/内存热插拔事件，同步 top_cpuset 的 effective_cpus/effective_mems 到最新可用掩码，并递归更新所有子 cpuset 节点。cpuset_update_active_cpus 将热插拔处理逻辑委派给异步工作队列以避免锁竞争。",
          "similarity": 0.5447496175765991
        }
      ]
    }
  ]
}