{
  "query": "clock_gettime",
  "timestamp": "2025-12-26 02:18:33",
  "retrieved_files": [
    {
      "source_file": "kernel/time/itimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:39:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\itimer.c`\n\n---\n\n# `time/itimer.c` 技术文档\n\n## 1. 文件概述\n\n`time/itimer.c` 是 Linux 内核中实现 POSIX 间隔定时器（interval timers，简称 itimers）的核心文件。该文件提供了对三种经典 Unix 间隔定时器的支持：\n\n- **ITIMER_REAL**：基于真实时间（墙上时钟）的定时器，到期时发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL**：基于进程用户态 CPU 时间的定时器，到期时发送 `SIGVTALRM` 信号\n- **ITIMER_PROF**：基于进程总 CPU 时间（用户态+内核态）的定时器，到期时发送 `SIGPROF` 信号\n\n该文件实现了 `getitimer()`、`setitimer()` 系统调用以及 `alarm()` 系统调用（在架构支持的情况下），为用户空间程序提供间隔定时器功能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`itimer_get_remtime()`**：获取高精度实时定时器的剩余时间\n- **`get_cpu_itimer()`**：获取 CPU 时间相关的定时器（虚拟/性能）状态\n- **`do_getitimer()`**：内部实现获取指定类型定时器状态的逻辑\n- **`put_itimerval()`**：将内核内部的 `itimerspec64` 格式转换为用户空间的 `old_itimerval` 格式\n- **`getitimer()` 系统调用**：用户空间获取定时器状态的入口\n- **`it_real_fn()`**：ITIMER_REAL 定时器到期时的回调函数\n- **`set_cpu_itimer()`**：设置 CPU 时间相关的定时器\n- **`do_setitimer()`**：内部实现设置指定类型定时器的逻辑\n- **`clear_itimer()`**：在 SELinux 环境下清除所有定时器（安全相关）\n- **`alarm_setitimer()`**：实现 `alarm()` 系统调用的内部函数\n- **`alarm()` 系统调用**：设置单次实时定时器的简化接口\n\n### 数据结构\n\n- **`struct cpu_itimer`**：存储 CPU 时间定时器的状态（在 `signal_struct` 中）\n- **`struct hrtimer`**：高精度定时器，用于实现 ITIMER_REAL\n- **`struct itimerspec64`**：64 位时间规格结构，内核内部使用\n- **`struct __kernel_old_itimerval`**：用户空间兼容的定时器值结构\n\n## 3. 关键实现\n\n### 定时器类型实现差异\n\n- **ITIMER_REAL**：使用高精度定时器（`hrtimer`）实现，基于真实时间，通过 `hrtimer_start()` 启动，到期时调用 `it_real_fn()` 发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL/ITIMER_PROF**：基于 CPU 时间采样实现，通过 `thread_group_sample_cputime()` 获取当前进程组的 CPU 时间，与设定的过期时间比较来判断是否到期\n\n### 时间精度处理\n\n- 使用纳秒级精度的 `ktime_t` 和 `timespec64` 进行内部计算\n- 用户空间接口使用微秒精度（`tv_usec`），通过 `NSEC_PER_USEC` 进行单位转换\n- 对于即将到期的定时器，返回 `TICK_NSEC`（1 微秒）作为剩余时间，避免返回 0 导致用户误判\n\n### 并发安全\n\n- 使用 `siglock` 自旋锁保护信号结构体中的定时器状态\n- ITIMER_REAL 的设置操作需要处理定时器可能正在执行的竞态条件，通过 `hrtimer_try_to_cancel()` 和重试机制确保安全\n- CPU 定时器操作在 `siglock` 保护下进行，确保线程组内的一致性\n\n### 兼容性支持\n\n- 提供 32 位兼容接口（`COMPAT_SYSCALL_DEFINE2`）\n- 支持 `alarm()` 系统调用（在 `__ARCH_WANT_SYS_ALARM` 定义时）\n- 处理 32 位系统上的时间值溢出问题（限制为 `INT_MAX`）\n\n## 4. 依赖关系\n\n### 头文件依赖\n\n- **`<linux/hrtimer.h>`**：高精度定时器框架，用于 ITIMER_REAL 实现\n- **`<linux/sched/cputime.h>`**：CPU 时间采样功能，用于虚拟和性能定时器\n- **`<linux/posix-timers.h>`**：POSIX 定时器相关定义\n- **`<linux/sched/signal.h>`**：信号处理和 `signal_struct` 结构定义\n- **`<linux/time.h>`**：时间转换和操作函数\n- **`<trace/events/timer.h>`**：定时器事件跟踪支持\n\n### 内核子系统依赖\n\n- **调度子系统**：通过 `current` 获取当前任务，使用 `thread_group_sample_cputime()` 采样 CPU 时间\n- **信号子系统**：通过 `kill_pid_info()` 发送信号，使用 `siglock` 进行同步\n- **高精度定时器子系统**：ITIMER_REAL 的底层实现依赖 hrtimer 框架\n- **安全子系统**：SELinux 相关的 `clear_itimer()` 函数\n\n## 5. 使用场景\n\n### 用户空间编程\n\n- **定时任务**：应用程序使用 `setitimer()` 设置周期性或一次性定时器\n- **超时控制**：网络编程中设置 I/O 操作超时\n- **性能监控**：使用 ITIMER_PROF 监控程序 CPU 使用情况\n- **简单定时**：使用 `alarm()` 系统调用设置简单的秒级定时器\n\n### 内核内部使用\n\n- **进程管理**：在进程退出或权限变更时清除定时器（SELinux 场景）\n- **信号处理**：定时器到期时向进程发送相应信号\n- **时间跟踪**：通过 tracepoint 记录定时器状态变化和到期事件\n- **兼容层**：为不同架构和位数提供统一的定时器接口\n\n### 系统调用路径\n\n- **`getitimer()`** → `do_getitimer()` → 对应定时器类型的具体获取函数\n- **`setitimer()`** → `do_setitimer()` → 对应定时器类型的具体设置函数  \n- **`alarm()`** → `alarm_setitimer()` → `do_setitimer(ITIMER_REAL, ...)`\n\n该文件是 Linux 内核 POSIX 定时器功能的重要组成部分，为用户空间提供了经典的 Unix 间隔定时器接口。",
      "similarity": 0.5518384575843811,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/itimer.c",
          "start_line": 29,
          "end_line": 129,
          "content": [
            "static struct timespec64 itimer_get_remtime(struct hrtimer *timer)",
            "{",
            "\tktime_t rem = __hrtimer_get_remaining(timer, true);",
            "",
            "\t/*",
            "\t * Racy but safe: if the itimer expires after the above",
            "\t * hrtimer_get_remtime() call but before this condition",
            "\t * then we return 0 - which is correct.",
            "\t */",
            "\tif (hrtimer_active(timer)) {",
            "\t\tif (rem <= 0)",
            "\t\t\trem = NSEC_PER_USEC;",
            "\t} else",
            "\t\trem = 0;",
            "",
            "\treturn ktime_to_timespec64(rem);",
            "}",
            "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   struct itimerspec64 *const value)",
            "{",
            "\tu64 val, interval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\tval = it->expires;",
            "\tinterval = it->incr;",
            "\tif (val) {",
            "\t\tu64 t, samples[CPUCLOCK_MAX];",
            "",
            "\t\tthread_group_sample_cputime(tsk, samples);",
            "\t\tt = samples[clock_id];",
            "",
            "\t\tif (val < t)",
            "\t\t\t/* about to fire */",
            "\t\t\tval = TICK_NSEC;",
            "\t\telse",
            "\t\t\tval -= t;",
            "\t}",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tvalue->it_value = ns_to_timespec64(val);",
            "\tvalue->it_interval = ns_to_timespec64(interval);",
            "}",
            "static int do_getitimer(int which, struct itimerspec64 *value)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);",
            "\t\tvalue->it_interval =",
            "\t\t\tktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn(-EINVAL);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int put_itimerval(struct __kernel_old_itimerval __user *o,",
            "\t\t\t const struct itimerspec64 *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tv.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v, sizeof(struct __kernel_old_itimerval)) ? -EFAULT : 0;",
            "}",
            "static int put_old_itimerval32(struct old_itimerval32 __user *o,",
            "\t\t\t       const struct itimerspec64 *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tv32.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv32.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv32.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv32.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v32, sizeof(struct old_itimerval32)) ? -EFAULT : 0;",
            "}",
            "enum hrtimer_restart it_real_fn(struct hrtimer *timer)",
            "{",
            "\tstruct signal_struct *sig =",
            "\t\tcontainer_of(timer, struct signal_struct, real_timer);",
            "\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];",
            "",
            "\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);",
            "\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}"
          ],
          "function_name": "itimer_get_remtime, get_cpu_itimer, do_getitimer, put_itimerval, put_old_itimerval32, it_real_fn",
          "description": "实现了itimer_get_remtime获取剩余时间、get_cpu_itimer读取CPU定时器信息、do_getitimer根据时钟类型获取定时器状态、put_itimerval/put_old_itimerval32转换并复制时间值到用户空间，以及it_real_fn作为实时时钟的超时处理函数",
          "similarity": 0.6496986150741577
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/itimer.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992 Darren Senn",
            " */",
            "",
            "/* These are all the functions necessary to implement itimers */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/time.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/hrtimer.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/compat.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "/**",
            " * itimer_get_remtime - get remaining time for the timer",
            " *",
            " * @timer: the timer to read",
            " *",
            " * Returns the delta between the expiry time and now, which can be",
            " * less than zero or 1usec for an pending expired timer",
            " */"
          ],
          "function_name": null,
          "description": "该代码块定义了itimer_get_remtime函数的原型，用于获取高精度定时器的剩余时间，通过计算当前时间与定时器到期时间的差值得到剩余时间，但未提供完整实现，上下文不完整",
          "similarity": 0.6463996171951294
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/itimer.c",
          "start_line": 313,
          "end_line": 348,
          "content": [
            "static int get_itimerval(struct itimerspec64 *o, const struct __kernel_old_itimerval __user *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tif (copy_from_user(&v, i, sizeof(struct __kernel_old_itimerval)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value. */",
            "\tif (!timeval_valid(&v.it_value) ||",
            "\t    !timeval_valid(&v.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}",
            "static int get_old_itimerval32(struct itimerspec64 *o, const struct old_itimerval32 __user *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tif (copy_from_user(&v32, i, sizeof(struct old_itimerval32)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value.  */",
            "\tif (!timeval_valid(&v32.it_value) ||",
            "\t    !timeval_valid(&v32.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v32.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v32.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v32.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v32.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_itimerval, get_old_itimerval32",
          "description": "实现get_itimerval/get_old_itimerval32将用户态时间值转换为内核时间结构体，执行有效性校验，确保输入时间值在合法范围内",
          "similarity": 0.5961258411407471
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/itimer.c",
          "start_line": 168,
          "end_line": 275,
          "content": [
            "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   const struct itimerspec64 *const value,",
            "\t\t\t   struct itimerspec64 *const ovalue)",
            "{",
            "\tu64 oval, nval, ointerval, ninterval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tnval = timespec64_to_ns(&value->it_value);",
            "\tninterval = timespec64_to_ns(&value->it_interval);",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\toval = it->expires;",
            "\tointerval = it->incr;",
            "\tif (oval || nval) {",
            "\t\tif (nval > 0)",
            "\t\t\tnval += TICK_NSEC;",
            "\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);",
            "\t}",
            "\tit->expires = nval;",
            "\tit->incr = ninterval;",
            "\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?",
            "\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tif (ovalue) {",
            "\t\tovalue->it_value = ns_to_timespec64(oval);",
            "\t\tovalue->it_interval = ns_to_timespec64(ointerval);",
            "\t}",
            "}",
            "static int do_setitimer(int which, struct itimerspec64 *value,",
            "\t\t\tstruct itimerspec64 *ovalue)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct hrtimer *timer;",
            "\tktime_t expires;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "again:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\ttimer = &tsk->signal->real_timer;",
            "\t\tif (ovalue) {",
            "\t\t\tovalue->it_value = itimer_get_remtime(timer);",
            "\t\t\tovalue->it_interval",
            "\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\t}",
            "\t\t/* We are sharing ->siglock with it_real_fn() */",
            "\t\tif (hrtimer_try_to_cancel(timer) < 0) {",
            "\t\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\t\thrtimer_cancel_wait_running(timer);",
            "\t\t\tgoto again;",
            "\t\t}",
            "\t\texpires = timespec64_to_ktime(value->it_value);",
            "\t\tif (expires != 0) {",
            "\t\t\ttsk->signal->it_real_incr =",
            "\t\t\t\ttimespec64_to_ktime(value->it_interval);",
            "\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);",
            "\t\t} else",
            "\t\t\ttsk->signal->it_real_incr = 0;",
            "",
            "\t\ttrace_itimer_state(ITIMER_REAL, value, 0);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "void clear_itimer(void)",
            "{",
            "\tstruct itimerspec64 v = {};",
            "\tint i;",
            "",
            "\tfor (i = 0; i < 3; i++)",
            "\t\tdo_setitimer(i, &v, NULL);",
            "}",
            "static unsigned int alarm_setitimer(unsigned int seconds)",
            "{",
            "\tstruct itimerspec64 it_new, it_old;",
            "",
            "#if BITS_PER_LONG < 64",
            "\tif (seconds > INT_MAX)",
            "\t\tseconds = INT_MAX;",
            "#endif",
            "\tit_new.it_value.tv_sec = seconds;",
            "\tit_new.it_value.tv_nsec = 0;",
            "\tit_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;",
            "",
            "\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);",
            "",
            "\t/*",
            "\t * We can't return 0 if we have an alarm pending ...  And we'd",
            "\t * better return too much than too little anyway",
            "\t */",
            "\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||",
            "\t      it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))",
            "\t\tit_old.it_value.tv_sec++;",
            "",
            "\treturn it_old.it_value.tv_sec;",
            "}"
          ],
          "function_name": "set_cpu_itimer, do_setitimer, clear_itimer, alarm_setitimer",
          "description": "包含set_cpu_itimer设置CPU定时器参数、do_setitimer根据时钟类型配置定时器、clear_itimer清除所有定时器、alarm_setitimer设置一次性闹钟，其中do_setitimer处理实时时钟的启动和取消操作",
          "similarity": 0.5771298408508301
        }
      ]
    },
    {
      "source_file": "kernel/time/sched_clock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:46:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\sched_clock.c`\n\n---\n\n# `time/sched_clock.c` 技术文档\n\n## 1. 文件概述\n\n`time/sched_clock.c` 实现了 Linux 内核中通用的 `sched_clock()` 机制，用于将底层硬件计数器（如 TSC、ARM arch timer 等）扩展为 64 位纳秒级单调时间戳。该机制为调度器、延迟跟踪、性能分析等子系统提供高精度、低开销的时间基准。文件通过双缓冲（双副本）+ 序列锁（`seqcount_latch_t`）的方式，确保即使在 NMI（不可屏蔽中断）上下文中调用 `sched_clock()` 也能获得一致、无撕裂的时间读数。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct clock_data`**  \n  全局状态结构体，包含：\n  - `seq`: `seqcount_latch_t` 类型的序列计数器，用于同步读写。\n  - `read_data[2]`: 双缓冲数组，分别存储当前有效和更新中的读取参数。\n  - `wrap_kt`: 计数器溢出前的最大持续时间（ktime_t 格式）。\n  - `rate`: 当前注册的时钟源频率（Hz）。\n  - `actual_read_sched_clock`: 指向底层硬件读取函数的指针。\n\n- **`struct clock_read_data`**（定义在头文件中）  \n  包含读取 `sched_clock` 所需的关键参数：\n  - `read_sched_clock`: 当前使用的读取函数（可能为挂起状态下的特殊函数）。\n  - `sched_clock_mask`: 计数器位宽掩码（如 `CLOCKSOURCE_MASK(bits)`）。\n  - `mult/shift`: 用于将计数器周期转换为纳秒的乘法/移位因子。\n  - `epoch_cyc/epoch_ns`: 上次校准时刻的计数器值和对应的纳秒时间戳。\n\n### 主要函数\n\n- **`sched_clock_noinstr(void)`**  \n  无插桩（noinstr）版本的 `sched_clock()`，在禁用抢占的上下文中直接读取并计算纳秒时间，使用序列锁保证一致性。\n\n- **`sched_clock(void)`**  \n  对外公开的 `sched_clock()` 接口，内部调用 `sched_clock_noinstr()` 并确保抢占被禁用。\n\n- **`sched_clock_register(read, bits, rate)`**  \n  注册新的底层硬件时钟源。计算 `mult/shift` 转换参数，更新全局 `clock_data`，并启动防溢出定时器。\n\n- **`generic_sched_clock_init(void)`**  \n  初始化通用 `sched_clock` 机制。若未注册硬件时钟，则回退到基于 `jiffies` 的实现，并启动周期性更新定时器。\n\n- **`sched_clock_suspend()/sched_clock_resume()`**  \n  系统挂起/恢复时的回调函数。挂起时切换读取函数为返回最后校准值的静态函数，恢复时重新同步并启用硬件读取。\n\n- **`update_sched_clock()`**  \n  更新 `epoch_cyc` 和 `epoch_ns`，防止因计数器长时间运行导致转换溢出。\n\n- **`sched_clock_poll()`**  \n  高精度定时器（hrtimer）回调函数，周期性调用 `update_sched_clock()`。\n\n## 3. 关键实现\n\n### 双缓冲 + Latch 序列锁机制\n\n- 使用 `seqcount_latch_t` 实现无锁读取：读操作通过 `sched_clock_read_begin()` 获取当前有效副本索引（`seq & 1`），并在末尾通过 `sched_clock_read_retry()` 验证读取期间未发生更新。\n- 写操作（如 `update_clock_read_data()`）先更新奇数副本（索引 1），通过 `raw_write_seqcount_latch()` 切换读者到奇数副本；再更新偶数副本（索引 0），再次切换回偶数副本。确保读者始终看到一致的旧数据或新数据，不会看到中间状态。\n\n### 时间转换与防溢出\n\n- 使用 `clocks_calc_mult_shift()` 计算最优的 `mult/shift` 对，将硬件计数器周期高效转换为纳秒（公式：`ns = (cyc * mult) >> shift`）。\n- 通过 `clocks_calc_max_nsecs()` 计算计数器在溢出前可安全表示的最大纳秒数，并以此设置 `hrtimer` 的超时时间（`wrap_kt`），定期调用 `update_sched_clock()` 重置 `epoch`，避免 64 位中间结果溢出。\n\n### 挂起/恢复处理\n\n- 系统挂起时，将 `read_sched_clock` 替换为 `suspended_sched_clock_read()`，该函数返回最后一次校准的 `epoch_cyc`，使 `sched_clock()` 在挂起期间表现为“冻结”。\n- 恢复时重新读取硬件计数器作为新的 `epoch_cyc`，并恢复原始读取函数。\n\n### 中断上下文安全\n\n- 所有读路径（`sched_clock*`）标记为 `notrace` 和 `noinstr`，避免在关键路径引入追踪或插桩开销。\n- 写操作（如注册、更新）在关中断（`local_irq_save`）下执行，确保与 NMI 上下文的读操作互斥。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/clocksource.h>`：提供 `CLOCKSOURCE_MASK`、`clocks_calc_mult_shift` 等时钟源工具。\n  - `<linux/hrtimer.h>`：用于实现防溢出定时器。\n  - `<linux/seqlock.h>`：提供 `seqcount_latch_t` 及相关操作。\n  - `\"timekeeping.h\"`：内核时间管理内部头文件。\n  - `<linux/sched/clock.h>`：定义 `sched_clock()` 接口及 `enable_sched_clock_irqtime()`。\n\n- **模块交互**：\n  - **调度器（scheduler）**：`sched_clock()` 是 `rq_clock()` 等调度时间基准的底层实现。\n  - **时间子系统（timekeeping）**：与 `ktime_get()` 等接口协同，但 `sched_clock()` 更侧重低开销、单调性。\n  - **电源管理（PM）**：通过 `syscore_ops` 注册挂起/恢复回调。\n  - **中断子系统**：若时钟频率 ≥ 1MHz 且 `irqtime` 未禁用，则启用中断时间统计（`enable_sched_clock_irqtime()`）。\n\n## 5. 使用场景\n\n- **调度延迟测量**：调度器使用 `sched_clock()` 计算任务运行时间、睡眠时间及调度延迟。\n- **性能分析工具**：如 `ftrace`、`perf` 使用 `sched_clock()` 作为事件时间戳。\n- **内核延迟跟踪**：`irqsoff`、`preemptoff` 等 tracer 依赖高精度单调时钟。\n- **硬件计数器抽象**：为架构特定的高精度计数器（如 x86 TSC、ARM arch timer）提供统一的 64 位纳秒接口。\n- **系统挂起/恢复**：在 Suspend-to-RAM 等场景下保持时间连续性，避免挂起期间时间“跳跃”。",
      "similarity": 0.5513043999671936,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 52,
          "end_line": 202,
          "content": [
            "static u64 notrace jiffy_sched_clock_read(void)",
            "{",
            "\t/*",
            "\t * We don't need to use get_jiffies_64 on 32-bit arches here",
            "\t * because we register with BITS_PER_LONG",
            "\t */",
            "\treturn (u64)(jiffies - INITIAL_JIFFIES);",
            "}",
            "static __always_inline u64 cyc_to_ns(u64 cyc, u32 mult, u32 shift)",
            "{",
            "\treturn (cyc * mult) >> shift;",
            "}",
            "notrace int sched_clock_read_retry(unsigned int seq)",
            "{",
            "\treturn raw_read_seqcount_latch_retry(&cd.seq, seq);",
            "}",
            "unsigned long long noinstr sched_clock_noinstr(void)",
            "{",
            "\tstruct clock_read_data *rd;",
            "\tunsigned int seq;",
            "\tu64 cyc, res;",
            "",
            "\tdo {",
            "\t\tseq = raw_read_seqcount_latch(&cd.seq);",
            "\t\trd = cd.read_data + (seq & 1);",
            "",
            "\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &",
            "\t\t      rd->sched_clock_mask;",
            "\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);",
            "\t} while (raw_read_seqcount_latch_retry(&cd.seq, seq));",
            "",
            "\treturn res;",
            "}",
            "unsigned long long notrace sched_clock(void)",
            "{",
            "\tunsigned long long ns;",
            "\tpreempt_disable_notrace();",
            "\tns = sched_clock_noinstr();",
            "\tpreempt_enable_notrace();",
            "\treturn ns;",
            "}",
            "static void update_clock_read_data(struct clock_read_data *rd)",
            "{",
            "\t/* update the backup (odd) copy with the new data */",
            "\tcd.read_data[1] = *rd;",
            "",
            "\t/* steer readers towards the odd copy */",
            "\traw_write_seqcount_latch(&cd.seq);",
            "",
            "\t/* now its safe for us to update the normal (even) copy */",
            "\tcd.read_data[0] = *rd;",
            "",
            "\t/* switch readers back to the even copy */",
            "\traw_write_seqcount_latch(&cd.seq);",
            "}",
            "static void update_sched_clock(void)",
            "{",
            "\tu64 cyc;",
            "\tu64 ns;",
            "\tstruct clock_read_data rd;",
            "",
            "\trd = cd.read_data[0];",
            "",
            "\tcyc = cd.actual_read_sched_clock();",
            "\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);",
            "",
            "\trd.epoch_ns = ns;",
            "\trd.epoch_cyc = cyc;",
            "",
            "\tupdate_clock_read_data(&rd);",
            "}",
            "static enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)",
            "{",
            "\tupdate_sched_clock();",
            "\thrtimer_forward_now(hrt, cd.wrap_kt);",
            "",
            "\treturn HRTIMER_RESTART;",
            "}",
            "void __init",
            "sched_clock_register(u64 (*read)(void), int bits, unsigned long rate)",
            "{",
            "\tu64 res, wrap, new_mask, new_epoch, cyc, ns;",
            "\tu32 new_mult, new_shift;",
            "\tunsigned long r, flags;",
            "\tchar r_unit;",
            "\tstruct clock_read_data rd;",
            "",
            "\tif (cd.rate > rate)",
            "\t\treturn;",
            "",
            "\t/* Cannot register a sched_clock with interrupts on */",
            "\tlocal_irq_save(flags);",
            "",
            "\t/* Calculate the mult/shift to convert counter ticks to ns. */",
            "\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);",
            "",
            "\tnew_mask = CLOCKSOURCE_MASK(bits);",
            "\tcd.rate = rate;",
            "",
            "\t/* Calculate how many nanosecs until we risk wrapping */",
            "\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);",
            "\tcd.wrap_kt = ns_to_ktime(wrap);",
            "",
            "\trd = cd.read_data[0];",
            "",
            "\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/",
            "\tnew_epoch = read();",
            "\tcyc = cd.actual_read_sched_clock();",
            "\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);",
            "\tcd.actual_read_sched_clock = read;",
            "",
            "\trd.read_sched_clock\t= read;",
            "\trd.sched_clock_mask\t= new_mask;",
            "\trd.mult\t\t\t= new_mult;",
            "\trd.shift\t\t= new_shift;",
            "\trd.epoch_cyc\t\t= new_epoch;",
            "\trd.epoch_ns\t\t= ns;",
            "",
            "\tupdate_clock_read_data(&rd);",
            "",
            "\tif (sched_clock_timer.function != NULL) {",
            "\t\t/* update timeout for clock wrap */",
            "\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt,",
            "\t\t\t      HRTIMER_MODE_REL_HARD);",
            "\t}",
            "",
            "\tr = rate;",
            "\tif (r >= 4000000) {",
            "\t\tr = DIV_ROUND_CLOSEST(r, 1000000);",
            "\t\tr_unit = 'M';",
            "\t} else if (r >= 4000) {",
            "\t\tr = DIV_ROUND_CLOSEST(r, 1000);",
            "\t\tr_unit = 'k';",
            "\t} else {",
            "\t\tr_unit = ' ';",
            "\t}",
            "",
            "\t/* Calculate the ns resolution of this counter */",
            "\tres = cyc_to_ns(1ULL, new_mult, new_shift);",
            "",
            "\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",",
            "\t\tbits, r, r_unit, res, wrap);",
            "",
            "\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */",
            "\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))",
            "\t\tenable_sched_clock_irqtime();",
            "",
            "\tlocal_irq_restore(flags);",
            "",
            "\tpr_debug(\"Registered %pS as sched_clock source\\n\", read);",
            "}"
          ],
          "function_name": "jiffy_sched_clock_read, cyc_to_ns, sched_clock_read_retry, sched_clock_noinstr, sched_clock, update_clock_read_data, update_sched_clock, sched_clock_poll, sched_clock_register",
          "description": "实现调度时钟读取逻辑，包含周期到纳秒转换、时钟数据更新、定时器回调及注册接口，支持多版本读取数据的原子更新和时钟包装检测",
          "similarity": 0.5741649866104126
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 237,
          "end_line": 285,
          "content": [
            "void __init generic_sched_clock_init(void)",
            "{",
            "\t/*",
            "\t * If no sched_clock() function has been provided at that point,",
            "\t * make it the final one.",
            "\t */",
            "\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)",
            "\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);",
            "",
            "\tupdate_sched_clock();",
            "",
            "\t/*",
            "\t * Start the timer to keep sched_clock() properly updated and",
            "\t * sets the initial epoch.",
            "\t */",
            "\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);",
            "\tsched_clock_timer.function = sched_clock_poll;",
            "\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);",
            "}",
            "static u64 notrace suspended_sched_clock_read(void)",
            "{",
            "\tunsigned int seq = raw_read_seqcount_latch(&cd.seq);",
            "",
            "\treturn cd.read_data[seq & 1].epoch_cyc;",
            "}",
            "int sched_clock_suspend(void)",
            "{",
            "\tstruct clock_read_data *rd = &cd.read_data[0];",
            "",
            "\tupdate_sched_clock();",
            "\thrtimer_cancel(&sched_clock_timer);",
            "\trd->read_sched_clock = suspended_sched_clock_read;",
            "",
            "\treturn 0;",
            "}",
            "void sched_clock_resume(void)",
            "{",
            "\tstruct clock_read_data *rd = &cd.read_data[0];",
            "",
            "\trd->epoch_cyc = cd.actual_read_sched_clock();",
            "\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);",
            "\trd->read_sched_clock = cd.actual_read_sched_clock;",
            "}",
            "static int __init sched_clock_syscore_init(void)",
            "{",
            "\tregister_syscore_ops(&sched_clock_ops);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "generic_sched_clock_init, suspended_sched_clock_read, sched_clock_suspend, sched_clock_resume, sched_clock_syscore_init",
          "description": "提供调度时钟初始化、挂起/恢复处理及系统核心操作注册，初始化阶段设置默认时钟源并启动更新定时器，挂起时切换至专用读取函数以保持时间连续性",
          "similarity": 0.5539588332176208
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 1,
          "end_line": 51,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Generic sched_clock() support, to extend low level hardware time",
            " * counters to full 64-bit ns values.",
            " */",
            "#include <linux/clocksource.h>",
            "#include <linux/init.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/math.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/bitops.h>",
            "",
            "#include \"timekeeping.h\"",
            "",
            "/**",
            " * struct clock_data - all data needed for sched_clock() (including",
            " *                     registration of a new clock source)",
            " *",
            " * @seq:\t\tSequence counter for protecting updates. The lowest",
            " *\t\t\tbit is the index for @read_data.",
            " * @read_data:\t\tData required to read from sched_clock.",
            " * @wrap_kt:\t\tDuration for which clock can run before wrapping.",
            " * @rate:\t\tTick rate of the registered clock.",
            " * @actual_read_sched_clock: Registered hardware level clock read function.",
            " *",
            " * The ordering of this structure has been chosen to optimize cache",
            " * performance. In particular 'seq' and 'read_data[0]' (combined) should fit",
            " * into a single 64-byte cache line.",
            " */",
            "struct clock_data {",
            "\tseqcount_latch_t\tseq;",
            "\tstruct clock_read_data\tread_data[2];",
            "\tktime_t\t\t\twrap_kt;",
            "\tunsigned long\t\trate;",
            "",
            "\tu64 (*actual_read_sched_clock)(void);",
            "};",
            "",
            "static struct hrtimer sched_clock_timer;",
            "static int irqtime = -1;",
            "",
            "core_param(irqtime, irqtime, int, 0400);",
            ""
          ],
          "function_name": null,
          "description": "定义调度时钟所需的数据结构和全局变量，其中struct clock_data用于存储时钟读取数据、序列计数器、包装时间、速率及实际读取函数指针，通过结构体布局优化缓存性能",
          "similarity": 0.5409801006317139
        }
      ]
    },
    {
      "source_file": "kernel/time/time.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:52:34\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\time.c`\n\n---\n\n# time/time.c 技术文档\n\n## 1. 文件概述\n\n`time/time.c` 是 Linux 内核中负责实现与时间相关的系统调用的核心文件。该文件提供了用户空间程序访问和设置系统时间的接口，包括 `time`、`stime`、`gettimeofday`、`settimeofday` 和 `adjtimex` 等传统 POSIX 时间系统调用。文件同时支持 32 位和 64 位时间表示，并处理不同架构和兼容性需求，确保内核时间子系统与用户空间的正确交互。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`sys_tz`** (`struct timezone`)：全局变量，存储系统默认时区信息，供 `gettimeofday` 系统调用返回。\n\n### 主要函数\n- **`SYSCALL_DEFINE1(time, ...)`**：返回自 Unix 纪元（1970-01-01 00:00:00 UTC）以来的秒数。\n- **`SYSCALL_DEFINE1(stime, ...)`**：设置系统时间（仅秒级精度）。\n- **`SYSCALL_DEFINE2(gettimeofday, ...)`**：获取高精度系统时间（微秒级）和时区信息。\n- **`SYSCALL_DEFINE2(settimeofday, ...)`**：设置系统时间（微秒级精度）和/或时区。\n- **`do_sys_settimeofday64(...)`**：`settimeofday` 的核心实现函数，处理时间/时区验证、安全检查和时钟调整。\n- **`SYSCALL_DEFINE1(adjtimex, ...)`**：用于 NTP（网络时间协议）时间同步，调整系统时钟频率和偏移。\n- **兼容性系统调用**：\n  - `time32` / `stime32`：32 位时间值的兼容接口（用于 `CONFIG_COMPAT_32BIT_TIME`）。\n  - `COMPAT_SYSCALL_DEFINE2(gettimeofday, ...)` / `COMPAT_SYSCALL_DEFINE2(settimeofday, ...)`：32 位用户空间兼容接口。\n- **辅助函数**：\n  - `get_old_timex32(...)`：将 32 位 `old_timex32` 结构转换为内核 `__kernel_timex`。\n  - `put_old_timex32(...)`：将内核 `__kernel_timex` 结构转换回 32 位 `old_timex32`（代码截断）。\n\n## 3. 关键实现\n\n### 时间获取与设置\n- 使用 `ktime_get_real_seconds()` 和 `ktime_get_real_ts64()` 从内核时间子系统获取高精度实时时间。\n- 时间设置通过 `do_settimeofday64()` 接口完成，该函数负责更新内核时间状态并通知相关子系统。\n\n### 时区处理\n- 全局变量 `sys_tz` 存储系统时区，通过 `settimeofday` 更新。\n- 首次设置时区时（`firsttime == 1`），若未同时设置时间，则调用 `timekeeping_warp_clock()` 将 CMOS 时钟从本地时间转换为 UTC 时间，避免时间跳变对应用程序造成影响。\n\n### 安全与验证\n- 所有修改系统时间的操作均调用 `security_settime64()` 进行 LSM（Linux Security Module）安全检查。\n- 输入参数严格验证：\n  - 时间值必须通过 `timespec64_valid_settod()` 检查有效性。\n  - 时区偏移限制在 ±15 小时范围内（`tz_minuteswest ∈ [-900, 900]`）。\n  - 微秒值必须在 `[0, USEC_PER_SEC)` 范围内。\n\n### 兼容性支持\n- 通过条件编译宏（如 `__ARCH_WANT_SYS_TIME`、`CONFIG_COMPAT_32BIT_TIME`、`CONFIG_COMPAT`）支持不同架构和位宽需求。\n- 32 位时间接口（`time32`/`stime32`）用于处理 `time_t` 为 32 位的旧应用程序。\n- 兼容层系统调用处理 32 位用户空间结构体与 64 位内核结构体之间的转换。\n\n### NTP 支持\n- `adjtimex` 系统调用提供对内核 PLL（锁相环）的精细控制，用于 NTP 时间同步。\n- 支持 NTPv4 规范，允许更大的时间常数（`time_constant > 6`）。\n\n## 4. 依赖关系\n\n- **内核时间子系统**：\n  - `<linux/timekeeper_internal.h>`、`\"timekeeping.h\"`：提供 `ktime_get_real_ts64()`、`do_settimeofday64()`、`timekeeping_warp_clock()` 等核心时间操作。\n- **安全框架**：\n  - `<linux/security.h>`：提供 `security_settime64()` 安全钩子。\n- **系统调用框架**：\n  - `<linux/syscalls.h>`：定义 `SYSCALL_DEFINE` 宏。\n  - `<linux/compat.h>`：提供 32/64 位兼容系统调用支持。\n- **架构相关**：\n  - `<asm/unistd.h>`：包含系统调用号定义。\n  - `__ARCH_WANT_SYS_TIME` 等宏由具体架构定义，决定是否编译传统时间系统调用。\n- **其他**：\n  - `<linux/uaccess.h>`：提供用户空间内存访问函数（`get_user`、`put_user`、`copy_to/from_user`）。\n  - `<generated/timeconst.h>`：包含编译时生成的时间常量。\n\n## 5. 使用场景\n\n- **用户空间时间获取**：应用程序通过 `gettimeofday()` 获取高精度当前时间，用于日志记录、性能分析、定时器等。\n- **系统时间设置**：管理员或 NTP 守护进程（如 `ntpd`、`chronyd`）通过 `settimeofday()` 或 `adjtimex()` 同步系统时间。\n- **时区配置**：系统初始化脚本（如 `/etc/rc`）通过 `settimeofday()` 设置时区，确保 CMOS 时钟以 UTC 运行。\n- **遗留应用支持**：32 位时间接口支持在 64 位系统上运行的旧版应用程序（Y2038 问题兼容）。\n- **NTP 精确时间同步**：`adjtimex()` 系统调用被 NTP 守护进程用于微调系统时钟频率和相位，实现高精度时间同步。",
      "similarity": 0.5491251349449158,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/time.c",
          "start_line": 1,
          "end_line": 168,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " *",
            " *  This file contains the interface functions for the various time related",
            " *  system calls: time, stime, gettimeofday, settimeofday, adjtime",
            " *",
            " * Modification history:",
            " *",
            " * 1993-09-02    Philip Gladstone",
            " *      Created file with time related functions from sched/core.c and adjtimex()",
            " * 1993-10-08    Torsten Duwe",
            " *      adjtime interface update and CMOS clock write code",
            " * 1995-08-13    Torsten Duwe",
            " *      kernel PLL updated to 1994-12-13 specs (rfc-1589)",
            " * 1999-01-16    Ulrich Windl",
            " *\tIntroduced error checking for many cases in adjtimex().",
            " *\tUpdated NTP code according to technical memorandum Jan '96",
            " *\t\"A Kernel Model for Precision Timekeeping\" by Dave Mills",
            " *\tAllow time_constant larger than MAXTC(6) for NTP v4 (MAXTC == 10)",
            " *\t(Even though the technical memorandum forbids it)",
            " * 2004-07-14\t Christoph Lameter",
            " *\tAdded getnstimeofday to allow the posix timer functions to return",
            " *\twith nanosecond accuracy",
            " */",
            "",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/timex.h>",
            "#include <linux/capability.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/errno.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/math64.h>",
            "#include <linux/ptrace.h>",
            "",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <asm/unistd.h>",
            "",
            "#include <generated/timeconst.h>",
            "#include \"timekeeping.h\"",
            "",
            "/*",
            " * The timezone where the local system is located.  Used as a default by some",
            " * programs who obtain this value by using gettimeofday.",
            " */",
            "struct timezone sys_tz;",
            "",
            "EXPORT_SYMBOL(sys_tz);",
            "",
            "#ifdef __ARCH_WANT_SYS_TIME",
            "",
            "/*",
            " * sys_time() can be implemented in user-level using",
            " * sys_gettimeofday().  Is this for backwards compatibility?  If so,",
            " * why not move it into the appropriate arch directory (for those",
            " * architectures that need it).",
            " */",
            "SYSCALL_DEFINE1(time, __kernel_old_time_t __user *, tloc)",
            "{",
            "\t__kernel_old_time_t i = (__kernel_old_time_t)ktime_get_real_seconds();",
            "",
            "\tif (tloc) {",
            "\t\tif (put_user(i,tloc))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\tforce_successful_syscall_return();",
            "\treturn i;",
            "}",
            "",
            "/*",
            " * sys_stime() can be implemented in user-level using",
            " * sys_settimeofday().  Is this for backwards compatibility?  If so,",
            " * why not move it into the appropriate arch directory (for those",
            " * architectures that need it).",
            " */",
            "",
            "SYSCALL_DEFINE1(stime, __kernel_old_time_t __user *, tptr)",
            "{",
            "\tstruct timespec64 tv;",
            "\tint err;",
            "",
            "\tif (get_user(tv.tv_sec, tptr))",
            "\t\treturn -EFAULT;",
            "",
            "\ttv.tv_nsec = 0;",
            "",
            "\terr = security_settime64(&tv, NULL);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tdo_settimeofday64(&tv);",
            "\treturn 0;",
            "}",
            "",
            "#endif /* __ARCH_WANT_SYS_TIME */",
            "",
            "#ifdef CONFIG_COMPAT_32BIT_TIME",
            "#ifdef __ARCH_WANT_SYS_TIME32",
            "",
            "/* old_time32_t is a 32 bit \"long\" and needs to get converted. */",
            "SYSCALL_DEFINE1(time32, old_time32_t __user *, tloc)",
            "{",
            "\told_time32_t i;",
            "",
            "\ti = (old_time32_t)ktime_get_real_seconds();",
            "",
            "\tif (tloc) {",
            "\t\tif (put_user(i,tloc))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\tforce_successful_syscall_return();",
            "\treturn i;",
            "}",
            "",
            "SYSCALL_DEFINE1(stime32, old_time32_t __user *, tptr)",
            "{",
            "\tstruct timespec64 tv;",
            "\tint err;",
            "",
            "\tif (get_user(tv.tv_sec, tptr))",
            "\t\treturn -EFAULT;",
            "",
            "\ttv.tv_nsec = 0;",
            "",
            "\terr = security_settime64(&tv, NULL);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tdo_settimeofday64(&tv);",
            "\treturn 0;",
            "}",
            "",
            "#endif /* __ARCH_WANT_SYS_TIME32 */",
            "#endif",
            "",
            "SYSCALL_DEFINE2(gettimeofday, struct __kernel_old_timeval __user *, tv,",
            "\t\tstruct timezone __user *, tz)",
            "{",
            "\tif (likely(tv != NULL)) {",
            "\t\tstruct timespec64 ts;",
            "",
            "\t\tktime_get_real_ts64(&ts);",
            "\t\tif (put_user(ts.tv_sec, &tv->tv_sec) ||",
            "\t\t    put_user(ts.tv_nsec / 1000, &tv->tv_usec))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\tif (unlikely(tz != NULL)) {",
            "\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "\treturn 0;",
            "}",
            "",
            "/*",
            " * In case for some reason the CMOS clock has not already been running",
            " * in UTC, but in some local time: The first time we set the timezone,",
            " * we will warp the clock so that it is ticking UTC time instead of",
            " * local time. Presumably, if someone is setting the timezone then we",
            " * are running in an environment where the programs understand about",
            " * timezones. This should be done at boot time in the /etc/rc script,",
            " * as soon as possible, so that the clock can be set right. Otherwise,",
            " * various programs will get confused when the clock gets warped.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "定义了时间相关系统调用接口，包括time、stime、gettimeofday等函数，用于获取和设置系统时间及时区信息，包含安全检查和用户空间数据拷贝操作。",
          "similarity": 0.6058027744293213
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/time.c",
          "start_line": 616,
          "end_line": 720,
          "content": [
            "unsigned long",
            "timespec64_to_jiffies(const struct timespec64 *value)",
            "{",
            "\tu64 sec = value->tv_sec;",
            "\tlong nsec = value->tv_nsec + TICK_NSEC - 1;",
            "",
            "\tif (sec >= MAX_SEC_IN_JIFFIES){",
            "\t\tsec = MAX_SEC_IN_JIFFIES;",
            "\t\tnsec = 0;",
            "\t}",
            "\treturn ((sec * SEC_CONVERSION) +",
            "\t\t(((u64)nsec * NSEC_CONVERSION) >>",
            "\t\t (NSEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;",
            "",
            "}",
            "void",
            "jiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)",
            "{",
            "\t/*",
            "\t * Convert jiffies to nanoseconds and separate with",
            "\t * one divide.",
            "\t */",
            "\tu32 rem;",
            "\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,",
            "\t\t\t\t    NSEC_PER_SEC, &rem);",
            "\tvalue->tv_nsec = rem;",
            "}",
            "clock_t jiffies_to_clock_t(unsigned long x)",
            "{",
            "#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0",
            "# if HZ < USER_HZ",
            "\treturn x * (USER_HZ / HZ);",
            "# else",
            "\treturn x / (HZ / USER_HZ);",
            "# endif",
            "#else",
            "\treturn div_u64((u64)x * TICK_NSEC, NSEC_PER_SEC / USER_HZ);",
            "#endif",
            "}",
            "unsigned long clock_t_to_jiffies(unsigned long x)",
            "{",
            "#if (HZ % USER_HZ)==0",
            "\tif (x >= ~0UL / (HZ / USER_HZ))",
            "\t\treturn ~0UL;",
            "\treturn x * (HZ / USER_HZ);",
            "#else",
            "\t/* Don't worry about loss of precision here .. */",
            "\tif (x >= ~0UL / HZ * USER_HZ)",
            "\t\treturn ~0UL;",
            "",
            "\t/* .. but do try to contain it here */",
            "\treturn div_u64((u64)x * HZ, USER_HZ);",
            "#endif",
            "}",
            "u64 jiffies_64_to_clock_t(u64 x)",
            "{",
            "#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0",
            "# if HZ < USER_HZ",
            "\tx = div_u64(x * USER_HZ, HZ);",
            "# elif HZ > USER_HZ",
            "\tx = div_u64(x, HZ / USER_HZ);",
            "# else",
            "\t/* Nothing to do */",
            "# endif",
            "#else",
            "\t/*",
            "\t * There are better ways that don't overflow early,",
            "\t * but even this doesn't overflow in hundreds of years",
            "\t * in 64 bits, so..",
            "\t */",
            "\tx = div_u64(x * TICK_NSEC, (NSEC_PER_SEC / USER_HZ));",
            "#endif",
            "\treturn x;",
            "}",
            "u64 nsec_to_clock_t(u64 x)",
            "{",
            "#if (NSEC_PER_SEC % USER_HZ) == 0",
            "\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);",
            "#elif (USER_HZ % 512) == 0",
            "\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);",
            "#else",
            "\t/*",
            "         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,",
            "         * overflow after 64.99 years.",
            "         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...",
            "         */",
            "\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);",
            "#endif",
            "}",
            "u64 jiffies64_to_nsecs(u64 j)",
            "{",
            "#if !(NSEC_PER_SEC % HZ)",
            "\treturn (NSEC_PER_SEC / HZ) * j;",
            "# else",
            "\treturn div_u64(j * HZ_TO_NSEC_NUM, HZ_TO_NSEC_DEN);",
            "#endif",
            "}",
            "u64 jiffies64_to_msecs(const u64 j)",
            "{",
            "#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)",
            "\treturn (MSEC_PER_SEC / HZ) * j;",
            "#else",
            "\treturn div_u64(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);",
            "#endif",
            "}"
          ],
          "function_name": "timespec64_to_jiffies, jiffies_to_timespec64, jiffies_to_clock_t, clock_t_to_jiffies, jiffies_64_to_clock_t, nsec_to_clock_t, jiffies64_to_nsecs, jiffies64_to_msecs",
          "description": "提供多种时间表示形式转换函数，包括timespec64与jiffies互转，clock_t与jiffies转换，以及nsec到clock_t等不同时间域间的转换实现。",
          "similarity": 0.602814257144928
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/time.c",
          "start_line": 169,
          "end_line": 273,
          "content": [
            "int do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)",
            "{",
            "\tstatic int firsttime = 1;",
            "\tint error = 0;",
            "",
            "\tif (tv && !timespec64_valid_settod(tv))",
            "\t\treturn -EINVAL;",
            "",
            "\terror = security_settime64(tv, tz);",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\tif (tz) {",
            "\t\t/* Verify we're within the +-15 hrs range */",
            "\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tsys_tz = *tz;",
            "\t\tupdate_vsyscall_tz();",
            "\t\tif (firsttime) {",
            "\t\t\tfirsttime = 0;",
            "\t\t\tif (!tv)",
            "\t\t\t\ttimekeeping_warp_clock();",
            "\t\t}",
            "\t}",
            "\tif (tv)",
            "\t\treturn do_settimeofday64(tv);",
            "\treturn 0;",
            "}",
            "int get_old_timex32(struct __kernel_timex *txc, const struct old_timex32 __user *utp)",
            "{",
            "\tstruct old_timex32 tx32;",
            "",
            "\tmemset(txc, 0, sizeof(struct __kernel_timex));",
            "\tif (copy_from_user(&tx32, utp, sizeof(struct old_timex32)))",
            "\t\treturn -EFAULT;",
            "",
            "\ttxc->modes = tx32.modes;",
            "\ttxc->offset = tx32.offset;",
            "\ttxc->freq = tx32.freq;",
            "\ttxc->maxerror = tx32.maxerror;",
            "\ttxc->esterror = tx32.esterror;",
            "\ttxc->status = tx32.status;",
            "\ttxc->constant = tx32.constant;",
            "\ttxc->precision = tx32.precision;",
            "\ttxc->tolerance = tx32.tolerance;",
            "\ttxc->time.tv_sec = tx32.time.tv_sec;",
            "\ttxc->time.tv_usec = tx32.time.tv_usec;",
            "\ttxc->tick = tx32.tick;",
            "\ttxc->ppsfreq = tx32.ppsfreq;",
            "\ttxc->jitter = tx32.jitter;",
            "\ttxc->shift = tx32.shift;",
            "\ttxc->stabil = tx32.stabil;",
            "\ttxc->jitcnt = tx32.jitcnt;",
            "\ttxc->calcnt = tx32.calcnt;",
            "\ttxc->errcnt = tx32.errcnt;",
            "\ttxc->stbcnt = tx32.stbcnt;",
            "",
            "\treturn 0;",
            "}",
            "int put_old_timex32(struct old_timex32 __user *utp, const struct __kernel_timex *txc)",
            "{",
            "\tstruct old_timex32 tx32;",
            "",
            "\tmemset(&tx32, 0, sizeof(struct old_timex32));",
            "\ttx32.modes = txc->modes;",
            "\ttx32.offset = txc->offset;",
            "\ttx32.freq = txc->freq;",
            "\ttx32.maxerror = txc->maxerror;",
            "\ttx32.esterror = txc->esterror;",
            "\ttx32.status = txc->status;",
            "\ttx32.constant = txc->constant;",
            "\ttx32.precision = txc->precision;",
            "\ttx32.tolerance = txc->tolerance;",
            "\ttx32.time.tv_sec = txc->time.tv_sec;",
            "\ttx32.time.tv_usec = txc->time.tv_usec;",
            "\ttx32.tick = txc->tick;",
            "\ttx32.ppsfreq = txc->ppsfreq;",
            "\ttx32.jitter = txc->jitter;",
            "\ttx32.shift = txc->shift;",
            "\ttx32.stabil = txc->stabil;",
            "\ttx32.jitcnt = txc->jitcnt;",
            "\ttx32.calcnt = txc->calcnt;",
            "\ttx32.errcnt = txc->errcnt;",
            "\ttx32.stbcnt = txc->stbcnt;",
            "\ttx32.tai = txc->tai;",
            "\tif (copy_to_user(utp, &tx32, sizeof(struct old_timex32)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "unsigned int jiffies_to_msecs(const unsigned long j)",
            "{",
            "#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)",
            "\treturn (MSEC_PER_SEC / HZ) * j;",
            "#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)",
            "\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);",
            "#else",
            "# if BITS_PER_LONG == 32",
            "\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>",
            "\t       HZ_TO_MSEC_SHR32;",
            "# else",
            "\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);",
            "# endif",
            "#endif",
            "}"
          ],
          "function_name": "do_sys_settimeofday64, get_old_timex32, put_old_timex32, jiffies_to_msecs",
          "description": "实现do_sys_settimeofday64用于设置系统时间，提供old_timex结构体转换函数get_old_timex32/put_old_timex32，以及jiffies到毫秒的转换函数jiffies_to_msecs。",
          "similarity": 0.5824571847915649
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/time.c",
          "start_line": 400,
          "end_line": 501,
          "content": [
            "unsigned int jiffies_to_usecs(const unsigned long j)",
            "{",
            "\t/*",
            "\t * Hz usually doesn't go much further MSEC_PER_SEC.",
            "\t * jiffies_to_usecs() and usecs_to_jiffies() depend on that.",
            "\t */",
            "\tBUILD_BUG_ON(HZ > USEC_PER_SEC);",
            "",
            "#if !(USEC_PER_SEC % HZ)",
            "\treturn (USEC_PER_SEC / HZ) * j;",
            "#else",
            "# if BITS_PER_LONG == 32",
            "\treturn (HZ_TO_USEC_MUL32 * j) >> HZ_TO_USEC_SHR32;",
            "# else",
            "\treturn (j * HZ_TO_USEC_NUM) / HZ_TO_USEC_DEN;",
            "# endif",
            "#endif",
            "}",
            "time64_t mktime64(const unsigned int year0, const unsigned int mon0,",
            "\t\tconst unsigned int day, const unsigned int hour,",
            "\t\tconst unsigned int min, const unsigned int sec)",
            "{",
            "\tunsigned int mon = mon0, year = year0;",
            "",
            "\t/* 1..12 -> 11,12,1..10 */",
            "\tif (0 >= (int) (mon -= 2)) {",
            "\t\tmon += 12;\t/* Puts Feb last since it has leap day */",
            "\t\tyear -= 1;",
            "\t}",
            "",
            "\treturn ((((time64_t)",
            "\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +",
            "\t\t  year*365 - 719499",
            "\t    )*24 + hour /* now have hours - midnight tomorrow handled here */",
            "\t  )*60 + min /* now have minutes */",
            "\t)*60 + sec; /* finally seconds */",
            "}",
            "struct __kernel_old_timeval ns_to_kernel_old_timeval(s64 nsec)",
            "{",
            "\tstruct timespec64 ts = ns_to_timespec64(nsec);",
            "\tstruct __kernel_old_timeval tv;",
            "",
            "\ttv.tv_sec = ts.tv_sec;",
            "\ttv.tv_usec = (suseconds_t)ts.tv_nsec / 1000;",
            "",
            "\treturn tv;",
            "}",
            "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)",
            "{",
            "\twhile (nsec >= NSEC_PER_SEC) {",
            "\t\t/*",
            "\t\t * The following asm() prevents the compiler from",
            "\t\t * optimising this loop into a modulo operation. See",
            "\t\t * also __iter_div_u64_rem() in include/linux/time.h",
            "\t\t */",
            "\t\tasm(\"\" : \"+rm\"(nsec));",
            "\t\tnsec -= NSEC_PER_SEC;",
            "\t\t++sec;",
            "\t}",
            "\twhile (nsec < 0) {",
            "\t\tasm(\"\" : \"+rm\"(nsec));",
            "\t\tnsec += NSEC_PER_SEC;",
            "\t\t--sec;",
            "\t}",
            "\tts->tv_sec = sec;",
            "\tts->tv_nsec = nsec;",
            "}",
            "struct timespec64 ns_to_timespec64(s64 nsec)",
            "{",
            "\tstruct timespec64 ts = { 0, 0 };",
            "\ts32 rem;",
            "",
            "\tif (likely(nsec > 0)) {",
            "\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);",
            "\t\tts.tv_nsec = rem;",
            "\t} else if (nsec < 0) {",
            "\t\t/*",
            "\t\t * With negative times, tv_sec points to the earlier",
            "\t\t * second, and tv_nsec counts the nanoseconds since",
            "\t\t * then, so tv_nsec is always a positive number.",
            "\t\t */",
            "\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;",
            "\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;",
            "\t}",
            "",
            "\treturn ts;",
            "}",
            "unsigned long __msecs_to_jiffies(const unsigned int m)",
            "{",
            "\t/*",
            "\t * Negative value, means infinite timeout:",
            "\t */",
            "\tif ((int)m < 0)",
            "\t\treturn MAX_JIFFY_OFFSET;",
            "\treturn _msecs_to_jiffies(m);",
            "}",
            "unsigned long __usecs_to_jiffies(const unsigned int u)",
            "{",
            "\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))",
            "\t\treturn MAX_JIFFY_OFFSET;",
            "\treturn _usecs_to_jiffies(u);",
            "}"
          ],
          "function_name": "jiffies_to_usecs, mktime64, ns_to_kernel_old_timeval, set_normalized_timespec64, ns_to_timespec64, __msecs_to_jiffies, __usecs_to_jiffies",
          "description": "包含时间单位转换函数jiffies_to_usecs/msecs_to_jiffies等，实现mktime64日期转时间戳，ns_to_*系列纳秒到时间结构体转换，以及set_normalized_timespec64时间归一化处理。",
          "similarity": 0.5689969062805176
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/time/time.c",
          "start_line": 984,
          "end_line": 1026,
          "content": [
            "int get_itimerspec64(struct itimerspec64 *it,",
            "\t\t\tconst struct __kernel_itimerspec __user *uit)",
            "{",
            "\tint ret;",
            "",
            "\tret = get_timespec64(&it->it_interval, &uit->it_interval);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = get_timespec64(&it->it_value, &uit->it_value);",
            "",
            "\treturn ret;",
            "}",
            "int put_itimerspec64(const struct itimerspec64 *it,",
            "\t\t\tstruct __kernel_itimerspec __user *uit)",
            "{",
            "\tint ret;",
            "",
            "\tret = put_timespec64(&it->it_interval, &uit->it_interval);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = put_timespec64(&it->it_value, &uit->it_value);",
            "",
            "\treturn ret;",
            "}",
            "int get_old_itimerspec32(struct itimerspec64 *its,",
            "\t\t\tconst struct old_itimerspec32 __user *uits)",
            "{",
            "",
            "\tif (__get_old_timespec32(&its->it_interval, &uits->it_interval) ||",
            "\t    __get_old_timespec32(&its->it_value, &uits->it_value))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "int put_old_itimerspec32(const struct itimerspec64 *its,",
            "\t\t\tstruct old_itimerspec32 __user *uits)",
            "{",
            "\tif (__put_old_timespec32(&its->it_interval, &uits->it_interval) ||",
            "\t    __put_old_timespec32(&its->it_value, &uits->it_value))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_itimerspec64, put_itimerspec64, get_old_itimerspec32, put_old_itimerspec32",
          "description": "该代码块实现了对时间间隔结构体（itimerspec）在用户空间与内核空间之间的转换，包含64位和32位兼容处理。  \n`get/put_itimerspec64` 用于64位时间规范的双向转换，通过 `get/put_timespec64` 处理内部时间戳字段；`get_old/put_old_itimerspec32` 专为兼容旧版32位接口设计，通过辅助函数进行安全拷贝并检查错误。  \n由于代码未包含 `get_timespec64`、`put_timespec64` 及 `__get_old_timespec32` 等关键辅助函数的定义，上下文信息不完整。",
          "similarity": 0.5644744634628296
        }
      ]
    }
  ]
}