{
  "query": "TCP/IP数据包处理流程",
  "timestamp": "2025-12-26 01:19:33",
  "retrieved_files": [
    {
      "source_file": "kernel/signal.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:24:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `signal.c`\n\n---\n\n# signal.c 技术文档\n\n## 1. 文件概述\n\n`signal.c` 是 Linux 内核中信号子系统的核心实现文件，负责管理进程间信号的发送、接收、排队、处理以及相关状态的维护。该文件实现了 POSIX 信号语义，包括标准信号和实时信号（通过 sigqueue），并处理信号的阻塞、忽略、默认行为及用户自定义处理函数的调用逻辑。它还集成了对 ptrace 调试、作业控制（job control）、冻结（freezer）和 cgroup 等子系统的支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `sigqueue_cachep`：用于分配 `sigqueue` 结构的 slab 缓存，支持可靠信号排队。\n- `task_struct::pending`：每个任务私有的挂起信号队列。\n- `signal_struct::shared_pending`：线程组共享的挂起信号队列。\n- `task_struct::blocked` / `real_blocked`：信号阻塞掩码。\n- `task_struct::jobctl`：作业控制相关状态位（如停止、陷阱等）。\n\n### 主要函数\n- `sig_handler()`：获取指定信号的处理函数指针。\n- `sig_handler_ignored()`：判断信号是否被显式或隐式忽略。\n- `sig_task_ignored()` / `sig_ignored()`：判断任务是否忽略某信号（考虑 init、kthread、ptrace 等特殊情况）。\n- `has_pending_signals()`：检查在给定阻塞掩码下是否存在可投递的挂起信号。\n- `recalc_sigpending_tsk()` / `recalc_sigpending()` / `recalc_sigpending_and_wake()`：重新计算并设置 `TIF_SIGPENDING` 线程标志。\n- `next_signal()`：从挂起信号中选择下一个应被处理的信号，优先处理同步信号（如 SIGSEGV、SIGILL 等）。\n- `task_set_jobctl_pending()`：设置任务的作业控制挂起状态（如停止请求）。\n- `task_clear_jobctl_trapping()`：清除作业控制陷阱状态并唤醒跟踪者（ptracer）。\n- `print_dropped_signal()`：当日志开启且达到 `RLIMIT_SIGPENDING` 限制时，记录被丢弃的信号。\n\n## 3. 关键实现\n\n### 信号忽略逻辑\n信号是否被忽略不仅取决于处理函数是否为 `SIG_IGN` 或默认且内核定义为可忽略（`sig_kernel_ignore()`），还需考虑：\n- 全局 init 进程不能接收 `SIGKILL`/`SIGSTOP`。\n- `SIGNAL_UNKILLABLE` 任务对默认处理的内核信号有特殊豁免。\n- 内核线程（`PF_KTHREAD`）仅响应强制（`force=true`）的内核信号。\n- 若任务被 ptrace 跟踪，除 `SIGKILL` 外，即使信号被忽略也需通知调试器。\n\n### 挂起信号检测优化\n`has_pending_signals()` 使用位运算高效检查 `signal & ~blocked` 是否非零，并针对 `_NSIG_WORDS` 的常见值（1、2、4）进行展开优化，避免循环开销。\n\n### 信号选择策略\n`next_signal()` 优先处理同步信号（定义在 `SYNCHRONOUS_MASK` 中），确保如段错误、非法指令等异常能被及时响应，符合 POSIX 对同步信号“立即投递”的要求。\n\n### TIF_SIGPENDING 标志管理\n- `recalc_sigpending_tsk()` 综合检查私有/共享挂起信号、作业控制状态和 cgroup 冻结状态，决定是否设置 `TIF_SIGPENDING`。\n- 为避免竞态，**不清除**该标志，仅由明确知道安全的调用者（如 `recalc_sigpending()`）在适当上下文中清除。\n- `recalc_sigpending_and_wake()` 在设置标志后主动唤醒任务，确保其能及时处理信号。\n\n### 作业控制集成\n通过 `jobctl` 字段和 `JOBCTL_*` 位掩码，支持 ptrace 和作业控制的复杂状态机（如停止、陷阱、信号消费），并在 `siglock` 保护下安全更新。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`thread_info` 标志（如 `TIF_SIGPENDING`）、`PF_EXITING` 等。\n- **内存管理**：使用 slab 分配器（`kmem_cache`）管理 `sigqueue`。\n- **进程管理**：与 `fork`/`exec`/`exit` 流程交互（如 `calculate_sigpending` 在 fork 后调用）。\n- **ptrace**：通过 `ptrace` 字段和 `JOBCTL_TRAPPING` 支持调试器信号拦截。\n- **cgroup/freezer**：检查 `cgroup_task_frozen()` 状态影响信号挂起判断。\n- **安全模块**：通过 `security_task_kill()` 等钩子（虽未在片段中体现，但完整文件包含）。\n- **tracepoint**：定义 `trace/events/signal.h` 中的跟踪点用于调试。\n- **架构相关代码**：依赖 `asm/siginfo.h`、`uaccess.h` 等处理用户空间信号帧。\n\n## 5. 使用场景\n\n- **系统调用处理**：`kill()`、`tkill()`、`rt_sigqueueinfo()` 等信号发送系统调用最终调用本文件逻辑。\n- **异常处理**：CPU 异常（如页错误、除零）触发同步信号（SIGSEGV、SIGFPE），由本文件选择并准备投递。\n- **进程生命周期管理**：在 `do_exit()`、`flush_old_exec()` 等路径中清理或重置信号状态。\n- **调试器支持**：ptrace 在注入信号或单步执行时依赖作业控制状态和信号忽略逻辑。\n- **资源限制**：当信号队列达到 `RLIMIT_SIGPENDING` 限制时，调用 `print_dropped_signal()` 记录丢弃事件。\n- **冻结/恢复**：cgroup freezer 或 suspend 流程通过 `cgroup_task_frozen()` 影响信号挂起状态，确保任务在冻结期间不处理信号。",
      "similarity": 0.5755293369293213,
      "chunks": [
        {
          "chunk_id": 23,
          "file_path": "kernel/signal.c",
          "start_line": 3620,
          "end_line": 3730,
          "content": [
            "static int __copy_siginfo_from_user32(int signo, struct kernel_siginfo *to,",
            "\t\t\t\t      const struct compat_siginfo __user *ufrom)",
            "{",
            "\tstruct compat_siginfo from;",
            "",
            "\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))",
            "\t\treturn -EFAULT;",
            "",
            "\tfrom.si_signo = signo;",
            "\treturn post_copy_siginfo_from_user32(to, &from);",
            "}",
            "int copy_siginfo_from_user32(struct kernel_siginfo *to,",
            "\t\t\t     const struct compat_siginfo __user *ufrom)",
            "{",
            "\tstruct compat_siginfo from;",
            "",
            "\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn post_copy_siginfo_from_user32(to, &from);",
            "}",
            "static int do_sigtimedwait(const sigset_t *which, kernel_siginfo_t *info,",
            "\t\t    const struct timespec64 *ts)",
            "{",
            "\tktime_t *to = NULL, timeout = KTIME_MAX;",
            "\tstruct task_struct *tsk = current;",
            "\tsigset_t mask = *which;",
            "\tenum pid_type type;",
            "\tint sig, ret = 0;",
            "",
            "\tif (ts) {",
            "\t\tif (!timespec64_valid(ts))",
            "\t\t\treturn -EINVAL;",
            "\t\ttimeout = timespec64_to_ktime(*ts);",
            "\t\tto = &timeout;",
            "\t}",
            "",
            "\t/*",
            "\t * Invert the set of allowed signals to get those we want to block.",
            "\t */",
            "\tsigdelsetmask(&mask, sigmask(SIGKILL) | sigmask(SIGSTOP));",
            "\tsignotset(&mask);",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "\tsig = dequeue_signal(tsk, &mask, info, &type);",
            "\tif (!sig && timeout) {",
            "\t\t/*",
            "\t\t * None ready, temporarily unblock those we're interested",
            "\t\t * while we are sleeping in so that we'll be awakened when",
            "\t\t * they arrive. Unblocking is always fine, we can avoid",
            "\t\t * set_current_blocked().",
            "\t\t */",
            "\t\ttsk->real_blocked = tsk->blocked;",
            "\t\tsigandsets(&tsk->blocked, &tsk->blocked, &mask);",
            "\t\trecalc_sigpending();",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\t\t__set_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE);",
            "\t\tret = schedule_hrtimeout_range(to, tsk->timer_slack_ns,",
            "\t\t\t\t\t       HRTIMER_MODE_REL);",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\t__set_task_blocked(tsk, &tsk->real_blocked);",
            "\t\tsigemptyset(&tsk->real_blocked);",
            "\t\tsig = dequeue_signal(tsk, &mask, info, &type);",
            "\t}",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tif (sig)",
            "\t\treturn sig;",
            "\treturn ret ? -EINTR : -EAGAIN;",
            "}",
            "static void prepare_kill_siginfo(int sig, struct kernel_siginfo *info,",
            "\t\t\t\t enum pid_type type)",
            "{",
            "\tclear_siginfo(info);",
            "\tinfo->si_signo = sig;",
            "\tinfo->si_errno = 0;",
            "\tinfo->si_code = (type == PIDTYPE_PID) ? SI_TKILL : SI_USER;",
            "\tinfo->si_pid = task_tgid_vnr(current);",
            "\tinfo->si_uid = from_kuid_munged(current_user_ns(), current_uid());",
            "}",
            "static bool access_pidfd_pidns(struct pid *pid)",
            "{",
            "\tstruct pid_namespace *active = task_active_pid_ns(current);",
            "\tstruct pid_namespace *p = ns_of_pid(pid);",
            "",
            "\tfor (;;) {",
            "\t\tif (!p)",
            "\t\t\treturn false;",
            "\t\tif (p == active)",
            "\t\t\tbreak;",
            "\t\tp = p->parent;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,",
            "\t\tsiginfo_t __user *info)",
            "{",
            "#ifdef CONFIG_COMPAT",
            "\t/*",
            "\t * Avoid hooking up compat syscalls and instead handle necessary",
            "\t * conversions here. Note, this is a stop-gap measure and should not be",
            "\t * considered a generic solution.",
            "\t */",
            "\tif (in_compat_syscall())",
            "\t\treturn copy_siginfo_from_user32(",
            "\t\t\tkinfo, (struct compat_siginfo __user *)info);",
            "#endif",
            "\treturn copy_siginfo_from_user(kinfo, info);",
            "}"
          ],
          "function_name": "__copy_siginfo_from_user32, copy_siginfo_from_user32, do_sigtimedwait, prepare_kill_siginfo, access_pidfd_pidns, copy_siginfo_from_user_any",
          "description": "实现信号等待、发送及信号信息解析功能，包含定时等待信号、进程权限检查和信号信息格式转换等核心逻辑。",
          "similarity": 0.5741270780563354
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/signal.c",
          "start_line": 559,
          "end_line": 706,
          "content": [
            "bool unhandled_signal(struct task_struct *tsk, int sig)",
            "{",
            "\tvoid __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;",
            "\tif (is_global_init(tsk))",
            "\t\treturn true;",
            "",
            "\tif (handler != SIG_IGN && handler != SIG_DFL)",
            "\t\treturn false;",
            "",
            "\t/* If dying, we handle all new signals by ignoring them */",
            "\tif (fatal_signal_pending(tsk))",
            "\t\treturn false;",
            "",
            "\t/* if ptraced, let the tracer determine */",
            "\treturn !tsk->ptrace;",
            "}",
            "static void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,",
            "\t\t\t   bool *resched_timer)",
            "{",
            "\tstruct sigqueue *q, *first = NULL;",
            "",
            "\t/*",
            "\t * Collect the siginfo appropriate to this signal.  Check if",
            "\t * there is another siginfo for the same signal.",
            "\t*/",
            "\tlist_for_each_entry(q, &list->list, list) {",
            "\t\tif (q->info.si_signo == sig) {",
            "\t\t\tif (first)",
            "\t\t\t\tgoto still_pending;",
            "\t\t\tfirst = q;",
            "\t\t}",
            "\t}",
            "",
            "\tsigdelset(&list->signal, sig);",
            "",
            "\tif (first) {",
            "still_pending:",
            "\t\tlist_del_init(&first->list);",
            "\t\tcopy_siginfo(info, &first->info);",
            "",
            "\t\t*resched_timer =",
            "\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&",
            "\t\t\t(info->si_code == SI_TIMER) &&",
            "\t\t\t(info->si_sys_private);",
            "",
            "\t\t__sigqueue_free(first);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Ok, it wasn't in the queue.  This must be",
            "\t\t * a fast-pathed signal or we must have been",
            "\t\t * out of queue space.  So zero out the info.",
            "\t\t */",
            "\t\tclear_siginfo(info);",
            "\t\tinfo->si_signo = sig;",
            "\t\tinfo->si_errno = 0;",
            "\t\tinfo->si_code = SI_USER;",
            "\t\tinfo->si_pid = 0;",
            "\t\tinfo->si_uid = 0;",
            "\t}",
            "}",
            "static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,",
            "\t\t\tkernel_siginfo_t *info, bool *resched_timer)",
            "{",
            "\tint sig = next_signal(pending, mask);",
            "",
            "\tif (sig)",
            "\t\tcollect_signal(sig, pending, info, resched_timer);",
            "\treturn sig;",
            "}",
            "int dequeue_signal(struct task_struct *tsk, sigset_t *mask,",
            "\t\t   kernel_siginfo_t *info, enum pid_type *type)",
            "{",
            "\tbool resched_timer = false;",
            "\tint signr;",
            "",
            "\t/* We only dequeue private signals from ourselves, we don't let",
            "\t * signalfd steal them",
            "\t */",
            "\t*type = PIDTYPE_PID;",
            "\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);",
            "\tif (!signr) {",
            "\t\t*type = PIDTYPE_TGID;",
            "\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,",
            "\t\t\t\t\t mask, info, &resched_timer);",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\t\t/*",
            "\t\t * itimer signal ?",
            "\t\t *",
            "\t\t * itimers are process shared and we restart periodic",
            "\t\t * itimers in the signal delivery path to prevent DoS",
            "\t\t * attacks in the high resolution timer case. This is",
            "\t\t * compliant with the old way of self-restarting",
            "\t\t * itimers, as the SIGALRM is a legacy signal and only",
            "\t\t * queued once. Changing the restart behaviour to",
            "\t\t * restart the timer in the signal dequeue path is",
            "\t\t * reducing the timer noise on heavy loaded !highres",
            "\t\t * systems too.",
            "\t\t */",
            "\t\tif (unlikely(signr == SIGALRM)) {",
            "\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;",
            "",
            "\t\t\tif (!hrtimer_is_queued(tmr) &&",
            "\t\t\t    tsk->signal->it_real_incr != 0) {",
            "\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),",
            "\t\t\t\t\t\ttsk->signal->it_real_incr);",
            "\t\t\t\thrtimer_restart(tmr);",
            "\t\t\t}",
            "\t\t}",
            "#endif",
            "\t}",
            "",
            "\trecalc_sigpending();",
            "\tif (!signr)",
            "\t\treturn 0;",
            "",
            "\tif (unlikely(sig_kernel_stop(signr))) {",
            "\t\t/*",
            "\t\t * Set a marker that we have dequeued a stop signal.  Our",
            "\t\t * caller might release the siglock and then the pending",
            "\t\t * stop signal it is about to process is no longer in the",
            "\t\t * pending bitmasks, but must still be cleared by a SIGCONT",
            "\t\t * (and overruled by a SIGKILL).  So those cases clear this",
            "\t\t * shared flag after we've set it.  Note that this flag may",
            "\t\t * remain set after the signal we return is ignored or",
            "\t\t * handled.  That doesn't matter because its only purpose",
            "\t\t * is to alert stop-signal processing code when another",
            "\t\t * processor has come along and cleared the flag.",
            "\t\t */",
            "\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;",
            "\t}",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\tif (resched_timer) {",
            "\t\t/*",
            "\t\t * Release the siglock to ensure proper locking order",
            "\t\t * of timer locks outside of siglocks.  Note, we leave",
            "\t\t * irqs disabled here, since the posix-timers code is",
            "\t\t * about to disable them again anyway.",
            "\t\t */",
            "\t\tspin_unlock(&tsk->sighand->siglock);",
            "\t\tposixtimer_rearm(info);",
            "\t\tspin_lock(&tsk->sighand->siglock);",
            "",
            "\t\t/* Don't expose the si_sys_private value to userspace */",
            "\t\tinfo->si_sys_private = 0;",
            "\t}",
            "#endif",
            "\treturn signr;",
            "}"
          ],
          "function_name": "unhandled_signal, collect_signal, __dequeue_signal, dequeue_signal",
          "description": "实现信号处理路径，包含未处理信号判定、信号信息收集、信号队列弹出操作及特殊信号（如SIGALRM）的处理逻辑。",
          "similarity": 0.5626567006111145
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/signal.c",
          "start_line": 1788,
          "end_line": 1900,
          "content": [
            "int send_sig_mceerr(int code, void __user *addr, short lsb, struct task_struct *t)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGBUS;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code = code;",
            "\tinfo.si_addr = addr;",
            "\tinfo.si_addr_lsb = lsb;",
            "\treturn send_sig_info(info.si_signo, &info, t);",
            "}",
            "int force_sig_bnderr(void __user *addr, void __user *lower, void __user *upper)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSEGV;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = SEGV_BNDERR;",
            "\tinfo.si_addr  = addr;",
            "\tinfo.si_lower = lower;",
            "\tinfo.si_upper = upper;",
            "\treturn force_sig_info(&info);",
            "}",
            "int force_sig_pkuerr(void __user *addr, u32 pkey)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSEGV;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = SEGV_PKUERR;",
            "\tinfo.si_addr  = addr;",
            "\tinfo.si_pkey  = pkey;",
            "\treturn force_sig_info(&info);",
            "}",
            "int send_sig_perf(void __user *addr, u32 type, u64 sig_data)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo     = SIGTRAP;",
            "\tinfo.si_errno     = 0;",
            "\tinfo.si_code      = TRAP_PERF;",
            "\tinfo.si_addr      = addr;",
            "\tinfo.si_perf_data = sig_data;",
            "\tinfo.si_perf_type = type;",
            "",
            "\t/*",
            "\t * Signals generated by perf events should not terminate the whole",
            "\t * process if SIGTRAP is blocked, however, delivering the signal",
            "\t * asynchronously is better than not delivering at all. But tell user",
            "\t * space if the signal was asynchronous, so it can clearly be",
            "\t * distinguished from normal synchronous ones.",
            "\t */",
            "\tinfo.si_perf_flags = sigismember(&current->blocked, info.si_signo) ?",
            "\t\t\t\t     TRAP_PERF_FLAG_ASYNC :",
            "\t\t\t\t     0;",
            "",
            "\treturn send_sig_info(info.si_signo, &info, current);",
            "}",
            "int force_sig_seccomp(int syscall, int reason, bool force_coredump)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSYS;",
            "\tinfo.si_code = SYS_SECCOMP;",
            "\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);",
            "\tinfo.si_errno = reason;",
            "\tinfo.si_arch = syscall_get_arch(current);",
            "\tinfo.si_syscall = syscall;",
            "\treturn force_sig_info_to_task(&info, current,",
            "\t\tforce_coredump ? HANDLER_EXIT : HANDLER_CURRENT);",
            "}",
            "int force_sig_ptrace_errno_trap(int errno, void __user *addr)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGTRAP;",
            "\tinfo.si_errno = errno;",
            "\tinfo.si_code  = TRAP_HWBKPT;",
            "\tinfo.si_addr  = addr;",
            "\treturn force_sig_info(&info);",
            "}",
            "int force_sig_fault_trapno(int sig, int code, void __user *addr, int trapno)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = code;",
            "\tinfo.si_addr  = addr;",
            "\tinfo.si_trapno = trapno;",
            "\treturn force_sig_info(&info);",
            "}",
            "int send_sig_fault_trapno(int sig, int code, void __user *addr, int trapno,",
            "\t\t\t  struct task_struct *t)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = code;",
            "\tinfo.si_addr  = addr;",
            "\tinfo.si_trapno = trapno;",
            "\treturn send_sig_info(info.si_signo, &info, t);",
            "}"
          ],
          "function_name": "send_sig_mceerr, force_sig_bnderr, force_sig_pkuerr, send_sig_perf, force_sig_seccomp, force_sig_ptrace_errno_trap, force_sig_fault_trapno, send_sig_fault_trapno",
          "description": "专门处理架构相关的信号错误场景，如内存绑定错误(SEGV_BNDERR)、PKU保护错误(SEGV_PKUERR)、性能监控陷阱(TRAP_PERF)等，通过构造特定信号信息调用通用发送接口。包含处理seccomp过滤器、ptrace跟踪等特殊情况的信号生成逻辑。",
          "similarity": 0.5521230697631836
        },
        {
          "chunk_id": 24,
          "file_path": "kernel/signal.c",
          "start_line": 3998,
          "end_line": 4145,
          "content": [
            "static int",
            "do_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)",
            "{",
            "\tstruct task_struct *p;",
            "\tint error = -ESRCH;",
            "",
            "\trcu_read_lock();",
            "\tp = find_task_by_vpid(pid);",
            "\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {",
            "\t\terror = check_kill_permission(sig, info, p);",
            "\t\t/*",
            "\t\t * The null signal is a permissions and process existence",
            "\t\t * probe.  No signal is actually delivered.",
            "\t\t */",
            "\t\tif (!error && sig) {",
            "\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);",
            "\t\t\t/*",
            "\t\t\t * If lock_task_sighand() failed we pretend the task",
            "\t\t\t * dies after receiving the signal. The window is tiny,",
            "\t\t\t * and the signal is private anyway.",
            "\t\t\t */",
            "\t\t\tif (unlikely(error == -ESRCH))",
            "\t\t\t\terror = 0;",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn error;",
            "}",
            "static int do_tkill(pid_t tgid, pid_t pid, int sig)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tprepare_kill_siginfo(sig, &info, PIDTYPE_PID);",
            "",
            "\treturn do_send_specific(tgid, pid, sig, &info);",
            "}",
            "static int do_rt_sigqueueinfo(pid_t pid, int sig, kernel_siginfo_t *info)",
            "{",
            "\t/* Not even root can pretend to send signals from the kernel.",
            "\t * Nor can they impersonate a kill()/tgkill(), which adds source info.",
            "\t */",
            "\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&",
            "\t    (task_pid_vnr(current) != pid))",
            "\t\treturn -EPERM;",
            "",
            "\t/* POSIX.1b doesn't mention process groups.  */",
            "\treturn kill_proc_info(sig, info, pid);",
            "}",
            "static int do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, kernel_siginfo_t *info)",
            "{",
            "\t/* This is only valid for single tasks */",
            "\tif (pid <= 0 || tgid <= 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Not even root can pretend to send signals from the kernel.",
            "\t * Nor can they impersonate a kill()/tgkill(), which adds source info.",
            "\t */",
            "\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&",
            "\t    (task_pid_vnr(current) != pid))",
            "\t\treturn -EPERM;",
            "",
            "\treturn do_send_specific(tgid, pid, sig, info);",
            "}",
            "void kernel_sigaction(int sig, __sighandler_t action)",
            "{",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;",
            "\tif (action == SIG_IGN) {",
            "\t\tsigset_t mask;",
            "",
            "\t\tsigemptyset(&mask);",
            "\t\tsigaddset(&mask, sig);",
            "",
            "\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);",
            "\t\tflush_sigqueue_mask(&mask, &current->pending);",
            "\t\trecalc_sigpending();",
            "\t}",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "}",
            "void __weak sigaction_compat_abi(struct k_sigaction *act,",
            "\t\tstruct k_sigaction *oact)",
            "{",
            "}",
            "int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)",
            "{",
            "\tstruct task_struct *p = current, *t;",
            "\tstruct k_sigaction *k;",
            "\tsigset_t mask;",
            "",
            "\tif (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))",
            "\t\treturn -EINVAL;",
            "",
            "\tk = &p->sighand->action[sig-1];",
            "",
            "\tspin_lock_irq(&p->sighand->siglock);",
            "\tif (k->sa.sa_flags & SA_IMMUTABLE) {",
            "\t\tspin_unlock_irq(&p->sighand->siglock);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\tif (oact)",
            "\t\t*oact = *k;",
            "",
            "\t/*",
            "\t * Make sure that we never accidentally claim to support SA_UNSUPPORTED,",
            "\t * e.g. by having an architecture use the bit in their uapi.",
            "\t */",
            "\tBUILD_BUG_ON(UAPI_SA_FLAGS & SA_UNSUPPORTED);",
            "",
            "\t/*",
            "\t * Clear unknown flag bits in order to allow userspace to detect missing",
            "\t * support for flag bits and to allow the kernel to use non-uapi bits",
            "\t * internally.",
            "\t */",
            "\tif (act)",
            "\t\tact->sa.sa_flags &= UAPI_SA_FLAGS;",
            "\tif (oact)",
            "\t\toact->sa.sa_flags &= UAPI_SA_FLAGS;",
            "",
            "\tsigaction_compat_abi(act, oact);",
            "",
            "\tif (act) {",
            "\t\tsigdelsetmask(&act->sa.sa_mask,",
            "\t\t\t      sigmask(SIGKILL) | sigmask(SIGSTOP));",
            "\t\t*k = *act;",
            "\t\t/*",
            "\t\t * POSIX 3.3.1.3:",
            "\t\t *  \"Setting a signal action to SIG_IGN for a signal that is",
            "\t\t *   pending shall cause the pending signal to be discarded,",
            "\t\t *   whether or not it is blocked.\"",
            "\t\t *",
            "\t\t *  \"Setting a signal action to SIG_DFL for a signal that is",
            "\t\t *   pending and whose default action is to ignore the signal",
            "\t\t *   (for example, SIGCHLD), shall cause the pending signal to",
            "\t\t *   be discarded, whether or not it is blocked\"",
            "\t\t */",
            "\t\tif (sig_handler_ignored(sig_handler(p, sig), sig)) {",
            "\t\t\tsigemptyset(&mask);",
            "\t\t\tsigaddset(&mask, sig);",
            "\t\t\tflush_sigqueue_mask(&mask, &p->signal->shared_pending);",
            "\t\t\tfor_each_thread(p, t)",
            "\t\t\t\tflush_sigqueue_mask(&mask, &t->pending);",
            "\t\t}",
            "\t}",
            "",
            "\tspin_unlock_irq(&p->sighand->siglock);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "do_send_specific, do_tkill, do_rt_sigqueueinfo, do_rt_tgsigqueueinfo, kernel_sigaction, sigaction_compat_abi, do_sigaction",
          "description": "处理信号动作设置与定向信号发送，包含信号处理函数注册、信号屏蔽更新及跨进程信号注入等关键控制流程。",
          "similarity": 0.548148512840271
        },
        {
          "chunk_id": 19,
          "file_path": "kernel/signal.c",
          "start_line": 2961,
          "end_line": 3063,
          "content": [
            "static void signal_delivered(struct ksignal *ksig, int stepping)",
            "{",
            "\tsigset_t blocked;",
            "",
            "\t/* A signal was successfully delivered, and the",
            "\t   saved sigmask was stored on the signal frame,",
            "\t   and will be restored by sigreturn.  So we can",
            "\t   simply clear the restore sigmask flag.  */",
            "\tclear_restore_sigmask();",
            "",
            "\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);",
            "\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))",
            "\t\tsigaddset(&blocked, ksig->sig);",
            "\tset_current_blocked(&blocked);",
            "\tif (current->sas_ss_flags & SS_AUTODISARM)",
            "\t\tsas_ss_reset(current);",
            "\tif (stepping)",
            "\t\tptrace_notify(SIGTRAP, 0);",
            "}",
            "void signal_setup_done(int failed, struct ksignal *ksig, int stepping)",
            "{",
            "\tif (failed)",
            "\t\tforce_sigsegv(ksig->sig);",
            "\telse",
            "\t\tsignal_delivered(ksig, stepping);",
            "}",
            "static void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)",
            "{",
            "\tsigset_t retarget;",
            "\tstruct task_struct *t;",
            "",
            "\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);",
            "\tif (sigisemptyset(&retarget))",
            "\t\treturn;",
            "",
            "\tt = tsk;",
            "\twhile_each_thread(tsk, t) {",
            "\t\tif (t->flags & PF_EXITING)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (!has_pending_signals(&retarget, &t->blocked))",
            "\t\t\tcontinue;",
            "\t\t/* Remove the signals this thread can handle. */",
            "\t\tsigandsets(&retarget, &retarget, &t->blocked);",
            "",
            "\t\tif (!task_sigpending(t))",
            "\t\t\tsignal_wake_up(t, 0);",
            "",
            "\t\tif (sigisemptyset(&retarget))",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "void exit_signals(struct task_struct *tsk)",
            "{",
            "\tint group_stop = 0;",
            "\tsigset_t unblocked;",
            "",
            "\t/*",
            "\t * @tsk is about to have PF_EXITING set - lock out users which",
            "\t * expect stable threadgroup.",
            "\t */",
            "\tcgroup_threadgroup_change_begin(tsk);",
            "",
            "\tif (thread_group_empty(tsk) || (tsk->signal->flags & SIGNAL_GROUP_EXIT)) {",
            "\t\tsched_mm_cid_exit_signals(tsk);",
            "\t\ttsk->flags |= PF_EXITING;",
            "\t\tcgroup_threadgroup_change_end(tsk);",
            "\t\treturn;",
            "\t}",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t/*",
            "\t * From now this task is not visible for group-wide signals,",
            "\t * see wants_signal(), do_signal_stop().",
            "\t */",
            "\tsched_mm_cid_exit_signals(tsk);",
            "\ttsk->flags |= PF_EXITING;",
            "",
            "\tcgroup_threadgroup_change_end(tsk);",
            "",
            "\tif (!task_sigpending(tsk))",
            "\t\tgoto out;",
            "",
            "\tunblocked = tsk->blocked;",
            "\tsignotset(&unblocked);",
            "\tretarget_shared_pending(tsk, &unblocked);",
            "",
            "\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&",
            "\t    task_participate_group_stop(tsk))",
            "\t\tgroup_stop = CLD_STOPPED;",
            "out:",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\t/*",
            "\t * If group stop has completed, deliver the notification.  This",
            "\t * should always go to the real parent of the group leader.",
            "\t */",
            "\tif (unlikely(group_stop)) {",
            "\t\tread_lock(&tasklist_lock);",
            "\t\tdo_notify_parent_cldstop(tsk, false, group_stop);",
            "\t\tread_unlock(&tasklist_lock);",
            "\t}",
            "}"
          ],
          "function_name": "signal_delivered, signal_setup_done, retarget_shared_pending, exit_signals",
          "description": "signal_delivered 完成信号送达后的阻塞集更新；signal_setup_done 根据信号处理结果设置异常；retarget_shared_pending 重新分配共享挂起信号；exit_signals 处理进程退出时的信号清理和组停止通知",
          "similarity": 0.533263623714447
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_events_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:18:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_events_filter.c`\n\n---\n\n# trace_events_filter.c 技术文档\n\n## 1. 文件概述\n\n`trace_events_filter.c` 是 Linux 内核中用于实现通用事件过滤（event filtering）功能的核心文件。它为 ftrace 事件跟踪系统提供了一套灵活的表达式解析和执行机制，允许用户通过逻辑表达式（支持 `&&`、`||`、`!` 等操作符）对跟踪事件进行动态过滤。该模块支持对事件字段进行数值比较、字符串匹配、位运算以及 CPU 掩码过滤等多种操作，广泛应用于性能分析、调试和系统监控场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct filter_pred`**  \n  表示一个过滤谓词（predicate），包含：\n  - 字段指针（`field`）\n  - 比较值（`val`, `val2`）\n  - 操作符（`op`，如 `==`, `<`, `&` 等）\n  - 谓词执行函数类型（`fn_num`）\n  - 正则表达式（`regex`）或 CPU 掩码（`mask`）\n  - 取反标志（`not`）\n\n- **`struct prog_entry`**  \n  表示过滤程序中的一个指令条目，用于构建基于跳转的执行逻辑：\n  - `pred`：关联的谓词\n  - `when_to_branch`：分支条件（0 或 1）\n  - `target`：跳转目标索引\n\n- **`struct filter_parse_error`**  \n  用于记录表达式解析过程中的错误类型和位置。\n\n- **`enum filter_op_ids` 和 `enum filter_pred_fn`**  \n  定义支持的操作符（如 `OP_EQ`, `OP_GT`）和谓词执行函数类型（如 `FILTER_PRED_FN_U64`, `FILTER_PRED_FN_STRING`）。\n\n- **错误码枚举（`FILT_ERR_*`）**  \n  定义了 20 余种解析和语义错误，如 `FIELD_NOT_FOUND`、`INVALID_OP`、`MISSING_QUOTE` 等。\n\n### 关键函数/逻辑\n\n- **`is_not()`**  \n  判断 `!` 是否表示逻辑取反（排除 `!=` 和 `!~` 的情况）。\n\n- **`update_preds()`**  \n  在构建过滤程序时动态更新跳转目标，用于处理 `&&` 和 `||` 的优先级和短路求值。\n\n- **`free_predicate()`**  \n  释放谓词结构及其关联资源（正则、CPU 掩码等）。\n\n- **表达式解析器框架**  \n  支持回调函数 `parse_pred_fn`，允许不同事件类型自定义谓词解析逻辑。\n\n## 3. 关键实现\n\n### 表达式解析与程序生成\n\n该文件实现了一个两阶段的逻辑表达式处理机制：\n\n1. **词法与语法解析**：将用户输入的字符串（如 `\"pid > 100 && comm == 'bash'\"`）解析为操作符、字段名和值的序列。\n2. **程序生成**：将逻辑表达式转换为线性“程序”（`prog_entry` 数组），通过条件跳转模拟 `&&`（短路与）和 `||`（短路或）的语义。\n\n例如，表达式 `a && !b || c` 被编译为类似以下的跳转逻辑：\n```text\neval a; if false goto L2\neval b; if true  goto L2\nreturn true\nL2: eval c; if false goto FAIL\nreturn true\nFAIL: return false\n```\n\n### 操作符优先级处理\n\n通过宏 `OPS` 定义操作符顺序，特别要求 `<=` 在 `<` 之前、`>=` 在 `>` 之前，以确保词法分析时长操作符优先匹配。\n\n### 取反逻辑（`!`）处理\n\n使用栈和 `invert` 标志跟踪当前作用域内的取反层数。每遇到一个 `!` 就翻转 `invert`，括号会将当前 `invert` 值压栈，确保作用域隔离。\n\n### 多类型谓词支持\n\n通过 `filter_pred_fn` 枚举区分不同数据类型的比较函数（如 8/16/32/64 位有无符号整数、字符串、CPU 掩码、函数指针等），实现类型安全的字段比较。\n\n### 错误报告机制\n\n提供详细的错误码和位置信息（`filter_parse_error`），便于用户调试无效过滤表达式。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `trace.h` / `trace_output.h`：ftrace 核心接口和事件定义\n  - `linux/slab.h`：内存分配（`kmalloc`/`kfree`）\n  - `linux/ctype.h`：字符处理\n  - `linux/perf_event.h`：与 perf 事件子系统集成\n  - `linux/uaccess.h`：用户空间数据访问\n\n- **模块依赖**：\n  - 依赖 ftrace 事件注册机制（`ftrace_event_field`）\n  - 与 `trace_events.c` 协同工作，提供过滤能力\n  - 被 perf 和 ftrace 用户接口（如 `/sys/kernel/debug/tracing/events/.../filter`）调用\n\n## 5. 使用场景\n\n- **动态事件过滤**：用户通过写入 `/sys/kernel/debug/tracing/events/<subsys>/<event>/filter` 设置过滤条件，仅记录满足条件的事件。\n- **全局过滤**：通过 `set_event_filter` 设置跨多个事件的统一过滤规则。\n- **性能分析**：在高负载系统中减少无关事件的记录开销，提升跟踪效率。\n- **调试特定行为**：例如 `filter='pid == 1234'` 仅跟踪指定进程的事件，或 `filter='latency > 1000'` 捕获高延迟操作。\n- **安全与审计**：结合字段值过滤实现细粒度的系统行为监控。",
      "similarity": 0.5724819302558899,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 862,
          "end_line": 968,
          "content": [
            "static int filter_pred_pchar(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_string(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_pchar_user(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_ustring(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_strloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 str_item = *(u32 *)(event + pred->offset);",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(event + str_loc);",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_strrelloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 *item = (u32 *)(event + pred->offset);",
            "\tu32 str_item = *item;",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(&item[1]) + str_loc;",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu, cmp;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\tcmp = pred->val;",
            "",
            "\tswitch (pred->op) {",
            "\tcase OP_EQ:",
            "\t\treturn cpu == cmp;",
            "\tcase OP_NE:",
            "\t\treturn cpu != cmp;",
            "\tcase OP_LT:",
            "\t\treturn cpu < cmp;",
            "\tcase OP_LE:",
            "\t\treturn cpu <= cmp;",
            "\tcase OP_GT:",
            "\t\treturn cpu > cmp;",
            "\tcase OP_GE:",
            "\t\treturn cpu >= cmp;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static int filter_pred_cpu_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu = raw_smp_processor_id();",
            "",
            "\treturn do_filter_scalar_cpumask(pred->op, cpu, pred->mask);",
            "}",
            "static int filter_pred_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tconst struct cpumask *cmp = pred->mask;",
            "",
            "\treturn do_filter_cpumask(pred->op, mask, cmp);",
            "}",
            "static int filter_pred_cpumask_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tunsigned int cpu = pred->val;",
            "",
            "\treturn do_filter_cpumask_scalar(pred->op, mask, cpu);",
            "}",
            "static int filter_pred_comm(struct filter_pred *pred, void *event)",
            "{",
            "\tint cmp;",
            "",
            "\tcmp = pred->regex->match(current->comm, pred->regex,",
            "\t\t\t\tTASK_COMM_LEN);",
            "\treturn cmp ^ pred->not;",
            "}"
          ],
          "function_name": "filter_pred_pchar, filter_pred_pchar_user, filter_pred_strloc, filter_pred_strrelloc, filter_pred_cpu, filter_pred_cpu_cpumask, filter_pred_cpumask, filter_pred_cpumask_cpu, filter_pred_comm",
          "description": "提供针对字符串、位置、进程名等特殊数据类型的过滤实现，处理指针解引用和内存地址匹配。",
          "similarity": 0.5726919770240784
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 1161,
          "end_line": 1262,
          "content": [
            "static int test_pred_visited_fn(struct filter_pred *pred, void *event)",
            "{",
            "\treturn 0;",
            "}",
            "int filter_match_preds(struct event_filter *filter, void *rec)",
            "{",
            "\tstruct prog_entry *prog;",
            "\tint i;",
            "",
            "\t/* no filter is considered a match */",
            "\tif (!filter)",
            "\t\treturn 1;",
            "",
            "\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */",
            "\tprog = rcu_dereference_raw(filter->prog);",
            "\tif (!prog)",
            "\t\treturn 1;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "\t\tint match = filter_pred_fn_call(pred, rec);",
            "\t\tif (match == prog[i].when_to_branch)",
            "\t\t\ti = prog[i].target;",
            "\t}",
            "\treturn prog[i].target;",
            "}",
            "static void remove_filter_string(struct event_filter *filter)",
            "{",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tkfree(filter->filter_string);",
            "\tfilter->filter_string = NULL;",
            "}",
            "static void append_filter_err(struct trace_array *tr,",
            "\t\t\t      struct filter_parse_error *pe,",
            "\t\t\t      struct event_filter *filter)",
            "{",
            "\tstruct trace_seq *s;",
            "\tint pos = pe->lasterr_pos;",
            "\tchar *buf;",
            "\tint len;",
            "",
            "\tif (WARN_ON(!filter->filter_string))",
            "\t\treturn;",
            "",
            "\ts = kmalloc(sizeof(*s), GFP_KERNEL);",
            "\tif (!s)",
            "\t\treturn;",
            "\ttrace_seq_init(s);",
            "",
            "\tlen = strlen(filter->filter_string);",
            "\tif (pos > len)",
            "\t\tpos = len;",
            "",
            "\t/* indexing is off by one */",
            "\tif (pos)",
            "\t\tpos++;",
            "",
            "\ttrace_seq_puts(s, filter->filter_string);",
            "\tif (pe->lasterr > 0) {",
            "\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");",
            "\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);",
            "\t\ttracing_log_err(tr, \"event filter parse error\",",
            "\t\t\t\tfilter->filter_string, err_text,",
            "\t\t\t\tpe->lasterr, pe->lasterr_pos);",
            "\t} else {",
            "\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);",
            "\t\ttracing_log_err(tr, \"event filter parse error\",",
            "\t\t\t\tfilter->filter_string, err_text,",
            "\t\t\t\tFILT_ERR_ERRNO, 0);",
            "\t}",
            "\ttrace_seq_putc(s, 0);",
            "\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);",
            "\tif (buf) {",
            "\t\tkfree(filter->filter_string);",
            "\t\tfilter->filter_string = buf;",
            "\t}",
            "\tkfree(s);",
            "}",
            "void print_event_filter(struct trace_event_file *file, struct trace_seq *s)",
            "{",
            "\tstruct event_filter *filter = event_filter(file);",
            "",
            "\tif (filter && filter->filter_string)",
            "\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);",
            "\telse",
            "\t\ttrace_seq_puts(s, \"none\\n\");",
            "}",
            "void print_subsystem_event_filter(struct event_subsystem *system,",
            "\t\t\t\t  struct trace_seq *s)",
            "{",
            "\tstruct event_filter *filter;",
            "",
            "\tmutex_lock(&event_mutex);",
            "\tfilter = system->filter;",
            "\tif (filter && filter->filter_string)",
            "\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);",
            "\telse",
            "\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");",
            "\tmutex_unlock(&event_mutex);",
            "}"
          ],
          "function_name": "test_pred_visited_fn, filter_match_preds, remove_filter_string, append_filter_err, print_event_filter, print_subsystem_event_filter",
          "description": "实现过滤器状态管理、错误附加、谓词匹配执行以及过滤器信息打印等功能的核心控制流程。",
          "similarity": 0.5314511656761169
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 1978,
          "end_line": 2110,
          "content": [
            "static int calc_stack(const char *str, int *parens, int *preds, int *err)",
            "{",
            "\tbool is_pred = false;",
            "\tint nr_preds = 0;",
            "\tint open = 1; /* Count the expression as \"(E)\" */",
            "\tint last_quote = 0;",
            "\tint max_open = 1;",
            "\tint quote = 0;",
            "\tint i;",
            "",
            "\t*err = 0;",
            "",
            "\tfor (i = 0; str[i]; i++) {",
            "\t\tif (isspace(str[i]))",
            "\t\t\tcontinue;",
            "\t\tif (quote) {",
            "\t\t\tif (str[i] == quote)",
            "\t\t\t       quote = 0;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tswitch (str[i]) {",
            "\t\tcase '\\'':",
            "\t\tcase '\"':",
            "\t\t\tquote = str[i];",
            "\t\t\tlast_quote = i;",
            "\t\t\tbreak;",
            "\t\tcase '|':",
            "\t\tcase '&':",
            "\t\t\tif (str[i+1] != str[i])",
            "\t\t\t\tbreak;",
            "\t\t\tis_pred = false;",
            "\t\t\tcontinue;",
            "\t\tcase '(':",
            "\t\t\tis_pred = false;",
            "\t\t\topen++;",
            "\t\t\tif (open > max_open)",
            "\t\t\t\tmax_open = open;",
            "\t\t\tcontinue;",
            "\t\tcase ')':",
            "\t\t\tis_pred = false;",
            "\t\t\tif (open == 1) {",
            "\t\t\t\t*err = i;",
            "\t\t\t\treturn TOO_MANY_CLOSE;",
            "\t\t\t}",
            "\t\t\topen--;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (!is_pred) {",
            "\t\t\tnr_preds++;",
            "\t\t\tis_pred = true;",
            "\t\t}",
            "\t}",
            "",
            "\tif (quote) {",
            "\t\t*err = last_quote;",
            "\t\treturn MISSING_QUOTE;",
            "\t}",
            "",
            "\tif (open != 1) {",
            "\t\tint level = open;",
            "",
            "\t\t/* find the bad open */",
            "\t\tfor (i--; i; i--) {",
            "\t\t\tif (quote) {",
            "\t\t\t\tif (str[i] == quote)",
            "\t\t\t\t\tquote = 0;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tswitch (str[i]) {",
            "\t\t\tcase '(':",
            "\t\t\t\tif (level == open) {",
            "\t\t\t\t\t*err = i;",
            "\t\t\t\t\treturn TOO_MANY_OPEN;",
            "\t\t\t\t}",
            "\t\t\t\tlevel--;",
            "\t\t\t\tbreak;",
            "\t\t\tcase ')':",
            "\t\t\t\tlevel++;",
            "\t\t\t\tbreak;",
            "\t\t\tcase '\\'':",
            "\t\t\tcase '\"':",
            "\t\t\t\tquote = str[i];",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\t/* First character is the '(' with missing ')' */",
            "\t\t*err = 0;",
            "\t\treturn TOO_MANY_OPEN;",
            "\t}",
            "",
            "\t/* Set the size of the required stacks */",
            "\t*parens = max_open;",
            "\t*preds = nr_preds;",
            "\treturn 0;",
            "}",
            "static int process_preds(struct trace_event_call *call,",
            "\t\t\t const char *filter_string,",
            "\t\t\t struct event_filter *filter,",
            "\t\t\t struct filter_parse_error *pe)",
            "{",
            "\tstruct prog_entry *prog;",
            "\tint nr_parens;",
            "\tint nr_preds;",
            "\tint index;",
            "\tint ret;",
            "",
            "\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);",
            "\tif (ret < 0) {",
            "\t\tswitch (ret) {",
            "\t\tcase MISSING_QUOTE:",
            "\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);",
            "\t\t\tbreak;",
            "\t\tcase TOO_MANY_OPEN:",
            "\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tif (!nr_preds)",
            "\t\treturn -EINVAL;",
            "",
            "\tprog = predicate_parse(filter_string, nr_parens, nr_preds,",
            "\t\t\t       parse_pred, call, pe);",
            "\tif (IS_ERR(prog))",
            "\t\treturn PTR_ERR(prog);",
            "",
            "\trcu_assign_pointer(filter->prog, prog);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "calc_stack, process_preds",
          "description": "实现过滤器语法校验和谓词链表生成，通过分析括号嵌套层级和谓词数量验证过滤表达式合法性，并将解析结果转化为谓词链表存储到事件过滤器",
          "similarity": 0.518794596195221
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 1281,
          "end_line": 1422,
          "content": [
            "static void free_prog(struct event_filter *filter)",
            "{",
            "\tstruct prog_entry *prog;",
            "\tint i;",
            "",
            "\tprog = rcu_access_pointer(filter->prog);",
            "\tif (!prog)",
            "\t\treturn;",
            "",
            "\tfor (i = 0; prog[i].pred; i++)",
            "\t\tfree_predicate(prog[i].pred);",
            "\tkfree(prog);",
            "}",
            "static void filter_disable(struct trace_event_file *file)",
            "{",
            "\tunsigned long old_flags = file->flags;",
            "",
            "\tfile->flags &= ~EVENT_FILE_FL_FILTERED;",
            "",
            "\tif (old_flags != file->flags)",
            "\t\ttrace_buffered_event_disable();",
            "}",
            "static void __free_filter(struct event_filter *filter)",
            "{",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tfree_prog(filter);",
            "\tkfree(filter->filter_string);",
            "\tkfree(filter);",
            "}",
            "void free_event_filter(struct event_filter *filter)",
            "{",
            "\t__free_filter(filter);",
            "}",
            "static inline void __remove_filter(struct trace_event_file *file)",
            "{",
            "\tfilter_disable(file);",
            "\tremove_filter_string(file->filter);",
            "}",
            "static void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,",
            "\t\t\t\t\tstruct trace_array *tr)",
            "{",
            "\tstruct trace_event_file *file;",
            "",
            "\tlist_for_each_entry(file, &tr->events, list) {",
            "\t\tif (file->system != dir)",
            "\t\t\tcontinue;",
            "\t\t__remove_filter(file);",
            "\t}",
            "}",
            "static inline void __free_subsystem_filter(struct trace_event_file *file)",
            "{",
            "\t__free_filter(file->filter);",
            "\tfile->filter = NULL;",
            "}",
            "static void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,",
            "\t\t\t\t\t  struct trace_array *tr)",
            "{",
            "\tstruct trace_event_file *file;",
            "",
            "\tlist_for_each_entry(file, &tr->events, list) {",
            "\t\tif (file->system != dir)",
            "\t\t\tcontinue;",
            "\t\t__free_subsystem_filter(file);",
            "\t}",
            "}",
            "int filter_assign_type(const char *type)",
            "{",
            "\tif (strstr(type, \"__data_loc\")) {",
            "\t\tif (strstr(type, \"char\"))",
            "\t\t\treturn FILTER_DYN_STRING;",
            "\t\tif (strstr(type, \"cpumask_t\"))",
            "\t\t\treturn FILTER_CPUMASK;",
            "\t}",
            "",
            "\tif (strstr(type, \"__rel_loc\") && strstr(type, \"char\"))",
            "\t\treturn FILTER_RDYN_STRING;",
            "",
            "\tif (strchr(type, '[') && strstr(type, \"char\"))",
            "\t\treturn FILTER_STATIC_STRING;",
            "",
            "\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)",
            "\t\treturn FILTER_PTR_STRING;",
            "",
            "\treturn FILTER_OTHER;",
            "}",
            "static enum filter_pred_fn select_comparison_fn(enum filter_op_ids op,",
            "\t\t\t\t\t\tint field_size, int field_is_signed)",
            "{",
            "\tenum filter_pred_fn fn = FILTER_PRED_FN_NOP;",
            "\tint pred_func_index = -1;",
            "",
            "\tswitch (op) {",
            "\tcase OP_EQ:",
            "\tcase OP_NE:",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))",
            "\t\t\treturn fn;",
            "\t\tpred_func_index = op - PRED_FUNC_START;",
            "\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))",
            "\t\t\treturn fn;",
            "\t}",
            "",
            "\tswitch (field_size) {",
            "\tcase 8:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_64;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S64;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U64;",
            "\t\tbreak;",
            "\tcase 4:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_32;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S32;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U32;",
            "\t\tbreak;",
            "\tcase 2:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_16;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S16;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U16;",
            "\t\tbreak;",
            "\tcase 1:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_8;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S8;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U8;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn fn;",
            "}"
          ],
          "function_name": "free_prog, filter_disable, __free_filter, free_event_filter, __remove_filter, filter_free_subsystem_preds, __free_subsystem_filter, filter_free_subsystem_filters, filter_assign_type, select_comparison_fn",
          "description": "实现事件过滤器资源释放逻辑，包括释放predicate、过滤字符串和过滤器结构体，处理子系统过滤器的遍历和销毁，定义字段类型判断函数及比较函数选择逻辑",
          "similarity": 0.516754150390625
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2113,
          "end_line": 2216,
          "content": [
            "static inline void event_set_filtered_flag(struct trace_event_file *file)",
            "{",
            "\tunsigned long old_flags = file->flags;",
            "",
            "\tfile->flags |= EVENT_FILE_FL_FILTERED;",
            "",
            "\tif (old_flags != file->flags)",
            "\t\ttrace_buffered_event_enable();",
            "}",
            "static inline void event_set_filter(struct trace_event_file *file,",
            "\t\t\t\t    struct event_filter *filter)",
            "{",
            "\trcu_assign_pointer(file->filter, filter);",
            "}",
            "static inline void event_clear_filter(struct trace_event_file *file)",
            "{",
            "\tRCU_INIT_POINTER(file->filter, NULL);",
            "}",
            "static int process_system_preds(struct trace_subsystem_dir *dir,",
            "\t\t\t\tstruct trace_array *tr,",
            "\t\t\t\tstruct filter_parse_error *pe,",
            "\t\t\t\tchar *filter_string)",
            "{",
            "\tstruct trace_event_file *file;",
            "\tstruct filter_list *filter_item;",
            "\tstruct event_filter *filter = NULL;",
            "\tstruct filter_list *tmp;",
            "\tLIST_HEAD(filter_list);",
            "\tbool fail = true;",
            "\tint err;",
            "",
            "\tlist_for_each_entry(file, &tr->events, list) {",
            "",
            "\t\tif (file->system != dir)",
            "\t\t\tcontinue;",
            "",
            "\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);",
            "\t\tif (!filter)",
            "\t\t\tgoto fail_mem;",
            "",
            "\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);",
            "\t\tif (!filter->filter_string)",
            "\t\t\tgoto fail_mem;",
            "",
            "\t\terr = process_preds(file->event_call, filter_string, filter, pe);",
            "\t\tif (err) {",
            "\t\t\tfilter_disable(file);",
            "\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);",
            "\t\t\tappend_filter_err(tr, pe, filter);",
            "\t\t} else",
            "\t\t\tevent_set_filtered_flag(file);",
            "",
            "",
            "\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);",
            "\t\tif (!filter_item)",
            "\t\t\tgoto fail_mem;",
            "",
            "\t\tlist_add_tail(&filter_item->list, &filter_list);",
            "\t\t/*",
            "\t\t * Regardless of if this returned an error, we still",
            "\t\t * replace the filter for the call.",
            "\t\t */",
            "\t\tfilter_item->filter = event_filter(file);",
            "\t\tevent_set_filter(file, filter);",
            "\t\tfilter = NULL;",
            "",
            "\t\tfail = false;",
            "\t}",
            "",
            "\tif (fail)",
            "\t\tgoto fail;",
            "",
            "\t/*",
            "\t * The calls can still be using the old filters.",
            "\t * Do a synchronize_rcu() and to ensure all calls are",
            "\t * done with them before we free them.",
            "\t */",
            "\ttracepoint_synchronize_unregister();",
            "\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {",
            "\t\t__free_filter(filter_item->filter);",
            "\t\tlist_del(&filter_item->list);",
            "\t\tkfree(filter_item);",
            "\t}",
            "\treturn 0;",
            " fail:",
            "\t/* No call succeeded */",
            "\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {",
            "\t\tlist_del(&filter_item->list);",
            "\t\tkfree(filter_item);",
            "\t}",
            "\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);",
            "\treturn -EINVAL;",
            " fail_mem:",
            "\t__free_filter(filter);",
            "\t/* If any call succeeded, we still need to sync */",
            "\tif (!fail)",
            "\t\ttracepoint_synchronize_unregister();",
            "\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {",
            "\t\t__free_filter(filter_item->filter);",
            "\t\tlist_del(&filter_item->list);",
            "\t\tkfree(filter_item);",
            "\t}",
            "\treturn -ENOMEM;",
            "}"
          ],
          "function_name": "event_set_filtered_flag, event_set_filter, event_clear_filter, process_system_preds",
          "description": "实现事件过滤状态控制接口，提供过滤器启用/禁用标记设置、过滤器引用更新等功能，处理子系统级过滤器的批量创建和错误传播机制",
          "similarity": 0.5146388411521912
        }
      ]
    },
    {
      "source_file": "kernel/bpf/task_iter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:33:05\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\task_iter.c`\n\n---\n\n# `bpf/task_iter.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/task_iter.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统的一部分，实现了基于 BPF 的任务（task）迭代器（iterator）。该文件提供了两种 BPF 迭代器：\n\n- **`task` 迭代器**：用于遍历内核中的 `task_struct`（即进程/线程）对象。\n- **`task_file` 迭代器**：用于遍历指定任务（或所有任务）打开的文件描述符及其对应的 `file` 对象。\n\n这些迭代器允许 BPF 程序以安全、高效的方式遍历内核中的任务和文件资源，常用于系统监控、安全审计和性能分析等场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct bpf_iter_seq_task_common`  \n  任务迭代器的通用上下文，包含 PID 命名空间、迭代类型（ALL/TID/PID）、目标 PID 和当前访问的 PID。\n\n- `struct bpf_iter_seq_task_info`  \n  用于 `task` 迭代器的私有数据，继承自 `bpf_iter_seq_task_common`，并记录当前线程 ID（TID）。\n\n- `struct bpf_iter_seq_task_file_info`  \n  用于 `task_file` 迭代器的私有数据，包含当前任务、TID 和当前文件描述符（fd）。\n\n- `struct bpf_iter__task` / `struct bpf_iter__task_file`  \n  BPF 程序的元数据上下文结构，分别用于向 BPF 程序传递 `task_struct` 或 `task_struct + file` 信息。\n\n### 主要函数\n\n- `task_seq_get_next()`  \n  根据迭代类型（ALL/TID/TGID）获取下一个有效的 `task_struct`。\n\n- `task_group_seq_get_next()`  \n  专门用于遍历指定线程组（TGID）内的所有线程。\n\n- `task_seq_start()` / `task_seq_next()` / `task_seq_stop()` / `task_seq_show()`  \n  实现标准 `seq_file` 接口，用于 `task` 迭代器的序列化遍历。\n\n- `task_file_seq_get_next()`  \n  遍历当前任务的文件描述符表，返回下一个有效的 `file` 对象。\n\n- `task_file_seq_start()` / `task_file_seq_next()`  \n  实现 `task_file` 迭代器的 `seq_file` 接口。\n\n- `bpf_iter_attach_task()`  \n  解析 BPF 迭代器链接时传入的参数（如 TID、PID 或 pidfd），初始化迭代器上下文。\n\n- `__task_seq_show()` / `DEFINE_BPF_ITER_FUNC(task, ...)`  \n  调用关联的 BPF 程序，并传入当前任务（或任务+文件）作为上下文。\n\n## 3. 关键实现\n\n### 迭代类型支持\n\n迭代器支持三种模式：\n- **`BPF_TASK_ITER_ALL`**：遍历命名空间中所有任务（按 PID 递增顺序）。\n- **`BPF_TASK_ITER_TID`**：仅遍历指定线程 ID（TID）对应的任务。\n- **`BPF_TASK_ITER_TGID`**：遍历指定线程组 ID（TGID，即主线程 PID）下的所有线程。\n\n### 安全遍历机制\n\n- 使用 `rcu_read_lock()` 保护对任务和 PID 哈希表的访问。\n- 通过 `get_pid_task()` 和 `put_task_struct()` 管理任务引用计数，防止遍历过程中任务被释放。\n- 在 `task_file` 迭代器中使用 `task_lookup_next_fdget_rcu()` 安全地遍历文件描述符表。\n\n### 文件去重逻辑\n\n在 `task_file` 迭代器中，若启用 `skip_if_dup_files`（实际在 `task_file_seq_get_next` 中硬编码为 `true`），会跳过与线程组 leader 共享 `files` 结构的非主线程，避免重复遍历同一组文件描述符。\n\n### PID 命名空间支持\n\n所有 PID 查找均通过 `find_pid_ns()` 和 `pid_nr_ns()` 在指定的 `pid_namespace` 中进行，确保容器环境下的正确性。\n\n### BPF 程序回调\n\n通过 `bpf_iter_run_prog()` 在每次 `show` 阶段调用用户态加载的 BPF 程序，传递当前任务（或任务+文件）作为上下文。`stop` 阶段也会调用一次 BPF 程序（`in_stop=true`），用于清理或最终处理。\n\n## 4. 依赖关系\n\n- **内核核心模块**：\n  - `<linux/pid_namespace.h>`：PID 命名空间管理。\n  - `<linux/sched.h>`（隐式）：`task_struct`、`next_thread()`、`thread_group_leader()` 等任务操作。\n  - `<linux/file.h>` / `<linux/fdtable.h>`：文件描述符表遍历。\n  - `<linux/bpf.h>` / `<linux/filter.h>`：BPF 核心框架和迭代器接口。\n  - `<linux/bpf_mem_alloc.h>`：BPF 内存分配。\n  - `\"mmap_unlock_work.h\"`：可能用于处理 mmap 锁相关上下文（具体用途需结合其他代码）。\n\n- **BPF 子系统**：\n  - 依赖 `bpf_iter_get_info()` 和 `bpf_iter_run_prog()` 等通用迭代器运行时支持。\n  - 使用 `DEFINE_BPF_ITER_FUNC` 宏注册 `task` 类型的 BPF 迭代器。\n\n## 5. 使用场景\n\n- **系统监控工具**：如 `bpftool` 可通过 `task` 迭代器收集所有进程的内存、CPU 或安全上下文信息。\n- **安全策略实施**：BPF 程序可遍历任务并检查其凭证（cred）、命名空间或打开的文件，实现运行时策略。\n- **资源审计**：`task_file` 迭代器可用于审计进程打开的文件、套接字或设备，检测异常行为。\n- **容器环境调试**：在容器（PID namespace）中精确遍历特定进程组的任务和资源。\n- **性能分析**：高效遍历任务结构，避免传统 `/proc` 文件系统解析开销。",
      "similarity": 0.5681146383285522,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/task_iter.c",
          "start_line": 198,
          "end_line": 303,
          "content": [
            "static int __task_seq_show(struct seq_file *seq, struct task_struct *task,",
            "\t\t\t   bool in_stop)",
            "{",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_iter__task ctx;",
            "\tstruct bpf_prog *prog;",
            "",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, in_stop);",
            "\tif (!prog)",
            "\t\treturn 0;",
            "",
            "\tctx.meta = &meta;",
            "\tctx.task = task;",
            "\treturn bpf_iter_run_prog(prog, &ctx);",
            "}",
            "static int task_seq_show(struct seq_file *seq, void *v)",
            "{",
            "\treturn __task_seq_show(seq, v, false);",
            "}",
            "static void task_seq_stop(struct seq_file *seq, void *v)",
            "{",
            "\tif (!v)",
            "\t\t(void)__task_seq_show(seq, v, true);",
            "\telse",
            "\t\tput_task_struct((struct task_struct *)v);",
            "}",
            "static int bpf_iter_attach_task(struct bpf_prog *prog,",
            "\t\t\t\tunion bpf_iter_link_info *linfo,",
            "\t\t\t\tstruct bpf_iter_aux_info *aux)",
            "{",
            "\tunsigned int flags;",
            "\tstruct pid *pid;",
            "\tpid_t tgid;",
            "",
            "\tif ((!!linfo->task.tid + !!linfo->task.pid + !!linfo->task.pid_fd) > 1)",
            "\t\treturn -EINVAL;",
            "",
            "\taux->task.type = BPF_TASK_ITER_ALL;",
            "\tif (linfo->task.tid != 0) {",
            "\t\taux->task.type = BPF_TASK_ITER_TID;",
            "\t\taux->task.pid = linfo->task.tid;",
            "\t}",
            "\tif (linfo->task.pid != 0) {",
            "\t\taux->task.type = BPF_TASK_ITER_TGID;",
            "\t\taux->task.pid = linfo->task.pid;",
            "\t}",
            "\tif (linfo->task.pid_fd != 0) {",
            "\t\taux->task.type = BPF_TASK_ITER_TGID;",
            "",
            "\t\tpid = pidfd_get_pid(linfo->task.pid_fd, &flags);",
            "\t\tif (IS_ERR(pid))",
            "\t\t\treturn PTR_ERR(pid);",
            "",
            "\t\ttgid = pid_nr_ns(pid, task_active_pid_ns(current));",
            "\t\taux->task.pid = tgid;",
            "\t\tput_pid(pid);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __task_file_seq_show(struct seq_file *seq, struct file *file,",
            "\t\t\t\tbool in_stop)",
            "{",
            "\tstruct bpf_iter_seq_task_file_info *info = seq->private;",
            "\tstruct bpf_iter__task_file ctx;",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_prog *prog;",
            "",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, in_stop);",
            "\tif (!prog)",
            "\t\treturn 0;",
            "",
            "\tctx.meta = &meta;",
            "\tctx.task = info->task;",
            "\tctx.fd = info->fd;",
            "\tctx.file = file;",
            "\treturn bpf_iter_run_prog(prog, &ctx);",
            "}",
            "static int task_file_seq_show(struct seq_file *seq, void *v)",
            "{",
            "\treturn __task_file_seq_show(seq, v, false);",
            "}",
            "static void task_file_seq_stop(struct seq_file *seq, void *v)",
            "{",
            "\tstruct bpf_iter_seq_task_file_info *info = seq->private;",
            "",
            "\tif (!v) {",
            "\t\t(void)__task_file_seq_show(seq, v, true);",
            "\t} else {",
            "\t\tfput((struct file *)v);",
            "\t\tput_task_struct(info->task);",
            "\t\tinfo->task = NULL;",
            "\t}",
            "}",
            "static int init_seq_pidns(void *priv_data, struct bpf_iter_aux_info *aux)",
            "{",
            "\tstruct bpf_iter_seq_task_common *common = priv_data;",
            "",
            "\tcommon->ns = get_pid_ns(task_active_pid_ns(current));",
            "\tcommon->type = aux->task.type;",
            "\tcommon->pid = aux->task.pid;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__task_seq_show, task_seq_show, task_seq_stop, bpf_iter_attach_task, __task_file_seq_show, task_file_seq_show, task_file_seq_stop, init_seq_pidns",
          "description": "实现任务迭代器的显示逻辑和链接参数解析，包含 __task_seq_show 显示任务信息，task_seq_stop 清理资源，bpf_iter_attach_task 解析任务类型（TID/TGID），及关联文件描述符的扩展功能。",
          "similarity": 0.5139793753623962
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/task_iter.c",
          "start_line": 900,
          "end_line": 1010,
          "content": [
            "__bpf_kfunc void bpf_iter_task_vma_destroy(struct bpf_iter_task_vma *it)",
            "{",
            "\tstruct bpf_iter_task_vma_kern *kit = (void *)it;",
            "",
            "\tif (kit->data) {",
            "\t\tbpf_mmap_unlock_mm(kit->data->work, kit->data->mm);",
            "\t\tput_task_struct(kit->data->task);",
            "\t\tbpf_mem_free(&bpf_global_ma, kit->data);",
            "\t}",
            "}",
            "__bpf_kfunc int bpf_iter_css_task_new(struct bpf_iter_css_task *it,",
            "\t\tstruct cgroup_subsys_state *css, unsigned int flags)",
            "{",
            "\tstruct bpf_iter_css_task_kern *kit = (void *)it;",
            "",
            "\tBUILD_BUG_ON(sizeof(struct bpf_iter_css_task_kern) != sizeof(struct bpf_iter_css_task));",
            "\tBUILD_BUG_ON(__alignof__(struct bpf_iter_css_task_kern) !=",
            "\t\t\t\t\t__alignof__(struct bpf_iter_css_task));",
            "\tkit->css_it = NULL;",
            "\tswitch (flags) {",
            "\tcase CSS_TASK_ITER_PROCS | CSS_TASK_ITER_THREADED:",
            "\tcase CSS_TASK_ITER_PROCS:",
            "\tcase 0:",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tkit->css_it = bpf_mem_alloc(&bpf_global_ma, sizeof(struct css_task_iter));",
            "\tif (!kit->css_it)",
            "\t\treturn -ENOMEM;",
            "\tcss_task_iter_start(css, flags, kit->css_it);",
            "\treturn 0;",
            "}",
            "__bpf_kfunc void bpf_iter_css_task_destroy(struct bpf_iter_css_task *it)",
            "{",
            "\tstruct bpf_iter_css_task_kern *kit = (void *)it;",
            "",
            "\tif (!kit->css_it)",
            "\t\treturn;",
            "\tcss_task_iter_end(kit->css_it);",
            "\tbpf_mem_free(&bpf_global_ma, kit->css_it);",
            "}",
            "__bpf_kfunc int bpf_iter_task_new(struct bpf_iter_task *it,",
            "\t\tstruct task_struct *task__nullable, unsigned int flags)",
            "{",
            "\tstruct bpf_iter_task_kern *kit = (void *)it;",
            "",
            "\tBUILD_BUG_ON(sizeof(struct bpf_iter_task_kern) > sizeof(struct bpf_iter_task));",
            "\tBUILD_BUG_ON(__alignof__(struct bpf_iter_task_kern) !=",
            "\t\t\t\t\t__alignof__(struct bpf_iter_task));",
            "",
            "\tkit->task = kit->pos = NULL;",
            "\tswitch (flags) {",
            "\tcase BPF_TASK_ITER_ALL_THREADS:",
            "\tcase BPF_TASK_ITER_ALL_PROCS:",
            "\t\tbreak;",
            "\tcase BPF_TASK_ITER_PROC_THREADS:",
            "\t\tif (!task__nullable)",
            "\t\t\treturn -EINVAL;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (flags == BPF_TASK_ITER_PROC_THREADS)",
            "\t\tkit->task = task__nullable;",
            "\telse",
            "\t\tkit->task = &init_task;",
            "\tkit->pos = kit->task;",
            "\tkit->flags = flags;",
            "\treturn 0;",
            "}",
            "__bpf_kfunc void bpf_iter_task_destroy(struct bpf_iter_task *it)",
            "{",
            "}",
            "static void do_mmap_read_unlock(struct irq_work *entry)",
            "{",
            "\tstruct mmap_unlock_irq_work *work;",
            "",
            "\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))",
            "\t\treturn;",
            "",
            "\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);",
            "\tmmap_read_unlock_non_owner(work->mm);",
            "}",
            "static int __init task_iter_init(void)",
            "{",
            "\tstruct mmap_unlock_irq_work *work;",
            "\tint ret, cpu;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\twork = per_cpu_ptr(&mmap_unlock_work, cpu);",
            "\t\tinit_irq_work(&work->irq_work, do_mmap_read_unlock);",
            "\t}",
            "",
            "\ttask_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];",
            "\tret = bpf_iter_reg_target(&task_reg_info);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\ttask_file_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];",
            "\ttask_file_reg_info.ctx_arg_info[1].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_FILE];",
            "\tret =  bpf_iter_reg_target(&task_file_reg_info);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\ttask_vma_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];",
            "\ttask_vma_reg_info.ctx_arg_info[1].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_VMA];",
            "\treturn bpf_iter_reg_target(&task_vma_reg_info);",
            "}"
          ],
          "function_name": "bpf_iter_task_vma_destroy, bpf_iter_css_task_new, bpf_iter_css_task_destroy, bpf_iter_task_new, bpf_iter_task_destroy, do_mmap_read_unlock, task_iter_init",
          "description": "实现 CSS 任务迭代器和通用任务迭代器的创建/销毁接口，包含 bpf_iter_task_new 创建任务迭代器，do_mmap_read_unlock 卸载 mmap 读锁，task_iter_init 注册 BPF 目标追踪模块到内核跟踪系统。",
          "similarity": 0.49328216910362244
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/task_iter.c",
          "start_line": 421,
          "end_line": 535,
          "content": [
            "static void fini_seq_pidns(void *priv_data)",
            "{",
            "\tstruct bpf_iter_seq_task_common *common = priv_data;",
            "",
            "\tput_pid_ns(common->ns);",
            "}",
            "static int __task_vma_seq_show(struct seq_file *seq, bool in_stop)",
            "{",
            "\tstruct bpf_iter_seq_task_vma_info *info = seq->private;",
            "\tstruct bpf_iter__task_vma ctx;",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_prog *prog;",
            "",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, in_stop);",
            "\tif (!prog)",
            "\t\treturn 0;",
            "",
            "\tctx.meta = &meta;",
            "\tctx.task = info->task;",
            "\tctx.vma = info->vma;",
            "\treturn bpf_iter_run_prog(prog, &ctx);",
            "}",
            "static int task_vma_seq_show(struct seq_file *seq, void *v)",
            "{",
            "\treturn __task_vma_seq_show(seq, false);",
            "}",
            "static void task_vma_seq_stop(struct seq_file *seq, void *v)",
            "{",
            "\tstruct bpf_iter_seq_task_vma_info *info = seq->private;",
            "",
            "\tif (!v) {",
            "\t\t(void)__task_vma_seq_show(seq, true);",
            "\t} else {",
            "\t\t/* info->vma has not been seen by the BPF program. If the",
            "\t\t * user space reads more, task_vma_seq_get_next should",
            "\t\t * return this vma again. Set prev_vm_start to ~0UL,",
            "\t\t * so that we don't skip the vma returned by the next",
            "\t\t * find_vma() (case task_vma_iter_find_vma in",
            "\t\t * task_vma_seq_get_next()).",
            "\t\t */",
            "\t\tinfo->prev_vm_start = ~0UL;",
            "\t\tinfo->prev_vm_end = info->vma->vm_end;",
            "\t\tmmap_read_unlock(info->mm);",
            "\t\tmmput(info->mm);",
            "\t\tinfo->mm = NULL;",
            "\t\tput_task_struct(info->task);",
            "\t\tinfo->task = NULL;",
            "\t}",
            "}",
            "static int bpf_iter_fill_link_info(const struct bpf_iter_aux_info *aux, struct bpf_link_info *info)",
            "{",
            "\tswitch (aux->task.type) {",
            "\tcase BPF_TASK_ITER_TID:",
            "\t\tinfo->iter.task.tid = aux->task.pid;",
            "\t\tbreak;",
            "\tcase BPF_TASK_ITER_TGID:",
            "\t\tinfo->iter.task.pid = aux->task.pid;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "\treturn 0;",
            "}",
            "static void bpf_iter_task_show_fdinfo(const struct bpf_iter_aux_info *aux, struct seq_file *seq)",
            "{",
            "\tseq_printf(seq, \"task_type:\\t%s\\n\", iter_task_type_names[aux->task.type]);",
            "\tif (aux->task.type == BPF_TASK_ITER_TID)",
            "\t\tseq_printf(seq, \"tid:\\t%u\\n\", aux->task.pid);",
            "\telse if (aux->task.type == BPF_TASK_ITER_TGID)",
            "\t\tseq_printf(seq, \"pid:\\t%u\\n\", aux->task.pid);",
            "}",
            "__bpf_kfunc int bpf_iter_task_vma_new(struct bpf_iter_task_vma *it,",
            "\t\t\t\t      struct task_struct *task, u64 addr)",
            "{",
            "\tstruct bpf_iter_task_vma_kern *kit = (void *)it;",
            "\tbool irq_work_busy = false;",
            "\tint err;",
            "",
            "\tBUILD_BUG_ON(sizeof(struct bpf_iter_task_vma_kern) != sizeof(struct bpf_iter_task_vma));",
            "\tBUILD_BUG_ON(__alignof__(struct bpf_iter_task_vma_kern) != __alignof__(struct bpf_iter_task_vma));",
            "",
            "\t/* is_iter_reg_valid_uninit guarantees that kit hasn't been initialized",
            "\t * before, so non-NULL kit->data doesn't point to previously",
            "\t * bpf_mem_alloc'd bpf_iter_task_vma_kern_data",
            "\t */",
            "\tkit->data = bpf_mem_alloc(&bpf_global_ma, sizeof(struct bpf_iter_task_vma_kern_data));",
            "\tif (!kit->data)",
            "\t\treturn -ENOMEM;",
            "",
            "\tkit->data->task = get_task_struct(task);",
            "\tkit->data->mm = task->mm;",
            "\tif (!kit->data->mm) {",
            "\t\terr = -ENOENT;",
            "\t\tgoto err_cleanup_iter;",
            "\t}",
            "",
            "\t/* kit->data->work == NULL is valid after bpf_mmap_unlock_get_irq_work */",
            "\tirq_work_busy = bpf_mmap_unlock_get_irq_work(&kit->data->work);",
            "\tif (irq_work_busy || !mmap_read_trylock(kit->data->mm)) {",
            "\t\terr = -EBUSY;",
            "\t\tgoto err_cleanup_iter;",
            "\t}",
            "",
            "\tvma_iter_init(&kit->data->vmi, kit->data->mm, addr);",
            "\treturn 0;",
            "",
            "err_cleanup_iter:",
            "\tif (kit->data->task)",
            "\t\tput_task_struct(kit->data->task);",
            "\tbpf_mem_free(&bpf_global_ma, kit->data);",
            "\t/* NULL kit->data signals failed bpf_iter_task_vma initialization */",
            "\tkit->data = NULL;",
            "\treturn err;",
            "}"
          ],
          "function_name": "fini_seq_pidns, __task_vma_seq_show, task_vma_seq_show, task_vma_seq_stop, bpf_iter_fill_link_info, bpf_iter_task_show_fdinfo, bpf_iter_task_vma_new",
          "description": "处理 VMA 区间遍历逻辑，包含 __task_vma_seq_show 显示 VMA 信息，task_vma_seq_stop 终止遍历并释放资源，提供 bpf_iter_fill_link_info 填充链接信息，以及 bpf_iter_task_vma_new 初始化 VMA 迭代器的内核态数据结构。",
          "similarity": 0.48592591285705566
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/task_iter.c",
          "start_line": 1,
          "end_line": 197,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2020 Facebook */",
            "",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_mem_alloc.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/mm_types.h>",
            "#include \"mmap_unlock_work.h\"",
            "",
            "static const char * const iter_task_type_names[] = {",
            "\t\"ALL\",",
            "\t\"TID\",",
            "\t\"PID\",",
            "};",
            "",
            "struct bpf_iter_seq_task_common {",
            "\tstruct pid_namespace *ns;",
            "\tenum bpf_iter_task_type\ttype;",
            "\tu32 pid;",
            "\tu32 pid_visiting;",
            "};",
            "",
            "struct bpf_iter_seq_task_info {",
            "\t/* The first field must be struct bpf_iter_seq_task_common.",
            "\t * this is assumed by {init, fini}_seq_pidns() callback functions.",
            "\t */",
            "\tstruct bpf_iter_seq_task_common common;",
            "\tu32 tid;",
            "};",
            "",
            "static struct task_struct *task_group_seq_get_next(struct bpf_iter_seq_task_common *common,",
            "\t\t\t\t\t\t   u32 *tid,",
            "\t\t\t\t\t\t   bool skip_if_dup_files)",
            "{",
            "\tstruct task_struct *task, *next_task;",
            "\tstruct pid *pid;",
            "\tu32 saved_tid;",
            "",
            "\tif (!*tid) {",
            "\t\t/* The first time, the iterator calls this function. */",
            "\t\tpid = find_pid_ns(common->pid, common->ns);",
            "\t\tif (!pid)",
            "\t\t\treturn NULL;",
            "",
            "\t\ttask = get_pid_task(pid, PIDTYPE_TGID);",
            "\t\tif (!task)",
            "\t\t\treturn NULL;",
            "",
            "\t\t*tid = common->pid;",
            "\t\tcommon->pid_visiting = common->pid;",
            "",
            "\t\treturn task;",
            "\t}",
            "",
            "\t/* If the control returns to user space and comes back to the",
            "\t * kernel again, *tid and common->pid_visiting should be the",
            "\t * same for task_seq_start() to pick up the correct task.",
            "\t */",
            "\tif (*tid == common->pid_visiting) {",
            "\t\tpid = find_pid_ns(common->pid_visiting, common->ns);",
            "\t\ttask = get_pid_task(pid, PIDTYPE_PID);",
            "",
            "\t\treturn task;",
            "\t}",
            "",
            "\tpid = find_pid_ns(common->pid_visiting, common->ns);",
            "\tif (!pid)",
            "\t\treturn NULL;",
            "",
            "\ttask = get_pid_task(pid, PIDTYPE_PID);",
            "\tif (!task)",
            "\t\treturn NULL;",
            "",
            "retry:",
            "\tif (!pid_alive(task)) {",
            "\t\tput_task_struct(task);",
            "\t\treturn NULL;",
            "\t}",
            "",
            "\tnext_task = next_thread(task);",
            "\tput_task_struct(task);",
            "\tif (!next_task)",
            "\t\treturn NULL;",
            "",
            "\tsaved_tid = *tid;",
            "\t*tid = __task_pid_nr_ns(next_task, PIDTYPE_PID, common->ns);",
            "\tif (!*tid || *tid == common->pid) {",
            "\t\t/* Run out of tasks of a process.  The tasks of a",
            "\t\t * thread_group are linked as circular linked list.",
            "\t\t */",
            "\t\t*tid = saved_tid;",
            "\t\treturn NULL;",
            "\t}",
            "",
            "\tget_task_struct(next_task);",
            "\tcommon->pid_visiting = *tid;",
            "",
            "\tif (skip_if_dup_files && task->files == task->group_leader->files) {",
            "\t\ttask = next_task;",
            "\t\tgoto retry;",
            "\t}",
            "",
            "\treturn next_task;",
            "}",
            "",
            "static struct task_struct *task_seq_get_next(struct bpf_iter_seq_task_common *common,",
            "\t\t\t\t\t     u32 *tid,",
            "\t\t\t\t\t     bool skip_if_dup_files)",
            "{",
            "\tstruct task_struct *task = NULL;",
            "\tstruct pid *pid;",
            "",
            "\tif (common->type == BPF_TASK_ITER_TID) {",
            "\t\tif (*tid && *tid != common->pid)",
            "\t\t\treturn NULL;",
            "\t\trcu_read_lock();",
            "\t\tpid = find_pid_ns(common->pid, common->ns);",
            "\t\tif (pid) {",
            "\t\t\ttask = get_pid_task(pid, PIDTYPE_PID);",
            "\t\t\t*tid = common->pid;",
            "\t\t}",
            "\t\trcu_read_unlock();",
            "",
            "\t\treturn task;",
            "\t}",
            "",
            "\tif (common->type == BPF_TASK_ITER_TGID) {",
            "\t\trcu_read_lock();",
            "\t\ttask = task_group_seq_get_next(common, tid, skip_if_dup_files);",
            "\t\trcu_read_unlock();",
            "",
            "\t\treturn task;",
            "\t}",
            "",
            "\trcu_read_lock();",
            "retry:",
            "\tpid = find_ge_pid(*tid, common->ns);",
            "\tif (pid) {",
            "\t\t*tid = pid_nr_ns(pid, common->ns);",
            "\t\ttask = get_pid_task(pid, PIDTYPE_PID);",
            "\t\tif (!task) {",
            "\t\t\t++*tid;",
            "\t\t\tgoto retry;",
            "\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&",
            "\t\t\t   task->files == task->group_leader->files) {",
            "\t\t\tput_task_struct(task);",
            "\t\t\ttask = NULL;",
            "\t\t\t++*tid;",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn task;",
            "}",
            "",
            "static void *task_seq_start(struct seq_file *seq, loff_t *pos)",
            "{",
            "\tstruct bpf_iter_seq_task_info *info = seq->private;",
            "\tstruct task_struct *task;",
            "",
            "\ttask = task_seq_get_next(&info->common, &info->tid, false);",
            "\tif (!task)",
            "\t\treturn NULL;",
            "",
            "\tif (*pos == 0)",
            "\t\t++*pos;",
            "\treturn task;",
            "}",
            "",
            "static void *task_seq_next(struct seq_file *seq, void *v, loff_t *pos)",
            "{",
            "\tstruct bpf_iter_seq_task_info *info = seq->private;",
            "\tstruct task_struct *task;",
            "",
            "\t++*pos;",
            "\t++info->tid;",
            "\tput_task_struct((struct task_struct *)v);",
            "\ttask = task_seq_get_next(&info->common, &info->tid, false);",
            "\tif (!task)",
            "\t\treturn NULL;",
            "",
            "\treturn task;",
            "}",
            "",
            "struct bpf_iter__task {",
            "\t__bpf_md_ptr(struct bpf_iter_meta *, meta);",
            "\t__bpf_md_ptr(struct task_struct *, task);",
            "};",
            "",
            "DEFINE_BPF_ITER_FUNC(task, struct bpf_iter_meta *meta, struct task_struct *task)",
            ""
          ],
          "function_name": null,
          "description": "定义任务迭代器相关结构体和函数，支持根据 TID/PID 遍历进程/线程，提供 task_group_seq_get_next 和 task_seq_get_next 等核心函数用于获取下一个任务实体，通过 RCU 锁保护并处理进程状态检查。",
          "similarity": 0.48122021555900574
        }
      ]
    }
  ]
}