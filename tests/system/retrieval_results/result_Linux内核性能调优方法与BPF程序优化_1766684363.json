{
  "query": "Linux内核性能调优方法与BPF程序优化",
  "timestamp": "2025-12-26 01:39:23",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/core.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:05:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\core.c`\n\n---\n\n# `bpf/core.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/core.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统的核心实现文件之一，主要负责 BPF 程序的内存分配、生命周期管理、辅助函数支持以及与 JIT（Just-In-Time）编译器的交互。该文件为 eBPF（extended BPF）程序提供基础运行时支持，包括程序结构体的分配与释放、统计信息管理、调试信息（如行号信息 linfo）填充、程序标签（tag）计算等关键功能。其设计融合了经典 BPF 的兼容性与现代 eBPF 的扩展能力，是连接用户空间 BPF 程序加载与内核执行环境的重要桥梁。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct bpf_prog`：eBPF 程序的核心结构体，包含指令数组、辅助信息（`aux`）、JIT 编译后的函数指针等。\n- `struct bpf_prog_aux`：BPF 程序的辅助数据结构，用于存储映射（maps）、外部函数（kfuncs）、调试信息（linfo）、引用计数等。\n- `struct bpf_prog_stats`：每 CPU 的 BPF 程序执行统计信息（如执行次数、运行时间）。\n- `bpf_global_ma`：全局 BPF 内存分配器实例，用于内存控制组（memcg）感知的内存分配。\n\n### 主要函数\n- `bpf_internal_load_pointer_neg_helper()`：为经典 BPF 程序提供负偏移量的数据包指针加载辅助函数。\n- `bpf_prog_alloc_no_stats()`：分配不包含统计信息的 BPF 程序结构体。\n- `bpf_prog_alloc()`：分配包含每 CPU 统计信息的完整 BPF 程序结构体（导出符号，供模块使用）。\n- `bpf_prog_alloc_jited_linfo()`：为 JIT 编译分配行号信息（linfo）映射数组。\n- `bpf_prog_jit_attempt_done()`：清理 JIT 编译尝试后的临时资源（如未使用的 linfo 或 kfunc 表）。\n- `bpf_prog_fill_jited_linfo()`：根据 JIT 指令偏移映射填充调试用的行号信息。\n- `bpf_prog_realloc()`：重新分配更大的 BPF 程序内存空间（用于程序转换或扩展）。\n- `__bpf_prog_free()`：释放 BPF 程序及其所有关联资源。\n- `bpf_prog_calc_tag()`：计算 BPF 程序的 SHA1 哈希标签（用于唯一标识程序内容，排除不稳定字段如 map fd）。\n\n## 3. 关键实现\n\n### 内存分配与管理\n- BPF 程序主体（`struct bpf_prog`）使用 `__vmalloc()` 分配，按页对齐（`round_up(size, PAGE_SIZE)`），支持大程序。\n- 辅助结构（`aux`）、每 CPU 统计（`stats`）和活跃状态（`active`）使用 `kzalloc()` 和 `alloc_percpu_gfp()` 分配，并集成内存控制组（memcg）支持（通过 `bpf_memcg_flags()`）。\n- 全局内存分配器 `bpf_global_ma` 用于统一管理 BPF 相关内存，支持 memcg 隔离。\n\n### JIT 调试信息支持\n- `bpf_prog_fill_jited_linfo()` 实现了从 BPF 指令偏移到 JIT 机器码偏移的映射，用于将源码行号信息（`linfo`）关联到 JIT 编译后的代码地址，便于调试和性能分析。\n- 该函数依赖 JIT 引擎提供的 `insn_to_jit_off` 数组，确保调试信息与实际执行代码对齐。\n\n### 程序标签计算\n- `bpf_prog_calc_tag()` 在计算 SHA1 哈希前，会复制程序指令并**移除不稳定的字段**（如 `BPF_LD_MAP_FD` 指令中的 map 文件描述符），确保相同逻辑的程序生成相同的标签，用于程序去重和验证缓存。\n\n### 安全与兼容性\n- `bpf_internal_load_pointer_neg_helper()` 处理经典 BPF 的负偏移访问（如 `SKF_NET_OFF`、`SKF_LL_OFF`），严格检查指针是否在 `sk_buff` 数据范围内，防止越界访问。\n- 所有内存分配均使用 `__GFP_ZERO` 初始化，避免信息泄露。\n- 支持细粒度锁（如 `used_maps_mutex`、`ext_mutex`）保护共享资源。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - BPF 核心接口：`<linux/bpf.h>`, `<linux/filter.h>`\n  - 验证器：`<linux/bpf_verifier.h>`\n  - 内存管理：`<linux/vmalloc.h>`, `<linux/memcontrol.h>`, `<linux/bpf_mem_alloc.h>`\n  - 网络子系统：`<linux/skbuff.h>`（用于经典 BPF 辅助函数）\n  - 调试与符号：`<linux/kallsyms.h>`, `<linux/perf_event.h>`\n  - 架构相关：`<asm/barrier.h>`, `<asm/unaligned.h>`\n- **模块依赖**：\n  - BPF JIT 编译器（通过 `ebpf_jit_enabled()` 和 `bpf_jit_blinding_enabled()` 交互）\n  - BPF 验证器（`bpf_check_classic()` 在其他文件中，但与此文件协同工作）\n  - cgroup BPF（`CONFIG_CGROUP_BPF` 条件编译）\n  - 内存控制组（memcg）子系统\n\n## 5. 使用场景\n\n- **BPF 程序加载**：当用户空间通过 `bpf(BPF_PROG_LOAD, ...)` 系统调用加载程序时，内核调用 `bpf_prog_alloc()` 分配程序结构。\n- **JIT 编译流程**：JIT 编译器在编译前后调用 `bpf_prog_alloc_jited_linfo()` 和 `bpf_prog_fill_jited_linfo()` 管理调试信息；编译失败时调用 `bpf_prog_jit_attempt_done()` 清理资源。\n- **程序转换与优化**：验证器或 JIT 在优化过程中可能需要更大的内存空间，调用 `bpf_prog_realloc()` 扩展程序存储。\n- **程序卸载**：当 BPF 程序引用计数归零时，调用 `__bpf_prog_free()` 释放所有资源。\n- **程序标识与缓存**：`bpf_prog_calc_tag()` 生成的标签用于内核内部缓存（如 verifier log 缓存）和用户空间工具（如 bpftool）识别程序。\n- **经典 BPF 兼容**：网络抓包工具（如 tcpdump）使用经典 BPF 时，内核通过 `bpf_internal_load_pointer_neg_helper()` 安全访问数据包头。",
      "similarity": 0.6820729970932007,
      "chunks": [
        {
          "chunk_id": 7,
          "file_path": "kernel/bpf/core.c",
          "start_line": 1434,
          "end_line": 1643,
          "content": [
            "static void bpf_prog_clone_free(struct bpf_prog *fp)",
            "{",
            "\t/* aux was stolen by the other clone, so we cannot free",
            "\t * it from this path! It will be freed eventually by the",
            "\t * other program on release.",
            "\t *",
            "\t * At this point, we don't need a deferred release since",
            "\t * clone is guaranteed to not be locked.",
            "\t */",
            "\tfp->aux = NULL;",
            "\tfp->stats = NULL;",
            "\tfp->active = NULL;",
            "\t__bpf_prog_free(fp);",
            "}",
            "void bpf_jit_prog_release_other(struct bpf_prog *fp, struct bpf_prog *fp_other)",
            "{",
            "\t/* We have to repoint aux->prog to self, as we don't",
            "\t * know whether fp here is the clone or the original.",
            "\t */",
            "\tfp->aux->prog = fp;",
            "\tbpf_prog_clone_free(fp_other);",
            "}",
            "noinline u64 __bpf_call_base(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)",
            "{",
            "\treturn 0;",
            "}",
            "bool bpf_opcode_in_insntable(u8 code)",
            "{",
            "#define BPF_INSN_2_TBL(x, y)    [BPF_##x | BPF_##y] = true",
            "#define BPF_INSN_3_TBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = true",
            "\tstatic const bool public_insntable[256] = {",
            "\t\t[0 ... 255] = false,",
            "\t\t/* Now overwrite non-defaults ... */",
            "\t\tBPF_INSN_MAP(BPF_INSN_2_TBL, BPF_INSN_3_TBL),",
            "\t\t/* UAPI exposed, but rewritten opcodes. cBPF carry-over. */",
            "\t\t[BPF_LD | BPF_ABS | BPF_B] = true,",
            "\t\t[BPF_LD | BPF_ABS | BPF_H] = true,",
            "\t\t[BPF_LD | BPF_ABS | BPF_W] = true,",
            "\t\t[BPF_LD | BPF_IND | BPF_B] = true,",
            "\t\t[BPF_LD | BPF_IND | BPF_H] = true,",
            "\t\t[BPF_LD | BPF_IND | BPF_W] = true,",
            "\t\t[BPF_JMP | BPF_JCOND] = true,",
            "\t};",
            "#undef BPF_INSN_3_TBL",
            "#undef BPF_INSN_2_TBL",
            "\treturn public_insntable[code];",
            "}",
            "static u64 ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn)",
            "{",
            "#define BPF_INSN_2_LBL(x, y)    [BPF_##x | BPF_##y] = &&x##_##y",
            "#define BPF_INSN_3_LBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = &&x##_##y##_##z",
            "\tstatic const void * const jumptable[256] __annotate_jump_table = {",
            "\t\t[0 ... 255] = &&default_label,",
            "\t\t/* Now overwrite non-defaults ... */",
            "\t\tBPF_INSN_MAP(BPF_INSN_2_LBL, BPF_INSN_3_LBL),",
            "\t\t/* Non-UAPI available opcodes. */",
            "\t\t[BPF_JMP | BPF_CALL_ARGS] = &&JMP_CALL_ARGS,",
            "\t\t[BPF_JMP | BPF_TAIL_CALL] = &&JMP_TAIL_CALL,",
            "\t\t[BPF_ST  | BPF_NOSPEC] = &&ST_NOSPEC,",
            "\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_B] = &&LDX_PROBE_MEM_B,",
            "\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_H] = &&LDX_PROBE_MEM_H,",
            "\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_W] = &&LDX_PROBE_MEM_W,",
            "\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_DW] = &&LDX_PROBE_MEM_DW,",
            "\t\t[BPF_LDX | BPF_PROBE_MEMSX | BPF_B] = &&LDX_PROBE_MEMSX_B,",
            "\t\t[BPF_LDX | BPF_PROBE_MEMSX | BPF_H] = &&LDX_PROBE_MEMSX_H,",
            "\t\t[BPF_LDX | BPF_PROBE_MEMSX | BPF_W] = &&LDX_PROBE_MEMSX_W,",
            "\t};",
            "#undef BPF_INSN_3_LBL",
            "#undef BPF_INSN_2_LBL",
            "\tu32 tail_call_cnt = 0;",
            "",
            "#define CONT\t ({ insn++; goto select_insn; })",
            "#define CONT_JMP ({ insn++; goto select_insn; })",
            "",
            "select_insn:",
            "\tgoto *jumptable[insn->code];",
            "",
            "\t/* Explicitly mask the register-based shift amounts with 63 or 31",
            "\t * to avoid undefined behavior. Normally this won't affect the",
            "\t * generated code, for example, in case of native 64 bit archs such",
            "\t * as x86-64 or arm64, the compiler is optimizing the AND away for",
            "\t * the interpreter. In case of JITs, each of the JIT backends compiles",
            "\t * the BPF shift operations to machine instructions which produce",
            "\t * implementation-defined results in such a case; the resulting",
            "\t * contents of the register may be arbitrary, but program behaviour",
            "\t * as a whole remains defined. In other words, in case of JIT backends,",
            "\t * the AND must /not/ be added to the emitted LSH/RSH/ARSH translation.",
            "\t */",
            "\t/* ALU (shifts) */",
            "#define SHT(OPCODE, OP)\t\t\t\t\t\\",
            "\tALU64_##OPCODE##_X:\t\t\t\t\\",
            "\t\tDST = DST OP (SRC & 63);\t\t\\",
            "\t\tCONT;\t\t\t\t\t\\",
            "\tALU_##OPCODE##_X:\t\t\t\t\\",
            "\t\tDST = (u32) DST OP ((u32) SRC & 31);\t\\",
            "\t\tCONT;\t\t\t\t\t\\",
            "\tALU64_##OPCODE##_K:\t\t\t\t\\",
            "\t\tDST = DST OP IMM;\t\t\t\\",
            "\t\tCONT;\t\t\t\t\t\\",
            "\tALU_##OPCODE##_K:\t\t\t\t\\",
            "\t\tDST = (u32) DST OP (u32) IMM;\t\t\\",
            "\t\tCONT;",
            "\t/* ALU (rest) */",
            "#define ALU(OPCODE, OP)\t\t\t\t\t\\",
            "\tALU64_##OPCODE##_X:\t\t\t\t\\",
            "\t\tDST = DST OP SRC;\t\t\t\\",
            "\t\tCONT;\t\t\t\t\t\\",
            "\tALU_##OPCODE##_X:\t\t\t\t\\",
            "\t\tDST = (u32) DST OP (u32) SRC;\t\t\\",
            "\t\tCONT;\t\t\t\t\t\\",
            "\tALU64_##OPCODE##_K:\t\t\t\t\\",
            "\t\tDST = DST OP IMM;\t\t\t\\",
            "\t\tCONT;\t\t\t\t\t\\",
            "\tALU_##OPCODE##_K:\t\t\t\t\\",
            "\t\tDST = (u32) DST OP (u32) IMM;\t\t\\",
            "\t\tCONT;",
            "\tALU(ADD,  +)",
            "\tALU(SUB,  -)",
            "\tALU(AND,  &)",
            "\tALU(OR,   |)",
            "\tALU(XOR,  ^)",
            "\tALU(MUL,  *)",
            "\tSHT(LSH, <<)",
            "\tSHT(RSH, >>)",
            "#undef SHT",
            "#undef ALU",
            "\tALU_NEG:",
            "\t\tDST = (u32) -DST;",
            "\t\tCONT;",
            "\tALU64_NEG:",
            "\t\tDST = -DST;",
            "\t\tCONT;",
            "\tALU_MOV_X:",
            "\t\tswitch (OFF) {",
            "\t\tcase 0:",
            "\t\t\tDST = (u32) SRC;",
            "\t\t\tbreak;",
            "\t\tcase 8:",
            "\t\t\tDST = (u32)(s8) SRC;",
            "\t\t\tbreak;",
            "\t\tcase 16:",
            "\t\t\tDST = (u32)(s16) SRC;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tCONT;",
            "\tALU_MOV_K:",
            "\t\tDST = (u32) IMM;",
            "\t\tCONT;",
            "\tALU64_MOV_X:",
            "\t\tswitch (OFF) {",
            "\t\tcase 0:",
            "\t\t\tDST = SRC;",
            "\t\t\tbreak;",
            "\t\tcase 8:",
            "\t\t\tDST = (s8) SRC;",
            "\t\t\tbreak;",
            "\t\tcase 16:",
            "\t\t\tDST = (s16) SRC;",
            "\t\t\tbreak;",
            "\t\tcase 32:",
            "\t\t\tDST = (s32) SRC;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tCONT;",
            "\tALU64_MOV_K:",
            "\t\tDST = IMM;",
            "\t\tCONT;",
            "\tLD_IMM_DW:",
            "\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;",
            "\t\tinsn++;",
            "\t\tCONT;",
            "\tALU_ARSH_X:",
            "\t\tDST = (u64) (u32) (((s32) DST) >> (SRC & 31));",
            "\t\tCONT;",
            "\tALU_ARSH_K:",
            "\t\tDST = (u64) (u32) (((s32) DST) >> IMM);",
            "\t\tCONT;",
            "\tALU64_ARSH_X:",
            "\t\t(*(s64 *) &DST) >>= (SRC & 63);",
            "\t\tCONT;",
            "\tALU64_ARSH_K:",
            "\t\t(*(s64 *) &DST) >>= IMM;",
            "\t\tCONT;",
            "\tALU64_MOD_X:",
            "\t\tswitch (OFF) {",
            "\t\tcase 0:",
            "\t\t\tdiv64_u64_rem(DST, SRC, &AX);",
            "\t\t\tDST = AX;",
            "\t\t\tbreak;",
            "\t\tcase 1:",
            "\t\t\tAX = div64_s64(DST, SRC);",
            "\t\t\tDST = DST - AX * SRC;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tCONT;",
            "\tALU_MOD_X:",
            "\t\tswitch (OFF) {",
            "\t\tcase 0:",
            "\t\t\tAX = (u32) DST;",
            "\t\t\tDST = do_div(AX, (u32) SRC);",
            "\t\t\tbreak;",
            "\t\tcase 1:",
            "\t\t\tAX = abs((s32)DST);",
            "\t\t\tAX = do_div(AX, abs((s32)SRC));",
            "\t\t\tif ((s32)DST < 0)",
            "\t\t\t\tDST = (u32)-AX;",
            "\t\t\telse",
            "\t\t\t\tDST = (u32)AX;",
            "\t\t\tbreak;",
            "\t\t}"
          ],
          "function_name": "bpf_prog_clone_free, bpf_jit_prog_release_other, __bpf_call_base, bpf_opcode_in_insntable, ___bpf_prog_run",
          "description": "实现BPF程序克隆释放机制，维护调用基址标识，构建指令跳转表并处理算术运算，包含寄存器移位优化及异常处理逻辑",
          "similarity": 0.6871089935302734
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/core.c",
          "start_line": 362,
          "end_line": 473,
          "content": [
            "static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, s32 end_old,",
            "\t\t\t\ts32 end_new, s32 curr, const bool probe_pass)",
            "{",
            "\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;",
            "\ts32 delta = end_new - end_old;",
            "\ts64 imm = insn->imm;",
            "",
            "\tif (curr < pos && curr + imm + 1 >= end_old)",
            "\t\timm += delta;",
            "\telse if (curr >= end_new && curr + imm + 1 < end_new)",
            "\t\timm -= delta;",
            "\tif (imm < imm_min || imm > imm_max)",
            "\t\treturn -ERANGE;",
            "\tif (!probe_pass)",
            "\t\tinsn->imm = imm;",
            "\treturn 0;",
            "}",
            "static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, s32 end_old,",
            "\t\t\t\ts32 end_new, s32 curr, const bool probe_pass)",
            "{",
            "\ts64 off_min, off_max, off;",
            "\ts32 delta = end_new - end_old;",
            "",
            "\tif (insn->code == (BPF_JMP32 | BPF_JA)) {",
            "\t\toff = insn->imm;",
            "\t\toff_min = S32_MIN;",
            "\t\toff_max = S32_MAX;",
            "\t} else {",
            "\t\toff = insn->off;",
            "\t\toff_min = S16_MIN;",
            "\t\toff_max = S16_MAX;",
            "\t}",
            "",
            "\tif (curr < pos && curr + off + 1 >= end_old)",
            "\t\toff += delta;",
            "\telse if (curr >= end_new && curr + off + 1 < end_new)",
            "\t\toff -= delta;",
            "\tif (off < off_min || off > off_max)",
            "\t\treturn -ERANGE;",
            "\tif (!probe_pass) {",
            "\t\tif (insn->code == (BPF_JMP32 | BPF_JA))",
            "\t\t\tinsn->imm = off;",
            "\t\telse",
            "\t\t\tinsn->off = off;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, s32 end_old,",
            "\t\t\t    s32 end_new, const bool probe_pass)",
            "{",
            "\tu32 i, insn_cnt = prog->len + (probe_pass ? end_new - end_old : 0);",
            "\tstruct bpf_insn *insn = prog->insnsi;",
            "\tint ret = 0;",
            "",
            "\tfor (i = 0; i < insn_cnt; i++, insn++) {",
            "\t\tu8 code;",
            "",
            "\t\t/* In the probing pass we still operate on the original,",
            "\t\t * unpatched image in order to check overflows before we",
            "\t\t * do any other adjustments. Therefore skip the patchlet.",
            "\t\t */",
            "\t\tif (probe_pass && i == pos) {",
            "\t\t\ti = end_new;",
            "\t\t\tinsn = prog->insnsi + end_old;",
            "\t\t}",
            "\t\tif (bpf_pseudo_func(insn)) {",
            "\t\t\tret = bpf_adj_delta_to_imm(insn, pos, end_old,",
            "\t\t\t\t\t\t   end_new, i, probe_pass);",
            "\t\t\tif (ret)",
            "\t\t\t\treturn ret;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tcode = insn->code;",
            "\t\tif ((BPF_CLASS(code) != BPF_JMP &&",
            "\t\t     BPF_CLASS(code) != BPF_JMP32) ||",
            "\t\t    BPF_OP(code) == BPF_EXIT)",
            "\t\t\tcontinue;",
            "\t\t/* Adjust offset of jmps if we cross patch boundaries. */",
            "\t\tif (BPF_OP(code) == BPF_CALL) {",
            "\t\t\tif (insn->src_reg != BPF_PSEUDO_CALL)",
            "\t\t\t\tcontinue;",
            "\t\t\tret = bpf_adj_delta_to_imm(insn, pos, end_old,",
            "\t\t\t\t\t\t   end_new, i, probe_pass);",
            "\t\t} else {",
            "\t\t\tret = bpf_adj_delta_to_off(insn, pos, end_old,",
            "\t\t\t\t\t\t   end_new, i, probe_pass);",
            "\t\t}",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static void bpf_adj_linfo(struct bpf_prog *prog, u32 off, u32 delta)",
            "{",
            "\tstruct bpf_line_info *linfo;",
            "\tu32 i, nr_linfo;",
            "",
            "\tnr_linfo = prog->aux->nr_linfo;",
            "\tif (!nr_linfo || !delta)",
            "\t\treturn;",
            "",
            "\tlinfo = prog->aux->linfo;",
            "",
            "\tfor (i = 0; i < nr_linfo; i++)",
            "\t\tif (off < linfo[i].insn_off)",
            "\t\t\tbreak;",
            "",
            "\t/* Push all off < linfo[i].insn_off by delta */",
            "\tfor (; i < nr_linfo; i++)",
            "\t\tlinfo[i].insn_off += delta;",
            "}"
          ],
          "function_name": "bpf_adj_delta_to_imm, bpf_adj_delta_to_off, bpf_adj_branches, bpf_adj_linfo",
          "description": "实现指令调整算法，用于动态修改BPF程序中的立即数、偏移量及调试信息，支持程序结构调整时的控制流修正。",
          "similarity": 0.6535606384277344
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/core.c",
          "start_line": 539,
          "end_line": 644,
          "content": [
            "int bpf_remove_insns(struct bpf_prog *prog, u32 off, u32 cnt)",
            "{",
            "\tint err;",
            "",
            "\t/* Branch offsets can't overflow when program is shrinking, no need",
            "\t * to call bpf_adj_branches(..., true) here",
            "\t */",
            "\tmemmove(prog->insnsi + off, prog->insnsi + off + cnt,",
            "\t\tsizeof(struct bpf_insn) * (prog->len - off - cnt));",
            "\tprog->len -= cnt;",
            "",
            "\terr = bpf_adj_branches(prog, off, off + cnt, off, false);",
            "\tWARN_ON_ONCE(err);",
            "\treturn err;",
            "}",
            "static void bpf_prog_kallsyms_del_subprogs(struct bpf_prog *fp)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < fp->aux->real_func_cnt; i++)",
            "\t\tbpf_prog_kallsyms_del(fp->aux->func[i]);",
            "}",
            "void bpf_prog_kallsyms_del_all(struct bpf_prog *fp)",
            "{",
            "\tbpf_prog_kallsyms_del_subprogs(fp);",
            "\tbpf_prog_kallsyms_del(fp);",
            "}",
            "static void",
            "bpf_prog_ksym_set_addr(struct bpf_prog *prog)",
            "{",
            "\tWARN_ON_ONCE(!bpf_prog_ebpf_jited(prog));",
            "",
            "\tprog->aux->ksym.start = (unsigned long) prog->bpf_func;",
            "\tprog->aux->ksym.end   = prog->aux->ksym.start + prog->jited_len;",
            "}",
            "static void",
            "bpf_prog_ksym_set_name(struct bpf_prog *prog)",
            "{",
            "\tchar *sym = prog->aux->ksym.name;",
            "\tconst char *end = sym + KSYM_NAME_LEN;",
            "\tconst struct btf_type *type;",
            "\tconst char *func_name;",
            "",
            "\tBUILD_BUG_ON(sizeof(\"bpf_prog_\") +",
            "\t\t     sizeof(prog->tag) * 2 +",
            "\t\t     /* name has been null terminated.",
            "\t\t      * We should need +1 for the '_' preceding",
            "\t\t      * the name.  However, the null character",
            "\t\t      * is double counted between the name and the",
            "\t\t      * sizeof(\"bpf_prog_\") above, so we omit",
            "\t\t      * the +1 here.",
            "\t\t      */",
            "\t\t     sizeof(prog->aux->name) > KSYM_NAME_LEN);",
            "",
            "\tsym += snprintf(sym, KSYM_NAME_LEN, \"bpf_prog_\");",
            "\tsym  = bin2hex(sym, prog->tag, sizeof(prog->tag));",
            "",
            "\t/* prog->aux->name will be ignored if full btf name is available */",
            "\tif (prog->aux->func_info_cnt && prog->aux->func_idx < prog->aux->func_info_cnt) {",
            "\t\ttype = btf_type_by_id(prog->aux->btf,",
            "\t\t\t\t      prog->aux->func_info[prog->aux->func_idx].type_id);",
            "\t\tfunc_name = btf_name_by_offset(prog->aux->btf, type->name_off);",
            "\t\tsnprintf(sym, (size_t)(end - sym), \"_%s\", func_name);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (prog->aux->name[0])",
            "\t\tsnprintf(sym, (size_t)(end - sym), \"_%s\", prog->aux->name);",
            "\telse",
            "\t\t*sym = 0;",
            "}",
            "static unsigned long bpf_get_ksym_start(struct latch_tree_node *n)",
            "{",
            "\treturn container_of(n, struct bpf_ksym, tnode)->start;",
            "}",
            "static __always_inline bool bpf_tree_less(struct latch_tree_node *a,",
            "\t\t\t\t\t  struct latch_tree_node *b)",
            "{",
            "\treturn bpf_get_ksym_start(a) < bpf_get_ksym_start(b);",
            "}",
            "static __always_inline int bpf_tree_comp(void *key, struct latch_tree_node *n)",
            "{",
            "\tunsigned long val = (unsigned long)key;",
            "\tconst struct bpf_ksym *ksym;",
            "",
            "\tksym = container_of(n, struct bpf_ksym, tnode);",
            "",
            "\tif (val < ksym->start)",
            "\t\treturn -1;",
            "\t/* Ensure that we detect return addresses as part of the program, when",
            "\t * the final instruction is a call for a program part of the stack",
            "\t * trace. Therefore, do val > ksym->end instead of val >= ksym->end.",
            "\t */",
            "\tif (val > ksym->end)",
            "\t\treturn  1;",
            "",
            "\treturn 0;",
            "}",
            "void bpf_ksym_add(struct bpf_ksym *ksym)",
            "{",
            "\tspin_lock_bh(&bpf_lock);",
            "\tWARN_ON_ONCE(!list_empty(&ksym->lnode));",
            "\tlist_add_tail_rcu(&ksym->lnode, &bpf_kallsyms);",
            "\tlatch_tree_insert(&ksym->tnode, &bpf_tree, &bpf_tree_ops);",
            "\tspin_unlock_bh(&bpf_lock);",
            "}"
          ],
          "function_name": "bpf_remove_insns, bpf_prog_kallsyms_del_subprogs, bpf_prog_kallsyms_del_all, bpf_prog_ksym_set_addr, bpf_prog_ksym_set_name, bpf_get_ksym_start, bpf_tree_less, bpf_tree_comp, bpf_ksym_add",
          "description": "管理BPF程序的内核符号表操作，包含符号地址/名称设置、符号树插入/删除逻辑及内核符号查找接口实现。",
          "similarity": 0.652789294719696
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/core.c",
          "start_line": 1,
          "end_line": 166,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Linux Socket Filter - Kernel level socket filtering",
            " *",
            " * Based on the design of the Berkeley Packet Filter. The new",
            " * internal format has been designed by PLUMgrid:",
            " *",
            " *\tCopyright (c) 2011 - 2014 PLUMgrid, http://plumgrid.com",
            " *",
            " * Authors:",
            " *",
            " *\tJay Schulist <jschlst@samba.org>",
            " *\tAlexei Starovoitov <ast@plumgrid.com>",
            " *\tDaniel Borkmann <dborkman@redhat.com>",
            " *",
            " * Andi Kleen - Fix a few bad bugs and races.",
            " * Kris Katterjohn - Added many additional checks in bpf_check_classic()",
            " */",
            "",
            "#include <uapi/linux/btf.h>",
            "#include <linux/filter.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/random.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/objtool.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/extable.h>",
            "#include <linux/log2.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/nospec.h>",
            "#include <linux/bpf_mem_alloc.h>",
            "#include <linux/memcontrol.h>",
            "",
            "#include <asm/barrier.h>",
            "#include <asm/unaligned.h>",
            "",
            "/* Registers */",
            "#define BPF_R0\tregs[BPF_REG_0]",
            "#define BPF_R1\tregs[BPF_REG_1]",
            "#define BPF_R2\tregs[BPF_REG_2]",
            "#define BPF_R3\tregs[BPF_REG_3]",
            "#define BPF_R4\tregs[BPF_REG_4]",
            "#define BPF_R5\tregs[BPF_REG_5]",
            "#define BPF_R6\tregs[BPF_REG_6]",
            "#define BPF_R7\tregs[BPF_REG_7]",
            "#define BPF_R8\tregs[BPF_REG_8]",
            "#define BPF_R9\tregs[BPF_REG_9]",
            "#define BPF_R10\tregs[BPF_REG_10]",
            "",
            "/* Named registers */",
            "#define DST\tregs[insn->dst_reg]",
            "#define SRC\tregs[insn->src_reg]",
            "#define FP\tregs[BPF_REG_FP]",
            "#define AX\tregs[BPF_REG_AX]",
            "#define ARG1\tregs[BPF_REG_ARG1]",
            "#define CTX\tregs[BPF_REG_CTX]",
            "#define OFF\tinsn->off",
            "#define IMM\tinsn->imm",
            "",
            "struct bpf_mem_alloc bpf_global_ma;",
            "bool bpf_global_ma_set;",
            "",
            "/* No hurry in this branch",
            " *",
            " * Exported for the bpf jit load helper.",
            " */",
            "void *bpf_internal_load_pointer_neg_helper(const struct sk_buff *skb, int k, unsigned int size)",
            "{",
            "\tu8 *ptr = NULL;",
            "",
            "\tif (k >= SKF_NET_OFF) {",
            "\t\tptr = skb_network_header(skb) + k - SKF_NET_OFF;",
            "\t} else if (k >= SKF_LL_OFF) {",
            "\t\tif (unlikely(!skb_mac_header_was_set(skb)))",
            "\t\t\treturn NULL;",
            "\t\tptr = skb_mac_header(skb) + k - SKF_LL_OFF;",
            "\t}",
            "\tif (ptr >= skb->head && ptr + size <= skb_tail_pointer(skb))",
            "\t\treturn ptr;",
            "",
            "\treturn NULL;",
            "}",
            "",
            "/* tell bpf programs that include vmlinux.h kernel's PAGE_SIZE */",
            "enum page_size_enum {",
            "\t__PAGE_SIZE = PAGE_SIZE",
            "};",
            "",
            "struct bpf_prog *bpf_prog_alloc_no_stats(unsigned int size, gfp_t gfp_extra_flags)",
            "{",
            "\tgfp_t gfp_flags = bpf_memcg_flags(GFP_KERNEL | __GFP_ZERO | gfp_extra_flags);",
            "\tstruct bpf_prog_aux *aux;",
            "\tstruct bpf_prog *fp;",
            "",
            "\tsize = round_up(size, __PAGE_SIZE);",
            "\tfp = __vmalloc(size, gfp_flags);",
            "\tif (fp == NULL)",
            "\t\treturn NULL;",
            "",
            "\taux = kzalloc(sizeof(*aux), bpf_memcg_flags(GFP_KERNEL | gfp_extra_flags));",
            "\tif (aux == NULL) {",
            "\t\tvfree(fp);",
            "\t\treturn NULL;",
            "\t}",
            "\tfp->active = alloc_percpu_gfp(int, bpf_memcg_flags(GFP_KERNEL | gfp_extra_flags));",
            "\tif (!fp->active) {",
            "\t\tvfree(fp);",
            "\t\tkfree(aux);",
            "\t\treturn NULL;",
            "\t}",
            "",
            "\tfp->pages = size / PAGE_SIZE;",
            "\tfp->aux = aux;",
            "\tfp->aux->prog = fp;",
            "\tfp->jit_requested = ebpf_jit_enabled();",
            "\tfp->blinding_requested = bpf_jit_blinding_enabled(fp);",
            "#ifdef CONFIG_CGROUP_BPF",
            "\taux->cgroup_atype = CGROUP_BPF_ATTACH_TYPE_INVALID;",
            "#endif",
            "",
            "\tINIT_LIST_HEAD_RCU(&fp->aux->ksym.lnode);",
            "#ifdef CONFIG_FINEIBT",
            "\tINIT_LIST_HEAD_RCU(&fp->aux->ksym_prefix.lnode);",
            "#endif",
            "\tmutex_init(&fp->aux->used_maps_mutex);",
            "\tmutex_init(&fp->aux->ext_mutex);",
            "\tmutex_init(&fp->aux->dst_mutex);",
            "",
            "\treturn fp;",
            "}",
            "",
            "struct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags)",
            "{",
            "\tgfp_t gfp_flags = bpf_memcg_flags(GFP_KERNEL | __GFP_ZERO | gfp_extra_flags);",
            "\tstruct bpf_prog *prog;",
            "\tint cpu;",
            "",
            "\tprog = bpf_prog_alloc_no_stats(size, gfp_extra_flags);",
            "\tif (!prog)",
            "\t\treturn NULL;",
            "",
            "\tprog->stats = alloc_percpu_gfp(struct bpf_prog_stats, gfp_flags);",
            "\tif (!prog->stats) {",
            "\t\tfree_percpu(prog->active);",
            "\t\tkfree(prog->aux);",
            "\t\tvfree(prog);",
            "\t\treturn NULL;",
            "\t}",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tstruct bpf_prog_stats *pstats;",
            "",
            "\t\tpstats = per_cpu_ptr(prog->stats, cpu);",
            "\t\tu64_stats_init(&pstats->syncp);",
            "\t}",
            "\treturn prog;",
            "}",
            "EXPORT_SYMBOL_GPL(bpf_prog_alloc);",
            ""
          ],
          "function_name": null,
          "description": "定义BPF核心功能和宏，提供BPF程序分配函数bpf_prog_alloc及其辅助结构初始化，包含内存分配、锁初始化及辅助数据结构设置。",
          "similarity": 0.6277718544006348
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/bpf/core.c",
          "start_line": 2653,
          "end_line": 2756,
          "content": [
            "void bpf_prog_array_delete_safe(struct bpf_prog_array *array,",
            "\t\t\t\tstruct bpf_prog *old_prog)",
            "{",
            "\tstruct bpf_prog_array_item *item;",
            "",
            "\tfor (item = array->items; item->prog; item++)",
            "\t\tif (item->prog == old_prog) {",
            "\t\t\tWRITE_ONCE(item->prog, &dummy_bpf_prog.prog);",
            "\t\t\tbreak;",
            "\t\t}",
            "}",
            "int bpf_prog_array_delete_safe_at(struct bpf_prog_array *array, int index)",
            "{",
            "\treturn bpf_prog_array_update_at(array, index, &dummy_bpf_prog.prog);",
            "}",
            "int bpf_prog_array_update_at(struct bpf_prog_array *array, int index,",
            "\t\t\t     struct bpf_prog *prog)",
            "{",
            "\tstruct bpf_prog_array_item *item;",
            "",
            "\tif (unlikely(index < 0))",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (item = array->items; item->prog; item++) {",
            "\t\tif (item->prog == &dummy_bpf_prog.prog)",
            "\t\t\tcontinue;",
            "\t\tif (!index) {",
            "\t\t\tWRITE_ONCE(item->prog, prog);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tindex--;",
            "\t}",
            "\treturn -ENOENT;",
            "}",
            "int bpf_prog_array_copy(struct bpf_prog_array *old_array,",
            "\t\t\tstruct bpf_prog *exclude_prog,",
            "\t\t\tstruct bpf_prog *include_prog,",
            "\t\t\tu64 bpf_cookie,",
            "\t\t\tstruct bpf_prog_array **new_array)",
            "{",
            "\tint new_prog_cnt, carry_prog_cnt = 0;",
            "\tstruct bpf_prog_array_item *existing, *new;",
            "\tstruct bpf_prog_array *array;",
            "\tbool found_exclude = false;",
            "",
            "\t/* Figure out how many existing progs we need to carry over to",
            "\t * the new array.",
            "\t */",
            "\tif (old_array) {",
            "\t\texisting = old_array->items;",
            "\t\tfor (; existing->prog; existing++) {",
            "\t\t\tif (existing->prog == exclude_prog) {",
            "\t\t\t\tfound_exclude = true;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif (existing->prog != &dummy_bpf_prog.prog)",
            "\t\t\t\tcarry_prog_cnt++;",
            "\t\t\tif (existing->prog == include_prog)",
            "\t\t\t\treturn -EEXIST;",
            "\t\t}",
            "\t}",
            "",
            "\tif (exclude_prog && !found_exclude)",
            "\t\treturn -ENOENT;",
            "",
            "\t/* How many progs (not NULL) will be in the new array? */",
            "\tnew_prog_cnt = carry_prog_cnt;",
            "\tif (include_prog)",
            "\t\tnew_prog_cnt += 1;",
            "",
            "\t/* Do we have any prog (not NULL) in the new array? */",
            "\tif (!new_prog_cnt) {",
            "\t\t*new_array = NULL;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* +1 as the end of prog_array is marked with NULL */",
            "\tarray = bpf_prog_array_alloc(new_prog_cnt + 1, GFP_KERNEL);",
            "\tif (!array)",
            "\t\treturn -ENOMEM;",
            "\tnew = array->items;",
            "",
            "\t/* Fill in the new prog array */",
            "\tif (carry_prog_cnt) {",
            "\t\texisting = old_array->items;",
            "\t\tfor (; existing->prog; existing++) {",
            "\t\t\tif (existing->prog == exclude_prog ||",
            "\t\t\t    existing->prog == &dummy_bpf_prog.prog)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tnew->prog = existing->prog;",
            "\t\t\tnew->bpf_cookie = existing->bpf_cookie;",
            "\t\t\tnew++;",
            "\t\t}",
            "\t}",
            "\tif (include_prog) {",
            "\t\tnew->prog = include_prog;",
            "\t\tnew->bpf_cookie = bpf_cookie;",
            "\t\tnew++;",
            "\t}",
            "\tnew->prog = NULL;",
            "\t*new_array = array;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_prog_array_delete_safe, bpf_prog_array_delete_safe_at, bpf_prog_array_update_at, bpf_prog_array_copy",
          "description": "实现对 BPF 程序数组的安全删除和更新操作，通过遍历数组项查找目标程序并替换为占位程序或直接修改指定索引项，支持数组复制时排除特定程序并保留其他条目",
          "similarity": 0.6193234324455261
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_iter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:58:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_iter.c`\n\n---\n\n# bpf/bpf_iter.c 技术文档\n\n## 1. 文件概述\n\n`bpf_iter.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统的一部分，实现了 **BPF 迭代器（BPF Iterator）** 的核心机制。BPF 迭代器是一种特殊的 BPF 程序类型，允许用户空间通过文件接口（如 `/sys/fs/bpf/` 下的文件）安全、高效地遍历内核中的数据结构（如任务、映射、网络连接等），而无需引入新的系统调用或暴露原始内核指针。\n\n该文件负责：\n- 管理 BPF 迭代器目标（target）的注册与注销\n- 实现自定义的 `seq_file` 读取逻辑（`bpf_seq_read`）\n- 管理迭代器会话的私有数据和生命周期\n- 提供文件操作接口（`file_operations`）供用户空间读取\n\n## 2. 核心功能\n\n### 主要数据结构\n\n| 结构体 | 说明 |\n|--------|------|\n| `struct bpf_iter_target_info` | 表示一个 BPF 迭代器目标的注册信息，包含 `bpf_iter_reg` 和缓存的 BTF ID |\n| `struct bpf_iter_link` | 继承自 `bpf_link`，用于将 BPF 程序与特定迭代器目标关联 |\n| `struct bpf_iter_priv_data` | `seq_file` 的私有数据，包含目标信息、BPF 程序、会话 ID、序列号等状态 |\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `bpf_iter_reg_target()` | 注册一个新的 BPF 迭代器目标类型 |\n| `bpf_iter_unreg_target()` | 注销已注册的 BPF 迭代器目标 |\n| `bpf_iter_prog_supported()` | 检查 BPF 程序是否为有效的迭代器程序（基于函数名前缀和 BTF ID 匹配） |\n| `bpf_seq_read()` | 自定义的 `seq_file` 读取实现，支持 BPF 程序在 `start/next/show/stop` 回调中执行 |\n| `iter_open()` / `iter_release()` | 文件打开/释放回调，初始化和清理迭代器会话 |\n| `bpf_iter_inc_seq_num()` / `bpf_iter_dec_seq_num()` | 管理当前迭代对象的序列号（用于跳过对象时回退） |\n| `bpf_iter_done_stop()` | 标记迭代已正常结束 |\n\n### 全局变量\n\n- `targets`：已注册迭代器目标的链表\n- `session_id`：全局递增的会话 ID，用于区分不同迭代会话\n- `bpf_iter_fops`：提供给 VFS 的文件操作接口\n\n## 3. 关键实现\n\n### BPF 迭代器工作流程\n1. **注册**：内核子系统（如 `task_iter`、`map_iter`）通过 `bpf_iter_reg_target()` 注册其迭代器实现（`bpf_iter_reg`）。\n2. **程序加载**：用户加载 BPF 程序时，若其 `attach_func_name` 以 `bpf_iter_` 开头，则调用 `bpf_iter_prog_supported()` 验证并绑定到对应目标。\n3. **文件打开**：用户打开 BPF 迭代器链接创建的文件时，`iter_open()` 调用 `prepare_seq_file()` 初始化 `seq_file`。\n4. **数据读取**：`bpf_seq_read()` 驱动迭代过程：\n   - 调用 `seq->op->start()` 获取首个对象\n   - 循环调用 `next()` 和 `show()`，其中 `show()` 可能执行 BPF 程序生成输出\n   - 支持在 `show()` 中返回 `>0` 跳过当前对象（通过 `bpf_iter_dec_seq_num()` 回退序列号）\n   - 限制最大迭代对象数（`MAX_ITER_OBJECTS = 1,000,000`）防止无限循环\n   - 支持可抢占目标（`BPF_ITER_RESCHED` 特性）在循环中调用 `cond_resched()`\n5. **结束**：`stop()` 回调被调用，可能再次执行 BPF 程序进行清理。\n\n### 安全与健壮性机制\n- **溢出保护**：检查 `seq_has_overflowed()` 防止缓冲区溢出，返回 `-E2BIG`\n- **对象数量限制**：防止恶意程序导致内核长时间占用 CPU\n- **序列号管理**：精确跟踪当前迭代位置，支持对象跳过\n- **会话隔离**：每个文件打开对应独立的 `session_id` 和私有数据\n\n### BTF ID 缓存优化\n- 首次匹配目标时，将程序的 `attach_btf_id` 缓存到 `tinfo->btf_id`\n- 后续程序可直接通过 BTF ID 快速匹配，避免字符串比较\n\n## 4. 依赖关系\n\n- **BPF 核心**：依赖 `linux/bpf.h`、`bpf_link` 机制和 BPF 程序管理（`bpf_prog_put`）\n- **VFS/seq_file**：基于 `linux/fs.h` 和 `seq_file` 框架实现迭代输出\n- **内存管理**：使用 `kvmalloc` 分配大缓冲区（`PAGE_SIZE << 3`）\n- **RCU/锁机制**：使用 `mutex`（`targets_mutex`, `link_mutex`）保护全局链表\n- **BTF（BPF Type Format）**：通过 `attach_btf_id` 和函数名匹配程序与目标\n- **调度器**：支持可抢占目标时调用 `cond_resched()`\n\n## 5. 使用场景\n\n1. **内核数据遍历**：用户空间安全读取内核内部数据结构，例如：\n   - 遍历所有进程（`bpf_iter_task`）\n   - 遍历 BPF 映射内容（`bpf_iter_map_elem`）\n   - 遍历网络连接（`bpf_iter_tcp`）\n2. **调试与监控**：替代 `/proc` 或 `debugfs` 接口，提供更灵活、可编程的数据导出\n3. **性能分析**：高效收集内核状态快照，避免频繁系统调用开销\n4. **安全审计**：以只读方式检查内核对象，无需暴露原始指针或增加系统调用\n\n> **注**：该文件被截断，实际 `bpf_iter_prog_supported()` 函数未完整显示，但核心逻辑已涵盖。完整实现还需处理 `ctx_arg_info` 等上下文参数配置。",
      "similarity": 0.6739153861999512,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 577,
          "end_line": 699,
          "content": [
            "static void init_seq_meta(struct bpf_iter_priv_data *priv_data,",
            "\t\t\t  struct bpf_iter_target_info *tinfo,",
            "\t\t\t  const struct bpf_iter_seq_info *seq_info,",
            "\t\t\t  struct bpf_prog *prog)",
            "{",
            "\tpriv_data->tinfo = tinfo;",
            "\tpriv_data->seq_info = seq_info;",
            "\tpriv_data->prog = prog;",
            "\tpriv_data->session_id = atomic64_inc_return(&session_id);",
            "\tpriv_data->seq_num = 0;",
            "\tpriv_data->done_stop = false;",
            "}",
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,",
            "\t\t\t    const struct bpf_iter_seq_info *seq_info)",
            "{",
            "\tstruct bpf_iter_priv_data *priv_data;",
            "\tstruct bpf_iter_target_info *tinfo;",
            "\tstruct bpf_prog *prog;",
            "\tu32 total_priv_dsize;",
            "\tstruct seq_file *seq;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&link_mutex);",
            "\tprog = link->link.prog;",
            "\tbpf_prog_inc(prog);",
            "\tmutex_unlock(&link_mutex);",
            "",
            "\ttinfo = link->tinfo;",
            "\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +",
            "\t\t\t   seq_info->seq_priv_size;",
            "\tpriv_data = __seq_open_private(file, seq_info->seq_ops,",
            "\t\t\t\t       total_priv_dsize);",
            "\tif (!priv_data) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto release_prog;",
            "\t}",
            "",
            "\tif (seq_info->init_seq_private) {",
            "\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);",
            "\t\tif (err)",
            "\t\t\tgoto release_seq_file;",
            "\t}",
            "",
            "\tinit_seq_meta(priv_data, tinfo, seq_info, prog);",
            "\tseq = file->private_data;",
            "\tseq->private = priv_data->target_private;",
            "",
            "\treturn 0;",
            "",
            "release_seq_file:",
            "\tseq_release_private(file->f_inode, file);",
            "\tfile->private_data = NULL;",
            "release_prog:",
            "\tbpf_prog_put(prog);",
            "\treturn err;",
            "}",
            "int bpf_iter_new_fd(struct bpf_link *link)",
            "{",
            "\tstruct bpf_iter_link *iter_link;",
            "\tstruct file *file;",
            "\tunsigned int flags;",
            "\tint err, fd;",
            "",
            "\tif (link->ops != &bpf_iter_link_lops)",
            "\t\treturn -EINVAL;",
            "",
            "\tflags = O_RDONLY | O_CLOEXEC;",
            "\tfd = get_unused_fd_flags(flags);",
            "\tif (fd < 0)",
            "\t\treturn fd;",
            "",
            "\tfile = anon_inode_getfile(\"bpf_iter\", &bpf_iter_fops, NULL, flags);",
            "\tif (IS_ERR(file)) {",
            "\t\terr = PTR_ERR(file);",
            "\t\tgoto free_fd;",
            "\t}",
            "",
            "\titer_link = container_of(link, struct bpf_iter_link, link);",
            "\terr = prepare_seq_file(file, iter_link, __get_seq_info(iter_link));",
            "\tif (err)",
            "\t\tgoto free_file;",
            "",
            "\tfd_install(fd, file);",
            "\treturn fd;",
            "",
            "free_file:",
            "\tfput(file);",
            "free_fd:",
            "\tput_unused_fd(fd);",
            "\treturn err;",
            "}",
            "int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)",
            "{",
            "\tstruct bpf_run_ctx run_ctx, *old_run_ctx;",
            "\tint ret;",
            "",
            "\tif (prog->sleepable) {",
            "\t\trcu_read_lock_trace();",
            "\t\tmigrate_disable();",
            "\t\tmight_fault();",
            "\t\told_run_ctx = bpf_set_run_ctx(&run_ctx);",
            "\t\tret = bpf_prog_run(prog, ctx);",
            "\t\tbpf_reset_run_ctx(old_run_ctx);",
            "\t\tmigrate_enable();",
            "\t\trcu_read_unlock_trace();",
            "\t} else {",
            "\t\trcu_read_lock();",
            "\t\tmigrate_disable();",
            "\t\told_run_ctx = bpf_set_run_ctx(&run_ctx);",
            "\t\tret = bpf_prog_run(prog, ctx);",
            "\t\tbpf_reset_run_ctx(old_run_ctx);",
            "\t\tmigrate_enable();",
            "\t\trcu_read_unlock();",
            "\t}",
            "",
            "\t/* bpf program can only return 0 or 1:",
            "\t *  0 : okay",
            "\t *  1 : retry the same object",
            "\t * The bpf_iter_run_prog() return value",
            "\t * will be seq_ops->show() return value.",
            "\t */",
            "\treturn ret == 0 ? 0 : -EAGAIN;",
            "}"
          ],
          "function_name": "init_seq_meta, prepare_seq_file, bpf_iter_new_fd, bpf_iter_run_prog",
          "description": "实现序列文件元数据初始化、迭代器文件创建和BPF程序执行逻辑，通过prepare_seq_file准备序列上下文，bpf_iter_run_prog执行程序并根据返回值控制迭代行为。",
          "similarity": 0.6429876089096069
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 44,
          "end_line": 226,
          "content": [
            "static void bpf_iter_inc_seq_num(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\titer_priv->seq_num++;",
            "}",
            "static void bpf_iter_dec_seq_num(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\titer_priv->seq_num--;",
            "}",
            "static void bpf_iter_done_stop(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\titer_priv->done_stop = true;",
            "}",
            "static inline bool bpf_iter_target_support_resched(const struct bpf_iter_target_info *tinfo)",
            "{",
            "\treturn tinfo->reg_info->feature & BPF_ITER_RESCHED;",
            "}",
            "static bool bpf_iter_support_resched(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\treturn bpf_iter_target_support_resched(iter_priv->tinfo);",
            "}",
            "static ssize_t bpf_seq_read(struct file *file, char __user *buf, size_t size,",
            "\t\t\t    loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tsize_t n, offs, copied = 0;",
            "\tint err = 0, num_objs = 0;",
            "\tbool can_resched;",
            "\tvoid *p;",
            "",
            "\tmutex_lock(&seq->lock);",
            "",
            "\tif (!seq->buf) {",
            "\t\tseq->size = PAGE_SIZE << 3;",
            "\t\tseq->buf = kvmalloc(seq->size, GFP_KERNEL);",
            "\t\tif (!seq->buf) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tgoto done;",
            "\t\t}",
            "\t}",
            "",
            "\tif (seq->count) {",
            "\t\tn = min(seq->count, size);",
            "\t\terr = copy_to_user(buf, seq->buf + seq->from, n);",
            "\t\tif (err) {",
            "\t\t\terr = -EFAULT;",
            "\t\t\tgoto done;",
            "\t\t}",
            "\t\tseq->count -= n;",
            "\t\tseq->from += n;",
            "\t\tcopied = n;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\tseq->from = 0;",
            "\tp = seq->op->start(seq, &seq->index);",
            "\tif (!p)",
            "\t\tgoto stop;",
            "\tif (IS_ERR(p)) {",
            "\t\terr = PTR_ERR(p);",
            "\t\tseq->op->stop(seq, p);",
            "\t\tseq->count = 0;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\terr = seq->op->show(seq, p);",
            "\tif (err > 0) {",
            "\t\t/* object is skipped, decrease seq_num, so next",
            "\t\t * valid object can reuse the same seq_num.",
            "\t\t */",
            "\t\tbpf_iter_dec_seq_num(seq);",
            "\t\tseq->count = 0;",
            "\t} else if (err < 0 || seq_has_overflowed(seq)) {",
            "\t\tif (!err)",
            "\t\t\terr = -E2BIG;",
            "\t\tseq->op->stop(seq, p);",
            "\t\tseq->count = 0;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\tcan_resched = bpf_iter_support_resched(seq);",
            "\twhile (1) {",
            "\t\tloff_t pos = seq->index;",
            "",
            "\t\tnum_objs++;",
            "\t\toffs = seq->count;",
            "\t\tp = seq->op->next(seq, p, &seq->index);",
            "\t\tif (pos == seq->index) {",
            "\t\t\tpr_info_ratelimited(\"buggy seq_file .next function %ps \"",
            "\t\t\t\t\"did not updated position index\\n\",",
            "\t\t\t\tseq->op->next);",
            "\t\t\tseq->index++;",
            "\t\t}",
            "",
            "\t\tif (IS_ERR_OR_NULL(p))",
            "\t\t\tbreak;",
            "",
            "\t\t/* got a valid next object, increase seq_num */",
            "\t\tbpf_iter_inc_seq_num(seq);",
            "",
            "\t\tif (seq->count >= size)",
            "\t\t\tbreak;",
            "",
            "\t\tif (num_objs >= MAX_ITER_OBJECTS) {",
            "\t\t\tif (offs == 0) {",
            "\t\t\t\terr = -EAGAIN;",
            "\t\t\t\tseq->op->stop(seq, p);",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\terr = seq->op->show(seq, p);",
            "\t\tif (err > 0) {",
            "\t\t\tbpf_iter_dec_seq_num(seq);",
            "\t\t\tseq->count = offs;",
            "\t\t} else if (err < 0 || seq_has_overflowed(seq)) {",
            "\t\t\tseq->count = offs;",
            "\t\t\tif (offs == 0) {",
            "\t\t\t\tif (!err)",
            "\t\t\t\t\terr = -E2BIG;",
            "\t\t\t\tseq->op->stop(seq, p);",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (can_resched)",
            "\t\t\tcond_resched();",
            "\t}",
            "stop:",
            "\toffs = seq->count;",
            "\tif (IS_ERR(p)) {",
            "\t\tseq->op->stop(seq, NULL);",
            "\t\terr = PTR_ERR(p);",
            "\t\tgoto done;",
            "\t}",
            "\t/* bpf program called if !p */",
            "\tseq->op->stop(seq, p);",
            "\tif (!p) {",
            "\t\tif (!seq_has_overflowed(seq)) {",
            "\t\t\tbpf_iter_done_stop(seq);",
            "\t\t} else {",
            "\t\t\tseq->count = offs;",
            "\t\t\tif (offs == 0) {",
            "\t\t\t\terr = -E2BIG;",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tn = min(seq->count, size);",
            "\terr = copy_to_user(buf, seq->buf, n);",
            "\tif (err) {",
            "\t\terr = -EFAULT;",
            "\t\tgoto done;",
            "\t}",
            "\tcopied = n;",
            "\tseq->count -= n;",
            "\tseq->from = n;",
            "done:",
            "\tif (!copied)",
            "\t\tcopied = err;",
            "\telse",
            "\t\t*ppos += copied;",
            "\tmutex_unlock(&seq->lock);",
            "\treturn copied;",
            "}"
          ],
          "function_name": "bpf_iter_inc_seq_num, bpf_iter_dec_seq_num, bpf_iter_done_stop, bpf_iter_target_support_resched, bpf_iter_support_resched, bpf_seq_read",
          "description": "实现BPF迭代器的序列文件操作辅助函数，包含计数器增减、支持重新调度判断和seq_read方法，通过维护seq_num和done_stop标志控制迭代流程并处理对象展示。",
          "similarity": 0.592886209487915
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 256,
          "end_line": 360,
          "content": [
            "static int iter_open(struct inode *inode, struct file *file)",
            "{",
            "\tstruct bpf_iter_link *link = inode->i_private;",
            "",
            "\treturn prepare_seq_file(file, link, __get_seq_info(link));",
            "}",
            "static int iter_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "\tstruct seq_file *seq;",
            "",
            "\tseq = file->private_data;",
            "\tif (!seq)",
            "\t\treturn 0;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "",
            "\tif (iter_priv->seq_info->fini_seq_private)",
            "\t\titer_priv->seq_info->fini_seq_private(seq->private);",
            "",
            "\tbpf_prog_put(iter_priv->prog);",
            "\tseq->private = iter_priv;",
            "",
            "\treturn seq_release_private(inode, file);",
            "}",
            "int bpf_iter_reg_target(const struct bpf_iter_reg *reg_info)",
            "{",
            "\tstruct bpf_iter_target_info *tinfo;",
            "",
            "\ttinfo = kzalloc(sizeof(*tinfo), GFP_KERNEL);",
            "\tif (!tinfo)",
            "\t\treturn -ENOMEM;",
            "",
            "\ttinfo->reg_info = reg_info;",
            "\tINIT_LIST_HEAD(&tinfo->list);",
            "",
            "\tmutex_lock(&targets_mutex);",
            "\tlist_add(&tinfo->list, &targets);",
            "\tmutex_unlock(&targets_mutex);",
            "",
            "\treturn 0;",
            "}",
            "void bpf_iter_unreg_target(const struct bpf_iter_reg *reg_info)",
            "{",
            "\tstruct bpf_iter_target_info *tinfo;",
            "\tbool found = false;",
            "",
            "\tmutex_lock(&targets_mutex);",
            "\tlist_for_each_entry(tinfo, &targets, list) {",
            "\t\tif (reg_info == tinfo->reg_info) {",
            "\t\t\tlist_del(&tinfo->list);",
            "\t\t\tkfree(tinfo);",
            "\t\t\tfound = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&targets_mutex);",
            "",
            "\tWARN_ON(found == false);",
            "}",
            "static void cache_btf_id(struct bpf_iter_target_info *tinfo,",
            "\t\t\t struct bpf_prog *prog)",
            "{",
            "\ttinfo->btf_id = prog->aux->attach_btf_id;",
            "}",
            "int bpf_iter_prog_supported(struct bpf_prog *prog)",
            "{",
            "\tconst char *attach_fname = prog->aux->attach_func_name;",
            "\tstruct bpf_iter_target_info *tinfo = NULL, *iter;",
            "\tu32 prog_btf_id = prog->aux->attach_btf_id;",
            "\tconst char *prefix = BPF_ITER_FUNC_PREFIX;",
            "\tint prefix_len = strlen(prefix);",
            "",
            "\tif (strncmp(attach_fname, prefix, prefix_len))",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&targets_mutex);",
            "\tlist_for_each_entry(iter, &targets, list) {",
            "\t\tif (iter->btf_id && iter->btf_id == prog_btf_id) {",
            "\t\t\ttinfo = iter;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (!strcmp(attach_fname + prefix_len, iter->reg_info->target)) {",
            "\t\t\tcache_btf_id(iter, prog);",
            "\t\t\ttinfo = iter;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&targets_mutex);",
            "",
            "\tif (!tinfo)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn bpf_prog_ctx_arg_info_init(prog, tinfo->reg_info->ctx_arg_info,",
            "\t\t\t\t\t  tinfo->reg_info->ctx_arg_info_size);",
            "}",
            "static void bpf_iter_link_release(struct bpf_link *link)",
            "{",
            "\tstruct bpf_iter_link *iter_link =",
            "\t\tcontainer_of(link, struct bpf_iter_link, link);",
            "",
            "\tif (iter_link->tinfo->reg_info->detach_target)",
            "\t\titer_link->tinfo->reg_info->detach_target(&iter_link->aux);",
            "}"
          ],
          "function_name": "iter_open, iter_release, bpf_iter_reg_target, bpf_iter_unreg_target, cache_btf_id, bpf_iter_prog_supported, bpf_iter_link_release",
          "description": "提供BPF迭代器目标注册/注销接口，实现BTF ID缓存、程序兼容性校验及链接释放逻辑，用于管理迭代器目标信息和清理资源。",
          "similarity": 0.5883893966674805
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 786,
          "end_line": 821,
          "content": [
            "__bpf_kfunc int bpf_iter_num_new(struct bpf_iter_num *it, int start, int end)",
            "{",
            "\tstruct bpf_iter_num_kern *s = (void *)it;",
            "",
            "\tBUILD_BUG_ON(sizeof(struct bpf_iter_num_kern) != sizeof(struct bpf_iter_num));",
            "\tBUILD_BUG_ON(__alignof__(struct bpf_iter_num_kern) != __alignof__(struct bpf_iter_num));",
            "",
            "\t/* start == end is legit, it's an empty range and we'll just get NULL",
            "\t * on first (and any subsequent) bpf_iter_num_next() call",
            "\t */",
            "\tif (start > end) {",
            "\t\ts->cur = s->end = 0;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* avoid overflows, e.g., if start == INT_MIN and end == INT_MAX */",
            "\tif ((s64)end - (s64)start > BPF_MAX_LOOPS) {",
            "\t\ts->cur = s->end = 0;",
            "\t\treturn -E2BIG;",
            "\t}",
            "",
            "\t/* user will call bpf_iter_num_next() first,",
            "\t * which will set s->cur to exactly start value;",
            "\t * underflow shouldn't matter",
            "\t */",
            "\ts->cur = start - 1;",
            "\ts->end = end;",
            "",
            "\treturn 0;",
            "}",
            "__bpf_kfunc void bpf_iter_num_destroy(struct bpf_iter_num *it)",
            "{",
            "\tstruct bpf_iter_num_kern *s = (void *)it;",
            "",
            "\ts->cur = s->end = 0;",
            "}"
          ],
          "function_name": "bpf_iter_num_new, bpf_iter_num_destroy",
          "description": "该代码段实现了BPF数值范围迭代器的创建与销毁功能。`bpf_iter_num_new`用于初始化一个指定起始/终止值的迭代器对象并进行边界检查，`bpf_iter_num_destroy`负责清空迭代器状态。因上下文不完整，未展示迭代器实际遍历逻辑及配套API。",
          "similarity": 0.569574236869812
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2020 Facebook */",
            "",
            "#include <linux/fs.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/rcupdate_trace.h>",
            "",
            "struct bpf_iter_target_info {",
            "\tstruct list_head list;",
            "\tconst struct bpf_iter_reg *reg_info;",
            "\tu32 btf_id;\t/* cached value */",
            "};",
            "",
            "struct bpf_iter_link {",
            "\tstruct bpf_link link;",
            "\tstruct bpf_iter_aux_info aux;",
            "\tstruct bpf_iter_target_info *tinfo;",
            "};",
            "",
            "struct bpf_iter_priv_data {",
            "\tstruct bpf_iter_target_info *tinfo;",
            "\tconst struct bpf_iter_seq_info *seq_info;",
            "\tstruct bpf_prog *prog;",
            "\tu64 session_id;",
            "\tu64 seq_num;",
            "\tbool done_stop;",
            "\tu8 target_private[] __aligned(8);",
            "};",
            "",
            "static struct list_head targets = LIST_HEAD_INIT(targets);",
            "static DEFINE_MUTEX(targets_mutex);",
            "",
            "/* protect bpf_iter_link changes */",
            "static DEFINE_MUTEX(link_mutex);",
            "",
            "/* incremented on every opened seq_file */",
            "static atomic64_t session_id;",
            "",
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,",
            "\t\t\t    const struct bpf_iter_seq_info *seq_info);",
            ""
          ],
          "function_name": null,
          "description": "声明BPF迭代器相关结构体及全局变量，定义用于管理迭代器目标信息、链接和私有数据的结构体，并初始化保护目标列表的互斥锁和会话ID原子变量。",
          "similarity": 0.5502610206604004
        }
      ]
    },
    {
      "source_file": "kernel/bpf/mprog.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:20:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\mprog.c`\n\n---\n\n# bpf/mprog.c 技术文档\n\n## 1. 文件概述\n\n`bpf/mprog.c` 是 Linux 内核中用于管理 **BPF 多程序（multi-program）挂载点** 的核心实现文件。该文件提供了一套机制，允许在同一个挂载点上按顺序组织多个 BPF 程序（或通过 BPF link 关联的程序），并支持在运行时对这些程序进行 **插入、替换、删除** 等原子操作。此机制主要用于支持 **BPF 程序链（program chains）**，例如在 tc（traffic control）、XDP 或 cgroup 等子系统中实现多个 BPF 程序的有序执行。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct bpf_tuple`：封装一个 BPF 程序及其关联的 link（可选），用于统一表示待操作的目标程序。\n- `struct bpf_mprog_entry`：表示一个多程序挂载点的当前状态，包含程序数组、引用计数、版本号等。\n- `struct bpf_mprog_fp` / `struct bpf_mprog_cp`：分别表示程序的“快路径”（fast path）和“控制路径”（control path）数据，用于 RCU 安全的读写分离。\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `bpf_mprog_link()` | 从 ID 或 FD 解析 BPF link，并验证程序类型 |\n| `bpf_mprog_prog()` | 从 ID 或 FD 解析 BPF program，并验证程序类型 |\n| `bpf_mprog_tuple_relative()` | 根据 flags（如 `BPF_F_ID`, `BPF_F_LINK`）统一解析用户传入的 `id_or_fd` 为 `bpf_tuple` |\n| `bpf_mprog_tuple_put()` | 释放 `bpf_tuple` 中持有的 program 或 link 引用 |\n| `bpf_mprog_replace()` | 在指定索引位置替换现有程序 |\n| `bpf_mprog_insert()` | 在指定位置（支持 `BPF_F_BEFORE` / `BPF_F_AFTER`）插入新程序 |\n| `bpf_mprog_delete()` | 删除指定位置的程序（支持首尾删除：`idx = -1` 或 `idx = total`） |\n| `bpf_mprog_pos_exact()` | 查找与给定 tuple 完全匹配的程序位置 |\n| `bpf_mprog_pos_before()` / `bpf_mprog_pos_after()` | 根据相对位置语义计算插入/删除目标索引 |\n| `bpf_mprog_attach()` | **核心入口函数**：根据用户 flags 执行 attach、replace 或 insert 操作 |\n| `bpf_mprog_fetch()` | （未完整实现）用于获取指定索引处的程序信息 |\n\n## 3. 关键实现\n\n### 3.1 程序与 Link 的统一抽象（`bpf_tuple`）\n通过 `bpf_tuple` 结构，将直接使用 BPF program FD/ID 与通过 BPF link 引用程序两种方式统一处理。`BPF_F_LINK` 标志决定是否从 link 解析，`BPF_F_ID` 决定输入是 ID 还是 FD。\n\n### 3.2 RCU 安全的多程序管理\n- 使用 `bpf_mprog_entry` 的 peer 机制实现 **写时复制（Copy-on-Write）**：\n  - 修改操作（insert/replace/delete）先复制当前 entry 到 peer\n  - 在 peer 上修改，最后原子切换指针\n  - 旧 entry 通过 RCU 回收，确保并发读安全\n- `bpf_mprog_read()` / `bpf_mprog_write()` 封装了对 `fp`（fast path）和 `cp`（control path）的访问\n\n### 3.3 相对位置语义支持\n- `BPF_F_BEFORE` / `BPF_F_AFTER` 允许用户指定相对于某个已有程序的位置\n- `bpf_mprog_pos_before()` / `bpf_mprog_pos_after()` 遍历当前程序列表，查找参考程序位置并返回目标索引\n- 特殊情况：当 `id_or_fd = 0` 且无 flags 时，表示在末尾插入（`idx = total`）\n\n### 3.4 原子性与一致性保障\n- `revision` 参数用于防止并发修改冲突（类似乐观锁）\n- `bpf_mprog_exists()` 检查避免重复添加同一程序\n- 所有修改操作最终通过 `*entry_new` 返回新 entry，由调用者负责发布\n\n### 3.5 边界处理\n- 插入到末尾：`idx == total`\n- 删除首元素：`idx = -1` → 转换为 `0`\n- 删除尾元素：`idx = total` → 转换为 `total - 1`\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/bpf.h>`：BPF 核心定义（`bpf_prog`, `bpf_link` 等）\n  - `<linux/bpf_mprog.h>`：多程序管理相关 API 和数据结构声明\n- **内核子系统依赖**：\n  - BPF 核心子系统（程序/链接生命周期管理）\n  - RCU 机制（用于无锁读取）\n  - 内存管理（`kmalloc`/`kfree` 用于 entry 复制）\n- **被调用方**：\n  - BPF 系统调用处理函数（如 `bpf(BPF_PROG_ATTACH, ...)` 的多程序扩展）\n  - 网络子系统（如 tc BPF 多程序支持）\n\n## 5. 使用场景\n\n1. **tc BPF 多程序链**：在同一个网络 qdisc 上挂载多个 BPF 程序，按顺序执行分类/过滤/修改操作\n2. **cgroup BPF 程序链**：在 cgroup 层级上组合多个安全或资源控制策略\n3. **动态策略更新**：运行时替换某个中间策略程序，而不中断整个链的执行\n4. **模块化 BPF 应用**：将复杂逻辑拆分为多个小程序，通过 attach 顺序组合\n5. **调试与热补丁**：临时插入诊断程序或替换有缺陷的程序版本\n\n该机制为 BPF 提供了类似“插件链”或“中间件栈”的能力，增强了 BPF 程序的组合性和动态管理能力。",
      "similarity": 0.6628118753433228,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 1,
          "end_line": 6,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2023 Isovalent */",
            "",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_mprog.h>",
            ""
          ],
          "function_name": null,
          "description": "声明GPL许可证并包含BPF相关头文件，为后续多程序模块实现提供基础",
          "similarity": 0.6158579587936401
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 7,
          "end_line": 116,
          "content": [
            "static int bpf_mprog_link(struct bpf_tuple *tuple,",
            "\t\t\t  u32 id_or_fd, u32 flags,",
            "\t\t\t  enum bpf_prog_type type)",
            "{",
            "\tstruct bpf_link *link = ERR_PTR(-EINVAL);",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tif (id)",
            "\t\tlink = bpf_link_by_id(id_or_fd);",
            "\telse if (id_or_fd)",
            "\t\tlink = bpf_link_get_from_fd(id_or_fd);",
            "\tif (IS_ERR(link))",
            "\t\treturn PTR_ERR(link);",
            "\tif (type && link->prog->type != type) {",
            "\t\tbpf_link_put(link);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttuple->link = link;",
            "\ttuple->prog = link->prog;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_prog(struct bpf_tuple *tuple,",
            "\t\t\t  u32 id_or_fd, u32 flags,",
            "\t\t\t  enum bpf_prog_type type)",
            "{",
            "\tstruct bpf_prog *prog = ERR_PTR(-EINVAL);",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tif (id)",
            "\t\tprog = bpf_prog_by_id(id_or_fd);",
            "\telse if (id_or_fd)",
            "\t\tprog = bpf_prog_get(id_or_fd);",
            "\tif (IS_ERR(prog))",
            "\t\treturn PTR_ERR(prog);",
            "\tif (type && prog->type != type) {",
            "\t\tbpf_prog_put(prog);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttuple->link = NULL;",
            "\ttuple->prog = prog;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_tuple_relative(struct bpf_tuple *tuple,",
            "\t\t\t\t    u32 id_or_fd, u32 flags,",
            "\t\t\t\t    enum bpf_prog_type type)",
            "{",
            "\tbool link = flags & BPF_F_LINK;",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tmemset(tuple, 0, sizeof(*tuple));",
            "\tif (link)",
            "\t\treturn bpf_mprog_link(tuple, id_or_fd, flags, type);",
            "\t/* If no relevant flag is set and no id_or_fd was passed, then",
            "\t * tuple link/prog is just NULLed. This is the case when before/",
            "\t * after selects first/last position without passing fd.",
            "\t */",
            "\tif (!id && !id_or_fd)",
            "\t\treturn 0;",
            "\treturn bpf_mprog_prog(tuple, id_or_fd, flags, type);",
            "}",
            "static void bpf_mprog_tuple_put(struct bpf_tuple *tuple)",
            "{",
            "\tif (tuple->link)",
            "\t\tbpf_link_put(tuple->link);",
            "\telse if (tuple->prog)",
            "\t\tbpf_prog_put(tuple->prog);",
            "}",
            "static int bpf_mprog_replace(struct bpf_mprog_entry *entry,",
            "\t\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t\t     struct bpf_tuple *ntuple, int idx)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_prog *oprog;",
            "",
            "\tbpf_mprog_read(entry, idx, &fp, &cp);",
            "\toprog = READ_ONCE(fp->prog);",
            "\tbpf_mprog_write(fp, cp, ntuple);",
            "\tif (!ntuple->link) {",
            "\t\tWARN_ON_ONCE(cp->link);",
            "\t\tbpf_prog_put(oprog);",
            "\t}",
            "\t*entry_new = entry;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_insert(struct bpf_mprog_entry *entry,",
            "\t\t\t    struct bpf_mprog_entry **entry_new,",
            "\t\t\t    struct bpf_tuple *ntuple, int idx, u32 flags)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_entry *peer;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "",
            "\tpeer = bpf_mprog_peer(entry);",
            "\tbpf_mprog_entry_copy(peer, entry);",
            "\tif (idx == total)",
            "\t\tgoto insert;",
            "\telse if (flags & BPF_F_BEFORE)",
            "\t\tidx += 1;",
            "\tbpf_mprog_entry_grow(peer, idx);",
            "insert:",
            "\tbpf_mprog_read(peer, idx, &fp, &cp);",
            "\tbpf_mprog_write(fp, cp, ntuple);",
            "\tbpf_mprog_inc(peer);",
            "\t*entry_new = peer;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_mprog_link, bpf_mprog_prog, bpf_mprog_tuple_relative, bpf_mprog_tuple_put, bpf_mprog_replace, bpf_mprog_insert",
          "description": "实现多程序链接与程序绑定逻辑，通过不同标志位选择性设置tuple中的link或prog字段，进行类型校验和引用计数管理",
          "similarity": 0.4976288378238678
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 151,
          "end_line": 284,
          "content": [
            "static int bpf_mprog_delete(struct bpf_mprog_entry *entry,",
            "\t\t\t    struct bpf_mprog_entry **entry_new,",
            "\t\t\t    struct bpf_tuple *dtuple, int idx)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_entry *peer;",
            "",
            "\tpeer = bpf_mprog_peer(entry);",
            "\tbpf_mprog_entry_copy(peer, entry);",
            "\tif (idx == -1)",
            "\t\tidx = 0;",
            "\telse if (idx == total)",
            "\t\tidx = total - 1;",
            "\tbpf_mprog_entry_shrink(peer, idx);",
            "\tbpf_mprog_dec(peer);",
            "\tbpf_mprog_mark_for_release(peer, dtuple);",
            "\t*entry_new = peer;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_pos_exact(struct bpf_mprog_entry *entry,",
            "\t\t\t       struct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog))",
            "\t\t\treturn tuple->link == cp->link ? i : -EBUSY;",
            "\t}",
            "\treturn -ENOENT;",
            "}",
            "static int bpf_mprog_pos_before(struct bpf_mprog_entry *entry,",
            "\t\t\t\tstruct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog) &&",
            "\t\t    (!tuple->link || tuple->link == cp->link))",
            "\t\t\treturn i - 1;",
            "\t}",
            "\treturn tuple->prog ? -ENOENT : -1;",
            "}",
            "static int bpf_mprog_pos_after(struct bpf_mprog_entry *entry,",
            "\t\t\t       struct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog) &&",
            "\t\t    (!tuple->link || tuple->link == cp->link))",
            "\t\t\treturn i + 1;",
            "\t}",
            "\treturn tuple->prog ? -ENOENT : bpf_mprog_total(entry);",
            "}",
            "int bpf_mprog_attach(struct bpf_mprog_entry *entry,",
            "\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t     struct bpf_prog *prog_new, struct bpf_link *link,",
            "\t\t     struct bpf_prog *prog_old,",
            "\t\t     u32 flags, u32 id_or_fd, u64 revision)",
            "{",
            "\tstruct bpf_tuple rtuple, ntuple = {",
            "\t\t.prog = prog_new,",
            "\t\t.link = link,",
            "\t}, otuple = {",
            "\t\t.prog = prog_old,",
            "\t\t.link = link,",
            "\t};",
            "\tint ret, idx = -ERANGE, tidx;",
            "",
            "\tif (revision && revision != bpf_mprog_revision(entry))",
            "\t\treturn -ESTALE;",
            "\tif (bpf_mprog_exists(entry, prog_new))",
            "\t\treturn -EEXIST;",
            "\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd,",
            "\t\t\t\t       flags & ~BPF_F_REPLACE,",
            "\t\t\t\t       prog_new->type);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (flags & BPF_F_REPLACE) {",
            "\t\ttidx = bpf_mprog_pos_exact(entry, &otuple);",
            "\t\tif (tidx < 0) {",
            "\t\t\tret = tidx;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t} else if (bpf_mprog_total(entry) == bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tif (flags & BPF_F_BEFORE) {",
            "\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < -1 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_AFTER) {",
            "\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < 0 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (idx < -1) {",
            "\t\tif (rtuple.prog || flags) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = bpf_mprog_total(entry);",
            "\t\tflags = BPF_F_AFTER;",
            "\t}",
            "\tif (idx >= bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tif (flags & BPF_F_REPLACE)",
            "\t\tret = bpf_mprog_replace(entry, entry_new, &ntuple, idx);",
            "\telse",
            "\t\tret = bpf_mprog_insert(entry, entry_new, &ntuple, idx, flags);",
            "out:",
            "\tbpf_mprog_tuple_put(&rtuple);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_mprog_delete, bpf_mprog_pos_exact, bpf_mprog_pos_before, bpf_mprog_pos_after, bpf_mprog_attach",
          "description": "实现多程序条目删除、精确匹配位置查找、前后位置确定等功能，支持基于程序和链接的条件匹配与索引计算",
          "similarity": 0.47330737113952637
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 297,
          "end_line": 450,
          "content": [
            "static int bpf_mprog_fetch(struct bpf_mprog_entry *entry,",
            "\t\t\t   struct bpf_tuple *tuple, int idx)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_prog *prog;",
            "\tstruct bpf_link *link;",
            "",
            "\tif (idx == -1)",
            "\t\tidx = 0;",
            "\telse if (idx == total)",
            "\t\tidx = total - 1;",
            "\tbpf_mprog_read(entry, idx, &fp, &cp);",
            "\tprog = READ_ONCE(fp->prog);",
            "\tlink = cp->link;",
            "\t/* The deletion request can either be without filled tuple in which",
            "\t * case it gets populated here based on idx, or with filled tuple",
            "\t * where the only thing we end up doing is the WARN_ON_ONCE() assert.",
            "\t * If we hit a BPF link at the given index, it must not be removed",
            "\t * from opts path.",
            "\t */",
            "\tif (link && !tuple->link)",
            "\t\treturn -EBUSY;",
            "\tWARN_ON_ONCE(tuple->prog && tuple->prog != prog);",
            "\tWARN_ON_ONCE(tuple->link && tuple->link != link);",
            "\ttuple->prog = prog;",
            "\ttuple->link = link;",
            "\treturn 0;",
            "}",
            "int bpf_mprog_detach(struct bpf_mprog_entry *entry,",
            "\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t     struct bpf_prog *prog, struct bpf_link *link,",
            "\t\t     u32 flags, u32 id_or_fd, u64 revision)",
            "{",
            "\tstruct bpf_tuple rtuple, dtuple = {",
            "\t\t.prog = prog,",
            "\t\t.link = link,",
            "\t};",
            "\tint ret, idx = -ERANGE, tidx;",
            "",
            "\tif (flags & BPF_F_REPLACE)",
            "\t\treturn -EINVAL;",
            "\tif (revision && revision != bpf_mprog_revision(entry))",
            "\t\treturn -ESTALE;",
            "\tif (!bpf_mprog_total(entry))",
            "\t\treturn -ENOENT;",
            "\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd, flags,",
            "\t\t\t\t       prog ? prog->type :",
            "\t\t\t\t       BPF_PROG_TYPE_UNSPEC);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (dtuple.prog) {",
            "\t\ttidx = bpf_mprog_pos_exact(entry, &dtuple);",
            "\t\tif (tidx < 0) {",
            "\t\t\tret = tidx;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_BEFORE) {",
            "\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < -1 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_AFTER) {",
            "\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < 0 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (idx < -1) {",
            "\t\tif (rtuple.prog || flags) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = bpf_mprog_total(entry);",
            "\t\tflags = BPF_F_AFTER;",
            "\t}",
            "\tif (idx >= bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tret = bpf_mprog_fetch(entry, &dtuple, idx);",
            "\tif (ret)",
            "\t\tgoto out;",
            "\tret = bpf_mprog_delete(entry, entry_new, &dtuple, idx);",
            "out:",
            "\tbpf_mprog_tuple_put(&rtuple);",
            "\treturn ret;",
            "}",
            "int bpf_mprog_query(const union bpf_attr *attr, union bpf_attr __user *uattr,",
            "\t\t    struct bpf_mprog_entry *entry)",
            "{",
            "\tu32 __user *uprog_flags, *ulink_flags;",
            "\tu32 __user *uprog_id, *ulink_id;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_prog *prog;",
            "\tconst u32 flags = 0;",
            "\tu32 id, count = 0;",
            "\tu64 revision = 1;",
            "\tint i, ret = 0;",
            "",
            "\tif (attr->query.query_flags || attr->query.attach_flags)",
            "\t\treturn -EINVAL;",
            "\tif (entry) {",
            "\t\trevision = bpf_mprog_revision(entry);",
            "\t\tcount = bpf_mprog_total(entry);",
            "\t}",
            "\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))",
            "\t\treturn -EFAULT;",
            "\tif (copy_to_user(&uattr->query.revision, &revision, sizeof(revision)))",
            "\t\treturn -EFAULT;",
            "\tif (copy_to_user(&uattr->query.count, &count, sizeof(count)))",
            "\t\treturn -EFAULT;",
            "\tuprog_id = u64_to_user_ptr(attr->query.prog_ids);",
            "\tuprog_flags = u64_to_user_ptr(attr->query.prog_attach_flags);",
            "\tulink_id = u64_to_user_ptr(attr->query.link_ids);",
            "\tulink_flags = u64_to_user_ptr(attr->query.link_attach_flags);",
            "\tif (attr->query.count == 0 || !uprog_id || !count)",
            "\t\treturn 0;",
            "\tif (attr->query.count < count) {",
            "\t\tcount = attr->query.count;",
            "\t\tret = -ENOSPC;",
            "\t}",
            "\tfor (i = 0; i < bpf_mprog_max(); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tprog = READ_ONCE(fp->prog);",
            "\t\tif (!prog)",
            "\t\t\tbreak;",
            "\t\tid = prog->aux->id;",
            "\t\tif (copy_to_user(uprog_id + i, &id, sizeof(id)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (uprog_flags &&",
            "\t\t    copy_to_user(uprog_flags + i, &flags, sizeof(flags)))",
            "\t\t\treturn -EFAULT;",
            "\t\tid = cp->link ? cp->link->id : 0;",
            "\t\tif (ulink_id &&",
            "\t\t    copy_to_user(ulink_id + i, &id, sizeof(id)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (ulink_flags &&",
            "\t\t    copy_to_user(ulink_flags + i, &flags, sizeof(flags)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (i + 1 == count)",
            "\t\t\tbreak;",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_mprog_fetch, bpf_mprog_detach, bpf_mprog_query",
          "description": "实现多程序条目查询接口，支持根据索引获取运行时状态、执行删除操作，并向用户空间导出程序ID和链接ID等元信息",
          "similarity": 0.44270163774490356
        }
      ]
    }
  ]
}