{
  "query": "死锁避免方法中安全序列检测代码",
  "timestamp": "2025-12-26 01:08:32",
  "retrieved_files": [
    {
      "source_file": "kernel/locking/locktorture.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:40:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\locktorture.c`\n\n---\n\n# `locking/locktorture.c` 技术文档\n\n## 1. 文件概述\n\n`locking/locktorture.c` 是 Linux 内核中的一个模块化压力测试（torture test）设施，用于对各种内核锁机制（如 spinlock、mutex、rwsem、rtmutex 等）进行高强度并发压力测试，以验证其正确性、健壮性和性能。该模块通过创建多个读/写线程，在高竞争、长持有、CPU 热插拔、优先级提升等极端场景下持续操作锁，检测潜在的死锁、竞态条件、内存泄漏或锁实现缺陷。\n\n该文件基于 RCU torture 测试框架（`kernel/rcu/torture.c`）构建，支持多种锁类型，并可通过内核模块参数灵活配置测试行为。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct lock_torture_ops`**  \n  锁操作抽象接口，定义了针对特定锁类型的初始化、加锁、解锁、延迟、RT 优先级提升等回调函数，支持不同锁机制的统一测试框架。\n  \n- **`struct lock_torture_cxt`**  \n  全局测试上下文，包含当前使用的锁操作集（`cur_ops`）、读者/写者线程数量、错误计数器、统计信息等。\n\n- **`struct lock_stress_stats`**  \n  用于记录每个线程的锁获取成功/失败次数，用于性能和正确性分析。\n\n- **`torture_param` 宏定义的模块参数**  \n  提供丰富的运行时配置选项，如线程数量、长持有时间、CPU 热插拔间隔、RT 优先级提升策略等。\n\n### 主要函数\n\n- **锁操作实现函数**（按锁类型分类）：\n  - `torture_spin_lock_write_lock()` / `torture_spin_lock_write_unlock()`：普通 spinlock 加/解锁。\n  - `torture_spin_lock_write_lock_irq()` / `torture_lock_spin_write_unlock_irq()`：带中断保存/恢复的 spinlock。\n  - `torture_lock_busted_*`：故意错误的“损坏”锁实现，用于验证测试框架能否检测异常行为。\n  - （代码片段未完整展示 mutex、rwsem、rtmutex 等实现，但框架支持）\n\n- **辅助函数**：\n  - `torture_lock_busted_write_delay()` / `torture_spin_lock_write_delay()`：模拟真实场景中的锁持有延迟，包括短延迟（微秒级）和偶尔的长延迟（毫秒级），以制造高竞争。\n  - `__torture_rt_boost()` / `torture_rt_boost()`：周期性将写线程提升为实时 FIFO 优先级，测试优先级继承（PI）和 RT 锁行为。\n  - `lock_torture_cleanup()`：测试结束时的资源清理（前向声明）。\n\n- **全局变量**：\n  - `writer_tasks` / `reader_tasks`：指向写/读测试线程的 `task_struct` 指针数组。\n  - `lock_is_write_held` / `lock_is_read_held`：用于检测锁状态一致性（如是否允许多个写者同时持有）。\n  - `last_lock_release`：记录上次释放锁的时间戳。\n\n## 3. 关键实现\n\n### 锁类型抽象与扩展\n通过 `lock_torture_ops` 结构体实现策略模式，不同锁类型只需实现对应的回调函数即可接入测试框架。当前支持：\n- `spin_lock`\n- `spin_lock_irq`\n- （完整代码中还包括 `mutex_lock`, `rwsem`, `rtmutex`, `raw_spin_lock` 等）\n\n默认锁类型根据 `CONFIG_PREEMPT_RT` 配置自动选择：RT 内核使用 `raw_spin_lock`，否则使用 `spin_lock`。\n\n### 高强度压力生成\n- **长持有延迟**：通过 `long_hold` 参数控制，偶尔让线程持有锁达数十至数百毫秒，极大增加竞争概率。\n- **随机延迟与抢占**：在锁持有期间插入随机微秒级延迟，并调用 `torture_preempt_schedule()` 主动触发抢占，测试锁在抢占式内核下的行为。\n- **嵌套锁支持**：通过 `nested_locks` 参数（最大 8 层）测试锁的嵌套使用，避免触发 lockdep 的 `MAX_LOCKDEP_CHAIN_HLOCKS` 限制。\n\n### 实时（RT）行为测试\n- **RT 优先级提升**：`rt_boost` 参数控制是否周期性将写线程设为 `SCHED_FIFO` 实时优先级。\n  - 模式 1：仅对 `rtmutex` 生效\n  - 模式 2：对所有锁类型生效\n- **PI（优先级继承）压力**：通过频繁提升/恢复优先级，触发 RT 锁的 PI 机制，验证其正确性。\n\n### 动态环境模拟\n- **CPU 热插拔**：通过 `onoff_holdoff` 和 `onoff_interval` 参数，在测试过程中动态上线/下线 CPU，检验锁在 CPU 拓扑变化时的稳定性。\n- **测试启停控制**：`stutter` 参数控制测试周期性暂停/恢复，模拟负载波动。\n\n### 错误检测机制\n- 使用 `atomic_t n_lock_torture_errors` 全局计数器记录检测到的错误（如违反锁互斥性）。\n- 通过 `lock_is_write_held` 和 `atomic_t lock_is_read_held` 检测写锁是否被多个线程同时持有，或读写锁状态不一致。\n\n## 4. 依赖关系\n\n- **内核核心组件**：\n  - `<linux/spinlock.h>`、`<linux/mutex.h>`、`<linux/rwsem.h>`、`<linux/rtmutex.h>`：提供被测试的锁原语。\n  - `<linux/kthread.h>`、`<linux/sched.h>`：用于创建和管理测试线程。\n  - `<linux/torture.h>`：提供通用 torture 测试框架（如随机数生成、线程控制、参数解析等）。\n  - `<linux/atomic.h>`、`<linux/delay.h>`：用于同步和延迟操作。\n- **配置依赖**：\n  - `CONFIG_PREEMPT_RT`：影响默认锁类型选择。\n  - `CONFIG_LOCKDEP`：嵌套锁深度受其 `MAX_LOCKDEP_CHAIN_HLOCKS` 限制。\n- **模块参数系统**：通过 `module_param` 和 `torture_param` 宏集成内核模块参数机制。\n\n## 5. 使用场景\n\n- **内核开发与测试**：\n  - 在开发新的锁实现或修改现有锁机制时，运行此模块进行回归测试。\n  - 在合并关键锁相关补丁前，通过长时间 torture 测试验证稳定性。\n- **实时系统验证**：\n  - 在 PREEMPT_RT 补丁集开发中，重点测试 `rtmutex` 和优先级继承行为。\n  - 验证系统在高优先级线程竞争锁时的响应性和正确性。\n- **硬件/平台压力测试**：\n  - 在新硬件平台或 NUMA 系统上运行，检测锁在复杂拓扑下的可扩展性和正确性。\n  - 结合 CPU 热插拔测试，验证锁在动态 CPU 环境下的鲁棒性。\n- **故障复现与调试**：\n  - 当怀疑存在锁相关的死锁或竞态条件时，通过配置特定参数（如高 `long_hold`、高线程数）复现问题。\n  - 利用 `verbose` 参数输出详细日志辅助调试。",
      "similarity": 0.5647048950195312,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/locking/locktorture.c",
          "start_line": 427,
          "end_line": 534,
          "content": [
            "static void torture_mutex_init(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < MAX_NESTED_LOCKS; i++)",
            "\t\t__mutex_init(&torture_nested_mutexes[i], __func__,",
            "\t\t\t     &nested_mutex_keys[i]);",
            "}",
            "static int torture_mutex_nested_lock(int tid __maybe_unused,",
            "\t\t\t\t     u32 lockset)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < nested_locks; i++)",
            "\t\tif (lockset & (1 << i))",
            "\t\t\tmutex_lock(&torture_nested_mutexes[i]);",
            "\treturn 0;",
            "}",
            "static int torture_mutex_lock(int tid __maybe_unused)",
            "__acquires(torture_mutex)",
            "{",
            "\tmutex_lock(&torture_mutex);",
            "\treturn 0;",
            "}",
            "static void torture_mutex_delay(struct torture_random_state *trsp)",
            "{",
            "\tconst unsigned long longdelay_ms = long_hold ? long_hold : ULONG_MAX;",
            "",
            "\t/* We want a long delay occasionally to force massive contention.  */",
            "\tif (!(torture_random(trsp) %",
            "\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))",
            "\t\tmdelay(longdelay_ms * 5);",
            "\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))",
            "\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */",
            "}",
            "static void torture_mutex_unlock(int tid __maybe_unused)",
            "__releases(torture_mutex)",
            "{",
            "\tmutex_unlock(&torture_mutex);",
            "}",
            "static void torture_mutex_nested_unlock(int tid __maybe_unused,",
            "\t\t\t\t\tu32 lockset)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nested_locks - 1; i >= 0; i--)",
            "\t\tif (lockset & (1 << i))",
            "\t\t\tmutex_unlock(&torture_nested_mutexes[i]);",
            "}",
            "static void torture_ww_mutex_init(void)",
            "{",
            "\tww_mutex_init(&torture_ww_mutex_0, &torture_ww_class);",
            "\tww_mutex_init(&torture_ww_mutex_1, &torture_ww_class);",
            "\tww_mutex_init(&torture_ww_mutex_2, &torture_ww_class);",
            "",
            "\tww_acquire_ctxs = kmalloc_array(cxt.nrealwriters_stress,",
            "\t\t\t\t\tsizeof(*ww_acquire_ctxs),",
            "\t\t\t\t\tGFP_KERNEL);",
            "\tif (!ww_acquire_ctxs)",
            "\t\tVERBOSE_TOROUT_STRING(\"ww_acquire_ctx: Out of memory\");",
            "}",
            "static void torture_ww_mutex_exit(void)",
            "{",
            "\tkfree(ww_acquire_ctxs);",
            "}",
            "static int torture_ww_mutex_lock(int tid)",
            "__acquires(torture_ww_mutex_0)",
            "__acquires(torture_ww_mutex_1)",
            "__acquires(torture_ww_mutex_2)",
            "{",
            "\tLIST_HEAD(list);",
            "\tstruct reorder_lock {",
            "\t\tstruct list_head link;",
            "\t\tstruct ww_mutex *lock;",
            "\t} locks[3], *ll, *ln;",
            "\tstruct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];",
            "",
            "\tlocks[0].lock = &torture_ww_mutex_0;",
            "\tlist_add(&locks[0].link, &list);",
            "",
            "\tlocks[1].lock = &torture_ww_mutex_1;",
            "\tlist_add(&locks[1].link, &list);",
            "",
            "\tlocks[2].lock = &torture_ww_mutex_2;",
            "\tlist_add(&locks[2].link, &list);",
            "",
            "\tww_acquire_init(ctx, &torture_ww_class);",
            "",
            "\tlist_for_each_entry(ll, &list, link) {",
            "\t\tint err;",
            "",
            "\t\terr = ww_mutex_lock(ll->lock, ctx);",
            "\t\tif (!err)",
            "\t\t\tcontinue;",
            "",
            "\t\tln = ll;",
            "\t\tlist_for_each_entry_continue_reverse(ln, &list, link)",
            "\t\t\tww_mutex_unlock(ln->lock);",
            "",
            "\t\tif (err != -EDEADLK)",
            "\t\t\treturn err;",
            "",
            "\t\tww_mutex_lock_slow(ll->lock, ctx);",
            "\t\tlist_move(&ll->link, &list);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "torture_mutex_init, torture_mutex_nested_lock, torture_mutex_lock, torture_mutex_delay, torture_mutex_unlock, torture_mutex_nested_unlock, torture_ww_mutex_init, torture_ww_mutex_exit, torture_ww_mutex_lock",
          "description": "实现互斥锁（mutex）及其扩展版本（ww_mutex）的测试逻辑，包含嵌套锁操作、初始化函数及死锁检测机制，用于验证复杂锁嵌套场景下的正确性。",
          "similarity": 0.5892341732978821
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/locktorture.c",
          "start_line": 112,
          "end_line": 212,
          "content": [
            "static int torture_lock_busted_write_lock(int tid __maybe_unused)",
            "{",
            "\treturn 0;  /* BUGGY, do not use in real life!!! */",
            "}",
            "static void torture_lock_busted_write_delay(struct torture_random_state *trsp)",
            "{",
            "\tconst unsigned long longdelay_ms = long_hold ? long_hold : ULONG_MAX;",
            "",
            "\t/* We want a long delay occasionally to force massive contention.  */",
            "\tif (!(torture_random(trsp) %",
            "\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))",
            "\t\tmdelay(longdelay_ms);",
            "\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))",
            "\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */",
            "}",
            "static void torture_lock_busted_write_unlock(int tid __maybe_unused)",
            "{",
            "\t  /* BUGGY, do not use in real life!!! */",
            "}",
            "static void __torture_rt_boost(struct torture_random_state *trsp)",
            "{",
            "\tconst unsigned int factor = rt_boost_factor;",
            "",
            "\tif (!rt_task(current)) {",
            "\t\t/*",
            "\t\t * Boost priority once every rt_boost_factor operations. When",
            "\t\t * the task tries to take the lock, the rtmutex it will account",
            "\t\t * for the new priority, and do any corresponding pi-dance.",
            "\t\t */",
            "\t\tif (trsp && !(torture_random(trsp) %",
            "\t\t\t      (cxt.nrealwriters_stress * factor))) {",
            "\t\t\tsched_set_fifo(current);",
            "\t\t} else /* common case, do nothing */",
            "\t\t\treturn;",
            "\t} else {",
            "\t\t/*",
            "\t\t * The task will remain boosted for another 10 * rt_boost_factor",
            "\t\t * operations, then restored back to its original prio, and so",
            "\t\t * forth.",
            "\t\t *",
            "\t\t * When @trsp is nil, we want to force-reset the task for",
            "\t\t * stopping the kthread.",
            "\t\t */",
            "\t\tif (!trsp || !(torture_random(trsp) %",
            "\t\t\t       (cxt.nrealwriters_stress * factor * 2))) {",
            "\t\t\tsched_set_normal(current, 0);",
            "\t\t} else /* common case, do nothing */",
            "\t\t\treturn;",
            "\t}",
            "}",
            "static void torture_rt_boost(struct torture_random_state *trsp)",
            "{",
            "\tif (rt_boost != 2)",
            "\t\treturn;",
            "",
            "\t__torture_rt_boost(trsp);",
            "}",
            "static int torture_spin_lock_write_lock(int tid __maybe_unused)",
            "__acquires(torture_spinlock)",
            "{",
            "\tspin_lock(&torture_spinlock);",
            "\treturn 0;",
            "}",
            "static void torture_spin_lock_write_delay(struct torture_random_state *trsp)",
            "{",
            "\tconst unsigned long shortdelay_us = 2;",
            "\tconst unsigned long longdelay_ms = long_hold ? long_hold : ULONG_MAX;",
            "\tunsigned long j;",
            "",
            "\t/* We want a short delay mostly to emulate likely code, and",
            "\t * we want a long delay occasionally to force massive contention.",
            "\t */",
            "\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * longdelay_ms))) {",
            "\t\tj = jiffies;",
            "\t\tmdelay(longdelay_ms);",
            "\t\tpr_alert(\"%s: delay = %lu jiffies.\\n\", __func__, jiffies - j);",
            "\t}",
            "\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 200 * shortdelay_us)))",
            "\t\tudelay(shortdelay_us);",
            "\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))",
            "\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */",
            "}",
            "static void torture_spin_lock_write_unlock(int tid __maybe_unused)",
            "__releases(torture_spinlock)",
            "{",
            "\tspin_unlock(&torture_spinlock);",
            "}",
            "static int torture_spin_lock_write_lock_irq(int tid __maybe_unused)",
            "__acquires(torture_spinlock)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&torture_spinlock, flags);",
            "\tcxt.cur_ops->flags = flags;",
            "\treturn 0;",
            "}",
            "static void torture_lock_spin_write_unlock_irq(int tid __maybe_unused)",
            "__releases(torture_spinlock)",
            "{",
            "\tspin_unlock_irqrestore(&torture_spinlock, cxt.cur_ops->flags);",
            "}"
          ],
          "function_name": "torture_lock_busted_write_lock, torture_lock_busted_write_delay, torture_lock_busted_write_unlock, __torture_rt_boost, torture_rt_boost, torture_spin_lock_write_lock, torture_spin_lock_write_delay, torture_spin_lock_write_unlock, torture_spin_lock_write_lock_irq, torture_lock_spin_write_unlock_irq",
          "description": "实现针对自旋锁的测试函数，包含锁获取、延迟操作、中断屏蔽版本的锁操作，以及实时优先级调整逻辑，用于模拟不同场景下的锁竞争与抢占行为。",
          "similarity": 0.5488812327384949
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/locktorture.c",
          "start_line": 260,
          "end_line": 362,
          "content": [
            "static int torture_raw_spin_lock_write_lock(int tid __maybe_unused)",
            "__acquires(torture_raw_spinlock)",
            "{",
            "\traw_spin_lock(&torture_raw_spinlock);",
            "\treturn 0;",
            "}",
            "static void torture_raw_spin_lock_write_unlock(int tid __maybe_unused)",
            "__releases(torture_raw_spinlock)",
            "{",
            "\traw_spin_unlock(&torture_raw_spinlock);",
            "}",
            "static int torture_raw_spin_lock_write_lock_irq(int tid __maybe_unused)",
            "__acquires(torture_raw_spinlock)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&torture_raw_spinlock, flags);",
            "\tcxt.cur_ops->flags = flags;",
            "\treturn 0;",
            "}",
            "static void torture_raw_spin_lock_write_unlock_irq(int tid __maybe_unused)",
            "__releases(torture_raw_spinlock)",
            "{",
            "\traw_spin_unlock_irqrestore(&torture_raw_spinlock, cxt.cur_ops->flags);",
            "}",
            "static int torture_rwlock_write_lock(int tid __maybe_unused)",
            "__acquires(torture_rwlock)",
            "{",
            "\twrite_lock(&torture_rwlock);",
            "\treturn 0;",
            "}",
            "static void torture_rwlock_write_delay(struct torture_random_state *trsp)",
            "{",
            "\tconst unsigned long shortdelay_us = 2;",
            "\tconst unsigned long longdelay_ms = long_hold ? long_hold : ULONG_MAX;",
            "",
            "\t/* We want a short delay mostly to emulate likely code, and",
            "\t * we want a long delay occasionally to force massive contention.",
            "\t */",
            "\tif (!(torture_random(trsp) %",
            "\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))",
            "\t\tmdelay(longdelay_ms);",
            "\telse",
            "\t\tudelay(shortdelay_us);",
            "}",
            "static void torture_rwlock_write_unlock(int tid __maybe_unused)",
            "__releases(torture_rwlock)",
            "{",
            "\twrite_unlock(&torture_rwlock);",
            "}",
            "static int torture_rwlock_read_lock(int tid __maybe_unused)",
            "__acquires(torture_rwlock)",
            "{",
            "\tread_lock(&torture_rwlock);",
            "\treturn 0;",
            "}",
            "static void torture_rwlock_read_delay(struct torture_random_state *trsp)",
            "{",
            "\tconst unsigned long shortdelay_us = 10;",
            "\tconst unsigned long longdelay_ms = 100;",
            "",
            "\t/* We want a short delay mostly to emulate likely code, and",
            "\t * we want a long delay occasionally to force massive contention.",
            "\t */",
            "\tif (!(torture_random(trsp) %",
            "\t      (cxt.nrealreaders_stress * 2000 * longdelay_ms)))",
            "\t\tmdelay(longdelay_ms);",
            "\telse",
            "\t\tudelay(shortdelay_us);",
            "}",
            "static void torture_rwlock_read_unlock(int tid __maybe_unused)",
            "__releases(torture_rwlock)",
            "{",
            "\tread_unlock(&torture_rwlock);",
            "}",
            "static int torture_rwlock_write_lock_irq(int tid __maybe_unused)",
            "__acquires(torture_rwlock)",
            "{",
            "\tunsigned long flags;",
            "",
            "\twrite_lock_irqsave(&torture_rwlock, flags);",
            "\tcxt.cur_ops->flags = flags;",
            "\treturn 0;",
            "}",
            "static void torture_rwlock_write_unlock_irq(int tid __maybe_unused)",
            "__releases(torture_rwlock)",
            "{",
            "\twrite_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);",
            "}",
            "static int torture_rwlock_read_lock_irq(int tid __maybe_unused)",
            "__acquires(torture_rwlock)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tread_lock_irqsave(&torture_rwlock, flags);",
            "\tcxt.cur_ops->flags = flags;",
            "\treturn 0;",
            "}",
            "static void torture_rwlock_read_unlock_irq(int tid __maybe_unused)",
            "__releases(torture_rwlock)",
            "{",
            "\tread_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);",
            "}"
          ],
          "function_name": "torture_raw_spin_lock_write_lock, torture_raw_spin_lock_write_unlock, torture_raw_spin_lock_write_lock_irq, torture_raw_spin_lock_write_unlock_irq, torture_rwlock_write_lock, torture_rwlock_write_delay, torture_rwlock_write_unlock, torture_rwlock_read_lock, torture_rwlock_read_delay, torture_rwlock_read_unlock, torture_rwlock_write_lock_irq, torture_rwlock_write_unlock_irq, torture_rwlock_read_lock_irq, torture_rwlock_read_unlock_irq",
          "description": "提供读写锁（rwlock）的测试函数，涵盖写锁获取、读锁获取、延迟操作及中断保护版本，支持对读写锁的并发访问压力测试。",
          "similarity": 0.5331804752349854
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/locking/locktorture.c",
          "start_line": 568,
          "end_line": 670,
          "content": [
            "static void torture_ww_mutex_unlock(int tid)",
            "__releases(torture_ww_mutex_0)",
            "__releases(torture_ww_mutex_1)",
            "__releases(torture_ww_mutex_2)",
            "{",
            "\tstruct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];",
            "",
            "\tww_mutex_unlock(&torture_ww_mutex_0);",
            "\tww_mutex_unlock(&torture_ww_mutex_1);",
            "\tww_mutex_unlock(&torture_ww_mutex_2);",
            "\tww_acquire_fini(ctx);",
            "}",
            "static void torture_rtmutex_init(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < MAX_NESTED_LOCKS; i++)",
            "\t\t__rt_mutex_init(&torture_nested_rtmutexes[i], __func__,",
            "\t\t\t\t&nested_rtmutex_keys[i]);",
            "}",
            "static int torture_rtmutex_nested_lock(int tid __maybe_unused,",
            "\t\t\t\t       u32 lockset)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < nested_locks; i++)",
            "\t\tif (lockset & (1 << i))",
            "\t\t\trt_mutex_lock(&torture_nested_rtmutexes[i]);",
            "\treturn 0;",
            "}",
            "static int torture_rtmutex_lock(int tid __maybe_unused)",
            "__acquires(torture_rtmutex)",
            "{",
            "\trt_mutex_lock(&torture_rtmutex);",
            "\treturn 0;",
            "}",
            "static void torture_rtmutex_delay(struct torture_random_state *trsp)",
            "{",
            "\tconst unsigned long shortdelay_us = 2;",
            "\tconst unsigned long longdelay_ms = long_hold ? long_hold : ULONG_MAX;",
            "",
            "\t/*",
            "\t * We want a short delay mostly to emulate likely code, and",
            "\t * we want a long delay occasionally to force massive contention.",
            "\t */",
            "\tif (!(torture_random(trsp) %",
            "\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))",
            "\t\tmdelay(longdelay_ms);",
            "\tif (!(torture_random(trsp) %",
            "\t      (cxt.nrealwriters_stress * 200 * shortdelay_us)))",
            "\t\tudelay(shortdelay_us);",
            "\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))",
            "\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */",
            "}",
            "static void torture_rtmutex_unlock(int tid __maybe_unused)",
            "__releases(torture_rtmutex)",
            "{",
            "\trt_mutex_unlock(&torture_rtmutex);",
            "}",
            "static void torture_rt_boost_rtmutex(struct torture_random_state *trsp)",
            "{",
            "\tif (!rt_boost)",
            "\t\treturn;",
            "",
            "\t__torture_rt_boost(trsp);",
            "}",
            "static void torture_rtmutex_nested_unlock(int tid __maybe_unused,",
            "\t\t\t\t\t  u32 lockset)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nested_locks - 1; i >= 0; i--)",
            "\t\tif (lockset & (1 << i))",
            "\t\t\trt_mutex_unlock(&torture_nested_rtmutexes[i]);",
            "}",
            "static int torture_rwsem_down_write(int tid __maybe_unused)",
            "__acquires(torture_rwsem)",
            "{",
            "\tdown_write(&torture_rwsem);",
            "\treturn 0;",
            "}",
            "static void torture_rwsem_write_delay(struct torture_random_state *trsp)",
            "{",
            "\tconst unsigned long longdelay_ms = long_hold ? long_hold : ULONG_MAX;",
            "",
            "\t/* We want a long delay occasionally to force massive contention.  */",
            "\tif (!(torture_random(trsp) %",
            "\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))",
            "\t\tmdelay(longdelay_ms * 10);",
            "\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))",
            "\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */",
            "}",
            "static void torture_rwsem_up_write(int tid __maybe_unused)",
            "__releases(torture_rwsem)",
            "{",
            "\tup_write(&torture_rwsem);",
            "}",
            "static int torture_rwsem_down_read(int tid __maybe_unused)",
            "__acquires(torture_rwsem)",
            "{",
            "\tdown_read(&torture_rwsem);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "torture_ww_mutex_unlock, torture_rtmutex_init, torture_rtmutex_nested_lock, torture_rtmutex_lock, torture_rtmutex_delay, torture_rtmutex_unlock, torture_rt_boost_rtmutex, torture_rtmutex_nested_unlock, torture_rwsem_down_write, torture_rwsem_write_delay, torture_rwsem_up_write, torture_rwsem_down_read",
          "description": "涵盖实时互斥锁（rtmutex）和读写信号量（rwsem）的测试函数，包含锁操作、延迟注入、优先级调整及资源竞争模拟，用于评估锁机制在实时系统中的表现。",
          "similarity": 0.5253868103027344
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/locking/locktorture.c",
          "start_line": 1001,
          "end_line": 1279,
          "content": [
            "static void lock_torture_cleanup(void)",
            "{",
            "\tint i;",
            "",
            "\tif (torture_cleanup_begin())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Indicates early cleanup, meaning that the test has not run,",
            "\t * such as when passing bogus args when loading the module.",
            "\t * However cxt->cur_ops.init() may have been invoked, so beside",
            "\t * perform the underlying torture-specific cleanups, cur_ops.exit()",
            "\t * will be invoked if needed.",
            "\t */",
            "\tif (!cxt.lwsa && !cxt.lrsa)",
            "\t\tgoto end;",
            "",
            "\tif (writer_tasks) {",
            "\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++)",
            "\t\t\ttorture_stop_kthread(lock_torture_writer, writer_tasks[i]);",
            "\t\tkfree(writer_tasks);",
            "\t\twriter_tasks = NULL;",
            "\t}",
            "",
            "\tif (reader_tasks) {",
            "\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)",
            "\t\t\ttorture_stop_kthread(lock_torture_reader,",
            "\t\t\t\t\t     reader_tasks[i]);",
            "\t\tkfree(reader_tasks);",
            "\t\treader_tasks = NULL;",
            "\t}",
            "",
            "\ttorture_stop_kthread(lock_torture_stats, stats_task);",
            "\tlock_torture_stats_print();  /* -After- the stats thread is stopped! */",
            "",
            "\tif (atomic_read(&cxt.n_lock_torture_errors))",
            "\t\tlock_torture_print_module_parms(cxt.cur_ops,",
            "\t\t\t\t\t\t\"End of test: FAILURE\");",
            "\telse if (torture_onoff_failures())",
            "\t\tlock_torture_print_module_parms(cxt.cur_ops,",
            "\t\t\t\t\t\t\"End of test: LOCK_HOTPLUG\");",
            "\telse",
            "\t\tlock_torture_print_module_parms(cxt.cur_ops,",
            "\t\t\t\t\t\t\"End of test: SUCCESS\");",
            "",
            "\tkfree(cxt.lwsa);",
            "\tcxt.lwsa = NULL;",
            "\tkfree(cxt.lrsa);",
            "\tcxt.lrsa = NULL;",
            "",
            "end:",
            "\tif (cxt.init_called) {",
            "\t\tif (cxt.cur_ops->exit)",
            "\t\t\tcxt.cur_ops->exit();",
            "\t\tcxt.init_called = false;",
            "\t}",
            "\ttorture_cleanup_end();",
            "}",
            "static int __init lock_torture_init(void)",
            "{",
            "\tint i, j;",
            "\tint firsterr = 0;",
            "\tstatic struct lock_torture_ops *torture_ops[] = {",
            "\t\t&lock_busted_ops,",
            "\t\t&spin_lock_ops, &spin_lock_irq_ops,",
            "\t\t&raw_spin_lock_ops, &raw_spin_lock_irq_ops,",
            "\t\t&rw_lock_ops, &rw_lock_irq_ops,",
            "\t\t&mutex_lock_ops,",
            "\t\t&ww_mutex_lock_ops,",
            "#ifdef CONFIG_RT_MUTEXES",
            "\t\t&rtmutex_lock_ops,",
            "#endif",
            "\t\t&rwsem_lock_ops,",
            "\t\t&percpu_rwsem_lock_ops,",
            "\t};",
            "",
            "\tif (!torture_init_begin(torture_type, verbose))",
            "\t\treturn -EBUSY;",
            "",
            "\t/* Process args and tell the world that the torturer is on the job. */",
            "\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {",
            "\t\tcxt.cur_ops = torture_ops[i];",
            "\t\tif (strcmp(torture_type, cxt.cur_ops->name) == 0)",
            "\t\t\tbreak;",
            "\t}",
            "\tif (i == ARRAY_SIZE(torture_ops)) {",
            "\t\tpr_alert(\"lock-torture: invalid torture type: \\\"%s\\\"\\n\",",
            "\t\t\t torture_type);",
            "\t\tpr_alert(\"lock-torture types:\");",
            "\t\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)",
            "\t\t\tpr_alert(\" %s\", torture_ops[i]->name);",
            "\t\tpr_alert(\"\\n\");",
            "\t\tfirsterr = -EINVAL;",
            "\t\tgoto unwind;",
            "\t}",
            "",
            "\tif (nwriters_stress == 0 &&",
            "\t    (!cxt.cur_ops->readlock || nreaders_stress == 0)) {",
            "\t\tpr_alert(\"lock-torture: must run at least one locking thread\\n\");",
            "\t\tfirsterr = -EINVAL;",
            "\t\tgoto unwind;",
            "\t}",
            "",
            "\tif (nwriters_stress >= 0)",
            "\t\tcxt.nrealwriters_stress = nwriters_stress;",
            "\telse",
            "\t\tcxt.nrealwriters_stress = 2 * num_online_cpus();",
            "",
            "\tif (cxt.cur_ops->init) {",
            "\t\tcxt.cur_ops->init();",
            "\t\tcxt.init_called = true;",
            "\t}",
            "",
            "#ifdef CONFIG_DEBUG_MUTEXES",
            "\tif (str_has_prefix(torture_type, \"mutex\"))",
            "\t\tcxt.debug_lock = true;",
            "#endif",
            "#ifdef CONFIG_DEBUG_RT_MUTEXES",
            "\tif (str_has_prefix(torture_type, \"rtmutex\"))",
            "\t\tcxt.debug_lock = true;",
            "#endif",
            "#ifdef CONFIG_DEBUG_SPINLOCK",
            "\tif ((str_has_prefix(torture_type, \"spin\")) ||",
            "\t    (str_has_prefix(torture_type, \"rw_lock\")))",
            "\t\tcxt.debug_lock = true;",
            "#endif",
            "",
            "\t/* Initialize the statistics so that each run gets its own numbers. */",
            "\tif (nwriters_stress) {",
            "\t\tlock_is_write_held = false;",
            "\t\tcxt.lwsa = kmalloc_array(cxt.nrealwriters_stress,",
            "\t\t\t\t\t sizeof(*cxt.lwsa),",
            "\t\t\t\t\t GFP_KERNEL);",
            "\t\tif (cxt.lwsa == NULL) {",
            "\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lwsa: Out of memory\");",
            "\t\t\tfirsterr = -ENOMEM;",
            "\t\t\tgoto unwind;",
            "\t\t}",
            "",
            "\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++) {",
            "\t\t\tcxt.lwsa[i].n_lock_fail = 0;",
            "\t\t\tcxt.lwsa[i].n_lock_acquired = 0;",
            "\t\t}",
            "\t}",
            "",
            "\tif (cxt.cur_ops->readlock) {",
            "\t\tif (nreaders_stress >= 0)",
            "\t\t\tcxt.nrealreaders_stress = nreaders_stress;",
            "\t\telse {",
            "\t\t\t/*",
            "\t\t\t * By default distribute evenly the number of",
            "\t\t\t * readers and writers. We still run the same number",
            "\t\t\t * of threads as the writer-only locks default.",
            "\t\t\t */",
            "\t\t\tif (nwriters_stress < 0) /* user doesn't care */",
            "\t\t\t\tcxt.nrealwriters_stress = num_online_cpus();",
            "\t\t\tcxt.nrealreaders_stress = cxt.nrealwriters_stress;",
            "\t\t}",
            "",
            "\t\tif (nreaders_stress) {",
            "\t\t\tcxt.lrsa = kmalloc_array(cxt.nrealreaders_stress,",
            "\t\t\t\t\t\t sizeof(*cxt.lrsa),",
            "\t\t\t\t\t\t GFP_KERNEL);",
            "\t\t\tif (cxt.lrsa == NULL) {",
            "\t\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lrsa: Out of memory\");",
            "\t\t\t\tfirsterr = -ENOMEM;",
            "\t\t\t\tkfree(cxt.lwsa);",
            "\t\t\t\tcxt.lwsa = NULL;",
            "\t\t\t\tgoto unwind;",
            "\t\t\t}",
            "",
            "\t\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++) {",
            "\t\t\t\tcxt.lrsa[i].n_lock_fail = 0;",
            "\t\t\t\tcxt.lrsa[i].n_lock_acquired = 0;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tlock_torture_print_module_parms(cxt.cur_ops, \"Start of test\");",
            "",
            "\t/* Prepare torture context. */",
            "\tif (onoff_interval > 0) {",
            "\t\tfirsterr = torture_onoff_init(onoff_holdoff * HZ,",
            "\t\t\t\t\t      onoff_interval * HZ, NULL);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "\tif (shuffle_interval > 0) {",
            "\t\tfirsterr = torture_shuffle_init(shuffle_interval);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "\tif (shutdown_secs > 0) {",
            "\t\tfirsterr = torture_shutdown_init(shutdown_secs,",
            "\t\t\t\t\t\t lock_torture_cleanup);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "\tif (stutter > 0) {",
            "\t\tfirsterr = torture_stutter_init(stutter, stutter);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "",
            "\tif (nwriters_stress) {",
            "\t\twriter_tasks = kcalloc(cxt.nrealwriters_stress,",
            "\t\t\t\t       sizeof(writer_tasks[0]),",
            "\t\t\t\t       GFP_KERNEL);",
            "\t\tif (writer_tasks == NULL) {",
            "\t\t\tTOROUT_ERRSTRING(\"writer_tasks: Out of memory\");",
            "\t\t\tfirsterr = -ENOMEM;",
            "\t\t\tgoto unwind;",
            "\t\t}",
            "\t}",
            "",
            "\t/* cap nested_locks to MAX_NESTED_LOCKS */",
            "\tif (nested_locks > MAX_NESTED_LOCKS)",
            "\t\tnested_locks = MAX_NESTED_LOCKS;",
            "",
            "\tif (cxt.cur_ops->readlock) {",
            "\t\treader_tasks = kcalloc(cxt.nrealreaders_stress,",
            "\t\t\t\t       sizeof(reader_tasks[0]),",
            "\t\t\t\t       GFP_KERNEL);",
            "\t\tif (reader_tasks == NULL) {",
            "\t\t\tTOROUT_ERRSTRING(\"reader_tasks: Out of memory\");",
            "\t\t\tkfree(writer_tasks);",
            "\t\t\twriter_tasks = NULL;",
            "\t\t\tfirsterr = -ENOMEM;",
            "\t\t\tgoto unwind;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Create the kthreads and start torturing (oh, those poor little locks).",
            "\t *",
            "\t * TODO: Note that we interleave writers with readers, giving writers a",
            "\t * slight advantage, by creating its kthread first. This can be modified",
            "\t * for very specific needs, or even let the user choose the policy, if",
            "\t * ever wanted.",
            "\t */",
            "\tfor (i = 0, j = 0; i < cxt.nrealwriters_stress ||",
            "\t\t    j < cxt.nrealreaders_stress; i++, j++) {",
            "\t\tif (i >= cxt.nrealwriters_stress)",
            "\t\t\tgoto create_reader;",
            "",
            "\t\t/* Create writer. */",
            "\t\tfirsterr = torture_create_kthread_cb(lock_torture_writer, &cxt.lwsa[i],",
            "\t\t\t\t\t\t     writer_tasks[i],",
            "\t\t\t\t\t\t     writer_fifo ? sched_set_fifo : NULL);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "",
            "\tcreate_reader:",
            "\t\tif (cxt.cur_ops->readlock == NULL || (j >= cxt.nrealreaders_stress))",
            "\t\t\tcontinue;",
            "\t\t/* Create reader. */",
            "\t\tfirsterr = torture_create_kthread(lock_torture_reader, &cxt.lrsa[j],",
            "\t\t\t\t\t\t  reader_tasks[j]);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "\tif (stat_interval > 0) {",
            "\t\tfirsterr = torture_create_kthread(lock_torture_stats, NULL,",
            "\t\t\t\t\t\t  stats_task);",
            "\t\tif (torture_init_error(firsterr))",
            "\t\t\tgoto unwind;",
            "\t}",
            "\ttorture_init_end();",
            "\treturn 0;",
            "",
            "unwind:",
            "\ttorture_init_end();",
            "\tlock_torture_cleanup();",
            "\tif (shutdown_secs) {",
            "\t\tWARN_ON(!IS_MODULE(CONFIG_LOCK_TORTURE_TEST));",
            "\t\tkernel_power_off();",
            "\t}",
            "\treturn firsterr;",
            "}"
          ],
          "function_name": "lock_torture_cleanup, lock_torture_init",
          "description": "lock_torture_cleanup负责安全终止所有测试线程、释放内存资源并输出最终测试状态；lock_torture_init实现模块加载时的初始化流程，包括参数解析、线程创建、内存分配、锁类型适配器初始化，以及与系统其他组件（如电源管理、任务调度）的交互设置。",
          "similarity": 0.5178723335266113
        }
      ]
    },
    {
      "source_file": "kernel/locking/lockdep.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:37:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\lockdep.c`\n\n---\n\n# `locking/lockdep.c` 技术文档\n\n## 1. 文件概述\n\n`lockdep.c` 是 Linux 内核中 **运行时锁依赖验证器（Lock Dependency Validator）** 的核心实现文件。该模块用于在内核运行期间动态追踪所有锁的获取顺序和依赖关系，旨在提前检测潜在的死锁风险和锁使用错误，即使当前执行路径并未实际触发死锁。其主要目标是发现以下三类并发编程错误：\n\n- **锁顺序反转（Lock Inversion）**：两个任务以相反顺序获取同一组锁。\n- **循环锁依赖（Circular Lock Dependencies）**：形成 A→B→C→A 的依赖环。\n- **中断上下文锁安全违规**：在硬中断（hardirq）或软中断（softirq）上下文中不安全地使用锁（如在中断禁用区域持有非 IRQ-safe 锁）。\n\n该机制由 Ingo Molnar 和 Peter Zijlstra 设计实现，基于 Arjan van de Ven 提出的运行时锁依赖映射思想。\n\n## 2. 核心功能\n\n### 主要全局变量与数据结构\n- `lockdep_recursion`（per-CPU）：递归计数器，防止 lockdep 自身递归调用。\n- `__lock`：原始自旋锁（`arch_spinlock_t`），保护 lockdep 内部全局数据结构。\n- `lock_classes[]`：存储所有已识别的锁类（`struct lock_class`），最大数量由 `MAX_LOCKDEP_KEYS` 限定。\n- `list_entries[]`：存储锁依赖边（`struct lock_list`），用于构建依赖图。\n- `lock_keys_hash[]`：哈希表，用于快速查找锁类。\n- `cpu_lock_stats`（per-CPU，仅当 `CONFIG_LOCK_STAT` 启用）：锁性能统计信息。\n\n### 关键函数\n- `lockdep_enabled()`：判断当前是否启用 lockdep 验证。\n- `lockdep_lock()` / `lockdep_unlock()`：获取/释放 lockdep 内部保护锁。\n- `graph_lock()` / `graph_unlock()`：安全地获取 lockdep 依赖图锁。\n- `hlock_class()`：根据 `held_lock` 获取对应的 `lock_class`。\n- `lock_stats()` / `clear_lock_stats()`（仅当 `CONFIG_LOCK_STAT` 启用）：聚合/清除锁统计信息。\n\n### 配置参数（可通过 sysfs 或 module_param 调整）\n- `prove_locking`（`CONFIG_PROVE_LOCKING`）：启用/禁用锁正确性验证。\n- `lock_stat`（`CONFIG_LOCK_STAT`）：启用/禁用锁性能统计。\n\n## 3. 关键实现\n\n### 锁依赖图构建\n- 每个锁实例在首次使用时被归类到一个 **锁类（lock class）**，相同类型的锁（如多个 `struct mutex` 实例）共享同一类。\n- 每次成功获取锁时，lockdep 记录当前任务持有的锁栈，并为新锁与栈中每个已有锁建立 **依赖边（A → B 表示先持 A 再持 B）**。\n- 所有依赖边存储在 `list_entries[]` 中，通过位图 `list_entries_in_use` 管理分配。\n\n### 死锁检测算法\n- 使用 **深度优先搜索（DFS）** 遍历依赖图，检测是否存在从新锁指向当前锁栈中某锁的反向路径（即环）。\n- 支持跨任务、跨时间的依赖检查：只要历史上存在过相反的锁序，即报告潜在死锁。\n\n### 中断上下文安全检查\n- 跟踪每个锁类在不同上下文（进程、softirq、hardirq）中的使用情况。\n- 若某锁在中断上下文中被持有，但未标记为 IRQ-safe，则在进程上下文获取该锁时会触发警告。\n\n### 递归防护机制\n- 通过 per-CPU 变量 `lockdep_recursion` 和任务结构中的 `lockdep_recursion` 字段，防止 lockdep 自身在验证过程中因嵌套锁操作而递归崩溃。\n- 内部保护锁 `__lock` 使用 **原始自旋锁（raw spinlock）**，避免其自身调用路径触发 lockdep 检查。\n\n### 性能统计（`CONFIG_LOCK_STAT`）\n- 每个 CPU 维护独立的锁统计结构，记录：\n  - 等待时间（`read_waittime`/`write_waittime`）\n  - 持有时间（`read_holdtime`/`write_holdtime`）\n  - 争用点（`contention_point`）和竞争源（`contending_point`）\n- 通过 `lock_stats()` 聚合所有 CPU 的统计数据供调试使用。\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n- **调度子系统**：`<linux/sched.h>`、`<linux/sched/clock.h>` 等，用于获取当前任务和时间戳。\n- **中断管理**：`<linux/interrupt.h>`、`<linux/irqflags.h>`，用于上下文判断。\n- **内存管理**：`<linux/gfp.h>`、`<linux/mm.h>`，用于动态分配（部分功能）。\n- **调试支持**：`<linux/debug_locks.h>`、`<linux/stacktrace.h>`、`<linux/kallsyms.h>`，用于错误报告和符号解析。\n- **同步原语**：`<linux/mutex.h>`、`<linux/spinlock.h>`，定义锁类型。\n- **跟踪系统**：`<trace/events/lock.h>`，集成 ftrace 锁事件。\n\n### 内部依赖\n- 依赖 `lockdep_internals.h` 中定义的内部数据结构和辅助宏。\n- 与 `kernel/locking/` 目录下的其他锁实现（如 `mutex.c`、`spinlock.c`）通过 `lock_acquire()`/`lock_release()` 等钩子函数交互。\n\n## 5. 使用场景\n\n- **内核开发与调试**：在 `CONFIG_PROVE_LOCKING` 启用时，自动检测驱动或子系统中的潜在死锁，是内核开发的重要调试工具。\n- **运行时验证**：在测试或生产环境中（通常仅限调试版本）持续监控锁行为，提前暴露并发问题。\n- **性能分析**：通过 `CONFIG_LOCK_STAT` 收集锁争用和延迟数据，优化高并发路径。\n- **中断安全审计**：确保中断处理程序中使用的锁符合 IRQ-safe 要求，防止系统挂死。\n- **自检机制**：内核启动时执行 lockdep 自检（`lockdep_selftest_task_struct` 相关逻辑，虽未在片段中完整显示），验证 lockdep 自身功能正常。",
      "similarity": 0.5641956329345703,
      "chunks": [
        {
          "chunk_id": 13,
          "file_path": "kernel/locking/lockdep.c",
          "start_line": 2519,
          "end_line": 2647,
          "content": [
            "static void",
            "print_irq_lock_scenario(struct lock_list *safe_entry,",
            "\t\t\tstruct lock_list *unsafe_entry,",
            "\t\t\tstruct lock_class *prev_class,",
            "\t\t\tstruct lock_class *next_class)",
            "{",
            "\tstruct lock_class *safe_class = safe_entry->class;",
            "\tstruct lock_class *unsafe_class = unsafe_entry->class;",
            "\tstruct lock_class *middle_class = prev_class;",
            "",
            "\tif (middle_class == safe_class)",
            "\t\tmiddle_class = next_class;",
            "",
            "\t/*",
            "\t * A direct locking problem where unsafe_class lock is taken",
            "\t * directly by safe_class lock, then all we need to show",
            "\t * is the deadlock scenario, as it is obvious that the",
            "\t * unsafe lock is taken under the safe lock.",
            "\t *",
            "\t * But if there is a chain instead, where the safe lock takes",
            "\t * an intermediate lock (middle_class) where this lock is",
            "\t * not the same as the safe lock, then the lock chain is",
            "\t * used to describe the problem. Otherwise we would need",
            "\t * to show a different CPU case for each link in the chain",
            "\t * from the safe_class lock to the unsafe_class lock.",
            "\t */",
            "\tif (middle_class != unsafe_class) {",
            "\t\tprintk(\"Chain exists of:\\n  \");",
            "\t\t__print_lock_name(NULL, safe_class);",
            "\t\tprintk(KERN_CONT \" --> \");",
            "\t\t__print_lock_name(NULL, middle_class);",
            "\t\tprintk(KERN_CONT \" --> \");",
            "\t\t__print_lock_name(NULL, unsafe_class);",
            "\t\tprintk(KERN_CONT \"\\n\\n\");",
            "\t}",
            "",
            "\tprintk(\" Possible interrupt unsafe locking scenario:\\n\\n\");",
            "\tprintk(\"       CPU0                    CPU1\\n\");",
            "\tprintk(\"       ----                    ----\\n\");",
            "\tprintk(\"  lock(\");",
            "\t__print_lock_name(NULL, unsafe_class);",
            "\tprintk(KERN_CONT \");\\n\");",
            "\tprintk(\"                               local_irq_disable();\\n\");",
            "\tprintk(\"                               lock(\");",
            "\t__print_lock_name(NULL, safe_class);",
            "\tprintk(KERN_CONT \");\\n\");",
            "\tprintk(\"                               lock(\");",
            "\t__print_lock_name(NULL, middle_class);",
            "\tprintk(KERN_CONT \");\\n\");",
            "\tprintk(\"  <Interrupt>\\n\");",
            "\tprintk(\"    lock(\");",
            "\t__print_lock_name(NULL, safe_class);",
            "\tprintk(KERN_CONT \");\\n\");",
            "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
            "}",
            "static void",
            "print_bad_irq_dependency(struct task_struct *curr,",
            "\t\t\t struct lock_list *prev_root,",
            "\t\t\t struct lock_list *next_root,",
            "\t\t\t struct lock_list *backwards_entry,",
            "\t\t\t struct lock_list *forwards_entry,",
            "\t\t\t struct held_lock *prev,",
            "\t\t\t struct held_lock *next,",
            "\t\t\t enum lock_usage_bit bit1,",
            "\t\t\t enum lock_usage_bit bit2,",
            "\t\t\t const char *irqclass)",
            "{",
            "\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)",
            "\t\treturn;",
            "",
            "\tnbcon_cpu_emergency_enter();",
            "",
            "\tpr_warn(\"\\n\");",
            "\tpr_warn(\"=====================================================\\n\");",
            "\tpr_warn(\"WARNING: %s-safe -> %s-unsafe lock order detected\\n\",",
            "\t\tirqclass, irqclass);",
            "\tprint_kernel_ident();",
            "\tpr_warn(\"-----------------------------------------------------\\n\");",
            "\tpr_warn(\"%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\\n\",",
            "\t\tcurr->comm, task_pid_nr(curr),",
            "\t\tlockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,",
            "\t\tcurr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,",
            "\t\tlockdep_hardirqs_enabled(),",
            "\t\tcurr->softirqs_enabled);",
            "\tprint_lock(next);",
            "",
            "\tpr_warn(\"\\nand this task is already holding:\\n\");",
            "\tprint_lock(prev);",
            "\tpr_warn(\"which would create a new lock dependency:\\n\");",
            "\tprint_lock_name(prev, hlock_class(prev));",
            "\tpr_cont(\" ->\");",
            "\tprint_lock_name(next, hlock_class(next));",
            "\tpr_cont(\"\\n\");",
            "",
            "\tpr_warn(\"\\nbut this new dependency connects a %s-irq-safe lock:\\n\",",
            "\t\tirqclass);",
            "\tprint_lock_name(NULL, backwards_entry->class);",
            "\tpr_warn(\"\\n... which became %s-irq-safe at:\\n\", irqclass);",
            "",
            "\tprint_lock_trace(backwards_entry->class->usage_traces[bit1], 1);",
            "",
            "\tpr_warn(\"\\nto a %s-irq-unsafe lock:\\n\", irqclass);",
            "\tprint_lock_name(NULL, forwards_entry->class);",
            "\tpr_warn(\"\\n... which became %s-irq-unsafe at:\\n\", irqclass);",
            "\tpr_warn(\"...\");",
            "",
            "\tprint_lock_trace(forwards_entry->class->usage_traces[bit2], 1);",
            "",
            "\tpr_warn(\"\\nother info that might help us debug this:\\n\\n\");",
            "\tprint_irq_lock_scenario(backwards_entry, forwards_entry,",
            "\t\t\t\thlock_class(prev), hlock_class(next));",
            "",
            "\tlockdep_print_held_locks(curr);",
            "",
            "\tpr_warn(\"\\nthe dependencies between %s-irq-safe lock and the holding lock:\\n\", irqclass);",
            "\tprint_shortest_lock_dependencies_backwards(backwards_entry, prev_root);",
            "",
            "\tpr_warn(\"\\nthe dependencies between the lock to be acquired\");",
            "\tpr_warn(\" and %s-irq-unsafe lock:\\n\", irqclass);",
            "\tnext_root->trace = save_trace();",
            "\tif (!next_root->trace)",
            "\t\tgoto out;",
            "\tprint_shortest_lock_dependencies(forwards_entry, next_root);",
            "",
            "\tpr_warn(\"\\nstack backtrace:\\n\");",
            "\tdump_stack();",
            "out:",
            "\tnbcon_cpu_emergency_exit();",
            "}"
          ],
          "function_name": "print_irq_lock_scenario, print_bad_irq_dependency",
          "description": "检测中断安全与非安全锁的依赖关系，生成特定场景下的死锁警告信息并展示相关锁的调用栈和依赖链条。",
          "similarity": 0.6311640739440918
        },
        {
          "chunk_id": 16,
          "file_path": "kernel/locking/lockdep.c",
          "start_line": 3050,
          "end_line": 3220,
          "content": [
            "static int",
            "check_deadlock(struct task_struct *curr, struct held_lock *next)",
            "{",
            "\tstruct lock_class *class;",
            "\tstruct held_lock *prev;",
            "\tstruct held_lock *nest = NULL;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < curr->lockdep_depth; i++) {",
            "\t\tprev = curr->held_locks + i;",
            "",
            "\t\tif (prev->instance == next->nest_lock)",
            "\t\t\tnest = prev;",
            "",
            "\t\tif (hlock_class(prev) != hlock_class(next))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Allow read-after-read recursion of the same",
            "\t\t * lock class (i.e. read_lock(lock)+read_lock(lock)):",
            "\t\t */",
            "\t\tif ((next->read == 2) && prev->read)",
            "\t\t\tcontinue;",
            "",
            "\t\tclass = hlock_class(prev);",
            "",
            "\t\tif (class->cmp_fn &&",
            "\t\t    class->cmp_fn(prev->instance, next->instance) < 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * We're holding the nest_lock, which serializes this lock's",
            "\t\t * nesting behaviour.",
            "\t\t */",
            "\t\tif (nest)",
            "\t\t\treturn 2;",
            "",
            "\t\tprint_deadlock_bug(curr, prev, next);",
            "\t\treturn 0;",
            "\t}",
            "\treturn 1;",
            "}",
            "static int",
            "check_prev_add(struct task_struct *curr, struct held_lock *prev,",
            "\t       struct held_lock *next, u16 distance,",
            "\t       struct lock_trace **const trace)",
            "{",
            "\tstruct lock_list *entry;",
            "\tenum bfs_result ret;",
            "",
            "\tif (!hlock_class(prev)->key || !hlock_class(next)->key) {",
            "\t\t/*",
            "\t\t * The warning statements below may trigger a use-after-free",
            "\t\t * of the class name. It is better to trigger a use-after free",
            "\t\t * and to have the class name most of the time instead of not",
            "\t\t * having the class name available.",
            "\t\t */",
            "\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(prev)->key,",
            "\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",",
            "\t\t\t  hlock_class(prev),",
            "\t\t\t  hlock_class(prev)->name);",
            "\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(next)->key,",
            "\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",",
            "\t\t\t  hlock_class(next),",
            "\t\t\t  hlock_class(next)->name);",
            "\t\treturn 2;",
            "\t}",
            "",
            "\tif (prev->class_idx == next->class_idx) {",
            "\t\tstruct lock_class *class = hlock_class(prev);",
            "",
            "\t\tif (class->cmp_fn &&",
            "\t\t    class->cmp_fn(prev->instance, next->instance) < 0)",
            "\t\t\treturn 2;",
            "\t}",
            "",
            "\t/*",
            "\t * Prove that the new <prev> -> <next> dependency would not",
            "\t * create a circular dependency in the graph. (We do this by",
            "\t * a breadth-first search into the graph starting at <next>,",
            "\t * and check whether we can reach <prev>.)",
            "\t *",
            "\t * The search is limited by the size of the circular queue (i.e.,",
            "\t * MAX_CIRCULAR_QUEUE_SIZE) which keeps track of a breadth of nodes",
            "\t * in the graph whose neighbours are to be checked.",
            "\t */",
            "\tret = check_noncircular(next, prev, trace);",
            "\tif (unlikely(bfs_error(ret) || ret == BFS_RMATCH))",
            "\t\treturn 0;",
            "",
            "\tif (!check_irq_usage(curr, prev, next))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * Is the <prev> -> <next> dependency already present?",
            "\t *",
            "\t * (this may occur even though this is a new chain: consider",
            "\t *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3",
            "\t *  chains - the second one will be new, but L1 already has",
            "\t *  L2 added to its dependency list, due to the first chain.)",
            "\t */",
            "\tlist_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {",
            "\t\tif (entry->class == hlock_class(next)) {",
            "\t\t\tif (distance == 1)",
            "\t\t\t\tentry->distance = 1;",
            "\t\t\tentry->dep |= calc_dep(prev, next);",
            "",
            "\t\t\t/*",
            "\t\t\t * Also, update the reverse dependency in @next's",
            "\t\t\t * ->locks_before list.",
            "\t\t\t *",
            "\t\t\t *  Here we reuse @entry as the cursor, which is fine",
            "\t\t\t *  because we won't go to the next iteration of the",
            "\t\t\t *  outer loop:",
            "\t\t\t *",
            "\t\t\t *  For normal cases, we return in the inner loop.",
            "\t\t\t *",
            "\t\t\t *  If we fail to return, we have inconsistency, i.e.",
            "\t\t\t *  <prev>::locks_after contains <next> while",
            "\t\t\t *  <next>::locks_before doesn't contain <prev>. In",
            "\t\t\t *  that case, we return after the inner and indicate",
            "\t\t\t *  something is wrong.",
            "\t\t\t */",
            "\t\t\tlist_for_each_entry(entry, &hlock_class(next)->locks_before, entry) {",
            "\t\t\t\tif (entry->class == hlock_class(prev)) {",
            "\t\t\t\t\tif (distance == 1)",
            "\t\t\t\t\t\tentry->distance = 1;",
            "\t\t\t\t\tentry->dep |= calc_depb(prev, next);",
            "\t\t\t\t\treturn 1;",
            "\t\t\t\t}",
            "\t\t\t}",
            "",
            "\t\t\t/* <prev> is not found in <next>::locks_before */",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Is the <prev> -> <next> link redundant?",
            "\t */",
            "\tret = check_redundant(prev, next);",
            "\tif (bfs_error(ret))",
            "\t\treturn 0;",
            "\telse if (ret == BFS_RMATCH)",
            "\t\treturn 2;",
            "",
            "\tif (!*trace) {",
            "\t\t*trace = save_trace();",
            "\t\tif (!*trace)",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\t/*",
            "\t * Ok, all validations passed, add the new lock",
            "\t * to the previous lock's dependency list:",
            "\t */",
            "\tret = add_lock_to_list(hlock_class(next), hlock_class(prev),",
            "\t\t\t       &hlock_class(prev)->locks_after, distance,",
            "\t\t\t       calc_dep(prev, next), *trace);",
            "",
            "\tif (!ret)",
            "\t\treturn 0;",
            "",
            "\tret = add_lock_to_list(hlock_class(prev), hlock_class(next),",
            "\t\t\t       &hlock_class(next)->locks_before, distance,",
            "\t\t\t       calc_depb(prev, next), *trace);",
            "\tif (!ret)",
            "\t\treturn 0;",
            "",
            "\treturn 2;",
            "}"
          ],
          "function_name": "check_deadlock, check_prev_add",
          "description": "实现死锁检测和锁依赖关系添加逻辑，通过遍历已有锁检查循环依赖并调用check_prev_add进行依赖关系校验与更新，包含非循环性检查、中断使用检查及锁类比对等关键步骤",
          "similarity": 0.6221973896026611
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/locking/lockdep.c",
          "start_line": 2132,
          "end_line": 2251,
          "content": [
            "unsigned long lockdep_count_backward_deps(struct lock_class *class)",
            "{",
            "\tunsigned long ret, flags;",
            "\tstruct lock_list this;",
            "",
            "\t__bfs_init_root(&this, class);",
            "",
            "\traw_local_irq_save(flags);",
            "\tlockdep_lock();",
            "\tret = __lockdep_count_backward_deps(&this);",
            "\tlockdep_unlock();",
            "\traw_local_irq_restore(flags);",
            "",
            "\treturn ret;",
            "}",
            "static noinline enum bfs_result",
            "check_path(struct held_lock *target, struct lock_list *src_entry,",
            "\t   bool (*match)(struct lock_list *entry, void *data),",
            "\t   bool (*skip)(struct lock_list *entry, void *data),",
            "\t   struct lock_list **target_entry)",
            "{",
            "\tenum bfs_result ret;",
            "",
            "\tret = __bfs_forwards(src_entry, target, match, skip, target_entry);",
            "",
            "\tif (unlikely(bfs_error(ret)))",
            "\t\tprint_bfs_bug(ret);",
            "",
            "\treturn ret;",
            "}",
            "static noinline enum bfs_result",
            "check_noncircular(struct held_lock *src, struct held_lock *target,",
            "\t\t  struct lock_trace **const trace)",
            "{",
            "\tenum bfs_result ret;",
            "\tstruct lock_list *target_entry;",
            "\tstruct lock_list src_entry;",
            "",
            "\tbfs_init_root(&src_entry, src);",
            "",
            "\tdebug_atomic_inc(nr_cyclic_checks);",
            "",
            "\tret = check_path(target, &src_entry, hlock_conflict, NULL, &target_entry);",
            "",
            "\tif (unlikely(ret == BFS_RMATCH)) {",
            "\t\tif (!*trace) {",
            "\t\t\t/*",
            "\t\t\t * If save_trace fails here, the printing might",
            "\t\t\t * trigger a WARN but because of the !nr_entries it",
            "\t\t\t * should not do bad things.",
            "\t\t\t */",
            "\t\t\t*trace = save_trace();",
            "\t\t}",
            "",
            "\t\tif (src->class_idx == target->class_idx)",
            "\t\t\tprint_deadlock_bug(current, src, target);",
            "\t\telse",
            "\t\t\tprint_circular_bug(&src_entry, target_entry, src, target);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static inline bool usage_accumulate(struct lock_list *entry, void *mask)",
            "{",
            "\tif (!entry->only_xr)",
            "\t\t*(unsigned long *)mask |= entry->class->usage_mask;",
            "\telse /* Mask out _READ usage bits */",
            "\t\t*(unsigned long *)mask |= (entry->class->usage_mask & LOCKF_IRQ);",
            "",
            "\treturn false;",
            "}",
            "static inline bool usage_match(struct lock_list *entry, void *mask)",
            "{",
            "\tif (!entry->only_xr)",
            "\t\treturn !!(entry->class->usage_mask & *(unsigned long *)mask);",
            "\telse /* Mask out _READ usage bits */",
            "\t\treturn !!((entry->class->usage_mask & LOCKF_IRQ) & *(unsigned long *)mask);",
            "}",
            "static inline bool usage_skip(struct lock_list *entry, void *mask)",
            "{",
            "\tif (entry->class->lock_type == LD_LOCK_NORMAL)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Skip local_lock() for irq inversion detection.",
            "\t *",
            "\t * For !RT, local_lock() is not a real lock, so it won't carry any",
            "\t * dependency.",
            "\t *",
            "\t * For RT, an irq inversion happens when we have lock A and B, and on",
            "\t * some CPU we can have:",
            "\t *",
            "\t *\tlock(A);",
            "\t *\t<interrupted>",
            "\t *\t  lock(B);",
            "\t *",
            "\t * where lock(B) cannot sleep, and we have a dependency B -> ... -> A.",
            "\t *",
            "\t * Now we prove local_lock() cannot exist in that dependency. First we",
            "\t * have the observation for any lock chain L1 -> ... -> Ln, for any",
            "\t * 1 <= i <= n, Li.inner_wait_type <= L1.inner_wait_type, otherwise",
            "\t * wait context check will complain. And since B is not a sleep lock,",
            "\t * therefore B.inner_wait_type >= 2, and since the inner_wait_type of",
            "\t * local_lock() is 3, which is greater than 2, therefore there is no",
            "\t * way the local_lock() exists in the dependency B -> ... -> A.",
            "\t *",
            "\t * As a result, we will skip local_lock(), when we search for irq",
            "\t * inversion bugs.",
            "\t */",
            "\tif (entry->class->lock_type == LD_LOCK_PERCPU &&",
            "\t    DEBUG_LOCKS_WARN_ON(entry->class->wait_type_inner < LD_WAIT_CONFIG))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Skip WAIT_OVERRIDE for irq inversion detection -- it's not actually",
            "\t * a lock and only used to override the wait_type.",
            "\t */",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "lockdep_count_backward_deps, check_path, check_noncircular, usage_accumulate, usage_match, usage_skip",
          "description": "实现非循环路径检查及锁使用掩码的累积、匹配和跳过逻辑，用于追踪锁的持有状态和中断安全依赖关系。",
          "similarity": 0.6107797622680664
        },
        {
          "chunk_id": 39,
          "file_path": "kernel/locking/lockdep.c",
          "start_line": 6537,
          "end_line": 6639,
          "content": [
            "void lockdep_unregister_key(struct lock_class_key *key)",
            "{",
            "\tstruct hlist_head *hash_head = keyhashentry(key);",
            "\tstruct lock_class_key *k;",
            "\tstruct pending_free *pf;",
            "\tunsigned long flags;",
            "\tbool found = false;",
            "\tbool need_callback = false;",
            "",
            "\tmight_sleep();",
            "",
            "\tif (WARN_ON_ONCE(static_obj(key)))",
            "\t\treturn;",
            "",
            "\traw_local_irq_save(flags);",
            "\tlockdep_lock();",
            "",
            "\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {",
            "\t\tif (k == key) {",
            "\t\t\thlist_del_rcu(&k->hash_entry);",
            "\t\t\tfound = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tWARN_ON_ONCE(!found && debug_locks);",
            "\tif (found) {",
            "\t\tpf = get_pending_free();",
            "\t\t__lockdep_free_key_range(pf, key, 1);",
            "\t\tneed_callback = prepare_call_rcu_zapped(pf);",
            "\t}",
            "\tlockdep_unlock();",
            "\traw_local_irq_restore(flags);",
            "",
            "\tif (need_callback)",
            "\t\tcall_rcu(&delayed_free.rcu_head, free_zapped_rcu);",
            "",
            "\t/* Wait until is_dynamic_key() has finished accessing k->hash_entry. */",
            "\tsynchronize_rcu();",
            "}",
            "void __init lockdep_init(void)",
            "{",
            "\tprintk(\"Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\\n\");",
            "",
            "\tprintk(\"... MAX_LOCKDEP_SUBCLASSES:  %lu\\n\", MAX_LOCKDEP_SUBCLASSES);",
            "\tprintk(\"... MAX_LOCK_DEPTH:          %lu\\n\", MAX_LOCK_DEPTH);",
            "\tprintk(\"... MAX_LOCKDEP_KEYS:        %lu\\n\", MAX_LOCKDEP_KEYS);",
            "\tprintk(\"... CLASSHASH_SIZE:          %lu\\n\", CLASSHASH_SIZE);",
            "\tprintk(\"... MAX_LOCKDEP_ENTRIES:     %lu\\n\", MAX_LOCKDEP_ENTRIES);",
            "\tprintk(\"... MAX_LOCKDEP_CHAINS:      %lu\\n\", MAX_LOCKDEP_CHAINS);",
            "\tprintk(\"... CHAINHASH_SIZE:          %lu\\n\", CHAINHASH_SIZE);",
            "",
            "\tprintk(\" memory used by lock dependency info: %zu kB\\n\",",
            "\t       (sizeof(lock_classes) +",
            "\t\tsizeof(lock_classes_in_use) +",
            "\t\tsizeof(classhash_table) +",
            "\t\tsizeof(list_entries) +",
            "\t\tsizeof(list_entries_in_use) +",
            "\t\tsizeof(chainhash_table) +",
            "\t\tsizeof(delayed_free)",
            "#ifdef CONFIG_PROVE_LOCKING",
            "\t\t+ sizeof(lock_cq)",
            "\t\t+ sizeof(lock_chains)",
            "\t\t+ sizeof(lock_chains_in_use)",
            "\t\t+ sizeof(chain_hlocks)",
            "#endif",
            "\t\t) / 1024",
            "\t\t);",
            "",
            "#if defined(CONFIG_TRACE_IRQFLAGS) && defined(CONFIG_PROVE_LOCKING)",
            "\tprintk(\" memory used for stack traces: %zu kB\\n\",",
            "\t       (sizeof(stack_trace) + sizeof(stack_trace_hash)) / 1024",
            "\t       );",
            "#endif",
            "",
            "\tprintk(\" per task-struct memory footprint: %zu bytes\\n\",",
            "\t       sizeof(((struct task_struct *)NULL)->held_locks));",
            "}",
            "static void",
            "print_freed_lock_bug(struct task_struct *curr, const void *mem_from,",
            "\t\t     const void *mem_to, struct held_lock *hlock)",
            "{",
            "\tif (!debug_locks_off())",
            "\t\treturn;",
            "\tif (debug_locks_silent)",
            "\t\treturn;",
            "",
            "\tnbcon_cpu_emergency_enter();",
            "",
            "\tpr_warn(\"\\n\");",
            "\tpr_warn(\"=========================\\n\");",
            "\tpr_warn(\"WARNING: held lock freed!\\n\");",
            "\tprint_kernel_ident();",
            "\tpr_warn(\"-------------------------\\n\");",
            "\tpr_warn(\"%s/%d is freeing memory %px-%px, with a lock still held there!\\n\",",
            "\t\tcurr->comm, task_pid_nr(curr), mem_from, mem_to-1);",
            "\tprint_lock(hlock);",
            "\tlockdep_print_held_locks(curr);",
            "",
            "\tpr_warn(\"\\nstack backtrace:\\n\");",
            "\tdump_stack();",
            "",
            "\tnbcon_cpu_emergency_exit();",
            "}"
          ],
          "function_name": "lockdep_unregister_key, lockdep_init, print_freed_lock_bug",
          "description": "初始化锁依赖验证系统并注册锁键，检测内存释放时仍持锁的情况并触发警告",
          "similarity": 0.6052895784378052
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/locking/lockdep.c",
          "start_line": 2679,
          "end_line": 2829,
          "content": [
            "static int exclusive_bit(int new_bit)",
            "{",
            "\tint state = new_bit & LOCK_USAGE_STATE_MASK;",
            "\tint dir = new_bit & LOCK_USAGE_DIR_MASK;",
            "",
            "\t/*",
            "\t * keep state, bit flip the direction and strip read.",
            "\t */",
            "\treturn state | (dir ^ LOCK_USAGE_DIR_MASK);",
            "}",
            "static unsigned long invert_dir_mask(unsigned long mask)",
            "{",
            "\tunsigned long excl = 0;",
            "",
            "\t/* Invert dir */",
            "\texcl |= (mask & LOCKF_ENABLED_IRQ_ALL) >> LOCK_USAGE_DIR_MASK;",
            "\texcl |= (mask & LOCKF_USED_IN_IRQ_ALL) << LOCK_USAGE_DIR_MASK;",
            "",
            "\treturn excl;",
            "}",
            "static unsigned long exclusive_mask(unsigned long mask)",
            "{",
            "\tunsigned long excl = invert_dir_mask(mask);",
            "",
            "\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;",
            "\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;",
            "",
            "\treturn excl;",
            "}",
            "static unsigned long original_mask(unsigned long mask)",
            "{",
            "\tunsigned long excl = invert_dir_mask(mask);",
            "",
            "\t/* Include read in existing usages */",
            "\texcl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;",
            "\texcl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;",
            "",
            "\treturn excl;",
            "}",
            "static int find_exclusive_match(unsigned long mask,",
            "\t\t\t\tunsigned long excl_mask,",
            "\t\t\t\tenum lock_usage_bit *bitp,",
            "\t\t\t\tenum lock_usage_bit *excl_bitp)",
            "{",
            "\tint bit, excl, excl_read;",
            "",
            "\tfor_each_set_bit(bit, &mask, LOCK_USED) {",
            "\t\t/*",
            "\t\t * exclusive_bit() strips the read bit, however,",
            "\t\t * LOCK_ENABLED_IRQ_*_READ may cause deadlocks too, so we need",
            "\t\t * to search excl | LOCK_USAGE_READ_MASK as well.",
            "\t\t */",
            "\t\texcl = exclusive_bit(bit);",
            "\t\texcl_read = excl | LOCK_USAGE_READ_MASK;",
            "\t\tif (excl_mask & lock_flag(excl)) {",
            "\t\t\t*bitp = bit;",
            "\t\t\t*excl_bitp = excl;",
            "\t\t\treturn 0;",
            "\t\t} else if (excl_mask & lock_flag(excl_read)) {",
            "\t\t\t*bitp = bit;",
            "\t\t\t*excl_bitp = excl_read;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\treturn -1;",
            "}",
            "static int check_irq_usage(struct task_struct *curr, struct held_lock *prev,",
            "\t\t\t   struct held_lock *next)",
            "{",
            "\tunsigned long usage_mask = 0, forward_mask, backward_mask;",
            "\tenum lock_usage_bit forward_bit = 0, backward_bit = 0;",
            "\tstruct lock_list *target_entry1;",
            "\tstruct lock_list *target_entry;",
            "\tstruct lock_list this, that;",
            "\tenum bfs_result ret;",
            "",
            "\t/*",
            "\t * Step 1: gather all hard/soft IRQs usages backward in an",
            "\t * accumulated usage mask.",
            "\t */",
            "\tbfs_init_rootb(&this, prev);",
            "",
            "\tret = __bfs_backwards(&this, &usage_mask, usage_accumulate, usage_skip, NULL);",
            "\tif (bfs_error(ret)) {",
            "\t\tprint_bfs_bug(ret);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tusage_mask &= LOCKF_USED_IN_IRQ_ALL;",
            "\tif (!usage_mask)",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * Step 2: find exclusive uses forward that match the previous",
            "\t * backward accumulated mask.",
            "\t */",
            "\tforward_mask = exclusive_mask(usage_mask);",
            "",
            "\tbfs_init_root(&that, next);",
            "",
            "\tret = find_usage_forwards(&that, forward_mask, &target_entry1);",
            "\tif (bfs_error(ret)) {",
            "\t\tprint_bfs_bug(ret);",
            "\t\treturn 0;",
            "\t}",
            "\tif (ret == BFS_RNOMATCH)",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * Step 3: we found a bad match! Now retrieve a lock from the backward",
            "\t * list whose usage mask matches the exclusive usage mask from the",
            "\t * lock found on the forward list.",
            "\t *",
            "\t * Note, we should only keep the LOCKF_ENABLED_IRQ_ALL bits, considering",
            "\t * the follow case:",
            "\t *",
            "\t * When trying to add A -> B to the graph, we find that there is a",
            "\t * hardirq-safe L, that L -> ... -> A, and another hardirq-unsafe M,",
            "\t * that B -> ... -> M. However M is **softirq-safe**, if we use exact",
            "\t * invert bits of M's usage_mask, we will find another lock N that is",
            "\t * **softirq-unsafe** and N -> ... -> A, however N -> .. -> M will not",
            "\t * cause a inversion deadlock.",
            "\t */",
            "\tbackward_mask = original_mask(target_entry1->class->usage_mask & LOCKF_ENABLED_IRQ_ALL);",
            "",
            "\tret = find_usage_backwards(&this, backward_mask, &target_entry);",
            "\tif (bfs_error(ret)) {",
            "\t\tprint_bfs_bug(ret);",
            "\t\treturn 0;",
            "\t}",
            "\tif (DEBUG_LOCKS_WARN_ON(ret == BFS_RNOMATCH))",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * Step 4: narrow down to a pair of incompatible usage bits",
            "\t * and report it.",
            "\t */",
            "\tret = find_exclusive_match(target_entry->class->usage_mask,",
            "\t\t\t\t   target_entry1->class->usage_mask,",
            "\t\t\t\t   &backward_bit, &forward_bit);",
            "\tif (DEBUG_LOCKS_WARN_ON(ret == -1))",
            "\t\treturn 1;",
            "",
            "\tprint_bad_irq_dependency(curr, &this, &that,",
            "\t\t\t\t target_entry, target_entry1,",
            "\t\t\t\t prev, next,",
            "\t\t\t\t backward_bit, forward_bit,",
            "\t\t\t\t state_name(backward_bit));",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "exclusive_bit, invert_dir_mask, exclusive_mask, original_mask, find_exclusive_match, check_irq_usage",
          "description": "处理锁使用掩码的转换与匹配，识别可能导致中断竞争的锁依赖关系，为中断安全检查提供位掩码分析支持。",
          "similarity": 0.6013672351837158
        }
      ]
    },
    {
      "source_file": "kernel/locking/mutex-debug.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:42:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\mutex-debug.c`\n\n---\n\n# `locking/mutex-debug.c` 技术文档\n\n## 1. 文件概述\n\n`mutex-debug.c` 是 Linux 内核中用于调试互斥锁（mutex）的辅助实现文件。该文件提供了一系列调试钩子函数，在启用锁调试功能（如 `CONFIG_DEBUG_MUTEXES` 或 `CONFIG_DEBUG_LOCK_ALLOC`）时，用于检测互斥锁使用中的常见错误，包括：\n- 重复初始化或销毁已持有的锁\n- 等待者（waiter）数据结构的非法状态\n- 死锁风险（通过与 lockdep 集成）\n- 内存污染（通过魔数 magic 和 poison 值）\n\n这些调试函数在正常编译配置下可能被编译器优化掉，仅在调试模式下生效，以最小化对性能的影响。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `debug_mutex_lock_common()` | 初始化一个 `mutex_waiter` 结构，设置魔数和初始状态 |\n| `debug_mutex_wake_waiter()` | 在唤醒等待者前验证其状态合法性 |\n| `debug_mutex_free_waiter()` | 释放等待者结构前清空并标记为已释放 |\n| `debug_mutex_add_waiter()` | 将当前任务标记为阻塞在指定 mutex 上（用于死锁检测） |\n| `debug_mutex_remove_waiter()` | 从等待队列中移除等待者，并清除任务的阻塞状态 |\n| `debug_mutex_unlock()` | 验证解锁操作时 mutex 的一致性（如魔数、等待队列状态） |\n| `debug_mutex_init()` | 初始化 mutex 的调试字段，并集成 lockdep 锁类跟踪 |\n| `mutex_destroy()` | 标记 mutex 为不可用，防止后续误用 |\n| `__devm_mutex_init()` | 为设备资源管理（devres）提供自动销毁的 mutex 初始化接口 |\n\n### 关键数据结构字段（调试相关）\n\n- `mutex::magic`：指向自身，用于检测内存损坏或重复释放\n- `mutex_waiter::magic`：指向自身，用于验证 waiter 结构完整性\n- `task_struct::blocked_on`：指向当前任务正在等待的 waiter，用于死锁检测\n- `mutex_waiter::ww_ctx`：用于 ww_mutex（写写互斥锁）调试，初始化为 poison 值\n\n## 3. 关键实现\n\n### 魔数（Magic Number）与 Poison 值\n- 所有 mutex 和 waiter 结构在初始化时设置 `magic = self`，销毁时置为 `NULL` 或特定 poison 值（如 `MUTEX_DEBUG_INIT`/`MUTEX_DEBUG_FREE`）。\n- 通过 `DEBUG_LOCKS_WARN_ON()` 宏在关键路径检查这些值，一旦发现异常立即触发警告。\n\n### 与 Lockdep 集成\n- `debug_mutex_init()` 调用 `lockdep_init_map_wait()` 将 mutex 注册到 lockdep 锁依赖跟踪系统，支持死锁检测。\n- `debug_check_no_locks_freed()` 确保不会在锁仍被持有时重新初始化，防止状态混乱。\n\n### 等待者生命周期管理\n- `debug_mutex_add_waiter()` 设置 `task->blocked_on = waiter`，使 lockdep 能构建任务等待图。\n- `debug_mutex_remove_waiter()` 清除此指针，并验证 waiter 与 task 的一致性，防止悬挂引用。\n\n### 设备资源管理（devres）支持\n- `__devm_mutex_init()` 利用 devres 框架自动注册 `devm_mutex_release()` 回调，确保设备卸载时自动调用 `mutex_destroy()`，避免资源泄漏。\n\n### 断言与警告\n- 大量使用 `lockdep_assert_held(&lock->wait_lock)` 确保函数在正确锁保护下被调用。\n- `DEBUG_LOCKS_WARN_ON()` 在检测到非法状态时输出警告（仅在 `debug_locks` 全局变量启用时生效）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mutex.h>`：mutex 核心 API\n  - `<linux/debug_locks.h>`：调试锁的通用宏（如 `DEBUG_LOCKS_WARN_ON`）\n  - `<linux/lockdep.h>`（间接）：通过 `lockdep_init_map_wait` 和 `debug_check_no_locks_freed`\n  - `<linux/device.h>`：devres 相关接口\n  - `<linux/sched.h>`：访问 `task_struct::blocked_on`\n\n- **内核配置依赖**：\n  - `CONFIG_DEBUG_MUTEXES`：启用 mutex 调试逻辑\n  - `CONFIG_DEBUG_LOCK_ALLOC`：启用 lockdep 集成\n  - `CONFIG_DEBUG_LIST`：增强链表调试（通过 `DEBUG_LOCKS_WARN_ON(list_empty(...))`）\n\n- **内部依赖**：\n  - 依赖 `mutex.h`（本地头文件）中定义的内部结构（如 `mutex_waiter`）\n\n## 5. 使用场景\n\n- **内核开发与调试**：\n  - 在启用 `CONFIG_DEBUG_MUTEXES` 的内核中，所有 mutex 操作自动插入调试检查，帮助开发者发现竞态条件、死锁或 API 误用。\n\n- **死锁检测**：\n  - 通过 `task->blocked_on` 和 lockdep 的等待图分析，检测潜在的 AB-BA 死锁。\n\n- **内存安全验证**：\n  - 魔数和 poison 值用于检测 use-after-free 或内存越界写入导致的 mutex 结构损坏。\n\n- **设备驱动开发**：\n  - 驱动使用 `__devm_mutex_init()` 可自动管理 mutex 生命周期，避免在错误路径遗漏 `mutex_destroy()`。\n\n- **生产环境**：\n  - 在非调试内核中，所有调试函数为空或内联优化掉，对性能无影响。",
      "similarity": 0.5632272958755493,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/mutex-debug.c",
          "start_line": 29,
          "end_line": 98,
          "content": [
            "void debug_mutex_lock_common(struct mutex *lock, struct mutex_waiter *waiter)",
            "{",
            "\tmemset(waiter, MUTEX_DEBUG_INIT, sizeof(*waiter));",
            "\twaiter->magic = waiter;",
            "\tINIT_LIST_HEAD(&waiter->list);",
            "\twaiter->ww_ctx = MUTEX_POISON_WW_CTX;",
            "}",
            "void debug_mutex_wake_waiter(struct mutex *lock, struct mutex_waiter *waiter)",
            "{",
            "\tlockdep_assert_held(&lock->wait_lock);",
            "\tDEBUG_LOCKS_WARN_ON(list_empty(&lock->wait_list));",
            "\tDEBUG_LOCKS_WARN_ON(waiter->magic != waiter);",
            "\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));",
            "}",
            "void debug_mutex_free_waiter(struct mutex_waiter *waiter)",
            "{",
            "\tDEBUG_LOCKS_WARN_ON(!list_empty(&waiter->list));",
            "\tmemset(waiter, MUTEX_DEBUG_FREE, sizeof(*waiter));",
            "}",
            "void debug_mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,",
            "\t\t\t    struct task_struct *task)",
            "{",
            "\tlockdep_assert_held(&lock->wait_lock);",
            "",
            "\t/* Mark the current thread as blocked on the lock: */",
            "\ttask->blocked_on = waiter;",
            "}",
            "void debug_mutex_remove_waiter(struct mutex *lock, struct mutex_waiter *waiter,",
            "\t\t\t struct task_struct *task)",
            "{",
            "\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));",
            "\tDEBUG_LOCKS_WARN_ON(waiter->task != task);",
            "\tDEBUG_LOCKS_WARN_ON(task->blocked_on != waiter);",
            "\ttask->blocked_on = NULL;",
            "",
            "\tINIT_LIST_HEAD(&waiter->list);",
            "\twaiter->task = NULL;",
            "}",
            "void debug_mutex_unlock(struct mutex *lock)",
            "{",
            "\tif (likely(debug_locks)) {",
            "\t\tDEBUG_LOCKS_WARN_ON(lock->magic != lock);",
            "\t\tDEBUG_LOCKS_WARN_ON(!lock->wait_list.prev && !lock->wait_list.next);",
            "\t}",
            "}",
            "void debug_mutex_init(struct mutex *lock, const char *name,",
            "\t\t      struct lock_class_key *key)",
            "{",
            "#ifdef CONFIG_DEBUG_LOCK_ALLOC",
            "\t/*",
            "\t * Make sure we are not reinitializing a held lock:",
            "\t */",
            "\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));",
            "\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, LD_WAIT_SLEEP);",
            "#endif",
            "\tlock->magic = lock;",
            "}",
            "static void devm_mutex_release(void *res)",
            "{",
            "\tmutex_destroy(res);",
            "}",
            "int __devm_mutex_init(struct device *dev, struct mutex *lock)",
            "{",
            "\treturn devm_add_action_or_reset(dev, devm_mutex_release, lock);",
            "}",
            "void mutex_destroy(struct mutex *lock)",
            "{",
            "\tDEBUG_LOCKS_WARN_ON(mutex_is_locked(lock));",
            "\tlock->magic = NULL;",
            "}"
          ],
          "function_name": "debug_mutex_lock_common, debug_mutex_wake_waiter, debug_mutex_free_waiter, debug_mutex_add_waiter, debug_mutex_remove_waiter, debug_mutex_unlock, debug_mutex_init, devm_mutex_release, __devm_mutex_init, mutex_destroy",
          "description": "实现了互斥锁调试核心函数，包括等待队列项初始化、唤醒/移除等待者、解锁验证、锁初始化及设备管理资源释放等功能，通过magic值校验和链表状态检测实现锁状态调试保障",
          "similarity": 0.5575404763221741
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/mutex-debug.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "/*",
            " * Debugging code for mutexes",
            " *",
            " * Started by Ingo Molnar:",
            " *",
            " *  Copyright (C) 2004, 2005, 2006 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>",
            " *",
            " * lock debugging, locking tree, deadlock detection started by:",
            " *",
            " *  Copyright (C) 2004, LynuxWorks, Inc., Igor Manyilov, Bill Huey",
            " *  Released under the General Public License (GPL).",
            " */",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/poison.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/debug_locks.h>",
            "",
            "#include \"mutex.h\"",
            "",
            "/*",
            " * Must be called with lock->wait_lock held.",
            " */"
          ],
          "function_name": null,
          "description": "此代码块定义了互斥锁调试模块的头文件引入及基本注释，包含核心调试相关头文件并声明了互斥锁调试逻辑的实现位置，当前上下文不完整",
          "similarity": 0.5456730127334595
        }
      ]
    }
  ]
}