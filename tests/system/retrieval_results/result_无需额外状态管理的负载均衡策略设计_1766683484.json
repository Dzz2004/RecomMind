{
  "query": "无需额外状态管理的负载均衡策略设计",
  "timestamp": "2025-12-26 01:24:44",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/loadavg.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:11:54\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\loadavg.c`\n\n---\n\n# `sched/loadavg.c` 技术文档\n\n## 1. 文件概述\n\n`sched/loadavg.c` 是 Linux 内核中负责计算**全局系统负载平均值**（load average）的核心实现文件。该文件通过分布式、异步的方式高效地维护三个时间窗口（1分钟、5分钟、15分钟）的系统负载平均值，用于反映系统中处于运行态（`nr_running`）和不可中断睡眠态（`nr_uninterruptible`）的任务数量。尽管负载平均值在技术上是一个“粗略估计”，但它被广泛用于系统监控、调度决策和用户感知的系统繁忙程度评估。\n\n该实现特别针对**大规模多核系统**和**无滴答**（tickless，即 `NO_HZ`）内核进行了优化，以最小化计算开销并保证在节能模式下的准确性。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `atomic_long_t calc_load_tasks`：用于累积所有 CPU 上活跃任务数的全局原子变量。\n- `unsigned long calc_load_update`：记录下一次负载计算更新的时间点（基于 `jiffies`）。\n- `unsigned long avenrun[3]`：存储三个时间窗口（1/5/15 分钟）的负载平均值，已导出供外部模块使用（注释建议移除导出）。\n\n### 主要函数\n- `get_avenrun(unsigned long *loads, unsigned long offset, int shift)`  \n  获取当前负载平均值数组，支持偏移和左移操作，用于适配不同精度需求（如 `/proc/loadavg` 输出）。\n- `calc_load_fold_active(struct rq *this_rq, long adjust)`  \n  计算当前 CPU 运行队列上活跃任务数（`nr_running + nr_uninterruptible`）相对于上次采样的变化量（delta），用于增量更新全局负载。\n- `fixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)`  \n  高效计算定点数的整数次幂（`x^n`），采用二分幂算法（O(log n)），用于负载衰减因子的指数运算。\n- `calc_load_n(unsigned long load, unsigned long exp, unsigned long active, unsigned int n)`  \n  计算经过 `n` 个采样周期后的负载值，基于指数平滑公式。\n- `calc_load_nohz_start()` / `calc_load_nohz_stop()` / `calc_load_nohz_remote()`  \n  在 `NO_HZ` 模式下管理负载采样的特殊处理，确保在 CPU 进入/退出无滴答状态时负载统计不丢失。\n\n### NO_HZ 相关变量（条件编译）\n- `static atomic_long_t calc_load_nohz[2]`：双缓冲数组，用于暂存 NO_HZ 期间累积的负载 delta。\n- `static int calc_load_idx`：索引标志，用于在两个 NO_HZ 缓冲区之间切换读写。\n\n## 3. 关键实现\n\n### 负载平均值计算原理\n系统负载平均值采用**指数加权移动平均**（EWMA）算法：\n```\navenrun[n] = avenrun[n] * exp + nr_active * (1 - exp)\n```\n其中 `exp` 是与时间窗口对应的衰减因子（如 1 分钟窗口对应 `exp ≈ 1884/2048`）。每 `LOAD_FREQ`（5 秒）更新一次。\n\n### 分布式增量更新机制\n为避免遍历所有 CPU 带来的高开销（尤其在 NUMA 系统上），采用**增量折叠**策略：\n- 每个 CPU 维护本地 `calc_load_active` 值。\n- 当本地活跃任务数变化时，计算 delta 并原子累加到全局 `calc_load_tasks`。\n- 全局更新时直接使用 `calc_load_tasks` 作为 `nr_active`，无需遍历 CPU。\n\n### NO_HZ 模式下的负载补偿\n在无滴答内核中，CPU 可能长时间不产生定时器中断，导致负载采样丢失。解决方案包括：\n- **双缓冲 NO_HZ Delta**：使用两个原子变量 `calc_load_nohz[2]`，通过 `calc_load_idx` 切换读写窗口，确保旧窗口的 delta 被正确计入，同时新窗口开始累积。\n- **写索引偏移**：`calc_load_write_idx()` 在窗口开始后切换写入缓冲区，而读取始终使用当前 `calc_load_idx`，避免读写冲突。\n- **远程更新支持**：`calc_load_nohz_remote()` 允许其他 CPU 代为更新处于 NO_HZ 状态的 CPU 的负载 delta（用于 `NO_HZ_FULL` 场景）。\n\n### 定点数幂运算优化\n`fixed_power_int()` 使用**二进制幂展开**（Exponentiation by Squaring）高效计算 `x^n`，适用于定点数（`frac_bits` 指定小数位数），避免浮点运算，保证实时性和精度。\n\n## 4. 依赖关系\n\n- **调度器核心**（`kernel/sched/core.c`）：依赖运行队列（`struct rq`）中的 `nr_running` 和 `nr_uninterruptible` 字段。\n- **时间子系统**：依赖 `jiffies` 和 `LOAD_FREQ`（定义在 `sched.h`）进行周期性更新。\n- **NO_HZ 子系统**（`CONFIG_NO_HZ_COMMON`）：与内核的动态滴答机制深度集成，需处理 CPU 空闲状态下的负载统计。\n- **SMP 原子操作**：使用 `atomic_long_t` 和 `smp_rmb()` 确保多核环境下的内存可见性和数据一致性。\n- **导出符号**：`avenrun` 被 `EXPORT_SYMBOL` 导出，供其他内核模块（如 procfs）读取。\n\n## 5. 使用场景\n\n- **`/proc/loadavg` 文件生成**：用户空间通过读取 `/proc/loadavg` 获取系统负载，其数据来源于 `avenrun` 数组。\n- **系统监控工具**：`top`、`htop`、`uptime` 等工具依赖此负载值评估系统繁忙程度。\n- **调度器决策辅助**：某些调度策略（如负载均衡）可能参考全局负载信息。\n- **内核调试与性能分析**：开发者可通过负载变化分析系统行为。\n- **NO_HZ 节能模式下的负载准确性保障**：在服务器和移动设备中，确保即使 CPU 频繁进入深度睡眠，负载统计仍保持合理精度。",
      "similarity": 0.5507223606109619,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/loadavg.c",
          "start_line": 283,
          "end_line": 371,
          "content": [
            "static long calc_load_nohz_read(void)",
            "{",
            "\tint idx = calc_load_read_idx();",
            "\tlong delta = 0;",
            "",
            "\tif (atomic_long_read(&calc_load_nohz[idx]))",
            "\t\tdelta = atomic_long_xchg(&calc_load_nohz[idx], 0);",
            "",
            "\treturn delta;",
            "}",
            "static void calc_global_nohz(void)",
            "{",
            "\tunsigned long sample_window;",
            "\tlong delta, active, n;",
            "",
            "\tsample_window = READ_ONCE(calc_load_update);",
            "\tif (!time_before(jiffies, sample_window + 10)) {",
            "\t\t/*",
            "\t\t * Catch-up, fold however many we are behind still",
            "\t\t */",
            "\t\tdelta = jiffies - sample_window - 10;",
            "\t\tn = 1 + (delta / LOAD_FREQ);",
            "",
            "\t\tactive = atomic_long_read(&calc_load_tasks);",
            "\t\tactive = active > 0 ? active * FIXED_1 : 0;",
            "",
            "\t\tavenrun[0] = calc_load_n(avenrun[0], EXP_1, active, n);",
            "\t\tavenrun[1] = calc_load_n(avenrun[1], EXP_5, active, n);",
            "\t\tavenrun[2] = calc_load_n(avenrun[2], EXP_15, active, n);",
            "",
            "\t\tWRITE_ONCE(calc_load_update, sample_window + n * LOAD_FREQ);",
            "\t}",
            "",
            "\t/*",
            "\t * Flip the NO_HZ index...",
            "\t *",
            "\t * Make sure we first write the new time then flip the index, so that",
            "\t * calc_load_write_idx() will see the new time when it reads the new",
            "\t * index, this avoids a double flip messing things up.",
            "\t */",
            "\tsmp_wmb();",
            "\tcalc_load_idx++;",
            "}",
            "static inline long calc_load_nohz_read(void) { return 0; }",
            "static inline void calc_global_nohz(void) { }",
            "void calc_global_load(void)",
            "{",
            "\tunsigned long sample_window;",
            "\tlong active, delta;",
            "",
            "\tsample_window = READ_ONCE(calc_load_update);",
            "\tif (time_before(jiffies, sample_window + 10))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Fold the 'old' NO_HZ-delta to include all NO_HZ CPUs.",
            "\t */",
            "\tdelta = calc_load_nohz_read();",
            "\tif (delta)",
            "\t\tatomic_long_add(delta, &calc_load_tasks);",
            "",
            "\tactive = atomic_long_read(&calc_load_tasks);",
            "\tactive = active > 0 ? active * FIXED_1 : 0;",
            "",
            "\tavenrun[0] = calc_load(avenrun[0], EXP_1, active);",
            "\tavenrun[1] = calc_load(avenrun[1], EXP_5, active);",
            "\tavenrun[2] = calc_load(avenrun[2], EXP_15, active);",
            "",
            "\tWRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);",
            "",
            "\t/*",
            "\t * In case we went to NO_HZ for multiple LOAD_FREQ intervals",
            "\t * catch up in bulk.",
            "\t */",
            "\tcalc_global_nohz();",
            "}",
            "void calc_global_load_tick(struct rq *this_rq)",
            "{",
            "\tlong delta;",
            "",
            "\tif (time_before(jiffies, this_rq->calc_load_update))",
            "\t\treturn;",
            "",
            "\tdelta  = calc_load_fold_active(this_rq, 0);",
            "\tif (delta)",
            "\t\tatomic_long_add(delta, &calc_load_tasks);",
            "",
            "\tthis_rq->calc_load_update += LOAD_FREQ;",
            "}"
          ],
          "function_name": "calc_load_nohz_read, calc_global_nohz, calc_load_nohz_read, calc_global_nohz, calc_global_load, calc_global_load_tick",
          "description": "实现全局负载更新主逻辑，包含时间窗口管理、非抢占模式数据合并、指数衰减计算及周期性负载值更新操作。",
          "similarity": 0.618993878364563
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/loadavg.c",
          "start_line": 71,
          "end_line": 184,
          "content": [
            "void get_avenrun(unsigned long *loads, unsigned long offset, int shift)",
            "{",
            "\tloads[0] = (avenrun[0] + offset) << shift;",
            "\tloads[1] = (avenrun[1] + offset) << shift;",
            "\tloads[2] = (avenrun[2] + offset) << shift;",
            "}",
            "long calc_load_fold_active(struct rq *this_rq, long adjust)",
            "{",
            "\tlong nr_active, delta = 0;",
            "",
            "\tnr_active = this_rq->nr_running - adjust;",
            "\tnr_active += (long)this_rq->nr_uninterruptible;",
            "",
            "\tif (nr_active != this_rq->calc_load_active) {",
            "\t\tdelta = nr_active - this_rq->calc_load_active;",
            "\t\tthis_rq->calc_load_active = nr_active;",
            "\t}",
            "",
            "\treturn delta;",
            "}",
            "static unsigned long",
            "fixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)",
            "{",
            "\tunsigned long result = 1UL << frac_bits;",
            "",
            "\tif (n) {",
            "\t\tfor (;;) {",
            "\t\t\tif (n & 1) {",
            "\t\t\t\tresult *= x;",
            "\t\t\t\tresult += 1UL << (frac_bits - 1);",
            "\t\t\t\tresult >>= frac_bits;",
            "\t\t\t}",
            "\t\t\tn >>= 1;",
            "\t\t\tif (!n)",
            "\t\t\t\tbreak;",
            "\t\t\tx *= x;",
            "\t\t\tx += 1UL << (frac_bits - 1);",
            "\t\t\tx >>= frac_bits;",
            "\t\t}",
            "\t}",
            "",
            "\treturn result;",
            "}",
            "unsigned long",
            "calc_load_n(unsigned long load, unsigned long exp,",
            "\t    unsigned long active, unsigned int n)",
            "{",
            "\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);",
            "}",
            "static inline int calc_load_write_idx(void)",
            "{",
            "\tint idx = calc_load_idx;",
            "",
            "\t/*",
            "\t * See calc_global_nohz(), if we observe the new index, we also",
            "\t * need to observe the new update time.",
            "\t */",
            "\tsmp_rmb();",
            "",
            "\t/*",
            "\t * If the folding window started, make sure we start writing in the",
            "\t * next NO_HZ-delta.",
            "\t */",
            "\tif (!time_before(jiffies, READ_ONCE(calc_load_update)))",
            "\t\tidx++;",
            "",
            "\treturn idx & 1;",
            "}",
            "static inline int calc_load_read_idx(void)",
            "{",
            "\treturn calc_load_idx & 1;",
            "}",
            "static void calc_load_nohz_fold(struct rq *rq)",
            "{",
            "\tlong delta;",
            "",
            "\tdelta = calc_load_fold_active(rq, 0);",
            "\tif (delta) {",
            "\t\tint idx = calc_load_write_idx();",
            "",
            "\t\tatomic_long_add(delta, &calc_load_nohz[idx]);",
            "\t}",
            "}",
            "void calc_load_nohz_start(void)",
            "{",
            "\t/*",
            "\t * We're going into NO_HZ mode, if there's any pending delta, fold it",
            "\t * into the pending NO_HZ delta.",
            "\t */",
            "\tcalc_load_nohz_fold(this_rq());",
            "}",
            "void calc_load_nohz_remote(struct rq *rq)",
            "{",
            "\tcalc_load_nohz_fold(rq);",
            "}",
            "void calc_load_nohz_stop(void)",
            "{",
            "\tstruct rq *this_rq = this_rq();",
            "",
            "\t/*",
            "\t * If we're still before the pending sample window, we're done.",
            "\t */",
            "\tthis_rq->calc_load_update = READ_ONCE(calc_load_update);",
            "\tif (time_before(jiffies, this_rq->calc_load_update))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * We woke inside or after the sample window, this means we're already",
            "\t * accounted through the nohz accounting, so skip the entire deal and",
            "\t * sync up for the next window.",
            "\t */",
            "\tif (time_before(jiffies, this_rq->calc_load_update + 10))",
            "\t\tthis_rq->calc_load_update += LOAD_FREQ;",
            "}"
          ],
          "function_name": "get_avenrun, calc_load_fold_active, fixed_power_int, calc_load_n, calc_load_write_idx, calc_load_read_idx, calc_load_nohz_fold, calc_load_nohz_start, calc_load_nohz_remote, calc_load_nohz_stop",
          "description": "实现负载计算核心逻辑，包含活动任务差值计算、指数运算、NO_HZ模式下的异步更新处理及跨CPU数据汇总机制。",
          "similarity": 0.6018584966659546
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/loadavg.c",
          "start_line": 1,
          "end_line": 70,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * kernel/sched/loadavg.c",
            " *",
            " * This file contains the magic bits required to compute the global loadavg",
            " * figure. Its a silly number but people think its important. We go through",
            " * great pains to make it work on big machines and tickless kernels.",
            " */",
            "",
            "/*",
            " * Global load-average calculations",
            " *",
            " * We take a distributed and async approach to calculating the global load-avg",
            " * in order to minimize overhead.",
            " *",
            " * The global load average is an exponentially decaying average of nr_running +",
            " * nr_uninterruptible.",
            " *",
            " * Once every LOAD_FREQ:",
            " *",
            " *   nr_active = 0;",
            " *   for_each_possible_cpu(cpu)",
            " *\tnr_active += cpu_of(cpu)->nr_running + cpu_of(cpu)->nr_uninterruptible;",
            " *",
            " *   avenrun[n] = avenrun[0] * exp_n + nr_active * (1 - exp_n)",
            " *",
            " * Due to a number of reasons the above turns in the mess below:",
            " *",
            " *  - for_each_possible_cpu() is prohibitively expensive on machines with",
            " *    serious number of CPUs, therefore we need to take a distributed approach",
            " *    to calculating nr_active.",
            " *",
            " *        \\Sum_i x_i(t) = \\Sum_i x_i(t) - x_i(t_0) | x_i(t_0) := 0",
            " *                      = \\Sum_i { \\Sum_j=1 x_i(t_j) - x_i(t_j-1) }",
            " *",
            " *    So assuming nr_active := 0 when we start out -- true per definition, we",
            " *    can simply take per-CPU deltas and fold those into a global accumulate",
            " *    to obtain the same result. See calc_load_fold_active().",
            " *",
            " *    Furthermore, in order to avoid synchronizing all per-CPU delta folding",
            " *    across the machine, we assume 10 ticks is sufficient time for every",
            " *    CPU to have completed this task.",
            " *",
            " *    This places an upper-bound on the IRQ-off latency of the machine. Then",
            " *    again, being late doesn't loose the delta, just wrecks the sample.",
            " *",
            " *  - cpu_rq()->nr_uninterruptible isn't accurately tracked per-CPU because",
            " *    this would add another cross-CPU cacheline miss and atomic operation",
            " *    to the wakeup path. Instead we increment on whatever CPU the task ran",
            " *    when it went into uninterruptible state and decrement on whatever CPU",
            " *    did the wakeup. This means that only the sum of nr_uninterruptible over",
            " *    all CPUs yields the correct result.",
            " *",
            " *  This covers the NO_HZ=n code, for extra head-aches, see the comment below.",
            " */",
            "",
            "/* Variables and functions for calc_load */",
            "atomic_long_t calc_load_tasks;",
            "unsigned long calc_load_update;",
            "unsigned long avenrun[3];",
            "EXPORT_SYMBOL(avenrun); /* should be removed */",
            "",
            "/**",
            " * get_avenrun - get the load average array",
            " * @loads:\tpointer to dest load array",
            " * @offset:\toffset to add",
            " * @shift:\tshift count to shift the result left",
            " *",
            " * These values are estimates at best, so no need for locking.",
            " */"
          ],
          "function_name": null,
          "description": "声明用于全局负载计算的原子变量和数组，定义获取负载平均值的接口，但未完整展示函数实现。",
          "similarity": 0.501515805721283
        }
      ]
    },
    {
      "source_file": "kernel/sched/sched.h",
      "md_summary": "> 自动生成时间: 2025-10-25 16:16:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\sched.h`\n\n---\n\n# `sched/sched.h` 技术文档\n\n## 1. 文件概述\n\n`sched/sched.h` 是 Linux 内核调度器（Scheduler）的核心内部头文件，定义了调度子系统内部使用的类型、宏、辅助函数和全局变量。该文件不对外暴露给其他子系统直接使用，而是作为调度器各组件（如 CFS、RT、Deadline 调度类）之间的内部接口和共享基础设施。它整合了任务状态管理、负载计算、策略判断、CPU 能力建模、cgroup 权重转换等关键调度逻辑，并为调试、性能追踪和平台适配提供支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct asym_cap_data`：用于描述非对称 CPU 架构中不同 CPU 集合的计算能力（capacity），支持异构多核系统（如 big.LITTLE）的调度优化。\n- `struct rq`（前向声明）：运行队列（runqueue）结构体，每个 CPU 对应一个，是调度器管理可运行任务的核心数据结构。\n- `struct cpuidle_state`（前向声明）：CPU 空闲状态信息，用于与调度器协同进行能效管理。\n\n### 关键全局变量\n- `scheduler_running`：标志调度器是否已启动。\n- `calc_load_update` / `calc_load_tasks`：用于全局负载（load average）计算的时间戳和任务计数。\n- `sysctl_sched_rt_period` / `sysctl_sched_rt_runtime`：实时任务带宽控制参数。\n- `sched_rr_timeslice`：SCHED_RR 策略的时间片长度。\n- `asym_cap_list`：非对称 CPU 能力数据的全局链表。\n\n### 核心辅助函数与宏\n- **任务策略判断函数**：\n  - `idle_policy()` / `task_has_idle_policy()`\n  - `normal_policy()` / `fair_policy()`\n  - `rt_policy()` / `task_has_rt_policy()`\n  - `dl_policy()` / `task_has_dl_policy()`\n  - `valid_policy()`\n- **负载与权重转换**：\n  - `scale_load()` / `scale_load_down()`：在内部高精度负载值与用户可见权重间转换。\n  - `sched_weight_from_cgroup()` / `sched_weight_to_cgroup()`：cgroup 权重与调度器内部权重的映射。\n- **时间与精度处理**：\n  - `NS_TO_JIFFIES()`：纳秒转 jiffies。\n  - `update_avg()`：指数移动平均（EMA）更新。\n  - `shr_bound()`：安全右移，避免未定义行为。\n- **特殊调度标志**：\n  - `SCHED_FLAG_SUGOV`：用于 schedutil 频率调节器的特殊标志，使相关 kworker 临时获得高于 SCHED_DEADLINE 的优先级。\n  - `dl_entity_is_special()`：判断 Deadline 实体是否为 SUGOV 特殊任务。\n\n### 重要宏定义\n- `TASK_ON_RQ_QUEUED` / `TASK_ON_RQ_MIGRATING`：`task_struct::on_rq` 字段的状态值。\n- `NICE_0_LOAD`：nice 值为 0 的任务对应的内部负载基准值。\n- `DL_SCALE`：SCHED_DEADLINE 内部计算的精度因子。\n- `RUNTIME_INF`：表示无限运行时间的常量。\n- `SCHED_WARN_ON()`：调度器专用的条件警告宏（仅在 `CONFIG_SCHED_DEBUG` 时生效）。\n\n## 3. 关键实现\n\n### 高精度负载计算（64 位优化）\n在 64 位架构上，通过 `NICE_0_LOAD_SHIFT = 2 * SCHED_FIXEDPOINT_SHIFT` 提升内部负载计算的精度，改善低权重任务组（如 nice +19）和深层 cgroup 层级的负载均衡效果。`scale_load()` 和 `scale_load_down()` 实现了用户权重与内部高精度负载值之间的无损转换。\n\n### 非对称 CPU 能力建模\n`asym_cap_data` 结构体结合 `cpu_capacity_span()` 宏，将具有相同计算能力的 CPU 归为一组，并通过全局链表 `asym_cap_list` 管理。这为调度器在异构系统中进行负载均衡和任务迁移提供关键拓扑信息。\n\n### cgroup 权重标准化\n通过 `sched_weight_from_cgroup()` 和 `sched_weight_to_cgroup()`，将 cgroup 接口的权重范围（1–10000，默认 100）映射到调度器内部使用的权重值（基于 1024 基准），确保用户配置与调度行为的一致性。\n\n### SCHED_DEADLINE 与频率调节协同\n引入 `SCHED_FLAG_SUGOV` 标志，允许 `schedutil` 频率调节器的工作线程在需要时临时突破 SCHED_DEADLINE 的优先级限制，以解决某些平台无法原子切换 CPU 频率的问题。这是一种临时性 workaround，依赖于 `dl_entity_is_special()` 进行识别。\n\n### 安全位运算\n`shr_bound()` 宏确保右移操作不会因移位数过大而触发未定义行为（UB），通过 `min_t()` 将移位数限制在 `BITS_PER_TYPE(val) - 1` 以内。\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n- **调度子系统内部**：包含多个调度相关子模块头文件（如 `affinity.h`, `deadline.h`, `topology.h`, `cpupri.h` 等）。\n- **核心内核设施**：依赖 `atomic.h`, `rcupdate.h`, `cpumask_api.h`, `ktime_api.h`, `trace/events/sched.h` 等。\n- **平台与虚拟化**：条件包含 `asm/paravirt.h`（半虚拟化支持）和 `asm/barrier.h`（内存屏障）。\n- **工作队列**：包含 `../workqueue_internal.h`，用于与工作队列子系统交互。\n\n### 配置选项依赖\n- `CONFIG_64BIT`：启用高精度负载计算。\n- `CONFIG_SCHED_DEBUG`：启用 `SCHED_WARN_ON()` 调试检查。\n- `CONFIG_CPU_FREQ_GOV_SCHEDUTIL`：启用 `SCHED_FLAG_SUGOV` 相关逻辑。\n- `CONFIG_SCHED_CLASS_EXT`：扩展调度类支持（影响 `normal_policy()` 判断）。\n- `CONFIG_PARAVIRT`：半虚拟化支持。\n\n## 5. 使用场景\n\n- **调度器初始化与运行**：`scheduler_running` 和负载计算变量在调度器启动和周期性负载更新中使用。\n- **任务调度策略处理**：所有调度类（CFS、RT、Deadline、Idle）在入队、出队、选择下一个任务时，通过策略判断函数确定任务类型。\n- **负载均衡与迁移**：`asym_cap_data` 和 CPU 拓扑信息用于跨 CPU 的任务迁移决策，尤其在异构系统中。\n- **cgroup 资源控制**：在设置或读取 cgroup 的 CPU 权重时，通过权重转换函数确保调度器内部表示与用户接口一致。\n- **实时带宽管理**：`sysctl_sched_rt_*` 参数用于限制 SCHED_FIFO/SCHED_RR 任务的 CPU 使用率。\n- **能效调度协同**：`SCHED_FLAG_SUGOV` 机制使频率调节器能及时响应 Deadline 任务的性能需求。\n- **内核调试与追踪**：`SCHED_WARN_ON()` 用于捕获调度器内部异常状态；tracepoint 定义支持调度事件追踪。",
      "similarity": 0.5377274751663208,
      "chunks": []
    },
    {
      "source_file": "kernel/sched/build_policy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:56:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\build_policy.c`\n\n---\n\n# `sched/build_policy.c` 技术文档\n\n## 1. 文件概述\n\n`build_policy.c` 是 Linux 内核调度子系统中的一个构建辅助文件，其主要作用是将多个与调度策略相关的源代码模块（如实时调度、截止时间调度、CPU 时间统计等）合并到一个编译单元中进行编译。这种设计并非用于实现具体调度逻辑，而是出于**构建效率优化**的目的：通过减少重复包含头文件的开销、平衡各编译单元的大小，从而缩短整体内核编译时间。该文件本身不包含任何函数或数据结构定义，仅通过 `#include` 指令聚合其他 `.c` 文件。\n\n## 2. 核心功能\n\n该文件本身**不定义任何函数或数据结构**，其“功能”体现在所包含的源文件模块中，主要包括：\n\n- **调度策略实现模块**：\n  - `idle.c`：空闲任务（idle task）的调度逻辑\n  - `rt.c`：实时调度类（SCHED_FIFO / SCHED_RR）的实现\n  - `deadline.c`：截止时间调度类（SCHED_DEADLINE）的实现\n  - `cpudeadline.c`（仅在 `CONFIG_SMP` 下）：SMP 架构下截止时间调度的 CPU 负载管理\n  - `ext.c`（仅在 `CONFIG_SCHED_CLASS_EXT` 下）：可扩展调度类支持\n\n- **辅助功能模块**：\n  - `cputime.c`：CPU 时间统计与账户管理\n  - `pelt.c`（仅在 `CONFIG_SMP` 下）：Per-Entity Load Tracking（PELT）负载跟踪机制\n  - `syscalls.c`：调度相关的系统调用（如 `sched_setattr`, `sched_getattr` 等）\n\n## 3. 关键实现\n\n- **单一编译单元聚合**：  \n  通过在一个 `.c` 文件中包含多个功能相关的 `.c` 文件，将原本分散的调度策略代码合并为一个较大的编译单元。这减少了每个源文件单独包含大量公共头文件（如 `sched.h`, `linux/sched/*.h` 等）所带来的重复解析开销。\n\n- **条件编译控制**：  \n  使用 `#ifdef CONFIG_SMP` 和 `#ifdef CONFIG_SCHED_CLASS_EXT` 等宏，确保仅在对应内核配置启用时才包含特定功能模块（如 `cpudeadline.c`、`pelt.c`、`ext.c`），保证构建的灵活性和配置适应性。\n\n- **构建时间平衡**：  \n  注释中明确指出，此编译单元的大小与 `core.c`（调度核心）和 `fair.c`（CFS 完全公平调度器）相当，有助于在并行编译时更均匀地分配工作负载，避免某些编译任务过重而拖慢整体构建速度。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - 调度子系统内部头文件：`\"sched.h\"`, `\"smp.h\"`, `\"autogroup.h\"`, `\"stats.h\"`, `\"pelt.h\"`\n  - 内核通用子系统：`<linux/sched/*.h>`, `<linux/cpuidle.h>`, `<linux/psi.h>`, `<linux/rhashtable.h>` 等\n  - 用户态接口：`<uapi/linux/sched/types.h>`\n\n- **模块依赖**：\n  - 依赖 `core.c` 和 `fair.c` 提供的调度核心框架和 CFS 调度器（但这两者被单独编译）\n  - 所包含的模块（如 `rt.c`, `deadline.c`）依赖调度类注册机制、运行队列管理、负载均衡等核心调度基础设施\n  - `pelt.c` 依赖 SMP 架构下的负载跟踪和迁移逻辑\n\n## 5. 使用场景\n\n- **内核构建阶段**：  \n  该文件仅在内核编译过程中被使用，用于高效地编译调度策略相关代码。最终生成的内核镜像中不包含此文件的独立实体。\n\n- **调度策略运行时**：  \n  虽然 `build_policy.c` 本身不参与运行时逻辑，但它所聚合的模块（如实时调度、截止时间调度、CPU 时间统计等）在以下场景中被激活：\n  - 用户进程使用 `SCHED_FIFO`、`SCHED_RR` 或 `SCHED_DEADLINE` 策略\n  - 系统调用如 `sched_setattr()` 被调用以配置高级调度参数\n  - 内核进行 CPU 负载跟踪（PELT）、空闲 CPU 管理、CPU 热插拔时的调度状态迁移\n  - 能耗管理（如 cpuidle、suspend）与调度器协同工作时\n\n该文件是 Linux 内核构建系统优化的一个典型示例，体现了在大型项目中通过源码组织方式提升编译效率的设计思想。",
      "similarity": 0.5362299084663391,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/build_policy.c",
          "start_line": 1,
          "end_line": 66,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * These are the scheduling policy related scheduler files, built",
            " * in a single compilation unit for build efficiency reasons.",
            " *",
            " * ( Incidentally, the size of the compilation unit is roughly",
            " *   comparable to core.c and fair.c, the other two big",
            " *   compilation units. This helps balance build time, while",
            " *   coalescing source files to amortize header inclusion",
            " *   cost. )",
            " *",
            " * core.c and fair.c are built separately.",
            " */",
            "",
            "/* Headers: */",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/posix-timers.h>",
            "#include <linux/sched/rt.h>",
            "",
            "#include <linux/cpuidle.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kobject.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/pm.h>",
            "#include <linux/psi.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/seqlock_api.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/vtime.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/percpu-rwsem.h>",
            "",
            "#include <uapi/linux/sched/types.h>",
            "",
            "#include \"sched.h\"",
            "#include \"smp.h\"",
            "",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include \"pelt.h\"",
            "",
            "/* Source code modules: */",
            "",
            "#include \"idle.c\"",
            "",
            "#include \"rt.c\"",
            "",
            "#ifdef CONFIG_SMP",
            "# include \"cpudeadline.c\"",
            "# include \"pelt.c\"",
            "#endif",
            "",
            "#include \"cputime.c\"",
            "#include \"deadline.c\"",
            "",
            "#ifdef CONFIG_SCHED_CLASS_EXT",
            "# include \"ext.c\"",
            "#endif",
            "",
            "#include \"syscalls.c\""
          ],
          "function_name": null,
          "description": "此代码段是Linux内核调度器中与调度策略相关的编译单元，核心功能是整合多个调度类（如实时调度、截止时间调度等）的实现，通过条件编译包含不同模块（如`idle.c`、`rt.c`、`deadline.c`等）以提升构建效率。该文件作为调度策略逻辑的聚合点，协调各子模块的实现并管理其依赖关系。",
          "similarity": 0.4441809356212616
        }
      ]
    }
  ]
}