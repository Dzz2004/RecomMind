{
  "query": "Linux文件系统inode结构实现",
  "timestamp": "2025-12-25 23:27:31",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/inode.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:12:33\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\inode.c`\n\n---\n\n# `bpf/inode.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/inode.c` 实现了一个轻量级的虚拟文件系统（称为 **bpffs**），用于支持 eBPF 对象（包括 BPF 程序、映射和链接）的 **pinning（持久化）机制**。该文件系统允许用户空间通过标准文件系统操作（如 `mkdir`、`create`、`unlink` 等）将 BPF 对象绑定到文件系统路径，从而在进程退出后仍能保持对这些对象的引用，避免被内核自动释放。此机制是 `bpf(2)` 系统调用中 `BPF_OBJ_PIN` 和 `BPF_OBJ_GET` 功能的后端支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `enum bpf_type`：枚举类型，标识 BPF 对象类型（`BPF_TYPE_PROG`、`BPF_TYPE_MAP`、`BPF_TYPE_LINK`）。\n- `struct map_iter`：用于 BPF map 序列化遍历的迭代器结构，包含当前 key 和完成标志。\n- `const struct inode_operations`：分别为目录、程序、映射、链接定义的 inode 操作集合（`bpf_dir_iops`、`bpf_prog_iops` 等）。\n- `const struct file_operations`：\n  - `bpffs_map_fops`：支持对支持 `seq_show` 的 BPF map 进行 `cat` 读取。\n  - `bpffs_obj_fops`：通用只读文件操作，打开即返回 `-EIO`，防止误操作。\n\n### 主要函数\n\n- `bpf_any_get()` / `bpf_any_put()`：根据对象类型统一增加/减少引用计数。\n- `bpf_fd_probe_obj()`：通过文件描述符探测并获取对应的 BPF 对象及其类型。\n- `bpf_get_inode()`：为 bpffs 创建新的 inode（支持目录、普通文件、符号链接）。\n- `bpf_inode_type()`：根据 inode 的 `i_op` 字段反推其对应的 BPF 对象类型。\n- `bpf_dentry_finalize()`：完成 dentry 与 inode 的绑定并更新父目录时间戳。\n- `bpf_mkdir()`：实现 bpffs 中的目录创建。\n- `bpf_mkprog()` / `bpf_mkmap()` / `bpf_mklink()`：分别创建 BPF 程序、映射、链接对应的文件 inode。\n- `map_iter_alloc()` / `map_iter_free()`：管理 map 遍历迭代器的生命周期。\n- `map_seq_*` 系列函数：实现 BPF map 的 `seq_file` 遍历接口，用于 `cat` 输出。\n- `bpffs_map_open()` / `bpffs_map_release()`：map 文件的打开与释放，初始化 seq_file 上下文。\n- `bpf_lookup()`：自定义 lookup 逻辑，禁止文件名中包含 `.`（保留用于未来扩展）。\n\n## 3. 关键实现\n\n### BPF 对象引用管理\n通过 `bpf_any_get()` 和 `bpf_any_put()` 封装不同 BPF 对象（prog/map/link）的引用计数操作，确保在 inode 创建和销毁时正确持有/释放内核对象，防止内存泄漏或提前释放。\n\n### 对象类型识别\n利用 `inode->i_op` 指针的唯一性（分别指向 `bpf_prog_iops`、`bpf_map_iops` 等空结构体）作为类型标签，在运行时通过指针比较快速判断 inode 对应的 BPF 对象类型。\n\n### BPF Map 的可读性支持\n对于支持 `map_seq_show_elem` 操作的 BPF map（如 hash、array 等），通过 `seq_file` 机制实现 `cat /sys/fs/bpf/map_name` 输出内容。输出包含警告信息，强调格式不稳定，仅用于调试。\n\n### 安全与扩展性设计\n- 文件名中禁止出现 `.` 字符（如 `foo.bar`），为未来在 bpffs 中引入特殊文件（如元数据、控制接口）预留命名空间。\n- 普通 BPF 对象文件（prog/link 或不支持 seq_show 的 map）使用 `bpffs_obj_fops`，其 `open` 返回 `-EIO`，防止用户误读/误写导致未定义行为。\n\n### 虚拟文件系统集成\n基于 `simple_fs` 框架（如 `simple_dir_operations`、`simple_lookup`）构建，仅重写必要操作（如 `mkdir`、`lookup`、`create` 逻辑由上层调用 `bpf_mk*` 实现），保持代码简洁。\n\n## 4. 依赖关系\n\n- **BPF 子系统核心**：依赖 `<linux/bpf.h>`、`<linux/filter.h>` 提供的 `bpf_prog_*`、`bpf_map_*`、`bpf_link_*` 等核心 API。\n- **VFS 层**：依赖标准 VFS 接口（`<linux/fs.h>`、`<linux/namei.h>`、`<linux/dcache.h>`）实现 inode、dentry、file 操作。\n- **预加载机制**：包含 `\"preload/bpf_preload.h\"`，可能用于内核启动时预加载 BPF 对象。\n- **迭代器支持**：若 BPF link 为 iterator 类型，会使用 `bpf_iter_fops`（定义在其他文件中）。\n\n## 5. 使用场景\n\n- **BPF 对象持久化**：用户空间工具（如 `bpftool`）调用 `bpf(BPF_OBJ_PIN, ...)` 将 map/prog/link pin 到 `/sys/fs/bpf/` 下的路径，内核通过本文件创建对应 inode 并持有对象引用。\n- **跨进程共享 BPF 对象**：多个进程可通过 `bpf(BPF_OBJ_GET, ...)` 从同一 bpffs 路径获取已 pin 对象的 fd，实现共享。\n- **调试与可观测性**：支持 `seq_show` 的 map 可通过 `cat` 命令查看内容，辅助开发调试（注意：非稳定接口）。\n- **系统启动预加载**：结合 `bpf_preload` 机制，在内核初始化阶段将关键 BPF 程序/映射 pin 到 bpffs，供后续服务使用。",
      "similarity": 0.6060532331466675,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 680,
          "end_line": 783,
          "content": [
            "static void seq_print_delegate_opts(struct seq_file *m,",
            "\t\t\t\t    const char *opt_name,",
            "\t\t\t\t    const struct btf *btf,",
            "\t\t\t\t    const struct btf_type *enum_t,",
            "\t\t\t\t    const char *prefix,",
            "\t\t\t\t    u64 delegate_msk, u64 any_msk)",
            "{",
            "\tconst struct btf_enum *e;",
            "\tbool first = true;",
            "\tconst char *name;",
            "\tu64 msk;",
            "\tint i, n, pfx_len = strlen(prefix);",
            "",
            "\tdelegate_msk &= any_msk; /* clear unknown bits */",
            "",
            "\tif (delegate_msk == 0)",
            "\t\treturn;",
            "",
            "\tseq_printf(m, \",%s\", opt_name);",
            "\tif (delegate_msk == any_msk) {",
            "\t\tseq_printf(m, \"=any\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (btf && enum_t) {",
            "\t\tfor (i = 0, n = btf_vlen(enum_t); i < n; i++) {",
            "\t\t\te = &btf_enum(enum_t)[i];",
            "\t\t\tname = btf_name_by_offset(btf, e->name_off);",
            "\t\t\tif (!name || strncasecmp(name, prefix, pfx_len) != 0)",
            "\t\t\t\tcontinue;",
            "\t\t\tmsk = 1ULL << e->val;",
            "\t\t\tif (delegate_msk & msk) {",
            "\t\t\t\t/* emit lower-case name without prefix */",
            "\t\t\t\tseq_printf(m, \"%c\", first ? '=' : ':');",
            "\t\t\t\tname += pfx_len;",
            "\t\t\t\twhile (*name) {",
            "\t\t\t\t\tseq_printf(m, \"%c\", tolower(*name));",
            "\t\t\t\t\tname++;",
            "\t\t\t\t}",
            "",
            "\t\t\t\tdelegate_msk &= ~msk;",
            "\t\t\t\tfirst = false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif (delegate_msk)",
            "\t\tseq_printf(m, \"%c0x%llx\", first ? '=' : ':', delegate_msk);",
            "}",
            "static int bpf_show_options(struct seq_file *m, struct dentry *root)",
            "{",
            "\tstruct inode *inode = d_inode(root);",
            "\tumode_t mode = inode->i_mode & S_IALLUGO & ~S_ISVTX;",
            "\tstruct bpf_mount_opts *opts = root->d_sb->s_fs_info;",
            "\tu64 mask;",
            "",
            "\tif (!uid_eq(inode->i_uid, GLOBAL_ROOT_UID))",
            "\t\tseq_printf(m, \",uid=%u\",",
            "\t\t\t   from_kuid_munged(&init_user_ns, inode->i_uid));",
            "\tif (!gid_eq(inode->i_gid, GLOBAL_ROOT_GID))",
            "\t\tseq_printf(m, \",gid=%u\",",
            "\t\t\t   from_kgid_munged(&init_user_ns, inode->i_gid));",
            "\tif (mode != S_IRWXUGO)",
            "\t\tseq_printf(m, \",mode=%o\", mode);",
            "",
            "\tif (opts->delegate_cmds || opts->delegate_maps ||",
            "\t    opts->delegate_progs || opts->delegate_attachs) {",
            "\t\tstruct bpffs_btf_enums info;",
            "",
            "\t\t/* ignore errors, fallback to hex */",
            "\t\t(void)find_bpffs_btf_enums(&info);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_cmds\",",
            "\t\t\t\t\tinfo.btf, info.cmd_t, \"BPF_\",",
            "\t\t\t\t\topts->delegate_cmds, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_maps\",",
            "\t\t\t\t\tinfo.btf, info.map_t, \"BPF_MAP_TYPE_\",",
            "\t\t\t\t\topts->delegate_maps, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_progs\",",
            "\t\t\t\t\tinfo.btf, info.prog_t, \"BPF_PROG_TYPE_\",",
            "\t\t\t\t\topts->delegate_progs, mask);",
            "",
            "\t\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\t\tseq_print_delegate_opts(m, \"delegate_attachs\",",
            "\t\t\t\t\tinfo.btf, info.attach_t, \"BPF_\",",
            "\t\t\t\t\topts->delegate_attachs, mask);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_free_inode(struct inode *inode)",
            "{",
            "\tenum bpf_type type;",
            "",
            "\tif (S_ISLNK(inode->i_mode))",
            "\t\tkfree(inode->i_link);",
            "\tif (!bpf_inode_type(inode, &type))",
            "\t\tbpf_any_put(inode->i_private, type);",
            "\tfree_inode_nonrcu(inode);",
            "}"
          ],
          "function_name": "seq_print_delegate_opts, bpf_show_options, bpf_free_inode",
          "description": "展示文件系统挂载参数，处理委托选项打印及inode释放时的资源回收操作",
          "similarity": 0.6453067064285278
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 53,
          "end_line": 155,
          "content": [
            "static void bpf_any_put(void *raw, enum bpf_type type)",
            "{",
            "\tswitch (type) {",
            "\tcase BPF_TYPE_PROG:",
            "\t\tbpf_prog_put(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_MAP:",
            "\t\tbpf_map_put_with_uref(raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_LINK:",
            "\t\tbpf_link_put(raw);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "}",
            "static int bpf_inode_type(const struct inode *inode, enum bpf_type *type)",
            "{",
            "\t*type = BPF_TYPE_UNSPEC;",
            "\tif (inode->i_op == &bpf_prog_iops)",
            "\t\t*type = BPF_TYPE_PROG;",
            "\telse if (inode->i_op == &bpf_map_iops)",
            "\t\t*type = BPF_TYPE_MAP;",
            "\telse if (inode->i_op == &bpf_link_iops)",
            "\t\t*type = BPF_TYPE_LINK;",
            "\telse",
            "\t\treturn -EACCES;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,",
            "\t\t\t\tstruct inode *dir)",
            "{",
            "\td_instantiate(dentry, inode);",
            "\tdget(dentry);",
            "",
            "\tdir->i_mtime = inode_set_ctime_current(dir);",
            "}",
            "static int bpf_mkdir(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t     struct dentry *dentry, umode_t mode)",
            "{",
            "\tstruct inode *inode;",
            "",
            "\tinode = bpf_get_inode(dir->i_sb, dir, mode | S_IFDIR);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_dir_iops;",
            "\tinode->i_fop = &simple_dir_operations;",
            "",
            "\tinc_nlink(inode);",
            "\tinc_nlink(dir);",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static void map_iter_free(struct map_iter *iter)",
            "{",
            "\tif (iter) {",
            "\t\tkfree(iter->key);",
            "\t\tkfree(iter);",
            "\t}",
            "}",
            "static void map_seq_stop(struct seq_file *m, void *v)",
            "{",
            "}",
            "static int map_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct bpf_map *map = seq_file_to_map(m);",
            "\tvoid *key = map_iter(m)->key;",
            "",
            "\tif (unlikely(v == SEQ_START_TOKEN)) {",
            "\t\tseq_puts(m, \"# WARNING!! The output is for debug purpose only\\n\");",
            "\t\tseq_puts(m, \"# WARNING!! The output format will change\\n\");",
            "\t} else {",
            "\t\tmap->ops->map_seq_show_elem(map, key, m);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int bpffs_map_open(struct inode *inode, struct file *file)",
            "{",
            "\tstruct bpf_map *map = inode->i_private;",
            "\tstruct map_iter *iter;",
            "\tstruct seq_file *m;",
            "\tint err;",
            "",
            "\titer = map_iter_alloc(map);",
            "\tif (!iter)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = seq_open(file, &bpffs_map_seq_ops);",
            "\tif (err) {",
            "\t\tmap_iter_free(iter);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tm = file->private_data;",
            "\tm->private = iter;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_any_put, bpf_inode_type, bpf_dentry_finalize, bpf_mkdir, map_iter_free, map_seq_stop, map_seq_show, bpffs_map_open",
          "description": "实现BPF对象引用释放逻辑，inode类型识别，目录创建，迭代器管理及序列化展示功能",
          "similarity": 0.6433961391448975
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 479,
          "end_line": 593,
          "content": [
            "int bpf_obj_pin_user(u32 ufd, int path_fd, const char __user *pathname)",
            "{",
            "\tenum bpf_type type;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\traw = bpf_fd_probe_obj(ufd, &type);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tret = bpf_obj_do_pin(path_fd, pathname, raw, type);",
            "\tif (ret != 0)",
            "\t\tbpf_any_put(raw, type);",
            "",
            "\treturn ret;",
            "}",
            "int bpf_obj_get_user(int path_fd, const char __user *pathname, int flags)",
            "{",
            "\tenum bpf_type type = BPF_TYPE_UNSPEC;",
            "\tint f_flags;",
            "\tvoid *raw;",
            "\tint ret;",
            "",
            "\tf_flags = bpf_get_file_flag(flags);",
            "\tif (f_flags < 0)",
            "\t\treturn f_flags;",
            "",
            "\traw = bpf_obj_do_get(path_fd, pathname, &type, f_flags);",
            "\tif (IS_ERR(raw))",
            "\t\treturn PTR_ERR(raw);",
            "",
            "\tif (type == BPF_TYPE_PROG)",
            "\t\tret = bpf_prog_new_fd(raw);",
            "\telse if (type == BPF_TYPE_MAP)",
            "\t\tret = bpf_map_new_fd(raw, f_flags);",
            "\telse if (type == BPF_TYPE_LINK)",
            "\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);",
            "\telse",
            "\t\treturn -ENOENT;",
            "",
            "\tif (ret < 0)",
            "\t\tbpf_any_put(raw, type);",
            "\treturn ret;",
            "}",
            "static int find_bpffs_btf_enums(struct bpffs_btf_enums *info)",
            "{",
            "\tconst struct btf *btf;",
            "\tconst struct btf_type *t;",
            "\tconst char *name;",
            "\tint i, n;",
            "",
            "\tmemset(info, 0, sizeof(*info));",
            "",
            "\tbtf = bpf_get_btf_vmlinux();",
            "\tif (IS_ERR(btf))",
            "\t\treturn PTR_ERR(btf);",
            "\tif (!btf)",
            "\t\treturn -ENOENT;",
            "",
            "\tinfo->btf = btf;",
            "",
            "\tfor (i = 1, n = btf_nr_types(btf); i < n; i++) {",
            "\t\tt = btf_type_by_id(btf, i);",
            "\t\tif (!btf_type_is_enum(t))",
            "\t\t\tcontinue;",
            "",
            "\t\tname = btf_name_by_offset(btf, t->name_off);",
            "\t\tif (!name)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (strcmp(name, \"bpf_cmd\") == 0)",
            "\t\t\tinfo->cmd_t = t;",
            "\t\telse if (strcmp(name, \"bpf_map_type\") == 0)",
            "\t\t\tinfo->map_t = t;",
            "\t\telse if (strcmp(name, \"bpf_prog_type\") == 0)",
            "\t\t\tinfo->prog_t = t;",
            "\t\telse if (strcmp(name, \"bpf_attach_type\") == 0)",
            "\t\t\tinfo->attach_t = t;",
            "\t\telse",
            "\t\t\tcontinue;",
            "",
            "\t\tif (info->cmd_t && info->map_t && info->prog_t && info->attach_t)",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\treturn -ESRCH;",
            "}",
            "static bool find_btf_enum_const(const struct btf *btf, const struct btf_type *enum_t,",
            "\t\t\t\tconst char *prefix, const char *str, int *value)",
            "{",
            "\tconst struct btf_enum *e;",
            "\tconst char *name;",
            "\tint i, n, pfx_len = strlen(prefix);",
            "",
            "\t*value = 0;",
            "",
            "\tif (!btf || !enum_t)",
            "\t\treturn false;",
            "",
            "\tfor (i = 0, n = btf_vlen(enum_t); i < n; i++) {",
            "\t\te = &btf_enum(enum_t)[i];",
            "",
            "\t\tname = btf_name_by_offset(btf, e->name_off);",
            "\t\tif (!name || strncasecmp(name, prefix, pfx_len) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* match symbolic name case insensitive and ignoring prefix */",
            "\t\tif (strcasecmp(name + pfx_len, str) == 0) {",
            "\t\t\t*value = e->val;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "bpf_obj_pin_user, bpf_obj_get_user, find_bpffs_btf_enums, find_btf_enum_const",
          "description": "实现用户空间对象pin操作，对象获取逻辑及BTF枚举常量解析功能",
          "similarity": 0.5231128931045532
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 296,
          "end_line": 425,
          "content": [
            "static int bpffs_map_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seq_file *m = file->private_data;",
            "",
            "\tmap_iter_free(map_iter(m));",
            "",
            "\treturn seq_release(inode, file);",
            "}",
            "static int bpffs_obj_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn -EIO;",
            "}",
            "static int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,",
            "\t\t\t const struct inode_operations *iops,",
            "\t\t\t const struct file_operations *fops)",
            "{",
            "\tstruct inode *dir = dentry->d_parent->d_inode;",
            "\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = iops;",
            "\tinode->i_fop = fops;",
            "\tinode->i_private = raw;",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static int bpf_mkprog(struct dentry *dentry, umode_t mode, void *arg)",
            "{",
            "\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_prog_iops,",
            "\t\t\t     &bpffs_obj_fops);",
            "}",
            "static int bpf_mkmap(struct dentry *dentry, umode_t mode, void *arg)",
            "{",
            "\tstruct bpf_map *map = arg;",
            "",
            "\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_map_iops,",
            "\t\t\t     bpf_map_support_seq_show(map) ?",
            "\t\t\t     &bpffs_map_fops : &bpffs_obj_fops);",
            "}",
            "static int bpf_mklink(struct dentry *dentry, umode_t mode, void *arg)",
            "{",
            "\tstruct bpf_link *link = arg;",
            "",
            "\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_link_iops,",
            "\t\t\t     bpf_link_is_iter(link) ?",
            "\t\t\t     &bpf_iter_fops : &bpffs_obj_fops);",
            "}",
            "static int bpf_symlink(struct mnt_idmap *idmap, struct inode *dir,",
            "\t\t       struct dentry *dentry, const char *target)",
            "{",
            "\tchar *link = kstrdup(target, GFP_USER | __GFP_NOWARN);",
            "\tstruct inode *inode;",
            "",
            "\tif (!link)",
            "\t\treturn -ENOMEM;",
            "",
            "\tinode = bpf_get_inode(dir->i_sb, dir, S_IRWXUGO | S_IFLNK);",
            "\tif (IS_ERR(inode)) {",
            "\t\tkfree(link);",
            "\t\treturn PTR_ERR(inode);",
            "\t}",
            "",
            "\tinode->i_op = &simple_symlink_inode_operations;",
            "\tinode->i_link = link;",
            "",
            "\tbpf_dentry_finalize(dentry, inode, dir);",
            "\treturn 0;",
            "}",
            "static int bpf_iter_link_pin_kernel(struct dentry *parent,",
            "\t\t\t\t    const char *name, struct bpf_link *link)",
            "{",
            "\tumode_t mode = S_IFREG | S_IRUSR;",
            "\tstruct dentry *dentry;",
            "\tint ret;",
            "",
            "\tinode_lock(parent->d_inode);",
            "\tdentry = lookup_one_len(name, parent, strlen(name));",
            "\tif (IS_ERR(dentry)) {",
            "\t\tinode_unlock(parent->d_inode);",
            "\t\treturn PTR_ERR(dentry);",
            "\t}",
            "\tret = bpf_mkobj_ops(dentry, mode, link, &bpf_link_iops,",
            "\t\t\t    &bpf_iter_fops);",
            "\tdput(dentry);",
            "\tinode_unlock(parent->d_inode);",
            "\treturn ret;",
            "}",
            "static int bpf_obj_do_pin(int path_fd, const char __user *pathname, void *raw,",
            "\t\t\t  enum bpf_type type)",
            "{",
            "\tstruct dentry *dentry;",
            "\tstruct inode *dir;",
            "\tstruct path path;",
            "\tumode_t mode;",
            "\tint ret;",
            "",
            "\tdentry = user_path_create(path_fd, pathname, &path, 0);",
            "\tif (IS_ERR(dentry))",
            "\t\treturn PTR_ERR(dentry);",
            "",
            "\tdir = d_inode(path.dentry);",
            "\tif (dir->i_op != &bpf_dir_iops) {",
            "\t\tret = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tret = security_path_mknod(&path, dentry, mode, 0);",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tswitch (type) {",
            "\tcase BPF_TYPE_PROG:",
            "\t\tret = vfs_mkobj(dentry, mode, bpf_mkprog, raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_MAP:",
            "\t\tret = vfs_mkobj(dentry, mode, bpf_mkmap, raw);",
            "\t\tbreak;",
            "\tcase BPF_TYPE_LINK:",
            "\t\tret = vfs_mkobj(dentry, mode, bpf_mklink, raw);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tret = -EPERM;",
            "\t}",
            "out:",
            "\tdone_path_create(&path, dentry);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpffs_map_release, bpffs_obj_open, bpf_mkobj_ops, bpf_mkprog, bpf_mkmap, bpf_mklink, bpf_symlink, bpf_iter_link_pin_kernel, bpf_obj_do_pin",
          "description": "提供对象创建接口，符号链接处理，链接对象挂载及对象pin操作实现",
          "similarity": 0.508031964302063
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/inode.c",
          "start_line": 818,
          "end_line": 943,
          "content": [
            "static int bpf_parse_param(struct fs_context *fc, struct fs_parameter *param)",
            "{",
            "\tstruct bpf_mount_opts *opts = fc->s_fs_info;",
            "\tstruct fs_parse_result result;",
            "\tkuid_t uid;",
            "\tkgid_t gid;",
            "\tint opt, err;",
            "",
            "\topt = fs_parse(fc, bpf_fs_parameters, param, &result);",
            "\tif (opt < 0) {",
            "\t\t/* We might like to report bad mount options here, but",
            "\t\t * traditionally we've ignored all mount options, so we'd",
            "\t\t * better continue to ignore non-existing options for bpf.",
            "\t\t */",
            "\t\tif (opt == -ENOPARAM) {",
            "\t\t\topt = vfs_parse_fs_param_source(fc, param);",
            "\t\t\tif (opt != -ENOPARAM)",
            "\t\t\t\treturn opt;",
            "",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\tif (opt < 0)",
            "\t\t\treturn opt;",
            "\t}",
            "",
            "\tswitch (opt) {",
            "\tcase OPT_UID:",
            "\t\tuid = make_kuid(current_user_ns(), result.uint_32);",
            "\t\tif (!uid_valid(uid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\t/*",
            "\t\t * The requested uid must be representable in the",
            "\t\t * filesystem's idmapping.",
            "\t\t */",
            "\t\tif (!kuid_has_mapping(fc->user_ns, uid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\topts->uid = uid;",
            "\t\tbreak;",
            "\tcase OPT_GID:",
            "\t\tgid = make_kgid(current_user_ns(), result.uint_32);",
            "\t\tif (!gid_valid(gid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\t/*",
            "\t\t * The requested gid must be representable in the",
            "\t\t * filesystem's idmapping.",
            "\t\t */",
            "\t\tif (!kgid_has_mapping(fc->user_ns, gid))",
            "\t\t\tgoto bad_value;",
            "",
            "\t\topts->gid = gid;",
            "\t\tbreak;",
            "\tcase OPT_MODE:",
            "\t\topts->mode = result.uint_32 & S_IALLUGO;",
            "\t\tbreak;",
            "\tcase OPT_DELEGATE_CMDS:",
            "\tcase OPT_DELEGATE_MAPS:",
            "\tcase OPT_DELEGATE_PROGS:",
            "\tcase OPT_DELEGATE_ATTACHS: {",
            "\t\tstruct bpffs_btf_enums info;",
            "\t\tconst struct btf_type *enum_t;",
            "\t\tconst char *enum_pfx;",
            "\t\tu64 *delegate_msk, msk = 0;",
            "\t\tchar *p, *str;",
            "\t\tint val;",
            "",
            "\t\t/* ignore errors, fallback to hex */",
            "\t\t(void)find_bpffs_btf_enums(&info);",
            "",
            "\t\tswitch (opt) {",
            "\t\tcase OPT_DELEGATE_CMDS:",
            "\t\t\tdelegate_msk = &opts->delegate_cmds;",
            "\t\t\tenum_t = info.cmd_t;",
            "\t\t\tenum_pfx = \"BPF_\";",
            "\t\t\tbreak;",
            "\t\tcase OPT_DELEGATE_MAPS:",
            "\t\t\tdelegate_msk = &opts->delegate_maps;",
            "\t\t\tenum_t = info.map_t;",
            "\t\t\tenum_pfx = \"BPF_MAP_TYPE_\";",
            "\t\t\tbreak;",
            "\t\tcase OPT_DELEGATE_PROGS:",
            "\t\t\tdelegate_msk = &opts->delegate_progs;",
            "\t\t\tenum_t = info.prog_t;",
            "\t\t\tenum_pfx = \"BPF_PROG_TYPE_\";",
            "\t\t\tbreak;",
            "\t\tcase OPT_DELEGATE_ATTACHS:",
            "\t\t\tdelegate_msk = &opts->delegate_attachs;",
            "\t\t\tenum_t = info.attach_t;",
            "\t\t\tenum_pfx = \"BPF_\";",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tstr = param->string;",
            "\t\twhile ((p = strsep(&str, \":\"))) {",
            "\t\t\tif (strcmp(p, \"any\") == 0) {",
            "\t\t\t\tmsk |= ~0ULL;",
            "\t\t\t} else if (find_btf_enum_const(info.btf, enum_t, enum_pfx, p, &val)) {",
            "\t\t\t\tmsk |= 1ULL << val;",
            "\t\t\t} else {",
            "\t\t\t\terr = kstrtou64(p, 0, &msk);",
            "\t\t\t\tif (err)",
            "\t\t\t\t\treturn err;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/* Setting delegation mount options requires privileges */",
            "\t\tif (msk && !capable(CAP_SYS_ADMIN))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t*delegate_msk |= msk;",
            "\t\tbreak;",
            "\t}",
            "\tdefault:",
            "\t\t/* ignore unknown mount options */",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn 0;",
            "bad_value:",
            "\treturn invalfc(fc, \"Bad value for '%s'\", param->key);",
            "}"
          ],
          "function_name": "bpf_parse_param",
          "description": "解析并验证BPF文件系统的挂载参数，处理UID/GID/模式及委托选项，检查值的有效性并设置到mount选项结构体中",
          "similarity": 0.47599223256111145
        }
      ]
    },
    {
      "source_file": "kernel/audit_watch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:52:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit_watch.c`\n\n---\n\n# audit_watch.c 技术文档\n\n## 1. 文件概述\n\n`audit_watch.c` 是 Linux 内核审计子系统（Audit Subsystem）中用于实现文件路径监控的核心模块。该文件通过与 `fsnotify` 机制集成，实现对指定路径的动态 inode 监控。当被监控的文件或目录发生创建、删除、移动或卸载等事件时，审计系统能够自动更新规则中关联的 inode 信息，确保审计规则持续有效。该机制解决了传统基于路径的监控在文件系统结构变化时失效的问题。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct audit_watch`**  \n  表示一个审计监控项，包含：\n  - `count`：引用计数\n  - `dev` / `ino`：关联的设备号和 inode 号（初始为未设置状态）\n  - `path`：原始监控路径字符串\n  - `parent`：指向所属父目录的 `audit_parent` 结构\n  - `wlist`：挂载到父目录监控列表的链表节点\n  - `rules`：关联的审计规则链表头\n\n- **`struct audit_parent`**  \n  表示被监控路径的父目录，包含：\n  - `watches`：该父目录下所有 `audit_watch` 的链表头\n  - `mark`：嵌入的 `fsnotify_mark`，用于注册到 VFS 通知系统\n\n### 主要函数\n\n- **`audit_to_watch()`**  \n  将用户空间传入的路径字符串转换为内核 `audit_watch` 对象，并绑定到审计规则\n\n- **`audit_init_watch()` / `audit_init_parent()`**  \n  初始化 `audit_watch` 和 `audit_parent` 结构\n\n- **`audit_dupe_watch()`**  \n  复制监控项（用于 inode 变更时的规则更新）\n\n- **`audit_update_watch()`**  \n  核心回调函数，处理文件系统事件（如重命名、删除）并更新所有关联规则的 inode 信息\n\n- **`audit_watch_compare()`**  \n  比较监控项与给定 inode/dev 是否匹配\n\n- **`audit_get_watch()` / `audit_put_watch()`**  \n  引用计数管理接口\n\n- **`audit_remove_watch()`**  \n  从父目录监控列表中移除监控项\n\n## 3. 关键实现\n\n### 引用计数机制\n- **`audit_watch`**：使用 `refcount_t` 管理生命周期，每个关联的审计规则持有引用\n- **`audit_parent`**：通过 `fsnotify_mark` 的引用计数管理，每个子监控项持有父目录引用\n\n### fsnotify 集成\n- 创建专用 `fsnotify_group` (`audit_watch_group`)\n- 监控事件类型：`FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF | FS_MOVE_SELF | FS_UNMOUNT`\n- 通过 `fsnotify_add_inode_mark()` 在父目录 inode 上注册监控标记\n\n### 动态 inode 更新流程\n1. 文件系统事件触发 `audit_update_watch()` 回调\n2. 根据事件中的 dentry 名称匹配对应 `audit_watch`\n3. 创建新 `audit_watch` 副本并更新 inode/dev 信息\n4. 遍历原监控项关联的所有规则：\n   - 从旧 inode 哈希表移除规则\n   - 创建规则副本并绑定到新监控项\n   - 插入新 inode 对应的哈希表\n5. 记录配置变更日志（`AUDIT_CONFIG_CHANGE`）\n\n### 路径解析策略\n- 仅支持绝对路径（以 `/` 开头）\n- 不支持目录路径（路径末尾不能为 `/`）\n- 仅允许用于 `AUDIT_FILTER_EXIT` 和 `AUDIT_FILTER_URING_EXIT` 规则类型\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `fsnotify` 子系统（`<linux/fsnotify_backend.h>`）：提供文件系统事件通知\n  - 审计核心模块（`audit.h`）：规则管理、日志记录、哈希表操作\n  - VFS 层（`<linux/fs.h>`, `<linux/namei.h>`）：inode/dentry 操作\n\n- **关键交互**：\n  - 通过 `audit_filter_mutex` 与审计规则管理模块同步\n  - 调用 `audit_filter_inodes()` 确保事件发生时的审计记录完整性\n  - 使用 `audit_inode_hash` 哈希表管理基于 inode 的规则索引\n\n## 5. 使用场景\n\n1. **审计规则动态维护**  \n   当用户通过 `auditctl -w /path/to/file` 添加路径监控时，内核将路径解析为 inode 并注册 fsnotify 监控。后续文件移动/重命名时自动更新规则绑定的 inode。\n\n2. **文件系统事件响应**  \n   处理以下场景：\n   - 文件被移动到监控目录（触发 `FS_CREATE`）\n   - 监控文件被重命名（触发 `FS_MOVE`）\n   - 监控目录被卸载（触发 `FS_UNMOUNT`）\n   - 监控文件被删除（触发 `FS_DELETE`）\n\n3. **审计日志完整性保障**  \n   在 inode 变更过程中，通过 `audit_filter_inodes()` 确保变更期间的系统调用仍能被正确审计，避免监控间隙。\n\n4. **资源生命周期管理**  \n   通过引用计数确保：\n   - 规则存在时监控项不被释放\n   - 父目录无监控项时自动清理 fsnotify 标记\n   - 路径字符串内存的安全回收",
      "similarity": 0.5980945825576782,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/audit_watch.c",
          "start_line": 322,
          "end_line": 437,
          "content": [
            "static void audit_remove_parent_watches(struct audit_parent *parent)",
            "{",
            "\tstruct audit_watch *w, *nextw;",
            "\tstruct audit_krule *r, *nextr;",
            "\tstruct audit_entry *e;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {",
            "\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {",
            "\t\t\te = container_of(r, struct audit_entry, rule);",
            "\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");",
            "\t\t\tif (e->rule.exe)",
            "\t\t\t\taudit_remove_mark(e->rule.exe);",
            "\t\t\tlist_del(&r->rlist);",
            "\t\t\tlist_del(&r->list);",
            "\t\t\tlist_del_rcu(&e->list);",
            "\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "\t\taudit_remove_watch(w);",
            "\t}",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);",
            "}",
            "static int audit_get_nd(struct audit_watch *watch, struct path *parent)",
            "{",
            "\tstruct dentry *d = kern_path_locked(watch->path, parent);",
            "\tif (IS_ERR(d))",
            "\t\treturn PTR_ERR(d);",
            "\tif (d_is_positive(d)) {",
            "\t\t/* update watch filter fields */",
            "\t\twatch->dev = d->d_sb->s_dev;",
            "\t\twatch->ino = d_backing_inode(d)->i_ino;",
            "\t}",
            "\tinode_unlock(d_backing_inode(parent->dentry));",
            "\tdput(d);",
            "\treturn 0;",
            "}",
            "static void audit_add_to_parent(struct audit_krule *krule,",
            "\t\t\t\tstruct audit_parent *parent)",
            "{",
            "\tstruct audit_watch *w, *watch = krule->watch;",
            "\tint watch_found = 0;",
            "",
            "\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));",
            "",
            "\tlist_for_each_entry(w, &parent->watches, wlist) {",
            "\t\tif (strcmp(watch->path, w->path))",
            "\t\t\tcontinue;",
            "",
            "\t\twatch_found = 1;",
            "",
            "\t\t/* put krule's ref to temporary watch */",
            "\t\taudit_put_watch(watch);",
            "",
            "\t\taudit_get_watch(w);",
            "\t\tkrule->watch = watch = w;",
            "",
            "\t\taudit_put_parent(parent);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tif (!watch_found) {",
            "\t\twatch->parent = parent;",
            "",
            "\t\taudit_get_watch(watch);",
            "\t\tlist_add(&watch->wlist, &parent->watches);",
            "\t}",
            "\tlist_add(&krule->rlist, &watch->rules);",
            "}",
            "int audit_add_watch(struct audit_krule *krule, struct list_head **list)",
            "{",
            "\tstruct audit_watch *watch = krule->watch;",
            "\tstruct audit_parent *parent;",
            "\tstruct path parent_path;",
            "\tint h, ret = 0;",
            "",
            "\t/*",
            "\t * When we will be calling audit_add_to_parent, krule->watch might have",
            "\t * been updated and watch might have been freed.",
            "\t * So we need to keep a reference of watch.",
            "\t */",
            "\taudit_get_watch(watch);",
            "",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t/* Avoid calling path_lookup under audit_filter_mutex. */",
            "\tret = audit_get_nd(watch, &parent_path);",
            "",
            "\t/* caller expects mutex locked */",
            "\tmutex_lock(&audit_filter_mutex);",
            "",
            "\tif (ret) {",
            "\t\taudit_put_watch(watch);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/* either find an old parent or attach a new one */",
            "\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));",
            "\tif (!parent) {",
            "\t\tparent = audit_init_parent(&parent_path);",
            "\t\tif (IS_ERR(parent)) {",
            "\t\t\tret = PTR_ERR(parent);",
            "\t\t\tgoto error;",
            "\t\t}",
            "\t}",
            "",
            "\taudit_add_to_parent(krule, parent);",
            "",
            "\th = audit_hash_ino((u32)watch->ino);",
            "\t*list = &audit_inode_hash[h];",
            "error:",
            "\tpath_put(&parent_path);",
            "\taudit_put_watch(watch);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "audit_remove_parent_watches, audit_get_nd, audit_add_to_parent, audit_add_watch",
          "description": "提供了将审计规则附加到文件系统路径的实现，包含路径解析、现有监视器查找替换逻辑，以及根据文件系统变更事件更新审计规则的机制。",
          "similarity": 0.5378087759017944
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/audit_watch.c",
          "start_line": 447,
          "end_line": 533,
          "content": [
            "void audit_remove_watch_rule(struct audit_krule *krule)",
            "{",
            "\tstruct audit_watch *watch = krule->watch;",
            "\tstruct audit_parent *parent = watch->parent;",
            "",
            "\tlist_del(&krule->rlist);",
            "",
            "\tif (list_empty(&watch->rules)) {",
            "\t\t/*",
            "\t\t * audit_remove_watch() drops our reference to 'parent' which",
            "\t\t * can get freed. Grab our own reference to be safe.",
            "\t\t */",
            "\t\taudit_get_parent(parent);",
            "\t\taudit_remove_watch(watch);",
            "\t\tif (list_empty(&parent->watches))",
            "\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);",
            "\t\taudit_put_parent(parent);",
            "\t}",
            "}",
            "static int audit_watch_handle_event(struct fsnotify_mark *inode_mark, u32 mask,",
            "\t\t\t\t    struct inode *inode, struct inode *dir,",
            "\t\t\t\t    const struct qstr *dname, u32 cookie)",
            "{",
            "\tstruct audit_parent *parent;",
            "",
            "\tparent = container_of(inode_mark, struct audit_parent, mark);",
            "",
            "\tif (WARN_ON_ONCE(inode_mark->group != audit_watch_group))",
            "\t\treturn 0;",
            "",
            "\tif (mask & (FS_CREATE|FS_MOVED_TO) && inode)",
            "\t\taudit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);",
            "\telse if (mask & (FS_DELETE|FS_MOVED_FROM))",
            "\t\taudit_update_watch(parent, dname, AUDIT_DEV_UNSET, AUDIT_INO_UNSET, 1);",
            "\telse if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))",
            "\t\taudit_remove_parent_watches(parent);",
            "",
            "\treturn 0;",
            "}",
            "static int __init audit_watch_init(void)",
            "{",
            "\taudit_watch_group = fsnotify_alloc_group(&audit_watch_fsnotify_ops, 0);",
            "\tif (IS_ERR(audit_watch_group)) {",
            "\t\taudit_watch_group = NULL;",
            "\t\taudit_panic(\"cannot create audit fsnotify group\");",
            "\t}",
            "\treturn 0;",
            "}",
            "int audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)",
            "{",
            "\tstruct audit_fsnotify_mark *audit_mark;",
            "\tchar *pathname;",
            "",
            "\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);",
            "\tif (!pathname)",
            "\t\treturn -ENOMEM;",
            "",
            "\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));",
            "\tif (IS_ERR(audit_mark)) {",
            "\t\tkfree(pathname);",
            "\t\treturn PTR_ERR(audit_mark);",
            "\t}",
            "\tnew->exe = audit_mark;",
            "",
            "\treturn 0;",
            "}",
            "int audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)",
            "{",
            "\tstruct file *exe_file;",
            "\tunsigned long ino;",
            "\tdev_t dev;",
            "",
            "\t/* only do exe filtering if we are recording @current events/records */",
            "\tif (tsk != current)",
            "\t\treturn 0;",
            "",
            "\tif (!current->mm)",
            "\t\treturn 0;",
            "\texe_file = get_mm_exe_file(current->mm);",
            "\tif (!exe_file)",
            "\t\treturn 0;",
            "\tino = file_inode(exe_file)->i_ino;",
            "\tdev = file_inode(exe_file)->i_sb->s_dev;",
            "\tfput(exe_file);",
            "",
            "\treturn audit_mark_compare(mark, ino, dev);",
            "}"
          ],
          "function_name": "audit_remove_watch_rule, audit_watch_handle_event, audit_watch_init, audit_dupe_exe, audit_exe_compare",
          "description": "实现了文件系统事件监听初始化、事件回调处理及执行文件路径比对功能。包含监视器事件处理入口、审计模块初始化代码，以及用于进程执行文件审计匹配的专用比较函数。",
          "similarity": 0.5064224004745483
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/audit_watch.c",
          "start_line": 1,
          "end_line": 57,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* audit_watch.c -- watching inodes",
            " *",
            " * Copyright 2003-2009 Red Hat, Inc.",
            " * Copyright 2005 Hewlett-Packard Development Company, L.P.",
            " * Copyright 2005 IBM Corporation",
            " */",
            "",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/audit.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/namei.h>",
            "#include <linux/netlink.h>",
            "#include <linux/refcount.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include \"audit.h\"",
            "",
            "/*",
            " * Reference counting:",
            " *",
            " * audit_parent: lifetime is from audit_init_parent() to receipt of an FS_IGNORED",
            " * \tevent.  Each audit_watch holds a reference to its associated parent.",
            " *",
            " * audit_watch: if added to lists, lifetime is from audit_init_watch() to",
            " * \taudit_remove_watch().  Additionally, an audit_watch may exist",
            " * \ttemporarily to assist in searching existing filter data.  Each",
            " * \taudit_krule holds a reference to its associated watch.",
            " */",
            "",
            "struct audit_watch {",
            "\trefcount_t\t\tcount;\t/* reference count */",
            "\tdev_t\t\t\tdev;\t/* associated superblock device */",
            "\tchar\t\t\t*path;\t/* insertion path */",
            "\tunsigned long\t\tino;\t/* associated inode number */",
            "\tstruct audit_parent\t*parent; /* associated parent */",
            "\tstruct list_head\twlist;\t/* entry in parent->watches list */",
            "\tstruct list_head\trules;\t/* anchor for krule->rlist */",
            "};",
            "",
            "struct audit_parent {",
            "\tstruct list_head\twatches; /* anchor for audit_watch->wlist */",
            "\tstruct fsnotify_mark mark; /* fsnotify mark on the inode */",
            "};",
            "",
            "/* fsnotify handle. */",
            "static struct fsnotify_group *audit_watch_group;",
            "",
            "/* fsnotify events we care about. */",
            "#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\",
            "\t\t\tFS_MOVE_SELF | FS_UNMOUNT)",
            ""
          ],
          "function_name": null,
          "description": "定义了audit_watch和audit_parent结构体，用于跟踪被审计的文件系统对象及其关联的监视器。声明了全局的fsnotify组用于文件系统事件通知，并定义了用于匹配文件系统事件的位掩码AUDIT_FS_WATCH。",
          "similarity": 0.5059931874275208
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/audit_watch.c",
          "start_line": 58,
          "end_line": 218,
          "content": [
            "static void audit_free_parent(struct audit_parent *parent)",
            "{",
            "\tWARN_ON(!list_empty(&parent->watches));",
            "\tkfree(parent);",
            "}",
            "static void audit_watch_free_mark(struct fsnotify_mark *entry)",
            "{",
            "\tstruct audit_parent *parent;",
            "",
            "\tparent = container_of(entry, struct audit_parent, mark);",
            "\taudit_free_parent(parent);",
            "}",
            "static void audit_get_parent(struct audit_parent *parent)",
            "{",
            "\tif (likely(parent))",
            "\t\tfsnotify_get_mark(&parent->mark);",
            "}",
            "static void audit_put_parent(struct audit_parent *parent)",
            "{",
            "\tif (likely(parent))",
            "\t\tfsnotify_put_mark(&parent->mark);",
            "}",
            "void audit_get_watch(struct audit_watch *watch)",
            "{",
            "\trefcount_inc(&watch->count);",
            "}",
            "void audit_put_watch(struct audit_watch *watch)",
            "{",
            "\tif (refcount_dec_and_test(&watch->count)) {",
            "\t\tWARN_ON(watch->parent);",
            "\t\tWARN_ON(!list_empty(&watch->rules));",
            "\t\tkfree(watch->path);",
            "\t\tkfree(watch);",
            "\t}",
            "}",
            "static void audit_remove_watch(struct audit_watch *watch)",
            "{",
            "\tlist_del(&watch->wlist);",
            "\taudit_put_parent(watch->parent);",
            "\twatch->parent = NULL;",
            "\taudit_put_watch(watch); /* match initial get */",
            "}",
            "int audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)",
            "{",
            "\treturn (watch->ino != AUDIT_INO_UNSET) &&",
            "\t\t(watch->ino == ino) &&",
            "\t\t(watch->dev == dev);",
            "}",
            "int audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)",
            "{",
            "\tstruct audit_watch *watch;",
            "",
            "\tif (!audit_watch_group)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tif (path[0] != '/' || path[len-1] == '/' ||",
            "\t    (krule->listnr != AUDIT_FILTER_EXIT &&",
            "\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||",
            "\t    op != Audit_equal ||",
            "\t    krule->inode_f || krule->watch || krule->tree)",
            "\t\treturn -EINVAL;",
            "",
            "\twatch = audit_init_watch(path);",
            "\tif (IS_ERR(watch))",
            "\t\treturn PTR_ERR(watch);",
            "",
            "\tkrule->watch = watch;",
            "",
            "\treturn 0;",
            "}",
            "static void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "\tab = audit_log_start(audit_context(), GFP_NOFS, AUDIT_CONFIG_CHANGE);",
            "\tif (!ab)",
            "\t\treturn;",
            "\taudit_log_session_info(ab);",
            "\taudit_log_format(ab, \"op=%s path=\", op);",
            "\taudit_log_untrustedstring(ab, w->path);",
            "\taudit_log_key(ab, r->filterkey);",
            "\taudit_log_format(ab, \" list=%d res=1\", r->listnr);",
            "\taudit_log_end(ab);",
            "}",
            "static void audit_update_watch(struct audit_parent *parent,",
            "\t\t\t       const struct qstr *dname, dev_t dev,",
            "\t\t\t       unsigned long ino, unsigned invalidating)",
            "{",
            "\tstruct audit_watch *owatch, *nwatch, *nextw;",
            "\tstruct audit_krule *r, *nextr;",
            "\tstruct audit_entry *oentry, *nentry;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\t/* Run all of the watches on this parent looking for the one that",
            "\t * matches the given dname */",
            "\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {",
            "\t\tif (audit_compare_dname_path(dname, owatch->path,",
            "\t\t\t\t\t     AUDIT_NAME_FULL))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* If the update involves invalidating rules, do the inode-based",
            "\t\t * filtering now, so we don't omit records. */",
            "\t\tif (invalidating && !audit_dummy_context())",
            "\t\t\taudit_filter_inodes(current, audit_context());",
            "",
            "\t\t/* updating ino will likely change which audit_hash_list we",
            "\t\t * are on so we need a new watch for the new list */",
            "\t\tnwatch = audit_dupe_watch(owatch);",
            "\t\tif (IS_ERR(nwatch)) {",
            "\t\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\t\taudit_panic(\"error updating watch, skipping\");",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tnwatch->dev = dev;",
            "\t\tnwatch->ino = ino;",
            "",
            "\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {",
            "",
            "\t\t\toentry = container_of(r, struct audit_entry, rule);",
            "\t\t\tlist_del(&oentry->rule.rlist);",
            "\t\t\tlist_del_rcu(&oentry->list);",
            "",
            "\t\t\tnentry = audit_dupe_rule(&oentry->rule);",
            "\t\t\tif (IS_ERR(nentry)) {",
            "\t\t\t\tlist_del(&oentry->rule.list);",
            "\t\t\t\taudit_panic(\"error updating watch, removing\");",
            "\t\t\t} else {",
            "\t\t\t\tint h = audit_hash_ino((u32)ino);",
            "",
            "\t\t\t\t/*",
            "\t\t\t\t * nentry->rule.watch == oentry->rule.watch so",
            "\t\t\t\t * we must drop that reference and set it to our",
            "\t\t\t\t * new watch.",
            "\t\t\t\t */",
            "\t\t\t\taudit_put_watch(nentry->rule.watch);",
            "\t\t\t\taudit_get_watch(nwatch);",
            "\t\t\t\tnentry->rule.watch = nwatch;",
            "\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);",
            "\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);",
            "\t\t\t\tlist_replace(&oentry->rule.list,",
            "\t\t\t\t\t     &nentry->rule.list);",
            "\t\t\t}",
            "\t\t\tif (oentry->rule.exe)",
            "\t\t\t\taudit_remove_mark(oentry->rule.exe);",
            "",
            "\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "",
            "\t\taudit_remove_watch(owatch);",
            "\t\tgoto add_watch_to_parent; /* event applies to a single watch */",
            "\t}",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\treturn;",
            "",
            "add_watch_to_parent:",
            "\tlist_add(&nwatch->wlist, &parent->watches);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\treturn;",
            "}"
          ],
          "function_name": "audit_free_parent, audit_watch_free_mark, audit_get_parent, audit_put_parent, audit_get_watch, audit_put_watch, audit_remove_watch, audit_watch_compare, audit_to_watch, audit_watch_log_rule_change, audit_update_watch",
          "description": "实现了审计监视器的引用计数管理、资源释放逻辑及动态更新机制。包含对监视器与规则的绑定解除、路径匹配判断、以及基于文件系统事件的监视器状态同步等功能。",
          "similarity": 0.4850456714630127
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_inode_storage.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:57:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_inode_storage.c`\n\n---\n\n# `bpf/bpf_inode_storage.c` 技术文档\n\n## 1. 文件概述\n\n`bpf_inode_storage.c` 实现了 BPF（Berkeley Packet Filter）程序对 **inode 级别本地存储（local storage）** 的支持。该机制允许 BPF 程序将任意用户定义的数据与内核中的 `struct inode` 实例关联，从而在不修改 VFS 层或文件系统代码的前提下，为 inode 附加自定义元数据。此功能主要用于 LSM（Linux Security Module）钩子、审计、追踪等场景。\n\n该文件基于通用的 `bpf_local_storage` 框架，为 inode 对象定制了存储管理逻辑，并提供了 BPF 辅助函数（helpers）和 map 操作接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `DEFINE_BPF_STORAGE_CACHE(inode_cache)`：为 inode 存储分配的专用内存缓存。\n- `inode_storage_map_ops`：`bpf_map_ops` 操作集，定义了 inode 存储 map 的行为。\n- `bpf_inode_storage_btf_ids`：BTF（BPF Type Format）类型 ID 列表，用于类型安全检查。\n\n### 关键函数\n- **存储访问与管理**\n  - `inode_storage_ptr()`：获取 inode 对应的 BPF 存储指针。\n  - `inode_storage_lookup()`：在指定 inode 和 map 中查找存储数据。\n  - `bpf_inode_storage_free()`：在 inode 销毁时释放其关联的 BPF 存储。\n  - `inode_storage_delete()`：从 inode 中删除指定 map 的存储项。\n\n- **BPF Map 操作接口**\n  - `bpf_fd_inode_storage_lookup_elem()`：通过文件描述符（fd）查找 inode 存储数据。\n  - `bpf_fd_inode_storage_update_elem()`：通过 fd 更新 inode 存储。\n  - `bpf_fd_inode_storage_delete_elem()`：通过 fd 删除 inode 存储。\n\n- **BPF 辅助函数（Helpers）**\n  - `bpf_inode_storage_get()`：BPF 程序调用的辅助函数，用于获取或创建 inode 存储。\n  - `bpf_inode_storage_delete()`：BPF 程序调用的辅助函数，用于删除 inode 存储。\n\n- **Map 生命周期管理**\n  - `inode_storage_map_alloc()`：分配 inode 存储类型的 BPF map。\n  - `inode_storage_map_free()`：释放该类型 map。\n\n## 3. 关键实现\n\n### 存储绑定机制\n- 每个 `struct inode` 通过 `bpf_inode()` 宏访问其内嵌的 `struct bpf_storage_blob`（通常位于 inode 的安全字段或扩展字段中）。\n- `bpf_storage_blob` 包含一个 RCU 保护的 `struct bpf_local_storage *storage` 指针，指向实际的存储容器。\n- 所有存储操作均通过 `bpf_local_storage` 通用框架完成，确保线程安全和内存管理一致性。\n\n### RCU 与锁策略\n- 查找操作使用 `rcu_read_lock()` 保护，避免持有写锁。\n- 更新/删除操作在必要时使用自旋锁（由 `bpf_local_storage_update` 内部处理）。\n- `bpf_inode_storage_get` 要求调用者已持有 RCU 锁（通过 `bpf_rcu_lock_held()` 验证），确保 inode 不会在操作期间被释放。\n\n### 内存分配策略\n- 存储项分配使用 `GFP_ATOMIC`（在 fd-based 接口）或由 verifier 传入的 `gfp_flags`（在 helper 中），以适应不同上下文（如中断、软中断）。\n- 使用专用 SLAB 缓存 `inode_cache` 优化内存分配性能。\n\n### BPF Map 与 Helper 集成\n- 提供两种访问路径：\n  1. **BPF 程序直接调用 helper**（如 `bpf_inode_storage_get`），传入 `struct inode *`。\n  2. **用户空间通过 fd 操作 map**（如 `bpf_map_lookup_elem`），内核自动解析 fd 到 inode。\n- `map_get_next_key` 返回 `-ENOTSUPP`，表明该 map 不支持迭代。\n\n### 类型安全\n- 通过 BTF 类型 ID (`bpf_inode_storage_btf_ids`) 确保 BPF 程序传入的 `inode` 指针类型正确。\n- `arg2_type = ARG_PTR_TO_BTF_ID_OR_NULL` 允许传入空指针（安全处理）。\n\n## 4. 依赖关系\n\n- **核心依赖**\n  - `<linux/bpf_local_storage.h>`：提供通用本地存储框架。\n  - `<linux/bpf.h>`：BPF 核心基础设施。\n  - `<linux/rculist.h>` / `<linux/spinlock.h>`：并发控制原语。\n  - `<linux/fdtable.h>`：fd 解析支持。\n\n- **关联子系统**\n  - **VFS（Virtual File System）**：依赖 `struct inode` 结构及生命周期管理。\n  - **BPF 子系统**：集成到 BPF map 和 helper 机制中。\n  - **LSM（Linux Security Modules）**：常用于在 LSM 钩子中附加安全上下文。\n  - **BTF（BPF Type Format）**：用于运行时类型验证。\n\n- **内存管理**\n  - 依赖 SLAB 分配器创建专用缓存 `inode_cache`。\n  - 与 RCU 机制深度集成，确保存储项安全回收。\n\n## 5. 使用场景\n\n1. **LSM 安全策略扩展**\n   - 在 LSM 钩子（如 `file_open`、`inode_permission`）中，BPF 程序可为 inode 附加自定义安全标签或策略数据。\n\n2. **文件系统审计与监控**\n   - 追踪特定 inode 的访问模式，记录额外审计信息（如首次访问时间、访问者 UID）。\n\n3. **资源配额与限制**\n   - 为 inode 关联配额计数器，实现细粒度资源控制（如单个文件的 I/O 限速）。\n\n4. **调试与性能分析**\n   - 在 BPF 程序中为热点 inode 附加调试信息，辅助性能调优。\n\n5. **用户空间工具集成**\n   - 通过 fd 操作 map，用户空间程序可查询/修改 inode 的 BPF 存储（如 `bpftool` 调试）。\n\n> **注意**：由于 inode 可能被频繁创建/销毁，BPF 程序必须确保在安全上下文中调用 helper（如持有 inode 引用或处于 RCU 临界区），避免访问已释放内存。",
      "similarity": 0.5963961482048035,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 1,
          "end_line": 56,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (c) 2019 Facebook",
            " * Copyright 2020 Google LLC.",
            " */",
            "",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/rcupdate_trace.h>",
            "",
            "DEFINE_BPF_STORAGE_CACHE(inode_cache);",
            "",
            "static struct bpf_local_storage __rcu **",
            "inode_storage_ptr(void *owner)",
            "{",
            "\tstruct inode *inode = owner;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "\treturn &bsb->storage;",
            "}",
            "",
            "static struct bpf_local_storage_data *inode_storage_lookup(struct inode *inode,",
            "\t\t\t\t\t\t\t   struct bpf_map *map,",
            "\t\t\t\t\t\t\t   bool cacheit_lockit)",
            "{",
            "\tstruct bpf_local_storage *inode_storage;",
            "\tstruct bpf_local_storage_map *smap;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "",
            "\tinode_storage =",
            "\t\trcu_dereference_check(bsb->storage, bpf_rcu_lock_held());",
            "\tif (!inode_storage)",
            "\t\treturn NULL;",
            "",
            "\tsmap = (struct bpf_local_storage_map *)map;",
            "\treturn bpf_local_storage_lookup(inode_storage, smap, cacheit_lockit);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义inode级别的BPF本地存储缓存inode_cache，并提供用于获取inode存储指针及查询特定map中存储数据的辅助函数。其中inode_storage_lookup通过RCU读锁安全地检索存储实例并调用底层BPF本地存储查找逻辑。",
          "similarity": 0.6493843197822571
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 57,
          "end_line": 121,
          "content": [
            "void bpf_inode_storage_free(struct inode *inode)",
            "{",
            "\tstruct bpf_local_storage *local_storage;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "",
            "\tlocal_storage = rcu_dereference(bsb->storage);",
            "\tif (!local_storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn;",
            "\t}",
            "",
            "\tbpf_local_storage_destroy(local_storage);",
            "\trcu_read_unlock();",
            "}",
            "static long bpf_fd_inode_storage_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t\t     void *value, u64 map_flags)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\tif (!inode_storage_ptr(file_inode(fd_file(f))))",
            "\t\treturn -EBADF;",
            "",
            "\tsdata = bpf_local_storage_update(file_inode(fd_file(f)),",
            "\t\t\t\t\t (struct bpf_local_storage_map *)map,",
            "\t\t\t\t\t value, map_flags, false, GFP_ATOMIC);",
            "\treturn PTR_ERR_OR_ZERO(sdata);",
            "}",
            "static int inode_storage_delete(struct inode *inode, struct bpf_map *map)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "",
            "\tsdata = inode_storage_lookup(inode, map, false);",
            "\tif (!sdata)",
            "\t\treturn -ENOENT;",
            "",
            "\tbpf_selem_unlink(SELEM(sdata), false);",
            "",
            "\treturn 0;",
            "}",
            "static long bpf_fd_inode_storage_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\treturn inode_storage_delete(file_inode(fd_file(f)), map);",
            "}",
            "static int notsupp_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\tvoid *next_key)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static void inode_storage_map_free(struct bpf_map *map)",
            "{",
            "\tbpf_local_storage_map_free(map, &inode_cache, NULL);",
            "}"
          ],
          "function_name": "bpf_inode_storage_free, bpf_fd_inode_storage_update_elem, inode_storage_delete, bpf_fd_inode_storage_delete_elem, notsupp_get_next_key, inode_storage_map_free",
          "description": "实现inode相关BPF存储资源的释放、更新、删除操作。包含释放存储空间、通过文件描述符更新存储项、删除存储条目等功能，同时注册了不支持的get_next_key操作并实现map销毁时的缓存回收逻辑。",
          "similarity": 0.638847827911377
        }
      ]
    }
  ]
}