{
  "query": "banker's algorithm implementation",
  "timestamp": "2025-12-26 01:04:03",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/kmem_cache_iter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:13:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\kmem_cache_iter.c`\n\n---\n\n# `bpf/kmem_cache_iter.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了 BPF（Berkeley Packet Filter）迭代器（iterator）机制对内核 slab 分配器中所有 `kmem_cache` 对象的遍历支持。通过该迭代器，BPF 程序可以在运行时安全地遍历系统中所有活动的内存缓存（slab caches），用于监控、调试或性能分析等用途。该实现同时支持 BPF kfunc 接口（供 BPF 程序直接调用）和基于 `seq_file` 的传统 BPF 迭代器接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_iter_kmem_cache`**  \n  用户态或 BPF 程序可见的不透明迭代器句柄，用于封装内部状态。\n\n- **`struct bpf_iter_kmem_cache_kern`**  \n  内核内部使用的迭代器状态结构，包含当前遍历位置（`pos` 指向 `kmem_cache`）。\n\n- **`struct bpf_iter__kmem_cache`**  \n  BPF 迭代器上下文结构，作为 BPF 程序的输入参数，包含元数据和当前 `kmem_cache` 指针。\n\n- **`union kmem_cache_iter_priv`**  \n  联合体，用于在 `seq_file` 私有数据中同时容纳用户态和内核态的迭代器结构。\n\n### 主要函数\n\n- **`bpf_iter_kmem_cache_new()`**  \n  初始化一个新的 `kmem_cache` 迭代器，设置起始位置为特殊标记 `KMEM_CACHE_POS_START`。\n\n- **`bpf_iter_kmem_cache_next()`**  \n  获取下一个有效的 `kmem_cache` 对象。负责引用计数管理：对新对象增加引用，对旧对象减少引用并在引用归零时调用 `kmem_cache_destroy()`。\n\n- **`bpf_iter_kmem_cache_destroy()`**  \n  销毁迭代器，释放当前持有的 `kmem_cache` 引用（如需要则触发销毁）。\n\n- **`kmem_cache_iter_seq_start()` / `next()` / `stop()` / `show()`**  \n  实现 `seq_file` 接口，用于支持通过 BPF 迭代器文件描述符进行遍历。\n\n- **`bpf_kmem_cache_iter_init()`**  \n  模块初始化函数，注册 `kmem_cache` 类型的 BPF 迭代器目标。\n\n## 3. 关键实现\n\n### 引用计数管理\n- 遍历时对每个非启动缓存（`boot_cache`，其 `refcount < 0`）的 `kmem_cache` 对象进行引用计数操作：\n  - 进入时（`next` 或 `start`）若 `refcount > 0`，则递增引用。\n  - 离开时（`next` 的前一个或 `stop`）若引用计数降至 1，则标记为可销毁，并在锁外调用 `kmem_cache_destroy()`。\n- 此机制确保遍历过程中目标对象不会被意外释放，同时避免内存泄漏。\n\n### 并发安全\n- 所有对全局 `slab_caches` 链表的访问均受 `slab_mutex` 互斥锁保护。\n- 由于遍历过程可能释放锁（如 `kmem_cache_destroy()` 需要睡眠），实现采用“按位置查找”策略（`seq_start` 中通过 `*pos` 重新定位），而非保存链表指针，以容忍中间元素的删除（虽可能跳过，但保证安全）。\n\n### BPF 接口集成\n- 通过 `DEFINE_BPF_ITER_FUNC` 和 `bpf_iter_reg_target()` 注册为 BPF 迭代器目标 `\"kmem_cache\"`。\n- 使用 `BTF_ID_LIST_GLOBAL_SINGLE` 导出 `kmem_cache` 结构的 BTF ID，使 BPF 程序能安全访问其字段。\n- 上下文参数 `s` 被标记为 `PTR_TO_BTF_ID_OR_NULL | PTR_TRUSTED`，表明其为可信的、类型安全的指针。\n\n### 特殊起始标记\n- 使用 `(void *)1L` 作为 `KMEM_CACHE_POS_START`，避免与合法指针或 `NULL` 冲突，用于标识迭代尚未开始。\n\n## 4. 依赖关系\n\n- **`<linux/slab.h>`**：提供 `kmem_cache`、`slab_caches` 链表和 `slab_mutex` 的定义。\n- **`<linux/bpf.h>`**：BPF 核心接口，包括迭代器注册、程序执行等。\n- **`<linux/btf_ids.h>`**：BTF（BPF Type Format）ID 管理，用于类型安全。\n- **`../../mm/slab.h`**：内核内部 slab 实现头文件，暴露 `kmem_cache` 结构细节。\n- **`kmem_cache_destroy()`**：依赖 slab 子系统的缓存销毁逻辑。\n\n## 5. 使用场景\n\n- **系统监控工具**：BPF 程序可通过此迭代器收集所有 slab 缓存的统计信息（如对象数量、内存使用量），用于内存泄漏检测或性能分析。\n- **安全审计**：检查异常或可疑的 `kmem_cache` 创建行为。\n- **内核调试**：在运行时动态查询 slab 子系统的状态，无需修改内核代码或重启系统。\n- **eBPF 应用开发**：为高级内存分析工具（如 `bpftrace`、`bcc` 工具集）提供底层支持。",
      "similarity": 0.5034332871437073,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/kmem_cache_iter.c",
          "start_line": 24,
          "end_line": 99,
          "content": [
            "__bpf_kfunc int bpf_iter_kmem_cache_new(struct bpf_iter_kmem_cache *it)",
            "{",
            "\tstruct bpf_iter_kmem_cache_kern *kit = (void *)it;",
            "",
            "\tBUILD_BUG_ON(sizeof(*kit) > sizeof(*it));",
            "\tBUILD_BUG_ON(__alignof__(*kit) != __alignof__(*it));",
            "",
            "\tkit->pos = KMEM_CACHE_POS_START;",
            "\treturn 0;",
            "}",
            "__bpf_kfunc void bpf_iter_kmem_cache_destroy(struct bpf_iter_kmem_cache *it)",
            "{",
            "\tstruct bpf_iter_kmem_cache_kern *kit = (void *)it;",
            "\tstruct kmem_cache *s = kit->pos;",
            "\tbool destroy = false;",
            "",
            "\tif (s == NULL || s == KMEM_CACHE_POS_START)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&slab_mutex);",
            "",
            "\t/* Skip kmem_cache_destroy() for active entries */",
            "\tif (s->refcount > 1)",
            "\t\ts->refcount--;",
            "\telse if (s->refcount == 1)",
            "\t\tdestroy = true;",
            "",
            "\tmutex_unlock(&slab_mutex);",
            "",
            "\tif (destroy)",
            "\t\tkmem_cache_destroy(s);",
            "}",
            "static void kmem_cache_iter_seq_stop(struct seq_file *seq, void *v)",
            "{",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_iter__kmem_cache ctx = {",
            "\t\t.meta = &meta,",
            "\t\t.s = v,",
            "\t};",
            "\tunion kmem_cache_iter_priv *p = seq->private;",
            "\tstruct bpf_prog *prog;",
            "",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, true);",
            "\tif (prog && !ctx.s)",
            "\t\tbpf_iter_run_prog(prog, &ctx);",
            "",
            "\tbpf_iter_kmem_cache_destroy(&p->it);",
            "}",
            "static int kmem_cache_iter_seq_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_iter__kmem_cache ctx = {",
            "\t\t.meta = &meta,",
            "\t\t.s = v,",
            "\t};",
            "\tstruct bpf_prog *prog;",
            "\tint ret = 0;",
            "",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, false);",
            "\tif (prog)",
            "\t\tret = bpf_iter_run_prog(prog, &ctx);",
            "",
            "\treturn ret;",
            "}",
            "static void bpf_iter_kmem_cache_show_fdinfo(const struct bpf_iter_aux_info *aux,",
            "\t\t\t\t\t    struct seq_file *seq)",
            "{",
            "\tseq_puts(seq, \"kmem_cache iter\\n\");",
            "}",
            "static int __init bpf_kmem_cache_iter_init(void)",
            "{",
            "\tbpf_kmem_cache_reg_info.ctx_arg_info[0].btf_id = bpf_kmem_cache_btf_id[0];",
            "\treturn bpf_iter_reg_target(&bpf_kmem_cache_reg_info);",
            "}"
          ],
          "function_name": "bpf_iter_kmem_cache_new, bpf_iter_kmem_cache_destroy, kmem_cache_iter_seq_stop, kmem_cache_iter_seq_show, bpf_iter_kmem_cache_show_fdinfo, bpf_kmem_cache_iter_init",
          "description": "实现BPF kmem_cache迭代器的核心函数，包含迭代器创建/销毁逻辑、序列化遍历控制、BPF程序执行及注册机制，通过slab_mutex保护缓存引用计数并处理销毁操作",
          "similarity": 0.4762100577354431
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/kmem_cache_iter.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2024 Google */",
            "#include <linux/bpf.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/seq_file.h>",
            "",
            "#include \"../../mm/slab.h\" /* kmem_cache, slab_caches and slab_mutex */",
            "",
            "/* open-coded version */",
            "struct bpf_iter_kmem_cache {",
            "\t__u64 __opaque[1];",
            "} __attribute__((aligned(8)));",
            "",
            "struct bpf_iter_kmem_cache_kern {",
            "\tstruct kmem_cache *pos;",
            "} __attribute__((aligned(8)));",
            "",
            "#define KMEM_CACHE_POS_START  ((void *)1L)",
            "",
            "__bpf_kfunc_start_defs();",
            ""
          ],
          "function_name": null,
          "description": "定义BPF kmem_cache迭代器的通用结构体和宏，用于支持BPF程序访问slab缓存对象，包含对齐属性和位置起始标记，但未包含完整实现",
          "similarity": 0.4490082561969757
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bloom_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:56:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bloom_filter.c`\n\n---\n\n# `bpf/bloom_filter.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了 Linux 内核中 eBPF（extended Berkeley Packet Filter）子系统所支持的 **布隆过滤器（Bloom Filter）映射类型**。布隆过滤器是一种空间高效的概率型数据结构，用于快速判断某个元素是否**可能存在于集合中**（允许假阳性，但不允许假阴性）。该映射类型专为只写入、只查询、不可删除的场景设计，适用于高性能、低内存开销的成员存在性检测。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_bloom_filter`**  \n  布隆过滤器的具体实现结构体，包含：\n  - `struct bpf_map map`：继承自通用 eBPF 映射结构。\n  - `u32 bitset_mask`：位图掩码，用于快速取模（因位图大小为 2 的幂）。\n  - `u32 hash_seed`：哈希种子，用于初始化哈希函数（可选随机化）。\n  - `u32 nr_hash_funcs`：使用的哈希函数数量（1–15，由 `map_extra` 指定）。\n  - `unsigned long bitset[]`：柔性数组，存储位图数据。\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `hash()` | 根据输入值、哈希种子和索引计算哈希值，并通过 `bitset_mask` 取模得到位图索引。支持 4 字节对齐和非对齐数据。 |\n| `bloom_map_peek_elem()` | 查询元素是否存在：对每个哈希函数计算位图位置，若任一位为 0 则返回 `-ENOENT`（不存在）；否则返回 0（可能存在）。 |\n| `bloom_map_push_elem()` | 插入元素：对每个哈希函数计算位图位置并置位。仅支持 `BPF_ANY` 标志。 |\n| `bloom_map_alloc()` | 分配并初始化布隆过滤器映射。根据 `max_entries` 和 `map_extra`（哈希函数数）计算最优位图大小，并向上取整为 2 的幂。 |\n| `bloom_map_free()` | 释放布隆过滤器占用的内存。 |\n| `bloom_map_alloc_check()` | 在创建映射前校验参数合法性（如 `value_size` 不超过 `KMALLOC_MAX_SIZE`）。 |\n| `bloom_map_check_btf()` | BTF（BPF Type Format）校验：要求 key 类型为 `void`（无 key）。 |\n| `bloom_map_mem_usage()` | 返回该映射实际占用的内存大小（含位图）。 |\n\n### 不支持的操作（返回 `-EOPNOTSUPP` 或 `-EINVAL`）\n\n- `bloom_map_pop_elem()`：不支持弹出元素。\n- `bloom_map_delete_elem()`：不支持删除元素。\n- `bloom_map_get_next_key()`：不支持遍历。\n- `bloom_map_lookup_elem()` / `bloom_map_update_elem()`：eBPF 程序应使用 `map_peek_elem` 和 `map_push_elem` 替代。\n\n### 映射操作表\n\n- `bloom_filter_map_ops`：定义了该映射类型支持的所有操作回调函数，注册到 eBPF 子系统。\n\n## 3. 关键实现\n\n### 布隆过滤器参数计算\n\n- **哈希函数数量**：由用户通过 `attr->map_extra & 0xF` 指定（1–15），若为 0 则默认使用 5 个。\n- **位图大小计算**：\n  - 理论最优位数：`n * k / ln(2)`，其中 `n = max_entries`，`k = nr_hash_funcs`。\n  - 代码使用 `7/5 ≈ 1/ln(2)` 近似计算：`nr_bits = (max_entries * k * 7) / 5`。\n  - 为提升哈希效率，将 `nr_bits` **向上取整为 2 的幂**，从而可用 `& (size - 1)` 替代取模运算。\n  - 若计算溢出（> 2^31），则使用最大位图（`U32_MAX` 位，约 512 MB）。\n\n### 哈希函数\n\n- 使用内核提供的 `jhash()` 和 `jhash2()`（Jenkins 哈希）。\n- 每个哈希函数通过 `hash_seed + index` 区分，确保独立性。\n- 支持任意长度的 `value`（由 `value_size` 指定），自动选择对齐/非对齐版本。\n\n### 内存分配\n\n- 使用 `bpf_map_area_alloc()` 分配连续内存，包含结构体头和位图。\n- 位图大小按 `unsigned long` 对齐，确保位操作效率。\n\n### 安全与校验\n\n- 严格校验创建参数：`key_size` 必须为 0，`value_size` 和 `max_entries` 必须 > 0。\n- 仅允许特定 `map_flags`（`BPF_F_NUMA_NODE`、`BPF_F_ZERO_SEED`、`BPF_F_ACCESS_MASK`）。\n- BTF 校验强制 key 类型为 `void`，符合“无 key”设计。\n\n## 4. 依赖关系\n\n- **内核头文件**：\n  - `<linux/bitmap.h>`：提供 `test_bit()`、`set_bit()` 等位操作。\n  - `<linux/bpf.h>`：eBPF 核心定义（`bpf_map`、操作码等）。\n  - `<linux/btf.h>`：BTF 类型系统支持。\n  - `<linux/jhash.h>`：Jenkins 哈希函数实现。\n  - `<linux/random.h>`：`get_random_u32()` 用于生成哈希种子。\n- **eBPF 子系统**：通过 `bpf_map_ops` 机制集成到 eBPF 映射框架中。\n- **内存管理**：依赖 `bpf_map_area_alloc/free` 进行 NUMA 感知内存分配。\n\n## 5. 使用场景\n\n- **网络数据包过滤**：快速判断 IP 地址、端口等是否在可疑集合中。\n- **安全监控**：检测进程、文件路径是否属于已知恶意样本（允许少量误报）。\n- **性能分析**：记录已观测到的事件 ID，避免重复处理。\n- **资源去重**：在无法存储完整集合的场景下，高效判断元素是否已存在。\n\n> **注意**：由于布隆过滤器**不支持删除操作**，且存在**假阳性**，适用于“写一次、查多次”且可容忍少量误报的场景。eBPF 程序需通过 `bpf_map_peek_elem()` 查询，通过 `bpf_map_push_elem()` 插入。",
      "similarity": 0.4963926672935486,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 23,
          "end_line": 117,
          "content": [
            "static u32 hash(struct bpf_bloom_filter *bloom, void *value,",
            "\t\tu32 value_size, u32 index)",
            "{",
            "\tu32 h;",
            "",
            "\tif (likely(value_size % 4 == 0))",
            "\t\th = jhash2(value, value_size / 4, bloom->hash_seed + index);",
            "\telse",
            "\t\th = jhash(value, value_size, bloom->hash_seed + index);",
            "",
            "\treturn h & bloom->bitset_mask;",
            "}",
            "static long bloom_map_peek_elem(struct bpf_map *map, void *value)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tif (!test_bit(h, bloom->bitset))",
            "\t\t\treturn -ENOENT;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_push_elem(struct bpf_map *map, void *value, u64 flags)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tif (flags != BPF_ANY)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tset_bit(h, bloom->bitset);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_pop_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static long bloom_map_delete_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_get_next_key(struct bpf_map *map, void *key, void *next_key)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_alloc_check(union bpf_attr *attr)",
            "{",
            "\tif (attr->value_size > KMALLOC_MAX_SIZE)",
            "\t\t/* if value_size is bigger, the user space won't be able to",
            "\t\t * access the elements.",
            "\t\t */",
            "\t\treturn -E2BIG;",
            "",
            "\treturn 0;",
            "}",
            "static void bloom_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "",
            "\tbpf_map_area_free(bloom);",
            "}",
            "static long bloom_map_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t  void *value, u64 flags)",
            "{",
            "\t/* The eBPF program should use map_push_elem instead */",
            "\treturn -EINVAL;",
            "}",
            "static int bloom_map_check_btf(const struct bpf_map *map,",
            "\t\t\t       const struct btf *btf,",
            "\t\t\t       const struct btf_type *key_type,",
            "\t\t\t       const struct btf_type *value_type)",
            "{",
            "\t/* Bloom filter maps are keyless */",
            "\treturn btf_type_is_void(key_type) ? 0 : -EINVAL;",
            "}",
            "static u64 bloom_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom;",
            "\tu64 bitset_bytes;",
            "",
            "\tbloom = container_of(map, struct bpf_bloom_filter, map);",
            "\tbitset_bytes = BITS_TO_BYTES((u64)bloom->bitset_mask + 1);",
            "\tbitset_bytes = roundup(bitset_bytes, sizeof(unsigned long));",
            "\treturn sizeof(*bloom) + bitset_bytes;",
            "}"
          ],
          "function_name": "hash, bloom_map_peek_elem, bloom_map_push_elem, bloom_map_pop_elem, bloom_map_delete_elem, bloom_map_get_next_key, bloom_map_alloc_check, bloom_map_free, bloom_map_update_elem, bloom_map_check_btf, bloom_map_mem_usage",
          "description": "实现Bloom过滤器核心操作，包括哈希计算、元素存在性检测、插入操作、内存校验、资源释放及内存占用统计，部分接口暂不支持并返回相应错误码",
          "similarity": 0.5209947228431702
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2021 Facebook */",
            "",
            "#include <linux/bitmap.h>",
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/err.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#define BLOOM_CREATE_FLAG_MASK \\",
            "\t(BPF_F_NUMA_NODE | BPF_F_ZERO_SEED | BPF_F_ACCESS_MASK)",
            "",
            "struct bpf_bloom_filter {",
            "\tstruct bpf_map map;",
            "\tu32 bitset_mask;",
            "\tu32 hash_seed;",
            "\tu32 nr_hash_funcs;",
            "\tunsigned long bitset[];",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义Bloom过滤器内核结构体，包含位图掩码、哈希种子、哈希函数数及动态扩展的位集合数组，用于eBPF程序中的布隆过滤器实现",
          "similarity": 0.44479942321777344
        }
      ]
    },
    {
      "source_file": "kernel/bpf/map_iter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:18:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\map_iter.c`\n\n---\n\n# `bpf/map_iter.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/map_iter.c` 是 Linux 内核 BPF（Berkeley Packet Filter）子系统中的一个核心文件，用于实现对 BPF map 的迭代器（iterator）支持。该文件提供了两种类型的 BPF 迭代器：\n\n- **`bpf_map` 迭代器**：用于遍历系统中所有已注册的 BPF map。\n- **`bpf_map_elem` 迭代器**：用于遍历指定 BPF map 中的所有键值对元素。\n\n此外，该文件还定义了一个 BPF kfunc（内核函数）`bpf_map_sum_elem_count`，用于安全地获取 per-CPU 类型 map 的总元素数量。整个实现基于内核的 seq_file 机制和 BPF 迭代器框架，允许用户空间通过 BPF 程序安全、高效地访问 map 元数据或内容。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_iter_seq_map_info`**  \n  用于在 seq_file 迭代过程中保存当前遍历的 map ID。\n\n- **`struct bpf_iter__bpf_map`**  \n  BPF 程序上下文结构，作为 `bpf_map` 迭代器的元数据传递给 BPF 程序，包含指向当前 `bpf_map` 的指针。\n\n- **`struct bpf_iter__bpf_map_elem`**（隐式定义）  \n  由 `DEFINE_BPF_ITER_FUNC(bpf_map_elem, ...)` 宏生成，用于 `bpf_map_elem` 迭代器，包含 `map`、`key` 和 `value` 指针。\n\n- **`bpf_map_seq_ops`**  \n  实现 `seq_operations` 接口，用于遍历所有 BPF map。\n\n- **`bpf_map_reg_info` 与 `bpf_map_elem_reg_info`**  \n  分别注册 `bpf_map` 和 `bpf_map_elem` 两种 BPF 迭代器目标。\n\n- **`bpf_map_iter_kfunc_set`**  \n  注册 BPF kfunc `bpf_map_sum_elem_count`，供 BPF 程序调用。\n\n### 主要函数\n\n- **`bpf_map_seq_start/next/stop/show`**  \n  实现 seq_file 接口，用于遍历所有 BPF map。\n\n- **`__bpf_map_seq_show`**  \n  调用关联的 BPF 程序处理当前 map。\n\n- **`bpf_iter_attach_map` / `bpf_iter_detach_map`**  \n  在 `bpf_map_elem` 迭代器 attach/detach 时管理 map 引用计数，并验证访问权限。\n\n- **`bpf_iter_map_show_fdinfo` / `bpf_iter_map_fill_link_info`**  \n  提供迭代器链接的调试信息和用户空间查询接口。\n\n- **`bpf_map_sum_elem_count`**  \n  BPF kfunc，安全累加 per-CPU map 的元素计数。\n\n- **`bpf_map_iter_init`**  \n  模块初始化函数，注册两个 BPF 迭代器目标。\n\n- **`init_subsystem`**  \n  注册 BPF kfunc 到 BTF 系统。\n\n## 3. 关键实现\n\n### BPF Map 全局遍历（`bpf_map` 迭代器）\n\n- 使用 `bpf_map_get_curr_or_next(&map_id)` 按 ID 顺序遍历所有 map。\n- `seq_file` 的 `start`/`next` 函数通过递增 `map_id` 实现迭代。\n- 每次访问 map 后通过 `bpf_map_put()` 释放引用，确保资源安全。\n- 在 `stop` 阶段，若 `v == NULL`（表示迭代结束），会再次调用 `__bpf_map_seq_show` 并传入 `in_stop=true`，用于通知 BPF 程序迭代已结束。\n\n### BPF Map 元素遍历（`bpf_map_elem` 迭代器）\n\n- 通过 `bpf_iter_attach_map` 从用户传入的 `map_fd` 获取 map 实例。\n- 支持的 map 类型包括：`HASH`、`LRU_HASH`、`ARRAY` 及其 per-CPU 变体。\n- 在 attach 时验证 BPF 程序对 key/value 的最大访问尺寸是否超过 map 定义的尺寸，防止越界访问。\n- 对 per-CPU map，value 大小计算为 `round_up(value_size, 8) * num_possible_cpus()`，符合内核 per-CPU 布局。\n\n### BPF kfunc：`bpf_map_sum_elem_count`\n\n- 仅当 `map->elem_count` 非空时（通常由支持计数的 map 类型提供）才进行累加。\n- 使用 `for_each_possible_cpu` 遍历所有 CPU，通过 `per_cpu_ptr` 安全读取 per-CPU 计数。\n- 使用 `READ_ONCE` 避免编译器优化导致的非原子读取问题。\n- 标记为 `KF_TRUSTED_ARGS`，表示参数来自内核可信上下文。\n\n### BTF 与类型安全\n\n- 通过 `BTF_ID_LIST_GLOBAL_SINGLE` 获取 `struct bpf_map` 的 BTF ID，用于类型验证。\n- `ctx_arg_info` 中使用 `PTR_TO_BTF_ID_OR_NULL | PTR_TRUSTED` 确保传递给 BPF 程序的 map 指针类型安全且可信。\n- kfunc 通过 `BTF_SET8` 注册，并关联 `KFUNC` 类型标志。\n\n## 4. 依赖关系\n\n- **`<linux/bpf.h>` / `<linux/filter.h>`**：BPF 核心接口和程序执行框架。\n- **`<linux/fs.h>`**：seq_file 机制，用于实现迭代器输出。\n- **`<linux/btf_ids.h>`**：BTF（BPF Type Format）支持，用于类型验证和 kfunc 注册。\n- **`bpf_map_get_curr_or_next` / `bpf_map_put`**：来自 BPF map 管理子系统（`kernel/bpf/syscall.c` 等）。\n- **`bpf_iter_get_info` / `bpf_iter_run_prog`**：BPF 迭代器运行时支持（`kernel/bpf/bpf_iter.c`）。\n- **`register_btf_kfunc_id_set`**：BPF kfunc 注册机制。\n\n## 5. 使用场景\n\n- **系统监控与调试**：用户可通过 BPF 程序遍历所有 BPF map，收集其类型、ID、引用计数等元信息，用于性能分析或调试。\n- **Map 内容导出**：通过 `bpf_map_elem` 迭代器，用户空间可安全遍历指定 map 的所有键值对，实现 map 数据导出（如 `bpftool map dump` 的底层机制）。\n- **安全审计**：结合 BPF 程序，可对 map 访问模式进行监控或策略检查。\n- **Per-CPU 统计聚合**：BPF 程序可调用 `bpf_map_sum_elem_count` 快速获取 per-CPU map 的总元素数，用于指标采集。\n- **内核自省**：作为 BPF 迭代器框架的一部分，为内核提供标准化的 map 遍历能力，避免直接暴露内部数据结构。",
      "similarity": 0.4862027168273926,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/map_iter.c",
          "start_line": 44,
          "end_line": 156,
          "content": [
            "static int __bpf_map_seq_show(struct seq_file *seq, void *v, bool in_stop)",
            "{",
            "\tstruct bpf_iter__bpf_map ctx;",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_prog *prog;",
            "\tint ret = 0;",
            "",
            "\tctx.meta = &meta;",
            "\tctx.map = v;",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, in_stop);",
            "\tif (prog)",
            "\t\tret = bpf_iter_run_prog(prog, &ctx);",
            "",
            "\treturn ret;",
            "}",
            "static int bpf_map_seq_show(struct seq_file *seq, void *v)",
            "{",
            "\treturn __bpf_map_seq_show(seq, v, false);",
            "}",
            "static void bpf_map_seq_stop(struct seq_file *seq, void *v)",
            "{",
            "\tif (!v)",
            "\t\t(void)__bpf_map_seq_show(seq, v, true);",
            "\telse",
            "\t\tbpf_map_put((struct bpf_map *)v);",
            "}",
            "static int bpf_iter_attach_map(struct bpf_prog *prog,",
            "\t\t\t       union bpf_iter_link_info *linfo,",
            "\t\t\t       struct bpf_iter_aux_info *aux)",
            "{",
            "\tu32 key_acc_size, value_acc_size, key_size, value_size;",
            "\tstruct bpf_map *map;",
            "\tbool is_percpu = false;",
            "\tint err = -EINVAL;",
            "",
            "\tif (!linfo->map.map_fd)",
            "\t\treturn -EBADF;",
            "",
            "\tmap = bpf_map_get_with_uref(linfo->map.map_fd);",
            "\tif (IS_ERR(map))",
            "\t\treturn PTR_ERR(map);",
            "",
            "\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||",
            "\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||",
            "\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY)",
            "\t\tis_percpu = true;",
            "\telse if (map->map_type != BPF_MAP_TYPE_HASH &&",
            "\t\t map->map_type != BPF_MAP_TYPE_LRU_HASH &&",
            "\t\t map->map_type != BPF_MAP_TYPE_ARRAY)",
            "\t\tgoto put_map;",
            "",
            "\tkey_acc_size = prog->aux->max_rdonly_access;",
            "\tvalue_acc_size = prog->aux->max_rdwr_access;",
            "\tkey_size = map->key_size;",
            "\tif (!is_percpu)",
            "\t\tvalue_size = map->value_size;",
            "\telse",
            "\t\tvalue_size = round_up(map->value_size, 8) * num_possible_cpus();",
            "",
            "\tif (key_acc_size > key_size || value_acc_size > value_size) {",
            "\t\terr = -EACCES;",
            "\t\tgoto put_map;",
            "\t}",
            "",
            "\taux->map = map;",
            "\treturn 0;",
            "",
            "put_map:",
            "\tbpf_map_put_with_uref(map);",
            "\treturn err;",
            "}",
            "static void bpf_iter_detach_map(struct bpf_iter_aux_info *aux)",
            "{",
            "\tbpf_map_put_with_uref(aux->map);",
            "}",
            "void bpf_iter_map_show_fdinfo(const struct bpf_iter_aux_info *aux,",
            "\t\t\t      struct seq_file *seq)",
            "{",
            "\tseq_printf(seq, \"map_id:\\t%u\\n\", aux->map->id);",
            "}",
            "int bpf_iter_map_fill_link_info(const struct bpf_iter_aux_info *aux,",
            "\t\t\t\tstruct bpf_link_info *info)",
            "{",
            "\tinfo->iter.map.map_id = aux->map->id;",
            "\treturn 0;",
            "}",
            "static int __init bpf_map_iter_init(void)",
            "{",
            "\tint ret;",
            "",
            "\tbpf_map_reg_info.ctx_arg_info[0].btf_id = *btf_bpf_map_id;",
            "\tret = bpf_iter_reg_target(&bpf_map_reg_info);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn bpf_iter_reg_target(&bpf_map_elem_reg_info);",
            "}",
            "__bpf_kfunc s64 bpf_map_sum_elem_count(const struct bpf_map *map)",
            "{",
            "\ts64 *pcount;",
            "\ts64 ret = 0;",
            "\tint cpu;",
            "",
            "\tif (!map || !map->elem_count)",
            "\t\treturn 0;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tpcount = per_cpu_ptr(map->elem_count, cpu);",
            "\t\tret += READ_ONCE(*pcount);",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__bpf_map_seq_show, bpf_map_seq_show, bpf_map_seq_stop, bpf_iter_attach_map, bpf_iter_detach_map, bpf_iter_map_show_fdinfo, bpf_iter_map_fill_link_info, bpf_map_iter_init, bpf_map_sum_elem_count",
          "description": "包含BPF map迭代器辅助函数实现，包括map属性展示、权限校验、元素计数统计及链接信息填充，支持通过BPF程序对map进行遍历操作，包含map附加/分离逻辑和子系统初始化",
          "similarity": 0.488589346408844
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/map_iter.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2020 Facebook */",
            "#include <linux/bpf.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kernel.h>",
            "#include <linux/btf_ids.h>",
            "",
            "struct bpf_iter_seq_map_info {",
            "\tu32 map_id;",
            "};",
            "",
            "static void *bpf_map_seq_start(struct seq_file *seq, loff_t *pos)",
            "{",
            "\tstruct bpf_iter_seq_map_info *info = seq->private;",
            "\tstruct bpf_map *map;",
            "",
            "\tmap = bpf_map_get_curr_or_next(&info->map_id);",
            "\tif (!map)",
            "\t\treturn NULL;",
            "",
            "\tif (*pos == 0)",
            "\t\t++*pos;",
            "\treturn map;",
            "}",
            "",
            "static void *bpf_map_seq_next(struct seq_file *seq, void *v, loff_t *pos)",
            "{",
            "\tstruct bpf_iter_seq_map_info *info = seq->private;",
            "",
            "\t++*pos;",
            "\t++info->map_id;",
            "\tbpf_map_put((struct bpf_map *)v);",
            "\treturn bpf_map_get_curr_or_next(&info->map_id);",
            "}",
            "",
            "struct bpf_iter__bpf_map {",
            "\t__bpf_md_ptr(struct bpf_iter_meta *, meta);",
            "\t__bpf_md_ptr(struct bpf_map *, map);",
            "};",
            "",
            "DEFINE_BPF_ITER_FUNC(bpf_map, struct bpf_iter_meta *meta, struct bpf_map *map)",
            ""
          ],
          "function_name": null,
          "description": "实现BPF map迭代器框架，提供seq_file遍历接口，通过bpf_map_seq_start和bpf_map_seq_next函数依次获取当前map及下一个map对象，使用 DEFINE_BPF_ITER_FUNC 注册迭代器回调函数",
          "similarity": 0.46686214208602905
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/map_iter.c",
          "start_line": 225,
          "end_line": 228,
          "content": [
            "static int init_subsystem(void)",
            "{",
            "\treturn register_btf_kfunc_id_set(BPF_PROG_TYPE_UNSPEC, &bpf_map_iter_kfunc_set);",
            "}"
          ],
          "function_name": "init_subsystem",
          "description": "注册BPF kfunc集合到BTF系统，用于关联bpf_map_sum_elem_count函数，实现多CPU环境下map元素数量的统计功能",
          "similarity": 0.4515060782432556
        }
      ]
    }
  ]
}