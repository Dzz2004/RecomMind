{
  "query": "Linux I/O子系统架构与实现原理",
  "timestamp": "2025-12-26 00:28:43",
  "retrieved_files": [
    {
      "source_file": "mm/page_io.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:03:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_io.c`\n\n---\n\n# page_io.c 技术文档\n\n## 1. 文件概述\n\n`page_io.c` 是 Linux 内核内存管理子系统中负责页面交换 I/O 操作的核心文件。该文件实现了将匿名页写入交换设备（swap-out）和从交换设备读回内存（swap-in）的底层机制，包括基于 `bio` 的块设备交换路径和基于文件系统的直接 I/O 交换路径。此外，还提供了通用的交换文件激活逻辑，用于在启用交换文件时构建物理块到交换页的映射。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `__end_swap_bio_write()` / `end_swap_bio_write()`：处理交换写操作完成的回调，处理写错误并结束写回。\n- `__end_swap_bio_read()` / `end_swap_bio_read()`：处理交换读操作完成的回调，设置页面 uptodate 状态或报告读错误。\n- `generic_swapfile_activate()`：为基于文件的交换设备（如 swapfile）构建连续的物理块映射，填充 `swap_info_struct`。\n- `swap_writepage()`：页面写回交换区的主入口函数，支持 zswap 压缩缓存、内存控制组限制等特性。\n- `swap_writepage_fs()`：通过文件系统直接 I/O 路径（如 swap-over-NFS）执行交换写操作。\n- `sio_pool_init()`：初始化用于异步交换 I/O 的内存池。\n- `sio_write_complete()`：处理基于 kiocb 的异步交换写完成回调。\n\n### 关键数据结构\n\n- `struct swap_iocb`：封装用于文件系统交换 I/O 的 `kiocb` 和 `bio_vec` 数组，支持批量交换页写入。\n- `sio_pool`：`mempool_t` 类型的内存池，用于分配 `swap_iocb` 结构，避免高内存压力下分配失败。\n\n## 3. 关键实现\n\n### 交换 I/O 完成处理\n- 写操作失败时，页面被重新标记为 dirty 并清除 `PG_reclaim` 标志，防止被错误回收，同时输出限频警告日志。\n- 读操作失败仅输出警告；成功则设置 `PG_uptodate` 并解锁页面。\n\n### 交换文件激活 (`generic_swapfile_activate`)\n- 遍历交换文件的逻辑块，使用 `bmap()` 获取物理块号。\n- 验证每个 PAGE_SIZE 对齐区域的物理块是否连续且对齐。\n- 通过 `add_swap_extent()` 将有效的交换页范围注册到交换子系统。\n- 计算交换空间的物理跨度（`span`），用于优化交换分配策略。\n\n### 交换写入路径选择\n- 默认使用 `__swap_writepage()`（基于 `bio` 的块设备路径）。\n- 若启用了 zswap 且压缩存储成功，则跳过磁盘 I/O。\n- 若内存控制组禁用 zswap 回写，则返回 `AOP_WRITEPAGE_ACTIVATE` 以保留页面在内存中。\n- 对于 NFS 等不支持 `bmap` 的文件系统，使用 `swap_writepage_fs()` 路径，通过 `kiocb` 异步 DIO 写入。\n\n### 异步交换 I/O 批处理\n- `swap_writepage_fs()` 支持通过 `wbc->swap_plug` 合并多个相邻页面的写请求到同一个 `swap_iocb`。\n- 利用 `mempool` 保证在内存紧张时仍能分配 I/O 控制块。\n- 完成回调中处理部分写入错误，标记所有相关页面为 dirty 并结束写回。\n\n### 资源统计与控制\n- 通过 `count_swpout_vm_event()` 更新透明大页（THP）和普通页的交换出计数。\n- 在配置了 MEMCG 和 BLK_CGROUP 时，通过 `bio_associate_blkg_from_page()` 将 I/O 请求关联到页面所属的 blkcg，实现 I/O 资源隔离。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/swap.h>`、`<linux/pagemap.h>` 等，与页面回收、反向映射、内存控制组紧密集成。\n- **块设备层**：通过 `<linux/bio.h>`、`<linux/blkdev.h>` 与块 I/O 子系统交互。\n- **文件系统接口**：使用 `bmap()` 和 `kiocb` 与具体文件系统（如 ext4、xfs）或网络文件系统（如 NFS）协作。\n- **压缩子系统**：集成 `<linux/zswap.h>`，支持透明压缩交换缓存。\n- **资源控制器**：依赖 MEMCG 和 BLK_CGROUP 实现内存与 I/O 的多租户隔离。\n- **内部头文件**：包含本地 `\"swap.h\"` 获取交换子系统私有接口。\n\n## 5. 使用场景\n\n- **系统内存不足时**：页面回收机制调用 `swap_writepage()` 将匿名页换出到交换设备。\n- **启用交换文件时**：`swapon` 系统调用执行 `generic_swapfile_activate()` 初始化交换文件的物理布局。\n- **从交换区缺页中断**：当访问已换出页面时，内核通过 `end_swap_bio_read` 路径将数据读回内存。\n- **容器环境**：在启用内存和 I/O 控制组的系统中，确保交换 I/O 正确归属到对应 cgroup。\n- **使用压缩交换缓存**：当 zswap 启用时，优先尝试压缩页面而非立即写入慢速交换设备。\n- **网络交换场景**：在无本地块设备的环境中（如云实例使用 NFS 作为交换后端），通过 `swap_writepage_fs()` 路径完成交换。",
      "similarity": 0.6407798528671265,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/page_io.c",
          "start_line": 30,
          "end_line": 169,
          "content": [
            "static void __end_swap_bio_write(struct bio *bio)",
            "{",
            "\tstruct folio *folio = bio_first_folio_all(bio);",
            "",
            "\tif (bio->bi_status) {",
            "\t\t/*",
            "\t\t * We failed to write the page out to swap-space.",
            "\t\t * Re-dirty the page in order to avoid it being reclaimed.",
            "\t\t * Also print a dire warning that things will go BAD (tm)",
            "\t\t * very quickly.",
            "\t\t *",
            "\t\t * Also clear PG_reclaim to avoid folio_rotate_reclaimable()",
            "\t\t */",
            "\t\tfolio_mark_dirty(folio);",
            "\t\tpr_alert_ratelimited(\"Write-error on swap-device (%u:%u:%llu)\\n\",",
            "\t\t\t\t     MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),",
            "\t\t\t\t     (unsigned long long)bio->bi_iter.bi_sector);",
            "\t\tfolio_clear_reclaim(folio);",
            "\t}",
            "\tfolio_end_writeback(folio);",
            "}",
            "static void end_swap_bio_write(struct bio *bio)",
            "{",
            "\t__end_swap_bio_write(bio);",
            "\tbio_put(bio);",
            "}",
            "static void __end_swap_bio_read(struct bio *bio)",
            "{",
            "\tstruct folio *folio = bio_first_folio_all(bio);",
            "",
            "\tif (bio->bi_status) {",
            "\t\tpr_alert_ratelimited(\"Read-error on swap-device (%u:%u:%llu)\\n\",",
            "\t\t\t\t     MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),",
            "\t\t\t\t     (unsigned long long)bio->bi_iter.bi_sector);",
            "\t} else {",
            "\t\tfolio_mark_uptodate(folio);",
            "\t}",
            "\tfolio_unlock(folio);",
            "}",
            "static void end_swap_bio_read(struct bio *bio)",
            "{",
            "\t__end_swap_bio_read(bio);",
            "\tbio_put(bio);",
            "}",
            "int generic_swapfile_activate(struct swap_info_struct *sis,",
            "\t\t\t\tstruct file *swap_file,",
            "\t\t\t\tsector_t *span)",
            "{",
            "\tstruct address_space *mapping = swap_file->f_mapping;",
            "\tstruct inode *inode = mapping->host;",
            "\tunsigned blocks_per_page;",
            "\tunsigned long page_no;",
            "\tunsigned blkbits;",
            "\tsector_t probe_block;",
            "\tsector_t last_block;",
            "\tsector_t lowest_block = -1;",
            "\tsector_t highest_block = 0;",
            "\tint nr_extents = 0;",
            "\tint ret;",
            "",
            "\tblkbits = inode->i_blkbits;",
            "\tblocks_per_page = PAGE_SIZE >> blkbits;",
            "",
            "\t/*",
            "\t * Map all the blocks into the extent tree.  This code doesn't try",
            "\t * to be very smart.",
            "\t */",
            "\tprobe_block = 0;",
            "\tpage_no = 0;",
            "\tlast_block = i_size_read(inode) >> blkbits;",
            "\twhile ((probe_block + blocks_per_page) <= last_block &&",
            "\t\t\tpage_no < sis->max) {",
            "\t\tunsigned block_in_page;",
            "\t\tsector_t first_block;",
            "",
            "\t\tcond_resched();",
            "",
            "\t\tfirst_block = probe_block;",
            "\t\tret = bmap(inode, &first_block);",
            "\t\tif (ret || !first_block)",
            "\t\t\tgoto bad_bmap;",
            "",
            "\t\t/*",
            "\t\t * It must be PAGE_SIZE aligned on-disk",
            "\t\t */",
            "\t\tif (first_block & (blocks_per_page - 1)) {",
            "\t\t\tprobe_block++;",
            "\t\t\tgoto reprobe;",
            "\t\t}",
            "",
            "\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;",
            "\t\t\t\t\tblock_in_page++) {",
            "\t\t\tsector_t block;",
            "",
            "\t\t\tblock = probe_block + block_in_page;",
            "\t\t\tret = bmap(inode, &block);",
            "\t\t\tif (ret || !block)",
            "\t\t\t\tgoto bad_bmap;",
            "",
            "\t\t\tif (block != first_block + block_in_page) {",
            "\t\t\t\t/* Discontiguity */",
            "\t\t\t\tprobe_block++;",
            "\t\t\t\tgoto reprobe;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tfirst_block >>= (PAGE_SHIFT - blkbits);",
            "\t\tif (page_no) {\t/* exclude the header page */",
            "\t\t\tif (first_block < lowest_block)",
            "\t\t\t\tlowest_block = first_block;",
            "\t\t\tif (first_block > highest_block)",
            "\t\t\t\thighest_block = first_block;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * We found a PAGE_SIZE-length, PAGE_SIZE-aligned run of blocks",
            "\t\t */",
            "\t\tret = add_swap_extent(sis, page_no, 1, first_block);",
            "\t\tif (ret < 0)",
            "\t\t\tgoto out;",
            "\t\tnr_extents += ret;",
            "\t\tpage_no++;",
            "\t\tprobe_block += blocks_per_page;",
            "reprobe:",
            "\t\tcontinue;",
            "\t}",
            "\tret = nr_extents;",
            "\t*span = 1 + highest_block - lowest_block;",
            "\tif (page_no == 0)",
            "\t\tpage_no = 1;\t/* force Empty message */",
            "\tsis->max = page_no;",
            "\tsis->pages = page_no - 1;",
            "\tsis->highest_bit = page_no - 1;",
            "out:",
            "\treturn ret;",
            "bad_bmap:",
            "\tpr_err(\"swapon: swapfile has holes\\n\");",
            "\tret = -EINVAL;",
            "\tgoto out;",
            "}"
          ],
          "function_name": "__end_swap_bio_write, end_swap_bio_write, __end_swap_bio_read, end_swap_bio_read, generic_swapfile_activate",
          "description": "实现交换I/O完成回调函数，处理写入错误重标记脏页及读取错误日志；generic_swapfile_activate扫描交换文件块并构建交换区范围。",
          "similarity": 0.5561143159866333
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page_io.c",
          "start_line": 298,
          "end_line": 400,
          "content": [
            "static void swap_writepage_fs(struct folio *folio, struct writeback_control *wbc)",
            "{",
            "\tstruct swap_iocb *sio = NULL;",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "\tstruct file *swap_file = sis->swap_file;",
            "\tloff_t pos = folio_file_pos(folio);",
            "",
            "\tcount_swpout_vm_event(folio);",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "\tif (wbc->swap_plug)",
            "\t\tsio = *wbc->swap_plug;",
            "\tif (sio) {",
            "\t\tif (sio->iocb.ki_filp != swap_file ||",
            "\t\t    sio->iocb.ki_pos + sio->len != pos) {",
            "\t\t\tswap_write_unplug(sio);",
            "\t\t\tsio = NULL;",
            "\t\t}",
            "\t}",
            "\tif (!sio) {",
            "\t\tsio = mempool_alloc(sio_pool, GFP_NOIO);",
            "\t\tinit_sync_kiocb(&sio->iocb, swap_file);",
            "\t\tsio->iocb.ki_complete = sio_write_complete;",
            "\t\tsio->iocb.ki_pos = pos;",
            "\t\tsio->pages = 0;",
            "\t\tsio->len = 0;",
            "\t}",
            "\tbvec_set_folio(&sio->bvec[sio->pages], folio, folio_size(folio), 0);",
            "\tsio->len += folio_size(folio);",
            "\tsio->pages += 1;",
            "\tif (sio->pages == ARRAY_SIZE(sio->bvec) || !wbc->swap_plug) {",
            "\t\tswap_write_unplug(sio);",
            "\t\tsio = NULL;",
            "\t}",
            "\tif (wbc->swap_plug)",
            "\t\t*wbc->swap_plug = sio;",
            "}",
            "static void swap_writepage_bdev_sync(struct folio *folio,",
            "\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)",
            "{",
            "\tstruct bio_vec bv;",
            "\tstruct bio bio;",
            "",
            "\tbio_init(&bio, sis->bdev, &bv, 1,",
            "\t\t REQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc));",
            "\tbio.bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio_add_folio_nofail(&bio, folio, folio_size(folio), 0);",
            "",
            "\tbio_associate_blkg_from_page(&bio, folio);",
            "\tcount_swpout_vm_event(folio);",
            "",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "",
            "\tsubmit_bio_wait(&bio);",
            "\t__end_swap_bio_write(&bio);",
            "}",
            "static void swap_writepage_bdev_async(struct folio *folio,",
            "\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)",
            "{",
            "\tstruct bio *bio;",
            "",
            "\tbio = bio_alloc(sis->bdev, 1,",
            "\t\t\tREQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc),",
            "\t\t\tGFP_NOIO);",
            "\tbio->bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio->bi_end_io = end_swap_bio_write;",
            "\tbio_add_folio_nofail(bio, folio, folio_size(folio), 0);",
            "",
            "\tbio_associate_blkg_from_page(bio, folio);",
            "\tcount_swpout_vm_event(folio);",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "\tsubmit_bio(bio);",
            "}",
            "void __swap_writepage(struct folio *folio, struct writeback_control *wbc)",
            "{",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio), folio);",
            "\t/*",
            "\t * ->flags can be updated non-atomicially (scan_swap_map_slots),",
            "\t * but that will never affect SWP_FS_OPS, so the data_race",
            "\t * is safe.",
            "\t */",
            "\tif (data_race(sis->flags & SWP_FS_OPS))",
            "\t\tswap_writepage_fs(folio, wbc);",
            "\telse if (sis->flags & SWP_SYNCHRONOUS_IO)",
            "\t\tswap_writepage_bdev_sync(folio, wbc, sis);",
            "\telse",
            "\t\tswap_writepage_bdev_async(folio, wbc, sis);",
            "}",
            "void swap_write_unplug(struct swap_iocb *sio)",
            "{",
            "\tstruct iov_iter from;",
            "\tstruct address_space *mapping = sio->iocb.ki_filp->f_mapping;",
            "\tint ret;",
            "",
            "\tiov_iter_bvec(&from, ITER_SOURCE, sio->bvec, sio->pages, sio->len);",
            "\tret = mapping->a_ops->swap_rw(&sio->iocb, &from);",
            "\tif (ret != -EIOCBQUEUED)",
            "\t\tsio_write_complete(&sio->iocb, ret);",
            "}"
          ],
          "function_name": "swap_writepage_fs, swap_writepage_bdev_sync, swap_writepage_bdev_async, __swap_writepage, swap_write_unplug",
          "description": "__swap_writepage根据配置选择同步/异步块设备写入路径，通过bio结构执行交换页面写入操作，支持批量提交优化。",
          "similarity": 0.5557456016540527
        },
        {
          "chunk_id": 5,
          "file_path": "mm/page_io.c",
          "start_line": 543,
          "end_line": 553,
          "content": [
            "void __swap_read_unplug(struct swap_iocb *sio)",
            "{",
            "\tstruct iov_iter from;",
            "\tstruct address_space *mapping = sio->iocb.ki_filp->f_mapping;",
            "\tint ret;",
            "",
            "\tiov_iter_bvec(&from, ITER_DEST, sio->bvec, sio->pages, sio->len);",
            "\tret = mapping->a_ops->swap_rw(&sio->iocb, &from);",
            "\tif (ret != -EIOCBQUEUED)",
            "\t\tsio_read_complete(&sio->iocb, ret);",
            "}"
          ],
          "function_name": "__swap_read_unplug",
          "description": "该函数是处理交换读取操作的关键函数，在页置换过程中将从交换设备读取的数据通过I/O向量传递至文件地址空间。  \n它通过构建iov_iter并调用address_space的a_ops->swap_rw接口进行实际的数据读取，并根据返回状态触发相应的完成回调。  \n注：swap_rw的具体实现依赖于对应文件系统的a_ops，此处上下文不完整。",
          "similarity": 0.5513358116149902
        },
        {
          "chunk_id": 2,
          "file_path": "mm/page_io.c",
          "start_line": 179,
          "end_line": 280,
          "content": [
            "int swap_writepage(struct page *page, struct writeback_control *wbc)",
            "{",
            "\tstruct folio *folio = page_folio(page);",
            "\tint ret;",
            "",
            "\tif (folio_free_swap(folio)) {",
            "\t\tfolio_unlock(folio);",
            "\t\treturn 0;",
            "\t}",
            "\t/*",
            "\t * Arch code may have to preserve more data than just the page",
            "\t * contents, e.g. memory tags.",
            "\t */",
            "\tret = arch_prepare_to_swap(folio);",
            "\tif (ret) {",
            "\t\tfolio_mark_dirty(folio);",
            "\t\tfolio_unlock(folio);",
            "\t\treturn ret;",
            "\t}",
            "\tif (zswap_store(folio)) {",
            "\t\tfolio_start_writeback(folio);",
            "\t\tfolio_unlock(folio);",
            "\t\tfolio_end_writeback(folio);",
            "\t\treturn 0;",
            "\t}",
            "\tif (!mem_cgroup_zswap_writeback_enabled(folio_memcg(folio))) {",
            "\t\tfolio_mark_dirty(folio);",
            "\t\treturn AOP_WRITEPAGE_ACTIVATE;",
            "\t}",
            "",
            "\t__swap_writepage(folio, wbc);",
            "\treturn 0;",
            "}",
            "static inline void count_swpout_vm_event(struct folio *folio)",
            "{",
            "#ifdef CONFIG_TRANSPARENT_HUGEPAGE",
            "\tif (unlikely(folio_test_pmd_mappable(folio))) {",
            "\t\tcount_memcg_folio_events(folio, THP_SWPOUT, 1);",
            "\t\tcount_vm_event(THP_SWPOUT);",
            "\t}",
            "\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPOUT);",
            "#endif",
            "\tcount_memcg_folio_events(folio, PSWPOUT, folio_nr_pages(folio));",
            "\tcount_vm_events(PSWPOUT, folio_nr_pages(folio));",
            "}",
            "static void bio_associate_blkg_from_page(struct bio *bio, struct folio *folio)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct mem_cgroup *memcg;",
            "",
            "\tmemcg = folio_memcg(folio);",
            "\tif (!memcg)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "\tcss = cgroup_e_css(memcg->css.cgroup, &io_cgrp_subsys);",
            "\tbio_associate_blkg_from_css(bio, css);",
            "\trcu_read_unlock();",
            "}",
            "int sio_pool_init(void)",
            "{",
            "\tif (!sio_pool) {",
            "\t\tmempool_t *pool = mempool_create_kmalloc_pool(",
            "\t\t\tSWAP_CLUSTER_MAX, sizeof(struct swap_iocb));",
            "\t\tif (cmpxchg(&sio_pool, NULL, pool))",
            "\t\t\tmempool_destroy(pool);",
            "\t}",
            "\tif (!sio_pool)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static void sio_write_complete(struct kiocb *iocb, long ret)",
            "{",
            "\tstruct swap_iocb *sio = container_of(iocb, struct swap_iocb, iocb);",
            "\tstruct page *page = sio->bvec[0].bv_page;",
            "\tint p;",
            "",
            "\tif (ret != sio->len) {",
            "\t\t/*",
            "\t\t * In the case of swap-over-nfs, this can be a",
            "\t\t * temporary failure if the system has limited",
            "\t\t * memory for allocating transmit buffers.",
            "\t\t * Mark the page dirty and avoid",
            "\t\t * folio_rotate_reclaimable but rate-limit the",
            "\t\t * messages but do not flag PageError like",
            "\t\t * the normal direct-to-bio case as it could",
            "\t\t * be temporary.",
            "\t\t */",
            "\t\tpr_err_ratelimited(\"Write error %ld on dio swapfile (%llu)\\n\",",
            "\t\t\t\t   ret, page_file_offset(page));",
            "\t\tfor (p = 0; p < sio->pages; p++) {",
            "\t\t\tpage = sio->bvec[p].bv_page;",
            "\t\t\tset_page_dirty(page);",
            "\t\t\tClearPageReclaim(page);",
            "\t\t}",
            "\t}",
            "",
            "\tfor (p = 0; p < sio->pages; p++)",
            "\t\tend_page_writeback(sio->bvec[p].bv_page);",
            "",
            "\tmempool_free(sio, sio_pool);",
            "}"
          ],
          "function_name": "swap_writepage, count_swpout_vm_event, bio_associate_blkg_from_page, sio_pool_init, sio_write_complete",
          "description": "swap_writepage发起页面换出流程，调用架构特定准备函数并处理ZSwap缓存；sio_write_complete处理异步写入完成，标记脏页并释放资源。",
          "similarity": 0.5073016285896301
        },
        {
          "chunk_id": 0,
          "file_path": "mm/page_io.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  linux/mm/page_io.c",
            " *",
            " *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds",
            " *",
            " *  Swap reorganised 29.12.95, ",
            " *  Asynchronous swapping added 30.12.95. Stephen Tweedie",
            " *  Removed race in async swapping. 14.4.1996. Bruno Haible",
            " *  Add swap of shared pages through the page cache. 20.2.1998. Stephen Tweedie",
            " *  Always use brw_page, life becomes simpler. 12 May 1998 Eric Biederman",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swapops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/psi.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/zswap.h>",
            "#include \"swap.h\"",
            ""
          ],
          "function_name": null,
          "description": "声明头文件并引入交换页面管理模块的基本依赖，为后续交换操作提供基础框架。",
          "similarity": 0.5067070722579956
        }
      ]
    },
    {
      "source_file": "mm/io-mapping.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:11:05\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `io-mapping.c`\n\n---\n\n# io-mapping.c 技术文档\n\n## 1. 文件概述\n\n`io-mapping.c` 是 Linux 内核中用于支持 I/O 映射（I/O mapping）功能的实现文件之一，主要提供将内核空间的 I/O 映射区域安全地重映射到用户空间虚拟内存区域（VMA）的能力。该文件的核心函数 `io_mapping_map_user()` 被用于图形驱动、设备驱动等需要将设备寄存器或显存暴露给用户态程序访问的场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`io_mapping_map_user()`**  \n  将一个已创建的 `io_mapping` 对象所代表的物理 I/O 区域映射到用户空间的指定虚拟内存区域（VMA）。该函数确保映射的安全性和一致性，并跳过页帧跟踪（track_pfn）以提升性能。\n\n### 相关数据结构\n\n- **`struct io_mapping`**  \n  表示一个 I/O 映射对象，通常由 `io_mapping_create_wc()` 等函数创建，包含映射的保护属性（`prot`）和底层物理地址信息。\n  \n- **`struct vm_area_struct`**  \n  用户空间虚拟内存区域描述符，用于描述进程地址空间中的一段连续虚拟内存。\n\n## 3. 关键实现\n\n- **安全校验**：  \n  函数首先通过 `WARN_ON_ONCE` 检查传入的 `vma` 是否设置了预期的标志位：`VM_PFNMAP`（表示直接映射物理页帧）、`VM_DONTEXPAND`（禁止 VMA 扩展）和 `VM_DONTDUMP`（不在 core dump 中包含该区域）。若不满足，则返回 `-EINVAL`，防止不安全的映射操作。\n\n- **页表重映射**：  \n  调用 `remap_pfn_range_notrack()` 实现物理页帧到用户虚拟地址的映射。与常规的 `remap_pfn_range()` 不同，`_notrack` 版本跳过了对页帧的引用计数和反向映射跟踪，适用于 I/O 内存这类非普通 RAM 的场景。\n\n- **页表属性合成**：  \n  新的页表保护属性（`pgprot`）由两部分组合而成：\n  - 保留 `iomap->prot` 中的缓存控制位（通过 `_PAGE_CACHE_MASK` 提取）；\n  - 保留 `vma->vm_page_prot` 中的非缓存控制位（通过 `~_PAGE_CACHE_MASK` 屏蔽缓存位后合并）。\n  \n  这种设计允许在保持 I/O 映射所需缓存策略的同时，继承 VMA 原有的其他页属性（如可读/可写等）。\n\n- **同步要求**：  \n  函数注释明确指出，调用时必须持有 `mm` 信号量（即 `mmap_lock`），以确保 VMA 结构在映射过程中不会被并发修改。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`：提供内存管理相关定义，如 `remap_pfn_range_notrack`、`pgprot_val` 等。\n  - `<linux/io-mapping.h>`：定义 `io_mapping` 结构体及相关接口。\n\n- **内核子系统依赖**：\n  - **内存管理子系统（MM）**：依赖 VMA 管理、页表操作和 `remap_pfn_range` 系列函数。\n  - **I/O 映射框架**：作为 `io-mapping` 子系统的一部分，与 `io-mapping.h` 中声明的其他函数（如 `io_mapping_create_wc`）协同工作。\n\n- **导出符号**：  \n  `io_mapping_map_user` 通过 `EXPORT_SYMBOL_GPL` 导出，仅限 GPL 兼容模块使用，常见于 DRM（Direct Rendering Manager）等图形子系统驱动中。\n\n## 5. 使用场景\n\n- **GPU/显卡驱动**：  \n  在 DRM 驱动中，将 GPU 显存或 MMIO 寄存器区域映射到用户空间，供 Mesa 等用户态图形库直接访问，实现零拷贝的命令提交或帧缓冲操作。\n\n- **高性能设备驱动**：  \n  需要将设备的 DMA 缓冲区或控制寄存器暴露给用户程序进行高效访问的场景，例如网络加速卡、FPGA 控制器等。\n\n- **用户态驱动支持**：  \n  为用户态驱动（如 UIO、VFIO 的某些模式）提供安全、高效的物理内存映射机制，同时确保内核内存管理的一致性与安全性。",
      "similarity": 0.6111833453178406,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/io-mapping.c",
          "start_line": 16,
          "end_line": 28,
          "content": [
            "int io_mapping_map_user(struct io_mapping *iomap, struct vm_area_struct *vma,",
            "\t\tunsigned long addr, unsigned long pfn, unsigned long size)",
            "{",
            "\tvm_flags_t expected_flags = VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;",
            "",
            "\tif (WARN_ON_ONCE((vma->vm_flags & expected_flags) != expected_flags))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* We rely on prevalidation of the io-mapping to skip track_pfn(). */",
            "\treturn remap_pfn_range_notrack(vma, addr, pfn, size,",
            "\t\t__pgprot((pgprot_val(iomap->prot) & _PAGE_CACHE_MASK) |",
            "\t\t\t (pgprot_val(vma->vm_page_prot) & ~_PAGE_CACHE_MASK)));",
            "}"
          ],
          "function_name": "io_mapping_map_user",
          "description": "该函数用于将I/O映射区域通过remap_pfn_range_notrack接口注册到用户虚拟地址空间，校验VMA标志后设置物理帧号与保护属性，实现内核物理内存向用户态的直接映射",
          "similarity": 0.49447083473205566
        },
        {
          "chunk_id": 0,
          "file_path": "mm/io-mapping.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/mm.h>",
            "#include <linux/io-mapping.h>",
            "",
            "/**",
            " * io_mapping_map_user - remap an I/O mapping to userspace",
            " * @iomap: the source io_mapping",
            " * @vma: user vma to map to",
            " * @addr: target user address to start at",
            " * @pfn: physical address of kernel memory",
            " * @size: size of map area",
            " *",
            " *  Note: this is only safe if the mm semaphore is held when called.",
            " */"
          ],
          "function_name": null,
          "description": "上下文不完整",
          "similarity": 0.405215859413147
        }
      ]
    },
    {
      "source_file": "kernel/resource.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:53:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `resource.c`\n\n---\n\n# resource.c 技术文档\n\n## 1. 文件概述\n\n`resource.c` 是 Linux 内核中用于管理和分配系统资源（如 I/O 端口和内存区域）的核心实现文件。它提供了一套通用的资源树管理机制，支持资源的申请、释放、查找和冲突检测。该文件维护了两个全局根资源节点：`ioport_resource`（用于 I/O 端口空间）和 `iomem_resource`（用于内存映射 I/O 空间），并通过树形结构组织所有已分配的子资源，确保资源分配的唯一性和安全性。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `struct resource ioport_resource`：I/O 端口资源的根节点，范围为 `[0, IO_SPACE_LIMIT]`，标志为 `IORESOURCE_IO`。\n- `struct resource iomem_resource`：内存映射 I/O 资源的根节点，范围为 `[0, -1]`（即全地址空间），标志为 `IORESOURCE_MEM`。\n- `struct resource_constraint`：用于描述资源分配时的约束条件（最小/最大地址、对齐要求及自定义对齐函数）。\n\n### 关键函数\n- `request_resource(struct resource *root, struct resource *new)`：尝试在指定根资源下申请一段新资源，成功返回 0，冲突返回 `-EBUSY`。\n- `request_resource_conflict(...)`：与 `request_resource` 类似，但冲突时直接返回冲突的资源指针。\n- `release_resource(struct resource *old)`：释放已分配的资源。\n- `release_child_resources(struct resource *r)`：递归释放指定资源的所有子资源。\n- `find_next_iomem_res(...)`：在 `iomem_resource` 树中查找与指定区间 `[start, end]` 重叠且满足标志和描述符条件的下一个内存资源。\n- `for_each_resource` 宏：遍历资源树的通用宏，支持是否跳过子树的选项。\n\n### /proc 接口（条件编译）\n- 通过 `CONFIG_PROC_FS` 启用时，注册 `/proc/ioports` 和 `/proc/iomem` 文件，以树形格式展示当前系统中已分配的 I/O 端口和内存资源（仅对 `CAP_SYS_ADMIN` 权限用户显示实际地址）。\n\n## 3. 关键实现\n\n### 资源树结构\n- 资源以多叉树形式组织，每个 `struct resource` 包含 `child`（第一个子节点）、`sibling`（下一个兄弟节点）和 `parent` 指针。\n- 树内节点按起始地址升序排列，便于快速查找和插入。\n\n### 资源申请（`__request_resource`）\n- 在持有写锁 `resource_lock` 的前提下，遍历根节点的子链表。\n- 若新资源与现有节点无重叠，则按地址顺序插入；若存在重叠，则返回冲突节点。\n- 插入操作维护树的有序性：新节点插入到第一个起始地址大于其结束地址的节点之前。\n\n### 资源释放（`__release_resource`）\n- 支持两种模式：完全释放（含子资源）或仅提升子资源（当 `release_child=false` 时，将子节点直接挂到父节点下）。\n- 释放时调整兄弟链表指针，确保树结构完整性。\n\n### 资源遍历\n- `next_resource()`：深度优先遍历（先子节点，再兄弟节点）。\n- `next_resource_skip_children()`：仅遍历同级兄弟节点，跳过子树。\n- `/proc` 显示使用深度优先遍历，并限制最大显示层级（`MAX_IORES_LEVEL=5`）以避免过深嵌套。\n\n### 内存管理\n- 资源结构体通过 `alloc_resource()`（即 `kzalloc`）分配，通过 `free_resource()` 释放。\n- 注释指出：若资源由早期 `memblock` 分配，则无法安全释放（因非页对齐），会轻微泄漏，这是有意为之的简化设计。\n\n### 并发控制\n- 使用读写锁 `resource_lock` 保护全局资源树：\n  - 读操作（如 `/proc` 显示、`find_next_iomem_res`）使用 `read_lock`。\n  - 写操作（申请/释放资源）使用 `write_lock`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ioport.h>`：定义 `struct resource` 及相关宏（如 `IORESOURCE_IO`）。\n  - `<linux/proc_fs.h>`、`<linux/seq_file.h>`：实现 `/proc` 接口。\n  - `<linux/slab.h>`：资源结构体的动态分配。\n  - `<linux/spinlock.h>`：读写锁 `resource_lock` 的实现。\n  - `<asm/io.h>`：架构相关的 I/O 定义（如 `IO_SPACE_LIMIT`）。\n- **导出符号**：\n  - `ioport_resource`、`iomem_resource`、`request_resource`、`release_resource` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如 PCI、platform_device 驱动）使用。\n- **配置依赖**：\n  - `/proc` 接口依赖 `CONFIG_PROC_FS`。\n\n## 5. 使用场景\n\n- **设备驱动资源管理**：PCI、platform 等总线驱动在探测设备时，调用 `request_resource()` 申请 I/O 端口或内存区域，防止资源冲突。\n- **固件/ACPI 资源解析**：内核解析 ACPI 表或 EFI 内存映射时，将保留区域注册到 `iomem_resource` 树中。\n- **系统调试与监控**：用户空间通过 `/proc/ioports` 和 `/proc/iomem` 查看硬件资源分配情况（需 root 权限）。\n- **内核子系统协作**：内存管理子系统（如 `devm_request_mem_region`）、DMA 引擎等依赖此机制确保物理地址资源的独占使用。\n- **热插拔支持**：设备移除时调用 `release_resource()` 释放资源，供后续设备重用。",
      "similarity": 0.6092879772186279,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/resource.c",
          "start_line": 284,
          "end_line": 424,
          "content": [
            "int request_resource(struct resource *root, struct resource *new)",
            "{",
            "\tstruct resource *conflict;",
            "",
            "\tconflict = request_resource_conflict(root, new);",
            "\treturn conflict ? -EBUSY : 0;",
            "}",
            "int release_resource(struct resource *old)",
            "{",
            "\tint retval;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tretval = __release_resource(old, true);",
            "\twrite_unlock(&resource_lock);",
            "\treturn retval;",
            "}",
            "static int find_next_iomem_res(resource_size_t start, resource_size_t end,",
            "\t\t\t       unsigned long flags, unsigned long desc,",
            "\t\t\t       struct resource *res)",
            "{",
            "\tstruct resource *p;",
            "",
            "\tif (!res)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (start >= end)",
            "\t\treturn -EINVAL;",
            "",
            "\tread_lock(&resource_lock);",
            "",
            "\tfor (p = iomem_resource.child; p; p = next_resource(p)) {",
            "\t\t/* If we passed the resource we are looking for, stop */",
            "\t\tif (p->start > end) {",
            "\t\t\tp = NULL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Skip until we find a range that matches what we look for */",
            "\t\tif (p->end < start)",
            "\t\t\tcontinue;",
            "",
            "\t\tif ((p->flags & flags) != flags)",
            "\t\t\tcontinue;",
            "\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Found a match, break */",
            "\t\tbreak;",
            "\t}",
            "",
            "\tif (p) {",
            "\t\t/* copy data */",
            "\t\t*res = (struct resource) {",
            "\t\t\t.start = max(start, p->start),",
            "\t\t\t.end = min(end, p->end),",
            "\t\t\t.flags = p->flags,",
            "\t\t\t.desc = p->desc,",
            "\t\t\t.parent = p->parent,",
            "\t\t};",
            "\t}",
            "",
            "\tread_unlock(&resource_lock);",
            "\treturn p ? 0 : -ENODEV;",
            "}",
            "static int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,",
            "\t\t\t\t unsigned long flags, unsigned long desc,",
            "\t\t\t\t void *arg,",
            "\t\t\t\t int (*func)(struct resource *, void *))",
            "{",
            "\tstruct resource res;",
            "\tint ret = -EINVAL;",
            "",
            "\twhile (start < end &&",
            "\t       !find_next_iomem_res(start, end, flags, desc, &res)) {",
            "\t\tret = (*func)(&res, arg);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "",
            "\t\tstart = res.end + 1;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "int walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,",
            "\t\tu64 end, void *arg, int (*func)(struct resource *, void *))",
            "{",
            "\treturn __walk_iomem_res_desc(start, end, flags, desc, arg, func);",
            "}",
            "int walk_system_ram_res(u64 start, u64 end, void *arg,",
            "\t\t\tint (*func)(struct resource *, void *))",
            "{",
            "\tunsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;",
            "",
            "\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,",
            "\t\t\t\t     func);",
            "}",
            "int walk_system_ram_res_rev(u64 start, u64 end, void *arg,",
            "\t\t\t\tint (*func)(struct resource *, void *))",
            "{",
            "\tstruct resource res, *rams;",
            "\tint rams_size = 16, i;",
            "\tunsigned long flags;",
            "\tint ret = -1;",
            "",
            "\t/* create a list */",
            "\trams = kvcalloc(rams_size, sizeof(struct resource), GFP_KERNEL);",
            "\tif (!rams)",
            "\t\treturn ret;",
            "",
            "\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;",
            "\ti = 0;",
            "\twhile ((start < end) &&",
            "\t\t(!find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res))) {",
            "\t\tif (i >= rams_size) {",
            "\t\t\t/* re-alloc */",
            "\t\t\tstruct resource *rams_new;",
            "",
            "\t\t\trams_new = kvrealloc(rams, (rams_size + 16) * sizeof(struct resource),",
            "\t\t\t\t\t     GFP_KERNEL);",
            "\t\t\tif (!rams_new)",
            "\t\t\t\tgoto out;",
            "",
            "\t\t\trams = rams_new;",
            "\t\t\trams_size += 16;",
            "\t\t}",
            "",
            "\t\trams[i++] = res;",
            "\t\tstart = res.end + 1;",
            "\t}",
            "",
            "\t/* go reverse */",
            "\tfor (i--; i >= 0; i--) {",
            "\t\tret = (*func)(&rams[i], arg);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "out:",
            "\tkvfree(rams);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "request_resource, release_resource, find_next_iomem_res, __walk_iomem_res_desc, walk_iomem_res_desc, walk_system_ram_res, walk_system_ram_res_rev",
          "description": "实现资源请求/释放接口及内存区域遍历算法，通过find_next_iomem_res搜索匹配描述符的资源区间，支持正序/逆序扫描系统RAM等特定类型资源。",
          "similarity": 0.5628288984298706
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/resource.c",
          "start_line": 1885,
          "end_line": 1952,
          "content": [
            "static bool gfr_continue(struct resource *base, resource_size_t addr,",
            "\t\t\t resource_size_t size, unsigned long flags)",
            "{",
            "\tif (flags & GFR_DESCENDING)",
            "\t\treturn addr > size && addr >= base->start;",
            "\t/*",
            "\t * In the ascend case be careful that the last increment by",
            "\t * @size did not wrap 0.",
            "\t */",
            "\treturn addr > addr - size &&",
            "\t       addr <= min_t(resource_size_t, base->end, PHYSMEM_END);",
            "}",
            "static resource_size_t gfr_next(resource_size_t addr, resource_size_t size,",
            "\t\t\t\tunsigned long flags)",
            "{",
            "\tif (flags & GFR_DESCENDING)",
            "\t\treturn addr - size;",
            "\treturn addr + size;",
            "}",
            "static void remove_free_mem_region(void *_res)",
            "{",
            "\tstruct resource *res = _res;",
            "",
            "\tif (res->parent)",
            "\t\tremove_resource(res);",
            "\tfree_resource(res);",
            "}",
            "static int __init strict_iomem(char *str)",
            "{",
            "\tif (strstr(str, \"relaxed\"))",
            "\t\tstrict_iomem_checks = 0;",
            "\tif (strstr(str, \"strict\"))",
            "\t\tstrict_iomem_checks = 1;",
            "\treturn 1;",
            "}",
            "static int iomem_fs_init_fs_context(struct fs_context *fc)",
            "{",
            "\treturn init_pseudo(fc, DEVMEM_MAGIC) ? 0 : -ENOMEM;",
            "}",
            "static int __init iomem_init_inode(void)",
            "{",
            "\tstatic struct vfsmount *iomem_vfs_mount;",
            "\tstatic int iomem_fs_cnt;",
            "\tstruct inode *inode;",
            "\tint rc;",
            "",
            "\trc = simple_pin_fs(&iomem_fs_type, &iomem_vfs_mount, &iomem_fs_cnt);",
            "\tif (rc < 0) {",
            "\t\tpr_err(\"Cannot mount iomem pseudo filesystem: %d\\n\", rc);",
            "\t\treturn rc;",
            "\t}",
            "",
            "\tinode = alloc_anon_inode(iomem_vfs_mount->mnt_sb);",
            "\tif (IS_ERR(inode)) {",
            "\t\trc = PTR_ERR(inode);",
            "\t\tpr_err(\"Cannot allocate inode for iomem: %d\\n\", rc);",
            "\t\tsimple_release_fs(&iomem_vfs_mount, &iomem_fs_cnt);",
            "\t\treturn rc;",
            "\t}",
            "",
            "\t/*",
            "\t * Publish iomem revocation inode initialized.",
            "\t * Pairs with smp_load_acquire() in revoke_iomem().",
            "\t */",
            "\tsmp_store_release(&iomem_inode, inode);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "gfr_continue, gfr_next, remove_free_mem_region, strict_iomem, iomem_fs_init_fs_context, iomem_init_inode",
          "description": "gfr_continue 检查当前地址是否满足连续分配条件；gfr_next 计算下一块可用地址；remove_free_mem_region 从资源树中移除并释放指定内存区域；strict_iomem 解析内核启动参数设置严格IOMAP检查标志；iomem_fs_init_fs_context 初始化IOMEM伪文件系统的上下文；iomem_init_inode 创建并挂载IOMEM伪文件系统的匿名inode节点。",
          "similarity": 0.5582702159881592
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/resource.c",
          "start_line": 1,
          "end_line": 103,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *\tlinux/kernel/resource.c",
            " *",
            " * Copyright (C) 1999\tLinus Torvalds",
            " * Copyright (C) 1999\tMartin Mares <mj@ucw.cz>",
            " *",
            " * Arbitrary resource management.",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/ioport.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/device.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/resource_ext.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <asm/io.h>",
            "",
            "",
            "struct resource ioport_resource = {",
            "\t.name\t= \"PCI IO\",",
            "\t.start\t= 0,",
            "\t.end\t= IO_SPACE_LIMIT,",
            "\t.flags\t= IORESOURCE_IO,",
            "};",
            "EXPORT_SYMBOL(ioport_resource);",
            "",
            "struct resource iomem_resource = {",
            "\t.name\t= \"PCI mem\",",
            "\t.start\t= 0,",
            "\t.end\t= -1,",
            "\t.flags\t= IORESOURCE_MEM,",
            "};",
            "EXPORT_SYMBOL(iomem_resource);",
            "",
            "/* constraints to be met while allocating resources */",
            "struct resource_constraint {",
            "\tresource_size_t min, max, align;",
            "\tresource_size_t (*alignf)(void *, const struct resource *,",
            "\t\t\tresource_size_t, resource_size_t);",
            "\tvoid *alignf_data;",
            "};",
            "",
            "static DEFINE_RWLOCK(resource_lock);",
            "",
            "static struct resource *next_resource(struct resource *p)",
            "{",
            "\tif (p->child)",
            "\t\treturn p->child;",
            "\twhile (!p->sibling && p->parent)",
            "\t\tp = p->parent;",
            "\treturn p->sibling;",
            "}",
            "",
            "static struct resource *next_resource_skip_children(struct resource *p)",
            "{",
            "\twhile (!p->sibling && p->parent)",
            "\t\tp = p->parent;",
            "\treturn p->sibling;",
            "}",
            "",
            "#define for_each_resource(_root, _p, _skip_children) \\",
            "\tfor ((_p) = (_root)->child; (_p); \\",
            "\t     (_p) = (_skip_children) ? next_resource_skip_children(_p) : \\",
            "\t\t\t\t       next_resource(_p))",
            "",
            "static void *r_next(struct seq_file *m, void *v, loff_t *pos)",
            "{",
            "\tstruct resource *p = v;",
            "\t(*pos)++;",
            "\treturn (void *)next_resource(p);",
            "}",
            "",
            "#ifdef CONFIG_PROC_FS",
            "",
            "enum { MAX_IORES_LEVEL = 5 };",
            "",
            "static void *r_start(struct seq_file *m, loff_t *pos)",
            "\t__acquires(resource_lock)",
            "{",
            "\tstruct resource *p = pde_data(file_inode(m->file));",
            "\tloff_t l = 0;",
            "\tread_lock(&resource_lock);",
            "\tfor (p = p->child; p && l < *pos; p = r_next(m, p, &l))",
            "\t\t;",
            "\treturn p;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义并导出IO端口和内存资源结构体ioport_resource和iomem_resource，初始化资源管理锁及遍历链表辅助函数，用于后续资源树的遍历和操作。",
          "similarity": 0.5505561828613281
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/resource.c",
          "start_line": 1208,
          "end_line": 1327,
          "content": [
            "static void revoke_iomem(struct resource *res)",
            "{",
            "\t/* pairs with smp_store_release() in iomem_init_inode() */",
            "\tstruct inode *inode = smp_load_acquire(&iomem_inode);",
            "",
            "\t/*",
            "\t * Check that the initialization has completed. Losing the race",
            "\t * is ok because it means drivers are claiming resources before",
            "\t * the fs_initcall level of init and prevent iomem_get_mapping users",
            "\t * from establishing mappings.",
            "\t */",
            "\tif (!inode)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * The expectation is that the driver has successfully marked",
            "\t * the resource busy by this point, so devmem_is_allowed()",
            "\t * should start returning false, however for performance this",
            "\t * does not iterate the entire resource range.",
            "\t */",
            "\tif (devmem_is_allowed(PHYS_PFN(res->start)) &&",
            "\t    devmem_is_allowed(PHYS_PFN(res->end))) {",
            "\t\t/*",
            "\t\t * *cringe* iomem=relaxed says \"go ahead, what's the",
            "\t\t * worst that can happen?\"",
            "\t\t */",
            "\t\treturn;",
            "\t}",
            "",
            "\tunmap_mapping_range(inode->i_mapping, res->start, resource_size(res), 1);",
            "}",
            "static void revoke_iomem(struct resource *res) {}",
            "static int __request_region_locked(struct resource *res, struct resource *parent,",
            "\t\t\t\t   resource_size_t start, resource_size_t n,",
            "\t\t\t\t   const char *name, int flags)",
            "{",
            "\tDECLARE_WAITQUEUE(wait, current);",
            "",
            "\tres->name = name;",
            "\tres->start = start;",
            "\tres->end = start + n - 1;",
            "",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tres->flags = resource_type(parent) | resource_ext_type(parent);",
            "\t\tres->flags |= IORESOURCE_BUSY | flags;",
            "\t\tres->desc = parent->desc;",
            "",
            "\t\tconflict = __request_resource(parent, res);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * mm/hmm.c reserves physical addresses which then",
            "\t\t * become unavailable to other users.  Conflicts are",
            "\t\t * not expected.  Warn to aid debugging if encountered.",
            "\t\t */",
            "\t\tif (parent == &iomem_resource &&",
            "\t\t    conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {",
            "\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\\n\",",
            "\t\t\t\tconflict->name, conflict, res);",
            "\t\t}",
            "\t\tif (conflict != parent) {",
            "\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {",
            "\t\t\t\tparent = conflict;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {",
            "\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);",
            "\t\t\twrite_unlock(&resource_lock);",
            "\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);",
            "\t\t\tschedule();",
            "\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);",
            "\t\t\twrite_lock(&resource_lock);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/* Uhhuh, that didn't work out.. */",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __release_region(struct resource *parent, resource_size_t start,",
            "\t\t      resource_size_t n)",
            "{",
            "\tstruct resource **p;",
            "\tresource_size_t end;",
            "",
            "\tp = &parent->child;",
            "\tend = start + n - 1;",
            "",
            "\twrite_lock(&resource_lock);",
            "",
            "\tfor (;;) {",
            "\t\tstruct resource *res = *p;",
            "",
            "\t\tif (!res)",
            "\t\t\tbreak;",
            "\t\tif (res->start <= start && res->end >= end) {",
            "\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {",
            "\t\t\t\tp = &res->child;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif (res->start != start || res->end != end)",
            "\t\t\t\tbreak;",
            "\t\t\t*p = res->sibling;",
            "\t\t\twrite_unlock(&resource_lock);",
            "\t\t\tif (res->flags & IORESOURCE_MUXED)",
            "\t\t\t\twake_up(&muxed_resource_wait);",
            "\t\t\tfree_resource(res);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tp = &res->sibling;",
            "\t}",
            "",
            "\twrite_unlock(&resource_lock);",
            "",
            "\tpr_warn(\"Trying to free nonexistent resource <%pa-%pa>\\n\", &start, &end);",
            "}"
          ],
          "function_name": "revoke_iomem, revoke_iomem, __request_region_locked, __release_region",
          "description": "实现IOMEM资源撤销机制，包含受保护的区域请求锁管理、资源释放及冲突处理逻辑，维护资源树结构。",
          "similarity": 0.5233843326568604
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/resource.c",
          "start_line": 1739,
          "end_line": 1846,
          "content": [
            "int iomem_map_sanity_check(resource_size_t addr, unsigned long size)",
            "{",
            "\tstruct resource *p = &iomem_resource;",
            "\tresource_size_t end = addr + size - 1;",
            "\tint err = 0;",
            "\tloff_t l;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {",
            "\t\t/*",
            "\t\t * We can probably skip the resources without",
            "\t\t * IORESOURCE_IO attribute?",
            "\t\t */",
            "\t\tif (p->start > end)",
            "\t\t\tcontinue;",
            "\t\tif (p->end < addr)",
            "\t\t\tcontinue;",
            "\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&",
            "\t\t    PFN_DOWN(p->end) >= PFN_DOWN(end))",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * if a resource is \"BUSY\", it's not a hardware resource",
            "\t\t * but a driver mapping of such a resource; we don't want",
            "\t\t * to warn for those; some drivers legitimately map only",
            "\t\t * partial hardware resources. (example: vesafb)",
            "\t\t */",
            "\t\tif (p->flags & IORESOURCE_BUSY)",
            "\t\t\tcontinue;",
            "",
            "\t\tpr_warn(\"resource sanity check: requesting [mem %pa-%pa], which spans more than %s %pR\\n\",",
            "\t\t\t&addr, &end, p->name, p);",
            "\t\terr = -1;",
            "\t\tbreak;",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool resource_is_exclusive(struct resource *root, u64 addr, resource_size_t size)",
            "{",
            "\tconst unsigned int exclusive_system_ram = IORESOURCE_SYSTEM_RAM |",
            "\t\t\t\t\t\t  IORESOURCE_EXCLUSIVE;",
            "\tbool skip_children = false, err = false;",
            "\tstruct resource *p;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor_each_resource(root, p, skip_children) {",
            "\t\tif (p->start >= addr + size)",
            "\t\t\tbreak;",
            "\t\tif (p->end < addr) {",
            "\t\t\tskip_children = true;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tskip_children = false;",
            "",
            "\t\t/*",
            "\t\t * IORESOURCE_SYSTEM_RAM resources are exclusive if",
            "\t\t * IORESOURCE_EXCLUSIVE is set, even if they",
            "\t\t * are not busy and even if \"iomem=relaxed\" is set. The",
            "\t\t * responsible driver dynamically adds/removes system RAM within",
            "\t\t * such an area and uncontrolled access is dangerous.",
            "\t\t */",
            "\t\tif ((p->flags & exclusive_system_ram) == exclusive_system_ram) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * A resource is exclusive if IORESOURCE_EXCLUSIVE is set",
            "\t\t * or CONFIG_IO_STRICT_DEVMEM is enabled and the",
            "\t\t * resource is busy.",
            "\t\t */",
            "\t\tif (!strict_iomem_checks || !(p->flags & IORESOURCE_BUSY))",
            "\t\t\tcontinue;",
            "\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)",
            "\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool iomem_is_exclusive(u64 addr)",
            "{",
            "\treturn resource_is_exclusive(&iomem_resource, addr & PAGE_MASK,",
            "\t\t\t\t     PAGE_SIZE);",
            "}",
            "void resource_list_free(struct list_head *head)",
            "{",
            "\tstruct resource_entry *entry, *tmp;",
            "",
            "\tlist_for_each_entry_safe(entry, tmp, head, node)",
            "\t\tresource_list_destroy_entry(entry);",
            "}",
            "static resource_size_t gfr_start(struct resource *base, resource_size_t size,",
            "\t\t\t\t resource_size_t align, unsigned long flags)",
            "{",
            "\tif (flags & GFR_DESCENDING) {",
            "\t\tresource_size_t end;",
            "",
            "\t\tend = min_t(resource_size_t, base->end, PHYSMEM_END);",
            "\t\treturn end - size + 1;",
            "\t}",
            "",
            "\treturn ALIGN(base->start, align);",
            "}"
          ],
          "function_name": "iomem_map_sanity_check, resource_is_exclusive, iomem_is_exclusive, resource_list_free, gfr_start",
          "description": "iomem_map_sanity_check 检查新请求的I/O内存区域是否与现有资源冲突，若存在覆盖则返回-1；resource_is_exclusive 判断目标地址是否属于独占资源，依据IORESOURCE_EXCLUSIVE标志及CONFIG_IO_STRICT_DEVMEM配置；iomem_is_exclusive 简化调用resource_is_exclusive检查单个地址；resource_list_free 遍历并销毁指定链表中的所有resource_entry；gfr_start 根据对齐方向计算起始地址，支持降序分配模式。",
          "similarity": 0.5149753093719482
        }
      ]
    }
  ]
}