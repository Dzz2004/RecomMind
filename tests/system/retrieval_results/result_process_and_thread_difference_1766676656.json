{
  "query": "process and thread difference",
  "timestamp": "2025-12-25 23:30:56",
  "retrieved_files": [
    {
      "source_file": "kernel/kthread.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:30:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kthread.c`\n\n---\n\n# kthread.c 技术文档\n\n## 文件概述\n\n`kthread.c` 是 Linux 内核中实现内核线程（kernel thread, kthread）管理机制的核心文件。它提供了创建、控制、同步和销毁内核线程的基础设施，确保内核线程在干净、受控的环境中运行，即使是从用户空间（如 modprobe、CPU 热插拔等）触发创建也能保证一致性。该文件实现了 kthread 的生命周期管理、状态控制（如停止、暂停）、数据访问接口以及与调度器、cgroup、freezer 等子系统的集成。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct kthread_create_info`**  \n  用于在 `kthread_create()` 和后台守护线程 `kthreadd` 之间传递创建参数和结果，包含线程函数、数据、节点信息、任务结构体指针和完成量。\n\n- **`struct kthread`**  \n  内核线程的私有控制块，挂载在 `task_struct->worker_private` 上，包含：\n  - 状态标志位（`KTHREAD_IS_PER_CPU`, `KTHREAD_SHOULD_STOP`, `KTHREAD_SHOULD_PARK`）\n  - CPU 绑定信息\n  - 线程函数指针和用户数据\n  - 用于同步的 `parked` 和 `exited` 完成量\n  - 完整线程名（当 `task->comm` 被截断时使用）\n  - （可选）块设备 cgroup 上下文（`blkcg_css`）\n\n- **全局变量**\n  - `kthread_create_lock`：保护 `kthread_create_list` 的自旋锁\n  - `kthread_create_list`：待创建内核线程的请求队列\n  - `kthreadd_task`：负责实际创建内核线程的守护进程任务结构体\n\n### 主要函数\n\n- **状态查询函数**\n  - `kthread_should_stop()`：检查是否应停止线程（由 `kthread_stop()` 触发）\n  - `kthread_should_park()`：检查是否应暂停线程（由 `kthread_park()` 触发）\n  - `kthread_should_stop_or_park()`：同时检查停止或暂停请求\n  - `kthread_freezable_should_stop()`：支持冻结的 kthread 停止检查，集成 freezer 机制\n\n- **数据访问函数**\n  - `kthread_func()`：获取线程创建时指定的函数指针\n  - `kthread_data()`：获取线程创建时传入的私有数据\n  - `kthread_probe_data()`：安全地探测可能的 kthread 数据（使用 `copy_from_kernel_nofault` 避免崩溃）\n  - `get_kthread_comm()`：获取完整的线程名称（优先使用 `full_name`）\n\n- **生命周期管理**\n  - `set_kthread_struct()`：为新任务分配并初始化 `struct kthread`\n  - `free_kthread_struct()`：释放 `struct kthread` 及其资源\n  - `kthread_parkme()`：将当前线程置于 `TASK_PARKED` 状态并等待唤醒\n  - `kthread_exit()`：终止当前 kthread 并返回结果（未在代码片段中完整显示）\n\n- **辅助函数**\n  - `to_kthread()` / `__to_kthread()`：从 `task_struct` 安全转换为 `struct kthread`，后者不假设任务一定是 kthread\n\n## 关键实现\n\n### kthread 私有数据管理\n- 每个 kthread 通过 `task_struct->worker_private` 指向其 `struct kthread` 实例。\n- `to_kthread()` 在访问前验证 `PF_KTHREAD` 标志，确保类型安全。\n- `__to_kthread()` 更加保守，仅在同时满足 `worker_private != NULL` 且 `PF_KTHREAD` 时才返回有效指针，以应对 `kernel_thread()` 可能执行 `exec()` 导致标志失效的情况。\n\n### 线程暂停机制（Parking）\n- 使用 `TASK_PARKED` 特殊任务状态，避免与常规调度状态冲突。\n- 在设置状态和检查标志之间使用原子操作，防止唤醒丢失。\n- 调用 `schedule_preempt_disabled()` 禁用抢占，确保 `kthread_park()` 调用者能可靠检测到线程已暂停。\n\n### 安全数据访问\n- `kthread_probe_data()` 使用 `copy_from_kernel_nofault()` 安全读取数据指针，即使目标内存无效也不会导致内核 oops，适用于调试或不确定上下文。\n\n### 冻结集成\n- `kthread_freezable_should_stop()` 在检查停止标志前先处理冻结请求，调用 `__refrigerator()` 进入冻结状态，避免 freezer 与 kthread_stop 死锁。\n\n### 名称管理\n- 当线程名超过 `TASK_COMM_LEN` 时，原始名称存储在 `kthread->full_name` 中，`get_kthread_comm()` 优先返回完整名称。\n\n## 依赖关系\n\n- **调度子系统**：依赖 `sched.h` 提供任务状态管理、调度原语（`schedule()`）、CPU 隔离等。\n- **内存管理**：使用 `slab.h` 分配 `kthread` 结构，`mm.h` 处理内存上下文。\n- **同步机制**：依赖 `completion.h` 实现线程创建和状态同步。\n- **cgroup 子系统**：条件编译支持 `CONFIG_BLK_CGROUP`，集成块设备 cgroup 控制。\n- **冻结子系统**：通过 `freezer.h` 与系统 suspend/hibernate 机制协作。\n- **追踪系统**：集成 `trace/events/sched.h` 提供调度事件追踪。\n- **用户空间接口**：通过 `uaccess.h` 支持安全内核空间访问（用于 `kthread_probe_data`）。\n\n## 使用场景\n\n- **内核模块加载**：`modprobe` 触发的模块可能创建 kthread，需通过 `kthreadd` 确保干净环境。\n- **设备驱动**：驱动程序使用 `kthread_run()` 创建工作线程处理中断下半部或轮询任务。\n- **系统服务线程**：如 `kswapd`（内存回收）、`kcompactd`（内存压缩）等核心内核线程。\n- **CPU 热插拔**：在 CPU 上下线时创建或迁移 per-CPU kthread。\n- **电源管理**：通过 `kthread_freezable_should_stop()` 支持系统 suspend 时冻结 kthread。\n- **动态资源管理**：使用 `kthread_park/unpark` 暂停/恢复线程以节省资源（如空闲时暂停工作线程）。\n- **调试与监控**：工具通过 `kthread_func()` 和 `kthread_data()` 获取线程上下文信息。",
      "similarity": 0.5266774296760559,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/kthread.c",
          "start_line": 299,
          "end_line": 413,
          "content": [
            "void kthread_parkme(void)",
            "{",
            "\t__kthread_parkme(to_kthread(current));",
            "}",
            "void __noreturn kthread_exit(long result)",
            "{",
            "\tstruct kthread *kthread = to_kthread(current);",
            "\tkthread->result = result;",
            "\tdo_exit(0);",
            "}",
            "void __noreturn kthread_complete_and_exit(struct completion *comp, long code)",
            "{",
            "\tif (comp)",
            "\t\tcomplete(comp);",
            "",
            "\tkthread_exit(code);",
            "}",
            "static int kthread(void *_create)",
            "{",
            "\tstatic const struct sched_param param = { .sched_priority = 0 };",
            "\t/* Copy data: it's on kthread's stack */",
            "\tstruct kthread_create_info *create = _create;",
            "\tint (*threadfn)(void *data) = create->threadfn;",
            "\tvoid *data = create->data;",
            "\tstruct completion *done;",
            "\tstruct kthread *self;",
            "\tint ret;",
            "",
            "\tself = to_kthread(current);",
            "",
            "\t/* Release the structure when caller killed by a fatal signal. */",
            "\tdone = xchg(&create->done, NULL);",
            "\tif (!done) {",
            "\t\tkfree(create->full_name);",
            "\t\tkfree(create);",
            "\t\tkthread_exit(-EINTR);",
            "\t}",
            "",
            "\tself->full_name = create->full_name;",
            "\tself->threadfn = threadfn;",
            "\tself->data = data;",
            "",
            "\t/*",
            "\t * The new thread inherited kthreadd's priority and CPU mask. Reset",
            "\t * back to default in case they have been changed.",
            "\t */",
            "\tsched_setscheduler_nocheck(current, SCHED_NORMAL, &param);",
            "\tset_cpus_allowed_ptr(current, housekeeping_cpumask(HK_TYPE_KTHREAD));",
            "",
            "\t/* OK, tell user we're spawned, wait for stop or wakeup */",
            "\t__set_current_state(TASK_UNINTERRUPTIBLE);",
            "\tcreate->result = current;",
            "\t/*",
            "\t * Thread is going to call schedule(), do not preempt it,",
            "\t * or the creator may spend more time in wait_task_inactive().",
            "\t */",
            "\tpreempt_disable();",
            "\tcomplete(done);",
            "\tschedule_preempt_disabled();",
            "\tpreempt_enable();",
            "",
            "\tret = -EINTR;",
            "\tif (!test_bit(KTHREAD_SHOULD_STOP, &self->flags)) {",
            "\t\tcgroup_kthread_ready();",
            "\t\t__kthread_parkme(self);",
            "\t\tret = threadfn(data);",
            "\t}",
            "\tkthread_exit(ret);",
            "}",
            "int tsk_fork_get_node(struct task_struct *tsk)",
            "{",
            "#ifdef CONFIG_NUMA",
            "\tif (tsk == kthreadd_task)",
            "\t\treturn tsk->pref_node_fork;",
            "#endif",
            "\treturn NUMA_NO_NODE;",
            "}",
            "static void create_kthread(struct kthread_create_info *create)",
            "{",
            "\tint pid;",
            "",
            "#ifdef CONFIG_NUMA",
            "\tcurrent->pref_node_fork = create->node;",
            "#endif",
            "\t/* We want our own signal handler (we take no signals by default). */",
            "\tpid = kernel_thread(kthread, create, create->full_name,",
            "\t\t\t    CLONE_FS | CLONE_FILES | SIGCHLD);",
            "\tif (pid < 0) {",
            "\t\t/* Release the structure when caller killed by a fatal signal. */",
            "\t\tstruct completion *done = xchg(&create->done, NULL);",
            "",
            "\t\tkfree(create->full_name);",
            "\t\tif (!done) {",
            "\t\t\tkfree(create);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tcreate->result = ERR_PTR(pid);",
            "\t\tcomplete(done);",
            "\t}",
            "}",
            "static void __kthread_bind_mask(struct task_struct *p, const struct cpumask *mask, unsigned int state)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!wait_task_inactive(p, state)) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* It's safe because the task is inactive. */",
            "\traw_spin_lock_irqsave(&p->pi_lock, flags);",
            "\tdo_set_cpus_allowed(p, mask);",
            "\tp->flags |= PF_NO_SETAFFINITY;",
            "\traw_spin_unlock_irqrestore(&p->pi_lock, flags);",
            "}"
          ],
          "function_name": "kthread_parkme, kthread_exit, kthread_complete_and_exit, kthread, tsk_fork_get_node, create_kthread, __kthread_bind_mask",
          "description": "处理线程执行流程、节点绑定及异常退出，kthread作为内核线程入口执行指定函数，create_kthread创建新线程并绑定CPU，__kthread_bind_mask调整线程CPU亲和性。",
          "similarity": 0.5458899140357971
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/kthread.c",
          "start_line": 982,
          "end_line": 1095,
          "content": [
            "static inline bool queuing_blocked(struct kthread_worker *worker,",
            "\t\t\t\t   struct kthread_work *work)",
            "{",
            "\tlockdep_assert_held(&worker->lock);",
            "",
            "\treturn !list_empty(&work->node) || work->canceling;",
            "}",
            "static void kthread_insert_work_sanity_check(struct kthread_worker *worker,",
            "\t\t\t\t\t     struct kthread_work *work)",
            "{",
            "\tlockdep_assert_held(&worker->lock);",
            "\tWARN_ON_ONCE(!list_empty(&work->node));",
            "\t/* Do not use a work with >1 worker, see kthread_queue_work() */",
            "\tWARN_ON_ONCE(work->worker && work->worker != worker);",
            "}",
            "static void kthread_insert_work(struct kthread_worker *worker,",
            "\t\t\t\tstruct kthread_work *work,",
            "\t\t\t\tstruct list_head *pos)",
            "{",
            "\tkthread_insert_work_sanity_check(worker, work);",
            "",
            "\ttrace_sched_kthread_work_queue_work(worker, work);",
            "",
            "\tlist_add_tail(&work->node, pos);",
            "\twork->worker = worker;",
            "\tif (!worker->current_work && likely(worker->task))",
            "\t\twake_up_process(worker->task);",
            "}",
            "bool kthread_queue_work(struct kthread_worker *worker,",
            "\t\t\tstruct kthread_work *work)",
            "{",
            "\tbool ret = false;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "\tif (!queuing_blocked(worker, work)) {",
            "\t\tkthread_insert_work(worker, work, &worker->work_list);",
            "\t\tret = true;",
            "\t}",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "\treturn ret;",
            "}",
            "void kthread_delayed_work_timer_fn(struct timer_list *t)",
            "{",
            "\tstruct kthread_delayed_work *dwork = from_timer(dwork, t, timer);",
            "\tstruct kthread_work *work = &dwork->work;",
            "\tstruct kthread_worker *worker = work->worker;",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * This might happen when a pending work is reinitialized.",
            "\t * It means that it is used a wrong way.",
            "\t */",
            "\tif (WARN_ON_ONCE(!worker))",
            "\t\treturn;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "\t/* Work must not be used with >1 worker, see kthread_queue_work(). */",
            "\tWARN_ON_ONCE(work->worker != worker);",
            "",
            "\t/* Move the work from worker->delayed_work_list. */",
            "\tWARN_ON_ONCE(list_empty(&work->node));",
            "\tlist_del_init(&work->node);",
            "\tif (!work->canceling)",
            "\t\tkthread_insert_work(worker, work, &worker->work_list);",
            "",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "}",
            "static void __kthread_queue_delayed_work(struct kthread_worker *worker,",
            "\t\t\t\t\t struct kthread_delayed_work *dwork,",
            "\t\t\t\t\t unsigned long delay)",
            "{",
            "\tstruct timer_list *timer = &dwork->timer;",
            "\tstruct kthread_work *work = &dwork->work;",
            "",
            "\tWARN_ON_ONCE(timer->function != kthread_delayed_work_timer_fn);",
            "",
            "\t/*",
            "\t * If @delay is 0, queue @dwork->work immediately.  This is for",
            "\t * both optimization and correctness.  The earliest @timer can",
            "\t * expire is on the closest next tick and delayed_work users depend",
            "\t * on that there's no such delay when @delay is 0.",
            "\t */",
            "\tif (!delay) {",
            "\t\tkthread_insert_work(worker, work, &worker->work_list);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Be paranoid and try to detect possible races already now. */",
            "\tkthread_insert_work_sanity_check(worker, work);",
            "",
            "\tlist_add(&work->node, &worker->delayed_work_list);",
            "\twork->worker = worker;",
            "\ttimer->expires = jiffies + delay;",
            "\tadd_timer(timer);",
            "}",
            "bool kthread_queue_delayed_work(struct kthread_worker *worker,",
            "\t\t\t\tstruct kthread_delayed_work *dwork,",
            "\t\t\t\tunsigned long delay)",
            "{",
            "\tstruct kthread_work *work = &dwork->work;",
            "\tunsigned long flags;",
            "\tbool ret = false;",
            "",
            "\traw_spin_lock_irqsave(&worker->lock, flags);",
            "",
            "\tif (!queuing_blocked(worker, work)) {",
            "\t\t__kthread_queue_delayed_work(worker, dwork, delay);",
            "\t\tret = true;",
            "\t}",
            "",
            "\traw_spin_unlock_irqrestore(&worker->lock, flags);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "queuing_blocked, kthread_insert_work_sanity_check, kthread_insert_work, kthread_queue_work, kthread_delayed_work_timer_fn, __kthread_queue_delayed_work, kthread_queue_delayed_work",
          "description": "实现kthread_worker与kthread_work的队列管理，包含插入/延迟插入逻辑、锁保护及任务唤醒机制，处理工作项状态校验和延迟定时器回调",
          "similarity": 0.5349231958389282
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/kthread.c",
          "start_line": 731,
          "end_line": 846,
          "content": [
            "int kthread_stop_put(struct task_struct *k)",
            "{",
            "\tint ret;",
            "",
            "\tret = kthread_stop(k);",
            "\tput_task_struct(k);",
            "\treturn ret;",
            "}",
            "int kthreadd(void *unused)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\t/* Setup a clean context for our children to inherit. */",
            "\tset_task_comm(tsk, \"kthreadd\");",
            "\tignore_signals(tsk);",
            "\tset_cpus_allowed_ptr(tsk, housekeeping_cpumask(HK_TYPE_KTHREAD));",
            "\tset_mems_allowed(node_states[N_MEMORY]);",
            "",
            "\tcurrent->flags |= PF_NOFREEZE;",
            "\tcgroup_init_kthreadd();",
            "",
            "\tfor (;;) {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tif (list_empty(&kthread_create_list))",
            "\t\t\tschedule();",
            "\t\t__set_current_state(TASK_RUNNING);",
            "",
            "\t\tspin_lock(&kthread_create_lock);",
            "\t\twhile (!list_empty(&kthread_create_list)) {",
            "\t\t\tstruct kthread_create_info *create;",
            "",
            "\t\t\tcreate = list_entry(kthread_create_list.next,",
            "\t\t\t\t\t    struct kthread_create_info, list);",
            "\t\t\tlist_del_init(&create->list);",
            "\t\t\tspin_unlock(&kthread_create_lock);",
            "",
            "\t\t\tcreate_kthread(create);",
            "",
            "\t\t\tspin_lock(&kthread_create_lock);",
            "\t\t}",
            "\t\tspin_unlock(&kthread_create_lock);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __kthread_init_worker(struct kthread_worker *worker,",
            "\t\t\t\tconst char *name,",
            "\t\t\t\tstruct lock_class_key *key)",
            "{",
            "\tmemset(worker, 0, sizeof(struct kthread_worker));",
            "\traw_spin_lock_init(&worker->lock);",
            "\tlockdep_set_class_and_name(&worker->lock, key, name);",
            "\tINIT_LIST_HEAD(&worker->work_list);",
            "\tINIT_LIST_HEAD(&worker->delayed_work_list);",
            "}",
            "int kthread_worker_fn(void *worker_ptr)",
            "{",
            "\tstruct kthread_worker *worker = worker_ptr;",
            "\tstruct kthread_work *work;",
            "",
            "\t/*",
            "\t * FIXME: Update the check and remove the assignment when all kthread",
            "\t * worker users are created using kthread_create_worker*() functions.",
            "\t */",
            "\tWARN_ON(worker->task && worker->task != current);",
            "\tworker->task = current;",
            "",
            "\tif (worker->flags & KTW_FREEZABLE)",
            "\t\tset_freezable();",
            "",
            "repeat:",
            "\tset_current_state(TASK_INTERRUPTIBLE);\t/* mb paired w/ kthread_stop */",
            "",
            "\tif (kthread_should_stop()) {",
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t\traw_spin_lock_irq(&worker->lock);",
            "\t\tworker->task = NULL;",
            "\t\traw_spin_unlock_irq(&worker->lock);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\twork = NULL;",
            "\traw_spin_lock_irq(&worker->lock);",
            "\tif (!list_empty(&worker->work_list)) {",
            "\t\twork = list_first_entry(&worker->work_list,",
            "\t\t\t\t\tstruct kthread_work, node);",
            "\t\tlist_del_init(&work->node);",
            "\t}",
            "\tworker->current_work = work;",
            "\traw_spin_unlock_irq(&worker->lock);",
            "",
            "\tif (work) {",
            "\t\tkthread_work_func_t func = work->func;",
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t\ttrace_sched_kthread_work_execute_start(work);",
            "\t\twork->func(work);",
            "\t\t/*",
            "\t\t * Avoid dereferencing work after this point.  The trace",
            "\t\t * event only cares about the address.",
            "\t\t */",
            "\t\ttrace_sched_kthread_work_execute_end(work, func);",
            "\t} else if (!freezing(current)) {",
            "\t\tschedule();",
            "\t} else {",
            "\t\t/*",
            "\t\t * Handle the case where the current remains",
            "\t\t * TASK_INTERRUPTIBLE. try_to_freeze() expects",
            "\t\t * the current to be TASK_RUNNING.",
            "\t\t */",
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t}",
            "",
            "\ttry_to_freeze();",
            "\tcond_resched();",
            "\tgoto repeat;",
            "}"
          ],
          "function_name": "kthread_stop_put, kthreadd, __kthread_init_worker, kthread_worker_fn",
          "description": "实现kthreadd主线程逻辑及工作队列管理，kthreadd持续处理线程创建请求，kthread_worker_fn作为工作队列执行入口，支持可冻结状态下的任务调度。",
          "similarity": 0.4809863567352295
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/kthread.c",
          "start_line": 538,
          "end_line": 639,
          "content": [
            "static void __kthread_bind(struct task_struct *p, unsigned int cpu, unsigned int state)",
            "{",
            "\t__kthread_bind_mask(p, cpumask_of(cpu), state);",
            "}",
            "void kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)",
            "{",
            "\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);",
            "}",
            "void kthread_bind(struct task_struct *p, unsigned int cpu)",
            "{",
            "\t__kthread_bind(p, cpu, TASK_UNINTERRUPTIBLE);",
            "}",
            "void kthread_set_per_cpu(struct task_struct *k, int cpu)",
            "{",
            "\tstruct kthread *kthread = to_kthread(k);",
            "\tif (!kthread)",
            "\t\treturn;",
            "",
            "\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));",
            "",
            "\tif (cpu < 0) {",
            "\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);",
            "\t\treturn;",
            "\t}",
            "",
            "\tkthread->cpu = cpu;",
            "\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);",
            "}",
            "bool kthread_is_per_cpu(struct task_struct *p)",
            "{",
            "\tstruct kthread *kthread = __to_kthread(p);",
            "\tif (!kthread)",
            "\t\treturn false;",
            "",
            "\treturn test_bit(KTHREAD_IS_PER_CPU, &kthread->flags);",
            "}",
            "void kthread_unpark(struct task_struct *k)",
            "{",
            "\tstruct kthread *kthread = to_kthread(k);",
            "",
            "\tif (!test_bit(KTHREAD_SHOULD_PARK, &kthread->flags))",
            "\t\treturn;",
            "\t/*",
            "\t * Newly created kthread was parked when the CPU was offline.",
            "\t * The binding was lost and we need to set it again.",
            "\t */",
            "\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))",
            "\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);",
            "",
            "\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);",
            "\t/*",
            "\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.",
            "\t */",
            "\twake_up_state(k, TASK_PARKED);",
            "}",
            "int kthread_park(struct task_struct *k)",
            "{",
            "\tstruct kthread *kthread = to_kthread(k);",
            "",
            "\tif (WARN_ON(k->flags & PF_EXITING))",
            "\t\treturn -ENOSYS;",
            "",
            "\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))",
            "\t\treturn -EBUSY;",
            "",
            "\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);",
            "\tif (k != current) {",
            "\t\twake_up_process(k);",
            "\t\t/*",
            "\t\t * Wait for __kthread_parkme() to complete(), this means we",
            "\t\t * _will_ have TASK_PARKED and are about to call schedule().",
            "\t\t */",
            "\t\twait_for_completion(&kthread->parked);",
            "\t\t/*",
            "\t\t * Now wait for that schedule() to complete and the task to",
            "\t\t * get scheduled out.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int kthread_stop(struct task_struct *k)",
            "{",
            "\tstruct kthread *kthread;",
            "\tint ret;",
            "",
            "\ttrace_sched_kthread_stop(k);",
            "",
            "\tget_task_struct(k);",
            "\tkthread = to_kthread(k);",
            "\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);",
            "\tkthread_unpark(k);",
            "\tset_tsk_thread_flag(k, TIF_NOTIFY_SIGNAL);",
            "\twake_up_process(k);",
            "\twait_for_completion(&kthread->exited);",
            "\tret = kthread->result;",
            "\tput_task_struct(k);",
            "",
            "\ttrace_sched_kthread_stop_ret(ret);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__kthread_bind, kthread_bind_mask, kthread_bind, kthread_set_per_cpu, kthread_is_per_cpu, kthread_unpark, kthread_park, kthread_stop",
          "description": "提供线程CPU绑定、停放/终止控制接口，kthread_park/kthread_stop修改线程状态标志并触发唤醒，kthread_is_per_cpu检测线程是否固定CPU运行。",
          "similarity": 0.4739774763584137
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/kthread.c",
          "start_line": 1490,
          "end_line": 1539,
          "content": [
            "void kthread_unuse_mm(struct mm_struct *mm)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tWARN_ON_ONCE(!(tsk->flags & PF_KTHREAD));",
            "\tWARN_ON_ONCE(!tsk->mm);",
            "",
            "\ttask_lock(tsk);",
            "\t/*",
            "\t * When a kthread stops operating on an address space, the loop",
            "\t * in membarrier_{private,global}_expedited() may not observe",
            "\t * that tsk->mm, and not issue an IPI. Membarrier requires a",
            "\t * memory barrier after accessing user-space memory, before",
            "\t * clearing tsk->mm.",
            "\t */",
            "\tsmp_mb__after_spinlock();",
            "\tsync_mm_rss(mm);",
            "\tlocal_irq_disable();",
            "\ttsk->mm = NULL;",
            "\tmembarrier_update_current_mm(NULL);",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(tsk, NULL);",
            "\t#endif",
            "\tmmgrab_lazy_tlb(mm);",
            "\t/* active_mm is still 'mm' */",
            "\tenter_lazy_tlb(mm, tsk);",
            "\tlocal_irq_enable();",
            "\ttask_unlock(tsk);",
            "",
            "\tmmdrop(mm);",
            "}",
            "void kthread_associate_blkcg(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct kthread *kthread;",
            "",
            "\tif (!(current->flags & PF_KTHREAD))",
            "\t\treturn;",
            "\tkthread = to_kthread(current);",
            "\tif (!kthread)",
            "\t\treturn;",
            "",
            "\tif (kthread->blkcg_css) {",
            "\t\tcss_put(kthread->blkcg_css);",
            "\t\tkthread->blkcg_css = NULL;",
            "\t}",
            "\tif (css) {",
            "\t\tcss_get(css);",
            "\t\tkthread->blkcg_css = css;",
            "\t}",
            "}"
          ],
          "function_name": "kthread_unuse_mm, kthread_associate_blkcg",
          "description": "管理kthread的地址空间切换，包含内存屏障同步、TLB更新及块控制组绑定操作，确保上下文切换安全性",
          "similarity": 0.4726579785346985
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_events_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:18:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_events_filter.c`\n\n---\n\n# trace_events_filter.c 技术文档\n\n## 1. 文件概述\n\n`trace_events_filter.c` 是 Linux 内核中用于实现通用事件过滤（event filtering）功能的核心文件。它为 ftrace 事件跟踪系统提供了一套灵活的表达式解析和执行机制，允许用户通过逻辑表达式（支持 `&&`、`||`、`!` 等操作符）对跟踪事件进行动态过滤。该模块支持对事件字段进行数值比较、字符串匹配、位运算以及 CPU 掩码过滤等多种操作，广泛应用于性能分析、调试和系统监控场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct filter_pred`**  \n  表示一个过滤谓词（predicate），包含：\n  - 字段指针（`field`）\n  - 比较值（`val`, `val2`）\n  - 操作符（`op`，如 `==`, `<`, `&` 等）\n  - 谓词执行函数类型（`fn_num`）\n  - 正则表达式（`regex`）或 CPU 掩码（`mask`）\n  - 取反标志（`not`）\n\n- **`struct prog_entry`**  \n  表示过滤程序中的一个指令条目，用于构建基于跳转的执行逻辑：\n  - `pred`：关联的谓词\n  - `when_to_branch`：分支条件（0 或 1）\n  - `target`：跳转目标索引\n\n- **`struct filter_parse_error`**  \n  用于记录表达式解析过程中的错误类型和位置。\n\n- **`enum filter_op_ids` 和 `enum filter_pred_fn`**  \n  定义支持的操作符（如 `OP_EQ`, `OP_GT`）和谓词执行函数类型（如 `FILTER_PRED_FN_U64`, `FILTER_PRED_FN_STRING`）。\n\n- **错误码枚举（`FILT_ERR_*`）**  \n  定义了 20 余种解析和语义错误，如 `FIELD_NOT_FOUND`、`INVALID_OP`、`MISSING_QUOTE` 等。\n\n### 关键函数/逻辑\n\n- **`is_not()`**  \n  判断 `!` 是否表示逻辑取反（排除 `!=` 和 `!~` 的情况）。\n\n- **`update_preds()`**  \n  在构建过滤程序时动态更新跳转目标，用于处理 `&&` 和 `||` 的优先级和短路求值。\n\n- **`free_predicate()`**  \n  释放谓词结构及其关联资源（正则、CPU 掩码等）。\n\n- **表达式解析器框架**  \n  支持回调函数 `parse_pred_fn`，允许不同事件类型自定义谓词解析逻辑。\n\n## 3. 关键实现\n\n### 表达式解析与程序生成\n\n该文件实现了一个两阶段的逻辑表达式处理机制：\n\n1. **词法与语法解析**：将用户输入的字符串（如 `\"pid > 100 && comm == 'bash'\"`）解析为操作符、字段名和值的序列。\n2. **程序生成**：将逻辑表达式转换为线性“程序”（`prog_entry` 数组），通过条件跳转模拟 `&&`（短路与）和 `||`（短路或）的语义。\n\n例如，表达式 `a && !b || c` 被编译为类似以下的跳转逻辑：\n```text\neval a; if false goto L2\neval b; if true  goto L2\nreturn true\nL2: eval c; if false goto FAIL\nreturn true\nFAIL: return false\n```\n\n### 操作符优先级处理\n\n通过宏 `OPS` 定义操作符顺序，特别要求 `<=` 在 `<` 之前、`>=` 在 `>` 之前，以确保词法分析时长操作符优先匹配。\n\n### 取反逻辑（`!`）处理\n\n使用栈和 `invert` 标志跟踪当前作用域内的取反层数。每遇到一个 `!` 就翻转 `invert`，括号会将当前 `invert` 值压栈，确保作用域隔离。\n\n### 多类型谓词支持\n\n通过 `filter_pred_fn` 枚举区分不同数据类型的比较函数（如 8/16/32/64 位有无符号整数、字符串、CPU 掩码、函数指针等），实现类型安全的字段比较。\n\n### 错误报告机制\n\n提供详细的错误码和位置信息（`filter_parse_error`），便于用户调试无效过滤表达式。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `trace.h` / `trace_output.h`：ftrace 核心接口和事件定义\n  - `linux/slab.h`：内存分配（`kmalloc`/`kfree`）\n  - `linux/ctype.h`：字符处理\n  - `linux/perf_event.h`：与 perf 事件子系统集成\n  - `linux/uaccess.h`：用户空间数据访问\n\n- **模块依赖**：\n  - 依赖 ftrace 事件注册机制（`ftrace_event_field`）\n  - 与 `trace_events.c` 协同工作，提供过滤能力\n  - 被 perf 和 ftrace 用户接口（如 `/sys/kernel/debug/tracing/events/.../filter`）调用\n\n## 5. 使用场景\n\n- **动态事件过滤**：用户通过写入 `/sys/kernel/debug/tracing/events/<subsys>/<event>/filter` 设置过滤条件，仅记录满足条件的事件。\n- **全局过滤**：通过 `set_event_filter` 设置跨多个事件的统一过滤规则。\n- **性能分析**：在高负载系统中减少无关事件的记录开销，提升跟踪效率。\n- **调试特定行为**：例如 `filter='pid == 1234'` 仅跟踪指定进程的事件，或 `filter='latency > 1000'` 捕获高延迟操作。\n- **安全与审计**：结合字段值过滤实现细粒度的系统行为监控。",
      "similarity": 0.5240676999092102,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2400,
          "end_line": 2508,
          "content": [
            "int apply_subsystem_event_filter(struct trace_subsystem_dir *dir,",
            "\t\t\t\t char *filter_string)",
            "{",
            "\tstruct event_subsystem *system = dir->subsystem;",
            "\tstruct trace_array *tr = dir->tr;",
            "\tstruct event_filter *filter = NULL;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&event_mutex);",
            "",
            "\t/* Make sure the system still has events */",
            "\tif (!dir->nr_events) {",
            "\t\terr = -ENODEV;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (!strcmp(strstrip(filter_string), \"0\")) {",
            "\t\tfilter_free_subsystem_preds(dir, tr);",
            "\t\tremove_filter_string(system->filter);",
            "\t\tfilter = system->filter;",
            "\t\tsystem->filter = NULL;",
            "\t\t/* Ensure all filters are no longer used */",
            "\t\ttracepoint_synchronize_unregister();",
            "\t\tfilter_free_subsystem_filters(dir, tr);",
            "\t\t__free_filter(filter);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\terr = create_system_filter(dir, filter_string, &filter);",
            "\tif (filter) {",
            "\t\t/*",
            "\t\t * No event actually uses the system filter",
            "\t\t * we can free it without synchronize_rcu().",
            "\t\t */",
            "\t\t__free_filter(system->filter);",
            "\t\tsystem->filter = filter;",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn err;",
            "}",
            "void ftrace_profile_free_filter(struct perf_event *event)",
            "{",
            "\tstruct event_filter *filter = event->filter;",
            "",
            "\tevent->filter = NULL;",
            "\t__free_filter(filter);",
            "}",
            "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,",
            "\t\t\t\t      int reset, char *re, int len)",
            "{",
            "\tint ret;",
            "",
            "\tif (filter)",
            "\t\tret = ftrace_set_filter(ops, re, len, reset);",
            "\telse",
            "\t\tret = ftrace_set_notrace(ops, re, len, reset);",
            "",
            "\treturn ret;",
            "}",
            "static int __ftrace_function_set_filter(int filter, char *buf, int len,",
            "\t\t\t\t\tstruct function_filter_data *data)",
            "{",
            "\tint i, re_cnt, ret = -EINVAL;",
            "\tint *reset;",
            "\tchar **re;",
            "",
            "\treset = filter ? &data->first_filter : &data->first_notrace;",
            "",
            "\t/*",
            "\t * The 'ip' field could have multiple filters set, separated",
            "\t * either by space or comma. We first cut the filter and apply",
            "\t * all pieces separately.",
            "\t */",
            "\tre = ftrace_function_filter_re(buf, len, &re_cnt);",
            "\tif (!re)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < re_cnt; i++) {",
            "\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,",
            "\t\t\t\t\t\t re[i], strlen(re[i]));",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "",
            "\t\tif (*reset)",
            "\t\t\t*reset = 0;",
            "\t}",
            "",
            "\targv_free(re);",
            "\treturn ret;",
            "}",
            "static int ftrace_function_check_pred(struct filter_pred *pred)",
            "{",
            "\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\t/*",
            "\t * Check the predicate for function trace, verify:",
            "\t *  - only '==' and '!=' is used",
            "\t *  - the 'ip' field is used",
            "\t */",
            "\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (strcmp(field->name, \"ip\"))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "apply_subsystem_event_filter, ftrace_profile_free_filter, ftrace_function_set_regexp, __ftrace_function_set_filter, ftrace_function_check_pred",
          "description": "apply_subsystem_event_filter 根据过滤字符串设置子系统级事件过滤器，处理过滤器创建、释放及错误返回；ftrace_profile_free_filter 释放perf_event的过滤器指针；__ftrace_function_set_filter 将过滤字符串分割后依次应用正则表达式到函数跟踪操作；ftrace_function_check_pred 验证谓词操作类型和字段是否符合函数跟踪要求",
          "similarity": 0.4671926498413086
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2543,
          "end_line": 2647,
          "content": [
            "static int ftrace_function_set_filter_pred(struct filter_pred *pred,",
            "\t\t\t\t\t   struct function_filter_data *data)",
            "{",
            "\tint ret;",
            "",
            "\t/* Checking the node is valid for function trace. */",
            "\tret = ftrace_function_check_pred(pred);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn __ftrace_function_set_filter(pred->op == OP_EQ,",
            "\t\t\t\t\t    pred->regex->pattern,",
            "\t\t\t\t\t    pred->regex->len,",
            "\t\t\t\t\t    data);",
            "}",
            "static bool is_or(struct prog_entry *prog, int i)",
            "{",
            "\tint target;",
            "",
            "\t/*",
            "\t * Only \"||\" is allowed for function events, thus,",
            "\t * all true branches should jump to true, and any",
            "\t * false branch should jump to false.",
            "\t */",
            "\ttarget = prog[i].target + 1;",
            "\t/* True and false have NULL preds (all prog entries should jump to one */",
            "\tif (prog[target].pred)",
            "\t\treturn false;",
            "",
            "\t/* prog[target].target is 1 for TRUE, 0 for FALSE */",
            "\treturn prog[i].when_to_branch == prog[target].target;",
            "}",
            "static int ftrace_function_set_filter(struct perf_event *event,",
            "\t\t\t\t      struct event_filter *filter)",
            "{",
            "\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,",
            "\t\t\t\t\t\tlockdep_is_held(&event_mutex));",
            "\tstruct function_filter_data data = {",
            "\t\t.first_filter  = 1,",
            "\t\t.first_notrace = 1,",
            "\t\t.ops           = &event->ftrace_ops,",
            "\t};",
            "\tint i;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "",
            "\t\tif (!is_or(prog, i))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int ftrace_function_set_filter(struct perf_event *event,",
            "\t\t\t\t      struct event_filter *filter)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "int ftrace_profile_set_filter(struct perf_event *event, int event_id,",
            "\t\t\t      char *filter_str)",
            "{",
            "\tint err;",
            "\tstruct event_filter *filter = NULL;",
            "\tstruct trace_event_call *call;",
            "",
            "\tmutex_lock(&event_mutex);",
            "",
            "\tcall = event->tp_event;",
            "",
            "\terr = -EINVAL;",
            "\tif (!call)",
            "\t\tgoto out_unlock;",
            "",
            "\terr = -EEXIST;",
            "\tif (event->filter)",
            "\t\tgoto out_unlock;",
            "",
            "\terr = create_filter(NULL, call, filter_str, false, &filter);",
            "\tif (err)",
            "\t\tgoto free_filter;",
            "",
            "\tif (ftrace_event_is_function(call))",
            "\t\terr = ftrace_function_set_filter(event, filter);",
            "\telse",
            "\t\tevent->filter = filter;",
            "",
            "free_filter:",
            "\tif (err || ftrace_event_is_function(call))",
            "\t\t__free_filter(filter);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn err;",
            "}",
            "static int test_pred_visited_fn(struct filter_pred *pred, void *event)",
            "{",
            "\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\ttest_pred_visited = 1;",
            "\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);",
            "\treturn 1;",
            "}"
          ],
          "function_name": "ftrace_function_set_filter_pred, is_or, ftrace_function_set_filter, ftrace_function_set_filter, ftrace_profile_set_filter, test_pred_visited_fn",
          "description": "ftrace_function_set_filter_pred 将谓词转换为正则表达式并调用底层设置函数；is_or 检查程序流图中节点是否为OR逻辑分支；ftrace_function_set_filter 遍历过滤器谓词链表，校验逻辑结构后应用到函数跟踪；ftrace_profile_set_filter 创建事件过滤器并根据事件类型选择设置方式；test_pred_visited_fn 标记谓词访问状态用于测试",
          "similarity": 0.4626535177230835
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 1161,
          "end_line": 1262,
          "content": [
            "static int test_pred_visited_fn(struct filter_pred *pred, void *event)",
            "{",
            "\treturn 0;",
            "}",
            "int filter_match_preds(struct event_filter *filter, void *rec)",
            "{",
            "\tstruct prog_entry *prog;",
            "\tint i;",
            "",
            "\t/* no filter is considered a match */",
            "\tif (!filter)",
            "\t\treturn 1;",
            "",
            "\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */",
            "\tprog = rcu_dereference_raw(filter->prog);",
            "\tif (!prog)",
            "\t\treturn 1;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "\t\tint match = filter_pred_fn_call(pred, rec);",
            "\t\tif (match == prog[i].when_to_branch)",
            "\t\t\ti = prog[i].target;",
            "\t}",
            "\treturn prog[i].target;",
            "}",
            "static void remove_filter_string(struct event_filter *filter)",
            "{",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tkfree(filter->filter_string);",
            "\tfilter->filter_string = NULL;",
            "}",
            "static void append_filter_err(struct trace_array *tr,",
            "\t\t\t      struct filter_parse_error *pe,",
            "\t\t\t      struct event_filter *filter)",
            "{",
            "\tstruct trace_seq *s;",
            "\tint pos = pe->lasterr_pos;",
            "\tchar *buf;",
            "\tint len;",
            "",
            "\tif (WARN_ON(!filter->filter_string))",
            "\t\treturn;",
            "",
            "\ts = kmalloc(sizeof(*s), GFP_KERNEL);",
            "\tif (!s)",
            "\t\treturn;",
            "\ttrace_seq_init(s);",
            "",
            "\tlen = strlen(filter->filter_string);",
            "\tif (pos > len)",
            "\t\tpos = len;",
            "",
            "\t/* indexing is off by one */",
            "\tif (pos)",
            "\t\tpos++;",
            "",
            "\ttrace_seq_puts(s, filter->filter_string);",
            "\tif (pe->lasterr > 0) {",
            "\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");",
            "\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);",
            "\t\ttracing_log_err(tr, \"event filter parse error\",",
            "\t\t\t\tfilter->filter_string, err_text,",
            "\t\t\t\tpe->lasterr, pe->lasterr_pos);",
            "\t} else {",
            "\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);",
            "\t\ttracing_log_err(tr, \"event filter parse error\",",
            "\t\t\t\tfilter->filter_string, err_text,",
            "\t\t\t\tFILT_ERR_ERRNO, 0);",
            "\t}",
            "\ttrace_seq_putc(s, 0);",
            "\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);",
            "\tif (buf) {",
            "\t\tkfree(filter->filter_string);",
            "\t\tfilter->filter_string = buf;",
            "\t}",
            "\tkfree(s);",
            "}",
            "void print_event_filter(struct trace_event_file *file, struct trace_seq *s)",
            "{",
            "\tstruct event_filter *filter = event_filter(file);",
            "",
            "\tif (filter && filter->filter_string)",
            "\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);",
            "\telse",
            "\t\ttrace_seq_puts(s, \"none\\n\");",
            "}",
            "void print_subsystem_event_filter(struct event_subsystem *system,",
            "\t\t\t\t  struct trace_seq *s)",
            "{",
            "\tstruct event_filter *filter;",
            "",
            "\tmutex_lock(&event_mutex);",
            "\tfilter = system->filter;",
            "\tif (filter && filter->filter_string)",
            "\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);",
            "\telse",
            "\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");",
            "\tmutex_unlock(&event_mutex);",
            "}"
          ],
          "function_name": "test_pred_visited_fn, filter_match_preds, remove_filter_string, append_filter_err, print_event_filter, print_subsystem_event_filter",
          "description": "实现过滤器状态管理、错误附加、谓词匹配执行以及过滤器信息打印等功能的核心控制流程。",
          "similarity": 0.4564504027366638
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 862,
          "end_line": 968,
          "content": [
            "static int filter_pred_pchar(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_string(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_pchar_user(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_ustring(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_strloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 str_item = *(u32 *)(event + pred->offset);",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(event + str_loc);",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_strrelloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 *item = (u32 *)(event + pred->offset);",
            "\tu32 str_item = *item;",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(&item[1]) + str_loc;",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu, cmp;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\tcmp = pred->val;",
            "",
            "\tswitch (pred->op) {",
            "\tcase OP_EQ:",
            "\t\treturn cpu == cmp;",
            "\tcase OP_NE:",
            "\t\treturn cpu != cmp;",
            "\tcase OP_LT:",
            "\t\treturn cpu < cmp;",
            "\tcase OP_LE:",
            "\t\treturn cpu <= cmp;",
            "\tcase OP_GT:",
            "\t\treturn cpu > cmp;",
            "\tcase OP_GE:",
            "\t\treturn cpu >= cmp;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static int filter_pred_cpu_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu = raw_smp_processor_id();",
            "",
            "\treturn do_filter_scalar_cpumask(pred->op, cpu, pred->mask);",
            "}",
            "static int filter_pred_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tconst struct cpumask *cmp = pred->mask;",
            "",
            "\treturn do_filter_cpumask(pred->op, mask, cmp);",
            "}",
            "static int filter_pred_cpumask_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tunsigned int cpu = pred->val;",
            "",
            "\treturn do_filter_cpumask_scalar(pred->op, mask, cpu);",
            "}",
            "static int filter_pred_comm(struct filter_pred *pred, void *event)",
            "{",
            "\tint cmp;",
            "",
            "\tcmp = pred->regex->match(current->comm, pred->regex,",
            "\t\t\t\tTASK_COMM_LEN);",
            "\treturn cmp ^ pred->not;",
            "}"
          ],
          "function_name": "filter_pred_pchar, filter_pred_pchar_user, filter_pred_strloc, filter_pred_strrelloc, filter_pred_cpu, filter_pred_cpu_cpumask, filter_pred_cpumask, filter_pred_cpumask_cpu, filter_pred_comm",
          "description": "提供针对字符串、位置、进程名等特殊数据类型的过滤实现，处理指针解引用和内存地址匹配。",
          "similarity": 0.45616352558135986
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2741,
          "end_line": 2822,
          "content": [
            "static void update_pred_fn(struct event_filter *filter, char *fields)",
            "{",
            "\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,",
            "\t\t\t\t\t\tlockdep_is_held(&event_mutex));",
            "\tint i;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "\t\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\t\tWARN_ON_ONCE(pred->fn_num == FILTER_PRED_FN_NOP);",
            "",
            "\t\tif (!field) {",
            "\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!strchr(fields, *field->name))",
            "\t\t\tcontinue;",
            "",
            "\t\tpred->fn_num = FILTER_PRED_TEST_VISITED;",
            "\t}",
            "}",
            "static __init int ftrace_test_event_filter(void)",
            "{",
            "\tint i;",
            "",
            "\tprintk(KERN_INFO \"Testing ftrace filter: \");",
            "",
            "\tfor (i = 0; i < DATA_CNT; i++) {",
            "\t\tstruct event_filter *filter = NULL;",
            "\t\tstruct test_filter_data_t *d = &test_filter_data[i];",
            "\t\tint err;",
            "",
            "\t\terr = create_filter(NULL, &event_ftrace_test_filter,",
            "\t\t\t\t    d->filter, false, &filter);",
            "\t\tif (err) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed to get filter for '%s', err %d\\n\",",
            "\t\t\t       d->filter, err);",
            "\t\t\t__free_filter(filter);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Needed to dereference filter->prog */",
            "\t\tmutex_lock(&event_mutex);",
            "\t\t/*",
            "\t\t * The preemption disabling is not really needed for self",
            "\t\t * tests, but the rcu dereference will complain without it.",
            "\t\t */",
            "\t\tpreempt_disable();",
            "\t\tif (*d->not_visited)",
            "\t\t\tupdate_pred_fn(filter, d->not_visited);",
            "",
            "\t\ttest_pred_visited = 0;",
            "\t\terr = filter_match_preds(filter, &d->rec);",
            "\t\tpreempt_enable();",
            "",
            "\t\tmutex_unlock(&event_mutex);",
            "",
            "\t\t__free_filter(filter);",
            "",
            "\t\tif (test_pred_visited) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",",
            "\t\t\t       d->filter);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (err != d->match) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed to match filter '%s', expected %d\\n\",",
            "\t\t\t       d->filter, d->match);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (i == DATA_CNT)",
            "\t\tprintk(KERN_CONT \"OK\\n\");",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "update_pred_fn, ftrace_test_event_filter",
          "description": "update_pred_fn 更新谓词节点的函数号标记已访问字段；ftrace_test_event_filter 自动测试过滤器匹配逻辑，通过创建过滤器、遍历谓词节点并验证匹配结果判断测试是否通过",
          "similarity": 0.45167481899261475
        }
      ]
    },
    {
      "source_file": "kernel/trace/pid_list.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:04:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\pid_list.c`\n\n---\n\n# `trace/pid_list.c` 技术文档\n\n## 1. 文件概述\n\n`trace/pid_list.c` 实现了一个高效、可扩展的 PID（进程标识符）集合管理机制，用于 Linux 内核跟踪子系统（ftrace）中对特定进程的过滤控制。该文件通过三级位图结构（upper1 → upper2 → lower）将 PID 空间分层组织，支持快速的 PID 设置、清除、查询及遍历操作，同时兼顾内存使用效率和并发安全性。该实现特别适用于需要动态跟踪大量进程但又不能占用过多连续内存的场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trace_pid_list_is_set()`：检查指定 PID 是否在列表中（用于调度时快速判断是否应跟踪该任务）。\n- `trace_pid_list_set()`：将指定 PID 加入跟踪列表。\n- `trace_pid_list_clear()`：从跟踪列表中移除指定 PID，并在对应位图块为空时自动释放内存。\n- `trace_pid_list_next()`：从给定 PID 开始查找下一个存在于列表中的 PID（用于遍历所有被跟踪的 PID）。\n\n### 辅助内联函数\n\n- `get_lower_chunk()` / `put_lower_chunk()`：从空闲链表中分配或归还底层位图块（`lower_chunk`）。\n- `get_upper_chunk()` / `put_upper_chunk()`：从空闲链表中分配或归还上层索引块（`upper_chunk`）。\n- `upper_empty()`：判断一个 `upper_chunk` 是否完全为空（所有 `lower_chunk` 均为 NULL）。\n- `pid_split()` / `pid_join()`：将 PID 拆分为三级索引（upper1, upper2, lower）或将三级索引合并为 PID。\n\n### 关键数据结构（定义于 `pid_list.h`）\n\n- `struct trace_pid_list`：PID 列表的主结构体，包含：\n  - 两级指针数组：`upper[UPPER_MAX]` 指向 `upper_chunk`。\n  - 空闲块链表：`lower_list` 和 `upper_list` 用于缓存未使用的块。\n  - 计数器：`free_lower_chunks` 和 `free_upper_chunks`。\n  - 自旋锁：`lock` 保证并发安全。\n  - 中断工作队列：`refill_irqwork` 用于异步补充空闲块。\n- `union upper_chunk`：包含一个指针数组 `data[UPPER_MAX]`，每个元素指向一个 `lower_chunk`。\n- `union lower_chunk`：包含一个位图数组 `data[LOWER_SIZE]`，用于存储 `LOWER_MAX` 个 PID 的存在状态。\n\n## 3. 关键实现\n\n### 三级分层位图结构\n- **设计目的**：避免为整个 PID 空间（最大 `PID_MAX_LIMIT`，通常为 4194304）分配连续大内存。\n- **层级划分**：\n  - **Upper1**：最高位，索引 `trace_pid_list->upper[]` 数组（大小 `UPPER_MAX`）。\n  - **Upper2**：中间位，索引 `upper_chunk->data[]` 数组（大小 `UPPER_MAX`）。\n  - **Lower**：最低位，索引 `lower_chunk->data` 位图中的具体位（范围 `0` 到 `LOWER_MAX-1`）。\n- **内存效率**：仅当某 PID 范围被使用时才动态分配对应的 `upper_chunk` 和 `lower_chunk`。\n\n### 并发与内存管理\n- **自旋锁保护**：所有操作均在 `pid_list->lock` 保护下进行，使用 `raw_spin_lock_irqsave()` 禁用本地中断以确保在硬中断上下文（如调度器）中的安全性。\n- **空闲块缓存**：通过 `lower_list` 和 `upper_list` 链表缓存已释放的块，避免频繁的内存分配/释放。\n- **异步补充机制**：当空闲块数量低于阈值 `CHUNK_REALLOC` 时，通过 `irq_work_queue()` 触发中断上下文工作（`refill_irqwork`）来补充空闲块，避免在持有调度器锁时执行耗时的内存分配。\n\n### 动态释放\n- 在 `trace_pid_list_clear()` 中，清除位后检查 `lower_chunk` 是否全零：\n  - 若是，则将其归还到 `lower_list` 并置空 `upper_chunk->data[upper2]`。\n  - 进一步检查 `upper_chunk` 是否完全为空（所有 `data[]` 为 NULL），若是则归还到 `upper_list` 并置空 `pid_list->upper[upper1]`。\n\n### PID 遍历算法\n- `trace_pid_list_next()` 从给定 PID 的拆分索引开始，按 `upper1 → upper2 → lower` 顺序遍历：\n  - 外层循环遍历 `upper1`（从起始值到 `UPPER_MASK`）。\n  - 内层循环遍历 `upper2`（从起始值或 0 到 `UPPER_MASK`）。\n  - 在有效的 `lower_chunk` 中使用 `find_next_bit()` 查找下一个置位的 PID。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/spinlock.h>`：提供自旋锁原语。\n  - `<linux/irq_work.h>`：提供中断上下文工作队列机制。\n  - `<linux/slab.h>`：提供内存分配接口（由 `pid_list.h` 或其他文件间接使用）。\n  - `\"trace.h\"`：包含跟踪子系统通用定义及 `pid_list.h`。\n- **数据结构依赖**：依赖 `pid_list.h` 中定义的 `struct trace_pid_list`、`union upper_chunk`、`union lower_chunk` 及相关常量（如 `UPPER_MASK`、`LOWER_MASK`、`CHUNK_REALLOC` 等）。\n- **内核子系统**：作为 ftrace 跟踪过滤机制的核心组件，被调度器（`kernel/sched/`）和 tracefs 接口（`kernel/trace/`）调用。\n\n## 5. 使用场景\n\n- **动态进程跟踪**：用户通过 tracefs 接口（如 `set_ftrace_pid`）指定要跟踪的进程 PID，内核调用 `trace_pid_list_set()` 将其加入列表。\n- **调度器过滤**：在任务切换时（`__schedule()`），调度器调用 `trace_pid_list_is_set()` 快速判断当前任务是否应被跟踪，决定是否触发跟踪事件。\n- **进程生命周期管理**：\n  - **Fork**：若父进程在跟踪列表中且配置了跟踪子进程，则新进程 PID 通过 `trace_pid_list_set()` 加入列表。\n  - **Exit**：任务退出时，若其 PID 在列表中，则通过 `trace_pid_list_clear()` 移除。\n- **PID 列表遍历**：调试工具或内核接口需要枚举所有被跟踪的 PID 时，调用 `trace_pid_list_next()` 进行迭代。\n- **内存压力处理**：在高并发设置/清除 PID 时，通过异步 `irq_work` 补充空闲块，避免在关键路径（如调度器）中阻塞。",
      "similarity": 0.511067807674408,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2021 VMware Inc, Steven Rostedt <rostedt@goodmis.org>",
            " */",
            "#include <linux/spinlock.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include \"trace.h\"",
            "",
            "/* See pid_list.h for details */",
            "",
            "static inline union lower_chunk *get_lower_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion lower_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->lower_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->lower_list;",
            "\tpid_list->lower_list = chunk->next;",
            "\tpid_list->free_lower_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_lower_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_lower_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            "",
            "static inline union upper_chunk *get_upper_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->upper_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->upper_list;",
            "\tpid_list->upper_list = chunk->next;",
            "\tpid_list->free_upper_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_upper_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_upper_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现从trace_pid_list结构中获取下层和上层块的函数，通过原子操作减少空闲块计数并可能触发异步补充分配，用于动态管理PID跟踪的内存块。",
          "similarity": 0.44885993003845215
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 457,
          "end_line": 495,
          "content": [
            "void trace_pid_list_free(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *upper;",
            "\tunion lower_chunk *lower;",
            "\tint i, j;",
            "",
            "\tif (!pid_list)",
            "\t\treturn;",
            "",
            "\tirq_work_sync(&pid_list->refill_irqwork);",
            "",
            "\twhile (pid_list->lower_list) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->lower_list;",
            "\t\tpid_list->lower_list = pid_list->lower_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\twhile (pid_list->upper_list) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->upper_list;",
            "\t\tpid_list->upper_list = pid_list->upper_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\tfor (i = 0; i < UPPER1_SIZE; i++) {",
            "\t\tupper = pid_list->upper[i];",
            "\t\tif (upper) {",
            "\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {",
            "\t\t\t\tlower = upper->data[j];",
            "\t\t\t\tkfree(lower);",
            "\t\t\t}",
            "\t\t\tkfree(upper);",
            "\t\t}",
            "\t}",
            "\tkfree(pid_list);",
            "}"
          ],
          "function_name": "trace_pid_list_free",
          "description": "释放trace_pid_list及其关联的所有内存资源，递归回收上层块和下层块链表，彻底清理PID跟踪结构体占用的内存量。",
          "similarity": 0.4364044666290283
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 221,
          "end_line": 377,
          "content": [
            "int trace_pid_list_clear(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (!upper_chunk)",
            "\t\tgoto out;",
            "",
            "\tlower_chunk = upper_chunk->data[upper2];",
            "\tif (!lower_chunk)",
            "\t\tgoto out;",
            "",
            "\tclear_bit(lower, lower_chunk->data);",
            "",
            "\t/* if there's no more bits set, add it to the free list */",
            "\tif (find_first_bit(lower_chunk->data, LOWER_MAX) >= LOWER_MAX) {",
            "\t\tput_lower_chunk(pid_list, lower_chunk);",
            "\t\tupper_chunk->data[upper2] = NULL;",
            "\t\tif (upper_empty(upper_chunk)) {",
            "\t\t\tput_upper_chunk(pid_list, upper_chunk);",
            "\t\t\tpid_list->upper[upper1] = NULL;",
            "\t\t}",
            "\t}",
            " out:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_next(struct trace_pid_list *pid_list, unsigned int pid,",
            "\t\t\tunsigned int *next)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tfor (; upper1 <= UPPER_MASK; upper1++, upper2 = 0) {",
            "\t\tupper_chunk = pid_list->upper[upper1];",
            "",
            "\t\tif (!upper_chunk)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (; upper2 <= UPPER_MASK; upper2++, lower = 0) {",
            "\t\t\tlower_chunk = upper_chunk->data[upper2];",
            "\t\t\tif (!lower_chunk)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tlower = find_next_bit(lower_chunk->data, LOWER_MAX,",
            "\t\t\t\t\t    lower);",
            "\t\t\tif (lower < LOWER_MAX)",
            "\t\t\t\tgoto found;",
            "\t\t}",
            "\t}",
            "",
            " found:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\tif (upper1 > UPPER_MASK)",
            "\t\treturn -1;",
            "",
            "\t*next = pid_join(upper1, upper2, lower);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_first(struct trace_pid_list *pid_list, unsigned int *pid)",
            "{",
            "\treturn trace_pid_list_next(pid_list, 0, pid);",
            "}",
            "static void pid_list_refill_irq(struct irq_work *iwork)",
            "{",
            "\tstruct trace_pid_list *pid_list = container_of(iwork, struct trace_pid_list,",
            "\t\t\t\t\t\t       refill_irqwork);",
            "\tunion upper_chunk *upper = NULL;",
            "\tunion lower_chunk *lower = NULL;",
            "\tunion upper_chunk **upper_next = &upper;",
            "\tunion lower_chunk **lower_next = &lower;",
            "\tint upper_count;",
            "\tint lower_count;",
            "\tint ucnt = 0;",
            "\tint lcnt = 0;",
            "",
            " again:",
            "\traw_spin_lock(&pid_list->lock);",
            "\tupper_count = CHUNK_ALLOC - pid_list->free_upper_chunks;",
            "\tlower_count = CHUNK_ALLOC - pid_list->free_lower_chunks;",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\tif (upper_count <= 0 && lower_count <= 0)",
            "\t\treturn;",
            "",
            "\twhile (upper_count-- > 0) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*upper_next = chunk;",
            "\t\tupper_next = &chunk->next;",
            "\t\tucnt++;",
            "\t}",
            "",
            "\twhile (lower_count-- > 0) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*lower_next = chunk;",
            "\t\tlower_next = &chunk->next;",
            "\t\tlcnt++;",
            "\t}",
            "",
            "\traw_spin_lock(&pid_list->lock);",
            "\tif (upper) {",
            "\t\t*upper_next = pid_list->upper_list;",
            "\t\tpid_list->upper_list = upper;",
            "\t\tpid_list->free_upper_chunks += ucnt;",
            "\t}",
            "\tif (lower) {",
            "\t\t*lower_next = pid_list->lower_list;",
            "\t\tpid_list->lower_list = lower;",
            "\t\tpid_list->free_lower_chunks += lcnt;",
            "\t}",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\t/*",
            "\t * On success of allocating all the chunks, both counters",
            "\t * will be less than zero. If they are not, then an allocation",
            "\t * failed, and we should not try again.",
            "\t */",
            "\tif (upper_count >= 0 || lower_count >= 0)",
            "\t\treturn;",
            "\t/*",
            "\t * When the locks were released, free chunks could have",
            "\t * been used and allocation needs to be done again. Might as",
            "\t * well allocate it now.",
            "\t */",
            "\tgoto again;",
            "}"
          ],
          "function_name": "trace_pid_list_clear, trace_pid_list_next, trace_pid_list_first, pid_list_refill_irq",
          "description": "实现PID集合的遍历与清理功能，包含按序查找下一个PID、首次PID查询及异步内存补充分配逻辑，支持动态扩展存储结构以避免内存耗尽。",
          "similarity": 0.40322378277778625
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 60,
          "end_line": 180,
          "content": [
            "static inline void put_lower_chunk(struct trace_pid_list *pid_list,",
            "\t\t\t\t   union lower_chunk *chunk)",
            "{",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tchunk->next = pid_list->lower_list;",
            "\tpid_list->lower_list = chunk;",
            "\tpid_list->free_lower_chunks++;",
            "}",
            "static inline void put_upper_chunk(struct trace_pid_list *pid_list,",
            "\t\t\t\t   union upper_chunk *chunk)",
            "{",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tchunk->next = pid_list->upper_list;",
            "\tpid_list->upper_list = chunk;",
            "\tpid_list->free_upper_chunks++;",
            "}",
            "static inline bool upper_empty(union upper_chunk *chunk)",
            "{",
            "\t/*",
            "\t * If chunk->data has no lower chunks, it will be the same",
            "\t * as a zeroed bitmask. Use find_first_bit() to test it",
            "\t * and if it doesn't find any bits set, then the array",
            "\t * is empty.",
            "\t */",
            "\tint bit = find_first_bit((unsigned long *)chunk->data,",
            "\t\t\t\t sizeof(chunk->data) * 8);",
            "\treturn bit >= sizeof(chunk->data) * 8;",
            "}",
            "static inline int pid_split(unsigned int pid, unsigned int *upper1,",
            "\t\t\t     unsigned int *upper2, unsigned int *lower)",
            "{",
            "\t/* MAX_PID should cover all pids */",
            "\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);",
            "",
            "\t/* In case a bad pid is passed in, then fail */",
            "\tif (unlikely(pid >= MAX_PID))",
            "\t\treturn -1;",
            "",
            "\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;",
            "\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;",
            "\t*lower = pid & LOWER_MASK;",
            "",
            "\treturn 0;",
            "}",
            "static inline unsigned int pid_join(unsigned int upper1,",
            "\t\t\t\t    unsigned int upper2, unsigned int lower)",
            "{",
            "\treturn ((upper1 & UPPER_MASK) << UPPER1_SHIFT) |",
            "\t\t((upper2 & UPPER_MASK) << UPPER2_SHIFT) |",
            "\t\t(lower & LOWER_MASK);",
            "}",
            "bool trace_pid_list_is_set(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "\tbool ret = false;",
            "",
            "\tif (!pid_list)",
            "\t\treturn false;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn false;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (upper_chunk) {",
            "\t\tlower_chunk = upper_chunk->data[upper2];",
            "\t\tif (lower_chunk)",
            "\t\t\tret = test_bit(lower, lower_chunk->data);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "int trace_pid_list_set(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "\tint ret;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (!upper_chunk) {",
            "\t\tupper_chunk = get_upper_chunk(pid_list);",
            "\t\tif (!upper_chunk) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tpid_list->upper[upper1] = upper_chunk;",
            "\t}",
            "\tlower_chunk = upper_chunk->data[upper2];",
            "\tif (!lower_chunk) {",
            "\t\tlower_chunk = get_lower_chunk(pid_list);",
            "\t\tif (!lower_chunk) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tupper_chunk->data[upper2] = lower_chunk;",
            "\t}",
            "\tset_bit(lower, lower_chunk->data);",
            "\tret = 0;",
            " out:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "put_lower_chunk, put_upper_chunk, upper_empty, pid_split, pid_join, trace_pid_list_is_set, trace_pid_list_set",
          "description": "提供PID存储结构的辅助操作，包括块回收、位掩码操作、PID地址转换及集合状态查询与更新，实现基于多级位图的高效PID追踪。",
          "similarity": 0.3488079309463501
        }
      ]
    }
  ]
}