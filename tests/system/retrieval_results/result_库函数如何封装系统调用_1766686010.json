{
  "query": "库函数如何封装系统调用",
  "timestamp": "2025-12-26 02:06:50",
  "retrieved_files": [
    {
      "source_file": "kernel/rcu/tree_plugin.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:48:59\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\tree_plugin.h`\n\n---\n\n# `rcu/tree_plugin.h` 技术文档\n\n## 1. 文件概述\n\n`rcu/tree_plugin.h` 是 Linux 内核中 **树形 RCU（Read-Copy Update）机制** 的内部头文件，用于实现基于分层树结构的 RCU 互斥机制。该文件定义了适用于 **经典 RCU** 或 **可抢占 RCU（PREEMPT_RCU）** 的内部非公开接口和辅助函数，主要服务于 `kernel/rcu/tree.c` 等核心 RCU 实现模块。其核心目标是在大规模 CPU 系统中高效管理宽限期（Grace Period）的检测与回调处理，同时支持 NOCB（No-CBs，即回调卸载）等高级特性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`rcu_rdp_is_offloaded(struct rcu_data *rdp)`**  \n  安全地判断指定 CPU 的 `rcu_data` 是否启用了 NOCB（回调卸载）模式。该函数包含严格的锁依赖检查（通过 `RCU_LOCKDEP_WARN`），确保在读取 `offloaded` 状态时不会因并发修改导致数据不一致。\n\n- **`rcu_bootup_announce_oddness(void)`**  \n  在内核启动阶段检测并打印所有非默认或调试相关的 RCU 配置参数，用于诊断和性能调优。涵盖内容包括：扇出（fanout）设置、回调水位线、FQS（Force Quiescent State）延迟、软中断处理方式、调试选项等。\n\n- **`rcu_bootup_announce(void)`**（仅 `CONFIG_PREEMPT_RCU`）  \n  启动时声明当前使用的是“可抢占的分层 RCU 实现”，并调用 `rcu_bootup_announce_oddness()` 输出配置异常信息。\n\n- **`rcu_preempt_ctxt_queue(struct rcu_node *rnp, struct rcu_data *rdp)`**（仅 `CONFIG_PREEMPT_RCU`）  \n  将当前被抢占且处于 RCU 读侧临界区的任务插入到 `rcu_node` 的阻塞任务链表（`blkd_tasks`）中的合适位置。其插入策略基于当前是否存在普通或加速宽限期（GP/EXP GP），以及当前 CPU 是否被这些宽限期阻塞，以最小化对已有宽限期的不必要阻塞。\n\n### 关键宏定义（仅 `CONFIG_PREEMPT_RCU`）\n\n- **`RCU_GP_TASKS` / `RCU_EXP_TASKS` / `RCU_GP_BLKD` / `RCU_EXP_BLKD`**  \n  用于构建决策表，表示 `rcu_node` 中普通/加速宽限期的等待状态及当前 CPU 的阻塞状态，指导 `rcu_preempt_ctxt_queue()` 的任务插入逻辑。\n\n## 3. 关键实现\n\n### 安全读取 NOCB 状态\n`rcu_rdp_is_offloaded()` 通过 `RCU_LOCKDEP_WARN` 强制要求调用者必须持有以下任一同步原语：\n- `rcu_state.barrier_mutex`\n- CPU 热插拔锁（读/写）\n- 对应 `rdp` 的 NOCB 锁\n- 在本地 CPU 且不可抢占（非 `CONFIG_PREEMPT_COUNT` 或不可抢占上下文）\n- 当前为 NOCB 内核线程  \n这确保了在读取 `rdp->cblist` 的 `offloaded` 标志时，其值不会被并发修改。\n\n### 可抢占 RCU 的任务阻塞队列策略\n在 `CONFIG_PREEMPT_RCU` 下，当任务在 RCU 读侧临界区内被抢占时，需将其加入 `rcu_node->blkd_tasks` 链表。`rcu_preempt_ctxt_queue()` 使用 **状态决策表**（基于 `blkd_state` 的 4 位组合）决定插入位置：\n- **插入链表头部**：当任务不会阻塞任何**已存在的**宽限期（尤其是加速宽限期）时，避免延长已有宽限期。\n- **插入链表尾部**（代码未完整显示，但逻辑隐含）：当任务会阻塞已有宽限期时，需排在末尾以确保正确性。  \n该策略优先保护**加速宽限期**的低延迟特性，即使可能轻微延长普通宽限期。\n\n### 启动配置诊断\n`rcu_bootup_announce_oddness()` 系统性地检查数十个编译时和运行时 RCU 参数，对任何非默认值或启用的调试功能输出 `pr_info` 日志。这为系统管理员和开发者提供了 RCU 行为的透明视图，便于性能分析和问题排查。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `../locking/rtmutex_common.h`：提供 `lockdep_is_cpus_held()` 等锁依赖检查宏。\n  - `rcu_segcblist_is_offloaded()`：来自 RCU 回调段管理模块，用于查询 NOCB 状态。\n  - `rcu_lockdep_is_held_nocb()`、`rcu_current_is_nocb_kthread()`：NOCB 相关的锁依赖和上下文检查函数。\n  - `rcupdate_announce_bootup_oddness()`：来自 `kernel/rcu/update.c`，用于打印通用 RCU 启动信息。\n\n- **配置依赖**：\n  - `CONFIG_PREEMPT_RCU`：启用可抢占 RCU 的特定逻辑（如任务阻塞队列）。\n  - `CONFIG_RCU_TRACE`、`CONFIG_PROVE_RCU`、`CONFIG_RCU_BOOST` 等：控制启动诊断信息的输出。\n  - `CONFIG_HOTPLUG_CPU`：影响 CPU 热插拔锁的检查逻辑。\n\n- **数据结构依赖**：\n  - `struct rcu_data`、`struct rcu_node`：RCU 核心数据结构，定义在 `kernel/rcu/tree.h`。\n  - `rcu_state`：全局 RCU 状态结构体。\n\n## 5. 使用场景\n\n- **内核启动阶段**：  \n  `rcu_bootup_announce()` 和 `rcu_bootup_announce_oddness()` 在 RCU 初始化时被调用，输出配置诊断信息，帮助确认 RCU 子系统按预期配置。\n\n- **NOCB（回调卸载）模式运行时**：  \n  当系统启用 `CONFIG_RCU_NOCB_CPU` 时，`rcu_rdp_is_offloaded()` 被频繁调用（如在回调处理、宽限期推进路径中），以安全判断当前 CPU 的回调是否由专用内核线程处理。\n\n- **可抢占内核中的任务调度**：  \n  在 `CONFIG_PREEMPT_RCU` 系统中，当任务在 RCU 读侧临界区内被抢占时，调度器路径会调用 `rcu_preempt_ctxt_queue()`，将任务加入阻塞链表，确保宽限期能正确等待该任务退出临界区。\n\n- **调试与性能分析**：  \n  启动时的“oddness”日志为 RCU 调优提供依据；`RCU_LOCKDEP_WARN` 等检查帮助开发者发现 RCU 状态访问的同步错误。",
      "similarity": 0.5660901665687561,
      "chunks": []
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5428175330162048,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.49762964248657227
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.4819110035896301
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.47732505202293396
        }
      ]
    },
    {
      "source_file": "kernel/seccomp.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:23:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `seccomp.c`\n\n---\n\n# seccomp.c 技术文档\n\n## 文件概述\n\n`seccomp.c` 是 Linux 内核中实现安全计算（Secure Computing，简称 seccomp）机制的核心文件。该机制用于限制进程可执行的系统调用，从而提升系统安全性。文件支持两种主要模式：\n\n- **Mode 1（严格模式）**：仅允许 `read`、`write`、`exit` 和 `sigreturn` 四个系统调用。\n- **Mode 2（过滤器模式）**：允许用户通过 Berkeley Packet Filter（BPF）形式定义自定义的系统调用过滤规则。\n\n此外，该文件还实现了 **用户空间通知（user-space notification）** 功能，允许内核在遇到特定系统调用时暂停执行并通知用户态监听器进行处理。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct seccomp_filter`**  \n  表示一个 seccomp BPF 过滤器实例，包含：\n  - 引用计数（`refs` 和 `users`）\n  - BPF 程序指针（`prog`）\n  - 通知相关结构（`notif`、`notify_lock`、`wqh`）\n  - 动作缓存（`cache`）\n  - 指向前一个过滤器的指针（`prev`），构成过滤器链\n\n- **`struct notification`**  \n  管理用户空间通知的容器，包含请求计数器、标志位、下一个通知 ID 和通知链表。\n\n- **`struct seccomp_knotif`**  \n  表示一个待处理的用户通知请求，记录触发通知的任务、系统调用数据、状态（INIT/SENT/REPLIED）、返回值及完成信号量。\n\n- **`struct seccomp_kaddfd`**  \n  用于 `SECCOMP_IOCTL_NOTIF_ADDFD` 操作，允许监听器向目标进程注入文件描述符。\n\n- **`struct action_cache`**（条件编译）  \n  针对原生和兼容架构的系统调用动作缓存，用于快速判断是否允许某系统调用，避免重复执行 BPF 程序。\n\n### 关键枚举与常量\n\n- **`enum notify_state`**：通知状态机（INIT → SENT → REPLIED）\n- **`SECCOMP_MODE_DEAD`**：内部使用的特殊模式，表示进程已进入不可恢复的 seccomp 状态\n- **`MAX_INSNS_PER_PATH`**：限制 BPF 指令路径总长度不超过 256KB，防止资源耗尽\n\n### 特殊兼容性处理\n\n- **`SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR`**：为兼容早期错误的 ioctl 命令方向而保留的旧定义\n\n## 关键实现\n\n### 过滤器生命周期管理\n\n- 使用双重引用计数机制：\n  - `refs`：控制对象内存释放（包括任务引用、依赖过滤器、通知监听器）\n  - `users`：跟踪直接或间接使用该过滤器的任务数量，用于判断是否还能被新任务继承\n- 过滤器一旦附加到任务，除引用计数外不可修改，确保并发安全\n\n### 用户空间通知机制\n\n- 当 BPF 程序返回 `SECCOMP_RET_USER_NOTIF` 时，内核创建 `seccomp_knotif` 并加入通知队列\n- 用户态通过文件描述符读取通知，内核将状态置为 `SENT`\n- 监听器通过 `ioctl` 回复结果，状态转为 `REPLIED`，触发 `completion` 使原任务继续执行\n- 支持通过 `SECCOMP_IOCTL_NOTIF_ADDFD` 向目标进程注入文件描述符\n\n### 动作缓存优化（`action_cache`）\n\n- 在支持 `SECCOMP_ARCH_NATIVE` 的架构上，为每个系统调用编号维护一个“始终允许”位图\n- 若缓存命中（即该系统调用在所有路径下均返回 `ALLOW`），可跳过 BPF 执行，提升性能\n- 分别处理原生（native）和兼容（compat）系统调用空间\n\n### 安全与资源限制\n\n- 限制 BPF 指令总路径长度，防止深度嵌套或循环导致 DoS\n- 通知机制使用互斥锁（`notify_lock`）和完成量（`completion`）保证状态一致性\n- 支持 `wait_killable_recv` 选项，使等待通知回复的进程可被信号中断\n\n## 依赖关系\n\n- **BPF 子系统**：依赖 `linux/filter.h` 提供的 socket filter/BPF 执行引擎\n- **进程管理**：与 `sched.h`、`task_struct` 紧密集成，管理 per-task seccomp 状态\n- **文件系统与 fd 管理**：通过 `file.h`、`uaccess.h` 实现跨进程 fd 注入\n- **审计与日志**：集成 `audit.h` 支持 seccomp 事件审计\n- **架构相关代码**：通过 `asm/syscall.h` 获取系统调用号和参数\n- **能力机制**：依赖 `capability.h` 检查特权操作权限\n- **内存管理**：使用 `slab.h` 分配过滤器和通知结构\n\n## 使用场景\n\n1. **容器安全**：Docker、LXC 等容器运行时使用 seccomp 过滤器限制容器内进程的系统调用，防止逃逸\n2. **沙箱应用**：Chromium、Firefox 等浏览器使用 seccomp 构建渲染进程沙箱\n3. **最小权限原则**：特权服务（如 systemd、sshd）在初始化后启用 seccomp 以减少攻击面\n4. **动态策略执行**：通过 `SECCOMP_RET_USER_NOTIF` 实现用户态代理系统调用（如 ptrace 替代方案）\n5. **安全审计**：结合 `SECCOMP_RET_LOG` 记录所有被拦截或允许的系统调用行为\n6. **系统加固**：在不可信环境中运行程序时，强制限制其系统调用能力",
      "similarity": 0.5424949526786804,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/seccomp.c",
          "start_line": 937,
          "end_line": 1066,
          "content": [
            "static void __get_seccomp_filter(struct seccomp_filter *filter)",
            "{",
            "\trefcount_inc(&filter->refs);",
            "}",
            "void get_seccomp_filter(struct task_struct *tsk)",
            "{",
            "\tstruct seccomp_filter *orig = tsk->seccomp.filter;",
            "\tif (!orig)",
            "\t\treturn;",
            "\t__get_seccomp_filter(orig);",
            "\trefcount_inc(&orig->users);",
            "}",
            "static inline void seccomp_log(unsigned long syscall, long signr, u32 action,",
            "\t\t\t       bool requested)",
            "{",
            "\tbool log = false;",
            "",
            "\tswitch (action) {",
            "\tcase SECCOMP_RET_ALLOW:",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_TRAP:",
            "\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_ERRNO:",
            "\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_TRACE:",
            "\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_USER_NOTIF:",
            "\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_USER_NOTIF;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_LOG:",
            "\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_KILL_THREAD:",
            "\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_KILL_PROCESS:",
            "\tdefault:",
            "\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;",
            "\t}",
            "",
            "\t/*",
            "\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the",
            "\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence",
            "\t * any action from being logged by removing the action name from the",
            "\t * seccomp_actions_logged sysctl.",
            "\t */",
            "\tif (!log)",
            "\t\treturn;",
            "",
            "\taudit_seccomp(syscall, signr, action);",
            "}",
            "static void __secure_computing_strict(int this_syscall)",
            "{",
            "\tconst int *allowed_syscalls = mode1_syscalls;",
            "#ifdef CONFIG_COMPAT",
            "\tif (in_compat_syscall())",
            "\t\tallowed_syscalls = get_compat_mode1_syscalls();",
            "#endif",
            "\tdo {",
            "\t\tif (*allowed_syscalls == this_syscall)",
            "\t\t\treturn;",
            "\t} while (*++allowed_syscalls != -1);",
            "",
            "#ifdef SECCOMP_DEBUG",
            "\tdump_stack();",
            "#endif",
            "\tcurrent->seccomp.mode = SECCOMP_MODE_DEAD;",
            "\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);",
            "\tdo_exit(SIGKILL);",
            "}",
            "void secure_computing_strict(int this_syscall)",
            "{",
            "\tint mode = current->seccomp.mode;",
            "",
            "\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&",
            "\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))",
            "\t\treturn;",
            "",
            "\tif (mode == SECCOMP_MODE_DISABLED)",
            "\t\treturn;",
            "\telse if (mode == SECCOMP_MODE_STRICT)",
            "\t\t__secure_computing_strict(this_syscall);",
            "\telse",
            "\t\tBUG();",
            "}",
            "static u64 seccomp_next_notify_id(struct seccomp_filter *filter)",
            "{",
            "\t/*",
            "\t * Note: overflow is ok here, the id just needs to be unique per",
            "\t * filter.",
            "\t */",
            "\tlockdep_assert_held(&filter->notify_lock);",
            "\treturn filter->notif->next_id++;",
            "}",
            "static void seccomp_handle_addfd(struct seccomp_kaddfd *addfd, struct seccomp_knotif *n)",
            "{",
            "\tint fd;",
            "",
            "\t/*",
            "\t * Remove the notification, and reset the list pointers, indicating",
            "\t * that it has been handled.",
            "\t */",
            "\tlist_del_init(&addfd->list);",
            "\tif (!addfd->setfd)",
            "\t\tfd = receive_fd(addfd->file, addfd->flags);",
            "\telse",
            "\t\tfd = receive_fd_replace(addfd->fd, addfd->file, addfd->flags);",
            "\taddfd->ret = fd;",
            "",
            "\tif (addfd->ioctl_flags & SECCOMP_ADDFD_FLAG_SEND) {",
            "\t\t/* If we fail reset and return an error to the notifier */",
            "\t\tif (fd < 0) {",
            "\t\t\tn->state = SECCOMP_NOTIFY_SENT;",
            "\t\t} else {",
            "\t\t\t/* Return the FD we just added */",
            "\t\t\tn->flags = 0;",
            "\t\t\tn->error = 0;",
            "\t\t\tn->val = fd;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Mark the notification as completed. From this point, addfd mem",
            "\t * might be invalidated and we can't safely read it anymore.",
            "\t */",
            "\tcomplete(&addfd->completion);",
            "}"
          ],
          "function_name": "__get_seccomp_filter, get_seccomp_filter, seccomp_log, __secure_computing_strict, secure_computing_strict, seccomp_next_notify_id, seccomp_handle_addfd",
          "description": "管理seccomp过滤器引用计数及日志记录，secure_computing_strict强制模式检查系统调用合法性，seccomp_handle_addfd处理文件描述符添加通知",
          "similarity": 0.5359405279159546
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/seccomp.c",
          "start_line": 1582,
          "end_line": 1778,
          "content": [
            "static long seccomp_notify_send(struct seccomp_filter *filter,",
            "\t\t\t\tvoid __user *buf)",
            "{",
            "\tstruct seccomp_notif_resp resp = {};",
            "\tstruct seccomp_knotif *knotif;",
            "\tlong ret;",
            "",
            "\tif (copy_from_user(&resp, buf, sizeof(resp)))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (resp.flags & ~SECCOMP_USER_NOTIF_FLAG_CONTINUE)",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((resp.flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE) &&",
            "\t    (resp.error || resp.val))",
            "\t\treturn -EINVAL;",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tknotif = find_notification(filter, resp.id);",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Allow exactly one reply. */",
            "\tif (knotif->state != SECCOMP_NOTIFY_SENT) {",
            "\t\tret = -EINPROGRESS;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\tknotif->error = resp.error;",
            "\tknotif->val = resp.val;",
            "\tknotif->flags = resp.flags;",
            "\tif (filter->notif->flags & SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\tcomplete_on_current_cpu(&knotif->ready);",
            "\telse",
            "\t\tcomplete(&knotif->ready);",
            "out:",
            "\tmutex_unlock(&filter->notify_lock);",
            "\treturn ret;",
            "}",
            "static long seccomp_notify_id_valid(struct seccomp_filter *filter,",
            "\t\t\t\t    void __user *buf)",
            "{",
            "\tstruct seccomp_knotif *knotif;",
            "\tu64 id;",
            "\tlong ret;",
            "",
            "\tif (copy_from_user(&id, buf, sizeof(id)))",
            "\t\treturn -EFAULT;",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tknotif = find_notification(filter, id);",
            "\tif (knotif && knotif->state == SECCOMP_NOTIFY_SENT)",
            "\t\tret = 0;",
            "\telse",
            "\t\tret = -ENOENT;",
            "",
            "\tmutex_unlock(&filter->notify_lock);",
            "\treturn ret;",
            "}",
            "static long seccomp_notify_set_flags(struct seccomp_filter *filter,",
            "\t\t\t\t    unsigned long flags)",
            "{",
            "\tlong ret;",
            "",
            "\tif (flags & ~SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\tfilter->notif->flags = flags;",
            "\tmutex_unlock(&filter->notify_lock);",
            "\treturn 0;",
            "}",
            "static long seccomp_notify_addfd(struct seccomp_filter *filter,",
            "\t\t\t\t struct seccomp_notif_addfd __user *uaddfd,",
            "\t\t\t\t unsigned int size)",
            "{",
            "\tstruct seccomp_notif_addfd addfd;",
            "\tstruct seccomp_knotif *knotif;",
            "\tstruct seccomp_kaddfd kaddfd;",
            "\tint ret;",
            "",
            "\tBUILD_BUG_ON(sizeof(addfd) < SECCOMP_NOTIFY_ADDFD_SIZE_VER0);",
            "\tBUILD_BUG_ON(sizeof(addfd) != SECCOMP_NOTIFY_ADDFD_SIZE_LATEST);",
            "",
            "\tif (size < SECCOMP_NOTIFY_ADDFD_SIZE_VER0 || size >= PAGE_SIZE)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = copy_struct_from_user(&addfd, sizeof(addfd), uaddfd, size);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (addfd.newfd_flags & ~O_CLOEXEC)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (addfd.flags & ~(SECCOMP_ADDFD_FLAG_SETFD | SECCOMP_ADDFD_FLAG_SEND))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (addfd.newfd && !(addfd.flags & SECCOMP_ADDFD_FLAG_SETFD))",
            "\t\treturn -EINVAL;",
            "",
            "\tkaddfd.file = fget(addfd.srcfd);",
            "\tif (!kaddfd.file)",
            "\t\treturn -EBADF;",
            "",
            "\tkaddfd.ioctl_flags = addfd.flags;",
            "\tkaddfd.flags = addfd.newfd_flags;",
            "\tkaddfd.setfd = addfd.flags & SECCOMP_ADDFD_FLAG_SETFD;",
            "\tkaddfd.fd = addfd.newfd;",
            "\tinit_completion(&kaddfd.completion);",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\tgoto out;",
            "",
            "\tknotif = find_notification(filter, addfd.id);",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\t/*",
            "\t * We do not want to allow for FD injection to occur before the",
            "\t * notification has been picked up by a userspace handler, or after",
            "\t * the notification has been replied to.",
            "\t */",
            "\tif (knotif->state != SECCOMP_NOTIFY_SENT) {",
            "\t\tret = -EINPROGRESS;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (addfd.flags & SECCOMP_ADDFD_FLAG_SEND) {",
            "\t\t/*",
            "\t\t * Disallow queuing an atomic addfd + send reply while there are",
            "\t\t * some addfd requests still to process.",
            "\t\t *",
            "\t\t * There is no clear reason to support it and allows us to keep",
            "\t\t * the loop on the other side straight-forward.",
            "\t\t */",
            "\t\tif (!list_empty(&knotif->addfd)) {",
            "\t\t\tret = -EBUSY;",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "",
            "\t\t/* Allow exactly only one reply */",
            "\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\t}",
            "",
            "\tlist_add(&kaddfd.list, &knotif->addfd);",
            "\tcomplete(&knotif->ready);",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\t/* Now we wait for it to be processed or be interrupted */",
            "\tret = wait_for_completion_interruptible(&kaddfd.completion);",
            "\tif (ret == 0) {",
            "\t\t/*",
            "\t\t * We had a successful completion. The other side has already",
            "\t\t * removed us from the addfd queue, and",
            "\t\t * wait_for_completion_interruptible has a memory barrier upon",
            "\t\t * success that lets us read this value directly without",
            "\t\t * locking.",
            "\t\t */",
            "\t\tret = kaddfd.ret;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "\t/*",
            "\t * Even though we were woken up by a signal and not a successful",
            "\t * completion, a completion may have happened in the mean time.",
            "\t *",
            "\t * We need to check again if the addfd request has been handled,",
            "\t * and if not, we will remove it from the queue.",
            "\t */",
            "\tif (list_empty(&kaddfd.list))",
            "\t\tret = kaddfd.ret;",
            "\telse",
            "\t\tlist_del(&kaddfd.list);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&filter->notify_lock);",
            "out:",
            "\tfput(kaddfd.file);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "seccomp_notify_send, seccomp_notify_id_valid, seccomp_notify_set_flags, seccomp_notify_addfd",
          "description": "该代码段实现了seccomp过滤器中用户空间通知机制的相关功能，核心作用是处理通知响应、验证通知ID、配置通知标志及管理文件描述符注入。  \n`seccomp_notify_send`接收并处理用户空间的响应数据，校验合法性后更新通知状态；`seccomp_notify_id_valid`验证指定ID的通知是否存在；`seccomp_notify_set_flags`和`seccomp_notify_addfd`分别用于设置通知标志和安全地注入文件描述符，均通过互斥锁保护关键操作。  \n代码片段完整，未引入额外API，所有行为均基于现有内核seccomp通知框架实现。",
          "similarity": 0.514326274394989
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/seccomp.c",
          "start_line": 1340,
          "end_line": 1443,
          "content": [
            "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,",
            "\t\t\t    const bool recheck_after_trace)",
            "{",
            "\tBUG();",
            "",
            "\treturn -1;",
            "}",
            "int __secure_computing(const struct seccomp_data *sd)",
            "{",
            "\tint mode = current->seccomp.mode;",
            "\tint this_syscall;",
            "",
            "\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&",
            "\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))",
            "\t\treturn 0;",
            "",
            "\tthis_syscall = sd ? sd->nr :",
            "\t\tsyscall_get_nr(current, current_pt_regs());",
            "",
            "\tswitch (mode) {",
            "\tcase SECCOMP_MODE_STRICT:",
            "\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */",
            "\t\treturn 0;",
            "\tcase SECCOMP_MODE_FILTER:",
            "\t\treturn __seccomp_filter(this_syscall, sd, false);",
            "\t/* Surviving SECCOMP_RET_KILL_* must be proactively impossible. */",
            "\tcase SECCOMP_MODE_DEAD:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tdo_exit(SIGKILL);",
            "\t\treturn -1;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "long prctl_get_seccomp(void)",
            "{",
            "\treturn current->seccomp.mode;",
            "}",
            "static long seccomp_set_mode_strict(void)",
            "{",
            "\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;",
            "\tlong ret = -EINVAL;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "",
            "\tif (!seccomp_may_assign_mode(seccomp_mode))",
            "\t\tgoto out;",
            "",
            "#ifdef TIF_NOTSC",
            "\tdisable_TSC();",
            "#endif",
            "\tseccomp_assign_mode(current, seccomp_mode, 0);",
            "\tret = 0;",
            "",
            "out:",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void seccomp_notify_free(struct seccomp_filter *filter)",
            "{",
            "\tkfree(filter->notif);",
            "\tfilter->notif = NULL;",
            "}",
            "static void seccomp_notify_detach(struct seccomp_filter *filter)",
            "{",
            "\tstruct seccomp_knotif *knotif;",
            "",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "",
            "\t/*",
            "\t * If this file is being closed because e.g. the task who owned it",
            "\t * died, let's wake everyone up who was waiting on us.",
            "\t */",
            "\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {",
            "\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)",
            "\t\t\tcontinue;",
            "",
            "\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\t\tknotif->error = -ENOSYS;",
            "\t\tknotif->val = 0;",
            "",
            "\t\t/*",
            "\t\t * We do not need to wake up any pending addfd messages, as",
            "\t\t * the notifier will do that for us, as this just looks",
            "\t\t * like a standard reply.",
            "\t\t */",
            "\t\tcomplete(&knotif->ready);",
            "\t}",
            "",
            "\tseccomp_notify_free(filter);",
            "\tmutex_unlock(&filter->notify_lock);",
            "}",
            "static int seccomp_notify_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "",
            "\tseccomp_notify_detach(filter);",
            "\t__put_seccomp_filter(filter);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__seccomp_filter, __secure_computing, prctl_get_seccomp, seccomp_set_mode_strict, seccomp_notify_free, seccomp_notify_detach, seccomp_notify_release",
          "description": "提供seccomp模式切换接口(prctl_get_seccomp/seccomp_set_mode_strict)，实现通知资源释放(detach/release)机制",
          "similarity": 0.5061136484146118
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/seccomp.c",
          "start_line": 179,
          "end_line": 286,
          "content": [
            "static inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,",
            "\t\t\t\t\t     const struct seccomp_data *sd)",
            "{",
            "\treturn false;",
            "}",
            "static inline void seccomp_cache_prepare(struct seccomp_filter *sfilter)",
            "{",
            "}",
            "static void populate_seccomp_data(struct seccomp_data *sd)",
            "{",
            "\t/*",
            "\t * Instead of using current_pt_reg(), we're already doing the work",
            "\t * to safely fetch \"current\", so just use \"task\" everywhere below.",
            "\t */",
            "\tstruct task_struct *task = current;",
            "\tstruct pt_regs *regs = task_pt_regs(task);",
            "\tunsigned long args[6];",
            "",
            "\tsd->nr = syscall_get_nr(task, regs);",
            "\tsd->arch = syscall_get_arch(task);",
            "\tsyscall_get_arguments(task, regs, args);",
            "\tsd->args[0] = args[0];",
            "\tsd->args[1] = args[1];",
            "\tsd->args[2] = args[2];",
            "\tsd->args[3] = args[3];",
            "\tsd->args[4] = args[4];",
            "\tsd->args[5] = args[5];",
            "\tsd->instruction_pointer = KSTK_EIP(task);",
            "}",
            "static int seccomp_check_filter(struct sock_filter *filter, unsigned int flen)",
            "{",
            "\tint pc;",
            "\tfor (pc = 0; pc < flen; pc++) {",
            "\t\tstruct sock_filter *ftest = &filter[pc];",
            "\t\tu16 code = ftest->code;",
            "\t\tu32 k = ftest->k;",
            "",
            "\t\tswitch (code) {",
            "\t\tcase BPF_LD | BPF_W | BPF_ABS:",
            "\t\t\tftest->code = BPF_LDX | BPF_W | BPF_ABS;",
            "\t\t\t/* 32-bit aligned and not out of bounds. */",
            "\t\t\tif (k >= sizeof(struct seccomp_data) || k & 3)",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\tcontinue;",
            "\t\tcase BPF_LD | BPF_W | BPF_LEN:",
            "\t\t\tftest->code = BPF_LD | BPF_IMM;",
            "\t\t\tftest->k = sizeof(struct seccomp_data);",
            "\t\t\tcontinue;",
            "\t\tcase BPF_LDX | BPF_W | BPF_LEN:",
            "\t\t\tftest->code = BPF_LDX | BPF_IMM;",
            "\t\t\tftest->k = sizeof(struct seccomp_data);",
            "\t\t\tcontinue;",
            "\t\t/* Explicitly include allowed calls. */",
            "\t\tcase BPF_RET | BPF_K:",
            "\t\tcase BPF_RET | BPF_A:",
            "\t\tcase BPF_ALU | BPF_ADD | BPF_K:",
            "\t\tcase BPF_ALU | BPF_ADD | BPF_X:",
            "\t\tcase BPF_ALU | BPF_SUB | BPF_K:",
            "\t\tcase BPF_ALU | BPF_SUB | BPF_X:",
            "\t\tcase BPF_ALU | BPF_MUL | BPF_K:",
            "\t\tcase BPF_ALU | BPF_MUL | BPF_X:",
            "\t\tcase BPF_ALU | BPF_DIV | BPF_K:",
            "\t\tcase BPF_ALU | BPF_DIV | BPF_X:",
            "\t\tcase BPF_ALU | BPF_AND | BPF_K:",
            "\t\tcase BPF_ALU | BPF_AND | BPF_X:",
            "\t\tcase BPF_ALU | BPF_OR | BPF_K:",
            "\t\tcase BPF_ALU | BPF_OR | BPF_X:",
            "\t\tcase BPF_ALU | BPF_XOR | BPF_K:",
            "\t\tcase BPF_ALU | BPF_XOR | BPF_X:",
            "\t\tcase BPF_ALU | BPF_LSH | BPF_K:",
            "\t\tcase BPF_ALU | BPF_LSH | BPF_X:",
            "\t\tcase BPF_ALU | BPF_RSH | BPF_K:",
            "\t\tcase BPF_ALU | BPF_RSH | BPF_X:",
            "\t\tcase BPF_ALU | BPF_NEG:",
            "\t\tcase BPF_LD | BPF_IMM:",
            "\t\tcase BPF_LDX | BPF_IMM:",
            "\t\tcase BPF_MISC | BPF_TAX:",
            "\t\tcase BPF_MISC | BPF_TXA:",
            "\t\tcase BPF_LD | BPF_MEM:",
            "\t\tcase BPF_LDX | BPF_MEM:",
            "\t\tcase BPF_ST:",
            "\t\tcase BPF_STX:",
            "\t\tcase BPF_JMP | BPF_JA:",
            "\t\tcase BPF_JMP | BPF_JEQ | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JEQ | BPF_X:",
            "\t\tcase BPF_JMP | BPF_JGE | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JGE | BPF_X:",
            "\t\tcase BPF_JMP | BPF_JGT | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JGT | BPF_X:",
            "\t\tcase BPF_JMP | BPF_JSET | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JSET | BPF_X:",
            "\t\t\tcontinue;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "static inline bool seccomp_cache_check_allow_bitmap(const void *bitmap,",
            "\t\t\t\t\t\t    size_t bitmap_size,",
            "\t\t\t\t\t\t    int syscall_nr)",
            "{",
            "\tif (unlikely(syscall_nr < 0 || syscall_nr >= bitmap_size))",
            "\t\treturn false;",
            "\tsyscall_nr = array_index_nospec(syscall_nr, bitmap_size);",
            "",
            "\treturn test_bit(syscall_nr, bitmap);",
            "}"
          ],
          "function_name": "seccomp_cache_check_allow, seccomp_cache_prepare, populate_seccomp_data, seccomp_check_filter, seccomp_cache_check_allow_bitmap",
          "description": "实现seccomp过滤器校验逻辑，包括填充系统调用数据的populate_seccomp_data函数、验证BPF指令有效性的seccomp_check_filter函数，以及基于位图的syscall允许检查的seccomp_cache_check_allow_bitmap函数。",
          "similarity": 0.49592748284339905
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/seccomp.c",
          "start_line": 1111,
          "end_line": 1212,
          "content": [
            "static bool should_sleep_killable(struct seccomp_filter *match,",
            "\t\t\t\t  struct seccomp_knotif *n)",
            "{",
            "\treturn match->wait_killable_recv && n->state == SECCOMP_NOTIFY_SENT;",
            "}",
            "static int seccomp_do_user_notification(int this_syscall,",
            "\t\t\t\t\tstruct seccomp_filter *match,",
            "\t\t\t\t\tconst struct seccomp_data *sd)",
            "{",
            "\tint err;",
            "\tu32 flags = 0;",
            "\tlong ret = 0;",
            "\tstruct seccomp_knotif n = {};",
            "\tstruct seccomp_kaddfd *addfd, *tmp;",
            "",
            "\tmutex_lock(&match->notify_lock);",
            "\terr = -ENOSYS;",
            "\tif (!match->notif)",
            "\t\tgoto out;",
            "",
            "\tn.task = current;",
            "\tn.state = SECCOMP_NOTIFY_INIT;",
            "\tn.data = sd;",
            "\tn.id = seccomp_next_notify_id(match);",
            "\tinit_completion(&n.ready);",
            "\tlist_add_tail(&n.list, &match->notif->notifications);",
            "\tINIT_LIST_HEAD(&n.addfd);",
            "",
            "\tatomic_inc(&match->notif->requests);",
            "\tif (match->notif->flags & SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\twake_up_poll_on_current_cpu(&match->wqh, EPOLLIN | EPOLLRDNORM);",
            "\telse",
            "\t\twake_up_poll(&match->wqh, EPOLLIN | EPOLLRDNORM);",
            "",
            "\t/*",
            "\t * This is where we wait for a reply from userspace.",
            "\t */",
            "\tdo {",
            "\t\tbool wait_killable = should_sleep_killable(match, &n);",
            "",
            "\t\tmutex_unlock(&match->notify_lock);",
            "\t\tif (wait_killable)",
            "\t\t\terr = wait_for_completion_killable(&n.ready);",
            "\t\telse",
            "\t\t\terr = wait_for_completion_interruptible(&n.ready);",
            "\t\tmutex_lock(&match->notify_lock);",
            "",
            "\t\tif (err != 0) {",
            "\t\t\t/*",
            "\t\t\t * Check to see if the notifcation got picked up and",
            "\t\t\t * whether we should switch to wait killable.",
            "\t\t\t */",
            "\t\t\tif (!wait_killable && should_sleep_killable(match, &n))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tgoto interrupted;",
            "\t\t}",
            "",
            "\t\taddfd = list_first_entry_or_null(&n.addfd,",
            "\t\t\t\t\t\t struct seccomp_kaddfd, list);",
            "\t\t/* Check if we were woken up by a addfd message */",
            "\t\tif (addfd)",
            "\t\t\tseccomp_handle_addfd(addfd, &n);",
            "",
            "\t}  while (n.state != SECCOMP_NOTIFY_REPLIED);",
            "",
            "\tret = n.val;",
            "\terr = n.error;",
            "\tflags = n.flags;",
            "",
            "interrupted:",
            "\t/* If there were any pending addfd calls, clear them out */",
            "\tlist_for_each_entry_safe(addfd, tmp, &n.addfd, list) {",
            "\t\t/* The process went away before we got a chance to handle it */",
            "\t\taddfd->ret = -ESRCH;",
            "\t\tlist_del_init(&addfd->list);",
            "\t\tcomplete(&addfd->completion);",
            "\t}",
            "",
            "\t/*",
            "\t * Note that it's possible the listener died in between the time when",
            "\t * we were notified of a response (or a signal) and when we were able to",
            "\t * re-acquire the lock, so only delete from the list if the",
            "\t * notification actually exists.",
            "\t *",
            "\t * Also note that this test is only valid because there's no way to",
            "\t * *reattach* to a notifier right now. If one is added, we'll need to",
            "\t * keep track of the notif itself and make sure they match here.",
            "\t */",
            "\tif (match->notif)",
            "\t\tlist_del(&n.list);",
            "out:",
            "\tmutex_unlock(&match->notify_lock);",
            "",
            "\t/* Userspace requests to continue the syscall. */",
            "\tif (flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE)",
            "\t\treturn 0;",
            "",
            "\tsyscall_set_return_value(current, current_pt_regs(),",
            "\t\t\t\t err, ret);",
            "\treturn -1;",
            "}"
          ],
          "function_name": "should_sleep_killable, seccomp_do_user_notification",
          "description": "实现用户空间通知等待逻辑，seccomp_do_user_notification处理通知状态转换、文件描述符传递及超时控制",
          "similarity": 0.49475663900375366
        }
      ]
    }
  ]
}