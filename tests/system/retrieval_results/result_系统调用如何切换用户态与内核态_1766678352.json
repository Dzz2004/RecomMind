{
  "query": "系统调用如何切换用户态与内核态",
  "timestamp": "2025-12-25 23:59:12",
  "retrieved_files": [
    {
      "source_file": "kernel/user-return-notifier.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user-return-notifier.c`\n\n---\n\n# user-return-notifier.c 技术文档\n\n## 1. 文件概述\n\n`user-return-notifier.c` 实现了用户态返回通知机制（User Return Notifier），允许内核子系统在当前 CPU 即将从内核态返回用户态时注册回调函数。该机制用于在特定内核事件（如安全策略更新、性能监控等）发生后，延迟执行某些操作，直到进程真正返回用户空间，从而避免在关键内核路径中引入额外开销或竞态条件。\n\n## 2. 核心功能\n\n### 数据结构\n- `return_notifier_list`：每 CPU 变量（per-CPU variable），类型为 `struct hlist_head`，用于存储当前 CPU 上注册的所有用户返回通知器链表。\n\n### 主要函数\n- `user_return_notifier_register(struct user_return_notifier *urn)`  \n  注册一个用户返回通知器，将其加入当前 CPU 的通知链表，并设置当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `user_return_notifier_unregister(struct user_return_notifier *urn)`  \n  从当前 CPU 的通知链表中移除指定的通知器；若链表变为空，则清除当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `fire_user_return_notifiers(void)`  \n  遍历并调用当前 CPU 上所有已注册的通知器的回调函数 `on_user_return`，通常在内核即将返回用户态前由调度或系统调用退出路径调用。\n\n## 3. 关键实现\n\n- **每 CPU 链表设计**：使用 `DEFINE_PER_CPU` 定义 per-CPU 的哈希链表头，确保每个 CPU 维护独立的通知器列表，避免跨 CPU 同步开销。\n  \n- **原子上下文要求**：注册和注销操作必须在原子上下文中执行（不可睡眠），因为它们操作 per-CPU 数据且可能在中断或调度关键路径中被调用。\n\n- **线程标志位控制**：通过设置/清除任务结构体中的 `TIF_USER_RETURN_NOTIFY` 标志位（`TIF_` 表示 Thread Info Flag），通知内核在返回用户态前需调用 `fire_user_return_notifiers()`。\n\n- **安全遍历与调用**：`fire_user_return_notifiers()` 使用 `hlist_for_each_entry_safe` 安全遍历链表，允许回调函数在执行过程中注销自身或其他通知器。\n\n- **CPU 变量访问**：使用 `get_cpu_var()` 和 `put_cpu_var()` 保证在访问 per-CPU 变量期间禁止内核抢占，确保操作的 CPU 一致性。\n\n## 4. 依赖关系\n\n- `<linux/user-return-notifier.h>`：定义 `struct user_return_notifier` 及相关 API。\n- `<linux/percpu.h>`：提供 per-CPU 变量支持。\n- `<linux/sched.h>`：提供任务结构体（`current`）和线程标志位操作函数（如 `set_tsk_thread_flag`）。\n- `<linux/export.h>`：导出符号供其他内核模块使用（`EXPORT_SYMBOL_GPL`）。\n- 依赖架构相关的线程信息标志（`TIF_USER_RETURN_NOTIFY`）在 `thread_info` 中的定义。\n\n## 5. 使用场景\n\n- **安全模块**：如 SELinux 或 LSM 框架在策略更新后，需通知用户态进程重新评估权限，可延迟到返回用户态时触发。\n- **性能监控与跟踪**：在系统调用或中断处理完成后，于返回用户态前收集上下文切换或延迟信息。\n- **延迟工作调度**：某些不适合在中断或原子上下文中执行的操作，可注册为用户返回通知，在安全的用户态切换点执行。\n- **虚拟化与容器**：在客户机或容器退出内核时同步状态或注入事件。\n\n该机制是内核“延迟通知”模式的典型实现，确保高优先级内核路径不受回调逻辑影响，同时保证通知在正确的执行上下文中触发。",
      "similarity": 0.6648620367050171,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 15,
          "end_line": 36,
          "content": [
            "void user_return_notifier_register(struct user_return_notifier *urn)",
            "{",
            "\tset_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "\thlist_add_head(&urn->link, this_cpu_ptr(&return_notifier_list));",
            "}",
            "void user_return_notifier_unregister(struct user_return_notifier *urn)",
            "{",
            "\thlist_del(&urn->link);",
            "\tif (hlist_empty(this_cpu_ptr(&return_notifier_list)))",
            "\t\tclear_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "}",
            "void fire_user_return_notifiers(void)",
            "{",
            "\tstruct user_return_notifier *urn;",
            "\tstruct hlist_node *tmp2;",
            "\tstruct hlist_head *head;",
            "",
            "\thead = &get_cpu_var(return_notifier_list);",
            "\thlist_for_each_entry_safe(urn, tmp2, head, link)",
            "\t\turn->on_user_return(urn);",
            "\tput_cpu_var(return_notifier_list);",
            "}"
          ],
          "function_name": "user_return_notifier_register, user_return_notifier_unregister, fire_user_return_notifiers",
          "description": "实现用户态返回通知器的注册/注销与触发机制。register 函数将通知器链接到当前 CPU 的链表并设置 TIF_USER_RETURN_NOTIFY 标志；unregister 函数移除节点并清理标志；fire 函数遍历当前 CPU 链表执行所有注册的 on_user_return 回调函数。",
          "similarity": 0.6053537130355835
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "",
            "static DEFINE_PER_CPU(struct hlist_head, return_notifier_list);",
            "",
            "/*",
            " * Request a notification when the current cpu returns to userspace.  Must be",
            " * called in atomic context.  The notifier will also be called in atomic",
            " * context.",
            " */"
          ],
          "function_name": null,
          "description": "定义了一个 per-CPU 的哈希列表头结构 return_notifier_list，用于存储用户态返回通知器注册项。该结构通过 DEFINE_PER_CPU 宏为每个 CPU 创建独立的链表头，支持多 CPU 环境下的并发访问。",
          "similarity": 0.48641133308410645
        }
      ]
    },
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.6639426946640015,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.6410803198814392
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.45695003867149353
        }
      ]
    },
    {
      "source_file": "kernel/uid16.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:43:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `uid16.c`\n\n---\n\n# uid16.c 技术文档\n\n## 文件概述\n\n`uid16.c` 是 Linux 内核中用于提供 16 位用户 ID（UID）和组 ID（GID）系统调用兼容性的封装层。该文件实现了旧式 16 位 UID/GID 系统调用（如 `chown16`、`setuid16` 等）到现代 32 位 UID/GID 内核接口的桥接，确保运行在 32 位 UID/GID 架构上的旧应用程序仍能在支持高 UID（high UID）的现代内核上正常工作。文件注释中提到“希望五年后能移除这些接口”，表明其为临时兼容性方案。\n\n## 核心功能\n\n### 主要系统调用函数\n\n- **文件所有权变更类**：\n  - `chown16`：变更文件所有者和所属组（16 位接口）\n  - `lchown16`：变更符号链接指向文件的所有者和组（16 位接口）\n  - `fchown16`：通过文件描述符变更文件所有者和组（16 位接口）\n\n- **用户 ID 设置类**：\n  - `setuid16` / `seteuid16`（通过 `setreuid16` 实现）：设置真实/有效 UID\n  - `setreuid16`：同时设置真实 UID 和有效 UID\n  - `setresuid16`：设置真实、有效和保存的 UID\n  - `setfsuid16`：设置文件系统 UID\n\n- **组 ID 设置类**：\n  - `setgid16` / `setegid16`（通过 `setregid16` 实现）：设置真实/有效 GID\n  - `setregid16`：同时设置真实 GID 和有效 GID\n  - `setresgid16`：设置真实、有效和保存的 GID\n  - `setfsgid16`：设置文件系统 GID\n\n- **查询类**：\n  - `getuid16` / `geteuid16`：获取当前真实/有效 UID（16 位返回）\n  - `getgid16` / `getegid16`：获取当前真实/有效 GID（16 位返回）\n  - `getresuid16` / `getresgid16`：获取三类 UID/GID（真实、有效、保存）\n  - `getgroups16`：获取当前进程的附加组列表（16 位格式）\n  - `setgroups16`：设置当前进程的附加组列表（16 位输入）\n\n### 辅助函数\n\n- `groups16_to_user`：将内核 `group_info` 中的 GID 转换为 16 位格式并复制到用户空间\n- `groups16_from_user`：从用户空间读取 16 位 GID 列表并转换为内核 `kgid_t` 格式\n\n### 关键宏与类型\n\n- `old_uid_t` / `old_gid_t`：定义为 16 位整数类型（通常为 `__u16`）\n- `low2highuid` / `low2highgid`：将 16 位 UID/GID 扩展为 32 位内核表示\n- `high2lowuid` / `high2lowgid`：将 32 位内核 UID/GID 截断为 16 位返回用户空间\n- `from_kuid_munged` / `from_kgid_munged`：在用户命名空间上下文中将内核 UID/GID 转换为用户可见值，并处理无效 ID\n\n## 关键实现\n\n### UID/GID 转换机制\n\n- 所有 16 位系统调用首先使用 `low2highuid()` 或 `low2highgid()` 将传入的 16 位值转换为内核使用的 32 位 `kuid_t`/`kgid_t` 类型。\n- 查询类调用（如 `getuid16`）则通过 `from_kuid_munged()` 将内核 UID 映射到当前用户命名空间的用户可见值，再用 `high2lowuid()` 截断为 16 位返回。\n- `from_kuid_munged()` 在 UID 超出 16 位范围（>65535）时会返回 `(uid_t) -1`，确保旧程序不会收到无法处理的大值。\n\n### 用户命名空间支持\n\n- 所有转换均通过 `current_user_ns()` 获取当前进程的用户命名空间，确保在容器或用户命名空间隔离环境中正确映射 UID/GID。\n- 例如：`from_kuid_munged(cred->user_ns, cred->uid)` 将内核 UID 转换为该命名空间下的用户视角 UID。\n\n### 组列表处理\n\n- `getgroups16` 和 `setgroups16` 通过辅助函数 `groups16_to_user`/`groups16_from_user` 实现 16 位与内核 `kgid_t` 数组的双向转换。\n- `setgroups16` 在设置前调用 `groups_sort()` 对组列表排序，符合内核对 `group_info` 的要求。\n\n### 错误处理与边界检查\n\n- `setgroups16` 检查 `gidsetsize` 是否超过 `NGROUPS_MAX`，防止内存溢出。\n- `getgroups16` 在 `gidsetsize` 小于实际组数时返回 `-EINVAL`，符合 POSIX 语义。\n- 所有用户空间访问均通过 `put_user`/`get_user` 进行，失败时返回 `-EFAULT`。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/cred.h>`：访问 `struct cred` 和 `current_cred()`\n  - `<linux/highuid.h>`：提供 `low2highuid`/`high2lowuid` 等转换宏\n  - `<linux/uaccess.h>`：提供 `put_user`/`get_user` 用户空间访问接口\n  - `<linux/syscalls.h>`：使用 `SYSCALL_DEFINE` 宏定义系统调用\n  - `<linux/security.h>`：间接依赖安全模块钩子（如 `may_setgroups`）\n\n- **内核子系统依赖**：\n  - **用户命名空间**（`user_namespace`）：所有 UID/GID 转换基于当前命名空间\n  - **凭证管理**（`cred`）：读取/修改进程的 UID/GID 属性\n  - **组管理**（`group_info`）：处理附加组列表的分配、排序和设置\n  - **系统调用框架**：通过 `ksys_*` 和 `__sys_*` 内核内部接口复用主逻辑\n\n## 使用场景\n\n- **旧版二进制兼容**：运行在早期 Linux 发行版（仅支持 16 位 UID/GID）上的应用程序在现代内核上执行时，自动通过这些 16 位系统调用接口与内核交互。\n- **嵌入式或资源受限系统**：某些遗留嵌入式系统可能仍使用 16 位 UID/GID 接口以节省空间或保持 ABI 兼容。\n- **用户命名空间容器环境**：在容器中运行的旧程序可通过这些接口正确映射容器内 UID/GID 到宿主机内核表示。\n- **系统调用拦截与审计**：安全模块可通过这些封装层监控或控制对 UID/GID 的变更操作。\n\n> 注：随着 16 位 UID/GID 的淘汰，这些接口在现代系统中已极少使用，主要用于维持向后兼容性。",
      "similarity": 0.6501265168190002,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/uid16.c",
          "start_line": 114,
          "end_line": 151,
          "content": [
            "static int groups16_to_user(old_gid_t __user *grouplist,",
            "    struct group_info *group_info)",
            "{",
            "\tstruct user_namespace *user_ns = current_user_ns();",
            "\tint i;",
            "\told_gid_t group;",
            "\tkgid_t kgid;",
            "",
            "\tfor (i = 0; i < group_info->ngroups; i++) {",
            "\t\tkgid = group_info->gid[i];",
            "\t\tgroup = high2lowgid(from_kgid_munged(user_ns, kgid));",
            "\t\tif (put_user(group, grouplist+i))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int groups16_from_user(struct group_info *group_info,",
            "    old_gid_t __user *grouplist)",
            "{",
            "\tstruct user_namespace *user_ns = current_user_ns();",
            "\tint i;",
            "\told_gid_t group;",
            "\tkgid_t kgid;",
            "",
            "\tfor (i = 0; i < group_info->ngroups; i++) {",
            "\t\tif (get_user(group, grouplist+i))",
            "\t\t\treturn  -EFAULT;",
            "",
            "\t\tkgid = make_kgid(user_ns, low2highgid(group));",
            "\t\tif (!gid_valid(kgid))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tgroup_info->gid[i] = kgid;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "groups16_to_user, groups16_from_user",
          "description": "该代码块包含两个辅助函数，groups16_to_user将用户组列表中的旧16位GID转换为kgid类型并写入用户空间缓冲区，groups16_from_user则从用户空间读取旧GID转换为kgid并填充至group_info结构，确保用户组操作在旧GID与内核GID之间的双向转换。",
          "similarity": 0.6142866611480713
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/uid16.c",
          "start_line": 1,
          "end_line": 113,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *\tWrapper functions for 16bit uid back compatibility. All nicely tied",
            " *\ttogether in the faint hope we can take the out in five years time.",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/notifier.h>",
            "#include <linux/reboot.h>",
            "#include <linux/prctl.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/highuid.h>",
            "#include <linux/security.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#include \"uid16.h\"",
            "",
            "SYSCALL_DEFINE3(chown16, const char __user *, filename, old_uid_t, user, old_gid_t, group)",
            "{",
            "\treturn ksys_chown(filename, low2highuid(user), low2highgid(group));",
            "}",
            "",
            "SYSCALL_DEFINE3(lchown16, const char __user *, filename, old_uid_t, user, old_gid_t, group)",
            "{",
            "\treturn ksys_lchown(filename, low2highuid(user), low2highgid(group));",
            "}",
            "",
            "SYSCALL_DEFINE3(fchown16, unsigned int, fd, old_uid_t, user, old_gid_t, group)",
            "{",
            "\treturn ksys_fchown(fd, low2highuid(user), low2highgid(group));",
            "}",
            "",
            "SYSCALL_DEFINE2(setregid16, old_gid_t, rgid, old_gid_t, egid)",
            "{",
            "\treturn __sys_setregid(low2highgid(rgid), low2highgid(egid));",
            "}",
            "",
            "SYSCALL_DEFINE1(setgid16, old_gid_t, gid)",
            "{",
            "\treturn __sys_setgid(low2highgid(gid));",
            "}",
            "",
            "SYSCALL_DEFINE2(setreuid16, old_uid_t, ruid, old_uid_t, euid)",
            "{",
            "\treturn __sys_setreuid(low2highuid(ruid), low2highuid(euid));",
            "}",
            "",
            "SYSCALL_DEFINE1(setuid16, old_uid_t, uid)",
            "{",
            "\treturn __sys_setuid(low2highuid(uid));",
            "}",
            "",
            "SYSCALL_DEFINE3(setresuid16, old_uid_t, ruid, old_uid_t, euid, old_uid_t, suid)",
            "{",
            "\treturn __sys_setresuid(low2highuid(ruid), low2highuid(euid),",
            "\t\t\t\t low2highuid(suid));",
            "}",
            "",
            "SYSCALL_DEFINE3(getresuid16, old_uid_t __user *, ruidp, old_uid_t __user *, euidp, old_uid_t __user *, suidp)",
            "{",
            "\tconst struct cred *cred = current_cred();",
            "\tint retval;",
            "\told_uid_t ruid, euid, suid;",
            "",
            "\truid = high2lowuid(from_kuid_munged(cred->user_ns, cred->uid));",
            "\teuid = high2lowuid(from_kuid_munged(cred->user_ns, cred->euid));",
            "\tsuid = high2lowuid(from_kuid_munged(cred->user_ns, cred->suid));",
            "",
            "\tif (!(retval   = put_user(ruid, ruidp)) &&",
            "\t    !(retval   = put_user(euid, euidp)))",
            "\t\tretval = put_user(suid, suidp);",
            "",
            "\treturn retval;",
            "}",
            "",
            "SYSCALL_DEFINE3(setresgid16, old_gid_t, rgid, old_gid_t, egid, old_gid_t, sgid)",
            "{",
            "\treturn __sys_setresgid(low2highgid(rgid), low2highgid(egid),",
            "\t\t\t\t low2highgid(sgid));",
            "}",
            "",
            "SYSCALL_DEFINE3(getresgid16, old_gid_t __user *, rgidp, old_gid_t __user *, egidp, old_gid_t __user *, sgidp)",
            "{",
            "\tconst struct cred *cred = current_cred();",
            "\tint retval;",
            "\told_gid_t rgid, egid, sgid;",
            "",
            "\trgid = high2lowgid(from_kgid_munged(cred->user_ns, cred->gid));",
            "\tegid = high2lowgid(from_kgid_munged(cred->user_ns, cred->egid));",
            "\tsgid = high2lowgid(from_kgid_munged(cred->user_ns, cred->sgid));",
            "",
            "\tif (!(retval   = put_user(rgid, rgidp)) &&",
            "\t    !(retval   = put_user(egid, egidp)))",
            "\t\tretval = put_user(sgid, sgidp);",
            "",
            "\treturn retval;",
            "}",
            "",
            "SYSCALL_DEFINE1(setfsuid16, old_uid_t, uid)",
            "{",
            "\treturn __sys_setfsuid(low2highuid(uid));",
            "}",
            "",
            "SYSCALL_DEFINE1(setfsgid16, old_gid_t, gid)",
            "{",
            "\treturn __sys_setfsgid(low2highgid(gid));",
            "}",
            ""
          ],
          "function_name": null,
          "description": "此代码块实现了16位UID的兼容性包装函数，将old_uid_t类型的参数转换为高位UID（通过low2highuid）后调用相应的内核函数（如ksys_chown、__sys_setuid等），并提供从高位UID还原为低位UID的逻辑（通过high2lowuid），以维护对旧应用程序的兼容性。",
          "similarity": 0.5373550057411194
        }
      ]
    }
  ]
}