{
  "query": "banker algorithm",
  "timestamp": "2025-12-26 01:08:42",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/bloom_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:56:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bloom_filter.c`\n\n---\n\n# `bpf/bloom_filter.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了 Linux 内核中 eBPF（extended Berkeley Packet Filter）子系统所支持的 **布隆过滤器（Bloom Filter）映射类型**。布隆过滤器是一种空间高效的概率型数据结构，用于快速判断某个元素是否**可能存在于集合中**（允许假阳性，但不允许假阴性）。该映射类型专为只写入、只查询、不可删除的场景设计，适用于高性能、低内存开销的成员存在性检测。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_bloom_filter`**  \n  布隆过滤器的具体实现结构体，包含：\n  - `struct bpf_map map`：继承自通用 eBPF 映射结构。\n  - `u32 bitset_mask`：位图掩码，用于快速取模（因位图大小为 2 的幂）。\n  - `u32 hash_seed`：哈希种子，用于初始化哈希函数（可选随机化）。\n  - `u32 nr_hash_funcs`：使用的哈希函数数量（1–15，由 `map_extra` 指定）。\n  - `unsigned long bitset[]`：柔性数组，存储位图数据。\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `hash()` | 根据输入值、哈希种子和索引计算哈希值，并通过 `bitset_mask` 取模得到位图索引。支持 4 字节对齐和非对齐数据。 |\n| `bloom_map_peek_elem()` | 查询元素是否存在：对每个哈希函数计算位图位置，若任一位为 0 则返回 `-ENOENT`（不存在）；否则返回 0（可能存在）。 |\n| `bloom_map_push_elem()` | 插入元素：对每个哈希函数计算位图位置并置位。仅支持 `BPF_ANY` 标志。 |\n| `bloom_map_alloc()` | 分配并初始化布隆过滤器映射。根据 `max_entries` 和 `map_extra`（哈希函数数）计算最优位图大小，并向上取整为 2 的幂。 |\n| `bloom_map_free()` | 释放布隆过滤器占用的内存。 |\n| `bloom_map_alloc_check()` | 在创建映射前校验参数合法性（如 `value_size` 不超过 `KMALLOC_MAX_SIZE`）。 |\n| `bloom_map_check_btf()` | BTF（BPF Type Format）校验：要求 key 类型为 `void`（无 key）。 |\n| `bloom_map_mem_usage()` | 返回该映射实际占用的内存大小（含位图）。 |\n\n### 不支持的操作（返回 `-EOPNOTSUPP` 或 `-EINVAL`）\n\n- `bloom_map_pop_elem()`：不支持弹出元素。\n- `bloom_map_delete_elem()`：不支持删除元素。\n- `bloom_map_get_next_key()`：不支持遍历。\n- `bloom_map_lookup_elem()` / `bloom_map_update_elem()`：eBPF 程序应使用 `map_peek_elem` 和 `map_push_elem` 替代。\n\n### 映射操作表\n\n- `bloom_filter_map_ops`：定义了该映射类型支持的所有操作回调函数，注册到 eBPF 子系统。\n\n## 3. 关键实现\n\n### 布隆过滤器参数计算\n\n- **哈希函数数量**：由用户通过 `attr->map_extra & 0xF` 指定（1–15），若为 0 则默认使用 5 个。\n- **位图大小计算**：\n  - 理论最优位数：`n * k / ln(2)`，其中 `n = max_entries`，`k = nr_hash_funcs`。\n  - 代码使用 `7/5 ≈ 1/ln(2)` 近似计算：`nr_bits = (max_entries * k * 7) / 5`。\n  - 为提升哈希效率，将 `nr_bits` **向上取整为 2 的幂**，从而可用 `& (size - 1)` 替代取模运算。\n  - 若计算溢出（> 2^31），则使用最大位图（`U32_MAX` 位，约 512 MB）。\n\n### 哈希函数\n\n- 使用内核提供的 `jhash()` 和 `jhash2()`（Jenkins 哈希）。\n- 每个哈希函数通过 `hash_seed + index` 区分，确保独立性。\n- 支持任意长度的 `value`（由 `value_size` 指定），自动选择对齐/非对齐版本。\n\n### 内存分配\n\n- 使用 `bpf_map_area_alloc()` 分配连续内存，包含结构体头和位图。\n- 位图大小按 `unsigned long` 对齐，确保位操作效率。\n\n### 安全与校验\n\n- 严格校验创建参数：`key_size` 必须为 0，`value_size` 和 `max_entries` 必须 > 0。\n- 仅允许特定 `map_flags`（`BPF_F_NUMA_NODE`、`BPF_F_ZERO_SEED`、`BPF_F_ACCESS_MASK`）。\n- BTF 校验强制 key 类型为 `void`，符合“无 key”设计。\n\n## 4. 依赖关系\n\n- **内核头文件**：\n  - `<linux/bitmap.h>`：提供 `test_bit()`、`set_bit()` 等位操作。\n  - `<linux/bpf.h>`：eBPF 核心定义（`bpf_map`、操作码等）。\n  - `<linux/btf.h>`：BTF 类型系统支持。\n  - `<linux/jhash.h>`：Jenkins 哈希函数实现。\n  - `<linux/random.h>`：`get_random_u32()` 用于生成哈希种子。\n- **eBPF 子系统**：通过 `bpf_map_ops` 机制集成到 eBPF 映射框架中。\n- **内存管理**：依赖 `bpf_map_area_alloc/free` 进行 NUMA 感知内存分配。\n\n## 5. 使用场景\n\n- **网络数据包过滤**：快速判断 IP 地址、端口等是否在可疑集合中。\n- **安全监控**：检测进程、文件路径是否属于已知恶意样本（允许少量误报）。\n- **性能分析**：记录已观测到的事件 ID，避免重复处理。\n- **资源去重**：在无法存储完整集合的场景下，高效判断元素是否已存在。\n\n> **注意**：由于布隆过滤器**不支持删除操作**，且存在**假阳性**，适用于“写一次、查多次”且可容忍少量误报的场景。eBPF 程序需通过 `bpf_map_peek_elem()` 查询，通过 `bpf_map_push_elem()` 插入。",
      "similarity": 0.49890804290771484,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 23,
          "end_line": 117,
          "content": [
            "static u32 hash(struct bpf_bloom_filter *bloom, void *value,",
            "\t\tu32 value_size, u32 index)",
            "{",
            "\tu32 h;",
            "",
            "\tif (likely(value_size % 4 == 0))",
            "\t\th = jhash2(value, value_size / 4, bloom->hash_seed + index);",
            "\telse",
            "\t\th = jhash(value, value_size, bloom->hash_seed + index);",
            "",
            "\treturn h & bloom->bitset_mask;",
            "}",
            "static long bloom_map_peek_elem(struct bpf_map *map, void *value)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tif (!test_bit(h, bloom->bitset))",
            "\t\t\treturn -ENOENT;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_push_elem(struct bpf_map *map, void *value, u64 flags)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tif (flags != BPF_ANY)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tset_bit(h, bloom->bitset);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_pop_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static long bloom_map_delete_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_get_next_key(struct bpf_map *map, void *key, void *next_key)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_alloc_check(union bpf_attr *attr)",
            "{",
            "\tif (attr->value_size > KMALLOC_MAX_SIZE)",
            "\t\t/* if value_size is bigger, the user space won't be able to",
            "\t\t * access the elements.",
            "\t\t */",
            "\t\treturn -E2BIG;",
            "",
            "\treturn 0;",
            "}",
            "static void bloom_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "",
            "\tbpf_map_area_free(bloom);",
            "}",
            "static long bloom_map_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t  void *value, u64 flags)",
            "{",
            "\t/* The eBPF program should use map_push_elem instead */",
            "\treturn -EINVAL;",
            "}",
            "static int bloom_map_check_btf(const struct bpf_map *map,",
            "\t\t\t       const struct btf *btf,",
            "\t\t\t       const struct btf_type *key_type,",
            "\t\t\t       const struct btf_type *value_type)",
            "{",
            "\t/* Bloom filter maps are keyless */",
            "\treturn btf_type_is_void(key_type) ? 0 : -EINVAL;",
            "}",
            "static u64 bloom_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom;",
            "\tu64 bitset_bytes;",
            "",
            "\tbloom = container_of(map, struct bpf_bloom_filter, map);",
            "\tbitset_bytes = BITS_TO_BYTES((u64)bloom->bitset_mask + 1);",
            "\tbitset_bytes = roundup(bitset_bytes, sizeof(unsigned long));",
            "\treturn sizeof(*bloom) + bitset_bytes;",
            "}"
          ],
          "function_name": "hash, bloom_map_peek_elem, bloom_map_push_elem, bloom_map_pop_elem, bloom_map_delete_elem, bloom_map_get_next_key, bloom_map_alloc_check, bloom_map_free, bloom_map_update_elem, bloom_map_check_btf, bloom_map_mem_usage",
          "description": "实现Bloom过滤器核心操作，包括哈希计算、元素存在性检测、插入操作、内存校验、资源释放及内存占用统计，部分接口暂不支持并返回相应错误码",
          "similarity": 0.4826749861240387
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2021 Facebook */",
            "",
            "#include <linux/bitmap.h>",
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/err.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#define BLOOM_CREATE_FLAG_MASK \\",
            "\t(BPF_F_NUMA_NODE | BPF_F_ZERO_SEED | BPF_F_ACCESS_MASK)",
            "",
            "struct bpf_bloom_filter {",
            "\tstruct bpf_map map;",
            "\tu32 bitset_mask;",
            "\tu32 hash_seed;",
            "\tu32 nr_hash_funcs;",
            "\tunsigned long bitset[];",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义Bloom过滤器内核结构体，包含位图掩码、哈希种子、哈希函数数及动态扩展的位集合数组，用于eBPF程序中的布隆过滤器实现",
          "similarity": 0.43255162239074707
        }
      ]
    },
    {
      "source_file": "kernel/bpf/kmem_cache_iter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:13:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\kmem_cache_iter.c`\n\n---\n\n# `bpf/kmem_cache_iter.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了 BPF（Berkeley Packet Filter）迭代器（iterator）机制对内核 slab 分配器中所有 `kmem_cache` 对象的遍历支持。通过该迭代器，BPF 程序可以在运行时安全地遍历系统中所有活动的内存缓存（slab caches），用于监控、调试或性能分析等用途。该实现同时支持 BPF kfunc 接口（供 BPF 程序直接调用）和基于 `seq_file` 的传统 BPF 迭代器接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_iter_kmem_cache`**  \n  用户态或 BPF 程序可见的不透明迭代器句柄，用于封装内部状态。\n\n- **`struct bpf_iter_kmem_cache_kern`**  \n  内核内部使用的迭代器状态结构，包含当前遍历位置（`pos` 指向 `kmem_cache`）。\n\n- **`struct bpf_iter__kmem_cache`**  \n  BPF 迭代器上下文结构，作为 BPF 程序的输入参数，包含元数据和当前 `kmem_cache` 指针。\n\n- **`union kmem_cache_iter_priv`**  \n  联合体，用于在 `seq_file` 私有数据中同时容纳用户态和内核态的迭代器结构。\n\n### 主要函数\n\n- **`bpf_iter_kmem_cache_new()`**  \n  初始化一个新的 `kmem_cache` 迭代器，设置起始位置为特殊标记 `KMEM_CACHE_POS_START`。\n\n- **`bpf_iter_kmem_cache_next()`**  \n  获取下一个有效的 `kmem_cache` 对象。负责引用计数管理：对新对象增加引用，对旧对象减少引用并在引用归零时调用 `kmem_cache_destroy()`。\n\n- **`bpf_iter_kmem_cache_destroy()`**  \n  销毁迭代器，释放当前持有的 `kmem_cache` 引用（如需要则触发销毁）。\n\n- **`kmem_cache_iter_seq_start()` / `next()` / `stop()` / `show()`**  \n  实现 `seq_file` 接口，用于支持通过 BPF 迭代器文件描述符进行遍历。\n\n- **`bpf_kmem_cache_iter_init()`**  \n  模块初始化函数，注册 `kmem_cache` 类型的 BPF 迭代器目标。\n\n## 3. 关键实现\n\n### 引用计数管理\n- 遍历时对每个非启动缓存（`boot_cache`，其 `refcount < 0`）的 `kmem_cache` 对象进行引用计数操作：\n  - 进入时（`next` 或 `start`）若 `refcount > 0`，则递增引用。\n  - 离开时（`next` 的前一个或 `stop`）若引用计数降至 1，则标记为可销毁，并在锁外调用 `kmem_cache_destroy()`。\n- 此机制确保遍历过程中目标对象不会被意外释放，同时避免内存泄漏。\n\n### 并发安全\n- 所有对全局 `slab_caches` 链表的访问均受 `slab_mutex` 互斥锁保护。\n- 由于遍历过程可能释放锁（如 `kmem_cache_destroy()` 需要睡眠），实现采用“按位置查找”策略（`seq_start` 中通过 `*pos` 重新定位），而非保存链表指针，以容忍中间元素的删除（虽可能跳过，但保证安全）。\n\n### BPF 接口集成\n- 通过 `DEFINE_BPF_ITER_FUNC` 和 `bpf_iter_reg_target()` 注册为 BPF 迭代器目标 `\"kmem_cache\"`。\n- 使用 `BTF_ID_LIST_GLOBAL_SINGLE` 导出 `kmem_cache` 结构的 BTF ID，使 BPF 程序能安全访问其字段。\n- 上下文参数 `s` 被标记为 `PTR_TO_BTF_ID_OR_NULL | PTR_TRUSTED`，表明其为可信的、类型安全的指针。\n\n### 特殊起始标记\n- 使用 `(void *)1L` 作为 `KMEM_CACHE_POS_START`，避免与合法指针或 `NULL` 冲突，用于标识迭代尚未开始。\n\n## 4. 依赖关系\n\n- **`<linux/slab.h>`**：提供 `kmem_cache`、`slab_caches` 链表和 `slab_mutex` 的定义。\n- **`<linux/bpf.h>`**：BPF 核心接口，包括迭代器注册、程序执行等。\n- **`<linux/btf_ids.h>`**：BTF（BPF Type Format）ID 管理，用于类型安全。\n- **`../../mm/slab.h`**：内核内部 slab 实现头文件，暴露 `kmem_cache` 结构细节。\n- **`kmem_cache_destroy()`**：依赖 slab 子系统的缓存销毁逻辑。\n\n## 5. 使用场景\n\n- **系统监控工具**：BPF 程序可通过此迭代器收集所有 slab 缓存的统计信息（如对象数量、内存使用量），用于内存泄漏检测或性能分析。\n- **安全审计**：检查异常或可疑的 `kmem_cache` 创建行为。\n- **内核调试**：在运行时动态查询 slab 子系统的状态，无需修改内核代码或重启系统。\n- **eBPF 应用开发**：为高级内存分析工具（如 `bpftrace`、`bcc` 工具集）提供底层支持。",
      "similarity": 0.4929070472717285,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/kmem_cache_iter.c",
          "start_line": 24,
          "end_line": 99,
          "content": [
            "__bpf_kfunc int bpf_iter_kmem_cache_new(struct bpf_iter_kmem_cache *it)",
            "{",
            "\tstruct bpf_iter_kmem_cache_kern *kit = (void *)it;",
            "",
            "\tBUILD_BUG_ON(sizeof(*kit) > sizeof(*it));",
            "\tBUILD_BUG_ON(__alignof__(*kit) != __alignof__(*it));",
            "",
            "\tkit->pos = KMEM_CACHE_POS_START;",
            "\treturn 0;",
            "}",
            "__bpf_kfunc void bpf_iter_kmem_cache_destroy(struct bpf_iter_kmem_cache *it)",
            "{",
            "\tstruct bpf_iter_kmem_cache_kern *kit = (void *)it;",
            "\tstruct kmem_cache *s = kit->pos;",
            "\tbool destroy = false;",
            "",
            "\tif (s == NULL || s == KMEM_CACHE_POS_START)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&slab_mutex);",
            "",
            "\t/* Skip kmem_cache_destroy() for active entries */",
            "\tif (s->refcount > 1)",
            "\t\ts->refcount--;",
            "\telse if (s->refcount == 1)",
            "\t\tdestroy = true;",
            "",
            "\tmutex_unlock(&slab_mutex);",
            "",
            "\tif (destroy)",
            "\t\tkmem_cache_destroy(s);",
            "}",
            "static void kmem_cache_iter_seq_stop(struct seq_file *seq, void *v)",
            "{",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_iter__kmem_cache ctx = {",
            "\t\t.meta = &meta,",
            "\t\t.s = v,",
            "\t};",
            "\tunion kmem_cache_iter_priv *p = seq->private;",
            "\tstruct bpf_prog *prog;",
            "",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, true);",
            "\tif (prog && !ctx.s)",
            "\t\tbpf_iter_run_prog(prog, &ctx);",
            "",
            "\tbpf_iter_kmem_cache_destroy(&p->it);",
            "}",
            "static int kmem_cache_iter_seq_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_iter__kmem_cache ctx = {",
            "\t\t.meta = &meta,",
            "\t\t.s = v,",
            "\t};",
            "\tstruct bpf_prog *prog;",
            "\tint ret = 0;",
            "",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, false);",
            "\tif (prog)",
            "\t\tret = bpf_iter_run_prog(prog, &ctx);",
            "",
            "\treturn ret;",
            "}",
            "static void bpf_iter_kmem_cache_show_fdinfo(const struct bpf_iter_aux_info *aux,",
            "\t\t\t\t\t    struct seq_file *seq)",
            "{",
            "\tseq_puts(seq, \"kmem_cache iter\\n\");",
            "}",
            "static int __init bpf_kmem_cache_iter_init(void)",
            "{",
            "\tbpf_kmem_cache_reg_info.ctx_arg_info[0].btf_id = bpf_kmem_cache_btf_id[0];",
            "\treturn bpf_iter_reg_target(&bpf_kmem_cache_reg_info);",
            "}"
          ],
          "function_name": "bpf_iter_kmem_cache_new, bpf_iter_kmem_cache_destroy, kmem_cache_iter_seq_stop, kmem_cache_iter_seq_show, bpf_iter_kmem_cache_show_fdinfo, bpf_kmem_cache_iter_init",
          "description": "实现BPF kmem_cache迭代器的核心函数，包含迭代器创建/销毁逻辑、序列化遍历控制、BPF程序执行及注册机制，通过slab_mutex保护缓存引用计数并处理销毁操作",
          "similarity": 0.4523184895515442
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/kmem_cache_iter.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2024 Google */",
            "#include <linux/bpf.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/seq_file.h>",
            "",
            "#include \"../../mm/slab.h\" /* kmem_cache, slab_caches and slab_mutex */",
            "",
            "/* open-coded version */",
            "struct bpf_iter_kmem_cache {",
            "\t__u64 __opaque[1];",
            "} __attribute__((aligned(8)));",
            "",
            "struct bpf_iter_kmem_cache_kern {",
            "\tstruct kmem_cache *pos;",
            "} __attribute__((aligned(8)));",
            "",
            "#define KMEM_CACHE_POS_START  ((void *)1L)",
            "",
            "__bpf_kfunc_start_defs();",
            ""
          ],
          "function_name": null,
          "description": "定义BPF kmem_cache迭代器的通用结构体和宏，用于支持BPF程序访问slab缓存对象，包含对齐属性和位置起始标记，但未包含完整实现",
          "similarity": 0.4232504963874817
        }
      ]
    },
    {
      "source_file": "kernel/bpf/queue_stack_maps.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:28:15\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\queue_stack_maps.c`\n\n---\n\n# bpf/queue_stack_maps.c 技术文档\n\n## 1. 文件概述\n\n`bpf/queue_stack_maps.c` 实现了 BPF（Berkeley Packet Filter）子系统中的两种特殊映射类型：**队列（Queue）** 和 **栈（Stack）**。这两种映射提供先进先出（FIFO）和后进先出（LIFO）的数据结构语义，用于在 eBPF 程序与用户空间之间高效传递数据。该文件定义了共享的底层数据结构 `struct bpf_queue_stack`，并通过两套不同的操作函数（`queue_map_ops` 和 `stack_map_ops`）分别暴露队列和栈的行为。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_queue_stack`**  \n  队列/栈映射的底层实现结构体，包含：\n  - `struct bpf_map map`：继承自通用 BPF 映射结构\n  - `raw_spinlock_t lock`：保护并发访问的原始自旋锁\n  - `u32 head, tail`：环形缓冲区的头尾指针\n  - `u32 size`：缓冲区实际大小（`max_entries + 1`）\n  - `char elements[]`：变长数组，存储实际元素数据（8 字节对齐）\n\n### 主要函数\n\n- **内存管理**\n  - `queue_stack_map_alloc_check()`：验证创建参数合法性\n  - `queue_stack_map_alloc()`：分配并初始化映射内存\n  - `queue_stack_map_free()`：释放映射内存\n  - `queue_stack_map_mem_usage()`：计算内存占用\n\n- **通用操作（返回错误）**\n  - `queue_stack_map_lookup_elem()`：不支持按键查找（返回 `NULL`）\n  - `queue_stack_map_update_elem()`：不支持按键更新（返回 `-EINVAL`）\n  - `queue_stack_map_delete_elem()`：不支持按键删除（返回 `-EINVAL`）\n  - `queue_stack_map_get_next_key()`：不支持迭代（返回 `-EINVAL`）\n\n- **队列专用操作**\n  - `queue_map_peek_elem()`：查看队首元素（不删除）\n  - `queue_map_pop_elem()`：弹出队首元素\n\n- **栈专用操作**\n  - `stack_map_peek_elem()`：查看栈顶元素（不删除）\n  - `stack_map_pop_elem()`：弹出栈顶元素\n\n- **共享写入操作**\n  - `queue_stack_map_push_elem()`：向队列尾部/栈顶部插入元素（支持 `BPF_EXIST` 覆盖模式）\n\n- **辅助函数**\n  - `bpf_queue_stack()`：从 `bpf_map` 指针转换为具体结构体指针\n  - `queue_stack_map_is_empty()`：判断是否为空\n  - `queue_stack_map_is_full()`：判断是否已满\n\n### 操作函数表\n\n- **`queue_map_ops`**：队列映射的操作函数集合\n- **`stack_map_ops`**：栈映射的操作函数集合\n\n## 3. 关键实现\n\n### 环形缓冲区设计\n- 使用 `head` 和 `tail` 指针实现环形缓冲区\n- 缓冲区实际大小为 `max_entries + 1`，通过牺牲一个槽位区分空/满状态：\n  - **空条件**：`head == tail`\n  - **满条件**：`(head + 1) % size == tail`\n\n### 并发安全机制\n- 使用 `raw_spinlock_t` 保护所有操作\n- 特殊处理 NMI（不可屏蔽中断）上下文：\n  - 在 NMI 中使用 `raw_spin_trylock_irqsave()` 避免死锁\n  - 在其他上下文使用 `raw_spin_lock_irqsave()`\n\n### 队列 vs 栈行为差异\n- **队列（FIFO）**：\n  - `pop/peek` 操作从 `tail` 读取\n  - `push` 操作写入 `head`\n- **栈（LIFO）**：\n  - `pop/peek` 操作从 `head - 1` 读取\n  - `push` 操作写入 `head`\n\n### 覆盖写入策略\n- 当缓冲区满时，若指定 `BPF_EXIST` 标志：\n  - **队列**：自动推进 `tail` 指针覆盖最旧元素\n  - **栈**：自动推进 `tail` 指针（逻辑上丢弃最旧元素）\n\n### 内存布局\n- 元数据（`struct bpf_queue_stack`）与元素存储区（`elements[]`）连续分配\n- 元素存储区按 8 字节对齐，确保跨架构兼容性\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/bpf.h>`：BPF 核心定义\n  - `<linux/list.h>`：内核链表操作\n  - `<linux/slab.h>`：内存分配接口\n  - `<linux/btf_ids.h>`：BTF（BPF Type Format）类型信息\n  - `\"percpu_freelist.h\"`：每 CPU 空闲列表（虽包含但未直接使用）\n\n- **内核子系统**：\n  - **BPF 子系统**：作为 BPF 映射类型注册到核心框架\n  - **内存管理子系统**：通过 `bpf_map_area_alloc/free` 分配内存\n  - **锁机制**：依赖内核自旋锁实现并发控制\n\n- **BTF 支持**：\n  - 通过 `BTF_ID_LIST_SINGLE` 声明类型信息，支持运行时类型检查\n\n## 5. 使用场景\n\n- **eBPF 程序与用户空间通信**：\n  - 用户空间通过 `bpf()` 系统调用操作队列/栈\n  - eBPF 程序通过 `bpf_map_push/pop/peek_elem()` 辅助函数访问\n\n- **高性能数据传递**：\n  - 适用于需要顺序处理数据的场景（如事件日志、采样数据）\n  - 队列用于生产者-消费者模型\n  - 栈用于需要后进先出语义的场景（如调用栈跟踪）\n\n- **资源受限环境**：\n  - 固定大小缓冲区避免动态内存分配开销\n  - 无锁设计（仅自旋锁）保证低延迟\n\n- **典型应用**：\n  - 网络数据包采样（队列）\n  - 函数调用跟踪（栈）\n  - 性能监控事件缓冲（队列）",
      "similarity": 0.47635722160339355,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/queue_stack_maps.c",
          "start_line": 30,
          "end_line": 132,
          "content": [
            "static bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)",
            "{",
            "\treturn qs->head == qs->tail;",
            "}",
            "static bool queue_stack_map_is_full(struct bpf_queue_stack *qs)",
            "{",
            "\tu32 head = qs->head + 1;",
            "",
            "\tif (unlikely(head >= qs->size))",
            "\t\thead = 0;",
            "",
            "\treturn head == qs->tail;",
            "}",
            "static int queue_stack_map_alloc_check(union bpf_attr *attr)",
            "{",
            "\t/* check sanity of attributes */",
            "\tif (attr->max_entries == 0 || attr->key_size != 0 ||",
            "\t    attr->value_size == 0 ||",
            "\t    attr->map_flags & ~QUEUE_STACK_CREATE_FLAG_MASK ||",
            "\t    !bpf_map_flags_access_ok(attr->map_flags))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (attr->value_size > KMALLOC_MAX_SIZE)",
            "\t\t/* if value_size is bigger, the user space won't be able to",
            "\t\t * access the elements.",
            "\t\t */",
            "\t\treturn -E2BIG;",
            "",
            "\treturn 0;",
            "}",
            "static void queue_stack_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);",
            "",
            "\tbpf_map_area_free(qs);",
            "}",
            "static long __queue_map_get(struct bpf_map *map, void *value, bool delete)",
            "{",
            "\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);",
            "\tunsigned long flags;",
            "\tint err = 0;",
            "\tvoid *ptr;",
            "",
            "\tif (in_nmi()) {",
            "\t\tif (!raw_spin_trylock_irqsave(&qs->lock, flags))",
            "\t\t\treturn -EBUSY;",
            "\t} else {",
            "\t\traw_spin_lock_irqsave(&qs->lock, flags);",
            "\t}",
            "",
            "\tif (queue_stack_map_is_empty(qs)) {",
            "\t\tmemset(value, 0, qs->map.value_size);",
            "\t\terr = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tptr = &qs->elements[qs->tail * qs->map.value_size];",
            "\tmemcpy(value, ptr, qs->map.value_size);",
            "",
            "\tif (delete) {",
            "\t\tif (unlikely(++qs->tail >= qs->size))",
            "\t\t\tqs->tail = 0;",
            "\t}",
            "",
            "out:",
            "\traw_spin_unlock_irqrestore(&qs->lock, flags);",
            "\treturn err;",
            "}",
            "static long __stack_map_get(struct bpf_map *map, void *value, bool delete)",
            "{",
            "\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);",
            "\tunsigned long flags;",
            "\tint err = 0;",
            "\tvoid *ptr;",
            "\tu32 index;",
            "",
            "\tif (in_nmi()) {",
            "\t\tif (!raw_spin_trylock_irqsave(&qs->lock, flags))",
            "\t\t\treturn -EBUSY;",
            "\t} else {",
            "\t\traw_spin_lock_irqsave(&qs->lock, flags);",
            "\t}",
            "",
            "\tif (queue_stack_map_is_empty(qs)) {",
            "\t\tmemset(value, 0, qs->map.value_size);",
            "\t\terr = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tindex = qs->head - 1;",
            "\tif (unlikely(index >= qs->size))",
            "\t\tindex = qs->size - 1;",
            "",
            "\tptr = &qs->elements[index * qs->map.value_size];",
            "\tmemcpy(value, ptr, qs->map.value_size);",
            "",
            "\tif (delete)",
            "\t\tqs->head = index;",
            "",
            "out:",
            "\traw_spin_unlock_irqrestore(&qs->lock, flags);",
            "\treturn err;",
            "}"
          ],
          "function_name": "queue_stack_map_is_empty, queue_stack_map_is_full, queue_stack_map_alloc_check, queue_stack_map_free, __queue_map_get, __stack_map_get",
          "description": "实现队列/栈的基本操作逻辑，包括空/满判断、内存分配校验、元素获取与删除操作，采用自旋锁保护临界区并处理NMI场景下的中断安全获取",
          "similarity": 0.45307257771492004
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/queue_stack_maps.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * queue_stack_maps.c: BPF queue and stack maps",
            " *",
            " * Copyright (c) 2018 Politecnico di Torino",
            " */",
            "#include <linux/bpf.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/btf_ids.h>",
            "#include \"percpu_freelist.h\"",
            "",
            "#define QUEUE_STACK_CREATE_FLAG_MASK \\",
            "\t(BPF_F_NUMA_NODE | BPF_F_ACCESS_MASK)",
            "",
            "struct bpf_queue_stack {",
            "\tstruct bpf_map map;",
            "\traw_spinlock_t lock;",
            "\tu32 head, tail;",
            "\tu32 size; /* max_entries + 1 */",
            "",
            "\tchar elements[] __aligned(8);",
            "};",
            "",
            "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)",
            "{",
            "\treturn container_of(map, struct bpf_queue_stack, map);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了BPF队列/栈映射的数据结构，包含环形缓冲区所需的head/tail指针、最大容量及元素存储区域，通过container_of宏关联到bpf_map结构",
          "similarity": 0.4392731785774231
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/queue_stack_maps.c",
          "start_line": 165,
          "end_line": 245,
          "content": [
            "static long queue_map_peek_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn __queue_map_get(map, value, false);",
            "}",
            "static long stack_map_peek_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn __stack_map_get(map, value, false);",
            "}",
            "static long queue_map_pop_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn __queue_map_get(map, value, true);",
            "}",
            "static long stack_map_pop_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn __stack_map_get(map, value, true);",
            "}",
            "static long queue_stack_map_push_elem(struct bpf_map *map, void *value,",
            "\t\t\t\t      u64 flags)",
            "{",
            "\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);",
            "\tunsigned long irq_flags;",
            "\tint err = 0;",
            "\tvoid *dst;",
            "",
            "\t/* BPF_EXIST is used to force making room for a new element in case the",
            "\t * map is full",
            "\t */",
            "\tbool replace = (flags & BPF_EXIST);",
            "",
            "\t/* Check supported flags for queue and stack maps */",
            "\tif (flags & BPF_NOEXIST || flags > BPF_EXIST)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (in_nmi()) {",
            "\t\tif (!raw_spin_trylock_irqsave(&qs->lock, irq_flags))",
            "\t\t\treturn -EBUSY;",
            "\t} else {",
            "\t\traw_spin_lock_irqsave(&qs->lock, irq_flags);",
            "\t}",
            "",
            "\tif (queue_stack_map_is_full(qs)) {",
            "\t\tif (!replace) {",
            "\t\t\terr = -E2BIG;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\t/* advance tail pointer to overwrite oldest element */",
            "\t\tif (unlikely(++qs->tail >= qs->size))",
            "\t\t\tqs->tail = 0;",
            "\t}",
            "",
            "\tdst = &qs->elements[qs->head * qs->map.value_size];",
            "\tmemcpy(dst, value, qs->map.value_size);",
            "",
            "\tif (unlikely(++qs->head >= qs->size))",
            "\t\tqs->head = 0;",
            "",
            "out:",
            "\traw_spin_unlock_irqrestore(&qs->lock, irq_flags);",
            "\treturn err;",
            "}",
            "static long queue_stack_map_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t\tvoid *value, u64 flags)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static long queue_stack_map_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int queue_stack_map_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\t\tvoid *next_key)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static u64 queue_stack_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tu64 usage = sizeof(struct bpf_queue_stack);",
            "",
            "\tusage += ((u64)map->max_entries + 1) * map->value_size;",
            "\treturn usage;",
            "}"
          ],
          "function_name": "queue_map_peek_elem, stack_map_peek_elem, queue_map_pop_elem, stack_map_pop_elem, queue_stack_map_push_elem, queue_stack_map_update_elem, queue_stack_map_delete_elem, queue_stack_map_get_next_key, queue_stack_map_mem_usage",
          "description": "封装队列/栈的标准接口方法，提供Peek/Pop操作实现，包含元素推入逻辑及内存使用统计，明确声明不支持Update/Delete操作以保持数据结构语义一致性",
          "similarity": 0.43659937381744385
        }
      ]
    }
  ]
}