{
  "query": "BIOS与引导加载程序交互机制",
  "timestamp": "2025-12-26 00:34:23",
  "retrieved_files": [
    {
      "source_file": "kernel/module/kmod.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:03:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\kmod.c`\n\n---\n\n# `module/kmod.c` 技术文档\n\n## 1. 文件概述\n\n`kmod.c` 是 Linux 内核中负责**内核模块自动加载机制**的核心实现文件。它提供了从内核空间调用用户态 `modprobe` 工具以动态加载缺失模块的能力。该机制允许内核在运行时按需加载驱动或功能模块（例如当设备被探测到但对应驱动未加载时），从而提升系统灵活性和资源利用率。\n\n该文件实现了 `__request_module()` 接口，作为内核其他子系统请求模块加载的统一入口，并通过 `call_usermodehelper` 机制安全地调用用户空间的 `/sbin/modprobe`（或由 `modprobe_path` 指定的路径）。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__request_module(bool wait, const char *fmt, ...)`**  \n  内核模块加载的主入口函数。支持格式化模块名，可选择同步（`wait=true`）或异步（`wait=false`）执行。返回值为 0 表示成功启动加载过程，负值为错误码，正值为 `modprobe` 的退出码。\n\n- **`call_modprobe(char *orig_module_name, int wait)`**  \n  封装对用户态 `modprobe` 的调用。构造命令行参数（`modprobe -q -- <module_name>`）和环境变量，通过 `call_usermodehelper_setup()` 和 `call_usermodehelper_exec()` 执行。\n\n- **`free_modprobe_argv(struct subprocess_info *info)`**  \n  释放 `call_modprobe` 中分配的参数内存，作为 `call_usermodehelper_setup()` 的清理回调。\n\n### 关键数据结构与变量\n\n- **`modprobe_path[KMOD_PATH_LEN]`**  \n  全局可配置的 `modprobe` 可执行文件路径，默认为 `CONFIG_MODPROBE_PATH`（通常为 `\"/sbin/modprobe\"`），可通过 `/proc/sys/kernel/modprobe` 修改。\n\n- **`kmod_concurrent_max`**  \n  信号量，限制同时进行的模块加载请求数量，上限为 `MAX_KMOD_CONCURRENT`（50），防止资源耗尽或递归依赖导致的死锁。\n\n- **`MAX_KMOD_ALL_BUSY_TIMEOUT`**  \n  超时阈值（5 秒），当所有并发槽位被占用超过此时间，判定为可能的模块依赖循环，拒绝新请求。\n\n## 3. 关键实现\n\n### 并发控制与死锁预防\n\n- 使用 `down_timeout(&kmod_concurrent_max, ...)` 限制并发加载线程数，避免系统资源（如内存、进程数）被大量 `modprobe` 进程耗尽。\n- 若所有 50 个并发槽位在 5 秒内未释放，内核判定为**模块依赖循环**（如 A 依赖 B，B 又依赖 A），主动拒绝请求并打印警告，防止无限递归。\n- 通过 `WARN_ON_ONCE(wait && current_is_async())` 禁止在异步上下文（如 workqueue、async 任务）中执行**同步**模块加载，避免与 `async_synchronize_full()` 产生死锁。\n\n### 安全与资源管理\n\n- 调用 `security_kernel_module_request()` 执行 LSM（Linux Security Module）安全检查，允许安全模块（如 SELinux、AppArmor）控制模块加载权限。\n- 使用 `UMH_KILLABLE` 标志使 `modprobe` 进程可被信号中断，提升系统响应性。\n- 通过 `kmod_dup_request_exists_wait()` 检测重复的模块加载请求，避免对同一模块发起多次 `modprobe` 调用，提升效率。\n\n### 用户态交互\n\n- 构造标准环境变量（`HOME=/`, `PATH=/sbin:/usr/sbin:/bin:/usr/bin`）确保 `modprobe` 在受限但可用的环境中执行。\n- 使用 `call_usermodehelper` 子系统创建内核线程执行用户态程序，该机制处理了凭证（cred）、文件描述符、挂载命名空间等上下文隔离。\n\n### 跟踪与调试\n\n- 集成 `trace_module_request` 跟踪点，可通过 ftrace 或 perf 监控模块加载请求。\n- 调用 `kmod_dup_request_announce()` 记录重复请求或失败事件，便于诊断。\n\n## 4. 依赖关系\n\n- **内核子系统依赖**：\n  - `call_usermodehelper`（`<linux/unistd.h>`, `<linux/binfmts.h>`）：用于执行用户态 helper 程序。\n  - LSM 框架（`<linux/security.h>`）：执行模块加载安全策略。\n  - 内存管理（`<linux/slab.h>`）：动态分配参数字符串。\n  - 同步原语（`<linux/semaphore.h>` via `DEFINE_SEMAPHORE`）：并发控制。\n  - 调试与跟踪（`<trace/events/module.h>`）：性能分析支持。\n- **配置依赖**：\n  - `CONFIG_MODULES`：模块支持必须启用。\n  - `CONFIG_MODPROBE_PATH`：定义默认 `modprobe` 路径。\n- **内部依赖**：\n  - `internal.h`：包含模块子系统内部声明（如 `kmod_dup_request_exists_wait`）。\n\n## 5. 使用场景\n\n- **设备驱动自动加载**：当内核探测到新硬件（如 USB 设备）但无对应驱动时，通过 `__request_module(\"usb:vXXXXpXXXX...\")` 触发驱动加载。\n- **文件系统按需挂载**：挂载未知文件系统类型时（如 `mount -t foo`），内核调用 `__request_module(\"fs-foo\")` 加载文件系统模块。\n- **网络协议模块加载**：使用未加载的网络协议（如 `AF_PHONET`）时自动加载对应模块。\n- **内核特性动态扩展**：如加密算法、压缩模块等在首次使用时按需加载。\n- **内核模块依赖解析**：当模块 A 依赖模块 B，而 B 未加载时，`insmod`/`modprobe` 内部会通过此机制加载 B。\n\n> **注意**：成功返回仅表示 `modprobe` 已启动，不保证模块最终加载成功。调用者必须验证所需功能是否可用。",
      "similarity": 0.562974214553833,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/module/kmod.c",
          "start_line": 1,
          "end_line": 65,
          "content": [
            "/*",
            " * kmod - the kernel module loader",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/cred.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/resource.h>",
            "#include <linux/notifier.h>",
            "#include <linux/suspend.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/async.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include <trace/events/module.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * Assuming:",
            " *",
            " * threads = div64_u64((u64) totalram_pages * (u64) PAGE_SIZE,",
            " *\t\t       (u64) THREAD_SIZE * 8UL);",
            " *",
            " * If you need less than 50 threads would mean we're dealing with systems",
            " * smaller than 3200 pages. This assumes you are capable of having ~13M memory,",
            " * and this would only be an upper limit, after which the OOM killer would take",
            " * effect. Systems like these are very unlikely if modules are enabled.",
            " */",
            "#define MAX_KMOD_CONCURRENT 50",
            "static DEFINE_SEMAPHORE(kmod_concurrent_max, MAX_KMOD_CONCURRENT);",
            "",
            "/*",
            " * This is a restriction on having *all* MAX_KMOD_CONCURRENT threads",
            " * running at the same time without returning. When this happens we",
            " * believe you've somehow ended up with a recursive module dependency",
            " * creating a loop.",
            " *",
            " * We have no option but to fail.",
            " *",
            " * Userspace should proactively try to detect and prevent these.",
            " */",
            "#define MAX_KMOD_ALL_BUSY_TIMEOUT 5",
            "",
            "/*",
            "\tmodprobe_path is set via /proc/sys.",
            "*/",
            "char modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;",
            ""
          ],
          "function_name": null,
          "description": "定义模块加载并发控制相关常量与全局变量，包含模块加载所需头文件并初始化modprobe路径",
          "similarity": 0.5519756078720093
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/kmod.c",
          "start_line": 66,
          "end_line": 161,
          "content": [
            "static void free_modprobe_argv(struct subprocess_info *info)",
            "{",
            "\tkfree(info->argv[3]); /* check call_modprobe() */",
            "\tkfree(info->argv);",
            "}",
            "static int call_modprobe(char *orig_module_name, int wait)",
            "{",
            "\tstruct subprocess_info *info;",
            "\tstatic char *envp[] = {",
            "\t\t\"HOME=/\",",
            "\t\t\"TERM=linux\",",
            "\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",",
            "\t\tNULL",
            "\t};",
            "\tchar *module_name;",
            "\tint ret;",
            "",
            "\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);",
            "\tif (!argv)",
            "\t\tgoto out;",
            "",
            "\tmodule_name = kstrdup(orig_module_name, GFP_KERNEL);",
            "\tif (!module_name)",
            "\t\tgoto free_argv;",
            "",
            "\targv[0] = modprobe_path;",
            "\targv[1] = \"-q\";",
            "\targv[2] = \"--\";",
            "\targv[3] = module_name;\t/* check free_modprobe_argv() */",
            "\targv[4] = NULL;",
            "",
            "\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,",
            "\t\t\t\t\t NULL, free_modprobe_argv, NULL);",
            "\tif (!info)",
            "\t\tgoto free_module_name;",
            "",
            "\tret = call_usermodehelper_exec(info, wait | UMH_KILLABLE);",
            "\tkmod_dup_request_announce(orig_module_name, ret);",
            "\treturn ret;",
            "",
            "free_module_name:",
            "\tkfree(module_name);",
            "free_argv:",
            "\tkfree(argv);",
            "out:",
            "\tkmod_dup_request_announce(orig_module_name, -ENOMEM);",
            "\treturn -ENOMEM;",
            "}",
            "int __request_module(bool wait, const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "\tchar module_name[MODULE_NAME_LEN];",
            "\tint ret, dup_ret;",
            "",
            "\t/*",
            "\t * We don't allow synchronous module loading from async.  Module",
            "\t * init may invoke async_synchronize_full() which will end up",
            "\t * waiting for this task which already is waiting for the module",
            "\t * loading to complete, leading to a deadlock.",
            "\t */",
            "\tWARN_ON_ONCE(wait && current_is_async());",
            "",
            "\tif (!modprobe_path[0])",
            "\t\treturn -ENOENT;",
            "",
            "\tva_start(args, fmt);",
            "\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);",
            "\tva_end(args);",
            "\tif (ret >= MODULE_NAME_LEN)",
            "\t\treturn -ENAMETOOLONG;",
            "",
            "\tret = security_kernel_module_request(module_name);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = down_timeout(&kmod_concurrent_max, MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);",
            "\tif (ret) {",
            "\t\tpr_warn_ratelimited(\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\",",
            "\t\t\t\t    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ttrace_module_request(module_name, wait, _RET_IP_);",
            "",
            "\tif (kmod_dup_request_exists_wait(module_name, wait, &dup_ret)) {",
            "\t\tret = dup_ret;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);",
            "",
            "out:",
            "\tup(&kmod_concurrent_max);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "free_modprobe_argv, call_modprobe, __request_module",
          "description": "实现模块请求处理逻辑，通过调用modprobe执行模块加载，包含参数构造、子进程管理及并发控制机制",
          "similarity": 0.5330276489257812
        }
      ]
    },
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.5561305284500122,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.5373345017433167
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.4374675750732422
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_boot.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:13:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_boot.c`\n\n---\n\n# `trace_boot.c` 技术文档\n\n## 1. 文件概述\n\n`trace_boot.c` 是 Linux 内核中用于在系统启动阶段（boot-time）配置和启用 ftrace 跟踪功能的核心实现文件。该文件通过解析内核启动参数中由 BootConfig（`/bootconfig`）提供的配置项，动态设置跟踪实例（`trace_array`）的各项参数，包括跟踪选项、事件启用、缓冲区大小、CPU 掩码、时钟源等，并支持高级功能如 kprobe 事件、合成事件（synthetic events）和直方图触发器（histogram triggers）。其目标是在内核初始化早期阶段完成跟踪系统的自动化配置，无需用户空间干预。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`trace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)`**  \n  解析 BootConfig 节点中与跟踪实例相关的通用配置项，设置 `tracing_on`、`trace_clock`、`buffer_size`、`cpumask` 和通用 ftrace 选项。\n\n- **`trace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)`**（需 `CONFIG_EVENT_TRACING`）  \n  根据 BootConfig 中的 `events` 数组启用指定的静态跟踪事件。\n\n- **`trace_boot_add_kprobe_event(struct xbc_node *node, const char *event)`**（需 `CONFIG_KPROBE_EVENTS`）  \n  动态创建并注册 kprobe 类型的动态事件，支持在启动时注入探针。\n\n- **`trace_boot_add_synth_event(struct xbc_node *node, const char *event)`**（需 `CONFIG_SYNTH_EVENTS`）  \n  根据 BootConfig 定义创建合成事件（synthetic event），用于组合多个事件数据。\n\n- **`trace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)`**（需 `CONFIG_HIST_TRIGGERS`）  \n  将 BootConfig 中的直方图触发器配置转换为内核可识别的命令字符串，用于设置复杂的事件触发逻辑（如 `onmax`、`onmatch` 等）。\n\n- **辅助函数（仅 `CONFIG_HIST_TRIGGERS` 下）**：\n  - `append_printf()`：安全地向缓冲区追加格式化字符串。\n  - `append_str_nospace()`：追加去除空白字符的字符串。\n  - `trace_boot_hist_add_array()`：处理直方图的数组型参数（如 `keys`、`values`）。\n  - `trace_boot_hist_add_one_handler()`：构建单个触发动作（如 `onmax(...).save(...)`）。\n  - `trace_boot_hist_add_handlers()`：处理多个或默认的触发器实例。\n\n## 3. 关键实现\n\n- **BootConfig 集成**：  \n  所有配置均通过 `xbc_node` 接口从 BootConfig 树中读取。使用 `xbc_node_find_value()` 获取标量值，`xbc_node_for_each_array_value()` 遍历数组，`xbc_node_for_each_subkey()` 处理嵌套结构。\n\n- **动态事件创建**：  \n  利用 `dynevent_cmd` 框架（`kprobe_event_cmd_init` / `synth_event_cmd_init`）构建动态事件命令，通过 `*_gen_cmd_start/end` 完成注册，确保与运行时动态事件机制一致。\n\n- **直方图触发器语法转换**：  \n  将 BootConfig 的树形结构（如 `hist { keys = ...; onmax.0 { var=...; save=... } }`）转换为内核直方图子系统所需的线性命令字符串（如 `\"hist:keys=...:onmax(var).save(...)\"`），通过递归解析子节点和参数完成。\n\n- **错误处理与日志**：  \n  所有配置项解析失败时均通过 `pr_err()` 输出错误信息，但不中断整体启动流程，保证系统稳定性。\n\n- **内存安全**：  \n  使用固定大小缓冲区（`MAX_BUF_LEN = 256`）并配合 `strscpy()` 防止溢出；CPU 掩码操作使用 `alloc_cpumask_var()` 动态分配。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/bootconfig.h>`：BootConfig 解析接口。\n  - `<linux/ftrace.h>`、`<linux/trace.h>`、`\"trace.h\"`：ftrace 核心 API 和内部结构。\n  - `<linux/trace_events.h>`：事件跟踪基础设施。\n\n- **条件编译依赖**：\n  - `CONFIG_EVENT_TRACING`：启用静态事件跟踪。\n  - `CONFIG_KPROBE_EVENTS`：支持 kprobe 动态事件。\n  - `CONFIG_SYNTH_EVENTS`：支持合成事件。\n  - `CONFIG_HIST_TRIGGERS`：支持直方图触发器。\n\n- **内核子系统交互**：\n  - **ftrace 子系统**：通过 `trace_set_options()`、`tracer_tracing_on/off()` 等接口控制跟踪行为。\n  - **Ring Buffer**：通过 `tracing_resize_ring_buffer()` 调整缓冲区。\n  - **CPU 热插拔**：通过 `tracing_set_cpumask()` 设置参与跟踪的 CPU 集合。\n\n## 5. 使用场景\n\n- **内核启动调试**：  \n  在系统早期初始化阶段自动启用特定跟踪事件（如调度器、内存分配），捕获传统用户空间工具无法观测的启动路径。\n\n- **自动化性能分析**：  \n  通过预置 BootConfig 配置，在每次启动时自动收集性能数据（如函数调用图、事件延迟），用于持续集成或基准测试。\n\n- **动态探针部署**：  \n  在无用户空间介入的情况下，于启动时注入 kprobe 探针监控关键函数，适用于嵌入式或安全受限环境。\n\n- **复杂事件关联**：  \n  利用合成事件和直方图触发器，在启动阶段实现跨事件的数据聚合与条件触发（如“当某函数延迟超过阈值时保存上下文”）。\n\n- **资源受限系统优化**：  \n  通过 `buffer_size` 和 `cpumask` 精确控制跟踪开销，避免在低内存或单核系统上影响启动性能。",
      "similarity": 0.5485028028488159,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace_boot.c",
            " * Tracing kernel boot-time",
            " */",
            "",
            "#define pr_fmt(fmt)\t\"trace_boot: \" fmt",
            "",
            "#include <linux/bootconfig.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace.h>",
            "#include <linux/trace_events.h>",
            "",
            "#include \"trace.h\"",
            "",
            "#define MAX_BUF_LEN 256",
            ""
          ],
          "function_name": null,
          "description": "定义trace_boot模块的基础头文件和宏，为跟踪启动时间相关功能提供基础设施。",
          "similarity": 0.5306603908538818
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 591,
          "end_line": 663,
          "content": [
            "static void __init",
            "trace_boot_enable_tracer(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tconst char *p;",
            "",
            "\ttrace_boot_set_ftrace_filter(tr, node);",
            "",
            "\tp = xbc_node_find_value(node, \"tracer\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (tracing_set_tracer(tr, p) < 0)",
            "\t\t\tpr_err(\"Failed to set given tracer: %s\\n\", p);",
            "\t}",
            "",
            "\t/* Since tracer can free snapshot buffer, allocate snapshot here.*/",
            "\tif (xbc_node_find_value(node, \"alloc_snapshot\", NULL)) {",
            "\t\tif (tracing_alloc_snapshot_instance(tr) < 0)",
            "\t\t\tpr_err(\"Failed to allocate snapshot buffer\\n\");",
            "\t}",
            "}",
            "static void __init",
            "trace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\ttrace_boot_set_instance_options(tr, node);",
            "\ttrace_boot_init_events(tr, node);",
            "\ttrace_boot_enable_events(tr, node);",
            "\ttrace_boot_enable_tracer(tr, node);",
            "}",
            "static void __init",
            "trace_boot_init_instances(struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *inode;",
            "\tstruct trace_array *tr;",
            "\tconst char *p;",
            "",
            "\tnode = xbc_node_find_subkey(node, \"instance\");",
            "\tif (!node)",
            "\t\treturn;",
            "",
            "\txbc_node_for_each_subkey(node, inode) {",
            "\t\tp = xbc_node_get_data(inode);",
            "\t\tif (!p || *p == '\\0')",
            "\t\t\tcontinue;",
            "",
            "\t\ttr = trace_array_get_by_name(p, NULL);",
            "\t\tif (!tr) {",
            "\t\t\tpr_err(\"Failed to get trace instance %s\\n\", p);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\ttrace_boot_init_one_instance(tr, inode);",
            "\t\ttrace_array_put(tr);",
            "\t}",
            "}",
            "static int __init trace_boot_init(void)",
            "{",
            "\tstruct xbc_node *trace_node;",
            "\tstruct trace_array *tr;",
            "",
            "\ttrace_node = xbc_find_node(\"ftrace\");",
            "\tif (!trace_node)",
            "\t\treturn 0;",
            "",
            "\ttr = top_trace_array();",
            "\tif (!tr)",
            "\t\treturn 0;",
            "",
            "\t/* Global trace array is also one instance */",
            "\ttrace_boot_init_one_instance(tr, trace_node);",
            "\ttrace_boot_init_instances(trace_node);",
            "",
            "\tdisable_tracing_selftest(\"running boot-time tracing\");",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "trace_boot_enable_tracer, trace_boot_init_one_instance, trace_boot_init_instances, trace_boot_init",
          "description": "该代码段实现了Boot-Time Tracing的初始化逻辑，核心功能是根据Xenon Boot Config（xbc）节点动态创建和配置跟踪实例。  \n`trace_boot_enable_tracer`启用指定tracer并分配快照缓冲区，`trace_boot_init_one_instance`初始化单个跟踪实例的事件与选项，`trace_boot_init_instances`遍历xbc节点注册多实例跟踪配置。  \n上下文不完整，缺少xbc_node结构体定义及部分辅助函数实现。",
          "similarity": 0.4947693347930908
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 138,
          "end_line": 247,
          "content": [
            "static int __init",
            "trace_boot_add_synth_event(struct xbc_node *node, const char *event)",
            "{",
            "\tstruct dynevent_cmd cmd;",
            "\tstruct xbc_node *anode;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tconst char *p;",
            "\tint ret;",
            "",
            "\tsynth_event_cmd_init(&cmd, buf, MAX_BUF_LEN);",
            "",
            "\tret = synth_event_gen_cmd_start(&cmd, event, NULL);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\txbc_node_for_each_array_value(node, \"fields\", anode, p) {",
            "\t\tret = synth_event_add_field_str(&cmd, p);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tret = synth_event_gen_cmd_end(&cmd);",
            "\tif (ret < 0)",
            "\t\tpr_err(\"Failed to add synthetic event: %s\\n\", buf);",
            "",
            "\treturn ret;",
            "}",
            "static inline int __init",
            "trace_boot_add_synth_event(struct xbc_node *node, const char *event)",
            "{",
            "\tpr_err(\"Synthetic event is not supported.\\n\");",
            "\treturn -ENOTSUPP;",
            "}",
            "static int __init",
            "trace_boot_hist_add_array(struct xbc_node *hnode, char **bufp,",
            "\t\t\t  char *end, const char *key)",
            "{",
            "\tstruct xbc_node *anode;",
            "\tconst char *p;",
            "\tchar sep;",
            "",
            "\tp = xbc_node_find_value(hnode, key, &anode);",
            "\tif (p) {",
            "\t\tif (!anode) {",
            "\t\t\tpr_err(\"hist.%s requires value(s).\\n\", key);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tappend_printf(bufp, end, \":%s\", key);",
            "\t\tsep = '=';",
            "\t\txbc_array_for_each_value(anode, p) {",
            "\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);",
            "\t\t\tif (sep == '=')",
            "\t\t\t\tsep = ',';",
            "\t\t}",
            "\t} else",
            "\t\treturn -ENOENT;",
            "",
            "\treturn 0;",
            "}",
            "static int __init",
            "trace_boot_hist_add_one_handler(struct xbc_node *hnode, char **bufp,",
            "\t\t\t\tchar *end, const char *handler,",
            "\t\t\t\tconst char *param)",
            "{",
            "\tstruct xbc_node *knode, *anode;",
            "\tconst char *p;",
            "\tchar sep;",
            "",
            "\t/* Compose 'handler' parameter */",
            "\tp = xbc_node_find_value(hnode, param, NULL);",
            "\tif (!p) {",
            "\t\tpr_err(\"hist.%s requires '%s' option.\\n\",",
            "\t\t       xbc_node_get_data(hnode), param);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\tappend_printf(bufp, end, \":%s(%s)\", handler, p);",
            "",
            "\t/* Compose 'action' parameter */",
            "\tknode = xbc_node_find_subkey(hnode, \"trace\");",
            "\tif (!knode)",
            "\t\tknode = xbc_node_find_subkey(hnode, \"save\");",
            "",
            "\tif (knode) {",
            "\t\tanode = xbc_node_get_child(knode);",
            "\t\tif (!anode || !xbc_node_is_value(anode)) {",
            "\t\t\tpr_err(\"hist.%s.%s requires value(s).\\n\",",
            "\t\t\t       xbc_node_get_data(hnode),",
            "\t\t\t       xbc_node_get_data(knode));",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tappend_printf(bufp, end, \".%s\", xbc_node_get_data(knode));",
            "\t\tsep = '(';",
            "\t\txbc_array_for_each_value(anode, p) {",
            "\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);",
            "\t\t\tif (sep == '(')",
            "\t\t\t\tsep = ',';",
            "\t\t}",
            "\t\tappend_printf(bufp, end, \")\");",
            "\t} else if (xbc_node_find_subkey(hnode, \"snapshot\")) {",
            "\t\tappend_printf(bufp, end, \".snapshot()\");",
            "\t} else {",
            "\t\tpr_err(\"hist.%s requires an action.\\n\",",
            "\t\t       xbc_node_get_data(hnode));",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "trace_boot_add_synth_event, trace_boot_add_synth_event, trace_boot_hist_add_array, trace_boot_hist_add_one_handler",
          "description": "处理合成事件字段添加与直方图参数构建，通过遍历节点值生成相应跟踪命令参数。",
          "similarity": 0.4461425542831421
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 297,
          "end_line": 427,
          "content": [
            "static int __init",
            "trace_boot_hist_add_handlers(struct xbc_node *hnode, char **bufp,",
            "\t\t\t     char *end, const char *param)",
            "{",
            "\tstruct xbc_node *node;",
            "\tconst char *p, *handler;",
            "\tint ret = 0;",
            "",
            "\thandler = xbc_node_get_data(hnode);",
            "",
            "\txbc_node_for_each_subkey(hnode, node) {",
            "\t\tp = xbc_node_get_data(node);",
            "\t\tif (!isdigit(p[0]))",
            "\t\t\tcontinue;",
            "\t\t/* All digit started node should be instances. */",
            "\t\tret = trace_boot_hist_add_one_handler(node, bufp, end, handler, param);",
            "\t\tif (ret < 0)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\tif (xbc_node_find_subkey(hnode, param))",
            "\t\tret = trace_boot_hist_add_one_handler(hnode, bufp, end, handler, param);",
            "",
            "\treturn ret;",
            "}",
            "static int __init",
            "trace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)",
            "{",
            "\tstruct xbc_node *node, *knode;",
            "\tchar *end = buf + size;",
            "\tconst char *p;",
            "\tint ret = 0;",
            "",
            "\tappend_printf(&buf, end, \"hist\");",
            "",
            "\tret = trace_boot_hist_add_array(hnode, &buf, end, \"keys\");",
            "\tif (ret < 0) {",
            "\t\tif (ret == -ENOENT)",
            "\t\t\tpr_err(\"hist requires keys.\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tret = trace_boot_hist_add_array(hnode, &buf, end, \"values\");",
            "\tif (ret == -EINVAL)",
            "\t\treturn ret;",
            "\tret = trace_boot_hist_add_array(hnode, &buf, end, \"sort\");",
            "\tif (ret == -EINVAL)",
            "\t\treturn ret;",
            "",
            "\tp = xbc_node_find_value(hnode, \"size\", NULL);",
            "\tif (p)",
            "\t\tappend_printf(&buf, end, \":size=%s\", p);",
            "",
            "\tp = xbc_node_find_value(hnode, \"name\", NULL);",
            "\tif (p)",
            "\t\tappend_printf(&buf, end, \":name=%s\", p);",
            "",
            "\tnode = xbc_node_find_subkey(hnode, \"var\");",
            "\tif (node) {",
            "\t\txbc_node_for_each_key_value(node, knode, p) {",
            "\t\t\t/* Expression must not include spaces. */",
            "\t\t\tappend_printf(&buf, end, \":%s=\",",
            "\t\t\t\t      xbc_node_get_data(knode));",
            "\t\t\tappend_str_nospace(&buf, end, p);",
            "\t\t}",
            "\t}",
            "",
            "\t/* Histogram control attributes (mutual exclusive) */",
            "\tif (xbc_node_find_value(hnode, \"pause\", NULL))",
            "\t\tappend_printf(&buf, end, \":pause\");",
            "\telse if (xbc_node_find_value(hnode, \"continue\", NULL))",
            "\t\tappend_printf(&buf, end, \":continue\");",
            "\telse if (xbc_node_find_value(hnode, \"clear\", NULL))",
            "\t\tappend_printf(&buf, end, \":clear\");",
            "",
            "\t/* Histogram handler and actions */",
            "\tnode = xbc_node_find_subkey(hnode, \"onmax\");",
            "\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)",
            "\t\treturn -EINVAL;",
            "\tnode = xbc_node_find_subkey(hnode, \"onchange\");",
            "\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)",
            "\t\treturn -EINVAL;",
            "\tnode = xbc_node_find_subkey(hnode, \"onmatch\");",
            "\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"event\") < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tp = xbc_node_find_value(hnode, \"filter\", NULL);",
            "\tif (p)",
            "\t\tappend_printf(&buf, end, \" if %s\", p);",
            "",
            "\tif (buf == end) {",
            "\t\tpr_err(\"hist exceeds the max command length.\\n\");",
            "\t\treturn -E2BIG;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void __init",
            "trace_boot_init_histograms(struct trace_event_file *file,",
            "\t\t\t   struct xbc_node *hnode, char *buf, size_t size)",
            "{",
            "\tstruct xbc_node *node;",
            "\tconst char *p;",
            "\tchar *tmp;",
            "",
            "\txbc_node_for_each_subkey(hnode, node) {",
            "\t\tp = xbc_node_get_data(node);",
            "\t\tif (!isdigit(p[0]))",
            "\t\t\tcontinue;",
            "\t\t/* All digit started node should be instances. */",
            "\t\tif (trace_boot_compose_hist_cmd(node, buf, size) == 0) {",
            "\t\t\ttmp = kstrdup(buf, GFP_KERNEL);",
            "\t\t\tif (!tmp)",
            "\t\t\t\treturn;",
            "\t\t\tif (trigger_process_regex(file, buf) < 0)",
            "\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);",
            "\t\t\tkfree(tmp);",
            "\t\t}",
            "\t}",
            "",
            "\tif (xbc_node_find_subkey(hnode, \"keys\")) {",
            "\t\tif (trace_boot_compose_hist_cmd(hnode, buf, size) == 0) {",
            "\t\t\ttmp = kstrdup(buf, GFP_KERNEL);",
            "\t\t\tif (!tmp)",
            "\t\t\t\treturn;",
            "\t\t\tif (trigger_process_regex(file, buf) < 0)",
            "\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);",
            "\t\t\tkfree(tmp);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "trace_boot_hist_add_handlers, trace_boot_compose_hist_cmd, trace_boot_init_histograms",
          "description": "构建直方图控制命令字符串，组合关键字、值、排序等参数，并处理事件触发动作配置。",
          "similarity": 0.44320300221443176
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_boot.c",
          "start_line": 24,
          "end_line": 129,
          "content": [
            "static void __init",
            "trace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *anode;",
            "\tconst char *p;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tunsigned long v = 0;",
            "",
            "\t/* Common ftrace options */",
            "\txbc_node_for_each_array_value(node, \"options\", anode, p) {",
            "\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0) {",
            "\t\t\tpr_err(\"String is too long: %s\\n\", p);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (trace_set_options(tr, buf) < 0)",
            "\t\t\tpr_err(\"Failed to set option: %s\\n\", buf);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"tracing_on\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (kstrtoul(p, 10, &v))",
            "\t\t\tpr_err(\"Failed to set tracing on: %s\\n\", p);",
            "\t\tif (v)",
            "\t\t\ttracer_tracing_on(tr);",
            "\t\telse",
            "\t\t\ttracer_tracing_off(tr);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"trace_clock\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tif (tracing_set_clock(tr, p) < 0)",
            "\t\t\tpr_err(\"Failed to set trace clock: %s\\n\", p);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"buffer_size\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tv = memparse(p, NULL);",
            "\t\tif (v < PAGE_SIZE)",
            "\t\t\tpr_err(\"Buffer size is too small: %s\\n\", p);",
            "\t\tif (tracing_resize_ring_buffer(tr, v, RING_BUFFER_ALL_CPUS) < 0)",
            "\t\t\tpr_err(\"Failed to resize trace buffer to %s\\n\", p);",
            "\t}",
            "",
            "\tp = xbc_node_find_value(node, \"cpumask\", NULL);",
            "\tif (p && *p != '\\0') {",
            "\t\tcpumask_var_t new_mask;",
            "",
            "\t\tif (alloc_cpumask_var(&new_mask, GFP_KERNEL)) {",
            "\t\t\tif (cpumask_parse(p, new_mask) < 0 ||",
            "\t\t\t    tracing_set_cpumask(tr, new_mask) < 0)",
            "\t\t\t\tpr_err(\"Failed to set new CPU mask %s\\n\", p);",
            "\t\t\tfree_cpumask_var(new_mask);",
            "\t\t}",
            "\t}",
            "}",
            "static void __init",
            "trace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)",
            "{",
            "\tstruct xbc_node *anode;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tconst char *p;",
            "",
            "\txbc_node_for_each_array_value(node, \"events\", anode, p) {",
            "\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0) {",
            "\t\t\tpr_err(\"String is too long: %s\\n\", p);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (ftrace_set_clr_event(tr, buf, 1) < 0)",
            "\t\t\tpr_err(\"Failed to enable event: %s\\n\", p);",
            "\t}",
            "}",
            "static int __init",
            "trace_boot_add_kprobe_event(struct xbc_node *node, const char *event)",
            "{",
            "\tstruct dynevent_cmd cmd;",
            "\tstruct xbc_node *anode;",
            "\tchar buf[MAX_BUF_LEN];",
            "\tconst char *val;",
            "\tint ret = 0;",
            "",
            "\txbc_node_for_each_array_value(node, \"probes\", anode, val) {",
            "\t\tkprobe_event_cmd_init(&cmd, buf, MAX_BUF_LEN);",
            "",
            "\t\tret = kprobe_event_gen_cmd_start(&cmd, event, val);",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"Failed to generate probe: %s\\n\", buf);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tret = kprobe_event_gen_cmd_end(&cmd);",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"Failed to add probe: %s\\n\", buf);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static inline int __init",
            "trace_boot_add_kprobe_event(struct xbc_node *node, const char *event)",
            "{",
            "\tpr_err(\"Kprobe event is not supported.\\n\");",
            "\treturn -ENOTSUPP;",
            "}"
          ],
          "function_name": "trace_boot_set_instance_options, trace_boot_enable_events, trace_boot_add_kprobe_event, trace_boot_add_kprobe_event",
          "description": "实现初始化跟踪实例选项设置、事件启用、kprobe事件添加等功能，包含重复定义的函数导致潜在冲突。",
          "similarity": 0.4377713203430176
        }
      ]
    }
  ]
}