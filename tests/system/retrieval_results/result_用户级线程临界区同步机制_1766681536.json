{
  "query": "用户级线程临界区同步机制",
  "timestamp": "2025-12-26 00:52:16",
  "retrieved_files": [
    {
      "source_file": "kernel/user-return-notifier.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user-return-notifier.c`\n\n---\n\n# user-return-notifier.c 技术文档\n\n## 1. 文件概述\n\n`user-return-notifier.c` 实现了用户态返回通知机制（User Return Notifier），允许内核子系统在当前 CPU 即将从内核态返回用户态时注册回调函数。该机制用于在特定内核事件（如安全策略更新、性能监控等）发生后，延迟执行某些操作，直到进程真正返回用户空间，从而避免在关键内核路径中引入额外开销或竞态条件。\n\n## 2. 核心功能\n\n### 数据结构\n- `return_notifier_list`：每 CPU 变量（per-CPU variable），类型为 `struct hlist_head`，用于存储当前 CPU 上注册的所有用户返回通知器链表。\n\n### 主要函数\n- `user_return_notifier_register(struct user_return_notifier *urn)`  \n  注册一个用户返回通知器，将其加入当前 CPU 的通知链表，并设置当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `user_return_notifier_unregister(struct user_return_notifier *urn)`  \n  从当前 CPU 的通知链表中移除指定的通知器；若链表变为空，则清除当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `fire_user_return_notifiers(void)`  \n  遍历并调用当前 CPU 上所有已注册的通知器的回调函数 `on_user_return`，通常在内核即将返回用户态前由调度或系统调用退出路径调用。\n\n## 3. 关键实现\n\n- **每 CPU 链表设计**：使用 `DEFINE_PER_CPU` 定义 per-CPU 的哈希链表头，确保每个 CPU 维护独立的通知器列表，避免跨 CPU 同步开销。\n  \n- **原子上下文要求**：注册和注销操作必须在原子上下文中执行（不可睡眠），因为它们操作 per-CPU 数据且可能在中断或调度关键路径中被调用。\n\n- **线程标志位控制**：通过设置/清除任务结构体中的 `TIF_USER_RETURN_NOTIFY` 标志位（`TIF_` 表示 Thread Info Flag），通知内核在返回用户态前需调用 `fire_user_return_notifiers()`。\n\n- **安全遍历与调用**：`fire_user_return_notifiers()` 使用 `hlist_for_each_entry_safe` 安全遍历链表，允许回调函数在执行过程中注销自身或其他通知器。\n\n- **CPU 变量访问**：使用 `get_cpu_var()` 和 `put_cpu_var()` 保证在访问 per-CPU 变量期间禁止内核抢占，确保操作的 CPU 一致性。\n\n## 4. 依赖关系\n\n- `<linux/user-return-notifier.h>`：定义 `struct user_return_notifier` 及相关 API。\n- `<linux/percpu.h>`：提供 per-CPU 变量支持。\n- `<linux/sched.h>`：提供任务结构体（`current`）和线程标志位操作函数（如 `set_tsk_thread_flag`）。\n- `<linux/export.h>`：导出符号供其他内核模块使用（`EXPORT_SYMBOL_GPL`）。\n- 依赖架构相关的线程信息标志（`TIF_USER_RETURN_NOTIFY`）在 `thread_info` 中的定义。\n\n## 5. 使用场景\n\n- **安全模块**：如 SELinux 或 LSM 框架在策略更新后，需通知用户态进程重新评估权限，可延迟到返回用户态时触发。\n- **性能监控与跟踪**：在系统调用或中断处理完成后，于返回用户态前收集上下文切换或延迟信息。\n- **延迟工作调度**：某些不适合在中断或原子上下文中执行的操作，可注册为用户返回通知，在安全的用户态切换点执行。\n- **虚拟化与容器**：在客户机或容器退出内核时同步状态或注入事件。\n\n该机制是内核“延迟通知”模式的典型实现，确保高优先级内核路径不受回调逻辑影响，同时保证通知在正确的执行上下文中触发。",
      "similarity": 0.6266368627548218,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 15,
          "end_line": 36,
          "content": [
            "void user_return_notifier_register(struct user_return_notifier *urn)",
            "{",
            "\tset_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "\thlist_add_head(&urn->link, this_cpu_ptr(&return_notifier_list));",
            "}",
            "void user_return_notifier_unregister(struct user_return_notifier *urn)",
            "{",
            "\thlist_del(&urn->link);",
            "\tif (hlist_empty(this_cpu_ptr(&return_notifier_list)))",
            "\t\tclear_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "}",
            "void fire_user_return_notifiers(void)",
            "{",
            "\tstruct user_return_notifier *urn;",
            "\tstruct hlist_node *tmp2;",
            "\tstruct hlist_head *head;",
            "",
            "\thead = &get_cpu_var(return_notifier_list);",
            "\thlist_for_each_entry_safe(urn, tmp2, head, link)",
            "\t\turn->on_user_return(urn);",
            "\tput_cpu_var(return_notifier_list);",
            "}"
          ],
          "function_name": "user_return_notifier_register, user_return_notifier_unregister, fire_user_return_notifiers",
          "description": "实现用户态返回通知器的注册/注销与触发机制。register 函数将通知器链接到当前 CPU 的链表并设置 TIF_USER_RETURN_NOTIFY 标志；unregister 函数移除节点并清理标志；fire 函数遍历当前 CPU 链表执行所有注册的 on_user_return 回调函数。",
          "similarity": 0.5289086103439331
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "",
            "static DEFINE_PER_CPU(struct hlist_head, return_notifier_list);",
            "",
            "/*",
            " * Request a notification when the current cpu returns to userspace.  Must be",
            " * called in atomic context.  The notifier will also be called in atomic",
            " * context.",
            " */"
          ],
          "function_name": null,
          "description": "定义了一个 per-CPU 的哈希列表头结构 return_notifier_list，用于存储用户态返回通知器注册项。该结构通过 DEFINE_PER_CPU 宏为每个 CPU 创建独立的链表头，支持多 CPU 环境下的并发访问。",
          "similarity": 0.4624670147895813
        }
      ]
    },
    {
      "source_file": "kernel/rseq.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:54:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rseq.c`\n\n---\n\n# rseq.c 技术文档\n\n## 文件概述\n\n`rseq.c` 实现了 Linux 内核对 **Restartable Sequences（可重启序列）** 系统调用的支持。该机制允许用户空间程序在不使用重量级原子操作的前提下，高效地执行与调度器抢占、信号投递和 CPU 迁移相关的**伪原子操作**，特别适用于高性能的每 CPU（per-CPU）数据结构操作。该文件负责管理用户空间注册的 `struct rseq` TLS（线程局部存储）区域，并在任务被抢占、迁移或收到信号时，安全地中止并重定向用户空间执行流。\n\n## 核心功能\n\n### 主要数据结构\n- `struct rseq`：用户空间注册的 TLS 结构，包含 `cpu_id_start`、`cpu_id`、`node_id`、`mm_cid` 和 `rseq_cs`（critical section 描述符指针）等字段。\n- `struct rseq_cs`：用户空间关键区（critical section）的描述结构，包含起始地址、提交地址、中止地址和标志位。\n\n### 主要函数\n- `rseq_update_cpu_node_id(struct task_struct *t)`  \n  更新任务的 `rseq` TLS 区域中的 CPU ID、NUMA 节点 ID 和内存上下文 ID（mm_cid），用于反映当前执行上下文。\n  \n- `rseq_reset_rseq_cpu_node_id(struct task_struct *t)`  \n  将任务的 `rseq` TLS 区域重置为初始状态（`cpu_id` 设为 `RSEQ_CPU_ID_UNINITIALIZED`）。\n\n- `rseq_get_rseq_cs_ptr_val(struct rseq __user *rseq, u64 *rseq_cs)`  \n  从用户空间 `rseq` 结构中安全读取 `rseq_cs` 指针值。\n\n- `rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)`  \n  若 `rseq_cs` 指针有效，则从用户空间复制并验证 `struct rseq_cs` 内容（代码片段未完整展示）。\n\n- `rseq_validate_ro_fields(struct task_struct *t)`（仅在 `CONFIG_DEBUG_RSEQ` 下启用）  \n  验证用户空间 `rseq` 结构中应为只读的字段是否与内核副本一致，防止用户空间篡改。\n\n### 宏定义\n- `rseq_unsafe_put_user()`：在写入用户空间 `rseq` 字段的同时，同步更新内核中的副本（调试模式下），确保状态一致性。\n- `RSEQ_CS_NO_RESTART_FLAGS`：定义关键区中禁止因抢占、信号或迁移而重启的标志组合。\n\n## 关键实现\n\n### 可重启序列执行模型\n用户空间关键区执行流程如下：\n1. 将关键区描述符地址写入 TLS 的 `rseq->rseq_cs`；\n2. 比较 `cpu_id_start` 与当前 `cpu_id`，不一致则跳转至 `abort_ip`；\n3. 执行关键区操作；\n4. 成功提交后继续正常执行。\n\n若在步骤 1–3 之间发生**抢占、CPU 迁移或信号投递**，内核会：\n- 清空 `rseq->rseq_cs`（设为 NULL）；\n- 将用户空间返回地址设置为 `abort_ip`；\n- 恢复执行时跳转至中止处理逻辑。\n\n### 安全访问与调试支持\n- 使用 `user_read_access_begin/end()` 和 `user_write_access_begin/end()` 确保对用户空间内存的安全访问。\n- 在 `CONFIG_DEBUG_RSEQ` 模式下，内核维护 `rseq` 字段的内核副本，并在每次更新前后校验用户空间只读字段的一致性，防止恶意或错误的用户空间修改。\n- 通过 `trace_rseq_update()` 提供跟踪点，便于性能分析和调试。\n\n### 兼容性处理\n- 原始 `rseq` 结构大小为 32 字节（`ORIG_RSEQ_SIZE`）；\n- 对于扩展字段（如 `mm_cid`），仅在 `t->rseq_len > ORIG_RSEQ_SIZE` 时才进行更新或重置，确保向后兼容。\n\n## 依赖关系\n\n- **调度子系统**：依赖 `raw_smp_processor_id()` 获取当前 CPU，`task_mm_cid()` 获取内存上下文 ID。\n- **内存管理**：使用 `cpu_to_node()` 获取 NUMA 节点信息。\n- **用户空间访问**：依赖 `uaccess.h` 提供的安全用户空间读写原语（如 `unsafe_get_user`/`unsafe_put_user`）。\n- **跟踪系统**：通过 `trace/events/rseq.h` 集成内核跟踪基础设施。\n- **架构支持**：依赖 `asm/ptrace.h` 处理信号/抢占后的用户空间返回地址重定向（完整实现位于架构相关代码中）。\n\n## 使用场景\n\n- **高性能 per-CPU 操作**：如无锁计数器、每 CPU 队列等，避免传统原子操作或锁的开销。\n- **实时/低延迟应用**：减少因内核同步原语引入的延迟抖动。\n- **用户空间调度器/运行时**：如 Go、Java 虚拟机等，用于实现高效的线程本地状态管理。\n- **系统调用 `sys_rseq()`**：由用户空间通过 `rseq(2)` 系统调用注册或注销 `rseq` TLS 区域，本文件提供内核侧支持逻辑（注册/注销时调用 `rseq_update_cpu_node_id` 或 `rseq_reset_rseq_cpu_node_id`）。",
      "similarity": 0.609731137752533,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/rseq.c",
          "start_line": 355,
          "end_line": 442,
          "content": [
            "static int clear_rseq_cs(struct rseq __user *rseq)",
            "{",
            "\t/*",
            "\t * The rseq_cs field is set to NULL on preemption or signal",
            "\t * delivery on top of rseq assembly block, as well as on top",
            "\t * of code outside of the rseq assembly block. This performs",
            "\t * a lazy clear of the rseq_cs field.",
            "\t *",
            "\t * Set rseq_cs to NULL.",
            "\t */",
            "#ifdef CONFIG_64BIT",
            "\treturn put_user(0UL, &rseq->rseq_cs);",
            "#else",
            "\tif (clear_user(&rseq->rseq_cs, sizeof(rseq->rseq_cs)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "#endif",
            "}",
            "static bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)",
            "{",
            "\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;",
            "}",
            "static int rseq_ip_fixup(struct pt_regs *regs)",
            "{",
            "\tunsigned long ip = instruction_pointer(regs);",
            "\tstruct task_struct *t = current;",
            "\tstruct rseq_cs rseq_cs;",
            "\tint ret;",
            "",
            "\tret = rseq_get_rseq_cs(t, &rseq_cs);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/*",
            "\t * Handle potentially not being within a critical section.",
            "\t * If not nested over a rseq critical section, restart is useless.",
            "\t * Clear the rseq_cs pointer and return.",
            "\t */",
            "\tif (!in_rseq_cs(ip, &rseq_cs))",
            "\t\treturn clear_rseq_cs(t->rseq);",
            "\tret = rseq_need_restart(t, rseq_cs.flags);",
            "\tif (ret <= 0)",
            "\t\treturn ret;",
            "\tret = clear_rseq_cs(t->rseq);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,",
            "\t\t\t    rseq_cs.abort_ip);",
            "\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);",
            "\treturn 0;",
            "}",
            "void __rseq_handle_notify_resume(struct ksignal *ksig, struct pt_regs *regs)",
            "{",
            "\tstruct task_struct *t = current;",
            "\tint ret, sig;",
            "",
            "\tif (unlikely(t->flags & PF_EXITING))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * regs is NULL if and only if the caller is in a syscall path.  Skip",
            "\t * fixup and leave rseq_cs as is so that rseq_sycall() will detect and",
            "\t * kill a misbehaving userspace on debug kernels.",
            "\t */",
            "\tif (regs) {",
            "\t\tret = rseq_ip_fixup(regs);",
            "\t\tif (unlikely(ret < 0))",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (unlikely(rseq_update_cpu_node_id(t)))",
            "\t\tgoto error;",
            "\treturn;",
            "",
            "error:",
            "\tsig = ksig ? ksig->sig : 0;",
            "\tforce_sigsegv(sig);",
            "}",
            "void rseq_syscall(struct pt_regs *regs)",
            "{",
            "\tunsigned long ip = instruction_pointer(regs);",
            "\tstruct task_struct *t = current;",
            "\tstruct rseq_cs rseq_cs;",
            "",
            "\tif (!t->rseq)",
            "\t\treturn;",
            "\tif (rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))",
            "\t\tforce_sig(SIGSEGV);",
            "}"
          ],
          "function_name": "clear_rseq_cs, in_rseq_cs, rseq_ip_fixup, __rseq_handle_notify_resume, rseq_syscall",
          "description": "实现rseq异常处理流程，包括临界区IP修复、通知恢复处理和系统调用保护，确保rseq执行的安全边界。",
          "similarity": 0.6079542636871338
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/rseq.c",
          "start_line": 35,
          "end_line": 159,
          "content": [
            "static int rseq_validate_ro_fields(struct task_struct *t)",
            "{",
            "\tstatic DEFINE_RATELIMIT_STATE(_rs,",
            "\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,",
            "\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
            "\tu32 cpu_id_start, cpu_id, node_id, mm_cid;",
            "\tstruct rseq __user *rseq = t->rseq;",
            "",
            "\t/*",
            "\t * Validate fields which are required to be read-only by",
            "\t * user-space.",
            "\t */",
            "\tif (!user_read_access_begin(rseq, t->rseq_len))",
            "\t\tgoto efault;",
            "\tunsafe_get_user(cpu_id_start, &rseq->cpu_id_start, efault_end);",
            "\tunsafe_get_user(cpu_id, &rseq->cpu_id, efault_end);",
            "\tunsafe_get_user(node_id, &rseq->node_id, efault_end);",
            "\tunsafe_get_user(mm_cid, &rseq->mm_cid, efault_end);",
            "\tuser_read_access_end();",
            "",
            "\tif ((cpu_id_start != rseq_kernel_fields(t)->cpu_id_start ||",
            "\t    cpu_id != rseq_kernel_fields(t)->cpu_id ||",
            "\t    node_id != rseq_kernel_fields(t)->node_id ||",
            "\t    mm_cid != rseq_kernel_fields(t)->mm_cid) && __ratelimit(&_rs)) {",
            "",
            "\t\tpr_warn(\"Detected rseq corruption for pid: %d, name: %s\\n\"",
            "\t\t\t\"\\tcpu_id_start: %u ?= %u\\n\"",
            "\t\t\t\"\\tcpu_id:       %u ?= %u\\n\"",
            "\t\t\t\"\\tnode_id:      %u ?= %u\\n\"",
            "\t\t\t\"\\tmm_cid:       %u ?= %u\\n\",",
            "\t\t\tt->pid, t->comm,",
            "\t\t\tcpu_id_start, rseq_kernel_fields(t)->cpu_id_start,",
            "\t\t\tcpu_id, rseq_kernel_fields(t)->cpu_id,",
            "\t\t\tnode_id, rseq_kernel_fields(t)->node_id,",
            "\t\t\tmm_cid, rseq_kernel_fields(t)->mm_cid);",
            "\t}",
            "",
            "\t/* For now, only print a console warning on mismatch. */",
            "\treturn 0;",
            "",
            "efault_end:",
            "\tuser_read_access_end();",
            "efault:",
            "\treturn -EFAULT;",
            "}",
            "static int rseq_validate_ro_fields(struct task_struct *t)",
            "{",
            "\treturn 0;",
            "}",
            "static int rseq_update_cpu_node_id(struct task_struct *t)",
            "{",
            "\tstruct rseq __user *rseq = t->rseq;",
            "\tu32 cpu_id = raw_smp_processor_id();",
            "\tu32 node_id = cpu_to_node(cpu_id);",
            "\tu32 mm_cid = task_mm_cid(t);",
            "",
            "\t/*",
            "\t * Validate read-only rseq fields.",
            "\t */",
            "\tif (rseq_validate_ro_fields(t))",
            "\t\tgoto efault;",
            "\tWARN_ON_ONCE((int) mm_cid < 0);",
            "\tif (!user_write_access_begin(rseq, t->rseq_len))",
            "\t\tgoto efault;",
            "",
            "\trseq_unsafe_put_user(t, cpu_id, cpu_id_start, efault_end);",
            "\trseq_unsafe_put_user(t, cpu_id, cpu_id, efault_end);",
            "\trseq_unsafe_put_user(t, node_id, node_id, efault_end);",
            "\trseq_unsafe_put_user(t, mm_cid, mm_cid, efault_end);",
            "",
            "\t/*",
            "\t * Additional feature fields added after ORIG_RSEQ_SIZE",
            "\t * need to be conditionally updated only if",
            "\t * t->rseq_len != ORIG_RSEQ_SIZE.",
            "\t */",
            "\tuser_write_access_end();",
            "\ttrace_rseq_update(t);",
            "\treturn 0;",
            "",
            "efault_end:",
            "\tuser_write_access_end();",
            "efault:",
            "\treturn -EFAULT;",
            "}",
            "static int rseq_reset_rseq_cpu_node_id(struct task_struct *t)",
            "{",
            "\tstruct rseq __user *rseq = t->rseq;",
            "\tu32 cpu_id_start = 0, cpu_id = RSEQ_CPU_ID_UNINITIALIZED, node_id = 0,",
            "\t    mm_cid = 0;",
            "",
            "\t/*",
            "\t * Validate read-only rseq fields.",
            "\t */",
            "\tif (rseq_validate_ro_fields(t))",
            "\t\tgoto efault;",
            "",
            "\tif (!user_write_access_begin(rseq, t->rseq_len))",
            "\t\tgoto efault;",
            "",
            "\t/*",
            "\t * Reset all fields to their initial state.",
            "\t *",
            "\t * All fields have an initial state of 0 except cpu_id which is set to",
            "\t * RSEQ_CPU_ID_UNINITIALIZED, so that any user coming in after",
            "\t * unregistration can figure out that rseq needs to be registered",
            "\t * again.",
            "\t */",
            "\trseq_unsafe_put_user(t, cpu_id_start, cpu_id_start, efault_end);",
            "\trseq_unsafe_put_user(t, cpu_id, cpu_id, efault_end);",
            "\trseq_unsafe_put_user(t, node_id, node_id, efault_end);",
            "\trseq_unsafe_put_user(t, mm_cid, mm_cid, efault_end);",
            "",
            "\t/*",
            "\t * Additional feature fields added after ORIG_RSEQ_SIZE",
            "\t * need to be conditionally reset only if",
            "\t * t->rseq_len != ORIG_RSEQ_SIZE.",
            "\t */",
            "\tuser_write_access_end();",
            "\treturn 0;",
            "",
            "efault_end:",
            "\tuser_write_access_end();",
            "efault:",
            "\treturn -EFAULT;",
            "}"
          ],
          "function_name": "rseq_validate_ro_fields, rseq_validate_ro_fields, rseq_update_cpu_node_id, rseq_reset_rseq_cpu_node_id",
          "description": "实现rseq只读字段校验、CPU/节点ID更新及重置功能，检测并防止用户态对只读字段的篡改。",
          "similarity": 0.5690575838088989
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/rseq.c",
          "start_line": 242,
          "end_line": 346,
          "content": [
            "static int rseq_get_rseq_cs_ptr_val(struct rseq __user *rseq, u64 *rseq_cs)",
            "{",
            "\tif (!rseq_cs)",
            "\t\treturn -EFAULT;",
            "",
            "#ifdef CONFIG_64BIT",
            "\tif (get_user(*rseq_cs, &rseq->rseq_cs))",
            "\t\treturn -EFAULT;",
            "#else",
            "\tif (copy_from_user(rseq_cs, &rseq->rseq_cs, sizeof(*rseq_cs)))",
            "\t\treturn -EFAULT;",
            "#endif",
            "",
            "\treturn 0;",
            "}",
            "static int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)",
            "{",
            "\tstruct rseq_cs __user *urseq_cs;",
            "\tu64 ptr;",
            "\tu32 __user *usig;",
            "\tu32 sig;",
            "\tint ret;",
            "",
            "\tret = rseq_get_rseq_cs_ptr_val(t->rseq, &ptr);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* If the rseq_cs pointer is NULL, return a cleared struct rseq_cs. */",
            "\tif (!ptr) {",
            "\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));",
            "\t\treturn 0;",
            "\t}",
            "\t/* Check that the pointer value fits in the user-space process space. */",
            "\tif (ptr >= TASK_SIZE)",
            "\t\treturn -EINVAL;",
            "\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;",
            "\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (rseq_cs->start_ip >= TASK_SIZE ||",
            "\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||",
            "\t    rseq_cs->abort_ip >= TASK_SIZE ||",
            "\t    rseq_cs->version > 0)",
            "\t\treturn -EINVAL;",
            "\t/* Check for overflow. */",
            "\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)",
            "\t\treturn -EINVAL;",
            "\t/* Ensure that abort_ip is not in the critical section. */",
            "\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)",
            "\t\treturn -EINVAL;",
            "",
            "\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));",
            "\tret = get_user(sig, usig);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (current->rseq_sig != sig) {",
            "\t\tprintk_ratelimited(KERN_WARNING",
            "\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",",
            "\t\t\tsig, current->rseq_sig, current->pid, usig);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool rseq_warn_flags(const char *str, u32 flags)",
            "{",
            "\tu32 test_flags;",
            "",
            "\tif (!flags)",
            "\t\treturn false;",
            "\ttest_flags = flags & RSEQ_CS_NO_RESTART_FLAGS;",
            "\tif (test_flags)",
            "\t\tpr_warn_once(\"Deprecated flags (%u) in %s ABI structure\", test_flags, str);",
            "\ttest_flags = flags & ~RSEQ_CS_NO_RESTART_FLAGS;",
            "\tif (test_flags)",
            "\t\tpr_warn_once(\"Unknown flags (%u) in %s ABI structure\", test_flags, str);",
            "\treturn true;",
            "}",
            "static int rseq_need_restart(struct task_struct *t, u32 cs_flags)",
            "{",
            "\tu32 flags, event_mask;",
            "\tint ret;",
            "",
            "\tif (rseq_warn_flags(\"rseq_cs\", cs_flags))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Get thread flags. */",
            "\tret = get_user(flags, &t->rseq->flags);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (rseq_warn_flags(\"rseq\", flags))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Load and clear event mask atomically with respect to",
            "\t * scheduler preemption.",
            "\t */",
            "\tpreempt_disable();",
            "\tevent_mask = t->rseq_event_mask;",
            "\tt->rseq_event_mask = 0;",
            "\tpreempt_enable();",
            "",
            "\treturn !!event_mask;",
            "}"
          ],
          "function_name": "rseq_get_rseq_cs_ptr_val, rseq_get_rseq_cs, rseq_warn_flags, rseq_need_restart",
          "description": "提供rseq_cs指针解析、结构体验证、标志位检查及是否需要重启的判定逻辑，保障安全性和兼容性。",
          "similarity": 0.5161912441253662
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/rseq.c",
          "start_line": 1,
          "end_line": 34,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Restartable sequences system call",
            " *",
            " * Copyright (C) 2015, Google, Inc.,",
            " * Paul Turner <pjt@google.com> and Andrew Hunter <ahh@google.com>",
            " * Copyright (C) 2015-2018, EfficiOS Inc.,",
            " * Mathieu Desnoyers <mathieu.desnoyers@efficios.com>",
            " */",
            "",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/rseq.h>",
            "#include <linux/types.h>",
            "#include <linux/ratelimit.h>",
            "#include <asm/ptrace.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/rseq.h>",
            "",
            "/* The original rseq structure size (including padding) is 32 bytes. */",
            "#define ORIG_RSEQ_SIZE\t\t32",
            "",
            "#define RSEQ_CS_NO_RESTART_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT | \\",
            "\t\t\t\t  RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL | \\",
            "\t\t\t\t  RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE)",
            "",
            "#ifdef CONFIG_DEBUG_RSEQ",
            "static struct rseq *rseq_kernel_fields(struct task_struct *t)",
            "{",
            "\treturn (struct rseq *) t->rseq_fields;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义rseq内核字段访问函数，用于获取当前任务的rseq结构体指针，供后续验证和操作使用。",
          "similarity": 0.48158755898475647
        }
      ]
    },
    {
      "source_file": "kernel/rcu/sync.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:44:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\sync.c`\n\n---\n\n# rcu/sync.c 技术文档\n\n## 文件概述\n\n`rcu/sync.c` 实现了一个基于 RCU（Read-Copy-Update）机制的轻量级读写同步基础设施，称为 `rcu_sync`。该机制允许写者（更新者）在需要时强制所有读者切换到“慢路径”（slow path），并在更新完成后经过一个 RCU 宽限期（grace period）后，允许读者重新使用“快路径”（fast path）。该设计特别适用于需要频繁但短暂地禁用读者快路径的场景，避免了传统读写锁的开销，同时利用 RCU 的无锁读取特性提升性能。\n\n## 核心功能\n\n### 数据结构\n\n- **`struct rcu_sync`**  \n  核心同步控制结构，包含以下关键字段：\n  - `gp_state`：当前同步状态（`GP_IDLE`, `GP_ENTER`, `GP_PASSED`, `GP_EXIT`, `GP_REPLAY`）\n  - `gp_count`：嵌套的 `rcu_sync_enter()` 调用计数\n  - `cb_head`：用于 RCU 回调的 `rcu_head`\n  - `gp_wait`：等待队列，用于阻塞等待状态转换完成\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `rcu_sync_init()` | 初始化 `rcu_sync` 结构体 |\n| `rcu_sync_enter_start()` | 预激活同步机制，使 `rcu_sync_is_idle()` 返回 false，且后续 enter/exit 成为 NO-OP |\n| `rcu_sync_enter()` | 强制读者进入慢路径，确保后续读者不会使用快路径 |\n| `rcu_sync_exit()` | 标记更新结束，安排在宽限期后恢复读者快路径 |\n| `rcu_sync_dtor()` | 销毁 `rcu_sync` 结构，确保所有 RCU 回调已完成 |\n| `rcu_sync_func()` | RCU 回调函数，根据当前状态推进状态机 |\n\n## 关键实现\n\n### 状态机设计\n\n`rcu_sync` 使用五种状态实现高效的状态转换：\n\n- **`GP_IDLE`**：初始状态，读者可使用快路径。\n- **`GP_ENTER`**：正在进入同步状态，需等待宽限期。\n- **`GP_PASSED`**：宽限期已过，读者已全部进入慢路径。\n- **`GP_EXIT`**：正在退出同步，需等待另一个宽限期以恢复快路径。\n- **`GP_REPLAY`**：在退出过程中又有新的 enter/exit 对发生，需重新调度回调。\n\n### 嵌套与优化\n\n- **嵌套支持**：通过 `gp_count` 支持 `rcu_sync_enter()` 的嵌套调用。只有当 `gp_count` 从 1 递减到 0 时，才触发退出流程。\n- **宽限期合并**：连续的 `enter/exit` 调用可避免多次等待宽限期。例如：\n  - 若在 `GP_PASSED` 状态下调用 `exit`，直接进入 `GP_EXIT` 并调度回调。\n  - 若在回调执行前再次调用 `enter/exit`，状态转为 `GP_REPLAY`，并在回调中重新调度，避免冗余宽限期。\n- **快速路径优化**：首次 `enter` 时若处于 `GP_IDLE`，直接调用 `synchronize_rcu()` 而非异步 `call_rcu()`，可利用 `rcu_expedited` 或 `rcu_blocking_is_gp()` 加速。\n\n### 同步与唤醒\n\n- 写者调用 `rcu_sync_enter()` 后，若非首次进入，会阻塞在 `wait_event()`，直到状态变为 `GP_PASSED` 或更高。\n- `rcu_sync_func()` 在宽限期后执行，根据 `gp_count` 和当前状态决定是唤醒等待者、重调度回调，还是恢复到 `GP_IDLE`。\n\n## 依赖关系\n\n- **`<linux/rcu_sync.h>`**：定义 `struct rcu_sync` 及相关 API。\n- **`<linux/sched.h>`**：提供 `wait_event()`、`wake_up_locked()` 等调度和等待队列原语。\n- **RCU 子系统**：\n  - `call_rcu_hurry()` / `call_rcu()`：用于注册宽限期后的回调。\n  - `synchronize_rcu()`：用于同步等待宽限期。\n  - `rcu_barrier()`：在析构时确保所有回调完成。\n- **自旋锁**：使用 `spin_lock_irqsave()` 保护状态和计数器，确保中断上下文安全。\n\n## 使用场景\n\n- **文件系统元数据更新**：如 overlayfs、btrfs 等在修改共享元数据结构时，临时禁止读者使用快路径缓存。\n- **动态配置更新**：内核模块或子系统在热更新全局配置时，确保读者看到一致状态。\n- **轻量级写者同步**：适用于写操作较少但需高效读者路径的场景，避免传统 rwlock 的读者竞争开销。\n- **替代 `synchronize_rcu()` 的批量操作**：当多个连续更新可合并为一次宽限期等待时，提升性能。",
      "similarity": 0.6069072484970093,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/rcu/sync.c",
          "start_line": 21,
          "end_line": 136,
          "content": [
            "void rcu_sync_init(struct rcu_sync *rsp)",
            "{",
            "\tmemset(rsp, 0, sizeof(*rsp));",
            "\tinit_waitqueue_head(&rsp->gp_wait);",
            "}",
            "void rcu_sync_enter_start(struct rcu_sync *rsp)",
            "{",
            "\trsp->gp_count++;",
            "\trsp->gp_state = GP_PASSED;",
            "}",
            "static void rcu_sync_call(struct rcu_sync *rsp)",
            "{",
            "\tcall_rcu_hurry(&rsp->cb_head, rcu_sync_func);",
            "}",
            "static void rcu_sync_func(struct rcu_head *rhp)",
            "{",
            "\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);",
            "\tunsigned long flags;",
            "",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);",
            "",
            "\tspin_lock_irqsave(&rsp->rss_lock, flags);",
            "\tif (rsp->gp_count) {",
            "\t\t/*",
            "\t\t * We're at least a GP after the GP_IDLE->GP_ENTER transition.",
            "\t\t */",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_PASSED);",
            "\t\twake_up_locked(&rsp->gp_wait);",
            "\t} else if (rsp->gp_state == GP_REPLAY) {",
            "\t\t/*",
            "\t\t * A new rcu_sync_exit() has happened; requeue the callback to",
            "\t\t * catch a later GP.",
            "\t\t */",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);",
            "\t\trcu_sync_call(rsp);",
            "\t} else {",
            "\t\t/*",
            "\t\t * We're at least a GP after the last rcu_sync_exit(); everybody",
            "\t\t * will now have observed the write side critical section.",
            "\t\t * Let 'em rip!",
            "\t\t */",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_IDLE);",
            "\t}",
            "\tspin_unlock_irqrestore(&rsp->rss_lock, flags);",
            "}",
            "void rcu_sync_enter(struct rcu_sync *rsp)",
            "{",
            "\tint gp_state;",
            "",
            "\tspin_lock_irq(&rsp->rss_lock);",
            "\tgp_state = rsp->gp_state;",
            "\tif (gp_state == GP_IDLE) {",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_ENTER);",
            "\t\tWARN_ON_ONCE(rsp->gp_count);",
            "\t\t/*",
            "\t\t * Note that we could simply do rcu_sync_call(rsp) here and",
            "\t\t * avoid the \"if (gp_state == GP_IDLE)\" block below.",
            "\t\t *",
            "\t\t * However, synchronize_rcu() can be faster if rcu_expedited",
            "\t\t * or rcu_blocking_is_gp() is true.",
            "\t\t *",
            "\t\t * Another reason is that we can't wait for rcu callback if",
            "\t\t * we are called at early boot time but this shouldn't happen.",
            "\t\t */",
            "\t}",
            "\trsp->gp_count++;",
            "\tspin_unlock_irq(&rsp->rss_lock);",
            "",
            "\tif (gp_state == GP_IDLE) {",
            "\t\t/*",
            "\t\t * See the comment above, this simply does the \"synchronous\"",
            "\t\t * call_rcu(rcu_sync_func) which does GP_ENTER -> GP_PASSED.",
            "\t\t */",
            "\t\tsynchronize_rcu();",
            "\t\trcu_sync_func(&rsp->cb_head);",
            "\t\t/* Not really needed, wait_event() would see GP_PASSED. */",
            "\t\treturn;",
            "\t}",
            "",
            "\twait_event(rsp->gp_wait, READ_ONCE(rsp->gp_state) >= GP_PASSED);",
            "}",
            "void rcu_sync_exit(struct rcu_sync *rsp)",
            "{",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count) == 0);",
            "",
            "\tspin_lock_irq(&rsp->rss_lock);",
            "\tif (!--rsp->gp_count) {",
            "\t\tif (rsp->gp_state == GP_PASSED) {",
            "\t\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);",
            "\t\t\trcu_sync_call(rsp);",
            "\t\t} else if (rsp->gp_state == GP_EXIT) {",
            "\t\t\tWRITE_ONCE(rsp->gp_state, GP_REPLAY);",
            "\t\t}",
            "\t}",
            "\tspin_unlock_irq(&rsp->rss_lock);",
            "}",
            "void rcu_sync_dtor(struct rcu_sync *rsp)",
            "{",
            "\tint gp_state;",
            "",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count));",
            "\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);",
            "",
            "\tspin_lock_irq(&rsp->rss_lock);",
            "\tif (rsp->gp_state == GP_REPLAY)",
            "\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);",
            "\tgp_state = rsp->gp_state;",
            "\tspin_unlock_irq(&rsp->rss_lock);",
            "",
            "\tif (gp_state != GP_IDLE) {",
            "\t\trcu_barrier();",
            "\t\tWARN_ON_ONCE(rsp->gp_state != GP_IDLE);",
            "\t}",
            "}"
          ],
          "function_name": "rcu_sync_init, rcu_sync_enter_start, rcu_sync_call, rcu_sync_func, rcu_sync_enter, rcu_sync_exit, rcu_sync_dtor",
          "description": "实现了RCU同步核心函数，包括初始化、状态管理、回调触发和退出处理，通过spinlock保护状态机并利用RCU回调实现延迟同步，用于协调读者-写者并发访问的安全转换",
          "similarity": 0.6262500286102295
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/rcu/sync.c",
          "start_line": 1,
          "end_line": 20,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * RCU-based infrastructure for lightweight reader-writer locking",
            " *",
            " * Copyright (c) 2015, Red Hat, Inc.",
            " *",
            " * Author: Oleg Nesterov <oleg@redhat.com>",
            " */",
            "",
            "#include <linux/rcu_sync.h>",
            "#include <linux/sched.h>",
            "",
            "enum { GP_IDLE = 0, GP_ENTER, GP_PASSED, GP_EXIT, GP_REPLAY };",
            "",
            "#define\trss_lock\tgp_wait.lock",
            "",
            "/**",
            " * rcu_sync_init() - Initialize an rcu_sync structure",
            " * @rsp: Pointer to rcu_sync structure to be initialized",
            " */"
          ],
          "function_name": null,
          "description": "定义了RCU同步基础设施的枚举常量和rcu_sync_init函数声明，用于初始化rcu_sync结构体，但代码上下文不完整",
          "similarity": 0.5207505226135254
        }
      ]
    }
  ]
}