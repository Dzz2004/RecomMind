{
  "query": "线程模型N:M实现原理及代码示例",
  "timestamp": "2025-12-26 00:49:54",
  "retrieved_files": [
    {
      "source_file": "mm/mm_slot.h",
      "md_summary": "> 自动生成时间: 2025-12-07 16:50:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mm_slot.h`\n\n---\n\n# mm_slot.h 技术文档\n\n## 1. 文件概述\n\n`mm_slot.h` 是 Linux 内核中用于管理 `mm_struct`（内存描述符）与辅助数据结构之间映射关系的头文件。它定义了一个轻量级的槽位（slot）机制，通过哈希表实现从 `mm_struct` 指针到对应 `mm_slot` 结构的快速查找，常用于需要为每个进程地址空间附加额外元数据的子系统（如 KSM、memory cgroup 等）。\n\n## 2. 核心功能\n\n### 数据结构\n- **`struct mm_slot`**  \n  表示一个内存描述符槽位，包含：\n  - `hash`：用于哈希表桶中的链表节点（`hlist_node`）\n  - `mm_node`：用于维护所有 `mm_slot` 的全局链表节点（`list_head`）\n  - `mm`：指向关联的 `struct mm_struct` 实例\n\n### 宏与内联函数\n- **`mm_slot_entry(ptr, type, member)`**  \n  基于 `container_of` 的宏，用于从 `mm_slot` 成员指针反向获取宿主结构体指针。\n  \n- **`mm_slot_alloc(cache)`**  \n  从指定的 slab 缓存中分配并零初始化一个 `mm_slot` 对象。\n\n- **`mm_slot_free(cache, objp)`**  \n  将 `mm_slot` 对象释放回 slab 缓存。\n\n- **`mm_slot_lookup(_hashtable, _mm)`**  \n  在给定的哈希表中查找与指定 `mm_struct` 关联的 `mm_slot`。\n\n- **`mm_slot_insert(_hashtable, _mm, _mm_slot)`**  \n  将新的 `mm_slot` 插入哈希表，并绑定到指定的 `mm_struct`。\n\n## 3. 关键实现\n\n- **哈希表设计**：  \n  使用内核通用哈希表（`<linux/hashtable.h>`）实现 O(1) 平均时间复杂度的查找。哈希键为 `mm_struct *` 指针的数值（转换为 `unsigned long`），通过 `hash_for_each_possible` 遍历冲突链。\n\n- **内存管理**：  \n  依赖 slab 分配器（`kmem_cache_zalloc` / `kmem_cache_free`）高效管理 `mm_slot` 对象生命周期，支持零初始化以避免脏数据。\n\n- **双重链表结构**：  \n  `mm_slot` 同时嵌入两个链表：\n  - 哈希桶链表（`hash` 字段）：用于快速查找\n  - 全局顺序链表（`mm_node` 字段）：便于遍历所有注册的槽位（例如在扫描或清理阶段）\n\n- **类型安全封装**：  \n  所有操作通过宏和内联函数封装，隐藏底层哈希表和链表操作细节，提升代码可读性与复用性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/hashtable.h>`：提供哈希表基础设施（`hash_add`, `hash_for_each_possible` 等）\n  - `<linux/slab.h>`：提供 slab 分配器接口（`kmem_cache_zalloc`, `kmem_cache_free`）\n\n- **内核模块依赖**：\n  - 依赖 `mm_struct` 定义（通常通过间接包含 `<linux/mm_types.h>`）\n  - 被需要跟踪进程地址空间的子系统使用，如：\n    - **KSM (Kernel Samepage Merging)**：用于去重内存页时跟踪参与合并的 `mm`\n    - **Memory Control Group (memcg)**：在某些实现中用于关联 `mm` 与资源统计\n\n## 5. 使用场景\n\n- **KSM 子系统**：  \n  KSM 使用 `mm_slot` 将参与内存页扫描的进程 `mm_struct` 注册到全局哈希表和链表中，以便周期性遍历所有候选地址空间进行页面内容比对。\n\n- **内存回收与监控**：  \n  当需要为每个用户态进程地址空间维护额外状态（如扫描进度、统计计数器等）时，可通过 `mm_slot` 机制建立 `mm_struct` 到私有数据的映射。\n\n- **动态注册/注销**：  \n  进程创建或退出时，相关子系统可调用 `mm_slot_insert` 和释放逻辑，动态维护活跃 `mm` 的集合，避免遍历全部进程。",
      "similarity": 0.5333532094955444,
      "chunks": []
    },
    {
      "source_file": "mm/memory-tiers.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:41:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memory-tiers.c`\n\n---\n\n# memory-tiers.c 技术文档\n\n## 1. 文件概述\n\n`memory-tiers.c` 是 Linux 内核中实现 **内存层级（Memory Tiering）** 功能的核心模块。该文件负责根据抽象距离（abstract distance, adistance）对 NUMA 节点进行分层管理，支持将不同性能特性的内存（如 DRAM、PMEM、HBM 等）组织成层级结构，并为页面迁移（demotion/promotion）和 NUMA 平衡提供基础支持。通过 sysfs 暴露内存层级信息，便于用户空间监控和策略配置。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct memory_tier`  \n  表示一个内存层级，包含：\n  - `adistance_start`：该层级的起始抽象距离（按 `MEMTIER_CHUNK_SIZE` 对齐）\n  - `memory_types`：属于该层级的所有内存设备类型（`memory_dev_type`）链表\n  - `lower_tier_mask`：所有更低层级（更高延迟/更低性能）节点的位掩码\n  - `dev`：对应的 sysfs 设备对象\n\n- `struct demotion_nodes`  \n  用于记录每个节点在页面降级（demotion）时的首选目标节点集合。\n\n- `struct node_memory_type_map`  \n  每个 NUMA 节点到其内存设备类型的映射及引用计数。\n\n- `node_demotion[]`（仅 `CONFIG_MIGRATION`）  \n  全局数组，存储每个节点的降级目标偏好。\n\n### 主要函数与接口\n\n- `find_create_memory_tier()`  \n  根据给定内存设备类型的抽象距离，查找或创建对应的 `memory_tier` 实例，并将其加入全局层级链表（按 `adistance_start` 升序排列）。\n\n- `__node_get_memory_tier()` / `node_is_toptier()`  \n  查询指定 NUMA 节点所属的内存层级；`node_is_toptier()` 判断节点是否属于顶层（最高性能）内存层级。\n\n- `node_get_allowed_targets()`  \n  获取指定节点在页面迁移时允许的目标节点集合（即其所在层级之下的所有节点）。\n\n- `next_demotion_node()`（未完整展示）  \n  返回从给定节点出发，在降级路径中的下一个目标节点 ID。\n\n- `folio_use_access_time()`（仅 `CONFIG_NUMA_BALANCING`）  \n  在启用内存层级模式的 NUMA 平衡中，判断是否将 folio 的 `_last_cpupid` 字段复用为访问时间戳（仅适用于非顶层内存节点）。\n\n- `nodelist_show()`  \n  sysfs 属性回调，输出当前内存层级包含的所有 NUMA 节点列表。\n\n## 3. 关键实现\n\n### 内存层级构建逻辑\n- 所有内存设备类型（`memory_dev_type`）通过其 `adistance` 值被归入特定层级。\n- 层级按 `adistance_start = round_down(adistance, MEMTIER_CHUNK_SIZE)` 分组，确保同一层级内设备具有相近的性能特征。\n- 全局链表 `memory_tiers` 维护层级顺序（从低 `adistance` 到高），反映从高性能到低性能的层级结构。\n\n### 层级间依赖关系\n- 每个 `memory_tier` 的 `lower_tier_mask` 记录了所有比它性能更低（`adistance` 更高）的层级所包含的节点集合，用于快速确定迁移目标范围。\n- 顶层层级由全局变量 `top_tier_adistance` 定义，通常对应最低 `adistance` 值的层级（如 CPU 本地 DRAM）。\n\n### RCU 与锁机制\n- 使用 `memory_tier_lock`（互斥锁）保护全局层级结构和设备注册。\n- 节点到层级的映射（`pgdat->memtier`）通过 RCU 机制更新和读取，确保在无锁路径（如页面访问）中的高效性。\n- `synchronize_rcu()` 用于在释放 `memory_tier` 前确保无并发 RCU 读者。\n\n### sysfs 集成\n- 每个 `memory_tier` 注册为 `memory_tiering` 子系统下的设备（`memory_tierX`）。\n- 通过 `nodelist` 属性暴露该层级包含的 NUMA 节点，格式为位图字符串（如 `\"0-3,8-11\"`）。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/memory.h>`：NUMA 节点和内存管理基础\n  - `<linux/memory-tiers.h>`：内存层级公共接口定义\n  - `\"internal.h\"`：内部辅助函数\n- **可选依赖**：\n  - `CONFIG_NUMA_BALANCING`：提供 `folio_use_access_time()`，支持基于访问时间的页面迁移\n  - `CONFIG_MIGRATION`：提供 `node_demotion` 结构和 `next_demotion_node()` 等迁移相关功能\n- **子系统交互**：\n  - 与内存热插拔（`memory_hotplug`）协同，动态更新层级结构\n  - 为自动 NUMA 平衡（AutoNUMA）和页面迁移框架提供层级拓扑信息\n\n## 5. 使用场景\n\n- **异构内存系统管理**：在包含 DRAM、PMEM、CXL 内存等多类型内存的系统中，自动构建性能层级视图。\n- **智能页面迁移**：作为 `migrate_pages()` 和后台 demotion daemon 的决策依据，将冷页从高性能内存迁移到大容量低速内存。\n- **NUMA 负载均衡优化**：在 `CONFIG_NUMA_BALANCING` 启用时，结合访问时间戳和层级信息，优先将热页保留在顶层内存。\n- **用户空间监控与调优**：通过 `/sys/devices/memory_tiering/memory_tier*/nodelist` 查看各层级节点分布，辅助制定应用部署策略。",
      "similarity": 0.5320989489555359,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "mm/memory-tiers.c",
          "start_line": 688,
          "end_line": 801,
          "content": [
            "int mt_perf_to_adistance(struct access_coordinate *perf, int *adist)",
            "{",
            "\tif (default_dram_perf_error)",
            "\t\treturn -EIO;",
            "",
            "\tif (default_dram_perf_ref_nid == NUMA_NO_NODE)",
            "\t\treturn -ENOENT;",
            "",
            "\tif (perf->read_latency + perf->write_latency == 0 ||",
            "\t    perf->read_bandwidth + perf->write_bandwidth == 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\t/*",
            "\t * The abstract distance of a memory node is in direct proportion to",
            "\t * its memory latency (read + write) and inversely proportional to its",
            "\t * memory bandwidth (read + write).  The abstract distance, memory",
            "\t * latency, and memory bandwidth of the default DRAM nodes are used as",
            "\t * the base.",
            "\t */",
            "\t*adist = MEMTIER_ADISTANCE_DRAM *",
            "\t\t(perf->read_latency + perf->write_latency) /",
            "\t\t(default_dram_perf.read_latency + default_dram_perf.write_latency) *",
            "\t\t(default_dram_perf.read_bandwidth + default_dram_perf.write_bandwidth) /",
            "\t\t(perf->read_bandwidth + perf->write_bandwidth);",
            "\tmutex_unlock(&memory_tier_lock);",
            "",
            "\treturn 0;",
            "}",
            "int register_mt_adistance_algorithm(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&mt_adistance_algorithms, nb);",
            "}",
            "int unregister_mt_adistance_algorithm(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&mt_adistance_algorithms, nb);",
            "}",
            "int mt_calc_adistance(int node, int *adist)",
            "{",
            "\treturn blocking_notifier_call_chain(&mt_adistance_algorithms, node, adist);",
            "}",
            "static int __meminit memtier_hotplug_callback(struct notifier_block *self,",
            "\t\t\t\t\t      unsigned long action, void *_arg)",
            "{",
            "\tstruct memory_tier *memtier;",
            "\tstruct memory_notify *arg = _arg;",
            "",
            "\t/*",
            "\t * Only update the node migration order when a node is",
            "\t * changing status, like online->offline.",
            "\t */",
            "\tif (arg->status_change_nid < 0)",
            "\t\treturn notifier_from_errno(0);",
            "",
            "\tswitch (action) {",
            "\tcase MEM_OFFLINE:",
            "\t\tmutex_lock(&memory_tier_lock);",
            "\t\tif (clear_node_memory_tier(arg->status_change_nid))",
            "\t\t\testablish_demotion_targets();",
            "\t\tmutex_unlock(&memory_tier_lock);",
            "\t\tbreak;",
            "\tcase MEM_ONLINE:",
            "\t\tmutex_lock(&memory_tier_lock);",
            "\t\tmemtier = set_node_memory_tier(arg->status_change_nid);",
            "\t\tif (!IS_ERR(memtier))",
            "\t\t\testablish_demotion_targets();",
            "\t\tmutex_unlock(&memory_tier_lock);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn notifier_from_errno(0);",
            "}",
            "static int __init memory_tier_init(void)",
            "{",
            "\tint ret, node;",
            "\tstruct memory_tier *memtier;",
            "",
            "\tret = subsys_virtual_register(&memory_tier_subsys, NULL);",
            "\tif (ret)",
            "\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);",
            "",
            "#ifdef CONFIG_MIGRATION",
            "\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),",
            "\t\t\t\tGFP_KERNEL);",
            "\tWARN_ON(!node_demotion);",
            "#endif",
            "\tmutex_lock(&memory_tier_lock);",
            "\t/*",
            "\t * For now we can have 4 faster memory tiers with smaller adistance",
            "\t * than default DRAM tier.",
            "\t */",
            "\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);",
            "\tif (IS_ERR(default_dram_type))",
            "\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);",
            "",
            "\t/*",
            "\t * Look at all the existing N_MEMORY nodes and add them to",
            "\t * default memory tier or to a tier if we already have memory",
            "\t * types assigned.",
            "\t */",
            "\tfor_each_node_state(node, N_MEMORY) {",
            "\t\tmemtier = set_node_memory_tier(node);",
            "\t\tif (IS_ERR(memtier))",
            "\t\t\t/*",
            "\t\t\t * Continue with memtiers we are able to setup",
            "\t\t\t */",
            "\t\t\tbreak;",
            "\t}",
            "\testablish_demotion_targets();",
            "\tmutex_unlock(&memory_tier_lock);",
            "",
            "\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "mt_perf_to_adistance, register_mt_adistance_algorithm, unregister_mt_adistance_algorithm, mt_calc_adistance, memtier_hotplug_callback, memory_tier_init",
          "description": "提供抽象距离计算接口和内存分层热插拔回调。初始化内存分层子系统，分配默认DRAM类型，遍历所有节点建立初始内存分层结构，并注册内存状态变化通知处理函数。",
          "similarity": 0.51192307472229
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memory-tiers.c",
          "start_line": 1,
          "end_line": 58,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/memory.h>",
            "#include <linux/memory-tiers.h>",
            "#include <linux/notifier.h>",
            "#include <linux/sched/sysctl.h>",
            "",
            "#include \"internal.h\"",
            "",
            "struct memory_tier {",
            "\t/* hierarchy of memory tiers */",
            "\tstruct list_head list;",
            "\t/* list of all memory types part of this tier */",
            "\tstruct list_head memory_types;",
            "\t/*",
            "\t * start value of abstract distance. memory tier maps",
            "\t * an abstract distance  range,",
            "\t * adistance_start .. adistance_start + MEMTIER_CHUNK_SIZE",
            "\t */",
            "\tint adistance_start;",
            "\tstruct device dev;",
            "\t/* All the nodes that are part of all the lower memory tiers. */",
            "\tnodemask_t lower_tier_mask;",
            "};",
            "",
            "struct demotion_nodes {",
            "\tnodemask_t preferred;",
            "};",
            "",
            "struct node_memory_type_map {",
            "\tstruct memory_dev_type *memtype;",
            "\tint map_count;",
            "};",
            "",
            "static DEFINE_MUTEX(memory_tier_lock);",
            "static LIST_HEAD(memory_tiers);",
            "static struct node_memory_type_map node_memory_types[MAX_NUMNODES];",
            "struct memory_dev_type *default_dram_type;",
            "",
            "static struct bus_type memory_tier_subsys = {",
            "\t.name = \"memory_tiering\",",
            "\t.dev_name = \"memory_tier\",",
            "};",
            "",
            "#ifdef CONFIG_NUMA_BALANCING",
            "/**",
            " * folio_use_access_time - check if a folio reuses cpupid for page access time",
            " * @folio: folio to check",
            " *",
            " * folio's _last_cpupid field is repurposed by memory tiering. In memory",
            " * tiering mode, cpupid of slow memory folio (not toptier memory) is used to",
            " * record page access time.",
            " *",
            " * Return: the folio _last_cpupid is used to record page access time",
            " */"
          ],
          "function_name": null,
          "description": "定义memory_tier结构体及辅助数据结构，用于管理内存分层体系。声明全局锁和链表头，注册内存分层子系统，并定义默认DRAM类型指针。包含用于内存分层的抽象距离相关内联函数原型。",
          "similarity": 0.5022779107093811
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memory-tiers.c",
          "start_line": 59,
          "end_line": 170,
          "content": [
            "bool folio_use_access_time(struct folio *folio)",
            "{",
            "\treturn (sysctl_numa_balancing_mode & NUMA_BALANCING_MEMORY_TIERING) &&",
            "\t       !node_is_toptier(folio_nid(folio));",
            "}",
            "static __always_inline nodemask_t get_memtier_nodemask(struct memory_tier *memtier)",
            "{",
            "\tnodemask_t nodes = NODE_MASK_NONE;",
            "\tstruct memory_dev_type *memtype;",
            "",
            "\tlist_for_each_entry(memtype, &memtier->memory_types, tier_sibling)",
            "\t\tnodes_or(nodes, nodes, memtype->nodes);",
            "",
            "\treturn nodes;",
            "}",
            "static void memory_tier_device_release(struct device *dev)",
            "{",
            "\tstruct memory_tier *tier = to_memory_tier(dev);",
            "\t/*",
            "\t * synchronize_rcu in clear_node_memory_tier makes sure",
            "\t * we don't have rcu access to this memory tier.",
            "\t */",
            "\tkfree(tier);",
            "}",
            "static ssize_t nodelist_show(struct device *dev,",
            "\t\t\t     struct device_attribute *attr, char *buf)",
            "{",
            "\tint ret;",
            "\tnodemask_t nmask;",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\tnmask = get_memtier_nodemask(to_memory_tier(dev));",
            "\tret = sysfs_emit(buf, \"%*pbl\\n\", nodemask_pr_args(&nmask));",
            "\tmutex_unlock(&memory_tier_lock);",
            "\treturn ret;",
            "}",
            "bool node_is_toptier(int node)",
            "{",
            "\tbool toptier;",
            "\tpg_data_t *pgdat;",
            "\tstruct memory_tier *memtier;",
            "",
            "\tpgdat = NODE_DATA(node);",
            "\tif (!pgdat)",
            "\t\treturn false;",
            "",
            "\trcu_read_lock();",
            "\tmemtier = rcu_dereference(pgdat->memtier);",
            "\tif (!memtier) {",
            "\t\ttoptier = true;",
            "\t\tgoto out;",
            "\t}",
            "\tif (memtier->adistance_start <= top_tier_adistance)",
            "\t\ttoptier = true;",
            "\telse",
            "\t\ttoptier = false;",
            "out:",
            "\trcu_read_unlock();",
            "\treturn toptier;",
            "}",
            "void node_get_allowed_targets(pg_data_t *pgdat, nodemask_t *targets)",
            "{",
            "\tstruct memory_tier *memtier;",
            "",
            "\t/*",
            "\t * pg_data_t.memtier updates includes a synchronize_rcu()",
            "\t * which ensures that we either find NULL or a valid memtier",
            "\t * in NODE_DATA. protect the access via rcu_read_lock();",
            "\t */",
            "\trcu_read_lock();",
            "\tmemtier = rcu_dereference(pgdat->memtier);",
            "\tif (memtier)",
            "\t\t*targets = memtier->lower_tier_mask;",
            "\telse",
            "\t\t*targets = NODE_MASK_NONE;",
            "\trcu_read_unlock();",
            "}",
            "int next_demotion_node(int node)",
            "{",
            "\tstruct demotion_nodes *nd;",
            "\tint target;",
            "",
            "\tif (!node_demotion)",
            "\t\treturn NUMA_NO_NODE;",
            "",
            "\tnd = &node_demotion[node];",
            "",
            "\t/*",
            "\t * node_demotion[] is updated without excluding this",
            "\t * function from running.",
            "\t *",
            "\t * Make sure to use RCU over entire code blocks if",
            "\t * node_demotion[] reads need to be consistent.",
            "\t */",
            "\trcu_read_lock();",
            "\t/*",
            "\t * If there are multiple target nodes, just select one",
            "\t * target node randomly.",
            "\t *",
            "\t * In addition, we can also use round-robin to select",
            "\t * target node, but we should introduce another variable",
            "\t * for node_demotion[] to record last selected target node,",
            "\t * that may cause cache ping-pong due to the changing of",
            "\t * last target node. Or introducing per-cpu data to avoid",
            "\t * caching issue, which seems more complicated. So selecting",
            "\t * target node randomly seems better until now.",
            "\t */",
            "\ttarget = node_random(&nd->preferred);",
            "\trcu_read_unlock();",
            "",
            "\treturn target;",
            "}"
          ],
          "function_name": "folio_use_access_time, get_memtier_nodemask, memory_tier_device_release, nodelist_show, node_is_toptier, node_get_allowed_targets, next_demotion_node",
          "description": "实现内存分层核心功能，包括判断页是否使用访问时间、获取内存分层节点掩码、设备释放、节点列表展示、判断是否为顶层节点、获取允许目标节点以及选择下一个降级节点的算法实现。",
          "similarity": 0.4937111735343933
        },
        {
          "chunk_id": 5,
          "file_path": "mm/memory-tiers.c",
          "start_line": 855,
          "end_line": 893,
          "content": [
            "static ssize_t demotion_enabled_show(struct kobject *kobj,",
            "\t\t\t\t     struct kobj_attribute *attr, char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%s\\n\",",
            "\t\t\t  numa_demotion_enabled ? \"true\" : \"false\");",
            "}",
            "static ssize_t demotion_enabled_store(struct kobject *kobj,",
            "\t\t\t\t      struct kobj_attribute *attr,",
            "\t\t\t\t      const char *buf, size_t count)",
            "{",
            "\tssize_t ret;",
            "",
            "\tret = kstrtobool(buf, &numa_demotion_enabled);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn count;",
            "}",
            "static int __init numa_init_sysfs(void)",
            "{",
            "\tint err;",
            "\tstruct kobject *numa_kobj;",
            "",
            "\tnuma_kobj = kobject_create_and_add(\"numa\", mm_kobj);",
            "\tif (!numa_kobj) {",
            "\t\tpr_err(\"failed to create numa kobject\\n\");",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\terr = sysfs_create_group(numa_kobj, &numa_attr_group);",
            "\tif (err) {",
            "\t\tpr_err(\"failed to register numa group\\n\");",
            "\t\tgoto delete_obj;",
            "\t}",
            "\treturn 0;",
            "",
            "delete_obj:",
            "\tkobject_put(numa_kobj);",
            "\treturn err;",
            "}"
          ],
          "function_name": "demotion_enabled_show, demotion_enabled_store, numa_init_sysfs",
          "description": "该代码段实现了NUMA内存降级功能的sysfs接口控制。  \n`demotion_enabled_show`与`demotion_enabled_store`分别用于读取和设置`numa_demotion_enabled`布尔标志。  \n`numa_init_sysfs`创建了NUMA相关sysfs属性组，但因缺少`numa_attr_group`定义，上下文不完整。",
          "similarity": 0.4832838177680969
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memory-tiers.c",
          "start_line": 481,
          "end_line": 635,
          "content": [
            "static inline void establish_demotion_targets(void) {}",
            "static inline void __init_node_memory_type(int node, struct memory_dev_type *memtype)",
            "{",
            "\tif (!node_memory_types[node].memtype)",
            "\t\tnode_memory_types[node].memtype = memtype;",
            "\t/*",
            "\t * for each device getting added in the same NUMA node",
            "\t * with this specific memtype, bump the map count. We",
            "\t * Only take memtype device reference once, so that",
            "\t * changing a node memtype can be done by droping the",
            "\t * only reference count taken here.",
            "\t */",
            "",
            "\tif (node_memory_types[node].memtype == memtype) {",
            "\t\tif (!node_memory_types[node].map_count++)",
            "\t\t\tkref_get(&memtype->kref);",
            "\t}",
            "}",
            "static void destroy_memory_tier(struct memory_tier *memtier)",
            "{",
            "\tlist_del(&memtier->list);",
            "\tdevice_unregister(&memtier->dev);",
            "}",
            "static bool clear_node_memory_tier(int node)",
            "{",
            "\tbool cleared = false;",
            "\tpg_data_t *pgdat;",
            "\tstruct memory_tier *memtier;",
            "",
            "\tpgdat = NODE_DATA(node);",
            "\tif (!pgdat)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Make sure that anybody looking at NODE_DATA who finds",
            "\t * a valid memtier finds memory_dev_types with nodes still",
            "\t * linked to the memtier. We achieve this by waiting for",
            "\t * rcu read section to finish using synchronize_rcu.",
            "\t * This also enables us to free the destroyed memory tier",
            "\t * with kfree instead of kfree_rcu",
            "\t */",
            "\tmemtier = __node_get_memory_tier(node);",
            "\tif (memtier) {",
            "\t\tstruct memory_dev_type *memtype;",
            "",
            "\t\trcu_assign_pointer(pgdat->memtier, NULL);",
            "\t\tsynchronize_rcu();",
            "\t\tmemtype = node_memory_types[node].memtype;",
            "\t\tnode_clear(node, memtype->nodes);",
            "\t\tif (nodes_empty(memtype->nodes)) {",
            "\t\t\tlist_del_init(&memtype->tier_sibling);",
            "\t\t\tif (list_empty(&memtier->memory_types))",
            "\t\t\t\tdestroy_memory_tier(memtier);",
            "\t\t}",
            "\t\tcleared = true;",
            "\t}",
            "\treturn cleared;",
            "}",
            "static void release_memtype(struct kref *kref)",
            "{",
            "\tstruct memory_dev_type *memtype;",
            "",
            "\tmemtype = container_of(kref, struct memory_dev_type, kref);",
            "\tkfree(memtype);",
            "}",
            "void put_memory_type(struct memory_dev_type *memtype)",
            "{",
            "\tkref_put(&memtype->kref, release_memtype);",
            "}",
            "void init_node_memory_type(int node, struct memory_dev_type *memtype)",
            "{",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\t__init_node_memory_type(node, memtype);",
            "\tmutex_unlock(&memory_tier_lock);",
            "}",
            "void clear_node_memory_type(int node, struct memory_dev_type *memtype)",
            "{",
            "\tmutex_lock(&memory_tier_lock);",
            "\tif (node_memory_types[node].memtype == memtype || !memtype)",
            "\t\tnode_memory_types[node].map_count--;",
            "\t/*",
            "\t * If we umapped all the attached devices to this node,",
            "\t * clear the node memory type.",
            "\t */",
            "\tif (!node_memory_types[node].map_count) {",
            "\t\tmemtype = node_memory_types[node].memtype;",
            "\t\tnode_memory_types[node].memtype = NULL;",
            "\t\tput_memory_type(memtype);",
            "\t}",
            "\tmutex_unlock(&memory_tier_lock);",
            "}",
            "static void dump_hmem_attrs(struct access_coordinate *coord, const char *prefix)",
            "{",
            "\tpr_info(",
            "\"%sread_latency: %u, write_latency: %u, read_bandwidth: %u, write_bandwidth: %u\\n\",",
            "\t\tprefix, coord->read_latency, coord->write_latency,",
            "\t\tcoord->read_bandwidth, coord->write_bandwidth);",
            "}",
            "int mt_set_default_dram_perf(int nid, struct access_coordinate *perf,",
            "\t\t\t     const char *source)",
            "{",
            "\tint rc = 0;",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\tif (default_dram_perf_error) {",
            "\t\trc = -EIO;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (perf->read_latency + perf->write_latency == 0 ||",
            "\t    perf->read_bandwidth + perf->write_bandwidth == 0) {",
            "\t\trc = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (default_dram_perf_ref_nid == NUMA_NO_NODE) {",
            "\t\tdefault_dram_perf = *perf;",
            "\t\tdefault_dram_perf_ref_nid = nid;",
            "\t\tdefault_dram_perf_ref_source = kstrdup(source, GFP_KERNEL);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * The performance of all default DRAM nodes is expected to be",
            "\t * same (that is, the variation is less than 10%).  And it",
            "\t * will be used as base to calculate the abstract distance of",
            "\t * other memory nodes.",
            "\t */",
            "\tif (abs(perf->read_latency - default_dram_perf.read_latency) * 10 >",
            "\t    default_dram_perf.read_latency ||",
            "\t    abs(perf->write_latency - default_dram_perf.write_latency) * 10 >",
            "\t    default_dram_perf.write_latency ||",
            "\t    abs(perf->read_bandwidth - default_dram_perf.read_bandwidth) * 10 >",
            "\t    default_dram_perf.read_bandwidth ||",
            "\t    abs(perf->write_bandwidth - default_dram_perf.write_bandwidth) * 10 >",
            "\t    default_dram_perf.write_bandwidth) {",
            "\t\tpr_info(",
            "\"memory-tiers: the performance of DRAM node %d mismatches that of the reference\\n\"",
            "\"DRAM node %d.\\n\", nid, default_dram_perf_ref_nid);",
            "\t\tpr_info(\"  performance of reference DRAM node %d:\\n\",",
            "\t\t\tdefault_dram_perf_ref_nid);",
            "\t\tdump_hmem_attrs(&default_dram_perf, \"    \");",
            "\t\tpr_info(\"  performance of DRAM node %d:\\n\", nid);",
            "\t\tdump_hmem_attrs(perf, \"    \");",
            "\t\tpr_info(",
            "\"  disable default DRAM node performance based abstract distance algorithm.\\n\");",
            "\t\tdefault_dram_perf_error = true;",
            "\t\trc = -EINVAL;",
            "\t}",
            "",
            "out:",
            "\tmutex_unlock(&memory_tier_lock);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "establish_demotion_targets, __init_node_memory_type, destroy_memory_tier, clear_node_memory_tier, release_memtype, put_memory_type, init_node_memory_type, clear_node_memory_type, dump_hmem_attrs, mt_set_default_dram_perf",
          "description": "实现内存类型管理系统，包含初始化/清除节点内存类型、引用计数管理、性能属性打印、默认DRAM性能设置等功能。通过kref机制跟踪内存类型引用，确保内存分层结构的正确释放。",
          "similarity": 0.4413887560367584
        }
      ]
    },
    {
      "source_file": "mm/oom_kill.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:58:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `oom_kill.c`\n\n---\n\n# oom_kill.c 技术文档\n\n## 1. 文件概述\n\n`oom_kill.c` 是 Linux 内核内存管理子系统中的关键组件，负责在系统严重内存不足（Out-Of-Memory, OOM）时选择并终止一个或多个进程，以释放内存资源、防止系统崩溃。该文件实现了 OOM Killer 的核心逻辑，包括候选进程的选择策略、内存压力评估、以及与内存控制组（memcg）、NUMA 策略、cpuset 等子系统的集成。OOM Killer 通常由 `__alloc_pages()` 在无法满足内存分配请求时触发。\n\n## 2. 核心功能\n\n### 主要函数\n- **`out_of_memory()`**：OOM Killer 的主入口函数（虽未在片段中完整显示，但为本文件核心）\n- **`oom_badness()`**：计算进程“坏度”（badness）分数的核心启发式函数，用于决定哪个进程最应被杀死\n- **`find_lock_task_mm()`**：在进程及其线程组中查找具有有效内存描述符（`mm_struct`）的可杀任务，并加锁\n- **`oom_unkillable_task()`**：判断某任务是否不可被 OOM Killer 杀死（如 init 进程、内核线程）\n- **`constrained_alloc()`**：确定当前内存分配所受的约束类型（如 memcg、cpuset、mempolicy）\n- **`oom_cpuset_eligible()`**（仅 CONFIG_NUMA）：在 NUMA 系统中检查任务是否符合 cpuset 或 mempolicy 的 OOM 杀死条件\n- **`should_dump_unreclaim_slab()`**：判断是否因不可回收 slab 内存过多而触发 OOM，用于辅助诊断\n\n### 关键数据结构\n- **`struct oom_control`**：封装 OOM 事件上下文，包括分配标志（`gfp_mask`）、节点掩码（`nodemask`）、内存控制组（`memcg`）、分配阶数（`order`）等\n- **`enum oom_constraint`**：表示内存分配受限的类型（`CONSTRAINT_NONE`、`CONSTRAINT_CPUSET`、`CONSTRAINT_MEMORY_POLICY`、`CONSTRAINT_MEMCG`）\n\n### 全局变量\n- **`sysctl_panic_on_oom`**：控制 OOM 时是否直接 panic\n- **`sysctl_oom_kill_allocating_task`**：若置位，则优先杀死触发 OOM 的进程\n- **`sysctl_oom_dump_tasks`**：控制 OOM 时是否打印所有任务的内存使用信息\n- **`oom_lock`**：互斥锁，序列化 OOM Killer 调用，防止并发过度杀进程\n- **`oom_adj_mutex`**：互斥锁，保护 `oom_score_adj` 和 `oom_score_adj_min` 的更新\n\n## 3. 关键实现\n\n### OOM 坏度评分算法 (`oom_badness`)\n- **基础分值**：基于进程的 RSS（Resident Set Size）、交换页数量（`MM_SWAPENTS`）和页表占用内存（`mm_pgtables_bytes`），单位为页数。\n- **调整因子**：通过 `oom_score_adj`（范围 [-1000, 1000]）进行线性调整。调整量 = `oom_score_adj * totalpages / 1000`，其中 `totalpages` 为当前 OOM 上下文允许的最大内存页数（全局或 memcg 限制）。\n- **排除规则**：\n  - 全局 init 进程（PID 1）和内核线程（`PF_KTHREAD`）不可杀。\n  - 显式设置 `oom_score_adj = OOM_SCORE_ADJ_MIN (-1000)` 的进程不可杀。\n  - 已被标记跳过（`MMF_OOM_SKIP`）或处于 `vfork` 中间状态的进程不可杀。\n- **返回值**：`LONG_MIN` 表示不可杀；否则返回综合评分，值越大越优先被杀。\n\n### 内存分配约束识别 (`constrained_alloc`)\n- **Memcg OOM**：若 `oc->memcg` 非空，则 `totalpages` 设为 memcg 的内存上限，约束类型为 `CONSTRAINT_MEMCG`。\n- **全局 OOM**：默认 `totalpages = totalram_pages + total_swap_pages`。\n- **NUMA 约束**：\n  - 若分配请求指定 `__GFP_THISNODE`，视为无特殊约束（避免杀死当前进程）。\n  - 若存在非全集的 `nodemask`（来自 mempolicy），则 `totalpages` 仅统计该 nodemask 覆盖节点的内存，约束类型为 `CONSTRAINT_MEMORY_POLICY`。\n  - Cpuset 约束由页面分配器处理，此处不直接计算。\n\n### 多线程与内存描述符处理 (`find_lock_task_mm`)\n- 遍历目标进程的整个线程组（`for_each_thread`），寻找任一仍持有有效 `mm_struct` 的线程。\n- 对找到的线程加 `task_lock` 并返回，确保在检查其内存状态时不会被释放。\n- 适用于主线程已退出但子线程仍在运行的场景。\n\n### NUMA 可杀性检查 (`oom_cpuset_eligible`)\n- 在 NUMA 系统中，仅当候选任务与触发 OOM 的当前任务在内存策略（mempolicy）或 cpuset 允许的节点集上有交集时，才视为可杀。\n- 若 OOM 由 mempolicy 触发（`oc->nodemask` 非空），则仅检查 mempolicy 交集。\n- 否则，检查 cpuset 的 `mems_allowed` 交集。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/gfp.h>`、`<linux/swap.h>` 获取内存状态、分配标志和交换信息。\n- **进程调度与管理**：依赖 `<linux/sched.h>` 及相关头文件访问任务结构、线程组、cpuset 和内存策略。\n- **内存控制组 (cgroup v2)**：通过 `<linux/memcontrol.h>` 集成 memcg，支持容器级 OOM。\n- **安全模块**：通过 `<linux/security.h>` 调用 LSM 钩子（如 `security_oom_kill()`）。\n- **调试与追踪**：使用 ftrace (`<linux/ftrace.h>`) 和自定义 tracepoint (`trace/events/oom.h`) 记录 OOM 事件。\n- **体系结构相关**：包含 `<asm/tlb.h>` 处理 TLB 刷新。\n- **内部 MM 实现**：包含 `\"internal.h\"` 和 `\"slab.h\"` 访问内核私有内存管理接口。\n\n## 5. 使用场景\n\n- **全局内存耗尽**：当系统整体可用内存（含 swap）低于临界阈值，且无法通过页面回收释放足够内存时，由页面分配器调用 `out_of_memory()`。\n- **Memcg 内存超限**：当某个 memory cgroup 的内存使用超过其配额时，触发该 cgroup 内的 OOM Killer。\n- **SysRq 触发**：通过 Magic SysRq 键（`Alt+SysRq+f`）手动触发 OOM Killer，此时 `oc->order = -1`。\n- **诊断辅助**：当不可回收 slab 内存（如内核对象缓存）异常增长导致 OOM 时，`should_dump_unreclaim_slab()` 可触发 slab 信息转储以辅助调试。\n- **策略约束下的 OOM**：在 NUMA 系统中，受 cpuset 或 mempolicy 限制的进程在局部节点内存耗尽时触发针对性 OOM。",
      "similarity": 0.5291190147399902,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/oom_kill.c",
          "start_line": 253,
          "end_line": 359,
          "content": [
            "static enum oom_constraint constrained_alloc(struct oom_control *oc)",
            "{",
            "\tstruct zone *zone;",
            "\tstruct zoneref *z;",
            "\tenum zone_type highest_zoneidx = gfp_zone(oc->gfp_mask);",
            "\tbool cpuset_limited = false;",
            "\tint nid;",
            "",
            "\tif (is_memcg_oom(oc)) {",
            "\t\toc->totalpages = mem_cgroup_get_max(oc->memcg) ?: 1;",
            "\t\treturn CONSTRAINT_MEMCG;",
            "\t}",
            "",
            "\t/* Default to all available memory */",
            "\toc->totalpages = totalram_pages() + total_swap_pages;",
            "",
            "\tif (!IS_ENABLED(CONFIG_NUMA))",
            "\t\treturn CONSTRAINT_NONE;",
            "",
            "\tif (!oc->zonelist)",
            "\t\treturn CONSTRAINT_NONE;",
            "\t/*",
            "\t * Reach here only when __GFP_NOFAIL is used. So, we should avoid",
            "\t * to kill current.We have to random task kill in this case.",
            "\t * Hopefully, CONSTRAINT_THISNODE...but no way to handle it, now.",
            "\t */",
            "\tif (oc->gfp_mask & __GFP_THISNODE)",
            "\t\treturn CONSTRAINT_NONE;",
            "",
            "\t/*",
            "\t * This is not a __GFP_THISNODE allocation, so a truncated nodemask in",
            "\t * the page allocator means a mempolicy is in effect.  Cpuset policy",
            "\t * is enforced in get_page_from_freelist().",
            "\t */",
            "\tif (oc->nodemask &&",
            "\t    !nodes_subset(node_states[N_MEMORY], *oc->nodemask)) {",
            "\t\toc->totalpages = total_swap_pages;",
            "\t\tfor_each_node_mask(nid, *oc->nodemask)",
            "\t\t\toc->totalpages += node_present_pages(nid);",
            "\t\treturn CONSTRAINT_MEMORY_POLICY;",
            "\t}",
            "",
            "\t/* Check this allocation failure is caused by cpuset's wall function */",
            "\tfor_each_zone_zonelist_nodemask(zone, z, oc->zonelist,",
            "\t\t\thighest_zoneidx, oc->nodemask)",
            "\t\tif (!cpuset_zone_allowed(zone, oc->gfp_mask))",
            "\t\t\tcpuset_limited = true;",
            "",
            "\tif (cpuset_limited) {",
            "\t\toc->totalpages = total_swap_pages;",
            "\t\tfor_each_node_mask(nid, cpuset_current_mems_allowed)",
            "\t\t\toc->totalpages += node_present_pages(nid);",
            "\t\treturn CONSTRAINT_CPUSET;",
            "\t}",
            "\treturn CONSTRAINT_NONE;",
            "}",
            "static int oom_evaluate_task(struct task_struct *task, void *arg)",
            "{",
            "\tstruct oom_control *oc = arg;",
            "\tlong points;",
            "",
            "\tif (oom_unkillable_task(task))",
            "\t\tgoto next;",
            "",
            "\t/* p may not have freeable memory in nodemask */",
            "\tif (!is_memcg_oom(oc) && !oom_cpuset_eligible(task, oc))",
            "\t\tgoto next;",
            "",
            "\t/*",
            "\t * This task already has access to memory reserves and is being killed.",
            "\t * Don't allow any other task to have access to the reserves unless",
            "\t * the task has MMF_OOM_SKIP because chances that it would release",
            "\t * any memory is quite low.",
            "\t */",
            "\tif (!is_sysrq_oom(oc) && tsk_is_oom_victim(task)) {",
            "\t\tif (test_bit(MMF_OOM_SKIP, &task->signal->oom_mm->flags))",
            "\t\t\tgoto next;",
            "\t\tgoto abort;",
            "\t}",
            "",
            "\t/*",
            "\t * If task is allocating a lot of memory and has been marked to be",
            "\t * killed first if it triggers an oom, then select it.",
            "\t */",
            "\tif (oom_task_origin(task)) {",
            "\t\tpoints = LONG_MAX;",
            "\t\tgoto select;",
            "\t}",
            "",
            "\tpoints = oom_badness(task, oc->totalpages);",
            "\tif (points == LONG_MIN || points < oc->chosen_points)",
            "\t\tgoto next;",
            "",
            "select:",
            "\tif (oc->chosen)",
            "\t\tput_task_struct(oc->chosen);",
            "\tget_task_struct(task);",
            "\toc->chosen = task;",
            "\toc->chosen_points = points;",
            "next:",
            "\treturn 0;",
            "abort:",
            "\tif (oc->chosen)",
            "\t\tput_task_struct(oc->chosen);",
            "\toc->chosen = (void *)-1UL;",
            "\treturn 1;",
            "}"
          ],
          "function_name": "constrained_alloc, oom_evaluate_task",
          "description": "根据内存分配约束条件（如NUMA节点、内存组）动态调整可回收内存总量，并通过评估函数筛选出具有最高OOM不良值的任务作为潜在受害者。",
          "similarity": 0.5301803350448608
        },
        {
          "chunk_id": 7,
          "file_path": "mm/oom_kill.c",
          "start_line": 1011,
          "end_line": 1162,
          "content": [
            "static int oom_kill_memcg_member(struct task_struct *task, void *message)",
            "{",
            "\tif (task->signal->oom_score_adj != OOM_SCORE_ADJ_MIN &&",
            "\t    !is_global_init(task)) {",
            "\t\tget_task_struct(task);",
            "\t\t__oom_kill_process(task, message);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void oom_kill_process(struct oom_control *oc, const char *message)",
            "{",
            "\tstruct task_struct *victim = oc->chosen;",
            "\tstruct mem_cgroup *oom_group;",
            "\tstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,",
            "\t\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
            "",
            "\t/*",
            "\t * If the task is already exiting, don't alarm the sysadmin or kill",
            "\t * its children or threads, just give it access to memory reserves",
            "\t * so it can die quickly",
            "\t */",
            "\ttask_lock(victim);",
            "\tif (task_will_free_mem(victim)) {",
            "\t\tmark_oom_victim(victim);",
            "\t\tqueue_oom_reaper(victim);",
            "\t\ttask_unlock(victim);",
            "\t\tput_task_struct(victim);",
            "\t\treturn;",
            "\t}",
            "\ttask_unlock(victim);",
            "",
            "\tif (__ratelimit(&oom_rs))",
            "\t\tdump_header(oc, victim);",
            "",
            "\t/*",
            "\t * Do we need to kill the entire memory cgroup?",
            "\t * Or even one of the ancestor memory cgroups?",
            "\t * Check this out before killing the victim task.",
            "\t */",
            "\toom_group = mem_cgroup_get_oom_group(victim, oc->memcg);",
            "",
            "\t__oom_kill_process(victim, message);",
            "",
            "\t/*",
            "\t * If necessary, kill all tasks in the selected memory cgroup.",
            "\t */",
            "\tif (oom_group) {",
            "\t\tmemcg_memory_event(oom_group, MEMCG_OOM_GROUP_KILL);",
            "\t\tmem_cgroup_print_oom_group(oom_group);",
            "\t\tmem_cgroup_scan_tasks(oom_group, oom_kill_memcg_member,",
            "\t\t\t\t      (void *)message);",
            "\t\tmem_cgroup_put(oom_group);",
            "\t}",
            "}",
            "static void check_panic_on_oom(struct oom_control *oc)",
            "{",
            "\tif (likely(!sysctl_panic_on_oom))",
            "\t\treturn;",
            "\tif (sysctl_panic_on_oom != 2) {",
            "\t\t/*",
            "\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel",
            "\t\t * does not panic for cpuset, mempolicy, or memcg allocation",
            "\t\t * failures.",
            "\t\t */",
            "\t\tif (oc->constraint != CONSTRAINT_NONE)",
            "\t\t\treturn;",
            "\t}",
            "\t/* Do not panic for oom kills triggered by sysrq */",
            "\tif (is_sysrq_oom(oc))",
            "\t\treturn;",
            "\tdump_header(oc, NULL);",
            "\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",",
            "\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");",
            "}",
            "int register_oom_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&oom_notify_list, nb);",
            "}",
            "int unregister_oom_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&oom_notify_list, nb);",
            "}",
            "bool out_of_memory(struct oom_control *oc)",
            "{",
            "\tunsigned long freed = 0;",
            "",
            "\tif (oom_killer_disabled)",
            "\t\treturn false;",
            "",
            "\tif (!is_memcg_oom(oc)) {",
            "\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);",
            "\t\tif (freed > 0 && !is_sysrq_oom(oc))",
            "\t\t\t/* Got some memory back in the last second. */",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * If current has a pending SIGKILL or is exiting, then automatically",
            "\t * select it.  The goal is to allow it to allocate so that it may",
            "\t * quickly exit and free its memory.",
            "\t */",
            "\tif (task_will_free_mem(current)) {",
            "\t\tmark_oom_victim(current);",
            "\t\tqueue_oom_reaper(current);",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * The OOM killer does not compensate for IO-less reclaim.",
            "\t * But mem_cgroup_oom() has to invoke the OOM killer even",
            "\t * if it is a GFP_NOFS allocation.",
            "\t */",
            "\tif (!(oc->gfp_mask & __GFP_FS) && !is_memcg_oom(oc))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Check if there were limitations on the allocation (only relevant for",
            "\t * NUMA and memcg) that may require different handling.",
            "\t */",
            "\toc->constraint = constrained_alloc(oc);",
            "\tif (oc->constraint != CONSTRAINT_MEMORY_POLICY)",
            "\t\toc->nodemask = NULL;",
            "\tcheck_panic_on_oom(oc);",
            "",
            "\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&",
            "\t    current->mm && !oom_unkillable_task(current) &&",
            "\t    oom_cpuset_eligible(current, oc) &&",
            "\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {",
            "\t\tget_task_struct(current);",
            "\t\toc->chosen = current;",
            "\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");",
            "\t\treturn true;",
            "\t}",
            "",
            "\tselect_bad_process(oc);",
            "\t/* Found nothing?!?! */",
            "\tif (!oc->chosen) {",
            "\t\tdump_header(oc, NULL);",
            "\t\tpr_warn(\"Out of memory and no killable processes...\\n\");",
            "\t\t/*",
            "\t\t * If we got here due to an actual allocation at the",
            "\t\t * system level, we cannot survive this and will enter",
            "\t\t * an endless loop in the allocator. Bail out now.",
            "\t\t */",
            "\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))",
            "\t\t\tpanic(\"System is deadlocked on memory\\n\");",
            "\t}",
            "\tif (oc->chosen && oc->chosen != (void *)-1UL)",
            "\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :",
            "\t\t\t\t \"Memory cgroup out of memory\");",
            "\treturn !!oc->chosen;",
            "}"
          ],
          "function_name": "oom_kill_memcg_member, oom_kill_process, check_panic_on_oom, register_oom_notifier, unregister_oom_notifier, out_of_memory",
          "description": "实现基于内存控制组的OOM处理逻辑，集成OOM通知机制，包含OOM触发判定、进程选择算法、内存组遍历杀进程等功能，支持系统级OOM恐慌检测",
          "similarity": 0.5282999277114868
        },
        {
          "chunk_id": 6,
          "file_path": "mm/oom_kill.c",
          "start_line": 826,
          "end_line": 995,
          "content": [
            "bool oom_killer_disable(signed long timeout)",
            "{",
            "\tsigned long ret;",
            "",
            "\t/*",
            "\t * Make sure to not race with an ongoing OOM killer. Check that the",
            "\t * current is not killed (possibly due to sharing the victim's memory).",
            "\t */",
            "\tif (mutex_lock_killable(&oom_lock))",
            "\t\treturn false;",
            "\toom_killer_disabled = true;",
            "\tmutex_unlock(&oom_lock);",
            "",
            "\tret = wait_event_interruptible_timeout(oom_victims_wait,",
            "\t\t\t!atomic_read(&oom_victims), timeout);",
            "\tif (ret <= 0) {",
            "\t\toom_killer_enable();",
            "\t\treturn false;",
            "\t}",
            "\tpr_info(\"OOM killer disabled.\\n\");",
            "",
            "\treturn true;",
            "}",
            "static inline bool __task_will_free_mem(struct task_struct *task)",
            "{",
            "\tstruct signal_struct *sig = task->signal;",
            "",
            "\t/*",
            "\t * A coredumping process may sleep for an extended period in",
            "\t * coredump_task_exit(), so the oom killer cannot assume that",
            "\t * the process will promptly exit and release memory.",
            "\t */",
            "\tif (sig->core_state)",
            "\t\treturn false;",
            "",
            "\tif (sig->flags & SIGNAL_GROUP_EXIT)",
            "\t\treturn true;",
            "",
            "\tif (thread_group_empty(task) && (task->flags & PF_EXITING))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static bool task_will_free_mem(struct task_struct *task)",
            "{",
            "\tstruct mm_struct *mm = task->mm;",
            "\tstruct task_struct *p;",
            "\tbool ret = true;",
            "",
            "\t/*",
            "\t * Skip tasks without mm because it might have passed its exit_mm and",
            "\t * exit_oom_victim. oom_reaper could have rescued that but do not rely",
            "\t * on that for now. We can consider find_lock_task_mm in future.",
            "\t */",
            "\tif (!mm)",
            "\t\treturn false;",
            "",
            "\tif (!__task_will_free_mem(task))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * This task has already been drained by the oom reaper so there are",
            "\t * only small chances it will free some more",
            "\t */",
            "\tif (test_bit(MMF_OOM_SKIP, &mm->flags))",
            "\t\treturn false;",
            "",
            "\tif (atomic_read(&mm->mm_users) <= 1)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Make sure that all tasks which share the mm with the given tasks",
            "\t * are dying as well to make sure that a) nobody pins its mm and",
            "\t * b) the task is also reapable by the oom reaper.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_process(p) {",
            "\t\tif (!process_shares_mm(p, mm))",
            "\t\t\tcontinue;",
            "\t\tif (same_thread_group(task, p))",
            "\t\t\tcontinue;",
            "\t\tret = __task_will_free_mem(p);",
            "\t\tif (!ret)",
            "\t\t\tbreak;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "static void __oom_kill_process(struct task_struct *victim, const char *message)",
            "{",
            "\tstruct task_struct *p;",
            "\tstruct mm_struct *mm;",
            "\tbool can_oom_reap = true;",
            "",
            "\tp = find_lock_task_mm(victim);",
            "\tif (!p) {",
            "\t\tpr_info(\"%s: OOM victim %d (%s) is already exiting. Skip killing the task\\n\",",
            "\t\t\tmessage, task_pid_nr(victim), victim->comm);",
            "\t\tput_task_struct(victim);",
            "\t\treturn;",
            "\t} else if (victim != p) {",
            "\t\tget_task_struct(p);",
            "\t\tput_task_struct(victim);",
            "\t\tvictim = p;",
            "\t}",
            "",
            "\t/* Get a reference to safely compare mm after task_unlock(victim) */",
            "\tmm = victim->mm;",
            "\tmmgrab(mm);",
            "",
            "\t/* Raise event before sending signal: task reaper must see this */",
            "\tcount_vm_event(OOM_KILL);",
            "\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);",
            "",
            "\t/*",
            "\t * We should send SIGKILL before granting access to memory reserves",
            "\t * in order to prevent the OOM victim from depleting the memory",
            "\t * reserves from the user space under its control.",
            "\t */",
            "\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);",
            "\tmark_oom_victim(victim);",
            "\tpr_err(\"%s: Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB, UID:%u pgtables:%lukB oom_score_adj:%hd\\n\",",
            "\t\tmessage, task_pid_nr(victim), victim->comm, K(mm->total_vm),",
            "\t\tK(get_mm_counter(mm, MM_ANONPAGES)),",
            "\t\tK(get_mm_counter(mm, MM_FILEPAGES)),",
            "\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)),",
            "\t\tfrom_kuid(&init_user_ns, task_uid(victim)),",
            "\t\tmm_pgtables_bytes(mm) >> 10, victim->signal->oom_score_adj);",
            "\ttask_unlock(victim);",
            "",
            "\t/*",
            "\t * Kill all user processes sharing victim->mm in other thread groups, if",
            "\t * any.  They don't get access to memory reserves, though, to avoid",
            "\t * depletion of all memory.  This prevents mm->mmap_lock livelock when an",
            "\t * oom killed thread cannot exit because it requires the semaphore and",
            "\t * its contended by another thread trying to allocate memory itself.",
            "\t * That thread will now get access to memory reserves since it has a",
            "\t * pending fatal signal.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_process(p) {",
            "\t\tif (!process_shares_mm(p, mm))",
            "\t\t\tcontinue;",
            "\t\tif (same_thread_group(p, victim))",
            "\t\t\tcontinue;",
            "\t\tif (is_global_init(p)) {",
            "\t\t\tcan_oom_reap = false;",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",",
            "\t\t\t\t\ttask_pid_nr(victim), victim->comm,",
            "\t\t\t\t\ttask_pid_nr(p), p->comm);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/*",
            "\t\t * No kthread_use_mm() user needs to read from the userspace so",
            "\t\t * we are ok to reap it.",
            "\t\t */",
            "\t\tif (unlikely(p->flags & PF_KTHREAD))",
            "\t\t\tcontinue;",
            "\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\tif (can_oom_reap)",
            "\t\tqueue_oom_reaper(victim);",
            "",
            "\tmmdrop(mm);",
            "\tput_task_struct(victim);",
            "}"
          ],
          "function_name": "oom_killer_disable, __task_will_free_mem, task_will_free_mem, __oom_kill_process",
          "description": "提供OOM杀手禁用逻辑及进程可回收性判断，实现OOM触发时的进程强制终止流程，包含共享MM处理、信号发送、内存统计等核心操作",
          "similarity": 0.518426775932312
        },
        {
          "chunk_id": 3,
          "file_path": "mm/oom_kill.c",
          "start_line": 366,
          "end_line": 466,
          "content": [
            "static void select_bad_process(struct oom_control *oc)",
            "{",
            "\toc->chosen_points = LONG_MIN;",
            "",
            "\tif (is_memcg_oom(oc))",
            "\t\tmem_cgroup_scan_tasks(oc->memcg, oom_evaluate_task, oc);",
            "\telse {",
            "\t\tstruct task_struct *p;",
            "",
            "\t\trcu_read_lock();",
            "\t\tfor_each_process(p)",
            "\t\t\tif (oom_evaluate_task(p, oc))",
            "\t\t\t\tbreak;",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static int dump_task(struct task_struct *p, void *arg)",
            "{",
            "\tstruct oom_control *oc = arg;",
            "\tstruct task_struct *task;",
            "",
            "\tif (oom_unkillable_task(p))",
            "\t\treturn 0;",
            "",
            "\t/* p may not have freeable memory in nodemask */",
            "\tif (!is_memcg_oom(oc) && !oom_cpuset_eligible(p, oc))",
            "\t\treturn 0;",
            "",
            "\ttask = find_lock_task_mm(p);",
            "\tif (!task) {",
            "\t\t/*",
            "\t\t * All of p's threads have already detached their mm's. There's",
            "\t\t * no need to report them; they can't be oom killed anyway.",
            "\t\t */",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tpr_info(\"[%7d] %5d %5d %8lu %8lu %8lu %8lu %9lu %8ld %8lu         %5hd %s\\n\",",
            "\t\ttask->pid, from_kuid(&init_user_ns, task_uid(task)),",
            "\t\ttask->tgid, task->mm->total_vm, get_mm_rss(task->mm),",
            "\t\tget_mm_counter(task->mm, MM_ANONPAGES), get_mm_counter(task->mm, MM_FILEPAGES),",
            "\t\tget_mm_counter(task->mm, MM_SHMEMPAGES), mm_pgtables_bytes(task->mm),",
            "\t\tget_mm_counter(task->mm, MM_SWAPENTS),",
            "\t\ttask->signal->oom_score_adj, task->comm);",
            "\ttask_unlock(task);",
            "",
            "\treturn 0;",
            "}",
            "static void dump_tasks(struct oom_control *oc)",
            "{",
            "\tpr_info(\"Tasks state (memory values in pages):\\n\");",
            "\tpr_info(\"[  pid  ]   uid  tgid total_vm      rss rss_anon rss_file rss_shmem pgtables_bytes swapents oom_score_adj name\\n\");",
            "",
            "\tif (is_memcg_oom(oc))",
            "\t\tmem_cgroup_scan_tasks(oc->memcg, dump_task, oc);",
            "\telse {",
            "\t\tstruct task_struct *p;",
            "\t\tint i = 0;",
            "",
            "\t\trcu_read_lock();",
            "\t\tfor_each_process(p) {",
            "\t\t\t/* Avoid potential softlockup warning */",
            "\t\t\tif ((++i & 1023) == 0)",
            "\t\t\t\ttouch_softlockup_watchdog();",
            "\t\t\tdump_task(p, oc);",
            "\t\t}",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static void dump_oom_summary(struct oom_control *oc, struct task_struct *victim)",
            "{",
            "\t/* one line summary of the oom killer context. */",
            "\tpr_info(\"oom-kill:constraint=%s,nodemask=%*pbl\",",
            "\t\t\toom_constraint_text[oc->constraint],",
            "\t\t\tnodemask_pr_args(oc->nodemask));",
            "\tcpuset_print_current_mems_allowed();",
            "\tmem_cgroup_print_oom_context(oc->memcg, victim);",
            "\tpr_cont(\",task=%s,pid=%d,uid=%d\\n\", victim->comm, victim->pid,",
            "\t\tfrom_kuid(&init_user_ns, task_uid(victim)));",
            "}",
            "static void dump_header(struct oom_control *oc, struct task_struct *p)",
            "{",
            "\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), order=%d, oom_score_adj=%hd\\n\",",
            "\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask, oc->order,",
            "\t\t\tcurrent->signal->oom_score_adj);",
            "\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)",
            "\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");",
            "",
            "\tdump_stack();",
            "\tif (is_memcg_oom(oc))",
            "\t\tmem_cgroup_print_oom_meminfo(oc->memcg);",
            "\telse {",
            "\t\t__show_mem(SHOW_MEM_FILTER_NODES, oc->nodemask, gfp_zone(oc->gfp_mask));",
            "\t\tif (should_dump_unreclaim_slab())",
            "\t\t\tdump_unreclaimable_slab();",
            "\t}",
            "\tif (sysctl_oom_dump_tasks)",
            "\t\tdump_tasks(oc);",
            "\tif (p)",
            "\t\tdump_oom_summary(oc, p);",
            "}"
          ],
          "function_name": "select_bad_process, dump_task, dump_tasks, dump_oom_summary, dump_header",
          "description": "遍历所有进程选择最优OOM目标，输出详细的进程内存状态信息，并生成OOM事件的上下文摘要报告。",
          "similarity": 0.5128198862075806
        },
        {
          "chunk_id": 5,
          "file_path": "mm/oom_kill.c",
          "start_line": 646,
          "end_line": 746,
          "content": [
            "static int oom_reaper(void *unused)",
            "{",
            "\tset_freezable();",
            "",
            "\twhile (true) {",
            "\t\tstruct task_struct *tsk = NULL;",
            "",
            "\t\twait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);",
            "\t\tspin_lock_irq(&oom_reaper_lock);",
            "\t\tif (oom_reaper_list != NULL) {",
            "\t\t\ttsk = oom_reaper_list;",
            "\t\t\toom_reaper_list = tsk->oom_reaper_list;",
            "\t\t}",
            "\t\tspin_unlock_irq(&oom_reaper_lock);",
            "",
            "\t\tif (tsk)",
            "\t\t\toom_reap_task(tsk);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void wake_oom_reaper(struct timer_list *timer)",
            "{",
            "\tstruct task_struct *tsk = container_of(timer, struct task_struct,",
            "\t\t\toom_reaper_timer);",
            "\tstruct mm_struct *mm = tsk->signal->oom_mm;",
            "\tunsigned long flags;",
            "",
            "\t/* The victim managed to terminate on its own - see exit_mmap */",
            "\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {",
            "\t\tput_task_struct(tsk);",
            "\t\treturn;",
            "\t}",
            "",
            "\tspin_lock_irqsave(&oom_reaper_lock, flags);",
            "\ttsk->oom_reaper_list = oom_reaper_list;",
            "\toom_reaper_list = tsk;",
            "\tspin_unlock_irqrestore(&oom_reaper_lock, flags);",
            "\ttrace_wake_reaper(tsk->pid);",
            "\twake_up(&oom_reaper_wait);",
            "}",
            "static void queue_oom_reaper(struct task_struct *tsk)",
            "{",
            "\t/* mm is already queued? */",
            "\tif (test_and_set_bit(MMF_OOM_REAP_QUEUED, &tsk->signal->oom_mm->flags))",
            "\t\treturn;",
            "",
            "\tget_task_struct(tsk);",
            "\ttimer_setup(&tsk->oom_reaper_timer, wake_oom_reaper, 0);",
            "\ttsk->oom_reaper_timer.expires = jiffies + OOM_REAPER_DELAY;",
            "\tadd_timer(&tsk->oom_reaper_timer);",
            "}",
            "static int __init oom_init(void)",
            "{",
            "\toom_reaper_th = kthread_run(oom_reaper, NULL, \"oom_reaper\");",
            "#ifdef CONFIG_SYSCTL",
            "\tregister_sysctl_init(\"vm\", vm_oom_kill_table);",
            "#endif",
            "\treturn 0;",
            "}",
            "static inline void queue_oom_reaper(struct task_struct *tsk)",
            "{",
            "}",
            "static void mark_oom_victim(struct task_struct *tsk)",
            "{",
            "\tconst struct cred *cred;",
            "\tstruct mm_struct *mm = tsk->mm;",
            "",
            "\tWARN_ON(oom_killer_disabled);",
            "\t/* OOM killer might race with memcg OOM */",
            "\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))",
            "\t\treturn;",
            "",
            "\t/* oom_mm is bound to the signal struct life time. */",
            "\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm))",
            "\t\tmmgrab(tsk->signal->oom_mm);",
            "",
            "\t/*",
            "\t * Make sure that the task is woken up from uninterruptible sleep",
            "\t * if it is frozen because OOM killer wouldn't be able to free",
            "\t * any memory and livelock. freezing_slow_path will tell the freezer",
            "\t * that TIF_MEMDIE tasks should be ignored.",
            "\t */",
            "\t__thaw_task(tsk);",
            "\tatomic_inc(&oom_victims);",
            "\tcred = get_task_cred(tsk);",
            "\ttrace_mark_victim(tsk, cred->uid.val);",
            "\tput_cred(cred);",
            "}",
            "void exit_oom_victim(void)",
            "{",
            "\tclear_thread_flag(TIF_MEMDIE);",
            "",
            "\tif (!atomic_dec_return(&oom_victims))",
            "\t\twake_up_all(&oom_victims_wait);",
            "}",
            "void oom_killer_enable(void)",
            "{",
            "\toom_killer_disabled = false;",
            "\tpr_info(\"OOM killer enabled.\\n\");",
            "}"
          ],
          "function_name": "oom_reaper, wake_oom_reaper, queue_oom_reaper, oom_init, queue_oom_reaper, mark_oom_victim, exit_oom_victim, oom_killer_enable",
          "description": "定义OOM杀手线程及其管理逻辑，通过等待队列和自旋锁协调进程回收，支持定时唤醒和任务标记机制，初始化OOM杀手线程并注册sysctl接口，部分函数存在重复定义导致上下文不完整",
          "similarity": 0.5083680152893066
        }
      ]
    }
  ]
}