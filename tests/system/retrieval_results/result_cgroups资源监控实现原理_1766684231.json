{
  "query": "cgroups资源监控实现原理",
  "timestamp": "2025-12-26 01:37:11",
  "retrieved_files": [
    {
      "source_file": "kernel/cgroup/misc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:48:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\misc.c`\n\n---\n\n# cgroup/misc.c 技术文档\n\n## 文件概述\n\n`cgroup/misc.c` 实现了一个通用的 **miscellaneous cgroup controller（杂项资源控制组控制器）**，用于对系统中非传统类型的资源（如 AMD SEV/SEV-ES ASID 等安全加密虚拟化资源）进行配额管理和使用量跟踪。该控制器采用 **Limits 资源分配模型**，允许为每个 cgroup 设置资源使用上限（max），并确保整个系统的总使用量不超过主机实际容量（capacity）。该模块支持资源的尝试性计费（try-charge）、取消计费（uncharge）、容量设置、使用量查询及事件通知等功能。\n\n## 核心功能\n\n### 主要数据结构\n\n- `struct misc_cg`：表示一个 misc cgroup 实例，包含每种资源类型的 `struct misc_res`。\n- `struct misc_res`（定义在 `<linux/misc_cgroup.h>`）：\n  - `usage`：当前资源使用量（`atomic64_t`）\n  - `max`：该 cgroup 的资源使用上限（`u64`）\n  - `watermark`：历史峰值使用量（`atomic64_t`）\n  - `events` / `events_local`：事件计数器（用于通知）\n- `misc_res_capacity[MISC_CG_RES_TYPES]`：全局数组，记录每种资源在整机上的实际容量。\n- `root_cg`：根 misc cgroup 实例。\n- `misc_res_name[]`：资源类型的字符串名称映射（与 `enum misc_res_type` 同步）。\n\n### 主要导出函数（API）\n\n- `misc_cg_set_capacity(enum misc_res_type type, u64 capacity)`  \n  设置指定资源类型的整机容量。容量为 0 表示该资源不可用。\n- `misc_cg_try_charge(enum misc_res_type type, struct misc_cg *cg, u64 amount)`  \n  尝试对指定 cgroup 计费指定资源量。若超过该 cgroup 的 `max` 限制或整机 `capacity`，则失败并回滚。\n- `misc_cg_uncharge(enum misc_res_type type, struct misc_cg *cg, u64 amount)`  \n  从指定 cgroup 取消指定资源量的计费。\n- `misc_cg_res_total_usage(enum misc_res_type type)`  \n  获取指定资源类型的全局总使用量（即根 cgroup 的 usage）。\n\n### 主要内部函数\n\n- `parent_misc()`：获取 misc cgroup 的父节点。\n- `valid_type()`：验证资源类型是否有效。\n- `misc_cg_cancel_charge()`：原子地减少资源使用量，并检查负值（使用 `WARN_ONCE`）。\n- `misc_cg_update_watermark()`：原子地更新资源使用峰值（watermark）。\n- `misc_cg_event()`：触发资源事件通知（本地及向上传播到祖先）。\n- `misc_cg_max_show/write`：实现 `misc.max` 接口文件的读写。\n- `misc_cg_current_show`：实现 `misc.current` 接口文件的读取。\n- `misc_cg_peak_show`：实现 `misc.peak` 接口文件的读取（代码未完整显示，但可推断）。\n\n## 关键实现\n\n### 资源计费与回滚机制\n- **计费流程**：从目标 cgroup 向上遍历至根 cgroup，依次原子增加各层级的 `usage`。\n- **限制检查**：每层检查 `new_usage <= res->max` 且 `new_usage <= misc_res_capacity[type]`。\n- **失败回滚**：若任一层检查失败，立即触发事件通知，并从目标 cgroup 到失败层（含）逐层原子减少已增加的 `usage`，保证状态一致性。\n\n### 原子操作与并发安全\n- 所有资源使用量（`usage`）、峰值（`watermark`）和事件计数均使用 `atomic64_t` 类型，确保多线程/多 CPU 环境下的安全访问。\n- 容量（`misc_res_capacity`）和上限（`max`）使用 `READ_ONCE`/`WRITE_ONCE` 进行访问，避免编译器优化导致的不一致。\n\n### 接口文件实现\n- **`misc.max`**：\n  - **读**：输出每种已启用资源（`capacity > 0`）的 `max` 值；若为 `U64_MAX` 则显示为 `\"max\"`。\n  - **写**：格式为 `\"<resource_name> <value>\"`，`value` 可为正整数或 `\"max\"`（表示无限制）。\n- **`misc.current`**：输出每种资源（只要 `capacity > 0` 或 `usage > 0`）的当前使用量。\n- **`misc.peak`**（推断）：输出每种资源的历史峰值使用量（`watermark`）。\n\n### 事件通知\n- 当计费失败时，调用 `misc_cg_event()`：\n  - 增加当前 cgroup 的本地事件计数器（`events_local`）并通知 `events_local_file`。\n  - 向上遍历所有祖先 cgroup，增加其全局事件计数器（`events`）并通知 `events_file`。\n\n## 依赖关系\n\n- **内核头文件**：\n  - `<linux/cgroup.h>`：cgroup 核心框架。\n  - `<linux/misc_cgroup.h>`：定义 `struct misc_cg`、`struct misc_res`、`enum misc_res_type` 等关键数据结构和类型。\n  - `<linux/atomic.h>`：提供原子操作。\n  - `<linux/slab.h>`：内存分配。\n- **配置选项**：\n  - `CONFIG_KVM_AMD_SEV`：决定是否启用 `\"sev\"` 和 `\"sev_es\"` 资源类型。\n- **其他模块**：\n  - **KVM 模块**：在启用 AMD SEV/SEV-ES 时，会调用本模块的 API（如 `misc_cg_try_charge`/`misc_cg_uncharge`）来管理 ASID 资源。\n  - **cgroup 核心**：通过 `css_misc()`、`cgroup_file_notify()` 等接口与 cgroup 子系统集成。\n\n## 使用场景\n\n1. **AMD SEV/SEV-ES 资源管理**：\n   - 在支持 AMD 安全加密虚拟化（SEV/SEV-ES）的系统中，ASID（Address Space Identifier）是一种有限的硬件资源。\n   - KVM 模块在创建/销毁 SEV 虚拟机时，通过 `misc_cg_try_charge`/`misc_cg_uncharge` 对当前进程所属的 misc cgroup 进行 ASID 资源计费。\n   - 管理员可通过 `misc.max` 文件为不同 cgroup 设置 ASID 使用上限，防止单个用户或服务耗尽全局 ASID 资源。\n\n2. **通用杂项资源控制框架**：\n   - 该控制器设计为可扩展，未来可支持其他类型的有限系统资源（如特定硬件加速器的上下文、特殊内存区域等）。\n   - 通过 `misc_cg_set_capacity` 在系统初始化时注册资源容量，通过标准 cgroup 接口进行配额分配和监控。\n\n3. **资源监控与告警**：\n   - 用户空间可通过读取 `misc.current` 和 `misc.peak` 监控资源使用情况。\n   - 当资源分配失败（如达到 `max` 限制）时，内核会更新事件计数器，用户空间可通过 `inotify` 或轮询 `misc.events` 文件获取通知，实现自动化告警或扩缩容。",
      "similarity": 0.6599913835525513,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 401,
          "end_line": 408,
          "content": [
            "static int misc_events_local_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn __misc_events_show(sf, true);",
            "}",
            "static void misc_cg_free(struct cgroup_subsys_state *css)",
            "{",
            "\tkfree(css_misc(css));",
            "}"
          ],
          "function_name": "misc_events_local_show, misc_cg_free",
          "description": "实现本地事件统计展示接口和cgroup子系统状态释放函数，用于清理misc控制器相关内存资源",
          "similarity": 0.6367474794387817
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 1,
          "end_line": 64,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Miscellaneous cgroup controller",
            " *",
            " * Copyright 2020 Google LLC",
            " * Author: Vipin Sharma <vipinsh@google.com>",
            " */",
            "",
            "#include <linux/limits.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/errno.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/misc_cgroup.h>",
            "",
            "#define MAX_STR \"max\"",
            "#define MAX_NUM U64_MAX",
            "",
            "/* Miscellaneous res name, keep it in sync with enum misc_res_type */",
            "static const char *const misc_res_name[] = {",
            "#ifdef CONFIG_KVM_AMD_SEV",
            "\t/* AMD SEV ASIDs resource */",
            "\t\"sev\",",
            "\t/* AMD SEV-ES ASIDs resource */",
            "\t\"sev_es\",",
            "#endif",
            "};",
            "",
            "/* Root misc cgroup */",
            "static struct misc_cg root_cg;",
            "",
            "/*",
            " * Miscellaneous resources capacity for the entire machine. 0 capacity means",
            " * resource is not initialized or not present in the host.",
            " *",
            " * root_cg.max and capacity are independent of each other. root_cg.max can be",
            " * more than the actual capacity. We are using Limits resource distribution",
            " * model of cgroup for miscellaneous controller.",
            " */",
            "static u64 misc_res_capacity[MISC_CG_RES_TYPES];",
            "",
            "/**",
            " * parent_misc() - Get the parent of the passed misc cgroup.",
            " * @cgroup: cgroup whose parent needs to be fetched.",
            " *",
            " * Context: Any context.",
            " * Return:",
            " * * struct misc_cg* - Parent of the @cgroup.",
            " * * %NULL - If @cgroup is null or the passed cgroup does not have a parent.",
            " */",
            "static struct misc_cg *parent_misc(struct misc_cg *cgroup)",
            "{",
            "\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;",
            "}",
            "",
            "/**",
            " * valid_type() - Check if @type is valid or not.",
            " * @type: misc res type.",
            " *",
            " * Context: Any context.",
            " * Return:",
            " * * true - If valid type.",
            " * * false - If not valid type.",
            " */"
          ],
          "function_name": null,
          "description": "定义misc控制器的资源名称数组和根cgroup结构，提供父节点查询函数，用于管理杂项资源的层级关系和容量配置",
          "similarity": 0.6316807270050049
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 65,
          "end_line": 175,
          "content": [
            "static inline bool valid_type(enum misc_res_type type)",
            "{",
            "\treturn type >= 0 && type < MISC_CG_RES_TYPES;",
            "}",
            "u64 misc_cg_res_total_usage(enum misc_res_type type)",
            "{",
            "\tif (valid_type(type))",
            "\t\treturn atomic64_read(&root_cg.res[type].usage);",
            "",
            "\treturn 0;",
            "}",
            "int misc_cg_set_capacity(enum misc_res_type type, u64 capacity)",
            "{",
            "\tif (!valid_type(type))",
            "\t\treturn -EINVAL;",
            "",
            "\tWRITE_ONCE(misc_res_capacity[type], capacity);",
            "\treturn 0;",
            "}",
            "static void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,",
            "\t\t\t\t  u64 amount)",
            "{",
            "\tWARN_ONCE(atomic64_add_negative(-amount, &cg->res[type].usage),",
            "\t\t  \"misc cgroup resource %s became less than 0\",",
            "\t\t  misc_res_name[type]);",
            "}",
            "static void misc_cg_update_watermark(struct misc_res *res, u64 new_usage)",
            "{",
            "\tu64 old;",
            "",
            "\twhile (true) {",
            "\t\told = atomic64_read(&res->watermark);",
            "\t\tif (new_usage <= old)",
            "\t\t\tbreak;",
            "\t\tif (atomic64_cmpxchg(&res->watermark, old, new_usage) == old)",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "static void misc_cg_event(enum misc_res_type type, struct misc_cg *cg)",
            "{",
            "\tatomic64_inc(&cg->res[type].events_local);",
            "\tcgroup_file_notify(&cg->events_local_file);",
            "",
            "\tfor (; parent_misc(cg); cg = parent_misc(cg)) {",
            "\t\tatomic64_inc(&cg->res[type].events);",
            "\t\tcgroup_file_notify(&cg->events_file);",
            "\t}",
            "}",
            "int misc_cg_try_charge(enum misc_res_type type, struct misc_cg *cg, u64 amount)",
            "{",
            "\tstruct misc_cg *i, *j;",
            "\tint ret;",
            "\tstruct misc_res *res;",
            "\tu64 new_usage;",
            "",
            "\tif (!(valid_type(type) && cg && READ_ONCE(misc_res_capacity[type])))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!amount)",
            "\t\treturn 0;",
            "",
            "\tfor (i = cg; i; i = parent_misc(i)) {",
            "\t\tres = &i->res[type];",
            "",
            "\t\tnew_usage = atomic64_add_return(amount, &res->usage);",
            "\t\tif (new_usage > READ_ONCE(res->max) ||",
            "\t\t    new_usage > READ_ONCE(misc_res_capacity[type])) {",
            "\t\t\tret = -EBUSY;",
            "\t\t\tgoto err_charge;",
            "\t\t}",
            "\t\tmisc_cg_update_watermark(res, new_usage);",
            "\t}",
            "\treturn 0;",
            "",
            "err_charge:",
            "\tmisc_cg_event(type, i);",
            "",
            "\tfor (j = cg; j != i; j = parent_misc(j))",
            "\t\tmisc_cg_cancel_charge(type, j, amount);",
            "\tmisc_cg_cancel_charge(type, i, amount);",
            "\treturn ret;",
            "}",
            "void misc_cg_uncharge(enum misc_res_type type, struct misc_cg *cg, u64 amount)",
            "{",
            "\tstruct misc_cg *i;",
            "",
            "\tif (!(amount && valid_type(type) && cg))",
            "\t\treturn;",
            "",
            "\tfor (i = cg; i; i = parent_misc(i))",
            "\t\tmisc_cg_cancel_charge(type, i, amount);",
            "}",
            "static int misc_cg_max_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "\tu64 max;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tif (READ_ONCE(misc_res_capacity[i])) {",
            "\t\t\tmax = READ_ONCE(cg->res[i].max);",
            "\t\t\tif (max == MAX_NUM)",
            "\t\t\t\tseq_printf(sf, \"%s max\\n\", misc_res_name[i]);",
            "\t\t\telse",
            "\t\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i],",
            "\t\t\t\t\t   max);",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "valid_type, misc_cg_res_total_usage, misc_cg_set_capacity, misc_cg_cancel_charge, misc_cg_update_watermark, misc_cg_event, misc_cg_try_charge, misc_cg_uncharge, misc_cg_max_show",
          "description": "实现资源类型有效性验证、总使用量查询、容量设置、资源充放电控制及水位更新逻辑，支持递归充电检查与事件通知机制",
          "similarity": 0.5134555697441101
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 266,
          "end_line": 368,
          "content": [
            "static ssize_t misc_cg_max_write(struct kernfs_open_file *of, char *buf,",
            "\t\t\t\t size_t nbytes, loff_t off)",
            "{",
            "\tstruct misc_cg *cg;",
            "\tu64 max;",
            "\tint ret = 0, i;",
            "\tenum misc_res_type type = MISC_CG_RES_TYPES;",
            "\tchar *token;",
            "",
            "\tbuf = strstrip(buf);",
            "\ttoken = strsep(&buf, \" \");",
            "",
            "\tif (!token || !buf)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tif (!strcmp(misc_res_name[i], token)) {",
            "\t\t\ttype = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (type == MISC_CG_RES_TYPES)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!strcmp(MAX_STR, buf)) {",
            "\t\tmax = MAX_NUM;",
            "\t} else {",
            "\t\tret = kstrtou64(buf, 0, &max);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tcg = css_misc(of_css(of));",
            "",
            "\tif (READ_ONCE(misc_res_capacity[type]))",
            "\t\tWRITE_ONCE(cg->res[type].max, max);",
            "\telse",
            "\t\tret = -EINVAL;",
            "",
            "\treturn ret ? ret : nbytes;",
            "}",
            "static int misc_cg_current_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tu64 usage;",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tusage = atomic64_read(&cg->res[i].usage);",
            "\t\tif (READ_ONCE(misc_res_capacity[i]) || usage)",
            "\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], usage);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int misc_cg_peak_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tu64 watermark;",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\twatermark = atomic64_read(&cg->res[i].watermark);",
            "\t\tif (READ_ONCE(misc_res_capacity[i]) || watermark)",
            "\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], watermark);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int misc_cg_capacity_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tu64 cap;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tcap = READ_ONCE(misc_res_capacity[i]);",
            "\t\tif (cap)",
            "\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], cap);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __misc_events_show(struct seq_file *sf, bool local)",
            "{",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "\tu64 events;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tif (local)",
            "\t\t\tevents = atomic64_read(&cg->res[i].events_local);",
            "\t\telse",
            "\t\t\tevents = atomic64_read(&cg->res[i].events);",
            "\t\tif (READ_ONCE(misc_res_capacity[i]) || events)",
            "\t\t\tseq_printf(sf, \"%s.max %llu\\n\", misc_res_name[i], events);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int misc_events_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn __misc_events_show(sf, false);",
            "}"
          ],
          "function_name": "misc_cg_max_write, misc_cg_current_show, misc_cg_peak_show, misc_cg_capacity_show, __misc_events_show, misc_events_show",
          "description": "提供资源最大值写入接口和当前使用量、峰值、容量展示接口，支持通过seq_file接口暴露资源统计信息到用户空间",
          "similarity": 0.49899744987487793
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/cgroup.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:42:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\cgroup.c`\n\n---\n\n# cgroup/cgroup.c 技术文档\n\n## 1. 文件概述\n\n`cgroup/cgroup.c` 是 Linux 内核中控制组（Control Group, cgroup）子系统的核心实现文件。它提供了通用的进程分组机制，用于对进程进行资源限制、优先级分配、资源统计和进程控制。该文件实现了 cgroup v2 统一层次结构（unified hierarchy）的基础框架，包括 cgroup 的创建、销毁、层级管理、子系统（subsystem/controller）注册与回调、文件系统接口、命名空间支持以及与 RCU、工作队列等内核机制的集成。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n\n- **`cgroup_mutex`**：cgroup 系统的主互斥锁，任何对 cgroup 层级结构或配置的修改都必须持有此锁。\n- **`css_set_lock`**：自旋锁，保护任务的 `task->cgroups` 指针、`css_set` 对象链表以及每个 `css_set` 关联的任务链。\n- **`cgroup_subsys[]`**：指向所有已注册 cgroup 子系统的指针数组，通过 `cgroup_subsys.h` 自动生成。\n- **`cgroup_subsys_name[]`**：各子系统的名称字符串数组。\n- **`cgroup_subsys_enabled_key[]` / `cgroup_subsys_on_dfl_key[]`**：静态键（static_key）数组，用于高效判断子系统是否启用或是否在默认层级（v2）上启用。\n- **`cgrp_dfl_root`**：默认 cgroup 层级（v2）的根节点。\n- **`cgroup_roots`**：所有已挂载 cgroup 层级根节点的链表。\n- **`init_cgroup_ns`**：初始 cgroup 命名空间，供 init 进程使用。\n- **`cgroup_destroy_wq`**：专用工作队列，用于异步销毁 cgroup，避免阻塞系统工作队列。\n\n### 关键静态变量\n\n- **`cgrp_dfl_visible`**：标志默认层级是否已挂载（首次挂载后可见）。\n- **`cgrp_dfl_inhibit_ss_mask` / `cgrp_dfl_implicit_ss_mask` / `cgrp_dfl_threaded_ss_mask`**：位掩码，分别表示在默认层级中被禁止、隐式启用和可线程化的子系统。\n- **`have_fork_callback` 等**：位掩码，记录哪些子系统实现了特定生命周期回调（如 fork、exit、release、can_fork）。\n- **`css_serial_nr_next`**：全局递增序列号，用于保证 cgroup 创建顺序和兄弟节点排序。\n\n### 核心函数（声明/定义）\n\n- **`cgroup_apply_control()`**：应用对 cgroup 的控制策略变更。\n- **`cgroup_finalize_control()`**：完成控制策略变更的最终处理。\n- **`cgroup_destroy_locked()`**：在持有 `cgroup_mutex` 的情况下销毁 cgroup。\n- **`css_create()`**：为指定 cgroup 和子系统创建 `cgroup_subsys_state`（css）。\n- **`css_release()`**：css 引用计数归零时的释放回调。\n- **`kill_css()`**：终止并清理一个 css。\n- **`css_task_iter_skip()`**：在遍历任务时跳过特定任务。\n- **`cgroup_addrm_files()`**：向 cgroup 目录动态添加或移除控制文件。\n\n## 3. 关键实现\n\n### 锁机制设计\n- **`cgroup_mutex`** 作为主锁，保护所有结构性变更（如创建/销毁 cgroup、挂载/卸载层级）。\n- **`css_set_lock`** 保护任务与 css_set 的关联关系，允许在不持有主锁的情况下快速读取任务的 cgroup 成员关系。\n- **`cgroup_idr_lock`** 保护 ID 分配器（`cgroup_idr` 和 `css_idr`），允许在不持有 `cgroup_mutex` 的情况下释放 ID。\n- **`cgroup_file_kn_lock`** 同步通知机制与文件节点（kn）的创建/销毁，尤其在 css 隐藏/显示时。\n- **`cgroup_threadgroup_rwsem`**（percpu rwsem）用于线程组操作的同步。\n\n### 子系统管理\n- 通过宏 `SUBSYS()` 和头文件 `linux/cgroup_subsys.h` 自动生成子系统数组、名称数组和静态键数组，实现编译期配置。\n- 使用 `static_key` 优化运行时检查（如 `cgroup_subsys_enabled()`），避免分支预测开销。\n- 位掩码（如 `have_fork_callback`）用于快速判断哪些子系统需要调用特定回调，避免遍历所有子系统。\n\n### 默认层级（v2）支持\n- `cgrp_dfl_root` 代表统一的 cgroup v2 层级，初始隐藏，首次挂载后变为可见。\n- 通过 `cgrp_dfl_inhibit_ss_mask` 等掩码控制哪些子系统可在 v2 中使用、是否自动启用或支持线程化模式。\n\n### 资源销毁与异步处理\n- 使用专用工作队列 `cgroup_destroy_wq` 处理 cgroup 销毁，防止大量并发销毁操作阻塞 `system_wq` 导致死锁。\n- css 的生命周期通过 `percpu_ref` 管理，`css_release()` 在引用归零时触发异步清理。\n\n### 调试与追踪\n- `trace_cgroup_path` 和 `trace_cgroup_path_lock` 用于追踪事件中记录 cgroup 路径。\n- `cgroup_debug` 全局开关控制调试输出。\n- 定义了 `CREATE_TRACE_POINTS` 以生成 cgroup 相关的 tracepoint。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `cgroup-internal.h`：cgroup 内部实现头文件。\n  - 多个内核子系统头文件：`sched.h`（调度）、`cred.h`（凭证）、`nsproxy.h`（命名空间）、`bpf-cgroup.h`（BPF 集成）、`psi.h`（压力指标）等。\n- **子系统依赖**：\n  - 所有 cgroup 子系统（如 `cpuset`、`memory`、`cpu` 等）通过 `cgroup_subsys.h` 注册到此框架。\n  - 依赖 `sysfs` 的设计思想（源自 Patrick Mochel）。\n- **内核机制依赖**：\n  - RCU（读-拷贝-更新）用于无锁读取。\n  - IDR（整数 ID 管理器）用于分配 cgroup 和 css 的唯一 ID。\n  - 工作队列（workqueue）用于异步销毁。\n  - 静态键（static_key）用于运行时优化。\n  - percpu 变量用于性能敏感数据（如 `cgrp_dfl_root_rstat_cpu`）。\n\n## 5. 使用场景\n\n- **容器运行时**（如 Docker、containerd）：通过挂载 cgroup v2 文件系统并写入进程 PID 到 `cgroup.procs`，实现对容器内进程的资源隔离与限制。\n- **系统资源管理器**（如 systemd）：使用 cgroup 层级组织服务进程，实施 CPU、内存、IO 等资源配额。\n- **内核子系统集成**：各资源控制器（如内存、CPU 调度器、blkio）通过注册 cgroup 子系统，将其资源管理策略与 cgroup 框架绑定。\n- **性能监控与调试**：通过 cgroup 提供的接口（如 `memory.stat`、`cpu.stat`）获取进程组的资源使用统计。\n- **安全隔离**：结合用户命名空间（user namespace）和 cgroup，实现多租户环境下的资源隔离。\n- **BPF 程序挂载**：通过 `bpf-cgroup` 接口，将 BPF 程序附加到 cgroup 上，实现网络、安全等策略的分组应用。",
      "similarity": 0.650212824344635,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 1560,
          "end_line": 1665,
          "content": [
            "static umode_t cgroup_file_mode(const struct cftype *cft)",
            "{",
            "\tumode_t mode = 0;",
            "",
            "\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)",
            "\t\tmode |= S_IRUGO;",
            "",
            "\tif (cft->write_u64 || cft->write_s64 || cft->write) {",
            "\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)",
            "\t\t\tmode |= S_IWUGO;",
            "\t\telse",
            "\t\t\tmode |= S_IWUSR;",
            "\t}",
            "",
            "\treturn mode;",
            "}",
            "static u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)",
            "{",
            "\tu16 cur_ss_mask = subtree_control;",
            "\tstruct cgroup_subsys *ss;",
            "\tint ssid;",
            "",
            "\tlockdep_assert_held(&cgroup_mutex);",
            "",
            "\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;",
            "",
            "\twhile (true) {",
            "\t\tu16 new_ss_mask = cur_ss_mask;",
            "",
            "\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {",
            "\t\t\tnew_ss_mask |= ss->depends_on;",
            "\t\t} while_each_subsys_mask();",
            "",
            "\t\t/*",
            "\t\t * Mask out subsystems which aren't available.  This can",
            "\t\t * happen only if some depended-upon subsystems were bound",
            "\t\t * to non-default hierarchies.",
            "\t\t */",
            "\t\tnew_ss_mask &= this_ss_mask;",
            "",
            "\t\tif (new_ss_mask == cur_ss_mask)",
            "\t\t\tbreak;",
            "\t\tcur_ss_mask = new_ss_mask;",
            "\t}",
            "",
            "\treturn cur_ss_mask;",
            "}",
            "void cgroup_kn_unlock(struct kernfs_node *kn)",
            "{",
            "\tstruct cgroup *cgrp;",
            "",
            "\tif (kernfs_type(kn) == KERNFS_DIR)",
            "\t\tcgrp = kn->priv;",
            "\telse",
            "\t\tcgrp = kn->parent->priv;",
            "",
            "\tcgroup_unlock();",
            "",
            "\tkernfs_unbreak_active_protection(kn);",
            "\tcgroup_put(cgrp);",
            "}",
            "static void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)",
            "{",
            "\tchar name[CGROUP_FILE_NAME_MAX];",
            "",
            "\tlockdep_assert_held(&cgroup_mutex);",
            "",
            "\tif (cft->file_offset) {",
            "\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);",
            "\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;",
            "",
            "\t\tspin_lock_irq(&cgroup_file_kn_lock);",
            "\t\tcfile->kn = NULL;",
            "\t\tspin_unlock_irq(&cgroup_file_kn_lock);",
            "",
            "\t\tdel_timer_sync(&cfile->notify_timer);",
            "\t}",
            "",
            "\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));",
            "}",
            "static void css_clear_dir(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct cgroup *cgrp = css->cgroup;",
            "\tstruct cftype *cfts;",
            "",
            "\tif (!(css->flags & CSS_VISIBLE))",
            "\t\treturn;",
            "",
            "\tcss->flags &= ~CSS_VISIBLE;",
            "",
            "\tif (!css->ss) {",
            "\t\tif (cgroup_on_dfl(cgrp)) {",
            "\t\t\tcgroup_addrm_files(css, cgrp,",
            "\t\t\t\t\t   cgroup_base_files, false);",
            "\t\t\tif (cgroup_psi_enabled())",
            "\t\t\t\tcgroup_addrm_files(css, cgrp,",
            "\t\t\t\t\t\t   cgroup_psi_files, false);",
            "\t\t} else {",
            "\t\t\tcgroup_addrm_files(css, cgrp,",
            "\t\t\t\t\t   cgroup1_base_files, false);",
            "\t\t}",
            "\t} else {",
            "\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)",
            "\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);",
            "\t}",
            "}"
          ],
          "function_name": "cgroup_file_mode, cgroup_calc_subtree_ss_mask, cgroup_kn_unlock, cgroup_rm_file, css_clear_dir",
          "description": "定义了cgroup文件权限计算逻辑，根据读写操作类型设置相应权限位；计算子系统掩码以确定可访问的控制器；解锁cgroup节点并释放引用；移除特定子系统的文件条目；清除子系统目录可见性并重新绑定基础文件操作。",
          "similarity": 0.6036603450775146
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 291,
          "end_line": 392,
          "content": [
            "bool cgroup_ssid_enabled(int ssid)",
            "{",
            "\tif (!CGROUP_HAS_SUBSYS_CONFIG)",
            "\t\treturn false;",
            "",
            "\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);",
            "}",
            "bool cgroup_on_dfl(const struct cgroup *cgrp)",
            "{",
            "\treturn cgrp->root == &cgrp_dfl_root;",
            "}",
            "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,",
            "\t\t\t    gfp_t gfp_mask)",
            "{",
            "\tint ret;",
            "",
            "\tidr_preload(gfp_mask);",
            "\tspin_lock_bh(&cgroup_idr_lock);",
            "\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);",
            "\tspin_unlock_bh(&cgroup_idr_lock);",
            "\tidr_preload_end();",
            "\treturn ret;",
            "}",
            "static void cgroup_idr_remove(struct idr *idr, int id)",
            "{",
            "\tspin_lock_bh(&cgroup_idr_lock);",
            "\tidr_remove(idr, id);",
            "\tspin_unlock_bh(&cgroup_idr_lock);",
            "}",
            "static bool cgroup_has_tasks(struct cgroup *cgrp)",
            "{",
            "\treturn cgrp->nr_populated_csets;",
            "}",
            "static bool cgroup_is_threaded(struct cgroup *cgrp)",
            "{",
            "\treturn cgrp->dom_cgrp != cgrp;",
            "}",
            "static bool cgroup_is_mixable(struct cgroup *cgrp)",
            "{",
            "\t/*",
            "\t * Root isn't under domain level resource control exempting it from",
            "\t * the no-internal-process constraint, so it can serve as a thread",
            "\t * root and a parent of resource domains at the same time.",
            "\t */",
            "\treturn !cgroup_parent(cgrp);",
            "}",
            "static bool cgroup_can_be_thread_root(struct cgroup *cgrp)",
            "{",
            "\t/* mixables don't care */",
            "\tif (cgroup_is_mixable(cgrp))",
            "\t\treturn true;",
            "",
            "\t/* domain roots can't be nested under threaded */",
            "\tif (cgroup_is_threaded(cgrp))",
            "\t\treturn false;",
            "",
            "\t/* can only have either domain or threaded children */",
            "\tif (cgrp->nr_populated_domain_children)",
            "\t\treturn false;",
            "",
            "\t/* and no domain controllers can be enabled */",
            "\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static bool cgroup_is_thread_root(struct cgroup *cgrp)",
            "{",
            "\t/* thread root should be a domain */",
            "\tif (cgroup_is_threaded(cgrp))",
            "\t\treturn false;",
            "",
            "\t/* a domain w/ threaded children is a thread root */",
            "\tif (cgrp->nr_threaded_children)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * A domain which has tasks and explicit threaded controllers",
            "\t * enabled is a thread root.",
            "\t */",
            "\tif (cgroup_has_tasks(cgrp) &&",
            "\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static bool cgroup_is_valid_domain(struct cgroup *cgrp)",
            "{",
            "\t/* the cgroup itself can be a thread root */",
            "\tif (cgroup_is_threaded(cgrp))",
            "\t\treturn false;",
            "",
            "\t/* but the ancestors can't be unless mixable */",
            "\twhile ((cgrp = cgroup_parent(cgrp))) {",
            "\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))",
            "\t\t\treturn false;",
            "\t\tif (cgroup_is_threaded(cgrp))",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "cgroup_ssid_enabled, cgroup_on_dfl, cgroup_idr_alloc, cgroup_idr_remove, cgroup_has_tasks, cgroup_is_threaded, cgroup_is_mixable, cgroup_can_be_thread_root, cgroup_is_thread_root, cgroup_is_valid_domain",
          "description": "提供了多个辅助函数用于cgroup管理，包括检查子系统是否启用（cgroup_ssid_enabled）、判断是否处于默认层级（cgroup_on_dfl）、ID分配/移除（cgroup_idr_*）、任务存在检测（cgroup_has_tasks）及线程化属性判断（cgroup_is_threaded等）。",
          "similarity": 0.5986923575401306
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 462,
          "end_line": 563,
          "content": [
            "static u16 cgroup_control(struct cgroup *cgrp)",
            "{",
            "\tstruct cgroup *parent = cgroup_parent(cgrp);",
            "\tu16 root_ss_mask = cgrp->root->subsys_mask;",
            "",
            "\tif (parent) {",
            "\t\tu16 ss_mask = parent->subtree_control;",
            "",
            "\t\t/* threaded cgroups can only have threaded controllers */",
            "\t\tif (cgroup_is_threaded(cgrp))",
            "\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;",
            "\t\treturn ss_mask;",
            "\t}",
            "",
            "\tif (cgroup_on_dfl(cgrp))",
            "\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |",
            "\t\t\t\t  cgrp_dfl_implicit_ss_mask);",
            "\treturn root_ss_mask;",
            "}",
            "static u16 cgroup_ss_mask(struct cgroup *cgrp)",
            "{",
            "\tstruct cgroup *parent = cgroup_parent(cgrp);",
            "",
            "\tif (parent) {",
            "\t\tu16 ss_mask = parent->subtree_ss_mask;",
            "",
            "\t\t/* threaded cgroups can only have threaded controllers */",
            "\t\tif (cgroup_is_threaded(cgrp))",
            "\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;",
            "\t\treturn ss_mask;",
            "\t}",
            "",
            "\treturn cgrp->root->subsys_mask;",
            "}",
            "static void cgroup_get_live(struct cgroup *cgrp)",
            "{",
            "\tWARN_ON_ONCE(cgroup_is_dead(cgrp));",
            "\tcgroup_get(cgrp);",
            "}",
            "int __cgroup_task_count(const struct cgroup *cgrp)",
            "{",
            "\tint count = 0;",
            "\tstruct cgrp_cset_link *link;",
            "",
            "\tlockdep_assert_held(&css_set_lock);",
            "",
            "\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)",
            "\t\tcount += link->cset->nr_tasks;",
            "",
            "\treturn count;",
            "}",
            "int cgroup_task_count(const struct cgroup *cgrp)",
            "{",
            "\tint count;",
            "",
            "\tspin_lock_irq(&css_set_lock);",
            "\tcount = __cgroup_task_count(cgrp);",
            "\tspin_unlock_irq(&css_set_lock);",
            "",
            "\treturn count;",
            "}",
            "static bool css_set_threaded(struct css_set *cset)",
            "{",
            "\treturn cset->dom_cset != cset;",
            "}",
            "static bool css_set_populated(struct css_set *cset)",
            "{",
            "\tlockdep_assert_held(&css_set_lock);",
            "",
            "\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);",
            "}",
            "static void cgroup_update_populated(struct cgroup *cgrp, bool populated)",
            "{",
            "\tstruct cgroup *child = NULL;",
            "\tint adj = populated ? 1 : -1;",
            "",
            "\tlockdep_assert_held(&css_set_lock);",
            "",
            "\tdo {",
            "\t\tbool was_populated = cgroup_is_populated(cgrp);",
            "",
            "\t\tif (!child) {",
            "\t\t\tcgrp->nr_populated_csets += adj;",
            "\t\t} else {",
            "\t\t\tif (cgroup_is_threaded(child))",
            "\t\t\t\tcgrp->nr_populated_threaded_children += adj;",
            "\t\t\telse",
            "\t\t\t\tcgrp->nr_populated_domain_children += adj;",
            "\t\t}",
            "",
            "\t\tif (was_populated == cgroup_is_populated(cgrp))",
            "\t\t\tbreak;",
            "",
            "\t\tcgroup1_check_for_release(cgrp);",
            "\t\tTRACE_CGROUP_PATH(notify_populated, cgrp,",
            "\t\t\t\t  cgroup_is_populated(cgrp));",
            "\t\tcgroup_file_notify(&cgrp->events_file);",
            "",
            "\t\tchild = cgrp;",
            "\t\tcgrp = cgroup_parent(cgrp);",
            "\t} while (cgrp);",
            "}"
          ],
          "function_name": "cgroup_control, cgroup_ss_mask, cgroup_get_live, __cgroup_task_count, cgroup_task_count, css_set_threaded, css_set_populated, cgroup_update_populated",
          "description": "实现cgroup控制掩码计算（cgroup_control）、子系统掩码获取（cgroup_ss_mask）以及任务计数维护（__cgroup_task_count/cgroup_task_count），还包括CSS集合状态更新（css_set_populated）和cgroup populated状态同步（cgroup_update_populated）。",
          "similarity": 0.5984967947006226
        },
        {
          "chunk_id": 19,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 6233,
          "end_line": 6336,
          "content": [
            "static int __init cgroup_wq_init(void)",
            "{",
            "\t/*",
            "\t * There isn't much point in executing destruction path in",
            "\t * parallel.  Good chunk is serialized with cgroup_mutex anyway.",
            "\t * Use 1 for @max_active.",
            "\t *",
            "\t * We would prefer to do this in cgroup_init() above, but that",
            "\t * is called before init_workqueues(): so leave this until after.",
            "\t */",
            "\tcgroup_offline_wq = alloc_workqueue(\"cgroup_offline\", 0, 1);",
            "\tBUG_ON(!cgroup_offline_wq);",
            "",
            "\tcgroup_release_wq = alloc_workqueue(\"cgroup_release\", 0, 1);",
            "\tBUG_ON(!cgroup_release_wq);",
            "",
            "\tcgroup_free_wq = alloc_workqueue(\"cgroup_free\", 0, 1);",
            "\tBUG_ON(!cgroup_free_wq);",
            "\treturn 0;",
            "}",
            "void cgroup_path_from_kernfs_id(u64 id, char *buf, size_t buflen)",
            "{",
            "\tstruct kernfs_node *kn;",
            "",
            "\tkn = kernfs_find_and_get_node_by_id(cgrp_dfl_root.kf_root, id);",
            "\tif (!kn)",
            "\t\treturn;",
            "\tkernfs_path(kn, buf, buflen);",
            "\tkernfs_put(kn);",
            "}",
            "int proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,",
            "\t\t     struct pid *pid, struct task_struct *tsk)",
            "{",
            "\tchar *buf;",
            "\tint retval;",
            "\tstruct cgroup_root *root;",
            "",
            "\tretval = -ENOMEM;",
            "\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);",
            "\tif (!buf)",
            "\t\tgoto out;",
            "",
            "\trcu_read_lock();",
            "\tspin_lock_irq(&css_set_lock);",
            "",
            "\tfor_each_root(root) {",
            "\t\tstruct cgroup_subsys *ss;",
            "\t\tstruct cgroup *cgrp;",
            "\t\tint ssid, count = 0;",
            "",
            "\t\tif (root == &cgrp_dfl_root && !READ_ONCE(cgrp_dfl_visible))",
            "\t\t\tcontinue;",
            "",
            "\t\tcgrp = task_cgroup_from_root(tsk, root);",
            "\t\t/* The root has already been unmounted. */",
            "\t\tif (!cgrp)",
            "\t\t\tcontinue;",
            "",
            "\t\tseq_printf(m, \"%d:\", root->hierarchy_id);",
            "\t\tif (root != &cgrp_dfl_root)",
            "\t\t\tfor_each_subsys(ss, ssid)",
            "\t\t\t\tif (root->subsys_mask & (1 << ssid))",
            "\t\t\t\t\tseq_printf(m, \"%s%s\", count++ ? \",\" : \"\",",
            "\t\t\t\t\t\t   ss->legacy_name);",
            "\t\tif (strlen(root->name))",
            "\t\t\tseq_printf(m, \"%sname=%s\", count ? \",\" : \"\",",
            "\t\t\t\t   root->name);",
            "\t\tseq_putc(m, ':');",
            "\t\t/*",
            "\t\t * On traditional hierarchies, all zombie tasks show up as",
            "\t\t * belonging to the root cgroup.  On the default hierarchy,",
            "\t\t * while a zombie doesn't show up in \"cgroup.procs\" and",
            "\t\t * thus can't be migrated, its /proc/PID/cgroup keeps",
            "\t\t * reporting the cgroup it belonged to before exiting.  If",
            "\t\t * the cgroup is removed before the zombie is reaped,",
            "\t\t * \" (deleted)\" is appended to the cgroup path.",
            "\t\t */",
            "\t\tif (cgroup_on_dfl(cgrp) || !(tsk->flags & PF_EXITING)) {",
            "\t\t\tretval = cgroup_path_ns_locked(cgrp, buf, PATH_MAX,",
            "\t\t\t\t\t\tcurrent->nsproxy->cgroup_ns);",
            "\t\t\tif (retval == -E2BIG)",
            "\t\t\t\tretval = -ENAMETOOLONG;",
            "\t\t\tif (retval < 0)",
            "\t\t\t\tgoto out_unlock;",
            "",
            "\t\t\tseq_puts(m, buf);",
            "\t\t} else {",
            "\t\t\tseq_puts(m, \"/\");",
            "\t\t}",
            "",
            "\t\tif (cgroup_on_dfl(cgrp) && cgroup_is_dead(cgrp))",
            "\t\t\tseq_puts(m, \" (deleted)\\n\");",
            "\t\telse",
            "\t\t\tseq_putc(m, '\\n');",
            "\t}",
            "",
            "\tretval = 0;",
            "out_unlock:",
            "\tspin_unlock_irq(&css_set_lock);",
            "\trcu_read_unlock();",
            "\tkfree(buf);",
            "out:",
            "\treturn retval;",
            "}"
          ],
          "function_name": "cgroup_wq_init, cgroup_path_from_kernfs_id, proc_cgroup_show",
          "description": "初始化cgroup工作队列用于异步资源清理。提供基于节点ID的路径解析函数，实现任务cgroup路径展示功能，支持显示当前任务所属的cgroup信息及其状态标识。",
          "similarity": 0.5946898460388184
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/cgroup/cgroup.c",
          "start_line": 5240,
          "end_line": 5352,
          "content": [
            "static ssize_t cgroup_procs_write(struct kernfs_open_file *of,",
            "\t\t\t\t  char *buf, size_t nbytes, loff_t off)",
            "{",
            "\treturn __cgroup_procs_write(of, buf, true) ?: nbytes;",
            "}",
            "static ssize_t cgroup_threads_write(struct kernfs_open_file *of,",
            "\t\t\t\t    char *buf, size_t nbytes, loff_t off)",
            "{",
            "\treturn __cgroup_procs_write(of, buf, false) ?: nbytes;",
            "}",
            "static void css_free_rwork_fn(struct work_struct *work)",
            "{",
            "\tstruct cgroup_subsys_state *css = container_of(to_rcu_work(work),",
            "\t\t\t\tstruct cgroup_subsys_state, destroy_rwork);",
            "\tstruct cgroup_subsys *ss = css->ss;",
            "\tstruct cgroup *cgrp = css->cgroup;",
            "",
            "\tpercpu_ref_exit(&css->refcnt);",
            "",
            "\tif (ss) {",
            "\t\t/* css free path */",
            "\t\tstruct cgroup_subsys_state *parent = css->parent;",
            "\t\tint id = css->id;",
            "",
            "\t\tss->css_free(css);",
            "\t\tcgroup_idr_remove(&ss->css_idr, id);",
            "\t\tcgroup_put(cgrp);",
            "",
            "\t\tif (parent)",
            "\t\t\tcss_put(parent);",
            "\t} else {",
            "\t\t/* cgroup free path */",
            "\t\tatomic_dec(&cgrp->root->nr_cgrps);",
            "\t\tif (!cgroup_on_dfl(cgrp))",
            "\t\t\tcgroup1_pidlist_destroy_all(cgrp);",
            "\t\tcancel_work_sync(&cgrp->release_agent_work);",
            "\t\tbpf_cgrp_storage_free(cgrp);",
            "",
            "\t\tif (cgroup_parent(cgrp)) {",
            "\t\t\t/*",
            "\t\t\t * We get a ref to the parent, and put the ref when",
            "\t\t\t * this cgroup is being freed, so it's guaranteed",
            "\t\t\t * that the parent won't be destroyed before its",
            "\t\t\t * children.",
            "\t\t\t */",
            "\t\t\tcgroup_put(cgroup_parent(cgrp));",
            "\t\t\tkernfs_put(cgrp->kn);",
            "\t\t\tpsi_cgroup_free(cgrp);",
            "\t\t\tcgroup_rstat_exit(cgrp);",
            "\t\t\tkfree(cgrp);",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * This is root cgroup's refcnt reaching zero,",
            "\t\t\t * which indicates that the root should be",
            "\t\t\t * released.",
            "\t\t\t */",
            "\t\t\tcgroup_destroy_root(cgrp->root);",
            "\t\t}",
            "\t}",
            "}",
            "static void css_release_work_fn(struct work_struct *work)",
            "{",
            "\tstruct cgroup_subsys_state *css =",
            "\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);",
            "\tstruct cgroup_subsys *ss = css->ss;",
            "\tstruct cgroup *cgrp = css->cgroup;",
            "",
            "\tcgroup_lock();",
            "",
            "\tcss->flags |= CSS_RELEASED;",
            "\tlist_del_rcu(&css->sibling);",
            "",
            "\tif (ss) {",
            "\t\t/* css release path */",
            "\t\tif (!list_empty(&css->rstat_css_node)) {",
            "\t\t\tcgroup_rstat_flush(cgrp);",
            "\t\t\tlist_del_rcu(&css->rstat_css_node);",
            "\t\t}",
            "",
            "\t\tcgroup_idr_replace(&ss->css_idr, NULL, css->id);",
            "\t\tif (ss->css_released)",
            "\t\t\tss->css_released(css);",
            "\t} else {",
            "\t\tstruct cgroup *tcgrp;",
            "",
            "\t\t/* cgroup release path */",
            "\t\tTRACE_CGROUP_PATH(release, cgrp);",
            "",
            "\t\tcgroup_rstat_flush(cgrp);",
            "",
            "\t\tspin_lock_irq(&css_set_lock);",
            "\t\tfor (tcgrp = cgroup_parent(cgrp); tcgrp;",
            "\t\t     tcgrp = cgroup_parent(tcgrp))",
            "\t\t\ttcgrp->nr_dying_descendants--;",
            "\t\tspin_unlock_irq(&css_set_lock);",
            "",
            "\t\t/*",
            "\t\t * There are two control paths which try to determine",
            "\t\t * cgroup from dentry without going through kernfs -",
            "\t\t * cgroupstats_build() and css_tryget_online_from_dir().",
            "\t\t * Those are supported by RCU protecting clearing of",
            "\t\t * cgrp->kn->priv backpointer.",
            "\t\t */",
            "\t\tif (cgrp->kn)",
            "\t\t\tRCU_INIT_POINTER(*(void __rcu __force **)&cgrp->kn->priv,",
            "\t\t\t\t\t NULL);",
            "\t}",
            "",
            "\tcgroup_unlock();",
            "",
            "\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);",
            "\tqueue_rcu_work(cgroup_free_wq, &css->destroy_rwork);",
            "}"
          ],
          "function_name": "cgroup_procs_write, cgroup_threads_write, css_free_rwork_fn, css_release_work_fn",
          "description": "定义了处理cgroup进程中写入操作的函数，通过区分进程和线程的不同行为进行数据更新。实现了CSS（控制组子系统状态）的释放工作函数，负责在RCU机制下安全地回收CSS资源并执行清理操作。",
          "similarity": 0.5836384892463684
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/pids.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:50:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\pids.c`\n\n---\n\n# cgroup/pids.c 技术文档\n\n## 1. 文件概述\n\n`cgroup/pids.c` 实现了 Linux 内核中 cgroup 的 **PID 控制器（pids controller）**，用于限制指定 cgroup 及其子层级中可创建的最大进程（任务）数量。该控制器通过监控 `fork()` 系统调用，在进程数量即将超过设定阈值时拒绝创建新进程（返回 `-EAGAIN`），从而防止 PID 资源耗尽。该控制器支持层级继承语义，即子 cgroup 的有效限制为其自身与所有祖先中**最严格**的限制。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct pids_cgroup`**  \n  表示一个 cgroup 的 PID 控制状态，包含：\n  - `counter`：当前 cgroup 中的进程数量（64 位原子计数器）\n  - `limit`：允许的最大进程数（64 位原子值，`PIDS_MAX` 表示无限制）\n  - `watermark`：历史最高进程数（用于监控）\n  - `events` / `events_local`：事件计数器（如 `PIDCG_MAX`、`PIDCG_FORKFAIL`）\n  - `events_file` / `events_local_file`：用于通知用户空间事件发生的 cgroup 文件句柄\n\n- **`enum pidcg_event`**  \n  定义两类事件：\n  - `PIDCG_MAX`：因本 cgroup 或祖先限制被触发而导致 fork 失败\n  - `PIDCG_FORKFAIL`：在本 cgroup 中 fork 失败（用于本地事件通知）\n\n### 主要函数\n\n- **资源分配与释放**\n  - `pids_css_alloc()`：为新 cgroup 分配 `pids_cgroup` 结构，初始限制设为 `PIDS_MAX`（无限制）\n  - `pids_css_free()`：释放 `pids_cgroup` 结构\n\n- **计数操作**\n  - `pids_charge()`：**无条件**增加指定 cgroup 及其所有祖先的进程计数（用于回滚）\n  - `pids_uncharge()`：减少指定 cgroup 及其所有祖先的进程计数\n  - `pids_cancel()`：内部辅助函数，执行实际的原子减操作，并检查负值（视为 bug）\n  - `pids_try_charge()`：**有条件**增加计数，若任一祖先层级超过限制则回滚并返回 `-EAGAIN`\n\n- **cgroup 钩子函数**\n  - `pids_can_attach()`：在任务迁移到新 cgroup 时，更新源/目标 cgroup 的计数\n  - `pids_cancel_attach()`：回滚 `pids_can_attach()` 的操作\n  - `pids_can_fork()`：在 `fork()` 前检查是否允许创建新进程（未在提供的代码片段中完整显示）\n  - `pids_cancel_fork()`：回滚 fork 失败时的计数（未在提供的代码片段中完整显示）\n\n- **事件通知**\n  - `pids_event()`：当 fork 因 PID 限制失败时，记录事件并通知用户空间（通过 `cgroup_file_notify`）\n\n- **辅助函数**\n  - `css_pids()`：从 `cgroup_subsys_state` 转换为 `pids_cgroup`\n  - `parent_pids()`：获取父 cgroup 的 `pids_cgroup`\n  - `pids_update_watermark()`：更新历史最高进程数（非原子，容忍竞态）\n\n## 3. 关键实现\n\n### 层级限制语义\nPID 限制遵循 cgroup 的层级继承规则：一个进程的实际限制由其所在 cgroup 路径上**所有祖先中最小的 `limit` 值**决定。`pids_try_charge()` 在从当前 cgroup 向根方向遍历时，一旦发现任一祖先的 `counter + num > limit`，即判定为违反策略。\n\n### 原子计数与回滚机制\n- 所有计数操作均使用 `atomic64_t` 保证并发安全。\n- `pids_try_charge()` 采用“先增加后检查+回滚”策略：先原子增加所有祖先计数，再逐级检查是否超限。若超限，则从当前节点回滚到起始节点的所有增量。\n- `pids_charge()` 用于必须成功的场景（如 attach 回滚），**不检查限制**，允许临时超限。\n\n### 事件通知机制\n- 当 fork 因限制失败时，调用 `pids_event()`：\n  - 在 fork 发生的 cgroup 中记录 `PIDCG_FORKFAIL` 事件（仅首次触发时打印内核日志）\n  - 若启用了本地事件（通过 `cgroup v2` 的 `pids.local_events` 选项），则仅通知本地事件文件\n  - 否则，在**触发限制的祖先 cgroup** 中记录 `PIDCG_MAX` 事件，并向上传播通知\n\n### 无限制表示\n使用 `PIDS_MAX = PID_MAX_LIMIT + 1` 表示“无限制”，因为实际 PID 数量不可能超过 `PID_MAX_LIMIT`，因此该值可安全用于比较（`new > limit` 永远为假）。\n\n## 4. 依赖关系\n\n- **`<linux/cgroup.h>`**：cgroup 核心框架，提供 `cgroup_subsys_state`、`cgroup_taskset` 等基础结构和钩子函数接口\n- **`<linux/atomic.h>`**：提供 64 位原子操作（`atomic64_t`）\n- **`<linux/sched/task.h>`**：提供 `task_css()` 等任务与 cgroup 关联的接口\n- **`<linux/slab.h>`**：内存分配（`kzalloc`/`kfree`）\n- **`pids_cgrp_id`**：全局子系统 ID，用于从 `css_set` 或 `task_struct` 中获取 PID 控制器状态\n- **`cgroup_threadgroup_change_begin()`**：确保在 `fork` 过程中 cgroup 关联稳定（`pids_can_fork` 依赖此锁）\n\n## 5. 使用场景\n\n1. **容器资源隔离**  \n   在容器运行时（如 Docker、Podman）中限制单个容器或 Pod 可创建的最大进程数，防止 fork bomb 耗尽系统 PID 资源。\n\n2. **多租户系统防护**  \n   在共享主机环境中，为不同用户或服务分配独立的 cgroup，并设置 PID 限制，避免某一用户进程泛滥影响其他用户。\n\n3. **系统稳定性保障**  \n   通过全局或关键服务 cgroup 设置 PID 上限，确保即使某个子系统异常，也不会导致整个系统因 PID 耗尽而无法创建新进程。\n\n4. **监控与告警**  \n   通过读取 `pids.current`、`pids.max` 和 `pids.events` 文件，监控进程使用情况并在接近或达到限制时触发告警。",
      "similarity": 0.643945038318634,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 1,
          "end_line": 90,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Process number limiting controller for cgroups.",
            " *",
            " * Used to allow a cgroup hierarchy to stop any new processes from fork()ing",
            " * after a certain limit is reached.",
            " *",
            " * Since it is trivial to hit the task limit without hitting any kmemcg limits",
            " * in place, PIDs are a fundamental resource. As such, PID exhaustion must be",
            " * preventable in the scope of a cgroup hierarchy by allowing resource limiting",
            " * of the number of tasks in a cgroup.",
            " *",
            " * In order to use the `pids` controller, set the maximum number of tasks in",
            " * pids.max (this is not available in the root cgroup for obvious reasons). The",
            " * number of processes currently in the cgroup is given by pids.current.",
            " * Organisational operations are not blocked by cgroup policies, so it is",
            " * possible to have pids.current > pids.max. However, it is not possible to",
            " * violate a cgroup policy through fork(). fork() will return -EAGAIN if forking",
            " * would cause a cgroup policy to be violated.",
            " *",
            " * To set a cgroup to have no limit, set pids.max to \"max\". This is the default",
            " * for all new cgroups (N.B. that PID limits are hierarchical, so the most",
            " * stringent limit in the hierarchy is followed).",
            " *",
            " * pids.current tracks all child cgroup hierarchies, so parent/pids.current is",
            " * a superset of parent/child/pids.current.",
            " *",
            " * Copyright (C) 2015 Aleksa Sarai <cyphar@cyphar.com>",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/threads.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "",
            "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)",
            "#define PIDS_MAX_STR \"max\"",
            "",
            "enum pidcg_event {",
            "\t/* Fork failed in subtree because this pids_cgroup limit was hit. */",
            "\tPIDCG_MAX,",
            "\t/* Fork failed in this pids_cgroup because ancestor limit was hit. */",
            "\tPIDCG_FORKFAIL,",
            "\tNR_PIDCG_EVENTS,",
            "};",
            "",
            "struct pids_cgroup {",
            "\tstruct cgroup_subsys_state\tcss;",
            "",
            "\t/*",
            "\t * Use 64-bit types so that we can safely represent \"max\" as",
            "\t * %PIDS_MAX = (%PID_MAX_LIMIT + 1).",
            "\t */",
            "\tatomic64_t\t\t\tcounter;",
            "\tatomic64_t\t\t\tlimit;",
            "\tint64_t\t\t\t\twatermark;",
            "",
            "\t/* Handles for pids.events[.local] */",
            "\tstruct cgroup_file\t\tevents_file;",
            "\tstruct cgroup_file\t\tevents_local_file;",
            "",
            "\tatomic64_t\t\t\tevents[NR_PIDCG_EVENTS];",
            "\tatomic64_t\t\t\tevents_local[NR_PIDCG_EVENTS];",
            "};",
            "",
            "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)",
            "{",
            "\treturn container_of(css, struct pids_cgroup, css);",
            "}",
            "",
            "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)",
            "{",
            "\treturn css_pids(pids->css.parent);",
            "}",
            "",
            "static struct cgroup_subsys_state *",
            "pids_css_alloc(struct cgroup_subsys_state *parent)",
            "{",
            "\tstruct pids_cgroup *pids;",
            "",
            "\tpids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);",
            "\tif (!pids)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "",
            "\tatomic64_set(&pids->limit, PIDS_MAX);",
            "\treturn &pids->css;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了cgroup的pids控制器核心结构体pids_cgroup，包含原子计数器、限制值和事件统计字段，用于跟踪任务数量以防止进程爆炸。通过CSS子系统状态关联到cgroup层级，支持基于层级的资源限制。",
          "similarity": 0.648775577545166
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 91,
          "end_line": 202,
          "content": [
            "static void pids_css_free(struct cgroup_subsys_state *css)",
            "{",
            "\tkfree(css_pids(css));",
            "}",
            "static void pids_update_watermark(struct pids_cgroup *p, int64_t nr_pids)",
            "{",
            "\t/*",
            "\t * This is racy, but we don't need perfectly accurate tallying of",
            "\t * the watermark, and this lets us avoid extra atomic overhead.",
            "\t */",
            "\tif (nr_pids > READ_ONCE(p->watermark))",
            "\t\tWRITE_ONCE(p->watermark, nr_pids);",
            "}",
            "static void pids_cancel(struct pids_cgroup *pids, int num)",
            "{",
            "\t/*",
            "\t * A negative count (or overflow for that matter) is invalid,",
            "\t * and indicates a bug in the `pids` controller proper.",
            "\t */",
            "\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));",
            "}",
            "static void pids_uncharge(struct pids_cgroup *pids, int num)",
            "{",
            "\tstruct pids_cgroup *p;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p))",
            "\t\tpids_cancel(p, num);",
            "}",
            "static void pids_charge(struct pids_cgroup *pids, int num)",
            "{",
            "\tstruct pids_cgroup *p;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {",
            "\t\tint64_t new = atomic64_add_return(num, &p->counter);",
            "",
            "\t\tpids_update_watermark(p, new);",
            "\t}",
            "}",
            "static int pids_try_charge(struct pids_cgroup *pids, int num, struct pids_cgroup **fail)",
            "{",
            "\tstruct pids_cgroup *p, *q;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {",
            "\t\tint64_t new = atomic64_add_return(num, &p->counter);",
            "\t\tint64_t limit = atomic64_read(&p->limit);",
            "",
            "\t\t/*",
            "\t\t * Since new is capped to the maximum number of pid_t, if",
            "\t\t * p->limit is %PIDS_MAX then we know that this test will never",
            "\t\t * fail.",
            "\t\t */",
            "\t\tif (new > limit) {",
            "\t\t\t*fail = p;",
            "\t\t\tgoto revert;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Not technically accurate if we go over limit somewhere up",
            "\t\t * the hierarchy, but that's tolerable for the watermark.",
            "\t\t */",
            "\t\tpids_update_watermark(p, new);",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "revert:",
            "\tfor (q = pids; q != p; q = parent_pids(q))",
            "\t\tpids_cancel(q, num);",
            "\tpids_cancel(p, num);",
            "",
            "\treturn -EAGAIN;",
            "}",
            "static int pids_can_attach(struct cgroup_taskset *tset)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct cgroup_subsys_state *dst_css;",
            "",
            "\tcgroup_taskset_for_each(task, dst_css, tset) {",
            "\t\tstruct pids_cgroup *pids = css_pids(dst_css);",
            "\t\tstruct cgroup_subsys_state *old_css;",
            "\t\tstruct pids_cgroup *old_pids;",
            "",
            "\t\t/*",
            "\t\t * No need to pin @old_css between here and cancel_attach()",
            "\t\t * because cgroup core protects it from being freed before",
            "\t\t * the migration completes or fails.",
            "\t\t */",
            "\t\told_css = task_css(task, pids_cgrp_id);",
            "\t\told_pids = css_pids(old_css);",
            "",
            "\t\tpids_charge(pids, 1);",
            "\t\tpids_uncharge(old_pids, 1);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void pids_cancel_attach(struct cgroup_taskset *tset)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct cgroup_subsys_state *dst_css;",
            "",
            "\tcgroup_taskset_for_each(task, dst_css, tset) {",
            "\t\tstruct pids_cgroup *pids = css_pids(dst_css);",
            "\t\tstruct cgroup_subsys_state *old_css;",
            "\t\tstruct pids_cgroup *old_pids;",
            "",
            "\t\told_css = task_css(task, pids_cgrp_id);",
            "\t\told_pids = css_pids(old_css);",
            "",
            "\t\tpids_charge(old_pids, 1);",
            "\t\tpids_uncharge(pids, 1);",
            "\t}",
            "}"
          ],
          "function_name": "pids_css_free, pids_update_watermark, pids_cancel, pids_uncharge, pids_charge, pids_try_charge, pids_can_attach, pids_cancel_attach",
          "description": "实现了pids控制器的资源充放电逻辑，包含分配/释放CSS结构、更新水位线、充放电操作及附件检查等功能。通过遍历祖先cgroup进行全局资源追踪，确保层级间限制一致性。",
          "similarity": 0.6422573328018188
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 355,
          "end_line": 394,
          "content": [
            "static s64 pids_current_read(struct cgroup_subsys_state *css,",
            "\t\t\t     struct cftype *cft)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "",
            "\treturn atomic64_read(&pids->counter);",
            "}",
            "static s64 pids_peak_read(struct cgroup_subsys_state *css,",
            "\t\t\t  struct cftype *cft)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "",
            "\treturn READ_ONCE(pids->watermark);",
            "}",
            "static int __pids_events_show(struct seq_file *sf, bool local)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(seq_css(sf));",
            "\tenum pidcg_event pe = PIDCG_MAX;",
            "\tatomic64_t *events;",
            "",
            "\tif (!cgroup_subsys_on_dfl(pids_cgrp_subsys) ||",
            "\t    cgrp_dfl_root.flags & CGRP_ROOT_PIDS_LOCAL_EVENTS) {",
            "\t\tpe = PIDCG_FORKFAIL;",
            "\t\tlocal = true;",
            "\t}",
            "\tevents = local ? pids->events_local : pids->events;",
            "",
            "\tseq_printf(sf, \"max %lld\\n\", (s64)atomic64_read(&events[pe]));",
            "\treturn 0;",
            "}",
            "static int pids_events_show(struct seq_file *sf, void *v)",
            "{",
            "\t__pids_events_show(sf, false);",
            "\treturn 0;",
            "}",
            "static int pids_events_local_show(struct seq_file *sf, void *v)",
            "{",
            "\t__pids_events_show(sf, true);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pids_current_read, pids_peak_read, __pids_events_show, pids_events_show, pids_events_local_show",
          "description": "暴露pids控制器的监控接口，包括当前任务数读取、历史峰值查询及事件统计展示。通过seq_file接口向用户空间导出运行时统计数据。",
          "similarity": 0.5067684650421143
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 243,
          "end_line": 344,
          "content": [
            "static void pids_event(struct pids_cgroup *pids_forking,",
            "\t\t       struct pids_cgroup *pids_over_limit)",
            "{",
            "\tstruct pids_cgroup *p = pids_forking;",
            "",
            "\t/* Only log the first time limit is hit. */",
            "\tif (atomic64_inc_return(&p->events_local[PIDCG_FORKFAIL]) == 1) {",
            "\t\tpr_info(\"cgroup: fork rejected by pids controller in \");",
            "\t\tpr_cont_cgroup_path(p->css.cgroup);",
            "\t\tpr_cont(\"\\n\");",
            "\t}",
            "\tif (!cgroup_subsys_on_dfl(pids_cgrp_subsys) ||",
            "\t    cgrp_dfl_root.flags & CGRP_ROOT_PIDS_LOCAL_EVENTS) {",
            "\t\tcgroup_file_notify(&p->events_local_file);",
            "\t\treturn;",
            "\t}",
            "",
            "\tatomic64_inc(&pids_over_limit->events_local[PIDCG_MAX]);",
            "\tcgroup_file_notify(&pids_over_limit->events_local_file);",
            "",
            "\tfor (p = pids_over_limit; parent_pids(p); p = parent_pids(p)) {",
            "\t\tatomic64_inc(&p->events[PIDCG_MAX]);",
            "\t\tcgroup_file_notify(&p->events_file);",
            "\t}",
            "}",
            "static int pids_can_fork(struct task_struct *task, struct css_set *cset)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct pids_cgroup *pids, *pids_over_limit;",
            "\tint err;",
            "",
            "\tif (cset)",
            "\t\tcss = cset->subsys[pids_cgrp_id];",
            "\telse",
            "\t\tcss = task_css_check(current, pids_cgrp_id, true);",
            "\tpids = css_pids(css);",
            "\terr = pids_try_charge(pids, 1, &pids_over_limit);",
            "\tif (err)",
            "\t\tpids_event(pids, pids_over_limit);",
            "",
            "\treturn err;",
            "}",
            "static void pids_cancel_fork(struct task_struct *task, struct css_set *cset)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct pids_cgroup *pids;",
            "",
            "\tif (cset)",
            "\t\tcss = cset->subsys[pids_cgrp_id];",
            "\telse",
            "\t\tcss = task_css_check(current, pids_cgrp_id, true);",
            "\tpids = css_pids(css);",
            "\tpids_uncharge(pids, 1);",
            "}",
            "static void pids_release(struct task_struct *task)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));",
            "",
            "\tpids_uncharge(pids, 1);",
            "}",
            "static ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,",
            "\t\t\t      size_t nbytes, loff_t off)",
            "{",
            "\tstruct cgroup_subsys_state *css = of_css(of);",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "\tint64_t limit;",
            "\tint err;",
            "",
            "\tbuf = strstrip(buf);",
            "\tif (!strcmp(buf, PIDS_MAX_STR)) {",
            "\t\tlimit = PIDS_MAX;",
            "\t\tgoto set_limit;",
            "\t}",
            "",
            "\terr = kstrtoll(buf, 0, &limit);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (limit < 0 || limit >= PIDS_MAX)",
            "\t\treturn -EINVAL;",
            "",
            "set_limit:",
            "\t/*",
            "\t * Limit updates don't need to be mutex'd, since it isn't",
            "\t * critical that any racing fork()s follow the new limit.",
            "\t */",
            "\tatomic64_set(&pids->limit, limit);",
            "\treturn nbytes;",
            "}",
            "static int pids_max_show(struct seq_file *sf, void *v)",
            "{",
            "\tstruct cgroup_subsys_state *css = seq_css(sf);",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "\tint64_t limit = atomic64_read(&pids->limit);",
            "",
            "\tif (limit >= PIDS_MAX)",
            "\t\tseq_printf(sf, \"%s\\n\", PIDS_MAX_STR);",
            "\telse",
            "\t\tseq_printf(sf, \"%lld\\n\", limit);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pids_event, pids_can_fork, pids_cancel_fork, pids_release, pids_max_write, pids_max_show",
          "description": "处理进程创建时的配额检查与事件记录，包含can_fork检查、取消fork操作、任务释放及最大进程数配置接口。当达到硬限制时触发事件通知并拒绝fork请求。",
          "similarity": 0.4641945958137512
        }
      ]
    }
  ]
}