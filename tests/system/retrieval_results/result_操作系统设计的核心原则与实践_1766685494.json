{
  "query": "操作系统设计的核心原则与实践",
  "timestamp": "2025-12-26 01:58:14",
  "retrieved_files": [
    {
      "source_file": "kernel/sys.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:30:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sys.c`\n\n---\n\n# `sys.c` 内核源码技术文档\n\n## 1. 文件概述\n\n`sys.c` 是 Linux 内核中实现系统调用（system calls）的核心源文件之一，位于 `kernel/` 目录下。该文件主要负责处理与进程调度优先级、用户/组 ID 溢出处理、系统信息查询等相关的通用系统调用。其历史可追溯至 Linus Torvalds 早期开发阶段，是内核中提供 POSIX 兼容性的重要组成部分。当前文档所涵盖的代码片段聚焦于 `setpriority` 和 `getpriority` 系统调用的实现，以及与 UID/GID 溢出相关的全局变量定义。\n\n## 2. 核心功能\n\n### 全局变量\n- `overflowuid` / `overflowgid`：用于在 32 位 UID/GID 架构中表示无法表示的旧式 16 位 UID/GID 的回退值，默认为 `DEFAULT_OVERFLOWUID`/`DEFAULT_OVERFLOWGID`。\n- `fs_overflowuid` / `fs_overflowgid`：专用于仅支持 16 位 UID/GID 的文件系统的溢出回退值，适用于所有架构。\n\n### 主要函数\n- `set_one_prio_perm(struct task_struct *p)`：检查当前进程是否有权限修改目标进程 `p` 的调度优先级（nice 值）。\n- `set_one_prio(struct task_struct *p, int niceval, int error)`：在权限检查通过后，实际设置目标进程的 nice 值。\n- `SYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)`：实现 `setpriority(2)` 系统调用，支持按进程、进程组或用户 ID 修改一组进程的优先级。\n- `SYSCALL_DEFINE2(getpriority, int, which, int, who)`：实现 `getpriority(2)` 系统调用，返回指定范围（进程、进程组、用户）内最高优先级（即最小 nice 值）对应的兼容值。\n\n## 3. 关键实现\n\n### 权限控制机制\n- `set_one_prio_perm()` 函数通过比较当前进程的有效 UID（`euid`）与目标进程的 UID 或有效 UID 是否相等来判断基本权限。\n- 若不满足 UID 匹配，则检查当前进程是否在目标进程所属的用户命名空间（`user_ns`）中拥有 `CAP_SYS_NICE` 能力。\n- 所有凭证（`cred`）访问均在 RCU 读锁保护下进行，确保并发安全。\n\n### 优先级设置逻辑\n- `setpriority` 系统调用首先将用户传入的 `niceval` 限制在 `[MIN_NICE, MAX_NICE]` 范围内（通常为 -20 到 19）。\n- 根据 `which` 参数（`PRIO_PROCESS`、`PRIO_PGRP` 或 `PRIO_USER`）分别处理：\n  - **进程**：通过 `find_task_by_vpid()` 查找目标进程。\n  - **进程组**：使用 `do_each_pid_thread()` 遍历指定进程组内的所有线程。\n  - **用户**：遍历所有进程，筛选 UID 匹配的进程；若目标 UID 非当前用户，则通过 `find_user()` 获取用户结构并最终 `free_uid()` 释放引用。\n- 实际设置前调用 LSM（Linux Security Module）钩子 `security_task_setnice()` 进行安全策略检查。\n\n### 优先级获取的兼容性处理\n- `getpriority` 返回值采用历史兼容格式：将实际 nice 值（-20~19）转换为 `20 - nice`，即返回 1~40 的正整数。\n- 该转换通过 `nice_to_rlimit()` 宏实现（定义在 `<linux/resource.h>` 中）。\n- 返回的是指定范围内**最高优先级**（即最大 `nice_to_rlimit` 值，对应最小实际 nice 值）。\n\n### 架构无关性处理\n- 文件开头通过一系列 `#ifndef` 宏定义（如 `SET_UNALIGN_CTL`、`GET_FP_MODE` 等）为不支持特定 CPU 控制功能的架构提供默认 `-EINVAL` 返回值，避免编译错误。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **调度子系统**：`<linux/sched.h>` 及其子头文件（如 `sched/task.h`、`sched/cputime.h`）提供任务结构、nice 值操作和遍历接口。\n- **用户/组管理**：`<linux/cred.h>`、`<linux/uidgid.h>`、`<linux/user_namespace.h>` 处理凭证、UID/GID 映射及命名空间。\n- **安全模块**：`<linux/security.h>`、`<linux/capability.h>` 提供 LSM 钩子和能力检查。\n- **进程管理**：`<linux/pid.h>`（通过 `find_vpid` 等）、`<linux/rcupdate.h>`（RCU 锁）、`<linux/task_io_accounting_ops.h>`。\n- **系统调用框架**：`<linux/syscalls.h>`、`<linux/uaccess.h>`。\n- **其他**：`<linux/resource.h>`（`nice_to_rlimit`）、`<linux/utsname.h>`（系统信息）、`<generated/utsrelease.h>`（内核版本）。\n\n### 内核子系统交互\n- **调度器**：通过 `set_user_nice()` 和 `task_nice()` 与核心调度逻辑交互。\n- **用户命名空间**：在 UID 比较和能力检查中依赖用户命名空间隔离机制。\n- **LSM 框架**：调用 `security_task_setnice()` 允许安全模块（如 SELinux、AppArmor）拦截优先级修改。\n- **进程遍历机制**：使用 `for_each_process_thread()` 和 `do_each_pid_thread()` 安全遍历进程列表。\n\n## 5. 使用场景\n\n- **用户空间程序调用 `setpriority()`/`getpriority()`**：如 `nice`、`renice` 命令，或应用程序动态调整自身/子进程 CPU 调度优先级。\n- **系统初始化**：`overflowuid`/`overflowgid` 等变量在内核启动时初始化，供 VFS 和 IPC 子系统在处理旧式 16 位 UID/GID 时使用。\n- **容器与命名空间环境**：在用户命名空间中，`setpriority` 的权限检查基于目标进程的用户命名空间，确保容器内进程无法越权修改宿主机进程优先级。\n- **安全审计与限制**：通过 LSM 钩子，系统可记录或阻止非特权进程提升优先级的行为。\n- **跨架构兼容**：为不支持浮点控制、对齐控制等特性的 CPU 架构提供统一的系统调用接口，避免架构特定代码污染通用逻辑。",
      "similarity": 0.5301523804664612,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/sys.c",
          "start_line": 851,
          "end_line": 966,
          "content": [
            "long __sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t krgid, kegid, ksgid;",
            "\tbool rgid_new, egid_new, sgid_new;",
            "",
            "\tkrgid = make_kgid(ns, rgid);",
            "\tkegid = make_kgid(ns, egid);",
            "\tksgid = make_kgid(ns, sgid);",
            "",
            "\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))",
            "\t\treturn -EINVAL;",
            "\tif ((egid != (gid_t) -1) && !gid_valid(kegid))",
            "\t\treturn -EINVAL;",
            "\tif ((sgid != (gid_t) -1) && !gid_valid(ksgid))",
            "\t\treturn -EINVAL;",
            "",
            "\told = current_cred();",
            "",
            "\t/* check for no-op */",
            "\tif ((rgid == (gid_t) -1 || gid_eq(krgid, old->gid)) &&",
            "\t    (egid == (gid_t) -1 || (gid_eq(kegid, old->egid) &&",
            "\t\t\t\t    gid_eq(kegid, old->fsgid))) &&",
            "\t    (sgid == (gid_t) -1 || gid_eq(ksgid, old->sgid)))",
            "\t\treturn 0;",
            "",
            "\trgid_new = rgid != (gid_t) -1        && !gid_eq(krgid, old->gid) &&",
            "\t\t   !gid_eq(krgid, old->egid) && !gid_eq(krgid, old->sgid);",
            "\tegid_new = egid != (gid_t) -1        && !gid_eq(kegid, old->gid) &&",
            "\t\t   !gid_eq(kegid, old->egid) && !gid_eq(kegid, old->sgid);",
            "\tsgid_new = sgid != (gid_t) -1        && !gid_eq(ksgid, old->gid) &&",
            "\t\t   !gid_eq(ksgid, old->egid) && !gid_eq(ksgid, old->sgid);",
            "\tif ((rgid_new || egid_new || sgid_new) &&",
            "\t    !ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\treturn -EPERM;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (rgid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_gid(new, krgid);",
            "\t\t#else",
            "\t\tnew->gid = krgid;",
            "\t\t#endif",
            "\tif (egid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_egid(new, kegid);",
            "\t\t#else",
            "\t\tnew->egid = kegid;",
            "\t\t#endif",
            "\tif (sgid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_sgid(new, ksgid);",
            "\t\t#else",
            "\t\tnew->sgid = ksgid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsgid(new, new->egid);",
            "\t#else",
            "\tnew->fsgid = new->egid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_RES);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "long __sys_setfsuid(uid_t uid)",
            "{",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tuid_t old_fsuid;",
            "\tkuid_t kuid;",
            "",
            "\told = current_cred();",
            "\told_fsuid = from_kuid_munged(old->user_ns, old->fsuid);",
            "",
            "\tkuid = make_kuid(old->user_ns, uid);",
            "\tif (!uid_valid(kuid))",
            "\t\treturn old_fsuid;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn old_fsuid;",
            "",
            "\tif (uid_eq(kuid, old->uid)  || uid_eq(kuid, old->euid)  ||",
            "\t    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||",
            "\t    ns_capable_setid(old->user_ns, CAP_SETUID)) {",
            "\t\tif (!uid_eq(kuid, old->fsuid)) {",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_fsuid(new, kuid);",
            "\t\t\t#else",
            "\t\t\tnew->fsuid = kuid;",
            "\t\t\t#endif",
            "\t\t\tif (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)",
            "\t\t\t\tgoto change_okay;",
            "\t\t}",
            "\t}",
            "",
            "\tabort_creds(new);",
            "\treturn old_fsuid;",
            "",
            "change_okay:",
            "\tcommit_creds(new);",
            "\treturn old_fsuid;",
            "}"
          ],
          "function_name": "__sys_setresgid, __sys_setfsuid",
          "description": "实现组ID资源管理接口及文件系统用户ID设置，包含组ID字段更新和文件系统用户ID的权限控制逻辑。",
          "similarity": 0.46112459897994995
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sys.c",
          "start_line": 458,
          "end_line": 628,
          "content": [
            "long __sys_setgid(gid_t gid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t kgid;",
            "",
            "\tkgid = make_kgid(ns, gid);",
            "\tif (!gid_valid(kgid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_sgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t\tiee_set_cred_gid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->gid = new->egid = new->sgid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->egid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse",
            "\t\tgoto error;",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_ID);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "static int set_user(struct cred *new)",
            "{",
            "\tstruct user_struct *new_user;",
            "",
            "\tnew_user = alloc_uid(new->uid);",
            "\tif (!new_user)",
            "\t\treturn -EAGAIN;",
            "",
            "\tfree_uid(new->user);",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_user(new, new_user);",
            "\t#else",
            "\tnew->user = new_user;",
            "\t#endif",
            "\treturn 0;",
            "}",
            "static void flag_nproc_exceeded(struct cred *new)",
            "{",
            "\tif (new->ucounts == current_ucounts())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * We don't fail in case of NPROC limit excess here because too many",
            "\t * poorly written programs don't check set*uid() return code, assuming",
            "\t * it never fails if called by root.  We may still enforce NPROC limit",
            "\t * for programs doing set*uid()+execve() by harmlessly deferring the",
            "\t * failure to the execve() stage.",
            "\t */",
            "\tif (is_rlimit_overlimit(new->ucounts, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC)) &&",
            "\t\t\tnew->user != INIT_USER)",
            "\t\tcurrent->flags |= PF_NPROC_EXCEEDED;",
            "\telse",
            "\t\tcurrent->flags &= ~PF_NPROC_EXCEEDED;",
            "}",
            "long __sys_setreuid(uid_t ruid, uid_t euid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kruid, keuid;",
            "",
            "\tkruid = make_kuid(ns, ruid);",
            "\tkeuid = make_kuid(ns, euid);",
            "",
            "\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))",
            "\t\treturn -EINVAL;",
            "\tif ((euid != (uid_t) -1) && !uid_valid(keuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ruid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kruid);",
            "\t\t#else",
            "\t\tnew->uid = kruid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, kruid) &&",
            "\t\t    !uid_eq(old->euid, kruid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (euid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_euid(new, keuid);",
            "\t\t#else",
            "\t\tnew->euid = keuid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, keuid) &&",
            "\t\t    !uid_eq(old->euid, keuid) &&",
            "\t\t    !uid_eq(old->suid, keuid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (!uid_eq(new->uid, old->uid)) {",
            "\t\tretval = set_user(new);",
            "\t\tif (retval < 0)",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (ruid != (uid_t) -1 ||",
            "\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_suid(new, new->euid);",
            "\t\t#else",
            "\t\tnew->suid = new->euid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(new, new->euid);",
            "\t#else",
            "\tnew->fsuid = new->euid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_RE);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "__sys_setgid, if, set_user, flag_nproc_exceeded, __sys_setreuid",
          "description": "实现用户ID调整逻辑，包含用户结构体分配、NPROC限制检测及用户命名空间权限校验，更新进程的有效/实始用户ID。",
          "similarity": 0.4129968285560608
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sys.c",
          "start_line": 182,
          "end_line": 286,
          "content": [
            "static bool set_one_prio_perm(struct task_struct *p)",
            "{",
            "\tconst struct cred *cred = current_cred(), *pcred = __task_cred(p);",
            "",
            "\tif (uid_eq(pcred->uid,  cred->euid) ||",
            "\t    uid_eq(pcred->euid, cred->euid))",
            "\t\treturn true;",
            "\tif (ns_capable(pcred->user_ns, CAP_SYS_NICE))",
            "\t\treturn true;",
            "\treturn false;",
            "}",
            "static int set_one_prio(struct task_struct *p, int niceval, int error)",
            "{",
            "\tint no_nice;",
            "",
            "\tif (!set_one_prio_perm(p)) {",
            "\t\terror = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "\tif (niceval < task_nice(p) && !can_nice(p, niceval)) {",
            "\t\terror = -EACCES;",
            "\t\tgoto out;",
            "\t}",
            "\tno_nice = security_task_setnice(p, niceval);",
            "\tif (no_nice) {",
            "\t\terror = no_nice;",
            "\t\tgoto out;",
            "\t}",
            "\tif (error == -ESRCH)",
            "\t\terror = 0;",
            "\tset_user_nice(p, niceval);",
            "out:",
            "\treturn error;",
            "}",
            "long __sys_setregid(gid_t rgid, gid_t egid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t krgid, kegid;",
            "",
            "\tkrgid = make_kgid(ns, rgid);",
            "\tkegid = make_kgid(ns, egid);",
            "",
            "\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))",
            "\t\treturn -EINVAL;",
            "\tif ((egid != (gid_t) -1) && !gid_valid(kegid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (rgid != (gid_t) -1) {",
            "\t\tif (gid_eq(old->gid, krgid) ||",
            "\t\t    gid_eq(old->egid, krgid) ||",
            "\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_gid(new, krgid);",
            "\t\t\t#else",
            "\t\t\tnew->gid = krgid;",
            "\t\t\t#endif",
            "\t\telse",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (egid != (gid_t) -1) {",
            "\t\tif (gid_eq(old->gid, kegid) ||",
            "\t\t    gid_eq(old->egid, kegid) ||",
            "\t\t    gid_eq(old->sgid, kegid) ||",
            "\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_egid(new, kegid);",
            "\t\t\t#else",
            "\t\t\tnew->egid = kegid;",
            "\t\t\t#endif",
            "\t\telse",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (rgid != (gid_t) -1 ||",
            "\t    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_sgid(new, new->egid);",
            "\t\t#else",
            "\t\tnew->sgid = new->egid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsgid(new, new->egid);",
            "\t#else",
            "\tnew->fsgid = new->egid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_RE);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "set_one_prio_perm, set_one_prio, __sys_setregid",
          "description": "实现组ID调整逻辑，包含优先级调整权限验证及组ID设置，通过cred结构体更新目标进程的gid/egid字段。",
          "similarity": 0.4098536968231201
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/sys.c",
          "start_line": 1386,
          "end_line": 1491,
          "content": [
            "static int override_release(char __user *release, size_t len)",
            "{",
            "\tint ret = 0;",
            "",
            "\tif (current->personality & UNAME26) {",
            "\t\tconst char *rest = UTS_RELEASE;",
            "\t\tchar buf[65] = { 0 };",
            "\t\tint ndots = 0;",
            "\t\tunsigned v;",
            "\t\tsize_t copy;",
            "",
            "\t\twhile (*rest) {",
            "\t\t\tif (*rest == '.' && ++ndots >= 3)",
            "\t\t\t\tbreak;",
            "\t\t\tif (!isdigit(*rest) && *rest != '.')",
            "\t\t\t\tbreak;",
            "\t\t\trest++;",
            "\t\t}",
            "\t\tv = LINUX_VERSION_PATCHLEVEL + 60;",
            "\t\tcopy = clamp_t(size_t, len, 1, sizeof(buf));",
            "\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);",
            "\t\tret = copy_to_user(release, buf, copy + 1);",
            "\t}",
            "\treturn ret;",
            "}",
            "static int do_prlimit(struct task_struct *tsk, unsigned int resource,",
            "\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)",
            "{",
            "\tstruct rlimit *rlim;",
            "\tint retval = 0;",
            "",
            "\tif (resource >= RLIM_NLIMITS)",
            "\t\treturn -EINVAL;",
            "\tresource = array_index_nospec(resource, RLIM_NLIMITS);",
            "",
            "\tif (new_rlim) {",
            "\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)",
            "\t\t\treturn -EINVAL;",
            "\t\tif (resource == RLIMIT_NOFILE &&",
            "\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* Holding a refcount on tsk protects tsk->signal from disappearing. */",
            "\trlim = tsk->signal->rlim + resource;",
            "\ttask_lock(tsk->group_leader);",
            "\tif (new_rlim) {",
            "\t\t/*",
            "\t\t * Keep the capable check against init_user_ns until cgroups can",
            "\t\t * contain all limits.",
            "\t\t */",
            "\t\tif (new_rlim->rlim_max > rlim->rlim_max &&",
            "\t\t\t\t!capable(CAP_SYS_RESOURCE))",
            "\t\t\tretval = -EPERM;",
            "\t\tif (!retval)",
            "\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);",
            "\t}",
            "\tif (!retval) {",
            "\t\tif (old_rlim)",
            "\t\t\t*old_rlim = *rlim;",
            "\t\tif (new_rlim)",
            "\t\t\t*rlim = *new_rlim;",
            "\t}",
            "\ttask_unlock(tsk->group_leader);",
            "",
            "\t/*",
            "\t * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not",
            "\t * infinite. In case of RLIM_INFINITY the posix CPU timer code",
            "\t * ignores the rlimit.",
            "\t */",
            "\tif (!retval && new_rlim && resource == RLIMIT_CPU &&",
            "\t    new_rlim->rlim_cur != RLIM_INFINITY &&",
            "\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {",
            "\t\t/*",
            "\t\t * update_rlimit_cpu can fail if the task is exiting, but there",
            "\t\t * may be other tasks in the thread group that are not exiting,",
            "\t\t * and they need their cpu timers adjusted.",
            "\t\t *",
            "\t\t * The group_leader is the last task to be released, so if we",
            "\t\t * cannot update_rlimit_cpu on it, then the entire process is",
            "\t\t * exiting and we do not need to update at all.",
            "\t\t */",
            "\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);",
            "\t}",
            "",
            "\treturn retval;",
            "}",
            "static inline bool rlim64_is_infinity(__u64 rlim64)",
            "{",
            "#if BITS_PER_LONG < 64",
            "\treturn rlim64 >= ULONG_MAX;",
            "#else",
            "\treturn rlim64 == RLIM64_INFINITY;",
            "#endif",
            "}",
            "static void rlim_to_rlim64(const struct rlimit *rlim, struct rlimit64 *rlim64)",
            "{",
            "\tif (rlim->rlim_cur == RLIM_INFINITY)",
            "\t\trlim64->rlim_cur = RLIM64_INFINITY;",
            "\telse",
            "\t\trlim64->rlim_cur = rlim->rlim_cur;",
            "\tif (rlim->rlim_max == RLIM_INFINITY)",
            "\t\trlim64->rlim_max = RLIM64_INFINITY;",
            "\telse",
            "\t\trlim64->rlim_max = rlim->rlim_max;",
            "}"
          ],
          "function_name": "override_release, do_prlimit, rlim64_is_infinity, rlim_to_rlim64",
          "description": "该代码段主要实现三个功能：  \n1. **`override_release`** 函数用于覆盖内核版本字符串，在 `UNAME26` 人格模式下强制替换 `UTS_RELEASE` 字符串为自定义格式（如 `2.6.xxxx`），并复制至用户空间。  \n2. **`do_prlimit`** 函数负责处理进程资源限制（如文件数、CPU时间等），执行有效性校验、权限检查，并通过安全钩子更新限制值，同时对 CPU 资源触发 POSIX 定时器。  \n3. **`rlim64_is_infinity` 和 `rlim_to_rlim64`** 分别用于判断 64 位资源限制是否为无穷大，以及将传统 32 位 `rlimit` 结构转换为 64 位版本以适配更大数值范围。",
          "similarity": 0.40898337960243225
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sys.c",
          "start_line": 666,
          "end_line": 811,
          "content": [
            "long __sys_setuid(uid_t uid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kuid;",
            "",
            "\tkuid = make_kuid(ns, uid);",
            "\tif (!uid_valid(kuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ns_capable_setid(old->user_ns, CAP_SETUID)) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kuid);",
            "\t\tiee_set_cred_suid(new, kuid);",
            "\t\t#else",
            "\t\tnew->suid = new->uid = kuid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(kuid, old->uid)) {",
            "\t\t\tretval = set_user(new);",
            "\t\t\tif (retval < 0)",
            "\t\t\t\tgoto error;",
            "\t\t}",
            "\t} else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {",
            "\t\tgoto error;",
            "\t}",
            "",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_euid(new, kuid);",
            "\tiee_set_cred_fsuid(new, kuid);",
            "\t#else",
            "\tnew->fsuid = new->euid = kuid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_ID);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kruid, keuid, ksuid;",
            "\tbool ruid_new, euid_new, suid_new;",
            "",
            "\tkruid = make_kuid(ns, ruid);",
            "\tkeuid = make_kuid(ns, euid);",
            "\tksuid = make_kuid(ns, suid);",
            "",
            "\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((euid != (uid_t) -1) && !uid_valid(keuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((suid != (uid_t) -1) && !uid_valid(ksuid))",
            "\t\treturn -EINVAL;",
            "",
            "\told = current_cred();",
            "",
            "\t/* check for no-op */",
            "\tif ((ruid == (uid_t) -1 || uid_eq(kruid, old->uid)) &&",
            "\t    (euid == (uid_t) -1 || (uid_eq(keuid, old->euid) &&",
            "\t\t\t\t    uid_eq(keuid, old->fsuid))) &&",
            "\t    (suid == (uid_t) -1 || uid_eq(ksuid, old->suid)))",
            "\t\treturn 0;",
            "",
            "\truid_new = ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&",
            "\t\t   !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid);",
            "\teuid_new = euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&",
            "\t\t   !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid);",
            "\tsuid_new = suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&",
            "\t\t   !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid);",
            "\tif ((ruid_new || euid_new || suid_new) &&",
            "\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\treturn -EPERM;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (ruid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kruid);",
            "\t\t#else",
            "\t\tnew->uid = kruid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(kruid, old->uid)) {",
            "\t\t\tretval = set_user(new);",
            "\t\t\tif (retval < 0)",
            "\t\t\t\tgoto error;",
            "\t\t}",
            "\t}",
            "\tif (euid != (uid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_euid(new, keuid);",
            "\t\t#else",
            "\t\tnew->euid = keuid;",
            "\t\t#endif",
            "\tif (suid != (uid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_suid(new, ksuid);",
            "\t\t#else",
            "\t\tnew->suid = ksuid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(new, new->euid);",
            "\t#else",
            "\tnew->fsuid = new->euid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_RES);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "__sys_setuid, __sys_setresuid",
          "description": "实现用户ID调整接口，支持基础UID设置与资源管理UID设置，包含完整性校验和用户结构体更新操作。",
          "similarity": 0.401084303855896
        }
      ]
    },
    {
      "source_file": "kernel/sysctl.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:32:56\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sysctl.c`\n\n---\n\n# sysctl.c 技术文档\n\n## 文件概述\n\n`sysctl.c` 是 Linux 内核中实现系统控制（sysctl）机制的核心文件，提供了通过 `/proc/sys` 接口动态读写内核运行时参数的能力。该文件实现了通用的 sysctl 框架，支持字符串、整数、长整型等多种数据类型的读写操作，并提供了严格的写入模式控制，确保系统参数的安全性和一致性。\n\n## 核心功能\n\n### 主要数据结构\n- `enum sysctl_writes_mode`: 定义 sysctl 写入模式的三种策略\n  - `SYSCTL_WRITES_LEGACY`: 传统模式，忽略文件位置\n  - `SYSCTL_WRITES_WARN`: 警告模式，非零位置写入时发出警告\n  - `SYSCTL_WRITES_STRICT`: 严格模式，强制要求位置为0且完整写入\n\n### 主要全局变量\n- `sysctl_vals[]`: 预定义的常用整数值常量数组（0, 1, 2, 3, 4, 100, 200, 1000, 3000, INT_MAX, 65535, -1）\n- `sysctl_long_vals[]`: 预定义的常用长整型值常量数组（0, 1, LONG_MAX）\n- `sysctl_writes_strict`: 当前 sysctl 写入模式，默认为严格模式\n- `sysctl_legacy_va_layout`: 控制虚拟地址布局的兼容性标志\n\n### 主要函数\n- `proc_dostring()`: 处理字符串类型 sysctl 参数的读写操作\n- `_proc_do_string()`: 字符串读写的底层实现函数\n- `proc_first_pos_non_zero_ignore()`: 检查文件位置是否为非零并根据模式处理\n- `warn_sysctl_write()`: 发出 sysctl 写入警告信息\n- `proc_skip_spaces()`: 跳过缓冲区中的空白字符\n- `proc_skip_char()`: 跳过缓冲区中的指定字符\n- `strtoul_lenient()`: 宽松的无符号长整型字符串解析函数（代码片段中未完整显示）\n\n## 关键实现\n\n### 写入模式控制\nsysctl 实现了三种写入模式来控制如何处理文件位置和多次写入：\n- **严格模式**（默认）: 要求写入必须从位置0开始，且一次写入必须包含完整值\n- **警告模式**: 允许非零位置写入但会发出警告\n- **传统模式**: 完全忽略文件位置，每次写入都覆盖整个值\n\n### 字符串处理机制\n`_proc_do_string()` 函数实现了智能的字符串读写逻辑：\n- **读取时**: 自动在字符串末尾添加换行符 `\\n`，支持分段读取\n- **写入时**: \n  - 严格模式下支持从指定位置继续写入（用于长字符串）\n  - 其他模式下总是从字符串开头覆盖写入\n  - 自动处理空字符和换行符作为字符串终止符\n\n### 安全性保障\n- 通过 `proc_first_pos_non_zero_ignore()` 函数确保数值类型参数的写入安全性\n- 使用 `maxlen` 参数防止缓冲区溢出\n- 自动截断超长字符串并确保 NULL 终止\n\n### 预定义常量优化\n通过导出 `sysctl_vals[]` 和 `sysctl_long_vals[]` 数组，避免在各个 sysctl 表项中重复定义常用数值，减少内存占用并提高一致性。\n\n## 依赖关系\n\n### 头文件依赖\n- **核心内核头文件**: `linux/module.h`, `linux/kernel.h`, `linux/init.h`\n- **内存管理**: `linux/mm.h`, `linux/slab.h`, `linux/swap.h`\n- **文件系统**: `linux/proc_fs.h`, `linux/fs.h`\n- **安全机制**: `linux/security.h`, `linux/capability.h`\n- **系统调用**: `linux/syscalls.h`, `linux/uaccess.h`\n- **架构相关**: `asm/processor.h` 及各架构特定头文件（X86、SPARC 等）\n\n### 配置依赖\n- `CONFIG_SYSCTL`: 主开关，控制 sysctl 功能是否启用\n- `CONFIG_PROC_SYSCTL`: 控制 `/proc/sys` 接口支持\n- `CONFIG_PERF_EVENTS`: 影响性能事件相关的 sysctl 参数\n- `CONFIG_RT_MUTEXES`: 实时互斥锁相关的 sysctl 支持\n- 架构特定配置: `HAVE_ARCH_PICK_MMAP_LAYOUT`, `CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT`\n\n### 模块交互\n- 与 proc 文件系统深度集成，提供 `/proc/sys` 虚拟文件接口\n- 为网络子系统、内存管理、调度器等内核子系统提供参数配置接口\n- 与安全模块（如 SELinux）协作进行权限检查\n\n## 使用场景\n\n### 内核参数动态配置\n- 系统管理员通过 `/proc/sys` 接口实时调整内核参数\n- 应用程序通过 sysctl 系统调用查询或修改内核行为\n- 启动脚本在系统初始化时设置关键内核参数\n\n### 子系统集成\n- **网络子系统**: 配置 TCP/IP 参数、网络缓冲区大小等\n- **内存管理**: 调整脏页回写策略、内存回收阈值等\n- **进程调度**: 设置调度策略参数、进程优先级范围等\n- **安全机制**: 配置 capability、用户命名空间等安全相关参数\n- **虚拟内存**: 控制 mmap 布局、huge page 行为等\n\n### 调试和监控\n- 开发者通过 sysctl 接口启用/禁用调试功能\n- 监控工具读取 sysctl 参数了解系统当前配置状态\n- 性能调优时动态调整内核参数以获得最佳性能\n\n### 兼容性支持\n- 通过 `sysctl_legacy_va_layout` 等参数维持向后兼容性\n- 支持传统应用程序对 sysctl 接口的使用模式\n- 提供平滑的迁移路径从传统模式到严格模式",
      "similarity": 0.5286881923675537,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/sysctl.c",
          "start_line": 453,
          "end_line": 603,
          "content": [
            "static int do_proc_douintvec_conv(unsigned long *lvalp,",
            "\t\t\t\t  unsigned int *valp,",
            "\t\t\t\t  int write, void *data)",
            "{",
            "\tif (write) {",
            "\t\tif (*lvalp > UINT_MAX)",
            "\t\t\treturn -EINVAL;",
            "\t\tWRITE_ONCE(*valp, *lvalp);",
            "\t} else {",
            "\t\tunsigned int val = READ_ONCE(*valp);",
            "\t\t*lvalp = (unsigned long)val;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,",
            "\t\t  int write, void *buffer,",
            "\t\t  size_t *lenp, loff_t *ppos,",
            "\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,",
            "\t\t\t      int write, void *data),",
            "\t\t  void *data)",
            "{",
            "\tint *i, vleft, first = 1, err = 0;",
            "\tsize_t left;",
            "\tchar *p;",
            "",
            "\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {",
            "\t\t*lenp = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ti = (int *) tbl_data;",
            "\tvleft = table->maxlen / sizeof(*i);",
            "\tleft = *lenp;",
            "",
            "\tif (!conv)",
            "\t\tconv = do_proc_dointvec_conv;",
            "",
            "\tif (write) {",
            "\t\tif (proc_first_pos_non_zero_ignore(ppos, table))",
            "\t\t\tgoto out;",
            "",
            "\t\tif (left > PAGE_SIZE - 1)",
            "\t\t\tleft = PAGE_SIZE - 1;",
            "\t\tp = buffer;",
            "\t}",
            "",
            "\tfor (; left && vleft--; i++, first=0) {",
            "\t\tunsigned long lval;",
            "\t\tbool neg;",
            "",
            "\t\tif (write) {",
            "\t\t\tproc_skip_spaces(&p, &left);",
            "",
            "\t\t\tif (!left)",
            "\t\t\t\tbreak;",
            "\t\t\terr = proc_get_long(&p, &left, &lval, &neg,",
            "\t\t\t\t\t     proc_wspace_sep,",
            "\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);",
            "\t\t\tif (err)",
            "\t\t\t\tbreak;",
            "\t\t\tif (conv(&neg, &lval, i, 1, data)) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tif (conv(&neg, &lval, i, 0, data)) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif (!first)",
            "\t\t\t\tproc_put_char(&buffer, &left, '\\t');",
            "\t\t\tproc_put_long(&buffer, &left, lval, neg);",
            "\t\t}",
            "\t}",
            "",
            "\tif (!write && !first && left && !err)",
            "\t\tproc_put_char(&buffer, &left, '\\n');",
            "\tif (write && !err && left)",
            "\t\tproc_skip_spaces(&p, &left);",
            "\tif (write && first)",
            "\t\treturn err ? : -EINVAL;",
            "\t*lenp -= left;",
            "out:",
            "\t*ppos += *lenp;",
            "\treturn err;",
            "}",
            "static int do_proc_dointvec(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos,",
            "\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,",
            "\t\t\t      int write, void *data),",
            "\t\t  void *data)",
            "{",
            "\treturn __do_proc_dointvec(table->data, table, write,",
            "\t\t\tbuffer, lenp, ppos, conv, data);",
            "}",
            "static int do_proc_douintvec_w(unsigned int *tbl_data,",
            "\t\t\t       struct ctl_table *table,",
            "\t\t\t       void *buffer,",
            "\t\t\t       size_t *lenp, loff_t *ppos,",
            "\t\t\t       int (*conv)(unsigned long *lvalp,",
            "\t\t\t\t\t   unsigned int *valp,",
            "\t\t\t\t\t   int write, void *data),",
            "\t\t\t       void *data)",
            "{",
            "\tunsigned long lval;",
            "\tint err = 0;",
            "\tsize_t left;",
            "\tbool neg;",
            "\tchar *p = buffer;",
            "",
            "\tleft = *lenp;",
            "",
            "\tif (proc_first_pos_non_zero_ignore(ppos, table))",
            "\t\tgoto bail_early;",
            "",
            "\tif (left > PAGE_SIZE - 1)",
            "\t\tleft = PAGE_SIZE - 1;",
            "",
            "\tproc_skip_spaces(&p, &left);",
            "\tif (!left) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\terr = proc_get_long(&p, &left, &lval, &neg,",
            "\t\t\t     proc_wspace_sep,",
            "\t\t\t     sizeof(proc_wspace_sep), NULL);",
            "\tif (err || neg) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\tif (conv(&lval, tbl_data, 1, data)) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\tif (!err && left)",
            "\t\tproc_skip_spaces(&p, &left);",
            "",
            "out_free:",
            "\tif (err)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "",
            "\t/* This is in keeping with old __do_proc_dointvec() */",
            "bail_early:",
            "\t*ppos += *lenp;",
            "\treturn err;",
            "}"
          ],
          "function_name": "do_proc_douintvec_conv, __do_proc_dointvec, do_proc_dointvec, do_proc_douintvec_w",
          "description": "实现多元素整数向量的读写处理逻辑，包含严格写入模式验证、数值解析与转换流程，用于处理proc文件系统中数组形式的sysctl参数操作。",
          "similarity": 0.4558666944503784
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sysctl.c",
          "start_line": 1,
          "end_line": 144,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * sysctl.c: General linux system control interface",
            " *",
            " * Begun 24 March 1995, Stephen Tweedie",
            " * Added /proc support, Dec 1995",
            " * Added bdflush entry and intvec min/max checking, 2/23/96, Tom Dyas.",
            " * Added hooks for /proc/sys/net (minor, minor patch), 96/4/1, Mike Shaver.",
            " * Added kernel/java-{interpreter,appletviewer}, 96/5/10, Mike Shaver.",
            " * Dynamic registration fixes, Stephen Tweedie.",
            " * Added kswapd-interval, ctrl-alt-del, printk stuff, 1/8/97, Chris Horn.",
            " * Made sysctl support optional via CONFIG_SYSCTL, 1/10/97, Chris",
            " *  Horn.",
            " * Added proc_doulongvec_ms_jiffies_minmax, 09/08/99, Carlos H. Bauer.",
            " * Added proc_doulongvec_minmax, 09/08/99, Carlos H. Bauer.",
            " * Changed linked lists to use list.h instead of lists.h, 02/24/00, Bill",
            " *  Wendling.",
            " * The list_for_each() macro wasn't appropriate for the sysctl loop.",
            " *  Removed it and replaced it with older style, 03/23/00, Bill Wendling",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/signal.h>",
            "#include <linux/panic.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/filter.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kobject.h>",
            "#include <linux/net.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/highuid.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/initrd.h>",
            "#include <linux/key.h>",
            "#include <linux/times.h>",
            "#include <linux/limits.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/acpi.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/oom.h>",
            "#include <linux/kmod.h>",
            "#include <linux/capability.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/mount.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/pid.h>",
            "",
            "#include \"../lib/kstrtox.h\"",
            "",
            "#include <linux/uaccess.h>",
            "#include <asm/processor.h>",
            "",
            "#ifdef CONFIG_X86",
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/io.h>",
            "#endif",
            "#ifdef CONFIG_SPARC",
            "#include <asm/setup.h>",
            "#endif",
            "#ifdef CONFIG_RT_MUTEXES",
            "#include <linux/rtmutex.h>",
            "#endif",
            "",
            "/* shared constants to be used in various sysctls */",
            "const int sysctl_vals[] = { 0, 1, 2, 3, 4, 100, 200, 1000, 3000, INT_MAX, 65535, -1 };",
            "EXPORT_SYMBOL(sysctl_vals);",
            "",
            "const unsigned long sysctl_long_vals[] = { 0, 1, LONG_MAX };",
            "EXPORT_SYMBOL_GPL(sysctl_long_vals);",
            "",
            "#if defined(CONFIG_SYSCTL)",
            "",
            "/* Constants used for minimum and maximum */",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "static const int six_hundred_forty_kb = 640 * 1024;",
            "#endif",
            "",
            "",
            "static const int ngroups_max = NGROUPS_MAX;",
            "static const int cap_last_cap = CAP_LAST_CAP;",
            "",
            "#ifdef CONFIG_PROC_SYSCTL",
            "",
            "/**",
            " * enum sysctl_writes_mode - supported sysctl write modes",
            " *",
            " * @SYSCTL_WRITES_LEGACY: each write syscall must fully contain the sysctl value",
            " *\tto be written, and multiple writes on the same sysctl file descriptor",
            " *\twill rewrite the sysctl value, regardless of file position. No warning",
            " *\tis issued when the initial position is not 0.",
            " * @SYSCTL_WRITES_WARN: same as above but warn when the initial file position is",
            " *\tnot 0.",
            " * @SYSCTL_WRITES_STRICT: writes to numeric sysctl entries must always be at",
            " *\tfile position 0 and the value must be fully contained in the buffer",
            " *\tsent to the write syscall. If dealing with strings respect the file",
            " *\tposition, but restrict this to the max length of the buffer, anything",
            " *\tpassed the max length will be ignored. Multiple writes will append",
            " *\tto the buffer.",
            " *",
            " * These write modes control how current file position affects the behavior of",
            " * updating sysctl values through the proc interface on each write.",
            " */",
            "enum sysctl_writes_mode {",
            "\tSYSCTL_WRITES_LEGACY\t\t= -1,",
            "\tSYSCTL_WRITES_WARN\t\t= 0,",
            "\tSYSCTL_WRITES_STRICT\t\t= 1,",
            "};",
            "",
            "static enum sysctl_writes_mode sysctl_writes_strict = SYSCTL_WRITES_STRICT;",
            "#endif /* CONFIG_PROC_SYSCTL */",
            "",
            "#if defined(HAVE_ARCH_PICK_MMAP_LAYOUT) || \\",
            "    defined(CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT)",
            "int sysctl_legacy_va_layout;",
            "#endif",
            "",
            "#endif /* CONFIG_SYSCTL */",
            "",
            "/*",
            " * /proc/sys support",
            " */",
            "",
            "#ifdef CONFIG_PROC_SYSCTL",
            ""
          ],
          "function_name": null,
          "description": "声明sysctl通用系统控制接口的实现，包含头文件和公共常量定义，用于支持/proc/sys虚拟文件系统中的参数控制，核心功能为构建sysctl框架基础结构。",
          "similarity": 0.4497450590133667
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/sysctl.c",
          "start_line": 1243,
          "end_line": 1360,
          "content": [
            "static int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,",
            "\t\t\t\t\t\tint *valp,",
            "\t\t\t\t\t\tint write, void *data)",
            "{",
            "\tif (write) {",
            "\t\tif (USER_HZ < HZ && *lvalp > (LONG_MAX / HZ) * USER_HZ)",
            "\t\t\treturn 1;",
            "\t\t*valp = clock_t_to_jiffies(*negp ? -*lvalp : *lvalp);",
            "\t} else {",
            "\t\tint val = *valp;",
            "\t\tunsigned long lval;",
            "\t\tif (val < 0) {",
            "\t\t\t*negp = true;",
            "\t\t\tlval = -(unsigned long)val;",
            "\t\t} else {",
            "\t\t\t*negp = false;",
            "\t\t\tlval = (unsigned long)val;",
            "\t\t}",
            "\t\t*lvalp = jiffies_to_clock_t(lval);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,",
            "\t\t\t\t\t    int *valp,",
            "\t\t\t\t\t    int write, void *data)",
            "{",
            "\tif (write) {",
            "\t\tunsigned long jif = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);",
            "",
            "\t\tif (jif > INT_MAX)",
            "\t\t\treturn 1;",
            "\t\tWRITE_ONCE(*valp, (int)jif);",
            "\t} else {",
            "\t\tint val = READ_ONCE(*valp);",
            "\t\tunsigned long lval;",
            "\t\tif (val < 0) {",
            "\t\t\t*negp = true;",
            "\t\t\tlval = -(unsigned long)val;",
            "\t\t} else {",
            "\t\t\t*negp = false;",
            "\t\t\tlval = (unsigned long)val;",
            "\t\t}",
            "\t\t*lvalp = jiffies_to_msecs(lval);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int do_proc_dointvec_ms_jiffies_minmax_conv(bool *negp, unsigned long *lvalp,",
            "\t\t\t\t\t\tint *valp, int write, void *data)",
            "{",
            "\tint tmp, ret;",
            "\tstruct do_proc_dointvec_minmax_conv_param *param = data;",
            "\t/*",
            "\t * If writing, first do so via a temporary local int so we can",
            "\t * bounds-check it before touching *valp.",
            "\t */",
            "\tint *ip = write ? &tmp : valp;",
            "",
            "\tret = do_proc_dointvec_ms_jiffies_conv(negp, lvalp, ip, write, data);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (write) {",
            "\t\tif ((param->min && *param->min > tmp) ||",
            "\t\t\t\t(param->max && *param->max < tmp))",
            "\t\t\treturn -EINVAL;",
            "\t\t*valp = tmp;",
            "\t}",
            "\treturn 0;",
            "}",
            "int proc_dointvec_jiffies(struct ctl_table *table, int write,",
            "\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "    return do_proc_dointvec(table,write,buffer,lenp,ppos,",
            "\t\t    \t    do_proc_dointvec_jiffies_conv,NULL);",
            "}",
            "int proc_dointvec_ms_jiffies_minmax(struct ctl_table *table, int write,",
            "\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct do_proc_dointvec_minmax_conv_param param = {",
            "\t\t.min = (int *) table->extra1,",
            "\t\t.max = (int *) table->extra2,",
            "\t};",
            "\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,",
            "\t\t\tdo_proc_dointvec_ms_jiffies_minmax_conv, &param);",
            "}",
            "int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,",
            "\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,",
            "\t\t\t\tdo_proc_dointvec_userhz_jiffies_conv, NULL);",
            "}",
            "int proc_dointvec_ms_jiffies(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos)",
            "{",
            "\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,",
            "\t\t\t\tdo_proc_dointvec_ms_jiffies_conv, NULL);",
            "}",
            "static int proc_do_cad_pid(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct pid *new_pid;",
            "\tpid_t tmp;",
            "\tint r;",
            "",
            "\ttmp = pid_vnr(cad_pid);",
            "",
            "\tr = __do_proc_dointvec(&tmp, table, write, buffer,",
            "\t\t\t       lenp, ppos, NULL, NULL);",
            "\tif (r || !write)",
            "\t\treturn r;",
            "",
            "\tnew_pid = find_get_pid(tmp);",
            "\tif (!new_pid)",
            "\t\treturn -ESRCH;",
            "",
            "\tput_pid(xchg(&cad_pid, new_pid));",
            "\treturn 0;",
            "}"
          ],
          "function_name": "do_proc_dointvec_userhz_jiffies_conv, do_proc_dointvec_ms_jiffies_conv, do_proc_dointvec_ms_jiffies_minmax_conv, proc_dointvec_jiffies, proc_dointvec_ms_jiffies_minmax, proc_dointvec_userhz_jiffies, proc_dointvec_ms_jiffies, proc_do_cad_pid",
          "description": "该代码段实现了多个用于处理 `/proc/sys` 系统控制表项（sysctl）的转换函数，核心功能是**将用户空间的字符串参数转换为内核内部表示的时间单位（jiffies/ms）并进行边界校验**。  \n其中 `do_proc_dointvec_*_conv` 系列函数负责具体转换逻辑，支持负值处理、Hz/USER_HZ 比例计算及溢出检测；`proc_dointvec_ms_jiffies_minmax` 引入了最小/最大值限制校验；`proc_do_cad_pid` 则专门用于安全地更新控制台关联进程 PID。  \n代码上下文完整，未引入未提及的API或机制。",
          "similarity": 0.44064509868621826
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/sysctl.c",
          "start_line": 1089,
          "end_line": 1203,
          "content": [
            "static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table,",
            "\t\tint write, void *buffer, size_t *lenp, loff_t *ppos,",
            "\t\tunsigned long convmul, unsigned long convdiv)",
            "{",
            "\tunsigned long *i, *min, *max;",
            "\tint vleft, first = 1, err = 0;",
            "\tsize_t left;",
            "\tchar *p;",
            "",
            "\tif (!data || !table->maxlen || !*lenp || (*ppos && !write)) {",
            "\t\t*lenp = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ti = data;",
            "\tmin = table->extra1;",
            "\tmax = table->extra2;",
            "\tvleft = table->maxlen / sizeof(unsigned long);",
            "\tleft = *lenp;",
            "",
            "\tif (write) {",
            "\t\tif (proc_first_pos_non_zero_ignore(ppos, table))",
            "\t\t\tgoto out;",
            "",
            "\t\tif (left > PAGE_SIZE - 1)",
            "\t\t\tleft = PAGE_SIZE - 1;",
            "\t\tp = buffer;",
            "\t}",
            "",
            "\tfor (; left && vleft--; i++, first = 0) {",
            "\t\tunsigned long val;",
            "",
            "\t\tif (write) {",
            "\t\t\tbool neg;",
            "",
            "\t\t\tproc_skip_spaces(&p, &left);",
            "\t\t\tif (!left)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\terr = proc_get_long(&p, &left, &val, &neg,",
            "\t\t\t\t\t     proc_wspace_sep,",
            "\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);",
            "\t\t\tif (err || neg) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\tval = convmul * val / convdiv;",
            "\t\t\tif ((min && val < *min) || (max && val > *max)) {",
            "\t\t\t\terr = -EINVAL;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tWRITE_ONCE(*i, val);",
            "\t\t} else {",
            "\t\t\tval = convdiv * READ_ONCE(*i) / convmul;",
            "\t\t\tif (!first)",
            "\t\t\t\tproc_put_char(&buffer, &left, '\\t');",
            "\t\t\tproc_put_long(&buffer, &left, val, false);",
            "\t\t}",
            "\t}",
            "",
            "\tif (!write && !first && left && !err)",
            "\t\tproc_put_char(&buffer, &left, '\\n');",
            "\tif (write && !err)",
            "\t\tproc_skip_spaces(&p, &left);",
            "\tif (write && first)",
            "\t\treturn err ? : -EINVAL;",
            "\t*lenp -= left;",
            "out:",
            "\t*ppos += *lenp;",
            "\treturn err;",
            "}",
            "static int do_proc_doulongvec_minmax(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos, unsigned long convmul,",
            "\t\tunsigned long convdiv)",
            "{",
            "\treturn __do_proc_doulongvec_minmax(table->data, table, write,",
            "\t\t\tbuffer, lenp, ppos, convmul, convdiv);",
            "}",
            "int proc_doulongvec_minmax(struct ctl_table *table, int write,",
            "\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "    return do_proc_doulongvec_minmax(table, write, buffer, lenp, ppos, 1l, 1l);",
            "}",
            "int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,",
            "\t\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "    return do_proc_doulongvec_minmax(table, write, buffer,",
            "\t\t\t\t     lenp, ppos, HZ, 1000l);",
            "}",
            "static int do_proc_dointvec_jiffies_conv(bool *negp, unsigned long *lvalp,",
            "\t\t\t\t\t int *valp,",
            "\t\t\t\t\t int write, void *data)",
            "{",
            "\tif (write) {",
            "\t\tif (*lvalp > INT_MAX / HZ)",
            "\t\t\treturn 1;",
            "\t\tif (*negp)",
            "\t\t\tWRITE_ONCE(*valp, -*lvalp * HZ);",
            "\t\telse",
            "\t\t\tWRITE_ONCE(*valp, *lvalp * HZ);",
            "\t} else {",
            "\t\tint val = READ_ONCE(*valp);",
            "\t\tunsigned long lval;",
            "\t\tif (val < 0) {",
            "\t\t\t*negp = true;",
            "\t\t\tlval = -(unsigned long)val;",
            "\t\t} else {",
            "\t\t\t*negp = false;",
            "\t\t\tlval = (unsigned long)val;",
            "\t\t}",
            "\t\t*lvalp = lval / HZ;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__do_proc_doulongvec_minmax, do_proc_doulongvec_minmax, proc_doulongvec_minmax, proc_doulongvec_ms_jiffies_minmax, do_proc_dointvec_jiffies_conv",
          "description": "该代码实现了一组用于处理 `/proc/sys` 系统控制表项的通用函数，核心功能是管理 `unsigned long` 类型向量的读写操作，并支持值范围校验及单位转换。  \n`__do_proc_doulongvec_minmax` 是核心函数，通过 `min`/`max` 指针限制数值范围，并利用 `convmul`/`convdiv` 进行单位转换；`proc_doulongvec_minmax` 和 `proc_doulongvec_ms_jiffies_minmax` 分别封装了默认转换逻辑（1:1 和 ms:jiffies）。  \n`do_proc_dointvec_jiffies_conv` 处理带符号整数与 jiffies 的双向转换，但因上下文缺失，无法确认其完整依赖关系。",
          "similarity": 0.44054991006851196
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/sysctl.c",
          "start_line": 760,
          "end_line": 862,
          "content": [
            "int proc_douintvec(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos)",
            "{",
            "\treturn do_proc_douintvec(table, write, buffer, lenp, ppos,",
            "\t\t\t\t do_proc_douintvec_conv, NULL);",
            "}",
            "static int proc_taint(struct ctl_table *table, int write,",
            "\t\t\t       void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct ctl_table t;",
            "\tunsigned long tmptaint = get_taint();",
            "\tint err;",
            "",
            "\tif (write && !capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tt = *table;",
            "\tt.data = &tmptaint;",
            "\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);",
            "\tif (err < 0)",
            "\t\treturn err;",
            "",
            "\tif (write) {",
            "\t\tint i;",
            "",
            "\t\t/*",
            "\t\t * If we are relying on panic_on_taint not producing",
            "\t\t * false positives due to userspace input, bail out",
            "\t\t * before setting the requested taint flags.",
            "\t\t */",
            "\t\tif (panic_on_taint_nousertaint && (tmptaint & panic_on_taint))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * Poor man's atomic or. Not worth adding a primitive",
            "\t\t * to everyone's atomic.h for this",
            "\t\t */",
            "\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++)",
            "\t\t\tif ((1UL << i) & tmptaint)",
            "\t\t\t\tadd_taint(i, LOCKDEP_STILL_OK);",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "static int do_proc_dointvec_minmax_conv(bool *negp, unsigned long *lvalp,",
            "\t\t\t\t\tint *valp,",
            "\t\t\t\t\tint write, void *data)",
            "{",
            "\tint tmp, ret;",
            "\tstruct do_proc_dointvec_minmax_conv_param *param = data;",
            "\t/*",
            "\t * If writing, first do so via a temporary local int so we can",
            "\t * bounds-check it before touching *valp.",
            "\t */",
            "\tint *ip = write ? &tmp : valp;",
            "",
            "\tret = do_proc_dointvec_conv(negp, lvalp, ip, write, data);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (write) {",
            "\t\tif ((param->min && *param->min > tmp) ||",
            "\t\t    (param->max && *param->max < tmp))",
            "\t\t\treturn -EINVAL;",
            "\t\tWRITE_ONCE(*valp, tmp);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int proc_dointvec_minmax(struct ctl_table *table, int write,",
            "\t\t  void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct do_proc_dointvec_minmax_conv_param param = {",
            "\t\t.min = (int *) table->extra1,",
            "\t\t.max = (int *) table->extra2,",
            "\t};",
            "\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,",
            "\t\t\t\tdo_proc_dointvec_minmax_conv, &param);",
            "}",
            "static int do_proc_douintvec_minmax_conv(unsigned long *lvalp,",
            "\t\t\t\t\t unsigned int *valp,",
            "\t\t\t\t\t int write, void *data)",
            "{",
            "\tint ret;",
            "\tunsigned int tmp;",
            "\tstruct do_proc_douintvec_minmax_conv_param *param = data;",
            "\t/* write via temporary local uint for bounds-checking */",
            "\tunsigned int *up = write ? &tmp : valp;",
            "",
            "\tret = do_proc_douintvec_conv(lvalp, up, write, data);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (write) {",
            "\t\tif ((param->min && *param->min > tmp) ||",
            "\t\t    (param->max && *param->max < tmp))",
            "\t\t\treturn -ERANGE;",
            "",
            "\t\tWRITE_ONCE(*valp, tmp);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "proc_douintvec, proc_taint, do_proc_dointvec_minmax_conv, proc_dointvec_minmax, do_proc_douintvec_minmax_conv",
          "description": "该代码段主要实现 sysctl 参数的读写处理，核心功能包括：  \n1. `proc_douintvec` 和 `proc_dointvec_minmax` 等函数通过封装 `do_proc_douintvec*` 家族函数，支持带范围校验的整数/无符号整数参数解析与设置；  \n2. `proc_taint` 函数专用于处理内核污点（taint）标志的写入，需 CAP_SYS_ADMIN 权限，且在设置前检查与 `panic_on_taint` 的冲突；  \n3. 所有函数均基于统一的转换框架（如 `do_proc_dointvec_minmax_conv`），通过传递 min/max 指针实现数值边界校验，避免越界问题。",
          "similarity": 0.4190673530101776
        }
      ]
    },
    {
      "source_file": "kernel/pid_sysctl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_sysctl.h`\n\n---\n\n# `pid_sysctl.h` 技术文档\n\n## 1. 文件概述\n\n`pid_sysctl.h` 是 Linux 内核中用于定义与 PID 命名空间（`pid_namespace`）相关的系统控制（sysctl）接口的头文件。其核心功能是提供对 `memfd_noexec` 系统策略的运行时配置支持，该策略用于控制通过 `memfd_create()` 创建的内存文件是否允许执行代码。该配置具有层级继承语义：子 PID 命名空间的策略不能比其父命名空间更宽松，以确保安全策略的向下兼容性和强制性。\n\n## 2. 核心功能\n\n### 函数\n\n- **`pid_mfd_noexec_dointvec_minmax`**  \n  自定义的 sysctl 处理函数，用于读写 `memfd_noexec` 策略值。在写入时执行权限检查和策略继承约束验证。\n\n- **`register_pid_ns_sysctl_table_vm`**  \n  内联函数，用于向内核 sysctl 子系统注册 `vm.memfd_noexec` 控制项（仅在 `CONFIG_SYSCTL` 和 `CONFIG_MEMFD_CREATE` 同时启用时有效）。\n\n### 数据结构\n\n- **`pid_ns_ctl_table_vm`**  \n  `ctl_table` 类型的静态数组，定义了 `vm.memfd_noexec` sysctl 条目，包括其名称、数据指针、访问权限、处理函数及取值范围（0 到 2）。\n\n## 3. 关键实现\n\n- **权限控制**：  \n  在写入 `memfd_noexec` 值时，调用 `ns_capable(ns->user_ns, CAP_SYS_ADMIN)` 检查当前任务是否在对应用户命名空间中拥有 `CAP_SYS_ADMIN` 能力，防止非特权用户修改安全策略。\n\n- **策略继承约束**：  \n  通过 `pidns_memfd_noexec_scope(ns->parent)` 获取父 PID 命名空间的策略值 `parent_scope`，并确保当前命名空间的策略值 `scope` 不小于父策略（即不能更宽松）。实际写入前使用 `max(READ_ONCE(ns->memfd_noexec_scope), parent_scope)` 保证该约束。\n\n- **原子读写**：  \n  使用 `READ_ONCE()` 和 `WRITE_ONCE()` 对 `ns->memfd_noexec_scope` 进行访问，确保在并发环境下内存访问的可见性和顺序性。\n\n- **sysctl 注册**：  \n  通过 `register_sysctl(\"vm\", pid_ns_ctl_table_vm)` 将控制项注册到 `/proc/sys/vm/memfd_noexec` 路径下，供用户空间通过标准 sysctl 接口访问。\n\n- **条件编译**：  \n  整个功能仅在 `CONFIG_SYSCTL`（启用 sysctl 支持）和 `CONFIG_MEMFD_CREATE`（启用 memfd_create 系统调用）同时配置时编译，否则 `register_pid_ns_sysctl_table_vm` 为空内联函数，避免代码膨胀。\n\n## 4. 依赖关系\n\n- **`<linux/pid_namespace.h>`**：  \n  提供 `struct pid_namespace` 定义及辅助函数如 `task_active_pid_ns()` 和 `pidns_memfd_noexec_scope()`。\n\n- **`CONFIG_SYSCTL`**：  \n  内核配置选项，启用 sysctl 框架支持，提供 `register_sysctl`、`proc_dointvec_minmax` 等接口。\n\n- **`CONFIG_MEMFD_CREATE`**：  \n  内核配置选项，启用 `memfd_create()` 系统调用及相关功能（如 `memfd_noexec_scope` 字段）。\n\n- **能力子系统（Capabilities）**：  \n  依赖 `ns_capable()` 进行命名空间感知的权限检查。\n\n## 5. 使用场景\n\n- **安全策略配置**：  \n  系统管理员或容器运行时可通过写入 `/proc/sys/vm/memfd_noexec` 设置当前 PID 命名空间中 `memfd` 文件的执行限制级别（0=允许执行，1=禁止执行但可覆盖，2=严格禁止执行），用于防御基于内存文件的代码注入攻击。\n\n- **容器隔离**：  \n  在容器化环境中，不同容器运行在独立的 PID 命名空间中。父命名空间（如宿主机）可设置较严格的 `memfd_noexec` 策略，子容器无法降低该策略级别，从而实现自上而下的安全策略强制。\n\n- **运行时动态调整**：  \n  允许在系统运行期间动态调整 `memfd` 执行策略，无需重启或重新加载内核模块，提升系统灵活性与安全性。",
      "similarity": 0.5229375958442688,
      "chunks": []
    }
  ]
}