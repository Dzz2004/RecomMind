{
  "query": "线程资源共享与隔离机制",
  "timestamp": "2025-12-26 00:46:42",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/matrix.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:03:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\matrix.c`\n\n---\n\n# `irq/matrix.c` 技术文档\n\n## 1. 文件概述\n\n`irq/matrix.c` 实现了一个通用的中断位图（IRQ matrix）管理机制，用于在多 CPU 系统中高效地分配和管理中断向量（或中断位）。该机制支持两类中断分配：\n\n- **普通分配（allocated）**：由设备驱动等动态申请的中断。\n- **托管分配（managed）**：由内核子系统（如 MSI/MSI-X）预先保留、按需激活的中断。\n\n该文件通过 per-CPU 的位图结构，结合全局状态跟踪，实现了跨 CPU 的中断资源分配、预留、释放和在线/离线管理，特别适用于中断向量数量有限（如 x86 的 256 个向量）的架构。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct cpumap`**：每个 CPU 的本地中断位图状态\n  - `available`：当前 CPU 可用的中断数量\n  - `allocated`：已分配的普通中断数量\n  - `managed` / `managed_allocated`：预留和已激活的托管中断数量\n  - `alloc_map[]`：记录已分配的普通中断位\n  - `managed_map[]`：记录预留的托管中断位\n  - `initialized` / `online`：CPU 初始化和在线状态\n\n- **`struct irq_matrix`**：全局中断矩阵控制结构\n  - `matrix_bits`：总位图大小（≤ `IRQ_MATRIX_BITS`）\n  - `alloc_start` / `alloc_end`：可分配范围\n  - `global_available`：全局可用中断总数\n  - `system_map[]`：系统保留位（如 APIC 自身使用的向量）\n  - `maps`：指向 per-CPU `cpumap` 的指针\n  - `scratch_map[]`：临时位图，用于分配时的合并计算\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `irq_alloc_matrix()` | 分配并初始化一个 `irq_matrix` 结构 |\n| `irq_matrix_online()` / `irq_matrix_offline()` | 将本地 CPU 的中断矩阵置为在线/离线状态 |\n| `irq_matrix_assign_system()` | 在矩阵中保留系统级中断位（如 APIC 向量） |\n| `irq_matrix_reserve_managed()` | 在指定 CPU 掩码上为托管中断预留位 |\n| `irq_matrix_remove_managed()` | 移除托管中断的预留位 |\n| `irq_matrix_alloc_managed()` | 从预留的托管中断中分配一个实际使用的中断 |\n| `matrix_alloc_area()` | 内部辅助函数：在合并位图中查找连续空闲区域 |\n| `matrix_find_best_cpu()` / `matrix_find_best_cpu_managed()` | 选择最优 CPU（基于可用数或托管分配数最少） |\n\n## 3. 关键实现\n\n### 位图合并分配策略\n- 在分配中断时，`matrix_alloc_area()` 会临时合并三个位图：\n  1. 当前 CPU 的 `managed_map`（托管预留）\n  2. 全局 `system_map`（系统保留）\n  3. 当前 CPU 的 `alloc_map`（已分配）\n- 使用 `bitmap_find_next_zero_area()` 在合并后的位图中查找连续空闲区域，确保不会重复分配。\n\n### 托管中断（Managed IRQ）机制\n- **两阶段分配**：\n  1. **预留（reserve）**：调用 `irq_matrix_reserve_managed()` 在多个 CPU 上各预留一个位（不一定对齐）。\n  2. **激活（alloc）**：调用 `irq_matrix_alloc_managed()` 从预留位中选择一个未使用的位进行实际分配。\n- **动态 CPU 选择**：`matrix_find_best_cpu_managed()` 优先选择 `managed_allocated` 最少的 CPU，实现负载均衡。\n\n### 系统中断保留\n- `irq_matrix_assign_system()` 用于保留如 x86 的 `IRQ0_VECTOR`（时钟中断）等关键系统向量。\n- 通过 `BUG_ON()` 强制保证：系统中断只能在单 CPU 初始化阶段分配，防止运行时冲突。\n\n### 在线/离线管理\n- CPU 上线时，将其 `available` 计数加入 `global_available`。\n- CPU 离线时，从全局计数中减去，但保留其位图数据（支持重新上线）。\n\n### 跟踪与调试\n- 集成 `trace/events/irq_matrix.h`，提供分配、预留、系统保留等关键操作的 tracepoint，便于调试中断分配问题。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/bitmap.h>`：位图操作（`bitmap_set`, `bitmap_find_next_zero_area` 等）\n  - `<linux/percpu.h>`：Per-CPU 变量支持\n  - `<linux/cpu.h>`：CPU 在线/离线状态\n  - `<linux/irq.h>`：中断子系统基础定义\n  - `<trace/events/irq_matrix.h>`：自定义 tracepoint\n\n- **内核子系统**：\n  - **中断子系统**：作为底层分配器，被 `irqdomain`、MSI/MSI-X 驱动等使用。\n  - **x86 APIC 驱动**：典型使用者，用于管理 256 个中断向量的分配（如 `kernel/irq/vector.c`）。\n\n## 5. 使用场景\n\n- **x86 中断向量管理**：在 `CONFIG_X86_IO_APIC` 或 `CONFIG_X86_LOCAL_APIC` 下，用于分配 IRQ 向量（0-255），区分系统向量、普通设备中断和 MSI 中断。\n- **MSI/MSI-X 中断分配**：PCIe 设备的 MSI 中断通过托管机制预留和分配，确保每个设备在多个 CPU 上有可用向量。\n- **CPU 热插拔**：支持 CPU 动态上线/下线时的中断资源重新平衡。\n- **中断负载均衡**：通过 `matrix_find_best_cpu*` 函数，在多 CPU 间均匀分配中断，避免单 CPU 向量耗尽。",
      "similarity": 0.5977622270584106,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 251,
          "end_line": 365,
          "content": [
            "void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)",
            "{",
            "\tunsigned int cpu;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "\t\tunsigned int bit, end = m->alloc_end;",
            "",
            "\t\tif (WARN_ON_ONCE(!cm->managed))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Get managed bit which are not allocated */",
            "\t\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);",
            "",
            "\t\tbit = find_first_bit(m->scratch_map, end);",
            "\t\tif (WARN_ON_ONCE(bit >= end))",
            "\t\t\tcontinue;",
            "",
            "\t\tclear_bit(bit, cm->managed_map);",
            "",
            "\t\tcm->managed--;",
            "\t\tif (cm->online) {",
            "\t\t\tcm->available++;",
            "\t\t\tm->global_available++;",
            "\t\t}",
            "\t\ttrace_irq_matrix_remove_managed(bit, cpu, m, cm);",
            "\t}",
            "}",
            "int irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,",
            "\t\t\t     unsigned int *mapped_cpu)",
            "{",
            "\tunsigned int bit, cpu, end;",
            "\tstruct cpumap *cm;",
            "",
            "\tif (cpumask_empty(msk))",
            "\t\treturn -EINVAL;",
            "",
            "\tcpu = matrix_find_best_cpu_managed(m, msk);",
            "\tif (cpu == UINT_MAX)",
            "\t\treturn -ENOSPC;",
            "",
            "\tcm = per_cpu_ptr(m->maps, cpu);",
            "\tend = m->alloc_end;",
            "\t/* Get managed bit which are not allocated */",
            "\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);",
            "\tbit = find_first_bit(m->scratch_map, end);",
            "\tif (bit >= end)",
            "\t\treturn -ENOSPC;",
            "\tset_bit(bit, cm->alloc_map);",
            "\tcm->allocated++;",
            "\tcm->managed_allocated++;",
            "\tm->total_allocated++;",
            "\t*mapped_cpu = cpu;",
            "\ttrace_irq_matrix_alloc_managed(bit, cpu, m, cm);",
            "\treturn bit;",
            "}",
            "void irq_matrix_assign(struct irq_matrix *m, unsigned int bit)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))",
            "\t\treturn;",
            "\tif (WARN_ON_ONCE(test_and_set_bit(bit, cm->alloc_map)))",
            "\t\treturn;",
            "\tcm->allocated++;",
            "\tm->total_allocated++;",
            "\tcm->available--;",
            "\tm->global_available--;",
            "\ttrace_irq_matrix_assign(bit, smp_processor_id(), m, cm);",
            "}",
            "void irq_matrix_reserve(struct irq_matrix *m)",
            "{",
            "\tif (m->global_reserved == m->global_available)",
            "\t\tpr_warn(\"Interrupt reservation exceeds available resources\\n\");",
            "",
            "\tm->global_reserved++;",
            "\ttrace_irq_matrix_reserve(m);",
            "}",
            "void irq_matrix_remove_reserved(struct irq_matrix *m)",
            "{",
            "\tm->global_reserved--;",
            "\ttrace_irq_matrix_remove_reserved(m);",
            "}",
            "int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,",
            "\t\t     bool reserved, unsigned int *mapped_cpu)",
            "{",
            "\tunsigned int cpu, bit;",
            "\tstruct cpumap *cm;",
            "",
            "\t/*",
            "\t * Not required in theory, but matrix_find_best_cpu() uses",
            "\t * for_each_cpu() which ignores the cpumask on UP .",
            "\t */",
            "\tif (cpumask_empty(msk))",
            "\t\treturn -EINVAL;",
            "",
            "\tcpu = matrix_find_best_cpu(m, msk);",
            "\tif (cpu == UINT_MAX)",
            "\t\treturn -ENOSPC;",
            "",
            "\tcm = per_cpu_ptr(m->maps, cpu);",
            "\tbit = matrix_alloc_area(m, cm, 1, false);",
            "\tif (bit >= m->alloc_end)",
            "\t\treturn -ENOSPC;",
            "\tcm->allocated++;",
            "\tcm->available--;",
            "\tm->total_allocated++;",
            "\tm->global_available--;",
            "\tif (reserved)",
            "\t\tm->global_reserved--;",
            "\t*mapped_cpu = cpu;",
            "\ttrace_irq_matrix_alloc(bit, cpu, m, cm);",
            "\treturn bit;",
            "",
            "}"
          ],
          "function_name": "irq_matrix_remove_managed, irq_matrix_alloc_managed, irq_matrix_assign, irq_matrix_reserve, irq_matrix_remove_reserved, irq_matrix_alloc",
          "description": "实现中断位的分配/回收机制，包含保留中断位的管理、跨CPU的中断分配逻辑，以及根据预留状态进行资源分配的控制流程",
          "similarity": 0.6444514393806458
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 78,
          "end_line": 205,
          "content": [
            "void irq_matrix_online(struct irq_matrix *m)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tBUG_ON(cm->online);",
            "",
            "\tif (!cm->initialized) {",
            "\t\tcm->available = m->alloc_size;",
            "\t\tcm->available -= cm->managed + m->systembits_inalloc;",
            "\t\tcm->initialized = true;",
            "\t}",
            "\tm->global_available += cm->available;",
            "\tcm->online = true;",
            "\tm->online_maps++;",
            "\ttrace_irq_matrix_online(m);",
            "}",
            "void irq_matrix_offline(struct irq_matrix *m)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\t/* Update the global available size */",
            "\tm->global_available -= cm->available;",
            "\tcm->online = false;",
            "\tm->online_maps--;",
            "\ttrace_irq_matrix_offline(m);",
            "}",
            "static unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,",
            "\t\t\t\t      unsigned int num, bool managed)",
            "{",
            "\tunsigned int area, start = m->alloc_start;",
            "\tunsigned int end = m->alloc_end;",
            "",
            "\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);",
            "\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);",
            "\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);",
            "\tif (area >= end)",
            "\t\treturn area;",
            "\tif (managed)",
            "\t\tbitmap_set(cm->managed_map, area, num);",
            "\telse",
            "\t\tbitmap_set(cm->alloc_map, area, num);",
            "\treturn area;",
            "}",
            "static unsigned int matrix_find_best_cpu(struct irq_matrix *m,",
            "\t\t\t\t\tconst struct cpumask *msk)",
            "{",
            "\tunsigned int cpu, best_cpu, maxavl = 0;",
            "\tstruct cpumap *cm;",
            "",
            "\tbest_cpu = UINT_MAX;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tcm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\t\tif (!cm->online || cm->available <= maxavl)",
            "\t\t\tcontinue;",
            "",
            "\t\tbest_cpu = cpu;",
            "\t\tmaxavl = cm->available;",
            "\t}",
            "\treturn best_cpu;",
            "}",
            "static unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,",
            "\t\t\t\t\t\tconst struct cpumask *msk)",
            "{",
            "\tunsigned int cpu, best_cpu, allocated = UINT_MAX;",
            "\tstruct cpumap *cm;",
            "",
            "\tbest_cpu = UINT_MAX;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tcm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\t\tif (!cm->online || cm->managed_allocated > allocated)",
            "\t\t\tcontinue;",
            "",
            "\t\tbest_cpu = cpu;",
            "\t\tallocated = cm->managed_allocated;",
            "\t}",
            "\treturn best_cpu;",
            "}",
            "void irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit,",
            "\t\t\t      bool replace)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tBUG_ON(bit > m->matrix_bits);",
            "\tBUG_ON(m->online_maps > 1 || (m->online_maps && !replace));",
            "",
            "\tset_bit(bit, m->system_map);",
            "\tif (replace) {",
            "\t\tBUG_ON(!test_and_clear_bit(bit, cm->alloc_map));",
            "\t\tcm->allocated--;",
            "\t\tm->total_allocated--;",
            "\t}",
            "\tif (bit >= m->alloc_start && bit < m->alloc_end)",
            "\t\tm->systembits_inalloc++;",
            "",
            "\ttrace_irq_matrix_assign_system(bit, m);",
            "}",
            "int irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk)",
            "{",
            "\tunsigned int cpu, failed_cpu;",
            "",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "\t\tunsigned int bit;",
            "",
            "\t\tbit = matrix_alloc_area(m, cm, 1, true);",
            "\t\tif (bit >= m->alloc_end)",
            "\t\t\tgoto cleanup;",
            "\t\tcm->managed++;",
            "\t\tif (cm->online) {",
            "\t\t\tcm->available--;",
            "\t\t\tm->global_available--;",
            "\t\t}",
            "\t\ttrace_irq_matrix_reserve_managed(bit, cpu, m, cm);",
            "\t}",
            "\treturn 0;",
            "cleanup:",
            "\tfailed_cpu = cpu;",
            "\tfor_each_cpu(cpu, msk) {",
            "\t\tif (cpu == failed_cpu)",
            "\t\t\tbreak;",
            "\t\tirq_matrix_remove_managed(m, cpumask_of(cpu));",
            "\t}",
            "\treturn -ENOSPC;",
            "}"
          ],
          "function_name": "irq_matrix_online, irq_matrix_offline, matrix_alloc_area, matrix_find_best_cpu, matrix_find_best_cpu_managed, irq_matrix_assign_system, irq_matrix_reserve_managed",
          "description": "实现CPU矩阵的上线/下线操作，通过bitmap操作实现中断位的分配策略，包含寻找最佳CPU的逻辑，支持系统位管理和保留区域的分配与追踪",
          "similarity": 0.6095526218414307
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 418,
          "end_line": 483,
          "content": [
            "void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,",
            "\t\t     unsigned int bit, bool managed)",
            "{",
            "\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))",
            "\t\treturn;",
            "",
            "\tif (WARN_ON_ONCE(!test_and_clear_bit(bit, cm->alloc_map)))",
            "\t\treturn;",
            "",
            "\tcm->allocated--;",
            "\tif(managed)",
            "\t\tcm->managed_allocated--;",
            "",
            "\tif (cm->online)",
            "\t\tm->total_allocated--;",
            "",
            "\tif (!managed) {",
            "\t\tcm->available++;",
            "\t\tif (cm->online)",
            "\t\t\tm->global_available++;",
            "\t}",
            "\ttrace_irq_matrix_free(bit, cpu, m, cm);",
            "}",
            "unsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\tif (!cpudown)",
            "\t\treturn m->global_available;",
            "\treturn m->global_available - cm->available;",
            "}",
            "unsigned int irq_matrix_reserved(struct irq_matrix *m)",
            "{",
            "\treturn m->global_reserved;",
            "}",
            "unsigned int irq_matrix_allocated(struct irq_matrix *m)",
            "{",
            "\tstruct cpumap *cm = this_cpu_ptr(m->maps);",
            "",
            "\treturn cm->allocated - cm->managed_allocated;",
            "}",
            "void irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind)",
            "{",
            "\tunsigned int nsys = bitmap_weight(m->system_map, m->matrix_bits);",
            "\tint cpu;",
            "",
            "\tseq_printf(sf, \"Online bitmaps:   %6u\\n\", m->online_maps);",
            "\tseq_printf(sf, \"Global available: %6u\\n\", m->global_available);",
            "\tseq_printf(sf, \"Global reserved:  %6u\\n\", m->global_reserved);",
            "\tseq_printf(sf, \"Total allocated:  %6u\\n\", m->total_allocated);",
            "\tseq_printf(sf, \"System: %u: %*pbl\\n\", nsys, m->matrix_bits,",
            "\t\t   m->system_map);",
            "\tseq_printf(sf, \"%*s| CPU | avl | man | mac | act | vectors\\n\", ind, \" \");",
            "\tcpus_read_lock();",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);",
            "",
            "\t\tseq_printf(sf, \"%*s %4d  %4u  %4u  %4u %4u  %*pbl\\n\", ind, \" \",",
            "\t\t\t   cpu, cm->available, cm->managed,",
            "\t\t\t   cm->managed_allocated, cm->allocated,",
            "\t\t\t   m->matrix_bits, cm->alloc_map);",
            "\t}",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "irq_matrix_free, irq_matrix_available, irq_matrix_reserved, irq_matrix_allocated, irq_matrix_debug_show",
          "description": "提供中断资源的释放接口，实现全局和CPU级的资源使用统计查询，包含调试信息展示功能，通过位图操作维护系统中断位的使用状态",
          "similarity": 0.592128574848175
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/matrix.c",
          "start_line": 1,
          "end_line": 77,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2017 Thomas Gleixner <tglx@linutronix.de>",
            "",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpu.h>",
            "#include <linux/irq.h>",
            "",
            "#define IRQ_MATRIX_SIZE\t(BITS_TO_LONGS(IRQ_MATRIX_BITS))",
            "",
            "struct cpumap {",
            "\tunsigned int\t\tavailable;",
            "\tunsigned int\t\tallocated;",
            "\tunsigned int\t\tmanaged;",
            "\tunsigned int\t\tmanaged_allocated;",
            "\tbool\t\t\tinitialized;",
            "\tbool\t\t\tonline;",
            "\tunsigned long\t\talloc_map[IRQ_MATRIX_SIZE];",
            "\tunsigned long\t\tmanaged_map[IRQ_MATRIX_SIZE];",
            "};",
            "",
            "struct irq_matrix {",
            "\tunsigned int\t\tmatrix_bits;",
            "\tunsigned int\t\talloc_start;",
            "\tunsigned int\t\talloc_end;",
            "\tunsigned int\t\talloc_size;",
            "\tunsigned int\t\tglobal_available;",
            "\tunsigned int\t\tglobal_reserved;",
            "\tunsigned int\t\tsystembits_inalloc;",
            "\tunsigned int\t\ttotal_allocated;",
            "\tunsigned int\t\tonline_maps;",
            "\tstruct cpumap __percpu\t*maps;",
            "\tunsigned long\t\tscratch_map[IRQ_MATRIX_SIZE];",
            "\tunsigned long\t\tsystem_map[IRQ_MATRIX_SIZE];",
            "};",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/irq_matrix.h>",
            "",
            "/**",
            " * irq_alloc_matrix - Allocate a irq_matrix structure and initialize it",
            " * @matrix_bits:\tNumber of matrix bits must be <= IRQ_MATRIX_BITS",
            " * @alloc_start:\tFrom which bit the allocation search starts",
            " * @alloc_end:\t\tAt which bit the allocation search ends, i.e first",
            " *\t\t\tinvalid bit",
            " */",
            "__init struct irq_matrix *irq_alloc_matrix(unsigned int matrix_bits,",
            "\t\t\t\t\t   unsigned int alloc_start,",
            "\t\t\t\t\t   unsigned int alloc_end)",
            "{",
            "\tstruct irq_matrix *m;",
            "",
            "\tif (matrix_bits > IRQ_MATRIX_BITS)",
            "\t\treturn NULL;",
            "",
            "\tm = kzalloc(sizeof(*m), GFP_KERNEL);",
            "\tif (!m)",
            "\t\treturn NULL;",
            "",
            "\tm->matrix_bits = matrix_bits;",
            "\tm->alloc_start = alloc_start;",
            "\tm->alloc_end = alloc_end;",
            "\tm->alloc_size = alloc_end - alloc_start;",
            "\tm->maps = alloc_percpu(*m->maps);",
            "\tif (!m->maps) {",
            "\t\tkfree(m);",
            "\t\treturn NULL;",
            "\t}",
            "\treturn m;",
            "}",
            "",
            "/**",
            " * irq_matrix_online - Bring the local CPU matrix online",
            " * @m:\t\tMatrix pointer",
            " */"
          ],
          "function_name": null,
          "description": "定义irq_matrix结构体和相关辅助数据结构，提供irq_alloc_matrix函数用于初始化并分配irq_matrix实例，设置矩阵大小、起始结束位置等参数，并分配per-CPU的cpumap数组",
          "similarity": 0.4642505943775177
        }
      ]
    },
    {
      "source_file": "mm/kasan/quarantine.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:17:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kasan\\quarantine.c`\n\n---\n\n# kasan/quarantine.c 技术文档\n\n## 1. 文件概述\n\n`kasan/quarantine.c` 实现了 KASAN（Kernel Address Sanitizer）的隔离区（Quarantine）机制。该机制用于延迟释放已释放但可能仍被非法访问的内存对象，从而提高检测 Use-After-Free（UAF）错误的能力。通过将释放的对象暂时放入隔离队列而非立即归还给内存分配器，KASAN 能在后续访问这些“已释放”内存时捕获违规行为。\n\n隔离区由每个 CPU 的本地队列和一个全局循环批次队列组成，并支持动态调整大小以适应系统内存压力，防止因隔离区过大导致 OOM（Out-Of-Memory）。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct qlist_head`**  \n  表示一个单向链表队列，包含头指针、尾指针、总字节数和离线标志。\n  \n- **`cpu_quarantine`**（per-CPU）  \n  每个 CPU 的本地隔离队列，用于暂存刚释放的对象。\n\n- **`global_quarantine[QUARANTINE_BATCHES]`**  \n  全局隔离批次数组，采用循环 FIFO 结构，存储从各 CPU 队列转移过来的批量对象。\n\n- **`shrink_qlist`**（per-CPU）  \n  用于内存回收路径的辅助队列，带自旋锁保护。\n\n- **`remove_cache_srcu`**  \n  SRCU（Sleepable RCU）同步机制，用于安全地移除特定 slab 缓存的所有隔离对象。\n\n### 主要函数\n\n- **`kasan_quarantine_put()`**  \n  将指定对象放入当前 CPU 的隔离队列；若队列超过阈值，则批量转移到全局隔离区。\n\n- **`kasan_quarantine_reduce()`**  \n  当全局隔离区总大小超过限制时，释放最早一批对象以回收内存。\n\n- **`qlist_free_all()`**  \n  遍历并实际释放队列中所有对象回 slab 分配器。\n\n- **`qlink_free()`**  \n  执行单个隔离对象的实际释放操作，包括清除 KASAN 元数据和 shadow 内存标记。\n\n- **`qlist_move_cache()`**（未完成）  \n  （代码截断）预期用于将特定缓存类型的所有对象从一个队列迁移到另一个队列，通常用于缓存销毁时清理隔离对象。\n\n## 3. 关键实现\n\n### 隔离队列结构\n- 使用轻量级单向链表 `qlist_head` 管理对象，每个节点为 `struct qlist_node`（嵌入在 `kasan_free_meta` 中）。\n- 每个 CPU 维护一个本地队列（`cpu_quarantine`），避免锁竞争，提升性能。\n- 全局隔离区由 `QUARANTINE_BATCHES` 个批次组成环形缓冲区，通过 `quarantine_head` 和 `quarantine_tail` 实现 FIFO。\n\n### 内存管理策略\n- 单个 CPU 队列最大为 `QUARANTINE_PERCPU_SIZE`（1MB）。\n- 全局隔离区最大容量为系统物理内存的 `1/QUARANTINE_FRACTION`（即 1/32），再减去所有 CPU 队列的上限总和。\n- 批次大小 `quarantine_batch_size` 动态计算，至少为 `QUARANTINE_PERCPU_SIZE`，确保高效批量处理。\n\n### 并发与同步\n- CPU 本地操作使用 `local_irq_save/restore` 禁用中断，保证原子性。\n- 全局队列操作受 `quarantine_lock`（raw spinlock）保护。\n- 使用 `SRCU`（`remove_cache_srcu`）协调 `kasan_quarantine_remove_cache()` 与隔离对象释放之间的同步，确保在缓存销毁时不会遗漏隔离中的对象。\n\n### 安全释放机制\n- 对象释放前会将对应的 KASAN shadow 字节设为 `KASAN_SLAB_FREE`，使后续访问触发 KASAN 报告。\n- 若启用了 `init_on_free` 且 free metadata 存储在对象内部，则在释放前显式清零元数据，避免残留敏感信息。\n\n## 4. 依赖关系\n\n- **KASAN 核心模块**：依赖 `kasan.h` 中定义的元数据结构（如 `kasan_free_meta`）、shadow 内存操作和 `kasan_get_free_meta()` 等接口。\n- **Slab 分配器**：通过 `___cache_free()` 将对象归还给底层 slab（SLAB/SLUB）；使用 `virt_to_slab()` 和 `slab_want_init_on_free()` 等 slab 内部接口。\n- **内存管理子系统**：调用 `totalram_pages()` 获取系统内存总量，用于动态调整隔离区大小。\n- **CPU 热插拔**：通过 `num_online_cpus()` 适配 CPU 数量变化。\n- **同步原语**：使用 `percpu`、`raw_spinlock`、`SRCU` 和 `local_irq_*` 实现并发控制。\n- **内存回收**：虽未直接注册 shrinker（注释提及 SLAB 不支持），但 `kasan_quarantine_reduce()` 可被外部调用以响应内存压力。\n\n## 5. 使用场景\n\n- **Use-After-Free 检测增强**：当内核启用 KASAN（特别是 `CONFIG_KASAN_GENERIC` 或 `CONFIG_KASAN_SW_TAGS`）时，`kfree()` 或 `kmem_cache_free()` 调用会先将对象放入隔离区而非立即释放，延长 UAF 检测窗口。\n- **内存压力下的自动回收**：当系统内存紧张或隔离区超过阈值时，调用 `kasan_quarantine_reduce()` 释放最早隔离的一批对象，防止内存耗尽。\n- **Slab 缓存销毁**：当某个 `kmem_cache` 被销毁时，需调用未在本文件中完整实现的 `kasan_quarantine_remove_cache()`（依赖 `qlist_move_cache`），将该缓存的所有隔离对象立即释放，避免悬空引用。\n- **调试与测试**：在内核开发和测试阶段，隔离机制显著提升内存错误的可复现性和诊断能力。",
      "similarity": 0.5942903757095337,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 238,
          "end_line": 375,
          "content": [
            "void kasan_quarantine_reduce(void)",
            "{",
            "\tsize_t total_size, new_quarantine_size, percpu_quarantines;",
            "\tunsigned long flags;",
            "\tint srcu_idx;",
            "\tstruct qlist_head to_free = QLIST_INIT;",
            "",
            "\tif (likely(READ_ONCE(quarantine_size) <=",
            "\t\t   READ_ONCE(quarantine_max_size)))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * srcu critical section ensures that kasan_quarantine_remove_cache()",
            "\t * will not miss objects belonging to the cache while they are in our",
            "\t * local to_free list. srcu is chosen because (1) it gives us private",
            "\t * grace period domain that does not interfere with anything else,",
            "\t * and (2) it allows synchronize_srcu() to return without waiting",
            "\t * if there are no pending read critical sections (which is the",
            "\t * expected case).",
            "\t */",
            "\tsrcu_idx = srcu_read_lock(&remove_cache_srcu);",
            "\traw_spin_lock_irqsave(&quarantine_lock, flags);",
            "",
            "\t/*",
            "\t * Update quarantine size in case of hotplug. Allocate a fraction of",
            "\t * the installed memory to quarantine minus per-cpu queue limits.",
            "\t */",
            "\ttotal_size = (totalram_pages() << PAGE_SHIFT) /",
            "\t\tQUARANTINE_FRACTION;",
            "\tpercpu_quarantines = QUARANTINE_PERCPU_SIZE * num_online_cpus();",
            "\tnew_quarantine_size = (total_size < percpu_quarantines) ?",
            "\t\t0 : total_size - percpu_quarantines;",
            "\tWRITE_ONCE(quarantine_max_size, new_quarantine_size);",
            "\t/* Aim at consuming at most 1/2 of slots in quarantine. */",
            "\tWRITE_ONCE(quarantine_batch_size, max((size_t)QUARANTINE_PERCPU_SIZE,",
            "\t\t2 * total_size / QUARANTINE_BATCHES));",
            "",
            "\tif (likely(quarantine_size > quarantine_max_size)) {",
            "\t\tqlist_move_all(&global_quarantine[quarantine_head], &to_free);",
            "\t\tWRITE_ONCE(quarantine_size, quarantine_size - to_free.bytes);",
            "\t\tquarantine_head++;",
            "\t\tif (quarantine_head == QUARANTINE_BATCHES)",
            "\t\t\tquarantine_head = 0;",
            "\t}",
            "",
            "\traw_spin_unlock_irqrestore(&quarantine_lock, flags);",
            "",
            "\tqlist_free_all(&to_free, NULL);",
            "\tsrcu_read_unlock(&remove_cache_srcu, srcu_idx);",
            "}",
            "static void qlist_move_cache(struct qlist_head *from,",
            "\t\t\t\t   struct qlist_head *to,",
            "\t\t\t\t   struct kmem_cache *cache)",
            "{",
            "\tstruct qlist_node *curr;",
            "",
            "\tif (unlikely(qlist_empty(from)))",
            "\t\treturn;",
            "",
            "\tcurr = from->head;",
            "\tqlist_init(from);",
            "\twhile (curr) {",
            "\t\tstruct qlist_node *next = curr->next;",
            "\t\tstruct kmem_cache *obj_cache = qlink_to_cache(curr);",
            "",
            "\t\tif (obj_cache == cache)",
            "\t\t\tqlist_put(to, curr, obj_cache->size);",
            "\t\telse",
            "\t\t\tqlist_put(from, curr, obj_cache->size);",
            "",
            "\t\tcurr = next;",
            "\t}",
            "}",
            "static void __per_cpu_remove_cache(struct qlist_head *q, void *arg)",
            "{",
            "\tstruct kmem_cache *cache = arg;",
            "\tunsigned long flags;",
            "\tstruct cpu_shrink_qlist *sq;",
            "",
            "\tsq = this_cpu_ptr(&shrink_qlist);",
            "\traw_spin_lock_irqsave(&sq->lock, flags);",
            "\tqlist_move_cache(q, &sq->qlist, cache);",
            "\traw_spin_unlock_irqrestore(&sq->lock, flags);",
            "}",
            "static void per_cpu_remove_cache(void *arg)",
            "{",
            "\tstruct qlist_head *q;",
            "",
            "\tq = this_cpu_ptr(&cpu_quarantine);",
            "\t/*",
            "\t * Ensure the ordering between the writing to q->offline and",
            "\t * per_cpu_remove_cache.  Prevent cpu_quarantine from being corrupted",
            "\t * by interrupt.",
            "\t */",
            "\tif (READ_ONCE(q->offline))",
            "\t\treturn;",
            "\t__per_cpu_remove_cache(q, arg);",
            "}",
            "void kasan_quarantine_remove_cache(struct kmem_cache *cache)",
            "{",
            "\tunsigned long flags, i;",
            "\tstruct qlist_head to_free = QLIST_INIT;",
            "\tint cpu;",
            "\tstruct cpu_shrink_qlist *sq;",
            "",
            "\t/*",
            "\t * Must be careful to not miss any objects that are being moved from",
            "\t * per-cpu list to the global quarantine in kasan_quarantine_put(),",
            "\t * nor objects being freed in kasan_quarantine_reduce(). on_each_cpu()",
            "\t * achieves the first goal, while synchronize_srcu() achieves the",
            "\t * second.",
            "\t */",
            "\ton_each_cpu(per_cpu_remove_cache, cache, 1);",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tsq = per_cpu_ptr(&shrink_qlist, cpu);",
            "\t\traw_spin_lock_irqsave(&sq->lock, flags);",
            "\t\tqlist_move_cache(&sq->qlist, &to_free, cache);",
            "\t\traw_spin_unlock_irqrestore(&sq->lock, flags);",
            "\t}",
            "\tqlist_free_all(&to_free, cache);",
            "",
            "\traw_spin_lock_irqsave(&quarantine_lock, flags);",
            "\tfor (i = 0; i < QUARANTINE_BATCHES; i++) {",
            "\t\tif (qlist_empty(&global_quarantine[i]))",
            "\t\t\tcontinue;",
            "\t\tqlist_move_cache(&global_quarantine[i], &to_free, cache);",
            "\t\t/* Scanning whole quarantine can take a while. */",
            "\t\traw_spin_unlock_irqrestore(&quarantine_lock, flags);",
            "\t\tcond_resched();",
            "\t\traw_spin_lock_irqsave(&quarantine_lock, flags);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&quarantine_lock, flags);",
            "",
            "\tqlist_free_all(&to_free, cache);",
            "",
            "\tsynchronize_srcu(&remove_cache_srcu);",
            "}"
          ],
          "function_name": "kasan_quarantine_reduce, qlist_move_cache, __per_cpu_remove_cache, per_cpu_remove_cache, kasan_quarantine_remove_cache",
          "description": "提供隔离区缩减机制(kasan_quarantine_reduce)，通过srcu同步和跨CPU遍历清除指定缓存对象，利用qlist_move_cache实现基于缓存类型的对象转移与释放。",
          "similarity": 0.6305927038192749
        },
        {
          "chunk_id": 1,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 42,
          "end_line": 172,
          "content": [
            "static bool qlist_empty(struct qlist_head *q)",
            "{",
            "\treturn !q->head;",
            "}",
            "static void qlist_init(struct qlist_head *q)",
            "{",
            "\tq->head = q->tail = NULL;",
            "\tq->bytes = 0;",
            "}",
            "static void qlist_put(struct qlist_head *q, struct qlist_node *qlink,",
            "\t\tsize_t size)",
            "{",
            "\tif (unlikely(qlist_empty(q)))",
            "\t\tq->head = qlink;",
            "\telse",
            "\t\tq->tail->next = qlink;",
            "\tq->tail = qlink;",
            "\tqlink->next = NULL;",
            "\tq->bytes += size;",
            "}",
            "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)",
            "{",
            "\tif (unlikely(qlist_empty(from)))",
            "\t\treturn;",
            "",
            "\tif (qlist_empty(to)) {",
            "\t\t*to = *from;",
            "\t\tqlist_init(from);",
            "\t\treturn;",
            "\t}",
            "",
            "\tto->tail->next = from->head;",
            "\tto->tail = from->tail;",
            "\tto->bytes += from->bytes;",
            "",
            "\tqlist_init(from);",
            "}",
            "static void qlink_free(struct qlist_node *qlink, struct kmem_cache *cache)",
            "{",
            "\tvoid *object = qlink_to_object(qlink, cache);",
            "\tstruct kasan_free_meta *meta = kasan_get_free_meta(cache, object);",
            "",
            "\t/*",
            "\t * If init_on_free is enabled and KASAN's free metadata is stored in",
            "\t * the object, zero the metadata. Otherwise, the object's memory will",
            "\t * not be properly zeroed, as KASAN saves the metadata after the slab",
            "\t * allocator zeroes the object.",
            "\t */",
            "\tif (slab_want_init_on_free(cache) &&",
            "\t    cache->kasan_info.free_meta_offset == 0)",
            "\t\tmemzero_explicit(meta, sizeof(*meta));",
            "",
            "\t/*",
            "\t * As the object now gets freed from the quarantine, assume that its",
            "\t * free track is no longer valid.",
            "\t */",
            "\t*(u8 *)kasan_mem_to_shadow(object) = KASAN_SLAB_FREE;",
            "",
            "\t___cache_free(cache, object, _THIS_IP_);",
            "}",
            "static void qlist_free_all(struct qlist_head *q, struct kmem_cache *cache)",
            "{",
            "\tstruct qlist_node *qlink;",
            "",
            "\tif (unlikely(qlist_empty(q)))",
            "\t\treturn;",
            "",
            "\tqlink = q->head;",
            "\twhile (qlink) {",
            "\t\tstruct kmem_cache *obj_cache =",
            "\t\t\tcache ? cache :\tqlink_to_cache(qlink);",
            "\t\tstruct qlist_node *next = qlink->next;",
            "",
            "\t\tqlink_free(qlink, obj_cache);",
            "\t\tqlink = next;",
            "\t}",
            "\tqlist_init(q);",
            "}",
            "bool kasan_quarantine_put(struct kmem_cache *cache, void *object)",
            "{",
            "\tunsigned long flags;",
            "\tstruct qlist_head *q;",
            "\tstruct qlist_head temp = QLIST_INIT;",
            "\tstruct kasan_free_meta *meta = kasan_get_free_meta(cache, object);",
            "",
            "\t/*",
            "\t * If there's no metadata for this object, don't put it into",
            "\t * quarantine.",
            "\t */",
            "\tif (!meta)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Note: irq must be disabled until after we move the batch to the",
            "\t * global quarantine. Otherwise kasan_quarantine_remove_cache() can",
            "\t * miss some objects belonging to the cache if they are in our local",
            "\t * temp list. kasan_quarantine_remove_cache() executes on_each_cpu()",
            "\t * at the beginning which ensures that it either sees the objects in",
            "\t * per-cpu lists or in the global quarantine.",
            "\t */",
            "\tlocal_irq_save(flags);",
            "",
            "\tq = this_cpu_ptr(&cpu_quarantine);",
            "\tif (q->offline) {",
            "\t\tlocal_irq_restore(flags);",
            "\t\treturn false;",
            "\t}",
            "\tqlist_put(q, &meta->quarantine_link, cache->size);",
            "\tif (unlikely(q->bytes > QUARANTINE_PERCPU_SIZE)) {",
            "\t\tqlist_move_all(q, &temp);",
            "",
            "\t\traw_spin_lock(&quarantine_lock);",
            "\t\tWRITE_ONCE(quarantine_size, quarantine_size + temp.bytes);",
            "\t\tqlist_move_all(&temp, &global_quarantine[quarantine_tail]);",
            "\t\tif (global_quarantine[quarantine_tail].bytes >=",
            "\t\t\t\tREAD_ONCE(quarantine_batch_size)) {",
            "\t\t\tint new_tail;",
            "",
            "\t\t\tnew_tail = quarantine_tail + 1;",
            "\t\t\tif (new_tail == QUARANTINE_BATCHES)",
            "\t\t\t\tnew_tail = 0;",
            "\t\t\tif (new_tail != quarantine_head)",
            "\t\t\t\tquarantine_tail = new_tail;",
            "\t\t}",
            "\t\traw_spin_unlock(&quarantine_lock);",
            "\t}",
            "",
            "\tlocal_irq_restore(flags);",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "qlist_empty, qlist_init, qlist_put, qlist_move_all, qlink_free, qlist_free_all, kasan_quarantine_put",
          "description": "实现了隔离区队列的基本操作（空判断、初始化、插入、转移和释放），kasan_quarantine_put将对象加入当前CPU隔离队列并触发全局隔离区迁移，通过中断屏蔽保证并发安全性。",
          "similarity": 0.6003787517547607
        },
        {
          "chunk_id": 3,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 382,
          "end_line": 410,
          "content": [
            "static int kasan_cpu_online(unsigned int cpu)",
            "{",
            "\tthis_cpu_ptr(&cpu_quarantine)->offline = false;",
            "\treturn 0;",
            "}",
            "static int kasan_cpu_offline(unsigned int cpu)",
            "{",
            "\tstruct qlist_head *q;",
            "",
            "\tq = this_cpu_ptr(&cpu_quarantine);",
            "\t/* Ensure the ordering between the writing to q->offline and",
            "\t * qlist_free_all. Otherwise, cpu_quarantine may be corrupted",
            "\t * by interrupt.",
            "\t */",
            "\tWRITE_ONCE(q->offline, true);",
            "\tbarrier();",
            "\tqlist_free_all(q, NULL);",
            "\treturn 0;",
            "}",
            "static int __init kasan_cpu_quarantine_init(void)",
            "{",
            "\tint ret = 0;",
            "",
            "\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/kasan:online\",",
            "\t\t\t\tkasan_cpu_online, kasan_cpu_offline);",
            "\tif (ret < 0)",
            "\t\tpr_err(\"kasan cpu quarantine register failed [%d]\\n\", ret);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "kasan_cpu_online, kasan_cpu_offline, kasan_cpu_quarantine_init",
          "description": "实现CPU热插拔时隔离区状态管理，kasan_cpu_online/kasan_cpu_offline控制隔离区可用性，kasan_cpu_quarantine_init注册CPU状态回调接口。",
          "similarity": 0.5951768159866333
        },
        {
          "chunk_id": 0,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * KASAN quarantine.",
            " *",
            " * Author: Alexander Potapenko <glider@google.com>",
            " * Copyright (C) 2016 Google, Inc.",
            " *",
            " * Based on code by Dmitry Chernenkov.",
            " */",
            "",
            "#include <linux/gfp.h>",
            "#include <linux/hash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/percpu.h>",
            "#include <linux/printk.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/cpuhotplug.h>",
            "",
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "",
            "/* Data structure and operations for quarantine queues. */",
            "",
            "/*",
            " * Each queue is a single-linked list, which also stores the total size of",
            " * objects inside of it.",
            " */",
            "struct qlist_head {",
            "\tstruct qlist_node *head;",
            "\tstruct qlist_node *tail;",
            "\tsize_t bytes;",
            "\tbool offline;",
            "};",
            "",
            "#define QLIST_INIT { NULL, NULL, 0 }",
            ""
          ],
          "function_name": null,
          "description": "定义了KASAN隔离区队列的数据结构qlist_head，包含头尾指针、总字节数和离线标志位，用于管理隔离对象的链表队列。",
          "similarity": 0.5423812866210938
        }
      ]
    },
    {
      "source_file": "kernel/irq/devres.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:52:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\devres.c`\n\n---\n\n# `irq/devres.c` 技术文档\n\n## 1. 文件概述\n\n`irq/devres.c` 是 Linux 内核中用于实现**设备资源管理（Device Resource Management, devres）感知的中断（IRQ）申请与释放机制**的核心文件。该文件封装了标准 IRQ 操作（如 `request_irq`、`free_irq` 等）为“可自动释放”的资源管理版本，确保在设备驱动卸载或设备移除时，已申请的中断资源能被自动、安全地释放，避免资源泄漏。\n\n该机制基于内核的 `devres`（Device Resource）框架，将 IRQ 资源与 `struct device` 生命周期绑定，极大简化了驱动开发中的资源管理逻辑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct irq_devres`**  \n  用于跟踪通过 `devm_*` 接口申请的中断资源，包含：\n  - `irq`：中断号\n  - `dev_id`：传递给中断处理函数的设备标识（用于共享中断的区分）\n\n- **`struct irq_desc_devres`**  \n  用于跟踪通过 `__devm_irq_alloc_descs` 分配的中断描述符范围，包含：\n  - `from`：分配的起始中断号\n  - `cnt`：分配的中断数量\n\n- **`struct irq_generic_chip_devres`**  \n  用于跟踪通过 `devm_irq_setup_generic_chip` 设置的通用中断芯片资源，包含：\n  - `gc`：指向 `irq_chip_generic` 结构的指针\n  - `msk`、`clr`、`set`：用于在释放时还原中断状态的参数\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `devm_request_threaded_irq` | 为设备申请带线程化处理的中断，自动管理生命周期 |\n| `devm_request_any_context_irq` | 为设备申请可在任意上下文（硬中断或线程）处理的中断 |\n| `devm_free_irq` | 手动释放由 `devm_*` 接口申请的中断（通常不需要调用） |\n| `__devm_irq_alloc_descs` | 为设备分配并管理一组中断描述符（IRQ descriptors） |\n| `devm_irq_alloc_generic_chip` | 为设备分配并初始化一个通用中断芯片结构（`irq_chip_generic`） |\n| `devm_irq_setup_generic_chip` | 为设备设置通用中断芯片的中断范围，并注册资源释放回调 |\n\n## 3. 关键实现\n\n### 资源自动释放机制\n- 所有 `devm_*` 接口在成功申请资源后，会通过 `devres_alloc()` 分配一个资源描述结构（如 `irq_devres`），并注册对应的释放函数（如 `devm_irq_release`）。\n- 该资源结构通过 `devres_add()` 绑定到 `struct device`。\n- 当设备被移除（`device_del`）或驱动卸载时，内核自动调用所有注册的 `devres` 释放函数，确保 `free_irq()` 或 `irq_free_descs()` 被正确调用。\n\n### 中断匹配逻辑\n- `devm_free_irq()` 使用 `devm_irq_match` 函数通过 `irq` 和 `dev_id` 精确匹配要释放的资源，确保不会误删其他中断。\n\n### 通用中断芯片支持\n- `devm_irq_alloc_generic_chip` 使用 `devm_kzalloc` 分配内存，确保芯片结构随设备生命周期自动释放。\n- `devm_irq_setup_generic_chip` 在设置芯片后注册 `devm_irq_remove_generic_chip` 回调，在设备移除时自动调用 `irq_remove_generic_chip` 清理中断配置。\n\n### 错误处理\n- 所有分配操作（如 `devres_alloc`）失败时返回 `-ENOMEM`。\n- 底层 IRQ 申请失败时，会释放已分配的 `devres` 结构，避免内存泄漏。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/device.h>`：提供 `devres` 框架接口（`devres_alloc`, `devres_add`, `devres_destroy` 等）\n  - `<linux/interrupt.h>`：提供标准 IRQ 接口（`request_threaded_irq`, `free_irq` 等）\n  - `<linux/irq.h>`：提供中断描述符管理接口（`__irq_alloc_descs`, `irq_free_descs`）\n  - `\"internals.h\"`：包含 IRQ 子系统内部实现细节\n\n- **内核配置依赖**：\n  - `CONFIG_GENERIC_IRQ_CHIP`：启用通用中断芯片支持（影响 `devm_irq_alloc_generic_chip` 和 `devm_irq_setup_generic_chip` 的编译）\n\n- **模块导出**：\n  - `devm_request_threaded_irq`、`devm_request_any_context_irq`、`devm_free_irq` 通过 `EXPORT_SYMBOL` 导出，供其他模块使用。\n  - 中断描述符和通用芯片相关函数通过 `EXPORT_SYMBOL_GPL` 导出，仅限 GPL 兼容模块使用。\n\n## 5. 使用场景\n\n- **驱动开发**：设备驱动在 `probe` 函数中使用 `devm_request_threaded_irq()` 申请中断，无需在 `remove` 函数中显式调用 `free_irq()`，简化代码并避免遗漏。\n- **虚拟中断分配**：平台驱动或中断控制器驱动使用 `__devm_irq_alloc_descs()` 为虚拟设备分配中断号范围，确保在设备移除时自动释放描述符。\n- **通用中断控制器**：使用 `devm_irq_alloc_generic_chip()` 和 `devm_irq_setup_generic_chip()` 管理基于 `irq_chip_generic` 的中断控制器，适用于 GPIO、I2C、SPI 等子系统中的中断复用场景。\n- **资源安全释放**：在驱动异常退出或设备热插拔场景下，内核自动释放 IRQ 资源，防止中断悬挂或资源冲突。",
      "similarity": 0.5931355357170105,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/devres.c",
          "start_line": 18,
          "end_line": 122,
          "content": [
            "static void devm_irq_release(struct device *dev, void *res)",
            "{",
            "\tstruct irq_devres *this = res;",
            "",
            "\tfree_irq(this->irq, this->dev_id);",
            "}",
            "static int devm_irq_match(struct device *dev, void *res, void *data)",
            "{",
            "\tstruct irq_devres *this = res, *match = data;",
            "",
            "\treturn this->irq == match->irq && this->dev_id == match->dev_id;",
            "}",
            "int devm_request_threaded_irq(struct device *dev, unsigned int irq,",
            "\t\t\t      irq_handler_t handler, irq_handler_t thread_fn,",
            "\t\t\t      unsigned long irqflags, const char *devname,",
            "\t\t\t      void *dev_id)",
            "{",
            "\tstruct irq_devres *dr;",
            "\tint rc;",
            "",
            "\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),",
            "\t\t\t  GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!devname)",
            "\t\tdevname = dev_name(dev);",
            "",
            "\trc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,",
            "\t\t\t\t  dev_id);",
            "\tif (rc) {",
            "\t\tdevres_free(dr);",
            "\t\treturn rc;",
            "\t}",
            "",
            "\tdr->irq = irq;",
            "\tdr->dev_id = dev_id;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn 0;",
            "}",
            "int devm_request_any_context_irq(struct device *dev, unsigned int irq,",
            "\t\t\t      irq_handler_t handler, unsigned long irqflags,",
            "\t\t\t      const char *devname, void *dev_id)",
            "{",
            "\tstruct irq_devres *dr;",
            "\tint rc;",
            "",
            "\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),",
            "\t\t\t  GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!devname)",
            "\t\tdevname = dev_name(dev);",
            "",
            "\trc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);",
            "\tif (rc < 0) {",
            "\t\tdevres_free(dr);",
            "\t\treturn rc;",
            "\t}",
            "",
            "\tdr->irq = irq;",
            "\tdr->dev_id = dev_id;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn rc;",
            "}",
            "void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)",
            "{",
            "\tstruct irq_devres match_data = { irq, dev_id };",
            "",
            "\tWARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,",
            "\t\t\t       &match_data));",
            "\tfree_irq(irq, dev_id);",
            "}",
            "static void devm_irq_desc_release(struct device *dev, void *res)",
            "{",
            "\tstruct irq_desc_devres *this = res;",
            "",
            "\tirq_free_descs(this->from, this->cnt);",
            "}",
            "int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,",
            "\t\t\t   unsigned int cnt, int node, struct module *owner,",
            "\t\t\t   const struct irq_affinity_desc *affinity)",
            "{",
            "\tstruct irq_desc_devres *dr;",
            "\tint base;",
            "",
            "\tdr = devres_alloc(devm_irq_desc_release, sizeof(*dr), GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tbase = __irq_alloc_descs(irq, from, cnt, node, owner, affinity);",
            "\tif (base < 0) {",
            "\t\tdevres_free(dr);",
            "\t\treturn base;",
            "\t}",
            "",
            "\tdr->from = base;",
            "\tdr->cnt = cnt;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn base;",
            "}"
          ],
          "function_name": "devm_irq_release, devm_irq_match, devm_request_threaded_irq, devm_request_any_context_irq, devm_free_irq, devm_irq_desc_release, __devm_irq_alloc_descs",
          "description": "实现设备资源管理的中断申请与释放逻辑，包含中断线程处理注册、任意上下文中断申请、中断释放及中断描述符分配等功能，通过devres框架实现资源自动管理。",
          "similarity": 0.5807844400405884
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/devres.c",
          "start_line": 240,
          "end_line": 266,
          "content": [
            "static void devm_irq_remove_generic_chip(struct device *dev, void *res)",
            "{",
            "\tstruct irq_generic_chip_devres *this = res;",
            "",
            "\tirq_remove_generic_chip(this->gc, this->msk, this->clr, this->set);",
            "}",
            "int devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,",
            "\t\t\t\tu32 msk, enum irq_gc_flags flags,",
            "\t\t\t\tunsigned int clr, unsigned int set)",
            "{",
            "\tstruct irq_generic_chip_devres *dr;",
            "",
            "\tdr = devres_alloc(devm_irq_remove_generic_chip,",
            "\t\t\t  sizeof(*dr), GFP_KERNEL);",
            "\tif (!dr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tirq_setup_generic_chip(gc, msk, flags, clr, set);",
            "",
            "\tdr->gc = gc;",
            "\tdr->msk = msk;",
            "\tdr->clr = clr;",
            "\tdr->set = set;",
            "\tdevres_add(dev, dr);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "devm_irq_remove_generic_chip, devm_irq_setup_generic_chip",
          "description": "提供通用中断芯片的配置与清理接口，用于在设备初始化时设置中断控制器参数并在设备移除时安全地移除通用中断芯片配置。",
          "similarity": 0.543514609336853
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/devres.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "/*",
            " * Device resource management aware IRQ request/free implementation.",
            " */",
            "struct irq_devres {",
            "\tunsigned int irq;",
            "\tvoid *dev_id;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义irq_devres结构体，用于存储中断号和设备ID，作为设备资源管理中断请求的辅助数据结构。",
          "similarity": 0.45758163928985596
        }
      ]
    }
  ]
}