{
  "query": "用户命名空间与文件权限检查流程",
  "timestamp": "2025-12-26 00:19:14",
  "retrieved_files": [
    {
      "source_file": "kernel/user_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:46:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user_namespace.c`\n\n---\n\n# user_namespace.c 技术文档\n\n## 1. 文件概述\n\n`user_namespace.c` 是 Linux 内核中实现用户命名空间（User Namespace）核心功能的源文件。用户命名空间是 Linux 命名空间机制的一部分，用于隔离用户和组 ID（UID/GID），使得不同命名空间中的相同 UID 可以映射到宿主系统中的不同实际 UID/GID。该文件负责用户命名空间的创建、销毁、引用计数管理、ID 映射查找以及与凭证（credentials）的集成，是容器化技术（如 Docker、LXC）实现非特权容器和用户隔离的关键组件。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`create_user_ns(struct cred *new)`**  \n  创建一个新的用户命名空间，设置其父命名空间、层级、所有者、资源限制，并初始化凭证中的命名空间指针。\n\n- **`unshare_userns(unsigned long unshare_flags, struct cred **new_cred)`**  \n  为当前进程创建新的用户命名空间（通过 `unshare(CLONE_NEWUSER)` 系统调用触发），并返回新的凭证结构。\n\n- **`free_user_ns(struct work_struct *work)`**  \n  异步释放用户命名空间及其关联资源（如 ID 映射、sysctl 表、密钥环等），通过工作队列延迟执行以避免死锁。\n\n- **`__put_user_ns(struct user_namespace *ns)`**  \n  减少用户命名空间引用计数，若引用计数归零则调度 `free_user_ns` 工作项进行释放。\n\n- **`map_id_range_down_base()` / `map_id_range_down_max()`**  \n  在 UID/GID 映射表中查找指定 ID 范围对应的映射条目，分别处理小规模（≤4 条）和大规模（>4 条）映射。\n\n- **`cmp_map_id()`**  \n  用于二分查找的比较函数，支持正向（内核 ID → 用户 ID）和反向（用户 ID → 内核 ID）映射查询。\n\n- **`set_cred_user_ns()`**  \n  初始化新凭证中的用户命名空间相关字段，包括能力集（capabilities）、安全位（securebits）和密钥认证上下文。\n\n- **`enforced_nproc_rlimit()`**  \n  根据当前用户是否为全局 root 以及是否处于初始用户命名空间，决定是否对 `RLIMIT_NPROC` 施加限制。\n\n### 主要数据结构\n\n- **`struct user_namespace`**  \n  用户命名空间的核心结构体，包含父命名空间指针、层级、所有者 UID/GID、ID 映射表（uid_map、gid_map、projid_map）、资源使用计数器（ucounts）、引用计数、标志位、密钥环列表等。\n\n- **`struct idmap_key`**  \n  用于 ID 映射查找的辅助结构，封装待查找的 ID、范围长度及映射方向（向上/向下）。\n\n- **`struct uid_gid_extent`**  \n  表示单个 UID/GID 映射区间的结构，包含起始内核 ID、起始用户 ID 和映射长度。\n\n## 3. 关键实现\n\n### 用户命名空间创建流程\n1. **层级限制检查**：防止命名空间嵌套过深（最大 32 层）。\n2. **资源计数**：通过 `inc_user_namespaces()` 增加父命名空间中创建者的用户命名空间使用计数。\n3. **安全策略验证**：\n   - 禁止在 chroot 环境中创建新用户命名空间。\n   - 确保创建者的 UID/GID 在父命名空间中有有效映射。\n4. **安全模块回调**：调用 LSM（如 SELinux、AppArmor）的 `security_create_user_ns()` 钩子进行权限检查。\n5. **初始化新命名空间**：\n   - 分配内存并设置层级、所有者、父指针。\n   - 初始化资源限制（如进程数、消息队列大小等）。\n   - 继承父命名空间的标志（如 `USERNS_SETGROUPS_ALLOWED`）。\n   - 设置凭证中的用户命名空间指针并重置能力集。\n\n### ID 映射查找算法\n- **小规模映射（≤4 条）**：使用线性遍历（`map_id_range_down_base`）。\n- **大规模映射（>4 条）**：使用二分查找（`map_id_range_down_max` + `bsearch`），映射表按 `first` 字段排序。\n- **双向映射支持**：通过 `idmap_key.map_up` 标志区分内核 ID → 用户 ID（map down）和用户 ID → 内核 ID（map up）。\n\n### 异步释放机制\n- 使用 `INIT_WORK()` 将释放操作注册为工作队列任务。\n- 在 `free_user_ns()` 中循环释放命名空间链（处理引用计数级联归零的情况）。\n- 释放动态分配的映射表内存、sysctl 表、密钥环资源，并减少资源使用计数。\n\n### 能力与安全上下文初始化\n- 新命名空间的初始凭证拥有 `CAP_FULL_SET`，但这些能力仅在新命名空间内有效。\n- 清除请求密钥认证（`request_key_auth`）上下文，防止跨命名空间密钥泄露。\n- 重置安全位（`securebits`）为默认值。\n\n## 4. 依赖关系\n\n- **命名空间基础设施**：依赖 `<linux/nsproxy.h>` 和 `ns_common` 结构，与 `proc_ns.c` 协作提供 `/proc/<pid>/ns/user` 接口。\n- **凭证管理**：与 `<linux/cred.h>` 紧密集成，通过 `prepare_creds()`/`put_cred()` 管理凭证生命周期。\n- **资源计数**：使用 `<linux/user_namespace.h>` 中的 `ucounts` 机制跟踪用户命名空间、进程数等资源使用。\n- **安全模块**：通过 LSM 接口（`security_create_user_ns()`）与安全子系统交互。\n- **密钥管理**：依赖 `<keys/user-type.h>` 实现命名空间隔离的用户密钥环。\n- **内存管理**：使用 SLAB 分配器（`kmem_cache`）高效分配 `user_namespace` 结构。\n- **ID 映射**：与 `uidgid.c` 协同实现 UID/GID 映射的设置与查询。\n\n## 5. 使用场景\n\n- **容器运行时**：Docker、Podman、LXC 等通过 `unshare(CLONE_NEWUSER)` 创建非特权容器，实现用户隔离。\n- **用户态命名空间管理**：`unshare(1)` 命令或 `clone(2)` 系统调用创建独立用户上下文。\n- **特权降级**：进程在创建用户命名空间后映射自身为新命名空间的 root，获得有限特权。\n- **安全沙箱**：浏览器、应用沙箱利用用户命名空间限制潜在攻击面。\n- **ID 映射服务**：`newuidmap`/`newgidmap` 工具通过写入 `/proc/<pid>/uid_map` 配置映射，内核通过本文件中的查找函数解析映射关系。\n- **资源隔离**：结合 `ucounts` 机制限制单个用户可创建的用户命名空间数量，防止资源耗尽攻击。",
      "similarity": 0.65485680103302,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user_namespace.c",
          "start_line": 41,
          "end_line": 180,
          "content": [
            "static void dec_user_namespaces(struct ucounts *ucounts)",
            "{",
            "\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);",
            "}",
            "static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)",
            "{",
            "\t/* Start with the same capabilities as init but useless for doing",
            "\t * anything as the capabilities are bound to the new user namespace.",
            "\t */",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_securebits(cred, SECUREBITS_DEFAULT);",
            "\tiee_set_cred_cap_inheritable(cred, CAP_EMPTY_SET);",
            "\tiee_set_cred_cap_permitted(cred, CAP_FULL_SET);",
            "\tiee_set_cred_cap_effective(cred, CAP_FULL_SET);",
            "\tiee_set_cred_cap_ambient(cred, CAP_EMPTY_SET);",
            "\tiee_set_cred_cap_bset(cred, CAP_FULL_SET);",
            "#ifdef CONFIG_KEYS",
            "\tkey_put(cred->request_key_auth);",
            "\tiee_set_cred_request_key_auth(cred, NULL);",
            "#endif",
            "\tiee_set_cred_user_ns(cred, user_ns);",
            "\t#else",
            "\tcred->securebits = SECUREBITS_DEFAULT;",
            "\tcred->cap_inheritable = CAP_EMPTY_SET;",
            "\tcred->cap_permitted = CAP_FULL_SET;",
            "\tcred->cap_effective = CAP_FULL_SET;",
            "\tcred->cap_ambient = CAP_EMPTY_SET;",
            "\tcred->cap_bset = CAP_FULL_SET;",
            "#ifdef CONFIG_KEYS",
            "\tkey_put(cred->request_key_auth);",
            "\tcred->request_key_auth = NULL;",
            "#endif",
            "\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */",
            "\tcred->user_ns = user_ns;",
            "\t#endif",
            "}",
            "static unsigned long enforced_nproc_rlimit(void)",
            "{",
            "\tunsigned long limit = RLIM_INFINITY;",
            "",
            "\t/* Is RLIMIT_NPROC currently enforced? */",
            "\tif (!uid_eq(current_uid(), GLOBAL_ROOT_UID) ||",
            "\t    (current_user_ns() != &init_user_ns))",
            "\t\tlimit = rlimit(RLIMIT_NPROC);",
            "",
            "\treturn limit;",
            "}",
            "int create_user_ns(struct cred *new)",
            "{",
            "\tstruct user_namespace *ns, *parent_ns = new->user_ns;",
            "\tkuid_t owner = new->euid;",
            "\tkgid_t group = new->egid;",
            "\tstruct ucounts *ucounts;",
            "\tint ret, i;",
            "",
            "\tret = -ENOSPC;",
            "\tif (parent_ns->level > 32)",
            "\t\tgoto fail;",
            "",
            "\tucounts = inc_user_namespaces(parent_ns, owner);",
            "\tif (!ucounts)",
            "\t\tgoto fail;",
            "",
            "\t/*",
            "\t * Verify that we can not violate the policy of which files",
            "\t * may be accessed that is specified by the root directory,",
            "\t * by verifying that the root directory is at the root of the",
            "\t * mount namespace which allows all files to be accessed.",
            "\t */",
            "\tret = -EPERM;",
            "\tif (current_chrooted())",
            "\t\tgoto fail_dec;",
            "",
            "\t/* The creator needs a mapping in the parent user namespace",
            "\t * or else we won't be able to reasonably tell userspace who",
            "\t * created a user_namespace.",
            "\t */",
            "\tret = -EPERM;",
            "\tif (!kuid_has_mapping(parent_ns, owner) ||",
            "\t    !kgid_has_mapping(parent_ns, group))",
            "\t\tgoto fail_dec;",
            "",
            "\tret = security_create_user_ns(new);",
            "\tif (ret < 0)",
            "\t\tgoto fail_dec;",
            "",
            "\tret = -ENOMEM;",
            "\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);",
            "\tif (!ns)",
            "\t\tgoto fail_dec;",
            "",
            "\tns->parent_could_setfcap = cap_raised(new->cap_effective, CAP_SETFCAP);",
            "\tret = ns_alloc_inum(&ns->ns);",
            "\tif (ret)",
            "\t\tgoto fail_free;",
            "\tns->ns.ops = &userns_operations;",
            "",
            "\trefcount_set(&ns->ns.count, 1);",
            "\t/* Leave the new->user_ns reference with the new user namespace. */",
            "\tns->parent = parent_ns;",
            "\tns->level = parent_ns->level + 1;",
            "\tns->owner = owner;",
            "\tns->group = group;",
            "\tINIT_WORK(&ns->work, free_user_ns);",
            "\tfor (i = 0; i < UCOUNT_COUNTS; i++) {",
            "\t\tns->ucount_max[i] = INT_MAX;",
            "\t}",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_NPROC, enforced_nproc_rlimit());",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_MSGQUEUE, rlimit(RLIMIT_MSGQUEUE));",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_SIGPENDING, rlimit(RLIMIT_SIGPENDING));",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_MEMLOCK, rlimit(RLIMIT_MEMLOCK));",
            "\tns->ucounts = ucounts;",
            "",
            "\t/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */",
            "\tmutex_lock(&userns_state_mutex);",
            "\tns->flags = parent_ns->flags;",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "#ifdef CONFIG_KEYS",
            "\tINIT_LIST_HEAD(&ns->keyring_name_list);",
            "\tinit_rwsem(&ns->keyring_sem);",
            "#endif",
            "\tret = -ENOMEM;",
            "\tif (!setup_userns_sysctls(ns))",
            "\t\tgoto fail_keyring;",
            "",
            "\tset_cred_user_ns(new, ns);",
            "\treturn 0;",
            "fail_keyring:",
            "#ifdef CONFIG_PERSISTENT_KEYRINGS",
            "\tkey_put(ns->persistent_keyring_register);",
            "#endif",
            "\tns_free_inum(&ns->ns);",
            "fail_free:",
            "\tkmem_cache_free(user_ns_cachep, ns);",
            "fail_dec:",
            "\tdec_user_namespaces(ucounts);",
            "fail:",
            "\treturn ret;",
            "}"
          ],
          "function_name": "dec_user_namespaces, set_cred_user_ns, enforced_nproc_rlimit, create_user_ns",
          "description": "实现用户命名空间创建逻辑，包含权限验证、资源分配、安全策略应用及命名空间引用计数管理。",
          "similarity": 0.7081617116928101
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1297,
          "end_line": 1365,
          "content": [
            "bool userns_may_setgroups(const struct user_namespace *ns)",
            "{",
            "\tbool allowed;",
            "",
            "\tmutex_lock(&userns_state_mutex);",
            "\t/* It is not safe to use setgroups until a gid mapping in",
            "\t * the user namespace has been established.",
            "\t */",
            "\tallowed = ns->gid_map.nr_extents != 0;",
            "\t/* Is setgroups allowed? */",
            "\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "\treturn allowed;",
            "}",
            "bool in_userns(const struct user_namespace *ancestor,",
            "\t       const struct user_namespace *child)",
            "{",
            "\tconst struct user_namespace *ns;",
            "\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)",
            "\t\t;",
            "\treturn (ns == ancestor);",
            "}",
            "bool current_in_userns(const struct user_namespace *target_ns)",
            "{",
            "\treturn in_userns(target_ns, current_user_ns());",
            "}",
            "static void userns_put(struct ns_common *ns)",
            "{",
            "\tput_user_ns(to_user_ns(ns));",
            "}",
            "static int userns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct user_namespace *user_ns = to_user_ns(ns);",
            "\tstruct cred *cred;",
            "",
            "\t/* Don't allow gaining capabilities by reentering",
            "\t * the same user namespace.",
            "\t */",
            "\tif (user_ns == current_user_ns())",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Tasks that share a thread group must share a user namespace */",
            "\tif (!thread_group_empty(current))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (current->fs->users != 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tcred = nsset_cred(nsset);",
            "\tif (!cred)",
            "\t\treturn -EINVAL;",
            "",
            "\tput_user_ns(cred->user_ns);",
            "\tset_cred_user_ns(cred, get_user_ns(user_ns));",
            "",
            "\tif (set_cred_ucounts(cred) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static __init int user_namespaces_init(void)",
            "{",
            "\tuser_ns_cachep = KMEM_CACHE(user_namespace, SLAB_PANIC | SLAB_ACCOUNT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "userns_may_setgroups, in_userns, current_in_userns, userns_put, userns_install, user_namespaces_init",
          "description": "实现用户命名空间相关辅助功能，userns_may_setgroups检查setgroups可用性，in_userns判断命名空间层级关系，userns_install负责用户命名空间的安装与引用计数管理，user_namespaces_init初始化用户命名空间对象缓存",
          "similarity": 0.6410403847694397
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1,
          "end_line": 40,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/export.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/highuid.h>",
            "#include <linux/cred.h>",
            "#include <linux/securebits.h>",
            "#include <linux/security.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ctype.h>",
            "#include <linux/projid.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/sort.h>",
            "#ifdef CONFIG_CREDP",
            "#include <asm/iee-cred.h>",
            "#endif",
            "",
            "static struct kmem_cache *user_ns_cachep __ro_after_init;",
            "static DEFINE_MUTEX(userns_state_mutex);",
            "",
            "static bool new_idmap_permitted(const struct file *file,",
            "\t\t\t\tstruct user_namespace *ns, int cap_setid,",
            "\t\t\t\tstruct uid_gid_map *map);",
            "static void free_user_ns(struct work_struct *work);",
            "",
            "static struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)",
            "{",
            "\treturn inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用户命名空间相关全局变量和缓存，声明辅助函数及用户命名空间操作的通用接口。",
          "similarity": 0.637020468711853
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/user_namespace.c",
          "start_line": 722,
          "end_line": 822,
          "content": [
            "static void m_stop(struct seq_file *seq, void *v)",
            "{",
            "\treturn;",
            "}",
            "static bool mappings_overlap(struct uid_gid_map *new_map,",
            "\t\t\t     struct uid_gid_extent *extent)",
            "{",
            "\tu32 upper_first, lower_first, upper_last, lower_last;",
            "\tunsigned idx;",
            "",
            "\tupper_first = extent->first;",
            "\tlower_first = extent->lower_first;",
            "\tupper_last = upper_first + extent->count - 1;",
            "\tlower_last = lower_first + extent->count - 1;",
            "",
            "\tfor (idx = 0; idx < new_map->nr_extents; idx++) {",
            "\t\tu32 prev_upper_first, prev_lower_first;",
            "\t\tu32 prev_upper_last, prev_lower_last;",
            "\t\tstruct uid_gid_extent *prev;",
            "",
            "\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\t\tprev = &new_map->extent[idx];",
            "\t\telse",
            "\t\t\tprev = &new_map->forward[idx];",
            "",
            "\t\tprev_upper_first = prev->first;",
            "\t\tprev_lower_first = prev->lower_first;",
            "\t\tprev_upper_last = prev_upper_first + prev->count - 1;",
            "\t\tprev_lower_last = prev_lower_first + prev->count - 1;",
            "",
            "\t\t/* Does the upper range intersect a previous extent? */",
            "\t\tif ((prev_upper_first <= upper_last) &&",
            "\t\t    (prev_upper_last >= upper_first))",
            "\t\t\treturn true;",
            "",
            "\t\t/* Does the lower range intersect a previous extent? */",
            "\t\tif ((prev_lower_first <= lower_last) &&",
            "\t\t    (prev_lower_last >= lower_first))",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static int insert_extent(struct uid_gid_map *map, struct uid_gid_extent *extent)",
            "{",
            "\tstruct uid_gid_extent *dest;",
            "",
            "\tif (map->nr_extents == UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\tstruct uid_gid_extent *forward;",
            "",
            "\t\t/* Allocate memory for 340 mappings. */",
            "\t\tforward = kmalloc_array(UID_GID_MAP_MAX_EXTENTS,",
            "\t\t\t\t\tsizeof(struct uid_gid_extent),",
            "\t\t\t\t\tGFP_KERNEL);",
            "\t\tif (!forward)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/* Copy over memory. Only set up memory for the forward pointer.",
            "\t\t * Defer the memory setup for the reverse pointer.",
            "\t\t */",
            "\t\tmemcpy(forward, map->extent,",
            "\t\t       map->nr_extents * sizeof(map->extent[0]));",
            "",
            "\t\tmap->forward = forward;",
            "\t\tmap->reverse = NULL;",
            "\t}",
            "",
            "\tif (map->nr_extents < UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\tdest = &map->extent[map->nr_extents];",
            "\telse",
            "\t\tdest = &map->forward[map->nr_extents];",
            "",
            "\t*dest = *extent;",
            "\tmap->nr_extents++;",
            "\treturn 0;",
            "}",
            "static int cmp_extents_forward(const void *a, const void *b)",
            "{",
            "\tconst struct uid_gid_extent *e1 = a;",
            "\tconst struct uid_gid_extent *e2 = b;",
            "",
            "\tif (e1->first < e2->first)",
            "\t\treturn -1;",
            "",
            "\tif (e1->first > e2->first)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int cmp_extents_reverse(const void *a, const void *b)",
            "{",
            "\tconst struct uid_gid_extent *e1 = a;",
            "\tconst struct uid_gid_extent *e2 = b;",
            "",
            "\tif (e1->lower_first < e2->lower_first)",
            "\t\treturn -1;",
            "",
            "\tif (e1->lower_first > e2->lower_first)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "m_stop, mappings_overlap, insert_extent, cmp_extents_forward, cmp_extents_reverse",
          "description": "实现用户命名空间映射区间管理函数，包含范围冲突检测、有序性排序及动态扩展逻辑。",
          "similarity": 0.6311986446380615
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/user_namespace.c",
          "start_line": 860,
          "end_line": 1109,
          "content": [
            "static int sort_idmaps(struct uid_gid_map *map)",
            "{",
            "\tif (map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\treturn 0;",
            "",
            "\t/* Sort forward array. */",
            "\tsort(map->forward, map->nr_extents, sizeof(struct uid_gid_extent),",
            "\t     cmp_extents_forward, NULL);",
            "",
            "\t/* Only copy the memory from forward we actually need. */",
            "\tmap->reverse = kmemdup(map->forward,",
            "\t\t\t       map->nr_extents * sizeof(struct uid_gid_extent),",
            "\t\t\t       GFP_KERNEL);",
            "\tif (!map->reverse)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* Sort reverse array. */",
            "\tsort(map->reverse, map->nr_extents, sizeof(struct uid_gid_extent),",
            "\t     cmp_extents_reverse, NULL);",
            "",
            "\treturn 0;",
            "}",
            "static bool verify_root_map(const struct file *file,",
            "\t\t\t    struct user_namespace *map_ns,",
            "\t\t\t    struct uid_gid_map *new_map)",
            "{",
            "\tint idx;",
            "\tconst struct user_namespace *file_ns = file->f_cred->user_ns;",
            "\tstruct uid_gid_extent *extent0 = NULL;",
            "",
            "\tfor (idx = 0; idx < new_map->nr_extents; idx++) {",
            "\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\t\textent0 = &new_map->extent[idx];",
            "\t\telse",
            "\t\t\textent0 = &new_map->forward[idx];",
            "\t\tif (extent0->lower_first == 0)",
            "\t\t\tbreak;",
            "",
            "\t\textent0 = NULL;",
            "\t}",
            "",
            "\tif (!extent0)",
            "\t\treturn true;",
            "",
            "\tif (map_ns == file_ns) {",
            "\t\t/* The process unshared its ns and is writing to its own",
            "\t\t * /proc/self/uid_map.  User already has full capabilites in",
            "\t\t * the new namespace.  Verify that the parent had CAP_SETFCAP",
            "\t\t * when it unshared.",
            "\t\t * */",
            "\t\tif (!file_ns->parent_could_setfcap)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\t/* Process p1 is writing to uid_map of p2, who is in a child",
            "\t\t * user namespace to p1's.  Verify that the opener of the map",
            "\t\t * file has CAP_SETFCAP against the parent of the new map",
            "\t\t * namespace */",
            "\t\tif (!file_ns_capable(file, map_ns->parent, CAP_SETFCAP))",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static ssize_t map_write(struct file *file, const char __user *buf,",
            "\t\t\t size_t count, loff_t *ppos,",
            "\t\t\t int cap_setid,",
            "\t\t\t struct uid_gid_map *map,",
            "\t\t\t struct uid_gid_map *parent_map)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tstruct user_namespace *map_ns = seq->private;",
            "\tstruct uid_gid_map new_map;",
            "\tunsigned idx;",
            "\tstruct uid_gid_extent extent;",
            "\tchar *kbuf = NULL, *pos, *next_line;",
            "\tssize_t ret;",
            "",
            "\t/* Only allow < page size writes at the beginning of the file */",
            "\tif ((*ppos != 0) || (count >= PAGE_SIZE))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Slurp in the user data */",
            "\tkbuf = memdup_user_nul(buf, count);",
            "\tif (IS_ERR(kbuf))",
            "\t\treturn PTR_ERR(kbuf);",
            "",
            "\t/*",
            "\t * The userns_state_mutex serializes all writes to any given map.",
            "\t *",
            "\t * Any map is only ever written once.",
            "\t *",
            "\t * An id map fits within 1 cache line on most architectures.",
            "\t *",
            "\t * On read nothing needs to be done unless you are on an",
            "\t * architecture with a crazy cache coherency model like alpha.",
            "\t *",
            "\t * There is a one time data dependency between reading the",
            "\t * count of the extents and the values of the extents.  The",
            "\t * desired behavior is to see the values of the extents that",
            "\t * were written before the count of the extents.",
            "\t *",
            "\t * To achieve this smp_wmb() is used on guarantee the write",
            "\t * order and smp_rmb() is guaranteed that we don't have crazy",
            "\t * architectures returning stale data.",
            "\t */",
            "\tmutex_lock(&userns_state_mutex);",
            "",
            "\tmemset(&new_map, 0, sizeof(struct uid_gid_map));",
            "",
            "\tret = -EPERM;",
            "\t/* Only allow one successful write to the map */",
            "\tif (map->nr_extents != 0)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Adjusting namespace settings requires capabilities on the target.",
            "\t */",
            "\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))",
            "\t\tgoto out;",
            "",
            "\t/* Parse the user data */",
            "\tret = -EINVAL;",
            "\tpos = kbuf;",
            "\tfor (; pos; pos = next_line) {",
            "",
            "\t\t/* Find the end of line and ensure I don't look past it */",
            "\t\tnext_line = strchr(pos, '\\n');",
            "\t\tif (next_line) {",
            "\t\t\t*next_line = '\\0';",
            "\t\t\tnext_line++;",
            "\t\t\tif (*next_line == '\\0')",
            "\t\t\t\tnext_line = NULL;",
            "\t\t}",
            "",
            "\t\tpos = skip_spaces(pos);",
            "\t\textent.first = simple_strtoul(pos, &pos, 10);",
            "\t\tif (!isspace(*pos))",
            "\t\t\tgoto out;",
            "",
            "\t\tpos = skip_spaces(pos);",
            "\t\textent.lower_first = simple_strtoul(pos, &pos, 10);",
            "\t\tif (!isspace(*pos))",
            "\t\t\tgoto out;",
            "",
            "\t\tpos = skip_spaces(pos);",
            "\t\textent.count = simple_strtoul(pos, &pos, 10);",
            "\t\tif (*pos && !isspace(*pos))",
            "\t\t\tgoto out;",
            "",
            "\t\t/* Verify there is not trailing junk on the line */",
            "\t\tpos = skip_spaces(pos);",
            "\t\tif (*pos != '\\0')",
            "\t\t\tgoto out;",
            "",
            "\t\t/* Verify we have been given valid starting values */",
            "\t\tif ((extent.first == (u32) -1) ||",
            "\t\t    (extent.lower_first == (u32) -1))",
            "\t\t\tgoto out;",
            "",
            "\t\t/* Verify count is not zero and does not cause the",
            "\t\t * extent to wrap",
            "\t\t */",
            "\t\tif ((extent.first + extent.count) <= extent.first)",
            "\t\t\tgoto out;",
            "\t\tif ((extent.lower_first + extent.count) <=",
            "\t\t     extent.lower_first)",
            "\t\t\tgoto out;",
            "",
            "\t\t/* Do the ranges in extent overlap any previous extents? */",
            "\t\tif (mappings_overlap(&new_map, &extent))",
            "\t\t\tgoto out;",
            "",
            "\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&",
            "\t\t    (next_line != NULL))",
            "\t\t\tgoto out;",
            "",
            "\t\tret = insert_extent(&new_map, &extent);",
            "\t\tif (ret < 0)",
            "\t\t\tgoto out;",
            "\t\tret = -EINVAL;",
            "\t}",
            "\t/* Be very certain the new map actually exists */",
            "\tif (new_map.nr_extents == 0)",
            "\t\tgoto out;",
            "",
            "\tret = -EPERM;",
            "\t/* Validate the user is allowed to use user id's mapped to. */",
            "\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))",
            "\t\tgoto out;",
            "",
            "\tret = -EPERM;",
            "\t/* Map the lower ids from the parent user namespace to the",
            "\t * kernel global id space.",
            "\t */",
            "\tfor (idx = 0; idx < new_map.nr_extents; idx++) {",
            "\t\tstruct uid_gid_extent *e;",
            "\t\tu32 lower_first;",
            "",
            "\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\t\te = &new_map.extent[idx];",
            "\t\telse",
            "\t\t\te = &new_map.forward[idx];",
            "",
            "\t\tlower_first = map_id_range_down(parent_map,",
            "\t\t\t\t\t\te->lower_first,",
            "\t\t\t\t\t\te->count);",
            "",
            "\t\t/* Fail if we can not map the specified extent to",
            "\t\t * the kernel global id space.",
            "\t\t */",
            "\t\tif (lower_first == (u32) -1)",
            "\t\t\tgoto out;",
            "",
            "\t\te->lower_first = lower_first;",
            "\t}",
            "",
            "\t/*",
            "\t * If we want to use binary search for lookup, this clones the extent",
            "\t * array and sorts both copies.",
            "\t */",
            "\tret = sort_idmaps(&new_map);",
            "\tif (ret < 0)",
            "\t\tgoto out;",
            "",
            "\t/* Install the map */",
            "\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\tmemcpy(map->extent, new_map.extent,",
            "\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));",
            "\t} else {",
            "\t\tmap->forward = new_map.forward;",
            "\t\tmap->reverse = new_map.reverse;",
            "\t}",
            "\tsmp_wmb();",
            "\tmap->nr_extents = new_map.nr_extents;",
            "",
            "\t*ppos = count;",
            "\tret = count;",
            "out:",
            "\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\tkfree(new_map.forward);",
            "\t\tkfree(new_map.reverse);",
            "\t\tmap->forward = NULL;",
            "\t\tmap->reverse = NULL;",
            "\t\tmap->nr_extents = 0;",
            "\t}",
            "",
            "\tmutex_unlock(&userns_state_mutex);",
            "\tkfree(kbuf);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "sort_idmaps, verify_root_map, map_write",
          "description": "实现用户命名空间中ID映射的排序与验证逻辑，通过sort_idmaps对映射区间排序并复制内存，verify_root_map检查根映射的权限合法性，map_write处理用户态ID映射写入，包含数据解析、有效性校验及映射安装，需具备SETUID/SETGID能力",
          "similarity": 0.6288136839866638
        }
      ]
    },
    {
      "source_file": "mm/usercopy.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:30:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usercopy.c`\n\n---\n\n# usercopy.c 技术文档\n\n## 1. 文件概述\n\n`usercopy.c` 实现了 Linux 内核中 `CONFIG_HARDENED_USERCOPY*` 系列安全机制的核心检查逻辑，旨在防止内核内存在用户空间与内核空间之间进行数据拷贝（如 `copy_from_user()` 和 `copy_to_user()`）时发生**非预期的暴露（exposure）或覆写（overwrite）**。该机制源自 PaX 的 `PAX_USERCOPY` 安全特性，通过严格验证待拷贝缓冲区的合法性，阻止攻击者利用内核漏洞读取或篡改敏感内核数据。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__check_object_size(const void *ptr, unsigned long n, bool to_user)`**  \n  入口函数，对指定内存区域 `[ptr, ptr+n)` 执行完整的安全性检查。\n  \n- **`usercopy_abort(const char *name, const char *detail, bool to_user, unsigned long offset, unsigned long len)`**  \n  安全违规处理函数，打印详细错误信息并触发内核 `BUG()` 崩溃。\n\n- **`check_stack_object(const void *obj, unsigned long len)`**  \n  检查对象是否位于当前任务的合法栈范围内，并进一步判断是否处于有效栈帧内。\n\n- **`check_heap_object(const void *ptr, unsigned long n, bool to_user)`**  \n  验证堆分配对象（包括 slab、vmalloc、高端内存映射等）的边界和合法性。\n\n- **`check_kernel_text_object(unsigned long ptr, unsigned long n, bool to_user)`**  \n  检测访问是否涉及内核代码段（`.text`），防止内核指令被意外读取或修改。\n\n- **`check_bogus_address(unsigned long ptr, unsigned long n, bool to_user)`**  \n  检查地址是否为非法值（如空指针、地址回绕等）。\n\n- **`overlaps(unsigned long ptr, unsigned long n, unsigned long low, unsigned long high)`**  \n  辅助函数，判断两个内存区间是否重叠。\n\n### 关键数据结构/宏\n\n- **`bypass_usercopy_checks`**  \n  静态跳转键（static key），用于在运行时动态关闭所有用户拷贝检查（通常仅用于调试）。\n\n- **`parse_hardened_usercopy(char *str)`**  \n  内核启动参数解析函数（未完整显示），用于通过 `hardened_usercopy=` 参数控制是否启用检查。\n\n- **返回码枚举（隐式定义）**：\n  - `NOT_STACK`：对象不在栈上\n  - `GOOD_FRAME`：对象完全位于有效栈帧内\n  - `GOOD_STACK`：对象在栈上但无法精确验证帧\n  - `BAD_STACK`：栈位置非法或跨越栈边界\n\n## 3. 关键实现\n\n### 多层次内存区域验证\n`__check_object_size()` 按顺序执行以下检查：\n\n1. **地址有效性检查**  \n   使用 `check_bogus_address()` 排除空指针、零长度及地址算术溢出（回绕）情况。\n\n2. **栈内存检查**  \n   调用 `check_stack_object()`：\n   - 首先确认对象完全位于当前任务的栈页（`[stack, stack + THREAD_SIZE)`）内；\n   - 若架构支持（`arch_within_stack_frames`），进一步验证是否处于合法调用帧中；\n   - 若支持当前栈指针（`current_stack_pointer`），还会检查对象是否位于当前栈指针的有效方向内（考虑栈增长方向）。\n\n3. **堆内存检查**  \n   `check_heap_object()` 区分多种分配类型：\n   - **kmap 地址**：限制单页内偏移不超过页边界；\n   - **vmalloc 地址**：通过 `find_vmap_area()` 获取虚拟内存区域，验证不越界；\n   - **物理页分配（folio）**：\n     - 若为 slab 对象，调用 `__check_heap_object()`（定义于 `slab.h`）检查是否在缓存的 `useroffset/usersize` 白名单范围内；\n     - 若为大页（`folio_test_large`），验证不超出 folio 范围。\n\n4. **内核文本段保护**  \n   `check_kernel_text_object()` 检查是否与 `_stext` 到 `_etext` 区间重叠，并额外处理某些架构存在的线性映射别名（通过 `lm_alias()`）。\n\n### 安全违规响应\n一旦任一检查失败，立即调用 `usercopy_abort()`：\n- 打印包含操作方向（to/from user）、对象类型、偏移、长度等详细信息；\n- 调用 `BUG()` 触发内核崩溃，防止继续执行可能被利用的路径。\n\n### 性能优化\n- 使用 `static_branch_unlikely(&bypass_usercopy_checks)` 实现检查开关，正常启用时几乎无性能开销；\n- 栈帧检查使用 `noinline` 避免内联膨胀；\n- 零长度拷贝直接跳过所有检查。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`, `<linux/slab.h>`, `\"slab.h\"`：内存管理及 slab 分配器接口\n  - `<linux/vmalloc.h>`：vmalloc 区域查询\n  - `<linux/highmem.h>`：高端内存映射（kmap）判断\n  - `<asm/sections.h>`：内核符号 `_stext`/`_etext`\n  - `<linux/jump_label.h>`：静态跳转键支持\n\n- **架构依赖**：\n  - `arch_within_stack_frames()`：由各架构提供栈帧验证实现\n  - `current_stack_pointer`：需 `CONFIG_ARCH_HAS_CURRENT_STACK_POINTER`\n  - `lm_alias()`：处理内核线性映射别名（如 x86 的 `__va()`/`__pa()` 非对称映射）\n\n- **导出符号**：\n  - `EXPORT_SYMBOL(__check_object_size)`：供其他模块（如驱动、文件系统）在自定义用户拷贝路径中调用\n\n## 5. 使用场景\n\n- **内核用户拷贝入口点**  \n  在 `copy_from_user()` / `copy_to_user()` 等函数内部（通常通过 `might_fault()` 或特定配置选项）调用 `__check_object_size()`，确保传入的内核缓冲区安全。\n\n- **Slab 缓存白名单验证**  \n  当使用 `kmem_cache_create_usercopy()` 创建允许部分暴露给用户的 slab 缓存时，此文件验证访问是否严格限制在声明的 `useroffset` 和 `usersize` 范围内。\n\n- **安全加固默认行为**  \n  启用 `CONFIG_HARDENED_USERCOPY` 后，所有未显式绕过检查的内核-用户数据传输均受保护，有效缓解因缓冲区溢出、Use-After-Free 等漏洞导致的内核信息泄露或提权攻击。\n\n- **调试与禁用**  \n  通过内核启动参数 `hardened_usercopy=0` 可临时禁用检查（需 `parse_hardened_usercopy` 完整实现），用于调试或兼容特殊硬件驱动。",
      "similarity": 0.636332094669342,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/usercopy.c",
          "start_line": 162,
          "end_line": 258,
          "content": [
            "static inline void check_heap_object(const void *ptr, unsigned long n,",
            "\t\t\t\t     bool to_user)",
            "{",
            "\tunsigned long addr = (unsigned long)ptr;",
            "\tunsigned long offset;",
            "\tstruct folio *folio;",
            "",
            "\tif (is_kmap_addr(ptr)) {",
            "\t\toffset = offset_in_page(ptr);",
            "\t\tif (n > PAGE_SIZE - offset)",
            "\t\t\tusercopy_abort(\"kmap\", NULL, to_user, offset, n);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (is_vmalloc_addr(ptr) && !pagefault_disabled()) {",
            "\t\tstruct vmap_area *area = find_vmap_area(addr);",
            "",
            "\t\tif (!area)",
            "\t\t\tusercopy_abort(\"vmalloc\", \"no area\", to_user, 0, n);",
            "",
            "\t\tif (n > area->va_end - addr) {",
            "\t\t\toffset = addr - area->va_start;",
            "\t\t\tusercopy_abort(\"vmalloc\", NULL, to_user, offset, n);",
            "\t\t}",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!virt_addr_valid(ptr))",
            "\t\treturn;",
            "",
            "\tfolio = virt_to_folio(ptr);",
            "",
            "\tif (folio_test_slab(folio)) {",
            "\t\t/* Check slab allocator for flags and size. */",
            "\t\t__check_heap_object(ptr, n, folio_slab(folio), to_user);",
            "\t} else if (folio_test_large(folio)) {",
            "\t\toffset = ptr - folio_address(folio);",
            "\t\tif (n > folio_size(folio) - offset)",
            "\t\t\tusercopy_abort(\"page alloc\", NULL, to_user, offset, n);",
            "\t}",
            "}",
            "void __check_object_size(const void *ptr, unsigned long n, bool to_user)",
            "{",
            "\tif (static_branch_unlikely(&bypass_usercopy_checks))",
            "\t\treturn;",
            "",
            "\t/* Skip all tests if size is zero. */",
            "\tif (!n)",
            "\t\treturn;",
            "",
            "\t/* Check for invalid addresses. */",
            "\tcheck_bogus_address((const unsigned long)ptr, n, to_user);",
            "",
            "\t/* Check for bad stack object. */",
            "\tswitch (check_stack_object(ptr, n)) {",
            "\tcase NOT_STACK:",
            "\t\t/* Object is not touching the current process stack. */",
            "\t\tbreak;",
            "\tcase GOOD_FRAME:",
            "\tcase GOOD_STACK:",
            "\t\t/*",
            "\t\t * Object is either in the correct frame (when it",
            "\t\t * is possible to check) or just generally on the",
            "\t\t * process stack (when frame checking not available).",
            "\t\t */",
            "\t\treturn;",
            "\tdefault:",
            "\t\tusercopy_abort(\"process stack\", NULL, to_user,",
            "#ifdef CONFIG_ARCH_HAS_CURRENT_STACK_POINTER",
            "\t\t\tIS_ENABLED(CONFIG_STACK_GROWSUP) ?",
            "\t\t\t\tptr - (void *)current_stack_pointer :",
            "\t\t\t\t(void *)current_stack_pointer - ptr,",
            "#else",
            "\t\t\t0,",
            "#endif",
            "\t\t\tn);",
            "\t}",
            "",
            "\t/* Check for bad heap object. */",
            "\tcheck_heap_object(ptr, n, to_user);",
            "",
            "\t/* Check for object in kernel to avoid text exposure. */",
            "\tcheck_kernel_text_object((const unsigned long)ptr, n, to_user);",
            "}",
            "static int __init parse_hardened_usercopy(char *str)",
            "{",
            "\tif (kstrtobool(str, &enable_checks))",
            "\t\tpr_warn(\"Invalid option string for hardened_usercopy: '%s'\\n\",",
            "\t\t\tstr);",
            "\treturn 1;",
            "}",
            "static int __init set_hardened_usercopy(void)",
            "{",
            "\tif (enable_checks == false)",
            "\t\tstatic_branch_enable(&bypass_usercopy_checks);",
            "\treturn 1;",
            "}"
          ],
          "function_name": "check_heap_object, __check_object_size, parse_hardened_usercopy, set_hardened_usercopy",
          "description": "实现堆对象有效性检查、通用对象大小验证及硬编码用户复制检查配置解析与启用逻辑，支持动态配置安全检查机制",
          "similarity": 0.6069455146789551
        },
        {
          "chunk_id": 0,
          "file_path": "mm/usercopy.c",
          "start_line": 1,
          "end_line": 36,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * This implements the various checks for CONFIG_HARDENED_USERCOPY*,",
            " * which are designed to protect kernel memory from needless exposure",
            " * and overwrite under many unintended conditions. This code is based",
            " * on PAX_USERCOPY, which is:",
            " *",
            " * Copyright (C) 2001-2016 PaX Team, Bradley Spengler, Open Source",
            " * Security Inc.",
            " */",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kstrtox.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/atomic.h>",
            "#include <linux/jump_label.h>",
            "#include <asm/sections.h>",
            "#include \"slab.h\"",
            "",
            "/*",
            " * Checks if a given pointer and length is contained by the current",
            " * stack frame (if possible).",
            " *",
            " * Returns:",
            " *\tNOT_STACK: not at all on the stack",
            " *\tGOOD_FRAME: fully within a valid stack frame",
            " *\tGOOD_STACK: within the current stack (when can't frame-check exactly)",
            " *\tBAD_STACK: error condition (invalid stack position or bad stack frame)",
            " */"
          ],
          "function_name": null,
          "description": "声明CONFIG_HARDENED_USERCOPY相关的检查常量和基础头文件，定义用于检测栈对象是否安全的返回值类型",
          "similarity": 0.586624026298523
        },
        {
          "chunk_id": 1,
          "file_path": "mm/usercopy.c",
          "start_line": 37,
          "end_line": 142,
          "content": [
            "static noinline int check_stack_object(const void *obj, unsigned long len)",
            "{",
            "\tconst void * const stack = task_stack_page(current);",
            "\tconst void * const stackend = stack + THREAD_SIZE;",
            "\tint ret;",
            "",
            "\t/* Object is not on the stack at all. */",
            "\tif (obj + len <= stack || stackend <= obj)",
            "\t\treturn NOT_STACK;",
            "",
            "\t/*",
            "\t * Reject: object partially overlaps the stack (passing the",
            "\t * check above means at least one end is within the stack,",
            "\t * so if this check fails, the other end is outside the stack).",
            "\t */",
            "\tif (obj < stack || stackend < obj + len)",
            "\t\treturn BAD_STACK;",
            "",
            "\t/* Check if object is safely within a valid frame. */",
            "\tret = arch_within_stack_frames(stack, stackend, obj, len);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* Finally, check stack depth if possible. */",
            "#ifdef CONFIG_ARCH_HAS_CURRENT_STACK_POINTER",
            "\tif (IS_ENABLED(CONFIG_STACK_GROWSUP)) {",
            "\t\tif ((void *)current_stack_pointer < obj + len)",
            "\t\t\treturn BAD_STACK;",
            "\t} else {",
            "\t\tif (obj < (void *)current_stack_pointer)",
            "\t\t\treturn BAD_STACK;",
            "\t}",
            "#endif",
            "",
            "\treturn GOOD_STACK;",
            "}",
            "void __noreturn usercopy_abort(const char *name, const char *detail,",
            "\t\t\t       bool to_user, unsigned long offset,",
            "\t\t\t       unsigned long len)",
            "{",
            "\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",",
            "\t\t to_user ? \"exposure\" : \"overwrite\",",
            "\t\t to_user ? \"from\" : \"to\",",
            "\t\t name ? : \"unknown?!\",",
            "\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",",
            "\t\t offset, len);",
            "",
            "\t/*",
            "\t * For greater effect, it would be nice to do do_group_exit(),",
            "\t * but BUG() actually hooks all the lock-breaking and per-arch",
            "\t * Oops code, so that is used here instead.",
            "\t */",
            "\tBUG();",
            "}",
            "static bool overlaps(const unsigned long ptr, unsigned long n,",
            "\t\t     unsigned long low, unsigned long high)",
            "{",
            "\tconst unsigned long check_low = ptr;",
            "\tunsigned long check_high = check_low + n;",
            "",
            "\t/* Does not overlap if entirely above or entirely below. */",
            "\tif (check_low >= high || check_high <= low)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static inline void check_kernel_text_object(const unsigned long ptr,",
            "\t\t\t\t\t    unsigned long n, bool to_user)",
            "{",
            "\tunsigned long textlow = (unsigned long)_stext;",
            "\tunsigned long texthigh = (unsigned long)_etext;",
            "\tunsigned long textlow_linear, texthigh_linear;",
            "",
            "\tif (overlaps(ptr, n, textlow, texthigh))",
            "\t\tusercopy_abort(\"kernel text\", NULL, to_user, ptr - textlow, n);",
            "",
            "\t/*",
            "\t * Some architectures have virtual memory mappings with a secondary",
            "\t * mapping of the kernel text, i.e. there is more than one virtual",
            "\t * kernel address that points to the kernel image. It is usually",
            "\t * when there is a separate linear physical memory mapping, in that",
            "\t * __pa() is not just the reverse of __va(). This can be detected",
            "\t * and checked:",
            "\t */",
            "\ttextlow_linear = (unsigned long)lm_alias(textlow);",
            "\t/* No different mapping: we're done. */",
            "\tif (textlow_linear == textlow)",
            "\t\treturn;",
            "",
            "\t/* Check the secondary mapping... */",
            "\ttexthigh_linear = (unsigned long)lm_alias(texthigh);",
            "\tif (overlaps(ptr, n, textlow_linear, texthigh_linear))",
            "\t\tusercopy_abort(\"linear kernel text\", NULL, to_user,",
            "\t\t\t       ptr - textlow_linear, n);",
            "}",
            "static inline void check_bogus_address(const unsigned long ptr, unsigned long n,",
            "\t\t\t\t       bool to_user)",
            "{",
            "\t/* Reject if object wraps past end of memory. */",
            "\tif (ptr + (n - 1) < ptr)",
            "\t\tusercopy_abort(\"wrapped address\", NULL, to_user, 0, ptr + n);",
            "",
            "\t/* Reject if NULL or ZERO-allocation. */",
            "\tif (ZERO_OR_NULL_PTR(ptr))",
            "\t\tusercopy_abort(\"null address\", NULL, to_user, ptr, n);",
            "}"
          ],
          "function_name": "check_stack_object, usercopy_abort, overlaps, check_kernel_text_object, check_bogus_address",
          "description": "实现栈对象边界检查、异常终止函数、地址范围重叠检测及内核文本区域防护逻辑，用于防止非法内存访问",
          "similarity": 0.5854461789131165
        }
      ]
    },
    {
      "source_file": "kernel/user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:58\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user.c`\n\n---\n\n# user.c 技术文档\n\n## 1. 文件概述\n\n`user.c` 实现了 Linux 内核中的 **用户缓存（user cache）** 机制，用于跟踪每个用户（以 UID 标识）所占用的系统资源（如进程数、打开文件数等），从而支持基于用户的资源限制（per-user limits）。该文件维护了一个全局的哈希表，用于快速查找和管理 `user_struct` 结构体实例，并提供了用户结构的分配、引用计数管理和释放接口。此外，文件还定义了初始用户命名空间 `init_user_ns` 和根用户结构 `root_user`，为系统启动和用户命名空间功能提供基础支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`init_user_ns`**：全局初始用户命名空间（`struct user_namespace`），作为所有用户命名空间的根，包含完整的 UID/GID/ProjID 映射（0~2³²-1），引用计数初始化为 3。\n- **`root_user`**：代表 UID 为 0 的根用户的 `struct user_struct` 实例，引用计数初始化为 1（供 init 进程使用）。\n- **`uidhash_table`**：大小为 `2^UIDHASH_BITS`（通常为 128）的哈希表，用于存储 `user_struct` 实例，实现 O(1) 平均查找复杂度。\n- **`uid_cachep`**：SLAB 缓存，用于高效分配和释放 `struct user_struct` 对象。\n\n### 主要函数\n\n- **`alloc_uid(kuid_t uid)`**：根据 UID 查找或创建对应的 `user_struct`。若不存在则分配新结构体，初始化资源计数器（如 epoll watches），并插入哈希表；若已存在则增加引用计数。处理并发创建的竞争条件。\n- **`find_user(kuid_t uid)`**：在哈希表中查找指定 UID 的 `user_struct`，若找到则增加引用计数并返回，否则返回 NULL。\n- **`free_uid(struct user_struct *up)`**：减少 `user_struct` 的引用计数，若计数归零则调用 `free_user` 释放资源。\n- **`free_user(struct user_struct *up, unsigned long flags)`**：内部函数，从哈希表中移除用户结构，释放 epoll 计数器，并通过 SLAB 缓存回收内存。\n- **`uid_cache_init(void)`**：初始化函数（通过 `subsys_initcall` 注册），创建 SLAB 缓存、初始化哈希表、为 `root_user` 分配 epoll 计数器，并将 `root_user` 插入哈希表。\n\n### 辅助函数\n\n- **`uid_hash_insert/remove/find`**：哈希表操作的内部封装，必须在持有 `uidhash_lock` 自旋锁时调用。\n- **`user_epoll_alloc/free`**：条件编译函数，用于初始化/销毁 `user_struct` 中的 epoll watches per-CPU 计数器（仅当 `CONFIG_EPOLL` 启用时有效）。\n\n## 3. 关键实现\n\n### 哈希表设计与并发控制\n\n- **哈希函数**：使用 `__uidhashfn(uid) = ((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK`，将 32 位 UID 映射到 `UIDHASH_SZ`（默认 128）个桶中，减少冲突。\n- **锁机制**：使用 `DEFINE_SPINLOCK(uidhash_lock)` 保护哈希表操作。该锁需 **软中断安全（softirq-safe）**，因为 `free_uid()` 可能在 RCU 回调（软中断上下文）中被调用。\n- **中断处理**：所有哈希表操作均使用 `spin_lock_irqsave/restore` 或 `spin_lock_irq/unlock`，确保在中断上下文和进程上下文间的正确同步。\n\n### 引用计数与资源管理\n\n- **引用计数**：`user_struct.__count` 使用 `refcount_t` 类型，确保原子操作。`alloc_uid` 返回时已持有引用，调用者必须通过 `free_uid` 释放。\n- **延迟释放**：`free_uid` 使用 `refcount_dec_and_lock_irqsave` 原子地减少计数并在归零时获取锁，避免竞态条件。\n- **资源初始化**：新创建的 `user_struct` 会初始化速率限制器（`ratelimit`）和 epoll watches 计数器（若启用）。\n\n### 初始化与竞态处理\n\n- **`root_user` 预置**：在 `uid_cache_init` 中预先将 `root_user` 插入哈希表，确保 init 进程可直接使用。\n- **双重检查**：`alloc_uid` 在分配新结构后再次检查哈希表，防止多线程同时创建同一 UID 的 `user_struct`，确保唯一性。\n\n### 用户命名空间支持\n\n- **`init_user_ns`**：作为初始用户命名空间，其 UID/GID 映射覆盖全范围（0 到 2³²-1），标志位 `USERNS_INIT_FLAGS` 启用特定行为（如允许 setgroups）。\n- **密钥环支持**：若启用 `CONFIG_KEYS`，`init_user_ns` 包含密钥环名称列表和读写信号量。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/sched/user.h>`：定义 `struct user_struct`。\n  - `<linux/user_namespace.h>`：定义 `struct user_namespace` 和相关操作。\n  - `<linux/key.h>`：提供密钥环支持（条件编译）。\n  - `<linux/percpu_counter.h>`（隐含）：用于 epoll watches 计数（通过 `CONFIG_EPOLL`）。\n- **内核配置依赖**：\n  - `CONFIG_EPOLL`：控制 epoll watches 计数器的编译。\n  - `CONFIG_USER_NS`：控制用户命名空间操作函数的绑定。\n  - `CONFIG_KEYS`：控制密钥环相关字段的初始化。\n- **子系统依赖**：\n  - **进程调度子系统**：`user_struct` 被嵌入到进程凭证（`cred`）中，用于资源统计。\n  - **用户命名空间子系统**：`init_user_ns` 是用户命名空间层次结构的根。\n  - **内存管理子系统**：依赖 SLAB 分配器管理 `user_struct` 对象。\n\n## 5. 使用场景\n\n- **进程凭证管理**：当进程通过 `setuid()`、`setreuid()` 等系统调用切换用户身份时，内核调用 `alloc_uid` 获取目标 UID 的 `user_struct`，并更新进程凭证中的用户引用。\n- **资源限制实施**：内核在创建进程、打开文件、分配内存等操作时，通过 `current_uid()` 获取当前用户的 `user_struct`，检查并更新资源使用计数（如 `processes`、`files` 字段），确保不超过 `ulimit` 限制。\n- **用户命名空间创建**：新用户命名空间的创建依赖 `init_user_ns` 作为父命名空间，并继承其映射逻辑。\n- **系统初始化**：在内核启动早期（`subsys_initcall` 阶段），初始化用户缓存和根用户结构，为 init 进程（PID 1）提供用户上下文。\n- **资源回收**：当进程退出或切换用户时，通过 `free_uid` 释放不再需要的 `user_struct` 引用，最终在引用计数归零时回收内存和相关资源（如 epoll 计数器）。",
      "similarity": 0.6326990127563477,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/user.c",
          "start_line": 1,
          "end_line": 107,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * The \"user cache\".",
            " *",
            " * (C) Copyright 1991-2000 Linus Torvalds",
            " *",
            " * We have a per-user structure to keep track of how many",
            " * processes, files etc the user has claimed, in order to be",
            " * able to have per-user limits for system resources. ",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "",
            "/*",
            " * userns count is 1 for root user, 1 for init_uts_ns,",
            " * and 1 for... ?",
            " */",
            "struct user_namespace init_user_ns = {",
            "\t.uid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.gid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.projid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.ns.count = REFCOUNT_INIT(3),",
            "\t.owner = GLOBAL_ROOT_UID,",
            "\t.group = GLOBAL_ROOT_GID,",
            "\t.ns.inum = PROC_USER_INIT_INO,",
            "#ifdef CONFIG_USER_NS",
            "\t.ns.ops = &userns_operations,",
            "#endif",
            "\t.flags = USERNS_INIT_FLAGS,",
            "#ifdef CONFIG_KEYS",
            "\t.keyring_name_list = LIST_HEAD_INIT(init_user_ns.keyring_name_list),",
            "\t.keyring_sem = __RWSEM_INITIALIZER(init_user_ns.keyring_sem),",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_user_ns);",
            "",
            "/*",
            " * UID task count cache, to get fast user lookup in \"alloc_uid\"",
            " * when changing user ID's (ie setuid() and friends).",
            " */",
            "",
            "#define UIDHASH_BITS\t(CONFIG_BASE_SMALL ? 3 : 7)",
            "#define UIDHASH_SZ\t(1 << UIDHASH_BITS)",
            "#define UIDHASH_MASK\t\t(UIDHASH_SZ - 1)",
            "#define __uidhashfn(uid)\t(((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK)",
            "#define uidhashentry(uid)\t(uidhash_table + __uidhashfn((__kuid_val(uid))))",
            "",
            "static struct kmem_cache *uid_cachep;",
            "static struct hlist_head uidhash_table[UIDHASH_SZ];",
            "",
            "/*",
            " * The uidhash_lock is mostly taken from process context, but it is",
            " * occasionally also taken from softirq/tasklet context, when",
            " * task-structs get RCU-freed. Hence all locking must be softirq-safe.",
            " * But free_uid() is also called with local interrupts disabled, and running",
            " * local_bh_enable() with local interrupts disabled is an error - we'll run",
            " * softirq callbacks, and they can unconditionally enable interrupts, and",
            " * the caller of free_uid() didn't expect that..",
            " */",
            "static DEFINE_SPINLOCK(uidhash_lock);",
            "",
            "/* root_user.__count is 1, for init task cred */",
            "struct user_struct root_user = {",
            "\t.__count\t= REFCOUNT_INIT(1),",
            "\t.uid\t\t= GLOBAL_ROOT_UID,",
            "\t.ratelimit\t= RATELIMIT_STATE_INIT(root_user.ratelimit, 0, 0),",
            "};",
            "",
            "/*",
            " * These routines must be called with the uidhash spinlock held!",
            " */"
          ],
          "function_name": null,
          "description": "定义初始用户命名空间init_user_ns，配置UID/GID/PROJID映射关系并初始化引用计数，建立全局根用户user_struct结构，通过uidhash_table构建基于哈希的UID快速查找表，设置UID哈希锁及缓存参数",
          "similarity": 0.5873976945877075
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/user.c",
          "start_line": 108,
          "end_line": 167,
          "content": [
            "static void uid_hash_insert(struct user_struct *up, struct hlist_head *hashent)",
            "{",
            "\thlist_add_head(&up->uidhash_node, hashent);",
            "}",
            "static void uid_hash_remove(struct user_struct *up)",
            "{",
            "\thlist_del_init(&up->uidhash_node);",
            "}",
            "static int user_epoll_alloc(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\treturn percpu_counter_init(&up->epoll_watches, 0, GFP_KERNEL);",
            "#else",
            "\treturn 0;",
            "#endif",
            "}",
            "static void user_epoll_free(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\tpercpu_counter_destroy(&up->epoll_watches);",
            "#endif",
            "}",
            "static void free_user(struct user_struct *up, unsigned long flags)",
            "\t__releases(&uidhash_lock)",
            "{",
            "\tuid_hash_remove(up);",
            "\tspin_unlock_irqrestore(&uidhash_lock, flags);",
            "\tuser_epoll_free(up);",
            "\tkmem_cache_free(uid_cachep, up);",
            "}",
            "void free_uid(struct user_struct *up)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!up)",
            "\t\treturn;",
            "",
            "\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))",
            "\t\tfree_user(up, flags);",
            "}",
            "static int __init uid_cache_init(void)",
            "{",
            "\tint n;",
            "",
            "\tuid_cachep = kmem_cache_create(\"uid_cache\", sizeof(struct user_struct),",
            "\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);",
            "",
            "\tfor(n = 0; n < UIDHASH_SZ; ++n)",
            "\t\tINIT_HLIST_HEAD(uidhash_table + n);",
            "",
            "\tif (user_epoll_alloc(&root_user))",
            "\t\tpanic(\"root_user epoll percpu counter alloc failed\");",
            "",
            "\t/* Insert the root user immediately (init already runs as root) */",
            "\tspin_lock_irq(&uidhash_lock);",
            "\tuid_hash_insert(&root_user, uidhashentry(GLOBAL_ROOT_UID));",
            "\tspin_unlock_irq(&uidhash_lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "uid_hash_insert, uid_hash_remove, user_epoll_alloc, user_epoll_free, free_user, free_uid, uid_cache_init",
          "description": "实现用户结构体在UID哈希表中的增删操作，管理epoll计数器资源分配释放，提供free_user/free_uid接口完成用户结构销毁流程，初始化uid_cache缓存及哈希表基础结构并注册根用户",
          "similarity": 0.5249764323234558
        }
      ]
    }
  ]
}