{
  "query": "安全模块（SELinux/AppArmor）文件保护实现",
  "timestamp": "2025-12-26 00:19:14",
  "retrieved_files": [
    {
      "source_file": "mm/memfd.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:40:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memfd.c`\n\n---\n\n# memfd.c 技术文档\n\n## 1. 文件概述\n\n`memfd.c` 实现了 Linux 内核中的 `memfd_create()` 系统调用及其配套的文件密封（file sealing）机制。该文件最初是 `shmem.c` 的一部分，后被拆分出来以同时支持 tmpfs 和 hugetlbfs 文件系统。其核心功能包括：\n\n- 创建匿名内存文件（memfd），无需关联磁盘或文件系统路径\n- 提供文件密封（sealing）能力，允许对共享内存区域施加不可逆的操作限制\n- 支持普通页和大页（hugetlb）两种内存分配模式\n- 通过引用计数检测和等待机制确保密封操作的安全性\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|---------|\n| `memfd_alloc_folio()` | 为 memfd 文件分配 folio（页），支持普通页和大页模式 |\n| `memfd_wait_for_pins()` | 等待所有被外部引用（如 GUP、DMA）的 folio 释放，用于 SEAL_WRITE 密封前的安全检查 |\n| `memfd_tag_pins()` | 扫描地址空间，标记具有额外引用计数的 folio |\n| `memfd_add_seals()` | 向文件添加密封标志，实现不可逆的访问控制 |\n| `memfd_get_seals()` | 获取文件当前的密封标志 |\n| `memfd_fcntl()` | 处理 F_ADD_SEALS 和 F_GET_SEALS fcntl 命令 |\n\n### 关键数据结构和常量\n\n- **密封标志**：\n  - `F_SEAL_SEAL`：禁止进一步添加密封\n  - `F_SEAL_WRITE`：禁止写入\n  - `F_SEAL_GROW/SHRINK`：禁止文件增长/缩小\n  - `F_SEAL_EXEC`：禁止修改执行权限位\n  - `F_SEAL_FUTURE_WRITE`：禁止未来写入（与 EXEC 相关）\n\n- **memfd 标志**：\n  - `MFD_CLOEXEC`：close-on-exec\n  - `MFD_ALLOW_SEALING`：允许密封\n  - `MFD_HUGETLB`：使用大页\n  - `MFD_NOEXEC_SEAL` / `MFD_EXEC`：控制执行权限\n\n- **内部标记**：\n  - `MEMFD_TAG_PINNED`：复用 `PAGECACHE_TAG_TOWRITE` 标记被外部引用的 folio\n\n## 3. 关键实现\n\n### 文件密封机制\n\n密封是一种**单向、不可逆**的访问控制机制：\n- 密封只能添加，不能移除\n- 一旦设置 `F_SEAL_SEAL`，不能再添加任何密封\n- 密封作用于整个 inode，影响所有文件描述符\n\n### 引用计数检测算法\n\n为安全实现 `SEAL_WRITE`，内核需确保无外部引用：\n1. **标记阶段** (`memfd_tag_pins`)：\n   - 遍历 radix tree 中的所有 folio\n   - 对 `folio_ref_count() - folio_mapcount() != folio_nr_pages()` 的 folio 标记为 PINNED\n   - 表示存在非映射引用（如 GUP、DMA）\n\n2. **等待阶段** (`memfd_wait_for_pins`)：\n   - 最多进行 5 次扫描（LAST_SCAN = 4）\n   - 指数退避等待（(HZ << scan) / 200）\n   - 最后一次扫描清理标记并返回 `-EBUSY`（如有残留引用）\n\n### 大页支持\n\n通过条件编译支持 hugetlbfs：\n- 检测 `is_file_hugepages()` 判断是否大页模式\n- 使用 `htlb_alloc_mask()` 并清除 `__GFP_HIGHMEM | __GFP_MOVABLE`\n- 调用 hugetlb 专用分配和缓存接口\n\n### 执行权限密封\n\n`F_SEAL_EXEC` 具有特殊语义：\n- 若文件已有执行权限（`i_mode & 0111`），自动添加 `WRITE|GROW|SHRINK|FUTURE_WRITE` 密封\n- 实现 W^X（Write XOR Execute）安全策略\n\n## 4. 依赖关系\n\n### 内核模块依赖\n\n- **内存管理**：\n  - `<linux/mm.h>`：folio 操作、GFP 标志\n  - `<linux/pagemap.h>`：address_space、radix tree 操作\n  - `<linux/shmem_fs.h>`：tmpfs inode 结构（`SHMEM_I`）\n  \n- **文件系统**：\n  - `<linux/hugetlb.h>`：大页支持（`HUGETLBFS_I`）\n  - `<linux/fs.h>` / `<linux/vfs.h>`：VFS 层接口\n  \n- **同步机制**：\n  - `<linux/sched/signal.h>`：可杀等待（`schedule_timeout_killable`）\n  - XArray 锁（`xas_lock_irq`）保证并发安全\n\n### 复用设计\n\n- **标记复用**：使用 `PAGECACHE_TAG_TOWRITE` 作为 `MEMFD_TAG_PINNED`，因 tmpfs/hugetlbfs 不使用此标记\n- **代码共享**：同时服务 tmpfs 和 hugetlbfs，通过 `memfd_file_seals_ptr()` 抽象 inode 访问\n\n## 5. 使用场景\n\n### 用户态应用场景\n\n1. **安全共享内存**：\n   - 多进程通过 `memfd_create()` 创建共享内存\n   - 生产者添加 `SEAL_WRITE` 后传递 fd 给消费者，确保数据不可篡改\n\n2. **动态代码加载**：\n   - JIT 编译器创建可执行 memfd\n   - 写入代码后密封 `SEAL_WRITE`，防止后续修改（配合 `SEAL_EXEC`）\n\n3. **容器/沙箱**：\n   - 限制不受信任进程对共享内存的操作能力\n   - 通过密封防止恶意进程破坏共享状态\n\n### 内核内部使用\n\n1. **GUP（Get User Pages）集成**：\n   - `memfd_alloc_folio()` 被 `gup.c` 调用，处理 memfd 的缺页\n   - 确保 DMA/GUP 场景下密封的安全性\n\n2. **大页优化**：\n   - 通过 `MFD_HUGETLB` 标志创建大页 memfd\n   - 适用于需要大块连续内存的高性能场景（如 DPDK）\n\n3. **安全增强**：\n   - `sysctl_memfd_noexec` 控制默认执行权限\n   - 防止 memfd 被滥用于代码注入攻击",
      "similarity": 0.5782186985015869,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/memfd.c",
          "start_line": 275,
          "end_line": 320,
          "content": [
            "static int memfd_get_seals(struct file *file)",
            "{",
            "\tunsigned int *seals = memfd_file_seals_ptr(file);",
            "",
            "\treturn seals ? *seals : -EINVAL;",
            "}",
            "long memfd_fcntl(struct file *file, unsigned int cmd, unsigned int arg)",
            "{",
            "\tlong error;",
            "",
            "\tswitch (cmd) {",
            "\tcase F_ADD_SEALS:",
            "\t\terror = memfd_add_seals(file, arg);",
            "\t\tbreak;",
            "\tcase F_GET_SEALS:",
            "\t\terror = memfd_get_seals(file);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\terror = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int check_sysctl_memfd_noexec(unsigned int *flags)",
            "{",
            "#ifdef CONFIG_SYSCTL",
            "\tstruct pid_namespace *ns = task_active_pid_ns(current);",
            "\tint sysctl = pidns_memfd_noexec_scope(ns);",
            "",
            "\tif (!(*flags & (MFD_EXEC | MFD_NOEXEC_SEAL))) {",
            "\t\tif (sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_SEAL)",
            "\t\t\t*flags |= MFD_NOEXEC_SEAL;",
            "\t\telse",
            "\t\t\t*flags |= MFD_EXEC;",
            "\t}",
            "",
            "\tif (!(*flags & MFD_NOEXEC_SEAL) && sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_ENFORCED) {",
            "\t\tpr_err_ratelimited(",
            "\t\t\t\"%s[%d]: memfd_create() requires MFD_NOEXEC_SEAL with vm.memfd_noexec=%d\\n\",",
            "\t\t\tcurrent->comm, task_pid_nr(current), sysctl);",
            "\t\treturn -EACCES;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "memfd_get_seals, memfd_fcntl, check_sysctl_memfd_noexec",
          "description": "提供密封信息查询接口(memfd_get_seals)和fcntl命令处理(memfd_fcntl)，check_sysctl_memfd_noexec根据内核配置动态调整内存文件执行权限标志，强制应用noexec安全策略。",
          "similarity": 0.5661303400993347
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memfd.c",
          "start_line": 32,
          "end_line": 194,
          "content": [
            "static bool memfd_folio_has_extra_refs(struct folio *folio)",
            "{",
            "\treturn folio_ref_count(folio) - folio_mapcount(folio) !=",
            "\t       folio_nr_pages(folio);",
            "}",
            "static void memfd_tag_pins(struct xa_state *xas)",
            "{",
            "\tstruct folio *folio;",
            "\tint latency = 0;",
            "",
            "\tlru_add_drain();",
            "",
            "\txas_lock_irq(xas);",
            "\txas_for_each(xas, folio, ULONG_MAX) {",
            "\t\tif (!xa_is_value(folio) && memfd_folio_has_extra_refs(folio))",
            "\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);",
            "",
            "\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\tcontinue;",
            "\t\tlatency = 0;",
            "",
            "\t\txas_pause(xas);",
            "\t\txas_unlock_irq(xas);",
            "\t\tcond_resched();",
            "\t\txas_lock_irq(xas);",
            "\t}",
            "\txas_unlock_irq(xas);",
            "}",
            "static int memfd_wait_for_pins(struct address_space *mapping)",
            "{",
            "\tXA_STATE(xas, &mapping->i_pages, 0);",
            "\tstruct folio *folio;",
            "\tint error, scan;",
            "",
            "\tmemfd_tag_pins(&xas);",
            "",
            "\terror = 0;",
            "\tfor (scan = 0; scan <= LAST_SCAN; scan++) {",
            "\t\tint latency = 0;",
            "",
            "\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))",
            "\t\t\tbreak;",
            "",
            "\t\tif (!scan)",
            "\t\t\tlru_add_drain_all();",
            "\t\telse if (schedule_timeout_killable((HZ << scan) / 200))",
            "\t\t\tscan = LAST_SCAN;",
            "",
            "\t\txas_set(&xas, 0);",
            "\t\txas_lock_irq(&xas);",
            "\t\txas_for_each_marked(&xas, folio, ULONG_MAX, MEMFD_TAG_PINNED) {",
            "\t\t\tbool clear = true;",
            "",
            "\t\t\tif (!xa_is_value(folio) &&",
            "\t\t\t    memfd_folio_has_extra_refs(folio)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * On the last scan, we clean up all those tags",
            "\t\t\t\t * we inserted; but make a note that we still",
            "\t\t\t\t * found folios pinned.",
            "\t\t\t\t */",
            "\t\t\t\tif (scan == LAST_SCAN)",
            "\t\t\t\t\terror = -EBUSY;",
            "\t\t\t\telse",
            "\t\t\t\t\tclear = false;",
            "\t\t\t}",
            "\t\t\tif (clear)",
            "\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);",
            "",
            "\t\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\t\tcontinue;",
            "\t\t\tlatency = 0;",
            "",
            "\t\t\txas_pause(&xas);",
            "\t\t\txas_unlock_irq(&xas);",
            "\t\t\tcond_resched();",
            "\t\t\txas_lock_irq(&xas);",
            "\t\t}",
            "\t\txas_unlock_irq(&xas);",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int memfd_add_seals(struct file *file, unsigned int seals)",
            "{",
            "\tstruct inode *inode = file_inode(file);",
            "\tunsigned int *file_seals;",
            "\tint error;",
            "",
            "\t/*",
            "\t * SEALING",
            "\t * Sealing allows multiple parties to share a tmpfs or hugetlbfs file",
            "\t * but restrict access to a specific subset of file operations. Seals",
            "\t * can only be added, but never removed. This way, mutually untrusted",
            "\t * parties can share common memory regions with a well-defined policy.",
            "\t * A malicious peer can thus never perform unwanted operations on a",
            "\t * shared object.",
            "\t *",
            "\t * Seals are only supported on special tmpfs or hugetlbfs files and",
            "\t * always affect the whole underlying inode. Once a seal is set, it",
            "\t * may prevent some kinds of access to the file. Currently, the",
            "\t * following seals are defined:",
            "\t *   SEAL_SEAL: Prevent further seals from being set on this file",
            "\t *   SEAL_SHRINK: Prevent the file from shrinking",
            "\t *   SEAL_GROW: Prevent the file from growing",
            "\t *   SEAL_WRITE: Prevent write access to the file",
            "\t *   SEAL_EXEC: Prevent modification of the exec bits in the file mode",
            "\t *",
            "\t * As we don't require any trust relationship between two parties, we",
            "\t * must prevent seals from being removed. Therefore, sealing a file",
            "\t * only adds a given set of seals to the file, it never touches",
            "\t * existing seals. Furthermore, the \"setting seals\"-operation can be",
            "\t * sealed itself, which basically prevents any further seal from being",
            "\t * added.",
            "\t *",
            "\t * Semantics of sealing are only defined on volatile files. Only",
            "\t * anonymous tmpfs and hugetlbfs files support sealing. More",
            "\t * importantly, seals are never written to disk. Therefore, there's",
            "\t * no plan to support it on other file types.",
            "\t */",
            "",
            "\tif (!(file->f_mode & FMODE_WRITE))",
            "\t\treturn -EPERM;",
            "\tif (seals & ~(unsigned int)F_ALL_SEALS)",
            "\t\treturn -EINVAL;",
            "",
            "\tinode_lock(inode);",
            "",
            "\tfile_seals = memfd_file_seals_ptr(file);",
            "\tif (!file_seals) {",
            "\t\terror = -EINVAL;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif (*file_seals & F_SEAL_SEAL) {",
            "\t\terror = -EPERM;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {",
            "\t\terror = mapping_deny_writable(file->f_mapping);",
            "\t\tif (error)",
            "\t\t\tgoto unlock;",
            "",
            "\t\terror = memfd_wait_for_pins(file->f_mapping);",
            "\t\tif (error) {",
            "\t\t\tmapping_allow_writable(file->f_mapping);",
            "\t\t\tgoto unlock;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * SEAL_EXEC implys SEAL_WRITE, making W^X from the start.",
            "\t */",
            "\tif (seals & F_SEAL_EXEC && inode->i_mode & 0111)",
            "\t\tseals |= F_SEAL_SHRINK|F_SEAL_GROW|F_SEAL_WRITE|F_SEAL_FUTURE_WRITE;",
            "",
            "\t*file_seals |= seals;",
            "\terror = 0;",
            "",
            "unlock:",
            "\tinode_unlock(inode);",
            "\treturn error;",
            "}"
          ],
          "function_name": "memfd_folio_has_extra_refs, memfd_tag_pins, memfd_wait_for_pins, memfd_add_seals",
          "description": "实现内存文件的页引用追踪与密封逻辑，memfd_tag_pins遍历页表标记额外引用页，memfd_wait_for_pins等待所有引用释放后清除标记，memfd_add_seals处理文件密封标志验证及权限限制设置。",
          "similarity": 0.5616908073425293
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memfd.c",
          "start_line": 1,
          "end_line": 31,
          "content": [
            "/*",
            " * memfd_create system call and file sealing support",
            " *",
            " * Code was originally included in shmem.c, and broken out to facilitate",
            " * use by hugetlbfs as well as tmpfs.",
            " *",
            " * This file is released under the GPL.",
            " */",
            "",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/memfd.h>",
            "#include <linux/pid_namespace.h>",
            "#include <uapi/linux/memfd.h>",
            "",
            "/*",
            " * We need a tag: a new tag would expand every xa_node by 8 bytes,",
            " * so reuse a tag which we firmly believe is never set or cleared on tmpfs",
            " * or hugetlbfs because they are memory only filesystems.",
            " */",
            "#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE",
            "#define LAST_SCAN               4       /* about 150ms max */",
            ""
          ],
          "function_name": null,
          "description": "定义MEMFD_TAG_PINNED宏用于标识内存文件的特殊页缓存标记，通过复用tmpfs和hugetlbfs中未使用的PAGECACHE_TAG_TOWRITE标签，为后续内存文件的页管理提供标记支持。",
          "similarity": 0.4175642728805542
        }
      ]
    },
    {
      "source_file": "kernel/module/strict_rwx.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:07:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\strict_rwx.c`\n\n---\n\n# `module/strict_rwx.c` 技术文档\n\n## 1. 文件概述\n\n`strict_rwx.c` 是 Linux 内核模块子系统中用于实现 **严格 RWX（Read-Write-Execute）内存权限控制** 的核心文件。其主要功能是在模块加载、初始化和运行过程中，对模块不同内存段（如代码段、只读数据段等）施加严格的内存保护策略，确保：\n\n- **可执行段不可写**（W^X 原则）\n- **只读段不可写也不可执行**\n- **数据段不可执行**\n\n该机制通过 `CONFIG_STRICT_MODULE_RWX` 配置选项启用，旨在提升内核模块的安全性，防止代码注入、ROP（Return-Oriented Programming）等攻击。\n\n---\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `module_set_memory()` | 内部辅助函数，对指定类型的模块内存区域应用指定的内存权限设置（如 `set_memory_x`、`set_memory_ro` 等） |\n| `module_enable_x()` | 启用模块文本段（text sections）的可执行权限（`set_memory_x`） |\n| `module_disable_ro()` | **（仅在 `CONFIG_LIVEPATCH_WO_FTRACE` 下）** 临时将只读段设为可写，用于热补丁（livepatch）更新 |\n| `module_enable_ro()` | 将模块的文本段和只读数据段设为只读（`set_memory_ro`），可选择是否包含 `MOD_RO_AFTER_INIT` 段 |\n| `module_enable_nx()` | 对模块的数据段（data sections）应用不可执行（NX）权限（`set_memory_nx`） |\n| `module_enforce_rwx_sections()` | 在模块加载时检查 ELF 节区是否违反 W^X 原则（即同时设置了 `SHF_WRITE` 和 `SHF_EXECINSTR`），若违反则拒绝加载 |\n\n### 关键数据结构/宏\n\n- `enum mod_mem_type`：定义模块内存类型（如 `MOD_TEXT`, `MOD_RODATA`, `MOD_RO_AFTER_INIT` 等）\n- `struct module_memory`：存储每种内存类型的基地址和大小\n- `for_class_mod_mem_type(type, text/data)`：宏，用于遍历指定类别的内存类型（文本类或数据类）\n\n---\n\n## 3. 关键实现\n\n### 3.1 内存权限设置机制\n\n- `module_set_memory()` 封装了通用的内存权限设置逻辑：\n  - 调用 `set_vm_flush_reset_perms()` 重置页表项的权限并刷新 TLB\n  - 调用底层架构相关的 `set_memory_*` 函数（如 `set_memory_ro`）应用新权限\n  - 权限粒度为页（`PAGE_SHIFT`）\n\n### 3.2 W^X 强制执行\n\n- `module_enforce_rwx_sections()` 在模块加载早期（解析 ELF 后）扫描所有节区头：\n  - 若发现同时包含 `SHF_WRITE | SHF_EXECINSTR` 的节区，立即报错并返回 `-ENOEXEC`\n  - 此检查独立于运行时权限设置，是静态安全屏障\n\n### 3.3 权限阶段控制\n\n- 模块加载流程中分阶段应用权限：\n  - **加载时**：数据段设为 NX，文本段设为可执行\n  - **初始化后**：调用 `module_enable_ro(..., true)` 将 `MOD_RO_AFTER_INIT` 段也设为只读\n- 热补丁场景（`CONFIG_LIVEPATCH_WO_FTRACE`）下，可通过 `module_disable_ro()` 临时解除只读保护以修改代码\n\n### 3.4 配置依赖\n\n- 所有运行时权限操作均受 `CONFIG_STRICT_MODULE_RWX` 控制\n- 即使未启用 `STRICT_MODULE_RWX`，`module_enable_x()` 仍会被调用（因其被架构代码依赖）\n\n---\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/module.h>`：模块核心结构定义\n- `<linux/mm.h>`、`<linux/vmalloc.h>`：内存管理接口\n- `<linux/set_memory.h>`：提供 `set_memory_ro/x/nx/rw` 等架构相关函数\n- `\"internal.h\"`：模块子系统内部头文件，定义 `mod_mem_type` 和 `module_memory`\n\n### 架构依赖\n- 依赖底层架构实现的 `set_memory_*` 函数（如 x86、ARM64 等）\n- 依赖 `set_vm_flush_reset_perms()`（定义在 `mm/vmalloc.c`）处理 vmalloc 区域的页表刷新\n\n### 配置选项依赖\n- `CONFIG_STRICT_MODULE_RWX`：主开关\n- `CONFIG_LIVEPATCH_WO_FTRACE`：控制 `module_disable_ro()` 的编译\n- `rodata_enabled`：运行时开关，可在启动参数中关闭（如 `rodata=off`）\n\n---\n\n## 5. 使用场景\n\n1. **模块加载过程**：\n   - 内核在 `load_module()` 中调用 `module_enforce_rwx_sections()` 检查 ELF 节区合法性\n   - 加载完成后调用 `module_enable_nx()` 和 `module_enable_x()` 设置初始权限\n\n2. **模块初始化完成**：\n   - 调用 `module_enable_ro(mod, true)` 将 `__ro_after_init` 段设为只读，防止运行时篡改\n\n3. **内核热补丁（Livepatch）**：\n   - 当使用 `CONFIG_LIVEPATCH_WO_FTRACE` 时，热补丁框架调用 `module_disable_ro()` 临时解除只读保护以写入新指令，补丁应用后再恢复只读\n\n4. **安全加固**：\n   - 防止恶意模块或漏洞利用通过可写+可执行内存执行任意代码\n   - 符合现代操作系统安全最佳实践（如 DEP/NX、W^X）",
      "similarity": 0.5757796168327332,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/strict_rwx.c",
          "start_line": 14,
          "end_line": 85,
          "content": [
            "static void module_set_memory(const struct module *mod, enum mod_mem_type type,",
            "\t\t\t      int (*set_memory)(unsigned long start, int num_pages))",
            "{",
            "\tconst struct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\tset_vm_flush_reset_perms(mod_mem->base);",
            "\tset_memory((unsigned long)mod_mem->base, mod_mem->size >> PAGE_SHIFT);",
            "}",
            "void module_enable_x(const struct module *mod)",
            "{",
            "\tfor_class_mod_mem_type(type, text)",
            "\t\tmodule_set_memory(mod, type, set_memory_x);",
            "}",
            "void module_disable_ro(const struct module *mod)",
            "{",
            "\tif (!IS_ENABLED(CONFIG_STRICT_MODULE_RWX))",
            "\t\treturn;",
            "#ifdef CONFIG_STRICT_MODULE_RWX",
            "\tif (!rodata_enabled)",
            "\t\treturn;",
            "#endif",
            "",
            "\tmodule_set_memory(mod, MOD_TEXT, set_memory_rw);",
            "\tmodule_set_memory(mod, MOD_INIT_TEXT, set_memory_rw);",
            "\tmodule_set_memory(mod, MOD_RODATA, set_memory_rw);",
            "\tmodule_set_memory(mod, MOD_INIT_RODATA, set_memory_rw);",
            "\tmodule_set_memory(mod, MOD_RO_AFTER_INIT, set_memory_rw);",
            "}",
            "void module_enable_ro(const struct module *mod, bool after_init)",
            "{",
            "\tif (!IS_ENABLED(CONFIG_STRICT_MODULE_RWX))",
            "\t\treturn;",
            "#ifdef CONFIG_STRICT_MODULE_RWX",
            "\tif (!rodata_enabled)",
            "\t\treturn;",
            "#endif",
            "",
            "\tmodule_set_memory(mod, MOD_TEXT, set_memory_ro);",
            "\tmodule_set_memory(mod, MOD_INIT_TEXT, set_memory_ro);",
            "\tmodule_set_memory(mod, MOD_RODATA, set_memory_ro);",
            "\tmodule_set_memory(mod, MOD_INIT_RODATA, set_memory_ro);",
            "",
            "\tif (after_init)",
            "\t\tmodule_set_memory(mod, MOD_RO_AFTER_INIT, set_memory_ro);",
            "}",
            "void module_enable_nx(const struct module *mod)",
            "{",
            "\tif (!IS_ENABLED(CONFIG_STRICT_MODULE_RWX))",
            "\t\treturn;",
            "",
            "\tfor_class_mod_mem_type(type, data)",
            "\t\tmodule_set_memory(mod, type, set_memory_nx);",
            "}",
            "int module_enforce_rwx_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,",
            "\t\t\t\tchar *secstrings, struct module *mod)",
            "{",
            "\tconst unsigned long shf_wx = SHF_WRITE | SHF_EXECINSTR;",
            "\tint i;",
            "",
            "\tif (!IS_ENABLED(CONFIG_STRICT_MODULE_RWX))",
            "\t\treturn 0;",
            "",
            "\tfor (i = 0; i < hdr->e_shnum; i++) {",
            "\t\tif ((sechdrs[i].sh_flags & shf_wx) == shf_wx) {",
            "\t\t\tpr_err(\"%s: section %s (index %d) has invalid WRITE|EXEC flags\\n\",",
            "\t\t\t       mod->name, secstrings + sechdrs[i].sh_name, i);",
            "\t\t\treturn -ENOEXEC;",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "module_set_memory, module_enable_x, module_disable_ro, module_enable_ro, module_enable_nx, module_enforce_rwx_sections",
          "description": "实现模块内存权限控制逻辑，包括设置内存属性、启用/禁用只读/不可执行等特性，同时校验ELF节头是否符合WRITE|EXEC组合限制。",
          "similarity": 0.5472538471221924
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/strict_rwx.c",
          "start_line": 1,
          "end_line": 13,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module strict rwx",
            " *",
            " * Copyright (C) 2015 Rusty Russell",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/set_memory.h>",
            "#include \"internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "定义模块严格RWX功能的基础结构，包含必要的头文件并声明内部接口，为后续内存权限管理提供支持。",
          "similarity": 0.5452132821083069
        }
      ]
    },
    {
      "source_file": "kernel/module/signing.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:06:05\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\signing.c`\n\n---\n\n# module/signing.c 技术文档\n\n## 1. 文件概述\n\n`module/signing.c` 是 Linux 内核中用于验证内核模块数字签名的核心实现文件。该文件提供了模块加载过程中对 PKCS#7 格式签名的解析、验证和策略控制功能，确保只有经过合法签名的模块才能被加载到内核中，从而增强系统的安全性和完整性。该机制是内核模块签名（Module Signature）子系统的关键组成部分，支持强制签名（`CONFIG_MODULE_SIG_FORCE`）和运行时策略控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`is_module_sig_enforced(void)`**  \n  返回当前是否强制要求模块必须具有有效签名。该函数导出为符号，供其他内核子系统使用。\n\n- **`set_module_sig_enforced(void)`**  \n  在运行时将模块签名强制策略设置为启用状态（`true`），通常由安全机制（如 Lockdown）调用。\n\n- **`mod_verify_sig(const void *mod, struct load_info *info)`**  \n  执行模块签名的实际验证逻辑：解析模块末尾的 `module_signature` 结构，提取签名数据，并调用通用 PKCS#7 验证接口进行验证。\n\n- **`module_sig_check(struct load_info *info, int flags)`**  \n  模块加载流程中的主入口函数，负责检测模块是否包含签名标记（`~Module signature appended~\\n`），决定是否调用 `mod_verify_sig`，并根据验证结果和系统策略决定是否允许加载。\n\n### 关键数据结构与变量\n\n- **`sig_enforce`**  \n  全局布尔变量，表示是否强制执行模块签名验证。初始值由 `CONFIG_MODULE_SIG_FORCE` 决定，可通过内核命令行参数 `module.sig_enforce=1` 或运行时调用 `set_module_sig_enforced()` 修改。\n\n- **`module_signature`**  \n  定义在 `<linux/module_signature.h>` 中的结构体，位于模块二进制末尾，包含签名元数据（如签名长度、哈希算法、密钥标识等）。\n\n- **`MODULE_SIG_STRING`**  \n  签名结束标记字符串 `\"~Module signature appended~\\n\"`，用于识别模块是否包含签名。\n\n## 3. 关键实现\n\n### 签名验证流程\n\n1. **签名检测**：  \n   `module_sig_check` 检查模块末尾是否存在 `MODULE_SIG_STRING` 标记。若存在，则认为模块包含签名。\n\n2. **签名解析**：  \n   `mod_verify_sig` 从模块末尾读取 `struct module_signature`，调用 `mod_check_sig()` 验证其格式合法性。\n\n3. **数据截断**：  \n   从模块总长度中扣除签名数据和签名结构体的长度，得到实际代码/数据部分的长度（`info->len` 更新为此值）。\n\n4. **PKCS#7 验证**：  \n   调用 `verify_pkcs7_signature()`，使用内核的 `VERIFY_USE_SECONDARY_KEYRING`（通常为 `.module_signing` 密钥环）验证模块主体的完整性与签名有效性。\n\n### 安全策略处理\n\n- **强制模式（`sig_enforce == true`）**：  \n  任何未签名、密钥不可用或加密算法不支持的模块均被拒绝加载，返回 `-EKEYREJECTED`。\n\n- **非强制模式**：  \n  允许加载未签名模块，但会检查系统是否处于 Lockdown 模式（通过 `security_locked_down(LOCKDOWN_MODULE_SIGNATURE)`）。若处于 Lockdown，则仍拒绝加载。\n\n- **模块篡改防护**：  \n  若加载标志包含 `MODULE_INIT_IGNORE_MODVERSIONS` 或 `MODULE_INIT_IGNORE_VERMAGIC`（即忽略版本魔数或模块版本），则视为“被篡改”的模块，即使有签名也不予验证，防止绕过签名保护。\n\n### 错误分类\n\n- **非致命错误**（仅在非强制模式下可忽略）：\n  - `-ENODATA`：模块未签名\n  - `-ENOPKG`：使用了内核不支持的加密算法\n  - `-ENOKEY`：签名所用公钥不在信任密钥环中\n\n- **致命错误**（无论是否强制均拒绝）：\n  - 内存分配失败、签名格式错误、哈希不匹配等\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/verification.h>`：提供 `verify_pkcs7_signature()` 接口\n  - `<crypto/public_key.h>`：PKCS#7 验证所需的密码学支持\n  - `<linux/module_signature.h>`：定义 `module_signature` 结构\n  - `\"internal.h\"`：模块子系统内部头文件\n\n- **内核配置依赖**：\n  - `CONFIG_MODULE_SIG`：启用模块签名功能\n  - `CONFIG_MODULE_SIG_FORCE`：决定 `sig_enforce` 的默认值\n  - `CONFIG_SECURITY_LOCKDOWN_LSM`：提供 `security_locked_down()` 支持\n\n- **密钥管理依赖**：  \n  依赖内核密钥环服务（Key Retention Service），特别是 `.module_signing` 二级密钥环存储用于验证模块的公钥。\n\n## 5. 使用场景\n\n- **模块加载流程**：  \n  在 `load_module()` 函数中，内核调用 `module_sig_check()` 对待加载模块进行签名验证，是模块安全加载的关键环节。\n\n- **安全启动（Secure Boot）环境**：  \n  当系统启用 UEFI Secure Boot 时，通常会强制启用模块签名（`sig_enforce = true`），确保所有内核模块均来自可信源。\n\n- **内核 Lockdown 模式**：  \n  在 Lockdown 的 `integrity` 或 `confidentiality` 级别下，即使未设置 `CONFIG_MODULE_SIG_FORCE`，也会通过 `security_locked_down()` 阻止未签名模块加载。\n\n- **动态策略调整**：  \n  安全模块（如 Lockdown LSM）可在运行时调用 `set_module_sig_enforced()` 动态提升安全策略，禁止后续未签名模块加载。",
      "similarity": 0.5721541047096252,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/signing.c",
          "start_line": 29,
          "end_line": 118,
          "content": [
            "bool is_module_sig_enforced(void)",
            "{",
            "\treturn sig_enforce;",
            "}",
            "void set_module_sig_enforced(void)",
            "{",
            "\tsig_enforce = true;",
            "}",
            "int mod_verify_sig(const void *mod, struct load_info *info)",
            "{",
            "\tstruct module_signature ms;",
            "\tsize_t sig_len, modlen = info->len;",
            "\tint ret;",
            "",
            "\tpr_devel(\"==>%s(,%zu)\\n\", __func__, modlen);",
            "",
            "\tif (modlen <= sizeof(ms))",
            "\t\treturn -EBADMSG;",
            "",
            "\tmemcpy(&ms, mod + (modlen - sizeof(ms)), sizeof(ms));",
            "",
            "\tret = mod_check_sig(&ms, modlen, \"module\");",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tsig_len = be32_to_cpu(ms.sig_len);",
            "\tmodlen -= sig_len + sizeof(ms);",
            "\tinfo->len = modlen;",
            "",
            "\treturn verify_pkcs7_signature(mod, modlen, mod + modlen, sig_len,",
            "\t\t\t\t      VERIFY_USE_SECONDARY_KEYRING,",
            "\t\t\t\t      VERIFYING_MODULE_SIGNATURE,",
            "\t\t\t\t      NULL, NULL);",
            "}",
            "int module_sig_check(struct load_info *info, int flags)",
            "{",
            "\tint err = -ENODATA;",
            "\tconst unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;",
            "\tconst char *reason;",
            "\tconst void *mod = info->hdr;",
            "\tbool mangled_module = flags & (MODULE_INIT_IGNORE_MODVERSIONS |",
            "\t\t\t\t       MODULE_INIT_IGNORE_VERMAGIC);",
            "\t/*",
            "\t * Do not allow mangled modules as a module with version information",
            "\t * removed is no longer the module that was signed.",
            "\t */",
            "\tif (!mangled_module &&",
            "\t    info->len > markerlen &&",
            "\t    memcmp(mod + info->len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {",
            "\t\t/* We truncate the module to discard the signature */",
            "\t\tinfo->len -= markerlen;",
            "\t\terr = mod_verify_sig(mod, info);",
            "\t\tif (!err) {",
            "\t\t\tinfo->sig_ok = true;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * We don't permit modules to be loaded into the trusted kernels",
            "\t * without a valid signature on them, but if we're not enforcing,",
            "\t * certain errors are non-fatal.",
            "\t */",
            "\tswitch (err) {",
            "\tcase -ENODATA:",
            "\t\treason = \"unsigned module\";",
            "\t\tbreak;",
            "\tcase -ENOPKG:",
            "\t\treason = \"module with unsupported crypto\";",
            "\t\tbreak;",
            "\tcase -ENOKEY:",
            "\t\treason = \"module with unavailable key\";",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\t/*",
            "\t\t * All other errors are fatal, including lack of memory,",
            "\t\t * unparseable signatures, and signature check failures --",
            "\t\t * even if signatures aren't required.",
            "\t\t */",
            "\t\treturn err;",
            "\t}",
            "",
            "\tif (is_module_sig_enforced()) {",
            "\t\tpr_notice(\"Loading of %s is rejected\\n\", reason);",
            "\t\treturn -EKEYREJECTED;",
            "\t}",
            "",
            "\treturn security_locked_down(LOCKDOWN_MODULE_SIGNATURE);",
            "}"
          ],
          "function_name": "is_module_sig_enforced, set_module_sig_enforced, mod_verify_sig, module_sig_check",
          "description": "实现模块签名验证核心逻辑，包含签名状态查询接口、签名验证执行函数以及综合检查入口，通过标记比对与证书验证完成模块签名有效性校验",
          "similarity": 0.5000132322311401
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/signing.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* Module signature checker",
            " *",
            " * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/string.h>",
            "#include <linux/verification.h>",
            "#include <linux/security.h>",
            "#include <crypto/public_key.h>",
            "#include <uapi/linux/module.h>",
            "#include \"internal.h\"",
            "",
            "#undef MODULE_PARAM_PREFIX",
            "#define MODULE_PARAM_PREFIX \"module.\"",
            "",
            "static bool sig_enforce = IS_ENABLED(CONFIG_MODULE_SIG_FORCE);",
            "module_param(sig_enforce, bool_enable_only, 0644);",
            "",
            "/*",
            " * Export sig_enforce kernel cmdline parameter to allow other subsystems rely",
            " * on that instead of directly to CONFIG_MODULE_SIG_FORCE config.",
            " */"
          ],
          "function_name": null,
          "description": "定义sig_enforce全局变量用于控制模块签名强制检查标志位，并注册模块参数供外部配置",
          "similarity": 0.46162140369415283
        }
      ]
    }
  ]
}